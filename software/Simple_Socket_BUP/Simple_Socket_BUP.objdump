
Simple_Socket_BUP.elf:     file format elf32-littlenios2
Simple_Socket_BUP.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08200200

Program Header:
    LOAD off    0x00001000 vaddr 0x04a80000 paddr 0x04a80000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001060 vaddr 0x08200060 paddr 0x08200060 align 2**12
         filesz 0x000539b0 memsz 0x0005e460 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  04a80000  04a80000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  08200060  08200060  00001060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004b7d0  08200200  08200200  00001200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005f54  0824b9d0  0824b9d0  0004c9d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020ec  08251924  08251924  00052924  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000aab0  08253a10  08253a10  00054a10  2**2
                  ALLOC, SMALL_DATA
  6 .ext_flash    00000000  04a80020  04a80020  00054a10  2**0
                  CONTENTS
  7 .descriptor_memory 00000000  08000000  08000000  00054a10  2**0
                  CONTENTS
  8 .onchip_ram   00000000  0825e4c0  0825e4c0  00054a10  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00054a10  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001d18  00000000  00000000  00054a38  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00066fe4  00000000  00000000  00056750  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00015607  00000000  00000000  000bd734  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001da5a  00000000  00000000  000d2d3b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00008908  00000000  00000000  000f0798  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000bab0  00000000  00000000  000f90a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001ef9a  00000000  00000000  00104b50  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  00123aec  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001e98  00000000  00000000  00123b40  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000006  00000000  00000000  001301ca  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  001301d0  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  001301d3  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  001301d4  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  001301d5  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  001301d9  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  001301dd  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  001301e1  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  001301ec  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  001301f7  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 0000001a  00000000  00000000  00130202  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000001a  00000000  00000000  0013021c  2**0
                  CONTENTS, READONLY
 31 .jdi          00006ef3  00000000  00000000  00130236  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     000bd54f  00000000  00000000  00137129  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04a80000 l    d  .entry	00000000 .entry
08200060 l    d  .exceptions	00000000 .exceptions
08200200 l    d  .text	00000000 .text
0824b9d0 l    d  .rodata	00000000 .rodata
08251924 l    d  .rwdata	00000000 .rwdata
08253a10 l    d  .bss	00000000 .bss
04a80020 l    d  .ext_flash	00000000 .ext_flash
08000000 l    d  .descriptor_memory	00000000 .descriptor_memory
0825e4c0 l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simple_Socket_BUP_bsp//obj/HAL/src/crt0.o
08200244 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
082000d4 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
08253a1c l     O .bss	00000004 SSSCommand.4950
08253c2c l     O .bss	000005f0 conn.4979
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 ctype_.c
0824ccb7 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
08251a5c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strstr.c
08203af4 l     F .text	00000104 critical_factorization
08203bf8 l     F .text	000003b0 two_way_long_needle
00000000 l    df *ABS*	00000000 vfprintf.c
0824d586 l     O .rodata	00000010 zeroes.4389
0824d596 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824d5a6 l     O .rodata	00000010 zeroes.4404
0820874c l     F .text	000000bc __sbprintf
0824d5b6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
08208ab4 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0820a5e4 l     F .text	00000008 __fp_unlock
0820a5f8 l     F .text	0000019c __sinit.part.1
0820a794 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
08251ea0 l     O .rwdata	00000020 lc_ctype_charset
08251e80 l     O .rwdata	00000020 lc_message_charset
08251ec0 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 mprec.c
0824d5e4 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0820d6b4 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824d718 l     O .rodata	00000010 blanks.4332
0824d708 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 vfprintf.c
0820ef90 l     F .text	000000fc __sprint_r.part.0
0824d738 l     O .rodata	00000010 blanks.4348
0824d728 l     O .rodata	00000010 zeroes.4349
0821051c l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
08213f88 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
08214074 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
08214154 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
082538dc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_env_lock.c
082538e0 l     O .rwdata	00000004 lockid
08253a54 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
082538e4 l     O .rwdata	00000004 lockid
08253a5c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
08215e04 l     F .text	00000048 OS_InitMisc
08215e4c l     F .text	0000006c OS_InitRdyList
08215fb8 l     F .text	000000e4 OS_InitTCBList
08215d24 l     F .text	000000e0 OS_InitEventList
08215eb8 l     F .text	00000080 OS_InitTaskIdle
08215f38 l     F .text	00000080 OS_InitTaskStat
08216228 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
08217f50 l     F .text	000000f4 OS_FlagTaskRdy
08217d10 l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0821c000 l     F .text	00000034 alt_dev_reg
08252300 l     O .rwdata	0000106c jtag_uart_0
0825336c l     O .rwdata	00000124 lcd
08253490 l     O .rwdata	00000030 sgdma_rx
082534c0 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0821c550 l     F .text	000002a4 altera_avalon_jtag_uart_irq
0821c7f4 l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
08253960 l     O .rwdata	00000004 colstart
0821cfd0 l     F .text	000000b8 lcd_write_command
0821d088 l     F .text	000000d8 lcd_write_data
0821d160 l     F .text	000000d0 lcd_clear_screen
0821d230 l     F .text	000001ec lcd_repaint_screen
0821d41c l     F .text	000000cc lcd_scroll_up
0821d4e8 l     F .text	000002ac lcd_handle_escape
0821dca4 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0821df30 l     F .text	0000003c alt_get_errno
0821eb60 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0821ecc4 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
08253ab6 l     O .bss	00000001 tse_system_count.4813
08253ab7 l     O .bss	00000001 is_init.4895
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
08254244 l     O .bss	0000003c closers
08253acc l     O .bss	00000004 nclosers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
0825397c l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
08254280 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0822b628 l     F .text	000000ac dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
00000000 l    df *ABS*	00000000 asm_cksum.o
0822d1c4 l       .text	00000000 done
0822d054 l       .text	00000000 asm1
0822d180 l       .text	00000000 loop0
0822d07c l       .text	00000000 loop
0822d19c l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
08253b38 l     O .bss	00000004 kbd_init.4233
08253b34 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
08253b6c l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
08231544 l     F .text	0000008c sockargs
08230868 l     F .text	000001dc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
08239038 l     F .text	000000c8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
0823b98c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
0823bb10 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0823bb3c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0823c00c l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0823c14c l     F .text	0000003c alt_get_errno
0823c188 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
0823c3a0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_free.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_write.c
0823c7b0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 allports.c
08253ba4 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0823d0ec l     F .text	0000018c check_interval_timers
08253bb0 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
08253bb4 l     O .bss	00000004 arp_timer
08253bbc l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
082539f8 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
08253bfc l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
08253a00 l     O .rwdata	00000004 iCounter.4951
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
08254298 l     O .bss	0000001e nearBuf.4578
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
08249c1c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
082538a0 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintfr_1.c
00000000 l    df *ABS*	00000000 alt_exit.c
08203048 g     F .text	00000018 putchar
0825dfbc g     O .bss	00000014 soq
0820cfd8 g     F .text	00000074 _mprec_log10
08220030 g     F .text	000000d8 alt_tse_get_mac_info
08253932 g     O .rwdata	00000002 OSTaskNameSize
0820d0c4 g     F .text	0000008c __any_on
08210ab8 g     F .text	00000054 _isatty_r
0824d5f0 g     O .rodata	00000028 __mprec_tinytens
0823ee7c g     F .text	00000724 ip_write_internal
08214264 g     F .text	000000bc alt_main
0824b1b4 g     F .text	00000090 strcpy
0822c970 g     F .text	000000ac pk_free
08203060 g     F .text	000000c0 _puts_r
0825e168 g     O .bss	00000100 alt_irq
08253740 g     O .rwdata	00000009 rtp_priority
08210b0c g     F .text	00000060 _lseek_r
0824adc0 g     F .text	00000314 icmp_timex
0822e26c g     F .text	00000044 m_freem
08249724 g     F .text	00000048 vgetc
0822d324 g     F .text	00000020 clock_c
08253b84 g     O .bss	00000004 tcp_optionbuf
0823e99c g     F .text	00000070 if_getbynum
08218770 g     F .text	000000cc OS_MemInit
08253b24 g     O .bss	00000004 dsc_rlyerrs
08253b14 g     O .bss	00000004 dsc_releases
082293d4 g     F .text	0000006c TK_OSTaskQuery
0822d034 g       .text	00000000 asm_cksum
08223c40 g     F .text	000000f0 marvell_cfg_rgmii
0821bfa0 g     F .text	00000060 OSTimeSet
0824962c g     F .text	000000f8 vgetc_locked
0822db5c g     F .text	00000020 post_task_setup
082424dc g     F .text	00000358 ipr_stats
0823a860 g     F .text	00000118 tcp_attach
0825398c g     O .rwdata	00000004 reqlist_len
0822f62c g     F .text	00000078 tcp_tick
08228628 g     F .text	0000007c print_ipad
082292dc g     F .text	000000f8 tcp_wakeup
082129f8 g     F .text	00000088 .hidden __eqdf2
08253a14 g     O .bss	00000004 last_flash_sector_offset
08253ad0 g     O .bss	00000004 igmp_timers_are_running
08200d98 g     F .text	000000e4 led_bit_toggle
08237a6c g     F .text	0000012c tcp_pulloutofband
0822122c g     F .text	00000210 alt_tse_phy_print_profile
08214a78 g     F .text	00000610 OSEventPendMulti
0825e4c0 g       *ABS*	00000000 __alt_heap_start
0823cb34 g     F .text	00000024 OSTaskCreateHook
0822c1ac g     F .text	00000068 dhc_ifacedone
082239e0 g     F .text	00000098 marvell_phy_cfg
08242884 g     F .text	00000380 ip_rcv
082493d0 g     F .text	0000014c vfseek
08233c18 g     F .text	00000108 soqremque
08244458 g     F .text	000007a8 udpdemux
08225368 g     F .text	00000104 tse_mac_close
08202e9c g     F .text	0000003c printf
08253bd0 g     O .bss	00000004 rt_mib
0825390a g     O .rwdata	00000002 OSMboxEn
0822c0cc g     F .text	00000058 dhc_state_init
0824b6d0 g     F .text	0000001c vsprintf
0821e090 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
082150e0 g     F .text	0000004c OSIntEnter
08210bcc g     F .text	0000009c _wcrtomb_r
0820da44 g     F .text	0000005c __sseek
0820a934 g     F .text	00000010 __sinit
082436f0 g     F .text	0000010c in_delmulti
08208808 g     F .text	00000140 __swbuf_r
08253be8 g     O .bss	00000004 so_evtmap_create
0825391a g     O .rwdata	00000002 OSQEn
08247a8c g     F .text	00000088 in_pcballoc
082539a8 g     O .rwdata	00000002 socket_defaults
0820b550 g     F .text	0000007c _setlocale_r
0823d878 g     F .text	00000454 send_arp
0820a79c g     F .text	00000068 __sfmoreglue
082484e8 g     F .text	00000338 vfopen_locked
08253a20 g     O .bss	00000004 SSSLEDCommandQ
0821474c g     F .text	000000cc __malloc_unlock
0823cb9c g     F .text	00000020 OSTaskStatHook
0823d00c g     F .text	00000054 prep_modules
08227c28 g     F .text	0000013c bsd_i_sockoptlen
08253a64 g     O .bss	00000001 OSLockNesting
08253984 g     O .rwdata	00000004 xids
08203a40 g     F .text	0000001c strerror
08220274 g     F .text	00000a88 getPHYSpeed
08248a2c g     F .text	00000044 vfclose
0825e05c g     O .bss	0000002c tcb
08253958 g     O .rwdata	00000002 OSDataSize
0823c53c g     F .text	00000034 alt_remap_cached
08253a65 g     O .bss	00000001 OSRunning
0823e6e4 g     F .text	000002b8 grat_arp
08201118 g     F .text	0000005c get_ip_addr
08247514 g     F .text	00000094 inet_pton
0823eae0 g     F .text	00000090 reg_type
0825db60 g     O .bss	000000f0 dhc_states
08226aa4 g     F .text	00000174 igmp_fasttimo
08248bd8 g     F .text	0000005c vunlink_flag_open_files
0822be94 g     F .text	00000080 dhc_halt
0821e7a8 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
08253b08 g     O .bss	00000004 dsc_acks
0825e088 g     O .bss	000000e0 tcpstat
08241dd4 g     F .text	0000034c ip_reasm_copy_queued_fragments_into_reassy_buffer
0822e7b8 g     F .text	0000009c dtom
08238f38 g     F .text	00000100 tcp_setpersist
08230c04 g     F .text	0000018c t_getsockopt
08202b54 g     F .text	0000015c memmove
08253b18 g     O .bss	00000004 dsc_naks
0822ec08 g     F .text	000005b0 ip_output
0823cbe8 g     F .text	00000020 OSInitHookBegin
0824b0d4 g     F .text	00000054 icmp_du
08253980 g     O .rwdata	00000004 num_net_tasks
08253c0c g     O .bss	00000004 vfiles
08253950 g     O .rwdata	00000002 OSTmrSize
08246ca4 g     F .text	00000114 dhc_main_ipset
0820a91c g     F .text	00000018 _cleanup
08240fa8 g     F .text	000002b8 ip_reasm_process_first_fragment
0820c154 g     F .text	000000a8 _Balloc
08201614 g     F .text	00000198 get_board_mac_addr
08253a68 g     O .bss	00000004 OSIdleCtr
08253a24 g     O .bss	00000004 SSSLEDLightshowSem
08222c40 g     F .text	000001c4 alt_tse_phy_set_adv_1000
0825396c g     O .rwdata	00000001 max_mac_system
08245c00 g     F .text	000005c8 ip_setmoptions
0821f2e4 g     F .text	000009fc alt_tse_system_add_sys
08212a80 g     F .text	000000dc .hidden __gtdf2
08247030 g     F .text	0000002c md_fseek
0823c9b4 g       .text	00000000 OSStartTsk
08216570 g     F .text	000002d4 OS_TCBInit
08241260 g     F .text	00000088 ip_reassm
0822bf14 g     F .text	000001b8 dhc_reclaim
0825e448 g     O .bss	00000010 udp_mib
04a80000 g     F .entry	00000000 __reset
082313a8 g     F .text	000000d8 t_shutdown
08202270 g     F .text	000001f0 sss_handle_receive
08230e70 g     F .text	00000140 t_recvfrom
08253956 g     O .rwdata	00000002 OSTmrWheelTblSize
0824638c g     F .text	000006b4 u_mctest_run
0821e2f8 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
08243860 g     F .text	00000080 prep_ifaces
08253aec g     O .bss	00000001 to_netmain
0822c620 g     F .text	000000c4 pk_alloc
082538f6 g     O .rwdata	00000002 OSEventSize
08200a10 g     F .text	00000298 alt_SSSErrorHandler
08253a6c g     O .bss	00000001 OSPrioHighRdy
08210a5c g     F .text	0000005c _fstat_r
0825193c g     O .rwdata	00000120 tse_mac_device
0822907c g     F .text	00000048 tk_nettick
0823cb58 g     F .text	00000024 OSTaskDelHook
08253a44 g     O .bss	00000004 errno
082031a8 g     F .text	00000014 __srget
08234e1c g     F .text	000000c4 in_pcbnotify
0820d9c0 g     F .text	00000008 __seofread
0823c994 g       .text	00000000 OSStartHighRdy
0825dc50 g     O .bss	00000014 lilfreeq
08200248 g     F .text	00000564 alt_uCOSIIErrorHandler
08243908 g     F .text	0000002c evtmap_setup
0821aa3c g     F .text	000001e4 OSTaskCreateExt
08253af0 g     O .bss	00000004 tcp_sleep_timeout
082345e0 g     F .text	000001b8 sbdrop
08253be4 g     O .bss	00000004 net_system_exit
0825e458 g     O .bss	00000068 icmp_mib
0820dd54 g     F .text	0000123c ___svfiprintf_internal_r
082399c8 g     F .text	00000074 tcp_getseq
08243cec g     F .text	000000b8 ip_raw_alloc
08223528 g     F .text	000004b8 alt_tse_phy_set_common_speed
08217858 g     F .text	00000060 OSFlagPendGetFlagsRdy
08253936 g     O .rwdata	00000002 OSTaskStatStkSize
0825d634 g     O .bss	00000010 pmac_groups
0822a73c g     F .text	00000a84 dhc_request
08232498 g     F .text	0000074c soreceive
082169d4 g     F .text	00000308 OSFlagAccept
08218da8 g     F .text	000000b8 OSQFlush
0821883c g     F .text	00000140 OSQAccept
08253a4c g     O .bss	00000004 alt_argv
0825b8b8 g       *ABS*	00000000 _gp
08242834 g     F .text	00000050 ip_reasm_send_icmp_timex
082143d0 g     F .text	00000138 usleep
08248a70 g     F .text	00000048 vfflush
0825df64 g     O .bss	00000040 resid_semaphore
082284e4 g     F .text	00000144 hexdump
08240e70 g     F .text	000000a0 ip_reasm_incr_mem_useage
08227108 g     F .text	00000080 igmp_leavegroup
0821a890 g     F .text	000001ac OSTaskCreate
0821a3a0 g     F .text	000004f0 OSTaskChangePrio
08253a60 g     O .bss	00000004 alt_heapsem
08239814 g     F .text	000000f0 tcp_close
08216844 g     F .text	00000190 OSDebugInit
0821ac20 g     F .text	00000344 OSTaskDel
08249b44 g     F .text	0000005c vferror
0823c758 g     F .text	00000058 alt_uncached_malloc
0821ede8 g     F .text	00000060 tse_mac_initTransInfo2
0824503c g     F .text	000000bc udp_alloc
082535a8 g     O .rwdata	00000180 alt_fd_list
0825a330 g     O .bss	00000370 OSFlagTbl
08253b70 g     O .bss	00000008 mbstat
08202914 g     F .text	00000070 _getc_r
08202984 g     F .text	00000088 getc
08203040 g     F .text	00000008 _putchar_r
08215b04 g     F .text	000000b8 OS_EventTaskRemove
08245848 g     F .text	00000144 igmpv2_chk_set_timer
082290c4 g     F .text	00000030 TK_OSTimeDly
0823bcdc g     F .text	00000090 alt_find_dev
08202a0c g     F .text	00000148 memcpy
0821f05c g     F .text	00000054 tse_mac_setMIImode
08253b20 g     O .bss	00000004 dsc_rebind
0823d498 g     F .text	0000007c task_stats
08230014 g     F .text	00000050 DOMAIN_CHECK
0822f1b8 g     F .text	00000038 in_broadcast
08253920 g     O .rwdata	00000002 OSRdyTblSize
08220cfc g     F .text	00000048 alt_tse_phy_rd_mdio_addr
08253c08 g     O .bss	00000004 vfsystems
08244f8c g     F .text	000000b0 udp_socket
08253ac0 g     O .bss	00000004 MaxMtu
08234af8 g     F .text	00000140 sock_selscan
0820a5ec g     F .text	0000000c _cleanup_r
08213ce4 g     F .text	000000dc .hidden __floatsidf
08240c48 g     F .text	000000c4 ip_reasm_match_frag_with_ire
08233d78 g     F .text	00000058 socantrcvmore
0821ee48 g     F .text	000000e4 tse_mac_sTxWrite
08201da0 g     F .text	000004d0 sss_exec_command
08202e58 g     F .text	00000014 perror
0823c0d0 g     F .text	0000007c alt_io_redirect
08212b5c g     F .text	000000f4 .hidden __ltdf2
08253b4c g     O .bss	00000004 netq_intmask
082474c8 g     F .text	0000004c hextoa
0824b9d0 g       *ABS*	00000000 __DTOR_END__
082311a4 g     F .text	00000204 t_send
0823b9c8 g     F .text	000000d0 alt_close
08253b78 g     O .bss	00000002 select_wait
08203120 g     F .text	00000014 puts
08228c04 g     F .text	00000044 std_out
0825d654 g     O .bss	00000030 tse_iniche_dev_driver_data
0824976c g     F .text	00000124 vfslookup_locked
08231d58 g     F .text	00000098 soaccept
08214818 g     F .text	00000120 OSEventNameGet
08253904 g     O .rwdata	00000002 OSFlagMax
082033e4 g     F .text	0000065c _strerror_r
0825dfd0 g     O .bss	0000003c tcpmib
082315d0 g     F .text	00000098 t_errno
08243934 g     F .text	000000d8 ip_raw_open
0820d8a4 g     F .text	00000074 __fpclassifyd
0822b520 g     F .text	00000108 dhc_decline
0820cf34 g     F .text	000000a4 __ratio
0821512c g     F .text	000000f8 OSIntExit
082539fc g     O .rwdata	00000004 ipRoutes
08248b88 g     F .text	00000050 vfeof
08210500 g     F .text	0000001c __vfiprintf_internal
08239cac g     F .text	00000060 tcp_canceltimers
08229fa8 g     F .text	000001e4 dhc_buildheader
0825393e g     O .rwdata	00000002 OSTCBSize
0821e3f0 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
08253a6d g     O .bss	00000001 OSPrioCur
0821ca50 g     F .text	000002bc altera_avalon_jtag_uart_read
0824b18c g     F .text	00000014 malloc
08253c04 g     O .bss	00000004 inpcb_cachemiss
08202e6c g     F .text	00000030 _printf_r
08247688 g     F .text	000000c4 inet46_addr
08253c00 g     O .bss	00000004 inpcb_cachehits
0820270c g     F .text	00000064 .hidden __udivsi3
08253568 g     O .rwdata	0000000b tcp_outflags
0825d684 g     O .bss	00000130 tse
082140b0 g     F .text	000000a4 isatty
0821fce0 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
08253924 g     O .rwdata	00000002 OSStkWidth
0824d640 g     O .rodata	000000c8 __mprec_tens
08248360 g     F .text	00000070 vf_alloc_and_link_vop
08253918 g     O .rwdata	00000002 OSPtrSize
08253bd4 g     O .bss	00000004 ipr_curr_mem
0822675c g     F .text	00000070 exit_hook
08253ad4 g     O .bss	00000004 igmp_cticks
0821ffb0 g     F .text	00000080 alt_tse_get_mac_info_index
08253b60 g     O .bss	00000004 mheap_sem_ptr
08237df4 g     F .text	00000048 ip4_tcpmss
0820b5cc g     F .text	0000000c __locale_charset
082538f8 g     O .rwdata	00000002 OSEventTblSize
0825e3cc g     O .bss	00000014 netlist
08232be4 g     F .text	00000098 soshutdown
0823c908 g       .text	00000000 OSCtxSw
0823cf98 g     F .text	00000050 packet_check
0822b1c0 g     F .text	0000027c dhc_setip
0825e00c g     O .bss	00000014 mbufq
08231d08 g     F .text	00000050 soabort
08253a40 g     O .bss	00000004 __malloc_top_pad
08253a70 g     O .bss	00000004 OSTCBList
0822cc60 g     F .text	00000100 qdel
0823cdf4 g     F .text	00000164 station_state
08243e30 g     F .text	00000154 rt_lookup
08253b90 g     O .bss	00000004 alt_fd_list_lock
082538c4 g     O .rwdata	00000004 __mb_cur_max
08227188 g     F .text	00000318 igmp_validate
0820b5fc g     F .text	0000000c _localeconv_r
082264b8 g     F .text	000002a4 ip_startup
08230320 g     F .text	00000254 t_accept
08233810 g     F .text	00000098 soisdisconnecting
0820c560 g     F .text	0000003c __i2b
0820af0c g     F .text	000004bc __sfvwrite_r
0821e528 g     F .text	0000005c alt_avalon_sgdma_stop
08225ef8 g     F .text	000003a4 pktdemux
0825a6a0 g     O .bss	00000c30 OSMemTbl
08253a74 g     O .bss	00000001 OSTickStepState
08220d9c g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0822d1fc g     F .text	00000094 kbhit
08230a44 g     F .text	000001c0 t_setsockopt
0820d918 g     F .text	00000054 _sbrk_r
08253728 g     O .rwdata	00000018 icmpdu_types
0822143c g     F .text	000006a4 alt_tse_mac_group_init
08248c34 g     F .text	00000200 vunlink
08224138 g     F .text	00000a60 tse_mac_init
0825391c g     O .rwdata	00000002 OSQMax
08228344 g     F .text	000000a4 ccksum
082483d0 g     F .text	000000c8 vf_alloc_buffer
08253bf8 g     O .bss	00000004 cachedRoute
08253990 g     O .rwdata	00000004 lilbufs
0825b2d0 g     O .bss	00000800 OSTaskStatStk
0824705c g     F .text	00000024 md_ftell
082283e8 g     F .text	00000054 cksum
082183ac g     F .text	000000f0 OSMemNameGet
0823193c g     F .text	00000110 sofree
08253ac8 g     O .bss	00000004 ifNumber
082538fc g     O .rwdata	00000002 OSFlagEn
08210b6c g     F .text	00000060 _read_r
08253942 g     O .rwdata	00000002 OSTimeTickHookEn
0823ba98 g     F .text	00000078 alt_dcache_flush
08219258 g     F .text	00000168 OSQPost
08218044 g     F .text	000000a4 OS_FlagUnlink
082539d0 g     O .rwdata	00000004 alt_max_fd
082160f0 g     F .text	00000068 OS_MemCopy
08253998 g     O .rwdata	00000004 bigbufs
0823a978 g     F .text	000000cc tcp_disconnect
08216158 g     F .text	000000d0 OS_Sched
08210750 g     F .text	000000f0 _fclose_r
082182bc g     F .text	000000f0 OSMemGet
0821b24c g     F .text	000001b4 OSTaskNameSet
0820a5b4 g     F .text	00000030 fflush
08253a3c g     O .bss	00000004 __malloc_max_sbrked_mem
08253a78 g     O .bss	00000004 OSCtxSwCtr
0825dad8 g     O .bss	00000064 igmpstats
0823cbbc g     F .text	0000002c OSTimeTickHook
0822a658 g     F .text	000000e4 dhc_rx_offer
08227d64 g     F .text	0000010c bsd_getsockopt
08253906 g     O .rwdata	00000002 OSFlagNameSize
0825e430 g     O .bss	00000018 ire_stats
08200ef0 g     F .text	000001d4 LEDManagementTask
0823abb0 g     F .text	000001a0 udp_soinput
0822cbb0 g     F .text	000000b0 putq
08215bbc g     F .text	00000100 OS_EventTaskRemoveMulti
08253ae8 g     O .bss	00000004 iniche_net_ready
08211864 g     F .text	000008ac .hidden __adddf3
082159b4 g     F .text	00000150 OS_EventTaskWaitMulti
08249afc g     F .text	00000048 isvfile
08232d78 g     F .text	00000430 sosetopt
08228f24 g     F .text	000000e0 netmain
08237e3c g     F .text	000000f8 tcp_mss
0820ccdc g     F .text	0000010c __b2d
0824716c g     F .text	000002fc parse_ipad
08248340 g     F .text	00000020 get_vfopen_error
0825391e g     O .rwdata	00000002 OSQSize
0821132c g     F .text	00000538 .hidden __umoddi3
08214190 g     F .text	000000d4 lseek
0823d060 g     F .text	0000008c inet_timer
08219d08 g     F .text	0000020c OSSemPend
08220f90 g     F .text	0000029c alt_tse_phy_add_profile_default
082226a8 g     F .text	00000598 alt_tse_phy_get_cap
08201abc g     F .text	0000021c sss_send_menu
082538bc g     O .rwdata	00000004 _global_impure_ptr
082288c4 g     F .text	00000154 print_eth
08248820 g     F .text	00000050 vfopen
0823c3dc g     F .text	000000fc alt_read
0820d150 g     F .text	00000564 _realloc_r
082007ac g     F .text	00000264 alt_NetworkErrorHandler
08253908 g     O .rwdata	00000002 OSLowestPrio
0825e4c0 g       *ABS*	00000000 __bss_end
0823bf1c g     F .text	000000f0 alt_iic_isr_register
0821df6c g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0822e164 g     F .text	00000108 m_free
0823cc48 g     F .text	00000024 OSTCBInitHook
08225328 g     F .text	00000040 tse_mac_stats
0822c6e4 g     F .text	0000028c pk_validate
0825394e g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0823c60c g     F .text	00000108 alt_tick
082480c0 g     F .text	00000254 in_pcblookup
0822c2c4 g     F .text	000000c0 find_opt
08210db4 g     F .text	00000578 .hidden __udivdi3
0822dfdc g     F .text	00000188 m_getnbuf
0822ca3c g     F .text	000000bc dump_buf_estats
082109b8 g     F .text	00000024 _fputwc_r
08222548 g     F .text	00000160 alt_tse_phy_check_link
08253bcc g     O .bss	00000004 arpRepsOut
082538f0 g     O .rwdata	00000002 OSEventEn
0824d618 g     O .rodata	00000028 __mprec_bigtens
0820c344 g     F .text	00000104 __s2b
0825394a g     O .rwdata	00000002 OSTmrCfgNameSize
08213dc0 g     F .text	000000a8 .hidden __floatunsidf
0823cc6c g     F .text	000000f4 netmain_init
08223b5c g     F .text	000000e4 marvell_cfg_sgmii
0822238c g     F .text	000001bc alt_tse_phy_restart_an
0820ca1c g     F .text	00000060 __mcmp
08253b04 g     O .bss	00000004 dsc_requests
0823925c g     F .text	00000400 tcp_respond
0823af8c g     F .text	000002d4 udp4_sockbind
08253b50 g     O .bss	00000004 old_mode
08226eb4 g     F .text	00000254 igmp_joingroup
0822f2e4 g     F .text	00000348 so_icmpdu
0820a954 g     F .text	00000018 __fp_lock_all
08253c18 g     O .bss	00000004 vfs_dir_stale
0823bed0 g     F .text	0000004c alt_ic_irq_enabled
0825d644 g     O .bss	00000010 pphy_profiles
08242120 g     F .text	000000d8 ip_reasm_process_timer_tick
08249ba0 g     F .text	00000058 vclearerr
08228264 g     F .text	000000e0 bsd_setsockopt
0822e764 g     F .text	00000054 mbuf_len
08217e70 g     F .text	000000e0 OS_FlagInit
0823c570 g     F .text	0000009c alt_alarm_stop
082498d8 g     F .text	000001cc strippath
08253988 g     O .rwdata	00000004 reqlist
08229168 g     F .text	00000174 tcp_sleep
0824b638 g     F .text	0000001c strtol
082297f8 g     F .text	000007b0 dhc_upcall
0823aa44 g     F .text	000000d0 tcp_usrclosed
08000000 g       *ABS*	00000000 __alt_mem_descriptor_memory
08253b3c g     O .bss	00000004 cticks_factor
0825392c g     O .rwdata	00000002 OSTaskIdleStkSize
08247b6c g     F .text	00000210 in_pcbbind
08253b94 g     O .bss	00000004 alt_irq_active
08219940 g     F .text	000000b0 OSSemAccept
082185b0 g     F .text	000000d8 OSMemPut
082180e8 g     F .text	000001d4 OSMemCreate
08253a7c g     O .bss	00000004 OSIdleCtrMax
0820012c g     F .exceptions	000000d4 alt_irq_handler
08253580 g     O .rwdata	00000028 alt_dev_null
082539aa g     O .rwdata	00000001 tcprexmtthresh
08253940 g     O .rwdata	00000002 OSTicksPerSec
0823eb70 g     F .text	00000094 if_killsocks
0823f5a0 g     F .text	00000220 ip_write
08242c04 g     F .text	000005cc ip_rcv_phase2
08230824 g     F .text	00000044 t_getsockname
08230574 g     F .text	0000026c t_connect
082539a4 g     O .rwdata	00000004 TCPTV_MSL
0825dc64 g     O .bss	00000010 memestats
08222274 g     F .text	00000118 alt_tse_phy_init
0822d290 g     F .text	0000005c getch
08253820 g     O .rwdata	00000080 vfs_root_path
082307e0 g     F .text	00000044 t_getpeername
0821e584 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
08240f10 g     F .text	00000098 ip_reasm_decr_mem_useage
08233f04 g     F .text	00000088 soreserve
0823c908 g       .text	00000000 OSIntCtxSw
0822dda0 g     F .text	00000034 npalloc
0820c448 g     F .text	00000068 __hi0bits
08253bf4 g     O .bss	00000004 ipraw_eps
0822c384 g     F .text	0000029c pk_init
08246e5c g     F .text	0000015c md_fread
08224b98 g     F .text	000002f8 tse_mac_raw_send
08213c64 g     F .text	00000080 .hidden __fixdfsi
0825e268 g     O .bss	00000064 intimers
08233fdc g     F .text	0000004c sbrelease
08234f60 g     F .text	000000f0 ifd_clr
08234898 g     F .text	00000090 sbdroprecord
08228a18 g     F .text	0000007c uslash
0823c7ec g     F .text	000000f8 alt_write
08253bc8 g     O .bss	00000004 arpRepsIn
08229678 g     F .text	00000088 dhc_get_srv_ipaddr
0823d278 g     F .text	00000160 in_timerset
08253a80 g     O .bss	00000004 OSTCBFreeList
08219f14 g     F .text	0000016c OSSemPendAbort
08237f34 g     F .text	00001004 tcp_output
08253ba0 g     O .bss	00000004 activehost
082539c8 g     O .rwdata	00000008 alt_dev_list
08228d20 g     F .text	00000204 parse_args
08253b54 g     O .bss	00000004 global_TCPwakeup_setIndx
0820a984 g     F .text	00000044 _fputc_r
0822566c g     F .text	00000068 write
0821e6c8 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0822ddd4 g     F .text	00000040 npfree
08202ed8 g     F .text	000000a0 _putc_r
0823df34 g     F .text	000002c0 arpReply
08228468 g     F .text	0000007c nextarg
08253944 g     O .rwdata	00000002 OSVersionNbr
0824184c g     F .text	00000530 ip_reasm_process_subsequent_fragments
08253a08 g     O .rwdata	00000004 pton_error
08253af8 g     O .bss	00000004 dsc_errors
082542b8 g     O .bss	00002000 SSSInitialTaskStk
0825d7b4 g     O .bss	00000014 rcvdq
08234ee0 g     F .text	00000080 tcp_notify
08213fc4 g     F .text	000000b0 fstat
082027f0 g     F .text	00000024 fprintf
08231df0 g     F .text	000000b8 soconnect
08243de8 g     F .text	00000048 ip_raw_maxalloc
08212b5c g     F .text	000000f4 .hidden __ledf2
08223d30 g     F .text	00000078 DP83848C_link_status_read
0822a18c g     F .text	000004cc dhc_discover
082018d8 g     F .text	000000a4 SSSCreateOSDataStructs
0824803c g     F .text	00000084 in_setpeeraddr
082538ec g     O .rwdata	00000004 OSEndiannessTest
0822d2ec g     F .text	00000038 clock_init
08248ab8 g     F .text	000000d0 vfgets
0823d5fc g     F .text	00000180 et_send
0820c794 g     F .text	00000140 __pow5mult
0820f0a4 g     F .text	0000145c ___vfiprintf_internal_r
08253a34 g     O .bss	00000004 __nlocale_changed
08202770 g     F .text	00000058 .hidden __umodsi3
08247468 g     F .text	00000060 inet_addr
08240ddc g     F .text	00000094 ip_reasm_check_mem_useage
08232c7c g     F .text	000000fc sorflush
0824b654 g     F .text	0000001c vprintf
0825dd78 g     O .bss	000000fc global_tcb_ext
0823fc0c g     F .text	00000420 ip_fragment_lc
0825d7c8 g     O .bss	00000300 netstatic
082300e4 g     F .text	00000164 t_bind
0821e370 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
082538fe g     O .rwdata	00000002 OSFlagGrpSize
0822cf5c g     F .text	000000d8 udp_close
0821e47c g     F .text	00000054 alt_avalon_sgdma_register_callback
0822d914 g     F .text	000001fc alt_iniche_init
0825e4c0 g       *ABS*	00000000 end
0822d508 g     F .text	00000088 UNLOCK_NET_RESOURCE
08223ee0 g     F .text	00000258 prep_tse_mac
08230d90 g     F .text	000000e0 t_recv
0821d794 g     F .text	00000510 altera_avalon_lcd_16207_write
08248e34 g     F .text	0000018c vfread
08225e14 g     F .text	000000e4 netclose
08202460 g     F .text	000001b4 SSSSimpleSocketServerTask
0824b148 g     F .text	0000000c _atoi_r
0821f100 g     F .text	000001e4 alt_tse_phy_add_profile
082539b4 g     O .rwdata	00000004 tcp_keepintvl
0821c408 g     F .text	00000148 altera_avalon_jtag_uart_init
082163c0 g     F .text	000000e4 OS_TaskStat
08253afc g     O .bss	00000004 dsc_discovers
0825395c g     O .rwdata	00000004 tse_mac_name
08253520 g     O .rwdata	00000018 tcp_protosw
0824b9d0 g       *ABS*	00000000 __CTOR_LIST__
08253c14 g     O .bss	00000004 vfopen_error
08380000 g       *ABS*	00000000 __alt_stack_pointer
08253b88 g     O .bss	00000004 tcp_maxidle
08253b28 g     O .bss	00000004 firstudp
0821e748 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0821ed3c g     F .text	0000007c alt_avalon_timer_sc_init
08213e68 g     F .text	00000064 .hidden __clzsi2
0821cd0c g     F .text	000002c4 altera_avalon_jtag_uart_write
0821e1a0 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0820a944 g     F .text	00000004 __sfp_lock_acquire
0820bff4 g     F .text	000000e4 memchr
0821609c g     F .text	00000054 OS_MemClr
08206538 g     F .text	000021f8 ___vfprintf_internal_r
0823c9d8 g     F .text	0000015c OSTaskStkInit
082031bc g     F .text	00000058 _sprintf_r
0821e298 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0820abfc g     F .text	00000310 _free_r
0824598c g     F .text	00000140 igmpv2_chk4_rtr_alert_opt
0820b5d8 g     F .text	00000010 __locale_mb_cur_max
08231480 g     F .text	000000c4 t_socketclose
082562b8 g     O .bss	00002000 LED7SegLightshowTaskStk
0821570c g     F .text	00000198 OS_EventTaskRdy
0824b804 g     F .text	00000180 __call_exitprocs
08203134 g     F .text	00000074 __srget_r
08224e90 g     F .text	000000ac tse_sgdmaRx_isr
08253a84 g     O .bss	00000001 OSCPUUsage
0825dac8 g     O .bss	00000010 nets
0822d444 g     F .text	000000c4 LOCK_NET_RESOURCE
0822b43c g     F .text	000000e4 dhc_resetip
08253a30 g     O .bss	00000004 __mlocale_changed
082250e8 g     F .text	00000240 tse_mac_rcv
08230064 g     F .text	00000080 t_socket
082538c8 g     O .rwdata	00000004 __malloc_sbrk_base
08200200 g     F .text	00000048 _start
0823d5b4 g     F .text	00000048 etainit
08253b98 g     O .bss	00000004 _alt_tick_rate
0823cfe8 g     F .text	00000024 mcastlist
08218e60 g     F .text	0000028c OSQPend
08203fa8 g     F .text	000003b0 strstr
0825dc74 g     O .bss	000000f0 pktlog
08245528 g     F .text	00000134 igmpv2_process_report
082350c8 g     F .text	00000078 ifd_isset
08244344 g     F .text	00000114 del_route
0821e5e8 g     F .text	00000054 alt_avalon_sgdma_open
08206530 g     F .text	00000008 _user_strerror
0821bb0c g     F .text	00000104 OSTimeDly
082010c4 g     F .text	00000054 get_mac_addr
0823186c g     F .text	000000d0 solisten
0820c8d4 g     F .text	00000148 __lshift
08253b9c g     O .bss	00000004 _alt_nticks
08220ec4 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
082255fc g     F .text	00000070 read
0821c06c g     F .text	00000238 alt_sys_init
08239904 g     F .text	0000004c tcp_quench
0820db84 g     F .text	000001d0 __ssprint_r
08228a94 g     F .text	00000170 ns_printf
0823ea0c g     F .text	000000d4 isbcast
0822d590 g     F .text	0000024c TK_NEWTASK
0824b6ec g     F .text	00000118 __register_exitproc
08253a85 g     O .bss	00000001 OSTaskCtr
08240d0c g     F .text	000000d0 ip_reasm_determine_type_of_frag
08253ab4 g     O .bss	00000001 phy_profile_count
0824b244 g     F .text	000000d0 strncmp
0821ff3c g     F .text	00000074 alt_tse_get_mac_group_index
0821bc10 g     F .text	00000160 OSTimeDlyHMSM
08243a0c g     F .text	000000bc ip_raw_close
0820c59c g     F .text	000001f8 __multiply
08253770 g     O .rwdata	000000b0 mdlist
0821c8f8 g     F .text	00000068 altera_avalon_jtag_uart_close
082269c4 g     F .text	000000e0 igmp_input
0823fb44 g     F .text	000000c8 ip_raw_write
08248fc0 g     F .text	000003b0 vfwrite_locked
0824b314 g     F .text	000000ec strncpy
08253b00 g     O .bss	00000004 dsc_offers
0825421c g     O .bss	00000028 __malloc_current_mallinfo
082538f2 g     O .rwdata	00000002 OSEventMax
0824774c g     F .text	0000006c inet_setport
0820cde8 g     F .text	0000014c __d2b
0821a080 g     F .text	00000110 OSSemPost
082378e4 g     F .text	00000188 tcp_dooptions
08253a28 g     O .bss	00000004 SSSLEDEventFlag
0823370c g     F .text	00000104 soisconnected
082152b0 g     F .text	000000dc OSSchedUnlock
082438e0 g     F .text	00000028 netexit
08201174 g     F .text	000001bc get_serial_number
08253ae4 g     O .bss	00000004 nettick_wakes
08220d44 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
08253b7c g     O .bss	00000001 tcpprintfs
0823d3d8 g     F .text	0000009c in_timerkill
08245404 g     F .text	00000124 igmpv2_input
08253b10 g     O .bss	00000004 dsc_declines
0821c2a4 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0822843c g     F .text	0000002c do_trap
08249e80 g     F .text	000000dc alt_get_fd
08227e70 g     F .text	000000f4 bsd_ioctl
08253a88 g     O .bss	00000004 OSMemFreeList
082153fc g     F .text	000000b0 OSStatInit
0822ea38 g     F .text	000001d0 tcp_rcv
0822887c g     F .text	00000048 panic
08253c1c g     O .bss	00000004 vfs_open_files
0822632c g     F .text	0000018c ip2mac
0823b834 g     F .text	00000158 alt_busy_sleep
08217c4c g     F .text	000000c4 OSFlagQuery
08234c38 g     F .text	000001e4 sock_select
08246a40 g     F .text	00000264 dhc_setup
08239100 g     F .text	00000054 tcp_init
08253b58 g     O .bss	00000004 cticks
08253aed g     O .bss	00000001 to_nettick
08253928 g     O .rwdata	00000002 OSTaskCreateExtEn
08210638 g     F .text	00000054 _close_r
082256d4 g     F .text	000005e8 Netinit
0822db7c g     F .text	00000038 prep_armintcp
082435a4 g     F .text	0000014c in_addmulti
08239154 g     F .text	00000108 tcp_template
08223200 g     F .text	00000328 alt_tse_phy_get_common_speed
0822e854 g     F .text	00000070 remque
0824b670 g     F .text	00000010 _vprintf_r
082351a4 g     F .text	00000410 tcp_reass
082478ec g     F .text	000001a0 tcp_cksum
0823b260 g     F .text	00000380 udp4_socksend
08248870 g     F .text	000001bc vfclose_locked
08235050 g     F .text	00000078 ifd_set
0820c0d8 g     F .text	0000007c memcmp
082156ec g     F .text	00000020 OS_Dummy
0821c364 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0822c214 g     F .text	000000b0 dhc_set_state
08253ac4 g     O .bss	00000004 NDEBUG
0825e4c0 g       *ABS*	00000000 __alt_stack_base
08253a18 g     O .bss	00000004 last_flash_sector
0821c3b4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
08233f8c g     F .text	00000050 sbreserve
08253ab5 g     O .bss	00000001 mac_group_count
08243ac8 g     F .text	00000224 ip_raw_input
08202814 g     F .text	000000cc _fwrite_r
08253994 g     O .rwdata	00000004 lilbufsiz
08235140 g     F .text	00000064 ifd_get
08233e78 g     F .text	0000008c sbwakeup
08208960 g     F .text	00000154 __swsetup_r
08223da8 g     F .text	00000138 altera_eth_tse_init
0825bad0 g     O .bss	000001e0 OSQTbl
08237b98 g     F .text	0000025c tcp_xmit_timer
08224f3c g     F .text	000001ac tse_sgdma_read_init
08212110 g     F .text	000008e8 .hidden __divdf3
0820a804 g     F .text	00000118 __sfp
082014d8 g     F .text	0000013c generate_mac_addr
0823ecec g     F .text	00000190 ip_bldhead
0820d04c g     F .text	00000078 __copybits
08234028 g     F .text	000000a0 sbappend
08251ef8 g     O .rwdata	00000408 __malloc_av_
0820a950 g     F .text	00000004 __sinit_lock_release
08253a8c g     O .bss	00000004 OSTCBHighRdy
08212c50 g     F .text	00000718 .hidden __muldf3
0823f7c0 g     F .text	00000384 ip_write2
0820d96c g     F .text	00000054 __sread
082539f4 g     O .rwdata	00000004 arp_ageout
08253a90 g     O .bss	00000004 OSQFreeList
08221ae0 g     F .text	00000424 alt_tse_mac_get_phy
0823ec04 g     F .text	000000e8 ip_init
08249d78 g     F .text	00000108 alt_find_file
08243da4 g     F .text	00000044 ip_raw_free
0823de38 g     F .text	000000fc make_arp_entry
0823bb78 g     F .text	000000a4 alt_dev_llist_insert
0821462c g     F .text	00000120 __malloc_lock
082027c8 g     F .text	00000028 _fprintf_r
08214320 g     F .text	000000b0 sbrk
0823ab54 g     F .text	0000005c udp_lookup
08204358 g     F .text	000021d8 ___svfprintf_internal_r
0821e4d0 g     F .text	00000058 alt_avalon_sgdma_start
08214938 g     F .text	00000140 OSEventNameSet
0820a558 g     F .text	0000005c _fflush_r
082201e8 g     F .text	0000008c alt_tse_mac_set_duplex
0821068c g     F .text	000000c4 _calloc_r
0822dcc0 g     F .text	000000e0 npfree_base
08253a94 g     O .bss	00000001 OSRdyGrp
08246e10 g     F .text	00000028 md_fopen
08253538 g     O .rwdata	00000018 udp_protosw
082538d4 g     O .rwdata	00000008 alt_flash_dev_list
08247fb8 g     F .text	00000084 in_setsockaddr
08253a10 g       *ABS*	00000000 __bss_start
08200e7c g     F .text	00000074 LED7SegLightshowTask
082340c8 g     F .text	000000d8 sbappendrecord
0825e3e0 g     O .bss	00000050 ip_mib
08202cb0 g     F .text	00000128 memset
08231ea8 g     F .text	00000098 sodisconnect
08200d18 g     F .text	00000080 main
08253a50 g     O .bss	00000004 alt_envp
08253a38 g     O .bss	00000004 __malloc_max_total_mem
08201a4c g     F .text	00000070 sss_reset_connection
0822e5a4 g     F .text	000001c0 m_adj
0821c304 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08208948 g     F .text	00000018 __swbuf
08247080 g     F .text	000000c8 md_fgetc
0824d85c g     O .rodata	00000100 OSUnMapTbl
08240694 g     F .text	000002a8 ip_dump
08229470 g     F .text	00000208 tk_stats
08253970 g     O .rwdata	00000008 alt_iniche_dev_list
082582b8 g     O .bss	00000078 SSSLEDCommandQTbl
0821dd50 g     F .text	00000180 altera_avalon_lcd_16207_init
08253964 g     O .rwdata	00000008 alt_sgdma_list
08253922 g     O .rwdata	00000002 OSSemEn
08253b40 g     O .bss	00000004 OS_TPS
0822f8c8 g     F .text	0000074c rawip_usrreq
082178b8 g     F .text	00000394 OSFlagPost
0820daa0 g     F .text	00000008 __sclose
0824762c g     F .text	0000005c print46_addr
08380000 g       *ABS*	00000000 __alt_heap_limit
08210840 g     F .text	00000014 fclose
082158a4 g     F .text	00000110 OS_EventTaskWait
0824b400 g     F .text	00000238 _strtol_r
082286a4 g     F .text	000001d8 print_uptime
082164a4 g     F .text	000000cc OS_TaskStatStkChk
0821af64 g     F .text	00000150 OSTaskDelReq
08208cb4 g     F .text	00001688 _dtoa_r
0820b7e8 g     F .text	0000080c _malloc_r
08247148 g     F .text	00000024 md_unlink
0821efd4 g     F .text	00000088 tse_mac_SwReset
08210d28 g     F .text	00000030 __ascii_wctomb
08247b14 g     F .text	00000058 in_pcbdetach
082539d4 g     O .rwdata	00000004 alt_errno
08253a04 g     O .rwdata	00000004 mdlist_size
0821538c g     F .text	00000070 OSStart
08246358 g     F .text	00000034 u_mctest_init
082145cc g     F .text	00000060 __env_unlock
0820b3c8 g     F .text	000000c4 _fwalk
0821b400 g     F .text	000001d4 OSTaskResume
08218688 g     F .text	000000e8 OSMemQuery
082477b8 g     F .text	00000134 convert_ip
0823dccc g     F .text	0000016c find_oldest_arp
08253934 g     O .rwdata	00000002 OSTaskStatEn
08253bc0 g     O .bss	00000004 arpReqsIn
08248498 g     F .text	00000050 vf_free_buffer
08249c58 g     F .text	00000120 alt_fcntl
0825390e g     O .rwdata	00000002 OSMemMax
082193c0 g     F .text	00000170 OSQPostFront
0822d1c8 g     F .text	00000034 dtrap
082539a0 g     O .rwdata	00000004 kb_last
08202f78 g     F .text	000000c8 putc
08202614 g     F .text	00000084 .hidden __divsi3
0821fe88 g     F .text	00000048 alt_tse_mac_set_common_speed
08253a95 g     O .bss	00000003 OSRdyTbl
082538e8 g     O .rwdata	00000002 OSDebugEn
0822dbb4 g     F .text	0000010c npalloc_base
082267cc g     F .text	000000d0 ip_exit
0820aad8 g     F .text	00000124 _malloc_trim_r
0824b9d0 g       *ABS*	00000000 __CTOR_END__
08253900 g     O .rwdata	00000002 OSFlagNodeSize
08253af4 g     O .bss	00000004 dhc_conn
0822d344 g     F .text	0000005c cticks_hook
08253948 g     O .rwdata	00000002 OSTmrCfgMax
0823cf58 g     F .text	00000040 sysuptime
0820daa8 g     F .text	000000dc strcmp
08201330 g     F .text	000001a8 generate_and_store_mac_addr
082421f8 g     F .text	000001b4 ip_reasm_delete_ire
0821897c g     F .text	000001ac OSQCreate
0822d3a0 g     F .text	00000060 irq_Mask
0821b0b4 g     F .text	00000198 OSTaskNameGet
08253ba8 g     O .bss	00000004 nextppp
08253b30 g     O .bss	00000004 irq_level
08225cbc g     F .text	00000158 fixup_subnet_mask
08219530 g     F .text	0000020c OSQPostOpt
082154ac g     F .text	00000220 OSTimeTick
08240b14 g     F .text	00000134 ip_copypkt
0822c124 g     F .text	00000088 dhc_alldone
08253930 g     O .rwdata	00000002 OSTaskMax
0824b9d0 g       *ABS*	00000000 __DTOR_LIST__
082199f0 g     F .text	000000d8 OSSemCreate
08253ad8 g     O .bss	00000004 igmp_all_hosts_group
08253954 g     O .rwdata	00000002 OSTmrWheelSize
08233dd0 g     F .text	0000003c sbselqueue
08253ae0 g     O .bss	00000004 netmain_wakes
0823e1f4 g     F .text	00000264 arprcv
082290f4 g     F .text	00000074 TK_OSTaskResume
082274a0 g     F .text	0000041c igmp_print_stats
082129f8 g     F .text	00000088 .hidden __nedf2
0822de88 g     F .text	00000090 pffindtype
0825392a g     O .rwdata	00000002 OSTaskDelEn
082539b8 g     O .rwdata	00000004 tcp_sendspace
0824951c g     F .text	00000110 vftell
0825db3c g     O .bss	00000012 eth_prt_buf
0821a190 g     F .text	00000110 OSSemQuery
08218b28 g     F .text	00000280 OSQDel
082190ec g     F .text	0000016c OSQPendAbort
0821c034 g     F .text	00000038 alt_irq_init
0821fe48 g     F .text	00000040 alt_tse_mac_get_common_speed
0825dfa4 g     O .bss	00000018 app_semaphore
0823c4d8 g     F .text	00000064 alt_release_fd
0822d898 g     F .text	0000007c post_app_sem
08226920 g     F .text	000000a4 igmp_init
08203214 g     F .text	0000006c sprintf
0824d748 g     O .rodata	00000100 .hidden __clz_tab
08253b1c g     O .bss	00000004 dsc_renew
08246fb8 g     F .text	00000078 md_fwrite
08253a2c g     O .bss	00000004 _PathLocale
08253b44 g     O .bss	00000004 tcp_sleep_count
0822e8c4 g     F .text	0000007c insque
0824b128 g     F .text	00000014 atexit
08253c10 g     O .bss	00000004 vfsfiles
082105d8 g     F .text	00000060 _write_r
0824b680 g     F .text	00000050 _vsprintf_r
08244c00 g     F .text	00000298 udp_send
08215224 g     F .text	0000008c OSSchedLock
08226c18 g     F .text	0000029c igmp_send
0820b608 g     F .text	00000018 setlocale
08216cdc g     F .text	00000108 OSFlagCreate
08258330 g     O .bss	00002000 LEDManagementTaskStk
0822d400 g     F .text	00000044 irq_Unmask
08230248 g     F .text	000000d8 t_listen
082538c0 g     O .rwdata	00000004 _impure_ptr
08251924 g     O .rwdata	00000018 ssstask
08253a48 g     O .bss	00000004 alt_argc
0823a18c g     F .text	000006d4 tcp_usrreq
0823ad50 g     F .text	0000023c udp_usrreq
0822de14 g     F .text	00000034 ncpalloc
0820a33c g     F .text	0000021c __sflush_r
0823bc7c g     F .text	00000060 _do_dtors
0820b5f4 g     F .text	00000008 __locale_cjk_lang
082538fa g     O .rwdata	00000002 OSEventMultiEn
082539ec g     O .rwdata	00000004 pingdelay
0823d804 g     F .text	00000074 arp_send_pending
0825d554 g     O .bss	000000e0 tse_mac_if
08245160 g     F .text	000002a4 igmpv1_input
0820d6d0 g     F .text	000001d4 __srefill_r
0822db10 g     F .text	0000004c pre_task_setup
08253b64 g     O .bss	00000004 rcvdq_sem_ptr
08227b04 g     F .text	00000124 bsd_getsockname
082423ac g     F .text	00000130 ip_reasm_mark_compact_rfq
082017ac g     F .text	0000012c FindLastFlashSectorOffset
08216de4 g     F .text	00000248 OSFlagDel
08253a98 g     O .bss	00000004 OSEventFreeList
082297b0 g     F .text	00000048 dhc_set_callback
08200060 g       .exceptions	00000000 alt_irq_entry
08253bb8 g     O .bss	00000004 arpcache
0824aac0 g     F .text	00000300 icmp_destun
082437fc g     F .text	00000064 lookup_mcast
08249890 g     F .text	00000048 vfslookup
082431d0 g     F .text	000003d4 ip_demux
0820cc78 g     F .text	00000064 __ulp
08253b48 g     O .bss	00000004 tcp_wakeup_count
082172a0 g     F .text	000005b8 OSFlagPend
08253946 g     O .rwdata	00000002 OSTmrEn
0820a96c g     F .text	00000018 __fp_unlock_all
0822d7dc g     F .text	000000bc wait_app_sem
0821ded0 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
0820a9c8 g     F .text	0000005c fputc
08253978 g     O .rwdata	00000004 ipmcfail_str
08253b5c g     O .bss	00000004 memtrapsize
0822e2b0 g     F .text	000002f4 m_copy
082539c0 g     O .rwdata	00000008 alt_fs_list
0825e020 g     O .bss	00000014 mfreeq
0821629c g     F .text	00000074 OS_StrCopy
08231810 g     F .text	0000005c sobind
08246db8 g     F .text	00000058 init_memdev
08253a10 g     O .bss	00000001 to_ssstask
0822e940 g     F .text	000000f8 nptcp_init
08253910 g     O .rwdata	00000002 OSMemNameSize
0825de74 g     O .bss	000000f0 global_TCPwakeup_set
0823cc08 g     F .text	00000020 OSInitHookEnd
082338a8 g     F .text	000000c4 soisdisconnected
0823d77c g     F .text	00000088 arp_free_pending
0825393c g     O .rwdata	00000002 OSTCBPrioTblMax
0820b620 g     F .text	0000000c localeconv
08231a4c g     F .text	000002bc soclose
0825dd64 g     O .bss	00000014 bigfreeq
08253938 g     O .rwdata	00000002 OSTaskStatStkChkEn
082539e8 g     O .rwdata	00000004 prompt
082539b0 g     O .rwdata	00000004 tcp_keepidle
08223058 g     F .text	000001a8 alt_tse_phy_set_adv_10
0822f700 g     F .text	000001c8 rawip_soinput
0823bd6c g     F .text	00000050 alt_ic_isr_register
08249370 g     F .text	00000060 vfwrite
0825390c g     O .rwdata	00000002 OSMemEn
08233b6c g     F .text	000000ac soqinsque
08253bec g     O .bss	00000004 so_evtmap_delete
082028e0 g     F .text	00000034 fwrite
08253916 g     O .rwdata	00000002 OSMutexEn
08253bd8 g     O .bss	00000004 h_ireq
08253a10 g       *ABS*	00000000 _edata
0824002c g     F .text	000005c4 ip_fragment
082254b4 g     F .text	00000148 iniche_devices_init
0825e034 g     O .bss	00000028 tcp_saveti
08228c48 g     F .text	000000d8 con_page
0825e4c0 g       *ABS*	00000000 _end
082331a8 g     F .text	000004a8 sogetopt
08213ecc g     F .text	00000068 alt_flash_open_dev
08253a9c g     O .bss	00000001 OSIntNesting
08221f04 g     F .text	00000248 alt_tse_mac_associate_phy
082534f0 g     O .rwdata	00000030 nettasks
0822ca1c g     F .text	00000020 pk_get_max_intrsafe_buf_len
08210854 g     F .text	00000164 __fputwc
0824093c g     F .text	000001d8 iproute
0822f1f0 g     F .text	000000f4 np_stripoptions
08253bf0 g     O .bss	00000001 so_evtmap
0821c960 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0820aa24 g     F .text	0000009c _fputs_r
0821bd70 g     F .text	000001d4 OSTimeDlyResume
0820197c g     F .text	000000d0 SSSCreateTasks
08243f84 g     F .text	000003c0 add_route
08217154 g     F .text	0000014c OSFlagNameSet
0822629c g     F .text	00000090 c_older
0823455c g     F .text	00000084 sbflush
08246e38 g     F .text	00000024 md_fclose
08229440 g     F .text	00000030 tk_yield
08201cd8 g     F .text	000000c8 sss_handle_accept
0821b5d4 g     F .text	000001c0 OSTaskStkChk
0823be44 g     F .text	0000008c alt_ic_irq_disable
08231f40 g     F .text	00000558 sosend
08253912 g     O .rwdata	00000002 OSMemSize
082405f0 g     F .text	000000a4 ip_mymach
0821e63c g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0820d9c8 g     F .text	0000007c __swrite
08253b2c g     O .bss	00000004 cticks_initialized
082539f0 g     O .rwdata	00000004 deflength
08230fb0 g     F .text	000001f4 t_sendto
082538cc g     O .rwdata	00000004 __malloc_trim_threshold
08202dd8 g     F .text	00000080 _perror_r
0823c8e4 g     F .text	00000024 altera_nios2_qsys_irq_init
0820b5e8 g     F .text	0000000c __locale_msgcharset
08253aa0 g     O .bss	00000004 OSTCBCur
08231668 g     F .text	000001a8 socreate
0824b154 g     F .text	00000038 exit
0825e2cc g     O .bss	00000100 arp_table
08253c28 g     O .bss	00000004 icmpdu_hook
08253914 g     O .rwdata	00000002 OSMemTblSize
0820b48c g     F .text	000000c4 _fwalk_reent
0823d474 g     F .text	00000024 create_apptasks
082539ac g     O .rwdata	00000004 tcp_ttl
0820ca7c g     F .text	000001fc __mdiff
08213f34 g     F .text	00000054 alt_flash_close_dev
0822de48 g     F .text	00000040 ncpfree
08202698 g     F .text	00000074 .hidden __modsi3
08253abc g     O .bss	00000004 MaxLnh
082538b8 g     O .rwdata	00000004 __ctype_ptr__
0821f0b0 g     F .text	00000050 tse_mac_setGMIImode
082475a8 g     F .text	00000084 inet_ntop
082450f8 g     F .text	00000024 udp_maxalloc
08223a78 g     F .text	000000e4 marvell_cfg_gmii
08380000 g       *ABS*	00000000 __alt_data_end
08200060 g     F .exceptions	00000000 alt_exception
0820a948 g     F .text	00000004 __sfp_lock_release
08215088 g     F .text	00000058 OSInit
0822214c g     F .text	00000128 alt_tse_phy_cfg_pcs
0821b978 g     F .text	00000124 OSTaskQuery
0823cd60 g     F .text	00000094 icmp_port_du
08253b8c g     O .bss	00000004 tcp_iss
08219898 g     F .text	000000a8 OS_QInit
0824b13c g     F .text	0000000c atoi
0825399c g     O .rwdata	00000004 bigbufsiz
08216310 g     F .text	00000054 OS_StrLen
08239950 g     F .text	00000078 tcp_putseq
0821849c g     F .text	00000114 OSMemNameSet
0824cbb6 g     O .rodata	00000101 _ctype_
08200000 g       *ABS*	00000000 __alt_mem_onchip_ram
082341a0 g     F .text	000001dc sbappendaddr
00000000 g       *ABS*	00000000 __alt_mem_ext_flash
08253c20 g     O .bss	00000004 vfs_total_rw_space
082461c8 g     F .text	00000108 ip_getmoptions
0825392e g     O .rwdata	00000002 OSTaskProfileEn
08244e98 g     F .text	000000f4 udpswap
08253aa4 g     O .bss	00000004 OSTime
08253b68 g     O .bss	00000004 nextslow
08239a3c g     F .text	00000270 tcp_slowtimo
0823965c g     F .text	0000010c tcp_newtcpcb
0823e458 g     F .text	00000180 send_via_arp
08229700 g     F .text	000000b0 dhc_init
08241d7c g     F .text	00000058 ip_reasm_find_ire
0825bcb0 g     O .bss	00000800 OSTaskIdleStk
0824b99c g     F .text	00000034 _exit
08249aa4 g     F .text	00000058 isvfile_locked
082280e0 g     F .text	00000184 bsd_select
0823b708 g     F .text	0000012c alt_alarm_start
0821702c g     F .text	00000128 OSFlagNameGet
0824511c g     F .text	00000044 udp_free
0822caf8 g     F .text	000000b8 getq
08249bf8 g     F .text	00000024 prep_vfs
0821bf44 g     F .text	0000005c OSTimeGet
082539e4 g     O .rwdata	00000004 name
08234798 g     F .text	00000100 sbdropend
0820b62c g     F .text	000001bc __smakebuf_r
0823e5d8 g     F .text	0000010c cb_arpent_tmo
08203a5c g     F .text	00000098 strlen
08245acc g     F .text	00000134 IPADDR_TO_NETP
08227f64 g     F .text	00000034 bsd_inet_ntoa
0823cb7c g     F .text	00000020 OSTaskSwHook
0823c24c g     F .text	00000154 open
0822cd60 g     F .text	000001fc udp_open
0825c4b0 g     O .bss	00000b40 OSEventTbl
08233d20 g     F .text	00000058 socantsendmore
08253c24 g     O .bss	00000004 vfs_total_dyna_files
08212a80 g     F .text	000000dc .hidden __gedf2
0823c714 g     F .text	00000044 alt_uncached_free
0825cff0 g     O .bss	00000510 OSTCBTbl
08253bc4 g     O .bss	00000004 arpReqsOut
0821a2a0 g     F .text	00000100 OSSemSet
08253a0c g     O .rwdata	00000004 http_root_path
0822b6d4 g     F .text	00000270 dhc_extract_opts
082412e8 g     F .text	00000564 ip_reasm_compute_overlap
082538d0 g     O .rwdata	00000004 __wctomb
0820f08c g     F .text	00000018 __sprint_r
0821ef2c g     F .text	000000a8 tse_mac_aRxRead
08203280 g     F .text	00000164 strchr
0825db4e g     O .bss	00000012 ipreturn
08253be0 g     O .bss	00000004 port_prep
08253573 g     O .rwdata	0000000d tcp_backoff
0823369c g     F .text	00000070 soisconnecting
08200ca8 g     F .text	00000070 SSSInitialTask
0820aac0 g     F .text	00000018 fputs
082539d8 g     O .rwdata	00000004 alt_priority_mask
0824565c g     F .text	000001ec igmpv2_process_query
08234928 g     F .text	000001d0 t_select
08219ac8 g     F .text	00000240 OSSemDel
0823b5e0 g     F .text	00000128 udp4_sockaddr
08253aa8 g     O .bss	00000004 OSFlagFreeList
08247d7c g     F .text	000001e0 in_pcbconnect
08253b80 g     O .bss	00000004 dropline
08253bdc g     O .bss	00000004 ire_cticks
0823bdbc g     F .text	00000088 alt_ic_irq_enable
082538f4 g     O .rwdata	00000002 OSEventNameSize
08208730 g     F .text	0000001c __vfprintf_internal
08229004 g     F .text	00000078 tk_netmain
08247f5c g     F .text	0000005c in_pcbdisconnect
08253aac g     O .bss	00000001 OSStatRdy
0825d500 g     O .bss	00000054 OSTCBPrioTbl
08210d58 g     F .text	0000005c _wctomb_r
08214508 g     F .text	000000c4 __env_lock
0825393a g     O .rwdata	00000002 OSTaskSwHookEn
0825374c g     O .rwdata	00000024 mdio
08220108 g     F .text	000000e0 alt_tse_mac_set_speed
0821e214 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
082278bc g     F .text	00000124 bsd_accept
082539bc g     O .rwdata	00000004 tcp_recvspace
08213368 g     F .text	000008fc .hidden __subdf3
0824b984 g     F .text	00000018 _vfprintf_r
0823ab14 g     F .text	00000040 tcpinit
08253adc g     O .bss	00000004 igmp_all_rtrs_group
0822f6a4 g     F .text	0000005c rawip_lookup
0823d514 g     F .text	000000a0 fcntl
0820c4b0 g     F .text	000000b0 __lo0bits
0823437c g     F .text	000001e0 sbcompress
082539dc g     O .rwdata	00000008 alt_alarm_list
08239768 g     F .text	000000ac tcp_drop
08253902 g     O .rwdata	00000002 OSFlagWidth
0823bc1c g     F .text	00000060 _do_ctors
08222e04 g     F .text	00000254 alt_tse_phy_set_adv_100
08239d0c g     F .text	00000480 tcp_timers
0822689c g     F .text	00000084 if_netnumber
082462d0 g     F .text	00000088 ip_freemoptions
08233650 g     F .text	0000004c sohasoutofband
08210c68 g     F .text	000000c0 wcrtomb
082355b4 g     F .text	00002330 tcp_input
082279e0 g     F .text	00000124 bsd_getpeername
08227f98 g     F .text	00000148 bsd_recvfrom
0822546c g     F .text	00000048 close
08253b0c g     O .bss	00000004 dsc_bpreplys
08253a58 g     O .bss	00000004 alt_envsem
08253ab0 g     O .bss	00000004 OSIdleCtrRun
082156cc g     F .text	00000020 OSVersion
0825394c g     O .rwdata	00000002 OSTmrCfgWheelSize
0821ba9c g     F .text	00000070 OS_TaskStkClr
08248314 g     F .text	0000002c set_vfopen_error
08253926 g     O .rwdata	00000002 OSTaskCreateEn
0821fed0 g     F .text	0000006c alt_tse_get_system_index
08253550 g     O .rwdata	00000018 rawip_protosw
08233e0c g     F .text	0000006c sbwait
08215cbc g     F .text	00000068 OS_EventWaitListInit
0822b944 g     F .text	00000550 dhc_second
0821ec1c g     F .text	000000a8 alt_avalon_sgdma_init
08253bac g     O .bss	00000004 port_1s_callout
082109dc g     F .text	00000080 fputwc
0823cc28 g     F .text	00000020 OSTaskIdleHook
0824b1a0 g     F .text	00000014 free
0820a94c g     F .text	00000004 __sinit_lock_acquire
08253ab8 g     O .bss	00000001 number_of_tse_mac
0820c224 g     F .text	00000120 __multadd
0821b794 g     F .text	000001e4 OSTaskSuspend
0820c1fc g     F .text	00000028 _Bfree
0821edb8 g     F .text	00000030 no_printf
0823396c g     F .text	00000200 sonewconn
08249f5c g     F .text	00000b64 icmprcv
0822df18 g     F .text	000000c4 pffindproto
08216364 g     F .text	0000005c OS_TaskIdle
08253952 g     O .rwdata	00000002 OSTmrTblSize
0821973c g     F .text	0000015c OSQQuery



Disassembly of section .exceptions:

08200060 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8200060:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8200064:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8200068:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 820006c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8200070:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8200074:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8200078:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 820007c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8200080:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8200084:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8200088:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 820008c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8200090:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8200094:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8200098:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 820009c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 82000a0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 82000a4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 82000a8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 82000ac:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 82000b0:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 82000b4:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 82000b8:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 82000bc:	10000326 	beq	r2,zero,82000cc <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 82000c0:	20000226 	beq	r4,zero,82000cc <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 82000c4:	820012c0 	call	820012c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 82000c8:	00000306 	br	82000d8 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 82000cc:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 82000d0:	e8bfff17 	ldw	r2,-4(ea)

082000d4 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 82000d4:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 82000d8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 82000dc:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 82000e0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 82000e4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 82000e8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 82000ec:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 82000f0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 82000f4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 82000f8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 82000fc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 8200100:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 8200104:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 8200108:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 820010c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 8200110:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 8200114:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 8200118:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 820011c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 8200120:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 8200124:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 8200128:	ef80083a 	eret

0820012c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 820012c:	defff904 	addi	sp,sp,-28
 8200130:	dfc00615 	stw	ra,24(sp)
 8200134:	df000515 	stw	fp,20(sp)
 8200138:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 820013c:	82150e00 	call	82150e0 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8200140:	0005313a 	rdctl	r2,ipending
 8200144:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8200148:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 820014c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8200150:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8200154:	00800044 	movi	r2,1
 8200158:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 820015c:	e0fffb17 	ldw	r3,-20(fp)
 8200160:	e0bffc17 	ldw	r2,-16(fp)
 8200164:	1884703a 	and	r2,r3,r2
 8200168:	10001426 	beq	r2,zero,82001bc <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 820016c:	008209b4 	movhi	r2,2086
 8200170:	10b85a04 	addi	r2,r2,-7832
 8200174:	e0fffd17 	ldw	r3,-12(fp)
 8200178:	180690fa 	slli	r3,r3,3
 820017c:	10c5883a 	add	r2,r2,r3
 8200180:	10c00017 	ldw	r3,0(r2)
 8200184:	008209b4 	movhi	r2,2086
 8200188:	10b85a04 	addi	r2,r2,-7832
 820018c:	e13ffd17 	ldw	r4,-12(fp)
 8200190:	200890fa 	slli	r4,r4,3
 8200194:	1105883a 	add	r2,r2,r4
 8200198:	10800104 	addi	r2,r2,4
 820019c:	10800017 	ldw	r2,0(r2)
 82001a0:	1009883a 	mov	r4,r2
 82001a4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 82001a8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 82001ac:	0005313a 	rdctl	r2,ipending
 82001b0:	e0bfff15 	stw	r2,-4(fp)

  return active;
 82001b4:	e0bfff17 	ldw	r2,-4(fp)
 82001b8:	00000706 	br	82001d8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 82001bc:	e0bffc17 	ldw	r2,-16(fp)
 82001c0:	1085883a 	add	r2,r2,r2
 82001c4:	e0bffc15 	stw	r2,-16(fp)
      i++;
 82001c8:	e0bffd17 	ldw	r2,-12(fp)
 82001cc:	10800044 	addi	r2,r2,1
 82001d0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 82001d4:	003fe106 	br	820015c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 82001d8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 82001dc:	e0bffb17 	ldw	r2,-20(fp)
 82001e0:	103fdb1e 	bne	r2,zero,8200150 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 82001e4:	821512c0 	call	821512c <OSIntExit>
}
 82001e8:	0001883a 	nop
 82001ec:	e037883a 	mov	sp,fp
 82001f0:	dfc00117 	ldw	ra,4(sp)
 82001f4:	df000017 	ldw	fp,0(sp)
 82001f8:	dec00204 	addi	sp,sp,8
 82001fc:	f800283a 	ret

Disassembly of section .text:

08200200 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8200200:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 8200204:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 8200208:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 820020c:	00bffd16 	blt	zero,r2,8200204 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8200210:	06c20e34 	movhi	sp,2104
    ori sp, sp, %lo(__alt_stack_pointer)
 8200214:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8200218:	06820974 	movhi	gp,2085
    ori gp, gp, %lo(_gp)
 820021c:	d6ae2e14 	ori	gp,gp,47288
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8200220:	00820974 	movhi	r2,2085
    ori r2, r2, %lo(__bss_start)
 8200224:	108e8414 	ori	r2,r2,14864

    movhi r3, %hi(__bss_end)
 8200228:	00c20974 	movhi	r3,2085
    ori r3, r3, %lo(__bss_end)
 820022c:	18f93014 	ori	r3,r3,58560

    beq r2, r3, 1f
 8200230:	10c00326 	beq	r2,r3,8200240 <_start+0x40>

0:
    stw zero, (r2)
 8200234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 8200238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 820023c:	10fffd36 	bltu	r2,r3,8200234 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8200240:	82142640 	call	8214264 <alt_main>

08200244 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 8200244:	003fff06 	br	8200244 <alt_after_alt_main>

08200248 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 8200248:	defffb04 	addi	sp,sp,-20
 820024c:	dfc00415 	stw	ra,16(sp)
 8200250:	df000315 	stw	fp,12(sp)
 8200254:	df000304 	addi	fp,sp,12
 8200258:	2005883a 	mov	r2,r4
 820025c:	e17fff15 	stw	r5,-4(fp)
 8200260:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 8200264:	e0bffe03 	ldbu	r2,-8(fp)
 8200268:	10014a26 	beq	r2,zero,8200794 <alt_uCOSIIErrorHandler+0x54c>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 820026c:	00800084 	movi	r2,2
 8200270:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200274:	82152240 	call	8215224 <OSSchedLock>
      
   switch (error_code)
 8200278:	e0bffe03 	ldbu	r2,-8(fp)
 820027c:	10c00a20 	cmpeqi	r3,r2,40
 8200280:	1800261e 	bne	r3,zero,820031c <alt_uCOSIIErrorHandler+0xd4>
 8200284:	10c00a48 	cmpgei	r3,r2,41
 8200288:	1800121e 	bne	r3,zero,82002d4 <alt_uCOSIIErrorHandler+0x8c>
 820028c:	10c00120 	cmpeqi	r3,r2,4
 8200290:	1800601e 	bne	r3,zero,8200414 <alt_uCOSIIErrorHandler+0x1cc>
 8200294:	10c00148 	cmpgei	r3,r2,5
 8200298:	1800071e 	bne	r3,zero,82002b8 <alt_uCOSIIErrorHandler+0x70>
 820029c:	10c000a0 	cmpeqi	r3,r2,2
 82002a0:	18007a1e 	bne	r3,zero,820048c <alt_uCOSIIErrorHandler+0x244>
 82002a4:	10c000c8 	cmpgei	r3,r2,3
 82002a8:	1800631e 	bne	r3,zero,8200438 <alt_uCOSIIErrorHandler+0x1f0>
 82002ac:	10800060 	cmpeqi	r2,r2,1
 82002b0:	10004d1e 	bne	r2,zero,82003e8 <alt_uCOSIIErrorHandler+0x1a0>
 82002b4:	0000bc06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002b8:	10c00520 	cmpeqi	r3,r2,20
 82002bc:	1800401e 	bne	r3,zero,82003c0 <alt_uCOSIIErrorHandler+0x178>
 82002c0:	10c007a0 	cmpeqi	r3,r2,30
 82002c4:	1800961e 	bne	r3,zero,8200520 <alt_uCOSIIErrorHandler+0x2d8>
 82002c8:	108002a0 	cmpeqi	r2,r2,10
 82002cc:	1000651e 	bne	r2,zero,8200464 <alt_uCOSIIErrorHandler+0x21c>
 82002d0:	0000b506 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002d4:	10c01020 	cmpeqi	r3,r2,64
 82002d8:	1800881e 	bne	r3,zero,82004fc <alt_uCOSIIErrorHandler+0x2b4>
 82002dc:	10c01048 	cmpgei	r3,r2,65
 82002e0:	1800071e 	bne	r3,zero,8200300 <alt_uCOSIIErrorHandler+0xb8>
 82002e4:	10c00f60 	cmpeqi	r3,r2,61
 82002e8:	18007a1e 	bne	r3,zero,82004d4 <alt_uCOSIIErrorHandler+0x28c>
 82002ec:	10c00fa0 	cmpeqi	r3,r2,62
 82002f0:	18006f1e 	bne	r3,zero,82004b0 <alt_uCOSIIErrorHandler+0x268>
 82002f4:	10800aa0 	cmpeqi	r2,r2,42
 82002f8:	1000111e 	bne	r2,zero,8200340 <alt_uCOSIIErrorHandler+0xf8>
 82002fc:	0000aa06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 8200300:	10c01920 	cmpeqi	r3,r2,100
 8200304:	1800901e 	bne	r3,zero,8200548 <alt_uCOSIIErrorHandler+0x300>
 8200308:	10c03fe0 	cmpeqi	r3,r2,255
 820030c:	1800991e 	bne	r3,zero,8200574 <alt_uCOSIIErrorHandler+0x32c>
 8200310:	108010a0 	cmpeqi	r2,r2,66
 8200314:	10001a1e 	bne	r2,zero,8200380 <alt_uCOSIIErrorHandler+0x138>
 8200318:	0000a306 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 820031c:	d0a00217 	ldw	r2,-32760(gp)
 8200320:	10800317 	ldw	r2,12(r2)
 8200324:	100f883a 	mov	r7,r2
 8200328:	01800c44 	movi	r6,49
 820032c:	01400044 	movi	r5,1
 8200330:	01020974 	movhi	r4,2085
 8200334:	212e7404 	addi	r4,r4,-17968
 8200338:	82028e00 	call	82028e0 <fwrite>
         break;
 820033c:	0000b106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 8200340:	d0a00217 	ldw	r2,-32760(gp)
 8200344:	10800317 	ldw	r2,12(r2)
 8200348:	100f883a 	mov	r7,r2
 820034c:	01800c44 	movi	r6,49
 8200350:	01400044 	movi	r5,1
 8200354:	01020974 	movhi	r4,2085
 8200358:	212e8104 	addi	r4,r4,-17916
 820035c:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 8200360:	d0a00217 	ldw	r2,-32760(gp)
 8200364:	10800317 	ldw	r2,12(r2)
 8200368:	01800504 	movi	r6,20
 820036c:	01420974 	movhi	r5,2085
 8200370:	296e8e04 	addi	r5,r5,-17864
 8200374:	1009883a 	mov	r4,r2
 8200378:	82027f00 	call	82027f0 <fprintf>
            OS_LOWEST_PRIO);
         break;
 820037c:	0000a106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 8200380:	d0a00217 	ldw	r2,-32760(gp)
 8200384:	10800317 	ldw	r2,12(r2)
 8200388:	100f883a 	mov	r7,r2
 820038c:	01800a04 	movi	r6,40
 8200390:	01400044 	movi	r5,1
 8200394:	01020974 	movhi	r4,2085
 8200398:	212e9b04 	addi	r4,r4,-17812
 820039c:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 82003a0:	d0a00217 	ldw	r2,-32760(gp)
 82003a4:	10800317 	ldw	r2,12(r2)
 82003a8:	01800284 	movi	r6,10
 82003ac:	01420974 	movhi	r5,2085
 82003b0:	296ea604 	addi	r5,r5,-17768
 82003b4:	1009883a 	mov	r4,r2
 82003b8:	82027f00 	call	82027f0 <fprintf>
         break;
 82003bc:	00009106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_MBOX_FULL:
         fault_level = NONE;
 82003c0:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 82003c4:	d0a00217 	ldw	r2,-32760(gp)
 82003c8:	10800317 	ldw	r2,12(r2)
 82003cc:	100f883a 	mov	r7,r2
 82003d0:	01800c84 	movi	r6,50
 82003d4:	01400044 	movi	r5,1
 82003d8:	01020974 	movhi	r4,2085
 82003dc:	212eaf04 	addi	r4,r4,-17732
 82003e0:	82028e00 	call	82028e0 <fwrite>
         break;
 82003e4:	00008706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 82003e8:	00800044 	movi	r2,1
 82003ec:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, 
 82003f0:	d0a00217 	ldw	r2,-32760(gp)
 82003f4:	10800317 	ldw	r2,12(r2)
 82003f8:	100f883a 	mov	r7,r2
 82003fc:	01801244 	movi	r6,73
 8200400:	01400044 	movi	r5,1
 8200404:	01020974 	movhi	r4,2085
 8200408:	212ebc04 	addi	r4,r4,-17680
 820040c:	82028e00 	call	82028e0 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 8200410:	00007c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 8200414:	d0a00217 	ldw	r2,-32760(gp)
 8200418:	10800317 	ldw	r2,12(r2)
 820041c:	100f883a 	mov	r7,r2
 8200420:	01800c44 	movi	r6,49
 8200424:	01400044 	movi	r5,1
 8200428:	01020974 	movhi	r4,2085
 820042c:	212ecf04 	addi	r4,r4,-17604
 8200430:	82028e00 	call	82028e0 <fwrite>
         break;
 8200434:	00007306 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 8200438:	00800044 	movi	r2,1
 820043c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 8200440:	d0a00217 	ldw	r2,-32760(gp)
 8200444:	10800317 	ldw	r2,12(r2)
 8200448:	100f883a 	mov	r7,r2
 820044c:	01800a44 	movi	r6,41
 8200450:	01400044 	movi	r5,1
 8200454:	01020974 	movhi	r4,2085
 8200458:	212edc04 	addi	r4,r4,-17552
 820045c:	82028e00 	call	82028e0 <fwrite>
         break;
 8200460:	00006806 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TIMEOUT:
         fault_level = NONE;
 8200464:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 8200468:	d0a00217 	ldw	r2,-32760(gp)
 820046c:	10800317 	ldw	r2,12(r2)
 8200470:	100f883a 	mov	r7,r2
 8200474:	01800a04 	movi	r6,40
 8200478:	01400044 	movi	r5,1
 820047c:	01020974 	movhi	r4,2085
 8200480:	212ee704 	addi	r4,r4,-17508
 8200484:	82028e00 	call	82028e0 <fwrite>
         break;
 8200488:	00005e06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 820048c:	d0a00217 	ldw	r2,-32760(gp)
 8200490:	10800317 	ldw	r2,12(r2)
 8200494:	100f883a 	mov	r7,r2
 8200498:	01800b04 	movi	r6,44
 820049c:	01400044 	movi	r5,1
 82004a0:	01020974 	movhi	r4,2085
 82004a4:	212ef204 	addi	r4,r4,-17464
 82004a8:	82028e00 	call	82028e0 <fwrite>
         break;
 82004ac:	00005506 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 82004b0:	d0a00217 	ldw	r2,-32760(gp)
 82004b4:	10800317 	ldw	r2,12(r2)
 82004b8:	100f883a 	mov	r7,r2
 82004bc:	01800884 	movi	r6,34
 82004c0:	01400044 	movi	r5,1
 82004c4:	01020974 	movhi	r4,2085
 82004c8:	212efe04 	addi	r4,r4,-17416
 82004cc:	82028e00 	call	82028e0 <fwrite>
         break;
 82004d0:	00004c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 82004d4:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 82004d8:	d0a00217 	ldw	r2,-32760(gp)
 82004dc:	10800317 	ldw	r2,12(r2)
 82004e0:	100f883a 	mov	r7,r2
 82004e4:	01800bc4 	movi	r6,47
 82004e8:	01400044 	movi	r5,1
 82004ec:	01020974 	movhi	r4,2085
 82004f0:	212f0704 	addi	r4,r4,-17380
 82004f4:	82028e00 	call	82028e0 <fwrite>
         break;
 82004f8:	00004206 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 82004fc:	d0a00217 	ldw	r2,-32760(gp)
 8200500:	10800317 	ldw	r2,12(r2)
 8200504:	100f883a 	mov	r7,r2
 8200508:	018009c4 	movi	r6,39
 820050c:	01400044 	movi	r5,1
 8200510:	01020974 	movhi	r4,2085
 8200514:	212f1304 	addi	r4,r4,-17332
 8200518:	82028e00 	call	82028e0 <fwrite>
         break;
 820051c:	00003906 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_Q_FULL:
         fault_level = NONE;
 8200520:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 8200524:	d0a00217 	ldw	r2,-32760(gp)
 8200528:	10800317 	ldw	r2,12(r2)
 820052c:	100f883a 	mov	r7,r2
 8200530:	01800a84 	movi	r6,42
 8200534:	01400044 	movi	r5,1
 8200538:	01020974 	movhi	r4,2085
 820053c:	212f1d04 	addi	r4,r4,-17292
 8200540:	82028e00 	call	82028e0 <fwrite>
         break;
 8200544:	00002f06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 8200548:	00800044 	movi	r2,1
 820054c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 8200550:	d0a00217 	ldw	r2,-32760(gp)
 8200554:	10800317 	ldw	r2,12(r2)
 8200558:	100f883a 	mov	r7,r2
 820055c:	01800c04 	movi	r6,48
 8200560:	01400044 	movi	r5,1
 8200564:	01020974 	movhi	r4,2085
 8200568:	212f2804 	addi	r4,r4,-17248
 820056c:	82028e00 	call	82028e0 <fwrite>
         break;
 8200570:	00002406 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200574:	00800084 	movi	r2,2
 8200578:	e0bffd15 	stw	r2,-12(fp)
         printf(
 820057c:	01020974 	movhi	r4,2085
 8200580:	212f3504 	addi	r4,r4,-17196
 8200584:	8202e9c0 	call	8202e9c <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 8200588:	d0a00217 	ldw	r2,-32760(gp)
 820058c:	10800317 	ldw	r2,12(r2)
 8200590:	e1bfff17 	ldw	r6,-4(fp)
 8200594:	01420974 	movhi	r5,2085
 8200598:	296f4504 	addi	r5,r5,-17132
 820059c:	1009883a 	mov	r4,r2
 82005a0:	82027f00 	call	82027f0 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 82005a4:	00001706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 82005a8:	01020974 	movhi	r4,2085
 82005ac:	212f5004 	addi	r4,r4,-17088
 82005b0:	82031200 	call	8203120 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 82005b4:	d0a00217 	ldw	r2,-32760(gp)
 82005b8:	10800317 	ldw	r2,12(r2)
 82005bc:	100f883a 	mov	r7,r2
 82005c0:	01800404 	movi	r6,16
 82005c4:	01400044 	movi	r5,1
 82005c8:	01020974 	movhi	r4,2085
 82005cc:	212f5e04 	addi	r4,r4,-17032
 82005d0:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 82005d4:	d0a00217 	ldw	r2,-32760(gp)
 82005d8:	10800317 	ldw	r2,12(r2)
 82005dc:	e0fffe03 	ldbu	r3,-8(fp)
 82005e0:	180d883a 	mov	r6,r3
 82005e4:	01420974 	movhi	r5,2085
 82005e8:	296f6304 	addi	r5,r5,-17012
 82005ec:	1009883a 	mov	r4,r2
 82005f0:	82027f00 	call	82027f0 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 82005f4:	01020974 	movhi	r4,2085
 82005f8:	212f6804 	addi	r4,r4,-16992
 82005fc:	8202e580 	call	8202e58 <perror>
         break;
 8200600:	0001883a 	nop

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 8200604:	e0bffd17 	ldw	r2,-12(fp)
 8200608:	10c00060 	cmpeqi	r3,r2,1
 820060c:	1800041e 	bne	r3,zero,8200620 <alt_uCOSIIErrorHandler+0x3d8>
 8200610:	00803a2e 	bgeu	zero,r2,82006fc <alt_uCOSIIErrorHandler+0x4b4>
 8200614:	108000a0 	cmpeqi	r2,r2,2
 8200618:	10001c1e 	bne	r2,zero,820068c <alt_uCOSIIErrorHandler+0x444>
 820061c:	00005106 	br	8200764 <alt_uCOSIIErrorHandler+0x51c>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 8200620:	01020974 	movhi	r4,2085
 8200624:	212f7604 	addi	r4,r4,-16936
 8200628:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 820062c:	d0a00217 	ldw	r2,-32760(gp)
 8200630:	10800317 	ldw	r2,12(r2)
 8200634:	100f883a 	mov	r7,r2
 8200638:	01800904 	movi	r6,36
 820063c:	01400044 	movi	r5,1
 8200640:	01020974 	movhi	r4,2085
 8200644:	212f8304 	addi	r4,r4,-16884
 8200648:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 820064c:	d0a00217 	ldw	r2,-32760(gp)
 8200650:	10800317 	ldw	r2,12(r2)
 8200654:	100f883a 	mov	r7,r2
 8200658:	01800a04 	movi	r6,40
 820065c:	01400044 	movi	r5,1
 8200660:	01020974 	movhi	r4,2085
 8200664:	212f8d04 	addi	r4,r4,-16844
 8200668:	82028e00 	call	82028e0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 820066c:	82152b00 	call	82152b0 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200670:	01003fc4 	movi	r4,255
 8200674:	821ac200 	call	821ac20 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200678:	e0bffe03 	ldbu	r2,-8(fp)
 820067c:	000b883a 	mov	r5,zero
 8200680:	1009883a 	mov	r4,r2
 8200684:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200688:	00004106 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 820068c:	01020974 	movhi	r4,2085
 8200690:	212f9804 	addi	r4,r4,-16800
 8200694:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 8200698:	d0a00217 	ldw	r2,-32760(gp)
 820069c:	10800317 	ldw	r2,12(r2)
 82006a0:	100f883a 	mov	r7,r2
 82006a4:	01800984 	movi	r6,38
 82006a8:	01400044 	movi	r5,1
 82006ac:	01020974 	movhi	r4,2085
 82006b0:	212fa604 	addi	r4,r4,-16744
 82006b4:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 82006b8:	d0a00217 	ldw	r2,-32760(gp)
 82006bc:	10800317 	ldw	r2,12(r2)
 82006c0:	100f883a 	mov	r7,r2
 82006c4:	01800bc4 	movi	r6,47
 82006c8:	01400044 	movi	r5,1
 82006cc:	01020974 	movhi	r4,2085
 82006d0:	212fb004 	addi	r4,r4,-16704
 82006d4:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 82006d8:	d0a00217 	ldw	r2,-32760(gp)
 82006dc:	10800317 	ldw	r2,12(r2)
 82006e0:	100f883a 	mov	r7,r2
 82006e4:	01800cc4 	movi	r6,51
 82006e8:	01400044 	movi	r5,1
 82006ec:	01020974 	movhi	r4,2085
 82006f0:	212fbc04 	addi	r4,r4,-16656
 82006f4:	82028e00 	call	82028e0 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 82006f8:	003fff06 	br	82006f8 <alt_uCOSIIErrorHandler+0x4b0>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 82006fc:	d0a00217 	ldw	r2,-32760(gp)
 8200700:	10800317 	ldw	r2,12(r2)
 8200704:	100f883a 	mov	r7,r2
 8200708:	01800904 	movi	r6,36
 820070c:	01400044 	movi	r5,1
 8200710:	01020974 	movhi	r4,2085
 8200714:	212fc904 	addi	r4,r4,-16604
 8200718:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 820071c:	d0a00217 	ldw	r2,-32760(gp)
 8200720:	10800317 	ldw	r2,12(r2)
 8200724:	100f883a 	mov	r7,r2
 8200728:	01800c84 	movi	r6,50
 820072c:	01400044 	movi	r5,1
 8200730:	01020974 	movhi	r4,2085
 8200734:	212fd304 	addi	r4,r4,-16564
 8200738:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, 
 820073c:	d0a00217 	ldw	r2,-32760(gp)
 8200740:	10800317 	ldw	r2,12(r2)
 8200744:	100f883a 	mov	r7,r2
 8200748:	01800f84 	movi	r6,62
 820074c:	01400044 	movi	r5,1
 8200750:	01020974 	movhi	r4,2085
 8200754:	212fe004 	addi	r4,r4,-16512
 8200758:	82028e00 	call	82028e0 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 820075c:	82152b00 	call	82152b0 <OSSchedUnlock>
         return;   
 8200760:	00000d06 	br	8200798 <alt_uCOSIIErrorHandler+0x550>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200764:	01020974 	movhi	r4,2085
 8200768:	212ff004 	addi	r4,r4,-16448
 820076c:	82031200 	call	8203120 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 8200770:	d0a00217 	ldw	r2,-32760(gp)
 8200774:	10800317 	ldw	r2,12(r2)
 8200778:	100f883a 	mov	r7,r2
 820077c:	01800ac4 	movi	r6,43
 8200780:	01400044 	movi	r5,1
 8200784:	01020974 	movhi	r4,2085
 8200788:	212ffe04 	addi	r4,r4,-16392
 820078c:	82028e00 	call	82028e0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200790:	003fff06 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
{
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
   {
      return;
 8200794:	0001883a 	nop
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200798:	e037883a 	mov	sp,fp
 820079c:	dfc00117 	ldw	ra,4(sp)
 82007a0:	df000017 	ldw	fp,0(sp)
 82007a4:	dec00204 	addi	sp,sp,8
 82007a8:	f800283a 	ret

082007ac <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 82007ac:	defffb04 	addi	sp,sp,-20
 82007b0:	dfc00415 	stw	ra,16(sp)
 82007b4:	df000315 	stw	fp,12(sp)
 82007b8:	df000304 	addi	fp,sp,12
 82007bc:	2005883a 	mov	r2,r4
 82007c0:	e17fff15 	stw	r5,-4(fp)
 82007c4:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 82007c8:	e0bffe03 	ldbu	r2,-8(fp)
 82007cc:	10008a26 	beq	r2,zero,82009f8 <alt_NetworkErrorHandler+0x24c>
   {
      return;
   }

   fault_level = SYSTEM;   
 82007d0:	00800084 	movi	r2,2
 82007d4:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 82007d8:	82152240 	call	8215224 <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 82007dc:	e0bffe03 	ldbu	r2,-8(fp)
 82007e0:	10803fd8 	cmpnei	r2,r2,255
 82007e4:	1000101e 	bne	r2,zero,8200828 <alt_NetworkErrorHandler+0x7c>
   {
      fault_level = SYSTEM;
 82007e8:	00800084 	movi	r2,2
 82007ec:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 82007f0:	01020974 	movhi	r4,2085
 82007f4:	21300904 	addi	r4,r4,-16348
 82007f8:	8202e9c0 	call	8202e9c <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 82007fc:	d0a00217 	ldw	r2,-32760(gp)
 8200800:	10800317 	ldw	r2,12(r2)
 8200804:	e1bfff17 	ldw	r6,-4(fp)
 8200808:	01420974 	movhi	r5,2085
 820080c:	29701804 	addi	r5,r5,-16288
 8200810:	1009883a 	mov	r4,r2
 8200814:	82027f00 	call	82027f0 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 8200818:	01020974 	movhi	r4,2085
 820081c:	21301c04 	addi	r4,r4,-16272
 8200820:	8202e580 	call	8202e58 <perror>
 8200824:	00001006 	br	8200868 <alt_NetworkErrorHandler+0xbc>
   }
   else 
   {
      fault_level = TASK;
 8200828:	00800044 	movi	r2,1
 820082c:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR.\n");    
 8200830:	01020974 	movhi	r4,2085
 8200834:	21302204 	addi	r4,r4,-16248
 8200838:	82031200 	call	8203120 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 820083c:	d0a00217 	ldw	r2,-32760(gp)
 8200840:	10800317 	ldw	r2,12(r2)
 8200844:	e0fffe03 	ldbu	r3,-8(fp)
 8200848:	180d883a 	mov	r6,r3
 820084c:	01420974 	movhi	r5,2085
 8200850:	29702804 	addi	r5,r5,-16224
 8200854:	1009883a 	mov	r4,r2
 8200858:	82027f00 	call	82027f0 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 820085c:	01020974 	movhi	r4,2085
 8200860:	21301c04 	addi	r4,r4,-16272
 8200864:	8202e580 	call	8202e58 <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200868:	e0bffd17 	ldw	r2,-12(fp)
 820086c:	10c00060 	cmpeqi	r3,r2,1
 8200870:	1800041e 	bne	r3,zero,8200884 <alt_NetworkErrorHandler+0xd8>
 8200874:	00803a2e 	bgeu	zero,r2,8200960 <alt_NetworkErrorHandler+0x1b4>
 8200878:	108000a0 	cmpeqi	r2,r2,2
 820087c:	10001c1e 	bne	r2,zero,82008f0 <alt_NetworkErrorHandler+0x144>
 8200880:	00005106 	br	82009c8 <alt_NetworkErrorHandler+0x21c>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 8200884:	01020974 	movhi	r4,2085
 8200888:	21302f04 	addi	r4,r4,-16196
 820088c:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 8200890:	d0a00217 	ldw	r2,-32760(gp)
 8200894:	10800317 	ldw	r2,12(r2)
 8200898:	100f883a 	mov	r7,r2
 820089c:	018007c4 	movi	r6,31
 82008a0:	01400044 	movi	r5,1
 82008a4:	01020974 	movhi	r4,2085
 82008a8:	21303b04 	addi	r4,r4,-16148
 82008ac:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 82008b0:	d0a00217 	ldw	r2,-32760(gp)
 82008b4:	10800317 	ldw	r2,12(r2)
 82008b8:	100f883a 	mov	r7,r2
 82008bc:	018008c4 	movi	r6,35
 82008c0:	01400044 	movi	r5,1
 82008c4:	01020974 	movhi	r4,2085
 82008c8:	21304304 	addi	r4,r4,-16116
 82008cc:	82028e00 	call	82028e0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 82008d0:	82152b00 	call	82152b0 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 82008d4:	01003fc4 	movi	r4,255
 82008d8:	821ac200 	call	821ac20 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 82008dc:	e0bffe03 	ldbu	r2,-8(fp)
 82008e0:	000b883a 	mov	r5,zero
 82008e4:	1009883a 	mov	r4,r2
 82008e8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 82008ec:	00004106 	br	82009f4 <alt_NetworkErrorHandler+0x248>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 82008f0:	01020974 	movhi	r4,2085
 82008f4:	21304c04 	addi	r4,r4,-16080
 82008f8:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 82008fc:	d0a00217 	ldw	r2,-32760(gp)
 8200900:	10800317 	ldw	r2,12(r2)
 8200904:	100f883a 	mov	r7,r2
 8200908:	01800884 	movi	r6,34
 820090c:	01400044 	movi	r5,1
 8200910:	01020974 	movhi	r4,2085
 8200914:	21305804 	addi	r4,r4,-16032
 8200918:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 820091c:	d0a00217 	ldw	r2,-32760(gp)
 8200920:	10800317 	ldw	r2,12(r2)
 8200924:	100f883a 	mov	r7,r2
 8200928:	01800a84 	movi	r6,42
 820092c:	01400044 	movi	r5,1
 8200930:	01020974 	movhi	r4,2085
 8200934:	21306104 	addi	r4,r4,-15996
 8200938:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 820093c:	d0a00217 	ldw	r2,-32760(gp)
 8200940:	10800317 	ldw	r2,12(r2)
 8200944:	100f883a 	mov	r7,r2
 8200948:	01800b84 	movi	r6,46
 820094c:	01400044 	movi	r5,1
 8200950:	01020974 	movhi	r4,2085
 8200954:	21306c04 	addi	r4,r4,-15952
 8200958:	82028e00 	call	82028e0 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 820095c:	003fff06 	br	820095c <alt_NetworkErrorHandler+0x1b0>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 8200960:	d0a00217 	ldw	r2,-32760(gp)
 8200964:	10800317 	ldw	r2,12(r2)
 8200968:	100f883a 	mov	r7,r2
 820096c:	01800804 	movi	r6,32
 8200970:	01400044 	movi	r5,1
 8200974:	01020974 	movhi	r4,2085
 8200978:	21307804 	addi	r4,r4,-15904
 820097c:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 8200980:	d0a00217 	ldw	r2,-32760(gp)
 8200984:	10800317 	ldw	r2,12(r2)
 8200988:	100f883a 	mov	r7,r2
 820098c:	01800d84 	movi	r6,54
 8200990:	01400044 	movi	r5,1
 8200994:	01020974 	movhi	r4,2085
 8200998:	21308104 	addi	r4,r4,-15868
 820099c:	82028e00 	call	82028e0 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 82009a0:	d0a00217 	ldw	r2,-32760(gp)
 82009a4:	10800317 	ldw	r2,12(r2)
 82009a8:	100f883a 	mov	r7,r2
 82009ac:	01800e44 	movi	r6,57
 82009b0:	01400044 	movi	r5,1
 82009b4:	01020974 	movhi	r4,2085
 82009b8:	21308f04 	addi	r4,r4,-15812
 82009bc:	82028e00 	call	82028e0 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 82009c0:	82152b00 	call	82152b0 <OSSchedUnlock>
         return;
 82009c4:	00000d06 	br	82009fc <alt_NetworkErrorHandler+0x250>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 82009c8:	01020974 	movhi	r4,2085
 82009cc:	21309e04 	addi	r4,r4,-15752
 82009d0:	82031200 	call	8203120 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 82009d4:	d0a00217 	ldw	r2,-32760(gp)
 82009d8:	10800317 	ldw	r2,12(r2)
 82009dc:	100f883a 	mov	r7,r2
 82009e0:	01800984 	movi	r6,38
 82009e4:	01400044 	movi	r5,1
 82009e8:	01020974 	movhi	r4,2085
 82009ec:	2130ab04 	addi	r4,r4,-15700
 82009f0:	82028e00 	call	82028e0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 82009f4:	003fff06 	br	82009f4 <alt_NetworkErrorHandler+0x248>
{
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
   {
      return;
 82009f8:	0001883a 	nop
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 82009fc:	e037883a 	mov	sp,fp
 8200a00:	dfc00117 	ldw	ra,4(sp)
 8200a04:	df000017 	ldw	fp,0(sp)
 8200a08:	dec00204 	addi	sp,sp,8
 8200a0c:	f800283a 	ret

08200a10 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 8200a10:	defffb04 	addi	sp,sp,-20
 8200a14:	dfc00415 	stw	ra,16(sp)
 8200a18:	df000315 	stw	fp,12(sp)
 8200a1c:	df000304 	addi	fp,sp,12
 8200a20:	2005883a 	mov	r2,r4
 8200a24:	e17fff15 	stw	r5,-4(fp)
 8200a28:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 8200a2c:	e0bffe03 	ldbu	r2,-8(fp)
 8200a30:	10009726 	beq	r2,zero,8200c90 <alt_SSSErrorHandler+0x280>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 8200a34:	e0bffe03 	ldbu	r2,-8(fp)
 8200a38:	1000021e 	bne	r2,zero,8200a44 <alt_SSSErrorHandler+0x34>
 8200a3c:	0005883a 	mov	r2,zero
 8200a40:	00000106 	br	8200a48 <alt_SSSErrorHandler+0x38>
 8200a44:	00800084 	movi	r2,2
 8200a48:	e0bffd15 	stw	r2,-12(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200a4c:	82152240 	call	8215224 <OSSchedLock>
   switch (error_code)
 8200a50:	e0bffe03 	ldbu	r2,-8(fp)
 8200a54:	10c007a0 	cmpeqi	r3,r2,30
 8200a58:	18000f1e 	bne	r3,zero,8200a98 <alt_SSSErrorHandler+0x88>
 8200a5c:	10803fe0 	cmpeqi	r2,r2,255
 8200a60:	10001726 	beq	r2,zero,8200ac0 <alt_SSSErrorHandler+0xb0>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200a64:	00800084 	movi	r2,2
 8200a68:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 8200a6c:	01020974 	movhi	r4,2085
 8200a70:	2130b504 	addi	r4,r4,-15660
 8200a74:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 8200a78:	d0a00217 	ldw	r2,-32760(gp)
 8200a7c:	10800317 	ldw	r2,12(r2)
 8200a80:	e1bfff17 	ldw	r6,-4(fp)
 8200a84:	01420974 	movhi	r5,2085
 8200a88:	2970c304 	addi	r5,r5,-15604
 8200a8c:	1009883a 	mov	r4,r2
 8200a90:	82027f00 	call	82027f0 <fprintf>
         break;
 8200a94:	00001a06 	br	8200b00 <alt_SSSErrorHandler+0xf0>
         
      case OS_Q_FULL:
         fault_level = NONE;
 8200a98:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 8200a9c:	d0a00217 	ldw	r2,-32760(gp)
 8200aa0:	10800317 	ldw	r2,12(r2)
 8200aa4:	100f883a 	mov	r7,r2
 8200aa8:	01800c84 	movi	r6,50
 8200aac:	01400044 	movi	r5,1
 8200ab0:	01020974 	movhi	r4,2085
 8200ab4:	2130c604 	addi	r4,r4,-15592
 8200ab8:	82028e00 	call	82028e0 <fwrite>
         break;
 8200abc:	00001006 	br	8200b00 <alt_SSSErrorHandler+0xf0>
      
      default:
         fault_level = SYSTEM;
 8200ac0:	00800084 	movi	r2,2
 8200ac4:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR.\n");    
 8200ac8:	01020974 	movhi	r4,2085
 8200acc:	2130d304 	addi	r4,r4,-15540
 8200ad0:	82031200 	call	8203120 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 8200ad4:	d0a00217 	ldw	r2,-32760(gp)
 8200ad8:	10800317 	ldw	r2,12(r2)
 8200adc:	e0fffe03 	ldbu	r3,-8(fp)
 8200ae0:	180d883a 	mov	r6,r3
 8200ae4:	01420974 	movhi	r5,2085
 8200ae8:	2970d804 	addi	r5,r5,-15520
 8200aec:	1009883a 	mov	r4,r2
 8200af0:	82027f00 	call	82027f0 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 8200af4:	01020974 	movhi	r4,2085
 8200af8:	2130de04 	addi	r4,r4,-15496
 8200afc:	8202e580 	call	8202e58 <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200b00:	e0bffd17 	ldw	r2,-12(fp)
 8200b04:	10c00060 	cmpeqi	r3,r2,1
 8200b08:	1800041e 	bne	r3,zero,8200b1c <alt_SSSErrorHandler+0x10c>
 8200b0c:	00803a2e 	bgeu	zero,r2,8200bf8 <alt_SSSErrorHandler+0x1e8>
 8200b10:	108000a0 	cmpeqi	r2,r2,2
 8200b14:	10001c1e 	bne	r2,zero,8200b88 <alt_SSSErrorHandler+0x178>
 8200b18:	00005106 	br	8200c60 <alt_SSSErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 8200b1c:	01020974 	movhi	r4,2085
 8200b20:	2130e304 	addi	r4,r4,-15476
 8200b24:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 8200b28:	d0a00217 	ldw	r2,-32760(gp)
 8200b2c:	10800317 	ldw	r2,12(r2)
 8200b30:	100f883a 	mov	r7,r2
 8200b34:	018006c4 	movi	r6,27
 8200b38:	01400044 	movi	r5,1
 8200b3c:	01020974 	movhi	r4,2085
 8200b40:	2130ee04 	addi	r4,r4,-15432
 8200b44:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 8200b48:	d0a00217 	ldw	r2,-32760(gp)
 8200b4c:	10800317 	ldw	r2,12(r2)
 8200b50:	100f883a 	mov	r7,r2
 8200b54:	018007c4 	movi	r6,31
 8200b58:	01400044 	movi	r5,1
 8200b5c:	01020974 	movhi	r4,2085
 8200b60:	2130f504 	addi	r4,r4,-15404
 8200b64:	82028e00 	call	82028e0 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 8200b68:	82152b00 	call	82152b0 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200b6c:	01003fc4 	movi	r4,255
 8200b70:	821ac200 	call	821ac20 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200b74:	e0bffe03 	ldbu	r2,-8(fp)
 8200b78:	000b883a 	mov	r5,zero
 8200b7c:	1009883a 	mov	r4,r2
 8200b80:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200b84:	00004106 	br	8200c8c <alt_SSSErrorHandler+0x27c>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 8200b88:	01020974 	movhi	r4,2085
 8200b8c:	2130fd04 	addi	r4,r4,-15372
 8200b90:	8202e9c0 	call	8202e9c <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 8200b94:	d0a00217 	ldw	r2,-32760(gp)
 8200b98:	10800317 	ldw	r2,12(r2)
 8200b9c:	100f883a 	mov	r7,r2
 8200ba0:	01800784 	movi	r6,30
 8200ba4:	01400044 	movi	r5,1
 8200ba8:	01020974 	movhi	r4,2085
 8200bac:	21310804 	addi	r4,r4,-15328
 8200bb0:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 8200bb4:	d0a00217 	ldw	r2,-32760(gp)
 8200bb8:	10800317 	ldw	r2,12(r2)
 8200bbc:	100f883a 	mov	r7,r2
 8200bc0:	01800984 	movi	r6,38
 8200bc4:	01400044 	movi	r5,1
 8200bc8:	01020974 	movhi	r4,2085
 8200bcc:	21311004 	addi	r4,r4,-15296
 8200bd0:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 8200bd4:	d0a00217 	ldw	r2,-32760(gp)
 8200bd8:	10800317 	ldw	r2,12(r2)
 8200bdc:	100f883a 	mov	r7,r2
 8200be0:	01800a84 	movi	r6,42
 8200be4:	01400044 	movi	r5,1
 8200be8:	01020974 	movhi	r4,2085
 8200bec:	21311a04 	addi	r4,r4,-15256
 8200bf0:	82028e00 	call	82028e0 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 8200bf4:	003fff06 	br	8200bf4 <alt_SSSErrorHandler+0x1e4>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 8200bf8:	d0a00217 	ldw	r2,-32760(gp)
 8200bfc:	10800317 	ldw	r2,12(r2)
 8200c00:	100f883a 	mov	r7,r2
 8200c04:	018006c4 	movi	r6,27
 8200c08:	01400044 	movi	r5,1
 8200c0c:	01020974 	movhi	r4,2085
 8200c10:	21312504 	addi	r4,r4,-15212
 8200c14:	82028e00 	call	82028e0 <fwrite>
         fprintf(stderr, 
 8200c18:	d0a00217 	ldw	r2,-32760(gp)
 8200c1c:	10800317 	ldw	r2,12(r2)
 8200c20:	100f883a 	mov	r7,r2
 8200c24:	01800f44 	movi	r6,61
 8200c28:	01400044 	movi	r5,1
 8200c2c:	01020974 	movhi	r4,2085
 8200c30:	21312c04 	addi	r4,r4,-15184
 8200c34:	82028e00 	call	82028e0 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 8200c38:	d0a00217 	ldw	r2,-32760(gp)
 8200c3c:	10800317 	ldw	r2,12(r2)
 8200c40:	100f883a 	mov	r7,r2
 8200c44:	01800b84 	movi	r6,46
 8200c48:	01400044 	movi	r5,1
 8200c4c:	01020974 	movhi	r4,2085
 8200c50:	21313c04 	addi	r4,r4,-15120
 8200c54:	82028e00 	call	82028e0 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 8200c58:	82152b00 	call	82152b0 <OSSchedUnlock>
         return;         
 8200c5c:	00000d06 	br	8200c94 <alt_SSSErrorHandler+0x284>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200c60:	01020974 	movhi	r4,2085
 8200c64:	21314804 	addi	r4,r4,-15072
 8200c68:	82031200 	call	8203120 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 8200c6c:	d0a00217 	ldw	r2,-32760(gp)
 8200c70:	10800317 	ldw	r2,12(r2)
 8200c74:	100f883a 	mov	r7,r2
 8200c78:	01800844 	movi	r6,33
 8200c7c:	01400044 	movi	r5,1
 8200c80:	01020974 	movhi	r4,2085
 8200c84:	21315404 	addi	r4,r4,-15024
 8200c88:	82028e00 	call	82028e0 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200c8c:	003fff06 	br	8200c8c <alt_SSSErrorHandler+0x27c>
{
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
   {
      return;
 8200c90:	0001883a 	nop
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200c94:	e037883a 	mov	sp,fp
 8200c98:	dfc00117 	ldw	ra,4(sp)
 8200c9c:	df000017 	ldw	fp,0(sp)
 8200ca0:	dec00204 	addi	sp,sp,8
 8200ca4:	f800283a 	ret

08200ca8 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 8200ca8:	defffc04 	addi	sp,sp,-16
 8200cac:	dfc00315 	stw	ra,12(sp)
 8200cb0:	df000215 	stw	fp,8(sp)
 8200cb4:	df000204 	addi	fp,sp,8
 8200cb8:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 8200cbc:	822d9140 	call	822d914 <alt_iniche_init>
  netmain(); 
 8200cc0:	8228f240 	call	8228f24 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cc4:	00000206 	br	8200cd0 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 8200cc8:	01000084 	movi	r4,2
 8200ccc:	821bb0c0 	call	821bb0c <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cd0:	d0a08c17 	ldw	r2,-32208(gp)
 8200cd4:	103ffc26 	beq	r2,zero,8200cc8 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 8200cd8:	01020974 	movhi	r4,2085
 8200cdc:	21316304 	addi	r4,r4,-14964
 8200ce0:	82031200 	call	8203120 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 8200ce4:	01020974 	movhi	r4,2085
 8200ce8:	21064904 	addi	r4,r4,6436
 8200cec:	822d5900 	call	822d590 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 8200cf0:	82018d80 	call	82018d8 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 8200cf4:	820197c0 	call	820197c <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 8200cf8:	01003fc4 	movi	r4,255
 8200cfc:	821ac200 	call	821ac20 <OSTaskDel>
 8200d00:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d04:	e0bffe03 	ldbu	r2,-8(fp)
 8200d08:	000b883a 	mov	r5,zero
 8200d0c:	1009883a 	mov	r4,r2
 8200d10:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 8200d14:	003fff06 	br	8200d14 <SSSInitialTask+0x6c>

08200d18 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 8200d18:	defff504 	addi	sp,sp,-44
 8200d1c:	dfc00a15 	stw	ra,40(sp)
 8200d20:	df000915 	stw	fp,36(sp)
 8200d24:	df000904 	addi	fp,sp,36
 8200d28:	e13ffd15 	stw	r4,-12(fp)
 8200d2c:	e17ffe15 	stw	r5,-8(fp)
 8200d30:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 8200d34:	0009883a 	mov	r4,zero
 8200d38:	821bfa00 	call	821bfa0 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 8200d3c:	d8000415 	stw	zero,16(sp)
 8200d40:	d8000315 	stw	zero,12(sp)
 8200d44:	00820004 	movi	r2,2048
 8200d48:	d8800215 	stw	r2,8(sp)
 8200d4c:	00820974 	movhi	r2,2085
 8200d50:	1090ae04 	addi	r2,r2,17080
 8200d54:	d8800115 	stw	r2,4(sp)
 8200d58:	00800144 	movi	r2,5
 8200d5c:	d8800015 	stw	r2,0(sp)
 8200d60:	01c00144 	movi	r7,5
 8200d64:	01820974 	movhi	r6,2085
 8200d68:	3198ae04 	addi	r6,r6,25272
 8200d6c:	000b883a 	mov	r5,zero
 8200d70:	01020834 	movhi	r4,2080
 8200d74:	21032a04 	addi	r4,r4,3240
 8200d78:	821aa3c0 	call	821aa3c <OSTaskCreateExt>
 8200d7c:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d80:	e0bffc03 	ldbu	r2,-16(fp)
 8200d84:	000b883a 	mov	r5,zero
 8200d88:	1009883a 	mov	r4,r2
 8200d8c:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 8200d90:	821538c0 	call	821538c <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 8200d94:	003fff06 	br	8200d94 <main+0x7c>

08200d98 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 8200d98:	defffc04 	addi	sp,sp,-16
 8200d9c:	dfc00315 	stw	ra,12(sp)
 8200da0:	df000215 	stw	fp,8(sp)
 8200da4:	df000204 	addi	fp,sp,8
 8200da8:	2005883a 	mov	r2,r4
 8200dac:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 8200db0:	d0a05c17 	ldw	r2,-32400(gp)
 8200db4:	e0fffe84 	addi	r3,fp,-6
 8200db8:	180b883a 	mov	r5,r3
 8200dbc:	1009883a 	mov	r4,r2
 8200dc0:	8217c4c0 	call	8217c4c <OSFlagQuery>
 8200dc4:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 8200dc8:	e0bffe83 	ldbu	r2,-6(fp)
 8200dcc:	10803fcc 	andi	r2,r2,255
 8200dd0:	000b883a 	mov	r5,zero
 8200dd4:	1009883a 	mov	r4,r2
 8200dd8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 8200ddc:	e0ffff0b 	ldhu	r3,-4(fp)
 8200de0:	e0bffe0b 	ldhu	r2,-8(fp)
 8200de4:	1884703a 	and	r2,r3,r2
 8200de8:	10bfffcc 	andi	r2,r2,65535
 8200dec:	10000f26 	beq	r2,zero,8200e2c <led_bit_toggle+0x94>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 8200df0:	d0a05c17 	ldw	r2,-32400(gp)
 8200df4:	e0ffff0b 	ldhu	r3,-4(fp)
 8200df8:	e13ffe84 	addi	r4,fp,-6
 8200dfc:	200f883a 	mov	r7,r4
 8200e00:	000d883a 	mov	r6,zero
 8200e04:	180b883a 	mov	r5,r3
 8200e08:	1009883a 	mov	r4,r2
 8200e0c:	82178b80 	call	82178b8 <OSFlagPost>
 8200e10:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e14:	e0bffe83 	ldbu	r2,-6(fp)
 8200e18:	10803fcc 	andi	r2,r2,255
 8200e1c:	000b883a 	mov	r5,zero
 8200e20:	1009883a 	mov	r4,r2
 8200e24:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e28:	00000f06 	br	8200e68 <led_bit_toggle+0xd0>
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
       alt_uCOSIIErrorHandler(error_code, 0);
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 8200e2c:	d0a05c17 	ldw	r2,-32400(gp)
 8200e30:	e0ffff0b 	ldhu	r3,-4(fp)
 8200e34:	e13ffe84 	addi	r4,fp,-6
 8200e38:	200f883a 	mov	r7,r4
 8200e3c:	01800044 	movi	r6,1
 8200e40:	180b883a 	mov	r5,r3
 8200e44:	1009883a 	mov	r4,r2
 8200e48:	82178b80 	call	82178b8 <OSFlagPost>
 8200e4c:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e50:	e0bffe83 	ldbu	r2,-6(fp)
 8200e54:	10803fcc 	andi	r2,r2,255
 8200e58:	000b883a 	mov	r5,zero
 8200e5c:	1009883a 	mov	r4,r2
 8200e60:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e64:	0001883a 	nop
}
 8200e68:	e037883a 	mov	sp,fp
 8200e6c:	dfc00117 	ldw	ra,4(sp)
 8200e70:	df000017 	ldw	fp,0(sp)
 8200e74:	dec00204 	addi	sp,sp,8
 8200e78:	f800283a 	ret

08200e7c <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 8200e7c:	defffd04 	addi	sp,sp,-12
 8200e80:	dfc00215 	stw	ra,8(sp)
 8200e84:	df000115 	stw	fp,4(sp)
 8200e88:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 8200e8c:	01c00c84 	movi	r7,50
 8200e90:	000d883a 	mov	r6,zero
 8200e94:	000b883a 	mov	r5,zero
 8200e98:	0009883a 	mov	r4,zero
 8200e9c:	821bc100 	call	821bc10 <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8200ea0:	d0a05b17 	ldw	r2,-32404(gp)
 8200ea4:	e1bfff04 	addi	r6,fp,-4
 8200ea8:	000b883a 	mov	r5,zero
 8200eac:	1009883a 	mov	r4,r2
 8200eb0:	8219d080 	call	8219d08 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 8200eb4:	e0bfff03 	ldbu	r2,-4(fp)
 8200eb8:	10803fcc 	andi	r2,r2,255
 8200ebc:	000b883a 	mov	r5,zero
 8200ec0:	1009883a 	mov	r4,r2
 8200ec4:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 8200ec8:	d0a05b17 	ldw	r2,-32404(gp)
 8200ecc:	1009883a 	mov	r4,r2
 8200ed0:	821a0800 	call	821a080 <OSSemPost>
 8200ed4:	e0bfff05 	stb	r2,-4(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 8200ed8:	e0bfff03 	ldbu	r2,-4(fp)
 8200edc:	10803fcc 	andi	r2,r2,255
 8200ee0:	000b883a 	mov	r5,zero
 8200ee4:	1009883a 	mov	r4,r2
 8200ee8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      
   }
 8200eec:	003fe706 	br	8200e8c <LED7SegLightshowTask+0x10>

08200ef0 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 8200ef0:	defffb04 	addi	sp,sp,-20
 8200ef4:	dfc00415 	stw	ra,16(sp)
 8200ef8:	df000315 	stw	fp,12(sp)
 8200efc:	df000304 	addi	fp,sp,12
  
  INT32U led_command; 
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  SSSLEDLightshowActive = OS_TRUE;
 8200f00:	00800044 	movi	r2,1
 8200f04:	e0bffd05 	stb	r2,-12(fp)
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 8200f08:	d0a05a17 	ldw	r2,-32408(gp)
 8200f0c:	e0ffff04 	addi	r3,fp,-4
 8200f10:	180d883a 	mov	r6,r3
 8200f14:	000b883a 	mov	r5,zero
 8200f18:	1009883a 	mov	r4,r2
 8200f1c:	8218e600 	call	8218e60 <OSQPend>
 8200f20:	e0bffe15 	stw	r2,-8(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 8200f24:	e0bfff03 	ldbu	r2,-4(fp)
 8200f28:	10803fcc 	andi	r2,r2,255
 8200f2c:	000b883a 	mov	r5,zero
 8200f30:	1009883a 	mov	r4,r2
 8200f34:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 8200f38:	e0bffe17 	ldw	r2,-8(fp)
 8200f3c:	10bff404 	addi	r2,r2,-48
 8200f40:	10c00928 	cmpgeui	r3,r2,36
 8200f44:	18005d1e 	bne	r3,zero,82010bc <LEDManagementTask+0x1cc>
 8200f48:	100690ba 	slli	r3,r2,2
 8200f4c:	00820834 	movhi	r2,2080
 8200f50:	1083d804 	addi	r2,r2,3936
 8200f54:	1885883a 	add	r2,r3,r2
 8200f58:	10800017 	ldw	r2,0(r2)
 8200f5c:	1000683a 	jmp	r2
 8200f60:	08200ff0 	cmpltui	zero,at,32831
 8200f64:	08200ffc 	xorhi	zero,at,32831
 8200f68:	08201008 	cmpgei	zero,at,-32704
 8200f6c:	08201014 	ori	zero,at,32832
 8200f70:	08201020 	cmpeqi	zero,at,-32704
 8200f74:	0820102c 	andhi	zero,at,32832
 8200f78:	08201038 	rdprs	zero,at,-32704
 8200f7c:	08201044 	addi	zero,at,-32703
 8200f80:	082010bc 	xorhi	zero,at,32834
 8200f84:	082010bc 	xorhi	zero,at,32834
 8200f88:	082010bc 	xorhi	zero,at,32834
 8200f8c:	082010bc 	xorhi	zero,at,32834
 8200f90:	082010bc 	xorhi	zero,at,32834
 8200f94:	082010bc 	xorhi	zero,at,32834
 8200f98:	082010bc 	xorhi	zero,at,32834
 8200f9c:	082010bc 	xorhi	zero,at,32834
 8200fa0:	082010bc 	xorhi	zero,at,32834
 8200fa4:	082010bc 	xorhi	zero,at,32834
 8200fa8:	082010bc 	xorhi	zero,at,32834
 8200fac:	082010bc 	xorhi	zero,at,32834
 8200fb0:	082010bc 	xorhi	zero,at,32834
 8200fb4:	082010bc 	xorhi	zero,at,32834
 8200fb8:	082010bc 	xorhi	zero,at,32834
 8200fbc:	082010bc 	xorhi	zero,at,32834
 8200fc0:	082010bc 	xorhi	zero,at,32834
 8200fc4:	082010bc 	xorhi	zero,at,32834
 8200fc8:	082010bc 	xorhi	zero,at,32834
 8200fcc:	082010bc 	xorhi	zero,at,32834
 8200fd0:	082010bc 	xorhi	zero,at,32834
 8200fd4:	082010bc 	xorhi	zero,at,32834
 8200fd8:	082010bc 	xorhi	zero,at,32834
 8200fdc:	082010bc 	xorhi	zero,at,32834
 8200fe0:	082010bc 	xorhi	zero,at,32834
 8200fe4:	082010bc 	xorhi	zero,at,32834
 8200fe8:	082010bc 	xorhi	zero,at,32834
 8200fec:	08201050 	cmplti	zero,at,-32703
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 8200ff0:	01000044 	movi	r4,1
 8200ff4:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8200ff8:	00003106 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 8200ffc:	01000084 	movi	r4,2
 8201000:	8200d980 	call	8200d98 <led_bit_toggle>
         break;   
 8201004:	00002e06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 8201008:	01000104 	movi	r4,4
 820100c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201010:	00002b06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 8201014:	01000204 	movi	r4,8
 8201018:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820101c:	00002806 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 8201020:	01000404 	movi	r4,16
 8201024:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201028:	00002506 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 820102c:	01000804 	movi	r4,32
 8201030:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201034:	00002206 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 8201038:	01001004 	movi	r4,64
 820103c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201040:	00001f06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 8201044:	01002004 	movi	r4,128
 8201048:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820104c:	00001c06 	br	82010c0 <LEDManagementTask+0x1d0>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 8201050:	e0bffd03 	ldbu	r2,-12(fp)
 8201054:	10000c1e 	bne	r2,zero,8201088 <LEDManagementTask+0x198>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 8201058:	d0a05b17 	ldw	r2,-32404(gp)
 820105c:	1009883a 	mov	r4,r2
 8201060:	821a0800 	call	821a080 <OSSemPost>
 8201064:	e0bfff05 	stb	r2,-4(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 8201068:	e0bfff03 	ldbu	r2,-4(fp)
 820106c:	10803fcc 	andi	r2,r2,255
 8201070:	000b883a 	mov	r5,zero
 8201074:	1009883a 	mov	r4,r2
 8201078:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 820107c:	00800044 	movi	r2,1
 8201080:	e0bffd05 	stb	r2,-12(fp)
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
             alt_uCOSIIErrorHandler(error_code, 0); 
             SSSLEDLightshowActive = OS_FALSE;
         }     
         break;
 8201084:	00000e06 	br	82010c0 <LEDManagementTask+0x1d0>
             alt_uCOSIIErrorHandler(error_code, 0);
             SSSLEDLightshowActive = OS_TRUE;
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8201088:	d0a05b17 	ldw	r2,-32404(gp)
 820108c:	e0ffff04 	addi	r3,fp,-4
 8201090:	180d883a 	mov	r6,r3
 8201094:	000b883a 	mov	r5,zero
 8201098:	1009883a 	mov	r4,r2
 820109c:	8219d080 	call	8219d08 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 82010a0:	e0bfff03 	ldbu	r2,-4(fp)
 82010a4:	10803fcc 	andi	r2,r2,255
 82010a8:	000b883a 	mov	r5,zero
 82010ac:	1009883a 	mov	r4,r2
 82010b0:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 82010b4:	e03ffd05 	stb	zero,-12(fp)
         }     
         break;
 82010b8:	00000106 	br	82010c0 <LEDManagementTask+0x1d0>
      default:     
        /* Discard unknown LED commands. */
        break;
 82010bc:	0001883a 	nop
    } /* switch led_command */
  } /* while(1) */
 82010c0:	003f9106 	br	8200f08 <LEDManagementTask+0x18>

082010c4 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 82010c4:	defffb04 	addi	sp,sp,-20
 82010c8:	dfc00415 	stw	ra,16(sp)
 82010cc:	df000315 	stw	fp,12(sp)
 82010d0:	df000304 	addi	fp,sp,12
 82010d4:	e13ffe15 	stw	r4,-8(fp)
 82010d8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 82010dc:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 82010e0:	e13fff17 	ldw	r4,-4(fp)
 82010e4:	82016140 	call	8201614 <get_board_mac_addr>
 82010e8:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 82010ec:	e0bffd17 	ldw	r2,-12(fp)
 82010f0:	10000326 	beq	r2,zero,8201100 <get_mac_addr+0x3c>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 82010f4:	e13fff17 	ldw	r4,-4(fp)
 82010f8:	82014d80 	call	82014d8 <generate_mac_addr>
 82010fc:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 8201100:	e0bffd17 	ldw	r2,-12(fp)
}
 8201104:	e037883a 	mov	sp,fp
 8201108:	dfc00117 	ldw	ra,4(sp)
 820110c:	df000017 	ldw	fp,0(sp)
 8201110:	dec00204 	addi	sp,sp,8
 8201114:	f800283a 	ret

08201118 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 8201118:	defffb04 	addi	sp,sp,-20
 820111c:	df000415 	stw	fp,16(sp)
 8201120:	df000404 	addi	fp,sp,16
 8201124:	e13ffc15 	stw	r4,-16(fp)
 8201128:	e17ffd15 	stw	r5,-12(fp)
 820112c:	e1bffe15 	stw	r6,-8(fp)
 8201130:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 8201134:	e0bffd17 	ldw	r2,-12(fp)
 8201138:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 820113c:	e0bfff17 	ldw	r2,-4(fp)
 8201140:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 8201144:	e0fffe17 	ldw	r3,-8(fp)
 8201148:	00804034 	movhi	r2,256
 820114c:	10bfffc4 	addi	r2,r2,-1
 8201150:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 8201154:	e0800117 	ldw	r2,4(fp)
 8201158:	00c00044 	movi	r3,1
 820115c:	10c00015 	stw	r3,0(r2)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 8201160:	00800044 	movi	r2,1
}
 8201164:	e037883a 	mov	sp,fp
 8201168:	df000017 	ldw	fp,0(sp)
 820116c:	dec00104 	addi	sp,sp,4
 8201170:	f800283a 	ret

08201174 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 8201174:	defff904 	addi	sp,sp,-28
 8201178:	dfc00615 	stw	ra,24(sp)
 820117c:	df000515 	stw	fp,20(sp)
 8201180:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 8201184:	e03ffb15 	stw	zero,-20(fp)
    char serial_number[9];
    int i = 0;
 8201188:	e03ffc15 	stw	zero,-16(fp)
    
    while(!ser_num)
 820118c:	00006006 	br	8201310 <get_serial_number+0x19c>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 8201190:	01020974 	movhi	r4,2085
 8201194:	21316c04 	addi	r4,r4,-14928
 8201198:	82031200 	call	8203120 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 820119c:	01020974 	movhi	r4,2085
 82011a0:	21317c04 	addi	r4,r4,-14864
 82011a4:	82031200 	call	8203120 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 82011a8:	01020974 	movhi	r4,2085
 82011ac:	21318c04 	addi	r4,r4,-14800
 82011b0:	8202e9c0 	call	8202e9c <printf>
        
        for(i=0; i<9; i++)
 82011b4:	e03ffc15 	stw	zero,-16(fp)
 82011b8:	00002606 	br	8201254 <get_serial_number+0xe0>
        {
            serial_number[i] = getchar();
 82011bc:	d0a00217 	ldw	r2,-32760(gp)
 82011c0:	10800117 	ldw	r2,4(r2)
 82011c4:	1009883a 	mov	r4,r2
 82011c8:	82029840 	call	8202984 <getc>
 82011cc:	1009883a 	mov	r4,r2
 82011d0:	e0fffd04 	addi	r3,fp,-12
 82011d4:	e0bffc17 	ldw	r2,-16(fp)
 82011d8:	1885883a 	add	r2,r3,r2
 82011dc:	11000005 	stb	r4,0(r2)
            putchar(serial_number[i]);
 82011e0:	e0fffd04 	addi	r3,fp,-12
 82011e4:	e0bffc17 	ldw	r2,-16(fp)
 82011e8:	1885883a 	add	r2,r3,r2
 82011ec:	10800003 	ldbu	r2,0(r2)
 82011f0:	10c03fcc 	andi	r3,r2,255
 82011f4:	18c0201c 	xori	r3,r3,128
 82011f8:	18ffe004 	addi	r3,r3,-128
 82011fc:	d0a00217 	ldw	r2,-32760(gp)
 8201200:	10800217 	ldw	r2,8(r2)
 8201204:	100b883a 	mov	r5,r2
 8201208:	1809883a 	mov	r4,r3
 820120c:	8202f780 	call	8202f78 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 8201210:	e0fffd04 	addi	r3,fp,-12
 8201214:	e0bffc17 	ldw	r2,-16(fp)
 8201218:	1885883a 	add	r2,r3,r2
 820121c:	10800003 	ldbu	r2,0(r2)
 8201220:	10803fcc 	andi	r2,r2,255
 8201224:	1080201c 	xori	r2,r2,128
 8201228:	10bfe004 	addi	r2,r2,-128
 820122c:	10800218 	cmpnei	r2,r2,8
 8201230:	1000051e 	bne	r2,zero,8201248 <get_serial_number+0xd4>
 8201234:	e0bffc17 	ldw	r2,-16(fp)
 8201238:	10000316 	blt	r2,zero,8201248 <get_serial_number+0xd4>
            {
                i--;
 820123c:	e0bffc17 	ldw	r2,-16(fp)
 8201240:	10bfffc4 	addi	r2,r2,-1
 8201244:	e0bffc15 	stw	r2,-16(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 8201248:	e0bffc17 	ldw	r2,-16(fp)
 820124c:	10800044 	addi	r2,r2,1
 8201250:	e0bffc15 	stw	r2,-16(fp)
 8201254:	e0bffc17 	ldw	r2,-16(fp)
 8201258:	10800250 	cmplti	r2,r2,9
 820125c:	103fd71e 	bne	r2,zero,82011bc <get_serial_number+0x48>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 8201260:	01000284 	movi	r4,10
 8201264:	82030480 	call	8203048 <putchar>
                
        for(i=0; i<9; i++)
 8201268:	e03ffc15 	stw	zero,-16(fp)
 820126c:	00002506 	br	8201304 <get_serial_number+0x190>
        {
            if (isdigit(serial_number[i]))
 8201270:	d0e00017 	ldw	r3,-32768(gp)
 8201274:	e13ffd04 	addi	r4,fp,-12
 8201278:	e0bffc17 	ldw	r2,-16(fp)
 820127c:	2085883a 	add	r2,r4,r2
 8201280:	10800003 	ldbu	r2,0(r2)
 8201284:	10803fcc 	andi	r2,r2,255
 8201288:	1080201c 	xori	r2,r2,128
 820128c:	10bfe004 	addi	r2,r2,-128
 8201290:	10800044 	addi	r2,r2,1
 8201294:	1885883a 	add	r2,r3,r2
 8201298:	10800003 	ldbu	r2,0(r2)
 820129c:	10803fcc 	andi	r2,r2,255
 82012a0:	1080010c 	andi	r2,r2,4
 82012a4:	10000f26 	beq	r2,zero,82012e4 <get_serial_number+0x170>
            {
                ser_num *= 10;
 82012a8:	e0bffb17 	ldw	r2,-20(fp)
 82012ac:	108002a4 	muli	r2,r2,10
 82012b0:	e0bffb15 	stw	r2,-20(fp)
                ser_num += serial_number[i] - '0';
 82012b4:	e0fffd04 	addi	r3,fp,-12
 82012b8:	e0bffc17 	ldw	r2,-16(fp)
 82012bc:	1885883a 	add	r2,r3,r2
 82012c0:	10800003 	ldbu	r2,0(r2)
 82012c4:	10c03fcc 	andi	r3,r2,255
 82012c8:	18c0201c 	xori	r3,r3,128
 82012cc:	18ffe004 	addi	r3,r3,-128
 82012d0:	e0bffb17 	ldw	r2,-20(fp)
 82012d4:	1885883a 	add	r2,r3,r2
 82012d8:	10bff404 	addi	r2,r2,-48
 82012dc:	e0bffb15 	stw	r2,-20(fp)
 82012e0:	00000506 	br	82012f8 <get_serial_number+0x184>
            }
            else
            {
                ser_num = 0;
 82012e4:	e03ffb15 	stw	zero,-20(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 82012e8:	01020974 	movhi	r4,2085
 82012ec:	21319a04 	addi	r4,r4,-14744
 82012f0:	82031200 	call	8203120 <puts>
                break;
 82012f4:	00000606 	br	8201310 <get_serial_number+0x19c>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 82012f8:	e0bffc17 	ldw	r2,-16(fp)
 82012fc:	10800044 	addi	r2,r2,1
 8201300:	e0bffc15 	stw	r2,-16(fp)
 8201304:	e0bffc17 	ldw	r2,-16(fp)
 8201308:	10800250 	cmplti	r2,r2,9
 820130c:	103fd81e 	bne	r2,zero,8201270 <get_serial_number+0xfc>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 8201310:	e0bffb17 	ldw	r2,-20(fp)
 8201314:	103f9e26 	beq	r2,zero,8201190 <get_serial_number+0x1c>
                break;
            }
        }
    }
    
    return ser_num;
 8201318:	e0bffb17 	ldw	r2,-20(fp)
}
 820131c:	e037883a 	mov	sp,fp
 8201320:	dfc00117 	ldw	ra,4(sp)
 8201324:	df000017 	ldw	fp,0(sp)
 8201328:	dec00204 	addi	sp,sp,8
 820132c:	f800283a 	ret

08201330 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 8201330:	deffef04 	addi	sp,sp,-68
 8201334:	dfc01015 	stw	ra,64(sp)
 8201338:	df000f15 	stw	fp,60(sp)
 820133c:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 8201340:	00bfffc4 	movi	r2,-1
 8201344:	e0bff115 	stw	r2,-60(fp)
    alt_u32 ser_num = 0;
 8201348:	e03ff215 	stw	zero,-56(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 820134c:	01020974 	movhi	r4,2085
 8201350:	2131a904 	addi	r4,r4,-14684
 8201354:	82031200 	call	8203120 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 8201358:	01020974 	movhi	r4,2085
 820135c:	2131b904 	addi	r4,r4,-14620
 8201360:	82031200 	call	8203120 <puts>
    printf("static network settings\n\n");
 8201364:	01020974 	movhi	r4,2085
 8201368:	2131ca04 	addi	r4,r4,-14552
 820136c:	82031200 	call	8203120 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201370:	0081d734 	movhi	r2,1884
 8201374:	10b34544 	addi	r2,r2,-13035
 8201378:	e0bff215 	stw	r2,-56(fp)
  
    if (ser_num)
 820137c:	e0bff217 	ldw	r2,-56(fp)
 8201380:	10004f26 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 8201384:	00bfff84 	movi	r2,-2
 8201388:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 820138c:	00801684 	movi	r2,90
 8201390:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 8201394:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 8201398:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 820139c:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 82013a0:	008001c4 	movi	r2,7
 82013a4:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 82013a8:	00bffb44 	movi	r2,-19
 82013ac:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 82013b0:	00bfffc4 	movi	r2,-1
 82013b4:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 82013b8:	e0bff217 	ldw	r2,-56(fp)
 82013bc:	10bfc00c 	andi	r2,r2,65280
 82013c0:	1004d23a 	srli	r2,r2,8
 82013c4:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 82013c8:	e0bff217 	ldw	r2,-56(fp)
 82013cc:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 82013d0:	00bfffc4 	movi	r2,-1
 82013d4:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 82013d8:	00bfffc4 	movi	r2,-1
 82013dc:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 82013e0:	e03ffb05 	stb	zero,-20(fp)
        flash_content[13] = IPADDR1;
 82013e4:	e03ffb45 	stb	zero,-19(fp)
        flash_content[14] = IPADDR2;
 82013e8:	e03ffb85 	stb	zero,-18(fp)
        flash_content[15] = IPADDR3;
 82013ec:	e03ffbc5 	stb	zero,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 82013f0:	00bfffc4 	movi	r2,-1
 82013f4:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 82013f8:	00bfffc4 	movi	r2,-1
 82013fc:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 8201400:	00bfffc4 	movi	r2,-1
 8201404:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 8201408:	00bfffc4 	movi	r2,-1
 820140c:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 8201410:	00bfffc4 	movi	r2,-1
 8201414:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 8201418:	00bfffc4 	movi	r2,-1
 820141c:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 8201420:	00bfffc4 	movi	r2,-1
 8201424:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 8201428:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 820142c:	e03ffe05 	stb	zero,-8(fp)
        flash_content[25] = GWADDR1;
 8201430:	e03ffe45 	stb	zero,-7(fp)
        flash_content[26] = GWADDR2;
 8201434:	e03ffe85 	stb	zero,-6(fp)
        flash_content[27] = GWADDR3;
 8201438:	e03ffec5 	stb	zero,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 820143c:	00bfffc4 	movi	r2,-1
 8201440:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 8201444:	00bfffc4 	movi	r2,-1
 8201448:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 820144c:	00bfffc4 	movi	r2,-1
 8201450:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 8201454:	00bfffc4 	movi	r2,-1
 8201458:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 820145c:	01020974 	movhi	r4,2085
 8201460:	2131d104 	addi	r4,r4,-14524
 8201464:	8213ecc0 	call	8213ecc <alt_flash_open_dev>
 8201468:	e0bff315 	stw	r2,-52(fp)
        if (flash_handle)
 820146c:	e0bff317 	ldw	r2,-52(fp)
 8201470:	10001326 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
        {
            alt_write_flash(flash_handle,
 8201474:	d0a05717 	ldw	r2,-32420(gp)
 8201478:	1007883a 	mov	r3,r2
 820147c:	e0bff317 	ldw	r2,-52(fp)
 8201480:	e0bff415 	stw	r2,-48(fp)
 8201484:	e0fff515 	stw	r3,-44(fp)
 8201488:	e0bff804 	addi	r2,fp,-32
 820148c:	e0bff615 	stw	r2,-40(fp)
 8201490:	00800804 	movi	r2,32
 8201494:	e0bff715 	stw	r2,-36(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 8201498:	e0bff417 	ldw	r2,-48(fp)
 820149c:	10800517 	ldw	r2,20(r2)
 82014a0:	e1fff717 	ldw	r7,-36(fp)
 82014a4:	e1bff617 	ldw	r6,-40(fp)
 82014a8:	e17ff517 	ldw	r5,-44(fp)
 82014ac:	e13ff417 	ldw	r4,-48(fp)
 82014b0:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 82014b4:	e13ff317 	ldw	r4,-52(fp)
 82014b8:	8213f340 	call	8213f34 <alt_flash_close_dev>
            error = 0;
 82014bc:	e03ff115 	stw	zero,-60(fp)
        }
    }

    return error;    
 82014c0:	e0bff117 	ldw	r2,-60(fp)
}
 82014c4:	e037883a 	mov	sp,fp
 82014c8:	dfc00117 	ldw	ra,4(sp)
 82014cc:	df000017 	ldw	fp,0(sp)
 82014d0:	dec00204 	addi	sp,sp,8
 82014d4:	f800283a 	ret

082014d8 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 82014d8:	defff804 	addi	sp,sp,-32
 82014dc:	dfc00715 	stw	ra,28(sp)
 82014e0:	df000615 	stw	fp,24(sp)
 82014e4:	df000604 	addi	fp,sp,24
 82014e8:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 82014ec:	00bfffc4 	movi	r2,-1
 82014f0:	e0bffd15 	stw	r2,-12(fp)
    alt_u32 ser_num = 0;
 82014f4:	e03ffe15 	stw	zero,-8(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 82014f8:	01020974 	movhi	r4,2085
 82014fc:	2131d504 	addi	r4,r4,-14508
 8201500:	82031200 	call	8203120 <puts>
    printf("a MAC address.\n\n");
 8201504:	01020974 	movhi	r4,2085
 8201508:	2131e504 	addi	r4,r4,-14444
 820150c:	82031200 	call	8203120 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201510:	0081d734 	movhi	r2,1884
 8201514:	10b34544 	addi	r2,r2,-13035
 8201518:	e0bffe15 	stw	r2,-8(fp)
  
    if (ser_num)
 820151c:	e0bffe17 	ldw	r2,-8(fp)
 8201520:	10003626 	beq	r2,zero,82015fc <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 8201524:	e0bfff17 	ldw	r2,-4(fp)
 8201528:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 820152c:	e0bfff17 	ldw	r2,-4(fp)
 8201530:	10800044 	addi	r2,r2,1
 8201534:	00c001c4 	movi	r3,7
 8201538:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = 0xed;
 820153c:	e0bfff17 	ldw	r2,-4(fp)
 8201540:	10800084 	addi	r2,r2,2
 8201544:	00fffb44 	movi	r3,-19
 8201548:	10c00005 	stb	r3,0(r2)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 820154c:	e0bfff17 	ldw	r2,-4(fp)
 8201550:	108000c4 	addi	r2,r2,3
 8201554:	00ffffc4 	movi	r3,-1
 8201558:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 820155c:	e0bfff17 	ldw	r2,-4(fp)
 8201560:	10800104 	addi	r2,r2,4
 8201564:	e0fffe17 	ldw	r3,-8(fp)
 8201568:	18ffc00c 	andi	r3,r3,65280
 820156c:	1806d23a 	srli	r3,r3,8
 8201570:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = ser_num & 0xff;
 8201574:	e0bfff17 	ldw	r2,-4(fp)
 8201578:	10800144 	addi	r2,r2,5
 820157c:	e0fffe17 	ldw	r3,-8(fp)
 8201580:	10c00005 	stb	r3,0(r2)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201584:	e0bfff17 	ldw	r2,-4(fp)
 8201588:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820158c:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 8201590:	e0bfff17 	ldw	r2,-4(fp)
 8201594:	10800044 	addi	r2,r2,1
 8201598:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820159c:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 82015a0:	e0bfff17 	ldw	r2,-4(fp)
 82015a4:	10800084 	addi	r2,r2,2
 82015a8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015ac:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 82015b0:	e0bfff17 	ldw	r2,-4(fp)
 82015b4:	108000c4 	addi	r2,r2,3
 82015b8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015bc:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 82015c0:	e0ffff17 	ldw	r3,-4(fp)
 82015c4:	18c00104 	addi	r3,r3,4
 82015c8:	18c00003 	ldbu	r3,0(r3)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015cc:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 82015d0:	e13fff17 	ldw	r4,-4(fp)
 82015d4:	21000144 	addi	r4,r4,5
 82015d8:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015dc:	21003fcc 	andi	r4,r4,255
 82015e0:	d9000215 	stw	r4,8(sp)
 82015e4:	d8c00115 	stw	r3,4(sp)
 82015e8:	d8800015 	stw	r2,0(sp)
 82015ec:	01020974 	movhi	r4,2085
 82015f0:	2131e904 	addi	r4,r4,-14428
 82015f4:	8202e9c0 	call	8202e9c <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 82015f8:	e03ffd15 	stw	zero,-12(fp)
    }
  
    return error;    
 82015fc:	e0bffd17 	ldw	r2,-12(fp)
}
 8201600:	e037883a 	mov	sp,fp
 8201604:	dfc00117 	ldw	ra,4(sp)
 8201608:	df000017 	ldw	fp,0(sp)
 820160c:	dec00204 	addi	sp,sp,8
 8201610:	f800283a 	ret

08201614 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 8201614:	defff804 	addi	sp,sp,-32
 8201618:	dfc00715 	stw	ra,28(sp)
 820161c:	df000615 	stw	fp,24(sp)
 8201620:	df000604 	addi	fp,sp,24
 8201624:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 8201628:	e03ffd15 	stw	zero,-12(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 820162c:	d1205704 	addi	r4,gp,-32420
 8201630:	82017ac0 	call	82017ac <FindLastFlashSectorOffset>
 8201634:	e0bffd15 	stw	r2,-12(fp)
    if (!error)
 8201638:	e0bffd17 	ldw	r2,-12(fp)
 820163c:	1000021e 	bne	r2,zero,8201648 <get_board_mac_addr+0x34>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 8201640:	d0a05717 	ldw	r2,-32420(gp)
 8201644:	d0a05815 	stw	r2,-32416(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 8201648:	e0bffd17 	ldw	r2,-12(fp)
 820164c:	1000081e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 8201650:	d0a05817 	ldw	r2,-32416(gp)
 8201654:	10800037 	ldwio	r2,0(r2)
 8201658:	e0bffe15 	stw	r2,-8(fp)
        if (signature != 0x00005afe)
 820165c:	e0bffe17 	ldw	r2,-8(fp)
 8201660:	1096bfa0 	cmpeqi	r2,r2,23294
 8201664:	1000021e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
        {
          error = generate_and_store_mac_addr();
 8201668:	82013300 	call	8201330 <generate_and_store_mac_addr>
 820166c:	e0bffd15 	stw	r2,-12(fp)
        }
    }
  
    if (!error)
 8201670:	e0bffd17 	ldw	r2,-12(fp)
 8201674:	1000471e 	bne	r2,zero,8201794 <get_board_mac_addr+0x180>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 8201678:	d0a05817 	ldw	r2,-32416(gp)
 820167c:	10800104 	addi	r2,r2,4
 8201680:	10800023 	ldbuio	r2,0(r2)
 8201684:	10803fcc 	andi	r2,r2,255
 8201688:	1007883a 	mov	r3,r2
 820168c:	e0bfff17 	ldw	r2,-4(fp)
 8201690:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 8201694:	e0bfff17 	ldw	r2,-4(fp)
 8201698:	10800044 	addi	r2,r2,1
 820169c:	d0e05817 	ldw	r3,-32416(gp)
 82016a0:	18c00144 	addi	r3,r3,5
 82016a4:	18c00023 	ldbuio	r3,0(r3)
 82016a8:	18c03fcc 	andi	r3,r3,255
 82016ac:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 82016b0:	e0bfff17 	ldw	r2,-4(fp)
 82016b4:	10800084 	addi	r2,r2,2
 82016b8:	d0e05817 	ldw	r3,-32416(gp)
 82016bc:	18c00184 	addi	r3,r3,6
 82016c0:	18c00023 	ldbuio	r3,0(r3)
 82016c4:	18c03fcc 	andi	r3,r3,255
 82016c8:	10c00005 	stb	r3,0(r2)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 82016cc:	e0bfff17 	ldw	r2,-4(fp)
 82016d0:	108000c4 	addi	r2,r2,3
 82016d4:	d0e05817 	ldw	r3,-32416(gp)
 82016d8:	18c001c4 	addi	r3,r3,7
 82016dc:	18c00023 	ldbuio	r3,0(r3)
 82016e0:	18c03fcc 	andi	r3,r3,255
 82016e4:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 82016e8:	e0bfff17 	ldw	r2,-4(fp)
 82016ec:	10800104 	addi	r2,r2,4
 82016f0:	d0e05817 	ldw	r3,-32416(gp)
 82016f4:	18c00204 	addi	r3,r3,8
 82016f8:	18c00023 	ldbuio	r3,0(r3)
 82016fc:	18c03fcc 	andi	r3,r3,255
 8201700:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 8201704:	e0bfff17 	ldw	r2,-4(fp)
 8201708:	10800144 	addi	r2,r2,5
 820170c:	d0e05817 	ldw	r3,-32416(gp)
 8201710:	18c00244 	addi	r3,r3,9
 8201714:	18c00023 	ldbuio	r3,0(r3)
 8201718:	18c03fcc 	andi	r3,r3,255
 820171c:	10c00005 	stb	r3,0(r2)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201720:	e0bfff17 	ldw	r2,-4(fp)
 8201724:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201728:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 820172c:	e0bfff17 	ldw	r2,-4(fp)
 8201730:	10800044 	addi	r2,r2,1
 8201734:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201738:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 820173c:	e0bfff17 	ldw	r2,-4(fp)
 8201740:	10800084 	addi	r2,r2,2
 8201744:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201748:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 820174c:	e0bfff17 	ldw	r2,-4(fp)
 8201750:	108000c4 	addi	r2,r2,3
 8201754:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201758:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 820175c:	e0ffff17 	ldw	r3,-4(fp)
 8201760:	18c00104 	addi	r3,r3,4
 8201764:	18c00003 	ldbu	r3,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201768:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 820176c:	e13fff17 	ldw	r4,-4(fp)
 8201770:	21000144 	addi	r4,r4,5
 8201774:	21000003 	ldbu	r4,0(r4)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201778:	21003fcc 	andi	r4,r4,255
 820177c:	d9000215 	stw	r4,8(sp)
 8201780:	d8c00115 	stw	r3,4(sp)
 8201784:	d8800015 	stw	r2,0(sp)
 8201788:	01020974 	movhi	r4,2085
 820178c:	2131e904 	addi	r4,r4,-14428
 8201790:	8202e9c0 	call	8202e9c <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 8201794:	e0bffd17 	ldw	r2,-12(fp)
}
 8201798:	e037883a 	mov	sp,fp
 820179c:	dfc00117 	ldw	ra,4(sp)
 82017a0:	df000017 	ldw	fp,0(sp)
 82017a4:	dec00204 	addi	sp,sp,8
 82017a8:	f800283a 	ret

082017ac <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 82017ac:	defff304 	addi	sp,sp,-52
 82017b0:	dfc00c15 	stw	ra,48(sp)
 82017b4:	df000b15 	stw	fp,44(sp)
 82017b8:	df000b04 	addi	fp,sp,44
 82017bc:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 82017c0:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 82017c4:	01020974 	movhi	r4,2085
 82017c8:	2131d104 	addi	r4,r4,-14524
 82017cc:	8213ecc0 	call	8213ecc <alt_flash_open_dev>
 82017d0:	e0bff915 	stw	r2,-28(fp)
    if (fd <= 0)
 82017d4:	e0bff917 	ldw	r2,-28(fp)
 82017d8:	1000021e 	bne	r2,zero,82017e4 <FindLastFlashSectorOffset+0x38>
        error = -1;
 82017dc:	00bfffc4 	movi	r2,-1
 82017e0:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 82017e4:	e0bff817 	ldw	r2,-32(fp)
 82017e8:	10000d1e 	bne	r2,zero,8201820 <FindLastFlashSectorOffset+0x74>
 82017ec:	e0bff917 	ldw	r2,-28(fp)
 82017f0:	e0bffa15 	stw	r2,-24(fp)
 82017f4:	e0bffd04 	addi	r2,fp,-12
 82017f8:	e0bffb15 	stw	r2,-20(fp)
 82017fc:	e0bffe04 	addi	r2,fp,-8
 8201800:	e0bffc15 	stw	r2,-16(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 8201804:	e0bffa17 	ldw	r2,-24(fp)
 8201808:	10800717 	ldw	r2,28(r2)
 820180c:	e1bffc17 	ldw	r6,-16(fp)
 8201810:	e17ffb17 	ldw	r5,-20(fp)
 8201814:	e13ffa17 	ldw	r4,-24(fp)
 8201818:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 820181c:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 8201820:	e0bff817 	ldw	r2,-32(fp)
 8201824:	1000211e 	bne	r2,zero,82018ac <FindLastFlashSectorOffset+0x100>
    {
        pLastRegion = &(regions[0]);
 8201828:	e0bffd17 	ldw	r2,-12(fp)
 820182c:	e0bff515 	stw	r2,-44(fp)
        for (n = 1; n < numRegions; n++)
 8201830:	00800044 	movi	r2,1
 8201834:	e0bff715 	stw	r2,-36(fp)
 8201838:	00001006 	br	820187c <FindLastFlashSectorOffset+0xd0>
        {
            if (regions[n].offset > pLastRegion->offset)
 820183c:	e0fffd17 	ldw	r3,-12(fp)
 8201840:	e0bff717 	ldw	r2,-36(fp)
 8201844:	1004913a 	slli	r2,r2,4
 8201848:	1885883a 	add	r2,r3,r2
 820184c:	10800017 	ldw	r2,0(r2)
 8201850:	e0fff517 	ldw	r3,-44(fp)
 8201854:	18c00017 	ldw	r3,0(r3)
 8201858:	1880050e 	bge	r3,r2,8201870 <FindLastFlashSectorOffset+0xc4>
                pLastRegion = &(regions[n]);
 820185c:	e0fffd17 	ldw	r3,-12(fp)
 8201860:	e0bff717 	ldw	r2,-36(fp)
 8201864:	1004913a 	slli	r2,r2,4
 8201868:	1885883a 	add	r2,r3,r2
 820186c:	e0bff515 	stw	r2,-44(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 8201870:	e0bff717 	ldw	r2,-36(fp)
 8201874:	10800044 	addi	r2,r2,1
 8201878:	e0bff715 	stw	r2,-36(fp)
 820187c:	e0bffe17 	ldw	r2,-8(fp)
 8201880:	e0fff717 	ldw	r3,-36(fp)
 8201884:	18bfed16 	blt	r3,r2,820183c <FindLastFlashSectorOffset+0x90>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 8201888:	e0bff517 	ldw	r2,-44(fp)
 820188c:	10c00017 	ldw	r3,0(r2)
                                + pLastRegion->region_size
 8201890:	e0bff517 	ldw	r2,-44(fp)
 8201894:	10800117 	ldw	r2,4(r2)
 8201898:	1887883a 	add	r3,r3,r2
                                - pLastRegion->block_size;
 820189c:	e0bff517 	ldw	r2,-44(fp)
 82018a0:	10800317 	ldw	r2,12(r2)
        for (n = 1; n < numRegions; n++)
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 82018a4:	1885c83a 	sub	r2,r3,r2
 82018a8:	e0bff615 	stw	r2,-40(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 82018ac:	e0bff817 	ldw	r2,-32(fp)
 82018b0:	1000031e 	bne	r2,zero,82018c0 <FindLastFlashSectorOffset+0x114>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 82018b4:	e0fff617 	ldw	r3,-40(fp)
 82018b8:	e0bfff17 	ldw	r2,-4(fp)
 82018bc:	10c00015 	stw	r3,0(r2)

    return (error);
 82018c0:	e0bff817 	ldw	r2,-32(fp)
}
 82018c4:	e037883a 	mov	sp,fp
 82018c8:	dfc00117 	ldw	ra,4(sp)
 82018cc:	df000017 	ldw	fp,0(sp)
 82018d0:	dec00204 	addi	sp,sp,8
 82018d4:	f800283a 	ret

082018d8 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 82018d8:	defffd04 	addi	sp,sp,-12
 82018dc:	dfc00215 	stw	ra,8(sp)
 82018e0:	df000115 	stw	fp,4(sp)
 82018e4:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 82018e8:	01400784 	movi	r5,30
 82018ec:	010209b4 	movhi	r4,2086
 82018f0:	2120ae04 	addi	r4,r4,-32072
 82018f4:	821897c0 	call	821897c <OSQCreate>
 82018f8:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 82018fc:	d0a05a17 	ldw	r2,-32408(gp)
 8201900:	1000041e 	bne	r2,zero,8201914 <SSSCreateOSDataStructs+0x3c>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201904:	01420974 	movhi	r5,2085
 8201908:	2971f804 	addi	r5,r5,-14368
 820190c:	01003fc4 	movi	r4,255
 8201910:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 8201914:	01000044 	movi	r4,1
 8201918:	82199f00 	call	82199f0 <OSSemCreate>
 820191c:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 8201920:	d0a05b17 	ldw	r2,-32404(gp)
 8201924:	1000041e 	bne	r2,zero,8201938 <SSSCreateOSDataStructs+0x60>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201928:	01420974 	movhi	r5,2085
 820192c:	29720104 	addi	r5,r5,-14332
 8201930:	01003fc4 	movi	r4,255
 8201934:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 8201938:	e17fff04 	addi	r5,fp,-4
 820193c:	0009883a 	mov	r4,zero
 8201940:	8216cdc0 	call	8216cdc <OSFlagCreate>
 8201944:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 8201948:	d0a05c17 	ldw	r2,-32400(gp)
 820194c:	1000051e 	bne	r2,zero,8201964 <SSSCreateOSDataStructs+0x8c>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 8201950:	e0bfff03 	ldbu	r2,-4(fp)
 8201954:	10803fcc 	andi	r2,r2,255
 8201958:	000b883a 	mov	r5,zero
 820195c:	1009883a 	mov	r4,r2
 8201960:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  }
}
 8201964:	0001883a 	nop
 8201968:	e037883a 	mov	sp,fp
 820196c:	dfc00117 	ldw	ra,4(sp)
 8201970:	df000017 	ldw	fp,0(sp)
 8201974:	dec00204 	addi	sp,sp,8
 8201978:	f800283a 	ret

0820197c <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 820197c:	defff804 	addi	sp,sp,-32
 8201980:	dfc00715 	stw	ra,28(sp)
 8201984:	df000615 	stw	fp,24(sp)
 8201988:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 820198c:	d8000415 	stw	zero,16(sp)
 8201990:	d8000315 	stw	zero,12(sp)
 8201994:	00820004 	movi	r2,2048
 8201998:	d8800215 	stw	r2,8(sp)
 820199c:	00820974 	movhi	r2,2085
 82019a0:	1098ae04 	addi	r2,r2,25272
 82019a4:	d8800115 	stw	r2,4(sp)
 82019a8:	00800484 	movi	r2,18
 82019ac:	d8800015 	stw	r2,0(sp)
 82019b0:	01c00484 	movi	r7,18
 82019b4:	018209b4 	movhi	r6,2086
 82019b8:	31a0ad04 	addi	r6,r6,-32076
 82019bc:	000b883a 	mov	r5,zero
 82019c0:	01020834 	movhi	r4,2080
 82019c4:	21039f04 	addi	r4,r4,3708
 82019c8:	821aa3c0 	call	821aa3c <OSTaskCreateExt>
 82019cc:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 82019d0:	e0bfff03 	ldbu	r2,-4(fp)
 82019d4:	000b883a 	mov	r5,zero
 82019d8:	1009883a 	mov	r4,r2
 82019dc:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 82019e0:	d8000415 	stw	zero,16(sp)
 82019e4:	d8000315 	stw	zero,12(sp)
 82019e8:	00820004 	movi	r2,2048
 82019ec:	d8800215 	stw	r2,8(sp)
 82019f0:	008209b4 	movhi	r2,2086
 82019f4:	10a0cc04 	addi	r2,r2,-31952
 82019f8:	d8800115 	stw	r2,4(sp)
 82019fc:	008001c4 	movi	r2,7
 8201a00:	d8800015 	stw	r2,0(sp)
 8201a04:	01c001c4 	movi	r7,7
 8201a08:	018209b4 	movhi	r6,2086
 8201a0c:	31a8cb04 	addi	r6,r6,-23764
 8201a10:	000b883a 	mov	r5,zero
 8201a14:	01020834 	movhi	r4,2080
 8201a18:	2103bc04 	addi	r4,r4,3824
 8201a1c:	821aa3c0 	call	821aa3c <OSTaskCreateExt>
 8201a20:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 8201a24:	e0bfff03 	ldbu	r2,-4(fp)
 8201a28:	000b883a 	mov	r5,zero
 8201a2c:	1009883a 	mov	r4,r2
 8201a30:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

}
 8201a34:	0001883a 	nop
 8201a38:	e037883a 	mov	sp,fp
 8201a3c:	dfc00117 	ldw	ra,4(sp)
 8201a40:	df000017 	ldw	fp,0(sp)
 8201a44:	dec00204 	addi	sp,sp,8
 8201a48:	f800283a 	ret

08201a4c <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 8201a4c:	defffd04 	addi	sp,sp,-12
 8201a50:	dfc00215 	stw	ra,8(sp)
 8201a54:	df000115 	stw	fp,4(sp)
 8201a58:	df000104 	addi	fp,sp,4
 8201a5c:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 8201a60:	01817c04 	movi	r6,1520
 8201a64:	000b883a 	mov	r5,zero
 8201a68:	e13fff17 	ldw	r4,-4(fp)
 8201a6c:	8202cb00 	call	8202cb0 <memset>

  conn->fd = -1;
 8201a70:	e0bfff17 	ldw	r2,-4(fp)
 8201a74:	00ffffc4 	movi	r3,-1
 8201a78:	10c00115 	stw	r3,4(r2)
  conn->state = READY;
 8201a7c:	e0bfff17 	ldw	r2,-4(fp)
 8201a80:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 8201a84:	e0bfff17 	ldw	r2,-4(fp)
 8201a88:	10c00304 	addi	r3,r2,12
 8201a8c:	e0bfff17 	ldw	r2,-4(fp)
 8201a90:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 8201a94:	e0bfff17 	ldw	r2,-4(fp)
 8201a98:	10c00304 	addi	r3,r2,12
 8201a9c:	e0bfff17 	ldw	r2,-4(fp)
 8201aa0:	10c17a15 	stw	r3,1512(r2)
  return;
 8201aa4:	0001883a 	nop
}
 8201aa8:	e037883a 	mov	sp,fp
 8201aac:	dfc00117 	ldw	ra,4(sp)
 8201ab0:	df000017 	ldw	fp,0(sp)
 8201ab4:	dec00204 	addi	sp,sp,8
 8201ab8:	f800283a 	ret

08201abc <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 8201abc:	defe8504 	addi	sp,sp,-1516
 8201ac0:	dfc17a15 	stw	ra,1512(sp)
 8201ac4:	df017915 	stw	fp,1508(sp)
 8201ac8:	df017904 	addi	fp,sp,1508
 8201acc:	e13fff15 	stw	r4,-4(fp)
  char  tx_buf[SSS_TX_BUF_SIZE];
  char *tx_wr_pos = tx_buf;
 8201ad0:	e0be8804 	addi	r2,fp,-1504
 8201ad4:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201ad8:	e0fe8717 	ldw	r3,-1508(fp)
 8201adc:	00820974 	movhi	r2,2085
 8201ae0:	10b20b04 	addi	r2,r2,-14292
 8201ae4:	1009883a 	mov	r4,r2
 8201ae8:	00800904 	movi	r2,36
 8201aec:	100d883a 	mov	r6,r2
 8201af0:	200b883a 	mov	r5,r4
 8201af4:	1809883a 	mov	r4,r3
 8201af8:	8202a0c0 	call	8202a0c <memcpy>
 8201afc:	008008c4 	movi	r2,35
 8201b00:	1007883a 	mov	r3,r2
 8201b04:	e0be8717 	ldw	r2,-1508(fp)
 8201b08:	10c5883a 	add	r2,r2,r3
 8201b0c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Nios II Simple Socket Server Menu\n\r");
 8201b10:	e0fe8717 	ldw	r3,-1508(fp)
 8201b14:	00820974 	movhi	r2,2085
 8201b18:	10b21404 	addi	r2,r2,-14256
 8201b1c:	1009883a 	mov	r4,r2
 8201b20:	00800904 	movi	r2,36
 8201b24:	100d883a 	mov	r6,r2
 8201b28:	200b883a 	mov	r5,r4
 8201b2c:	1809883a 	mov	r4,r3
 8201b30:	8202a0c0 	call	8202a0c <memcpy>
 8201b34:	008008c4 	movi	r2,35
 8201b38:	1007883a 	mov	r3,r2
 8201b3c:	e0be8717 	ldw	r2,-1508(fp)
 8201b40:	10c5883a 	add	r2,r2,r3
 8201b44:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201b48:	e0fe8717 	ldw	r3,-1508(fp)
 8201b4c:	00820974 	movhi	r2,2085
 8201b50:	10b20b04 	addi	r2,r2,-14292
 8201b54:	1009883a 	mov	r4,r2
 8201b58:	00800904 	movi	r2,36
 8201b5c:	100d883a 	mov	r6,r2
 8201b60:	200b883a 	mov	r5,r4
 8201b64:	1809883a 	mov	r4,r3
 8201b68:	8202a0c0 	call	8202a0c <memcpy>
 8201b6c:	008008c4 	movi	r2,35
 8201b70:	1007883a 	mov	r3,r2
 8201b74:	e0be8717 	ldw	r2,-1508(fp)
 8201b78:	10c5883a 	add	r2,r2,r3
 8201b7c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"0-7: Toggle board LEDs D0 - D7\n\r");
 8201b80:	e0fe8717 	ldw	r3,-1508(fp)
 8201b84:	00820974 	movhi	r2,2085
 8201b88:	10b21d04 	addi	r2,r2,-14220
 8201b8c:	1009883a 	mov	r4,r2
 8201b90:	00800844 	movi	r2,33
 8201b94:	100d883a 	mov	r6,r2
 8201b98:	200b883a 	mov	r5,r4
 8201b9c:	1809883a 	mov	r4,r3
 8201ba0:	8202a0c0 	call	8202a0c <memcpy>
 8201ba4:	00800804 	movi	r2,32
 8201ba8:	1007883a 	mov	r3,r2
 8201bac:	e0be8717 	ldw	r2,-1508(fp)
 8201bb0:	10c5883a 	add	r2,r2,r3
 8201bb4:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"S: 7-Segment LED Light Show\n\r");
 8201bb8:	e0fe8717 	ldw	r3,-1508(fp)
 8201bbc:	00820974 	movhi	r2,2085
 8201bc0:	10b22604 	addi	r2,r2,-14184
 8201bc4:	1009883a 	mov	r4,r2
 8201bc8:	00800784 	movi	r2,30
 8201bcc:	100d883a 	mov	r6,r2
 8201bd0:	200b883a 	mov	r5,r4
 8201bd4:	1809883a 	mov	r4,r3
 8201bd8:	8202a0c0 	call	8202a0c <memcpy>
 8201bdc:	00800744 	movi	r2,29
 8201be0:	1007883a 	mov	r3,r2
 8201be4:	e0be8717 	ldw	r2,-1508(fp)
 8201be8:	10c5883a 	add	r2,r2,r3
 8201bec:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Q: Terminate session\n\r");
 8201bf0:	e0fe8717 	ldw	r3,-1508(fp)
 8201bf4:	00820974 	movhi	r2,2085
 8201bf8:	10b22e04 	addi	r2,r2,-14152
 8201bfc:	1009883a 	mov	r4,r2
 8201c00:	008005c4 	movi	r2,23
 8201c04:	100d883a 	mov	r6,r2
 8201c08:	200b883a 	mov	r5,r4
 8201c0c:	1809883a 	mov	r4,r3
 8201c10:	8202a0c0 	call	8202a0c <memcpy>
 8201c14:	00800584 	movi	r2,22
 8201c18:	1007883a 	mov	r3,r2
 8201c1c:	e0be8717 	ldw	r2,-1508(fp)
 8201c20:	10c5883a 	add	r2,r2,r3
 8201c24:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201c28:	e0fe8717 	ldw	r3,-1508(fp)
 8201c2c:	00820974 	movhi	r2,2085
 8201c30:	10b20b04 	addi	r2,r2,-14292
 8201c34:	1009883a 	mov	r4,r2
 8201c38:	00800904 	movi	r2,36
 8201c3c:	100d883a 	mov	r6,r2
 8201c40:	200b883a 	mov	r5,r4
 8201c44:	1809883a 	mov	r4,r3
 8201c48:	8202a0c0 	call	8202a0c <memcpy>
 8201c4c:	008008c4 	movi	r2,35
 8201c50:	1007883a 	mov	r3,r2
 8201c54:	e0be8717 	ldw	r2,-1508(fp)
 8201c58:	10c5883a 	add	r2,r2,r3
 8201c5c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 8201c60:	e0fe8717 	ldw	r3,-1508(fp)
 8201c64:	00820974 	movhi	r2,2085
 8201c68:	10b23404 	addi	r2,r2,-14128
 8201c6c:	1009883a 	mov	r4,r2
 8201c70:	00800904 	movi	r2,36
 8201c74:	100d883a 	mov	r6,r2
 8201c78:	200b883a 	mov	r5,r4
 8201c7c:	1809883a 	mov	r4,r3
 8201c80:	8202a0c0 	call	8202a0c <memcpy>
 8201c84:	008008c4 	movi	r2,35
 8201c88:	1007883a 	mov	r3,r2
 8201c8c:	e0be8717 	ldw	r2,-1508(fp)
 8201c90:	10c5883a 	add	r2,r2,r3
 8201c94:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 8201c98:	e0bfff17 	ldw	r2,-4(fp)
 8201c9c:	11000117 	ldw	r4,4(r2)
 8201ca0:	e0fe8717 	ldw	r3,-1508(fp)
 8201ca4:	e0be8804 	addi	r2,fp,-1504
 8201ca8:	1887c83a 	sub	r3,r3,r2
 8201cac:	e0be8804 	addi	r2,fp,-1504
 8201cb0:	000f883a 	mov	r7,zero
 8201cb4:	180d883a 	mov	r6,r3
 8201cb8:	100b883a 	mov	r5,r2
 8201cbc:	82311a40 	call	82311a4 <t_send>
  
  return;
 8201cc0:	0001883a 	nop
}
 8201cc4:	e037883a 	mov	sp,fp
 8201cc8:	dfc00117 	ldw	ra,4(sp)
 8201ccc:	df000017 	ldw	fp,0(sp)
 8201cd0:	dec00204 	addi	sp,sp,8
 8201cd4:	f800283a 	ret

08201cd8 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 8201cd8:	defff604 	addi	sp,sp,-40
 8201cdc:	dfc00915 	stw	ra,36(sp)
 8201ce0:	df000815 	stw	fp,32(sp)
 8201ce4:	df000804 	addi	fp,sp,32
 8201ce8:	e13ffe15 	stw	r4,-8(fp)
 8201cec:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 8201cf0:	00800404 	movi	r2,16
 8201cf4:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 8201cf8:	e0bfff17 	ldw	r2,-4(fp)
 8201cfc:	10800117 	ldw	r2,4(r2)
 8201d00:	10bfffd8 	cmpnei	r2,r2,-1
 8201d04:	10001a1e 	bne	r2,zero,8201d70 <sss_handle_accept+0x98>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 8201d08:	e0fff904 	addi	r3,fp,-28
 8201d0c:	e0bffa04 	addi	r2,fp,-24
 8201d10:	180d883a 	mov	r6,r3
 8201d14:	100b883a 	mov	r5,r2
 8201d18:	e13ffe17 	ldw	r4,-8(fp)
 8201d1c:	82278bc0 	call	82278bc <bsd_accept>
 8201d20:	e0bff815 	stw	r2,-32(fp)
 8201d24:	e0bff817 	ldw	r2,-32(fp)
 8201d28:	1000050e 	bge	r2,zero,8201d40 <sss_handle_accept+0x68>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 8201d2c:	01420974 	movhi	r5,2085
 8201d30:	29723d04 	addi	r5,r5,-14092
 8201d34:	01003fc4 	movi	r4,255
 8201d38:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201d3c:	00001306 	br	8201d8c <sss_handle_accept+0xb4>
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 8201d40:	e0bfff17 	ldw	r2,-4(fp)
 8201d44:	e0fff817 	ldw	r3,-32(fp)
 8201d48:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 8201d4c:	e13fff17 	ldw	r4,-4(fp)
 8201d50:	8201abc0 	call	8201abc <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 8201d54:	e13ffb17 	ldw	r4,-20(fp)
 8201d58:	8227f640 	call	8227f64 <bsd_inet_ntoa>
 8201d5c:	100b883a 	mov	r5,r2
 8201d60:	01020974 	movhi	r4,2085
 8201d64:	21324604 	addi	r4,r4,-14056
 8201d68:	8202e9c0 	call	8202e9c <printf>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201d6c:	00000706 	br	8201d8c <sss_handle_accept+0xb4>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 8201d70:	e13ffb17 	ldw	r4,-20(fp)
 8201d74:	8227f640 	call	8227f64 <bsd_inet_ntoa>
 8201d78:	100b883a 	mov	r5,r2
 8201d7c:	01020974 	movhi	r4,2085
 8201d80:	21325504 	addi	r4,r4,-13996
 8201d84:	8202e9c0 	call	8202e9c <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201d88:	0001883a 	nop
}
 8201d8c:	e037883a 	mov	sp,fp
 8201d90:	dfc00117 	ldw	ra,4(sp)
 8201d94:	df000017 	ldw	fp,0(sp)
 8201d98:	dec00204 	addi	sp,sp,8
 8201d9c:	f800283a 	ret

08201da0 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 8201da0:	defb9104 	addi	sp,sp,-4540
 8201da4:	dfc46e15 	stw	ra,4536(sp)
 8201da8:	df046d15 	stw	fp,4532(sp)
 8201dac:	df046d04 	addi	fp,sp,4532
 8201db0:	e13fff15 	stw	r4,-4(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 8201db4:	e0bfff17 	ldw	r2,-4(fp)
 8201db8:	10817b17 	ldw	r2,1516(r2)
 8201dbc:	1007883a 	mov	r3,r2
 8201dc0:	e0bfff17 	ldw	r2,-4(fp)
 8201dc4:	10817a17 	ldw	r2,1512(r2)
 8201dc8:	1885c83a 	sub	r2,r3,r2
 8201dcc:	e0bb9315 	stw	r2,-4532(fp)

   char  tx_buf[SSS_TX_BUF_SIZE];
   char *tx_wr_pos = tx_buf;
 8201dd0:	e0bb9a04 	addi	r2,fp,-4504
 8201dd4:	e0bb9415 	stw	r2,-4528(fp)

   char text_buf[SSS_TX_BUF_SIZE];
   char *text = text_buf;
 8201dd8:	e0bd1104 	addi	r2,fp,-3004
 8201ddc:	e0bb9515 	stw	r2,-4524(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 8201de0:	00800c04 	movi	r2,48
 8201de4:	d0a05915 	stw	r2,-32412(gp)



   while(bytes_to_process--)
 8201de8:	00002206 	br	8201e74 <sss_exec_command+0xd4>
   {
      SSSCommand = tolower(*(conn->rx_rd_pos++));
 8201dec:	e0bfff17 	ldw	r2,-4(fp)
 8201df0:	10817a17 	ldw	r2,1512(r2)
 8201df4:	11000044 	addi	r4,r2,1
 8201df8:	e0ffff17 	ldw	r3,-4(fp)
 8201dfc:	19017a15 	stw	r4,1512(r3)
 8201e00:	10800003 	ldbu	r2,0(r2)
 8201e04:	e0bb9885 	stb	r2,-4510(fp)
 8201e08:	d0e00017 	ldw	r3,-32768(gp)
 8201e0c:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e10:	10800044 	addi	r2,r2,1
 8201e14:	1885883a 	add	r2,r3,r2
 8201e18:	10800003 	ldbu	r2,0(r2)
 8201e1c:	10803fcc 	andi	r2,r2,255
 8201e20:	108000cc 	andi	r2,r2,3
 8201e24:	10800058 	cmpnei	r2,r2,1
 8201e28:	1000031e 	bne	r2,zero,8201e38 <sss_exec_command+0x98>
 8201e2c:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e30:	10800804 	addi	r2,r2,32
 8201e34:	00000106 	br	8201e3c <sss_exec_command+0x9c>
 8201e38:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e3c:	d0a05915 	stw	r2,-32412(gp)

	  text += sprintf(text,"%c",(char)SSSCommand);
 8201e40:	d0a05917 	ldw	r2,-32412(gp)
 8201e44:	10803fcc 	andi	r2,r2,255
 8201e48:	1080201c 	xori	r2,r2,128
 8201e4c:	10bfe004 	addi	r2,r2,-128
 8201e50:	100d883a 	mov	r6,r2
 8201e54:	01420974 	movhi	r5,2085
 8201e58:	29726404 	addi	r5,r5,-13936
 8201e5c:	e13b9517 	ldw	r4,-4524(fp)
 8201e60:	82032140 	call	8203214 <sprintf>
 8201e64:	1007883a 	mov	r3,r2
 8201e68:	e0bb9517 	ldw	r2,-4524(fp)
 8201e6c:	10c5883a 	add	r2,r2,r3
 8201e70:	e0bb9515 	stw	r2,-4524(fp)
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;



   while(bytes_to_process--)
 8201e74:	e0bb9317 	ldw	r2,-4532(fp)
 8201e78:	10ffffc4 	addi	r3,r2,-1
 8201e7c:	e0fb9315 	stw	r3,-4532(fp)
 8201e80:	103fda1e 	bne	r2,zero,8201dec <sss_exec_command+0x4c>

	  text += sprintf(text,"%c",(char)SSSCommand);

   }

   alt_u8 message = 'N';
 8201e84:	00801384 	movi	r2,78
 8201e88:	e0bb9605 	stb	r2,-4520(fp)

   if(strstr(text_buf, "acquire") != NULL){
 8201e8c:	e0bd1104 	addi	r2,fp,-3004
 8201e90:	01420974 	movhi	r5,2085
 8201e94:	29726504 	addi	r5,r5,-13932
 8201e98:	1009883a 	mov	r4,r2
 8201e9c:	8203fa80 	call	8203fa8 <strstr>
 8201ea0:	10000326 	beq	r2,zero,8201eb0 <sss_exec_command+0x110>
	   message = 'A';
 8201ea4:	00801044 	movi	r2,65
 8201ea8:	e0bb9605 	stb	r2,-4520(fp)
 8201eac:	00006506 	br	8202044 <sss_exec_command+0x2a4>

   } else if( strstr(text_buf, "delay") != NULL){
 8201eb0:	e0bd1104 	addi	r2,fp,-3004
 8201eb4:	01420974 	movhi	r5,2085
 8201eb8:	29726704 	addi	r5,r5,-13924
 8201ebc:	1009883a 	mov	r4,r2
 8201ec0:	8203fa80 	call	8203fa8 <strstr>
 8201ec4:	10001426 	beq	r2,zero,8201f18 <sss_exec_command+0x178>
	   printf("Sending delay signal\n");
 8201ec8:	01020974 	movhi	r4,2085
 8201ecc:	21326904 	addi	r4,r4,-13916
 8201ed0:	82031200 	call	8203120 <puts>
	   tx_wr_pos += sprintf(tx_wr_pos, "Toggling delay\n");
 8201ed4:	e0fb9417 	ldw	r3,-4528(fp)
 8201ed8:	00820974 	movhi	r2,2085
 8201edc:	10b26f04 	addi	r2,r2,-13892
 8201ee0:	1009883a 	mov	r4,r2
 8201ee4:	00800404 	movi	r2,16
 8201ee8:	100d883a 	mov	r6,r2
 8201eec:	200b883a 	mov	r5,r4
 8201ef0:	1809883a 	mov	r4,r3
 8201ef4:	8202a0c0 	call	8202a0c <memcpy>
 8201ef8:	008003c4 	movi	r2,15
 8201efc:	1007883a 	mov	r3,r2
 8201f00:	e0bb9417 	ldw	r2,-4528(fp)
 8201f04:	10c5883a 	add	r2,r2,r3
 8201f08:	e0bb9415 	stw	r2,-4528(fp)
	   message = 'D';
 8201f0c:	00801104 	movi	r2,68
 8201f10:	e0bb9605 	stb	r2,-4520(fp)
 8201f14:	00004b06 	br	8202044 <sss_exec_command+0x2a4>


   } else if( strstr(text_buf, "triggerslope") != NULL){
 8201f18:	e0bd1104 	addi	r2,fp,-3004
 8201f1c:	01420974 	movhi	r5,2085
 8201f20:	29727304 	addi	r5,r5,-13876
 8201f24:	1009883a 	mov	r4,r2
 8201f28:	8203fa80 	call	8203fa8 <strstr>
 8201f2c:	10001426 	beq	r2,zero,8201f80 <sss_exec_command+0x1e0>
	   printf("Sending trigger slope signal\n");
 8201f30:	01020974 	movhi	r4,2085
 8201f34:	21327704 	addi	r4,r4,-13860
 8201f38:	82031200 	call	8203120 <puts>
	   tx_wr_pos += sprintf(tx_wr_pos, "Toggling trigger slope\n");
 8201f3c:	e0fb9417 	ldw	r3,-4528(fp)
 8201f40:	00820974 	movhi	r2,2085
 8201f44:	10b27f04 	addi	r2,r2,-13828
 8201f48:	1009883a 	mov	r4,r2
 8201f4c:	00800604 	movi	r2,24
 8201f50:	100d883a 	mov	r6,r2
 8201f54:	200b883a 	mov	r5,r4
 8201f58:	1809883a 	mov	r4,r3
 8201f5c:	8202a0c0 	call	8202a0c <memcpy>
 8201f60:	008005c4 	movi	r2,23
 8201f64:	1007883a 	mov	r3,r2
 8201f68:	e0bb9417 	ldw	r2,-4528(fp)
 8201f6c:	10c5883a 	add	r2,r2,r3
 8201f70:	e0bb9415 	stw	r2,-4528(fp)
	   message = 'S';
 8201f74:	008014c4 	movi	r2,83
 8201f78:	e0bb9605 	stb	r2,-4520(fp)
 8201f7c:	00003106 	br	8202044 <sss_exec_command+0x2a4>
   } else if( strstr(text_buf, "triggersource") != NULL){
 8201f80:	e0bd1104 	addi	r2,fp,-3004
 8201f84:	01420974 	movhi	r5,2085
 8201f88:	29728504 	addi	r5,r5,-13804
 8201f8c:	1009883a 	mov	r4,r2
 8201f90:	8203fa80 	call	8203fa8 <strstr>
 8201f94:	10001426 	beq	r2,zero,8201fe8 <sss_exec_command+0x248>
  	   printf("Sending trigger source signal\n");
 8201f98:	01020974 	movhi	r4,2085
 8201f9c:	21328904 	addi	r4,r4,-13788
 8201fa0:	82031200 	call	8203120 <puts>
	   tx_wr_pos += sprintf(tx_wr_pos, "Toggling trigger source\n");
 8201fa4:	e0fb9417 	ldw	r3,-4528(fp)
 8201fa8:	00820974 	movhi	r2,2085
 8201fac:	10b29104 	addi	r2,r2,-13756
 8201fb0:	1009883a 	mov	r4,r2
 8201fb4:	00800644 	movi	r2,25
 8201fb8:	100d883a 	mov	r6,r2
 8201fbc:	200b883a 	mov	r5,r4
 8201fc0:	1809883a 	mov	r4,r3
 8201fc4:	8202a0c0 	call	8202a0c <memcpy>
 8201fc8:	00800604 	movi	r2,24
 8201fcc:	1007883a 	mov	r3,r2
 8201fd0:	e0bb9417 	ldw	r2,-4528(fp)
 8201fd4:	10c5883a 	add	r2,r2,r3
 8201fd8:	e0bb9415 	stw	r2,-4528(fp)
	   message = 'T';
 8201fdc:	00801504 	movi	r2,84
 8201fe0:	e0bb9605 	stb	r2,-4520(fp)
 8201fe4:	00001706 	br	8202044 <sss_exec_command+0x2a4>
   } else if ( strstr(text_buf, "quit") != NULL){
 8201fe8:	e0bd1104 	addi	r2,fp,-3004
 8201fec:	01420974 	movhi	r5,2085
 8201ff0:	29729804 	addi	r5,r5,-13728
 8201ff4:	1009883a 	mov	r4,r2
 8201ff8:	8203fa80 	call	8203fa8 <strstr>
 8201ffc:	10001126 	beq	r2,zero,8202044 <sss_exec_command+0x2a4>
	   tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 8202000:	e0fb9417 	ldw	r3,-4528(fp)
 8202004:	00820974 	movhi	r2,2085
 8202008:	10b29a04 	addi	r2,r2,-13720
 820200c:	1009883a 	mov	r4,r2
 8202010:	008006c4 	movi	r2,27
 8202014:	100d883a 	mov	r6,r2
 8202018:	200b883a 	mov	r5,r4
 820201c:	1809883a 	mov	r4,r3
 8202020:	8202a0c0 	call	8202a0c <memcpy>
 8202024:	00800684 	movi	r2,26
 8202028:	1007883a 	mov	r3,r2
 820202c:	e0bb9417 	ldw	r2,-4528(fp)
 8202030:	10c5883a 	add	r2,r2,r3
 8202034:	e0bb9415 	stw	r2,-4528(fp)
	   conn->close = 1;
 8202038:	e0bfff17 	ldw	r2,-4(fp)
 820203c:	00c00044 	movi	r3,1
 8202040:	10c00215 	stw	r3,8(r2)
   }


   if(message=='A'){
 8202044:	e0bb9603 	ldbu	r2,-4520(fp)
 8202048:	10801058 	cmpnei	r2,r2,65
 820204c:	1000651e 	bne	r2,zero,82021e4 <sss_exec_command+0x444>
	   //send the acquire signal
	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, message);
 8202050:	e0fb9603 	ldbu	r3,-4520(fp)
 8202054:	00824034 	movhi	r2,2304
 8202058:	10801004 	addi	r2,r2,64
 820205c:	10c00035 	stwio	r3,0(r2)

	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;
 8202060:	e0be8804 	addi	r2,fp,-1504
 8202064:	e0bb9715 	stw	r2,-4516(fp)



	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8202068:	00800044 	movi	r2,1
 820206c:	e0bb980d 	sth	r2,-4512(fp)
 8202070:	00002e06 	br	820212c <sss_exec_command+0x38c>

		   //request the ith sample of the waveform
		   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, i);
 8202074:	e0fb980b 	ldhu	r3,-4512(fp)
 8202078:	00824034 	movhi	r2,2304
 820207c:	10801804 	addi	r2,r2,96
 8202080:	10c00035 	stwio	r3,0(r2)

		   usleep(1);
 8202084:	01000044 	movi	r4,1
 8202088:	82143d00 	call	82143d0 <usleep>

		   alt_u16 sample = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 820208c:	00824034 	movhi	r2,2304
 8202090:	10801404 	addi	r2,r2,80
 8202094:	10800037 	ldwio	r2,0(r2)
 8202098:	e0bb990d 	sth	r2,-4508(fp)

		   //printf("%d\t", i);
		   //printf("%d\n", sample);

		   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\n", sample);
 820209c:	e0bb990b 	ldhu	r2,-4508(fp)
 82020a0:	100d883a 	mov	r6,r2
 82020a4:	01420974 	movhi	r5,2085
 82020a8:	2972a104 	addi	r5,r5,-13692
 82020ac:	e13b9717 	ldw	r4,-4516(fp)
 82020b0:	82032140 	call	8203214 <sprintf>
 82020b4:	1007883a 	mov	r3,r2
 82020b8:	e0bb9717 	ldw	r2,-4516(fp)
 82020bc:	10c5883a 	add	r2,r2,r3
 82020c0:	e0bb9715 	stw	r2,-4516(fp)

		   //send data every 100 samples.
		   if(i%100==0){
 82020c4:	e0bb980b 	ldhu	r2,-4512(fp)
 82020c8:	01401904 	movi	r5,100
 82020cc:	1009883a 	mov	r4,r2
 82020d0:	82027700 	call	8202770 <__umodsi3>
 82020d4:	10bfffcc 	andi	r2,r2,65535
 82020d8:	1000111e 	bne	r2,zero,8202120 <sss_exec_command+0x380>
			   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 82020dc:	e0bfff17 	ldw	r2,-4(fp)
 82020e0:	11000117 	ldw	r4,4(r2)
 82020e4:	e0fb9717 	ldw	r3,-4516(fp)
 82020e8:	e0be8804 	addi	r2,fp,-1504
 82020ec:	1887c83a 	sub	r3,r3,r2
 82020f0:	e0be8804 	addi	r2,fp,-1504
 82020f4:	000f883a 	mov	r7,zero
 82020f8:	180d883a 	mov	r6,r3
 82020fc:	100b883a 	mov	r5,r2
 8202100:	82311a40 	call	82311a4 <t_send>

			   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202104:	e0be8804 	addi	r2,fp,-1504
 8202108:	01817704 	movi	r6,1500
 820210c:	000b883a 	mov	r5,zero
 8202110:	1009883a 	mov	r4,r2
 8202114:	8202cb00 	call	8202cb0 <memset>
			   tx_wr_pos_data = tx_buf_data;
 8202118:	e0be8804 	addi	r2,fp,-1504
 820211c:	e0bb9715 	stw	r2,-4516(fp)
	   char *tx_wr_pos_data = tx_buf_data;



	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8202120:	e0bb980b 	ldhu	r2,-4512(fp)
 8202124:	10800044 	addi	r2,r2,1
 8202128:	e0bb980d 	sth	r2,-4512(fp)
 820212c:	e0bb980b 	ldhu	r2,-4512(fp)
 8202130:	1080fa70 	cmpltui	r2,r2,1001
 8202134:	103fcf1e 	bne	r2,zero,8202074 <sss_exec_command+0x2d4>
			   tx_wr_pos_data = tx_buf_data;

		   }

	   }
	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 1001);
 8202138:	00c0fa44 	movi	r3,1001
 820213c:	00824034 	movhi	r2,2304
 8202140:	10801804 	addi	r2,r2,96
 8202144:	10c00035 	stwio	r3,0(r2)
	   usleep(1);
 8202148:	01000044 	movi	r4,1
 820214c:	82143d00 	call	82143d0 <usleep>
	   alt_u16 waveNum = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8202150:	00824034 	movhi	r2,2304
 8202154:	10801404 	addi	r2,r2,80
 8202158:	10800037 	ldwio	r2,0(r2)
 820215c:	e0bb998d 	sth	r2,-4506(fp)
	   //printf("%d\n", waveNum);

	   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202160:	e0be8804 	addi	r2,fp,-1504
 8202164:	01817704 	movi	r6,1500
 8202168:	000b883a 	mov	r5,zero
 820216c:	1009883a 	mov	r4,r2
 8202170:	8202cb00 	call	8202cb0 <memset>
	   tx_wr_pos_data = tx_buf_data;
 8202174:	e0be8804 	addi	r2,fp,-1504
 8202178:	e0bb9715 	stw	r2,-4516(fp)

	   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\ncomplete\n",waveNum);
 820217c:	e0bb998b 	ldhu	r2,-4506(fp)
 8202180:	100d883a 	mov	r6,r2
 8202184:	01420974 	movhi	r5,2085
 8202188:	2972a204 	addi	r5,r5,-13688
 820218c:	e13b9717 	ldw	r4,-4516(fp)
 8202190:	82032140 	call	8203214 <sprintf>
 8202194:	1007883a 	mov	r3,r2
 8202198:	e0bb9717 	ldw	r2,-4516(fp)
 820219c:	10c5883a 	add	r2,r2,r3
 82021a0:	e0bb9715 	stw	r2,-4516(fp)

	   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 82021a4:	e0bfff17 	ldw	r2,-4(fp)
 82021a8:	11000117 	ldw	r4,4(r2)
 82021ac:	e0fb9717 	ldw	r3,-4516(fp)
 82021b0:	e0be8804 	addi	r2,fp,-1504
 82021b4:	1887c83a 	sub	r3,r3,r2
 82021b8:	e0be8804 	addi	r2,fp,-1504
 82021bc:	000f883a 	mov	r7,zero
 82021c0:	180d883a 	mov	r6,r3
 82021c4:	100b883a 	mov	r5,r2
 82021c8:	82311a40 	call	82311a4 <t_send>

	   //reset the control pio
	   message=0;
 82021cc:	e03b9605 	stb	zero,-4520(fp)
	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, message);
 82021d0:	e0fb9603 	ldbu	r3,-4520(fp)
 82021d4:	00824034 	movhi	r2,2304
 82021d8:	10801004 	addi	r2,r2,64
 82021dc:	10c00035 	stwio	r3,0(r2)
 82021e0:	00000a06 	br	820220c <sss_exec_command+0x46c>


   } else if(message!='N'){
 82021e4:	e0bb9603 	ldbu	r2,-4520(fp)
 82021e8:	108013a0 	cmpeqi	r2,r2,78
 82021ec:	1000071e 	bne	r2,zero,820220c <sss_exec_command+0x46c>
	   printf("sending message\n");
 82021f0:	01020974 	movhi	r4,2085
 82021f4:	2132a604 	addi	r4,r4,-13672
 82021f8:	82031200 	call	8203120 <puts>
	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, message);
 82021fc:	e0fb9603 	ldbu	r3,-4520(fp)
 8202200:	00824034 	movhi	r2,2304
 8202204:	10801004 	addi	r2,r2,64
 8202208:	10c00035 	stwio	r3,0(r2)
   }


   if(strstr(text_buf, "sam") != NULL){
 820220c:	e0bd1104 	addi	r2,fp,-3004
 8202210:	01420974 	movhi	r5,2085
 8202214:	2972aa04 	addi	r5,r5,-13656
 8202218:	1009883a 	mov	r4,r2
 820221c:	8203fa80 	call	8203fa8 <strstr>
 8202220:	10000326 	beq	r2,zero,8202230 <sss_exec_command+0x490>
	   printf("Hello Sam!");
 8202224:	01020974 	movhi	r4,2085
 8202228:	2132ab04 	addi	r4,r4,-13652
 820222c:	8202e9c0 	call	8202e9c <printf>
   }



  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 8202230:	e0bfff17 	ldw	r2,-4(fp)
 8202234:	11000117 	ldw	r4,4(r2)
 8202238:	e0fb9417 	ldw	r3,-4528(fp)
 820223c:	e0bb9a04 	addi	r2,fp,-4504
 8202240:	1887c83a 	sub	r3,r3,r2
 8202244:	e0bb9a04 	addi	r2,fp,-4504
 8202248:	000f883a 	mov	r7,zero
 820224c:	180d883a 	mov	r6,r3
 8202250:	100b883a 	mov	r5,r2
 8202254:	82311a40 	call	82311a4 <t_send>
  
  return;
 8202258:	0001883a 	nop
}
 820225c:	e037883a 	mov	sp,fp
 8202260:	dfc00117 	ldw	ra,4(sp)
 8202264:	df000017 	ldw	fp,0(sp)
 8202268:	dec00204 	addi	sp,sp,8
 820226c:	f800283a 	ret

08202270 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 8202270:	defffa04 	addi	sp,sp,-24
 8202274:	dfc00515 	stw	ra,20(sp)
 8202278:	df000415 	stw	fp,16(sp)
 820227c:	df000404 	addi	fp,sp,16
 8202280:	e13fff15 	stw	r4,-4(fp)
  int data_used = 0, rx_code = 0;
 8202284:	e03ffc15 	stw	zero,-16(fp)
 8202288:	e03ffd15 	stw	zero,-12(fp)
  char *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 820228c:	e0bfff17 	ldw	r2,-4(fp)
 8202290:	10c00304 	addi	r3,r2,12
 8202294:	e0bfff17 	ldw	r2,-4(fp)
 8202298:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 820229c:	e0bfff17 	ldw	r2,-4(fp)
 82022a0:	10c00304 	addi	r3,r2,12
 82022a4:	e0bfff17 	ldw	r2,-4(fp)
 82022a8:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 82022ac:	01020974 	movhi	r4,2085
 82022b0:	2132ae04 	addi	r4,r4,-13640
 82022b4:	82031200 	call	8203120 <puts>
  
  while(conn->state != CLOSE)
 82022b8:	00005606 	br	8202414 <sss_handle_receive+0x1a4>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr((const char*)conn->rx_buffer, '\n');
 82022bc:	e0bfff17 	ldw	r2,-4(fp)
 82022c0:	10800304 	addi	r2,r2,12
 82022c4:	01400284 	movi	r5,10
 82022c8:	1009883a 	mov	r4,r2
 82022cc:	82032800 	call	8203280 <strchr>
 82022d0:	e0bffe15 	stw	r2,-8(fp)
      
    if(lf_addr)
 82022d4:	e0bffe17 	ldw	r2,-8(fp)
 82022d8:	10000326 	beq	r2,zero,82022e8 <sss_handle_receive+0x78>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 82022dc:	e13fff17 	ldw	r4,-4(fp)
 82022e0:	8201da00 	call	8201da0 <sss_exec_command>
 82022e4:	00001c06 	br	8202358 <sss_handle_receive+0xe8>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, (char*)conn->rx_wr_pos, 
 82022e8:	e0bfff17 	ldw	r2,-4(fp)
 82022ec:	11000117 	ldw	r4,4(r2)
 82022f0:	e0bfff17 	ldw	r2,-4(fp)
 82022f4:	11417b17 	ldw	r5,1516(r2)
 82022f8:	e0bfff17 	ldw	r2,-4(fp)
 82022fc:	10817b17 	ldw	r2,1516(r2)
 8202300:	1007883a 	mov	r3,r2
 8202304:	e0bfff17 	ldw	r2,-4(fp)
 8202308:	10800304 	addi	r2,r2,12
 820230c:	1885c83a 	sub	r2,r3,r2
 8202310:	00c176c4 	movi	r3,1499
 8202314:	1885c83a 	sub	r2,r3,r2
 8202318:	000f883a 	mov	r7,zero
 820231c:	100d883a 	mov	r6,r2
 8202320:	8230d900 	call	8230d90 <t_recv>
 8202324:	e0bffd15 	stw	r2,-12(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 8202328:	e0bffd17 	ldw	r2,-12(fp)
 820232c:	00800a0e 	bge	zero,r2,8202358 <sss_handle_receive+0xe8>
      {
        conn->rx_wr_pos += rx_code;
 8202330:	e0bfff17 	ldw	r2,-4(fp)
 8202334:	10c17b17 	ldw	r3,1516(r2)
 8202338:	e0bffd17 	ldw	r2,-12(fp)
 820233c:	1887883a 	add	r3,r3,r2
 8202340:	e0bfff17 	ldw	r2,-4(fp)
 8202344:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 8202348:	e0bfff17 	ldw	r2,-4(fp)
 820234c:	10817b17 	ldw	r2,1516(r2)
 8202350:	10800044 	addi	r2,r2,1
 8202354:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 8202358:	e0bfff17 	ldw	r2,-4(fp)
 820235c:	10800217 	ldw	r2,8(r2)
 8202360:	10000226 	beq	r2,zero,820236c <sss_handle_receive+0xfc>
 8202364:	00800084 	movi	r2,2
 8202368:	00000106 	br	8202370 <sss_handle_receive+0x100>
 820236c:	0005883a 	mov	r2,zero
 8202370:	e0ffff17 	ldw	r3,-4(fp)
 8202374:	18800015 	stw	r2,0(r3)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 8202378:	e0bfff17 	ldw	r2,-4(fp)
 820237c:	10817a17 	ldw	r2,1512(r2)
 8202380:	1007883a 	mov	r3,r2
 8202384:	e0bfff17 	ldw	r2,-4(fp)
 8202388:	10800304 	addi	r2,r2,12
 820238c:	1885c83a 	sub	r2,r3,r2
 8202390:	e0bffc15 	stw	r2,-16(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 8202394:	e0bfff17 	ldw	r2,-4(fp)
 8202398:	10c00304 	addi	r3,r2,12
 820239c:	e0bfff17 	ldw	r2,-4(fp)
 82023a0:	11017a17 	ldw	r4,1512(r2)
       conn->rx_wr_pos - conn->rx_rd_pos);
 82023a4:	e0bfff17 	ldw	r2,-4(fp)
 82023a8:	10817b17 	ldw	r2,1516(r2)
 82023ac:	100b883a 	mov	r5,r2
 82023b0:	e0bfff17 	ldw	r2,-4(fp)
 82023b4:	10817a17 	ldw	r2,1512(r2)
 82023b8:	2885c83a 	sub	r2,r5,r2
     */
    conn->state = conn->close ? CLOSE : READY;

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 82023bc:	100d883a 	mov	r6,r2
 82023c0:	200b883a 	mov	r5,r4
 82023c4:	1809883a 	mov	r4,r3
 82023c8:	8202b540 	call	8202b54 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 82023cc:	e0bfff17 	ldw	r2,-4(fp)
 82023d0:	10c00304 	addi	r3,r2,12
 82023d4:	e0bfff17 	ldw	r2,-4(fp)
 82023d8:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 82023dc:	e0bfff17 	ldw	r2,-4(fp)
 82023e0:	10c17b17 	ldw	r3,1516(r2)
 82023e4:	e0bffc17 	ldw	r2,-16(fp)
 82023e8:	0085c83a 	sub	r2,zero,r2
 82023ec:	1887883a 	add	r3,r3,r2
 82023f0:	e0bfff17 	ldw	r2,-4(fp)
 82023f4:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 82023f8:	e0bfff17 	ldw	r2,-4(fp)
 82023fc:	10817b17 	ldw	r2,1516(r2)
 8202400:	e0fffc17 	ldw	r3,-16(fp)
 8202404:	180d883a 	mov	r6,r3
 8202408:	000b883a 	mov	r5,zero
 820240c:	1009883a 	mov	r4,r2
 8202410:	8202cb00 	call	8202cb0 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 8202414:	e0bfff17 	ldw	r2,-4(fp)
 8202418:	10800017 	ldw	r2,0(r2)
 820241c:	10800098 	cmpnei	r2,r2,2
 8202420:	103fa61e 	bne	r2,zero,82022bc <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 8202424:	01020974 	movhi	r4,2085
 8202428:	2132b804 	addi	r4,r4,-13600
 820242c:	82031200 	call	8203120 <puts>
  close(conn->fd);
 8202430:	e0bfff17 	ldw	r2,-4(fp)
 8202434:	10800117 	ldw	r2,4(r2)
 8202438:	1009883a 	mov	r4,r2
 820243c:	822546c0 	call	822546c <close>
  sss_reset_connection(conn);
 8202440:	e13fff17 	ldw	r4,-4(fp)
 8202444:	8201a4c0 	call	8201a4c <sss_reset_connection>
  
  return;
 8202448:	0001883a 	nop
}
 820244c:	e037883a 	mov	sp,fp
 8202450:	dfc00117 	ldw	ra,4(sp)
 8202454:	df000017 	ldw	fp,0(sp)
 8202458:	dec00204 	addi	sp,sp,8
 820245c:	f800283a 	ret

08202460 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 8202460:	deffb604 	addi	sp,sp,-296
 8202464:	dfc04915 	stw	ra,292(sp)
 8202468:	df004815 	stw	fp,288(sp)
 820246c:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 8202470:	000d883a 	mov	r6,zero
 8202474:	01400044 	movi	r5,1
 8202478:	01000084 	movi	r4,2
 820247c:	82300640 	call	8230064 <t_socket>
 8202480:	e0bfba15 	stw	r2,-280(fp)
 8202484:	e0bfba17 	ldw	r2,-280(fp)
 8202488:	1000040e 	bge	r2,zero,820249c <SSSSimpleSocketServerTask+0x3c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 820248c:	01420974 	movhi	r5,2085
 8202490:	2972c204 	addi	r5,r5,-13560
 8202494:	01003fc4 	movi	r4,255
 8202498:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 820249c:	00800084 	movi	r2,2
 82024a0:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 82024a4:	00878004 	movi	r2,7680
 82024a8:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 82024ac:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 82024b0:	e0bfbb04 	addi	r2,fp,-276
 82024b4:	01800404 	movi	r6,16
 82024b8:	100b883a 	mov	r5,r2
 82024bc:	e13fba17 	ldw	r4,-280(fp)
 82024c0:	82300e40 	call	82300e4 <t_bind>
 82024c4:	1000040e 	bge	r2,zero,82024d8 <SSSSimpleSocketServerTask+0x78>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 82024c8:	01420974 	movhi	r5,2085
 82024cc:	2972cb04 	addi	r5,r5,-13524
 82024d0:	01003fc4 	movi	r4,255
 82024d4:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 82024d8:	01400044 	movi	r5,1
 82024dc:	e13fba17 	ldw	r4,-280(fp)
 82024e0:	82302480 	call	8230248 <t_listen>
 82024e4:	1000040e 	bge	r2,zero,82024f8 <SSSSimpleSocketServerTask+0x98>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 82024e8:	01420974 	movhi	r5,2085
 82024ec:	2972d104 	addi	r5,r5,-13500
 82024f0:	01003fc4 	movi	r4,255
 82024f4:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 82024f8:	01020974 	movhi	r4,2085
 82024fc:	210f0b04 	addi	r4,r4,15404
 8202500:	8201a4c0 	call	8201a4c <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 8202504:	01400784 	movi	r5,30
 8202508:	01020974 	movhi	r4,2085
 820250c:	2132d804 	addi	r4,r4,-13472
 8202510:	8202e9c0 	call	8202e9c <printf>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 8202514:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 8202518:	e0bfbf04 	addi	r2,fp,-260
 820251c:	100b883a 	mov	r5,r2
 8202520:	e13fba17 	ldw	r4,-280(fp)
 8202524:	82350500 	call	8235050 <ifd_set>
    max_socket = fd_listen+1;
 8202528:	e0bfba17 	ldw	r2,-280(fp)
 820252c:	10800044 	addi	r2,r2,1
 8202530:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 8202534:	00820974 	movhi	r2,2085
 8202538:	108f0b04 	addi	r2,r2,15404
 820253c:	10800117 	ldw	r2,4(r2)
 8202540:	10bfffe0 	cmpeqi	r2,r2,-1
 8202544:	1000111e 	bne	r2,zero,820258c <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 8202548:	00820974 	movhi	r2,2085
 820254c:	108f0b04 	addi	r2,r2,15404
 8202550:	10800117 	ldw	r2,4(r2)
 8202554:	e0ffbf04 	addi	r3,fp,-260
 8202558:	180b883a 	mov	r5,r3
 820255c:	1009883a 	mov	r4,r2
 8202560:	82350500 	call	8235050 <ifd_set>
      if (max_socket <= conn.fd)
 8202564:	00820974 	movhi	r2,2085
 8202568:	108f0b04 	addi	r2,r2,15404
 820256c:	10c00117 	ldw	r3,4(r2)
 8202570:	e0bfb917 	ldw	r2,-284(fp)
 8202574:	18800516 	blt	r3,r2,820258c <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 8202578:	00820974 	movhi	r2,2085
 820257c:	108f0b04 	addi	r2,r2,15404
 8202580:	10800117 	ldw	r2,4(r2)
 8202584:	10800044 	addi	r2,r2,1
 8202588:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 820258c:	e0bfbf04 	addi	r2,fp,-260
 8202590:	d8000015 	stw	zero,0(sp)
 8202594:	000f883a 	mov	r7,zero
 8202598:	000d883a 	mov	r6,zero
 820259c:	100b883a 	mov	r5,r2
 82025a0:	e13fb917 	ldw	r4,-284(fp)
 82025a4:	82280e00 	call	82280e0 <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 82025a8:	e0bfbf04 	addi	r2,fp,-260
 82025ac:	100b883a 	mov	r5,r2
 82025b0:	e13fba17 	ldw	r4,-280(fp)
 82025b4:	82350c80 	call	82350c8 <ifd_isset>
 82025b8:	10000526 	beq	r2,zero,82025d0 <SSSSimpleSocketServerTask+0x170>
    {
      sss_handle_accept(fd_listen, &conn);
 82025bc:	01420974 	movhi	r5,2085
 82025c0:	294f0b04 	addi	r5,r5,15404
 82025c4:	e13fba17 	ldw	r4,-280(fp)
 82025c8:	8201cd80 	call	8201cd8 <sss_handle_accept>
 82025cc:	003fd106 	br	8202514 <SSSSimpleSocketServerTask+0xb4>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 82025d0:	00820974 	movhi	r2,2085
 82025d4:	108f0b04 	addi	r2,r2,15404
 82025d8:	10800117 	ldw	r2,4(r2)
 82025dc:	10bfffe0 	cmpeqi	r2,r2,-1
 82025e0:	103fcc1e 	bne	r2,zero,8202514 <SSSSimpleSocketServerTask+0xb4>
 82025e4:	00820974 	movhi	r2,2085
 82025e8:	108f0b04 	addi	r2,r2,15404
 82025ec:	10800117 	ldw	r2,4(r2)
 82025f0:	e0ffbf04 	addi	r3,fp,-260
 82025f4:	180b883a 	mov	r5,r3
 82025f8:	1009883a 	mov	r4,r2
 82025fc:	82350c80 	call	82350c8 <ifd_isset>
 8202600:	103fc426 	beq	r2,zero,8202514 <SSSSimpleSocketServerTask+0xb4>
      {
        sss_handle_receive(&conn);
 8202604:	01020974 	movhi	r4,2085
 8202608:	210f0b04 	addi	r4,r4,15404
 820260c:	82022700 	call	8202270 <sss_handle_receive>
      }
    }
  } /* while(1) */
 8202610:	003fc006 	br	8202514 <SSSSimpleSocketServerTask+0xb4>

08202614 <__divsi3>:
 8202614:	20001b16 	blt	r4,zero,8202684 <__divsi3+0x70>
 8202618:	000f883a 	mov	r7,zero
 820261c:	28001616 	blt	r5,zero,8202678 <__divsi3+0x64>
 8202620:	200d883a 	mov	r6,r4
 8202624:	29001a2e 	bgeu	r5,r4,8202690 <__divsi3+0x7c>
 8202628:	00800804 	movi	r2,32
 820262c:	00c00044 	movi	r3,1
 8202630:	00000106 	br	8202638 <__divsi3+0x24>
 8202634:	10000d26 	beq	r2,zero,820266c <__divsi3+0x58>
 8202638:	294b883a 	add	r5,r5,r5
 820263c:	10bfffc4 	addi	r2,r2,-1
 8202640:	18c7883a 	add	r3,r3,r3
 8202644:	293ffb36 	bltu	r5,r4,8202634 <__divsi3+0x20>
 8202648:	0005883a 	mov	r2,zero
 820264c:	18000726 	beq	r3,zero,820266c <__divsi3+0x58>
 8202650:	0005883a 	mov	r2,zero
 8202654:	31400236 	bltu	r6,r5,8202660 <__divsi3+0x4c>
 8202658:	314dc83a 	sub	r6,r6,r5
 820265c:	10c4b03a 	or	r2,r2,r3
 8202660:	1806d07a 	srli	r3,r3,1
 8202664:	280ad07a 	srli	r5,r5,1
 8202668:	183ffa1e 	bne	r3,zero,8202654 <__divsi3+0x40>
 820266c:	38000126 	beq	r7,zero,8202674 <__divsi3+0x60>
 8202670:	0085c83a 	sub	r2,zero,r2
 8202674:	f800283a 	ret
 8202678:	014bc83a 	sub	r5,zero,r5
 820267c:	39c0005c 	xori	r7,r7,1
 8202680:	003fe706 	br	8202620 <__divsi3+0xc>
 8202684:	0109c83a 	sub	r4,zero,r4
 8202688:	01c00044 	movi	r7,1
 820268c:	003fe306 	br	820261c <__divsi3+0x8>
 8202690:	00c00044 	movi	r3,1
 8202694:	003fee06 	br	8202650 <__divsi3+0x3c>

08202698 <__modsi3>:
 8202698:	20001716 	blt	r4,zero,82026f8 <__modsi3+0x60>
 820269c:	000f883a 	mov	r7,zero
 82026a0:	2005883a 	mov	r2,r4
 82026a4:	28001216 	blt	r5,zero,82026f0 <__modsi3+0x58>
 82026a8:	2900162e 	bgeu	r5,r4,8202704 <__modsi3+0x6c>
 82026ac:	01800804 	movi	r6,32
 82026b0:	00c00044 	movi	r3,1
 82026b4:	00000106 	br	82026bc <__modsi3+0x24>
 82026b8:	30000a26 	beq	r6,zero,82026e4 <__modsi3+0x4c>
 82026bc:	294b883a 	add	r5,r5,r5
 82026c0:	31bfffc4 	addi	r6,r6,-1
 82026c4:	18c7883a 	add	r3,r3,r3
 82026c8:	293ffb36 	bltu	r5,r4,82026b8 <__modsi3+0x20>
 82026cc:	18000526 	beq	r3,zero,82026e4 <__modsi3+0x4c>
 82026d0:	1806d07a 	srli	r3,r3,1
 82026d4:	11400136 	bltu	r2,r5,82026dc <__modsi3+0x44>
 82026d8:	1145c83a 	sub	r2,r2,r5
 82026dc:	280ad07a 	srli	r5,r5,1
 82026e0:	183ffb1e 	bne	r3,zero,82026d0 <__modsi3+0x38>
 82026e4:	38000126 	beq	r7,zero,82026ec <__modsi3+0x54>
 82026e8:	0085c83a 	sub	r2,zero,r2
 82026ec:	f800283a 	ret
 82026f0:	014bc83a 	sub	r5,zero,r5
 82026f4:	003fec06 	br	82026a8 <__modsi3+0x10>
 82026f8:	0109c83a 	sub	r4,zero,r4
 82026fc:	01c00044 	movi	r7,1
 8202700:	003fe706 	br	82026a0 <__modsi3+0x8>
 8202704:	00c00044 	movi	r3,1
 8202708:	003ff106 	br	82026d0 <__modsi3+0x38>

0820270c <__udivsi3>:
 820270c:	200d883a 	mov	r6,r4
 8202710:	2900152e 	bgeu	r5,r4,8202768 <__udivsi3+0x5c>
 8202714:	28001416 	blt	r5,zero,8202768 <__udivsi3+0x5c>
 8202718:	00800804 	movi	r2,32
 820271c:	00c00044 	movi	r3,1
 8202720:	00000206 	br	820272c <__udivsi3+0x20>
 8202724:	10000e26 	beq	r2,zero,8202760 <__udivsi3+0x54>
 8202728:	28000516 	blt	r5,zero,8202740 <__udivsi3+0x34>
 820272c:	294b883a 	add	r5,r5,r5
 8202730:	10bfffc4 	addi	r2,r2,-1
 8202734:	18c7883a 	add	r3,r3,r3
 8202738:	293ffa36 	bltu	r5,r4,8202724 <__udivsi3+0x18>
 820273c:	18000826 	beq	r3,zero,8202760 <__udivsi3+0x54>
 8202740:	0005883a 	mov	r2,zero
 8202744:	31400236 	bltu	r6,r5,8202750 <__udivsi3+0x44>
 8202748:	314dc83a 	sub	r6,r6,r5
 820274c:	10c4b03a 	or	r2,r2,r3
 8202750:	1806d07a 	srli	r3,r3,1
 8202754:	280ad07a 	srli	r5,r5,1
 8202758:	183ffa1e 	bne	r3,zero,8202744 <__udivsi3+0x38>
 820275c:	f800283a 	ret
 8202760:	0005883a 	mov	r2,zero
 8202764:	f800283a 	ret
 8202768:	00c00044 	movi	r3,1
 820276c:	003ff406 	br	8202740 <__udivsi3+0x34>

08202770 <__umodsi3>:
 8202770:	2005883a 	mov	r2,r4
 8202774:	2900122e 	bgeu	r5,r4,82027c0 <__umodsi3+0x50>
 8202778:	28001116 	blt	r5,zero,82027c0 <__umodsi3+0x50>
 820277c:	01800804 	movi	r6,32
 8202780:	00c00044 	movi	r3,1
 8202784:	00000206 	br	8202790 <__umodsi3+0x20>
 8202788:	30000c26 	beq	r6,zero,82027bc <__umodsi3+0x4c>
 820278c:	28000516 	blt	r5,zero,82027a4 <__umodsi3+0x34>
 8202790:	294b883a 	add	r5,r5,r5
 8202794:	31bfffc4 	addi	r6,r6,-1
 8202798:	18c7883a 	add	r3,r3,r3
 820279c:	293ffa36 	bltu	r5,r4,8202788 <__umodsi3+0x18>
 82027a0:	18000626 	beq	r3,zero,82027bc <__umodsi3+0x4c>
 82027a4:	1806d07a 	srli	r3,r3,1
 82027a8:	11400136 	bltu	r2,r5,82027b0 <__umodsi3+0x40>
 82027ac:	1145c83a 	sub	r2,r2,r5
 82027b0:	280ad07a 	srli	r5,r5,1
 82027b4:	183ffb1e 	bne	r3,zero,82027a4 <__umodsi3+0x34>
 82027b8:	f800283a 	ret
 82027bc:	f800283a 	ret
 82027c0:	00c00044 	movi	r3,1
 82027c4:	003ff706 	br	82027a4 <__umodsi3+0x34>

082027c8 <_fprintf_r>:
 82027c8:	defffe04 	addi	sp,sp,-8
 82027cc:	2809883a 	mov	r4,r5
 82027d0:	300b883a 	mov	r5,r6
 82027d4:	dfc00015 	stw	ra,0(sp)
 82027d8:	d9c00115 	stw	r7,4(sp)
 82027dc:	d9800104 	addi	r6,sp,4
 82027e0:	82087300 	call	8208730 <__vfprintf_internal>
 82027e4:	dfc00017 	ldw	ra,0(sp)
 82027e8:	dec00204 	addi	sp,sp,8
 82027ec:	f800283a 	ret

082027f0 <fprintf>:
 82027f0:	defffd04 	addi	sp,sp,-12
 82027f4:	dfc00015 	stw	ra,0(sp)
 82027f8:	d9800115 	stw	r6,4(sp)
 82027fc:	d9c00215 	stw	r7,8(sp)
 8202800:	d9800104 	addi	r6,sp,4
 8202804:	82087300 	call	8208730 <__vfprintf_internal>
 8202808:	dfc00017 	ldw	ra,0(sp)
 820280c:	dec00304 	addi	sp,sp,12
 8202810:	f800283a 	ret

08202814 <_fwrite_r>:
 8202814:	defff504 	addi	sp,sp,-44
 8202818:	dc800815 	stw	r18,32(sp)
 820281c:	39a5383a 	mul	r18,r7,r6
 8202820:	d8800304 	addi	r2,sp,12
 8202824:	d8800015 	stw	r2,0(sp)
 8202828:	00800044 	movi	r2,1
 820282c:	dcc00915 	stw	r19,36(sp)
 8202830:	dc400715 	stw	r17,28(sp)
 8202834:	dc000615 	stw	r16,24(sp)
 8202838:	d9400315 	stw	r5,12(sp)
 820283c:	dfc00a15 	stw	ra,40(sp)
 8202840:	dc800415 	stw	r18,16(sp)
 8202844:	dc800215 	stw	r18,8(sp)
 8202848:	d8800115 	stw	r2,4(sp)
 820284c:	3027883a 	mov	r19,r6
 8202850:	3821883a 	mov	r16,r7
 8202854:	2023883a 	mov	r17,r4
 8202858:	d9400b17 	ldw	r5,44(sp)
 820285c:	20000226 	beq	r4,zero,8202868 <_fwrite_r+0x54>
 8202860:	20800e17 	ldw	r2,56(r4)
 8202864:	10001a26 	beq	r2,zero,82028d0 <_fwrite_r+0xbc>
 8202868:	2880030b 	ldhu	r2,12(r5)
 820286c:	10c8000c 	andi	r3,r2,8192
 8202870:	1800061e 	bne	r3,zero,820288c <_fwrite_r+0x78>
 8202874:	29001917 	ldw	r4,100(r5)
 8202878:	00f7ffc4 	movi	r3,-8193
 820287c:	10880014 	ori	r2,r2,8192
 8202880:	20c6703a 	and	r3,r4,r3
 8202884:	2880030d 	sth	r2,12(r5)
 8202888:	28c01915 	stw	r3,100(r5)
 820288c:	d80d883a 	mov	r6,sp
 8202890:	8809883a 	mov	r4,r17
 8202894:	820af0c0 	call	820af0c <__sfvwrite_r>
 8202898:	10000b26 	beq	r2,zero,82028c8 <_fwrite_r+0xb4>
 820289c:	d9000217 	ldw	r4,8(sp)
 82028a0:	980b883a 	mov	r5,r19
 82028a4:	9109c83a 	sub	r4,r18,r4
 82028a8:	820270c0 	call	820270c <__udivsi3>
 82028ac:	dfc00a17 	ldw	ra,40(sp)
 82028b0:	dcc00917 	ldw	r19,36(sp)
 82028b4:	dc800817 	ldw	r18,32(sp)
 82028b8:	dc400717 	ldw	r17,28(sp)
 82028bc:	dc000617 	ldw	r16,24(sp)
 82028c0:	dec00b04 	addi	sp,sp,44
 82028c4:	f800283a 	ret
 82028c8:	8005883a 	mov	r2,r16
 82028cc:	003ff706 	br	82028ac <_fwrite_r+0x98>
 82028d0:	d9400515 	stw	r5,20(sp)
 82028d4:	820a9340 	call	820a934 <__sinit>
 82028d8:	d9400517 	ldw	r5,20(sp)
 82028dc:	003fe206 	br	8202868 <_fwrite_r+0x54>

082028e0 <fwrite>:
 82028e0:	defffe04 	addi	sp,sp,-8
 82028e4:	00820974 	movhi	r2,2085
 82028e8:	d9c00015 	stw	r7,0(sp)
 82028ec:	108e3004 	addi	r2,r2,14528
 82028f0:	300f883a 	mov	r7,r6
 82028f4:	280d883a 	mov	r6,r5
 82028f8:	200b883a 	mov	r5,r4
 82028fc:	11000017 	ldw	r4,0(r2)
 8202900:	dfc00115 	stw	ra,4(sp)
 8202904:	82028140 	call	8202814 <_fwrite_r>
 8202908:	dfc00117 	ldw	ra,4(sp)
 820290c:	dec00204 	addi	sp,sp,8
 8202910:	f800283a 	ret

08202914 <_getc_r>:
 8202914:	defffd04 	addi	sp,sp,-12
 8202918:	dc000115 	stw	r16,4(sp)
 820291c:	dfc00215 	stw	ra,8(sp)
 8202920:	2021883a 	mov	r16,r4
 8202924:	20000226 	beq	r4,zero,8202930 <_getc_r+0x1c>
 8202928:	20800e17 	ldw	r2,56(r4)
 820292c:	10000c26 	beq	r2,zero,8202960 <_getc_r+0x4c>
 8202930:	28800117 	ldw	r2,4(r5)
 8202934:	10bfffc4 	addi	r2,r2,-1
 8202938:	28800115 	stw	r2,4(r5)
 820293c:	10000c16 	blt	r2,zero,8202970 <_getc_r+0x5c>
 8202940:	28800017 	ldw	r2,0(r5)
 8202944:	10c00044 	addi	r3,r2,1
 8202948:	28c00015 	stw	r3,0(r5)
 820294c:	10800003 	ldbu	r2,0(r2)
 8202950:	dfc00217 	ldw	ra,8(sp)
 8202954:	dc000117 	ldw	r16,4(sp)
 8202958:	dec00304 	addi	sp,sp,12
 820295c:	f800283a 	ret
 8202960:	d9400015 	stw	r5,0(sp)
 8202964:	820a9340 	call	820a934 <__sinit>
 8202968:	d9400017 	ldw	r5,0(sp)
 820296c:	003ff006 	br	8202930 <_getc_r+0x1c>
 8202970:	8009883a 	mov	r4,r16
 8202974:	dfc00217 	ldw	ra,8(sp)
 8202978:	dc000117 	ldw	r16,4(sp)
 820297c:	dec00304 	addi	sp,sp,12
 8202980:	82031341 	jmpi	8203134 <__srget_r>

08202984 <getc>:
 8202984:	00820974 	movhi	r2,2085
 8202988:	defffd04 	addi	sp,sp,-12
 820298c:	108e3004 	addi	r2,r2,14528
 8202990:	dc400115 	stw	r17,4(sp)
 8202994:	14400017 	ldw	r17,0(r2)
 8202998:	dc000015 	stw	r16,0(sp)
 820299c:	dfc00215 	stw	ra,8(sp)
 82029a0:	2021883a 	mov	r16,r4
 82029a4:	88000226 	beq	r17,zero,82029b0 <getc+0x2c>
 82029a8:	88800e17 	ldw	r2,56(r17)
 82029ac:	10000d26 	beq	r2,zero,82029e4 <getc+0x60>
 82029b0:	80800117 	ldw	r2,4(r16)
 82029b4:	10bfffc4 	addi	r2,r2,-1
 82029b8:	80800115 	stw	r2,4(r16)
 82029bc:	10000c16 	blt	r2,zero,82029f0 <getc+0x6c>
 82029c0:	80800017 	ldw	r2,0(r16)
 82029c4:	10c00044 	addi	r3,r2,1
 82029c8:	80c00015 	stw	r3,0(r16)
 82029cc:	10800003 	ldbu	r2,0(r2)
 82029d0:	dfc00217 	ldw	ra,8(sp)
 82029d4:	dc400117 	ldw	r17,4(sp)
 82029d8:	dc000017 	ldw	r16,0(sp)
 82029dc:	dec00304 	addi	sp,sp,12
 82029e0:	f800283a 	ret
 82029e4:	8809883a 	mov	r4,r17
 82029e8:	820a9340 	call	820a934 <__sinit>
 82029ec:	003ff006 	br	82029b0 <getc+0x2c>
 82029f0:	800b883a 	mov	r5,r16
 82029f4:	8809883a 	mov	r4,r17
 82029f8:	dfc00217 	ldw	ra,8(sp)
 82029fc:	dc400117 	ldw	r17,4(sp)
 8202a00:	dc000017 	ldw	r16,0(sp)
 8202a04:	dec00304 	addi	sp,sp,12
 8202a08:	82031341 	jmpi	8203134 <__srget_r>

08202a0c <memcpy>:
 8202a0c:	defffd04 	addi	sp,sp,-12
 8202a10:	dfc00215 	stw	ra,8(sp)
 8202a14:	dc400115 	stw	r17,4(sp)
 8202a18:	dc000015 	stw	r16,0(sp)
 8202a1c:	00c003c4 	movi	r3,15
 8202a20:	2005883a 	mov	r2,r4
 8202a24:	1980452e 	bgeu	r3,r6,8202b3c <memcpy+0x130>
 8202a28:	2906b03a 	or	r3,r5,r4
 8202a2c:	18c000cc 	andi	r3,r3,3
 8202a30:	1800441e 	bne	r3,zero,8202b44 <memcpy+0x138>
 8202a34:	347ffc04 	addi	r17,r6,-16
 8202a38:	8822d13a 	srli	r17,r17,4
 8202a3c:	28c00104 	addi	r3,r5,4
 8202a40:	23400104 	addi	r13,r4,4
 8202a44:	8820913a 	slli	r16,r17,4
 8202a48:	2b000204 	addi	r12,r5,8
 8202a4c:	22c00204 	addi	r11,r4,8
 8202a50:	84000504 	addi	r16,r16,20
 8202a54:	2a800304 	addi	r10,r5,12
 8202a58:	22400304 	addi	r9,r4,12
 8202a5c:	2c21883a 	add	r16,r5,r16
 8202a60:	2811883a 	mov	r8,r5
 8202a64:	200f883a 	mov	r7,r4
 8202a68:	41000017 	ldw	r4,0(r8)
 8202a6c:	1fc00017 	ldw	ra,0(r3)
 8202a70:	63c00017 	ldw	r15,0(r12)
 8202a74:	39000015 	stw	r4,0(r7)
 8202a78:	53800017 	ldw	r14,0(r10)
 8202a7c:	6fc00015 	stw	ra,0(r13)
 8202a80:	5bc00015 	stw	r15,0(r11)
 8202a84:	4b800015 	stw	r14,0(r9)
 8202a88:	18c00404 	addi	r3,r3,16
 8202a8c:	39c00404 	addi	r7,r7,16
 8202a90:	42000404 	addi	r8,r8,16
 8202a94:	6b400404 	addi	r13,r13,16
 8202a98:	63000404 	addi	r12,r12,16
 8202a9c:	5ac00404 	addi	r11,r11,16
 8202aa0:	52800404 	addi	r10,r10,16
 8202aa4:	4a400404 	addi	r9,r9,16
 8202aa8:	1c3fef1e 	bne	r3,r16,8202a68 <memcpy+0x5c>
 8202aac:	89c00044 	addi	r7,r17,1
 8202ab0:	380e913a 	slli	r7,r7,4
 8202ab4:	310003cc 	andi	r4,r6,15
 8202ab8:	02c000c4 	movi	r11,3
 8202abc:	11c7883a 	add	r3,r2,r7
 8202ac0:	29cb883a 	add	r5,r5,r7
 8202ac4:	5900212e 	bgeu	r11,r4,8202b4c <memcpy+0x140>
 8202ac8:	1813883a 	mov	r9,r3
 8202acc:	2811883a 	mov	r8,r5
 8202ad0:	200f883a 	mov	r7,r4
 8202ad4:	42800017 	ldw	r10,0(r8)
 8202ad8:	4a400104 	addi	r9,r9,4
 8202adc:	39ffff04 	addi	r7,r7,-4
 8202ae0:	4abfff15 	stw	r10,-4(r9)
 8202ae4:	42000104 	addi	r8,r8,4
 8202ae8:	59fffa36 	bltu	r11,r7,8202ad4 <memcpy+0xc8>
 8202aec:	213fff04 	addi	r4,r4,-4
 8202af0:	2008d0ba 	srli	r4,r4,2
 8202af4:	318000cc 	andi	r6,r6,3
 8202af8:	21000044 	addi	r4,r4,1
 8202afc:	2109883a 	add	r4,r4,r4
 8202b00:	2109883a 	add	r4,r4,r4
 8202b04:	1907883a 	add	r3,r3,r4
 8202b08:	290b883a 	add	r5,r5,r4
 8202b0c:	30000626 	beq	r6,zero,8202b28 <memcpy+0x11c>
 8202b10:	198d883a 	add	r6,r3,r6
 8202b14:	29c00003 	ldbu	r7,0(r5)
 8202b18:	18c00044 	addi	r3,r3,1
 8202b1c:	29400044 	addi	r5,r5,1
 8202b20:	19ffffc5 	stb	r7,-1(r3)
 8202b24:	19bffb1e 	bne	r3,r6,8202b14 <memcpy+0x108>
 8202b28:	dfc00217 	ldw	ra,8(sp)
 8202b2c:	dc400117 	ldw	r17,4(sp)
 8202b30:	dc000017 	ldw	r16,0(sp)
 8202b34:	dec00304 	addi	sp,sp,12
 8202b38:	f800283a 	ret
 8202b3c:	2007883a 	mov	r3,r4
 8202b40:	003ff206 	br	8202b0c <memcpy+0x100>
 8202b44:	2007883a 	mov	r3,r4
 8202b48:	003ff106 	br	8202b10 <memcpy+0x104>
 8202b4c:	200d883a 	mov	r6,r4
 8202b50:	003fee06 	br	8202b0c <memcpy+0x100>

08202b54 <memmove>:
 8202b54:	2005883a 	mov	r2,r4
 8202b58:	29000b2e 	bgeu	r5,r4,8202b88 <memmove+0x34>
 8202b5c:	298f883a 	add	r7,r5,r6
 8202b60:	21c0092e 	bgeu	r4,r7,8202b88 <memmove+0x34>
 8202b64:	2187883a 	add	r3,r4,r6
 8202b68:	198bc83a 	sub	r5,r3,r6
 8202b6c:	30004826 	beq	r6,zero,8202c90 <memmove+0x13c>
 8202b70:	39ffffc4 	addi	r7,r7,-1
 8202b74:	39000003 	ldbu	r4,0(r7)
 8202b78:	18ffffc4 	addi	r3,r3,-1
 8202b7c:	19000005 	stb	r4,0(r3)
 8202b80:	28fffb1e 	bne	r5,r3,8202b70 <memmove+0x1c>
 8202b84:	f800283a 	ret
 8202b88:	00c003c4 	movi	r3,15
 8202b8c:	1980412e 	bgeu	r3,r6,8202c94 <memmove+0x140>
 8202b90:	2886b03a 	or	r3,r5,r2
 8202b94:	18c000cc 	andi	r3,r3,3
 8202b98:	1800401e 	bne	r3,zero,8202c9c <memmove+0x148>
 8202b9c:	33fffc04 	addi	r15,r6,-16
 8202ba0:	781ed13a 	srli	r15,r15,4
 8202ba4:	28c00104 	addi	r3,r5,4
 8202ba8:	13400104 	addi	r13,r2,4
 8202bac:	781c913a 	slli	r14,r15,4
 8202bb0:	2b000204 	addi	r12,r5,8
 8202bb4:	12c00204 	addi	r11,r2,8
 8202bb8:	73800504 	addi	r14,r14,20
 8202bbc:	2a800304 	addi	r10,r5,12
 8202bc0:	12400304 	addi	r9,r2,12
 8202bc4:	2b9d883a 	add	r14,r5,r14
 8202bc8:	2811883a 	mov	r8,r5
 8202bcc:	100f883a 	mov	r7,r2
 8202bd0:	41000017 	ldw	r4,0(r8)
 8202bd4:	39c00404 	addi	r7,r7,16
 8202bd8:	18c00404 	addi	r3,r3,16
 8202bdc:	393ffc15 	stw	r4,-16(r7)
 8202be0:	193ffc17 	ldw	r4,-16(r3)
 8202be4:	6b400404 	addi	r13,r13,16
 8202be8:	5ac00404 	addi	r11,r11,16
 8202bec:	693ffc15 	stw	r4,-16(r13)
 8202bf0:	61000017 	ldw	r4,0(r12)
 8202bf4:	4a400404 	addi	r9,r9,16
 8202bf8:	42000404 	addi	r8,r8,16
 8202bfc:	593ffc15 	stw	r4,-16(r11)
 8202c00:	51000017 	ldw	r4,0(r10)
 8202c04:	63000404 	addi	r12,r12,16
 8202c08:	52800404 	addi	r10,r10,16
 8202c0c:	493ffc15 	stw	r4,-16(r9)
 8202c10:	1bbfef1e 	bne	r3,r14,8202bd0 <memmove+0x7c>
 8202c14:	79000044 	addi	r4,r15,1
 8202c18:	2008913a 	slli	r4,r4,4
 8202c1c:	328003cc 	andi	r10,r6,15
 8202c20:	02c000c4 	movi	r11,3
 8202c24:	1107883a 	add	r3,r2,r4
 8202c28:	290b883a 	add	r5,r5,r4
 8202c2c:	5a801e2e 	bgeu	r11,r10,8202ca8 <memmove+0x154>
 8202c30:	1813883a 	mov	r9,r3
 8202c34:	2811883a 	mov	r8,r5
 8202c38:	500f883a 	mov	r7,r10
 8202c3c:	41000017 	ldw	r4,0(r8)
 8202c40:	4a400104 	addi	r9,r9,4
 8202c44:	39ffff04 	addi	r7,r7,-4
 8202c48:	493fff15 	stw	r4,-4(r9)
 8202c4c:	42000104 	addi	r8,r8,4
 8202c50:	59fffa36 	bltu	r11,r7,8202c3c <memmove+0xe8>
 8202c54:	513fff04 	addi	r4,r10,-4
 8202c58:	2008d0ba 	srli	r4,r4,2
 8202c5c:	318000cc 	andi	r6,r6,3
 8202c60:	21000044 	addi	r4,r4,1
 8202c64:	2109883a 	add	r4,r4,r4
 8202c68:	2109883a 	add	r4,r4,r4
 8202c6c:	1907883a 	add	r3,r3,r4
 8202c70:	290b883a 	add	r5,r5,r4
 8202c74:	30000b26 	beq	r6,zero,8202ca4 <memmove+0x150>
 8202c78:	198d883a 	add	r6,r3,r6
 8202c7c:	29c00003 	ldbu	r7,0(r5)
 8202c80:	18c00044 	addi	r3,r3,1
 8202c84:	29400044 	addi	r5,r5,1
 8202c88:	19ffffc5 	stb	r7,-1(r3)
 8202c8c:	19bffb1e 	bne	r3,r6,8202c7c <memmove+0x128>
 8202c90:	f800283a 	ret
 8202c94:	1007883a 	mov	r3,r2
 8202c98:	003ff606 	br	8202c74 <memmove+0x120>
 8202c9c:	1007883a 	mov	r3,r2
 8202ca0:	003ff506 	br	8202c78 <memmove+0x124>
 8202ca4:	f800283a 	ret
 8202ca8:	500d883a 	mov	r6,r10
 8202cac:	003ff106 	br	8202c74 <memmove+0x120>

08202cb0 <memset>:
 8202cb0:	20c000cc 	andi	r3,r4,3
 8202cb4:	2005883a 	mov	r2,r4
 8202cb8:	18004426 	beq	r3,zero,8202dcc <memset+0x11c>
 8202cbc:	31ffffc4 	addi	r7,r6,-1
 8202cc0:	30004026 	beq	r6,zero,8202dc4 <memset+0x114>
 8202cc4:	2813883a 	mov	r9,r5
 8202cc8:	200d883a 	mov	r6,r4
 8202ccc:	2007883a 	mov	r3,r4
 8202cd0:	00000406 	br	8202ce4 <memset+0x34>
 8202cd4:	3a3fffc4 	addi	r8,r7,-1
 8202cd8:	31800044 	addi	r6,r6,1
 8202cdc:	38003926 	beq	r7,zero,8202dc4 <memset+0x114>
 8202ce0:	400f883a 	mov	r7,r8
 8202ce4:	18c00044 	addi	r3,r3,1
 8202ce8:	32400005 	stb	r9,0(r6)
 8202cec:	1a0000cc 	andi	r8,r3,3
 8202cf0:	403ff81e 	bne	r8,zero,8202cd4 <memset+0x24>
 8202cf4:	010000c4 	movi	r4,3
 8202cf8:	21c02d2e 	bgeu	r4,r7,8202db0 <memset+0x100>
 8202cfc:	29003fcc 	andi	r4,r5,255
 8202d00:	200c923a 	slli	r6,r4,8
 8202d04:	3108b03a 	or	r4,r6,r4
 8202d08:	200c943a 	slli	r6,r4,16
 8202d0c:	218cb03a 	or	r6,r4,r6
 8202d10:	010003c4 	movi	r4,15
 8202d14:	21c0182e 	bgeu	r4,r7,8202d78 <memset+0xc8>
 8202d18:	3b3ffc04 	addi	r12,r7,-16
 8202d1c:	6018d13a 	srli	r12,r12,4
 8202d20:	1a000104 	addi	r8,r3,4
 8202d24:	1ac00204 	addi	r11,r3,8
 8202d28:	6008913a 	slli	r4,r12,4
 8202d2c:	1a800304 	addi	r10,r3,12
 8202d30:	1813883a 	mov	r9,r3
 8202d34:	21000504 	addi	r4,r4,20
 8202d38:	1909883a 	add	r4,r3,r4
 8202d3c:	49800015 	stw	r6,0(r9)
 8202d40:	41800015 	stw	r6,0(r8)
 8202d44:	59800015 	stw	r6,0(r11)
 8202d48:	51800015 	stw	r6,0(r10)
 8202d4c:	42000404 	addi	r8,r8,16
 8202d50:	4a400404 	addi	r9,r9,16
 8202d54:	5ac00404 	addi	r11,r11,16
 8202d58:	52800404 	addi	r10,r10,16
 8202d5c:	413ff71e 	bne	r8,r4,8202d3c <memset+0x8c>
 8202d60:	63000044 	addi	r12,r12,1
 8202d64:	6018913a 	slli	r12,r12,4
 8202d68:	39c003cc 	andi	r7,r7,15
 8202d6c:	010000c4 	movi	r4,3
 8202d70:	1b07883a 	add	r3,r3,r12
 8202d74:	21c00e2e 	bgeu	r4,r7,8202db0 <memset+0x100>
 8202d78:	1813883a 	mov	r9,r3
 8202d7c:	3811883a 	mov	r8,r7
 8202d80:	010000c4 	movi	r4,3
 8202d84:	49800015 	stw	r6,0(r9)
 8202d88:	423fff04 	addi	r8,r8,-4
 8202d8c:	4a400104 	addi	r9,r9,4
 8202d90:	223ffc36 	bltu	r4,r8,8202d84 <memset+0xd4>
 8202d94:	393fff04 	addi	r4,r7,-4
 8202d98:	2008d0ba 	srli	r4,r4,2
 8202d9c:	39c000cc 	andi	r7,r7,3
 8202da0:	21000044 	addi	r4,r4,1
 8202da4:	2109883a 	add	r4,r4,r4
 8202da8:	2109883a 	add	r4,r4,r4
 8202dac:	1907883a 	add	r3,r3,r4
 8202db0:	38000526 	beq	r7,zero,8202dc8 <memset+0x118>
 8202db4:	19cf883a 	add	r7,r3,r7
 8202db8:	19400005 	stb	r5,0(r3)
 8202dbc:	18c00044 	addi	r3,r3,1
 8202dc0:	38fffd1e 	bne	r7,r3,8202db8 <memset+0x108>
 8202dc4:	f800283a 	ret
 8202dc8:	f800283a 	ret
 8202dcc:	2007883a 	mov	r3,r4
 8202dd0:	300f883a 	mov	r7,r6
 8202dd4:	003fc706 	br	8202cf4 <memset+0x44>

08202dd8 <_perror_r>:
 8202dd8:	defffd04 	addi	sp,sp,-12
 8202ddc:	dc000115 	stw	r16,4(sp)
 8202de0:	dfc00215 	stw	ra,8(sp)
 8202de4:	2021883a 	mov	r16,r4
 8202de8:	28000326 	beq	r5,zero,8202df8 <_perror_r+0x20>
 8202dec:	28c00007 	ldb	r3,0(r5)
 8202df0:	2805883a 	mov	r2,r5
 8202df4:	1800101e 	bne	r3,zero,8202e38 <_perror_r+0x60>
 8202df8:	81400017 	ldw	r5,0(r16)
 8202dfc:	d80f883a 	mov	r7,sp
 8202e00:	01800044 	movi	r6,1
 8202e04:	8009883a 	mov	r4,r16
 8202e08:	82033e40 	call	82033e4 <_strerror_r>
 8202e0c:	10000326 	beq	r2,zero,8202e1c <_perror_r+0x44>
 8202e10:	81400317 	ldw	r5,12(r16)
 8202e14:	1009883a 	mov	r4,r2
 8202e18:	820aac00 	call	820aac0 <fputs>
 8202e1c:	81400317 	ldw	r5,12(r16)
 8202e20:	01000284 	movi	r4,10
 8202e24:	820a9c80 	call	820a9c8 <fputc>
 8202e28:	dfc00217 	ldw	ra,8(sp)
 8202e2c:	dc000117 	ldw	r16,4(sp)
 8202e30:	dec00304 	addi	sp,sp,12
 8202e34:	f800283a 	ret
 8202e38:	21400317 	ldw	r5,12(r4)
 8202e3c:	1009883a 	mov	r4,r2
 8202e40:	820aac00 	call	820aac0 <fputs>
 8202e44:	81400317 	ldw	r5,12(r16)
 8202e48:	01020974 	movhi	r4,2085
 8202e4c:	21338f04 	addi	r4,r4,-12740
 8202e50:	820aac00 	call	820aac0 <fputs>
 8202e54:	003fe806 	br	8202df8 <_perror_r+0x20>

08202e58 <perror>:
 8202e58:	00820974 	movhi	r2,2085
 8202e5c:	108e3004 	addi	r2,r2,14528
 8202e60:	200b883a 	mov	r5,r4
 8202e64:	11000017 	ldw	r4,0(r2)
 8202e68:	8202dd81 	jmpi	8202dd8 <_perror_r>

08202e6c <_printf_r>:
 8202e6c:	defffd04 	addi	sp,sp,-12
 8202e70:	2805883a 	mov	r2,r5
 8202e74:	dfc00015 	stw	ra,0(sp)
 8202e78:	d9800115 	stw	r6,4(sp)
 8202e7c:	d9c00215 	stw	r7,8(sp)
 8202e80:	21400217 	ldw	r5,8(r4)
 8202e84:	d9c00104 	addi	r7,sp,4
 8202e88:	100d883a 	mov	r6,r2
 8202e8c:	82065380 	call	8206538 <___vfprintf_internal_r>
 8202e90:	dfc00017 	ldw	ra,0(sp)
 8202e94:	dec00304 	addi	sp,sp,12
 8202e98:	f800283a 	ret

08202e9c <printf>:
 8202e9c:	defffc04 	addi	sp,sp,-16
 8202ea0:	dfc00015 	stw	ra,0(sp)
 8202ea4:	d9400115 	stw	r5,4(sp)
 8202ea8:	d9800215 	stw	r6,8(sp)
 8202eac:	d9c00315 	stw	r7,12(sp)
 8202eb0:	00820974 	movhi	r2,2085
 8202eb4:	108e3004 	addi	r2,r2,14528
 8202eb8:	10800017 	ldw	r2,0(r2)
 8202ebc:	200b883a 	mov	r5,r4
 8202ec0:	d9800104 	addi	r6,sp,4
 8202ec4:	11000217 	ldw	r4,8(r2)
 8202ec8:	82087300 	call	8208730 <__vfprintf_internal>
 8202ecc:	dfc00017 	ldw	ra,0(sp)
 8202ed0:	dec00404 	addi	sp,sp,16
 8202ed4:	f800283a 	ret

08202ed8 <_putc_r>:
 8202ed8:	defffc04 	addi	sp,sp,-16
 8202edc:	dc000215 	stw	r16,8(sp)
 8202ee0:	dfc00315 	stw	ra,12(sp)
 8202ee4:	2021883a 	mov	r16,r4
 8202ee8:	20000226 	beq	r4,zero,8202ef4 <_putc_r+0x1c>
 8202eec:	20800e17 	ldw	r2,56(r4)
 8202ef0:	10001b26 	beq	r2,zero,8202f60 <_putc_r+0x88>
 8202ef4:	30800217 	ldw	r2,8(r6)
 8202ef8:	10bfffc4 	addi	r2,r2,-1
 8202efc:	30800215 	stw	r2,8(r6)
 8202f00:	10000a16 	blt	r2,zero,8202f2c <_putc_r+0x54>
 8202f04:	30800017 	ldw	r2,0(r6)
 8202f08:	11400005 	stb	r5,0(r2)
 8202f0c:	30800017 	ldw	r2,0(r6)
 8202f10:	10c00044 	addi	r3,r2,1
 8202f14:	30c00015 	stw	r3,0(r6)
 8202f18:	10800003 	ldbu	r2,0(r2)
 8202f1c:	dfc00317 	ldw	ra,12(sp)
 8202f20:	dc000217 	ldw	r16,8(sp)
 8202f24:	dec00404 	addi	sp,sp,16
 8202f28:	f800283a 	ret
 8202f2c:	30c00617 	ldw	r3,24(r6)
 8202f30:	10c00616 	blt	r2,r3,8202f4c <_putc_r+0x74>
 8202f34:	30800017 	ldw	r2,0(r6)
 8202f38:	00c00284 	movi	r3,10
 8202f3c:	11400005 	stb	r5,0(r2)
 8202f40:	30800017 	ldw	r2,0(r6)
 8202f44:	11400003 	ldbu	r5,0(r2)
 8202f48:	28fff11e 	bne	r5,r3,8202f10 <_putc_r+0x38>
 8202f4c:	8009883a 	mov	r4,r16
 8202f50:	dfc00317 	ldw	ra,12(sp)
 8202f54:	dc000217 	ldw	r16,8(sp)
 8202f58:	dec00404 	addi	sp,sp,16
 8202f5c:	82088081 	jmpi	8208808 <__swbuf_r>
 8202f60:	d9400015 	stw	r5,0(sp)
 8202f64:	d9800115 	stw	r6,4(sp)
 8202f68:	820a9340 	call	820a934 <__sinit>
 8202f6c:	d9800117 	ldw	r6,4(sp)
 8202f70:	d9400017 	ldw	r5,0(sp)
 8202f74:	003fdf06 	br	8202ef4 <_putc_r+0x1c>

08202f78 <putc>:
 8202f78:	00820974 	movhi	r2,2085
 8202f7c:	defffc04 	addi	sp,sp,-16
 8202f80:	108e3004 	addi	r2,r2,14528
 8202f84:	dc000115 	stw	r16,4(sp)
 8202f88:	14000017 	ldw	r16,0(r2)
 8202f8c:	dc400215 	stw	r17,8(sp)
 8202f90:	dfc00315 	stw	ra,12(sp)
 8202f94:	2023883a 	mov	r17,r4
 8202f98:	80000226 	beq	r16,zero,8202fa4 <putc+0x2c>
 8202f9c:	80800e17 	ldw	r2,56(r16)
 8202fa0:	10001a26 	beq	r2,zero,820300c <putc+0x94>
 8202fa4:	28800217 	ldw	r2,8(r5)
 8202fa8:	10bfffc4 	addi	r2,r2,-1
 8202fac:	28800215 	stw	r2,8(r5)
 8202fb0:	10000b16 	blt	r2,zero,8202fe0 <putc+0x68>
 8202fb4:	28800017 	ldw	r2,0(r5)
 8202fb8:	14400005 	stb	r17,0(r2)
 8202fbc:	28800017 	ldw	r2,0(r5)
 8202fc0:	10c00044 	addi	r3,r2,1
 8202fc4:	28c00015 	stw	r3,0(r5)
 8202fc8:	10800003 	ldbu	r2,0(r2)
 8202fcc:	dfc00317 	ldw	ra,12(sp)
 8202fd0:	dc400217 	ldw	r17,8(sp)
 8202fd4:	dc000117 	ldw	r16,4(sp)
 8202fd8:	dec00404 	addi	sp,sp,16
 8202fdc:	f800283a 	ret
 8202fe0:	28c00617 	ldw	r3,24(r5)
 8202fe4:	10c00e16 	blt	r2,r3,8203020 <putc+0xa8>
 8202fe8:	28800017 	ldw	r2,0(r5)
 8202fec:	01000284 	movi	r4,10
 8202ff0:	14400005 	stb	r17,0(r2)
 8202ff4:	28800017 	ldw	r2,0(r5)
 8202ff8:	10c00003 	ldbu	r3,0(r2)
 8202ffc:	193ff01e 	bne	r3,r4,8202fc0 <putc+0x48>
 8203000:	280d883a 	mov	r6,r5
 8203004:	180b883a 	mov	r5,r3
 8203008:	00000706 	br	8203028 <putc+0xb0>
 820300c:	8009883a 	mov	r4,r16
 8203010:	d9400015 	stw	r5,0(sp)
 8203014:	820a9340 	call	820a934 <__sinit>
 8203018:	d9400017 	ldw	r5,0(sp)
 820301c:	003fe106 	br	8202fa4 <putc+0x2c>
 8203020:	280d883a 	mov	r6,r5
 8203024:	880b883a 	mov	r5,r17
 8203028:	8009883a 	mov	r4,r16
 820302c:	dfc00317 	ldw	ra,12(sp)
 8203030:	dc400217 	ldw	r17,8(sp)
 8203034:	dc000117 	ldw	r16,4(sp)
 8203038:	dec00404 	addi	sp,sp,16
 820303c:	82088081 	jmpi	8208808 <__swbuf_r>

08203040 <_putchar_r>:
 8203040:	21800217 	ldw	r6,8(r4)
 8203044:	8202ed81 	jmpi	8202ed8 <_putc_r>

08203048 <putchar>:
 8203048:	00820974 	movhi	r2,2085
 820304c:	108e3004 	addi	r2,r2,14528
 8203050:	200b883a 	mov	r5,r4
 8203054:	11000017 	ldw	r4,0(r2)
 8203058:	21800217 	ldw	r6,8(r4)
 820305c:	8202ed81 	jmpi	8202ed8 <_putc_r>

08203060 <_puts_r>:
 8203060:	defff604 	addi	sp,sp,-40
 8203064:	dc000715 	stw	r16,28(sp)
 8203068:	2021883a 	mov	r16,r4
 820306c:	2809883a 	mov	r4,r5
 8203070:	dc400815 	stw	r17,32(sp)
 8203074:	dfc00915 	stw	ra,36(sp)
 8203078:	2823883a 	mov	r17,r5
 820307c:	8203a5c0 	call	8203a5c <strlen>
 8203080:	10c00044 	addi	r3,r2,1
 8203084:	d8800115 	stw	r2,4(sp)
 8203088:	00820974 	movhi	r2,2085
 820308c:	10b39004 	addi	r2,r2,-12736
 8203090:	d8800215 	stw	r2,8(sp)
 8203094:	00800044 	movi	r2,1
 8203098:	d8800315 	stw	r2,12(sp)
 820309c:	00800084 	movi	r2,2
 82030a0:	dc400015 	stw	r17,0(sp)
 82030a4:	d8c00615 	stw	r3,24(sp)
 82030a8:	dec00415 	stw	sp,16(sp)
 82030ac:	d8800515 	stw	r2,20(sp)
 82030b0:	80000226 	beq	r16,zero,82030bc <_puts_r+0x5c>
 82030b4:	80800e17 	ldw	r2,56(r16)
 82030b8:	10001426 	beq	r2,zero,820310c <_puts_r+0xac>
 82030bc:	81400217 	ldw	r5,8(r16)
 82030c0:	2880030b 	ldhu	r2,12(r5)
 82030c4:	10c8000c 	andi	r3,r2,8192
 82030c8:	1800061e 	bne	r3,zero,82030e4 <_puts_r+0x84>
 82030cc:	29001917 	ldw	r4,100(r5)
 82030d0:	00f7ffc4 	movi	r3,-8193
 82030d4:	10880014 	ori	r2,r2,8192
 82030d8:	20c6703a 	and	r3,r4,r3
 82030dc:	2880030d 	sth	r2,12(r5)
 82030e0:	28c01915 	stw	r3,100(r5)
 82030e4:	d9800404 	addi	r6,sp,16
 82030e8:	8009883a 	mov	r4,r16
 82030ec:	820af0c0 	call	820af0c <__sfvwrite_r>
 82030f0:	1000091e 	bne	r2,zero,8203118 <_puts_r+0xb8>
 82030f4:	00800284 	movi	r2,10
 82030f8:	dfc00917 	ldw	ra,36(sp)
 82030fc:	dc400817 	ldw	r17,32(sp)
 8203100:	dc000717 	ldw	r16,28(sp)
 8203104:	dec00a04 	addi	sp,sp,40
 8203108:	f800283a 	ret
 820310c:	8009883a 	mov	r4,r16
 8203110:	820a9340 	call	820a934 <__sinit>
 8203114:	003fe906 	br	82030bc <_puts_r+0x5c>
 8203118:	00bfffc4 	movi	r2,-1
 820311c:	003ff606 	br	82030f8 <_puts_r+0x98>

08203120 <puts>:
 8203120:	00820974 	movhi	r2,2085
 8203124:	108e3004 	addi	r2,r2,14528
 8203128:	200b883a 	mov	r5,r4
 820312c:	11000017 	ldw	r4,0(r2)
 8203130:	82030601 	jmpi	8203060 <_puts_r>

08203134 <__srget_r>:
 8203134:	defffd04 	addi	sp,sp,-12
 8203138:	dc400115 	stw	r17,4(sp)
 820313c:	dc000015 	stw	r16,0(sp)
 8203140:	dfc00215 	stw	ra,8(sp)
 8203144:	2023883a 	mov	r17,r4
 8203148:	2821883a 	mov	r16,r5
 820314c:	20000226 	beq	r4,zero,8203158 <__srget_r+0x24>
 8203150:	20800e17 	ldw	r2,56(r4)
 8203154:	10001026 	beq	r2,zero,8203198 <__srget_r+0x64>
 8203158:	800b883a 	mov	r5,r16
 820315c:	8809883a 	mov	r4,r17
 8203160:	820d6d00 	call	820d6d0 <__srefill_r>
 8203164:	10000e1e 	bne	r2,zero,82031a0 <__srget_r+0x6c>
 8203168:	80c00017 	ldw	r3,0(r16)
 820316c:	80800117 	ldw	r2,4(r16)
 8203170:	19000044 	addi	r4,r3,1
 8203174:	10bfffc4 	addi	r2,r2,-1
 8203178:	80800115 	stw	r2,4(r16)
 820317c:	81000015 	stw	r4,0(r16)
 8203180:	18800003 	ldbu	r2,0(r3)
 8203184:	dfc00217 	ldw	ra,8(sp)
 8203188:	dc400117 	ldw	r17,4(sp)
 820318c:	dc000017 	ldw	r16,0(sp)
 8203190:	dec00304 	addi	sp,sp,12
 8203194:	f800283a 	ret
 8203198:	820a9340 	call	820a934 <__sinit>
 820319c:	003fee06 	br	8203158 <__srget_r+0x24>
 82031a0:	00bfffc4 	movi	r2,-1
 82031a4:	003ff706 	br	8203184 <__srget_r+0x50>

082031a8 <__srget>:
 82031a8:	00820974 	movhi	r2,2085
 82031ac:	108e3004 	addi	r2,r2,14528
 82031b0:	200b883a 	mov	r5,r4
 82031b4:	11000017 	ldw	r4,0(r2)
 82031b8:	82031341 	jmpi	8203134 <__srget_r>

082031bc <_sprintf_r>:
 82031bc:	deffe404 	addi	sp,sp,-112
 82031c0:	2807883a 	mov	r3,r5
 82031c4:	dfc01a15 	stw	ra,104(sp)
 82031c8:	d9c01b15 	stw	r7,108(sp)
 82031cc:	00a00034 	movhi	r2,32768
 82031d0:	10bfffc4 	addi	r2,r2,-1
 82031d4:	02008204 	movi	r8,520
 82031d8:	d8800215 	stw	r2,8(sp)
 82031dc:	d8800515 	stw	r2,20(sp)
 82031e0:	d9c01b04 	addi	r7,sp,108
 82031e4:	d80b883a 	mov	r5,sp
 82031e8:	00bfffc4 	movi	r2,-1
 82031ec:	d8c00015 	stw	r3,0(sp)
 82031f0:	d8c00415 	stw	r3,16(sp)
 82031f4:	da00030d 	sth	r8,12(sp)
 82031f8:	d880038d 	sth	r2,14(sp)
 82031fc:	82043580 	call	8204358 <___svfprintf_internal_r>
 8203200:	d8c00017 	ldw	r3,0(sp)
 8203204:	18000005 	stb	zero,0(r3)
 8203208:	dfc01a17 	ldw	ra,104(sp)
 820320c:	dec01c04 	addi	sp,sp,112
 8203210:	f800283a 	ret

08203214 <sprintf>:
 8203214:	deffe304 	addi	sp,sp,-116
 8203218:	2007883a 	mov	r3,r4
 820321c:	dfc01a15 	stw	ra,104(sp)
 8203220:	d9801b15 	stw	r6,108(sp)
 8203224:	d9c01c15 	stw	r7,112(sp)
 8203228:	01020974 	movhi	r4,2085
 820322c:	210e3004 	addi	r4,r4,14528
 8203230:	21000017 	ldw	r4,0(r4)
 8203234:	00a00034 	movhi	r2,32768
 8203238:	10bfffc4 	addi	r2,r2,-1
 820323c:	280d883a 	mov	r6,r5
 8203240:	02008204 	movi	r8,520
 8203244:	d8800215 	stw	r2,8(sp)
 8203248:	d8800515 	stw	r2,20(sp)
 820324c:	d9c01b04 	addi	r7,sp,108
 8203250:	d80b883a 	mov	r5,sp
 8203254:	00bfffc4 	movi	r2,-1
 8203258:	d8c00015 	stw	r3,0(sp)
 820325c:	d8c00415 	stw	r3,16(sp)
 8203260:	da00030d 	sth	r8,12(sp)
 8203264:	d880038d 	sth	r2,14(sp)
 8203268:	82043580 	call	8204358 <___svfprintf_internal_r>
 820326c:	d8c00017 	ldw	r3,0(sp)
 8203270:	18000005 	stb	zero,0(r3)
 8203274:	dfc01a17 	ldw	ra,104(sp)
 8203278:	dec01d04 	addi	sp,sp,116
 820327c:	f800283a 	ret

08203280 <strchr>:
 8203280:	2ac03fcc 	andi	r11,r5,255
 8203284:	2813883a 	mov	r9,r5
 8203288:	208000cc 	andi	r2,r4,3
 820328c:	58003726 	beq	r11,zero,820336c <strchr+0xec>
 8203290:	10000b26 	beq	r2,zero,82032c0 <strchr+0x40>
 8203294:	20800003 	ldbu	r2,0(r4)
 8203298:	10003226 	beq	r2,zero,8203364 <strchr+0xe4>
 820329c:	28c03fcc 	andi	r3,r5,255
 82032a0:	5880041e 	bne	r11,r2,82032b4 <strchr+0x34>
 82032a4:	00004d06 	br	82033dc <strchr+0x15c>
 82032a8:	20800003 	ldbu	r2,0(r4)
 82032ac:	10002d26 	beq	r2,zero,8203364 <strchr+0xe4>
 82032b0:	18804a26 	beq	r3,r2,82033dc <strchr+0x15c>
 82032b4:	21000044 	addi	r4,r4,1
 82032b8:	208000cc 	andi	r2,r4,3
 82032bc:	103ffa1e 	bne	r2,zero,82032a8 <strchr+0x28>
 82032c0:	29403fcc 	andi	r5,r5,255
 82032c4:	2814923a 	slli	r10,r5,8
 82032c8:	20800017 	ldw	r2,0(r4)
 82032cc:	01bfbff4 	movhi	r6,65279
 82032d0:	2a8ab03a 	or	r5,r5,r10
 82032d4:	2814943a 	slli	r10,r5,16
 82032d8:	31bfbfc4 	addi	r6,r6,-257
 82032dc:	119b883a 	add	r13,r2,r6
 82032e0:	5154b03a 	or	r10,r10,r5
 82032e4:	008e303a 	nor	r7,zero,r2
 82032e8:	5084f03a 	xor	r2,r10,r2
 82032ec:	1191883a 	add	r8,r2,r6
 82032f0:	0086303a 	nor	r3,zero,r2
 82032f4:	03202074 	movhi	r12,32897
 82032f8:	69ca703a 	and	r5,r13,r7
 82032fc:	40c4703a 	and	r2,r8,r3
 8203300:	63202004 	addi	r12,r12,-32640
 8203304:	2884b03a 	or	r2,r5,r2
 8203308:	1304703a 	and	r2,r2,r12
 820330c:	10000c1e 	bne	r2,zero,8203340 <strchr+0xc0>
 8203310:	21000104 	addi	r4,r4,4
 8203314:	20c00017 	ldw	r3,0(r4)
 8203318:	50c4f03a 	xor	r2,r10,r3
 820331c:	1991883a 	add	r8,r3,r6
 8203320:	00ca303a 	nor	r5,zero,r3
 8203324:	118f883a 	add	r7,r2,r6
 8203328:	0086303a 	nor	r3,zero,r2
 820332c:	414a703a 	and	r5,r8,r5
 8203330:	38c4703a 	and	r2,r7,r3
 8203334:	2884b03a 	or	r2,r5,r2
 8203338:	1304703a 	and	r2,r2,r12
 820333c:	103ff426 	beq	r2,zero,8203310 <strchr+0x90>
 8203340:	20800003 	ldbu	r2,0(r4)
 8203344:	10000726 	beq	r2,zero,8203364 <strchr+0xe4>
 8203348:	58802426 	beq	r11,r2,82033dc <strchr+0x15c>
 820334c:	48c03fcc 	andi	r3,r9,255
 8203350:	00000106 	br	8203358 <strchr+0xd8>
 8203354:	18802126 	beq	r3,r2,82033dc <strchr+0x15c>
 8203358:	21000044 	addi	r4,r4,1
 820335c:	20800003 	ldbu	r2,0(r4)
 8203360:	103ffc1e 	bne	r2,zero,8203354 <strchr+0xd4>
 8203364:	0005883a 	mov	r2,zero
 8203368:	f800283a 	ret
 820336c:	10000526 	beq	r2,zero,8203384 <strchr+0x104>
 8203370:	20800003 	ldbu	r2,0(r4)
 8203374:	10001926 	beq	r2,zero,82033dc <strchr+0x15c>
 8203378:	21000044 	addi	r4,r4,1
 820337c:	208000cc 	andi	r2,r4,3
 8203380:	103ffb1e 	bne	r2,zero,8203370 <strchr+0xf0>
 8203384:	20800017 	ldw	r2,0(r4)
 8203388:	01bfbff4 	movhi	r6,65279
 820338c:	31bfbfc4 	addi	r6,r6,-257
 8203390:	0086303a 	nor	r3,zero,r2
 8203394:	01602074 	movhi	r5,32897
 8203398:	1185883a 	add	r2,r2,r6
 820339c:	29602004 	addi	r5,r5,-32640
 82033a0:	10c4703a 	and	r2,r2,r3
 82033a4:	1144703a 	and	r2,r2,r5
 82033a8:	1000071e 	bne	r2,zero,82033c8 <strchr+0x148>
 82033ac:	21000104 	addi	r4,r4,4
 82033b0:	20800017 	ldw	r2,0(r4)
 82033b4:	1187883a 	add	r3,r2,r6
 82033b8:	0084303a 	nor	r2,zero,r2
 82033bc:	1884703a 	and	r2,r3,r2
 82033c0:	1144703a 	and	r2,r2,r5
 82033c4:	103ff926 	beq	r2,zero,82033ac <strchr+0x12c>
 82033c8:	20800003 	ldbu	r2,0(r4)
 82033cc:	10000326 	beq	r2,zero,82033dc <strchr+0x15c>
 82033d0:	21000044 	addi	r4,r4,1
 82033d4:	20800003 	ldbu	r2,0(r4)
 82033d8:	103ffd1e 	bne	r2,zero,82033d0 <strchr+0x150>
 82033dc:	2005883a 	mov	r2,r4
 82033e0:	f800283a 	ret

082033e4 <_strerror_r>:
 82033e4:	deffff04 	addi	sp,sp,-4
 82033e8:	2807883a 	mov	r3,r5
 82033ec:	dfc00015 	stw	ra,0(sp)
 82033f0:	00802384 	movi	r2,142
 82033f4:	300b883a 	mov	r5,r6
 82033f8:	10c18736 	bltu	r2,r3,8203a18 <_strerror_r+0x634>
 82033fc:	181090ba 	slli	r8,r3,2
 8203400:	00820834 	movhi	r2,2080
 8203404:	108d0504 	addi	r2,r2,13332
 8203408:	4085883a 	add	r2,r8,r2
 820340c:	10800017 	ldw	r2,0(r2)
 8203410:	1000683a 	jmp	r2
 8203414:	08203650 	cmplti	zero,at,-32551
 8203418:	08203a0c 	andi	zero,at,33000
 820341c:	08203a00 	call	8203a0 <OSCtxSw_SWITCH_PC+0x820360>
 8203420:	082039f4 	orhi	zero,at,32999
 8203424:	082039e8 	cmpgeui	zero,at,32999
 8203428:	082039dc 	xori	zero,at,32999
 820342c:	082039d0 	cmplti	zero,at,-32537
 8203430:	082039c4 	addi	zero,at,-32537
 8203434:	082039b8 	rdprs	zero,at,-32538
 8203438:	082039ac 	andhi	zero,at,32998
 820343c:	082039a0 	cmpeqi	zero,at,-32538
 8203440:	08203994 	ori	zero,at,32998
 8203444:	08203988 	cmpgei	zero,at,-32538
 8203448:	0820397c 	xorhi	zero,at,32997
 820344c:	08203970 	cmpltui	zero,at,32997
 8203450:	08203a18 	cmpnei	zero,at,-32536
 8203454:	08203964 	muli	zero,at,-32539
 8203458:	08203958 	cmpnei	zero,at,-32539
 820345c:	0820394c 	andi	zero,at,32997
 8203460:	08203940 	call	820394 <OSCtxSw_SWITCH_PC+0x820354>
 8203464:	08203934 	orhi	zero,at,32996
 8203468:	08203928 	cmpgeui	zero,at,32996
 820346c:	0820391c 	xori	zero,at,32996
 8203470:	08203910 	cmplti	zero,at,-32540
 8203474:	08203904 	addi	zero,at,-32540
 8203478:	082038f8 	rdprs	zero,at,-32541
 820347c:	082038ec 	andhi	zero,at,32995
 8203480:	082038e0 	cmpeqi	zero,at,-32541
 8203484:	082038d4 	ori	zero,at,32995
 8203488:	082038c8 	cmpgei	zero,at,-32541
 820348c:	082038bc 	xorhi	zero,at,32994
 8203490:	082038b0 	cmpltui	zero,at,32994
 8203494:	082038a4 	muli	zero,at,-32542
 8203498:	08203898 	cmpnei	zero,at,-32542
 820349c:	0820388c 	andi	zero,at,32994
 82034a0:	08203880 	call	820388 <OSCtxSw_SWITCH_PC+0x820348>
 82034a4:	08203874 	orhi	zero,at,32993
 82034a8:	08203a18 	cmpnei	zero,at,-32536
 82034ac:	08203a18 	cmpnei	zero,at,-32536
 82034b0:	08203a18 	cmpnei	zero,at,-32536
 82034b4:	08203a18 	cmpnei	zero,at,-32536
 82034b8:	08203a18 	cmpnei	zero,at,-32536
 82034bc:	08203a18 	cmpnei	zero,at,-32536
 82034c0:	08203a18 	cmpnei	zero,at,-32536
 82034c4:	08203a18 	cmpnei	zero,at,-32536
 82034c8:	08203868 	cmpgeui	zero,at,32993
 82034cc:	0820385c 	xori	zero,at,32993
 82034d0:	08203a18 	cmpnei	zero,at,-32536
 82034d4:	08203a18 	cmpnei	zero,at,-32536
 82034d8:	08203a18 	cmpnei	zero,at,-32536
 82034dc:	08203a18 	cmpnei	zero,at,-32536
 82034e0:	08203a18 	cmpnei	zero,at,-32536
 82034e4:	08203a18 	cmpnei	zero,at,-32536
 82034e8:	08203a18 	cmpnei	zero,at,-32536
 82034ec:	08203a18 	cmpnei	zero,at,-32536
 82034f0:	08203a18 	cmpnei	zero,at,-32536
 82034f4:	08203a18 	cmpnei	zero,at,-32536
 82034f8:	08203a18 	cmpnei	zero,at,-32536
 82034fc:	08203a18 	cmpnei	zero,at,-32536
 8203500:	08203a18 	cmpnei	zero,at,-32536
 8203504:	08203850 	cmplti	zero,at,-32543
 8203508:	08203844 	addi	zero,at,-32543
 820350c:	08203838 	rdprs	zero,at,-32544
 8203510:	0820382c 	andhi	zero,at,32992
 8203514:	08203a18 	cmpnei	zero,at,-32536
 8203518:	08203a18 	cmpnei	zero,at,-32536
 820351c:	08203a18 	cmpnei	zero,at,-32536
 8203520:	08203820 	cmpeqi	zero,at,-32544
 8203524:	08203a18 	cmpnei	zero,at,-32536
 8203528:	08203a18 	cmpnei	zero,at,-32536
 820352c:	08203a18 	cmpnei	zero,at,-32536
 8203530:	08203814 	ori	zero,at,32992
 8203534:	08203a18 	cmpnei	zero,at,-32536
 8203538:	08203a18 	cmpnei	zero,at,-32536
 820353c:	08203808 	cmpgei	zero,at,-32544
 8203540:	08203a18 	cmpnei	zero,at,-32536
 8203544:	08203a18 	cmpnei	zero,at,-32536
 8203548:	082037fc 	xorhi	zero,at,32991
 820354c:	08203a18 	cmpnei	zero,at,-32536
 8203550:	08203a18 	cmpnei	zero,at,-32536
 8203554:	08203a18 	cmpnei	zero,at,-32536
 8203558:	08203a18 	cmpnei	zero,at,-32536
 820355c:	08203a18 	cmpnei	zero,at,-32536
 8203560:	08203a18 	cmpnei	zero,at,-32536
 8203564:	08203a18 	cmpnei	zero,at,-32536
 8203568:	08203a18 	cmpnei	zero,at,-32536
 820356c:	08203a18 	cmpnei	zero,at,-32536
 8203570:	08203a18 	cmpnei	zero,at,-32536
 8203574:	082037f0 	cmpltui	zero,at,32991
 8203578:	08203a18 	cmpnei	zero,at,-32536
 820357c:	082037e4 	muli	zero,at,-32545
 8203580:	082037d8 	cmpnei	zero,at,-32545
 8203584:	082037cc 	andi	zero,at,32991
 8203588:	08203a18 	cmpnei	zero,at,-32536
 820358c:	08203a18 	cmpnei	zero,at,-32536
 8203590:	082037c0 	call	82037c <OSCtxSw_SWITCH_PC+0x82033c>
 8203594:	08203a18 	cmpnei	zero,at,-32536
 8203598:	08203a18 	cmpnei	zero,at,-32536
 820359c:	08203a18 	cmpnei	zero,at,-32536
 82035a0:	08203a18 	cmpnei	zero,at,-32536
 82035a4:	08203a18 	cmpnei	zero,at,-32536
 82035a8:	08203a18 	cmpnei	zero,at,-32536
 82035ac:	08203a18 	cmpnei	zero,at,-32536
 82035b0:	08203a18 	cmpnei	zero,at,-32536
 82035b4:	082037b4 	orhi	zero,at,32990
 82035b8:	082037a8 	cmpgeui	zero,at,32990
 82035bc:	0820379c 	xori	zero,at,32990
 82035c0:	08203790 	cmplti	zero,at,-32546
 82035c4:	08203784 	addi	zero,at,-32546
 82035c8:	08203778 	rdprs	zero,at,-32547
 82035cc:	08203a18 	cmpnei	zero,at,-32536
 82035d0:	0820376c 	andhi	zero,at,32989
 82035d4:	08203760 	cmpeqi	zero,at,-32547
 82035d8:	08203754 	ori	zero,at,32989
 82035dc:	08203748 	cmpgei	zero,at,-32547
 82035e0:	0820373c 	xorhi	zero,at,32988
 82035e4:	08203730 	cmpltui	zero,at,32988
 82035e8:	08203724 	muli	zero,at,-32548
 82035ec:	08203718 	cmpnei	zero,at,-32548
 82035f0:	0820370c 	andi	zero,at,32988
 82035f4:	08203700 	call	820370 <OSCtxSw_SWITCH_PC+0x820330>
 82035f8:	082036f4 	orhi	zero,at,32987
 82035fc:	082036e8 	cmpgeui	zero,at,32987
 8203600:	082036dc 	xori	zero,at,32987
 8203604:	08203a18 	cmpnei	zero,at,-32536
 8203608:	082036d0 	cmplti	zero,at,-32549
 820360c:	082036c4 	addi	zero,at,-32549
 8203610:	082036b8 	rdprs	zero,at,-32550
 8203614:	082036ac 	andhi	zero,at,32986
 8203618:	08203a18 	cmpnei	zero,at,-32536
 820361c:	08203a18 	cmpnei	zero,at,-32536
 8203620:	08203a18 	cmpnei	zero,at,-32536
 8203624:	08203a18 	cmpnei	zero,at,-32536
 8203628:	08203a18 	cmpnei	zero,at,-32536
 820362c:	082036a0 	cmpeqi	zero,at,-32550
 8203630:	08203a18 	cmpnei	zero,at,-32536
 8203634:	08203a18 	cmpnei	zero,at,-32536
 8203638:	08203a18 	cmpnei	zero,at,-32536
 820363c:	08203694 	ori	zero,at,32986
 8203640:	08203688 	cmpgei	zero,at,-32550
 8203644:	0820367c 	xorhi	zero,at,32985
 8203648:	08203670 	cmpltui	zero,at,32985
 820364c:	08203664 	muli	zero,at,-32551
 8203650:	00820974 	movhi	r2,2085
 8203654:	10b39104 	addi	r2,r2,-12732
 8203658:	dfc00017 	ldw	ra,0(sp)
 820365c:	dec00104 	addi	sp,sp,4
 8203660:	f800283a 	ret
 8203664:	00820974 	movhi	r2,2085
 8203668:	10b52e04 	addi	r2,r2,-11080
 820366c:	003ffa06 	br	8203658 <_strerror_r+0x274>
 8203670:	00820974 	movhi	r2,2085
 8203674:	10b52804 	addi	r2,r2,-11104
 8203678:	003ff706 	br	8203658 <_strerror_r+0x274>
 820367c:	00820974 	movhi	r2,2085
 8203680:	10b52304 	addi	r2,r2,-11124
 8203684:	003ff406 	br	8203658 <_strerror_r+0x274>
 8203688:	00820974 	movhi	r2,2085
 820368c:	10b53c04 	addi	r2,r2,-11024
 8203690:	003ff106 	br	8203658 <_strerror_r+0x274>
 8203694:	00820974 	movhi	r2,2085
 8203698:	10b47a04 	addi	r2,r2,-11800
 820369c:	003fee06 	br	8203658 <_strerror_r+0x274>
 82036a0:	00820974 	movhi	r2,2085
 82036a4:	10b44804 	addi	r2,r2,-12000
 82036a8:	003feb06 	br	8203658 <_strerror_r+0x274>
 82036ac:	00820974 	movhi	r2,2085
 82036b0:	10b51604 	addi	r2,r2,-11176
 82036b4:	003fe806 	br	8203658 <_strerror_r+0x274>
 82036b8:	00820974 	movhi	r2,2085
 82036bc:	10b51c04 	addi	r2,r2,-11152
 82036c0:	003fe506 	br	8203658 <_strerror_r+0x274>
 82036c4:	00820974 	movhi	r2,2085
 82036c8:	10b41704 	addi	r2,r2,-12196
 82036cc:	003fe206 	br	8203658 <_strerror_r+0x274>
 82036d0:	00820974 	movhi	r2,2085
 82036d4:	10b50704 	addi	r2,r2,-11236
 82036d8:	003fdf06 	br	8203658 <_strerror_r+0x274>
 82036dc:	00820974 	movhi	r2,2085
 82036e0:	10b4a404 	addi	r2,r2,-11632
 82036e4:	003fdc06 	br	8203658 <_strerror_r+0x274>
 82036e8:	00820974 	movhi	r2,2085
 82036ec:	10b54604 	addi	r2,r2,-10984
 82036f0:	003fd906 	br	8203658 <_strerror_r+0x274>
 82036f4:	00820974 	movhi	r2,2085
 82036f8:	10b3c904 	addi	r2,r2,-12508
 82036fc:	003fd606 	br	8203658 <_strerror_r+0x274>
 8203700:	00820974 	movhi	r2,2085
 8203704:	10b3bb04 	addi	r2,r2,-12564
 8203708:	003fd306 	br	8203658 <_strerror_r+0x274>
 820370c:	00820974 	movhi	r2,2085
 8203710:	10b3fd04 	addi	r2,r2,-12300
 8203714:	003fd006 	br	8203658 <_strerror_r+0x274>
 8203718:	00820974 	movhi	r2,2085
 820371c:	10b43d04 	addi	r2,r2,-12044
 8203720:	003fcd06 	br	8203658 <_strerror_r+0x274>
 8203724:	00820974 	movhi	r2,2085
 8203728:	10b3f904 	addi	r2,r2,-12316
 820372c:	003fca06 	br	8203658 <_strerror_r+0x274>
 8203730:	00820974 	movhi	r2,2085
 8203734:	10b54b04 	addi	r2,r2,-10964
 8203738:	003fc706 	br	8203658 <_strerror_r+0x274>
 820373c:	00820974 	movhi	r2,2085
 8203740:	10b40e04 	addi	r2,r2,-12232
 8203744:	003fc406 	br	8203658 <_strerror_r+0x274>
 8203748:	00820974 	movhi	r2,2085
 820374c:	10b48304 	addi	r2,r2,-11764
 8203750:	003fc106 	br	8203658 <_strerror_r+0x274>
 8203754:	00820974 	movhi	r2,2085
 8203758:	10b50d04 	addi	r2,r2,-11212
 820375c:	003fbe06 	br	8203658 <_strerror_r+0x274>
 8203760:	00820974 	movhi	r2,2085
 8203764:	10b50104 	addi	r2,r2,-11260
 8203768:	003fbb06 	br	8203658 <_strerror_r+0x274>
 820376c:	00820974 	movhi	r2,2085
 8203770:	10b4f504 	addi	r2,r2,-11308
 8203774:	003fb806 	br	8203658 <_strerror_r+0x274>
 8203778:	00820974 	movhi	r2,2085
 820377c:	10b4ef04 	addi	r2,r2,-11332
 8203780:	003fb506 	br	8203658 <_strerror_r+0x274>
 8203784:	00820974 	movhi	r2,2085
 8203788:	10b4e704 	addi	r2,r2,-11364
 820378c:	003fb206 	br	8203658 <_strerror_r+0x274>
 8203790:	00820974 	movhi	r2,2085
 8203794:	10b4df04 	addi	r2,r2,-11396
 8203798:	003faf06 	br	8203658 <_strerror_r+0x274>
 820379c:	00820974 	movhi	r2,2085
 82037a0:	10b4d304 	addi	r2,r2,-11444
 82037a4:	003fac06 	br	8203658 <_strerror_r+0x274>
 82037a8:	00820974 	movhi	r2,2085
 82037ac:	10b4ca04 	addi	r2,r2,-11480
 82037b0:	003fa906 	br	8203658 <_strerror_r+0x274>
 82037b4:	00820974 	movhi	r2,2085
 82037b8:	10b4fa04 	addi	r2,r2,-11288
 82037bc:	003fa606 	br	8203658 <_strerror_r+0x274>
 82037c0:	00820974 	movhi	r2,2085
 82037c4:	10b53304 	addi	r2,r2,-11060
 82037c8:	003fa306 	br	8203658 <_strerror_r+0x274>
 82037cc:	00820974 	movhi	r2,2085
 82037d0:	10b4c404 	addi	r2,r2,-11504
 82037d4:	003fa006 	br	8203658 <_strerror_r+0x274>
 82037d8:	00820974 	movhi	r2,2085
 82037dc:	10b4bd04 	addi	r2,r2,-11532
 82037e0:	003f9d06 	br	8203658 <_strerror_r+0x274>
 82037e4:	00820974 	movhi	r2,2085
 82037e8:	10b4b804 	addi	r2,r2,-11552
 82037ec:	003f9a06 	br	8203658 <_strerror_r+0x274>
 82037f0:	00820974 	movhi	r2,2085
 82037f4:	10b4b104 	addi	r2,r2,-11580
 82037f8:	003f9706 	br	8203658 <_strerror_r+0x274>
 82037fc:	00820974 	movhi	r2,2085
 8203800:	10b4ae04 	addi	r2,r2,-11592
 8203804:	003f9406 	br	8203658 <_strerror_r+0x274>
 8203808:	00820974 	movhi	r2,2085
 820380c:	10b4a904 	addi	r2,r2,-11612
 8203810:	003f9106 	br	8203658 <_strerror_r+0x274>
 8203814:	00820974 	movhi	r2,2085
 8203818:	10b4a004 	addi	r2,r2,-11648
 820381c:	003f8e06 	br	8203658 <_strerror_r+0x274>
 8203820:	00820974 	movhi	r2,2085
 8203824:	10b49a04 	addi	r2,r2,-11672
 8203828:	003f8b06 	br	8203658 <_strerror_r+0x274>
 820382c:	00820974 	movhi	r2,2085
 8203830:	10b49504 	addi	r2,r2,-11692
 8203834:	003f8806 	br	8203658 <_strerror_r+0x274>
 8203838:	00820974 	movhi	r2,2085
 820383c:	10b48f04 	addi	r2,r2,-11716
 8203840:	003f8506 	br	8203658 <_strerror_r+0x274>
 8203844:	00820974 	movhi	r2,2085
 8203848:	10b4d104 	addi	r2,r2,-11452
 820384c:	003f8206 	br	8203658 <_strerror_r+0x274>
 8203850:	00820974 	movhi	r2,2085
 8203854:	10b48b04 	addi	r2,r2,-11732
 8203858:	003f7f06 	br	8203658 <_strerror_r+0x274>
 820385c:	00820974 	movhi	r2,2085
 8203860:	10b48904 	addi	r2,r2,-11740
 8203864:	003f7c06 	br	8203658 <_strerror_r+0x274>
 8203868:	00820974 	movhi	r2,2085
 820386c:	10b48004 	addi	r2,r2,-11776
 8203870:	003f7906 	br	8203658 <_strerror_r+0x274>
 8203874:	00820974 	movhi	r2,2085
 8203878:	10b47504 	addi	r2,r2,-11820
 820387c:	003f7606 	br	8203658 <_strerror_r+0x274>
 8203880:	00820974 	movhi	r2,2085
 8203884:	10b46e04 	addi	r2,r2,-11848
 8203888:	003f7306 	br	8203658 <_strerror_r+0x274>
 820388c:	00820974 	movhi	r2,2085
 8203890:	10b46904 	addi	r2,r2,-11868
 8203894:	003f7006 	br	8203658 <_strerror_r+0x274>
 8203898:	00820974 	movhi	r2,2085
 820389c:	10b45d04 	addi	r2,r2,-11916
 82038a0:	003f6d06 	br	8203658 <_strerror_r+0x274>
 82038a4:	00820974 	movhi	r2,2085
 82038a8:	10b45a04 	addi	r2,r2,-11928
 82038ac:	003f6a06 	br	8203658 <_strerror_r+0x274>
 82038b0:	00820974 	movhi	r2,2085
 82038b4:	10b45604 	addi	r2,r2,-11944
 82038b8:	003f6706 	br	8203658 <_strerror_r+0x274>
 82038bc:	00820974 	movhi	r2,2085
 82038c0:	10b45004 	addi	r2,r2,-11968
 82038c4:	003f6406 	br	8203658 <_strerror_r+0x274>
 82038c8:	00820974 	movhi	r2,2085
 82038cc:	10b44c04 	addi	r2,r2,-11984
 82038d0:	003f6106 	br	8203658 <_strerror_r+0x274>
 82038d4:	00820974 	movhi	r2,2085
 82038d8:	10b44204 	addi	r2,r2,-12024
 82038dc:	003f5e06 	br	8203658 <_strerror_r+0x274>
 82038e0:	00820974 	movhi	r2,2085
 82038e4:	10b43904 	addi	r2,r2,-12060
 82038e8:	003f5b06 	br	8203658 <_strerror_r+0x274>
 82038ec:	00820974 	movhi	r2,2085
 82038f0:	10b43504 	addi	r2,r2,-12076
 82038f4:	003f5806 	br	8203658 <_strerror_r+0x274>
 82038f8:	00820974 	movhi	r2,2085
 82038fc:	10b42f04 	addi	r2,r2,-12100
 8203900:	003f5506 	br	8203658 <_strerror_r+0x274>
 8203904:	00820974 	movhi	r2,2085
 8203908:	10b42704 	addi	r2,r2,-12132
 820390c:	003f5206 	br	8203658 <_strerror_r+0x274>
 8203910:	00820974 	movhi	r2,2085
 8203914:	10b41f04 	addi	r2,r2,-12164
 8203918:	003f4f06 	br	8203658 <_strerror_r+0x274>
 820391c:	00820974 	movhi	r2,2085
 8203920:	10b40904 	addi	r2,r2,-12252
 8203924:	003f4c06 	br	8203658 <_strerror_r+0x274>
 8203928:	00820974 	movhi	r2,2085
 820392c:	10b40504 	addi	r2,r2,-12268
 8203930:	003f4906 	br	8203658 <_strerror_r+0x274>
 8203934:	00820974 	movhi	r2,2085
 8203938:	10b3f504 	addi	r2,r2,-12332
 820393c:	003f4606 	br	8203658 <_strerror_r+0x274>
 8203940:	00820974 	movhi	r2,2085
 8203944:	10b3f104 	addi	r2,r2,-12348
 8203948:	003f4306 	br	8203658 <_strerror_r+0x274>
 820394c:	00820974 	movhi	r2,2085
 8203950:	10b3ec04 	addi	r2,r2,-12368
 8203954:	003f4006 	br	8203658 <_strerror_r+0x274>
 8203958:	00820974 	movhi	r2,2085
 820395c:	10b3e904 	addi	r2,r2,-12380
 8203960:	003f3d06 	br	8203658 <_strerror_r+0x274>
 8203964:	00820974 	movhi	r2,2085
 8203968:	10b3e304 	addi	r2,r2,-12404
 820396c:	003f3a06 	br	8203658 <_strerror_r+0x274>
 8203970:	00820974 	movhi	r2,2085
 8203974:	10b3e004 	addi	r2,r2,-12416
 8203978:	003f3706 	br	8203658 <_strerror_r+0x274>
 820397c:	00820974 	movhi	r2,2085
 8203980:	10b3db04 	addi	r2,r2,-12436
 8203984:	003f3406 	br	8203658 <_strerror_r+0x274>
 8203988:	00820974 	movhi	r2,2085
 820398c:	10b3d604 	addi	r2,r2,-12456
 8203990:	003f3106 	br	8203658 <_strerror_r+0x274>
 8203994:	00820974 	movhi	r2,2085
 8203998:	10b3d104 	addi	r2,r2,-12476
 820399c:	003f2e06 	br	8203658 <_strerror_r+0x274>
 82039a0:	00820974 	movhi	r2,2085
 82039a4:	10b3c604 	addi	r2,r2,-12520
 82039a8:	003f2b06 	br	8203658 <_strerror_r+0x274>
 82039ac:	00820974 	movhi	r2,2085
 82039b0:	10b3c204 	addi	r2,r2,-12536
 82039b4:	003f2806 	br	8203658 <_strerror_r+0x274>
 82039b8:	00820974 	movhi	r2,2085
 82039bc:	10b3b604 	addi	r2,r2,-12584
 82039c0:	003f2506 	br	8203658 <_strerror_r+0x274>
 82039c4:	00820974 	movhi	r2,2085
 82039c8:	10b3b104 	addi	r2,r2,-12604
 82039cc:	003f2206 	br	8203658 <_strerror_r+0x274>
 82039d0:	00820974 	movhi	r2,2085
 82039d4:	10b3aa04 	addi	r2,r2,-12632
 82039d8:	003f1f06 	br	8203658 <_strerror_r+0x274>
 82039dc:	00820974 	movhi	r2,2085
 82039e0:	10b3a704 	addi	r2,r2,-12644
 82039e4:	003f1c06 	br	8203658 <_strerror_r+0x274>
 82039e8:	00820974 	movhi	r2,2085
 82039ec:	10b3a104 	addi	r2,r2,-12668
 82039f0:	003f1906 	br	8203658 <_strerror_r+0x274>
 82039f4:	00820974 	movhi	r2,2085
 82039f8:	10b39d04 	addi	r2,r2,-12684
 82039fc:	003f1606 	br	8203658 <_strerror_r+0x274>
 8203a00:	00820974 	movhi	r2,2085
 8203a04:	10b39604 	addi	r2,r2,-12712
 8203a08:	003f1306 	br	8203658 <_strerror_r+0x274>
 8203a0c:	00820974 	movhi	r2,2085
 8203a10:	10b39304 	addi	r2,r2,-12724
 8203a14:	003f1006 	br	8203658 <_strerror_r+0x274>
 8203a18:	38000726 	beq	r7,zero,8203a38 <_strerror_r+0x654>
 8203a1c:	380d883a 	mov	r6,r7
 8203a20:	1809883a 	mov	r4,r3
 8203a24:	82065300 	call	8206530 <_user_strerror>
 8203a28:	103f0b1e 	bne	r2,zero,8203658 <_strerror_r+0x274>
 8203a2c:	00820974 	movhi	r2,2085
 8203a30:	10b55904 	addi	r2,r2,-10908
 8203a34:	003f0806 	br	8203658 <_strerror_r+0x274>
 8203a38:	200f883a 	mov	r7,r4
 8203a3c:	003ff706 	br	8203a1c <_strerror_r+0x638>

08203a40 <strerror>:
 8203a40:	00820974 	movhi	r2,2085
 8203a44:	108e3004 	addi	r2,r2,14528
 8203a48:	200b883a 	mov	r5,r4
 8203a4c:	11000017 	ldw	r4,0(r2)
 8203a50:	000f883a 	mov	r7,zero
 8203a54:	000d883a 	mov	r6,zero
 8203a58:	82033e41 	jmpi	82033e4 <_strerror_r>

08203a5c <strlen>:
 8203a5c:	208000cc 	andi	r2,r4,3
 8203a60:	10002026 	beq	r2,zero,8203ae4 <strlen+0x88>
 8203a64:	20800007 	ldb	r2,0(r4)
 8203a68:	10002026 	beq	r2,zero,8203aec <strlen+0x90>
 8203a6c:	2005883a 	mov	r2,r4
 8203a70:	00000206 	br	8203a7c <strlen+0x20>
 8203a74:	10c00007 	ldb	r3,0(r2)
 8203a78:	18001826 	beq	r3,zero,8203adc <strlen+0x80>
 8203a7c:	10800044 	addi	r2,r2,1
 8203a80:	10c000cc 	andi	r3,r2,3
 8203a84:	183ffb1e 	bne	r3,zero,8203a74 <strlen+0x18>
 8203a88:	10c00017 	ldw	r3,0(r2)
 8203a8c:	01ffbff4 	movhi	r7,65279
 8203a90:	39ffbfc4 	addi	r7,r7,-257
 8203a94:	00ca303a 	nor	r5,zero,r3
 8203a98:	01a02074 	movhi	r6,32897
 8203a9c:	19c7883a 	add	r3,r3,r7
 8203aa0:	31a02004 	addi	r6,r6,-32640
 8203aa4:	1946703a 	and	r3,r3,r5
 8203aa8:	1986703a 	and	r3,r3,r6
 8203aac:	1800091e 	bne	r3,zero,8203ad4 <strlen+0x78>
 8203ab0:	10800104 	addi	r2,r2,4
 8203ab4:	10c00017 	ldw	r3,0(r2)
 8203ab8:	19cb883a 	add	r5,r3,r7
 8203abc:	00c6303a 	nor	r3,zero,r3
 8203ac0:	28c6703a 	and	r3,r5,r3
 8203ac4:	1986703a 	and	r3,r3,r6
 8203ac8:	183ff926 	beq	r3,zero,8203ab0 <strlen+0x54>
 8203acc:	00000106 	br	8203ad4 <strlen+0x78>
 8203ad0:	10800044 	addi	r2,r2,1
 8203ad4:	10c00007 	ldb	r3,0(r2)
 8203ad8:	183ffd1e 	bne	r3,zero,8203ad0 <strlen+0x74>
 8203adc:	1105c83a 	sub	r2,r2,r4
 8203ae0:	f800283a 	ret
 8203ae4:	2005883a 	mov	r2,r4
 8203ae8:	003fe706 	br	8203a88 <strlen+0x2c>
 8203aec:	0005883a 	mov	r2,zero
 8203af0:	f800283a 	ret

08203af4 <critical_factorization>:
 8203af4:	02c00044 	movi	r11,1
 8203af8:	5811883a 	mov	r8,r11
 8203afc:	0013883a 	mov	r9,zero
 8203b00:	00bfffc4 	movi	r2,-1
 8203b04:	2087883a 	add	r3,r4,r2
 8203b08:	1a0f883a 	add	r7,r3,r8
 8203b0c:	4a07883a 	add	r3,r9,r8
 8203b10:	20d5883a 	add	r10,r4,r3
 8203b14:	1940102e 	bgeu	r3,r5,8203b58 <critical_factorization+0x64>
 8203b18:	52800003 	ldbu	r10,0(r10)
 8203b1c:	39c00003 	ldbu	r7,0(r7)
 8203b20:	51c0042e 	bgeu	r10,r7,8203b34 <critical_factorization+0x40>
 8203b24:	1897c83a 	sub	r11,r3,r2
 8203b28:	1813883a 	mov	r9,r3
 8203b2c:	02000044 	movi	r8,1
 8203b30:	003ff406 	br	8203b04 <critical_factorization+0x10>
 8203b34:	51c00526 	beq	r10,r7,8203b4c <critical_factorization+0x58>
 8203b38:	02c00044 	movi	r11,1
 8203b3c:	4805883a 	mov	r2,r9
 8203b40:	5811883a 	mov	r8,r11
 8203b44:	4ad3883a 	add	r9,r9,r11
 8203b48:	003fee06 	br	8203b04 <critical_factorization+0x10>
 8203b4c:	42c02226 	beq	r8,r11,8203bd8 <critical_factorization+0xe4>
 8203b50:	42000044 	addi	r8,r8,1
 8203b54:	003feb06 	br	8203b04 <critical_factorization+0x10>
 8203b58:	03000044 	movi	r12,1
 8203b5c:	32c00015 	stw	r11,0(r6)
 8203b60:	6011883a 	mov	r8,r12
 8203b64:	0013883a 	mov	r9,zero
 8203b68:	02ffffc4 	movi	r11,-1
 8203b6c:	22c7883a 	add	r3,r4,r11
 8203b70:	1a0f883a 	add	r7,r3,r8
 8203b74:	4a07883a 	add	r3,r9,r8
 8203b78:	20d5883a 	add	r10,r4,r3
 8203b7c:	1940102e 	bgeu	r3,r5,8203bc0 <critical_factorization+0xcc>
 8203b80:	52800003 	ldbu	r10,0(r10)
 8203b84:	39c00003 	ldbu	r7,0(r7)
 8203b88:	3a80042e 	bgeu	r7,r10,8203b9c <critical_factorization+0xa8>
 8203b8c:	1ad9c83a 	sub	r12,r3,r11
 8203b90:	1813883a 	mov	r9,r3
 8203b94:	02000044 	movi	r8,1
 8203b98:	003ff406 	br	8203b6c <critical_factorization+0x78>
 8203b9c:	51c00526 	beq	r10,r7,8203bb4 <critical_factorization+0xc0>
 8203ba0:	03000044 	movi	r12,1
 8203ba4:	4817883a 	mov	r11,r9
 8203ba8:	6011883a 	mov	r8,r12
 8203bac:	4b13883a 	add	r9,r9,r12
 8203bb0:	003fee06 	br	8203b6c <critical_factorization+0x78>
 8203bb4:	43000c26 	beq	r8,r12,8203be8 <critical_factorization+0xf4>
 8203bb8:	42000044 	addi	r8,r8,1
 8203bbc:	003feb06 	br	8203b6c <critical_factorization+0x78>
 8203bc0:	5ac00044 	addi	r11,r11,1
 8203bc4:	10800044 	addi	r2,r2,1
 8203bc8:	58800236 	bltu	r11,r2,8203bd4 <critical_factorization+0xe0>
 8203bcc:	33000015 	stw	r12,0(r6)
 8203bd0:	5805883a 	mov	r2,r11
 8203bd4:	f800283a 	ret
 8203bd8:	4017883a 	mov	r11,r8
 8203bdc:	1813883a 	mov	r9,r3
 8203be0:	02000044 	movi	r8,1
 8203be4:	003fc706 	br	8203b04 <critical_factorization+0x10>
 8203be8:	4019883a 	mov	r12,r8
 8203bec:	1813883a 	mov	r9,r3
 8203bf0:	02000044 	movi	r8,1
 8203bf4:	003fdd06 	br	8203b6c <critical_factorization+0x78>

08203bf8 <two_way_long_needle>:
 8203bf8:	defef104 	addi	sp,sp,-1084
 8203bfc:	dc810715 	stw	r18,1052(sp)
 8203c00:	dc410615 	stw	r17,1048(sp)
 8203c04:	dc810004 	addi	r18,sp,1024
 8203c08:	3023883a 	mov	r17,r6
 8203c0c:	2807883a 	mov	r3,r5
 8203c10:	ddc10c15 	stw	r23,1072(sp)
 8203c14:	900d883a 	mov	r6,r18
 8203c18:	202f883a 	mov	r23,r4
 8203c1c:	380b883a 	mov	r5,r7
 8203c20:	8809883a 	mov	r4,r17
 8203c24:	dd810b15 	stw	r22,1068(sp)
 8203c28:	dc010515 	stw	r16,1044(sp)
 8203c2c:	d8c10415 	stw	r3,1040(sp)
 8203c30:	dfc10e15 	stw	ra,1080(sp)
 8203c34:	df010d15 	stw	fp,1076(sp)
 8203c38:	dd410a15 	stw	r21,1064(sp)
 8203c3c:	dd010915 	stw	r20,1060(sp)
 8203c40:	dcc10815 	stw	r19,1056(sp)
 8203c44:	382d883a 	mov	r22,r7
 8203c48:	8203af40 	call	8203af4 <critical_factorization>
 8203c4c:	d8c10417 	ldw	r3,1040(sp)
 8203c50:	1021883a 	mov	r16,r2
 8203c54:	d805883a 	mov	r2,sp
 8203c58:	15800015 	stw	r22,0(r2)
 8203c5c:	10800104 	addi	r2,r2,4
 8203c60:	90bffd1e 	bne	r18,r2,8203c58 <two_way_long_needle+0x60>
 8203c64:	b0000b26 	beq	r22,zero,8203c94 <two_way_long_needle+0x9c>
 8203c68:	b17fffc4 	addi	r5,r22,-1
 8203c6c:	8809883a 	mov	r4,r17
 8203c70:	8d8d883a 	add	r6,r17,r22
 8203c74:	20800003 	ldbu	r2,0(r4)
 8203c78:	21000044 	addi	r4,r4,1
 8203c7c:	1085883a 	add	r2,r2,r2
 8203c80:	1085883a 	add	r2,r2,r2
 8203c84:	d885883a 	add	r2,sp,r2
 8203c88:	11400015 	stw	r5,0(r2)
 8203c8c:	297fffc4 	addi	r5,r5,-1
 8203c90:	21bff81e 	bne	r4,r6,8203c74 <two_way_long_needle+0x7c>
 8203c94:	d9410017 	ldw	r5,1024(sp)
 8203c98:	800d883a 	mov	r6,r16
 8203c9c:	8809883a 	mov	r4,r17
 8203ca0:	894b883a 	add	r5,r17,r5
 8203ca4:	d8c10415 	stw	r3,1040(sp)
 8203ca8:	820c0d80 	call	820c0d8 <memcmp>
 8203cac:	d8c10417 	ldw	r3,1040(sp)
 8203cb0:	10006a1e 	bne	r2,zero,8203e5c <two_way_long_needle+0x264>
 8203cb4:	84bfffc4 	addi	r18,r16,-1
 8203cb8:	8c85883a 	add	r2,r17,r18
 8203cbc:	d8810215 	stw	r2,1032(sp)
 8203cc0:	00800044 	movi	r2,1
 8203cc4:	813fff84 	addi	r4,r16,-2
 8203cc8:	1405c83a 	sub	r2,r2,r16
 8203ccc:	0029883a 	mov	r20,zero
 8203cd0:	0039883a 	mov	fp,zero
 8203cd4:	b57fffc4 	addi	r21,r22,-1
 8203cd8:	d9010115 	stw	r4,1028(sp)
 8203cdc:	d8810315 	stw	r2,1036(sp)
 8203ce0:	00000706 	br	8203d00 <two_way_long_needle+0x108>
 8203ce4:	a0000326 	beq	r20,zero,8203cf4 <two_way_long_needle+0xfc>
 8203ce8:	d8c10017 	ldw	r3,1024(sp)
 8203cec:	10c0012e 	bgeu	r2,r3,8203cf4 <two_way_long_needle+0xfc>
 8203cf0:	b0c5c83a 	sub	r2,r22,r3
 8203cf4:	e0b9883a 	add	fp,fp,r2
 8203cf8:	0029883a 	mov	r20,zero
 8203cfc:	9807883a 	mov	r3,r19
 8203d00:	e5a7883a 	add	r19,fp,r22
 8203d04:	98cdc83a 	sub	r6,r19,r3
 8203d08:	000b883a 	mov	r5,zero
 8203d0c:	b8c9883a 	add	r4,r23,r3
 8203d10:	820bff40 	call	820bff4 <memchr>
 8203d14:	1000441e 	bne	r2,zero,8203e28 <two_way_long_needle+0x230>
 8203d18:	98004326 	beq	r19,zero,8203e28 <two_way_long_needle+0x230>
 8203d1c:	bcc5883a 	add	r2,r23,r19
 8203d20:	10bfffc3 	ldbu	r2,-1(r2)
 8203d24:	1085883a 	add	r2,r2,r2
 8203d28:	1085883a 	add	r2,r2,r2
 8203d2c:	d885883a 	add	r2,sp,r2
 8203d30:	10800017 	ldw	r2,0(r2)
 8203d34:	103feb1e 	bne	r2,zero,8203ce4 <two_way_long_needle+0xec>
 8203d38:	a015883a 	mov	r10,r20
 8203d3c:	a400012e 	bgeu	r20,r16,8203d44 <two_way_long_needle+0x14c>
 8203d40:	8015883a 	mov	r10,r16
 8203d44:	5540152e 	bgeu	r10,r21,8203d9c <two_way_long_needle+0x1a4>
 8203d48:	bf05883a 	add	r2,r23,fp
 8203d4c:	8a87883a 	add	r3,r17,r10
 8203d50:	1285883a 	add	r2,r2,r10
 8203d54:	18c00003 	ldbu	r3,0(r3)
 8203d58:	10800003 	ldbu	r2,0(r2)
 8203d5c:	18802d1e 	bne	r3,r2,8203e14 <two_way_long_needle+0x21c>
 8203d60:	e1400044 	addi	r5,fp,1
 8203d64:	50800044 	addi	r2,r10,1
 8203d68:	2a8b883a 	add	r5,r5,r10
 8203d6c:	888d883a 	add	r6,r17,r2
 8203d70:	b94b883a 	add	r5,r23,r5
 8203d74:	00000706 	br	8203d94 <two_way_long_needle+0x19c>
 8203d78:	31000003 	ldbu	r4,0(r6)
 8203d7c:	28c00003 	ldbu	r3,0(r5)
 8203d80:	31800044 	addi	r6,r6,1
 8203d84:	21003fcc 	andi	r4,r4,255
 8203d88:	29400044 	addi	r5,r5,1
 8203d8c:	20c0211e 	bne	r4,r3,8203e14 <two_way_long_needle+0x21c>
 8203d90:	10800044 	addi	r2,r2,1
 8203d94:	1015883a 	mov	r10,r2
 8203d98:	157ff736 	bltu	r2,r21,8203d78 <two_way_long_needle+0x180>
 8203d9c:	900d883a 	mov	r6,r18
 8203da0:	a4007d2e 	bgeu	r20,r16,8203f98 <two_way_long_needle+0x3a0>
 8203da4:	d9410217 	ldw	r5,1032(sp)
 8203da8:	bf05883a 	add	r2,r23,fp
 8203dac:	1485883a 	add	r2,r2,r18
 8203db0:	28c00003 	ldbu	r3,0(r5)
 8203db4:	10800003 	ldbu	r2,0(r2)
 8203db8:	1880771e 	bne	r3,r2,8203f98 <two_way_long_needle+0x3a0>
 8203dbc:	d8c10117 	ldw	r3,1028(sp)
 8203dc0:	a2ffffc4 	addi	r11,r20,-1
 8203dc4:	8ad7883a 	add	r11,r17,r11
 8203dc8:	e0cb883a 	add	r5,fp,r3
 8203dcc:	88c5883a 	add	r2,r17,r3
 8203dd0:	b94b883a 	add	r5,r23,r5
 8203dd4:	00000706 	br	8203df4 <two_way_long_needle+0x1fc>
 8203dd8:	11000003 	ldbu	r4,0(r2)
 8203ddc:	28c00003 	ldbu	r3,0(r5)
 8203de0:	10bfffc4 	addi	r2,r2,-1
 8203de4:	21003fcc 	andi	r4,r4,255
 8203de8:	297fffc4 	addi	r5,r5,-1
 8203dec:	20c0031e 	bne	r4,r3,8203dfc <two_way_long_needle+0x204>
 8203df0:	500d883a 	mov	r6,r10
 8203df4:	32bfffc4 	addi	r10,r6,-1
 8203df8:	58bff71e 	bne	r11,r2,8203dd8 <two_way_long_needle+0x1e0>
 8203dfc:	a2400044 	addi	r9,r20,1
 8203e00:	32406736 	bltu	r6,r9,8203fa0 <two_way_long_needle+0x3a8>
 8203e04:	da410017 	ldw	r9,1024(sp)
 8203e08:	e279883a 	add	fp,fp,r9
 8203e0c:	b269c83a 	sub	r20,r22,r9
 8203e10:	003fba06 	br	8203cfc <two_way_long_needle+0x104>
 8203e14:	d8c10317 	ldw	r3,1036(sp)
 8203e18:	0029883a 	mov	r20,zero
 8203e1c:	1f39883a 	add	fp,r3,fp
 8203e20:	e2b9883a 	add	fp,fp,r10
 8203e24:	003fb506 	br	8203cfc <two_way_long_needle+0x104>
 8203e28:	0005883a 	mov	r2,zero
 8203e2c:	dfc10e17 	ldw	ra,1080(sp)
 8203e30:	df010d17 	ldw	fp,1076(sp)
 8203e34:	ddc10c17 	ldw	r23,1072(sp)
 8203e38:	dd810b17 	ldw	r22,1068(sp)
 8203e3c:	dd410a17 	ldw	r21,1064(sp)
 8203e40:	dd010917 	ldw	r20,1060(sp)
 8203e44:	dcc10817 	ldw	r19,1056(sp)
 8203e48:	dc810717 	ldw	r18,1052(sp)
 8203e4c:	dc410617 	ldw	r17,1048(sp)
 8203e50:	dc010517 	ldw	r16,1044(sp)
 8203e54:	dec10f04 	addi	sp,sp,1084
 8203e58:	f800283a 	ret
 8203e5c:	b405c83a 	sub	r2,r22,r16
 8203e60:	14004b36 	bltu	r2,r16,8203f90 <two_way_long_needle+0x398>
 8203e64:	10800044 	addi	r2,r2,1
 8203e68:	84bfffc4 	addi	r18,r16,-1
 8203e6c:	d8810015 	stw	r2,1024(sp)
 8203e70:	00800044 	movi	r2,1
 8203e74:	8c89883a 	add	r4,r17,r18
 8203e78:	817fff84 	addi	r5,r16,-2
 8203e7c:	1405c83a 	sub	r2,r2,r16
 8203e80:	0029883a 	mov	r20,zero
 8203e84:	b73fffc4 	addi	fp,r22,-1
 8203e88:	d9010215 	stw	r4,1032(sp)
 8203e8c:	d9410115 	stw	r5,1028(sp)
 8203e90:	8d7fffc4 	addi	r21,r17,-1
 8203e94:	d8810315 	stw	r2,1036(sp)
 8203e98:	a5a7883a 	add	r19,r20,r22
 8203e9c:	98cdc83a 	sub	r6,r19,r3
 8203ea0:	000b883a 	mov	r5,zero
 8203ea4:	b8c9883a 	add	r4,r23,r3
 8203ea8:	820bff40 	call	820bff4 <memchr>
 8203eac:	103fde1e 	bne	r2,zero,8203e28 <two_way_long_needle+0x230>
 8203eb0:	983fdd26 	beq	r19,zero,8203e28 <two_way_long_needle+0x230>
 8203eb4:	bcc5883a 	add	r2,r23,r19
 8203eb8:	10bfffc3 	ldbu	r2,-1(r2)
 8203ebc:	1085883a 	add	r2,r2,r2
 8203ec0:	1085883a 	add	r2,r2,r2
 8203ec4:	d885883a 	add	r2,sp,r2
 8203ec8:	10800017 	ldw	r2,0(r2)
 8203ecc:	1000291e 	bne	r2,zero,8203f74 <two_way_long_needle+0x37c>
 8203ed0:	bd05883a 	add	r2,r23,r20
 8203ed4:	8700142e 	bgeu	r16,fp,8203f28 <two_way_long_needle+0x330>
 8203ed8:	8c07883a 	add	r3,r17,r16
 8203edc:	140b883a 	add	r5,r2,r16
 8203ee0:	19000003 	ldbu	r4,0(r3)
 8203ee4:	28c00003 	ldbu	r3,0(r5)
 8203ee8:	800d883a 	mov	r6,r16
 8203eec:	20c0241e 	bne	r4,r3,8203f80 <two_way_long_needle+0x388>
 8203ef0:	81400044 	addi	r5,r16,1
 8203ef4:	a155883a 	add	r10,r20,r5
 8203ef8:	ba95883a 	add	r10,r23,r10
 8203efc:	894b883a 	add	r5,r17,r5
 8203f00:	800d883a 	mov	r6,r16
 8203f04:	00000606 	br	8203f20 <two_way_long_needle+0x328>
 8203f08:	29000003 	ldbu	r4,0(r5)
 8203f0c:	50c00003 	ldbu	r3,0(r10)
 8203f10:	29400044 	addi	r5,r5,1
 8203f14:	21003fcc 	andi	r4,r4,255
 8203f18:	52800044 	addi	r10,r10,1
 8203f1c:	20c0181e 	bne	r4,r3,8203f80 <two_way_long_needle+0x388>
 8203f20:	31800044 	addi	r6,r6,1
 8203f24:	373ff836 	bltu	r6,fp,8203f08 <two_way_long_needle+0x310>
 8203f28:	00ffffc4 	movi	r3,-1
 8203f2c:	90ffbf26 	beq	r18,r3,8203e2c <two_way_long_needle+0x234>
 8203f30:	d9410217 	ldw	r5,1032(sp)
 8203f34:	1487883a 	add	r3,r2,r18
 8203f38:	18c00003 	ldbu	r3,0(r3)
 8203f3c:	29000003 	ldbu	r4,0(r5)
 8203f40:	20c00b1e 	bne	r4,r3,8203f70 <two_way_long_needle+0x378>
 8203f44:	d8c10117 	ldw	r3,1028(sp)
 8203f48:	a0cd883a 	add	r6,r20,r3
 8203f4c:	b98d883a 	add	r6,r23,r6
 8203f50:	88c7883a 	add	r3,r17,r3
 8203f54:	1d7fb526 	beq	r3,r21,8203e2c <two_way_long_needle+0x234>
 8203f58:	19400003 	ldbu	r5,0(r3)
 8203f5c:	31000003 	ldbu	r4,0(r6)
 8203f60:	18ffffc4 	addi	r3,r3,-1
 8203f64:	29403fcc 	andi	r5,r5,255
 8203f68:	31bfffc4 	addi	r6,r6,-1
 8203f6c:	293ff926 	beq	r5,r4,8203f54 <two_way_long_needle+0x35c>
 8203f70:	d8810017 	ldw	r2,1024(sp)
 8203f74:	a0a9883a 	add	r20,r20,r2
 8203f78:	9807883a 	mov	r3,r19
 8203f7c:	003fc606 	br	8203e98 <two_way_long_needle+0x2a0>
 8203f80:	d8c10317 	ldw	r3,1036(sp)
 8203f84:	1d11883a 	add	r8,r3,r20
 8203f88:	41a9883a 	add	r20,r8,r6
 8203f8c:	003ffa06 	br	8203f78 <two_way_long_needle+0x380>
 8203f90:	8005883a 	mov	r2,r16
 8203f94:	003fb306 	br	8203e64 <two_way_long_needle+0x26c>
 8203f98:	800d883a 	mov	r6,r16
 8203f9c:	003f9706 	br	8203dfc <two_way_long_needle+0x204>
 8203fa0:	bf05883a 	add	r2,r23,fp
 8203fa4:	003fa106 	br	8203e2c <two_way_long_needle+0x234>

08203fa8 <strstr>:
 8203fa8:	21800007 	ldb	r6,0(r4)
 8203fac:	30009226 	beq	r6,zero,82041f8 <strstr+0x250>
 8203fb0:	28c00007 	ldb	r3,0(r5)
 8203fb4:	18000f26 	beq	r3,zero,8203ff4 <strstr+0x4c>
 8203fb8:	280f883a 	mov	r7,r5
 8203fbc:	2011883a 	mov	r8,r4
 8203fc0:	02400044 	movi	r9,1
 8203fc4:	00000206 	br	8203fd0 <strstr+0x28>
 8203fc8:	38c00007 	ldb	r3,0(r7)
 8203fcc:	18000826 	beq	r3,zero,8203ff0 <strstr+0x48>
 8203fd0:	42000044 	addi	r8,r8,1
 8203fd4:	1987003a 	cmpeq	r3,r3,r6
 8203fd8:	41800007 	ldb	r6,0(r8)
 8203fdc:	39c00044 	addi	r7,r7,1
 8203fe0:	48d2703a 	and	r9,r9,r3
 8203fe4:	303ff81e 	bne	r6,zero,8203fc8 <strstr+0x20>
 8203fe8:	38800007 	ldb	r2,0(r7)
 8203fec:	1000841e 	bne	r2,zero,8204200 <strstr+0x258>
 8203ff0:	48000226 	beq	r9,zero,8203ffc <strstr+0x54>
 8203ff4:	2005883a 	mov	r2,r4
 8203ff8:	f800283a 	ret
 8203ffc:	defff104 	addi	sp,sp,-60
 8204000:	ddc00c15 	stw	r23,48(sp)
 8204004:	dd800b15 	stw	r22,44(sp)
 8204008:	dd400a15 	stw	r21,40(sp)
 820400c:	dc000515 	stw	r16,20(sp)
 8204010:	dfc00e15 	stw	ra,56(sp)
 8204014:	df000d15 	stw	fp,52(sp)
 8204018:	dd000915 	stw	r20,36(sp)
 820401c:	dcc00815 	stw	r19,32(sp)
 8204020:	dc800715 	stw	r18,28(sp)
 8204024:	dc400615 	stw	r17,24(sp)
 8204028:	282d883a 	mov	r22,r5
 820402c:	29400007 	ldb	r5,0(r5)
 8204030:	202b883a 	mov	r21,r4
 8204034:	21000044 	addi	r4,r4,1
 8204038:	3da1c83a 	sub	r16,r7,r22
 820403c:	82032800 	call	8203280 <strchr>
 8204040:	102f883a 	mov	r23,r2
 8204044:	10007526 	beq	r2,zero,820421c <strstr+0x274>
 8204048:	00c00044 	movi	r3,1
 820404c:	80c00a26 	beq	r16,r3,8204078 <strstr+0xd0>
 8204050:	ac09883a 	add	r4,r21,r16
 8204054:	20800136 	bltu	r4,r2,820405c <strstr+0xb4>
 8204058:	2087c83a 	sub	r3,r4,r2
 820405c:	008007c4 	movi	r2,31
 8204060:	1400112e 	bgeu	r2,r16,82040a8 <strstr+0x100>
 8204064:	800f883a 	mov	r7,r16
 8204068:	b00d883a 	mov	r6,r22
 820406c:	180b883a 	mov	r5,r3
 8204070:	b809883a 	mov	r4,r23
 8204074:	8203bf80 	call	8203bf8 <two_way_long_needle>
 8204078:	dfc00e17 	ldw	ra,56(sp)
 820407c:	df000d17 	ldw	fp,52(sp)
 8204080:	ddc00c17 	ldw	r23,48(sp)
 8204084:	dd800b17 	ldw	r22,44(sp)
 8204088:	dd400a17 	ldw	r21,40(sp)
 820408c:	dd000917 	ldw	r20,36(sp)
 8204090:	dcc00817 	ldw	r19,32(sp)
 8204094:	dc800717 	ldw	r18,28(sp)
 8204098:	dc400617 	ldw	r17,24(sp)
 820409c:	dc000517 	ldw	r16,20(sp)
 82040a0:	dec00f04 	addi	sp,sp,60
 82040a4:	f800283a 	ret
 82040a8:	d80d883a 	mov	r6,sp
 82040ac:	800b883a 	mov	r5,r16
 82040b0:	b009883a 	mov	r4,r22
 82040b4:	d8c00415 	stw	r3,16(sp)
 82040b8:	8203af40 	call	8203af4 <critical_factorization>
 82040bc:	d9400017 	ldw	r5,0(sp)
 82040c0:	100d883a 	mov	r6,r2
 82040c4:	b009883a 	mov	r4,r22
 82040c8:	b14b883a 	add	r5,r22,r5
 82040cc:	1039883a 	mov	fp,r2
 82040d0:	820c0d80 	call	820c0d8 <memcmp>
 82040d4:	d8c00417 	ldw	r3,16(sp)
 82040d8:	1000521e 	bne	r2,zero,8204224 <strstr+0x27c>
 82040dc:	e47fffc4 	addi	r17,fp,-1
 82040e0:	04c00044 	movi	r19,1
 82040e4:	b445883a 	add	r2,r22,r17
 82040e8:	9f27c83a 	sub	r19,r19,fp
 82040ec:	0029883a 	mov	r20,zero
 82040f0:	002b883a 	mov	r21,zero
 82040f4:	d8800215 	stw	r2,8(sp)
 82040f8:	e4bfff84 	addi	r18,fp,-2
 82040fc:	dcc00115 	stw	r19,4(sp)
 8204100:	8567883a 	add	r19,r16,r21
 8204104:	98cdc83a 	sub	r6,r19,r3
 8204108:	000b883a 	mov	r5,zero
 820410c:	b8c9883a 	add	r4,r23,r3
 8204110:	820bff40 	call	820bff4 <memchr>
 8204114:	1000411e 	bne	r2,zero,820421c <strstr+0x274>
 8204118:	98004026 	beq	r19,zero,820421c <strstr+0x274>
 820411c:	e00b883a 	mov	r5,fp
 8204120:	e500012e 	bgeu	fp,r20,8204128 <strstr+0x180>
 8204124:	a00b883a 	mov	r5,r20
 8204128:	2c00152e 	bgeu	r5,r16,8204180 <strstr+0x1d8>
 820412c:	b947883a 	add	r3,r23,r5
 8204130:	1d47883a 	add	r3,r3,r21
 8204134:	b145883a 	add	r2,r22,r5
 8204138:	18c00003 	ldbu	r3,0(r3)
 820413c:	10800003 	ldbu	r2,0(r2)
 8204140:	1880311e 	bne	r3,r2,8204208 <strstr+0x260>
 8204144:	a8800044 	addi	r2,r21,1
 8204148:	28c00044 	addi	r3,r5,1
 820414c:	1145883a 	add	r2,r2,r5
 8204150:	b0c9883a 	add	r4,r22,r3
 8204154:	b885883a 	add	r2,r23,r2
 8204158:	00000706 	br	8204178 <strstr+0x1d0>
 820415c:	21c00003 	ldbu	r7,0(r4)
 8204160:	11800003 	ldbu	r6,0(r2)
 8204164:	21000044 	addi	r4,r4,1
 8204168:	39c03fcc 	andi	r7,r7,255
 820416c:	10800044 	addi	r2,r2,1
 8204170:	3980251e 	bne	r7,r6,8204208 <strstr+0x260>
 8204174:	18c00044 	addi	r3,r3,1
 8204178:	180b883a 	mov	r5,r3
 820417c:	1c3ff736 	bltu	r3,r16,820415c <strstr+0x1b4>
 8204180:	880d883a 	mov	r6,r17
 8204184:	a700702e 	bgeu	r20,fp,8204348 <strstr+0x3a0>
 8204188:	d9000217 	ldw	r4,8(sp)
 820418c:	bd45883a 	add	r2,r23,r21
 8204190:	1445883a 	add	r2,r2,r17
 8204194:	20c00003 	ldbu	r3,0(r4)
 8204198:	10800003 	ldbu	r2,0(r2)
 820419c:	18806a1e 	bne	r3,r2,8204348 <strstr+0x3a0>
 82041a0:	954b883a 	add	r5,r18,r21
 82041a4:	a2bfffc4 	addi	r10,r20,-1
 82041a8:	b485883a 	add	r2,r22,r18
 82041ac:	b94b883a 	add	r5,r23,r5
 82041b0:	b295883a 	add	r10,r22,r10
 82041b4:	00000706 	br	82041d4 <strstr+0x22c>
 82041b8:	11000003 	ldbu	r4,0(r2)
 82041bc:	28c00003 	ldbu	r3,0(r5)
 82041c0:	10bfffc4 	addi	r2,r2,-1
 82041c4:	21003fcc 	andi	r4,r4,255
 82041c8:	297fffc4 	addi	r5,r5,-1
 82041cc:	20c0031e 	bne	r4,r3,82041dc <strstr+0x234>
 82041d0:	380d883a 	mov	r6,r7
 82041d4:	31ffffc4 	addi	r7,r6,-1
 82041d8:	12bff71e 	bne	r2,r10,82041b8 <strstr+0x210>
 82041dc:	a2000044 	addi	r8,r20,1
 82041e0:	32005b36 	bltu	r6,r8,8204350 <strstr+0x3a8>
 82041e4:	da000017 	ldw	r8,0(sp)
 82041e8:	aa2b883a 	add	r21,r21,r8
 82041ec:	8229c83a 	sub	r20,r16,r8
 82041f0:	9807883a 	mov	r3,r19
 82041f4:	003fc206 	br	8204100 <strstr+0x158>
 82041f8:	28800007 	ldb	r2,0(r5)
 82041fc:	103f7d26 	beq	r2,zero,8203ff4 <strstr+0x4c>
 8204200:	0005883a 	mov	r2,zero
 8204204:	f800283a 	ret
 8204208:	d8c00117 	ldw	r3,4(sp)
 820420c:	0029883a 	mov	r20,zero
 8204210:	1d6b883a 	add	r21,r3,r21
 8204214:	a96b883a 	add	r21,r21,r5
 8204218:	003ff506 	br	82041f0 <strstr+0x248>
 820421c:	0005883a 	mov	r2,zero
 8204220:	003f9506 	br	8204078 <strstr+0xd0>
 8204224:	8705c83a 	sub	r2,r16,fp
 8204228:	1700012e 	bgeu	r2,fp,8204230 <strstr+0x288>
 820422c:	e005883a 	mov	r2,fp
 8204230:	10800044 	addi	r2,r2,1
 8204234:	e4bfffc4 	addi	r18,fp,-1
 8204238:	05000044 	movi	r20,1
 820423c:	a729c83a 	sub	r20,r20,fp
 8204240:	d8800015 	stw	r2,0(sp)
 8204244:	b48b883a 	add	r5,r22,r18
 8204248:	e0bfff84 	addi	r2,fp,-2
 820424c:	dd000215 	stw	r20,8(sp)
 8204250:	002b883a 	mov	r21,zero
 8204254:	e4400044 	addi	r17,fp,1
 8204258:	d9400315 	stw	r5,12(sp)
 820425c:	d8800115 	stw	r2,4(sp)
 8204260:	b53fffc4 	addi	r20,r22,-1
 8204264:	8567883a 	add	r19,r16,r21
 8204268:	98cdc83a 	sub	r6,r19,r3
 820426c:	000b883a 	mov	r5,zero
 8204270:	b8c9883a 	add	r4,r23,r3
 8204274:	820bff40 	call	820bff4 <memchr>
 8204278:	103fe81e 	bne	r2,zero,820421c <strstr+0x274>
 820427c:	983fe726 	beq	r19,zero,820421c <strstr+0x274>
 8204280:	e400132e 	bgeu	fp,r16,82042d0 <strstr+0x328>
 8204284:	bf07883a 	add	r3,r23,fp
 8204288:	1d47883a 	add	r3,r3,r21
 820428c:	b705883a 	add	r2,r22,fp
 8204290:	18c00003 	ldbu	r3,0(r3)
 8204294:	10800003 	ldbu	r2,0(r2)
 8204298:	1880241e 	bne	r3,r2,820432c <strstr+0x384>
 820429c:	ac45883a 	add	r2,r21,r17
 82042a0:	b44b883a 	add	r5,r22,r17
 82042a4:	b885883a 	add	r2,r23,r2
 82042a8:	e009883a 	mov	r4,fp
 82042ac:	00000606 	br	82042c8 <strstr+0x320>
 82042b0:	29800003 	ldbu	r6,0(r5)
 82042b4:	10c00003 	ldbu	r3,0(r2)
 82042b8:	29400044 	addi	r5,r5,1
 82042bc:	31803fcc 	andi	r6,r6,255
 82042c0:	10800044 	addi	r2,r2,1
 82042c4:	30c01a1e 	bne	r6,r3,8204330 <strstr+0x388>
 82042c8:	21000044 	addi	r4,r4,1
 82042cc:	243ff836 	bltu	r4,r16,82042b0 <strstr+0x308>
 82042d0:	00bfffc4 	movi	r2,-1
 82042d4:	bd49883a 	add	r4,r23,r21
 82042d8:	90801926 	beq	r18,r2,8204340 <strstr+0x398>
 82042dc:	d9400317 	ldw	r5,12(sp)
 82042e0:	2485883a 	add	r2,r4,r18
 82042e4:	10800003 	ldbu	r2,0(r2)
 82042e8:	28c00003 	ldbu	r3,0(r5)
 82042ec:	18800b1e 	bne	r3,r2,820431c <strstr+0x374>
 82042f0:	d8c00117 	ldw	r3,4(sp)
 82042f4:	a8c5883a 	add	r2,r21,r3
 82042f8:	b885883a 	add	r2,r23,r2
 82042fc:	b0c7883a 	add	r3,r22,r3
 8204300:	1d000f26 	beq	r3,r20,8204340 <strstr+0x398>
 8204304:	19800003 	ldbu	r6,0(r3)
 8204308:	11400003 	ldbu	r5,0(r2)
 820430c:	18ffffc4 	addi	r3,r3,-1
 8204310:	31803fcc 	andi	r6,r6,255
 8204314:	10bfffc4 	addi	r2,r2,-1
 8204318:	317ff926 	beq	r6,r5,8204300 <strstr+0x358>
 820431c:	d8800017 	ldw	r2,0(sp)
 8204320:	a8ab883a 	add	r21,r21,r2
 8204324:	9807883a 	mov	r3,r19
 8204328:	003fce06 	br	8204264 <strstr+0x2bc>
 820432c:	e009883a 	mov	r4,fp
 8204330:	d8c00217 	ldw	r3,8(sp)
 8204334:	1d4f883a 	add	r7,r3,r21
 8204338:	392b883a 	add	r21,r7,r4
 820433c:	003ff906 	br	8204324 <strstr+0x37c>
 8204340:	2005883a 	mov	r2,r4
 8204344:	003f4c06 	br	8204078 <strstr+0xd0>
 8204348:	e00d883a 	mov	r6,fp
 820434c:	003fa306 	br	82041dc <strstr+0x234>
 8204350:	bd45883a 	add	r2,r23,r21
 8204354:	003f4806 	br	8204078 <strstr+0xd0>

08204358 <___svfprintf_internal_r>:
 8204358:	deffb704 	addi	sp,sp,-292
 820435c:	dfc04815 	stw	ra,288(sp)
 8204360:	ddc04615 	stw	r23,280(sp)
 8204364:	d9402c15 	stw	r5,176(sp)
 8204368:	d9003915 	stw	r4,228(sp)
 820436c:	302f883a 	mov	r23,r6
 8204370:	d9c02d15 	stw	r7,180(sp)
 8204374:	df004715 	stw	fp,284(sp)
 8204378:	dd804515 	stw	r22,276(sp)
 820437c:	dd404415 	stw	r21,272(sp)
 8204380:	dd004315 	stw	r20,268(sp)
 8204384:	dcc04215 	stw	r19,264(sp)
 8204388:	dc804115 	stw	r18,260(sp)
 820438c:	dc404015 	stw	r17,256(sp)
 8204390:	dc003f15 	stw	r16,252(sp)
 8204394:	820b5fc0 	call	820b5fc <_localeconv_r>
 8204398:	10800017 	ldw	r2,0(r2)
 820439c:	1009883a 	mov	r4,r2
 82043a0:	d8803415 	stw	r2,208(sp)
 82043a4:	8203a5c0 	call	8203a5c <strlen>
 82043a8:	d8c02c17 	ldw	r3,176(sp)
 82043ac:	d8803815 	stw	r2,224(sp)
 82043b0:	1880030b 	ldhu	r2,12(r3)
 82043b4:	1080200c 	andi	r2,r2,128
 82043b8:	10000226 	beq	r2,zero,82043c4 <___svfprintf_internal_r+0x6c>
 82043bc:	18800417 	ldw	r2,16(r3)
 82043c0:	10067f26 	beq	r2,zero,8205dc0 <___svfprintf_internal_r+0x1a68>
 82043c4:	dcc03917 	ldw	r19,228(sp)
 82043c8:	d8c00404 	addi	r3,sp,16
 82043cc:	05420974 	movhi	r21,2085
 82043d0:	d9001e04 	addi	r4,sp,120
 82043d4:	ad756184 	addi	r21,r21,-10874
 82043d8:	d8c01e15 	stw	r3,120(sp)
 82043dc:	d8002015 	stw	zero,128(sp)
 82043e0:	d8001f15 	stw	zero,124(sp)
 82043e4:	d8003315 	stw	zero,204(sp)
 82043e8:	d8003615 	stw	zero,216(sp)
 82043ec:	d8003715 	stw	zero,220(sp)
 82043f0:	1811883a 	mov	r8,r3
 82043f4:	d8003a15 	stw	zero,232(sp)
 82043f8:	d8003b15 	stw	zero,236(sp)
 82043fc:	d8002f15 	stw	zero,188(sp)
 8204400:	d9002815 	stw	r4,160(sp)
 8204404:	b8800007 	ldb	r2,0(r23)
 8204408:	10026726 	beq	r2,zero,8204da8 <___svfprintf_internal_r+0xa50>
 820440c:	00c00944 	movi	r3,37
 8204410:	b821883a 	mov	r16,r23
 8204414:	10c0021e 	bne	r2,r3,8204420 <___svfprintf_internal_r+0xc8>
 8204418:	00001406 	br	820446c <___svfprintf_internal_r+0x114>
 820441c:	10c00326 	beq	r2,r3,820442c <___svfprintf_internal_r+0xd4>
 8204420:	84000044 	addi	r16,r16,1
 8204424:	80800007 	ldb	r2,0(r16)
 8204428:	103ffc1e 	bne	r2,zero,820441c <___svfprintf_internal_r+0xc4>
 820442c:	85e3c83a 	sub	r17,r16,r23
 8204430:	88000e26 	beq	r17,zero,820446c <___svfprintf_internal_r+0x114>
 8204434:	d8c02017 	ldw	r3,128(sp)
 8204438:	d8801f17 	ldw	r2,124(sp)
 820443c:	45c00015 	stw	r23,0(r8)
 8204440:	1c47883a 	add	r3,r3,r17
 8204444:	10800044 	addi	r2,r2,1
 8204448:	d8c02015 	stw	r3,128(sp)
 820444c:	44400115 	stw	r17,4(r8)
 8204450:	d8801f15 	stw	r2,124(sp)
 8204454:	00c001c4 	movi	r3,7
 8204458:	18809716 	blt	r3,r2,82046b8 <___svfprintf_internal_r+0x360>
 820445c:	42000204 	addi	r8,r8,8
 8204460:	d9402f17 	ldw	r5,188(sp)
 8204464:	2c4b883a 	add	r5,r5,r17
 8204468:	d9402f15 	stw	r5,188(sp)
 820446c:	80800007 	ldb	r2,0(r16)
 8204470:	10009826 	beq	r2,zero,82046d4 <___svfprintf_internal_r+0x37c>
 8204474:	84400047 	ldb	r17,1(r16)
 8204478:	00bfffc4 	movi	r2,-1
 820447c:	85c00044 	addi	r23,r16,1
 8204480:	d8002785 	stb	zero,158(sp)
 8204484:	0007883a 	mov	r3,zero
 8204488:	000f883a 	mov	r7,zero
 820448c:	d8802915 	stw	r2,164(sp)
 8204490:	d8003115 	stw	zero,196(sp)
 8204494:	0025883a 	mov	r18,zero
 8204498:	01401604 	movi	r5,88
 820449c:	01800244 	movi	r6,9
 82044a0:	02800a84 	movi	r10,42
 82044a4:	02401b04 	movi	r9,108
 82044a8:	bdc00044 	addi	r23,r23,1
 82044ac:	88bff804 	addi	r2,r17,-32
 82044b0:	2882f036 	bltu	r5,r2,8205074 <___svfprintf_internal_r+0xd1c>
 82044b4:	100490ba 	slli	r2,r2,2
 82044b8:	01020834 	movhi	r4,2080
 82044bc:	21113304 	addi	r4,r4,17612
 82044c0:	1105883a 	add	r2,r2,r4
 82044c4:	10800017 	ldw	r2,0(r2)
 82044c8:	1000683a 	jmp	r2
 82044cc:	08204fdc 	xori	zero,at,33087
 82044d0:	08205074 	orhi	zero,at,33089
 82044d4:	08205074 	orhi	zero,at,33089
 82044d8:	08204fd0 	cmplti	zero,at,-32449
 82044dc:	08205074 	orhi	zero,at,33089
 82044e0:	08205074 	orhi	zero,at,33089
 82044e4:	08205074 	orhi	zero,at,33089
 82044e8:	08205074 	orhi	zero,at,33089
 82044ec:	08205074 	orhi	zero,at,33089
 82044f0:	08205074 	orhi	zero,at,33089
 82044f4:	08204730 	cmpltui	zero,at,33052
 82044f8:	08204f0c 	andi	zero,at,33084
 82044fc:	08205074 	orhi	zero,at,33089
 8204500:	08204640 	call	820464 <OSCtxSw_SWITCH_PC+0x820424>
 8204504:	08204758 	cmpnei	zero,at,-32483
 8204508:	08205074 	orhi	zero,at,33089
 820450c:	082047cc 	andi	zero,at,33055
 8204510:	08204798 	cmpnei	zero,at,-32482
 8204514:	08204798 	cmpnei	zero,at,-32482
 8204518:	08204798 	cmpnei	zero,at,-32482
 820451c:	08204798 	cmpnei	zero,at,-32482
 8204520:	08204798 	cmpnei	zero,at,-32482
 8204524:	08204798 	cmpnei	zero,at,-32482
 8204528:	08204798 	cmpnei	zero,at,-32482
 820452c:	08204798 	cmpnei	zero,at,-32482
 8204530:	08204798 	cmpnei	zero,at,-32482
 8204534:	08205074 	orhi	zero,at,33089
 8204538:	08205074 	orhi	zero,at,33089
 820453c:	08205074 	orhi	zero,at,33089
 8204540:	08205074 	orhi	zero,at,33089
 8204544:	08205074 	orhi	zero,at,33089
 8204548:	08205074 	orhi	zero,at,33089
 820454c:	08205074 	orhi	zero,at,33089
 8204550:	08205074 	orhi	zero,at,33089
 8204554:	08205074 	orhi	zero,at,33089
 8204558:	08205074 	orhi	zero,at,33089
 820455c:	08204884 	addi	zero,at,-32478
 8204560:	082047d8 	cmpnei	zero,at,-32481
 8204564:	08205074 	orhi	zero,at,33089
 8204568:	082047d8 	cmpnei	zero,at,-32481
 820456c:	08205074 	orhi	zero,at,33089
 8204570:	08205074 	orhi	zero,at,33089
 8204574:	08205074 	orhi	zero,at,33089
 8204578:	08205074 	orhi	zero,at,33089
 820457c:	08204878 	rdprs	zero,at,-32479
 8204580:	08205074 	orhi	zero,at,33089
 8204584:	08205074 	orhi	zero,at,33089
 8204588:	08204940 	call	820494 <OSCtxSw_SWITCH_PC+0x820454>
 820458c:	08205074 	orhi	zero,at,33089
 8204590:	08205074 	orhi	zero,at,33089
 8204594:	08205074 	orhi	zero,at,33089
 8204598:	08205074 	orhi	zero,at,33089
 820459c:	08205074 	orhi	zero,at,33089
 82045a0:	08204db0 	cmpltui	zero,at,33078
 82045a4:	08205074 	orhi	zero,at,33089
 82045a8:	08205074 	orhi	zero,at,33089
 82045ac:	08204e10 	cmplti	zero,at,-32456
 82045b0:	08205074 	orhi	zero,at,33089
 82045b4:	08205074 	orhi	zero,at,33089
 82045b8:	08205074 	orhi	zero,at,33089
 82045bc:	08205074 	orhi	zero,at,33089
 82045c0:	08205074 	orhi	zero,at,33089
 82045c4:	08205074 	orhi	zero,at,33089
 82045c8:	08205074 	orhi	zero,at,33089
 82045cc:	08205074 	orhi	zero,at,33089
 82045d0:	08205074 	orhi	zero,at,33089
 82045d4:	08205074 	orhi	zero,at,33089
 82045d8:	08204ec0 	call	8204ec <OSCtxSw_SWITCH_PC+0x8204ac>
 82045dc:	08204ffc 	xorhi	zero,at,33087
 82045e0:	082047d8 	cmpnei	zero,at,-32481
 82045e4:	082047d8 	cmpnei	zero,at,-32481
 82045e8:	082047d8 	cmpnei	zero,at,-32481
 82045ec:	08205050 	cmplti	zero,at,-32447
 82045f0:	08204ffc 	xorhi	zero,at,33087
 82045f4:	08205074 	orhi	zero,at,33089
 82045f8:	08205074 	orhi	zero,at,33089
 82045fc:	0820500c 	andi	zero,at,33088
 8204600:	08205074 	orhi	zero,at,33089
 8204604:	0820501c 	xori	zero,at,33088
 8204608:	08204efc 	xorhi	zero,at,33083
 820460c:	0820464c 	andi	zero,at,33049
 8204610:	08204f1c 	xori	zero,at,33084
 8204614:	08205074 	orhi	zero,at,33089
 8204618:	08204f28 	cmpgeui	zero,at,33084
 820461c:	08205074 	orhi	zero,at,33089
 8204620:	08204f84 	addi	zero,at,-32450
 8204624:	08205074 	orhi	zero,at,33089
 8204628:	08205074 	orhi	zero,at,33089
 820462c:	08204f94 	ori	zero,at,33086
 8204630:	d9003117 	ldw	r4,196(sp)
 8204634:	d8802d15 	stw	r2,180(sp)
 8204638:	0109c83a 	sub	r4,zero,r4
 820463c:	d9003115 	stw	r4,196(sp)
 8204640:	94800114 	ori	r18,r18,4
 8204644:	bc400007 	ldb	r17,0(r23)
 8204648:	003f9706 	br	82044a8 <___svfprintf_internal_r+0x150>
 820464c:	00800c04 	movi	r2,48
 8204650:	d9002d17 	ldw	r4,180(sp)
 8204654:	d9402917 	ldw	r5,164(sp)
 8204658:	d8802705 	stb	r2,156(sp)
 820465c:	00801e04 	movi	r2,120
 8204660:	d8802745 	stb	r2,157(sp)
 8204664:	d8002785 	stb	zero,158(sp)
 8204668:	20c00104 	addi	r3,r4,4
 820466c:	25000017 	ldw	r20,0(r4)
 8204670:	002d883a 	mov	r22,zero
 8204674:	90800094 	ori	r2,r18,2
 8204678:	28028616 	blt	r5,zero,8205094 <___svfprintf_internal_r+0xd3c>
 820467c:	00bfdfc4 	movi	r2,-129
 8204680:	90a4703a 	and	r18,r18,r2
 8204684:	d8c02d15 	stw	r3,180(sp)
 8204688:	94800094 	ori	r18,r18,2
 820468c:	a002731e 	bne	r20,zero,820505c <___svfprintf_internal_r+0xd04>
 8204690:	00820974 	movhi	r2,2085
 8204694:	10b55a04 	addi	r2,r2,-10904
 8204698:	d8803a15 	stw	r2,232(sp)
 820469c:	04401e04 	movi	r17,120
 82046a0:	d8c02917 	ldw	r3,164(sp)
 82046a4:	0039883a 	mov	fp,zero
 82046a8:	1801d526 	beq	r3,zero,8204e00 <___svfprintf_internal_r+0xaa8>
 82046ac:	0029883a 	mov	r20,zero
 82046b0:	002d883a 	mov	r22,zero
 82046b4:	0001f106 	br	8204e7c <___svfprintf_internal_r+0xb24>
 82046b8:	d9402c17 	ldw	r5,176(sp)
 82046bc:	d9801e04 	addi	r6,sp,120
 82046c0:	9809883a 	mov	r4,r19
 82046c4:	820db840 	call	820db84 <__ssprint_r>
 82046c8:	1000081e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82046cc:	da000404 	addi	r8,sp,16
 82046d0:	003f6306 	br	8204460 <___svfprintf_internal_r+0x108>
 82046d4:	d8802017 	ldw	r2,128(sp)
 82046d8:	10000426 	beq	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82046dc:	d9402c17 	ldw	r5,176(sp)
 82046e0:	d9003917 	ldw	r4,228(sp)
 82046e4:	d9801e04 	addi	r6,sp,120
 82046e8:	820db840 	call	820db84 <__ssprint_r>
 82046ec:	d8802c17 	ldw	r2,176(sp)
 82046f0:	10c0030b 	ldhu	r3,12(r2)
 82046f4:	d8802f17 	ldw	r2,188(sp)
 82046f8:	18c0100c 	andi	r3,r3,64
 82046fc:	1805f51e 	bne	r3,zero,8205ed4 <___svfprintf_internal_r+0x1b7c>
 8204700:	dfc04817 	ldw	ra,288(sp)
 8204704:	df004717 	ldw	fp,284(sp)
 8204708:	ddc04617 	ldw	r23,280(sp)
 820470c:	dd804517 	ldw	r22,276(sp)
 8204710:	dd404417 	ldw	r21,272(sp)
 8204714:	dd004317 	ldw	r20,268(sp)
 8204718:	dcc04217 	ldw	r19,264(sp)
 820471c:	dc804117 	ldw	r18,260(sp)
 8204720:	dc404017 	ldw	r17,256(sp)
 8204724:	dc003f17 	ldw	r16,252(sp)
 8204728:	dec04904 	addi	sp,sp,292
 820472c:	f800283a 	ret
 8204730:	d8802d17 	ldw	r2,180(sp)
 8204734:	d9002d17 	ldw	r4,180(sp)
 8204738:	10800017 	ldw	r2,0(r2)
 820473c:	d8803115 	stw	r2,196(sp)
 8204740:	20800104 	addi	r2,r4,4
 8204744:	d9003117 	ldw	r4,196(sp)
 8204748:	203fb916 	blt	r4,zero,8204630 <___svfprintf_internal_r+0x2d8>
 820474c:	d8802d15 	stw	r2,180(sp)
 8204750:	bc400007 	ldb	r17,0(r23)
 8204754:	003f5406 	br	82044a8 <___svfprintf_internal_r+0x150>
 8204758:	bc400007 	ldb	r17,0(r23)
 820475c:	bac00044 	addi	r11,r23,1
 8204760:	8a873926 	beq	r17,r10,8206448 <___svfprintf_internal_r+0x20f0>
 8204764:	88bff404 	addi	r2,r17,-48
 8204768:	0009883a 	mov	r4,zero
 820476c:	30868836 	bltu	r6,r2,8206190 <___svfprintf_internal_r+0x1e38>
 8204770:	5c400007 	ldb	r17,0(r11)
 8204774:	210002a4 	muli	r4,r4,10
 8204778:	5dc00044 	addi	r23,r11,1
 820477c:	b817883a 	mov	r11,r23
 8204780:	2089883a 	add	r4,r4,r2
 8204784:	88bff404 	addi	r2,r17,-48
 8204788:	30bff92e 	bgeu	r6,r2,8204770 <___svfprintf_internal_r+0x418>
 820478c:	2005d716 	blt	r4,zero,8205eec <___svfprintf_internal_r+0x1b94>
 8204790:	d9002915 	stw	r4,164(sp)
 8204794:	003f4506 	br	82044ac <___svfprintf_internal_r+0x154>
 8204798:	b809883a 	mov	r4,r23
 820479c:	d8003115 	stw	zero,196(sp)
 82047a0:	88bff404 	addi	r2,r17,-48
 82047a4:	0017883a 	mov	r11,zero
 82047a8:	24400007 	ldb	r17,0(r4)
 82047ac:	5ac002a4 	muli	r11,r11,10
 82047b0:	bdc00044 	addi	r23,r23,1
 82047b4:	b809883a 	mov	r4,r23
 82047b8:	12d7883a 	add	r11,r2,r11
 82047bc:	88bff404 	addi	r2,r17,-48
 82047c0:	30bff92e 	bgeu	r6,r2,82047a8 <___svfprintf_internal_r+0x450>
 82047c4:	dac03115 	stw	r11,196(sp)
 82047c8:	003f3806 	br	82044ac <___svfprintf_internal_r+0x154>
 82047cc:	94802014 	ori	r18,r18,128
 82047d0:	bc400007 	ldb	r17,0(r23)
 82047d4:	003f3406 	br	82044a8 <___svfprintf_internal_r+0x150>
 82047d8:	18c03fcc 	andi	r3,r3,255
 82047dc:	1807471e 	bne	r3,zero,82064fc <___svfprintf_internal_r+0x21a4>
 82047e0:	9080020c 	andi	r2,r18,8
 82047e4:	10047d26 	beq	r2,zero,82059dc <___svfprintf_internal_r+0x1684>
 82047e8:	d8c02d17 	ldw	r3,180(sp)
 82047ec:	d9002d17 	ldw	r4,180(sp)
 82047f0:	d9402d17 	ldw	r5,180(sp)
 82047f4:	18c00017 	ldw	r3,0(r3)
 82047f8:	21000117 	ldw	r4,4(r4)
 82047fc:	29400204 	addi	r5,r5,8
 8204800:	d8c03615 	stw	r3,216(sp)
 8204804:	d9003715 	stw	r4,220(sp)
 8204808:	d9402d15 	stw	r5,180(sp)
 820480c:	d9003617 	ldw	r4,216(sp)
 8204810:	d9403717 	ldw	r5,220(sp)
 8204814:	da003e15 	stw	r8,248(sp)
 8204818:	04000044 	movi	r16,1
 820481c:	820d8a40 	call	820d8a4 <__fpclassifyd>
 8204820:	da003e17 	ldw	r8,248(sp)
 8204824:	14044b1e 	bne	r2,r16,8205954 <___svfprintf_internal_r+0x15fc>
 8204828:	d9003617 	ldw	r4,216(sp)
 820482c:	d9403717 	ldw	r5,220(sp)
 8204830:	000d883a 	mov	r6,zero
 8204834:	000f883a 	mov	r7,zero
 8204838:	8212b5c0 	call	8212b5c <__ledf2>
 820483c:	da003e17 	ldw	r8,248(sp)
 8204840:	1005f316 	blt	r2,zero,8206010 <___svfprintf_internal_r+0x1cb8>
 8204844:	df002783 	ldbu	fp,158(sp)
 8204848:	008011c4 	movi	r2,71
 820484c:	1445590e 	bge	r2,r17,8205db4 <___svfprintf_internal_r+0x1a5c>
 8204850:	04020974 	movhi	r16,2085
 8204854:	84355204 	addi	r16,r16,-10936
 8204858:	00c000c4 	movi	r3,3
 820485c:	00bfdfc4 	movi	r2,-129
 8204860:	d8c02a15 	stw	r3,168(sp)
 8204864:	90a4703a 	and	r18,r18,r2
 8204868:	d8c02e15 	stw	r3,184(sp)
 820486c:	d8002915 	stw	zero,164(sp)
 8204870:	d8003215 	stw	zero,200(sp)
 8204874:	00006606 	br	8204a10 <___svfprintf_internal_r+0x6b8>
 8204878:	94800214 	ori	r18,r18,8
 820487c:	bc400007 	ldb	r17,0(r23)
 8204880:	003f0906 	br	82044a8 <___svfprintf_internal_r+0x150>
 8204884:	18c03fcc 	andi	r3,r3,255
 8204888:	1807181e 	bne	r3,zero,82064ec <___svfprintf_internal_r+0x2194>
 820488c:	94800414 	ori	r18,r18,16
 8204890:	9080080c 	andi	r2,r18,32
 8204894:	10039626 	beq	r2,zero,82056f0 <___svfprintf_internal_r+0x1398>
 8204898:	d9402d17 	ldw	r5,180(sp)
 820489c:	28800117 	ldw	r2,4(r5)
 82048a0:	2d000017 	ldw	r20,0(r5)
 82048a4:	29400204 	addi	r5,r5,8
 82048a8:	d9402d15 	stw	r5,180(sp)
 82048ac:	102d883a 	mov	r22,r2
 82048b0:	10039816 	blt	r2,zero,8205714 <___svfprintf_internal_r+0x13bc>
 82048b4:	d9402917 	ldw	r5,164(sp)
 82048b8:	df002783 	ldbu	fp,158(sp)
 82048bc:	2803ab16 	blt	r5,zero,820576c <___svfprintf_internal_r+0x1414>
 82048c0:	00ffdfc4 	movi	r3,-129
 82048c4:	a584b03a 	or	r2,r20,r22
 82048c8:	90e4703a 	and	r18,r18,r3
 82048cc:	10014a26 	beq	r2,zero,8204df8 <___svfprintf_internal_r+0xaa0>
 82048d0:	b0034b26 	beq	r22,zero,8205600 <___svfprintf_internal_r+0x12a8>
 82048d4:	dc402a15 	stw	r17,168(sp)
 82048d8:	dc001e04 	addi	r16,sp,120
 82048dc:	b023883a 	mov	r17,r22
 82048e0:	402d883a 	mov	r22,r8
 82048e4:	a009883a 	mov	r4,r20
 82048e8:	880b883a 	mov	r5,r17
 82048ec:	01800284 	movi	r6,10
 82048f0:	000f883a 	mov	r7,zero
 82048f4:	821132c0 	call	821132c <__umoddi3>
 82048f8:	10800c04 	addi	r2,r2,48
 82048fc:	843fffc4 	addi	r16,r16,-1
 8204900:	a009883a 	mov	r4,r20
 8204904:	880b883a 	mov	r5,r17
 8204908:	80800005 	stb	r2,0(r16)
 820490c:	01800284 	movi	r6,10
 8204910:	000f883a 	mov	r7,zero
 8204914:	8210db40 	call	8210db4 <__udivdi3>
 8204918:	1029883a 	mov	r20,r2
 820491c:	10c4b03a 	or	r2,r2,r3
 8204920:	1823883a 	mov	r17,r3
 8204924:	103fef1e 	bne	r2,zero,82048e4 <___svfprintf_internal_r+0x58c>
 8204928:	d8c02817 	ldw	r3,160(sp)
 820492c:	dc402a17 	ldw	r17,168(sp)
 8204930:	b011883a 	mov	r8,r22
 8204934:	1c07c83a 	sub	r3,r3,r16
 8204938:	d8c02e15 	stw	r3,184(sp)
 820493c:	00002e06 	br	82049f8 <___svfprintf_internal_r+0x6a0>
 8204940:	18c03fcc 	andi	r3,r3,255
 8204944:	1806e71e 	bne	r3,zero,82064e4 <___svfprintf_internal_r+0x218c>
 8204948:	94800414 	ori	r18,r18,16
 820494c:	9080080c 	andi	r2,r18,32
 8204950:	1002d426 	beq	r2,zero,82054a4 <___svfprintf_internal_r+0x114c>
 8204954:	d9402d17 	ldw	r5,180(sp)
 8204958:	d8c02917 	ldw	r3,164(sp)
 820495c:	d8002785 	stb	zero,158(sp)
 8204960:	28800204 	addi	r2,r5,8
 8204964:	2d000017 	ldw	r20,0(r5)
 8204968:	2d800117 	ldw	r22,4(r5)
 820496c:	18041516 	blt	r3,zero,82059c4 <___svfprintf_internal_r+0x166c>
 8204970:	013fdfc4 	movi	r4,-129
 8204974:	a586b03a 	or	r3,r20,r22
 8204978:	d8802d15 	stw	r2,180(sp)
 820497c:	9124703a 	and	r18,r18,r4
 8204980:	1802d51e 	bne	r3,zero,82054d8 <___svfprintf_internal_r+0x1180>
 8204984:	d9402917 	ldw	r5,164(sp)
 8204988:	0039883a 	mov	fp,zero
 820498c:	2806be26 	beq	r5,zero,8206488 <___svfprintf_internal_r+0x2130>
 8204990:	0029883a 	mov	r20,zero
 8204994:	002d883a 	mov	r22,zero
 8204998:	dc001e04 	addi	r16,sp,120
 820499c:	a006d0fa 	srli	r3,r20,3
 82049a0:	b008977a 	slli	r4,r22,29
 82049a4:	b02cd0fa 	srli	r22,r22,3
 82049a8:	a50001cc 	andi	r20,r20,7
 82049ac:	a0800c04 	addi	r2,r20,48
 82049b0:	843fffc4 	addi	r16,r16,-1
 82049b4:	20e8b03a 	or	r20,r4,r3
 82049b8:	80800005 	stb	r2,0(r16)
 82049bc:	a586b03a 	or	r3,r20,r22
 82049c0:	183ff61e 	bne	r3,zero,820499c <___svfprintf_internal_r+0x644>
 82049c4:	90c0004c 	andi	r3,r18,1
 82049c8:	18013926 	beq	r3,zero,8204eb0 <___svfprintf_internal_r+0xb58>
 82049cc:	10803fcc 	andi	r2,r2,255
 82049d0:	1080201c 	xori	r2,r2,128
 82049d4:	10bfe004 	addi	r2,r2,-128
 82049d8:	00c00c04 	movi	r3,48
 82049dc:	10c13426 	beq	r2,r3,8204eb0 <___svfprintf_internal_r+0xb58>
 82049e0:	80ffffc5 	stb	r3,-1(r16)
 82049e4:	d8c02817 	ldw	r3,160(sp)
 82049e8:	80bfffc4 	addi	r2,r16,-1
 82049ec:	1021883a 	mov	r16,r2
 82049f0:	1887c83a 	sub	r3,r3,r2
 82049f4:	d8c02e15 	stw	r3,184(sp)
 82049f8:	d8802e17 	ldw	r2,184(sp)
 82049fc:	d9002917 	ldw	r4,164(sp)
 8204a00:	1100010e 	bge	r2,r4,8204a08 <___svfprintf_internal_r+0x6b0>
 8204a04:	2005883a 	mov	r2,r4
 8204a08:	d8802a15 	stw	r2,168(sp)
 8204a0c:	d8003215 	stw	zero,200(sp)
 8204a10:	e7003fcc 	andi	fp,fp,255
 8204a14:	e700201c 	xori	fp,fp,128
 8204a18:	e73fe004 	addi	fp,fp,-128
 8204a1c:	e0000326 	beq	fp,zero,8204a2c <___svfprintf_internal_r+0x6d4>
 8204a20:	d8c02a17 	ldw	r3,168(sp)
 8204a24:	18c00044 	addi	r3,r3,1
 8204a28:	d8c02a15 	stw	r3,168(sp)
 8204a2c:	90c0008c 	andi	r3,r18,2
 8204a30:	d8c02b15 	stw	r3,172(sp)
 8204a34:	18000326 	beq	r3,zero,8204a44 <___svfprintf_internal_r+0x6ec>
 8204a38:	d8c02a17 	ldw	r3,168(sp)
 8204a3c:	18c00084 	addi	r3,r3,2
 8204a40:	d8c02a15 	stw	r3,168(sp)
 8204a44:	90c0210c 	andi	r3,r18,132
 8204a48:	d8c03015 	stw	r3,192(sp)
 8204a4c:	1801a11e 	bne	r3,zero,82050d4 <___svfprintf_internal_r+0xd7c>
 8204a50:	d9003117 	ldw	r4,196(sp)
 8204a54:	d8c02a17 	ldw	r3,168(sp)
 8204a58:	20e9c83a 	sub	r20,r4,r3
 8204a5c:	05019d0e 	bge	zero,r20,82050d4 <___svfprintf_internal_r+0xd7c>
 8204a60:	02400404 	movi	r9,16
 8204a64:	d8c02017 	ldw	r3,128(sp)
 8204a68:	d8801f17 	ldw	r2,124(sp)
 8204a6c:	4d051b0e 	bge	r9,r20,8205edc <___svfprintf_internal_r+0x1b84>
 8204a70:	01420974 	movhi	r5,2085
 8204a74:	29756584 	addi	r5,r5,-10858
 8204a78:	dc403c15 	stw	r17,240(sp)
 8204a7c:	d9403515 	stw	r5,212(sp)
 8204a80:	a023883a 	mov	r17,r20
 8204a84:	482d883a 	mov	r22,r9
 8204a88:	9029883a 	mov	r20,r18
 8204a8c:	070001c4 	movi	fp,7
 8204a90:	8025883a 	mov	r18,r16
 8204a94:	dc002c17 	ldw	r16,176(sp)
 8204a98:	00000306 	br	8204aa8 <___svfprintf_internal_r+0x750>
 8204a9c:	8c7ffc04 	addi	r17,r17,-16
 8204aa0:	42000204 	addi	r8,r8,8
 8204aa4:	b440130e 	bge	r22,r17,8204af4 <___svfprintf_internal_r+0x79c>
 8204aa8:	01020974 	movhi	r4,2085
 8204aac:	18c00404 	addi	r3,r3,16
 8204ab0:	10800044 	addi	r2,r2,1
 8204ab4:	21356584 	addi	r4,r4,-10858
 8204ab8:	41000015 	stw	r4,0(r8)
 8204abc:	45800115 	stw	r22,4(r8)
 8204ac0:	d8c02015 	stw	r3,128(sp)
 8204ac4:	d8801f15 	stw	r2,124(sp)
 8204ac8:	e0bff40e 	bge	fp,r2,8204a9c <___svfprintf_internal_r+0x744>
 8204acc:	d9801e04 	addi	r6,sp,120
 8204ad0:	800b883a 	mov	r5,r16
 8204ad4:	9809883a 	mov	r4,r19
 8204ad8:	820db840 	call	820db84 <__ssprint_r>
 8204adc:	103f031e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8204ae0:	8c7ffc04 	addi	r17,r17,-16
 8204ae4:	d8c02017 	ldw	r3,128(sp)
 8204ae8:	d8801f17 	ldw	r2,124(sp)
 8204aec:	da000404 	addi	r8,sp,16
 8204af0:	b47fed16 	blt	r22,r17,8204aa8 <___svfprintf_internal_r+0x750>
 8204af4:	9021883a 	mov	r16,r18
 8204af8:	a025883a 	mov	r18,r20
 8204afc:	8829883a 	mov	r20,r17
 8204b00:	dc403c17 	ldw	r17,240(sp)
 8204b04:	d9403517 	ldw	r5,212(sp)
 8204b08:	a0c7883a 	add	r3,r20,r3
 8204b0c:	10800044 	addi	r2,r2,1
 8204b10:	41400015 	stw	r5,0(r8)
 8204b14:	45000115 	stw	r20,4(r8)
 8204b18:	d8c02015 	stw	r3,128(sp)
 8204b1c:	d8801f15 	stw	r2,124(sp)
 8204b20:	010001c4 	movi	r4,7
 8204b24:	20829f16 	blt	r4,r2,82055a4 <___svfprintf_internal_r+0x124c>
 8204b28:	df002787 	ldb	fp,158(sp)
 8204b2c:	42000204 	addi	r8,r8,8
 8204b30:	e0000c26 	beq	fp,zero,8204b64 <___svfprintf_internal_r+0x80c>
 8204b34:	d8801f17 	ldw	r2,124(sp)
 8204b38:	d9002784 	addi	r4,sp,158
 8204b3c:	18c00044 	addi	r3,r3,1
 8204b40:	10800044 	addi	r2,r2,1
 8204b44:	41000015 	stw	r4,0(r8)
 8204b48:	01000044 	movi	r4,1
 8204b4c:	41000115 	stw	r4,4(r8)
 8204b50:	d8c02015 	stw	r3,128(sp)
 8204b54:	d8801f15 	stw	r2,124(sp)
 8204b58:	010001c4 	movi	r4,7
 8204b5c:	20823816 	blt	r4,r2,8205440 <___svfprintf_internal_r+0x10e8>
 8204b60:	42000204 	addi	r8,r8,8
 8204b64:	d8802b17 	ldw	r2,172(sp)
 8204b68:	10000c26 	beq	r2,zero,8204b9c <___svfprintf_internal_r+0x844>
 8204b6c:	d8801f17 	ldw	r2,124(sp)
 8204b70:	d9002704 	addi	r4,sp,156
 8204b74:	18c00084 	addi	r3,r3,2
 8204b78:	10800044 	addi	r2,r2,1
 8204b7c:	41000015 	stw	r4,0(r8)
 8204b80:	01000084 	movi	r4,2
 8204b84:	41000115 	stw	r4,4(r8)
 8204b88:	d8c02015 	stw	r3,128(sp)
 8204b8c:	d8801f15 	stw	r2,124(sp)
 8204b90:	010001c4 	movi	r4,7
 8204b94:	20823216 	blt	r4,r2,8205460 <___svfprintf_internal_r+0x1108>
 8204b98:	42000204 	addi	r8,r8,8
 8204b9c:	d9003017 	ldw	r4,192(sp)
 8204ba0:	00802004 	movi	r2,128
 8204ba4:	20819726 	beq	r4,r2,8205204 <___svfprintf_internal_r+0xeac>
 8204ba8:	d9402917 	ldw	r5,164(sp)
 8204bac:	d8802e17 	ldw	r2,184(sp)
 8204bb0:	28adc83a 	sub	r22,r5,r2
 8204bb4:	05802f0e 	bge	zero,r22,8204c74 <___svfprintf_internal_r+0x91c>
 8204bb8:	07000404 	movi	fp,16
 8204bbc:	d8801f17 	ldw	r2,124(sp)
 8204bc0:	e583c00e 	bge	fp,r22,8205ac4 <___svfprintf_internal_r+0x176c>
 8204bc4:	01420974 	movhi	r5,2085
 8204bc8:	29756184 	addi	r5,r5,-10874
 8204bcc:	dc402915 	stw	r17,164(sp)
 8204bd0:	d9402b15 	stw	r5,172(sp)
 8204bd4:	b023883a 	mov	r17,r22
 8204bd8:	050001c4 	movi	r20,7
 8204bdc:	902d883a 	mov	r22,r18
 8204be0:	8025883a 	mov	r18,r16
 8204be4:	dc002c17 	ldw	r16,176(sp)
 8204be8:	00000306 	br	8204bf8 <___svfprintf_internal_r+0x8a0>
 8204bec:	8c7ffc04 	addi	r17,r17,-16
 8204bf0:	42000204 	addi	r8,r8,8
 8204bf4:	e440110e 	bge	fp,r17,8204c3c <___svfprintf_internal_r+0x8e4>
 8204bf8:	18c00404 	addi	r3,r3,16
 8204bfc:	10800044 	addi	r2,r2,1
 8204c00:	45400015 	stw	r21,0(r8)
 8204c04:	47000115 	stw	fp,4(r8)
 8204c08:	d8c02015 	stw	r3,128(sp)
 8204c0c:	d8801f15 	stw	r2,124(sp)
 8204c10:	a0bff60e 	bge	r20,r2,8204bec <___svfprintf_internal_r+0x894>
 8204c14:	d9801e04 	addi	r6,sp,120
 8204c18:	800b883a 	mov	r5,r16
 8204c1c:	9809883a 	mov	r4,r19
 8204c20:	820db840 	call	820db84 <__ssprint_r>
 8204c24:	103eb11e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8204c28:	8c7ffc04 	addi	r17,r17,-16
 8204c2c:	d8c02017 	ldw	r3,128(sp)
 8204c30:	d8801f17 	ldw	r2,124(sp)
 8204c34:	da000404 	addi	r8,sp,16
 8204c38:	e47fef16 	blt	fp,r17,8204bf8 <___svfprintf_internal_r+0x8a0>
 8204c3c:	9021883a 	mov	r16,r18
 8204c40:	b025883a 	mov	r18,r22
 8204c44:	882d883a 	mov	r22,r17
 8204c48:	dc402917 	ldw	r17,164(sp)
 8204c4c:	d9002b17 	ldw	r4,172(sp)
 8204c50:	1d87883a 	add	r3,r3,r22
 8204c54:	10800044 	addi	r2,r2,1
 8204c58:	41000015 	stw	r4,0(r8)
 8204c5c:	45800115 	stw	r22,4(r8)
 8204c60:	d8c02015 	stw	r3,128(sp)
 8204c64:	d8801f15 	stw	r2,124(sp)
 8204c68:	010001c4 	movi	r4,7
 8204c6c:	2081ec16 	blt	r4,r2,8205420 <___svfprintf_internal_r+0x10c8>
 8204c70:	42000204 	addi	r8,r8,8
 8204c74:	9080400c 	andi	r2,r18,256
 8204c78:	1001181e 	bne	r2,zero,82050dc <___svfprintf_internal_r+0xd84>
 8204c7c:	d9402e17 	ldw	r5,184(sp)
 8204c80:	d8801f17 	ldw	r2,124(sp)
 8204c84:	44000015 	stw	r16,0(r8)
 8204c88:	1947883a 	add	r3,r3,r5
 8204c8c:	10800044 	addi	r2,r2,1
 8204c90:	41400115 	stw	r5,4(r8)
 8204c94:	d8c02015 	stw	r3,128(sp)
 8204c98:	d8801f15 	stw	r2,124(sp)
 8204c9c:	010001c4 	movi	r4,7
 8204ca0:	2081d116 	blt	r4,r2,82053e8 <___svfprintf_internal_r+0x1090>
 8204ca4:	42000204 	addi	r8,r8,8
 8204ca8:	9480010c 	andi	r18,r18,4
 8204cac:	90003226 	beq	r18,zero,8204d78 <___svfprintf_internal_r+0xa20>
 8204cb0:	d9403117 	ldw	r5,196(sp)
 8204cb4:	d8802a17 	ldw	r2,168(sp)
 8204cb8:	28a1c83a 	sub	r16,r5,r2
 8204cbc:	04002e0e 	bge	zero,r16,8204d78 <___svfprintf_internal_r+0xa20>
 8204cc0:	04400404 	movi	r17,16
 8204cc4:	d8801f17 	ldw	r2,124(sp)
 8204cc8:	8c04b90e 	bge	r17,r16,8205fb0 <___svfprintf_internal_r+0x1c58>
 8204ccc:	01420974 	movhi	r5,2085
 8204cd0:	29756584 	addi	r5,r5,-10858
 8204cd4:	d9403515 	stw	r5,212(sp)
 8204cd8:	048001c4 	movi	r18,7
 8204cdc:	dd002c17 	ldw	r20,176(sp)
 8204ce0:	00000306 	br	8204cf0 <___svfprintf_internal_r+0x998>
 8204ce4:	843ffc04 	addi	r16,r16,-16
 8204ce8:	42000204 	addi	r8,r8,8
 8204cec:	8c00130e 	bge	r17,r16,8204d3c <___svfprintf_internal_r+0x9e4>
 8204cf0:	01020974 	movhi	r4,2085
 8204cf4:	18c00404 	addi	r3,r3,16
 8204cf8:	10800044 	addi	r2,r2,1
 8204cfc:	21356584 	addi	r4,r4,-10858
 8204d00:	41000015 	stw	r4,0(r8)
 8204d04:	44400115 	stw	r17,4(r8)
 8204d08:	d8c02015 	stw	r3,128(sp)
 8204d0c:	d8801f15 	stw	r2,124(sp)
 8204d10:	90bff40e 	bge	r18,r2,8204ce4 <___svfprintf_internal_r+0x98c>
 8204d14:	d9801e04 	addi	r6,sp,120
 8204d18:	a00b883a 	mov	r5,r20
 8204d1c:	9809883a 	mov	r4,r19
 8204d20:	820db840 	call	820db84 <__ssprint_r>
 8204d24:	103e711e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8204d28:	843ffc04 	addi	r16,r16,-16
 8204d2c:	d8c02017 	ldw	r3,128(sp)
 8204d30:	d8801f17 	ldw	r2,124(sp)
 8204d34:	da000404 	addi	r8,sp,16
 8204d38:	8c3fed16 	blt	r17,r16,8204cf0 <___svfprintf_internal_r+0x998>
 8204d3c:	d9403517 	ldw	r5,212(sp)
 8204d40:	1c07883a 	add	r3,r3,r16
 8204d44:	10800044 	addi	r2,r2,1
 8204d48:	41400015 	stw	r5,0(r8)
 8204d4c:	44000115 	stw	r16,4(r8)
 8204d50:	d8c02015 	stw	r3,128(sp)
 8204d54:	d8801f15 	stw	r2,124(sp)
 8204d58:	010001c4 	movi	r4,7
 8204d5c:	2080060e 	bge	r4,r2,8204d78 <___svfprintf_internal_r+0xa20>
 8204d60:	d9402c17 	ldw	r5,176(sp)
 8204d64:	d9801e04 	addi	r6,sp,120
 8204d68:	9809883a 	mov	r4,r19
 8204d6c:	820db840 	call	820db84 <__ssprint_r>
 8204d70:	103e5e1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8204d74:	d8c02017 	ldw	r3,128(sp)
 8204d78:	d8803117 	ldw	r2,196(sp)
 8204d7c:	d9002a17 	ldw	r4,168(sp)
 8204d80:	1100010e 	bge	r2,r4,8204d88 <___svfprintf_internal_r+0xa30>
 8204d84:	2005883a 	mov	r2,r4
 8204d88:	d9402f17 	ldw	r5,188(sp)
 8204d8c:	288b883a 	add	r5,r5,r2
 8204d90:	d9402f15 	stw	r5,188(sp)
 8204d94:	18019c1e 	bne	r3,zero,8205408 <___svfprintf_internal_r+0x10b0>
 8204d98:	b8800007 	ldb	r2,0(r23)
 8204d9c:	d8001f15 	stw	zero,124(sp)
 8204da0:	da000404 	addi	r8,sp,16
 8204da4:	103d991e 	bne	r2,zero,820440c <___svfprintf_internal_r+0xb4>
 8204da8:	b821883a 	mov	r16,r23
 8204dac:	003daf06 	br	820446c <___svfprintf_internal_r+0x114>
 8204db0:	18c03fcc 	andi	r3,r3,255
 8204db4:	1805c71e 	bne	r3,zero,82064d4 <___svfprintf_internal_r+0x217c>
 8204db8:	94800414 	ori	r18,r18,16
 8204dbc:	9080080c 	andi	r2,r18,32
 8204dc0:	10020126 	beq	r2,zero,82055c8 <___svfprintf_internal_r+0x1270>
 8204dc4:	d8802d17 	ldw	r2,180(sp)
 8204dc8:	d9002917 	ldw	r4,164(sp)
 8204dcc:	d8002785 	stb	zero,158(sp)
 8204dd0:	10c00204 	addi	r3,r2,8
 8204dd4:	15000017 	ldw	r20,0(r2)
 8204dd8:	15800117 	ldw	r22,4(r2)
 8204ddc:	20038e16 	blt	r4,zero,8205c18 <___svfprintf_internal_r+0x18c0>
 8204de0:	013fdfc4 	movi	r4,-129
 8204de4:	a584b03a 	or	r2,r20,r22
 8204de8:	d8c02d15 	stw	r3,180(sp)
 8204dec:	9124703a 	and	r18,r18,r4
 8204df0:	0039883a 	mov	fp,zero
 8204df4:	103eb61e 	bne	r2,zero,82048d0 <___svfprintf_internal_r+0x578>
 8204df8:	d8802917 	ldw	r2,164(sp)
 8204dfc:	1002c81e 	bne	r2,zero,8205920 <___svfprintf_internal_r+0x15c8>
 8204e00:	d8002915 	stw	zero,164(sp)
 8204e04:	d8002e15 	stw	zero,184(sp)
 8204e08:	dc001e04 	addi	r16,sp,120
 8204e0c:	003efa06 	br	82049f8 <___svfprintf_internal_r+0x6a0>
 8204e10:	18c03fcc 	andi	r3,r3,255
 8204e14:	1805ad1e 	bne	r3,zero,82064cc <___svfprintf_internal_r+0x2174>
 8204e18:	01420974 	movhi	r5,2085
 8204e1c:	29755504 	addi	r5,r5,-10924
 8204e20:	d9403a15 	stw	r5,232(sp)
 8204e24:	9080080c 	andi	r2,r18,32
 8204e28:	10006126 	beq	r2,zero,8204fb0 <___svfprintf_internal_r+0xc58>
 8204e2c:	d8802d17 	ldw	r2,180(sp)
 8204e30:	15000017 	ldw	r20,0(r2)
 8204e34:	15800117 	ldw	r22,4(r2)
 8204e38:	10800204 	addi	r2,r2,8
 8204e3c:	d8802d15 	stw	r2,180(sp)
 8204e40:	9080004c 	andi	r2,r18,1
 8204e44:	10018e26 	beq	r2,zero,8205480 <___svfprintf_internal_r+0x1128>
 8204e48:	a584b03a 	or	r2,r20,r22
 8204e4c:	10030926 	beq	r2,zero,8205a74 <___svfprintf_internal_r+0x171c>
 8204e50:	d8c02917 	ldw	r3,164(sp)
 8204e54:	00800c04 	movi	r2,48
 8204e58:	d8802705 	stb	r2,156(sp)
 8204e5c:	dc402745 	stb	r17,157(sp)
 8204e60:	d8002785 	stb	zero,158(sp)
 8204e64:	90800094 	ori	r2,r18,2
 8204e68:	18048716 	blt	r3,zero,8206088 <___svfprintf_internal_r+0x1d30>
 8204e6c:	00bfdfc4 	movi	r2,-129
 8204e70:	90a4703a 	and	r18,r18,r2
 8204e74:	94800094 	ori	r18,r18,2
 8204e78:	0039883a 	mov	fp,zero
 8204e7c:	d9003a17 	ldw	r4,232(sp)
 8204e80:	dc001e04 	addi	r16,sp,120
 8204e84:	a08003cc 	andi	r2,r20,15
 8204e88:	b006973a 	slli	r3,r22,28
 8204e8c:	2085883a 	add	r2,r4,r2
 8204e90:	a028d13a 	srli	r20,r20,4
 8204e94:	10800003 	ldbu	r2,0(r2)
 8204e98:	b02cd13a 	srli	r22,r22,4
 8204e9c:	843fffc4 	addi	r16,r16,-1
 8204ea0:	1d28b03a 	or	r20,r3,r20
 8204ea4:	80800005 	stb	r2,0(r16)
 8204ea8:	a584b03a 	or	r2,r20,r22
 8204eac:	103ff51e 	bne	r2,zero,8204e84 <___svfprintf_internal_r+0xb2c>
 8204eb0:	d8c02817 	ldw	r3,160(sp)
 8204eb4:	1c07c83a 	sub	r3,r3,r16
 8204eb8:	d8c02e15 	stw	r3,184(sp)
 8204ebc:	003ece06 	br	82049f8 <___svfprintf_internal_r+0x6a0>
 8204ec0:	d8c02d17 	ldw	r3,180(sp)
 8204ec4:	d9002d17 	ldw	r4,180(sp)
 8204ec8:	d8002785 	stb	zero,158(sp)
 8204ecc:	18800017 	ldw	r2,0(r3)
 8204ed0:	21000104 	addi	r4,r4,4
 8204ed4:	00c00044 	movi	r3,1
 8204ed8:	d8c02a15 	stw	r3,168(sp)
 8204edc:	d8801405 	stb	r2,80(sp)
 8204ee0:	d9002d15 	stw	r4,180(sp)
 8204ee4:	d8c02e15 	stw	r3,184(sp)
 8204ee8:	d8002915 	stw	zero,164(sp)
 8204eec:	d8003215 	stw	zero,200(sp)
 8204ef0:	dc001404 	addi	r16,sp,80
 8204ef4:	0039883a 	mov	fp,zero
 8204ef8:	003ecc06 	br	8204a2c <___svfprintf_internal_r+0x6d4>
 8204efc:	18c03fcc 	andi	r3,r3,255
 8204f00:	183e9226 	beq	r3,zero,820494c <___svfprintf_internal_r+0x5f4>
 8204f04:	d9c02785 	stb	r7,158(sp)
 8204f08:	003e9006 	br	820494c <___svfprintf_internal_r+0x5f4>
 8204f0c:	00c00044 	movi	r3,1
 8204f10:	01c00ac4 	movi	r7,43
 8204f14:	bc400007 	ldb	r17,0(r23)
 8204f18:	003d6306 	br	82044a8 <___svfprintf_internal_r+0x150>
 8204f1c:	94800814 	ori	r18,r18,32
 8204f20:	bc400007 	ldb	r17,0(r23)
 8204f24:	003d6006 	br	82044a8 <___svfprintf_internal_r+0x150>
 8204f28:	d8c02d17 	ldw	r3,180(sp)
 8204f2c:	d8002785 	stb	zero,158(sp)
 8204f30:	1c000017 	ldw	r16,0(r3)
 8204f34:	1d000104 	addi	r20,r3,4
 8204f38:	80040f26 	beq	r16,zero,8205f78 <___svfprintf_internal_r+0x1c20>
 8204f3c:	d9002917 	ldw	r4,164(sp)
 8204f40:	2003dc16 	blt	r4,zero,8205eb4 <___svfprintf_internal_r+0x1b5c>
 8204f44:	200d883a 	mov	r6,r4
 8204f48:	000b883a 	mov	r5,zero
 8204f4c:	8009883a 	mov	r4,r16
 8204f50:	da003e15 	stw	r8,248(sp)
 8204f54:	820bff40 	call	820bff4 <memchr>
 8204f58:	da003e17 	ldw	r8,248(sp)
 8204f5c:	10045826 	beq	r2,zero,82060c0 <___svfprintf_internal_r+0x1d68>
 8204f60:	1405c83a 	sub	r2,r2,r16
 8204f64:	d8802e15 	stw	r2,184(sp)
 8204f68:	1003d816 	blt	r2,zero,8205ecc <___svfprintf_internal_r+0x1b74>
 8204f6c:	df002783 	ldbu	fp,158(sp)
 8204f70:	d8802a15 	stw	r2,168(sp)
 8204f74:	dd002d15 	stw	r20,180(sp)
 8204f78:	d8002915 	stw	zero,164(sp)
 8204f7c:	d8003215 	stw	zero,200(sp)
 8204f80:	003ea306 	br	8204a10 <___svfprintf_internal_r+0x6b8>
 8204f84:	18c03fcc 	andi	r3,r3,255
 8204f88:	183f8c26 	beq	r3,zero,8204dbc <___svfprintf_internal_r+0xa64>
 8204f8c:	d9c02785 	stb	r7,158(sp)
 8204f90:	003f8a06 	br	8204dbc <___svfprintf_internal_r+0xa64>
 8204f94:	18c03fcc 	andi	r3,r3,255
 8204f98:	1805631e 	bne	r3,zero,8206528 <___svfprintf_internal_r+0x21d0>
 8204f9c:	01420974 	movhi	r5,2085
 8204fa0:	29755a04 	addi	r5,r5,-10904
 8204fa4:	d9403a15 	stw	r5,232(sp)
 8204fa8:	9080080c 	andi	r2,r18,32
 8204fac:	103f9f1e 	bne	r2,zero,8204e2c <___svfprintf_internal_r+0xad4>
 8204fb0:	9080040c 	andi	r2,r18,16
 8204fb4:	10029c26 	beq	r2,zero,8205a28 <___svfprintf_internal_r+0x16d0>
 8204fb8:	d8c02d17 	ldw	r3,180(sp)
 8204fbc:	002d883a 	mov	r22,zero
 8204fc0:	1d000017 	ldw	r20,0(r3)
 8204fc4:	18c00104 	addi	r3,r3,4
 8204fc8:	d8c02d15 	stw	r3,180(sp)
 8204fcc:	003f9c06 	br	8204e40 <___svfprintf_internal_r+0xae8>
 8204fd0:	94800054 	ori	r18,r18,1
 8204fd4:	bc400007 	ldb	r17,0(r23)
 8204fd8:	003d3306 	br	82044a8 <___svfprintf_internal_r+0x150>
 8204fdc:	38803fcc 	andi	r2,r7,255
 8204fe0:	1080201c 	xori	r2,r2,128
 8204fe4:	10bfe004 	addi	r2,r2,-128
 8204fe8:	1002971e 	bne	r2,zero,8205a48 <___svfprintf_internal_r+0x16f0>
 8204fec:	00c00044 	movi	r3,1
 8204ff0:	01c00804 	movi	r7,32
 8204ff4:	bc400007 	ldb	r17,0(r23)
 8204ff8:	003d2b06 	br	82044a8 <___svfprintf_internal_r+0x150>
 8204ffc:	18c03fcc 	andi	r3,r3,255
 8205000:	183e2326 	beq	r3,zero,8204890 <___svfprintf_internal_r+0x538>
 8205004:	d9c02785 	stb	r7,158(sp)
 8205008:	003e2106 	br	8204890 <___svfprintf_internal_r+0x538>
 820500c:	bc400007 	ldb	r17,0(r23)
 8205010:	8a430426 	beq	r17,r9,8205c24 <___svfprintf_internal_r+0x18cc>
 8205014:	94800414 	ori	r18,r18,16
 8205018:	003d2306 	br	82044a8 <___svfprintf_internal_r+0x150>
 820501c:	18c03fcc 	andi	r3,r3,255
 8205020:	18053f1e 	bne	r3,zero,8206520 <___svfprintf_internal_r+0x21c8>
 8205024:	9080080c 	andi	r2,r18,32
 8205028:	10028926 	beq	r2,zero,8205a50 <___svfprintf_internal_r+0x16f8>
 820502c:	d9402d17 	ldw	r5,180(sp)
 8205030:	d9002f17 	ldw	r4,188(sp)
 8205034:	28800017 	ldw	r2,0(r5)
 8205038:	2007d7fa 	srai	r3,r4,31
 820503c:	29400104 	addi	r5,r5,4
 8205040:	d9402d15 	stw	r5,180(sp)
 8205044:	11000015 	stw	r4,0(r2)
 8205048:	10c00115 	stw	r3,4(r2)
 820504c:	003ced06 	br	8204404 <___svfprintf_internal_r+0xac>
 8205050:	94801014 	ori	r18,r18,64
 8205054:	bc400007 	ldb	r17,0(r23)
 8205058:	003d1306 	br	82044a8 <___svfprintf_internal_r+0x150>
 820505c:	01020974 	movhi	r4,2085
 8205060:	21355a04 	addi	r4,r4,-10904
 8205064:	0039883a 	mov	fp,zero
 8205068:	d9003a15 	stw	r4,232(sp)
 820506c:	04401e04 	movi	r17,120
 8205070:	003f8206 	br	8204e7c <___svfprintf_internal_r+0xb24>
 8205074:	18c03fcc 	andi	r3,r3,255
 8205078:	1805221e 	bne	r3,zero,8206504 <___svfprintf_internal_r+0x21ac>
 820507c:	883d9526 	beq	r17,zero,82046d4 <___svfprintf_internal_r+0x37c>
 8205080:	00c00044 	movi	r3,1
 8205084:	d8c02a15 	stw	r3,168(sp)
 8205088:	dc401405 	stb	r17,80(sp)
 820508c:	d8002785 	stb	zero,158(sp)
 8205090:	003f9406 	br	8204ee4 <___svfprintf_internal_r+0xb8c>
 8205094:	01020974 	movhi	r4,2085
 8205098:	21355a04 	addi	r4,r4,-10904
 820509c:	d9003a15 	stw	r4,232(sp)
 82050a0:	d8c02d15 	stw	r3,180(sp)
 82050a4:	1025883a 	mov	r18,r2
 82050a8:	04401e04 	movi	r17,120
 82050ac:	a584b03a 	or	r2,r20,r22
 82050b0:	1000fa1e 	bne	r2,zero,820549c <___svfprintf_internal_r+0x1144>
 82050b4:	0039883a 	mov	fp,zero
 82050b8:	00800084 	movi	r2,2
 82050bc:	10803fcc 	andi	r2,r2,255
 82050c0:	00c00044 	movi	r3,1
 82050c4:	10c21626 	beq	r2,r3,8205920 <___svfprintf_internal_r+0x15c8>
 82050c8:	00c00084 	movi	r3,2
 82050cc:	10fe301e 	bne	r2,r3,8204990 <___svfprintf_internal_r+0x638>
 82050d0:	003d7606 	br	82046ac <___svfprintf_internal_r+0x354>
 82050d4:	d8c02017 	ldw	r3,128(sp)
 82050d8:	003e9506 	br	8204b30 <___svfprintf_internal_r+0x7d8>
 82050dc:	00801944 	movi	r2,101
 82050e0:	14407c0e 	bge	r2,r17,82052d4 <___svfprintf_internal_r+0xf7c>
 82050e4:	d9003617 	ldw	r4,216(sp)
 82050e8:	d9403717 	ldw	r5,220(sp)
 82050ec:	000d883a 	mov	r6,zero
 82050f0:	000f883a 	mov	r7,zero
 82050f4:	d8c03d15 	stw	r3,244(sp)
 82050f8:	da003e15 	stw	r8,248(sp)
 82050fc:	82129f80 	call	82129f8 <__eqdf2>
 8205100:	d8c03d17 	ldw	r3,244(sp)
 8205104:	da003e17 	ldw	r8,248(sp)
 8205108:	1000f51e 	bne	r2,zero,82054e0 <___svfprintf_internal_r+0x1188>
 820510c:	d8801f17 	ldw	r2,124(sp)
 8205110:	01020974 	movhi	r4,2085
 8205114:	21356104 	addi	r4,r4,-10876
 8205118:	18c00044 	addi	r3,r3,1
 820511c:	10800044 	addi	r2,r2,1
 8205120:	41000015 	stw	r4,0(r8)
 8205124:	01000044 	movi	r4,1
 8205128:	41000115 	stw	r4,4(r8)
 820512c:	d8c02015 	stw	r3,128(sp)
 8205130:	d8801f15 	stw	r2,124(sp)
 8205134:	010001c4 	movi	r4,7
 8205138:	20826616 	blt	r4,r2,8205ad4 <___svfprintf_internal_r+0x177c>
 820513c:	42000204 	addi	r8,r8,8
 8205140:	d8802617 	ldw	r2,152(sp)
 8205144:	d9403317 	ldw	r5,204(sp)
 8205148:	11400216 	blt	r2,r5,8205154 <___svfprintf_internal_r+0xdfc>
 820514c:	9080004c 	andi	r2,r18,1
 8205150:	103ed526 	beq	r2,zero,8204ca8 <___svfprintf_internal_r+0x950>
 8205154:	d8803817 	ldw	r2,224(sp)
 8205158:	d9003417 	ldw	r4,208(sp)
 820515c:	d9403817 	ldw	r5,224(sp)
 8205160:	1887883a 	add	r3,r3,r2
 8205164:	d8801f17 	ldw	r2,124(sp)
 8205168:	41000015 	stw	r4,0(r8)
 820516c:	41400115 	stw	r5,4(r8)
 8205170:	10800044 	addi	r2,r2,1
 8205174:	d8c02015 	stw	r3,128(sp)
 8205178:	d8801f15 	stw	r2,124(sp)
 820517c:	010001c4 	movi	r4,7
 8205180:	2082af16 	blt	r4,r2,8205c40 <___svfprintf_internal_r+0x18e8>
 8205184:	42000204 	addi	r8,r8,8
 8205188:	d8803317 	ldw	r2,204(sp)
 820518c:	143fffc4 	addi	r16,r2,-1
 8205190:	043ec50e 	bge	zero,r16,8204ca8 <___svfprintf_internal_r+0x950>
 8205194:	04400404 	movi	r17,16
 8205198:	d8801f17 	ldw	r2,124(sp)
 820519c:	8c00860e 	bge	r17,r16,82053b8 <___svfprintf_internal_r+0x1060>
 82051a0:	01420974 	movhi	r5,2085
 82051a4:	29756184 	addi	r5,r5,-10874
 82051a8:	d9402b15 	stw	r5,172(sp)
 82051ac:	058001c4 	movi	r22,7
 82051b0:	dd002c17 	ldw	r20,176(sp)
 82051b4:	00000306 	br	82051c4 <___svfprintf_internal_r+0xe6c>
 82051b8:	42000204 	addi	r8,r8,8
 82051bc:	843ffc04 	addi	r16,r16,-16
 82051c0:	8c00800e 	bge	r17,r16,82053c4 <___svfprintf_internal_r+0x106c>
 82051c4:	18c00404 	addi	r3,r3,16
 82051c8:	10800044 	addi	r2,r2,1
 82051cc:	45400015 	stw	r21,0(r8)
 82051d0:	44400115 	stw	r17,4(r8)
 82051d4:	d8c02015 	stw	r3,128(sp)
 82051d8:	d8801f15 	stw	r2,124(sp)
 82051dc:	b0bff60e 	bge	r22,r2,82051b8 <___svfprintf_internal_r+0xe60>
 82051e0:	d9801e04 	addi	r6,sp,120
 82051e4:	a00b883a 	mov	r5,r20
 82051e8:	9809883a 	mov	r4,r19
 82051ec:	820db840 	call	820db84 <__ssprint_r>
 82051f0:	103d3e1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82051f4:	d8c02017 	ldw	r3,128(sp)
 82051f8:	d8801f17 	ldw	r2,124(sp)
 82051fc:	da000404 	addi	r8,sp,16
 8205200:	003fee06 	br	82051bc <___svfprintf_internal_r+0xe64>
 8205204:	d9403117 	ldw	r5,196(sp)
 8205208:	d8802a17 	ldw	r2,168(sp)
 820520c:	28adc83a 	sub	r22,r5,r2
 8205210:	05be650e 	bge	zero,r22,8204ba8 <___svfprintf_internal_r+0x850>
 8205214:	07000404 	movi	fp,16
 8205218:	d8801f17 	ldw	r2,124(sp)
 820521c:	e583a20e 	bge	fp,r22,82060a8 <___svfprintf_internal_r+0x1d50>
 8205220:	01420974 	movhi	r5,2085
 8205224:	29756184 	addi	r5,r5,-10874
 8205228:	dc403015 	stw	r17,192(sp)
 820522c:	d9402b15 	stw	r5,172(sp)
 8205230:	b023883a 	mov	r17,r22
 8205234:	050001c4 	movi	r20,7
 8205238:	902d883a 	mov	r22,r18
 820523c:	8025883a 	mov	r18,r16
 8205240:	dc002c17 	ldw	r16,176(sp)
 8205244:	00000306 	br	8205254 <___svfprintf_internal_r+0xefc>
 8205248:	8c7ffc04 	addi	r17,r17,-16
 820524c:	42000204 	addi	r8,r8,8
 8205250:	e440110e 	bge	fp,r17,8205298 <___svfprintf_internal_r+0xf40>
 8205254:	18c00404 	addi	r3,r3,16
 8205258:	10800044 	addi	r2,r2,1
 820525c:	45400015 	stw	r21,0(r8)
 8205260:	47000115 	stw	fp,4(r8)
 8205264:	d8c02015 	stw	r3,128(sp)
 8205268:	d8801f15 	stw	r2,124(sp)
 820526c:	a0bff60e 	bge	r20,r2,8205248 <___svfprintf_internal_r+0xef0>
 8205270:	d9801e04 	addi	r6,sp,120
 8205274:	800b883a 	mov	r5,r16
 8205278:	9809883a 	mov	r4,r19
 820527c:	820db840 	call	820db84 <__ssprint_r>
 8205280:	103d1a1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205284:	8c7ffc04 	addi	r17,r17,-16
 8205288:	d8c02017 	ldw	r3,128(sp)
 820528c:	d8801f17 	ldw	r2,124(sp)
 8205290:	da000404 	addi	r8,sp,16
 8205294:	e47fef16 	blt	fp,r17,8205254 <___svfprintf_internal_r+0xefc>
 8205298:	9021883a 	mov	r16,r18
 820529c:	b025883a 	mov	r18,r22
 82052a0:	882d883a 	mov	r22,r17
 82052a4:	dc403017 	ldw	r17,192(sp)
 82052a8:	d9002b17 	ldw	r4,172(sp)
 82052ac:	1d87883a 	add	r3,r3,r22
 82052b0:	10800044 	addi	r2,r2,1
 82052b4:	41000015 	stw	r4,0(r8)
 82052b8:	45800115 	stw	r22,4(r8)
 82052bc:	d8c02015 	stw	r3,128(sp)
 82052c0:	d8801f15 	stw	r2,124(sp)
 82052c4:	010001c4 	movi	r4,7
 82052c8:	20819a16 	blt	r4,r2,8205934 <___svfprintf_internal_r+0x15dc>
 82052cc:	42000204 	addi	r8,r8,8
 82052d0:	003e3506 	br	8204ba8 <___svfprintf_internal_r+0x850>
 82052d4:	d9403317 	ldw	r5,204(sp)
 82052d8:	00800044 	movi	r2,1
 82052dc:	18c00044 	addi	r3,r3,1
 82052e0:	1141710e 	bge	r2,r5,82058a8 <___svfprintf_internal_r+0x1550>
 82052e4:	dc401f17 	ldw	r17,124(sp)
 82052e8:	00800044 	movi	r2,1
 82052ec:	40800115 	stw	r2,4(r8)
 82052f0:	8c400044 	addi	r17,r17,1
 82052f4:	44000015 	stw	r16,0(r8)
 82052f8:	d8c02015 	stw	r3,128(sp)
 82052fc:	dc401f15 	stw	r17,124(sp)
 8205300:	008001c4 	movi	r2,7
 8205304:	14417416 	blt	r2,r17,82058d8 <___svfprintf_internal_r+0x1580>
 8205308:	42000204 	addi	r8,r8,8
 820530c:	d8803817 	ldw	r2,224(sp)
 8205310:	d9003417 	ldw	r4,208(sp)
 8205314:	8c400044 	addi	r17,r17,1
 8205318:	10c7883a 	add	r3,r2,r3
 820531c:	40800115 	stw	r2,4(r8)
 8205320:	41000015 	stw	r4,0(r8)
 8205324:	d8c02015 	stw	r3,128(sp)
 8205328:	dc401f15 	stw	r17,124(sp)
 820532c:	008001c4 	movi	r2,7
 8205330:	14417216 	blt	r2,r17,82058fc <___svfprintf_internal_r+0x15a4>
 8205334:	45800204 	addi	r22,r8,8
 8205338:	d9003617 	ldw	r4,216(sp)
 820533c:	d9403717 	ldw	r5,220(sp)
 8205340:	000d883a 	mov	r6,zero
 8205344:	000f883a 	mov	r7,zero
 8205348:	d8c03d15 	stw	r3,244(sp)
 820534c:	82129f80 	call	82129f8 <__eqdf2>
 8205350:	d8c03d17 	ldw	r3,244(sp)
 8205354:	1000b326 	beq	r2,zero,8205624 <___svfprintf_internal_r+0x12cc>
 8205358:	d9403317 	ldw	r5,204(sp)
 820535c:	84000044 	addi	r16,r16,1
 8205360:	8c400044 	addi	r17,r17,1
 8205364:	28bfffc4 	addi	r2,r5,-1
 8205368:	1887883a 	add	r3,r3,r2
 820536c:	b0800115 	stw	r2,4(r22)
 8205370:	b4000015 	stw	r16,0(r22)
 8205374:	d8c02015 	stw	r3,128(sp)
 8205378:	dc401f15 	stw	r17,124(sp)
 820537c:	008001c4 	movi	r2,7
 8205380:	1440d216 	blt	r2,r17,82056cc <___svfprintf_internal_r+0x1374>
 8205384:	b5800204 	addi	r22,r22,8
 8205388:	d9003b17 	ldw	r4,236(sp)
 820538c:	df0022c4 	addi	fp,sp,139
 8205390:	8c400044 	addi	r17,r17,1
 8205394:	20c7883a 	add	r3,r4,r3
 8205398:	b7000015 	stw	fp,0(r22)
 820539c:	b1000115 	stw	r4,4(r22)
 82053a0:	d8c02015 	stw	r3,128(sp)
 82053a4:	dc401f15 	stw	r17,124(sp)
 82053a8:	008001c4 	movi	r2,7
 82053ac:	14400e16 	blt	r2,r17,82053e8 <___svfprintf_internal_r+0x1090>
 82053b0:	b2000204 	addi	r8,r22,8
 82053b4:	003e3c06 	br	8204ca8 <___svfprintf_internal_r+0x950>
 82053b8:	01020974 	movhi	r4,2085
 82053bc:	21356184 	addi	r4,r4,-10874
 82053c0:	d9002b15 	stw	r4,172(sp)
 82053c4:	d9002b17 	ldw	r4,172(sp)
 82053c8:	1c07883a 	add	r3,r3,r16
 82053cc:	44000115 	stw	r16,4(r8)
 82053d0:	41000015 	stw	r4,0(r8)
 82053d4:	10800044 	addi	r2,r2,1
 82053d8:	d8c02015 	stw	r3,128(sp)
 82053dc:	d8801f15 	stw	r2,124(sp)
 82053e0:	010001c4 	movi	r4,7
 82053e4:	20be2f0e 	bge	r4,r2,8204ca4 <___svfprintf_internal_r+0x94c>
 82053e8:	d9402c17 	ldw	r5,176(sp)
 82053ec:	d9801e04 	addi	r6,sp,120
 82053f0:	9809883a 	mov	r4,r19
 82053f4:	820db840 	call	820db84 <__ssprint_r>
 82053f8:	103cbc1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82053fc:	d8c02017 	ldw	r3,128(sp)
 8205400:	da000404 	addi	r8,sp,16
 8205404:	003e2806 	br	8204ca8 <___svfprintf_internal_r+0x950>
 8205408:	d9402c17 	ldw	r5,176(sp)
 820540c:	d9801e04 	addi	r6,sp,120
 8205410:	9809883a 	mov	r4,r19
 8205414:	820db840 	call	820db84 <__ssprint_r>
 8205418:	103e5f26 	beq	r2,zero,8204d98 <___svfprintf_internal_r+0xa40>
 820541c:	003cb306 	br	82046ec <___svfprintf_internal_r+0x394>
 8205420:	d9402c17 	ldw	r5,176(sp)
 8205424:	d9801e04 	addi	r6,sp,120
 8205428:	9809883a 	mov	r4,r19
 820542c:	820db840 	call	820db84 <__ssprint_r>
 8205430:	103cae1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205434:	d8c02017 	ldw	r3,128(sp)
 8205438:	da000404 	addi	r8,sp,16
 820543c:	003e0d06 	br	8204c74 <___svfprintf_internal_r+0x91c>
 8205440:	d9402c17 	ldw	r5,176(sp)
 8205444:	d9801e04 	addi	r6,sp,120
 8205448:	9809883a 	mov	r4,r19
 820544c:	820db840 	call	820db84 <__ssprint_r>
 8205450:	103ca61e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205454:	d8c02017 	ldw	r3,128(sp)
 8205458:	da000404 	addi	r8,sp,16
 820545c:	003dc106 	br	8204b64 <___svfprintf_internal_r+0x80c>
 8205460:	d9402c17 	ldw	r5,176(sp)
 8205464:	d9801e04 	addi	r6,sp,120
 8205468:	9809883a 	mov	r4,r19
 820546c:	820db840 	call	820db84 <__ssprint_r>
 8205470:	103c9e1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205474:	d8c02017 	ldw	r3,128(sp)
 8205478:	da000404 	addi	r8,sp,16
 820547c:	003dc706 	br	8204b9c <___svfprintf_internal_r+0x844>
 8205480:	d8802917 	ldw	r2,164(sp)
 8205484:	d8002785 	stb	zero,158(sp)
 8205488:	103f0816 	blt	r2,zero,82050ac <___svfprintf_internal_r+0xd54>
 820548c:	00ffdfc4 	movi	r3,-129
 8205490:	a584b03a 	or	r2,r20,r22
 8205494:	90e4703a 	and	r18,r18,r3
 8205498:	103c8126 	beq	r2,zero,82046a0 <___svfprintf_internal_r+0x348>
 820549c:	0039883a 	mov	fp,zero
 82054a0:	003e7606 	br	8204e7c <___svfprintf_internal_r+0xb24>
 82054a4:	9080040c 	andi	r2,r18,16
 82054a8:	10013d26 	beq	r2,zero,82059a0 <___svfprintf_internal_r+0x1648>
 82054ac:	d9002d17 	ldw	r4,180(sp)
 82054b0:	d9402917 	ldw	r5,164(sp)
 82054b4:	d8002785 	stb	zero,158(sp)
 82054b8:	20800104 	addi	r2,r4,4
 82054bc:	25000017 	ldw	r20,0(r4)
 82054c0:	002d883a 	mov	r22,zero
 82054c4:	28013f16 	blt	r5,zero,82059c4 <___svfprintf_internal_r+0x166c>
 82054c8:	00ffdfc4 	movi	r3,-129
 82054cc:	d8802d15 	stw	r2,180(sp)
 82054d0:	90e4703a 	and	r18,r18,r3
 82054d4:	a03d2b26 	beq	r20,zero,8204984 <___svfprintf_internal_r+0x62c>
 82054d8:	0039883a 	mov	fp,zero
 82054dc:	003d2e06 	br	8204998 <___svfprintf_internal_r+0x640>
 82054e0:	dc402617 	ldw	r17,152(sp)
 82054e4:	0441830e 	bge	zero,r17,8205af4 <___svfprintf_internal_r+0x179c>
 82054e8:	dc403217 	ldw	r17,200(sp)
 82054ec:	d8803317 	ldw	r2,204(sp)
 82054f0:	1440010e 	bge	r2,r17,82054f8 <___svfprintf_internal_r+0x11a0>
 82054f4:	1023883a 	mov	r17,r2
 82054f8:	04400a0e 	bge	zero,r17,8205524 <___svfprintf_internal_r+0x11cc>
 82054fc:	d8801f17 	ldw	r2,124(sp)
 8205500:	1c47883a 	add	r3,r3,r17
 8205504:	44000015 	stw	r16,0(r8)
 8205508:	10800044 	addi	r2,r2,1
 820550c:	44400115 	stw	r17,4(r8)
 8205510:	d8c02015 	stw	r3,128(sp)
 8205514:	d8801f15 	stw	r2,124(sp)
 8205518:	010001c4 	movi	r4,7
 820551c:	20827516 	blt	r4,r2,8205ef4 <___svfprintf_internal_r+0x1b9c>
 8205520:	42000204 	addi	r8,r8,8
 8205524:	88027b16 	blt	r17,zero,8205f14 <___svfprintf_internal_r+0x1bbc>
 8205528:	d9003217 	ldw	r4,200(sp)
 820552c:	2463c83a 	sub	r17,r4,r17
 8205530:	0440990e 	bge	zero,r17,8205798 <___svfprintf_internal_r+0x1440>
 8205534:	05800404 	movi	r22,16
 8205538:	d8801f17 	ldw	r2,124(sp)
 820553c:	b441530e 	bge	r22,r17,8205a8c <___svfprintf_internal_r+0x1734>
 8205540:	01020974 	movhi	r4,2085
 8205544:	21356184 	addi	r4,r4,-10874
 8205548:	d9002b15 	stw	r4,172(sp)
 820554c:	070001c4 	movi	fp,7
 8205550:	dd002c17 	ldw	r20,176(sp)
 8205554:	00000306 	br	8205564 <___svfprintf_internal_r+0x120c>
 8205558:	42000204 	addi	r8,r8,8
 820555c:	8c7ffc04 	addi	r17,r17,-16
 8205560:	b4414d0e 	bge	r22,r17,8205a98 <___svfprintf_internal_r+0x1740>
 8205564:	18c00404 	addi	r3,r3,16
 8205568:	10800044 	addi	r2,r2,1
 820556c:	45400015 	stw	r21,0(r8)
 8205570:	45800115 	stw	r22,4(r8)
 8205574:	d8c02015 	stw	r3,128(sp)
 8205578:	d8801f15 	stw	r2,124(sp)
 820557c:	e0bff60e 	bge	fp,r2,8205558 <___svfprintf_internal_r+0x1200>
 8205580:	d9801e04 	addi	r6,sp,120
 8205584:	a00b883a 	mov	r5,r20
 8205588:	9809883a 	mov	r4,r19
 820558c:	820db840 	call	820db84 <__ssprint_r>
 8205590:	103c561e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205594:	d8c02017 	ldw	r3,128(sp)
 8205598:	d8801f17 	ldw	r2,124(sp)
 820559c:	da000404 	addi	r8,sp,16
 82055a0:	003fee06 	br	820555c <___svfprintf_internal_r+0x1204>
 82055a4:	d9402c17 	ldw	r5,176(sp)
 82055a8:	d9801e04 	addi	r6,sp,120
 82055ac:	9809883a 	mov	r4,r19
 82055b0:	820db840 	call	820db84 <__ssprint_r>
 82055b4:	103c4d1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82055b8:	d8c02017 	ldw	r3,128(sp)
 82055bc:	df002787 	ldb	fp,158(sp)
 82055c0:	da000404 	addi	r8,sp,16
 82055c4:	003d5a06 	br	8204b30 <___svfprintf_internal_r+0x7d8>
 82055c8:	9080040c 	andi	r2,r18,16
 82055cc:	10005c26 	beq	r2,zero,8205740 <___svfprintf_internal_r+0x13e8>
 82055d0:	d9402d17 	ldw	r5,180(sp)
 82055d4:	d8c02917 	ldw	r3,164(sp)
 82055d8:	d8002785 	stb	zero,158(sp)
 82055dc:	28800104 	addi	r2,r5,4
 82055e0:	2d000017 	ldw	r20,0(r5)
 82055e4:	002d883a 	mov	r22,zero
 82055e8:	18005e16 	blt	r3,zero,8205764 <___svfprintf_internal_r+0x140c>
 82055ec:	00ffdfc4 	movi	r3,-129
 82055f0:	d8802d15 	stw	r2,180(sp)
 82055f4:	90e4703a 	and	r18,r18,r3
 82055f8:	0039883a 	mov	fp,zero
 82055fc:	a03dfe26 	beq	r20,zero,8204df8 <___svfprintf_internal_r+0xaa0>
 8205600:	00800244 	movi	r2,9
 8205604:	153cb336 	bltu	r2,r20,82048d4 <___svfprintf_internal_r+0x57c>
 8205608:	a5000c04 	addi	r20,r20,48
 820560c:	dc001dc4 	addi	r16,sp,119
 8205610:	dd001dc5 	stb	r20,119(sp)
 8205614:	d8c02817 	ldw	r3,160(sp)
 8205618:	1c07c83a 	sub	r3,r3,r16
 820561c:	d8c02e15 	stw	r3,184(sp)
 8205620:	003cf506 	br	82049f8 <___svfprintf_internal_r+0x6a0>
 8205624:	d8803317 	ldw	r2,204(sp)
 8205628:	143fffc4 	addi	r16,r2,-1
 820562c:	043f560e 	bge	zero,r16,8205388 <___svfprintf_internal_r+0x1030>
 8205630:	07000404 	movi	fp,16
 8205634:	e403530e 	bge	fp,r16,8206384 <___svfprintf_internal_r+0x202c>
 8205638:	01420974 	movhi	r5,2085
 820563c:	29756184 	addi	r5,r5,-10874
 8205640:	d9402b15 	stw	r5,172(sp)
 8205644:	01c001c4 	movi	r7,7
 8205648:	dd002c17 	ldw	r20,176(sp)
 820564c:	00000306 	br	820565c <___svfprintf_internal_r+0x1304>
 8205650:	843ffc04 	addi	r16,r16,-16
 8205654:	b5800204 	addi	r22,r22,8
 8205658:	e400130e 	bge	fp,r16,82056a8 <___svfprintf_internal_r+0x1350>
 820565c:	18c00404 	addi	r3,r3,16
 8205660:	8c400044 	addi	r17,r17,1
 8205664:	b5400015 	stw	r21,0(r22)
 8205668:	b7000115 	stw	fp,4(r22)
 820566c:	d8c02015 	stw	r3,128(sp)
 8205670:	dc401f15 	stw	r17,124(sp)
 8205674:	3c7ff60e 	bge	r7,r17,8205650 <___svfprintf_internal_r+0x12f8>
 8205678:	d9801e04 	addi	r6,sp,120
 820567c:	a00b883a 	mov	r5,r20
 8205680:	9809883a 	mov	r4,r19
 8205684:	d9c03d15 	stw	r7,244(sp)
 8205688:	820db840 	call	820db84 <__ssprint_r>
 820568c:	d9c03d17 	ldw	r7,244(sp)
 8205690:	103c161e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205694:	843ffc04 	addi	r16,r16,-16
 8205698:	d8c02017 	ldw	r3,128(sp)
 820569c:	dc401f17 	ldw	r17,124(sp)
 82056a0:	dd800404 	addi	r22,sp,16
 82056a4:	e43fed16 	blt	fp,r16,820565c <___svfprintf_internal_r+0x1304>
 82056a8:	d8802b17 	ldw	r2,172(sp)
 82056ac:	1c07883a 	add	r3,r3,r16
 82056b0:	8c400044 	addi	r17,r17,1
 82056b4:	b0800015 	stw	r2,0(r22)
 82056b8:	b4000115 	stw	r16,4(r22)
 82056bc:	d8c02015 	stw	r3,128(sp)
 82056c0:	dc401f15 	stw	r17,124(sp)
 82056c4:	008001c4 	movi	r2,7
 82056c8:	147f2e0e 	bge	r2,r17,8205384 <___svfprintf_internal_r+0x102c>
 82056cc:	d9402c17 	ldw	r5,176(sp)
 82056d0:	d9801e04 	addi	r6,sp,120
 82056d4:	9809883a 	mov	r4,r19
 82056d8:	820db840 	call	820db84 <__ssprint_r>
 82056dc:	103c031e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82056e0:	d8c02017 	ldw	r3,128(sp)
 82056e4:	dc401f17 	ldw	r17,124(sp)
 82056e8:	dd800404 	addi	r22,sp,16
 82056ec:	003f2606 	br	8205388 <___svfprintf_internal_r+0x1030>
 82056f0:	9080040c 	andi	r2,r18,16
 82056f4:	1000c326 	beq	r2,zero,8205a04 <___svfprintf_internal_r+0x16ac>
 82056f8:	d8802d17 	ldw	r2,180(sp)
 82056fc:	15000017 	ldw	r20,0(r2)
 8205700:	10800104 	addi	r2,r2,4
 8205704:	d8802d15 	stw	r2,180(sp)
 8205708:	a02dd7fa 	srai	r22,r20,31
 820570c:	b005883a 	mov	r2,r22
 8205710:	103c680e 	bge	r2,zero,82048b4 <___svfprintf_internal_r+0x55c>
 8205714:	0529c83a 	sub	r20,zero,r20
 8205718:	a004c03a 	cmpne	r2,r20,zero
 820571c:	05adc83a 	sub	r22,zero,r22
 8205720:	b0adc83a 	sub	r22,r22,r2
 8205724:	d8802917 	ldw	r2,164(sp)
 8205728:	07000b44 	movi	fp,45
 820572c:	df002785 	stb	fp,158(sp)
 8205730:	10022e16 	blt	r2,zero,8205fec <___svfprintf_internal_r+0x1c94>
 8205734:	00bfdfc4 	movi	r2,-129
 8205738:	90a4703a 	and	r18,r18,r2
 820573c:	003c6406 	br	82048d0 <___svfprintf_internal_r+0x578>
 8205740:	9080100c 	andi	r2,r18,64
 8205744:	d8002785 	stb	zero,158(sp)
 8205748:	10012526 	beq	r2,zero,8205be0 <___svfprintf_internal_r+0x1888>
 820574c:	d9002d17 	ldw	r4,180(sp)
 8205750:	d9402917 	ldw	r5,164(sp)
 8205754:	002d883a 	mov	r22,zero
 8205758:	20800104 	addi	r2,r4,4
 820575c:	2500000b 	ldhu	r20,0(r4)
 8205760:	283fa20e 	bge	r5,zero,82055ec <___svfprintf_internal_r+0x1294>
 8205764:	d8802d15 	stw	r2,180(sp)
 8205768:	0039883a 	mov	fp,zero
 820576c:	a584b03a 	or	r2,r20,r22
 8205770:	103c571e 	bne	r2,zero,82048d0 <___svfprintf_internal_r+0x578>
 8205774:	00800044 	movi	r2,1
 8205778:	003e5006 	br	82050bc <___svfprintf_internal_r+0xd64>
 820577c:	d9402c17 	ldw	r5,176(sp)
 8205780:	d9801e04 	addi	r6,sp,120
 8205784:	9809883a 	mov	r4,r19
 8205788:	820db840 	call	820db84 <__ssprint_r>
 820578c:	103bd71e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205790:	d8c02017 	ldw	r3,128(sp)
 8205794:	da000404 	addi	r8,sp,16
 8205798:	d9003217 	ldw	r4,200(sp)
 820579c:	d8802617 	ldw	r2,152(sp)
 82057a0:	d9403317 	ldw	r5,204(sp)
 82057a4:	8123883a 	add	r17,r16,r4
 82057a8:	11400216 	blt	r2,r5,82057b4 <___svfprintf_internal_r+0x145c>
 82057ac:	9100004c 	andi	r4,r18,1
 82057b0:	20000d26 	beq	r4,zero,82057e8 <___svfprintf_internal_r+0x1490>
 82057b4:	d9003817 	ldw	r4,224(sp)
 82057b8:	d9403417 	ldw	r5,208(sp)
 82057bc:	1907883a 	add	r3,r3,r4
 82057c0:	d9001f17 	ldw	r4,124(sp)
 82057c4:	41400015 	stw	r5,0(r8)
 82057c8:	d9403817 	ldw	r5,224(sp)
 82057cc:	21000044 	addi	r4,r4,1
 82057d0:	d8c02015 	stw	r3,128(sp)
 82057d4:	41400115 	stw	r5,4(r8)
 82057d8:	d9001f15 	stw	r4,124(sp)
 82057dc:	014001c4 	movi	r5,7
 82057e0:	2901dc16 	blt	r5,r4,8205f54 <___svfprintf_internal_r+0x1bfc>
 82057e4:	42000204 	addi	r8,r8,8
 82057e8:	d9003317 	ldw	r4,204(sp)
 82057ec:	8121883a 	add	r16,r16,r4
 82057f0:	2085c83a 	sub	r2,r4,r2
 82057f4:	8461c83a 	sub	r16,r16,r17
 82057f8:	1400010e 	bge	r2,r16,8205800 <___svfprintf_internal_r+0x14a8>
 82057fc:	1021883a 	mov	r16,r2
 8205800:	04000a0e 	bge	zero,r16,820582c <___svfprintf_internal_r+0x14d4>
 8205804:	d9001f17 	ldw	r4,124(sp)
 8205808:	1c07883a 	add	r3,r3,r16
 820580c:	44400015 	stw	r17,0(r8)
 8205810:	21000044 	addi	r4,r4,1
 8205814:	44000115 	stw	r16,4(r8)
 8205818:	d8c02015 	stw	r3,128(sp)
 820581c:	d9001f15 	stw	r4,124(sp)
 8205820:	014001c4 	movi	r5,7
 8205824:	2901e616 	blt	r5,r4,8205fc0 <___svfprintf_internal_r+0x1c68>
 8205828:	42000204 	addi	r8,r8,8
 820582c:	8001f616 	blt	r16,zero,8206008 <___svfprintf_internal_r+0x1cb0>
 8205830:	1421c83a 	sub	r16,r2,r16
 8205834:	043d1c0e 	bge	zero,r16,8204ca8 <___svfprintf_internal_r+0x950>
 8205838:	04400404 	movi	r17,16
 820583c:	d8801f17 	ldw	r2,124(sp)
 8205840:	8c3edd0e 	bge	r17,r16,82053b8 <___svfprintf_internal_r+0x1060>
 8205844:	01420974 	movhi	r5,2085
 8205848:	29756184 	addi	r5,r5,-10874
 820584c:	d9402b15 	stw	r5,172(sp)
 8205850:	058001c4 	movi	r22,7
 8205854:	dd002c17 	ldw	r20,176(sp)
 8205858:	00000306 	br	8205868 <___svfprintf_internal_r+0x1510>
 820585c:	42000204 	addi	r8,r8,8
 8205860:	843ffc04 	addi	r16,r16,-16
 8205864:	8c3ed70e 	bge	r17,r16,82053c4 <___svfprintf_internal_r+0x106c>
 8205868:	18c00404 	addi	r3,r3,16
 820586c:	10800044 	addi	r2,r2,1
 8205870:	45400015 	stw	r21,0(r8)
 8205874:	44400115 	stw	r17,4(r8)
 8205878:	d8c02015 	stw	r3,128(sp)
 820587c:	d8801f15 	stw	r2,124(sp)
 8205880:	b0bff60e 	bge	r22,r2,820585c <___svfprintf_internal_r+0x1504>
 8205884:	d9801e04 	addi	r6,sp,120
 8205888:	a00b883a 	mov	r5,r20
 820588c:	9809883a 	mov	r4,r19
 8205890:	820db840 	call	820db84 <__ssprint_r>
 8205894:	103b951e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205898:	d8c02017 	ldw	r3,128(sp)
 820589c:	d8801f17 	ldw	r2,124(sp)
 82058a0:	da000404 	addi	r8,sp,16
 82058a4:	003fee06 	br	8205860 <___svfprintf_internal_r+0x1508>
 82058a8:	9088703a 	and	r4,r18,r2
 82058ac:	203e8d1e 	bne	r4,zero,82052e4 <___svfprintf_internal_r+0xf8c>
 82058b0:	dc401f17 	ldw	r17,124(sp)
 82058b4:	40800115 	stw	r2,4(r8)
 82058b8:	44000015 	stw	r16,0(r8)
 82058bc:	8c400044 	addi	r17,r17,1
 82058c0:	d8c02015 	stw	r3,128(sp)
 82058c4:	dc401f15 	stw	r17,124(sp)
 82058c8:	008001c4 	movi	r2,7
 82058cc:	147f7f16 	blt	r2,r17,82056cc <___svfprintf_internal_r+0x1374>
 82058d0:	45800204 	addi	r22,r8,8
 82058d4:	003eac06 	br	8205388 <___svfprintf_internal_r+0x1030>
 82058d8:	d9402c17 	ldw	r5,176(sp)
 82058dc:	d9801e04 	addi	r6,sp,120
 82058e0:	9809883a 	mov	r4,r19
 82058e4:	820db840 	call	820db84 <__ssprint_r>
 82058e8:	103b801e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 82058ec:	d8c02017 	ldw	r3,128(sp)
 82058f0:	dc401f17 	ldw	r17,124(sp)
 82058f4:	da000404 	addi	r8,sp,16
 82058f8:	003e8406 	br	820530c <___svfprintf_internal_r+0xfb4>
 82058fc:	d9402c17 	ldw	r5,176(sp)
 8205900:	d9801e04 	addi	r6,sp,120
 8205904:	9809883a 	mov	r4,r19
 8205908:	820db840 	call	820db84 <__ssprint_r>
 820590c:	103b771e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205910:	d8c02017 	ldw	r3,128(sp)
 8205914:	dc401f17 	ldw	r17,124(sp)
 8205918:	dd800404 	addi	r22,sp,16
 820591c:	003e8606 	br	8205338 <___svfprintf_internal_r+0xfe0>
 8205920:	0029883a 	mov	r20,zero
 8205924:	a5000c04 	addi	r20,r20,48
 8205928:	dc001dc4 	addi	r16,sp,119
 820592c:	dd001dc5 	stb	r20,119(sp)
 8205930:	003f3806 	br	8205614 <___svfprintf_internal_r+0x12bc>
 8205934:	d9402c17 	ldw	r5,176(sp)
 8205938:	d9801e04 	addi	r6,sp,120
 820593c:	9809883a 	mov	r4,r19
 8205940:	820db840 	call	820db84 <__ssprint_r>
 8205944:	103b691e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205948:	d8c02017 	ldw	r3,128(sp)
 820594c:	da000404 	addi	r8,sp,16
 8205950:	003c9506 	br	8204ba8 <___svfprintf_internal_r+0x850>
 8205954:	d9003617 	ldw	r4,216(sp)
 8205958:	d9403717 	ldw	r5,220(sp)
 820595c:	da003e15 	stw	r8,248(sp)
 8205960:	820d8a40 	call	820d8a4 <__fpclassifyd>
 8205964:	da003e17 	ldw	r8,248(sp)
 8205968:	1000bd1e 	bne	r2,zero,8205c60 <___svfprintf_internal_r+0x1908>
 820596c:	008011c4 	movi	r2,71
 8205970:	14411e0e 	bge	r2,r17,8205dec <___svfprintf_internal_r+0x1a94>
 8205974:	04020974 	movhi	r16,2085
 8205978:	84355404 	addi	r16,r16,-10928
 820597c:	00c000c4 	movi	r3,3
 8205980:	00bfdfc4 	movi	r2,-129
 8205984:	d8c02a15 	stw	r3,168(sp)
 8205988:	90a4703a 	and	r18,r18,r2
 820598c:	df002783 	ldbu	fp,158(sp)
 8205990:	d8c02e15 	stw	r3,184(sp)
 8205994:	d8002915 	stw	zero,164(sp)
 8205998:	d8003215 	stw	zero,200(sp)
 820599c:	003c1c06 	br	8204a10 <___svfprintf_internal_r+0x6b8>
 82059a0:	9080100c 	andi	r2,r18,64
 82059a4:	d8002785 	stb	zero,158(sp)
 82059a8:	10009426 	beq	r2,zero,8205bfc <___svfprintf_internal_r+0x18a4>
 82059ac:	d8c02d17 	ldw	r3,180(sp)
 82059b0:	d9002917 	ldw	r4,164(sp)
 82059b4:	002d883a 	mov	r22,zero
 82059b8:	18800104 	addi	r2,r3,4
 82059bc:	1d00000b 	ldhu	r20,0(r3)
 82059c0:	203ec10e 	bge	r4,zero,82054c8 <___svfprintf_internal_r+0x1170>
 82059c4:	a586b03a 	or	r3,r20,r22
 82059c8:	d8802d15 	stw	r2,180(sp)
 82059cc:	183ec21e 	bne	r3,zero,82054d8 <___svfprintf_internal_r+0x1180>
 82059d0:	0039883a 	mov	fp,zero
 82059d4:	0005883a 	mov	r2,zero
 82059d8:	003db806 	br	82050bc <___svfprintf_internal_r+0xd64>
 82059dc:	d8802d17 	ldw	r2,180(sp)
 82059e0:	d8c02d17 	ldw	r3,180(sp)
 82059e4:	d9002d17 	ldw	r4,180(sp)
 82059e8:	10800017 	ldw	r2,0(r2)
 82059ec:	18c00117 	ldw	r3,4(r3)
 82059f0:	21000204 	addi	r4,r4,8
 82059f4:	d8803615 	stw	r2,216(sp)
 82059f8:	d8c03715 	stw	r3,220(sp)
 82059fc:	d9002d15 	stw	r4,180(sp)
 8205a00:	003b8206 	br	820480c <___svfprintf_internal_r+0x4b4>
 8205a04:	9080100c 	andi	r2,r18,64
 8205a08:	10010726 	beq	r2,zero,8205e28 <___svfprintf_internal_r+0x1ad0>
 8205a0c:	d8c02d17 	ldw	r3,180(sp)
 8205a10:	1d00000f 	ldh	r20,0(r3)
 8205a14:	18c00104 	addi	r3,r3,4
 8205a18:	d8c02d15 	stw	r3,180(sp)
 8205a1c:	a02dd7fa 	srai	r22,r20,31
 8205a20:	b005883a 	mov	r2,r22
 8205a24:	003ba206 	br	82048b0 <___svfprintf_internal_r+0x558>
 8205a28:	9080100c 	andi	r2,r18,64
 8205a2c:	10010526 	beq	r2,zero,8205e44 <___svfprintf_internal_r+0x1aec>
 8205a30:	d9002d17 	ldw	r4,180(sp)
 8205a34:	002d883a 	mov	r22,zero
 8205a38:	2500000b 	ldhu	r20,0(r4)
 8205a3c:	21000104 	addi	r4,r4,4
 8205a40:	d9002d15 	stw	r4,180(sp)
 8205a44:	003cfe06 	br	8204e40 <___svfprintf_internal_r+0xae8>
 8205a48:	bc400007 	ldb	r17,0(r23)
 8205a4c:	003a9606 	br	82044a8 <___svfprintf_internal_r+0x150>
 8205a50:	9080040c 	andi	r2,r18,16
 8205a54:	10010126 	beq	r2,zero,8205e5c <___svfprintf_internal_r+0x1b04>
 8205a58:	d9402d17 	ldw	r5,180(sp)
 8205a5c:	d8c02f17 	ldw	r3,188(sp)
 8205a60:	28800017 	ldw	r2,0(r5)
 8205a64:	29400104 	addi	r5,r5,4
 8205a68:	d9402d15 	stw	r5,180(sp)
 8205a6c:	10c00015 	stw	r3,0(r2)
 8205a70:	003a6406 	br	8204404 <___svfprintf_internal_r+0xac>
 8205a74:	d9002917 	ldw	r4,164(sp)
 8205a78:	d8002785 	stb	zero,158(sp)
 8205a7c:	203d8d16 	blt	r4,zero,82050b4 <___svfprintf_internal_r+0xd5c>
 8205a80:	00bfdfc4 	movi	r2,-129
 8205a84:	90a4703a 	and	r18,r18,r2
 8205a88:	003b0506 	br	82046a0 <___svfprintf_internal_r+0x348>
 8205a8c:	01420974 	movhi	r5,2085
 8205a90:	29756184 	addi	r5,r5,-10874
 8205a94:	d9402b15 	stw	r5,172(sp)
 8205a98:	d9402b17 	ldw	r5,172(sp)
 8205a9c:	1c47883a 	add	r3,r3,r17
 8205aa0:	10800044 	addi	r2,r2,1
 8205aa4:	41400015 	stw	r5,0(r8)
 8205aa8:	44400115 	stw	r17,4(r8)
 8205aac:	d8c02015 	stw	r3,128(sp)
 8205ab0:	d8801f15 	stw	r2,124(sp)
 8205ab4:	010001c4 	movi	r4,7
 8205ab8:	20bf3016 	blt	r4,r2,820577c <___svfprintf_internal_r+0x1424>
 8205abc:	42000204 	addi	r8,r8,8
 8205ac0:	003f3506 	br	8205798 <___svfprintf_internal_r+0x1440>
 8205ac4:	01020974 	movhi	r4,2085
 8205ac8:	21356184 	addi	r4,r4,-10874
 8205acc:	d9002b15 	stw	r4,172(sp)
 8205ad0:	003c5e06 	br	8204c4c <___svfprintf_internal_r+0x8f4>
 8205ad4:	d9402c17 	ldw	r5,176(sp)
 8205ad8:	d9801e04 	addi	r6,sp,120
 8205adc:	9809883a 	mov	r4,r19
 8205ae0:	820db840 	call	820db84 <__ssprint_r>
 8205ae4:	103b011e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205ae8:	d8c02017 	ldw	r3,128(sp)
 8205aec:	da000404 	addi	r8,sp,16
 8205af0:	003d9306 	br	8205140 <___svfprintf_internal_r+0xde8>
 8205af4:	d8801f17 	ldw	r2,124(sp)
 8205af8:	01420974 	movhi	r5,2085
 8205afc:	01000044 	movi	r4,1
 8205b00:	18c00044 	addi	r3,r3,1
 8205b04:	10800044 	addi	r2,r2,1
 8205b08:	29756104 	addi	r5,r5,-10876
 8205b0c:	41000115 	stw	r4,4(r8)
 8205b10:	41400015 	stw	r5,0(r8)
 8205b14:	d8c02015 	stw	r3,128(sp)
 8205b18:	d8801f15 	stw	r2,124(sp)
 8205b1c:	010001c4 	movi	r4,7
 8205b20:	2080b516 	blt	r4,r2,8205df8 <___svfprintf_internal_r+0x1aa0>
 8205b24:	42000204 	addi	r8,r8,8
 8205b28:	8800041e 	bne	r17,zero,8205b3c <___svfprintf_internal_r+0x17e4>
 8205b2c:	d8803317 	ldw	r2,204(sp)
 8205b30:	1000021e 	bne	r2,zero,8205b3c <___svfprintf_internal_r+0x17e4>
 8205b34:	9080004c 	andi	r2,r18,1
 8205b38:	103c5b26 	beq	r2,zero,8204ca8 <___svfprintf_internal_r+0x950>
 8205b3c:	d9003817 	ldw	r4,224(sp)
 8205b40:	d8801f17 	ldw	r2,124(sp)
 8205b44:	d9403417 	ldw	r5,208(sp)
 8205b48:	20c7883a 	add	r3,r4,r3
 8205b4c:	10800044 	addi	r2,r2,1
 8205b50:	41000115 	stw	r4,4(r8)
 8205b54:	41400015 	stw	r5,0(r8)
 8205b58:	d8c02015 	stw	r3,128(sp)
 8205b5c:	d8801f15 	stw	r2,124(sp)
 8205b60:	010001c4 	movi	r4,7
 8205b64:	20818016 	blt	r4,r2,8206168 <___svfprintf_internal_r+0x1e10>
 8205b68:	42000204 	addi	r8,r8,8
 8205b6c:	0463c83a 	sub	r17,zero,r17
 8205b70:	0440cb0e 	bge	zero,r17,8205ea0 <___svfprintf_internal_r+0x1b48>
 8205b74:	05800404 	movi	r22,16
 8205b78:	b440e80e 	bge	r22,r17,8205f1c <___svfprintf_internal_r+0x1bc4>
 8205b7c:	01420974 	movhi	r5,2085
 8205b80:	29756184 	addi	r5,r5,-10874
 8205b84:	d9402b15 	stw	r5,172(sp)
 8205b88:	070001c4 	movi	fp,7
 8205b8c:	dd002c17 	ldw	r20,176(sp)
 8205b90:	00000306 	br	8205ba0 <___svfprintf_internal_r+0x1848>
 8205b94:	42000204 	addi	r8,r8,8
 8205b98:	8c7ffc04 	addi	r17,r17,-16
 8205b9c:	b440e20e 	bge	r22,r17,8205f28 <___svfprintf_internal_r+0x1bd0>
 8205ba0:	18c00404 	addi	r3,r3,16
 8205ba4:	10800044 	addi	r2,r2,1
 8205ba8:	45400015 	stw	r21,0(r8)
 8205bac:	45800115 	stw	r22,4(r8)
 8205bb0:	d8c02015 	stw	r3,128(sp)
 8205bb4:	d8801f15 	stw	r2,124(sp)
 8205bb8:	e0bff60e 	bge	fp,r2,8205b94 <___svfprintf_internal_r+0x183c>
 8205bbc:	d9801e04 	addi	r6,sp,120
 8205bc0:	a00b883a 	mov	r5,r20
 8205bc4:	9809883a 	mov	r4,r19
 8205bc8:	820db840 	call	820db84 <__ssprint_r>
 8205bcc:	103ac71e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205bd0:	d8c02017 	ldw	r3,128(sp)
 8205bd4:	d8801f17 	ldw	r2,124(sp)
 8205bd8:	da000404 	addi	r8,sp,16
 8205bdc:	003fee06 	br	8205b98 <___svfprintf_internal_r+0x1840>
 8205be0:	d8c02d17 	ldw	r3,180(sp)
 8205be4:	d9002917 	ldw	r4,164(sp)
 8205be8:	002d883a 	mov	r22,zero
 8205bec:	18800104 	addi	r2,r3,4
 8205bf0:	1d000017 	ldw	r20,0(r3)
 8205bf4:	203e7d0e 	bge	r4,zero,82055ec <___svfprintf_internal_r+0x1294>
 8205bf8:	003eda06 	br	8205764 <___svfprintf_internal_r+0x140c>
 8205bfc:	d9402d17 	ldw	r5,180(sp)
 8205c00:	d8c02917 	ldw	r3,164(sp)
 8205c04:	002d883a 	mov	r22,zero
 8205c08:	28800104 	addi	r2,r5,4
 8205c0c:	2d000017 	ldw	r20,0(r5)
 8205c10:	183e2d0e 	bge	r3,zero,82054c8 <___svfprintf_internal_r+0x1170>
 8205c14:	003f6b06 	br	82059c4 <___svfprintf_internal_r+0x166c>
 8205c18:	d8c02d15 	stw	r3,180(sp)
 8205c1c:	0039883a 	mov	fp,zero
 8205c20:	003ed206 	br	820576c <___svfprintf_internal_r+0x1414>
 8205c24:	bc400043 	ldbu	r17,1(r23)
 8205c28:	94800814 	ori	r18,r18,32
 8205c2c:	bdc00044 	addi	r23,r23,1
 8205c30:	8c403fcc 	andi	r17,r17,255
 8205c34:	8c40201c 	xori	r17,r17,128
 8205c38:	8c7fe004 	addi	r17,r17,-128
 8205c3c:	003a1a06 	br	82044a8 <___svfprintf_internal_r+0x150>
 8205c40:	d9402c17 	ldw	r5,176(sp)
 8205c44:	d9801e04 	addi	r6,sp,120
 8205c48:	9809883a 	mov	r4,r19
 8205c4c:	820db840 	call	820db84 <__ssprint_r>
 8205c50:	103aa61e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205c54:	d8c02017 	ldw	r3,128(sp)
 8205c58:	da000404 	addi	r8,sp,16
 8205c5c:	003d4a06 	br	8205188 <___svfprintf_internal_r+0xe30>
 8205c60:	d9002917 	ldw	r4,164(sp)
 8205c64:	05bff7c4 	movi	r22,-33
 8205c68:	00bfffc4 	movi	r2,-1
 8205c6c:	8dac703a 	and	r22,r17,r22
 8205c70:	20806a26 	beq	r4,r2,8205e1c <___svfprintf_internal_r+0x1ac4>
 8205c74:	008011c4 	movi	r2,71
 8205c78:	b0813726 	beq	r22,r2,8206158 <___svfprintf_internal_r+0x1e00>
 8205c7c:	d9003717 	ldw	r4,220(sp)
 8205c80:	90c04014 	ori	r3,r18,256
 8205c84:	d8c02b15 	stw	r3,172(sp)
 8205c88:	20015d16 	blt	r4,zero,8206200 <___svfprintf_internal_r+0x1ea8>
 8205c8c:	dd003717 	ldw	r20,220(sp)
 8205c90:	d8002a05 	stb	zero,168(sp)
 8205c94:	00801984 	movi	r2,102
 8205c98:	88814026 	beq	r17,r2,820619c <___svfprintf_internal_r+0x1e44>
 8205c9c:	00801184 	movi	r2,70
 8205ca0:	88817126 	beq	r17,r2,8206268 <___svfprintf_internal_r+0x1f10>
 8205ca4:	00801144 	movi	r2,69
 8205ca8:	b0816226 	beq	r22,r2,8206234 <___svfprintf_internal_r+0x1edc>
 8205cac:	d8c02917 	ldw	r3,164(sp)
 8205cb0:	d8802104 	addi	r2,sp,132
 8205cb4:	d8800315 	stw	r2,12(sp)
 8205cb8:	d9403617 	ldw	r5,216(sp)
 8205cbc:	d8802504 	addi	r2,sp,148
 8205cc0:	d8800215 	stw	r2,8(sp)
 8205cc4:	d8802604 	addi	r2,sp,152
 8205cc8:	d8c00015 	stw	r3,0(sp)
 8205ccc:	d8800115 	stw	r2,4(sp)
 8205cd0:	01c00084 	movi	r7,2
 8205cd4:	a00d883a 	mov	r6,r20
 8205cd8:	9809883a 	mov	r4,r19
 8205cdc:	d8c03d15 	stw	r3,244(sp)
 8205ce0:	da003e15 	stw	r8,248(sp)
 8205ce4:	8208cb40 	call	8208cb4 <_dtoa_r>
 8205ce8:	1021883a 	mov	r16,r2
 8205cec:	008019c4 	movi	r2,103
 8205cf0:	d8c03d17 	ldw	r3,244(sp)
 8205cf4:	da003e17 	ldw	r8,248(sp)
 8205cf8:	8880e726 	beq	r17,r2,8206098 <___svfprintf_internal_r+0x1d40>
 8205cfc:	008011c4 	movi	r2,71
 8205d00:	8880d426 	beq	r17,r2,8206054 <___svfprintf_internal_r+0x1cfc>
 8205d04:	80f9883a 	add	fp,r16,r3
 8205d08:	d9003617 	ldw	r4,216(sp)
 8205d0c:	000d883a 	mov	r6,zero
 8205d10:	000f883a 	mov	r7,zero
 8205d14:	a00b883a 	mov	r5,r20
 8205d18:	da003e15 	stw	r8,248(sp)
 8205d1c:	82129f80 	call	82129f8 <__eqdf2>
 8205d20:	da003e17 	ldw	r8,248(sp)
 8205d24:	1000e426 	beq	r2,zero,82060b8 <___svfprintf_internal_r+0x1d60>
 8205d28:	d8802117 	ldw	r2,132(sp)
 8205d2c:	1700062e 	bgeu	r2,fp,8205d48 <___svfprintf_internal_r+0x19f0>
 8205d30:	01000c04 	movi	r4,48
 8205d34:	10c00044 	addi	r3,r2,1
 8205d38:	d8c02115 	stw	r3,132(sp)
 8205d3c:	11000005 	stb	r4,0(r2)
 8205d40:	d8802117 	ldw	r2,132(sp)
 8205d44:	173ffb36 	bltu	r2,fp,8205d34 <___svfprintf_internal_r+0x19dc>
 8205d48:	1405c83a 	sub	r2,r2,r16
 8205d4c:	d8803315 	stw	r2,204(sp)
 8205d50:	008011c4 	movi	r2,71
 8205d54:	b080c526 	beq	r22,r2,820606c <___svfprintf_internal_r+0x1d14>
 8205d58:	00801944 	movi	r2,101
 8205d5c:	1441d90e 	bge	r2,r17,82064c4 <___svfprintf_internal_r+0x216c>
 8205d60:	d8c02617 	ldw	r3,152(sp)
 8205d64:	00801984 	movi	r2,102
 8205d68:	d8c03215 	stw	r3,200(sp)
 8205d6c:	88813426 	beq	r17,r2,8206240 <___svfprintf_internal_r+0x1ee8>
 8205d70:	d8c03217 	ldw	r3,200(sp)
 8205d74:	d9003317 	ldw	r4,204(sp)
 8205d78:	19012516 	blt	r3,r4,8206210 <___svfprintf_internal_r+0x1eb8>
 8205d7c:	9480004c 	andi	r18,r18,1
 8205d80:	9001841e 	bne	r18,zero,8206394 <___svfprintf_internal_r+0x203c>
 8205d84:	1805883a 	mov	r2,r3
 8205d88:	1801cc16 	blt	r3,zero,82064bc <___svfprintf_internal_r+0x2164>
 8205d8c:	d8c03217 	ldw	r3,200(sp)
 8205d90:	044019c4 	movi	r17,103
 8205d94:	d8c02e15 	stw	r3,184(sp)
 8205d98:	df002a07 	ldb	fp,168(sp)
 8205d9c:	e000a61e 	bne	fp,zero,8206038 <___svfprintf_internal_r+0x1ce0>
 8205da0:	df002783 	ldbu	fp,158(sp)
 8205da4:	d8802a15 	stw	r2,168(sp)
 8205da8:	dc802b17 	ldw	r18,172(sp)
 8205dac:	d8002915 	stw	zero,164(sp)
 8205db0:	003b1706 	br	8204a10 <___svfprintf_internal_r+0x6b8>
 8205db4:	04020974 	movhi	r16,2085
 8205db8:	84355104 	addi	r16,r16,-10940
 8205dbc:	003aa606 	br	8204858 <___svfprintf_internal_r+0x500>
 8205dc0:	d9003917 	ldw	r4,228(sp)
 8205dc4:	04001004 	movi	r16,64
 8205dc8:	800b883a 	mov	r5,r16
 8205dcc:	820b7e80 	call	820b7e8 <_malloc_r>
 8205dd0:	d9002c17 	ldw	r4,176(sp)
 8205dd4:	20800015 	stw	r2,0(r4)
 8205dd8:	20800415 	stw	r2,16(r4)
 8205ddc:	1001cb26 	beq	r2,zero,820650c <___svfprintf_internal_r+0x21b4>
 8205de0:	d8802c17 	ldw	r2,176(sp)
 8205de4:	14000515 	stw	r16,20(r2)
 8205de8:	00397606 	br	82043c4 <___svfprintf_internal_r+0x6c>
 8205dec:	04020974 	movhi	r16,2085
 8205df0:	84355304 	addi	r16,r16,-10932
 8205df4:	003ee106 	br	820597c <___svfprintf_internal_r+0x1624>
 8205df8:	d9402c17 	ldw	r5,176(sp)
 8205dfc:	d9801e04 	addi	r6,sp,120
 8205e00:	9809883a 	mov	r4,r19
 8205e04:	820db840 	call	820db84 <__ssprint_r>
 8205e08:	103a381e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205e0c:	dc402617 	ldw	r17,152(sp)
 8205e10:	d8c02017 	ldw	r3,128(sp)
 8205e14:	da000404 	addi	r8,sp,16
 8205e18:	003f4306 	br	8205b28 <___svfprintf_internal_r+0x17d0>
 8205e1c:	01400184 	movi	r5,6
 8205e20:	d9402915 	stw	r5,164(sp)
 8205e24:	003f9506 	br	8205c7c <___svfprintf_internal_r+0x1924>
 8205e28:	d9002d17 	ldw	r4,180(sp)
 8205e2c:	25000017 	ldw	r20,0(r4)
 8205e30:	21000104 	addi	r4,r4,4
 8205e34:	d9002d15 	stw	r4,180(sp)
 8205e38:	a02dd7fa 	srai	r22,r20,31
 8205e3c:	b005883a 	mov	r2,r22
 8205e40:	003a9b06 	br	82048b0 <___svfprintf_internal_r+0x558>
 8205e44:	d9402d17 	ldw	r5,180(sp)
 8205e48:	002d883a 	mov	r22,zero
 8205e4c:	2d000017 	ldw	r20,0(r5)
 8205e50:	29400104 	addi	r5,r5,4
 8205e54:	d9402d15 	stw	r5,180(sp)
 8205e58:	003bf906 	br	8204e40 <___svfprintf_internal_r+0xae8>
 8205e5c:	9480100c 	andi	r18,r18,64
 8205e60:	90006e26 	beq	r18,zero,820601c <___svfprintf_internal_r+0x1cc4>
 8205e64:	d9002d17 	ldw	r4,180(sp)
 8205e68:	d9402f17 	ldw	r5,188(sp)
 8205e6c:	20800017 	ldw	r2,0(r4)
 8205e70:	21000104 	addi	r4,r4,4
 8205e74:	d9002d15 	stw	r4,180(sp)
 8205e78:	1140000d 	sth	r5,0(r2)
 8205e7c:	00396106 	br	8204404 <___svfprintf_internal_r+0xac>
 8205e80:	d9402c17 	ldw	r5,176(sp)
 8205e84:	d9801e04 	addi	r6,sp,120
 8205e88:	9809883a 	mov	r4,r19
 8205e8c:	820db840 	call	820db84 <__ssprint_r>
 8205e90:	103a161e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205e94:	d8c02017 	ldw	r3,128(sp)
 8205e98:	d8801f17 	ldw	r2,124(sp)
 8205e9c:	da000404 	addi	r8,sp,16
 8205ea0:	d9403317 	ldw	r5,204(sp)
 8205ea4:	10800044 	addi	r2,r2,1
 8205ea8:	44000015 	stw	r16,0(r8)
 8205eac:	28c7883a 	add	r3,r5,r3
 8205eb0:	003b7706 	br	8204c90 <___svfprintf_internal_r+0x938>
 8205eb4:	8009883a 	mov	r4,r16
 8205eb8:	da003e15 	stw	r8,248(sp)
 8205ebc:	8203a5c0 	call	8203a5c <strlen>
 8205ec0:	d8802e15 	stw	r2,184(sp)
 8205ec4:	da003e17 	ldw	r8,248(sp)
 8205ec8:	103c280e 	bge	r2,zero,8204f6c <___svfprintf_internal_r+0xc14>
 8205ecc:	0005883a 	mov	r2,zero
 8205ed0:	003c2606 	br	8204f6c <___svfprintf_internal_r+0xc14>
 8205ed4:	00bfffc4 	movi	r2,-1
 8205ed8:	003a0906 	br	8204700 <___svfprintf_internal_r+0x3a8>
 8205edc:	01020974 	movhi	r4,2085
 8205ee0:	21356584 	addi	r4,r4,-10858
 8205ee4:	d9003515 	stw	r4,212(sp)
 8205ee8:	003b0606 	br	8204b04 <___svfprintf_internal_r+0x7ac>
 8205eec:	013fffc4 	movi	r4,-1
 8205ef0:	003a2706 	br	8204790 <___svfprintf_internal_r+0x438>
 8205ef4:	d9402c17 	ldw	r5,176(sp)
 8205ef8:	d9801e04 	addi	r6,sp,120
 8205efc:	9809883a 	mov	r4,r19
 8205f00:	820db840 	call	820db84 <__ssprint_r>
 8205f04:	1039f91e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205f08:	d8c02017 	ldw	r3,128(sp)
 8205f0c:	da000404 	addi	r8,sp,16
 8205f10:	003d8406 	br	8205524 <___svfprintf_internal_r+0x11cc>
 8205f14:	0023883a 	mov	r17,zero
 8205f18:	003d8306 	br	8205528 <___svfprintf_internal_r+0x11d0>
 8205f1c:	01020974 	movhi	r4,2085
 8205f20:	21356184 	addi	r4,r4,-10874
 8205f24:	d9002b15 	stw	r4,172(sp)
 8205f28:	d9002b17 	ldw	r4,172(sp)
 8205f2c:	1c47883a 	add	r3,r3,r17
 8205f30:	10800044 	addi	r2,r2,1
 8205f34:	41000015 	stw	r4,0(r8)
 8205f38:	44400115 	stw	r17,4(r8)
 8205f3c:	d8c02015 	stw	r3,128(sp)
 8205f40:	d8801f15 	stw	r2,124(sp)
 8205f44:	010001c4 	movi	r4,7
 8205f48:	20bfcd16 	blt	r4,r2,8205e80 <___svfprintf_internal_r+0x1b28>
 8205f4c:	42000204 	addi	r8,r8,8
 8205f50:	003fd306 	br	8205ea0 <___svfprintf_internal_r+0x1b48>
 8205f54:	d9402c17 	ldw	r5,176(sp)
 8205f58:	d9801e04 	addi	r6,sp,120
 8205f5c:	9809883a 	mov	r4,r19
 8205f60:	820db840 	call	820db84 <__ssprint_r>
 8205f64:	1039e11e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205f68:	d8802617 	ldw	r2,152(sp)
 8205f6c:	d8c02017 	ldw	r3,128(sp)
 8205f70:	da000404 	addi	r8,sp,16
 8205f74:	003e1c06 	br	82057e8 <___svfprintf_internal_r+0x1490>
 8205f78:	d8802917 	ldw	r2,164(sp)
 8205f7c:	00c00184 	movi	r3,6
 8205f80:	1880012e 	bgeu	r3,r2,8205f88 <___svfprintf_internal_r+0x1c30>
 8205f84:	1805883a 	mov	r2,r3
 8205f88:	d8802e15 	stw	r2,184(sp)
 8205f8c:	1000f316 	blt	r2,zero,820635c <___svfprintf_internal_r+0x2004>
 8205f90:	04020974 	movhi	r16,2085
 8205f94:	d8802a15 	stw	r2,168(sp)
 8205f98:	dd002d15 	stw	r20,180(sp)
 8205f9c:	d8002915 	stw	zero,164(sp)
 8205fa0:	d8003215 	stw	zero,200(sp)
 8205fa4:	84355f04 	addi	r16,r16,-10884
 8205fa8:	0039883a 	mov	fp,zero
 8205fac:	003a9f06 	br	8204a2c <___svfprintf_internal_r+0x6d4>
 8205fb0:	01020974 	movhi	r4,2085
 8205fb4:	21356584 	addi	r4,r4,-10858
 8205fb8:	d9003515 	stw	r4,212(sp)
 8205fbc:	003b5f06 	br	8204d3c <___svfprintf_internal_r+0x9e4>
 8205fc0:	d9402c17 	ldw	r5,176(sp)
 8205fc4:	d9801e04 	addi	r6,sp,120
 8205fc8:	9809883a 	mov	r4,r19
 8205fcc:	820db840 	call	820db84 <__ssprint_r>
 8205fd0:	1039c61e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 8205fd4:	d8802617 	ldw	r2,152(sp)
 8205fd8:	d9403317 	ldw	r5,204(sp)
 8205fdc:	d8c02017 	ldw	r3,128(sp)
 8205fe0:	da000404 	addi	r8,sp,16
 8205fe4:	2885c83a 	sub	r2,r5,r2
 8205fe8:	003e1006 	br	820582c <___svfprintf_internal_r+0x14d4>
 8205fec:	00800044 	movi	r2,1
 8205ff0:	10803fcc 	andi	r2,r2,255
 8205ff4:	00c00044 	movi	r3,1
 8205ff8:	10fa3526 	beq	r2,r3,82048d0 <___svfprintf_internal_r+0x578>
 8205ffc:	00c00084 	movi	r3,2
 8206000:	10fb9e26 	beq	r2,r3,8204e7c <___svfprintf_internal_r+0xb24>
 8206004:	003a6406 	br	8204998 <___svfprintf_internal_r+0x640>
 8206008:	0021883a 	mov	r16,zero
 820600c:	003e0806 	br	8205830 <___svfprintf_internal_r+0x14d8>
 8206010:	07000b44 	movi	fp,45
 8206014:	df002785 	stb	fp,158(sp)
 8206018:	003a0b06 	br	8204848 <___svfprintf_internal_r+0x4f0>
 820601c:	d8c02d17 	ldw	r3,180(sp)
 8206020:	d9002f17 	ldw	r4,188(sp)
 8206024:	18800017 	ldw	r2,0(r3)
 8206028:	18c00104 	addi	r3,r3,4
 820602c:	d8c02d15 	stw	r3,180(sp)
 8206030:	11000015 	stw	r4,0(r2)
 8206034:	0038f306 	br	8204404 <___svfprintf_internal_r+0xac>
 8206038:	00c00b44 	movi	r3,45
 820603c:	d8c02785 	stb	r3,158(sp)
 8206040:	d8802a15 	stw	r2,168(sp)
 8206044:	dc802b17 	ldw	r18,172(sp)
 8206048:	d8002915 	stw	zero,164(sp)
 820604c:	07000b44 	movi	fp,45
 8206050:	003a7306 	br	8204a20 <___svfprintf_internal_r+0x6c8>
 8206054:	9080004c 	andi	r2,r18,1
 8206058:	1000941e 	bne	r2,zero,82062ac <___svfprintf_internal_r+0x1f54>
 820605c:	d8802117 	ldw	r2,132(sp)
 8206060:	1405c83a 	sub	r2,r2,r16
 8206064:	d8803315 	stw	r2,204(sp)
 8206068:	b441161e 	bne	r22,r17,82064c4 <___svfprintf_internal_r+0x216c>
 820606c:	dd802617 	ldw	r22,152(sp)
 8206070:	00bfff44 	movi	r2,-3
 8206074:	b0801a16 	blt	r22,r2,82060e0 <___svfprintf_internal_r+0x1d88>
 8206078:	d9402917 	ldw	r5,164(sp)
 820607c:	2d801816 	blt	r5,r22,82060e0 <___svfprintf_internal_r+0x1d88>
 8206080:	dd803215 	stw	r22,200(sp)
 8206084:	003f3a06 	br	8205d70 <___svfprintf_internal_r+0x1a18>
 8206088:	1025883a 	mov	r18,r2
 820608c:	0039883a 	mov	fp,zero
 8206090:	00800084 	movi	r2,2
 8206094:	003fd606 	br	8205ff0 <___svfprintf_internal_r+0x1c98>
 8206098:	9080004c 	andi	r2,r18,1
 820609c:	103f191e 	bne	r2,zero,8205d04 <___svfprintf_internal_r+0x19ac>
 82060a0:	d8802117 	ldw	r2,132(sp)
 82060a4:	003f2806 	br	8205d48 <___svfprintf_internal_r+0x19f0>
 82060a8:	01020974 	movhi	r4,2085
 82060ac:	21356184 	addi	r4,r4,-10874
 82060b0:	d9002b15 	stw	r4,172(sp)
 82060b4:	003c7c06 	br	82052a8 <___svfprintf_internal_r+0xf50>
 82060b8:	e005883a 	mov	r2,fp
 82060bc:	003f2206 	br	8205d48 <___svfprintf_internal_r+0x19f0>
 82060c0:	d9402917 	ldw	r5,164(sp)
 82060c4:	df002783 	ldbu	fp,158(sp)
 82060c8:	dd002d15 	stw	r20,180(sp)
 82060cc:	d9402a15 	stw	r5,168(sp)
 82060d0:	d9402e15 	stw	r5,184(sp)
 82060d4:	d8002915 	stw	zero,164(sp)
 82060d8:	d8003215 	stw	zero,200(sp)
 82060dc:	003a4c06 	br	8204a10 <___svfprintf_internal_r+0x6b8>
 82060e0:	8c7fff84 	addi	r17,r17,-2
 82060e4:	b5bfffc4 	addi	r22,r22,-1
 82060e8:	dd802615 	stw	r22,152(sp)
 82060ec:	dc4022c5 	stb	r17,139(sp)
 82060f0:	b000c316 	blt	r22,zero,8206400 <___svfprintf_internal_r+0x20a8>
 82060f4:	00800ac4 	movi	r2,43
 82060f8:	d8802305 	stb	r2,140(sp)
 82060fc:	00800244 	movi	r2,9
 8206100:	15806e16 	blt	r2,r22,82062bc <___svfprintf_internal_r+0x1f64>
 8206104:	00800c04 	movi	r2,48
 8206108:	b5800c04 	addi	r22,r22,48
 820610c:	d8802345 	stb	r2,141(sp)
 8206110:	dd802385 	stb	r22,142(sp)
 8206114:	d88023c4 	addi	r2,sp,143
 8206118:	df0022c4 	addi	fp,sp,139
 820611c:	d8c03317 	ldw	r3,204(sp)
 8206120:	1739c83a 	sub	fp,r2,fp
 8206124:	d9003317 	ldw	r4,204(sp)
 8206128:	e0c7883a 	add	r3,fp,r3
 820612c:	df003b15 	stw	fp,236(sp)
 8206130:	d8c02e15 	stw	r3,184(sp)
 8206134:	00800044 	movi	r2,1
 8206138:	1100b70e 	bge	r2,r4,8206418 <___svfprintf_internal_r+0x20c0>
 820613c:	d8c02e17 	ldw	r3,184(sp)
 8206140:	18c00044 	addi	r3,r3,1
 8206144:	d8c02e15 	stw	r3,184(sp)
 8206148:	1805883a 	mov	r2,r3
 820614c:	1800b016 	blt	r3,zero,8206410 <___svfprintf_internal_r+0x20b8>
 8206150:	d8003215 	stw	zero,200(sp)
 8206154:	003f1006 	br	8205d98 <___svfprintf_internal_r+0x1a40>
 8206158:	d8802917 	ldw	r2,164(sp)
 820615c:	103ec71e 	bne	r2,zero,8205c7c <___svfprintf_internal_r+0x1924>
 8206160:	dc002915 	stw	r16,164(sp)
 8206164:	003ec506 	br	8205c7c <___svfprintf_internal_r+0x1924>
 8206168:	d9402c17 	ldw	r5,176(sp)
 820616c:	d9801e04 	addi	r6,sp,120
 8206170:	9809883a 	mov	r4,r19
 8206174:	820db840 	call	820db84 <__ssprint_r>
 8206178:	10395c1e 	bne	r2,zero,82046ec <___svfprintf_internal_r+0x394>
 820617c:	dc402617 	ldw	r17,152(sp)
 8206180:	d8c02017 	ldw	r3,128(sp)
 8206184:	d8801f17 	ldw	r2,124(sp)
 8206188:	da000404 	addi	r8,sp,16
 820618c:	003e7706 	br	8205b6c <___svfprintf_internal_r+0x1814>
 8206190:	582f883a 	mov	r23,r11
 8206194:	d8002915 	stw	zero,164(sp)
 8206198:	0038c406 	br	82044ac <___svfprintf_internal_r+0x154>
 820619c:	d8c02917 	ldw	r3,164(sp)
 82061a0:	d8802104 	addi	r2,sp,132
 82061a4:	d8800315 	stw	r2,12(sp)
 82061a8:	d9403617 	ldw	r5,216(sp)
 82061ac:	d8802504 	addi	r2,sp,148
 82061b0:	d8800215 	stw	r2,8(sp)
 82061b4:	d8802604 	addi	r2,sp,152
 82061b8:	d8c00015 	stw	r3,0(sp)
 82061bc:	9809883a 	mov	r4,r19
 82061c0:	d8800115 	stw	r2,4(sp)
 82061c4:	01c000c4 	movi	r7,3
 82061c8:	a00d883a 	mov	r6,r20
 82061cc:	da003e15 	stw	r8,248(sp)
 82061d0:	8208cb40 	call	8208cb4 <_dtoa_r>
 82061d4:	d9002917 	ldw	r4,164(sp)
 82061d8:	da003e17 	ldw	r8,248(sp)
 82061dc:	1021883a 	mov	r16,r2
 82061e0:	1139883a 	add	fp,r2,r4
 82061e4:	2007883a 	mov	r3,r4
 82061e8:	81000007 	ldb	r4,0(r16)
 82061ec:	00800c04 	movi	r2,48
 82061f0:	20806f26 	beq	r4,r2,82063b0 <___svfprintf_internal_r+0x2058>
 82061f4:	d8c02617 	ldw	r3,152(sp)
 82061f8:	e0f9883a 	add	fp,fp,r3
 82061fc:	003ec206 	br	8205d08 <___svfprintf_internal_r+0x19b0>
 8206200:	00c00b44 	movi	r3,45
 8206204:	2520003c 	xorhi	r20,r4,32768
 8206208:	d8c02a05 	stb	r3,168(sp)
 820620c:	003ea106 	br	8205c94 <___svfprintf_internal_r+0x193c>
 8206210:	d8c03217 	ldw	r3,200(sp)
 8206214:	00c0890e 	bge	zero,r3,820643c <___svfprintf_internal_r+0x20e4>
 8206218:	00800044 	movi	r2,1
 820621c:	d9003317 	ldw	r4,204(sp)
 8206220:	1105883a 	add	r2,r2,r4
 8206224:	d8802e15 	stw	r2,184(sp)
 8206228:	10005f16 	blt	r2,zero,82063a8 <___svfprintf_internal_r+0x2050>
 820622c:	044019c4 	movi	r17,103
 8206230:	003ed906 	br	8205d98 <___svfprintf_internal_r+0x1a40>
 8206234:	d9002917 	ldw	r4,164(sp)
 8206238:	20c00044 	addi	r3,r4,1
 820623c:	003e9c06 	br	8205cb0 <___svfprintf_internal_r+0x1958>
 8206240:	d9002917 	ldw	r4,164(sp)
 8206244:	00c0680e 	bge	zero,r3,82063e8 <___svfprintf_internal_r+0x2090>
 8206248:	2000461e 	bne	r4,zero,8206364 <___svfprintf_internal_r+0x200c>
 820624c:	9480004c 	andi	r18,r18,1
 8206250:	9000441e 	bne	r18,zero,8206364 <___svfprintf_internal_r+0x200c>
 8206254:	1805883a 	mov	r2,r3
 8206258:	1800a016 	blt	r3,zero,82064dc <___svfprintf_internal_r+0x2184>
 820625c:	d8c03217 	ldw	r3,200(sp)
 8206260:	d8c02e15 	stw	r3,184(sp)
 8206264:	003ecc06 	br	8205d98 <___svfprintf_internal_r+0x1a40>
 8206268:	d9402917 	ldw	r5,164(sp)
 820626c:	d8802104 	addi	r2,sp,132
 8206270:	d8800315 	stw	r2,12(sp)
 8206274:	d9400015 	stw	r5,0(sp)
 8206278:	d8802504 	addi	r2,sp,148
 820627c:	d9403617 	ldw	r5,216(sp)
 8206280:	d8800215 	stw	r2,8(sp)
 8206284:	d8802604 	addi	r2,sp,152
 8206288:	d8800115 	stw	r2,4(sp)
 820628c:	01c000c4 	movi	r7,3
 8206290:	a00d883a 	mov	r6,r20
 8206294:	9809883a 	mov	r4,r19
 8206298:	da003e15 	stw	r8,248(sp)
 820629c:	8208cb40 	call	8208cb4 <_dtoa_r>
 82062a0:	d8c02917 	ldw	r3,164(sp)
 82062a4:	da003e17 	ldw	r8,248(sp)
 82062a8:	1021883a 	mov	r16,r2
 82062ac:	00801184 	movi	r2,70
 82062b0:	80f9883a 	add	fp,r16,r3
 82062b4:	88bfcc26 	beq	r17,r2,82061e8 <___svfprintf_internal_r+0x1e90>
 82062b8:	003e9306 	br	8205d08 <___svfprintf_internal_r+0x19b0>
 82062bc:	df0022c4 	addi	fp,sp,139
 82062c0:	dc002915 	stw	r16,164(sp)
 82062c4:	9829883a 	mov	r20,r19
 82062c8:	e021883a 	mov	r16,fp
 82062cc:	4027883a 	mov	r19,r8
 82062d0:	b009883a 	mov	r4,r22
 82062d4:	01400284 	movi	r5,10
 82062d8:	82026980 	call	8202698 <__modsi3>
 82062dc:	10800c04 	addi	r2,r2,48
 82062e0:	843fffc4 	addi	r16,r16,-1
 82062e4:	b009883a 	mov	r4,r22
 82062e8:	01400284 	movi	r5,10
 82062ec:	80800005 	stb	r2,0(r16)
 82062f0:	82026140 	call	8202614 <__divsi3>
 82062f4:	102d883a 	mov	r22,r2
 82062f8:	00800244 	movi	r2,9
 82062fc:	15bff416 	blt	r2,r22,82062d0 <___svfprintf_internal_r+0x1f78>
 8206300:	9811883a 	mov	r8,r19
 8206304:	b0800c04 	addi	r2,r22,48
 8206308:	a027883a 	mov	r19,r20
 820630c:	8029883a 	mov	r20,r16
 8206310:	a17fffc4 	addi	r5,r20,-1
 8206314:	a0bfffc5 	stb	r2,-1(r20)
 8206318:	dc002917 	ldw	r16,164(sp)
 820631c:	2f00752e 	bgeu	r5,fp,82064f4 <___svfprintf_internal_r+0x219c>
 8206320:	d9c02384 	addi	r7,sp,142
 8206324:	3d0fc83a 	sub	r7,r7,r20
 8206328:	d9002344 	addi	r4,sp,141
 820632c:	e1cf883a 	add	r7,fp,r7
 8206330:	00000106 	br	8206338 <___svfprintf_internal_r+0x1fe0>
 8206334:	28800003 	ldbu	r2,0(r5)
 8206338:	20800005 	stb	r2,0(r4)
 820633c:	21000044 	addi	r4,r4,1
 8206340:	29400044 	addi	r5,r5,1
 8206344:	21fffb1e 	bne	r4,r7,8206334 <___svfprintf_internal_r+0x1fdc>
 8206348:	d8802304 	addi	r2,sp,140
 820634c:	1505c83a 	sub	r2,r2,r20
 8206350:	d8c02344 	addi	r3,sp,141
 8206354:	1885883a 	add	r2,r3,r2
 8206358:	003f7006 	br	820611c <___svfprintf_internal_r+0x1dc4>
 820635c:	0005883a 	mov	r2,zero
 8206360:	003f0b06 	br	8205f90 <___svfprintf_internal_r+0x1c38>
 8206364:	d9002917 	ldw	r4,164(sp)
 8206368:	d8c03217 	ldw	r3,200(sp)
 820636c:	20800044 	addi	r2,r4,1
 8206370:	1885883a 	add	r2,r3,r2
 8206374:	d8802e15 	stw	r2,184(sp)
 8206378:	103e870e 	bge	r2,zero,8205d98 <___svfprintf_internal_r+0x1a40>
 820637c:	0005883a 	mov	r2,zero
 8206380:	003e8506 	br	8205d98 <___svfprintf_internal_r+0x1a40>
 8206384:	01020974 	movhi	r4,2085
 8206388:	21356184 	addi	r4,r4,-10874
 820638c:	d9002b15 	stw	r4,172(sp)
 8206390:	003cc506 	br	82056a8 <___svfprintf_internal_r+0x1350>
 8206394:	d8c03217 	ldw	r3,200(sp)
 8206398:	18c00044 	addi	r3,r3,1
 820639c:	d8c02e15 	stw	r3,184(sp)
 82063a0:	1805883a 	mov	r2,r3
 82063a4:	183fa10e 	bge	r3,zero,820622c <___svfprintf_internal_r+0x1ed4>
 82063a8:	0005883a 	mov	r2,zero
 82063ac:	003f9f06 	br	820622c <___svfprintf_internal_r+0x1ed4>
 82063b0:	d9003617 	ldw	r4,216(sp)
 82063b4:	000d883a 	mov	r6,zero
 82063b8:	000f883a 	mov	r7,zero
 82063bc:	a00b883a 	mov	r5,r20
 82063c0:	d8c03d15 	stw	r3,244(sp)
 82063c4:	da003e15 	stw	r8,248(sp)
 82063c8:	82129f80 	call	82129f8 <__eqdf2>
 82063cc:	d8c03d17 	ldw	r3,244(sp)
 82063d0:	da003e17 	ldw	r8,248(sp)
 82063d4:	103f8726 	beq	r2,zero,82061f4 <___svfprintf_internal_r+0x1e9c>
 82063d8:	00800044 	movi	r2,1
 82063dc:	10c7c83a 	sub	r3,r2,r3
 82063e0:	d8c02615 	stw	r3,152(sp)
 82063e4:	003f8406 	br	82061f8 <___svfprintf_internal_r+0x1ea0>
 82063e8:	20000e1e 	bne	r4,zero,8206424 <___svfprintf_internal_r+0x20cc>
 82063ec:	9480004c 	andi	r18,r18,1
 82063f0:	90000c1e 	bne	r18,zero,8206424 <___svfprintf_internal_r+0x20cc>
 82063f4:	00800044 	movi	r2,1
 82063f8:	d8802e15 	stw	r2,184(sp)
 82063fc:	003e6606 	br	8205d98 <___svfprintf_internal_r+0x1a40>
 8206400:	00800b44 	movi	r2,45
 8206404:	05adc83a 	sub	r22,zero,r22
 8206408:	d8802305 	stb	r2,140(sp)
 820640c:	003f3b06 	br	82060fc <___svfprintf_internal_r+0x1da4>
 8206410:	0005883a 	mov	r2,zero
 8206414:	003f4e06 	br	8206150 <___svfprintf_internal_r+0x1df8>
 8206418:	90a4703a 	and	r18,r18,r2
 820641c:	903f4a26 	beq	r18,zero,8206148 <___svfprintf_internal_r+0x1df0>
 8206420:	003f4606 	br	820613c <___svfprintf_internal_r+0x1de4>
 8206424:	d8c02917 	ldw	r3,164(sp)
 8206428:	18c00084 	addi	r3,r3,2
 820642c:	d8c02e15 	stw	r3,184(sp)
 8206430:	1805883a 	mov	r2,r3
 8206434:	183e580e 	bge	r3,zero,8205d98 <___svfprintf_internal_r+0x1a40>
 8206438:	003fd006 	br	820637c <___svfprintf_internal_r+0x2024>
 820643c:	00800084 	movi	r2,2
 8206440:	10c5c83a 	sub	r2,r2,r3
 8206444:	003f7506 	br	820621c <___svfprintf_internal_r+0x1ec4>
 8206448:	d8802d17 	ldw	r2,180(sp)
 820644c:	d9002d17 	ldw	r4,180(sp)
 8206450:	bc400043 	ldbu	r17,1(r23)
 8206454:	10800017 	ldw	r2,0(r2)
 8206458:	582f883a 	mov	r23,r11
 820645c:	d8802915 	stw	r2,164(sp)
 8206460:	20800104 	addi	r2,r4,4
 8206464:	d9002917 	ldw	r4,164(sp)
 8206468:	d8802d15 	stw	r2,180(sp)
 820646c:	203df00e 	bge	r4,zero,8205c30 <___svfprintf_internal_r+0x18d8>
 8206470:	8c403fcc 	andi	r17,r17,255
 8206474:	00bfffc4 	movi	r2,-1
 8206478:	8c40201c 	xori	r17,r17,128
 820647c:	d8802915 	stw	r2,164(sp)
 8206480:	8c7fe004 	addi	r17,r17,-128
 8206484:	00380806 	br	82044a8 <___svfprintf_internal_r+0x150>
 8206488:	9080004c 	andi	r2,r18,1
 820648c:	0039883a 	mov	fp,zero
 8206490:	10000726 	beq	r2,zero,82064b0 <___svfprintf_internal_r+0x2158>
 8206494:	d8c02817 	ldw	r3,160(sp)
 8206498:	dc001dc4 	addi	r16,sp,119
 820649c:	00800c04 	movi	r2,48
 82064a0:	1c07c83a 	sub	r3,r3,r16
 82064a4:	d8801dc5 	stb	r2,119(sp)
 82064a8:	d8c02e15 	stw	r3,184(sp)
 82064ac:	00395206 	br	82049f8 <___svfprintf_internal_r+0x6a0>
 82064b0:	d8002e15 	stw	zero,184(sp)
 82064b4:	dc001e04 	addi	r16,sp,120
 82064b8:	00394f06 	br	82049f8 <___svfprintf_internal_r+0x6a0>
 82064bc:	0005883a 	mov	r2,zero
 82064c0:	003e3206 	br	8205d8c <___svfprintf_internal_r+0x1a34>
 82064c4:	dd802617 	ldw	r22,152(sp)
 82064c8:	003f0606 	br	82060e4 <___svfprintf_internal_r+0x1d8c>
 82064cc:	d9c02785 	stb	r7,158(sp)
 82064d0:	003a5106 	br	8204e18 <___svfprintf_internal_r+0xac0>
 82064d4:	d9c02785 	stb	r7,158(sp)
 82064d8:	003a3706 	br	8204db8 <___svfprintf_internal_r+0xa60>
 82064dc:	0005883a 	mov	r2,zero
 82064e0:	003f5e06 	br	820625c <___svfprintf_internal_r+0x1f04>
 82064e4:	d9c02785 	stb	r7,158(sp)
 82064e8:	00391706 	br	8204948 <___svfprintf_internal_r+0x5f0>
 82064ec:	d9c02785 	stb	r7,158(sp)
 82064f0:	0038e606 	br	820488c <___svfprintf_internal_r+0x534>
 82064f4:	d8802344 	addi	r2,sp,141
 82064f8:	003f0806 	br	820611c <___svfprintf_internal_r+0x1dc4>
 82064fc:	d9c02785 	stb	r7,158(sp)
 8206500:	0038b706 	br	82047e0 <___svfprintf_internal_r+0x488>
 8206504:	d9c02785 	stb	r7,158(sp)
 8206508:	003adc06 	br	820507c <___svfprintf_internal_r+0xd24>
 820650c:	d9403917 	ldw	r5,228(sp)
 8206510:	00800304 	movi	r2,12
 8206514:	28800015 	stw	r2,0(r5)
 8206518:	00bfffc4 	movi	r2,-1
 820651c:	00387806 	br	8204700 <___svfprintf_internal_r+0x3a8>
 8206520:	d9c02785 	stb	r7,158(sp)
 8206524:	003abf06 	br	8205024 <___svfprintf_internal_r+0xccc>
 8206528:	d9c02785 	stb	r7,158(sp)
 820652c:	003a9b06 	br	8204f9c <___svfprintf_internal_r+0xc44>

08206530 <_user_strerror>:
 8206530:	0005883a 	mov	r2,zero
 8206534:	f800283a 	ret

08206538 <___vfprintf_internal_r>:
 8206538:	deffb804 	addi	sp,sp,-288
 820653c:	dfc04715 	stw	ra,284(sp)
 8206540:	ddc04515 	stw	r23,276(sp)
 8206544:	dd404315 	stw	r21,268(sp)
 8206548:	d9002c15 	stw	r4,176(sp)
 820654c:	282f883a 	mov	r23,r5
 8206550:	302b883a 	mov	r21,r6
 8206554:	d9c02d15 	stw	r7,180(sp)
 8206558:	df004615 	stw	fp,280(sp)
 820655c:	dd804415 	stw	r22,272(sp)
 8206560:	dd004215 	stw	r20,264(sp)
 8206564:	dcc04115 	stw	r19,260(sp)
 8206568:	dc804015 	stw	r18,256(sp)
 820656c:	dc403f15 	stw	r17,252(sp)
 8206570:	dc003e15 	stw	r16,248(sp)
 8206574:	820b5fc0 	call	820b5fc <_localeconv_r>
 8206578:	10800017 	ldw	r2,0(r2)
 820657c:	1009883a 	mov	r4,r2
 8206580:	d8803415 	stw	r2,208(sp)
 8206584:	8203a5c0 	call	8203a5c <strlen>
 8206588:	d8803715 	stw	r2,220(sp)
 820658c:	d8802c17 	ldw	r2,176(sp)
 8206590:	10000226 	beq	r2,zero,820659c <___vfprintf_internal_r+0x64>
 8206594:	10800e17 	ldw	r2,56(r2)
 8206598:	1000f926 	beq	r2,zero,8206980 <___vfprintf_internal_r+0x448>
 820659c:	b880030b 	ldhu	r2,12(r23)
 82065a0:	10c8000c 	andi	r3,r2,8192
 82065a4:	1800061e 	bne	r3,zero,82065c0 <___vfprintf_internal_r+0x88>
 82065a8:	b9001917 	ldw	r4,100(r23)
 82065ac:	00f7ffc4 	movi	r3,-8193
 82065b0:	10880014 	ori	r2,r2,8192
 82065b4:	20c6703a 	and	r3,r4,r3
 82065b8:	b880030d 	sth	r2,12(r23)
 82065bc:	b8c01915 	stw	r3,100(r23)
 82065c0:	10c0020c 	andi	r3,r2,8
 82065c4:	1800c126 	beq	r3,zero,82068cc <___vfprintf_internal_r+0x394>
 82065c8:	b8c00417 	ldw	r3,16(r23)
 82065cc:	1800bf26 	beq	r3,zero,82068cc <___vfprintf_internal_r+0x394>
 82065d0:	1080068c 	andi	r2,r2,26
 82065d4:	00c00284 	movi	r3,10
 82065d8:	10c0c426 	beq	r2,r3,82068ec <___vfprintf_internal_r+0x3b4>
 82065dc:	d8c00404 	addi	r3,sp,16
 82065e0:	05020974 	movhi	r20,2085
 82065e4:	d9001e04 	addi	r4,sp,120
 82065e8:	a5356984 	addi	r20,r20,-10842
 82065ec:	d8c01e15 	stw	r3,120(sp)
 82065f0:	d8002015 	stw	zero,128(sp)
 82065f4:	d8001f15 	stw	zero,124(sp)
 82065f8:	d8003315 	stw	zero,204(sp)
 82065fc:	d8003615 	stw	zero,216(sp)
 8206600:	d8003815 	stw	zero,224(sp)
 8206604:	1811883a 	mov	r8,r3
 8206608:	d8003915 	stw	zero,228(sp)
 820660c:	d8003a15 	stw	zero,232(sp)
 8206610:	d8002f15 	stw	zero,188(sp)
 8206614:	d9002815 	stw	r4,160(sp)
 8206618:	a8800007 	ldb	r2,0(r21)
 820661c:	10027b26 	beq	r2,zero,820700c <___vfprintf_internal_r+0xad4>
 8206620:	00c00944 	movi	r3,37
 8206624:	a821883a 	mov	r16,r21
 8206628:	10c0021e 	bne	r2,r3,8206634 <___vfprintf_internal_r+0xfc>
 820662c:	00001406 	br	8206680 <___vfprintf_internal_r+0x148>
 8206630:	10c00326 	beq	r2,r3,8206640 <___vfprintf_internal_r+0x108>
 8206634:	84000044 	addi	r16,r16,1
 8206638:	80800007 	ldb	r2,0(r16)
 820663c:	103ffc1e 	bne	r2,zero,8206630 <___vfprintf_internal_r+0xf8>
 8206640:	8563c83a 	sub	r17,r16,r21
 8206644:	88000e26 	beq	r17,zero,8206680 <___vfprintf_internal_r+0x148>
 8206648:	d8c02017 	ldw	r3,128(sp)
 820664c:	d8801f17 	ldw	r2,124(sp)
 8206650:	45400015 	stw	r21,0(r8)
 8206654:	1c47883a 	add	r3,r3,r17
 8206658:	10800044 	addi	r2,r2,1
 820665c:	d8c02015 	stw	r3,128(sp)
 8206660:	44400115 	stw	r17,4(r8)
 8206664:	d8801f15 	stw	r2,124(sp)
 8206668:	00c001c4 	movi	r3,7
 820666c:	1880a716 	blt	r3,r2,820690c <___vfprintf_internal_r+0x3d4>
 8206670:	42000204 	addi	r8,r8,8
 8206674:	d9402f17 	ldw	r5,188(sp)
 8206678:	2c4b883a 	add	r5,r5,r17
 820667c:	d9402f15 	stw	r5,188(sp)
 8206680:	80800007 	ldb	r2,0(r16)
 8206684:	1000a826 	beq	r2,zero,8206928 <___vfprintf_internal_r+0x3f0>
 8206688:	84400047 	ldb	r17,1(r16)
 820668c:	00bfffc4 	movi	r2,-1
 8206690:	85400044 	addi	r21,r16,1
 8206694:	d8002785 	stb	zero,158(sp)
 8206698:	0007883a 	mov	r3,zero
 820669c:	000f883a 	mov	r7,zero
 82066a0:	d8802915 	stw	r2,164(sp)
 82066a4:	d8003115 	stw	zero,196(sp)
 82066a8:	0025883a 	mov	r18,zero
 82066ac:	01401604 	movi	r5,88
 82066b0:	01800244 	movi	r6,9
 82066b4:	02800a84 	movi	r10,42
 82066b8:	02401b04 	movi	r9,108
 82066bc:	ad400044 	addi	r21,r21,1
 82066c0:	88bff804 	addi	r2,r17,-32
 82066c4:	28830436 	bltu	r5,r2,82072d8 <___vfprintf_internal_r+0xda0>
 82066c8:	100490ba 	slli	r2,r2,2
 82066cc:	01020834 	movhi	r4,2080
 82066d0:	2119b804 	addi	r4,r4,26336
 82066d4:	1105883a 	add	r2,r2,r4
 82066d8:	10800017 	ldw	r2,0(r2)
 82066dc:	1000683a 	jmp	r2
 82066e0:	082071f8 	rdprs	zero,at,-32313
 82066e4:	082072d8 	cmpnei	zero,at,-32309
 82066e8:	082072d8 	cmpnei	zero,at,-32309
 82066ec:	08207218 	cmpnei	zero,at,-32312
 82066f0:	082072d8 	cmpnei	zero,at,-32309
 82066f4:	082072d8 	cmpnei	zero,at,-32309
 82066f8:	082072d8 	cmpnei	zero,at,-32309
 82066fc:	082072d8 	cmpnei	zero,at,-32309
 8206700:	082072d8 	cmpnei	zero,at,-32309
 8206704:	082072d8 	cmpnei	zero,at,-32309
 8206708:	0820698c 	andi	zero,at,33190
 820670c:	08207134 	orhi	zero,at,33220
 8206710:	082072d8 	cmpnei	zero,at,-32309
 8206714:	08206854 	ori	zero,at,33185
 8206718:	082069b4 	orhi	zero,at,33190
 820671c:	082072d8 	cmpnei	zero,at,-32309
 8206720:	082069f4 	orhi	zero,at,33191
 8206724:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206728:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 820672c:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206730:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206734:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206738:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 820673c:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206740:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206744:	08206a00 	call	8206a0 <OSCtxSw_SWITCH_PC+0x820660>
 8206748:	082072d8 	cmpnei	zero,at,-32309
 820674c:	082072d8 	cmpnei	zero,at,-32309
 8206750:	082072d8 	cmpnei	zero,at,-32309
 8206754:	082072d8 	cmpnei	zero,at,-32309
 8206758:	082072d8 	cmpnei	zero,at,-32309
 820675c:	082072d8 	cmpnei	zero,at,-32309
 8206760:	082072d8 	cmpnei	zero,at,-32309
 8206764:	082072d8 	cmpnei	zero,at,-32309
 8206768:	082072d8 	cmpnei	zero,at,-32309
 820676c:	082072d8 	cmpnei	zero,at,-32309
 8206770:	08206a34 	orhi	zero,at,33192
 8206774:	08206af0 	cmpltui	zero,at,33195
 8206778:	082072d8 	cmpnei	zero,at,-32309
 820677c:	08206af0 	cmpltui	zero,at,33195
 8206780:	082072d8 	cmpnei	zero,at,-32309
 8206784:	082072d8 	cmpnei	zero,at,-32309
 8206788:	082072d8 	cmpnei	zero,at,-32309
 820678c:	082072d8 	cmpnei	zero,at,-32309
 8206790:	08206b90 	cmplti	zero,at,-32338
 8206794:	082072d8 	cmpnei	zero,at,-32309
 8206798:	082072d8 	cmpnei	zero,at,-32309
 820679c:	08206b9c 	xori	zero,at,33198
 82067a0:	082072d8 	cmpnei	zero,at,-32309
 82067a4:	082072d8 	cmpnei	zero,at,-32309
 82067a8:	082072d8 	cmpnei	zero,at,-32309
 82067ac:	082072d8 	cmpnei	zero,at,-32309
 82067b0:	082072d8 	cmpnei	zero,at,-32309
 82067b4:	08207014 	ori	zero,at,33216
 82067b8:	082072d8 	cmpnei	zero,at,-32309
 82067bc:	082072d8 	cmpnei	zero,at,-32309
 82067c0:	08207074 	orhi	zero,at,33217
 82067c4:	082072d8 	cmpnei	zero,at,-32309
 82067c8:	082072d8 	cmpnei	zero,at,-32309
 82067cc:	082072d8 	cmpnei	zero,at,-32309
 82067d0:	082072d8 	cmpnei	zero,at,-32309
 82067d4:	082072d8 	cmpnei	zero,at,-32309
 82067d8:	082072d8 	cmpnei	zero,at,-32309
 82067dc:	082072d8 	cmpnei	zero,at,-32309
 82067e0:	082072d8 	cmpnei	zero,at,-32309
 82067e4:	082072d8 	cmpnei	zero,at,-32309
 82067e8:	082072d8 	cmpnei	zero,at,-32309
 82067ec:	08207284 	addi	zero,at,-32310
 82067f0:	08207224 	muli	zero,at,-32312
 82067f4:	08206af0 	cmpltui	zero,at,33195
 82067f8:	08206af0 	cmpltui	zero,at,33195
 82067fc:	08206af0 	cmpltui	zero,at,33195
 8206800:	08207234 	orhi	zero,at,33224
 8206804:	08207224 	muli	zero,at,-32312
 8206808:	082072d8 	cmpnei	zero,at,-32309
 820680c:	082072d8 	cmpnei	zero,at,-32309
 8206810:	08207240 	call	820724 <OSCtxSw_SWITCH_PC+0x8206e4>
 8206814:	082072d8 	cmpnei	zero,at,-32309
 8206818:	08207250 	cmplti	zero,at,-32311
 820681c:	08207124 	muli	zero,at,-32316
 8206820:	08206860 	cmpeqi	zero,at,-32351
 8206824:	08207144 	addi	zero,at,-32315
 8206828:	082072d8 	cmpnei	zero,at,-32309
 820682c:	08207150 	cmplti	zero,at,-32315
 8206830:	082072d8 	cmpnei	zero,at,-32309
 8206834:	082071ac 	andhi	zero,at,33222
 8206838:	082072d8 	cmpnei	zero,at,-32309
 820683c:	082072d8 	cmpnei	zero,at,-32309
 8206840:	082071bc 	xorhi	zero,at,33222
 8206844:	d9003117 	ldw	r4,196(sp)
 8206848:	d8802d15 	stw	r2,180(sp)
 820684c:	0109c83a 	sub	r4,zero,r4
 8206850:	d9003115 	stw	r4,196(sp)
 8206854:	94800114 	ori	r18,r18,4
 8206858:	ac400007 	ldb	r17,0(r21)
 820685c:	003f9706 	br	82066bc <___vfprintf_internal_r+0x184>
 8206860:	00800c04 	movi	r2,48
 8206864:	d9002d17 	ldw	r4,180(sp)
 8206868:	d9402917 	ldw	r5,164(sp)
 820686c:	d8802705 	stb	r2,156(sp)
 8206870:	00801e04 	movi	r2,120
 8206874:	d8802745 	stb	r2,157(sp)
 8206878:	d8002785 	stb	zero,158(sp)
 820687c:	20c00104 	addi	r3,r4,4
 8206880:	24c00017 	ldw	r19,0(r4)
 8206884:	002d883a 	mov	r22,zero
 8206888:	90800094 	ori	r2,r18,2
 820688c:	28029a16 	blt	r5,zero,82072f8 <___vfprintf_internal_r+0xdc0>
 8206890:	00bfdfc4 	movi	r2,-129
 8206894:	90a4703a 	and	r18,r18,r2
 8206898:	d8c02d15 	stw	r3,180(sp)
 820689c:	94800094 	ori	r18,r18,2
 82068a0:	9802871e 	bne	r19,zero,82072c0 <___vfprintf_internal_r+0xd88>
 82068a4:	00820974 	movhi	r2,2085
 82068a8:	10b55a04 	addi	r2,r2,-10904
 82068ac:	d8803915 	stw	r2,228(sp)
 82068b0:	04401e04 	movi	r17,120
 82068b4:	d8802917 	ldw	r2,164(sp)
 82068b8:	0039883a 	mov	fp,zero
 82068bc:	1001e926 	beq	r2,zero,8207064 <___vfprintf_internal_r+0xb2c>
 82068c0:	0027883a 	mov	r19,zero
 82068c4:	002d883a 	mov	r22,zero
 82068c8:	00020506 	br	82070e0 <___vfprintf_internal_r+0xba8>
 82068cc:	d9002c17 	ldw	r4,176(sp)
 82068d0:	b80b883a 	mov	r5,r23
 82068d4:	82089600 	call	8208960 <__swsetup_r>
 82068d8:	1005ac1e 	bne	r2,zero,8207f8c <___vfprintf_internal_r+0x1a54>
 82068dc:	b880030b 	ldhu	r2,12(r23)
 82068e0:	00c00284 	movi	r3,10
 82068e4:	1080068c 	andi	r2,r2,26
 82068e8:	10ff3c1e 	bne	r2,r3,82065dc <___vfprintf_internal_r+0xa4>
 82068ec:	b880038f 	ldh	r2,14(r23)
 82068f0:	103f3a16 	blt	r2,zero,82065dc <___vfprintf_internal_r+0xa4>
 82068f4:	d9c02d17 	ldw	r7,180(sp)
 82068f8:	d9002c17 	ldw	r4,176(sp)
 82068fc:	a80d883a 	mov	r6,r21
 8206900:	b80b883a 	mov	r5,r23
 8206904:	820874c0 	call	820874c <__sbprintf>
 8206908:	00001106 	br	8206950 <___vfprintf_internal_r+0x418>
 820690c:	d9002c17 	ldw	r4,176(sp)
 8206910:	d9801e04 	addi	r6,sp,120
 8206914:	b80b883a 	mov	r5,r23
 8206918:	820f08c0 	call	820f08c <__sprint_r>
 820691c:	1000081e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8206920:	da000404 	addi	r8,sp,16
 8206924:	003f5306 	br	8206674 <___vfprintf_internal_r+0x13c>
 8206928:	d8802017 	ldw	r2,128(sp)
 820692c:	10000426 	beq	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8206930:	d9002c17 	ldw	r4,176(sp)
 8206934:	d9801e04 	addi	r6,sp,120
 8206938:	b80b883a 	mov	r5,r23
 820693c:	820f08c0 	call	820f08c <__sprint_r>
 8206940:	b880030b 	ldhu	r2,12(r23)
 8206944:	1080100c 	andi	r2,r2,64
 8206948:	1005901e 	bne	r2,zero,8207f8c <___vfprintf_internal_r+0x1a54>
 820694c:	d8802f17 	ldw	r2,188(sp)
 8206950:	dfc04717 	ldw	ra,284(sp)
 8206954:	df004617 	ldw	fp,280(sp)
 8206958:	ddc04517 	ldw	r23,276(sp)
 820695c:	dd804417 	ldw	r22,272(sp)
 8206960:	dd404317 	ldw	r21,268(sp)
 8206964:	dd004217 	ldw	r20,264(sp)
 8206968:	dcc04117 	ldw	r19,260(sp)
 820696c:	dc804017 	ldw	r18,256(sp)
 8206970:	dc403f17 	ldw	r17,252(sp)
 8206974:	dc003e17 	ldw	r16,248(sp)
 8206978:	dec04804 	addi	sp,sp,288
 820697c:	f800283a 	ret
 8206980:	d9002c17 	ldw	r4,176(sp)
 8206984:	820a9340 	call	820a934 <__sinit>
 8206988:	003f0406 	br	820659c <___vfprintf_internal_r+0x64>
 820698c:	d8802d17 	ldw	r2,180(sp)
 8206990:	d9002d17 	ldw	r4,180(sp)
 8206994:	10800017 	ldw	r2,0(r2)
 8206998:	d8803115 	stw	r2,196(sp)
 820699c:	20800104 	addi	r2,r4,4
 82069a0:	d9003117 	ldw	r4,196(sp)
 82069a4:	203fa716 	blt	r4,zero,8206844 <___vfprintf_internal_r+0x30c>
 82069a8:	d8802d15 	stw	r2,180(sp)
 82069ac:	ac400007 	ldb	r17,0(r21)
 82069b0:	003f4206 	br	82066bc <___vfprintf_internal_r+0x184>
 82069b4:	ac400007 	ldb	r17,0(r21)
 82069b8:	aac00044 	addi	r11,r21,1
 82069bc:	8a872826 	beq	r17,r10,8208660 <___vfprintf_internal_r+0x2128>
 82069c0:	88bff404 	addi	r2,r17,-48
 82069c4:	0009883a 	mov	r4,zero
 82069c8:	30867d36 	bltu	r6,r2,82083c0 <___vfprintf_internal_r+0x1e88>
 82069cc:	5c400007 	ldb	r17,0(r11)
 82069d0:	210002a4 	muli	r4,r4,10
 82069d4:	5d400044 	addi	r21,r11,1
 82069d8:	a817883a 	mov	r11,r21
 82069dc:	2089883a 	add	r4,r4,r2
 82069e0:	88bff404 	addi	r2,r17,-48
 82069e4:	30bff92e 	bgeu	r6,r2,82069cc <___vfprintf_internal_r+0x494>
 82069e8:	2005c916 	blt	r4,zero,8208110 <___vfprintf_internal_r+0x1bd8>
 82069ec:	d9002915 	stw	r4,164(sp)
 82069f0:	003f3306 	br	82066c0 <___vfprintf_internal_r+0x188>
 82069f4:	94802014 	ori	r18,r18,128
 82069f8:	ac400007 	ldb	r17,0(r21)
 82069fc:	003f2f06 	br	82066bc <___vfprintf_internal_r+0x184>
 8206a00:	a809883a 	mov	r4,r21
 8206a04:	d8003115 	stw	zero,196(sp)
 8206a08:	88bff404 	addi	r2,r17,-48
 8206a0c:	0017883a 	mov	r11,zero
 8206a10:	24400007 	ldb	r17,0(r4)
 8206a14:	5ac002a4 	muli	r11,r11,10
 8206a18:	ad400044 	addi	r21,r21,1
 8206a1c:	a809883a 	mov	r4,r21
 8206a20:	12d7883a 	add	r11,r2,r11
 8206a24:	88bff404 	addi	r2,r17,-48
 8206a28:	30bff92e 	bgeu	r6,r2,8206a10 <___vfprintf_internal_r+0x4d8>
 8206a2c:	dac03115 	stw	r11,196(sp)
 8206a30:	003f2306 	br	82066c0 <___vfprintf_internal_r+0x188>
 8206a34:	18c03fcc 	andi	r3,r3,255
 8206a38:	18072b1e 	bne	r3,zero,82086e8 <___vfprintf_internal_r+0x21b0>
 8206a3c:	94800414 	ori	r18,r18,16
 8206a40:	9080080c 	andi	r2,r18,32
 8206a44:	10037b26 	beq	r2,zero,8207834 <___vfprintf_internal_r+0x12fc>
 8206a48:	d9402d17 	ldw	r5,180(sp)
 8206a4c:	28800117 	ldw	r2,4(r5)
 8206a50:	2cc00017 	ldw	r19,0(r5)
 8206a54:	29400204 	addi	r5,r5,8
 8206a58:	d9402d15 	stw	r5,180(sp)
 8206a5c:	102d883a 	mov	r22,r2
 8206a60:	10044b16 	blt	r2,zero,8207b90 <___vfprintf_internal_r+0x1658>
 8206a64:	d9402917 	ldw	r5,164(sp)
 8206a68:	df002783 	ldbu	fp,158(sp)
 8206a6c:	2803bc16 	blt	r5,zero,8207960 <___vfprintf_internal_r+0x1428>
 8206a70:	00ffdfc4 	movi	r3,-129
 8206a74:	9d84b03a 	or	r2,r19,r22
 8206a78:	90e4703a 	and	r18,r18,r3
 8206a7c:	10017726 	beq	r2,zero,820705c <___vfprintf_internal_r+0xb24>
 8206a80:	b0038326 	beq	r22,zero,8207890 <___vfprintf_internal_r+0x1358>
 8206a84:	dc402a15 	stw	r17,168(sp)
 8206a88:	dc001e04 	addi	r16,sp,120
 8206a8c:	b023883a 	mov	r17,r22
 8206a90:	402d883a 	mov	r22,r8
 8206a94:	9809883a 	mov	r4,r19
 8206a98:	880b883a 	mov	r5,r17
 8206a9c:	01800284 	movi	r6,10
 8206aa0:	000f883a 	mov	r7,zero
 8206aa4:	821132c0 	call	821132c <__umoddi3>
 8206aa8:	10800c04 	addi	r2,r2,48
 8206aac:	843fffc4 	addi	r16,r16,-1
 8206ab0:	9809883a 	mov	r4,r19
 8206ab4:	880b883a 	mov	r5,r17
 8206ab8:	80800005 	stb	r2,0(r16)
 8206abc:	01800284 	movi	r6,10
 8206ac0:	000f883a 	mov	r7,zero
 8206ac4:	8210db40 	call	8210db4 <__udivdi3>
 8206ac8:	1027883a 	mov	r19,r2
 8206acc:	10c4b03a 	or	r2,r2,r3
 8206ad0:	1823883a 	mov	r17,r3
 8206ad4:	103fef1e 	bne	r2,zero,8206a94 <___vfprintf_internal_r+0x55c>
 8206ad8:	d8c02817 	ldw	r3,160(sp)
 8206adc:	dc402a17 	ldw	r17,168(sp)
 8206ae0:	b011883a 	mov	r8,r22
 8206ae4:	1c07c83a 	sub	r3,r3,r16
 8206ae8:	d8c02e15 	stw	r3,184(sp)
 8206aec:	00005906 	br	8206c54 <___vfprintf_internal_r+0x71c>
 8206af0:	18c03fcc 	andi	r3,r3,255
 8206af4:	1806fa1e 	bne	r3,zero,82086e0 <___vfprintf_internal_r+0x21a8>
 8206af8:	9080020c 	andi	r2,r18,8
 8206afc:	10048a26 	beq	r2,zero,8207d28 <___vfprintf_internal_r+0x17f0>
 8206b00:	d8c02d17 	ldw	r3,180(sp)
 8206b04:	d9002d17 	ldw	r4,180(sp)
 8206b08:	d9402d17 	ldw	r5,180(sp)
 8206b0c:	18c00017 	ldw	r3,0(r3)
 8206b10:	21000117 	ldw	r4,4(r4)
 8206b14:	29400204 	addi	r5,r5,8
 8206b18:	d8c03615 	stw	r3,216(sp)
 8206b1c:	d9003815 	stw	r4,224(sp)
 8206b20:	d9402d15 	stw	r5,180(sp)
 8206b24:	d9003617 	ldw	r4,216(sp)
 8206b28:	d9403817 	ldw	r5,224(sp)
 8206b2c:	da003d15 	stw	r8,244(sp)
 8206b30:	04000044 	movi	r16,1
 8206b34:	820d8a40 	call	820d8a4 <__fpclassifyd>
 8206b38:	da003d17 	ldw	r8,244(sp)
 8206b3c:	14041f1e 	bne	r2,r16,8207bbc <___vfprintf_internal_r+0x1684>
 8206b40:	d9003617 	ldw	r4,216(sp)
 8206b44:	d9403817 	ldw	r5,224(sp)
 8206b48:	000d883a 	mov	r6,zero
 8206b4c:	000f883a 	mov	r7,zero
 8206b50:	8212b5c0 	call	8212b5c <__ledf2>
 8206b54:	da003d17 	ldw	r8,244(sp)
 8206b58:	1005be16 	blt	r2,zero,8208254 <___vfprintf_internal_r+0x1d1c>
 8206b5c:	df002783 	ldbu	fp,158(sp)
 8206b60:	008011c4 	movi	r2,71
 8206b64:	1445330e 	bge	r2,r17,8208034 <___vfprintf_internal_r+0x1afc>
 8206b68:	04020974 	movhi	r16,2085
 8206b6c:	84355204 	addi	r16,r16,-10936
 8206b70:	00c000c4 	movi	r3,3
 8206b74:	00bfdfc4 	movi	r2,-129
 8206b78:	d8c02a15 	stw	r3,168(sp)
 8206b7c:	90a4703a 	and	r18,r18,r2
 8206b80:	d8c02e15 	stw	r3,184(sp)
 8206b84:	d8002915 	stw	zero,164(sp)
 8206b88:	d8003215 	stw	zero,200(sp)
 8206b8c:	00003706 	br	8206c6c <___vfprintf_internal_r+0x734>
 8206b90:	94800214 	ori	r18,r18,8
 8206b94:	ac400007 	ldb	r17,0(r21)
 8206b98:	003ec806 	br	82066bc <___vfprintf_internal_r+0x184>
 8206b9c:	18c03fcc 	andi	r3,r3,255
 8206ba0:	1806db1e 	bne	r3,zero,8208710 <___vfprintf_internal_r+0x21d8>
 8206ba4:	94800414 	ori	r18,r18,16
 8206ba8:	9080080c 	andi	r2,r18,32
 8206bac:	1002d826 	beq	r2,zero,8207710 <___vfprintf_internal_r+0x11d8>
 8206bb0:	d9402d17 	ldw	r5,180(sp)
 8206bb4:	d8c02917 	ldw	r3,164(sp)
 8206bb8:	d8002785 	stb	zero,158(sp)
 8206bbc:	28800204 	addi	r2,r5,8
 8206bc0:	2cc00017 	ldw	r19,0(r5)
 8206bc4:	2d800117 	ldw	r22,4(r5)
 8206bc8:	18048f16 	blt	r3,zero,8207e08 <___vfprintf_internal_r+0x18d0>
 8206bcc:	013fdfc4 	movi	r4,-129
 8206bd0:	9d86b03a 	or	r3,r19,r22
 8206bd4:	d8802d15 	stw	r2,180(sp)
 8206bd8:	9124703a 	and	r18,r18,r4
 8206bdc:	1802d91e 	bne	r3,zero,8207744 <___vfprintf_internal_r+0x120c>
 8206be0:	d8c02917 	ldw	r3,164(sp)
 8206be4:	0039883a 	mov	fp,zero
 8206be8:	1805c326 	beq	r3,zero,82082f8 <___vfprintf_internal_r+0x1dc0>
 8206bec:	0027883a 	mov	r19,zero
 8206bf0:	002d883a 	mov	r22,zero
 8206bf4:	dc001e04 	addi	r16,sp,120
 8206bf8:	9806d0fa 	srli	r3,r19,3
 8206bfc:	b008977a 	slli	r4,r22,29
 8206c00:	b02cd0fa 	srli	r22,r22,3
 8206c04:	9cc001cc 	andi	r19,r19,7
 8206c08:	98800c04 	addi	r2,r19,48
 8206c0c:	843fffc4 	addi	r16,r16,-1
 8206c10:	20e6b03a 	or	r19,r4,r3
 8206c14:	80800005 	stb	r2,0(r16)
 8206c18:	9d86b03a 	or	r3,r19,r22
 8206c1c:	183ff61e 	bne	r3,zero,8206bf8 <___vfprintf_internal_r+0x6c0>
 8206c20:	90c0004c 	andi	r3,r18,1
 8206c24:	18013b26 	beq	r3,zero,8207114 <___vfprintf_internal_r+0xbdc>
 8206c28:	10803fcc 	andi	r2,r2,255
 8206c2c:	1080201c 	xori	r2,r2,128
 8206c30:	10bfe004 	addi	r2,r2,-128
 8206c34:	00c00c04 	movi	r3,48
 8206c38:	10c13626 	beq	r2,r3,8207114 <___vfprintf_internal_r+0xbdc>
 8206c3c:	80ffffc5 	stb	r3,-1(r16)
 8206c40:	d8c02817 	ldw	r3,160(sp)
 8206c44:	80bfffc4 	addi	r2,r16,-1
 8206c48:	1021883a 	mov	r16,r2
 8206c4c:	1887c83a 	sub	r3,r3,r2
 8206c50:	d8c02e15 	stw	r3,184(sp)
 8206c54:	d8802e17 	ldw	r2,184(sp)
 8206c58:	d9002917 	ldw	r4,164(sp)
 8206c5c:	1100010e 	bge	r2,r4,8206c64 <___vfprintf_internal_r+0x72c>
 8206c60:	2005883a 	mov	r2,r4
 8206c64:	d8802a15 	stw	r2,168(sp)
 8206c68:	d8003215 	stw	zero,200(sp)
 8206c6c:	e7003fcc 	andi	fp,fp,255
 8206c70:	e700201c 	xori	fp,fp,128
 8206c74:	e73fe004 	addi	fp,fp,-128
 8206c78:	e0000326 	beq	fp,zero,8206c88 <___vfprintf_internal_r+0x750>
 8206c7c:	d8c02a17 	ldw	r3,168(sp)
 8206c80:	18c00044 	addi	r3,r3,1
 8206c84:	d8c02a15 	stw	r3,168(sp)
 8206c88:	90c0008c 	andi	r3,r18,2
 8206c8c:	d8c02b15 	stw	r3,172(sp)
 8206c90:	18000326 	beq	r3,zero,8206ca0 <___vfprintf_internal_r+0x768>
 8206c94:	d8c02a17 	ldw	r3,168(sp)
 8206c98:	18c00084 	addi	r3,r3,2
 8206c9c:	d8c02a15 	stw	r3,168(sp)
 8206ca0:	90c0210c 	andi	r3,r18,132
 8206ca4:	d8c03015 	stw	r3,192(sp)
 8206ca8:	1801a31e 	bne	r3,zero,8207338 <___vfprintf_internal_r+0xe00>
 8206cac:	d9003117 	ldw	r4,196(sp)
 8206cb0:	d8c02a17 	ldw	r3,168(sp)
 8206cb4:	20e7c83a 	sub	r19,r4,r3
 8206cb8:	04c19f0e 	bge	zero,r19,8207338 <___vfprintf_internal_r+0xe00>
 8206cbc:	02400404 	movi	r9,16
 8206cc0:	d8c02017 	ldw	r3,128(sp)
 8206cc4:	d8801f17 	ldw	r2,124(sp)
 8206cc8:	4cc50d0e 	bge	r9,r19,8208100 <___vfprintf_internal_r+0x1bc8>
 8206ccc:	01420974 	movhi	r5,2085
 8206cd0:	29756d84 	addi	r5,r5,-10826
 8206cd4:	dc403b15 	stw	r17,236(sp)
 8206cd8:	d9403515 	stw	r5,212(sp)
 8206cdc:	9823883a 	mov	r17,r19
 8206ce0:	482d883a 	mov	r22,r9
 8206ce4:	9027883a 	mov	r19,r18
 8206ce8:	070001c4 	movi	fp,7
 8206cec:	8025883a 	mov	r18,r16
 8206cf0:	dc002c17 	ldw	r16,176(sp)
 8206cf4:	00000306 	br	8206d04 <___vfprintf_internal_r+0x7cc>
 8206cf8:	8c7ffc04 	addi	r17,r17,-16
 8206cfc:	42000204 	addi	r8,r8,8
 8206d00:	b440130e 	bge	r22,r17,8206d50 <___vfprintf_internal_r+0x818>
 8206d04:	01020974 	movhi	r4,2085
 8206d08:	18c00404 	addi	r3,r3,16
 8206d0c:	10800044 	addi	r2,r2,1
 8206d10:	21356d84 	addi	r4,r4,-10826
 8206d14:	41000015 	stw	r4,0(r8)
 8206d18:	45800115 	stw	r22,4(r8)
 8206d1c:	d8c02015 	stw	r3,128(sp)
 8206d20:	d8801f15 	stw	r2,124(sp)
 8206d24:	e0bff40e 	bge	fp,r2,8206cf8 <___vfprintf_internal_r+0x7c0>
 8206d28:	d9801e04 	addi	r6,sp,120
 8206d2c:	b80b883a 	mov	r5,r23
 8206d30:	8009883a 	mov	r4,r16
 8206d34:	820f08c0 	call	820f08c <__sprint_r>
 8206d38:	103f011e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8206d3c:	8c7ffc04 	addi	r17,r17,-16
 8206d40:	d8c02017 	ldw	r3,128(sp)
 8206d44:	d8801f17 	ldw	r2,124(sp)
 8206d48:	da000404 	addi	r8,sp,16
 8206d4c:	b47fed16 	blt	r22,r17,8206d04 <___vfprintf_internal_r+0x7cc>
 8206d50:	9021883a 	mov	r16,r18
 8206d54:	9825883a 	mov	r18,r19
 8206d58:	8827883a 	mov	r19,r17
 8206d5c:	dc403b17 	ldw	r17,236(sp)
 8206d60:	d9403517 	ldw	r5,212(sp)
 8206d64:	98c7883a 	add	r3,r19,r3
 8206d68:	10800044 	addi	r2,r2,1
 8206d6c:	41400015 	stw	r5,0(r8)
 8206d70:	44c00115 	stw	r19,4(r8)
 8206d74:	d8c02015 	stw	r3,128(sp)
 8206d78:	d8801f15 	stw	r2,124(sp)
 8206d7c:	010001c4 	movi	r4,7
 8206d80:	2082a316 	blt	r4,r2,8207810 <___vfprintf_internal_r+0x12d8>
 8206d84:	df002787 	ldb	fp,158(sp)
 8206d88:	42000204 	addi	r8,r8,8
 8206d8c:	e0000c26 	beq	fp,zero,8206dc0 <___vfprintf_internal_r+0x888>
 8206d90:	d8801f17 	ldw	r2,124(sp)
 8206d94:	d9002784 	addi	r4,sp,158
 8206d98:	18c00044 	addi	r3,r3,1
 8206d9c:	10800044 	addi	r2,r2,1
 8206da0:	41000015 	stw	r4,0(r8)
 8206da4:	01000044 	movi	r4,1
 8206da8:	41000115 	stw	r4,4(r8)
 8206dac:	d8c02015 	stw	r3,128(sp)
 8206db0:	d8801f15 	stw	r2,124(sp)
 8206db4:	010001c4 	movi	r4,7
 8206db8:	20823c16 	blt	r4,r2,82076ac <___vfprintf_internal_r+0x1174>
 8206dbc:	42000204 	addi	r8,r8,8
 8206dc0:	d8802b17 	ldw	r2,172(sp)
 8206dc4:	10000c26 	beq	r2,zero,8206df8 <___vfprintf_internal_r+0x8c0>
 8206dc8:	d8801f17 	ldw	r2,124(sp)
 8206dcc:	d9002704 	addi	r4,sp,156
 8206dd0:	18c00084 	addi	r3,r3,2
 8206dd4:	10800044 	addi	r2,r2,1
 8206dd8:	41000015 	stw	r4,0(r8)
 8206ddc:	01000084 	movi	r4,2
 8206de0:	41000115 	stw	r4,4(r8)
 8206de4:	d8c02015 	stw	r3,128(sp)
 8206de8:	d8801f15 	stw	r2,124(sp)
 8206dec:	010001c4 	movi	r4,7
 8206df0:	20823616 	blt	r4,r2,82076cc <___vfprintf_internal_r+0x1194>
 8206df4:	42000204 	addi	r8,r8,8
 8206df8:	d9003017 	ldw	r4,192(sp)
 8206dfc:	00802004 	movi	r2,128
 8206e00:	20819926 	beq	r4,r2,8207468 <___vfprintf_internal_r+0xf30>
 8206e04:	d9402917 	ldw	r5,164(sp)
 8206e08:	d8802e17 	ldw	r2,184(sp)
 8206e0c:	28adc83a 	sub	r22,r5,r2
 8206e10:	0580310e 	bge	zero,r22,8206ed8 <___vfprintf_internal_r+0x9a0>
 8206e14:	07000404 	movi	fp,16
 8206e18:	d8801f17 	ldw	r2,124(sp)
 8206e1c:	e584140e 	bge	fp,r22,8207e70 <___vfprintf_internal_r+0x1938>
 8206e20:	01420974 	movhi	r5,2085
 8206e24:	29756984 	addi	r5,r5,-10842
 8206e28:	dc402915 	stw	r17,164(sp)
 8206e2c:	d9402b15 	stw	r5,172(sp)
 8206e30:	b023883a 	mov	r17,r22
 8206e34:	04c001c4 	movi	r19,7
 8206e38:	a82d883a 	mov	r22,r21
 8206e3c:	902b883a 	mov	r21,r18
 8206e40:	8025883a 	mov	r18,r16
 8206e44:	dc002c17 	ldw	r16,176(sp)
 8206e48:	00000306 	br	8206e58 <___vfprintf_internal_r+0x920>
 8206e4c:	8c7ffc04 	addi	r17,r17,-16
 8206e50:	42000204 	addi	r8,r8,8
 8206e54:	e440110e 	bge	fp,r17,8206e9c <___vfprintf_internal_r+0x964>
 8206e58:	18c00404 	addi	r3,r3,16
 8206e5c:	10800044 	addi	r2,r2,1
 8206e60:	45000015 	stw	r20,0(r8)
 8206e64:	47000115 	stw	fp,4(r8)
 8206e68:	d8c02015 	stw	r3,128(sp)
 8206e6c:	d8801f15 	stw	r2,124(sp)
 8206e70:	98bff60e 	bge	r19,r2,8206e4c <___vfprintf_internal_r+0x914>
 8206e74:	d9801e04 	addi	r6,sp,120
 8206e78:	b80b883a 	mov	r5,r23
 8206e7c:	8009883a 	mov	r4,r16
 8206e80:	820f08c0 	call	820f08c <__sprint_r>
 8206e84:	103eae1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8206e88:	8c7ffc04 	addi	r17,r17,-16
 8206e8c:	d8c02017 	ldw	r3,128(sp)
 8206e90:	d8801f17 	ldw	r2,124(sp)
 8206e94:	da000404 	addi	r8,sp,16
 8206e98:	e47fef16 	blt	fp,r17,8206e58 <___vfprintf_internal_r+0x920>
 8206e9c:	9021883a 	mov	r16,r18
 8206ea0:	a825883a 	mov	r18,r21
 8206ea4:	b02b883a 	mov	r21,r22
 8206ea8:	882d883a 	mov	r22,r17
 8206eac:	dc402917 	ldw	r17,164(sp)
 8206eb0:	d9002b17 	ldw	r4,172(sp)
 8206eb4:	1d87883a 	add	r3,r3,r22
 8206eb8:	10800044 	addi	r2,r2,1
 8206ebc:	41000015 	stw	r4,0(r8)
 8206ec0:	45800115 	stw	r22,4(r8)
 8206ec4:	d8c02015 	stw	r3,128(sp)
 8206ec8:	d8801f15 	stw	r2,124(sp)
 8206ecc:	010001c4 	movi	r4,7
 8206ed0:	2081ee16 	blt	r4,r2,820768c <___vfprintf_internal_r+0x1154>
 8206ed4:	42000204 	addi	r8,r8,8
 8206ed8:	9080400c 	andi	r2,r18,256
 8206edc:	1001181e 	bne	r2,zero,8207340 <___vfprintf_internal_r+0xe08>
 8206ee0:	d9402e17 	ldw	r5,184(sp)
 8206ee4:	d8801f17 	ldw	r2,124(sp)
 8206ee8:	44000015 	stw	r16,0(r8)
 8206eec:	1947883a 	add	r3,r3,r5
 8206ef0:	10800044 	addi	r2,r2,1
 8206ef4:	41400115 	stw	r5,4(r8)
 8206ef8:	d8c02015 	stw	r3,128(sp)
 8206efc:	d8801f15 	stw	r2,124(sp)
 8206f00:	010001c4 	movi	r4,7
 8206f04:	2081d316 	blt	r4,r2,8207654 <___vfprintf_internal_r+0x111c>
 8206f08:	42000204 	addi	r8,r8,8
 8206f0c:	9480010c 	andi	r18,r18,4
 8206f10:	90003226 	beq	r18,zero,8206fdc <___vfprintf_internal_r+0xaa4>
 8206f14:	d9403117 	ldw	r5,196(sp)
 8206f18:	d8802a17 	ldw	r2,168(sp)
 8206f1c:	28a1c83a 	sub	r16,r5,r2
 8206f20:	04002e0e 	bge	zero,r16,8206fdc <___vfprintf_internal_r+0xaa4>
 8206f24:	04400404 	movi	r17,16
 8206f28:	d8801f17 	ldw	r2,124(sp)
 8206f2c:	8c04a20e 	bge	r17,r16,82081b8 <___vfprintf_internal_r+0x1c80>
 8206f30:	01420974 	movhi	r5,2085
 8206f34:	29756d84 	addi	r5,r5,-10826
 8206f38:	d9403515 	stw	r5,212(sp)
 8206f3c:	048001c4 	movi	r18,7
 8206f40:	dcc02c17 	ldw	r19,176(sp)
 8206f44:	00000306 	br	8206f54 <___vfprintf_internal_r+0xa1c>
 8206f48:	843ffc04 	addi	r16,r16,-16
 8206f4c:	42000204 	addi	r8,r8,8
 8206f50:	8c00130e 	bge	r17,r16,8206fa0 <___vfprintf_internal_r+0xa68>
 8206f54:	01020974 	movhi	r4,2085
 8206f58:	18c00404 	addi	r3,r3,16
 8206f5c:	10800044 	addi	r2,r2,1
 8206f60:	21356d84 	addi	r4,r4,-10826
 8206f64:	41000015 	stw	r4,0(r8)
 8206f68:	44400115 	stw	r17,4(r8)
 8206f6c:	d8c02015 	stw	r3,128(sp)
 8206f70:	d8801f15 	stw	r2,124(sp)
 8206f74:	90bff40e 	bge	r18,r2,8206f48 <___vfprintf_internal_r+0xa10>
 8206f78:	d9801e04 	addi	r6,sp,120
 8206f7c:	b80b883a 	mov	r5,r23
 8206f80:	9809883a 	mov	r4,r19
 8206f84:	820f08c0 	call	820f08c <__sprint_r>
 8206f88:	103e6d1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8206f8c:	843ffc04 	addi	r16,r16,-16
 8206f90:	d8c02017 	ldw	r3,128(sp)
 8206f94:	d8801f17 	ldw	r2,124(sp)
 8206f98:	da000404 	addi	r8,sp,16
 8206f9c:	8c3fed16 	blt	r17,r16,8206f54 <___vfprintf_internal_r+0xa1c>
 8206fa0:	d9403517 	ldw	r5,212(sp)
 8206fa4:	1c07883a 	add	r3,r3,r16
 8206fa8:	10800044 	addi	r2,r2,1
 8206fac:	41400015 	stw	r5,0(r8)
 8206fb0:	44000115 	stw	r16,4(r8)
 8206fb4:	d8c02015 	stw	r3,128(sp)
 8206fb8:	d8801f15 	stw	r2,124(sp)
 8206fbc:	010001c4 	movi	r4,7
 8206fc0:	2080060e 	bge	r4,r2,8206fdc <___vfprintf_internal_r+0xaa4>
 8206fc4:	d9002c17 	ldw	r4,176(sp)
 8206fc8:	d9801e04 	addi	r6,sp,120
 8206fcc:	b80b883a 	mov	r5,r23
 8206fd0:	820f08c0 	call	820f08c <__sprint_r>
 8206fd4:	103e5a1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8206fd8:	d8c02017 	ldw	r3,128(sp)
 8206fdc:	d8803117 	ldw	r2,196(sp)
 8206fe0:	d9002a17 	ldw	r4,168(sp)
 8206fe4:	1100010e 	bge	r2,r4,8206fec <___vfprintf_internal_r+0xab4>
 8206fe8:	2005883a 	mov	r2,r4
 8206fec:	d9402f17 	ldw	r5,188(sp)
 8206ff0:	288b883a 	add	r5,r5,r2
 8206ff4:	d9402f15 	stw	r5,188(sp)
 8206ff8:	18019e1e 	bne	r3,zero,8207674 <___vfprintf_internal_r+0x113c>
 8206ffc:	a8800007 	ldb	r2,0(r21)
 8207000:	d8001f15 	stw	zero,124(sp)
 8207004:	da000404 	addi	r8,sp,16
 8207008:	103d851e 	bne	r2,zero,8206620 <___vfprintf_internal_r+0xe8>
 820700c:	a821883a 	mov	r16,r21
 8207010:	003d9b06 	br	8206680 <___vfprintf_internal_r+0x148>
 8207014:	18c03fcc 	andi	r3,r3,255
 8207018:	1805c11e 	bne	r3,zero,8208720 <___vfprintf_internal_r+0x21e8>
 820701c:	94800414 	ori	r18,r18,16
 8207020:	9080080c 	andi	r2,r18,32
 8207024:	10020c26 	beq	r2,zero,8207858 <___vfprintf_internal_r+0x1320>
 8207028:	d8802d17 	ldw	r2,180(sp)
 820702c:	d9002917 	ldw	r4,164(sp)
 8207030:	d8002785 	stb	zero,158(sp)
 8207034:	10c00204 	addi	r3,r2,8
 8207038:	14c00017 	ldw	r19,0(r2)
 820703c:	15800117 	ldw	r22,4(r2)
 8207040:	20040f16 	blt	r4,zero,8208080 <___vfprintf_internal_r+0x1b48>
 8207044:	013fdfc4 	movi	r4,-129
 8207048:	9d84b03a 	or	r2,r19,r22
 820704c:	d8c02d15 	stw	r3,180(sp)
 8207050:	9124703a 	and	r18,r18,r4
 8207054:	0039883a 	mov	fp,zero
 8207058:	103e891e 	bne	r2,zero,8206a80 <___vfprintf_internal_r+0x548>
 820705c:	d9002917 	ldw	r4,164(sp)
 8207060:	2002c11e 	bne	r4,zero,8207b68 <___vfprintf_internal_r+0x1630>
 8207064:	d8002915 	stw	zero,164(sp)
 8207068:	d8002e15 	stw	zero,184(sp)
 820706c:	dc001e04 	addi	r16,sp,120
 8207070:	003ef806 	br	8206c54 <___vfprintf_internal_r+0x71c>
 8207074:	18c03fcc 	andi	r3,r3,255
 8207078:	18059d1e 	bne	r3,zero,82086f0 <___vfprintf_internal_r+0x21b8>
 820707c:	01420974 	movhi	r5,2085
 8207080:	29755504 	addi	r5,r5,-10924
 8207084:	d9403915 	stw	r5,228(sp)
 8207088:	9080080c 	andi	r2,r18,32
 820708c:	10005226 	beq	r2,zero,82071d8 <___vfprintf_internal_r+0xca0>
 8207090:	d8802d17 	ldw	r2,180(sp)
 8207094:	14c00017 	ldw	r19,0(r2)
 8207098:	15800117 	ldw	r22,4(r2)
 820709c:	10800204 	addi	r2,r2,8
 82070a0:	d8802d15 	stw	r2,180(sp)
 82070a4:	9080004c 	andi	r2,r18,1
 82070a8:	10019026 	beq	r2,zero,82076ec <___vfprintf_internal_r+0x11b4>
 82070ac:	9d84b03a 	or	r2,r19,r22
 82070b0:	10036926 	beq	r2,zero,8207e58 <___vfprintf_internal_r+0x1920>
 82070b4:	d8c02917 	ldw	r3,164(sp)
 82070b8:	00800c04 	movi	r2,48
 82070bc:	d8802705 	stb	r2,156(sp)
 82070c0:	dc402745 	stb	r17,157(sp)
 82070c4:	d8002785 	stb	zero,158(sp)
 82070c8:	90800094 	ori	r2,r18,2
 82070cc:	18045d16 	blt	r3,zero,8208244 <___vfprintf_internal_r+0x1d0c>
 82070d0:	00bfdfc4 	movi	r2,-129
 82070d4:	90a4703a 	and	r18,r18,r2
 82070d8:	94800094 	ori	r18,r18,2
 82070dc:	0039883a 	mov	fp,zero
 82070e0:	d9003917 	ldw	r4,228(sp)
 82070e4:	dc001e04 	addi	r16,sp,120
 82070e8:	988003cc 	andi	r2,r19,15
 82070ec:	b006973a 	slli	r3,r22,28
 82070f0:	2085883a 	add	r2,r4,r2
 82070f4:	9826d13a 	srli	r19,r19,4
 82070f8:	10800003 	ldbu	r2,0(r2)
 82070fc:	b02cd13a 	srli	r22,r22,4
 8207100:	843fffc4 	addi	r16,r16,-1
 8207104:	1ce6b03a 	or	r19,r3,r19
 8207108:	80800005 	stb	r2,0(r16)
 820710c:	9d84b03a 	or	r2,r19,r22
 8207110:	103ff51e 	bne	r2,zero,82070e8 <___vfprintf_internal_r+0xbb0>
 8207114:	d8c02817 	ldw	r3,160(sp)
 8207118:	1c07c83a 	sub	r3,r3,r16
 820711c:	d8c02e15 	stw	r3,184(sp)
 8207120:	003ecc06 	br	8206c54 <___vfprintf_internal_r+0x71c>
 8207124:	18c03fcc 	andi	r3,r3,255
 8207128:	183e9f26 	beq	r3,zero,8206ba8 <___vfprintf_internal_r+0x670>
 820712c:	d9c02785 	stb	r7,158(sp)
 8207130:	003e9d06 	br	8206ba8 <___vfprintf_internal_r+0x670>
 8207134:	00c00044 	movi	r3,1
 8207138:	01c00ac4 	movi	r7,43
 820713c:	ac400007 	ldb	r17,0(r21)
 8207140:	003d5e06 	br	82066bc <___vfprintf_internal_r+0x184>
 8207144:	94800814 	ori	r18,r18,32
 8207148:	ac400007 	ldb	r17,0(r21)
 820714c:	003d5b06 	br	82066bc <___vfprintf_internal_r+0x184>
 8207150:	d8c02d17 	ldw	r3,180(sp)
 8207154:	d8002785 	stb	zero,158(sp)
 8207158:	1c000017 	ldw	r16,0(r3)
 820715c:	1cc00104 	addi	r19,r3,4
 8207160:	80041926 	beq	r16,zero,82081c8 <___vfprintf_internal_r+0x1c90>
 8207164:	d9002917 	ldw	r4,164(sp)
 8207168:	2003d016 	blt	r4,zero,82080ac <___vfprintf_internal_r+0x1b74>
 820716c:	200d883a 	mov	r6,r4
 8207170:	000b883a 	mov	r5,zero
 8207174:	8009883a 	mov	r4,r16
 8207178:	da003d15 	stw	r8,244(sp)
 820717c:	820bff40 	call	820bff4 <memchr>
 8207180:	da003d17 	ldw	r8,244(sp)
 8207184:	10045426 	beq	r2,zero,82082d8 <___vfprintf_internal_r+0x1da0>
 8207188:	1405c83a 	sub	r2,r2,r16
 820718c:	d8802e15 	stw	r2,184(sp)
 8207190:	1003cc16 	blt	r2,zero,82080c4 <___vfprintf_internal_r+0x1b8c>
 8207194:	df002783 	ldbu	fp,158(sp)
 8207198:	d8802a15 	stw	r2,168(sp)
 820719c:	dcc02d15 	stw	r19,180(sp)
 82071a0:	d8002915 	stw	zero,164(sp)
 82071a4:	d8003215 	stw	zero,200(sp)
 82071a8:	003eb006 	br	8206c6c <___vfprintf_internal_r+0x734>
 82071ac:	18c03fcc 	andi	r3,r3,255
 82071b0:	183f9b26 	beq	r3,zero,8207020 <___vfprintf_internal_r+0xae8>
 82071b4:	d9c02785 	stb	r7,158(sp)
 82071b8:	003f9906 	br	8207020 <___vfprintf_internal_r+0xae8>
 82071bc:	18c03fcc 	andi	r3,r3,255
 82071c0:	1805551e 	bne	r3,zero,8208718 <___vfprintf_internal_r+0x21e0>
 82071c4:	01420974 	movhi	r5,2085
 82071c8:	29755a04 	addi	r5,r5,-10904
 82071cc:	d9403915 	stw	r5,228(sp)
 82071d0:	9080080c 	andi	r2,r18,32
 82071d4:	103fae1e 	bne	r2,zero,8207090 <___vfprintf_internal_r+0xb58>
 82071d8:	9080040c 	andi	r2,r18,16
 82071dc:	1002de26 	beq	r2,zero,8207d58 <___vfprintf_internal_r+0x1820>
 82071e0:	d8c02d17 	ldw	r3,180(sp)
 82071e4:	002d883a 	mov	r22,zero
 82071e8:	1cc00017 	ldw	r19,0(r3)
 82071ec:	18c00104 	addi	r3,r3,4
 82071f0:	d8c02d15 	stw	r3,180(sp)
 82071f4:	003fab06 	br	82070a4 <___vfprintf_internal_r+0xb6c>
 82071f8:	38803fcc 	andi	r2,r7,255
 82071fc:	1080201c 	xori	r2,r2,128
 8207200:	10bfe004 	addi	r2,r2,-128
 8207204:	1002d21e 	bne	r2,zero,8207d50 <___vfprintf_internal_r+0x1818>
 8207208:	00c00044 	movi	r3,1
 820720c:	01c00804 	movi	r7,32
 8207210:	ac400007 	ldb	r17,0(r21)
 8207214:	003d2906 	br	82066bc <___vfprintf_internal_r+0x184>
 8207218:	94800054 	ori	r18,r18,1
 820721c:	ac400007 	ldb	r17,0(r21)
 8207220:	003d2606 	br	82066bc <___vfprintf_internal_r+0x184>
 8207224:	18c03fcc 	andi	r3,r3,255
 8207228:	183e0526 	beq	r3,zero,8206a40 <___vfprintf_internal_r+0x508>
 820722c:	d9c02785 	stb	r7,158(sp)
 8207230:	003e0306 	br	8206a40 <___vfprintf_internal_r+0x508>
 8207234:	94801014 	ori	r18,r18,64
 8207238:	ac400007 	ldb	r17,0(r21)
 820723c:	003d1f06 	br	82066bc <___vfprintf_internal_r+0x184>
 8207240:	ac400007 	ldb	r17,0(r21)
 8207244:	8a438726 	beq	r17,r9,8208064 <___vfprintf_internal_r+0x1b2c>
 8207248:	94800414 	ori	r18,r18,16
 820724c:	003d1b06 	br	82066bc <___vfprintf_internal_r+0x184>
 8207250:	18c03fcc 	andi	r3,r3,255
 8207254:	1805341e 	bne	r3,zero,8208728 <___vfprintf_internal_r+0x21f0>
 8207258:	9080080c 	andi	r2,r18,32
 820725c:	1002cd26 	beq	r2,zero,8207d94 <___vfprintf_internal_r+0x185c>
 8207260:	d9402d17 	ldw	r5,180(sp)
 8207264:	d9002f17 	ldw	r4,188(sp)
 8207268:	28800017 	ldw	r2,0(r5)
 820726c:	2007d7fa 	srai	r3,r4,31
 8207270:	29400104 	addi	r5,r5,4
 8207274:	d9402d15 	stw	r5,180(sp)
 8207278:	11000015 	stw	r4,0(r2)
 820727c:	10c00115 	stw	r3,4(r2)
 8207280:	003ce506 	br	8206618 <___vfprintf_internal_r+0xe0>
 8207284:	d8c02d17 	ldw	r3,180(sp)
 8207288:	d9002d17 	ldw	r4,180(sp)
 820728c:	d8002785 	stb	zero,158(sp)
 8207290:	18800017 	ldw	r2,0(r3)
 8207294:	21000104 	addi	r4,r4,4
 8207298:	00c00044 	movi	r3,1
 820729c:	d8c02a15 	stw	r3,168(sp)
 82072a0:	d8801405 	stb	r2,80(sp)
 82072a4:	d9002d15 	stw	r4,180(sp)
 82072a8:	d8c02e15 	stw	r3,184(sp)
 82072ac:	d8002915 	stw	zero,164(sp)
 82072b0:	d8003215 	stw	zero,200(sp)
 82072b4:	dc001404 	addi	r16,sp,80
 82072b8:	0039883a 	mov	fp,zero
 82072bc:	003e7206 	br	8206c88 <___vfprintf_internal_r+0x750>
 82072c0:	01020974 	movhi	r4,2085
 82072c4:	21355a04 	addi	r4,r4,-10904
 82072c8:	0039883a 	mov	fp,zero
 82072cc:	d9003915 	stw	r4,228(sp)
 82072d0:	04401e04 	movi	r17,120
 82072d4:	003f8206 	br	82070e0 <___vfprintf_internal_r+0xba8>
 82072d8:	18c03fcc 	andi	r3,r3,255
 82072dc:	1805061e 	bne	r3,zero,82086f8 <___vfprintf_internal_r+0x21c0>
 82072e0:	883d9126 	beq	r17,zero,8206928 <___vfprintf_internal_r+0x3f0>
 82072e4:	00c00044 	movi	r3,1
 82072e8:	d8c02a15 	stw	r3,168(sp)
 82072ec:	dc401405 	stb	r17,80(sp)
 82072f0:	d8002785 	stb	zero,158(sp)
 82072f4:	003fec06 	br	82072a8 <___vfprintf_internal_r+0xd70>
 82072f8:	01420974 	movhi	r5,2085
 82072fc:	29755a04 	addi	r5,r5,-10904
 8207300:	d9403915 	stw	r5,228(sp)
 8207304:	d8c02d15 	stw	r3,180(sp)
 8207308:	1025883a 	mov	r18,r2
 820730c:	04401e04 	movi	r17,120
 8207310:	9d84b03a 	or	r2,r19,r22
 8207314:	1000fc1e 	bne	r2,zero,8207708 <___vfprintf_internal_r+0x11d0>
 8207318:	0039883a 	mov	fp,zero
 820731c:	00800084 	movi	r2,2
 8207320:	10803fcc 	andi	r2,r2,255
 8207324:	00c00044 	movi	r3,1
 8207328:	10c20f26 	beq	r2,r3,8207b68 <___vfprintf_internal_r+0x1630>
 820732c:	00c00084 	movi	r3,2
 8207330:	10fd6326 	beq	r2,r3,82068c0 <___vfprintf_internal_r+0x388>
 8207334:	003e2d06 	br	8206bec <___vfprintf_internal_r+0x6b4>
 8207338:	d8c02017 	ldw	r3,128(sp)
 820733c:	003e9306 	br	8206d8c <___vfprintf_internal_r+0x854>
 8207340:	00801944 	movi	r2,101
 8207344:	14407e0e 	bge	r2,r17,8207540 <___vfprintf_internal_r+0x1008>
 8207348:	d9003617 	ldw	r4,216(sp)
 820734c:	d9403817 	ldw	r5,224(sp)
 8207350:	000d883a 	mov	r6,zero
 8207354:	000f883a 	mov	r7,zero
 8207358:	d8c03c15 	stw	r3,240(sp)
 820735c:	da003d15 	stw	r8,244(sp)
 8207360:	82129f80 	call	82129f8 <__eqdf2>
 8207364:	d8c03c17 	ldw	r3,240(sp)
 8207368:	da003d17 	ldw	r8,244(sp)
 820736c:	1000f71e 	bne	r2,zero,820774c <___vfprintf_internal_r+0x1214>
 8207370:	d8801f17 	ldw	r2,124(sp)
 8207374:	01020974 	movhi	r4,2085
 8207378:	21356104 	addi	r4,r4,-10876
 820737c:	18c00044 	addi	r3,r3,1
 8207380:	10800044 	addi	r2,r2,1
 8207384:	41000015 	stw	r4,0(r8)
 8207388:	01000044 	movi	r4,1
 820738c:	41000115 	stw	r4,4(r8)
 8207390:	d8c02015 	stw	r3,128(sp)
 8207394:	d8801f15 	stw	r2,124(sp)
 8207398:	010001c4 	movi	r4,7
 820739c:	2082b816 	blt	r4,r2,8207e80 <___vfprintf_internal_r+0x1948>
 82073a0:	42000204 	addi	r8,r8,8
 82073a4:	d8802617 	ldw	r2,152(sp)
 82073a8:	d9403317 	ldw	r5,204(sp)
 82073ac:	11400216 	blt	r2,r5,82073b8 <___vfprintf_internal_r+0xe80>
 82073b0:	9080004c 	andi	r2,r18,1
 82073b4:	103ed526 	beq	r2,zero,8206f0c <___vfprintf_internal_r+0x9d4>
 82073b8:	d8803717 	ldw	r2,220(sp)
 82073bc:	d9003417 	ldw	r4,208(sp)
 82073c0:	d9403717 	ldw	r5,220(sp)
 82073c4:	1887883a 	add	r3,r3,r2
 82073c8:	d8801f17 	ldw	r2,124(sp)
 82073cc:	41000015 	stw	r4,0(r8)
 82073d0:	41400115 	stw	r5,4(r8)
 82073d4:	10800044 	addi	r2,r2,1
 82073d8:	d8c02015 	stw	r3,128(sp)
 82073dc:	d8801f15 	stw	r2,124(sp)
 82073e0:	010001c4 	movi	r4,7
 82073e4:	20832916 	blt	r4,r2,820808c <___vfprintf_internal_r+0x1b54>
 82073e8:	42000204 	addi	r8,r8,8
 82073ec:	d8803317 	ldw	r2,204(sp)
 82073f0:	143fffc4 	addi	r16,r2,-1
 82073f4:	043ec50e 	bge	zero,r16,8206f0c <___vfprintf_internal_r+0x9d4>
 82073f8:	04400404 	movi	r17,16
 82073fc:	d8801f17 	ldw	r2,124(sp)
 8207400:	8c00880e 	bge	r17,r16,8207624 <___vfprintf_internal_r+0x10ec>
 8207404:	01420974 	movhi	r5,2085
 8207408:	29756984 	addi	r5,r5,-10842
 820740c:	d9402b15 	stw	r5,172(sp)
 8207410:	058001c4 	movi	r22,7
 8207414:	dcc02c17 	ldw	r19,176(sp)
 8207418:	00000306 	br	8207428 <___vfprintf_internal_r+0xef0>
 820741c:	42000204 	addi	r8,r8,8
 8207420:	843ffc04 	addi	r16,r16,-16
 8207424:	8c00820e 	bge	r17,r16,8207630 <___vfprintf_internal_r+0x10f8>
 8207428:	18c00404 	addi	r3,r3,16
 820742c:	10800044 	addi	r2,r2,1
 8207430:	45000015 	stw	r20,0(r8)
 8207434:	44400115 	stw	r17,4(r8)
 8207438:	d8c02015 	stw	r3,128(sp)
 820743c:	d8801f15 	stw	r2,124(sp)
 8207440:	b0bff60e 	bge	r22,r2,820741c <___vfprintf_internal_r+0xee4>
 8207444:	d9801e04 	addi	r6,sp,120
 8207448:	b80b883a 	mov	r5,r23
 820744c:	9809883a 	mov	r4,r19
 8207450:	820f08c0 	call	820f08c <__sprint_r>
 8207454:	103d3a1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207458:	d8c02017 	ldw	r3,128(sp)
 820745c:	d8801f17 	ldw	r2,124(sp)
 8207460:	da000404 	addi	r8,sp,16
 8207464:	003fee06 	br	8207420 <___vfprintf_internal_r+0xee8>
 8207468:	d9403117 	ldw	r5,196(sp)
 820746c:	d8802a17 	ldw	r2,168(sp)
 8207470:	28adc83a 	sub	r22,r5,r2
 8207474:	05be630e 	bge	zero,r22,8206e04 <___vfprintf_internal_r+0x8cc>
 8207478:	07000404 	movi	fp,16
 820747c:	d8801f17 	ldw	r2,124(sp)
 8207480:	e5838f0e 	bge	fp,r22,82082c0 <___vfprintf_internal_r+0x1d88>
 8207484:	01420974 	movhi	r5,2085
 8207488:	29756984 	addi	r5,r5,-10842
 820748c:	dc403015 	stw	r17,192(sp)
 8207490:	d9402b15 	stw	r5,172(sp)
 8207494:	b023883a 	mov	r17,r22
 8207498:	04c001c4 	movi	r19,7
 820749c:	a82d883a 	mov	r22,r21
 82074a0:	902b883a 	mov	r21,r18
 82074a4:	8025883a 	mov	r18,r16
 82074a8:	dc002c17 	ldw	r16,176(sp)
 82074ac:	00000306 	br	82074bc <___vfprintf_internal_r+0xf84>
 82074b0:	8c7ffc04 	addi	r17,r17,-16
 82074b4:	42000204 	addi	r8,r8,8
 82074b8:	e440110e 	bge	fp,r17,8207500 <___vfprintf_internal_r+0xfc8>
 82074bc:	18c00404 	addi	r3,r3,16
 82074c0:	10800044 	addi	r2,r2,1
 82074c4:	45000015 	stw	r20,0(r8)
 82074c8:	47000115 	stw	fp,4(r8)
 82074cc:	d8c02015 	stw	r3,128(sp)
 82074d0:	d8801f15 	stw	r2,124(sp)
 82074d4:	98bff60e 	bge	r19,r2,82074b0 <___vfprintf_internal_r+0xf78>
 82074d8:	d9801e04 	addi	r6,sp,120
 82074dc:	b80b883a 	mov	r5,r23
 82074e0:	8009883a 	mov	r4,r16
 82074e4:	820f08c0 	call	820f08c <__sprint_r>
 82074e8:	103d151e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82074ec:	8c7ffc04 	addi	r17,r17,-16
 82074f0:	d8c02017 	ldw	r3,128(sp)
 82074f4:	d8801f17 	ldw	r2,124(sp)
 82074f8:	da000404 	addi	r8,sp,16
 82074fc:	e47fef16 	blt	fp,r17,82074bc <___vfprintf_internal_r+0xf84>
 8207500:	9021883a 	mov	r16,r18
 8207504:	a825883a 	mov	r18,r21
 8207508:	b02b883a 	mov	r21,r22
 820750c:	882d883a 	mov	r22,r17
 8207510:	dc403017 	ldw	r17,192(sp)
 8207514:	d9002b17 	ldw	r4,172(sp)
 8207518:	1d87883a 	add	r3,r3,r22
 820751c:	10800044 	addi	r2,r2,1
 8207520:	41000015 	stw	r4,0(r8)
 8207524:	45800115 	stw	r22,4(r8)
 8207528:	d8c02015 	stw	r3,128(sp)
 820752c:	d8801f15 	stw	r2,124(sp)
 8207530:	010001c4 	movi	r4,7
 8207534:	20818e16 	blt	r4,r2,8207b70 <___vfprintf_internal_r+0x1638>
 8207538:	42000204 	addi	r8,r8,8
 820753c:	003e3106 	br	8206e04 <___vfprintf_internal_r+0x8cc>
 8207540:	d9403317 	ldw	r5,204(sp)
 8207544:	00800044 	movi	r2,1
 8207548:	18c00044 	addi	r3,r3,1
 820754c:	1141530e 	bge	r2,r5,8207a9c <___vfprintf_internal_r+0x1564>
 8207550:	dc401f17 	ldw	r17,124(sp)
 8207554:	00800044 	movi	r2,1
 8207558:	40800115 	stw	r2,4(r8)
 820755c:	8c400044 	addi	r17,r17,1
 8207560:	44000015 	stw	r16,0(r8)
 8207564:	d8c02015 	stw	r3,128(sp)
 8207568:	dc401f15 	stw	r17,124(sp)
 820756c:	008001c4 	movi	r2,7
 8207570:	14416b16 	blt	r2,r17,8207b20 <___vfprintf_internal_r+0x15e8>
 8207574:	42000204 	addi	r8,r8,8
 8207578:	d8803717 	ldw	r2,220(sp)
 820757c:	d9003417 	ldw	r4,208(sp)
 8207580:	8c400044 	addi	r17,r17,1
 8207584:	10c7883a 	add	r3,r2,r3
 8207588:	40800115 	stw	r2,4(r8)
 820758c:	41000015 	stw	r4,0(r8)
 8207590:	d8c02015 	stw	r3,128(sp)
 8207594:	dc401f15 	stw	r17,124(sp)
 8207598:	008001c4 	movi	r2,7
 820759c:	14416916 	blt	r2,r17,8207b44 <___vfprintf_internal_r+0x160c>
 82075a0:	45800204 	addi	r22,r8,8
 82075a4:	d9003617 	ldw	r4,216(sp)
 82075a8:	d9403817 	ldw	r5,224(sp)
 82075ac:	000d883a 	mov	r6,zero
 82075b0:	000f883a 	mov	r7,zero
 82075b4:	d8c03c15 	stw	r3,240(sp)
 82075b8:	82129f80 	call	82129f8 <__eqdf2>
 82075bc:	d8c03c17 	ldw	r3,240(sp)
 82075c0:	1000bc26 	beq	r2,zero,82078b4 <___vfprintf_internal_r+0x137c>
 82075c4:	d9403317 	ldw	r5,204(sp)
 82075c8:	84000044 	addi	r16,r16,1
 82075cc:	8c400044 	addi	r17,r17,1
 82075d0:	28bfffc4 	addi	r2,r5,-1
 82075d4:	1887883a 	add	r3,r3,r2
 82075d8:	b0800115 	stw	r2,4(r22)
 82075dc:	b4000015 	stw	r16,0(r22)
 82075e0:	d8c02015 	stw	r3,128(sp)
 82075e4:	dc401f15 	stw	r17,124(sp)
 82075e8:	008001c4 	movi	r2,7
 82075ec:	14414316 	blt	r2,r17,8207afc <___vfprintf_internal_r+0x15c4>
 82075f0:	b5800204 	addi	r22,r22,8
 82075f4:	d9003a17 	ldw	r4,232(sp)
 82075f8:	df0022c4 	addi	fp,sp,139
 82075fc:	8c400044 	addi	r17,r17,1
 8207600:	20c7883a 	add	r3,r4,r3
 8207604:	b7000015 	stw	fp,0(r22)
 8207608:	b1000115 	stw	r4,4(r22)
 820760c:	d8c02015 	stw	r3,128(sp)
 8207610:	dc401f15 	stw	r17,124(sp)
 8207614:	008001c4 	movi	r2,7
 8207618:	14400e16 	blt	r2,r17,8207654 <___vfprintf_internal_r+0x111c>
 820761c:	b2000204 	addi	r8,r22,8
 8207620:	003e3a06 	br	8206f0c <___vfprintf_internal_r+0x9d4>
 8207624:	01020974 	movhi	r4,2085
 8207628:	21356984 	addi	r4,r4,-10842
 820762c:	d9002b15 	stw	r4,172(sp)
 8207630:	d9002b17 	ldw	r4,172(sp)
 8207634:	1c07883a 	add	r3,r3,r16
 8207638:	44000115 	stw	r16,4(r8)
 820763c:	41000015 	stw	r4,0(r8)
 8207640:	10800044 	addi	r2,r2,1
 8207644:	d8c02015 	stw	r3,128(sp)
 8207648:	d8801f15 	stw	r2,124(sp)
 820764c:	010001c4 	movi	r4,7
 8207650:	20be2d0e 	bge	r4,r2,8206f08 <___vfprintf_internal_r+0x9d0>
 8207654:	d9002c17 	ldw	r4,176(sp)
 8207658:	d9801e04 	addi	r6,sp,120
 820765c:	b80b883a 	mov	r5,r23
 8207660:	820f08c0 	call	820f08c <__sprint_r>
 8207664:	103cb61e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207668:	d8c02017 	ldw	r3,128(sp)
 820766c:	da000404 	addi	r8,sp,16
 8207670:	003e2606 	br	8206f0c <___vfprintf_internal_r+0x9d4>
 8207674:	d9002c17 	ldw	r4,176(sp)
 8207678:	d9801e04 	addi	r6,sp,120
 820767c:	b80b883a 	mov	r5,r23
 8207680:	820f08c0 	call	820f08c <__sprint_r>
 8207684:	103e5d26 	beq	r2,zero,8206ffc <___vfprintf_internal_r+0xac4>
 8207688:	003cad06 	br	8206940 <___vfprintf_internal_r+0x408>
 820768c:	d9002c17 	ldw	r4,176(sp)
 8207690:	d9801e04 	addi	r6,sp,120
 8207694:	b80b883a 	mov	r5,r23
 8207698:	820f08c0 	call	820f08c <__sprint_r>
 820769c:	103ca81e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82076a0:	d8c02017 	ldw	r3,128(sp)
 82076a4:	da000404 	addi	r8,sp,16
 82076a8:	003e0b06 	br	8206ed8 <___vfprintf_internal_r+0x9a0>
 82076ac:	d9002c17 	ldw	r4,176(sp)
 82076b0:	d9801e04 	addi	r6,sp,120
 82076b4:	b80b883a 	mov	r5,r23
 82076b8:	820f08c0 	call	820f08c <__sprint_r>
 82076bc:	103ca01e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82076c0:	d8c02017 	ldw	r3,128(sp)
 82076c4:	da000404 	addi	r8,sp,16
 82076c8:	003dbd06 	br	8206dc0 <___vfprintf_internal_r+0x888>
 82076cc:	d9002c17 	ldw	r4,176(sp)
 82076d0:	d9801e04 	addi	r6,sp,120
 82076d4:	b80b883a 	mov	r5,r23
 82076d8:	820f08c0 	call	820f08c <__sprint_r>
 82076dc:	103c981e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82076e0:	d8c02017 	ldw	r3,128(sp)
 82076e4:	da000404 	addi	r8,sp,16
 82076e8:	003dc306 	br	8206df8 <___vfprintf_internal_r+0x8c0>
 82076ec:	d8802917 	ldw	r2,164(sp)
 82076f0:	d8002785 	stb	zero,158(sp)
 82076f4:	103f0616 	blt	r2,zero,8207310 <___vfprintf_internal_r+0xdd8>
 82076f8:	00ffdfc4 	movi	r3,-129
 82076fc:	9d84b03a 	or	r2,r19,r22
 8207700:	90e4703a 	and	r18,r18,r3
 8207704:	103c6b26 	beq	r2,zero,82068b4 <___vfprintf_internal_r+0x37c>
 8207708:	0039883a 	mov	fp,zero
 820770c:	003e7406 	br	82070e0 <___vfprintf_internal_r+0xba8>
 8207710:	9080040c 	andi	r2,r18,16
 8207714:	1001b326 	beq	r2,zero,8207de4 <___vfprintf_internal_r+0x18ac>
 8207718:	d9002d17 	ldw	r4,180(sp)
 820771c:	d9402917 	ldw	r5,164(sp)
 8207720:	d8002785 	stb	zero,158(sp)
 8207724:	20800104 	addi	r2,r4,4
 8207728:	24c00017 	ldw	r19,0(r4)
 820772c:	002d883a 	mov	r22,zero
 8207730:	2801b516 	blt	r5,zero,8207e08 <___vfprintf_internal_r+0x18d0>
 8207734:	00ffdfc4 	movi	r3,-129
 8207738:	d8802d15 	stw	r2,180(sp)
 820773c:	90e4703a 	and	r18,r18,r3
 8207740:	983d2726 	beq	r19,zero,8206be0 <___vfprintf_internal_r+0x6a8>
 8207744:	0039883a 	mov	fp,zero
 8207748:	003d2a06 	br	8206bf4 <___vfprintf_internal_r+0x6bc>
 820774c:	dc402617 	ldw	r17,152(sp)
 8207750:	0441d30e 	bge	zero,r17,8207ea0 <___vfprintf_internal_r+0x1968>
 8207754:	dc403217 	ldw	r17,200(sp)
 8207758:	d8803317 	ldw	r2,204(sp)
 820775c:	1440010e 	bge	r2,r17,8207764 <___vfprintf_internal_r+0x122c>
 8207760:	1023883a 	mov	r17,r2
 8207764:	04400a0e 	bge	zero,r17,8207790 <___vfprintf_internal_r+0x1258>
 8207768:	d8801f17 	ldw	r2,124(sp)
 820776c:	1c47883a 	add	r3,r3,r17
 8207770:	44000015 	stw	r16,0(r8)
 8207774:	10800044 	addi	r2,r2,1
 8207778:	44400115 	stw	r17,4(r8)
 820777c:	d8c02015 	stw	r3,128(sp)
 8207780:	d8801f15 	stw	r2,124(sp)
 8207784:	010001c4 	movi	r4,7
 8207788:	20826516 	blt	r4,r2,8208120 <___vfprintf_internal_r+0x1be8>
 820778c:	42000204 	addi	r8,r8,8
 8207790:	88026116 	blt	r17,zero,8208118 <___vfprintf_internal_r+0x1be0>
 8207794:	d9003217 	ldw	r4,200(sp)
 8207798:	2463c83a 	sub	r17,r4,r17
 820779c:	04407b0e 	bge	zero,r17,820798c <___vfprintf_internal_r+0x1454>
 82077a0:	05800404 	movi	r22,16
 82077a4:	d8801f17 	ldw	r2,124(sp)
 82077a8:	b4419d0e 	bge	r22,r17,8207e20 <___vfprintf_internal_r+0x18e8>
 82077ac:	01020974 	movhi	r4,2085
 82077b0:	21356984 	addi	r4,r4,-10842
 82077b4:	d9002b15 	stw	r4,172(sp)
 82077b8:	070001c4 	movi	fp,7
 82077bc:	dcc02c17 	ldw	r19,176(sp)
 82077c0:	00000306 	br	82077d0 <___vfprintf_internal_r+0x1298>
 82077c4:	42000204 	addi	r8,r8,8
 82077c8:	8c7ffc04 	addi	r17,r17,-16
 82077cc:	b441970e 	bge	r22,r17,8207e2c <___vfprintf_internal_r+0x18f4>
 82077d0:	18c00404 	addi	r3,r3,16
 82077d4:	10800044 	addi	r2,r2,1
 82077d8:	45000015 	stw	r20,0(r8)
 82077dc:	45800115 	stw	r22,4(r8)
 82077e0:	d8c02015 	stw	r3,128(sp)
 82077e4:	d8801f15 	stw	r2,124(sp)
 82077e8:	e0bff60e 	bge	fp,r2,82077c4 <___vfprintf_internal_r+0x128c>
 82077ec:	d9801e04 	addi	r6,sp,120
 82077f0:	b80b883a 	mov	r5,r23
 82077f4:	9809883a 	mov	r4,r19
 82077f8:	820f08c0 	call	820f08c <__sprint_r>
 82077fc:	103c501e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207800:	d8c02017 	ldw	r3,128(sp)
 8207804:	d8801f17 	ldw	r2,124(sp)
 8207808:	da000404 	addi	r8,sp,16
 820780c:	003fee06 	br	82077c8 <___vfprintf_internal_r+0x1290>
 8207810:	d9002c17 	ldw	r4,176(sp)
 8207814:	d9801e04 	addi	r6,sp,120
 8207818:	b80b883a 	mov	r5,r23
 820781c:	820f08c0 	call	820f08c <__sprint_r>
 8207820:	103c471e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207824:	d8c02017 	ldw	r3,128(sp)
 8207828:	df002787 	ldb	fp,158(sp)
 820782c:	da000404 	addi	r8,sp,16
 8207830:	003d5606 	br	8206d8c <___vfprintf_internal_r+0x854>
 8207834:	9080040c 	andi	r2,r18,16
 8207838:	10016126 	beq	r2,zero,8207dc0 <___vfprintf_internal_r+0x1888>
 820783c:	d8802d17 	ldw	r2,180(sp)
 8207840:	14c00017 	ldw	r19,0(r2)
 8207844:	10800104 	addi	r2,r2,4
 8207848:	d8802d15 	stw	r2,180(sp)
 820784c:	982dd7fa 	srai	r22,r19,31
 8207850:	b005883a 	mov	r2,r22
 8207854:	003c8206 	br	8206a60 <___vfprintf_internal_r+0x528>
 8207858:	9080040c 	andi	r2,r18,16
 820785c:	10003526 	beq	r2,zero,8207934 <___vfprintf_internal_r+0x13fc>
 8207860:	d9402d17 	ldw	r5,180(sp)
 8207864:	d8c02917 	ldw	r3,164(sp)
 8207868:	d8002785 	stb	zero,158(sp)
 820786c:	28800104 	addi	r2,r5,4
 8207870:	2cc00017 	ldw	r19,0(r5)
 8207874:	002d883a 	mov	r22,zero
 8207878:	18003716 	blt	r3,zero,8207958 <___vfprintf_internal_r+0x1420>
 820787c:	00ffdfc4 	movi	r3,-129
 8207880:	d8802d15 	stw	r2,180(sp)
 8207884:	90e4703a 	and	r18,r18,r3
 8207888:	0039883a 	mov	fp,zero
 820788c:	983df326 	beq	r19,zero,820705c <___vfprintf_internal_r+0xb24>
 8207890:	00800244 	movi	r2,9
 8207894:	14fc7b36 	bltu	r2,r19,8206a84 <___vfprintf_internal_r+0x54c>
 8207898:	d8c02817 	ldw	r3,160(sp)
 820789c:	dc001dc4 	addi	r16,sp,119
 82078a0:	9cc00c04 	addi	r19,r19,48
 82078a4:	1c07c83a 	sub	r3,r3,r16
 82078a8:	dcc01dc5 	stb	r19,119(sp)
 82078ac:	d8c02e15 	stw	r3,184(sp)
 82078b0:	003ce806 	br	8206c54 <___vfprintf_internal_r+0x71c>
 82078b4:	d8803317 	ldw	r2,204(sp)
 82078b8:	143fffc4 	addi	r16,r2,-1
 82078bc:	043f4d0e 	bge	zero,r16,82075f4 <___vfprintf_internal_r+0x10bc>
 82078c0:	07000404 	movi	fp,16
 82078c4:	e400810e 	bge	fp,r16,8207acc <___vfprintf_internal_r+0x1594>
 82078c8:	01420974 	movhi	r5,2085
 82078cc:	29756984 	addi	r5,r5,-10842
 82078d0:	d9402b15 	stw	r5,172(sp)
 82078d4:	01c001c4 	movi	r7,7
 82078d8:	dcc02c17 	ldw	r19,176(sp)
 82078dc:	00000306 	br	82078ec <___vfprintf_internal_r+0x13b4>
 82078e0:	b5800204 	addi	r22,r22,8
 82078e4:	843ffc04 	addi	r16,r16,-16
 82078e8:	e4007b0e 	bge	fp,r16,8207ad8 <___vfprintf_internal_r+0x15a0>
 82078ec:	18c00404 	addi	r3,r3,16
 82078f0:	8c400044 	addi	r17,r17,1
 82078f4:	b5000015 	stw	r20,0(r22)
 82078f8:	b7000115 	stw	fp,4(r22)
 82078fc:	d8c02015 	stw	r3,128(sp)
 8207900:	dc401f15 	stw	r17,124(sp)
 8207904:	3c7ff60e 	bge	r7,r17,82078e0 <___vfprintf_internal_r+0x13a8>
 8207908:	d9801e04 	addi	r6,sp,120
 820790c:	b80b883a 	mov	r5,r23
 8207910:	9809883a 	mov	r4,r19
 8207914:	d9c03c15 	stw	r7,240(sp)
 8207918:	820f08c0 	call	820f08c <__sprint_r>
 820791c:	d9c03c17 	ldw	r7,240(sp)
 8207920:	103c071e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207924:	d8c02017 	ldw	r3,128(sp)
 8207928:	dc401f17 	ldw	r17,124(sp)
 820792c:	dd800404 	addi	r22,sp,16
 8207930:	003fec06 	br	82078e4 <___vfprintf_internal_r+0x13ac>
 8207934:	9080100c 	andi	r2,r18,64
 8207938:	d8002785 	stb	zero,158(sp)
 820793c:	10010e26 	beq	r2,zero,8207d78 <___vfprintf_internal_r+0x1840>
 8207940:	d9002d17 	ldw	r4,180(sp)
 8207944:	d9402917 	ldw	r5,164(sp)
 8207948:	002d883a 	mov	r22,zero
 820794c:	20800104 	addi	r2,r4,4
 8207950:	24c0000b 	ldhu	r19,0(r4)
 8207954:	283fc90e 	bge	r5,zero,820787c <___vfprintf_internal_r+0x1344>
 8207958:	d8802d15 	stw	r2,180(sp)
 820795c:	0039883a 	mov	fp,zero
 8207960:	9d84b03a 	or	r2,r19,r22
 8207964:	103c461e 	bne	r2,zero,8206a80 <___vfprintf_internal_r+0x548>
 8207968:	00800044 	movi	r2,1
 820796c:	003e6c06 	br	8207320 <___vfprintf_internal_r+0xde8>
 8207970:	d9002c17 	ldw	r4,176(sp)
 8207974:	d9801e04 	addi	r6,sp,120
 8207978:	b80b883a 	mov	r5,r23
 820797c:	820f08c0 	call	820f08c <__sprint_r>
 8207980:	103bef1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207984:	d8c02017 	ldw	r3,128(sp)
 8207988:	da000404 	addi	r8,sp,16
 820798c:	d9003217 	ldw	r4,200(sp)
 8207990:	d8802617 	ldw	r2,152(sp)
 8207994:	d9403317 	ldw	r5,204(sp)
 8207998:	8123883a 	add	r17,r16,r4
 820799c:	11400216 	blt	r2,r5,82079a8 <___vfprintf_internal_r+0x1470>
 82079a0:	9100004c 	andi	r4,r18,1
 82079a4:	20000d26 	beq	r4,zero,82079dc <___vfprintf_internal_r+0x14a4>
 82079a8:	d9003717 	ldw	r4,220(sp)
 82079ac:	d9403417 	ldw	r5,208(sp)
 82079b0:	1907883a 	add	r3,r3,r4
 82079b4:	d9001f17 	ldw	r4,124(sp)
 82079b8:	41400015 	stw	r5,0(r8)
 82079bc:	d9403717 	ldw	r5,220(sp)
 82079c0:	21000044 	addi	r4,r4,1
 82079c4:	d8c02015 	stw	r3,128(sp)
 82079c8:	41400115 	stw	r5,4(r8)
 82079cc:	d9001f15 	stw	r4,124(sp)
 82079d0:	014001c4 	movi	r5,7
 82079d4:	2901e816 	blt	r5,r4,8208178 <___vfprintf_internal_r+0x1c40>
 82079d8:	42000204 	addi	r8,r8,8
 82079dc:	d9003317 	ldw	r4,204(sp)
 82079e0:	8121883a 	add	r16,r16,r4
 82079e4:	2085c83a 	sub	r2,r4,r2
 82079e8:	8461c83a 	sub	r16,r16,r17
 82079ec:	1400010e 	bge	r2,r16,82079f4 <___vfprintf_internal_r+0x14bc>
 82079f0:	1021883a 	mov	r16,r2
 82079f4:	04000a0e 	bge	zero,r16,8207a20 <___vfprintf_internal_r+0x14e8>
 82079f8:	d9001f17 	ldw	r4,124(sp)
 82079fc:	1c07883a 	add	r3,r3,r16
 8207a00:	44400015 	stw	r17,0(r8)
 8207a04:	21000044 	addi	r4,r4,1
 8207a08:	44000115 	stw	r16,4(r8)
 8207a0c:	d8c02015 	stw	r3,128(sp)
 8207a10:	d9001f15 	stw	r4,124(sp)
 8207a14:	014001c4 	movi	r5,7
 8207a18:	2901fb16 	blt	r5,r4,8208208 <___vfprintf_internal_r+0x1cd0>
 8207a1c:	42000204 	addi	r8,r8,8
 8207a20:	8001f716 	blt	r16,zero,8208200 <___vfprintf_internal_r+0x1cc8>
 8207a24:	1421c83a 	sub	r16,r2,r16
 8207a28:	043d380e 	bge	zero,r16,8206f0c <___vfprintf_internal_r+0x9d4>
 8207a2c:	04400404 	movi	r17,16
 8207a30:	d8801f17 	ldw	r2,124(sp)
 8207a34:	8c3efb0e 	bge	r17,r16,8207624 <___vfprintf_internal_r+0x10ec>
 8207a38:	01420974 	movhi	r5,2085
 8207a3c:	29756984 	addi	r5,r5,-10842
 8207a40:	d9402b15 	stw	r5,172(sp)
 8207a44:	058001c4 	movi	r22,7
 8207a48:	dcc02c17 	ldw	r19,176(sp)
 8207a4c:	00000306 	br	8207a5c <___vfprintf_internal_r+0x1524>
 8207a50:	42000204 	addi	r8,r8,8
 8207a54:	843ffc04 	addi	r16,r16,-16
 8207a58:	8c3ef50e 	bge	r17,r16,8207630 <___vfprintf_internal_r+0x10f8>
 8207a5c:	18c00404 	addi	r3,r3,16
 8207a60:	10800044 	addi	r2,r2,1
 8207a64:	45000015 	stw	r20,0(r8)
 8207a68:	44400115 	stw	r17,4(r8)
 8207a6c:	d8c02015 	stw	r3,128(sp)
 8207a70:	d8801f15 	stw	r2,124(sp)
 8207a74:	b0bff60e 	bge	r22,r2,8207a50 <___vfprintf_internal_r+0x1518>
 8207a78:	d9801e04 	addi	r6,sp,120
 8207a7c:	b80b883a 	mov	r5,r23
 8207a80:	9809883a 	mov	r4,r19
 8207a84:	820f08c0 	call	820f08c <__sprint_r>
 8207a88:	103bad1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207a8c:	d8c02017 	ldw	r3,128(sp)
 8207a90:	d8801f17 	ldw	r2,124(sp)
 8207a94:	da000404 	addi	r8,sp,16
 8207a98:	003fee06 	br	8207a54 <___vfprintf_internal_r+0x151c>
 8207a9c:	9088703a 	and	r4,r18,r2
 8207aa0:	203eab1e 	bne	r4,zero,8207550 <___vfprintf_internal_r+0x1018>
 8207aa4:	dc401f17 	ldw	r17,124(sp)
 8207aa8:	40800115 	stw	r2,4(r8)
 8207aac:	44000015 	stw	r16,0(r8)
 8207ab0:	8c400044 	addi	r17,r17,1
 8207ab4:	d8c02015 	stw	r3,128(sp)
 8207ab8:	dc401f15 	stw	r17,124(sp)
 8207abc:	008001c4 	movi	r2,7
 8207ac0:	14400e16 	blt	r2,r17,8207afc <___vfprintf_internal_r+0x15c4>
 8207ac4:	45800204 	addi	r22,r8,8
 8207ac8:	003eca06 	br	82075f4 <___vfprintf_internal_r+0x10bc>
 8207acc:	01020974 	movhi	r4,2085
 8207ad0:	21356984 	addi	r4,r4,-10842
 8207ad4:	d9002b15 	stw	r4,172(sp)
 8207ad8:	d8802b17 	ldw	r2,172(sp)
 8207adc:	1c07883a 	add	r3,r3,r16
 8207ae0:	8c400044 	addi	r17,r17,1
 8207ae4:	b0800015 	stw	r2,0(r22)
 8207ae8:	b4000115 	stw	r16,4(r22)
 8207aec:	d8c02015 	stw	r3,128(sp)
 8207af0:	dc401f15 	stw	r17,124(sp)
 8207af4:	008001c4 	movi	r2,7
 8207af8:	147ebd0e 	bge	r2,r17,82075f0 <___vfprintf_internal_r+0x10b8>
 8207afc:	d9002c17 	ldw	r4,176(sp)
 8207b00:	d9801e04 	addi	r6,sp,120
 8207b04:	b80b883a 	mov	r5,r23
 8207b08:	820f08c0 	call	820f08c <__sprint_r>
 8207b0c:	103b8c1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207b10:	d8c02017 	ldw	r3,128(sp)
 8207b14:	dc401f17 	ldw	r17,124(sp)
 8207b18:	dd800404 	addi	r22,sp,16
 8207b1c:	003eb506 	br	82075f4 <___vfprintf_internal_r+0x10bc>
 8207b20:	d9002c17 	ldw	r4,176(sp)
 8207b24:	d9801e04 	addi	r6,sp,120
 8207b28:	b80b883a 	mov	r5,r23
 8207b2c:	820f08c0 	call	820f08c <__sprint_r>
 8207b30:	103b831e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207b34:	d8c02017 	ldw	r3,128(sp)
 8207b38:	dc401f17 	ldw	r17,124(sp)
 8207b3c:	da000404 	addi	r8,sp,16
 8207b40:	003e8d06 	br	8207578 <___vfprintf_internal_r+0x1040>
 8207b44:	d9002c17 	ldw	r4,176(sp)
 8207b48:	d9801e04 	addi	r6,sp,120
 8207b4c:	b80b883a 	mov	r5,r23
 8207b50:	820f08c0 	call	820f08c <__sprint_r>
 8207b54:	103b7a1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207b58:	d8c02017 	ldw	r3,128(sp)
 8207b5c:	dc401f17 	ldw	r17,124(sp)
 8207b60:	dd800404 	addi	r22,sp,16
 8207b64:	003e8f06 	br	82075a4 <___vfprintf_internal_r+0x106c>
 8207b68:	0027883a 	mov	r19,zero
 8207b6c:	003f4a06 	br	8207898 <___vfprintf_internal_r+0x1360>
 8207b70:	d9002c17 	ldw	r4,176(sp)
 8207b74:	d9801e04 	addi	r6,sp,120
 8207b78:	b80b883a 	mov	r5,r23
 8207b7c:	820f08c0 	call	820f08c <__sprint_r>
 8207b80:	103b6f1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207b84:	d8c02017 	ldw	r3,128(sp)
 8207b88:	da000404 	addi	r8,sp,16
 8207b8c:	003c9d06 	br	8206e04 <___vfprintf_internal_r+0x8cc>
 8207b90:	04e7c83a 	sub	r19,zero,r19
 8207b94:	9804c03a 	cmpne	r2,r19,zero
 8207b98:	05adc83a 	sub	r22,zero,r22
 8207b9c:	b0adc83a 	sub	r22,r22,r2
 8207ba0:	d8802917 	ldw	r2,164(sp)
 8207ba4:	07000b44 	movi	fp,45
 8207ba8:	df002785 	stb	fp,158(sp)
 8207bac:	10017b16 	blt	r2,zero,820819c <___vfprintf_internal_r+0x1c64>
 8207bb0:	00bfdfc4 	movi	r2,-129
 8207bb4:	90a4703a 	and	r18,r18,r2
 8207bb8:	003bb106 	br	8206a80 <___vfprintf_internal_r+0x548>
 8207bbc:	d9003617 	ldw	r4,216(sp)
 8207bc0:	d9403817 	ldw	r5,224(sp)
 8207bc4:	da003d15 	stw	r8,244(sp)
 8207bc8:	820d8a40 	call	820d8a4 <__fpclassifyd>
 8207bcc:	da003d17 	ldw	r8,244(sp)
 8207bd0:	1000f026 	beq	r2,zero,8207f94 <___vfprintf_internal_r+0x1a5c>
 8207bd4:	d9002917 	ldw	r4,164(sp)
 8207bd8:	05bff7c4 	movi	r22,-33
 8207bdc:	00bfffc4 	movi	r2,-1
 8207be0:	8dac703a 	and	r22,r17,r22
 8207be4:	20820026 	beq	r4,r2,82083e8 <___vfprintf_internal_r+0x1eb0>
 8207be8:	008011c4 	movi	r2,71
 8207bec:	b081f726 	beq	r22,r2,82083cc <___vfprintf_internal_r+0x1e94>
 8207bf0:	d9003817 	ldw	r4,224(sp)
 8207bf4:	90c04014 	ori	r3,r18,256
 8207bf8:	d8c02b15 	stw	r3,172(sp)
 8207bfc:	20021516 	blt	r4,zero,8208454 <___vfprintf_internal_r+0x1f1c>
 8207c00:	dcc03817 	ldw	r19,224(sp)
 8207c04:	d8002a05 	stb	zero,168(sp)
 8207c08:	00801984 	movi	r2,102
 8207c0c:	8881f926 	beq	r17,r2,82083f4 <___vfprintf_internal_r+0x1ebc>
 8207c10:	00801184 	movi	r2,70
 8207c14:	88821c26 	beq	r17,r2,8208488 <___vfprintf_internal_r+0x1f50>
 8207c18:	00801144 	movi	r2,69
 8207c1c:	b081ef26 	beq	r22,r2,82083dc <___vfprintf_internal_r+0x1ea4>
 8207c20:	d8c02917 	ldw	r3,164(sp)
 8207c24:	d8802104 	addi	r2,sp,132
 8207c28:	d8800315 	stw	r2,12(sp)
 8207c2c:	d9403617 	ldw	r5,216(sp)
 8207c30:	d8802504 	addi	r2,sp,148
 8207c34:	d9002c17 	ldw	r4,176(sp)
 8207c38:	d8800215 	stw	r2,8(sp)
 8207c3c:	d8802604 	addi	r2,sp,152
 8207c40:	d8c00015 	stw	r3,0(sp)
 8207c44:	d8800115 	stw	r2,4(sp)
 8207c48:	01c00084 	movi	r7,2
 8207c4c:	980d883a 	mov	r6,r19
 8207c50:	d8c03c15 	stw	r3,240(sp)
 8207c54:	da003d15 	stw	r8,244(sp)
 8207c58:	8208cb40 	call	8208cb4 <_dtoa_r>
 8207c5c:	1021883a 	mov	r16,r2
 8207c60:	008019c4 	movi	r2,103
 8207c64:	d8c03c17 	ldw	r3,240(sp)
 8207c68:	da003d17 	ldw	r8,244(sp)
 8207c6c:	88817126 	beq	r17,r2,8208234 <___vfprintf_internal_r+0x1cfc>
 8207c70:	008011c4 	movi	r2,71
 8207c74:	88829226 	beq	r17,r2,82086c0 <___vfprintf_internal_r+0x2188>
 8207c78:	80f9883a 	add	fp,r16,r3
 8207c7c:	d9003617 	ldw	r4,216(sp)
 8207c80:	000d883a 	mov	r6,zero
 8207c84:	000f883a 	mov	r7,zero
 8207c88:	980b883a 	mov	r5,r19
 8207c8c:	da003d15 	stw	r8,244(sp)
 8207c90:	82129f80 	call	82129f8 <__eqdf2>
 8207c94:	da003d17 	ldw	r8,244(sp)
 8207c98:	10018d26 	beq	r2,zero,82082d0 <___vfprintf_internal_r+0x1d98>
 8207c9c:	d8802117 	ldw	r2,132(sp)
 8207ca0:	1700062e 	bgeu	r2,fp,8207cbc <___vfprintf_internal_r+0x1784>
 8207ca4:	01000c04 	movi	r4,48
 8207ca8:	10c00044 	addi	r3,r2,1
 8207cac:	d8c02115 	stw	r3,132(sp)
 8207cb0:	11000005 	stb	r4,0(r2)
 8207cb4:	d8802117 	ldw	r2,132(sp)
 8207cb8:	173ffb36 	bltu	r2,fp,8207ca8 <___vfprintf_internal_r+0x1770>
 8207cbc:	1405c83a 	sub	r2,r2,r16
 8207cc0:	d8803315 	stw	r2,204(sp)
 8207cc4:	008011c4 	movi	r2,71
 8207cc8:	b0817626 	beq	r22,r2,82082a4 <___vfprintf_internal_r+0x1d6c>
 8207ccc:	00801944 	movi	r2,101
 8207cd0:	1442810e 	bge	r2,r17,82086d8 <___vfprintf_internal_r+0x21a0>
 8207cd4:	d8c02617 	ldw	r3,152(sp)
 8207cd8:	00801984 	movi	r2,102
 8207cdc:	d8c03215 	stw	r3,200(sp)
 8207ce0:	8881fe26 	beq	r17,r2,82084dc <___vfprintf_internal_r+0x1fa4>
 8207ce4:	d8c03217 	ldw	r3,200(sp)
 8207ce8:	d9003317 	ldw	r4,204(sp)
 8207cec:	1901dd16 	blt	r3,r4,8208464 <___vfprintf_internal_r+0x1f2c>
 8207cf0:	9480004c 	andi	r18,r18,1
 8207cf4:	90022b1e 	bne	r18,zero,82085a4 <___vfprintf_internal_r+0x206c>
 8207cf8:	1805883a 	mov	r2,r3
 8207cfc:	18028016 	blt	r3,zero,8208700 <___vfprintf_internal_r+0x21c8>
 8207d00:	d8c03217 	ldw	r3,200(sp)
 8207d04:	044019c4 	movi	r17,103
 8207d08:	d8c02e15 	stw	r3,184(sp)
 8207d0c:	df002a07 	ldb	fp,168(sp)
 8207d10:	e001531e 	bne	fp,zero,8208260 <___vfprintf_internal_r+0x1d28>
 8207d14:	df002783 	ldbu	fp,158(sp)
 8207d18:	d8802a15 	stw	r2,168(sp)
 8207d1c:	dc802b17 	ldw	r18,172(sp)
 8207d20:	d8002915 	stw	zero,164(sp)
 8207d24:	003bd106 	br	8206c6c <___vfprintf_internal_r+0x734>
 8207d28:	d8802d17 	ldw	r2,180(sp)
 8207d2c:	d8c02d17 	ldw	r3,180(sp)
 8207d30:	d9002d17 	ldw	r4,180(sp)
 8207d34:	10800017 	ldw	r2,0(r2)
 8207d38:	18c00117 	ldw	r3,4(r3)
 8207d3c:	21000204 	addi	r4,r4,8
 8207d40:	d8803615 	stw	r2,216(sp)
 8207d44:	d8c03815 	stw	r3,224(sp)
 8207d48:	d9002d15 	stw	r4,180(sp)
 8207d4c:	003b7506 	br	8206b24 <___vfprintf_internal_r+0x5ec>
 8207d50:	ac400007 	ldb	r17,0(r21)
 8207d54:	003a5906 	br	82066bc <___vfprintf_internal_r+0x184>
 8207d58:	9080100c 	andi	r2,r18,64
 8207d5c:	1000a826 	beq	r2,zero,8208000 <___vfprintf_internal_r+0x1ac8>
 8207d60:	d9002d17 	ldw	r4,180(sp)
 8207d64:	002d883a 	mov	r22,zero
 8207d68:	24c0000b 	ldhu	r19,0(r4)
 8207d6c:	21000104 	addi	r4,r4,4
 8207d70:	d9002d15 	stw	r4,180(sp)
 8207d74:	003ccb06 	br	82070a4 <___vfprintf_internal_r+0xb6c>
 8207d78:	d8c02d17 	ldw	r3,180(sp)
 8207d7c:	d9002917 	ldw	r4,164(sp)
 8207d80:	002d883a 	mov	r22,zero
 8207d84:	18800104 	addi	r2,r3,4
 8207d88:	1cc00017 	ldw	r19,0(r3)
 8207d8c:	203ebb0e 	bge	r4,zero,820787c <___vfprintf_internal_r+0x1344>
 8207d90:	003ef106 	br	8207958 <___vfprintf_internal_r+0x1420>
 8207d94:	9080040c 	andi	r2,r18,16
 8207d98:	1000921e 	bne	r2,zero,8207fe4 <___vfprintf_internal_r+0x1aac>
 8207d9c:	9480100c 	andi	r18,r18,64
 8207da0:	90013926 	beq	r18,zero,8208288 <___vfprintf_internal_r+0x1d50>
 8207da4:	d9002d17 	ldw	r4,180(sp)
 8207da8:	d9402f17 	ldw	r5,188(sp)
 8207dac:	20800017 	ldw	r2,0(r4)
 8207db0:	21000104 	addi	r4,r4,4
 8207db4:	d9002d15 	stw	r4,180(sp)
 8207db8:	1140000d 	sth	r5,0(r2)
 8207dbc:	003a1606 	br	8206618 <___vfprintf_internal_r+0xe0>
 8207dc0:	9080100c 	andi	r2,r18,64
 8207dc4:	10008026 	beq	r2,zero,8207fc8 <___vfprintf_internal_r+0x1a90>
 8207dc8:	d8c02d17 	ldw	r3,180(sp)
 8207dcc:	1cc0000f 	ldh	r19,0(r3)
 8207dd0:	18c00104 	addi	r3,r3,4
 8207dd4:	d8c02d15 	stw	r3,180(sp)
 8207dd8:	982dd7fa 	srai	r22,r19,31
 8207ddc:	b005883a 	mov	r2,r22
 8207de0:	003b1f06 	br	8206a60 <___vfprintf_internal_r+0x528>
 8207de4:	9080100c 	andi	r2,r18,64
 8207de8:	d8002785 	stb	zero,158(sp)
 8207dec:	10008a1e 	bne	r2,zero,8208018 <___vfprintf_internal_r+0x1ae0>
 8207df0:	d9402d17 	ldw	r5,180(sp)
 8207df4:	d8c02917 	ldw	r3,164(sp)
 8207df8:	002d883a 	mov	r22,zero
 8207dfc:	28800104 	addi	r2,r5,4
 8207e00:	2cc00017 	ldw	r19,0(r5)
 8207e04:	183e4b0e 	bge	r3,zero,8207734 <___vfprintf_internal_r+0x11fc>
 8207e08:	9d86b03a 	or	r3,r19,r22
 8207e0c:	d8802d15 	stw	r2,180(sp)
 8207e10:	183e4c1e 	bne	r3,zero,8207744 <___vfprintf_internal_r+0x120c>
 8207e14:	0039883a 	mov	fp,zero
 8207e18:	0005883a 	mov	r2,zero
 8207e1c:	003d4006 	br	8207320 <___vfprintf_internal_r+0xde8>
 8207e20:	01420974 	movhi	r5,2085
 8207e24:	29756984 	addi	r5,r5,-10842
 8207e28:	d9402b15 	stw	r5,172(sp)
 8207e2c:	d9402b17 	ldw	r5,172(sp)
 8207e30:	1c47883a 	add	r3,r3,r17
 8207e34:	10800044 	addi	r2,r2,1
 8207e38:	41400015 	stw	r5,0(r8)
 8207e3c:	44400115 	stw	r17,4(r8)
 8207e40:	d8c02015 	stw	r3,128(sp)
 8207e44:	d8801f15 	stw	r2,124(sp)
 8207e48:	010001c4 	movi	r4,7
 8207e4c:	20bec816 	blt	r4,r2,8207970 <___vfprintf_internal_r+0x1438>
 8207e50:	42000204 	addi	r8,r8,8
 8207e54:	003ecd06 	br	820798c <___vfprintf_internal_r+0x1454>
 8207e58:	d9002917 	ldw	r4,164(sp)
 8207e5c:	d8002785 	stb	zero,158(sp)
 8207e60:	203d2d16 	blt	r4,zero,8207318 <___vfprintf_internal_r+0xde0>
 8207e64:	00bfdfc4 	movi	r2,-129
 8207e68:	90a4703a 	and	r18,r18,r2
 8207e6c:	003a9106 	br	82068b4 <___vfprintf_internal_r+0x37c>
 8207e70:	01020974 	movhi	r4,2085
 8207e74:	21356984 	addi	r4,r4,-10842
 8207e78:	d9002b15 	stw	r4,172(sp)
 8207e7c:	003c0c06 	br	8206eb0 <___vfprintf_internal_r+0x978>
 8207e80:	d9002c17 	ldw	r4,176(sp)
 8207e84:	d9801e04 	addi	r6,sp,120
 8207e88:	b80b883a 	mov	r5,r23
 8207e8c:	820f08c0 	call	820f08c <__sprint_r>
 8207e90:	103aab1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207e94:	d8c02017 	ldw	r3,128(sp)
 8207e98:	da000404 	addi	r8,sp,16
 8207e9c:	003d4106 	br	82073a4 <___vfprintf_internal_r+0xe6c>
 8207ea0:	d8801f17 	ldw	r2,124(sp)
 8207ea4:	01420974 	movhi	r5,2085
 8207ea8:	01000044 	movi	r4,1
 8207eac:	18c00044 	addi	r3,r3,1
 8207eb0:	10800044 	addi	r2,r2,1
 8207eb4:	29756104 	addi	r5,r5,-10876
 8207eb8:	41000115 	stw	r4,4(r8)
 8207ebc:	41400015 	stw	r5,0(r8)
 8207ec0:	d8c02015 	stw	r3,128(sp)
 8207ec4:	d8801f15 	stw	r2,124(sp)
 8207ec8:	010001c4 	movi	r4,7
 8207ecc:	20805c16 	blt	r4,r2,8208040 <___vfprintf_internal_r+0x1b08>
 8207ed0:	42000204 	addi	r8,r8,8
 8207ed4:	8800041e 	bne	r17,zero,8207ee8 <___vfprintf_internal_r+0x19b0>
 8207ed8:	d8803317 	ldw	r2,204(sp)
 8207edc:	1000021e 	bne	r2,zero,8207ee8 <___vfprintf_internal_r+0x19b0>
 8207ee0:	9080004c 	andi	r2,r18,1
 8207ee4:	103c0926 	beq	r2,zero,8206f0c <___vfprintf_internal_r+0x9d4>
 8207ee8:	d9003717 	ldw	r4,220(sp)
 8207eec:	d8801f17 	ldw	r2,124(sp)
 8207ef0:	d9403417 	ldw	r5,208(sp)
 8207ef4:	20c7883a 	add	r3,r4,r3
 8207ef8:	10800044 	addi	r2,r2,1
 8207efc:	41000115 	stw	r4,4(r8)
 8207f00:	41400015 	stw	r5,0(r8)
 8207f04:	d8c02015 	stw	r3,128(sp)
 8207f08:	d8801f15 	stw	r2,124(sp)
 8207f0c:	010001c4 	movi	r4,7
 8207f10:	20812116 	blt	r4,r2,8208398 <___vfprintf_internal_r+0x1e60>
 8207f14:	42000204 	addi	r8,r8,8
 8207f18:	0463c83a 	sub	r17,zero,r17
 8207f1c:	0440730e 	bge	zero,r17,82080ec <___vfprintf_internal_r+0x1bb4>
 8207f20:	05800404 	movi	r22,16
 8207f24:	b440860e 	bge	r22,r17,8208140 <___vfprintf_internal_r+0x1c08>
 8207f28:	01420974 	movhi	r5,2085
 8207f2c:	29756984 	addi	r5,r5,-10842
 8207f30:	d9402b15 	stw	r5,172(sp)
 8207f34:	070001c4 	movi	fp,7
 8207f38:	dcc02c17 	ldw	r19,176(sp)
 8207f3c:	00000306 	br	8207f4c <___vfprintf_internal_r+0x1a14>
 8207f40:	42000204 	addi	r8,r8,8
 8207f44:	8c7ffc04 	addi	r17,r17,-16
 8207f48:	b440800e 	bge	r22,r17,820814c <___vfprintf_internal_r+0x1c14>
 8207f4c:	18c00404 	addi	r3,r3,16
 8207f50:	10800044 	addi	r2,r2,1
 8207f54:	45000015 	stw	r20,0(r8)
 8207f58:	45800115 	stw	r22,4(r8)
 8207f5c:	d8c02015 	stw	r3,128(sp)
 8207f60:	d8801f15 	stw	r2,124(sp)
 8207f64:	e0bff60e 	bge	fp,r2,8207f40 <___vfprintf_internal_r+0x1a08>
 8207f68:	d9801e04 	addi	r6,sp,120
 8207f6c:	b80b883a 	mov	r5,r23
 8207f70:	9809883a 	mov	r4,r19
 8207f74:	820f08c0 	call	820f08c <__sprint_r>
 8207f78:	103a711e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8207f7c:	d8c02017 	ldw	r3,128(sp)
 8207f80:	d8801f17 	ldw	r2,124(sp)
 8207f84:	da000404 	addi	r8,sp,16
 8207f88:	003fee06 	br	8207f44 <___vfprintf_internal_r+0x1a0c>
 8207f8c:	00bfffc4 	movi	r2,-1
 8207f90:	003a6f06 	br	8206950 <___vfprintf_internal_r+0x418>
 8207f94:	008011c4 	movi	r2,71
 8207f98:	1440b816 	blt	r2,r17,820827c <___vfprintf_internal_r+0x1d44>
 8207f9c:	04020974 	movhi	r16,2085
 8207fa0:	84355304 	addi	r16,r16,-10932
 8207fa4:	00c000c4 	movi	r3,3
 8207fa8:	00bfdfc4 	movi	r2,-129
 8207fac:	d8c02a15 	stw	r3,168(sp)
 8207fb0:	90a4703a 	and	r18,r18,r2
 8207fb4:	df002783 	ldbu	fp,158(sp)
 8207fb8:	d8c02e15 	stw	r3,184(sp)
 8207fbc:	d8002915 	stw	zero,164(sp)
 8207fc0:	d8003215 	stw	zero,200(sp)
 8207fc4:	003b2906 	br	8206c6c <___vfprintf_internal_r+0x734>
 8207fc8:	d9002d17 	ldw	r4,180(sp)
 8207fcc:	24c00017 	ldw	r19,0(r4)
 8207fd0:	21000104 	addi	r4,r4,4
 8207fd4:	d9002d15 	stw	r4,180(sp)
 8207fd8:	982dd7fa 	srai	r22,r19,31
 8207fdc:	b005883a 	mov	r2,r22
 8207fe0:	003a9f06 	br	8206a60 <___vfprintf_internal_r+0x528>
 8207fe4:	d9402d17 	ldw	r5,180(sp)
 8207fe8:	d8c02f17 	ldw	r3,188(sp)
 8207fec:	28800017 	ldw	r2,0(r5)
 8207ff0:	29400104 	addi	r5,r5,4
 8207ff4:	d9402d15 	stw	r5,180(sp)
 8207ff8:	10c00015 	stw	r3,0(r2)
 8207ffc:	00398606 	br	8206618 <___vfprintf_internal_r+0xe0>
 8208000:	d9402d17 	ldw	r5,180(sp)
 8208004:	002d883a 	mov	r22,zero
 8208008:	2cc00017 	ldw	r19,0(r5)
 820800c:	29400104 	addi	r5,r5,4
 8208010:	d9402d15 	stw	r5,180(sp)
 8208014:	003c2306 	br	82070a4 <___vfprintf_internal_r+0xb6c>
 8208018:	d8c02d17 	ldw	r3,180(sp)
 820801c:	d9002917 	ldw	r4,164(sp)
 8208020:	002d883a 	mov	r22,zero
 8208024:	18800104 	addi	r2,r3,4
 8208028:	1cc0000b 	ldhu	r19,0(r3)
 820802c:	203dc10e 	bge	r4,zero,8207734 <___vfprintf_internal_r+0x11fc>
 8208030:	003f7506 	br	8207e08 <___vfprintf_internal_r+0x18d0>
 8208034:	04020974 	movhi	r16,2085
 8208038:	84355104 	addi	r16,r16,-10940
 820803c:	003acc06 	br	8206b70 <___vfprintf_internal_r+0x638>
 8208040:	d9002c17 	ldw	r4,176(sp)
 8208044:	d9801e04 	addi	r6,sp,120
 8208048:	b80b883a 	mov	r5,r23
 820804c:	820f08c0 	call	820f08c <__sprint_r>
 8208050:	103a3b1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8208054:	dc402617 	ldw	r17,152(sp)
 8208058:	d8c02017 	ldw	r3,128(sp)
 820805c:	da000404 	addi	r8,sp,16
 8208060:	003f9c06 	br	8207ed4 <___vfprintf_internal_r+0x199c>
 8208064:	ac400043 	ldbu	r17,1(r21)
 8208068:	94800814 	ori	r18,r18,32
 820806c:	ad400044 	addi	r21,r21,1
 8208070:	8c403fcc 	andi	r17,r17,255
 8208074:	8c40201c 	xori	r17,r17,128
 8208078:	8c7fe004 	addi	r17,r17,-128
 820807c:	00398f06 	br	82066bc <___vfprintf_internal_r+0x184>
 8208080:	d8c02d15 	stw	r3,180(sp)
 8208084:	0039883a 	mov	fp,zero
 8208088:	003e3506 	br	8207960 <___vfprintf_internal_r+0x1428>
 820808c:	d9002c17 	ldw	r4,176(sp)
 8208090:	d9801e04 	addi	r6,sp,120
 8208094:	b80b883a 	mov	r5,r23
 8208098:	820f08c0 	call	820f08c <__sprint_r>
 820809c:	103a281e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82080a0:	d8c02017 	ldw	r3,128(sp)
 82080a4:	da000404 	addi	r8,sp,16
 82080a8:	003cd006 	br	82073ec <___vfprintf_internal_r+0xeb4>
 82080ac:	8009883a 	mov	r4,r16
 82080b0:	da003d15 	stw	r8,244(sp)
 82080b4:	8203a5c0 	call	8203a5c <strlen>
 82080b8:	d8802e15 	stw	r2,184(sp)
 82080bc:	da003d17 	ldw	r8,244(sp)
 82080c0:	103c340e 	bge	r2,zero,8207194 <___vfprintf_internal_r+0xc5c>
 82080c4:	0005883a 	mov	r2,zero
 82080c8:	003c3206 	br	8207194 <___vfprintf_internal_r+0xc5c>
 82080cc:	d9002c17 	ldw	r4,176(sp)
 82080d0:	d9801e04 	addi	r6,sp,120
 82080d4:	b80b883a 	mov	r5,r23
 82080d8:	820f08c0 	call	820f08c <__sprint_r>
 82080dc:	103a181e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82080e0:	d8c02017 	ldw	r3,128(sp)
 82080e4:	d8801f17 	ldw	r2,124(sp)
 82080e8:	da000404 	addi	r8,sp,16
 82080ec:	d9403317 	ldw	r5,204(sp)
 82080f0:	10800044 	addi	r2,r2,1
 82080f4:	44000015 	stw	r16,0(r8)
 82080f8:	28c7883a 	add	r3,r5,r3
 82080fc:	003b7d06 	br	8206ef4 <___vfprintf_internal_r+0x9bc>
 8208100:	01020974 	movhi	r4,2085
 8208104:	21356d84 	addi	r4,r4,-10826
 8208108:	d9003515 	stw	r4,212(sp)
 820810c:	003b1406 	br	8206d60 <___vfprintf_internal_r+0x828>
 8208110:	013fffc4 	movi	r4,-1
 8208114:	003a3506 	br	82069ec <___vfprintf_internal_r+0x4b4>
 8208118:	0023883a 	mov	r17,zero
 820811c:	003d9d06 	br	8207794 <___vfprintf_internal_r+0x125c>
 8208120:	d9002c17 	ldw	r4,176(sp)
 8208124:	d9801e04 	addi	r6,sp,120
 8208128:	b80b883a 	mov	r5,r23
 820812c:	820f08c0 	call	820f08c <__sprint_r>
 8208130:	103a031e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 8208134:	d8c02017 	ldw	r3,128(sp)
 8208138:	da000404 	addi	r8,sp,16
 820813c:	003d9406 	br	8207790 <___vfprintf_internal_r+0x1258>
 8208140:	01020974 	movhi	r4,2085
 8208144:	21356984 	addi	r4,r4,-10842
 8208148:	d9002b15 	stw	r4,172(sp)
 820814c:	d9002b17 	ldw	r4,172(sp)
 8208150:	1c47883a 	add	r3,r3,r17
 8208154:	10800044 	addi	r2,r2,1
 8208158:	41000015 	stw	r4,0(r8)
 820815c:	44400115 	stw	r17,4(r8)
 8208160:	d8c02015 	stw	r3,128(sp)
 8208164:	d8801f15 	stw	r2,124(sp)
 8208168:	010001c4 	movi	r4,7
 820816c:	20bfd716 	blt	r4,r2,82080cc <___vfprintf_internal_r+0x1b94>
 8208170:	42000204 	addi	r8,r8,8
 8208174:	003fdd06 	br	82080ec <___vfprintf_internal_r+0x1bb4>
 8208178:	d9002c17 	ldw	r4,176(sp)
 820817c:	d9801e04 	addi	r6,sp,120
 8208180:	b80b883a 	mov	r5,r23
 8208184:	820f08c0 	call	820f08c <__sprint_r>
 8208188:	1039ed1e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 820818c:	d8802617 	ldw	r2,152(sp)
 8208190:	d8c02017 	ldw	r3,128(sp)
 8208194:	da000404 	addi	r8,sp,16
 8208198:	003e1006 	br	82079dc <___vfprintf_internal_r+0x14a4>
 820819c:	00800044 	movi	r2,1
 82081a0:	10803fcc 	andi	r2,r2,255
 82081a4:	00c00044 	movi	r3,1
 82081a8:	10fa3526 	beq	r2,r3,8206a80 <___vfprintf_internal_r+0x548>
 82081ac:	00c00084 	movi	r3,2
 82081b0:	10fbcb26 	beq	r2,r3,82070e0 <___vfprintf_internal_r+0xba8>
 82081b4:	003a8f06 	br	8206bf4 <___vfprintf_internal_r+0x6bc>
 82081b8:	01020974 	movhi	r4,2085
 82081bc:	21356d84 	addi	r4,r4,-10826
 82081c0:	d9003515 	stw	r4,212(sp)
 82081c4:	003b7606 	br	8206fa0 <___vfprintf_internal_r+0xa68>
 82081c8:	d8802917 	ldw	r2,164(sp)
 82081cc:	00c00184 	movi	r3,6
 82081d0:	1880012e 	bgeu	r3,r2,82081d8 <___vfprintf_internal_r+0x1ca0>
 82081d4:	1805883a 	mov	r2,r3
 82081d8:	d8802e15 	stw	r2,184(sp)
 82081dc:	1000ef16 	blt	r2,zero,820859c <___vfprintf_internal_r+0x2064>
 82081e0:	04020974 	movhi	r16,2085
 82081e4:	d8802a15 	stw	r2,168(sp)
 82081e8:	dcc02d15 	stw	r19,180(sp)
 82081ec:	d8002915 	stw	zero,164(sp)
 82081f0:	d8003215 	stw	zero,200(sp)
 82081f4:	84355f04 	addi	r16,r16,-10884
 82081f8:	0039883a 	mov	fp,zero
 82081fc:	003aa206 	br	8206c88 <___vfprintf_internal_r+0x750>
 8208200:	0021883a 	mov	r16,zero
 8208204:	003e0706 	br	8207a24 <___vfprintf_internal_r+0x14ec>
 8208208:	d9002c17 	ldw	r4,176(sp)
 820820c:	d9801e04 	addi	r6,sp,120
 8208210:	b80b883a 	mov	r5,r23
 8208214:	820f08c0 	call	820f08c <__sprint_r>
 8208218:	1039c91e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 820821c:	d8802617 	ldw	r2,152(sp)
 8208220:	d9403317 	ldw	r5,204(sp)
 8208224:	d8c02017 	ldw	r3,128(sp)
 8208228:	da000404 	addi	r8,sp,16
 820822c:	2885c83a 	sub	r2,r5,r2
 8208230:	003dfb06 	br	8207a20 <___vfprintf_internal_r+0x14e8>
 8208234:	9080004c 	andi	r2,r18,1
 8208238:	103e8f1e 	bne	r2,zero,8207c78 <___vfprintf_internal_r+0x1740>
 820823c:	d8802117 	ldw	r2,132(sp)
 8208240:	003e9e06 	br	8207cbc <___vfprintf_internal_r+0x1784>
 8208244:	1025883a 	mov	r18,r2
 8208248:	0039883a 	mov	fp,zero
 820824c:	00800084 	movi	r2,2
 8208250:	003fd306 	br	82081a0 <___vfprintf_internal_r+0x1c68>
 8208254:	07000b44 	movi	fp,45
 8208258:	df002785 	stb	fp,158(sp)
 820825c:	003a4006 	br	8206b60 <___vfprintf_internal_r+0x628>
 8208260:	00c00b44 	movi	r3,45
 8208264:	d8c02785 	stb	r3,158(sp)
 8208268:	d8802a15 	stw	r2,168(sp)
 820826c:	dc802b17 	ldw	r18,172(sp)
 8208270:	d8002915 	stw	zero,164(sp)
 8208274:	07000b44 	movi	fp,45
 8208278:	003a8006 	br	8206c7c <___vfprintf_internal_r+0x744>
 820827c:	04020974 	movhi	r16,2085
 8208280:	84355404 	addi	r16,r16,-10928
 8208284:	003f4706 	br	8207fa4 <___vfprintf_internal_r+0x1a6c>
 8208288:	d8c02d17 	ldw	r3,180(sp)
 820828c:	d9002f17 	ldw	r4,188(sp)
 8208290:	18800017 	ldw	r2,0(r3)
 8208294:	18c00104 	addi	r3,r3,4
 8208298:	d8c02d15 	stw	r3,180(sp)
 820829c:	11000015 	stw	r4,0(r2)
 82082a0:	0038dd06 	br	8206618 <___vfprintf_internal_r+0xe0>
 82082a4:	dd802617 	ldw	r22,152(sp)
 82082a8:	00bfff44 	movi	r2,-3
 82082ac:	b0801c16 	blt	r22,r2,8208320 <___vfprintf_internal_r+0x1de8>
 82082b0:	d9402917 	ldw	r5,164(sp)
 82082b4:	2d801a16 	blt	r5,r22,8208320 <___vfprintf_internal_r+0x1de8>
 82082b8:	dd803215 	stw	r22,200(sp)
 82082bc:	003e8906 	br	8207ce4 <___vfprintf_internal_r+0x17ac>
 82082c0:	01020974 	movhi	r4,2085
 82082c4:	21356984 	addi	r4,r4,-10842
 82082c8:	d9002b15 	stw	r4,172(sp)
 82082cc:	003c9106 	br	8207514 <___vfprintf_internal_r+0xfdc>
 82082d0:	e005883a 	mov	r2,fp
 82082d4:	003e7906 	br	8207cbc <___vfprintf_internal_r+0x1784>
 82082d8:	d9402917 	ldw	r5,164(sp)
 82082dc:	df002783 	ldbu	fp,158(sp)
 82082e0:	dcc02d15 	stw	r19,180(sp)
 82082e4:	d9402a15 	stw	r5,168(sp)
 82082e8:	d9402e15 	stw	r5,184(sp)
 82082ec:	d8002915 	stw	zero,164(sp)
 82082f0:	d8003215 	stw	zero,200(sp)
 82082f4:	003a5d06 	br	8206c6c <___vfprintf_internal_r+0x734>
 82082f8:	9080004c 	andi	r2,r18,1
 82082fc:	0039883a 	mov	fp,zero
 8208300:	10000426 	beq	r2,zero,8208314 <___vfprintf_internal_r+0x1ddc>
 8208304:	00800c04 	movi	r2,48
 8208308:	dc001dc4 	addi	r16,sp,119
 820830c:	d8801dc5 	stb	r2,119(sp)
 8208310:	003b8006 	br	8207114 <___vfprintf_internal_r+0xbdc>
 8208314:	d8002e15 	stw	zero,184(sp)
 8208318:	dc001e04 	addi	r16,sp,120
 820831c:	003a4d06 	br	8206c54 <___vfprintf_internal_r+0x71c>
 8208320:	8c7fff84 	addi	r17,r17,-2
 8208324:	b5bfffc4 	addi	r22,r22,-1
 8208328:	dd802615 	stw	r22,152(sp)
 820832c:	dc4022c5 	stb	r17,139(sp)
 8208330:	b000bf16 	blt	r22,zero,8208630 <___vfprintf_internal_r+0x20f8>
 8208334:	00800ac4 	movi	r2,43
 8208338:	d8802305 	stb	r2,140(sp)
 820833c:	00800244 	movi	r2,9
 8208340:	15807016 	blt	r2,r22,8208504 <___vfprintf_internal_r+0x1fcc>
 8208344:	00800c04 	movi	r2,48
 8208348:	b5800c04 	addi	r22,r22,48
 820834c:	d8802345 	stb	r2,141(sp)
 8208350:	dd802385 	stb	r22,142(sp)
 8208354:	d88023c4 	addi	r2,sp,143
 8208358:	df0022c4 	addi	fp,sp,139
 820835c:	d8c03317 	ldw	r3,204(sp)
 8208360:	1739c83a 	sub	fp,r2,fp
 8208364:	d9003317 	ldw	r4,204(sp)
 8208368:	e0c7883a 	add	r3,fp,r3
 820836c:	df003a15 	stw	fp,232(sp)
 8208370:	d8c02e15 	stw	r3,184(sp)
 8208374:	00800044 	movi	r2,1
 8208378:	1100b30e 	bge	r2,r4,8208648 <___vfprintf_internal_r+0x2110>
 820837c:	d8c02e17 	ldw	r3,184(sp)
 8208380:	18c00044 	addi	r3,r3,1
 8208384:	d8c02e15 	stw	r3,184(sp)
 8208388:	1805883a 	mov	r2,r3
 820838c:	1800ac16 	blt	r3,zero,8208640 <___vfprintf_internal_r+0x2108>
 8208390:	d8003215 	stw	zero,200(sp)
 8208394:	003e5d06 	br	8207d0c <___vfprintf_internal_r+0x17d4>
 8208398:	d9002c17 	ldw	r4,176(sp)
 820839c:	d9801e04 	addi	r6,sp,120
 82083a0:	b80b883a 	mov	r5,r23
 82083a4:	820f08c0 	call	820f08c <__sprint_r>
 82083a8:	1039651e 	bne	r2,zero,8206940 <___vfprintf_internal_r+0x408>
 82083ac:	dc402617 	ldw	r17,152(sp)
 82083b0:	d8c02017 	ldw	r3,128(sp)
 82083b4:	d8801f17 	ldw	r2,124(sp)
 82083b8:	da000404 	addi	r8,sp,16
 82083bc:	003ed606 	br	8207f18 <___vfprintf_internal_r+0x19e0>
 82083c0:	582b883a 	mov	r21,r11
 82083c4:	d8002915 	stw	zero,164(sp)
 82083c8:	0038bd06 	br	82066c0 <___vfprintf_internal_r+0x188>
 82083cc:	d8802917 	ldw	r2,164(sp)
 82083d0:	103e071e 	bne	r2,zero,8207bf0 <___vfprintf_internal_r+0x16b8>
 82083d4:	dc002915 	stw	r16,164(sp)
 82083d8:	003e0506 	br	8207bf0 <___vfprintf_internal_r+0x16b8>
 82083dc:	d9002917 	ldw	r4,164(sp)
 82083e0:	20c00044 	addi	r3,r4,1
 82083e4:	003e0f06 	br	8207c24 <___vfprintf_internal_r+0x16ec>
 82083e8:	01400184 	movi	r5,6
 82083ec:	d9402915 	stw	r5,164(sp)
 82083f0:	003dff06 	br	8207bf0 <___vfprintf_internal_r+0x16b8>
 82083f4:	d8802104 	addi	r2,sp,132
 82083f8:	d8800315 	stw	r2,12(sp)
 82083fc:	d8802504 	addi	r2,sp,148
 8208400:	d8800215 	stw	r2,8(sp)
 8208404:	d8802604 	addi	r2,sp,152
 8208408:	d8800115 	stw	r2,4(sp)
 820840c:	d8802917 	ldw	r2,164(sp)
 8208410:	d9403617 	ldw	r5,216(sp)
 8208414:	d9002c17 	ldw	r4,176(sp)
 8208418:	d8800015 	stw	r2,0(sp)
 820841c:	01c000c4 	movi	r7,3
 8208420:	980d883a 	mov	r6,r19
 8208424:	da003d15 	stw	r8,244(sp)
 8208428:	8208cb40 	call	8208cb4 <_dtoa_r>
 820842c:	d8c02917 	ldw	r3,164(sp)
 8208430:	da003d17 	ldw	r8,244(sp)
 8208434:	1021883a 	mov	r16,r2
 8208438:	10f9883a 	add	fp,r2,r3
 820843c:	81000007 	ldb	r4,0(r16)
 8208440:	00800c04 	movi	r2,48
 8208444:	20805e26 	beq	r4,r2,82085c0 <___vfprintf_internal_r+0x2088>
 8208448:	d8c02617 	ldw	r3,152(sp)
 820844c:	e0f9883a 	add	fp,fp,r3
 8208450:	003e0a06 	br	8207c7c <___vfprintf_internal_r+0x1744>
 8208454:	00c00b44 	movi	r3,45
 8208458:	24e0003c 	xorhi	r19,r4,32768
 820845c:	d8c02a05 	stb	r3,168(sp)
 8208460:	003de906 	br	8207c08 <___vfprintf_internal_r+0x16d0>
 8208464:	d8c03217 	ldw	r3,200(sp)
 8208468:	00c07a0e 	bge	zero,r3,8208654 <___vfprintf_internal_r+0x211c>
 820846c:	00800044 	movi	r2,1
 8208470:	d9003317 	ldw	r4,204(sp)
 8208474:	1105883a 	add	r2,r2,r4
 8208478:	d8802e15 	stw	r2,184(sp)
 820847c:	10004e16 	blt	r2,zero,82085b8 <___vfprintf_internal_r+0x2080>
 8208480:	044019c4 	movi	r17,103
 8208484:	003e2106 	br	8207d0c <___vfprintf_internal_r+0x17d4>
 8208488:	d9002917 	ldw	r4,164(sp)
 820848c:	d8802104 	addi	r2,sp,132
 8208490:	d8800315 	stw	r2,12(sp)
 8208494:	d9000015 	stw	r4,0(sp)
 8208498:	d8802504 	addi	r2,sp,148
 820849c:	d9403617 	ldw	r5,216(sp)
 82084a0:	d9002c17 	ldw	r4,176(sp)
 82084a4:	d8800215 	stw	r2,8(sp)
 82084a8:	d8802604 	addi	r2,sp,152
 82084ac:	d8800115 	stw	r2,4(sp)
 82084b0:	01c000c4 	movi	r7,3
 82084b4:	980d883a 	mov	r6,r19
 82084b8:	da003d15 	stw	r8,244(sp)
 82084bc:	8208cb40 	call	8208cb4 <_dtoa_r>
 82084c0:	d8c02917 	ldw	r3,164(sp)
 82084c4:	da003d17 	ldw	r8,244(sp)
 82084c8:	1021883a 	mov	r16,r2
 82084cc:	00801184 	movi	r2,70
 82084d0:	80f9883a 	add	fp,r16,r3
 82084d4:	88bfd926 	beq	r17,r2,820843c <___vfprintf_internal_r+0x1f04>
 82084d8:	003de806 	br	8207c7c <___vfprintf_internal_r+0x1744>
 82084dc:	d9002917 	ldw	r4,164(sp)
 82084e0:	00c04d0e 	bge	zero,r3,8208618 <___vfprintf_internal_r+0x20e0>
 82084e4:	2000441e 	bne	r4,zero,82085f8 <___vfprintf_internal_r+0x20c0>
 82084e8:	9480004c 	andi	r18,r18,1
 82084ec:	9000421e 	bne	r18,zero,82085f8 <___vfprintf_internal_r+0x20c0>
 82084f0:	1805883a 	mov	r2,r3
 82084f4:	18007016 	blt	r3,zero,82086b8 <___vfprintf_internal_r+0x2180>
 82084f8:	d8c03217 	ldw	r3,200(sp)
 82084fc:	d8c02e15 	stw	r3,184(sp)
 8208500:	003e0206 	br	8207d0c <___vfprintf_internal_r+0x17d4>
 8208504:	df0022c4 	addi	fp,sp,139
 8208508:	dc002915 	stw	r16,164(sp)
 820850c:	4027883a 	mov	r19,r8
 8208510:	e021883a 	mov	r16,fp
 8208514:	b009883a 	mov	r4,r22
 8208518:	01400284 	movi	r5,10
 820851c:	82026980 	call	8202698 <__modsi3>
 8208520:	10800c04 	addi	r2,r2,48
 8208524:	843fffc4 	addi	r16,r16,-1
 8208528:	b009883a 	mov	r4,r22
 820852c:	01400284 	movi	r5,10
 8208530:	80800005 	stb	r2,0(r16)
 8208534:	82026140 	call	8202614 <__divsi3>
 8208538:	102d883a 	mov	r22,r2
 820853c:	00800244 	movi	r2,9
 8208540:	15bff416 	blt	r2,r22,8208514 <___vfprintf_internal_r+0x1fdc>
 8208544:	9811883a 	mov	r8,r19
 8208548:	b0800c04 	addi	r2,r22,48
 820854c:	8027883a 	mov	r19,r16
 8208550:	997fffc4 	addi	r5,r19,-1
 8208554:	98bfffc5 	stb	r2,-1(r19)
 8208558:	dc002917 	ldw	r16,164(sp)
 820855c:	2f006a2e 	bgeu	r5,fp,8208708 <___vfprintf_internal_r+0x21d0>
 8208560:	d9c02384 	addi	r7,sp,142
 8208564:	3ccfc83a 	sub	r7,r7,r19
 8208568:	d9002344 	addi	r4,sp,141
 820856c:	e1cf883a 	add	r7,fp,r7
 8208570:	00000106 	br	8208578 <___vfprintf_internal_r+0x2040>
 8208574:	28800003 	ldbu	r2,0(r5)
 8208578:	20800005 	stb	r2,0(r4)
 820857c:	21000044 	addi	r4,r4,1
 8208580:	29400044 	addi	r5,r5,1
 8208584:	393ffb1e 	bne	r7,r4,8208574 <___vfprintf_internal_r+0x203c>
 8208588:	d8802304 	addi	r2,sp,140
 820858c:	14c5c83a 	sub	r2,r2,r19
 8208590:	d8c02344 	addi	r3,sp,141
 8208594:	1885883a 	add	r2,r3,r2
 8208598:	003f7006 	br	820835c <___vfprintf_internal_r+0x1e24>
 820859c:	0005883a 	mov	r2,zero
 82085a0:	003f0f06 	br	82081e0 <___vfprintf_internal_r+0x1ca8>
 82085a4:	d8c03217 	ldw	r3,200(sp)
 82085a8:	18c00044 	addi	r3,r3,1
 82085ac:	d8c02e15 	stw	r3,184(sp)
 82085b0:	1805883a 	mov	r2,r3
 82085b4:	183fb20e 	bge	r3,zero,8208480 <___vfprintf_internal_r+0x1f48>
 82085b8:	0005883a 	mov	r2,zero
 82085bc:	003fb006 	br	8208480 <___vfprintf_internal_r+0x1f48>
 82085c0:	d9003617 	ldw	r4,216(sp)
 82085c4:	000d883a 	mov	r6,zero
 82085c8:	000f883a 	mov	r7,zero
 82085cc:	980b883a 	mov	r5,r19
 82085d0:	d8c03c15 	stw	r3,240(sp)
 82085d4:	da003d15 	stw	r8,244(sp)
 82085d8:	82129f80 	call	82129f8 <__eqdf2>
 82085dc:	d8c03c17 	ldw	r3,240(sp)
 82085e0:	da003d17 	ldw	r8,244(sp)
 82085e4:	103f9826 	beq	r2,zero,8208448 <___vfprintf_internal_r+0x1f10>
 82085e8:	00800044 	movi	r2,1
 82085ec:	10c7c83a 	sub	r3,r2,r3
 82085f0:	d8c02615 	stw	r3,152(sp)
 82085f4:	003f9506 	br	820844c <___vfprintf_internal_r+0x1f14>
 82085f8:	d9002917 	ldw	r4,164(sp)
 82085fc:	d8c03217 	ldw	r3,200(sp)
 8208600:	20800044 	addi	r2,r4,1
 8208604:	1885883a 	add	r2,r3,r2
 8208608:	d8802e15 	stw	r2,184(sp)
 820860c:	103dbf0e 	bge	r2,zero,8207d0c <___vfprintf_internal_r+0x17d4>
 8208610:	0005883a 	mov	r2,zero
 8208614:	003dbd06 	br	8207d0c <___vfprintf_internal_r+0x17d4>
 8208618:	2000211e 	bne	r4,zero,82086a0 <___vfprintf_internal_r+0x2168>
 820861c:	9480004c 	andi	r18,r18,1
 8208620:	90001f1e 	bne	r18,zero,82086a0 <___vfprintf_internal_r+0x2168>
 8208624:	00800044 	movi	r2,1
 8208628:	d8802e15 	stw	r2,184(sp)
 820862c:	003db706 	br	8207d0c <___vfprintf_internal_r+0x17d4>
 8208630:	00800b44 	movi	r2,45
 8208634:	05adc83a 	sub	r22,zero,r22
 8208638:	d8802305 	stb	r2,140(sp)
 820863c:	003f3f06 	br	820833c <___vfprintf_internal_r+0x1e04>
 8208640:	0005883a 	mov	r2,zero
 8208644:	003f5206 	br	8208390 <___vfprintf_internal_r+0x1e58>
 8208648:	90a4703a 	and	r18,r18,r2
 820864c:	903f4e26 	beq	r18,zero,8208388 <___vfprintf_internal_r+0x1e50>
 8208650:	003f4a06 	br	820837c <___vfprintf_internal_r+0x1e44>
 8208654:	00800084 	movi	r2,2
 8208658:	10c5c83a 	sub	r2,r2,r3
 820865c:	003f8406 	br	8208470 <___vfprintf_internal_r+0x1f38>
 8208660:	d8802d17 	ldw	r2,180(sp)
 8208664:	d9002d17 	ldw	r4,180(sp)
 8208668:	ac400043 	ldbu	r17,1(r21)
 820866c:	10800017 	ldw	r2,0(r2)
 8208670:	582b883a 	mov	r21,r11
 8208674:	d8802915 	stw	r2,164(sp)
 8208678:	20800104 	addi	r2,r4,4
 820867c:	d9002917 	ldw	r4,164(sp)
 8208680:	d8802d15 	stw	r2,180(sp)
 8208684:	203e7a0e 	bge	r4,zero,8208070 <___vfprintf_internal_r+0x1b38>
 8208688:	8c403fcc 	andi	r17,r17,255
 820868c:	00bfffc4 	movi	r2,-1
 8208690:	8c40201c 	xori	r17,r17,128
 8208694:	d8802915 	stw	r2,164(sp)
 8208698:	8c7fe004 	addi	r17,r17,-128
 820869c:	00380706 	br	82066bc <___vfprintf_internal_r+0x184>
 82086a0:	d8c02917 	ldw	r3,164(sp)
 82086a4:	18c00084 	addi	r3,r3,2
 82086a8:	d8c02e15 	stw	r3,184(sp)
 82086ac:	1805883a 	mov	r2,r3
 82086b0:	183d960e 	bge	r3,zero,8207d0c <___vfprintf_internal_r+0x17d4>
 82086b4:	003fd606 	br	8208610 <___vfprintf_internal_r+0x20d8>
 82086b8:	0005883a 	mov	r2,zero
 82086bc:	003f8e06 	br	82084f8 <___vfprintf_internal_r+0x1fc0>
 82086c0:	9080004c 	andi	r2,r18,1
 82086c4:	103f811e 	bne	r2,zero,82084cc <___vfprintf_internal_r+0x1f94>
 82086c8:	d8802117 	ldw	r2,132(sp)
 82086cc:	1405c83a 	sub	r2,r2,r16
 82086d0:	d8803315 	stw	r2,204(sp)
 82086d4:	b47ef326 	beq	r22,r17,82082a4 <___vfprintf_internal_r+0x1d6c>
 82086d8:	dd802617 	ldw	r22,152(sp)
 82086dc:	003f1106 	br	8208324 <___vfprintf_internal_r+0x1dec>
 82086e0:	d9c02785 	stb	r7,158(sp)
 82086e4:	00390406 	br	8206af8 <___vfprintf_internal_r+0x5c0>
 82086e8:	d9c02785 	stb	r7,158(sp)
 82086ec:	0038d306 	br	8206a3c <___vfprintf_internal_r+0x504>
 82086f0:	d9c02785 	stb	r7,158(sp)
 82086f4:	003a6106 	br	820707c <___vfprintf_internal_r+0xb44>
 82086f8:	d9c02785 	stb	r7,158(sp)
 82086fc:	003af806 	br	82072e0 <___vfprintf_internal_r+0xda8>
 8208700:	0005883a 	mov	r2,zero
 8208704:	003d7e06 	br	8207d00 <___vfprintf_internal_r+0x17c8>
 8208708:	d8802344 	addi	r2,sp,141
 820870c:	003f1306 	br	820835c <___vfprintf_internal_r+0x1e24>
 8208710:	d9c02785 	stb	r7,158(sp)
 8208714:	00392306 	br	8206ba4 <___vfprintf_internal_r+0x66c>
 8208718:	d9c02785 	stb	r7,158(sp)
 820871c:	003aa906 	br	82071c4 <___vfprintf_internal_r+0xc8c>
 8208720:	d9c02785 	stb	r7,158(sp)
 8208724:	003a3d06 	br	820701c <___vfprintf_internal_r+0xae4>
 8208728:	d9c02785 	stb	r7,158(sp)
 820872c:	003aca06 	br	8207258 <___vfprintf_internal_r+0xd20>

08208730 <__vfprintf_internal>:
 8208730:	00820974 	movhi	r2,2085
 8208734:	108e3004 	addi	r2,r2,14528
 8208738:	300f883a 	mov	r7,r6
 820873c:	280d883a 	mov	r6,r5
 8208740:	200b883a 	mov	r5,r4
 8208744:	11000017 	ldw	r4,0(r2)
 8208748:	82065381 	jmpi	8206538 <___vfprintf_internal_r>

0820874c <__sbprintf>:
 820874c:	2880030b 	ldhu	r2,12(r5)
 8208750:	2ac01917 	ldw	r11,100(r5)
 8208754:	2a80038b 	ldhu	r10,14(r5)
 8208758:	2a400717 	ldw	r9,28(r5)
 820875c:	2a000917 	ldw	r8,36(r5)
 8208760:	defee204 	addi	sp,sp,-1144
 8208764:	00c10004 	movi	r3,1024
 8208768:	dc011a15 	stw	r16,1128(sp)
 820876c:	10bfff4c 	andi	r2,r2,65533
 8208770:	2821883a 	mov	r16,r5
 8208774:	d8cb883a 	add	r5,sp,r3
 8208778:	dc811c15 	stw	r18,1136(sp)
 820877c:	dc411b15 	stw	r17,1132(sp)
 8208780:	dfc11d15 	stw	ra,1140(sp)
 8208784:	2025883a 	mov	r18,r4
 8208788:	d881030d 	sth	r2,1036(sp)
 820878c:	dac11915 	stw	r11,1124(sp)
 8208790:	da81038d 	sth	r10,1038(sp)
 8208794:	da410715 	stw	r9,1052(sp)
 8208798:	da010915 	stw	r8,1060(sp)
 820879c:	dec10015 	stw	sp,1024(sp)
 82087a0:	dec10415 	stw	sp,1040(sp)
 82087a4:	d8c10215 	stw	r3,1032(sp)
 82087a8:	d8c10515 	stw	r3,1044(sp)
 82087ac:	d8010615 	stw	zero,1048(sp)
 82087b0:	82065380 	call	8206538 <___vfprintf_internal_r>
 82087b4:	1023883a 	mov	r17,r2
 82087b8:	10000416 	blt	r2,zero,82087cc <__sbprintf+0x80>
 82087bc:	d9410004 	addi	r5,sp,1024
 82087c0:	9009883a 	mov	r4,r18
 82087c4:	820a5580 	call	820a558 <_fflush_r>
 82087c8:	10000d1e 	bne	r2,zero,8208800 <__sbprintf+0xb4>
 82087cc:	d881030b 	ldhu	r2,1036(sp)
 82087d0:	1080100c 	andi	r2,r2,64
 82087d4:	10000326 	beq	r2,zero,82087e4 <__sbprintf+0x98>
 82087d8:	8080030b 	ldhu	r2,12(r16)
 82087dc:	10801014 	ori	r2,r2,64
 82087e0:	8080030d 	sth	r2,12(r16)
 82087e4:	8805883a 	mov	r2,r17
 82087e8:	dfc11d17 	ldw	ra,1140(sp)
 82087ec:	dc811c17 	ldw	r18,1136(sp)
 82087f0:	dc411b17 	ldw	r17,1132(sp)
 82087f4:	dc011a17 	ldw	r16,1128(sp)
 82087f8:	dec11e04 	addi	sp,sp,1144
 82087fc:	f800283a 	ret
 8208800:	047fffc4 	movi	r17,-1
 8208804:	003ff106 	br	82087cc <__sbprintf+0x80>

08208808 <__swbuf_r>:
 8208808:	defffb04 	addi	sp,sp,-20
 820880c:	dcc00315 	stw	r19,12(sp)
 8208810:	dc800215 	stw	r18,8(sp)
 8208814:	dc000015 	stw	r16,0(sp)
 8208818:	dfc00415 	stw	ra,16(sp)
 820881c:	dc400115 	stw	r17,4(sp)
 8208820:	2025883a 	mov	r18,r4
 8208824:	2827883a 	mov	r19,r5
 8208828:	3021883a 	mov	r16,r6
 820882c:	20000226 	beq	r4,zero,8208838 <__swbuf_r+0x30>
 8208830:	20800e17 	ldw	r2,56(r4)
 8208834:	10004226 	beq	r2,zero,8208940 <__swbuf_r+0x138>
 8208838:	80800617 	ldw	r2,24(r16)
 820883c:	8100030b 	ldhu	r4,12(r16)
 8208840:	80800215 	stw	r2,8(r16)
 8208844:	2080020c 	andi	r2,r4,8
 8208848:	10003626 	beq	r2,zero,8208924 <__swbuf_r+0x11c>
 820884c:	80c00417 	ldw	r3,16(r16)
 8208850:	18003426 	beq	r3,zero,8208924 <__swbuf_r+0x11c>
 8208854:	2088000c 	andi	r2,r4,8192
 8208858:	9c403fcc 	andi	r17,r19,255
 820885c:	10001a26 	beq	r2,zero,82088c8 <__swbuf_r+0xc0>
 8208860:	80800017 	ldw	r2,0(r16)
 8208864:	81000517 	ldw	r4,20(r16)
 8208868:	10c7c83a 	sub	r3,r2,r3
 820886c:	1900200e 	bge	r3,r4,82088f0 <__swbuf_r+0xe8>
 8208870:	18c00044 	addi	r3,r3,1
 8208874:	81000217 	ldw	r4,8(r16)
 8208878:	11400044 	addi	r5,r2,1
 820887c:	81400015 	stw	r5,0(r16)
 8208880:	213fffc4 	addi	r4,r4,-1
 8208884:	81000215 	stw	r4,8(r16)
 8208888:	14c00005 	stb	r19,0(r2)
 820888c:	80800517 	ldw	r2,20(r16)
 8208890:	10c01e26 	beq	r2,r3,820890c <__swbuf_r+0x104>
 8208894:	8080030b 	ldhu	r2,12(r16)
 8208898:	1080004c 	andi	r2,r2,1
 820889c:	10000226 	beq	r2,zero,82088a8 <__swbuf_r+0xa0>
 82088a0:	00800284 	movi	r2,10
 82088a4:	88801926 	beq	r17,r2,820890c <__swbuf_r+0x104>
 82088a8:	8805883a 	mov	r2,r17
 82088ac:	dfc00417 	ldw	ra,16(sp)
 82088b0:	dcc00317 	ldw	r19,12(sp)
 82088b4:	dc800217 	ldw	r18,8(sp)
 82088b8:	dc400117 	ldw	r17,4(sp)
 82088bc:	dc000017 	ldw	r16,0(sp)
 82088c0:	dec00504 	addi	sp,sp,20
 82088c4:	f800283a 	ret
 82088c8:	81401917 	ldw	r5,100(r16)
 82088cc:	00b7ffc4 	movi	r2,-8193
 82088d0:	21080014 	ori	r4,r4,8192
 82088d4:	2884703a 	and	r2,r5,r2
 82088d8:	80801915 	stw	r2,100(r16)
 82088dc:	80800017 	ldw	r2,0(r16)
 82088e0:	8100030d 	sth	r4,12(r16)
 82088e4:	81000517 	ldw	r4,20(r16)
 82088e8:	10c7c83a 	sub	r3,r2,r3
 82088ec:	193fe016 	blt	r3,r4,8208870 <__swbuf_r+0x68>
 82088f0:	800b883a 	mov	r5,r16
 82088f4:	9009883a 	mov	r4,r18
 82088f8:	820a5580 	call	820a558 <_fflush_r>
 82088fc:	1000071e 	bne	r2,zero,820891c <__swbuf_r+0x114>
 8208900:	80800017 	ldw	r2,0(r16)
 8208904:	00c00044 	movi	r3,1
 8208908:	003fda06 	br	8208874 <__swbuf_r+0x6c>
 820890c:	800b883a 	mov	r5,r16
 8208910:	9009883a 	mov	r4,r18
 8208914:	820a5580 	call	820a558 <_fflush_r>
 8208918:	103fe326 	beq	r2,zero,82088a8 <__swbuf_r+0xa0>
 820891c:	00bfffc4 	movi	r2,-1
 8208920:	003fe206 	br	82088ac <__swbuf_r+0xa4>
 8208924:	800b883a 	mov	r5,r16
 8208928:	9009883a 	mov	r4,r18
 820892c:	82089600 	call	8208960 <__swsetup_r>
 8208930:	103ffa1e 	bne	r2,zero,820891c <__swbuf_r+0x114>
 8208934:	8100030b 	ldhu	r4,12(r16)
 8208938:	80c00417 	ldw	r3,16(r16)
 820893c:	003fc506 	br	8208854 <__swbuf_r+0x4c>
 8208940:	820a9340 	call	820a934 <__sinit>
 8208944:	003fbc06 	br	8208838 <__swbuf_r+0x30>

08208948 <__swbuf>:
 8208948:	00820974 	movhi	r2,2085
 820894c:	108e3004 	addi	r2,r2,14528
 8208950:	280d883a 	mov	r6,r5
 8208954:	200b883a 	mov	r5,r4
 8208958:	11000017 	ldw	r4,0(r2)
 820895c:	82088081 	jmpi	8208808 <__swbuf_r>

08208960 <__swsetup_r>:
 8208960:	00820974 	movhi	r2,2085
 8208964:	defffd04 	addi	sp,sp,-12
 8208968:	108e3004 	addi	r2,r2,14528
 820896c:	dc400115 	stw	r17,4(sp)
 8208970:	2023883a 	mov	r17,r4
 8208974:	11000017 	ldw	r4,0(r2)
 8208978:	dc000015 	stw	r16,0(sp)
 820897c:	dfc00215 	stw	ra,8(sp)
 8208980:	2821883a 	mov	r16,r5
 8208984:	20000226 	beq	r4,zero,8208990 <__swsetup_r+0x30>
 8208988:	20800e17 	ldw	r2,56(r4)
 820898c:	10003126 	beq	r2,zero,8208a54 <__swsetup_r+0xf4>
 8208990:	8080030b 	ldhu	r2,12(r16)
 8208994:	10c0020c 	andi	r3,r2,8
 8208998:	1009883a 	mov	r4,r2
 820899c:	18000f26 	beq	r3,zero,82089dc <__swsetup_r+0x7c>
 82089a0:	80c00417 	ldw	r3,16(r16)
 82089a4:	18001526 	beq	r3,zero,82089fc <__swsetup_r+0x9c>
 82089a8:	1100004c 	andi	r4,r2,1
 82089ac:	20001c1e 	bne	r4,zero,8208a20 <__swsetup_r+0xc0>
 82089b0:	1080008c 	andi	r2,r2,2
 82089b4:	1000291e 	bne	r2,zero,8208a5c <__swsetup_r+0xfc>
 82089b8:	80800517 	ldw	r2,20(r16)
 82089bc:	80800215 	stw	r2,8(r16)
 82089c0:	18001c26 	beq	r3,zero,8208a34 <__swsetup_r+0xd4>
 82089c4:	0005883a 	mov	r2,zero
 82089c8:	dfc00217 	ldw	ra,8(sp)
 82089cc:	dc400117 	ldw	r17,4(sp)
 82089d0:	dc000017 	ldw	r16,0(sp)
 82089d4:	dec00304 	addi	sp,sp,12
 82089d8:	f800283a 	ret
 82089dc:	2080040c 	andi	r2,r4,16
 82089e0:	10002e26 	beq	r2,zero,8208a9c <__swsetup_r+0x13c>
 82089e4:	2080010c 	andi	r2,r4,4
 82089e8:	10001e1e 	bne	r2,zero,8208a64 <__swsetup_r+0x104>
 82089ec:	80c00417 	ldw	r3,16(r16)
 82089f0:	20800214 	ori	r2,r4,8
 82089f4:	8080030d 	sth	r2,12(r16)
 82089f8:	183feb1e 	bne	r3,zero,82089a8 <__swsetup_r+0x48>
 82089fc:	1100a00c 	andi	r4,r2,640
 8208a00:	01408004 	movi	r5,512
 8208a04:	217fe826 	beq	r4,r5,82089a8 <__swsetup_r+0x48>
 8208a08:	800b883a 	mov	r5,r16
 8208a0c:	8809883a 	mov	r4,r17
 8208a10:	820b62c0 	call	820b62c <__smakebuf_r>
 8208a14:	8080030b 	ldhu	r2,12(r16)
 8208a18:	80c00417 	ldw	r3,16(r16)
 8208a1c:	003fe206 	br	82089a8 <__swsetup_r+0x48>
 8208a20:	80800517 	ldw	r2,20(r16)
 8208a24:	80000215 	stw	zero,8(r16)
 8208a28:	0085c83a 	sub	r2,zero,r2
 8208a2c:	80800615 	stw	r2,24(r16)
 8208a30:	183fe41e 	bne	r3,zero,82089c4 <__swsetup_r+0x64>
 8208a34:	80c0030b 	ldhu	r3,12(r16)
 8208a38:	0005883a 	mov	r2,zero
 8208a3c:	1900200c 	andi	r4,r3,128
 8208a40:	203fe126 	beq	r4,zero,82089c8 <__swsetup_r+0x68>
 8208a44:	18c01014 	ori	r3,r3,64
 8208a48:	80c0030d 	sth	r3,12(r16)
 8208a4c:	00bfffc4 	movi	r2,-1
 8208a50:	003fdd06 	br	82089c8 <__swsetup_r+0x68>
 8208a54:	820a9340 	call	820a934 <__sinit>
 8208a58:	003fcd06 	br	8208990 <__swsetup_r+0x30>
 8208a5c:	0005883a 	mov	r2,zero
 8208a60:	003fd606 	br	82089bc <__swsetup_r+0x5c>
 8208a64:	81400c17 	ldw	r5,48(r16)
 8208a68:	28000626 	beq	r5,zero,8208a84 <__swsetup_r+0x124>
 8208a6c:	80801004 	addi	r2,r16,64
 8208a70:	28800326 	beq	r5,r2,8208a80 <__swsetup_r+0x120>
 8208a74:	8809883a 	mov	r4,r17
 8208a78:	820abfc0 	call	820abfc <_free_r>
 8208a7c:	8100030b 	ldhu	r4,12(r16)
 8208a80:	80000c15 	stw	zero,48(r16)
 8208a84:	80c00417 	ldw	r3,16(r16)
 8208a88:	00bff6c4 	movi	r2,-37
 8208a8c:	1108703a 	and	r4,r2,r4
 8208a90:	80000115 	stw	zero,4(r16)
 8208a94:	80c00015 	stw	r3,0(r16)
 8208a98:	003fd506 	br	82089f0 <__swsetup_r+0x90>
 8208a9c:	00800244 	movi	r2,9
 8208aa0:	88800015 	stw	r2,0(r17)
 8208aa4:	20801014 	ori	r2,r4,64
 8208aa8:	8080030d 	sth	r2,12(r16)
 8208aac:	00bfffc4 	movi	r2,-1
 8208ab0:	003fc506 	br	82089c8 <__swsetup_r+0x68>

08208ab4 <quorem>:
 8208ab4:	defff704 	addi	sp,sp,-36
 8208ab8:	dc800215 	stw	r18,8(sp)
 8208abc:	20800417 	ldw	r2,16(r4)
 8208ac0:	2c800417 	ldw	r18,16(r5)
 8208ac4:	dfc00815 	stw	ra,32(sp)
 8208ac8:	ddc00715 	stw	r23,28(sp)
 8208acc:	dd800615 	stw	r22,24(sp)
 8208ad0:	dd400515 	stw	r21,20(sp)
 8208ad4:	dd000415 	stw	r20,16(sp)
 8208ad8:	dcc00315 	stw	r19,12(sp)
 8208adc:	dc400115 	stw	r17,4(sp)
 8208ae0:	dc000015 	stw	r16,0(sp)
 8208ae4:	14807116 	blt	r2,r18,8208cac <quorem+0x1f8>
 8208ae8:	94bfffc4 	addi	r18,r18,-1
 8208aec:	94ad883a 	add	r22,r18,r18
 8208af0:	b5ad883a 	add	r22,r22,r22
 8208af4:	2c400504 	addi	r17,r5,20
 8208af8:	8da9883a 	add	r20,r17,r22
 8208afc:	25400504 	addi	r21,r4,20
 8208b00:	282f883a 	mov	r23,r5
 8208b04:	adad883a 	add	r22,r21,r22
 8208b08:	a1400017 	ldw	r5,0(r20)
 8208b0c:	2021883a 	mov	r16,r4
 8208b10:	b1000017 	ldw	r4,0(r22)
 8208b14:	29400044 	addi	r5,r5,1
 8208b18:	820270c0 	call	820270c <__udivsi3>
 8208b1c:	1027883a 	mov	r19,r2
 8208b20:	10002c26 	beq	r2,zero,8208bd4 <quorem+0x120>
 8208b24:	a813883a 	mov	r9,r21
 8208b28:	880b883a 	mov	r5,r17
 8208b2c:	0009883a 	mov	r4,zero
 8208b30:	000d883a 	mov	r6,zero
 8208b34:	2a000017 	ldw	r8,0(r5)
 8208b38:	49c00017 	ldw	r7,0(r9)
 8208b3c:	29400104 	addi	r5,r5,4
 8208b40:	40bfffcc 	andi	r2,r8,65535
 8208b44:	14c5383a 	mul	r2,r2,r19
 8208b48:	4010d43a 	srli	r8,r8,16
 8208b4c:	38ffffcc 	andi	r3,r7,65535
 8208b50:	1105883a 	add	r2,r2,r4
 8208b54:	1008d43a 	srli	r4,r2,16
 8208b58:	44d1383a 	mul	r8,r8,r19
 8208b5c:	198d883a 	add	r6,r3,r6
 8208b60:	10ffffcc 	andi	r3,r2,65535
 8208b64:	30c7c83a 	sub	r3,r6,r3
 8208b68:	380ed43a 	srli	r7,r7,16
 8208b6c:	4105883a 	add	r2,r8,r4
 8208b70:	180dd43a 	srai	r6,r3,16
 8208b74:	113fffcc 	andi	r4,r2,65535
 8208b78:	390fc83a 	sub	r7,r7,r4
 8208b7c:	398d883a 	add	r6,r7,r6
 8208b80:	300e943a 	slli	r7,r6,16
 8208b84:	18ffffcc 	andi	r3,r3,65535
 8208b88:	1008d43a 	srli	r4,r2,16
 8208b8c:	38ceb03a 	or	r7,r7,r3
 8208b90:	49c00015 	stw	r7,0(r9)
 8208b94:	300dd43a 	srai	r6,r6,16
 8208b98:	4a400104 	addi	r9,r9,4
 8208b9c:	a17fe52e 	bgeu	r20,r5,8208b34 <quorem+0x80>
 8208ba0:	b0800017 	ldw	r2,0(r22)
 8208ba4:	10000b1e 	bne	r2,zero,8208bd4 <quorem+0x120>
 8208ba8:	b0bfff04 	addi	r2,r22,-4
 8208bac:	a880082e 	bgeu	r21,r2,8208bd0 <quorem+0x11c>
 8208bb0:	b0ffff17 	ldw	r3,-4(r22)
 8208bb4:	18000326 	beq	r3,zero,8208bc4 <quorem+0x110>
 8208bb8:	00000506 	br	8208bd0 <quorem+0x11c>
 8208bbc:	10c00017 	ldw	r3,0(r2)
 8208bc0:	1800031e 	bne	r3,zero,8208bd0 <quorem+0x11c>
 8208bc4:	10bfff04 	addi	r2,r2,-4
 8208bc8:	94bfffc4 	addi	r18,r18,-1
 8208bcc:	a8bffb36 	bltu	r21,r2,8208bbc <quorem+0x108>
 8208bd0:	84800415 	stw	r18,16(r16)
 8208bd4:	b80b883a 	mov	r5,r23
 8208bd8:	8009883a 	mov	r4,r16
 8208bdc:	820ca1c0 	call	820ca1c <__mcmp>
 8208be0:	10002616 	blt	r2,zero,8208c7c <quorem+0x1c8>
 8208be4:	9cc00044 	addi	r19,r19,1
 8208be8:	a805883a 	mov	r2,r21
 8208bec:	000b883a 	mov	r5,zero
 8208bf0:	11000017 	ldw	r4,0(r2)
 8208bf4:	89800017 	ldw	r6,0(r17)
 8208bf8:	10800104 	addi	r2,r2,4
 8208bfc:	20ffffcc 	andi	r3,r4,65535
 8208c00:	194b883a 	add	r5,r3,r5
 8208c04:	30ffffcc 	andi	r3,r6,65535
 8208c08:	28c7c83a 	sub	r3,r5,r3
 8208c0c:	300cd43a 	srli	r6,r6,16
 8208c10:	2008d43a 	srli	r4,r4,16
 8208c14:	180bd43a 	srai	r5,r3,16
 8208c18:	18ffffcc 	andi	r3,r3,65535
 8208c1c:	2189c83a 	sub	r4,r4,r6
 8208c20:	2149883a 	add	r4,r4,r5
 8208c24:	200c943a 	slli	r6,r4,16
 8208c28:	8c400104 	addi	r17,r17,4
 8208c2c:	200bd43a 	srai	r5,r4,16
 8208c30:	30c6b03a 	or	r3,r6,r3
 8208c34:	10ffff15 	stw	r3,-4(r2)
 8208c38:	a47fed2e 	bgeu	r20,r17,8208bf0 <quorem+0x13c>
 8208c3c:	9485883a 	add	r2,r18,r18
 8208c40:	1085883a 	add	r2,r2,r2
 8208c44:	a887883a 	add	r3,r21,r2
 8208c48:	18800017 	ldw	r2,0(r3)
 8208c4c:	10000b1e 	bne	r2,zero,8208c7c <quorem+0x1c8>
 8208c50:	18bfff04 	addi	r2,r3,-4
 8208c54:	a880082e 	bgeu	r21,r2,8208c78 <quorem+0x1c4>
 8208c58:	18ffff17 	ldw	r3,-4(r3)
 8208c5c:	18000326 	beq	r3,zero,8208c6c <quorem+0x1b8>
 8208c60:	00000506 	br	8208c78 <quorem+0x1c4>
 8208c64:	10c00017 	ldw	r3,0(r2)
 8208c68:	1800031e 	bne	r3,zero,8208c78 <quorem+0x1c4>
 8208c6c:	10bfff04 	addi	r2,r2,-4
 8208c70:	94bfffc4 	addi	r18,r18,-1
 8208c74:	a8bffb36 	bltu	r21,r2,8208c64 <quorem+0x1b0>
 8208c78:	84800415 	stw	r18,16(r16)
 8208c7c:	9805883a 	mov	r2,r19
 8208c80:	dfc00817 	ldw	ra,32(sp)
 8208c84:	ddc00717 	ldw	r23,28(sp)
 8208c88:	dd800617 	ldw	r22,24(sp)
 8208c8c:	dd400517 	ldw	r21,20(sp)
 8208c90:	dd000417 	ldw	r20,16(sp)
 8208c94:	dcc00317 	ldw	r19,12(sp)
 8208c98:	dc800217 	ldw	r18,8(sp)
 8208c9c:	dc400117 	ldw	r17,4(sp)
 8208ca0:	dc000017 	ldw	r16,0(sp)
 8208ca4:	dec00904 	addi	sp,sp,36
 8208ca8:	f800283a 	ret
 8208cac:	0005883a 	mov	r2,zero
 8208cb0:	003ff306 	br	8208c80 <quorem+0x1cc>

08208cb4 <_dtoa_r>:
 8208cb4:	20801017 	ldw	r2,64(r4)
 8208cb8:	deffde04 	addi	sp,sp,-136
 8208cbc:	df002015 	stw	fp,128(sp)
 8208cc0:	dcc01b15 	stw	r19,108(sp)
 8208cc4:	dc801a15 	stw	r18,104(sp)
 8208cc8:	dc401915 	stw	r17,100(sp)
 8208ccc:	dc001815 	stw	r16,96(sp)
 8208cd0:	dfc02115 	stw	ra,132(sp)
 8208cd4:	ddc01f15 	stw	r23,124(sp)
 8208cd8:	dd801e15 	stw	r22,120(sp)
 8208cdc:	dd401d15 	stw	r21,116(sp)
 8208ce0:	dd001c15 	stw	r20,112(sp)
 8208ce4:	d9c00315 	stw	r7,12(sp)
 8208ce8:	2039883a 	mov	fp,r4
 8208cec:	3023883a 	mov	r17,r6
 8208cf0:	2825883a 	mov	r18,r5
 8208cf4:	dc002417 	ldw	r16,144(sp)
 8208cf8:	3027883a 	mov	r19,r6
 8208cfc:	10000826 	beq	r2,zero,8208d20 <_dtoa_r+0x6c>
 8208d00:	21801117 	ldw	r6,68(r4)
 8208d04:	00c00044 	movi	r3,1
 8208d08:	100b883a 	mov	r5,r2
 8208d0c:	1986983a 	sll	r3,r3,r6
 8208d10:	11800115 	stw	r6,4(r2)
 8208d14:	10c00215 	stw	r3,8(r2)
 8208d18:	820c1fc0 	call	820c1fc <_Bfree>
 8208d1c:	e0001015 	stw	zero,64(fp)
 8208d20:	88002e16 	blt	r17,zero,8208ddc <_dtoa_r+0x128>
 8208d24:	80000015 	stw	zero,0(r16)
 8208d28:	889ffc2c 	andhi	r2,r17,32752
 8208d2c:	00dffc34 	movhi	r3,32752
 8208d30:	10c01c26 	beq	r2,r3,8208da4 <_dtoa_r+0xf0>
 8208d34:	000d883a 	mov	r6,zero
 8208d38:	000f883a 	mov	r7,zero
 8208d3c:	9009883a 	mov	r4,r18
 8208d40:	980b883a 	mov	r5,r19
 8208d44:	82129f80 	call	82129f8 <__eqdf2>
 8208d48:	10002b1e 	bne	r2,zero,8208df8 <_dtoa_r+0x144>
 8208d4c:	d9c02317 	ldw	r7,140(sp)
 8208d50:	00800044 	movi	r2,1
 8208d54:	38800015 	stw	r2,0(r7)
 8208d58:	d8802517 	ldw	r2,148(sp)
 8208d5c:	10019e26 	beq	r2,zero,82093d8 <_dtoa_r+0x724>
 8208d60:	d8c02517 	ldw	r3,148(sp)
 8208d64:	00820974 	movhi	r2,2085
 8208d68:	10b56144 	addi	r2,r2,-10875
 8208d6c:	18800015 	stw	r2,0(r3)
 8208d70:	10bfffc4 	addi	r2,r2,-1
 8208d74:	dfc02117 	ldw	ra,132(sp)
 8208d78:	df002017 	ldw	fp,128(sp)
 8208d7c:	ddc01f17 	ldw	r23,124(sp)
 8208d80:	dd801e17 	ldw	r22,120(sp)
 8208d84:	dd401d17 	ldw	r21,116(sp)
 8208d88:	dd001c17 	ldw	r20,112(sp)
 8208d8c:	dcc01b17 	ldw	r19,108(sp)
 8208d90:	dc801a17 	ldw	r18,104(sp)
 8208d94:	dc401917 	ldw	r17,100(sp)
 8208d98:	dc001817 	ldw	r16,96(sp)
 8208d9c:	dec02204 	addi	sp,sp,136
 8208da0:	f800283a 	ret
 8208da4:	d8c02317 	ldw	r3,140(sp)
 8208da8:	0089c3c4 	movi	r2,9999
 8208dac:	18800015 	stw	r2,0(r3)
 8208db0:	90017726 	beq	r18,zero,8209390 <_dtoa_r+0x6dc>
 8208db4:	00820974 	movhi	r2,2085
 8208db8:	10b57504 	addi	r2,r2,-10796
 8208dbc:	d9002517 	ldw	r4,148(sp)
 8208dc0:	203fec26 	beq	r4,zero,8208d74 <_dtoa_r+0xc0>
 8208dc4:	10c000c7 	ldb	r3,3(r2)
 8208dc8:	1801781e 	bne	r3,zero,82093ac <_dtoa_r+0x6f8>
 8208dcc:	10c000c4 	addi	r3,r2,3
 8208dd0:	d9802517 	ldw	r6,148(sp)
 8208dd4:	30c00015 	stw	r3,0(r6)
 8208dd8:	003fe606 	br	8208d74 <_dtoa_r+0xc0>
 8208ddc:	04e00034 	movhi	r19,32768
 8208de0:	9cffffc4 	addi	r19,r19,-1
 8208de4:	00800044 	movi	r2,1
 8208de8:	8ce6703a 	and	r19,r17,r19
 8208dec:	80800015 	stw	r2,0(r16)
 8208df0:	9823883a 	mov	r17,r19
 8208df4:	003fcc06 	br	8208d28 <_dtoa_r+0x74>
 8208df8:	d8800204 	addi	r2,sp,8
 8208dfc:	d8800015 	stw	r2,0(sp)
 8208e00:	d9c00104 	addi	r7,sp,4
 8208e04:	900b883a 	mov	r5,r18
 8208e08:	980d883a 	mov	r6,r19
 8208e0c:	e009883a 	mov	r4,fp
 8208e10:	8820d53a 	srli	r16,r17,20
 8208e14:	820cde80 	call	820cde8 <__d2b>
 8208e18:	d8800915 	stw	r2,36(sp)
 8208e1c:	8001651e 	bne	r16,zero,82093b4 <_dtoa_r+0x700>
 8208e20:	dd800217 	ldw	r22,8(sp)
 8208e24:	dc000117 	ldw	r16,4(sp)
 8208e28:	00800804 	movi	r2,32
 8208e2c:	b421883a 	add	r16,r22,r16
 8208e30:	80c10c84 	addi	r3,r16,1074
 8208e34:	10c2d10e 	bge	r2,r3,820997c <_dtoa_r+0xcc8>
 8208e38:	00801004 	movi	r2,64
 8208e3c:	81010484 	addi	r4,r16,1042
 8208e40:	10c7c83a 	sub	r3,r2,r3
 8208e44:	9108d83a 	srl	r4,r18,r4
 8208e48:	88e2983a 	sll	r17,r17,r3
 8208e4c:	2448b03a 	or	r4,r4,r17
 8208e50:	8213dc00 	call	8213dc0 <__floatunsidf>
 8208e54:	017f8434 	movhi	r5,65040
 8208e58:	01800044 	movi	r6,1
 8208e5c:	1009883a 	mov	r4,r2
 8208e60:	194b883a 	add	r5,r3,r5
 8208e64:	843fffc4 	addi	r16,r16,-1
 8208e68:	d9801115 	stw	r6,68(sp)
 8208e6c:	000d883a 	mov	r6,zero
 8208e70:	01cffe34 	movhi	r7,16376
 8208e74:	82133680 	call	8213368 <__subdf3>
 8208e78:	0198dbf4 	movhi	r6,25455
 8208e7c:	01cff4f4 	movhi	r7,16339
 8208e80:	3190d844 	addi	r6,r6,17249
 8208e84:	39e1e9c4 	addi	r7,r7,-30809
 8208e88:	1009883a 	mov	r4,r2
 8208e8c:	180b883a 	mov	r5,r3
 8208e90:	8212c500 	call	8212c50 <__muldf3>
 8208e94:	01a2d874 	movhi	r6,35681
 8208e98:	01cff1f4 	movhi	r7,16327
 8208e9c:	31b22cc4 	addi	r6,r6,-14157
 8208ea0:	39e28a04 	addi	r7,r7,-30168
 8208ea4:	180b883a 	mov	r5,r3
 8208ea8:	1009883a 	mov	r4,r2
 8208eac:	82118640 	call	8211864 <__adddf3>
 8208eb0:	8009883a 	mov	r4,r16
 8208eb4:	1029883a 	mov	r20,r2
 8208eb8:	1823883a 	mov	r17,r3
 8208ebc:	8213ce40 	call	8213ce4 <__floatsidf>
 8208ec0:	019427f4 	movhi	r6,20639
 8208ec4:	01cff4f4 	movhi	r7,16339
 8208ec8:	319e7ec4 	addi	r6,r6,31227
 8208ecc:	39d104c4 	addi	r7,r7,17427
 8208ed0:	1009883a 	mov	r4,r2
 8208ed4:	180b883a 	mov	r5,r3
 8208ed8:	8212c500 	call	8212c50 <__muldf3>
 8208edc:	100d883a 	mov	r6,r2
 8208ee0:	180f883a 	mov	r7,r3
 8208ee4:	a009883a 	mov	r4,r20
 8208ee8:	880b883a 	mov	r5,r17
 8208eec:	82118640 	call	8211864 <__adddf3>
 8208ef0:	1009883a 	mov	r4,r2
 8208ef4:	180b883a 	mov	r5,r3
 8208ef8:	1029883a 	mov	r20,r2
 8208efc:	1823883a 	mov	r17,r3
 8208f00:	8213c640 	call	8213c64 <__fixdfsi>
 8208f04:	000d883a 	mov	r6,zero
 8208f08:	000f883a 	mov	r7,zero
 8208f0c:	a009883a 	mov	r4,r20
 8208f10:	880b883a 	mov	r5,r17
 8208f14:	d8800515 	stw	r2,20(sp)
 8208f18:	8212b5c0 	call	8212b5c <__ledf2>
 8208f1c:	10028716 	blt	r2,zero,820993c <_dtoa_r+0xc88>
 8208f20:	d8c00517 	ldw	r3,20(sp)
 8208f24:	00800584 	movi	r2,22
 8208f28:	10c27536 	bltu	r2,r3,8209900 <_dtoa_r+0xc4c>
 8208f2c:	180490fa 	slli	r2,r3,3
 8208f30:	00c20974 	movhi	r3,2085
 8208f34:	18f59004 	addi	r3,r3,-10688
 8208f38:	1885883a 	add	r2,r3,r2
 8208f3c:	11000017 	ldw	r4,0(r2)
 8208f40:	11400117 	ldw	r5,4(r2)
 8208f44:	900d883a 	mov	r6,r18
 8208f48:	980f883a 	mov	r7,r19
 8208f4c:	8212a800 	call	8212a80 <__gedf2>
 8208f50:	00828d0e 	bge	zero,r2,8209988 <_dtoa_r+0xcd4>
 8208f54:	d9000517 	ldw	r4,20(sp)
 8208f58:	d8000e15 	stw	zero,56(sp)
 8208f5c:	213fffc4 	addi	r4,r4,-1
 8208f60:	d9000515 	stw	r4,20(sp)
 8208f64:	b42dc83a 	sub	r22,r22,r16
 8208f68:	b5bfffc4 	addi	r22,r22,-1
 8208f6c:	b0026f16 	blt	r22,zero,820992c <_dtoa_r+0xc78>
 8208f70:	d8000815 	stw	zero,32(sp)
 8208f74:	d9c00517 	ldw	r7,20(sp)
 8208f78:	38026416 	blt	r7,zero,820990c <_dtoa_r+0xc58>
 8208f7c:	b1ed883a 	add	r22,r22,r7
 8208f80:	d9c00d15 	stw	r7,52(sp)
 8208f84:	d8000a15 	stw	zero,40(sp)
 8208f88:	d9800317 	ldw	r6,12(sp)
 8208f8c:	00800244 	movi	r2,9
 8208f90:	11811436 	bltu	r2,r6,82093e4 <_dtoa_r+0x730>
 8208f94:	00800144 	movi	r2,5
 8208f98:	1184e10e 	bge	r2,r6,820a320 <_dtoa_r+0x166c>
 8208f9c:	31bfff04 	addi	r6,r6,-4
 8208fa0:	d9800315 	stw	r6,12(sp)
 8208fa4:	0023883a 	mov	r17,zero
 8208fa8:	d9800317 	ldw	r6,12(sp)
 8208fac:	008000c4 	movi	r2,3
 8208fb0:	30836726 	beq	r6,r2,8209d50 <_dtoa_r+0x109c>
 8208fb4:	1183410e 	bge	r2,r6,8209cbc <_dtoa_r+0x1008>
 8208fb8:	d9c00317 	ldw	r7,12(sp)
 8208fbc:	00800104 	movi	r2,4
 8208fc0:	38827c26 	beq	r7,r2,82099b4 <_dtoa_r+0xd00>
 8208fc4:	00800144 	movi	r2,5
 8208fc8:	3884c41e 	bne	r7,r2,820a2dc <_dtoa_r+0x1628>
 8208fcc:	00800044 	movi	r2,1
 8208fd0:	d8800b15 	stw	r2,44(sp)
 8208fd4:	d8c00517 	ldw	r3,20(sp)
 8208fd8:	d9002217 	ldw	r4,136(sp)
 8208fdc:	1907883a 	add	r3,r3,r4
 8208fe0:	19800044 	addi	r6,r3,1
 8208fe4:	d8c00c15 	stw	r3,48(sp)
 8208fe8:	d9800615 	stw	r6,24(sp)
 8208fec:	0183a40e 	bge	zero,r6,8209e80 <_dtoa_r+0x11cc>
 8208ff0:	d9800617 	ldw	r6,24(sp)
 8208ff4:	3021883a 	mov	r16,r6
 8208ff8:	e0001115 	stw	zero,68(fp)
 8208ffc:	008005c4 	movi	r2,23
 8209000:	1184c92e 	bgeu	r2,r6,820a328 <_dtoa_r+0x1674>
 8209004:	00c00044 	movi	r3,1
 8209008:	00800104 	movi	r2,4
 820900c:	1085883a 	add	r2,r2,r2
 8209010:	11000504 	addi	r4,r2,20
 8209014:	180b883a 	mov	r5,r3
 8209018:	18c00044 	addi	r3,r3,1
 820901c:	313ffb2e 	bgeu	r6,r4,820900c <_dtoa_r+0x358>
 8209020:	e1401115 	stw	r5,68(fp)
 8209024:	e009883a 	mov	r4,fp
 8209028:	820c1540 	call	820c154 <_Balloc>
 820902c:	d8800715 	stw	r2,28(sp)
 8209030:	e0801015 	stw	r2,64(fp)
 8209034:	00800384 	movi	r2,14
 8209038:	1400f736 	bltu	r2,r16,8209418 <_dtoa_r+0x764>
 820903c:	8800f626 	beq	r17,zero,8209418 <_dtoa_r+0x764>
 8209040:	d9c00517 	ldw	r7,20(sp)
 8209044:	01c39a0e 	bge	zero,r7,8209eb0 <_dtoa_r+0x11fc>
 8209048:	388003cc 	andi	r2,r7,15
 820904c:	100490fa 	slli	r2,r2,3
 8209050:	382bd13a 	srai	r21,r7,4
 8209054:	00c20974 	movhi	r3,2085
 8209058:	18f59004 	addi	r3,r3,-10688
 820905c:	1885883a 	add	r2,r3,r2
 8209060:	a8c0040c 	andi	r3,r21,16
 8209064:	12400017 	ldw	r9,0(r2)
 8209068:	12000117 	ldw	r8,4(r2)
 820906c:	18037926 	beq	r3,zero,8209e54 <_dtoa_r+0x11a0>
 8209070:	00820974 	movhi	r2,2085
 8209074:	10b58604 	addi	r2,r2,-10728
 8209078:	11800817 	ldw	r6,32(r2)
 820907c:	11c00917 	ldw	r7,36(r2)
 8209080:	9009883a 	mov	r4,r18
 8209084:	980b883a 	mov	r5,r19
 8209088:	da001715 	stw	r8,92(sp)
 820908c:	da401615 	stw	r9,88(sp)
 8209090:	82121100 	call	8212110 <__divdf3>
 8209094:	da001717 	ldw	r8,92(sp)
 8209098:	da401617 	ldw	r9,88(sp)
 820909c:	ad4003cc 	andi	r21,r21,15
 82090a0:	040000c4 	movi	r16,3
 82090a4:	1023883a 	mov	r17,r2
 82090a8:	1829883a 	mov	r20,r3
 82090ac:	a8001126 	beq	r21,zero,82090f4 <_dtoa_r+0x440>
 82090b0:	05c20974 	movhi	r23,2085
 82090b4:	bdf58604 	addi	r23,r23,-10728
 82090b8:	4805883a 	mov	r2,r9
 82090bc:	4007883a 	mov	r3,r8
 82090c0:	a980004c 	andi	r6,r21,1
 82090c4:	1009883a 	mov	r4,r2
 82090c8:	a82bd07a 	srai	r21,r21,1
 82090cc:	180b883a 	mov	r5,r3
 82090d0:	30000426 	beq	r6,zero,82090e4 <_dtoa_r+0x430>
 82090d4:	b9800017 	ldw	r6,0(r23)
 82090d8:	b9c00117 	ldw	r7,4(r23)
 82090dc:	84000044 	addi	r16,r16,1
 82090e0:	8212c500 	call	8212c50 <__muldf3>
 82090e4:	bdc00204 	addi	r23,r23,8
 82090e8:	a83ff51e 	bne	r21,zero,82090c0 <_dtoa_r+0x40c>
 82090ec:	1013883a 	mov	r9,r2
 82090f0:	1811883a 	mov	r8,r3
 82090f4:	480d883a 	mov	r6,r9
 82090f8:	400f883a 	mov	r7,r8
 82090fc:	8809883a 	mov	r4,r17
 8209100:	a00b883a 	mov	r5,r20
 8209104:	82121100 	call	8212110 <__divdf3>
 8209108:	d8800f15 	stw	r2,60(sp)
 820910c:	d8c01015 	stw	r3,64(sp)
 8209110:	d8c00e17 	ldw	r3,56(sp)
 8209114:	18000626 	beq	r3,zero,8209130 <_dtoa_r+0x47c>
 8209118:	d9000f17 	ldw	r4,60(sp)
 820911c:	d9401017 	ldw	r5,64(sp)
 8209120:	000d883a 	mov	r6,zero
 8209124:	01cffc34 	movhi	r7,16368
 8209128:	8212b5c0 	call	8212b5c <__ledf2>
 820912c:	10040b16 	blt	r2,zero,820a15c <_dtoa_r+0x14a8>
 8209130:	8009883a 	mov	r4,r16
 8209134:	8213ce40 	call	8213ce4 <__floatsidf>
 8209138:	d9800f17 	ldw	r6,60(sp)
 820913c:	d9c01017 	ldw	r7,64(sp)
 8209140:	1009883a 	mov	r4,r2
 8209144:	180b883a 	mov	r5,r3
 8209148:	8212c500 	call	8212c50 <__muldf3>
 820914c:	000d883a 	mov	r6,zero
 8209150:	01d00734 	movhi	r7,16412
 8209154:	1009883a 	mov	r4,r2
 8209158:	180b883a 	mov	r5,r3
 820915c:	82118640 	call	8211864 <__adddf3>
 8209160:	1021883a 	mov	r16,r2
 8209164:	d8800617 	ldw	r2,24(sp)
 8209168:	047f3034 	movhi	r17,64704
 820916c:	1c63883a 	add	r17,r3,r17
 8209170:	10031826 	beq	r2,zero,8209dd4 <_dtoa_r+0x1120>
 8209174:	d8c00517 	ldw	r3,20(sp)
 8209178:	db000617 	ldw	r12,24(sp)
 820917c:	d8c01315 	stw	r3,76(sp)
 8209180:	d9000b17 	ldw	r4,44(sp)
 8209184:	20038f26 	beq	r4,zero,8209fc4 <_dtoa_r+0x1310>
 8209188:	60bfffc4 	addi	r2,r12,-1
 820918c:	100490fa 	slli	r2,r2,3
 8209190:	00c20974 	movhi	r3,2085
 8209194:	18f59004 	addi	r3,r3,-10688
 8209198:	1885883a 	add	r2,r3,r2
 820919c:	11800017 	ldw	r6,0(r2)
 82091a0:	11c00117 	ldw	r7,4(r2)
 82091a4:	d8800717 	ldw	r2,28(sp)
 82091a8:	0009883a 	mov	r4,zero
 82091ac:	014ff834 	movhi	r5,16352
 82091b0:	db001615 	stw	r12,88(sp)
 82091b4:	15c00044 	addi	r23,r2,1
 82091b8:	82121100 	call	8212110 <__divdf3>
 82091bc:	800d883a 	mov	r6,r16
 82091c0:	880f883a 	mov	r7,r17
 82091c4:	1009883a 	mov	r4,r2
 82091c8:	180b883a 	mov	r5,r3
 82091cc:	82133680 	call	8213368 <__subdf3>
 82091d0:	d9401017 	ldw	r5,64(sp)
 82091d4:	d9000f17 	ldw	r4,60(sp)
 82091d8:	102b883a 	mov	r21,r2
 82091dc:	d8c01215 	stw	r3,72(sp)
 82091e0:	8213c640 	call	8213c64 <__fixdfsi>
 82091e4:	1009883a 	mov	r4,r2
 82091e8:	1029883a 	mov	r20,r2
 82091ec:	8213ce40 	call	8213ce4 <__floatsidf>
 82091f0:	d9000f17 	ldw	r4,60(sp)
 82091f4:	d9401017 	ldw	r5,64(sp)
 82091f8:	100d883a 	mov	r6,r2
 82091fc:	180f883a 	mov	r7,r3
 8209200:	82133680 	call	8213368 <__subdf3>
 8209204:	1823883a 	mov	r17,r3
 8209208:	d8c00717 	ldw	r3,28(sp)
 820920c:	d9401217 	ldw	r5,72(sp)
 8209210:	a2000c04 	addi	r8,r20,48
 8209214:	1021883a 	mov	r16,r2
 8209218:	1a000005 	stb	r8,0(r3)
 820921c:	800d883a 	mov	r6,r16
 8209220:	880f883a 	mov	r7,r17
 8209224:	a809883a 	mov	r4,r21
 8209228:	4029883a 	mov	r20,r8
 820922c:	8212a800 	call	8212a80 <__gedf2>
 8209230:	00841d16 	blt	zero,r2,820a2a8 <_dtoa_r+0x15f4>
 8209234:	800d883a 	mov	r6,r16
 8209238:	880f883a 	mov	r7,r17
 820923c:	0009883a 	mov	r4,zero
 8209240:	014ffc34 	movhi	r5,16368
 8209244:	82133680 	call	8213368 <__subdf3>
 8209248:	d9401217 	ldw	r5,72(sp)
 820924c:	100d883a 	mov	r6,r2
 8209250:	180f883a 	mov	r7,r3
 8209254:	a809883a 	mov	r4,r21
 8209258:	8212a800 	call	8212a80 <__gedf2>
 820925c:	db001617 	ldw	r12,88(sp)
 8209260:	00840e16 	blt	zero,r2,820a29c <_dtoa_r+0x15e8>
 8209264:	00800044 	movi	r2,1
 8209268:	13006b0e 	bge	r2,r12,8209418 <_dtoa_r+0x764>
 820926c:	d9000717 	ldw	r4,28(sp)
 8209270:	dd800f15 	stw	r22,60(sp)
 8209274:	dcc01015 	stw	r19,64(sp)
 8209278:	2319883a 	add	r12,r4,r12
 820927c:	dcc01217 	ldw	r19,72(sp)
 8209280:	602d883a 	mov	r22,r12
 8209284:	dc801215 	stw	r18,72(sp)
 8209288:	b825883a 	mov	r18,r23
 820928c:	00000906 	br	82092b4 <_dtoa_r+0x600>
 8209290:	82133680 	call	8213368 <__subdf3>
 8209294:	a80d883a 	mov	r6,r21
 8209298:	980f883a 	mov	r7,r19
 820929c:	1009883a 	mov	r4,r2
 82092a0:	180b883a 	mov	r5,r3
 82092a4:	8212b5c0 	call	8212b5c <__ledf2>
 82092a8:	1003e816 	blt	r2,zero,820a24c <_dtoa_r+0x1598>
 82092ac:	b825883a 	mov	r18,r23
 82092b0:	bd83e926 	beq	r23,r22,820a258 <_dtoa_r+0x15a4>
 82092b4:	a809883a 	mov	r4,r21
 82092b8:	980b883a 	mov	r5,r19
 82092bc:	000d883a 	mov	r6,zero
 82092c0:	01d00934 	movhi	r7,16420
 82092c4:	8212c500 	call	8212c50 <__muldf3>
 82092c8:	000d883a 	mov	r6,zero
 82092cc:	01d00934 	movhi	r7,16420
 82092d0:	8009883a 	mov	r4,r16
 82092d4:	880b883a 	mov	r5,r17
 82092d8:	102b883a 	mov	r21,r2
 82092dc:	1827883a 	mov	r19,r3
 82092e0:	8212c500 	call	8212c50 <__muldf3>
 82092e4:	180b883a 	mov	r5,r3
 82092e8:	1009883a 	mov	r4,r2
 82092ec:	1821883a 	mov	r16,r3
 82092f0:	1023883a 	mov	r17,r2
 82092f4:	8213c640 	call	8213c64 <__fixdfsi>
 82092f8:	1009883a 	mov	r4,r2
 82092fc:	1029883a 	mov	r20,r2
 8209300:	8213ce40 	call	8213ce4 <__floatsidf>
 8209304:	8809883a 	mov	r4,r17
 8209308:	800b883a 	mov	r5,r16
 820930c:	100d883a 	mov	r6,r2
 8209310:	180f883a 	mov	r7,r3
 8209314:	82133680 	call	8213368 <__subdf3>
 8209318:	a5000c04 	addi	r20,r20,48
 820931c:	a80d883a 	mov	r6,r21
 8209320:	980f883a 	mov	r7,r19
 8209324:	1009883a 	mov	r4,r2
 8209328:	180b883a 	mov	r5,r3
 820932c:	95000005 	stb	r20,0(r18)
 8209330:	1021883a 	mov	r16,r2
 8209334:	1823883a 	mov	r17,r3
 8209338:	8212b5c0 	call	8212b5c <__ledf2>
 820933c:	bdc00044 	addi	r23,r23,1
 8209340:	800d883a 	mov	r6,r16
 8209344:	880f883a 	mov	r7,r17
 8209348:	0009883a 	mov	r4,zero
 820934c:	014ffc34 	movhi	r5,16368
 8209350:	103fcf0e 	bge	r2,zero,8209290 <_dtoa_r+0x5dc>
 8209354:	d8c01317 	ldw	r3,76(sp)
 8209358:	d8c00515 	stw	r3,20(sp)
 820935c:	d9400917 	ldw	r5,36(sp)
 8209360:	e009883a 	mov	r4,fp
 8209364:	820c1fc0 	call	820c1fc <_Bfree>
 8209368:	d9000517 	ldw	r4,20(sp)
 820936c:	d9802317 	ldw	r6,140(sp)
 8209370:	d9c02517 	ldw	r7,148(sp)
 8209374:	b8000005 	stb	zero,0(r23)
 8209378:	20800044 	addi	r2,r4,1
 820937c:	30800015 	stw	r2,0(r6)
 8209380:	3802aa26 	beq	r7,zero,8209e2c <_dtoa_r+0x1178>
 8209384:	3dc00015 	stw	r23,0(r7)
 8209388:	d8800717 	ldw	r2,28(sp)
 820938c:	003e7906 	br	8208d74 <_dtoa_r+0xc0>
 8209390:	00800434 	movhi	r2,16
 8209394:	10bfffc4 	addi	r2,r2,-1
 8209398:	88a2703a 	and	r17,r17,r2
 820939c:	883e851e 	bne	r17,zero,8208db4 <_dtoa_r+0x100>
 82093a0:	00820974 	movhi	r2,2085
 82093a4:	10b57204 	addi	r2,r2,-10808
 82093a8:	003e8406 	br	8208dbc <_dtoa_r+0x108>
 82093ac:	10c00204 	addi	r3,r2,8
 82093b0:	003e8706 	br	8208dd0 <_dtoa_r+0x11c>
 82093b4:	01400434 	movhi	r5,16
 82093b8:	297fffc4 	addi	r5,r5,-1
 82093bc:	994a703a 	and	r5,r19,r5
 82093c0:	9009883a 	mov	r4,r18
 82093c4:	843f0044 	addi	r16,r16,-1023
 82093c8:	294ffc34 	orhi	r5,r5,16368
 82093cc:	dd800217 	ldw	r22,8(sp)
 82093d0:	d8001115 	stw	zero,68(sp)
 82093d4:	003ea506 	br	8208e6c <_dtoa_r+0x1b8>
 82093d8:	00820974 	movhi	r2,2085
 82093dc:	10b56104 	addi	r2,r2,-10876
 82093e0:	003e6406 	br	8208d74 <_dtoa_r+0xc0>
 82093e4:	e0001115 	stw	zero,68(fp)
 82093e8:	000b883a 	mov	r5,zero
 82093ec:	e009883a 	mov	r4,fp
 82093f0:	820c1540 	call	820c154 <_Balloc>
 82093f4:	01bfffc4 	movi	r6,-1
 82093f8:	01c00044 	movi	r7,1
 82093fc:	d8800715 	stw	r2,28(sp)
 8209400:	d9800c15 	stw	r6,48(sp)
 8209404:	e0801015 	stw	r2,64(fp)
 8209408:	d8000315 	stw	zero,12(sp)
 820940c:	d9c00b15 	stw	r7,44(sp)
 8209410:	d9800615 	stw	r6,24(sp)
 8209414:	d8002215 	stw	zero,136(sp)
 8209418:	d8800117 	ldw	r2,4(sp)
 820941c:	10008916 	blt	r2,zero,8209644 <_dtoa_r+0x990>
 8209420:	d9000517 	ldw	r4,20(sp)
 8209424:	00c00384 	movi	r3,14
 8209428:	19008616 	blt	r3,r4,8209644 <_dtoa_r+0x990>
 820942c:	200490fa 	slli	r2,r4,3
 8209430:	00c20974 	movhi	r3,2085
 8209434:	d9802217 	ldw	r6,136(sp)
 8209438:	18f59004 	addi	r3,r3,-10688
 820943c:	1885883a 	add	r2,r3,r2
 8209440:	14000017 	ldw	r16,0(r2)
 8209444:	14400117 	ldw	r17,4(r2)
 8209448:	30016316 	blt	r6,zero,82099d8 <_dtoa_r+0xd24>
 820944c:	800d883a 	mov	r6,r16
 8209450:	880f883a 	mov	r7,r17
 8209454:	9009883a 	mov	r4,r18
 8209458:	980b883a 	mov	r5,r19
 820945c:	82121100 	call	8212110 <__divdf3>
 8209460:	180b883a 	mov	r5,r3
 8209464:	1009883a 	mov	r4,r2
 8209468:	8213c640 	call	8213c64 <__fixdfsi>
 820946c:	1009883a 	mov	r4,r2
 8209470:	102b883a 	mov	r21,r2
 8209474:	8213ce40 	call	8213ce4 <__floatsidf>
 8209478:	800d883a 	mov	r6,r16
 820947c:	880f883a 	mov	r7,r17
 8209480:	1009883a 	mov	r4,r2
 8209484:	180b883a 	mov	r5,r3
 8209488:	8212c500 	call	8212c50 <__muldf3>
 820948c:	100d883a 	mov	r6,r2
 8209490:	180f883a 	mov	r7,r3
 8209494:	9009883a 	mov	r4,r18
 8209498:	980b883a 	mov	r5,r19
 820949c:	82133680 	call	8213368 <__subdf3>
 82094a0:	d9c00717 	ldw	r7,28(sp)
 82094a4:	1009883a 	mov	r4,r2
 82094a8:	a8800c04 	addi	r2,r21,48
 82094ac:	38800005 	stb	r2,0(r7)
 82094b0:	3dc00044 	addi	r23,r7,1
 82094b4:	d9c00617 	ldw	r7,24(sp)
 82094b8:	01800044 	movi	r6,1
 82094bc:	180b883a 	mov	r5,r3
 82094c0:	2005883a 	mov	r2,r4
 82094c4:	39803826 	beq	r7,r6,82095a8 <_dtoa_r+0x8f4>
 82094c8:	000d883a 	mov	r6,zero
 82094cc:	01d00934 	movhi	r7,16420
 82094d0:	8212c500 	call	8212c50 <__muldf3>
 82094d4:	000d883a 	mov	r6,zero
 82094d8:	000f883a 	mov	r7,zero
 82094dc:	1009883a 	mov	r4,r2
 82094e0:	180b883a 	mov	r5,r3
 82094e4:	1025883a 	mov	r18,r2
 82094e8:	1827883a 	mov	r19,r3
 82094ec:	82129f80 	call	82129f8 <__eqdf2>
 82094f0:	103f9a26 	beq	r2,zero,820935c <_dtoa_r+0x6a8>
 82094f4:	d9c00617 	ldw	r7,24(sp)
 82094f8:	d8c00717 	ldw	r3,28(sp)
 82094fc:	b829883a 	mov	r20,r23
 8209500:	38bfffc4 	addi	r2,r7,-1
 8209504:	18ad883a 	add	r22,r3,r2
 8209508:	00000a06 	br	8209534 <_dtoa_r+0x880>
 820950c:	8212c500 	call	8212c50 <__muldf3>
 8209510:	000d883a 	mov	r6,zero
 8209514:	000f883a 	mov	r7,zero
 8209518:	1009883a 	mov	r4,r2
 820951c:	180b883a 	mov	r5,r3
 8209520:	1025883a 	mov	r18,r2
 8209524:	1827883a 	mov	r19,r3
 8209528:	b829883a 	mov	r20,r23
 820952c:	82129f80 	call	82129f8 <__eqdf2>
 8209530:	103f8a26 	beq	r2,zero,820935c <_dtoa_r+0x6a8>
 8209534:	800d883a 	mov	r6,r16
 8209538:	880f883a 	mov	r7,r17
 820953c:	9009883a 	mov	r4,r18
 8209540:	980b883a 	mov	r5,r19
 8209544:	82121100 	call	8212110 <__divdf3>
 8209548:	180b883a 	mov	r5,r3
 820954c:	1009883a 	mov	r4,r2
 8209550:	8213c640 	call	8213c64 <__fixdfsi>
 8209554:	1009883a 	mov	r4,r2
 8209558:	102b883a 	mov	r21,r2
 820955c:	8213ce40 	call	8213ce4 <__floatsidf>
 8209560:	800d883a 	mov	r6,r16
 8209564:	880f883a 	mov	r7,r17
 8209568:	1009883a 	mov	r4,r2
 820956c:	180b883a 	mov	r5,r3
 8209570:	8212c500 	call	8212c50 <__muldf3>
 8209574:	100d883a 	mov	r6,r2
 8209578:	180f883a 	mov	r7,r3
 820957c:	9009883a 	mov	r4,r18
 8209580:	980b883a 	mov	r5,r19
 8209584:	82133680 	call	8213368 <__subdf3>
 8209588:	aa000c04 	addi	r8,r21,48
 820958c:	a2000005 	stb	r8,0(r20)
 8209590:	000d883a 	mov	r6,zero
 8209594:	01d00934 	movhi	r7,16420
 8209598:	1009883a 	mov	r4,r2
 820959c:	180b883a 	mov	r5,r3
 82095a0:	a5c00044 	addi	r23,r20,1
 82095a4:	b53fd91e 	bne	r22,r20,820950c <_dtoa_r+0x858>
 82095a8:	100d883a 	mov	r6,r2
 82095ac:	180f883a 	mov	r7,r3
 82095b0:	1009883a 	mov	r4,r2
 82095b4:	180b883a 	mov	r5,r3
 82095b8:	82118640 	call	8211864 <__adddf3>
 82095bc:	100d883a 	mov	r6,r2
 82095c0:	180f883a 	mov	r7,r3
 82095c4:	8009883a 	mov	r4,r16
 82095c8:	880b883a 	mov	r5,r17
 82095cc:	1027883a 	mov	r19,r2
 82095d0:	1825883a 	mov	r18,r3
 82095d4:	8212b5c0 	call	8212b5c <__ledf2>
 82095d8:	10000816 	blt	r2,zero,82095fc <_dtoa_r+0x948>
 82095dc:	980d883a 	mov	r6,r19
 82095e0:	900f883a 	mov	r7,r18
 82095e4:	8009883a 	mov	r4,r16
 82095e8:	880b883a 	mov	r5,r17
 82095ec:	82129f80 	call	82129f8 <__eqdf2>
 82095f0:	103f5a1e 	bne	r2,zero,820935c <_dtoa_r+0x6a8>
 82095f4:	ad40004c 	andi	r21,r21,1
 82095f8:	a83f5826 	beq	r21,zero,820935c <_dtoa_r+0x6a8>
 82095fc:	bd3fffc3 	ldbu	r20,-1(r23)
 8209600:	b8bfffc4 	addi	r2,r23,-1
 8209604:	1007883a 	mov	r3,r2
 8209608:	01400e44 	movi	r5,57
 820960c:	d9800717 	ldw	r6,28(sp)
 8209610:	00000506 	br	8209628 <_dtoa_r+0x974>
 8209614:	18ffffc4 	addi	r3,r3,-1
 8209618:	11824726 	beq	r2,r6,8209f38 <_dtoa_r+0x1284>
 820961c:	1d000003 	ldbu	r20,0(r3)
 8209620:	102f883a 	mov	r23,r2
 8209624:	10bfffc4 	addi	r2,r2,-1
 8209628:	a1003fcc 	andi	r4,r20,255
 820962c:	2100201c 	xori	r4,r4,128
 8209630:	213fe004 	addi	r4,r4,-128
 8209634:	217ff726 	beq	r4,r5,8209614 <_dtoa_r+0x960>
 8209638:	a2000044 	addi	r8,r20,1
 820963c:	12000005 	stb	r8,0(r2)
 8209640:	003f4606 	br	820935c <_dtoa_r+0x6a8>
 8209644:	d9000b17 	ldw	r4,44(sp)
 8209648:	2000c826 	beq	r4,zero,820996c <_dtoa_r+0xcb8>
 820964c:	d9800317 	ldw	r6,12(sp)
 8209650:	00c00044 	movi	r3,1
 8209654:	1980f90e 	bge	r3,r6,8209a3c <_dtoa_r+0xd88>
 8209658:	d8800617 	ldw	r2,24(sp)
 820965c:	d8c00a17 	ldw	r3,40(sp)
 8209660:	157fffc4 	addi	r21,r2,-1
 8209664:	1d41f316 	blt	r3,r21,8209e34 <_dtoa_r+0x1180>
 8209668:	1d6bc83a 	sub	r21,r3,r21
 820966c:	d9c00617 	ldw	r7,24(sp)
 8209670:	3802aa16 	blt	r7,zero,820a11c <_dtoa_r+0x1468>
 8209674:	dd000817 	ldw	r20,32(sp)
 8209678:	d8800617 	ldw	r2,24(sp)
 820967c:	d8c00817 	ldw	r3,32(sp)
 8209680:	01400044 	movi	r5,1
 8209684:	e009883a 	mov	r4,fp
 8209688:	1887883a 	add	r3,r3,r2
 820968c:	d8c00815 	stw	r3,32(sp)
 8209690:	b0ad883a 	add	r22,r22,r2
 8209694:	820c5600 	call	820c560 <__i2b>
 8209698:	1023883a 	mov	r17,r2
 820969c:	a0000826 	beq	r20,zero,82096c0 <_dtoa_r+0xa0c>
 82096a0:	0580070e 	bge	zero,r22,82096c0 <_dtoa_r+0xa0c>
 82096a4:	a005883a 	mov	r2,r20
 82096a8:	b500b916 	blt	r22,r20,8209990 <_dtoa_r+0xcdc>
 82096ac:	d9000817 	ldw	r4,32(sp)
 82096b0:	a0a9c83a 	sub	r20,r20,r2
 82096b4:	b0adc83a 	sub	r22,r22,r2
 82096b8:	2089c83a 	sub	r4,r4,r2
 82096bc:	d9000815 	stw	r4,32(sp)
 82096c0:	d9800a17 	ldw	r6,40(sp)
 82096c4:	0181810e 	bge	zero,r6,8209ccc <_dtoa_r+0x1018>
 82096c8:	d9c00b17 	ldw	r7,44(sp)
 82096cc:	3800b326 	beq	r7,zero,820999c <_dtoa_r+0xce8>
 82096d0:	a800b226 	beq	r21,zero,820999c <_dtoa_r+0xce8>
 82096d4:	880b883a 	mov	r5,r17
 82096d8:	a80d883a 	mov	r6,r21
 82096dc:	e009883a 	mov	r4,fp
 82096e0:	820c7940 	call	820c794 <__pow5mult>
 82096e4:	d9800917 	ldw	r6,36(sp)
 82096e8:	100b883a 	mov	r5,r2
 82096ec:	e009883a 	mov	r4,fp
 82096f0:	1023883a 	mov	r17,r2
 82096f4:	820c59c0 	call	820c59c <__multiply>
 82096f8:	1021883a 	mov	r16,r2
 82096fc:	d8800a17 	ldw	r2,40(sp)
 8209700:	d9400917 	ldw	r5,36(sp)
 8209704:	e009883a 	mov	r4,fp
 8209708:	1545c83a 	sub	r2,r2,r21
 820970c:	d8800a15 	stw	r2,40(sp)
 8209710:	820c1fc0 	call	820c1fc <_Bfree>
 8209714:	d8c00a17 	ldw	r3,40(sp)
 8209718:	18009f1e 	bne	r3,zero,8209998 <_dtoa_r+0xce4>
 820971c:	05c00044 	movi	r23,1
 8209720:	e009883a 	mov	r4,fp
 8209724:	b80b883a 	mov	r5,r23
 8209728:	820c5600 	call	820c560 <__i2b>
 820972c:	d9000d17 	ldw	r4,52(sp)
 8209730:	102b883a 	mov	r21,r2
 8209734:	2000ce26 	beq	r4,zero,8209a70 <_dtoa_r+0xdbc>
 8209738:	200d883a 	mov	r6,r4
 820973c:	100b883a 	mov	r5,r2
 8209740:	e009883a 	mov	r4,fp
 8209744:	820c7940 	call	820c794 <__pow5mult>
 8209748:	d9800317 	ldw	r6,12(sp)
 820974c:	102b883a 	mov	r21,r2
 8209750:	b981810e 	bge	r23,r6,8209d58 <_dtoa_r+0x10a4>
 8209754:	0027883a 	mov	r19,zero
 8209758:	a8800417 	ldw	r2,16(r21)
 820975c:	05c00804 	movi	r23,32
 8209760:	10800104 	addi	r2,r2,4
 8209764:	1085883a 	add	r2,r2,r2
 8209768:	1085883a 	add	r2,r2,r2
 820976c:	a885883a 	add	r2,r21,r2
 8209770:	11000017 	ldw	r4,0(r2)
 8209774:	820c4480 	call	820c448 <__hi0bits>
 8209778:	b885c83a 	sub	r2,r23,r2
 820977c:	1585883a 	add	r2,r2,r22
 8209780:	108007cc 	andi	r2,r2,31
 8209784:	1000b326 	beq	r2,zero,8209a54 <_dtoa_r+0xda0>
 8209788:	00c00804 	movi	r3,32
 820978c:	1887c83a 	sub	r3,r3,r2
 8209790:	01000104 	movi	r4,4
 8209794:	20c2cd0e 	bge	r4,r3,820a2cc <_dtoa_r+0x1618>
 8209798:	00c00704 	movi	r3,28
 820979c:	1885c83a 	sub	r2,r3,r2
 82097a0:	d8c00817 	ldw	r3,32(sp)
 82097a4:	a0a9883a 	add	r20,r20,r2
 82097a8:	b0ad883a 	add	r22,r22,r2
 82097ac:	1887883a 	add	r3,r3,r2
 82097b0:	d8c00815 	stw	r3,32(sp)
 82097b4:	d9800817 	ldw	r6,32(sp)
 82097b8:	0180040e 	bge	zero,r6,82097cc <_dtoa_r+0xb18>
 82097bc:	800b883a 	mov	r5,r16
 82097c0:	e009883a 	mov	r4,fp
 82097c4:	820c8d40 	call	820c8d4 <__lshift>
 82097c8:	1021883a 	mov	r16,r2
 82097cc:	0580050e 	bge	zero,r22,82097e4 <_dtoa_r+0xb30>
 82097d0:	a80b883a 	mov	r5,r21
 82097d4:	b00d883a 	mov	r6,r22
 82097d8:	e009883a 	mov	r4,fp
 82097dc:	820c8d40 	call	820c8d4 <__lshift>
 82097e0:	102b883a 	mov	r21,r2
 82097e4:	d9c00e17 	ldw	r7,56(sp)
 82097e8:	3801211e 	bne	r7,zero,8209c70 <_dtoa_r+0xfbc>
 82097ec:	d9800617 	ldw	r6,24(sp)
 82097f0:	0181380e 	bge	zero,r6,8209cd4 <_dtoa_r+0x1020>
 82097f4:	d8c00b17 	ldw	r3,44(sp)
 82097f8:	1800ab1e 	bne	r3,zero,8209aa8 <_dtoa_r+0xdf4>
 82097fc:	dc800717 	ldw	r18,28(sp)
 8209800:	dcc00617 	ldw	r19,24(sp)
 8209804:	9029883a 	mov	r20,r18
 8209808:	00000206 	br	8209814 <_dtoa_r+0xb60>
 820980c:	820c2240 	call	820c224 <__multadd>
 8209810:	1021883a 	mov	r16,r2
 8209814:	a80b883a 	mov	r5,r21
 8209818:	8009883a 	mov	r4,r16
 820981c:	8208ab40 	call	8208ab4 <quorem>
 8209820:	10800c04 	addi	r2,r2,48
 8209824:	90800005 	stb	r2,0(r18)
 8209828:	94800044 	addi	r18,r18,1
 820982c:	9507c83a 	sub	r3,r18,r20
 8209830:	000f883a 	mov	r7,zero
 8209834:	01800284 	movi	r6,10
 8209838:	800b883a 	mov	r5,r16
 820983c:	e009883a 	mov	r4,fp
 8209840:	1cfff216 	blt	r3,r19,820980c <_dtoa_r+0xb58>
 8209844:	1011883a 	mov	r8,r2
 8209848:	d8800617 	ldw	r2,24(sp)
 820984c:	0082370e 	bge	zero,r2,820a12c <_dtoa_r+0x1478>
 8209850:	d9000717 	ldw	r4,28(sp)
 8209854:	0025883a 	mov	r18,zero
 8209858:	20af883a 	add	r23,r4,r2
 820985c:	01800044 	movi	r6,1
 8209860:	800b883a 	mov	r5,r16
 8209864:	e009883a 	mov	r4,fp
 8209868:	da001715 	stw	r8,92(sp)
 820986c:	820c8d40 	call	820c8d4 <__lshift>
 8209870:	a80b883a 	mov	r5,r21
 8209874:	1009883a 	mov	r4,r2
 8209878:	d8800915 	stw	r2,36(sp)
 820987c:	820ca1c0 	call	820ca1c <__mcmp>
 8209880:	da001717 	ldw	r8,92(sp)
 8209884:	0081800e 	bge	zero,r2,8209e88 <_dtoa_r+0x11d4>
 8209888:	b93fffc3 	ldbu	r4,-1(r23)
 820988c:	b8bfffc4 	addi	r2,r23,-1
 8209890:	1007883a 	mov	r3,r2
 8209894:	01800e44 	movi	r6,57
 8209898:	d9c00717 	ldw	r7,28(sp)
 820989c:	00000506 	br	82098b4 <_dtoa_r+0xc00>
 82098a0:	18ffffc4 	addi	r3,r3,-1
 82098a4:	11c12326 	beq	r2,r7,8209d34 <_dtoa_r+0x1080>
 82098a8:	19000003 	ldbu	r4,0(r3)
 82098ac:	102f883a 	mov	r23,r2
 82098b0:	10bfffc4 	addi	r2,r2,-1
 82098b4:	21403fcc 	andi	r5,r4,255
 82098b8:	2940201c 	xori	r5,r5,128
 82098bc:	297fe004 	addi	r5,r5,-128
 82098c0:	29bff726 	beq	r5,r6,82098a0 <_dtoa_r+0xbec>
 82098c4:	21000044 	addi	r4,r4,1
 82098c8:	11000005 	stb	r4,0(r2)
 82098cc:	a80b883a 	mov	r5,r21
 82098d0:	e009883a 	mov	r4,fp
 82098d4:	820c1fc0 	call	820c1fc <_Bfree>
 82098d8:	883ea026 	beq	r17,zero,820935c <_dtoa_r+0x6a8>
 82098dc:	90000426 	beq	r18,zero,82098f0 <_dtoa_r+0xc3c>
 82098e0:	94400326 	beq	r18,r17,82098f0 <_dtoa_r+0xc3c>
 82098e4:	900b883a 	mov	r5,r18
 82098e8:	e009883a 	mov	r4,fp
 82098ec:	820c1fc0 	call	820c1fc <_Bfree>
 82098f0:	880b883a 	mov	r5,r17
 82098f4:	e009883a 	mov	r4,fp
 82098f8:	820c1fc0 	call	820c1fc <_Bfree>
 82098fc:	003e9706 	br	820935c <_dtoa_r+0x6a8>
 8209900:	01800044 	movi	r6,1
 8209904:	d9800e15 	stw	r6,56(sp)
 8209908:	003d9606 	br	8208f64 <_dtoa_r+0x2b0>
 820990c:	d8800817 	ldw	r2,32(sp)
 8209910:	d8c00517 	ldw	r3,20(sp)
 8209914:	d8000d15 	stw	zero,52(sp)
 8209918:	10c5c83a 	sub	r2,r2,r3
 820991c:	00c9c83a 	sub	r4,zero,r3
 8209920:	d8800815 	stw	r2,32(sp)
 8209924:	d9000a15 	stw	r4,40(sp)
 8209928:	003d9706 	br	8208f88 <_dtoa_r+0x2d4>
 820992c:	05adc83a 	sub	r22,zero,r22
 8209930:	dd800815 	stw	r22,32(sp)
 8209934:	002d883a 	mov	r22,zero
 8209938:	003d8e06 	br	8208f74 <_dtoa_r+0x2c0>
 820993c:	d9000517 	ldw	r4,20(sp)
 8209940:	8213ce40 	call	8213ce4 <__floatsidf>
 8209944:	100d883a 	mov	r6,r2
 8209948:	180f883a 	mov	r7,r3
 820994c:	a009883a 	mov	r4,r20
 8209950:	880b883a 	mov	r5,r17
 8209954:	82129f80 	call	82129f8 <__eqdf2>
 8209958:	103d7126 	beq	r2,zero,8208f20 <_dtoa_r+0x26c>
 820995c:	d9c00517 	ldw	r7,20(sp)
 8209960:	39ffffc4 	addi	r7,r7,-1
 8209964:	d9c00515 	stw	r7,20(sp)
 8209968:	003d6d06 	br	8208f20 <_dtoa_r+0x26c>
 820996c:	dd400a17 	ldw	r21,40(sp)
 8209970:	dd000817 	ldw	r20,32(sp)
 8209974:	0023883a 	mov	r17,zero
 8209978:	003f4806 	br	820969c <_dtoa_r+0x9e8>
 820997c:	10e3c83a 	sub	r17,r2,r3
 8209980:	9448983a 	sll	r4,r18,r17
 8209984:	003d3206 	br	8208e50 <_dtoa_r+0x19c>
 8209988:	d8000e15 	stw	zero,56(sp)
 820998c:	003d7506 	br	8208f64 <_dtoa_r+0x2b0>
 8209990:	b005883a 	mov	r2,r22
 8209994:	003f4506 	br	82096ac <_dtoa_r+0x9f8>
 8209998:	dc000915 	stw	r16,36(sp)
 820999c:	d9800a17 	ldw	r6,40(sp)
 82099a0:	d9400917 	ldw	r5,36(sp)
 82099a4:	e009883a 	mov	r4,fp
 82099a8:	820c7940 	call	820c794 <__pow5mult>
 82099ac:	1021883a 	mov	r16,r2
 82099b0:	003f5a06 	br	820971c <_dtoa_r+0xa68>
 82099b4:	01c00044 	movi	r7,1
 82099b8:	d9c00b15 	stw	r7,44(sp)
 82099bc:	d8802217 	ldw	r2,136(sp)
 82099c0:	0081280e 	bge	zero,r2,8209e64 <_dtoa_r+0x11b0>
 82099c4:	100d883a 	mov	r6,r2
 82099c8:	1021883a 	mov	r16,r2
 82099cc:	d8800c15 	stw	r2,48(sp)
 82099d0:	d8800615 	stw	r2,24(sp)
 82099d4:	003d8806 	br	8208ff8 <_dtoa_r+0x344>
 82099d8:	d8800617 	ldw	r2,24(sp)
 82099dc:	00be9b16 	blt	zero,r2,820944c <_dtoa_r+0x798>
 82099e0:	10010f1e 	bne	r2,zero,8209e20 <_dtoa_r+0x116c>
 82099e4:	880b883a 	mov	r5,r17
 82099e8:	000d883a 	mov	r6,zero
 82099ec:	01d00534 	movhi	r7,16404
 82099f0:	8009883a 	mov	r4,r16
 82099f4:	8212c500 	call	8212c50 <__muldf3>
 82099f8:	900d883a 	mov	r6,r18
 82099fc:	980f883a 	mov	r7,r19
 8209a00:	1009883a 	mov	r4,r2
 8209a04:	180b883a 	mov	r5,r3
 8209a08:	8212a800 	call	8212a80 <__gedf2>
 8209a0c:	002b883a 	mov	r21,zero
 8209a10:	0023883a 	mov	r17,zero
 8209a14:	1000bf16 	blt	r2,zero,8209d14 <_dtoa_r+0x1060>
 8209a18:	d9802217 	ldw	r6,136(sp)
 8209a1c:	ddc00717 	ldw	r23,28(sp)
 8209a20:	018c303a 	nor	r6,zero,r6
 8209a24:	d9800515 	stw	r6,20(sp)
 8209a28:	a80b883a 	mov	r5,r21
 8209a2c:	e009883a 	mov	r4,fp
 8209a30:	820c1fc0 	call	820c1fc <_Bfree>
 8209a34:	883e4926 	beq	r17,zero,820935c <_dtoa_r+0x6a8>
 8209a38:	003fad06 	br	82098f0 <_dtoa_r+0xc3c>
 8209a3c:	d9c01117 	ldw	r7,68(sp)
 8209a40:	3801bc26 	beq	r7,zero,820a134 <_dtoa_r+0x1480>
 8209a44:	10810cc4 	addi	r2,r2,1075
 8209a48:	dd400a17 	ldw	r21,40(sp)
 8209a4c:	dd000817 	ldw	r20,32(sp)
 8209a50:	003f0a06 	br	820967c <_dtoa_r+0x9c8>
 8209a54:	00800704 	movi	r2,28
 8209a58:	d9000817 	ldw	r4,32(sp)
 8209a5c:	a0a9883a 	add	r20,r20,r2
 8209a60:	b0ad883a 	add	r22,r22,r2
 8209a64:	2089883a 	add	r4,r4,r2
 8209a68:	d9000815 	stw	r4,32(sp)
 8209a6c:	003f5106 	br	82097b4 <_dtoa_r+0xb00>
 8209a70:	d8c00317 	ldw	r3,12(sp)
 8209a74:	b8c1fc0e 	bge	r23,r3,820a268 <_dtoa_r+0x15b4>
 8209a78:	0027883a 	mov	r19,zero
 8209a7c:	b805883a 	mov	r2,r23
 8209a80:	003f3e06 	br	820977c <_dtoa_r+0xac8>
 8209a84:	880b883a 	mov	r5,r17
 8209a88:	e009883a 	mov	r4,fp
 8209a8c:	000f883a 	mov	r7,zero
 8209a90:	01800284 	movi	r6,10
 8209a94:	820c2240 	call	820c224 <__multadd>
 8209a98:	d9000c17 	ldw	r4,48(sp)
 8209a9c:	1023883a 	mov	r17,r2
 8209aa0:	0102040e 	bge	zero,r4,820a2b4 <_dtoa_r+0x1600>
 8209aa4:	d9000615 	stw	r4,24(sp)
 8209aa8:	0500050e 	bge	zero,r20,8209ac0 <_dtoa_r+0xe0c>
 8209aac:	880b883a 	mov	r5,r17
 8209ab0:	a00d883a 	mov	r6,r20
 8209ab4:	e009883a 	mov	r4,fp
 8209ab8:	820c8d40 	call	820c8d4 <__lshift>
 8209abc:	1023883a 	mov	r17,r2
 8209ac0:	9801241e 	bne	r19,zero,8209f54 <_dtoa_r+0x12a0>
 8209ac4:	8829883a 	mov	r20,r17
 8209ac8:	d9000617 	ldw	r4,24(sp)
 8209acc:	dcc00717 	ldw	r19,28(sp)
 8209ad0:	9480004c 	andi	r18,r18,1
 8209ad4:	20bfffc4 	addi	r2,r4,-1
 8209ad8:	9885883a 	add	r2,r19,r2
 8209adc:	d8800415 	stw	r2,16(sp)
 8209ae0:	dc800615 	stw	r18,24(sp)
 8209ae4:	a80b883a 	mov	r5,r21
 8209ae8:	8009883a 	mov	r4,r16
 8209aec:	8208ab40 	call	8208ab4 <quorem>
 8209af0:	880b883a 	mov	r5,r17
 8209af4:	8009883a 	mov	r4,r16
 8209af8:	102f883a 	mov	r23,r2
 8209afc:	820ca1c0 	call	820ca1c <__mcmp>
 8209b00:	a80b883a 	mov	r5,r21
 8209b04:	a00d883a 	mov	r6,r20
 8209b08:	e009883a 	mov	r4,fp
 8209b0c:	102d883a 	mov	r22,r2
 8209b10:	820ca7c0 	call	820ca7c <__mdiff>
 8209b14:	1007883a 	mov	r3,r2
 8209b18:	10800317 	ldw	r2,12(r2)
 8209b1c:	bc800c04 	addi	r18,r23,48
 8209b20:	180b883a 	mov	r5,r3
 8209b24:	10004e1e 	bne	r2,zero,8209c60 <_dtoa_r+0xfac>
 8209b28:	8009883a 	mov	r4,r16
 8209b2c:	d8c01615 	stw	r3,88(sp)
 8209b30:	820ca1c0 	call	820ca1c <__mcmp>
 8209b34:	d8c01617 	ldw	r3,88(sp)
 8209b38:	e009883a 	mov	r4,fp
 8209b3c:	d8801615 	stw	r2,88(sp)
 8209b40:	180b883a 	mov	r5,r3
 8209b44:	820c1fc0 	call	820c1fc <_Bfree>
 8209b48:	d8801617 	ldw	r2,88(sp)
 8209b4c:	1000041e 	bne	r2,zero,8209b60 <_dtoa_r+0xeac>
 8209b50:	d9800317 	ldw	r6,12(sp)
 8209b54:	3000021e 	bne	r6,zero,8209b60 <_dtoa_r+0xeac>
 8209b58:	d8c00617 	ldw	r3,24(sp)
 8209b5c:	18003726 	beq	r3,zero,8209c3c <_dtoa_r+0xf88>
 8209b60:	b0002016 	blt	r22,zero,8209be4 <_dtoa_r+0xf30>
 8209b64:	b000041e 	bne	r22,zero,8209b78 <_dtoa_r+0xec4>
 8209b68:	d9000317 	ldw	r4,12(sp)
 8209b6c:	2000021e 	bne	r4,zero,8209b78 <_dtoa_r+0xec4>
 8209b70:	d8c00617 	ldw	r3,24(sp)
 8209b74:	18001b26 	beq	r3,zero,8209be4 <_dtoa_r+0xf30>
 8209b78:	00810716 	blt	zero,r2,8209f98 <_dtoa_r+0x12e4>
 8209b7c:	d8c00417 	ldw	r3,16(sp)
 8209b80:	9d800044 	addi	r22,r19,1
 8209b84:	9c800005 	stb	r18,0(r19)
 8209b88:	b02f883a 	mov	r23,r22
 8209b8c:	98c10626 	beq	r19,r3,8209fa8 <_dtoa_r+0x12f4>
 8209b90:	800b883a 	mov	r5,r16
 8209b94:	000f883a 	mov	r7,zero
 8209b98:	01800284 	movi	r6,10
 8209b9c:	e009883a 	mov	r4,fp
 8209ba0:	820c2240 	call	820c224 <__multadd>
 8209ba4:	1021883a 	mov	r16,r2
 8209ba8:	000f883a 	mov	r7,zero
 8209bac:	01800284 	movi	r6,10
 8209bb0:	880b883a 	mov	r5,r17
 8209bb4:	e009883a 	mov	r4,fp
 8209bb8:	8d002526 	beq	r17,r20,8209c50 <_dtoa_r+0xf9c>
 8209bbc:	820c2240 	call	820c224 <__multadd>
 8209bc0:	a00b883a 	mov	r5,r20
 8209bc4:	000f883a 	mov	r7,zero
 8209bc8:	01800284 	movi	r6,10
 8209bcc:	e009883a 	mov	r4,fp
 8209bd0:	1023883a 	mov	r17,r2
 8209bd4:	820c2240 	call	820c224 <__multadd>
 8209bd8:	1029883a 	mov	r20,r2
 8209bdc:	b027883a 	mov	r19,r22
 8209be0:	003fc006 	br	8209ae4 <_dtoa_r+0xe30>
 8209be4:	9011883a 	mov	r8,r18
 8209be8:	00800e0e 	bge	zero,r2,8209c24 <_dtoa_r+0xf70>
 8209bec:	800b883a 	mov	r5,r16
 8209bf0:	01800044 	movi	r6,1
 8209bf4:	e009883a 	mov	r4,fp
 8209bf8:	da001715 	stw	r8,92(sp)
 8209bfc:	820c8d40 	call	820c8d4 <__lshift>
 8209c00:	a80b883a 	mov	r5,r21
 8209c04:	1009883a 	mov	r4,r2
 8209c08:	1021883a 	mov	r16,r2
 8209c0c:	820ca1c0 	call	820ca1c <__mcmp>
 8209c10:	da001717 	ldw	r8,92(sp)
 8209c14:	0081960e 	bge	zero,r2,820a270 <_dtoa_r+0x15bc>
 8209c18:	00800e44 	movi	r2,57
 8209c1c:	40817026 	beq	r8,r2,820a1e0 <_dtoa_r+0x152c>
 8209c20:	ba000c44 	addi	r8,r23,49
 8209c24:	8825883a 	mov	r18,r17
 8209c28:	9dc00044 	addi	r23,r19,1
 8209c2c:	9a000005 	stb	r8,0(r19)
 8209c30:	a023883a 	mov	r17,r20
 8209c34:	dc000915 	stw	r16,36(sp)
 8209c38:	003f2406 	br	82098cc <_dtoa_r+0xc18>
 8209c3c:	00800e44 	movi	r2,57
 8209c40:	9011883a 	mov	r8,r18
 8209c44:	90816626 	beq	r18,r2,820a1e0 <_dtoa_r+0x152c>
 8209c48:	05bff516 	blt	zero,r22,8209c20 <_dtoa_r+0xf6c>
 8209c4c:	003ff506 	br	8209c24 <_dtoa_r+0xf70>
 8209c50:	820c2240 	call	820c224 <__multadd>
 8209c54:	1023883a 	mov	r17,r2
 8209c58:	1029883a 	mov	r20,r2
 8209c5c:	003fdf06 	br	8209bdc <_dtoa_r+0xf28>
 8209c60:	e009883a 	mov	r4,fp
 8209c64:	820c1fc0 	call	820c1fc <_Bfree>
 8209c68:	00800044 	movi	r2,1
 8209c6c:	003fbc06 	br	8209b60 <_dtoa_r+0xeac>
 8209c70:	a80b883a 	mov	r5,r21
 8209c74:	8009883a 	mov	r4,r16
 8209c78:	820ca1c0 	call	820ca1c <__mcmp>
 8209c7c:	103edb0e 	bge	r2,zero,82097ec <_dtoa_r+0xb38>
 8209c80:	800b883a 	mov	r5,r16
 8209c84:	000f883a 	mov	r7,zero
 8209c88:	01800284 	movi	r6,10
 8209c8c:	e009883a 	mov	r4,fp
 8209c90:	820c2240 	call	820c224 <__multadd>
 8209c94:	1021883a 	mov	r16,r2
 8209c98:	d8800517 	ldw	r2,20(sp)
 8209c9c:	d8c00b17 	ldw	r3,44(sp)
 8209ca0:	10bfffc4 	addi	r2,r2,-1
 8209ca4:	d8800515 	stw	r2,20(sp)
 8209ca8:	183f761e 	bne	r3,zero,8209a84 <_dtoa_r+0xdd0>
 8209cac:	d9000c17 	ldw	r4,48(sp)
 8209cb0:	0101730e 	bge	zero,r4,820a280 <_dtoa_r+0x15cc>
 8209cb4:	d9000615 	stw	r4,24(sp)
 8209cb8:	003ed006 	br	82097fc <_dtoa_r+0xb48>
 8209cbc:	00800084 	movi	r2,2
 8209cc0:	3081861e 	bne	r6,r2,820a2dc <_dtoa_r+0x1628>
 8209cc4:	d8000b15 	stw	zero,44(sp)
 8209cc8:	003f3c06 	br	82099bc <_dtoa_r+0xd08>
 8209ccc:	dc000917 	ldw	r16,36(sp)
 8209cd0:	003e9206 	br	820971c <_dtoa_r+0xa68>
 8209cd4:	d9c00317 	ldw	r7,12(sp)
 8209cd8:	00800084 	movi	r2,2
 8209cdc:	11fec50e 	bge	r2,r7,82097f4 <_dtoa_r+0xb40>
 8209ce0:	d9000617 	ldw	r4,24(sp)
 8209ce4:	20013c1e 	bne	r4,zero,820a1d8 <_dtoa_r+0x1524>
 8209ce8:	a80b883a 	mov	r5,r21
 8209cec:	000f883a 	mov	r7,zero
 8209cf0:	01800144 	movi	r6,5
 8209cf4:	e009883a 	mov	r4,fp
 8209cf8:	820c2240 	call	820c224 <__multadd>
 8209cfc:	100b883a 	mov	r5,r2
 8209d00:	8009883a 	mov	r4,r16
 8209d04:	102b883a 	mov	r21,r2
 8209d08:	820ca1c0 	call	820ca1c <__mcmp>
 8209d0c:	dc000915 	stw	r16,36(sp)
 8209d10:	00bf410e 	bge	zero,r2,8209a18 <_dtoa_r+0xd64>
 8209d14:	d9c00717 	ldw	r7,28(sp)
 8209d18:	00800c44 	movi	r2,49
 8209d1c:	38800005 	stb	r2,0(r7)
 8209d20:	d8800517 	ldw	r2,20(sp)
 8209d24:	3dc00044 	addi	r23,r7,1
 8209d28:	10800044 	addi	r2,r2,1
 8209d2c:	d8800515 	stw	r2,20(sp)
 8209d30:	003f3d06 	br	8209a28 <_dtoa_r+0xd74>
 8209d34:	d9800517 	ldw	r6,20(sp)
 8209d38:	d9c00717 	ldw	r7,28(sp)
 8209d3c:	00800c44 	movi	r2,49
 8209d40:	31800044 	addi	r6,r6,1
 8209d44:	d9800515 	stw	r6,20(sp)
 8209d48:	38800005 	stb	r2,0(r7)
 8209d4c:	003edf06 	br	82098cc <_dtoa_r+0xc18>
 8209d50:	d8000b15 	stw	zero,44(sp)
 8209d54:	003c9f06 	br	8208fd4 <_dtoa_r+0x320>
 8209d58:	903e7e1e 	bne	r18,zero,8209754 <_dtoa_r+0xaa0>
 8209d5c:	00800434 	movhi	r2,16
 8209d60:	10bfffc4 	addi	r2,r2,-1
 8209d64:	9884703a 	and	r2,r19,r2
 8209d68:	1000ea1e 	bne	r2,zero,820a114 <_dtoa_r+0x1460>
 8209d6c:	9cdffc2c 	andhi	r19,r19,32752
 8209d70:	9800e826 	beq	r19,zero,820a114 <_dtoa_r+0x1460>
 8209d74:	d9c00817 	ldw	r7,32(sp)
 8209d78:	b5800044 	addi	r22,r22,1
 8209d7c:	04c00044 	movi	r19,1
 8209d80:	39c00044 	addi	r7,r7,1
 8209d84:	d9c00815 	stw	r7,32(sp)
 8209d88:	d8800d17 	ldw	r2,52(sp)
 8209d8c:	103e721e 	bne	r2,zero,8209758 <_dtoa_r+0xaa4>
 8209d90:	00800044 	movi	r2,1
 8209d94:	003e7906 	br	820977c <_dtoa_r+0xac8>
 8209d98:	8009883a 	mov	r4,r16
 8209d9c:	8213ce40 	call	8213ce4 <__floatsidf>
 8209da0:	d9800f17 	ldw	r6,60(sp)
 8209da4:	d9c01017 	ldw	r7,64(sp)
 8209da8:	1009883a 	mov	r4,r2
 8209dac:	180b883a 	mov	r5,r3
 8209db0:	8212c500 	call	8212c50 <__muldf3>
 8209db4:	000d883a 	mov	r6,zero
 8209db8:	01d00734 	movhi	r7,16412
 8209dbc:	1009883a 	mov	r4,r2
 8209dc0:	180b883a 	mov	r5,r3
 8209dc4:	82118640 	call	8211864 <__adddf3>
 8209dc8:	047f3034 	movhi	r17,64704
 8209dcc:	1021883a 	mov	r16,r2
 8209dd0:	1c63883a 	add	r17,r3,r17
 8209dd4:	d9000f17 	ldw	r4,60(sp)
 8209dd8:	d9401017 	ldw	r5,64(sp)
 8209ddc:	000d883a 	mov	r6,zero
 8209de0:	01d00534 	movhi	r7,16404
 8209de4:	82133680 	call	8213368 <__subdf3>
 8209de8:	800d883a 	mov	r6,r16
 8209dec:	880f883a 	mov	r7,r17
 8209df0:	1009883a 	mov	r4,r2
 8209df4:	180b883a 	mov	r5,r3
 8209df8:	102b883a 	mov	r21,r2
 8209dfc:	1829883a 	mov	r20,r3
 8209e00:	8212a800 	call	8212a80 <__gedf2>
 8209e04:	00806c16 	blt	zero,r2,8209fb8 <_dtoa_r+0x1304>
 8209e08:	89e0003c 	xorhi	r7,r17,32768
 8209e0c:	800d883a 	mov	r6,r16
 8209e10:	a809883a 	mov	r4,r21
 8209e14:	a00b883a 	mov	r5,r20
 8209e18:	8212b5c0 	call	8212b5c <__ledf2>
 8209e1c:	103d7e0e 	bge	r2,zero,8209418 <_dtoa_r+0x764>
 8209e20:	002b883a 	mov	r21,zero
 8209e24:	0023883a 	mov	r17,zero
 8209e28:	003efb06 	br	8209a18 <_dtoa_r+0xd64>
 8209e2c:	d8800717 	ldw	r2,28(sp)
 8209e30:	003bd006 	br	8208d74 <_dtoa_r+0xc0>
 8209e34:	d9000a17 	ldw	r4,40(sp)
 8209e38:	d9800d17 	ldw	r6,52(sp)
 8209e3c:	dd400a15 	stw	r21,40(sp)
 8209e40:	a905c83a 	sub	r2,r21,r4
 8209e44:	308d883a 	add	r6,r6,r2
 8209e48:	d9800d15 	stw	r6,52(sp)
 8209e4c:	002b883a 	mov	r21,zero
 8209e50:	003e0606 	br	820966c <_dtoa_r+0x9b8>
 8209e54:	9023883a 	mov	r17,r18
 8209e58:	9829883a 	mov	r20,r19
 8209e5c:	04000084 	movi	r16,2
 8209e60:	003c9206 	br	82090ac <_dtoa_r+0x3f8>
 8209e64:	04000044 	movi	r16,1
 8209e68:	dc000c15 	stw	r16,48(sp)
 8209e6c:	dc000615 	stw	r16,24(sp)
 8209e70:	dc002215 	stw	r16,136(sp)
 8209e74:	e0001115 	stw	zero,68(fp)
 8209e78:	000b883a 	mov	r5,zero
 8209e7c:	003c6906 	br	8209024 <_dtoa_r+0x370>
 8209e80:	3021883a 	mov	r16,r6
 8209e84:	003ffb06 	br	8209e74 <_dtoa_r+0x11c0>
 8209e88:	1000021e 	bne	r2,zero,8209e94 <_dtoa_r+0x11e0>
 8209e8c:	4200004c 	andi	r8,r8,1
 8209e90:	403e7d1e 	bne	r8,zero,8209888 <_dtoa_r+0xbd4>
 8209e94:	01000c04 	movi	r4,48
 8209e98:	00000106 	br	8209ea0 <_dtoa_r+0x11ec>
 8209e9c:	102f883a 	mov	r23,r2
 8209ea0:	b8bfffc4 	addi	r2,r23,-1
 8209ea4:	10c00007 	ldb	r3,0(r2)
 8209ea8:	193ffc26 	beq	r3,r4,8209e9c <_dtoa_r+0x11e8>
 8209eac:	003e8706 	br	82098cc <_dtoa_r+0xc18>
 8209eb0:	d8800517 	ldw	r2,20(sp)
 8209eb4:	00a3c83a 	sub	r17,zero,r2
 8209eb8:	8800a426 	beq	r17,zero,820a14c <_dtoa_r+0x1498>
 8209ebc:	888003cc 	andi	r2,r17,15
 8209ec0:	100490fa 	slli	r2,r2,3
 8209ec4:	00c20974 	movhi	r3,2085
 8209ec8:	18f59004 	addi	r3,r3,-10688
 8209ecc:	1885883a 	add	r2,r3,r2
 8209ed0:	11800017 	ldw	r6,0(r2)
 8209ed4:	11c00117 	ldw	r7,4(r2)
 8209ed8:	9009883a 	mov	r4,r18
 8209edc:	980b883a 	mov	r5,r19
 8209ee0:	8823d13a 	srai	r17,r17,4
 8209ee4:	8212c500 	call	8212c50 <__muldf3>
 8209ee8:	d8800f15 	stw	r2,60(sp)
 8209eec:	d8c01015 	stw	r3,64(sp)
 8209ef0:	8800e826 	beq	r17,zero,820a294 <_dtoa_r+0x15e0>
 8209ef4:	05020974 	movhi	r20,2085
 8209ef8:	a5358604 	addi	r20,r20,-10728
 8209efc:	04000084 	movi	r16,2
 8209f00:	8980004c 	andi	r6,r17,1
 8209f04:	1009883a 	mov	r4,r2
 8209f08:	8823d07a 	srai	r17,r17,1
 8209f0c:	180b883a 	mov	r5,r3
 8209f10:	30000426 	beq	r6,zero,8209f24 <_dtoa_r+0x1270>
 8209f14:	a1800017 	ldw	r6,0(r20)
 8209f18:	a1c00117 	ldw	r7,4(r20)
 8209f1c:	84000044 	addi	r16,r16,1
 8209f20:	8212c500 	call	8212c50 <__muldf3>
 8209f24:	a5000204 	addi	r20,r20,8
 8209f28:	883ff51e 	bne	r17,zero,8209f00 <_dtoa_r+0x124c>
 8209f2c:	d8800f15 	stw	r2,60(sp)
 8209f30:	d8c01015 	stw	r3,64(sp)
 8209f34:	003c7606 	br	8209110 <_dtoa_r+0x45c>
 8209f38:	00c00c04 	movi	r3,48
 8209f3c:	10c00005 	stb	r3,0(r2)
 8209f40:	d8c00517 	ldw	r3,20(sp)
 8209f44:	bd3fffc3 	ldbu	r20,-1(r23)
 8209f48:	18c00044 	addi	r3,r3,1
 8209f4c:	d8c00515 	stw	r3,20(sp)
 8209f50:	003db906 	br	8209638 <_dtoa_r+0x984>
 8209f54:	89400117 	ldw	r5,4(r17)
 8209f58:	e009883a 	mov	r4,fp
 8209f5c:	820c1540 	call	820c154 <_Balloc>
 8209f60:	89800417 	ldw	r6,16(r17)
 8209f64:	89400304 	addi	r5,r17,12
 8209f68:	11000304 	addi	r4,r2,12
 8209f6c:	31800084 	addi	r6,r6,2
 8209f70:	318d883a 	add	r6,r6,r6
 8209f74:	318d883a 	add	r6,r6,r6
 8209f78:	1027883a 	mov	r19,r2
 8209f7c:	8202a0c0 	call	8202a0c <memcpy>
 8209f80:	01800044 	movi	r6,1
 8209f84:	980b883a 	mov	r5,r19
 8209f88:	e009883a 	mov	r4,fp
 8209f8c:	820c8d40 	call	820c8d4 <__lshift>
 8209f90:	1029883a 	mov	r20,r2
 8209f94:	003ecc06 	br	8209ac8 <_dtoa_r+0xe14>
 8209f98:	00800e44 	movi	r2,57
 8209f9c:	90809026 	beq	r18,r2,820a1e0 <_dtoa_r+0x152c>
 8209fa0:	92000044 	addi	r8,r18,1
 8209fa4:	003f1f06 	br	8209c24 <_dtoa_r+0xf70>
 8209fa8:	9011883a 	mov	r8,r18
 8209fac:	8825883a 	mov	r18,r17
 8209fb0:	a023883a 	mov	r17,r20
 8209fb4:	003e2906 	br	820985c <_dtoa_r+0xba8>
 8209fb8:	002b883a 	mov	r21,zero
 8209fbc:	0023883a 	mov	r17,zero
 8209fc0:	003f5406 	br	8209d14 <_dtoa_r+0x1060>
 8209fc4:	61bfffc4 	addi	r6,r12,-1
 8209fc8:	300490fa 	slli	r2,r6,3
 8209fcc:	00c20974 	movhi	r3,2085
 8209fd0:	18f59004 	addi	r3,r3,-10688
 8209fd4:	1885883a 	add	r2,r3,r2
 8209fd8:	11000017 	ldw	r4,0(r2)
 8209fdc:	11400117 	ldw	r5,4(r2)
 8209fe0:	d8800717 	ldw	r2,28(sp)
 8209fe4:	880f883a 	mov	r7,r17
 8209fe8:	d9801215 	stw	r6,72(sp)
 8209fec:	800d883a 	mov	r6,r16
 8209ff0:	db001615 	stw	r12,88(sp)
 8209ff4:	15c00044 	addi	r23,r2,1
 8209ff8:	8212c500 	call	8212c50 <__muldf3>
 8209ffc:	d9401017 	ldw	r5,64(sp)
 820a000:	d9000f17 	ldw	r4,60(sp)
 820a004:	d8c01515 	stw	r3,84(sp)
 820a008:	d8801415 	stw	r2,80(sp)
 820a00c:	8213c640 	call	8213c64 <__fixdfsi>
 820a010:	1009883a 	mov	r4,r2
 820a014:	1021883a 	mov	r16,r2
 820a018:	8213ce40 	call	8213ce4 <__floatsidf>
 820a01c:	d9000f17 	ldw	r4,60(sp)
 820a020:	d9401017 	ldw	r5,64(sp)
 820a024:	100d883a 	mov	r6,r2
 820a028:	180f883a 	mov	r7,r3
 820a02c:	82133680 	call	8213368 <__subdf3>
 820a030:	1829883a 	mov	r20,r3
 820a034:	d8c00717 	ldw	r3,28(sp)
 820a038:	84000c04 	addi	r16,r16,48
 820a03c:	1023883a 	mov	r17,r2
 820a040:	1c000005 	stb	r16,0(r3)
 820a044:	db001617 	ldw	r12,88(sp)
 820a048:	00800044 	movi	r2,1
 820a04c:	60802226 	beq	r12,r2,820a0d8 <_dtoa_r+0x1424>
 820a050:	d9c00717 	ldw	r7,28(sp)
 820a054:	8805883a 	mov	r2,r17
 820a058:	b82b883a 	mov	r21,r23
 820a05c:	3b19883a 	add	r12,r7,r12
 820a060:	6023883a 	mov	r17,r12
 820a064:	a007883a 	mov	r3,r20
 820a068:	dc800f15 	stw	r18,60(sp)
 820a06c:	000d883a 	mov	r6,zero
 820a070:	01d00934 	movhi	r7,16420
 820a074:	1009883a 	mov	r4,r2
 820a078:	180b883a 	mov	r5,r3
 820a07c:	8212c500 	call	8212c50 <__muldf3>
 820a080:	180b883a 	mov	r5,r3
 820a084:	1009883a 	mov	r4,r2
 820a088:	1829883a 	mov	r20,r3
 820a08c:	1025883a 	mov	r18,r2
 820a090:	8213c640 	call	8213c64 <__fixdfsi>
 820a094:	1009883a 	mov	r4,r2
 820a098:	1021883a 	mov	r16,r2
 820a09c:	8213ce40 	call	8213ce4 <__floatsidf>
 820a0a0:	100d883a 	mov	r6,r2
 820a0a4:	180f883a 	mov	r7,r3
 820a0a8:	9009883a 	mov	r4,r18
 820a0ac:	a00b883a 	mov	r5,r20
 820a0b0:	84000c04 	addi	r16,r16,48
 820a0b4:	82133680 	call	8213368 <__subdf3>
 820a0b8:	ad400044 	addi	r21,r21,1
 820a0bc:	ac3fffc5 	stb	r16,-1(r21)
 820a0c0:	ac7fea1e 	bne	r21,r17,820a06c <_dtoa_r+0x13b8>
 820a0c4:	1023883a 	mov	r17,r2
 820a0c8:	d8801217 	ldw	r2,72(sp)
 820a0cc:	dc800f17 	ldw	r18,60(sp)
 820a0d0:	1829883a 	mov	r20,r3
 820a0d4:	b8af883a 	add	r23,r23,r2
 820a0d8:	d9001417 	ldw	r4,80(sp)
 820a0dc:	d9401517 	ldw	r5,84(sp)
 820a0e0:	000d883a 	mov	r6,zero
 820a0e4:	01cff834 	movhi	r7,16352
 820a0e8:	82118640 	call	8211864 <__adddf3>
 820a0ec:	880d883a 	mov	r6,r17
 820a0f0:	a00f883a 	mov	r7,r20
 820a0f4:	1009883a 	mov	r4,r2
 820a0f8:	180b883a 	mov	r5,r3
 820a0fc:	8212b5c0 	call	8212b5c <__ledf2>
 820a100:	10003e0e 	bge	r2,zero,820a1fc <_dtoa_r+0x1548>
 820a104:	d9001317 	ldw	r4,76(sp)
 820a108:	bd3fffc3 	ldbu	r20,-1(r23)
 820a10c:	d9000515 	stw	r4,20(sp)
 820a110:	003d3b06 	br	8209600 <_dtoa_r+0x94c>
 820a114:	0027883a 	mov	r19,zero
 820a118:	003f1b06 	br	8209d88 <_dtoa_r+0x10d4>
 820a11c:	d8800817 	ldw	r2,32(sp)
 820a120:	11e9c83a 	sub	r20,r2,r7
 820a124:	0005883a 	mov	r2,zero
 820a128:	003d5406 	br	820967c <_dtoa_r+0x9c8>
 820a12c:	00800044 	movi	r2,1
 820a130:	003dc706 	br	8209850 <_dtoa_r+0xb9c>
 820a134:	d8c00217 	ldw	r3,8(sp)
 820a138:	00800d84 	movi	r2,54
 820a13c:	dd400a17 	ldw	r21,40(sp)
 820a140:	10c5c83a 	sub	r2,r2,r3
 820a144:	dd000817 	ldw	r20,32(sp)
 820a148:	003d4c06 	br	820967c <_dtoa_r+0x9c8>
 820a14c:	dc800f15 	stw	r18,60(sp)
 820a150:	dcc01015 	stw	r19,64(sp)
 820a154:	04000084 	movi	r16,2
 820a158:	003bed06 	br	8209110 <_dtoa_r+0x45c>
 820a15c:	d9000617 	ldw	r4,24(sp)
 820a160:	203f0d26 	beq	r4,zero,8209d98 <_dtoa_r+0x10e4>
 820a164:	d9800c17 	ldw	r6,48(sp)
 820a168:	01bcab0e 	bge	zero,r6,8209418 <_dtoa_r+0x764>
 820a16c:	d9401017 	ldw	r5,64(sp)
 820a170:	d9000f17 	ldw	r4,60(sp)
 820a174:	000d883a 	mov	r6,zero
 820a178:	01d00934 	movhi	r7,16420
 820a17c:	8212c500 	call	8212c50 <__muldf3>
 820a180:	81000044 	addi	r4,r16,1
 820a184:	d8800f15 	stw	r2,60(sp)
 820a188:	d8c01015 	stw	r3,64(sp)
 820a18c:	8213ce40 	call	8213ce4 <__floatsidf>
 820a190:	d9800f17 	ldw	r6,60(sp)
 820a194:	d9c01017 	ldw	r7,64(sp)
 820a198:	1009883a 	mov	r4,r2
 820a19c:	180b883a 	mov	r5,r3
 820a1a0:	8212c500 	call	8212c50 <__muldf3>
 820a1a4:	01d00734 	movhi	r7,16412
 820a1a8:	000d883a 	mov	r6,zero
 820a1ac:	1009883a 	mov	r4,r2
 820a1b0:	180b883a 	mov	r5,r3
 820a1b4:	82118640 	call	8211864 <__adddf3>
 820a1b8:	d9c00517 	ldw	r7,20(sp)
 820a1bc:	047f3034 	movhi	r17,64704
 820a1c0:	1021883a 	mov	r16,r2
 820a1c4:	39ffffc4 	addi	r7,r7,-1
 820a1c8:	d9c01315 	stw	r7,76(sp)
 820a1cc:	1c63883a 	add	r17,r3,r17
 820a1d0:	db000c17 	ldw	r12,48(sp)
 820a1d4:	003bea06 	br	8209180 <_dtoa_r+0x4cc>
 820a1d8:	dc000915 	stw	r16,36(sp)
 820a1dc:	003e0e06 	br	8209a18 <_dtoa_r+0xd64>
 820a1e0:	01000e44 	movi	r4,57
 820a1e4:	8825883a 	mov	r18,r17
 820a1e8:	9dc00044 	addi	r23,r19,1
 820a1ec:	99000005 	stb	r4,0(r19)
 820a1f0:	a023883a 	mov	r17,r20
 820a1f4:	dc000915 	stw	r16,36(sp)
 820a1f8:	003da406 	br	820988c <_dtoa_r+0xbd8>
 820a1fc:	d9801417 	ldw	r6,80(sp)
 820a200:	d9c01517 	ldw	r7,84(sp)
 820a204:	0009883a 	mov	r4,zero
 820a208:	014ff834 	movhi	r5,16352
 820a20c:	82133680 	call	8213368 <__subdf3>
 820a210:	880d883a 	mov	r6,r17
 820a214:	a00f883a 	mov	r7,r20
 820a218:	1009883a 	mov	r4,r2
 820a21c:	180b883a 	mov	r5,r3
 820a220:	8212a800 	call	8212a80 <__gedf2>
 820a224:	00bc7c0e 	bge	zero,r2,8209418 <_dtoa_r+0x764>
 820a228:	01000c04 	movi	r4,48
 820a22c:	00000106 	br	820a234 <_dtoa_r+0x1580>
 820a230:	102f883a 	mov	r23,r2
 820a234:	b8bfffc4 	addi	r2,r23,-1
 820a238:	10c00007 	ldb	r3,0(r2)
 820a23c:	193ffc26 	beq	r3,r4,820a230 <_dtoa_r+0x157c>
 820a240:	d9801317 	ldw	r6,76(sp)
 820a244:	d9800515 	stw	r6,20(sp)
 820a248:	003c4406 	br	820935c <_dtoa_r+0x6a8>
 820a24c:	d9801317 	ldw	r6,76(sp)
 820a250:	d9800515 	stw	r6,20(sp)
 820a254:	003cea06 	br	8209600 <_dtoa_r+0x94c>
 820a258:	dd800f17 	ldw	r22,60(sp)
 820a25c:	dcc01017 	ldw	r19,64(sp)
 820a260:	dc801217 	ldw	r18,72(sp)
 820a264:	003c6c06 	br	8209418 <_dtoa_r+0x764>
 820a268:	903e031e 	bne	r18,zero,8209a78 <_dtoa_r+0xdc4>
 820a26c:	003ebb06 	br	8209d5c <_dtoa_r+0x10a8>
 820a270:	103e6c1e 	bne	r2,zero,8209c24 <_dtoa_r+0xf70>
 820a274:	4080004c 	andi	r2,r8,1
 820a278:	103e6a26 	beq	r2,zero,8209c24 <_dtoa_r+0xf70>
 820a27c:	003e6606 	br	8209c18 <_dtoa_r+0xf64>
 820a280:	d8c00317 	ldw	r3,12(sp)
 820a284:	00800084 	movi	r2,2
 820a288:	10c02916 	blt	r2,r3,820a330 <_dtoa_r+0x167c>
 820a28c:	d9000c17 	ldw	r4,48(sp)
 820a290:	003e8806 	br	8209cb4 <_dtoa_r+0x1000>
 820a294:	04000084 	movi	r16,2
 820a298:	003b9d06 	br	8209110 <_dtoa_r+0x45c>
 820a29c:	d9001317 	ldw	r4,76(sp)
 820a2a0:	d9000515 	stw	r4,20(sp)
 820a2a4:	003cd606 	br	8209600 <_dtoa_r+0x94c>
 820a2a8:	d8801317 	ldw	r2,76(sp)
 820a2ac:	d8800515 	stw	r2,20(sp)
 820a2b0:	003c2a06 	br	820935c <_dtoa_r+0x6a8>
 820a2b4:	d9800317 	ldw	r6,12(sp)
 820a2b8:	00800084 	movi	r2,2
 820a2bc:	11801516 	blt	r2,r6,820a314 <_dtoa_r+0x1660>
 820a2c0:	d9c00c17 	ldw	r7,48(sp)
 820a2c4:	d9c00615 	stw	r7,24(sp)
 820a2c8:	003df706 	br	8209aa8 <_dtoa_r+0xdf4>
 820a2cc:	193d3926 	beq	r3,r4,82097b4 <_dtoa_r+0xb00>
 820a2d0:	00c00f04 	movi	r3,60
 820a2d4:	1885c83a 	sub	r2,r3,r2
 820a2d8:	003ddf06 	br	8209a58 <_dtoa_r+0xda4>
 820a2dc:	e009883a 	mov	r4,fp
 820a2e0:	e0001115 	stw	zero,68(fp)
 820a2e4:	000b883a 	mov	r5,zero
 820a2e8:	820c1540 	call	820c154 <_Balloc>
 820a2ec:	d8800715 	stw	r2,28(sp)
 820a2f0:	d8c00717 	ldw	r3,28(sp)
 820a2f4:	00bfffc4 	movi	r2,-1
 820a2f8:	01000044 	movi	r4,1
 820a2fc:	d8800c15 	stw	r2,48(sp)
 820a300:	e0c01015 	stw	r3,64(fp)
 820a304:	d9000b15 	stw	r4,44(sp)
 820a308:	d8800615 	stw	r2,24(sp)
 820a30c:	d8002215 	stw	zero,136(sp)
 820a310:	003c4106 	br	8209418 <_dtoa_r+0x764>
 820a314:	d8c00c17 	ldw	r3,48(sp)
 820a318:	d8c00615 	stw	r3,24(sp)
 820a31c:	003e7006 	br	8209ce0 <_dtoa_r+0x102c>
 820a320:	04400044 	movi	r17,1
 820a324:	003b2006 	br	8208fa8 <_dtoa_r+0x2f4>
 820a328:	000b883a 	mov	r5,zero
 820a32c:	003b3d06 	br	8209024 <_dtoa_r+0x370>
 820a330:	d8800c17 	ldw	r2,48(sp)
 820a334:	d8800615 	stw	r2,24(sp)
 820a338:	003e6906 	br	8209ce0 <_dtoa_r+0x102c>

0820a33c <__sflush_r>:
 820a33c:	2880030b 	ldhu	r2,12(r5)
 820a340:	defffb04 	addi	sp,sp,-20
 820a344:	dcc00315 	stw	r19,12(sp)
 820a348:	dc400115 	stw	r17,4(sp)
 820a34c:	dfc00415 	stw	ra,16(sp)
 820a350:	dc800215 	stw	r18,8(sp)
 820a354:	dc000015 	stw	r16,0(sp)
 820a358:	10c0020c 	andi	r3,r2,8
 820a35c:	2823883a 	mov	r17,r5
 820a360:	2027883a 	mov	r19,r4
 820a364:	1800311e 	bne	r3,zero,820a42c <__sflush_r+0xf0>
 820a368:	28c00117 	ldw	r3,4(r5)
 820a36c:	10820014 	ori	r2,r2,2048
 820a370:	2880030d 	sth	r2,12(r5)
 820a374:	00c04b0e 	bge	zero,r3,820a4a4 <__sflush_r+0x168>
 820a378:	8a000a17 	ldw	r8,40(r17)
 820a37c:	40002326 	beq	r8,zero,820a40c <__sflush_r+0xd0>
 820a380:	9c000017 	ldw	r16,0(r19)
 820a384:	10c4000c 	andi	r3,r2,4096
 820a388:	98000015 	stw	zero,0(r19)
 820a38c:	18004826 	beq	r3,zero,820a4b0 <__sflush_r+0x174>
 820a390:	89801417 	ldw	r6,80(r17)
 820a394:	10c0010c 	andi	r3,r2,4
 820a398:	18000626 	beq	r3,zero,820a3b4 <__sflush_r+0x78>
 820a39c:	88c00117 	ldw	r3,4(r17)
 820a3a0:	88800c17 	ldw	r2,48(r17)
 820a3a4:	30cdc83a 	sub	r6,r6,r3
 820a3a8:	10000226 	beq	r2,zero,820a3b4 <__sflush_r+0x78>
 820a3ac:	88800f17 	ldw	r2,60(r17)
 820a3b0:	308dc83a 	sub	r6,r6,r2
 820a3b4:	89400717 	ldw	r5,28(r17)
 820a3b8:	000f883a 	mov	r7,zero
 820a3bc:	9809883a 	mov	r4,r19
 820a3c0:	403ee83a 	callr	r8
 820a3c4:	00ffffc4 	movi	r3,-1
 820a3c8:	10c04426 	beq	r2,r3,820a4dc <__sflush_r+0x1a0>
 820a3cc:	88c0030b 	ldhu	r3,12(r17)
 820a3d0:	89000417 	ldw	r4,16(r17)
 820a3d4:	88000115 	stw	zero,4(r17)
 820a3d8:	197dffcc 	andi	r5,r3,63487
 820a3dc:	8940030d 	sth	r5,12(r17)
 820a3e0:	89000015 	stw	r4,0(r17)
 820a3e4:	18c4000c 	andi	r3,r3,4096
 820a3e8:	18002c1e 	bne	r3,zero,820a49c <__sflush_r+0x160>
 820a3ec:	89400c17 	ldw	r5,48(r17)
 820a3f0:	9c000015 	stw	r16,0(r19)
 820a3f4:	28000526 	beq	r5,zero,820a40c <__sflush_r+0xd0>
 820a3f8:	88801004 	addi	r2,r17,64
 820a3fc:	28800226 	beq	r5,r2,820a408 <__sflush_r+0xcc>
 820a400:	9809883a 	mov	r4,r19
 820a404:	820abfc0 	call	820abfc <_free_r>
 820a408:	88000c15 	stw	zero,48(r17)
 820a40c:	0005883a 	mov	r2,zero
 820a410:	dfc00417 	ldw	ra,16(sp)
 820a414:	dcc00317 	ldw	r19,12(sp)
 820a418:	dc800217 	ldw	r18,8(sp)
 820a41c:	dc400117 	ldw	r17,4(sp)
 820a420:	dc000017 	ldw	r16,0(sp)
 820a424:	dec00504 	addi	sp,sp,20
 820a428:	f800283a 	ret
 820a42c:	2c800417 	ldw	r18,16(r5)
 820a430:	903ff626 	beq	r18,zero,820a40c <__sflush_r+0xd0>
 820a434:	2c000017 	ldw	r16,0(r5)
 820a438:	108000cc 	andi	r2,r2,3
 820a43c:	2c800015 	stw	r18,0(r5)
 820a440:	84a1c83a 	sub	r16,r16,r18
 820a444:	1000131e 	bne	r2,zero,820a494 <__sflush_r+0x158>
 820a448:	28800517 	ldw	r2,20(r5)
 820a44c:	88800215 	stw	r2,8(r17)
 820a450:	04000316 	blt	zero,r16,820a460 <__sflush_r+0x124>
 820a454:	003fed06 	br	820a40c <__sflush_r+0xd0>
 820a458:	90a5883a 	add	r18,r18,r2
 820a45c:	043feb0e 	bge	zero,r16,820a40c <__sflush_r+0xd0>
 820a460:	88800917 	ldw	r2,36(r17)
 820a464:	89400717 	ldw	r5,28(r17)
 820a468:	800f883a 	mov	r7,r16
 820a46c:	900d883a 	mov	r6,r18
 820a470:	9809883a 	mov	r4,r19
 820a474:	103ee83a 	callr	r2
 820a478:	80a1c83a 	sub	r16,r16,r2
 820a47c:	00bff616 	blt	zero,r2,820a458 <__sflush_r+0x11c>
 820a480:	88c0030b 	ldhu	r3,12(r17)
 820a484:	00bfffc4 	movi	r2,-1
 820a488:	18c01014 	ori	r3,r3,64
 820a48c:	88c0030d 	sth	r3,12(r17)
 820a490:	003fdf06 	br	820a410 <__sflush_r+0xd4>
 820a494:	0005883a 	mov	r2,zero
 820a498:	003fec06 	br	820a44c <__sflush_r+0x110>
 820a49c:	88801415 	stw	r2,80(r17)
 820a4a0:	003fd206 	br	820a3ec <__sflush_r+0xb0>
 820a4a4:	28c00f17 	ldw	r3,60(r5)
 820a4a8:	00ffb316 	blt	zero,r3,820a378 <__sflush_r+0x3c>
 820a4ac:	003fd706 	br	820a40c <__sflush_r+0xd0>
 820a4b0:	89400717 	ldw	r5,28(r17)
 820a4b4:	000d883a 	mov	r6,zero
 820a4b8:	01c00044 	movi	r7,1
 820a4bc:	9809883a 	mov	r4,r19
 820a4c0:	403ee83a 	callr	r8
 820a4c4:	100d883a 	mov	r6,r2
 820a4c8:	00bfffc4 	movi	r2,-1
 820a4cc:	30801426 	beq	r6,r2,820a520 <__sflush_r+0x1e4>
 820a4d0:	8880030b 	ldhu	r2,12(r17)
 820a4d4:	8a000a17 	ldw	r8,40(r17)
 820a4d8:	003fae06 	br	820a394 <__sflush_r+0x58>
 820a4dc:	98c00017 	ldw	r3,0(r19)
 820a4e0:	183fba26 	beq	r3,zero,820a3cc <__sflush_r+0x90>
 820a4e4:	01000744 	movi	r4,29
 820a4e8:	19000626 	beq	r3,r4,820a504 <__sflush_r+0x1c8>
 820a4ec:	01000584 	movi	r4,22
 820a4f0:	19000426 	beq	r3,r4,820a504 <__sflush_r+0x1c8>
 820a4f4:	88c0030b 	ldhu	r3,12(r17)
 820a4f8:	18c01014 	ori	r3,r3,64
 820a4fc:	88c0030d 	sth	r3,12(r17)
 820a500:	003fc306 	br	820a410 <__sflush_r+0xd4>
 820a504:	8880030b 	ldhu	r2,12(r17)
 820a508:	88c00417 	ldw	r3,16(r17)
 820a50c:	88000115 	stw	zero,4(r17)
 820a510:	10bdffcc 	andi	r2,r2,63487
 820a514:	8880030d 	sth	r2,12(r17)
 820a518:	88c00015 	stw	r3,0(r17)
 820a51c:	003fb306 	br	820a3ec <__sflush_r+0xb0>
 820a520:	98800017 	ldw	r2,0(r19)
 820a524:	103fea26 	beq	r2,zero,820a4d0 <__sflush_r+0x194>
 820a528:	00c00744 	movi	r3,29
 820a52c:	10c00226 	beq	r2,r3,820a538 <__sflush_r+0x1fc>
 820a530:	00c00584 	movi	r3,22
 820a534:	10c0031e 	bne	r2,r3,820a544 <__sflush_r+0x208>
 820a538:	9c000015 	stw	r16,0(r19)
 820a53c:	0005883a 	mov	r2,zero
 820a540:	003fb306 	br	820a410 <__sflush_r+0xd4>
 820a544:	88c0030b 	ldhu	r3,12(r17)
 820a548:	3005883a 	mov	r2,r6
 820a54c:	18c01014 	ori	r3,r3,64
 820a550:	88c0030d 	sth	r3,12(r17)
 820a554:	003fae06 	br	820a410 <__sflush_r+0xd4>

0820a558 <_fflush_r>:
 820a558:	defffd04 	addi	sp,sp,-12
 820a55c:	dc000115 	stw	r16,4(sp)
 820a560:	dfc00215 	stw	ra,8(sp)
 820a564:	2021883a 	mov	r16,r4
 820a568:	20000226 	beq	r4,zero,820a574 <_fflush_r+0x1c>
 820a56c:	20800e17 	ldw	r2,56(r4)
 820a570:	10000c26 	beq	r2,zero,820a5a4 <_fflush_r+0x4c>
 820a574:	2880030f 	ldh	r2,12(r5)
 820a578:	1000051e 	bne	r2,zero,820a590 <_fflush_r+0x38>
 820a57c:	0005883a 	mov	r2,zero
 820a580:	dfc00217 	ldw	ra,8(sp)
 820a584:	dc000117 	ldw	r16,4(sp)
 820a588:	dec00304 	addi	sp,sp,12
 820a58c:	f800283a 	ret
 820a590:	8009883a 	mov	r4,r16
 820a594:	dfc00217 	ldw	ra,8(sp)
 820a598:	dc000117 	ldw	r16,4(sp)
 820a59c:	dec00304 	addi	sp,sp,12
 820a5a0:	820a33c1 	jmpi	820a33c <__sflush_r>
 820a5a4:	d9400015 	stw	r5,0(sp)
 820a5a8:	820a9340 	call	820a934 <__sinit>
 820a5ac:	d9400017 	ldw	r5,0(sp)
 820a5b0:	003ff006 	br	820a574 <_fflush_r+0x1c>

0820a5b4 <fflush>:
 820a5b4:	20000526 	beq	r4,zero,820a5cc <fflush+0x18>
 820a5b8:	00820974 	movhi	r2,2085
 820a5bc:	108e3004 	addi	r2,r2,14528
 820a5c0:	200b883a 	mov	r5,r4
 820a5c4:	11000017 	ldw	r4,0(r2)
 820a5c8:	820a5581 	jmpi	820a558 <_fflush_r>
 820a5cc:	00820974 	movhi	r2,2085
 820a5d0:	108e2f04 	addi	r2,r2,14524
 820a5d4:	11000017 	ldw	r4,0(r2)
 820a5d8:	01420874 	movhi	r5,2081
 820a5dc:	29695604 	addi	r5,r5,-23208
 820a5e0:	820b48c1 	jmpi	820b48c <_fwalk_reent>

0820a5e4 <__fp_unlock>:
 820a5e4:	0005883a 	mov	r2,zero
 820a5e8:	f800283a 	ret

0820a5ec <_cleanup_r>:
 820a5ec:	01420874 	movhi	r5,2081
 820a5f0:	2941d404 	addi	r5,r5,1872
 820a5f4:	820b48c1 	jmpi	820b48c <_fwalk_reent>

0820a5f8 <__sinit.part.1>:
 820a5f8:	defff704 	addi	sp,sp,-36
 820a5fc:	00c20874 	movhi	r3,2081
 820a600:	dfc00815 	stw	ra,32(sp)
 820a604:	ddc00715 	stw	r23,28(sp)
 820a608:	dd800615 	stw	r22,24(sp)
 820a60c:	dd400515 	stw	r21,20(sp)
 820a610:	dd000415 	stw	r20,16(sp)
 820a614:	dcc00315 	stw	r19,12(sp)
 820a618:	dc800215 	stw	r18,8(sp)
 820a61c:	dc400115 	stw	r17,4(sp)
 820a620:	dc000015 	stw	r16,0(sp)
 820a624:	18e97b04 	addi	r3,r3,-23060
 820a628:	24000117 	ldw	r16,4(r4)
 820a62c:	20c00f15 	stw	r3,60(r4)
 820a630:	2080bb04 	addi	r2,r4,748
 820a634:	00c000c4 	movi	r3,3
 820a638:	20c0b915 	stw	r3,740(r4)
 820a63c:	2080ba15 	stw	r2,744(r4)
 820a640:	2000b815 	stw	zero,736(r4)
 820a644:	05c00204 	movi	r23,8
 820a648:	00800104 	movi	r2,4
 820a64c:	2025883a 	mov	r18,r4
 820a650:	b80d883a 	mov	r6,r23
 820a654:	81001704 	addi	r4,r16,92
 820a658:	000b883a 	mov	r5,zero
 820a65c:	80000015 	stw	zero,0(r16)
 820a660:	80000115 	stw	zero,4(r16)
 820a664:	80000215 	stw	zero,8(r16)
 820a668:	8080030d 	sth	r2,12(r16)
 820a66c:	80001915 	stw	zero,100(r16)
 820a670:	8000038d 	sth	zero,14(r16)
 820a674:	80000415 	stw	zero,16(r16)
 820a678:	80000515 	stw	zero,20(r16)
 820a67c:	80000615 	stw	zero,24(r16)
 820a680:	8202cb00 	call	8202cb0 <memset>
 820a684:	05820874 	movhi	r22,2081
 820a688:	94400217 	ldw	r17,8(r18)
 820a68c:	05420874 	movhi	r21,2081
 820a690:	05020874 	movhi	r20,2081
 820a694:	04c20874 	movhi	r19,2081
 820a698:	b5b65b04 	addi	r22,r22,-9876
 820a69c:	ad767204 	addi	r21,r21,-9784
 820a6a0:	a5369104 	addi	r20,r20,-9660
 820a6a4:	9cf6a804 	addi	r19,r19,-9568
 820a6a8:	85800815 	stw	r22,32(r16)
 820a6ac:	85400915 	stw	r21,36(r16)
 820a6b0:	85000a15 	stw	r20,40(r16)
 820a6b4:	84c00b15 	stw	r19,44(r16)
 820a6b8:	84000715 	stw	r16,28(r16)
 820a6bc:	00800284 	movi	r2,10
 820a6c0:	8880030d 	sth	r2,12(r17)
 820a6c4:	00800044 	movi	r2,1
 820a6c8:	b80d883a 	mov	r6,r23
 820a6cc:	89001704 	addi	r4,r17,92
 820a6d0:	000b883a 	mov	r5,zero
 820a6d4:	88000015 	stw	zero,0(r17)
 820a6d8:	88000115 	stw	zero,4(r17)
 820a6dc:	88000215 	stw	zero,8(r17)
 820a6e0:	88001915 	stw	zero,100(r17)
 820a6e4:	8880038d 	sth	r2,14(r17)
 820a6e8:	88000415 	stw	zero,16(r17)
 820a6ec:	88000515 	stw	zero,20(r17)
 820a6f0:	88000615 	stw	zero,24(r17)
 820a6f4:	8202cb00 	call	8202cb0 <memset>
 820a6f8:	94000317 	ldw	r16,12(r18)
 820a6fc:	00800484 	movi	r2,18
 820a700:	8c400715 	stw	r17,28(r17)
 820a704:	8d800815 	stw	r22,32(r17)
 820a708:	8d400915 	stw	r21,36(r17)
 820a70c:	8d000a15 	stw	r20,40(r17)
 820a710:	8cc00b15 	stw	r19,44(r17)
 820a714:	8080030d 	sth	r2,12(r16)
 820a718:	00800084 	movi	r2,2
 820a71c:	80000015 	stw	zero,0(r16)
 820a720:	80000115 	stw	zero,4(r16)
 820a724:	80000215 	stw	zero,8(r16)
 820a728:	80001915 	stw	zero,100(r16)
 820a72c:	8080038d 	sth	r2,14(r16)
 820a730:	80000415 	stw	zero,16(r16)
 820a734:	80000515 	stw	zero,20(r16)
 820a738:	80000615 	stw	zero,24(r16)
 820a73c:	b80d883a 	mov	r6,r23
 820a740:	000b883a 	mov	r5,zero
 820a744:	81001704 	addi	r4,r16,92
 820a748:	8202cb00 	call	8202cb0 <memset>
 820a74c:	00800044 	movi	r2,1
 820a750:	84000715 	stw	r16,28(r16)
 820a754:	85800815 	stw	r22,32(r16)
 820a758:	85400915 	stw	r21,36(r16)
 820a75c:	85000a15 	stw	r20,40(r16)
 820a760:	84c00b15 	stw	r19,44(r16)
 820a764:	90800e15 	stw	r2,56(r18)
 820a768:	dfc00817 	ldw	ra,32(sp)
 820a76c:	ddc00717 	ldw	r23,28(sp)
 820a770:	dd800617 	ldw	r22,24(sp)
 820a774:	dd400517 	ldw	r21,20(sp)
 820a778:	dd000417 	ldw	r20,16(sp)
 820a77c:	dcc00317 	ldw	r19,12(sp)
 820a780:	dc800217 	ldw	r18,8(sp)
 820a784:	dc400117 	ldw	r17,4(sp)
 820a788:	dc000017 	ldw	r16,0(sp)
 820a78c:	dec00904 	addi	sp,sp,36
 820a790:	f800283a 	ret

0820a794 <__fp_lock>:
 820a794:	0005883a 	mov	r2,zero
 820a798:	f800283a 	ret

0820a79c <__sfmoreglue>:
 820a79c:	defffc04 	addi	sp,sp,-16
 820a7a0:	dc400115 	stw	r17,4(sp)
 820a7a4:	2c7fffc4 	addi	r17,r5,-1
 820a7a8:	8c401a24 	muli	r17,r17,104
 820a7ac:	dc800215 	stw	r18,8(sp)
 820a7b0:	2825883a 	mov	r18,r5
 820a7b4:	89401d04 	addi	r5,r17,116
 820a7b8:	dc000015 	stw	r16,0(sp)
 820a7bc:	dfc00315 	stw	ra,12(sp)
 820a7c0:	820b7e80 	call	820b7e8 <_malloc_r>
 820a7c4:	1021883a 	mov	r16,r2
 820a7c8:	10000726 	beq	r2,zero,820a7e8 <__sfmoreglue+0x4c>
 820a7cc:	11000304 	addi	r4,r2,12
 820a7d0:	10000015 	stw	zero,0(r2)
 820a7d4:	14800115 	stw	r18,4(r2)
 820a7d8:	11000215 	stw	r4,8(r2)
 820a7dc:	89801a04 	addi	r6,r17,104
 820a7e0:	000b883a 	mov	r5,zero
 820a7e4:	8202cb00 	call	8202cb0 <memset>
 820a7e8:	8005883a 	mov	r2,r16
 820a7ec:	dfc00317 	ldw	ra,12(sp)
 820a7f0:	dc800217 	ldw	r18,8(sp)
 820a7f4:	dc400117 	ldw	r17,4(sp)
 820a7f8:	dc000017 	ldw	r16,0(sp)
 820a7fc:	dec00404 	addi	sp,sp,16
 820a800:	f800283a 	ret

0820a804 <__sfp>:
 820a804:	defffb04 	addi	sp,sp,-20
 820a808:	dc000015 	stw	r16,0(sp)
 820a80c:	04020974 	movhi	r16,2085
 820a810:	840e2f04 	addi	r16,r16,14524
 820a814:	dcc00315 	stw	r19,12(sp)
 820a818:	2027883a 	mov	r19,r4
 820a81c:	81000017 	ldw	r4,0(r16)
 820a820:	dfc00415 	stw	ra,16(sp)
 820a824:	dc800215 	stw	r18,8(sp)
 820a828:	20800e17 	ldw	r2,56(r4)
 820a82c:	dc400115 	stw	r17,4(sp)
 820a830:	1000021e 	bne	r2,zero,820a83c <__sfp+0x38>
 820a834:	820a5f80 	call	820a5f8 <__sinit.part.1>
 820a838:	81000017 	ldw	r4,0(r16)
 820a83c:	2480b804 	addi	r18,r4,736
 820a840:	047fffc4 	movi	r17,-1
 820a844:	91000117 	ldw	r4,4(r18)
 820a848:	94000217 	ldw	r16,8(r18)
 820a84c:	213fffc4 	addi	r4,r4,-1
 820a850:	20000a16 	blt	r4,zero,820a87c <__sfp+0x78>
 820a854:	8080030f 	ldh	r2,12(r16)
 820a858:	10000c26 	beq	r2,zero,820a88c <__sfp+0x88>
 820a85c:	80c01d04 	addi	r3,r16,116
 820a860:	00000206 	br	820a86c <__sfp+0x68>
 820a864:	18bfe60f 	ldh	r2,-104(r3)
 820a868:	10000826 	beq	r2,zero,820a88c <__sfp+0x88>
 820a86c:	213fffc4 	addi	r4,r4,-1
 820a870:	1c3ffd04 	addi	r16,r3,-12
 820a874:	18c01a04 	addi	r3,r3,104
 820a878:	247ffa1e 	bne	r4,r17,820a864 <__sfp+0x60>
 820a87c:	90800017 	ldw	r2,0(r18)
 820a880:	10001d26 	beq	r2,zero,820a8f8 <__sfp+0xf4>
 820a884:	1025883a 	mov	r18,r2
 820a888:	003fee06 	br	820a844 <__sfp+0x40>
 820a88c:	00bfffc4 	movi	r2,-1
 820a890:	8080038d 	sth	r2,14(r16)
 820a894:	00800044 	movi	r2,1
 820a898:	8080030d 	sth	r2,12(r16)
 820a89c:	80001915 	stw	zero,100(r16)
 820a8a0:	80000015 	stw	zero,0(r16)
 820a8a4:	80000215 	stw	zero,8(r16)
 820a8a8:	80000115 	stw	zero,4(r16)
 820a8ac:	80000415 	stw	zero,16(r16)
 820a8b0:	80000515 	stw	zero,20(r16)
 820a8b4:	80000615 	stw	zero,24(r16)
 820a8b8:	01800204 	movi	r6,8
 820a8bc:	000b883a 	mov	r5,zero
 820a8c0:	81001704 	addi	r4,r16,92
 820a8c4:	8202cb00 	call	8202cb0 <memset>
 820a8c8:	8005883a 	mov	r2,r16
 820a8cc:	80000c15 	stw	zero,48(r16)
 820a8d0:	80000d15 	stw	zero,52(r16)
 820a8d4:	80001115 	stw	zero,68(r16)
 820a8d8:	80001215 	stw	zero,72(r16)
 820a8dc:	dfc00417 	ldw	ra,16(sp)
 820a8e0:	dcc00317 	ldw	r19,12(sp)
 820a8e4:	dc800217 	ldw	r18,8(sp)
 820a8e8:	dc400117 	ldw	r17,4(sp)
 820a8ec:	dc000017 	ldw	r16,0(sp)
 820a8f0:	dec00504 	addi	sp,sp,20
 820a8f4:	f800283a 	ret
 820a8f8:	01400104 	movi	r5,4
 820a8fc:	9809883a 	mov	r4,r19
 820a900:	820a79c0 	call	820a79c <__sfmoreglue>
 820a904:	90800015 	stw	r2,0(r18)
 820a908:	103fde1e 	bne	r2,zero,820a884 <__sfp+0x80>
 820a90c:	00800304 	movi	r2,12
 820a910:	98800015 	stw	r2,0(r19)
 820a914:	0005883a 	mov	r2,zero
 820a918:	003ff006 	br	820a8dc <__sfp+0xd8>

0820a91c <_cleanup>:
 820a91c:	00820974 	movhi	r2,2085
 820a920:	108e2f04 	addi	r2,r2,14524
 820a924:	11000017 	ldw	r4,0(r2)
 820a928:	01420874 	movhi	r5,2081
 820a92c:	2941d404 	addi	r5,r5,1872
 820a930:	820b48c1 	jmpi	820b48c <_fwalk_reent>

0820a934 <__sinit>:
 820a934:	20800e17 	ldw	r2,56(r4)
 820a938:	10000126 	beq	r2,zero,820a940 <__sinit+0xc>
 820a93c:	f800283a 	ret
 820a940:	820a5f81 	jmpi	820a5f8 <__sinit.part.1>

0820a944 <__sfp_lock_acquire>:
 820a944:	f800283a 	ret

0820a948 <__sfp_lock_release>:
 820a948:	f800283a 	ret

0820a94c <__sinit_lock_acquire>:
 820a94c:	f800283a 	ret

0820a950 <__sinit_lock_release>:
 820a950:	f800283a 	ret

0820a954 <__fp_lock_all>:
 820a954:	00820974 	movhi	r2,2085
 820a958:	108e3004 	addi	r2,r2,14528
 820a95c:	11000017 	ldw	r4,0(r2)
 820a960:	01420874 	movhi	r5,2081
 820a964:	2969e504 	addi	r5,r5,-22636
 820a968:	820b3c81 	jmpi	820b3c8 <_fwalk>

0820a96c <__fp_unlock_all>:
 820a96c:	00820974 	movhi	r2,2085
 820a970:	108e3004 	addi	r2,r2,14528
 820a974:	11000017 	ldw	r4,0(r2)
 820a978:	01420874 	movhi	r5,2081
 820a97c:	29697904 	addi	r5,r5,-23068
 820a980:	820b3c81 	jmpi	820b3c8 <_fwalk>

0820a984 <_fputc_r>:
 820a984:	defffc04 	addi	sp,sp,-16
 820a988:	dc000215 	stw	r16,8(sp)
 820a98c:	dfc00315 	stw	ra,12(sp)
 820a990:	2021883a 	mov	r16,r4
 820a994:	20000726 	beq	r4,zero,820a9b4 <_fputc_r+0x30>
 820a998:	20800e17 	ldw	r2,56(r4)
 820a99c:	1000051e 	bne	r2,zero,820a9b4 <_fputc_r+0x30>
 820a9a0:	d9400015 	stw	r5,0(sp)
 820a9a4:	d9800115 	stw	r6,4(sp)
 820a9a8:	820a9340 	call	820a934 <__sinit>
 820a9ac:	d9800117 	ldw	r6,4(sp)
 820a9b0:	d9400017 	ldw	r5,0(sp)
 820a9b4:	8009883a 	mov	r4,r16
 820a9b8:	dfc00317 	ldw	ra,12(sp)
 820a9bc:	dc000217 	ldw	r16,8(sp)
 820a9c0:	dec00404 	addi	sp,sp,16
 820a9c4:	8202ed81 	jmpi	8202ed8 <_putc_r>

0820a9c8 <fputc>:
 820a9c8:	00820974 	movhi	r2,2085
 820a9cc:	defffc04 	addi	sp,sp,-16
 820a9d0:	108e3004 	addi	r2,r2,14528
 820a9d4:	dc000115 	stw	r16,4(sp)
 820a9d8:	14000017 	ldw	r16,0(r2)
 820a9dc:	dc400215 	stw	r17,8(sp)
 820a9e0:	dfc00315 	stw	ra,12(sp)
 820a9e4:	2023883a 	mov	r17,r4
 820a9e8:	80000626 	beq	r16,zero,820aa04 <fputc+0x3c>
 820a9ec:	80800e17 	ldw	r2,56(r16)
 820a9f0:	1000041e 	bne	r2,zero,820aa04 <fputc+0x3c>
 820a9f4:	8009883a 	mov	r4,r16
 820a9f8:	d9400015 	stw	r5,0(sp)
 820a9fc:	820a9340 	call	820a934 <__sinit>
 820aa00:	d9400017 	ldw	r5,0(sp)
 820aa04:	280d883a 	mov	r6,r5
 820aa08:	8009883a 	mov	r4,r16
 820aa0c:	880b883a 	mov	r5,r17
 820aa10:	dfc00317 	ldw	ra,12(sp)
 820aa14:	dc400217 	ldw	r17,8(sp)
 820aa18:	dc000117 	ldw	r16,4(sp)
 820aa1c:	dec00404 	addi	sp,sp,16
 820aa20:	8202ed81 	jmpi	8202ed8 <_putc_r>

0820aa24 <_fputs_r>:
 820aa24:	defff804 	addi	sp,sp,-32
 820aa28:	dc400615 	stw	r17,24(sp)
 820aa2c:	2023883a 	mov	r17,r4
 820aa30:	2809883a 	mov	r4,r5
 820aa34:	dc000515 	stw	r16,20(sp)
 820aa38:	dfc00715 	stw	ra,28(sp)
 820aa3c:	3021883a 	mov	r16,r6
 820aa40:	d9400315 	stw	r5,12(sp)
 820aa44:	8203a5c0 	call	8203a5c <strlen>
 820aa48:	d8800215 	stw	r2,8(sp)
 820aa4c:	d8800415 	stw	r2,16(sp)
 820aa50:	d8800304 	addi	r2,sp,12
 820aa54:	d8800015 	stw	r2,0(sp)
 820aa58:	00800044 	movi	r2,1
 820aa5c:	d8800115 	stw	r2,4(sp)
 820aa60:	88000226 	beq	r17,zero,820aa6c <_fputs_r+0x48>
 820aa64:	88800e17 	ldw	r2,56(r17)
 820aa68:	10001226 	beq	r2,zero,820aab4 <_fputs_r+0x90>
 820aa6c:	8080030b 	ldhu	r2,12(r16)
 820aa70:	10c8000c 	andi	r3,r2,8192
 820aa74:	1800061e 	bne	r3,zero,820aa90 <_fputs_r+0x6c>
 820aa78:	81001917 	ldw	r4,100(r16)
 820aa7c:	00f7ffc4 	movi	r3,-8193
 820aa80:	10880014 	ori	r2,r2,8192
 820aa84:	20c6703a 	and	r3,r4,r3
 820aa88:	8080030d 	sth	r2,12(r16)
 820aa8c:	80c01915 	stw	r3,100(r16)
 820aa90:	d80d883a 	mov	r6,sp
 820aa94:	800b883a 	mov	r5,r16
 820aa98:	8809883a 	mov	r4,r17
 820aa9c:	820af0c0 	call	820af0c <__sfvwrite_r>
 820aaa0:	dfc00717 	ldw	ra,28(sp)
 820aaa4:	dc400617 	ldw	r17,24(sp)
 820aaa8:	dc000517 	ldw	r16,20(sp)
 820aaac:	dec00804 	addi	sp,sp,32
 820aab0:	f800283a 	ret
 820aab4:	8809883a 	mov	r4,r17
 820aab8:	820a9340 	call	820a934 <__sinit>
 820aabc:	003feb06 	br	820aa6c <_fputs_r+0x48>

0820aac0 <fputs>:
 820aac0:	00820974 	movhi	r2,2085
 820aac4:	108e3004 	addi	r2,r2,14528
 820aac8:	280d883a 	mov	r6,r5
 820aacc:	200b883a 	mov	r5,r4
 820aad0:	11000017 	ldw	r4,0(r2)
 820aad4:	820aa241 	jmpi	820aa24 <_fputs_r>

0820aad8 <_malloc_trim_r>:
 820aad8:	defffb04 	addi	sp,sp,-20
 820aadc:	dcc00315 	stw	r19,12(sp)
 820aae0:	04c20974 	movhi	r19,2085
 820aae4:	dc800215 	stw	r18,8(sp)
 820aae8:	dc400115 	stw	r17,4(sp)
 820aaec:	dc000015 	stw	r16,0(sp)
 820aaf0:	dfc00415 	stw	ra,16(sp)
 820aaf4:	2821883a 	mov	r16,r5
 820aaf8:	9cc7be04 	addi	r19,r19,7928
 820aafc:	2025883a 	mov	r18,r4
 820ab00:	821462c0 	call	821462c <__malloc_lock>
 820ab04:	98800217 	ldw	r2,8(r19)
 820ab08:	14400117 	ldw	r17,4(r2)
 820ab0c:	00bfff04 	movi	r2,-4
 820ab10:	88a2703a 	and	r17,r17,r2
 820ab14:	8c21c83a 	sub	r16,r17,r16
 820ab18:	8403fbc4 	addi	r16,r16,4079
 820ab1c:	8020d33a 	srli	r16,r16,12
 820ab20:	0083ffc4 	movi	r2,4095
 820ab24:	843fffc4 	addi	r16,r16,-1
 820ab28:	8020933a 	slli	r16,r16,12
 820ab2c:	1400060e 	bge	r2,r16,820ab48 <_malloc_trim_r+0x70>
 820ab30:	000b883a 	mov	r5,zero
 820ab34:	9009883a 	mov	r4,r18
 820ab38:	820d9180 	call	820d918 <_sbrk_r>
 820ab3c:	98c00217 	ldw	r3,8(r19)
 820ab40:	1c47883a 	add	r3,r3,r17
 820ab44:	10c00a26 	beq	r2,r3,820ab70 <_malloc_trim_r+0x98>
 820ab48:	9009883a 	mov	r4,r18
 820ab4c:	821474c0 	call	821474c <__malloc_unlock>
 820ab50:	0005883a 	mov	r2,zero
 820ab54:	dfc00417 	ldw	ra,16(sp)
 820ab58:	dcc00317 	ldw	r19,12(sp)
 820ab5c:	dc800217 	ldw	r18,8(sp)
 820ab60:	dc400117 	ldw	r17,4(sp)
 820ab64:	dc000017 	ldw	r16,0(sp)
 820ab68:	dec00504 	addi	sp,sp,20
 820ab6c:	f800283a 	ret
 820ab70:	040bc83a 	sub	r5,zero,r16
 820ab74:	9009883a 	mov	r4,r18
 820ab78:	820d9180 	call	820d918 <_sbrk_r>
 820ab7c:	00ffffc4 	movi	r3,-1
 820ab80:	10c00d26 	beq	r2,r3,820abb8 <_malloc_trim_r+0xe0>
 820ab84:	00c20974 	movhi	r3,2085
 820ab88:	18d08704 	addi	r3,r3,16924
 820ab8c:	18800017 	ldw	r2,0(r3)
 820ab90:	99000217 	ldw	r4,8(r19)
 820ab94:	8c23c83a 	sub	r17,r17,r16
 820ab98:	8c400054 	ori	r17,r17,1
 820ab9c:	1421c83a 	sub	r16,r2,r16
 820aba0:	24400115 	stw	r17,4(r4)
 820aba4:	9009883a 	mov	r4,r18
 820aba8:	1c000015 	stw	r16,0(r3)
 820abac:	821474c0 	call	821474c <__malloc_unlock>
 820abb0:	00800044 	movi	r2,1
 820abb4:	003fe706 	br	820ab54 <_malloc_trim_r+0x7c>
 820abb8:	000b883a 	mov	r5,zero
 820abbc:	9009883a 	mov	r4,r18
 820abc0:	820d9180 	call	820d918 <_sbrk_r>
 820abc4:	99000217 	ldw	r4,8(r19)
 820abc8:	014003c4 	movi	r5,15
 820abcc:	1107c83a 	sub	r3,r2,r4
 820abd0:	28ffdd0e 	bge	r5,r3,820ab48 <_malloc_trim_r+0x70>
 820abd4:	01420974 	movhi	r5,2085
 820abd8:	294e3204 	addi	r5,r5,14536
 820abdc:	29400017 	ldw	r5,0(r5)
 820abe0:	18c00054 	ori	r3,r3,1
 820abe4:	20c00115 	stw	r3,4(r4)
 820abe8:	00c20974 	movhi	r3,2085
 820abec:	1145c83a 	sub	r2,r2,r5
 820abf0:	18d08704 	addi	r3,r3,16924
 820abf4:	18800015 	stw	r2,0(r3)
 820abf8:	003fd306 	br	820ab48 <_malloc_trim_r+0x70>

0820abfc <_free_r>:
 820abfc:	28004126 	beq	r5,zero,820ad04 <_free_r+0x108>
 820ac00:	defffd04 	addi	sp,sp,-12
 820ac04:	dc400115 	stw	r17,4(sp)
 820ac08:	dc000015 	stw	r16,0(sp)
 820ac0c:	2023883a 	mov	r17,r4
 820ac10:	2821883a 	mov	r16,r5
 820ac14:	dfc00215 	stw	ra,8(sp)
 820ac18:	821462c0 	call	821462c <__malloc_lock>
 820ac1c:	81ffff17 	ldw	r7,-4(r16)
 820ac20:	00bfff84 	movi	r2,-2
 820ac24:	01020974 	movhi	r4,2085
 820ac28:	81bffe04 	addi	r6,r16,-8
 820ac2c:	3884703a 	and	r2,r7,r2
 820ac30:	2107be04 	addi	r4,r4,7928
 820ac34:	308b883a 	add	r5,r6,r2
 820ac38:	2a400117 	ldw	r9,4(r5)
 820ac3c:	22000217 	ldw	r8,8(r4)
 820ac40:	00ffff04 	movi	r3,-4
 820ac44:	48c6703a 	and	r3,r9,r3
 820ac48:	2a005726 	beq	r5,r8,820ada8 <_free_r+0x1ac>
 820ac4c:	28c00115 	stw	r3,4(r5)
 820ac50:	39c0004c 	andi	r7,r7,1
 820ac54:	3800091e 	bne	r7,zero,820ac7c <_free_r+0x80>
 820ac58:	823ffe17 	ldw	r8,-8(r16)
 820ac5c:	22400204 	addi	r9,r4,8
 820ac60:	320dc83a 	sub	r6,r6,r8
 820ac64:	31c00217 	ldw	r7,8(r6)
 820ac68:	1205883a 	add	r2,r2,r8
 820ac6c:	3a406526 	beq	r7,r9,820ae04 <_free_r+0x208>
 820ac70:	32000317 	ldw	r8,12(r6)
 820ac74:	3a000315 	stw	r8,12(r7)
 820ac78:	41c00215 	stw	r7,8(r8)
 820ac7c:	28cf883a 	add	r7,r5,r3
 820ac80:	39c00117 	ldw	r7,4(r7)
 820ac84:	39c0004c 	andi	r7,r7,1
 820ac88:	38003a26 	beq	r7,zero,820ad74 <_free_r+0x178>
 820ac8c:	10c00054 	ori	r3,r2,1
 820ac90:	30c00115 	stw	r3,4(r6)
 820ac94:	3087883a 	add	r3,r6,r2
 820ac98:	18800015 	stw	r2,0(r3)
 820ac9c:	00c07fc4 	movi	r3,511
 820aca0:	18801936 	bltu	r3,r2,820ad08 <_free_r+0x10c>
 820aca4:	1004d0fa 	srli	r2,r2,3
 820aca8:	01c00044 	movi	r7,1
 820acac:	21400117 	ldw	r5,4(r4)
 820acb0:	10c00044 	addi	r3,r2,1
 820acb4:	18c7883a 	add	r3,r3,r3
 820acb8:	1005d0ba 	srai	r2,r2,2
 820acbc:	18c7883a 	add	r3,r3,r3
 820acc0:	18c7883a 	add	r3,r3,r3
 820acc4:	1907883a 	add	r3,r3,r4
 820acc8:	3884983a 	sll	r2,r7,r2
 820accc:	19c00017 	ldw	r7,0(r3)
 820acd0:	1a3ffe04 	addi	r8,r3,-8
 820acd4:	1144b03a 	or	r2,r2,r5
 820acd8:	32000315 	stw	r8,12(r6)
 820acdc:	31c00215 	stw	r7,8(r6)
 820ace0:	20800115 	stw	r2,4(r4)
 820ace4:	19800015 	stw	r6,0(r3)
 820ace8:	39800315 	stw	r6,12(r7)
 820acec:	8809883a 	mov	r4,r17
 820acf0:	dfc00217 	ldw	ra,8(sp)
 820acf4:	dc400117 	ldw	r17,4(sp)
 820acf8:	dc000017 	ldw	r16,0(sp)
 820acfc:	dec00304 	addi	sp,sp,12
 820ad00:	821474c1 	jmpi	821474c <__malloc_unlock>
 820ad04:	f800283a 	ret
 820ad08:	100ad27a 	srli	r5,r2,9
 820ad0c:	00c00104 	movi	r3,4
 820ad10:	19404a36 	bltu	r3,r5,820ae3c <_free_r+0x240>
 820ad14:	100ad1ba 	srli	r5,r2,6
 820ad18:	28c00e44 	addi	r3,r5,57
 820ad1c:	18c7883a 	add	r3,r3,r3
 820ad20:	29400e04 	addi	r5,r5,56
 820ad24:	18c7883a 	add	r3,r3,r3
 820ad28:	18c7883a 	add	r3,r3,r3
 820ad2c:	1909883a 	add	r4,r3,r4
 820ad30:	20c00017 	ldw	r3,0(r4)
 820ad34:	01c20974 	movhi	r7,2085
 820ad38:	213ffe04 	addi	r4,r4,-8
 820ad3c:	39c7be04 	addi	r7,r7,7928
 820ad40:	20c04426 	beq	r4,r3,820ae54 <_free_r+0x258>
 820ad44:	01ffff04 	movi	r7,-4
 820ad48:	19400117 	ldw	r5,4(r3)
 820ad4c:	29ca703a 	and	r5,r5,r7
 820ad50:	1140022e 	bgeu	r2,r5,820ad5c <_free_r+0x160>
 820ad54:	18c00217 	ldw	r3,8(r3)
 820ad58:	20fffb1e 	bne	r4,r3,820ad48 <_free_r+0x14c>
 820ad5c:	19000317 	ldw	r4,12(r3)
 820ad60:	31000315 	stw	r4,12(r6)
 820ad64:	30c00215 	stw	r3,8(r6)
 820ad68:	21800215 	stw	r6,8(r4)
 820ad6c:	19800315 	stw	r6,12(r3)
 820ad70:	003fde06 	br	820acec <_free_r+0xf0>
 820ad74:	29c00217 	ldw	r7,8(r5)
 820ad78:	10c5883a 	add	r2,r2,r3
 820ad7c:	00c20974 	movhi	r3,2085
 820ad80:	18c7c004 	addi	r3,r3,7936
 820ad84:	38c03b26 	beq	r7,r3,820ae74 <_free_r+0x278>
 820ad88:	2a000317 	ldw	r8,12(r5)
 820ad8c:	11400054 	ori	r5,r2,1
 820ad90:	3087883a 	add	r3,r6,r2
 820ad94:	3a000315 	stw	r8,12(r7)
 820ad98:	41c00215 	stw	r7,8(r8)
 820ad9c:	31400115 	stw	r5,4(r6)
 820ada0:	18800015 	stw	r2,0(r3)
 820ada4:	003fbd06 	br	820ac9c <_free_r+0xa0>
 820ada8:	39c0004c 	andi	r7,r7,1
 820adac:	10c5883a 	add	r2,r2,r3
 820adb0:	3800071e 	bne	r7,zero,820add0 <_free_r+0x1d4>
 820adb4:	81fffe17 	ldw	r7,-8(r16)
 820adb8:	31cdc83a 	sub	r6,r6,r7
 820adbc:	30c00317 	ldw	r3,12(r6)
 820adc0:	31400217 	ldw	r5,8(r6)
 820adc4:	11c5883a 	add	r2,r2,r7
 820adc8:	28c00315 	stw	r3,12(r5)
 820adcc:	19400215 	stw	r5,8(r3)
 820add0:	10c00054 	ori	r3,r2,1
 820add4:	30c00115 	stw	r3,4(r6)
 820add8:	00c20974 	movhi	r3,2085
 820addc:	18ce3304 	addi	r3,r3,14540
 820ade0:	18c00017 	ldw	r3,0(r3)
 820ade4:	21800215 	stw	r6,8(r4)
 820ade8:	10ffc036 	bltu	r2,r3,820acec <_free_r+0xf0>
 820adec:	00820974 	movhi	r2,2085
 820adf0:	108e9004 	addi	r2,r2,14912
 820adf4:	11400017 	ldw	r5,0(r2)
 820adf8:	8809883a 	mov	r4,r17
 820adfc:	820aad80 	call	820aad8 <_malloc_trim_r>
 820ae00:	003fba06 	br	820acec <_free_r+0xf0>
 820ae04:	28c9883a 	add	r4,r5,r3
 820ae08:	21000117 	ldw	r4,4(r4)
 820ae0c:	2100004c 	andi	r4,r4,1
 820ae10:	2000391e 	bne	r4,zero,820aef8 <_free_r+0x2fc>
 820ae14:	29c00217 	ldw	r7,8(r5)
 820ae18:	29000317 	ldw	r4,12(r5)
 820ae1c:	1885883a 	add	r2,r3,r2
 820ae20:	10c00054 	ori	r3,r2,1
 820ae24:	39000315 	stw	r4,12(r7)
 820ae28:	21c00215 	stw	r7,8(r4)
 820ae2c:	30c00115 	stw	r3,4(r6)
 820ae30:	308d883a 	add	r6,r6,r2
 820ae34:	30800015 	stw	r2,0(r6)
 820ae38:	003fac06 	br	820acec <_free_r+0xf0>
 820ae3c:	00c00504 	movi	r3,20
 820ae40:	19401536 	bltu	r3,r5,820ae98 <_free_r+0x29c>
 820ae44:	28c01704 	addi	r3,r5,92
 820ae48:	18c7883a 	add	r3,r3,r3
 820ae4c:	294016c4 	addi	r5,r5,91
 820ae50:	003fb406 	br	820ad24 <_free_r+0x128>
 820ae54:	280bd0ba 	srai	r5,r5,2
 820ae58:	00c00044 	movi	r3,1
 820ae5c:	38800117 	ldw	r2,4(r7)
 820ae60:	194a983a 	sll	r5,r3,r5
 820ae64:	2007883a 	mov	r3,r4
 820ae68:	2884b03a 	or	r2,r5,r2
 820ae6c:	38800115 	stw	r2,4(r7)
 820ae70:	003fbb06 	br	820ad60 <_free_r+0x164>
 820ae74:	21800515 	stw	r6,20(r4)
 820ae78:	21800415 	stw	r6,16(r4)
 820ae7c:	10c00054 	ori	r3,r2,1
 820ae80:	31c00315 	stw	r7,12(r6)
 820ae84:	31c00215 	stw	r7,8(r6)
 820ae88:	30c00115 	stw	r3,4(r6)
 820ae8c:	308d883a 	add	r6,r6,r2
 820ae90:	30800015 	stw	r2,0(r6)
 820ae94:	003f9506 	br	820acec <_free_r+0xf0>
 820ae98:	00c01504 	movi	r3,84
 820ae9c:	19400536 	bltu	r3,r5,820aeb4 <_free_r+0x2b8>
 820aea0:	100ad33a 	srli	r5,r2,12
 820aea4:	28c01bc4 	addi	r3,r5,111
 820aea8:	18c7883a 	add	r3,r3,r3
 820aeac:	29401b84 	addi	r5,r5,110
 820aeb0:	003f9c06 	br	820ad24 <_free_r+0x128>
 820aeb4:	00c05504 	movi	r3,340
 820aeb8:	19400536 	bltu	r3,r5,820aed0 <_free_r+0x2d4>
 820aebc:	100ad3fa 	srli	r5,r2,15
 820aec0:	28c01e04 	addi	r3,r5,120
 820aec4:	18c7883a 	add	r3,r3,r3
 820aec8:	29401dc4 	addi	r5,r5,119
 820aecc:	003f9506 	br	820ad24 <_free_r+0x128>
 820aed0:	00c15504 	movi	r3,1364
 820aed4:	19400536 	bltu	r3,r5,820aeec <_free_r+0x2f0>
 820aed8:	100ad4ba 	srli	r5,r2,18
 820aedc:	28c01f44 	addi	r3,r5,125
 820aee0:	18c7883a 	add	r3,r3,r3
 820aee4:	29401f04 	addi	r5,r5,124
 820aee8:	003f8e06 	br	820ad24 <_free_r+0x128>
 820aeec:	00c03f84 	movi	r3,254
 820aef0:	01401f84 	movi	r5,126
 820aef4:	003f8b06 	br	820ad24 <_free_r+0x128>
 820aef8:	10c00054 	ori	r3,r2,1
 820aefc:	30c00115 	stw	r3,4(r6)
 820af00:	308d883a 	add	r6,r6,r2
 820af04:	30800015 	stw	r2,0(r6)
 820af08:	003f7806 	br	820acec <_free_r+0xf0>

0820af0c <__sfvwrite_r>:
 820af0c:	30800217 	ldw	r2,8(r6)
 820af10:	10006726 	beq	r2,zero,820b0b0 <__sfvwrite_r+0x1a4>
 820af14:	28c0030b 	ldhu	r3,12(r5)
 820af18:	defff404 	addi	sp,sp,-48
 820af1c:	dd400715 	stw	r21,28(sp)
 820af20:	dd000615 	stw	r20,24(sp)
 820af24:	dc000215 	stw	r16,8(sp)
 820af28:	dfc00b15 	stw	ra,44(sp)
 820af2c:	df000a15 	stw	fp,40(sp)
 820af30:	ddc00915 	stw	r23,36(sp)
 820af34:	dd800815 	stw	r22,32(sp)
 820af38:	dcc00515 	stw	r19,20(sp)
 820af3c:	dc800415 	stw	r18,16(sp)
 820af40:	dc400315 	stw	r17,12(sp)
 820af44:	1880020c 	andi	r2,r3,8
 820af48:	2821883a 	mov	r16,r5
 820af4c:	202b883a 	mov	r21,r4
 820af50:	3029883a 	mov	r20,r6
 820af54:	10002726 	beq	r2,zero,820aff4 <__sfvwrite_r+0xe8>
 820af58:	28800417 	ldw	r2,16(r5)
 820af5c:	10002526 	beq	r2,zero,820aff4 <__sfvwrite_r+0xe8>
 820af60:	1880008c 	andi	r2,r3,2
 820af64:	a4400017 	ldw	r17,0(r20)
 820af68:	10002a26 	beq	r2,zero,820b014 <__sfvwrite_r+0x108>
 820af6c:	05a00034 	movhi	r22,32768
 820af70:	0027883a 	mov	r19,zero
 820af74:	0025883a 	mov	r18,zero
 820af78:	b5bf0004 	addi	r22,r22,-1024
 820af7c:	980d883a 	mov	r6,r19
 820af80:	a809883a 	mov	r4,r21
 820af84:	90004626 	beq	r18,zero,820b0a0 <__sfvwrite_r+0x194>
 820af88:	900f883a 	mov	r7,r18
 820af8c:	b480022e 	bgeu	r22,r18,820af98 <__sfvwrite_r+0x8c>
 820af90:	01e00034 	movhi	r7,32768
 820af94:	39ff0004 	addi	r7,r7,-1024
 820af98:	80800917 	ldw	r2,36(r16)
 820af9c:	81400717 	ldw	r5,28(r16)
 820afa0:	103ee83a 	callr	r2
 820afa4:	0080570e 	bge	zero,r2,820b104 <__sfvwrite_r+0x1f8>
 820afa8:	a0c00217 	ldw	r3,8(r20)
 820afac:	98a7883a 	add	r19,r19,r2
 820afb0:	90a5c83a 	sub	r18,r18,r2
 820afb4:	1885c83a 	sub	r2,r3,r2
 820afb8:	a0800215 	stw	r2,8(r20)
 820afbc:	103fef1e 	bne	r2,zero,820af7c <__sfvwrite_r+0x70>
 820afc0:	0005883a 	mov	r2,zero
 820afc4:	dfc00b17 	ldw	ra,44(sp)
 820afc8:	df000a17 	ldw	fp,40(sp)
 820afcc:	ddc00917 	ldw	r23,36(sp)
 820afd0:	dd800817 	ldw	r22,32(sp)
 820afd4:	dd400717 	ldw	r21,28(sp)
 820afd8:	dd000617 	ldw	r20,24(sp)
 820afdc:	dcc00517 	ldw	r19,20(sp)
 820afe0:	dc800417 	ldw	r18,16(sp)
 820afe4:	dc400317 	ldw	r17,12(sp)
 820afe8:	dc000217 	ldw	r16,8(sp)
 820afec:	dec00c04 	addi	sp,sp,48
 820aff0:	f800283a 	ret
 820aff4:	800b883a 	mov	r5,r16
 820aff8:	a809883a 	mov	r4,r21
 820affc:	82089600 	call	8208960 <__swsetup_r>
 820b000:	1000eb1e 	bne	r2,zero,820b3b0 <__sfvwrite_r+0x4a4>
 820b004:	80c0030b 	ldhu	r3,12(r16)
 820b008:	a4400017 	ldw	r17,0(r20)
 820b00c:	1880008c 	andi	r2,r3,2
 820b010:	103fd61e 	bne	r2,zero,820af6c <__sfvwrite_r+0x60>
 820b014:	1880004c 	andi	r2,r3,1
 820b018:	10003f1e 	bne	r2,zero,820b118 <__sfvwrite_r+0x20c>
 820b01c:	0039883a 	mov	fp,zero
 820b020:	0025883a 	mov	r18,zero
 820b024:	90001a26 	beq	r18,zero,820b090 <__sfvwrite_r+0x184>
 820b028:	1880800c 	andi	r2,r3,512
 820b02c:	84c00217 	ldw	r19,8(r16)
 820b030:	10002126 	beq	r2,zero,820b0b8 <__sfvwrite_r+0x1ac>
 820b034:	982f883a 	mov	r23,r19
 820b038:	94c09336 	bltu	r18,r19,820b288 <__sfvwrite_r+0x37c>
 820b03c:	1881200c 	andi	r2,r3,1152
 820b040:	10009e1e 	bne	r2,zero,820b2bc <__sfvwrite_r+0x3b0>
 820b044:	81000017 	ldw	r4,0(r16)
 820b048:	b80d883a 	mov	r6,r23
 820b04c:	e00b883a 	mov	r5,fp
 820b050:	8202b540 	call	8202b54 <memmove>
 820b054:	80c00217 	ldw	r3,8(r16)
 820b058:	81000017 	ldw	r4,0(r16)
 820b05c:	9005883a 	mov	r2,r18
 820b060:	1ce7c83a 	sub	r19,r3,r19
 820b064:	25cf883a 	add	r7,r4,r23
 820b068:	84c00215 	stw	r19,8(r16)
 820b06c:	81c00015 	stw	r7,0(r16)
 820b070:	a0c00217 	ldw	r3,8(r20)
 820b074:	e0b9883a 	add	fp,fp,r2
 820b078:	90a5c83a 	sub	r18,r18,r2
 820b07c:	18a7c83a 	sub	r19,r3,r2
 820b080:	a4c00215 	stw	r19,8(r20)
 820b084:	983fce26 	beq	r19,zero,820afc0 <__sfvwrite_r+0xb4>
 820b088:	80c0030b 	ldhu	r3,12(r16)
 820b08c:	903fe61e 	bne	r18,zero,820b028 <__sfvwrite_r+0x11c>
 820b090:	8f000017 	ldw	fp,0(r17)
 820b094:	8c800117 	ldw	r18,4(r17)
 820b098:	8c400204 	addi	r17,r17,8
 820b09c:	003fe106 	br	820b024 <__sfvwrite_r+0x118>
 820b0a0:	8cc00017 	ldw	r19,0(r17)
 820b0a4:	8c800117 	ldw	r18,4(r17)
 820b0a8:	8c400204 	addi	r17,r17,8
 820b0ac:	003fb306 	br	820af7c <__sfvwrite_r+0x70>
 820b0b0:	0005883a 	mov	r2,zero
 820b0b4:	f800283a 	ret
 820b0b8:	81000017 	ldw	r4,0(r16)
 820b0bc:	80800417 	ldw	r2,16(r16)
 820b0c0:	11005736 	bltu	r2,r4,820b220 <__sfvwrite_r+0x314>
 820b0c4:	85c00517 	ldw	r23,20(r16)
 820b0c8:	95c05536 	bltu	r18,r23,820b220 <__sfvwrite_r+0x314>
 820b0cc:	00a00034 	movhi	r2,32768
 820b0d0:	10bfffc4 	addi	r2,r2,-1
 820b0d4:	9009883a 	mov	r4,r18
 820b0d8:	1480012e 	bgeu	r2,r18,820b0e0 <__sfvwrite_r+0x1d4>
 820b0dc:	1009883a 	mov	r4,r2
 820b0e0:	b80b883a 	mov	r5,r23
 820b0e4:	82026140 	call	8202614 <__divsi3>
 820b0e8:	15cf383a 	mul	r7,r2,r23
 820b0ec:	81400717 	ldw	r5,28(r16)
 820b0f0:	80800917 	ldw	r2,36(r16)
 820b0f4:	e00d883a 	mov	r6,fp
 820b0f8:	a809883a 	mov	r4,r21
 820b0fc:	103ee83a 	callr	r2
 820b100:	00bfdb16 	blt	zero,r2,820b070 <__sfvwrite_r+0x164>
 820b104:	8080030b 	ldhu	r2,12(r16)
 820b108:	10801014 	ori	r2,r2,64
 820b10c:	8080030d 	sth	r2,12(r16)
 820b110:	00bfffc4 	movi	r2,-1
 820b114:	003fab06 	br	820afc4 <__sfvwrite_r+0xb8>
 820b118:	0027883a 	mov	r19,zero
 820b11c:	0011883a 	mov	r8,zero
 820b120:	0039883a 	mov	fp,zero
 820b124:	0025883a 	mov	r18,zero
 820b128:	90001f26 	beq	r18,zero,820b1a8 <__sfvwrite_r+0x29c>
 820b12c:	40005a26 	beq	r8,zero,820b298 <__sfvwrite_r+0x38c>
 820b130:	982d883a 	mov	r22,r19
 820b134:	94c0012e 	bgeu	r18,r19,820b13c <__sfvwrite_r+0x230>
 820b138:	902d883a 	mov	r22,r18
 820b13c:	81000017 	ldw	r4,0(r16)
 820b140:	80800417 	ldw	r2,16(r16)
 820b144:	b02f883a 	mov	r23,r22
 820b148:	81c00517 	ldw	r7,20(r16)
 820b14c:	1100032e 	bgeu	r2,r4,820b15c <__sfvwrite_r+0x250>
 820b150:	80c00217 	ldw	r3,8(r16)
 820b154:	38c7883a 	add	r3,r7,r3
 820b158:	1d801816 	blt	r3,r22,820b1bc <__sfvwrite_r+0x2b0>
 820b15c:	b1c03e16 	blt	r22,r7,820b258 <__sfvwrite_r+0x34c>
 820b160:	80800917 	ldw	r2,36(r16)
 820b164:	81400717 	ldw	r5,28(r16)
 820b168:	e00d883a 	mov	r6,fp
 820b16c:	da000115 	stw	r8,4(sp)
 820b170:	a809883a 	mov	r4,r21
 820b174:	103ee83a 	callr	r2
 820b178:	102f883a 	mov	r23,r2
 820b17c:	da000117 	ldw	r8,4(sp)
 820b180:	00bfe00e 	bge	zero,r2,820b104 <__sfvwrite_r+0x1f8>
 820b184:	9de7c83a 	sub	r19,r19,r23
 820b188:	98001f26 	beq	r19,zero,820b208 <__sfvwrite_r+0x2fc>
 820b18c:	a0800217 	ldw	r2,8(r20)
 820b190:	e5f9883a 	add	fp,fp,r23
 820b194:	95e5c83a 	sub	r18,r18,r23
 820b198:	15efc83a 	sub	r23,r2,r23
 820b19c:	a5c00215 	stw	r23,8(r20)
 820b1a0:	b83f8726 	beq	r23,zero,820afc0 <__sfvwrite_r+0xb4>
 820b1a4:	903fe11e 	bne	r18,zero,820b12c <__sfvwrite_r+0x220>
 820b1a8:	8f000017 	ldw	fp,0(r17)
 820b1ac:	8c800117 	ldw	r18,4(r17)
 820b1b0:	0011883a 	mov	r8,zero
 820b1b4:	8c400204 	addi	r17,r17,8
 820b1b8:	003fdb06 	br	820b128 <__sfvwrite_r+0x21c>
 820b1bc:	180d883a 	mov	r6,r3
 820b1c0:	e00b883a 	mov	r5,fp
 820b1c4:	da000115 	stw	r8,4(sp)
 820b1c8:	d8c00015 	stw	r3,0(sp)
 820b1cc:	8202b540 	call	8202b54 <memmove>
 820b1d0:	d8c00017 	ldw	r3,0(sp)
 820b1d4:	80800017 	ldw	r2,0(r16)
 820b1d8:	800b883a 	mov	r5,r16
 820b1dc:	a809883a 	mov	r4,r21
 820b1e0:	10c5883a 	add	r2,r2,r3
 820b1e4:	80800015 	stw	r2,0(r16)
 820b1e8:	d8c00015 	stw	r3,0(sp)
 820b1ec:	820a5580 	call	820a558 <_fflush_r>
 820b1f0:	d8c00017 	ldw	r3,0(sp)
 820b1f4:	da000117 	ldw	r8,4(sp)
 820b1f8:	103fc21e 	bne	r2,zero,820b104 <__sfvwrite_r+0x1f8>
 820b1fc:	182f883a 	mov	r23,r3
 820b200:	9de7c83a 	sub	r19,r19,r23
 820b204:	983fe11e 	bne	r19,zero,820b18c <__sfvwrite_r+0x280>
 820b208:	800b883a 	mov	r5,r16
 820b20c:	a809883a 	mov	r4,r21
 820b210:	820a5580 	call	820a558 <_fflush_r>
 820b214:	103fbb1e 	bne	r2,zero,820b104 <__sfvwrite_r+0x1f8>
 820b218:	0011883a 	mov	r8,zero
 820b21c:	003fdb06 	br	820b18c <__sfvwrite_r+0x280>
 820b220:	94c0012e 	bgeu	r18,r19,820b228 <__sfvwrite_r+0x31c>
 820b224:	9027883a 	mov	r19,r18
 820b228:	980d883a 	mov	r6,r19
 820b22c:	e00b883a 	mov	r5,fp
 820b230:	8202b540 	call	8202b54 <memmove>
 820b234:	80800217 	ldw	r2,8(r16)
 820b238:	80c00017 	ldw	r3,0(r16)
 820b23c:	14c5c83a 	sub	r2,r2,r19
 820b240:	1cc7883a 	add	r3,r3,r19
 820b244:	80800215 	stw	r2,8(r16)
 820b248:	80c00015 	stw	r3,0(r16)
 820b24c:	10004326 	beq	r2,zero,820b35c <__sfvwrite_r+0x450>
 820b250:	9805883a 	mov	r2,r19
 820b254:	003f8606 	br	820b070 <__sfvwrite_r+0x164>
 820b258:	b00d883a 	mov	r6,r22
 820b25c:	e00b883a 	mov	r5,fp
 820b260:	da000115 	stw	r8,4(sp)
 820b264:	8202b540 	call	8202b54 <memmove>
 820b268:	80800217 	ldw	r2,8(r16)
 820b26c:	80c00017 	ldw	r3,0(r16)
 820b270:	da000117 	ldw	r8,4(sp)
 820b274:	1585c83a 	sub	r2,r2,r22
 820b278:	1dad883a 	add	r22,r3,r22
 820b27c:	80800215 	stw	r2,8(r16)
 820b280:	85800015 	stw	r22,0(r16)
 820b284:	003fbf06 	br	820b184 <__sfvwrite_r+0x278>
 820b288:	81000017 	ldw	r4,0(r16)
 820b28c:	9027883a 	mov	r19,r18
 820b290:	902f883a 	mov	r23,r18
 820b294:	003f6c06 	br	820b048 <__sfvwrite_r+0x13c>
 820b298:	900d883a 	mov	r6,r18
 820b29c:	01400284 	movi	r5,10
 820b2a0:	e009883a 	mov	r4,fp
 820b2a4:	820bff40 	call	820bff4 <memchr>
 820b2a8:	10003e26 	beq	r2,zero,820b3a4 <__sfvwrite_r+0x498>
 820b2ac:	10800044 	addi	r2,r2,1
 820b2b0:	1727c83a 	sub	r19,r2,fp
 820b2b4:	02000044 	movi	r8,1
 820b2b8:	003f9d06 	br	820b130 <__sfvwrite_r+0x224>
 820b2bc:	80800517 	ldw	r2,20(r16)
 820b2c0:	81400417 	ldw	r5,16(r16)
 820b2c4:	81c00017 	ldw	r7,0(r16)
 820b2c8:	10a7883a 	add	r19,r2,r2
 820b2cc:	9885883a 	add	r2,r19,r2
 820b2d0:	1026d7fa 	srli	r19,r2,31
 820b2d4:	396dc83a 	sub	r22,r7,r5
 820b2d8:	b1000044 	addi	r4,r22,1
 820b2dc:	9885883a 	add	r2,r19,r2
 820b2e0:	1027d07a 	srai	r19,r2,1
 820b2e4:	2485883a 	add	r2,r4,r18
 820b2e8:	980d883a 	mov	r6,r19
 820b2ec:	9880022e 	bgeu	r19,r2,820b2f8 <__sfvwrite_r+0x3ec>
 820b2f0:	1027883a 	mov	r19,r2
 820b2f4:	100d883a 	mov	r6,r2
 820b2f8:	18c1000c 	andi	r3,r3,1024
 820b2fc:	18001c26 	beq	r3,zero,820b370 <__sfvwrite_r+0x464>
 820b300:	300b883a 	mov	r5,r6
 820b304:	a809883a 	mov	r4,r21
 820b308:	820b7e80 	call	820b7e8 <_malloc_r>
 820b30c:	102f883a 	mov	r23,r2
 820b310:	10002926 	beq	r2,zero,820b3b8 <__sfvwrite_r+0x4ac>
 820b314:	81400417 	ldw	r5,16(r16)
 820b318:	b00d883a 	mov	r6,r22
 820b31c:	1009883a 	mov	r4,r2
 820b320:	8202a0c0 	call	8202a0c <memcpy>
 820b324:	8080030b 	ldhu	r2,12(r16)
 820b328:	00fedfc4 	movi	r3,-1153
 820b32c:	10c4703a 	and	r2,r2,r3
 820b330:	10802014 	ori	r2,r2,128
 820b334:	8080030d 	sth	r2,12(r16)
 820b338:	bd89883a 	add	r4,r23,r22
 820b33c:	9d8fc83a 	sub	r7,r19,r22
 820b340:	85c00415 	stw	r23,16(r16)
 820b344:	84c00515 	stw	r19,20(r16)
 820b348:	81000015 	stw	r4,0(r16)
 820b34c:	9027883a 	mov	r19,r18
 820b350:	81c00215 	stw	r7,8(r16)
 820b354:	902f883a 	mov	r23,r18
 820b358:	003f3b06 	br	820b048 <__sfvwrite_r+0x13c>
 820b35c:	800b883a 	mov	r5,r16
 820b360:	a809883a 	mov	r4,r21
 820b364:	820a5580 	call	820a558 <_fflush_r>
 820b368:	103fb926 	beq	r2,zero,820b250 <__sfvwrite_r+0x344>
 820b36c:	003f6506 	br	820b104 <__sfvwrite_r+0x1f8>
 820b370:	a809883a 	mov	r4,r21
 820b374:	820d1500 	call	820d150 <_realloc_r>
 820b378:	102f883a 	mov	r23,r2
 820b37c:	103fee1e 	bne	r2,zero,820b338 <__sfvwrite_r+0x42c>
 820b380:	81400417 	ldw	r5,16(r16)
 820b384:	a809883a 	mov	r4,r21
 820b388:	820abfc0 	call	820abfc <_free_r>
 820b38c:	8080030b 	ldhu	r2,12(r16)
 820b390:	00ffdfc4 	movi	r3,-129
 820b394:	1884703a 	and	r2,r3,r2
 820b398:	00c00304 	movi	r3,12
 820b39c:	a8c00015 	stw	r3,0(r21)
 820b3a0:	003f5906 	br	820b108 <__sfvwrite_r+0x1fc>
 820b3a4:	94c00044 	addi	r19,r18,1
 820b3a8:	02000044 	movi	r8,1
 820b3ac:	003f6006 	br	820b130 <__sfvwrite_r+0x224>
 820b3b0:	00bfffc4 	movi	r2,-1
 820b3b4:	003f0306 	br	820afc4 <__sfvwrite_r+0xb8>
 820b3b8:	00800304 	movi	r2,12
 820b3bc:	a8800015 	stw	r2,0(r21)
 820b3c0:	8080030b 	ldhu	r2,12(r16)
 820b3c4:	003f5006 	br	820b108 <__sfvwrite_r+0x1fc>

0820b3c8 <_fwalk>:
 820b3c8:	defff704 	addi	sp,sp,-36
 820b3cc:	dd000415 	stw	r20,16(sp)
 820b3d0:	dfc00815 	stw	ra,32(sp)
 820b3d4:	ddc00715 	stw	r23,28(sp)
 820b3d8:	dd800615 	stw	r22,24(sp)
 820b3dc:	dd400515 	stw	r21,20(sp)
 820b3e0:	dcc00315 	stw	r19,12(sp)
 820b3e4:	dc800215 	stw	r18,8(sp)
 820b3e8:	dc400115 	stw	r17,4(sp)
 820b3ec:	dc000015 	stw	r16,0(sp)
 820b3f0:	2500b804 	addi	r20,r4,736
 820b3f4:	a0002326 	beq	r20,zero,820b484 <_fwalk+0xbc>
 820b3f8:	282b883a 	mov	r21,r5
 820b3fc:	002f883a 	mov	r23,zero
 820b400:	05800044 	movi	r22,1
 820b404:	04ffffc4 	movi	r19,-1
 820b408:	a4400117 	ldw	r17,4(r20)
 820b40c:	a4800217 	ldw	r18,8(r20)
 820b410:	8c7fffc4 	addi	r17,r17,-1
 820b414:	88000d16 	blt	r17,zero,820b44c <_fwalk+0x84>
 820b418:	94000304 	addi	r16,r18,12
 820b41c:	94800384 	addi	r18,r18,14
 820b420:	8080000b 	ldhu	r2,0(r16)
 820b424:	8c7fffc4 	addi	r17,r17,-1
 820b428:	813ffd04 	addi	r4,r16,-12
 820b42c:	b080042e 	bgeu	r22,r2,820b440 <_fwalk+0x78>
 820b430:	9080000f 	ldh	r2,0(r18)
 820b434:	14c00226 	beq	r2,r19,820b440 <_fwalk+0x78>
 820b438:	a83ee83a 	callr	r21
 820b43c:	b8aeb03a 	or	r23,r23,r2
 820b440:	84001a04 	addi	r16,r16,104
 820b444:	94801a04 	addi	r18,r18,104
 820b448:	8cfff51e 	bne	r17,r19,820b420 <_fwalk+0x58>
 820b44c:	a5000017 	ldw	r20,0(r20)
 820b450:	a03fed1e 	bne	r20,zero,820b408 <_fwalk+0x40>
 820b454:	b805883a 	mov	r2,r23
 820b458:	dfc00817 	ldw	ra,32(sp)
 820b45c:	ddc00717 	ldw	r23,28(sp)
 820b460:	dd800617 	ldw	r22,24(sp)
 820b464:	dd400517 	ldw	r21,20(sp)
 820b468:	dd000417 	ldw	r20,16(sp)
 820b46c:	dcc00317 	ldw	r19,12(sp)
 820b470:	dc800217 	ldw	r18,8(sp)
 820b474:	dc400117 	ldw	r17,4(sp)
 820b478:	dc000017 	ldw	r16,0(sp)
 820b47c:	dec00904 	addi	sp,sp,36
 820b480:	f800283a 	ret
 820b484:	002f883a 	mov	r23,zero
 820b488:	003ff206 	br	820b454 <_fwalk+0x8c>

0820b48c <_fwalk_reent>:
 820b48c:	defff704 	addi	sp,sp,-36
 820b490:	dd000415 	stw	r20,16(sp)
 820b494:	dfc00815 	stw	ra,32(sp)
 820b498:	ddc00715 	stw	r23,28(sp)
 820b49c:	dd800615 	stw	r22,24(sp)
 820b4a0:	dd400515 	stw	r21,20(sp)
 820b4a4:	dcc00315 	stw	r19,12(sp)
 820b4a8:	dc800215 	stw	r18,8(sp)
 820b4ac:	dc400115 	stw	r17,4(sp)
 820b4b0:	dc000015 	stw	r16,0(sp)
 820b4b4:	2500b804 	addi	r20,r4,736
 820b4b8:	a0002326 	beq	r20,zero,820b548 <_fwalk_reent+0xbc>
 820b4bc:	282b883a 	mov	r21,r5
 820b4c0:	2027883a 	mov	r19,r4
 820b4c4:	002f883a 	mov	r23,zero
 820b4c8:	05800044 	movi	r22,1
 820b4cc:	04bfffc4 	movi	r18,-1
 820b4d0:	a4400117 	ldw	r17,4(r20)
 820b4d4:	a4000217 	ldw	r16,8(r20)
 820b4d8:	8c7fffc4 	addi	r17,r17,-1
 820b4dc:	88000c16 	blt	r17,zero,820b510 <_fwalk_reent+0x84>
 820b4e0:	84000304 	addi	r16,r16,12
 820b4e4:	8080000b 	ldhu	r2,0(r16)
 820b4e8:	8c7fffc4 	addi	r17,r17,-1
 820b4ec:	817ffd04 	addi	r5,r16,-12
 820b4f0:	b080052e 	bgeu	r22,r2,820b508 <_fwalk_reent+0x7c>
 820b4f4:	8080008f 	ldh	r2,2(r16)
 820b4f8:	9809883a 	mov	r4,r19
 820b4fc:	14800226 	beq	r2,r18,820b508 <_fwalk_reent+0x7c>
 820b500:	a83ee83a 	callr	r21
 820b504:	b8aeb03a 	or	r23,r23,r2
 820b508:	84001a04 	addi	r16,r16,104
 820b50c:	8cbff51e 	bne	r17,r18,820b4e4 <_fwalk_reent+0x58>
 820b510:	a5000017 	ldw	r20,0(r20)
 820b514:	a03fee1e 	bne	r20,zero,820b4d0 <_fwalk_reent+0x44>
 820b518:	b805883a 	mov	r2,r23
 820b51c:	dfc00817 	ldw	ra,32(sp)
 820b520:	ddc00717 	ldw	r23,28(sp)
 820b524:	dd800617 	ldw	r22,24(sp)
 820b528:	dd400517 	ldw	r21,20(sp)
 820b52c:	dd000417 	ldw	r20,16(sp)
 820b530:	dcc00317 	ldw	r19,12(sp)
 820b534:	dc800217 	ldw	r18,8(sp)
 820b538:	dc400117 	ldw	r17,4(sp)
 820b53c:	dc000017 	ldw	r16,0(sp)
 820b540:	dec00904 	addi	sp,sp,36
 820b544:	f800283a 	ret
 820b548:	002f883a 	mov	r23,zero
 820b54c:	003ff206 	br	820b518 <_fwalk_reent+0x8c>

0820b550 <_setlocale_r>:
 820b550:	30001b26 	beq	r6,zero,820b5c0 <_setlocale_r+0x70>
 820b554:	01420974 	movhi	r5,2085
 820b558:	defffe04 	addi	sp,sp,-8
 820b55c:	29757604 	addi	r5,r5,-10792
 820b560:	3009883a 	mov	r4,r6
 820b564:	dc000015 	stw	r16,0(sp)
 820b568:	dfc00115 	stw	ra,4(sp)
 820b56c:	3021883a 	mov	r16,r6
 820b570:	820daa80 	call	820daa8 <strcmp>
 820b574:	1000061e 	bne	r2,zero,820b590 <_setlocale_r+0x40>
 820b578:	00820974 	movhi	r2,2085
 820b57c:	10b38e04 	addi	r2,r2,-12744
 820b580:	dfc00117 	ldw	ra,4(sp)
 820b584:	dc000017 	ldw	r16,0(sp)
 820b588:	dec00204 	addi	sp,sp,8
 820b58c:	f800283a 	ret
 820b590:	01420974 	movhi	r5,2085
 820b594:	29738e04 	addi	r5,r5,-12744
 820b598:	8009883a 	mov	r4,r16
 820b59c:	820daa80 	call	820daa8 <strcmp>
 820b5a0:	103ff526 	beq	r2,zero,820b578 <_setlocale_r+0x28>
 820b5a4:	01420974 	movhi	r5,2085
 820b5a8:	29755904 	addi	r5,r5,-10908
 820b5ac:	8009883a 	mov	r4,r16
 820b5b0:	820daa80 	call	820daa8 <strcmp>
 820b5b4:	103ff026 	beq	r2,zero,820b578 <_setlocale_r+0x28>
 820b5b8:	0005883a 	mov	r2,zero
 820b5bc:	003ff006 	br	820b580 <_setlocale_r+0x30>
 820b5c0:	00820974 	movhi	r2,2085
 820b5c4:	10b38e04 	addi	r2,r2,-12744
 820b5c8:	f800283a 	ret

0820b5cc <__locale_charset>:
 820b5cc:	00820974 	movhi	r2,2085
 820b5d0:	1087a804 	addi	r2,r2,7840
 820b5d4:	f800283a 	ret

0820b5d8 <__locale_mb_cur_max>:
 820b5d8:	00820974 	movhi	r2,2085
 820b5dc:	108e3104 	addi	r2,r2,14532
 820b5e0:	10800017 	ldw	r2,0(r2)
 820b5e4:	f800283a 	ret

0820b5e8 <__locale_msgcharset>:
 820b5e8:	00820974 	movhi	r2,2085
 820b5ec:	1087a004 	addi	r2,r2,7808
 820b5f0:	f800283a 	ret

0820b5f4 <__locale_cjk_lang>:
 820b5f4:	0005883a 	mov	r2,zero
 820b5f8:	f800283a 	ret

0820b5fc <_localeconv_r>:
 820b5fc:	00820974 	movhi	r2,2085
 820b600:	1087b004 	addi	r2,r2,7872
 820b604:	f800283a 	ret

0820b608 <setlocale>:
 820b608:	00820974 	movhi	r2,2085
 820b60c:	108e3004 	addi	r2,r2,14528
 820b610:	280d883a 	mov	r6,r5
 820b614:	200b883a 	mov	r5,r4
 820b618:	11000017 	ldw	r4,0(r2)
 820b61c:	820b5501 	jmpi	820b550 <_setlocale_r>

0820b620 <localeconv>:
 820b620:	00820974 	movhi	r2,2085
 820b624:	1087b004 	addi	r2,r2,7872
 820b628:	f800283a 	ret

0820b62c <__smakebuf_r>:
 820b62c:	2880030b 	ldhu	r2,12(r5)
 820b630:	10c0008c 	andi	r3,r2,2
 820b634:	1800411e 	bne	r3,zero,820b73c <__smakebuf_r+0x110>
 820b638:	deffec04 	addi	sp,sp,-80
 820b63c:	dc000f15 	stw	r16,60(sp)
 820b640:	2821883a 	mov	r16,r5
 820b644:	2940038f 	ldh	r5,14(r5)
 820b648:	dc401015 	stw	r17,64(sp)
 820b64c:	dfc01315 	stw	ra,76(sp)
 820b650:	dcc01215 	stw	r19,72(sp)
 820b654:	dc801115 	stw	r18,68(sp)
 820b658:	2023883a 	mov	r17,r4
 820b65c:	28001c16 	blt	r5,zero,820b6d0 <__smakebuf_r+0xa4>
 820b660:	d80d883a 	mov	r6,sp
 820b664:	8210a5c0 	call	8210a5c <_fstat_r>
 820b668:	10001816 	blt	r2,zero,820b6cc <__smakebuf_r+0xa0>
 820b66c:	d8800117 	ldw	r2,4(sp)
 820b670:	00e00014 	movui	r3,32768
 820b674:	10bc000c 	andi	r2,r2,61440
 820b678:	14c80020 	cmpeqi	r19,r2,8192
 820b67c:	10c03726 	beq	r2,r3,820b75c <__smakebuf_r+0x130>
 820b680:	80c0030b 	ldhu	r3,12(r16)
 820b684:	18c20014 	ori	r3,r3,2048
 820b688:	80c0030d 	sth	r3,12(r16)
 820b68c:	00c80004 	movi	r3,8192
 820b690:	10c0521e 	bne	r2,r3,820b7dc <__smakebuf_r+0x1b0>
 820b694:	8140038f 	ldh	r5,14(r16)
 820b698:	8809883a 	mov	r4,r17
 820b69c:	8210ab80 	call	8210ab8 <_isatty_r>
 820b6a0:	10004c26 	beq	r2,zero,820b7d4 <__smakebuf_r+0x1a8>
 820b6a4:	8080030b 	ldhu	r2,12(r16)
 820b6a8:	80c010c4 	addi	r3,r16,67
 820b6ac:	80c00015 	stw	r3,0(r16)
 820b6b0:	10800054 	ori	r2,r2,1
 820b6b4:	8080030d 	sth	r2,12(r16)
 820b6b8:	00800044 	movi	r2,1
 820b6bc:	80c00415 	stw	r3,16(r16)
 820b6c0:	80800515 	stw	r2,20(r16)
 820b6c4:	04810004 	movi	r18,1024
 820b6c8:	00000706 	br	820b6e8 <__smakebuf_r+0xbc>
 820b6cc:	8080030b 	ldhu	r2,12(r16)
 820b6d0:	10c0200c 	andi	r3,r2,128
 820b6d4:	18001f1e 	bne	r3,zero,820b754 <__smakebuf_r+0x128>
 820b6d8:	04810004 	movi	r18,1024
 820b6dc:	10820014 	ori	r2,r2,2048
 820b6e0:	8080030d 	sth	r2,12(r16)
 820b6e4:	0027883a 	mov	r19,zero
 820b6e8:	900b883a 	mov	r5,r18
 820b6ec:	8809883a 	mov	r4,r17
 820b6f0:	820b7e80 	call	820b7e8 <_malloc_r>
 820b6f4:	10002c26 	beq	r2,zero,820b7a8 <__smakebuf_r+0x17c>
 820b6f8:	80c0030b 	ldhu	r3,12(r16)
 820b6fc:	01020874 	movhi	r4,2081
 820b700:	21297b04 	addi	r4,r4,-23060
 820b704:	89000f15 	stw	r4,60(r17)
 820b708:	18c02014 	ori	r3,r3,128
 820b70c:	80c0030d 	sth	r3,12(r16)
 820b710:	80800015 	stw	r2,0(r16)
 820b714:	80800415 	stw	r2,16(r16)
 820b718:	84800515 	stw	r18,20(r16)
 820b71c:	98001a1e 	bne	r19,zero,820b788 <__smakebuf_r+0x15c>
 820b720:	dfc01317 	ldw	ra,76(sp)
 820b724:	dcc01217 	ldw	r19,72(sp)
 820b728:	dc801117 	ldw	r18,68(sp)
 820b72c:	dc401017 	ldw	r17,64(sp)
 820b730:	dc000f17 	ldw	r16,60(sp)
 820b734:	dec01404 	addi	sp,sp,80
 820b738:	f800283a 	ret
 820b73c:	288010c4 	addi	r2,r5,67
 820b740:	28800015 	stw	r2,0(r5)
 820b744:	28800415 	stw	r2,16(r5)
 820b748:	00800044 	movi	r2,1
 820b74c:	28800515 	stw	r2,20(r5)
 820b750:	f800283a 	ret
 820b754:	04801004 	movi	r18,64
 820b758:	003fe006 	br	820b6dc <__smakebuf_r+0xb0>
 820b75c:	81000a17 	ldw	r4,40(r16)
 820b760:	00c20874 	movhi	r3,2081
 820b764:	18f69104 	addi	r3,r3,-9660
 820b768:	20ffc51e 	bne	r4,r3,820b680 <__smakebuf_r+0x54>
 820b76c:	8080030b 	ldhu	r2,12(r16)
 820b770:	04810004 	movi	r18,1024
 820b774:	84801315 	stw	r18,76(r16)
 820b778:	1484b03a 	or	r2,r2,r18
 820b77c:	8080030d 	sth	r2,12(r16)
 820b780:	0027883a 	mov	r19,zero
 820b784:	003fd806 	br	820b6e8 <__smakebuf_r+0xbc>
 820b788:	8140038f 	ldh	r5,14(r16)
 820b78c:	8809883a 	mov	r4,r17
 820b790:	8210ab80 	call	8210ab8 <_isatty_r>
 820b794:	103fe226 	beq	r2,zero,820b720 <__smakebuf_r+0xf4>
 820b798:	8080030b 	ldhu	r2,12(r16)
 820b79c:	10800054 	ori	r2,r2,1
 820b7a0:	8080030d 	sth	r2,12(r16)
 820b7a4:	003fde06 	br	820b720 <__smakebuf_r+0xf4>
 820b7a8:	8080030b 	ldhu	r2,12(r16)
 820b7ac:	10c0800c 	andi	r3,r2,512
 820b7b0:	183fdb1e 	bne	r3,zero,820b720 <__smakebuf_r+0xf4>
 820b7b4:	10800094 	ori	r2,r2,2
 820b7b8:	80c010c4 	addi	r3,r16,67
 820b7bc:	8080030d 	sth	r2,12(r16)
 820b7c0:	00800044 	movi	r2,1
 820b7c4:	80c00015 	stw	r3,0(r16)
 820b7c8:	80c00415 	stw	r3,16(r16)
 820b7cc:	80800515 	stw	r2,20(r16)
 820b7d0:	003fd306 	br	820b720 <__smakebuf_r+0xf4>
 820b7d4:	04810004 	movi	r18,1024
 820b7d8:	003fc306 	br	820b6e8 <__smakebuf_r+0xbc>
 820b7dc:	0027883a 	mov	r19,zero
 820b7e0:	04810004 	movi	r18,1024
 820b7e4:	003fc006 	br	820b6e8 <__smakebuf_r+0xbc>

0820b7e8 <_malloc_r>:
 820b7e8:	defff504 	addi	sp,sp,-44
 820b7ec:	dc800315 	stw	r18,12(sp)
 820b7f0:	dfc00a15 	stw	ra,40(sp)
 820b7f4:	df000915 	stw	fp,36(sp)
 820b7f8:	ddc00815 	stw	r23,32(sp)
 820b7fc:	dd800715 	stw	r22,28(sp)
 820b800:	dd400615 	stw	r21,24(sp)
 820b804:	dd000515 	stw	r20,20(sp)
 820b808:	dcc00415 	stw	r19,16(sp)
 820b80c:	dc400215 	stw	r17,8(sp)
 820b810:	dc000115 	stw	r16,4(sp)
 820b814:	288002c4 	addi	r2,r5,11
 820b818:	00c00584 	movi	r3,22
 820b81c:	2025883a 	mov	r18,r4
 820b820:	18807f2e 	bgeu	r3,r2,820ba20 <_malloc_r+0x238>
 820b824:	047ffe04 	movi	r17,-8
 820b828:	1462703a 	and	r17,r2,r17
 820b82c:	8800a316 	blt	r17,zero,820babc <_malloc_r+0x2d4>
 820b830:	8940a236 	bltu	r17,r5,820babc <_malloc_r+0x2d4>
 820b834:	821462c0 	call	821462c <__malloc_lock>
 820b838:	00807dc4 	movi	r2,503
 820b83c:	1441e92e 	bgeu	r2,r17,820bfe4 <_malloc_r+0x7fc>
 820b840:	8804d27a 	srli	r2,r17,9
 820b844:	1000a126 	beq	r2,zero,820bacc <_malloc_r+0x2e4>
 820b848:	00c00104 	movi	r3,4
 820b84c:	18811e36 	bltu	r3,r2,820bcc8 <_malloc_r+0x4e0>
 820b850:	8804d1ba 	srli	r2,r17,6
 820b854:	12000e44 	addi	r8,r2,57
 820b858:	11c00e04 	addi	r7,r2,56
 820b85c:	4209883a 	add	r4,r8,r8
 820b860:	04c20974 	movhi	r19,2085
 820b864:	2109883a 	add	r4,r4,r4
 820b868:	9cc7be04 	addi	r19,r19,7928
 820b86c:	2109883a 	add	r4,r4,r4
 820b870:	9909883a 	add	r4,r19,r4
 820b874:	24000117 	ldw	r16,4(r4)
 820b878:	213ffe04 	addi	r4,r4,-8
 820b87c:	24009726 	beq	r4,r16,820badc <_malloc_r+0x2f4>
 820b880:	80800117 	ldw	r2,4(r16)
 820b884:	01bfff04 	movi	r6,-4
 820b888:	014003c4 	movi	r5,15
 820b88c:	1184703a 	and	r2,r2,r6
 820b890:	1447c83a 	sub	r3,r2,r17
 820b894:	28c00716 	blt	r5,r3,820b8b4 <_malloc_r+0xcc>
 820b898:	1800920e 	bge	r3,zero,820bae4 <_malloc_r+0x2fc>
 820b89c:	84000317 	ldw	r16,12(r16)
 820b8a0:	24008e26 	beq	r4,r16,820badc <_malloc_r+0x2f4>
 820b8a4:	80800117 	ldw	r2,4(r16)
 820b8a8:	1184703a 	and	r2,r2,r6
 820b8ac:	1447c83a 	sub	r3,r2,r17
 820b8b0:	28fff90e 	bge	r5,r3,820b898 <_malloc_r+0xb0>
 820b8b4:	3809883a 	mov	r4,r7
 820b8b8:	01820974 	movhi	r6,2085
 820b8bc:	9c000417 	ldw	r16,16(r19)
 820b8c0:	3187be04 	addi	r6,r6,7928
 820b8c4:	32000204 	addi	r8,r6,8
 820b8c8:	82013426 	beq	r16,r8,820bd9c <_malloc_r+0x5b4>
 820b8cc:	80c00117 	ldw	r3,4(r16)
 820b8d0:	00bfff04 	movi	r2,-4
 820b8d4:	188e703a 	and	r7,r3,r2
 820b8d8:	3c45c83a 	sub	r2,r7,r17
 820b8dc:	00c003c4 	movi	r3,15
 820b8e0:	18811f16 	blt	r3,r2,820bd60 <_malloc_r+0x578>
 820b8e4:	32000515 	stw	r8,20(r6)
 820b8e8:	32000415 	stw	r8,16(r6)
 820b8ec:	10007f0e 	bge	r2,zero,820baec <_malloc_r+0x304>
 820b8f0:	00807fc4 	movi	r2,511
 820b8f4:	11c0fd36 	bltu	r2,r7,820bcec <_malloc_r+0x504>
 820b8f8:	3806d0fa 	srli	r3,r7,3
 820b8fc:	01c00044 	movi	r7,1
 820b900:	30800117 	ldw	r2,4(r6)
 820b904:	19400044 	addi	r5,r3,1
 820b908:	294b883a 	add	r5,r5,r5
 820b90c:	1807d0ba 	srai	r3,r3,2
 820b910:	294b883a 	add	r5,r5,r5
 820b914:	294b883a 	add	r5,r5,r5
 820b918:	298b883a 	add	r5,r5,r6
 820b91c:	38c6983a 	sll	r3,r7,r3
 820b920:	29c00017 	ldw	r7,0(r5)
 820b924:	2a7ffe04 	addi	r9,r5,-8
 820b928:	1886b03a 	or	r3,r3,r2
 820b92c:	82400315 	stw	r9,12(r16)
 820b930:	81c00215 	stw	r7,8(r16)
 820b934:	30c00115 	stw	r3,4(r6)
 820b938:	2c000015 	stw	r16,0(r5)
 820b93c:	3c000315 	stw	r16,12(r7)
 820b940:	2005d0ba 	srai	r2,r4,2
 820b944:	01400044 	movi	r5,1
 820b948:	288a983a 	sll	r5,r5,r2
 820b94c:	19406f36 	bltu	r3,r5,820bb0c <_malloc_r+0x324>
 820b950:	28c4703a 	and	r2,r5,r3
 820b954:	10000a1e 	bne	r2,zero,820b980 <_malloc_r+0x198>
 820b958:	00bfff04 	movi	r2,-4
 820b95c:	294b883a 	add	r5,r5,r5
 820b960:	2088703a 	and	r4,r4,r2
 820b964:	28c4703a 	and	r2,r5,r3
 820b968:	21000104 	addi	r4,r4,4
 820b96c:	1000041e 	bne	r2,zero,820b980 <_malloc_r+0x198>
 820b970:	294b883a 	add	r5,r5,r5
 820b974:	28c4703a 	and	r2,r5,r3
 820b978:	21000104 	addi	r4,r4,4
 820b97c:	103ffc26 	beq	r2,zero,820b970 <_malloc_r+0x188>
 820b980:	02bfff04 	movi	r10,-4
 820b984:	024003c4 	movi	r9,15
 820b988:	21800044 	addi	r6,r4,1
 820b98c:	318d883a 	add	r6,r6,r6
 820b990:	318d883a 	add	r6,r6,r6
 820b994:	318d883a 	add	r6,r6,r6
 820b998:	998d883a 	add	r6,r19,r6
 820b99c:	333ffe04 	addi	r12,r6,-8
 820b9a0:	2017883a 	mov	r11,r4
 820b9a4:	31800104 	addi	r6,r6,4
 820b9a8:	34000017 	ldw	r16,0(r6)
 820b9ac:	31fffd04 	addi	r7,r6,-12
 820b9b0:	81c0041e 	bne	r16,r7,820b9c4 <_malloc_r+0x1dc>
 820b9b4:	0000fb06 	br	820bda4 <_malloc_r+0x5bc>
 820b9b8:	1801030e 	bge	r3,zero,820bdc8 <_malloc_r+0x5e0>
 820b9bc:	84000317 	ldw	r16,12(r16)
 820b9c0:	81c0f826 	beq	r16,r7,820bda4 <_malloc_r+0x5bc>
 820b9c4:	80800117 	ldw	r2,4(r16)
 820b9c8:	1284703a 	and	r2,r2,r10
 820b9cc:	1447c83a 	sub	r3,r2,r17
 820b9d0:	48fff90e 	bge	r9,r3,820b9b8 <_malloc_r+0x1d0>
 820b9d4:	80800317 	ldw	r2,12(r16)
 820b9d8:	81000217 	ldw	r4,8(r16)
 820b9dc:	89400054 	ori	r5,r17,1
 820b9e0:	81400115 	stw	r5,4(r16)
 820b9e4:	20800315 	stw	r2,12(r4)
 820b9e8:	11000215 	stw	r4,8(r2)
 820b9ec:	8463883a 	add	r17,r16,r17
 820b9f0:	9c400515 	stw	r17,20(r19)
 820b9f4:	9c400415 	stw	r17,16(r19)
 820b9f8:	18800054 	ori	r2,r3,1
 820b9fc:	88800115 	stw	r2,4(r17)
 820ba00:	8a000315 	stw	r8,12(r17)
 820ba04:	8a000215 	stw	r8,8(r17)
 820ba08:	88e3883a 	add	r17,r17,r3
 820ba0c:	88c00015 	stw	r3,0(r17)
 820ba10:	9009883a 	mov	r4,r18
 820ba14:	821474c0 	call	821474c <__malloc_unlock>
 820ba18:	80800204 	addi	r2,r16,8
 820ba1c:	00001b06 	br	820ba8c <_malloc_r+0x2a4>
 820ba20:	04400404 	movi	r17,16
 820ba24:	89402536 	bltu	r17,r5,820babc <_malloc_r+0x2d4>
 820ba28:	821462c0 	call	821462c <__malloc_lock>
 820ba2c:	00800184 	movi	r2,6
 820ba30:	01000084 	movi	r4,2
 820ba34:	04c20974 	movhi	r19,2085
 820ba38:	1085883a 	add	r2,r2,r2
 820ba3c:	9cc7be04 	addi	r19,r19,7928
 820ba40:	1085883a 	add	r2,r2,r2
 820ba44:	9885883a 	add	r2,r19,r2
 820ba48:	14000117 	ldw	r16,4(r2)
 820ba4c:	10fffe04 	addi	r3,r2,-8
 820ba50:	80c0d926 	beq	r16,r3,820bdb8 <_malloc_r+0x5d0>
 820ba54:	80c00117 	ldw	r3,4(r16)
 820ba58:	81000317 	ldw	r4,12(r16)
 820ba5c:	00bfff04 	movi	r2,-4
 820ba60:	1884703a 	and	r2,r3,r2
 820ba64:	81400217 	ldw	r5,8(r16)
 820ba68:	8085883a 	add	r2,r16,r2
 820ba6c:	10c00117 	ldw	r3,4(r2)
 820ba70:	29000315 	stw	r4,12(r5)
 820ba74:	21400215 	stw	r5,8(r4)
 820ba78:	18c00054 	ori	r3,r3,1
 820ba7c:	10c00115 	stw	r3,4(r2)
 820ba80:	9009883a 	mov	r4,r18
 820ba84:	821474c0 	call	821474c <__malloc_unlock>
 820ba88:	80800204 	addi	r2,r16,8
 820ba8c:	dfc00a17 	ldw	ra,40(sp)
 820ba90:	df000917 	ldw	fp,36(sp)
 820ba94:	ddc00817 	ldw	r23,32(sp)
 820ba98:	dd800717 	ldw	r22,28(sp)
 820ba9c:	dd400617 	ldw	r21,24(sp)
 820baa0:	dd000517 	ldw	r20,20(sp)
 820baa4:	dcc00417 	ldw	r19,16(sp)
 820baa8:	dc800317 	ldw	r18,12(sp)
 820baac:	dc400217 	ldw	r17,8(sp)
 820bab0:	dc000117 	ldw	r16,4(sp)
 820bab4:	dec00b04 	addi	sp,sp,44
 820bab8:	f800283a 	ret
 820babc:	00800304 	movi	r2,12
 820bac0:	90800015 	stw	r2,0(r18)
 820bac4:	0005883a 	mov	r2,zero
 820bac8:	003ff006 	br	820ba8c <_malloc_r+0x2a4>
 820bacc:	01002004 	movi	r4,128
 820bad0:	02001004 	movi	r8,64
 820bad4:	01c00fc4 	movi	r7,63
 820bad8:	003f6106 	br	820b860 <_malloc_r+0x78>
 820badc:	4009883a 	mov	r4,r8
 820bae0:	003f7506 	br	820b8b8 <_malloc_r+0xd0>
 820bae4:	81000317 	ldw	r4,12(r16)
 820bae8:	003fde06 	br	820ba64 <_malloc_r+0x27c>
 820baec:	81c5883a 	add	r2,r16,r7
 820baf0:	11400117 	ldw	r5,4(r2)
 820baf4:	9009883a 	mov	r4,r18
 820baf8:	29400054 	ori	r5,r5,1
 820bafc:	11400115 	stw	r5,4(r2)
 820bb00:	821474c0 	call	821474c <__malloc_unlock>
 820bb04:	80800204 	addi	r2,r16,8
 820bb08:	003fe006 	br	820ba8c <_malloc_r+0x2a4>
 820bb0c:	9c000217 	ldw	r16,8(r19)
 820bb10:	00bfff04 	movi	r2,-4
 820bb14:	85800117 	ldw	r22,4(r16)
 820bb18:	b0ac703a 	and	r22,r22,r2
 820bb1c:	b4400336 	bltu	r22,r17,820bb2c <_malloc_r+0x344>
 820bb20:	b445c83a 	sub	r2,r22,r17
 820bb24:	00c003c4 	movi	r3,15
 820bb28:	18805d16 	blt	r3,r2,820bca0 <_malloc_r+0x4b8>
 820bb2c:	05c20974 	movhi	r23,2085
 820bb30:	00820974 	movhi	r2,2085
 820bb34:	108e9004 	addi	r2,r2,14912
 820bb38:	bdce3204 	addi	r23,r23,14536
 820bb3c:	15400017 	ldw	r21,0(r2)
 820bb40:	b8c00017 	ldw	r3,0(r23)
 820bb44:	00bfffc4 	movi	r2,-1
 820bb48:	858d883a 	add	r6,r16,r22
 820bb4c:	8d6b883a 	add	r21,r17,r21
 820bb50:	1880ea26 	beq	r3,r2,820befc <_malloc_r+0x714>
 820bb54:	ad4403c4 	addi	r21,r21,4111
 820bb58:	00bc0004 	movi	r2,-4096
 820bb5c:	a8aa703a 	and	r21,r21,r2
 820bb60:	a80b883a 	mov	r5,r21
 820bb64:	9009883a 	mov	r4,r18
 820bb68:	d9800015 	stw	r6,0(sp)
 820bb6c:	820d9180 	call	820d918 <_sbrk_r>
 820bb70:	1029883a 	mov	r20,r2
 820bb74:	00bfffc4 	movi	r2,-1
 820bb78:	d9800017 	ldw	r6,0(sp)
 820bb7c:	a080e826 	beq	r20,r2,820bf20 <_malloc_r+0x738>
 820bb80:	a180a636 	bltu	r20,r6,820be1c <_malloc_r+0x634>
 820bb84:	07020974 	movhi	fp,2085
 820bb88:	e7108704 	addi	fp,fp,16924
 820bb8c:	e0800017 	ldw	r2,0(fp)
 820bb90:	a887883a 	add	r3,r21,r2
 820bb94:	e0c00015 	stw	r3,0(fp)
 820bb98:	3500e626 	beq	r6,r20,820bf34 <_malloc_r+0x74c>
 820bb9c:	b9000017 	ldw	r4,0(r23)
 820bba0:	00bfffc4 	movi	r2,-1
 820bba4:	2080ee26 	beq	r4,r2,820bf60 <_malloc_r+0x778>
 820bba8:	a185c83a 	sub	r2,r20,r6
 820bbac:	10c5883a 	add	r2,r2,r3
 820bbb0:	e0800015 	stw	r2,0(fp)
 820bbb4:	a0c001cc 	andi	r3,r20,7
 820bbb8:	1800bc26 	beq	r3,zero,820beac <_malloc_r+0x6c4>
 820bbbc:	a0e9c83a 	sub	r20,r20,r3
 820bbc0:	00840204 	movi	r2,4104
 820bbc4:	a5000204 	addi	r20,r20,8
 820bbc8:	10c7c83a 	sub	r3,r2,r3
 820bbcc:	a545883a 	add	r2,r20,r21
 820bbd0:	1083ffcc 	andi	r2,r2,4095
 820bbd4:	18abc83a 	sub	r21,r3,r2
 820bbd8:	a80b883a 	mov	r5,r21
 820bbdc:	9009883a 	mov	r4,r18
 820bbe0:	820d9180 	call	820d918 <_sbrk_r>
 820bbe4:	00ffffc4 	movi	r3,-1
 820bbe8:	10c0e126 	beq	r2,r3,820bf70 <_malloc_r+0x788>
 820bbec:	1505c83a 	sub	r2,r2,r20
 820bbf0:	1545883a 	add	r2,r2,r21
 820bbf4:	10800054 	ori	r2,r2,1
 820bbf8:	e0c00017 	ldw	r3,0(fp)
 820bbfc:	9d000215 	stw	r20,8(r19)
 820bc00:	a0800115 	stw	r2,4(r20)
 820bc04:	a8c7883a 	add	r3,r21,r3
 820bc08:	e0c00015 	stw	r3,0(fp)
 820bc0c:	84c00e26 	beq	r16,r19,820bc48 <_malloc_r+0x460>
 820bc10:	018003c4 	movi	r6,15
 820bc14:	3580a72e 	bgeu	r6,r22,820beb4 <_malloc_r+0x6cc>
 820bc18:	81400117 	ldw	r5,4(r16)
 820bc1c:	013ffe04 	movi	r4,-8
 820bc20:	b0bffd04 	addi	r2,r22,-12
 820bc24:	1104703a 	and	r2,r2,r4
 820bc28:	2900004c 	andi	r4,r5,1
 820bc2c:	2088b03a 	or	r4,r4,r2
 820bc30:	81000115 	stw	r4,4(r16)
 820bc34:	01400144 	movi	r5,5
 820bc38:	8089883a 	add	r4,r16,r2
 820bc3c:	21400115 	stw	r5,4(r4)
 820bc40:	21400215 	stw	r5,8(r4)
 820bc44:	3080cd36 	bltu	r6,r2,820bf7c <_malloc_r+0x794>
 820bc48:	00820974 	movhi	r2,2085
 820bc4c:	108e8f04 	addi	r2,r2,14908
 820bc50:	11000017 	ldw	r4,0(r2)
 820bc54:	20c0012e 	bgeu	r4,r3,820bc5c <_malloc_r+0x474>
 820bc58:	10c00015 	stw	r3,0(r2)
 820bc5c:	00820974 	movhi	r2,2085
 820bc60:	108e8e04 	addi	r2,r2,14904
 820bc64:	11000017 	ldw	r4,0(r2)
 820bc68:	9c000217 	ldw	r16,8(r19)
 820bc6c:	20c0012e 	bgeu	r4,r3,820bc74 <_malloc_r+0x48c>
 820bc70:	10c00015 	stw	r3,0(r2)
 820bc74:	80c00117 	ldw	r3,4(r16)
 820bc78:	00bfff04 	movi	r2,-4
 820bc7c:	1886703a 	and	r3,r3,r2
 820bc80:	1c45c83a 	sub	r2,r3,r17
 820bc84:	1c400236 	bltu	r3,r17,820bc90 <_malloc_r+0x4a8>
 820bc88:	00c003c4 	movi	r3,15
 820bc8c:	18800416 	blt	r3,r2,820bca0 <_malloc_r+0x4b8>
 820bc90:	9009883a 	mov	r4,r18
 820bc94:	821474c0 	call	821474c <__malloc_unlock>
 820bc98:	0005883a 	mov	r2,zero
 820bc9c:	003f7b06 	br	820ba8c <_malloc_r+0x2a4>
 820bca0:	88c00054 	ori	r3,r17,1
 820bca4:	80c00115 	stw	r3,4(r16)
 820bca8:	8463883a 	add	r17,r16,r17
 820bcac:	10800054 	ori	r2,r2,1
 820bcb0:	9c400215 	stw	r17,8(r19)
 820bcb4:	88800115 	stw	r2,4(r17)
 820bcb8:	9009883a 	mov	r4,r18
 820bcbc:	821474c0 	call	821474c <__malloc_unlock>
 820bcc0:	80800204 	addi	r2,r16,8
 820bcc4:	003f7106 	br	820ba8c <_malloc_r+0x2a4>
 820bcc8:	00c00504 	movi	r3,20
 820bccc:	18804a2e 	bgeu	r3,r2,820bdf8 <_malloc_r+0x610>
 820bcd0:	00c01504 	movi	r3,84
 820bcd4:	18806e36 	bltu	r3,r2,820be90 <_malloc_r+0x6a8>
 820bcd8:	8804d33a 	srli	r2,r17,12
 820bcdc:	12001bc4 	addi	r8,r2,111
 820bce0:	11c01b84 	addi	r7,r2,110
 820bce4:	4209883a 	add	r4,r8,r8
 820bce8:	003edd06 	br	820b860 <_malloc_r+0x78>
 820bcec:	3804d27a 	srli	r2,r7,9
 820bcf0:	00c00104 	movi	r3,4
 820bcf4:	1880442e 	bgeu	r3,r2,820be08 <_malloc_r+0x620>
 820bcf8:	00c00504 	movi	r3,20
 820bcfc:	18808136 	bltu	r3,r2,820bf04 <_malloc_r+0x71c>
 820bd00:	11401704 	addi	r5,r2,92
 820bd04:	10c016c4 	addi	r3,r2,91
 820bd08:	294b883a 	add	r5,r5,r5
 820bd0c:	294b883a 	add	r5,r5,r5
 820bd10:	294b883a 	add	r5,r5,r5
 820bd14:	994b883a 	add	r5,r19,r5
 820bd18:	28800017 	ldw	r2,0(r5)
 820bd1c:	01820974 	movhi	r6,2085
 820bd20:	297ffe04 	addi	r5,r5,-8
 820bd24:	3187be04 	addi	r6,r6,7928
 820bd28:	28806526 	beq	r5,r2,820bec0 <_malloc_r+0x6d8>
 820bd2c:	01bfff04 	movi	r6,-4
 820bd30:	10c00117 	ldw	r3,4(r2)
 820bd34:	1986703a 	and	r3,r3,r6
 820bd38:	38c0022e 	bgeu	r7,r3,820bd44 <_malloc_r+0x55c>
 820bd3c:	10800217 	ldw	r2,8(r2)
 820bd40:	28bffb1e 	bne	r5,r2,820bd30 <_malloc_r+0x548>
 820bd44:	11400317 	ldw	r5,12(r2)
 820bd48:	98c00117 	ldw	r3,4(r19)
 820bd4c:	81400315 	stw	r5,12(r16)
 820bd50:	80800215 	stw	r2,8(r16)
 820bd54:	2c000215 	stw	r16,8(r5)
 820bd58:	14000315 	stw	r16,12(r2)
 820bd5c:	003ef806 	br	820b940 <_malloc_r+0x158>
 820bd60:	88c00054 	ori	r3,r17,1
 820bd64:	80c00115 	stw	r3,4(r16)
 820bd68:	8463883a 	add	r17,r16,r17
 820bd6c:	34400515 	stw	r17,20(r6)
 820bd70:	34400415 	stw	r17,16(r6)
 820bd74:	10c00054 	ori	r3,r2,1
 820bd78:	8a000315 	stw	r8,12(r17)
 820bd7c:	8a000215 	stw	r8,8(r17)
 820bd80:	88c00115 	stw	r3,4(r17)
 820bd84:	88a3883a 	add	r17,r17,r2
 820bd88:	88800015 	stw	r2,0(r17)
 820bd8c:	9009883a 	mov	r4,r18
 820bd90:	821474c0 	call	821474c <__malloc_unlock>
 820bd94:	80800204 	addi	r2,r16,8
 820bd98:	003f3c06 	br	820ba8c <_malloc_r+0x2a4>
 820bd9c:	30c00117 	ldw	r3,4(r6)
 820bda0:	003ee706 	br	820b940 <_malloc_r+0x158>
 820bda4:	5ac00044 	addi	r11,r11,1
 820bda8:	588000cc 	andi	r2,r11,3
 820bdac:	31800204 	addi	r6,r6,8
 820bdb0:	103efd1e 	bne	r2,zero,820b9a8 <_malloc_r+0x1c0>
 820bdb4:	00002406 	br	820be48 <_malloc_r+0x660>
 820bdb8:	14000317 	ldw	r16,12(r2)
 820bdbc:	143f251e 	bne	r2,r16,820ba54 <_malloc_r+0x26c>
 820bdc0:	21000084 	addi	r4,r4,2
 820bdc4:	003ebc06 	br	820b8b8 <_malloc_r+0xd0>
 820bdc8:	8085883a 	add	r2,r16,r2
 820bdcc:	10c00117 	ldw	r3,4(r2)
 820bdd0:	81000317 	ldw	r4,12(r16)
 820bdd4:	81400217 	ldw	r5,8(r16)
 820bdd8:	18c00054 	ori	r3,r3,1
 820bddc:	10c00115 	stw	r3,4(r2)
 820bde0:	29000315 	stw	r4,12(r5)
 820bde4:	21400215 	stw	r5,8(r4)
 820bde8:	9009883a 	mov	r4,r18
 820bdec:	821474c0 	call	821474c <__malloc_unlock>
 820bdf0:	80800204 	addi	r2,r16,8
 820bdf4:	003f2506 	br	820ba8c <_malloc_r+0x2a4>
 820bdf8:	12001704 	addi	r8,r2,92
 820bdfc:	11c016c4 	addi	r7,r2,91
 820be00:	4209883a 	add	r4,r8,r8
 820be04:	003e9606 	br	820b860 <_malloc_r+0x78>
 820be08:	3804d1ba 	srli	r2,r7,6
 820be0c:	11400e44 	addi	r5,r2,57
 820be10:	10c00e04 	addi	r3,r2,56
 820be14:	294b883a 	add	r5,r5,r5
 820be18:	003fbc06 	br	820bd0c <_malloc_r+0x524>
 820be1c:	84ff5926 	beq	r16,r19,820bb84 <_malloc_r+0x39c>
 820be20:	00820974 	movhi	r2,2085
 820be24:	1087be04 	addi	r2,r2,7928
 820be28:	14000217 	ldw	r16,8(r2)
 820be2c:	00bfff04 	movi	r2,-4
 820be30:	80c00117 	ldw	r3,4(r16)
 820be34:	1886703a 	and	r3,r3,r2
 820be38:	003f9106 	br	820bc80 <_malloc_r+0x498>
 820be3c:	60800217 	ldw	r2,8(r12)
 820be40:	213fffc4 	addi	r4,r4,-1
 820be44:	1300651e 	bne	r2,r12,820bfdc <_malloc_r+0x7f4>
 820be48:	208000cc 	andi	r2,r4,3
 820be4c:	633ffe04 	addi	r12,r12,-8
 820be50:	103ffa1e 	bne	r2,zero,820be3c <_malloc_r+0x654>
 820be54:	98800117 	ldw	r2,4(r19)
 820be58:	0146303a 	nor	r3,zero,r5
 820be5c:	1884703a 	and	r2,r3,r2
 820be60:	98800115 	stw	r2,4(r19)
 820be64:	294b883a 	add	r5,r5,r5
 820be68:	117f2836 	bltu	r2,r5,820bb0c <_malloc_r+0x324>
 820be6c:	283f2726 	beq	r5,zero,820bb0c <_malloc_r+0x324>
 820be70:	2886703a 	and	r3,r5,r2
 820be74:	5809883a 	mov	r4,r11
 820be78:	183ec31e 	bne	r3,zero,820b988 <_malloc_r+0x1a0>
 820be7c:	294b883a 	add	r5,r5,r5
 820be80:	2886703a 	and	r3,r5,r2
 820be84:	21000104 	addi	r4,r4,4
 820be88:	183ffc26 	beq	r3,zero,820be7c <_malloc_r+0x694>
 820be8c:	003ebe06 	br	820b988 <_malloc_r+0x1a0>
 820be90:	00c05504 	movi	r3,340
 820be94:	18801236 	bltu	r3,r2,820bee0 <_malloc_r+0x6f8>
 820be98:	8804d3fa 	srli	r2,r17,15
 820be9c:	12001e04 	addi	r8,r2,120
 820bea0:	11c01dc4 	addi	r7,r2,119
 820bea4:	4209883a 	add	r4,r8,r8
 820bea8:	003e6d06 	br	820b860 <_malloc_r+0x78>
 820beac:	00c40004 	movi	r3,4096
 820beb0:	003f4606 	br	820bbcc <_malloc_r+0x3e4>
 820beb4:	00800044 	movi	r2,1
 820beb8:	a0800115 	stw	r2,4(r20)
 820bebc:	003f7406 	br	820bc90 <_malloc_r+0x4a8>
 820bec0:	1805d0ba 	srai	r2,r3,2
 820bec4:	01c00044 	movi	r7,1
 820bec8:	30c00117 	ldw	r3,4(r6)
 820becc:	388e983a 	sll	r7,r7,r2
 820bed0:	2805883a 	mov	r2,r5
 820bed4:	38c6b03a 	or	r3,r7,r3
 820bed8:	30c00115 	stw	r3,4(r6)
 820bedc:	003f9b06 	br	820bd4c <_malloc_r+0x564>
 820bee0:	00c15504 	movi	r3,1364
 820bee4:	18801a36 	bltu	r3,r2,820bf50 <_malloc_r+0x768>
 820bee8:	8804d4ba 	srli	r2,r17,18
 820beec:	12001f44 	addi	r8,r2,125
 820bef0:	11c01f04 	addi	r7,r2,124
 820bef4:	4209883a 	add	r4,r8,r8
 820bef8:	003e5906 	br	820b860 <_malloc_r+0x78>
 820befc:	ad400404 	addi	r21,r21,16
 820bf00:	003f1706 	br	820bb60 <_malloc_r+0x378>
 820bf04:	00c01504 	movi	r3,84
 820bf08:	18802336 	bltu	r3,r2,820bf98 <_malloc_r+0x7b0>
 820bf0c:	3804d33a 	srli	r2,r7,12
 820bf10:	11401bc4 	addi	r5,r2,111
 820bf14:	10c01b84 	addi	r3,r2,110
 820bf18:	294b883a 	add	r5,r5,r5
 820bf1c:	003f7b06 	br	820bd0c <_malloc_r+0x524>
 820bf20:	9c000217 	ldw	r16,8(r19)
 820bf24:	00bfff04 	movi	r2,-4
 820bf28:	80c00117 	ldw	r3,4(r16)
 820bf2c:	1886703a 	and	r3,r3,r2
 820bf30:	003f5306 	br	820bc80 <_malloc_r+0x498>
 820bf34:	3083ffcc 	andi	r2,r6,4095
 820bf38:	103f181e 	bne	r2,zero,820bb9c <_malloc_r+0x3b4>
 820bf3c:	99000217 	ldw	r4,8(r19)
 820bf40:	b545883a 	add	r2,r22,r21
 820bf44:	10800054 	ori	r2,r2,1
 820bf48:	20800115 	stw	r2,4(r4)
 820bf4c:	003f3e06 	br	820bc48 <_malloc_r+0x460>
 820bf50:	01003f84 	movi	r4,254
 820bf54:	02001fc4 	movi	r8,127
 820bf58:	01c01f84 	movi	r7,126
 820bf5c:	003e4006 	br	820b860 <_malloc_r+0x78>
 820bf60:	00820974 	movhi	r2,2085
 820bf64:	108e3204 	addi	r2,r2,14536
 820bf68:	15000015 	stw	r20,0(r2)
 820bf6c:	003f1106 	br	820bbb4 <_malloc_r+0x3cc>
 820bf70:	00800044 	movi	r2,1
 820bf74:	002b883a 	mov	r21,zero
 820bf78:	003f1f06 	br	820bbf8 <_malloc_r+0x410>
 820bf7c:	81400204 	addi	r5,r16,8
 820bf80:	9009883a 	mov	r4,r18
 820bf84:	820abfc0 	call	820abfc <_free_r>
 820bf88:	00820974 	movhi	r2,2085
 820bf8c:	10908704 	addi	r2,r2,16924
 820bf90:	10c00017 	ldw	r3,0(r2)
 820bf94:	003f2c06 	br	820bc48 <_malloc_r+0x460>
 820bf98:	00c05504 	movi	r3,340
 820bf9c:	18800536 	bltu	r3,r2,820bfb4 <_malloc_r+0x7cc>
 820bfa0:	3804d3fa 	srli	r2,r7,15
 820bfa4:	11401e04 	addi	r5,r2,120
 820bfa8:	10c01dc4 	addi	r3,r2,119
 820bfac:	294b883a 	add	r5,r5,r5
 820bfb0:	003f5606 	br	820bd0c <_malloc_r+0x524>
 820bfb4:	00c15504 	movi	r3,1364
 820bfb8:	18800536 	bltu	r3,r2,820bfd0 <_malloc_r+0x7e8>
 820bfbc:	3804d4ba 	srli	r2,r7,18
 820bfc0:	11401f44 	addi	r5,r2,125
 820bfc4:	10c01f04 	addi	r3,r2,124
 820bfc8:	294b883a 	add	r5,r5,r5
 820bfcc:	003f4f06 	br	820bd0c <_malloc_r+0x524>
 820bfd0:	01403f84 	movi	r5,254
 820bfd4:	00c01f84 	movi	r3,126
 820bfd8:	003f4c06 	br	820bd0c <_malloc_r+0x524>
 820bfdc:	98800117 	ldw	r2,4(r19)
 820bfe0:	003fa006 	br	820be64 <_malloc_r+0x67c>
 820bfe4:	8808d0fa 	srli	r4,r17,3
 820bfe8:	20800044 	addi	r2,r4,1
 820bfec:	1085883a 	add	r2,r2,r2
 820bff0:	003e9006 	br	820ba34 <_malloc_r+0x24c>

0820bff4 <memchr>:
 820bff4:	208000cc 	andi	r2,r4,3
 820bff8:	280f883a 	mov	r7,r5
 820bffc:	10003426 	beq	r2,zero,820c0d0 <memchr+0xdc>
 820c000:	30bfffc4 	addi	r2,r6,-1
 820c004:	30001a26 	beq	r6,zero,820c070 <memchr+0x7c>
 820c008:	20c00003 	ldbu	r3,0(r4)
 820c00c:	29803fcc 	andi	r6,r5,255
 820c010:	30c0051e 	bne	r6,r3,820c028 <memchr+0x34>
 820c014:	00001806 	br	820c078 <memchr+0x84>
 820c018:	10001526 	beq	r2,zero,820c070 <memchr+0x7c>
 820c01c:	20c00003 	ldbu	r3,0(r4)
 820c020:	10bfffc4 	addi	r2,r2,-1
 820c024:	30c01426 	beq	r6,r3,820c078 <memchr+0x84>
 820c028:	21000044 	addi	r4,r4,1
 820c02c:	20c000cc 	andi	r3,r4,3
 820c030:	183ff91e 	bne	r3,zero,820c018 <memchr+0x24>
 820c034:	020000c4 	movi	r8,3
 820c038:	40801136 	bltu	r8,r2,820c080 <memchr+0x8c>
 820c03c:	10000c26 	beq	r2,zero,820c070 <memchr+0x7c>
 820c040:	20c00003 	ldbu	r3,0(r4)
 820c044:	29403fcc 	andi	r5,r5,255
 820c048:	28c00b26 	beq	r5,r3,820c078 <memchr+0x84>
 820c04c:	20c00044 	addi	r3,r4,1
 820c050:	39803fcc 	andi	r6,r7,255
 820c054:	2089883a 	add	r4,r4,r2
 820c058:	00000306 	br	820c068 <memchr+0x74>
 820c05c:	18c00044 	addi	r3,r3,1
 820c060:	197fffc3 	ldbu	r5,-1(r3)
 820c064:	31400526 	beq	r6,r5,820c07c <memchr+0x88>
 820c068:	1805883a 	mov	r2,r3
 820c06c:	20fffb1e 	bne	r4,r3,820c05c <memchr+0x68>
 820c070:	0005883a 	mov	r2,zero
 820c074:	f800283a 	ret
 820c078:	2005883a 	mov	r2,r4
 820c07c:	f800283a 	ret
 820c080:	28c03fcc 	andi	r3,r5,255
 820c084:	1812923a 	slli	r9,r3,8
 820c088:	02ffbff4 	movhi	r11,65279
 820c08c:	02a02074 	movhi	r10,32897
 820c090:	48d2b03a 	or	r9,r9,r3
 820c094:	4806943a 	slli	r3,r9,16
 820c098:	5affbfc4 	addi	r11,r11,-257
 820c09c:	52a02004 	addi	r10,r10,-32640
 820c0a0:	48d2b03a 	or	r9,r9,r3
 820c0a4:	20c00017 	ldw	r3,0(r4)
 820c0a8:	48c6f03a 	xor	r3,r9,r3
 820c0ac:	1acd883a 	add	r6,r3,r11
 820c0b0:	00c6303a 	nor	r3,zero,r3
 820c0b4:	30c6703a 	and	r3,r6,r3
 820c0b8:	1a86703a 	and	r3,r3,r10
 820c0bc:	183fe01e 	bne	r3,zero,820c040 <memchr+0x4c>
 820c0c0:	10bfff04 	addi	r2,r2,-4
 820c0c4:	21000104 	addi	r4,r4,4
 820c0c8:	40bff636 	bltu	r8,r2,820c0a4 <memchr+0xb0>
 820c0cc:	003fdb06 	br	820c03c <memchr+0x48>
 820c0d0:	3005883a 	mov	r2,r6
 820c0d4:	003fd706 	br	820c034 <memchr+0x40>

0820c0d8 <memcmp>:
 820c0d8:	01c000c4 	movi	r7,3
 820c0dc:	3980192e 	bgeu	r7,r6,820c144 <memcmp+0x6c>
 820c0e0:	2144b03a 	or	r2,r4,r5
 820c0e4:	11c4703a 	and	r2,r2,r7
 820c0e8:	10000f26 	beq	r2,zero,820c128 <memcmp+0x50>
 820c0ec:	20800003 	ldbu	r2,0(r4)
 820c0f0:	28c00003 	ldbu	r3,0(r5)
 820c0f4:	10c0151e 	bne	r2,r3,820c14c <memcmp+0x74>
 820c0f8:	31bfff84 	addi	r6,r6,-2
 820c0fc:	01ffffc4 	movi	r7,-1
 820c100:	00000406 	br	820c114 <memcmp+0x3c>
 820c104:	20800003 	ldbu	r2,0(r4)
 820c108:	28c00003 	ldbu	r3,0(r5)
 820c10c:	31bfffc4 	addi	r6,r6,-1
 820c110:	10c00e1e 	bne	r2,r3,820c14c <memcmp+0x74>
 820c114:	21000044 	addi	r4,r4,1
 820c118:	29400044 	addi	r5,r5,1
 820c11c:	31fff91e 	bne	r6,r7,820c104 <memcmp+0x2c>
 820c120:	0005883a 	mov	r2,zero
 820c124:	f800283a 	ret
 820c128:	20c00017 	ldw	r3,0(r4)
 820c12c:	28800017 	ldw	r2,0(r5)
 820c130:	18bfee1e 	bne	r3,r2,820c0ec <memcmp+0x14>
 820c134:	31bfff04 	addi	r6,r6,-4
 820c138:	21000104 	addi	r4,r4,4
 820c13c:	29400104 	addi	r5,r5,4
 820c140:	39bff936 	bltu	r7,r6,820c128 <memcmp+0x50>
 820c144:	303fe91e 	bne	r6,zero,820c0ec <memcmp+0x14>
 820c148:	003ff506 	br	820c120 <memcmp+0x48>
 820c14c:	10c5c83a 	sub	r2,r2,r3
 820c150:	f800283a 	ret

0820c154 <_Balloc>:
 820c154:	20801317 	ldw	r2,76(r4)
 820c158:	defffc04 	addi	sp,sp,-16
 820c15c:	dc400115 	stw	r17,4(sp)
 820c160:	dc000015 	stw	r16,0(sp)
 820c164:	dfc00315 	stw	ra,12(sp)
 820c168:	dc800215 	stw	r18,8(sp)
 820c16c:	2023883a 	mov	r17,r4
 820c170:	2821883a 	mov	r16,r5
 820c174:	10000f26 	beq	r2,zero,820c1b4 <_Balloc+0x60>
 820c178:	8407883a 	add	r3,r16,r16
 820c17c:	18c7883a 	add	r3,r3,r3
 820c180:	10c7883a 	add	r3,r2,r3
 820c184:	18800017 	ldw	r2,0(r3)
 820c188:	10001126 	beq	r2,zero,820c1d0 <_Balloc+0x7c>
 820c18c:	11000017 	ldw	r4,0(r2)
 820c190:	19000015 	stw	r4,0(r3)
 820c194:	10000415 	stw	zero,16(r2)
 820c198:	10000315 	stw	zero,12(r2)
 820c19c:	dfc00317 	ldw	ra,12(sp)
 820c1a0:	dc800217 	ldw	r18,8(sp)
 820c1a4:	dc400117 	ldw	r17,4(sp)
 820c1a8:	dc000017 	ldw	r16,0(sp)
 820c1ac:	dec00404 	addi	sp,sp,16
 820c1b0:	f800283a 	ret
 820c1b4:	01800844 	movi	r6,33
 820c1b8:	01400104 	movi	r5,4
 820c1bc:	821068c0 	call	821068c <_calloc_r>
 820c1c0:	88801315 	stw	r2,76(r17)
 820c1c4:	103fec1e 	bne	r2,zero,820c178 <_Balloc+0x24>
 820c1c8:	0005883a 	mov	r2,zero
 820c1cc:	003ff306 	br	820c19c <_Balloc+0x48>
 820c1d0:	01400044 	movi	r5,1
 820c1d4:	2c24983a 	sll	r18,r5,r16
 820c1d8:	8809883a 	mov	r4,r17
 820c1dc:	91800144 	addi	r6,r18,5
 820c1e0:	318d883a 	add	r6,r6,r6
 820c1e4:	318d883a 	add	r6,r6,r6
 820c1e8:	821068c0 	call	821068c <_calloc_r>
 820c1ec:	103ff626 	beq	r2,zero,820c1c8 <_Balloc+0x74>
 820c1f0:	14000115 	stw	r16,4(r2)
 820c1f4:	14800215 	stw	r18,8(r2)
 820c1f8:	003fe606 	br	820c194 <_Balloc+0x40>

0820c1fc <_Bfree>:
 820c1fc:	28000826 	beq	r5,zero,820c220 <_Bfree+0x24>
 820c200:	28c00117 	ldw	r3,4(r5)
 820c204:	20801317 	ldw	r2,76(r4)
 820c208:	18c7883a 	add	r3,r3,r3
 820c20c:	18c7883a 	add	r3,r3,r3
 820c210:	10c5883a 	add	r2,r2,r3
 820c214:	10c00017 	ldw	r3,0(r2)
 820c218:	28c00015 	stw	r3,0(r5)
 820c21c:	11400015 	stw	r5,0(r2)
 820c220:	f800283a 	ret

0820c224 <__multadd>:
 820c224:	defffa04 	addi	sp,sp,-24
 820c228:	dc800315 	stw	r18,12(sp)
 820c22c:	dc400215 	stw	r17,8(sp)
 820c230:	dc000115 	stw	r16,4(sp)
 820c234:	2823883a 	mov	r17,r5
 820c238:	2c000417 	ldw	r16,16(r5)
 820c23c:	dfc00515 	stw	ra,20(sp)
 820c240:	dcc00415 	stw	r19,16(sp)
 820c244:	2025883a 	mov	r18,r4
 820c248:	29400504 	addi	r5,r5,20
 820c24c:	0011883a 	mov	r8,zero
 820c250:	28c00017 	ldw	r3,0(r5)
 820c254:	29400104 	addi	r5,r5,4
 820c258:	42000044 	addi	r8,r8,1
 820c25c:	18bfffcc 	andi	r2,r3,65535
 820c260:	1185383a 	mul	r2,r2,r6
 820c264:	1806d43a 	srli	r3,r3,16
 820c268:	11cf883a 	add	r7,r2,r7
 820c26c:	3808d43a 	srli	r4,r7,16
 820c270:	1987383a 	mul	r3,r3,r6
 820c274:	38bfffcc 	andi	r2,r7,65535
 820c278:	1907883a 	add	r3,r3,r4
 820c27c:	1808943a 	slli	r4,r3,16
 820c280:	180ed43a 	srli	r7,r3,16
 820c284:	2085883a 	add	r2,r4,r2
 820c288:	28bfff15 	stw	r2,-4(r5)
 820c28c:	443ff016 	blt	r8,r16,820c250 <__multadd+0x2c>
 820c290:	38000926 	beq	r7,zero,820c2b8 <__multadd+0x94>
 820c294:	88800217 	ldw	r2,8(r17)
 820c298:	80800f0e 	bge	r16,r2,820c2d8 <__multadd+0xb4>
 820c29c:	80800144 	addi	r2,r16,5
 820c2a0:	1085883a 	add	r2,r2,r2
 820c2a4:	1085883a 	add	r2,r2,r2
 820c2a8:	8885883a 	add	r2,r17,r2
 820c2ac:	11c00015 	stw	r7,0(r2)
 820c2b0:	84000044 	addi	r16,r16,1
 820c2b4:	8c000415 	stw	r16,16(r17)
 820c2b8:	8805883a 	mov	r2,r17
 820c2bc:	dfc00517 	ldw	ra,20(sp)
 820c2c0:	dcc00417 	ldw	r19,16(sp)
 820c2c4:	dc800317 	ldw	r18,12(sp)
 820c2c8:	dc400217 	ldw	r17,8(sp)
 820c2cc:	dc000117 	ldw	r16,4(sp)
 820c2d0:	dec00604 	addi	sp,sp,24
 820c2d4:	f800283a 	ret
 820c2d8:	89400117 	ldw	r5,4(r17)
 820c2dc:	9009883a 	mov	r4,r18
 820c2e0:	d9c00015 	stw	r7,0(sp)
 820c2e4:	29400044 	addi	r5,r5,1
 820c2e8:	820c1540 	call	820c154 <_Balloc>
 820c2ec:	89800417 	ldw	r6,16(r17)
 820c2f0:	89400304 	addi	r5,r17,12
 820c2f4:	11000304 	addi	r4,r2,12
 820c2f8:	31800084 	addi	r6,r6,2
 820c2fc:	318d883a 	add	r6,r6,r6
 820c300:	318d883a 	add	r6,r6,r6
 820c304:	1027883a 	mov	r19,r2
 820c308:	8202a0c0 	call	8202a0c <memcpy>
 820c30c:	d9c00017 	ldw	r7,0(sp)
 820c310:	88000a26 	beq	r17,zero,820c33c <__multadd+0x118>
 820c314:	88c00117 	ldw	r3,4(r17)
 820c318:	90801317 	ldw	r2,76(r18)
 820c31c:	18c7883a 	add	r3,r3,r3
 820c320:	18c7883a 	add	r3,r3,r3
 820c324:	10c5883a 	add	r2,r2,r3
 820c328:	10c00017 	ldw	r3,0(r2)
 820c32c:	88c00015 	stw	r3,0(r17)
 820c330:	14400015 	stw	r17,0(r2)
 820c334:	9823883a 	mov	r17,r19
 820c338:	003fd806 	br	820c29c <__multadd+0x78>
 820c33c:	9823883a 	mov	r17,r19
 820c340:	003fd606 	br	820c29c <__multadd+0x78>

0820c344 <__s2b>:
 820c344:	defff904 	addi	sp,sp,-28
 820c348:	dc400115 	stw	r17,4(sp)
 820c34c:	dc000015 	stw	r16,0(sp)
 820c350:	2023883a 	mov	r17,r4
 820c354:	2821883a 	mov	r16,r5
 820c358:	39000204 	addi	r4,r7,8
 820c35c:	01400244 	movi	r5,9
 820c360:	dcc00315 	stw	r19,12(sp)
 820c364:	dc800215 	stw	r18,8(sp)
 820c368:	dfc00615 	stw	ra,24(sp)
 820c36c:	dd400515 	stw	r21,20(sp)
 820c370:	dd000415 	stw	r20,16(sp)
 820c374:	3825883a 	mov	r18,r7
 820c378:	3027883a 	mov	r19,r6
 820c37c:	82026140 	call	8202614 <__divsi3>
 820c380:	00c00044 	movi	r3,1
 820c384:	000b883a 	mov	r5,zero
 820c388:	1880030e 	bge	r3,r2,820c398 <__s2b+0x54>
 820c38c:	18c7883a 	add	r3,r3,r3
 820c390:	29400044 	addi	r5,r5,1
 820c394:	18bffd16 	blt	r3,r2,820c38c <__s2b+0x48>
 820c398:	8809883a 	mov	r4,r17
 820c39c:	820c1540 	call	820c154 <_Balloc>
 820c3a0:	d8c00717 	ldw	r3,28(sp)
 820c3a4:	10c00515 	stw	r3,20(r2)
 820c3a8:	00c00044 	movi	r3,1
 820c3ac:	10c00415 	stw	r3,16(r2)
 820c3b0:	00c00244 	movi	r3,9
 820c3b4:	1cc0210e 	bge	r3,r19,820c43c <__s2b+0xf8>
 820c3b8:	80eb883a 	add	r21,r16,r3
 820c3bc:	a829883a 	mov	r20,r21
 820c3c0:	84e1883a 	add	r16,r16,r19
 820c3c4:	a1c00007 	ldb	r7,0(r20)
 820c3c8:	01800284 	movi	r6,10
 820c3cc:	a5000044 	addi	r20,r20,1
 820c3d0:	100b883a 	mov	r5,r2
 820c3d4:	39fff404 	addi	r7,r7,-48
 820c3d8:	8809883a 	mov	r4,r17
 820c3dc:	820c2240 	call	820c224 <__multadd>
 820c3e0:	a43ff81e 	bne	r20,r16,820c3c4 <__s2b+0x80>
 820c3e4:	ace1883a 	add	r16,r21,r19
 820c3e8:	843ffe04 	addi	r16,r16,-8
 820c3ec:	9c800a0e 	bge	r19,r18,820c418 <__s2b+0xd4>
 820c3f0:	94e5c83a 	sub	r18,r18,r19
 820c3f4:	84a5883a 	add	r18,r16,r18
 820c3f8:	81c00007 	ldb	r7,0(r16)
 820c3fc:	01800284 	movi	r6,10
 820c400:	84000044 	addi	r16,r16,1
 820c404:	100b883a 	mov	r5,r2
 820c408:	39fff404 	addi	r7,r7,-48
 820c40c:	8809883a 	mov	r4,r17
 820c410:	820c2240 	call	820c224 <__multadd>
 820c414:	84bff81e 	bne	r16,r18,820c3f8 <__s2b+0xb4>
 820c418:	dfc00617 	ldw	ra,24(sp)
 820c41c:	dd400517 	ldw	r21,20(sp)
 820c420:	dd000417 	ldw	r20,16(sp)
 820c424:	dcc00317 	ldw	r19,12(sp)
 820c428:	dc800217 	ldw	r18,8(sp)
 820c42c:	dc400117 	ldw	r17,4(sp)
 820c430:	dc000017 	ldw	r16,0(sp)
 820c434:	dec00704 	addi	sp,sp,28
 820c438:	f800283a 	ret
 820c43c:	84000284 	addi	r16,r16,10
 820c440:	1827883a 	mov	r19,r3
 820c444:	003fe906 	br	820c3ec <__s2b+0xa8>

0820c448 <__hi0bits>:
 820c448:	20bfffec 	andhi	r2,r4,65535
 820c44c:	1000141e 	bne	r2,zero,820c4a0 <__hi0bits+0x58>
 820c450:	2008943a 	slli	r4,r4,16
 820c454:	00800404 	movi	r2,16
 820c458:	20ffc02c 	andhi	r3,r4,65280
 820c45c:	1800021e 	bne	r3,zero,820c468 <__hi0bits+0x20>
 820c460:	2008923a 	slli	r4,r4,8
 820c464:	10800204 	addi	r2,r2,8
 820c468:	20fc002c 	andhi	r3,r4,61440
 820c46c:	1800021e 	bne	r3,zero,820c478 <__hi0bits+0x30>
 820c470:	2008913a 	slli	r4,r4,4
 820c474:	10800104 	addi	r2,r2,4
 820c478:	20f0002c 	andhi	r3,r4,49152
 820c47c:	1800031e 	bne	r3,zero,820c48c <__hi0bits+0x44>
 820c480:	2109883a 	add	r4,r4,r4
 820c484:	10800084 	addi	r2,r2,2
 820c488:	2109883a 	add	r4,r4,r4
 820c48c:	20000316 	blt	r4,zero,820c49c <__hi0bits+0x54>
 820c490:	2110002c 	andhi	r4,r4,16384
 820c494:	2000041e 	bne	r4,zero,820c4a8 <__hi0bits+0x60>
 820c498:	00800804 	movi	r2,32
 820c49c:	f800283a 	ret
 820c4a0:	0005883a 	mov	r2,zero
 820c4a4:	003fec06 	br	820c458 <__hi0bits+0x10>
 820c4a8:	10800044 	addi	r2,r2,1
 820c4ac:	f800283a 	ret

0820c4b0 <__lo0bits>:
 820c4b0:	20c00017 	ldw	r3,0(r4)
 820c4b4:	188001cc 	andi	r2,r3,7
 820c4b8:	10000826 	beq	r2,zero,820c4dc <__lo0bits+0x2c>
 820c4bc:	1880004c 	andi	r2,r3,1
 820c4c0:	1000211e 	bne	r2,zero,820c548 <__lo0bits+0x98>
 820c4c4:	1880008c 	andi	r2,r3,2
 820c4c8:	1000211e 	bne	r2,zero,820c550 <__lo0bits+0xa0>
 820c4cc:	1806d0ba 	srli	r3,r3,2
 820c4d0:	00800084 	movi	r2,2
 820c4d4:	20c00015 	stw	r3,0(r4)
 820c4d8:	f800283a 	ret
 820c4dc:	18bfffcc 	andi	r2,r3,65535
 820c4e0:	10001326 	beq	r2,zero,820c530 <__lo0bits+0x80>
 820c4e4:	0005883a 	mov	r2,zero
 820c4e8:	19403fcc 	andi	r5,r3,255
 820c4ec:	2800021e 	bne	r5,zero,820c4f8 <__lo0bits+0x48>
 820c4f0:	1806d23a 	srli	r3,r3,8
 820c4f4:	10800204 	addi	r2,r2,8
 820c4f8:	194003cc 	andi	r5,r3,15
 820c4fc:	2800021e 	bne	r5,zero,820c508 <__lo0bits+0x58>
 820c500:	1806d13a 	srli	r3,r3,4
 820c504:	10800104 	addi	r2,r2,4
 820c508:	194000cc 	andi	r5,r3,3
 820c50c:	2800021e 	bne	r5,zero,820c518 <__lo0bits+0x68>
 820c510:	1806d0ba 	srli	r3,r3,2
 820c514:	10800084 	addi	r2,r2,2
 820c518:	1940004c 	andi	r5,r3,1
 820c51c:	2800081e 	bne	r5,zero,820c540 <__lo0bits+0x90>
 820c520:	1806d07a 	srli	r3,r3,1
 820c524:	1800051e 	bne	r3,zero,820c53c <__lo0bits+0x8c>
 820c528:	00800804 	movi	r2,32
 820c52c:	f800283a 	ret
 820c530:	1806d43a 	srli	r3,r3,16
 820c534:	00800404 	movi	r2,16
 820c538:	003feb06 	br	820c4e8 <__lo0bits+0x38>
 820c53c:	10800044 	addi	r2,r2,1
 820c540:	20c00015 	stw	r3,0(r4)
 820c544:	f800283a 	ret
 820c548:	0005883a 	mov	r2,zero
 820c54c:	f800283a 	ret
 820c550:	1806d07a 	srli	r3,r3,1
 820c554:	00800044 	movi	r2,1
 820c558:	20c00015 	stw	r3,0(r4)
 820c55c:	f800283a 	ret

0820c560 <__i2b>:
 820c560:	defffd04 	addi	sp,sp,-12
 820c564:	dc000015 	stw	r16,0(sp)
 820c568:	04000044 	movi	r16,1
 820c56c:	dc400115 	stw	r17,4(sp)
 820c570:	2823883a 	mov	r17,r5
 820c574:	800b883a 	mov	r5,r16
 820c578:	dfc00215 	stw	ra,8(sp)
 820c57c:	820c1540 	call	820c154 <_Balloc>
 820c580:	14400515 	stw	r17,20(r2)
 820c584:	14000415 	stw	r16,16(r2)
 820c588:	dfc00217 	ldw	ra,8(sp)
 820c58c:	dc400117 	ldw	r17,4(sp)
 820c590:	dc000017 	ldw	r16,0(sp)
 820c594:	dec00304 	addi	sp,sp,12
 820c598:	f800283a 	ret

0820c59c <__multiply>:
 820c59c:	defffa04 	addi	sp,sp,-24
 820c5a0:	dcc00315 	stw	r19,12(sp)
 820c5a4:	dc800215 	stw	r18,8(sp)
 820c5a8:	34c00417 	ldw	r19,16(r6)
 820c5ac:	2c800417 	ldw	r18,16(r5)
 820c5b0:	dd000415 	stw	r20,16(sp)
 820c5b4:	dc400115 	stw	r17,4(sp)
 820c5b8:	dfc00515 	stw	ra,20(sp)
 820c5bc:	dc000015 	stw	r16,0(sp)
 820c5c0:	2829883a 	mov	r20,r5
 820c5c4:	3023883a 	mov	r17,r6
 820c5c8:	94c0050e 	bge	r18,r19,820c5e0 <__multiply+0x44>
 820c5cc:	9007883a 	mov	r3,r18
 820c5d0:	3029883a 	mov	r20,r6
 820c5d4:	9825883a 	mov	r18,r19
 820c5d8:	2823883a 	mov	r17,r5
 820c5dc:	1827883a 	mov	r19,r3
 820c5e0:	a0800217 	ldw	r2,8(r20)
 820c5e4:	94e1883a 	add	r16,r18,r19
 820c5e8:	a1400117 	ldw	r5,4(r20)
 820c5ec:	1400010e 	bge	r2,r16,820c5f4 <__multiply+0x58>
 820c5f0:	29400044 	addi	r5,r5,1
 820c5f4:	820c1540 	call	820c154 <_Balloc>
 820c5f8:	8415883a 	add	r10,r16,r16
 820c5fc:	12c00504 	addi	r11,r2,20
 820c600:	5295883a 	add	r10,r10,r10
 820c604:	5a95883a 	add	r10,r11,r10
 820c608:	5807883a 	mov	r3,r11
 820c60c:	5a80032e 	bgeu	r11,r10,820c61c <__multiply+0x80>
 820c610:	18000015 	stw	zero,0(r3)
 820c614:	18c00104 	addi	r3,r3,4
 820c618:	1abffd36 	bltu	r3,r10,820c610 <__multiply+0x74>
 820c61c:	9ce7883a 	add	r19,r19,r19
 820c620:	94a5883a 	add	r18,r18,r18
 820c624:	89800504 	addi	r6,r17,20
 820c628:	9ce7883a 	add	r19,r19,r19
 820c62c:	a3400504 	addi	r13,r20,20
 820c630:	94a5883a 	add	r18,r18,r18
 820c634:	34d9883a 	add	r12,r6,r19
 820c638:	6c93883a 	add	r9,r13,r18
 820c63c:	3300422e 	bgeu	r6,r12,820c748 <__multiply+0x1ac>
 820c640:	37c00017 	ldw	ra,0(r6)
 820c644:	fbffffcc 	andi	r15,ra,65535
 820c648:	78001b26 	beq	r15,zero,820c6b8 <__multiply+0x11c>
 820c64c:	5811883a 	mov	r8,r11
 820c650:	681d883a 	mov	r14,r13
 820c654:	000f883a 	mov	r7,zero
 820c658:	71000017 	ldw	r4,0(r14)
 820c65c:	40c00017 	ldw	r3,0(r8)
 820c660:	73800104 	addi	r14,r14,4
 820c664:	217fffcc 	andi	r5,r4,65535
 820c668:	2bcb383a 	mul	r5,r5,r15
 820c66c:	2008d43a 	srli	r4,r4,16
 820c670:	1c7fffcc 	andi	r17,r3,65535
 820c674:	2c4b883a 	add	r5,r5,r17
 820c678:	29cb883a 	add	r5,r5,r7
 820c67c:	23c9383a 	mul	r4,r4,r15
 820c680:	1806d43a 	srli	r3,r3,16
 820c684:	280ed43a 	srli	r7,r5,16
 820c688:	297fffcc 	andi	r5,r5,65535
 820c68c:	20c7883a 	add	r3,r4,r3
 820c690:	19c7883a 	add	r3,r3,r7
 820c694:	1808943a 	slli	r4,r3,16
 820c698:	4023883a 	mov	r17,r8
 820c69c:	180ed43a 	srli	r7,r3,16
 820c6a0:	214ab03a 	or	r5,r4,r5
 820c6a4:	41400015 	stw	r5,0(r8)
 820c6a8:	42000104 	addi	r8,r8,4
 820c6ac:	727fea36 	bltu	r14,r9,820c658 <__multiply+0xbc>
 820c6b0:	89c00115 	stw	r7,4(r17)
 820c6b4:	37c00017 	ldw	ra,0(r6)
 820c6b8:	f83ed43a 	srli	ra,ra,16
 820c6bc:	f8001f26 	beq	ra,zero,820c73c <__multiply+0x1a0>
 820c6c0:	58c00017 	ldw	r3,0(r11)
 820c6c4:	681d883a 	mov	r14,r13
 820c6c8:	581f883a 	mov	r15,r11
 820c6cc:	1811883a 	mov	r8,r3
 820c6d0:	5825883a 	mov	r18,r11
 820c6d4:	000f883a 	mov	r7,zero
 820c6d8:	00000106 	br	820c6e0 <__multiply+0x144>
 820c6dc:	8825883a 	mov	r18,r17
 820c6e0:	7140000b 	ldhu	r5,0(r14)
 820c6e4:	4010d43a 	srli	r8,r8,16
 820c6e8:	193fffcc 	andi	r4,r3,65535
 820c6ec:	2fcb383a 	mul	r5,r5,ra
 820c6f0:	7bc00104 	addi	r15,r15,4
 820c6f4:	73800104 	addi	r14,r14,4
 820c6f8:	2a0b883a 	add	r5,r5,r8
 820c6fc:	29cb883a 	add	r5,r5,r7
 820c700:	2806943a 	slli	r3,r5,16
 820c704:	94400104 	addi	r17,r18,4
 820c708:	280ad43a 	srli	r5,r5,16
 820c70c:	1908b03a 	or	r4,r3,r4
 820c710:	793fff15 	stw	r4,-4(r15)
 820c714:	70ffff17 	ldw	r3,-4(r14)
 820c718:	8a000017 	ldw	r8,0(r17)
 820c71c:	1806d43a 	srli	r3,r3,16
 820c720:	413fffcc 	andi	r4,r8,65535
 820c724:	1fc7383a 	mul	r3,r3,ra
 820c728:	1907883a 	add	r3,r3,r4
 820c72c:	1947883a 	add	r3,r3,r5
 820c730:	180ed43a 	srli	r7,r3,16
 820c734:	727fe936 	bltu	r14,r9,820c6dc <__multiply+0x140>
 820c738:	90c00115 	stw	r3,4(r18)
 820c73c:	31800104 	addi	r6,r6,4
 820c740:	5ac00104 	addi	r11,r11,4
 820c744:	333fbe36 	bltu	r6,r12,820c640 <__multiply+0xa4>
 820c748:	0400090e 	bge	zero,r16,820c770 <__multiply+0x1d4>
 820c74c:	50ffff17 	ldw	r3,-4(r10)
 820c750:	52bfff04 	addi	r10,r10,-4
 820c754:	18000326 	beq	r3,zero,820c764 <__multiply+0x1c8>
 820c758:	00000506 	br	820c770 <__multiply+0x1d4>
 820c75c:	50c00017 	ldw	r3,0(r10)
 820c760:	1800031e 	bne	r3,zero,820c770 <__multiply+0x1d4>
 820c764:	843fffc4 	addi	r16,r16,-1
 820c768:	52bfff04 	addi	r10,r10,-4
 820c76c:	803ffb1e 	bne	r16,zero,820c75c <__multiply+0x1c0>
 820c770:	14000415 	stw	r16,16(r2)
 820c774:	dfc00517 	ldw	ra,20(sp)
 820c778:	dd000417 	ldw	r20,16(sp)
 820c77c:	dcc00317 	ldw	r19,12(sp)
 820c780:	dc800217 	ldw	r18,8(sp)
 820c784:	dc400117 	ldw	r17,4(sp)
 820c788:	dc000017 	ldw	r16,0(sp)
 820c78c:	dec00604 	addi	sp,sp,24
 820c790:	f800283a 	ret

0820c794 <__pow5mult>:
 820c794:	defffa04 	addi	sp,sp,-24
 820c798:	dcc00315 	stw	r19,12(sp)
 820c79c:	dc000015 	stw	r16,0(sp)
 820c7a0:	dfc00515 	stw	ra,20(sp)
 820c7a4:	dd000415 	stw	r20,16(sp)
 820c7a8:	dc800215 	stw	r18,8(sp)
 820c7ac:	dc400115 	stw	r17,4(sp)
 820c7b0:	308000cc 	andi	r2,r6,3
 820c7b4:	3021883a 	mov	r16,r6
 820c7b8:	2027883a 	mov	r19,r4
 820c7bc:	10002f1e 	bne	r2,zero,820c87c <__pow5mult+0xe8>
 820c7c0:	2825883a 	mov	r18,r5
 820c7c4:	8021d0ba 	srai	r16,r16,2
 820c7c8:	80001a26 	beq	r16,zero,820c834 <__pow5mult+0xa0>
 820c7cc:	9c401217 	ldw	r17,72(r19)
 820c7d0:	8800061e 	bne	r17,zero,820c7ec <__pow5mult+0x58>
 820c7d4:	00003406 	br	820c8a8 <__pow5mult+0x114>
 820c7d8:	8021d07a 	srai	r16,r16,1
 820c7dc:	80001526 	beq	r16,zero,820c834 <__pow5mult+0xa0>
 820c7e0:	88800017 	ldw	r2,0(r17)
 820c7e4:	10001c26 	beq	r2,zero,820c858 <__pow5mult+0xc4>
 820c7e8:	1023883a 	mov	r17,r2
 820c7ec:	8080004c 	andi	r2,r16,1
 820c7f0:	103ff926 	beq	r2,zero,820c7d8 <__pow5mult+0x44>
 820c7f4:	880d883a 	mov	r6,r17
 820c7f8:	900b883a 	mov	r5,r18
 820c7fc:	9809883a 	mov	r4,r19
 820c800:	820c59c0 	call	820c59c <__multiply>
 820c804:	90001b26 	beq	r18,zero,820c874 <__pow5mult+0xe0>
 820c808:	91000117 	ldw	r4,4(r18)
 820c80c:	98c01317 	ldw	r3,76(r19)
 820c810:	8021d07a 	srai	r16,r16,1
 820c814:	2109883a 	add	r4,r4,r4
 820c818:	2109883a 	add	r4,r4,r4
 820c81c:	1907883a 	add	r3,r3,r4
 820c820:	19000017 	ldw	r4,0(r3)
 820c824:	91000015 	stw	r4,0(r18)
 820c828:	1c800015 	stw	r18,0(r3)
 820c82c:	1025883a 	mov	r18,r2
 820c830:	803feb1e 	bne	r16,zero,820c7e0 <__pow5mult+0x4c>
 820c834:	9005883a 	mov	r2,r18
 820c838:	dfc00517 	ldw	ra,20(sp)
 820c83c:	dd000417 	ldw	r20,16(sp)
 820c840:	dcc00317 	ldw	r19,12(sp)
 820c844:	dc800217 	ldw	r18,8(sp)
 820c848:	dc400117 	ldw	r17,4(sp)
 820c84c:	dc000017 	ldw	r16,0(sp)
 820c850:	dec00604 	addi	sp,sp,24
 820c854:	f800283a 	ret
 820c858:	880d883a 	mov	r6,r17
 820c85c:	880b883a 	mov	r5,r17
 820c860:	9809883a 	mov	r4,r19
 820c864:	820c59c0 	call	820c59c <__multiply>
 820c868:	88800015 	stw	r2,0(r17)
 820c86c:	10000015 	stw	zero,0(r2)
 820c870:	003fdd06 	br	820c7e8 <__pow5mult+0x54>
 820c874:	1025883a 	mov	r18,r2
 820c878:	003fd706 	br	820c7d8 <__pow5mult+0x44>
 820c87c:	10bfffc4 	addi	r2,r2,-1
 820c880:	1085883a 	add	r2,r2,r2
 820c884:	00c20974 	movhi	r3,2085
 820c888:	18f57904 	addi	r3,r3,-10780
 820c88c:	1085883a 	add	r2,r2,r2
 820c890:	1885883a 	add	r2,r3,r2
 820c894:	11800017 	ldw	r6,0(r2)
 820c898:	000f883a 	mov	r7,zero
 820c89c:	820c2240 	call	820c224 <__multadd>
 820c8a0:	1025883a 	mov	r18,r2
 820c8a4:	003fc706 	br	820c7c4 <__pow5mult+0x30>
 820c8a8:	05000044 	movi	r20,1
 820c8ac:	a00b883a 	mov	r5,r20
 820c8b0:	9809883a 	mov	r4,r19
 820c8b4:	820c1540 	call	820c154 <_Balloc>
 820c8b8:	1023883a 	mov	r17,r2
 820c8bc:	00809c44 	movi	r2,625
 820c8c0:	88800515 	stw	r2,20(r17)
 820c8c4:	8d000415 	stw	r20,16(r17)
 820c8c8:	9c401215 	stw	r17,72(r19)
 820c8cc:	88000015 	stw	zero,0(r17)
 820c8d0:	003fc606 	br	820c7ec <__pow5mult+0x58>

0820c8d4 <__lshift>:
 820c8d4:	defff904 	addi	sp,sp,-28
 820c8d8:	dd400515 	stw	r21,20(sp)
 820c8dc:	dcc00315 	stw	r19,12(sp)
 820c8e0:	302bd17a 	srai	r21,r6,5
 820c8e4:	2cc00417 	ldw	r19,16(r5)
 820c8e8:	28800217 	ldw	r2,8(r5)
 820c8ec:	dd000415 	stw	r20,16(sp)
 820c8f0:	ace7883a 	add	r19,r21,r19
 820c8f4:	dc800215 	stw	r18,8(sp)
 820c8f8:	dc400115 	stw	r17,4(sp)
 820c8fc:	dc000015 	stw	r16,0(sp)
 820c900:	dfc00615 	stw	ra,24(sp)
 820c904:	9c000044 	addi	r16,r19,1
 820c908:	2823883a 	mov	r17,r5
 820c90c:	3029883a 	mov	r20,r6
 820c910:	2025883a 	mov	r18,r4
 820c914:	29400117 	ldw	r5,4(r5)
 820c918:	1400030e 	bge	r2,r16,820c928 <__lshift+0x54>
 820c91c:	1085883a 	add	r2,r2,r2
 820c920:	29400044 	addi	r5,r5,1
 820c924:	143ffd16 	blt	r2,r16,820c91c <__lshift+0x48>
 820c928:	9009883a 	mov	r4,r18
 820c92c:	820c1540 	call	820c154 <_Balloc>
 820c930:	10c00504 	addi	r3,r2,20
 820c934:	0540070e 	bge	zero,r21,820c954 <__lshift+0x80>
 820c938:	ad6b883a 	add	r21,r21,r21
 820c93c:	ad6b883a 	add	r21,r21,r21
 820c940:	1809883a 	mov	r4,r3
 820c944:	1d47883a 	add	r3,r3,r21
 820c948:	20000015 	stw	zero,0(r4)
 820c94c:	21000104 	addi	r4,r4,4
 820c950:	193ffd1e 	bne	r3,r4,820c948 <__lshift+0x74>
 820c954:	8a000417 	ldw	r8,16(r17)
 820c958:	89000504 	addi	r4,r17,20
 820c95c:	a18007cc 	andi	r6,r20,31
 820c960:	4211883a 	add	r8,r8,r8
 820c964:	4211883a 	add	r8,r8,r8
 820c968:	2211883a 	add	r8,r4,r8
 820c96c:	30002326 	beq	r6,zero,820c9fc <__lshift+0x128>
 820c970:	02400804 	movi	r9,32
 820c974:	4993c83a 	sub	r9,r9,r6
 820c978:	000b883a 	mov	r5,zero
 820c97c:	21c00017 	ldw	r7,0(r4)
 820c980:	1815883a 	mov	r10,r3
 820c984:	18c00104 	addi	r3,r3,4
 820c988:	398e983a 	sll	r7,r7,r6
 820c98c:	21000104 	addi	r4,r4,4
 820c990:	394ab03a 	or	r5,r7,r5
 820c994:	197fff15 	stw	r5,-4(r3)
 820c998:	217fff17 	ldw	r5,-4(r4)
 820c99c:	2a4ad83a 	srl	r5,r5,r9
 820c9a0:	223ff636 	bltu	r4,r8,820c97c <__lshift+0xa8>
 820c9a4:	51400115 	stw	r5,4(r10)
 820c9a8:	28001a1e 	bne	r5,zero,820ca14 <__lshift+0x140>
 820c9ac:	843fffc4 	addi	r16,r16,-1
 820c9b0:	14000415 	stw	r16,16(r2)
 820c9b4:	88000826 	beq	r17,zero,820c9d8 <__lshift+0x104>
 820c9b8:	89000117 	ldw	r4,4(r17)
 820c9bc:	90c01317 	ldw	r3,76(r18)
 820c9c0:	2109883a 	add	r4,r4,r4
 820c9c4:	2109883a 	add	r4,r4,r4
 820c9c8:	1907883a 	add	r3,r3,r4
 820c9cc:	19000017 	ldw	r4,0(r3)
 820c9d0:	89000015 	stw	r4,0(r17)
 820c9d4:	1c400015 	stw	r17,0(r3)
 820c9d8:	dfc00617 	ldw	ra,24(sp)
 820c9dc:	dd400517 	ldw	r21,20(sp)
 820c9e0:	dd000417 	ldw	r20,16(sp)
 820c9e4:	dcc00317 	ldw	r19,12(sp)
 820c9e8:	dc800217 	ldw	r18,8(sp)
 820c9ec:	dc400117 	ldw	r17,4(sp)
 820c9f0:	dc000017 	ldw	r16,0(sp)
 820c9f4:	dec00704 	addi	sp,sp,28
 820c9f8:	f800283a 	ret
 820c9fc:	21400017 	ldw	r5,0(r4)
 820ca00:	18c00104 	addi	r3,r3,4
 820ca04:	21000104 	addi	r4,r4,4
 820ca08:	197fff15 	stw	r5,-4(r3)
 820ca0c:	223ffb36 	bltu	r4,r8,820c9fc <__lshift+0x128>
 820ca10:	003fe606 	br	820c9ac <__lshift+0xd8>
 820ca14:	9c000084 	addi	r16,r19,2
 820ca18:	003fe406 	br	820c9ac <__lshift+0xd8>

0820ca1c <__mcmp>:
 820ca1c:	20800417 	ldw	r2,16(r4)
 820ca20:	28c00417 	ldw	r3,16(r5)
 820ca24:	10c5c83a 	sub	r2,r2,r3
 820ca28:	1000111e 	bne	r2,zero,820ca70 <__mcmp+0x54>
 820ca2c:	18c7883a 	add	r3,r3,r3
 820ca30:	18c7883a 	add	r3,r3,r3
 820ca34:	21000504 	addi	r4,r4,20
 820ca38:	29400504 	addi	r5,r5,20
 820ca3c:	20c5883a 	add	r2,r4,r3
 820ca40:	28cb883a 	add	r5,r5,r3
 820ca44:	00000106 	br	820ca4c <__mcmp+0x30>
 820ca48:	20800a2e 	bgeu	r4,r2,820ca74 <__mcmp+0x58>
 820ca4c:	10bfff04 	addi	r2,r2,-4
 820ca50:	297fff04 	addi	r5,r5,-4
 820ca54:	11800017 	ldw	r6,0(r2)
 820ca58:	28c00017 	ldw	r3,0(r5)
 820ca5c:	30fffa26 	beq	r6,r3,820ca48 <__mcmp+0x2c>
 820ca60:	30c00236 	bltu	r6,r3,820ca6c <__mcmp+0x50>
 820ca64:	00800044 	movi	r2,1
 820ca68:	f800283a 	ret
 820ca6c:	00bfffc4 	movi	r2,-1
 820ca70:	f800283a 	ret
 820ca74:	0005883a 	mov	r2,zero
 820ca78:	f800283a 	ret

0820ca7c <__mdiff>:
 820ca7c:	28c00417 	ldw	r3,16(r5)
 820ca80:	30800417 	ldw	r2,16(r6)
 820ca84:	defffa04 	addi	sp,sp,-24
 820ca88:	dcc00315 	stw	r19,12(sp)
 820ca8c:	dc800215 	stw	r18,8(sp)
 820ca90:	dfc00515 	stw	ra,20(sp)
 820ca94:	dd000415 	stw	r20,16(sp)
 820ca98:	dc400115 	stw	r17,4(sp)
 820ca9c:	dc000015 	stw	r16,0(sp)
 820caa0:	1887c83a 	sub	r3,r3,r2
 820caa4:	2825883a 	mov	r18,r5
 820caa8:	3027883a 	mov	r19,r6
 820caac:	1800141e 	bne	r3,zero,820cb00 <__mdiff+0x84>
 820cab0:	1085883a 	add	r2,r2,r2
 820cab4:	1085883a 	add	r2,r2,r2
 820cab8:	2a000504 	addi	r8,r5,20
 820cabc:	34000504 	addi	r16,r6,20
 820cac0:	4087883a 	add	r3,r8,r2
 820cac4:	8085883a 	add	r2,r16,r2
 820cac8:	00000106 	br	820cad0 <__mdiff+0x54>
 820cacc:	40c0592e 	bgeu	r8,r3,820cc34 <__mdiff+0x1b8>
 820cad0:	18ffff04 	addi	r3,r3,-4
 820cad4:	10bfff04 	addi	r2,r2,-4
 820cad8:	19c00017 	ldw	r7,0(r3)
 820cadc:	11400017 	ldw	r5,0(r2)
 820cae0:	397ffa26 	beq	r7,r5,820cacc <__mdiff+0x50>
 820cae4:	3940592e 	bgeu	r7,r5,820cc4c <__mdiff+0x1d0>
 820cae8:	9005883a 	mov	r2,r18
 820caec:	4023883a 	mov	r17,r8
 820caf0:	9825883a 	mov	r18,r19
 820caf4:	05000044 	movi	r20,1
 820caf8:	1027883a 	mov	r19,r2
 820cafc:	00000406 	br	820cb10 <__mdiff+0x94>
 820cb00:	18005616 	blt	r3,zero,820cc5c <__mdiff+0x1e0>
 820cb04:	34400504 	addi	r17,r6,20
 820cb08:	2c000504 	addi	r16,r5,20
 820cb0c:	0029883a 	mov	r20,zero
 820cb10:	91400117 	ldw	r5,4(r18)
 820cb14:	820c1540 	call	820c154 <_Balloc>
 820cb18:	92400417 	ldw	r9,16(r18)
 820cb1c:	9b000417 	ldw	r12,16(r19)
 820cb20:	12c00504 	addi	r11,r2,20
 820cb24:	4a51883a 	add	r8,r9,r9
 820cb28:	6319883a 	add	r12,r12,r12
 820cb2c:	4211883a 	add	r8,r8,r8
 820cb30:	6319883a 	add	r12,r12,r12
 820cb34:	15000315 	stw	r20,12(r2)
 820cb38:	8211883a 	add	r8,r16,r8
 820cb3c:	8b19883a 	add	r12,r17,r12
 820cb40:	0007883a 	mov	r3,zero
 820cb44:	81400017 	ldw	r5,0(r16)
 820cb48:	89c00017 	ldw	r7,0(r17)
 820cb4c:	59800104 	addi	r6,r11,4
 820cb50:	293fffcc 	andi	r4,r5,65535
 820cb54:	20c7883a 	add	r3,r4,r3
 820cb58:	393fffcc 	andi	r4,r7,65535
 820cb5c:	1909c83a 	sub	r4,r3,r4
 820cb60:	280ad43a 	srli	r5,r5,16
 820cb64:	380ed43a 	srli	r7,r7,16
 820cb68:	2007d43a 	srai	r3,r4,16
 820cb6c:	213fffcc 	andi	r4,r4,65535
 820cb70:	29cbc83a 	sub	r5,r5,r7
 820cb74:	28c7883a 	add	r3,r5,r3
 820cb78:	180a943a 	slli	r5,r3,16
 820cb7c:	8c400104 	addi	r17,r17,4
 820cb80:	84000104 	addi	r16,r16,4
 820cb84:	2908b03a 	or	r4,r5,r4
 820cb88:	59000015 	stw	r4,0(r11)
 820cb8c:	1807d43a 	srai	r3,r3,16
 820cb90:	3015883a 	mov	r10,r6
 820cb94:	3017883a 	mov	r11,r6
 820cb98:	8b3fea36 	bltu	r17,r12,820cb44 <__mdiff+0xc8>
 820cb9c:	8200162e 	bgeu	r16,r8,820cbf8 <__mdiff+0x17c>
 820cba0:	8017883a 	mov	r11,r16
 820cba4:	59400017 	ldw	r5,0(r11)
 820cba8:	31800104 	addi	r6,r6,4
 820cbac:	5ac00104 	addi	r11,r11,4
 820cbb0:	293fffcc 	andi	r4,r5,65535
 820cbb4:	20c7883a 	add	r3,r4,r3
 820cbb8:	280ed43a 	srli	r7,r5,16
 820cbbc:	180bd43a 	srai	r5,r3,16
 820cbc0:	193fffcc 	andi	r4,r3,65535
 820cbc4:	3947883a 	add	r3,r7,r5
 820cbc8:	180a943a 	slli	r5,r3,16
 820cbcc:	1807d43a 	srai	r3,r3,16
 820cbd0:	2908b03a 	or	r4,r5,r4
 820cbd4:	313fff15 	stw	r4,-4(r6)
 820cbd8:	5a3ff236 	bltu	r11,r8,820cba4 <__mdiff+0x128>
 820cbdc:	0406303a 	nor	r3,zero,r16
 820cbe0:	1a07883a 	add	r3,r3,r8
 820cbe4:	1806d0ba 	srli	r3,r3,2
 820cbe8:	18c00044 	addi	r3,r3,1
 820cbec:	18c7883a 	add	r3,r3,r3
 820cbf0:	18c7883a 	add	r3,r3,r3
 820cbf4:	50d5883a 	add	r10,r10,r3
 820cbf8:	50ffff04 	addi	r3,r10,-4
 820cbfc:	2000041e 	bne	r4,zero,820cc10 <__mdiff+0x194>
 820cc00:	18ffff04 	addi	r3,r3,-4
 820cc04:	19000017 	ldw	r4,0(r3)
 820cc08:	4a7fffc4 	addi	r9,r9,-1
 820cc0c:	203ffc26 	beq	r4,zero,820cc00 <__mdiff+0x184>
 820cc10:	12400415 	stw	r9,16(r2)
 820cc14:	dfc00517 	ldw	ra,20(sp)
 820cc18:	dd000417 	ldw	r20,16(sp)
 820cc1c:	dcc00317 	ldw	r19,12(sp)
 820cc20:	dc800217 	ldw	r18,8(sp)
 820cc24:	dc400117 	ldw	r17,4(sp)
 820cc28:	dc000017 	ldw	r16,0(sp)
 820cc2c:	dec00604 	addi	sp,sp,24
 820cc30:	f800283a 	ret
 820cc34:	000b883a 	mov	r5,zero
 820cc38:	820c1540 	call	820c154 <_Balloc>
 820cc3c:	00c00044 	movi	r3,1
 820cc40:	10c00415 	stw	r3,16(r2)
 820cc44:	10000515 	stw	zero,20(r2)
 820cc48:	003ff206 	br	820cc14 <__mdiff+0x198>
 820cc4c:	8023883a 	mov	r17,r16
 820cc50:	0029883a 	mov	r20,zero
 820cc54:	4021883a 	mov	r16,r8
 820cc58:	003fad06 	br	820cb10 <__mdiff+0x94>
 820cc5c:	9005883a 	mov	r2,r18
 820cc60:	94400504 	addi	r17,r18,20
 820cc64:	9c000504 	addi	r16,r19,20
 820cc68:	9825883a 	mov	r18,r19
 820cc6c:	05000044 	movi	r20,1
 820cc70:	1027883a 	mov	r19,r2
 820cc74:	003fa606 	br	820cb10 <__mdiff+0x94>

0820cc78 <__ulp>:
 820cc78:	295ffc2c 	andhi	r5,r5,32752
 820cc7c:	00bf3034 	movhi	r2,64704
 820cc80:	2887883a 	add	r3,r5,r2
 820cc84:	00c0020e 	bge	zero,r3,820cc90 <__ulp+0x18>
 820cc88:	0005883a 	mov	r2,zero
 820cc8c:	f800283a 	ret
 820cc90:	00c7c83a 	sub	r3,zero,r3
 820cc94:	1807d53a 	srai	r3,r3,20
 820cc98:	008004c4 	movi	r2,19
 820cc9c:	10c00b0e 	bge	r2,r3,820cccc <__ulp+0x54>
 820cca0:	18bffb04 	addi	r2,r3,-20
 820cca4:	01000784 	movi	r4,30
 820cca8:	0007883a 	mov	r3,zero
 820ccac:	20800516 	blt	r4,r2,820ccc4 <__ulp+0x4c>
 820ccb0:	010007c4 	movi	r4,31
 820ccb4:	2089c83a 	sub	r4,r4,r2
 820ccb8:	00800044 	movi	r2,1
 820ccbc:	1104983a 	sll	r2,r2,r4
 820ccc0:	f800283a 	ret
 820ccc4:	00800044 	movi	r2,1
 820ccc8:	f800283a 	ret
 820cccc:	01400234 	movhi	r5,8
 820ccd0:	28c7d83a 	sra	r3,r5,r3
 820ccd4:	0005883a 	mov	r2,zero
 820ccd8:	f800283a 	ret

0820ccdc <__b2d>:
 820ccdc:	defffa04 	addi	sp,sp,-24
 820cce0:	dc000015 	stw	r16,0(sp)
 820cce4:	24000417 	ldw	r16,16(r4)
 820cce8:	dc400115 	stw	r17,4(sp)
 820ccec:	24400504 	addi	r17,r4,20
 820ccf0:	8421883a 	add	r16,r16,r16
 820ccf4:	8421883a 	add	r16,r16,r16
 820ccf8:	8c21883a 	add	r16,r17,r16
 820ccfc:	dc800215 	stw	r18,8(sp)
 820cd00:	84bfff17 	ldw	r18,-4(r16)
 820cd04:	dd000415 	stw	r20,16(sp)
 820cd08:	dcc00315 	stw	r19,12(sp)
 820cd0c:	9009883a 	mov	r4,r18
 820cd10:	2829883a 	mov	r20,r5
 820cd14:	dfc00515 	stw	ra,20(sp)
 820cd18:	820c4480 	call	820c448 <__hi0bits>
 820cd1c:	00c00804 	movi	r3,32
 820cd20:	1889c83a 	sub	r4,r3,r2
 820cd24:	a1000015 	stw	r4,0(r20)
 820cd28:	01000284 	movi	r4,10
 820cd2c:	84ffff04 	addi	r19,r16,-4
 820cd30:	20801216 	blt	r4,r2,820cd7c <__b2d+0xa0>
 820cd34:	018002c4 	movi	r6,11
 820cd38:	308dc83a 	sub	r6,r6,r2
 820cd3c:	9186d83a 	srl	r3,r18,r6
 820cd40:	18cffc34 	orhi	r3,r3,16368
 820cd44:	8cc0212e 	bgeu	r17,r19,820cdcc <__b2d+0xf0>
 820cd48:	813ffe17 	ldw	r4,-8(r16)
 820cd4c:	218cd83a 	srl	r6,r4,r6
 820cd50:	10800544 	addi	r2,r2,21
 820cd54:	9084983a 	sll	r2,r18,r2
 820cd58:	1184b03a 	or	r2,r2,r6
 820cd5c:	dfc00517 	ldw	ra,20(sp)
 820cd60:	dd000417 	ldw	r20,16(sp)
 820cd64:	dcc00317 	ldw	r19,12(sp)
 820cd68:	dc800217 	ldw	r18,8(sp)
 820cd6c:	dc400117 	ldw	r17,4(sp)
 820cd70:	dc000017 	ldw	r16,0(sp)
 820cd74:	dec00604 	addi	sp,sp,24
 820cd78:	f800283a 	ret
 820cd7c:	8cc00f2e 	bgeu	r17,r19,820cdbc <__b2d+0xe0>
 820cd80:	117ffd44 	addi	r5,r2,-11
 820cd84:	80bffe17 	ldw	r2,-8(r16)
 820cd88:	28000e26 	beq	r5,zero,820cdc4 <__b2d+0xe8>
 820cd8c:	1949c83a 	sub	r4,r3,r5
 820cd90:	9164983a 	sll	r18,r18,r5
 820cd94:	1106d83a 	srl	r3,r2,r4
 820cd98:	81bffe04 	addi	r6,r16,-8
 820cd9c:	948ffc34 	orhi	r18,r18,16368
 820cda0:	90c6b03a 	or	r3,r18,r3
 820cda4:	89800e2e 	bgeu	r17,r6,820cde0 <__b2d+0x104>
 820cda8:	81bffd17 	ldw	r6,-12(r16)
 820cdac:	1144983a 	sll	r2,r2,r5
 820cdb0:	310ad83a 	srl	r5,r6,r4
 820cdb4:	2884b03a 	or	r2,r5,r2
 820cdb8:	003fe806 	br	820cd5c <__b2d+0x80>
 820cdbc:	10bffd44 	addi	r2,r2,-11
 820cdc0:	1000041e 	bne	r2,zero,820cdd4 <__b2d+0xf8>
 820cdc4:	90cffc34 	orhi	r3,r18,16368
 820cdc8:	003fe406 	br	820cd5c <__b2d+0x80>
 820cdcc:	000d883a 	mov	r6,zero
 820cdd0:	003fdf06 	br	820cd50 <__b2d+0x74>
 820cdd4:	90a4983a 	sll	r18,r18,r2
 820cdd8:	0005883a 	mov	r2,zero
 820cddc:	003ff906 	br	820cdc4 <__b2d+0xe8>
 820cde0:	1144983a 	sll	r2,r2,r5
 820cde4:	003fdd06 	br	820cd5c <__b2d+0x80>

0820cde8 <__d2b>:
 820cde8:	defff804 	addi	sp,sp,-32
 820cdec:	dc000215 	stw	r16,8(sp)
 820cdf0:	3021883a 	mov	r16,r6
 820cdf4:	dc400315 	stw	r17,12(sp)
 820cdf8:	8022907a 	slli	r17,r16,1
 820cdfc:	dd000615 	stw	r20,24(sp)
 820ce00:	2829883a 	mov	r20,r5
 820ce04:	01400044 	movi	r5,1
 820ce08:	dcc00515 	stw	r19,20(sp)
 820ce0c:	dc800415 	stw	r18,16(sp)
 820ce10:	dfc00715 	stw	ra,28(sp)
 820ce14:	3825883a 	mov	r18,r7
 820ce18:	8822d57a 	srli	r17,r17,21
 820ce1c:	820c1540 	call	820c154 <_Balloc>
 820ce20:	1027883a 	mov	r19,r2
 820ce24:	00800434 	movhi	r2,16
 820ce28:	10bfffc4 	addi	r2,r2,-1
 820ce2c:	808c703a 	and	r6,r16,r2
 820ce30:	88000126 	beq	r17,zero,820ce38 <__d2b+0x50>
 820ce34:	31800434 	orhi	r6,r6,16
 820ce38:	d9800015 	stw	r6,0(sp)
 820ce3c:	a0002426 	beq	r20,zero,820ced0 <__d2b+0xe8>
 820ce40:	d9000104 	addi	r4,sp,4
 820ce44:	dd000115 	stw	r20,4(sp)
 820ce48:	820c4b00 	call	820c4b0 <__lo0bits>
 820ce4c:	d8c00017 	ldw	r3,0(sp)
 820ce50:	10002f1e 	bne	r2,zero,820cf10 <__d2b+0x128>
 820ce54:	d9000117 	ldw	r4,4(sp)
 820ce58:	99000515 	stw	r4,20(r19)
 820ce5c:	1821003a 	cmpeq	r16,r3,zero
 820ce60:	01000084 	movi	r4,2
 820ce64:	2421c83a 	sub	r16,r4,r16
 820ce68:	98c00615 	stw	r3,24(r19)
 820ce6c:	9c000415 	stw	r16,16(r19)
 820ce70:	88001f1e 	bne	r17,zero,820cef0 <__d2b+0x108>
 820ce74:	10bef384 	addi	r2,r2,-1074
 820ce78:	90800015 	stw	r2,0(r18)
 820ce7c:	00900034 	movhi	r2,16384
 820ce80:	10bfffc4 	addi	r2,r2,-1
 820ce84:	8085883a 	add	r2,r16,r2
 820ce88:	1085883a 	add	r2,r2,r2
 820ce8c:	1085883a 	add	r2,r2,r2
 820ce90:	9885883a 	add	r2,r19,r2
 820ce94:	11000517 	ldw	r4,20(r2)
 820ce98:	8020917a 	slli	r16,r16,5
 820ce9c:	820c4480 	call	820c448 <__hi0bits>
 820cea0:	d8c00817 	ldw	r3,32(sp)
 820cea4:	8085c83a 	sub	r2,r16,r2
 820cea8:	18800015 	stw	r2,0(r3)
 820ceac:	9805883a 	mov	r2,r19
 820ceb0:	dfc00717 	ldw	ra,28(sp)
 820ceb4:	dd000617 	ldw	r20,24(sp)
 820ceb8:	dcc00517 	ldw	r19,20(sp)
 820cebc:	dc800417 	ldw	r18,16(sp)
 820cec0:	dc400317 	ldw	r17,12(sp)
 820cec4:	dc000217 	ldw	r16,8(sp)
 820cec8:	dec00804 	addi	sp,sp,32
 820cecc:	f800283a 	ret
 820ced0:	d809883a 	mov	r4,sp
 820ced4:	820c4b00 	call	820c4b0 <__lo0bits>
 820ced8:	d8c00017 	ldw	r3,0(sp)
 820cedc:	04000044 	movi	r16,1
 820cee0:	9c000415 	stw	r16,16(r19)
 820cee4:	98c00515 	stw	r3,20(r19)
 820cee8:	10800804 	addi	r2,r2,32
 820ceec:	883fe126 	beq	r17,zero,820ce74 <__d2b+0x8c>
 820cef0:	00c00d44 	movi	r3,53
 820cef4:	8c7ef344 	addi	r17,r17,-1075
 820cef8:	88a3883a 	add	r17,r17,r2
 820cefc:	1885c83a 	sub	r2,r3,r2
 820cf00:	d8c00817 	ldw	r3,32(sp)
 820cf04:	94400015 	stw	r17,0(r18)
 820cf08:	18800015 	stw	r2,0(r3)
 820cf0c:	003fe706 	br	820ceac <__d2b+0xc4>
 820cf10:	01000804 	movi	r4,32
 820cf14:	2089c83a 	sub	r4,r4,r2
 820cf18:	1908983a 	sll	r4,r3,r4
 820cf1c:	d9400117 	ldw	r5,4(sp)
 820cf20:	1886d83a 	srl	r3,r3,r2
 820cf24:	2148b03a 	or	r4,r4,r5
 820cf28:	99000515 	stw	r4,20(r19)
 820cf2c:	d8c00015 	stw	r3,0(sp)
 820cf30:	003fca06 	br	820ce5c <__d2b+0x74>

0820cf34 <__ratio>:
 820cf34:	defff904 	addi	sp,sp,-28
 820cf38:	dc400315 	stw	r17,12(sp)
 820cf3c:	2823883a 	mov	r17,r5
 820cf40:	d9400104 	addi	r5,sp,4
 820cf44:	dfc00615 	stw	ra,24(sp)
 820cf48:	dcc00515 	stw	r19,20(sp)
 820cf4c:	dc800415 	stw	r18,16(sp)
 820cf50:	2027883a 	mov	r19,r4
 820cf54:	dc000215 	stw	r16,8(sp)
 820cf58:	820ccdc0 	call	820ccdc <__b2d>
 820cf5c:	d80b883a 	mov	r5,sp
 820cf60:	8809883a 	mov	r4,r17
 820cf64:	1025883a 	mov	r18,r2
 820cf68:	1821883a 	mov	r16,r3
 820cf6c:	820ccdc0 	call	820ccdc <__b2d>
 820cf70:	8a000417 	ldw	r8,16(r17)
 820cf74:	99000417 	ldw	r4,16(r19)
 820cf78:	d9400117 	ldw	r5,4(sp)
 820cf7c:	2209c83a 	sub	r4,r4,r8
 820cf80:	2010917a 	slli	r8,r4,5
 820cf84:	d9000017 	ldw	r4,0(sp)
 820cf88:	2909c83a 	sub	r4,r5,r4
 820cf8c:	4109883a 	add	r4,r8,r4
 820cf90:	01000e0e 	bge	zero,r4,820cfcc <__ratio+0x98>
 820cf94:	2008953a 	slli	r4,r4,20
 820cf98:	2421883a 	add	r16,r4,r16
 820cf9c:	100d883a 	mov	r6,r2
 820cfa0:	180f883a 	mov	r7,r3
 820cfa4:	9009883a 	mov	r4,r18
 820cfa8:	800b883a 	mov	r5,r16
 820cfac:	82121100 	call	8212110 <__divdf3>
 820cfb0:	dfc00617 	ldw	ra,24(sp)
 820cfb4:	dcc00517 	ldw	r19,20(sp)
 820cfb8:	dc800417 	ldw	r18,16(sp)
 820cfbc:	dc400317 	ldw	r17,12(sp)
 820cfc0:	dc000217 	ldw	r16,8(sp)
 820cfc4:	dec00704 	addi	sp,sp,28
 820cfc8:	f800283a 	ret
 820cfcc:	2008953a 	slli	r4,r4,20
 820cfd0:	1907c83a 	sub	r3,r3,r4
 820cfd4:	003ff106 	br	820cf9c <__ratio+0x68>

0820cfd8 <_mprec_log10>:
 820cfd8:	defffe04 	addi	sp,sp,-8
 820cfdc:	dc000015 	stw	r16,0(sp)
 820cfe0:	dfc00115 	stw	ra,4(sp)
 820cfe4:	008005c4 	movi	r2,23
 820cfe8:	2021883a 	mov	r16,r4
 820cfec:	11000d0e 	bge	r2,r4,820d024 <_mprec_log10+0x4c>
 820cff0:	0005883a 	mov	r2,zero
 820cff4:	00cffc34 	movhi	r3,16368
 820cff8:	843fffc4 	addi	r16,r16,-1
 820cffc:	000d883a 	mov	r6,zero
 820d000:	01d00934 	movhi	r7,16420
 820d004:	1009883a 	mov	r4,r2
 820d008:	180b883a 	mov	r5,r3
 820d00c:	8212c500 	call	8212c50 <__muldf3>
 820d010:	803ff91e 	bne	r16,zero,820cff8 <_mprec_log10+0x20>
 820d014:	dfc00117 	ldw	ra,4(sp)
 820d018:	dc000017 	ldw	r16,0(sp)
 820d01c:	dec00204 	addi	sp,sp,8
 820d020:	f800283a 	ret
 820d024:	202090fa 	slli	r16,r4,3
 820d028:	00820974 	movhi	r2,2085
 820d02c:	10b59004 	addi	r2,r2,-10688
 820d030:	1421883a 	add	r16,r2,r16
 820d034:	80800017 	ldw	r2,0(r16)
 820d038:	80c00117 	ldw	r3,4(r16)
 820d03c:	dfc00117 	ldw	ra,4(sp)
 820d040:	dc000017 	ldw	r16,0(sp)
 820d044:	dec00204 	addi	sp,sp,8
 820d048:	f800283a 	ret

0820d04c <__copybits>:
 820d04c:	297fffc4 	addi	r5,r5,-1
 820d050:	280fd17a 	srai	r7,r5,5
 820d054:	30c00417 	ldw	r3,16(r6)
 820d058:	30800504 	addi	r2,r6,20
 820d05c:	39c00044 	addi	r7,r7,1
 820d060:	18c7883a 	add	r3,r3,r3
 820d064:	39cf883a 	add	r7,r7,r7
 820d068:	18c7883a 	add	r3,r3,r3
 820d06c:	39cf883a 	add	r7,r7,r7
 820d070:	10c7883a 	add	r3,r2,r3
 820d074:	21cf883a 	add	r7,r4,r7
 820d078:	10c00d2e 	bgeu	r2,r3,820d0b0 <__copybits+0x64>
 820d07c:	200b883a 	mov	r5,r4
 820d080:	12000017 	ldw	r8,0(r2)
 820d084:	29400104 	addi	r5,r5,4
 820d088:	10800104 	addi	r2,r2,4
 820d08c:	2a3fff15 	stw	r8,-4(r5)
 820d090:	10fffb36 	bltu	r2,r3,820d080 <__copybits+0x34>
 820d094:	1985c83a 	sub	r2,r3,r6
 820d098:	10bffac4 	addi	r2,r2,-21
 820d09c:	1004d0ba 	srli	r2,r2,2
 820d0a0:	10800044 	addi	r2,r2,1
 820d0a4:	1085883a 	add	r2,r2,r2
 820d0a8:	1085883a 	add	r2,r2,r2
 820d0ac:	2089883a 	add	r4,r4,r2
 820d0b0:	21c0032e 	bgeu	r4,r7,820d0c0 <__copybits+0x74>
 820d0b4:	20000015 	stw	zero,0(r4)
 820d0b8:	21000104 	addi	r4,r4,4
 820d0bc:	21fffd36 	bltu	r4,r7,820d0b4 <__copybits+0x68>
 820d0c0:	f800283a 	ret

0820d0c4 <__any_on>:
 820d0c4:	20c00417 	ldw	r3,16(r4)
 820d0c8:	2805d17a 	srai	r2,r5,5
 820d0cc:	21000504 	addi	r4,r4,20
 820d0d0:	18800d0e 	bge	r3,r2,820d108 <__any_on+0x44>
 820d0d4:	18c7883a 	add	r3,r3,r3
 820d0d8:	18c7883a 	add	r3,r3,r3
 820d0dc:	20c7883a 	add	r3,r4,r3
 820d0e0:	20c0192e 	bgeu	r4,r3,820d148 <__any_on+0x84>
 820d0e4:	18bfff17 	ldw	r2,-4(r3)
 820d0e8:	18ffff04 	addi	r3,r3,-4
 820d0ec:	1000041e 	bne	r2,zero,820d100 <__any_on+0x3c>
 820d0f0:	20c0142e 	bgeu	r4,r3,820d144 <__any_on+0x80>
 820d0f4:	18ffff04 	addi	r3,r3,-4
 820d0f8:	19400017 	ldw	r5,0(r3)
 820d0fc:	283ffc26 	beq	r5,zero,820d0f0 <__any_on+0x2c>
 820d100:	00800044 	movi	r2,1
 820d104:	f800283a 	ret
 820d108:	10c00a0e 	bge	r2,r3,820d134 <__any_on+0x70>
 820d10c:	1085883a 	add	r2,r2,r2
 820d110:	1085883a 	add	r2,r2,r2
 820d114:	294007cc 	andi	r5,r5,31
 820d118:	2087883a 	add	r3,r4,r2
 820d11c:	283ff026 	beq	r5,zero,820d0e0 <__any_on+0x1c>
 820d120:	19800017 	ldw	r6,0(r3)
 820d124:	3144d83a 	srl	r2,r6,r5
 820d128:	114a983a 	sll	r5,r2,r5
 820d12c:	317ff41e 	bne	r6,r5,820d100 <__any_on+0x3c>
 820d130:	003feb06 	br	820d0e0 <__any_on+0x1c>
 820d134:	1085883a 	add	r2,r2,r2
 820d138:	1085883a 	add	r2,r2,r2
 820d13c:	2087883a 	add	r3,r4,r2
 820d140:	003fe706 	br	820d0e0 <__any_on+0x1c>
 820d144:	f800283a 	ret
 820d148:	0005883a 	mov	r2,zero
 820d14c:	f800283a 	ret

0820d150 <_realloc_r>:
 820d150:	defff604 	addi	sp,sp,-40
 820d154:	dc800215 	stw	r18,8(sp)
 820d158:	dfc00915 	stw	ra,36(sp)
 820d15c:	df000815 	stw	fp,32(sp)
 820d160:	ddc00715 	stw	r23,28(sp)
 820d164:	dd800615 	stw	r22,24(sp)
 820d168:	dd400515 	stw	r21,20(sp)
 820d16c:	dd000415 	stw	r20,16(sp)
 820d170:	dcc00315 	stw	r19,12(sp)
 820d174:	dc400115 	stw	r17,4(sp)
 820d178:	dc000015 	stw	r16,0(sp)
 820d17c:	3025883a 	mov	r18,r6
 820d180:	2800b726 	beq	r5,zero,820d460 <_realloc_r+0x310>
 820d184:	282b883a 	mov	r21,r5
 820d188:	2029883a 	mov	r20,r4
 820d18c:	821462c0 	call	821462c <__malloc_lock>
 820d190:	a8bfff17 	ldw	r2,-4(r21)
 820d194:	043fff04 	movi	r16,-4
 820d198:	90c002c4 	addi	r3,r18,11
 820d19c:	01000584 	movi	r4,22
 820d1a0:	acfffe04 	addi	r19,r21,-8
 820d1a4:	1420703a 	and	r16,r2,r16
 820d1a8:	20c0332e 	bgeu	r4,r3,820d278 <_realloc_r+0x128>
 820d1ac:	047ffe04 	movi	r17,-8
 820d1b0:	1c62703a 	and	r17,r3,r17
 820d1b4:	8807883a 	mov	r3,r17
 820d1b8:	88005816 	blt	r17,zero,820d31c <_realloc_r+0x1cc>
 820d1bc:	8c805736 	bltu	r17,r18,820d31c <_realloc_r+0x1cc>
 820d1c0:	80c0300e 	bge	r16,r3,820d284 <_realloc_r+0x134>
 820d1c4:	07020974 	movhi	fp,2085
 820d1c8:	e707be04 	addi	fp,fp,7928
 820d1cc:	e1c00217 	ldw	r7,8(fp)
 820d1d0:	9c09883a 	add	r4,r19,r16
 820d1d4:	22000117 	ldw	r8,4(r4)
 820d1d8:	21c06326 	beq	r4,r7,820d368 <_realloc_r+0x218>
 820d1dc:	017fff84 	movi	r5,-2
 820d1e0:	414a703a 	and	r5,r8,r5
 820d1e4:	214b883a 	add	r5,r4,r5
 820d1e8:	29800117 	ldw	r6,4(r5)
 820d1ec:	3180004c 	andi	r6,r6,1
 820d1f0:	30003f26 	beq	r6,zero,820d2f0 <_realloc_r+0x1a0>
 820d1f4:	1080004c 	andi	r2,r2,1
 820d1f8:	10008326 	beq	r2,zero,820d408 <_realloc_r+0x2b8>
 820d1fc:	900b883a 	mov	r5,r18
 820d200:	a009883a 	mov	r4,r20
 820d204:	820b7e80 	call	820b7e8 <_malloc_r>
 820d208:	1025883a 	mov	r18,r2
 820d20c:	10011e26 	beq	r2,zero,820d688 <_realloc_r+0x538>
 820d210:	a93fff17 	ldw	r4,-4(r21)
 820d214:	10fffe04 	addi	r3,r2,-8
 820d218:	00bfff84 	movi	r2,-2
 820d21c:	2084703a 	and	r2,r4,r2
 820d220:	9885883a 	add	r2,r19,r2
 820d224:	1880ee26 	beq	r3,r2,820d5e0 <_realloc_r+0x490>
 820d228:	81bfff04 	addi	r6,r16,-4
 820d22c:	00800904 	movi	r2,36
 820d230:	1180b836 	bltu	r2,r6,820d514 <_realloc_r+0x3c4>
 820d234:	00c004c4 	movi	r3,19
 820d238:	19809636 	bltu	r3,r6,820d494 <_realloc_r+0x344>
 820d23c:	9005883a 	mov	r2,r18
 820d240:	a807883a 	mov	r3,r21
 820d244:	19000017 	ldw	r4,0(r3)
 820d248:	11000015 	stw	r4,0(r2)
 820d24c:	19000117 	ldw	r4,4(r3)
 820d250:	11000115 	stw	r4,4(r2)
 820d254:	18c00217 	ldw	r3,8(r3)
 820d258:	10c00215 	stw	r3,8(r2)
 820d25c:	a80b883a 	mov	r5,r21
 820d260:	a009883a 	mov	r4,r20
 820d264:	820abfc0 	call	820abfc <_free_r>
 820d268:	a009883a 	mov	r4,r20
 820d26c:	821474c0 	call	821474c <__malloc_unlock>
 820d270:	9005883a 	mov	r2,r18
 820d274:	00001206 	br	820d2c0 <_realloc_r+0x170>
 820d278:	00c00404 	movi	r3,16
 820d27c:	1823883a 	mov	r17,r3
 820d280:	003fce06 	br	820d1bc <_realloc_r+0x6c>
 820d284:	a825883a 	mov	r18,r21
 820d288:	8445c83a 	sub	r2,r16,r17
 820d28c:	00c003c4 	movi	r3,15
 820d290:	18802636 	bltu	r3,r2,820d32c <_realloc_r+0x1dc>
 820d294:	99800117 	ldw	r6,4(r19)
 820d298:	9c07883a 	add	r3,r19,r16
 820d29c:	3180004c 	andi	r6,r6,1
 820d2a0:	3420b03a 	or	r16,r6,r16
 820d2a4:	9c000115 	stw	r16,4(r19)
 820d2a8:	18800117 	ldw	r2,4(r3)
 820d2ac:	10800054 	ori	r2,r2,1
 820d2b0:	18800115 	stw	r2,4(r3)
 820d2b4:	a009883a 	mov	r4,r20
 820d2b8:	821474c0 	call	821474c <__malloc_unlock>
 820d2bc:	9005883a 	mov	r2,r18
 820d2c0:	dfc00917 	ldw	ra,36(sp)
 820d2c4:	df000817 	ldw	fp,32(sp)
 820d2c8:	ddc00717 	ldw	r23,28(sp)
 820d2cc:	dd800617 	ldw	r22,24(sp)
 820d2d0:	dd400517 	ldw	r21,20(sp)
 820d2d4:	dd000417 	ldw	r20,16(sp)
 820d2d8:	dcc00317 	ldw	r19,12(sp)
 820d2dc:	dc800217 	ldw	r18,8(sp)
 820d2e0:	dc400117 	ldw	r17,4(sp)
 820d2e4:	dc000017 	ldw	r16,0(sp)
 820d2e8:	dec00a04 	addi	sp,sp,40
 820d2ec:	f800283a 	ret
 820d2f0:	017fff04 	movi	r5,-4
 820d2f4:	414a703a 	and	r5,r8,r5
 820d2f8:	814d883a 	add	r6,r16,r5
 820d2fc:	30c01f16 	blt	r6,r3,820d37c <_realloc_r+0x22c>
 820d300:	20800317 	ldw	r2,12(r4)
 820d304:	20c00217 	ldw	r3,8(r4)
 820d308:	a825883a 	mov	r18,r21
 820d30c:	3021883a 	mov	r16,r6
 820d310:	18800315 	stw	r2,12(r3)
 820d314:	10c00215 	stw	r3,8(r2)
 820d318:	003fdb06 	br	820d288 <_realloc_r+0x138>
 820d31c:	00800304 	movi	r2,12
 820d320:	a0800015 	stw	r2,0(r20)
 820d324:	0005883a 	mov	r2,zero
 820d328:	003fe506 	br	820d2c0 <_realloc_r+0x170>
 820d32c:	98c00117 	ldw	r3,4(r19)
 820d330:	9c4b883a 	add	r5,r19,r17
 820d334:	11000054 	ori	r4,r2,1
 820d338:	18c0004c 	andi	r3,r3,1
 820d33c:	1c62b03a 	or	r17,r3,r17
 820d340:	9c400115 	stw	r17,4(r19)
 820d344:	29000115 	stw	r4,4(r5)
 820d348:	2885883a 	add	r2,r5,r2
 820d34c:	10c00117 	ldw	r3,4(r2)
 820d350:	29400204 	addi	r5,r5,8
 820d354:	a009883a 	mov	r4,r20
 820d358:	18c00054 	ori	r3,r3,1
 820d35c:	10c00115 	stw	r3,4(r2)
 820d360:	820abfc0 	call	820abfc <_free_r>
 820d364:	003fd306 	br	820d2b4 <_realloc_r+0x164>
 820d368:	017fff04 	movi	r5,-4
 820d36c:	414a703a 	and	r5,r8,r5
 820d370:	89800404 	addi	r6,r17,16
 820d374:	8151883a 	add	r8,r16,r5
 820d378:	4180590e 	bge	r8,r6,820d4e0 <_realloc_r+0x390>
 820d37c:	1080004c 	andi	r2,r2,1
 820d380:	103f9e1e 	bne	r2,zero,820d1fc <_realloc_r+0xac>
 820d384:	adbffe17 	ldw	r22,-8(r21)
 820d388:	00bfff04 	movi	r2,-4
 820d38c:	9dadc83a 	sub	r22,r19,r22
 820d390:	b1800117 	ldw	r6,4(r22)
 820d394:	3084703a 	and	r2,r6,r2
 820d398:	20002026 	beq	r4,zero,820d41c <_realloc_r+0x2cc>
 820d39c:	80af883a 	add	r23,r16,r2
 820d3a0:	b96f883a 	add	r23,r23,r5
 820d3a4:	21c05f26 	beq	r4,r7,820d524 <_realloc_r+0x3d4>
 820d3a8:	b8c01c16 	blt	r23,r3,820d41c <_realloc_r+0x2cc>
 820d3ac:	20800317 	ldw	r2,12(r4)
 820d3b0:	20c00217 	ldw	r3,8(r4)
 820d3b4:	81bfff04 	addi	r6,r16,-4
 820d3b8:	01000904 	movi	r4,36
 820d3bc:	18800315 	stw	r2,12(r3)
 820d3c0:	10c00215 	stw	r3,8(r2)
 820d3c4:	b0c00217 	ldw	r3,8(r22)
 820d3c8:	b0800317 	ldw	r2,12(r22)
 820d3cc:	b4800204 	addi	r18,r22,8
 820d3d0:	18800315 	stw	r2,12(r3)
 820d3d4:	10c00215 	stw	r3,8(r2)
 820d3d8:	21801b36 	bltu	r4,r6,820d448 <_realloc_r+0x2f8>
 820d3dc:	008004c4 	movi	r2,19
 820d3e0:	1180352e 	bgeu	r2,r6,820d4b8 <_realloc_r+0x368>
 820d3e4:	a8800017 	ldw	r2,0(r21)
 820d3e8:	b0800215 	stw	r2,8(r22)
 820d3ec:	a8800117 	ldw	r2,4(r21)
 820d3f0:	b0800315 	stw	r2,12(r22)
 820d3f4:	008006c4 	movi	r2,27
 820d3f8:	11807f36 	bltu	r2,r6,820d5f8 <_realloc_r+0x4a8>
 820d3fc:	b0800404 	addi	r2,r22,16
 820d400:	ad400204 	addi	r21,r21,8
 820d404:	00002d06 	br	820d4bc <_realloc_r+0x36c>
 820d408:	adbffe17 	ldw	r22,-8(r21)
 820d40c:	00bfff04 	movi	r2,-4
 820d410:	9dadc83a 	sub	r22,r19,r22
 820d414:	b1000117 	ldw	r4,4(r22)
 820d418:	2084703a 	and	r2,r4,r2
 820d41c:	b03f7726 	beq	r22,zero,820d1fc <_realloc_r+0xac>
 820d420:	80af883a 	add	r23,r16,r2
 820d424:	b8ff7516 	blt	r23,r3,820d1fc <_realloc_r+0xac>
 820d428:	b0800317 	ldw	r2,12(r22)
 820d42c:	b0c00217 	ldw	r3,8(r22)
 820d430:	81bfff04 	addi	r6,r16,-4
 820d434:	01000904 	movi	r4,36
 820d438:	18800315 	stw	r2,12(r3)
 820d43c:	10c00215 	stw	r3,8(r2)
 820d440:	b4800204 	addi	r18,r22,8
 820d444:	21bfe52e 	bgeu	r4,r6,820d3dc <_realloc_r+0x28c>
 820d448:	a80b883a 	mov	r5,r21
 820d44c:	9009883a 	mov	r4,r18
 820d450:	8202b540 	call	8202b54 <memmove>
 820d454:	b821883a 	mov	r16,r23
 820d458:	b027883a 	mov	r19,r22
 820d45c:	003f8a06 	br	820d288 <_realloc_r+0x138>
 820d460:	300b883a 	mov	r5,r6
 820d464:	dfc00917 	ldw	ra,36(sp)
 820d468:	df000817 	ldw	fp,32(sp)
 820d46c:	ddc00717 	ldw	r23,28(sp)
 820d470:	dd800617 	ldw	r22,24(sp)
 820d474:	dd400517 	ldw	r21,20(sp)
 820d478:	dd000417 	ldw	r20,16(sp)
 820d47c:	dcc00317 	ldw	r19,12(sp)
 820d480:	dc800217 	ldw	r18,8(sp)
 820d484:	dc400117 	ldw	r17,4(sp)
 820d488:	dc000017 	ldw	r16,0(sp)
 820d48c:	dec00a04 	addi	sp,sp,40
 820d490:	820b7e81 	jmpi	820b7e8 <_malloc_r>
 820d494:	a8c00017 	ldw	r3,0(r21)
 820d498:	90c00015 	stw	r3,0(r18)
 820d49c:	a8c00117 	ldw	r3,4(r21)
 820d4a0:	90c00115 	stw	r3,4(r18)
 820d4a4:	00c006c4 	movi	r3,27
 820d4a8:	19804536 	bltu	r3,r6,820d5c0 <_realloc_r+0x470>
 820d4ac:	90800204 	addi	r2,r18,8
 820d4b0:	a8c00204 	addi	r3,r21,8
 820d4b4:	003f6306 	br	820d244 <_realloc_r+0xf4>
 820d4b8:	9005883a 	mov	r2,r18
 820d4bc:	a8c00017 	ldw	r3,0(r21)
 820d4c0:	b821883a 	mov	r16,r23
 820d4c4:	b027883a 	mov	r19,r22
 820d4c8:	10c00015 	stw	r3,0(r2)
 820d4cc:	a8c00117 	ldw	r3,4(r21)
 820d4d0:	10c00115 	stw	r3,4(r2)
 820d4d4:	a8c00217 	ldw	r3,8(r21)
 820d4d8:	10c00215 	stw	r3,8(r2)
 820d4dc:	003f6a06 	br	820d288 <_realloc_r+0x138>
 820d4e0:	9c67883a 	add	r19,r19,r17
 820d4e4:	4445c83a 	sub	r2,r8,r17
 820d4e8:	e4c00215 	stw	r19,8(fp)
 820d4ec:	10800054 	ori	r2,r2,1
 820d4f0:	98800115 	stw	r2,4(r19)
 820d4f4:	a8bfff17 	ldw	r2,-4(r21)
 820d4f8:	a009883a 	mov	r4,r20
 820d4fc:	1080004c 	andi	r2,r2,1
 820d500:	1462b03a 	or	r17,r2,r17
 820d504:	ac7fff15 	stw	r17,-4(r21)
 820d508:	821474c0 	call	821474c <__malloc_unlock>
 820d50c:	a805883a 	mov	r2,r21
 820d510:	003f6b06 	br	820d2c0 <_realloc_r+0x170>
 820d514:	a80b883a 	mov	r5,r21
 820d518:	9009883a 	mov	r4,r18
 820d51c:	8202b540 	call	8202b54 <memmove>
 820d520:	003f4e06 	br	820d25c <_realloc_r+0x10c>
 820d524:	89000404 	addi	r4,r17,16
 820d528:	b93fbc16 	blt	r23,r4,820d41c <_realloc_r+0x2cc>
 820d52c:	b0800317 	ldw	r2,12(r22)
 820d530:	b0c00217 	ldw	r3,8(r22)
 820d534:	81bfff04 	addi	r6,r16,-4
 820d538:	01000904 	movi	r4,36
 820d53c:	18800315 	stw	r2,12(r3)
 820d540:	10c00215 	stw	r3,8(r2)
 820d544:	b4800204 	addi	r18,r22,8
 820d548:	21804336 	bltu	r4,r6,820d658 <_realloc_r+0x508>
 820d54c:	008004c4 	movi	r2,19
 820d550:	11803f2e 	bgeu	r2,r6,820d650 <_realloc_r+0x500>
 820d554:	a8800017 	ldw	r2,0(r21)
 820d558:	b0800215 	stw	r2,8(r22)
 820d55c:	a8800117 	ldw	r2,4(r21)
 820d560:	b0800315 	stw	r2,12(r22)
 820d564:	008006c4 	movi	r2,27
 820d568:	11803f36 	bltu	r2,r6,820d668 <_realloc_r+0x518>
 820d56c:	b0800404 	addi	r2,r22,16
 820d570:	ad400204 	addi	r21,r21,8
 820d574:	a8c00017 	ldw	r3,0(r21)
 820d578:	10c00015 	stw	r3,0(r2)
 820d57c:	a8c00117 	ldw	r3,4(r21)
 820d580:	10c00115 	stw	r3,4(r2)
 820d584:	a8c00217 	ldw	r3,8(r21)
 820d588:	10c00215 	stw	r3,8(r2)
 820d58c:	b447883a 	add	r3,r22,r17
 820d590:	bc45c83a 	sub	r2,r23,r17
 820d594:	e0c00215 	stw	r3,8(fp)
 820d598:	10800054 	ori	r2,r2,1
 820d59c:	18800115 	stw	r2,4(r3)
 820d5a0:	b0800117 	ldw	r2,4(r22)
 820d5a4:	a009883a 	mov	r4,r20
 820d5a8:	1080004c 	andi	r2,r2,1
 820d5ac:	1462b03a 	or	r17,r2,r17
 820d5b0:	b4400115 	stw	r17,4(r22)
 820d5b4:	821474c0 	call	821474c <__malloc_unlock>
 820d5b8:	9005883a 	mov	r2,r18
 820d5bc:	003f4006 	br	820d2c0 <_realloc_r+0x170>
 820d5c0:	a8c00217 	ldw	r3,8(r21)
 820d5c4:	90c00215 	stw	r3,8(r18)
 820d5c8:	a8c00317 	ldw	r3,12(r21)
 820d5cc:	90c00315 	stw	r3,12(r18)
 820d5d0:	30801126 	beq	r6,r2,820d618 <_realloc_r+0x4c8>
 820d5d4:	90800404 	addi	r2,r18,16
 820d5d8:	a8c00404 	addi	r3,r21,16
 820d5dc:	003f1906 	br	820d244 <_realloc_r+0xf4>
 820d5e0:	90ffff17 	ldw	r3,-4(r18)
 820d5e4:	00bfff04 	movi	r2,-4
 820d5e8:	a825883a 	mov	r18,r21
 820d5ec:	1884703a 	and	r2,r3,r2
 820d5f0:	80a1883a 	add	r16,r16,r2
 820d5f4:	003f2406 	br	820d288 <_realloc_r+0x138>
 820d5f8:	a8800217 	ldw	r2,8(r21)
 820d5fc:	b0800415 	stw	r2,16(r22)
 820d600:	a8800317 	ldw	r2,12(r21)
 820d604:	b0800515 	stw	r2,20(r22)
 820d608:	31000a26 	beq	r6,r4,820d634 <_realloc_r+0x4e4>
 820d60c:	b0800604 	addi	r2,r22,24
 820d610:	ad400404 	addi	r21,r21,16
 820d614:	003fa906 	br	820d4bc <_realloc_r+0x36c>
 820d618:	a9000417 	ldw	r4,16(r21)
 820d61c:	90800604 	addi	r2,r18,24
 820d620:	a8c00604 	addi	r3,r21,24
 820d624:	91000415 	stw	r4,16(r18)
 820d628:	a9000517 	ldw	r4,20(r21)
 820d62c:	91000515 	stw	r4,20(r18)
 820d630:	003f0406 	br	820d244 <_realloc_r+0xf4>
 820d634:	a8c00417 	ldw	r3,16(r21)
 820d638:	ad400604 	addi	r21,r21,24
 820d63c:	b0800804 	addi	r2,r22,32
 820d640:	b0c00615 	stw	r3,24(r22)
 820d644:	a8ffff17 	ldw	r3,-4(r21)
 820d648:	b0c00715 	stw	r3,28(r22)
 820d64c:	003f9b06 	br	820d4bc <_realloc_r+0x36c>
 820d650:	9005883a 	mov	r2,r18
 820d654:	003fc706 	br	820d574 <_realloc_r+0x424>
 820d658:	a80b883a 	mov	r5,r21
 820d65c:	9009883a 	mov	r4,r18
 820d660:	8202b540 	call	8202b54 <memmove>
 820d664:	003fc906 	br	820d58c <_realloc_r+0x43c>
 820d668:	a8800217 	ldw	r2,8(r21)
 820d66c:	b0800415 	stw	r2,16(r22)
 820d670:	a8800317 	ldw	r2,12(r21)
 820d674:	b0800515 	stw	r2,20(r22)
 820d678:	31000726 	beq	r6,r4,820d698 <_realloc_r+0x548>
 820d67c:	b0800604 	addi	r2,r22,24
 820d680:	ad400404 	addi	r21,r21,16
 820d684:	003fbb06 	br	820d574 <_realloc_r+0x424>
 820d688:	a009883a 	mov	r4,r20
 820d68c:	821474c0 	call	821474c <__malloc_unlock>
 820d690:	0005883a 	mov	r2,zero
 820d694:	003f0a06 	br	820d2c0 <_realloc_r+0x170>
 820d698:	a8c00417 	ldw	r3,16(r21)
 820d69c:	ad400604 	addi	r21,r21,24
 820d6a0:	b0800804 	addi	r2,r22,32
 820d6a4:	b0c00615 	stw	r3,24(r22)
 820d6a8:	a8ffff17 	ldw	r3,-4(r21)
 820d6ac:	b0c00715 	stw	r3,28(r22)
 820d6b0:	003fb006 	br	820d574 <_realloc_r+0x424>

0820d6b4 <lflush>:
 820d6b4:	2080030b 	ldhu	r2,12(r4)
 820d6b8:	00c00244 	movi	r3,9
 820d6bc:	1080024c 	andi	r2,r2,9
 820d6c0:	10c00226 	beq	r2,r3,820d6cc <lflush+0x18>
 820d6c4:	0005883a 	mov	r2,zero
 820d6c8:	f800283a 	ret
 820d6cc:	820a5b41 	jmpi	820a5b4 <fflush>

0820d6d0 <__srefill_r>:
 820d6d0:	defffc04 	addi	sp,sp,-16
 820d6d4:	dc400115 	stw	r17,4(sp)
 820d6d8:	dc000015 	stw	r16,0(sp)
 820d6dc:	dfc00315 	stw	ra,12(sp)
 820d6e0:	dc800215 	stw	r18,8(sp)
 820d6e4:	2023883a 	mov	r17,r4
 820d6e8:	2821883a 	mov	r16,r5
 820d6ec:	20000226 	beq	r4,zero,820d6f8 <__srefill_r+0x28>
 820d6f0:	20800e17 	ldw	r2,56(r4)
 820d6f4:	10003c26 	beq	r2,zero,820d7e8 <__srefill_r+0x118>
 820d6f8:	80c0030b 	ldhu	r3,12(r16)
 820d6fc:	1908000c 	andi	r4,r3,8192
 820d700:	1805883a 	mov	r2,r3
 820d704:	2000071e 	bne	r4,zero,820d724 <__srefill_r+0x54>
 820d708:	81001917 	ldw	r4,100(r16)
 820d70c:	18880014 	ori	r2,r3,8192
 820d710:	00f7ffc4 	movi	r3,-8193
 820d714:	20c8703a 	and	r4,r4,r3
 820d718:	8080030d 	sth	r2,12(r16)
 820d71c:	1007883a 	mov	r3,r2
 820d720:	81001915 	stw	r4,100(r16)
 820d724:	80000115 	stw	zero,4(r16)
 820d728:	1100080c 	andi	r4,r2,32
 820d72c:	2000571e 	bne	r4,zero,820d88c <__srefill_r+0x1bc>
 820d730:	1100010c 	andi	r4,r2,4
 820d734:	20001f26 	beq	r4,zero,820d7b4 <__srefill_r+0xe4>
 820d738:	81400c17 	ldw	r5,48(r16)
 820d73c:	28000826 	beq	r5,zero,820d760 <__srefill_r+0x90>
 820d740:	80801004 	addi	r2,r16,64
 820d744:	28800226 	beq	r5,r2,820d750 <__srefill_r+0x80>
 820d748:	8809883a 	mov	r4,r17
 820d74c:	820abfc0 	call	820abfc <_free_r>
 820d750:	80800f17 	ldw	r2,60(r16)
 820d754:	80000c15 	stw	zero,48(r16)
 820d758:	80800115 	stw	r2,4(r16)
 820d75c:	1000391e 	bne	r2,zero,820d844 <__srefill_r+0x174>
 820d760:	80800417 	ldw	r2,16(r16)
 820d764:	10004b26 	beq	r2,zero,820d894 <__srefill_r+0x1c4>
 820d768:	8480030b 	ldhu	r18,12(r16)
 820d76c:	908000cc 	andi	r2,r18,3
 820d770:	10001f1e 	bne	r2,zero,820d7f0 <__srefill_r+0x120>
 820d774:	81800417 	ldw	r6,16(r16)
 820d778:	80800817 	ldw	r2,32(r16)
 820d77c:	81c00517 	ldw	r7,20(r16)
 820d780:	81400717 	ldw	r5,28(r16)
 820d784:	81800015 	stw	r6,0(r16)
 820d788:	8809883a 	mov	r4,r17
 820d78c:	103ee83a 	callr	r2
 820d790:	80800115 	stw	r2,4(r16)
 820d794:	00800e0e 	bge	zero,r2,820d7d0 <__srefill_r+0x100>
 820d798:	0005883a 	mov	r2,zero
 820d79c:	dfc00317 	ldw	ra,12(sp)
 820d7a0:	dc800217 	ldw	r18,8(sp)
 820d7a4:	dc400117 	ldw	r17,4(sp)
 820d7a8:	dc000017 	ldw	r16,0(sp)
 820d7ac:	dec00404 	addi	sp,sp,16
 820d7b0:	f800283a 	ret
 820d7b4:	1100040c 	andi	r4,r2,16
 820d7b8:	20003026 	beq	r4,zero,820d87c <__srefill_r+0x1ac>
 820d7bc:	1080020c 	andi	r2,r2,8
 820d7c0:	1000241e 	bne	r2,zero,820d854 <__srefill_r+0x184>
 820d7c4:	18c00114 	ori	r3,r3,4
 820d7c8:	80c0030d 	sth	r3,12(r16)
 820d7cc:	003fe406 	br	820d760 <__srefill_r+0x90>
 820d7d0:	80c0030b 	ldhu	r3,12(r16)
 820d7d4:	1000161e 	bne	r2,zero,820d830 <__srefill_r+0x160>
 820d7d8:	18c00814 	ori	r3,r3,32
 820d7dc:	00bfffc4 	movi	r2,-1
 820d7e0:	80c0030d 	sth	r3,12(r16)
 820d7e4:	003fed06 	br	820d79c <__srefill_r+0xcc>
 820d7e8:	820a9340 	call	820a934 <__sinit>
 820d7ec:	003fc206 	br	820d6f8 <__srefill_r+0x28>
 820d7f0:	00820974 	movhi	r2,2085
 820d7f4:	108e2f04 	addi	r2,r2,14524
 820d7f8:	11000017 	ldw	r4,0(r2)
 820d7fc:	01420874 	movhi	r5,2081
 820d800:	00800044 	movi	r2,1
 820d804:	2975ad04 	addi	r5,r5,-10572
 820d808:	8080030d 	sth	r2,12(r16)
 820d80c:	820b3c80 	call	820b3c8 <_fwalk>
 820d810:	00800244 	movi	r2,9
 820d814:	8480030d 	sth	r18,12(r16)
 820d818:	9480024c 	andi	r18,r18,9
 820d81c:	90bfd51e 	bne	r18,r2,820d774 <__srefill_r+0xa4>
 820d820:	800b883a 	mov	r5,r16
 820d824:	8809883a 	mov	r4,r17
 820d828:	820a33c0 	call	820a33c <__sflush_r>
 820d82c:	003fd106 	br	820d774 <__srefill_r+0xa4>
 820d830:	18c01014 	ori	r3,r3,64
 820d834:	80000115 	stw	zero,4(r16)
 820d838:	00bfffc4 	movi	r2,-1
 820d83c:	80c0030d 	sth	r3,12(r16)
 820d840:	003fd606 	br	820d79c <__srefill_r+0xcc>
 820d844:	80c00e17 	ldw	r3,56(r16)
 820d848:	0005883a 	mov	r2,zero
 820d84c:	80c00015 	stw	r3,0(r16)
 820d850:	003fd206 	br	820d79c <__srefill_r+0xcc>
 820d854:	800b883a 	mov	r5,r16
 820d858:	8809883a 	mov	r4,r17
 820d85c:	820a5580 	call	820a558 <_fflush_r>
 820d860:	10000a1e 	bne	r2,zero,820d88c <__srefill_r+0x1bc>
 820d864:	8080030b 	ldhu	r2,12(r16)
 820d868:	00fffdc4 	movi	r3,-9
 820d86c:	80000215 	stw	zero,8(r16)
 820d870:	1886703a 	and	r3,r3,r2
 820d874:	80000615 	stw	zero,24(r16)
 820d878:	003fd206 	br	820d7c4 <__srefill_r+0xf4>
 820d87c:	00800244 	movi	r2,9
 820d880:	88800015 	stw	r2,0(r17)
 820d884:	18c01014 	ori	r3,r3,64
 820d888:	80c0030d 	sth	r3,12(r16)
 820d88c:	00bfffc4 	movi	r2,-1
 820d890:	003fc206 	br	820d79c <__srefill_r+0xcc>
 820d894:	800b883a 	mov	r5,r16
 820d898:	8809883a 	mov	r4,r17
 820d89c:	820b62c0 	call	820b62c <__smakebuf_r>
 820d8a0:	003fb106 	br	820d768 <__srefill_r+0x98>

0820d8a4 <__fpclassifyd>:
 820d8a4:	00a00034 	movhi	r2,32768
 820d8a8:	10bfffc4 	addi	r2,r2,-1
 820d8ac:	2884703a 	and	r2,r5,r2
 820d8b0:	10000726 	beq	r2,zero,820d8d0 <__fpclassifyd+0x2c>
 820d8b4:	00fffc34 	movhi	r3,65520
 820d8b8:	019ff834 	movhi	r6,32736
 820d8bc:	28c7883a 	add	r3,r5,r3
 820d8c0:	31bfffc4 	addi	r6,r6,-1
 820d8c4:	30c00536 	bltu	r6,r3,820d8dc <__fpclassifyd+0x38>
 820d8c8:	00800104 	movi	r2,4
 820d8cc:	f800283a 	ret
 820d8d0:	2000021e 	bne	r4,zero,820d8dc <__fpclassifyd+0x38>
 820d8d4:	00800084 	movi	r2,2
 820d8d8:	f800283a 	ret
 820d8dc:	00dffc34 	movhi	r3,32752
 820d8e0:	019ff834 	movhi	r6,32736
 820d8e4:	28cb883a 	add	r5,r5,r3
 820d8e8:	31bfffc4 	addi	r6,r6,-1
 820d8ec:	317ff62e 	bgeu	r6,r5,820d8c8 <__fpclassifyd+0x24>
 820d8f0:	01400434 	movhi	r5,16
 820d8f4:	297fffc4 	addi	r5,r5,-1
 820d8f8:	28800236 	bltu	r5,r2,820d904 <__fpclassifyd+0x60>
 820d8fc:	008000c4 	movi	r2,3
 820d900:	f800283a 	ret
 820d904:	10c00226 	beq	r2,r3,820d910 <__fpclassifyd+0x6c>
 820d908:	0005883a 	mov	r2,zero
 820d90c:	f800283a 	ret
 820d910:	2005003a 	cmpeq	r2,r4,zero
 820d914:	f800283a 	ret

0820d918 <_sbrk_r>:
 820d918:	defffd04 	addi	sp,sp,-12
 820d91c:	dc000015 	stw	r16,0(sp)
 820d920:	04020974 	movhi	r16,2085
 820d924:	dc400115 	stw	r17,4(sp)
 820d928:	840e9104 	addi	r16,r16,14916
 820d92c:	2023883a 	mov	r17,r4
 820d930:	2809883a 	mov	r4,r5
 820d934:	dfc00215 	stw	ra,8(sp)
 820d938:	80000015 	stw	zero,0(r16)
 820d93c:	82143200 	call	8214320 <sbrk>
 820d940:	00ffffc4 	movi	r3,-1
 820d944:	10c00526 	beq	r2,r3,820d95c <_sbrk_r+0x44>
 820d948:	dfc00217 	ldw	ra,8(sp)
 820d94c:	dc400117 	ldw	r17,4(sp)
 820d950:	dc000017 	ldw	r16,0(sp)
 820d954:	dec00304 	addi	sp,sp,12
 820d958:	f800283a 	ret
 820d95c:	80c00017 	ldw	r3,0(r16)
 820d960:	183ff926 	beq	r3,zero,820d948 <_sbrk_r+0x30>
 820d964:	88c00015 	stw	r3,0(r17)
 820d968:	003ff706 	br	820d948 <_sbrk_r+0x30>

0820d96c <__sread>:
 820d96c:	defffe04 	addi	sp,sp,-8
 820d970:	dc000015 	stw	r16,0(sp)
 820d974:	2821883a 	mov	r16,r5
 820d978:	2940038f 	ldh	r5,14(r5)
 820d97c:	dfc00115 	stw	ra,4(sp)
 820d980:	8210b6c0 	call	8210b6c <_read_r>
 820d984:	10000716 	blt	r2,zero,820d9a4 <__sread+0x38>
 820d988:	80c01417 	ldw	r3,80(r16)
 820d98c:	1887883a 	add	r3,r3,r2
 820d990:	80c01415 	stw	r3,80(r16)
 820d994:	dfc00117 	ldw	ra,4(sp)
 820d998:	dc000017 	ldw	r16,0(sp)
 820d99c:	dec00204 	addi	sp,sp,8
 820d9a0:	f800283a 	ret
 820d9a4:	80c0030b 	ldhu	r3,12(r16)
 820d9a8:	18fbffcc 	andi	r3,r3,61439
 820d9ac:	80c0030d 	sth	r3,12(r16)
 820d9b0:	dfc00117 	ldw	ra,4(sp)
 820d9b4:	dc000017 	ldw	r16,0(sp)
 820d9b8:	dec00204 	addi	sp,sp,8
 820d9bc:	f800283a 	ret

0820d9c0 <__seofread>:
 820d9c0:	0005883a 	mov	r2,zero
 820d9c4:	f800283a 	ret

0820d9c8 <__swrite>:
 820d9c8:	2880030b 	ldhu	r2,12(r5)
 820d9cc:	defffb04 	addi	sp,sp,-20
 820d9d0:	dcc00315 	stw	r19,12(sp)
 820d9d4:	dc800215 	stw	r18,8(sp)
 820d9d8:	dc400115 	stw	r17,4(sp)
 820d9dc:	dc000015 	stw	r16,0(sp)
 820d9e0:	dfc00415 	stw	ra,16(sp)
 820d9e4:	10c0400c 	andi	r3,r2,256
 820d9e8:	2821883a 	mov	r16,r5
 820d9ec:	2023883a 	mov	r17,r4
 820d9f0:	3025883a 	mov	r18,r6
 820d9f4:	3827883a 	mov	r19,r7
 820d9f8:	18000526 	beq	r3,zero,820da10 <__swrite+0x48>
 820d9fc:	2940038f 	ldh	r5,14(r5)
 820da00:	01c00084 	movi	r7,2
 820da04:	000d883a 	mov	r6,zero
 820da08:	8210b0c0 	call	8210b0c <_lseek_r>
 820da0c:	8080030b 	ldhu	r2,12(r16)
 820da10:	8140038f 	ldh	r5,14(r16)
 820da14:	10bbffcc 	andi	r2,r2,61439
 820da18:	980f883a 	mov	r7,r19
 820da1c:	900d883a 	mov	r6,r18
 820da20:	8809883a 	mov	r4,r17
 820da24:	8080030d 	sth	r2,12(r16)
 820da28:	dfc00417 	ldw	ra,16(sp)
 820da2c:	dcc00317 	ldw	r19,12(sp)
 820da30:	dc800217 	ldw	r18,8(sp)
 820da34:	dc400117 	ldw	r17,4(sp)
 820da38:	dc000017 	ldw	r16,0(sp)
 820da3c:	dec00504 	addi	sp,sp,20
 820da40:	82105d81 	jmpi	82105d8 <_write_r>

0820da44 <__sseek>:
 820da44:	defffe04 	addi	sp,sp,-8
 820da48:	dc000015 	stw	r16,0(sp)
 820da4c:	2821883a 	mov	r16,r5
 820da50:	2940038f 	ldh	r5,14(r5)
 820da54:	dfc00115 	stw	ra,4(sp)
 820da58:	8210b0c0 	call	8210b0c <_lseek_r>
 820da5c:	00ffffc4 	movi	r3,-1
 820da60:	10c00826 	beq	r2,r3,820da84 <__sseek+0x40>
 820da64:	80c0030b 	ldhu	r3,12(r16)
 820da68:	80801415 	stw	r2,80(r16)
 820da6c:	18c40014 	ori	r3,r3,4096
 820da70:	80c0030d 	sth	r3,12(r16)
 820da74:	dfc00117 	ldw	ra,4(sp)
 820da78:	dc000017 	ldw	r16,0(sp)
 820da7c:	dec00204 	addi	sp,sp,8
 820da80:	f800283a 	ret
 820da84:	80c0030b 	ldhu	r3,12(r16)
 820da88:	18fbffcc 	andi	r3,r3,61439
 820da8c:	80c0030d 	sth	r3,12(r16)
 820da90:	dfc00117 	ldw	ra,4(sp)
 820da94:	dc000017 	ldw	r16,0(sp)
 820da98:	dec00204 	addi	sp,sp,8
 820da9c:	f800283a 	ret

0820daa0 <__sclose>:
 820daa0:	2940038f 	ldh	r5,14(r5)
 820daa4:	82106381 	jmpi	8210638 <_close_r>

0820daa8 <strcmp>:
 820daa8:	2144b03a 	or	r2,r4,r5
 820daac:	108000cc 	andi	r2,r2,3
 820dab0:	1000171e 	bne	r2,zero,820db10 <strcmp+0x68>
 820dab4:	20800017 	ldw	r2,0(r4)
 820dab8:	28c00017 	ldw	r3,0(r5)
 820dabc:	10c0141e 	bne	r2,r3,820db10 <strcmp+0x68>
 820dac0:	027fbff4 	movhi	r9,65279
 820dac4:	4a7fbfc4 	addi	r9,r9,-257
 820dac8:	0086303a 	nor	r3,zero,r2
 820dacc:	02202074 	movhi	r8,32897
 820dad0:	1245883a 	add	r2,r2,r9
 820dad4:	42202004 	addi	r8,r8,-32640
 820dad8:	10c4703a 	and	r2,r2,r3
 820dadc:	1204703a 	and	r2,r2,r8
 820dae0:	10000226 	beq	r2,zero,820daec <strcmp+0x44>
 820dae4:	00002306 	br	820db74 <strcmp+0xcc>
 820dae8:	1000221e 	bne	r2,zero,820db74 <strcmp+0xcc>
 820daec:	21000104 	addi	r4,r4,4
 820daf0:	20c00017 	ldw	r3,0(r4)
 820daf4:	29400104 	addi	r5,r5,4
 820daf8:	29800017 	ldw	r6,0(r5)
 820dafc:	1a4f883a 	add	r7,r3,r9
 820db00:	00c4303a 	nor	r2,zero,r3
 820db04:	3884703a 	and	r2,r7,r2
 820db08:	1204703a 	and	r2,r2,r8
 820db0c:	19bff626 	beq	r3,r6,820dae8 <strcmp+0x40>
 820db10:	20800003 	ldbu	r2,0(r4)
 820db14:	10c03fcc 	andi	r3,r2,255
 820db18:	18c0201c 	xori	r3,r3,128
 820db1c:	18ffe004 	addi	r3,r3,-128
 820db20:	18000c26 	beq	r3,zero,820db54 <strcmp+0xac>
 820db24:	29800007 	ldb	r6,0(r5)
 820db28:	19800326 	beq	r3,r6,820db38 <strcmp+0x90>
 820db2c:	00001306 	br	820db7c <strcmp+0xd4>
 820db30:	29800007 	ldb	r6,0(r5)
 820db34:	11800b1e 	bne	r2,r6,820db64 <strcmp+0xbc>
 820db38:	21000044 	addi	r4,r4,1
 820db3c:	20c00003 	ldbu	r3,0(r4)
 820db40:	29400044 	addi	r5,r5,1
 820db44:	18803fcc 	andi	r2,r3,255
 820db48:	1080201c 	xori	r2,r2,128
 820db4c:	10bfe004 	addi	r2,r2,-128
 820db50:	103ff71e 	bne	r2,zero,820db30 <strcmp+0x88>
 820db54:	0007883a 	mov	r3,zero
 820db58:	28800003 	ldbu	r2,0(r5)
 820db5c:	1885c83a 	sub	r2,r3,r2
 820db60:	f800283a 	ret
 820db64:	28800003 	ldbu	r2,0(r5)
 820db68:	18c03fcc 	andi	r3,r3,255
 820db6c:	1885c83a 	sub	r2,r3,r2
 820db70:	f800283a 	ret
 820db74:	0005883a 	mov	r2,zero
 820db78:	f800283a 	ret
 820db7c:	10c03fcc 	andi	r3,r2,255
 820db80:	003ff506 	br	820db58 <strcmp+0xb0>

0820db84 <__ssprint_r>:
 820db84:	30800217 	ldw	r2,8(r6)
 820db88:	defff604 	addi	sp,sp,-40
 820db8c:	dc800215 	stw	r18,8(sp)
 820db90:	dfc00915 	stw	ra,36(sp)
 820db94:	df000815 	stw	fp,32(sp)
 820db98:	ddc00715 	stw	r23,28(sp)
 820db9c:	dd800615 	stw	r22,24(sp)
 820dba0:	dd400515 	stw	r21,20(sp)
 820dba4:	dd000415 	stw	r20,16(sp)
 820dba8:	dcc00315 	stw	r19,12(sp)
 820dbac:	dc400115 	stw	r17,4(sp)
 820dbb0:	dc000015 	stw	r16,0(sp)
 820dbb4:	3025883a 	mov	r18,r6
 820dbb8:	10005826 	beq	r2,zero,820dd1c <__ssprint_r+0x198>
 820dbbc:	2027883a 	mov	r19,r4
 820dbc0:	35c00017 	ldw	r23,0(r6)
 820dbc4:	29000017 	ldw	r4,0(r5)
 820dbc8:	28800217 	ldw	r2,8(r5)
 820dbcc:	2823883a 	mov	r17,r5
 820dbd0:	0039883a 	mov	fp,zero
 820dbd4:	0021883a 	mov	r16,zero
 820dbd8:	80003926 	beq	r16,zero,820dcc0 <__ssprint_r+0x13c>
 820dbdc:	102b883a 	mov	r21,r2
 820dbe0:	102d883a 	mov	r22,r2
 820dbe4:	80803a36 	bltu	r16,r2,820dcd0 <__ssprint_r+0x14c>
 820dbe8:	88c0030b 	ldhu	r3,12(r17)
 820dbec:	1881200c 	andi	r2,r3,1152
 820dbf0:	10002626 	beq	r2,zero,820dc8c <__ssprint_r+0x108>
 820dbf4:	88800517 	ldw	r2,20(r17)
 820dbf8:	89400417 	ldw	r5,16(r17)
 820dbfc:	81800044 	addi	r6,r16,1
 820dc00:	108f883a 	add	r7,r2,r2
 820dc04:	3885883a 	add	r2,r7,r2
 820dc08:	100ed7fa 	srli	r7,r2,31
 820dc0c:	216dc83a 	sub	r22,r4,r5
 820dc10:	3589883a 	add	r4,r6,r22
 820dc14:	3885883a 	add	r2,r7,r2
 820dc18:	102bd07a 	srai	r21,r2,1
 820dc1c:	a80d883a 	mov	r6,r21
 820dc20:	a900022e 	bgeu	r21,r4,820dc2c <__ssprint_r+0xa8>
 820dc24:	202b883a 	mov	r21,r4
 820dc28:	200d883a 	mov	r6,r4
 820dc2c:	18c1000c 	andi	r3,r3,1024
 820dc30:	18002a26 	beq	r3,zero,820dcdc <__ssprint_r+0x158>
 820dc34:	300b883a 	mov	r5,r6
 820dc38:	9809883a 	mov	r4,r19
 820dc3c:	820b7e80 	call	820b7e8 <_malloc_r>
 820dc40:	1029883a 	mov	r20,r2
 820dc44:	10002c26 	beq	r2,zero,820dcf8 <__ssprint_r+0x174>
 820dc48:	89400417 	ldw	r5,16(r17)
 820dc4c:	b00d883a 	mov	r6,r22
 820dc50:	1009883a 	mov	r4,r2
 820dc54:	8202a0c0 	call	8202a0c <memcpy>
 820dc58:	8880030b 	ldhu	r2,12(r17)
 820dc5c:	00fedfc4 	movi	r3,-1153
 820dc60:	10c4703a 	and	r2,r2,r3
 820dc64:	10802014 	ori	r2,r2,128
 820dc68:	8880030d 	sth	r2,12(r17)
 820dc6c:	a589883a 	add	r4,r20,r22
 820dc70:	adadc83a 	sub	r22,r21,r22
 820dc74:	8d400515 	stw	r21,20(r17)
 820dc78:	8d800215 	stw	r22,8(r17)
 820dc7c:	8d000415 	stw	r20,16(r17)
 820dc80:	89000015 	stw	r4,0(r17)
 820dc84:	802b883a 	mov	r21,r16
 820dc88:	802d883a 	mov	r22,r16
 820dc8c:	b00d883a 	mov	r6,r22
 820dc90:	e00b883a 	mov	r5,fp
 820dc94:	8202b540 	call	8202b54 <memmove>
 820dc98:	88800217 	ldw	r2,8(r17)
 820dc9c:	89000017 	ldw	r4,0(r17)
 820dca0:	90c00217 	ldw	r3,8(r18)
 820dca4:	1545c83a 	sub	r2,r2,r21
 820dca8:	2589883a 	add	r4,r4,r22
 820dcac:	88800215 	stw	r2,8(r17)
 820dcb0:	89000015 	stw	r4,0(r17)
 820dcb4:	1c21c83a 	sub	r16,r3,r16
 820dcb8:	94000215 	stw	r16,8(r18)
 820dcbc:	80001726 	beq	r16,zero,820dd1c <__ssprint_r+0x198>
 820dcc0:	bf000017 	ldw	fp,0(r23)
 820dcc4:	bc000117 	ldw	r16,4(r23)
 820dcc8:	bdc00204 	addi	r23,r23,8
 820dccc:	003fc206 	br	820dbd8 <__ssprint_r+0x54>
 820dcd0:	802b883a 	mov	r21,r16
 820dcd4:	802d883a 	mov	r22,r16
 820dcd8:	003fec06 	br	820dc8c <__ssprint_r+0x108>
 820dcdc:	9809883a 	mov	r4,r19
 820dce0:	820d1500 	call	820d150 <_realloc_r>
 820dce4:	1029883a 	mov	r20,r2
 820dce8:	103fe01e 	bne	r2,zero,820dc6c <__ssprint_r+0xe8>
 820dcec:	89400417 	ldw	r5,16(r17)
 820dcf0:	9809883a 	mov	r4,r19
 820dcf4:	820abfc0 	call	820abfc <_free_r>
 820dcf8:	88c0030b 	ldhu	r3,12(r17)
 820dcfc:	00800304 	movi	r2,12
 820dd00:	98800015 	stw	r2,0(r19)
 820dd04:	18c01014 	ori	r3,r3,64
 820dd08:	88c0030d 	sth	r3,12(r17)
 820dd0c:	00bfffc4 	movi	r2,-1
 820dd10:	90000215 	stw	zero,8(r18)
 820dd14:	90000115 	stw	zero,4(r18)
 820dd18:	00000206 	br	820dd24 <__ssprint_r+0x1a0>
 820dd1c:	90000115 	stw	zero,4(r18)
 820dd20:	0005883a 	mov	r2,zero
 820dd24:	dfc00917 	ldw	ra,36(sp)
 820dd28:	df000817 	ldw	fp,32(sp)
 820dd2c:	ddc00717 	ldw	r23,28(sp)
 820dd30:	dd800617 	ldw	r22,24(sp)
 820dd34:	dd400517 	ldw	r21,20(sp)
 820dd38:	dd000417 	ldw	r20,16(sp)
 820dd3c:	dcc00317 	ldw	r19,12(sp)
 820dd40:	dc800217 	ldw	r18,8(sp)
 820dd44:	dc400117 	ldw	r17,4(sp)
 820dd48:	dc000017 	ldw	r16,0(sp)
 820dd4c:	dec00a04 	addi	sp,sp,40
 820dd50:	f800283a 	ret

0820dd54 <___svfiprintf_internal_r>:
 820dd54:	2880030b 	ldhu	r2,12(r5)
 820dd58:	deffc804 	addi	sp,sp,-224
 820dd5c:	dcc03115 	stw	r19,196(sp)
 820dd60:	dfc03715 	stw	ra,220(sp)
 820dd64:	df003615 	stw	fp,216(sp)
 820dd68:	ddc03515 	stw	r23,212(sp)
 820dd6c:	dd803415 	stw	r22,208(sp)
 820dd70:	dd403315 	stw	r21,204(sp)
 820dd74:	dd003215 	stw	r20,200(sp)
 820dd78:	dc803015 	stw	r18,192(sp)
 820dd7c:	dc402f15 	stw	r17,188(sp)
 820dd80:	dc002e15 	stw	r16,184(sp)
 820dd84:	d9402715 	stw	r5,156(sp)
 820dd88:	d9002a15 	stw	r4,168(sp)
 820dd8c:	1080200c 	andi	r2,r2,128
 820dd90:	d9c02315 	stw	r7,140(sp)
 820dd94:	3027883a 	mov	r19,r6
 820dd98:	10000226 	beq	r2,zero,820dda4 <___svfiprintf_internal_r+0x50>
 820dd9c:	28800417 	ldw	r2,16(r5)
 820dda0:	10041d26 	beq	r2,zero,820ee18 <___svfiprintf_internal_r+0x10c4>
 820dda4:	dac01a04 	addi	r11,sp,104
 820dda8:	dac01e15 	stw	r11,120(sp)
 820ddac:	d8801e17 	ldw	r2,120(sp)
 820ddb0:	dac019c4 	addi	r11,sp,103
 820ddb4:	dd402a17 	ldw	r21,168(sp)
 820ddb8:	ddc02717 	ldw	r23,156(sp)
 820ddbc:	05820974 	movhi	r22,2085
 820ddc0:	05020974 	movhi	r20,2085
 820ddc4:	dac01f15 	stw	r11,124(sp)
 820ddc8:	12d7c83a 	sub	r11,r2,r11
 820ddcc:	b5b5c604 	addi	r22,r22,-10472
 820ddd0:	a535c204 	addi	r20,r20,-10488
 820ddd4:	dec01a15 	stw	sp,104(sp)
 820ddd8:	d8001c15 	stw	zero,112(sp)
 820dddc:	d8001b15 	stw	zero,108(sp)
 820dde0:	d811883a 	mov	r8,sp
 820dde4:	d8002915 	stw	zero,164(sp)
 820dde8:	d8002515 	stw	zero,148(sp)
 820ddec:	dac02b15 	stw	r11,172(sp)
 820ddf0:	98800007 	ldb	r2,0(r19)
 820ddf4:	1002dd26 	beq	r2,zero,820e96c <___svfiprintf_internal_r+0xc18>
 820ddf8:	00c00944 	movi	r3,37
 820ddfc:	9823883a 	mov	r17,r19
 820de00:	10c0021e 	bne	r2,r3,820de0c <___svfiprintf_internal_r+0xb8>
 820de04:	00001406 	br	820de58 <___svfiprintf_internal_r+0x104>
 820de08:	10c00326 	beq	r2,r3,820de18 <___svfiprintf_internal_r+0xc4>
 820de0c:	8c400044 	addi	r17,r17,1
 820de10:	88800007 	ldb	r2,0(r17)
 820de14:	103ffc1e 	bne	r2,zero,820de08 <___svfiprintf_internal_r+0xb4>
 820de18:	8ce1c83a 	sub	r16,r17,r19
 820de1c:	80000e26 	beq	r16,zero,820de58 <___svfiprintf_internal_r+0x104>
 820de20:	d8c01c17 	ldw	r3,112(sp)
 820de24:	d8801b17 	ldw	r2,108(sp)
 820de28:	44c00015 	stw	r19,0(r8)
 820de2c:	1c07883a 	add	r3,r3,r16
 820de30:	10800044 	addi	r2,r2,1
 820de34:	d8c01c15 	stw	r3,112(sp)
 820de38:	44000115 	stw	r16,4(r8)
 820de3c:	d8801b15 	stw	r2,108(sp)
 820de40:	00c001c4 	movi	r3,7
 820de44:	18831e16 	blt	r3,r2,820eac0 <___svfiprintf_internal_r+0xd6c>
 820de48:	42000204 	addi	r8,r8,8
 820de4c:	dac02517 	ldw	r11,148(sp)
 820de50:	5c17883a 	add	r11,r11,r16
 820de54:	dac02515 	stw	r11,148(sp)
 820de58:	88800007 	ldb	r2,0(r17)
 820de5c:	1002c526 	beq	r2,zero,820e974 <___svfiprintf_internal_r+0xc20>
 820de60:	88c00047 	ldb	r3,1(r17)
 820de64:	8cc00044 	addi	r19,r17,1
 820de68:	d8001d85 	stb	zero,118(sp)
 820de6c:	0009883a 	mov	r4,zero
 820de70:	000f883a 	mov	r7,zero
 820de74:	043fffc4 	movi	r16,-1
 820de78:	d8002415 	stw	zero,144(sp)
 820de7c:	0025883a 	mov	r18,zero
 820de80:	01401604 	movi	r5,88
 820de84:	01800244 	movi	r6,9
 820de88:	02800a84 	movi	r10,42
 820de8c:	02401b04 	movi	r9,108
 820de90:	9cc00044 	addi	r19,r19,1
 820de94:	18bff804 	addi	r2,r3,-32
 820de98:	2881dd36 	bltu	r5,r2,820e610 <___svfiprintf_internal_r+0x8bc>
 820de9c:	100490ba 	slli	r2,r2,2
 820dea0:	02c20874 	movhi	r11,2081
 820dea4:	5af7ad04 	addi	r11,r11,-8524
 820dea8:	12c5883a 	add	r2,r2,r11
 820deac:	10800017 	ldw	r2,0(r2)
 820deb0:	1000683a 	jmp	r2
 820deb4:	0820e0b0 	cmpltui	zero,at,33666
 820deb8:	0820e610 	cmplti	zero,at,-31848
 820debc:	0820e610 	cmplti	zero,at,-31848
 820dec0:	0820e0a4 	muli	zero,at,-31870
 820dec4:	0820e610 	cmplti	zero,at,-31848
 820dec8:	0820e610 	cmplti	zero,at,-31848
 820decc:	0820e610 	cmplti	zero,at,-31848
 820ded0:	0820e610 	cmplti	zero,at,-31848
 820ded4:	0820e610 	cmplti	zero,at,-31848
 820ded8:	0820e610 	cmplti	zero,at,-31848
 820dedc:	0820e018 	cmpnei	zero,at,-31872
 820dee0:	0820e1f4 	orhi	zero,at,33671
 820dee4:	0820e610 	cmplti	zero,at,-31848
 820dee8:	0820e044 	addi	zero,at,-31871
 820deec:	0820e644 	addi	zero,at,-31847
 820def0:	0820e610 	cmplti	zero,at,-31848
 820def4:	0820e638 	rdprs	zero,at,-31848
 820def8:	0820e5d8 	cmpnei	zero,at,-31849
 820defc:	0820e5d8 	cmpnei	zero,at,-31849
 820df00:	0820e5d8 	cmpnei	zero,at,-31849
 820df04:	0820e5d8 	cmpnei	zero,at,-31849
 820df08:	0820e5d8 	cmpnei	zero,at,-31849
 820df0c:	0820e5d8 	cmpnei	zero,at,-31849
 820df10:	0820e5d8 	cmpnei	zero,at,-31849
 820df14:	0820e5d8 	cmpnei	zero,at,-31849
 820df18:	0820e5d8 	cmpnei	zero,at,-31849
 820df1c:	0820e610 	cmplti	zero,at,-31848
 820df20:	0820e610 	cmplti	zero,at,-31848
 820df24:	0820e610 	cmplti	zero,at,-31848
 820df28:	0820e610 	cmplti	zero,at,-31848
 820df2c:	0820e610 	cmplti	zero,at,-31848
 820df30:	0820e610 	cmplti	zero,at,-31848
 820df34:	0820e610 	cmplti	zero,at,-31848
 820df38:	0820e610 	cmplti	zero,at,-31848
 820df3c:	0820e610 	cmplti	zero,at,-31848
 820df40:	0820e610 	cmplti	zero,at,-31848
 820df44:	0820e574 	orhi	zero,at,33685
 820df48:	0820e610 	cmplti	zero,at,-31848
 820df4c:	0820e610 	cmplti	zero,at,-31848
 820df50:	0820e610 	cmplti	zero,at,-31848
 820df54:	0820e610 	cmplti	zero,at,-31848
 820df58:	0820e610 	cmplti	zero,at,-31848
 820df5c:	0820e610 	cmplti	zero,at,-31848
 820df60:	0820e610 	cmplti	zero,at,-31848
 820df64:	0820e610 	cmplti	zero,at,-31848
 820df68:	0820e610 	cmplti	zero,at,-31848
 820df6c:	0820e610 	cmplti	zero,at,-31848
 820df70:	0820e6ec 	andhi	zero,at,33691
 820df74:	0820e610 	cmplti	zero,at,-31848
 820df78:	0820e610 	cmplti	zero,at,-31848
 820df7c:	0820e610 	cmplti	zero,at,-31848
 820df80:	0820e610 	cmplti	zero,at,-31848
 820df84:	0820e610 	cmplti	zero,at,-31848
 820df88:	0820e684 	addi	zero,at,-31846
 820df8c:	0820e610 	cmplti	zero,at,-31848
 820df90:	0820e610 	cmplti	zero,at,-31848
 820df94:	0820e3b8 	rdprs	zero,at,-31858
 820df98:	0820e610 	cmplti	zero,at,-31848
 820df9c:	0820e610 	cmplti	zero,at,-31848
 820dfa0:	0820e610 	cmplti	zero,at,-31848
 820dfa4:	0820e610 	cmplti	zero,at,-31848
 820dfa8:	0820e610 	cmplti	zero,at,-31848
 820dfac:	0820e610 	cmplti	zero,at,-31848
 820dfb0:	0820e610 	cmplti	zero,at,-31848
 820dfb4:	0820e610 	cmplti	zero,at,-31848
 820dfb8:	0820e610 	cmplti	zero,at,-31848
 820dfbc:	0820e610 	cmplti	zero,at,-31848
 820dfc0:	0820e2a8 	cmpgeui	zero,at,33674
 820dfc4:	0820e454 	ori	zero,at,33681
 820dfc8:	0820e610 	cmplti	zero,at,-31848
 820dfcc:	0820e610 	cmplti	zero,at,-31848
 820dfd0:	0820e610 	cmplti	zero,at,-31848
 820dfd4:	0820e448 	cmpgei	zero,at,-31855
 820dfd8:	0820e454 	ori	zero,at,33681
 820dfdc:	0820e610 	cmplti	zero,at,-31848
 820dfe0:	0820e610 	cmplti	zero,at,-31848
 820dfe4:	0820e438 	rdprs	zero,at,-31856
 820dfe8:	0820e610 	cmplti	zero,at,-31848
 820dfec:	0820e3fc 	xorhi	zero,at,33679
 820dff0:	0820e204 	addi	zero,at,-31864
 820dff4:	0820e050 	cmplti	zero,at,-31871
 820dff8:	0820e568 	cmpgeui	zero,at,33685
 820dffc:	0820e610 	cmplti	zero,at,-31848
 820e000:	0820e51c 	xori	zero,at,33684
 820e004:	0820e610 	cmplti	zero,at,-31848
 820e008:	0820e174 	orhi	zero,at,33669
 820e00c:	0820e610 	cmplti	zero,at,-31848
 820e010:	0820e610 	cmplti	zero,at,-31848
 820e014:	0820e0d0 	cmplti	zero,at,-31869
 820e018:	dac02317 	ldw	r11,140(sp)
 820e01c:	5ac00017 	ldw	r11,0(r11)
 820e020:	dac02415 	stw	r11,144(sp)
 820e024:	dac02317 	ldw	r11,140(sp)
 820e028:	58800104 	addi	r2,r11,4
 820e02c:	dac02417 	ldw	r11,144(sp)
 820e030:	5802e90e 	bge	r11,zero,820ebd8 <___svfiprintf_internal_r+0xe84>
 820e034:	dac02417 	ldw	r11,144(sp)
 820e038:	d8802315 	stw	r2,140(sp)
 820e03c:	02d7c83a 	sub	r11,zero,r11
 820e040:	dac02415 	stw	r11,144(sp)
 820e044:	94800114 	ori	r18,r18,4
 820e048:	98c00007 	ldb	r3,0(r19)
 820e04c:	003f9006 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e050:	00800c04 	movi	r2,48
 820e054:	dac02317 	ldw	r11,140(sp)
 820e058:	d8801d05 	stb	r2,116(sp)
 820e05c:	00801e04 	movi	r2,120
 820e060:	d8801d45 	stb	r2,117(sp)
 820e064:	d8001d85 	stb	zero,118(sp)
 820e068:	58c00104 	addi	r3,r11,4
 820e06c:	5f000017 	ldw	fp,0(r11)
 820e070:	0013883a 	mov	r9,zero
 820e074:	90800094 	ori	r2,r18,2
 820e078:	80032b16 	blt	r16,zero,820ed28 <___svfiprintf_internal_r+0xfd4>
 820e07c:	00bfdfc4 	movi	r2,-129
 820e080:	90a4703a 	and	r18,r18,r2
 820e084:	d8c02315 	stw	r3,140(sp)
 820e088:	94800094 	ori	r18,r18,2
 820e08c:	e002dc26 	beq	fp,zero,820ec00 <___svfiprintf_internal_r+0xeac>
 820e090:	01020974 	movhi	r4,2085
 820e094:	21355a04 	addi	r4,r4,-10904
 820e098:	0015883a 	mov	r10,zero
 820e09c:	d9002915 	stw	r4,164(sp)
 820e0a0:	00002306 	br	820e130 <___svfiprintf_internal_r+0x3dc>
 820e0a4:	94800054 	ori	r18,r18,1
 820e0a8:	98c00007 	ldb	r3,0(r19)
 820e0ac:	003f7806 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e0b0:	38803fcc 	andi	r2,r7,255
 820e0b4:	1080201c 	xori	r2,r2,128
 820e0b8:	10bfe004 	addi	r2,r2,-128
 820e0bc:	1002f31e 	bne	r2,zero,820ec8c <___svfiprintf_internal_r+0xf38>
 820e0c0:	01000044 	movi	r4,1
 820e0c4:	01c00804 	movi	r7,32
 820e0c8:	98c00007 	ldb	r3,0(r19)
 820e0cc:	003f7006 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e0d0:	21003fcc 	andi	r4,r4,255
 820e0d4:	2003aa1e 	bne	r4,zero,820ef80 <___svfiprintf_internal_r+0x122c>
 820e0d8:	00820974 	movhi	r2,2085
 820e0dc:	10b55a04 	addi	r2,r2,-10904
 820e0e0:	d8802915 	stw	r2,164(sp)
 820e0e4:	9080080c 	andi	r2,r18,32
 820e0e8:	1000ba26 	beq	r2,zero,820e3d4 <___svfiprintf_internal_r+0x680>
 820e0ec:	dac02317 	ldw	r11,140(sp)
 820e0f0:	5f000017 	ldw	fp,0(r11)
 820e0f4:	5a400117 	ldw	r9,4(r11)
 820e0f8:	5ac00204 	addi	r11,r11,8
 820e0fc:	dac02315 	stw	r11,140(sp)
 820e100:	9080004c 	andi	r2,r18,1
 820e104:	10029026 	beq	r2,zero,820eb48 <___svfiprintf_internal_r+0xdf4>
 820e108:	e244b03a 	or	r2,fp,r9
 820e10c:	1002d41e 	bne	r2,zero,820ec60 <___svfiprintf_internal_r+0xf0c>
 820e110:	d8001d85 	stb	zero,118(sp)
 820e114:	80030b16 	blt	r16,zero,820ed44 <___svfiprintf_internal_r+0xff0>
 820e118:	00bfdfc4 	movi	r2,-129
 820e11c:	90a4703a 	and	r18,r18,r2
 820e120:	0015883a 	mov	r10,zero
 820e124:	80002426 	beq	r16,zero,820e1b8 <___svfiprintf_internal_r+0x464>
 820e128:	0039883a 	mov	fp,zero
 820e12c:	0013883a 	mov	r9,zero
 820e130:	d9002917 	ldw	r4,164(sp)
 820e134:	dc401a04 	addi	r17,sp,104
 820e138:	e08003cc 	andi	r2,fp,15
 820e13c:	4806973a 	slli	r3,r9,28
 820e140:	2085883a 	add	r2,r4,r2
 820e144:	e038d13a 	srli	fp,fp,4
 820e148:	10800003 	ldbu	r2,0(r2)
 820e14c:	4812d13a 	srli	r9,r9,4
 820e150:	8c7fffc4 	addi	r17,r17,-1
 820e154:	1f38b03a 	or	fp,r3,fp
 820e158:	88800005 	stb	r2,0(r17)
 820e15c:	e244b03a 	or	r2,fp,r9
 820e160:	103ff51e 	bne	r2,zero,820e138 <___svfiprintf_internal_r+0x3e4>
 820e164:	dac01e17 	ldw	r11,120(sp)
 820e168:	5c57c83a 	sub	r11,r11,r17
 820e16c:	dac02115 	stw	r11,132(sp)
 820e170:	00001406 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820e174:	21003fcc 	andi	r4,r4,255
 820e178:	2003741e 	bne	r4,zero,820ef4c <___svfiprintf_internal_r+0x11f8>
 820e17c:	9080080c 	andi	r2,r18,32
 820e180:	10014526 	beq	r2,zero,820e698 <___svfiprintf_internal_r+0x944>
 820e184:	dac02317 	ldw	r11,140(sp)
 820e188:	d8001d85 	stb	zero,118(sp)
 820e18c:	58c00204 	addi	r3,r11,8
 820e190:	5f000017 	ldw	fp,0(r11)
 820e194:	5a400117 	ldw	r9,4(r11)
 820e198:	8002d916 	blt	r16,zero,820ed00 <___svfiprintf_internal_r+0xfac>
 820e19c:	013fdfc4 	movi	r4,-129
 820e1a0:	e244b03a 	or	r2,fp,r9
 820e1a4:	d8c02315 	stw	r3,140(sp)
 820e1a8:	9124703a 	and	r18,r18,r4
 820e1ac:	0015883a 	mov	r10,zero
 820e1b0:	1000b91e 	bne	r2,zero,820e498 <___svfiprintf_internal_r+0x744>
 820e1b4:	8002e61e 	bne	r16,zero,820ed50 <___svfiprintf_internal_r+0xffc>
 820e1b8:	0021883a 	mov	r16,zero
 820e1bc:	d8002115 	stw	zero,132(sp)
 820e1c0:	dc401a04 	addi	r17,sp,104
 820e1c4:	d8c02117 	ldw	r3,132(sp)
 820e1c8:	dc002015 	stw	r16,128(sp)
 820e1cc:	80c0010e 	bge	r16,r3,820e1d4 <___svfiprintf_internal_r+0x480>
 820e1d0:	d8c02015 	stw	r3,128(sp)
 820e1d4:	52803fcc 	andi	r10,r10,255
 820e1d8:	5280201c 	xori	r10,r10,128
 820e1dc:	52bfe004 	addi	r10,r10,-128
 820e1e0:	50003c26 	beq	r10,zero,820e2d4 <___svfiprintf_internal_r+0x580>
 820e1e4:	dac02017 	ldw	r11,128(sp)
 820e1e8:	5ac00044 	addi	r11,r11,1
 820e1ec:	dac02015 	stw	r11,128(sp)
 820e1f0:	00003806 	br	820e2d4 <___svfiprintf_internal_r+0x580>
 820e1f4:	01000044 	movi	r4,1
 820e1f8:	01c00ac4 	movi	r7,43
 820e1fc:	98c00007 	ldb	r3,0(r19)
 820e200:	003f2306 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e204:	21003fcc 	andi	r4,r4,255
 820e208:	2003481e 	bne	r4,zero,820ef2c <___svfiprintf_internal_r+0x11d8>
 820e20c:	9080080c 	andi	r2,r18,32
 820e210:	10013b26 	beq	r2,zero,820e700 <___svfiprintf_internal_r+0x9ac>
 820e214:	dac02317 	ldw	r11,140(sp)
 820e218:	d8001d85 	stb	zero,118(sp)
 820e21c:	58800204 	addi	r2,r11,8
 820e220:	5f000017 	ldw	fp,0(r11)
 820e224:	5a400117 	ldw	r9,4(r11)
 820e228:	8002a816 	blt	r16,zero,820eccc <___svfiprintf_internal_r+0xf78>
 820e22c:	013fdfc4 	movi	r4,-129
 820e230:	e246b03a 	or	r3,fp,r9
 820e234:	d8802315 	stw	r2,140(sp)
 820e238:	9124703a 	and	r18,r18,r4
 820e23c:	18013c26 	beq	r3,zero,820e730 <___svfiprintf_internal_r+0x9dc>
 820e240:	0015883a 	mov	r10,zero
 820e244:	dc401a04 	addi	r17,sp,104
 820e248:	e006d0fa 	srli	r3,fp,3
 820e24c:	4808977a 	slli	r4,r9,29
 820e250:	4812d0fa 	srli	r9,r9,3
 820e254:	e70001cc 	andi	fp,fp,7
 820e258:	e0800c04 	addi	r2,fp,48
 820e25c:	8c7fffc4 	addi	r17,r17,-1
 820e260:	20f8b03a 	or	fp,r4,r3
 820e264:	88800005 	stb	r2,0(r17)
 820e268:	e246b03a 	or	r3,fp,r9
 820e26c:	183ff61e 	bne	r3,zero,820e248 <___svfiprintf_internal_r+0x4f4>
 820e270:	90c0004c 	andi	r3,r18,1
 820e274:	1800a526 	beq	r3,zero,820e50c <___svfiprintf_internal_r+0x7b8>
 820e278:	10803fcc 	andi	r2,r2,255
 820e27c:	1080201c 	xori	r2,r2,128
 820e280:	10bfe004 	addi	r2,r2,-128
 820e284:	00c00c04 	movi	r3,48
 820e288:	10ffb626 	beq	r2,r3,820e164 <___svfiprintf_internal_r+0x410>
 820e28c:	88ffffc5 	stb	r3,-1(r17)
 820e290:	d8c01e17 	ldw	r3,120(sp)
 820e294:	88bfffc4 	addi	r2,r17,-1
 820e298:	1023883a 	mov	r17,r2
 820e29c:	1887c83a 	sub	r3,r3,r2
 820e2a0:	d8c02115 	stw	r3,132(sp)
 820e2a4:	003fc706 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820e2a8:	dac02317 	ldw	r11,140(sp)
 820e2ac:	00c00044 	movi	r3,1
 820e2b0:	d8c02015 	stw	r3,128(sp)
 820e2b4:	58800017 	ldw	r2,0(r11)
 820e2b8:	5ac00104 	addi	r11,r11,4
 820e2bc:	d8001d85 	stb	zero,118(sp)
 820e2c0:	d8801005 	stb	r2,64(sp)
 820e2c4:	dac02315 	stw	r11,140(sp)
 820e2c8:	d8c02115 	stw	r3,132(sp)
 820e2cc:	dc401004 	addi	r17,sp,64
 820e2d0:	0021883a 	mov	r16,zero
 820e2d4:	90c0008c 	andi	r3,r18,2
 820e2d8:	d8c02215 	stw	r3,136(sp)
 820e2dc:	18000326 	beq	r3,zero,820e2ec <___svfiprintf_internal_r+0x598>
 820e2e0:	dac02017 	ldw	r11,128(sp)
 820e2e4:	5ac00084 	addi	r11,r11,2
 820e2e8:	dac02015 	stw	r11,128(sp)
 820e2ec:	90c0210c 	andi	r3,r18,132
 820e2f0:	d8c02615 	stw	r3,152(sp)
 820e2f4:	1801131e 	bne	r3,zero,820e744 <___svfiprintf_internal_r+0x9f0>
 820e2f8:	dac02417 	ldw	r11,144(sp)
 820e2fc:	d8c02017 	ldw	r3,128(sp)
 820e300:	58f9c83a 	sub	fp,r11,r3
 820e304:	07010f0e 	bge	zero,fp,820e744 <___svfiprintf_internal_r+0x9f0>
 820e308:	02400404 	movi	r9,16
 820e30c:	d8c01c17 	ldw	r3,112(sp)
 820e310:	d8801b17 	ldw	r2,108(sp)
 820e314:	4f02d60e 	bge	r9,fp,820ee70 <___svfiprintf_internal_r+0x111c>
 820e318:	01420974 	movhi	r5,2085
 820e31c:	2975c604 	addi	r5,r5,-10472
 820e320:	d9402815 	stw	r5,160(sp)
 820e324:	028001c4 	movi	r10,7
 820e328:	00000306 	br	820e338 <___svfiprintf_internal_r+0x5e4>
 820e32c:	e73ffc04 	addi	fp,fp,-16
 820e330:	42000204 	addi	r8,r8,8
 820e334:	4f00150e 	bge	r9,fp,820e38c <___svfiprintf_internal_r+0x638>
 820e338:	18c00404 	addi	r3,r3,16
 820e33c:	10800044 	addi	r2,r2,1
 820e340:	45800015 	stw	r22,0(r8)
 820e344:	42400115 	stw	r9,4(r8)
 820e348:	d8c01c15 	stw	r3,112(sp)
 820e34c:	d8801b15 	stw	r2,108(sp)
 820e350:	50bff60e 	bge	r10,r2,820e32c <___svfiprintf_internal_r+0x5d8>
 820e354:	d9801a04 	addi	r6,sp,104
 820e358:	b80b883a 	mov	r5,r23
 820e35c:	a809883a 	mov	r4,r21
 820e360:	da402c15 	stw	r9,176(sp)
 820e364:	da802d15 	stw	r10,180(sp)
 820e368:	820db840 	call	820db84 <__ssprint_r>
 820e36c:	da402c17 	ldw	r9,176(sp)
 820e370:	da802d17 	ldw	r10,180(sp)
 820e374:	1001851e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820e378:	e73ffc04 	addi	fp,fp,-16
 820e37c:	d8c01c17 	ldw	r3,112(sp)
 820e380:	d8801b17 	ldw	r2,108(sp)
 820e384:	d811883a 	mov	r8,sp
 820e388:	4f3feb16 	blt	r9,fp,820e338 <___svfiprintf_internal_r+0x5e4>
 820e38c:	dac02817 	ldw	r11,160(sp)
 820e390:	e0c7883a 	add	r3,fp,r3
 820e394:	10800044 	addi	r2,r2,1
 820e398:	42c00015 	stw	r11,0(r8)
 820e39c:	47000115 	stw	fp,4(r8)
 820e3a0:	d8c01c15 	stw	r3,112(sp)
 820e3a4:	d8801b15 	stw	r2,108(sp)
 820e3a8:	010001c4 	movi	r4,7
 820e3ac:	2081ee16 	blt	r4,r2,820eb68 <___svfiprintf_internal_r+0xe14>
 820e3b0:	42000204 	addi	r8,r8,8
 820e3b4:	0000e506 	br	820e74c <___svfiprintf_internal_r+0x9f8>
 820e3b8:	21003fcc 	andi	r4,r4,255
 820e3bc:	2002dd1e 	bne	r4,zero,820ef34 <___svfiprintf_internal_r+0x11e0>
 820e3c0:	00820974 	movhi	r2,2085
 820e3c4:	10b55504 	addi	r2,r2,-10924
 820e3c8:	d8802915 	stw	r2,164(sp)
 820e3cc:	9080080c 	andi	r2,r18,32
 820e3d0:	103f461e 	bne	r2,zero,820e0ec <___svfiprintf_internal_r+0x398>
 820e3d4:	9080040c 	andi	r2,r18,16
 820e3d8:	10022e1e 	bne	r2,zero,820ec94 <___svfiprintf_internal_r+0xf40>
 820e3dc:	9080100c 	andi	r2,r18,64
 820e3e0:	dac02317 	ldw	r11,140(sp)
 820e3e4:	10027326 	beq	r2,zero,820edb4 <___svfiprintf_internal_r+0x1060>
 820e3e8:	5f00000b 	ldhu	fp,0(r11)
 820e3ec:	5ac00104 	addi	r11,r11,4
 820e3f0:	0013883a 	mov	r9,zero
 820e3f4:	dac02315 	stw	r11,140(sp)
 820e3f8:	003f4106 	br	820e100 <___svfiprintf_internal_r+0x3ac>
 820e3fc:	21003fcc 	andi	r4,r4,255
 820e400:	2002e11e 	bne	r4,zero,820ef88 <___svfiprintf_internal_r+0x1234>
 820e404:	9080080c 	andi	r2,r18,32
 820e408:	1002011e 	bne	r2,zero,820ec10 <___svfiprintf_internal_r+0xebc>
 820e40c:	9080040c 	andi	r2,r18,16
 820e410:	10023e1e 	bne	r2,zero,820ed0c <___svfiprintf_internal_r+0xfb8>
 820e414:	9480100c 	andi	r18,r18,64
 820e418:	90023c26 	beq	r18,zero,820ed0c <___svfiprintf_internal_r+0xfb8>
 820e41c:	dac02317 	ldw	r11,140(sp)
 820e420:	58800017 	ldw	r2,0(r11)
 820e424:	5ac00104 	addi	r11,r11,4
 820e428:	dac02315 	stw	r11,140(sp)
 820e42c:	dac02517 	ldw	r11,148(sp)
 820e430:	12c0000d 	sth	r11,0(r2)
 820e434:	003e6e06 	br	820ddf0 <___svfiprintf_internal_r+0x9c>
 820e438:	98c00007 	ldb	r3,0(r19)
 820e43c:	1a422926 	beq	r3,r9,820ece4 <___svfiprintf_internal_r+0xf90>
 820e440:	94800414 	ori	r18,r18,16
 820e444:	003e9206 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e448:	94801014 	ori	r18,r18,64
 820e44c:	98c00007 	ldb	r3,0(r19)
 820e450:	003e8f06 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e454:	21003fcc 	andi	r4,r4,255
 820e458:	2002c71e 	bne	r4,zero,820ef78 <___svfiprintf_internal_r+0x1224>
 820e45c:	9080080c 	andi	r2,r18,32
 820e460:	10004926 	beq	r2,zero,820e588 <___svfiprintf_internal_r+0x834>
 820e464:	dac02317 	ldw	r11,140(sp)
 820e468:	58800117 	ldw	r2,4(r11)
 820e46c:	5f000017 	ldw	fp,0(r11)
 820e470:	5ac00204 	addi	r11,r11,8
 820e474:	dac02315 	stw	r11,140(sp)
 820e478:	1013883a 	mov	r9,r2
 820e47c:	10004b16 	blt	r2,zero,820e5ac <___svfiprintf_internal_r+0x858>
 820e480:	da801d83 	ldbu	r10,118(sp)
 820e484:	8001cb16 	blt	r16,zero,820ebb4 <___svfiprintf_internal_r+0xe60>
 820e488:	00ffdfc4 	movi	r3,-129
 820e48c:	e244b03a 	or	r2,fp,r9
 820e490:	90e4703a 	and	r18,r18,r3
 820e494:	103f4726 	beq	r2,zero,820e1b4 <___svfiprintf_internal_r+0x460>
 820e498:	48008c26 	beq	r9,zero,820e6cc <___svfiprintf_internal_r+0x978>
 820e49c:	dc802015 	stw	r18,128(sp)
 820e4a0:	dc002115 	stw	r16,132(sp)
 820e4a4:	dc401a04 	addi	r17,sp,104
 820e4a8:	e021883a 	mov	r16,fp
 820e4ac:	da002215 	stw	r8,136(sp)
 820e4b0:	5039883a 	mov	fp,r10
 820e4b4:	4825883a 	mov	r18,r9
 820e4b8:	8009883a 	mov	r4,r16
 820e4bc:	900b883a 	mov	r5,r18
 820e4c0:	01800284 	movi	r6,10
 820e4c4:	000f883a 	mov	r7,zero
 820e4c8:	821132c0 	call	821132c <__umoddi3>
 820e4cc:	10800c04 	addi	r2,r2,48
 820e4d0:	8c7fffc4 	addi	r17,r17,-1
 820e4d4:	8009883a 	mov	r4,r16
 820e4d8:	900b883a 	mov	r5,r18
 820e4dc:	88800005 	stb	r2,0(r17)
 820e4e0:	01800284 	movi	r6,10
 820e4e4:	000f883a 	mov	r7,zero
 820e4e8:	8210db40 	call	8210db4 <__udivdi3>
 820e4ec:	1021883a 	mov	r16,r2
 820e4f0:	10c4b03a 	or	r2,r2,r3
 820e4f4:	1825883a 	mov	r18,r3
 820e4f8:	103fef1e 	bne	r2,zero,820e4b8 <___svfiprintf_internal_r+0x764>
 820e4fc:	dc802017 	ldw	r18,128(sp)
 820e500:	dc002117 	ldw	r16,132(sp)
 820e504:	da002217 	ldw	r8,136(sp)
 820e508:	e015883a 	mov	r10,fp
 820e50c:	d8c01e17 	ldw	r3,120(sp)
 820e510:	1c47c83a 	sub	r3,r3,r17
 820e514:	d8c02115 	stw	r3,132(sp)
 820e518:	003f2a06 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820e51c:	dac02317 	ldw	r11,140(sp)
 820e520:	d8001d85 	stb	zero,118(sp)
 820e524:	5c400017 	ldw	r17,0(r11)
 820e528:	5f000104 	addi	fp,r11,4
 820e52c:	88022f26 	beq	r17,zero,820edec <___svfiprintf_internal_r+0x1098>
 820e530:	80022516 	blt	r16,zero,820edc8 <___svfiprintf_internal_r+0x1074>
 820e534:	800d883a 	mov	r6,r16
 820e538:	000b883a 	mov	r5,zero
 820e53c:	8809883a 	mov	r4,r17
 820e540:	da002c15 	stw	r8,176(sp)
 820e544:	820bff40 	call	820bff4 <memchr>
 820e548:	da002c17 	ldw	r8,176(sp)
 820e54c:	10026426 	beq	r2,zero,820eee0 <___svfiprintf_internal_r+0x118c>
 820e550:	1445c83a 	sub	r2,r2,r17
 820e554:	d8802115 	stw	r2,132(sp)
 820e558:	da801d83 	ldbu	r10,118(sp)
 820e55c:	df002315 	stw	fp,140(sp)
 820e560:	0021883a 	mov	r16,zero
 820e564:	003f1706 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820e568:	94800814 	ori	r18,r18,32
 820e56c:	98c00007 	ldb	r3,0(r19)
 820e570:	003e4706 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e574:	21003fcc 	andi	r4,r4,255
 820e578:	2002701e 	bne	r4,zero,820ef3c <___svfiprintf_internal_r+0x11e8>
 820e57c:	94800414 	ori	r18,r18,16
 820e580:	9080080c 	andi	r2,r18,32
 820e584:	103fb71e 	bne	r2,zero,820e464 <___svfiprintf_internal_r+0x710>
 820e588:	9080040c 	andi	r2,r18,16
 820e58c:	1001ab26 	beq	r2,zero,820ec3c <___svfiprintf_internal_r+0xee8>
 820e590:	dac02317 	ldw	r11,140(sp)
 820e594:	5f000017 	ldw	fp,0(r11)
 820e598:	5ac00104 	addi	r11,r11,4
 820e59c:	dac02315 	stw	r11,140(sp)
 820e5a0:	e013d7fa 	srai	r9,fp,31
 820e5a4:	4805883a 	mov	r2,r9
 820e5a8:	103fb50e 	bge	r2,zero,820e480 <___svfiprintf_internal_r+0x72c>
 820e5ac:	0739c83a 	sub	fp,zero,fp
 820e5b0:	02800b44 	movi	r10,45
 820e5b4:	e004c03a 	cmpne	r2,fp,zero
 820e5b8:	0253c83a 	sub	r9,zero,r9
 820e5bc:	da801d85 	stb	r10,118(sp)
 820e5c0:	4893c83a 	sub	r9,r9,r2
 820e5c4:	80023016 	blt	r16,zero,820ee88 <___svfiprintf_internal_r+0x1134>
 820e5c8:	00bfdfc4 	movi	r2,-129
 820e5cc:	90a4703a 	and	r18,r18,r2
 820e5d0:	483fb21e 	bne	r9,zero,820e49c <___svfiprintf_internal_r+0x748>
 820e5d4:	00003d06 	br	820e6cc <___svfiprintf_internal_r+0x978>
 820e5d8:	9817883a 	mov	r11,r19
 820e5dc:	d8002415 	stw	zero,144(sp)
 820e5e0:	18bff404 	addi	r2,r3,-48
 820e5e4:	0019883a 	mov	r12,zero
 820e5e8:	58c00007 	ldb	r3,0(r11)
 820e5ec:	630002a4 	muli	r12,r12,10
 820e5f0:	9cc00044 	addi	r19,r19,1
 820e5f4:	9817883a 	mov	r11,r19
 820e5f8:	1319883a 	add	r12,r2,r12
 820e5fc:	18bff404 	addi	r2,r3,-48
 820e600:	30bff92e 	bgeu	r6,r2,820e5e8 <___svfiprintf_internal_r+0x894>
 820e604:	db002415 	stw	r12,144(sp)
 820e608:	18bff804 	addi	r2,r3,-32
 820e60c:	28be232e 	bgeu	r5,r2,820de9c <___svfiprintf_internal_r+0x148>
 820e610:	21003fcc 	andi	r4,r4,255
 820e614:	20024b1e 	bne	r4,zero,820ef44 <___svfiprintf_internal_r+0x11f0>
 820e618:	1800d626 	beq	r3,zero,820e974 <___svfiprintf_internal_r+0xc20>
 820e61c:	02c00044 	movi	r11,1
 820e620:	dac02015 	stw	r11,128(sp)
 820e624:	d8c01005 	stb	r3,64(sp)
 820e628:	d8001d85 	stb	zero,118(sp)
 820e62c:	dac02115 	stw	r11,132(sp)
 820e630:	dc401004 	addi	r17,sp,64
 820e634:	003f2606 	br	820e2d0 <___svfiprintf_internal_r+0x57c>
 820e638:	94802014 	ori	r18,r18,128
 820e63c:	98c00007 	ldb	r3,0(r19)
 820e640:	003e1306 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820e644:	98c00007 	ldb	r3,0(r19)
 820e648:	9ac00044 	addi	r11,r19,1
 820e64c:	1a822b26 	beq	r3,r10,820eefc <___svfiprintf_internal_r+0x11a8>
 820e650:	18bff404 	addi	r2,r3,-48
 820e654:	0021883a 	mov	r16,zero
 820e658:	30821e36 	bltu	r6,r2,820eed4 <___svfiprintf_internal_r+0x1180>
 820e65c:	58c00007 	ldb	r3,0(r11)
 820e660:	840002a4 	muli	r16,r16,10
 820e664:	5cc00044 	addi	r19,r11,1
 820e668:	9817883a 	mov	r11,r19
 820e66c:	80a1883a 	add	r16,r16,r2
 820e670:	18bff404 	addi	r2,r3,-48
 820e674:	30bff92e 	bgeu	r6,r2,820e65c <___svfiprintf_internal_r+0x908>
 820e678:	803e060e 	bge	r16,zero,820de94 <___svfiprintf_internal_r+0x140>
 820e67c:	043fffc4 	movi	r16,-1
 820e680:	003e0406 	br	820de94 <___svfiprintf_internal_r+0x140>
 820e684:	21003fcc 	andi	r4,r4,255
 820e688:	2002371e 	bne	r4,zero,820ef68 <___svfiprintf_internal_r+0x1214>
 820e68c:	94800414 	ori	r18,r18,16
 820e690:	9080080c 	andi	r2,r18,32
 820e694:	103ebb1e 	bne	r2,zero,820e184 <___svfiprintf_internal_r+0x430>
 820e698:	9080040c 	andi	r2,r18,16
 820e69c:	10013b26 	beq	r2,zero,820eb8c <___svfiprintf_internal_r+0xe38>
 820e6a0:	dac02317 	ldw	r11,140(sp)
 820e6a4:	d8001d85 	stb	zero,118(sp)
 820e6a8:	0013883a 	mov	r9,zero
 820e6ac:	58800104 	addi	r2,r11,4
 820e6b0:	5f000017 	ldw	fp,0(r11)
 820e6b4:	80013d16 	blt	r16,zero,820ebac <___svfiprintf_internal_r+0xe58>
 820e6b8:	00ffdfc4 	movi	r3,-129
 820e6bc:	d8802315 	stw	r2,140(sp)
 820e6c0:	90e4703a 	and	r18,r18,r3
 820e6c4:	0015883a 	mov	r10,zero
 820e6c8:	e03eba26 	beq	fp,zero,820e1b4 <___svfiprintf_internal_r+0x460>
 820e6cc:	00800244 	movi	r2,9
 820e6d0:	173f7236 	bltu	r2,fp,820e49c <___svfiprintf_internal_r+0x748>
 820e6d4:	dac02b17 	ldw	r11,172(sp)
 820e6d8:	e7000c04 	addi	fp,fp,48
 820e6dc:	df0019c5 	stb	fp,103(sp)
 820e6e0:	dac02115 	stw	r11,132(sp)
 820e6e4:	dc4019c4 	addi	r17,sp,103
 820e6e8:	003eb606 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820e6ec:	21003fcc 	andi	r4,r4,255
 820e6f0:	20021f1e 	bne	r4,zero,820ef70 <___svfiprintf_internal_r+0x121c>
 820e6f4:	94800414 	ori	r18,r18,16
 820e6f8:	9080080c 	andi	r2,r18,32
 820e6fc:	103ec51e 	bne	r2,zero,820e214 <___svfiprintf_internal_r+0x4c0>
 820e700:	9080040c 	andi	r2,r18,16
 820e704:	10016926 	beq	r2,zero,820ecac <___svfiprintf_internal_r+0xf58>
 820e708:	dac02317 	ldw	r11,140(sp)
 820e70c:	d8001d85 	stb	zero,118(sp)
 820e710:	0013883a 	mov	r9,zero
 820e714:	58800104 	addi	r2,r11,4
 820e718:	5f000017 	ldw	fp,0(r11)
 820e71c:	80016b16 	blt	r16,zero,820eccc <___svfiprintf_internal_r+0xf78>
 820e720:	00ffdfc4 	movi	r3,-129
 820e724:	d8802315 	stw	r2,140(sp)
 820e728:	90e4703a 	and	r18,r18,r3
 820e72c:	e03ec41e 	bne	fp,zero,820e240 <___svfiprintf_internal_r+0x4ec>
 820e730:	0015883a 	mov	r10,zero
 820e734:	8001c226 	beq	r16,zero,820ee40 <___svfiprintf_internal_r+0x10ec>
 820e738:	0039883a 	mov	fp,zero
 820e73c:	0013883a 	mov	r9,zero
 820e740:	003ec006 	br	820e244 <___svfiprintf_internal_r+0x4f0>
 820e744:	d8c01c17 	ldw	r3,112(sp)
 820e748:	d8801b17 	ldw	r2,108(sp)
 820e74c:	d9001d87 	ldb	r4,118(sp)
 820e750:	20000b26 	beq	r4,zero,820e780 <___svfiprintf_internal_r+0xa2c>
 820e754:	d9001d84 	addi	r4,sp,118
 820e758:	18c00044 	addi	r3,r3,1
 820e75c:	10800044 	addi	r2,r2,1
 820e760:	41000015 	stw	r4,0(r8)
 820e764:	01000044 	movi	r4,1
 820e768:	41000115 	stw	r4,4(r8)
 820e76c:	d8c01c15 	stw	r3,112(sp)
 820e770:	d8801b15 	stw	r2,108(sp)
 820e774:	010001c4 	movi	r4,7
 820e778:	2080e116 	blt	r4,r2,820eb00 <___svfiprintf_internal_r+0xdac>
 820e77c:	42000204 	addi	r8,r8,8
 820e780:	dac02217 	ldw	r11,136(sp)
 820e784:	58000b26 	beq	r11,zero,820e7b4 <___svfiprintf_internal_r+0xa60>
 820e788:	d9001d04 	addi	r4,sp,116
 820e78c:	18c00084 	addi	r3,r3,2
 820e790:	10800044 	addi	r2,r2,1
 820e794:	41000015 	stw	r4,0(r8)
 820e798:	01000084 	movi	r4,2
 820e79c:	41000115 	stw	r4,4(r8)
 820e7a0:	d8c01c15 	stw	r3,112(sp)
 820e7a4:	d8801b15 	stw	r2,108(sp)
 820e7a8:	010001c4 	movi	r4,7
 820e7ac:	2080dd16 	blt	r4,r2,820eb24 <___svfiprintf_internal_r+0xdd0>
 820e7b0:	42000204 	addi	r8,r8,8
 820e7b4:	dac02617 	ldw	r11,152(sp)
 820e7b8:	01002004 	movi	r4,128
 820e7bc:	59008426 	beq	r11,r4,820e9d0 <___svfiprintf_internal_r+0xc7c>
 820e7c0:	dac02117 	ldw	r11,132(sp)
 820e7c4:	82e1c83a 	sub	r16,r16,r11
 820e7c8:	0400270e 	bge	zero,r16,820e868 <___svfiprintf_internal_r+0xb14>
 820e7cc:	01c00404 	movi	r7,16
 820e7d0:	3c016a0e 	bge	r7,r16,820ed7c <___svfiprintf_internal_r+0x1028>
 820e7d4:	01420974 	movhi	r5,2085
 820e7d8:	2975c204 	addi	r5,r5,-10488
 820e7dc:	d9402215 	stw	r5,136(sp)
 820e7e0:	070001c4 	movi	fp,7
 820e7e4:	00000306 	br	820e7f4 <___svfiprintf_internal_r+0xaa0>
 820e7e8:	843ffc04 	addi	r16,r16,-16
 820e7ec:	42000204 	addi	r8,r8,8
 820e7f0:	3c00130e 	bge	r7,r16,820e840 <___svfiprintf_internal_r+0xaec>
 820e7f4:	18c00404 	addi	r3,r3,16
 820e7f8:	10800044 	addi	r2,r2,1
 820e7fc:	45000015 	stw	r20,0(r8)
 820e800:	41c00115 	stw	r7,4(r8)
 820e804:	d8c01c15 	stw	r3,112(sp)
 820e808:	d8801b15 	stw	r2,108(sp)
 820e80c:	e0bff60e 	bge	fp,r2,820e7e8 <___svfiprintf_internal_r+0xa94>
 820e810:	d9801a04 	addi	r6,sp,104
 820e814:	b80b883a 	mov	r5,r23
 820e818:	a809883a 	mov	r4,r21
 820e81c:	d9c02c15 	stw	r7,176(sp)
 820e820:	820db840 	call	820db84 <__ssprint_r>
 820e824:	d9c02c17 	ldw	r7,176(sp)
 820e828:	1000581e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820e82c:	843ffc04 	addi	r16,r16,-16
 820e830:	d8c01c17 	ldw	r3,112(sp)
 820e834:	d8801b17 	ldw	r2,108(sp)
 820e838:	d811883a 	mov	r8,sp
 820e83c:	3c3fed16 	blt	r7,r16,820e7f4 <___svfiprintf_internal_r+0xaa0>
 820e840:	dac02217 	ldw	r11,136(sp)
 820e844:	1c07883a 	add	r3,r3,r16
 820e848:	10800044 	addi	r2,r2,1
 820e84c:	42c00015 	stw	r11,0(r8)
 820e850:	44000115 	stw	r16,4(r8)
 820e854:	d8c01c15 	stw	r3,112(sp)
 820e858:	d8801b15 	stw	r2,108(sp)
 820e85c:	010001c4 	movi	r4,7
 820e860:	20809e16 	blt	r4,r2,820eadc <___svfiprintf_internal_r+0xd88>
 820e864:	42000204 	addi	r8,r8,8
 820e868:	dac02117 	ldw	r11,132(sp)
 820e86c:	10800044 	addi	r2,r2,1
 820e870:	44400015 	stw	r17,0(r8)
 820e874:	58c7883a 	add	r3,r11,r3
 820e878:	42c00115 	stw	r11,4(r8)
 820e87c:	d8c01c15 	stw	r3,112(sp)
 820e880:	d8801b15 	stw	r2,108(sp)
 820e884:	010001c4 	movi	r4,7
 820e888:	20807f16 	blt	r4,r2,820ea88 <___svfiprintf_internal_r+0xd34>
 820e88c:	42000204 	addi	r8,r8,8
 820e890:	9480010c 	andi	r18,r18,4
 820e894:	90002926 	beq	r18,zero,820e93c <___svfiprintf_internal_r+0xbe8>
 820e898:	dac02417 	ldw	r11,144(sp)
 820e89c:	d8802017 	ldw	r2,128(sp)
 820e8a0:	58a1c83a 	sub	r16,r11,r2
 820e8a4:	0400250e 	bge	zero,r16,820e93c <___svfiprintf_internal_r+0xbe8>
 820e8a8:	04400404 	movi	r17,16
 820e8ac:	d8801b17 	ldw	r2,108(sp)
 820e8b0:	8c017c0e 	bge	r17,r16,820eea4 <___svfiprintf_internal_r+0x1150>
 820e8b4:	01420974 	movhi	r5,2085
 820e8b8:	2975c604 	addi	r5,r5,-10472
 820e8bc:	d9402815 	stw	r5,160(sp)
 820e8c0:	048001c4 	movi	r18,7
 820e8c4:	00000306 	br	820e8d4 <___svfiprintf_internal_r+0xb80>
 820e8c8:	843ffc04 	addi	r16,r16,-16
 820e8cc:	42000204 	addi	r8,r8,8
 820e8d0:	8c00110e 	bge	r17,r16,820e918 <___svfiprintf_internal_r+0xbc4>
 820e8d4:	18c00404 	addi	r3,r3,16
 820e8d8:	10800044 	addi	r2,r2,1
 820e8dc:	45800015 	stw	r22,0(r8)
 820e8e0:	44400115 	stw	r17,4(r8)
 820e8e4:	d8c01c15 	stw	r3,112(sp)
 820e8e8:	d8801b15 	stw	r2,108(sp)
 820e8ec:	90bff60e 	bge	r18,r2,820e8c8 <___svfiprintf_internal_r+0xb74>
 820e8f0:	d9801a04 	addi	r6,sp,104
 820e8f4:	b80b883a 	mov	r5,r23
 820e8f8:	a809883a 	mov	r4,r21
 820e8fc:	820db840 	call	820db84 <__ssprint_r>
 820e900:	1000221e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820e904:	843ffc04 	addi	r16,r16,-16
 820e908:	d8c01c17 	ldw	r3,112(sp)
 820e90c:	d8801b17 	ldw	r2,108(sp)
 820e910:	d811883a 	mov	r8,sp
 820e914:	8c3fef16 	blt	r17,r16,820e8d4 <___svfiprintf_internal_r+0xb80>
 820e918:	dac02817 	ldw	r11,160(sp)
 820e91c:	1c07883a 	add	r3,r3,r16
 820e920:	10800044 	addi	r2,r2,1
 820e924:	42c00015 	stw	r11,0(r8)
 820e928:	44000115 	stw	r16,4(r8)
 820e92c:	d8c01c15 	stw	r3,112(sp)
 820e930:	d8801b15 	stw	r2,108(sp)
 820e934:	010001c4 	movi	r4,7
 820e938:	2080aa16 	blt	r4,r2,820ebe4 <___svfiprintf_internal_r+0xe90>
 820e93c:	d8802417 	ldw	r2,144(sp)
 820e940:	dac02017 	ldw	r11,128(sp)
 820e944:	12c0010e 	bge	r2,r11,820e94c <___svfiprintf_internal_r+0xbf8>
 820e948:	5805883a 	mov	r2,r11
 820e94c:	dac02517 	ldw	r11,148(sp)
 820e950:	5897883a 	add	r11,r11,r2
 820e954:	dac02515 	stw	r11,148(sp)
 820e958:	1800531e 	bne	r3,zero,820eaa8 <___svfiprintf_internal_r+0xd54>
 820e95c:	98800007 	ldb	r2,0(r19)
 820e960:	d8001b15 	stw	zero,108(sp)
 820e964:	d811883a 	mov	r8,sp
 820e968:	103d231e 	bne	r2,zero,820ddf8 <___svfiprintf_internal_r+0xa4>
 820e96c:	9823883a 	mov	r17,r19
 820e970:	003d3906 	br	820de58 <___svfiprintf_internal_r+0x104>
 820e974:	d8801c17 	ldw	r2,112(sp)
 820e978:	10000426 	beq	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820e97c:	d9402717 	ldw	r5,156(sp)
 820e980:	d9002a17 	ldw	r4,168(sp)
 820e984:	d9801a04 	addi	r6,sp,104
 820e988:	820db840 	call	820db84 <__ssprint_r>
 820e98c:	dac02717 	ldw	r11,156(sp)
 820e990:	d8802517 	ldw	r2,148(sp)
 820e994:	58c0030b 	ldhu	r3,12(r11)
 820e998:	18c0100c 	andi	r3,r3,64
 820e99c:	1801381e 	bne	r3,zero,820ee80 <___svfiprintf_internal_r+0x112c>
 820e9a0:	dfc03717 	ldw	ra,220(sp)
 820e9a4:	df003617 	ldw	fp,216(sp)
 820e9a8:	ddc03517 	ldw	r23,212(sp)
 820e9ac:	dd803417 	ldw	r22,208(sp)
 820e9b0:	dd403317 	ldw	r21,204(sp)
 820e9b4:	dd003217 	ldw	r20,200(sp)
 820e9b8:	dcc03117 	ldw	r19,196(sp)
 820e9bc:	dc803017 	ldw	r18,192(sp)
 820e9c0:	dc402f17 	ldw	r17,188(sp)
 820e9c4:	dc002e17 	ldw	r16,184(sp)
 820e9c8:	dec03804 	addi	sp,sp,224
 820e9cc:	f800283a 	ret
 820e9d0:	dac02417 	ldw	r11,144(sp)
 820e9d4:	d9002017 	ldw	r4,128(sp)
 820e9d8:	5939c83a 	sub	fp,r11,r4
 820e9dc:	073f780e 	bge	zero,fp,820e7c0 <___svfiprintf_internal_r+0xa6c>
 820e9e0:	02400404 	movi	r9,16
 820e9e4:	4f01370e 	bge	r9,fp,820eec4 <___svfiprintf_internal_r+0x1170>
 820e9e8:	02c20974 	movhi	r11,2085
 820e9ec:	5af5c204 	addi	r11,r11,-10488
 820e9f0:	dac02215 	stw	r11,136(sp)
 820e9f4:	028001c4 	movi	r10,7
 820e9f8:	00000306 	br	820ea08 <___svfiprintf_internal_r+0xcb4>
 820e9fc:	e73ffc04 	addi	fp,fp,-16
 820ea00:	42000204 	addi	r8,r8,8
 820ea04:	4f00150e 	bge	r9,fp,820ea5c <___svfiprintf_internal_r+0xd08>
 820ea08:	18c00404 	addi	r3,r3,16
 820ea0c:	10800044 	addi	r2,r2,1
 820ea10:	45000015 	stw	r20,0(r8)
 820ea14:	42400115 	stw	r9,4(r8)
 820ea18:	d8c01c15 	stw	r3,112(sp)
 820ea1c:	d8801b15 	stw	r2,108(sp)
 820ea20:	50bff60e 	bge	r10,r2,820e9fc <___svfiprintf_internal_r+0xca8>
 820ea24:	d9801a04 	addi	r6,sp,104
 820ea28:	b80b883a 	mov	r5,r23
 820ea2c:	a809883a 	mov	r4,r21
 820ea30:	da402c15 	stw	r9,176(sp)
 820ea34:	da802d15 	stw	r10,180(sp)
 820ea38:	820db840 	call	820db84 <__ssprint_r>
 820ea3c:	da402c17 	ldw	r9,176(sp)
 820ea40:	da802d17 	ldw	r10,180(sp)
 820ea44:	103fd11e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820ea48:	e73ffc04 	addi	fp,fp,-16
 820ea4c:	d8c01c17 	ldw	r3,112(sp)
 820ea50:	d8801b17 	ldw	r2,108(sp)
 820ea54:	d811883a 	mov	r8,sp
 820ea58:	4f3feb16 	blt	r9,fp,820ea08 <___svfiprintf_internal_r+0xcb4>
 820ea5c:	dac02217 	ldw	r11,136(sp)
 820ea60:	1f07883a 	add	r3,r3,fp
 820ea64:	10800044 	addi	r2,r2,1
 820ea68:	42c00015 	stw	r11,0(r8)
 820ea6c:	47000115 	stw	fp,4(r8)
 820ea70:	d8c01c15 	stw	r3,112(sp)
 820ea74:	d8801b15 	stw	r2,108(sp)
 820ea78:	010001c4 	movi	r4,7
 820ea7c:	2080b616 	blt	r4,r2,820ed58 <___svfiprintf_internal_r+0x1004>
 820ea80:	42000204 	addi	r8,r8,8
 820ea84:	003f4e06 	br	820e7c0 <___svfiprintf_internal_r+0xa6c>
 820ea88:	d9801a04 	addi	r6,sp,104
 820ea8c:	b80b883a 	mov	r5,r23
 820ea90:	a809883a 	mov	r4,r21
 820ea94:	820db840 	call	820db84 <__ssprint_r>
 820ea98:	103fbc1e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820ea9c:	d8c01c17 	ldw	r3,112(sp)
 820eaa0:	d811883a 	mov	r8,sp
 820eaa4:	003f7a06 	br	820e890 <___svfiprintf_internal_r+0xb3c>
 820eaa8:	d9801a04 	addi	r6,sp,104
 820eaac:	b80b883a 	mov	r5,r23
 820eab0:	a809883a 	mov	r4,r21
 820eab4:	820db840 	call	820db84 <__ssprint_r>
 820eab8:	103fa826 	beq	r2,zero,820e95c <___svfiprintf_internal_r+0xc08>
 820eabc:	003fb306 	br	820e98c <___svfiprintf_internal_r+0xc38>
 820eac0:	d9801a04 	addi	r6,sp,104
 820eac4:	b80b883a 	mov	r5,r23
 820eac8:	a809883a 	mov	r4,r21
 820eacc:	820db840 	call	820db84 <__ssprint_r>
 820ead0:	103fae1e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820ead4:	d811883a 	mov	r8,sp
 820ead8:	003cdc06 	br	820de4c <___svfiprintf_internal_r+0xf8>
 820eadc:	d9801a04 	addi	r6,sp,104
 820eae0:	b80b883a 	mov	r5,r23
 820eae4:	a809883a 	mov	r4,r21
 820eae8:	820db840 	call	820db84 <__ssprint_r>
 820eaec:	103fa71e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820eaf0:	d8c01c17 	ldw	r3,112(sp)
 820eaf4:	d8801b17 	ldw	r2,108(sp)
 820eaf8:	d811883a 	mov	r8,sp
 820eafc:	003f5a06 	br	820e868 <___svfiprintf_internal_r+0xb14>
 820eb00:	d9801a04 	addi	r6,sp,104
 820eb04:	b80b883a 	mov	r5,r23
 820eb08:	a809883a 	mov	r4,r21
 820eb0c:	820db840 	call	820db84 <__ssprint_r>
 820eb10:	103f9e1e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820eb14:	d8c01c17 	ldw	r3,112(sp)
 820eb18:	d8801b17 	ldw	r2,108(sp)
 820eb1c:	d811883a 	mov	r8,sp
 820eb20:	003f1706 	br	820e780 <___svfiprintf_internal_r+0xa2c>
 820eb24:	d9801a04 	addi	r6,sp,104
 820eb28:	b80b883a 	mov	r5,r23
 820eb2c:	a809883a 	mov	r4,r21
 820eb30:	820db840 	call	820db84 <__ssprint_r>
 820eb34:	103f951e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820eb38:	d8c01c17 	ldw	r3,112(sp)
 820eb3c:	d8801b17 	ldw	r2,108(sp)
 820eb40:	d811883a 	mov	r8,sp
 820eb44:	003f1b06 	br	820e7b4 <___svfiprintf_internal_r+0xa60>
 820eb48:	d8001d85 	stb	zero,118(sp)
 820eb4c:	80007b16 	blt	r16,zero,820ed3c <___svfiprintf_internal_r+0xfe8>
 820eb50:	00ffdfc4 	movi	r3,-129
 820eb54:	e244b03a 	or	r2,fp,r9
 820eb58:	90e4703a 	and	r18,r18,r3
 820eb5c:	103d7026 	beq	r2,zero,820e120 <___svfiprintf_internal_r+0x3cc>
 820eb60:	0015883a 	mov	r10,zero
 820eb64:	003d7206 	br	820e130 <___svfiprintf_internal_r+0x3dc>
 820eb68:	d9801a04 	addi	r6,sp,104
 820eb6c:	b80b883a 	mov	r5,r23
 820eb70:	a809883a 	mov	r4,r21
 820eb74:	820db840 	call	820db84 <__ssprint_r>
 820eb78:	103f841e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820eb7c:	d8c01c17 	ldw	r3,112(sp)
 820eb80:	d8801b17 	ldw	r2,108(sp)
 820eb84:	d811883a 	mov	r8,sp
 820eb88:	003ef006 	br	820e74c <___svfiprintf_internal_r+0x9f8>
 820eb8c:	9080100c 	andi	r2,r18,64
 820eb90:	d8001d85 	stb	zero,118(sp)
 820eb94:	dac02317 	ldw	r11,140(sp)
 820eb98:	10008126 	beq	r2,zero,820eda0 <___svfiprintf_internal_r+0x104c>
 820eb9c:	58800104 	addi	r2,r11,4
 820eba0:	5f00000b 	ldhu	fp,0(r11)
 820eba4:	0013883a 	mov	r9,zero
 820eba8:	803ec30e 	bge	r16,zero,820e6b8 <___svfiprintf_internal_r+0x964>
 820ebac:	d8802315 	stw	r2,140(sp)
 820ebb0:	0015883a 	mov	r10,zero
 820ebb4:	e244b03a 	or	r2,fp,r9
 820ebb8:	103e371e 	bne	r2,zero,820e498 <___svfiprintf_internal_r+0x744>
 820ebbc:	00800044 	movi	r2,1
 820ebc0:	10803fcc 	andi	r2,r2,255
 820ebc4:	00c00044 	movi	r3,1
 820ebc8:	10c06126 	beq	r2,r3,820ed50 <___svfiprintf_internal_r+0xffc>
 820ebcc:	00c00084 	movi	r3,2
 820ebd0:	10fd5526 	beq	r2,r3,820e128 <___svfiprintf_internal_r+0x3d4>
 820ebd4:	003ed806 	br	820e738 <___svfiprintf_internal_r+0x9e4>
 820ebd8:	d8802315 	stw	r2,140(sp)
 820ebdc:	98c00007 	ldb	r3,0(r19)
 820ebe0:	003cab06 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820ebe4:	d9801a04 	addi	r6,sp,104
 820ebe8:	b80b883a 	mov	r5,r23
 820ebec:	a809883a 	mov	r4,r21
 820ebf0:	820db840 	call	820db84 <__ssprint_r>
 820ebf4:	103f651e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820ebf8:	d8c01c17 	ldw	r3,112(sp)
 820ebfc:	003f4f06 	br	820e93c <___svfiprintf_internal_r+0xbe8>
 820ec00:	00820974 	movhi	r2,2085
 820ec04:	10b55a04 	addi	r2,r2,-10904
 820ec08:	d8802915 	stw	r2,164(sp)
 820ec0c:	003d4406 	br	820e120 <___svfiprintf_internal_r+0x3cc>
 820ec10:	dac02317 	ldw	r11,140(sp)
 820ec14:	58800017 	ldw	r2,0(r11)
 820ec18:	dac02517 	ldw	r11,148(sp)
 820ec1c:	5807d7fa 	srai	r3,r11,31
 820ec20:	dac02317 	ldw	r11,140(sp)
 820ec24:	10c00115 	stw	r3,4(r2)
 820ec28:	5ac00104 	addi	r11,r11,4
 820ec2c:	dac02315 	stw	r11,140(sp)
 820ec30:	dac02517 	ldw	r11,148(sp)
 820ec34:	12c00015 	stw	r11,0(r2)
 820ec38:	003c6d06 	br	820ddf0 <___svfiprintf_internal_r+0x9c>
 820ec3c:	9080100c 	andi	r2,r18,64
 820ec40:	dac02317 	ldw	r11,140(sp)
 820ec44:	103e5326 	beq	r2,zero,820e594 <___svfiprintf_internal_r+0x840>
 820ec48:	5f00000f 	ldh	fp,0(r11)
 820ec4c:	5ac00104 	addi	r11,r11,4
 820ec50:	dac02315 	stw	r11,140(sp)
 820ec54:	e013d7fa 	srai	r9,fp,31
 820ec58:	4805883a 	mov	r2,r9
 820ec5c:	003e0706 	br	820e47c <___svfiprintf_internal_r+0x728>
 820ec60:	00800c04 	movi	r2,48
 820ec64:	d8801d05 	stb	r2,116(sp)
 820ec68:	d8c01d45 	stb	r3,117(sp)
 820ec6c:	d8001d85 	stb	zero,118(sp)
 820ec70:	90800094 	ori	r2,r18,2
 820ec74:	80008f16 	blt	r16,zero,820eeb4 <___svfiprintf_internal_r+0x1160>
 820ec78:	00bfdfc4 	movi	r2,-129
 820ec7c:	90a4703a 	and	r18,r18,r2
 820ec80:	94800094 	ori	r18,r18,2
 820ec84:	0015883a 	mov	r10,zero
 820ec88:	003d2906 	br	820e130 <___svfiprintf_internal_r+0x3dc>
 820ec8c:	98c00007 	ldb	r3,0(r19)
 820ec90:	003c7f06 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820ec94:	dac02317 	ldw	r11,140(sp)
 820ec98:	0013883a 	mov	r9,zero
 820ec9c:	5f000017 	ldw	fp,0(r11)
 820eca0:	5ac00104 	addi	r11,r11,4
 820eca4:	dac02315 	stw	r11,140(sp)
 820eca8:	003d1506 	br	820e100 <___svfiprintf_internal_r+0x3ac>
 820ecac:	9080100c 	andi	r2,r18,64
 820ecb0:	d8001d85 	stb	zero,118(sp)
 820ecb4:	dac02317 	ldw	r11,140(sp)
 820ecb8:	10003426 	beq	r2,zero,820ed8c <___svfiprintf_internal_r+0x1038>
 820ecbc:	58800104 	addi	r2,r11,4
 820ecc0:	5f00000b 	ldhu	fp,0(r11)
 820ecc4:	0013883a 	mov	r9,zero
 820ecc8:	803e950e 	bge	r16,zero,820e720 <___svfiprintf_internal_r+0x9cc>
 820eccc:	e246b03a 	or	r3,fp,r9
 820ecd0:	d8802315 	stw	r2,140(sp)
 820ecd4:	183d5a1e 	bne	r3,zero,820e240 <___svfiprintf_internal_r+0x4ec>
 820ecd8:	0015883a 	mov	r10,zero
 820ecdc:	0005883a 	mov	r2,zero
 820ece0:	003fb706 	br	820ebc0 <___svfiprintf_internal_r+0xe6c>
 820ece4:	98c00043 	ldbu	r3,1(r19)
 820ece8:	94800814 	ori	r18,r18,32
 820ecec:	9cc00044 	addi	r19,r19,1
 820ecf0:	18c03fcc 	andi	r3,r3,255
 820ecf4:	18c0201c 	xori	r3,r3,128
 820ecf8:	18ffe004 	addi	r3,r3,-128
 820ecfc:	003c6406 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820ed00:	d8c02315 	stw	r3,140(sp)
 820ed04:	0015883a 	mov	r10,zero
 820ed08:	003faa06 	br	820ebb4 <___svfiprintf_internal_r+0xe60>
 820ed0c:	dac02317 	ldw	r11,140(sp)
 820ed10:	58800017 	ldw	r2,0(r11)
 820ed14:	5ac00104 	addi	r11,r11,4
 820ed18:	dac02315 	stw	r11,140(sp)
 820ed1c:	dac02517 	ldw	r11,148(sp)
 820ed20:	12c00015 	stw	r11,0(r2)
 820ed24:	003c3206 	br	820ddf0 <___svfiprintf_internal_r+0x9c>
 820ed28:	01020974 	movhi	r4,2085
 820ed2c:	21355a04 	addi	r4,r4,-10904
 820ed30:	d9002915 	stw	r4,164(sp)
 820ed34:	d8c02315 	stw	r3,140(sp)
 820ed38:	1025883a 	mov	r18,r2
 820ed3c:	e244b03a 	or	r2,fp,r9
 820ed40:	103f871e 	bne	r2,zero,820eb60 <___svfiprintf_internal_r+0xe0c>
 820ed44:	0015883a 	mov	r10,zero
 820ed48:	00800084 	movi	r2,2
 820ed4c:	003f9c06 	br	820ebc0 <___svfiprintf_internal_r+0xe6c>
 820ed50:	0039883a 	mov	fp,zero
 820ed54:	003e5f06 	br	820e6d4 <___svfiprintf_internal_r+0x980>
 820ed58:	d9801a04 	addi	r6,sp,104
 820ed5c:	b80b883a 	mov	r5,r23
 820ed60:	a809883a 	mov	r4,r21
 820ed64:	820db840 	call	820db84 <__ssprint_r>
 820ed68:	103f081e 	bne	r2,zero,820e98c <___svfiprintf_internal_r+0xc38>
 820ed6c:	d8c01c17 	ldw	r3,112(sp)
 820ed70:	d8801b17 	ldw	r2,108(sp)
 820ed74:	d811883a 	mov	r8,sp
 820ed78:	003e9106 	br	820e7c0 <___svfiprintf_internal_r+0xa6c>
 820ed7c:	01020974 	movhi	r4,2085
 820ed80:	2135c204 	addi	r4,r4,-10488
 820ed84:	d9002215 	stw	r4,136(sp)
 820ed88:	003ead06 	br	820e840 <___svfiprintf_internal_r+0xaec>
 820ed8c:	58800104 	addi	r2,r11,4
 820ed90:	5f000017 	ldw	fp,0(r11)
 820ed94:	0013883a 	mov	r9,zero
 820ed98:	803e610e 	bge	r16,zero,820e720 <___svfiprintf_internal_r+0x9cc>
 820ed9c:	003fcb06 	br	820eccc <___svfiprintf_internal_r+0xf78>
 820eda0:	58800104 	addi	r2,r11,4
 820eda4:	5f000017 	ldw	fp,0(r11)
 820eda8:	0013883a 	mov	r9,zero
 820edac:	803e420e 	bge	r16,zero,820e6b8 <___svfiprintf_internal_r+0x964>
 820edb0:	003f7e06 	br	820ebac <___svfiprintf_internal_r+0xe58>
 820edb4:	5f000017 	ldw	fp,0(r11)
 820edb8:	5ac00104 	addi	r11,r11,4
 820edbc:	0013883a 	mov	r9,zero
 820edc0:	dac02315 	stw	r11,140(sp)
 820edc4:	003cce06 	br	820e100 <___svfiprintf_internal_r+0x3ac>
 820edc8:	8809883a 	mov	r4,r17
 820edcc:	da002c15 	stw	r8,176(sp)
 820edd0:	8203a5c0 	call	8203a5c <strlen>
 820edd4:	d8802115 	stw	r2,132(sp)
 820edd8:	da801d83 	ldbu	r10,118(sp)
 820eddc:	df002315 	stw	fp,140(sp)
 820ede0:	0021883a 	mov	r16,zero
 820ede4:	da002c17 	ldw	r8,176(sp)
 820ede8:	003cf606 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820edec:	00800184 	movi	r2,6
 820edf0:	1400012e 	bgeu	r2,r16,820edf8 <___svfiprintf_internal_r+0x10a4>
 820edf4:	1021883a 	mov	r16,r2
 820edf8:	dc002115 	stw	r16,132(sp)
 820edfc:	8005883a 	mov	r2,r16
 820ee00:	80003c16 	blt	r16,zero,820eef4 <___svfiprintf_internal_r+0x11a0>
 820ee04:	04420974 	movhi	r17,2085
 820ee08:	d8802015 	stw	r2,128(sp)
 820ee0c:	df002315 	stw	fp,140(sp)
 820ee10:	8c755f04 	addi	r17,r17,-10884
 820ee14:	003d2e06 	br	820e2d0 <___svfiprintf_internal_r+0x57c>
 820ee18:	04001004 	movi	r16,64
 820ee1c:	800b883a 	mov	r5,r16
 820ee20:	820b7e80 	call	820b7e8 <_malloc_r>
 820ee24:	dac02717 	ldw	r11,156(sp)
 820ee28:	58800015 	stw	r2,0(r11)
 820ee2c:	58800415 	stw	r2,16(r11)
 820ee30:	10004826 	beq	r2,zero,820ef54 <___svfiprintf_internal_r+0x1200>
 820ee34:	dac02717 	ldw	r11,156(sp)
 820ee38:	5c000515 	stw	r16,20(r11)
 820ee3c:	003bd906 	br	820dda4 <___svfiprintf_internal_r+0x50>
 820ee40:	9080004c 	andi	r2,r18,1
 820ee44:	0015883a 	mov	r10,zero
 820ee48:	10000626 	beq	r2,zero,820ee64 <___svfiprintf_internal_r+0x1110>
 820ee4c:	dac02b17 	ldw	r11,172(sp)
 820ee50:	00800c04 	movi	r2,48
 820ee54:	d88019c5 	stb	r2,103(sp)
 820ee58:	dac02115 	stw	r11,132(sp)
 820ee5c:	dc4019c4 	addi	r17,sp,103
 820ee60:	003cd806 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820ee64:	d8002115 	stw	zero,132(sp)
 820ee68:	dc401a04 	addi	r17,sp,104
 820ee6c:	003cd506 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820ee70:	01020974 	movhi	r4,2085
 820ee74:	2135c604 	addi	r4,r4,-10472
 820ee78:	d9002815 	stw	r4,160(sp)
 820ee7c:	003d4306 	br	820e38c <___svfiprintf_internal_r+0x638>
 820ee80:	00bfffc4 	movi	r2,-1
 820ee84:	003ec606 	br	820e9a0 <___svfiprintf_internal_r+0xc4c>
 820ee88:	00800044 	movi	r2,1
 820ee8c:	10803fcc 	andi	r2,r2,255
 820ee90:	00c00044 	movi	r3,1
 820ee94:	10fd8026 	beq	r2,r3,820e498 <___svfiprintf_internal_r+0x744>
 820ee98:	00c00084 	movi	r3,2
 820ee9c:	10fca426 	beq	r2,r3,820e130 <___svfiprintf_internal_r+0x3dc>
 820eea0:	003ce806 	br	820e244 <___svfiprintf_internal_r+0x4f0>
 820eea4:	01020974 	movhi	r4,2085
 820eea8:	2135c604 	addi	r4,r4,-10472
 820eeac:	d9002815 	stw	r4,160(sp)
 820eeb0:	003e9906 	br	820e918 <___svfiprintf_internal_r+0xbc4>
 820eeb4:	1025883a 	mov	r18,r2
 820eeb8:	0015883a 	mov	r10,zero
 820eebc:	00800084 	movi	r2,2
 820eec0:	003ff206 	br	820ee8c <___svfiprintf_internal_r+0x1138>
 820eec4:	01420974 	movhi	r5,2085
 820eec8:	2975c204 	addi	r5,r5,-10488
 820eecc:	d9402215 	stw	r5,136(sp)
 820eed0:	003ee206 	br	820ea5c <___svfiprintf_internal_r+0xd08>
 820eed4:	5827883a 	mov	r19,r11
 820eed8:	0021883a 	mov	r16,zero
 820eedc:	003bed06 	br	820de94 <___svfiprintf_internal_r+0x140>
 820eee0:	dc002115 	stw	r16,132(sp)
 820eee4:	da801d83 	ldbu	r10,118(sp)
 820eee8:	df002315 	stw	fp,140(sp)
 820eeec:	0021883a 	mov	r16,zero
 820eef0:	003cb406 	br	820e1c4 <___svfiprintf_internal_r+0x470>
 820eef4:	0005883a 	mov	r2,zero
 820eef8:	003fc206 	br	820ee04 <___svfiprintf_internal_r+0x10b0>
 820eefc:	d8802317 	ldw	r2,140(sp)
 820ef00:	98c00043 	ldbu	r3,1(r19)
 820ef04:	5827883a 	mov	r19,r11
 820ef08:	14000017 	ldw	r16,0(r2)
 820ef0c:	10800104 	addi	r2,r2,4
 820ef10:	d8802315 	stw	r2,140(sp)
 820ef14:	803f760e 	bge	r16,zero,820ecf0 <___svfiprintf_internal_r+0xf9c>
 820ef18:	18c03fcc 	andi	r3,r3,255
 820ef1c:	18c0201c 	xori	r3,r3,128
 820ef20:	043fffc4 	movi	r16,-1
 820ef24:	18ffe004 	addi	r3,r3,-128
 820ef28:	003bd906 	br	820de90 <___svfiprintf_internal_r+0x13c>
 820ef2c:	d9c01d85 	stb	r7,118(sp)
 820ef30:	003cb606 	br	820e20c <___svfiprintf_internal_r+0x4b8>
 820ef34:	d9c01d85 	stb	r7,118(sp)
 820ef38:	003d2106 	br	820e3c0 <___svfiprintf_internal_r+0x66c>
 820ef3c:	d9c01d85 	stb	r7,118(sp)
 820ef40:	003d8e06 	br	820e57c <___svfiprintf_internal_r+0x828>
 820ef44:	d9c01d85 	stb	r7,118(sp)
 820ef48:	003db306 	br	820e618 <___svfiprintf_internal_r+0x8c4>
 820ef4c:	d9c01d85 	stb	r7,118(sp)
 820ef50:	003c8a06 	br	820e17c <___svfiprintf_internal_r+0x428>
 820ef54:	dac02a17 	ldw	r11,168(sp)
 820ef58:	00800304 	movi	r2,12
 820ef5c:	58800015 	stw	r2,0(r11)
 820ef60:	00bfffc4 	movi	r2,-1
 820ef64:	003e8e06 	br	820e9a0 <___svfiprintf_internal_r+0xc4c>
 820ef68:	d9c01d85 	stb	r7,118(sp)
 820ef6c:	003dc706 	br	820e68c <___svfiprintf_internal_r+0x938>
 820ef70:	d9c01d85 	stb	r7,118(sp)
 820ef74:	003ddf06 	br	820e6f4 <___svfiprintf_internal_r+0x9a0>
 820ef78:	d9c01d85 	stb	r7,118(sp)
 820ef7c:	003d3706 	br	820e45c <___svfiprintf_internal_r+0x708>
 820ef80:	d9c01d85 	stb	r7,118(sp)
 820ef84:	003c5406 	br	820e0d8 <___svfiprintf_internal_r+0x384>
 820ef88:	d9c01d85 	stb	r7,118(sp)
 820ef8c:	003d1d06 	br	820e404 <___svfiprintf_internal_r+0x6b0>

0820ef90 <__sprint_r.part.0>:
 820ef90:	28801917 	ldw	r2,100(r5)
 820ef94:	defff604 	addi	sp,sp,-40
 820ef98:	dd400515 	stw	r21,20(sp)
 820ef9c:	dfc00915 	stw	ra,36(sp)
 820efa0:	df000815 	stw	fp,32(sp)
 820efa4:	ddc00715 	stw	r23,28(sp)
 820efa8:	dd800615 	stw	r22,24(sp)
 820efac:	dd000415 	stw	r20,16(sp)
 820efb0:	dcc00315 	stw	r19,12(sp)
 820efb4:	dc800215 	stw	r18,8(sp)
 820efb8:	dc400115 	stw	r17,4(sp)
 820efbc:	dc000015 	stw	r16,0(sp)
 820efc0:	1088000c 	andi	r2,r2,8192
 820efc4:	302b883a 	mov	r21,r6
 820efc8:	10002e26 	beq	r2,zero,820f084 <__sprint_r.part.0+0xf4>
 820efcc:	30800217 	ldw	r2,8(r6)
 820efd0:	35800017 	ldw	r22,0(r6)
 820efd4:	10002926 	beq	r2,zero,820f07c <__sprint_r.part.0+0xec>
 820efd8:	2827883a 	mov	r19,r5
 820efdc:	2029883a 	mov	r20,r4
 820efe0:	b5c00104 	addi	r23,r22,4
 820efe4:	04bfffc4 	movi	r18,-1
 820efe8:	bc400017 	ldw	r17,0(r23)
 820efec:	b4000017 	ldw	r16,0(r22)
 820eff0:	0039883a 	mov	fp,zero
 820eff4:	8822d0ba 	srli	r17,r17,2
 820eff8:	8800031e 	bne	r17,zero,820f008 <__sprint_r.part.0+0x78>
 820effc:	00001806 	br	820f060 <__sprint_r.part.0+0xd0>
 820f000:	84000104 	addi	r16,r16,4
 820f004:	8f001526 	beq	r17,fp,820f05c <__sprint_r.part.0+0xcc>
 820f008:	81400017 	ldw	r5,0(r16)
 820f00c:	980d883a 	mov	r6,r19
 820f010:	a009883a 	mov	r4,r20
 820f014:	82109b80 	call	82109b8 <_fputwc_r>
 820f018:	e7000044 	addi	fp,fp,1
 820f01c:	14bff81e 	bne	r2,r18,820f000 <__sprint_r.part.0+0x70>
 820f020:	9005883a 	mov	r2,r18
 820f024:	a8000215 	stw	zero,8(r21)
 820f028:	a8000115 	stw	zero,4(r21)
 820f02c:	dfc00917 	ldw	ra,36(sp)
 820f030:	df000817 	ldw	fp,32(sp)
 820f034:	ddc00717 	ldw	r23,28(sp)
 820f038:	dd800617 	ldw	r22,24(sp)
 820f03c:	dd400517 	ldw	r21,20(sp)
 820f040:	dd000417 	ldw	r20,16(sp)
 820f044:	dcc00317 	ldw	r19,12(sp)
 820f048:	dc800217 	ldw	r18,8(sp)
 820f04c:	dc400117 	ldw	r17,4(sp)
 820f050:	dc000017 	ldw	r16,0(sp)
 820f054:	dec00a04 	addi	sp,sp,40
 820f058:	f800283a 	ret
 820f05c:	a8800217 	ldw	r2,8(r21)
 820f060:	8c63883a 	add	r17,r17,r17
 820f064:	8c63883a 	add	r17,r17,r17
 820f068:	1445c83a 	sub	r2,r2,r17
 820f06c:	a8800215 	stw	r2,8(r21)
 820f070:	b5800204 	addi	r22,r22,8
 820f074:	bdc00204 	addi	r23,r23,8
 820f078:	103fdb1e 	bne	r2,zero,820efe8 <__sprint_r.part.0+0x58>
 820f07c:	0005883a 	mov	r2,zero
 820f080:	003fe806 	br	820f024 <__sprint_r.part.0+0x94>
 820f084:	820af0c0 	call	820af0c <__sfvwrite_r>
 820f088:	003fe606 	br	820f024 <__sprint_r.part.0+0x94>

0820f08c <__sprint_r>:
 820f08c:	30c00217 	ldw	r3,8(r6)
 820f090:	18000126 	beq	r3,zero,820f098 <__sprint_r+0xc>
 820f094:	820ef901 	jmpi	820ef90 <__sprint_r.part.0>
 820f098:	30000115 	stw	zero,4(r6)
 820f09c:	0005883a 	mov	r2,zero
 820f0a0:	f800283a 	ret

0820f0a4 <___vfiprintf_internal_r>:
 820f0a4:	deffc904 	addi	sp,sp,-220
 820f0a8:	df003515 	stw	fp,212(sp)
 820f0ac:	dd003115 	stw	r20,196(sp)
 820f0b0:	dfc03615 	stw	ra,216(sp)
 820f0b4:	ddc03415 	stw	r23,208(sp)
 820f0b8:	dd803315 	stw	r22,204(sp)
 820f0bc:	dd403215 	stw	r21,200(sp)
 820f0c0:	dcc03015 	stw	r19,192(sp)
 820f0c4:	dc802f15 	stw	r18,188(sp)
 820f0c8:	dc402e15 	stw	r17,184(sp)
 820f0cc:	dc002d15 	stw	r16,180(sp)
 820f0d0:	d9002015 	stw	r4,128(sp)
 820f0d4:	d9c02215 	stw	r7,136(sp)
 820f0d8:	2829883a 	mov	r20,r5
 820f0dc:	3039883a 	mov	fp,r6
 820f0e0:	20000226 	beq	r4,zero,820f0ec <___vfiprintf_internal_r+0x48>
 820f0e4:	20800e17 	ldw	r2,56(r4)
 820f0e8:	1000cf26 	beq	r2,zero,820f428 <___vfiprintf_internal_r+0x384>
 820f0ec:	a080030b 	ldhu	r2,12(r20)
 820f0f0:	10c8000c 	andi	r3,r2,8192
 820f0f4:	1800061e 	bne	r3,zero,820f110 <___vfiprintf_internal_r+0x6c>
 820f0f8:	a1001917 	ldw	r4,100(r20)
 820f0fc:	00f7ffc4 	movi	r3,-8193
 820f100:	10880014 	ori	r2,r2,8192
 820f104:	20c6703a 	and	r3,r4,r3
 820f108:	a080030d 	sth	r2,12(r20)
 820f10c:	a0c01915 	stw	r3,100(r20)
 820f110:	10c0020c 	andi	r3,r2,8
 820f114:	1800a926 	beq	r3,zero,820f3bc <___vfiprintf_internal_r+0x318>
 820f118:	a0c00417 	ldw	r3,16(r20)
 820f11c:	1800a726 	beq	r3,zero,820f3bc <___vfiprintf_internal_r+0x318>
 820f120:	1080068c 	andi	r2,r2,26
 820f124:	00c00284 	movi	r3,10
 820f128:	10c0ac26 	beq	r2,r3,820f3dc <___vfiprintf_internal_r+0x338>
 820f12c:	da801a04 	addi	r10,sp,104
 820f130:	da801e15 	stw	r10,120(sp)
 820f134:	d8801e17 	ldw	r2,120(sp)
 820f138:	da8019c4 	addi	r10,sp,103
 820f13c:	05820974 	movhi	r22,2085
 820f140:	05c20974 	movhi	r23,2085
 820f144:	da801f15 	stw	r10,124(sp)
 820f148:	1295c83a 	sub	r10,r2,r10
 820f14c:	b5b5ce04 	addi	r22,r22,-10440
 820f150:	bdf5ca04 	addi	r23,r23,-10456
 820f154:	dec01a15 	stw	sp,104(sp)
 820f158:	d8001c15 	stw	zero,112(sp)
 820f15c:	d8001b15 	stw	zero,108(sp)
 820f160:	d8002615 	stw	zero,152(sp)
 820f164:	d8002315 	stw	zero,140(sp)
 820f168:	da802715 	stw	r10,156(sp)
 820f16c:	d811883a 	mov	r8,sp
 820f170:	dd002115 	stw	r20,132(sp)
 820f174:	e021883a 	mov	r16,fp
 820f178:	80800007 	ldb	r2,0(r16)
 820f17c:	1003ea26 	beq	r2,zero,8210128 <___vfiprintf_internal_r+0x1084>
 820f180:	00c00944 	movi	r3,37
 820f184:	8025883a 	mov	r18,r16
 820f188:	10c0021e 	bne	r2,r3,820f194 <___vfiprintf_internal_r+0xf0>
 820f18c:	00001606 	br	820f1e8 <___vfiprintf_internal_r+0x144>
 820f190:	10c00326 	beq	r2,r3,820f1a0 <___vfiprintf_internal_r+0xfc>
 820f194:	94800044 	addi	r18,r18,1
 820f198:	90800007 	ldb	r2,0(r18)
 820f19c:	103ffc1e 	bne	r2,zero,820f190 <___vfiprintf_internal_r+0xec>
 820f1a0:	9423c83a 	sub	r17,r18,r16
 820f1a4:	88001026 	beq	r17,zero,820f1e8 <___vfiprintf_internal_r+0x144>
 820f1a8:	d8c01c17 	ldw	r3,112(sp)
 820f1ac:	d8801b17 	ldw	r2,108(sp)
 820f1b0:	44000015 	stw	r16,0(r8)
 820f1b4:	88c7883a 	add	r3,r17,r3
 820f1b8:	10800044 	addi	r2,r2,1
 820f1bc:	44400115 	stw	r17,4(r8)
 820f1c0:	d8c01c15 	stw	r3,112(sp)
 820f1c4:	d8801b15 	stw	r2,108(sp)
 820f1c8:	010001c4 	movi	r4,7
 820f1cc:	2080760e 	bge	r4,r2,820f3a8 <___vfiprintf_internal_r+0x304>
 820f1d0:	1803821e 	bne	r3,zero,820ffdc <___vfiprintf_internal_r+0xf38>
 820f1d4:	da802317 	ldw	r10,140(sp)
 820f1d8:	d8001b15 	stw	zero,108(sp)
 820f1dc:	d811883a 	mov	r8,sp
 820f1e0:	5455883a 	add	r10,r10,r17
 820f1e4:	da802315 	stw	r10,140(sp)
 820f1e8:	90800007 	ldb	r2,0(r18)
 820f1ec:	10044626 	beq	r2,zero,8210308 <___vfiprintf_internal_r+0x1264>
 820f1f0:	90c00047 	ldb	r3,1(r18)
 820f1f4:	94000044 	addi	r16,r18,1
 820f1f8:	d8001d85 	stb	zero,118(sp)
 820f1fc:	0009883a 	mov	r4,zero
 820f200:	000f883a 	mov	r7,zero
 820f204:	027fffc4 	movi	r9,-1
 820f208:	0023883a 	mov	r17,zero
 820f20c:	0029883a 	mov	r20,zero
 820f210:	01401604 	movi	r5,88
 820f214:	01800244 	movi	r6,9
 820f218:	03400a84 	movi	r13,42
 820f21c:	03001b04 	movi	r12,108
 820f220:	84000044 	addi	r16,r16,1
 820f224:	18bff804 	addi	r2,r3,-32
 820f228:	28827336 	bltu	r5,r2,820fbf8 <___vfiprintf_internal_r+0xb54>
 820f22c:	100490ba 	slli	r2,r2,2
 820f230:	02820874 	movhi	r10,2081
 820f234:	52bc9104 	addi	r10,r10,-3516
 820f238:	1285883a 	add	r2,r2,r10
 820f23c:	10800017 	ldw	r2,0(r2)
 820f240:	1000683a 	jmp	r2
 820f244:	0820f92c 	andhi	zero,at,33764
 820f248:	0820fbf8 	rdprs	zero,at,-31761
 820f24c:	0820fbf8 	rdprs	zero,at,-31761
 820f250:	0820f94c 	andi	zero,at,33765
 820f254:	0820fbf8 	rdprs	zero,at,-31761
 820f258:	0820fbf8 	rdprs	zero,at,-31761
 820f25c:	0820fbf8 	rdprs	zero,at,-31761
 820f260:	0820fbf8 	rdprs	zero,at,-31761
 820f264:	0820fbf8 	rdprs	zero,at,-31761
 820f268:	0820fbf8 	rdprs	zero,at,-31761
 820f26c:	0820fb34 	orhi	zero,at,33772
 820f270:	0820fb50 	cmplti	zero,at,-31763
 820f274:	0820fbf8 	rdprs	zero,at,-31761
 820f278:	0820f438 	rdprs	zero,at,-31792
 820f27c:	0820fb60 	cmpeqi	zero,at,-31763
 820f280:	0820fbf8 	rdprs	zero,at,-31761
 820f284:	0820f958 	cmpnei	zero,at,-31771
 820f288:	0820f964 	muli	zero,at,-31771
 820f28c:	0820f964 	muli	zero,at,-31771
 820f290:	0820f964 	muli	zero,at,-31771
 820f294:	0820f964 	muli	zero,at,-31771
 820f298:	0820f964 	muli	zero,at,-31771
 820f29c:	0820f964 	muli	zero,at,-31771
 820f2a0:	0820f964 	muli	zero,at,-31771
 820f2a4:	0820f964 	muli	zero,at,-31771
 820f2a8:	0820f964 	muli	zero,at,-31771
 820f2ac:	0820fbf8 	rdprs	zero,at,-31761
 820f2b0:	0820fbf8 	rdprs	zero,at,-31761
 820f2b4:	0820fbf8 	rdprs	zero,at,-31761
 820f2b8:	0820fbf8 	rdprs	zero,at,-31761
 820f2bc:	0820fbf8 	rdprs	zero,at,-31761
 820f2c0:	0820fbf8 	rdprs	zero,at,-31761
 820f2c4:	0820fbf8 	rdprs	zero,at,-31761
 820f2c8:	0820fbf8 	rdprs	zero,at,-31761
 820f2cc:	0820fbf8 	rdprs	zero,at,-31761
 820f2d0:	0820fbf8 	rdprs	zero,at,-31761
 820f2d4:	0820f990 	cmplti	zero,at,-31770
 820f2d8:	0820fbf8 	rdprs	zero,at,-31761
 820f2dc:	0820fbf8 	rdprs	zero,at,-31761
 820f2e0:	0820fbf8 	rdprs	zero,at,-31761
 820f2e4:	0820fbf8 	rdprs	zero,at,-31761
 820f2e8:	0820fbf8 	rdprs	zero,at,-31761
 820f2ec:	0820fbf8 	rdprs	zero,at,-31761
 820f2f0:	0820fbf8 	rdprs	zero,at,-31761
 820f2f4:	0820fbf8 	rdprs	zero,at,-31761
 820f2f8:	0820fbf8 	rdprs	zero,at,-31761
 820f2fc:	0820fbf8 	rdprs	zero,at,-31761
 820f300:	0820f9c8 	cmpgei	zero,at,-31769
 820f304:	0820fbf8 	rdprs	zero,at,-31761
 820f308:	0820fbf8 	rdprs	zero,at,-31761
 820f30c:	0820fbf8 	rdprs	zero,at,-31761
 820f310:	0820fbf8 	rdprs	zero,at,-31761
 820f314:	0820fbf8 	rdprs	zero,at,-31761
 820f318:	0820fa20 	cmpeqi	zero,at,-31768
 820f31c:	0820fbf8 	rdprs	zero,at,-31761
 820f320:	0820fbf8 	rdprs	zero,at,-31761
 820f324:	0820fa90 	cmplti	zero,at,-31766
 820f328:	0820fbf8 	rdprs	zero,at,-31761
 820f32c:	0820fbf8 	rdprs	zero,at,-31761
 820f330:	0820fbf8 	rdprs	zero,at,-31761
 820f334:	0820fbf8 	rdprs	zero,at,-31761
 820f338:	0820fbf8 	rdprs	zero,at,-31761
 820f33c:	0820fbf8 	rdprs	zero,at,-31761
 820f340:	0820fbf8 	rdprs	zero,at,-31761
 820f344:	0820fbf8 	rdprs	zero,at,-31761
 820f348:	0820fbf8 	rdprs	zero,at,-31761
 820f34c:	0820fbf8 	rdprs	zero,at,-31761
 820f350:	0820f83c 	xorhi	zero,at,33760
 820f354:	0820f868 	cmpgeui	zero,at,33761
 820f358:	0820fbf8 	rdprs	zero,at,-31761
 820f35c:	0820fbf8 	rdprs	zero,at,-31761
 820f360:	0820fbf8 	rdprs	zero,at,-31761
 820f364:	0820fba0 	cmpeqi	zero,at,-31762
 820f368:	0820f868 	cmpgeui	zero,at,33761
 820f36c:	0820fbf8 	rdprs	zero,at,-31761
 820f370:	0820fbf8 	rdprs	zero,at,-31761
 820f374:	0820f6fc 	xorhi	zero,at,33755
 820f378:	0820fbf8 	rdprs	zero,at,-31761
 820f37c:	0820f70c 	andi	zero,at,33756
 820f380:	0820f748 	cmpgei	zero,at,-31779
 820f384:	0820f444 	addi	zero,at,-31791
 820f388:	0820f6f0 	cmpltui	zero,at,33755
 820f38c:	0820fbf8 	rdprs	zero,at,-31761
 820f390:	0820facc 	andi	zero,at,33771
 820f394:	0820fbf8 	rdprs	zero,at,-31761
 820f398:	0820fb24 	muli	zero,at,-31764
 820f39c:	0820fbf8 	rdprs	zero,at,-31761
 820f3a0:	0820fbf8 	rdprs	zero,at,-31761
 820f3a4:	0820f7e8 	cmpgeui	zero,at,33759
 820f3a8:	42000204 	addi	r8,r8,8
 820f3ac:	da802317 	ldw	r10,140(sp)
 820f3b0:	5455883a 	add	r10,r10,r17
 820f3b4:	da802315 	stw	r10,140(sp)
 820f3b8:	003f8b06 	br	820f1e8 <___vfiprintf_internal_r+0x144>
 820f3bc:	d9002017 	ldw	r4,128(sp)
 820f3c0:	a00b883a 	mov	r5,r20
 820f3c4:	82089600 	call	8208960 <__swsetup_r>
 820f3c8:	1003b11e 	bne	r2,zero,8210290 <___vfiprintf_internal_r+0x11ec>
 820f3cc:	a080030b 	ldhu	r2,12(r20)
 820f3d0:	00c00284 	movi	r3,10
 820f3d4:	1080068c 	andi	r2,r2,26
 820f3d8:	10ff541e 	bne	r2,r3,820f12c <___vfiprintf_internal_r+0x88>
 820f3dc:	a080038f 	ldh	r2,14(r20)
 820f3e0:	103f5216 	blt	r2,zero,820f12c <___vfiprintf_internal_r+0x88>
 820f3e4:	d9c02217 	ldw	r7,136(sp)
 820f3e8:	d9002017 	ldw	r4,128(sp)
 820f3ec:	e00d883a 	mov	r6,fp
 820f3f0:	a00b883a 	mov	r5,r20
 820f3f4:	821051c0 	call	821051c <__sbprintf>
 820f3f8:	dfc03617 	ldw	ra,216(sp)
 820f3fc:	df003517 	ldw	fp,212(sp)
 820f400:	ddc03417 	ldw	r23,208(sp)
 820f404:	dd803317 	ldw	r22,204(sp)
 820f408:	dd403217 	ldw	r21,200(sp)
 820f40c:	dd003117 	ldw	r20,196(sp)
 820f410:	dcc03017 	ldw	r19,192(sp)
 820f414:	dc802f17 	ldw	r18,188(sp)
 820f418:	dc402e17 	ldw	r17,184(sp)
 820f41c:	dc002d17 	ldw	r16,180(sp)
 820f420:	dec03704 	addi	sp,sp,220
 820f424:	f800283a 	ret
 820f428:	820a9340 	call	820a934 <__sinit>
 820f42c:	003f2f06 	br	820f0ec <___vfiprintf_internal_r+0x48>
 820f430:	0463c83a 	sub	r17,zero,r17
 820f434:	d8802215 	stw	r2,136(sp)
 820f438:	a5000114 	ori	r20,r20,4
 820f43c:	80c00007 	ldb	r3,0(r16)
 820f440:	003f7706 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820f444:	00800c04 	movi	r2,48
 820f448:	da802217 	ldw	r10,136(sp)
 820f44c:	d8801d05 	stb	r2,116(sp)
 820f450:	00801e04 	movi	r2,120
 820f454:	d8801d45 	stb	r2,117(sp)
 820f458:	d8001d85 	stb	zero,118(sp)
 820f45c:	50c00104 	addi	r3,r10,4
 820f460:	54800017 	ldw	r18,0(r10)
 820f464:	0027883a 	mov	r19,zero
 820f468:	a0800094 	ori	r2,r20,2
 820f46c:	48030b16 	blt	r9,zero,821009c <___vfiprintf_internal_r+0xff8>
 820f470:	00bfdfc4 	movi	r2,-129
 820f474:	a096703a 	and	r11,r20,r2
 820f478:	d8c02215 	stw	r3,136(sp)
 820f47c:	5d000094 	ori	r20,r11,2
 820f480:	90032b1e 	bne	r18,zero,8210130 <___vfiprintf_internal_r+0x108c>
 820f484:	00820974 	movhi	r2,2085
 820f488:	10b55a04 	addi	r2,r2,-10904
 820f48c:	d8802615 	stw	r2,152(sp)
 820f490:	0039883a 	mov	fp,zero
 820f494:	48017b1e 	bne	r9,zero,820fa84 <___vfiprintf_internal_r+0x9e0>
 820f498:	0013883a 	mov	r9,zero
 820f49c:	0027883a 	mov	r19,zero
 820f4a0:	dd401a04 	addi	r21,sp,104
 820f4a4:	4825883a 	mov	r18,r9
 820f4a8:	4cc0010e 	bge	r9,r19,820f4b0 <___vfiprintf_internal_r+0x40c>
 820f4ac:	9825883a 	mov	r18,r19
 820f4b0:	e7003fcc 	andi	fp,fp,255
 820f4b4:	e700201c 	xori	fp,fp,128
 820f4b8:	e73fe004 	addi	fp,fp,-128
 820f4bc:	e0000126 	beq	fp,zero,820f4c4 <___vfiprintf_internal_r+0x420>
 820f4c0:	94800044 	addi	r18,r18,1
 820f4c4:	a380008c 	andi	r14,r20,2
 820f4c8:	70000126 	beq	r14,zero,820f4d0 <___vfiprintf_internal_r+0x42c>
 820f4cc:	94800084 	addi	r18,r18,2
 820f4d0:	a700210c 	andi	fp,r20,132
 820f4d4:	e001df1e 	bne	fp,zero,820fc54 <___vfiprintf_internal_r+0xbb0>
 820f4d8:	8c87c83a 	sub	r3,r17,r18
 820f4dc:	00c1dd0e 	bge	zero,r3,820fc54 <___vfiprintf_internal_r+0xbb0>
 820f4e0:	01c00404 	movi	r7,16
 820f4e4:	d8801c17 	ldw	r2,112(sp)
 820f4e8:	38c3ad0e 	bge	r7,r3,82103a0 <___vfiprintf_internal_r+0x12fc>
 820f4ec:	02820974 	movhi	r10,2085
 820f4f0:	52b5ce04 	addi	r10,r10,-10440
 820f4f4:	dc002915 	stw	r16,164(sp)
 820f4f8:	d9801b17 	ldw	r6,108(sp)
 820f4fc:	da802415 	stw	r10,144(sp)
 820f500:	03c001c4 	movi	r15,7
 820f504:	da402515 	stw	r9,148(sp)
 820f508:	db802815 	stw	r14,160(sp)
 820f50c:	1821883a 	mov	r16,r3
 820f510:	00000506 	br	820f528 <___vfiprintf_internal_r+0x484>
 820f514:	31400084 	addi	r5,r6,2
 820f518:	42000204 	addi	r8,r8,8
 820f51c:	200d883a 	mov	r6,r4
 820f520:	843ffc04 	addi	r16,r16,-16
 820f524:	3c000d0e 	bge	r7,r16,820f55c <___vfiprintf_internal_r+0x4b8>
 820f528:	10800404 	addi	r2,r2,16
 820f52c:	31000044 	addi	r4,r6,1
 820f530:	45800015 	stw	r22,0(r8)
 820f534:	41c00115 	stw	r7,4(r8)
 820f538:	d8801c15 	stw	r2,112(sp)
 820f53c:	d9001b15 	stw	r4,108(sp)
 820f540:	793ff40e 	bge	r15,r4,820f514 <___vfiprintf_internal_r+0x470>
 820f544:	1001b51e 	bne	r2,zero,820fc1c <___vfiprintf_internal_r+0xb78>
 820f548:	843ffc04 	addi	r16,r16,-16
 820f54c:	000d883a 	mov	r6,zero
 820f550:	01400044 	movi	r5,1
 820f554:	d811883a 	mov	r8,sp
 820f558:	3c3ff316 	blt	r7,r16,820f528 <___vfiprintf_internal_r+0x484>
 820f55c:	8007883a 	mov	r3,r16
 820f560:	da402517 	ldw	r9,148(sp)
 820f564:	db802817 	ldw	r14,160(sp)
 820f568:	dc002917 	ldw	r16,164(sp)
 820f56c:	da802417 	ldw	r10,144(sp)
 820f570:	1885883a 	add	r2,r3,r2
 820f574:	40c00115 	stw	r3,4(r8)
 820f578:	42800015 	stw	r10,0(r8)
 820f57c:	d8801c15 	stw	r2,112(sp)
 820f580:	d9401b15 	stw	r5,108(sp)
 820f584:	00c001c4 	movi	r3,7
 820f588:	19426016 	blt	r3,r5,820ff0c <___vfiprintf_internal_r+0xe68>
 820f58c:	d8c01d87 	ldb	r3,118(sp)
 820f590:	42000204 	addi	r8,r8,8
 820f594:	29000044 	addi	r4,r5,1
 820f598:	1801b31e 	bne	r3,zero,820fc68 <___vfiprintf_internal_r+0xbc4>
 820f59c:	7001c026 	beq	r14,zero,820fca0 <___vfiprintf_internal_r+0xbfc>
 820f5a0:	d8c01d04 	addi	r3,sp,116
 820f5a4:	10800084 	addi	r2,r2,2
 820f5a8:	40c00015 	stw	r3,0(r8)
 820f5ac:	00c00084 	movi	r3,2
 820f5b0:	40c00115 	stw	r3,4(r8)
 820f5b4:	d8801c15 	stw	r2,112(sp)
 820f5b8:	d9001b15 	stw	r4,108(sp)
 820f5bc:	00c001c4 	movi	r3,7
 820f5c0:	1902650e 	bge	r3,r4,820ff58 <___vfiprintf_internal_r+0xeb4>
 820f5c4:	10029a1e 	bne	r2,zero,8210030 <___vfiprintf_internal_r+0xf8c>
 820f5c8:	00c02004 	movi	r3,128
 820f5cc:	01000044 	movi	r4,1
 820f5d0:	000b883a 	mov	r5,zero
 820f5d4:	d811883a 	mov	r8,sp
 820f5d8:	e0c1b31e 	bne	fp,r3,820fca8 <___vfiprintf_internal_r+0xc04>
 820f5dc:	8cb9c83a 	sub	fp,r17,r18
 820f5e0:	0701b10e 	bge	zero,fp,820fca8 <___vfiprintf_internal_r+0xc04>
 820f5e4:	01c00404 	movi	r7,16
 820f5e8:	3f03890e 	bge	r7,fp,8210410 <___vfiprintf_internal_r+0x136c>
 820f5ec:	00c20974 	movhi	r3,2085
 820f5f0:	18f5ca04 	addi	r3,r3,-10456
 820f5f4:	d8c02415 	stw	r3,144(sp)
 820f5f8:	8007883a 	mov	r3,r16
 820f5fc:	034001c4 	movi	r13,7
 820f600:	e021883a 	mov	r16,fp
 820f604:	da402515 	stw	r9,148(sp)
 820f608:	1839883a 	mov	fp,r3
 820f60c:	00000506 	br	820f624 <___vfiprintf_internal_r+0x580>
 820f610:	29800084 	addi	r6,r5,2
 820f614:	42000204 	addi	r8,r8,8
 820f618:	180b883a 	mov	r5,r3
 820f61c:	843ffc04 	addi	r16,r16,-16
 820f620:	3c000d0e 	bge	r7,r16,820f658 <___vfiprintf_internal_r+0x5b4>
 820f624:	10800404 	addi	r2,r2,16
 820f628:	28c00044 	addi	r3,r5,1
 820f62c:	45c00015 	stw	r23,0(r8)
 820f630:	41c00115 	stw	r7,4(r8)
 820f634:	d8801c15 	stw	r2,112(sp)
 820f638:	d8c01b15 	stw	r3,108(sp)
 820f63c:	68fff40e 	bge	r13,r3,820f610 <___vfiprintf_internal_r+0x56c>
 820f640:	1002241e 	bne	r2,zero,820fed4 <___vfiprintf_internal_r+0xe30>
 820f644:	843ffc04 	addi	r16,r16,-16
 820f648:	01800044 	movi	r6,1
 820f64c:	000b883a 	mov	r5,zero
 820f650:	d811883a 	mov	r8,sp
 820f654:	3c3ff316 	blt	r7,r16,820f624 <___vfiprintf_internal_r+0x580>
 820f658:	da402517 	ldw	r9,148(sp)
 820f65c:	e007883a 	mov	r3,fp
 820f660:	8039883a 	mov	fp,r16
 820f664:	1821883a 	mov	r16,r3
 820f668:	d8c02417 	ldw	r3,144(sp)
 820f66c:	1705883a 	add	r2,r2,fp
 820f670:	47000115 	stw	fp,4(r8)
 820f674:	40c00015 	stw	r3,0(r8)
 820f678:	d8801c15 	stw	r2,112(sp)
 820f67c:	d9801b15 	stw	r6,108(sp)
 820f680:	00c001c4 	movi	r3,7
 820f684:	19827616 	blt	r3,r6,8210060 <___vfiprintf_internal_r+0xfbc>
 820f688:	4cf9c83a 	sub	fp,r9,r19
 820f68c:	42000204 	addi	r8,r8,8
 820f690:	31000044 	addi	r4,r6,1
 820f694:	300b883a 	mov	r5,r6
 820f698:	07018516 	blt	zero,fp,820fcb0 <___vfiprintf_internal_r+0xc0c>
 820f69c:	9885883a 	add	r2,r19,r2
 820f6a0:	45400015 	stw	r21,0(r8)
 820f6a4:	44c00115 	stw	r19,4(r8)
 820f6a8:	d8801c15 	stw	r2,112(sp)
 820f6ac:	d9001b15 	stw	r4,108(sp)
 820f6b0:	00c001c4 	movi	r3,7
 820f6b4:	1901dd0e 	bge	r3,r4,820fe2c <___vfiprintf_internal_r+0xd88>
 820f6b8:	1002401e 	bne	r2,zero,820ffbc <___vfiprintf_internal_r+0xf18>
 820f6bc:	d8001b15 	stw	zero,108(sp)
 820f6c0:	a2c0010c 	andi	r11,r20,4
 820f6c4:	58000226 	beq	r11,zero,820f6d0 <___vfiprintf_internal_r+0x62c>
 820f6c8:	8ca7c83a 	sub	r19,r17,r18
 820f6cc:	04c2f216 	blt	zero,r19,8210298 <___vfiprintf_internal_r+0x11f4>
 820f6d0:	8c80010e 	bge	r17,r18,820f6d8 <___vfiprintf_internal_r+0x634>
 820f6d4:	9023883a 	mov	r17,r18
 820f6d8:	da802317 	ldw	r10,140(sp)
 820f6dc:	5455883a 	add	r10,r10,r17
 820f6e0:	da802315 	stw	r10,140(sp)
 820f6e4:	d8001b15 	stw	zero,108(sp)
 820f6e8:	d811883a 	mov	r8,sp
 820f6ec:	003ea206 	br	820f178 <___vfiprintf_internal_r+0xd4>
 820f6f0:	a5000814 	ori	r20,r20,32
 820f6f4:	80c00007 	ldb	r3,0(r16)
 820f6f8:	003ec906 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820f6fc:	80c00007 	ldb	r3,0(r16)
 820f700:	1b030926 	beq	r3,r12,8210328 <___vfiprintf_internal_r+0x1284>
 820f704:	a5000414 	ori	r20,r20,16
 820f708:	003ec506 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820f70c:	21003fcc 	andi	r4,r4,255
 820f710:	20035e1e 	bne	r4,zero,821048c <___vfiprintf_internal_r+0x13e8>
 820f714:	a080080c 	andi	r2,r20,32
 820f718:	1002a526 	beq	r2,zero,82101b0 <___vfiprintf_internal_r+0x110c>
 820f71c:	da802217 	ldw	r10,136(sp)
 820f720:	50800017 	ldw	r2,0(r10)
 820f724:	da802317 	ldw	r10,140(sp)
 820f728:	5007d7fa 	srai	r3,r10,31
 820f72c:	da802217 	ldw	r10,136(sp)
 820f730:	10c00115 	stw	r3,4(r2)
 820f734:	52800104 	addi	r10,r10,4
 820f738:	da802215 	stw	r10,136(sp)
 820f73c:	da802317 	ldw	r10,140(sp)
 820f740:	12800015 	stw	r10,0(r2)
 820f744:	003e8c06 	br	820f178 <___vfiprintf_internal_r+0xd4>
 820f748:	21003fcc 	andi	r4,r4,255
 820f74c:	2003511e 	bne	r4,zero,8210494 <___vfiprintf_internal_r+0x13f0>
 820f750:	a080080c 	andi	r2,r20,32
 820f754:	1000a126 	beq	r2,zero,820f9dc <___vfiprintf_internal_r+0x938>
 820f758:	da802217 	ldw	r10,136(sp)
 820f75c:	d8001d85 	stb	zero,118(sp)
 820f760:	50800204 	addi	r2,r10,8
 820f764:	54800017 	ldw	r18,0(r10)
 820f768:	54c00117 	ldw	r19,4(r10)
 820f76c:	4802b416 	blt	r9,zero,8210240 <___vfiprintf_internal_r+0x119c>
 820f770:	013fdfc4 	movi	r4,-129
 820f774:	94c6b03a 	or	r3,r18,r19
 820f778:	d8802215 	stw	r2,136(sp)
 820f77c:	a128703a 	and	r20,r20,r4
 820f780:	1800a226 	beq	r3,zero,820fa0c <___vfiprintf_internal_r+0x968>
 820f784:	0039883a 	mov	fp,zero
 820f788:	dd401a04 	addi	r21,sp,104
 820f78c:	9006d0fa 	srli	r3,r18,3
 820f790:	9808977a 	slli	r4,r19,29
 820f794:	9826d0fa 	srli	r19,r19,3
 820f798:	948001cc 	andi	r18,r18,7
 820f79c:	90800c04 	addi	r2,r18,48
 820f7a0:	ad7fffc4 	addi	r21,r21,-1
 820f7a4:	20e4b03a 	or	r18,r4,r3
 820f7a8:	a8800005 	stb	r2,0(r21)
 820f7ac:	94c6b03a 	or	r3,r18,r19
 820f7b0:	183ff61e 	bne	r3,zero,820f78c <___vfiprintf_internal_r+0x6e8>
 820f7b4:	a0c0004c 	andi	r3,r20,1
 820f7b8:	18005926 	beq	r3,zero,820f920 <___vfiprintf_internal_r+0x87c>
 820f7bc:	10803fcc 	andi	r2,r2,255
 820f7c0:	1080201c 	xori	r2,r2,128
 820f7c4:	10bfe004 	addi	r2,r2,-128
 820f7c8:	00c00c04 	movi	r3,48
 820f7cc:	10c05426 	beq	r2,r3,820f920 <___vfiprintf_internal_r+0x87c>
 820f7d0:	da801e17 	ldw	r10,120(sp)
 820f7d4:	a8bfffc4 	addi	r2,r21,-1
 820f7d8:	a8ffffc5 	stb	r3,-1(r21)
 820f7dc:	50a7c83a 	sub	r19,r10,r2
 820f7e0:	102b883a 	mov	r21,r2
 820f7e4:	003f2f06 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 820f7e8:	21003fcc 	andi	r4,r4,255
 820f7ec:	2003421e 	bne	r4,zero,82104f8 <___vfiprintf_internal_r+0x1454>
 820f7f0:	00820974 	movhi	r2,2085
 820f7f4:	10b55a04 	addi	r2,r2,-10904
 820f7f8:	d8802615 	stw	r2,152(sp)
 820f7fc:	a080080c 	andi	r2,r20,32
 820f800:	1000aa26 	beq	r2,zero,820faac <___vfiprintf_internal_r+0xa08>
 820f804:	da802217 	ldw	r10,136(sp)
 820f808:	54800017 	ldw	r18,0(r10)
 820f80c:	54c00117 	ldw	r19,4(r10)
 820f810:	52800204 	addi	r10,r10,8
 820f814:	da802215 	stw	r10,136(sp)
 820f818:	a080004c 	andi	r2,r20,1
 820f81c:	1001d226 	beq	r2,zero,820ff68 <___vfiprintf_internal_r+0xec4>
 820f820:	94c4b03a 	or	r2,r18,r19
 820f824:	1002351e 	bne	r2,zero,82100fc <___vfiprintf_internal_r+0x1058>
 820f828:	d8001d85 	stb	zero,118(sp)
 820f82c:	48022216 	blt	r9,zero,82100b8 <___vfiprintf_internal_r+0x1014>
 820f830:	00bfdfc4 	movi	r2,-129
 820f834:	a0a8703a 	and	r20,r20,r2
 820f838:	003f1506 	br	820f490 <___vfiprintf_internal_r+0x3ec>
 820f83c:	da802217 	ldw	r10,136(sp)
 820f840:	04800044 	movi	r18,1
 820f844:	d8001d85 	stb	zero,118(sp)
 820f848:	50800017 	ldw	r2,0(r10)
 820f84c:	52800104 	addi	r10,r10,4
 820f850:	da802215 	stw	r10,136(sp)
 820f854:	d8801005 	stb	r2,64(sp)
 820f858:	9027883a 	mov	r19,r18
 820f85c:	dd401004 	addi	r21,sp,64
 820f860:	0013883a 	mov	r9,zero
 820f864:	003f1706 	br	820f4c4 <___vfiprintf_internal_r+0x420>
 820f868:	21003fcc 	andi	r4,r4,255
 820f86c:	2003201e 	bne	r4,zero,82104f0 <___vfiprintf_internal_r+0x144c>
 820f870:	a080080c 	andi	r2,r20,32
 820f874:	10004b26 	beq	r2,zero,820f9a4 <___vfiprintf_internal_r+0x900>
 820f878:	da802217 	ldw	r10,136(sp)
 820f87c:	50800117 	ldw	r2,4(r10)
 820f880:	54800017 	ldw	r18,0(r10)
 820f884:	52800204 	addi	r10,r10,8
 820f888:	da802215 	stw	r10,136(sp)
 820f88c:	1027883a 	mov	r19,r2
 820f890:	10022c16 	blt	r2,zero,8210144 <___vfiprintf_internal_r+0x10a0>
 820f894:	df001d83 	ldbu	fp,118(sp)
 820f898:	48007216 	blt	r9,zero,820fa64 <___vfiprintf_internal_r+0x9c0>
 820f89c:	00ffdfc4 	movi	r3,-129
 820f8a0:	94c4b03a 	or	r2,r18,r19
 820f8a4:	a0e8703a 	and	r20,r20,r3
 820f8a8:	1000cc26 	beq	r2,zero,820fbdc <___vfiprintf_internal_r+0xb38>
 820f8ac:	98021026 	beq	r19,zero,82100f0 <___vfiprintf_internal_r+0x104c>
 820f8b0:	dc402415 	stw	r17,144(sp)
 820f8b4:	dc002515 	stw	r16,148(sp)
 820f8b8:	9823883a 	mov	r17,r19
 820f8bc:	9021883a 	mov	r16,r18
 820f8c0:	dd401a04 	addi	r21,sp,104
 820f8c4:	4825883a 	mov	r18,r9
 820f8c8:	4027883a 	mov	r19,r8
 820f8cc:	8009883a 	mov	r4,r16
 820f8d0:	880b883a 	mov	r5,r17
 820f8d4:	01800284 	movi	r6,10
 820f8d8:	000f883a 	mov	r7,zero
 820f8dc:	821132c0 	call	821132c <__umoddi3>
 820f8e0:	10800c04 	addi	r2,r2,48
 820f8e4:	ad7fffc4 	addi	r21,r21,-1
 820f8e8:	8009883a 	mov	r4,r16
 820f8ec:	880b883a 	mov	r5,r17
 820f8f0:	a8800005 	stb	r2,0(r21)
 820f8f4:	01800284 	movi	r6,10
 820f8f8:	000f883a 	mov	r7,zero
 820f8fc:	8210db40 	call	8210db4 <__udivdi3>
 820f900:	1021883a 	mov	r16,r2
 820f904:	10c4b03a 	or	r2,r2,r3
 820f908:	1823883a 	mov	r17,r3
 820f90c:	103fef1e 	bne	r2,zero,820f8cc <___vfiprintf_internal_r+0x828>
 820f910:	dc402417 	ldw	r17,144(sp)
 820f914:	dc002517 	ldw	r16,148(sp)
 820f918:	9013883a 	mov	r9,r18
 820f91c:	9811883a 	mov	r8,r19
 820f920:	da801e17 	ldw	r10,120(sp)
 820f924:	5567c83a 	sub	r19,r10,r21
 820f928:	003ede06 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 820f92c:	38803fcc 	andi	r2,r7,255
 820f930:	1080201c 	xori	r2,r2,128
 820f934:	10bfe004 	addi	r2,r2,-128
 820f938:	1002371e 	bne	r2,zero,8210218 <___vfiprintf_internal_r+0x1174>
 820f93c:	01000044 	movi	r4,1
 820f940:	01c00804 	movi	r7,32
 820f944:	80c00007 	ldb	r3,0(r16)
 820f948:	003e3506 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820f94c:	a5000054 	ori	r20,r20,1
 820f950:	80c00007 	ldb	r3,0(r16)
 820f954:	003e3206 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820f958:	a5002014 	ori	r20,r20,128
 820f95c:	80c00007 	ldb	r3,0(r16)
 820f960:	003e2f06 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820f964:	8015883a 	mov	r10,r16
 820f968:	0023883a 	mov	r17,zero
 820f96c:	18bff404 	addi	r2,r3,-48
 820f970:	50c00007 	ldb	r3,0(r10)
 820f974:	8c4002a4 	muli	r17,r17,10
 820f978:	84000044 	addi	r16,r16,1
 820f97c:	8015883a 	mov	r10,r16
 820f980:	1463883a 	add	r17,r2,r17
 820f984:	18bff404 	addi	r2,r3,-48
 820f988:	30bff92e 	bgeu	r6,r2,820f970 <___vfiprintf_internal_r+0x8cc>
 820f98c:	003e2506 	br	820f224 <___vfiprintf_internal_r+0x180>
 820f990:	21003fcc 	andi	r4,r4,255
 820f994:	2002d41e 	bne	r4,zero,82104e8 <___vfiprintf_internal_r+0x1444>
 820f998:	a5000414 	ori	r20,r20,16
 820f99c:	a080080c 	andi	r2,r20,32
 820f9a0:	103fb51e 	bne	r2,zero,820f878 <___vfiprintf_internal_r+0x7d4>
 820f9a4:	a080040c 	andi	r2,r20,16
 820f9a8:	1001f826 	beq	r2,zero,821018c <___vfiprintf_internal_r+0x10e8>
 820f9ac:	da802217 	ldw	r10,136(sp)
 820f9b0:	54800017 	ldw	r18,0(r10)
 820f9b4:	52800104 	addi	r10,r10,4
 820f9b8:	da802215 	stw	r10,136(sp)
 820f9bc:	9027d7fa 	srai	r19,r18,31
 820f9c0:	9805883a 	mov	r2,r19
 820f9c4:	003fb206 	br	820f890 <___vfiprintf_internal_r+0x7ec>
 820f9c8:	21003fcc 	andi	r4,r4,255
 820f9cc:	2002c41e 	bne	r4,zero,82104e0 <___vfiprintf_internal_r+0x143c>
 820f9d0:	a5000414 	ori	r20,r20,16
 820f9d4:	a080080c 	andi	r2,r20,32
 820f9d8:	103f5f1e 	bne	r2,zero,820f758 <___vfiprintf_internal_r+0x6b4>
 820f9dc:	a080040c 	andi	r2,r20,16
 820f9e0:	10020f26 	beq	r2,zero,8210220 <___vfiprintf_internal_r+0x117c>
 820f9e4:	da802217 	ldw	r10,136(sp)
 820f9e8:	d8001d85 	stb	zero,118(sp)
 820f9ec:	0027883a 	mov	r19,zero
 820f9f0:	50800104 	addi	r2,r10,4
 820f9f4:	54800017 	ldw	r18,0(r10)
 820f9f8:	48021116 	blt	r9,zero,8210240 <___vfiprintf_internal_r+0x119c>
 820f9fc:	00ffdfc4 	movi	r3,-129
 820fa00:	d8802215 	stw	r2,136(sp)
 820fa04:	a0e8703a 	and	r20,r20,r3
 820fa08:	903f5e1e 	bne	r18,zero,820f784 <___vfiprintf_internal_r+0x6e0>
 820fa0c:	0039883a 	mov	fp,zero
 820fa10:	4802a626 	beq	r9,zero,82104ac <___vfiprintf_internal_r+0x1408>
 820fa14:	0025883a 	mov	r18,zero
 820fa18:	0027883a 	mov	r19,zero
 820fa1c:	003f5a06 	br	820f788 <___vfiprintf_internal_r+0x6e4>
 820fa20:	21003fcc 	andi	r4,r4,255
 820fa24:	20029f1e 	bne	r4,zero,82104a4 <___vfiprintf_internal_r+0x1400>
 820fa28:	a5000414 	ori	r20,r20,16
 820fa2c:	a080080c 	andi	r2,r20,32
 820fa30:	10005e1e 	bne	r2,zero,820fbac <___vfiprintf_internal_r+0xb08>
 820fa34:	a080040c 	andi	r2,r20,16
 820fa38:	1001a21e 	bne	r2,zero,82100c4 <___vfiprintf_internal_r+0x1020>
 820fa3c:	a080100c 	andi	r2,r20,64
 820fa40:	d8001d85 	stb	zero,118(sp)
 820fa44:	da802217 	ldw	r10,136(sp)
 820fa48:	1002231e 	bne	r2,zero,82102d8 <___vfiprintf_internal_r+0x1234>
 820fa4c:	50800104 	addi	r2,r10,4
 820fa50:	54800017 	ldw	r18,0(r10)
 820fa54:	0027883a 	mov	r19,zero
 820fa58:	4801a00e 	bge	r9,zero,82100dc <___vfiprintf_internal_r+0x1038>
 820fa5c:	d8802215 	stw	r2,136(sp)
 820fa60:	0039883a 	mov	fp,zero
 820fa64:	94c4b03a 	or	r2,r18,r19
 820fa68:	103f901e 	bne	r2,zero,820f8ac <___vfiprintf_internal_r+0x808>
 820fa6c:	00800044 	movi	r2,1
 820fa70:	10803fcc 	andi	r2,r2,255
 820fa74:	00c00044 	movi	r3,1
 820fa78:	10c05926 	beq	r2,r3,820fbe0 <___vfiprintf_internal_r+0xb3c>
 820fa7c:	00c00084 	movi	r3,2
 820fa80:	10ffe41e 	bne	r2,r3,820fa14 <___vfiprintf_internal_r+0x970>
 820fa84:	0025883a 	mov	r18,zero
 820fa88:	0027883a 	mov	r19,zero
 820fa8c:	00013d06 	br	820ff84 <___vfiprintf_internal_r+0xee0>
 820fa90:	21003fcc 	andi	r4,r4,255
 820fa94:	2002811e 	bne	r4,zero,821049c <___vfiprintf_internal_r+0x13f8>
 820fa98:	00820974 	movhi	r2,2085
 820fa9c:	10b55504 	addi	r2,r2,-10924
 820faa0:	d8802615 	stw	r2,152(sp)
 820faa4:	a080080c 	andi	r2,r20,32
 820faa8:	103f561e 	bne	r2,zero,820f804 <___vfiprintf_internal_r+0x760>
 820faac:	a080040c 	andi	r2,r20,16
 820fab0:	1001d126 	beq	r2,zero,82101f8 <___vfiprintf_internal_r+0x1154>
 820fab4:	da802217 	ldw	r10,136(sp)
 820fab8:	0027883a 	mov	r19,zero
 820fabc:	54800017 	ldw	r18,0(r10)
 820fac0:	52800104 	addi	r10,r10,4
 820fac4:	da802215 	stw	r10,136(sp)
 820fac8:	003f5306 	br	820f818 <___vfiprintf_internal_r+0x774>
 820facc:	da802217 	ldw	r10,136(sp)
 820fad0:	d8001d85 	stb	zero,118(sp)
 820fad4:	55400017 	ldw	r21,0(r10)
 820fad8:	50c00104 	addi	r3,r10,4
 820fadc:	a8024226 	beq	r21,zero,82103e8 <___vfiprintf_internal_r+0x1344>
 820fae0:	48021816 	blt	r9,zero,8210344 <___vfiprintf_internal_r+0x12a0>
 820fae4:	480d883a 	mov	r6,r9
 820fae8:	000b883a 	mov	r5,zero
 820faec:	a809883a 	mov	r4,r21
 820faf0:	d8c02a15 	stw	r3,168(sp)
 820faf4:	da002b15 	stw	r8,172(sp)
 820faf8:	da402c15 	stw	r9,176(sp)
 820fafc:	820bff40 	call	820bff4 <memchr>
 820fb00:	d8c02a17 	ldw	r3,168(sp)
 820fb04:	da002b17 	ldw	r8,172(sp)
 820fb08:	da402c17 	ldw	r9,176(sp)
 820fb0c:	10024826 	beq	r2,zero,8210430 <___vfiprintf_internal_r+0x138c>
 820fb10:	1567c83a 	sub	r19,r2,r21
 820fb14:	df001d83 	ldbu	fp,118(sp)
 820fb18:	d8c02215 	stw	r3,136(sp)
 820fb1c:	0013883a 	mov	r9,zero
 820fb20:	003e6006 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 820fb24:	21003fcc 	andi	r4,r4,255
 820fb28:	203fc026 	beq	r4,zero,820fa2c <___vfiprintf_internal_r+0x988>
 820fb2c:	d9c01d85 	stb	r7,118(sp)
 820fb30:	003fbe06 	br	820fa2c <___vfiprintf_internal_r+0x988>
 820fb34:	da802217 	ldw	r10,136(sp)
 820fb38:	54400017 	ldw	r17,0(r10)
 820fb3c:	50800104 	addi	r2,r10,4
 820fb40:	883e3b16 	blt	r17,zero,820f430 <___vfiprintf_internal_r+0x38c>
 820fb44:	d8802215 	stw	r2,136(sp)
 820fb48:	80c00007 	ldb	r3,0(r16)
 820fb4c:	003db406 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820fb50:	01000044 	movi	r4,1
 820fb54:	01c00ac4 	movi	r7,43
 820fb58:	80c00007 	ldb	r3,0(r16)
 820fb5c:	003db006 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820fb60:	80c00007 	ldb	r3,0(r16)
 820fb64:	82800044 	addi	r10,r16,1
 820fb68:	1b423c26 	beq	r3,r13,821045c <___vfiprintf_internal_r+0x13b8>
 820fb6c:	18bff404 	addi	r2,r3,-48
 820fb70:	0013883a 	mov	r9,zero
 820fb74:	30822b36 	bltu	r6,r2,8210424 <___vfiprintf_internal_r+0x1380>
 820fb78:	50c00007 	ldb	r3,0(r10)
 820fb7c:	4a4002a4 	muli	r9,r9,10
 820fb80:	54000044 	addi	r16,r10,1
 820fb84:	8015883a 	mov	r10,r16
 820fb88:	4893883a 	add	r9,r9,r2
 820fb8c:	18bff404 	addi	r2,r3,-48
 820fb90:	30bff92e 	bgeu	r6,r2,820fb78 <___vfiprintf_internal_r+0xad4>
 820fb94:	483da30e 	bge	r9,zero,820f224 <___vfiprintf_internal_r+0x180>
 820fb98:	027fffc4 	movi	r9,-1
 820fb9c:	003da106 	br	820f224 <___vfiprintf_internal_r+0x180>
 820fba0:	a5001014 	ori	r20,r20,64
 820fba4:	80c00007 	ldb	r3,0(r16)
 820fba8:	003d9d06 	br	820f220 <___vfiprintf_internal_r+0x17c>
 820fbac:	da802217 	ldw	r10,136(sp)
 820fbb0:	d8001d85 	stb	zero,118(sp)
 820fbb4:	50c00204 	addi	r3,r10,8
 820fbb8:	54800017 	ldw	r18,0(r10)
 820fbbc:	54c00117 	ldw	r19,4(r10)
 820fbc0:	4801ca16 	blt	r9,zero,82102ec <___vfiprintf_internal_r+0x1248>
 820fbc4:	013fdfc4 	movi	r4,-129
 820fbc8:	94c4b03a 	or	r2,r18,r19
 820fbcc:	d8c02215 	stw	r3,136(sp)
 820fbd0:	a128703a 	and	r20,r20,r4
 820fbd4:	0039883a 	mov	fp,zero
 820fbd8:	103f341e 	bne	r2,zero,820f8ac <___vfiprintf_internal_r+0x808>
 820fbdc:	483e2e26 	beq	r9,zero,820f498 <___vfiprintf_internal_r+0x3f4>
 820fbe0:	0025883a 	mov	r18,zero
 820fbe4:	94800c04 	addi	r18,r18,48
 820fbe8:	dc8019c5 	stb	r18,103(sp)
 820fbec:	dcc02717 	ldw	r19,156(sp)
 820fbf0:	dd4019c4 	addi	r21,sp,103
 820fbf4:	003e2b06 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 820fbf8:	21003fcc 	andi	r4,r4,255
 820fbfc:	2002361e 	bne	r4,zero,82104d8 <___vfiprintf_internal_r+0x1434>
 820fc00:	1801c126 	beq	r3,zero,8210308 <___vfiprintf_internal_r+0x1264>
 820fc04:	04800044 	movi	r18,1
 820fc08:	d8c01005 	stb	r3,64(sp)
 820fc0c:	d8001d85 	stb	zero,118(sp)
 820fc10:	9027883a 	mov	r19,r18
 820fc14:	dd401004 	addi	r21,sp,64
 820fc18:	003f1106 	br	820f860 <___vfiprintf_internal_r+0x7bc>
 820fc1c:	d9402117 	ldw	r5,132(sp)
 820fc20:	d9002017 	ldw	r4,128(sp)
 820fc24:	d9801a04 	addi	r6,sp,104
 820fc28:	d9c02b15 	stw	r7,172(sp)
 820fc2c:	dbc02a15 	stw	r15,168(sp)
 820fc30:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820fc34:	d9c02b17 	ldw	r7,172(sp)
 820fc38:	dbc02a17 	ldw	r15,168(sp)
 820fc3c:	10006d1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820fc40:	d9801b17 	ldw	r6,108(sp)
 820fc44:	d8801c17 	ldw	r2,112(sp)
 820fc48:	d811883a 	mov	r8,sp
 820fc4c:	31400044 	addi	r5,r6,1
 820fc50:	003e3306 	br	820f520 <___vfiprintf_internal_r+0x47c>
 820fc54:	d9401b17 	ldw	r5,108(sp)
 820fc58:	d8801c17 	ldw	r2,112(sp)
 820fc5c:	29000044 	addi	r4,r5,1
 820fc60:	d8c01d87 	ldb	r3,118(sp)
 820fc64:	183e4d26 	beq	r3,zero,820f59c <___vfiprintf_internal_r+0x4f8>
 820fc68:	00c00044 	movi	r3,1
 820fc6c:	d9401d84 	addi	r5,sp,118
 820fc70:	10c5883a 	add	r2,r2,r3
 820fc74:	41400015 	stw	r5,0(r8)
 820fc78:	40c00115 	stw	r3,4(r8)
 820fc7c:	d8801c15 	stw	r2,112(sp)
 820fc80:	d9001b15 	stw	r4,108(sp)
 820fc84:	014001c4 	movi	r5,7
 820fc88:	2900a90e 	bge	r5,r4,820ff30 <___vfiprintf_internal_r+0xe8c>
 820fc8c:	1000da1e 	bne	r2,zero,820fff8 <___vfiprintf_internal_r+0xf54>
 820fc90:	7000ab1e 	bne	r14,zero,820ff40 <___vfiprintf_internal_r+0xe9c>
 820fc94:	000b883a 	mov	r5,zero
 820fc98:	1809883a 	mov	r4,r3
 820fc9c:	d811883a 	mov	r8,sp
 820fca0:	00c02004 	movi	r3,128
 820fca4:	e0fe4d26 	beq	fp,r3,820f5dc <___vfiprintf_internal_r+0x538>
 820fca8:	4cf9c83a 	sub	fp,r9,r19
 820fcac:	073e7b0e 	bge	zero,fp,820f69c <___vfiprintf_internal_r+0x5f8>
 820fcb0:	01c00404 	movi	r7,16
 820fcb4:	3f01900e 	bge	r7,fp,82102f8 <___vfiprintf_internal_r+0x1254>
 820fcb8:	00c20974 	movhi	r3,2085
 820fcbc:	18f5ca04 	addi	r3,r3,-10456
 820fcc0:	d8c02415 	stw	r3,144(sp)
 820fcc4:	034001c4 	movi	r13,7
 820fcc8:	00000506 	br	820fce0 <___vfiprintf_internal_r+0xc3c>
 820fccc:	29000084 	addi	r4,r5,2
 820fcd0:	42000204 	addi	r8,r8,8
 820fcd4:	180b883a 	mov	r5,r3
 820fcd8:	e73ffc04 	addi	fp,fp,-16
 820fcdc:	3f000d0e 	bge	r7,fp,820fd14 <___vfiprintf_internal_r+0xc70>
 820fce0:	10800404 	addi	r2,r2,16
 820fce4:	28c00044 	addi	r3,r5,1
 820fce8:	45c00015 	stw	r23,0(r8)
 820fcec:	41c00115 	stw	r7,4(r8)
 820fcf0:	d8801c15 	stw	r2,112(sp)
 820fcf4:	d8c01b15 	stw	r3,108(sp)
 820fcf8:	68fff40e 	bge	r13,r3,820fccc <___vfiprintf_internal_r+0xc28>
 820fcfc:	1000101e 	bne	r2,zero,820fd40 <___vfiprintf_internal_r+0xc9c>
 820fd00:	e73ffc04 	addi	fp,fp,-16
 820fd04:	01000044 	movi	r4,1
 820fd08:	000b883a 	mov	r5,zero
 820fd0c:	d811883a 	mov	r8,sp
 820fd10:	3f3ff316 	blt	r7,fp,820fce0 <___vfiprintf_internal_r+0xc3c>
 820fd14:	da802417 	ldw	r10,144(sp)
 820fd18:	1705883a 	add	r2,r2,fp
 820fd1c:	47000115 	stw	fp,4(r8)
 820fd20:	42800015 	stw	r10,0(r8)
 820fd24:	d8801c15 	stw	r2,112(sp)
 820fd28:	d9001b15 	stw	r4,108(sp)
 820fd2c:	00c001c4 	movi	r3,7
 820fd30:	19003616 	blt	r3,r4,820fe0c <___vfiprintf_internal_r+0xd68>
 820fd34:	42000204 	addi	r8,r8,8
 820fd38:	21000044 	addi	r4,r4,1
 820fd3c:	003e5706 	br	820f69c <___vfiprintf_internal_r+0x5f8>
 820fd40:	d9402117 	ldw	r5,132(sp)
 820fd44:	d9002017 	ldw	r4,128(sp)
 820fd48:	d9801a04 	addi	r6,sp,104
 820fd4c:	d9c02b15 	stw	r7,172(sp)
 820fd50:	db402a15 	stw	r13,168(sp)
 820fd54:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820fd58:	d9c02b17 	ldw	r7,172(sp)
 820fd5c:	db402a17 	ldw	r13,168(sp)
 820fd60:	1000241e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820fd64:	d9401b17 	ldw	r5,108(sp)
 820fd68:	d8801c17 	ldw	r2,112(sp)
 820fd6c:	d811883a 	mov	r8,sp
 820fd70:	29000044 	addi	r4,r5,1
 820fd74:	003fd806 	br	820fcd8 <___vfiprintf_internal_r+0xc34>
 820fd78:	d9401b17 	ldw	r5,108(sp)
 820fd7c:	00c20974 	movhi	r3,2085
 820fd80:	18f5ce04 	addi	r3,r3,-10440
 820fd84:	d8c02415 	stw	r3,144(sp)
 820fd88:	29400044 	addi	r5,r5,1
 820fd8c:	d8c02417 	ldw	r3,144(sp)
 820fd90:	14c5883a 	add	r2,r2,r19
 820fd94:	44c00115 	stw	r19,4(r8)
 820fd98:	40c00015 	stw	r3,0(r8)
 820fd9c:	d8801c15 	stw	r2,112(sp)
 820fda0:	d9401b15 	stw	r5,108(sp)
 820fda4:	00c001c4 	movi	r3,7
 820fda8:	1940070e 	bge	r3,r5,820fdc8 <___vfiprintf_internal_r+0xd24>
 820fdac:	103e4826 	beq	r2,zero,820f6d0 <___vfiprintf_internal_r+0x62c>
 820fdb0:	d9402117 	ldw	r5,132(sp)
 820fdb4:	d9002017 	ldw	r4,128(sp)
 820fdb8:	d9801a04 	addi	r6,sp,104
 820fdbc:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820fdc0:	10000c1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820fdc4:	d8801c17 	ldw	r2,112(sp)
 820fdc8:	8c80010e 	bge	r17,r18,820fdd0 <___vfiprintf_internal_r+0xd2c>
 820fdcc:	9023883a 	mov	r17,r18
 820fdd0:	da802317 	ldw	r10,140(sp)
 820fdd4:	5455883a 	add	r10,r10,r17
 820fdd8:	da802315 	stw	r10,140(sp)
 820fddc:	103e4126 	beq	r2,zero,820f6e4 <___vfiprintf_internal_r+0x640>
 820fde0:	d9402117 	ldw	r5,132(sp)
 820fde4:	d9002017 	ldw	r4,128(sp)
 820fde8:	d9801a04 	addi	r6,sp,104
 820fdec:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820fdf0:	103e3c26 	beq	r2,zero,820f6e4 <___vfiprintf_internal_r+0x640>
 820fdf4:	dd002117 	ldw	r20,132(sp)
 820fdf8:	a080030b 	ldhu	r2,12(r20)
 820fdfc:	1080100c 	andi	r2,r2,64
 820fe00:	1001231e 	bne	r2,zero,8210290 <___vfiprintf_internal_r+0x11ec>
 820fe04:	d8802317 	ldw	r2,140(sp)
 820fe08:	003d7b06 	br	820f3f8 <___vfiprintf_internal_r+0x354>
 820fe0c:	1000991e 	bne	r2,zero,8210074 <___vfiprintf_internal_r+0xfd0>
 820fe10:	00c00044 	movi	r3,1
 820fe14:	9805883a 	mov	r2,r19
 820fe18:	dd400015 	stw	r21,0(sp)
 820fe1c:	dcc00115 	stw	r19,4(sp)
 820fe20:	dcc01c15 	stw	r19,112(sp)
 820fe24:	d8c01b15 	stw	r3,108(sp)
 820fe28:	d811883a 	mov	r8,sp
 820fe2c:	42000204 	addi	r8,r8,8
 820fe30:	a2c0010c 	andi	r11,r20,4
 820fe34:	583fe426 	beq	r11,zero,820fdc8 <___vfiprintf_internal_r+0xd24>
 820fe38:	8ca7c83a 	sub	r19,r17,r18
 820fe3c:	04ffe20e 	bge	zero,r19,820fdc8 <___vfiprintf_internal_r+0xd24>
 820fe40:	01c00404 	movi	r7,16
 820fe44:	3cffcc0e 	bge	r7,r19,820fd78 <___vfiprintf_internal_r+0xcd4>
 820fe48:	02820974 	movhi	r10,2085
 820fe4c:	52b5ce04 	addi	r10,r10,-10440
 820fe50:	d9001b17 	ldw	r4,108(sp)
 820fe54:	da802415 	stw	r10,144(sp)
 820fe58:	382b883a 	mov	r21,r7
 820fe5c:	050001c4 	movi	r20,7
 820fe60:	df002017 	ldw	fp,128(sp)
 820fe64:	00000506 	br	820fe7c <___vfiprintf_internal_r+0xdd8>
 820fe68:	21400084 	addi	r5,r4,2
 820fe6c:	42000204 	addi	r8,r8,8
 820fe70:	1809883a 	mov	r4,r3
 820fe74:	9cfffc04 	addi	r19,r19,-16
 820fe78:	acffc40e 	bge	r21,r19,820fd8c <___vfiprintf_internal_r+0xce8>
 820fe7c:	10800404 	addi	r2,r2,16
 820fe80:	20c00044 	addi	r3,r4,1
 820fe84:	45800015 	stw	r22,0(r8)
 820fe88:	45400115 	stw	r21,4(r8)
 820fe8c:	d8801c15 	stw	r2,112(sp)
 820fe90:	d8c01b15 	stw	r3,108(sp)
 820fe94:	a0fff40e 	bge	r20,r3,820fe68 <___vfiprintf_internal_r+0xdc4>
 820fe98:	1000041e 	bne	r2,zero,820feac <___vfiprintf_internal_r+0xe08>
 820fe9c:	01400044 	movi	r5,1
 820fea0:	0009883a 	mov	r4,zero
 820fea4:	d811883a 	mov	r8,sp
 820fea8:	003ff206 	br	820fe74 <___vfiprintf_internal_r+0xdd0>
 820feac:	d9402117 	ldw	r5,132(sp)
 820feb0:	d9801a04 	addi	r6,sp,104
 820feb4:	e009883a 	mov	r4,fp
 820feb8:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820febc:	103fcd1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820fec0:	d9001b17 	ldw	r4,108(sp)
 820fec4:	d8801c17 	ldw	r2,112(sp)
 820fec8:	d811883a 	mov	r8,sp
 820fecc:	21400044 	addi	r5,r4,1
 820fed0:	003fe806 	br	820fe74 <___vfiprintf_internal_r+0xdd0>
 820fed4:	d9402117 	ldw	r5,132(sp)
 820fed8:	d9002017 	ldw	r4,128(sp)
 820fedc:	d9801a04 	addi	r6,sp,104
 820fee0:	d9c02b15 	stw	r7,172(sp)
 820fee4:	db402a15 	stw	r13,168(sp)
 820fee8:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820feec:	d9c02b17 	ldw	r7,172(sp)
 820fef0:	db402a17 	ldw	r13,168(sp)
 820fef4:	103fbf1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820fef8:	d9401b17 	ldw	r5,108(sp)
 820fefc:	d8801c17 	ldw	r2,112(sp)
 820ff00:	d811883a 	mov	r8,sp
 820ff04:	29800044 	addi	r6,r5,1
 820ff08:	003dc406 	br	820f61c <___vfiprintf_internal_r+0x578>
 820ff0c:	1000d21e 	bne	r2,zero,8210258 <___vfiprintf_internal_r+0x11b4>
 820ff10:	d8c01d87 	ldb	r3,118(sp)
 820ff14:	18009526 	beq	r3,zero,821016c <___vfiprintf_internal_r+0x10c8>
 820ff18:	00800044 	movi	r2,1
 820ff1c:	d8c01d84 	addi	r3,sp,118
 820ff20:	1009883a 	mov	r4,r2
 820ff24:	d8c00015 	stw	r3,0(sp)
 820ff28:	d8800115 	stw	r2,4(sp)
 820ff2c:	d811883a 	mov	r8,sp
 820ff30:	200b883a 	mov	r5,r4
 820ff34:	42000204 	addi	r8,r8,8
 820ff38:	21000044 	addi	r4,r4,1
 820ff3c:	003d9706 	br	820f59c <___vfiprintf_internal_r+0x4f8>
 820ff40:	d9001d04 	addi	r4,sp,116
 820ff44:	00800084 	movi	r2,2
 820ff48:	d9000015 	stw	r4,0(sp)
 820ff4c:	d8800115 	stw	r2,4(sp)
 820ff50:	1809883a 	mov	r4,r3
 820ff54:	d811883a 	mov	r8,sp
 820ff58:	200b883a 	mov	r5,r4
 820ff5c:	42000204 	addi	r8,r8,8
 820ff60:	21000044 	addi	r4,r4,1
 820ff64:	003f4e06 	br	820fca0 <___vfiprintf_internal_r+0xbfc>
 820ff68:	d8001d85 	stb	zero,118(sp)
 820ff6c:	48005016 	blt	r9,zero,82100b0 <___vfiprintf_internal_r+0x100c>
 820ff70:	00ffdfc4 	movi	r3,-129
 820ff74:	94c4b03a 	or	r2,r18,r19
 820ff78:	a0e8703a 	and	r20,r20,r3
 820ff7c:	103d4426 	beq	r2,zero,820f490 <___vfiprintf_internal_r+0x3ec>
 820ff80:	0039883a 	mov	fp,zero
 820ff84:	d9002617 	ldw	r4,152(sp)
 820ff88:	dd401a04 	addi	r21,sp,104
 820ff8c:	908003cc 	andi	r2,r18,15
 820ff90:	9806973a 	slli	r3,r19,28
 820ff94:	2085883a 	add	r2,r4,r2
 820ff98:	9024d13a 	srli	r18,r18,4
 820ff9c:	10800003 	ldbu	r2,0(r2)
 820ffa0:	9826d13a 	srli	r19,r19,4
 820ffa4:	ad7fffc4 	addi	r21,r21,-1
 820ffa8:	1ca4b03a 	or	r18,r3,r18
 820ffac:	a8800005 	stb	r2,0(r21)
 820ffb0:	94c4b03a 	or	r2,r18,r19
 820ffb4:	103ff51e 	bne	r2,zero,820ff8c <___vfiprintf_internal_r+0xee8>
 820ffb8:	003e5906 	br	820f920 <___vfiprintf_internal_r+0x87c>
 820ffbc:	d9402117 	ldw	r5,132(sp)
 820ffc0:	d9002017 	ldw	r4,128(sp)
 820ffc4:	d9801a04 	addi	r6,sp,104
 820ffc8:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820ffcc:	103f891e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820ffd0:	d8801c17 	ldw	r2,112(sp)
 820ffd4:	d811883a 	mov	r8,sp
 820ffd8:	003f9506 	br	820fe30 <___vfiprintf_internal_r+0xd8c>
 820ffdc:	d9402117 	ldw	r5,132(sp)
 820ffe0:	d9002017 	ldw	r4,128(sp)
 820ffe4:	d9801a04 	addi	r6,sp,104
 820ffe8:	820ef900 	call	820ef90 <__sprint_r.part.0>
 820ffec:	103f811e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 820fff0:	d811883a 	mov	r8,sp
 820fff4:	003ced06 	br	820f3ac <___vfiprintf_internal_r+0x308>
 820fff8:	d9402117 	ldw	r5,132(sp)
 820fffc:	d9002017 	ldw	r4,128(sp)
 8210000:	d9801a04 	addi	r6,sp,104
 8210004:	da402c15 	stw	r9,176(sp)
 8210008:	db802a15 	stw	r14,168(sp)
 821000c:	820ef900 	call	820ef90 <__sprint_r.part.0>
 8210010:	da402c17 	ldw	r9,176(sp)
 8210014:	db802a17 	ldw	r14,168(sp)
 8210018:	103f761e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 821001c:	d9401b17 	ldw	r5,108(sp)
 8210020:	d8801c17 	ldw	r2,112(sp)
 8210024:	d811883a 	mov	r8,sp
 8210028:	29000044 	addi	r4,r5,1
 821002c:	003d5b06 	br	820f59c <___vfiprintf_internal_r+0x4f8>
 8210030:	d9402117 	ldw	r5,132(sp)
 8210034:	d9002017 	ldw	r4,128(sp)
 8210038:	d9801a04 	addi	r6,sp,104
 821003c:	da402c15 	stw	r9,176(sp)
 8210040:	820ef900 	call	820ef90 <__sprint_r.part.0>
 8210044:	da402c17 	ldw	r9,176(sp)
 8210048:	103f6a1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 821004c:	d9401b17 	ldw	r5,108(sp)
 8210050:	d8801c17 	ldw	r2,112(sp)
 8210054:	d811883a 	mov	r8,sp
 8210058:	29000044 	addi	r4,r5,1
 821005c:	003f1006 	br	820fca0 <___vfiprintf_internal_r+0xbfc>
 8210060:	1000c31e 	bne	r2,zero,8210370 <___vfiprintf_internal_r+0x12cc>
 8210064:	01000044 	movi	r4,1
 8210068:	000b883a 	mov	r5,zero
 821006c:	d811883a 	mov	r8,sp
 8210070:	003f0d06 	br	820fca8 <___vfiprintf_internal_r+0xc04>
 8210074:	d9402117 	ldw	r5,132(sp)
 8210078:	d9002017 	ldw	r4,128(sp)
 821007c:	d9801a04 	addi	r6,sp,104
 8210080:	820ef900 	call	820ef90 <__sprint_r.part.0>
 8210084:	103f5b1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 8210088:	d9001b17 	ldw	r4,108(sp)
 821008c:	d8801c17 	ldw	r2,112(sp)
 8210090:	d811883a 	mov	r8,sp
 8210094:	21000044 	addi	r4,r4,1
 8210098:	003d8006 	br	820f69c <___vfiprintf_internal_r+0x5f8>
 821009c:	01020974 	movhi	r4,2085
 82100a0:	21355a04 	addi	r4,r4,-10904
 82100a4:	d9002615 	stw	r4,152(sp)
 82100a8:	d8c02215 	stw	r3,136(sp)
 82100ac:	1029883a 	mov	r20,r2
 82100b0:	94c4b03a 	or	r2,r18,r19
 82100b4:	103fb21e 	bne	r2,zero,820ff80 <___vfiprintf_internal_r+0xedc>
 82100b8:	0039883a 	mov	fp,zero
 82100bc:	00800084 	movi	r2,2
 82100c0:	003e6b06 	br	820fa70 <___vfiprintf_internal_r+0x9cc>
 82100c4:	da802217 	ldw	r10,136(sp)
 82100c8:	d8001d85 	stb	zero,118(sp)
 82100cc:	0027883a 	mov	r19,zero
 82100d0:	50800104 	addi	r2,r10,4
 82100d4:	54800017 	ldw	r18,0(r10)
 82100d8:	483e6016 	blt	r9,zero,820fa5c <___vfiprintf_internal_r+0x9b8>
 82100dc:	00ffdfc4 	movi	r3,-129
 82100e0:	d8802215 	stw	r2,136(sp)
 82100e4:	a0e8703a 	and	r20,r20,r3
 82100e8:	0039883a 	mov	fp,zero
 82100ec:	903ebb26 	beq	r18,zero,820fbdc <___vfiprintf_internal_r+0xb38>
 82100f0:	00800244 	movi	r2,9
 82100f4:	14bdee36 	bltu	r2,r18,820f8b0 <___vfiprintf_internal_r+0x80c>
 82100f8:	003eba06 	br	820fbe4 <___vfiprintf_internal_r+0xb40>
 82100fc:	00800c04 	movi	r2,48
 8210100:	d8c01d45 	stb	r3,117(sp)
 8210104:	d8801d05 	stb	r2,116(sp)
 8210108:	d8001d85 	stb	zero,118(sp)
 821010c:	a0c00094 	ori	r3,r20,2
 8210110:	4800a916 	blt	r9,zero,82103b8 <___vfiprintf_internal_r+0x1314>
 8210114:	00bfdfc4 	movi	r2,-129
 8210118:	a096703a 	and	r11,r20,r2
 821011c:	5d000094 	ori	r20,r11,2
 8210120:	0039883a 	mov	fp,zero
 8210124:	003f9706 	br	820ff84 <___vfiprintf_internal_r+0xee0>
 8210128:	8025883a 	mov	r18,r16
 821012c:	003c2e06 	br	820f1e8 <___vfiprintf_internal_r+0x144>
 8210130:	00820974 	movhi	r2,2085
 8210134:	10b55a04 	addi	r2,r2,-10904
 8210138:	0039883a 	mov	fp,zero
 821013c:	d8802615 	stw	r2,152(sp)
 8210140:	003f9006 	br	820ff84 <___vfiprintf_internal_r+0xee0>
 8210144:	04a5c83a 	sub	r18,zero,r18
 8210148:	07000b44 	movi	fp,45
 821014c:	9004c03a 	cmpne	r2,r18,zero
 8210150:	04e7c83a 	sub	r19,zero,r19
 8210154:	df001d85 	stb	fp,118(sp)
 8210158:	98a7c83a 	sub	r19,r19,r2
 821015c:	48009f16 	blt	r9,zero,82103dc <___vfiprintf_internal_r+0x1338>
 8210160:	00bfdfc4 	movi	r2,-129
 8210164:	a0a8703a 	and	r20,r20,r2
 8210168:	003dd006 	br	820f8ac <___vfiprintf_internal_r+0x808>
 821016c:	70004c26 	beq	r14,zero,82102a0 <___vfiprintf_internal_r+0x11fc>
 8210170:	00800084 	movi	r2,2
 8210174:	d8c01d04 	addi	r3,sp,116
 8210178:	d8c00015 	stw	r3,0(sp)
 821017c:	d8800115 	stw	r2,4(sp)
 8210180:	01000044 	movi	r4,1
 8210184:	d811883a 	mov	r8,sp
 8210188:	003f7306 	br	820ff58 <___vfiprintf_internal_r+0xeb4>
 821018c:	a080100c 	andi	r2,r20,64
 8210190:	da802217 	ldw	r10,136(sp)
 8210194:	103e0626 	beq	r2,zero,820f9b0 <___vfiprintf_internal_r+0x90c>
 8210198:	5480000f 	ldh	r18,0(r10)
 821019c:	52800104 	addi	r10,r10,4
 82101a0:	da802215 	stw	r10,136(sp)
 82101a4:	9027d7fa 	srai	r19,r18,31
 82101a8:	9805883a 	mov	r2,r19
 82101ac:	003db806 	br	820f890 <___vfiprintf_internal_r+0x7ec>
 82101b0:	a080040c 	andi	r2,r20,16
 82101b4:	1000091e 	bne	r2,zero,82101dc <___vfiprintf_internal_r+0x1138>
 82101b8:	a2c0100c 	andi	r11,r20,64
 82101bc:	58000726 	beq	r11,zero,82101dc <___vfiprintf_internal_r+0x1138>
 82101c0:	da802217 	ldw	r10,136(sp)
 82101c4:	50800017 	ldw	r2,0(r10)
 82101c8:	52800104 	addi	r10,r10,4
 82101cc:	da802215 	stw	r10,136(sp)
 82101d0:	da802317 	ldw	r10,140(sp)
 82101d4:	1280000d 	sth	r10,0(r2)
 82101d8:	003be706 	br	820f178 <___vfiprintf_internal_r+0xd4>
 82101dc:	da802217 	ldw	r10,136(sp)
 82101e0:	50800017 	ldw	r2,0(r10)
 82101e4:	52800104 	addi	r10,r10,4
 82101e8:	da802215 	stw	r10,136(sp)
 82101ec:	da802317 	ldw	r10,140(sp)
 82101f0:	12800015 	stw	r10,0(r2)
 82101f4:	003be006 	br	820f178 <___vfiprintf_internal_r+0xd4>
 82101f8:	a080100c 	andi	r2,r20,64
 82101fc:	da802217 	ldw	r10,136(sp)
 8210200:	10003026 	beq	r2,zero,82102c4 <___vfiprintf_internal_r+0x1220>
 8210204:	5480000b 	ldhu	r18,0(r10)
 8210208:	52800104 	addi	r10,r10,4
 821020c:	0027883a 	mov	r19,zero
 8210210:	da802215 	stw	r10,136(sp)
 8210214:	003d8006 	br	820f818 <___vfiprintf_internal_r+0x774>
 8210218:	80c00007 	ldb	r3,0(r16)
 821021c:	003c0006 	br	820f220 <___vfiprintf_internal_r+0x17c>
 8210220:	a080100c 	andi	r2,r20,64
 8210224:	d8001d85 	stb	zero,118(sp)
 8210228:	da802217 	ldw	r10,136(sp)
 821022c:	1000201e 	bne	r2,zero,82102b0 <___vfiprintf_internal_r+0x120c>
 8210230:	50800104 	addi	r2,r10,4
 8210234:	54800017 	ldw	r18,0(r10)
 8210238:	0027883a 	mov	r19,zero
 821023c:	483def0e 	bge	r9,zero,820f9fc <___vfiprintf_internal_r+0x958>
 8210240:	94c6b03a 	or	r3,r18,r19
 8210244:	d8802215 	stw	r2,136(sp)
 8210248:	183d4e1e 	bne	r3,zero,820f784 <___vfiprintf_internal_r+0x6e0>
 821024c:	0039883a 	mov	fp,zero
 8210250:	0005883a 	mov	r2,zero
 8210254:	003e0606 	br	820fa70 <___vfiprintf_internal_r+0x9cc>
 8210258:	d9402117 	ldw	r5,132(sp)
 821025c:	d9002017 	ldw	r4,128(sp)
 8210260:	d9801a04 	addi	r6,sp,104
 8210264:	da402c15 	stw	r9,176(sp)
 8210268:	db802a15 	stw	r14,168(sp)
 821026c:	820ef900 	call	820ef90 <__sprint_r.part.0>
 8210270:	da402c17 	ldw	r9,176(sp)
 8210274:	db802a17 	ldw	r14,168(sp)
 8210278:	103ede1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 821027c:	d9401b17 	ldw	r5,108(sp)
 8210280:	d8801c17 	ldw	r2,112(sp)
 8210284:	d811883a 	mov	r8,sp
 8210288:	29000044 	addi	r4,r5,1
 821028c:	003e7406 	br	820fc60 <___vfiprintf_internal_r+0xbbc>
 8210290:	00bfffc4 	movi	r2,-1
 8210294:	003c5806 	br	820f3f8 <___vfiprintf_internal_r+0x354>
 8210298:	d811883a 	mov	r8,sp
 821029c:	003ee806 	br	820fe40 <___vfiprintf_internal_r+0xd9c>
 82102a0:	000b883a 	mov	r5,zero
 82102a4:	01000044 	movi	r4,1
 82102a8:	d811883a 	mov	r8,sp
 82102ac:	003e7c06 	br	820fca0 <___vfiprintf_internal_r+0xbfc>
 82102b0:	50800104 	addi	r2,r10,4
 82102b4:	5480000b 	ldhu	r18,0(r10)
 82102b8:	0027883a 	mov	r19,zero
 82102bc:	483dcf0e 	bge	r9,zero,820f9fc <___vfiprintf_internal_r+0x958>
 82102c0:	003fdf06 	br	8210240 <___vfiprintf_internal_r+0x119c>
 82102c4:	54800017 	ldw	r18,0(r10)
 82102c8:	52800104 	addi	r10,r10,4
 82102cc:	0027883a 	mov	r19,zero
 82102d0:	da802215 	stw	r10,136(sp)
 82102d4:	003d5006 	br	820f818 <___vfiprintf_internal_r+0x774>
 82102d8:	50800104 	addi	r2,r10,4
 82102dc:	5480000b 	ldhu	r18,0(r10)
 82102e0:	0027883a 	mov	r19,zero
 82102e4:	483f7d0e 	bge	r9,zero,82100dc <___vfiprintf_internal_r+0x1038>
 82102e8:	003ddc06 	br	820fa5c <___vfiprintf_internal_r+0x9b8>
 82102ec:	d8c02215 	stw	r3,136(sp)
 82102f0:	0039883a 	mov	fp,zero
 82102f4:	003ddb06 	br	820fa64 <___vfiprintf_internal_r+0x9c0>
 82102f8:	02820974 	movhi	r10,2085
 82102fc:	52b5ca04 	addi	r10,r10,-10456
 8210300:	da802415 	stw	r10,144(sp)
 8210304:	003e8306 	br	820fd14 <___vfiprintf_internal_r+0xc70>
 8210308:	d8801c17 	ldw	r2,112(sp)
 821030c:	dd002117 	ldw	r20,132(sp)
 8210310:	103eb926 	beq	r2,zero,820fdf8 <___vfiprintf_internal_r+0xd54>
 8210314:	d9002017 	ldw	r4,128(sp)
 8210318:	d9801a04 	addi	r6,sp,104
 821031c:	a00b883a 	mov	r5,r20
 8210320:	820ef900 	call	820ef90 <__sprint_r.part.0>
 8210324:	003eb406 	br	820fdf8 <___vfiprintf_internal_r+0xd54>
 8210328:	80c00043 	ldbu	r3,1(r16)
 821032c:	a5000814 	ori	r20,r20,32
 8210330:	84000044 	addi	r16,r16,1
 8210334:	18c03fcc 	andi	r3,r3,255
 8210338:	18c0201c 	xori	r3,r3,128
 821033c:	18ffe004 	addi	r3,r3,-128
 8210340:	003bb706 	br	820f220 <___vfiprintf_internal_r+0x17c>
 8210344:	a809883a 	mov	r4,r21
 8210348:	d8c02a15 	stw	r3,168(sp)
 821034c:	da002b15 	stw	r8,172(sp)
 8210350:	8203a5c0 	call	8203a5c <strlen>
 8210354:	d8c02a17 	ldw	r3,168(sp)
 8210358:	1027883a 	mov	r19,r2
 821035c:	df001d83 	ldbu	fp,118(sp)
 8210360:	d8c02215 	stw	r3,136(sp)
 8210364:	0013883a 	mov	r9,zero
 8210368:	da002b17 	ldw	r8,172(sp)
 821036c:	003c4d06 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 8210370:	d9402117 	ldw	r5,132(sp)
 8210374:	d9002017 	ldw	r4,128(sp)
 8210378:	d9801a04 	addi	r6,sp,104
 821037c:	da402c15 	stw	r9,176(sp)
 8210380:	820ef900 	call	820ef90 <__sprint_r.part.0>
 8210384:	da402c17 	ldw	r9,176(sp)
 8210388:	103e9a1e 	bne	r2,zero,820fdf4 <___vfiprintf_internal_r+0xd50>
 821038c:	d9401b17 	ldw	r5,108(sp)
 8210390:	d8801c17 	ldw	r2,112(sp)
 8210394:	d811883a 	mov	r8,sp
 8210398:	29000044 	addi	r4,r5,1
 821039c:	003e4206 	br	820fca8 <___vfiprintf_internal_r+0xc04>
 82103a0:	d9401b17 	ldw	r5,108(sp)
 82103a4:	01020974 	movhi	r4,2085
 82103a8:	2135ce04 	addi	r4,r4,-10440
 82103ac:	d9002415 	stw	r4,144(sp)
 82103b0:	29400044 	addi	r5,r5,1
 82103b4:	003c6d06 	br	820f56c <___vfiprintf_internal_r+0x4c8>
 82103b8:	0039883a 	mov	fp,zero
 82103bc:	00800084 	movi	r2,2
 82103c0:	10803fcc 	andi	r2,r2,255
 82103c4:	01000044 	movi	r4,1
 82103c8:	11001e26 	beq	r2,r4,8210444 <___vfiprintf_internal_r+0x13a0>
 82103cc:	01000084 	movi	r4,2
 82103d0:	11001e1e 	bne	r2,r4,821044c <___vfiprintf_internal_r+0x13a8>
 82103d4:	1829883a 	mov	r20,r3
 82103d8:	003eea06 	br	820ff84 <___vfiprintf_internal_r+0xee0>
 82103dc:	a007883a 	mov	r3,r20
 82103e0:	00800044 	movi	r2,1
 82103e4:	003ff606 	br	82103c0 <___vfiprintf_internal_r+0x131c>
 82103e8:	00800184 	movi	r2,6
 82103ec:	1240012e 	bgeu	r2,r9,82103f4 <___vfiprintf_internal_r+0x1350>
 82103f0:	1013883a 	mov	r9,r2
 82103f4:	4827883a 	mov	r19,r9
 82103f8:	4825883a 	mov	r18,r9
 82103fc:	48001516 	blt	r9,zero,8210454 <___vfiprintf_internal_r+0x13b0>
 8210400:	05420974 	movhi	r21,2085
 8210404:	d8c02215 	stw	r3,136(sp)
 8210408:	ad755f04 	addi	r21,r21,-10884
 821040c:	003d1406 	br	820f860 <___vfiprintf_internal_r+0x7bc>
 8210410:	02820974 	movhi	r10,2085
 8210414:	52b5ca04 	addi	r10,r10,-10456
 8210418:	da802415 	stw	r10,144(sp)
 821041c:	200d883a 	mov	r6,r4
 8210420:	003c9106 	br	820f668 <___vfiprintf_internal_r+0x5c4>
 8210424:	5021883a 	mov	r16,r10
 8210428:	0013883a 	mov	r9,zero
 821042c:	003b7d06 	br	820f224 <___vfiprintf_internal_r+0x180>
 8210430:	4827883a 	mov	r19,r9
 8210434:	df001d83 	ldbu	fp,118(sp)
 8210438:	d8c02215 	stw	r3,136(sp)
 821043c:	0013883a 	mov	r9,zero
 8210440:	003c1806 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 8210444:	1829883a 	mov	r20,r3
 8210448:	003d1806 	br	820f8ac <___vfiprintf_internal_r+0x808>
 821044c:	1829883a 	mov	r20,r3
 8210450:	003ccd06 	br	820f788 <___vfiprintf_internal_r+0x6e4>
 8210454:	0025883a 	mov	r18,zero
 8210458:	003fe906 	br	8210400 <___vfiprintf_internal_r+0x135c>
 821045c:	d8802217 	ldw	r2,136(sp)
 8210460:	80c00043 	ldbu	r3,1(r16)
 8210464:	5021883a 	mov	r16,r10
 8210468:	12400017 	ldw	r9,0(r2)
 821046c:	10800104 	addi	r2,r2,4
 8210470:	d8802215 	stw	r2,136(sp)
 8210474:	483faf0e 	bge	r9,zero,8210334 <___vfiprintf_internal_r+0x1290>
 8210478:	18c03fcc 	andi	r3,r3,255
 821047c:	18c0201c 	xori	r3,r3,128
 8210480:	027fffc4 	movi	r9,-1
 8210484:	18ffe004 	addi	r3,r3,-128
 8210488:	003b6506 	br	820f220 <___vfiprintf_internal_r+0x17c>
 821048c:	d9c01d85 	stb	r7,118(sp)
 8210490:	003ca006 	br	820f714 <___vfiprintf_internal_r+0x670>
 8210494:	d9c01d85 	stb	r7,118(sp)
 8210498:	003cad06 	br	820f750 <___vfiprintf_internal_r+0x6ac>
 821049c:	d9c01d85 	stb	r7,118(sp)
 82104a0:	003d7d06 	br	820fa98 <___vfiprintf_internal_r+0x9f4>
 82104a4:	d9c01d85 	stb	r7,118(sp)
 82104a8:	003d5f06 	br	820fa28 <___vfiprintf_internal_r+0x984>
 82104ac:	a080004c 	andi	r2,r20,1
 82104b0:	0039883a 	mov	fp,zero
 82104b4:	10000526 	beq	r2,zero,82104cc <___vfiprintf_internal_r+0x1428>
 82104b8:	00800c04 	movi	r2,48
 82104bc:	d88019c5 	stb	r2,103(sp)
 82104c0:	dcc02717 	ldw	r19,156(sp)
 82104c4:	dd4019c4 	addi	r21,sp,103
 82104c8:	003bf606 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 82104cc:	0027883a 	mov	r19,zero
 82104d0:	dd401a04 	addi	r21,sp,104
 82104d4:	003bf306 	br	820f4a4 <___vfiprintf_internal_r+0x400>
 82104d8:	d9c01d85 	stb	r7,118(sp)
 82104dc:	003dc806 	br	820fc00 <___vfiprintf_internal_r+0xb5c>
 82104e0:	d9c01d85 	stb	r7,118(sp)
 82104e4:	003d3a06 	br	820f9d0 <___vfiprintf_internal_r+0x92c>
 82104e8:	d9c01d85 	stb	r7,118(sp)
 82104ec:	003d2a06 	br	820f998 <___vfiprintf_internal_r+0x8f4>
 82104f0:	d9c01d85 	stb	r7,118(sp)
 82104f4:	003cde06 	br	820f870 <___vfiprintf_internal_r+0x7cc>
 82104f8:	d9c01d85 	stb	r7,118(sp)
 82104fc:	003cbc06 	br	820f7f0 <___vfiprintf_internal_r+0x74c>

08210500 <__vfiprintf_internal>:
 8210500:	00820974 	movhi	r2,2085
 8210504:	108e3004 	addi	r2,r2,14528
 8210508:	300f883a 	mov	r7,r6
 821050c:	280d883a 	mov	r6,r5
 8210510:	200b883a 	mov	r5,r4
 8210514:	11000017 	ldw	r4,0(r2)
 8210518:	820f0a41 	jmpi	820f0a4 <___vfiprintf_internal_r>

0821051c <__sbprintf>:
 821051c:	2880030b 	ldhu	r2,12(r5)
 8210520:	2ac01917 	ldw	r11,100(r5)
 8210524:	2a80038b 	ldhu	r10,14(r5)
 8210528:	2a400717 	ldw	r9,28(r5)
 821052c:	2a000917 	ldw	r8,36(r5)
 8210530:	defee204 	addi	sp,sp,-1144
 8210534:	00c10004 	movi	r3,1024
 8210538:	dc011a15 	stw	r16,1128(sp)
 821053c:	10bfff4c 	andi	r2,r2,65533
 8210540:	2821883a 	mov	r16,r5
 8210544:	d8cb883a 	add	r5,sp,r3
 8210548:	dc811c15 	stw	r18,1136(sp)
 821054c:	dc411b15 	stw	r17,1132(sp)
 8210550:	dfc11d15 	stw	ra,1140(sp)
 8210554:	2025883a 	mov	r18,r4
 8210558:	d881030d 	sth	r2,1036(sp)
 821055c:	dac11915 	stw	r11,1124(sp)
 8210560:	da81038d 	sth	r10,1038(sp)
 8210564:	da410715 	stw	r9,1052(sp)
 8210568:	da010915 	stw	r8,1060(sp)
 821056c:	dec10015 	stw	sp,1024(sp)
 8210570:	dec10415 	stw	sp,1040(sp)
 8210574:	d8c10215 	stw	r3,1032(sp)
 8210578:	d8c10515 	stw	r3,1044(sp)
 821057c:	d8010615 	stw	zero,1048(sp)
 8210580:	820f0a40 	call	820f0a4 <___vfiprintf_internal_r>
 8210584:	1023883a 	mov	r17,r2
 8210588:	10000416 	blt	r2,zero,821059c <__sbprintf+0x80>
 821058c:	d9410004 	addi	r5,sp,1024
 8210590:	9009883a 	mov	r4,r18
 8210594:	820a5580 	call	820a558 <_fflush_r>
 8210598:	10000d1e 	bne	r2,zero,82105d0 <__sbprintf+0xb4>
 821059c:	d881030b 	ldhu	r2,1036(sp)
 82105a0:	1080100c 	andi	r2,r2,64
 82105a4:	10000326 	beq	r2,zero,82105b4 <__sbprintf+0x98>
 82105a8:	8080030b 	ldhu	r2,12(r16)
 82105ac:	10801014 	ori	r2,r2,64
 82105b0:	8080030d 	sth	r2,12(r16)
 82105b4:	8805883a 	mov	r2,r17
 82105b8:	dfc11d17 	ldw	ra,1140(sp)
 82105bc:	dc811c17 	ldw	r18,1136(sp)
 82105c0:	dc411b17 	ldw	r17,1132(sp)
 82105c4:	dc011a17 	ldw	r16,1128(sp)
 82105c8:	dec11e04 	addi	sp,sp,1144
 82105cc:	f800283a 	ret
 82105d0:	047fffc4 	movi	r17,-1
 82105d4:	003ff106 	br	821059c <__sbprintf+0x80>

082105d8 <_write_r>:
 82105d8:	defffd04 	addi	sp,sp,-12
 82105dc:	2805883a 	mov	r2,r5
 82105e0:	dc000015 	stw	r16,0(sp)
 82105e4:	04020974 	movhi	r16,2085
 82105e8:	dc400115 	stw	r17,4(sp)
 82105ec:	300b883a 	mov	r5,r6
 82105f0:	840e9104 	addi	r16,r16,14916
 82105f4:	2023883a 	mov	r17,r4
 82105f8:	380d883a 	mov	r6,r7
 82105fc:	1009883a 	mov	r4,r2
 8210600:	dfc00215 	stw	ra,8(sp)
 8210604:	80000015 	stw	zero,0(r16)
 8210608:	822566c0 	call	822566c <write>
 821060c:	00ffffc4 	movi	r3,-1
 8210610:	10c00526 	beq	r2,r3,8210628 <_write_r+0x50>
 8210614:	dfc00217 	ldw	ra,8(sp)
 8210618:	dc400117 	ldw	r17,4(sp)
 821061c:	dc000017 	ldw	r16,0(sp)
 8210620:	dec00304 	addi	sp,sp,12
 8210624:	f800283a 	ret
 8210628:	80c00017 	ldw	r3,0(r16)
 821062c:	183ff926 	beq	r3,zero,8210614 <_write_r+0x3c>
 8210630:	88c00015 	stw	r3,0(r17)
 8210634:	003ff706 	br	8210614 <_write_r+0x3c>

08210638 <_close_r>:
 8210638:	defffd04 	addi	sp,sp,-12
 821063c:	dc000015 	stw	r16,0(sp)
 8210640:	04020974 	movhi	r16,2085
 8210644:	dc400115 	stw	r17,4(sp)
 8210648:	840e9104 	addi	r16,r16,14916
 821064c:	2023883a 	mov	r17,r4
 8210650:	2809883a 	mov	r4,r5
 8210654:	dfc00215 	stw	ra,8(sp)
 8210658:	80000015 	stw	zero,0(r16)
 821065c:	822546c0 	call	822546c <close>
 8210660:	00ffffc4 	movi	r3,-1
 8210664:	10c00526 	beq	r2,r3,821067c <_close_r+0x44>
 8210668:	dfc00217 	ldw	ra,8(sp)
 821066c:	dc400117 	ldw	r17,4(sp)
 8210670:	dc000017 	ldw	r16,0(sp)
 8210674:	dec00304 	addi	sp,sp,12
 8210678:	f800283a 	ret
 821067c:	80c00017 	ldw	r3,0(r16)
 8210680:	183ff926 	beq	r3,zero,8210668 <_close_r+0x30>
 8210684:	88c00015 	stw	r3,0(r17)
 8210688:	003ff706 	br	8210668 <_close_r+0x30>

0821068c <_calloc_r>:
 821068c:	298b383a 	mul	r5,r5,r6
 8210690:	defffe04 	addi	sp,sp,-8
 8210694:	dfc00115 	stw	ra,4(sp)
 8210698:	dc000015 	stw	r16,0(sp)
 821069c:	820b7e80 	call	820b7e8 <_malloc_r>
 82106a0:	10002926 	beq	r2,zero,8210748 <_calloc_r+0xbc>
 82106a4:	11bfff17 	ldw	r6,-4(r2)
 82106a8:	1021883a 	mov	r16,r2
 82106ac:	00bfff04 	movi	r2,-4
 82106b0:	308c703a 	and	r6,r6,r2
 82106b4:	00c00904 	movi	r3,36
 82106b8:	308d883a 	add	r6,r6,r2
 82106bc:	19801636 	bltu	r3,r6,8210718 <_calloc_r+0x8c>
 82106c0:	008004c4 	movi	r2,19
 82106c4:	11800b2e 	bgeu	r2,r6,82106f4 <_calloc_r+0x68>
 82106c8:	80000015 	stw	zero,0(r16)
 82106cc:	80000115 	stw	zero,4(r16)
 82106d0:	008006c4 	movi	r2,27
 82106d4:	11801a2e 	bgeu	r2,r6,8210740 <_calloc_r+0xb4>
 82106d8:	80000215 	stw	zero,8(r16)
 82106dc:	80000315 	stw	zero,12(r16)
 82106e0:	30c0151e 	bne	r6,r3,8210738 <_calloc_r+0xac>
 82106e4:	80000415 	stw	zero,16(r16)
 82106e8:	80800604 	addi	r2,r16,24
 82106ec:	80000515 	stw	zero,20(r16)
 82106f0:	00000106 	br	82106f8 <_calloc_r+0x6c>
 82106f4:	8005883a 	mov	r2,r16
 82106f8:	10000015 	stw	zero,0(r2)
 82106fc:	10000115 	stw	zero,4(r2)
 8210700:	10000215 	stw	zero,8(r2)
 8210704:	8005883a 	mov	r2,r16
 8210708:	dfc00117 	ldw	ra,4(sp)
 821070c:	dc000017 	ldw	r16,0(sp)
 8210710:	dec00204 	addi	sp,sp,8
 8210714:	f800283a 	ret
 8210718:	000b883a 	mov	r5,zero
 821071c:	8009883a 	mov	r4,r16
 8210720:	8202cb00 	call	8202cb0 <memset>
 8210724:	8005883a 	mov	r2,r16
 8210728:	dfc00117 	ldw	ra,4(sp)
 821072c:	dc000017 	ldw	r16,0(sp)
 8210730:	dec00204 	addi	sp,sp,8
 8210734:	f800283a 	ret
 8210738:	80800404 	addi	r2,r16,16
 821073c:	003fee06 	br	82106f8 <_calloc_r+0x6c>
 8210740:	80800204 	addi	r2,r16,8
 8210744:	003fec06 	br	82106f8 <_calloc_r+0x6c>
 8210748:	0005883a 	mov	r2,zero
 821074c:	003fee06 	br	8210708 <_calloc_r+0x7c>

08210750 <_fclose_r>:
 8210750:	28003926 	beq	r5,zero,8210838 <_fclose_r+0xe8>
 8210754:	defffc04 	addi	sp,sp,-16
 8210758:	dc400115 	stw	r17,4(sp)
 821075c:	dc000015 	stw	r16,0(sp)
 8210760:	dfc00315 	stw	ra,12(sp)
 8210764:	dc800215 	stw	r18,8(sp)
 8210768:	2023883a 	mov	r17,r4
 821076c:	2821883a 	mov	r16,r5
 8210770:	20000226 	beq	r4,zero,821077c <_fclose_r+0x2c>
 8210774:	20800e17 	ldw	r2,56(r4)
 8210778:	10002726 	beq	r2,zero,8210818 <_fclose_r+0xc8>
 821077c:	8080030f 	ldh	r2,12(r16)
 8210780:	1000071e 	bne	r2,zero,82107a0 <_fclose_r+0x50>
 8210784:	0005883a 	mov	r2,zero
 8210788:	dfc00317 	ldw	ra,12(sp)
 821078c:	dc800217 	ldw	r18,8(sp)
 8210790:	dc400117 	ldw	r17,4(sp)
 8210794:	dc000017 	ldw	r16,0(sp)
 8210798:	dec00404 	addi	sp,sp,16
 821079c:	f800283a 	ret
 82107a0:	800b883a 	mov	r5,r16
 82107a4:	8809883a 	mov	r4,r17
 82107a8:	820a33c0 	call	820a33c <__sflush_r>
 82107ac:	1025883a 	mov	r18,r2
 82107b0:	80800b17 	ldw	r2,44(r16)
 82107b4:	10000426 	beq	r2,zero,82107c8 <_fclose_r+0x78>
 82107b8:	81400717 	ldw	r5,28(r16)
 82107bc:	8809883a 	mov	r4,r17
 82107c0:	103ee83a 	callr	r2
 82107c4:	10001616 	blt	r2,zero,8210820 <_fclose_r+0xd0>
 82107c8:	8080030b 	ldhu	r2,12(r16)
 82107cc:	1080200c 	andi	r2,r2,128
 82107d0:	1000151e 	bne	r2,zero,8210828 <_fclose_r+0xd8>
 82107d4:	81400c17 	ldw	r5,48(r16)
 82107d8:	28000526 	beq	r5,zero,82107f0 <_fclose_r+0xa0>
 82107dc:	80801004 	addi	r2,r16,64
 82107e0:	28800226 	beq	r5,r2,82107ec <_fclose_r+0x9c>
 82107e4:	8809883a 	mov	r4,r17
 82107e8:	820abfc0 	call	820abfc <_free_r>
 82107ec:	80000c15 	stw	zero,48(r16)
 82107f0:	81401117 	ldw	r5,68(r16)
 82107f4:	28000326 	beq	r5,zero,8210804 <_fclose_r+0xb4>
 82107f8:	8809883a 	mov	r4,r17
 82107fc:	820abfc0 	call	820abfc <_free_r>
 8210800:	80001115 	stw	zero,68(r16)
 8210804:	820a9440 	call	820a944 <__sfp_lock_acquire>
 8210808:	8000030d 	sth	zero,12(r16)
 821080c:	820a9480 	call	820a948 <__sfp_lock_release>
 8210810:	9005883a 	mov	r2,r18
 8210814:	003fdc06 	br	8210788 <_fclose_r+0x38>
 8210818:	820a9340 	call	820a934 <__sinit>
 821081c:	003fd706 	br	821077c <_fclose_r+0x2c>
 8210820:	04bfffc4 	movi	r18,-1
 8210824:	003fe806 	br	82107c8 <_fclose_r+0x78>
 8210828:	81400417 	ldw	r5,16(r16)
 821082c:	8809883a 	mov	r4,r17
 8210830:	820abfc0 	call	820abfc <_free_r>
 8210834:	003fe706 	br	82107d4 <_fclose_r+0x84>
 8210838:	0005883a 	mov	r2,zero
 821083c:	f800283a 	ret

08210840 <fclose>:
 8210840:	00820974 	movhi	r2,2085
 8210844:	108e3004 	addi	r2,r2,14528
 8210848:	200b883a 	mov	r5,r4
 821084c:	11000017 	ldw	r4,0(r2)
 8210850:	82107501 	jmpi	8210750 <_fclose_r>

08210854 <__fputwc>:
 8210854:	defff804 	addi	sp,sp,-32
 8210858:	dcc00415 	stw	r19,16(sp)
 821085c:	dc800315 	stw	r18,12(sp)
 8210860:	dc000115 	stw	r16,4(sp)
 8210864:	dfc00715 	stw	ra,28(sp)
 8210868:	dd400615 	stw	r21,24(sp)
 821086c:	dd000515 	stw	r20,20(sp)
 8210870:	dc400215 	stw	r17,8(sp)
 8210874:	2027883a 	mov	r19,r4
 8210878:	2825883a 	mov	r18,r5
 821087c:	3021883a 	mov	r16,r6
 8210880:	820b5d80 	call	820b5d8 <__locale_mb_cur_max>
 8210884:	00c00044 	movi	r3,1
 8210888:	10c03e26 	beq	r2,r3,8210984 <__fputwc+0x130>
 821088c:	81c01704 	addi	r7,r16,92
 8210890:	900d883a 	mov	r6,r18
 8210894:	d80b883a 	mov	r5,sp
 8210898:	9809883a 	mov	r4,r19
 821089c:	8210bcc0 	call	8210bcc <_wcrtomb_r>
 82108a0:	1029883a 	mov	r20,r2
 82108a4:	00bfffc4 	movi	r2,-1
 82108a8:	a0802026 	beq	r20,r2,821092c <__fputwc+0xd8>
 82108ac:	d9400003 	ldbu	r5,0(sp)
 82108b0:	a0001c26 	beq	r20,zero,8210924 <__fputwc+0xd0>
 82108b4:	0023883a 	mov	r17,zero
 82108b8:	05400284 	movi	r21,10
 82108bc:	00000906 	br	82108e4 <__fputwc+0x90>
 82108c0:	80800017 	ldw	r2,0(r16)
 82108c4:	11400005 	stb	r5,0(r2)
 82108c8:	80c00017 	ldw	r3,0(r16)
 82108cc:	18c00044 	addi	r3,r3,1
 82108d0:	80c00015 	stw	r3,0(r16)
 82108d4:	8c400044 	addi	r17,r17,1
 82108d8:	dc45883a 	add	r2,sp,r17
 82108dc:	8d00112e 	bgeu	r17,r20,8210924 <__fputwc+0xd0>
 82108e0:	11400003 	ldbu	r5,0(r2)
 82108e4:	80c00217 	ldw	r3,8(r16)
 82108e8:	18ffffc4 	addi	r3,r3,-1
 82108ec:	80c00215 	stw	r3,8(r16)
 82108f0:	183ff30e 	bge	r3,zero,82108c0 <__fputwc+0x6c>
 82108f4:	80800617 	ldw	r2,24(r16)
 82108f8:	18801916 	blt	r3,r2,8210960 <__fputwc+0x10c>
 82108fc:	80800017 	ldw	r2,0(r16)
 8210900:	11400005 	stb	r5,0(r2)
 8210904:	80800017 	ldw	r2,0(r16)
 8210908:	10c00003 	ldbu	r3,0(r2)
 821090c:	10800044 	addi	r2,r2,1
 8210910:	1d402326 	beq	r3,r21,82109a0 <__fputwc+0x14c>
 8210914:	80800015 	stw	r2,0(r16)
 8210918:	8c400044 	addi	r17,r17,1
 821091c:	dc45883a 	add	r2,sp,r17
 8210920:	8d3fef36 	bltu	r17,r20,82108e0 <__fputwc+0x8c>
 8210924:	9005883a 	mov	r2,r18
 8210928:	00000406 	br	821093c <__fputwc+0xe8>
 821092c:	80c0030b 	ldhu	r3,12(r16)
 8210930:	a005883a 	mov	r2,r20
 8210934:	18c01014 	ori	r3,r3,64
 8210938:	80c0030d 	sth	r3,12(r16)
 821093c:	dfc00717 	ldw	ra,28(sp)
 8210940:	dd400617 	ldw	r21,24(sp)
 8210944:	dd000517 	ldw	r20,20(sp)
 8210948:	dcc00417 	ldw	r19,16(sp)
 821094c:	dc800317 	ldw	r18,12(sp)
 8210950:	dc400217 	ldw	r17,8(sp)
 8210954:	dc000117 	ldw	r16,4(sp)
 8210958:	dec00804 	addi	sp,sp,32
 821095c:	f800283a 	ret
 8210960:	800d883a 	mov	r6,r16
 8210964:	29403fcc 	andi	r5,r5,255
 8210968:	9809883a 	mov	r4,r19
 821096c:	82088080 	call	8208808 <__swbuf_r>
 8210970:	10bfffe0 	cmpeqi	r2,r2,-1
 8210974:	10803fcc 	andi	r2,r2,255
 8210978:	103fd626 	beq	r2,zero,82108d4 <__fputwc+0x80>
 821097c:	00bfffc4 	movi	r2,-1
 8210980:	003fee06 	br	821093c <__fputwc+0xe8>
 8210984:	90ffffc4 	addi	r3,r18,-1
 8210988:	01003f84 	movi	r4,254
 821098c:	20ffbf36 	bltu	r4,r3,821088c <__fputwc+0x38>
 8210990:	900b883a 	mov	r5,r18
 8210994:	dc800005 	stb	r18,0(sp)
 8210998:	1029883a 	mov	r20,r2
 821099c:	003fc506 	br	82108b4 <__fputwc+0x60>
 82109a0:	800d883a 	mov	r6,r16
 82109a4:	a80b883a 	mov	r5,r21
 82109a8:	9809883a 	mov	r4,r19
 82109ac:	82088080 	call	8208808 <__swbuf_r>
 82109b0:	10bfffe0 	cmpeqi	r2,r2,-1
 82109b4:	003fef06 	br	8210974 <__fputwc+0x120>

082109b8 <_fputwc_r>:
 82109b8:	3080030b 	ldhu	r2,12(r6)
 82109bc:	10c8000c 	andi	r3,r2,8192
 82109c0:	1800051e 	bne	r3,zero,82109d8 <_fputwc_r+0x20>
 82109c4:	30c01917 	ldw	r3,100(r6)
 82109c8:	10880014 	ori	r2,r2,8192
 82109cc:	3080030d 	sth	r2,12(r6)
 82109d0:	18880014 	ori	r2,r3,8192
 82109d4:	30801915 	stw	r2,100(r6)
 82109d8:	82108541 	jmpi	8210854 <__fputwc>

082109dc <fputwc>:
 82109dc:	00820974 	movhi	r2,2085
 82109e0:	defffc04 	addi	sp,sp,-16
 82109e4:	108e3004 	addi	r2,r2,14528
 82109e8:	dc000115 	stw	r16,4(sp)
 82109ec:	14000017 	ldw	r16,0(r2)
 82109f0:	dc400215 	stw	r17,8(sp)
 82109f4:	dfc00315 	stw	ra,12(sp)
 82109f8:	2023883a 	mov	r17,r4
 82109fc:	80000226 	beq	r16,zero,8210a08 <fputwc+0x2c>
 8210a00:	80800e17 	ldw	r2,56(r16)
 8210a04:	10001026 	beq	r2,zero,8210a48 <fputwc+0x6c>
 8210a08:	2880030b 	ldhu	r2,12(r5)
 8210a0c:	10c8000c 	andi	r3,r2,8192
 8210a10:	1800051e 	bne	r3,zero,8210a28 <fputwc+0x4c>
 8210a14:	28c01917 	ldw	r3,100(r5)
 8210a18:	10880014 	ori	r2,r2,8192
 8210a1c:	2880030d 	sth	r2,12(r5)
 8210a20:	18880014 	ori	r2,r3,8192
 8210a24:	28801915 	stw	r2,100(r5)
 8210a28:	280d883a 	mov	r6,r5
 8210a2c:	8009883a 	mov	r4,r16
 8210a30:	880b883a 	mov	r5,r17
 8210a34:	dfc00317 	ldw	ra,12(sp)
 8210a38:	dc400217 	ldw	r17,8(sp)
 8210a3c:	dc000117 	ldw	r16,4(sp)
 8210a40:	dec00404 	addi	sp,sp,16
 8210a44:	82108541 	jmpi	8210854 <__fputwc>
 8210a48:	8009883a 	mov	r4,r16
 8210a4c:	d9400015 	stw	r5,0(sp)
 8210a50:	820a9340 	call	820a934 <__sinit>
 8210a54:	d9400017 	ldw	r5,0(sp)
 8210a58:	003feb06 	br	8210a08 <fputwc+0x2c>

08210a5c <_fstat_r>:
 8210a5c:	defffd04 	addi	sp,sp,-12
 8210a60:	2805883a 	mov	r2,r5
 8210a64:	dc000015 	stw	r16,0(sp)
 8210a68:	04020974 	movhi	r16,2085
 8210a6c:	dc400115 	stw	r17,4(sp)
 8210a70:	840e9104 	addi	r16,r16,14916
 8210a74:	2023883a 	mov	r17,r4
 8210a78:	300b883a 	mov	r5,r6
 8210a7c:	1009883a 	mov	r4,r2
 8210a80:	dfc00215 	stw	ra,8(sp)
 8210a84:	80000015 	stw	zero,0(r16)
 8210a88:	8213fc40 	call	8213fc4 <fstat>
 8210a8c:	00ffffc4 	movi	r3,-1
 8210a90:	10c00526 	beq	r2,r3,8210aa8 <_fstat_r+0x4c>
 8210a94:	dfc00217 	ldw	ra,8(sp)
 8210a98:	dc400117 	ldw	r17,4(sp)
 8210a9c:	dc000017 	ldw	r16,0(sp)
 8210aa0:	dec00304 	addi	sp,sp,12
 8210aa4:	f800283a 	ret
 8210aa8:	80c00017 	ldw	r3,0(r16)
 8210aac:	183ff926 	beq	r3,zero,8210a94 <_fstat_r+0x38>
 8210ab0:	88c00015 	stw	r3,0(r17)
 8210ab4:	003ff706 	br	8210a94 <_fstat_r+0x38>

08210ab8 <_isatty_r>:
 8210ab8:	defffd04 	addi	sp,sp,-12
 8210abc:	dc000015 	stw	r16,0(sp)
 8210ac0:	04020974 	movhi	r16,2085
 8210ac4:	dc400115 	stw	r17,4(sp)
 8210ac8:	840e9104 	addi	r16,r16,14916
 8210acc:	2023883a 	mov	r17,r4
 8210ad0:	2809883a 	mov	r4,r5
 8210ad4:	dfc00215 	stw	ra,8(sp)
 8210ad8:	80000015 	stw	zero,0(r16)
 8210adc:	82140b00 	call	82140b0 <isatty>
 8210ae0:	00ffffc4 	movi	r3,-1
 8210ae4:	10c00526 	beq	r2,r3,8210afc <_isatty_r+0x44>
 8210ae8:	dfc00217 	ldw	ra,8(sp)
 8210aec:	dc400117 	ldw	r17,4(sp)
 8210af0:	dc000017 	ldw	r16,0(sp)
 8210af4:	dec00304 	addi	sp,sp,12
 8210af8:	f800283a 	ret
 8210afc:	80c00017 	ldw	r3,0(r16)
 8210b00:	183ff926 	beq	r3,zero,8210ae8 <_isatty_r+0x30>
 8210b04:	88c00015 	stw	r3,0(r17)
 8210b08:	003ff706 	br	8210ae8 <_isatty_r+0x30>

08210b0c <_lseek_r>:
 8210b0c:	defffd04 	addi	sp,sp,-12
 8210b10:	2805883a 	mov	r2,r5
 8210b14:	dc000015 	stw	r16,0(sp)
 8210b18:	04020974 	movhi	r16,2085
 8210b1c:	dc400115 	stw	r17,4(sp)
 8210b20:	300b883a 	mov	r5,r6
 8210b24:	840e9104 	addi	r16,r16,14916
 8210b28:	2023883a 	mov	r17,r4
 8210b2c:	380d883a 	mov	r6,r7
 8210b30:	1009883a 	mov	r4,r2
 8210b34:	dfc00215 	stw	ra,8(sp)
 8210b38:	80000015 	stw	zero,0(r16)
 8210b3c:	82141900 	call	8214190 <lseek>
 8210b40:	00ffffc4 	movi	r3,-1
 8210b44:	10c00526 	beq	r2,r3,8210b5c <_lseek_r+0x50>
 8210b48:	dfc00217 	ldw	ra,8(sp)
 8210b4c:	dc400117 	ldw	r17,4(sp)
 8210b50:	dc000017 	ldw	r16,0(sp)
 8210b54:	dec00304 	addi	sp,sp,12
 8210b58:	f800283a 	ret
 8210b5c:	80c00017 	ldw	r3,0(r16)
 8210b60:	183ff926 	beq	r3,zero,8210b48 <_lseek_r+0x3c>
 8210b64:	88c00015 	stw	r3,0(r17)
 8210b68:	003ff706 	br	8210b48 <_lseek_r+0x3c>

08210b6c <_read_r>:
 8210b6c:	defffd04 	addi	sp,sp,-12
 8210b70:	2805883a 	mov	r2,r5
 8210b74:	dc000015 	stw	r16,0(sp)
 8210b78:	04020974 	movhi	r16,2085
 8210b7c:	dc400115 	stw	r17,4(sp)
 8210b80:	300b883a 	mov	r5,r6
 8210b84:	840e9104 	addi	r16,r16,14916
 8210b88:	2023883a 	mov	r17,r4
 8210b8c:	380d883a 	mov	r6,r7
 8210b90:	1009883a 	mov	r4,r2
 8210b94:	dfc00215 	stw	ra,8(sp)
 8210b98:	80000015 	stw	zero,0(r16)
 8210b9c:	82255fc0 	call	82255fc <read>
 8210ba0:	00ffffc4 	movi	r3,-1
 8210ba4:	10c00526 	beq	r2,r3,8210bbc <_read_r+0x50>
 8210ba8:	dfc00217 	ldw	ra,8(sp)
 8210bac:	dc400117 	ldw	r17,4(sp)
 8210bb0:	dc000017 	ldw	r16,0(sp)
 8210bb4:	dec00304 	addi	sp,sp,12
 8210bb8:	f800283a 	ret
 8210bbc:	80c00017 	ldw	r3,0(r16)
 8210bc0:	183ff926 	beq	r3,zero,8210ba8 <_read_r+0x3c>
 8210bc4:	88c00015 	stw	r3,0(r17)
 8210bc8:	003ff706 	br	8210ba8 <_read_r+0x3c>

08210bcc <_wcrtomb_r>:
 8210bcc:	defff604 	addi	sp,sp,-40
 8210bd0:	00820974 	movhi	r2,2085
 8210bd4:	dc800815 	stw	r18,32(sp)
 8210bd8:	dc400715 	stw	r17,28(sp)
 8210bdc:	dc000615 	stw	r16,24(sp)
 8210be0:	108e3404 	addi	r2,r2,14544
 8210be4:	dfc00915 	stw	ra,36(sp)
 8210be8:	2021883a 	mov	r16,r4
 8210bec:	3823883a 	mov	r17,r7
 8210bf0:	14800017 	ldw	r18,0(r2)
 8210bf4:	28001426 	beq	r5,zero,8210c48 <_wcrtomb_r+0x7c>
 8210bf8:	d9400415 	stw	r5,16(sp)
 8210bfc:	d9800515 	stw	r6,20(sp)
 8210c00:	820b5cc0 	call	820b5cc <__locale_charset>
 8210c04:	d9800517 	ldw	r6,20(sp)
 8210c08:	d9400417 	ldw	r5,16(sp)
 8210c0c:	100f883a 	mov	r7,r2
 8210c10:	dc400015 	stw	r17,0(sp)
 8210c14:	8009883a 	mov	r4,r16
 8210c18:	903ee83a 	callr	r18
 8210c1c:	00ffffc4 	movi	r3,-1
 8210c20:	10c0031e 	bne	r2,r3,8210c30 <_wcrtomb_r+0x64>
 8210c24:	88000015 	stw	zero,0(r17)
 8210c28:	00c02284 	movi	r3,138
 8210c2c:	80c00015 	stw	r3,0(r16)
 8210c30:	dfc00917 	ldw	ra,36(sp)
 8210c34:	dc800817 	ldw	r18,32(sp)
 8210c38:	dc400717 	ldw	r17,28(sp)
 8210c3c:	dc000617 	ldw	r16,24(sp)
 8210c40:	dec00a04 	addi	sp,sp,40
 8210c44:	f800283a 	ret
 8210c48:	820b5cc0 	call	820b5cc <__locale_charset>
 8210c4c:	100f883a 	mov	r7,r2
 8210c50:	dc400015 	stw	r17,0(sp)
 8210c54:	000d883a 	mov	r6,zero
 8210c58:	d9400104 	addi	r5,sp,4
 8210c5c:	8009883a 	mov	r4,r16
 8210c60:	903ee83a 	callr	r18
 8210c64:	003fed06 	br	8210c1c <_wcrtomb_r+0x50>

08210c68 <wcrtomb>:
 8210c68:	defff604 	addi	sp,sp,-40
 8210c6c:	00820974 	movhi	r2,2085
 8210c70:	dc800615 	stw	r18,24(sp)
 8210c74:	dc400515 	stw	r17,20(sp)
 8210c78:	108e3004 	addi	r2,r2,14528
 8210c7c:	dfc00915 	stw	ra,36(sp)
 8210c80:	dd000815 	stw	r20,32(sp)
 8210c84:	dcc00715 	stw	r19,28(sp)
 8210c88:	dc000415 	stw	r16,16(sp)
 8210c8c:	3025883a 	mov	r18,r6
 8210c90:	14400017 	ldw	r17,0(r2)
 8210c94:	20001926 	beq	r4,zero,8210cfc <wcrtomb+0x94>
 8210c98:	00820974 	movhi	r2,2085
 8210c9c:	108e3404 	addi	r2,r2,14544
 8210ca0:	15000017 	ldw	r20,0(r2)
 8210ca4:	2021883a 	mov	r16,r4
 8210ca8:	2827883a 	mov	r19,r5
 8210cac:	820b5cc0 	call	820b5cc <__locale_charset>
 8210cb0:	100f883a 	mov	r7,r2
 8210cb4:	dc800015 	stw	r18,0(sp)
 8210cb8:	980d883a 	mov	r6,r19
 8210cbc:	800b883a 	mov	r5,r16
 8210cc0:	8809883a 	mov	r4,r17
 8210cc4:	a03ee83a 	callr	r20
 8210cc8:	00ffffc4 	movi	r3,-1
 8210ccc:	10c0031e 	bne	r2,r3,8210cdc <wcrtomb+0x74>
 8210cd0:	90000015 	stw	zero,0(r18)
 8210cd4:	00c02284 	movi	r3,138
 8210cd8:	88c00015 	stw	r3,0(r17)
 8210cdc:	dfc00917 	ldw	ra,36(sp)
 8210ce0:	dd000817 	ldw	r20,32(sp)
 8210ce4:	dcc00717 	ldw	r19,28(sp)
 8210ce8:	dc800617 	ldw	r18,24(sp)
 8210cec:	dc400517 	ldw	r17,20(sp)
 8210cf0:	dc000417 	ldw	r16,16(sp)
 8210cf4:	dec00a04 	addi	sp,sp,40
 8210cf8:	f800283a 	ret
 8210cfc:	00820974 	movhi	r2,2085
 8210d00:	108e3404 	addi	r2,r2,14544
 8210d04:	14000017 	ldw	r16,0(r2)
 8210d08:	820b5cc0 	call	820b5cc <__locale_charset>
 8210d0c:	100f883a 	mov	r7,r2
 8210d10:	dc800015 	stw	r18,0(sp)
 8210d14:	000d883a 	mov	r6,zero
 8210d18:	d9400104 	addi	r5,sp,4
 8210d1c:	8809883a 	mov	r4,r17
 8210d20:	803ee83a 	callr	r16
 8210d24:	003fe806 	br	8210cc8 <wcrtomb+0x60>

08210d28 <__ascii_wctomb>:
 8210d28:	28000526 	beq	r5,zero,8210d40 <__ascii_wctomb+0x18>
 8210d2c:	00803fc4 	movi	r2,255
 8210d30:	11800536 	bltu	r2,r6,8210d48 <__ascii_wctomb+0x20>
 8210d34:	29800005 	stb	r6,0(r5)
 8210d38:	00800044 	movi	r2,1
 8210d3c:	f800283a 	ret
 8210d40:	0005883a 	mov	r2,zero
 8210d44:	f800283a 	ret
 8210d48:	00802284 	movi	r2,138
 8210d4c:	20800015 	stw	r2,0(r4)
 8210d50:	00bfffc4 	movi	r2,-1
 8210d54:	f800283a 	ret

08210d58 <_wctomb_r>:
 8210d58:	00820974 	movhi	r2,2085
 8210d5c:	defff904 	addi	sp,sp,-28
 8210d60:	108e3404 	addi	r2,r2,14544
 8210d64:	dfc00615 	stw	ra,24(sp)
 8210d68:	dc400515 	stw	r17,20(sp)
 8210d6c:	dc000415 	stw	r16,16(sp)
 8210d70:	3823883a 	mov	r17,r7
 8210d74:	14000017 	ldw	r16,0(r2)
 8210d78:	d9000115 	stw	r4,4(sp)
 8210d7c:	d9400215 	stw	r5,8(sp)
 8210d80:	d9800315 	stw	r6,12(sp)
 8210d84:	820b5cc0 	call	820b5cc <__locale_charset>
 8210d88:	d9800317 	ldw	r6,12(sp)
 8210d8c:	d9400217 	ldw	r5,8(sp)
 8210d90:	d9000117 	ldw	r4,4(sp)
 8210d94:	100f883a 	mov	r7,r2
 8210d98:	dc400015 	stw	r17,0(sp)
 8210d9c:	803ee83a 	callr	r16
 8210da0:	dfc00617 	ldw	ra,24(sp)
 8210da4:	dc400517 	ldw	r17,20(sp)
 8210da8:	dc000417 	ldw	r16,16(sp)
 8210dac:	dec00704 	addi	sp,sp,28
 8210db0:	f800283a 	ret

08210db4 <__udivdi3>:
 8210db4:	defff504 	addi	sp,sp,-44
 8210db8:	dcc00415 	stw	r19,16(sp)
 8210dbc:	dc000115 	stw	r16,4(sp)
 8210dc0:	dfc00a15 	stw	ra,40(sp)
 8210dc4:	df000915 	stw	fp,36(sp)
 8210dc8:	ddc00815 	stw	r23,32(sp)
 8210dcc:	dd800715 	stw	r22,28(sp)
 8210dd0:	dd400615 	stw	r21,24(sp)
 8210dd4:	dd000515 	stw	r20,20(sp)
 8210dd8:	dc800315 	stw	r18,12(sp)
 8210ddc:	dc400215 	stw	r17,8(sp)
 8210de0:	2027883a 	mov	r19,r4
 8210de4:	2821883a 	mov	r16,r5
 8210de8:	3800411e 	bne	r7,zero,8210ef0 <__udivdi3+0x13c>
 8210dec:	3023883a 	mov	r17,r6
 8210df0:	2025883a 	mov	r18,r4
 8210df4:	2980522e 	bgeu	r5,r6,8210f40 <__udivdi3+0x18c>
 8210df8:	00bfffd4 	movui	r2,65535
 8210dfc:	282d883a 	mov	r22,r5
 8210e00:	1180a836 	bltu	r2,r6,82110a4 <__udivdi3+0x2f0>
 8210e04:	00803fc4 	movi	r2,255
 8210e08:	1185803a 	cmpltu	r2,r2,r6
 8210e0c:	100490fa 	slli	r2,r2,3
 8210e10:	3086d83a 	srl	r3,r6,r2
 8210e14:	01020974 	movhi	r4,2085
 8210e18:	2135d204 	addi	r4,r4,-10424
 8210e1c:	20c7883a 	add	r3,r4,r3
 8210e20:	18c00003 	ldbu	r3,0(r3)
 8210e24:	1885883a 	add	r2,r3,r2
 8210e28:	00c00804 	movi	r3,32
 8210e2c:	1887c83a 	sub	r3,r3,r2
 8210e30:	18000526 	beq	r3,zero,8210e48 <__udivdi3+0x94>
 8210e34:	80e0983a 	sll	r16,r16,r3
 8210e38:	9884d83a 	srl	r2,r19,r2
 8210e3c:	30e2983a 	sll	r17,r6,r3
 8210e40:	98e4983a 	sll	r18,r19,r3
 8210e44:	142cb03a 	or	r22,r2,r16
 8210e48:	882ad43a 	srli	r21,r17,16
 8210e4c:	b009883a 	mov	r4,r22
 8210e50:	8d3fffcc 	andi	r20,r17,65535
 8210e54:	a80b883a 	mov	r5,r21
 8210e58:	82027700 	call	8202770 <__umodsi3>
 8210e5c:	b009883a 	mov	r4,r22
 8210e60:	a80b883a 	mov	r5,r21
 8210e64:	1027883a 	mov	r19,r2
 8210e68:	820270c0 	call	820270c <__udivsi3>
 8210e6c:	102d883a 	mov	r22,r2
 8210e70:	9826943a 	slli	r19,r19,16
 8210e74:	9004d43a 	srli	r2,r18,16
 8210e78:	a5a1383a 	mul	r16,r20,r22
 8210e7c:	14c4b03a 	or	r2,r2,r19
 8210e80:	1400052e 	bgeu	r2,r16,8210e98 <__udivdi3+0xe4>
 8210e84:	1445883a 	add	r2,r2,r17
 8210e88:	b0ffffc4 	addi	r3,r22,-1
 8210e8c:	14400136 	bltu	r2,r17,8210e94 <__udivdi3+0xe0>
 8210e90:	14012336 	bltu	r2,r16,8211320 <__udivdi3+0x56c>
 8210e94:	182d883a 	mov	r22,r3
 8210e98:	1421c83a 	sub	r16,r2,r16
 8210e9c:	a80b883a 	mov	r5,r21
 8210ea0:	8009883a 	mov	r4,r16
 8210ea4:	82027700 	call	8202770 <__umodsi3>
 8210ea8:	1027883a 	mov	r19,r2
 8210eac:	a80b883a 	mov	r5,r21
 8210eb0:	8009883a 	mov	r4,r16
 8210eb4:	820270c0 	call	820270c <__udivsi3>
 8210eb8:	9826943a 	slli	r19,r19,16
 8210ebc:	a0a9383a 	mul	r20,r20,r2
 8210ec0:	94bfffcc 	andi	r18,r18,65535
 8210ec4:	94e4b03a 	or	r18,r18,r19
 8210ec8:	9500052e 	bgeu	r18,r20,8210ee0 <__udivdi3+0x12c>
 8210ecc:	8ca5883a 	add	r18,r17,r18
 8210ed0:	10ffffc4 	addi	r3,r2,-1
 8210ed4:	9440f136 	bltu	r18,r17,821129c <__udivdi3+0x4e8>
 8210ed8:	9500f02e 	bgeu	r18,r20,821129c <__udivdi3+0x4e8>
 8210edc:	10bfff84 	addi	r2,r2,-2
 8210ee0:	b00c943a 	slli	r6,r22,16
 8210ee4:	0007883a 	mov	r3,zero
 8210ee8:	3084b03a 	or	r2,r6,r2
 8210eec:	00005906 	br	8211054 <__udivdi3+0x2a0>
 8210ef0:	29c05636 	bltu	r5,r7,821104c <__udivdi3+0x298>
 8210ef4:	00bfffd4 	movui	r2,65535
 8210ef8:	11c0622e 	bgeu	r2,r7,8211084 <__udivdi3+0x2d0>
 8210efc:	00804034 	movhi	r2,256
 8210f00:	10bfffc4 	addi	r2,r2,-1
 8210f04:	11c0ee36 	bltu	r2,r7,82112c0 <__udivdi3+0x50c>
 8210f08:	00800404 	movi	r2,16
 8210f0c:	3886d83a 	srl	r3,r7,r2
 8210f10:	01020974 	movhi	r4,2085
 8210f14:	2135d204 	addi	r4,r4,-10424
 8210f18:	20c7883a 	add	r3,r4,r3
 8210f1c:	18c00003 	ldbu	r3,0(r3)
 8210f20:	05400804 	movi	r21,32
 8210f24:	1885883a 	add	r2,r3,r2
 8210f28:	a8abc83a 	sub	r21,r21,r2
 8210f2c:	a800621e 	bne	r21,zero,82110b8 <__udivdi3+0x304>
 8210f30:	3c00e936 	bltu	r7,r16,82112d8 <__udivdi3+0x524>
 8210f34:	9985403a 	cmpgeu	r2,r19,r6
 8210f38:	0007883a 	mov	r3,zero
 8210f3c:	00004506 	br	8211054 <__udivdi3+0x2a0>
 8210f40:	3000041e 	bne	r6,zero,8210f54 <__udivdi3+0x1a0>
 8210f44:	000b883a 	mov	r5,zero
 8210f48:	01000044 	movi	r4,1
 8210f4c:	820270c0 	call	820270c <__udivsi3>
 8210f50:	1023883a 	mov	r17,r2
 8210f54:	00bfffd4 	movui	r2,65535
 8210f58:	14404e2e 	bgeu	r2,r17,8211094 <__udivdi3+0x2e0>
 8210f5c:	00804034 	movhi	r2,256
 8210f60:	10bfffc4 	addi	r2,r2,-1
 8210f64:	1440d836 	bltu	r2,r17,82112c8 <__udivdi3+0x514>
 8210f68:	00800404 	movi	r2,16
 8210f6c:	8886d83a 	srl	r3,r17,r2
 8210f70:	01020974 	movhi	r4,2085
 8210f74:	2135d204 	addi	r4,r4,-10424
 8210f78:	20c7883a 	add	r3,r4,r3
 8210f7c:	18c00003 	ldbu	r3,0(r3)
 8210f80:	1885883a 	add	r2,r3,r2
 8210f84:	00c00804 	movi	r3,32
 8210f88:	1887c83a 	sub	r3,r3,r2
 8210f8c:	18008f1e 	bne	r3,zero,82111cc <__udivdi3+0x418>
 8210f90:	882ad43a 	srli	r21,r17,16
 8210f94:	8461c83a 	sub	r16,r16,r17
 8210f98:	8d3fffcc 	andi	r20,r17,65535
 8210f9c:	00c00044 	movi	r3,1
 8210fa0:	8009883a 	mov	r4,r16
 8210fa4:	a80b883a 	mov	r5,r21
 8210fa8:	d8c00015 	stw	r3,0(sp)
 8210fac:	82027700 	call	8202770 <__umodsi3>
 8210fb0:	8009883a 	mov	r4,r16
 8210fb4:	a80b883a 	mov	r5,r21
 8210fb8:	1027883a 	mov	r19,r2
 8210fbc:	820270c0 	call	820270c <__udivsi3>
 8210fc0:	9826943a 	slli	r19,r19,16
 8210fc4:	9008d43a 	srli	r4,r18,16
 8210fc8:	1521383a 	mul	r16,r2,r20
 8210fcc:	102d883a 	mov	r22,r2
 8210fd0:	24c8b03a 	or	r4,r4,r19
 8210fd4:	d8c00017 	ldw	r3,0(sp)
 8210fd8:	2400052e 	bgeu	r4,r16,8210ff0 <__udivdi3+0x23c>
 8210fdc:	2449883a 	add	r4,r4,r17
 8210fe0:	b0bfffc4 	addi	r2,r22,-1
 8210fe4:	24400136 	bltu	r4,r17,8210fec <__udivdi3+0x238>
 8210fe8:	2400ca36 	bltu	r4,r16,8211314 <__udivdi3+0x560>
 8210fec:	102d883a 	mov	r22,r2
 8210ff0:	2421c83a 	sub	r16,r4,r16
 8210ff4:	a80b883a 	mov	r5,r21
 8210ff8:	8009883a 	mov	r4,r16
 8210ffc:	d8c00015 	stw	r3,0(sp)
 8211000:	82027700 	call	8202770 <__umodsi3>
 8211004:	1027883a 	mov	r19,r2
 8211008:	a80b883a 	mov	r5,r21
 821100c:	8009883a 	mov	r4,r16
 8211010:	820270c0 	call	820270c <__udivsi3>
 8211014:	9826943a 	slli	r19,r19,16
 8211018:	1529383a 	mul	r20,r2,r20
 821101c:	94bfffcc 	andi	r18,r18,65535
 8211020:	94e4b03a 	or	r18,r18,r19
 8211024:	d8c00017 	ldw	r3,0(sp)
 8211028:	9500052e 	bgeu	r18,r20,8211040 <__udivdi3+0x28c>
 821102c:	8ca5883a 	add	r18,r17,r18
 8211030:	113fffc4 	addi	r4,r2,-1
 8211034:	94409736 	bltu	r18,r17,8211294 <__udivdi3+0x4e0>
 8211038:	9500962e 	bgeu	r18,r20,8211294 <__udivdi3+0x4e0>
 821103c:	10bfff84 	addi	r2,r2,-2
 8211040:	b00c943a 	slli	r6,r22,16
 8211044:	3084b03a 	or	r2,r6,r2
 8211048:	00000206 	br	8211054 <__udivdi3+0x2a0>
 821104c:	0007883a 	mov	r3,zero
 8211050:	0005883a 	mov	r2,zero
 8211054:	dfc00a17 	ldw	ra,40(sp)
 8211058:	df000917 	ldw	fp,36(sp)
 821105c:	ddc00817 	ldw	r23,32(sp)
 8211060:	dd800717 	ldw	r22,28(sp)
 8211064:	dd400617 	ldw	r21,24(sp)
 8211068:	dd000517 	ldw	r20,20(sp)
 821106c:	dcc00417 	ldw	r19,16(sp)
 8211070:	dc800317 	ldw	r18,12(sp)
 8211074:	dc400217 	ldw	r17,8(sp)
 8211078:	dc000117 	ldw	r16,4(sp)
 821107c:	dec00b04 	addi	sp,sp,44
 8211080:	f800283a 	ret
 8211084:	00803fc4 	movi	r2,255
 8211088:	11c5803a 	cmpltu	r2,r2,r7
 821108c:	100490fa 	slli	r2,r2,3
 8211090:	003f9e06 	br	8210f0c <__udivdi3+0x158>
 8211094:	00803fc4 	movi	r2,255
 8211098:	1445803a 	cmpltu	r2,r2,r17
 821109c:	100490fa 	slli	r2,r2,3
 82110a0:	003fb206 	br	8210f6c <__udivdi3+0x1b8>
 82110a4:	00804034 	movhi	r2,256
 82110a8:	10bfffc4 	addi	r2,r2,-1
 82110ac:	11808836 	bltu	r2,r6,82112d0 <__udivdi3+0x51c>
 82110b0:	00800404 	movi	r2,16
 82110b4:	003f5606 	br	8210e10 <__udivdi3+0x5c>
 82110b8:	30aed83a 	srl	r23,r6,r2
 82110bc:	3d4e983a 	sll	r7,r7,r21
 82110c0:	80acd83a 	srl	r22,r16,r2
 82110c4:	9884d83a 	srl	r2,r19,r2
 82110c8:	3deeb03a 	or	r23,r7,r23
 82110cc:	b824d43a 	srli	r18,r23,16
 82110d0:	8560983a 	sll	r16,r16,r21
 82110d4:	b009883a 	mov	r4,r22
 82110d8:	900b883a 	mov	r5,r18
 82110dc:	3568983a 	sll	r20,r6,r21
 82110e0:	1420b03a 	or	r16,r2,r16
 82110e4:	82027700 	call	8202770 <__umodsi3>
 82110e8:	b009883a 	mov	r4,r22
 82110ec:	900b883a 	mov	r5,r18
 82110f0:	1023883a 	mov	r17,r2
 82110f4:	820270c0 	call	820270c <__udivsi3>
 82110f8:	8808943a 	slli	r4,r17,16
 82110fc:	bf3fffcc 	andi	fp,r23,65535
 8211100:	8006d43a 	srli	r3,r16,16
 8211104:	e0a3383a 	mul	r17,fp,r2
 8211108:	100d883a 	mov	r6,r2
 821110c:	1906b03a 	or	r3,r3,r4
 8211110:	1c40042e 	bgeu	r3,r17,8211124 <__udivdi3+0x370>
 8211114:	1dc7883a 	add	r3,r3,r23
 8211118:	10bfffc4 	addi	r2,r2,-1
 821111c:	1dc0752e 	bgeu	r3,r23,82112f4 <__udivdi3+0x540>
 8211120:	100d883a 	mov	r6,r2
 8211124:	1c63c83a 	sub	r17,r3,r17
 8211128:	900b883a 	mov	r5,r18
 821112c:	8809883a 	mov	r4,r17
 8211130:	d9800015 	stw	r6,0(sp)
 8211134:	82027700 	call	8202770 <__umodsi3>
 8211138:	102d883a 	mov	r22,r2
 821113c:	8809883a 	mov	r4,r17
 8211140:	900b883a 	mov	r5,r18
 8211144:	820270c0 	call	820270c <__udivsi3>
 8211148:	b02c943a 	slli	r22,r22,16
 821114c:	e089383a 	mul	r4,fp,r2
 8211150:	843fffcc 	andi	r16,r16,65535
 8211154:	85a0b03a 	or	r16,r16,r22
 8211158:	d9800017 	ldw	r6,0(sp)
 821115c:	8100042e 	bgeu	r16,r4,8211170 <__udivdi3+0x3bc>
 8211160:	85e1883a 	add	r16,r16,r23
 8211164:	10ffffc4 	addi	r3,r2,-1
 8211168:	85c05e2e 	bgeu	r16,r23,82112e4 <__udivdi3+0x530>
 821116c:	1805883a 	mov	r2,r3
 8211170:	300c943a 	slli	r6,r6,16
 8211174:	a17fffcc 	andi	r5,r20,65535
 8211178:	a028d43a 	srli	r20,r20,16
 821117c:	3084b03a 	or	r2,r6,r2
 8211180:	10ffffcc 	andi	r3,r2,65535
 8211184:	100cd43a 	srli	r6,r2,16
 8211188:	194f383a 	mul	r7,r3,r5
 821118c:	1d07383a 	mul	r3,r3,r20
 8211190:	314b383a 	mul	r5,r6,r5
 8211194:	3810d43a 	srli	r8,r7,16
 8211198:	8121c83a 	sub	r16,r16,r4
 821119c:	1947883a 	add	r3,r3,r5
 82111a0:	40c7883a 	add	r3,r8,r3
 82111a4:	350d383a 	mul	r6,r6,r20
 82111a8:	1940022e 	bgeu	r3,r5,82111b4 <__udivdi3+0x400>
 82111ac:	01000074 	movhi	r4,1
 82111b0:	310d883a 	add	r6,r6,r4
 82111b4:	1828d43a 	srli	r20,r3,16
 82111b8:	a18d883a 	add	r6,r20,r6
 82111bc:	81803e36 	bltu	r16,r6,82112b8 <__udivdi3+0x504>
 82111c0:	81803826 	beq	r16,r6,82112a4 <__udivdi3+0x4f0>
 82111c4:	0007883a 	mov	r3,zero
 82111c8:	003fa206 	br	8211054 <__udivdi3+0x2a0>
 82111cc:	88e2983a 	sll	r17,r17,r3
 82111d0:	80a8d83a 	srl	r20,r16,r2
 82111d4:	80e0983a 	sll	r16,r16,r3
 82111d8:	882ad43a 	srli	r21,r17,16
 82111dc:	9884d83a 	srl	r2,r19,r2
 82111e0:	a009883a 	mov	r4,r20
 82111e4:	a80b883a 	mov	r5,r21
 82111e8:	142eb03a 	or	r23,r2,r16
 82111ec:	98e4983a 	sll	r18,r19,r3
 82111f0:	82027700 	call	8202770 <__umodsi3>
 82111f4:	a009883a 	mov	r4,r20
 82111f8:	a80b883a 	mov	r5,r21
 82111fc:	1021883a 	mov	r16,r2
 8211200:	820270c0 	call	820270c <__udivsi3>
 8211204:	1039883a 	mov	fp,r2
 8211208:	8d3fffcc 	andi	r20,r17,65535
 821120c:	8020943a 	slli	r16,r16,16
 8211210:	b804d43a 	srli	r2,r23,16
 8211214:	a72d383a 	mul	r22,r20,fp
 8211218:	1404b03a 	or	r2,r2,r16
 821121c:	1580062e 	bgeu	r2,r22,8211238 <__udivdi3+0x484>
 8211220:	1445883a 	add	r2,r2,r17
 8211224:	e0ffffc4 	addi	r3,fp,-1
 8211228:	14403836 	bltu	r2,r17,821130c <__udivdi3+0x558>
 821122c:	1580372e 	bgeu	r2,r22,821130c <__udivdi3+0x558>
 8211230:	e73fff84 	addi	fp,fp,-2
 8211234:	1445883a 	add	r2,r2,r17
 8211238:	15adc83a 	sub	r22,r2,r22
 821123c:	a80b883a 	mov	r5,r21
 8211240:	b009883a 	mov	r4,r22
 8211244:	82027700 	call	8202770 <__umodsi3>
 8211248:	1027883a 	mov	r19,r2
 821124c:	b009883a 	mov	r4,r22
 8211250:	a80b883a 	mov	r5,r21
 8211254:	820270c0 	call	820270c <__udivsi3>
 8211258:	9826943a 	slli	r19,r19,16
 821125c:	a0a1383a 	mul	r16,r20,r2
 8211260:	b93fffcc 	andi	r4,r23,65535
 8211264:	24c8b03a 	or	r4,r4,r19
 8211268:	2400062e 	bgeu	r4,r16,8211284 <__udivdi3+0x4d0>
 821126c:	2449883a 	add	r4,r4,r17
 8211270:	10ffffc4 	addi	r3,r2,-1
 8211274:	24402336 	bltu	r4,r17,8211304 <__udivdi3+0x550>
 8211278:	2400222e 	bgeu	r4,r16,8211304 <__udivdi3+0x550>
 821127c:	10bfff84 	addi	r2,r2,-2
 8211280:	2449883a 	add	r4,r4,r17
 8211284:	e038943a 	slli	fp,fp,16
 8211288:	2421c83a 	sub	r16,r4,r16
 821128c:	e086b03a 	or	r3,fp,r2
 8211290:	003f4306 	br	8210fa0 <__udivdi3+0x1ec>
 8211294:	2005883a 	mov	r2,r4
 8211298:	003f6906 	br	8211040 <__udivdi3+0x28c>
 821129c:	1805883a 	mov	r2,r3
 82112a0:	003f0f06 	br	8210ee0 <__udivdi3+0x12c>
 82112a4:	1806943a 	slli	r3,r3,16
 82112a8:	9d66983a 	sll	r19,r19,r21
 82112ac:	39ffffcc 	andi	r7,r7,65535
 82112b0:	19c7883a 	add	r3,r3,r7
 82112b4:	98ffc32e 	bgeu	r19,r3,82111c4 <__udivdi3+0x410>
 82112b8:	10bfffc4 	addi	r2,r2,-1
 82112bc:	003fc106 	br	82111c4 <__udivdi3+0x410>
 82112c0:	00800604 	movi	r2,24
 82112c4:	003f1106 	br	8210f0c <__udivdi3+0x158>
 82112c8:	00800604 	movi	r2,24
 82112cc:	003f2706 	br	8210f6c <__udivdi3+0x1b8>
 82112d0:	00800604 	movi	r2,24
 82112d4:	003ece06 	br	8210e10 <__udivdi3+0x5c>
 82112d8:	0007883a 	mov	r3,zero
 82112dc:	00800044 	movi	r2,1
 82112e0:	003f5c06 	br	8211054 <__udivdi3+0x2a0>
 82112e4:	813fa12e 	bgeu	r16,r4,821116c <__udivdi3+0x3b8>
 82112e8:	10bfff84 	addi	r2,r2,-2
 82112ec:	85e1883a 	add	r16,r16,r23
 82112f0:	003f9f06 	br	8211170 <__udivdi3+0x3bc>
 82112f4:	1c7f8a2e 	bgeu	r3,r17,8211120 <__udivdi3+0x36c>
 82112f8:	31bfff84 	addi	r6,r6,-2
 82112fc:	1dc7883a 	add	r3,r3,r23
 8211300:	003f8806 	br	8211124 <__udivdi3+0x370>
 8211304:	1805883a 	mov	r2,r3
 8211308:	003fde06 	br	8211284 <__udivdi3+0x4d0>
 821130c:	1839883a 	mov	fp,r3
 8211310:	003fc906 	br	8211238 <__udivdi3+0x484>
 8211314:	b5bfff84 	addi	r22,r22,-2
 8211318:	2449883a 	add	r4,r4,r17
 821131c:	003f3406 	br	8210ff0 <__udivdi3+0x23c>
 8211320:	b5bfff84 	addi	r22,r22,-2
 8211324:	1445883a 	add	r2,r2,r17
 8211328:	003edb06 	br	8210e98 <__udivdi3+0xe4>

0821132c <__umoddi3>:
 821132c:	defff404 	addi	sp,sp,-48
 8211330:	df000a15 	stw	fp,40(sp)
 8211334:	dc400315 	stw	r17,12(sp)
 8211338:	dc000215 	stw	r16,8(sp)
 821133c:	dfc00b15 	stw	ra,44(sp)
 8211340:	ddc00915 	stw	r23,36(sp)
 8211344:	dd800815 	stw	r22,32(sp)
 8211348:	dd400715 	stw	r21,28(sp)
 821134c:	dd000615 	stw	r20,24(sp)
 8211350:	dcc00515 	stw	r19,20(sp)
 8211354:	dc800415 	stw	r18,16(sp)
 8211358:	2021883a 	mov	r16,r4
 821135c:	2823883a 	mov	r17,r5
 8211360:	2839883a 	mov	fp,r5
 8211364:	38003c1e 	bne	r7,zero,8211458 <__umoddi3+0x12c>
 8211368:	3027883a 	mov	r19,r6
 821136c:	2029883a 	mov	r20,r4
 8211370:	2980512e 	bgeu	r5,r6,82114b8 <__umoddi3+0x18c>
 8211374:	00bfffd4 	movui	r2,65535
 8211378:	11809a36 	bltu	r2,r6,82115e4 <__umoddi3+0x2b8>
 821137c:	01003fc4 	movi	r4,255
 8211380:	2189803a 	cmpltu	r4,r4,r6
 8211384:	200890fa 	slli	r4,r4,3
 8211388:	3104d83a 	srl	r2,r6,r4
 821138c:	00c20974 	movhi	r3,2085
 8211390:	18f5d204 	addi	r3,r3,-10424
 8211394:	1885883a 	add	r2,r3,r2
 8211398:	10c00003 	ldbu	r3,0(r2)
 821139c:	00800804 	movi	r2,32
 82113a0:	1909883a 	add	r4,r3,r4
 82113a4:	1125c83a 	sub	r18,r2,r4
 82113a8:	90000526 	beq	r18,zero,82113c0 <__umoddi3+0x94>
 82113ac:	8ca2983a 	sll	r17,r17,r18
 82113b0:	8108d83a 	srl	r4,r16,r4
 82113b4:	34a6983a 	sll	r19,r6,r18
 82113b8:	84a8983a 	sll	r20,r16,r18
 82113bc:	2478b03a 	or	fp,r4,r17
 82113c0:	982ed43a 	srli	r23,r19,16
 82113c4:	e009883a 	mov	r4,fp
 82113c8:	9dbfffcc 	andi	r22,r19,65535
 82113cc:	b80b883a 	mov	r5,r23
 82113d0:	82027700 	call	8202770 <__umodsi3>
 82113d4:	e009883a 	mov	r4,fp
 82113d8:	b80b883a 	mov	r5,r23
 82113dc:	102b883a 	mov	r21,r2
 82113e0:	820270c0 	call	820270c <__udivsi3>
 82113e4:	a806943a 	slli	r3,r21,16
 82113e8:	a008d43a 	srli	r4,r20,16
 82113ec:	b085383a 	mul	r2,r22,r2
 82113f0:	20c8b03a 	or	r4,r4,r3
 82113f4:	2080032e 	bgeu	r4,r2,8211404 <__umoddi3+0xd8>
 82113f8:	24c9883a 	add	r4,r4,r19
 82113fc:	24c00136 	bltu	r4,r19,8211404 <__umoddi3+0xd8>
 8211400:	20811036 	bltu	r4,r2,8211844 <__umoddi3+0x518>
 8211404:	20abc83a 	sub	r21,r4,r2
 8211408:	b80b883a 	mov	r5,r23
 821140c:	a809883a 	mov	r4,r21
 8211410:	82027700 	call	8202770 <__umodsi3>
 8211414:	1023883a 	mov	r17,r2
 8211418:	b80b883a 	mov	r5,r23
 821141c:	a809883a 	mov	r4,r21
 8211420:	820270c0 	call	820270c <__udivsi3>
 8211424:	8822943a 	slli	r17,r17,16
 8211428:	b085383a 	mul	r2,r22,r2
 821142c:	a0ffffcc 	andi	r3,r20,65535
 8211430:	1c46b03a 	or	r3,r3,r17
 8211434:	1880042e 	bgeu	r3,r2,8211448 <__umoddi3+0x11c>
 8211438:	1cc7883a 	add	r3,r3,r19
 821143c:	1cc00236 	bltu	r3,r19,8211448 <__umoddi3+0x11c>
 8211440:	1880012e 	bgeu	r3,r2,8211448 <__umoddi3+0x11c>
 8211444:	1cc7883a 	add	r3,r3,r19
 8211448:	1885c83a 	sub	r2,r3,r2
 821144c:	1484d83a 	srl	r2,r2,r18
 8211450:	0007883a 	mov	r3,zero
 8211454:	00004f06 	br	8211594 <__umoddi3+0x268>
 8211458:	29c04c36 	bltu	r5,r7,821158c <__umoddi3+0x260>
 821145c:	00bfffd4 	movui	r2,65535
 8211460:	11c0582e 	bgeu	r2,r7,82115c4 <__umoddi3+0x298>
 8211464:	00804034 	movhi	r2,256
 8211468:	10bfffc4 	addi	r2,r2,-1
 821146c:	11c0e736 	bltu	r2,r7,821180c <__umoddi3+0x4e0>
 8211470:	01000404 	movi	r4,16
 8211474:	3904d83a 	srl	r2,r7,r4
 8211478:	00c20974 	movhi	r3,2085
 821147c:	18f5d204 	addi	r3,r3,-10424
 8211480:	1885883a 	add	r2,r3,r2
 8211484:	14c00003 	ldbu	r19,0(r2)
 8211488:	00c00804 	movi	r3,32
 821148c:	9927883a 	add	r19,r19,r4
 8211490:	1ce9c83a 	sub	r20,r3,r19
 8211494:	a000581e 	bne	r20,zero,82115f8 <__umoddi3+0x2cc>
 8211498:	3c400136 	bltu	r7,r17,82114a0 <__umoddi3+0x174>
 821149c:	8180eb36 	bltu	r16,r6,821184c <__umoddi3+0x520>
 82114a0:	8185c83a 	sub	r2,r16,r6
 82114a4:	89e3c83a 	sub	r17,r17,r7
 82114a8:	8089803a 	cmpltu	r4,r16,r2
 82114ac:	8939c83a 	sub	fp,r17,r4
 82114b0:	e007883a 	mov	r3,fp
 82114b4:	00003706 	br	8211594 <__umoddi3+0x268>
 82114b8:	3000041e 	bne	r6,zero,82114cc <__umoddi3+0x1a0>
 82114bc:	000b883a 	mov	r5,zero
 82114c0:	01000044 	movi	r4,1
 82114c4:	820270c0 	call	820270c <__udivsi3>
 82114c8:	1027883a 	mov	r19,r2
 82114cc:	00bfffd4 	movui	r2,65535
 82114d0:	14c0402e 	bgeu	r2,r19,82115d4 <__umoddi3+0x2a8>
 82114d4:	00804034 	movhi	r2,256
 82114d8:	10bfffc4 	addi	r2,r2,-1
 82114dc:	14c0cd36 	bltu	r2,r19,8211814 <__umoddi3+0x4e8>
 82114e0:	00800404 	movi	r2,16
 82114e4:	9886d83a 	srl	r3,r19,r2
 82114e8:	01020974 	movhi	r4,2085
 82114ec:	2135d204 	addi	r4,r4,-10424
 82114f0:	20c7883a 	add	r3,r4,r3
 82114f4:	18c00003 	ldbu	r3,0(r3)
 82114f8:	1887883a 	add	r3,r3,r2
 82114fc:	00800804 	movi	r2,32
 8211500:	10e5c83a 	sub	r18,r2,r3
 8211504:	9000901e 	bne	r18,zero,8211748 <__umoddi3+0x41c>
 8211508:	982cd43a 	srli	r22,r19,16
 821150c:	8ce3c83a 	sub	r17,r17,r19
 8211510:	9d7fffcc 	andi	r21,r19,65535
 8211514:	b00b883a 	mov	r5,r22
 8211518:	8809883a 	mov	r4,r17
 821151c:	82027700 	call	8202770 <__umodsi3>
 8211520:	8809883a 	mov	r4,r17
 8211524:	b00b883a 	mov	r5,r22
 8211528:	1021883a 	mov	r16,r2
 821152c:	820270c0 	call	820270c <__udivsi3>
 8211530:	8006943a 	slli	r3,r16,16
 8211534:	a008d43a 	srli	r4,r20,16
 8211538:	1545383a 	mul	r2,r2,r21
 821153c:	20c8b03a 	or	r4,r4,r3
 8211540:	2080042e 	bgeu	r4,r2,8211554 <__umoddi3+0x228>
 8211544:	24c9883a 	add	r4,r4,r19
 8211548:	24c00236 	bltu	r4,r19,8211554 <__umoddi3+0x228>
 821154c:	2080012e 	bgeu	r4,r2,8211554 <__umoddi3+0x228>
 8211550:	24c9883a 	add	r4,r4,r19
 8211554:	20a1c83a 	sub	r16,r4,r2
 8211558:	b00b883a 	mov	r5,r22
 821155c:	8009883a 	mov	r4,r16
 8211560:	82027700 	call	8202770 <__umodsi3>
 8211564:	1023883a 	mov	r17,r2
 8211568:	b00b883a 	mov	r5,r22
 821156c:	8009883a 	mov	r4,r16
 8211570:	820270c0 	call	820270c <__udivsi3>
 8211574:	8822943a 	slli	r17,r17,16
 8211578:	1545383a 	mul	r2,r2,r21
 821157c:	a53fffcc 	andi	r20,r20,65535
 8211580:	a446b03a 	or	r3,r20,r17
 8211584:	18bfb02e 	bgeu	r3,r2,8211448 <__umoddi3+0x11c>
 8211588:	003fab06 	br	8211438 <__umoddi3+0x10c>
 821158c:	2005883a 	mov	r2,r4
 8211590:	2807883a 	mov	r3,r5
 8211594:	dfc00b17 	ldw	ra,44(sp)
 8211598:	df000a17 	ldw	fp,40(sp)
 821159c:	ddc00917 	ldw	r23,36(sp)
 82115a0:	dd800817 	ldw	r22,32(sp)
 82115a4:	dd400717 	ldw	r21,28(sp)
 82115a8:	dd000617 	ldw	r20,24(sp)
 82115ac:	dcc00517 	ldw	r19,20(sp)
 82115b0:	dc800417 	ldw	r18,16(sp)
 82115b4:	dc400317 	ldw	r17,12(sp)
 82115b8:	dc000217 	ldw	r16,8(sp)
 82115bc:	dec00c04 	addi	sp,sp,48
 82115c0:	f800283a 	ret
 82115c4:	04c03fc4 	movi	r19,255
 82115c8:	99c9803a 	cmpltu	r4,r19,r7
 82115cc:	200890fa 	slli	r4,r4,3
 82115d0:	003fa806 	br	8211474 <__umoddi3+0x148>
 82115d4:	00803fc4 	movi	r2,255
 82115d8:	14c5803a 	cmpltu	r2,r2,r19
 82115dc:	100490fa 	slli	r2,r2,3
 82115e0:	003fc006 	br	82114e4 <__umoddi3+0x1b8>
 82115e4:	00804034 	movhi	r2,256
 82115e8:	10bfffc4 	addi	r2,r2,-1
 82115ec:	11808b36 	bltu	r2,r6,821181c <__umoddi3+0x4f0>
 82115f0:	01000404 	movi	r4,16
 82115f4:	003f6406 	br	8211388 <__umoddi3+0x5c>
 82115f8:	34c4d83a 	srl	r2,r6,r19
 82115fc:	3d0e983a 	sll	r7,r7,r20
 8211600:	8cf8d83a 	srl	fp,r17,r19
 8211604:	8d10983a 	sll	r8,r17,r20
 8211608:	38aab03a 	or	r21,r7,r2
 821160c:	a82cd43a 	srli	r22,r21,16
 8211610:	84e2d83a 	srl	r17,r16,r19
 8211614:	e009883a 	mov	r4,fp
 8211618:	b00b883a 	mov	r5,r22
 821161c:	8a22b03a 	or	r17,r17,r8
 8211620:	3524983a 	sll	r18,r6,r20
 8211624:	82027700 	call	8202770 <__umodsi3>
 8211628:	e009883a 	mov	r4,fp
 821162c:	b00b883a 	mov	r5,r22
 8211630:	102f883a 	mov	r23,r2
 8211634:	820270c0 	call	820270c <__udivsi3>
 8211638:	100d883a 	mov	r6,r2
 821163c:	b808943a 	slli	r4,r23,16
 8211640:	aa3fffcc 	andi	r8,r21,65535
 8211644:	8804d43a 	srli	r2,r17,16
 8211648:	41af383a 	mul	r23,r8,r6
 821164c:	8520983a 	sll	r16,r16,r20
 8211650:	1104b03a 	or	r2,r2,r4
 8211654:	15c0042e 	bgeu	r2,r23,8211668 <__umoddi3+0x33c>
 8211658:	1545883a 	add	r2,r2,r21
 821165c:	30ffffc4 	addi	r3,r6,-1
 8211660:	1540742e 	bgeu	r2,r21,8211834 <__umoddi3+0x508>
 8211664:	180d883a 	mov	r6,r3
 8211668:	15efc83a 	sub	r23,r2,r23
 821166c:	b00b883a 	mov	r5,r22
 8211670:	b809883a 	mov	r4,r23
 8211674:	d9800115 	stw	r6,4(sp)
 8211678:	da000015 	stw	r8,0(sp)
 821167c:	82027700 	call	8202770 <__umodsi3>
 8211680:	b00b883a 	mov	r5,r22
 8211684:	b809883a 	mov	r4,r23
 8211688:	1039883a 	mov	fp,r2
 821168c:	820270c0 	call	820270c <__udivsi3>
 8211690:	da000017 	ldw	r8,0(sp)
 8211694:	e038943a 	slli	fp,fp,16
 8211698:	100b883a 	mov	r5,r2
 821169c:	4089383a 	mul	r4,r8,r2
 82116a0:	8a3fffcc 	andi	r8,r17,65535
 82116a4:	4710b03a 	or	r8,r8,fp
 82116a8:	d9800117 	ldw	r6,4(sp)
 82116ac:	4100042e 	bgeu	r8,r4,82116c0 <__umoddi3+0x394>
 82116b0:	4551883a 	add	r8,r8,r21
 82116b4:	10bfffc4 	addi	r2,r2,-1
 82116b8:	45405a2e 	bgeu	r8,r21,8211824 <__umoddi3+0x4f8>
 82116bc:	100b883a 	mov	r5,r2
 82116c0:	300c943a 	slli	r6,r6,16
 82116c4:	91ffffcc 	andi	r7,r18,65535
 82116c8:	9004d43a 	srli	r2,r18,16
 82116cc:	314cb03a 	or	r6,r6,r5
 82116d0:	317fffcc 	andi	r5,r6,65535
 82116d4:	300cd43a 	srli	r6,r6,16
 82116d8:	29d3383a 	mul	r9,r5,r7
 82116dc:	288b383a 	mul	r5,r5,r2
 82116e0:	31cf383a 	mul	r7,r6,r7
 82116e4:	4806d43a 	srli	r3,r9,16
 82116e8:	4111c83a 	sub	r8,r8,r4
 82116ec:	29cb883a 	add	r5,r5,r7
 82116f0:	194b883a 	add	r5,r3,r5
 82116f4:	3085383a 	mul	r2,r6,r2
 82116f8:	29c0022e 	bgeu	r5,r7,8211704 <__umoddi3+0x3d8>
 82116fc:	00c00074 	movhi	r3,1
 8211700:	10c5883a 	add	r2,r2,r3
 8211704:	2808d43a 	srli	r4,r5,16
 8211708:	280a943a 	slli	r5,r5,16
 821170c:	4a7fffcc 	andi	r9,r9,65535
 8211710:	2085883a 	add	r2,r4,r2
 8211714:	2a4b883a 	add	r5,r5,r9
 8211718:	40803636 	bltu	r8,r2,82117f4 <__umoddi3+0x4c8>
 821171c:	40804d26 	beq	r8,r2,8211854 <__umoddi3+0x528>
 8211720:	4089c83a 	sub	r4,r8,r2
 8211724:	280f883a 	mov	r7,r5
 8211728:	81cfc83a 	sub	r7,r16,r7
 821172c:	81c7803a 	cmpltu	r3,r16,r7
 8211730:	20c7c83a 	sub	r3,r4,r3
 8211734:	1cc4983a 	sll	r2,r3,r19
 8211738:	3d0ed83a 	srl	r7,r7,r20
 821173c:	1d06d83a 	srl	r3,r3,r20
 8211740:	11c4b03a 	or	r2,r2,r7
 8211744:	003f9306 	br	8211594 <__umoddi3+0x268>
 8211748:	9ca6983a 	sll	r19,r19,r18
 821174c:	88e8d83a 	srl	r20,r17,r3
 8211750:	80c4d83a 	srl	r2,r16,r3
 8211754:	982cd43a 	srli	r22,r19,16
 8211758:	8ca2983a 	sll	r17,r17,r18
 821175c:	a009883a 	mov	r4,r20
 8211760:	b00b883a 	mov	r5,r22
 8211764:	1478b03a 	or	fp,r2,r17
 8211768:	82027700 	call	8202770 <__umodsi3>
 821176c:	a009883a 	mov	r4,r20
 8211770:	b00b883a 	mov	r5,r22
 8211774:	1023883a 	mov	r17,r2
 8211778:	820270c0 	call	820270c <__udivsi3>
 821177c:	9d7fffcc 	andi	r21,r19,65535
 8211780:	880a943a 	slli	r5,r17,16
 8211784:	e008d43a 	srli	r4,fp,16
 8211788:	a885383a 	mul	r2,r21,r2
 821178c:	84a8983a 	sll	r20,r16,r18
 8211790:	2148b03a 	or	r4,r4,r5
 8211794:	2080042e 	bgeu	r4,r2,82117a8 <__umoddi3+0x47c>
 8211798:	24c9883a 	add	r4,r4,r19
 821179c:	24c00236 	bltu	r4,r19,82117a8 <__umoddi3+0x47c>
 82117a0:	2080012e 	bgeu	r4,r2,82117a8 <__umoddi3+0x47c>
 82117a4:	24c9883a 	add	r4,r4,r19
 82117a8:	20a3c83a 	sub	r17,r4,r2
 82117ac:	b00b883a 	mov	r5,r22
 82117b0:	8809883a 	mov	r4,r17
 82117b4:	82027700 	call	8202770 <__umodsi3>
 82117b8:	102f883a 	mov	r23,r2
 82117bc:	8809883a 	mov	r4,r17
 82117c0:	b00b883a 	mov	r5,r22
 82117c4:	820270c0 	call	820270c <__udivsi3>
 82117c8:	b82e943a 	slli	r23,r23,16
 82117cc:	a885383a 	mul	r2,r21,r2
 82117d0:	e13fffcc 	andi	r4,fp,65535
 82117d4:	25c8b03a 	or	r4,r4,r23
 82117d8:	2080042e 	bgeu	r4,r2,82117ec <__umoddi3+0x4c0>
 82117dc:	24c9883a 	add	r4,r4,r19
 82117e0:	24c00236 	bltu	r4,r19,82117ec <__umoddi3+0x4c0>
 82117e4:	2080012e 	bgeu	r4,r2,82117ec <__umoddi3+0x4c0>
 82117e8:	24c9883a 	add	r4,r4,r19
 82117ec:	20a3c83a 	sub	r17,r4,r2
 82117f0:	003f4806 	br	8211514 <__umoddi3+0x1e8>
 82117f4:	2c8fc83a 	sub	r7,r5,r18
 82117f8:	1545c83a 	sub	r2,r2,r21
 82117fc:	29cb803a 	cmpltu	r5,r5,r7
 8211800:	1145c83a 	sub	r2,r2,r5
 8211804:	4089c83a 	sub	r4,r8,r2
 8211808:	003fc706 	br	8211728 <__umoddi3+0x3fc>
 821180c:	01000604 	movi	r4,24
 8211810:	003f1806 	br	8211474 <__umoddi3+0x148>
 8211814:	00800604 	movi	r2,24
 8211818:	003f3206 	br	82114e4 <__umoddi3+0x1b8>
 821181c:	01000604 	movi	r4,24
 8211820:	003ed906 	br	8211388 <__umoddi3+0x5c>
 8211824:	413fa52e 	bgeu	r8,r4,82116bc <__umoddi3+0x390>
 8211828:	297fff84 	addi	r5,r5,-2
 821182c:	4551883a 	add	r8,r8,r21
 8211830:	003fa306 	br	82116c0 <__umoddi3+0x394>
 8211834:	15ff8b2e 	bgeu	r2,r23,8211664 <__umoddi3+0x338>
 8211838:	31bfff84 	addi	r6,r6,-2
 821183c:	1545883a 	add	r2,r2,r21
 8211840:	003f8906 	br	8211668 <__umoddi3+0x33c>
 8211844:	24c9883a 	add	r4,r4,r19
 8211848:	003eee06 	br	8211404 <__umoddi3+0xd8>
 821184c:	8005883a 	mov	r2,r16
 8211850:	003f1706 	br	82114b0 <__umoddi3+0x184>
 8211854:	817fe736 	bltu	r16,r5,82117f4 <__umoddi3+0x4c8>
 8211858:	280f883a 	mov	r7,r5
 821185c:	0009883a 	mov	r4,zero
 8211860:	003fb106 	br	8211728 <__umoddi3+0x3fc>

08211864 <__adddf3>:
 8211864:	02c00434 	movhi	r11,16
 8211868:	5affffc4 	addi	r11,r11,-1
 821186c:	2806d7fa 	srli	r3,r5,31
 8211870:	2ad4703a 	and	r10,r5,r11
 8211874:	3ad2703a 	and	r9,r7,r11
 8211878:	3804d53a 	srli	r2,r7,20
 821187c:	3018d77a 	srli	r12,r6,29
 8211880:	280ad53a 	srli	r5,r5,20
 8211884:	501490fa 	slli	r10,r10,3
 8211888:	2010d77a 	srli	r8,r4,29
 821188c:	481290fa 	slli	r9,r9,3
 8211890:	380ed7fa 	srli	r7,r7,31
 8211894:	defffb04 	addi	sp,sp,-20
 8211898:	dc800215 	stw	r18,8(sp)
 821189c:	dc400115 	stw	r17,4(sp)
 82118a0:	dc000015 	stw	r16,0(sp)
 82118a4:	dfc00415 	stw	ra,16(sp)
 82118a8:	dcc00315 	stw	r19,12(sp)
 82118ac:	1c803fcc 	andi	r18,r3,255
 82118b0:	2c01ffcc 	andi	r16,r5,2047
 82118b4:	5210b03a 	or	r8,r10,r8
 82118b8:	202290fa 	slli	r17,r4,3
 82118bc:	1081ffcc 	andi	r2,r2,2047
 82118c0:	4b12b03a 	or	r9,r9,r12
 82118c4:	300c90fa 	slli	r6,r6,3
 82118c8:	91c07526 	beq	r18,r7,8211aa0 <__adddf3+0x23c>
 82118cc:	8087c83a 	sub	r3,r16,r2
 82118d0:	00c0ab0e 	bge	zero,r3,8211b80 <__adddf3+0x31c>
 82118d4:	10002a1e 	bne	r2,zero,8211980 <__adddf3+0x11c>
 82118d8:	4984b03a 	or	r2,r9,r6
 82118dc:	1000961e 	bne	r2,zero,8211b38 <__adddf3+0x2d4>
 82118e0:	888001cc 	andi	r2,r17,7
 82118e4:	10000726 	beq	r2,zero,8211904 <__adddf3+0xa0>
 82118e8:	888003cc 	andi	r2,r17,15
 82118ec:	00c00104 	movi	r3,4
 82118f0:	10c00426 	beq	r2,r3,8211904 <__adddf3+0xa0>
 82118f4:	88c7883a 	add	r3,r17,r3
 82118f8:	1c63803a 	cmpltu	r17,r3,r17
 82118fc:	4451883a 	add	r8,r8,r17
 8211900:	1823883a 	mov	r17,r3
 8211904:	4080202c 	andhi	r2,r8,128
 8211908:	10005926 	beq	r2,zero,8211a70 <__adddf3+0x20c>
 821190c:	84000044 	addi	r16,r16,1
 8211910:	0081ffc4 	movi	r2,2047
 8211914:	8080ba26 	beq	r16,r2,8211c00 <__adddf3+0x39c>
 8211918:	00bfe034 	movhi	r2,65408
 821191c:	10bfffc4 	addi	r2,r2,-1
 8211920:	4090703a 	and	r8,r8,r2
 8211924:	4004977a 	slli	r2,r8,29
 8211928:	4010927a 	slli	r8,r8,9
 821192c:	8822d0fa 	srli	r17,r17,3
 8211930:	8401ffcc 	andi	r16,r16,2047
 8211934:	4010d33a 	srli	r8,r8,12
 8211938:	9007883a 	mov	r3,r18
 821193c:	1444b03a 	or	r2,r2,r17
 8211940:	8401ffcc 	andi	r16,r16,2047
 8211944:	8020953a 	slli	r16,r16,20
 8211948:	18c03fcc 	andi	r3,r3,255
 821194c:	01000434 	movhi	r4,16
 8211950:	213fffc4 	addi	r4,r4,-1
 8211954:	180697fa 	slli	r3,r3,31
 8211958:	4110703a 	and	r8,r8,r4
 821195c:	4410b03a 	or	r8,r8,r16
 8211960:	40c6b03a 	or	r3,r8,r3
 8211964:	dfc00417 	ldw	ra,16(sp)
 8211968:	dcc00317 	ldw	r19,12(sp)
 821196c:	dc800217 	ldw	r18,8(sp)
 8211970:	dc400117 	ldw	r17,4(sp)
 8211974:	dc000017 	ldw	r16,0(sp)
 8211978:	dec00504 	addi	sp,sp,20
 821197c:	f800283a 	ret
 8211980:	0081ffc4 	movi	r2,2047
 8211984:	80bfd626 	beq	r16,r2,82118e0 <__adddf3+0x7c>
 8211988:	4a402034 	orhi	r9,r9,128
 821198c:	00800e04 	movi	r2,56
 8211990:	10c09f16 	blt	r2,r3,8211c10 <__adddf3+0x3ac>
 8211994:	008007c4 	movi	r2,31
 8211998:	10c0c216 	blt	r2,r3,8211ca4 <__adddf3+0x440>
 821199c:	00800804 	movi	r2,32
 82119a0:	10c5c83a 	sub	r2,r2,r3
 82119a4:	488a983a 	sll	r5,r9,r2
 82119a8:	30c8d83a 	srl	r4,r6,r3
 82119ac:	3084983a 	sll	r2,r6,r2
 82119b0:	48c6d83a 	srl	r3,r9,r3
 82119b4:	290cb03a 	or	r6,r5,r4
 82119b8:	1004c03a 	cmpne	r2,r2,zero
 82119bc:	308cb03a 	or	r6,r6,r2
 82119c0:	898dc83a 	sub	r6,r17,r6
 82119c4:	89a3803a 	cmpltu	r17,r17,r6
 82119c8:	40d1c83a 	sub	r8,r8,r3
 82119cc:	4451c83a 	sub	r8,r8,r17
 82119d0:	3023883a 	mov	r17,r6
 82119d4:	4080202c 	andhi	r2,r8,128
 82119d8:	10002326 	beq	r2,zero,8211a68 <__adddf3+0x204>
 82119dc:	04c02034 	movhi	r19,128
 82119e0:	9cffffc4 	addi	r19,r19,-1
 82119e4:	44e6703a 	and	r19,r8,r19
 82119e8:	98007626 	beq	r19,zero,8211bc4 <__adddf3+0x360>
 82119ec:	9809883a 	mov	r4,r19
 82119f0:	8213e680 	call	8213e68 <__clzsi2>
 82119f4:	10fffe04 	addi	r3,r2,-8
 82119f8:	010007c4 	movi	r4,31
 82119fc:	20c07716 	blt	r4,r3,8211bdc <__adddf3+0x378>
 8211a00:	00800804 	movi	r2,32
 8211a04:	10c5c83a 	sub	r2,r2,r3
 8211a08:	8884d83a 	srl	r2,r17,r2
 8211a0c:	98d0983a 	sll	r8,r19,r3
 8211a10:	88e2983a 	sll	r17,r17,r3
 8211a14:	1204b03a 	or	r2,r2,r8
 8211a18:	1c007416 	blt	r3,r16,8211bec <__adddf3+0x388>
 8211a1c:	1c21c83a 	sub	r16,r3,r16
 8211a20:	82000044 	addi	r8,r16,1
 8211a24:	00c007c4 	movi	r3,31
 8211a28:	1a009116 	blt	r3,r8,8211c70 <__adddf3+0x40c>
 8211a2c:	00c00804 	movi	r3,32
 8211a30:	1a07c83a 	sub	r3,r3,r8
 8211a34:	8a08d83a 	srl	r4,r17,r8
 8211a38:	88e2983a 	sll	r17,r17,r3
 8211a3c:	10c6983a 	sll	r3,r2,r3
 8211a40:	1210d83a 	srl	r8,r2,r8
 8211a44:	8804c03a 	cmpne	r2,r17,zero
 8211a48:	1906b03a 	or	r3,r3,r4
 8211a4c:	18a2b03a 	or	r17,r3,r2
 8211a50:	0021883a 	mov	r16,zero
 8211a54:	003fa206 	br	82118e0 <__adddf3+0x7c>
 8211a58:	1890b03a 	or	r8,r3,r2
 8211a5c:	40017d26 	beq	r8,zero,8212054 <__adddf3+0x7f0>
 8211a60:	1011883a 	mov	r8,r2
 8211a64:	1823883a 	mov	r17,r3
 8211a68:	888001cc 	andi	r2,r17,7
 8211a6c:	103f9e1e 	bne	r2,zero,82118e8 <__adddf3+0x84>
 8211a70:	4004977a 	slli	r2,r8,29
 8211a74:	8822d0fa 	srli	r17,r17,3
 8211a78:	4010d0fa 	srli	r8,r8,3
 8211a7c:	9007883a 	mov	r3,r18
 8211a80:	1444b03a 	or	r2,r2,r17
 8211a84:	0101ffc4 	movi	r4,2047
 8211a88:	81002426 	beq	r16,r4,8211b1c <__adddf3+0x2b8>
 8211a8c:	8120703a 	and	r16,r16,r4
 8211a90:	01000434 	movhi	r4,16
 8211a94:	213fffc4 	addi	r4,r4,-1
 8211a98:	4110703a 	and	r8,r8,r4
 8211a9c:	003fa806 	br	8211940 <__adddf3+0xdc>
 8211aa0:	8089c83a 	sub	r4,r16,r2
 8211aa4:	01005e0e 	bge	zero,r4,8211c20 <__adddf3+0x3bc>
 8211aa8:	10002b26 	beq	r2,zero,8211b58 <__adddf3+0x2f4>
 8211aac:	0081ffc4 	movi	r2,2047
 8211ab0:	80bf8b26 	beq	r16,r2,82118e0 <__adddf3+0x7c>
 8211ab4:	4a402034 	orhi	r9,r9,128
 8211ab8:	00800e04 	movi	r2,56
 8211abc:	1100a40e 	bge	r2,r4,8211d50 <__adddf3+0x4ec>
 8211ac0:	498cb03a 	or	r6,r9,r6
 8211ac4:	300ac03a 	cmpne	r5,r6,zero
 8211ac8:	0013883a 	mov	r9,zero
 8211acc:	2c4b883a 	add	r5,r5,r17
 8211ad0:	2c63803a 	cmpltu	r17,r5,r17
 8211ad4:	4a11883a 	add	r8,r9,r8
 8211ad8:	8a11883a 	add	r8,r17,r8
 8211adc:	2823883a 	mov	r17,r5
 8211ae0:	4080202c 	andhi	r2,r8,128
 8211ae4:	103fe026 	beq	r2,zero,8211a68 <__adddf3+0x204>
 8211ae8:	84000044 	addi	r16,r16,1
 8211aec:	0081ffc4 	movi	r2,2047
 8211af0:	8080d226 	beq	r16,r2,8211e3c <__adddf3+0x5d8>
 8211af4:	00bfe034 	movhi	r2,65408
 8211af8:	10bfffc4 	addi	r2,r2,-1
 8211afc:	4090703a 	and	r8,r8,r2
 8211b00:	880ad07a 	srli	r5,r17,1
 8211b04:	400897fa 	slli	r4,r8,31
 8211b08:	88c0004c 	andi	r3,r17,1
 8211b0c:	28e2b03a 	or	r17,r5,r3
 8211b10:	4010d07a 	srli	r8,r8,1
 8211b14:	2462b03a 	or	r17,r4,r17
 8211b18:	003f7106 	br	82118e0 <__adddf3+0x7c>
 8211b1c:	4088b03a 	or	r4,r8,r2
 8211b20:	20014526 	beq	r4,zero,8212038 <__adddf3+0x7d4>
 8211b24:	01000434 	movhi	r4,16
 8211b28:	42000234 	orhi	r8,r8,8
 8211b2c:	213fffc4 	addi	r4,r4,-1
 8211b30:	4110703a 	and	r8,r8,r4
 8211b34:	003f8206 	br	8211940 <__adddf3+0xdc>
 8211b38:	18ffffc4 	addi	r3,r3,-1
 8211b3c:	1800491e 	bne	r3,zero,8211c64 <__adddf3+0x400>
 8211b40:	898bc83a 	sub	r5,r17,r6
 8211b44:	8963803a 	cmpltu	r17,r17,r5
 8211b48:	4251c83a 	sub	r8,r8,r9
 8211b4c:	4451c83a 	sub	r8,r8,r17
 8211b50:	2823883a 	mov	r17,r5
 8211b54:	003f9f06 	br	82119d4 <__adddf3+0x170>
 8211b58:	4984b03a 	or	r2,r9,r6
 8211b5c:	103f6026 	beq	r2,zero,82118e0 <__adddf3+0x7c>
 8211b60:	213fffc4 	addi	r4,r4,-1
 8211b64:	2000931e 	bne	r4,zero,8211db4 <__adddf3+0x550>
 8211b68:	898d883a 	add	r6,r17,r6
 8211b6c:	3463803a 	cmpltu	r17,r6,r17
 8211b70:	4251883a 	add	r8,r8,r9
 8211b74:	8a11883a 	add	r8,r17,r8
 8211b78:	3023883a 	mov	r17,r6
 8211b7c:	003fd806 	br	8211ae0 <__adddf3+0x27c>
 8211b80:	1800541e 	bne	r3,zero,8211cd4 <__adddf3+0x470>
 8211b84:	80800044 	addi	r2,r16,1
 8211b88:	1081ffcc 	andi	r2,r2,2047
 8211b8c:	00c00044 	movi	r3,1
 8211b90:	1880a00e 	bge	r3,r2,8211e14 <__adddf3+0x5b0>
 8211b94:	8989c83a 	sub	r4,r17,r6
 8211b98:	8905803a 	cmpltu	r2,r17,r4
 8211b9c:	4267c83a 	sub	r19,r8,r9
 8211ba0:	98a7c83a 	sub	r19,r19,r2
 8211ba4:	9880202c 	andhi	r2,r19,128
 8211ba8:	10006326 	beq	r2,zero,8211d38 <__adddf3+0x4d4>
 8211bac:	3463c83a 	sub	r17,r6,r17
 8211bb0:	4a07c83a 	sub	r3,r9,r8
 8211bb4:	344d803a 	cmpltu	r6,r6,r17
 8211bb8:	19a7c83a 	sub	r19,r3,r6
 8211bbc:	3825883a 	mov	r18,r7
 8211bc0:	983f8a1e 	bne	r19,zero,82119ec <__adddf3+0x188>
 8211bc4:	8809883a 	mov	r4,r17
 8211bc8:	8213e680 	call	8213e68 <__clzsi2>
 8211bcc:	10800804 	addi	r2,r2,32
 8211bd0:	10fffe04 	addi	r3,r2,-8
 8211bd4:	010007c4 	movi	r4,31
 8211bd8:	20ff890e 	bge	r4,r3,8211a00 <__adddf3+0x19c>
 8211bdc:	10bff604 	addi	r2,r2,-40
 8211be0:	8884983a 	sll	r2,r17,r2
 8211be4:	0023883a 	mov	r17,zero
 8211be8:	1c3f8c0e 	bge	r3,r16,8211a1c <__adddf3+0x1b8>
 8211bec:	023fe034 	movhi	r8,65408
 8211bf0:	423fffc4 	addi	r8,r8,-1
 8211bf4:	80e1c83a 	sub	r16,r16,r3
 8211bf8:	1210703a 	and	r8,r2,r8
 8211bfc:	003f3806 	br	82118e0 <__adddf3+0x7c>
 8211c00:	9007883a 	mov	r3,r18
 8211c04:	0011883a 	mov	r8,zero
 8211c08:	0005883a 	mov	r2,zero
 8211c0c:	003f4c06 	br	8211940 <__adddf3+0xdc>
 8211c10:	498cb03a 	or	r6,r9,r6
 8211c14:	300cc03a 	cmpne	r6,r6,zero
 8211c18:	0007883a 	mov	r3,zero
 8211c1c:	003f6806 	br	82119c0 <__adddf3+0x15c>
 8211c20:	20009c1e 	bne	r4,zero,8211e94 <__adddf3+0x630>
 8211c24:	80800044 	addi	r2,r16,1
 8211c28:	1141ffcc 	andi	r5,r2,2047
 8211c2c:	01000044 	movi	r4,1
 8211c30:	2140670e 	bge	r4,r5,8211dd0 <__adddf3+0x56c>
 8211c34:	0101ffc4 	movi	r4,2047
 8211c38:	11007f26 	beq	r2,r4,8211e38 <__adddf3+0x5d4>
 8211c3c:	898d883a 	add	r6,r17,r6
 8211c40:	4247883a 	add	r3,r8,r9
 8211c44:	3451803a 	cmpltu	r8,r6,r17
 8211c48:	40d1883a 	add	r8,r8,r3
 8211c4c:	402297fa 	slli	r17,r8,31
 8211c50:	300cd07a 	srli	r6,r6,1
 8211c54:	4010d07a 	srli	r8,r8,1
 8211c58:	1021883a 	mov	r16,r2
 8211c5c:	89a2b03a 	or	r17,r17,r6
 8211c60:	003f1f06 	br	82118e0 <__adddf3+0x7c>
 8211c64:	0081ffc4 	movi	r2,2047
 8211c68:	80bf481e 	bne	r16,r2,821198c <__adddf3+0x128>
 8211c6c:	003f1c06 	br	82118e0 <__adddf3+0x7c>
 8211c70:	843ff844 	addi	r16,r16,-31
 8211c74:	01000804 	movi	r4,32
 8211c78:	1406d83a 	srl	r3,r2,r16
 8211c7c:	41005026 	beq	r8,r4,8211dc0 <__adddf3+0x55c>
 8211c80:	01001004 	movi	r4,64
 8211c84:	2211c83a 	sub	r8,r4,r8
 8211c88:	1204983a 	sll	r2,r2,r8
 8211c8c:	88a2b03a 	or	r17,r17,r2
 8211c90:	8822c03a 	cmpne	r17,r17,zero
 8211c94:	1c62b03a 	or	r17,r3,r17
 8211c98:	0011883a 	mov	r8,zero
 8211c9c:	0021883a 	mov	r16,zero
 8211ca0:	003f7106 	br	8211a68 <__adddf3+0x204>
 8211ca4:	193ff804 	addi	r4,r3,-32
 8211ca8:	00800804 	movi	r2,32
 8211cac:	4908d83a 	srl	r4,r9,r4
 8211cb0:	18804526 	beq	r3,r2,8211dc8 <__adddf3+0x564>
 8211cb4:	00801004 	movi	r2,64
 8211cb8:	10c5c83a 	sub	r2,r2,r3
 8211cbc:	4886983a 	sll	r3,r9,r2
 8211cc0:	198cb03a 	or	r6,r3,r6
 8211cc4:	300cc03a 	cmpne	r6,r6,zero
 8211cc8:	218cb03a 	or	r6,r4,r6
 8211ccc:	0007883a 	mov	r3,zero
 8211cd0:	003f3b06 	br	82119c0 <__adddf3+0x15c>
 8211cd4:	80002a26 	beq	r16,zero,8211d80 <__adddf3+0x51c>
 8211cd8:	0101ffc4 	movi	r4,2047
 8211cdc:	11006826 	beq	r2,r4,8211e80 <__adddf3+0x61c>
 8211ce0:	00c7c83a 	sub	r3,zero,r3
 8211ce4:	42002034 	orhi	r8,r8,128
 8211ce8:	01000e04 	movi	r4,56
 8211cec:	20c07c16 	blt	r4,r3,8211ee0 <__adddf3+0x67c>
 8211cf0:	010007c4 	movi	r4,31
 8211cf4:	20c0da16 	blt	r4,r3,8212060 <__adddf3+0x7fc>
 8211cf8:	01000804 	movi	r4,32
 8211cfc:	20c9c83a 	sub	r4,r4,r3
 8211d00:	4114983a 	sll	r10,r8,r4
 8211d04:	88cad83a 	srl	r5,r17,r3
 8211d08:	8908983a 	sll	r4,r17,r4
 8211d0c:	40c6d83a 	srl	r3,r8,r3
 8211d10:	5162b03a 	or	r17,r10,r5
 8211d14:	2008c03a 	cmpne	r4,r4,zero
 8211d18:	8922b03a 	or	r17,r17,r4
 8211d1c:	3463c83a 	sub	r17,r6,r17
 8211d20:	48c7c83a 	sub	r3,r9,r3
 8211d24:	344d803a 	cmpltu	r6,r6,r17
 8211d28:	1991c83a 	sub	r8,r3,r6
 8211d2c:	1021883a 	mov	r16,r2
 8211d30:	3825883a 	mov	r18,r7
 8211d34:	003f2706 	br	82119d4 <__adddf3+0x170>
 8211d38:	24d0b03a 	or	r8,r4,r19
 8211d3c:	40001b1e 	bne	r8,zero,8211dac <__adddf3+0x548>
 8211d40:	0005883a 	mov	r2,zero
 8211d44:	0007883a 	mov	r3,zero
 8211d48:	0021883a 	mov	r16,zero
 8211d4c:	003f4d06 	br	8211a84 <__adddf3+0x220>
 8211d50:	008007c4 	movi	r2,31
 8211d54:	11003c16 	blt	r2,r4,8211e48 <__adddf3+0x5e4>
 8211d58:	00800804 	movi	r2,32
 8211d5c:	1105c83a 	sub	r2,r2,r4
 8211d60:	488e983a 	sll	r7,r9,r2
 8211d64:	310ad83a 	srl	r5,r6,r4
 8211d68:	3084983a 	sll	r2,r6,r2
 8211d6c:	4912d83a 	srl	r9,r9,r4
 8211d70:	394ab03a 	or	r5,r7,r5
 8211d74:	1004c03a 	cmpne	r2,r2,zero
 8211d78:	288ab03a 	or	r5,r5,r2
 8211d7c:	003f5306 	br	8211acc <__adddf3+0x268>
 8211d80:	4448b03a 	or	r4,r8,r17
 8211d84:	20003e26 	beq	r4,zero,8211e80 <__adddf3+0x61c>
 8211d88:	00c6303a 	nor	r3,zero,r3
 8211d8c:	18003a1e 	bne	r3,zero,8211e78 <__adddf3+0x614>
 8211d90:	3463c83a 	sub	r17,r6,r17
 8211d94:	4a07c83a 	sub	r3,r9,r8
 8211d98:	344d803a 	cmpltu	r6,r6,r17
 8211d9c:	1991c83a 	sub	r8,r3,r6
 8211da0:	1021883a 	mov	r16,r2
 8211da4:	3825883a 	mov	r18,r7
 8211da8:	003f0a06 	br	82119d4 <__adddf3+0x170>
 8211dac:	2023883a 	mov	r17,r4
 8211db0:	003f0d06 	br	82119e8 <__adddf3+0x184>
 8211db4:	0081ffc4 	movi	r2,2047
 8211db8:	80bf3f1e 	bne	r16,r2,8211ab8 <__adddf3+0x254>
 8211dbc:	003ec806 	br	82118e0 <__adddf3+0x7c>
 8211dc0:	0005883a 	mov	r2,zero
 8211dc4:	003fb106 	br	8211c8c <__adddf3+0x428>
 8211dc8:	0007883a 	mov	r3,zero
 8211dcc:	003fbc06 	br	8211cc0 <__adddf3+0x45c>
 8211dd0:	4444b03a 	or	r2,r8,r17
 8211dd4:	8000871e 	bne	r16,zero,8211ff4 <__adddf3+0x790>
 8211dd8:	1000ba26 	beq	r2,zero,82120c4 <__adddf3+0x860>
 8211ddc:	4984b03a 	or	r2,r9,r6
 8211de0:	103ebf26 	beq	r2,zero,82118e0 <__adddf3+0x7c>
 8211de4:	8985883a 	add	r2,r17,r6
 8211de8:	4247883a 	add	r3,r8,r9
 8211dec:	1451803a 	cmpltu	r8,r2,r17
 8211df0:	40d1883a 	add	r8,r8,r3
 8211df4:	40c0202c 	andhi	r3,r8,128
 8211df8:	1023883a 	mov	r17,r2
 8211dfc:	183f1a26 	beq	r3,zero,8211a68 <__adddf3+0x204>
 8211e00:	00bfe034 	movhi	r2,65408
 8211e04:	10bfffc4 	addi	r2,r2,-1
 8211e08:	2021883a 	mov	r16,r4
 8211e0c:	4090703a 	and	r8,r8,r2
 8211e10:	003eb306 	br	82118e0 <__adddf3+0x7c>
 8211e14:	4444b03a 	or	r2,r8,r17
 8211e18:	8000291e 	bne	r16,zero,8211ec0 <__adddf3+0x65c>
 8211e1c:	10004b1e 	bne	r2,zero,8211f4c <__adddf3+0x6e8>
 8211e20:	4990b03a 	or	r8,r9,r6
 8211e24:	40008b26 	beq	r8,zero,8212054 <__adddf3+0x7f0>
 8211e28:	4811883a 	mov	r8,r9
 8211e2c:	3023883a 	mov	r17,r6
 8211e30:	3825883a 	mov	r18,r7
 8211e34:	003eaa06 	br	82118e0 <__adddf3+0x7c>
 8211e38:	1021883a 	mov	r16,r2
 8211e3c:	0011883a 	mov	r8,zero
 8211e40:	0005883a 	mov	r2,zero
 8211e44:	003f0f06 	br	8211a84 <__adddf3+0x220>
 8211e48:	217ff804 	addi	r5,r4,-32
 8211e4c:	00800804 	movi	r2,32
 8211e50:	494ad83a 	srl	r5,r9,r5
 8211e54:	20807d26 	beq	r4,r2,821204c <__adddf3+0x7e8>
 8211e58:	00801004 	movi	r2,64
 8211e5c:	1109c83a 	sub	r4,r2,r4
 8211e60:	4912983a 	sll	r9,r9,r4
 8211e64:	498cb03a 	or	r6,r9,r6
 8211e68:	300cc03a 	cmpne	r6,r6,zero
 8211e6c:	298ab03a 	or	r5,r5,r6
 8211e70:	0013883a 	mov	r9,zero
 8211e74:	003f1506 	br	8211acc <__adddf3+0x268>
 8211e78:	0101ffc4 	movi	r4,2047
 8211e7c:	113f9a1e 	bne	r2,r4,8211ce8 <__adddf3+0x484>
 8211e80:	4811883a 	mov	r8,r9
 8211e84:	3023883a 	mov	r17,r6
 8211e88:	1021883a 	mov	r16,r2
 8211e8c:	3825883a 	mov	r18,r7
 8211e90:	003e9306 	br	82118e0 <__adddf3+0x7c>
 8211e94:	8000161e 	bne	r16,zero,8211ef0 <__adddf3+0x68c>
 8211e98:	444ab03a 	or	r5,r8,r17
 8211e9c:	28005126 	beq	r5,zero,8211fe4 <__adddf3+0x780>
 8211ea0:	0108303a 	nor	r4,zero,r4
 8211ea4:	20004d1e 	bne	r4,zero,8211fdc <__adddf3+0x778>
 8211ea8:	89a3883a 	add	r17,r17,r6
 8211eac:	4253883a 	add	r9,r8,r9
 8211eb0:	898d803a 	cmpltu	r6,r17,r6
 8211eb4:	3251883a 	add	r8,r6,r9
 8211eb8:	1021883a 	mov	r16,r2
 8211ebc:	003f0806 	br	8211ae0 <__adddf3+0x27c>
 8211ec0:	1000301e 	bne	r2,zero,8211f84 <__adddf3+0x720>
 8211ec4:	4984b03a 	or	r2,r9,r6
 8211ec8:	10007126 	beq	r2,zero,8212090 <__adddf3+0x82c>
 8211ecc:	4811883a 	mov	r8,r9
 8211ed0:	3023883a 	mov	r17,r6
 8211ed4:	3825883a 	mov	r18,r7
 8211ed8:	0401ffc4 	movi	r16,2047
 8211edc:	003e8006 	br	82118e0 <__adddf3+0x7c>
 8211ee0:	4462b03a 	or	r17,r8,r17
 8211ee4:	8822c03a 	cmpne	r17,r17,zero
 8211ee8:	0007883a 	mov	r3,zero
 8211eec:	003f8b06 	br	8211d1c <__adddf3+0x4b8>
 8211ef0:	0141ffc4 	movi	r5,2047
 8211ef4:	11403b26 	beq	r2,r5,8211fe4 <__adddf3+0x780>
 8211ef8:	0109c83a 	sub	r4,zero,r4
 8211efc:	42002034 	orhi	r8,r8,128
 8211f00:	01400e04 	movi	r5,56
 8211f04:	29006716 	blt	r5,r4,82120a4 <__adddf3+0x840>
 8211f08:	014007c4 	movi	r5,31
 8211f0c:	29007016 	blt	r5,r4,82120d0 <__adddf3+0x86c>
 8211f10:	01400804 	movi	r5,32
 8211f14:	290bc83a 	sub	r5,r5,r4
 8211f18:	4154983a 	sll	r10,r8,r5
 8211f1c:	890ed83a 	srl	r7,r17,r4
 8211f20:	894a983a 	sll	r5,r17,r5
 8211f24:	4108d83a 	srl	r4,r8,r4
 8211f28:	51e2b03a 	or	r17,r10,r7
 8211f2c:	280ac03a 	cmpne	r5,r5,zero
 8211f30:	8962b03a 	or	r17,r17,r5
 8211f34:	89a3883a 	add	r17,r17,r6
 8211f38:	2253883a 	add	r9,r4,r9
 8211f3c:	898d803a 	cmpltu	r6,r17,r6
 8211f40:	3251883a 	add	r8,r6,r9
 8211f44:	1021883a 	mov	r16,r2
 8211f48:	003ee506 	br	8211ae0 <__adddf3+0x27c>
 8211f4c:	4984b03a 	or	r2,r9,r6
 8211f50:	103e6326 	beq	r2,zero,82118e0 <__adddf3+0x7c>
 8211f54:	8987c83a 	sub	r3,r17,r6
 8211f58:	88c9803a 	cmpltu	r4,r17,r3
 8211f5c:	4245c83a 	sub	r2,r8,r9
 8211f60:	1105c83a 	sub	r2,r2,r4
 8211f64:	1100202c 	andhi	r4,r2,128
 8211f68:	203ebb26 	beq	r4,zero,8211a58 <__adddf3+0x1f4>
 8211f6c:	3463c83a 	sub	r17,r6,r17
 8211f70:	4a07c83a 	sub	r3,r9,r8
 8211f74:	344d803a 	cmpltu	r6,r6,r17
 8211f78:	1991c83a 	sub	r8,r3,r6
 8211f7c:	3825883a 	mov	r18,r7
 8211f80:	003e5706 	br	82118e0 <__adddf3+0x7c>
 8211f84:	4984b03a 	or	r2,r9,r6
 8211f88:	10002e26 	beq	r2,zero,8212044 <__adddf3+0x7e0>
 8211f8c:	4004d0fa 	srli	r2,r8,3
 8211f90:	8822d0fa 	srli	r17,r17,3
 8211f94:	4010977a 	slli	r8,r8,29
 8211f98:	10c0022c 	andhi	r3,r2,8
 8211f9c:	4462b03a 	or	r17,r8,r17
 8211fa0:	18000826 	beq	r3,zero,8211fc4 <__adddf3+0x760>
 8211fa4:	4808d0fa 	srli	r4,r9,3
 8211fa8:	20c0022c 	andhi	r3,r4,8
 8211fac:	1800051e 	bne	r3,zero,8211fc4 <__adddf3+0x760>
 8211fb0:	300cd0fa 	srli	r6,r6,3
 8211fb4:	4806977a 	slli	r3,r9,29
 8211fb8:	2005883a 	mov	r2,r4
 8211fbc:	3825883a 	mov	r18,r7
 8211fc0:	19a2b03a 	or	r17,r3,r6
 8211fc4:	8810d77a 	srli	r8,r17,29
 8211fc8:	100490fa 	slli	r2,r2,3
 8211fcc:	882290fa 	slli	r17,r17,3
 8211fd0:	0401ffc4 	movi	r16,2047
 8211fd4:	4090b03a 	or	r8,r8,r2
 8211fd8:	003e4106 	br	82118e0 <__adddf3+0x7c>
 8211fdc:	0141ffc4 	movi	r5,2047
 8211fe0:	117fc71e 	bne	r2,r5,8211f00 <__adddf3+0x69c>
 8211fe4:	4811883a 	mov	r8,r9
 8211fe8:	3023883a 	mov	r17,r6
 8211fec:	1021883a 	mov	r16,r2
 8211ff0:	003e3b06 	br	82118e0 <__adddf3+0x7c>
 8211ff4:	10002f26 	beq	r2,zero,82120b4 <__adddf3+0x850>
 8211ff8:	4984b03a 	or	r2,r9,r6
 8211ffc:	10001126 	beq	r2,zero,8212044 <__adddf3+0x7e0>
 8212000:	4004d0fa 	srli	r2,r8,3
 8212004:	8822d0fa 	srli	r17,r17,3
 8212008:	4010977a 	slli	r8,r8,29
 821200c:	10c0022c 	andhi	r3,r2,8
 8212010:	4462b03a 	or	r17,r8,r17
 8212014:	183feb26 	beq	r3,zero,8211fc4 <__adddf3+0x760>
 8212018:	4808d0fa 	srli	r4,r9,3
 821201c:	20c0022c 	andhi	r3,r4,8
 8212020:	183fe81e 	bne	r3,zero,8211fc4 <__adddf3+0x760>
 8212024:	300cd0fa 	srli	r6,r6,3
 8212028:	4806977a 	slli	r3,r9,29
 821202c:	2005883a 	mov	r2,r4
 8212030:	19a2b03a 	or	r17,r3,r6
 8212034:	003fe306 	br	8211fc4 <__adddf3+0x760>
 8212038:	0011883a 	mov	r8,zero
 821203c:	0005883a 	mov	r2,zero
 8212040:	003e3f06 	br	8211940 <__adddf3+0xdc>
 8212044:	0401ffc4 	movi	r16,2047
 8212048:	003e2506 	br	82118e0 <__adddf3+0x7c>
 821204c:	0013883a 	mov	r9,zero
 8212050:	003f8406 	br	8211e64 <__adddf3+0x600>
 8212054:	0005883a 	mov	r2,zero
 8212058:	0007883a 	mov	r3,zero
 821205c:	003e8906 	br	8211a84 <__adddf3+0x220>
 8212060:	197ff804 	addi	r5,r3,-32
 8212064:	01000804 	movi	r4,32
 8212068:	414ad83a 	srl	r5,r8,r5
 821206c:	19002426 	beq	r3,r4,8212100 <__adddf3+0x89c>
 8212070:	01001004 	movi	r4,64
 8212074:	20c7c83a 	sub	r3,r4,r3
 8212078:	40c6983a 	sll	r3,r8,r3
 821207c:	1c46b03a 	or	r3,r3,r17
 8212080:	1806c03a 	cmpne	r3,r3,zero
 8212084:	28e2b03a 	or	r17,r5,r3
 8212088:	0007883a 	mov	r3,zero
 821208c:	003f2306 	br	8211d1c <__adddf3+0x4b8>
 8212090:	0007883a 	mov	r3,zero
 8212094:	5811883a 	mov	r8,r11
 8212098:	00bfffc4 	movi	r2,-1
 821209c:	0401ffc4 	movi	r16,2047
 82120a0:	003e7806 	br	8211a84 <__adddf3+0x220>
 82120a4:	4462b03a 	or	r17,r8,r17
 82120a8:	8822c03a 	cmpne	r17,r17,zero
 82120ac:	0009883a 	mov	r4,zero
 82120b0:	003fa006 	br	8211f34 <__adddf3+0x6d0>
 82120b4:	4811883a 	mov	r8,r9
 82120b8:	3023883a 	mov	r17,r6
 82120bc:	0401ffc4 	movi	r16,2047
 82120c0:	003e0706 	br	82118e0 <__adddf3+0x7c>
 82120c4:	4811883a 	mov	r8,r9
 82120c8:	3023883a 	mov	r17,r6
 82120cc:	003e0406 	br	82118e0 <__adddf3+0x7c>
 82120d0:	21fff804 	addi	r7,r4,-32
 82120d4:	01400804 	movi	r5,32
 82120d8:	41ced83a 	srl	r7,r8,r7
 82120dc:	21400a26 	beq	r4,r5,8212108 <__adddf3+0x8a4>
 82120e0:	01401004 	movi	r5,64
 82120e4:	2909c83a 	sub	r4,r5,r4
 82120e8:	4108983a 	sll	r4,r8,r4
 82120ec:	2448b03a 	or	r4,r4,r17
 82120f0:	2008c03a 	cmpne	r4,r4,zero
 82120f4:	3922b03a 	or	r17,r7,r4
 82120f8:	0009883a 	mov	r4,zero
 82120fc:	003f8d06 	br	8211f34 <__adddf3+0x6d0>
 8212100:	0007883a 	mov	r3,zero
 8212104:	003fdd06 	br	821207c <__adddf3+0x818>
 8212108:	0009883a 	mov	r4,zero
 821210c:	003ff706 	br	82120ec <__adddf3+0x888>

08212110 <__divdf3>:
 8212110:	defff204 	addi	sp,sp,-56
 8212114:	dd400915 	stw	r21,36(sp)
 8212118:	282ad53a 	srli	r21,r5,20
 821211c:	dd000815 	stw	r20,32(sp)
 8212120:	2828d7fa 	srli	r20,r5,31
 8212124:	dc000415 	stw	r16,16(sp)
 8212128:	04000434 	movhi	r16,16
 821212c:	df000c15 	stw	fp,48(sp)
 8212130:	843fffc4 	addi	r16,r16,-1
 8212134:	dfc00d15 	stw	ra,52(sp)
 8212138:	ddc00b15 	stw	r23,44(sp)
 821213c:	dd800a15 	stw	r22,40(sp)
 8212140:	dcc00715 	stw	r19,28(sp)
 8212144:	dc800615 	stw	r18,24(sp)
 8212148:	dc400515 	stw	r17,20(sp)
 821214c:	ad41ffcc 	andi	r21,r21,2047
 8212150:	2c20703a 	and	r16,r5,r16
 8212154:	a7003fcc 	andi	fp,r20,255
 8212158:	a8006126 	beq	r21,zero,82122e0 <__divdf3+0x1d0>
 821215c:	0081ffc4 	movi	r2,2047
 8212160:	2025883a 	mov	r18,r4
 8212164:	a8803726 	beq	r21,r2,8212244 <__divdf3+0x134>
 8212168:	80800434 	orhi	r2,r16,16
 821216c:	100490fa 	slli	r2,r2,3
 8212170:	2020d77a 	srli	r16,r4,29
 8212174:	202490fa 	slli	r18,r4,3
 8212178:	ad7f0044 	addi	r21,r21,-1023
 821217c:	80a0b03a 	or	r16,r16,r2
 8212180:	0027883a 	mov	r19,zero
 8212184:	0013883a 	mov	r9,zero
 8212188:	3804d53a 	srli	r2,r7,20
 821218c:	382cd7fa 	srli	r22,r7,31
 8212190:	04400434 	movhi	r17,16
 8212194:	8c7fffc4 	addi	r17,r17,-1
 8212198:	1081ffcc 	andi	r2,r2,2047
 821219c:	3011883a 	mov	r8,r6
 82121a0:	3c62703a 	and	r17,r7,r17
 82121a4:	b5c03fcc 	andi	r23,r22,255
 82121a8:	10006c26 	beq	r2,zero,821235c <__divdf3+0x24c>
 82121ac:	00c1ffc4 	movi	r3,2047
 82121b0:	10c06426 	beq	r2,r3,8212344 <__divdf3+0x234>
 82121b4:	88c00434 	orhi	r3,r17,16
 82121b8:	180690fa 	slli	r3,r3,3
 82121bc:	3022d77a 	srli	r17,r6,29
 82121c0:	301090fa 	slli	r8,r6,3
 82121c4:	10bf0044 	addi	r2,r2,-1023
 82121c8:	88e2b03a 	or	r17,r17,r3
 82121cc:	000f883a 	mov	r7,zero
 82121d0:	a58cf03a 	xor	r6,r20,r22
 82121d4:	3cc8b03a 	or	r4,r7,r19
 82121d8:	a8abc83a 	sub	r21,r21,r2
 82121dc:	008003c4 	movi	r2,15
 82121e0:	3007883a 	mov	r3,r6
 82121e4:	34c03fcc 	andi	r19,r6,255
 82121e8:	11009036 	bltu	r2,r4,821242c <__divdf3+0x31c>
 82121ec:	200890ba 	slli	r4,r4,2
 82121f0:	00820874 	movhi	r2,2081
 82121f4:	10888104 	addi	r2,r2,8708
 82121f8:	2089883a 	add	r4,r4,r2
 82121fc:	20800017 	ldw	r2,0(r4)
 8212200:	1000683a 	jmp	r2
 8212204:	0821242c 	andhi	zero,at,33936
 8212208:	0821227c 	xorhi	zero,at,33929
 821220c:	0821241c 	xori	zero,at,33936
 8212210:	08212270 	cmpltui	zero,at,33929
 8212214:	0821241c 	xori	zero,at,33936
 8212218:	082123f0 	cmpltui	zero,at,33935
 821221c:	0821241c 	xori	zero,at,33936
 8212220:	08212270 	cmpltui	zero,at,33929
 8212224:	0821227c 	xorhi	zero,at,33929
 8212228:	0821227c 	xorhi	zero,at,33929
 821222c:	082123f0 	cmpltui	zero,at,33935
 8212230:	08212270 	cmpltui	zero,at,33929
 8212234:	08212260 	cmpeqi	zero,at,-31607
 8212238:	08212260 	cmpeqi	zero,at,-31607
 821223c:	08212260 	cmpeqi	zero,at,-31607
 8212240:	08212710 	cmplti	zero,at,-31588
 8212244:	2404b03a 	or	r2,r4,r16
 8212248:	1000661e 	bne	r2,zero,82123e4 <__divdf3+0x2d4>
 821224c:	04c00204 	movi	r19,8
 8212250:	0021883a 	mov	r16,zero
 8212254:	0025883a 	mov	r18,zero
 8212258:	02400084 	movi	r9,2
 821225c:	003fca06 	br	8212188 <__divdf3+0x78>
 8212260:	8023883a 	mov	r17,r16
 8212264:	9011883a 	mov	r8,r18
 8212268:	e02f883a 	mov	r23,fp
 821226c:	480f883a 	mov	r7,r9
 8212270:	00800084 	movi	r2,2
 8212274:	3881311e 	bne	r7,r2,821273c <__divdf3+0x62c>
 8212278:	b827883a 	mov	r19,r23
 821227c:	98c0004c 	andi	r3,r19,1
 8212280:	0081ffc4 	movi	r2,2047
 8212284:	000b883a 	mov	r5,zero
 8212288:	0025883a 	mov	r18,zero
 821228c:	1004953a 	slli	r2,r2,20
 8212290:	18c03fcc 	andi	r3,r3,255
 8212294:	04400434 	movhi	r17,16
 8212298:	8c7fffc4 	addi	r17,r17,-1
 821229c:	180697fa 	slli	r3,r3,31
 82122a0:	2c4a703a 	and	r5,r5,r17
 82122a4:	288ab03a 	or	r5,r5,r2
 82122a8:	28c6b03a 	or	r3,r5,r3
 82122ac:	9005883a 	mov	r2,r18
 82122b0:	dfc00d17 	ldw	ra,52(sp)
 82122b4:	df000c17 	ldw	fp,48(sp)
 82122b8:	ddc00b17 	ldw	r23,44(sp)
 82122bc:	dd800a17 	ldw	r22,40(sp)
 82122c0:	dd400917 	ldw	r21,36(sp)
 82122c4:	dd000817 	ldw	r20,32(sp)
 82122c8:	dcc00717 	ldw	r19,28(sp)
 82122cc:	dc800617 	ldw	r18,24(sp)
 82122d0:	dc400517 	ldw	r17,20(sp)
 82122d4:	dc000417 	ldw	r16,16(sp)
 82122d8:	dec00e04 	addi	sp,sp,56
 82122dc:	f800283a 	ret
 82122e0:	2404b03a 	or	r2,r4,r16
 82122e4:	2027883a 	mov	r19,r4
 82122e8:	10003926 	beq	r2,zero,82123d0 <__divdf3+0x2c0>
 82122ec:	80012e26 	beq	r16,zero,82127a8 <__divdf3+0x698>
 82122f0:	8009883a 	mov	r4,r16
 82122f4:	d9800315 	stw	r6,12(sp)
 82122f8:	d9c00215 	stw	r7,8(sp)
 82122fc:	8213e680 	call	8213e68 <__clzsi2>
 8212300:	d9800317 	ldw	r6,12(sp)
 8212304:	d9c00217 	ldw	r7,8(sp)
 8212308:	113ffd44 	addi	r4,r2,-11
 821230c:	00c00704 	movi	r3,28
 8212310:	19012116 	blt	r3,r4,8212798 <__divdf3+0x688>
 8212314:	00c00744 	movi	r3,29
 8212318:	147ffe04 	addi	r17,r2,-8
 821231c:	1907c83a 	sub	r3,r3,r4
 8212320:	8460983a 	sll	r16,r16,r17
 8212324:	98c6d83a 	srl	r3,r19,r3
 8212328:	9c64983a 	sll	r18,r19,r17
 821232c:	1c20b03a 	or	r16,r3,r16
 8212330:	1080fcc4 	addi	r2,r2,1011
 8212334:	00abc83a 	sub	r21,zero,r2
 8212338:	0027883a 	mov	r19,zero
 821233c:	0013883a 	mov	r9,zero
 8212340:	003f9106 	br	8212188 <__divdf3+0x78>
 8212344:	3446b03a 	or	r3,r6,r17
 8212348:	18001f1e 	bne	r3,zero,82123c8 <__divdf3+0x2b8>
 821234c:	0023883a 	mov	r17,zero
 8212350:	0011883a 	mov	r8,zero
 8212354:	01c00084 	movi	r7,2
 8212358:	003f9d06 	br	82121d0 <__divdf3+0xc0>
 821235c:	3446b03a 	or	r3,r6,r17
 8212360:	18001526 	beq	r3,zero,82123b8 <__divdf3+0x2a8>
 8212364:	88011b26 	beq	r17,zero,82127d4 <__divdf3+0x6c4>
 8212368:	8809883a 	mov	r4,r17
 821236c:	d9800315 	stw	r6,12(sp)
 8212370:	da400115 	stw	r9,4(sp)
 8212374:	8213e680 	call	8213e68 <__clzsi2>
 8212378:	d9800317 	ldw	r6,12(sp)
 821237c:	da400117 	ldw	r9,4(sp)
 8212380:	113ffd44 	addi	r4,r2,-11
 8212384:	00c00704 	movi	r3,28
 8212388:	19010e16 	blt	r3,r4,82127c4 <__divdf3+0x6b4>
 821238c:	00c00744 	movi	r3,29
 8212390:	123ffe04 	addi	r8,r2,-8
 8212394:	1907c83a 	sub	r3,r3,r4
 8212398:	8a22983a 	sll	r17,r17,r8
 821239c:	30c6d83a 	srl	r3,r6,r3
 82123a0:	3210983a 	sll	r8,r6,r8
 82123a4:	1c62b03a 	or	r17,r3,r17
 82123a8:	1080fcc4 	addi	r2,r2,1011
 82123ac:	0085c83a 	sub	r2,zero,r2
 82123b0:	000f883a 	mov	r7,zero
 82123b4:	003f8606 	br	82121d0 <__divdf3+0xc0>
 82123b8:	0023883a 	mov	r17,zero
 82123bc:	0011883a 	mov	r8,zero
 82123c0:	01c00044 	movi	r7,1
 82123c4:	003f8206 	br	82121d0 <__divdf3+0xc0>
 82123c8:	01c000c4 	movi	r7,3
 82123cc:	003f8006 	br	82121d0 <__divdf3+0xc0>
 82123d0:	04c00104 	movi	r19,4
 82123d4:	0021883a 	mov	r16,zero
 82123d8:	0025883a 	mov	r18,zero
 82123dc:	02400044 	movi	r9,1
 82123e0:	003f6906 	br	8212188 <__divdf3+0x78>
 82123e4:	04c00304 	movi	r19,12
 82123e8:	024000c4 	movi	r9,3
 82123ec:	003f6606 	br	8212188 <__divdf3+0x78>
 82123f0:	01400434 	movhi	r5,16
 82123f4:	0007883a 	mov	r3,zero
 82123f8:	297fffc4 	addi	r5,r5,-1
 82123fc:	04bfffc4 	movi	r18,-1
 8212400:	0081ffc4 	movi	r2,2047
 8212404:	003fa106 	br	821228c <__divdf3+0x17c>
 8212408:	00c00044 	movi	r3,1
 821240c:	1887c83a 	sub	r3,r3,r2
 8212410:	01000e04 	movi	r4,56
 8212414:	20c1210e 	bge	r4,r3,821289c <__divdf3+0x78c>
 8212418:	98c0004c 	andi	r3,r19,1
 821241c:	0005883a 	mov	r2,zero
 8212420:	000b883a 	mov	r5,zero
 8212424:	0025883a 	mov	r18,zero
 8212428:	003f9806 	br	821228c <__divdf3+0x17c>
 821242c:	8c00fd36 	bltu	r17,r16,8212824 <__divdf3+0x714>
 8212430:	8440fb26 	beq	r16,r17,8212820 <__divdf3+0x710>
 8212434:	8007883a 	mov	r3,r16
 8212438:	ad7fffc4 	addi	r21,r21,-1
 821243c:	0021883a 	mov	r16,zero
 8212440:	4004d63a 	srli	r2,r8,24
 8212444:	8822923a 	slli	r17,r17,8
 8212448:	1809883a 	mov	r4,r3
 821244c:	402c923a 	slli	r22,r8,8
 8212450:	88b8b03a 	or	fp,r17,r2
 8212454:	e028d43a 	srli	r20,fp,16
 8212458:	d8c00015 	stw	r3,0(sp)
 821245c:	e5ffffcc 	andi	r23,fp,65535
 8212460:	a00b883a 	mov	r5,r20
 8212464:	820270c0 	call	820270c <__udivsi3>
 8212468:	d8c00017 	ldw	r3,0(sp)
 821246c:	a00b883a 	mov	r5,r20
 8212470:	d8800315 	stw	r2,12(sp)
 8212474:	1809883a 	mov	r4,r3
 8212478:	82027700 	call	8202770 <__umodsi3>
 821247c:	d9800317 	ldw	r6,12(sp)
 8212480:	1006943a 	slli	r3,r2,16
 8212484:	9004d43a 	srli	r2,r18,16
 8212488:	b9a3383a 	mul	r17,r23,r6
 821248c:	10c4b03a 	or	r2,r2,r3
 8212490:	1440062e 	bgeu	r2,r17,82124ac <__divdf3+0x39c>
 8212494:	1705883a 	add	r2,r2,fp
 8212498:	30ffffc4 	addi	r3,r6,-1
 821249c:	1700ee36 	bltu	r2,fp,8212858 <__divdf3+0x748>
 82124a0:	1440ed2e 	bgeu	r2,r17,8212858 <__divdf3+0x748>
 82124a4:	31bfff84 	addi	r6,r6,-2
 82124a8:	1705883a 	add	r2,r2,fp
 82124ac:	1463c83a 	sub	r17,r2,r17
 82124b0:	a00b883a 	mov	r5,r20
 82124b4:	8809883a 	mov	r4,r17
 82124b8:	d9800315 	stw	r6,12(sp)
 82124bc:	820270c0 	call	820270c <__udivsi3>
 82124c0:	a00b883a 	mov	r5,r20
 82124c4:	8809883a 	mov	r4,r17
 82124c8:	d8800215 	stw	r2,8(sp)
 82124cc:	82027700 	call	8202770 <__umodsi3>
 82124d0:	d9c00217 	ldw	r7,8(sp)
 82124d4:	1004943a 	slli	r2,r2,16
 82124d8:	94bfffcc 	andi	r18,r18,65535
 82124dc:	b9d1383a 	mul	r8,r23,r7
 82124e0:	90a4b03a 	or	r18,r18,r2
 82124e4:	d9800317 	ldw	r6,12(sp)
 82124e8:	9200062e 	bgeu	r18,r8,8212504 <__divdf3+0x3f4>
 82124ec:	9725883a 	add	r18,r18,fp
 82124f0:	38bfffc4 	addi	r2,r7,-1
 82124f4:	9700d636 	bltu	r18,fp,8212850 <__divdf3+0x740>
 82124f8:	9200d52e 	bgeu	r18,r8,8212850 <__divdf3+0x740>
 82124fc:	39ffff84 	addi	r7,r7,-2
 8212500:	9725883a 	add	r18,r18,fp
 8212504:	3004943a 	slli	r2,r6,16
 8212508:	b012d43a 	srli	r9,r22,16
 821250c:	b1bfffcc 	andi	r6,r22,65535
 8212510:	11e2b03a 	or	r17,r2,r7
 8212514:	8806d43a 	srli	r3,r17,16
 8212518:	893fffcc 	andi	r4,r17,65535
 821251c:	218b383a 	mul	r5,r4,r6
 8212520:	30c5383a 	mul	r2,r6,r3
 8212524:	2249383a 	mul	r4,r4,r9
 8212528:	280ed43a 	srli	r7,r5,16
 821252c:	9225c83a 	sub	r18,r18,r8
 8212530:	2089883a 	add	r4,r4,r2
 8212534:	3909883a 	add	r4,r7,r4
 8212538:	1a47383a 	mul	r3,r3,r9
 821253c:	2080022e 	bgeu	r4,r2,8212548 <__divdf3+0x438>
 8212540:	00800074 	movhi	r2,1
 8212544:	1887883a 	add	r3,r3,r2
 8212548:	2004d43a 	srli	r2,r4,16
 821254c:	2008943a 	slli	r4,r4,16
 8212550:	297fffcc 	andi	r5,r5,65535
 8212554:	10c7883a 	add	r3,r2,r3
 8212558:	2149883a 	add	r4,r4,r5
 821255c:	90c0a536 	bltu	r18,r3,82127f4 <__divdf3+0x6e4>
 8212560:	90c0bf26 	beq	r18,r3,8212860 <__divdf3+0x750>
 8212564:	90c7c83a 	sub	r3,r18,r3
 8212568:	810fc83a 	sub	r7,r16,r4
 821256c:	81e5803a 	cmpltu	r18,r16,r7
 8212570:	1ca5c83a 	sub	r18,r3,r18
 8212574:	e480c126 	beq	fp,r18,821287c <__divdf3+0x76c>
 8212578:	a00b883a 	mov	r5,r20
 821257c:	9009883a 	mov	r4,r18
 8212580:	d9800315 	stw	r6,12(sp)
 8212584:	d9c00215 	stw	r7,8(sp)
 8212588:	da400115 	stw	r9,4(sp)
 821258c:	820270c0 	call	820270c <__udivsi3>
 8212590:	a00b883a 	mov	r5,r20
 8212594:	9009883a 	mov	r4,r18
 8212598:	d8800015 	stw	r2,0(sp)
 821259c:	82027700 	call	8202770 <__umodsi3>
 82125a0:	d9c00217 	ldw	r7,8(sp)
 82125a4:	da000017 	ldw	r8,0(sp)
 82125a8:	1006943a 	slli	r3,r2,16
 82125ac:	3804d43a 	srli	r2,r7,16
 82125b0:	ba21383a 	mul	r16,r23,r8
 82125b4:	d9800317 	ldw	r6,12(sp)
 82125b8:	10c4b03a 	or	r2,r2,r3
 82125bc:	da400117 	ldw	r9,4(sp)
 82125c0:	1400062e 	bgeu	r2,r16,82125dc <__divdf3+0x4cc>
 82125c4:	1705883a 	add	r2,r2,fp
 82125c8:	40ffffc4 	addi	r3,r8,-1
 82125cc:	1700ad36 	bltu	r2,fp,8212884 <__divdf3+0x774>
 82125d0:	1400ac2e 	bgeu	r2,r16,8212884 <__divdf3+0x774>
 82125d4:	423fff84 	addi	r8,r8,-2
 82125d8:	1705883a 	add	r2,r2,fp
 82125dc:	1421c83a 	sub	r16,r2,r16
 82125e0:	a00b883a 	mov	r5,r20
 82125e4:	8009883a 	mov	r4,r16
 82125e8:	d9800315 	stw	r6,12(sp)
 82125ec:	d9c00215 	stw	r7,8(sp)
 82125f0:	da000015 	stw	r8,0(sp)
 82125f4:	da400115 	stw	r9,4(sp)
 82125f8:	820270c0 	call	820270c <__udivsi3>
 82125fc:	8009883a 	mov	r4,r16
 8212600:	a00b883a 	mov	r5,r20
 8212604:	1025883a 	mov	r18,r2
 8212608:	82027700 	call	8202770 <__umodsi3>
 821260c:	d9c00217 	ldw	r7,8(sp)
 8212610:	1004943a 	slli	r2,r2,16
 8212614:	bcaf383a 	mul	r23,r23,r18
 8212618:	393fffcc 	andi	r4,r7,65535
 821261c:	2088b03a 	or	r4,r4,r2
 8212620:	d9800317 	ldw	r6,12(sp)
 8212624:	da000017 	ldw	r8,0(sp)
 8212628:	da400117 	ldw	r9,4(sp)
 821262c:	25c0062e 	bgeu	r4,r23,8212648 <__divdf3+0x538>
 8212630:	2709883a 	add	r4,r4,fp
 8212634:	90bfffc4 	addi	r2,r18,-1
 8212638:	27009436 	bltu	r4,fp,821288c <__divdf3+0x77c>
 821263c:	25c0932e 	bgeu	r4,r23,821288c <__divdf3+0x77c>
 8212640:	94bfff84 	addi	r18,r18,-2
 8212644:	2709883a 	add	r4,r4,fp
 8212648:	4004943a 	slli	r2,r8,16
 821264c:	25efc83a 	sub	r23,r4,r23
 8212650:	1490b03a 	or	r8,r2,r18
 8212654:	4008d43a 	srli	r4,r8,16
 8212658:	40ffffcc 	andi	r3,r8,65535
 821265c:	30c5383a 	mul	r2,r6,r3
 8212660:	1a47383a 	mul	r3,r3,r9
 8212664:	310d383a 	mul	r6,r6,r4
 8212668:	100ad43a 	srli	r5,r2,16
 821266c:	4913383a 	mul	r9,r9,r4
 8212670:	1987883a 	add	r3,r3,r6
 8212674:	28c7883a 	add	r3,r5,r3
 8212678:	1980022e 	bgeu	r3,r6,8212684 <__divdf3+0x574>
 821267c:	01000074 	movhi	r4,1
 8212680:	4913883a 	add	r9,r9,r4
 8212684:	1808d43a 	srli	r4,r3,16
 8212688:	1806943a 	slli	r3,r3,16
 821268c:	10bfffcc 	andi	r2,r2,65535
 8212690:	2253883a 	add	r9,r4,r9
 8212694:	1887883a 	add	r3,r3,r2
 8212698:	ba403836 	bltu	r23,r9,821277c <__divdf3+0x66c>
 821269c:	ba403626 	beq	r23,r9,8212778 <__divdf3+0x668>
 82126a0:	42000054 	ori	r8,r8,1
 82126a4:	a880ffc4 	addi	r2,r21,1023
 82126a8:	00bf570e 	bge	zero,r2,8212408 <__divdf3+0x2f8>
 82126ac:	40c001cc 	andi	r3,r8,7
 82126b0:	18000726 	beq	r3,zero,82126d0 <__divdf3+0x5c0>
 82126b4:	40c003cc 	andi	r3,r8,15
 82126b8:	01000104 	movi	r4,4
 82126bc:	19000426 	beq	r3,r4,82126d0 <__divdf3+0x5c0>
 82126c0:	4107883a 	add	r3,r8,r4
 82126c4:	1a11803a 	cmpltu	r8,r3,r8
 82126c8:	8a23883a 	add	r17,r17,r8
 82126cc:	1811883a 	mov	r8,r3
 82126d0:	88c0402c 	andhi	r3,r17,256
 82126d4:	18000426 	beq	r3,zero,82126e8 <__divdf3+0x5d8>
 82126d8:	00ffc034 	movhi	r3,65280
 82126dc:	18ffffc4 	addi	r3,r3,-1
 82126e0:	a8810004 	addi	r2,r21,1024
 82126e4:	88e2703a 	and	r17,r17,r3
 82126e8:	00c1ff84 	movi	r3,2046
 82126ec:	18bee316 	blt	r3,r2,821227c <__divdf3+0x16c>
 82126f0:	8824977a 	slli	r18,r17,29
 82126f4:	4010d0fa 	srli	r8,r8,3
 82126f8:	8822927a 	slli	r17,r17,9
 82126fc:	1081ffcc 	andi	r2,r2,2047
 8212700:	9224b03a 	or	r18,r18,r8
 8212704:	880ad33a 	srli	r5,r17,12
 8212708:	98c0004c 	andi	r3,r19,1
 821270c:	003edf06 	br	821228c <__divdf3+0x17c>
 8212710:	8080022c 	andhi	r2,r16,8
 8212714:	10001226 	beq	r2,zero,8212760 <__divdf3+0x650>
 8212718:	8880022c 	andhi	r2,r17,8
 821271c:	1000101e 	bne	r2,zero,8212760 <__divdf3+0x650>
 8212720:	00800434 	movhi	r2,16
 8212724:	89400234 	orhi	r5,r17,8
 8212728:	10bfffc4 	addi	r2,r2,-1
 821272c:	b007883a 	mov	r3,r22
 8212730:	288a703a 	and	r5,r5,r2
 8212734:	4025883a 	mov	r18,r8
 8212738:	003f3106 	br	8212400 <__divdf3+0x2f0>
 821273c:	008000c4 	movi	r2,3
 8212740:	3880a626 	beq	r7,r2,82129dc <__divdf3+0x8cc>
 8212744:	00800044 	movi	r2,1
 8212748:	3880521e 	bne	r7,r2,8212894 <__divdf3+0x784>
 821274c:	b807883a 	mov	r3,r23
 8212750:	0005883a 	mov	r2,zero
 8212754:	000b883a 	mov	r5,zero
 8212758:	0025883a 	mov	r18,zero
 821275c:	003ecb06 	br	821228c <__divdf3+0x17c>
 8212760:	00800434 	movhi	r2,16
 8212764:	81400234 	orhi	r5,r16,8
 8212768:	10bfffc4 	addi	r2,r2,-1
 821276c:	a007883a 	mov	r3,r20
 8212770:	288a703a 	and	r5,r5,r2
 8212774:	003f2206 	br	8212400 <__divdf3+0x2f0>
 8212778:	183fca26 	beq	r3,zero,82126a4 <__divdf3+0x594>
 821277c:	e5ef883a 	add	r23,fp,r23
 8212780:	40bfffc4 	addi	r2,r8,-1
 8212784:	bf00392e 	bgeu	r23,fp,821286c <__divdf3+0x75c>
 8212788:	1011883a 	mov	r8,r2
 821278c:	ba7fc41e 	bne	r23,r9,82126a0 <__divdf3+0x590>
 8212790:	b0ffc31e 	bne	r22,r3,82126a0 <__divdf3+0x590>
 8212794:	003fc306 	br	82126a4 <__divdf3+0x594>
 8212798:	143ff604 	addi	r16,r2,-40
 821279c:	9c20983a 	sll	r16,r19,r16
 82127a0:	0025883a 	mov	r18,zero
 82127a4:	003ee206 	br	8212330 <__divdf3+0x220>
 82127a8:	d9800315 	stw	r6,12(sp)
 82127ac:	d9c00215 	stw	r7,8(sp)
 82127b0:	8213e680 	call	8213e68 <__clzsi2>
 82127b4:	10800804 	addi	r2,r2,32
 82127b8:	d9c00217 	ldw	r7,8(sp)
 82127bc:	d9800317 	ldw	r6,12(sp)
 82127c0:	003ed106 	br	8212308 <__divdf3+0x1f8>
 82127c4:	147ff604 	addi	r17,r2,-40
 82127c8:	3462983a 	sll	r17,r6,r17
 82127cc:	0011883a 	mov	r8,zero
 82127d0:	003ef506 	br	82123a8 <__divdf3+0x298>
 82127d4:	3009883a 	mov	r4,r6
 82127d8:	d9800315 	stw	r6,12(sp)
 82127dc:	da400115 	stw	r9,4(sp)
 82127e0:	8213e680 	call	8213e68 <__clzsi2>
 82127e4:	10800804 	addi	r2,r2,32
 82127e8:	da400117 	ldw	r9,4(sp)
 82127ec:	d9800317 	ldw	r6,12(sp)
 82127f0:	003ee306 	br	8212380 <__divdf3+0x270>
 82127f4:	85a1883a 	add	r16,r16,r22
 82127f8:	8585803a 	cmpltu	r2,r16,r22
 82127fc:	1705883a 	add	r2,r2,fp
 8212800:	14a5883a 	add	r18,r2,r18
 8212804:	88bfffc4 	addi	r2,r17,-1
 8212808:	e4800c2e 	bgeu	fp,r18,821283c <__divdf3+0x72c>
 821280c:	90c03e36 	bltu	r18,r3,8212908 <__divdf3+0x7f8>
 8212810:	1c806926 	beq	r3,r18,82129b8 <__divdf3+0x8a8>
 8212814:	90c7c83a 	sub	r3,r18,r3
 8212818:	1023883a 	mov	r17,r2
 821281c:	003f5206 	br	8212568 <__divdf3+0x458>
 8212820:	923f0436 	bltu	r18,r8,8212434 <__divdf3+0x324>
 8212824:	800897fa 	slli	r4,r16,31
 8212828:	9004d07a 	srli	r2,r18,1
 821282c:	8006d07a 	srli	r3,r16,1
 8212830:	902097fa 	slli	r16,r18,31
 8212834:	20a4b03a 	or	r18,r4,r2
 8212838:	003f0106 	br	8212440 <__divdf3+0x330>
 821283c:	e4bff51e 	bne	fp,r18,8212814 <__divdf3+0x704>
 8212840:	85bff22e 	bgeu	r16,r22,821280c <__divdf3+0x6fc>
 8212844:	e0c7c83a 	sub	r3,fp,r3
 8212848:	1023883a 	mov	r17,r2
 821284c:	003f4606 	br	8212568 <__divdf3+0x458>
 8212850:	100f883a 	mov	r7,r2
 8212854:	003f2b06 	br	8212504 <__divdf3+0x3f4>
 8212858:	180d883a 	mov	r6,r3
 821285c:	003f1306 	br	82124ac <__divdf3+0x39c>
 8212860:	813fe436 	bltu	r16,r4,82127f4 <__divdf3+0x6e4>
 8212864:	0007883a 	mov	r3,zero
 8212868:	003f3f06 	br	8212568 <__divdf3+0x458>
 821286c:	ba402c36 	bltu	r23,r9,8212920 <__divdf3+0x810>
 8212870:	4dc05426 	beq	r9,r23,82129c4 <__divdf3+0x8b4>
 8212874:	1011883a 	mov	r8,r2
 8212878:	003f8906 	br	82126a0 <__divdf3+0x590>
 821287c:	023fffc4 	movi	r8,-1
 8212880:	003f8806 	br	82126a4 <__divdf3+0x594>
 8212884:	1811883a 	mov	r8,r3
 8212888:	003f5406 	br	82125dc <__divdf3+0x4cc>
 821288c:	1025883a 	mov	r18,r2
 8212890:	003f6d06 	br	8212648 <__divdf3+0x538>
 8212894:	b827883a 	mov	r19,r23
 8212898:	003f8206 	br	82126a4 <__divdf3+0x594>
 821289c:	010007c4 	movi	r4,31
 82128a0:	20c02616 	blt	r4,r3,821293c <__divdf3+0x82c>
 82128a4:	00800804 	movi	r2,32
 82128a8:	10c5c83a 	sub	r2,r2,r3
 82128ac:	888a983a 	sll	r5,r17,r2
 82128b0:	40c8d83a 	srl	r4,r8,r3
 82128b4:	4084983a 	sll	r2,r8,r2
 82128b8:	88e2d83a 	srl	r17,r17,r3
 82128bc:	2906b03a 	or	r3,r5,r4
 82128c0:	1004c03a 	cmpne	r2,r2,zero
 82128c4:	1886b03a 	or	r3,r3,r2
 82128c8:	188001cc 	andi	r2,r3,7
 82128cc:	10000726 	beq	r2,zero,82128ec <__divdf3+0x7dc>
 82128d0:	188003cc 	andi	r2,r3,15
 82128d4:	01000104 	movi	r4,4
 82128d8:	11000426 	beq	r2,r4,82128ec <__divdf3+0x7dc>
 82128dc:	1805883a 	mov	r2,r3
 82128e0:	10c00104 	addi	r3,r2,4
 82128e4:	1885803a 	cmpltu	r2,r3,r2
 82128e8:	88a3883a 	add	r17,r17,r2
 82128ec:	8880202c 	andhi	r2,r17,128
 82128f0:	10002726 	beq	r2,zero,8212990 <__divdf3+0x880>
 82128f4:	98c0004c 	andi	r3,r19,1
 82128f8:	00800044 	movi	r2,1
 82128fc:	000b883a 	mov	r5,zero
 8212900:	0025883a 	mov	r18,zero
 8212904:	003e6106 	br	821228c <__divdf3+0x17c>
 8212908:	85a1883a 	add	r16,r16,r22
 821290c:	8585803a 	cmpltu	r2,r16,r22
 8212910:	1705883a 	add	r2,r2,fp
 8212914:	14a5883a 	add	r18,r2,r18
 8212918:	8c7fff84 	addi	r17,r17,-2
 821291c:	003f1106 	br	8212564 <__divdf3+0x454>
 8212920:	b589883a 	add	r4,r22,r22
 8212924:	25ad803a 	cmpltu	r22,r4,r22
 8212928:	b739883a 	add	fp,r22,fp
 821292c:	40bfff84 	addi	r2,r8,-2
 8212930:	bf2f883a 	add	r23,r23,fp
 8212934:	202d883a 	mov	r22,r4
 8212938:	003f9306 	br	8212788 <__divdf3+0x678>
 821293c:	013ff844 	movi	r4,-31
 8212940:	2085c83a 	sub	r2,r4,r2
 8212944:	8888d83a 	srl	r4,r17,r2
 8212948:	00800804 	movi	r2,32
 821294c:	18802126 	beq	r3,r2,82129d4 <__divdf3+0x8c4>
 8212950:	00801004 	movi	r2,64
 8212954:	10c5c83a 	sub	r2,r2,r3
 8212958:	8884983a 	sll	r2,r17,r2
 821295c:	1204b03a 	or	r2,r2,r8
 8212960:	1004c03a 	cmpne	r2,r2,zero
 8212964:	2084b03a 	or	r2,r4,r2
 8212968:	144001cc 	andi	r17,r2,7
 821296c:	88000d1e 	bne	r17,zero,82129a4 <__divdf3+0x894>
 8212970:	000b883a 	mov	r5,zero
 8212974:	1024d0fa 	srli	r18,r2,3
 8212978:	98c0004c 	andi	r3,r19,1
 821297c:	0005883a 	mov	r2,zero
 8212980:	9464b03a 	or	r18,r18,r17
 8212984:	003e4106 	br	821228c <__divdf3+0x17c>
 8212988:	1007883a 	mov	r3,r2
 821298c:	0023883a 	mov	r17,zero
 8212990:	880a927a 	slli	r5,r17,9
 8212994:	1805883a 	mov	r2,r3
 8212998:	8822977a 	slli	r17,r17,29
 821299c:	280ad33a 	srli	r5,r5,12
 82129a0:	003ff406 	br	8212974 <__divdf3+0x864>
 82129a4:	10c003cc 	andi	r3,r2,15
 82129a8:	01000104 	movi	r4,4
 82129ac:	193ff626 	beq	r3,r4,8212988 <__divdf3+0x878>
 82129b0:	0023883a 	mov	r17,zero
 82129b4:	003fca06 	br	82128e0 <__divdf3+0x7d0>
 82129b8:	813fd336 	bltu	r16,r4,8212908 <__divdf3+0x7f8>
 82129bc:	1023883a 	mov	r17,r2
 82129c0:	003fa806 	br	8212864 <__divdf3+0x754>
 82129c4:	b0ffd636 	bltu	r22,r3,8212920 <__divdf3+0x810>
 82129c8:	1011883a 	mov	r8,r2
 82129cc:	b0ff341e 	bne	r22,r3,82126a0 <__divdf3+0x590>
 82129d0:	003f3406 	br	82126a4 <__divdf3+0x594>
 82129d4:	0005883a 	mov	r2,zero
 82129d8:	003fe006 	br	821295c <__divdf3+0x84c>
 82129dc:	00800434 	movhi	r2,16
 82129e0:	89400234 	orhi	r5,r17,8
 82129e4:	10bfffc4 	addi	r2,r2,-1
 82129e8:	b807883a 	mov	r3,r23
 82129ec:	288a703a 	and	r5,r5,r2
 82129f0:	4025883a 	mov	r18,r8
 82129f4:	003e8206 	br	8212400 <__divdf3+0x2f0>

082129f8 <__eqdf2>:
 82129f8:	2804d53a 	srli	r2,r5,20
 82129fc:	3806d53a 	srli	r3,r7,20
 8212a00:	02000434 	movhi	r8,16
 8212a04:	423fffc4 	addi	r8,r8,-1
 8212a08:	1081ffcc 	andi	r2,r2,2047
 8212a0c:	0281ffc4 	movi	r10,2047
 8212a10:	2a12703a 	and	r9,r5,r8
 8212a14:	18c1ffcc 	andi	r3,r3,2047
 8212a18:	3a10703a 	and	r8,r7,r8
 8212a1c:	280ad7fa 	srli	r5,r5,31
 8212a20:	380ed7fa 	srli	r7,r7,31
 8212a24:	12801026 	beq	r2,r10,8212a68 <__eqdf2+0x70>
 8212a28:	0281ffc4 	movi	r10,2047
 8212a2c:	1a800a26 	beq	r3,r10,8212a58 <__eqdf2+0x60>
 8212a30:	10c00226 	beq	r2,r3,8212a3c <__eqdf2+0x44>
 8212a34:	00800044 	movi	r2,1
 8212a38:	f800283a 	ret
 8212a3c:	4a3ffd1e 	bne	r9,r8,8212a34 <__eqdf2+0x3c>
 8212a40:	21bffc1e 	bne	r4,r6,8212a34 <__eqdf2+0x3c>
 8212a44:	29c00c26 	beq	r5,r7,8212a78 <__eqdf2+0x80>
 8212a48:	103ffa1e 	bne	r2,zero,8212a34 <__eqdf2+0x3c>
 8212a4c:	2244b03a 	or	r2,r4,r9
 8212a50:	1004c03a 	cmpne	r2,r2,zero
 8212a54:	f800283a 	ret
 8212a58:	3214b03a 	or	r10,r6,r8
 8212a5c:	503ff426 	beq	r10,zero,8212a30 <__eqdf2+0x38>
 8212a60:	00800044 	movi	r2,1
 8212a64:	f800283a 	ret
 8212a68:	2254b03a 	or	r10,r4,r9
 8212a6c:	503fee26 	beq	r10,zero,8212a28 <__eqdf2+0x30>
 8212a70:	00800044 	movi	r2,1
 8212a74:	f800283a 	ret
 8212a78:	0005883a 	mov	r2,zero
 8212a7c:	f800283a 	ret

08212a80 <__gedf2>:
 8212a80:	2804d53a 	srli	r2,r5,20
 8212a84:	3806d53a 	srli	r3,r7,20
 8212a88:	02000434 	movhi	r8,16
 8212a8c:	423fffc4 	addi	r8,r8,-1
 8212a90:	1081ffcc 	andi	r2,r2,2047
 8212a94:	0241ffc4 	movi	r9,2047
 8212a98:	2a14703a 	and	r10,r5,r8
 8212a9c:	18c1ffcc 	andi	r3,r3,2047
 8212aa0:	3a10703a 	and	r8,r7,r8
 8212aa4:	280ad7fa 	srli	r5,r5,31
 8212aa8:	380ed7fa 	srli	r7,r7,31
 8212aac:	12401d26 	beq	r2,r9,8212b24 <__gedf2+0xa4>
 8212ab0:	0241ffc4 	movi	r9,2047
 8212ab4:	1a401226 	beq	r3,r9,8212b00 <__gedf2+0x80>
 8212ab8:	1000081e 	bne	r2,zero,8212adc <__gedf2+0x5c>
 8212abc:	2296b03a 	or	r11,r4,r10
 8212ac0:	5813003a 	cmpeq	r9,r11,zero
 8212ac4:	1800091e 	bne	r3,zero,8212aec <__gedf2+0x6c>
 8212ac8:	3218b03a 	or	r12,r6,r8
 8212acc:	6000071e 	bne	r12,zero,8212aec <__gedf2+0x6c>
 8212ad0:	0005883a 	mov	r2,zero
 8212ad4:	5800101e 	bne	r11,zero,8212b18 <__gedf2+0x98>
 8212ad8:	f800283a 	ret
 8212adc:	18000c1e 	bne	r3,zero,8212b10 <__gedf2+0x90>
 8212ae0:	3212b03a 	or	r9,r6,r8
 8212ae4:	48000c26 	beq	r9,zero,8212b18 <__gedf2+0x98>
 8212ae8:	0013883a 	mov	r9,zero
 8212aec:	39c03fcc 	andi	r7,r7,255
 8212af0:	48000826 	beq	r9,zero,8212b14 <__gedf2+0x94>
 8212af4:	38000926 	beq	r7,zero,8212b1c <__gedf2+0x9c>
 8212af8:	00800044 	movi	r2,1
 8212afc:	f800283a 	ret
 8212b00:	3212b03a 	or	r9,r6,r8
 8212b04:	483fec26 	beq	r9,zero,8212ab8 <__gedf2+0x38>
 8212b08:	00bfff84 	movi	r2,-2
 8212b0c:	f800283a 	ret
 8212b10:	39c03fcc 	andi	r7,r7,255
 8212b14:	29c00626 	beq	r5,r7,8212b30 <__gedf2+0xb0>
 8212b18:	283ff726 	beq	r5,zero,8212af8 <__gedf2+0x78>
 8212b1c:	00bfffc4 	movi	r2,-1
 8212b20:	f800283a 	ret
 8212b24:	2292b03a 	or	r9,r4,r10
 8212b28:	483fe126 	beq	r9,zero,8212ab0 <__gedf2+0x30>
 8212b2c:	003ff606 	br	8212b08 <__gedf2+0x88>
 8212b30:	18bff916 	blt	r3,r2,8212b18 <__gedf2+0x98>
 8212b34:	10c00316 	blt	r2,r3,8212b44 <__gedf2+0xc4>
 8212b38:	42bff736 	bltu	r8,r10,8212b18 <__gedf2+0x98>
 8212b3c:	52000326 	beq	r10,r8,8212b4c <__gedf2+0xcc>
 8212b40:	5200042e 	bgeu	r10,r8,8212b54 <__gedf2+0xd4>
 8212b44:	283fec1e 	bne	r5,zero,8212af8 <__gedf2+0x78>
 8212b48:	003ff406 	br	8212b1c <__gedf2+0x9c>
 8212b4c:	313ff236 	bltu	r6,r4,8212b18 <__gedf2+0x98>
 8212b50:	21bffc36 	bltu	r4,r6,8212b44 <__gedf2+0xc4>
 8212b54:	0005883a 	mov	r2,zero
 8212b58:	f800283a 	ret

08212b5c <__ledf2>:
 8212b5c:	2804d53a 	srli	r2,r5,20
 8212b60:	3810d53a 	srli	r8,r7,20
 8212b64:	00c00434 	movhi	r3,16
 8212b68:	18ffffc4 	addi	r3,r3,-1
 8212b6c:	1081ffcc 	andi	r2,r2,2047
 8212b70:	0241ffc4 	movi	r9,2047
 8212b74:	28d4703a 	and	r10,r5,r3
 8212b78:	4201ffcc 	andi	r8,r8,2047
 8212b7c:	38c6703a 	and	r3,r7,r3
 8212b80:	280ad7fa 	srli	r5,r5,31
 8212b84:	380ed7fa 	srli	r7,r7,31
 8212b88:	12401f26 	beq	r2,r9,8212c08 <__ledf2+0xac>
 8212b8c:	0241ffc4 	movi	r9,2047
 8212b90:	42401426 	beq	r8,r9,8212be4 <__ledf2+0x88>
 8212b94:	1000091e 	bne	r2,zero,8212bbc <__ledf2+0x60>
 8212b98:	2296b03a 	or	r11,r4,r10
 8212b9c:	5813003a 	cmpeq	r9,r11,zero
 8212ba0:	29403fcc 	andi	r5,r5,255
 8212ba4:	40000a1e 	bne	r8,zero,8212bd0 <__ledf2+0x74>
 8212ba8:	30d8b03a 	or	r12,r6,r3
 8212bac:	6000081e 	bne	r12,zero,8212bd0 <__ledf2+0x74>
 8212bb0:	0005883a 	mov	r2,zero
 8212bb4:	5800111e 	bne	r11,zero,8212bfc <__ledf2+0xa0>
 8212bb8:	f800283a 	ret
 8212bbc:	29403fcc 	andi	r5,r5,255
 8212bc0:	40000c1e 	bne	r8,zero,8212bf4 <__ledf2+0x98>
 8212bc4:	30d2b03a 	or	r9,r6,r3
 8212bc8:	48000c26 	beq	r9,zero,8212bfc <__ledf2+0xa0>
 8212bcc:	0013883a 	mov	r9,zero
 8212bd0:	39c03fcc 	andi	r7,r7,255
 8212bd4:	48000826 	beq	r9,zero,8212bf8 <__ledf2+0x9c>
 8212bd8:	38001126 	beq	r7,zero,8212c20 <__ledf2+0xc4>
 8212bdc:	00800044 	movi	r2,1
 8212be0:	f800283a 	ret
 8212be4:	30d2b03a 	or	r9,r6,r3
 8212be8:	483fea26 	beq	r9,zero,8212b94 <__ledf2+0x38>
 8212bec:	00800084 	movi	r2,2
 8212bf0:	f800283a 	ret
 8212bf4:	39c03fcc 	andi	r7,r7,255
 8212bf8:	39400726 	beq	r7,r5,8212c18 <__ledf2+0xbc>
 8212bfc:	2800081e 	bne	r5,zero,8212c20 <__ledf2+0xc4>
 8212c00:	00800044 	movi	r2,1
 8212c04:	f800283a 	ret
 8212c08:	2292b03a 	or	r9,r4,r10
 8212c0c:	483fdf26 	beq	r9,zero,8212b8c <__ledf2+0x30>
 8212c10:	00800084 	movi	r2,2
 8212c14:	f800283a 	ret
 8212c18:	4080030e 	bge	r8,r2,8212c28 <__ledf2+0xcc>
 8212c1c:	383fef26 	beq	r7,zero,8212bdc <__ledf2+0x80>
 8212c20:	00bfffc4 	movi	r2,-1
 8212c24:	f800283a 	ret
 8212c28:	123feb16 	blt	r2,r8,8212bd8 <__ledf2+0x7c>
 8212c2c:	1abff336 	bltu	r3,r10,8212bfc <__ledf2+0xa0>
 8212c30:	50c00326 	beq	r10,r3,8212c40 <__ledf2+0xe4>
 8212c34:	50c0042e 	bgeu	r10,r3,8212c48 <__ledf2+0xec>
 8212c38:	283fe81e 	bne	r5,zero,8212bdc <__ledf2+0x80>
 8212c3c:	003ff806 	br	8212c20 <__ledf2+0xc4>
 8212c40:	313fee36 	bltu	r6,r4,8212bfc <__ledf2+0xa0>
 8212c44:	21bffc36 	bltu	r4,r6,8212c38 <__ledf2+0xdc>
 8212c48:	0005883a 	mov	r2,zero
 8212c4c:	f800283a 	ret

08212c50 <__muldf3>:
 8212c50:	defff304 	addi	sp,sp,-52
 8212c54:	2804d53a 	srli	r2,r5,20
 8212c58:	dd800915 	stw	r22,36(sp)
 8212c5c:	282cd7fa 	srli	r22,r5,31
 8212c60:	dc000315 	stw	r16,12(sp)
 8212c64:	04000434 	movhi	r16,16
 8212c68:	dd400815 	stw	r21,32(sp)
 8212c6c:	dc800515 	stw	r18,20(sp)
 8212c70:	843fffc4 	addi	r16,r16,-1
 8212c74:	dfc00c15 	stw	ra,48(sp)
 8212c78:	df000b15 	stw	fp,44(sp)
 8212c7c:	ddc00a15 	stw	r23,40(sp)
 8212c80:	dd000715 	stw	r20,28(sp)
 8212c84:	dcc00615 	stw	r19,24(sp)
 8212c88:	dc400415 	stw	r17,16(sp)
 8212c8c:	1481ffcc 	andi	r18,r2,2047
 8212c90:	2c20703a 	and	r16,r5,r16
 8212c94:	b02b883a 	mov	r21,r22
 8212c98:	b2403fcc 	andi	r9,r22,255
 8212c9c:	90006026 	beq	r18,zero,8212e20 <__muldf3+0x1d0>
 8212ca0:	0081ffc4 	movi	r2,2047
 8212ca4:	2029883a 	mov	r20,r4
 8212ca8:	90803626 	beq	r18,r2,8212d84 <__muldf3+0x134>
 8212cac:	80800434 	orhi	r2,r16,16
 8212cb0:	100490fa 	slli	r2,r2,3
 8212cb4:	2020d77a 	srli	r16,r4,29
 8212cb8:	202890fa 	slli	r20,r4,3
 8212cbc:	94bf0044 	addi	r18,r18,-1023
 8212cc0:	80a0b03a 	or	r16,r16,r2
 8212cc4:	0027883a 	mov	r19,zero
 8212cc8:	0039883a 	mov	fp,zero
 8212ccc:	3804d53a 	srli	r2,r7,20
 8212cd0:	382ed7fa 	srli	r23,r7,31
 8212cd4:	04400434 	movhi	r17,16
 8212cd8:	8c7fffc4 	addi	r17,r17,-1
 8212cdc:	1081ffcc 	andi	r2,r2,2047
 8212ce0:	3011883a 	mov	r8,r6
 8212ce4:	3c62703a 	and	r17,r7,r17
 8212ce8:	ba803fcc 	andi	r10,r23,255
 8212cec:	10006d26 	beq	r2,zero,8212ea4 <__muldf3+0x254>
 8212cf0:	00c1ffc4 	movi	r3,2047
 8212cf4:	10c06526 	beq	r2,r3,8212e8c <__muldf3+0x23c>
 8212cf8:	88c00434 	orhi	r3,r17,16
 8212cfc:	180690fa 	slli	r3,r3,3
 8212d00:	3022d77a 	srli	r17,r6,29
 8212d04:	301090fa 	slli	r8,r6,3
 8212d08:	10bf0044 	addi	r2,r2,-1023
 8212d0c:	88e2b03a 	or	r17,r17,r3
 8212d10:	000b883a 	mov	r5,zero
 8212d14:	9085883a 	add	r2,r18,r2
 8212d18:	2cc8b03a 	or	r4,r5,r19
 8212d1c:	00c003c4 	movi	r3,15
 8212d20:	bdacf03a 	xor	r22,r23,r22
 8212d24:	12c00044 	addi	r11,r2,1
 8212d28:	19009936 	bltu	r3,r4,8212f90 <__muldf3+0x340>
 8212d2c:	200890ba 	slli	r4,r4,2
 8212d30:	00c20874 	movhi	r3,2081
 8212d34:	18cb5104 	addi	r3,r3,11588
 8212d38:	20c9883a 	add	r4,r4,r3
 8212d3c:	20c00017 	ldw	r3,0(r4)
 8212d40:	1800683a 	jmp	r3
 8212d44:	08212f90 	cmplti	zero,at,-31554
 8212d48:	08212da4 	muli	zero,at,-31562
 8212d4c:	08212da4 	muli	zero,at,-31562
 8212d50:	08212da0 	cmpeqi	zero,at,-31562
 8212d54:	08212f6c 	andhi	zero,at,33981
 8212d58:	08212f6c 	andhi	zero,at,33981
 8212d5c:	08212f54 	ori	zero,at,33981
 8212d60:	08212da0 	cmpeqi	zero,at,-31562
 8212d64:	08212f6c 	andhi	zero,at,33981
 8212d68:	08212f54 	ori	zero,at,33981
 8212d6c:	08212f6c 	andhi	zero,at,33981
 8212d70:	08212da0 	cmpeqi	zero,at,-31562
 8212d74:	08212f7c 	xorhi	zero,at,33981
 8212d78:	08212f7c 	xorhi	zero,at,33981
 8212d7c:	08212f7c 	xorhi	zero,at,33981
 8212d80:	08213198 	cmpnei	zero,at,-31546
 8212d84:	2404b03a 	or	r2,r4,r16
 8212d88:	10006f1e 	bne	r2,zero,8212f48 <__muldf3+0x2f8>
 8212d8c:	04c00204 	movi	r19,8
 8212d90:	0021883a 	mov	r16,zero
 8212d94:	0029883a 	mov	r20,zero
 8212d98:	07000084 	movi	fp,2
 8212d9c:	003fcb06 	br	8212ccc <__muldf3+0x7c>
 8212da0:	502d883a 	mov	r22,r10
 8212da4:	00800084 	movi	r2,2
 8212da8:	28805726 	beq	r5,r2,8212f08 <__muldf3+0x2b8>
 8212dac:	008000c4 	movi	r2,3
 8212db0:	28816626 	beq	r5,r2,821334c <__muldf3+0x6fc>
 8212db4:	00800044 	movi	r2,1
 8212db8:	2881411e 	bne	r5,r2,82132c0 <__muldf3+0x670>
 8212dbc:	b02b883a 	mov	r21,r22
 8212dc0:	0005883a 	mov	r2,zero
 8212dc4:	000b883a 	mov	r5,zero
 8212dc8:	0029883a 	mov	r20,zero
 8212dcc:	1004953a 	slli	r2,r2,20
 8212dd0:	a8c03fcc 	andi	r3,r21,255
 8212dd4:	04400434 	movhi	r17,16
 8212dd8:	8c7fffc4 	addi	r17,r17,-1
 8212ddc:	180697fa 	slli	r3,r3,31
 8212de0:	2c4a703a 	and	r5,r5,r17
 8212de4:	288ab03a 	or	r5,r5,r2
 8212de8:	28c6b03a 	or	r3,r5,r3
 8212dec:	a005883a 	mov	r2,r20
 8212df0:	dfc00c17 	ldw	ra,48(sp)
 8212df4:	df000b17 	ldw	fp,44(sp)
 8212df8:	ddc00a17 	ldw	r23,40(sp)
 8212dfc:	dd800917 	ldw	r22,36(sp)
 8212e00:	dd400817 	ldw	r21,32(sp)
 8212e04:	dd000717 	ldw	r20,28(sp)
 8212e08:	dcc00617 	ldw	r19,24(sp)
 8212e0c:	dc800517 	ldw	r18,20(sp)
 8212e10:	dc400417 	ldw	r17,16(sp)
 8212e14:	dc000317 	ldw	r16,12(sp)
 8212e18:	dec00d04 	addi	sp,sp,52
 8212e1c:	f800283a 	ret
 8212e20:	2404b03a 	or	r2,r4,r16
 8212e24:	2027883a 	mov	r19,r4
 8212e28:	10004226 	beq	r2,zero,8212f34 <__muldf3+0x2e4>
 8212e2c:	8000fc26 	beq	r16,zero,8213220 <__muldf3+0x5d0>
 8212e30:	8009883a 	mov	r4,r16
 8212e34:	d9800215 	stw	r6,8(sp)
 8212e38:	d9c00015 	stw	r7,0(sp)
 8212e3c:	da400115 	stw	r9,4(sp)
 8212e40:	8213e680 	call	8213e68 <__clzsi2>
 8212e44:	d9800217 	ldw	r6,8(sp)
 8212e48:	d9c00017 	ldw	r7,0(sp)
 8212e4c:	da400117 	ldw	r9,4(sp)
 8212e50:	113ffd44 	addi	r4,r2,-11
 8212e54:	00c00704 	movi	r3,28
 8212e58:	1900ed16 	blt	r3,r4,8213210 <__muldf3+0x5c0>
 8212e5c:	00c00744 	movi	r3,29
 8212e60:	147ffe04 	addi	r17,r2,-8
 8212e64:	1907c83a 	sub	r3,r3,r4
 8212e68:	8460983a 	sll	r16,r16,r17
 8212e6c:	98c6d83a 	srl	r3,r19,r3
 8212e70:	9c68983a 	sll	r20,r19,r17
 8212e74:	1c20b03a 	or	r16,r3,r16
 8212e78:	1080fcc4 	addi	r2,r2,1011
 8212e7c:	00a5c83a 	sub	r18,zero,r2
 8212e80:	0027883a 	mov	r19,zero
 8212e84:	0039883a 	mov	fp,zero
 8212e88:	003f9006 	br	8212ccc <__muldf3+0x7c>
 8212e8c:	3446b03a 	or	r3,r6,r17
 8212e90:	1800261e 	bne	r3,zero,8212f2c <__muldf3+0x2dc>
 8212e94:	0023883a 	mov	r17,zero
 8212e98:	0011883a 	mov	r8,zero
 8212e9c:	01400084 	movi	r5,2
 8212ea0:	003f9c06 	br	8212d14 <__muldf3+0xc4>
 8212ea4:	3446b03a 	or	r3,r6,r17
 8212ea8:	18001c26 	beq	r3,zero,8212f1c <__muldf3+0x2cc>
 8212eac:	8800ce26 	beq	r17,zero,82131e8 <__muldf3+0x598>
 8212eb0:	8809883a 	mov	r4,r17
 8212eb4:	d9800215 	stw	r6,8(sp)
 8212eb8:	da400115 	stw	r9,4(sp)
 8212ebc:	da800015 	stw	r10,0(sp)
 8212ec0:	8213e680 	call	8213e68 <__clzsi2>
 8212ec4:	d9800217 	ldw	r6,8(sp)
 8212ec8:	da400117 	ldw	r9,4(sp)
 8212ecc:	da800017 	ldw	r10,0(sp)
 8212ed0:	113ffd44 	addi	r4,r2,-11
 8212ed4:	00c00704 	movi	r3,28
 8212ed8:	1900bf16 	blt	r3,r4,82131d8 <__muldf3+0x588>
 8212edc:	00c00744 	movi	r3,29
 8212ee0:	123ffe04 	addi	r8,r2,-8
 8212ee4:	1907c83a 	sub	r3,r3,r4
 8212ee8:	8a22983a 	sll	r17,r17,r8
 8212eec:	30c6d83a 	srl	r3,r6,r3
 8212ef0:	3210983a 	sll	r8,r6,r8
 8212ef4:	1c62b03a 	or	r17,r3,r17
 8212ef8:	1080fcc4 	addi	r2,r2,1011
 8212efc:	0085c83a 	sub	r2,zero,r2
 8212f00:	000b883a 	mov	r5,zero
 8212f04:	003f8306 	br	8212d14 <__muldf3+0xc4>
 8212f08:	b02b883a 	mov	r21,r22
 8212f0c:	0081ffc4 	movi	r2,2047
 8212f10:	000b883a 	mov	r5,zero
 8212f14:	0029883a 	mov	r20,zero
 8212f18:	003fac06 	br	8212dcc <__muldf3+0x17c>
 8212f1c:	0023883a 	mov	r17,zero
 8212f20:	0011883a 	mov	r8,zero
 8212f24:	01400044 	movi	r5,1
 8212f28:	003f7a06 	br	8212d14 <__muldf3+0xc4>
 8212f2c:	014000c4 	movi	r5,3
 8212f30:	003f7806 	br	8212d14 <__muldf3+0xc4>
 8212f34:	04c00104 	movi	r19,4
 8212f38:	0021883a 	mov	r16,zero
 8212f3c:	0029883a 	mov	r20,zero
 8212f40:	07000044 	movi	fp,1
 8212f44:	003f6106 	br	8212ccc <__muldf3+0x7c>
 8212f48:	04c00304 	movi	r19,12
 8212f4c:	070000c4 	movi	fp,3
 8212f50:	003f5e06 	br	8212ccc <__muldf3+0x7c>
 8212f54:	01400434 	movhi	r5,16
 8212f58:	002b883a 	mov	r21,zero
 8212f5c:	297fffc4 	addi	r5,r5,-1
 8212f60:	053fffc4 	movi	r20,-1
 8212f64:	0081ffc4 	movi	r2,2047
 8212f68:	003f9806 	br	8212dcc <__muldf3+0x17c>
 8212f6c:	8023883a 	mov	r17,r16
 8212f70:	a011883a 	mov	r8,r20
 8212f74:	e00b883a 	mov	r5,fp
 8212f78:	003f8a06 	br	8212da4 <__muldf3+0x154>
 8212f7c:	8023883a 	mov	r17,r16
 8212f80:	a011883a 	mov	r8,r20
 8212f84:	482d883a 	mov	r22,r9
 8212f88:	e00b883a 	mov	r5,fp
 8212f8c:	003f8506 	br	8212da4 <__muldf3+0x154>
 8212f90:	a00ad43a 	srli	r5,r20,16
 8212f94:	401ad43a 	srli	r13,r8,16
 8212f98:	a53fffcc 	andi	r20,r20,65535
 8212f9c:	423fffcc 	andi	r8,r8,65535
 8212fa0:	4519383a 	mul	r12,r8,r20
 8212fa4:	4147383a 	mul	r3,r8,r5
 8212fa8:	6d09383a 	mul	r4,r13,r20
 8212fac:	600cd43a 	srli	r6,r12,16
 8212fb0:	2b5d383a 	mul	r14,r5,r13
 8212fb4:	20c9883a 	add	r4,r4,r3
 8212fb8:	310d883a 	add	r6,r6,r4
 8212fbc:	30c0022e 	bgeu	r6,r3,8212fc8 <__muldf3+0x378>
 8212fc0:	00c00074 	movhi	r3,1
 8212fc4:	70dd883a 	add	r14,r14,r3
 8212fc8:	8826d43a 	srli	r19,r17,16
 8212fcc:	8bffffcc 	andi	r15,r17,65535
 8212fd0:	7d23383a 	mul	r17,r15,r20
 8212fd4:	7949383a 	mul	r4,r15,r5
 8212fd8:	9d29383a 	mul	r20,r19,r20
 8212fdc:	8814d43a 	srli	r10,r17,16
 8212fe0:	3012943a 	slli	r9,r6,16
 8212fe4:	a129883a 	add	r20,r20,r4
 8212fe8:	633fffcc 	andi	r12,r12,65535
 8212fec:	5515883a 	add	r10,r10,r20
 8212ff0:	3006d43a 	srli	r3,r6,16
 8212ff4:	4b13883a 	add	r9,r9,r12
 8212ff8:	2ccb383a 	mul	r5,r5,r19
 8212ffc:	5100022e 	bgeu	r10,r4,8213008 <__muldf3+0x3b8>
 8213000:	01000074 	movhi	r4,1
 8213004:	290b883a 	add	r5,r5,r4
 8213008:	802ad43a 	srli	r21,r16,16
 821300c:	843fffcc 	andi	r16,r16,65535
 8213010:	440d383a 	mul	r6,r8,r16
 8213014:	4565383a 	mul	r18,r8,r21
 8213018:	8349383a 	mul	r4,r16,r13
 821301c:	500e943a 	slli	r7,r10,16
 8213020:	3010d43a 	srli	r8,r6,16
 8213024:	5028d43a 	srli	r20,r10,16
 8213028:	2489883a 	add	r4,r4,r18
 821302c:	8abfffcc 	andi	r10,r17,65535
 8213030:	3a95883a 	add	r10,r7,r10
 8213034:	4119883a 	add	r12,r8,r4
 8213038:	a169883a 	add	r20,r20,r5
 821303c:	1a87883a 	add	r3,r3,r10
 8213040:	6d5b383a 	mul	r13,r13,r21
 8213044:	6480022e 	bgeu	r12,r18,8213050 <__muldf3+0x400>
 8213048:	01000074 	movhi	r4,1
 821304c:	691b883a 	add	r13,r13,r4
 8213050:	7c25383a 	mul	r18,r15,r16
 8213054:	7d4b383a 	mul	r5,r15,r21
 8213058:	84cf383a 	mul	r7,r16,r19
 821305c:	901ed43a 	srli	r15,r18,16
 8213060:	6008d43a 	srli	r4,r12,16
 8213064:	6010943a 	slli	r8,r12,16
 8213068:	394f883a 	add	r7,r7,r5
 821306c:	333fffcc 	andi	r12,r6,65535
 8213070:	79df883a 	add	r15,r15,r7
 8213074:	235b883a 	add	r13,r4,r13
 8213078:	9d63383a 	mul	r17,r19,r21
 821307c:	4309883a 	add	r4,r8,r12
 8213080:	7940022e 	bgeu	r15,r5,821308c <__muldf3+0x43c>
 8213084:	01400074 	movhi	r5,1
 8213088:	8963883a 	add	r17,r17,r5
 821308c:	780a943a 	slli	r5,r15,16
 8213090:	91bfffcc 	andi	r6,r18,65535
 8213094:	70c7883a 	add	r3,r14,r3
 8213098:	298d883a 	add	r6,r5,r6
 821309c:	1a8f803a 	cmpltu	r7,r3,r10
 82130a0:	350b883a 	add	r5,r6,r20
 82130a4:	20c7883a 	add	r3,r4,r3
 82130a8:	3955883a 	add	r10,r7,r5
 82130ac:	1909803a 	cmpltu	r4,r3,r4
 82130b0:	6a91883a 	add	r8,r13,r10
 82130b4:	780cd43a 	srli	r6,r15,16
 82130b8:	2219883a 	add	r12,r4,r8
 82130bc:	2d0b803a 	cmpltu	r5,r5,r20
 82130c0:	51cf803a 	cmpltu	r7,r10,r7
 82130c4:	29ceb03a 	or	r7,r5,r7
 82130c8:	4351803a 	cmpltu	r8,r8,r13
 82130cc:	610b803a 	cmpltu	r5,r12,r4
 82130d0:	4148b03a 	or	r4,r8,r5
 82130d4:	398f883a 	add	r7,r7,r6
 82130d8:	3909883a 	add	r4,r7,r4
 82130dc:	1810927a 	slli	r8,r3,9
 82130e0:	2449883a 	add	r4,r4,r17
 82130e4:	2008927a 	slli	r4,r4,9
 82130e8:	6022d5fa 	srli	r17,r12,23
 82130ec:	1806d5fa 	srli	r3,r3,23
 82130f0:	4252b03a 	or	r9,r8,r9
 82130f4:	600a927a 	slli	r5,r12,9
 82130f8:	4810c03a 	cmpne	r8,r9,zero
 82130fc:	2462b03a 	or	r17,r4,r17
 8213100:	40c6b03a 	or	r3,r8,r3
 8213104:	8900402c 	andhi	r4,r17,256
 8213108:	1950b03a 	or	r8,r3,r5
 821310c:	20000726 	beq	r4,zero,821312c <__muldf3+0x4dc>
 8213110:	4006d07a 	srli	r3,r8,1
 8213114:	880497fa 	slli	r2,r17,31
 8213118:	4200004c 	andi	r8,r8,1
 821311c:	8822d07a 	srli	r17,r17,1
 8213120:	1a10b03a 	or	r8,r3,r8
 8213124:	1210b03a 	or	r8,r2,r8
 8213128:	5805883a 	mov	r2,r11
 821312c:	1140ffc4 	addi	r5,r2,1023
 8213130:	0140440e 	bge	zero,r5,8213244 <__muldf3+0x5f4>
 8213134:	40c001cc 	andi	r3,r8,7
 8213138:	18000726 	beq	r3,zero,8213158 <__muldf3+0x508>
 821313c:	40c003cc 	andi	r3,r8,15
 8213140:	01000104 	movi	r4,4
 8213144:	19000426 	beq	r3,r4,8213158 <__muldf3+0x508>
 8213148:	4107883a 	add	r3,r8,r4
 821314c:	1a11803a 	cmpltu	r8,r3,r8
 8213150:	8a23883a 	add	r17,r17,r8
 8213154:	1811883a 	mov	r8,r3
 8213158:	88c0402c 	andhi	r3,r17,256
 821315c:	18000426 	beq	r3,zero,8213170 <__muldf3+0x520>
 8213160:	11410004 	addi	r5,r2,1024
 8213164:	00bfc034 	movhi	r2,65280
 8213168:	10bfffc4 	addi	r2,r2,-1
 821316c:	88a2703a 	and	r17,r17,r2
 8213170:	0081ff84 	movi	r2,2046
 8213174:	117f6416 	blt	r2,r5,8212f08 <__muldf3+0x2b8>
 8213178:	8828977a 	slli	r20,r17,29
 821317c:	4010d0fa 	srli	r8,r8,3
 8213180:	8822927a 	slli	r17,r17,9
 8213184:	2881ffcc 	andi	r2,r5,2047
 8213188:	a228b03a 	or	r20,r20,r8
 821318c:	880ad33a 	srli	r5,r17,12
 8213190:	b02b883a 	mov	r21,r22
 8213194:	003f0d06 	br	8212dcc <__muldf3+0x17c>
 8213198:	8080022c 	andhi	r2,r16,8
 821319c:	10000926 	beq	r2,zero,82131c4 <__muldf3+0x574>
 82131a0:	8880022c 	andhi	r2,r17,8
 82131a4:	1000071e 	bne	r2,zero,82131c4 <__muldf3+0x574>
 82131a8:	00800434 	movhi	r2,16
 82131ac:	89400234 	orhi	r5,r17,8
 82131b0:	10bfffc4 	addi	r2,r2,-1
 82131b4:	b82b883a 	mov	r21,r23
 82131b8:	288a703a 	and	r5,r5,r2
 82131bc:	4029883a 	mov	r20,r8
 82131c0:	003f6806 	br	8212f64 <__muldf3+0x314>
 82131c4:	00800434 	movhi	r2,16
 82131c8:	81400234 	orhi	r5,r16,8
 82131cc:	10bfffc4 	addi	r2,r2,-1
 82131d0:	288a703a 	and	r5,r5,r2
 82131d4:	003f6306 	br	8212f64 <__muldf3+0x314>
 82131d8:	147ff604 	addi	r17,r2,-40
 82131dc:	3462983a 	sll	r17,r6,r17
 82131e0:	0011883a 	mov	r8,zero
 82131e4:	003f4406 	br	8212ef8 <__muldf3+0x2a8>
 82131e8:	3009883a 	mov	r4,r6
 82131ec:	d9800215 	stw	r6,8(sp)
 82131f0:	da400115 	stw	r9,4(sp)
 82131f4:	da800015 	stw	r10,0(sp)
 82131f8:	8213e680 	call	8213e68 <__clzsi2>
 82131fc:	10800804 	addi	r2,r2,32
 8213200:	da800017 	ldw	r10,0(sp)
 8213204:	da400117 	ldw	r9,4(sp)
 8213208:	d9800217 	ldw	r6,8(sp)
 821320c:	003f3006 	br	8212ed0 <__muldf3+0x280>
 8213210:	143ff604 	addi	r16,r2,-40
 8213214:	9c20983a 	sll	r16,r19,r16
 8213218:	0029883a 	mov	r20,zero
 821321c:	003f1606 	br	8212e78 <__muldf3+0x228>
 8213220:	d9800215 	stw	r6,8(sp)
 8213224:	d9c00015 	stw	r7,0(sp)
 8213228:	da400115 	stw	r9,4(sp)
 821322c:	8213e680 	call	8213e68 <__clzsi2>
 8213230:	10800804 	addi	r2,r2,32
 8213234:	da400117 	ldw	r9,4(sp)
 8213238:	d9c00017 	ldw	r7,0(sp)
 821323c:	d9800217 	ldw	r6,8(sp)
 8213240:	003f0306 	br	8212e50 <__muldf3+0x200>
 8213244:	00c00044 	movi	r3,1
 8213248:	1947c83a 	sub	r3,r3,r5
 821324c:	00800e04 	movi	r2,56
 8213250:	10feda16 	blt	r2,r3,8212dbc <__muldf3+0x16c>
 8213254:	008007c4 	movi	r2,31
 8213258:	10c01b16 	blt	r2,r3,82132c8 <__muldf3+0x678>
 821325c:	00800804 	movi	r2,32
 8213260:	10c5c83a 	sub	r2,r2,r3
 8213264:	888a983a 	sll	r5,r17,r2
 8213268:	40c8d83a 	srl	r4,r8,r3
 821326c:	4084983a 	sll	r2,r8,r2
 8213270:	88e2d83a 	srl	r17,r17,r3
 8213274:	2906b03a 	or	r3,r5,r4
 8213278:	1004c03a 	cmpne	r2,r2,zero
 821327c:	1886b03a 	or	r3,r3,r2
 8213280:	188001cc 	andi	r2,r3,7
 8213284:	10000726 	beq	r2,zero,82132a4 <__muldf3+0x654>
 8213288:	188003cc 	andi	r2,r3,15
 821328c:	01000104 	movi	r4,4
 8213290:	11000426 	beq	r2,r4,82132a4 <__muldf3+0x654>
 8213294:	1805883a 	mov	r2,r3
 8213298:	10c00104 	addi	r3,r2,4
 821329c:	1885803a 	cmpltu	r2,r3,r2
 82132a0:	88a3883a 	add	r17,r17,r2
 82132a4:	8880202c 	andhi	r2,r17,128
 82132a8:	10001c26 	beq	r2,zero,821331c <__muldf3+0x6cc>
 82132ac:	b02b883a 	mov	r21,r22
 82132b0:	00800044 	movi	r2,1
 82132b4:	000b883a 	mov	r5,zero
 82132b8:	0029883a 	mov	r20,zero
 82132bc:	003ec306 	br	8212dcc <__muldf3+0x17c>
 82132c0:	5805883a 	mov	r2,r11
 82132c4:	003f9906 	br	821312c <__muldf3+0x4dc>
 82132c8:	00bff844 	movi	r2,-31
 82132cc:	1145c83a 	sub	r2,r2,r5
 82132d0:	8888d83a 	srl	r4,r17,r2
 82132d4:	00800804 	movi	r2,32
 82132d8:	18801a26 	beq	r3,r2,8213344 <__muldf3+0x6f4>
 82132dc:	00801004 	movi	r2,64
 82132e0:	10c5c83a 	sub	r2,r2,r3
 82132e4:	8884983a 	sll	r2,r17,r2
 82132e8:	1204b03a 	or	r2,r2,r8
 82132ec:	1004c03a 	cmpne	r2,r2,zero
 82132f0:	2084b03a 	or	r2,r4,r2
 82132f4:	144001cc 	andi	r17,r2,7
 82132f8:	88000d1e 	bne	r17,zero,8213330 <__muldf3+0x6e0>
 82132fc:	000b883a 	mov	r5,zero
 8213300:	1028d0fa 	srli	r20,r2,3
 8213304:	b02b883a 	mov	r21,r22
 8213308:	0005883a 	mov	r2,zero
 821330c:	a468b03a 	or	r20,r20,r17
 8213310:	003eae06 	br	8212dcc <__muldf3+0x17c>
 8213314:	1007883a 	mov	r3,r2
 8213318:	0023883a 	mov	r17,zero
 821331c:	880a927a 	slli	r5,r17,9
 8213320:	1805883a 	mov	r2,r3
 8213324:	8822977a 	slli	r17,r17,29
 8213328:	280ad33a 	srli	r5,r5,12
 821332c:	003ff406 	br	8213300 <__muldf3+0x6b0>
 8213330:	10c003cc 	andi	r3,r2,15
 8213334:	01000104 	movi	r4,4
 8213338:	193ff626 	beq	r3,r4,8213314 <__muldf3+0x6c4>
 821333c:	0023883a 	mov	r17,zero
 8213340:	003fd506 	br	8213298 <__muldf3+0x648>
 8213344:	0005883a 	mov	r2,zero
 8213348:	003fe706 	br	82132e8 <__muldf3+0x698>
 821334c:	00800434 	movhi	r2,16
 8213350:	89400234 	orhi	r5,r17,8
 8213354:	10bfffc4 	addi	r2,r2,-1
 8213358:	b02b883a 	mov	r21,r22
 821335c:	288a703a 	and	r5,r5,r2
 8213360:	4029883a 	mov	r20,r8
 8213364:	003eff06 	br	8212f64 <__muldf3+0x314>

08213368 <__subdf3>:
 8213368:	02000434 	movhi	r8,16
 821336c:	423fffc4 	addi	r8,r8,-1
 8213370:	defffb04 	addi	sp,sp,-20
 8213374:	2a14703a 	and	r10,r5,r8
 8213378:	3812d53a 	srli	r9,r7,20
 821337c:	3a10703a 	and	r8,r7,r8
 8213380:	2006d77a 	srli	r3,r4,29
 8213384:	3004d77a 	srli	r2,r6,29
 8213388:	dc000015 	stw	r16,0(sp)
 821338c:	501490fa 	slli	r10,r10,3
 8213390:	2820d53a 	srli	r16,r5,20
 8213394:	401090fa 	slli	r8,r8,3
 8213398:	dc800215 	stw	r18,8(sp)
 821339c:	dc400115 	stw	r17,4(sp)
 82133a0:	dfc00415 	stw	ra,16(sp)
 82133a4:	202290fa 	slli	r17,r4,3
 82133a8:	dcc00315 	stw	r19,12(sp)
 82133ac:	4a41ffcc 	andi	r9,r9,2047
 82133b0:	0101ffc4 	movi	r4,2047
 82133b4:	2824d7fa 	srli	r18,r5,31
 82133b8:	8401ffcc 	andi	r16,r16,2047
 82133bc:	50c6b03a 	or	r3,r10,r3
 82133c0:	380ed7fa 	srli	r7,r7,31
 82133c4:	408ab03a 	or	r5,r8,r2
 82133c8:	300c90fa 	slli	r6,r6,3
 82133cc:	49009626 	beq	r9,r4,8213628 <__subdf3+0x2c0>
 82133d0:	39c0005c 	xori	r7,r7,1
 82133d4:	8245c83a 	sub	r2,r16,r9
 82133d8:	3c807426 	beq	r7,r18,82135ac <__subdf3+0x244>
 82133dc:	0080af0e 	bge	zero,r2,821369c <__subdf3+0x334>
 82133e0:	48002a1e 	bne	r9,zero,821348c <__subdf3+0x124>
 82133e4:	2988b03a 	or	r4,r5,r6
 82133e8:	20009a1e 	bne	r4,zero,8213654 <__subdf3+0x2ec>
 82133ec:	888001cc 	andi	r2,r17,7
 82133f0:	10000726 	beq	r2,zero,8213410 <__subdf3+0xa8>
 82133f4:	888003cc 	andi	r2,r17,15
 82133f8:	01000104 	movi	r4,4
 82133fc:	11000426 	beq	r2,r4,8213410 <__subdf3+0xa8>
 8213400:	890b883a 	add	r5,r17,r4
 8213404:	2c63803a 	cmpltu	r17,r5,r17
 8213408:	1c47883a 	add	r3,r3,r17
 821340c:	2823883a 	mov	r17,r5
 8213410:	1880202c 	andhi	r2,r3,128
 8213414:	10005926 	beq	r2,zero,821357c <__subdf3+0x214>
 8213418:	84000044 	addi	r16,r16,1
 821341c:	0081ffc4 	movi	r2,2047
 8213420:	8080be26 	beq	r16,r2,821371c <__subdf3+0x3b4>
 8213424:	017fe034 	movhi	r5,65408
 8213428:	297fffc4 	addi	r5,r5,-1
 821342c:	1946703a 	and	r3,r3,r5
 8213430:	1804977a 	slli	r2,r3,29
 8213434:	1806927a 	slli	r3,r3,9
 8213438:	8822d0fa 	srli	r17,r17,3
 821343c:	8401ffcc 	andi	r16,r16,2047
 8213440:	180ad33a 	srli	r5,r3,12
 8213444:	9100004c 	andi	r4,r18,1
 8213448:	1444b03a 	or	r2,r2,r17
 821344c:	80c1ffcc 	andi	r3,r16,2047
 8213450:	1820953a 	slli	r16,r3,20
 8213454:	20c03fcc 	andi	r3,r4,255
 8213458:	180897fa 	slli	r4,r3,31
 821345c:	00c00434 	movhi	r3,16
 8213460:	18ffffc4 	addi	r3,r3,-1
 8213464:	28c6703a 	and	r3,r5,r3
 8213468:	1c06b03a 	or	r3,r3,r16
 821346c:	1906b03a 	or	r3,r3,r4
 8213470:	dfc00417 	ldw	ra,16(sp)
 8213474:	dcc00317 	ldw	r19,12(sp)
 8213478:	dc800217 	ldw	r18,8(sp)
 821347c:	dc400117 	ldw	r17,4(sp)
 8213480:	dc000017 	ldw	r16,0(sp)
 8213484:	dec00504 	addi	sp,sp,20
 8213488:	f800283a 	ret
 821348c:	0101ffc4 	movi	r4,2047
 8213490:	813fd626 	beq	r16,r4,82133ec <__subdf3+0x84>
 8213494:	29402034 	orhi	r5,r5,128
 8213498:	01000e04 	movi	r4,56
 821349c:	2080a316 	blt	r4,r2,821372c <__subdf3+0x3c4>
 82134a0:	010007c4 	movi	r4,31
 82134a4:	2080c616 	blt	r4,r2,82137c0 <__subdf3+0x458>
 82134a8:	01000804 	movi	r4,32
 82134ac:	2089c83a 	sub	r4,r4,r2
 82134b0:	2910983a 	sll	r8,r5,r4
 82134b4:	308ed83a 	srl	r7,r6,r2
 82134b8:	3108983a 	sll	r4,r6,r4
 82134bc:	2884d83a 	srl	r2,r5,r2
 82134c0:	41ccb03a 	or	r6,r8,r7
 82134c4:	2008c03a 	cmpne	r4,r4,zero
 82134c8:	310cb03a 	or	r6,r6,r4
 82134cc:	898dc83a 	sub	r6,r17,r6
 82134d0:	89a3803a 	cmpltu	r17,r17,r6
 82134d4:	1887c83a 	sub	r3,r3,r2
 82134d8:	1c47c83a 	sub	r3,r3,r17
 82134dc:	3023883a 	mov	r17,r6
 82134e0:	1880202c 	andhi	r2,r3,128
 82134e4:	10002326 	beq	r2,zero,8213574 <__subdf3+0x20c>
 82134e8:	04c02034 	movhi	r19,128
 82134ec:	9cffffc4 	addi	r19,r19,-1
 82134f0:	1ce6703a 	and	r19,r3,r19
 82134f4:	98007a26 	beq	r19,zero,82136e0 <__subdf3+0x378>
 82134f8:	9809883a 	mov	r4,r19
 82134fc:	8213e680 	call	8213e68 <__clzsi2>
 8213500:	113ffe04 	addi	r4,r2,-8
 8213504:	00c007c4 	movi	r3,31
 8213508:	19007b16 	blt	r3,r4,82136f8 <__subdf3+0x390>
 821350c:	00800804 	movi	r2,32
 8213510:	1105c83a 	sub	r2,r2,r4
 8213514:	8884d83a 	srl	r2,r17,r2
 8213518:	9906983a 	sll	r3,r19,r4
 821351c:	8922983a 	sll	r17,r17,r4
 8213520:	10c4b03a 	or	r2,r2,r3
 8213524:	24007816 	blt	r4,r16,8213708 <__subdf3+0x3a0>
 8213528:	2421c83a 	sub	r16,r4,r16
 821352c:	80c00044 	addi	r3,r16,1
 8213530:	010007c4 	movi	r4,31
 8213534:	20c09516 	blt	r4,r3,821378c <__subdf3+0x424>
 8213538:	01400804 	movi	r5,32
 821353c:	28cbc83a 	sub	r5,r5,r3
 8213540:	88c8d83a 	srl	r4,r17,r3
 8213544:	8962983a 	sll	r17,r17,r5
 8213548:	114a983a 	sll	r5,r2,r5
 821354c:	10c6d83a 	srl	r3,r2,r3
 8213550:	8804c03a 	cmpne	r2,r17,zero
 8213554:	290ab03a 	or	r5,r5,r4
 8213558:	28a2b03a 	or	r17,r5,r2
 821355c:	0021883a 	mov	r16,zero
 8213560:	003fa206 	br	82133ec <__subdf3+0x84>
 8213564:	2090b03a 	or	r8,r4,r2
 8213568:	40018e26 	beq	r8,zero,8213ba4 <__subdf3+0x83c>
 821356c:	1007883a 	mov	r3,r2
 8213570:	2023883a 	mov	r17,r4
 8213574:	888001cc 	andi	r2,r17,7
 8213578:	103f9e1e 	bne	r2,zero,82133f4 <__subdf3+0x8c>
 821357c:	1804977a 	slli	r2,r3,29
 8213580:	8822d0fa 	srli	r17,r17,3
 8213584:	1810d0fa 	srli	r8,r3,3
 8213588:	9100004c 	andi	r4,r18,1
 821358c:	1444b03a 	or	r2,r2,r17
 8213590:	00c1ffc4 	movi	r3,2047
 8213594:	80c02826 	beq	r16,r3,8213638 <__subdf3+0x2d0>
 8213598:	01400434 	movhi	r5,16
 821359c:	297fffc4 	addi	r5,r5,-1
 82135a0:	80e0703a 	and	r16,r16,r3
 82135a4:	414a703a 	and	r5,r8,r5
 82135a8:	003fa806 	br	821344c <__subdf3+0xe4>
 82135ac:	0080630e 	bge	zero,r2,821373c <__subdf3+0x3d4>
 82135b0:	48003026 	beq	r9,zero,8213674 <__subdf3+0x30c>
 82135b4:	0101ffc4 	movi	r4,2047
 82135b8:	813f8c26 	beq	r16,r4,82133ec <__subdf3+0x84>
 82135bc:	29402034 	orhi	r5,r5,128
 82135c0:	01000e04 	movi	r4,56
 82135c4:	2080a90e 	bge	r4,r2,821386c <__subdf3+0x504>
 82135c8:	298cb03a 	or	r6,r5,r6
 82135cc:	3012c03a 	cmpne	r9,r6,zero
 82135d0:	0005883a 	mov	r2,zero
 82135d4:	4c53883a 	add	r9,r9,r17
 82135d8:	4c63803a 	cmpltu	r17,r9,r17
 82135dc:	10c7883a 	add	r3,r2,r3
 82135e0:	88c7883a 	add	r3,r17,r3
 82135e4:	4823883a 	mov	r17,r9
 82135e8:	1880202c 	andhi	r2,r3,128
 82135ec:	1000d026 	beq	r2,zero,8213930 <__subdf3+0x5c8>
 82135f0:	84000044 	addi	r16,r16,1
 82135f4:	0081ffc4 	movi	r2,2047
 82135f8:	8080fe26 	beq	r16,r2,82139f4 <__subdf3+0x68c>
 82135fc:	00bfe034 	movhi	r2,65408
 8213600:	10bfffc4 	addi	r2,r2,-1
 8213604:	1886703a 	and	r3,r3,r2
 8213608:	880ad07a 	srli	r5,r17,1
 821360c:	180497fa 	slli	r2,r3,31
 8213610:	8900004c 	andi	r4,r17,1
 8213614:	2922b03a 	or	r17,r5,r4
 8213618:	1806d07a 	srli	r3,r3,1
 821361c:	1462b03a 	or	r17,r2,r17
 8213620:	3825883a 	mov	r18,r7
 8213624:	003f7106 	br	82133ec <__subdf3+0x84>
 8213628:	2984b03a 	or	r2,r5,r6
 821362c:	103f6826 	beq	r2,zero,82133d0 <__subdf3+0x68>
 8213630:	39c03fcc 	andi	r7,r7,255
 8213634:	003f6706 	br	82133d4 <__subdf3+0x6c>
 8213638:	4086b03a 	or	r3,r8,r2
 821363c:	18015226 	beq	r3,zero,8213b88 <__subdf3+0x820>
 8213640:	00c00434 	movhi	r3,16
 8213644:	41400234 	orhi	r5,r8,8
 8213648:	18ffffc4 	addi	r3,r3,-1
 821364c:	28ca703a 	and	r5,r5,r3
 8213650:	003f7e06 	br	821344c <__subdf3+0xe4>
 8213654:	10bfffc4 	addi	r2,r2,-1
 8213658:	1000491e 	bne	r2,zero,8213780 <__subdf3+0x418>
 821365c:	898fc83a 	sub	r7,r17,r6
 8213660:	89e3803a 	cmpltu	r17,r17,r7
 8213664:	1947c83a 	sub	r3,r3,r5
 8213668:	1c47c83a 	sub	r3,r3,r17
 821366c:	3823883a 	mov	r17,r7
 8213670:	003f9b06 	br	82134e0 <__subdf3+0x178>
 8213674:	2988b03a 	or	r4,r5,r6
 8213678:	203f5c26 	beq	r4,zero,82133ec <__subdf3+0x84>
 821367c:	10bfffc4 	addi	r2,r2,-1
 8213680:	1000931e 	bne	r2,zero,82138d0 <__subdf3+0x568>
 8213684:	898d883a 	add	r6,r17,r6
 8213688:	3463803a 	cmpltu	r17,r6,r17
 821368c:	1947883a 	add	r3,r3,r5
 8213690:	88c7883a 	add	r3,r17,r3
 8213694:	3023883a 	mov	r17,r6
 8213698:	003fd306 	br	82135e8 <__subdf3+0x280>
 821369c:	1000541e 	bne	r2,zero,82137f0 <__subdf3+0x488>
 82136a0:	80800044 	addi	r2,r16,1
 82136a4:	1081ffcc 	andi	r2,r2,2047
 82136a8:	01000044 	movi	r4,1
 82136ac:	2080a20e 	bge	r4,r2,8213938 <__subdf3+0x5d0>
 82136b0:	8989c83a 	sub	r4,r17,r6
 82136b4:	8905803a 	cmpltu	r2,r17,r4
 82136b8:	1967c83a 	sub	r19,r3,r5
 82136bc:	98a7c83a 	sub	r19,r19,r2
 82136c0:	9880202c 	andhi	r2,r19,128
 82136c4:	10006326 	beq	r2,zero,8213854 <__subdf3+0x4ec>
 82136c8:	3463c83a 	sub	r17,r6,r17
 82136cc:	28c7c83a 	sub	r3,r5,r3
 82136d0:	344d803a 	cmpltu	r6,r6,r17
 82136d4:	19a7c83a 	sub	r19,r3,r6
 82136d8:	3825883a 	mov	r18,r7
 82136dc:	983f861e 	bne	r19,zero,82134f8 <__subdf3+0x190>
 82136e0:	8809883a 	mov	r4,r17
 82136e4:	8213e680 	call	8213e68 <__clzsi2>
 82136e8:	10800804 	addi	r2,r2,32
 82136ec:	113ffe04 	addi	r4,r2,-8
 82136f0:	00c007c4 	movi	r3,31
 82136f4:	193f850e 	bge	r3,r4,821350c <__subdf3+0x1a4>
 82136f8:	10bff604 	addi	r2,r2,-40
 82136fc:	8884983a 	sll	r2,r17,r2
 8213700:	0023883a 	mov	r17,zero
 8213704:	243f880e 	bge	r4,r16,8213528 <__subdf3+0x1c0>
 8213708:	00ffe034 	movhi	r3,65408
 821370c:	18ffffc4 	addi	r3,r3,-1
 8213710:	8121c83a 	sub	r16,r16,r4
 8213714:	10c6703a 	and	r3,r2,r3
 8213718:	003f3406 	br	82133ec <__subdf3+0x84>
 821371c:	9100004c 	andi	r4,r18,1
 8213720:	000b883a 	mov	r5,zero
 8213724:	0005883a 	mov	r2,zero
 8213728:	003f4806 	br	821344c <__subdf3+0xe4>
 821372c:	298cb03a 	or	r6,r5,r6
 8213730:	300cc03a 	cmpne	r6,r6,zero
 8213734:	0005883a 	mov	r2,zero
 8213738:	003f6406 	br	82134cc <__subdf3+0x164>
 821373c:	10009a1e 	bne	r2,zero,82139a8 <__subdf3+0x640>
 8213740:	82400044 	addi	r9,r16,1
 8213744:	4881ffcc 	andi	r2,r9,2047
 8213748:	02800044 	movi	r10,1
 821374c:	5080670e 	bge	r10,r2,82138ec <__subdf3+0x584>
 8213750:	0081ffc4 	movi	r2,2047
 8213754:	4880af26 	beq	r9,r2,8213a14 <__subdf3+0x6ac>
 8213758:	898d883a 	add	r6,r17,r6
 821375c:	1945883a 	add	r2,r3,r5
 8213760:	3447803a 	cmpltu	r3,r6,r17
 8213764:	1887883a 	add	r3,r3,r2
 8213768:	182297fa 	slli	r17,r3,31
 821376c:	300cd07a 	srli	r6,r6,1
 8213770:	1806d07a 	srli	r3,r3,1
 8213774:	4821883a 	mov	r16,r9
 8213778:	89a2b03a 	or	r17,r17,r6
 821377c:	003f1b06 	br	82133ec <__subdf3+0x84>
 8213780:	0101ffc4 	movi	r4,2047
 8213784:	813f441e 	bne	r16,r4,8213498 <__subdf3+0x130>
 8213788:	003f1806 	br	82133ec <__subdf3+0x84>
 821378c:	843ff844 	addi	r16,r16,-31
 8213790:	01400804 	movi	r5,32
 8213794:	1408d83a 	srl	r4,r2,r16
 8213798:	19405026 	beq	r3,r5,82138dc <__subdf3+0x574>
 821379c:	01401004 	movi	r5,64
 82137a0:	28c7c83a 	sub	r3,r5,r3
 82137a4:	10c4983a 	sll	r2,r2,r3
 82137a8:	88a2b03a 	or	r17,r17,r2
 82137ac:	8822c03a 	cmpne	r17,r17,zero
 82137b0:	2462b03a 	or	r17,r4,r17
 82137b4:	0007883a 	mov	r3,zero
 82137b8:	0021883a 	mov	r16,zero
 82137bc:	003f6d06 	br	8213574 <__subdf3+0x20c>
 82137c0:	11fff804 	addi	r7,r2,-32
 82137c4:	01000804 	movi	r4,32
 82137c8:	29ced83a 	srl	r7,r5,r7
 82137cc:	11004526 	beq	r2,r4,82138e4 <__subdf3+0x57c>
 82137d0:	01001004 	movi	r4,64
 82137d4:	2089c83a 	sub	r4,r4,r2
 82137d8:	2904983a 	sll	r2,r5,r4
 82137dc:	118cb03a 	or	r6,r2,r6
 82137e0:	300cc03a 	cmpne	r6,r6,zero
 82137e4:	398cb03a 	or	r6,r7,r6
 82137e8:	0005883a 	mov	r2,zero
 82137ec:	003f3706 	br	82134cc <__subdf3+0x164>
 82137f0:	80002a26 	beq	r16,zero,821389c <__subdf3+0x534>
 82137f4:	0101ffc4 	movi	r4,2047
 82137f8:	49006626 	beq	r9,r4,8213994 <__subdf3+0x62c>
 82137fc:	0085c83a 	sub	r2,zero,r2
 8213800:	18c02034 	orhi	r3,r3,128
 8213804:	01000e04 	movi	r4,56
 8213808:	20807e16 	blt	r4,r2,8213a04 <__subdf3+0x69c>
 821380c:	010007c4 	movi	r4,31
 8213810:	2080e716 	blt	r4,r2,8213bb0 <__subdf3+0x848>
 8213814:	01000804 	movi	r4,32
 8213818:	2089c83a 	sub	r4,r4,r2
 821381c:	1914983a 	sll	r10,r3,r4
 8213820:	8890d83a 	srl	r8,r17,r2
 8213824:	8908983a 	sll	r4,r17,r4
 8213828:	1884d83a 	srl	r2,r3,r2
 821382c:	5222b03a 	or	r17,r10,r8
 8213830:	2006c03a 	cmpne	r3,r4,zero
 8213834:	88e2b03a 	or	r17,r17,r3
 8213838:	3463c83a 	sub	r17,r6,r17
 821383c:	2885c83a 	sub	r2,r5,r2
 8213840:	344d803a 	cmpltu	r6,r6,r17
 8213844:	1187c83a 	sub	r3,r2,r6
 8213848:	4821883a 	mov	r16,r9
 821384c:	3825883a 	mov	r18,r7
 8213850:	003f2306 	br	82134e0 <__subdf3+0x178>
 8213854:	24d0b03a 	or	r8,r4,r19
 8213858:	40001b1e 	bne	r8,zero,82138c8 <__subdf3+0x560>
 821385c:	0005883a 	mov	r2,zero
 8213860:	0009883a 	mov	r4,zero
 8213864:	0021883a 	mov	r16,zero
 8213868:	003f4906 	br	8213590 <__subdf3+0x228>
 821386c:	010007c4 	movi	r4,31
 8213870:	20803a16 	blt	r4,r2,821395c <__subdf3+0x5f4>
 8213874:	01000804 	movi	r4,32
 8213878:	2089c83a 	sub	r4,r4,r2
 821387c:	2912983a 	sll	r9,r5,r4
 8213880:	3090d83a 	srl	r8,r6,r2
 8213884:	3108983a 	sll	r4,r6,r4
 8213888:	2884d83a 	srl	r2,r5,r2
 821388c:	4a12b03a 	or	r9,r9,r8
 8213890:	2008c03a 	cmpne	r4,r4,zero
 8213894:	4912b03a 	or	r9,r9,r4
 8213898:	003f4e06 	br	82135d4 <__subdf3+0x26c>
 821389c:	1c48b03a 	or	r4,r3,r17
 82138a0:	20003c26 	beq	r4,zero,8213994 <__subdf3+0x62c>
 82138a4:	0084303a 	nor	r2,zero,r2
 82138a8:	1000381e 	bne	r2,zero,821398c <__subdf3+0x624>
 82138ac:	3463c83a 	sub	r17,r6,r17
 82138b0:	28c5c83a 	sub	r2,r5,r3
 82138b4:	344d803a 	cmpltu	r6,r6,r17
 82138b8:	1187c83a 	sub	r3,r2,r6
 82138bc:	4821883a 	mov	r16,r9
 82138c0:	3825883a 	mov	r18,r7
 82138c4:	003f0606 	br	82134e0 <__subdf3+0x178>
 82138c8:	2023883a 	mov	r17,r4
 82138cc:	003f0906 	br	82134f4 <__subdf3+0x18c>
 82138d0:	0101ffc4 	movi	r4,2047
 82138d4:	813f3a1e 	bne	r16,r4,82135c0 <__subdf3+0x258>
 82138d8:	003ec406 	br	82133ec <__subdf3+0x84>
 82138dc:	0005883a 	mov	r2,zero
 82138e0:	003fb106 	br	82137a8 <__subdf3+0x440>
 82138e4:	0005883a 	mov	r2,zero
 82138e8:	003fbc06 	br	82137dc <__subdf3+0x474>
 82138ec:	1c44b03a 	or	r2,r3,r17
 82138f0:	80008e1e 	bne	r16,zero,8213b2c <__subdf3+0x7c4>
 82138f4:	1000c826 	beq	r2,zero,8213c18 <__subdf3+0x8b0>
 82138f8:	2984b03a 	or	r2,r5,r6
 82138fc:	103ebb26 	beq	r2,zero,82133ec <__subdf3+0x84>
 8213900:	8989883a 	add	r4,r17,r6
 8213904:	1945883a 	add	r2,r3,r5
 8213908:	2447803a 	cmpltu	r3,r4,r17
 821390c:	1887883a 	add	r3,r3,r2
 8213910:	1880202c 	andhi	r2,r3,128
 8213914:	2023883a 	mov	r17,r4
 8213918:	103f1626 	beq	r2,zero,8213574 <__subdf3+0x20c>
 821391c:	00bfe034 	movhi	r2,65408
 8213920:	10bfffc4 	addi	r2,r2,-1
 8213924:	5021883a 	mov	r16,r10
 8213928:	1886703a 	and	r3,r3,r2
 821392c:	003eaf06 	br	82133ec <__subdf3+0x84>
 8213930:	3825883a 	mov	r18,r7
 8213934:	003f0f06 	br	8213574 <__subdf3+0x20c>
 8213938:	1c44b03a 	or	r2,r3,r17
 821393c:	8000251e 	bne	r16,zero,82139d4 <__subdf3+0x66c>
 8213940:	1000661e 	bne	r2,zero,8213adc <__subdf3+0x774>
 8213944:	2990b03a 	or	r8,r5,r6
 8213948:	40009626 	beq	r8,zero,8213ba4 <__subdf3+0x83c>
 821394c:	2807883a 	mov	r3,r5
 8213950:	3023883a 	mov	r17,r6
 8213954:	3825883a 	mov	r18,r7
 8213958:	003ea406 	br	82133ec <__subdf3+0x84>
 821395c:	127ff804 	addi	r9,r2,-32
 8213960:	01000804 	movi	r4,32
 8213964:	2a52d83a 	srl	r9,r5,r9
 8213968:	11008c26 	beq	r2,r4,8213b9c <__subdf3+0x834>
 821396c:	01001004 	movi	r4,64
 8213970:	2085c83a 	sub	r2,r4,r2
 8213974:	2884983a 	sll	r2,r5,r2
 8213978:	118cb03a 	or	r6,r2,r6
 821397c:	300cc03a 	cmpne	r6,r6,zero
 8213980:	4992b03a 	or	r9,r9,r6
 8213984:	0005883a 	mov	r2,zero
 8213988:	003f1206 	br	82135d4 <__subdf3+0x26c>
 821398c:	0101ffc4 	movi	r4,2047
 8213990:	493f9c1e 	bne	r9,r4,8213804 <__subdf3+0x49c>
 8213994:	2807883a 	mov	r3,r5
 8213998:	3023883a 	mov	r17,r6
 821399c:	4821883a 	mov	r16,r9
 82139a0:	3825883a 	mov	r18,r7
 82139a4:	003e9106 	br	82133ec <__subdf3+0x84>
 82139a8:	80001f1e 	bne	r16,zero,8213a28 <__subdf3+0x6c0>
 82139ac:	1c48b03a 	or	r4,r3,r17
 82139b0:	20005a26 	beq	r4,zero,8213b1c <__subdf3+0x7b4>
 82139b4:	0084303a 	nor	r2,zero,r2
 82139b8:	1000561e 	bne	r2,zero,8213b14 <__subdf3+0x7ac>
 82139bc:	89a3883a 	add	r17,r17,r6
 82139c0:	1945883a 	add	r2,r3,r5
 82139c4:	898d803a 	cmpltu	r6,r17,r6
 82139c8:	3087883a 	add	r3,r6,r2
 82139cc:	4821883a 	mov	r16,r9
 82139d0:	003f0506 	br	82135e8 <__subdf3+0x280>
 82139d4:	10002b1e 	bne	r2,zero,8213a84 <__subdf3+0x71c>
 82139d8:	2984b03a 	or	r2,r5,r6
 82139dc:	10008026 	beq	r2,zero,8213be0 <__subdf3+0x878>
 82139e0:	2807883a 	mov	r3,r5
 82139e4:	3023883a 	mov	r17,r6
 82139e8:	3825883a 	mov	r18,r7
 82139ec:	0401ffc4 	movi	r16,2047
 82139f0:	003e7e06 	br	82133ec <__subdf3+0x84>
 82139f4:	3809883a 	mov	r4,r7
 82139f8:	0011883a 	mov	r8,zero
 82139fc:	0005883a 	mov	r2,zero
 8213a00:	003ee306 	br	8213590 <__subdf3+0x228>
 8213a04:	1c62b03a 	or	r17,r3,r17
 8213a08:	8822c03a 	cmpne	r17,r17,zero
 8213a0c:	0005883a 	mov	r2,zero
 8213a10:	003f8906 	br	8213838 <__subdf3+0x4d0>
 8213a14:	3809883a 	mov	r4,r7
 8213a18:	4821883a 	mov	r16,r9
 8213a1c:	0011883a 	mov	r8,zero
 8213a20:	0005883a 	mov	r2,zero
 8213a24:	003eda06 	br	8213590 <__subdf3+0x228>
 8213a28:	0101ffc4 	movi	r4,2047
 8213a2c:	49003b26 	beq	r9,r4,8213b1c <__subdf3+0x7b4>
 8213a30:	0085c83a 	sub	r2,zero,r2
 8213a34:	18c02034 	orhi	r3,r3,128
 8213a38:	01000e04 	movi	r4,56
 8213a3c:	20806e16 	blt	r4,r2,8213bf8 <__subdf3+0x890>
 8213a40:	010007c4 	movi	r4,31
 8213a44:	20807716 	blt	r4,r2,8213c24 <__subdf3+0x8bc>
 8213a48:	01000804 	movi	r4,32
 8213a4c:	2089c83a 	sub	r4,r4,r2
 8213a50:	1914983a 	sll	r10,r3,r4
 8213a54:	8890d83a 	srl	r8,r17,r2
 8213a58:	8908983a 	sll	r4,r17,r4
 8213a5c:	1884d83a 	srl	r2,r3,r2
 8213a60:	5222b03a 	or	r17,r10,r8
 8213a64:	2006c03a 	cmpne	r3,r4,zero
 8213a68:	88e2b03a 	or	r17,r17,r3
 8213a6c:	89a3883a 	add	r17,r17,r6
 8213a70:	1145883a 	add	r2,r2,r5
 8213a74:	898d803a 	cmpltu	r6,r17,r6
 8213a78:	3087883a 	add	r3,r6,r2
 8213a7c:	4821883a 	mov	r16,r9
 8213a80:	003ed906 	br	82135e8 <__subdf3+0x280>
 8213a84:	2984b03a 	or	r2,r5,r6
 8213a88:	10004226 	beq	r2,zero,8213b94 <__subdf3+0x82c>
 8213a8c:	1808d0fa 	srli	r4,r3,3
 8213a90:	8822d0fa 	srli	r17,r17,3
 8213a94:	1806977a 	slli	r3,r3,29
 8213a98:	2080022c 	andhi	r2,r4,8
 8213a9c:	1c62b03a 	or	r17,r3,r17
 8213aa0:	10000826 	beq	r2,zero,8213ac4 <__subdf3+0x75c>
 8213aa4:	2812d0fa 	srli	r9,r5,3
 8213aa8:	4880022c 	andhi	r2,r9,8
 8213aac:	1000051e 	bne	r2,zero,8213ac4 <__subdf3+0x75c>
 8213ab0:	300cd0fa 	srli	r6,r6,3
 8213ab4:	2804977a 	slli	r2,r5,29
 8213ab8:	4809883a 	mov	r4,r9
 8213abc:	3825883a 	mov	r18,r7
 8213ac0:	11a2b03a 	or	r17,r2,r6
 8213ac4:	8806d77a 	srli	r3,r17,29
 8213ac8:	200890fa 	slli	r4,r4,3
 8213acc:	882290fa 	slli	r17,r17,3
 8213ad0:	0401ffc4 	movi	r16,2047
 8213ad4:	1906b03a 	or	r3,r3,r4
 8213ad8:	003e4406 	br	82133ec <__subdf3+0x84>
 8213adc:	2984b03a 	or	r2,r5,r6
 8213ae0:	103e4226 	beq	r2,zero,82133ec <__subdf3+0x84>
 8213ae4:	8989c83a 	sub	r4,r17,r6
 8213ae8:	8911803a 	cmpltu	r8,r17,r4
 8213aec:	1945c83a 	sub	r2,r3,r5
 8213af0:	1205c83a 	sub	r2,r2,r8
 8213af4:	1200202c 	andhi	r8,r2,128
 8213af8:	403e9a26 	beq	r8,zero,8213564 <__subdf3+0x1fc>
 8213afc:	3463c83a 	sub	r17,r6,r17
 8213b00:	28c5c83a 	sub	r2,r5,r3
 8213b04:	344d803a 	cmpltu	r6,r6,r17
 8213b08:	1187c83a 	sub	r3,r2,r6
 8213b0c:	3825883a 	mov	r18,r7
 8213b10:	003e3606 	br	82133ec <__subdf3+0x84>
 8213b14:	0101ffc4 	movi	r4,2047
 8213b18:	493fc71e 	bne	r9,r4,8213a38 <__subdf3+0x6d0>
 8213b1c:	2807883a 	mov	r3,r5
 8213b20:	3023883a 	mov	r17,r6
 8213b24:	4821883a 	mov	r16,r9
 8213b28:	003e3006 	br	82133ec <__subdf3+0x84>
 8213b2c:	10003626 	beq	r2,zero,8213c08 <__subdf3+0x8a0>
 8213b30:	2984b03a 	or	r2,r5,r6
 8213b34:	10001726 	beq	r2,zero,8213b94 <__subdf3+0x82c>
 8213b38:	1808d0fa 	srli	r4,r3,3
 8213b3c:	8822d0fa 	srli	r17,r17,3
 8213b40:	1806977a 	slli	r3,r3,29
 8213b44:	2080022c 	andhi	r2,r4,8
 8213b48:	1c62b03a 	or	r17,r3,r17
 8213b4c:	10000726 	beq	r2,zero,8213b6c <__subdf3+0x804>
 8213b50:	2812d0fa 	srli	r9,r5,3
 8213b54:	4880022c 	andhi	r2,r9,8
 8213b58:	1000041e 	bne	r2,zero,8213b6c <__subdf3+0x804>
 8213b5c:	300cd0fa 	srli	r6,r6,3
 8213b60:	2804977a 	slli	r2,r5,29
 8213b64:	4809883a 	mov	r4,r9
 8213b68:	11a2b03a 	or	r17,r2,r6
 8213b6c:	8806d77a 	srli	r3,r17,29
 8213b70:	200890fa 	slli	r4,r4,3
 8213b74:	882290fa 	slli	r17,r17,3
 8213b78:	3825883a 	mov	r18,r7
 8213b7c:	1906b03a 	or	r3,r3,r4
 8213b80:	0401ffc4 	movi	r16,2047
 8213b84:	003e1906 	br	82133ec <__subdf3+0x84>
 8213b88:	000b883a 	mov	r5,zero
 8213b8c:	0005883a 	mov	r2,zero
 8213b90:	003e2e06 	br	821344c <__subdf3+0xe4>
 8213b94:	0401ffc4 	movi	r16,2047
 8213b98:	003e1406 	br	82133ec <__subdf3+0x84>
 8213b9c:	0005883a 	mov	r2,zero
 8213ba0:	003f7506 	br	8213978 <__subdf3+0x610>
 8213ba4:	0005883a 	mov	r2,zero
 8213ba8:	0009883a 	mov	r4,zero
 8213bac:	003e7806 	br	8213590 <__subdf3+0x228>
 8213bb0:	123ff804 	addi	r8,r2,-32
 8213bb4:	01000804 	movi	r4,32
 8213bb8:	1a10d83a 	srl	r8,r3,r8
 8213bbc:	11002526 	beq	r2,r4,8213c54 <__subdf3+0x8ec>
 8213bc0:	01001004 	movi	r4,64
 8213bc4:	2085c83a 	sub	r2,r4,r2
 8213bc8:	1884983a 	sll	r2,r3,r2
 8213bcc:	1444b03a 	or	r2,r2,r17
 8213bd0:	1004c03a 	cmpne	r2,r2,zero
 8213bd4:	40a2b03a 	or	r17,r8,r2
 8213bd8:	0005883a 	mov	r2,zero
 8213bdc:	003f1606 	br	8213838 <__subdf3+0x4d0>
 8213be0:	02000434 	movhi	r8,16
 8213be4:	0009883a 	mov	r4,zero
 8213be8:	423fffc4 	addi	r8,r8,-1
 8213bec:	00bfffc4 	movi	r2,-1
 8213bf0:	0401ffc4 	movi	r16,2047
 8213bf4:	003e6606 	br	8213590 <__subdf3+0x228>
 8213bf8:	1c62b03a 	or	r17,r3,r17
 8213bfc:	8822c03a 	cmpne	r17,r17,zero
 8213c00:	0005883a 	mov	r2,zero
 8213c04:	003f9906 	br	8213a6c <__subdf3+0x704>
 8213c08:	2807883a 	mov	r3,r5
 8213c0c:	3023883a 	mov	r17,r6
 8213c10:	0401ffc4 	movi	r16,2047
 8213c14:	003df506 	br	82133ec <__subdf3+0x84>
 8213c18:	2807883a 	mov	r3,r5
 8213c1c:	3023883a 	mov	r17,r6
 8213c20:	003df206 	br	82133ec <__subdf3+0x84>
 8213c24:	123ff804 	addi	r8,r2,-32
 8213c28:	01000804 	movi	r4,32
 8213c2c:	1a10d83a 	srl	r8,r3,r8
 8213c30:	11000a26 	beq	r2,r4,8213c5c <__subdf3+0x8f4>
 8213c34:	01001004 	movi	r4,64
 8213c38:	2085c83a 	sub	r2,r4,r2
 8213c3c:	1884983a 	sll	r2,r3,r2
 8213c40:	1444b03a 	or	r2,r2,r17
 8213c44:	1004c03a 	cmpne	r2,r2,zero
 8213c48:	40a2b03a 	or	r17,r8,r2
 8213c4c:	0005883a 	mov	r2,zero
 8213c50:	003f8606 	br	8213a6c <__subdf3+0x704>
 8213c54:	0005883a 	mov	r2,zero
 8213c58:	003fdc06 	br	8213bcc <__subdf3+0x864>
 8213c5c:	0005883a 	mov	r2,zero
 8213c60:	003ff706 	br	8213c40 <__subdf3+0x8d8>

08213c64 <__fixdfsi>:
 8213c64:	280cd53a 	srli	r6,r5,20
 8213c68:	00c00434 	movhi	r3,16
 8213c6c:	18ffffc4 	addi	r3,r3,-1
 8213c70:	3181ffcc 	andi	r6,r6,2047
 8213c74:	01c0ff84 	movi	r7,1022
 8213c78:	28c6703a 	and	r3,r5,r3
 8213c7c:	280ad7fa 	srli	r5,r5,31
 8213c80:	3980120e 	bge	r7,r6,8213ccc <__fixdfsi+0x68>
 8213c84:	00810744 	movi	r2,1053
 8213c88:	11800c16 	blt	r2,r6,8213cbc <__fixdfsi+0x58>
 8213c8c:	00810cc4 	movi	r2,1075
 8213c90:	1185c83a 	sub	r2,r2,r6
 8213c94:	01c007c4 	movi	r7,31
 8213c98:	18c00434 	orhi	r3,r3,16
 8213c9c:	38800d16 	blt	r7,r2,8213cd4 <__fixdfsi+0x70>
 8213ca0:	31befb44 	addi	r6,r6,-1043
 8213ca4:	2084d83a 	srl	r2,r4,r2
 8213ca8:	1986983a 	sll	r3,r3,r6
 8213cac:	1884b03a 	or	r2,r3,r2
 8213cb0:	28000726 	beq	r5,zero,8213cd0 <__fixdfsi+0x6c>
 8213cb4:	0085c83a 	sub	r2,zero,r2
 8213cb8:	f800283a 	ret
 8213cbc:	00a00034 	movhi	r2,32768
 8213cc0:	10bfffc4 	addi	r2,r2,-1
 8213cc4:	2885883a 	add	r2,r5,r2
 8213cc8:	f800283a 	ret
 8213ccc:	0005883a 	mov	r2,zero
 8213cd0:	f800283a 	ret
 8213cd4:	008104c4 	movi	r2,1043
 8213cd8:	1185c83a 	sub	r2,r2,r6
 8213cdc:	1884d83a 	srl	r2,r3,r2
 8213ce0:	003ff306 	br	8213cb0 <__fixdfsi+0x4c>

08213ce4 <__floatsidf>:
 8213ce4:	defffd04 	addi	sp,sp,-12
 8213ce8:	dfc00215 	stw	ra,8(sp)
 8213cec:	dc400115 	stw	r17,4(sp)
 8213cf0:	dc000015 	stw	r16,0(sp)
 8213cf4:	20002b26 	beq	r4,zero,8213da4 <__floatsidf+0xc0>
 8213cf8:	2023883a 	mov	r17,r4
 8213cfc:	2020d7fa 	srli	r16,r4,31
 8213d00:	20002d16 	blt	r4,zero,8213db8 <__floatsidf+0xd4>
 8213d04:	8809883a 	mov	r4,r17
 8213d08:	8213e680 	call	8213e68 <__clzsi2>
 8213d0c:	01410784 	movi	r5,1054
 8213d10:	288bc83a 	sub	r5,r5,r2
 8213d14:	01010cc4 	movi	r4,1075
 8213d18:	2149c83a 	sub	r4,r4,r5
 8213d1c:	00c007c4 	movi	r3,31
 8213d20:	1900160e 	bge	r3,r4,8213d7c <__floatsidf+0x98>
 8213d24:	00c104c4 	movi	r3,1043
 8213d28:	1947c83a 	sub	r3,r3,r5
 8213d2c:	88c6983a 	sll	r3,r17,r3
 8213d30:	00800434 	movhi	r2,16
 8213d34:	10bfffc4 	addi	r2,r2,-1
 8213d38:	1886703a 	and	r3,r3,r2
 8213d3c:	2941ffcc 	andi	r5,r5,2047
 8213d40:	800d883a 	mov	r6,r16
 8213d44:	0005883a 	mov	r2,zero
 8213d48:	280a953a 	slli	r5,r5,20
 8213d4c:	31803fcc 	andi	r6,r6,255
 8213d50:	01000434 	movhi	r4,16
 8213d54:	300c97fa 	slli	r6,r6,31
 8213d58:	213fffc4 	addi	r4,r4,-1
 8213d5c:	1906703a 	and	r3,r3,r4
 8213d60:	1946b03a 	or	r3,r3,r5
 8213d64:	1986b03a 	or	r3,r3,r6
 8213d68:	dfc00217 	ldw	ra,8(sp)
 8213d6c:	dc400117 	ldw	r17,4(sp)
 8213d70:	dc000017 	ldw	r16,0(sp)
 8213d74:	dec00304 	addi	sp,sp,12
 8213d78:	f800283a 	ret
 8213d7c:	00c002c4 	movi	r3,11
 8213d80:	1887c83a 	sub	r3,r3,r2
 8213d84:	88c6d83a 	srl	r3,r17,r3
 8213d88:	8904983a 	sll	r2,r17,r4
 8213d8c:	01000434 	movhi	r4,16
 8213d90:	213fffc4 	addi	r4,r4,-1
 8213d94:	2941ffcc 	andi	r5,r5,2047
 8213d98:	1906703a 	and	r3,r3,r4
 8213d9c:	800d883a 	mov	r6,r16
 8213da0:	003fe906 	br	8213d48 <__floatsidf+0x64>
 8213da4:	000d883a 	mov	r6,zero
 8213da8:	000b883a 	mov	r5,zero
 8213dac:	0007883a 	mov	r3,zero
 8213db0:	0005883a 	mov	r2,zero
 8213db4:	003fe406 	br	8213d48 <__floatsidf+0x64>
 8213db8:	0123c83a 	sub	r17,zero,r4
 8213dbc:	003fd106 	br	8213d04 <__floatsidf+0x20>

08213dc0 <__floatunsidf>:
 8213dc0:	defffe04 	addi	sp,sp,-8
 8213dc4:	dc000015 	stw	r16,0(sp)
 8213dc8:	dfc00115 	stw	ra,4(sp)
 8213dcc:	2021883a 	mov	r16,r4
 8213dd0:	20002226 	beq	r4,zero,8213e5c <__floatunsidf+0x9c>
 8213dd4:	8213e680 	call	8213e68 <__clzsi2>
 8213dd8:	01010784 	movi	r4,1054
 8213ddc:	2089c83a 	sub	r4,r4,r2
 8213de0:	01810cc4 	movi	r6,1075
 8213de4:	310dc83a 	sub	r6,r6,r4
 8213de8:	00c007c4 	movi	r3,31
 8213dec:	1980120e 	bge	r3,r6,8213e38 <__floatunsidf+0x78>
 8213df0:	00c104c4 	movi	r3,1043
 8213df4:	1907c83a 	sub	r3,r3,r4
 8213df8:	80ca983a 	sll	r5,r16,r3
 8213dfc:	00800434 	movhi	r2,16
 8213e00:	10bfffc4 	addi	r2,r2,-1
 8213e04:	2101ffcc 	andi	r4,r4,2047
 8213e08:	0021883a 	mov	r16,zero
 8213e0c:	288a703a 	and	r5,r5,r2
 8213e10:	2008953a 	slli	r4,r4,20
 8213e14:	00c00434 	movhi	r3,16
 8213e18:	18ffffc4 	addi	r3,r3,-1
 8213e1c:	28c6703a 	and	r3,r5,r3
 8213e20:	8005883a 	mov	r2,r16
 8213e24:	1906b03a 	or	r3,r3,r4
 8213e28:	dfc00117 	ldw	ra,4(sp)
 8213e2c:	dc000017 	ldw	r16,0(sp)
 8213e30:	dec00204 	addi	sp,sp,8
 8213e34:	f800283a 	ret
 8213e38:	00c002c4 	movi	r3,11
 8213e3c:	188bc83a 	sub	r5,r3,r2
 8213e40:	814ad83a 	srl	r5,r16,r5
 8213e44:	00c00434 	movhi	r3,16
 8213e48:	18ffffc4 	addi	r3,r3,-1
 8213e4c:	81a0983a 	sll	r16,r16,r6
 8213e50:	2101ffcc 	andi	r4,r4,2047
 8213e54:	28ca703a 	and	r5,r5,r3
 8213e58:	003fed06 	br	8213e10 <__floatunsidf+0x50>
 8213e5c:	0009883a 	mov	r4,zero
 8213e60:	000b883a 	mov	r5,zero
 8213e64:	003fea06 	br	8213e10 <__floatunsidf+0x50>

08213e68 <__clzsi2>:
 8213e68:	00bfffd4 	movui	r2,65535
 8213e6c:	11000536 	bltu	r2,r4,8213e84 <__clzsi2+0x1c>
 8213e70:	00803fc4 	movi	r2,255
 8213e74:	11000f36 	bltu	r2,r4,8213eb4 <__clzsi2+0x4c>
 8213e78:	00800804 	movi	r2,32
 8213e7c:	0007883a 	mov	r3,zero
 8213e80:	00000506 	br	8213e98 <__clzsi2+0x30>
 8213e84:	00804034 	movhi	r2,256
 8213e88:	10bfffc4 	addi	r2,r2,-1
 8213e8c:	11000c2e 	bgeu	r2,r4,8213ec0 <__clzsi2+0x58>
 8213e90:	00800204 	movi	r2,8
 8213e94:	00c00604 	movi	r3,24
 8213e98:	20c8d83a 	srl	r4,r4,r3
 8213e9c:	00c20974 	movhi	r3,2085
 8213ea0:	18f5d204 	addi	r3,r3,-10424
 8213ea4:	1909883a 	add	r4,r3,r4
 8213ea8:	20c00003 	ldbu	r3,0(r4)
 8213eac:	10c5c83a 	sub	r2,r2,r3
 8213eb0:	f800283a 	ret
 8213eb4:	00800604 	movi	r2,24
 8213eb8:	00c00204 	movi	r3,8
 8213ebc:	003ff606 	br	8213e98 <__clzsi2+0x30>
 8213ec0:	00800404 	movi	r2,16
 8213ec4:	1007883a 	mov	r3,r2
 8213ec8:	003ff306 	br	8213e98 <__clzsi2+0x30>

08213ecc <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 8213ecc:	defffc04 	addi	sp,sp,-16
 8213ed0:	dfc00315 	stw	ra,12(sp)
 8213ed4:	df000215 	stw	fp,8(sp)
 8213ed8:	df000204 	addi	fp,sp,8
 8213edc:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 8213ee0:	d1600704 	addi	r5,gp,-32740
 8213ee4:	e13fff17 	ldw	r4,-4(fp)
 8213ee8:	823bcdc0 	call	823bcdc <alt_find_dev>
 8213eec:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 8213ef0:	e0bffe17 	ldw	r2,-8(fp)
 8213ef4:	10000926 	beq	r2,zero,8213f1c <alt_flash_open_dev+0x50>
 8213ef8:	e0bffe17 	ldw	r2,-8(fp)
 8213efc:	10800317 	ldw	r2,12(r2)
 8213f00:	10000626 	beq	r2,zero,8213f1c <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 8213f04:	e0bffe17 	ldw	r2,-8(fp)
 8213f08:	10800317 	ldw	r2,12(r2)
 8213f0c:	e17fff17 	ldw	r5,-4(fp)
 8213f10:	e13ffe17 	ldw	r4,-8(fp)
 8213f14:	103ee83a 	callr	r2
 8213f18:	00000106 	br	8213f20 <alt_flash_open_dev+0x54>
  }

  return dev;
 8213f1c:	e0bffe17 	ldw	r2,-8(fp)
}
 8213f20:	e037883a 	mov	sp,fp
 8213f24:	dfc00117 	ldw	ra,4(sp)
 8213f28:	df000017 	ldw	fp,0(sp)
 8213f2c:	dec00204 	addi	sp,sp,8
 8213f30:	f800283a 	ret

08213f34 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 8213f34:	defffd04 	addi	sp,sp,-12
 8213f38:	dfc00215 	stw	ra,8(sp)
 8213f3c:	df000115 	stw	fp,4(sp)
 8213f40:	df000104 	addi	fp,sp,4
 8213f44:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 8213f48:	e0bfff17 	ldw	r2,-4(fp)
 8213f4c:	10000826 	beq	r2,zero,8213f70 <alt_flash_close_dev+0x3c>
 8213f50:	e0bfff17 	ldw	r2,-4(fp)
 8213f54:	10800417 	ldw	r2,16(r2)
 8213f58:	10000526 	beq	r2,zero,8213f70 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 8213f5c:	e0bfff17 	ldw	r2,-4(fp)
 8213f60:	10800417 	ldw	r2,16(r2)
 8213f64:	e13fff17 	ldw	r4,-4(fp)
 8213f68:	103ee83a 	callr	r2
  }
  return;
 8213f6c:	0001883a 	nop
 8213f70:	0001883a 	nop
}
 8213f74:	e037883a 	mov	sp,fp
 8213f78:	dfc00117 	ldw	ra,4(sp)
 8213f7c:	df000017 	ldw	fp,0(sp)
 8213f80:	dec00204 	addi	sp,sp,8
 8213f84:	f800283a 	ret

08213f88 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8213f88:	defffe04 	addi	sp,sp,-8
 8213f8c:	dfc00115 	stw	ra,4(sp)
 8213f90:	df000015 	stw	fp,0(sp)
 8213f94:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8213f98:	d0a04717 	ldw	r2,-32484(gp)
 8213f9c:	10000326 	beq	r2,zero,8213fac <alt_get_errno+0x24>
 8213fa0:	d0a04717 	ldw	r2,-32484(gp)
 8213fa4:	103ee83a 	callr	r2
 8213fa8:	00000106 	br	8213fb0 <alt_get_errno+0x28>
 8213fac:	d0a06304 	addi	r2,gp,-32372
}
 8213fb0:	e037883a 	mov	sp,fp
 8213fb4:	dfc00117 	ldw	ra,4(sp)
 8213fb8:	df000017 	ldw	fp,0(sp)
 8213fbc:	dec00204 	addi	sp,sp,8
 8213fc0:	f800283a 	ret

08213fc4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 8213fc4:	defffb04 	addi	sp,sp,-20
 8213fc8:	dfc00415 	stw	ra,16(sp)
 8213fcc:	df000315 	stw	fp,12(sp)
 8213fd0:	df000304 	addi	fp,sp,12
 8213fd4:	e13ffe15 	stw	r4,-8(fp)
 8213fd8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8213fdc:	e0bffe17 	ldw	r2,-8(fp)
 8213fe0:	10000616 	blt	r2,zero,8213ffc <fstat+0x38>
 8213fe4:	e0bffe17 	ldw	r2,-8(fp)
 8213fe8:	10c00324 	muli	r3,r2,12
 8213fec:	00820974 	movhi	r2,2085
 8213ff0:	108d6a04 	addi	r2,r2,13736
 8213ff4:	1885883a 	add	r2,r3,r2
 8213ff8:	00000106 	br	8214000 <fstat+0x3c>
 8213ffc:	0005883a 	mov	r2,zero
 8214000:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8214004:	e0bffd17 	ldw	r2,-12(fp)
 8214008:	10001026 	beq	r2,zero,821404c <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 821400c:	e0bffd17 	ldw	r2,-12(fp)
 8214010:	10800017 	ldw	r2,0(r2)
 8214014:	10800817 	ldw	r2,32(r2)
 8214018:	10000726 	beq	r2,zero,8214038 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 821401c:	e0bffd17 	ldw	r2,-12(fp)
 8214020:	10800017 	ldw	r2,0(r2)
 8214024:	10800817 	ldw	r2,32(r2)
 8214028:	e17fff17 	ldw	r5,-4(fp)
 821402c:	e13ffd17 	ldw	r4,-12(fp)
 8214030:	103ee83a 	callr	r2
 8214034:	00000a06 	br	8214060 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 8214038:	e0bfff17 	ldw	r2,-4(fp)
 821403c:	00c80004 	movi	r3,8192
 8214040:	10c00115 	stw	r3,4(r2)
      return 0;
 8214044:	0005883a 	mov	r2,zero
 8214048:	00000506 	br	8214060 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 821404c:	8213f880 	call	8213f88 <alt_get_errno>
 8214050:	1007883a 	mov	r3,r2
 8214054:	00801444 	movi	r2,81
 8214058:	18800015 	stw	r2,0(r3)
    return -1;
 821405c:	00bfffc4 	movi	r2,-1
  }
}
 8214060:	e037883a 	mov	sp,fp
 8214064:	dfc00117 	ldw	ra,4(sp)
 8214068:	df000017 	ldw	fp,0(sp)
 821406c:	dec00204 	addi	sp,sp,8
 8214070:	f800283a 	ret

08214074 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8214074:	defffe04 	addi	sp,sp,-8
 8214078:	dfc00115 	stw	ra,4(sp)
 821407c:	df000015 	stw	fp,0(sp)
 8214080:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8214084:	d0a04717 	ldw	r2,-32484(gp)
 8214088:	10000326 	beq	r2,zero,8214098 <alt_get_errno+0x24>
 821408c:	d0a04717 	ldw	r2,-32484(gp)
 8214090:	103ee83a 	callr	r2
 8214094:	00000106 	br	821409c <alt_get_errno+0x28>
 8214098:	d0a06304 	addi	r2,gp,-32372
}
 821409c:	e037883a 	mov	sp,fp
 82140a0:	dfc00117 	ldw	ra,4(sp)
 82140a4:	df000017 	ldw	fp,0(sp)
 82140a8:	dec00204 	addi	sp,sp,8
 82140ac:	f800283a 	ret

082140b0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 82140b0:	deffed04 	addi	sp,sp,-76
 82140b4:	dfc01215 	stw	ra,72(sp)
 82140b8:	df001115 	stw	fp,68(sp)
 82140bc:	df001104 	addi	fp,sp,68
 82140c0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 82140c4:	e0bfff17 	ldw	r2,-4(fp)
 82140c8:	10000616 	blt	r2,zero,82140e4 <isatty+0x34>
 82140cc:	e0bfff17 	ldw	r2,-4(fp)
 82140d0:	10c00324 	muli	r3,r2,12
 82140d4:	00820974 	movhi	r2,2085
 82140d8:	108d6a04 	addi	r2,r2,13736
 82140dc:	1885883a 	add	r2,r3,r2
 82140e0:	00000106 	br	82140e8 <isatty+0x38>
 82140e4:	0005883a 	mov	r2,zero
 82140e8:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 82140ec:	e0bfef17 	ldw	r2,-68(fp)
 82140f0:	10000e26 	beq	r2,zero,821412c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 82140f4:	e0bfef17 	ldw	r2,-68(fp)
 82140f8:	10800017 	ldw	r2,0(r2)
 82140fc:	10800817 	ldw	r2,32(r2)
 8214100:	1000021e 	bne	r2,zero,821410c <isatty+0x5c>
    {
      return 1;
 8214104:	00800044 	movi	r2,1
 8214108:	00000d06 	br	8214140 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 821410c:	e0bff004 	addi	r2,fp,-64
 8214110:	100b883a 	mov	r5,r2
 8214114:	e13fff17 	ldw	r4,-4(fp)
 8214118:	8213fc40 	call	8213fc4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 821411c:	e0bff117 	ldw	r2,-60(fp)
 8214120:	10880020 	cmpeqi	r2,r2,8192
 8214124:	10803fcc 	andi	r2,r2,255
 8214128:	00000506 	br	8214140 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 821412c:	82140740 	call	8214074 <alt_get_errno>
 8214130:	1007883a 	mov	r3,r2
 8214134:	00801444 	movi	r2,81
 8214138:	18800015 	stw	r2,0(r3)
    return 0;
 821413c:	0005883a 	mov	r2,zero
  }
}
 8214140:	e037883a 	mov	sp,fp
 8214144:	dfc00117 	ldw	ra,4(sp)
 8214148:	df000017 	ldw	fp,0(sp)
 821414c:	dec00204 	addi	sp,sp,8
 8214150:	f800283a 	ret

08214154 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8214154:	defffe04 	addi	sp,sp,-8
 8214158:	dfc00115 	stw	ra,4(sp)
 821415c:	df000015 	stw	fp,0(sp)
 8214160:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8214164:	d0a04717 	ldw	r2,-32484(gp)
 8214168:	10000326 	beq	r2,zero,8214178 <alt_get_errno+0x24>
 821416c:	d0a04717 	ldw	r2,-32484(gp)
 8214170:	103ee83a 	callr	r2
 8214174:	00000106 	br	821417c <alt_get_errno+0x28>
 8214178:	d0a06304 	addi	r2,gp,-32372
}
 821417c:	e037883a 	mov	sp,fp
 8214180:	dfc00117 	ldw	ra,4(sp)
 8214184:	df000017 	ldw	fp,0(sp)
 8214188:	dec00204 	addi	sp,sp,8
 821418c:	f800283a 	ret

08214190 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 8214190:	defff904 	addi	sp,sp,-28
 8214194:	dfc00615 	stw	ra,24(sp)
 8214198:	df000515 	stw	fp,20(sp)
 821419c:	df000504 	addi	fp,sp,20
 82141a0:	e13ffd15 	stw	r4,-12(fp)
 82141a4:	e17ffe15 	stw	r5,-8(fp)
 82141a8:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 82141ac:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 82141b0:	e0bffd17 	ldw	r2,-12(fp)
 82141b4:	10000616 	blt	r2,zero,82141d0 <lseek+0x40>
 82141b8:	e0bffd17 	ldw	r2,-12(fp)
 82141bc:	10c00324 	muli	r3,r2,12
 82141c0:	00820974 	movhi	r2,2085
 82141c4:	108d6a04 	addi	r2,r2,13736
 82141c8:	1885883a 	add	r2,r3,r2
 82141cc:	00000106 	br	82141d4 <lseek+0x44>
 82141d0:	0005883a 	mov	r2,zero
 82141d4:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 82141d8:	e0bffc17 	ldw	r2,-16(fp)
 82141dc:	10001026 	beq	r2,zero,8214220 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 82141e0:	e0bffc17 	ldw	r2,-16(fp)
 82141e4:	10800017 	ldw	r2,0(r2)
 82141e8:	10800717 	ldw	r2,28(r2)
 82141ec:	10000926 	beq	r2,zero,8214214 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 82141f0:	e0bffc17 	ldw	r2,-16(fp)
 82141f4:	10800017 	ldw	r2,0(r2)
 82141f8:	10800717 	ldw	r2,28(r2)
 82141fc:	e1bfff17 	ldw	r6,-4(fp)
 8214200:	e17ffe17 	ldw	r5,-8(fp)
 8214204:	e13ffc17 	ldw	r4,-16(fp)
 8214208:	103ee83a 	callr	r2
 821420c:	e0bffb15 	stw	r2,-20(fp)
 8214210:	00000506 	br	8214228 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 8214214:	00bfde84 	movi	r2,-134
 8214218:	e0bffb15 	stw	r2,-20(fp)
 821421c:	00000206 	br	8214228 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 8214220:	00bfebc4 	movi	r2,-81
 8214224:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 8214228:	e0bffb17 	ldw	r2,-20(fp)
 821422c:	1000070e 	bge	r2,zero,821424c <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 8214230:	82141540 	call	8214154 <alt_get_errno>
 8214234:	1007883a 	mov	r3,r2
 8214238:	e0bffb17 	ldw	r2,-20(fp)
 821423c:	0085c83a 	sub	r2,zero,r2
 8214240:	18800015 	stw	r2,0(r3)
    rc = -1;
 8214244:	00bfffc4 	movi	r2,-1
 8214248:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 821424c:	e0bffb17 	ldw	r2,-20(fp)
}
 8214250:	e037883a 	mov	sp,fp
 8214254:	dfc00117 	ldw	ra,4(sp)
 8214258:	df000017 	ldw	fp,0(sp)
 821425c:	dec00204 	addi	sp,sp,8
 8214260:	f800283a 	ret

08214264 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 8214264:	defff904 	addi	sp,sp,-28
 8214268:	dfc00615 	stw	ra,24(sp)
 821426c:	df000515 	stw	fp,20(sp)
 8214270:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 8214274:	0009883a 	mov	r4,zero
 8214278:	821c0340 	call	821c034 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 821427c:	82150880 	call	8215088 <OSInit>
 8214280:	01000044 	movi	r4,1
 8214284:	82199f00 	call	82199f0 <OSSemCreate>
 8214288:	d0a06815 	stw	r2,-32352(gp)
 821428c:	01000044 	movi	r4,1
 8214290:	82199f00 	call	82199f0 <OSSemCreate>
 8214294:	d0a06a15 	stw	r2,-32344(gp)
 8214298:	d0a0b604 	addi	r2,gp,-32040
 821429c:	e0bffc15 	stw	r2,-16(fp)
 82142a0:	00800044 	movi	r2,1
 82142a4:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 82142a8:	e0bffd0b 	ldhu	r2,-12(fp)
 82142ac:	1009883a 	mov	r4,r2
 82142b0:	82199f00 	call	82199f0 <OSSemCreate>
 82142b4:	1007883a 	mov	r3,r2
 82142b8:	e0bffc17 	ldw	r2,-16(fp)
 82142bc:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 82142c0:	821c06c0 	call	821c06c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 82142c4:	01820974 	movhi	r6,2085
 82142c8:	31b61204 	addi	r6,r6,-10168
 82142cc:	01420974 	movhi	r5,2085
 82142d0:	29761204 	addi	r5,r5,-10168
 82142d4:	01020974 	movhi	r4,2085
 82142d8:	21361204 	addi	r4,r4,-10168
 82142dc:	823c0d00 	call	823c0d0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 82142e0:	823bc1c0 	call	823bc1c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 82142e4:	01020934 	movhi	r4,2084
 82142e8:	212f1f04 	addi	r4,r4,-17284
 82142ec:	824b1280 	call	824b128 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 82142f0:	d0a06417 	ldw	r2,-32368(gp)
 82142f4:	d0e06517 	ldw	r3,-32364(gp)
 82142f8:	d1206617 	ldw	r4,-32360(gp)
 82142fc:	200d883a 	mov	r6,r4
 8214300:	180b883a 	mov	r5,r3
 8214304:	1009883a 	mov	r4,r2
 8214308:	8200d180 	call	8200d18 <main>
 821430c:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 8214310:	01000044 	movi	r4,1
 8214314:	822546c0 	call	822546c <close>
  exit (result);
 8214318:	e13ffb17 	ldw	r4,-20(fp)
 821431c:	824b1540 	call	824b154 <exit>

08214320 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 8214320:	defff904 	addi	sp,sp,-28
 8214324:	df000615 	stw	fp,24(sp)
 8214328:	df000604 	addi	fp,sp,24
 821432c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214330:	0005303a 	rdctl	r2,status
 8214334:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214338:	e0fffe17 	ldw	r3,-8(fp)
 821433c:	00bfff84 	movi	r2,-2
 8214340:	1884703a 	and	r2,r3,r2
 8214344:	1001703a 	wrctl	status,r2
  
  return context;
 8214348:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 821434c:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 8214350:	d0a00917 	ldw	r2,-32732(gp)
 8214354:	10c000c4 	addi	r3,r2,3
 8214358:	00bfff04 	movi	r2,-4
 821435c:	1884703a 	and	r2,r3,r2
 8214360:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 8214364:	d0e00917 	ldw	r3,-32732(gp)
 8214368:	e0bfff17 	ldw	r2,-4(fp)
 821436c:	1887883a 	add	r3,r3,r2
 8214370:	00820e34 	movhi	r2,2104
 8214374:	10800004 	addi	r2,r2,0
 8214378:	10c0062e 	bgeu	r2,r3,8214394 <sbrk+0x74>
 821437c:	e0bffb17 	ldw	r2,-20(fp)
 8214380:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214384:	e0bffa17 	ldw	r2,-24(fp)
 8214388:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 821438c:	00bfffc4 	movi	r2,-1
 8214390:	00000b06 	br	82143c0 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 8214394:	d0a00917 	ldw	r2,-32732(gp)
 8214398:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 821439c:	d0e00917 	ldw	r3,-32732(gp)
 82143a0:	e0bfff17 	ldw	r2,-4(fp)
 82143a4:	1885883a 	add	r2,r3,r2
 82143a8:	d0a00915 	stw	r2,-32732(gp)
 82143ac:	e0bffb17 	ldw	r2,-20(fp)
 82143b0:	e0bffc15 	stw	r2,-16(fp)
 82143b4:	e0bffc17 	ldw	r2,-16(fp)
 82143b8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 82143bc:	e0bffd17 	ldw	r2,-12(fp)
} 
 82143c0:	e037883a 	mov	sp,fp
 82143c4:	df000017 	ldw	fp,0(sp)
 82143c8:	dec00104 	addi	sp,sp,4
 82143cc:	f800283a 	ret

082143d0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 82143d0:	defffb04 	addi	sp,sp,-20
 82143d4:	dfc00415 	stw	ra,16(sp)
 82143d8:	df000315 	stw	fp,12(sp)
 82143dc:	df000304 	addi	fp,sp,12
 82143e0:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 82143e4:	d0a06b43 	ldbu	r2,-32339(gp)
 82143e8:	10803fcc 	andi	r2,r2,255
 82143ec:	1000031e 	bne	r2,zero,82143fc <usleep+0x2c>
  {
    return alt_busy_sleep (us);
 82143f0:	e13fff17 	ldw	r4,-4(fp)
 82143f4:	823b8340 	call	823b834 <alt_busy_sleep>
 82143f8:	00003e06 	br	82144f4 <usleep+0x124>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 82143fc:	d0a0b817 	ldw	r2,-32032(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 8214400:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 8214404:	e0ffff17 	ldw	r3,-4(fp)
 8214408:	0090c734 	movhi	r2,17180
 821440c:	10b7a0c4 	addi	r2,r2,-8573
 8214410:	1888383a 	mulxuu	r4,r3,r2
 8214414:	1885383a 	mul	r2,r3,r2
 8214418:	1013883a 	mov	r9,r2
 821441c:	2015883a 	mov	r10,r4
 8214420:	5006d4ba 	srli	r3,r10,18
 8214424:	e0bffe17 	ldw	r2,-8(fp)
 8214428:	1893383a 	mul	r9,r3,r2
 821442c:	e0ffff17 	ldw	r3,-4(fp)
 8214430:	0090c734 	movhi	r2,17180
 8214434:	10b7a0c4 	addi	r2,r2,-8573
 8214438:	1888383a 	mulxuu	r4,r3,r2
 821443c:	1885383a 	mul	r2,r3,r2
 8214440:	100f883a 	mov	r7,r2
 8214444:	2011883a 	mov	r8,r4
 8214448:	4004d4ba 	srli	r2,r8,18
 821444c:	010003f4 	movhi	r4,15
 8214450:	21109004 	addi	r4,r4,16960
 8214454:	1105383a 	mul	r2,r2,r4
 8214458:	1885c83a 	sub	r2,r3,r2
 821445c:	e0fffe17 	ldw	r3,-8(fp)
 8214460:	10c7383a 	mul	r3,r2,r3
 8214464:	0090c734 	movhi	r2,17180
 8214468:	10b7a0c4 	addi	r2,r2,-8573
 821446c:	1888383a 	mulxuu	r4,r3,r2
 8214470:	1885383a 	mul	r2,r3,r2
 8214474:	100b883a 	mov	r5,r2
 8214478:	200d883a 	mov	r6,r4
 821447c:	3004d4ba 	srli	r2,r6,18
 8214480:	4885883a 	add	r2,r9,r2
 8214484:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 8214488:	00000706 	br	82144a8 <usleep+0xd8>
  {
    OSTimeDly(0xffff);
 821448c:	013fffd4 	movui	r4,65535
 8214490:	821bb0c0 	call	821bb0c <OSTimeDly>
    ticks -= 0xffff;
 8214494:	e0fffd17 	ldw	r3,-12(fp)
 8214498:	00bffff4 	movhi	r2,65535
 821449c:	10800044 	addi	r2,r2,1
 82144a0:	1885883a 	add	r2,r3,r2
 82144a4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 82144a8:	e0bffd17 	ldw	r2,-12(fp)
 82144ac:	00ffffd4 	movui	r3,65535
 82144b0:	18bff636 	bltu	r3,r2,821448c <usleep+0xbc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 82144b4:	e0bffd17 	ldw	r2,-12(fp)
 82144b8:	10bfffcc 	andi	r2,r2,65535
 82144bc:	1009883a 	mov	r4,r2
 82144c0:	821bb0c0 	call	821bb0c <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 82144c4:	e17ffe17 	ldw	r5,-8(fp)
 82144c8:	010003f4 	movhi	r4,15
 82144cc:	21109004 	addi	r4,r4,16960
 82144d0:	820270c0 	call	820270c <__udivsi3>
 82144d4:	1007883a 	mov	r3,r2
 82144d8:	e0bfff17 	ldw	r2,-4(fp)
 82144dc:	180b883a 	mov	r5,r3
 82144e0:	1009883a 	mov	r4,r2
 82144e4:	82027700 	call	8202770 <__umodsi3>
 82144e8:	1009883a 	mov	r4,r2
 82144ec:	823b8340 	call	823b834 <alt_busy_sleep>

  return 0;  
 82144f0:	0005883a 	mov	r2,zero
}
 82144f4:	e037883a 	mov	sp,fp
 82144f8:	dfc00117 	ldw	ra,4(sp)
 82144fc:	df000017 	ldw	fp,0(sp)
 8214500:	dec00204 	addi	sp,sp,8
 8214504:	f800283a 	ret

08214508 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 8214508:	deffdf04 	addi	sp,sp,-132
 821450c:	dfc02015 	stw	ra,128(sp)
 8214510:	df001f15 	stw	fp,124(sp)
 8214514:	df001f04 	addi	fp,sp,124
 8214518:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 821451c:	e0bfe204 	addi	r2,fp,-120
 8214520:	100b883a 	mov	r5,r2
 8214524:	01003fc4 	movi	r4,255
 8214528:	821b9780 	call	821b978 <OSTaskQuery>
 821452c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214530:	e0bffe83 	ldbu	r2,-6(fp)
 8214534:	10803fcc 	andi	r2,r2,255
 8214538:	10001e1e 	bne	r2,zero,82145b4 <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
 821453c:	e0bfee83 	ldbu	r2,-70(fp)
 8214540:	10803fcc 	andi	r2,r2,255
 8214544:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 8214548:	d0a06817 	ldw	r2,-32352(gp)
 821454c:	e0fffd04 	addi	r3,fp,-12
 8214550:	180b883a 	mov	r5,r3
 8214554:	1009883a 	mov	r4,r2
 8214558:	821a1900 	call	821a190 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 821455c:	e0bffe43 	ldbu	r2,-7(fp)
 8214560:	10803fcc 	andi	r2,r2,255
 8214564:	10000726 	beq	r2,zero,8214584 <__env_lock+0x7c>
 8214568:	d0a00a17 	ldw	r2,-32728(gp)
 821456c:	e0ffe117 	ldw	r3,-124(fp)
 8214570:	1880041e 	bne	r3,r2,8214584 <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 8214574:	d0a06717 	ldw	r2,-32356(gp)
 8214578:	10800044 	addi	r2,r2,1
 821457c:	d0a06715 	stw	r2,-32356(gp)
 8214580:	00000a06 	br	82145ac <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 8214584:	d0a06817 	ldw	r2,-32352(gp)
 8214588:	e0fffe84 	addi	r3,fp,-6
 821458c:	180d883a 	mov	r6,r3
 8214590:	000b883a 	mov	r5,zero
 8214594:	1009883a 	mov	r4,r2
 8214598:	8219d080 	call	8219d08 <OSSemPend>
    locks  = 1;
 821459c:	00800044 	movi	r2,1
 82145a0:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 82145a4:	e0bfe117 	ldw	r2,-124(fp)
 82145a8:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 82145ac:	0001883a 	nop
 82145b0:	00000106 	br	82145b8 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 82145b4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 82145b8:	e037883a 	mov	sp,fp
 82145bc:	dfc00117 	ldw	ra,4(sp)
 82145c0:	df000017 	ldw	fp,0(sp)
 82145c4:	dec00204 	addi	sp,sp,8
 82145c8:	f800283a 	ret

082145cc <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 82145cc:	defffd04 	addi	sp,sp,-12
 82145d0:	dfc00215 	stw	ra,8(sp)
 82145d4:	df000115 	stw	fp,4(sp)
 82145d8:	df000104 	addi	fp,sp,4
 82145dc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 82145e0:	d0a06717 	ldw	r2,-32356(gp)
 82145e4:	10000b26 	beq	r2,zero,8214614 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 82145e8:	d0a06717 	ldw	r2,-32356(gp)
 82145ec:	10bfffc4 	addi	r2,r2,-1
 82145f0:	d0a06715 	stw	r2,-32356(gp)
 82145f4:	d0a06717 	ldw	r2,-32356(gp)
 82145f8:	1000071e 	bne	r2,zero,8214618 <__env_unlock+0x4c>
  {
    lockid = -1;
 82145fc:	00bfffc4 	movi	r2,-1
 8214600:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 8214604:	d0a06817 	ldw	r2,-32352(gp)
 8214608:	1009883a 	mov	r4,r2
 821460c:	821a0800 	call	821a080 <OSSemPost>
 8214610:	00000106 	br	8214618 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 8214614:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214618:	e037883a 	mov	sp,fp
 821461c:	dfc00117 	ldw	ra,4(sp)
 8214620:	df000017 	ldw	fp,0(sp)
 8214624:	dec00204 	addi	sp,sp,8
 8214628:	f800283a 	ret

0821462c <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 821462c:	deffdb04 	addi	sp,sp,-148
 8214630:	dfc02415 	stw	ra,144(sp)
 8214634:	df002315 	stw	fp,140(sp)
 8214638:	df002304 	addi	fp,sp,140
 821463c:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214640:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 8214644:	d0a06b43 	ldbu	r2,-32339(gp)
 8214648:	10803fcc 	andi	r2,r2,255
 821464c:	10800060 	cmpeqi	r2,r2,1
 8214650:	10003626 	beq	r2,zero,821472c <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 8214654:	e0bfe204 	addi	r2,fp,-120
 8214658:	100b883a 	mov	r5,r2
 821465c:	01003fc4 	movi	r4,255
 8214660:	821b9780 	call	821b978 <OSTaskQuery>
 8214664:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214668:	e0bffe83 	ldbu	r2,-6(fp)
 821466c:	10803fcc 	andi	r2,r2,255
 8214670:	1000301e 	bne	r2,zero,8214734 <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
 8214674:	e0bfee83 	ldbu	r2,-70(fp)
 8214678:	10803fcc 	andi	r2,r2,255
 821467c:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 8214680:	d0a06a17 	ldw	r2,-32344(gp)
 8214684:	e0fffd04 	addi	r3,fp,-12
 8214688:	180b883a 	mov	r5,r3
 821468c:	1009883a 	mov	r4,r2
 8214690:	821a1900 	call	821a190 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214694:	0005303a 	rdctl	r2,status
 8214698:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821469c:	e0ffe117 	ldw	r3,-124(fp)
 82146a0:	00bfff84 	movi	r2,-2
 82146a4:	1884703a 	and	r2,r3,r2
 82146a8:	1001703a 	wrctl	status,r2
  
  return context;
 82146ac:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
 82146b0:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 82146b4:	e0bffd0b 	ldhu	r2,-12(fp)
 82146b8:	10bfffcc 	andi	r2,r2,65535
 82146bc:	10000b1e 	bne	r2,zero,82146ec <__malloc_lock+0xc0>
 82146c0:	d0a00b17 	ldw	r2,-32724(gp)
 82146c4:	e0ffde17 	ldw	r3,-136(fp)
 82146c8:	1880081e 	bne	r3,r2,82146ec <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
 82146cc:	d0a06917 	ldw	r2,-32348(gp)
 82146d0:	10800044 	addi	r2,r2,1
 82146d4:	d0a06915 	stw	r2,-32348(gp)
 82146d8:	e0bfdd17 	ldw	r2,-140(fp)
 82146dc:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82146e0:	e0bfdf17 	ldw	r2,-132(fp)
 82146e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 82146e8:	00000e06 	br	8214724 <__malloc_lock+0xf8>
 82146ec:	e0bfdd17 	ldw	r2,-140(fp)
 82146f0:	e0bfe015 	stw	r2,-128(fp)
 82146f4:	e0bfe017 	ldw	r2,-128(fp)
 82146f8:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 82146fc:	d0a06a17 	ldw	r2,-32344(gp)
 8214700:	e0fffe84 	addi	r3,fp,-6
 8214704:	180d883a 	mov	r6,r3
 8214708:	000b883a 	mov	r5,zero
 821470c:	1009883a 	mov	r4,r2
 8214710:	8219d080 	call	8219d08 <OSSemPend>
    locks  = 1;
 8214714:	00800044 	movi	r2,1
 8214718:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 821471c:	e0bfde17 	ldw	r2,-136(fp)
 8214720:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 8214724:	0001883a 	nop
 8214728:	00000306 	br	8214738 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
 821472c:	0001883a 	nop
 8214730:	00000106 	br	8214738 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 8214734:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214738:	e037883a 	mov	sp,fp
 821473c:	dfc00117 	ldw	ra,4(sp)
 8214740:	df000017 	ldw	fp,0(sp)
 8214744:	dec00204 	addi	sp,sp,8
 8214748:	f800283a 	ret

0821474c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 821474c:	defff804 	addi	sp,sp,-32
 8214750:	dfc00715 	stw	ra,28(sp)
 8214754:	df000615 	stw	fp,24(sp)
 8214758:	df000604 	addi	fp,sp,24
 821475c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214760:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 8214764:	d0a06b43 	ldbu	r2,-32339(gp)
 8214768:	10803fcc 	andi	r2,r2,255
 821476c:	10800060 	cmpeqi	r2,r2,1
 8214770:	10002326 	beq	r2,zero,8214800 <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214774:	0005303a 	rdctl	r2,status
 8214778:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821477c:	e0fffe17 	ldw	r3,-8(fp)
 8214780:	00bfff84 	movi	r2,-2
 8214784:	1884703a 	and	r2,r3,r2
 8214788:	1001703a 	wrctl	status,r2
  
  return context;
 821478c:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
 8214790:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 8214794:	d0a06917 	ldw	r2,-32348(gp)
 8214798:	1000051e 	bne	r2,zero,82147b0 <__malloc_unlock+0x64>
 821479c:	e0bffa17 	ldw	r2,-24(fp)
 82147a0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82147a4:	e0bffb17 	ldw	r2,-20(fp)
 82147a8:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 82147ac:	00001506 	br	8214804 <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 82147b0:	d0a06917 	ldw	r2,-32348(gp)
 82147b4:	10bfffc4 	addi	r2,r2,-1
 82147b8:	d0a06915 	stw	r2,-32348(gp)
 82147bc:	d0a06917 	ldw	r2,-32348(gp)
 82147c0:	10000a1e 	bne	r2,zero,82147ec <__malloc_unlock+0xa0>
  {
    lockid = -1;
 82147c4:	00bfffc4 	movi	r2,-1
 82147c8:	d0a00b15 	stw	r2,-32724(gp)
 82147cc:	e0bffa17 	ldw	r2,-24(fp)
 82147d0:	e0bffc15 	stw	r2,-16(fp)
 82147d4:	e0bffc17 	ldw	r2,-16(fp)
 82147d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 82147dc:	d0a06a17 	ldw	r2,-32344(gp)
 82147e0:	1009883a 	mov	r4,r2
 82147e4:	821a0800 	call	821a080 <OSSemPost>
 82147e8:	00000606 	br	8214804 <__malloc_unlock+0xb8>
 82147ec:	e0bffa17 	ldw	r2,-24(fp)
 82147f0:	e0bffd15 	stw	r2,-12(fp)
 82147f4:	e0bffd17 	ldw	r2,-12(fp)
 82147f8:	1001703a 	wrctl	status,r2
 82147fc:	00000106 	br	8214804 <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 8214800:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214804:	e037883a 	mov	sp,fp
 8214808:	dfc00117 	ldw	ra,4(sp)
 821480c:	df000017 	ldw	fp,0(sp)
 8214810:	dec00204 	addi	sp,sp,8
 8214814:	f800283a 	ret

08214818 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214818:	defff704 	addi	sp,sp,-36
 821481c:	dfc00815 	stw	ra,32(sp)
 8214820:	df000715 	stw	fp,28(sp)
 8214824:	df000704 	addi	fp,sp,28
 8214828:	e13ffd15 	stw	r4,-12(fp)
 821482c:	e17ffe15 	stw	r5,-8(fp)
 8214830:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214834:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214838:	e0bfff17 	ldw	r2,-4(fp)
 821483c:	1000021e 	bne	r2,zero,8214848 <OSEventNameGet+0x30>
        return (0);
 8214840:	0005883a 	mov	r2,zero
 8214844:	00003706 	br	8214924 <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214848:	e0bffd17 	ldw	r2,-12(fp)
 821484c:	1000051e 	bne	r2,zero,8214864 <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 8214850:	e0bfff17 	ldw	r2,-4(fp)
 8214854:	00c00104 	movi	r3,4
 8214858:	10c00005 	stb	r3,0(r2)
        return (0);
 821485c:	0005883a 	mov	r2,zero
 8214860:	00003006 	br	8214924 <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214864:	e0bffe17 	ldw	r2,-8(fp)
 8214868:	1000051e 	bne	r2,zero,8214880 <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 821486c:	e0bfff17 	ldw	r2,-4(fp)
 8214870:	00c00304 	movi	r3,12
 8214874:	10c00005 	stb	r3,0(r2)
        return (0);
 8214878:	0005883a 	mov	r2,zero
 821487c:	00002906 	br	8214924 <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214880:	d0a07903 	ldbu	r2,-32284(gp)
 8214884:	10803fcc 	andi	r2,r2,255
 8214888:	10000526 	beq	r2,zero,82148a0 <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 821488c:	e0bfff17 	ldw	r2,-4(fp)
 8214890:	00c00444 	movi	r3,17
 8214894:	10c00005 	stb	r3,0(r2)
        return (0);
 8214898:	0005883a 	mov	r2,zero
 821489c:	00002106 	br	8214924 <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 82148a0:	e0bffd17 	ldw	r2,-12(fp)
 82148a4:	10800003 	ldbu	r2,0(r2)
 82148a8:	10803fcc 	andi	r2,r2,255
 82148ac:	10bfffc4 	addi	r2,r2,-1
 82148b0:	10800128 	cmpgeui	r2,r2,4
 82148b4:	10000526 	beq	r2,zero,82148cc <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 82148b8:	e0bfff17 	ldw	r2,-4(fp)
 82148bc:	00c00044 	movi	r3,1
 82148c0:	10c00005 	stb	r3,0(r2)
             return (0);
 82148c4:	0005883a 	mov	r2,zero
 82148c8:	00001606 	br	8214924 <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 82148cc:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82148d0:	0005303a 	rdctl	r2,status
 82148d4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82148d8:	e0fffb17 	ldw	r3,-20(fp)
 82148dc:	00bfff84 	movi	r2,-2
 82148e0:	1884703a 	and	r2,r3,r2
 82148e4:	1001703a 	wrctl	status,r2
  
  return context;
 82148e8:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 82148ec:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 82148f0:	e0bffd17 	ldw	r2,-12(fp)
 82148f4:	10800384 	addi	r2,r2,14
 82148f8:	100b883a 	mov	r5,r2
 82148fc:	e13ffe17 	ldw	r4,-8(fp)
 8214900:	821629c0 	call	821629c <OS_StrCopy>
 8214904:	e0bffa05 	stb	r2,-24(fp)
 8214908:	e0bff917 	ldw	r2,-28(fp)
 821490c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214910:	e0bffc17 	ldw	r2,-16(fp)
 8214914:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214918:	e0bfff17 	ldw	r2,-4(fp)
 821491c:	10000005 	stb	zero,0(r2)
    return (len);
 8214920:	e0bffa03 	ldbu	r2,-24(fp)
}
 8214924:	e037883a 	mov	sp,fp
 8214928:	dfc00117 	ldw	ra,4(sp)
 821492c:	df000017 	ldw	fp,0(sp)
 8214930:	dec00204 	addi	sp,sp,8
 8214934:	f800283a 	ret

08214938 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214938:	defff604 	addi	sp,sp,-40
 821493c:	dfc00915 	stw	ra,36(sp)
 8214940:	df000815 	stw	fp,32(sp)
 8214944:	df000804 	addi	fp,sp,32
 8214948:	e13ffd15 	stw	r4,-12(fp)
 821494c:	e17ffe15 	stw	r5,-8(fp)
 8214950:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214954:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214958:	e0bfff17 	ldw	r2,-4(fp)
 821495c:	10004026 	beq	r2,zero,8214a60 <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214960:	e0bffd17 	ldw	r2,-12(fp)
 8214964:	1000041e 	bne	r2,zero,8214978 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 8214968:	e0bfff17 	ldw	r2,-4(fp)
 821496c:	00c00104 	movi	r3,4
 8214970:	10c00005 	stb	r3,0(r2)
        return;
 8214974:	00003b06 	br	8214a64 <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214978:	e0bffe17 	ldw	r2,-8(fp)
 821497c:	1000041e 	bne	r2,zero,8214990 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8214980:	e0bfff17 	ldw	r2,-4(fp)
 8214984:	00c00304 	movi	r3,12
 8214988:	10c00005 	stb	r3,0(r2)
        return;
 821498c:	00003506 	br	8214a64 <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214990:	d0a07903 	ldbu	r2,-32284(gp)
 8214994:	10803fcc 	andi	r2,r2,255
 8214998:	10000426 	beq	r2,zero,82149ac <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 821499c:	e0bfff17 	ldw	r2,-4(fp)
 82149a0:	00c00484 	movi	r3,18
 82149a4:	10c00005 	stb	r3,0(r2)
        return;
 82149a8:	00002e06 	br	8214a64 <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
 82149ac:	e0bffd17 	ldw	r2,-12(fp)
 82149b0:	10800003 	ldbu	r2,0(r2)
 82149b4:	10803fcc 	andi	r2,r2,255
 82149b8:	10bfffc4 	addi	r2,r2,-1
 82149bc:	10800128 	cmpgeui	r2,r2,4
 82149c0:	10000426 	beq	r2,zero,82149d4 <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 82149c4:	e0bfff17 	ldw	r2,-4(fp)
 82149c8:	00c00044 	movi	r3,1
 82149cc:	10c00005 	stb	r3,0(r2)
             return;
 82149d0:	00002406 	br	8214a64 <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 82149d4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82149d8:	0005303a 	rdctl	r2,status
 82149dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82149e0:	e0fffc17 	ldw	r3,-16(fp)
 82149e4:	00bfff84 	movi	r2,-2
 82149e8:	1884703a 	and	r2,r3,r2
 82149ec:	1001703a 	wrctl	status,r2
  
  return context;
 82149f0:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 82149f4:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 82149f8:	e13ffe17 	ldw	r4,-8(fp)
 82149fc:	82163100 	call	8216310 <OS_StrLen>
 8214a00:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 8214a04:	e0bffa03 	ldbu	r2,-24(fp)
 8214a08:	10800830 	cmpltui	r2,r2,32
 8214a0c:	1000081e 	bne	r2,zero,8214a30 <OSEventNameSet+0xf8>
 8214a10:	e0bff817 	ldw	r2,-32(fp)
 8214a14:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214a18:	e0bff917 	ldw	r2,-28(fp)
 8214a1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 8214a20:	e0bfff17 	ldw	r2,-4(fp)
 8214a24:	00c002c4 	movi	r3,11
 8214a28:	10c00005 	stb	r3,0(r2)
        return;
 8214a2c:	00000d06 	br	8214a64 <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 8214a30:	e0bffd17 	ldw	r2,-12(fp)
 8214a34:	10800384 	addi	r2,r2,14
 8214a38:	e17ffe17 	ldw	r5,-8(fp)
 8214a3c:	1009883a 	mov	r4,r2
 8214a40:	821629c0 	call	821629c <OS_StrCopy>
 8214a44:	e0bff817 	ldw	r2,-32(fp)
 8214a48:	e0bffb15 	stw	r2,-20(fp)
 8214a4c:	e0bffb17 	ldw	r2,-20(fp)
 8214a50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214a54:	e0bfff17 	ldw	r2,-4(fp)
 8214a58:	10000005 	stb	zero,0(r2)
 8214a5c:	00000106 	br	8214a64 <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8214a60:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 8214a64:	e037883a 	mov	sp,fp
 8214a68:	dfc00117 	ldw	ra,4(sp)
 8214a6c:	df000017 	ldw	fp,0(sp)
 8214a70:	dec00204 	addi	sp,sp,8
 8214a74:	f800283a 	ret

08214a78 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 8214a78:	deffed04 	addi	sp,sp,-76
 8214a7c:	dfc01215 	stw	ra,72(sp)
 8214a80:	df001115 	stw	fp,68(sp)
 8214a84:	df001104 	addi	fp,sp,68
 8214a88:	e13ffc15 	stw	r4,-16(fp)
 8214a8c:	e17ffd15 	stw	r5,-12(fp)
 8214a90:	e1bffe15 	stw	r6,-8(fp)
 8214a94:	3805883a 	mov	r2,r7
 8214a98:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 8214a9c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 8214aa0:	e0800217 	ldw	r2,8(fp)
 8214aa4:	1000021e 	bne	r2,zero,8214ab0 <OSEventPendMulti+0x38>
        return (0);
 8214aa8:	0005883a 	mov	r2,zero
 8214aac:	00017106 	br	8215074 <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 8214ab0:	e0bffc17 	ldw	r2,-16(fp)
 8214ab4:	1000051e 	bne	r2,zero,8214acc <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 8214ab8:	e0800217 	ldw	r2,8(fp)
 8214abc:	00c00104 	movi	r3,4
 8214ac0:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ac4:	0005883a 	mov	r2,zero
 8214ac8:	00016a06 	br	8215074 <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 8214acc:	e0bffd17 	ldw	r2,-12(fp)
 8214ad0:	1000051e 	bne	r2,zero,8214ae8 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 8214ad4:	e0800217 	ldw	r2,8(fp)
 8214ad8:	00c00104 	movi	r3,4
 8214adc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ae0:	0005883a 	mov	r2,zero
 8214ae4:	00016306 	br	8215074 <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 8214ae8:	e0bffe17 	ldw	r2,-8(fp)
 8214aec:	1000051e 	bne	r2,zero,8214b04 <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 8214af0:	e0800217 	ldw	r2,8(fp)
 8214af4:	00c00104 	movi	r3,4
 8214af8:	10c00005 	stb	r3,0(r2)
        return (0);
 8214afc:	0005883a 	mov	r2,zero
 8214b00:	00015c06 	br	8215074 <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 8214b04:	e0bffd17 	ldw	r2,-12(fp)
 8214b08:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 8214b0c:	e0bffc17 	ldw	r2,-16(fp)
 8214b10:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 8214b14:	e0bfef17 	ldw	r2,-68(fp)
 8214b18:	10800017 	ldw	r2,0(r2)
 8214b1c:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 8214b20:	00001906 	br	8214b88 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 8214b24:	e0bff017 	ldw	r2,-64(fp)
 8214b28:	10800003 	ldbu	r2,0(r2)
 8214b2c:	10803fcc 	andi	r2,r2,255
 8214b30:	10c000a0 	cmpeqi	r3,r2,2
 8214b34:	1800091e 	bne	r3,zero,8214b5c <OSEventPendMulti+0xe4>
 8214b38:	10c000e0 	cmpeqi	r3,r2,3
 8214b3c:	1800091e 	bne	r3,zero,8214b64 <OSEventPendMulti+0xec>
 8214b40:	10800060 	cmpeqi	r2,r2,1
 8214b44:	1000091e 	bne	r2,zero,8214b6c <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 8214b48:	e0800217 	ldw	r2,8(fp)
 8214b4c:	00c00044 	movi	r3,1
 8214b50:	10c00005 	stb	r3,0(r2)
                 return (0);
 8214b54:	0005883a 	mov	r2,zero
 8214b58:	00014606 	br	8215074 <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 8214b5c:	0001883a 	nop
 8214b60:	00000306 	br	8214b70 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 8214b64:	0001883a 	nop
 8214b68:	00000106 	br	8214b70 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 8214b6c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 8214b70:	e0bfef17 	ldw	r2,-68(fp)
 8214b74:	10800104 	addi	r2,r2,4
 8214b78:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214b7c:	e0bfef17 	ldw	r2,-68(fp)
 8214b80:	10800017 	ldw	r2,0(r2)
 8214b84:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 8214b88:	e0bff017 	ldw	r2,-64(fp)
 8214b8c:	103fe51e 	bne	r2,zero,8214b24 <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 8214b90:	d0a07903 	ldbu	r2,-32284(gp)
 8214b94:	10803fcc 	andi	r2,r2,255
 8214b98:	10000526 	beq	r2,zero,8214bb0 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 8214b9c:	e0800217 	ldw	r2,8(fp)
 8214ba0:	00c00084 	movi	r3,2
 8214ba4:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ba8:	0005883a 	mov	r2,zero
 8214bac:	00013106 	br	8215074 <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 8214bb0:	d0a06b03 	ldbu	r2,-32340(gp)
 8214bb4:	10803fcc 	andi	r2,r2,255
 8214bb8:	10000526 	beq	r2,zero,8214bd0 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 8214bbc:	e0800217 	ldw	r2,8(fp)
 8214bc0:	00c00344 	movi	r3,13
 8214bc4:	10c00005 	stb	r3,0(r2)
        return (0);
 8214bc8:	0005883a 	mov	r2,zero
 8214bcc:	00012906 	br	8215074 <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214bd0:	0005303a 	rdctl	r2,status
 8214bd4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214bd8:	e0fffb17 	ldw	r3,-20(fp)
 8214bdc:	00bfff84 	movi	r2,-2
 8214be0:	1884703a 	and	r2,r3,r2
 8214be4:	1001703a 	wrctl	status,r2
  
  return context;
 8214be8:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 8214bec:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 8214bf0:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 8214bf4:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 8214bf8:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 8214bfc:	e0bffc17 	ldw	r2,-16(fp)
 8214c00:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 8214c04:	e0bfef17 	ldw	r2,-68(fp)
 8214c08:	10800017 	ldw	r2,0(r2)
 8214c0c:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8214c10:	00008106 	br	8214e18 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
 8214c14:	e0bff017 	ldw	r2,-64(fp)
 8214c18:	10800003 	ldbu	r2,0(r2)
 8214c1c:	10803fcc 	andi	r2,r2,255
 8214c20:	10c000a0 	cmpeqi	r3,r2,2
 8214c24:	18003c1e 	bne	r3,zero,8214d18 <OSEventPendMulti+0x2a0>
 8214c28:	10c000e0 	cmpeqi	r3,r2,3
 8214c2c:	1800031e 	bne	r3,zero,8214c3c <OSEventPendMulti+0x1c4>
 8214c30:	10800060 	cmpeqi	r2,r2,1
 8214c34:	10001e1e 	bne	r2,zero,8214cb0 <OSEventPendMulti+0x238>
 8214c38:	00006606 	br	8214dd4 <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 8214c3c:	e0bff017 	ldw	r2,-64(fp)
 8214c40:	1080020b 	ldhu	r2,8(r2)
 8214c44:	10bfffcc 	andi	r2,r2,65535
 8214c48:	10001526 	beq	r2,zero,8214ca0 <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 8214c4c:	e0bff017 	ldw	r2,-64(fp)
 8214c50:	1080020b 	ldhu	r2,8(r2)
 8214c54:	10bfffc4 	addi	r2,r2,-1
 8214c58:	1007883a 	mov	r3,r2
 8214c5c:	e0bff017 	ldw	r2,-64(fp)
 8214c60:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 8214c64:	e0bffd17 	ldw	r2,-12(fp)
 8214c68:	10c00104 	addi	r3,r2,4
 8214c6c:	e0fffd15 	stw	r3,-12(fp)
 8214c70:	e0fff017 	ldw	r3,-64(fp)
 8214c74:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
 8214c78:	00800044 	movi	r2,1
 8214c7c:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 8214c80:	e0bffe17 	ldw	r2,-8(fp)
 8214c84:	10c00104 	addi	r3,r2,4
 8214c88:	e0fffe15 	stw	r3,-8(fp)
 8214c8c:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
 8214c90:	e0bff18b 	ldhu	r2,-58(fp)
 8214c94:	10800044 	addi	r2,r2,1
 8214c98:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 8214c9c:	00005806 	br	8214e00 <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 8214ca0:	e0bff203 	ldbu	r2,-56(fp)
 8214ca4:	10800054 	ori	r2,r2,1
 8214ca8:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214cac:	00005406 	br	8214e00 <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 8214cb0:	e0bff017 	ldw	r2,-64(fp)
 8214cb4:	10800117 	ldw	r2,4(r2)
 8214cb8:	10001326 	beq	r2,zero,8214d08 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 8214cbc:	e0bffe17 	ldw	r2,-8(fp)
 8214cc0:	10c00104 	addi	r3,r2,4
 8214cc4:	e0fffe15 	stw	r3,-8(fp)
 8214cc8:	e0fff017 	ldw	r3,-64(fp)
 8214ccc:	18c00117 	ldw	r3,4(r3)
 8214cd0:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
 8214cd4:	e0bff017 	ldw	r2,-64(fp)
 8214cd8:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 8214cdc:	e0bffd17 	ldw	r2,-12(fp)
 8214ce0:	10c00104 	addi	r3,r2,4
 8214ce4:	e0fffd15 	stw	r3,-12(fp)
 8214ce8:	e0fff017 	ldw	r3,-64(fp)
 8214cec:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
 8214cf0:	00800044 	movi	r2,1
 8214cf4:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8214cf8:	e0bff18b 	ldhu	r2,-58(fp)
 8214cfc:	10800044 	addi	r2,r2,1
 8214d00:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 8214d04:	00003e06 	br	8214e00 <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 8214d08:	e0bff203 	ldbu	r2,-56(fp)
 8214d0c:	10800094 	ori	r2,r2,2
 8214d10:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214d14:	00003a06 	br	8214e00 <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 8214d18:	e0bff017 	ldw	r2,-64(fp)
 8214d1c:	10800117 	ldw	r2,4(r2)
 8214d20:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 8214d24:	e0bff517 	ldw	r2,-44(fp)
 8214d28:	1080058b 	ldhu	r2,22(r2)
 8214d2c:	10bfffcc 	andi	r2,r2,65535
 8214d30:	10002426 	beq	r2,zero,8214dc4 <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 8214d34:	e0bffe17 	ldw	r2,-8(fp)
 8214d38:	10c00104 	addi	r3,r2,4
 8214d3c:	e0fffe15 	stw	r3,-8(fp)
 8214d40:	e0fff517 	ldw	r3,-44(fp)
 8214d44:	18c00417 	ldw	r3,16(r3)
 8214d48:	19400104 	addi	r5,r3,4
 8214d4c:	e13ff517 	ldw	r4,-44(fp)
 8214d50:	21400415 	stw	r5,16(r4)
 8214d54:	18c00017 	ldw	r3,0(r3)
 8214d58:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 8214d5c:	e0bff517 	ldw	r2,-44(fp)
 8214d60:	10c00417 	ldw	r3,16(r2)
 8214d64:	e0bff517 	ldw	r2,-44(fp)
 8214d68:	10800217 	ldw	r2,8(r2)
 8214d6c:	1880041e 	bne	r3,r2,8214d80 <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 8214d70:	e0bff517 	ldw	r2,-44(fp)
 8214d74:	10c00117 	ldw	r3,4(r2)
 8214d78:	e0bff517 	ldw	r2,-44(fp)
 8214d7c:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 8214d80:	e0bff517 	ldw	r2,-44(fp)
 8214d84:	1080058b 	ldhu	r2,22(r2)
 8214d88:	10bfffc4 	addi	r2,r2,-1
 8214d8c:	1007883a 	mov	r3,r2
 8214d90:	e0bff517 	ldw	r2,-44(fp)
 8214d94:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 8214d98:	e0bffd17 	ldw	r2,-12(fp)
 8214d9c:	10c00104 	addi	r3,r2,4
 8214da0:	e0fffd15 	stw	r3,-12(fp)
 8214da4:	e0fff017 	ldw	r3,-64(fp)
 8214da8:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
 8214dac:	00800044 	movi	r2,1
 8214db0:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8214db4:	e0bff18b 	ldhu	r2,-58(fp)
 8214db8:	10800044 	addi	r2,r2,1
 8214dbc:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 8214dc0:	00000f06 	br	8214e00 <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 8214dc4:	e0bff203 	ldbu	r2,-56(fp)
 8214dc8:	10800114 	ori	r2,r2,4
 8214dcc:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214dd0:	00000b06 	br	8214e00 <OSEventPendMulti+0x388>
 8214dd4:	e0bff317 	ldw	r2,-52(fp)
 8214dd8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214ddc:	e0bff417 	ldw	r2,-48(fp)
 8214de0:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 8214de4:	e0bffd17 	ldw	r2,-12(fp)
 8214de8:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 8214dec:	e0800217 	ldw	r2,8(fp)
 8214df0:	00c00044 	movi	r3,1
 8214df4:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 8214df8:	e0bff18b 	ldhu	r2,-58(fp)
 8214dfc:	00009d06 	br	8215074 <OSEventPendMulti+0x5fc>
        }
        pevents++;
 8214e00:	e0bfef17 	ldw	r2,-68(fp)
 8214e04:	10800104 	addi	r2,r2,4
 8214e08:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214e0c:	e0bfef17 	ldw	r2,-68(fp)
 8214e10:	10800017 	ldw	r2,0(r2)
 8214e14:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8214e18:	e0bff017 	ldw	r2,-64(fp)
 8214e1c:	103f7d1e 	bne	r2,zero,8214c14 <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 8214e20:	e0bff103 	ldbu	r2,-60(fp)
 8214e24:	10800058 	cmpnei	r2,r2,1
 8214e28:	10000a1e 	bne	r2,zero,8214e54 <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 8214e2c:	e0bffd17 	ldw	r2,-12(fp)
 8214e30:	10000015 	stw	zero,0(r2)
 8214e34:	e0bff317 	ldw	r2,-52(fp)
 8214e38:	e0bff615 	stw	r2,-40(fp)
 8214e3c:	e0bff617 	ldw	r2,-40(fp)
 8214e40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 8214e44:	e0800217 	ldw	r2,8(fp)
 8214e48:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 8214e4c:	e0bff18b 	ldhu	r2,-58(fp)
 8214e50:	00008806 	br	8215074 <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 8214e54:	d0a07a17 	ldw	r2,-32280(gp)
 8214e58:	d0e07a17 	ldw	r3,-32280(gp)
 8214e5c:	19000c03 	ldbu	r4,48(r3)
 8214e60:	e0fff203 	ldbu	r3,-56(fp)
 8214e64:	20c6b03a 	or	r3,r4,r3
 8214e68:	1809883a 	mov	r4,r3
 8214e6c:	00ffe004 	movi	r3,-128
 8214e70:	20c6b03a 	or	r3,r4,r3
 8214e74:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8214e78:	d0a07a17 	ldw	r2,-32280(gp)
 8214e7c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 8214e80:	d0a07a17 	ldw	r2,-32280(gp)
 8214e84:	e0ffff0b 	ldhu	r3,-4(fp)
 8214e88:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 8214e8c:	e13ffc17 	ldw	r4,-16(fp)
 8214e90:	82159b40 	call	82159b4 <OS_EventTaskWaitMulti>
 8214e94:	e0bff317 	ldw	r2,-52(fp)
 8214e98:	e0bff915 	stw	r2,-28(fp)
 8214e9c:	e0bff917 	ldw	r2,-28(fp)
 8214ea0:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 8214ea4:	82161580 	call	8216158 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214ea8:	0005303a 	rdctl	r2,status
 8214eac:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214eb0:	e0fff717 	ldw	r3,-36(fp)
 8214eb4:	00bfff84 	movi	r2,-2
 8214eb8:	1884703a 	and	r2,r3,r2
 8214ebc:	1001703a 	wrctl	status,r2
  
  return context;
 8214ec0:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 8214ec4:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 8214ec8:	d0a07a17 	ldw	r2,-32280(gp)
 8214ecc:	10800c43 	ldbu	r2,49(r2)
 8214ed0:	10803fcc 	andi	r2,r2,255
 8214ed4:	10000226 	beq	r2,zero,8214ee0 <OSEventPendMulti+0x468>
 8214ed8:	108000a0 	cmpeqi	r2,r2,2
 8214edc:	10001826 	beq	r2,zero,8214f40 <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 8214ee0:	d0a07a17 	ldw	r2,-32280(gp)
 8214ee4:	10800717 	ldw	r2,28(r2)
 8214ee8:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 8214eec:	e0bff017 	ldw	r2,-64(fp)
 8214ef0:	10000b26 	beq	r2,zero,8214f20 <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 8214ef4:	e0bffd17 	ldw	r2,-12(fp)
 8214ef8:	10c00104 	addi	r3,r2,4
 8214efc:	e0fffd15 	stw	r3,-12(fp)
 8214f00:	e0fff017 	ldw	r3,-64(fp)
 8214f04:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 8214f08:	e0bffd17 	ldw	r2,-12(fp)
 8214f0c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 8214f10:	e0bff18b 	ldhu	r2,-58(fp)
 8214f14:	10800044 	addi	r2,r2,1
 8214f18:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 8214f1c:	00000d06 	br	8214f54 <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 8214f20:	d0a07a17 	ldw	r2,-32280(gp)
 8214f24:	00c00044 	movi	r3,1
 8214f28:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8214f2c:	d0a07a17 	ldw	r2,-32280(gp)
 8214f30:	e17ffc17 	ldw	r5,-16(fp)
 8214f34:	1009883a 	mov	r4,r2
 8214f38:	8215bbc0 	call	8215bbc <OS_EventTaskRemoveMulti>
             }
			 break;
 8214f3c:	00000506 	br	8214f54 <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8214f40:	d0a07a17 	ldw	r2,-32280(gp)
 8214f44:	e17ffc17 	ldw	r5,-16(fp)
 8214f48:	1009883a 	mov	r4,r2
 8214f4c:	8215bbc0 	call	8215bbc <OS_EventTaskRemoveMulti>
             break;
 8214f50:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 8214f54:	d0a07a17 	ldw	r2,-32280(gp)
 8214f58:	10800c43 	ldbu	r2,49(r2)
 8214f5c:	10803fcc 	andi	r2,r2,255
 8214f60:	10000326 	beq	r2,zero,8214f70 <OSEventPendMulti+0x4f8>
 8214f64:	108000a0 	cmpeqi	r2,r2,2
 8214f68:	1000231e 	bne	r2,zero,8214ff8 <OSEventPendMulti+0x580>
 8214f6c:	00002a06 	br	8215018 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 8214f70:	e0bff017 	ldw	r2,-64(fp)
 8214f74:	10800003 	ldbu	r2,0(r2)
 8214f78:	10803fcc 	andi	r2,r2,255
 8214f7c:	0080100e 	bge	zero,r2,8214fc0 <OSEventPendMulti+0x548>
 8214f80:	10c000d0 	cmplti	r3,r2,3
 8214f84:	1800071e 	bne	r3,zero,8214fa4 <OSEventPendMulti+0x52c>
 8214f88:	108000e0 	cmpeqi	r2,r2,3
 8214f8c:	10000c26 	beq	r2,zero,8214fc0 <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 8214f90:	e0bffe17 	ldw	r2,-8(fp)
 8214f94:	10c00104 	addi	r3,r2,4
 8214f98:	e0fffe15 	stw	r3,-8(fp)
 8214f9c:	10000015 	stw	zero,0(r2)
                      break;
 8214fa0:	00001206 	br	8214fec <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 8214fa4:	e0bffe17 	ldw	r2,-8(fp)
 8214fa8:	10c00104 	addi	r3,r2,4
 8214fac:	e0fffe15 	stw	r3,-8(fp)
 8214fb0:	d0e07a17 	ldw	r3,-32280(gp)
 8214fb4:	18c00917 	ldw	r3,36(r3)
 8214fb8:	10c00015 	stw	r3,0(r2)
                      break;
 8214fbc:	00000b06 	br	8214fec <OSEventPendMulti+0x574>
 8214fc0:	e0bff317 	ldw	r2,-52(fp)
 8214fc4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214fc8:	e0bff817 	ldw	r2,-32(fp)
 8214fcc:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 8214fd0:	e0bffd17 	ldw	r2,-12(fp)
 8214fd4:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 8214fd8:	e0800217 	ldw	r2,8(fp)
 8214fdc:	00c00044 	movi	r3,1
 8214fe0:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 8214fe4:	e0bff18b 	ldhu	r2,-58(fp)
 8214fe8:	00002206 	br	8215074 <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
 8214fec:	e0800217 	ldw	r2,8(fp)
 8214ff0:	10000005 	stb	zero,0(r2)
             break;
 8214ff4:	00001006 	br	8215038 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 8214ff8:	e0bffe17 	ldw	r2,-8(fp)
 8214ffc:	10c00104 	addi	r3,r2,4
 8215000:	e0fffe15 	stw	r3,-8(fp)
 8215004:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 8215008:	e0800217 	ldw	r2,8(fp)
 821500c:	00c00384 	movi	r3,14
 8215010:	10c00005 	stb	r3,0(r2)
             break;
 8215014:	00000806 	br	8215038 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 8215018:	e0bffe17 	ldw	r2,-8(fp)
 821501c:	10c00104 	addi	r3,r2,4
 8215020:	e0fffe15 	stw	r3,-8(fp)
 8215024:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 8215028:	e0800217 	ldw	r2,8(fp)
 821502c:	00c00284 	movi	r3,10
 8215030:	10c00005 	stb	r3,0(r2)
             break;
 8215034:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 8215038:	d0a07a17 	ldw	r2,-32280(gp)
 821503c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 8215040:	d0a07a17 	ldw	r2,-32280(gp)
 8215044:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 8215048:	d0a07a17 	ldw	r2,-32280(gp)
 821504c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8215050:	d0a07a17 	ldw	r2,-32280(gp)
 8215054:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 8215058:	d0a07a17 	ldw	r2,-32280(gp)
 821505c:	10000915 	stw	zero,36(r2)
 8215060:	e0bff317 	ldw	r2,-52(fp)
 8215064:	e0bffa15 	stw	r2,-24(fp)
 8215068:	e0bffa17 	ldw	r2,-24(fp)
 821506c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 8215070:	e0bff18b 	ldhu	r2,-58(fp)
}
 8215074:	e037883a 	mov	sp,fp
 8215078:	dfc00117 	ldw	ra,4(sp)
 821507c:	df000017 	ldw	fp,0(sp)
 8215080:	dec00204 	addi	sp,sp,8
 8215084:	f800283a 	ret

08215088 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 8215088:	defffe04 	addi	sp,sp,-8
 821508c:	dfc00115 	stw	ra,4(sp)
 8215090:	df000015 	stw	fp,0(sp)
 8215094:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 8215098:	823cbe80 	call	823cbe8 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 821509c:	8215e040 	call	8215e04 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 82150a0:	8215e4c0 	call	8215e4c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 82150a4:	8215fb80 	call	8215fb8 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 82150a8:	8215d240 	call	8215d24 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 82150ac:	8217e700 	call	8217e70 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 82150b0:	82187700 	call	8218770 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 82150b4:	82198980 	call	8219898 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 82150b8:	8215eb80 	call	8215eb8 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 82150bc:	8215f380 	call	8215f38 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 82150c0:	823cc080 	call	823cc08 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 82150c4:	82168440 	call	8216844 <OSDebugInit>
#endif
}
 82150c8:	0001883a 	nop
 82150cc:	e037883a 	mov	sp,fp
 82150d0:	dfc00117 	ldw	ra,4(sp)
 82150d4:	df000017 	ldw	fp,0(sp)
 82150d8:	dec00204 	addi	sp,sp,8
 82150dc:	f800283a 	ret

082150e0 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 82150e0:	deffff04 	addi	sp,sp,-4
 82150e4:	df000015 	stw	fp,0(sp)
 82150e8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
 82150ec:	d0a06b43 	ldbu	r2,-32339(gp)
 82150f0:	10803fcc 	andi	r2,r2,255
 82150f4:	10800058 	cmpnei	r2,r2,1
 82150f8:	1000071e 	bne	r2,zero,8215118 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
 82150fc:	d0a07903 	ldbu	r2,-32284(gp)
 8215100:	10803fcc 	andi	r2,r2,255
 8215104:	10803fe0 	cmpeqi	r2,r2,255
 8215108:	1000031e 	bne	r2,zero,8215118 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 821510c:	d0a07903 	ldbu	r2,-32284(gp)
 8215110:	10800044 	addi	r2,r2,1
 8215114:	d0a07905 	stb	r2,-32284(gp)
        }
    }
}
 8215118:	0001883a 	nop
 821511c:	e037883a 	mov	sp,fp
 8215120:	df000017 	ldw	fp,0(sp)
 8215124:	dec00104 	addi	sp,sp,4
 8215128:	f800283a 	ret

0821512c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 821512c:	defffb04 	addi	sp,sp,-20
 8215130:	dfc00415 	stw	ra,16(sp)
 8215134:	df000315 	stw	fp,12(sp)
 8215138:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821513c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 8215140:	d0a06b43 	ldbu	r2,-32339(gp)
 8215144:	10803fcc 	andi	r2,r2,255
 8215148:	10800058 	cmpnei	r2,r2,1
 821514c:	10002f1e 	bne	r2,zero,821520c <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215150:	0005303a 	rdctl	r2,status
 8215154:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215158:	e0ffff17 	ldw	r3,-4(fp)
 821515c:	00bfff84 	movi	r2,-2
 8215160:	1884703a 	and	r2,r3,r2
 8215164:	1001703a 	wrctl	status,r2
  
  return context;
 8215168:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 821516c:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 8215170:	d0a07903 	ldbu	r2,-32284(gp)
 8215174:	10803fcc 	andi	r2,r2,255
 8215178:	10000326 	beq	r2,zero,8215188 <OSIntExit+0x5c>
            OSIntNesting--;
 821517c:	d0a07903 	ldbu	r2,-32284(gp)
 8215180:	10bfffc4 	addi	r2,r2,-1
 8215184:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 8215188:	d0a07903 	ldbu	r2,-32284(gp)
 821518c:	10803fcc 	andi	r2,r2,255
 8215190:	10001a1e 	bne	r2,zero,82151fc <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 8215194:	d0a06b03 	ldbu	r2,-32340(gp)
 8215198:	10803fcc 	andi	r2,r2,255
 821519c:	1000171e 	bne	r2,zero,82151fc <OSIntExit+0xd0>
                OS_SchedNew();
 82151a0:	82162280 	call	8216228 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 82151a4:	d0e06d03 	ldbu	r3,-32332(gp)
 82151a8:	d0a06d43 	ldbu	r2,-32331(gp)
 82151ac:	18c03fcc 	andi	r3,r3,255
 82151b0:	10803fcc 	andi	r2,r2,255
 82151b4:	18801126 	beq	r3,r2,82151fc <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 82151b8:	d0a06d03 	ldbu	r2,-32332(gp)
 82151bc:	10c03fcc 	andi	r3,r2,255
 82151c0:	008209b4 	movhi	r2,2086
 82151c4:	10b54004 	addi	r2,r2,-11008
 82151c8:	18c7883a 	add	r3,r3,r3
 82151cc:	18c7883a 	add	r3,r3,r3
 82151d0:	10c5883a 	add	r2,r2,r3
 82151d4:	10800017 	ldw	r2,0(r2)
 82151d8:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 82151dc:	d0a07517 	ldw	r2,-32300(gp)
 82151e0:	10c00e17 	ldw	r3,56(r2)
 82151e4:	18c00044 	addi	r3,r3,1
 82151e8:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 82151ec:	d0a07017 	ldw	r2,-32320(gp)
 82151f0:	10800044 	addi	r2,r2,1
 82151f4:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 82151f8:	823c9080 	call	823c908 <OSCtxSw>
 82151fc:	e0bffd17 	ldw	r2,-12(fp)
 8215200:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215204:	e0bffe17 	ldw	r2,-8(fp)
 8215208:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 821520c:	0001883a 	nop
 8215210:	e037883a 	mov	sp,fp
 8215214:	dfc00117 	ldw	ra,4(sp)
 8215218:	df000017 	ldw	fp,0(sp)
 821521c:	dec00204 	addi	sp,sp,8
 8215220:	f800283a 	ret

08215224 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 8215224:	defffc04 	addi	sp,sp,-16
 8215228:	df000315 	stw	fp,12(sp)
 821522c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215230:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 8215234:	d0a06b43 	ldbu	r2,-32339(gp)
 8215238:	10803fcc 	andi	r2,r2,255
 821523c:	10800058 	cmpnei	r2,r2,1
 8215240:	1000161e 	bne	r2,zero,821529c <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215244:	0005303a 	rdctl	r2,status
 8215248:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821524c:	e0ffff17 	ldw	r3,-4(fp)
 8215250:	00bfff84 	movi	r2,-2
 8215254:	1884703a 	and	r2,r3,r2
 8215258:	1001703a 	wrctl	status,r2
  
  return context;
 821525c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215260:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 8215264:	d0a07903 	ldbu	r2,-32284(gp)
 8215268:	10803fcc 	andi	r2,r2,255
 821526c:	1000071e 	bne	r2,zero,821528c <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 8215270:	d0a06b03 	ldbu	r2,-32340(gp)
 8215274:	10803fcc 	andi	r2,r2,255
 8215278:	10803fe0 	cmpeqi	r2,r2,255
 821527c:	1000031e 	bne	r2,zero,821528c <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 8215280:	d0a06b03 	ldbu	r2,-32340(gp)
 8215284:	10800044 	addi	r2,r2,1
 8215288:	d0a06b05 	stb	r2,-32340(gp)
 821528c:	e0bffd17 	ldw	r2,-12(fp)
 8215290:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215294:	e0bffe17 	ldw	r2,-8(fp)
 8215298:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 821529c:	0001883a 	nop
 82152a0:	e037883a 	mov	sp,fp
 82152a4:	df000017 	ldw	fp,0(sp)
 82152a8:	dec00104 	addi	sp,sp,4
 82152ac:	f800283a 	ret

082152b0 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 82152b0:	defff804 	addi	sp,sp,-32
 82152b4:	dfc00715 	stw	ra,28(sp)
 82152b8:	df000615 	stw	fp,24(sp)
 82152bc:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82152c0:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 82152c4:	d0a06b43 	ldbu	r2,-32339(gp)
 82152c8:	10803fcc 	andi	r2,r2,255
 82152cc:	10800058 	cmpnei	r2,r2,1
 82152d0:	1000281e 	bne	r2,zero,8215374 <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82152d4:	0005303a 	rdctl	r2,status
 82152d8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82152dc:	e0ffff17 	ldw	r3,-4(fp)
 82152e0:	00bfff84 	movi	r2,-2
 82152e4:	1884703a 	and	r2,r3,r2
 82152e8:	1001703a 	wrctl	status,r2
  
  return context;
 82152ec:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 82152f0:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 82152f4:	d0a06b03 	ldbu	r2,-32340(gp)
 82152f8:	10803fcc 	andi	r2,r2,255
 82152fc:	10001926 	beq	r2,zero,8215364 <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 8215300:	d0a06b03 	ldbu	r2,-32340(gp)
 8215304:	10bfffc4 	addi	r2,r2,-1
 8215308:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 821530c:	d0a06b03 	ldbu	r2,-32340(gp)
 8215310:	10803fcc 	andi	r2,r2,255
 8215314:	10000e1e 	bne	r2,zero,8215350 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 8215318:	d0a07903 	ldbu	r2,-32284(gp)
 821531c:	10803fcc 	andi	r2,r2,255
 8215320:	1000061e 	bne	r2,zero,821533c <OSSchedUnlock+0x8c>
 8215324:	e0bffa17 	ldw	r2,-24(fp)
 8215328:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821532c:	e0bffb17 	ldw	r2,-20(fp)
 8215330:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 8215334:	82161580 	call	8216158 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 8215338:	00000e06 	br	8215374 <OSSchedUnlock+0xc4>
 821533c:	e0bffa17 	ldw	r2,-24(fp)
 8215340:	e0bffc15 	stw	r2,-16(fp)
 8215344:	e0bffc17 	ldw	r2,-16(fp)
 8215348:	1001703a 	wrctl	status,r2
 821534c:	00000906 	br	8215374 <OSSchedUnlock+0xc4>
 8215350:	e0bffa17 	ldw	r2,-24(fp)
 8215354:	e0bffd15 	stw	r2,-12(fp)
 8215358:	e0bffd17 	ldw	r2,-12(fp)
 821535c:	1001703a 	wrctl	status,r2
 8215360:	00000406 	br	8215374 <OSSchedUnlock+0xc4>
 8215364:	e0bffa17 	ldw	r2,-24(fp)
 8215368:	e0bffe15 	stw	r2,-8(fp)
 821536c:	e0bffe17 	ldw	r2,-8(fp)
 8215370:	1001703a 	wrctl	status,r2
 8215374:	0001883a 	nop
 8215378:	e037883a 	mov	sp,fp
 821537c:	dfc00117 	ldw	ra,4(sp)
 8215380:	df000017 	ldw	fp,0(sp)
 8215384:	dec00204 	addi	sp,sp,8
 8215388:	f800283a 	ret

0821538c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 821538c:	defffe04 	addi	sp,sp,-8
 8215390:	dfc00115 	stw	ra,4(sp)
 8215394:	df000015 	stw	fp,0(sp)
 8215398:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 821539c:	d0a06b43 	ldbu	r2,-32339(gp)
 82153a0:	10803fcc 	andi	r2,r2,255
 82153a4:	10000f1e 	bne	r2,zero,82153e4 <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 82153a8:	82162280 	call	8216228 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 82153ac:	d0a06d03 	ldbu	r2,-32332(gp)
 82153b0:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 82153b4:	d0a06d03 	ldbu	r2,-32332(gp)
 82153b8:	10c03fcc 	andi	r3,r2,255
 82153bc:	008209b4 	movhi	r2,2086
 82153c0:	10b54004 	addi	r2,r2,-11008
 82153c4:	18c7883a 	add	r3,r3,r3
 82153c8:	18c7883a 	add	r3,r3,r3
 82153cc:	10c5883a 	add	r2,r2,r3
 82153d0:	10800017 	ldw	r2,0(r2)
 82153d4:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 82153d8:	d0a07517 	ldw	r2,-32300(gp)
 82153dc:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 82153e0:	823c9940 	call	823c994 <OSStartHighRdy>
    }
}
 82153e4:	0001883a 	nop
 82153e8:	e037883a 	mov	sp,fp
 82153ec:	dfc00117 	ldw	ra,4(sp)
 82153f0:	df000017 	ldw	fp,0(sp)
 82153f4:	dec00204 	addi	sp,sp,8
 82153f8:	f800283a 	ret

082153fc <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 82153fc:	defff904 	addi	sp,sp,-28
 8215400:	dfc00615 	stw	ra,24(sp)
 8215404:	df000515 	stw	fp,20(sp)
 8215408:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821540c:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 8215410:	01000084 	movi	r4,2
 8215414:	821bb0c0 	call	821bb0c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215418:	0005303a 	rdctl	r2,status
 821541c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215420:	e0fffc17 	ldw	r3,-16(fp)
 8215424:	00bfff84 	movi	r2,-2
 8215428:	1884703a 	and	r2,r3,r2
 821542c:	1001703a 	wrctl	status,r2
  
  return context;
 8215430:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 8215434:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 8215438:	d0206c15 	stw	zero,-32336(gp)
 821543c:	e0bffb17 	ldw	r2,-20(fp)
 8215440:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215444:	e0bffd17 	ldw	r2,-12(fp)
 8215448:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 821544c:	01000284 	movi	r4,10
 8215450:	821bb0c0 	call	821bb0c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215454:	0005303a 	rdctl	r2,status
 8215458:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821545c:	e0fffe17 	ldw	r3,-8(fp)
 8215460:	00bfff84 	movi	r2,-2
 8215464:	1884703a 	and	r2,r3,r2
 8215468:	1001703a 	wrctl	status,r2
  
  return context;
 821546c:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 8215470:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 8215474:	d0a06c17 	ldw	r2,-32336(gp)
 8215478:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 821547c:	00800044 	movi	r2,1
 8215480:	d0a07d05 	stb	r2,-32268(gp)
 8215484:	e0bffb17 	ldw	r2,-20(fp)
 8215488:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821548c:	e0bfff17 	ldw	r2,-4(fp)
 8215490:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 8215494:	0001883a 	nop
 8215498:	e037883a 	mov	sp,fp
 821549c:	dfc00117 	ldw	ra,4(sp)
 82154a0:	df000017 	ldw	fp,0(sp)
 82154a4:	dec00204 	addi	sp,sp,8
 82154a8:	f800283a 	ret

082154ac <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 82154ac:	defff704 	addi	sp,sp,-36
 82154b0:	dfc00815 	stw	ra,32(sp)
 82154b4:	df000715 	stw	fp,28(sp)
 82154b8:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 82154bc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 82154c0:	823cbbc0 	call	823cbbc <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82154c4:	0005303a 	rdctl	r2,status
 82154c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82154cc:	e0fffd17 	ldw	r3,-12(fp)
 82154d0:	00bfff84 	movi	r2,-2
 82154d4:	1884703a 	and	r2,r3,r2
 82154d8:	1001703a 	wrctl	status,r2
  
  return context;
 82154dc:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 82154e0:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 82154e4:	d0a07b17 	ldw	r2,-32276(gp)
 82154e8:	10800044 	addi	r2,r2,1
 82154ec:	d0a07b15 	stw	r2,-32276(gp)
 82154f0:	e0bffb17 	ldw	r2,-20(fp)
 82154f4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82154f8:	e0bfff17 	ldw	r2,-4(fp)
 82154fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 8215500:	d0a06b43 	ldbu	r2,-32339(gp)
 8215504:	10803fcc 	andi	r2,r2,255
 8215508:	10800058 	cmpnei	r2,r2,1
 821550c:	10006a1e 	bne	r2,zero,82156b8 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 8215510:	d0a06f03 	ldbu	r2,-32324(gp)
 8215514:	10803fcc 	andi	r2,r2,255
 8215518:	10c00060 	cmpeqi	r3,r2,1
 821551c:	1800061e 	bne	r3,zero,8215538 <OSTimeTick+0x8c>
 8215520:	10c000a0 	cmpeqi	r3,r2,2
 8215524:	1800061e 	bne	r3,zero,8215540 <OSTimeTick+0x94>
 8215528:	10000a1e 	bne	r2,zero,8215554 <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 821552c:	00800044 	movi	r2,1
 8215530:	e0bffa05 	stb	r2,-24(fp)
                 break;
 8215534:	00000b06 	br	8215564 <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 8215538:	e03ffa05 	stb	zero,-24(fp)
                 break;
 821553c:	00000906 	br	8215564 <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 8215540:	00800044 	movi	r2,1
 8215544:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 8215548:	00800044 	movi	r2,1
 821554c:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 8215550:	00000406 	br	8215564 <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 8215554:	00800044 	movi	r2,1
 8215558:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 821555c:	d0206f05 	stb	zero,-32324(gp)
                 break;
 8215560:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 8215564:	e0bffa03 	ldbu	r2,-24(fp)
 8215568:	10005226 	beq	r2,zero,82156b4 <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 821556c:	d0a06e17 	ldw	r2,-32328(gp)
 8215570:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 8215574:	00004906 	br	821569c <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215578:	0005303a 	rdctl	r2,status
 821557c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215580:	e0fffc17 	ldw	r3,-16(fp)
 8215584:	00bfff84 	movi	r2,-2
 8215588:	1884703a 	and	r2,r3,r2
 821558c:	1001703a 	wrctl	status,r2
  
  return context;
 8215590:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
 8215594:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 8215598:	e0bff917 	ldw	r2,-28(fp)
 821559c:	10800b8b 	ldhu	r2,46(r2)
 82155a0:	10bfffcc 	andi	r2,r2,65535
 82155a4:	10003626 	beq	r2,zero,8215680 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 82155a8:	e0bff917 	ldw	r2,-28(fp)
 82155ac:	10800b8b 	ldhu	r2,46(r2)
 82155b0:	10bfffc4 	addi	r2,r2,-1
 82155b4:	1007883a 	mov	r3,r2
 82155b8:	e0bff917 	ldw	r2,-28(fp)
 82155bc:	10c00b8d 	sth	r3,46(r2)
 82155c0:	e0bff917 	ldw	r2,-28(fp)
 82155c4:	10800b8b 	ldhu	r2,46(r2)
 82155c8:	10bfffcc 	andi	r2,r2,65535
 82155cc:	10002c1e 	bne	r2,zero,8215680 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 82155d0:	e0bff917 	ldw	r2,-28(fp)
 82155d4:	10800c03 	ldbu	r2,48(r2)
 82155d8:	10803fcc 	andi	r2,r2,255
 82155dc:	10800dcc 	andi	r2,r2,55
 82155e0:	10000b26 	beq	r2,zero,8215610 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 82155e4:	e0bff917 	ldw	r2,-28(fp)
 82155e8:	10c00c03 	ldbu	r3,48(r2)
 82155ec:	00bff204 	movi	r2,-56
 82155f0:	1884703a 	and	r2,r3,r2
 82155f4:	1007883a 	mov	r3,r2
 82155f8:	e0bff917 	ldw	r2,-28(fp)
 82155fc:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 8215600:	e0bff917 	ldw	r2,-28(fp)
 8215604:	00c00044 	movi	r3,1
 8215608:	10c00c45 	stb	r3,49(r2)
 821560c:	00000206 	br	8215618 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 8215610:	e0bff917 	ldw	r2,-28(fp)
 8215614:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 8215618:	e0bff917 	ldw	r2,-28(fp)
 821561c:	10800c03 	ldbu	r2,48(r2)
 8215620:	10803fcc 	andi	r2,r2,255
 8215624:	1080020c 	andi	r2,r2,8
 8215628:	1000151e 	bne	r2,zero,8215680 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 821562c:	e0bff917 	ldw	r2,-28(fp)
 8215630:	10c00d83 	ldbu	r3,54(r2)
 8215634:	d0a07703 	ldbu	r2,-32292(gp)
 8215638:	1884b03a 	or	r2,r3,r2
 821563c:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8215640:	e0bff917 	ldw	r2,-28(fp)
 8215644:	10800d03 	ldbu	r2,52(r2)
 8215648:	10c03fcc 	andi	r3,r2,255
 821564c:	e0bff917 	ldw	r2,-28(fp)
 8215650:	10800d03 	ldbu	r2,52(r2)
 8215654:	11003fcc 	andi	r4,r2,255
 8215658:	d0a07744 	addi	r2,gp,-32291
 821565c:	2085883a 	add	r2,r4,r2
 8215660:	11000003 	ldbu	r4,0(r2)
 8215664:	e0bff917 	ldw	r2,-28(fp)
 8215668:	10800d43 	ldbu	r2,53(r2)
 821566c:	2084b03a 	or	r2,r4,r2
 8215670:	1009883a 	mov	r4,r2
 8215674:	d0a07744 	addi	r2,gp,-32291
 8215678:	1885883a 	add	r2,r3,r2
 821567c:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 8215680:	e0bff917 	ldw	r2,-28(fp)
 8215684:	10800517 	ldw	r2,20(r2)
 8215688:	e0bff915 	stw	r2,-28(fp)
 821568c:	e0bffb17 	ldw	r2,-20(fp)
 8215690:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215694:	e0bffe17 	ldw	r2,-8(fp)
 8215698:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 821569c:	e0bff917 	ldw	r2,-28(fp)
 82156a0:	10800c83 	ldbu	r2,50(r2)
 82156a4:	10803fcc 	andi	r2,r2,255
 82156a8:	10800518 	cmpnei	r2,r2,20
 82156ac:	103fb21e 	bne	r2,zero,8215578 <OSTimeTick+0xcc>
 82156b0:	00000106 	br	82156b8 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 82156b4:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 82156b8:	e037883a 	mov	sp,fp
 82156bc:	dfc00117 	ldw	ra,4(sp)
 82156c0:	df000017 	ldw	fp,0(sp)
 82156c4:	dec00204 	addi	sp,sp,8
 82156c8:	f800283a 	ret

082156cc <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 82156cc:	deffff04 	addi	sp,sp,-4
 82156d0:	df000015 	stw	fp,0(sp)
 82156d4:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 82156d8:	00804784 	movi	r2,286
}
 82156dc:	e037883a 	mov	sp,fp
 82156e0:	df000017 	ldw	fp,0(sp)
 82156e4:	dec00104 	addi	sp,sp,4
 82156e8:	f800283a 	ret

082156ec <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 82156ec:	deffff04 	addi	sp,sp,-4
 82156f0:	df000015 	stw	fp,0(sp)
 82156f4:	d839883a 	mov	fp,sp
}
 82156f8:	0001883a 	nop
 82156fc:	e037883a 	mov	sp,fp
 8215700:	df000017 	ldw	fp,0(sp)
 8215704:	dec00104 	addi	sp,sp,4
 8215708:	f800283a 	ret

0821570c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 821570c:	defff804 	addi	sp,sp,-32
 8215710:	dfc00715 	stw	ra,28(sp)
 8215714:	df000615 	stw	fp,24(sp)
 8215718:	df000604 	addi	fp,sp,24
 821571c:	e13ffc15 	stw	r4,-16(fp)
 8215720:	e17ffd15 	stw	r5,-12(fp)
 8215724:	3007883a 	mov	r3,r6
 8215728:	3805883a 	mov	r2,r7
 821572c:	e0fffe05 	stb	r3,-8(fp)
 8215730:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 8215734:	e0bffc17 	ldw	r2,-16(fp)
 8215738:	10800283 	ldbu	r2,10(r2)
 821573c:	10c03fcc 	andi	r3,r2,255
 8215740:	00820974 	movhi	r2,2085
 8215744:	10b61704 	addi	r2,r2,-10148
 8215748:	10c5883a 	add	r2,r2,r3
 821574c:	10800003 	ldbu	r2,0(r2)
 8215750:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 8215754:	e0bffa03 	ldbu	r2,-24(fp)
 8215758:	e0fffc17 	ldw	r3,-16(fp)
 821575c:	1885883a 	add	r2,r3,r2
 8215760:	108002c4 	addi	r2,r2,11
 8215764:	10800003 	ldbu	r2,0(r2)
 8215768:	10c03fcc 	andi	r3,r2,255
 821576c:	00820974 	movhi	r2,2085
 8215770:	10b61704 	addi	r2,r2,-10148
 8215774:	10c5883a 	add	r2,r2,r3
 8215778:	10800003 	ldbu	r2,0(r2)
 821577c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 8215780:	e0bffa03 	ldbu	r2,-24(fp)
 8215784:	100490fa 	slli	r2,r2,3
 8215788:	1007883a 	mov	r3,r2
 821578c:	e0bffa43 	ldbu	r2,-23(fp)
 8215790:	1885883a 	add	r2,r3,r2
 8215794:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 8215798:	e0fffa83 	ldbu	r3,-22(fp)
 821579c:	008209b4 	movhi	r2,2086
 82157a0:	10b54004 	addi	r2,r2,-11008
 82157a4:	18c7883a 	add	r3,r3,r3
 82157a8:	18c7883a 	add	r3,r3,r3
 82157ac:	10c5883a 	add	r2,r2,r3
 82157b0:	10800017 	ldw	r2,0(r2)
 82157b4:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 82157b8:	e0bffb17 	ldw	r2,-20(fp)
 82157bc:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 82157c0:	e0bffb17 	ldw	r2,-20(fp)
 82157c4:	e0fffd17 	ldw	r3,-12(fp)
 82157c8:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 82157cc:	e0bffb17 	ldw	r2,-20(fp)
 82157d0:	10800c03 	ldbu	r2,48(r2)
 82157d4:	1007883a 	mov	r3,r2
 82157d8:	e0bffe03 	ldbu	r2,-8(fp)
 82157dc:	0084303a 	nor	r2,zero,r2
 82157e0:	1884703a 	and	r2,r3,r2
 82157e4:	1007883a 	mov	r3,r2
 82157e8:	e0bffb17 	ldw	r2,-20(fp)
 82157ec:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 82157f0:	e0bffb17 	ldw	r2,-20(fp)
 82157f4:	e0ffff03 	ldbu	r3,-4(fp)
 82157f8:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 82157fc:	e0bffb17 	ldw	r2,-20(fp)
 8215800:	10800c03 	ldbu	r2,48(r2)
 8215804:	10803fcc 	andi	r2,r2,255
 8215808:	1080020c 	andi	r2,r2,8
 821580c:	1000111e 	bne	r2,zero,8215854 <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 8215810:	e0bffb17 	ldw	r2,-20(fp)
 8215814:	10c00d83 	ldbu	r3,54(r2)
 8215818:	d0a07703 	ldbu	r2,-32292(gp)
 821581c:	1884b03a 	or	r2,r3,r2
 8215820:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 8215824:	e0fffa03 	ldbu	r3,-24(fp)
 8215828:	e13ffa03 	ldbu	r4,-24(fp)
 821582c:	d0a07744 	addi	r2,gp,-32291
 8215830:	2085883a 	add	r2,r4,r2
 8215834:	11000003 	ldbu	r4,0(r2)
 8215838:	e0bffb17 	ldw	r2,-20(fp)
 821583c:	10800d43 	ldbu	r2,53(r2)
 8215840:	2084b03a 	or	r2,r4,r2
 8215844:	1009883a 	mov	r4,r2
 8215848:	d0a07744 	addi	r2,gp,-32291
 821584c:	1885883a 	add	r2,r3,r2
 8215850:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 8215854:	e17ffc17 	ldw	r5,-16(fp)
 8215858:	e13ffb17 	ldw	r4,-20(fp)
 821585c:	8215b040 	call	8215b04 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 8215860:	e0bffb17 	ldw	r2,-20(fp)
 8215864:	10800817 	ldw	r2,32(r2)
 8215868:	10000826 	beq	r2,zero,821588c <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 821586c:	e0bffb17 	ldw	r2,-20(fp)
 8215870:	10800817 	ldw	r2,32(r2)
 8215874:	100b883a 	mov	r5,r2
 8215878:	e13ffb17 	ldw	r4,-20(fp)
 821587c:	8215bbc0 	call	8215bbc <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 8215880:	e0bffb17 	ldw	r2,-20(fp)
 8215884:	e0fffc17 	ldw	r3,-16(fp)
 8215888:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 821588c:	e0bffa83 	ldbu	r2,-22(fp)
}
 8215890:	e037883a 	mov	sp,fp
 8215894:	dfc00117 	ldw	ra,4(sp)
 8215898:	df000017 	ldw	fp,0(sp)
 821589c:	dec00204 	addi	sp,sp,8
 82158a0:	f800283a 	ret

082158a4 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 82158a4:	defffd04 	addi	sp,sp,-12
 82158a8:	df000215 	stw	fp,8(sp)
 82158ac:	df000204 	addi	fp,sp,8
 82158b0:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 82158b4:	d0a07a17 	ldw	r2,-32280(gp)
 82158b8:	e0ffff17 	ldw	r3,-4(fp)
 82158bc:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 82158c0:	d0a07a17 	ldw	r2,-32280(gp)
 82158c4:	10800d03 	ldbu	r2,52(r2)
 82158c8:	10803fcc 	andi	r2,r2,255
 82158cc:	d0e07a17 	ldw	r3,-32280(gp)
 82158d0:	18c00d03 	ldbu	r3,52(r3)
 82158d4:	18c03fcc 	andi	r3,r3,255
 82158d8:	e13fff17 	ldw	r4,-4(fp)
 82158dc:	20c7883a 	add	r3,r4,r3
 82158e0:	18c002c4 	addi	r3,r3,11
 82158e4:	19000003 	ldbu	r4,0(r3)
 82158e8:	d0e07a17 	ldw	r3,-32280(gp)
 82158ec:	18c00d43 	ldbu	r3,53(r3)
 82158f0:	20c6b03a 	or	r3,r4,r3
 82158f4:	1809883a 	mov	r4,r3
 82158f8:	e0ffff17 	ldw	r3,-4(fp)
 82158fc:	1885883a 	add	r2,r3,r2
 8215900:	108002c4 	addi	r2,r2,11
 8215904:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215908:	e0bfff17 	ldw	r2,-4(fp)
 821590c:	10c00283 	ldbu	r3,10(r2)
 8215910:	d0a07a17 	ldw	r2,-32280(gp)
 8215914:	10800d83 	ldbu	r2,54(r2)
 8215918:	1884b03a 	or	r2,r3,r2
 821591c:	1007883a 	mov	r3,r2
 8215920:	e0bfff17 	ldw	r2,-4(fp)
 8215924:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215928:	d0a07a17 	ldw	r2,-32280(gp)
 821592c:	10800d03 	ldbu	r2,52(r2)
 8215930:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215934:	e0fffe03 	ldbu	r3,-8(fp)
 8215938:	e13ffe03 	ldbu	r4,-8(fp)
 821593c:	d0a07744 	addi	r2,gp,-32291
 8215940:	2085883a 	add	r2,r4,r2
 8215944:	10800003 	ldbu	r2,0(r2)
 8215948:	1009883a 	mov	r4,r2
 821594c:	d0a07a17 	ldw	r2,-32280(gp)
 8215950:	10800d43 	ldbu	r2,53(r2)
 8215954:	0084303a 	nor	r2,zero,r2
 8215958:	2084703a 	and	r2,r4,r2
 821595c:	1009883a 	mov	r4,r2
 8215960:	d0a07744 	addi	r2,gp,-32291
 8215964:	1885883a 	add	r2,r3,r2
 8215968:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 821596c:	e0fffe03 	ldbu	r3,-8(fp)
 8215970:	d0a07744 	addi	r2,gp,-32291
 8215974:	1885883a 	add	r2,r3,r2
 8215978:	10800003 	ldbu	r2,0(r2)
 821597c:	10803fcc 	andi	r2,r2,255
 8215980:	1000071e 	bne	r2,zero,82159a0 <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215984:	d0a07a17 	ldw	r2,-32280(gp)
 8215988:	10800d83 	ldbu	r2,54(r2)
 821598c:	0084303a 	nor	r2,zero,r2
 8215990:	1007883a 	mov	r3,r2
 8215994:	d0a07703 	ldbu	r2,-32292(gp)
 8215998:	1884703a 	and	r2,r3,r2
 821599c:	d0a07705 	stb	r2,-32292(gp)
    }
}
 82159a0:	0001883a 	nop
 82159a4:	e037883a 	mov	sp,fp
 82159a8:	df000017 	ldw	fp,0(sp)
 82159ac:	dec00104 	addi	sp,sp,4
 82159b0:	f800283a 	ret

082159b4 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 82159b4:	defffb04 	addi	sp,sp,-20
 82159b8:	df000415 	stw	fp,16(sp)
 82159bc:	df000404 	addi	fp,sp,16
 82159c0:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 82159c4:	d0a07a17 	ldw	r2,-32280(gp)
 82159c8:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 82159cc:	d0a07a17 	ldw	r2,-32280(gp)
 82159d0:	e0ffff17 	ldw	r3,-4(fp)
 82159d4:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 82159d8:	e0bfff17 	ldw	r2,-4(fp)
 82159dc:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 82159e0:	e0bffc17 	ldw	r2,-16(fp)
 82159e4:	10800017 	ldw	r2,0(r2)
 82159e8:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 82159ec:	00002006 	br	8215a70 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 82159f0:	d0a07a17 	ldw	r2,-32280(gp)
 82159f4:	10800d03 	ldbu	r2,52(r2)
 82159f8:	10803fcc 	andi	r2,r2,255
 82159fc:	d0e07a17 	ldw	r3,-32280(gp)
 8215a00:	18c00d03 	ldbu	r3,52(r3)
 8215a04:	18c03fcc 	andi	r3,r3,255
 8215a08:	e13ffd17 	ldw	r4,-12(fp)
 8215a0c:	20c7883a 	add	r3,r4,r3
 8215a10:	18c002c4 	addi	r3,r3,11
 8215a14:	19000003 	ldbu	r4,0(r3)
 8215a18:	d0e07a17 	ldw	r3,-32280(gp)
 8215a1c:	18c00d43 	ldbu	r3,53(r3)
 8215a20:	20c6b03a 	or	r3,r4,r3
 8215a24:	1809883a 	mov	r4,r3
 8215a28:	e0fffd17 	ldw	r3,-12(fp)
 8215a2c:	1885883a 	add	r2,r3,r2
 8215a30:	108002c4 	addi	r2,r2,11
 8215a34:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215a38:	e0bffd17 	ldw	r2,-12(fp)
 8215a3c:	10c00283 	ldbu	r3,10(r2)
 8215a40:	d0a07a17 	ldw	r2,-32280(gp)
 8215a44:	10800d83 	ldbu	r2,54(r2)
 8215a48:	1884b03a 	or	r2,r3,r2
 8215a4c:	1007883a 	mov	r3,r2
 8215a50:	e0bffd17 	ldw	r2,-12(fp)
 8215a54:	10c00285 	stb	r3,10(r2)
        pevents++;
 8215a58:	e0bffc17 	ldw	r2,-16(fp)
 8215a5c:	10800104 	addi	r2,r2,4
 8215a60:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 8215a64:	e0bffc17 	ldw	r2,-16(fp)
 8215a68:	10800017 	ldw	r2,0(r2)
 8215a6c:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215a70:	e0bffd17 	ldw	r2,-12(fp)
 8215a74:	103fde1e 	bne	r2,zero,82159f0 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215a78:	d0a07a17 	ldw	r2,-32280(gp)
 8215a7c:	10800d03 	ldbu	r2,52(r2)
 8215a80:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215a84:	e0fffe03 	ldbu	r3,-8(fp)
 8215a88:	e13ffe03 	ldbu	r4,-8(fp)
 8215a8c:	d0a07744 	addi	r2,gp,-32291
 8215a90:	2085883a 	add	r2,r4,r2
 8215a94:	10800003 	ldbu	r2,0(r2)
 8215a98:	1009883a 	mov	r4,r2
 8215a9c:	d0a07a17 	ldw	r2,-32280(gp)
 8215aa0:	10800d43 	ldbu	r2,53(r2)
 8215aa4:	0084303a 	nor	r2,zero,r2
 8215aa8:	2084703a 	and	r2,r4,r2
 8215aac:	1009883a 	mov	r4,r2
 8215ab0:	d0a07744 	addi	r2,gp,-32291
 8215ab4:	1885883a 	add	r2,r3,r2
 8215ab8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215abc:	e0fffe03 	ldbu	r3,-8(fp)
 8215ac0:	d0a07744 	addi	r2,gp,-32291
 8215ac4:	1885883a 	add	r2,r3,r2
 8215ac8:	10800003 	ldbu	r2,0(r2)
 8215acc:	10803fcc 	andi	r2,r2,255
 8215ad0:	1000071e 	bne	r2,zero,8215af0 <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215ad4:	d0a07a17 	ldw	r2,-32280(gp)
 8215ad8:	10800d83 	ldbu	r2,54(r2)
 8215adc:	0084303a 	nor	r2,zero,r2
 8215ae0:	1007883a 	mov	r3,r2
 8215ae4:	d0a07703 	ldbu	r2,-32292(gp)
 8215ae8:	1884703a 	and	r2,r3,r2
 8215aec:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215af0:	0001883a 	nop
 8215af4:	e037883a 	mov	sp,fp
 8215af8:	df000017 	ldw	fp,0(sp)
 8215afc:	dec00104 	addi	sp,sp,4
 8215b00:	f800283a 	ret

08215b04 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 8215b04:	defffc04 	addi	sp,sp,-16
 8215b08:	df000315 	stw	fp,12(sp)
 8215b0c:	df000304 	addi	fp,sp,12
 8215b10:	e13ffe15 	stw	r4,-8(fp)
 8215b14:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 8215b18:	e0bffe17 	ldw	r2,-8(fp)
 8215b1c:	10800d03 	ldbu	r2,52(r2)
 8215b20:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 8215b24:	e0bffd03 	ldbu	r2,-12(fp)
 8215b28:	e0fffd03 	ldbu	r3,-12(fp)
 8215b2c:	e13fff17 	ldw	r4,-4(fp)
 8215b30:	20c7883a 	add	r3,r4,r3
 8215b34:	18c002c4 	addi	r3,r3,11
 8215b38:	18c00003 	ldbu	r3,0(r3)
 8215b3c:	1809883a 	mov	r4,r3
 8215b40:	e0fffe17 	ldw	r3,-8(fp)
 8215b44:	18c00d43 	ldbu	r3,53(r3)
 8215b48:	00c6303a 	nor	r3,zero,r3
 8215b4c:	20c6703a 	and	r3,r4,r3
 8215b50:	1809883a 	mov	r4,r3
 8215b54:	e0ffff17 	ldw	r3,-4(fp)
 8215b58:	1885883a 	add	r2,r3,r2
 8215b5c:	108002c4 	addi	r2,r2,11
 8215b60:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
 8215b64:	e0bffd03 	ldbu	r2,-12(fp)
 8215b68:	e0ffff17 	ldw	r3,-4(fp)
 8215b6c:	1885883a 	add	r2,r3,r2
 8215b70:	108002c4 	addi	r2,r2,11
 8215b74:	10800003 	ldbu	r2,0(r2)
 8215b78:	10803fcc 	andi	r2,r2,255
 8215b7c:	10000a1e 	bne	r2,zero,8215ba8 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 8215b80:	e0bfff17 	ldw	r2,-4(fp)
 8215b84:	10800283 	ldbu	r2,10(r2)
 8215b88:	1007883a 	mov	r3,r2
 8215b8c:	e0bffe17 	ldw	r2,-8(fp)
 8215b90:	10800d83 	ldbu	r2,54(r2)
 8215b94:	0084303a 	nor	r2,zero,r2
 8215b98:	1884703a 	and	r2,r3,r2
 8215b9c:	1007883a 	mov	r3,r2
 8215ba0:	e0bfff17 	ldw	r2,-4(fp)
 8215ba4:	10c00285 	stb	r3,10(r2)
    }
}
 8215ba8:	0001883a 	nop
 8215bac:	e037883a 	mov	sp,fp
 8215bb0:	df000017 	ldw	fp,0(sp)
 8215bb4:	dec00104 	addi	sp,sp,4
 8215bb8:	f800283a 	ret

08215bbc <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 8215bbc:	defffa04 	addi	sp,sp,-24
 8215bc0:	df000515 	stw	fp,20(sp)
 8215bc4:	df000504 	addi	fp,sp,20
 8215bc8:	e13ffe15 	stw	r4,-8(fp)
 8215bcc:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 8215bd0:	e0bffe17 	ldw	r2,-8(fp)
 8215bd4:	10800d03 	ldbu	r2,52(r2)
 8215bd8:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 8215bdc:	e0bffe17 	ldw	r2,-8(fp)
 8215be0:	10800d83 	ldbu	r2,54(r2)
 8215be4:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 8215be8:	e0bffe17 	ldw	r2,-8(fp)
 8215bec:	10800d43 	ldbu	r2,53(r2)
 8215bf0:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 8215bf4:	e0bfff17 	ldw	r2,-4(fp)
 8215bf8:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 8215bfc:	e0bffb17 	ldw	r2,-20(fp)
 8215c00:	10800017 	ldw	r2,0(r2)
 8215c04:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215c08:	00002506 	br	8215ca0 <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
 8215c0c:	e0bffd03 	ldbu	r2,-12(fp)
 8215c10:	e0fffd03 	ldbu	r3,-12(fp)
 8215c14:	e13ffc17 	ldw	r4,-16(fp)
 8215c18:	20c7883a 	add	r3,r4,r3
 8215c1c:	18c002c4 	addi	r3,r3,11
 8215c20:	18c00003 	ldbu	r3,0(r3)
 8215c24:	1809883a 	mov	r4,r3
 8215c28:	e0fffd83 	ldbu	r3,-10(fp)
 8215c2c:	00c6303a 	nor	r3,zero,r3
 8215c30:	20c6703a 	and	r3,r4,r3
 8215c34:	1809883a 	mov	r4,r3
 8215c38:	e0fffc17 	ldw	r3,-16(fp)
 8215c3c:	1885883a 	add	r2,r3,r2
 8215c40:	108002c4 	addi	r2,r2,11
 8215c44:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
 8215c48:	e0bffd03 	ldbu	r2,-12(fp)
 8215c4c:	e0fffc17 	ldw	r3,-16(fp)
 8215c50:	1885883a 	add	r2,r3,r2
 8215c54:	108002c4 	addi	r2,r2,11
 8215c58:	10800003 	ldbu	r2,0(r2)
 8215c5c:	10803fcc 	andi	r2,r2,255
 8215c60:	1000091e 	bne	r2,zero,8215c88 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
 8215c64:	e0bffc17 	ldw	r2,-16(fp)
 8215c68:	10800283 	ldbu	r2,10(r2)
 8215c6c:	1007883a 	mov	r3,r2
 8215c70:	e0bffd43 	ldbu	r2,-11(fp)
 8215c74:	0084303a 	nor	r2,zero,r2
 8215c78:	1884703a 	and	r2,r3,r2
 8215c7c:	1007883a 	mov	r3,r2
 8215c80:	e0bffc17 	ldw	r2,-16(fp)
 8215c84:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 8215c88:	e0bffb17 	ldw	r2,-20(fp)
 8215c8c:	10800104 	addi	r2,r2,4
 8215c90:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 8215c94:	e0bffb17 	ldw	r2,-20(fp)
 8215c98:	10800017 	ldw	r2,0(r2)
 8215c9c:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215ca0:	e0bffc17 	ldw	r2,-16(fp)
 8215ca4:	103fd91e 	bne	r2,zero,8215c0c <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 8215ca8:	0001883a 	nop
 8215cac:	e037883a 	mov	sp,fp
 8215cb0:	df000017 	ldw	fp,0(sp)
 8215cb4:	dec00104 	addi	sp,sp,4
 8215cb8:	f800283a 	ret

08215cbc <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 8215cbc:	defffc04 	addi	sp,sp,-16
 8215cc0:	df000315 	stw	fp,12(sp)
 8215cc4:	df000304 	addi	fp,sp,12
 8215cc8:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 8215ccc:	e0bfff17 	ldw	r2,-4(fp)
 8215cd0:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 8215cd4:	e0bfff17 	ldw	r2,-4(fp)
 8215cd8:	108002c4 	addi	r2,r2,11
 8215cdc:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8215ce0:	e03ffe05 	stb	zero,-8(fp)
 8215ce4:	00000706 	br	8215d04 <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
 8215ce8:	e0bffd17 	ldw	r2,-12(fp)
 8215cec:	10c00044 	addi	r3,r2,1
 8215cf0:	e0fffd15 	stw	r3,-12(fp)
 8215cf4:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8215cf8:	e0bffe03 	ldbu	r2,-8(fp)
 8215cfc:	10800044 	addi	r2,r2,1
 8215d00:	e0bffe05 	stb	r2,-8(fp)
 8215d04:	e0bffe03 	ldbu	r2,-8(fp)
 8215d08:	108000f0 	cmpltui	r2,r2,3
 8215d0c:	103ff61e 	bne	r2,zero,8215ce8 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 8215d10:	0001883a 	nop
 8215d14:	e037883a 	mov	sp,fp
 8215d18:	df000017 	ldw	fp,0(sp)
 8215d1c:	dec00104 	addi	sp,sp,4
 8215d20:	f800283a 	ret

08215d24 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 8215d24:	defffb04 	addi	sp,sp,-20
 8215d28:	dfc00415 	stw	ra,16(sp)
 8215d2c:	df000315 	stw	fp,12(sp)
 8215d30:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 8215d34:	0142d004 	movi	r5,2880
 8215d38:	010209b4 	movhi	r4,2086
 8215d3c:	21312c04 	addi	r4,r4,-15184
 8215d40:	821609c0 	call	821609c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 8215d44:	008209b4 	movhi	r2,2086
 8215d48:	10b12c04 	addi	r2,r2,-15184
 8215d4c:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 8215d50:	008209b4 	movhi	r2,2086
 8215d54:	10b13804 	addi	r2,r2,-15136
 8215d58:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8215d5c:	e03ffd0d 	sth	zero,-12(fp)
 8215d60:	00001306 	br	8215db0 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8215d64:	e0bffe17 	ldw	r2,-8(fp)
 8215d68:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 8215d6c:	e0bffe17 	ldw	r2,-8(fp)
 8215d70:	e0ffff17 	ldw	r3,-4(fp)
 8215d74:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 8215d78:	e0bffe17 	ldw	r2,-8(fp)
 8215d7c:	00c00fc4 	movi	r3,63
 8215d80:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 8215d84:	e0bffe17 	ldw	r2,-8(fp)
 8215d88:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 8215d8c:	e0bffe17 	ldw	r2,-8(fp)
 8215d90:	10800c04 	addi	r2,r2,48
 8215d94:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 8215d98:	e0bfff17 	ldw	r2,-4(fp)
 8215d9c:	10800c04 	addi	r2,r2,48
 8215da0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8215da4:	e0bffd0b 	ldhu	r2,-12(fp)
 8215da8:	10800044 	addi	r2,r2,1
 8215dac:	e0bffd0d 	sth	r2,-12(fp)
 8215db0:	e0bffd0b 	ldhu	r2,-12(fp)
 8215db4:	10800ef0 	cmpltui	r2,r2,59
 8215db8:	103fea1e 	bne	r2,zero,8215d64 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 8215dbc:	e0bffe17 	ldw	r2,-8(fp)
 8215dc0:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 8215dc4:	e0bffe17 	ldw	r2,-8(fp)
 8215dc8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 8215dcc:	e0bffe17 	ldw	r2,-8(fp)
 8215dd0:	00c00fc4 	movi	r3,63
 8215dd4:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 8215dd8:	e0bffe17 	ldw	r2,-8(fp)
 8215ddc:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 8215de0:	008209b4 	movhi	r2,2086
 8215de4:	10b12c04 	addi	r2,r2,-15184
 8215de8:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 8215dec:	0001883a 	nop
 8215df0:	e037883a 	mov	sp,fp
 8215df4:	dfc00117 	ldw	ra,4(sp)
 8215df8:	df000017 	ldw	fp,0(sp)
 8215dfc:	dec00204 	addi	sp,sp,8
 8215e00:	f800283a 	ret

08215e04 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 8215e04:	deffff04 	addi	sp,sp,-4
 8215e08:	df000015 	stw	fp,0(sp)
 8215e0c:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 8215e10:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 8215e14:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 8215e18:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 8215e1c:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 8215e20:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 8215e24:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 8215e28:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 8215e2c:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 8215e30:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 8215e34:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 8215e38:	0001883a 	nop
 8215e3c:	e037883a 	mov	sp,fp
 8215e40:	df000017 	ldw	fp,0(sp)
 8215e44:	dec00104 	addi	sp,sp,4
 8215e48:	f800283a 	ret

08215e4c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 8215e4c:	defffd04 	addi	sp,sp,-12
 8215e50:	df000215 	stw	fp,8(sp)
 8215e54:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 8215e58:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 8215e5c:	d0a07744 	addi	r2,gp,-32291
 8215e60:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 8215e64:	e03ffe05 	stb	zero,-8(fp)
 8215e68:	00000706 	br	8215e88 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
 8215e6c:	e0bfff17 	ldw	r2,-4(fp)
 8215e70:	10c00044 	addi	r3,r2,1
 8215e74:	e0ffff15 	stw	r3,-4(fp)
 8215e78:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 8215e7c:	e0bffe03 	ldbu	r2,-8(fp)
 8215e80:	10800044 	addi	r2,r2,1
 8215e84:	e0bffe05 	stb	r2,-8(fp)
 8215e88:	e0bffe03 	ldbu	r2,-8(fp)
 8215e8c:	108000f0 	cmpltui	r2,r2,3
 8215e90:	103ff61e 	bne	r2,zero,8215e6c <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 8215e94:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 8215e98:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 8215e9c:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 8215ea0:	d0207a15 	stw	zero,-32280(gp)
}
 8215ea4:	0001883a 	nop
 8215ea8:	e037883a 	mov	sp,fp
 8215eac:	df000017 	ldw	fp,0(sp)
 8215eb0:	dec00104 	addi	sp,sp,4
 8215eb4:	f800283a 	ret

08215eb8 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 8215eb8:	defff804 	addi	sp,sp,-32
 8215ebc:	dfc00715 	stw	ra,28(sp)
 8215ec0:	df000615 	stw	fp,24(sp)
 8215ec4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 8215ec8:	008000c4 	movi	r2,3
 8215ecc:	d8800415 	stw	r2,16(sp)
 8215ed0:	d8000315 	stw	zero,12(sp)
 8215ed4:	00808004 	movi	r2,512
 8215ed8:	d8800215 	stw	r2,8(sp)
 8215edc:	008209b4 	movhi	r2,2086
 8215ee0:	10af2c04 	addi	r2,r2,-17232
 8215ee4:	d8800115 	stw	r2,4(sp)
 8215ee8:	00bfffd4 	movui	r2,65535
 8215eec:	d8800015 	stw	r2,0(sp)
 8215ef0:	01c00504 	movi	r7,20
 8215ef4:	018209b4 	movhi	r6,2086
 8215ef8:	31b12b04 	addi	r6,r6,-15188
 8215efc:	000b883a 	mov	r5,zero
 8215f00:	01020874 	movhi	r4,2081
 8215f04:	2118d904 	addi	r4,r4,25444
 8215f08:	821aa3c0 	call	821aa3c <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 8215f0c:	e1bfff04 	addi	r6,fp,-4
 8215f10:	01420974 	movhi	r5,2085
 8215f14:	29765704 	addi	r5,r5,-9892
 8215f18:	01000504 	movi	r4,20
 8215f1c:	821b24c0 	call	821b24c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 8215f20:	0001883a 	nop
 8215f24:	e037883a 	mov	sp,fp
 8215f28:	dfc00117 	ldw	ra,4(sp)
 8215f2c:	df000017 	ldw	fp,0(sp)
 8215f30:	dec00204 	addi	sp,sp,8
 8215f34:	f800283a 	ret

08215f38 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 8215f38:	defff804 	addi	sp,sp,-32
 8215f3c:	dfc00715 	stw	ra,28(sp)
 8215f40:	df000615 	stw	fp,24(sp)
 8215f44:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 8215f48:	008000c4 	movi	r2,3
 8215f4c:	d8800415 	stw	r2,16(sp)
 8215f50:	d8000315 	stw	zero,12(sp)
 8215f54:	00808004 	movi	r2,512
 8215f58:	d8800215 	stw	r2,8(sp)
 8215f5c:	008209b4 	movhi	r2,2086
 8215f60:	10acb404 	addi	r2,r2,-19760
 8215f64:	d8800115 	stw	r2,4(sp)
 8215f68:	00bfff94 	movui	r2,65534
 8215f6c:	d8800015 	stw	r2,0(sp)
 8215f70:	01c004c4 	movi	r7,19
 8215f74:	018209b4 	movhi	r6,2086
 8215f78:	31aeb304 	addi	r6,r6,-17716
 8215f7c:	000b883a 	mov	r5,zero
 8215f80:	01020874 	movhi	r4,2081
 8215f84:	2118f004 	addi	r4,r4,25536
 8215f88:	821aa3c0 	call	821aa3c <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 8215f8c:	e1bfff04 	addi	r6,fp,-4
 8215f90:	01420974 	movhi	r5,2085
 8215f94:	29765b04 	addi	r5,r5,-9876
 8215f98:	010004c4 	movi	r4,19
 8215f9c:	821b24c0 	call	821b24c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 8215fa0:	0001883a 	nop
 8215fa4:	e037883a 	mov	sp,fp
 8215fa8:	dfc00117 	ldw	ra,4(sp)
 8215fac:	df000017 	ldw	fp,0(sp)
 8215fb0:	dec00204 	addi	sp,sp,8
 8215fb4:	f800283a 	ret

08215fb8 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 8215fb8:	defffb04 	addi	sp,sp,-20
 8215fbc:	dfc00415 	stw	ra,16(sp)
 8215fc0:	df000315 	stw	fp,12(sp)
 8215fc4:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 8215fc8:	01414404 	movi	r5,1296
 8215fcc:	010209b4 	movhi	r4,2086
 8215fd0:	2133fc04 	addi	r4,r4,-12304
 8215fd4:	821609c0 	call	821609c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 8215fd8:	01401504 	movi	r5,84
 8215fdc:	010209b4 	movhi	r4,2086
 8215fe0:	21354004 	addi	r4,r4,-11008
 8215fe4:	821609c0 	call	821609c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 8215fe8:	008209b4 	movhi	r2,2086
 8215fec:	10b3fc04 	addi	r2,r2,-12304
 8215ff0:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 8215ff4:	008209b4 	movhi	r2,2086
 8215ff8:	10b41704 	addi	r2,r2,-12196
 8215ffc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216000:	e03ffd05 	stb	zero,-12(fp)
 8216004:	00001106 	br	821604c <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 8216008:	e0bffe17 	ldw	r2,-8(fp)
 821600c:	e0ffff17 	ldw	r3,-4(fp)
 8216010:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 8216014:	e0bffe17 	ldw	r2,-8(fp)
 8216018:	00c00fc4 	movi	r3,63
 821601c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216020:	e0bffe17 	ldw	r2,-8(fp)
 8216024:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 8216028:	e0bffe17 	ldw	r2,-8(fp)
 821602c:	10801b04 	addi	r2,r2,108
 8216030:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 8216034:	e0bfff17 	ldw	r2,-4(fp)
 8216038:	10801b04 	addi	r2,r2,108
 821603c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216040:	e0bffd03 	ldbu	r2,-12(fp)
 8216044:	10800044 	addi	r2,r2,1
 8216048:	e0bffd05 	stb	r2,-12(fp)
 821604c:	e0bffd03 	ldbu	r2,-12(fp)
 8216050:	108002f0 	cmpltui	r2,r2,11
 8216054:	103fec1e 	bne	r2,zero,8216008 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 8216058:	e0bffe17 	ldw	r2,-8(fp)
 821605c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 8216060:	e0bffe17 	ldw	r2,-8(fp)
 8216064:	00c00fc4 	movi	r3,63
 8216068:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 821606c:	e0bffe17 	ldw	r2,-8(fp)
 8216070:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 8216074:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 8216078:	008209b4 	movhi	r2,2086
 821607c:	10b3fc04 	addi	r2,r2,-12304
 8216080:	d0a07215 	stw	r2,-32312(gp)
}
 8216084:	0001883a 	nop
 8216088:	e037883a 	mov	sp,fp
 821608c:	dfc00117 	ldw	ra,4(sp)
 8216090:	df000017 	ldw	fp,0(sp)
 8216094:	dec00204 	addi	sp,sp,8
 8216098:	f800283a 	ret

0821609c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 821609c:	defffd04 	addi	sp,sp,-12
 82160a0:	df000215 	stw	fp,8(sp)
 82160a4:	df000204 	addi	fp,sp,8
 82160a8:	e13ffe15 	stw	r4,-8(fp)
 82160ac:	2805883a 	mov	r2,r5
 82160b0:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 82160b4:	00000706 	br	82160d4 <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 82160b8:	e0bffe17 	ldw	r2,-8(fp)
 82160bc:	10c00044 	addi	r3,r2,1
 82160c0:	e0fffe15 	stw	r3,-8(fp)
 82160c4:	10000005 	stb	zero,0(r2)
        size--;
 82160c8:	e0bfff0b 	ldhu	r2,-4(fp)
 82160cc:	10bfffc4 	addi	r2,r2,-1
 82160d0:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 82160d4:	e0bfff0b 	ldhu	r2,-4(fp)
 82160d8:	103ff71e 	bne	r2,zero,82160b8 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 82160dc:	0001883a 	nop
 82160e0:	e037883a 	mov	sp,fp
 82160e4:	df000017 	ldw	fp,0(sp)
 82160e8:	dec00104 	addi	sp,sp,4
 82160ec:	f800283a 	ret

082160f0 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 82160f0:	defffc04 	addi	sp,sp,-16
 82160f4:	df000315 	stw	fp,12(sp)
 82160f8:	df000304 	addi	fp,sp,12
 82160fc:	e13ffd15 	stw	r4,-12(fp)
 8216100:	e17ffe15 	stw	r5,-8(fp)
 8216104:	3005883a 	mov	r2,r6
 8216108:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 821610c:	00000b06 	br	821613c <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
 8216110:	e0bffd17 	ldw	r2,-12(fp)
 8216114:	10c00044 	addi	r3,r2,1
 8216118:	e0fffd15 	stw	r3,-12(fp)
 821611c:	e0fffe17 	ldw	r3,-8(fp)
 8216120:	19000044 	addi	r4,r3,1
 8216124:	e13ffe15 	stw	r4,-8(fp)
 8216128:	18c00003 	ldbu	r3,0(r3)
 821612c:	10c00005 	stb	r3,0(r2)
        size--;
 8216130:	e0bfff0b 	ldhu	r2,-4(fp)
 8216134:	10bfffc4 	addi	r2,r2,-1
 8216138:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 821613c:	e0bfff0b 	ldhu	r2,-4(fp)
 8216140:	103ff31e 	bne	r2,zero,8216110 <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 8216144:	0001883a 	nop
 8216148:	e037883a 	mov	sp,fp
 821614c:	df000017 	ldw	fp,0(sp)
 8216150:	dec00104 	addi	sp,sp,4
 8216154:	f800283a 	ret

08216158 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 8216158:	defffb04 	addi	sp,sp,-20
 821615c:	dfc00415 	stw	ra,16(sp)
 8216160:	df000315 	stw	fp,12(sp)
 8216164:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8216168:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821616c:	0005303a 	rdctl	r2,status
 8216170:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216174:	e0ffff17 	ldw	r3,-4(fp)
 8216178:	00bfff84 	movi	r2,-2
 821617c:	1884703a 	and	r2,r3,r2
 8216180:	1001703a 	wrctl	status,r2
  
  return context;
 8216184:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
 8216188:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 821618c:	d0a07903 	ldbu	r2,-32284(gp)
 8216190:	10803fcc 	andi	r2,r2,255
 8216194:	10001a1e 	bne	r2,zero,8216200 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 8216198:	d0a06b03 	ldbu	r2,-32340(gp)
 821619c:	10803fcc 	andi	r2,r2,255
 82161a0:	1000171e 	bne	r2,zero,8216200 <OS_Sched+0xa8>
            OS_SchedNew();
 82161a4:	82162280 	call	8216228 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 82161a8:	d0e06d03 	ldbu	r3,-32332(gp)
 82161ac:	d0a06d43 	ldbu	r2,-32331(gp)
 82161b0:	18c03fcc 	andi	r3,r3,255
 82161b4:	10803fcc 	andi	r2,r2,255
 82161b8:	18801126 	beq	r3,r2,8216200 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 82161bc:	d0a06d03 	ldbu	r2,-32332(gp)
 82161c0:	10c03fcc 	andi	r3,r2,255
 82161c4:	008209b4 	movhi	r2,2086
 82161c8:	10b54004 	addi	r2,r2,-11008
 82161cc:	18c7883a 	add	r3,r3,r3
 82161d0:	18c7883a 	add	r3,r3,r3
 82161d4:	10c5883a 	add	r2,r2,r3
 82161d8:	10800017 	ldw	r2,0(r2)
 82161dc:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 82161e0:	d0a07517 	ldw	r2,-32300(gp)
 82161e4:	10c00e17 	ldw	r3,56(r2)
 82161e8:	18c00044 	addi	r3,r3,1
 82161ec:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 82161f0:	d0a07017 	ldw	r2,-32320(gp)
 82161f4:	10800044 	addi	r2,r2,1
 82161f8:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 82161fc:	823c9080 	call	823c908 <OSCtxSw>
 8216200:	e0bffd17 	ldw	r2,-12(fp)
 8216204:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216208:	e0bffe17 	ldw	r2,-8(fp)
 821620c:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 8216210:	0001883a 	nop
 8216214:	e037883a 	mov	sp,fp
 8216218:	dfc00117 	ldw	ra,4(sp)
 821621c:	df000017 	ldw	fp,0(sp)
 8216220:	dec00204 	addi	sp,sp,8
 8216224:	f800283a 	ret

08216228 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 8216228:	defffe04 	addi	sp,sp,-8
 821622c:	df000115 	stw	fp,4(sp)
 8216230:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 8216234:	d0a07703 	ldbu	r2,-32292(gp)
 8216238:	10c03fcc 	andi	r3,r2,255
 821623c:	00820974 	movhi	r2,2085
 8216240:	10b61704 	addi	r2,r2,-10148
 8216244:	10c5883a 	add	r2,r2,r3
 8216248:	10800003 	ldbu	r2,0(r2)
 821624c:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 8216250:	e0bfff03 	ldbu	r2,-4(fp)
 8216254:	100490fa 	slli	r2,r2,3
 8216258:	1009883a 	mov	r4,r2
 821625c:	e0ffff03 	ldbu	r3,-4(fp)
 8216260:	d0a07744 	addi	r2,gp,-32291
 8216264:	1885883a 	add	r2,r3,r2
 8216268:	10800003 	ldbu	r2,0(r2)
 821626c:	10c03fcc 	andi	r3,r2,255
 8216270:	00820974 	movhi	r2,2085
 8216274:	10b61704 	addi	r2,r2,-10148
 8216278:	10c5883a 	add	r2,r2,r3
 821627c:	10800003 	ldbu	r2,0(r2)
 8216280:	2085883a 	add	r2,r4,r2
 8216284:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 8216288:	0001883a 	nop
 821628c:	e037883a 	mov	sp,fp
 8216290:	df000017 	ldw	fp,0(sp)
 8216294:	dec00104 	addi	sp,sp,4
 8216298:	f800283a 	ret

0821629c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 821629c:	defffc04 	addi	sp,sp,-16
 82162a0:	df000315 	stw	fp,12(sp)
 82162a4:	df000304 	addi	fp,sp,12
 82162a8:	e13ffe15 	stw	r4,-8(fp)
 82162ac:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 82162b0:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 82162b4:	00000b06 	br	82162e4 <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
 82162b8:	e0bffe17 	ldw	r2,-8(fp)
 82162bc:	10c00044 	addi	r3,r2,1
 82162c0:	e0fffe15 	stw	r3,-8(fp)
 82162c4:	e0ffff17 	ldw	r3,-4(fp)
 82162c8:	19000044 	addi	r4,r3,1
 82162cc:	e13fff15 	stw	r4,-4(fp)
 82162d0:	18c00003 	ldbu	r3,0(r3)
 82162d4:	10c00005 	stb	r3,0(r2)
        len++;
 82162d8:	e0bffd03 	ldbu	r2,-12(fp)
 82162dc:	10800044 	addi	r2,r2,1
 82162e0:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 82162e4:	e0bfff17 	ldw	r2,-4(fp)
 82162e8:	10800003 	ldbu	r2,0(r2)
 82162ec:	10803fcc 	andi	r2,r2,255
 82162f0:	103ff11e 	bne	r2,zero,82162b8 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 82162f4:	e0bffe17 	ldw	r2,-8(fp)
 82162f8:	10000005 	stb	zero,0(r2)
    return (len);
 82162fc:	e0bffd03 	ldbu	r2,-12(fp)
}
 8216300:	e037883a 	mov	sp,fp
 8216304:	df000017 	ldw	fp,0(sp)
 8216308:	dec00104 	addi	sp,sp,4
 821630c:	f800283a 	ret

08216310 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 8216310:	defffd04 	addi	sp,sp,-12
 8216314:	df000215 	stw	fp,8(sp)
 8216318:	df000204 	addi	fp,sp,8
 821631c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 8216320:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 8216324:	00000606 	br	8216340 <OS_StrLen+0x30>
        psrc++;
 8216328:	e0bfff17 	ldw	r2,-4(fp)
 821632c:	10800044 	addi	r2,r2,1
 8216330:	e0bfff15 	stw	r2,-4(fp)
        len++;
 8216334:	e0bffe03 	ldbu	r2,-8(fp)
 8216338:	10800044 	addi	r2,r2,1
 821633c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 8216340:	e0bfff17 	ldw	r2,-4(fp)
 8216344:	10800003 	ldbu	r2,0(r2)
 8216348:	10803fcc 	andi	r2,r2,255
 821634c:	103ff61e 	bne	r2,zero,8216328 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 8216350:	e0bffe03 	ldbu	r2,-8(fp)
}
 8216354:	e037883a 	mov	sp,fp
 8216358:	df000017 	ldw	fp,0(sp)
 821635c:	dec00104 	addi	sp,sp,4
 8216360:	f800283a 	ret

08216364 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 8216364:	defffa04 	addi	sp,sp,-24
 8216368:	dfc00515 	stw	ra,20(sp)
 821636c:	df000415 	stw	fp,16(sp)
 8216370:	df000404 	addi	fp,sp,16
 8216374:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8216378:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821637c:	0005303a 	rdctl	r2,status
 8216380:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216384:	e0fffd17 	ldw	r3,-12(fp)
 8216388:	00bfff84 	movi	r2,-2
 821638c:	1884703a 	and	r2,r3,r2
 8216390:	1001703a 	wrctl	status,r2
  
  return context;
 8216394:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 8216398:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 821639c:	d0a06c17 	ldw	r2,-32336(gp)
 82163a0:	10800044 	addi	r2,r2,1
 82163a4:	d0a06c15 	stw	r2,-32336(gp)
 82163a8:	e0bffc17 	ldw	r2,-16(fp)
 82163ac:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82163b0:	e0bffe17 	ldw	r2,-8(fp)
 82163b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 82163b8:	823cc280 	call	823cc28 <OSTaskIdleHook>
    }
 82163bc:	003fef06 	br	821637c <OS_TaskIdle+0x18>

082163c0 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 82163c0:	defff804 	addi	sp,sp,-32
 82163c4:	dfc00715 	stw	ra,28(sp)
 82163c8:	df000615 	stw	fp,24(sp)
 82163cc:	dc400515 	stw	r17,20(sp)
 82163d0:	dc000415 	stw	r16,16(sp)
 82163d4:	df000604 	addi	fp,sp,24
 82163d8:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82163dc:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 82163e0:	00000206 	br	82163ec <OS_TaskStat+0x2c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 82163e4:	01000504 	movi	r4,20
 82163e8:	821bb0c0 	call	821bb0c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 82163ec:	d0a07d03 	ldbu	r2,-32268(gp)
 82163f0:	10803fcc 	andi	r2,r2,255
 82163f4:	103ffb26 	beq	r2,zero,82163e4 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 82163f8:	d0e07117 	ldw	r3,-32316(gp)
 82163fc:	00947b34 	movhi	r2,20972
 8216400:	10a147c4 	addi	r2,r2,-31457
 8216404:	1888383a 	mulxuu	r4,r3,r2
 8216408:	1885383a 	mul	r2,r3,r2
 821640c:	1021883a 	mov	r16,r2
 8216410:	2023883a 	mov	r17,r4
 8216414:	8804d17a 	srli	r2,r17,5
 8216418:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 821641c:	d0a07117 	ldw	r2,-32316(gp)
 8216420:	1000031e 	bne	r2,zero,8216430 <OS_TaskStat+0x70>
        OSCPUUsage = 0;
 8216424:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 8216428:	01003fc4 	movi	r4,255
 821642c:	821b7940 	call	821b794 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216430:	0005303a 	rdctl	r2,status
 8216434:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216438:	e0fffb17 	ldw	r3,-20(fp)
 821643c:	00bfff84 	movi	r2,-2
 8216440:	1884703a 	and	r2,r3,r2
 8216444:	1001703a 	wrctl	status,r2
  
  return context;
 8216448:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 821644c:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 8216450:	d0a06c17 	ldw	r2,-32336(gp)
 8216454:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 8216458:	d0206c15 	stw	zero,-32336(gp)
 821645c:	e0bffa17 	ldw	r2,-24(fp)
 8216460:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216464:	e0bffc17 	ldw	r2,-16(fp)
 8216468:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 821646c:	d0a07e17 	ldw	r2,-32264(gp)
 8216470:	d0e07117 	ldw	r3,-32316(gp)
 8216474:	180b883a 	mov	r5,r3
 8216478:	1009883a 	mov	r4,r2
 821647c:	820270c0 	call	820270c <__udivsi3>
 8216480:	1007883a 	mov	r3,r2
 8216484:	00801904 	movi	r2,100
 8216488:	10c5c83a 	sub	r2,r2,r3
 821648c:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 8216490:	823cb9c0 	call	823cb9c <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 8216494:	82164a40 	call	82164a4 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 8216498:	01000284 	movi	r4,10
 821649c:	821bb0c0 	call	821bb0c <OSTimeDly>
    }
 82164a0:	003fe306 	br	8216430 <OS_TaskStat+0x70>

082164a4 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 82164a4:	defffa04 	addi	sp,sp,-24
 82164a8:	dfc00515 	stw	ra,20(sp)
 82164ac:	df000415 	stw	fp,16(sp)
 82164b0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 82164b4:	e03ffc05 	stb	zero,-16(fp)
 82164b8:	00002406 	br	821654c <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 82164bc:	e0bffc03 	ldbu	r2,-16(fp)
 82164c0:	e0fffe04 	addi	r3,fp,-8
 82164c4:	180b883a 	mov	r5,r3
 82164c8:	1009883a 	mov	r4,r2
 82164cc:	821b5d40 	call	821b5d4 <OSTaskStkChk>
 82164d0:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 82164d4:	e0bffc43 	ldbu	r2,-15(fp)
 82164d8:	1000191e 	bne	r2,zero,8216540 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 82164dc:	e0fffc03 	ldbu	r3,-16(fp)
 82164e0:	008209b4 	movhi	r2,2086
 82164e4:	10b54004 	addi	r2,r2,-11008
 82164e8:	18c7883a 	add	r3,r3,r3
 82164ec:	18c7883a 	add	r3,r3,r3
 82164f0:	10c5883a 	add	r2,r2,r3
 82164f4:	10800017 	ldw	r2,0(r2)
 82164f8:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 82164fc:	e0bffd17 	ldw	r2,-12(fp)
 8216500:	10000f26 	beq	r2,zero,8216540 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 8216504:	e0bffd17 	ldw	r2,-12(fp)
 8216508:	10800060 	cmpeqi	r2,r2,1
 821650c:	10000c1e 	bne	r2,zero,8216540 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 8216510:	e0bffd17 	ldw	r2,-12(fp)
 8216514:	10c00217 	ldw	r3,8(r2)
 8216518:	e0bffd17 	ldw	r2,-12(fp)
 821651c:	10800317 	ldw	r2,12(r2)
 8216520:	1085883a 	add	r2,r2,r2
 8216524:	1085883a 	add	r2,r2,r2
 8216528:	1887883a 	add	r3,r3,r2
 821652c:	e0bffd17 	ldw	r2,-12(fp)
 8216530:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 8216534:	e0ffff17 	ldw	r3,-4(fp)
 8216538:	e0bffd17 	ldw	r2,-12(fp)
 821653c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 8216540:	e0bffc03 	ldbu	r2,-16(fp)
 8216544:	10800044 	addi	r2,r2,1
 8216548:	e0bffc05 	stb	r2,-16(fp)
 821654c:	e0bffc03 	ldbu	r2,-16(fp)
 8216550:	10800570 	cmpltui	r2,r2,21
 8216554:	103fd91e 	bne	r2,zero,82164bc <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 8216558:	0001883a 	nop
 821655c:	e037883a 	mov	sp,fp
 8216560:	dfc00117 	ldw	ra,4(sp)
 8216564:	df000017 	ldw	fp,0(sp)
 8216568:	dec00204 	addi	sp,sp,8
 821656c:	f800283a 	ret

08216570 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 8216570:	defff204 	addi	sp,sp,-56
 8216574:	dfc00d15 	stw	ra,52(sp)
 8216578:	df000c15 	stw	fp,48(sp)
 821657c:	df000c04 	addi	fp,sp,48
 8216580:	e17ffc15 	stw	r5,-16(fp)
 8216584:	e1bffd15 	stw	r6,-12(fp)
 8216588:	3807883a 	mov	r3,r7
 821658c:	e0800417 	ldw	r2,16(fp)
 8216590:	e13ffb05 	stb	r4,-20(fp)
 8216594:	e0fffe0d 	sth	r3,-8(fp)
 8216598:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821659c:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82165a0:	0005303a 	rdctl	r2,status
 82165a4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82165a8:	e0fffa17 	ldw	r3,-24(fp)
 82165ac:	00bfff84 	movi	r2,-2
 82165b0:	1884703a 	and	r2,r3,r2
 82165b4:	1001703a 	wrctl	status,r2
  
  return context;
 82165b8:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
 82165bc:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 82165c0:	d0a07217 	ldw	r2,-32312(gp)
 82165c4:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
 82165c8:	e0bff617 	ldw	r2,-40(fp)
 82165cc:	10009326 	beq	r2,zero,821681c <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 82165d0:	e0bff617 	ldw	r2,-40(fp)
 82165d4:	10800517 	ldw	r2,20(r2)
 82165d8:	d0a07215 	stw	r2,-32312(gp)
 82165dc:	e0bff417 	ldw	r2,-48(fp)
 82165e0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82165e4:	e0bff817 	ldw	r2,-32(fp)
 82165e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 82165ec:	e0bff617 	ldw	r2,-40(fp)
 82165f0:	e0fffc17 	ldw	r3,-16(fp)
 82165f4:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 82165f8:	e0bff617 	ldw	r2,-40(fp)
 82165fc:	e0fffb03 	ldbu	r3,-20(fp)
 8216600:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 8216604:	e0bff617 	ldw	r2,-40(fp)
 8216608:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 821660c:	e0bff617 	ldw	r2,-40(fp)
 8216610:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 8216614:	e0bff617 	ldw	r2,-40(fp)
 8216618:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 821661c:	e0bff617 	ldw	r2,-40(fp)
 8216620:	e0c00317 	ldw	r3,12(fp)
 8216624:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 8216628:	e0bff617 	ldw	r2,-40(fp)
 821662c:	e0c00217 	ldw	r3,8(fp)
 8216630:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 8216634:	e0bff617 	ldw	r2,-40(fp)
 8216638:	e0fffd17 	ldw	r3,-12(fp)
 821663c:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 8216640:	e0bff617 	ldw	r2,-40(fp)
 8216644:	e0ffff0b 	ldhu	r3,-4(fp)
 8216648:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 821664c:	e0bff617 	ldw	r2,-40(fp)
 8216650:	e0fffe0b 	ldhu	r3,-8(fp)
 8216654:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 8216658:	e0bff617 	ldw	r2,-40(fp)
 821665c:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 8216660:	e0bffb03 	ldbu	r2,-20(fp)
 8216664:	1004d0fa 	srli	r2,r2,3
 8216668:	1007883a 	mov	r3,r2
 821666c:	e0bff617 	ldw	r2,-40(fp)
 8216670:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 8216674:	e0bffb03 	ldbu	r2,-20(fp)
 8216678:	108001cc 	andi	r2,r2,7
 821667c:	1007883a 	mov	r3,r2
 8216680:	e0bff617 	ldw	r2,-40(fp)
 8216684:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 8216688:	e0bff617 	ldw	r2,-40(fp)
 821668c:	10800d03 	ldbu	r2,52(r2)
 8216690:	10803fcc 	andi	r2,r2,255
 8216694:	00c00044 	movi	r3,1
 8216698:	1884983a 	sll	r2,r3,r2
 821669c:	1007883a 	mov	r3,r2
 82166a0:	e0bff617 	ldw	r2,-40(fp)
 82166a4:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 82166a8:	e0bff617 	ldw	r2,-40(fp)
 82166ac:	10800cc3 	ldbu	r2,51(r2)
 82166b0:	10803fcc 	andi	r2,r2,255
 82166b4:	00c00044 	movi	r3,1
 82166b8:	1884983a 	sll	r2,r3,r2
 82166bc:	1007883a 	mov	r3,r2
 82166c0:	e0bff617 	ldw	r2,-40(fp)
 82166c4:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 82166c8:	e0bff617 	ldw	r2,-40(fp)
 82166cc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 82166d0:	e0bff617 	ldw	r2,-40(fp)
 82166d4:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 82166d8:	e0bff617 	ldw	r2,-40(fp)
 82166dc:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 82166e0:	e0bff617 	ldw	r2,-40(fp)
 82166e4:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 82166e8:	e0bff617 	ldw	r2,-40(fp)
 82166ec:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 82166f0:	e0bff617 	ldw	r2,-40(fp)
 82166f4:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 82166f8:	e0bff617 	ldw	r2,-40(fp)
 82166fc:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 8216700:	e0bff617 	ldw	r2,-40(fp)
 8216704:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 8216708:	e0bff617 	ldw	r2,-40(fp)
 821670c:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 8216710:	e0bff617 	ldw	r2,-40(fp)
 8216714:	00c00fc4 	movi	r3,63
 8216718:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 821671c:	e0bff617 	ldw	r2,-40(fp)
 8216720:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 8216724:	e13ff617 	ldw	r4,-40(fp)
 8216728:	823cc480 	call	823cc48 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 821672c:	e13ff617 	ldw	r4,-40(fp)
 8216730:	823cb340 	call	823cb34 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216734:	0005303a 	rdctl	r2,status
 8216738:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821673c:	e0fff517 	ldw	r3,-44(fp)
 8216740:	00bfff84 	movi	r2,-2
 8216744:	1884703a 	and	r2,r3,r2
 8216748:	1001703a 	wrctl	status,r2
  
  return context;
 821674c:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 8216750:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 8216754:	e0fffb03 	ldbu	r3,-20(fp)
 8216758:	008209b4 	movhi	r2,2086
 821675c:	10b54004 	addi	r2,r2,-11008
 8216760:	18c7883a 	add	r3,r3,r3
 8216764:	18c7883a 	add	r3,r3,r3
 8216768:	10c5883a 	add	r2,r2,r3
 821676c:	e0fff617 	ldw	r3,-40(fp)
 8216770:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 8216774:	d0e06e17 	ldw	r3,-32328(gp)
 8216778:	e0bff617 	ldw	r2,-40(fp)
 821677c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 8216780:	e0bff617 	ldw	r2,-40(fp)
 8216784:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 8216788:	d0a06e17 	ldw	r2,-32328(gp)
 821678c:	10000326 	beq	r2,zero,821679c <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
 8216790:	d0a06e17 	ldw	r2,-32328(gp)
 8216794:	e0fff617 	ldw	r3,-40(fp)
 8216798:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 821679c:	e0bff617 	ldw	r2,-40(fp)
 82167a0:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 82167a4:	e0bff617 	ldw	r2,-40(fp)
 82167a8:	10c00d83 	ldbu	r3,54(r2)
 82167ac:	d0a07703 	ldbu	r2,-32292(gp)
 82167b0:	1884b03a 	or	r2,r3,r2
 82167b4:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 82167b8:	e0bff617 	ldw	r2,-40(fp)
 82167bc:	10800d03 	ldbu	r2,52(r2)
 82167c0:	10c03fcc 	andi	r3,r2,255
 82167c4:	e0bff617 	ldw	r2,-40(fp)
 82167c8:	10800d03 	ldbu	r2,52(r2)
 82167cc:	11003fcc 	andi	r4,r2,255
 82167d0:	d0a07744 	addi	r2,gp,-32291
 82167d4:	2085883a 	add	r2,r4,r2
 82167d8:	11000003 	ldbu	r4,0(r2)
 82167dc:	e0bff617 	ldw	r2,-40(fp)
 82167e0:	10800d43 	ldbu	r2,53(r2)
 82167e4:	2084b03a 	or	r2,r4,r2
 82167e8:	1009883a 	mov	r4,r2
 82167ec:	d0a07744 	addi	r2,gp,-32291
 82167f0:	1885883a 	add	r2,r3,r2
 82167f4:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 82167f8:	d0a07343 	ldbu	r2,-32307(gp)
 82167fc:	10800044 	addi	r2,r2,1
 8216800:	d0a07345 	stb	r2,-32307(gp)
 8216804:	e0bff417 	ldw	r2,-48(fp)
 8216808:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821680c:	e0bff717 	ldw	r2,-36(fp)
 8216810:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 8216814:	0005883a 	mov	r2,zero
 8216818:	00000506 	br	8216830 <OS_TCBInit+0x2c0>
 821681c:	e0bff417 	ldw	r2,-48(fp)
 8216820:	e0bff915 	stw	r2,-28(fp)
 8216824:	e0bff917 	ldw	r2,-28(fp)
 8216828:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 821682c:	00801084 	movi	r2,66
}
 8216830:	e037883a 	mov	sp,fp
 8216834:	dfc00117 	ldw	ra,4(sp)
 8216838:	df000017 	ldw	fp,0(sp)
 821683c:	dec00204 	addi	sp,sp,8
 8216840:	f800283a 	ret

08216844 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 8216844:	defffe04 	addi	sp,sp,-8
 8216848:	df000115 	stw	fp,4(sp)
 821684c:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 8216850:	d0a00c04 	addi	r2,gp,-32720
 8216854:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 8216858:	d0a00d04 	addi	r2,gp,-32716
 821685c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 8216860:	d0a00e84 	addi	r2,gp,-32710
 8216864:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 8216868:	d0a00f04 	addi	r2,gp,-32708
 821686c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 8216870:	d0a00e04 	addi	r2,gp,-32712
 8216874:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 8216878:	d0a00f84 	addi	r2,gp,-32706
 821687c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 8216880:	d0a01004 	addi	r2,gp,-32704
 8216884:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 8216888:	d0a01084 	addi	r2,gp,-32702
 821688c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 8216890:	d0a01104 	addi	r2,gp,-32700
 8216894:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 8216898:	d0a01184 	addi	r2,gp,-32698
 821689c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 82168a0:	d0a01204 	addi	r2,gp,-32696
 82168a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 82168a8:	d0a01284 	addi	r2,gp,-32694
 82168ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 82168b0:	d0a01304 	addi	r2,gp,-32692
 82168b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 82168b8:	d0a01384 	addi	r2,gp,-32690
 82168bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 82168c0:	d0a01404 	addi	r2,gp,-32688
 82168c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 82168c8:	d0a01484 	addi	r2,gp,-32686
 82168cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 82168d0:	d0a01504 	addi	r2,gp,-32684
 82168d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 82168d8:	d0a01584 	addi	r2,gp,-32682
 82168dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 82168e0:	d0a01604 	addi	r2,gp,-32680
 82168e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 82168e8:	d0a01684 	addi	r2,gp,-32678
 82168ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 82168f0:	d0a01704 	addi	r2,gp,-32676
 82168f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 82168f8:	d0a01784 	addi	r2,gp,-32674
 82168fc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 8216900:	d0a01804 	addi	r2,gp,-32672
 8216904:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 8216908:	d0a01884 	addi	r2,gp,-32670
 821690c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 8216910:	d0a01904 	addi	r2,gp,-32668
 8216914:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 8216918:	d0a01984 	addi	r2,gp,-32666
 821691c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 8216920:	d0a01a04 	addi	r2,gp,-32664
 8216924:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 8216928:	d0a01a84 	addi	r2,gp,-32662
 821692c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 8216930:	d0a01b04 	addi	r2,gp,-32660
 8216934:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 8216938:	d0a01b84 	addi	r2,gp,-32658
 821693c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 8216940:	d0a01c04 	addi	r2,gp,-32656
 8216944:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 8216948:	d0a01c84 	addi	r2,gp,-32654
 821694c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 8216950:	d0a01d04 	addi	r2,gp,-32652
 8216954:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 8216958:	d0a01d84 	addi	r2,gp,-32650
 821695c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 8216960:	d0a01e04 	addi	r2,gp,-32648
 8216964:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 8216968:	d0a01e84 	addi	r2,gp,-32646
 821696c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 8216970:	d0a01f04 	addi	r2,gp,-32644
 8216974:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 8216978:	d0a01f84 	addi	r2,gp,-32642
 821697c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 8216980:	d0a02004 	addi	r2,gp,-32640
 8216984:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 8216988:	d0a02084 	addi	r2,gp,-32638
 821698c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 8216990:	d0a02104 	addi	r2,gp,-32636
 8216994:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 8216998:	d0a02184 	addi	r2,gp,-32634
 821699c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 82169a0:	d0a02204 	addi	r2,gp,-32632
 82169a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 82169a8:	d0a02284 	addi	r2,gp,-32630
 82169ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 82169b0:	d0a02304 	addi	r2,gp,-32628
 82169b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 82169b8:	d0a02804 	addi	r2,gp,-32608
 82169bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 82169c0:	0001883a 	nop
 82169c4:	e037883a 	mov	sp,fp
 82169c8:	df000017 	ldw	fp,0(sp)
 82169cc:	dec00104 	addi	sp,sp,4
 82169d0:	f800283a 	ret

082169d4 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 82169d4:	defff204 	addi	sp,sp,-56
 82169d8:	df000d15 	stw	fp,52(sp)
 82169dc:	df000d04 	addi	fp,sp,52
 82169e0:	e13ffc15 	stw	r4,-16(fp)
 82169e4:	2807883a 	mov	r3,r5
 82169e8:	3005883a 	mov	r2,r6
 82169ec:	e1ffff15 	stw	r7,-4(fp)
 82169f0:	e0fffd0d 	sth	r3,-12(fp)
 82169f4:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 82169f8:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 82169fc:	e0bfff17 	ldw	r2,-4(fp)
 8216a00:	1000021e 	bne	r2,zero,8216a0c <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 8216a04:	0005883a 	mov	r2,zero
 8216a08:	0000b006 	br	8216ccc <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216a0c:	e0bffc17 	ldw	r2,-16(fp)
 8216a10:	1000051e 	bne	r2,zero,8216a28 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216a14:	e0bfff17 	ldw	r2,-4(fp)
 8216a18:	00c01b84 	movi	r3,110
 8216a1c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216a20:	0005883a 	mov	r2,zero
 8216a24:	0000a906 	br	8216ccc <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8216a28:	e0bffc17 	ldw	r2,-16(fp)
 8216a2c:	10800003 	ldbu	r2,0(r2)
 8216a30:	10803fcc 	andi	r2,r2,255
 8216a34:	10800160 	cmpeqi	r2,r2,5
 8216a38:	1000051e 	bne	r2,zero,8216a50 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 8216a3c:	e0bfff17 	ldw	r2,-4(fp)
 8216a40:	00c00044 	movi	r3,1
 8216a44:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216a48:	0005883a 	mov	r2,zero
 8216a4c:	00009f06 	br	8216ccc <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8216a50:	e0fffe03 	ldbu	r3,-8(fp)
 8216a54:	00bfe004 	movi	r2,-128
 8216a58:	1884703a 	and	r2,r3,r2
 8216a5c:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 8216a60:	e0bff503 	ldbu	r2,-44(fp)
 8216a64:	10000626 	beq	r2,zero,8216a80 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 8216a68:	e0bffe03 	ldbu	r2,-8(fp)
 8216a6c:	10801fcc 	andi	r2,r2,127
 8216a70:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8216a74:	00800044 	movi	r2,1
 8216a78:	e0bff385 	stb	r2,-50(fp)
 8216a7c:	00000106 	br	8216a84 <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 8216a80:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 8216a84:	e0bfff17 	ldw	r2,-4(fp)
 8216a88:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216a8c:	0005303a 	rdctl	r2,status
 8216a90:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216a94:	e0fffb17 	ldw	r3,-20(fp)
 8216a98:	00bfff84 	movi	r2,-2
 8216a9c:	1884703a 	and	r2,r3,r2
 8216aa0:	1001703a 	wrctl	status,r2
  
  return context;
 8216aa4:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 8216aa8:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 8216aac:	e0bffe03 	ldbu	r2,-8(fp)
 8216ab0:	10c00060 	cmpeqi	r3,r2,1
 8216ab4:	18005f1e 	bne	r3,zero,8216c34 <OSFlagAccept+0x260>
 8216ab8:	10c00088 	cmpgei	r3,r2,2
 8216abc:	1800021e 	bne	r3,zero,8216ac8 <OSFlagAccept+0xf4>
 8216ac0:	10003f26 	beq	r2,zero,8216bc0 <OSFlagAccept+0x1ec>
 8216ac4:	00007706 	br	8216ca4 <OSFlagAccept+0x2d0>
 8216ac8:	10c000a0 	cmpeqi	r3,r2,2
 8216acc:	1800031e 	bne	r3,zero,8216adc <OSFlagAccept+0x108>
 8216ad0:	108000e0 	cmpeqi	r2,r2,3
 8216ad4:	10001e1e 	bne	r2,zero,8216b50 <OSFlagAccept+0x17c>
 8216ad8:	00007206 	br	8216ca4 <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216adc:	e0bffc17 	ldw	r2,-16(fp)
 8216ae0:	10c0020b 	ldhu	r3,8(r2)
 8216ae4:	e0bffd0b 	ldhu	r2,-12(fp)
 8216ae8:	1884703a 	and	r2,r3,r2
 8216aec:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216af0:	e0fff30b 	ldhu	r3,-52(fp)
 8216af4:	e0bffd0b 	ldhu	r2,-12(fp)
 8216af8:	18800d1e 	bne	r3,r2,8216b30 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216afc:	e0bff383 	ldbu	r2,-50(fp)
 8216b00:	10800058 	cmpnei	r2,r2,1
 8216b04:	10000d1e 	bne	r2,zero,8216b3c <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8216b08:	e0bffc17 	ldw	r2,-16(fp)
 8216b0c:	1080020b 	ldhu	r2,8(r2)
 8216b10:	1007883a 	mov	r3,r2
 8216b14:	e0bff30b 	ldhu	r2,-52(fp)
 8216b18:	0084303a 	nor	r2,zero,r2
 8216b1c:	1884703a 	and	r2,r3,r2
 8216b20:	1007883a 	mov	r3,r2
 8216b24:	e0bffc17 	ldw	r2,-16(fp)
 8216b28:	10c0020d 	sth	r3,8(r2)
 8216b2c:	00000306 	br	8216b3c <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216b30:	e0bfff17 	ldw	r2,-4(fp)
 8216b34:	00c01c04 	movi	r3,112
 8216b38:	10c00005 	stb	r3,0(r2)
 8216b3c:	e0bff417 	ldw	r2,-48(fp)
 8216b40:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216b44:	e0bff617 	ldw	r2,-40(fp)
 8216b48:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216b4c:	00005e06 	br	8216cc8 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216b50:	e0bffc17 	ldw	r2,-16(fp)
 8216b54:	10c0020b 	ldhu	r3,8(r2)
 8216b58:	e0bffd0b 	ldhu	r2,-12(fp)
 8216b5c:	1884703a 	and	r2,r3,r2
 8216b60:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 8216b64:	e0bff30b 	ldhu	r2,-52(fp)
 8216b68:	10000d26 	beq	r2,zero,8216ba0 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216b6c:	e0bff383 	ldbu	r2,-50(fp)
 8216b70:	10800058 	cmpnei	r2,r2,1
 8216b74:	10000d1e 	bne	r2,zero,8216bac <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 8216b78:	e0bffc17 	ldw	r2,-16(fp)
 8216b7c:	1080020b 	ldhu	r2,8(r2)
 8216b80:	1007883a 	mov	r3,r2
 8216b84:	e0bff30b 	ldhu	r2,-52(fp)
 8216b88:	0084303a 	nor	r2,zero,r2
 8216b8c:	1884703a 	and	r2,r3,r2
 8216b90:	1007883a 	mov	r3,r2
 8216b94:	e0bffc17 	ldw	r2,-16(fp)
 8216b98:	10c0020d 	sth	r3,8(r2)
 8216b9c:	00000306 	br	8216bac <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216ba0:	e0bfff17 	ldw	r2,-4(fp)
 8216ba4:	00c01c04 	movi	r3,112
 8216ba8:	10c00005 	stb	r3,0(r2)
 8216bac:	e0bff417 	ldw	r2,-48(fp)
 8216bb0:	e0bff715 	stw	r2,-36(fp)
 8216bb4:	e0bff717 	ldw	r2,-36(fp)
 8216bb8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216bbc:	00004206 	br	8216cc8 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8216bc0:	e0bffc17 	ldw	r2,-16(fp)
 8216bc4:	1080020b 	ldhu	r2,8(r2)
 8216bc8:	0084303a 	nor	r2,zero,r2
 8216bcc:	1007883a 	mov	r3,r2
 8216bd0:	e0bffd0b 	ldhu	r2,-12(fp)
 8216bd4:	1884703a 	and	r2,r3,r2
 8216bd8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216bdc:	e0fff30b 	ldhu	r3,-52(fp)
 8216be0:	e0bffd0b 	ldhu	r2,-12(fp)
 8216be4:	18800b1e 	bne	r3,r2,8216c14 <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216be8:	e0bff383 	ldbu	r2,-50(fp)
 8216bec:	10800058 	cmpnei	r2,r2,1
 8216bf0:	10000b1e 	bne	r2,zero,8216c20 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 8216bf4:	e0bffc17 	ldw	r2,-16(fp)
 8216bf8:	10c0020b 	ldhu	r3,8(r2)
 8216bfc:	e0bff30b 	ldhu	r2,-52(fp)
 8216c00:	1884b03a 	or	r2,r3,r2
 8216c04:	1007883a 	mov	r3,r2
 8216c08:	e0bffc17 	ldw	r2,-16(fp)
 8216c0c:	10c0020d 	sth	r3,8(r2)
 8216c10:	00000306 	br	8216c20 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216c14:	e0bfff17 	ldw	r2,-4(fp)
 8216c18:	00c01c04 	movi	r3,112
 8216c1c:	10c00005 	stb	r3,0(r2)
 8216c20:	e0bff417 	ldw	r2,-48(fp)
 8216c24:	e0bff815 	stw	r2,-32(fp)
 8216c28:	e0bff817 	ldw	r2,-32(fp)
 8216c2c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216c30:	00002506 	br	8216cc8 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 8216c34:	e0bffc17 	ldw	r2,-16(fp)
 8216c38:	1080020b 	ldhu	r2,8(r2)
 8216c3c:	0084303a 	nor	r2,zero,r2
 8216c40:	1007883a 	mov	r3,r2
 8216c44:	e0bffd0b 	ldhu	r2,-12(fp)
 8216c48:	1884703a 	and	r2,r3,r2
 8216c4c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8216c50:	e0bff30b 	ldhu	r2,-52(fp)
 8216c54:	10000b26 	beq	r2,zero,8216c84 <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216c58:	e0bff383 	ldbu	r2,-50(fp)
 8216c5c:	10800058 	cmpnei	r2,r2,1
 8216c60:	10000b1e 	bne	r2,zero,8216c90 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8216c64:	e0bffc17 	ldw	r2,-16(fp)
 8216c68:	10c0020b 	ldhu	r3,8(r2)
 8216c6c:	e0bff30b 	ldhu	r2,-52(fp)
 8216c70:	1884b03a 	or	r2,r3,r2
 8216c74:	1007883a 	mov	r3,r2
 8216c78:	e0bffc17 	ldw	r2,-16(fp)
 8216c7c:	10c0020d 	sth	r3,8(r2)
 8216c80:	00000306 	br	8216c90 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216c84:	e0bfff17 	ldw	r2,-4(fp)
 8216c88:	00c01c04 	movi	r3,112
 8216c8c:	10c00005 	stb	r3,0(r2)
 8216c90:	e0bff417 	ldw	r2,-48(fp)
 8216c94:	e0bff915 	stw	r2,-28(fp)
 8216c98:	e0bff917 	ldw	r2,-28(fp)
 8216c9c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216ca0:	00000906 	br	8216cc8 <OSFlagAccept+0x2f4>
 8216ca4:	e0bff417 	ldw	r2,-48(fp)
 8216ca8:	e0bffa15 	stw	r2,-24(fp)
 8216cac:	e0bffa17 	ldw	r2,-24(fp)
 8216cb0:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8216cb4:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 8216cb8:	e0bfff17 	ldw	r2,-4(fp)
 8216cbc:	00c01bc4 	movi	r3,111
 8216cc0:	10c00005 	stb	r3,0(r2)
             break;
 8216cc4:	0001883a 	nop
    }
    return (flags_rdy);
 8216cc8:	e0bff30b 	ldhu	r2,-52(fp)
}
 8216ccc:	e037883a 	mov	sp,fp
 8216cd0:	df000017 	ldw	fp,0(sp)
 8216cd4:	dec00104 	addi	sp,sp,4
 8216cd8:	f800283a 	ret

08216cdc <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 8216cdc:	defff804 	addi	sp,sp,-32
 8216ce0:	df000715 	stw	fp,28(sp)
 8216ce4:	df000704 	addi	fp,sp,28
 8216ce8:	2005883a 	mov	r2,r4
 8216cec:	e17fff15 	stw	r5,-4(fp)
 8216cf0:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 8216cf4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 8216cf8:	e0bfff17 	ldw	r2,-4(fp)
 8216cfc:	1000021e 	bne	r2,zero,8216d08 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 8216d00:	0005883a 	mov	r2,zero
 8216d04:	00003306 	br	8216dd4 <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 8216d08:	d0a07903 	ldbu	r2,-32284(gp)
 8216d0c:	10803fcc 	andi	r2,r2,255
 8216d10:	10000526 	beq	r2,zero,8216d28 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 8216d14:	e0bfff17 	ldw	r2,-4(fp)
 8216d18:	00c00404 	movi	r3,16
 8216d1c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 8216d20:	0005883a 	mov	r2,zero
 8216d24:	00002b06 	br	8216dd4 <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216d28:	0005303a 	rdctl	r2,status
 8216d2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216d30:	e0fffd17 	ldw	r3,-12(fp)
 8216d34:	00bfff84 	movi	r2,-2
 8216d38:	1884703a 	and	r2,r3,r2
 8216d3c:	1001703a 	wrctl	status,r2
  
  return context;
 8216d40:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8216d44:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 8216d48:	d0a07c17 	ldw	r2,-32272(gp)
 8216d4c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 8216d50:	e0bffb17 	ldw	r2,-20(fp)
 8216d54:	10001726 	beq	r2,zero,8216db4 <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 8216d58:	d0a07c17 	ldw	r2,-32272(gp)
 8216d5c:	10800117 	ldw	r2,4(r2)
 8216d60:	d0a07c15 	stw	r2,-32272(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 8216d64:	e0bffb17 	ldw	r2,-20(fp)
 8216d68:	00c00144 	movi	r3,5
 8216d6c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 8216d70:	e0bffb17 	ldw	r2,-20(fp)
 8216d74:	e0fffe0b 	ldhu	r3,-8(fp)
 8216d78:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 8216d7c:	e0bffb17 	ldw	r2,-20(fp)
 8216d80:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 8216d84:	e0bffb17 	ldw	r2,-20(fp)
 8216d88:	00c00fc4 	movi	r3,63
 8216d8c:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8216d90:	e0bffb17 	ldw	r2,-20(fp)
 8216d94:	100002c5 	stb	zero,11(r2)
 8216d98:	e0bff917 	ldw	r2,-28(fp)
 8216d9c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216da0:	e0bffa17 	ldw	r2,-24(fp)
 8216da4:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 8216da8:	e0bfff17 	ldw	r2,-4(fp)
 8216dac:	10000005 	stb	zero,0(r2)
 8216db0:	00000706 	br	8216dd0 <OSFlagCreate+0xf4>
 8216db4:	e0bff917 	ldw	r2,-28(fp)
 8216db8:	e0bffc15 	stw	r2,-16(fp)
 8216dbc:	e0bffc17 	ldw	r2,-16(fp)
 8216dc0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 8216dc4:	e0bfff17 	ldw	r2,-4(fp)
 8216dc8:	00c01c84 	movi	r3,114
 8216dcc:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 8216dd0:	e0bffb17 	ldw	r2,-20(fp)
}
 8216dd4:	e037883a 	mov	sp,fp
 8216dd8:	df000017 	ldw	fp,0(sp)
 8216ddc:	dec00104 	addi	sp,sp,4
 8216de0:	f800283a 	ret

08216de4 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 8216de4:	defff204 	addi	sp,sp,-56
 8216de8:	dfc00d15 	stw	ra,52(sp)
 8216dec:	df000c15 	stw	fp,48(sp)
 8216df0:	df000c04 	addi	fp,sp,48
 8216df4:	e13ffd15 	stw	r4,-12(fp)
 8216df8:	2805883a 	mov	r2,r5
 8216dfc:	e1bfff15 	stw	r6,-4(fp)
 8216e00:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8216e04:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8216e08:	e0bfff17 	ldw	r2,-4(fp)
 8216e0c:	1000021e 	bne	r2,zero,8216e18 <OSFlagDel+0x34>
        return (pgrp);
 8216e10:	e0bffd17 	ldw	r2,-12(fp)
 8216e14:	00008006 	br	8217018 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216e18:	e0bffd17 	ldw	r2,-12(fp)
 8216e1c:	1000051e 	bne	r2,zero,8216e34 <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216e20:	e0bfff17 	ldw	r2,-4(fp)
 8216e24:	00c01b84 	movi	r3,110
 8216e28:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8216e2c:	e0bffd17 	ldw	r2,-12(fp)
 8216e30:	00007906 	br	8217018 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8216e34:	d0a07903 	ldbu	r2,-32284(gp)
 8216e38:	10803fcc 	andi	r2,r2,255
 8216e3c:	10000526 	beq	r2,zero,8216e54 <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8216e40:	e0bfff17 	ldw	r2,-4(fp)
 8216e44:	00c003c4 	movi	r3,15
 8216e48:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8216e4c:	e0bffd17 	ldw	r2,-12(fp)
 8216e50:	00007106 	br	8217018 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 8216e54:	e0bffd17 	ldw	r2,-12(fp)
 8216e58:	10800003 	ldbu	r2,0(r2)
 8216e5c:	10803fcc 	andi	r2,r2,255
 8216e60:	10800160 	cmpeqi	r2,r2,5
 8216e64:	1000051e 	bne	r2,zero,8216e7c <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
 8216e68:	e0bfff17 	ldw	r2,-4(fp)
 8216e6c:	00c00044 	movi	r3,1
 8216e70:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8216e74:	e0bffd17 	ldw	r2,-12(fp)
 8216e78:	00006706 	br	8217018 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216e7c:	0005303a 	rdctl	r2,status
 8216e80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216e84:	e0fffc17 	ldw	r3,-16(fp)
 8216e88:	00bfff84 	movi	r2,-2
 8216e8c:	1884703a 	and	r2,r3,r2
 8216e90:	1001703a 	wrctl	status,r2
  
  return context;
 8216e94:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8216e98:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 8216e9c:	e0bffd17 	ldw	r2,-12(fp)
 8216ea0:	10800117 	ldw	r2,4(r2)
 8216ea4:	10000326 	beq	r2,zero,8216eb4 <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8216ea8:	00800044 	movi	r2,1
 8216eac:	e0bff405 	stb	r2,-48(fp)
 8216eb0:	00000106 	br	8216eb8 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8216eb4:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8216eb8:	e0bffe03 	ldbu	r2,-8(fp)
 8216ebc:	10000326 	beq	r2,zero,8216ecc <OSFlagDel+0xe8>
 8216ec0:	10800060 	cmpeqi	r2,r2,1
 8216ec4:	1000231e 	bne	r2,zero,8216f54 <OSFlagDel+0x170>
 8216ec8:	00004806 	br	8216fec <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 8216ecc:	e0bff403 	ldbu	r2,-48(fp)
 8216ed0:	1000161e 	bne	r2,zero,8216f2c <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 8216ed4:	e0bffd17 	ldw	r2,-12(fp)
 8216ed8:	00c00fc4 	movi	r3,63
 8216edc:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8216ee0:	e0bffd17 	ldw	r2,-12(fp)
 8216ee4:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8216ee8:	e0bffd17 	ldw	r2,-12(fp)
 8216eec:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 8216ef0:	d0e07c17 	ldw	r3,-32272(gp)
 8216ef4:	e0bffd17 	ldw	r2,-12(fp)
 8216ef8:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 8216efc:	e0bffd17 	ldw	r2,-12(fp)
 8216f00:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 8216f04:	e0bffd17 	ldw	r2,-12(fp)
 8216f08:	d0a07c15 	stw	r2,-32272(gp)
 8216f0c:	e0bff717 	ldw	r2,-36(fp)
 8216f10:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216f14:	e0bff817 	ldw	r2,-32(fp)
 8216f18:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 8216f1c:	e0bfff17 	ldw	r2,-4(fp)
 8216f20:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 8216f24:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 8216f28:	00003a06 	br	8217014 <OSFlagDel+0x230>
 8216f2c:	e0bff717 	ldw	r2,-36(fp)
 8216f30:	e0bff915 	stw	r2,-28(fp)
 8216f34:	e0bff917 	ldw	r2,-28(fp)
 8216f38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 8216f3c:	e0bfff17 	ldw	r2,-4(fp)
 8216f40:	00c01244 	movi	r3,73
 8216f44:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 8216f48:	e0bffd17 	ldw	r2,-12(fp)
 8216f4c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8216f50:	00003006 	br	8217014 <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8216f54:	e0bffd17 	ldw	r2,-12(fp)
 8216f58:	10800117 	ldw	r2,4(r2)
 8216f5c:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8216f60:	00000606 	br	8216f7c <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 8216f64:	000b883a 	mov	r5,zero
 8216f68:	e13ff517 	ldw	r4,-44(fp)
 8216f6c:	8217f500 	call	8217f50 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8216f70:	e0bff517 	ldw	r2,-44(fp)
 8216f74:	10800017 	ldw	r2,0(r2)
 8216f78:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8216f7c:	e0bff517 	ldw	r2,-44(fp)
 8216f80:	103ff81e 	bne	r2,zero,8216f64 <OSFlagDel+0x180>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 8216f84:	e0bffd17 	ldw	r2,-12(fp)
 8216f88:	00c00fc4 	movi	r3,63
 8216f8c:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8216f90:	e0bffd17 	ldw	r2,-12(fp)
 8216f94:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8216f98:	e0bffd17 	ldw	r2,-12(fp)
 8216f9c:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 8216fa0:	d0e07c17 	ldw	r3,-32272(gp)
 8216fa4:	e0bffd17 	ldw	r2,-12(fp)
 8216fa8:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 8216fac:	e0bffd17 	ldw	r2,-12(fp)
 8216fb0:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 8216fb4:	e0bffd17 	ldw	r2,-12(fp)
 8216fb8:	d0a07c15 	stw	r2,-32272(gp)
 8216fbc:	e0bff717 	ldw	r2,-36(fp)
 8216fc0:	e0bffa15 	stw	r2,-24(fp)
 8216fc4:	e0bffa17 	ldw	r2,-24(fp)
 8216fc8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8216fcc:	e0bff403 	ldbu	r2,-48(fp)
 8216fd0:	10800058 	cmpnei	r2,r2,1
 8216fd4:	1000011e 	bne	r2,zero,8216fdc <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8216fd8:	82161580 	call	8216158 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 8216fdc:	e0bfff17 	ldw	r2,-4(fp)
 8216fe0:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 8216fe4:	e03ff615 	stw	zero,-40(fp)
             break;
 8216fe8:	00000a06 	br	8217014 <OSFlagDel+0x230>
 8216fec:	e0bff717 	ldw	r2,-36(fp)
 8216ff0:	e0bffb15 	stw	r2,-20(fp)
 8216ff4:	e0bffb17 	ldw	r2,-20(fp)
 8216ff8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 8216ffc:	e0bfff17 	ldw	r2,-4(fp)
 8217000:	00c001c4 	movi	r3,7
 8217004:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 8217008:	e0bffd17 	ldw	r2,-12(fp)
 821700c:	e0bff615 	stw	r2,-40(fp)
             break;
 8217010:	0001883a 	nop
    }
    return (pgrp_return);
 8217014:	e0bff617 	ldw	r2,-40(fp)
}
 8217018:	e037883a 	mov	sp,fp
 821701c:	dfc00117 	ldw	ra,4(sp)
 8217020:	df000017 	ldw	fp,0(sp)
 8217024:	dec00204 	addi	sp,sp,8
 8217028:	f800283a 	ret

0821702c <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 821702c:	defff604 	addi	sp,sp,-40
 8217030:	dfc00915 	stw	ra,36(sp)
 8217034:	df000815 	stw	fp,32(sp)
 8217038:	df000804 	addi	fp,sp,32
 821703c:	e13ffd15 	stw	r4,-12(fp)
 8217040:	e17ffe15 	stw	r5,-8(fp)
 8217044:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217048:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 821704c:	e0bfff17 	ldw	r2,-4(fp)
 8217050:	1000021e 	bne	r2,zero,821705c <OSFlagNameGet+0x30>
        return (0);
 8217054:	0005883a 	mov	r2,zero
 8217058:	00003906 	br	8217140 <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 821705c:	e0bffd17 	ldw	r2,-12(fp)
 8217060:	1000051e 	bne	r2,zero,8217078 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217064:	e0bfff17 	ldw	r2,-4(fp)
 8217068:	00c01b84 	movi	r3,110
 821706c:	10c00005 	stb	r3,0(r2)
        return (0);
 8217070:	0005883a 	mov	r2,zero
 8217074:	00003206 	br	8217140 <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8217078:	e0bffe17 	ldw	r2,-8(fp)
 821707c:	1000051e 	bne	r2,zero,8217094 <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8217080:	e0bfff17 	ldw	r2,-4(fp)
 8217084:	00c00304 	movi	r3,12
 8217088:	10c00005 	stb	r3,0(r2)
        return (0);
 821708c:	0005883a 	mov	r2,zero
 8217090:	00002b06 	br	8217140 <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8217094:	d0a07903 	ldbu	r2,-32284(gp)
 8217098:	10803fcc 	andi	r2,r2,255
 821709c:	10000526 	beq	r2,zero,82170b4 <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 82170a0:	e0bfff17 	ldw	r2,-4(fp)
 82170a4:	00c00444 	movi	r3,17
 82170a8:	10c00005 	stb	r3,0(r2)
        return (0);
 82170ac:	0005883a 	mov	r2,zero
 82170b0:	00002306 	br	8217140 <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82170b4:	0005303a 	rdctl	r2,status
 82170b8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82170bc:	e0fffc17 	ldw	r3,-16(fp)
 82170c0:	00bfff84 	movi	r2,-2
 82170c4:	1884703a 	and	r2,r3,r2
 82170c8:	1001703a 	wrctl	status,r2
  
  return context;
 82170cc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82170d0:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 82170d4:	e0bffd17 	ldw	r2,-12(fp)
 82170d8:	10800003 	ldbu	r2,0(r2)
 82170dc:	10803fcc 	andi	r2,r2,255
 82170e0:	10800160 	cmpeqi	r2,r2,5
 82170e4:	1000091e 	bne	r2,zero,821710c <OSFlagNameGet+0xe0>
 82170e8:	e0bff817 	ldw	r2,-32(fp)
 82170ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82170f0:	e0bff917 	ldw	r2,-28(fp)
 82170f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 82170f8:	e0bfff17 	ldw	r2,-4(fp)
 82170fc:	00c00044 	movi	r3,1
 8217100:	10c00005 	stb	r3,0(r2)
        return (0);
 8217104:	0005883a 	mov	r2,zero
 8217108:	00000d06 	br	8217140 <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 821710c:	e0bffd17 	ldw	r2,-12(fp)
 8217110:	10800284 	addi	r2,r2,10
 8217114:	100b883a 	mov	r5,r2
 8217118:	e13ffe17 	ldw	r4,-8(fp)
 821711c:	821629c0 	call	821629c <OS_StrCopy>
 8217120:	e0bffb05 	stb	r2,-20(fp)
 8217124:	e0bff817 	ldw	r2,-32(fp)
 8217128:	e0bffa15 	stw	r2,-24(fp)
 821712c:	e0bffa17 	ldw	r2,-24(fp)
 8217130:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217134:	e0bfff17 	ldw	r2,-4(fp)
 8217138:	10000005 	stb	zero,0(r2)
    return (len);
 821713c:	e0bffb03 	ldbu	r2,-20(fp)
}
 8217140:	e037883a 	mov	sp,fp
 8217144:	dfc00117 	ldw	ra,4(sp)
 8217148:	df000017 	ldw	fp,0(sp)
 821714c:	dec00204 	addi	sp,sp,8
 8217150:	f800283a 	ret

08217154 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 8217154:	defff504 	addi	sp,sp,-44
 8217158:	dfc00a15 	stw	ra,40(sp)
 821715c:	df000915 	stw	fp,36(sp)
 8217160:	df000904 	addi	fp,sp,36
 8217164:	e13ffd15 	stw	r4,-12(fp)
 8217168:	e17ffe15 	stw	r5,-8(fp)
 821716c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217170:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8217174:	e0bfff17 	ldw	r2,-4(fp)
 8217178:	10004326 	beq	r2,zero,8217288 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 821717c:	e0bffd17 	ldw	r2,-12(fp)
 8217180:	1000041e 	bne	r2,zero,8217194 <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217184:	e0bfff17 	ldw	r2,-4(fp)
 8217188:	00c01b84 	movi	r3,110
 821718c:	10c00005 	stb	r3,0(r2)
        return;
 8217190:	00003e06 	br	821728c <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8217194:	e0bffe17 	ldw	r2,-8(fp)
 8217198:	1000041e 	bne	r2,zero,82171ac <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 821719c:	e0bfff17 	ldw	r2,-4(fp)
 82171a0:	00c00304 	movi	r3,12
 82171a4:	10c00005 	stb	r3,0(r2)
        return;
 82171a8:	00003806 	br	821728c <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82171ac:	d0a07903 	ldbu	r2,-32284(gp)
 82171b0:	10803fcc 	andi	r2,r2,255
 82171b4:	10000426 	beq	r2,zero,82171c8 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 82171b8:	e0bfff17 	ldw	r2,-4(fp)
 82171bc:	00c00484 	movi	r3,18
 82171c0:	10c00005 	stb	r3,0(r2)
        return;
 82171c4:	00003106 	br	821728c <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82171c8:	0005303a 	rdctl	r2,status
 82171cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82171d0:	e0fffc17 	ldw	r3,-16(fp)
 82171d4:	00bfff84 	movi	r2,-2
 82171d8:	1884703a 	and	r2,r3,r2
 82171dc:	1001703a 	wrctl	status,r2
  
  return context;
 82171e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82171e4:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 82171e8:	e0bffd17 	ldw	r2,-12(fp)
 82171ec:	10800003 	ldbu	r2,0(r2)
 82171f0:	10803fcc 	andi	r2,r2,255
 82171f4:	10800160 	cmpeqi	r2,r2,5
 82171f8:	1000081e 	bne	r2,zero,821721c <OSFlagNameSet+0xc8>
 82171fc:	e0bff717 	ldw	r2,-36(fp)
 8217200:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217204:	e0bff817 	ldw	r2,-32(fp)
 8217208:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 821720c:	e0bfff17 	ldw	r2,-4(fp)
 8217210:	00c00044 	movi	r3,1
 8217214:	10c00005 	stb	r3,0(r2)
        return;
 8217218:	00001c06 	br	821728c <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 821721c:	e13ffe17 	ldw	r4,-8(fp)
 8217220:	82163100 	call	8216310 <OS_StrLen>
 8217224:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 8217228:	e0bffa03 	ldbu	r2,-24(fp)
 821722c:	10800830 	cmpltui	r2,r2,32
 8217230:	1000081e 	bne	r2,zero,8217254 <OSFlagNameSet+0x100>
 8217234:	e0bff717 	ldw	r2,-36(fp)
 8217238:	e0bff915 	stw	r2,-28(fp)
 821723c:	e0bff917 	ldw	r2,-28(fp)
 8217240:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 8217244:	e0bfff17 	ldw	r2,-4(fp)
 8217248:	00c01cc4 	movi	r3,115
 821724c:	10c00005 	stb	r3,0(r2)
        return;
 8217250:	00000e06 	br	821728c <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 8217254:	e0bffd17 	ldw	r2,-12(fp)
 8217258:	10800284 	addi	r2,r2,10
 821725c:	e17ffe17 	ldw	r5,-8(fp)
 8217260:	1009883a 	mov	r4,r2
 8217264:	821629c0 	call	821629c <OS_StrCopy>
 8217268:	e0bff717 	ldw	r2,-36(fp)
 821726c:	e0bffb15 	stw	r2,-20(fp)
 8217270:	e0bffb17 	ldw	r2,-20(fp)
 8217274:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217278:	e0bfff17 	ldw	r2,-4(fp)
 821727c:	10000005 	stb	zero,0(r2)
    return;
 8217280:	0001883a 	nop
 8217284:	00000106 	br	821728c <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8217288:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 821728c:	e037883a 	mov	sp,fp
 8217290:	dfc00117 	ldw	ra,4(sp)
 8217294:	df000017 	ldw	fp,0(sp)
 8217298:	dec00204 	addi	sp,sp,8
 821729c:	f800283a 	ret

082172a0 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 82172a0:	deffe104 	addi	sp,sp,-124
 82172a4:	dfc01e15 	stw	ra,120(sp)
 82172a8:	df001d15 	stw	fp,116(sp)
 82172ac:	df001d04 	addi	fp,sp,116
 82172b0:	e13ffc15 	stw	r4,-16(fp)
 82172b4:	2809883a 	mov	r4,r5
 82172b8:	3007883a 	mov	r3,r6
 82172bc:	3805883a 	mov	r2,r7
 82172c0:	e13ffd0d 	sth	r4,-12(fp)
 82172c4:	e0fffe05 	stb	r3,-8(fp)
 82172c8:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 82172cc:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 82172d0:	e0800217 	ldw	r2,8(fp)
 82172d4:	1000021e 	bne	r2,zero,82172e0 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 82172d8:	0005883a 	mov	r2,zero
 82172dc:	00015906 	br	8217844 <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 82172e0:	e0bffc17 	ldw	r2,-16(fp)
 82172e4:	1000051e 	bne	r2,zero,82172fc <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82172e8:	e0800217 	ldw	r2,8(fp)
 82172ec:	00c01b84 	movi	r3,110
 82172f0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 82172f4:	0005883a 	mov	r2,zero
 82172f8:	00015206 	br	8217844 <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 82172fc:	d0a07903 	ldbu	r2,-32284(gp)
 8217300:	10803fcc 	andi	r2,r2,255
 8217304:	10000526 	beq	r2,zero,821731c <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 8217308:	e0800217 	ldw	r2,8(fp)
 821730c:	00c00084 	movi	r3,2
 8217310:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217314:	0005883a 	mov	r2,zero
 8217318:	00014a06 	br	8217844 <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 821731c:	d0a06b03 	ldbu	r2,-32340(gp)
 8217320:	10803fcc 	andi	r2,r2,255
 8217324:	10000526 	beq	r2,zero,821733c <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 8217328:	e0800217 	ldw	r2,8(fp)
 821732c:	00c00344 	movi	r3,13
 8217330:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217334:	0005883a 	mov	r2,zero
 8217338:	00014206 	br	8217844 <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 821733c:	e0bffc17 	ldw	r2,-16(fp)
 8217340:	10800003 	ldbu	r2,0(r2)
 8217344:	10803fcc 	andi	r2,r2,255
 8217348:	10800160 	cmpeqi	r2,r2,5
 821734c:	1000051e 	bne	r2,zero,8217364 <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
 8217350:	e0800217 	ldw	r2,8(fp)
 8217354:	00c00044 	movi	r3,1
 8217358:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821735c:	0005883a 	mov	r2,zero
 8217360:	00013806 	br	8217844 <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8217364:	e0fffe03 	ldbu	r3,-8(fp)
 8217368:	00bfe004 	movi	r2,-128
 821736c:	1884703a 	and	r2,r3,r2
 8217370:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 8217374:	e0bfe603 	ldbu	r2,-104(fp)
 8217378:	10000626 	beq	r2,zero,8217394 <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 821737c:	e0bffe03 	ldbu	r2,-8(fp)
 8217380:	10801fcc 	andi	r2,r2,127
 8217384:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8217388:	00800044 	movi	r2,1
 821738c:	e0bfe405 	stb	r2,-112(fp)
 8217390:	00000106 	br	8217398 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
 8217394:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217398:	0005303a 	rdctl	r2,status
 821739c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82173a0:	e0fff617 	ldw	r3,-40(fp)
 82173a4:	00bfff84 	movi	r2,-2
 82173a8:	1884703a 	and	r2,r3,r2
 82173ac:	1001703a 	wrctl	status,r2
  
  return context;
 82173b0:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 82173b4:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
 82173b8:	e0bffe03 	ldbu	r2,-8(fp)
 82173bc:	10c00060 	cmpeqi	r3,r2,1
 82173c0:	1800921e 	bne	r3,zero,821760c <OSFlagPend+0x36c>
 82173c4:	10c00088 	cmpgei	r3,r2,2
 82173c8:	1800021e 	bne	r3,zero,82173d4 <OSFlagPend+0x134>
 82173cc:	10006126 	beq	r2,zero,8217554 <OSFlagPend+0x2b4>
 82173d0:	0000bb06 	br	82176c0 <OSFlagPend+0x420>
 82173d4:	10c000a0 	cmpeqi	r3,r2,2
 82173d8:	1800031e 	bne	r3,zero,82173e8 <OSFlagPend+0x148>
 82173dc:	108000e0 	cmpeqi	r2,r2,3
 82173e0:	10002f1e 	bne	r2,zero,82174a0 <OSFlagPend+0x200>
 82173e4:	0000b606 	br	82176c0 <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 82173e8:	e0bffc17 	ldw	r2,-16(fp)
 82173ec:	10c0020b 	ldhu	r3,8(r2)
 82173f0:	e0bffd0b 	ldhu	r2,-12(fp)
 82173f4:	1884703a 	and	r2,r3,r2
 82173f8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 82173fc:	e0ffe80b 	ldhu	r3,-96(fp)
 8217400:	e0bffd0b 	ldhu	r2,-12(fp)
 8217404:	1880171e 	bne	r3,r2,8217464 <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217408:	e0bfe403 	ldbu	r2,-112(fp)
 821740c:	10800058 	cmpnei	r2,r2,1
 8217410:	1000091e 	bne	r2,zero,8217438 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8217414:	e0bffc17 	ldw	r2,-16(fp)
 8217418:	1080020b 	ldhu	r2,8(r2)
 821741c:	1007883a 	mov	r3,r2
 8217420:	e0bfe80b 	ldhu	r2,-96(fp)
 8217424:	0084303a 	nor	r2,zero,r2
 8217428:	1884703a 	and	r2,r3,r2
 821742c:	1007883a 	mov	r3,r2
 8217430:	e0bffc17 	ldw	r2,-16(fp)
 8217434:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217438:	d0a07a17 	ldw	r2,-32280(gp)
 821743c:	e0ffe80b 	ldhu	r3,-96(fp)
 8217440:	10c00b0d 	sth	r3,44(r2)
 8217444:	e0bfe517 	ldw	r2,-108(fp)
 8217448:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821744c:	e0bfe717 	ldw	r2,-100(fp)
 8217450:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217454:	e0800217 	ldw	r2,8(fp)
 8217458:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 821745c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217460:	0000f806 	br	8217844 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217464:	e13ffd0b 	ldhu	r4,-12(fp)
 8217468:	e17ffe03 	ldbu	r5,-8(fp)
 821746c:	e0bfff0b 	ldhu	r2,-4(fp)
 8217470:	e0fff704 	addi	r3,fp,-36
 8217474:	d8800015 	stw	r2,0(sp)
 8217478:	280f883a 	mov	r7,r5
 821747c:	200d883a 	mov	r6,r4
 8217480:	180b883a 	mov	r5,r3
 8217484:	e13ffc17 	ldw	r4,-16(fp)
 8217488:	8217d100 	call	8217d10 <OS_FlagBlock>
 821748c:	e0bfe517 	ldw	r2,-108(fp)
 8217490:	e0bfe915 	stw	r2,-92(fp)
 8217494:	e0bfe917 	ldw	r2,-92(fp)
 8217498:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 821749c:	00009206 	br	82176e8 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 82174a0:	e0bffc17 	ldw	r2,-16(fp)
 82174a4:	10c0020b 	ldhu	r3,8(r2)
 82174a8:	e0bffd0b 	ldhu	r2,-12(fp)
 82174ac:	1884703a 	and	r2,r3,r2
 82174b0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 82174b4:	e0bfe80b 	ldhu	r2,-96(fp)
 82174b8:	10001726 	beq	r2,zero,8217518 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82174bc:	e0bfe403 	ldbu	r2,-112(fp)
 82174c0:	10800058 	cmpnei	r2,r2,1
 82174c4:	1000091e 	bne	r2,zero,82174ec <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 82174c8:	e0bffc17 	ldw	r2,-16(fp)
 82174cc:	1080020b 	ldhu	r2,8(r2)
 82174d0:	1007883a 	mov	r3,r2
 82174d4:	e0bfe80b 	ldhu	r2,-96(fp)
 82174d8:	0084303a 	nor	r2,zero,r2
 82174dc:	1884703a 	and	r2,r3,r2
 82174e0:	1007883a 	mov	r3,r2
 82174e4:	e0bffc17 	ldw	r2,-16(fp)
 82174e8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 82174ec:	d0a07a17 	ldw	r2,-32280(gp)
 82174f0:	e0ffe80b 	ldhu	r3,-96(fp)
 82174f4:	10c00b0d 	sth	r3,44(r2)
 82174f8:	e0bfe517 	ldw	r2,-108(fp)
 82174fc:	e0bfea15 	stw	r2,-88(fp)
 8217500:	e0bfea17 	ldw	r2,-88(fp)
 8217504:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217508:	e0800217 	ldw	r2,8(fp)
 821750c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217510:	e0bfe80b 	ldhu	r2,-96(fp)
 8217514:	0000cb06 	br	8217844 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217518:	e13ffd0b 	ldhu	r4,-12(fp)
 821751c:	e17ffe03 	ldbu	r5,-8(fp)
 8217520:	e0bfff0b 	ldhu	r2,-4(fp)
 8217524:	e0fff704 	addi	r3,fp,-36
 8217528:	d8800015 	stw	r2,0(sp)
 821752c:	280f883a 	mov	r7,r5
 8217530:	200d883a 	mov	r6,r4
 8217534:	180b883a 	mov	r5,r3
 8217538:	e13ffc17 	ldw	r4,-16(fp)
 821753c:	8217d100 	call	8217d10 <OS_FlagBlock>
 8217540:	e0bfe517 	ldw	r2,-108(fp)
 8217544:	e0bfeb15 	stw	r2,-84(fp)
 8217548:	e0bfeb17 	ldw	r2,-84(fp)
 821754c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217550:	00006506 	br	82176e8 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8217554:	e0bffc17 	ldw	r2,-16(fp)
 8217558:	1080020b 	ldhu	r2,8(r2)
 821755c:	0084303a 	nor	r2,zero,r2
 8217560:	1007883a 	mov	r3,r2
 8217564:	e0bffd0b 	ldhu	r2,-12(fp)
 8217568:	1884703a 	and	r2,r3,r2
 821756c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8217570:	e0ffe80b 	ldhu	r3,-96(fp)
 8217574:	e0bffd0b 	ldhu	r2,-12(fp)
 8217578:	1880151e 	bne	r3,r2,82175d0 <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 821757c:	e0bfe403 	ldbu	r2,-112(fp)
 8217580:	10800058 	cmpnei	r2,r2,1
 8217584:	1000071e 	bne	r2,zero,82175a4 <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 8217588:	e0bffc17 	ldw	r2,-16(fp)
 821758c:	10c0020b 	ldhu	r3,8(r2)
 8217590:	e0bfe80b 	ldhu	r2,-96(fp)
 8217594:	1884b03a 	or	r2,r3,r2
 8217598:	1007883a 	mov	r3,r2
 821759c:	e0bffc17 	ldw	r2,-16(fp)
 82175a0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 82175a4:	d0a07a17 	ldw	r2,-32280(gp)
 82175a8:	e0ffe80b 	ldhu	r3,-96(fp)
 82175ac:	10c00b0d 	sth	r3,44(r2)
 82175b0:	e0bfe517 	ldw	r2,-108(fp)
 82175b4:	e0bfec15 	stw	r2,-80(fp)
 82175b8:	e0bfec17 	ldw	r2,-80(fp)
 82175bc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 82175c0:	e0800217 	ldw	r2,8(fp)
 82175c4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 82175c8:	e0bfe80b 	ldhu	r2,-96(fp)
 82175cc:	00009d06 	br	8217844 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 82175d0:	e13ffd0b 	ldhu	r4,-12(fp)
 82175d4:	e17ffe03 	ldbu	r5,-8(fp)
 82175d8:	e0bfff0b 	ldhu	r2,-4(fp)
 82175dc:	e0fff704 	addi	r3,fp,-36
 82175e0:	d8800015 	stw	r2,0(sp)
 82175e4:	280f883a 	mov	r7,r5
 82175e8:	200d883a 	mov	r6,r4
 82175ec:	180b883a 	mov	r5,r3
 82175f0:	e13ffc17 	ldw	r4,-16(fp)
 82175f4:	8217d100 	call	8217d10 <OS_FlagBlock>
 82175f8:	e0bfe517 	ldw	r2,-108(fp)
 82175fc:	e0bfed15 	stw	r2,-76(fp)
 8217600:	e0bfed17 	ldw	r2,-76(fp)
 8217604:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217608:	00003706 	br	82176e8 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 821760c:	e0bffc17 	ldw	r2,-16(fp)
 8217610:	1080020b 	ldhu	r2,8(r2)
 8217614:	0084303a 	nor	r2,zero,r2
 8217618:	1007883a 	mov	r3,r2
 821761c:	e0bffd0b 	ldhu	r2,-12(fp)
 8217620:	1884703a 	and	r2,r3,r2
 8217624:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8217628:	e0bfe80b 	ldhu	r2,-96(fp)
 821762c:	10001526 	beq	r2,zero,8217684 <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217630:	e0bfe403 	ldbu	r2,-112(fp)
 8217634:	10800058 	cmpnei	r2,r2,1
 8217638:	1000071e 	bne	r2,zero,8217658 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 821763c:	e0bffc17 	ldw	r2,-16(fp)
 8217640:	10c0020b 	ldhu	r3,8(r2)
 8217644:	e0bfe80b 	ldhu	r2,-96(fp)
 8217648:	1884b03a 	or	r2,r3,r2
 821764c:	1007883a 	mov	r3,r2
 8217650:	e0bffc17 	ldw	r2,-16(fp)
 8217654:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217658:	d0a07a17 	ldw	r2,-32280(gp)
 821765c:	e0ffe80b 	ldhu	r3,-96(fp)
 8217660:	10c00b0d 	sth	r3,44(r2)
 8217664:	e0bfe517 	ldw	r2,-108(fp)
 8217668:	e0bfee15 	stw	r2,-72(fp)
 821766c:	e0bfee17 	ldw	r2,-72(fp)
 8217670:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217674:	e0800217 	ldw	r2,8(fp)
 8217678:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 821767c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217680:	00007006 	br	8217844 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217684:	e13ffd0b 	ldhu	r4,-12(fp)
 8217688:	e17ffe03 	ldbu	r5,-8(fp)
 821768c:	e0bfff0b 	ldhu	r2,-4(fp)
 8217690:	e0fff704 	addi	r3,fp,-36
 8217694:	d8800015 	stw	r2,0(sp)
 8217698:	280f883a 	mov	r7,r5
 821769c:	200d883a 	mov	r6,r4
 82176a0:	180b883a 	mov	r5,r3
 82176a4:	e13ffc17 	ldw	r4,-16(fp)
 82176a8:	8217d100 	call	8217d10 <OS_FlagBlock>
 82176ac:	e0bfe517 	ldw	r2,-108(fp)
 82176b0:	e0bfef15 	stw	r2,-68(fp)
 82176b4:	e0bfef17 	ldw	r2,-68(fp)
 82176b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82176bc:	00000a06 	br	82176e8 <OSFlagPend+0x448>
 82176c0:	e0bfe517 	ldw	r2,-108(fp)
 82176c4:	e0bff015 	stw	r2,-64(fp)
 82176c8:	e0bff017 	ldw	r2,-64(fp)
 82176cc:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 82176d0:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 82176d4:	e0800217 	ldw	r2,8(fp)
 82176d8:	00c01bc4 	movi	r3,111
 82176dc:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 82176e0:	e0bfe80b 	ldhu	r2,-96(fp)
 82176e4:	00005706 	br	8217844 <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 82176e8:	82161580 	call	8216158 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82176ec:	0005303a 	rdctl	r2,status
 82176f0:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82176f4:	e0fff117 	ldw	r3,-60(fp)
 82176f8:	00bfff84 	movi	r2,-2
 82176fc:	1884703a 	and	r2,r3,r2
 8217700:	1001703a 	wrctl	status,r2
  
  return context;
 8217704:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
 8217708:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 821770c:	d0a07a17 	ldw	r2,-32280(gp)
 8217710:	10800c43 	ldbu	r2,49(r2)
 8217714:	10803fcc 	andi	r2,r2,255
 8217718:	10001c26 	beq	r2,zero,821778c <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 821771c:	d0a07a17 	ldw	r2,-32280(gp)
 8217720:	10800c43 	ldbu	r2,49(r2)
 8217724:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8217728:	d0a07a17 	ldw	r2,-32280(gp)
 821772c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 8217730:	e0bff704 	addi	r2,fp,-36
 8217734:	1009883a 	mov	r4,r2
 8217738:	82180440 	call	8218044 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 821773c:	d0a07a17 	ldw	r2,-32280(gp)
 8217740:	10000c05 	stb	zero,48(r2)
 8217744:	e0bfe517 	ldw	r2,-108(fp)
 8217748:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821774c:	e0bff217 	ldw	r2,-56(fp)
 8217750:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 8217754:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
 8217758:	e0bff303 	ldbu	r2,-52(fp)
 821775c:	108000a0 	cmpeqi	r2,r2,2
 8217760:	10000426 	beq	r2,zero,8217774 <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 8217764:	e0800217 	ldw	r2,8(fp)
 8217768:	00c00384 	movi	r3,14
 821776c:	10c00005 	stb	r3,0(r2)
                 break;
 8217770:	00000406 	br	8217784 <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 8217774:	e0800217 	ldw	r2,8(fp)
 8217778:	00c00284 	movi	r3,10
 821777c:	10c00005 	stb	r3,0(r2)
                 break;
 8217780:	0001883a 	nop
        }
        return (flags_rdy);
 8217784:	e0bfe80b 	ldhu	r2,-96(fp)
 8217788:	00002e06 	br	8217844 <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 821778c:	d0a07a17 	ldw	r2,-32280(gp)
 8217790:	10800b0b 	ldhu	r2,44(r2)
 8217794:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 8217798:	e0bfe403 	ldbu	r2,-112(fp)
 821779c:	10800058 	cmpnei	r2,r2,1
 82177a0:	1000211e 	bne	r2,zero,8217828 <OSFlagPend+0x588>
        switch (wait_type) {
 82177a4:	e0bffe03 	ldbu	r2,-8(fp)
 82177a8:	10001616 	blt	r2,zero,8217804 <OSFlagPend+0x564>
 82177ac:	10c00090 	cmplti	r3,r2,2
 82177b0:	18000c1e 	bne	r3,zero,82177e4 <OSFlagPend+0x544>
 82177b4:	10800108 	cmpgei	r2,r2,4
 82177b8:	1000121e 	bne	r2,zero,8217804 <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 82177bc:	e0bffc17 	ldw	r2,-16(fp)
 82177c0:	1080020b 	ldhu	r2,8(r2)
 82177c4:	1007883a 	mov	r3,r2
 82177c8:	e0bfe80b 	ldhu	r2,-96(fp)
 82177cc:	0084303a 	nor	r2,zero,r2
 82177d0:	1884703a 	and	r2,r3,r2
 82177d4:	1007883a 	mov	r3,r2
 82177d8:	e0bffc17 	ldw	r2,-16(fp)
 82177dc:	10c0020d 	sth	r3,8(r2)
                 break;
 82177e0:	00001106 	br	8217828 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 82177e4:	e0bffc17 	ldw	r2,-16(fp)
 82177e8:	10c0020b 	ldhu	r3,8(r2)
 82177ec:	e0bfe80b 	ldhu	r2,-96(fp)
 82177f0:	1884b03a 	or	r2,r3,r2
 82177f4:	1007883a 	mov	r3,r2
 82177f8:	e0bffc17 	ldw	r2,-16(fp)
 82177fc:	10c0020d 	sth	r3,8(r2)
                 break;
 8217800:	00000906 	br	8217828 <OSFlagPend+0x588>
 8217804:	e0bfe517 	ldw	r2,-108(fp)
 8217808:	e0bff415 	stw	r2,-48(fp)
 821780c:	e0bff417 	ldw	r2,-48(fp)
 8217810:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217814:	e0800217 	ldw	r2,8(fp)
 8217818:	00c01bc4 	movi	r3,111
 821781c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217820:	0005883a 	mov	r2,zero
 8217824:	00000706 	br	8217844 <OSFlagPend+0x5a4>
 8217828:	e0bfe517 	ldw	r2,-108(fp)
 821782c:	e0bff515 	stw	r2,-44(fp)
 8217830:	e0bff517 	ldw	r2,-44(fp)
 8217834:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 8217838:	e0800217 	ldw	r2,8(fp)
 821783c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 8217840:	e0bfe80b 	ldhu	r2,-96(fp)
}
 8217844:	e037883a 	mov	sp,fp
 8217848:	dfc00117 	ldw	ra,4(sp)
 821784c:	df000017 	ldw	fp,0(sp)
 8217850:	dec00204 	addi	sp,sp,8
 8217854:	f800283a 	ret

08217858 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 8217858:	defffb04 	addi	sp,sp,-20
 821785c:	df000415 	stw	fp,16(sp)
 8217860:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8217864:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217868:	0005303a 	rdctl	r2,status
 821786c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217870:	e0fffe17 	ldw	r3,-8(fp)
 8217874:	00bfff84 	movi	r2,-2
 8217878:	1884703a 	and	r2,r3,r2
 821787c:	1001703a 	wrctl	status,r2
  
  return context;
 8217880:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 8217884:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 8217888:	d0a07a17 	ldw	r2,-32280(gp)
 821788c:	10800b0b 	ldhu	r2,44(r2)
 8217890:	e0bffd0d 	sth	r2,-12(fp)
 8217894:	e0bffc17 	ldw	r2,-16(fp)
 8217898:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821789c:	e0bfff17 	ldw	r2,-4(fp)
 82178a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 82178a4:	e0bffd0b 	ldhu	r2,-12(fp)
}
 82178a8:	e037883a 	mov	sp,fp
 82178ac:	df000017 	ldw	fp,0(sp)
 82178b0:	dec00104 	addi	sp,sp,4
 82178b4:	f800283a 	ret

082178b8 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 82178b8:	deffef04 	addi	sp,sp,-68
 82178bc:	dfc01015 	stw	ra,64(sp)
 82178c0:	df000f15 	stw	fp,60(sp)
 82178c4:	df000f04 	addi	fp,sp,60
 82178c8:	e13ffc15 	stw	r4,-16(fp)
 82178cc:	2807883a 	mov	r3,r5
 82178d0:	3005883a 	mov	r2,r6
 82178d4:	e1ffff15 	stw	r7,-4(fp)
 82178d8:	e0fffd0d 	sth	r3,-12(fp)
 82178dc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 82178e0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 82178e4:	e0bfff17 	ldw	r2,-4(fp)
 82178e8:	1000021e 	bne	r2,zero,82178f4 <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 82178ec:	0005883a 	mov	r2,zero
 82178f0:	0000d106 	br	8217c38 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 82178f4:	e0bffc17 	ldw	r2,-16(fp)
 82178f8:	1000051e 	bne	r2,zero,8217910 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82178fc:	e0bfff17 	ldw	r2,-4(fp)
 8217900:	00c01b84 	movi	r3,110
 8217904:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217908:	0005883a 	mov	r2,zero
 821790c:	0000ca06 	br	8217c38 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 8217910:	e0bffc17 	ldw	r2,-16(fp)
 8217914:	10800003 	ldbu	r2,0(r2)
 8217918:	10803fcc 	andi	r2,r2,255
 821791c:	10800160 	cmpeqi	r2,r2,5
 8217920:	1000051e 	bne	r2,zero,8217938 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 8217924:	e0bfff17 	ldw	r2,-4(fp)
 8217928:	00c00044 	movi	r3,1
 821792c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217930:	0005883a 	mov	r2,zero
 8217934:	0000c006 	br	8217c38 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217938:	0005303a 	rdctl	r2,status
 821793c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217940:	e0fffb17 	ldw	r3,-20(fp)
 8217944:	00bfff84 	movi	r2,-2
 8217948:	1884703a 	and	r2,r3,r2
 821794c:	1001703a 	wrctl	status,r2
  
  return context;
 8217950:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 8217954:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 8217958:	e0bffe03 	ldbu	r2,-8(fp)
 821795c:	10000326 	beq	r2,zero,821796c <OSFlagPost+0xb4>
 8217960:	10800060 	cmpeqi	r2,r2,1
 8217964:	10000b1e 	bne	r2,zero,8217994 <OSFlagPost+0xdc>
 8217968:	00001206 	br	82179b4 <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 821796c:	e0bffc17 	ldw	r2,-16(fp)
 8217970:	1080020b 	ldhu	r2,8(r2)
 8217974:	1007883a 	mov	r3,r2
 8217978:	e0bffd0b 	ldhu	r2,-12(fp)
 821797c:	0084303a 	nor	r2,zero,r2
 8217980:	1884703a 	and	r2,r3,r2
 8217984:	1007883a 	mov	r3,r2
 8217988:	e0bffc17 	ldw	r2,-16(fp)
 821798c:	10c0020d 	sth	r3,8(r2)
             break;
 8217990:	00001106 	br	82179d8 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 8217994:	e0bffc17 	ldw	r2,-16(fp)
 8217998:	10c0020b 	ldhu	r3,8(r2)
 821799c:	e0bffd0b 	ldhu	r2,-12(fp)
 82179a0:	1884b03a 	or	r2,r3,r2
 82179a4:	1007883a 	mov	r3,r2
 82179a8:	e0bffc17 	ldw	r2,-16(fp)
 82179ac:	10c0020d 	sth	r3,8(r2)
             break;
 82179b0:	00000906 	br	82179d8 <OSFlagPost+0x120>
 82179b4:	e0bff317 	ldw	r2,-52(fp)
 82179b8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82179bc:	e0bff417 	ldw	r2,-48(fp)
 82179c0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 82179c4:	e0bfff17 	ldw	r2,-4(fp)
 82179c8:	00c01c44 	movi	r3,113
 82179cc:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 82179d0:	0005883a 	mov	r2,zero
 82179d4:	00009806 	br	8217c38 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 82179d8:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 82179dc:	e0bffc17 	ldw	r2,-16(fp)
 82179e0:	10800117 	ldw	r2,4(r2)
 82179e4:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 82179e8:	00007706 	br	8217bc8 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 82179ec:	e0bff117 	ldw	r2,-60(fp)
 82179f0:	10800483 	ldbu	r2,18(r2)
 82179f4:	10803fcc 	andi	r2,r2,255
 82179f8:	10c00060 	cmpeqi	r3,r2,1
 82179fc:	18004a1e 	bne	r3,zero,8217b28 <OSFlagPost+0x270>
 8217a00:	10c00088 	cmpgei	r3,r2,2
 8217a04:	1800021e 	bne	r3,zero,8217a10 <OSFlagPost+0x158>
 8217a08:	10002f26 	beq	r2,zero,8217ac8 <OSFlagPost+0x210>
 8217a0c:	00005b06 	br	8217b7c <OSFlagPost+0x2c4>
 8217a10:	10c000a0 	cmpeqi	r3,r2,2
 8217a14:	1800031e 	bne	r3,zero,8217a24 <OSFlagPost+0x16c>
 8217a18:	108000e0 	cmpeqi	r2,r2,3
 8217a1c:	1000171e 	bne	r2,zero,8217a7c <OSFlagPost+0x1c4>
 8217a20:	00005606 	br	8217b7c <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217a24:	e0bffc17 	ldw	r2,-16(fp)
 8217a28:	10c0020b 	ldhu	r3,8(r2)
 8217a2c:	e0bff117 	ldw	r2,-60(fp)
 8217a30:	1080040b 	ldhu	r2,16(r2)
 8217a34:	1884703a 	and	r2,r3,r2
 8217a38:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217a3c:	e0bff117 	ldw	r2,-60(fp)
 8217a40:	1080040b 	ldhu	r2,16(r2)
 8217a44:	10ffffcc 	andi	r3,r2,65535
 8217a48:	e0bff60b 	ldhu	r2,-40(fp)
 8217a4c:	1880541e 	bne	r3,r2,8217ba0 <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217a50:	e0bff60b 	ldhu	r2,-40(fp)
 8217a54:	100b883a 	mov	r5,r2
 8217a58:	e13ff117 	ldw	r4,-60(fp)
 8217a5c:	8217f500 	call	8217f50 <OS_FlagTaskRdy>
 8217a60:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217a64:	e0bff683 	ldbu	r2,-38(fp)
 8217a68:	10800058 	cmpnei	r2,r2,1
 8217a6c:	10004c1e 	bne	r2,zero,8217ba0 <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217a70:	00800044 	movi	r2,1
 8217a74:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217a78:	00004906 	br	8217ba0 <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217a7c:	e0bffc17 	ldw	r2,-16(fp)
 8217a80:	10c0020b 	ldhu	r3,8(r2)
 8217a84:	e0bff117 	ldw	r2,-60(fp)
 8217a88:	1080040b 	ldhu	r2,16(r2)
 8217a8c:	1884703a 	and	r2,r3,r2
 8217a90:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217a94:	e0bff60b 	ldhu	r2,-40(fp)
 8217a98:	10004326 	beq	r2,zero,8217ba8 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217a9c:	e0bff60b 	ldhu	r2,-40(fp)
 8217aa0:	100b883a 	mov	r5,r2
 8217aa4:	e13ff117 	ldw	r4,-60(fp)
 8217aa8:	8217f500 	call	8217f50 <OS_FlagTaskRdy>
 8217aac:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217ab0:	e0bff683 	ldbu	r2,-38(fp)
 8217ab4:	10800058 	cmpnei	r2,r2,1
 8217ab8:	10003b1e 	bne	r2,zero,8217ba8 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217abc:	00800044 	movi	r2,1
 8217ac0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217ac4:	00003806 	br	8217ba8 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217ac8:	e0bffc17 	ldw	r2,-16(fp)
 8217acc:	1080020b 	ldhu	r2,8(r2)
 8217ad0:	0084303a 	nor	r2,zero,r2
 8217ad4:	1007883a 	mov	r3,r2
 8217ad8:	e0bff117 	ldw	r2,-60(fp)
 8217adc:	1080040b 	ldhu	r2,16(r2)
 8217ae0:	1884703a 	and	r2,r3,r2
 8217ae4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217ae8:	e0bff117 	ldw	r2,-60(fp)
 8217aec:	1080040b 	ldhu	r2,16(r2)
 8217af0:	10ffffcc 	andi	r3,r2,65535
 8217af4:	e0bff60b 	ldhu	r2,-40(fp)
 8217af8:	18802d1e 	bne	r3,r2,8217bb0 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217afc:	e0bff60b 	ldhu	r2,-40(fp)
 8217b00:	100b883a 	mov	r5,r2
 8217b04:	e13ff117 	ldw	r4,-60(fp)
 8217b08:	8217f500 	call	8217f50 <OS_FlagTaskRdy>
 8217b0c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217b10:	e0bff683 	ldbu	r2,-38(fp)
 8217b14:	10800058 	cmpnei	r2,r2,1
 8217b18:	1000251e 	bne	r2,zero,8217bb0 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217b1c:	00800044 	movi	r2,1
 8217b20:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217b24:	00002206 	br	8217bb0 <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217b28:	e0bffc17 	ldw	r2,-16(fp)
 8217b2c:	1080020b 	ldhu	r2,8(r2)
 8217b30:	0084303a 	nor	r2,zero,r2
 8217b34:	1007883a 	mov	r3,r2
 8217b38:	e0bff117 	ldw	r2,-60(fp)
 8217b3c:	1080040b 	ldhu	r2,16(r2)
 8217b40:	1884703a 	and	r2,r3,r2
 8217b44:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217b48:	e0bff60b 	ldhu	r2,-40(fp)
 8217b4c:	10001a26 	beq	r2,zero,8217bb8 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217b50:	e0bff60b 	ldhu	r2,-40(fp)
 8217b54:	100b883a 	mov	r5,r2
 8217b58:	e13ff117 	ldw	r4,-60(fp)
 8217b5c:	8217f500 	call	8217f50 <OS_FlagTaskRdy>
 8217b60:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217b64:	e0bff683 	ldbu	r2,-38(fp)
 8217b68:	10800058 	cmpnei	r2,r2,1
 8217b6c:	1000121e 	bne	r2,zero,8217bb8 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217b70:	00800044 	movi	r2,1
 8217b74:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217b78:	00000f06 	br	8217bb8 <OSFlagPost+0x300>
 8217b7c:	e0bff317 	ldw	r2,-52(fp)
 8217b80:	e0bff515 	stw	r2,-44(fp)
 8217b84:	e0bff517 	ldw	r2,-44(fp)
 8217b88:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217b8c:	e0bfff17 	ldw	r2,-4(fp)
 8217b90:	00c01bc4 	movi	r3,111
 8217b94:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217b98:	0005883a 	mov	r2,zero
 8217b9c:	00002606 	br	8217c38 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217ba0:	0001883a 	nop
 8217ba4:	00000506 	br	8217bbc <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217ba8:	0001883a 	nop
 8217bac:	00000306 	br	8217bbc <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217bb0:	0001883a 	nop
 8217bb4:	00000106 	br	8217bbc <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217bb8:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 8217bbc:	e0bff117 	ldw	r2,-60(fp)
 8217bc0:	10800017 	ldw	r2,0(r2)
 8217bc4:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217bc8:	e0bff117 	ldw	r2,-60(fp)
 8217bcc:	103f871e 	bne	r2,zero,82179ec <OSFlagPost+0x134>
 8217bd0:	e0bff317 	ldw	r2,-52(fp)
 8217bd4:	e0bff715 	stw	r2,-36(fp)
 8217bd8:	e0bff717 	ldw	r2,-36(fp)
 8217bdc:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 8217be0:	e0bff203 	ldbu	r2,-56(fp)
 8217be4:	10800058 	cmpnei	r2,r2,1
 8217be8:	1000011e 	bne	r2,zero,8217bf0 <OSFlagPost+0x338>
        OS_Sched();
 8217bec:	82161580 	call	8216158 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217bf0:	0005303a 	rdctl	r2,status
 8217bf4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217bf8:	e0fffa17 	ldw	r3,-24(fp)
 8217bfc:	00bfff84 	movi	r2,-2
 8217c00:	1884703a 	and	r2,r3,r2
 8217c04:	1001703a 	wrctl	status,r2
  
  return context;
 8217c08:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 8217c0c:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 8217c10:	e0bffc17 	ldw	r2,-16(fp)
 8217c14:	1080020b 	ldhu	r2,8(r2)
 8217c18:	e0bff90d 	sth	r2,-28(fp)
 8217c1c:	e0bff317 	ldw	r2,-52(fp)
 8217c20:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217c24:	e0bff817 	ldw	r2,-32(fp)
 8217c28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 8217c2c:	e0bfff17 	ldw	r2,-4(fp)
 8217c30:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 8217c34:	e0bff90b 	ldhu	r2,-28(fp)
}
 8217c38:	e037883a 	mov	sp,fp
 8217c3c:	dfc00117 	ldw	ra,4(sp)
 8217c40:	df000017 	ldw	fp,0(sp)
 8217c44:	dec00204 	addi	sp,sp,8
 8217c48:	f800283a 	ret

08217c4c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 8217c4c:	defff904 	addi	sp,sp,-28
 8217c50:	df000615 	stw	fp,24(sp)
 8217c54:	df000604 	addi	fp,sp,24
 8217c58:	e13ffe15 	stw	r4,-8(fp)
 8217c5c:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 8217c60:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 8217c64:	e0bfff17 	ldw	r2,-4(fp)
 8217c68:	1000021e 	bne	r2,zero,8217c74 <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 8217c6c:	0005883a 	mov	r2,zero
 8217c70:	00002306 	br	8217d00 <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 8217c74:	e0bffe17 	ldw	r2,-8(fp)
 8217c78:	1000051e 	bne	r2,zero,8217c90 <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217c7c:	e0bfff17 	ldw	r2,-4(fp)
 8217c80:	00c01b84 	movi	r3,110
 8217c84:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217c88:	0005883a 	mov	r2,zero
 8217c8c:	00001c06 	br	8217d00 <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 8217c90:	e0bffe17 	ldw	r2,-8(fp)
 8217c94:	10800003 	ldbu	r2,0(r2)
 8217c98:	10803fcc 	andi	r2,r2,255
 8217c9c:	10800160 	cmpeqi	r2,r2,5
 8217ca0:	1000051e 	bne	r2,zero,8217cb8 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8217ca4:	e0bfff17 	ldw	r2,-4(fp)
 8217ca8:	00c00044 	movi	r3,1
 8217cac:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217cb0:	0005883a 	mov	r2,zero
 8217cb4:	00001206 	br	8217d00 <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217cb8:	0005303a 	rdctl	r2,status
 8217cbc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217cc0:	e0fffc17 	ldw	r3,-16(fp)
 8217cc4:	00bfff84 	movi	r2,-2
 8217cc8:	1884703a 	and	r2,r3,r2
 8217ccc:	1001703a 	wrctl	status,r2
  
  return context;
 8217cd0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8217cd4:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 8217cd8:	e0bffe17 	ldw	r2,-8(fp)
 8217cdc:	1080020b 	ldhu	r2,8(r2)
 8217ce0:	e0bffb0d 	sth	r2,-20(fp)
 8217ce4:	e0bffa17 	ldw	r2,-24(fp)
 8217ce8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217cec:	e0bffd17 	ldw	r2,-12(fp)
 8217cf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217cf4:	e0bfff17 	ldw	r2,-4(fp)
 8217cf8:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 8217cfc:	e0bffb0b 	ldhu	r2,-20(fp)
}
 8217d00:	e037883a 	mov	sp,fp
 8217d04:	df000017 	ldw	fp,0(sp)
 8217d08:	dec00104 	addi	sp,sp,4
 8217d0c:	f800283a 	ret

08217d10 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 8217d10:	defff804 	addi	sp,sp,-32
 8217d14:	df000715 	stw	fp,28(sp)
 8217d18:	df000704 	addi	fp,sp,28
 8217d1c:	e13ffb15 	stw	r4,-20(fp)
 8217d20:	e17ffc15 	stw	r5,-16(fp)
 8217d24:	3009883a 	mov	r4,r6
 8217d28:	3807883a 	mov	r3,r7
 8217d2c:	e0800117 	ldw	r2,4(fp)
 8217d30:	e13ffd0d 	sth	r4,-12(fp)
 8217d34:	e0fffe05 	stb	r3,-8(fp)
 8217d38:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 8217d3c:	d0a07a17 	ldw	r2,-32280(gp)
 8217d40:	d0e07a17 	ldw	r3,-32280(gp)
 8217d44:	18c00c03 	ldbu	r3,48(r3)
 8217d48:	18c00814 	ori	r3,r3,32
 8217d4c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 8217d50:	d0a07a17 	ldw	r2,-32280(gp)
 8217d54:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 8217d58:	d0a07a17 	ldw	r2,-32280(gp)
 8217d5c:	e0ffff0b 	ldhu	r3,-4(fp)
 8217d60:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 8217d64:	d0a07a17 	ldw	r2,-32280(gp)
 8217d68:	e0fffc17 	ldw	r3,-16(fp)
 8217d6c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 8217d70:	e0bffc17 	ldw	r2,-16(fp)
 8217d74:	e0fffd0b 	ldhu	r3,-12(fp)
 8217d78:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 8217d7c:	e0bffc17 	ldw	r2,-16(fp)
 8217d80:	e0fffe03 	ldbu	r3,-8(fp)
 8217d84:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 8217d88:	d0e07a17 	ldw	r3,-32280(gp)
 8217d8c:	e0bffc17 	ldw	r2,-16(fp)
 8217d90:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 8217d94:	e0bffb17 	ldw	r2,-20(fp)
 8217d98:	10c00117 	ldw	r3,4(r2)
 8217d9c:	e0bffc17 	ldw	r2,-16(fp)
 8217da0:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 8217da4:	e0bffc17 	ldw	r2,-16(fp)
 8217da8:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 8217dac:	e0bffc17 	ldw	r2,-16(fp)
 8217db0:	e0fffb17 	ldw	r3,-20(fp)
 8217db4:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217db8:	e0bffb17 	ldw	r2,-20(fp)
 8217dbc:	10800117 	ldw	r2,4(r2)
 8217dc0:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 8217dc4:	e0bff917 	ldw	r2,-28(fp)
 8217dc8:	10000326 	beq	r2,zero,8217dd8 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 8217dcc:	e0bff917 	ldw	r2,-28(fp)
 8217dd0:	e0fffc17 	ldw	r3,-16(fp)
 8217dd4:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 8217dd8:	e0bffb17 	ldw	r2,-20(fp)
 8217ddc:	e0fffc17 	ldw	r3,-16(fp)
 8217de0:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 8217de4:	d0a07a17 	ldw	r2,-32280(gp)
 8217de8:	10800d03 	ldbu	r2,52(r2)
 8217dec:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 8217df0:	e0fffa03 	ldbu	r3,-24(fp)
 8217df4:	e13ffa03 	ldbu	r4,-24(fp)
 8217df8:	d0a07744 	addi	r2,gp,-32291
 8217dfc:	2085883a 	add	r2,r4,r2
 8217e00:	10800003 	ldbu	r2,0(r2)
 8217e04:	1009883a 	mov	r4,r2
 8217e08:	d0a07a17 	ldw	r2,-32280(gp)
 8217e0c:	10800d43 	ldbu	r2,53(r2)
 8217e10:	0084303a 	nor	r2,zero,r2
 8217e14:	2084703a 	and	r2,r4,r2
 8217e18:	1009883a 	mov	r4,r2
 8217e1c:	d0a07744 	addi	r2,gp,-32291
 8217e20:	1885883a 	add	r2,r3,r2
 8217e24:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 8217e28:	e0fffa03 	ldbu	r3,-24(fp)
 8217e2c:	d0a07744 	addi	r2,gp,-32291
 8217e30:	1885883a 	add	r2,r3,r2
 8217e34:	10800003 	ldbu	r2,0(r2)
 8217e38:	10803fcc 	andi	r2,r2,255
 8217e3c:	1000071e 	bne	r2,zero,8217e5c <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 8217e40:	d0a07a17 	ldw	r2,-32280(gp)
 8217e44:	10800d83 	ldbu	r2,54(r2)
 8217e48:	0084303a 	nor	r2,zero,r2
 8217e4c:	1007883a 	mov	r3,r2
 8217e50:	d0a07703 	ldbu	r2,-32292(gp)
 8217e54:	1884703a 	and	r2,r3,r2
 8217e58:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8217e5c:	0001883a 	nop
 8217e60:	e037883a 	mov	sp,fp
 8217e64:	df000017 	ldw	fp,0(sp)
 8217e68:	dec00104 	addi	sp,sp,4
 8217e6c:	f800283a 	ret

08217e70 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 8217e70:	defffb04 	addi	sp,sp,-20
 8217e74:	dfc00415 	stw	ra,16(sp)
 8217e78:	df000315 	stw	fp,12(sp)
 8217e7c:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 8217e80:	0140dc04 	movi	r5,880
 8217e84:	010209b4 	movhi	r4,2086
 8217e88:	2128cc04 	addi	r4,r4,-23760
 8217e8c:	821609c0 	call	821609c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 8217e90:	008209b4 	movhi	r2,2086
 8217e94:	10a8cc04 	addi	r2,r2,-23760
 8217e98:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 8217e9c:	008209b4 	movhi	r2,2086
 8217ea0:	10a8d704 	addi	r2,r2,-23716
 8217ea4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8217ea8:	e03ffd0d 	sth	zero,-12(fp)
 8217eac:	00001306 	br	8217efc <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217eb0:	e0bffe17 	ldw	r2,-8(fp)
 8217eb4:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 8217eb8:	e0bffe17 	ldw	r2,-8(fp)
 8217ebc:	e0ffff17 	ldw	r3,-4(fp)
 8217ec0:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 8217ec4:	e0bffe17 	ldw	r2,-8(fp)
 8217ec8:	00c00fc4 	movi	r3,63
 8217ecc:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 8217ed0:	e0bffe17 	ldw	r2,-8(fp)
 8217ed4:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 8217ed8:	e0bffe17 	ldw	r2,-8(fp)
 8217edc:	10800b04 	addi	r2,r2,44
 8217ee0:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 8217ee4:	e0bfff17 	ldw	r2,-4(fp)
 8217ee8:	10800b04 	addi	r2,r2,44
 8217eec:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8217ef0:	e0bffd0b 	ldhu	r2,-12(fp)
 8217ef4:	10800044 	addi	r2,r2,1
 8217ef8:	e0bffd0d 	sth	r2,-12(fp)
 8217efc:	e0bffd0b 	ldhu	r2,-12(fp)
 8217f00:	108004f0 	cmpltui	r2,r2,19
 8217f04:	103fea1e 	bne	r2,zero,8217eb0 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217f08:	e0bffe17 	ldw	r2,-8(fp)
 8217f0c:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 8217f10:	e0bffe17 	ldw	r2,-8(fp)
 8217f14:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 8217f18:	e0bffe17 	ldw	r2,-8(fp)
 8217f1c:	00c00fc4 	movi	r3,63
 8217f20:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 8217f24:	e0bffe17 	ldw	r2,-8(fp)
 8217f28:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 8217f2c:	008209b4 	movhi	r2,2086
 8217f30:	10a8cc04 	addi	r2,r2,-23760
 8217f34:	d0a07c15 	stw	r2,-32272(gp)
#endif
}
 8217f38:	0001883a 	nop
 8217f3c:	e037883a 	mov	sp,fp
 8217f40:	dfc00117 	ldw	ra,4(sp)
 8217f44:	df000017 	ldw	fp,0(sp)
 8217f48:	dec00204 	addi	sp,sp,8
 8217f4c:	f800283a 	ret

08217f50 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 8217f50:	defffa04 	addi	sp,sp,-24
 8217f54:	dfc00515 	stw	ra,20(sp)
 8217f58:	df000415 	stw	fp,16(sp)
 8217f5c:	df000404 	addi	fp,sp,16
 8217f60:	e13ffe15 	stw	r4,-8(fp)
 8217f64:	2805883a 	mov	r2,r5
 8217f68:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 8217f6c:	e0bffe17 	ldw	r2,-8(fp)
 8217f70:	10800217 	ldw	r2,8(r2)
 8217f74:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 8217f78:	e0bffd17 	ldw	r2,-12(fp)
 8217f7c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 8217f80:	e0bffd17 	ldw	r2,-12(fp)
 8217f84:	e0ffff0b 	ldhu	r3,-4(fp)
 8217f88:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 8217f8c:	e0bffd17 	ldw	r2,-12(fp)
 8217f90:	10c00c03 	ldbu	r3,48(r2)
 8217f94:	00bff7c4 	movi	r2,-33
 8217f98:	1884703a 	and	r2,r3,r2
 8217f9c:	1007883a 	mov	r3,r2
 8217fa0:	e0bffd17 	ldw	r2,-12(fp)
 8217fa4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 8217fa8:	e0bffd17 	ldw	r2,-12(fp)
 8217fac:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 8217fb0:	e0bffd17 	ldw	r2,-12(fp)
 8217fb4:	10800c03 	ldbu	r2,48(r2)
 8217fb8:	10803fcc 	andi	r2,r2,255
 8217fbc:	1000181e 	bne	r2,zero,8218020 <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 8217fc0:	e0bffd17 	ldw	r2,-12(fp)
 8217fc4:	10c00d83 	ldbu	r3,54(r2)
 8217fc8:	d0a07703 	ldbu	r2,-32292(gp)
 8217fcc:	1884b03a 	or	r2,r3,r2
 8217fd0:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8217fd4:	e0bffd17 	ldw	r2,-12(fp)
 8217fd8:	10800d03 	ldbu	r2,52(r2)
 8217fdc:	10c03fcc 	andi	r3,r2,255
 8217fe0:	e0bffd17 	ldw	r2,-12(fp)
 8217fe4:	10800d03 	ldbu	r2,52(r2)
 8217fe8:	11003fcc 	andi	r4,r2,255
 8217fec:	d0a07744 	addi	r2,gp,-32291
 8217ff0:	2085883a 	add	r2,r4,r2
 8217ff4:	11000003 	ldbu	r4,0(r2)
 8217ff8:	e0bffd17 	ldw	r2,-12(fp)
 8217ffc:	10800d43 	ldbu	r2,53(r2)
 8218000:	2084b03a 	or	r2,r4,r2
 8218004:	1009883a 	mov	r4,r2
 8218008:	d0a07744 	addi	r2,gp,-32291
 821800c:	1885883a 	add	r2,r3,r2
 8218010:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
 8218014:	00800044 	movi	r2,1
 8218018:	e0bffc05 	stb	r2,-16(fp)
 821801c:	00000106 	br	8218024 <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
 8218020:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 8218024:	e13ffe17 	ldw	r4,-8(fp)
 8218028:	82180440 	call	8218044 <OS_FlagUnlink>
    return (sched);
 821802c:	e0bffc03 	ldbu	r2,-16(fp)
}
 8218030:	e037883a 	mov	sp,fp
 8218034:	dfc00117 	ldw	ra,4(sp)
 8218038:	df000017 	ldw	fp,0(sp)
 821803c:	dec00204 	addi	sp,sp,8
 8218040:	f800283a 	ret

08218044 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 8218044:	defffa04 	addi	sp,sp,-24
 8218048:	df000515 	stw	fp,20(sp)
 821804c:	df000504 	addi	fp,sp,20
 8218050:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 8218054:	e0bfff17 	ldw	r2,-4(fp)
 8218058:	10800117 	ldw	r2,4(r2)
 821805c:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8218060:	e0bfff17 	ldw	r2,-4(fp)
 8218064:	10800017 	ldw	r2,0(r2)
 8218068:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 821806c:	e0bffb17 	ldw	r2,-20(fp)
 8218070:	10000b1e 	bne	r2,zero,82180a0 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 8218074:	e0bfff17 	ldw	r2,-4(fp)
 8218078:	10800317 	ldw	r2,12(r2)
 821807c:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 8218080:	e0bffd17 	ldw	r2,-12(fp)
 8218084:	e0fffc17 	ldw	r3,-16(fp)
 8218088:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 821808c:	e0bffc17 	ldw	r2,-16(fp)
 8218090:	10000b26 	beq	r2,zero,82180c0 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 8218094:	e0bffc17 	ldw	r2,-16(fp)
 8218098:	10000115 	stw	zero,4(r2)
 821809c:	00000806 	br	82180c0 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 82180a0:	e0bffb17 	ldw	r2,-20(fp)
 82180a4:	e0fffc17 	ldw	r3,-16(fp)
 82180a8:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 82180ac:	e0bffc17 	ldw	r2,-16(fp)
 82180b0:	10000326 	beq	r2,zero,82180c0 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 82180b4:	e0bffc17 	ldw	r2,-16(fp)
 82180b8:	e0fffb17 	ldw	r3,-20(fp)
 82180bc:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 82180c0:	e0bfff17 	ldw	r2,-4(fp)
 82180c4:	10800217 	ldw	r2,8(r2)
 82180c8:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 82180cc:	e0bffe17 	ldw	r2,-8(fp)
 82180d0:	10000a15 	stw	zero,40(r2)
#endif
}
 82180d4:	0001883a 	nop
 82180d8:	e037883a 	mov	sp,fp
 82180dc:	df000017 	ldw	fp,0(sp)
 82180e0:	dec00104 	addi	sp,sp,4
 82180e4:	f800283a 	ret

082180e8 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 82180e8:	defff404 	addi	sp,sp,-48
 82180ec:	df000b15 	stw	fp,44(sp)
 82180f0:	df000b04 	addi	fp,sp,44
 82180f4:	e13ffc15 	stw	r4,-16(fp)
 82180f8:	e17ffd15 	stw	r5,-12(fp)
 82180fc:	e1bffe15 	stw	r6,-8(fp)
 8218100:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8218104:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8218108:	e0bfff17 	ldw	r2,-4(fp)
 821810c:	1000021e 	bne	r2,zero,8218118 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 8218110:	0005883a 	mov	r2,zero
 8218114:	00006506 	br	82182ac <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 8218118:	e0bffc17 	ldw	r2,-16(fp)
 821811c:	1000051e 	bne	r2,zero,8218134 <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218120:	e0bfff17 	ldw	r2,-4(fp)
 8218124:	00c01884 	movi	r3,98
 8218128:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821812c:	0005883a 	mov	r2,zero
 8218130:	00005e06 	br	82182ac <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 8218134:	e0bffc17 	ldw	r2,-16(fp)
 8218138:	108000cc 	andi	r2,r2,3
 821813c:	10000526 	beq	r2,zero,8218154 <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218140:	e0bfff17 	ldw	r2,-4(fp)
 8218144:	00c01884 	movi	r3,98
 8218148:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821814c:	0005883a 	mov	r2,zero
 8218150:	00005606 	br	82182ac <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 8218154:	e0bffd17 	ldw	r2,-12(fp)
 8218158:	108000a8 	cmpgeui	r2,r2,2
 821815c:	1000051e 	bne	r2,zero,8218174 <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 8218160:	e0bfff17 	ldw	r2,-4(fp)
 8218164:	00c016c4 	movi	r3,91
 8218168:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821816c:	0005883a 	mov	r2,zero
 8218170:	00004e06 	br	82182ac <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 8218174:	e0bffe17 	ldw	r2,-8(fp)
 8218178:	10800128 	cmpgeui	r2,r2,4
 821817c:	1000051e 	bne	r2,zero,8218194 <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 8218180:	e0bfff17 	ldw	r2,-4(fp)
 8218184:	00c01704 	movi	r3,92
 8218188:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821818c:	0005883a 	mov	r2,zero
 8218190:	00004606 	br	82182ac <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218194:	0005303a 	rdctl	r2,status
 8218198:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821819c:	e0fffb17 	ldw	r3,-20(fp)
 82181a0:	00bfff84 	movi	r2,-2
 82181a4:	1884703a 	and	r2,r3,r2
 82181a8:	1001703a 	wrctl	status,r2
  
  return context;
 82181ac:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82181b0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 82181b4:	d0a07417 	ldw	r2,-32304(gp)
 82181b8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 82181bc:	d0a07417 	ldw	r2,-32304(gp)
 82181c0:	10000326 	beq	r2,zero,82181d0 <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 82181c4:	d0a07417 	ldw	r2,-32304(gp)
 82181c8:	10800117 	ldw	r2,4(r2)
 82181cc:	d0a07415 	stw	r2,-32304(gp)
 82181d0:	e0bff817 	ldw	r2,-32(fp)
 82181d4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82181d8:	e0bff917 	ldw	r2,-28(fp)
 82181dc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 82181e0:	e0bffa17 	ldw	r2,-24(fp)
 82181e4:	1000051e 	bne	r2,zero,82181fc <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
 82181e8:	e0bfff17 	ldw	r2,-4(fp)
 82181ec:	00c01684 	movi	r3,90
 82181f0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 82181f4:	0005883a 	mov	r2,zero
 82181f8:	00002c06 	br	82182ac <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 82181fc:	e0bffc17 	ldw	r2,-16(fp)
 8218200:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 8218204:	e0fffc17 	ldw	r3,-16(fp)
 8218208:	e0bffe17 	ldw	r2,-8(fp)
 821820c:	1885883a 	add	r2,r3,r2
 8218210:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 8218214:	e03ff715 	stw	zero,-36(fp)
 8218218:	00000c06 	br	821824c <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 821821c:	e0bff617 	ldw	r2,-40(fp)
 8218220:	e0fff517 	ldw	r3,-44(fp)
 8218224:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 8218228:	e0bff517 	ldw	r2,-44(fp)
 821822c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 8218230:	e0fff517 	ldw	r3,-44(fp)
 8218234:	e0bffe17 	ldw	r2,-8(fp)
 8218238:	1885883a 	add	r2,r3,r2
 821823c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 8218240:	e0bff717 	ldw	r2,-36(fp)
 8218244:	10800044 	addi	r2,r2,1
 8218248:	e0bff715 	stw	r2,-36(fp)
 821824c:	e0bffd17 	ldw	r2,-12(fp)
 8218250:	10bfffc4 	addi	r2,r2,-1
 8218254:	e0fff717 	ldw	r3,-36(fp)
 8218258:	18bff036 	bltu	r3,r2,821821c <OSMemCreate+0x134>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 821825c:	e0bff617 	ldw	r2,-40(fp)
 8218260:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 8218264:	e0bffa17 	ldw	r2,-24(fp)
 8218268:	e0fffc17 	ldw	r3,-16(fp)
 821826c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 8218270:	e0bffa17 	ldw	r2,-24(fp)
 8218274:	e0fffc17 	ldw	r3,-16(fp)
 8218278:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 821827c:	e0bffa17 	ldw	r2,-24(fp)
 8218280:	e0fffd17 	ldw	r3,-12(fp)
 8218284:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 8218288:	e0bffa17 	ldw	r2,-24(fp)
 821828c:	e0fffd17 	ldw	r3,-12(fp)
 8218290:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 8218294:	e0bffa17 	ldw	r2,-24(fp)
 8218298:	e0fffe17 	ldw	r3,-8(fp)
 821829c:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 82182a0:	e0bfff17 	ldw	r2,-4(fp)
 82182a4:	10000005 	stb	zero,0(r2)
    return (pmem);
 82182a8:	e0bffa17 	ldw	r2,-24(fp)
}
 82182ac:	e037883a 	mov	sp,fp
 82182b0:	df000017 	ldw	fp,0(sp)
 82182b4:	dec00104 	addi	sp,sp,4
 82182b8:	f800283a 	ret

082182bc <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 82182bc:	defff804 	addi	sp,sp,-32
 82182c0:	df000715 	stw	fp,28(sp)
 82182c4:	df000704 	addi	fp,sp,28
 82182c8:	e13ffe15 	stw	r4,-8(fp)
 82182cc:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82182d0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 82182d4:	e0bfff17 	ldw	r2,-4(fp)
 82182d8:	1000021e 	bne	r2,zero,82182e4 <OSMemGet+0x28>
        return ((void *)0);
 82182dc:	0005883a 	mov	r2,zero
 82182e0:	00002e06 	br	821839c <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 82182e4:	e0bffe17 	ldw	r2,-8(fp)
 82182e8:	1000051e 	bne	r2,zero,8218300 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82182ec:	e0bfff17 	ldw	r2,-4(fp)
 82182f0:	00c01804 	movi	r3,96
 82182f4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82182f8:	0005883a 	mov	r2,zero
 82182fc:	00002706 	br	821839c <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218300:	0005303a 	rdctl	r2,status
 8218304:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218308:	e0fffd17 	ldw	r3,-12(fp)
 821830c:	00bfff84 	movi	r2,-2
 8218310:	1884703a 	and	r2,r3,r2
 8218314:	1001703a 	wrctl	status,r2
  
  return context;
 8218318:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821831c:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 8218320:	e0bffe17 	ldw	r2,-8(fp)
 8218324:	10800417 	ldw	r2,16(r2)
 8218328:	10001426 	beq	r2,zero,821837c <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 821832c:	e0bffe17 	ldw	r2,-8(fp)
 8218330:	10800117 	ldw	r2,4(r2)
 8218334:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 8218338:	e0bffb17 	ldw	r2,-20(fp)
 821833c:	10c00017 	ldw	r3,0(r2)
 8218340:	e0bffe17 	ldw	r2,-8(fp)
 8218344:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 8218348:	e0bffe17 	ldw	r2,-8(fp)
 821834c:	10800417 	ldw	r2,16(r2)
 8218350:	10ffffc4 	addi	r3,r2,-1
 8218354:	e0bffe17 	ldw	r2,-8(fp)
 8218358:	10c00415 	stw	r3,16(r2)
 821835c:	e0bff917 	ldw	r2,-28(fp)
 8218360:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218364:	e0bffa17 	ldw	r2,-24(fp)
 8218368:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 821836c:	e0bfff17 	ldw	r2,-4(fp)
 8218370:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 8218374:	e0bffb17 	ldw	r2,-20(fp)
 8218378:	00000806 	br	821839c <OSMemGet+0xe0>
 821837c:	e0bff917 	ldw	r2,-28(fp)
 8218380:	e0bffc15 	stw	r2,-16(fp)
 8218384:	e0bffc17 	ldw	r2,-16(fp)
 8218388:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 821838c:	e0bfff17 	ldw	r2,-4(fp)
 8218390:	00c01744 	movi	r3,93
 8218394:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 8218398:	0005883a 	mov	r2,zero
}
 821839c:	e037883a 	mov	sp,fp
 82183a0:	df000017 	ldw	fp,0(sp)
 82183a4:	dec00104 	addi	sp,sp,4
 82183a8:	f800283a 	ret

082183ac <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82183ac:	defff704 	addi	sp,sp,-36
 82183b0:	dfc00815 	stw	ra,32(sp)
 82183b4:	df000715 	stw	fp,28(sp)
 82183b8:	df000704 	addi	fp,sp,28
 82183bc:	e13ffd15 	stw	r4,-12(fp)
 82183c0:	e17ffe15 	stw	r5,-8(fp)
 82183c4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82183c8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82183cc:	e0bfff17 	ldw	r2,-4(fp)
 82183d0:	1000021e 	bne	r2,zero,82183dc <OSMemNameGet+0x30>
        return (0);
 82183d4:	0005883a 	mov	r2,zero
 82183d8:	00002b06 	br	8218488 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82183dc:	e0bffd17 	ldw	r2,-12(fp)
 82183e0:	1000051e 	bne	r2,zero,82183f8 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82183e4:	e0bfff17 	ldw	r2,-4(fp)
 82183e8:	00c01804 	movi	r3,96
 82183ec:	10c00005 	stb	r3,0(r2)
        return (0);
 82183f0:	0005883a 	mov	r2,zero
 82183f4:	00002406 	br	8218488 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82183f8:	e0bffe17 	ldw	r2,-8(fp)
 82183fc:	1000051e 	bne	r2,zero,8218414 <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8218400:	e0bfff17 	ldw	r2,-4(fp)
 8218404:	00c00304 	movi	r3,12
 8218408:	10c00005 	stb	r3,0(r2)
        return (0);
 821840c:	0005883a 	mov	r2,zero
 8218410:	00001d06 	br	8218488 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8218414:	d0a07903 	ldbu	r2,-32284(gp)
 8218418:	10803fcc 	andi	r2,r2,255
 821841c:	10000526 	beq	r2,zero,8218434 <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 8218420:	e0bfff17 	ldw	r2,-4(fp)
 8218424:	00c00444 	movi	r3,17
 8218428:	10c00005 	stb	r3,0(r2)
        return (0);
 821842c:	0005883a 	mov	r2,zero
 8218430:	00001506 	br	8218488 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218434:	0005303a 	rdctl	r2,status
 8218438:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821843c:	e0fffb17 	ldw	r3,-20(fp)
 8218440:	00bfff84 	movi	r2,-2
 8218444:	1884703a 	and	r2,r3,r2
 8218448:	1001703a 	wrctl	status,r2
  
  return context;
 821844c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 8218450:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 8218454:	e0bffd17 	ldw	r2,-12(fp)
 8218458:	10800504 	addi	r2,r2,20
 821845c:	100b883a 	mov	r5,r2
 8218460:	e13ffe17 	ldw	r4,-8(fp)
 8218464:	821629c0 	call	821629c <OS_StrCopy>
 8218468:	e0bffa05 	stb	r2,-24(fp)
 821846c:	e0bff917 	ldw	r2,-28(fp)
 8218470:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218474:	e0bffc17 	ldw	r2,-16(fp)
 8218478:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821847c:	e0bfff17 	ldw	r2,-4(fp)
 8218480:	10000005 	stb	zero,0(r2)
    return (len);
 8218484:	e0bffa03 	ldbu	r2,-24(fp)
}
 8218488:	e037883a 	mov	sp,fp
 821848c:	dfc00117 	ldw	ra,4(sp)
 8218490:	df000017 	ldw	fp,0(sp)
 8218494:	dec00204 	addi	sp,sp,8
 8218498:	f800283a 	ret

0821849c <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 821849c:	defff604 	addi	sp,sp,-40
 82184a0:	dfc00915 	stw	ra,36(sp)
 82184a4:	df000815 	stw	fp,32(sp)
 82184a8:	df000804 	addi	fp,sp,32
 82184ac:	e13ffd15 	stw	r4,-12(fp)
 82184b0:	e17ffe15 	stw	r5,-8(fp)
 82184b4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82184b8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82184bc:	e0bfff17 	ldw	r2,-4(fp)
 82184c0:	10003526 	beq	r2,zero,8218598 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82184c4:	e0bffd17 	ldw	r2,-12(fp)
 82184c8:	1000041e 	bne	r2,zero,82184dc <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82184cc:	e0bfff17 	ldw	r2,-4(fp)
 82184d0:	00c01804 	movi	r3,96
 82184d4:	10c00005 	stb	r3,0(r2)
        return;
 82184d8:	00003006 	br	821859c <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82184dc:	e0bffe17 	ldw	r2,-8(fp)
 82184e0:	1000041e 	bne	r2,zero,82184f4 <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 82184e4:	e0bfff17 	ldw	r2,-4(fp)
 82184e8:	00c00304 	movi	r3,12
 82184ec:	10c00005 	stb	r3,0(r2)
        return;
 82184f0:	00002a06 	br	821859c <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82184f4:	d0a07903 	ldbu	r2,-32284(gp)
 82184f8:	10803fcc 	andi	r2,r2,255
 82184fc:	10000426 	beq	r2,zero,8218510 <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8218500:	e0bfff17 	ldw	r2,-4(fp)
 8218504:	00c00484 	movi	r3,18
 8218508:	10c00005 	stb	r3,0(r2)
        return;
 821850c:	00002306 	br	821859c <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218510:	0005303a 	rdctl	r2,status
 8218514:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218518:	e0fffc17 	ldw	r3,-16(fp)
 821851c:	00bfff84 	movi	r2,-2
 8218520:	1884703a 	and	r2,r3,r2
 8218524:	1001703a 	wrctl	status,r2
  
  return context;
 8218528:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821852c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 8218530:	e13ffe17 	ldw	r4,-8(fp)
 8218534:	82163100 	call	8216310 <OS_StrLen>
 8218538:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 821853c:	e0bffa03 	ldbu	r2,-24(fp)
 8218540:	10800830 	cmpltui	r2,r2,32
 8218544:	1000081e 	bne	r2,zero,8218568 <OSMemNameSet+0xcc>
 8218548:	e0bff817 	ldw	r2,-32(fp)
 821854c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218550:	e0bff917 	ldw	r2,-28(fp)
 8218554:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 8218558:	e0bfff17 	ldw	r2,-4(fp)
 821855c:	00c018c4 	movi	r3,99
 8218560:	10c00005 	stb	r3,0(r2)
        return;
 8218564:	00000d06 	br	821859c <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 8218568:	e0bffd17 	ldw	r2,-12(fp)
 821856c:	10800504 	addi	r2,r2,20
 8218570:	e17ffe17 	ldw	r5,-8(fp)
 8218574:	1009883a 	mov	r4,r2
 8218578:	821629c0 	call	821629c <OS_StrCopy>
 821857c:	e0bff817 	ldw	r2,-32(fp)
 8218580:	e0bffb15 	stw	r2,-20(fp)
 8218584:	e0bffb17 	ldw	r2,-20(fp)
 8218588:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821858c:	e0bfff17 	ldw	r2,-4(fp)
 8218590:	10000005 	stb	zero,0(r2)
 8218594:	00000106 	br	821859c <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8218598:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 821859c:	e037883a 	mov	sp,fp
 82185a0:	dfc00117 	ldw	ra,4(sp)
 82185a4:	df000017 	ldw	fp,0(sp)
 82185a8:	dec00204 	addi	sp,sp,8
 82185ac:	f800283a 	ret

082185b0 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 82185b0:	defff904 	addi	sp,sp,-28
 82185b4:	df000615 	stw	fp,24(sp)
 82185b8:	df000604 	addi	fp,sp,24
 82185bc:	e13ffe15 	stw	r4,-8(fp)
 82185c0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82185c4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82185c8:	e0bffe17 	ldw	r2,-8(fp)
 82185cc:	1000021e 	bne	r2,zero,82185d8 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 82185d0:	00801804 	movi	r2,96
 82185d4:	00002806 	br	8218678 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 82185d8:	e0bfff17 	ldw	r2,-4(fp)
 82185dc:	1000021e 	bne	r2,zero,82185e8 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 82185e0:	008017c4 	movi	r2,95
 82185e4:	00002406 	br	8218678 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82185e8:	0005303a 	rdctl	r2,status
 82185ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82185f0:	e0fffd17 	ldw	r3,-12(fp)
 82185f4:	00bfff84 	movi	r2,-2
 82185f8:	1884703a 	and	r2,r3,r2
 82185fc:	1001703a 	wrctl	status,r2
  
  return context;
 8218600:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218604:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 8218608:	e0bffe17 	ldw	r2,-8(fp)
 821860c:	10c00417 	ldw	r3,16(r2)
 8218610:	e0bffe17 	ldw	r2,-8(fp)
 8218614:	10800317 	ldw	r2,12(r2)
 8218618:	18800636 	bltu	r3,r2,8218634 <OSMemPut+0x84>
 821861c:	e0bffa17 	ldw	r2,-24(fp)
 8218620:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218624:	e0bffb17 	ldw	r2,-20(fp)
 8218628:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 821862c:	00801784 	movi	r2,94
 8218630:	00001106 	br	8218678 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 8218634:	e0bffe17 	ldw	r2,-8(fp)
 8218638:	10c00117 	ldw	r3,4(r2)
 821863c:	e0bfff17 	ldw	r2,-4(fp)
 8218640:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 8218644:	e0bffe17 	ldw	r2,-8(fp)
 8218648:	e0ffff17 	ldw	r3,-4(fp)
 821864c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 8218650:	e0bffe17 	ldw	r2,-8(fp)
 8218654:	10800417 	ldw	r2,16(r2)
 8218658:	10c00044 	addi	r3,r2,1
 821865c:	e0bffe17 	ldw	r2,-8(fp)
 8218660:	10c00415 	stw	r3,16(r2)
 8218664:	e0bffa17 	ldw	r2,-24(fp)
 8218668:	e0bffc15 	stw	r2,-16(fp)
 821866c:	e0bffc17 	ldw	r2,-16(fp)
 8218670:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 8218674:	0005883a 	mov	r2,zero
}
 8218678:	e037883a 	mov	sp,fp
 821867c:	df000017 	ldw	fp,0(sp)
 8218680:	dec00104 	addi	sp,sp,4
 8218684:	f800283a 	ret

08218688 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 8218688:	defffa04 	addi	sp,sp,-24
 821868c:	df000515 	stw	fp,20(sp)
 8218690:	df000504 	addi	fp,sp,20
 8218694:	e13ffe15 	stw	r4,-8(fp)
 8218698:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821869c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82186a0:	e0bffe17 	ldw	r2,-8(fp)
 82186a4:	1000021e 	bne	r2,zero,82186b0 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 82186a8:	00801804 	movi	r2,96
 82186ac:	00002c06 	br	8218760 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 82186b0:	e0bfff17 	ldw	r2,-4(fp)
 82186b4:	1000021e 	bne	r2,zero,82186c0 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 82186b8:	00801844 	movi	r2,97
 82186bc:	00002806 	br	8218760 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82186c0:	0005303a 	rdctl	r2,status
 82186c4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82186c8:	e0fffc17 	ldw	r3,-16(fp)
 82186cc:	00bfff84 	movi	r2,-2
 82186d0:	1884703a 	and	r2,r3,r2
 82186d4:	1001703a 	wrctl	status,r2
  
  return context;
 82186d8:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82186dc:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 82186e0:	e0bffe17 	ldw	r2,-8(fp)
 82186e4:	10c00017 	ldw	r3,0(r2)
 82186e8:	e0bfff17 	ldw	r2,-4(fp)
 82186ec:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 82186f0:	e0bffe17 	ldw	r2,-8(fp)
 82186f4:	10c00117 	ldw	r3,4(r2)
 82186f8:	e0bfff17 	ldw	r2,-4(fp)
 82186fc:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 8218700:	e0bffe17 	ldw	r2,-8(fp)
 8218704:	10c00217 	ldw	r3,8(r2)
 8218708:	e0bfff17 	ldw	r2,-4(fp)
 821870c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 8218710:	e0bffe17 	ldw	r2,-8(fp)
 8218714:	10c00317 	ldw	r3,12(r2)
 8218718:	e0bfff17 	ldw	r2,-4(fp)
 821871c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 8218720:	e0bffe17 	ldw	r2,-8(fp)
 8218724:	10c00417 	ldw	r3,16(r2)
 8218728:	e0bfff17 	ldw	r2,-4(fp)
 821872c:	10c00415 	stw	r3,16(r2)
 8218730:	e0bffb17 	ldw	r2,-20(fp)
 8218734:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218738:	e0bffd17 	ldw	r2,-12(fp)
 821873c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 8218740:	e0bfff17 	ldw	r2,-4(fp)
 8218744:	10c00317 	ldw	r3,12(r2)
 8218748:	e0bfff17 	ldw	r2,-4(fp)
 821874c:	10800417 	ldw	r2,16(r2)
 8218750:	1887c83a 	sub	r3,r3,r2
 8218754:	e0bfff17 	ldw	r2,-4(fp)
 8218758:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 821875c:	0005883a 	mov	r2,zero
}
 8218760:	e037883a 	mov	sp,fp
 8218764:	df000017 	ldw	fp,0(sp)
 8218768:	dec00104 	addi	sp,sp,4
 821876c:	f800283a 	ret

08218770 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 8218770:	defffc04 	addi	sp,sp,-16
 8218774:	dfc00315 	stw	ra,12(sp)
 8218778:	df000215 	stw	fp,8(sp)
 821877c:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 8218780:	01430c04 	movi	r5,3120
 8218784:	010209b4 	movhi	r4,2086
 8218788:	2129a804 	addi	r4,r4,-22880
 821878c:	821609c0 	call	821609c <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 8218790:	008209b4 	movhi	r2,2086
 8218794:	10a9a804 	addi	r2,r2,-22880
 8218798:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 821879c:	e03fff0d 	sth	zero,-4(fp)
 82187a0:	00001306 	br	82187f0 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 82187a4:	e0bfff0b 	ldhu	r2,-4(fp)
 82187a8:	10800044 	addi	r2,r2,1
 82187ac:	10c00d24 	muli	r3,r2,52
 82187b0:	008209b4 	movhi	r2,2086
 82187b4:	10a9a804 	addi	r2,r2,-22880
 82187b8:	1887883a 	add	r3,r3,r2
 82187bc:	e0bffe17 	ldw	r2,-8(fp)
 82187c0:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 82187c4:	e0bffe17 	ldw	r2,-8(fp)
 82187c8:	00c00fc4 	movi	r3,63
 82187cc:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 82187d0:	e0bffe17 	ldw	r2,-8(fp)
 82187d4:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 82187d8:	e0bffe17 	ldw	r2,-8(fp)
 82187dc:	10800d04 	addi	r2,r2,52
 82187e0:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 82187e4:	e0bfff0b 	ldhu	r2,-4(fp)
 82187e8:	10800044 	addi	r2,r2,1
 82187ec:	e0bfff0d 	sth	r2,-4(fp)
 82187f0:	e0bfff0b 	ldhu	r2,-4(fp)
 82187f4:	10800ef0 	cmpltui	r2,r2,59
 82187f8:	103fea1e 	bne	r2,zero,82187a4 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 82187fc:	e0bffe17 	ldw	r2,-8(fp)
 8218800:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 8218804:	e0bffe17 	ldw	r2,-8(fp)
 8218808:	00c00fc4 	movi	r3,63
 821880c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218810:	e0bffe17 	ldw	r2,-8(fp)
 8218814:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 8218818:	008209b4 	movhi	r2,2086
 821881c:	10a9a804 	addi	r2,r2,-22880
 8218820:	d0a07415 	stw	r2,-32304(gp)
#endif
}
 8218824:	0001883a 	nop
 8218828:	e037883a 	mov	sp,fp
 821882c:	dfc00117 	ldw	ra,4(sp)
 8218830:	df000017 	ldw	fp,0(sp)
 8218834:	dec00204 	addi	sp,sp,8
 8218838:	f800283a 	ret

0821883c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 821883c:	defff804 	addi	sp,sp,-32
 8218840:	df000715 	stw	fp,28(sp)
 8218844:	df000704 	addi	fp,sp,28
 8218848:	e13ffe15 	stw	r4,-8(fp)
 821884c:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218850:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218854:	e0bfff17 	ldw	r2,-4(fp)
 8218858:	1000021e 	bne	r2,zero,8218864 <OSQAccept+0x28>
        return ((void *)0);
 821885c:	0005883a 	mov	r2,zero
 8218860:	00004206 	br	821896c <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8218864:	e0bffe17 	ldw	r2,-8(fp)
 8218868:	1000051e 	bne	r2,zero,8218880 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 821886c:	e0bfff17 	ldw	r2,-4(fp)
 8218870:	00c00104 	movi	r3,4
 8218874:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218878:	0005883a 	mov	r2,zero
 821887c:	00003b06 	br	821896c <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218880:	e0bffe17 	ldw	r2,-8(fp)
 8218884:	10800003 	ldbu	r2,0(r2)
 8218888:	10803fcc 	andi	r2,r2,255
 821888c:	108000a0 	cmpeqi	r2,r2,2
 8218890:	1000051e 	bne	r2,zero,82188a8 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8218894:	e0bfff17 	ldw	r2,-4(fp)
 8218898:	00c00044 	movi	r3,1
 821889c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82188a0:	0005883a 	mov	r2,zero
 82188a4:	00003106 	br	821896c <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82188a8:	0005303a 	rdctl	r2,status
 82188ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82188b0:	e0fffd17 	ldw	r3,-12(fp)
 82188b4:	00bfff84 	movi	r2,-2
 82188b8:	1884703a 	and	r2,r3,r2
 82188bc:	1001703a 	wrctl	status,r2
  
  return context;
 82188c0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82188c4:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 82188c8:	e0bffe17 	ldw	r2,-8(fp)
 82188cc:	10800117 	ldw	r2,4(r2)
 82188d0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 82188d4:	e0bffc17 	ldw	r2,-16(fp)
 82188d8:	1080058b 	ldhu	r2,22(r2)
 82188dc:	10bfffcc 	andi	r2,r2,65535
 82188e0:	10001926 	beq	r2,zero,8218948 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 82188e4:	e0bffc17 	ldw	r2,-16(fp)
 82188e8:	10800417 	ldw	r2,16(r2)
 82188ec:	11000104 	addi	r4,r2,4
 82188f0:	e0fffc17 	ldw	r3,-16(fp)
 82188f4:	19000415 	stw	r4,16(r3)
 82188f8:	10800017 	ldw	r2,0(r2)
 82188fc:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8218900:	e0bffc17 	ldw	r2,-16(fp)
 8218904:	1080058b 	ldhu	r2,22(r2)
 8218908:	10bfffc4 	addi	r2,r2,-1
 821890c:	1007883a 	mov	r3,r2
 8218910:	e0bffc17 	ldw	r2,-16(fp)
 8218914:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8218918:	e0bffc17 	ldw	r2,-16(fp)
 821891c:	10c00417 	ldw	r3,16(r2)
 8218920:	e0bffc17 	ldw	r2,-16(fp)
 8218924:	10800217 	ldw	r2,8(r2)
 8218928:	1880041e 	bne	r3,r2,821893c <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 821892c:	e0bffc17 	ldw	r2,-16(fp)
 8218930:	10c00117 	ldw	r3,4(r2)
 8218934:	e0bffc17 	ldw	r2,-16(fp)
 8218938:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 821893c:	e0bfff17 	ldw	r2,-4(fp)
 8218940:	10000005 	stb	zero,0(r2)
 8218944:	00000406 	br	8218958 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 8218948:	e0bfff17 	ldw	r2,-4(fp)
 821894c:	00c007c4 	movi	r3,31
 8218950:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 8218954:	e03ff915 	stw	zero,-28(fp)
 8218958:	e0bffa17 	ldw	r2,-24(fp)
 821895c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218960:	e0bffb17 	ldw	r2,-20(fp)
 8218964:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 8218968:	e0bff917 	ldw	r2,-28(fp)
}
 821896c:	e037883a 	mov	sp,fp
 8218970:	df000017 	ldw	fp,0(sp)
 8218974:	dec00104 	addi	sp,sp,4
 8218978:	f800283a 	ret

0821897c <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 821897c:	defff404 	addi	sp,sp,-48
 8218980:	dfc00b15 	stw	ra,44(sp)
 8218984:	df000a15 	stw	fp,40(sp)
 8218988:	df000a04 	addi	fp,sp,40
 821898c:	e13ffe15 	stw	r4,-8(fp)
 8218990:	2805883a 	mov	r2,r5
 8218994:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218998:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 821899c:	d0a07903 	ldbu	r2,-32284(gp)
 82189a0:	10803fcc 	andi	r2,r2,255
 82189a4:	10000226 	beq	r2,zero,82189b0 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 82189a8:	0005883a 	mov	r2,zero
 82189ac:	00005906 	br	8218b14 <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82189b0:	0005303a 	rdctl	r2,status
 82189b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82189b8:	e0fffd17 	ldw	r3,-12(fp)
 82189bc:	00bfff84 	movi	r2,-2
 82189c0:	1884703a 	and	r2,r3,r2
 82189c4:	1001703a 	wrctl	status,r2
  
  return context;
 82189c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82189cc:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 82189d0:	d0a07817 	ldw	r2,-32288(gp)
 82189d4:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 82189d8:	d0a07817 	ldw	r2,-32288(gp)
 82189dc:	10000326 	beq	r2,zero,82189ec <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 82189e0:	d0a07817 	ldw	r2,-32288(gp)
 82189e4:	10800117 	ldw	r2,4(r2)
 82189e8:	d0a07815 	stw	r2,-32288(gp)
 82189ec:	e0bff717 	ldw	r2,-36(fp)
 82189f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82189f4:	e0bff817 	ldw	r2,-32(fp)
 82189f8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 82189fc:	e0bff617 	ldw	r2,-40(fp)
 8218a00:	10004326 	beq	r2,zero,8218b10 <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218a04:	0005303a 	rdctl	r2,status
 8218a08:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218a0c:	e0fff917 	ldw	r3,-28(fp)
 8218a10:	00bfff84 	movi	r2,-2
 8218a14:	1884703a 	and	r2,r3,r2
 8218a18:	1001703a 	wrctl	status,r2
  
  return context;
 8218a1c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
 8218a20:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 8218a24:	d0a07617 	ldw	r2,-32296(gp)
 8218a28:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 8218a2c:	e0bffb17 	ldw	r2,-20(fp)
 8218a30:	10002d26 	beq	r2,zero,8218ae8 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 8218a34:	d0a07617 	ldw	r2,-32296(gp)
 8218a38:	10800017 	ldw	r2,0(r2)
 8218a3c:	d0a07615 	stw	r2,-32296(gp)
 8218a40:	e0bff717 	ldw	r2,-36(fp)
 8218a44:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218a48:	e0bffa17 	ldw	r2,-24(fp)
 8218a4c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 8218a50:	e0bffb17 	ldw	r2,-20(fp)
 8218a54:	e0fffe17 	ldw	r3,-8(fp)
 8218a58:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 8218a5c:	e0bfff0b 	ldhu	r2,-4(fp)
 8218a60:	1085883a 	add	r2,r2,r2
 8218a64:	1085883a 	add	r2,r2,r2
 8218a68:	1007883a 	mov	r3,r2
 8218a6c:	e0bffe17 	ldw	r2,-8(fp)
 8218a70:	10c7883a 	add	r3,r2,r3
 8218a74:	e0bffb17 	ldw	r2,-20(fp)
 8218a78:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 8218a7c:	e0bffb17 	ldw	r2,-20(fp)
 8218a80:	e0fffe17 	ldw	r3,-8(fp)
 8218a84:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 8218a88:	e0bffb17 	ldw	r2,-20(fp)
 8218a8c:	e0fffe17 	ldw	r3,-8(fp)
 8218a90:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 8218a94:	e0bffb17 	ldw	r2,-20(fp)
 8218a98:	e0ffff0b 	ldhu	r3,-4(fp)
 8218a9c:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 8218aa0:	e0bffb17 	ldw	r2,-20(fp)
 8218aa4:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 8218aa8:	e0bff617 	ldw	r2,-40(fp)
 8218aac:	00c00084 	movi	r3,2
 8218ab0:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 8218ab4:	e0bff617 	ldw	r2,-40(fp)
 8218ab8:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 8218abc:	e0bff617 	ldw	r2,-40(fp)
 8218ac0:	e0fffb17 	ldw	r3,-20(fp)
 8218ac4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 8218ac8:	e0bff617 	ldw	r2,-40(fp)
 8218acc:	00c00fc4 	movi	r3,63
 8218ad0:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 8218ad4:	e0bff617 	ldw	r2,-40(fp)
 8218ad8:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 8218adc:	e13ff617 	ldw	r4,-40(fp)
 8218ae0:	8215cbc0 	call	8215cbc <OS_EventWaitListInit>
 8218ae4:	00000a06 	br	8218b10 <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 8218ae8:	d0e07817 	ldw	r3,-32288(gp)
 8218aec:	e0bff617 	ldw	r2,-40(fp)
 8218af0:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 8218af4:	e0bff617 	ldw	r2,-40(fp)
 8218af8:	d0a07815 	stw	r2,-32288(gp)
 8218afc:	e0bff717 	ldw	r2,-36(fp)
 8218b00:	e0bffc15 	stw	r2,-16(fp)
 8218b04:	e0bffc17 	ldw	r2,-16(fp)
 8218b08:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 8218b0c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 8218b10:	e0bff617 	ldw	r2,-40(fp)
}
 8218b14:	e037883a 	mov	sp,fp
 8218b18:	dfc00117 	ldw	ra,4(sp)
 8218b1c:	df000017 	ldw	fp,0(sp)
 8218b20:	dec00204 	addi	sp,sp,8
 8218b24:	f800283a 	ret

08218b28 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8218b28:	defff204 	addi	sp,sp,-56
 8218b2c:	dfc00d15 	stw	ra,52(sp)
 8218b30:	df000c15 	stw	fp,48(sp)
 8218b34:	df000c04 	addi	fp,sp,48
 8218b38:	e13ffd15 	stw	r4,-12(fp)
 8218b3c:	2805883a 	mov	r2,r5
 8218b40:	e1bfff15 	stw	r6,-4(fp)
 8218b44:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8218b48:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8218b4c:	e0bfff17 	ldw	r2,-4(fp)
 8218b50:	1000021e 	bne	r2,zero,8218b5c <OSQDel+0x34>
        return (pevent);
 8218b54:	e0bffd17 	ldw	r2,-12(fp)
 8218b58:	00008e06 	br	8218d94 <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8218b5c:	e0bffd17 	ldw	r2,-12(fp)
 8218b60:	1000051e 	bne	r2,zero,8218b78 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218b64:	e0bfff17 	ldw	r2,-4(fp)
 8218b68:	00c00104 	movi	r3,4
 8218b6c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218b70:	e0bffd17 	ldw	r2,-12(fp)
 8218b74:	00008706 	br	8218d94 <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8218b78:	e0bffd17 	ldw	r2,-12(fp)
 8218b7c:	10800003 	ldbu	r2,0(r2)
 8218b80:	10803fcc 	andi	r2,r2,255
 8218b84:	108000a0 	cmpeqi	r2,r2,2
 8218b88:	1000051e 	bne	r2,zero,8218ba0 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218b8c:	e0bfff17 	ldw	r2,-4(fp)
 8218b90:	00c00044 	movi	r3,1
 8218b94:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218b98:	e0bffd17 	ldw	r2,-12(fp)
 8218b9c:	00007d06 	br	8218d94 <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8218ba0:	d0a07903 	ldbu	r2,-32284(gp)
 8218ba4:	10803fcc 	andi	r2,r2,255
 8218ba8:	10000526 	beq	r2,zero,8218bc0 <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8218bac:	e0bfff17 	ldw	r2,-4(fp)
 8218bb0:	00c003c4 	movi	r3,15
 8218bb4:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218bb8:	e0bffd17 	ldw	r2,-12(fp)
 8218bbc:	00007506 	br	8218d94 <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218bc0:	0005303a 	rdctl	r2,status
 8218bc4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218bc8:	e0fffc17 	ldw	r3,-16(fp)
 8218bcc:	00bfff84 	movi	r2,-2
 8218bd0:	1884703a 	and	r2,r3,r2
 8218bd4:	1001703a 	wrctl	status,r2
  
  return context;
 8218bd8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218bdc:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 8218be0:	e0bffd17 	ldw	r2,-12(fp)
 8218be4:	10800283 	ldbu	r2,10(r2)
 8218be8:	10803fcc 	andi	r2,r2,255
 8218bec:	10000326 	beq	r2,zero,8218bfc <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8218bf0:	00800044 	movi	r2,1
 8218bf4:	e0bff405 	stb	r2,-48(fp)
 8218bf8:	00000106 	br	8218c00 <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8218bfc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8218c00:	e0bffe03 	ldbu	r2,-8(fp)
 8218c04:	10000326 	beq	r2,zero,8218c14 <OSQDel+0xec>
 8218c08:	10800060 	cmpeqi	r2,r2,1
 8218c0c:	1000301e 	bne	r2,zero,8218cd0 <OSQDel+0x1a8>
 8218c10:	00005506 	br	8218d68 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 8218c14:	e0bff403 	ldbu	r2,-48(fp)
 8218c18:	10001e1e 	bne	r2,zero,8218c94 <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8218c1c:	e0bffd17 	ldw	r2,-12(fp)
 8218c20:	00c00fc4 	movi	r3,63
 8218c24:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8218c28:	e0bffd17 	ldw	r2,-12(fp)
 8218c2c:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 8218c30:	e0bffd17 	ldw	r2,-12(fp)
 8218c34:	10800117 	ldw	r2,4(r2)
 8218c38:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 8218c3c:	d0e07617 	ldw	r3,-32296(gp)
 8218c40:	e0bff817 	ldw	r2,-32(fp)
 8218c44:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 8218c48:	e0bff817 	ldw	r2,-32(fp)
 8218c4c:	d0a07615 	stw	r2,-32296(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8218c50:	e0bffd17 	ldw	r2,-12(fp)
 8218c54:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8218c58:	d0e07817 	ldw	r3,-32288(gp)
 8218c5c:	e0bffd17 	ldw	r2,-12(fp)
 8218c60:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8218c64:	e0bffd17 	ldw	r2,-12(fp)
 8218c68:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8218c6c:	e0bffd17 	ldw	r2,-12(fp)
 8218c70:	d0a07815 	stw	r2,-32288(gp)
 8218c74:	e0bff617 	ldw	r2,-40(fp)
 8218c78:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218c7c:	e0bff717 	ldw	r2,-36(fp)
 8218c80:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8218c84:	e0bfff17 	ldw	r2,-4(fp)
 8218c88:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 8218c8c:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8218c90:	00003f06 	br	8218d90 <OSQDel+0x268>
 8218c94:	e0bff617 	ldw	r2,-40(fp)
 8218c98:	e0bff915 	stw	r2,-28(fp)
 8218c9c:	e0bff917 	ldw	r2,-28(fp)
 8218ca0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8218ca4:	e0bfff17 	ldw	r2,-4(fp)
 8218ca8:	00c01244 	movi	r3,73
 8218cac:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8218cb0:	e0bffd17 	ldw	r2,-12(fp)
 8218cb4:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 8218cb8:	00003506 	br	8218d90 <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 8218cbc:	000f883a 	mov	r7,zero
 8218cc0:	01800104 	movi	r6,4
 8218cc4:	000b883a 	mov	r5,zero
 8218cc8:	e13ffd17 	ldw	r4,-12(fp)
 8218ccc:	821570c0 	call	821570c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 8218cd0:	e0bffd17 	ldw	r2,-12(fp)
 8218cd4:	10800283 	ldbu	r2,10(r2)
 8218cd8:	10803fcc 	andi	r2,r2,255
 8218cdc:	103ff71e 	bne	r2,zero,8218cbc <OSQDel+0x194>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8218ce0:	e0bffd17 	ldw	r2,-12(fp)
 8218ce4:	00c00fc4 	movi	r3,63
 8218ce8:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 8218cec:	e0bffd17 	ldw	r2,-12(fp)
 8218cf0:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 8218cf4:	e0bffd17 	ldw	r2,-12(fp)
 8218cf8:	10800117 	ldw	r2,4(r2)
 8218cfc:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 8218d00:	d0e07617 	ldw	r3,-32296(gp)
 8218d04:	e0bff817 	ldw	r2,-32(fp)
 8218d08:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 8218d0c:	e0bff817 	ldw	r2,-32(fp)
 8218d10:	d0a07615 	stw	r2,-32296(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8218d14:	e0bffd17 	ldw	r2,-12(fp)
 8218d18:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 8218d1c:	d0e07817 	ldw	r3,-32288(gp)
 8218d20:	e0bffd17 	ldw	r2,-12(fp)
 8218d24:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8218d28:	e0bffd17 	ldw	r2,-12(fp)
 8218d2c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8218d30:	e0bffd17 	ldw	r2,-12(fp)
 8218d34:	d0a07815 	stw	r2,-32288(gp)
 8218d38:	e0bff617 	ldw	r2,-40(fp)
 8218d3c:	e0bffa15 	stw	r2,-24(fp)
 8218d40:	e0bffa17 	ldw	r2,-24(fp)
 8218d44:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8218d48:	e0bff403 	ldbu	r2,-48(fp)
 8218d4c:	10800058 	cmpnei	r2,r2,1
 8218d50:	1000011e 	bne	r2,zero,8218d58 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8218d54:	82161580 	call	8216158 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8218d58:	e0bfff17 	ldw	r2,-4(fp)
 8218d5c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 8218d60:	e03ff515 	stw	zero,-44(fp)
             break;
 8218d64:	00000a06 	br	8218d90 <OSQDel+0x268>
 8218d68:	e0bff617 	ldw	r2,-40(fp)
 8218d6c:	e0bffb15 	stw	r2,-20(fp)
 8218d70:	e0bffb17 	ldw	r2,-20(fp)
 8218d74:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 8218d78:	e0bfff17 	ldw	r2,-4(fp)
 8218d7c:	00c001c4 	movi	r3,7
 8218d80:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 8218d84:	e0bffd17 	ldw	r2,-12(fp)
 8218d88:	e0bff515 	stw	r2,-44(fp)
             break;
 8218d8c:	0001883a 	nop
    }
    return (pevent_return);
 8218d90:	e0bff517 	ldw	r2,-44(fp)
}
 8218d94:	e037883a 	mov	sp,fp
 8218d98:	dfc00117 	ldw	ra,4(sp)
 8218d9c:	df000017 	ldw	fp,0(sp)
 8218da0:	dec00204 	addi	sp,sp,8
 8218da4:	f800283a 	ret

08218da8 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 8218da8:	defffa04 	addi	sp,sp,-24
 8218dac:	df000515 	stw	fp,20(sp)
 8218db0:	df000504 	addi	fp,sp,20
 8218db4:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8218db8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8218dbc:	e0bfff17 	ldw	r2,-4(fp)
 8218dc0:	1000021e 	bne	r2,zero,8218dcc <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 8218dc4:	00800104 	movi	r2,4
 8218dc8:	00002106 	br	8218e50 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8218dcc:	e0bfff17 	ldw	r2,-4(fp)
 8218dd0:	10800003 	ldbu	r2,0(r2)
 8218dd4:	10803fcc 	andi	r2,r2,255
 8218dd8:	108000a0 	cmpeqi	r2,r2,2
 8218ddc:	1000021e 	bne	r2,zero,8218de8 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 8218de0:	00800044 	movi	r2,1
 8218de4:	00001a06 	br	8218e50 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218de8:	0005303a 	rdctl	r2,status
 8218dec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218df0:	e0fffd17 	ldw	r3,-12(fp)
 8218df4:	00bfff84 	movi	r2,-2
 8218df8:	1884703a 	and	r2,r3,r2
 8218dfc:	1001703a 	wrctl	status,r2
  
  return context;
 8218e00:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218e04:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 8218e08:	e0bfff17 	ldw	r2,-4(fp)
 8218e0c:	10800117 	ldw	r2,4(r2)
 8218e10:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 8218e14:	e0bffc17 	ldw	r2,-16(fp)
 8218e18:	10c00117 	ldw	r3,4(r2)
 8218e1c:	e0bffc17 	ldw	r2,-16(fp)
 8218e20:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 8218e24:	e0bffc17 	ldw	r2,-16(fp)
 8218e28:	10c00117 	ldw	r3,4(r2)
 8218e2c:	e0bffc17 	ldw	r2,-16(fp)
 8218e30:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 8218e34:	e0bffc17 	ldw	r2,-16(fp)
 8218e38:	1000058d 	sth	zero,22(r2)
 8218e3c:	e0bffb17 	ldw	r2,-20(fp)
 8218e40:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218e44:	e0bffe17 	ldw	r2,-8(fp)
 8218e48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8218e4c:	0005883a 	mov	r2,zero
}
 8218e50:	e037883a 	mov	sp,fp
 8218e54:	df000017 	ldw	fp,0(sp)
 8218e58:	dec00104 	addi	sp,sp,4
 8218e5c:	f800283a 	ret

08218e60 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 8218e60:	defff304 	addi	sp,sp,-52
 8218e64:	dfc00c15 	stw	ra,48(sp)
 8218e68:	df000b15 	stw	fp,44(sp)
 8218e6c:	df000b04 	addi	fp,sp,44
 8218e70:	e13ffd15 	stw	r4,-12(fp)
 8218e74:	2805883a 	mov	r2,r5
 8218e78:	e1bfff15 	stw	r6,-4(fp)
 8218e7c:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218e80:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218e84:	e0bfff17 	ldw	r2,-4(fp)
 8218e88:	1000021e 	bne	r2,zero,8218e94 <OSQPend+0x34>
        return ((void *)0);
 8218e8c:	0005883a 	mov	r2,zero
 8218e90:	00009106 	br	82190d8 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8218e94:	e0bffd17 	ldw	r2,-12(fp)
 8218e98:	1000051e 	bne	r2,zero,8218eb0 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218e9c:	e0bfff17 	ldw	r2,-4(fp)
 8218ea0:	00c00104 	movi	r3,4
 8218ea4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218ea8:	0005883a 	mov	r2,zero
 8218eac:	00008a06 	br	82190d8 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218eb0:	e0bffd17 	ldw	r2,-12(fp)
 8218eb4:	10800003 	ldbu	r2,0(r2)
 8218eb8:	10803fcc 	andi	r2,r2,255
 8218ebc:	108000a0 	cmpeqi	r2,r2,2
 8218ec0:	1000051e 	bne	r2,zero,8218ed8 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218ec4:	e0bfff17 	ldw	r2,-4(fp)
 8218ec8:	00c00044 	movi	r3,1
 8218ecc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218ed0:	0005883a 	mov	r2,zero
 8218ed4:	00008006 	br	82190d8 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8218ed8:	d0a07903 	ldbu	r2,-32284(gp)
 8218edc:	10803fcc 	andi	r2,r2,255
 8218ee0:	10000526 	beq	r2,zero,8218ef8 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 8218ee4:	e0bfff17 	ldw	r2,-4(fp)
 8218ee8:	00c00084 	movi	r3,2
 8218eec:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218ef0:	0005883a 	mov	r2,zero
 8218ef4:	00007806 	br	82190d8 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 8218ef8:	d0a06b03 	ldbu	r2,-32340(gp)
 8218efc:	10803fcc 	andi	r2,r2,255
 8218f00:	10000526 	beq	r2,zero,8218f18 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 8218f04:	e0bfff17 	ldw	r2,-4(fp)
 8218f08:	00c00344 	movi	r3,13
 8218f0c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218f10:	0005883a 	mov	r2,zero
 8218f14:	00007006 	br	82190d8 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218f18:	0005303a 	rdctl	r2,status
 8218f1c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218f20:	e0fffc17 	ldw	r3,-16(fp)
 8218f24:	00bfff84 	movi	r2,-2
 8218f28:	1884703a 	and	r2,r3,r2
 8218f2c:	1001703a 	wrctl	status,r2
  
  return context;
 8218f30:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218f34:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8218f38:	e0bffd17 	ldw	r2,-12(fp)
 8218f3c:	10800117 	ldw	r2,4(r2)
 8218f40:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 8218f44:	e0bff817 	ldw	r2,-32(fp)
 8218f48:	1080058b 	ldhu	r2,22(r2)
 8218f4c:	10bfffcc 	andi	r2,r2,65535
 8218f50:	10001e26 	beq	r2,zero,8218fcc <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 8218f54:	e0bff817 	ldw	r2,-32(fp)
 8218f58:	10800417 	ldw	r2,16(r2)
 8218f5c:	11000104 	addi	r4,r2,4
 8218f60:	e0fff817 	ldw	r3,-32(fp)
 8218f64:	19000415 	stw	r4,16(r3)
 8218f68:	10800017 	ldw	r2,0(r2)
 8218f6c:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8218f70:	e0bff817 	ldw	r2,-32(fp)
 8218f74:	1080058b 	ldhu	r2,22(r2)
 8218f78:	10bfffc4 	addi	r2,r2,-1
 8218f7c:	1007883a 	mov	r3,r2
 8218f80:	e0bff817 	ldw	r2,-32(fp)
 8218f84:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8218f88:	e0bff817 	ldw	r2,-32(fp)
 8218f8c:	10c00417 	ldw	r3,16(r2)
 8218f90:	e0bff817 	ldw	r2,-32(fp)
 8218f94:	10800217 	ldw	r2,8(r2)
 8218f98:	1880041e 	bne	r3,r2,8218fac <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
 8218f9c:	e0bff817 	ldw	r2,-32(fp)
 8218fa0:	10c00117 	ldw	r3,4(r2)
 8218fa4:	e0bff817 	ldw	r2,-32(fp)
 8218fa8:	10c00415 	stw	r3,16(r2)
 8218fac:	e0bff617 	ldw	r2,-40(fp)
 8218fb0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218fb4:	e0bff717 	ldw	r2,-36(fp)
 8218fb8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 8218fbc:	e0bfff17 	ldw	r2,-4(fp)
 8218fc0:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 8218fc4:	e0bff517 	ldw	r2,-44(fp)
 8218fc8:	00004306 	br	82190d8 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 8218fcc:	d0a07a17 	ldw	r2,-32280(gp)
 8218fd0:	d0e07a17 	ldw	r3,-32280(gp)
 8218fd4:	18c00c03 	ldbu	r3,48(r3)
 8218fd8:	18c00114 	ori	r3,r3,4
 8218fdc:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8218fe0:	d0a07a17 	ldw	r2,-32280(gp)
 8218fe4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 8218fe8:	d0a07a17 	ldw	r2,-32280(gp)
 8218fec:	e0fffe0b 	ldhu	r3,-8(fp)
 8218ff0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 8218ff4:	e13ffd17 	ldw	r4,-12(fp)
 8218ff8:	82158a40 	call	82158a4 <OS_EventTaskWait>
 8218ffc:	e0bff617 	ldw	r2,-40(fp)
 8219000:	e0bffb15 	stw	r2,-20(fp)
 8219004:	e0bffb17 	ldw	r2,-20(fp)
 8219008:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 821900c:	82161580 	call	8216158 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219010:	0005303a 	rdctl	r2,status
 8219014:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219018:	e0fff917 	ldw	r3,-28(fp)
 821901c:	00bfff84 	movi	r2,-2
 8219020:	1884703a 	and	r2,r3,r2
 8219024:	1001703a 	wrctl	status,r2
  
  return context;
 8219028:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 821902c:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 8219030:	d0a07a17 	ldw	r2,-32280(gp)
 8219034:	10800c43 	ldbu	r2,49(r2)
 8219038:	10803fcc 	andi	r2,r2,255
 821903c:	10000326 	beq	r2,zero,821904c <OSQPend+0x1ec>
 8219040:	108000a0 	cmpeqi	r2,r2,2
 8219044:	1000071e 	bne	r2,zero,8219064 <OSQPend+0x204>
 8219048:	00000b06 	br	8219078 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 821904c:	d0a07a17 	ldw	r2,-32280(gp)
 8219050:	10800917 	ldw	r2,36(r2)
 8219054:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 8219058:	e0bfff17 	ldw	r2,-4(fp)
 821905c:	10000005 	stb	zero,0(r2)
             break;
 8219060:	00000e06 	br	821909c <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 8219064:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219068:	e0bfff17 	ldw	r2,-4(fp)
 821906c:	00c00384 	movi	r3,14
 8219070:	10c00005 	stb	r3,0(r2)
             break;
 8219074:	00000906 	br	821909c <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 8219078:	d0a07a17 	ldw	r2,-32280(gp)
 821907c:	e17ffd17 	ldw	r5,-12(fp)
 8219080:	1009883a 	mov	r4,r2
 8219084:	8215b040 	call	8215b04 <OS_EventTaskRemove>
             pmsg = (void *)0;
 8219088:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 821908c:	e0bfff17 	ldw	r2,-4(fp)
 8219090:	00c00284 	movi	r3,10
 8219094:	10c00005 	stb	r3,0(r2)
             break;
 8219098:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 821909c:	d0a07a17 	ldw	r2,-32280(gp)
 82190a0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 82190a4:	d0a07a17 	ldw	r2,-32280(gp)
 82190a8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 82190ac:	d0a07a17 	ldw	r2,-32280(gp)
 82190b0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 82190b4:	d0a07a17 	ldw	r2,-32280(gp)
 82190b8:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 82190bc:	d0a07a17 	ldw	r2,-32280(gp)
 82190c0:	10000915 	stw	zero,36(r2)
 82190c4:	e0bff617 	ldw	r2,-40(fp)
 82190c8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82190cc:	e0bffa17 	ldw	r2,-24(fp)
 82190d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 82190d4:	e0bff517 	ldw	r2,-44(fp)
}
 82190d8:	e037883a 	mov	sp,fp
 82190dc:	dfc00117 	ldw	ra,4(sp)
 82190e0:	df000017 	ldw	fp,0(sp)
 82190e4:	dec00204 	addi	sp,sp,8
 82190e8:	f800283a 	ret

082190ec <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 82190ec:	defff604 	addi	sp,sp,-40
 82190f0:	dfc00915 	stw	ra,36(sp)
 82190f4:	df000815 	stw	fp,32(sp)
 82190f8:	df000804 	addi	fp,sp,32
 82190fc:	e13ffd15 	stw	r4,-12(fp)
 8219100:	2805883a 	mov	r2,r5
 8219104:	e1bfff15 	stw	r6,-4(fp)
 8219108:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821910c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219110:	e0bfff17 	ldw	r2,-4(fp)
 8219114:	1000021e 	bne	r2,zero,8219120 <OSQPendAbort+0x34>
        return (0);
 8219118:	0005883a 	mov	r2,zero
 821911c:	00004906 	br	8219244 <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219120:	e0bffd17 	ldw	r2,-12(fp)
 8219124:	1000051e 	bne	r2,zero,821913c <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219128:	e0bfff17 	ldw	r2,-4(fp)
 821912c:	00c00104 	movi	r3,4
 8219130:	10c00005 	stb	r3,0(r2)
        return (0);
 8219134:	0005883a 	mov	r2,zero
 8219138:	00004206 	br	8219244 <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 821913c:	e0bffd17 	ldw	r2,-12(fp)
 8219140:	10800003 	ldbu	r2,0(r2)
 8219144:	10803fcc 	andi	r2,r2,255
 8219148:	108000a0 	cmpeqi	r2,r2,2
 821914c:	1000051e 	bne	r2,zero,8219164 <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219150:	e0bfff17 	ldw	r2,-4(fp)
 8219154:	00c00044 	movi	r3,1
 8219158:	10c00005 	stb	r3,0(r2)
        return (0);
 821915c:	0005883a 	mov	r2,zero
 8219160:	00003806 	br	8219244 <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219164:	0005303a 	rdctl	r2,status
 8219168:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821916c:	e0fffc17 	ldw	r3,-16(fp)
 8219170:	00bfff84 	movi	r2,-2
 8219174:	1884703a 	and	r2,r3,r2
 8219178:	1001703a 	wrctl	status,r2
  
  return context;
 821917c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219180:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 8219184:	e0bffd17 	ldw	r2,-12(fp)
 8219188:	10800283 	ldbu	r2,10(r2)
 821918c:	10803fcc 	andi	r2,r2,255
 8219190:	10002526 	beq	r2,zero,8219228 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
 8219194:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 8219198:	e0bffe03 	ldbu	r2,-8(fp)
 821919c:	10800060 	cmpeqi	r2,r2,1
 82191a0:	10000e26 	beq	r2,zero,82191dc <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82191a4:	00000806 	br	82191c8 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82191a8:	01c00084 	movi	r7,2
 82191ac:	01800104 	movi	r6,4
 82191b0:	000b883a 	mov	r5,zero
 82191b4:	e13ffd17 	ldw	r4,-12(fp)
 82191b8:	821570c0 	call	821570c <OS_EventTaskRdy>
                     nbr_tasks++;
 82191bc:	e0bff803 	ldbu	r2,-32(fp)
 82191c0:	10800044 	addi	r2,r2,1
 82191c4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82191c8:	e0bffd17 	ldw	r2,-12(fp)
 82191cc:	10800283 	ldbu	r2,10(r2)
 82191d0:	10803fcc 	andi	r2,r2,255
 82191d4:	103ff41e 	bne	r2,zero,82191a8 <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 82191d8:	00000906 	br	8219200 <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82191dc:	01c00084 	movi	r7,2
 82191e0:	01800104 	movi	r6,4
 82191e4:	000b883a 	mov	r5,zero
 82191e8:	e13ffd17 	ldw	r4,-12(fp)
 82191ec:	821570c0 	call	821570c <OS_EventTaskRdy>
                 nbr_tasks++;
 82191f0:	e0bff803 	ldbu	r2,-32(fp)
 82191f4:	10800044 	addi	r2,r2,1
 82191f8:	e0bff805 	stb	r2,-32(fp)
                 break;
 82191fc:	0001883a 	nop
 8219200:	e0bff917 	ldw	r2,-28(fp)
 8219204:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219208:	e0bffa17 	ldw	r2,-24(fp)
 821920c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 8219210:	82161580 	call	8216158 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 8219214:	e0bfff17 	ldw	r2,-4(fp)
 8219218:	00c00384 	movi	r3,14
 821921c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 8219220:	e0bff803 	ldbu	r2,-32(fp)
 8219224:	00000706 	br	8219244 <OSQPendAbort+0x158>
 8219228:	e0bff917 	ldw	r2,-28(fp)
 821922c:	e0bffb15 	stw	r2,-20(fp)
 8219230:	e0bffb17 	ldw	r2,-20(fp)
 8219234:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8219238:	e0bfff17 	ldw	r2,-4(fp)
 821923c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 8219240:	0005883a 	mov	r2,zero
}
 8219244:	e037883a 	mov	sp,fp
 8219248:	dfc00117 	ldw	ra,4(sp)
 821924c:	df000017 	ldw	fp,0(sp)
 8219250:	dec00204 	addi	sp,sp,8
 8219254:	f800283a 	ret

08219258 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 8219258:	defff604 	addi	sp,sp,-40
 821925c:	dfc00915 	stw	ra,36(sp)
 8219260:	df000815 	stw	fp,32(sp)
 8219264:	df000804 	addi	fp,sp,32
 8219268:	e13ffe15 	stw	r4,-8(fp)
 821926c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219270:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 8219274:	e0bffe17 	ldw	r2,-8(fp)
 8219278:	1000021e 	bne	r2,zero,8219284 <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 821927c:	00800104 	movi	r2,4
 8219280:	00004a06 	br	82193ac <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 8219284:	e0bffe17 	ldw	r2,-8(fp)
 8219288:	10800003 	ldbu	r2,0(r2)
 821928c:	10803fcc 	andi	r2,r2,255
 8219290:	108000a0 	cmpeqi	r2,r2,2
 8219294:	1000021e 	bne	r2,zero,82192a0 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 8219298:	00800044 	movi	r2,1
 821929c:	00004306 	br	82193ac <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82192a0:	0005303a 	rdctl	r2,status
 82192a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82192a8:	e0fffd17 	ldw	r3,-12(fp)
 82192ac:	00bfff84 	movi	r2,-2
 82192b0:	1884703a 	and	r2,r3,r2
 82192b4:	1001703a 	wrctl	status,r2
  
  return context;
 82192b8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82192bc:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 82192c0:	e0bffe17 	ldw	r2,-8(fp)
 82192c4:	10800283 	ldbu	r2,10(r2)
 82192c8:	10803fcc 	andi	r2,r2,255
 82192cc:	10000c26 	beq	r2,zero,8219300 <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82192d0:	000f883a 	mov	r7,zero
 82192d4:	01800104 	movi	r6,4
 82192d8:	e17fff17 	ldw	r5,-4(fp)
 82192dc:	e13ffe17 	ldw	r4,-8(fp)
 82192e0:	821570c0 	call	821570c <OS_EventTaskRdy>
 82192e4:	e0bff817 	ldw	r2,-32(fp)
 82192e8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82192ec:	e0bff917 	ldw	r2,-28(fp)
 82192f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 82192f4:	82161580 	call	8216158 <OS_Sched>
        return (OS_ERR_NONE);
 82192f8:	0005883a 	mov	r2,zero
 82192fc:	00002b06 	br	82193ac <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 8219300:	e0bffe17 	ldw	r2,-8(fp)
 8219304:	10800117 	ldw	r2,4(r2)
 8219308:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 821930c:	e0bffb17 	ldw	r2,-20(fp)
 8219310:	10c0058b 	ldhu	r3,22(r2)
 8219314:	e0bffb17 	ldw	r2,-20(fp)
 8219318:	1080050b 	ldhu	r2,20(r2)
 821931c:	18ffffcc 	andi	r3,r3,65535
 8219320:	10bfffcc 	andi	r2,r2,65535
 8219324:	18800636 	bltu	r3,r2,8219340 <OSQPost+0xe8>
 8219328:	e0bff817 	ldw	r2,-32(fp)
 821932c:	e0bffa15 	stw	r2,-24(fp)
 8219330:	e0bffa17 	ldw	r2,-24(fp)
 8219334:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219338:	00800784 	movi	r2,30
 821933c:	00001b06 	br	82193ac <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 8219340:	e0bffb17 	ldw	r2,-20(fp)
 8219344:	10800317 	ldw	r2,12(r2)
 8219348:	11000104 	addi	r4,r2,4
 821934c:	e0fffb17 	ldw	r3,-20(fp)
 8219350:	19000315 	stw	r4,12(r3)
 8219354:	e0ffff17 	ldw	r3,-4(fp)
 8219358:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 821935c:	e0bffb17 	ldw	r2,-20(fp)
 8219360:	1080058b 	ldhu	r2,22(r2)
 8219364:	10800044 	addi	r2,r2,1
 8219368:	1007883a 	mov	r3,r2
 821936c:	e0bffb17 	ldw	r2,-20(fp)
 8219370:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 8219374:	e0bffb17 	ldw	r2,-20(fp)
 8219378:	10c00317 	ldw	r3,12(r2)
 821937c:	e0bffb17 	ldw	r2,-20(fp)
 8219380:	10800217 	ldw	r2,8(r2)
 8219384:	1880041e 	bne	r3,r2,8219398 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 8219388:	e0bffb17 	ldw	r2,-20(fp)
 821938c:	10c00117 	ldw	r3,4(r2)
 8219390:	e0bffb17 	ldw	r2,-20(fp)
 8219394:	10c00315 	stw	r3,12(r2)
 8219398:	e0bff817 	ldw	r2,-32(fp)
 821939c:	e0bffc15 	stw	r2,-16(fp)
 82193a0:	e0bffc17 	ldw	r2,-16(fp)
 82193a4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 82193a8:	0005883a 	mov	r2,zero
}
 82193ac:	e037883a 	mov	sp,fp
 82193b0:	dfc00117 	ldw	ra,4(sp)
 82193b4:	df000017 	ldw	fp,0(sp)
 82193b8:	dec00204 	addi	sp,sp,8
 82193bc:	f800283a 	ret

082193c0 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 82193c0:	defff604 	addi	sp,sp,-40
 82193c4:	dfc00915 	stw	ra,36(sp)
 82193c8:	df000815 	stw	fp,32(sp)
 82193cc:	df000804 	addi	fp,sp,32
 82193d0:	e13ffe15 	stw	r4,-8(fp)
 82193d4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82193d8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 82193dc:	e0bffe17 	ldw	r2,-8(fp)
 82193e0:	1000021e 	bne	r2,zero,82193ec <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 82193e4:	00800104 	movi	r2,4
 82193e8:	00004c06 	br	821951c <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 82193ec:	e0bffe17 	ldw	r2,-8(fp)
 82193f0:	10800003 	ldbu	r2,0(r2)
 82193f4:	10803fcc 	andi	r2,r2,255
 82193f8:	108000a0 	cmpeqi	r2,r2,2
 82193fc:	1000021e 	bne	r2,zero,8219408 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 8219400:	00800044 	movi	r2,1
 8219404:	00004506 	br	821951c <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219408:	0005303a 	rdctl	r2,status
 821940c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219410:	e0fffd17 	ldw	r3,-12(fp)
 8219414:	00bfff84 	movi	r2,-2
 8219418:	1884703a 	and	r2,r3,r2
 821941c:	1001703a 	wrctl	status,r2
  
  return context;
 8219420:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8219424:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 8219428:	e0bffe17 	ldw	r2,-8(fp)
 821942c:	10800283 	ldbu	r2,10(r2)
 8219430:	10803fcc 	andi	r2,r2,255
 8219434:	10000c26 	beq	r2,zero,8219468 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219438:	000f883a 	mov	r7,zero
 821943c:	01800104 	movi	r6,4
 8219440:	e17fff17 	ldw	r5,-4(fp)
 8219444:	e13ffe17 	ldw	r4,-8(fp)
 8219448:	821570c0 	call	821570c <OS_EventTaskRdy>
 821944c:	e0bff817 	ldw	r2,-32(fp)
 8219450:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219454:	e0bff917 	ldw	r2,-28(fp)
 8219458:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 821945c:	82161580 	call	8216158 <OS_Sched>
        return (OS_ERR_NONE);
 8219460:	0005883a 	mov	r2,zero
 8219464:	00002d06 	br	821951c <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219468:	e0bffe17 	ldw	r2,-8(fp)
 821946c:	10800117 	ldw	r2,4(r2)
 8219470:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 8219474:	e0bffb17 	ldw	r2,-20(fp)
 8219478:	10c0058b 	ldhu	r3,22(r2)
 821947c:	e0bffb17 	ldw	r2,-20(fp)
 8219480:	1080050b 	ldhu	r2,20(r2)
 8219484:	18ffffcc 	andi	r3,r3,65535
 8219488:	10bfffcc 	andi	r2,r2,65535
 821948c:	18800636 	bltu	r3,r2,82194a8 <OSQPostFront+0xe8>
 8219490:	e0bff817 	ldw	r2,-32(fp)
 8219494:	e0bffa15 	stw	r2,-24(fp)
 8219498:	e0bffa17 	ldw	r2,-24(fp)
 821949c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 82194a0:	00800784 	movi	r2,30
 82194a4:	00001d06 	br	821951c <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 82194a8:	e0bffb17 	ldw	r2,-20(fp)
 82194ac:	10c00417 	ldw	r3,16(r2)
 82194b0:	e0bffb17 	ldw	r2,-20(fp)
 82194b4:	10800117 	ldw	r2,4(r2)
 82194b8:	1880041e 	bne	r3,r2,82194cc <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 82194bc:	e0bffb17 	ldw	r2,-20(fp)
 82194c0:	10c00217 	ldw	r3,8(r2)
 82194c4:	e0bffb17 	ldw	r2,-20(fp)
 82194c8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 82194cc:	e0bffb17 	ldw	r2,-20(fp)
 82194d0:	10800417 	ldw	r2,16(r2)
 82194d4:	10ffff04 	addi	r3,r2,-4
 82194d8:	e0bffb17 	ldw	r2,-20(fp)
 82194dc:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 82194e0:	e0bffb17 	ldw	r2,-20(fp)
 82194e4:	10800417 	ldw	r2,16(r2)
 82194e8:	e0ffff17 	ldw	r3,-4(fp)
 82194ec:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 82194f0:	e0bffb17 	ldw	r2,-20(fp)
 82194f4:	1080058b 	ldhu	r2,22(r2)
 82194f8:	10800044 	addi	r2,r2,1
 82194fc:	1007883a 	mov	r3,r2
 8219500:	e0bffb17 	ldw	r2,-20(fp)
 8219504:	10c0058d 	sth	r3,22(r2)
 8219508:	e0bff817 	ldw	r2,-32(fp)
 821950c:	e0bffc15 	stw	r2,-16(fp)
 8219510:	e0bffc17 	ldw	r2,-16(fp)
 8219514:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219518:	0005883a 	mov	r2,zero
}
 821951c:	e037883a 	mov	sp,fp
 8219520:	dfc00117 	ldw	ra,4(sp)
 8219524:	df000017 	ldw	fp,0(sp)
 8219528:	dec00204 	addi	sp,sp,8
 821952c:	f800283a 	ret

08219530 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 8219530:	defff504 	addi	sp,sp,-44
 8219534:	dfc00a15 	stw	ra,40(sp)
 8219538:	df000915 	stw	fp,36(sp)
 821953c:	df000904 	addi	fp,sp,36
 8219540:	e13ffd15 	stw	r4,-12(fp)
 8219544:	e17ffe15 	stw	r5,-8(fp)
 8219548:	3005883a 	mov	r2,r6
 821954c:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219550:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219554:	e0bffd17 	ldw	r2,-12(fp)
 8219558:	1000021e 	bne	r2,zero,8219564 <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 821955c:	00800104 	movi	r2,4
 8219560:	00007106 	br	8219728 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8219564:	e0bffd17 	ldw	r2,-12(fp)
 8219568:	10800003 	ldbu	r2,0(r2)
 821956c:	10803fcc 	andi	r2,r2,255
 8219570:	108000a0 	cmpeqi	r2,r2,2
 8219574:	1000021e 	bne	r2,zero,8219580 <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 8219578:	00800044 	movi	r2,1
 821957c:	00006a06 	br	8219728 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219580:	0005303a 	rdctl	r2,status
 8219584:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219588:	e0fffc17 	ldw	r3,-16(fp)
 821958c:	00bfff84 	movi	r2,-2
 8219590:	1884703a 	and	r2,r3,r2
 8219594:	1001703a 	wrctl	status,r2
  
  return context;
 8219598:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821959c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 82195a0:	e0bffd17 	ldw	r2,-12(fp)
 82195a4:	10800283 	ldbu	r2,10(r2)
 82195a8:	10803fcc 	andi	r2,r2,255
 82195ac:	10001d26 	beq	r2,zero,8219624 <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 82195b0:	e0bfff03 	ldbu	r2,-4(fp)
 82195b4:	1080004c 	andi	r2,r2,1
 82195b8:	10000b26 	beq	r2,zero,82195e8 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82195bc:	00000506 	br	82195d4 <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82195c0:	000f883a 	mov	r7,zero
 82195c4:	01800104 	movi	r6,4
 82195c8:	e17ffe17 	ldw	r5,-8(fp)
 82195cc:	e13ffd17 	ldw	r4,-12(fp)
 82195d0:	821570c0 	call	821570c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82195d4:	e0bffd17 	ldw	r2,-12(fp)
 82195d8:	10800283 	ldbu	r2,10(r2)
 82195dc:	10803fcc 	andi	r2,r2,255
 82195e0:	103ff71e 	bne	r2,zero,82195c0 <OSQPostOpt+0x90>
 82195e4:	00000506 	br	82195fc <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82195e8:	000f883a 	mov	r7,zero
 82195ec:	01800104 	movi	r6,4
 82195f0:	e17ffe17 	ldw	r5,-8(fp)
 82195f4:	e13ffd17 	ldw	r4,-12(fp)
 82195f8:	821570c0 	call	821570c <OS_EventTaskRdy>
 82195fc:	e0bff717 	ldw	r2,-36(fp)
 8219600:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219604:	e0bff817 	ldw	r2,-32(fp)
 8219608:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 821960c:	e0bfff03 	ldbu	r2,-4(fp)
 8219610:	1080010c 	andi	r2,r2,4
 8219614:	1000011e 	bne	r2,zero,821961c <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 8219618:	82161580 	call	8216158 <OS_Sched>
        }
        return (OS_ERR_NONE);
 821961c:	0005883a 	mov	r2,zero
 8219620:	00004106 	br	8219728 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219624:	e0bffd17 	ldw	r2,-12(fp)
 8219628:	10800117 	ldw	r2,4(r2)
 821962c:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 8219630:	e0bffa17 	ldw	r2,-24(fp)
 8219634:	10c0058b 	ldhu	r3,22(r2)
 8219638:	e0bffa17 	ldw	r2,-24(fp)
 821963c:	1080050b 	ldhu	r2,20(r2)
 8219640:	18ffffcc 	andi	r3,r3,65535
 8219644:	10bfffcc 	andi	r2,r2,65535
 8219648:	18800636 	bltu	r3,r2,8219664 <OSQPostOpt+0x134>
 821964c:	e0bff717 	ldw	r2,-36(fp)
 8219650:	e0bff915 	stw	r2,-28(fp)
 8219654:	e0bff917 	ldw	r2,-28(fp)
 8219658:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 821965c:	00800784 	movi	r2,30
 8219660:	00003106 	br	8219728 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 8219664:	e0bfff03 	ldbu	r2,-4(fp)
 8219668:	1080008c 	andi	r2,r2,2
 821966c:	10001326 	beq	r2,zero,82196bc <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 8219670:	e0bffa17 	ldw	r2,-24(fp)
 8219674:	10c00417 	ldw	r3,16(r2)
 8219678:	e0bffa17 	ldw	r2,-24(fp)
 821967c:	10800117 	ldw	r2,4(r2)
 8219680:	1880041e 	bne	r3,r2,8219694 <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 8219684:	e0bffa17 	ldw	r2,-24(fp)
 8219688:	10c00217 	ldw	r3,8(r2)
 821968c:	e0bffa17 	ldw	r2,-24(fp)
 8219690:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 8219694:	e0bffa17 	ldw	r2,-24(fp)
 8219698:	10800417 	ldw	r2,16(r2)
 821969c:	10ffff04 	addi	r3,r2,-4
 82196a0:	e0bffa17 	ldw	r2,-24(fp)
 82196a4:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 82196a8:	e0bffa17 	ldw	r2,-24(fp)
 82196ac:	10800417 	ldw	r2,16(r2)
 82196b0:	e0fffe17 	ldw	r3,-8(fp)
 82196b4:	10c00015 	stw	r3,0(r2)
 82196b8:	00001006 	br	82196fc <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 82196bc:	e0bffa17 	ldw	r2,-24(fp)
 82196c0:	10800317 	ldw	r2,12(r2)
 82196c4:	11000104 	addi	r4,r2,4
 82196c8:	e0fffa17 	ldw	r3,-24(fp)
 82196cc:	19000315 	stw	r4,12(r3)
 82196d0:	e0fffe17 	ldw	r3,-8(fp)
 82196d4:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 82196d8:	e0bffa17 	ldw	r2,-24(fp)
 82196dc:	10c00317 	ldw	r3,12(r2)
 82196e0:	e0bffa17 	ldw	r2,-24(fp)
 82196e4:	10800217 	ldw	r2,8(r2)
 82196e8:	1880041e 	bne	r3,r2,82196fc <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 82196ec:	e0bffa17 	ldw	r2,-24(fp)
 82196f0:	10c00117 	ldw	r3,4(r2)
 82196f4:	e0bffa17 	ldw	r2,-24(fp)
 82196f8:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 82196fc:	e0bffa17 	ldw	r2,-24(fp)
 8219700:	1080058b 	ldhu	r2,22(r2)
 8219704:	10800044 	addi	r2,r2,1
 8219708:	1007883a 	mov	r3,r2
 821970c:	e0bffa17 	ldw	r2,-24(fp)
 8219710:	10c0058d 	sth	r3,22(r2)
 8219714:	e0bff717 	ldw	r2,-36(fp)
 8219718:	e0bffb15 	stw	r2,-20(fp)
 821971c:	e0bffb17 	ldw	r2,-20(fp)
 8219720:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219724:	0005883a 	mov	r2,zero
}
 8219728:	e037883a 	mov	sp,fp
 821972c:	dfc00117 	ldw	ra,4(sp)
 8219730:	df000017 	ldw	fp,0(sp)
 8219734:	dec00204 	addi	sp,sp,8
 8219738:	f800283a 	ret

0821973c <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 821973c:	defff604 	addi	sp,sp,-40
 8219740:	df000915 	stw	fp,36(sp)
 8219744:	df000904 	addi	fp,sp,36
 8219748:	e13ffe15 	stw	r4,-8(fp)
 821974c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219750:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 8219754:	e0bffe17 	ldw	r2,-8(fp)
 8219758:	1000021e 	bne	r2,zero,8219764 <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 821975c:	00800104 	movi	r2,4
 8219760:	00004906 	br	8219888 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 8219764:	e0bfff17 	ldw	r2,-4(fp)
 8219768:	1000021e 	bne	r2,zero,8219774 <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 821976c:	00800244 	movi	r2,9
 8219770:	00004506 	br	8219888 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 8219774:	e0bffe17 	ldw	r2,-8(fp)
 8219778:	10800003 	ldbu	r2,0(r2)
 821977c:	10803fcc 	andi	r2,r2,255
 8219780:	108000a0 	cmpeqi	r2,r2,2
 8219784:	1000021e 	bne	r2,zero,8219790 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 8219788:	00800044 	movi	r2,1
 821978c:	00003e06 	br	8219888 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219790:	0005303a 	rdctl	r2,status
 8219794:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219798:	e0fffd17 	ldw	r3,-12(fp)
 821979c:	00bfff84 	movi	r2,-2
 82197a0:	1884703a 	and	r2,r3,r2
 82197a4:	1001703a 	wrctl	status,r2
  
  return context;
 82197a8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82197ac:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 82197b0:	e0bffe17 	ldw	r2,-8(fp)
 82197b4:	10c00283 	ldbu	r3,10(r2)
 82197b8:	e0bfff17 	ldw	r2,-4(fp)
 82197bc:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 82197c0:	e0bffe17 	ldw	r2,-8(fp)
 82197c4:	108002c4 	addi	r2,r2,11
 82197c8:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 82197cc:	e0bfff17 	ldw	r2,-4(fp)
 82197d0:	10800204 	addi	r2,r2,8
 82197d4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 82197d8:	e03ff705 	stb	zero,-36(fp)
 82197dc:	00000b06 	br	821980c <OSQQuery+0xd0>
        *pdest++ = *psrc++;
 82197e0:	e0bff917 	ldw	r2,-28(fp)
 82197e4:	10c00044 	addi	r3,r2,1
 82197e8:	e0fff915 	stw	r3,-28(fp)
 82197ec:	e0fff817 	ldw	r3,-32(fp)
 82197f0:	19000044 	addi	r4,r3,1
 82197f4:	e13ff815 	stw	r4,-32(fp)
 82197f8:	18c00003 	ldbu	r3,0(r3)
 82197fc:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219800:	e0bff703 	ldbu	r2,-36(fp)
 8219804:	10800044 	addi	r2,r2,1
 8219808:	e0bff705 	stb	r2,-36(fp)
 821980c:	e0bff703 	ldbu	r2,-36(fp)
 8219810:	108000f0 	cmpltui	r2,r2,3
 8219814:	103ff21e 	bne	r2,zero,82197e0 <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 8219818:	e0bffe17 	ldw	r2,-8(fp)
 821981c:	10800117 	ldw	r2,4(r2)
 8219820:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 8219824:	e0bffc17 	ldw	r2,-16(fp)
 8219828:	1080058b 	ldhu	r2,22(r2)
 821982c:	10bfffcc 	andi	r2,r2,65535
 8219830:	10000626 	beq	r2,zero,821984c <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 8219834:	e0bffc17 	ldw	r2,-16(fp)
 8219838:	10800417 	ldw	r2,16(r2)
 821983c:	10c00017 	ldw	r3,0(r2)
 8219840:	e0bfff17 	ldw	r2,-4(fp)
 8219844:	10c00015 	stw	r3,0(r2)
 8219848:	00000206 	br	8219854 <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
 821984c:	e0bfff17 	ldw	r2,-4(fp)
 8219850:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 8219854:	e0bffc17 	ldw	r2,-16(fp)
 8219858:	10c0058b 	ldhu	r3,22(r2)
 821985c:	e0bfff17 	ldw	r2,-4(fp)
 8219860:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 8219864:	e0bffc17 	ldw	r2,-16(fp)
 8219868:	10c0050b 	ldhu	r3,20(r2)
 821986c:	e0bfff17 	ldw	r2,-4(fp)
 8219870:	10c0018d 	sth	r3,6(r2)
 8219874:	e0bffa17 	ldw	r2,-24(fp)
 8219878:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821987c:	e0bffb17 	ldw	r2,-20(fp)
 8219880:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219884:	0005883a 	mov	r2,zero
}
 8219888:	e037883a 	mov	sp,fp
 821988c:	df000017 	ldw	fp,0(sp)
 8219890:	dec00104 	addi	sp,sp,4
 8219894:	f800283a 	ret

08219898 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 8219898:	defffb04 	addi	sp,sp,-20
 821989c:	dfc00415 	stw	ra,16(sp)
 82198a0:	df000315 	stw	fp,12(sp)
 82198a4:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 82198a8:	01407804 	movi	r5,480
 82198ac:	010209b4 	movhi	r4,2086
 82198b0:	212eb404 	addi	r4,r4,-17712
 82198b4:	821609c0 	call	821609c <OS_MemClr>
    pq1 = &OSQTbl[0];
 82198b8:	008209b4 	movhi	r2,2086
 82198bc:	10aeb404 	addi	r2,r2,-17712
 82198c0:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 82198c4:	008209b4 	movhi	r2,2086
 82198c8:	10aeba04 	addi	r2,r2,-17688
 82198cc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 82198d0:	e03ffd0d 	sth	zero,-12(fp)
 82198d4:	00000c06 	br	8219908 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 82198d8:	e0bffe17 	ldw	r2,-8(fp)
 82198dc:	e0ffff17 	ldw	r3,-4(fp)
 82198e0:	10c00015 	stw	r3,0(r2)
        pq1++;
 82198e4:	e0bffe17 	ldw	r2,-8(fp)
 82198e8:	10800604 	addi	r2,r2,24
 82198ec:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 82198f0:	e0bfff17 	ldw	r2,-4(fp)
 82198f4:	10800604 	addi	r2,r2,24
 82198f8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 82198fc:	e0bffd0b 	ldhu	r2,-12(fp)
 8219900:	10800044 	addi	r2,r2,1
 8219904:	e0bffd0d 	sth	r2,-12(fp)
 8219908:	e0bffd0b 	ldhu	r2,-12(fp)
 821990c:	108004f0 	cmpltui	r2,r2,19
 8219910:	103ff11e 	bne	r2,zero,82198d8 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 8219914:	e0bffe17 	ldw	r2,-8(fp)
 8219918:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 821991c:	008209b4 	movhi	r2,2086
 8219920:	10aeb404 	addi	r2,r2,-17712
 8219924:	d0a07615 	stw	r2,-32296(gp)
#endif
}
 8219928:	0001883a 	nop
 821992c:	e037883a 	mov	sp,fp
 8219930:	dfc00117 	ldw	ra,4(sp)
 8219934:	df000017 	ldw	fp,0(sp)
 8219938:	dec00204 	addi	sp,sp,8
 821993c:	f800283a 	ret

08219940 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 8219940:	defffa04 	addi	sp,sp,-24
 8219944:	df000515 	stw	fp,20(sp)
 8219948:	df000504 	addi	fp,sp,20
 821994c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219950:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219954:	e0bfff17 	ldw	r2,-4(fp)
 8219958:	1000021e 	bne	r2,zero,8219964 <OSSemAccept+0x24>
        return (0);
 821995c:	0005883a 	mov	r2,zero
 8219960:	00001f06 	br	82199e0 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219964:	e0bfff17 	ldw	r2,-4(fp)
 8219968:	10800003 	ldbu	r2,0(r2)
 821996c:	10803fcc 	andi	r2,r2,255
 8219970:	108000e0 	cmpeqi	r2,r2,3
 8219974:	1000021e 	bne	r2,zero,8219980 <OSSemAccept+0x40>
        return (0);
 8219978:	0005883a 	mov	r2,zero
 821997c:	00001806 	br	82199e0 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219980:	0005303a 	rdctl	r2,status
 8219984:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219988:	e0fffe17 	ldw	r3,-8(fp)
 821998c:	00bfff84 	movi	r2,-2
 8219990:	1884703a 	and	r2,r3,r2
 8219994:	1001703a 	wrctl	status,r2
  
  return context;
 8219998:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821999c:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 82199a0:	e0bfff17 	ldw	r2,-4(fp)
 82199a4:	1080020b 	ldhu	r2,8(r2)
 82199a8:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 82199ac:	e0bffd0b 	ldhu	r2,-12(fp)
 82199b0:	10000626 	beq	r2,zero,82199cc <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 82199b4:	e0bfff17 	ldw	r2,-4(fp)
 82199b8:	1080020b 	ldhu	r2,8(r2)
 82199bc:	10bfffc4 	addi	r2,r2,-1
 82199c0:	1007883a 	mov	r3,r2
 82199c4:	e0bfff17 	ldw	r2,-4(fp)
 82199c8:	10c0020d 	sth	r3,8(r2)
 82199cc:	e0bffb17 	ldw	r2,-20(fp)
 82199d0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82199d4:	e0bffc17 	ldw	r2,-16(fp)
 82199d8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 82199dc:	e0bffd0b 	ldhu	r2,-12(fp)
}
 82199e0:	e037883a 	mov	sp,fp
 82199e4:	df000017 	ldw	fp,0(sp)
 82199e8:	dec00104 	addi	sp,sp,4
 82199ec:	f800283a 	ret

082199f0 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 82199f0:	defff904 	addi	sp,sp,-28
 82199f4:	dfc00615 	stw	ra,24(sp)
 82199f8:	df000515 	stw	fp,20(sp)
 82199fc:	df000504 	addi	fp,sp,20
 8219a00:	2005883a 	mov	r2,r4
 8219a04:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219a08:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219a0c:	d0a07903 	ldbu	r2,-32284(gp)
 8219a10:	10803fcc 	andi	r2,r2,255
 8219a14:	10000226 	beq	r2,zero,8219a20 <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 8219a18:	0005883a 	mov	r2,zero
 8219a1c:	00002506 	br	8219ab4 <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219a20:	0005303a 	rdctl	r2,status
 8219a24:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219a28:	e0fffe17 	ldw	r3,-8(fp)
 8219a2c:	00bfff84 	movi	r2,-2
 8219a30:	1884703a 	and	r2,r3,r2
 8219a34:	1001703a 	wrctl	status,r2
  
  return context;
 8219a38:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219a3c:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 8219a40:	d0a07817 	ldw	r2,-32288(gp)
 8219a44:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 8219a48:	d0a07817 	ldw	r2,-32288(gp)
 8219a4c:	10000326 	beq	r2,zero,8219a5c <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8219a50:	d0a07817 	ldw	r2,-32288(gp)
 8219a54:	10800117 	ldw	r2,4(r2)
 8219a58:	d0a07815 	stw	r2,-32288(gp)
 8219a5c:	e0bffb17 	ldw	r2,-20(fp)
 8219a60:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219a64:	e0bffc17 	ldw	r2,-16(fp)
 8219a68:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 8219a6c:	e0bffd17 	ldw	r2,-12(fp)
 8219a70:	10000f26 	beq	r2,zero,8219ab0 <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 8219a74:	e0bffd17 	ldw	r2,-12(fp)
 8219a78:	00c000c4 	movi	r3,3
 8219a7c:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 8219a80:	e0bffd17 	ldw	r2,-12(fp)
 8219a84:	e0ffff0b 	ldhu	r3,-4(fp)
 8219a88:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 8219a8c:	e0bffd17 	ldw	r2,-12(fp)
 8219a90:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 8219a94:	e0bffd17 	ldw	r2,-12(fp)
 8219a98:	00c00fc4 	movi	r3,63
 8219a9c:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 8219aa0:	e0bffd17 	ldw	r2,-12(fp)
 8219aa4:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 8219aa8:	e13ffd17 	ldw	r4,-12(fp)
 8219aac:	8215cbc0 	call	8215cbc <OS_EventWaitListInit>
    }
    return (pevent);
 8219ab0:	e0bffd17 	ldw	r2,-12(fp)
}
 8219ab4:	e037883a 	mov	sp,fp
 8219ab8:	dfc00117 	ldw	ra,4(sp)
 8219abc:	df000017 	ldw	fp,0(sp)
 8219ac0:	dec00204 	addi	sp,sp,8
 8219ac4:	f800283a 	ret

08219ac8 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219ac8:	defff304 	addi	sp,sp,-52
 8219acc:	dfc00c15 	stw	ra,48(sp)
 8219ad0:	df000b15 	stw	fp,44(sp)
 8219ad4:	df000b04 	addi	fp,sp,44
 8219ad8:	e13ffd15 	stw	r4,-12(fp)
 8219adc:	2805883a 	mov	r2,r5
 8219ae0:	e1bfff15 	stw	r6,-4(fp)
 8219ae4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219ae8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219aec:	e0bfff17 	ldw	r2,-4(fp)
 8219af0:	1000021e 	bne	r2,zero,8219afc <OSSemDel+0x34>
        return (pevent);
 8219af4:	e0bffd17 	ldw	r2,-12(fp)
 8219af8:	00007e06 	br	8219cf4 <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219afc:	e0bffd17 	ldw	r2,-12(fp)
 8219b00:	1000051e 	bne	r2,zero,8219b18 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219b04:	e0bfff17 	ldw	r2,-4(fp)
 8219b08:	00c00104 	movi	r3,4
 8219b0c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219b10:	e0bffd17 	ldw	r2,-12(fp)
 8219b14:	00007706 	br	8219cf4 <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 8219b18:	e0bffd17 	ldw	r2,-12(fp)
 8219b1c:	10800003 	ldbu	r2,0(r2)
 8219b20:	10803fcc 	andi	r2,r2,255
 8219b24:	108000e0 	cmpeqi	r2,r2,3
 8219b28:	1000051e 	bne	r2,zero,8219b40 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219b2c:	e0bfff17 	ldw	r2,-4(fp)
 8219b30:	00c00044 	movi	r3,1
 8219b34:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219b38:	e0bffd17 	ldw	r2,-12(fp)
 8219b3c:	00006d06 	br	8219cf4 <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219b40:	d0a07903 	ldbu	r2,-32284(gp)
 8219b44:	10803fcc 	andi	r2,r2,255
 8219b48:	10000526 	beq	r2,zero,8219b60 <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 8219b4c:	e0bfff17 	ldw	r2,-4(fp)
 8219b50:	00c003c4 	movi	r3,15
 8219b54:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219b58:	e0bffd17 	ldw	r2,-12(fp)
 8219b5c:	00006506 	br	8219cf4 <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219b60:	0005303a 	rdctl	r2,status
 8219b64:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219b68:	e0fffc17 	ldw	r3,-16(fp)
 8219b6c:	00bfff84 	movi	r2,-2
 8219b70:	1884703a 	and	r2,r3,r2
 8219b74:	1001703a 	wrctl	status,r2
  
  return context;
 8219b78:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219b7c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 8219b80:	e0bffd17 	ldw	r2,-12(fp)
 8219b84:	10800283 	ldbu	r2,10(r2)
 8219b88:	10803fcc 	andi	r2,r2,255
 8219b8c:	10000326 	beq	r2,zero,8219b9c <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8219b90:	00800044 	movi	r2,1
 8219b94:	e0bff505 	stb	r2,-44(fp)
 8219b98:	00000106 	br	8219ba0 <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8219b9c:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 8219ba0:	e0bffe03 	ldbu	r2,-8(fp)
 8219ba4:	10000326 	beq	r2,zero,8219bb4 <OSSemDel+0xec>
 8219ba8:	10800060 	cmpeqi	r2,r2,1
 8219bac:	1000281e 	bne	r2,zero,8219c50 <OSSemDel+0x188>
 8219bb0:	00004506 	br	8219cc8 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 8219bb4:	e0bff503 	ldbu	r2,-44(fp)
 8219bb8:	1000161e 	bne	r2,zero,8219c14 <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8219bbc:	e0bffd17 	ldw	r2,-12(fp)
 8219bc0:	00c00fc4 	movi	r3,63
 8219bc4:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8219bc8:	e0bffd17 	ldw	r2,-12(fp)
 8219bcc:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219bd0:	e0bffd17 	ldw	r2,-12(fp)
 8219bd4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8219bd8:	d0e07817 	ldw	r3,-32288(gp)
 8219bdc:	e0bffd17 	ldw	r2,-12(fp)
 8219be0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8219be4:	e0bffd17 	ldw	r2,-12(fp)
 8219be8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8219bec:	e0bffd17 	ldw	r2,-12(fp)
 8219bf0:	d0a07815 	stw	r2,-32288(gp)
 8219bf4:	e0bff717 	ldw	r2,-36(fp)
 8219bf8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219bfc:	e0bff817 	ldw	r2,-32(fp)
 8219c00:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8219c04:	e0bfff17 	ldw	r2,-4(fp)
 8219c08:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 8219c0c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8219c10:	00003706 	br	8219cf0 <OSSemDel+0x228>
 8219c14:	e0bff717 	ldw	r2,-36(fp)
 8219c18:	e0bff915 	stw	r2,-28(fp)
 8219c1c:	e0bff917 	ldw	r2,-28(fp)
 8219c20:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8219c24:	e0bfff17 	ldw	r2,-4(fp)
 8219c28:	00c01244 	movi	r3,73
 8219c2c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8219c30:	e0bffd17 	ldw	r2,-12(fp)
 8219c34:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8219c38:	00002d06 	br	8219cf0 <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 8219c3c:	000f883a 	mov	r7,zero
 8219c40:	01800044 	movi	r6,1
 8219c44:	000b883a 	mov	r5,zero
 8219c48:	e13ffd17 	ldw	r4,-12(fp)
 8219c4c:	821570c0 	call	821570c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 8219c50:	e0bffd17 	ldw	r2,-12(fp)
 8219c54:	10800283 	ldbu	r2,10(r2)
 8219c58:	10803fcc 	andi	r2,r2,255
 8219c5c:	103ff71e 	bne	r2,zero,8219c3c <OSSemDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8219c60:	e0bffd17 	ldw	r2,-12(fp)
 8219c64:	00c00fc4 	movi	r3,63
 8219c68:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 8219c6c:	e0bffd17 	ldw	r2,-12(fp)
 8219c70:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219c74:	e0bffd17 	ldw	r2,-12(fp)
 8219c78:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 8219c7c:	d0e07817 	ldw	r3,-32288(gp)
 8219c80:	e0bffd17 	ldw	r2,-12(fp)
 8219c84:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8219c88:	e0bffd17 	ldw	r2,-12(fp)
 8219c8c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8219c90:	e0bffd17 	ldw	r2,-12(fp)
 8219c94:	d0a07815 	stw	r2,-32288(gp)
 8219c98:	e0bff717 	ldw	r2,-36(fp)
 8219c9c:	e0bffa15 	stw	r2,-24(fp)
 8219ca0:	e0bffa17 	ldw	r2,-24(fp)
 8219ca4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8219ca8:	e0bff503 	ldbu	r2,-44(fp)
 8219cac:	10800058 	cmpnei	r2,r2,1
 8219cb0:	1000011e 	bne	r2,zero,8219cb8 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8219cb4:	82161580 	call	8216158 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8219cb8:	e0bfff17 	ldw	r2,-4(fp)
 8219cbc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 8219cc0:	e03ff615 	stw	zero,-40(fp)
             break;
 8219cc4:	00000a06 	br	8219cf0 <OSSemDel+0x228>
 8219cc8:	e0bff717 	ldw	r2,-36(fp)
 8219ccc:	e0bffb15 	stw	r2,-20(fp)
 8219cd0:	e0bffb17 	ldw	r2,-20(fp)
 8219cd4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 8219cd8:	e0bfff17 	ldw	r2,-4(fp)
 8219cdc:	00c001c4 	movi	r3,7
 8219ce0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 8219ce4:	e0bffd17 	ldw	r2,-12(fp)
 8219ce8:	e0bff615 	stw	r2,-40(fp)
             break;
 8219cec:	0001883a 	nop
    }
    return (pevent_return);
 8219cf0:	e0bff617 	ldw	r2,-40(fp)
}
 8219cf4:	e037883a 	mov	sp,fp
 8219cf8:	dfc00117 	ldw	ra,4(sp)
 8219cfc:	df000017 	ldw	fp,0(sp)
 8219d00:	dec00204 	addi	sp,sp,8
 8219d04:	f800283a 	ret

08219d08 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 8219d08:	defff504 	addi	sp,sp,-44
 8219d0c:	dfc00a15 	stw	ra,40(sp)
 8219d10:	df000915 	stw	fp,36(sp)
 8219d14:	df000904 	addi	fp,sp,36
 8219d18:	e13ffd15 	stw	r4,-12(fp)
 8219d1c:	2805883a 	mov	r2,r5
 8219d20:	e1bfff15 	stw	r6,-4(fp)
 8219d24:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219d28:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8219d2c:	e0bfff17 	ldw	r2,-4(fp)
 8219d30:	10007226 	beq	r2,zero,8219efc <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219d34:	e0bffd17 	ldw	r2,-12(fp)
 8219d38:	1000041e 	bne	r2,zero,8219d4c <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 8219d3c:	e0bfff17 	ldw	r2,-4(fp)
 8219d40:	00c00104 	movi	r3,4
 8219d44:	10c00005 	stb	r3,0(r2)
        return;
 8219d48:	00006d06 	br	8219f00 <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219d4c:	e0bffd17 	ldw	r2,-12(fp)
 8219d50:	10800003 	ldbu	r2,0(r2)
 8219d54:	10803fcc 	andi	r2,r2,255
 8219d58:	108000e0 	cmpeqi	r2,r2,3
 8219d5c:	1000041e 	bne	r2,zero,8219d70 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 8219d60:	e0bfff17 	ldw	r2,-4(fp)
 8219d64:	00c00044 	movi	r3,1
 8219d68:	10c00005 	stb	r3,0(r2)
        return;
 8219d6c:	00006406 	br	8219f00 <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 8219d70:	d0a07903 	ldbu	r2,-32284(gp)
 8219d74:	10803fcc 	andi	r2,r2,255
 8219d78:	10000426 	beq	r2,zero,8219d8c <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 8219d7c:	e0bfff17 	ldw	r2,-4(fp)
 8219d80:	00c00084 	movi	r3,2
 8219d84:	10c00005 	stb	r3,0(r2)
        return;
 8219d88:	00005d06 	br	8219f00 <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 8219d8c:	d0a06b03 	ldbu	r2,-32340(gp)
 8219d90:	10803fcc 	andi	r2,r2,255
 8219d94:	10000426 	beq	r2,zero,8219da8 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 8219d98:	e0bfff17 	ldw	r2,-4(fp)
 8219d9c:	00c00344 	movi	r3,13
 8219da0:	10c00005 	stb	r3,0(r2)
        return;
 8219da4:	00005606 	br	8219f00 <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219da8:	0005303a 	rdctl	r2,status
 8219dac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219db0:	e0fffc17 	ldw	r3,-16(fp)
 8219db4:	00bfff84 	movi	r2,-2
 8219db8:	1884703a 	and	r2,r3,r2
 8219dbc:	1001703a 	wrctl	status,r2
  
  return context;
 8219dc0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219dc4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 8219dc8:	e0bffd17 	ldw	r2,-12(fp)
 8219dcc:	1080020b 	ldhu	r2,8(r2)
 8219dd0:	10bfffcc 	andi	r2,r2,65535
 8219dd4:	10000d26 	beq	r2,zero,8219e0c <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 8219dd8:	e0bffd17 	ldw	r2,-12(fp)
 8219ddc:	1080020b 	ldhu	r2,8(r2)
 8219de0:	10bfffc4 	addi	r2,r2,-1
 8219de4:	1007883a 	mov	r3,r2
 8219de8:	e0bffd17 	ldw	r2,-12(fp)
 8219dec:	10c0020d 	sth	r3,8(r2)
 8219df0:	e0bff717 	ldw	r2,-36(fp)
 8219df4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219df8:	e0bff817 	ldw	r2,-32(fp)
 8219dfc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 8219e00:	e0bfff17 	ldw	r2,-4(fp)
 8219e04:	10000005 	stb	zero,0(r2)
        return;
 8219e08:	00003d06 	br	8219f00 <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 8219e0c:	d0a07a17 	ldw	r2,-32280(gp)
 8219e10:	d0e07a17 	ldw	r3,-32280(gp)
 8219e14:	18c00c03 	ldbu	r3,48(r3)
 8219e18:	18c00054 	ori	r3,r3,1
 8219e1c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8219e20:	d0a07a17 	ldw	r2,-32280(gp)
 8219e24:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 8219e28:	d0a07a17 	ldw	r2,-32280(gp)
 8219e2c:	e0fffe0b 	ldhu	r3,-8(fp)
 8219e30:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 8219e34:	e13ffd17 	ldw	r4,-12(fp)
 8219e38:	82158a40 	call	82158a4 <OS_EventTaskWait>
 8219e3c:	e0bff717 	ldw	r2,-36(fp)
 8219e40:	e0bffb15 	stw	r2,-20(fp)
 8219e44:	e0bffb17 	ldw	r2,-20(fp)
 8219e48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 8219e4c:	82161580 	call	8216158 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219e50:	0005303a 	rdctl	r2,status
 8219e54:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219e58:	e0fff917 	ldw	r3,-28(fp)
 8219e5c:	00bfff84 	movi	r2,-2
 8219e60:	1884703a 	and	r2,r3,r2
 8219e64:	1001703a 	wrctl	status,r2
  
  return context;
 8219e68:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 8219e6c:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 8219e70:	d0a07a17 	ldw	r2,-32280(gp)
 8219e74:	10800c43 	ldbu	r2,49(r2)
 8219e78:	10803fcc 	andi	r2,r2,255
 8219e7c:	10000326 	beq	r2,zero,8219e8c <OSSemPend+0x184>
 8219e80:	108000a0 	cmpeqi	r2,r2,2
 8219e84:	1000041e 	bne	r2,zero,8219e98 <OSSemPend+0x190>
 8219e88:	00000706 	br	8219ea8 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 8219e8c:	e0bfff17 	ldw	r2,-4(fp)
 8219e90:	10000005 	stb	zero,0(r2)
             break;
 8219e94:	00000c06 	br	8219ec8 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219e98:	e0bfff17 	ldw	r2,-4(fp)
 8219e9c:	00c00384 	movi	r3,14
 8219ea0:	10c00005 	stb	r3,0(r2)
             break;
 8219ea4:	00000806 	br	8219ec8 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 8219ea8:	d0a07a17 	ldw	r2,-32280(gp)
 8219eac:	e17ffd17 	ldw	r5,-12(fp)
 8219eb0:	1009883a 	mov	r4,r2
 8219eb4:	8215b040 	call	8215b04 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 8219eb8:	e0bfff17 	ldw	r2,-4(fp)
 8219ebc:	00c00284 	movi	r3,10
 8219ec0:	10c00005 	stb	r3,0(r2)
             break;
 8219ec4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 8219ec8:	d0a07a17 	ldw	r2,-32280(gp)
 8219ecc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 8219ed0:	d0a07a17 	ldw	r2,-32280(gp)
 8219ed4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 8219ed8:	d0a07a17 	ldw	r2,-32280(gp)
 8219edc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8219ee0:	d0a07a17 	ldw	r2,-32280(gp)
 8219ee4:	10000815 	stw	zero,32(r2)
 8219ee8:	e0bff717 	ldw	r2,-36(fp)
 8219eec:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219ef0:	e0bffa17 	ldw	r2,-24(fp)
 8219ef4:	1001703a 	wrctl	status,r2
 8219ef8:	00000106 	br	8219f00 <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 8219efc:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 8219f00:	e037883a 	mov	sp,fp
 8219f04:	dfc00117 	ldw	ra,4(sp)
 8219f08:	df000017 	ldw	fp,0(sp)
 8219f0c:	dec00204 	addi	sp,sp,8
 8219f10:	f800283a 	ret

08219f14 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219f14:	defff604 	addi	sp,sp,-40
 8219f18:	dfc00915 	stw	ra,36(sp)
 8219f1c:	df000815 	stw	fp,32(sp)
 8219f20:	df000804 	addi	fp,sp,32
 8219f24:	e13ffd15 	stw	r4,-12(fp)
 8219f28:	2805883a 	mov	r2,r5
 8219f2c:	e1bfff15 	stw	r6,-4(fp)
 8219f30:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219f34:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8219f38:	e0bfff17 	ldw	r2,-4(fp)
 8219f3c:	1000021e 	bne	r2,zero,8219f48 <OSSemPendAbort+0x34>
        return (0);
 8219f40:	0005883a 	mov	r2,zero
 8219f44:	00004906 	br	821a06c <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219f48:	e0bffd17 	ldw	r2,-12(fp)
 8219f4c:	1000051e 	bne	r2,zero,8219f64 <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219f50:	e0bfff17 	ldw	r2,-4(fp)
 8219f54:	00c00104 	movi	r3,4
 8219f58:	10c00005 	stb	r3,0(r2)
        return (0);
 8219f5c:	0005883a 	mov	r2,zero
 8219f60:	00004206 	br	821a06c <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219f64:	e0bffd17 	ldw	r2,-12(fp)
 8219f68:	10800003 	ldbu	r2,0(r2)
 8219f6c:	10803fcc 	andi	r2,r2,255
 8219f70:	108000e0 	cmpeqi	r2,r2,3
 8219f74:	1000051e 	bne	r2,zero,8219f8c <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219f78:	e0bfff17 	ldw	r2,-4(fp)
 8219f7c:	00c00044 	movi	r3,1
 8219f80:	10c00005 	stb	r3,0(r2)
        return (0);
 8219f84:	0005883a 	mov	r2,zero
 8219f88:	00003806 	br	821a06c <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219f8c:	0005303a 	rdctl	r2,status
 8219f90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219f94:	e0fffc17 	ldw	r3,-16(fp)
 8219f98:	00bfff84 	movi	r2,-2
 8219f9c:	1884703a 	and	r2,r3,r2
 8219fa0:	1001703a 	wrctl	status,r2
  
  return context;
 8219fa4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219fa8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 8219fac:	e0bffd17 	ldw	r2,-12(fp)
 8219fb0:	10800283 	ldbu	r2,10(r2)
 8219fb4:	10803fcc 	andi	r2,r2,255
 8219fb8:	10002526 	beq	r2,zero,821a050 <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
 8219fbc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 8219fc0:	e0bffe03 	ldbu	r2,-8(fp)
 8219fc4:	10800060 	cmpeqi	r2,r2,1
 8219fc8:	10000e26 	beq	r2,zero,821a004 <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 8219fcc:	00000806 	br	8219ff0 <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 8219fd0:	01c00084 	movi	r7,2
 8219fd4:	01800044 	movi	r6,1
 8219fd8:	000b883a 	mov	r5,zero
 8219fdc:	e13ffd17 	ldw	r4,-12(fp)
 8219fe0:	821570c0 	call	821570c <OS_EventTaskRdy>
                     nbr_tasks++;
 8219fe4:	e0bff803 	ldbu	r2,-32(fp)
 8219fe8:	10800044 	addi	r2,r2,1
 8219fec:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 8219ff0:	e0bffd17 	ldw	r2,-12(fp)
 8219ff4:	10800283 	ldbu	r2,10(r2)
 8219ff8:	10803fcc 	andi	r2,r2,255
 8219ffc:	103ff41e 	bne	r2,zero,8219fd0 <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 821a000:	00000906 	br	821a028 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a004:	01c00084 	movi	r7,2
 821a008:	01800044 	movi	r6,1
 821a00c:	000b883a 	mov	r5,zero
 821a010:	e13ffd17 	ldw	r4,-12(fp)
 821a014:	821570c0 	call	821570c <OS_EventTaskRdy>
                 nbr_tasks++;
 821a018:	e0bff803 	ldbu	r2,-32(fp)
 821a01c:	10800044 	addi	r2,r2,1
 821a020:	e0bff805 	stb	r2,-32(fp)
                 break;
 821a024:	0001883a 	nop
 821a028:	e0bff917 	ldw	r2,-28(fp)
 821a02c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a030:	e0bffa17 	ldw	r2,-24(fp)
 821a034:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a038:	82161580 	call	8216158 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821a03c:	e0bfff17 	ldw	r2,-4(fp)
 821a040:	00c00384 	movi	r3,14
 821a044:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 821a048:	e0bff803 	ldbu	r2,-32(fp)
 821a04c:	00000706 	br	821a06c <OSSemPendAbort+0x158>
 821a050:	e0bff917 	ldw	r2,-28(fp)
 821a054:	e0bffb15 	stw	r2,-20(fp)
 821a058:	e0bffb17 	ldw	r2,-20(fp)
 821a05c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821a060:	e0bfff17 	ldw	r2,-4(fp)
 821a064:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 821a068:	0005883a 	mov	r2,zero
}
 821a06c:	e037883a 	mov	sp,fp
 821a070:	dfc00117 	ldw	ra,4(sp)
 821a074:	df000017 	ldw	fp,0(sp)
 821a078:	dec00204 	addi	sp,sp,8
 821a07c:	f800283a 	ret

0821a080 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 821a080:	defff804 	addi	sp,sp,-32
 821a084:	dfc00715 	stw	ra,28(sp)
 821a088:	df000615 	stw	fp,24(sp)
 821a08c:	df000604 	addi	fp,sp,24
 821a090:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a094:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a098:	e0bfff17 	ldw	r2,-4(fp)
 821a09c:	1000021e 	bne	r2,zero,821a0a8 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a0a0:	00800104 	movi	r2,4
 821a0a4:	00003506 	br	821a17c <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a0a8:	e0bfff17 	ldw	r2,-4(fp)
 821a0ac:	10800003 	ldbu	r2,0(r2)
 821a0b0:	10803fcc 	andi	r2,r2,255
 821a0b4:	108000e0 	cmpeqi	r2,r2,3
 821a0b8:	1000021e 	bne	r2,zero,821a0c4 <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 821a0bc:	00800044 	movi	r2,1
 821a0c0:	00002e06 	br	821a17c <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a0c4:	0005303a 	rdctl	r2,status
 821a0c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a0cc:	e0fffe17 	ldw	r3,-8(fp)
 821a0d0:	00bfff84 	movi	r2,-2
 821a0d4:	1884703a 	and	r2,r3,r2
 821a0d8:	1001703a 	wrctl	status,r2
  
  return context;
 821a0dc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821a0e0:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 821a0e4:	e0bfff17 	ldw	r2,-4(fp)
 821a0e8:	10800283 	ldbu	r2,10(r2)
 821a0ec:	10803fcc 	andi	r2,r2,255
 821a0f0:	10000c26 	beq	r2,zero,821a124 <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a0f4:	000f883a 	mov	r7,zero
 821a0f8:	01800044 	movi	r6,1
 821a0fc:	000b883a 	mov	r5,zero
 821a100:	e13fff17 	ldw	r4,-4(fp)
 821a104:	821570c0 	call	821570c <OS_EventTaskRdy>
 821a108:	e0bffa17 	ldw	r2,-24(fp)
 821a10c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a110:	e0bffb17 	ldw	r2,-20(fp)
 821a114:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a118:	82161580 	call	8216158 <OS_Sched>
        return (OS_ERR_NONE);
 821a11c:	0005883a 	mov	r2,zero
 821a120:	00001606 	br	821a17c <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 821a124:	e0bfff17 	ldw	r2,-4(fp)
 821a128:	1080020b 	ldhu	r2,8(r2)
 821a12c:	10ffffcc 	andi	r3,r2,65535
 821a130:	00bfffd4 	movui	r2,65535
 821a134:	18800c26 	beq	r3,r2,821a168 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 821a138:	e0bfff17 	ldw	r2,-4(fp)
 821a13c:	1080020b 	ldhu	r2,8(r2)
 821a140:	10800044 	addi	r2,r2,1
 821a144:	1007883a 	mov	r3,r2
 821a148:	e0bfff17 	ldw	r2,-4(fp)
 821a14c:	10c0020d 	sth	r3,8(r2)
 821a150:	e0bffa17 	ldw	r2,-24(fp)
 821a154:	e0bffc15 	stw	r2,-16(fp)
 821a158:	e0bffc17 	ldw	r2,-16(fp)
 821a15c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 821a160:	0005883a 	mov	r2,zero
 821a164:	00000506 	br	821a17c <OSSemPost+0xfc>
 821a168:	e0bffa17 	ldw	r2,-24(fp)
 821a16c:	e0bffd15 	stw	r2,-12(fp)
 821a170:	e0bffd17 	ldw	r2,-12(fp)
 821a174:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 821a178:	00800c84 	movi	r2,50
}
 821a17c:	e037883a 	mov	sp,fp
 821a180:	dfc00117 	ldw	ra,4(sp)
 821a184:	df000017 	ldw	fp,0(sp)
 821a188:	dec00204 	addi	sp,sp,8
 821a18c:	f800283a 	ret

0821a190 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 821a190:	defff704 	addi	sp,sp,-36
 821a194:	df000815 	stw	fp,32(sp)
 821a198:	df000804 	addi	fp,sp,32
 821a19c:	e13ffe15 	stw	r4,-8(fp)
 821a1a0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821a1a4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 821a1a8:	e0bffe17 	ldw	r2,-8(fp)
 821a1ac:	1000021e 	bne	r2,zero,821a1b8 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a1b0:	00800104 	movi	r2,4
 821a1b4:	00003606 	br	821a290 <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 821a1b8:	e0bfff17 	ldw	r2,-4(fp)
 821a1bc:	1000021e 	bne	r2,zero,821a1c8 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 821a1c0:	00800244 	movi	r2,9
 821a1c4:	00003206 	br	821a290 <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 821a1c8:	e0bffe17 	ldw	r2,-8(fp)
 821a1cc:	10800003 	ldbu	r2,0(r2)
 821a1d0:	10803fcc 	andi	r2,r2,255
 821a1d4:	108000e0 	cmpeqi	r2,r2,3
 821a1d8:	1000021e 	bne	r2,zero,821a1e4 <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 821a1dc:	00800044 	movi	r2,1
 821a1e0:	00002b06 	br	821a290 <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a1e4:	0005303a 	rdctl	r2,status
 821a1e8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a1ec:	e0fffd17 	ldw	r3,-12(fp)
 821a1f0:	00bfff84 	movi	r2,-2
 821a1f4:	1884703a 	and	r2,r3,r2
 821a1f8:	1001703a 	wrctl	status,r2
  
  return context;
 821a1fc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821a200:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 821a204:	e0bffe17 	ldw	r2,-8(fp)
 821a208:	10c00283 	ldbu	r3,10(r2)
 821a20c:	e0bfff17 	ldw	r2,-4(fp)
 821a210:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 821a214:	e0bffe17 	ldw	r2,-8(fp)
 821a218:	108002c4 	addi	r2,r2,11
 821a21c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 821a220:	e0bfff17 	ldw	r2,-4(fp)
 821a224:	10800084 	addi	r2,r2,2
 821a228:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a22c:	e03ffa05 	stb	zero,-24(fp)
 821a230:	00000b06 	br	821a260 <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
 821a234:	e0bff917 	ldw	r2,-28(fp)
 821a238:	10c00044 	addi	r3,r2,1
 821a23c:	e0fff915 	stw	r3,-28(fp)
 821a240:	e0fff817 	ldw	r3,-32(fp)
 821a244:	19000044 	addi	r4,r3,1
 821a248:	e13ff815 	stw	r4,-32(fp)
 821a24c:	18c00003 	ldbu	r3,0(r3)
 821a250:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a254:	e0bffa03 	ldbu	r2,-24(fp)
 821a258:	10800044 	addi	r2,r2,1
 821a25c:	e0bffa05 	stb	r2,-24(fp)
 821a260:	e0bffa03 	ldbu	r2,-24(fp)
 821a264:	108000f0 	cmpltui	r2,r2,3
 821a268:	103ff21e 	bne	r2,zero,821a234 <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 821a26c:	e0bffe17 	ldw	r2,-8(fp)
 821a270:	10c0020b 	ldhu	r3,8(r2)
 821a274:	e0bfff17 	ldw	r2,-4(fp)
 821a278:	10c0000d 	sth	r3,0(r2)
 821a27c:	e0bffb17 	ldw	r2,-20(fp)
 821a280:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a284:	e0bffc17 	ldw	r2,-16(fp)
 821a288:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821a28c:	0005883a 	mov	r2,zero
}
 821a290:	e037883a 	mov	sp,fp
 821a294:	df000017 	ldw	fp,0(sp)
 821a298:	dec00104 	addi	sp,sp,4
 821a29c:	f800283a 	ret

0821a2a0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 821a2a0:	defff904 	addi	sp,sp,-28
 821a2a4:	df000615 	stw	fp,24(sp)
 821a2a8:	df000604 	addi	fp,sp,24
 821a2ac:	e13ffd15 	stw	r4,-12(fp)
 821a2b0:	2805883a 	mov	r2,r5
 821a2b4:	e1bfff15 	stw	r6,-4(fp)
 821a2b8:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a2bc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a2c0:	e0bfff17 	ldw	r2,-4(fp)
 821a2c4:	10003126 	beq	r2,zero,821a38c <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a2c8:	e0bffd17 	ldw	r2,-12(fp)
 821a2cc:	1000041e 	bne	r2,zero,821a2e0 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 821a2d0:	e0bfff17 	ldw	r2,-4(fp)
 821a2d4:	00c00104 	movi	r3,4
 821a2d8:	10c00005 	stb	r3,0(r2)
        return;
 821a2dc:	00002c06 	br	821a390 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a2e0:	e0bffd17 	ldw	r2,-12(fp)
 821a2e4:	10800003 	ldbu	r2,0(r2)
 821a2e8:	10803fcc 	andi	r2,r2,255
 821a2ec:	108000e0 	cmpeqi	r2,r2,3
 821a2f0:	1000041e 	bne	r2,zero,821a304 <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 821a2f4:	e0bfff17 	ldw	r2,-4(fp)
 821a2f8:	00c00044 	movi	r3,1
 821a2fc:	10c00005 	stb	r3,0(r2)
        return;
 821a300:	00002306 	br	821a390 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a304:	0005303a 	rdctl	r2,status
 821a308:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a30c:	e0fffc17 	ldw	r3,-16(fp)
 821a310:	00bfff84 	movi	r2,-2
 821a314:	1884703a 	and	r2,r3,r2
 821a318:	1001703a 	wrctl	status,r2
  
  return context;
 821a31c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a320:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 821a324:	e0bfff17 	ldw	r2,-4(fp)
 821a328:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 821a32c:	e0bffd17 	ldw	r2,-12(fp)
 821a330:	1080020b 	ldhu	r2,8(r2)
 821a334:	10bfffcc 	andi	r2,r2,65535
 821a338:	10000426 	beq	r2,zero,821a34c <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 821a33c:	e0bffd17 	ldw	r2,-12(fp)
 821a340:	e0fffe0b 	ldhu	r3,-8(fp)
 821a344:	10c0020d 	sth	r3,8(r2)
 821a348:	00000b06 	br	821a378 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 821a34c:	e0bffd17 	ldw	r2,-12(fp)
 821a350:	10800283 	ldbu	r2,10(r2)
 821a354:	10803fcc 	andi	r2,r2,255
 821a358:	1000041e 	bne	r2,zero,821a36c <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 821a35c:	e0bffd17 	ldw	r2,-12(fp)
 821a360:	e0fffe0b 	ldhu	r3,-8(fp)
 821a364:	10c0020d 	sth	r3,8(r2)
 821a368:	00000306 	br	821a378 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 821a36c:	e0bfff17 	ldw	r2,-4(fp)
 821a370:	00c01244 	movi	r3,73
 821a374:	10c00005 	stb	r3,0(r2)
 821a378:	e0bffa17 	ldw	r2,-24(fp)
 821a37c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a380:	e0bffb17 	ldw	r2,-20(fp)
 821a384:	1001703a 	wrctl	status,r2
 821a388:	00000106 	br	821a390 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a38c:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 821a390:	e037883a 	mov	sp,fp
 821a394:	df000017 	ldw	fp,0(sp)
 821a398:	dec00104 	addi	sp,sp,4
 821a39c:	f800283a 	ret

0821a3a0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 821a3a0:	defff104 	addi	sp,sp,-60
 821a3a4:	dfc00e15 	stw	ra,56(sp)
 821a3a8:	df000d15 	stw	fp,52(sp)
 821a3ac:	df000d04 	addi	fp,sp,52
 821a3b0:	2007883a 	mov	r3,r4
 821a3b4:	2805883a 	mov	r2,r5
 821a3b8:	e0fffe05 	stb	r3,-8(fp)
 821a3bc:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 821a3c0:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 821a3c4:	e0bffe03 	ldbu	r2,-8(fp)
 821a3c8:	10800530 	cmpltui	r2,r2,20
 821a3cc:	1000051e 	bne	r2,zero,821a3e4 <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 821a3d0:	e0bffe03 	ldbu	r2,-8(fp)
 821a3d4:	10803fe0 	cmpeqi	r2,r2,255
 821a3d8:	1000021e 	bne	r2,zero,821a3e4 <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 821a3dc:	00800a84 	movi	r2,42
 821a3e0:	00012606 	br	821a87c <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 821a3e4:	e0bfff03 	ldbu	r2,-4(fp)
 821a3e8:	10800530 	cmpltui	r2,r2,20
 821a3ec:	1000021e 	bne	r2,zero,821a3f8 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 821a3f0:	00800a84 	movi	r2,42
 821a3f4:	00012106 	br	821a87c <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a3f8:	0005303a 	rdctl	r2,status
 821a3fc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a400:	e0fffd17 	ldw	r3,-12(fp)
 821a404:	00bfff84 	movi	r2,-2
 821a408:	1884703a 	and	r2,r3,r2
 821a40c:	1001703a 	wrctl	status,r2
  
  return context;
 821a410:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821a414:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 821a418:	e0ffff03 	ldbu	r3,-4(fp)
 821a41c:	008209b4 	movhi	r2,2086
 821a420:	10b54004 	addi	r2,r2,-11008
 821a424:	18c7883a 	add	r3,r3,r3
 821a428:	18c7883a 	add	r3,r3,r3
 821a42c:	10c5883a 	add	r2,r2,r3
 821a430:	10800017 	ldw	r2,0(r2)
 821a434:	10000626 	beq	r2,zero,821a450 <OSTaskChangePrio+0xb0>
 821a438:	e0bff517 	ldw	r2,-44(fp)
 821a43c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a440:	e0bff617 	ldw	r2,-40(fp)
 821a444:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 821a448:	00800a04 	movi	r2,40
 821a44c:	00010b06 	br	821a87c <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 821a450:	e0bffe03 	ldbu	r2,-8(fp)
 821a454:	10803fd8 	cmpnei	r2,r2,255
 821a458:	1000031e 	bne	r2,zero,821a468 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 821a45c:	d0a07a17 	ldw	r2,-32280(gp)
 821a460:	10800c83 	ldbu	r2,50(r2)
 821a464:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 821a468:	e0fffe03 	ldbu	r3,-8(fp)
 821a46c:	008209b4 	movhi	r2,2086
 821a470:	10b54004 	addi	r2,r2,-11008
 821a474:	18c7883a 	add	r3,r3,r3
 821a478:	18c7883a 	add	r3,r3,r3
 821a47c:	10c5883a 	add	r2,r2,r3
 821a480:	10800017 	ldw	r2,0(r2)
 821a484:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 821a488:	e0bff817 	ldw	r2,-32(fp)
 821a48c:	1000061e 	bne	r2,zero,821a4a8 <OSTaskChangePrio+0x108>
 821a490:	e0bff517 	ldw	r2,-44(fp)
 821a494:	e0bff715 	stw	r2,-36(fp)
 821a498:	e0bff717 	ldw	r2,-36(fp)
 821a49c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 821a4a0:	00800a44 	movi	r2,41
 821a4a4:	0000f506 	br	821a87c <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 821a4a8:	e0bff817 	ldw	r2,-32(fp)
 821a4ac:	10800058 	cmpnei	r2,r2,1
 821a4b0:	1000061e 	bne	r2,zero,821a4cc <OSTaskChangePrio+0x12c>
 821a4b4:	e0bff517 	ldw	r2,-44(fp)
 821a4b8:	e0bff915 	stw	r2,-28(fp)
 821a4bc:	e0bff917 	ldw	r2,-28(fp)
 821a4c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 821a4c4:	008010c4 	movi	r2,67
 821a4c8:	0000ec06 	br	821a87c <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 821a4cc:	e0bfff03 	ldbu	r2,-4(fp)
 821a4d0:	1004d0fa 	srli	r2,r2,3
 821a4d4:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 821a4d8:	e0bfff03 	ldbu	r2,-4(fp)
 821a4dc:	108001cc 	andi	r2,r2,7
 821a4e0:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
 821a4e4:	e0bffb03 	ldbu	r2,-20(fp)
 821a4e8:	00c00044 	movi	r3,1
 821a4ec:	1884983a 	sll	r2,r3,r2
 821a4f0:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
 821a4f4:	e0bffb43 	ldbu	r2,-19(fp)
 821a4f8:	00c00044 	movi	r3,1
 821a4fc:	1884983a 	sll	r2,r3,r2
 821a500:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 821a504:	e0fffe03 	ldbu	r3,-8(fp)
 821a508:	008209b4 	movhi	r2,2086
 821a50c:	10b54004 	addi	r2,r2,-11008
 821a510:	18c7883a 	add	r3,r3,r3
 821a514:	18c7883a 	add	r3,r3,r3
 821a518:	10c5883a 	add	r2,r2,r3
 821a51c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 821a520:	e0ffff03 	ldbu	r3,-4(fp)
 821a524:	008209b4 	movhi	r2,2086
 821a528:	10b54004 	addi	r2,r2,-11008
 821a52c:	18c7883a 	add	r3,r3,r3
 821a530:	18c7883a 	add	r3,r3,r3
 821a534:	10c5883a 	add	r2,r2,r3
 821a538:	e0fff817 	ldw	r3,-32(fp)
 821a53c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 821a540:	e0bff817 	ldw	r2,-32(fp)
 821a544:	10800d03 	ldbu	r2,52(r2)
 821a548:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
 821a54c:	e0bff817 	ldw	r2,-32(fp)
 821a550:	10800d83 	ldbu	r2,54(r2)
 821a554:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 821a558:	e0bff817 	ldw	r2,-32(fp)
 821a55c:	10800d43 	ldbu	r2,53(r2)
 821a560:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 821a564:	e0fffc03 	ldbu	r3,-16(fp)
 821a568:	d0a07744 	addi	r2,gp,-32291
 821a56c:	1885883a 	add	r2,r3,r2
 821a570:	10c00003 	ldbu	r3,0(r2)
 821a574:	e0bffc83 	ldbu	r2,-14(fp)
 821a578:	1884703a 	and	r2,r3,r2
 821a57c:	10803fcc 	andi	r2,r2,255
 821a580:	10002826 	beq	r2,zero,821a624 <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
 821a584:	e0fffc03 	ldbu	r3,-16(fp)
 821a588:	e13ffc03 	ldbu	r4,-16(fp)
 821a58c:	d0a07744 	addi	r2,gp,-32291
 821a590:	2085883a 	add	r2,r4,r2
 821a594:	10800003 	ldbu	r2,0(r2)
 821a598:	1009883a 	mov	r4,r2
 821a59c:	e0bffc83 	ldbu	r2,-14(fp)
 821a5a0:	0084303a 	nor	r2,zero,r2
 821a5a4:	2084703a 	and	r2,r4,r2
 821a5a8:	1009883a 	mov	r4,r2
 821a5ac:	d0a07744 	addi	r2,gp,-32291
 821a5b0:	1885883a 	add	r2,r3,r2
 821a5b4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 821a5b8:	e0fffc03 	ldbu	r3,-16(fp)
 821a5bc:	d0a07744 	addi	r2,gp,-32291
 821a5c0:	1885883a 	add	r2,r3,r2
 821a5c4:	10800003 	ldbu	r2,0(r2)
 821a5c8:	10803fcc 	andi	r2,r2,255
 821a5cc:	1000061e 	bne	r2,zero,821a5e8 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
 821a5d0:	e0bffc43 	ldbu	r2,-15(fp)
 821a5d4:	0084303a 	nor	r2,zero,r2
 821a5d8:	1007883a 	mov	r3,r2
 821a5dc:	d0a07703 	ldbu	r2,-32292(gp)
 821a5e0:	1884703a 	and	r2,r3,r2
 821a5e4:	d0a07705 	stb	r2,-32292(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 821a5e8:	d0e07703 	ldbu	r3,-32292(gp)
 821a5ec:	e0bffb83 	ldbu	r2,-18(fp)
 821a5f0:	1884b03a 	or	r2,r3,r2
 821a5f4:	d0a07705 	stb	r2,-32292(gp)
         OSRdyTbl[y_new] |= bitx_new;
 821a5f8:	e0fffb03 	ldbu	r3,-20(fp)
 821a5fc:	e13ffb03 	ldbu	r4,-20(fp)
 821a600:	d0a07744 	addi	r2,gp,-32291
 821a604:	2085883a 	add	r2,r4,r2
 821a608:	11000003 	ldbu	r4,0(r2)
 821a60c:	e0bffbc3 	ldbu	r2,-17(fp)
 821a610:	2084b03a 	or	r2,r4,r2
 821a614:	1009883a 	mov	r4,r2
 821a618:	d0a07744 	addi	r2,gp,-32291
 821a61c:	1885883a 	add	r2,r3,r2
 821a620:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 821a624:	e0bff817 	ldw	r2,-32(fp)
 821a628:	10800717 	ldw	r2,28(r2)
 821a62c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 821a630:	e0bff317 	ldw	r2,-52(fp)
 821a634:	10003326 	beq	r2,zero,821a704 <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 821a638:	e0bffc03 	ldbu	r2,-16(fp)
 821a63c:	e0fffc03 	ldbu	r3,-16(fp)
 821a640:	e13ff317 	ldw	r4,-52(fp)
 821a644:	20c7883a 	add	r3,r4,r3
 821a648:	18c002c4 	addi	r3,r3,11
 821a64c:	18c00003 	ldbu	r3,0(r3)
 821a650:	1809883a 	mov	r4,r3
 821a654:	e0fffc83 	ldbu	r3,-14(fp)
 821a658:	00c6303a 	nor	r3,zero,r3
 821a65c:	20c6703a 	and	r3,r4,r3
 821a660:	1809883a 	mov	r4,r3
 821a664:	e0fff317 	ldw	r3,-52(fp)
 821a668:	1885883a 	add	r2,r3,r2
 821a66c:	108002c4 	addi	r2,r2,11
 821a670:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 821a674:	e0bffc03 	ldbu	r2,-16(fp)
 821a678:	e0fff317 	ldw	r3,-52(fp)
 821a67c:	1885883a 	add	r2,r3,r2
 821a680:	108002c4 	addi	r2,r2,11
 821a684:	10800003 	ldbu	r2,0(r2)
 821a688:	10803fcc 	andi	r2,r2,255
 821a68c:	1000091e 	bne	r2,zero,821a6b4 <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
 821a690:	e0bff317 	ldw	r2,-52(fp)
 821a694:	10800283 	ldbu	r2,10(r2)
 821a698:	1007883a 	mov	r3,r2
 821a69c:	e0bffc43 	ldbu	r2,-15(fp)
 821a6a0:	0084303a 	nor	r2,zero,r2
 821a6a4:	1884703a 	and	r2,r3,r2
 821a6a8:	1007883a 	mov	r3,r2
 821a6ac:	e0bff317 	ldw	r2,-52(fp)
 821a6b0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 821a6b4:	e0bff317 	ldw	r2,-52(fp)
 821a6b8:	10c00283 	ldbu	r3,10(r2)
 821a6bc:	e0bffb83 	ldbu	r2,-18(fp)
 821a6c0:	1884b03a 	or	r2,r3,r2
 821a6c4:	1007883a 	mov	r3,r2
 821a6c8:	e0bff317 	ldw	r2,-52(fp)
 821a6cc:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 821a6d0:	e0bffb03 	ldbu	r2,-20(fp)
 821a6d4:	e0fffb03 	ldbu	r3,-20(fp)
 821a6d8:	e13ff317 	ldw	r4,-52(fp)
 821a6dc:	20c7883a 	add	r3,r4,r3
 821a6e0:	18c002c4 	addi	r3,r3,11
 821a6e4:	19000003 	ldbu	r4,0(r3)
 821a6e8:	e0fffbc3 	ldbu	r3,-17(fp)
 821a6ec:	20c6b03a 	or	r3,r4,r3
 821a6f0:	1809883a 	mov	r4,r3
 821a6f4:	e0fff317 	ldw	r3,-52(fp)
 821a6f8:	1885883a 	add	r2,r3,r2
 821a6fc:	108002c4 	addi	r2,r2,11
 821a700:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 821a704:	e0bff817 	ldw	r2,-32(fp)
 821a708:	10800817 	ldw	r2,32(r2)
 821a70c:	10004226 	beq	r2,zero,821a818 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
 821a710:	e0bff817 	ldw	r2,-32(fp)
 821a714:	10800817 	ldw	r2,32(r2)
 821a718:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 821a71c:	e0bff417 	ldw	r2,-48(fp)
 821a720:	10800017 	ldw	r2,0(r2)
 821a724:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 821a728:	00003906 	br	821a810 <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 821a72c:	e0bffc03 	ldbu	r2,-16(fp)
 821a730:	e0fffc03 	ldbu	r3,-16(fp)
 821a734:	e13ff317 	ldw	r4,-52(fp)
 821a738:	20c7883a 	add	r3,r4,r3
 821a73c:	18c002c4 	addi	r3,r3,11
 821a740:	18c00003 	ldbu	r3,0(r3)
 821a744:	1809883a 	mov	r4,r3
 821a748:	e0fffc83 	ldbu	r3,-14(fp)
 821a74c:	00c6303a 	nor	r3,zero,r3
 821a750:	20c6703a 	and	r3,r4,r3
 821a754:	1809883a 	mov	r4,r3
 821a758:	e0fff317 	ldw	r3,-52(fp)
 821a75c:	1885883a 	add	r2,r3,r2
 821a760:	108002c4 	addi	r2,r2,11
 821a764:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 821a768:	e0bffc03 	ldbu	r2,-16(fp)
 821a76c:	e0fff317 	ldw	r3,-52(fp)
 821a770:	1885883a 	add	r2,r3,r2
 821a774:	108002c4 	addi	r2,r2,11
 821a778:	10800003 	ldbu	r2,0(r2)
 821a77c:	10803fcc 	andi	r2,r2,255
 821a780:	1000091e 	bne	r2,zero,821a7a8 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
 821a784:	e0bff317 	ldw	r2,-52(fp)
 821a788:	10800283 	ldbu	r2,10(r2)
 821a78c:	1007883a 	mov	r3,r2
 821a790:	e0bffc43 	ldbu	r2,-15(fp)
 821a794:	0084303a 	nor	r2,zero,r2
 821a798:	1884703a 	and	r2,r3,r2
 821a79c:	1007883a 	mov	r3,r2
 821a7a0:	e0bff317 	ldw	r2,-52(fp)
 821a7a4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 821a7a8:	e0bff317 	ldw	r2,-52(fp)
 821a7ac:	10c00283 	ldbu	r3,10(r2)
 821a7b0:	e0bffb83 	ldbu	r2,-18(fp)
 821a7b4:	1884b03a 	or	r2,r3,r2
 821a7b8:	1007883a 	mov	r3,r2
 821a7bc:	e0bff317 	ldw	r2,-52(fp)
 821a7c0:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 821a7c4:	e0bffb03 	ldbu	r2,-20(fp)
 821a7c8:	e0fffb03 	ldbu	r3,-20(fp)
 821a7cc:	e13ff317 	ldw	r4,-52(fp)
 821a7d0:	20c7883a 	add	r3,r4,r3
 821a7d4:	18c002c4 	addi	r3,r3,11
 821a7d8:	19000003 	ldbu	r4,0(r3)
 821a7dc:	e0fffbc3 	ldbu	r3,-17(fp)
 821a7e0:	20c6b03a 	or	r3,r4,r3
 821a7e4:	1809883a 	mov	r4,r3
 821a7e8:	e0fff317 	ldw	r3,-52(fp)
 821a7ec:	1885883a 	add	r2,r3,r2
 821a7f0:	108002c4 	addi	r2,r2,11
 821a7f4:	11000005 	stb	r4,0(r2)
            pevents++;
 821a7f8:	e0bff417 	ldw	r2,-48(fp)
 821a7fc:	10800104 	addi	r2,r2,4
 821a800:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 821a804:	e0bff417 	ldw	r2,-48(fp)
 821a808:	10800017 	ldw	r2,0(r2)
 821a80c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 821a810:	e0bff317 	ldw	r2,-52(fp)
 821a814:	103fc51e 	bne	r2,zero,821a72c <OSTaskChangePrio+0x38c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 821a818:	e0bff817 	ldw	r2,-32(fp)
 821a81c:	e0ffff03 	ldbu	r3,-4(fp)
 821a820:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 821a824:	e0bff817 	ldw	r2,-32(fp)
 821a828:	e0fffb03 	ldbu	r3,-20(fp)
 821a82c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 821a830:	e0bff817 	ldw	r2,-32(fp)
 821a834:	e0fffb43 	ldbu	r3,-19(fp)
 821a838:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 821a83c:	e0bff817 	ldw	r2,-32(fp)
 821a840:	e0fffb83 	ldbu	r3,-18(fp)
 821a844:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 821a848:	e0bff817 	ldw	r2,-32(fp)
 821a84c:	e0fffbc3 	ldbu	r3,-17(fp)
 821a850:	10c00d45 	stb	r3,53(r2)
 821a854:	e0bff517 	ldw	r2,-44(fp)
 821a858:	e0bffa15 	stw	r2,-24(fp)
 821a85c:	e0bffa17 	ldw	r2,-24(fp)
 821a860:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821a864:	d0a06b43 	ldbu	r2,-32339(gp)
 821a868:	10803fcc 	andi	r2,r2,255
 821a86c:	10800058 	cmpnei	r2,r2,1
 821a870:	1000011e 	bne	r2,zero,821a878 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
 821a874:	82161580 	call	8216158 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821a878:	0005883a 	mov	r2,zero
}
 821a87c:	e037883a 	mov	sp,fp
 821a880:	dfc00117 	ldw	ra,4(sp)
 821a884:	df000017 	ldw	fp,0(sp)
 821a888:	dec00204 	addi	sp,sp,8
 821a88c:	f800283a 	ret

0821a890 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 821a890:	deffee04 	addi	sp,sp,-72
 821a894:	dfc01115 	stw	ra,68(sp)
 821a898:	df001015 	stw	fp,64(sp)
 821a89c:	df001004 	addi	fp,sp,64
 821a8a0:	e13ffc15 	stw	r4,-16(fp)
 821a8a4:	e17ffd15 	stw	r5,-12(fp)
 821a8a8:	e1bffe15 	stw	r6,-8(fp)
 821a8ac:	3805883a 	mov	r2,r7
 821a8b0:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821a8b4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821a8b8:	e0bfff03 	ldbu	r2,-4(fp)
 821a8bc:	10800570 	cmpltui	r2,r2,21
 821a8c0:	1000021e 	bne	r2,zero,821a8cc <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 821a8c4:	00800a84 	movi	r2,42
 821a8c8:	00005706 	br	821aa28 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a8cc:	0005303a 	rdctl	r2,status
 821a8d0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a8d4:	e0fffb17 	ldw	r3,-20(fp)
 821a8d8:	00bfff84 	movi	r2,-2
 821a8dc:	1884703a 	and	r2,r3,r2
 821a8e0:	1001703a 	wrctl	status,r2
  
  return context;
 821a8e4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821a8e8:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821a8ec:	d0a07903 	ldbu	r2,-32284(gp)
 821a8f0:	10803fcc 	andi	r2,r2,255
 821a8f4:	10000626 	beq	r2,zero,821a910 <OSTaskCreate+0x80>
 821a8f8:	e0bff317 	ldw	r2,-52(fp)
 821a8fc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a900:	e0bff417 	ldw	r2,-48(fp)
 821a904:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821a908:	00800f04 	movi	r2,60
 821a90c:	00004606 	br	821aa28 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821a910:	e0ffff03 	ldbu	r3,-4(fp)
 821a914:	008209b4 	movhi	r2,2086
 821a918:	10b54004 	addi	r2,r2,-11008
 821a91c:	18c7883a 	add	r3,r3,r3
 821a920:	18c7883a 	add	r3,r3,r3
 821a924:	10c5883a 	add	r2,r2,r3
 821a928:	10800017 	ldw	r2,0(r2)
 821a92c:	1000391e 	bne	r2,zero,821aa14 <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821a930:	e0ffff03 	ldbu	r3,-4(fp)
 821a934:	008209b4 	movhi	r2,2086
 821a938:	10b54004 	addi	r2,r2,-11008
 821a93c:	18c7883a 	add	r3,r3,r3
 821a940:	18c7883a 	add	r3,r3,r3
 821a944:	10c5883a 	add	r2,r2,r3
 821a948:	00c00044 	movi	r3,1
 821a94c:	10c00015 	stw	r3,0(r2)
 821a950:	e0bff317 	ldw	r2,-52(fp)
 821a954:	e0bff515 	stw	r2,-44(fp)
 821a958:	e0bff517 	ldw	r2,-44(fp)
 821a95c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 821a960:	000f883a 	mov	r7,zero
 821a964:	e1bffe17 	ldw	r6,-8(fp)
 821a968:	e17ffd17 	ldw	r5,-12(fp)
 821a96c:	e13ffc17 	ldw	r4,-16(fp)
 821a970:	823c9d80 	call	823c9d8 <OSTaskStkInit>
 821a974:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 821a978:	e0bfff03 	ldbu	r2,-4(fp)
 821a97c:	d8000215 	stw	zero,8(sp)
 821a980:	d8000115 	stw	zero,4(sp)
 821a984:	d8000015 	stw	zero,0(sp)
 821a988:	000f883a 	mov	r7,zero
 821a98c:	000d883a 	mov	r6,zero
 821a990:	e17ff717 	ldw	r5,-36(fp)
 821a994:	1009883a 	mov	r4,r2
 821a998:	82165700 	call	8216570 <OS_TCBInit>
 821a99c:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
 821a9a0:	e0bff803 	ldbu	r2,-32(fp)
 821a9a4:	1000061e 	bne	r2,zero,821a9c0 <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 821a9a8:	d0a06b43 	ldbu	r2,-32339(gp)
 821a9ac:	10803fcc 	andi	r2,r2,255
 821a9b0:	10800058 	cmpnei	r2,r2,1
 821a9b4:	1000151e 	bne	r2,zero,821aa0c <OSTaskCreate+0x17c>
                OS_Sched();
 821a9b8:	82161580 	call	8216158 <OS_Sched>
 821a9bc:	00001306 	br	821aa0c <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a9c0:	0005303a 	rdctl	r2,status
 821a9c4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a9c8:	e0fffa17 	ldw	r3,-24(fp)
 821a9cc:	00bfff84 	movi	r2,-2
 821a9d0:	1884703a 	and	r2,r3,r2
 821a9d4:	1001703a 	wrctl	status,r2
  
  return context;
 821a9d8:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821a9dc:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 821a9e0:	e0ffff03 	ldbu	r3,-4(fp)
 821a9e4:	008209b4 	movhi	r2,2086
 821a9e8:	10b54004 	addi	r2,r2,-11008
 821a9ec:	18c7883a 	add	r3,r3,r3
 821a9f0:	18c7883a 	add	r3,r3,r3
 821a9f4:	10c5883a 	add	r2,r2,r3
 821a9f8:	10000015 	stw	zero,0(r2)
 821a9fc:	e0bff317 	ldw	r2,-52(fp)
 821aa00:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821aa04:	e0bff617 	ldw	r2,-40(fp)
 821aa08:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821aa0c:	e0bff803 	ldbu	r2,-32(fp)
 821aa10:	00000506 	br	821aa28 <OSTaskCreate+0x198>
 821aa14:	e0bff317 	ldw	r2,-52(fp)
 821aa18:	e0bff915 	stw	r2,-28(fp)
 821aa1c:	e0bff917 	ldw	r2,-28(fp)
 821aa20:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821aa24:	00800a04 	movi	r2,40
}
 821aa28:	e037883a 	mov	sp,fp
 821aa2c:	dfc00117 	ldw	ra,4(sp)
 821aa30:	df000017 	ldw	fp,0(sp)
 821aa34:	dec00204 	addi	sp,sp,8
 821aa38:	f800283a 	ret

0821aa3c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 821aa3c:	deffec04 	addi	sp,sp,-80
 821aa40:	dfc01315 	stw	ra,76(sp)
 821aa44:	df001215 	stw	fp,72(sp)
 821aa48:	df001204 	addi	fp,sp,72
 821aa4c:	e13ffa15 	stw	r4,-24(fp)
 821aa50:	e17ffb15 	stw	r5,-20(fp)
 821aa54:	e1bffc15 	stw	r6,-16(fp)
 821aa58:	3809883a 	mov	r4,r7
 821aa5c:	e0c00217 	ldw	r3,8(fp)
 821aa60:	e0800617 	ldw	r2,24(fp)
 821aa64:	e13ffd05 	stb	r4,-12(fp)
 821aa68:	e0fffe0d 	sth	r3,-8(fp)
 821aa6c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821aa70:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821aa74:	e0bffd03 	ldbu	r2,-12(fp)
 821aa78:	10800570 	cmpltui	r2,r2,21
 821aa7c:	1000021e 	bne	r2,zero,821aa88 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 821aa80:	00800a84 	movi	r2,42
 821aa84:	00006106 	br	821ac0c <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821aa88:	0005303a 	rdctl	r2,status
 821aa8c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821aa90:	e0fff917 	ldw	r3,-28(fp)
 821aa94:	00bfff84 	movi	r2,-2
 821aa98:	1884703a 	and	r2,r3,r2
 821aa9c:	1001703a 	wrctl	status,r2
  
  return context;
 821aaa0:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821aaa4:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821aaa8:	d0a07903 	ldbu	r2,-32284(gp)
 821aaac:	10803fcc 	andi	r2,r2,255
 821aab0:	10000626 	beq	r2,zero,821aacc <OSTaskCreateExt+0x90>
 821aab4:	e0bff117 	ldw	r2,-60(fp)
 821aab8:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821aabc:	e0bff217 	ldw	r2,-56(fp)
 821aac0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821aac4:	00800f04 	movi	r2,60
 821aac8:	00005006 	br	821ac0c <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821aacc:	e0fffd03 	ldbu	r3,-12(fp)
 821aad0:	008209b4 	movhi	r2,2086
 821aad4:	10b54004 	addi	r2,r2,-11008
 821aad8:	18c7883a 	add	r3,r3,r3
 821aadc:	18c7883a 	add	r3,r3,r3
 821aae0:	10c5883a 	add	r2,r2,r3
 821aae4:	10800017 	ldw	r2,0(r2)
 821aae8:	1000431e 	bne	r2,zero,821abf8 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821aaec:	e0fffd03 	ldbu	r3,-12(fp)
 821aaf0:	008209b4 	movhi	r2,2086
 821aaf4:	10b54004 	addi	r2,r2,-11008
 821aaf8:	18c7883a 	add	r3,r3,r3
 821aafc:	18c7883a 	add	r3,r3,r3
 821ab00:	10c5883a 	add	r2,r2,r3
 821ab04:	00c00044 	movi	r3,1
 821ab08:	10c00015 	stw	r3,0(r2)
 821ab0c:	e0bff117 	ldw	r2,-60(fp)
 821ab10:	e0bff315 	stw	r2,-52(fp)
 821ab14:	e0bff317 	ldw	r2,-52(fp)
 821ab18:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 821ab1c:	e0bfff0b 	ldhu	r2,-4(fp)
 821ab20:	100d883a 	mov	r6,r2
 821ab24:	e1400417 	ldw	r5,16(fp)
 821ab28:	e1000317 	ldw	r4,12(fp)
 821ab2c:	821ba9c0 	call	821ba9c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 821ab30:	e0bfff0b 	ldhu	r2,-4(fp)
 821ab34:	100f883a 	mov	r7,r2
 821ab38:	e1bffc17 	ldw	r6,-16(fp)
 821ab3c:	e17ffb17 	ldw	r5,-20(fp)
 821ab40:	e13ffa17 	ldw	r4,-24(fp)
 821ab44:	823c9d80 	call	823c9d8 <OSTaskStkInit>
 821ab48:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 821ab4c:	e0fffd03 	ldbu	r3,-12(fp)
 821ab50:	e13ffe0b 	ldhu	r4,-8(fp)
 821ab54:	e0bfff0b 	ldhu	r2,-4(fp)
 821ab58:	d8800215 	stw	r2,8(sp)
 821ab5c:	e0800517 	ldw	r2,20(fp)
 821ab60:	d8800115 	stw	r2,4(sp)
 821ab64:	e0800417 	ldw	r2,16(fp)
 821ab68:	d8800015 	stw	r2,0(sp)
 821ab6c:	200f883a 	mov	r7,r4
 821ab70:	e1800317 	ldw	r6,12(fp)
 821ab74:	e17ff517 	ldw	r5,-44(fp)
 821ab78:	1809883a 	mov	r4,r3
 821ab7c:	82165700 	call	8216570 <OS_TCBInit>
 821ab80:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
 821ab84:	e0bff603 	ldbu	r2,-40(fp)
 821ab88:	1000061e 	bne	r2,zero,821aba4 <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 821ab8c:	d0a06b43 	ldbu	r2,-32339(gp)
 821ab90:	10803fcc 	andi	r2,r2,255
 821ab94:	10800058 	cmpnei	r2,r2,1
 821ab98:	1000151e 	bne	r2,zero,821abf0 <OSTaskCreateExt+0x1b4>
                OS_Sched();
 821ab9c:	82161580 	call	8216158 <OS_Sched>
 821aba0:	00001306 	br	821abf0 <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821aba4:	0005303a 	rdctl	r2,status
 821aba8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821abac:	e0fff817 	ldw	r3,-32(fp)
 821abb0:	00bfff84 	movi	r2,-2
 821abb4:	1884703a 	and	r2,r3,r2
 821abb8:	1001703a 	wrctl	status,r2
  
  return context;
 821abbc:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821abc0:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 821abc4:	e0fffd03 	ldbu	r3,-12(fp)
 821abc8:	008209b4 	movhi	r2,2086
 821abcc:	10b54004 	addi	r2,r2,-11008
 821abd0:	18c7883a 	add	r3,r3,r3
 821abd4:	18c7883a 	add	r3,r3,r3
 821abd8:	10c5883a 	add	r2,r2,r3
 821abdc:	10000015 	stw	zero,0(r2)
 821abe0:	e0bff117 	ldw	r2,-60(fp)
 821abe4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821abe8:	e0bff417 	ldw	r2,-48(fp)
 821abec:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821abf0:	e0bff603 	ldbu	r2,-40(fp)
 821abf4:	00000506 	br	821ac0c <OSTaskCreateExt+0x1d0>
 821abf8:	e0bff117 	ldw	r2,-60(fp)
 821abfc:	e0bff715 	stw	r2,-36(fp)
 821ac00:	e0bff717 	ldw	r2,-36(fp)
 821ac04:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821ac08:	00800a04 	movi	r2,40
}
 821ac0c:	e037883a 	mov	sp,fp
 821ac10:	dfc00117 	ldw	ra,4(sp)
 821ac14:	df000017 	ldw	fp,0(sp)
 821ac18:	dec00204 	addi	sp,sp,8
 821ac1c:	f800283a 	ret

0821ac20 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 821ac20:	defff404 	addi	sp,sp,-48
 821ac24:	dfc00b15 	stw	ra,44(sp)
 821ac28:	df000a15 	stw	fp,40(sp)
 821ac2c:	df000a04 	addi	fp,sp,40
 821ac30:	2005883a 	mov	r2,r4
 821ac34:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 821ac38:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 821ac3c:	d0a07903 	ldbu	r2,-32284(gp)
 821ac40:	10803fcc 	andi	r2,r2,255
 821ac44:	10000226 	beq	r2,zero,821ac50 <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
 821ac48:	00801004 	movi	r2,64
 821ac4c:	0000c006 	br	821af50 <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 821ac50:	e0bfff03 	ldbu	r2,-4(fp)
 821ac54:	10800518 	cmpnei	r2,r2,20
 821ac58:	1000021e 	bne	r2,zero,821ac64 <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
 821ac5c:	00800f84 	movi	r2,62
 821ac60:	0000bb06 	br	821af50 <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 821ac64:	e0bfff03 	ldbu	r2,-4(fp)
 821ac68:	10800530 	cmpltui	r2,r2,20
 821ac6c:	1000051e 	bne	r2,zero,821ac84 <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
 821ac70:	e0bfff03 	ldbu	r2,-4(fp)
 821ac74:	10803fe0 	cmpeqi	r2,r2,255
 821ac78:	1000021e 	bne	r2,zero,821ac84 <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
 821ac7c:	00800a84 	movi	r2,42
 821ac80:	0000b306 	br	821af50 <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ac84:	0005303a 	rdctl	r2,status
 821ac88:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ac8c:	e0fffe17 	ldw	r3,-8(fp)
 821ac90:	00bfff84 	movi	r2,-2
 821ac94:	1884703a 	and	r2,r3,r2
 821ac98:	1001703a 	wrctl	status,r2
  
  return context;
 821ac9c:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 821aca0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 821aca4:	e0bfff03 	ldbu	r2,-4(fp)
 821aca8:	10803fd8 	cmpnei	r2,r2,255
 821acac:	1000031e 	bne	r2,zero,821acbc <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 821acb0:	d0a07a17 	ldw	r2,-32280(gp)
 821acb4:	10800c83 	ldbu	r2,50(r2)
 821acb8:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821acbc:	e0ffff03 	ldbu	r3,-4(fp)
 821acc0:	008209b4 	movhi	r2,2086
 821acc4:	10b54004 	addi	r2,r2,-11008
 821acc8:	18c7883a 	add	r3,r3,r3
 821accc:	18c7883a 	add	r3,r3,r3
 821acd0:	10c5883a 	add	r2,r2,r3
 821acd4:	10800017 	ldw	r2,0(r2)
 821acd8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 821acdc:	e0bff817 	ldw	r2,-32(fp)
 821ace0:	1000061e 	bne	r2,zero,821acfc <OSTaskDel+0xdc>
 821ace4:	e0bff617 	ldw	r2,-40(fp)
 821ace8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821acec:	e0bff717 	ldw	r2,-36(fp)
 821acf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821acf4:	008010c4 	movi	r2,67
 821acf8:	00009506 	br	821af50 <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 821acfc:	e0bff817 	ldw	r2,-32(fp)
 821ad00:	10800058 	cmpnei	r2,r2,1
 821ad04:	1000061e 	bne	r2,zero,821ad20 <OSTaskDel+0x100>
 821ad08:	e0bff617 	ldw	r2,-40(fp)
 821ad0c:	e0bff915 	stw	r2,-28(fp)
 821ad10:	e0bff917 	ldw	r2,-28(fp)
 821ad14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821ad18:	00800f44 	movi	r2,61
 821ad1c:	00008c06 	br	821af50 <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 821ad20:	e0bff817 	ldw	r2,-32(fp)
 821ad24:	10800d03 	ldbu	r2,52(r2)
 821ad28:	10c03fcc 	andi	r3,r2,255
 821ad2c:	e0bff817 	ldw	r2,-32(fp)
 821ad30:	10800d03 	ldbu	r2,52(r2)
 821ad34:	11003fcc 	andi	r4,r2,255
 821ad38:	d0a07744 	addi	r2,gp,-32291
 821ad3c:	2085883a 	add	r2,r4,r2
 821ad40:	10800003 	ldbu	r2,0(r2)
 821ad44:	1009883a 	mov	r4,r2
 821ad48:	e0bff817 	ldw	r2,-32(fp)
 821ad4c:	10800d43 	ldbu	r2,53(r2)
 821ad50:	0084303a 	nor	r2,zero,r2
 821ad54:	2084703a 	and	r2,r4,r2
 821ad58:	1009883a 	mov	r4,r2
 821ad5c:	d0a07744 	addi	r2,gp,-32291
 821ad60:	1885883a 	add	r2,r3,r2
 821ad64:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 821ad68:	e0bff817 	ldw	r2,-32(fp)
 821ad6c:	10800d03 	ldbu	r2,52(r2)
 821ad70:	10c03fcc 	andi	r3,r2,255
 821ad74:	d0a07744 	addi	r2,gp,-32291
 821ad78:	1885883a 	add	r2,r3,r2
 821ad7c:	10800003 	ldbu	r2,0(r2)
 821ad80:	10803fcc 	andi	r2,r2,255
 821ad84:	1000071e 	bne	r2,zero,821ada4 <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 821ad88:	e0bff817 	ldw	r2,-32(fp)
 821ad8c:	10800d83 	ldbu	r2,54(r2)
 821ad90:	0084303a 	nor	r2,zero,r2
 821ad94:	1007883a 	mov	r3,r2
 821ad98:	d0a07703 	ldbu	r2,-32292(gp)
 821ad9c:	1884703a 	and	r2,r3,r2
 821ada0:	d0a07705 	stb	r2,-32292(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 821ada4:	e0bff817 	ldw	r2,-32(fp)
 821ada8:	10800717 	ldw	r2,28(r2)
 821adac:	10000526 	beq	r2,zero,821adc4 <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 821adb0:	e0bff817 	ldw	r2,-32(fp)
 821adb4:	10800717 	ldw	r2,28(r2)
 821adb8:	100b883a 	mov	r5,r2
 821adbc:	e13ff817 	ldw	r4,-32(fp)
 821adc0:	8215b040 	call	8215b04 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 821adc4:	e0bff817 	ldw	r2,-32(fp)
 821adc8:	10800817 	ldw	r2,32(r2)
 821adcc:	10000526 	beq	r2,zero,821ade4 <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 821add0:	e0bff817 	ldw	r2,-32(fp)
 821add4:	10800817 	ldw	r2,32(r2)
 821add8:	100b883a 	mov	r5,r2
 821addc:	e13ff817 	ldw	r4,-32(fp)
 821ade0:	8215bbc0 	call	8215bbc <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 821ade4:	e0bff817 	ldw	r2,-32(fp)
 821ade8:	10800a17 	ldw	r2,40(r2)
 821adec:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 821adf0:	e0bffb17 	ldw	r2,-20(fp)
 821adf4:	10000226 	beq	r2,zero,821ae00 <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 821adf8:	e13ffb17 	ldw	r4,-20(fp)
 821adfc:	82180440 	call	8218044 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 821ae00:	e0bff817 	ldw	r2,-32(fp)
 821ae04:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 821ae08:	e0bff817 	ldw	r2,-32(fp)
 821ae0c:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 821ae10:	e0bff817 	ldw	r2,-32(fp)
 821ae14:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 821ae18:	d0a06b03 	ldbu	r2,-32340(gp)
 821ae1c:	10803fcc 	andi	r2,r2,255
 821ae20:	10803fe0 	cmpeqi	r2,r2,255
 821ae24:	1000031e 	bne	r2,zero,821ae34 <OSTaskDel+0x214>
        OSLockNesting++;
 821ae28:	d0a06b03 	ldbu	r2,-32340(gp)
 821ae2c:	10800044 	addi	r2,r2,1
 821ae30:	d0a06b05 	stb	r2,-32340(gp)
 821ae34:	e0bff617 	ldw	r2,-40(fp)
 821ae38:	e0bffd15 	stw	r2,-12(fp)
 821ae3c:	e0bffd17 	ldw	r2,-12(fp)
 821ae40:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 821ae44:	82156ec0 	call	82156ec <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ae48:	0005303a 	rdctl	r2,status
 821ae4c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ae50:	e0fffa17 	ldw	r3,-24(fp)
 821ae54:	00bfff84 	movi	r2,-2
 821ae58:	1884703a 	and	r2,r3,r2
 821ae5c:	1001703a 	wrctl	status,r2
  
  return context;
 821ae60:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 821ae64:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 821ae68:	d0a06b03 	ldbu	r2,-32340(gp)
 821ae6c:	10803fcc 	andi	r2,r2,255
 821ae70:	10000326 	beq	r2,zero,821ae80 <OSTaskDel+0x260>
        OSLockNesting--;
 821ae74:	d0a06b03 	ldbu	r2,-32340(gp)
 821ae78:	10bfffc4 	addi	r2,r2,-1
 821ae7c:	d0a06b05 	stb	r2,-32340(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 821ae80:	e13ff817 	ldw	r4,-32(fp)
 821ae84:	823cb580 	call	823cb58 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 821ae88:	d0a07343 	ldbu	r2,-32307(gp)
 821ae8c:	10bfffc4 	addi	r2,r2,-1
 821ae90:	d0a07345 	stb	r2,-32307(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 821ae94:	e0ffff03 	ldbu	r3,-4(fp)
 821ae98:	008209b4 	movhi	r2,2086
 821ae9c:	10b54004 	addi	r2,r2,-11008
 821aea0:	18c7883a 	add	r3,r3,r3
 821aea4:	18c7883a 	add	r3,r3,r3
 821aea8:	10c5883a 	add	r2,r2,r3
 821aeac:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 821aeb0:	e0bff817 	ldw	r2,-32(fp)
 821aeb4:	10800617 	ldw	r2,24(r2)
 821aeb8:	1000071e 	bne	r2,zero,821aed8 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 821aebc:	e0bff817 	ldw	r2,-32(fp)
 821aec0:	10800517 	ldw	r2,20(r2)
 821aec4:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 821aec8:	e0bff817 	ldw	r2,-32(fp)
 821aecc:	10800517 	ldw	r2,20(r2)
 821aed0:	d0a06e15 	stw	r2,-32328(gp)
 821aed4:	00000a06 	br	821af00 <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 821aed8:	e0bff817 	ldw	r2,-32(fp)
 821aedc:	10800617 	ldw	r2,24(r2)
 821aee0:	e0fff817 	ldw	r3,-32(fp)
 821aee4:	18c00517 	ldw	r3,20(r3)
 821aee8:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 821aeec:	e0bff817 	ldw	r2,-32(fp)
 821aef0:	10800517 	ldw	r2,20(r2)
 821aef4:	e0fff817 	ldw	r3,-32(fp)
 821aef8:	18c00617 	ldw	r3,24(r3)
 821aefc:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 821af00:	d0e07217 	ldw	r3,-32312(gp)
 821af04:	e0bff817 	ldw	r2,-32(fp)
 821af08:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 821af0c:	e0bff817 	ldw	r2,-32(fp)
 821af10:	d0a07215 	stw	r2,-32312(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 821af14:	e0bff817 	ldw	r2,-32(fp)
 821af18:	00c00fc4 	movi	r3,63
 821af1c:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 821af20:	e0bff817 	ldw	r2,-32(fp)
 821af24:	10001345 	stb	zero,77(r2)
 821af28:	e0bff617 	ldw	r2,-40(fp)
 821af2c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821af30:	e0bffc17 	ldw	r2,-16(fp)
 821af34:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821af38:	d0a06b43 	ldbu	r2,-32339(gp)
 821af3c:	10803fcc 	andi	r2,r2,255
 821af40:	10800058 	cmpnei	r2,r2,1
 821af44:	1000011e 	bne	r2,zero,821af4c <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
 821af48:	82161580 	call	8216158 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821af4c:	0005883a 	mov	r2,zero
}
 821af50:	e037883a 	mov	sp,fp
 821af54:	dfc00117 	ldw	ra,4(sp)
 821af58:	df000017 	ldw	fp,0(sp)
 821af5c:	dec00204 	addi	sp,sp,8
 821af60:	f800283a 	ret

0821af64 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 821af64:	defff504 	addi	sp,sp,-44
 821af68:	df000a15 	stw	fp,40(sp)
 821af6c:	df000a04 	addi	fp,sp,40
 821af70:	2005883a 	mov	r2,r4
 821af74:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821af78:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 821af7c:	e0bfff03 	ldbu	r2,-4(fp)
 821af80:	10800518 	cmpnei	r2,r2,20
 821af84:	1000021e 	bne	r2,zero,821af90 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 821af88:	00800f84 	movi	r2,62
 821af8c:	00004506 	br	821b0a4 <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821af90:	e0bfff03 	ldbu	r2,-4(fp)
 821af94:	10800530 	cmpltui	r2,r2,20
 821af98:	1000051e 	bne	r2,zero,821afb0 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 821af9c:	e0bfff03 	ldbu	r2,-4(fp)
 821afa0:	10803fe0 	cmpeqi	r2,r2,255
 821afa4:	1000021e 	bne	r2,zero,821afb0 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 821afa8:	00800a84 	movi	r2,42
 821afac:	00003d06 	br	821b0a4 <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 821afb0:	e0bfff03 	ldbu	r2,-4(fp)
 821afb4:	10803fd8 	cmpnei	r2,r2,255
 821afb8:	1000111e 	bne	r2,zero,821b000 <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821afbc:	0005303a 	rdctl	r2,status
 821afc0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821afc4:	e0fff917 	ldw	r3,-28(fp)
 821afc8:	00bfff84 	movi	r2,-2
 821afcc:	1884703a 	and	r2,r3,r2
 821afd0:	1001703a 	wrctl	status,r2
  
  return context;
 821afd4:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 821afd8:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 821afdc:	d0a07a17 	ldw	r2,-32280(gp)
 821afe0:	10800dc3 	ldbu	r2,55(r2)
 821afe4:	e0bff805 	stb	r2,-32(fp)
 821afe8:	e0bff617 	ldw	r2,-40(fp)
 821afec:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821aff0:	e0bffe17 	ldw	r2,-8(fp)
 821aff4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 821aff8:	e0bff803 	ldbu	r2,-32(fp)
 821affc:	00002906 	br	821b0a4 <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b000:	0005303a 	rdctl	r2,status
 821b004:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b008:	e0fff717 	ldw	r3,-36(fp)
 821b00c:	00bfff84 	movi	r2,-2
 821b010:	1884703a 	and	r2,r3,r2
 821b014:	1001703a 	wrctl	status,r2
  
  return context;
 821b018:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 821b01c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b020:	e0ffff03 	ldbu	r3,-4(fp)
 821b024:	008209b4 	movhi	r2,2086
 821b028:	10b54004 	addi	r2,r2,-11008
 821b02c:	18c7883a 	add	r3,r3,r3
 821b030:	18c7883a 	add	r3,r3,r3
 821b034:	10c5883a 	add	r2,r2,r3
 821b038:	10800017 	ldw	r2,0(r2)
 821b03c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 821b040:	e0bffb17 	ldw	r2,-20(fp)
 821b044:	1000061e 	bne	r2,zero,821b060 <OSTaskDelReq+0xfc>
 821b048:	e0bff617 	ldw	r2,-40(fp)
 821b04c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b050:	e0bffa17 	ldw	r2,-24(fp)
 821b054:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 821b058:	008010c4 	movi	r2,67
 821b05c:	00001106 	br	821b0a4 <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 821b060:	e0bffb17 	ldw	r2,-20(fp)
 821b064:	10800058 	cmpnei	r2,r2,1
 821b068:	1000061e 	bne	r2,zero,821b084 <OSTaskDelReq+0x120>
 821b06c:	e0bff617 	ldw	r2,-40(fp)
 821b070:	e0bffc15 	stw	r2,-16(fp)
 821b074:	e0bffc17 	ldw	r2,-16(fp)
 821b078:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b07c:	00800f44 	movi	r2,61
 821b080:	00000806 	br	821b0a4 <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 821b084:	e0bffb17 	ldw	r2,-20(fp)
 821b088:	00c00fc4 	movi	r3,63
 821b08c:	10c00dc5 	stb	r3,55(r2)
 821b090:	e0bff617 	ldw	r2,-40(fp)
 821b094:	e0bffd15 	stw	r2,-12(fp)
 821b098:	e0bffd17 	ldw	r2,-12(fp)
 821b09c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821b0a0:	0005883a 	mov	r2,zero
}
 821b0a4:	e037883a 	mov	sp,fp
 821b0a8:	df000017 	ldw	fp,0(sp)
 821b0ac:	dec00104 	addi	sp,sp,4
 821b0b0:	f800283a 	ret

0821b0b4 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b0b4:	defff404 	addi	sp,sp,-48
 821b0b8:	dfc00b15 	stw	ra,44(sp)
 821b0bc:	df000a15 	stw	fp,40(sp)
 821b0c0:	df000a04 	addi	fp,sp,40
 821b0c4:	2005883a 	mov	r2,r4
 821b0c8:	e17ffe15 	stw	r5,-8(fp)
 821b0cc:	e1bfff15 	stw	r6,-4(fp)
 821b0d0:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 821b0d4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 821b0d8:	e0bfff17 	ldw	r2,-4(fp)
 821b0dc:	1000021e 	bne	r2,zero,821b0e8 <OSTaskNameGet+0x34>
        return (0);
 821b0e0:	0005883a 	mov	r2,zero
 821b0e4:	00005406 	br	821b238 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 821b0e8:	e0bffd03 	ldbu	r2,-12(fp)
 821b0ec:	10800570 	cmpltui	r2,r2,21
 821b0f0:	1000081e 	bne	r2,zero,821b114 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 821b0f4:	e0bffd03 	ldbu	r2,-12(fp)
 821b0f8:	10803fe0 	cmpeqi	r2,r2,255
 821b0fc:	1000051e 	bne	r2,zero,821b114 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 821b100:	e0bfff17 	ldw	r2,-4(fp)
 821b104:	00c00a84 	movi	r3,42
 821b108:	10c00005 	stb	r3,0(r2)
            return (0);
 821b10c:	0005883a 	mov	r2,zero
 821b110:	00004906 	br	821b238 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 821b114:	e0bffe17 	ldw	r2,-8(fp)
 821b118:	1000051e 	bne	r2,zero,821b130 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 821b11c:	e0bfff17 	ldw	r2,-4(fp)
 821b120:	00c00304 	movi	r3,12
 821b124:	10c00005 	stb	r3,0(r2)
        return (0);
 821b128:	0005883a 	mov	r2,zero
 821b12c:	00004206 	br	821b238 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 821b130:	d0a07903 	ldbu	r2,-32284(gp)
 821b134:	10803fcc 	andi	r2,r2,255
 821b138:	10000526 	beq	r2,zero,821b150 <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
 821b13c:	e0bfff17 	ldw	r2,-4(fp)
 821b140:	00c00444 	movi	r3,17
 821b144:	10c00005 	stb	r3,0(r2)
        return (0);
 821b148:	0005883a 	mov	r2,zero
 821b14c:	00003a06 	br	821b238 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b150:	0005303a 	rdctl	r2,status
 821b154:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b158:	e0fffc17 	ldw	r3,-16(fp)
 821b15c:	00bfff84 	movi	r2,-2
 821b160:	1884703a 	and	r2,r3,r2
 821b164:	1001703a 	wrctl	status,r2
  
  return context;
 821b168:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b16c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 821b170:	e0bffd03 	ldbu	r2,-12(fp)
 821b174:	10803fd8 	cmpnei	r2,r2,255
 821b178:	1000031e 	bne	r2,zero,821b188 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
 821b17c:	d0a07a17 	ldw	r2,-32280(gp)
 821b180:	10800c83 	ldbu	r2,50(r2)
 821b184:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b188:	e0fffd03 	ldbu	r3,-12(fp)
 821b18c:	008209b4 	movhi	r2,2086
 821b190:	10b54004 	addi	r2,r2,-11008
 821b194:	18c7883a 	add	r3,r3,r3
 821b198:	18c7883a 	add	r3,r3,r3
 821b19c:	10c5883a 	add	r2,r2,r3
 821b1a0:	10800017 	ldw	r2,0(r2)
 821b1a4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 821b1a8:	e0bff817 	ldw	r2,-32(fp)
 821b1ac:	1000091e 	bne	r2,zero,821b1d4 <OSTaskNameGet+0x120>
 821b1b0:	e0bff617 	ldw	r2,-40(fp)
 821b1b4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b1b8:	e0bff717 	ldw	r2,-36(fp)
 821b1bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b1c0:	e0bfff17 	ldw	r2,-4(fp)
 821b1c4:	00c010c4 	movi	r3,67
 821b1c8:	10c00005 	stb	r3,0(r2)
        return (0);
 821b1cc:	0005883a 	mov	r2,zero
 821b1d0:	00001906 	br	821b238 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 821b1d4:	e0bff817 	ldw	r2,-32(fp)
 821b1d8:	10800058 	cmpnei	r2,r2,1
 821b1dc:	1000091e 	bne	r2,zero,821b204 <OSTaskNameGet+0x150>
 821b1e0:	e0bff617 	ldw	r2,-40(fp)
 821b1e4:	e0bff915 	stw	r2,-28(fp)
 821b1e8:	e0bff917 	ldw	r2,-28(fp)
 821b1ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b1f0:	e0bfff17 	ldw	r2,-4(fp)
 821b1f4:	00c010c4 	movi	r3,67
 821b1f8:	10c00005 	stb	r3,0(r2)
        return (0);
 821b1fc:	0005883a 	mov	r2,zero
 821b200:	00000d06 	br	821b238 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 821b204:	e0bff817 	ldw	r2,-32(fp)
 821b208:	10801304 	addi	r2,r2,76
 821b20c:	100b883a 	mov	r5,r2
 821b210:	e13ffe17 	ldw	r4,-8(fp)
 821b214:	821629c0 	call	821629c <OS_StrCopy>
 821b218:	e0bffb05 	stb	r2,-20(fp)
 821b21c:	e0bff617 	ldw	r2,-40(fp)
 821b220:	e0bffa15 	stw	r2,-24(fp)
 821b224:	e0bffa17 	ldw	r2,-24(fp)
 821b228:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b22c:	e0bfff17 	ldw	r2,-4(fp)
 821b230:	10000005 	stb	zero,0(r2)
    return (len);
 821b234:	e0bffb03 	ldbu	r2,-20(fp)
}
 821b238:	e037883a 	mov	sp,fp
 821b23c:	dfc00117 	ldw	ra,4(sp)
 821b240:	df000017 	ldw	fp,0(sp)
 821b244:	dec00204 	addi	sp,sp,8
 821b248:	f800283a 	ret

0821b24c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b24c:	defff304 	addi	sp,sp,-52
 821b250:	dfc00c15 	stw	ra,48(sp)
 821b254:	df000b15 	stw	fp,44(sp)
 821b258:	df000b04 	addi	fp,sp,44
 821b25c:	2005883a 	mov	r2,r4
 821b260:	e17ffe15 	stw	r5,-8(fp)
 821b264:	e1bfff15 	stw	r6,-4(fp)
 821b268:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b26c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 821b270:	e0bfff17 	ldw	r2,-4(fp)
 821b274:	10005c26 	beq	r2,zero,821b3e8 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 821b278:	e0bffd03 	ldbu	r2,-12(fp)
 821b27c:	10800570 	cmpltui	r2,r2,21
 821b280:	1000071e 	bne	r2,zero,821b2a0 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 821b284:	e0bffd03 	ldbu	r2,-12(fp)
 821b288:	10803fe0 	cmpeqi	r2,r2,255
 821b28c:	1000041e 	bne	r2,zero,821b2a0 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 821b290:	e0bfff17 	ldw	r2,-4(fp)
 821b294:	00c00a84 	movi	r3,42
 821b298:	10c00005 	stb	r3,0(r2)
            return;
 821b29c:	00005306 	br	821b3ec <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 821b2a0:	e0bffe17 	ldw	r2,-8(fp)
 821b2a4:	1000041e 	bne	r2,zero,821b2b8 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 821b2a8:	e0bfff17 	ldw	r2,-4(fp)
 821b2ac:	00c00304 	movi	r3,12
 821b2b0:	10c00005 	stb	r3,0(r2)
        return;
 821b2b4:	00004d06 	br	821b3ec <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 821b2b8:	d0a07903 	ldbu	r2,-32284(gp)
 821b2bc:	10803fcc 	andi	r2,r2,255
 821b2c0:	10000426 	beq	r2,zero,821b2d4 <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
 821b2c4:	e0bfff17 	ldw	r2,-4(fp)
 821b2c8:	00c00484 	movi	r3,18
 821b2cc:	10c00005 	stb	r3,0(r2)
        return;
 821b2d0:	00004606 	br	821b3ec <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b2d4:	0005303a 	rdctl	r2,status
 821b2d8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b2dc:	e0fffc17 	ldw	r3,-16(fp)
 821b2e0:	00bfff84 	movi	r2,-2
 821b2e4:	1884703a 	and	r2,r3,r2
 821b2e8:	1001703a 	wrctl	status,r2
  
  return context;
 821b2ec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b2f0:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 821b2f4:	e0bffd03 	ldbu	r2,-12(fp)
 821b2f8:	10803fd8 	cmpnei	r2,r2,255
 821b2fc:	1000031e 	bne	r2,zero,821b30c <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
 821b300:	d0a07a17 	ldw	r2,-32280(gp)
 821b304:	10800c83 	ldbu	r2,50(r2)
 821b308:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b30c:	e0fffd03 	ldbu	r3,-12(fp)
 821b310:	008209b4 	movhi	r2,2086
 821b314:	10b54004 	addi	r2,r2,-11008
 821b318:	18c7883a 	add	r3,r3,r3
 821b31c:	18c7883a 	add	r3,r3,r3
 821b320:	10c5883a 	add	r2,r2,r3
 821b324:	10800017 	ldw	r2,0(r2)
 821b328:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 821b32c:	e0bff717 	ldw	r2,-36(fp)
 821b330:	1000081e 	bne	r2,zero,821b354 <OSTaskNameSet+0x108>
 821b334:	e0bff517 	ldw	r2,-44(fp)
 821b338:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b33c:	e0bff617 	ldw	r2,-40(fp)
 821b340:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b344:	e0bfff17 	ldw	r2,-4(fp)
 821b348:	00c010c4 	movi	r3,67
 821b34c:	10c00005 	stb	r3,0(r2)
        return;
 821b350:	00002606 	br	821b3ec <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 821b354:	e0bff717 	ldw	r2,-36(fp)
 821b358:	10800058 	cmpnei	r2,r2,1
 821b35c:	1000081e 	bne	r2,zero,821b380 <OSTaskNameSet+0x134>
 821b360:	e0bff517 	ldw	r2,-44(fp)
 821b364:	e0bff815 	stw	r2,-32(fp)
 821b368:	e0bff817 	ldw	r2,-32(fp)
 821b36c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b370:	e0bfff17 	ldw	r2,-4(fp)
 821b374:	00c010c4 	movi	r3,67
 821b378:	10c00005 	stb	r3,0(r2)
        return;
 821b37c:	00001b06 	br	821b3ec <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 821b380:	e13ffe17 	ldw	r4,-8(fp)
 821b384:	82163100 	call	8216310 <OS_StrLen>
 821b388:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 821b38c:	e0bffa03 	ldbu	r2,-24(fp)
 821b390:	10800830 	cmpltui	r2,r2,32
 821b394:	1000081e 	bne	r2,zero,821b3b8 <OSTaskNameSet+0x16c>
 821b398:	e0bff517 	ldw	r2,-44(fp)
 821b39c:	e0bff915 	stw	r2,-28(fp)
 821b3a0:	e0bff917 	ldw	r2,-28(fp)
 821b3a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 821b3a8:	e0bfff17 	ldw	r2,-4(fp)
 821b3ac:	00c01044 	movi	r3,65
 821b3b0:	10c00005 	stb	r3,0(r2)
        return;
 821b3b4:	00000d06 	br	821b3ec <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 821b3b8:	e0bff717 	ldw	r2,-36(fp)
 821b3bc:	10801304 	addi	r2,r2,76
 821b3c0:	e17ffe17 	ldw	r5,-8(fp)
 821b3c4:	1009883a 	mov	r4,r2
 821b3c8:	821629c0 	call	821629c <OS_StrCopy>
 821b3cc:	e0bff517 	ldw	r2,-44(fp)
 821b3d0:	e0bffb15 	stw	r2,-20(fp)
 821b3d4:	e0bffb17 	ldw	r2,-20(fp)
 821b3d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b3dc:	e0bfff17 	ldw	r2,-4(fp)
 821b3e0:	10000005 	stb	zero,0(r2)
 821b3e4:	00000106 	br	821b3ec <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 821b3e8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 821b3ec:	e037883a 	mov	sp,fp
 821b3f0:	dfc00117 	ldw	ra,4(sp)
 821b3f4:	df000017 	ldw	fp,0(sp)
 821b3f8:	dec00204 	addi	sp,sp,8
 821b3fc:	f800283a 	ret

0821b400 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 821b400:	defff404 	addi	sp,sp,-48
 821b404:	dfc00b15 	stw	ra,44(sp)
 821b408:	df000a15 	stw	fp,40(sp)
 821b40c:	df000a04 	addi	fp,sp,40
 821b410:	2005883a 	mov	r2,r4
 821b414:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b418:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 821b41c:	e0bfff03 	ldbu	r2,-4(fp)
 821b420:	10800530 	cmpltui	r2,r2,20
 821b424:	1000021e 	bne	r2,zero,821b430 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821b428:	00800a84 	movi	r2,42
 821b42c:	00006406 	br	821b5c0 <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b430:	0005303a 	rdctl	r2,status
 821b434:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b438:	e0fffe17 	ldw	r3,-8(fp)
 821b43c:	00bfff84 	movi	r2,-2
 821b440:	1884703a 	and	r2,r3,r2
 821b444:	1001703a 	wrctl	status,r2
  
  return context;
 821b448:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821b44c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b450:	e0ffff03 	ldbu	r3,-4(fp)
 821b454:	008209b4 	movhi	r2,2086
 821b458:	10b54004 	addi	r2,r2,-11008
 821b45c:	18c7883a 	add	r3,r3,r3
 821b460:	18c7883a 	add	r3,r3,r3
 821b464:	10c5883a 	add	r2,r2,r3
 821b468:	10800017 	ldw	r2,0(r2)
 821b46c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 821b470:	e0bff817 	ldw	r2,-32(fp)
 821b474:	1000061e 	bne	r2,zero,821b490 <OSTaskResume+0x90>
 821b478:	e0bff617 	ldw	r2,-40(fp)
 821b47c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b480:	e0bff717 	ldw	r2,-36(fp)
 821b484:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 821b488:	00801184 	movi	r2,70
 821b48c:	00004c06 	br	821b5c0 <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 821b490:	e0bff817 	ldw	r2,-32(fp)
 821b494:	10800058 	cmpnei	r2,r2,1
 821b498:	1000061e 	bne	r2,zero,821b4b4 <OSTaskResume+0xb4>
 821b49c:	e0bff617 	ldw	r2,-40(fp)
 821b4a0:	e0bff915 	stw	r2,-28(fp)
 821b4a4:	e0bff917 	ldw	r2,-28(fp)
 821b4a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b4ac:	008010c4 	movi	r2,67
 821b4b0:	00004306 	br	821b5c0 <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 821b4b4:	e0bff817 	ldw	r2,-32(fp)
 821b4b8:	10800c03 	ldbu	r2,48(r2)
 821b4bc:	10803fcc 	andi	r2,r2,255
 821b4c0:	1080020c 	andi	r2,r2,8
 821b4c4:	10003926 	beq	r2,zero,821b5ac <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 821b4c8:	e0bff817 	ldw	r2,-32(fp)
 821b4cc:	10c00c03 	ldbu	r3,48(r2)
 821b4d0:	00bffdc4 	movi	r2,-9
 821b4d4:	1884703a 	and	r2,r3,r2
 821b4d8:	1007883a 	mov	r3,r2
 821b4dc:	e0bff817 	ldw	r2,-32(fp)
 821b4e0:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 821b4e4:	e0bff817 	ldw	r2,-32(fp)
 821b4e8:	10800c03 	ldbu	r2,48(r2)
 821b4ec:	10803fcc 	andi	r2,r2,255
 821b4f0:	1000281e 	bne	r2,zero,821b594 <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
 821b4f4:	e0bff817 	ldw	r2,-32(fp)
 821b4f8:	10800b8b 	ldhu	r2,46(r2)
 821b4fc:	10bfffcc 	andi	r2,r2,65535
 821b500:	10001f1e 	bne	r2,zero,821b580 <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 821b504:	e0bff817 	ldw	r2,-32(fp)
 821b508:	10c00d83 	ldbu	r3,54(r2)
 821b50c:	d0a07703 	ldbu	r2,-32292(gp)
 821b510:	1884b03a 	or	r2,r3,r2
 821b514:	d0a07705 	stb	r2,-32292(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821b518:	e0bff817 	ldw	r2,-32(fp)
 821b51c:	10800d03 	ldbu	r2,52(r2)
 821b520:	10c03fcc 	andi	r3,r2,255
 821b524:	e0bff817 	ldw	r2,-32(fp)
 821b528:	10800d03 	ldbu	r2,52(r2)
 821b52c:	11003fcc 	andi	r4,r2,255
 821b530:	d0a07744 	addi	r2,gp,-32291
 821b534:	2085883a 	add	r2,r4,r2
 821b538:	11000003 	ldbu	r4,0(r2)
 821b53c:	e0bff817 	ldw	r2,-32(fp)
 821b540:	10800d43 	ldbu	r2,53(r2)
 821b544:	2084b03a 	or	r2,r4,r2
 821b548:	1009883a 	mov	r4,r2
 821b54c:	d0a07744 	addi	r2,gp,-32291
 821b550:	1885883a 	add	r2,r3,r2
 821b554:	11000005 	stb	r4,0(r2)
 821b558:	e0bff617 	ldw	r2,-40(fp)
 821b55c:	e0bffa15 	stw	r2,-24(fp)
 821b560:	e0bffa17 	ldw	r2,-24(fp)
 821b564:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 821b568:	d0a06b43 	ldbu	r2,-32339(gp)
 821b56c:	10803fcc 	andi	r2,r2,255
 821b570:	10800058 	cmpnei	r2,r2,1
 821b574:	10000b1e 	bne	r2,zero,821b5a4 <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
 821b578:	82161580 	call	8216158 <OS_Sched>
 821b57c:	00000906 	br	821b5a4 <OSTaskResume+0x1a4>
 821b580:	e0bff617 	ldw	r2,-40(fp)
 821b584:	e0bffb15 	stw	r2,-20(fp)
 821b588:	e0bffb17 	ldw	r2,-20(fp)
 821b58c:	1001703a 	wrctl	status,r2
 821b590:	00000406 	br	821b5a4 <OSTaskResume+0x1a4>
 821b594:	e0bff617 	ldw	r2,-40(fp)
 821b598:	e0bffc15 	stw	r2,-16(fp)
 821b59c:	e0bffc17 	ldw	r2,-16(fp)
 821b5a0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 821b5a4:	0005883a 	mov	r2,zero
 821b5a8:	00000506 	br	821b5c0 <OSTaskResume+0x1c0>
 821b5ac:	e0bff617 	ldw	r2,-40(fp)
 821b5b0:	e0bffd15 	stw	r2,-12(fp)
 821b5b4:	e0bffd17 	ldw	r2,-12(fp)
 821b5b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 821b5bc:	00801104 	movi	r2,68
}
 821b5c0:	e037883a 	mov	sp,fp
 821b5c4:	dfc00117 	ldw	ra,4(sp)
 821b5c8:	df000017 	ldw	fp,0(sp)
 821b5cc:	dec00204 	addi	sp,sp,8
 821b5d0:	f800283a 	ret

0821b5d4 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 821b5d4:	defff304 	addi	sp,sp,-52
 821b5d8:	df000c15 	stw	fp,48(sp)
 821b5dc:	df000c04 	addi	fp,sp,48
 821b5e0:	2005883a 	mov	r2,r4
 821b5e4:	e17fff15 	stw	r5,-4(fp)
 821b5e8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 821b5ec:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 821b5f0:	e0bffe03 	ldbu	r2,-8(fp)
 821b5f4:	10800570 	cmpltui	r2,r2,21
 821b5f8:	1000051e 	bne	r2,zero,821b610 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 821b5fc:	e0bffe03 	ldbu	r2,-8(fp)
 821b600:	10803fe0 	cmpeqi	r2,r2,255
 821b604:	1000021e 	bne	r2,zero,821b610 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 821b608:	00800a84 	movi	r2,42
 821b60c:	00005d06 	br	821b784 <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 821b610:	e0bfff17 	ldw	r2,-4(fp)
 821b614:	1000021e 	bne	r2,zero,821b620 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 821b618:	00800244 	movi	r2,9
 821b61c:	00005906 	br	821b784 <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 821b620:	e0bfff17 	ldw	r2,-4(fp)
 821b624:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 821b628:	e0bfff17 	ldw	r2,-4(fp)
 821b62c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b630:	0005303a 	rdctl	r2,status
 821b634:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b638:	e0fffd17 	ldw	r3,-12(fp)
 821b63c:	00bfff84 	movi	r2,-2
 821b640:	1884703a 	and	r2,r3,r2
 821b644:	1001703a 	wrctl	status,r2
  
  return context;
 821b648:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
 821b64c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 821b650:	e0bffe03 	ldbu	r2,-8(fp)
 821b654:	10803fd8 	cmpnei	r2,r2,255
 821b658:	1000031e 	bne	r2,zero,821b668 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821b65c:	d0a07a17 	ldw	r2,-32280(gp)
 821b660:	10800c83 	ldbu	r2,50(r2)
 821b664:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b668:	e0fffe03 	ldbu	r3,-8(fp)
 821b66c:	008209b4 	movhi	r2,2086
 821b670:	10b54004 	addi	r2,r2,-11008
 821b674:	18c7883a 	add	r3,r3,r3
 821b678:	18c7883a 	add	r3,r3,r3
 821b67c:	10c5883a 	add	r2,r2,r3
 821b680:	10800017 	ldw	r2,0(r2)
 821b684:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 821b688:	e0bff817 	ldw	r2,-32(fp)
 821b68c:	1000061e 	bne	r2,zero,821b6a8 <OSTaskStkChk+0xd4>
 821b690:	e0bff617 	ldw	r2,-40(fp)
 821b694:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b698:	e0bff717 	ldw	r2,-36(fp)
 821b69c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b6a0:	008010c4 	movi	r2,67
 821b6a4:	00003706 	br	821b784 <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821b6a8:	e0bff817 	ldw	r2,-32(fp)
 821b6ac:	10800058 	cmpnei	r2,r2,1
 821b6b0:	1000061e 	bne	r2,zero,821b6cc <OSTaskStkChk+0xf8>
 821b6b4:	e0bff617 	ldw	r2,-40(fp)
 821b6b8:	e0bff915 	stw	r2,-28(fp)
 821b6bc:	e0bff917 	ldw	r2,-28(fp)
 821b6c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b6c4:	008010c4 	movi	r2,67
 821b6c8:	00002e06 	br	821b784 <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 821b6cc:	e0bff817 	ldw	r2,-32(fp)
 821b6d0:	1080040b 	ldhu	r2,16(r2)
 821b6d4:	10bfffcc 	andi	r2,r2,65535
 821b6d8:	1080004c 	andi	r2,r2,1
 821b6dc:	1000061e 	bne	r2,zero,821b6f8 <OSTaskStkChk+0x124>
 821b6e0:	e0bff617 	ldw	r2,-40(fp)
 821b6e4:	e0bffa15 	stw	r2,-24(fp)
 821b6e8:	e0bffa17 	ldw	r2,-24(fp)
 821b6ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 821b6f0:	00801144 	movi	r2,69
 821b6f4:	00002306 	br	821b784 <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
 821b6f8:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 821b6fc:	e0bff817 	ldw	r2,-32(fp)
 821b700:	10800317 	ldw	r2,12(r2)
 821b704:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
 821b708:	e0bff817 	ldw	r2,-32(fp)
 821b70c:	10800217 	ldw	r2,8(r2)
 821b710:	e0bff415 	stw	r2,-48(fp)
 821b714:	e0bff617 	ldw	r2,-40(fp)
 821b718:	e0bffb15 	stw	r2,-20(fp)
 821b71c:	e0bffb17 	ldw	r2,-20(fp)
 821b720:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821b724:	00000306 	br	821b734 <OSTaskStkChk+0x160>
        nfree++;
 821b728:	e0bff517 	ldw	r2,-44(fp)
 821b72c:	10800044 	addi	r2,r2,1
 821b730:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821b734:	e0bff417 	ldw	r2,-48(fp)
 821b738:	10c00104 	addi	r3,r2,4
 821b73c:	e0fff415 	stw	r3,-48(fp)
 821b740:	10800017 	ldw	r2,0(r2)
 821b744:	103ff826 	beq	r2,zero,821b728 <OSTaskStkChk+0x154>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 821b748:	e0bff517 	ldw	r2,-44(fp)
 821b74c:	1085883a 	add	r2,r2,r2
 821b750:	1085883a 	add	r2,r2,r2
 821b754:	1007883a 	mov	r3,r2
 821b758:	e0bfff17 	ldw	r2,-4(fp)
 821b75c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 821b760:	e0fffc17 	ldw	r3,-16(fp)
 821b764:	e0bff517 	ldw	r2,-44(fp)
 821b768:	1885c83a 	sub	r2,r3,r2
 821b76c:	1085883a 	add	r2,r2,r2
 821b770:	1085883a 	add	r2,r2,r2
 821b774:	1007883a 	mov	r3,r2
 821b778:	e0bfff17 	ldw	r2,-4(fp)
 821b77c:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 821b780:	0005883a 	mov	r2,zero
}
 821b784:	e037883a 	mov	sp,fp
 821b788:	df000017 	ldw	fp,0(sp)
 821b78c:	dec00104 	addi	sp,sp,4
 821b790:	f800283a 	ret

0821b794 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 821b794:	defff504 	addi	sp,sp,-44
 821b798:	dfc00a15 	stw	ra,40(sp)
 821b79c:	df000915 	stw	fp,36(sp)
 821b7a0:	df000904 	addi	fp,sp,36
 821b7a4:	2005883a 	mov	r2,r4
 821b7a8:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b7ac:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 821b7b0:	e0bfff03 	ldbu	r2,-4(fp)
 821b7b4:	10800518 	cmpnei	r2,r2,20
 821b7b8:	1000021e 	bne	r2,zero,821b7c4 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 821b7bc:	008011c4 	movi	r2,71
 821b7c0:	00006806 	br	821b964 <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821b7c4:	e0bfff03 	ldbu	r2,-4(fp)
 821b7c8:	10800530 	cmpltui	r2,r2,20
 821b7cc:	1000051e 	bne	r2,zero,821b7e4 <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 821b7d0:	e0bfff03 	ldbu	r2,-4(fp)
 821b7d4:	10803fe0 	cmpeqi	r2,r2,255
 821b7d8:	1000021e 	bne	r2,zero,821b7e4 <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 821b7dc:	00800a84 	movi	r2,42
 821b7e0:	00006006 	br	821b964 <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b7e4:	0005303a 	rdctl	r2,status
 821b7e8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b7ec:	e0fffe17 	ldw	r3,-8(fp)
 821b7f0:	00bfff84 	movi	r2,-2
 821b7f4:	1884703a 	and	r2,r3,r2
 821b7f8:	1001703a 	wrctl	status,r2
  
  return context;
 821b7fc:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 821b800:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 821b804:	e0bfff03 	ldbu	r2,-4(fp)
 821b808:	10803fd8 	cmpnei	r2,r2,255
 821b80c:	1000061e 	bne	r2,zero,821b828 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821b810:	d0a07a17 	ldw	r2,-32280(gp)
 821b814:	10800c83 	ldbu	r2,50(r2)
 821b818:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 821b81c:	00800044 	movi	r2,1
 821b820:	e0bff705 	stb	r2,-36(fp)
 821b824:	00000906 	br	821b84c <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 821b828:	d0a07a17 	ldw	r2,-32280(gp)
 821b82c:	10800c83 	ldbu	r2,50(r2)
 821b830:	10c03fcc 	andi	r3,r2,255
 821b834:	e0bfff03 	ldbu	r2,-4(fp)
 821b838:	1880031e 	bne	r3,r2,821b848 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
 821b83c:	00800044 	movi	r2,1
 821b840:	e0bff705 	stb	r2,-36(fp)
 821b844:	00000106 	br	821b84c <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 821b848:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b84c:	e0ffff03 	ldbu	r3,-4(fp)
 821b850:	008209b4 	movhi	r2,2086
 821b854:	10b54004 	addi	r2,r2,-11008
 821b858:	18c7883a 	add	r3,r3,r3
 821b85c:	18c7883a 	add	r3,r3,r3
 821b860:	10c5883a 	add	r2,r2,r3
 821b864:	10800017 	ldw	r2,0(r2)
 821b868:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 821b86c:	e0bffa17 	ldw	r2,-24(fp)
 821b870:	1000061e 	bne	r2,zero,821b88c <OSTaskSuspend+0xf8>
 821b874:	e0bff817 	ldw	r2,-32(fp)
 821b878:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b87c:	e0bff917 	ldw	r2,-28(fp)
 821b880:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 821b884:	00801204 	movi	r2,72
 821b888:	00003606 	br	821b964 <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 821b88c:	e0bffa17 	ldw	r2,-24(fp)
 821b890:	10800058 	cmpnei	r2,r2,1
 821b894:	1000061e 	bne	r2,zero,821b8b0 <OSTaskSuspend+0x11c>
 821b898:	e0bff817 	ldw	r2,-32(fp)
 821b89c:	e0bffb15 	stw	r2,-20(fp)
 821b8a0:	e0bffb17 	ldw	r2,-20(fp)
 821b8a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b8a8:	008010c4 	movi	r2,67
 821b8ac:	00002d06 	br	821b964 <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
 821b8b0:	e0bffa17 	ldw	r2,-24(fp)
 821b8b4:	10800d03 	ldbu	r2,52(r2)
 821b8b8:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 821b8bc:	e0fffd03 	ldbu	r3,-12(fp)
 821b8c0:	e13ffd03 	ldbu	r4,-12(fp)
 821b8c4:	d0a07744 	addi	r2,gp,-32291
 821b8c8:	2085883a 	add	r2,r4,r2
 821b8cc:	10800003 	ldbu	r2,0(r2)
 821b8d0:	1009883a 	mov	r4,r2
 821b8d4:	e0bffa17 	ldw	r2,-24(fp)
 821b8d8:	10800d43 	ldbu	r2,53(r2)
 821b8dc:	0084303a 	nor	r2,zero,r2
 821b8e0:	2084703a 	and	r2,r4,r2
 821b8e4:	1009883a 	mov	r4,r2
 821b8e8:	d0a07744 	addi	r2,gp,-32291
 821b8ec:	1885883a 	add	r2,r3,r2
 821b8f0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 821b8f4:	e0fffd03 	ldbu	r3,-12(fp)
 821b8f8:	d0a07744 	addi	r2,gp,-32291
 821b8fc:	1885883a 	add	r2,r3,r2
 821b900:	10800003 	ldbu	r2,0(r2)
 821b904:	10803fcc 	andi	r2,r2,255
 821b908:	1000071e 	bne	r2,zero,821b928 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 821b90c:	e0bffa17 	ldw	r2,-24(fp)
 821b910:	10800d83 	ldbu	r2,54(r2)
 821b914:	0084303a 	nor	r2,zero,r2
 821b918:	1007883a 	mov	r3,r2
 821b91c:	d0a07703 	ldbu	r2,-32292(gp)
 821b920:	1884703a 	and	r2,r3,r2
 821b924:	d0a07705 	stb	r2,-32292(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 821b928:	e0bffa17 	ldw	r2,-24(fp)
 821b92c:	10800c03 	ldbu	r2,48(r2)
 821b930:	10800214 	ori	r2,r2,8
 821b934:	1007883a 	mov	r3,r2
 821b938:	e0bffa17 	ldw	r2,-24(fp)
 821b93c:	10c00c05 	stb	r3,48(r2)
 821b940:	e0bff817 	ldw	r2,-32(fp)
 821b944:	e0bffc15 	stw	r2,-16(fp)
 821b948:	e0bffc17 	ldw	r2,-16(fp)
 821b94c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 821b950:	e0bff703 	ldbu	r2,-36(fp)
 821b954:	10800058 	cmpnei	r2,r2,1
 821b958:	1000011e 	bne	r2,zero,821b960 <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
 821b95c:	82161580 	call	8216158 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821b960:	0005883a 	mov	r2,zero
}
 821b964:	e037883a 	mov	sp,fp
 821b968:	dfc00117 	ldw	ra,4(sp)
 821b96c:	df000017 	ldw	fp,0(sp)
 821b970:	dec00204 	addi	sp,sp,8
 821b974:	f800283a 	ret

0821b978 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 821b978:	defff604 	addi	sp,sp,-40
 821b97c:	dfc00915 	stw	ra,36(sp)
 821b980:	df000815 	stw	fp,32(sp)
 821b984:	df000804 	addi	fp,sp,32
 821b988:	2005883a 	mov	r2,r4
 821b98c:	e17fff15 	stw	r5,-4(fp)
 821b990:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b994:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 821b998:	e0bffe03 	ldbu	r2,-8(fp)
 821b99c:	10800570 	cmpltui	r2,r2,21
 821b9a0:	1000051e 	bne	r2,zero,821b9b8 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 821b9a4:	e0bffe03 	ldbu	r2,-8(fp)
 821b9a8:	10803fe0 	cmpeqi	r2,r2,255
 821b9ac:	1000021e 	bne	r2,zero,821b9b8 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 821b9b0:	00800a84 	movi	r2,42
 821b9b4:	00003406 	br	821ba88 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 821b9b8:	e0bfff17 	ldw	r2,-4(fp)
 821b9bc:	1000021e 	bne	r2,zero,821b9c8 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 821b9c0:	00800244 	movi	r2,9
 821b9c4:	00003006 	br	821ba88 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b9c8:	0005303a 	rdctl	r2,status
 821b9cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b9d0:	e0fffd17 	ldw	r3,-12(fp)
 821b9d4:	00bfff84 	movi	r2,-2
 821b9d8:	1884703a 	and	r2,r3,r2
 821b9dc:	1001703a 	wrctl	status,r2
  
  return context;
 821b9e0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821b9e4:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 821b9e8:	e0bffe03 	ldbu	r2,-8(fp)
 821b9ec:	10803fd8 	cmpnei	r2,r2,255
 821b9f0:	1000031e 	bne	r2,zero,821ba00 <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
 821b9f4:	d0a07a17 	ldw	r2,-32280(gp)
 821b9f8:	10800c83 	ldbu	r2,50(r2)
 821b9fc:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821ba00:	e0fffe03 	ldbu	r3,-8(fp)
 821ba04:	008209b4 	movhi	r2,2086
 821ba08:	10b54004 	addi	r2,r2,-11008
 821ba0c:	18c7883a 	add	r3,r3,r3
 821ba10:	18c7883a 	add	r3,r3,r3
 821ba14:	10c5883a 	add	r2,r2,r3
 821ba18:	10800017 	ldw	r2,0(r2)
 821ba1c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 821ba20:	e0bffa17 	ldw	r2,-24(fp)
 821ba24:	1000061e 	bne	r2,zero,821ba40 <OSTaskQuery+0xc8>
 821ba28:	e0bff817 	ldw	r2,-32(fp)
 821ba2c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ba30:	e0bff917 	ldw	r2,-28(fp)
 821ba34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 821ba38:	00800a44 	movi	r2,41
 821ba3c:	00001206 	br	821ba88 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 821ba40:	e0bffa17 	ldw	r2,-24(fp)
 821ba44:	10800058 	cmpnei	r2,r2,1
 821ba48:	1000061e 	bne	r2,zero,821ba64 <OSTaskQuery+0xec>
 821ba4c:	e0bff817 	ldw	r2,-32(fp)
 821ba50:	e0bffb15 	stw	r2,-20(fp)
 821ba54:	e0bffb17 	ldw	r2,-20(fp)
 821ba58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821ba5c:	008010c4 	movi	r2,67
 821ba60:	00000906 	br	821ba88 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 821ba64:	01801b04 	movi	r6,108
 821ba68:	e17ffa17 	ldw	r5,-24(fp)
 821ba6c:	e13fff17 	ldw	r4,-4(fp)
 821ba70:	82160f00 	call	82160f0 <OS_MemCopy>
 821ba74:	e0bff817 	ldw	r2,-32(fp)
 821ba78:	e0bffc15 	stw	r2,-16(fp)
 821ba7c:	e0bffc17 	ldw	r2,-16(fp)
 821ba80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821ba84:	0005883a 	mov	r2,zero
}
 821ba88:	e037883a 	mov	sp,fp
 821ba8c:	dfc00117 	ldw	ra,4(sp)
 821ba90:	df000017 	ldw	fp,0(sp)
 821ba94:	dec00204 	addi	sp,sp,8
 821ba98:	f800283a 	ret

0821ba9c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 821ba9c:	defffc04 	addi	sp,sp,-16
 821baa0:	df000315 	stw	fp,12(sp)
 821baa4:	df000304 	addi	fp,sp,12
 821baa8:	e13ffd15 	stw	r4,-12(fp)
 821baac:	e17ffe15 	stw	r5,-8(fp)
 821bab0:	3005883a 	mov	r2,r6
 821bab4:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 821bab8:	e0bfff0b 	ldhu	r2,-4(fp)
 821babc:	1080004c 	andi	r2,r2,1
 821bac0:	10000d26 	beq	r2,zero,821baf8 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 821bac4:	e0bfff0b 	ldhu	r2,-4(fp)
 821bac8:	1080008c 	andi	r2,r2,2
 821bacc:	10000a26 	beq	r2,zero,821baf8 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821bad0:	00000706 	br	821baf0 <OS_TaskStkClr+0x54>
                size--;
 821bad4:	e0bffe17 	ldw	r2,-8(fp)
 821bad8:	10bfffc4 	addi	r2,r2,-1
 821badc:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 821bae0:	e0bffd17 	ldw	r2,-12(fp)
 821bae4:	10c00104 	addi	r3,r2,4
 821bae8:	e0fffd15 	stw	r3,-12(fp)
 821baec:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821baf0:	e0bffe17 	ldw	r2,-8(fp)
 821baf4:	103ff71e 	bne	r2,zero,821bad4 <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 821baf8:	0001883a 	nop
 821bafc:	e037883a 	mov	sp,fp
 821bb00:	df000017 	ldw	fp,0(sp)
 821bb04:	dec00104 	addi	sp,sp,4
 821bb08:	f800283a 	ret

0821bb0c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 821bb0c:	defff904 	addi	sp,sp,-28
 821bb10:	dfc00615 	stw	ra,24(sp)
 821bb14:	df000515 	stw	fp,20(sp)
 821bb18:	df000504 	addi	fp,sp,20
 821bb1c:	2005883a 	mov	r2,r4
 821bb20:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bb24:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bb28:	d0a07903 	ldbu	r2,-32284(gp)
 821bb2c:	10803fcc 	andi	r2,r2,255
 821bb30:	1000311e 	bne	r2,zero,821bbf8 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 821bb34:	e0bfff0b 	ldhu	r2,-4(fp)
 821bb38:	10003026 	beq	r2,zero,821bbfc <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bb3c:	0005303a 	rdctl	r2,status
 821bb40:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bb44:	e0fffe17 	ldw	r3,-8(fp)
 821bb48:	00bfff84 	movi	r2,-2
 821bb4c:	1884703a 	and	r2,r3,r2
 821bb50:	1001703a 	wrctl	status,r2
  
  return context;
 821bb54:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 821bb58:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 821bb5c:	d0a07a17 	ldw	r2,-32280(gp)
 821bb60:	10800d03 	ldbu	r2,52(r2)
 821bb64:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 821bb68:	e0fffd03 	ldbu	r3,-12(fp)
 821bb6c:	e13ffd03 	ldbu	r4,-12(fp)
 821bb70:	d0a07744 	addi	r2,gp,-32291
 821bb74:	2085883a 	add	r2,r4,r2
 821bb78:	10800003 	ldbu	r2,0(r2)
 821bb7c:	1009883a 	mov	r4,r2
 821bb80:	d0a07a17 	ldw	r2,-32280(gp)
 821bb84:	10800d43 	ldbu	r2,53(r2)
 821bb88:	0084303a 	nor	r2,zero,r2
 821bb8c:	2084703a 	and	r2,r4,r2
 821bb90:	1009883a 	mov	r4,r2
 821bb94:	d0a07744 	addi	r2,gp,-32291
 821bb98:	1885883a 	add	r2,r3,r2
 821bb9c:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
 821bba0:	e0fffd03 	ldbu	r3,-12(fp)
 821bba4:	d0a07744 	addi	r2,gp,-32291
 821bba8:	1885883a 	add	r2,r3,r2
 821bbac:	10800003 	ldbu	r2,0(r2)
 821bbb0:	10803fcc 	andi	r2,r2,255
 821bbb4:	1000071e 	bne	r2,zero,821bbd4 <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 821bbb8:	d0a07a17 	ldw	r2,-32280(gp)
 821bbbc:	10800d83 	ldbu	r2,54(r2)
 821bbc0:	0084303a 	nor	r2,zero,r2
 821bbc4:	1007883a 	mov	r3,r2
 821bbc8:	d0a07703 	ldbu	r2,-32292(gp)
 821bbcc:	1884703a 	and	r2,r3,r2
 821bbd0:	d0a07705 	stb	r2,-32292(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 821bbd4:	d0a07a17 	ldw	r2,-32280(gp)
 821bbd8:	e0ffff0b 	ldhu	r3,-4(fp)
 821bbdc:	10c00b8d 	sth	r3,46(r2)
 821bbe0:	e0bffb17 	ldw	r2,-20(fp)
 821bbe4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bbe8:	e0bffc17 	ldw	r2,-16(fp)
 821bbec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 821bbf0:	82161580 	call	8216158 <OS_Sched>
 821bbf4:	00000106 	br	821bbfc <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 821bbf8:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 821bbfc:	e037883a 	mov	sp,fp
 821bc00:	dfc00117 	ldw	ra,4(sp)
 821bc04:	df000017 	ldw	fp,0(sp)
 821bc08:	dec00204 	addi	sp,sp,8
 821bc0c:	f800283a 	ret

0821bc10 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 821bc10:	defff804 	addi	sp,sp,-32
 821bc14:	dfc00715 	stw	ra,28(sp)
 821bc18:	df000615 	stw	fp,24(sp)
 821bc1c:	df000604 	addi	fp,sp,24
 821bc20:	2015883a 	mov	r10,r4
 821bc24:	2809883a 	mov	r4,r5
 821bc28:	3007883a 	mov	r3,r6
 821bc2c:	3805883a 	mov	r2,r7
 821bc30:	e2bffc05 	stb	r10,-16(fp)
 821bc34:	e13ffd05 	stb	r4,-12(fp)
 821bc38:	e0fffe05 	stb	r3,-8(fp)
 821bc3c:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bc40:	d0a07903 	ldbu	r2,-32284(gp)
 821bc44:	10803fcc 	andi	r2,r2,255
 821bc48:	10000226 	beq	r2,zero,821bc54 <OSTimeDlyHMSM+0x44>
        return (OS_ERR_TIME_DLY_ISR);
 821bc4c:	00801544 	movi	r2,85
 821bc50:	00004206 	br	821bd5c <OSTimeDlyHMSM+0x14c>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 821bc54:	e0bffc03 	ldbu	r2,-16(fp)
 821bc58:	1000081e 	bne	r2,zero,821bc7c <OSTimeDlyHMSM+0x6c>
        if (minutes == 0) {
 821bc5c:	e0bffd03 	ldbu	r2,-12(fp)
 821bc60:	1000061e 	bne	r2,zero,821bc7c <OSTimeDlyHMSM+0x6c>
            if (seconds == 0) {
 821bc64:	e0bffe03 	ldbu	r2,-8(fp)
 821bc68:	1000041e 	bne	r2,zero,821bc7c <OSTimeDlyHMSM+0x6c>
                if (ms == 0) {
 821bc6c:	e0bfff0b 	ldhu	r2,-4(fp)
 821bc70:	1000021e 	bne	r2,zero,821bc7c <OSTimeDlyHMSM+0x6c>
                    return (OS_ERR_TIME_ZERO_DLY);
 821bc74:	00801504 	movi	r2,84
 821bc78:	00003806 	br	821bd5c <OSTimeDlyHMSM+0x14c>
                }
            }
        }
    }
    if (minutes > 59) {
 821bc7c:	e0bffd03 	ldbu	r2,-12(fp)
 821bc80:	10800f30 	cmpltui	r2,r2,60
 821bc84:	1000021e 	bne	r2,zero,821bc90 <OSTimeDlyHMSM+0x80>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 821bc88:	00801444 	movi	r2,81
 821bc8c:	00003306 	br	821bd5c <OSTimeDlyHMSM+0x14c>
    }
    if (seconds > 59) {
 821bc90:	e0bffe03 	ldbu	r2,-8(fp)
 821bc94:	10800f30 	cmpltui	r2,r2,60
 821bc98:	1000021e 	bne	r2,zero,821bca4 <OSTimeDlyHMSM+0x94>
        return (OS_ERR_TIME_INVALID_SECONDS);
 821bc9c:	00801484 	movi	r2,82
 821bca0:	00002e06 	br	821bd5c <OSTimeDlyHMSM+0x14c>
    }
    if (ms > 999) {
 821bca4:	e0bfff0b 	ldhu	r2,-4(fp)
 821bca8:	1080fa30 	cmpltui	r2,r2,1000
 821bcac:	1000021e 	bne	r2,zero,821bcb8 <OSTimeDlyHMSM+0xa8>
        return (OS_ERR_TIME_INVALID_MS);
 821bcb0:	008014c4 	movi	r2,83
 821bcb4:	00002906 	br	821bd5c <OSTimeDlyHMSM+0x14c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821bcb8:	e0bffc03 	ldbu	r2,-16(fp)
 821bcbc:	10c38424 	muli	r3,r2,3600
 821bcc0:	e0bffd03 	ldbu	r2,-12(fp)
 821bcc4:	10800f24 	muli	r2,r2,60
 821bcc8:	1887883a 	add	r3,r3,r2
 821bccc:	e0bffe03 	ldbu	r2,-8(fp)
 821bcd0:	1885883a 	add	r2,r3,r2
 821bcd4:	11001924 	muli	r4,r2,100
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 821bcd8:	e0bfff0b 	ldhu	r2,-4(fp)
 821bcdc:	10801924 	muli	r2,r2,100
 821bce0:	10c07d04 	addi	r3,r2,500
 821bce4:	008418b4 	movhi	r2,4194
 821bce8:	109374c4 	addi	r2,r2,19923
 821bcec:	188a383a 	mulxuu	r5,r3,r2
 821bcf0:	1885383a 	mul	r2,r3,r2
 821bcf4:	1011883a 	mov	r8,r2
 821bcf8:	2813883a 	mov	r9,r5
 821bcfc:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821bd00:	2085883a 	add	r2,r4,r2
 821bd04:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 821bd08:	e0bffb17 	ldw	r2,-20(fp)
 821bd0c:	1004d43a 	srli	r2,r2,16
 821bd10:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 821bd14:	e0bffb17 	ldw	r2,-20(fp)
 821bd18:	10bfffcc 	andi	r2,r2,65535
 821bd1c:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
 821bd20:	e0bffb17 	ldw	r2,-20(fp)
 821bd24:	10bfffcc 	andi	r2,r2,65535
 821bd28:	1009883a 	mov	r4,r2
 821bd2c:	821bb0c0 	call	821bb0c <OSTimeDly>
    while (loops > 0) {
 821bd30:	00000706 	br	821bd50 <OSTimeDlyHMSM+0x140>
        OSTimeDly((INT16U)32768u);
 821bd34:	01200014 	movui	r4,32768
 821bd38:	821bb0c0 	call	821bb0c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 821bd3c:	01200014 	movui	r4,32768
 821bd40:	821bb0c0 	call	821bb0c <OSTimeDly>
        loops--;
 821bd44:	e0bffa0b 	ldhu	r2,-24(fp)
 821bd48:	10bfffc4 	addi	r2,r2,-1
 821bd4c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 821bd50:	e0bffa0b 	ldhu	r2,-24(fp)
 821bd54:	103ff71e 	bne	r2,zero,821bd34 <OSTimeDlyHMSM+0x124>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 821bd58:	0005883a 	mov	r2,zero
}
 821bd5c:	e037883a 	mov	sp,fp
 821bd60:	dfc00117 	ldw	ra,4(sp)
 821bd64:	df000017 	ldw	fp,0(sp)
 821bd68:	dec00204 	addi	sp,sp,8
 821bd6c:	f800283a 	ret

0821bd70 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 821bd70:	defff504 	addi	sp,sp,-44
 821bd74:	dfc00a15 	stw	ra,40(sp)
 821bd78:	df000915 	stw	fp,36(sp)
 821bd7c:	df000904 	addi	fp,sp,36
 821bd80:	2005883a 	mov	r2,r4
 821bd84:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821bd88:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 821bd8c:	e0bfff03 	ldbu	r2,-4(fp)
 821bd90:	10800530 	cmpltui	r2,r2,20
 821bd94:	1000021e 	bne	r2,zero,821bda0 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821bd98:	00800a84 	movi	r2,42
 821bd9c:	00006406 	br	821bf30 <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bda0:	0005303a 	rdctl	r2,status
 821bda4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bda8:	e0fffe17 	ldw	r3,-8(fp)
 821bdac:	00bfff84 	movi	r2,-2
 821bdb0:	1884703a 	and	r2,r3,r2
 821bdb4:	1001703a 	wrctl	status,r2
  
  return context;
 821bdb8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821bdbc:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 821bdc0:	e0ffff03 	ldbu	r3,-4(fp)
 821bdc4:	008209b4 	movhi	r2,2086
 821bdc8:	10b54004 	addi	r2,r2,-11008
 821bdcc:	18c7883a 	add	r3,r3,r3
 821bdd0:	18c7883a 	add	r3,r3,r3
 821bdd4:	10c5883a 	add	r2,r2,r3
 821bdd8:	10800017 	ldw	r2,0(r2)
 821bddc:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
 821bde0:	e0bff917 	ldw	r2,-28(fp)
 821bde4:	1000061e 	bne	r2,zero,821be00 <OSTimeDlyResume+0x90>
 821bde8:	e0bff717 	ldw	r2,-36(fp)
 821bdec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bdf0:	e0bff817 	ldw	r2,-32(fp)
 821bdf4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821bdf8:	008010c4 	movi	r2,67
 821bdfc:	00004c06 	br	821bf30 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821be00:	e0bff917 	ldw	r2,-28(fp)
 821be04:	10800058 	cmpnei	r2,r2,1
 821be08:	1000061e 	bne	r2,zero,821be24 <OSTimeDlyResume+0xb4>
 821be0c:	e0bff717 	ldw	r2,-36(fp)
 821be10:	e0bffa15 	stw	r2,-24(fp)
 821be14:	e0bffa17 	ldw	r2,-24(fp)
 821be18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821be1c:	008010c4 	movi	r2,67
 821be20:	00004306 	br	821bf30 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 821be24:	e0bff917 	ldw	r2,-28(fp)
 821be28:	10800b8b 	ldhu	r2,46(r2)
 821be2c:	10bfffcc 	andi	r2,r2,65535
 821be30:	1000061e 	bne	r2,zero,821be4c <OSTimeDlyResume+0xdc>
 821be34:	e0bff717 	ldw	r2,-36(fp)
 821be38:	e0bffb15 	stw	r2,-20(fp)
 821be3c:	e0bffb17 	ldw	r2,-20(fp)
 821be40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 821be44:	00801404 	movi	r2,80
 821be48:	00003906 	br	821bf30 <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 821be4c:	e0bff917 	ldw	r2,-28(fp)
 821be50:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 821be54:	e0bff917 	ldw	r2,-28(fp)
 821be58:	10800c03 	ldbu	r2,48(r2)
 821be5c:	10803fcc 	andi	r2,r2,255
 821be60:	10800dcc 	andi	r2,r2,55
 821be64:	10000b26 	beq	r2,zero,821be94 <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 821be68:	e0bff917 	ldw	r2,-28(fp)
 821be6c:	10c00c03 	ldbu	r3,48(r2)
 821be70:	00bff204 	movi	r2,-56
 821be74:	1884703a 	and	r2,r3,r2
 821be78:	1007883a 	mov	r3,r2
 821be7c:	e0bff917 	ldw	r2,-28(fp)
 821be80:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 821be84:	e0bff917 	ldw	r2,-28(fp)
 821be88:	00c00044 	movi	r3,1
 821be8c:	10c00c45 	stb	r3,49(r2)
 821be90:	00000206 	br	821be9c <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 821be94:	e0bff917 	ldw	r2,-28(fp)
 821be98:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 821be9c:	e0bff917 	ldw	r2,-28(fp)
 821bea0:	10800c03 	ldbu	r2,48(r2)
 821bea4:	10803fcc 	andi	r2,r2,255
 821bea8:	1080020c 	andi	r2,r2,8
 821beac:	10001b1e 	bne	r2,zero,821bf1c <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 821beb0:	e0bff917 	ldw	r2,-28(fp)
 821beb4:	10c00d83 	ldbu	r3,54(r2)
 821beb8:	d0a07703 	ldbu	r2,-32292(gp)
 821bebc:	1884b03a 	or	r2,r3,r2
 821bec0:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821bec4:	e0bff917 	ldw	r2,-28(fp)
 821bec8:	10800d03 	ldbu	r2,52(r2)
 821becc:	10c03fcc 	andi	r3,r2,255
 821bed0:	e0bff917 	ldw	r2,-28(fp)
 821bed4:	10800d03 	ldbu	r2,52(r2)
 821bed8:	11003fcc 	andi	r4,r2,255
 821bedc:	d0a07744 	addi	r2,gp,-32291
 821bee0:	2085883a 	add	r2,r4,r2
 821bee4:	11000003 	ldbu	r4,0(r2)
 821bee8:	e0bff917 	ldw	r2,-28(fp)
 821beec:	10800d43 	ldbu	r2,53(r2)
 821bef0:	2084b03a 	or	r2,r4,r2
 821bef4:	1009883a 	mov	r4,r2
 821bef8:	d0a07744 	addi	r2,gp,-32291
 821befc:	1885883a 	add	r2,r3,r2
 821bf00:	11000005 	stb	r4,0(r2)
 821bf04:	e0bff717 	ldw	r2,-36(fp)
 821bf08:	e0bffc15 	stw	r2,-16(fp)
 821bf0c:	e0bffc17 	ldw	r2,-16(fp)
 821bf10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 821bf14:	82161580 	call	8216158 <OS_Sched>
 821bf18:	00000406 	br	821bf2c <OSTimeDlyResume+0x1bc>
 821bf1c:	e0bff717 	ldw	r2,-36(fp)
 821bf20:	e0bffd15 	stw	r2,-12(fp)
 821bf24:	e0bffd17 	ldw	r2,-12(fp)
 821bf28:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 821bf2c:	0005883a 	mov	r2,zero
}
 821bf30:	e037883a 	mov	sp,fp
 821bf34:	dfc00117 	ldw	ra,4(sp)
 821bf38:	df000017 	ldw	fp,0(sp)
 821bf3c:	dec00204 	addi	sp,sp,8
 821bf40:	f800283a 	ret

0821bf44 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 821bf44:	defffb04 	addi	sp,sp,-20
 821bf48:	df000415 	stw	fp,16(sp)
 821bf4c:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bf50:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bf54:	0005303a 	rdctl	r2,status
 821bf58:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bf5c:	e0fffe17 	ldw	r3,-8(fp)
 821bf60:	00bfff84 	movi	r2,-2
 821bf64:	1884703a 	and	r2,r3,r2
 821bf68:	1001703a 	wrctl	status,r2
  
  return context;
 821bf6c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 821bf70:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 821bf74:	d0a07b17 	ldw	r2,-32276(gp)
 821bf78:	e0bffd15 	stw	r2,-12(fp)
 821bf7c:	e0bffc17 	ldw	r2,-16(fp)
 821bf80:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bf84:	e0bfff17 	ldw	r2,-4(fp)
 821bf88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 821bf8c:	e0bffd17 	ldw	r2,-12(fp)
}
 821bf90:	e037883a 	mov	sp,fp
 821bf94:	df000017 	ldw	fp,0(sp)
 821bf98:	dec00104 	addi	sp,sp,4
 821bf9c:	f800283a 	ret

0821bfa0 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 821bfa0:	defffb04 	addi	sp,sp,-20
 821bfa4:	df000415 	stw	fp,16(sp)
 821bfa8:	df000404 	addi	fp,sp,16
 821bfac:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bfb0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bfb4:	0005303a 	rdctl	r2,status
 821bfb8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bfbc:	e0fffd17 	ldw	r3,-12(fp)
 821bfc0:	00bfff84 	movi	r2,-2
 821bfc4:	1884703a 	and	r2,r3,r2
 821bfc8:	1001703a 	wrctl	status,r2
  
  return context;
 821bfcc:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 821bfd0:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 821bfd4:	e0bfff17 	ldw	r2,-4(fp)
 821bfd8:	d0a07b15 	stw	r2,-32276(gp)
 821bfdc:	e0bffc17 	ldw	r2,-16(fp)
 821bfe0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bfe4:	e0bffe17 	ldw	r2,-8(fp)
 821bfe8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 821bfec:	0001883a 	nop
 821bff0:	e037883a 	mov	sp,fp
 821bff4:	df000017 	ldw	fp,0(sp)
 821bff8:	dec00104 	addi	sp,sp,4
 821bffc:	f800283a 	ret

0821c000 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 821c000:	defffd04 	addi	sp,sp,-12
 821c004:	dfc00215 	stw	ra,8(sp)
 821c008:	df000115 	stw	fp,4(sp)
 821c00c:	df000104 	addi	fp,sp,4
 821c010:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 821c014:	d1604404 	addi	r5,gp,-32496
 821c018:	e13fff17 	ldw	r4,-4(fp)
 821c01c:	823bb780 	call	823bb78 <alt_dev_llist_insert>
}
 821c020:	e037883a 	mov	sp,fp
 821c024:	dfc00117 	ldw	ra,4(sp)
 821c028:	df000017 	ldw	fp,0(sp)
 821c02c:	dec00204 	addi	sp,sp,8
 821c030:	f800283a 	ret

0821c034 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 821c034:	defffd04 	addi	sp,sp,-12
 821c038:	dfc00215 	stw	ra,8(sp)
 821c03c:	df000115 	stw	fp,4(sp)
 821c040:	df000104 	addi	fp,sp,4
 821c044:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 821c048:	823c8e40 	call	823c8e4 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 821c04c:	00800044 	movi	r2,1
 821c050:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 821c054:	0001883a 	nop
 821c058:	e037883a 	mov	sp,fp
 821c05c:	dfc00117 	ldw	ra,4(sp)
 821c060:	df000017 	ldw	fp,0(sp)
 821c064:	dec00204 	addi	sp,sp,8
 821c068:	f800283a 	ret

0821c06c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 821c06c:	defffa04 	addi	sp,sp,-24
 821c070:	dfc00515 	stw	ra,20(sp)
 821c074:	df000415 	stw	fp,16(sp)
 821c078:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 821c07c:	01c01904 	movi	r7,100
 821c080:	000d883a 	mov	r6,zero
 821c084:	000b883a 	mov	r5,zero
 821c088:	01024034 	movhi	r4,2304
 821c08c:	821ed3c0 	call	821ed3c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 821c090:	01800044 	movi	r6,1
 821c094:	000b883a 	mov	r5,zero
 821c098:	01020974 	movhi	r4,2085
 821c09c:	2108ca04 	addi	r4,r4,9000
 821c0a0:	821c4080 	call	821c408 <altera_avalon_jtag_uart_init>
 821c0a4:	01020974 	movhi	r4,2085
 821c0a8:	2108c004 	addi	r4,r4,8960
 821c0ac:	821c0000 	call	821c000 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 821c0b0:	01020974 	movhi	r4,2085
 821c0b4:	210ce504 	addi	r4,r4,13204
 821c0b8:	821dd500 	call	821dd50 <altera_avalon_lcd_16207_init>
 821c0bc:	01020974 	movhi	r4,2085
 821c0c0:	210cdb04 	addi	r4,r4,13164
 821c0c4:	821c0000 	call	821c000 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 821c0c8:	01800084 	movi	r6,2
 821c0cc:	000b883a 	mov	r5,zero
 821c0d0:	01020974 	movhi	r4,2085
 821c0d4:	210d2404 	addi	r4,r4,13456
 821c0d8:	821ec1c0 	call	821ec1c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 821c0dc:	018000c4 	movi	r6,3
 821c0e0:	000b883a 	mov	r5,zero
 821c0e4:	01020974 	movhi	r4,2085
 821c0e8:	210d3004 	addi	r4,r4,13504
 821c0ec:	821ec1c0 	call	821ec1c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 821c0f0:	0001883a 	nop
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 821c0f4:	e03ffc15 	stw	zero,-16(fp)
 821c0f8:	00800044 	movi	r2,1
 821c0fc:	e0bffd15 	stw	r2,-12(fp)
 821c100:	e0bffd17 	ldw	r2,-12(fp)
 821c104:	00800216 	blt	zero,r2,821c110 <alt_sys_init+0xa4>
 821c108:	00800044 	movi	r2,1
 821c10c:	e0bffd15 	stw	r2,-12(fp)
 821c110:	e03ffc15 	stw	zero,-16(fp)
 821c114:	00005a06 	br	821c280 <alt_sys_init+0x214>
 821c118:	008209b4 	movhi	r2,2086
 821c11c:	10b55504 	addi	r2,r2,-10924
 821c120:	e0fffc17 	ldw	r3,-16(fp)
 821c124:	18c00724 	muli	r3,r3,28
 821c128:	10c5883a 	add	r2,r2,r3
 821c12c:	10000015 	stw	zero,0(r2)
 821c130:	008209b4 	movhi	r2,2086
 821c134:	10b55504 	addi	r2,r2,-10924
 821c138:	e0fffc17 	ldw	r3,-16(fp)
 821c13c:	18c00724 	muli	r3,r3,28
 821c140:	10c5883a 	add	r2,r2,r3
 821c144:	10800104 	addi	r2,r2,4
 821c148:	10000015 	stw	zero,0(r2)
 821c14c:	d0e02917 	ldw	r3,-32604(gp)
 821c150:	008209b4 	movhi	r2,2086
 821c154:	10b55504 	addi	r2,r2,-10924
 821c158:	e13ffc17 	ldw	r4,-16(fp)
 821c15c:	21000724 	muli	r4,r4,28
 821c160:	1105883a 	add	r2,r2,r4
 821c164:	10800204 	addi	r2,r2,8
 821c168:	10c00015 	stw	r3,0(r2)
 821c16c:	008209b4 	movhi	r2,2086
 821c170:	10b55504 	addi	r2,r2,-10924
 821c174:	e0fffc17 	ldw	r3,-16(fp)
 821c178:	18c00724 	muli	r3,r3,28
 821c17c:	10c5883a 	add	r2,r2,r3
 821c180:	10c00304 	addi	r3,r2,12
 821c184:	008208b4 	movhi	r2,2082
 821c188:	108f6a04 	addi	r2,r2,15784
 821c18c:	18800015 	stw	r2,0(r3)
 821c190:	e0bffc17 	ldw	r2,-16(fp)
 821c194:	10c00724 	muli	r3,r2,28
 821c198:	008209b4 	movhi	r2,2086
 821c19c:	10b55504 	addi	r2,r2,-10924
 821c1a0:	1885883a 	add	r2,r3,r2
 821c1a4:	d0e02e04 	addi	r3,gp,-32584
 821c1a8:	e0fffe15 	stw	r3,-8(fp)
 821c1ac:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 821c1b0:	e0bfff17 	ldw	r2,-4(fp)
 821c1b4:	e0fffe17 	ldw	r3,-8(fp)
 821c1b8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 821c1bc:	e0bffe17 	ldw	r2,-8(fp)
 821c1c0:	10c00017 	ldw	r3,0(r2)
 821c1c4:	e0bfff17 	ldw	r2,-4(fp)
 821c1c8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 821c1cc:	e0bffe17 	ldw	r2,-8(fp)
 821c1d0:	10800017 	ldw	r2,0(r2)
 821c1d4:	e0ffff17 	ldw	r3,-4(fp)
 821c1d8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 821c1dc:	e0bffe17 	ldw	r2,-8(fp)
 821c1e0:	e0ffff17 	ldw	r3,-4(fp)
 821c1e4:	10c00015 	stw	r3,0(r2)
 821c1e8:	d0a08003 	ldbu	r2,-32256(gp)
 821c1ec:	11003fcc 	andi	r4,r2,255
 821c1f0:	e0bffc17 	ldw	r2,-16(fp)
 821c1f4:	10c00724 	muli	r3,r2,28
 821c1f8:	008209b4 	movhi	r2,2086
 821c1fc:	10b55504 	addi	r2,r2,-10924
 821c200:	1887883a 	add	r3,r3,r2
 821c204:	008209b4 	movhi	r2,2086
 821c208:	10b59504 	addi	r2,r2,-10668
 821c20c:	21000324 	muli	r4,r4,12
 821c210:	1105883a 	add	r2,r2,r4
 821c214:	10c00015 	stw	r3,0(r2)
 821c218:	d0a08003 	ldbu	r2,-32256(gp)
 821c21c:	10c03fcc 	andi	r3,r2,255
 821c220:	008209b4 	movhi	r2,2086
 821c224:	10b59504 	addi	r2,r2,-10668
 821c228:	18c00324 	muli	r3,r3,12
 821c22c:	10c5883a 	add	r2,r2,r3
 821c230:	10c00104 	addi	r3,r2,4
 821c234:	00820034 	movhi	r2,2048
 821c238:	108c0004 	addi	r2,r2,12288
 821c23c:	18800015 	stw	r2,0(r3)
 821c240:	d0a08003 	ldbu	r2,-32256(gp)
 821c244:	10c03fcc 	andi	r3,r2,255
 821c248:	e0bffc17 	ldw	r2,-16(fp)
 821c24c:	1009883a 	mov	r4,r2
 821c250:	008209b4 	movhi	r2,2086
 821c254:	10b59504 	addi	r2,r2,-10668
 821c258:	18c00324 	muli	r3,r3,12
 821c25c:	10c5883a 	add	r2,r2,r3
 821c260:	10800204 	addi	r2,r2,8
 821c264:	11000005 	stb	r4,0(r2)
 821c268:	d0a08003 	ldbu	r2,-32256(gp)
 821c26c:	10800044 	addi	r2,r2,1
 821c270:	d0a08005 	stb	r2,-32256(gp)
 821c274:	e0bffc17 	ldw	r2,-16(fp)
 821c278:	10800044 	addi	r2,r2,1
 821c27c:	e0bffc15 	stw	r2,-16(fp)
 821c280:	e0fffc17 	ldw	r3,-16(fp)
 821c284:	e0bffd17 	ldw	r2,-12(fp)
 821c288:	18bfa316 	blt	r3,r2,821c118 <alt_sys_init+0xac>
}
 821c28c:	0001883a 	nop
 821c290:	e037883a 	mov	sp,fp
 821c294:	dfc00117 	ldw	ra,4(sp)
 821c298:	df000017 	ldw	fp,0(sp)
 821c29c:	dec00204 	addi	sp,sp,8
 821c2a0:	f800283a 	ret

0821c2a4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 821c2a4:	defffa04 	addi	sp,sp,-24
 821c2a8:	dfc00515 	stw	ra,20(sp)
 821c2ac:	df000415 	stw	fp,16(sp)
 821c2b0:	df000404 	addi	fp,sp,16
 821c2b4:	e13ffd15 	stw	r4,-12(fp)
 821c2b8:	e17ffe15 	stw	r5,-8(fp)
 821c2bc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c2c0:	e0bffd17 	ldw	r2,-12(fp)
 821c2c4:	10800017 	ldw	r2,0(r2)
 821c2c8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 821c2cc:	e0bffc17 	ldw	r2,-16(fp)
 821c2d0:	10c00a04 	addi	r3,r2,40
 821c2d4:	e0bffd17 	ldw	r2,-12(fp)
 821c2d8:	10800217 	ldw	r2,8(r2)
 821c2dc:	100f883a 	mov	r7,r2
 821c2e0:	e1bfff17 	ldw	r6,-4(fp)
 821c2e4:	e17ffe17 	ldw	r5,-8(fp)
 821c2e8:	1809883a 	mov	r4,r3
 821c2ec:	821ca500 	call	821ca50 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 821c2f0:	e037883a 	mov	sp,fp
 821c2f4:	dfc00117 	ldw	ra,4(sp)
 821c2f8:	df000017 	ldw	fp,0(sp)
 821c2fc:	dec00204 	addi	sp,sp,8
 821c300:	f800283a 	ret

0821c304 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821c304:	defffa04 	addi	sp,sp,-24
 821c308:	dfc00515 	stw	ra,20(sp)
 821c30c:	df000415 	stw	fp,16(sp)
 821c310:	df000404 	addi	fp,sp,16
 821c314:	e13ffd15 	stw	r4,-12(fp)
 821c318:	e17ffe15 	stw	r5,-8(fp)
 821c31c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c320:	e0bffd17 	ldw	r2,-12(fp)
 821c324:	10800017 	ldw	r2,0(r2)
 821c328:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 821c32c:	e0bffc17 	ldw	r2,-16(fp)
 821c330:	10c00a04 	addi	r3,r2,40
 821c334:	e0bffd17 	ldw	r2,-12(fp)
 821c338:	10800217 	ldw	r2,8(r2)
 821c33c:	100f883a 	mov	r7,r2
 821c340:	e1bfff17 	ldw	r6,-4(fp)
 821c344:	e17ffe17 	ldw	r5,-8(fp)
 821c348:	1809883a 	mov	r4,r3
 821c34c:	821cd0c0 	call	821cd0c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 821c350:	e037883a 	mov	sp,fp
 821c354:	dfc00117 	ldw	ra,4(sp)
 821c358:	df000017 	ldw	fp,0(sp)
 821c35c:	dec00204 	addi	sp,sp,8
 821c360:	f800283a 	ret

0821c364 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 821c364:	defffc04 	addi	sp,sp,-16
 821c368:	dfc00315 	stw	ra,12(sp)
 821c36c:	df000215 	stw	fp,8(sp)
 821c370:	df000204 	addi	fp,sp,8
 821c374:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c378:	e0bfff17 	ldw	r2,-4(fp)
 821c37c:	10800017 	ldw	r2,0(r2)
 821c380:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 821c384:	e0bffe17 	ldw	r2,-8(fp)
 821c388:	10c00a04 	addi	r3,r2,40
 821c38c:	e0bfff17 	ldw	r2,-4(fp)
 821c390:	10800217 	ldw	r2,8(r2)
 821c394:	100b883a 	mov	r5,r2
 821c398:	1809883a 	mov	r4,r3
 821c39c:	821c8f80 	call	821c8f8 <altera_avalon_jtag_uart_close>
}
 821c3a0:	e037883a 	mov	sp,fp
 821c3a4:	dfc00117 	ldw	ra,4(sp)
 821c3a8:	df000017 	ldw	fp,0(sp)
 821c3ac:	dec00204 	addi	sp,sp,8
 821c3b0:	f800283a 	ret

0821c3b4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 821c3b4:	defffa04 	addi	sp,sp,-24
 821c3b8:	dfc00515 	stw	ra,20(sp)
 821c3bc:	df000415 	stw	fp,16(sp)
 821c3c0:	df000404 	addi	fp,sp,16
 821c3c4:	e13ffd15 	stw	r4,-12(fp)
 821c3c8:	e17ffe15 	stw	r5,-8(fp)
 821c3cc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 821c3d0:	e0bffd17 	ldw	r2,-12(fp)
 821c3d4:	10800017 	ldw	r2,0(r2)
 821c3d8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 821c3dc:	e0bffc17 	ldw	r2,-16(fp)
 821c3e0:	10800a04 	addi	r2,r2,40
 821c3e4:	e1bfff17 	ldw	r6,-4(fp)
 821c3e8:	e17ffe17 	ldw	r5,-8(fp)
 821c3ec:	1009883a 	mov	r4,r2
 821c3f0:	821c9600 	call	821c960 <altera_avalon_jtag_uart_ioctl>
}
 821c3f4:	e037883a 	mov	sp,fp
 821c3f8:	dfc00117 	ldw	ra,4(sp)
 821c3fc:	df000017 	ldw	fp,0(sp)
 821c400:	dec00204 	addi	sp,sp,8
 821c404:	f800283a 	ret

0821c408 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 821c408:	defff104 	addi	sp,sp,-60
 821c40c:	dfc00e15 	stw	ra,56(sp)
 821c410:	df000d15 	stw	fp,52(sp)
 821c414:	df000d04 	addi	fp,sp,52
 821c418:	e13ff915 	stw	r4,-28(fp)
 821c41c:	e17ffa15 	stw	r5,-24(fp)
 821c420:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 821c424:	e0bff917 	ldw	r2,-28(fp)
 821c428:	10800c04 	addi	r2,r2,48
 821c42c:	e0bff415 	stw	r2,-48(fp)
 821c430:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 821c434:	e0bff80b 	ldhu	r2,-32(fp)
 821c438:	e0fff884 	addi	r3,fp,-30
 821c43c:	180b883a 	mov	r5,r3
 821c440:	1009883a 	mov	r4,r2
 821c444:	8216cdc0 	call	8216cdc <OSFlagCreate>
 821c448:	1007883a 	mov	r3,r2
 821c44c:	e0bff417 	ldw	r2,-48(fp)
 821c450:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 821c454:	e0bff917 	ldw	r2,-28(fp)
 821c458:	10800a04 	addi	r2,r2,40
 821c45c:	e0bff515 	stw	r2,-44(fp)
 821c460:	00800044 	movi	r2,1
 821c464:	e0bff78d 	sth	r2,-34(fp)
 821c468:	e0bff78b 	ldhu	r2,-34(fp)
 821c46c:	1009883a 	mov	r4,r2
 821c470:	82199f00 	call	82199f0 <OSSemCreate>
 821c474:	1007883a 	mov	r3,r2
 821c478:	e0bff517 	ldw	r2,-44(fp)
 821c47c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 821c480:	e0bff917 	ldw	r2,-28(fp)
 821c484:	10800b04 	addi	r2,r2,44
 821c488:	e0bff615 	stw	r2,-40(fp)
 821c48c:	00800044 	movi	r2,1
 821c490:	e0bff70d 	sth	r2,-36(fp)
 821c494:	e0bff70b 	ldhu	r2,-36(fp)
 821c498:	1009883a 	mov	r4,r2
 821c49c:	82199f00 	call	82199f0 <OSSemCreate>
 821c4a0:	1007883a 	mov	r3,r2
 821c4a4:	e0bff617 	ldw	r2,-40(fp)
 821c4a8:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c4ac:	e0bff917 	ldw	r2,-28(fp)
 821c4b0:	00c00044 	movi	r3,1
 821c4b4:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 821c4b8:	e0bff917 	ldw	r2,-28(fp)
 821c4bc:	10800017 	ldw	r2,0(r2)
 821c4c0:	10800104 	addi	r2,r2,4
 821c4c4:	1007883a 	mov	r3,r2
 821c4c8:	e0bff917 	ldw	r2,-28(fp)
 821c4cc:	10800817 	ldw	r2,32(r2)
 821c4d0:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 821c4d4:	e0bffa17 	ldw	r2,-24(fp)
 821c4d8:	e0fffb17 	ldw	r3,-20(fp)
 821c4dc:	d8000015 	stw	zero,0(sp)
 821c4e0:	e1fff917 	ldw	r7,-28(fp)
 821c4e4:	018208b4 	movhi	r6,2082
 821c4e8:	31b15404 	addi	r6,r6,-15024
 821c4ec:	180b883a 	mov	r5,r3
 821c4f0:	1009883a 	mov	r4,r2
 821c4f4:	823bd6c0 	call	823bd6c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 821c4f8:	e0bff917 	ldw	r2,-28(fp)
 821c4fc:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 821c500:	e0bff917 	ldw	r2,-28(fp)
 821c504:	10800204 	addi	r2,r2,8
 821c508:	d0e0b817 	ldw	r3,-32032(gp)
 821c50c:	e1fff917 	ldw	r7,-28(fp)
 821c510:	018208b4 	movhi	r6,2082
 821c514:	31b1fd04 	addi	r6,r6,-14348
 821c518:	180b883a 	mov	r5,r3
 821c51c:	1009883a 	mov	r4,r2
 821c520:	823b7080 	call	823b708 <alt_alarm_start>
 821c524:	1000040e 	bge	r2,zero,821c538 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 821c528:	e0fff917 	ldw	r3,-28(fp)
 821c52c:	00a00034 	movhi	r2,32768
 821c530:	10bfffc4 	addi	r2,r2,-1
 821c534:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 821c538:	0001883a 	nop
 821c53c:	e037883a 	mov	sp,fp
 821c540:	dfc00117 	ldw	ra,4(sp)
 821c544:	df000017 	ldw	fp,0(sp)
 821c548:	dec00204 	addi	sp,sp,8
 821c54c:	f800283a 	ret

0821c550 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 821c550:	defff204 	addi	sp,sp,-56
 821c554:	dfc00d15 	stw	ra,52(sp)
 821c558:	df000c15 	stw	fp,48(sp)
 821c55c:	df000c04 	addi	fp,sp,48
 821c560:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 821c564:	e0bfff17 	ldw	r2,-4(fp)
 821c568:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
 821c56c:	e0bff617 	ldw	r2,-40(fp)
 821c570:	10800017 	ldw	r2,0(r2)
 821c574:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c578:	e0bff717 	ldw	r2,-36(fp)
 821c57c:	10800104 	addi	r2,r2,4
 821c580:	10800037 	ldwio	r2,0(r2)
 821c584:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 821c588:	e0bff817 	ldw	r2,-32(fp)
 821c58c:	1080c00c 	andi	r2,r2,768
 821c590:	10009126 	beq	r2,zero,821c7d8 <altera_avalon_jtag_uart_irq+0x288>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 821c594:	e0bff817 	ldw	r2,-32(fp)
 821c598:	1080400c 	andi	r2,r2,256
 821c59c:	10004726 	beq	r2,zero,821c6bc <altera_avalon_jtag_uart_irq+0x16c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 821c5a0:	00800074 	movhi	r2,1
 821c5a4:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c5a8:	e0bff617 	ldw	r2,-40(fp)
 821c5ac:	10800d17 	ldw	r2,52(r2)
 821c5b0:	10800044 	addi	r2,r2,1
 821c5b4:	1081ffcc 	andi	r2,r2,2047
 821c5b8:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 821c5bc:	e0bff617 	ldw	r2,-40(fp)
 821c5c0:	10c00e17 	ldw	r3,56(r2)
 821c5c4:	e0bff917 	ldw	r2,-28(fp)
 821c5c8:	18802726 	beq	r3,r2,821c668 <altera_avalon_jtag_uart_irq+0x118>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 821c5cc:	e0bff717 	ldw	r2,-36(fp)
 821c5d0:	10800037 	ldwio	r2,0(r2)
 821c5d4:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 821c5d8:	e0bff417 	ldw	r2,-48(fp)
 821c5dc:	10a0000c 	andi	r2,r2,32768
 821c5e0:	10002326 	beq	r2,zero,821c670 <altera_avalon_jtag_uart_irq+0x120>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 821c5e4:	e0bff617 	ldw	r2,-40(fp)
 821c5e8:	10800d17 	ldw	r2,52(r2)
 821c5ec:	e0fff417 	ldw	r3,-48(fp)
 821c5f0:	1809883a 	mov	r4,r3
 821c5f4:	e0fff617 	ldw	r3,-40(fp)
 821c5f8:	1885883a 	add	r2,r3,r2
 821c5fc:	10801104 	addi	r2,r2,68
 821c600:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c604:	e0bff617 	ldw	r2,-40(fp)
 821c608:	10800d17 	ldw	r2,52(r2)
 821c60c:	10800044 	addi	r2,r2,1
 821c610:	10c1ffcc 	andi	r3,r2,2047
 821c614:	e0bff617 	ldw	r2,-40(fp)
 821c618:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 821c61c:	e0bff617 	ldw	r2,-40(fp)
 821c620:	10800c17 	ldw	r2,48(r2)
 821c624:	e0bffb15 	stw	r2,-20(fp)
 821c628:	00800044 	movi	r2,1
 821c62c:	e0bffc0d 	sth	r2,-16(fp)
 821c630:	00800044 	movi	r2,1
 821c634:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c638:	d0a06b43 	ldbu	r2,-32339(gp)
 821c63c:	10803fcc 	andi	r2,r2,255
 821c640:	103fd926 	beq	r2,zero,821c5a8 <altera_avalon_jtag_uart_irq+0x58>
  {
    OSFlagPost (group, flags, opt, &err);
 821c644:	e0bffc0b 	ldhu	r2,-16(fp)
 821c648:	e0fffc83 	ldbu	r3,-14(fp)
 821c64c:	e13ffdc4 	addi	r4,fp,-9
 821c650:	200f883a 	mov	r7,r4
 821c654:	180d883a 	mov	r6,r3
 821c658:	100b883a 	mov	r5,r2
 821c65c:	e13ffb17 	ldw	r4,-20(fp)
 821c660:	82178b80 	call	82178b8 <OSFlagPost>
      }
 821c664:	003fd006 	br	821c5a8 <altera_avalon_jtag_uart_irq+0x58>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 821c668:	0001883a 	nop
 821c66c:	00000106 	br	821c674 <altera_avalon_jtag_uart_irq+0x124>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 821c670:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 821c674:	e0bff417 	ldw	r2,-48(fp)
 821c678:	10bfffec 	andhi	r2,r2,65535
 821c67c:	10000f26 	beq	r2,zero,821c6bc <altera_avalon_jtag_uart_irq+0x16c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c680:	e0bff617 	ldw	r2,-40(fp)
 821c684:	10c00817 	ldw	r3,32(r2)
 821c688:	00bfff84 	movi	r2,-2
 821c68c:	1886703a 	and	r3,r3,r2
 821c690:	e0bff617 	ldw	r2,-40(fp)
 821c694:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 821c698:	e0bff717 	ldw	r2,-36(fp)
 821c69c:	10800104 	addi	r2,r2,4
 821c6a0:	1007883a 	mov	r3,r2
 821c6a4:	e0bff617 	ldw	r2,-40(fp)
 821c6a8:	10800817 	ldw	r2,32(r2)
 821c6ac:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c6b0:	e0bff717 	ldw	r2,-36(fp)
 821c6b4:	10800104 	addi	r2,r2,4
 821c6b8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 821c6bc:	e0bff817 	ldw	r2,-32(fp)
 821c6c0:	1080800c 	andi	r2,r2,512
 821c6c4:	103fac26 	beq	r2,zero,821c578 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 821c6c8:	e0bff817 	ldw	r2,-32(fp)
 821c6cc:	1004d43a 	srli	r2,r2,16
 821c6d0:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 821c6d4:	00002606 	br	821c770 <altera_avalon_jtag_uart_irq+0x220>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 821c6d8:	e0bff717 	ldw	r2,-36(fp)
 821c6dc:	e0fff617 	ldw	r3,-40(fp)
 821c6e0:	18c01017 	ldw	r3,64(r3)
 821c6e4:	e13ff617 	ldw	r4,-40(fp)
 821c6e8:	20c7883a 	add	r3,r4,r3
 821c6ec:	18c21104 	addi	r3,r3,2116
 821c6f0:	18c00003 	ldbu	r3,0(r3)
 821c6f4:	18c03fcc 	andi	r3,r3,255
 821c6f8:	18c0201c 	xori	r3,r3,128
 821c6fc:	18ffe004 	addi	r3,r3,-128
 821c700:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c704:	e0bff617 	ldw	r2,-40(fp)
 821c708:	10801017 	ldw	r2,64(r2)
 821c70c:	10800044 	addi	r2,r2,1
 821c710:	10c1ffcc 	andi	r3,r2,2047
 821c714:	e0bff617 	ldw	r2,-40(fp)
 821c718:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 821c71c:	e0bff617 	ldw	r2,-40(fp)
 821c720:	10800c17 	ldw	r2,48(r2)
 821c724:	e0bffa15 	stw	r2,-24(fp)
 821c728:	00800084 	movi	r2,2
 821c72c:	e0bffd0d 	sth	r2,-12(fp)
 821c730:	00800044 	movi	r2,1
 821c734:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c738:	d0a06b43 	ldbu	r2,-32339(gp)
 821c73c:	10803fcc 	andi	r2,r2,255
 821c740:	10000826 	beq	r2,zero,821c764 <altera_avalon_jtag_uart_irq+0x214>
  {
    OSFlagPost (group, flags, opt, &err);
 821c744:	e0bffd0b 	ldhu	r2,-12(fp)
 821c748:	e0fffd83 	ldbu	r3,-10(fp)
 821c74c:	e13ffe04 	addi	r4,fp,-8
 821c750:	200f883a 	mov	r7,r4
 821c754:	180d883a 	mov	r6,r3
 821c758:	100b883a 	mov	r5,r2
 821c75c:	e13ffa17 	ldw	r4,-24(fp)
 821c760:	82178b80 	call	82178b8 <OSFlagPost>

        space--;
 821c764:	e0bff517 	ldw	r2,-44(fp)
 821c768:	10bfffc4 	addi	r2,r2,-1
 821c76c:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 821c770:	e0bff517 	ldw	r2,-44(fp)
 821c774:	10000526 	beq	r2,zero,821c78c <altera_avalon_jtag_uart_irq+0x23c>
 821c778:	e0bff617 	ldw	r2,-40(fp)
 821c77c:	10c01017 	ldw	r3,64(r2)
 821c780:	e0bff617 	ldw	r2,-40(fp)
 821c784:	10800f17 	ldw	r2,60(r2)
 821c788:	18bfd31e 	bne	r3,r2,821c6d8 <altera_avalon_jtag_uart_irq+0x188>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 821c78c:	e0bff517 	ldw	r2,-44(fp)
 821c790:	103f7926 	beq	r2,zero,821c578 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821c794:	e0bff617 	ldw	r2,-40(fp)
 821c798:	10c00817 	ldw	r3,32(r2)
 821c79c:	00bfff44 	movi	r2,-3
 821c7a0:	1886703a 	and	r3,r3,r2
 821c7a4:	e0bff617 	ldw	r2,-40(fp)
 821c7a8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821c7ac:	e0bff617 	ldw	r2,-40(fp)
 821c7b0:	10800017 	ldw	r2,0(r2)
 821c7b4:	10800104 	addi	r2,r2,4
 821c7b8:	1007883a 	mov	r3,r2
 821c7bc:	e0bff617 	ldw	r2,-40(fp)
 821c7c0:	10800817 	ldw	r2,32(r2)
 821c7c4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c7c8:	e0bff717 	ldw	r2,-36(fp)
 821c7cc:	10800104 	addi	r2,r2,4
 821c7d0:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 821c7d4:	003f6806 	br	821c578 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 821c7d8:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 821c7dc:	0001883a 	nop
 821c7e0:	e037883a 	mov	sp,fp
 821c7e4:	dfc00117 	ldw	ra,4(sp)
 821c7e8:	df000017 	ldw	fp,0(sp)
 821c7ec:	dec00204 	addi	sp,sp,8
 821c7f0:	f800283a 	ret

0821c7f4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 821c7f4:	defff904 	addi	sp,sp,-28
 821c7f8:	dfc00615 	stw	ra,24(sp)
 821c7fc:	df000515 	stw	fp,20(sp)
 821c800:	df000504 	addi	fp,sp,20
 821c804:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 821c808:	e0bfff17 	ldw	r2,-4(fp)
 821c80c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 821c810:	e0bffb17 	ldw	r2,-20(fp)
 821c814:	10800017 	ldw	r2,0(r2)
 821c818:	10800104 	addi	r2,r2,4
 821c81c:	10800037 	ldwio	r2,0(r2)
 821c820:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 821c824:	e0bffc17 	ldw	r2,-16(fp)
 821c828:	1081000c 	andi	r2,r2,1024
 821c82c:	10000b26 	beq	r2,zero,821c85c <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 821c830:	e0bffb17 	ldw	r2,-20(fp)
 821c834:	10800017 	ldw	r2,0(r2)
 821c838:	10800104 	addi	r2,r2,4
 821c83c:	1007883a 	mov	r3,r2
 821c840:	e0bffb17 	ldw	r2,-20(fp)
 821c844:	10800817 	ldw	r2,32(r2)
 821c848:	10810014 	ori	r2,r2,1024
 821c84c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 821c850:	e0bffb17 	ldw	r2,-20(fp)
 821c854:	10000915 	stw	zero,36(r2)
 821c858:	00002106 	br	821c8e0 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 821c85c:	e0bffb17 	ldw	r2,-20(fp)
 821c860:	10c00917 	ldw	r3,36(r2)
 821c864:	00a00034 	movhi	r2,32768
 821c868:	10bfff04 	addi	r2,r2,-4
 821c86c:	10c01c36 	bltu	r2,r3,821c8e0 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 821c870:	e0bffb17 	ldw	r2,-20(fp)
 821c874:	10800917 	ldw	r2,36(r2)
 821c878:	10c00044 	addi	r3,r2,1
 821c87c:	e0bffb17 	ldw	r2,-20(fp)
 821c880:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 821c884:	e0bffb17 	ldw	r2,-20(fp)
 821c888:	10c00917 	ldw	r3,36(r2)
 821c88c:	e0bffb17 	ldw	r2,-20(fp)
 821c890:	10800117 	ldw	r2,4(r2)
 821c894:	18801236 	bltu	r3,r2,821c8e0 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 821c898:	e0bffb17 	ldw	r2,-20(fp)
 821c89c:	10800c17 	ldw	r2,48(r2)
 821c8a0:	e0bffd15 	stw	r2,-12(fp)
 821c8a4:	00800104 	movi	r2,4
 821c8a8:	e0bffe0d 	sth	r2,-8(fp)
 821c8ac:	00800044 	movi	r2,1
 821c8b0:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c8b4:	d0a06b43 	ldbu	r2,-32339(gp)
 821c8b8:	10803fcc 	andi	r2,r2,255
 821c8bc:	10000826 	beq	r2,zero,821c8e0 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 821c8c0:	e0bffe0b 	ldhu	r2,-8(fp)
 821c8c4:	e0fffe83 	ldbu	r3,-6(fp)
 821c8c8:	e13ffec4 	addi	r4,fp,-5
 821c8cc:	200f883a 	mov	r7,r4
 821c8d0:	180d883a 	mov	r6,r3
 821c8d4:	100b883a 	mov	r5,r2
 821c8d8:	e13ffd17 	ldw	r4,-12(fp)
 821c8dc:	82178b80 	call	82178b8 <OSFlagPost>
 821c8e0:	d0a0b817 	ldw	r2,-32032(gp)
    }
  }

  return alt_ticks_per_second();
}
 821c8e4:	e037883a 	mov	sp,fp
 821c8e8:	dfc00117 	ldw	ra,4(sp)
 821c8ec:	df000017 	ldw	fp,0(sp)
 821c8f0:	dec00204 	addi	sp,sp,8
 821c8f4:	f800283a 	ret

0821c8f8 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 821c8f8:	defffd04 	addi	sp,sp,-12
 821c8fc:	df000215 	stw	fp,8(sp)
 821c900:	df000204 	addi	fp,sp,8
 821c904:	e13ffe15 	stw	r4,-8(fp)
 821c908:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821c90c:	00000506 	br	821c924 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 821c910:	e0bfff17 	ldw	r2,-4(fp)
 821c914:	1090000c 	andi	r2,r2,16384
 821c918:	10000226 	beq	r2,zero,821c924 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 821c91c:	00bffd44 	movi	r2,-11
 821c920:	00000b06 	br	821c950 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821c924:	e0bffe17 	ldw	r2,-8(fp)
 821c928:	10c01017 	ldw	r3,64(r2)
 821c92c:	e0bffe17 	ldw	r2,-8(fp)
 821c930:	10800f17 	ldw	r2,60(r2)
 821c934:	18800526 	beq	r3,r2,821c94c <altera_avalon_jtag_uart_close+0x54>
 821c938:	e0bffe17 	ldw	r2,-8(fp)
 821c93c:	10c00917 	ldw	r3,36(r2)
 821c940:	e0bffe17 	ldw	r2,-8(fp)
 821c944:	10800117 	ldw	r2,4(r2)
 821c948:	18bff136 	bltu	r3,r2,821c910 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 821c94c:	0005883a 	mov	r2,zero
}
 821c950:	e037883a 	mov	sp,fp
 821c954:	df000017 	ldw	fp,0(sp)
 821c958:	dec00104 	addi	sp,sp,4
 821c95c:	f800283a 	ret

0821c960 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 821c960:	defffa04 	addi	sp,sp,-24
 821c964:	df000515 	stw	fp,20(sp)
 821c968:	df000504 	addi	fp,sp,20
 821c96c:	e13ffd15 	stw	r4,-12(fp)
 821c970:	e17ffe15 	stw	r5,-8(fp)
 821c974:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 821c978:	00bff9c4 	movi	r2,-25
 821c97c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 821c980:	e0bffe17 	ldw	r2,-8(fp)
 821c984:	10da8060 	cmpeqi	r3,r2,27137
 821c988:	1800031e 	bne	r3,zero,821c998 <altera_avalon_jtag_uart_ioctl+0x38>
 821c98c:	109a80a0 	cmpeqi	r2,r2,27138
 821c990:	1000181e 	bne	r2,zero,821c9f4 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 821c994:	00002906 	br	821ca3c <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 821c998:	e0bffd17 	ldw	r2,-12(fp)
 821c99c:	10c00117 	ldw	r3,4(r2)
 821c9a0:	00a00034 	movhi	r2,32768
 821c9a4:	10bfffc4 	addi	r2,r2,-1
 821c9a8:	18802126 	beq	r3,r2,821ca30 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 821c9ac:	e0bfff17 	ldw	r2,-4(fp)
 821c9b0:	10800017 	ldw	r2,0(r2)
 821c9b4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 821c9b8:	e0bffc17 	ldw	r2,-16(fp)
 821c9bc:	10800090 	cmplti	r2,r2,2
 821c9c0:	1000061e 	bne	r2,zero,821c9dc <altera_avalon_jtag_uart_ioctl+0x7c>
 821c9c4:	e0fffc17 	ldw	r3,-16(fp)
 821c9c8:	00a00034 	movhi	r2,32768
 821c9cc:	10bfffc4 	addi	r2,r2,-1
 821c9d0:	18800226 	beq	r3,r2,821c9dc <altera_avalon_jtag_uart_ioctl+0x7c>
 821c9d4:	e0bffc17 	ldw	r2,-16(fp)
 821c9d8:	00000206 	br	821c9e4 <altera_avalon_jtag_uart_ioctl+0x84>
 821c9dc:	00a00034 	movhi	r2,32768
 821c9e0:	10bfff84 	addi	r2,r2,-2
 821c9e4:	e0fffd17 	ldw	r3,-12(fp)
 821c9e8:	18800115 	stw	r2,4(r3)
      rc = 0;
 821c9ec:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821c9f0:	00000f06 	br	821ca30 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 821c9f4:	e0bffd17 	ldw	r2,-12(fp)
 821c9f8:	10c00117 	ldw	r3,4(r2)
 821c9fc:	00a00034 	movhi	r2,32768
 821ca00:	10bfffc4 	addi	r2,r2,-1
 821ca04:	18800c26 	beq	r3,r2,821ca38 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 821ca08:	e0bffd17 	ldw	r2,-12(fp)
 821ca0c:	10c00917 	ldw	r3,36(r2)
 821ca10:	e0bffd17 	ldw	r2,-12(fp)
 821ca14:	10800117 	ldw	r2,4(r2)
 821ca18:	1885803a 	cmpltu	r2,r3,r2
 821ca1c:	10c03fcc 	andi	r3,r2,255
 821ca20:	e0bfff17 	ldw	r2,-4(fp)
 821ca24:	10c00015 	stw	r3,0(r2)
      rc = 0;
 821ca28:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821ca2c:	00000206 	br	821ca38 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 821ca30:	0001883a 	nop
 821ca34:	00000106 	br	821ca3c <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 821ca38:	0001883a 	nop

  default:
    break;
  }

  return rc;
 821ca3c:	e0bffb17 	ldw	r2,-20(fp)
}
 821ca40:	e037883a 	mov	sp,fp
 821ca44:	df000017 	ldw	fp,0(sp)
 821ca48:	dec00104 	addi	sp,sp,4
 821ca4c:	f800283a 	ret

0821ca50 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 821ca50:	deffed04 	addi	sp,sp,-76
 821ca54:	dfc01215 	stw	ra,72(sp)
 821ca58:	df001115 	stw	fp,68(sp)
 821ca5c:	df001104 	addi	fp,sp,68
 821ca60:	e13ffc15 	stw	r4,-16(fp)
 821ca64:	e17ffd15 	stw	r5,-12(fp)
 821ca68:	e1bffe15 	stw	r6,-8(fp)
 821ca6c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 821ca70:	e0bffd17 	ldw	r2,-12(fp)
 821ca74:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 821ca78:	e0bffc17 	ldw	r2,-16(fp)
 821ca7c:	10800a17 	ldw	r2,40(r2)
 821ca80:	e0bff815 	stw	r2,-32(fp)
 821ca84:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 821ca88:	e0bff90b 	ldhu	r2,-28(fp)
 821ca8c:	e0fffb04 	addi	r3,fp,-20
 821ca90:	180d883a 	mov	r6,r3
 821ca94:	100b883a 	mov	r5,r2
 821ca98:	e13ff817 	ldw	r4,-32(fp)
 821ca9c:	8219d080 	call	8219d08 <OSSemPend>

  while (space > 0)
 821caa0:	00006106 	br	821cc28 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 821caa4:	e0bffc17 	ldw	r2,-16(fp)
 821caa8:	10800d17 	ldw	r2,52(r2)
 821caac:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
 821cab0:	e0bffc17 	ldw	r2,-16(fp)
 821cab4:	10800e17 	ldw	r2,56(r2)
 821cab8:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
 821cabc:	e0fff317 	ldw	r3,-52(fp)
 821cac0:	e0bff417 	ldw	r2,-48(fp)
 821cac4:	18800536 	bltu	r3,r2,821cadc <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 821cac8:	e0fff317 	ldw	r3,-52(fp)
 821cacc:	e0bff417 	ldw	r2,-48(fp)
 821cad0:	1885c83a 	sub	r2,r3,r2
 821cad4:	e0bff115 	stw	r2,-60(fp)
 821cad8:	00000406 	br	821caec <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 821cadc:	00c20004 	movi	r3,2048
 821cae0:	e0bff417 	ldw	r2,-48(fp)
 821cae4:	1885c83a 	sub	r2,r3,r2
 821cae8:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821caec:	e0bff117 	ldw	r2,-60(fp)
 821caf0:	10001e26 	beq	r2,zero,821cb6c <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 821caf4:	e0fffe17 	ldw	r3,-8(fp)
 821caf8:	e0bff117 	ldw	r2,-60(fp)
 821cafc:	1880022e 	bgeu	r3,r2,821cb08 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 821cb00:	e0bffe17 	ldw	r2,-8(fp)
 821cb04:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 821cb08:	e0bffc17 	ldw	r2,-16(fp)
 821cb0c:	10c01104 	addi	r3,r2,68
 821cb10:	e0bff417 	ldw	r2,-48(fp)
 821cb14:	1885883a 	add	r2,r3,r2
 821cb18:	e1bff117 	ldw	r6,-60(fp)
 821cb1c:	100b883a 	mov	r5,r2
 821cb20:	e13ff017 	ldw	r4,-64(fp)
 821cb24:	8202a0c0 	call	8202a0c <memcpy>
      ptr   += n;
 821cb28:	e0fff017 	ldw	r3,-64(fp)
 821cb2c:	e0bff117 	ldw	r2,-60(fp)
 821cb30:	1885883a 	add	r2,r3,r2
 821cb34:	e0bff015 	stw	r2,-64(fp)
      space -= n;
 821cb38:	e0fffe17 	ldw	r3,-8(fp)
 821cb3c:	e0bff117 	ldw	r2,-60(fp)
 821cb40:	1885c83a 	sub	r2,r3,r2
 821cb44:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cb48:	e0fff417 	ldw	r3,-48(fp)
 821cb4c:	e0bff117 	ldw	r2,-60(fp)
 821cb50:	1885883a 	add	r2,r3,r2
 821cb54:	10c1ffcc 	andi	r3,r2,2047
 821cb58:	e0bffc17 	ldw	r2,-16(fp)
 821cb5c:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 821cb60:	e0bffe17 	ldw	r2,-8(fp)
 821cb64:	00bfcf16 	blt	zero,r2,821caa4 <altera_avalon_jtag_uart_read+0x54>
 821cb68:	00000106 	br	821cb70 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 821cb6c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 821cb70:	e0fff017 	ldw	r3,-64(fp)
 821cb74:	e0bffd17 	ldw	r2,-12(fp)
 821cb78:	18802e1e 	bne	r3,r2,821cc34 <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 821cb7c:	e0bfff17 	ldw	r2,-4(fp)
 821cb80:	1090000c 	andi	r2,r2,16384
 821cb84:	10002d1e 	bne	r2,zero,821cc3c <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 821cb88:	d0a06b43 	ldbu	r2,-32339(gp)
 821cb8c:	10803fcc 	andi	r2,r2,255
 821cb90:	10800058 	cmpnei	r2,r2,1
 821cb94:	1000161e 	bne	r2,zero,821cbf0 <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 821cb98:	e0bffc17 	ldw	r2,-16(fp)
 821cb9c:	10800c17 	ldw	r2,48(r2)
 821cba0:	e0bff215 	stw	r2,-56(fp)
 821cba4:	00800144 	movi	r2,5
 821cba8:	e0bff98d 	sth	r2,-26(fp)
 821cbac:	00bfe0c4 	movi	r2,-125
 821cbb0:	e0bffa05 	stb	r2,-24(fp)
 821cbb4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821cbb8:	d0a06b43 	ldbu	r2,-32339(gp)
 821cbbc:	10803fcc 	andi	r2,r2,255
 821cbc0:	10001526 	beq	r2,zero,821cc18 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821cbc4:	e0fff98b 	ldhu	r3,-26(fp)
 821cbc8:	e13ffa03 	ldbu	r4,-24(fp)
 821cbcc:	e17ffa8b 	ldhu	r5,-22(fp)
 821cbd0:	e0bffb44 	addi	r2,fp,-19
 821cbd4:	d8800015 	stw	r2,0(sp)
 821cbd8:	280f883a 	mov	r7,r5
 821cbdc:	200d883a 	mov	r6,r4
 821cbe0:	180b883a 	mov	r5,r3
 821cbe4:	e13ff217 	ldw	r4,-56(fp)
 821cbe8:	82172a00 	call	82172a0 <OSFlagPend>
 821cbec:	00000a06 	br	821cc18 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 821cbf0:	0001883a 	nop
 821cbf4:	e0bffc17 	ldw	r2,-16(fp)
 821cbf8:	10c00d17 	ldw	r3,52(r2)
 821cbfc:	e0bff317 	ldw	r2,-52(fp)
 821cc00:	1880051e 	bne	r3,r2,821cc18 <altera_avalon_jtag_uart_read+0x1c8>
 821cc04:	e0bffc17 	ldw	r2,-16(fp)
 821cc08:	10c00917 	ldw	r3,36(r2)
 821cc0c:	e0bffc17 	ldw	r2,-16(fp)
 821cc10:	10800117 	ldw	r2,4(r2)
 821cc14:	18bff736 	bltu	r3,r2,821cbf4 <altera_avalon_jtag_uart_read+0x1a4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 821cc18:	e0bffc17 	ldw	r2,-16(fp)
 821cc1c:	10c00d17 	ldw	r3,52(r2)
 821cc20:	e0bff317 	ldw	r2,-52(fp)
 821cc24:	18800726 	beq	r3,r2,821cc44 <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 821cc28:	e0bffe17 	ldw	r2,-8(fp)
 821cc2c:	00bf9d16 	blt	zero,r2,821caa4 <altera_avalon_jtag_uart_read+0x54>
 821cc30:	00000506 	br	821cc48 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 821cc34:	0001883a 	nop
 821cc38:	00000306 	br	821cc48 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 821cc3c:	0001883a 	nop
 821cc40:	00000106 	br	821cc48 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 821cc44:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 821cc48:	e0bffc17 	ldw	r2,-16(fp)
 821cc4c:	10800a17 	ldw	r2,40(r2)
 821cc50:	1009883a 	mov	r4,r2
 821cc54:	821a0800 	call	821a080 <OSSemPost>

  if (ptr != buffer)
 821cc58:	e0fff017 	ldw	r3,-64(fp)
 821cc5c:	e0bffd17 	ldw	r2,-12(fp)
 821cc60:	18801826 	beq	r3,r2,821ccc4 <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821cc64:	0005303a 	rdctl	r2,status
 821cc68:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821cc6c:	e0fff717 	ldw	r3,-36(fp)
 821cc70:	00bfff84 	movi	r2,-2
 821cc74:	1884703a 	and	r2,r3,r2
 821cc78:	1001703a 	wrctl	status,r2
  
  return context;
 821cc7c:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 821cc80:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821cc84:	e0bffc17 	ldw	r2,-16(fp)
 821cc88:	10800817 	ldw	r2,32(r2)
 821cc8c:	10c00054 	ori	r3,r2,1
 821cc90:	e0bffc17 	ldw	r2,-16(fp)
 821cc94:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cc98:	e0bffc17 	ldw	r2,-16(fp)
 821cc9c:	10800017 	ldw	r2,0(r2)
 821cca0:	10800104 	addi	r2,r2,4
 821cca4:	1007883a 	mov	r3,r2
 821cca8:	e0bffc17 	ldw	r2,-16(fp)
 821ccac:	10800817 	ldw	r2,32(r2)
 821ccb0:	18800035 	stwio	r2,0(r3)
 821ccb4:	e0bff617 	ldw	r2,-40(fp)
 821ccb8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ccbc:	e0bff517 	ldw	r2,-44(fp)
 821ccc0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 821ccc4:	e0fff017 	ldw	r3,-64(fp)
 821ccc8:	e0bffd17 	ldw	r2,-12(fp)
 821cccc:	18800426 	beq	r3,r2,821cce0 <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
 821ccd0:	e0fff017 	ldw	r3,-64(fp)
 821ccd4:	e0bffd17 	ldw	r2,-12(fp)
 821ccd8:	1885c83a 	sub	r2,r3,r2
 821ccdc:	00000606 	br	821ccf8 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 821cce0:	e0bfff17 	ldw	r2,-4(fp)
 821cce4:	1090000c 	andi	r2,r2,16384
 821cce8:	10000226 	beq	r2,zero,821ccf4 <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
 821ccec:	00bffd44 	movi	r2,-11
 821ccf0:	00000106 	br	821ccf8 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 821ccf4:	00bffec4 	movi	r2,-5
}
 821ccf8:	e037883a 	mov	sp,fp
 821ccfc:	dfc00117 	ldw	ra,4(sp)
 821cd00:	df000017 	ldw	fp,0(sp)
 821cd04:	dec00204 	addi	sp,sp,8
 821cd08:	f800283a 	ret

0821cd0c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 821cd0c:	deffed04 	addi	sp,sp,-76
 821cd10:	dfc01215 	stw	ra,72(sp)
 821cd14:	df001115 	stw	fp,68(sp)
 821cd18:	df001104 	addi	fp,sp,68
 821cd1c:	e13ffc15 	stw	r4,-16(fp)
 821cd20:	e17ffd15 	stw	r5,-12(fp)
 821cd24:	e1bffe15 	stw	r6,-8(fp)
 821cd28:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 821cd2c:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 821cd30:	e0bffd17 	ldw	r2,-12(fp)
 821cd34:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 821cd38:	e0bffc17 	ldw	r2,-16(fp)
 821cd3c:	10800b17 	ldw	r2,44(r2)
 821cd40:	e0bff815 	stw	r2,-32(fp)
 821cd44:	e03ff90d 	sth	zero,-28(fp)
 821cd48:	e0bff90b 	ldhu	r2,-28(fp)
 821cd4c:	e0fffb44 	addi	r3,fp,-19
 821cd50:	180d883a 	mov	r6,r3
 821cd54:	100b883a 	mov	r5,r2
 821cd58:	e13ff817 	ldw	r4,-32(fp)
 821cd5c:	8219d080 	call	8219d08 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821cd60:	00003706 	br	821ce40 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 821cd64:	e0bffc17 	ldw	r2,-16(fp)
 821cd68:	10800f17 	ldw	r2,60(r2)
 821cd6c:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
 821cd70:	e0bffc17 	ldw	r2,-16(fp)
 821cd74:	10801017 	ldw	r2,64(r2)
 821cd78:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 821cd7c:	e0fff417 	ldw	r3,-48(fp)
 821cd80:	e0bff017 	ldw	r2,-64(fp)
 821cd84:	1880062e 	bgeu	r3,r2,821cda0 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 821cd88:	e0fff017 	ldw	r3,-64(fp)
 821cd8c:	e0bff417 	ldw	r2,-48(fp)
 821cd90:	1885c83a 	sub	r2,r3,r2
 821cd94:	10bfffc4 	addi	r2,r2,-1
 821cd98:	e0bff115 	stw	r2,-60(fp)
 821cd9c:	00000b06 	br	821cdcc <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 821cda0:	e0bff017 	ldw	r2,-64(fp)
 821cda4:	10000526 	beq	r2,zero,821cdbc <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 821cda8:	00c20004 	movi	r3,2048
 821cdac:	e0bff417 	ldw	r2,-48(fp)
 821cdb0:	1885c83a 	sub	r2,r3,r2
 821cdb4:	e0bff115 	stw	r2,-60(fp)
 821cdb8:	00000406 	br	821cdcc <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 821cdbc:	00c1ffc4 	movi	r3,2047
 821cdc0:	e0bff417 	ldw	r2,-48(fp)
 821cdc4:	1885c83a 	sub	r2,r3,r2
 821cdc8:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821cdcc:	e0bff117 	ldw	r2,-60(fp)
 821cdd0:	10001e26 	beq	r2,zero,821ce4c <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 821cdd4:	e0fffe17 	ldw	r3,-8(fp)
 821cdd8:	e0bff117 	ldw	r2,-60(fp)
 821cddc:	1880022e 	bgeu	r3,r2,821cde8 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 821cde0:	e0bffe17 	ldw	r2,-8(fp)
 821cde4:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 821cde8:	e0bffc17 	ldw	r2,-16(fp)
 821cdec:	10c21104 	addi	r3,r2,2116
 821cdf0:	e0bff417 	ldw	r2,-48(fp)
 821cdf4:	1885883a 	add	r2,r3,r2
 821cdf8:	e1bff117 	ldw	r6,-60(fp)
 821cdfc:	e17ffd17 	ldw	r5,-12(fp)
 821ce00:	1009883a 	mov	r4,r2
 821ce04:	8202a0c0 	call	8202a0c <memcpy>
      ptr   += n;
 821ce08:	e0fffd17 	ldw	r3,-12(fp)
 821ce0c:	e0bff117 	ldw	r2,-60(fp)
 821ce10:	1885883a 	add	r2,r3,r2
 821ce14:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 821ce18:	e0fffe17 	ldw	r3,-8(fp)
 821ce1c:	e0bff117 	ldw	r2,-60(fp)
 821ce20:	1885c83a 	sub	r2,r3,r2
 821ce24:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821ce28:	e0fff417 	ldw	r3,-48(fp)
 821ce2c:	e0bff117 	ldw	r2,-60(fp)
 821ce30:	1885883a 	add	r2,r3,r2
 821ce34:	10c1ffcc 	andi	r3,r2,2047
 821ce38:	e0bffc17 	ldw	r2,-16(fp)
 821ce3c:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821ce40:	e0bffe17 	ldw	r2,-8(fp)
 821ce44:	00bfc716 	blt	zero,r2,821cd64 <altera_avalon_jtag_uart_write+0x58>
 821ce48:	00000106 	br	821ce50 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 821ce4c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ce50:	0005303a 	rdctl	r2,status
 821ce54:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ce58:	e0fff717 	ldw	r3,-36(fp)
 821ce5c:	00bfff84 	movi	r2,-2
 821ce60:	1884703a 	and	r2,r3,r2
 821ce64:	1001703a 	wrctl	status,r2
  
  return context;
 821ce68:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 821ce6c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821ce70:	e0bffc17 	ldw	r2,-16(fp)
 821ce74:	10800817 	ldw	r2,32(r2)
 821ce78:	10c00094 	ori	r3,r2,2
 821ce7c:	e0bffc17 	ldw	r2,-16(fp)
 821ce80:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821ce84:	e0bffc17 	ldw	r2,-16(fp)
 821ce88:	10800017 	ldw	r2,0(r2)
 821ce8c:	10800104 	addi	r2,r2,4
 821ce90:	1007883a 	mov	r3,r2
 821ce94:	e0bffc17 	ldw	r2,-16(fp)
 821ce98:	10800817 	ldw	r2,32(r2)
 821ce9c:	18800035 	stwio	r2,0(r3)
 821cea0:	e0bff617 	ldw	r2,-40(fp)
 821cea4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821cea8:	e0bff317 	ldw	r2,-52(fp)
 821ceac:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 821ceb0:	e0bffe17 	ldw	r2,-8(fp)
 821ceb4:	00802a0e 	bge	zero,r2,821cf60 <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
 821ceb8:	e0bfff17 	ldw	r2,-4(fp)
 821cebc:	1090000c 	andi	r2,r2,16384
 821cec0:	10002a1e 	bne	r2,zero,821cf6c <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 821cec4:	d0a06b43 	ldbu	r2,-32339(gp)
 821cec8:	10803fcc 	andi	r2,r2,255
 821cecc:	10800058 	cmpnei	r2,r2,1
 821ced0:	1000161e 	bne	r2,zero,821cf2c <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 821ced4:	e0bffc17 	ldw	r2,-16(fp)
 821ced8:	10800c17 	ldw	r2,48(r2)
 821cedc:	e0bff515 	stw	r2,-44(fp)
 821cee0:	00800184 	movi	r2,6
 821cee4:	e0bff98d 	sth	r2,-26(fp)
 821cee8:	00bfe0c4 	movi	r2,-125
 821ceec:	e0bffa05 	stb	r2,-24(fp)
 821cef0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821cef4:	d0a06b43 	ldbu	r2,-32339(gp)
 821cef8:	10803fcc 	andi	r2,r2,255
 821cefc:	10001526 	beq	r2,zero,821cf54 <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821cf00:	e0fff98b 	ldhu	r3,-26(fp)
 821cf04:	e13ffa03 	ldbu	r4,-24(fp)
 821cf08:	e17ffa8b 	ldhu	r5,-22(fp)
 821cf0c:	e0bffb04 	addi	r2,fp,-20
 821cf10:	d8800015 	stw	r2,0(sp)
 821cf14:	280f883a 	mov	r7,r5
 821cf18:	200d883a 	mov	r6,r4
 821cf1c:	180b883a 	mov	r5,r3
 821cf20:	e13ff517 	ldw	r4,-44(fp)
 821cf24:	82172a00 	call	82172a0 <OSFlagPend>
 821cf28:	00000a06 	br	821cf54 <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 821cf2c:	0001883a 	nop
 821cf30:	e0bffc17 	ldw	r2,-16(fp)
 821cf34:	10c01017 	ldw	r3,64(r2)
 821cf38:	e0bff017 	ldw	r2,-64(fp)
 821cf3c:	1880051e 	bne	r3,r2,821cf54 <altera_avalon_jtag_uart_write+0x248>
 821cf40:	e0bffc17 	ldw	r2,-16(fp)
 821cf44:	10c00917 	ldw	r3,36(r2)
 821cf48:	e0bffc17 	ldw	r2,-16(fp)
 821cf4c:	10800117 	ldw	r2,4(r2)
 821cf50:	18bff736 	bltu	r3,r2,821cf30 <altera_avalon_jtag_uart_write+0x224>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 821cf54:	e0bffc17 	ldw	r2,-16(fp)
 821cf58:	10800917 	ldw	r2,36(r2)
 821cf5c:	1000051e 	bne	r2,zero,821cf74 <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
 821cf60:	e0bffe17 	ldw	r2,-8(fp)
 821cf64:	00bfb616 	blt	zero,r2,821ce40 <altera_avalon_jtag_uart_write+0x134>
 821cf68:	00000306 	br	821cf78 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 821cf6c:	0001883a 	nop
 821cf70:	00000106 	br	821cf78 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 821cf74:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 821cf78:	e0bffc17 	ldw	r2,-16(fp)
 821cf7c:	10800b17 	ldw	r2,44(r2)
 821cf80:	1009883a 	mov	r4,r2
 821cf84:	821a0800 	call	821a080 <OSSemPost>

  if (ptr != start)
 821cf88:	e0fffd17 	ldw	r3,-12(fp)
 821cf8c:	e0bff217 	ldw	r2,-56(fp)
 821cf90:	18800426 	beq	r3,r2,821cfa4 <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
 821cf94:	e0fffd17 	ldw	r3,-12(fp)
 821cf98:	e0bff217 	ldw	r2,-56(fp)
 821cf9c:	1885c83a 	sub	r2,r3,r2
 821cfa0:	00000606 	br	821cfbc <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
 821cfa4:	e0bfff17 	ldw	r2,-4(fp)
 821cfa8:	1090000c 	andi	r2,r2,16384
 821cfac:	10000226 	beq	r2,zero,821cfb8 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
 821cfb0:	00bffd44 	movi	r2,-11
 821cfb4:	00000106 	br	821cfbc <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 821cfb8:	00bffec4 	movi	r2,-5
}
 821cfbc:	e037883a 	mov	sp,fp
 821cfc0:	dfc00117 	ldw	ra,4(sp)
 821cfc4:	df000017 	ldw	fp,0(sp)
 821cfc8:	dec00204 	addi	sp,sp,8
 821cfcc:	f800283a 	ret

0821cfd0 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 821cfd0:	defffa04 	addi	sp,sp,-24
 821cfd4:	dfc00515 	stw	ra,20(sp)
 821cfd8:	df000415 	stw	fp,16(sp)
 821cfdc:	df000404 	addi	fp,sp,16
 821cfe0:	e13ffe15 	stw	r4,-8(fp)
 821cfe4:	2805883a 	mov	r2,r5
 821cfe8:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821cfec:	e0bffe17 	ldw	r2,-8(fp)
 821cff0:	10800017 	ldw	r2,0(r2)
 821cff4:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821cff8:	008003f4 	movhi	r2,15
 821cffc:	10909004 	addi	r2,r2,16960
 821d000:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d004:	e0bffe17 	ldw	r2,-8(fp)
 821d008:	10800803 	ldbu	r2,32(r2)
 821d00c:	10803fcc 	andi	r2,r2,255
 821d010:	1080201c 	xori	r2,r2,128
 821d014:	10bfe004 	addi	r2,r2,-128
 821d018:	1000151e 	bne	r2,zero,821d070 <lcd_write_command+0xa0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d01c:	00000906 	br	821d044 <lcd_write_command+0x74>
    if (--i == 0)
 821d020:	e0bffc17 	ldw	r2,-16(fp)
 821d024:	10bfffc4 	addi	r2,r2,-1
 821d028:	e0bffc15 	stw	r2,-16(fp)
 821d02c:	e0bffc17 	ldw	r2,-16(fp)
 821d030:	1000041e 	bne	r2,zero,821d044 <lcd_write_command+0x74>
    {
      sp->broken = 1;
 821d034:	e0bffe17 	ldw	r2,-8(fp)
 821d038:	00c00044 	movi	r3,1
 821d03c:	10c00805 	stb	r3,32(r2)
      return;
 821d040:	00000c06 	br	821d074 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d044:	e0bffd17 	ldw	r2,-12(fp)
 821d048:	10800104 	addi	r2,r2,4
 821d04c:	10800037 	ldwio	r2,0(r2)
 821d050:	1080200c 	andi	r2,r2,128
 821d054:	103ff21e 	bne	r2,zero,821d020 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d058:	01001904 	movi	r4,100
 821d05c:	82143d00 	call	82143d0 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 821d060:	e0bffd17 	ldw	r2,-12(fp)
 821d064:	e0ffff03 	ldbu	r3,-4(fp)
 821d068:	10c00035 	stwio	r3,0(r2)
 821d06c:	00000106 	br	821d074 <lcd_write_command+0xa4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d070:	0001883a 	nop
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
}
 821d074:	e037883a 	mov	sp,fp
 821d078:	dfc00117 	ldw	ra,4(sp)
 821d07c:	df000017 	ldw	fp,0(sp)
 821d080:	dec00204 	addi	sp,sp,8
 821d084:	f800283a 	ret

0821d088 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 821d088:	defffa04 	addi	sp,sp,-24
 821d08c:	dfc00515 	stw	ra,20(sp)
 821d090:	df000415 	stw	fp,16(sp)
 821d094:	df000404 	addi	fp,sp,16
 821d098:	e13ffe15 	stw	r4,-8(fp)
 821d09c:	2805883a 	mov	r2,r5
 821d0a0:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d0a4:	e0bffe17 	ldw	r2,-8(fp)
 821d0a8:	10800017 	ldw	r2,0(r2)
 821d0ac:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d0b0:	008003f4 	movhi	r2,15
 821d0b4:	10909004 	addi	r2,r2,16960
 821d0b8:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d0bc:	e0bffe17 	ldw	r2,-8(fp)
 821d0c0:	10800803 	ldbu	r2,32(r2)
 821d0c4:	10803fcc 	andi	r2,r2,255
 821d0c8:	1080201c 	xori	r2,r2,128
 821d0cc:	10bfe004 	addi	r2,r2,-128
 821d0d0:	10001d1e 	bne	r2,zero,821d148 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d0d4:	00000906 	br	821d0fc <lcd_write_data+0x74>
    if (--i == 0)
 821d0d8:	e0bffc17 	ldw	r2,-16(fp)
 821d0dc:	10bfffc4 	addi	r2,r2,-1
 821d0e0:	e0bffc15 	stw	r2,-16(fp)
 821d0e4:	e0bffc17 	ldw	r2,-16(fp)
 821d0e8:	1000041e 	bne	r2,zero,821d0fc <lcd_write_data+0x74>
    {
      sp->broken = 1;
 821d0ec:	e0bffe17 	ldw	r2,-8(fp)
 821d0f0:	00c00044 	movi	r3,1
 821d0f4:	10c00805 	stb	r3,32(r2)
      return;
 821d0f8:	00001406 	br	821d14c <lcd_write_data+0xc4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d0fc:	e0bffd17 	ldw	r2,-12(fp)
 821d100:	10800104 	addi	r2,r2,4
 821d104:	10800037 	ldwio	r2,0(r2)
 821d108:	1080200c 	andi	r2,r2,128
 821d10c:	103ff21e 	bne	r2,zero,821d0d8 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d110:	01001904 	movi	r4,100
 821d114:	82143d00 	call	82143d0 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 821d118:	e0bffd17 	ldw	r2,-12(fp)
 821d11c:	10800204 	addi	r2,r2,8
 821d120:	1007883a 	mov	r3,r2
 821d124:	e0bfff03 	ldbu	r2,-4(fp)
 821d128:	18800035 	stwio	r2,0(r3)

  sp->address++;
 821d12c:	e0bffe17 	ldw	r2,-8(fp)
 821d130:	108008c3 	ldbu	r2,35(r2)
 821d134:	10800044 	addi	r2,r2,1
 821d138:	1007883a 	mov	r3,r2
 821d13c:	e0bffe17 	ldw	r2,-8(fp)
 821d140:	10c008c5 	stb	r3,35(r2)
 821d144:	00000106 	br	821d14c <lcd_write_data+0xc4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d148:	0001883a 	nop
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);

  sp->address++;
}
 821d14c:	e037883a 	mov	sp,fp
 821d150:	dfc00117 	ldw	ra,4(sp)
 821d154:	df000017 	ldw	fp,0(sp)
 821d158:	dec00204 	addi	sp,sp,8
 821d15c:	f800283a 	ret

0821d160 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 821d160:	defffc04 	addi	sp,sp,-16
 821d164:	dfc00315 	stw	ra,12(sp)
 821d168:	df000215 	stw	fp,8(sp)
 821d16c:	df000204 	addi	fp,sp,8
 821d170:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 821d174:	01400044 	movi	r5,1
 821d178:	e13fff17 	ldw	r4,-4(fp)
 821d17c:	821cfd00 	call	821cfd0 <lcd_write_command>

  sp->x = 0;
 821d180:	e0bfff17 	ldw	r2,-4(fp)
 821d184:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 821d188:	e0bfff17 	ldw	r2,-4(fp)
 821d18c:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 821d190:	e0bfff17 	ldw	r2,-4(fp)
 821d194:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d198:	e03ffe15 	stw	zero,-8(fp)
 821d19c:	00001b06 	br	821d20c <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 821d1a0:	e0bffe17 	ldw	r2,-8(fp)
 821d1a4:	108018e4 	muli	r2,r2,99
 821d1a8:	10801004 	addi	r2,r2,64
 821d1ac:	e0ffff17 	ldw	r3,-4(fp)
 821d1b0:	1885883a 	add	r2,r3,r2
 821d1b4:	01801444 	movi	r6,81
 821d1b8:	01400804 	movi	r5,32
 821d1bc:	1009883a 	mov	r4,r2
 821d1c0:	8202cb00 	call	8202cb0 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 821d1c4:	e0bffe17 	ldw	r2,-8(fp)
 821d1c8:	108018e4 	muli	r2,r2,99
 821d1cc:	10800c04 	addi	r2,r2,48
 821d1d0:	e0ffff17 	ldw	r3,-4(fp)
 821d1d4:	1885883a 	add	r2,r3,r2
 821d1d8:	01800404 	movi	r6,16
 821d1dc:	01400804 	movi	r5,32
 821d1e0:	1009883a 	mov	r4,r2
 821d1e4:	8202cb00 	call	8202cb0 <memset>
    sp->line[y].width = 0;
 821d1e8:	e0ffff17 	ldw	r3,-4(fp)
 821d1ec:	e0bffe17 	ldw	r2,-8(fp)
 821d1f0:	108018e4 	muli	r2,r2,99
 821d1f4:	1885883a 	add	r2,r3,r2
 821d1f8:	10802444 	addi	r2,r2,145
 821d1fc:	10000005 	stb	zero,0(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d200:	e0bffe17 	ldw	r2,-8(fp)
 821d204:	10800044 	addi	r2,r2,1
 821d208:	e0bffe15 	stw	r2,-8(fp)
 821d20c:	e0bffe17 	ldw	r2,-8(fp)
 821d210:	10800090 	cmplti	r2,r2,2
 821d214:	103fe21e 	bne	r2,zero,821d1a0 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 821d218:	0001883a 	nop
 821d21c:	e037883a 	mov	sp,fp
 821d220:	dfc00117 	ldw	ra,4(sp)
 821d224:	df000017 	ldw	fp,0(sp)
 821d228:	dec00204 	addi	sp,sp,8
 821d22c:	f800283a 	ret

0821d230 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 821d230:	defff704 	addi	sp,sp,-36
 821d234:	dfc00815 	stw	ra,32(sp)
 821d238:	df000715 	stw	fp,28(sp)
 821d23c:	df000704 	addi	fp,sp,28
 821d240:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 821d244:	e0bfff17 	ldw	r2,-4(fp)
 821d248:	10800943 	ldbu	r2,37(r2)
 821d24c:	10803fcc 	andi	r2,r2,255
 821d250:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d254:	e03ff915 	stw	zero,-28(fp)
 821d258:	00006706 	br	821d3f8 <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 821d25c:	e0ffff17 	ldw	r3,-4(fp)
 821d260:	e0bff917 	ldw	r2,-28(fp)
 821d264:	108018e4 	muli	r2,r2,99
 821d268:	1885883a 	add	r2,r3,r2
 821d26c:	10802444 	addi	r2,r2,145
 821d270:	10800003 	ldbu	r2,0(r2)
 821d274:	10803fcc 	andi	r2,r2,255
 821d278:	1080201c 	xori	r2,r2,128
 821d27c:	10bfe004 	addi	r2,r2,-128
 821d280:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 821d284:	e0ffff17 	ldw	r3,-4(fp)
 821d288:	e0bff917 	ldw	r2,-28(fp)
 821d28c:	108018e4 	muli	r2,r2,99
 821d290:	1885883a 	add	r2,r3,r2
 821d294:	10802484 	addi	r2,r2,146
 821d298:	10800003 	ldbu	r2,0(r2)
 821d29c:	10c03fcc 	andi	r3,r2,255
 821d2a0:	e0bffc17 	ldw	r2,-16(fp)
 821d2a4:	1885383a 	mul	r2,r3,r2
 821d2a8:	1005d23a 	srai	r2,r2,8
 821d2ac:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
 821d2b0:	e0fffb17 	ldw	r3,-20(fp)
 821d2b4:	e0bffd17 	ldw	r2,-12(fp)
 821d2b8:	18800116 	blt	r3,r2,821d2c0 <lcd_repaint_screen+0x90>
      offset = 0;
 821d2bc:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d2c0:	e03ffa15 	stw	zero,-24(fp)
 821d2c4:	00004606 	br	821d3e0 <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 821d2c8:	e0fffa17 	ldw	r3,-24(fp)
 821d2cc:	e0bffb17 	ldw	r2,-20(fp)
 821d2d0:	1885883a 	add	r2,r3,r2
 821d2d4:	e17ffd17 	ldw	r5,-12(fp)
 821d2d8:	1009883a 	mov	r4,r2
 821d2dc:	82026980 	call	8202698 <__modsi3>
 821d2e0:	1009883a 	mov	r4,r2
 821d2e4:	e0ffff17 	ldw	r3,-4(fp)
 821d2e8:	e0bff917 	ldw	r2,-28(fp)
 821d2ec:	108018e4 	muli	r2,r2,99
 821d2f0:	1885883a 	add	r2,r3,r2
 821d2f4:	1105883a 	add	r2,r2,r4
 821d2f8:	10801004 	addi	r2,r2,64
 821d2fc:	10800003 	ldbu	r2,0(r2)
 821d300:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 821d304:	e0ffff17 	ldw	r3,-4(fp)
 821d308:	e0bff917 	ldw	r2,-28(fp)
 821d30c:	108018e4 	muli	r2,r2,99
 821d310:	1887883a 	add	r3,r3,r2
 821d314:	e0bffa17 	ldw	r2,-24(fp)
 821d318:	1885883a 	add	r2,r3,r2
 821d31c:	10800c04 	addi	r2,r2,48
 821d320:	10800003 	ldbu	r2,0(r2)
 821d324:	10c03fcc 	andi	r3,r2,255
 821d328:	18c0201c 	xori	r3,r3,128
 821d32c:	18ffe004 	addi	r3,r3,-128
 821d330:	e0bffe07 	ldb	r2,-8(fp)
 821d334:	18802726 	beq	r3,r2,821d3d4 <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 821d338:	e0fff917 	ldw	r3,-28(fp)
 821d33c:	d0a02a04 	addi	r2,gp,-32600
 821d340:	1885883a 	add	r2,r3,r2
 821d344:	10800003 	ldbu	r2,0(r2)
 821d348:	1007883a 	mov	r3,r2
 821d34c:	e0bffa17 	ldw	r2,-24(fp)
 821d350:	1885883a 	add	r2,r3,r2
 821d354:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
 821d358:	e0fffe43 	ldbu	r3,-7(fp)
 821d35c:	e0bfff17 	ldw	r2,-4(fp)
 821d360:	108008c3 	ldbu	r2,35(r2)
 821d364:	10803fcc 	andi	r2,r2,255
 821d368:	1080201c 	xori	r2,r2,128
 821d36c:	10bfe004 	addi	r2,r2,-128
 821d370:	18800a26 	beq	r3,r2,821d39c <lcd_repaint_screen+0x16c>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 821d374:	e0fffe43 	ldbu	r3,-7(fp)
 821d378:	00bfe004 	movi	r2,-128
 821d37c:	1884b03a 	or	r2,r3,r2
 821d380:	10803fcc 	andi	r2,r2,255
 821d384:	100b883a 	mov	r5,r2
 821d388:	e13fff17 	ldw	r4,-4(fp)
 821d38c:	821cfd00 	call	821cfd0 <lcd_write_command>
          sp->address = address;
 821d390:	e0fffe43 	ldbu	r3,-7(fp)
 821d394:	e0bfff17 	ldw	r2,-4(fp)
 821d398:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 821d39c:	e0bffe03 	ldbu	r2,-8(fp)
 821d3a0:	10803fcc 	andi	r2,r2,255
 821d3a4:	100b883a 	mov	r5,r2
 821d3a8:	e13fff17 	ldw	r4,-4(fp)
 821d3ac:	821d0880 	call	821d088 <lcd_write_data>
        sp->line[y].visible[x] = c;
 821d3b0:	e0ffff17 	ldw	r3,-4(fp)
 821d3b4:	e0bff917 	ldw	r2,-28(fp)
 821d3b8:	108018e4 	muli	r2,r2,99
 821d3bc:	1887883a 	add	r3,r3,r2
 821d3c0:	e0bffa17 	ldw	r2,-24(fp)
 821d3c4:	1885883a 	add	r2,r3,r2
 821d3c8:	10800c04 	addi	r2,r2,48
 821d3cc:	e0fffe03 	ldbu	r3,-8(fp)
 821d3d0:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d3d4:	e0bffa17 	ldw	r2,-24(fp)
 821d3d8:	10800044 	addi	r2,r2,1
 821d3dc:	e0bffa15 	stw	r2,-24(fp)
 821d3e0:	e0bffa17 	ldw	r2,-24(fp)
 821d3e4:	10800410 	cmplti	r2,r2,16
 821d3e8:	103fb71e 	bne	r2,zero,821d2c8 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d3ec:	e0bff917 	ldw	r2,-28(fp)
 821d3f0:	10800044 	addi	r2,r2,1
 821d3f4:	e0bff915 	stw	r2,-28(fp)
 821d3f8:	e0bff917 	ldw	r2,-28(fp)
 821d3fc:	10800090 	cmplti	r2,r2,2
 821d400:	103f961e 	bne	r2,zero,821d25c <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 821d404:	0001883a 	nop
 821d408:	e037883a 	mov	sp,fp
 821d40c:	dfc00117 	ldw	ra,4(sp)
 821d410:	df000017 	ldw	fp,0(sp)
 821d414:	dec00204 	addi	sp,sp,8
 821d418:	f800283a 	ret

0821d41c <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 821d41c:	defffc04 	addi	sp,sp,-16
 821d420:	dfc00315 	stw	ra,12(sp)
 821d424:	df000215 	stw	fp,8(sp)
 821d428:	df000204 	addi	fp,sp,8
 821d42c:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d430:	e03ffe15 	stw	zero,-8(fp)
 821d434:	00001d06 	br	821d4ac <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 821d438:	e0bffe17 	ldw	r2,-8(fp)
 821d43c:	00800f16 	blt	zero,r2,821d47c <lcd_scroll_up+0x60>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 821d440:	e0bffe17 	ldw	r2,-8(fp)
 821d444:	108018e4 	muli	r2,r2,99
 821d448:	10801004 	addi	r2,r2,64
 821d44c:	e0ffff17 	ldw	r3,-4(fp)
 821d450:	1889883a 	add	r4,r3,r2
 821d454:	e0bffe17 	ldw	r2,-8(fp)
 821d458:	10800044 	addi	r2,r2,1
 821d45c:	108018e4 	muli	r2,r2,99
 821d460:	10801004 	addi	r2,r2,64
 821d464:	e0ffff17 	ldw	r3,-4(fp)
 821d468:	1885883a 	add	r2,r3,r2
 821d46c:	01801404 	movi	r6,80
 821d470:	100b883a 	mov	r5,r2
 821d474:	8202a0c0 	call	8202a0c <memcpy>
 821d478:	00000906 	br	821d4a0 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 821d47c:	e0bffe17 	ldw	r2,-8(fp)
 821d480:	108018e4 	muli	r2,r2,99
 821d484:	10801004 	addi	r2,r2,64
 821d488:	e0ffff17 	ldw	r3,-4(fp)
 821d48c:	1885883a 	add	r2,r3,r2
 821d490:	01801404 	movi	r6,80
 821d494:	01400804 	movi	r5,32
 821d498:	1009883a 	mov	r4,r2
 821d49c:	8202cb00 	call	8202cb0 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d4a0:	e0bffe17 	ldw	r2,-8(fp)
 821d4a4:	10800044 	addi	r2,r2,1
 821d4a8:	e0bffe15 	stw	r2,-8(fp)
 821d4ac:	e0bffe17 	ldw	r2,-8(fp)
 821d4b0:	10800090 	cmplti	r2,r2,2
 821d4b4:	103fe01e 	bne	r2,zero,821d438 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 821d4b8:	e0bfff17 	ldw	r2,-4(fp)
 821d4bc:	10800883 	ldbu	r2,34(r2)
 821d4c0:	10bfffc4 	addi	r2,r2,-1
 821d4c4:	1007883a 	mov	r3,r2
 821d4c8:	e0bfff17 	ldw	r2,-4(fp)
 821d4cc:	10c00885 	stb	r3,34(r2)
}
 821d4d0:	0001883a 	nop
 821d4d4:	e037883a 	mov	sp,fp
 821d4d8:	dfc00117 	ldw	ra,4(sp)
 821d4dc:	df000017 	ldw	fp,0(sp)
 821d4e0:	dec00204 	addi	sp,sp,8
 821d4e4:	f800283a 	ret

0821d4e8 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 821d4e8:	defff904 	addi	sp,sp,-28
 821d4ec:	dfc00615 	stw	ra,24(sp)
 821d4f0:	df000515 	stw	fp,20(sp)
 821d4f4:	df000504 	addi	fp,sp,20
 821d4f8:	e13ffe15 	stw	r4,-8(fp)
 821d4fc:	2805883a 	mov	r2,r5
 821d500:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
 821d504:	e03ffb15 	stw	zero,-20(fp)
 821d508:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
 821d50c:	e0bffe17 	ldw	r2,-8(fp)
 821d510:	10800a03 	ldbu	r2,40(r2)
 821d514:	10803fcc 	andi	r2,r2,255
 821d518:	1080201c 	xori	r2,r2,128
 821d51c:	10bfe004 	addi	r2,r2,-128
 821d520:	108016d8 	cmpnei	r2,r2,91
 821d524:	1000411e 	bne	r2,zero,821d62c <lcd_handle_escape+0x144>
  {
    char * ptr = sp->escape+1;
 821d528:	e0bffe17 	ldw	r2,-8(fp)
 821d52c:	10800a04 	addi	r2,r2,40
 821d530:	10800044 	addi	r2,r2,1
 821d534:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
 821d538:	00000c06 	br	821d56c <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 821d53c:	e0bffb17 	ldw	r2,-20(fp)
 821d540:	10c002a4 	muli	r3,r2,10
 821d544:	e0bffd17 	ldw	r2,-12(fp)
 821d548:	11000044 	addi	r4,r2,1
 821d54c:	e13ffd15 	stw	r4,-12(fp)
 821d550:	10800003 	ldbu	r2,0(r2)
 821d554:	10803fcc 	andi	r2,r2,255
 821d558:	1080201c 	xori	r2,r2,128
 821d55c:	10bfe004 	addi	r2,r2,-128
 821d560:	10bff404 	addi	r2,r2,-48
 821d564:	1885883a 	add	r2,r3,r2
 821d568:	e0bffb15 	stw	r2,-20(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 821d56c:	d0e00017 	ldw	r3,-32768(gp)
 821d570:	e0bffd17 	ldw	r2,-12(fp)
 821d574:	10800003 	ldbu	r2,0(r2)
 821d578:	10803fcc 	andi	r2,r2,255
 821d57c:	1080201c 	xori	r2,r2,128
 821d580:	10bfe004 	addi	r2,r2,-128
 821d584:	10800044 	addi	r2,r2,1
 821d588:	1885883a 	add	r2,r3,r2
 821d58c:	10800003 	ldbu	r2,0(r2)
 821d590:	10803fcc 	andi	r2,r2,255
 821d594:	1080010c 	andi	r2,r2,4
 821d598:	103fe81e 	bne	r2,zero,821d53c <lcd_handle_escape+0x54>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 821d59c:	e0bffd17 	ldw	r2,-12(fp)
 821d5a0:	10800003 	ldbu	r2,0(r2)
 821d5a4:	10803fcc 	andi	r2,r2,255
 821d5a8:	1080201c 	xori	r2,r2,128
 821d5ac:	10bfe004 	addi	r2,r2,-128
 821d5b0:	10800ed8 	cmpnei	r2,r2,59
 821d5b4:	10001f1e 	bne	r2,zero,821d634 <lcd_handle_escape+0x14c>
    {
      ptr++;
 821d5b8:	e0bffd17 	ldw	r2,-12(fp)
 821d5bc:	10800044 	addi	r2,r2,1
 821d5c0:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
 821d5c4:	00000c06 	br	821d5f8 <lcd_handle_escape+0x110>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 821d5c8:	e0bffc17 	ldw	r2,-16(fp)
 821d5cc:	10c002a4 	muli	r3,r2,10
 821d5d0:	e0bffd17 	ldw	r2,-12(fp)
 821d5d4:	11000044 	addi	r4,r2,1
 821d5d8:	e13ffd15 	stw	r4,-12(fp)
 821d5dc:	10800003 	ldbu	r2,0(r2)
 821d5e0:	10803fcc 	andi	r2,r2,255
 821d5e4:	1080201c 	xori	r2,r2,128
 821d5e8:	10bfe004 	addi	r2,r2,-128
 821d5ec:	10bff404 	addi	r2,r2,-48
 821d5f0:	1885883a 	add	r2,r3,r2
 821d5f4:	e0bffc15 	stw	r2,-16(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 821d5f8:	d0e00017 	ldw	r3,-32768(gp)
 821d5fc:	e0bffd17 	ldw	r2,-12(fp)
 821d600:	10800003 	ldbu	r2,0(r2)
 821d604:	10803fcc 	andi	r2,r2,255
 821d608:	1080201c 	xori	r2,r2,128
 821d60c:	10bfe004 	addi	r2,r2,-128
 821d610:	10800044 	addi	r2,r2,1
 821d614:	1885883a 	add	r2,r3,r2
 821d618:	10800003 	ldbu	r2,0(r2)
 821d61c:	10803fcc 	andi	r2,r2,255
 821d620:	1080010c 	andi	r2,r2,4
 821d624:	103fe81e 	bne	r2,zero,821d5c8 <lcd_handle_escape+0xe0>
 821d628:	00000206 	br	821d634 <lcd_handle_escape+0x14c>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 821d62c:	00bfffc4 	movi	r2,-1
 821d630:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
 821d634:	e0bfff07 	ldb	r2,-4(fp)
 821d638:	10c012a0 	cmpeqi	r3,r2,74
 821d63c:	1800291e 	bne	r3,zero,821d6e4 <lcd_handle_escape+0x1fc>
 821d640:	10c012c8 	cmpgei	r3,r2,75
 821d644:	1800031e 	bne	r3,zero,821d654 <lcd_handle_escape+0x16c>
 821d648:	10801220 	cmpeqi	r2,r2,72
 821d64c:	1000061e 	bne	r2,zero,821d668 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821d650:	00004a06 	br	821d77c <lcd_handle_escape+0x294>
    }
  }
  else
    parm1 = -1;

  switch (c)
 821d654:	10c012e0 	cmpeqi	r3,r2,75
 821d658:	1800281e 	bne	r3,zero,821d6fc <lcd_handle_escape+0x214>
 821d65c:	108019a0 	cmpeqi	r2,r2,102
 821d660:	1000011e 	bne	r2,zero,821d668 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821d664:	00004506 	br	821d77c <lcd_handle_escape+0x294>

  switch (c)
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 821d668:	e0bffc17 	ldw	r2,-16(fp)
 821d66c:	0080050e 	bge	zero,r2,821d684 <lcd_handle_escape+0x19c>
      sp->x = parm2 - 1;
 821d670:	e0bffc17 	ldw	r2,-16(fp)
 821d674:	10bfffc4 	addi	r2,r2,-1
 821d678:	1007883a 	mov	r3,r2
 821d67c:	e0bffe17 	ldw	r2,-8(fp)
 821d680:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 821d684:	e0bffb17 	ldw	r2,-20(fp)
 821d688:	0080370e 	bge	zero,r2,821d768 <lcd_handle_escape+0x280>
    {
      sp->y = parm1 - 1;
 821d68c:	e0bffb17 	ldw	r2,-20(fp)
 821d690:	10bfffc4 	addi	r2,r2,-1
 821d694:	1007883a 	mov	r3,r2
 821d698:	e0bffe17 	ldw	r2,-8(fp)
 821d69c:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 821d6a0:	e0bffe17 	ldw	r2,-8(fp)
 821d6a4:	10800883 	ldbu	r2,34(r2)
 821d6a8:	10803fcc 	andi	r2,r2,255
 821d6ac:	10800170 	cmpltui	r2,r2,5
 821d6b0:	1000061e 	bne	r2,zero,821d6cc <lcd_handle_escape+0x1e4>
        sp->y = ALT_LCD_HEIGHT * 2;
 821d6b4:	e0bffe17 	ldw	r2,-8(fp)
 821d6b8:	00c00104 	movi	r3,4
 821d6bc:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
 821d6c0:	00000206 	br	821d6cc <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
 821d6c4:	e13ffe17 	ldw	r4,-8(fp)
 821d6c8:	821d41c0 	call	821d41c <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 821d6cc:	e0bffe17 	ldw	r2,-8(fp)
 821d6d0:	10800883 	ldbu	r2,34(r2)
 821d6d4:	10803fcc 	andi	r2,r2,255
 821d6d8:	108000e8 	cmpgeui	r2,r2,3
 821d6dc:	103ff91e 	bne	r2,zero,821d6c4 <lcd_handle_escape+0x1dc>
        lcd_scroll_up(sp);
    }
    break;
 821d6e0:	00002106 	br	821d768 <lcd_handle_escape+0x280>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 821d6e4:	e0bffb17 	ldw	r2,-20(fp)
 821d6e8:	10800098 	cmpnei	r2,r2,2
 821d6ec:	1000201e 	bne	r2,zero,821d770 <lcd_handle_escape+0x288>
      lcd_clear_screen(sp);
 821d6f0:	e13ffe17 	ldw	r4,-8(fp)
 821d6f4:	821d1600 	call	821d160 <lcd_clear_screen>
    break;
 821d6f8:	00001d06 	br	821d770 <lcd_handle_escape+0x288>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 821d6fc:	e0bffb17 	ldw	r2,-20(fp)
 821d700:	00801d16 	blt	zero,r2,821d778 <lcd_handle_escape+0x290>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821d704:	e0bffe17 	ldw	r2,-8(fp)
 821d708:	10800843 	ldbu	r2,33(r2)
 821d70c:	10803fcc 	andi	r2,r2,255
 821d710:	10801428 	cmpgeui	r2,r2,80
 821d714:	1000181e 	bne	r2,zero,821d778 <lcd_handle_escape+0x290>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 821d718:	e0bffe17 	ldw	r2,-8(fp)
 821d71c:	10800883 	ldbu	r2,34(r2)
 821d720:	10803fcc 	andi	r2,r2,255
 821d724:	108018e4 	muli	r2,r2,99
 821d728:	10801004 	addi	r2,r2,64
 821d72c:	e0fffe17 	ldw	r3,-8(fp)
 821d730:	1887883a 	add	r3,r3,r2
 821d734:	e0bffe17 	ldw	r2,-8(fp)
 821d738:	10800843 	ldbu	r2,33(r2)
 821d73c:	10803fcc 	andi	r2,r2,255
 821d740:	1889883a 	add	r4,r3,r2
 821d744:	e0bffe17 	ldw	r2,-8(fp)
 821d748:	10800843 	ldbu	r2,33(r2)
 821d74c:	10803fcc 	andi	r2,r2,255
 821d750:	00c01404 	movi	r3,80
 821d754:	1885c83a 	sub	r2,r3,r2
 821d758:	100d883a 	mov	r6,r2
 821d75c:	01400804 	movi	r5,32
 821d760:	8202cb00 	call	8202cb0 <memset>
    }
    break;
 821d764:	00000406 	br	821d778 <lcd_handle_escape+0x290>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
 821d768:	0001883a 	nop
 821d76c:	00000306 	br	821d77c <lcd_handle_escape+0x294>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
 821d770:	0001883a 	nop
 821d774:	00000106 	br	821d77c <lcd_handle_escape+0x294>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
 821d778:	0001883a 	nop
  }
}
 821d77c:	0001883a 	nop
 821d780:	e037883a 	mov	sp,fp
 821d784:	dfc00117 	ldw	ra,4(sp)
 821d788:	df000017 	ldw	fp,0(sp)
 821d78c:	dec00204 	addi	sp,sp,8
 821d790:	f800283a 	ret

0821d794 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 821d794:	defff104 	addi	sp,sp,-60
 821d798:	dfc00e15 	stw	ra,56(sp)
 821d79c:	df000d15 	stw	fp,52(sp)
 821d7a0:	df000d04 	addi	fp,sp,52
 821d7a4:	e13ffc15 	stw	r4,-16(fp)
 821d7a8:	e17ffd15 	stw	r5,-12(fp)
 821d7ac:	e1bffe15 	stw	r6,-8(fp)
 821d7b0:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 821d7b4:	e0bffe17 	ldw	r2,-8(fp)
 821d7b8:	e0fffd17 	ldw	r3,-12(fp)
 821d7bc:	1885883a 	add	r2,r3,r2
 821d7c0:	e0bff615 	stw	r2,-40(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 821d7c4:	e0bffc17 	ldw	r2,-16(fp)
 821d7c8:	10803e17 	ldw	r2,248(r2)
 821d7cc:	e0bffa15 	stw	r2,-24(fp)
 821d7d0:	e03ffb0d 	sth	zero,-20(fp)
 821d7d4:	e0bffb0b 	ldhu	r2,-20(fp)
 821d7d8:	e0fffb84 	addi	r3,fp,-18
 821d7dc:	180d883a 	mov	r6,r3
 821d7e0:	100b883a 	mov	r5,r2
 821d7e4:	e13ffa17 	ldw	r4,-24(fp)
 821d7e8:	8219d080 	call	8219d08 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 821d7ec:	e0bffc17 	ldw	r2,-16(fp)
 821d7f0:	00c00044 	movi	r3,1
 821d7f4:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
 821d7f8:	00009906 	br	821da60 <altera_avalon_lcd_16207_write+0x2cc>
  {
    char c = *ptr;
 821d7fc:	e0bffd17 	ldw	r2,-12(fp)
 821d800:	10800003 	ldbu	r2,0(r2)
 821d804:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 821d808:	e0bffc17 	ldw	r2,-16(fp)
 821d80c:	10800903 	ldbu	r2,36(r2)
 821d810:	10803fcc 	andi	r2,r2,255
 821d814:	1080201c 	xori	r2,r2,128
 821d818:	10bfe004 	addi	r2,r2,-128
 821d81c:	10003716 	blt	r2,zero,821d8fc <altera_avalon_lcd_16207_write+0x168>
    {
      unsigned int esccount = sp->esccount;
 821d820:	e0bffc17 	ldw	r2,-16(fp)
 821d824:	10800903 	ldbu	r2,36(r2)
 821d828:	10803fcc 	andi	r2,r2,255
 821d82c:	1080201c 	xori	r2,r2,128
 821d830:	10bfe004 	addi	r2,r2,-128
 821d834:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 821d838:	e0bff817 	ldw	r2,-32(fp)
 821d83c:	1000031e 	bne	r2,zero,821d84c <altera_avalon_lcd_16207_write+0xb8>
 821d840:	e0bff707 	ldb	r2,-36(fp)
 821d844:	108016d8 	cmpnei	r2,r2,91
 821d848:	10000d1e 	bne	r2,zero,821d880 <altera_avalon_lcd_16207_write+0xec>
 821d84c:	e0bff817 	ldw	r2,-32(fp)
 821d850:	10001826 	beq	r2,zero,821d8b4 <altera_avalon_lcd_16207_write+0x120>
          (esccount > 0 && !isdigit(c) && c != ';'))
 821d854:	d0e00017 	ldw	r3,-32768(gp)
 821d858:	e0bff707 	ldb	r2,-36(fp)
 821d85c:	10800044 	addi	r2,r2,1
 821d860:	1885883a 	add	r2,r3,r2
 821d864:	10800003 	ldbu	r2,0(r2)
 821d868:	10803fcc 	andi	r2,r2,255
 821d86c:	1080010c 	andi	r2,r2,4
 821d870:	1000101e 	bne	r2,zero,821d8b4 <altera_avalon_lcd_16207_write+0x120>
 821d874:	e0bff707 	ldb	r2,-36(fp)
 821d878:	10800ee0 	cmpeqi	r2,r2,59
 821d87c:	10000d1e 	bne	r2,zero,821d8b4 <altera_avalon_lcd_16207_write+0x120>
      {
        sp->escape[esccount] = 0;
 821d880:	e0fffc17 	ldw	r3,-16(fp)
 821d884:	e0bff817 	ldw	r2,-32(fp)
 821d888:	1885883a 	add	r2,r3,r2
 821d88c:	10800a04 	addi	r2,r2,40
 821d890:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 821d894:	e0bff707 	ldb	r2,-36(fp)
 821d898:	100b883a 	mov	r5,r2
 821d89c:	e13ffc17 	ldw	r4,-16(fp)
 821d8a0:	821d4e80 	call	821d4e8 <lcd_handle_escape>

        sp->esccount = -1;
 821d8a4:	e0bffc17 	ldw	r2,-16(fp)
 821d8a8:	00ffffc4 	movi	r3,-1
 821d8ac:	10c00905 	stb	r3,36(r2)
 821d8b0:	00006806 	br	821da54 <altera_avalon_lcd_16207_write+0x2c0>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 821d8b4:	e0bffc17 	ldw	r2,-16(fp)
 821d8b8:	10800903 	ldbu	r2,36(r2)
 821d8bc:	10803fcc 	andi	r2,r2,255
 821d8c0:	108001e8 	cmpgeui	r2,r2,7
 821d8c4:	1000631e 	bne	r2,zero,821da54 <altera_avalon_lcd_16207_write+0x2c0>
      {
        sp->escape[esccount] = c;
 821d8c8:	e0fffc17 	ldw	r3,-16(fp)
 821d8cc:	e0bff817 	ldw	r2,-32(fp)
 821d8d0:	1885883a 	add	r2,r3,r2
 821d8d4:	10800a04 	addi	r2,r2,40
 821d8d8:	e0fff703 	ldbu	r3,-36(fp)
 821d8dc:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
 821d8e0:	e0bffc17 	ldw	r2,-16(fp)
 821d8e4:	10800903 	ldbu	r2,36(r2)
 821d8e8:	10800044 	addi	r2,r2,1
 821d8ec:	1007883a 	mov	r3,r2
 821d8f0:	e0bffc17 	ldw	r2,-16(fp)
 821d8f4:	10c00905 	stb	r3,36(r2)
 821d8f8:	00005606 	br	821da54 <altera_avalon_lcd_16207_write+0x2c0>
      }
    }
    else if (c == 27) /* ESC */
 821d8fc:	e0bff707 	ldb	r2,-36(fp)
 821d900:	108006d8 	cmpnei	r2,r2,27
 821d904:	1000031e 	bne	r2,zero,821d914 <altera_avalon_lcd_16207_write+0x180>
    {
      sp->esccount = 0;
 821d908:	e0bffc17 	ldw	r2,-16(fp)
 821d90c:	10000905 	stb	zero,36(r2)
 821d910:	00005006 	br	821da54 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\r')
 821d914:	e0bff707 	ldb	r2,-36(fp)
 821d918:	10800358 	cmpnei	r2,r2,13
 821d91c:	1000031e 	bne	r2,zero,821d92c <altera_avalon_lcd_16207_write+0x198>
    {
      sp->x = 0;
 821d920:	e0bffc17 	ldw	r2,-16(fp)
 821d924:	10000845 	stb	zero,33(r2)
 821d928:	00004a06 	br	821da54 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\n')
 821d92c:	e0bff707 	ldb	r2,-36(fp)
 821d930:	10800298 	cmpnei	r2,r2,10
 821d934:	1000101e 	bne	r2,zero,821d978 <altera_avalon_lcd_16207_write+0x1e4>
    {
      sp->x = 0;
 821d938:	e0bffc17 	ldw	r2,-16(fp)
 821d93c:	10000845 	stb	zero,33(r2)
      sp->y++;
 821d940:	e0bffc17 	ldw	r2,-16(fp)
 821d944:	10800883 	ldbu	r2,34(r2)
 821d948:	10800044 	addi	r2,r2,1
 821d94c:	1007883a 	mov	r3,r2
 821d950:	e0bffc17 	ldw	r2,-16(fp)
 821d954:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 821d958:	e0bffc17 	ldw	r2,-16(fp)
 821d95c:	10800883 	ldbu	r2,34(r2)
 821d960:	10803fcc 	andi	r2,r2,255
 821d964:	108000f0 	cmpltui	r2,r2,3
 821d968:	10003a1e 	bne	r2,zero,821da54 <altera_avalon_lcd_16207_write+0x2c0>
        lcd_scroll_up(sp);
 821d96c:	e13ffc17 	ldw	r4,-16(fp)
 821d970:	821d41c0 	call	821d41c <lcd_scroll_up>
 821d974:	00003706 	br	821da54 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\b')
 821d978:	e0bff707 	ldb	r2,-36(fp)
 821d97c:	10800218 	cmpnei	r2,r2,8
 821d980:	10000b1e 	bne	r2,zero,821d9b0 <altera_avalon_lcd_16207_write+0x21c>
    {
      if (sp->x > 0)
 821d984:	e0bffc17 	ldw	r2,-16(fp)
 821d988:	10800843 	ldbu	r2,33(r2)
 821d98c:	10803fcc 	andi	r2,r2,255
 821d990:	10003026 	beq	r2,zero,821da54 <altera_avalon_lcd_16207_write+0x2c0>
        sp->x--;
 821d994:	e0bffc17 	ldw	r2,-16(fp)
 821d998:	10800843 	ldbu	r2,33(r2)
 821d99c:	10bfffc4 	addi	r2,r2,-1
 821d9a0:	1007883a 	mov	r3,r2
 821d9a4:	e0bffc17 	ldw	r2,-16(fp)
 821d9a8:	10c00845 	stb	r3,33(r2)
 821d9ac:	00002906 	br	821da54 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (isprint(c))
 821d9b0:	d0e00017 	ldw	r3,-32768(gp)
 821d9b4:	e0bff707 	ldb	r2,-36(fp)
 821d9b8:	10800044 	addi	r2,r2,1
 821d9bc:	1885883a 	add	r2,r3,r2
 821d9c0:	10800003 	ldbu	r2,0(r2)
 821d9c4:	10803fcc 	andi	r2,r2,255
 821d9c8:	1080201c 	xori	r2,r2,128
 821d9cc:	10bfe004 	addi	r2,r2,-128
 821d9d0:	108025cc 	andi	r2,r2,151
 821d9d4:	10001f26 	beq	r2,zero,821da54 <altera_avalon_lcd_16207_write+0x2c0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 821d9d8:	e0bffc17 	ldw	r2,-16(fp)
 821d9dc:	10800883 	ldbu	r2,34(r2)
 821d9e0:	10803fcc 	andi	r2,r2,255
 821d9e4:	108000b0 	cmpltui	r2,r2,2
 821d9e8:	1000021e 	bne	r2,zero,821d9f4 <altera_avalon_lcd_16207_write+0x260>
        lcd_scroll_up(sp);
 821d9ec:	e13ffc17 	ldw	r4,-16(fp)
 821d9f0:	821d41c0 	call	821d41c <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821d9f4:	e0bffc17 	ldw	r2,-16(fp)
 821d9f8:	10800843 	ldbu	r2,33(r2)
 821d9fc:	10803fcc 	andi	r2,r2,255
 821da00:	10801428 	cmpgeui	r2,r2,80
 821da04:	10000d1e 	bne	r2,zero,821da3c <altera_avalon_lcd_16207_write+0x2a8>
        sp->line[sp->y].data[sp->x] = c;
 821da08:	e0bffc17 	ldw	r2,-16(fp)
 821da0c:	10800883 	ldbu	r2,34(r2)
 821da10:	10c03fcc 	andi	r3,r2,255
 821da14:	e0bffc17 	ldw	r2,-16(fp)
 821da18:	10800843 	ldbu	r2,33(r2)
 821da1c:	10803fcc 	andi	r2,r2,255
 821da20:	e13ffc17 	ldw	r4,-16(fp)
 821da24:	18c018e4 	muli	r3,r3,99
 821da28:	20c7883a 	add	r3,r4,r3
 821da2c:	1885883a 	add	r2,r3,r2
 821da30:	10801004 	addi	r2,r2,64
 821da34:	e0fff703 	ldbu	r3,-36(fp)
 821da38:	10c00005 	stb	r3,0(r2)

      sp->x++;
 821da3c:	e0bffc17 	ldw	r2,-16(fp)
 821da40:	10800843 	ldbu	r2,33(r2)
 821da44:	10800044 	addi	r2,r2,1
 821da48:	1007883a 	mov	r3,r2
 821da4c:	e0bffc17 	ldw	r2,-16(fp)
 821da50:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 821da54:	e0bffd17 	ldw	r2,-12(fp)
 821da58:	10800044 	addi	r2,r2,1
 821da5c:	e0bffd15 	stw	r2,-12(fp)
 821da60:	e0fffd17 	ldw	r3,-12(fp)
 821da64:	e0bff617 	ldw	r2,-40(fp)
 821da68:	18bf6436 	bltu	r3,r2,821d7fc <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 821da6c:	00800404 	movi	r2,16
 821da70:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821da74:	e03ff315 	stw	zero,-52(fp)
 821da78:	00003706 	br	821db58 <altera_avalon_lcd_16207_write+0x3c4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821da7c:	00801404 	movi	r2,80
 821da80:	e0bff515 	stw	r2,-44(fp)
 821da84:	00001106 	br	821dacc <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
 821da88:	e0bff517 	ldw	r2,-44(fp)
 821da8c:	10bfffc4 	addi	r2,r2,-1
 821da90:	e13ffc17 	ldw	r4,-16(fp)
 821da94:	e0fff317 	ldw	r3,-52(fp)
 821da98:	18c018e4 	muli	r3,r3,99
 821da9c:	20c7883a 	add	r3,r4,r3
 821daa0:	1885883a 	add	r2,r3,r2
 821daa4:	10801004 	addi	r2,r2,64
 821daa8:	10800003 	ldbu	r2,0(r2)
 821daac:	10803fcc 	andi	r2,r2,255
 821dab0:	1080201c 	xori	r2,r2,128
 821dab4:	10bfe004 	addi	r2,r2,-128
 821dab8:	10800820 	cmpeqi	r2,r2,32
 821dabc:	10000626 	beq	r2,zero,821dad8 <altera_avalon_lcd_16207_write+0x344>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821dac0:	e0bff517 	ldw	r2,-44(fp)
 821dac4:	10bfffc4 	addi	r2,r2,-1
 821dac8:	e0bff515 	stw	r2,-44(fp)
 821dacc:	e0bff517 	ldw	r2,-44(fp)
 821dad0:	00bfed16 	blt	zero,r2,821da88 <altera_avalon_lcd_16207_write+0x2f4>
 821dad4:	00000106 	br	821dadc <altera_avalon_lcd_16207_write+0x348>
      if (sp->line[y].data[width-1] != ' ')
        break;
 821dad8:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 821dadc:	e0bff517 	ldw	r2,-44(fp)
 821dae0:	10800448 	cmpgei	r2,r2,17
 821dae4:	1000031e 	bne	r2,zero,821daf4 <altera_avalon_lcd_16207_write+0x360>
      width = ALT_LCD_WIDTH;
 821dae8:	00800404 	movi	r2,16
 821daec:	e0bff515 	stw	r2,-44(fp)
 821daf0:	00000306 	br	821db00 <altera_avalon_lcd_16207_write+0x36c>
    else
      width++;
 821daf4:	e0bff517 	ldw	r2,-44(fp)
 821daf8:	10800044 	addi	r2,r2,1
 821dafc:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 821db00:	e0bff517 	ldw	r2,-44(fp)
 821db04:	1009883a 	mov	r4,r2
 821db08:	e0fffc17 	ldw	r3,-16(fp)
 821db0c:	e0bff317 	ldw	r2,-52(fp)
 821db10:	108018e4 	muli	r2,r2,99
 821db14:	1885883a 	add	r2,r3,r2
 821db18:	10802444 	addi	r2,r2,145
 821db1c:	11000005 	stb	r4,0(r2)
    if (widthmax < width)
 821db20:	e0fff417 	ldw	r3,-48(fp)
 821db24:	e0bff517 	ldw	r2,-44(fp)
 821db28:	1880020e 	bge	r3,r2,821db34 <altera_avalon_lcd_16207_write+0x3a0>
      widthmax = width;
 821db2c:	e0bff517 	ldw	r2,-44(fp)
 821db30:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 821db34:	e0fffc17 	ldw	r3,-16(fp)
 821db38:	e0bff317 	ldw	r2,-52(fp)
 821db3c:	108018e4 	muli	r2,r2,99
 821db40:	1885883a 	add	r2,r3,r2
 821db44:	10802484 	addi	r2,r2,146
 821db48:	10000005 	stb	zero,0(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821db4c:	e0bff317 	ldw	r2,-52(fp)
 821db50:	10800044 	addi	r2,r2,1
 821db54:	e0bff315 	stw	r2,-52(fp)
 821db58:	e0bff317 	ldw	r2,-52(fp)
 821db5c:	10800090 	cmplti	r2,r2,2
 821db60:	103fc61e 	bne	r2,zero,821da7c <altera_avalon_lcd_16207_write+0x2e8>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 821db64:	e0bff417 	ldw	r2,-48(fp)
 821db68:	10800448 	cmpgei	r2,r2,17
 821db6c:	1000031e 	bne	r2,zero,821db7c <altera_avalon_lcd_16207_write+0x3e8>
    sp->scrollmax = 0;
 821db70:	e0bffc17 	ldw	r2,-16(fp)
 821db74:	10000985 	stb	zero,38(r2)
 821db78:	00002e06 	br	821dc34 <altera_avalon_lcd_16207_write+0x4a0>
  else
  {
    widthmax *= 2;
 821db7c:	e0bff417 	ldw	r2,-48(fp)
 821db80:	1085883a 	add	r2,r2,r2
 821db84:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
 821db88:	e0bff417 	ldw	r2,-48(fp)
 821db8c:	1007883a 	mov	r3,r2
 821db90:	e0bffc17 	ldw	r2,-16(fp)
 821db94:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821db98:	e03ff315 	stw	zero,-52(fp)
 821db9c:	00002206 	br	821dc28 <altera_avalon_lcd_16207_write+0x494>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 821dba0:	e0fffc17 	ldw	r3,-16(fp)
 821dba4:	e0bff317 	ldw	r2,-52(fp)
 821dba8:	108018e4 	muli	r2,r2,99
 821dbac:	1885883a 	add	r2,r3,r2
 821dbb0:	10802444 	addi	r2,r2,145
 821dbb4:	10800003 	ldbu	r2,0(r2)
 821dbb8:	10803fcc 	andi	r2,r2,255
 821dbbc:	1080201c 	xori	r2,r2,128
 821dbc0:	10bfe004 	addi	r2,r2,-128
 821dbc4:	10800450 	cmplti	r2,r2,17
 821dbc8:	1000141e 	bne	r2,zero,821dc1c <altera_avalon_lcd_16207_write+0x488>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 821dbcc:	e0fffc17 	ldw	r3,-16(fp)
 821dbd0:	e0bff317 	ldw	r2,-52(fp)
 821dbd4:	108018e4 	muli	r2,r2,99
 821dbd8:	1885883a 	add	r2,r3,r2
 821dbdc:	10802444 	addi	r2,r2,145
 821dbe0:	10800003 	ldbu	r2,0(r2)
 821dbe4:	10803fcc 	andi	r2,r2,255
 821dbe8:	1080201c 	xori	r2,r2,128
 821dbec:	10bfe004 	addi	r2,r2,-128
 821dbf0:	1004923a 	slli	r2,r2,8
 821dbf4:	e17ff417 	ldw	r5,-48(fp)
 821dbf8:	1009883a 	mov	r4,r2
 821dbfc:	82026140 	call	8202614 <__divsi3>
 821dc00:	1009883a 	mov	r4,r2
 821dc04:	e0fffc17 	ldw	r3,-16(fp)
 821dc08:	e0bff317 	ldw	r2,-52(fp)
 821dc0c:	108018e4 	muli	r2,r2,99
 821dc10:	1885883a 	add	r2,r3,r2
 821dc14:	10802484 	addi	r2,r2,146
 821dc18:	11000005 	stb	r4,0(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dc1c:	e0bff317 	ldw	r2,-52(fp)
 821dc20:	10800044 	addi	r2,r2,1
 821dc24:	e0bff315 	stw	r2,-52(fp)
 821dc28:	e0bff317 	ldw	r2,-52(fp)
 821dc2c:	10800090 	cmplti	r2,r2,2
 821dc30:	103fdb1e 	bne	r2,zero,821dba0 <altera_avalon_lcd_16207_write+0x40c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 821dc34:	e0bffc17 	ldw	r2,-16(fp)
 821dc38:	10800943 	ldbu	r2,37(r2)
 821dc3c:	10803fcc 	andi	r2,r2,255
 821dc40:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
 821dc44:	e13ffc17 	ldw	r4,-16(fp)
 821dc48:	821d2300 	call	821d230 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 821dc4c:	e0bffc17 	ldw	r2,-16(fp)
 821dc50:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 821dc54:	e0bffc17 	ldw	r2,-16(fp)
 821dc58:	10800943 	ldbu	r2,37(r2)
 821dc5c:	10c03fcc 	andi	r3,r2,255
 821dc60:	e0bff917 	ldw	r2,-28(fp)
 821dc64:	18800426 	beq	r3,r2,821dc78 <altera_avalon_lcd_16207_write+0x4e4>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 821dc68:	e0bffc17 	ldw	r2,-16(fp)
 821dc6c:	00c00044 	movi	r3,1
 821dc70:	10c009c5 	stb	r3,39(r2)
  }
 821dc74:	003fef06 	br	821dc34 <altera_avalon_lcd_16207_write+0x4a0>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
 821dc78:	0001883a 	nop

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 821dc7c:	e0bffc17 	ldw	r2,-16(fp)
 821dc80:	10803e17 	ldw	r2,248(r2)
 821dc84:	1009883a 	mov	r4,r2
 821dc88:	821a0800 	call	821a080 <OSSemPost>

  return len;
 821dc8c:	e0bffe17 	ldw	r2,-8(fp)
}
 821dc90:	e037883a 	mov	sp,fp
 821dc94:	dfc00117 	ldw	ra,4(sp)
 821dc98:	df000017 	ldw	fp,0(sp)
 821dc9c:	dec00204 	addi	sp,sp,8
 821dca0:	f800283a 	ret

0821dca4 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 821dca4:	defffc04 	addi	sp,sp,-16
 821dca8:	dfc00315 	stw	ra,12(sp)
 821dcac:	df000215 	stw	fp,8(sp)
 821dcb0:	df000204 	addi	fp,sp,8
 821dcb4:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 821dcb8:	e0bfff17 	ldw	r2,-4(fp)
 821dcbc:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 821dcc0:	e0bffe17 	ldw	r2,-8(fp)
 821dcc4:	10800943 	ldbu	r2,37(r2)
 821dcc8:	10803fcc 	andi	r2,r2,255
 821dccc:	10c00044 	addi	r3,r2,1
 821dcd0:	e0bffe17 	ldw	r2,-8(fp)
 821dcd4:	10800983 	ldbu	r2,38(r2)
 821dcd8:	10803fcc 	andi	r2,r2,255
 821dcdc:	18800316 	blt	r3,r2,821dcec <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
 821dce0:	e0bffe17 	ldw	r2,-8(fp)
 821dce4:	10000945 	stb	zero,37(r2)
 821dce8:	00000606 	br	821dd04 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
 821dcec:	e0bffe17 	ldw	r2,-8(fp)
 821dcf0:	10800943 	ldbu	r2,37(r2)
 821dcf4:	10800044 	addi	r2,r2,1
 821dcf8:	1007883a 	mov	r3,r2
 821dcfc:	e0bffe17 	ldw	r2,-8(fp)
 821dd00:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 821dd04:	e0bffe17 	ldw	r2,-8(fp)
 821dd08:	10800983 	ldbu	r2,38(r2)
 821dd0c:	10803fcc 	andi	r2,r2,255
 821dd10:	10000826 	beq	r2,zero,821dd34 <alt_lcd_16207_timeout+0x90>
 821dd14:	e0bffe17 	ldw	r2,-8(fp)
 821dd18:	108009c3 	ldbu	r2,39(r2)
 821dd1c:	10803fcc 	andi	r2,r2,255
 821dd20:	1080201c 	xori	r2,r2,128
 821dd24:	10bfe004 	addi	r2,r2,-128
 821dd28:	1000021e 	bne	r2,zero,821dd34 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
 821dd2c:	e13ffe17 	ldw	r4,-8(fp)
 821dd30:	821d2300 	call	821d230 <lcd_repaint_screen>

  return sp->period;
 821dd34:	e0bffe17 	ldw	r2,-8(fp)
 821dd38:	10800717 	ldw	r2,28(r2)
}
 821dd3c:	e037883a 	mov	sp,fp
 821dd40:	dfc00117 	ldw	ra,4(sp)
 821dd44:	df000017 	ldw	fp,0(sp)
 821dd48:	dec00204 	addi	sp,sp,8
 821dd4c:	f800283a 	ret

0821dd50 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 821dd50:	defff604 	addi	sp,sp,-40
 821dd54:	dfc00915 	stw	ra,36(sp)
 821dd58:	df000815 	stw	fp,32(sp)
 821dd5c:	dc400715 	stw	r17,28(sp)
 821dd60:	dc000615 	stw	r16,24(sp)
 821dd64:	df000804 	addi	fp,sp,32
 821dd68:	e13ffb15 	stw	r4,-20(fp)
  unsigned int base = sp->base;
 821dd6c:	e0bffb17 	ldw	r2,-20(fp)
 821dd70:	10800017 	ldw	r2,0(r2)
 821dd74:	e0bff815 	stw	r2,-32(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 821dd78:	e0bffb17 	ldw	r2,-20(fp)
 821dd7c:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 821dd80:	e0bffb17 	ldw	r2,-20(fp)
 821dd84:	10803e04 	addi	r2,r2,248
 821dd88:	e0bff915 	stw	r2,-28(fp)
 821dd8c:	00800044 	movi	r2,1
 821dd90:	e0bffa0d 	sth	r2,-24(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 821dd94:	e0bffa0b 	ldhu	r2,-24(fp)
 821dd98:	1009883a 	mov	r4,r2
 821dd9c:	82199f00 	call	82199f0 <OSSemCreate>
 821dda0:	1007883a 	mov	r3,r2
 821dda4:	e0bff917 	ldw	r2,-28(fp)
 821dda8:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 821ddac:	010ea604 	movi	r4,15000
 821ddb0:	82143d00 	call	82143d0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821ddb4:	e0bff817 	ldw	r2,-32(fp)
 821ddb8:	00c00c04 	movi	r3,48
 821ddbc:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 821ddc0:	01040104 	movi	r4,4100
 821ddc4:	82143d00 	call	82143d0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821ddc8:	e0bff817 	ldw	r2,-32(fp)
 821ddcc:	00c00c04 	movi	r3,48
 821ddd0:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 821ddd4:	0100fa04 	movi	r4,1000
 821ddd8:	82143d00 	call	82143d0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821dddc:	e0bff817 	ldw	r2,-32(fp)
 821dde0:	00c00c04 	movi	r3,48
 821dde4:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 821dde8:	01400e04 	movi	r5,56
 821ddec:	e13ffb17 	ldw	r4,-20(fp)
 821ddf0:	821cfd00 	call	821cfd0 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 821ddf4:	01400204 	movi	r5,8
 821ddf8:	e13ffb17 	ldw	r4,-20(fp)
 821ddfc:	821cfd00 	call	821cfd0 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 821de00:	e13ffb17 	ldw	r4,-20(fp)
 821de04:	821d1600 	call	821d160 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 821de08:	01400184 	movi	r5,6
 821de0c:	e13ffb17 	ldw	r4,-20(fp)
 821de10:	821cfd00 	call	821cfd0 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 821de14:	01400304 	movi	r5,12
 821de18:	e13ffb17 	ldw	r4,-20(fp)
 821de1c:	821cfd00 	call	821cfd0 <lcd_write_command>

  sp->esccount = -1;
 821de20:	e0bffb17 	ldw	r2,-20(fp)
 821de24:	00ffffc4 	movi	r3,-1
 821de28:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
 821de2c:	e0bffb17 	ldw	r2,-20(fp)
 821de30:	10800a04 	addi	r2,r2,40
 821de34:	01800204 	movi	r6,8
 821de38:	000b883a 	mov	r5,zero
 821de3c:	1009883a 	mov	r4,r2
 821de40:	8202cb00 	call	8202cb0 <memset>

  sp->scrollpos = 0;
 821de44:	e0bffb17 	ldw	r2,-20(fp)
 821de48:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 821de4c:	e0bffb17 	ldw	r2,-20(fp)
 821de50:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 821de54:	e0bffb17 	ldw	r2,-20(fp)
 821de58:	100009c5 	stb	zero,39(r2)
 821de5c:	d0e0b817 	ldw	r3,-32032(gp)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 821de60:	00b33374 	movhi	r2,52429
 821de64:	10b33344 	addi	r2,r2,-13107
 821de68:	1888383a 	mulxuu	r4,r3,r2
 821de6c:	1885383a 	mul	r2,r3,r2
 821de70:	1021883a 	mov	r16,r2
 821de74:	2023883a 	mov	r17,r4
 821de78:	8804d0fa 	srli	r2,r17,3
 821de7c:	1007883a 	mov	r3,r2
 821de80:	e0bffb17 	ldw	r2,-20(fp)
 821de84:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 821de88:	e0bffb17 	ldw	r2,-20(fp)
 821de8c:	10c00104 	addi	r3,r2,4
 821de90:	e0bffb17 	ldw	r2,-20(fp)
 821de94:	10800717 	ldw	r2,28(r2)
 821de98:	e1fffb17 	ldw	r7,-20(fp)
 821de9c:	018208b4 	movhi	r6,2082
 821dea0:	31b72904 	addi	r6,r6,-9052
 821dea4:	100b883a 	mov	r5,r2
 821dea8:	1809883a 	mov	r4,r3
 821deac:	823b7080 	call	823b708 <alt_alarm_start>
}
 821deb0:	0001883a 	nop
 821deb4:	e6fffe04 	addi	sp,fp,-8
 821deb8:	dfc00317 	ldw	ra,12(sp)
 821debc:	df000217 	ldw	fp,8(sp)
 821dec0:	dc400117 	ldw	r17,4(sp)
 821dec4:	dc000017 	ldw	r16,0(sp)
 821dec8:	dec00404 	addi	sp,sp,16
 821decc:	f800283a 	ret

0821ded0 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821ded0:	defffa04 	addi	sp,sp,-24
 821ded4:	dfc00515 	stw	ra,20(sp)
 821ded8:	df000415 	stw	fp,16(sp)
 821dedc:	df000404 	addi	fp,sp,16
 821dee0:	e13ffd15 	stw	r4,-12(fp)
 821dee4:	e17ffe15 	stw	r5,-8(fp)
 821dee8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 821deec:	e0bffd17 	ldw	r2,-12(fp)
 821def0:	10800017 	ldw	r2,0(r2)
 821def4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 821def8:	e0bffc17 	ldw	r2,-16(fp)
 821defc:	10c00a04 	addi	r3,r2,40
 821df00:	e0bffd17 	ldw	r2,-12(fp)
 821df04:	10800217 	ldw	r2,8(r2)
 821df08:	100f883a 	mov	r7,r2
 821df0c:	e1bfff17 	ldw	r6,-4(fp)
 821df10:	e17ffe17 	ldw	r5,-8(fp)
 821df14:	1809883a 	mov	r4,r3
 821df18:	821d7940 	call	821d794 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 821df1c:	e037883a 	mov	sp,fp
 821df20:	dfc00117 	ldw	ra,4(sp)
 821df24:	df000017 	ldw	fp,0(sp)
 821df28:	dec00204 	addi	sp,sp,8
 821df2c:	f800283a 	ret

0821df30 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 821df30:	defffe04 	addi	sp,sp,-8
 821df34:	dfc00115 	stw	ra,4(sp)
 821df38:	df000015 	stw	fp,0(sp)
 821df3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 821df40:	d0a04717 	ldw	r2,-32484(gp)
 821df44:	10000326 	beq	r2,zero,821df54 <alt_get_errno+0x24>
 821df48:	d0a04717 	ldw	r2,-32484(gp)
 821df4c:	103ee83a 	callr	r2
 821df50:	00000106 	br	821df58 <alt_get_errno+0x28>
 821df54:	d0a06304 	addi	r2,gp,-32372
}
 821df58:	e037883a 	mov	sp,fp
 821df5c:	dfc00117 	ldw	ra,4(sp)
 821df60:	df000017 	ldw	fp,0(sp)
 821df64:	dec00204 	addi	sp,sp,8
 821df68:	f800283a 	ret

0821df6c <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821df6c:	defffc04 	addi	sp,sp,-16
 821df70:	df000315 	stw	fp,12(sp)
 821df74:	df000304 	addi	fp,sp,12
 821df78:	e13ffe15 	stw	r4,-8(fp)
 821df7c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821df80:	e0bffe17 	ldw	r2,-8(fp)
 821df84:	10800317 	ldw	r2,12(r2)
 821df88:	10800037 	ldwio	r2,0(r2)
 821df8c:	1080040c 	andi	r2,r2,16
 821df90:	10000226 	beq	r2,zero,821df9c <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 821df94:	00bffc04 	movi	r2,-16
 821df98:	00003906 	br	821e080 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821df9c:	e0bffe17 	ldw	r2,-8(fp)
 821dfa0:	10800317 	ldw	r2,12(r2)
 821dfa4:	10800404 	addi	r2,r2,16
 821dfa8:	e0fffe17 	ldw	r3,-8(fp)
 821dfac:	18c00317 	ldw	r3,12(r3)
 821dfb0:	18c00404 	addi	r3,r3,16
 821dfb4:	19000037 	ldwio	r4,0(r3)
 821dfb8:	00fff7c4 	movi	r3,-33
 821dfbc:	20c6703a 	and	r3,r4,r3
 821dfc0:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821dfc4:	e0bffe17 	ldw	r2,-8(fp)
 821dfc8:	10800317 	ldw	r2,12(r2)
 821dfcc:	00c03fc4 	movi	r3,255
 821dfd0:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821dfd4:	e0bffe17 	ldw	r2,-8(fp)
 821dfd8:	10800317 	ldw	r2,12(r2)
 821dfdc:	10800804 	addi	r2,r2,32
 821dfe0:	e0ffff17 	ldw	r3,-4(fp)
 821dfe4:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 821dfe8:	e0bffe17 	ldw	r2,-8(fp)
 821dfec:	10800917 	ldw	r2,36(r2)
 821dff0:	10001126 	beq	r2,zero,821e038 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821dff4:	e0bffe17 	ldw	r2,-8(fp)
 821dff8:	10800317 	ldw	r2,12(r2)
 821dffc:	10800404 	addi	r2,r2,16
 821e000:	10800037 	ldwio	r2,0(r2)
 821e004:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 821e008:	e0bffe17 	ldw	r2,-8(fp)
 821e00c:	10c00b17 	ldw	r3,44(r2)
 821e010:	e0bffd17 	ldw	r2,-12(fp)
 821e014:	1884b03a 	or	r2,r3,r2
 821e018:	10801814 	ori	r2,r2,96
 821e01c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e020:	e0bffe17 	ldw	r2,-8(fp)
 821e024:	10800317 	ldw	r2,12(r2)
 821e028:	10800404 	addi	r2,r2,16
 821e02c:	e0fffd17 	ldw	r3,-12(fp)
 821e030:	10c00035 	stwio	r3,0(r2)
 821e034:	00001106 	br	821e07c <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e038:	e0bffe17 	ldw	r2,-8(fp)
 821e03c:	10800317 	ldw	r2,12(r2)
 821e040:	10800404 	addi	r2,r2,16
 821e044:	10800037 	ldwio	r2,0(r2)
 821e048:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 821e04c:	e0bffd17 	ldw	r2,-12(fp)
 821e050:	10801814 	ori	r2,r2,96
 821e054:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 821e058:	e0fffd17 	ldw	r3,-12(fp)
 821e05c:	00bffbc4 	movi	r2,-17
 821e060:	1884703a 	and	r2,r3,r2
 821e064:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e068:	e0bffe17 	ldw	r2,-8(fp)
 821e06c:	10800317 	ldw	r2,12(r2)
 821e070:	10800404 	addi	r2,r2,16
 821e074:	e0fffd17 	ldw	r3,-12(fp)
 821e078:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 821e07c:	0005883a 	mov	r2,zero
}
 821e080:	e037883a 	mov	sp,fp
 821e084:	df000017 	ldw	fp,0(sp)
 821e088:	dec00104 	addi	sp,sp,4
 821e08c:	f800283a 	ret

0821e090 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e090:	defffc04 	addi	sp,sp,-16
 821e094:	df000315 	stw	fp,12(sp)
 821e098:	df000304 	addi	fp,sp,12
 821e09c:	e13ffe15 	stw	r4,-8(fp)
 821e0a0:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e0a4:	0001883a 	nop
 821e0a8:	e0bffe17 	ldw	r2,-8(fp)
 821e0ac:	10800317 	ldw	r2,12(r2)
 821e0b0:	10800037 	ldwio	r2,0(r2)
 821e0b4:	1080040c 	andi	r2,r2,16
 821e0b8:	103ffb1e 	bne	r2,zero,821e0a8 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e0bc:	e0bffe17 	ldw	r2,-8(fp)
 821e0c0:	10800317 	ldw	r2,12(r2)
 821e0c4:	10800404 	addi	r2,r2,16
 821e0c8:	e0fffe17 	ldw	r3,-8(fp)
 821e0cc:	18c00317 	ldw	r3,12(r3)
 821e0d0:	18c00404 	addi	r3,r3,16
 821e0d4:	19000037 	ldwio	r4,0(r3)
 821e0d8:	00fff7c4 	movi	r3,-33
 821e0dc:	20c6703a 	and	r3,r4,r3
 821e0e0:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e0e4:	e0bffe17 	ldw	r2,-8(fp)
 821e0e8:	10800317 	ldw	r2,12(r2)
 821e0ec:	00c03fc4 	movi	r3,255
 821e0f0:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e0f4:	e0bffe17 	ldw	r2,-8(fp)
 821e0f8:	10800317 	ldw	r2,12(r2)
 821e0fc:	10800804 	addi	r2,r2,32
 821e100:	e0ffff17 	ldw	r3,-4(fp)
 821e104:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e108:	e0bffe17 	ldw	r2,-8(fp)
 821e10c:	10800317 	ldw	r2,12(r2)
 821e110:	10800404 	addi	r2,r2,16
 821e114:	e0fffe17 	ldw	r3,-8(fp)
 821e118:	18c00317 	ldw	r3,12(r3)
 821e11c:	18c00404 	addi	r3,r3,16
 821e120:	18c00037 	ldwio	r3,0(r3)
 821e124:	18c01814 	ori	r3,r3,96
 821e128:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e12c:	0001883a 	nop
 821e130:	e0bffe17 	ldw	r2,-8(fp)
 821e134:	10800317 	ldw	r2,12(r2)
 821e138:	10800037 	ldwio	r2,0(r2)
 821e13c:	1080040c 	andi	r2,r2,16
 821e140:	103ffb1e 	bne	r2,zero,821e130 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821e144:	e0bffe17 	ldw	r2,-8(fp)
 821e148:	10800317 	ldw	r2,12(r2)
 821e14c:	10800404 	addi	r2,r2,16
 821e150:	e0fffe17 	ldw	r3,-8(fp)
 821e154:	18c00317 	ldw	r3,12(r3)
 821e158:	18c00404 	addi	r3,r3,16
 821e15c:	19000037 	ldwio	r4,0(r3)
 821e160:	00fff7c4 	movi	r3,-33
 821e164:	20c6703a 	and	r3,r4,r3
 821e168:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 821e16c:	e0bffe17 	ldw	r2,-8(fp)
 821e170:	10800317 	ldw	r2,12(r2)
 821e174:	10800037 	ldwio	r2,0(r2)
 821e178:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e17c:	e0bffe17 	ldw	r2,-8(fp)
 821e180:	10800317 	ldw	r2,12(r2)
 821e184:	00c03fc4 	movi	r3,255
 821e188:	10c00035 	stwio	r3,0(r2)

  return status;
 821e18c:	e0bffd03 	ldbu	r2,-12(fp)
}
 821e190:	e037883a 	mov	sp,fp
 821e194:	df000017 	ldw	fp,0(sp)
 821e198:	dec00104 	addi	sp,sp,4
 821e19c:	f800283a 	ret

0821e1a0 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 821e1a0:	defff404 	addi	sp,sp,-48
 821e1a4:	dfc00b15 	stw	ra,44(sp)
 821e1a8:	df000a15 	stw	fp,40(sp)
 821e1ac:	df000a04 	addi	fp,sp,40
 821e1b0:	e13ffb15 	stw	r4,-20(fp)
 821e1b4:	e17ffc15 	stw	r5,-16(fp)
 821e1b8:	e1bffd15 	stw	r6,-12(fp)
 821e1bc:	e1fffe15 	stw	r7,-8(fp)
 821e1c0:	e0800217 	ldw	r2,8(fp)
 821e1c4:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 821e1c8:	e0bfff0b 	ldhu	r2,-4(fp)
 821e1cc:	d8000415 	stw	zero,16(sp)
 821e1d0:	d8000315 	stw	zero,12(sp)
 821e1d4:	e0c00417 	ldw	r3,16(fp)
 821e1d8:	d8c00215 	stw	r3,8(sp)
 821e1dc:	e0c00317 	ldw	r3,12(fp)
 821e1e0:	d8c00115 	stw	r3,4(sp)
 821e1e4:	d8800015 	stw	r2,0(sp)
 821e1e8:	e1fffe17 	ldw	r7,-8(fp)
 821e1ec:	e1bffd17 	ldw	r6,-12(fp)
 821e1f0:	e17ffc17 	ldw	r5,-16(fp)
 821e1f4:	e13ffb17 	ldw	r4,-20(fp)
 821e1f8:	821e2140 	call	821e214 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 821e1fc:	0001883a 	nop
 821e200:	e037883a 	mov	sp,fp
 821e204:	dfc00117 	ldw	ra,4(sp)
 821e208:	df000017 	ldw	fp,0(sp)
 821e20c:	dec00204 	addi	sp,sp,8
 821e210:	f800283a 	ret

0821e214 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 821e214:	defff204 	addi	sp,sp,-56
 821e218:	dfc00d15 	stw	ra,52(sp)
 821e21c:	df000c15 	stw	fp,48(sp)
 821e220:	df000c04 	addi	fp,sp,48
 821e224:	e13ffb15 	stw	r4,-20(fp)
 821e228:	e17ffc15 	stw	r5,-16(fp)
 821e22c:	e1bffd15 	stw	r6,-12(fp)
 821e230:	e1fffe15 	stw	r7,-8(fp)
 821e234:	e0800217 	ldw	r2,8(fp)
 821e238:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e23c:	e0bfff0b 	ldhu	r2,-4(fp)
 821e240:	d8000615 	stw	zero,24(sp)
 821e244:	e0c00617 	ldw	r3,24(fp)
 821e248:	d8c00515 	stw	r3,20(sp)
 821e24c:	e0c00517 	ldw	r3,20(fp)
 821e250:	d8c00415 	stw	r3,16(sp)
 821e254:	e0c00417 	ldw	r3,16(fp)
 821e258:	d8c00315 	stw	r3,12(sp)
 821e25c:	e0c00317 	ldw	r3,12(fp)
 821e260:	d8c00215 	stw	r3,8(sp)
 821e264:	d8000115 	stw	zero,4(sp)
 821e268:	d8800015 	stw	r2,0(sp)
 821e26c:	e1fffe17 	ldw	r7,-8(fp)
 821e270:	e1bffd17 	ldw	r6,-12(fp)
 821e274:	e17ffc17 	ldw	r5,-16(fp)
 821e278:	e13ffb17 	ldw	r4,-20(fp)
 821e27c:	821e7a80 	call	821e7a8 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 821e280:	0001883a 	nop
 821e284:	e037883a 	mov	sp,fp
 821e288:	dfc00117 	ldw	ra,4(sp)
 821e28c:	df000017 	ldw	fp,0(sp)
 821e290:	dec00204 	addi	sp,sp,8
 821e294:	f800283a 	ret

0821e298 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 821e298:	defff804 	addi	sp,sp,-32
 821e29c:	dfc00715 	stw	ra,28(sp)
 821e2a0:	df000615 	stw	fp,24(sp)
 821e2a4:	df000604 	addi	fp,sp,24
 821e2a8:	e13ffc15 	stw	r4,-16(fp)
 821e2ac:	e17ffd15 	stw	r5,-12(fp)
 821e2b0:	e1bffe15 	stw	r6,-8(fp)
 821e2b4:	3805883a 	mov	r2,r7
 821e2b8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 821e2bc:	e0ffff0b 	ldhu	r3,-4(fp)
 821e2c0:	d8000115 	stw	zero,4(sp)
 821e2c4:	e0800217 	ldw	r2,8(fp)
 821e2c8:	d8800015 	stw	r2,0(sp)
 821e2cc:	180f883a 	mov	r7,r3
 821e2d0:	e1bffe17 	ldw	r6,-8(fp)
 821e2d4:	e17ffd17 	ldw	r5,-12(fp)
 821e2d8:	e13ffc17 	ldw	r4,-16(fp)
 821e2dc:	821e2f80 	call	821e2f8 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 821e2e0:	0001883a 	nop
 821e2e4:	e037883a 	mov	sp,fp
 821e2e8:	dfc00117 	ldw	ra,4(sp)
 821e2ec:	df000017 	ldw	fp,0(sp)
 821e2f0:	dec00204 	addi	sp,sp,8
 821e2f4:	f800283a 	ret

0821e2f8 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 821e2f8:	defff304 	addi	sp,sp,-52
 821e2fc:	dfc00c15 	stw	ra,48(sp)
 821e300:	df000b15 	stw	fp,44(sp)
 821e304:	df000b04 	addi	fp,sp,44
 821e308:	e13ffc15 	stw	r4,-16(fp)
 821e30c:	e17ffd15 	stw	r5,-12(fp)
 821e310:	e1bffe15 	stw	r6,-8(fp)
 821e314:	3805883a 	mov	r2,r7
 821e318:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e31c:	e0bfff0b 	ldhu	r2,-4(fp)
 821e320:	d8000615 	stw	zero,24(sp)
 821e324:	e0c00317 	ldw	r3,12(fp)
 821e328:	d8c00515 	stw	r3,20(sp)
 821e32c:	d8000415 	stw	zero,16(sp)
 821e330:	e0c00217 	ldw	r3,8(fp)
 821e334:	d8c00315 	stw	r3,12(sp)
 821e338:	d8000215 	stw	zero,8(sp)
 821e33c:	d8000115 	stw	zero,4(sp)
 821e340:	d8800015 	stw	r2,0(sp)
 821e344:	e1fffe17 	ldw	r7,-8(fp)
 821e348:	000d883a 	mov	r6,zero
 821e34c:	e17ffd17 	ldw	r5,-12(fp)
 821e350:	e13ffc17 	ldw	r4,-16(fp)
 821e354:	821e7a80 	call	821e7a8 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 821e358:	0001883a 	nop
 821e35c:	e037883a 	mov	sp,fp
 821e360:	dfc00117 	ldw	ra,4(sp)
 821e364:	df000017 	ldw	fp,0(sp)
 821e368:	dec00204 	addi	sp,sp,8
 821e36c:	f800283a 	ret

0821e370 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 821e370:	defff404 	addi	sp,sp,-48
 821e374:	dfc00b15 	stw	ra,44(sp)
 821e378:	df000a15 	stw	fp,40(sp)
 821e37c:	df000a04 	addi	fp,sp,40
 821e380:	e13ffb15 	stw	r4,-20(fp)
 821e384:	e17ffc15 	stw	r5,-16(fp)
 821e388:	e1bffd15 	stw	r6,-12(fp)
 821e38c:	3807883a 	mov	r3,r7
 821e390:	e0800517 	ldw	r2,20(fp)
 821e394:	e0fffe0d 	sth	r3,-8(fp)
 821e398:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 821e39c:	e0fffe0b 	ldhu	r3,-8(fp)
 821e3a0:	e0bfff03 	ldbu	r2,-4(fp)
 821e3a4:	d8800415 	stw	r2,16(sp)
 821e3a8:	d8000315 	stw	zero,12(sp)
 821e3ac:	e0800417 	ldw	r2,16(fp)
 821e3b0:	d8800215 	stw	r2,8(sp)
 821e3b4:	e0800317 	ldw	r2,12(fp)
 821e3b8:	d8800115 	stw	r2,4(sp)
 821e3bc:	e0800217 	ldw	r2,8(fp)
 821e3c0:	d8800015 	stw	r2,0(sp)
 821e3c4:	180f883a 	mov	r7,r3
 821e3c8:	e1bffd17 	ldw	r6,-12(fp)
 821e3cc:	e17ffc17 	ldw	r5,-16(fp)
 821e3d0:	e13ffb17 	ldw	r4,-20(fp)
 821e3d4:	821e3f00 	call	821e3f0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 821e3d8:	0001883a 	nop
 821e3dc:	e037883a 	mov	sp,fp
 821e3e0:	dfc00117 	ldw	ra,4(sp)
 821e3e4:	df000017 	ldw	fp,0(sp)
 821e3e8:	dec00204 	addi	sp,sp,8
 821e3ec:	f800283a 	ret

0821e3f0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 821e3f0:	defff204 	addi	sp,sp,-56
 821e3f4:	dfc00d15 	stw	ra,52(sp)
 821e3f8:	df000c15 	stw	fp,48(sp)
 821e3fc:	df000c04 	addi	fp,sp,48
 821e400:	e13ffb15 	stw	r4,-20(fp)
 821e404:	e17ffc15 	stw	r5,-16(fp)
 821e408:	e1bffd15 	stw	r6,-12(fp)
 821e40c:	3807883a 	mov	r3,r7
 821e410:	e0800617 	ldw	r2,24(fp)
 821e414:	e0fffe0d 	sth	r3,-8(fp)
 821e418:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e41c:	e0bffe0b 	ldhu	r2,-8(fp)
 821e420:	e0ffff03 	ldbu	r3,-4(fp)
 821e424:	d8c00615 	stw	r3,24(sp)
 821e428:	d8000515 	stw	zero,20(sp)
 821e42c:	e0c00517 	ldw	r3,20(fp)
 821e430:	d8c00415 	stw	r3,16(sp)
 821e434:	e0c00317 	ldw	r3,12(fp)
 821e438:	d8c00315 	stw	r3,12(sp)
 821e43c:	e0c00217 	ldw	r3,8(fp)
 821e440:	d8c00215 	stw	r3,8(sp)
 821e444:	e0c00417 	ldw	r3,16(fp)
 821e448:	d8c00115 	stw	r3,4(sp)
 821e44c:	d8800015 	stw	r2,0(sp)
 821e450:	000f883a 	mov	r7,zero
 821e454:	e1bffd17 	ldw	r6,-12(fp)
 821e458:	e17ffc17 	ldw	r5,-16(fp)
 821e45c:	e13ffb17 	ldw	r4,-20(fp)
 821e460:	821e7a80 	call	821e7a8 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 821e464:	0001883a 	nop
 821e468:	e037883a 	mov	sp,fp
 821e46c:	dfc00117 	ldw	ra,4(sp)
 821e470:	df000017 	ldw	fp,0(sp)
 821e474:	dec00204 	addi	sp,sp,8
 821e478:	f800283a 	ret

0821e47c <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 821e47c:	defffb04 	addi	sp,sp,-20
 821e480:	df000415 	stw	fp,16(sp)
 821e484:	df000404 	addi	fp,sp,16
 821e488:	e13ffc15 	stw	r4,-16(fp)
 821e48c:	e17ffd15 	stw	r5,-12(fp)
 821e490:	e1bffe15 	stw	r6,-8(fp)
 821e494:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 821e498:	e0bffc17 	ldw	r2,-16(fp)
 821e49c:	e0fffd17 	ldw	r3,-12(fp)
 821e4a0:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 821e4a4:	e0bffc17 	ldw	r2,-16(fp)
 821e4a8:	e0ffff17 	ldw	r3,-4(fp)
 821e4ac:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 821e4b0:	e0bffc17 	ldw	r2,-16(fp)
 821e4b4:	e0fffe17 	ldw	r3,-8(fp)
 821e4b8:	10c00b15 	stw	r3,44(r2)
}
 821e4bc:	0001883a 	nop
 821e4c0:	e037883a 	mov	sp,fp
 821e4c4:	df000017 	ldw	fp,0(sp)
 821e4c8:	dec00104 	addi	sp,sp,4
 821e4cc:	f800283a 	ret

0821e4d0 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 821e4d0:	defffd04 	addi	sp,sp,-12
 821e4d4:	df000215 	stw	fp,8(sp)
 821e4d8:	df000204 	addi	fp,sp,8
 821e4dc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e4e0:	e0bfff17 	ldw	r2,-4(fp)
 821e4e4:	10800317 	ldw	r2,12(r2)
 821e4e8:	10800404 	addi	r2,r2,16
 821e4ec:	10800037 	ldwio	r2,0(r2)
 821e4f0:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e4f4:	e0bffe17 	ldw	r2,-8(fp)
 821e4f8:	10800814 	ori	r2,r2,32
 821e4fc:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e500:	e0bfff17 	ldw	r2,-4(fp)
 821e504:	10800317 	ldw	r2,12(r2)
 821e508:	10800404 	addi	r2,r2,16
 821e50c:	e0fffe17 	ldw	r3,-8(fp)
 821e510:	10c00035 	stwio	r3,0(r2)
}
 821e514:	0001883a 	nop
 821e518:	e037883a 	mov	sp,fp
 821e51c:	df000017 	ldw	fp,0(sp)
 821e520:	dec00104 	addi	sp,sp,4
 821e524:	f800283a 	ret

0821e528 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 821e528:	defffd04 	addi	sp,sp,-12
 821e52c:	df000215 	stw	fp,8(sp)
 821e530:	df000204 	addi	fp,sp,8
 821e534:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e538:	e0bfff17 	ldw	r2,-4(fp)
 821e53c:	10800317 	ldw	r2,12(r2)
 821e540:	10800404 	addi	r2,r2,16
 821e544:	10800037 	ldwio	r2,0(r2)
 821e548:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e54c:	e0fffe17 	ldw	r3,-8(fp)
 821e550:	00bff7c4 	movi	r2,-33
 821e554:	1884703a 	and	r2,r3,r2
 821e558:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e55c:	e0bfff17 	ldw	r2,-4(fp)
 821e560:	10800317 	ldw	r2,12(r2)
 821e564:	10800404 	addi	r2,r2,16
 821e568:	e0fffe17 	ldw	r3,-8(fp)
 821e56c:	10c00035 	stwio	r3,0(r2)
}
 821e570:	0001883a 	nop
 821e574:	e037883a 	mov	sp,fp
 821e578:	df000017 	ldw	fp,0(sp)
 821e57c:	dec00104 	addi	sp,sp,4
 821e580:	f800283a 	ret

0821e584 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 821e584:	defffe04 	addi	sp,sp,-8
 821e588:	df000115 	stw	fp,4(sp)
 821e58c:	df000104 	addi	fp,sp,4
 821e590:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 821e594:	e0bfff17 	ldw	r2,-4(fp)
 821e598:	10800784 	addi	r2,r2,30
 821e59c:	10800023 	ldbuio	r2,0(r2)
 821e5a0:	10803fcc 	andi	r2,r2,255
 821e5a4:	10801fcc 	andi	r2,r2,127
 821e5a8:	10000226 	beq	r2,zero,821e5b4 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 821e5ac:	00bffec4 	movi	r2,-5
 821e5b0:	00000906 	br	821e5d8 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 821e5b4:	e0bfff17 	ldw	r2,-4(fp)
 821e5b8:	108007c4 	addi	r2,r2,31
 821e5bc:	10800023 	ldbuio	r2,0(r2)
 821e5c0:	10803fcc 	andi	r2,r2,255
 821e5c4:	1080200c 	andi	r2,r2,128
 821e5c8:	10000226 	beq	r2,zero,821e5d4 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 821e5cc:	00bfe244 	movi	r2,-119
 821e5d0:	00000106 	br	821e5d8 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 821e5d4:	0005883a 	mov	r2,zero
}
 821e5d8:	e037883a 	mov	sp,fp
 821e5dc:	df000017 	ldw	fp,0(sp)
 821e5e0:	dec00104 	addi	sp,sp,4
 821e5e4:	f800283a 	ret

0821e5e8 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 821e5e8:	defffc04 	addi	sp,sp,-16
 821e5ec:	dfc00315 	stw	ra,12(sp)
 821e5f0:	df000215 	stw	fp,8(sp)
 821e5f4:	df000204 	addi	fp,sp,8
 821e5f8:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 821e5fc:	d1602b04 	addi	r5,gp,-32596
 821e600:	e13fff17 	ldw	r4,-4(fp)
 821e604:	823bcdc0 	call	823bcdc <alt_find_dev>
 821e608:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 821e60c:	e0bffe17 	ldw	r2,-8(fp)
 821e610:	1000041e 	bne	r2,zero,821e624 <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 821e614:	821df300 	call	821df30 <alt_get_errno>
 821e618:	1007883a 	mov	r3,r2
 821e61c:	008004c4 	movi	r2,19
 821e620:	18800015 	stw	r2,0(r3)
  }

  return dev;
 821e624:	e0bffe17 	ldw	r2,-8(fp)
}
 821e628:	e037883a 	mov	sp,fp
 821e62c:	dfc00117 	ldw	ra,4(sp)
 821e630:	df000017 	ldw	fp,0(sp)
 821e634:	dec00204 	addi	sp,sp,8
 821e638:	f800283a 	ret

0821e63c <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 821e63c:	defff104 	addi	sp,sp,-60
 821e640:	dfc00e15 	stw	ra,56(sp)
 821e644:	df000d15 	stw	fp,52(sp)
 821e648:	df000d04 	addi	fp,sp,52
 821e64c:	e13ffa15 	stw	r4,-24(fp)
 821e650:	e17ffb15 	stw	r5,-20(fp)
 821e654:	e1bffc15 	stw	r6,-16(fp)
 821e658:	e1fffd15 	stw	r7,-12(fp)
 821e65c:	e0c00217 	ldw	r3,8(fp)
 821e660:	e0800617 	ldw	r2,24(fp)
 821e664:	e0fffe0d 	sth	r3,-8(fp)
 821e668:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 821e66c:	e0bffe0b 	ldhu	r2,-8(fp)
 821e670:	e0ffff03 	ldbu	r3,-4(fp)
 821e674:	d8c00615 	stw	r3,24(sp)
 821e678:	d8000515 	stw	zero,20(sp)
 821e67c:	d8000415 	stw	zero,16(sp)
 821e680:	e0c00517 	ldw	r3,20(fp)
 821e684:	d8c00315 	stw	r3,12(sp)
 821e688:	e0c00417 	ldw	r3,16(fp)
 821e68c:	d8c00215 	stw	r3,8(sp)
 821e690:	e0c00317 	ldw	r3,12(fp)
 821e694:	d8c00115 	stw	r3,4(sp)
 821e698:	d8800015 	stw	r2,0(sp)
 821e69c:	e1fffd17 	ldw	r7,-12(fp)
 821e6a0:	e1bffc17 	ldw	r6,-16(fp)
 821e6a4:	e17ffb17 	ldw	r5,-20(fp)
 821e6a8:	e13ffa17 	ldw	r4,-24(fp)
 821e6ac:	821e7a80 	call	821e7a8 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 821e6b0:	0001883a 	nop
 821e6b4:	e037883a 	mov	sp,fp
 821e6b8:	dfc00117 	ldw	ra,4(sp)
 821e6bc:	df000017 	ldw	fp,0(sp)
 821e6c0:	dec00204 	addi	sp,sp,8
 821e6c4:	f800283a 	ret

0821e6c8 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 821e6c8:	defffc04 	addi	sp,sp,-16
 821e6cc:	df000315 	stw	fp,12(sp)
 821e6d0:	df000304 	addi	fp,sp,12
 821e6d4:	e13ffe15 	stw	r4,-8(fp)
 821e6d8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e6dc:	e0bffe17 	ldw	r2,-8(fp)
 821e6e0:	10800317 	ldw	r2,12(r2)
 821e6e4:	10800404 	addi	r2,r2,16
 821e6e8:	10800037 	ldwio	r2,0(r2)
 821e6ec:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 821e6f0:	e0fffd17 	ldw	r3,-12(fp)
 821e6f4:	00a00434 	movhi	r2,32784
 821e6f8:	10bfffc4 	addi	r2,r2,-1
 821e6fc:	1884703a 	and	r2,r3,r2
 821e700:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 821e704:	e0bfff17 	ldw	r2,-4(fp)
 821e708:	1004953a 	slli	r2,r2,20
 821e70c:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 821e710:	e0bffd17 	ldw	r2,-12(fp)
 821e714:	1884b03a 	or	r2,r3,r2
 821e718:	10800134 	orhi	r2,r2,4
 821e71c:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e720:	e0bffe17 	ldw	r2,-8(fp)
 821e724:	10800317 	ldw	r2,12(r2)
 821e728:	10800404 	addi	r2,r2,16
 821e72c:	e0fffd17 	ldw	r3,-12(fp)
 821e730:	10c00035 	stwio	r3,0(r2)
  
  return;
 821e734:	0001883a 	nop
}
 821e738:	e037883a 	mov	sp,fp
 821e73c:	df000017 	ldw	fp,0(sp)
 821e740:	dec00104 	addi	sp,sp,4
 821e744:	f800283a 	ret

0821e748 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 821e748:	defffd04 	addi	sp,sp,-12
 821e74c:	df000215 	stw	fp,8(sp)
 821e750:	df000204 	addi	fp,sp,8
 821e754:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e758:	e0bfff17 	ldw	r2,-4(fp)
 821e75c:	10800317 	ldw	r2,12(r2)
 821e760:	10800404 	addi	r2,r2,16
 821e764:	10800037 	ldwio	r2,0(r2)
 821e768:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 821e76c:	e0fffe17 	ldw	r3,-8(fp)
 821e770:	00bfff34 	movhi	r2,65532
 821e774:	10bfffc4 	addi	r2,r2,-1
 821e778:	1884703a 	and	r2,r3,r2
 821e77c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e780:	e0bfff17 	ldw	r2,-4(fp)
 821e784:	10800317 	ldw	r2,12(r2)
 821e788:	10800404 	addi	r2,r2,16
 821e78c:	e0fffe17 	ldw	r3,-8(fp)
 821e790:	10c00035 	stwio	r3,0(r2)
  
  return;
 821e794:	0001883a 	nop
}
 821e798:	e037883a 	mov	sp,fp
 821e79c:	df000017 	ldw	fp,0(sp)
 821e7a0:	dec00104 	addi	sp,sp,4
 821e7a4:	f800283a 	ret

0821e7a8 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 821e7a8:	defff804 	addi	sp,sp,-32
 821e7ac:	dfc00715 	stw	ra,28(sp)
 821e7b0:	df000615 	stw	fp,24(sp)
 821e7b4:	df000604 	addi	fp,sp,24
 821e7b8:	e13ffa15 	stw	r4,-24(fp)
 821e7bc:	e17ffb15 	stw	r5,-20(fp)
 821e7c0:	e1bffc15 	stw	r6,-16(fp)
 821e7c4:	e1fffd15 	stw	r7,-12(fp)
 821e7c8:	e0c00217 	ldw	r3,8(fp)
 821e7cc:	e0800817 	ldw	r2,32(fp)
 821e7d0:	e0fffe0d 	sth	r3,-8(fp)
 821e7d4:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 821e7d8:	e0bffb17 	ldw	r2,-20(fp)
 821e7dc:	108007c4 	addi	r2,r2,31
 821e7e0:	e0fffb17 	ldw	r3,-20(fp)
 821e7e4:	18c007c3 	ldbu	r3,31(r3)
 821e7e8:	19003fcc 	andi	r4,r3,255
 821e7ec:	00ffdfc4 	movi	r3,-129
 821e7f0:	20c6703a 	and	r3,r4,r3
 821e7f4:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 821e7f8:	e0bffa17 	ldw	r2,-24(fp)
 821e7fc:	e0fffc17 	ldw	r3,-16(fp)
 821e800:	19403fcc 	andi	r5,r3,255
 821e804:	10c00003 	ldbu	r3,0(r2)
 821e808:	1806703a 	and	r3,r3,zero
 821e80c:	1809883a 	mov	r4,r3
 821e810:	2807883a 	mov	r3,r5
 821e814:	20c6b03a 	or	r3,r4,r3
 821e818:	10c00005 	stb	r3,0(r2)
 821e81c:	e0fffc17 	ldw	r3,-16(fp)
 821e820:	1806d23a 	srli	r3,r3,8
 821e824:	19403fcc 	andi	r5,r3,255
 821e828:	10c00043 	ldbu	r3,1(r2)
 821e82c:	1806703a 	and	r3,r3,zero
 821e830:	1809883a 	mov	r4,r3
 821e834:	2807883a 	mov	r3,r5
 821e838:	20c6b03a 	or	r3,r4,r3
 821e83c:	10c00045 	stb	r3,1(r2)
 821e840:	e0fffc17 	ldw	r3,-16(fp)
 821e844:	1806d43a 	srli	r3,r3,16
 821e848:	19403fcc 	andi	r5,r3,255
 821e84c:	10c00083 	ldbu	r3,2(r2)
 821e850:	1806703a 	and	r3,r3,zero
 821e854:	1809883a 	mov	r4,r3
 821e858:	2807883a 	mov	r3,r5
 821e85c:	20c6b03a 	or	r3,r4,r3
 821e860:	10c00085 	stb	r3,2(r2)
 821e864:	e0fffc17 	ldw	r3,-16(fp)
 821e868:	180ad63a 	srli	r5,r3,24
 821e86c:	10c000c3 	ldbu	r3,3(r2)
 821e870:	1806703a 	and	r3,r3,zero
 821e874:	1809883a 	mov	r4,r3
 821e878:	2807883a 	mov	r3,r5
 821e87c:	20c6b03a 	or	r3,r4,r3
 821e880:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 821e884:	e0bffa17 	ldw	r2,-24(fp)
 821e888:	e0fffd17 	ldw	r3,-12(fp)
 821e88c:	19403fcc 	andi	r5,r3,255
 821e890:	10c00203 	ldbu	r3,8(r2)
 821e894:	1806703a 	and	r3,r3,zero
 821e898:	1809883a 	mov	r4,r3
 821e89c:	2807883a 	mov	r3,r5
 821e8a0:	20c6b03a 	or	r3,r4,r3
 821e8a4:	10c00205 	stb	r3,8(r2)
 821e8a8:	e0fffd17 	ldw	r3,-12(fp)
 821e8ac:	1806d23a 	srli	r3,r3,8
 821e8b0:	19403fcc 	andi	r5,r3,255
 821e8b4:	10c00243 	ldbu	r3,9(r2)
 821e8b8:	1806703a 	and	r3,r3,zero
 821e8bc:	1809883a 	mov	r4,r3
 821e8c0:	2807883a 	mov	r3,r5
 821e8c4:	20c6b03a 	or	r3,r4,r3
 821e8c8:	10c00245 	stb	r3,9(r2)
 821e8cc:	e0fffd17 	ldw	r3,-12(fp)
 821e8d0:	1806d43a 	srli	r3,r3,16
 821e8d4:	19403fcc 	andi	r5,r3,255
 821e8d8:	10c00283 	ldbu	r3,10(r2)
 821e8dc:	1806703a 	and	r3,r3,zero
 821e8e0:	1809883a 	mov	r4,r3
 821e8e4:	2807883a 	mov	r3,r5
 821e8e8:	20c6b03a 	or	r3,r4,r3
 821e8ec:	10c00285 	stb	r3,10(r2)
 821e8f0:	e0fffd17 	ldw	r3,-12(fp)
 821e8f4:	180ad63a 	srli	r5,r3,24
 821e8f8:	10c002c3 	ldbu	r3,11(r2)
 821e8fc:	1806703a 	and	r3,r3,zero
 821e900:	1809883a 	mov	r4,r3
 821e904:	2807883a 	mov	r3,r5
 821e908:	20c6b03a 	or	r3,r4,r3
 821e90c:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 821e910:	e0bffa17 	ldw	r2,-24(fp)
 821e914:	e0fffb17 	ldw	r3,-20(fp)
 821e918:	19403fcc 	andi	r5,r3,255
 821e91c:	10c00403 	ldbu	r3,16(r2)
 821e920:	1806703a 	and	r3,r3,zero
 821e924:	1809883a 	mov	r4,r3
 821e928:	2807883a 	mov	r3,r5
 821e92c:	20c6b03a 	or	r3,r4,r3
 821e930:	10c00405 	stb	r3,16(r2)
 821e934:	e0fffb17 	ldw	r3,-20(fp)
 821e938:	1806d23a 	srli	r3,r3,8
 821e93c:	19403fcc 	andi	r5,r3,255
 821e940:	10c00443 	ldbu	r3,17(r2)
 821e944:	1806703a 	and	r3,r3,zero
 821e948:	1809883a 	mov	r4,r3
 821e94c:	2807883a 	mov	r3,r5
 821e950:	20c6b03a 	or	r3,r4,r3
 821e954:	10c00445 	stb	r3,17(r2)
 821e958:	e0fffb17 	ldw	r3,-20(fp)
 821e95c:	1806d43a 	srli	r3,r3,16
 821e960:	19403fcc 	andi	r5,r3,255
 821e964:	10c00483 	ldbu	r3,18(r2)
 821e968:	1806703a 	and	r3,r3,zero
 821e96c:	1809883a 	mov	r4,r3
 821e970:	2807883a 	mov	r3,r5
 821e974:	20c6b03a 	or	r3,r4,r3
 821e978:	10c00485 	stb	r3,18(r2)
 821e97c:	e0fffb17 	ldw	r3,-20(fp)
 821e980:	180ad63a 	srli	r5,r3,24
 821e984:	10c004c3 	ldbu	r3,19(r2)
 821e988:	1806703a 	and	r3,r3,zero
 821e98c:	1809883a 	mov	r4,r3
 821e990:	2807883a 	mov	r3,r5
 821e994:	20c6b03a 	or	r3,r4,r3
 821e998:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 821e99c:	e0bffa17 	ldw	r2,-24(fp)
 821e9a0:	10c00103 	ldbu	r3,4(r2)
 821e9a4:	1806703a 	and	r3,r3,zero
 821e9a8:	10c00105 	stb	r3,4(r2)
 821e9ac:	10c00143 	ldbu	r3,5(r2)
 821e9b0:	1806703a 	and	r3,r3,zero
 821e9b4:	10c00145 	stb	r3,5(r2)
 821e9b8:	10c00183 	ldbu	r3,6(r2)
 821e9bc:	1806703a 	and	r3,r3,zero
 821e9c0:	10c00185 	stb	r3,6(r2)
 821e9c4:	10c001c3 	ldbu	r3,7(r2)
 821e9c8:	1806703a 	and	r3,r3,zero
 821e9cc:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 821e9d0:	e0bffa17 	ldw	r2,-24(fp)
 821e9d4:	10c00303 	ldbu	r3,12(r2)
 821e9d8:	1806703a 	and	r3,r3,zero
 821e9dc:	10c00305 	stb	r3,12(r2)
 821e9e0:	10c00343 	ldbu	r3,13(r2)
 821e9e4:	1806703a 	and	r3,r3,zero
 821e9e8:	10c00345 	stb	r3,13(r2)
 821e9ec:	10c00383 	ldbu	r3,14(r2)
 821e9f0:	1806703a 	and	r3,r3,zero
 821e9f4:	10c00385 	stb	r3,14(r2)
 821e9f8:	10c003c3 	ldbu	r3,15(r2)
 821e9fc:	1806703a 	and	r3,r3,zero
 821ea00:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 821ea04:	e0bffa17 	ldw	r2,-24(fp)
 821ea08:	10c00503 	ldbu	r3,20(r2)
 821ea0c:	1806703a 	and	r3,r3,zero
 821ea10:	10c00505 	stb	r3,20(r2)
 821ea14:	10c00543 	ldbu	r3,21(r2)
 821ea18:	1806703a 	and	r3,r3,zero
 821ea1c:	10c00545 	stb	r3,21(r2)
 821ea20:	10c00583 	ldbu	r3,22(r2)
 821ea24:	1806703a 	and	r3,r3,zero
 821ea28:	10c00585 	stb	r3,22(r2)
 821ea2c:	10c005c3 	ldbu	r3,23(r2)
 821ea30:	1806703a 	and	r3,r3,zero
 821ea34:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 821ea38:	e0bffa17 	ldw	r2,-24(fp)
 821ea3c:	e0fffe17 	ldw	r3,-8(fp)
 821ea40:	19403fcc 	andi	r5,r3,255
 821ea44:	10c00603 	ldbu	r3,24(r2)
 821ea48:	1806703a 	and	r3,r3,zero
 821ea4c:	1809883a 	mov	r4,r3
 821ea50:	2807883a 	mov	r3,r5
 821ea54:	20c6b03a 	or	r3,r4,r3
 821ea58:	10c00605 	stb	r3,24(r2)
 821ea5c:	e0fffe17 	ldw	r3,-8(fp)
 821ea60:	1806d23a 	srli	r3,r3,8
 821ea64:	19403fcc 	andi	r5,r3,255
 821ea68:	10c00643 	ldbu	r3,25(r2)
 821ea6c:	1806703a 	and	r3,r3,zero
 821ea70:	1809883a 	mov	r4,r3
 821ea74:	2807883a 	mov	r3,r5
 821ea78:	20c6b03a 	or	r3,r4,r3
 821ea7c:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 821ea80:	e0bffa17 	ldw	r2,-24(fp)
 821ea84:	10c00703 	ldbu	r3,28(r2)
 821ea88:	1806703a 	and	r3,r3,zero
 821ea8c:	10c00705 	stb	r3,28(r2)
 821ea90:	10c00743 	ldbu	r3,29(r2)
 821ea94:	1806703a 	and	r3,r3,zero
 821ea98:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 821ea9c:	e0bffa17 	ldw	r2,-24(fp)
 821eaa0:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 821eaa4:	e0800617 	ldw	r2,24(fp)
 821eaa8:	1007883a 	mov	r3,r2
 821eaac:	e0bffa17 	ldw	r2,-24(fp)
 821eab0:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 821eab4:	e0800717 	ldw	r2,28(fp)
 821eab8:	1007883a 	mov	r3,r2
 821eabc:	e0bffa17 	ldw	r2,-24(fp)
 821eac0:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821eac4:	e0800317 	ldw	r2,12(fp)
 821eac8:	10000226 	beq	r2,zero,821ead4 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 821eacc:	00bfe044 	movi	r2,-127
 821ead0:	00000106 	br	821ead8 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 821ead4:	00bfe004 	movi	r2,-128
 821ead8:	e0c00417 	ldw	r3,16(fp)
 821eadc:	18000226 	beq	r3,zero,821eae8 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 821eae0:	00c00084 	movi	r3,2
 821eae4:	00000106 	br	821eaec <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 821eae8:	0007883a 	mov	r3,zero
 821eaec:	10c4b03a 	or	r2,r2,r3
 821eaf0:	1007883a 	mov	r3,r2
 821eaf4:	e0800517 	ldw	r2,20(fp)
 821eaf8:	10000226 	beq	r2,zero,821eb04 <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 821eafc:	00800104 	movi	r2,4
 821eb00:	00000106 	br	821eb08 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 821eb04:	0005883a 	mov	r2,zero
 821eb08:	1884b03a 	or	r2,r3,r2
 821eb0c:	1007883a 	mov	r3,r2
 821eb10:	e0bfff03 	ldbu	r2,-4(fp)
 821eb14:	10000426 	beq	r2,zero,821eb28 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 821eb18:	e0bfff03 	ldbu	r2,-4(fp)
 821eb1c:	108003cc 	andi	r2,r2,15
 821eb20:	100490fa 	slli	r2,r2,3
 821eb24:	00000106 	br	821eb2c <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821eb28:	0005883a 	mov	r2,zero
 821eb2c:	1884b03a 	or	r2,r3,r2
 821eb30:	1007883a 	mov	r3,r2
 821eb34:	e0bffa17 	ldw	r2,-24(fp)
 821eb38:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 821eb3c:	01400804 	movi	r5,32
 821eb40:	e13ffa17 	ldw	r4,-24(fp)
 821eb44:	823ba980 	call	823ba98 <alt_dcache_flush>
}
 821eb48:	0001883a 	nop
 821eb4c:	e037883a 	mov	sp,fp
 821eb50:	dfc00117 	ldw	ra,4(sp)
 821eb54:	df000017 	ldw	fp,0(sp)
 821eb58:	dec00204 	addi	sp,sp,8
 821eb5c:	f800283a 	ret

0821eb60 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 821eb60:	defff904 	addi	sp,sp,-28
 821eb64:	dfc00615 	stw	ra,24(sp)
 821eb68:	df000515 	stw	fp,20(sp)
 821eb6c:	df000504 	addi	fp,sp,20
 821eb70:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 821eb74:	e0bfff17 	ldw	r2,-4(fp)
 821eb78:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821eb7c:	e0bffb17 	ldw	r2,-20(fp)
 821eb80:	10800317 	ldw	r2,12(r2)
 821eb84:	10800404 	addi	r2,r2,16
 821eb88:	e0fffb17 	ldw	r3,-20(fp)
 821eb8c:	18c00317 	ldw	r3,12(r3)
 821eb90:	18c00404 	addi	r3,r3,16
 821eb94:	18c00037 	ldwio	r3,0(r3)
 821eb98:	18e00034 	orhi	r3,r3,32768
 821eb9c:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821eba0:	e0bffb17 	ldw	r2,-20(fp)
 821eba4:	10800317 	ldw	r2,12(r2)
 821eba8:	10800404 	addi	r2,r2,16
 821ebac:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 821ebb0:	e0bffb17 	ldw	r2,-20(fp)
 821ebb4:	10800917 	ldw	r2,36(r2)
 821ebb8:	10001226 	beq	r2,zero,821ec04 <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ebbc:	0005303a 	rdctl	r2,status
 821ebc0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ebc4:	e0fffd17 	ldw	r3,-12(fp)
 821ebc8:	00bfff84 	movi	r2,-2
 821ebcc:	1884703a 	and	r2,r3,r2
 821ebd0:	1001703a 	wrctl	status,r2
  
  return context;
 821ebd4:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 821ebd8:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 821ebdc:	e0bffb17 	ldw	r2,-20(fp)
 821ebe0:	10800917 	ldw	r2,36(r2)
 821ebe4:	e0fffb17 	ldw	r3,-20(fp)
 821ebe8:	18c00a17 	ldw	r3,40(r3)
 821ebec:	1809883a 	mov	r4,r3
 821ebf0:	103ee83a 	callr	r2
 821ebf4:	e0bffc17 	ldw	r2,-16(fp)
 821ebf8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ebfc:	e0bffe17 	ldw	r2,-8(fp)
 821ec00:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 821ec04:	0001883a 	nop
 821ec08:	e037883a 	mov	sp,fp
 821ec0c:	dfc00117 	ldw	ra,4(sp)
 821ec10:	df000017 	ldw	fp,0(sp)
 821ec14:	dec00204 	addi	sp,sp,8
 821ec18:	f800283a 	ret

0821ec1c <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 821ec1c:	defffa04 	addi	sp,sp,-24
 821ec20:	dfc00515 	stw	ra,20(sp)
 821ec24:	df000415 	stw	fp,16(sp)
 821ec28:	df000404 	addi	fp,sp,16
 821ec2c:	e13ffd15 	stw	r4,-12(fp)
 821ec30:	e17ffe15 	stw	r5,-8(fp)
 821ec34:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821ec38:	e0bffd17 	ldw	r2,-12(fp)
 821ec3c:	10800317 	ldw	r2,12(r2)
 821ec40:	10800404 	addi	r2,r2,16
 821ec44:	00c00074 	movhi	r3,1
 821ec48:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821ec4c:	e0bffd17 	ldw	r2,-12(fp)
 821ec50:	10800317 	ldw	r2,12(r2)
 821ec54:	10800404 	addi	r2,r2,16
 821ec58:	00c00074 	movhi	r3,1
 821ec5c:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 821ec60:	e0bffd17 	ldw	r2,-12(fp)
 821ec64:	10800317 	ldw	r2,12(r2)
 821ec68:	10800404 	addi	r2,r2,16
 821ec6c:	0007883a 	mov	r3,zero
 821ec70:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821ec74:	e0bffd17 	ldw	r2,-12(fp)
 821ec78:	10800317 	ldw	r2,12(r2)
 821ec7c:	00c03fc4 	movi	r3,255
 821ec80:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 821ec84:	d1602b04 	addi	r5,gp,-32596
 821ec88:	e13ffd17 	ldw	r4,-12(fp)
 821ec8c:	823bb780 	call	823bb78 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 821ec90:	d8000015 	stw	zero,0(sp)
 821ec94:	e1fffd17 	ldw	r7,-12(fp)
 821ec98:	018208b4 	movhi	r6,2082
 821ec9c:	31bad804 	addi	r6,r6,-5280
 821eca0:	e17fff17 	ldw	r5,-4(fp)
 821eca4:	e13ffe17 	ldw	r4,-8(fp)
 821eca8:	823bd6c0 	call	823bd6c <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 821ecac:	0001883a 	nop
 821ecb0:	e037883a 	mov	sp,fp
 821ecb4:	dfc00117 	ldw	ra,4(sp)
 821ecb8:	df000017 	ldw	fp,0(sp)
 821ecbc:	dec00204 	addi	sp,sp,8
 821ecc0:	f800283a 	ret

0821ecc4 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 821ecc4:	defffa04 	addi	sp,sp,-24
 821ecc8:	dfc00515 	stw	ra,20(sp)
 821eccc:	df000415 	stw	fp,16(sp)
 821ecd0:	df000404 	addi	fp,sp,16
 821ecd4:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 821ecd8:	0007883a 	mov	r3,zero
 821ecdc:	e0bfff17 	ldw	r2,-4(fp)
 821ece0:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 821ece4:	e0bfff17 	ldw	r2,-4(fp)
 821ece8:	10800104 	addi	r2,r2,4
 821ecec:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ecf0:	0005303a 	rdctl	r2,status
 821ecf4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ecf8:	e0fffd17 	ldw	r3,-12(fp)
 821ecfc:	00bfff84 	movi	r2,-2
 821ed00:	1884703a 	and	r2,r3,r2
 821ed04:	1001703a 	wrctl	status,r2
  
  return context;
 821ed08:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 821ed0c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 821ed10:	823c60c0 	call	823c60c <alt_tick>
 821ed14:	e0bffc17 	ldw	r2,-16(fp)
 821ed18:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ed1c:	e0bffe17 	ldw	r2,-8(fp)
 821ed20:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 821ed24:	0001883a 	nop
 821ed28:	e037883a 	mov	sp,fp
 821ed2c:	dfc00117 	ldw	ra,4(sp)
 821ed30:	df000017 	ldw	fp,0(sp)
 821ed34:	dec00204 	addi	sp,sp,8
 821ed38:	f800283a 	ret

0821ed3c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 821ed3c:	defff804 	addi	sp,sp,-32
 821ed40:	dfc00715 	stw	ra,28(sp)
 821ed44:	df000615 	stw	fp,24(sp)
 821ed48:	df000604 	addi	fp,sp,24
 821ed4c:	e13ffc15 	stw	r4,-16(fp)
 821ed50:	e17ffd15 	stw	r5,-12(fp)
 821ed54:	e1bffe15 	stw	r6,-8(fp)
 821ed58:	e1ffff15 	stw	r7,-4(fp)
 821ed5c:	e0bfff17 	ldw	r2,-4(fp)
 821ed60:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 821ed64:	d0a0b817 	ldw	r2,-32032(gp)
 821ed68:	1000021e 	bne	r2,zero,821ed74 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 821ed6c:	e0bffb17 	ldw	r2,-20(fp)
 821ed70:	d0a0b815 	stw	r2,-32032(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 821ed74:	e0bffc17 	ldw	r2,-16(fp)
 821ed78:	10800104 	addi	r2,r2,4
 821ed7c:	00c001c4 	movi	r3,7
 821ed80:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 821ed84:	d8000015 	stw	zero,0(sp)
 821ed88:	e1fffc17 	ldw	r7,-16(fp)
 821ed8c:	018208b4 	movhi	r6,2082
 821ed90:	31bb3104 	addi	r6,r6,-4924
 821ed94:	e17ffe17 	ldw	r5,-8(fp)
 821ed98:	e13ffd17 	ldw	r4,-12(fp)
 821ed9c:	823bd6c0 	call	823bd6c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 821eda0:	0001883a 	nop
 821eda4:	e037883a 	mov	sp,fp
 821eda8:	dfc00117 	ldw	ra,4(sp)
 821edac:	df000017 	ldw	fp,0(sp)
 821edb0:	dec00204 	addi	sp,sp,8
 821edb4:	f800283a 	ret

0821edb8 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 821edb8:	defffb04 	addi	sp,sp,-20
 821edbc:	df000115 	stw	fp,4(sp)
 821edc0:	df000104 	addi	fp,sp,4
 821edc4:	e13fff15 	stw	r4,-4(fp)
 821edc8:	e1400115 	stw	r5,4(fp)
 821edcc:	e1800215 	stw	r6,8(fp)
 821edd0:	e1c00315 	stw	r7,12(fp)
 821edd4:	0001883a 	nop
 821edd8:	e037883a 	mov	sp,fp
 821eddc:	df000017 	ldw	fp,0(sp)
 821ede0:	dec00404 	addi	sp,sp,16
 821ede4:	f800283a 	ret

0821ede8 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 821ede8:	defffb04 	addi	sp,sp,-20
 821edec:	df000415 	stw	fp,16(sp)
 821edf0:	df000404 	addi	fp,sp,16
 821edf4:	e13ffc15 	stw	r4,-16(fp)
 821edf8:	e17ffd15 	stw	r5,-12(fp)
 821edfc:	e1bffe15 	stw	r6,-8(fp)
 821ee00:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 821ee04:	e0fffd17 	ldw	r3,-12(fp)
 821ee08:	e0bffc17 	ldw	r2,-16(fp)
 821ee0c:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 821ee10:	e0fffe17 	ldw	r3,-8(fp)
 821ee14:	e0bffc17 	ldw	r2,-16(fp)
 821ee18:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 821ee1c:	e0ffff17 	ldw	r3,-4(fp)
 821ee20:	e0bffc17 	ldw	r2,-16(fp)
 821ee24:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 821ee28:	e0c00117 	ldw	r3,4(fp)
 821ee2c:	e0bffc17 	ldw	r2,-16(fp)
 821ee30:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 821ee34:	0005883a 	mov	r2,zero
}
 821ee38:	e037883a 	mov	sp,fp
 821ee3c:	df000017 	ldw	fp,0(sp)
 821ee40:	dec00104 	addi	sp,sp,4
 821ee44:	f800283a 	ret

0821ee48 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 821ee48:	defffa04 	addi	sp,sp,-24
 821ee4c:	dfc00515 	stw	ra,20(sp)
 821ee50:	df000415 	stw	fp,16(sp)
 821ee54:	df000404 	addi	fp,sp,16
 821ee58:	e13ffe15 	stw	r4,-8(fp)
 821ee5c:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 821ee60:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 821ee64:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821ee68:	00000b06 	br	821ee98 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821ee6c:	e0fffc17 	ldw	r3,-16(fp)
 821ee70:	18800044 	addi	r2,r3,1
 821ee74:	e0bffc15 	stw	r2,-16(fp)
 821ee78:	008003f4 	movhi	r2,15
 821ee7c:	10909004 	addi	r2,r2,16960
 821ee80:	1880051e 	bne	r3,r2,821ee98 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 821ee84:	01020974 	movhi	r4,2085
 821ee88:	21367304 	addi	r4,r4,-9780
 821ee8c:	82031200 	call	8203120 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 821ee90:	00bffa84 	movi	r2,-22
 821ee94:	00002006 	br	821ef18 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821ee98:	e0bffe17 	ldw	r2,-8(fp)
 821ee9c:	10800117 	ldw	r2,4(r2)
 821eea0:	10800317 	ldw	r2,12(r2)
 821eea4:	10800037 	ldwio	r2,0(r2)
 821eea8:	1080040c 	andi	r2,r2,16
 821eeac:	103fef1e 	bne	r2,zero,821ee6c <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 821eeb0:	e0bffe17 	ldw	r2,-8(fp)
 821eeb4:	10800117 	ldw	r2,4(r2)
 821eeb8:	10800317 	ldw	r2,12(r2)
 821eebc:	10800404 	addi	r2,r2,16
 821eec0:	0007883a 	mov	r3,zero
 821eec4:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 821eec8:	e0bffe17 	ldw	r2,-8(fp)
 821eecc:	10800117 	ldw	r2,4(r2)
 821eed0:	10800317 	ldw	r2,12(r2)
 821eed4:	00c03fc4 	movi	r3,255
 821eed8:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 821eedc:	e0bffe17 	ldw	r2,-8(fp)
 821eee0:	10800117 	ldw	r2,4(r2)
 821eee4:	e17fff17 	ldw	r5,-4(fp)
 821eee8:	1009883a 	mov	r4,r2
 821eeec:	821e0900 	call	821e090 <alt_avalon_sgdma_do_sync_transfer>
 821eef0:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 821eef4:	e0bffd03 	ldbu	r2,-12(fp)
 821eef8:	10000226 	beq	r2,zero,821ef04 <tse_mac_sTxWrite+0xbc>
    return -1;
 821eefc:	00bfffc4 	movi	r2,-1
 821ef00:	00000506 	br	821ef18 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 821ef04:	e0bfff17 	ldw	r2,-4(fp)
 821ef08:	10800704 	addi	r2,r2,28
 821ef0c:	10800037 	ldwio	r2,0(r2)
 821ef10:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 821ef14:	e0bffd8b 	ldhu	r2,-10(fp)
}
 821ef18:	e037883a 	mov	sp,fp
 821ef1c:	dfc00117 	ldw	ra,4(sp)
 821ef20:	df000017 	ldw	fp,0(sp)
 821ef24:	dec00204 	addi	sp,sp,8
 821ef28:	f800283a 	ret

0821ef2c <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 821ef2c:	defffa04 	addi	sp,sp,-24
 821ef30:	dfc00515 	stw	ra,20(sp)
 821ef34:	df000415 	stw	fp,16(sp)
 821ef38:	df000404 	addi	fp,sp,16
 821ef3c:	e13ffe15 	stw	r4,-8(fp)
 821ef40:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 821ef44:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 821ef48:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821ef4c:	00000b06 	br	821ef7c <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821ef50:	e0fffc17 	ldw	r3,-16(fp)
 821ef54:	18800044 	addi	r2,r3,1
 821ef58:	e0bffc15 	stw	r2,-16(fp)
 821ef5c:	008003f4 	movhi	r2,15
 821ef60:	10909004 	addi	r2,r2,16960
 821ef64:	1880051e 	bne	r3,r2,821ef7c <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 821ef68:	01020974 	movhi	r4,2085
 821ef6c:	21367a04 	addi	r4,r4,-9752
 821ef70:	82031200 	call	8203120 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 821ef74:	00bffa84 	movi	r2,-22
 821ef78:	00001106 	br	821efc0 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821ef7c:	e0bffe17 	ldw	r2,-8(fp)
 821ef80:	10800217 	ldw	r2,8(r2)
 821ef84:	10800317 	ldw	r2,12(r2)
 821ef88:	10800037 	ldwio	r2,0(r2)
 821ef8c:	1080040c 	andi	r2,r2,16
 821ef90:	103fef1e 	bne	r2,zero,821ef50 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 821ef94:	e0bffe17 	ldw	r2,-8(fp)
 821ef98:	10800217 	ldw	r2,8(r2)
 821ef9c:	e17fff17 	ldw	r5,-4(fp)
 821efa0:	1009883a 	mov	r4,r2
 821efa4:	821df6c0 	call	821df6c <alt_avalon_sgdma_do_async_transfer>
 821efa8:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 821efac:	e0bffd03 	ldbu	r2,-12(fp)
 821efb0:	10000226 	beq	r2,zero,821efbc <tse_mac_aRxRead+0x90>
    return -1;
 821efb4:	00bfffc4 	movi	r2,-1
 821efb8:	00000106 	br	821efc0 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 821efbc:	0005883a 	mov	r2,zero
}
 821efc0:	e037883a 	mov	sp,fp
 821efc4:	dfc00117 	ldw	ra,4(sp)
 821efc8:	df000017 	ldw	fp,0(sp)
 821efcc:	dec00204 	addi	sp,sp,8
 821efd0:	f800283a 	ret

0821efd4 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 821efd4:	defffc04 	addi	sp,sp,-16
 821efd8:	df000315 	stw	fp,12(sp)
 821efdc:	df000304 	addi	fp,sp,12
 821efe0:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821efe4:	e0bfff17 	ldw	r2,-4(fp)
 821efe8:	10800204 	addi	r2,r2,8
 821efec:	10800037 	ldwio	r2,0(r2)
 821eff0:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 821eff4:	e0bfff17 	ldw	r2,-4(fp)
 821eff8:	10800204 	addi	r2,r2,8
 821effc:	00c80204 	movi	r3,8200
 821f000:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 821f004:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 821f008:	00000306 	br	821f018 <tse_mac_SwReset+0x44>
 821f00c:	e0bffd17 	ldw	r2,-12(fp)
 821f010:	10800044 	addi	r2,r2,1
 821f014:	e0bffd15 	stw	r2,-12(fp)
 821f018:	e0bfff17 	ldw	r2,-4(fp)
 821f01c:	10800204 	addi	r2,r2,8
 821f020:	10800037 	ldwio	r2,0(r2)
 821f024:	1088000c 	andi	r2,r2,8192
 821f028:	10000326 	beq	r2,zero,821f038 <tse_mac_SwReset+0x64>
 821f02c:	e0bffd17 	ldw	r2,-12(fp)
 821f030:	1089c410 	cmplti	r2,r2,10000
 821f034:	103ff51e 	bne	r2,zero,821f00c <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 821f038:	e0bfff17 	ldw	r2,-4(fp)
 821f03c:	10800204 	addi	r2,r2,8
 821f040:	e0fffe17 	ldw	r3,-8(fp)
 821f044:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 821f048:	0005883a 	mov	r2,zero
}
 821f04c:	e037883a 	mov	sp,fp
 821f050:	df000017 	ldw	fp,0(sp)
 821f054:	dec00104 	addi	sp,sp,4
 821f058:	f800283a 	ret

0821f05c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 821f05c:	defffd04 	addi	sp,sp,-12
 821f060:	df000215 	stw	fp,8(sp)
 821f064:	df000204 	addi	fp,sp,8
 821f068:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f06c:	e0bfff17 	ldw	r2,-4(fp)
 821f070:	10800204 	addi	r2,r2,8
 821f074:	10800037 	ldwio	r2,0(r2)
 821f078:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 821f07c:	e0fffe17 	ldw	r3,-8(fp)
 821f080:	00bffdc4 	movi	r2,-9
 821f084:	1884703a 	and	r2,r3,r2
 821f088:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f08c:	e0bfff17 	ldw	r2,-4(fp)
 821f090:	10800204 	addi	r2,r2,8
 821f094:	e0fffe17 	ldw	r3,-8(fp)
 821f098:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f09c:	0005883a 	mov	r2,zero
}
 821f0a0:	e037883a 	mov	sp,fp
 821f0a4:	df000017 	ldw	fp,0(sp)
 821f0a8:	dec00104 	addi	sp,sp,4
 821f0ac:	f800283a 	ret

0821f0b0 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 821f0b0:	defffd04 	addi	sp,sp,-12
 821f0b4:	df000215 	stw	fp,8(sp)
 821f0b8:	df000204 	addi	fp,sp,8
 821f0bc:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f0c0:	e0bfff17 	ldw	r2,-4(fp)
 821f0c4:	10800204 	addi	r2,r2,8
 821f0c8:	10800037 	ldwio	r2,0(r2)
 821f0cc:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 821f0d0:	e0bffe17 	ldw	r2,-8(fp)
 821f0d4:	10800214 	ori	r2,r2,8
 821f0d8:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f0dc:	e0bfff17 	ldw	r2,-4(fp)
 821f0e0:	10800204 	addi	r2,r2,8
 821f0e4:	e0fffe17 	ldw	r3,-8(fp)
 821f0e8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f0ec:	0005883a 	mov	r2,zero
}
 821f0f0:	e037883a 	mov	sp,fp
 821f0f4:	df000017 	ldw	fp,0(sp)
 821f0f8:	dec00104 	addi	sp,sp,4
 821f0fc:	f800283a 	ret

0821f100 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 821f100:	defffb04 	addi	sp,sp,-20
 821f104:	dfc00415 	stw	ra,16(sp)
 821f108:	df000315 	stw	fp,12(sp)
 821f10c:	dc000215 	stw	r16,8(sp)
 821f110:	df000304 	addi	fp,sp,12
 821f114:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f118:	e03ffd15 	stw	zero,-12(fp)
 821f11c:	00002906 	br	821f1c4 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 821f120:	008209b4 	movhi	r2,2086
 821f124:	10b59104 	addi	r2,r2,-10684
 821f128:	e0fffd17 	ldw	r3,-12(fp)
 821f12c:	18c7883a 	add	r3,r3,r3
 821f130:	18c7883a 	add	r3,r3,r3
 821f134:	10c5883a 	add	r2,r2,r3
 821f138:	10800017 	ldw	r2,0(r2)
 821f13c:	10c01417 	ldw	r3,80(r2)
 821f140:	e0bffe17 	ldw	r2,-8(fp)
 821f144:	10801417 	ldw	r2,80(r2)
 821f148:	18801b1e 	bne	r3,r2,821f1b8 <alt_tse_phy_add_profile+0xb8>
 821f14c:	008209b4 	movhi	r2,2086
 821f150:	10b59104 	addi	r2,r2,-10684
 821f154:	e0fffd17 	ldw	r3,-12(fp)
 821f158:	18c7883a 	add	r3,r3,r3
 821f15c:	18c7883a 	add	r3,r3,r3
 821f160:	10c5883a 	add	r2,r2,r3
 821f164:	10800017 	ldw	r2,0(r2)
 821f168:	10c01503 	ldbu	r3,84(r2)
 821f16c:	e0bffe17 	ldw	r2,-8(fp)
 821f170:	10801503 	ldbu	r2,84(r2)
 821f174:	18c03fcc 	andi	r3,r3,255
 821f178:	10803fcc 	andi	r2,r2,255
 821f17c:	18800e1e 	bne	r3,r2,821f1b8 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 821f180:	e0bffe17 	ldw	r2,-8(fp)
 821f184:	10801417 	ldw	r2,80(r2)
 821f188:	1007883a 	mov	r3,r2
 821f18c:	e0bffe17 	ldw	r2,-8(fp)
 821f190:	10801503 	ldbu	r2,84(r2)
 821f194:	10803fcc 	andi	r2,r2,255
 821f198:	100d883a 	mov	r6,r2
 821f19c:	180b883a 	mov	r5,r3
 821f1a0:	01020974 	movhi	r4,2085
 821f1a4:	21368104 	addi	r4,r4,-9724
 821f1a8:	8202e9c0 	call	8202e9c <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 821f1ac:	01020974 	movhi	r4,2085
 821f1b0:	21369504 	addi	r4,r4,-9644
 821f1b4:	82031200 	call	8203120 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f1b8:	e0bffd17 	ldw	r2,-12(fp)
 821f1bc:	10800044 	addi	r2,r2,1
 821f1c0:	e0bffd15 	stw	r2,-12(fp)
 821f1c4:	d0a07f03 	ldbu	r2,-32260(gp)
 821f1c8:	10803fcc 	andi	r2,r2,255
 821f1cc:	e0fffd17 	ldw	r3,-12(fp)
 821f1d0:	18bfd316 	blt	r3,r2,821f120 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 821f1d4:	d0a07f03 	ldbu	r2,-32260(gp)
 821f1d8:	14003fcc 	andi	r16,r2,255
 821f1dc:	01001904 	movi	r4,100
 821f1e0:	824b18c0 	call	824b18c <malloc>
 821f1e4:	1009883a 	mov	r4,r2
 821f1e8:	008209b4 	movhi	r2,2086
 821f1ec:	10b59104 	addi	r2,r2,-10684
 821f1f0:	8407883a 	add	r3,r16,r16
 821f1f4:	18c7883a 	add	r3,r3,r3
 821f1f8:	10c5883a 	add	r2,r2,r3
 821f1fc:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 821f200:	d0a07f03 	ldbu	r2,-32260(gp)
 821f204:	10c03fcc 	andi	r3,r2,255
 821f208:	008209b4 	movhi	r2,2086
 821f20c:	10b59104 	addi	r2,r2,-10684
 821f210:	18c7883a 	add	r3,r3,r3
 821f214:	18c7883a 	add	r3,r3,r3
 821f218:	10c5883a 	add	r2,r2,r3
 821f21c:	10800017 	ldw	r2,0(r2)
 821f220:	1000081e 	bne	r2,zero,821f244 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 821f224:	d0a07f03 	ldbu	r2,-32260(gp)
 821f228:	10803fcc 	andi	r2,r2,255
 821f22c:	100b883a 	mov	r5,r2
 821f230:	01020974 	movhi	r4,2085
 821f234:	2136ad04 	addi	r4,r4,-9548
 821f238:	8202e9c0 	call	8202e9c <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 821f23c:	00bfffc4 	movi	r2,-1
 821f240:	00002206 	br	821f2cc <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 821f244:	d0a07f03 	ldbu	r2,-32260(gp)
 821f248:	10c03fcc 	andi	r3,r2,255
 821f24c:	008209b4 	movhi	r2,2086
 821f250:	10b59104 	addi	r2,r2,-10684
 821f254:	18c7883a 	add	r3,r3,r3
 821f258:	18c7883a 	add	r3,r3,r3
 821f25c:	10c5883a 	add	r2,r2,r3
 821f260:	10c00017 	ldw	r3,0(r2)
 821f264:	e0bffe17 	ldw	r2,-8(fp)
 821f268:	1009883a 	mov	r4,r2
 821f26c:	00801904 	movi	r2,100
 821f270:	100d883a 	mov	r6,r2
 821f274:	200b883a 	mov	r5,r4
 821f278:	1809883a 	mov	r4,r3
 821f27c:	8202a0c0 	call	8202a0c <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 821f280:	d0a07f03 	ldbu	r2,-32260(gp)
 821f284:	10c03fcc 	andi	r3,r2,255
 821f288:	008209b4 	movhi	r2,2086
 821f28c:	10b59104 	addi	r2,r2,-10684
 821f290:	18c7883a 	add	r3,r3,r3
 821f294:	18c7883a 	add	r3,r3,r3
 821f298:	10c5883a 	add	r2,r2,r3
 821f29c:	10800017 	ldw	r2,0(r2)
 821f2a0:	1007883a 	mov	r3,r2
 821f2a4:	e0bffe17 	ldw	r2,-8(fp)
 821f2a8:	100b883a 	mov	r5,r2
 821f2ac:	1809883a 	mov	r4,r3
 821f2b0:	824b1b40 	call	824b1b4 <strcpy>
    
    phy_profile_count++;
 821f2b4:	d0a07f03 	ldbu	r2,-32260(gp)
 821f2b8:	10800044 	addi	r2,r2,1
 821f2bc:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 821f2c0:	d0a07f03 	ldbu	r2,-32260(gp)
 821f2c4:	10803fcc 	andi	r2,r2,255
 821f2c8:	10bfffc4 	addi	r2,r2,-1
}
 821f2cc:	e6ffff04 	addi	sp,fp,-4
 821f2d0:	dfc00217 	ldw	ra,8(sp)
 821f2d4:	df000117 	ldw	fp,4(sp)
 821f2d8:	dc000017 	ldw	r16,0(sp)
 821f2dc:	dec00304 	addi	sp,sp,12
 821f2e0:	f800283a 	ret

0821f2e4 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 821f2e4:	defff204 	addi	sp,sp,-56
 821f2e8:	dfc00d15 	stw	ra,52(sp)
 821f2ec:	df000c15 	stw	fp,48(sp)
 821f2f0:	dc000b15 	stw	r16,44(sp)
 821f2f4:	df000c04 	addi	fp,sp,48
 821f2f8:	e13ffb15 	stw	r4,-20(fp)
 821f2fc:	e17ffc15 	stw	r5,-16(fp)
 821f300:	e1bffd15 	stw	r6,-12(fp)
 821f304:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 821f308:	e0bffb17 	ldw	r2,-20(fp)
 821f30c:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 821f310:	e0bffc17 	ldw	r2,-16(fp)
 821f314:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 821f318:	e0bffd17 	ldw	r2,-12(fp)
 821f31c:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 821f320:	e0bffe17 	ldw	r2,-8(fp)
 821f324:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 821f328:	e0800217 	ldw	r2,8(fp)
 821f32c:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 821f330:	e0bffa17 	ldw	r2,-24(fp)
 821f334:	10800303 	ldbu	r2,12(r2)
 821f338:	10803fcc 	andi	r2,r2,255
 821f33c:	1000031e 	bne	r2,zero,821f34c <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 821f340:	00800044 	movi	r2,1
 821f344:	e0bff515 	stw	r2,-44(fp)
 821f348:	00000e06 	br	821f384 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 821f34c:	e0bffa17 	ldw	r2,-24(fp)
 821f350:	10800303 	ldbu	r2,12(r2)
 821f354:	10803fcc 	andi	r2,r2,255
 821f358:	10000526 	beq	r2,zero,821f370 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 821f35c:	e0bffa17 	ldw	r2,-24(fp)
 821f360:	10800303 	ldbu	r2,12(r2)
 821f364:	10803fcc 	andi	r2,r2,255
 821f368:	e0bff515 	stw	r2,-44(fp)
 821f36c:	00000506 	br	821f384 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 821f370:	01020974 	movhi	r4,2085
 821f374:	2136bc04 	addi	r4,r4,-9488
 821f378:	82031200 	call	8203120 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f37c:	00bfffc4 	movi	r2,-1
 821f380:	00025106 	br	821fcc8 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 821f384:	e03ff415 	stw	zero,-48(fp)
 821f388:	00024b06 	br	821fcb8 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 821f38c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f390:	10803fcc 	andi	r2,r2,255
 821f394:	1080201c 	xori	r2,r2,128
 821f398:	10bfe004 	addi	r2,r2,-128
 821f39c:	10800110 	cmplti	r2,r2,4
 821f3a0:	10000c1e 	bne	r2,zero,821f3d4 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 821f3a4:	01020974 	movhi	r4,2085
 821f3a8:	2136c804 	addi	r4,r4,-9440
 821f3ac:	82031200 	call	8203120 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 821f3b0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f3b4:	10803fcc 	andi	r2,r2,255
 821f3b8:	1080201c 	xori	r2,r2,128
 821f3bc:	10bfe004 	addi	r2,r2,-128
 821f3c0:	100d883a 	mov	r6,r2
 821f3c4:	01400104 	movi	r5,4
 821f3c8:	01020974 	movhi	r4,2085
 821f3cc:	2136d804 	addi	r4,r4,-9376
 821f3d0:	8202e9c0 	call	8202e9c <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 821f3d4:	e0bffa17 	ldw	r2,-24(fp)
 821f3d8:	1000081e 	bne	r2,zero,821f3fc <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821f3dc:	01020974 	movhi	r4,2085
 821f3e0:	2136e704 	addi	r4,r4,-9316
 821f3e4:	82031200 	call	8203120 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 821f3e8:	01020974 	movhi	r4,2085
 821f3ec:	2136f104 	addi	r4,r4,-9276
 821f3f0:	82031200 	call	8203120 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f3f4:	00bfffc4 	movi	r2,-1
 821f3f8:	00023306 	br	821fcc8 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 821f3fc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f400:	11003fcc 	andi	r4,r2,255
 821f404:	2100201c 	xori	r4,r4,128
 821f408:	213fe004 	addi	r4,r4,-128
 821f40c:	e0bffa17 	ldw	r2,-24(fp)
 821f410:	10800017 	ldw	r2,0(r2)
 821f414:	e0fff417 	ldw	r3,-48(fp)
 821f418:	180692ba 	slli	r3,r3,10
 821f41c:	10c7883a 	add	r3,r2,r3
 821f420:	00820974 	movhi	r2,2085
 821f424:	10864f04 	addi	r2,r2,6460
 821f428:	21001224 	muli	r4,r4,72
 821f42c:	1105883a 	add	r2,r2,r4
 821f430:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 821f434:	d0a07f83 	ldbu	r2,-32258(gp)
 821f438:	11003fcc 	andi	r4,r2,255
 821f43c:	2100201c 	xori	r4,r4,128
 821f440:	213fe004 	addi	r4,r4,-128
 821f444:	e0bffa17 	ldw	r2,-24(fp)
 821f448:	10c0010b 	ldhu	r3,4(r2)
 821f44c:	00820974 	movhi	r2,2085
 821f450:	10864f04 	addi	r2,r2,6460
 821f454:	21001224 	muli	r4,r4,72
 821f458:	1105883a 	add	r2,r2,r4
 821f45c:	10800104 	addi	r2,r2,4
 821f460:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 821f464:	d0a07f83 	ldbu	r2,-32258(gp)
 821f468:	11003fcc 	andi	r4,r2,255
 821f46c:	2100201c 	xori	r4,r4,128
 821f470:	213fe004 	addi	r4,r4,-128
 821f474:	e0bffa17 	ldw	r2,-24(fp)
 821f478:	10c0018b 	ldhu	r3,6(r2)
 821f47c:	00820974 	movhi	r2,2085
 821f480:	10864f04 	addi	r2,r2,6460
 821f484:	21001224 	muli	r4,r4,72
 821f488:	1105883a 	add	r2,r2,r4
 821f48c:	10800184 	addi	r2,r2,6
 821f490:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 821f494:	d0a07f83 	ldbu	r2,-32258(gp)
 821f498:	11003fcc 	andi	r4,r2,255
 821f49c:	2100201c 	xori	r4,r4,128
 821f4a0:	213fe004 	addi	r4,r4,-128
 821f4a4:	e0bffa17 	ldw	r2,-24(fp)
 821f4a8:	10c00203 	ldbu	r3,8(r2)
 821f4ac:	00820974 	movhi	r2,2085
 821f4b0:	10864f04 	addi	r2,r2,6460
 821f4b4:	21001224 	muli	r4,r4,72
 821f4b8:	1105883a 	add	r2,r2,r4
 821f4bc:	10800204 	addi	r2,r2,8
 821f4c0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 821f4c4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f4c8:	11003fcc 	andi	r4,r2,255
 821f4cc:	2100201c 	xori	r4,r4,128
 821f4d0:	213fe004 	addi	r4,r4,-128
 821f4d4:	e0bffa17 	ldw	r2,-24(fp)
 821f4d8:	10c00243 	ldbu	r3,9(r2)
 821f4dc:	00820974 	movhi	r2,2085
 821f4e0:	10864f04 	addi	r2,r2,6460
 821f4e4:	21001224 	muli	r4,r4,72
 821f4e8:	1105883a 	add	r2,r2,r4
 821f4ec:	10800244 	addi	r2,r2,9
 821f4f0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 821f4f4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f4f8:	11003fcc 	andi	r4,r2,255
 821f4fc:	2100201c 	xori	r4,r4,128
 821f500:	213fe004 	addi	r4,r4,-128
 821f504:	e0bffa17 	ldw	r2,-24(fp)
 821f508:	10c00283 	ldbu	r3,10(r2)
 821f50c:	00820974 	movhi	r2,2085
 821f510:	10864f04 	addi	r2,r2,6460
 821f514:	21001224 	muli	r4,r4,72
 821f518:	1105883a 	add	r2,r2,r4
 821f51c:	10800284 	addi	r2,r2,10
 821f520:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 821f524:	d0a07f83 	ldbu	r2,-32258(gp)
 821f528:	11003fcc 	andi	r4,r2,255
 821f52c:	2100201c 	xori	r4,r4,128
 821f530:	213fe004 	addi	r4,r4,-128
 821f534:	e0bffa17 	ldw	r2,-24(fp)
 821f538:	10c002c3 	ldbu	r3,11(r2)
 821f53c:	00820974 	movhi	r2,2085
 821f540:	10864f04 	addi	r2,r2,6460
 821f544:	21001224 	muli	r4,r4,72
 821f548:	1105883a 	add	r2,r2,r4
 821f54c:	108002c4 	addi	r2,r2,11
 821f550:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 821f554:	d0a07f83 	ldbu	r2,-32258(gp)
 821f558:	11003fcc 	andi	r4,r2,255
 821f55c:	2100201c 	xori	r4,r4,128
 821f560:	213fe004 	addi	r4,r4,-128
 821f564:	e0bffa17 	ldw	r2,-24(fp)
 821f568:	10c00303 	ldbu	r3,12(r2)
 821f56c:	00820974 	movhi	r2,2085
 821f570:	10864f04 	addi	r2,r2,6460
 821f574:	21001224 	muli	r4,r4,72
 821f578:	1105883a 	add	r2,r2,r4
 821f57c:	10800304 	addi	r2,r2,12
 821f580:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 821f584:	d0a07f83 	ldbu	r2,-32258(gp)
 821f588:	11003fcc 	andi	r4,r2,255
 821f58c:	2100201c 	xori	r4,r4,128
 821f590:	213fe004 	addi	r4,r4,-128
 821f594:	e0bffa17 	ldw	r2,-24(fp)
 821f598:	10c00343 	ldbu	r3,13(r2)
 821f59c:	00820974 	movhi	r2,2085
 821f5a0:	10864f04 	addi	r2,r2,6460
 821f5a4:	21001224 	muli	r4,r4,72
 821f5a8:	1105883a 	add	r2,r2,r4
 821f5ac:	10800344 	addi	r2,r2,13
 821f5b0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 821f5b4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f5b8:	11003fcc 	andi	r4,r2,255
 821f5bc:	2100201c 	xori	r4,r4,128
 821f5c0:	213fe004 	addi	r4,r4,-128
 821f5c4:	e0bffa17 	ldw	r2,-24(fp)
 821f5c8:	10c00383 	ldbu	r3,14(r2)
 821f5cc:	00820974 	movhi	r2,2085
 821f5d0:	10864f04 	addi	r2,r2,6460
 821f5d4:	21001224 	muli	r4,r4,72
 821f5d8:	1105883a 	add	r2,r2,r4
 821f5dc:	10800384 	addi	r2,r2,14
 821f5e0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 821f5e4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f5e8:	11003fcc 	andi	r4,r2,255
 821f5ec:	2100201c 	xori	r4,r4,128
 821f5f0:	213fe004 	addi	r4,r4,-128
 821f5f4:	e0bffa17 	ldw	r2,-24(fp)
 821f5f8:	10c003c3 	ldbu	r3,15(r2)
 821f5fc:	00820974 	movhi	r2,2085
 821f600:	10864f04 	addi	r2,r2,6460
 821f604:	21001224 	muli	r4,r4,72
 821f608:	1105883a 	add	r2,r2,r4
 821f60c:	108003c4 	addi	r2,r2,15
 821f610:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 821f614:	d0a07f83 	ldbu	r2,-32258(gp)
 821f618:	11003fcc 	andi	r4,r2,255
 821f61c:	2100201c 	xori	r4,r4,128
 821f620:	213fe004 	addi	r4,r4,-128
 821f624:	e0bffa17 	ldw	r2,-24(fp)
 821f628:	10c00403 	ldbu	r3,16(r2)
 821f62c:	00820974 	movhi	r2,2085
 821f630:	10864f04 	addi	r2,r2,6460
 821f634:	21001224 	muli	r4,r4,72
 821f638:	1105883a 	add	r2,r2,r4
 821f63c:	10800404 	addi	r2,r2,16
 821f640:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 821f644:	e0bff617 	ldw	r2,-40(fp)
 821f648:	10000d1e 	bne	r2,zero,821f680 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 821f64c:	01020974 	movhi	r4,2085
 821f650:	21370304 	addi	r4,r4,-9204
 821f654:	82031200 	call	8203120 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 821f658:	d0a07f83 	ldbu	r2,-32258(gp)
 821f65c:	10803fcc 	andi	r2,r2,255
 821f660:	1080201c 	xori	r2,r2,128
 821f664:	10bfe004 	addi	r2,r2,-128
 821f668:	100b883a 	mov	r5,r2
 821f66c:	01020974 	movhi	r4,2085
 821f670:	21370e04 	addi	r4,r4,-9160
 821f674:	8202e9c0 	call	8202e9c <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f678:	00bfffc4 	movi	r2,-1
 821f67c:	00019206 	br	821fcc8 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 821f680:	d0a07f83 	ldbu	r2,-32258(gp)
 821f684:	14003fcc 	andi	r16,r2,255
 821f688:	8400201c 	xori	r16,r16,128
 821f68c:	843fe004 	addi	r16,r16,-128
 821f690:	e0bff617 	ldw	r2,-40(fp)
 821f694:	10800017 	ldw	r2,0(r2)
 821f698:	1009883a 	mov	r4,r2
 821f69c:	8203a5c0 	call	8203a5c <strlen>
 821f6a0:	10800044 	addi	r2,r2,1
 821f6a4:	1009883a 	mov	r4,r2
 821f6a8:	824b18c0 	call	824b18c <malloc>
 821f6ac:	1009883a 	mov	r4,r2
 821f6b0:	00820974 	movhi	r2,2085
 821f6b4:	10864f04 	addi	r2,r2,6460
 821f6b8:	80c01224 	muli	r3,r16,72
 821f6bc:	10c5883a 	add	r2,r2,r3
 821f6c0:	10800504 	addi	r2,r2,20
 821f6c4:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 821f6c8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f6cc:	10c03fcc 	andi	r3,r2,255
 821f6d0:	18c0201c 	xori	r3,r3,128
 821f6d4:	18ffe004 	addi	r3,r3,-128
 821f6d8:	00820974 	movhi	r2,2085
 821f6dc:	10864f04 	addi	r2,r2,6460
 821f6e0:	18c01224 	muli	r3,r3,72
 821f6e4:	10c5883a 	add	r2,r2,r3
 821f6e8:	10800504 	addi	r2,r2,20
 821f6ec:	10800017 	ldw	r2,0(r2)
 821f6f0:	10000a1e 	bne	r2,zero,821f71c <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 821f6f4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f6f8:	10803fcc 	andi	r2,r2,255
 821f6fc:	1080201c 	xori	r2,r2,128
 821f700:	10bfe004 	addi	r2,r2,-128
 821f704:	100b883a 	mov	r5,r2
 821f708:	01020974 	movhi	r4,2085
 821f70c:	21372604 	addi	r4,r4,-9064
 821f710:	8202e9c0 	call	8202e9c <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821f714:	00bfffc4 	movi	r2,-1
 821f718:	00016b06 	br	821fcc8 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 821f71c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f720:	10c03fcc 	andi	r3,r2,255
 821f724:	18c0201c 	xori	r3,r3,128
 821f728:	18ffe004 	addi	r3,r3,-128
 821f72c:	00820974 	movhi	r2,2085
 821f730:	10864f04 	addi	r2,r2,6460
 821f734:	18c01224 	muli	r3,r3,72
 821f738:	10c5883a 	add	r2,r2,r3
 821f73c:	10800504 	addi	r2,r2,20
 821f740:	10c00017 	ldw	r3,0(r2)
 821f744:	e0bff617 	ldw	r2,-40(fp)
 821f748:	10800017 	ldw	r2,0(r2)
 821f74c:	100b883a 	mov	r5,r2
 821f750:	1809883a 	mov	r4,r3
 821f754:	824b1b40 	call	824b1b4 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 821f758:	d0a07f83 	ldbu	r2,-32258(gp)
 821f75c:	14003fcc 	andi	r16,r2,255
 821f760:	8400201c 	xori	r16,r16,128
 821f764:	843fe004 	addi	r16,r16,-128
 821f768:	e0bff617 	ldw	r2,-40(fp)
 821f76c:	10800117 	ldw	r2,4(r2)
 821f770:	1009883a 	mov	r4,r2
 821f774:	8203a5c0 	call	8203a5c <strlen>
 821f778:	10800044 	addi	r2,r2,1
 821f77c:	1009883a 	mov	r4,r2
 821f780:	824b18c0 	call	824b18c <malloc>
 821f784:	1009883a 	mov	r4,r2
 821f788:	00820974 	movhi	r2,2085
 821f78c:	10864f04 	addi	r2,r2,6460
 821f790:	80c01224 	muli	r3,r16,72
 821f794:	10c5883a 	add	r2,r2,r3
 821f798:	10800604 	addi	r2,r2,24
 821f79c:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 821f7a0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7a4:	10c03fcc 	andi	r3,r2,255
 821f7a8:	18c0201c 	xori	r3,r3,128
 821f7ac:	18ffe004 	addi	r3,r3,-128
 821f7b0:	00820974 	movhi	r2,2085
 821f7b4:	10864f04 	addi	r2,r2,6460
 821f7b8:	18c01224 	muli	r3,r3,72
 821f7bc:	10c5883a 	add	r2,r2,r3
 821f7c0:	10800604 	addi	r2,r2,24
 821f7c4:	10800017 	ldw	r2,0(r2)
 821f7c8:	10000a1e 	bne	r2,zero,821f7f4 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 821f7cc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7d0:	10803fcc 	andi	r2,r2,255
 821f7d4:	1080201c 	xori	r2,r2,128
 821f7d8:	10bfe004 	addi	r2,r2,-128
 821f7dc:	100b883a 	mov	r5,r2
 821f7e0:	01020974 	movhi	r4,2085
 821f7e4:	21373904 	addi	r4,r4,-8988
 821f7e8:	8202e9c0 	call	8202e9c <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821f7ec:	00bfffc4 	movi	r2,-1
 821f7f0:	00013506 	br	821fcc8 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 821f7f4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7f8:	10c03fcc 	andi	r3,r2,255
 821f7fc:	18c0201c 	xori	r3,r3,128
 821f800:	18ffe004 	addi	r3,r3,-128
 821f804:	00820974 	movhi	r2,2085
 821f808:	10864f04 	addi	r2,r2,6460
 821f80c:	18c01224 	muli	r3,r3,72
 821f810:	10c5883a 	add	r2,r2,r3
 821f814:	10800604 	addi	r2,r2,24
 821f818:	10c00017 	ldw	r3,0(r2)
 821f81c:	e0bff617 	ldw	r2,-40(fp)
 821f820:	10800117 	ldw	r2,4(r2)
 821f824:	100b883a 	mov	r5,r2
 821f828:	1809883a 	mov	r4,r3
 821f82c:	824b1b40 	call	824b1b4 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 821f830:	d0a07f83 	ldbu	r2,-32258(gp)
 821f834:	11003fcc 	andi	r4,r2,255
 821f838:	2100201c 	xori	r4,r4,128
 821f83c:	213fe004 	addi	r4,r4,-128
 821f840:	e0bff617 	ldw	r2,-40(fp)
 821f844:	10c0020b 	ldhu	r3,8(r2)
 821f848:	00820974 	movhi	r2,2085
 821f84c:	10864f04 	addi	r2,r2,6460
 821f850:	21001224 	muli	r4,r4,72
 821f854:	1105883a 	add	r2,r2,r4
 821f858:	10800704 	addi	r2,r2,28
 821f85c:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 821f860:	e0bff717 	ldw	r2,-36(fp)
 821f864:	1000151e 	bne	r2,zero,821f8bc <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 821f868:	d0a07f83 	ldbu	r2,-32258(gp)
 821f86c:	10c03fcc 	andi	r3,r2,255
 821f870:	18c0201c 	xori	r3,r3,128
 821f874:	18ffe004 	addi	r3,r3,-128
 821f878:	00820974 	movhi	r2,2085
 821f87c:	10864f04 	addi	r2,r2,6460
 821f880:	18c01224 	muli	r3,r3,72
 821f884:	10c5883a 	add	r2,r2,r3
 821f888:	10800784 	addi	r2,r2,30
 821f88c:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 821f890:	d0a07f83 	ldbu	r2,-32258(gp)
 821f894:	10c03fcc 	andi	r3,r2,255
 821f898:	18c0201c 	xori	r3,r3,128
 821f89c:	18ffe004 	addi	r3,r3,-128
 821f8a0:	00820974 	movhi	r2,2085
 821f8a4:	10864f04 	addi	r2,r2,6460
 821f8a8:	18c01224 	muli	r3,r3,72
 821f8ac:	10c5883a 	add	r2,r2,r3
 821f8b0:	10800804 	addi	r2,r2,32
 821f8b4:	10000015 	stw	zero,0(r2)
 821f8b8:	00001806 	br	821f91c <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 821f8bc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8c0:	11003fcc 	andi	r4,r2,255
 821f8c4:	2100201c 	xori	r4,r4,128
 821f8c8:	213fe004 	addi	r4,r4,-128
 821f8cc:	e0bff717 	ldw	r2,-36(fp)
 821f8d0:	10c00003 	ldbu	r3,0(r2)
 821f8d4:	00820974 	movhi	r2,2085
 821f8d8:	10864f04 	addi	r2,r2,6460
 821f8dc:	21001224 	muli	r4,r4,72
 821f8e0:	1105883a 	add	r2,r2,r4
 821f8e4:	10800784 	addi	r2,r2,30
 821f8e8:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 821f8ec:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8f0:	11003fcc 	andi	r4,r2,255
 821f8f4:	2100201c 	xori	r4,r4,128
 821f8f8:	213fe004 	addi	r4,r4,-128
 821f8fc:	e0bff717 	ldw	r2,-36(fp)
 821f900:	10c00117 	ldw	r3,4(r2)
 821f904:	00820974 	movhi	r2,2085
 821f908:	10864f04 	addi	r2,r2,6460
 821f90c:	21001224 	muli	r4,r4,72
 821f910:	1105883a 	add	r2,r2,r4
 821f914:	10800804 	addi	r2,r2,32
 821f918:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 821f91c:	e0bff817 	ldw	r2,-32(fp)
 821f920:	1000471e 	bne	r2,zero,821fa40 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 821f924:	d0a07f83 	ldbu	r2,-32258(gp)
 821f928:	10c03fcc 	andi	r3,r2,255
 821f92c:	18c0201c 	xori	r3,r3,128
 821f930:	18ffe004 	addi	r3,r3,-128
 821f934:	00820974 	movhi	r2,2085
 821f938:	10864f04 	addi	r2,r2,6460
 821f93c:	18c01224 	muli	r3,r3,72
 821f940:	10c5883a 	add	r2,r2,r3
 821f944:	10800904 	addi	r2,r2,36
 821f948:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821f94c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f950:	10c03fcc 	andi	r3,r2,255
 821f954:	18c0201c 	xori	r3,r3,128
 821f958:	18ffe004 	addi	r3,r3,-128
 821f95c:	00820974 	movhi	r2,2085
 821f960:	10864f04 	addi	r2,r2,6460
 821f964:	18c01224 	muli	r3,r3,72
 821f968:	10c5883a 	add	r2,r2,r3
 821f96c:	10800a04 	addi	r2,r2,40
 821f970:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 821f974:	d0a07f83 	ldbu	r2,-32258(gp)
 821f978:	10c03fcc 	andi	r3,r2,255
 821f97c:	18c0201c 	xori	r3,r3,128
 821f980:	18ffe004 	addi	r3,r3,-128
 821f984:	00820974 	movhi	r2,2085
 821f988:	10864f04 	addi	r2,r2,6460
 821f98c:	18c01224 	muli	r3,r3,72
 821f990:	10c5883a 	add	r2,r2,r3
 821f994:	10800b04 	addi	r2,r2,44
 821f998:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 821f99c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9a0:	10c03fcc 	andi	r3,r2,255
 821f9a4:	18c0201c 	xori	r3,r3,128
 821f9a8:	18ffe004 	addi	r3,r3,-128
 821f9ac:	00820974 	movhi	r2,2085
 821f9b0:	10864f04 	addi	r2,r2,6460
 821f9b4:	18c01224 	muli	r3,r3,72
 821f9b8:	10c5883a 	add	r2,r2,r3
 821f9bc:	10800c04 	addi	r2,r2,48
 821f9c0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821f9c4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9c8:	10c03fcc 	andi	r3,r2,255
 821f9cc:	18c0201c 	xori	r3,r3,128
 821f9d0:	18ffe004 	addi	r3,r3,-128
 821f9d4:	00820974 	movhi	r2,2085
 821f9d8:	10864f04 	addi	r2,r2,6460
 821f9dc:	18c01224 	muli	r3,r3,72
 821f9e0:	10c5883a 	add	r2,r2,r3
 821f9e4:	10800d04 	addi	r2,r2,52
 821f9e8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 821f9ec:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9f0:	10c03fcc 	andi	r3,r2,255
 821f9f4:	18c0201c 	xori	r3,r3,128
 821f9f8:	18ffe004 	addi	r3,r3,-128
 821f9fc:	00820974 	movhi	r2,2085
 821fa00:	10864f04 	addi	r2,r2,6460
 821fa04:	18c01224 	muli	r3,r3,72
 821fa08:	10c5883a 	add	r2,r2,r3
 821fa0c:	10800e04 	addi	r2,r2,56
 821fa10:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 821fa14:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa18:	10c03fcc 	andi	r3,r2,255
 821fa1c:	18c0201c 	xori	r3,r3,128
 821fa20:	18ffe004 	addi	r3,r3,-128
 821fa24:	00820974 	movhi	r2,2085
 821fa28:	10864f04 	addi	r2,r2,6460
 821fa2c:	18c01224 	muli	r3,r3,72
 821fa30:	10c5883a 	add	r2,r2,r3
 821fa34:	10800f04 	addi	r2,r2,60
 821fa38:	10000015 	stw	zero,0(r2)
 821fa3c:	00005406 	br	821fb90 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 821fa40:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa44:	11003fcc 	andi	r4,r2,255
 821fa48:	2100201c 	xori	r4,r4,128
 821fa4c:	213fe004 	addi	r4,r4,-128
 821fa50:	e0bff817 	ldw	r2,-32(fp)
 821fa54:	10c00003 	ldbu	r3,0(r2)
 821fa58:	00820974 	movhi	r2,2085
 821fa5c:	10864f04 	addi	r2,r2,6460
 821fa60:	21001224 	muli	r4,r4,72
 821fa64:	1105883a 	add	r2,r2,r4
 821fa68:	10800904 	addi	r2,r2,36
 821fa6c:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 821fa70:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa74:	11003fcc 	andi	r4,r2,255
 821fa78:	2100201c 	xori	r4,r4,128
 821fa7c:	213fe004 	addi	r4,r4,-128
 821fa80:	e0bff817 	ldw	r2,-32(fp)
 821fa84:	10c00117 	ldw	r3,4(r2)
 821fa88:	00820974 	movhi	r2,2085
 821fa8c:	10864f04 	addi	r2,r2,6460
 821fa90:	21001224 	muli	r4,r4,72
 821fa94:	1105883a 	add	r2,r2,r4
 821fa98:	10800a04 	addi	r2,r2,40
 821fa9c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 821faa0:	d0a07f83 	ldbu	r2,-32258(gp)
 821faa4:	11003fcc 	andi	r4,r2,255
 821faa8:	2100201c 	xori	r4,r4,128
 821faac:	213fe004 	addi	r4,r4,-128
 821fab0:	e0bff817 	ldw	r2,-32(fp)
 821fab4:	10c00217 	ldw	r3,8(r2)
 821fab8:	00820974 	movhi	r2,2085
 821fabc:	10864f04 	addi	r2,r2,6460
 821fac0:	21001224 	muli	r4,r4,72
 821fac4:	1105883a 	add	r2,r2,r4
 821fac8:	10800b04 	addi	r2,r2,44
 821facc:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 821fad0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fad4:	11003fcc 	andi	r4,r2,255
 821fad8:	2100201c 	xori	r4,r4,128
 821fadc:	213fe004 	addi	r4,r4,-128
 821fae0:	e0bff817 	ldw	r2,-32(fp)
 821fae4:	10c00317 	ldw	r3,12(r2)
 821fae8:	00820974 	movhi	r2,2085
 821faec:	10864f04 	addi	r2,r2,6460
 821faf0:	21001224 	muli	r4,r4,72
 821faf4:	1105883a 	add	r2,r2,r4
 821faf8:	10800c04 	addi	r2,r2,48
 821fafc:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 821fb00:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb04:	11003fcc 	andi	r4,r2,255
 821fb08:	2100201c 	xori	r4,r4,128
 821fb0c:	213fe004 	addi	r4,r4,-128
 821fb10:	e0bff817 	ldw	r2,-32(fp)
 821fb14:	10c00417 	ldw	r3,16(r2)
 821fb18:	00820974 	movhi	r2,2085
 821fb1c:	10864f04 	addi	r2,r2,6460
 821fb20:	21001224 	muli	r4,r4,72
 821fb24:	1105883a 	add	r2,r2,r4
 821fb28:	10800d04 	addi	r2,r2,52
 821fb2c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 821fb30:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb34:	11003fcc 	andi	r4,r2,255
 821fb38:	2100201c 	xori	r4,r4,128
 821fb3c:	213fe004 	addi	r4,r4,-128
 821fb40:	e0bff817 	ldw	r2,-32(fp)
 821fb44:	10c00517 	ldw	r3,20(r2)
 821fb48:	00820974 	movhi	r2,2085
 821fb4c:	10864f04 	addi	r2,r2,6460
 821fb50:	21001224 	muli	r4,r4,72
 821fb54:	1105883a 	add	r2,r2,r4
 821fb58:	10800e04 	addi	r2,r2,56
 821fb5c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 821fb60:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb64:	11003fcc 	andi	r4,r2,255
 821fb68:	2100201c 	xori	r4,r4,128
 821fb6c:	213fe004 	addi	r4,r4,-128
 821fb70:	e0bff817 	ldw	r2,-32(fp)
 821fb74:	10c00617 	ldw	r3,24(r2)
 821fb78:	00820974 	movhi	r2,2085
 821fb7c:	10864f04 	addi	r2,r2,6460
 821fb80:	21001224 	muli	r4,r4,72
 821fb84:	1105883a 	add	r2,r2,r4
 821fb88:	10800f04 	addi	r2,r2,60
 821fb8c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 821fb90:	e0bff917 	ldw	r2,-28(fp)
 821fb94:	1000161e 	bne	r2,zero,821fbf0 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 821fb98:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb9c:	10c03fcc 	andi	r3,r2,255
 821fba0:	18c0201c 	xori	r3,r3,128
 821fba4:	18ffe004 	addi	r3,r3,-128
 821fba8:	00820974 	movhi	r2,2085
 821fbac:	10864f04 	addi	r2,r2,6460
 821fbb0:	18c01224 	muli	r3,r3,72
 821fbb4:	10c5883a 	add	r2,r2,r3
 821fbb8:	10801004 	addi	r2,r2,64
 821fbbc:	00ffffc4 	movi	r3,-1
 821fbc0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 821fbc4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbc8:	10c03fcc 	andi	r3,r2,255
 821fbcc:	18c0201c 	xori	r3,r3,128
 821fbd0:	18ffe004 	addi	r3,r3,-128
 821fbd4:	00820974 	movhi	r2,2085
 821fbd8:	10864f04 	addi	r2,r2,6460
 821fbdc:	18c01224 	muli	r3,r3,72
 821fbe0:	10c5883a 	add	r2,r2,r3
 821fbe4:	10801104 	addi	r2,r2,68
 821fbe8:	10000015 	stw	zero,0(r2)
 821fbec:	00001806 	br	821fc50 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 821fbf0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbf4:	11003fcc 	andi	r4,r2,255
 821fbf8:	2100201c 	xori	r4,r4,128
 821fbfc:	213fe004 	addi	r4,r4,-128
 821fc00:	e0bff917 	ldw	r2,-28(fp)
 821fc04:	10c00017 	ldw	r3,0(r2)
 821fc08:	00820974 	movhi	r2,2085
 821fc0c:	10864f04 	addi	r2,r2,6460
 821fc10:	21001224 	muli	r4,r4,72
 821fc14:	1105883a 	add	r2,r2,r4
 821fc18:	10801004 	addi	r2,r2,64
 821fc1c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 821fc20:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc24:	11003fcc 	andi	r4,r2,255
 821fc28:	2100201c 	xori	r4,r4,128
 821fc2c:	213fe004 	addi	r4,r4,-128
 821fc30:	e0bff917 	ldw	r2,-28(fp)
 821fc34:	10c00117 	ldw	r3,4(r2)
 821fc38:	00820974 	movhi	r2,2085
 821fc3c:	10864f04 	addi	r2,r2,6460
 821fc40:	21001224 	muli	r4,r4,72
 821fc44:	1105883a 	add	r2,r2,r4
 821fc48:	10801104 	addi	r2,r2,68
 821fc4c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 821fc50:	e0bff617 	ldw	r2,-40(fp)
 821fc54:	10800304 	addi	r2,r2,12
 821fc58:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 821fc5c:	e0bff717 	ldw	r2,-36(fp)
 821fc60:	10000326 	beq	r2,zero,821fc70 <alt_tse_system_add_sys+0x98c>
 821fc64:	e0bff717 	ldw	r2,-36(fp)
 821fc68:	10800204 	addi	r2,r2,8
 821fc6c:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 821fc70:	e0bff817 	ldw	r2,-32(fp)
 821fc74:	10000326 	beq	r2,zero,821fc84 <alt_tse_system_add_sys+0x9a0>
 821fc78:	e0bff817 	ldw	r2,-32(fp)
 821fc7c:	10800704 	addi	r2,r2,28
 821fc80:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 821fc84:	e0bff917 	ldw	r2,-28(fp)
 821fc88:	10000326 	beq	r2,zero,821fc98 <alt_tse_system_add_sys+0x9b4>
 821fc8c:	e0bff917 	ldw	r2,-28(fp)
 821fc90:	10800204 	addi	r2,r2,8
 821fc94:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 821fc98:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc9c:	10800044 	addi	r2,r2,1
 821fca0:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 821fca4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fca8:	d0a02d05 	stb	r2,-32588(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 821fcac:	e0bff417 	ldw	r2,-48(fp)
 821fcb0:	10800044 	addi	r2,r2,1
 821fcb4:	e0bff415 	stw	r2,-48(fp)
 821fcb8:	e0fff417 	ldw	r3,-48(fp)
 821fcbc:	e0bff517 	ldw	r2,-44(fp)
 821fcc0:	18bdb216 	blt	r3,r2,821f38c <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 821fcc4:	0005883a 	mov	r2,zero
	
}
 821fcc8:	e6ffff04 	addi	sp,fp,-4
 821fccc:	dfc00217 	ldw	ra,8(sp)
 821fcd0:	df000117 	ldw	fp,4(sp)
 821fcd4:	dc000017 	ldw	r16,0(sp)
 821fcd8:	dec00304 	addi	sp,sp,12
 821fcdc:	f800283a 	ret

0821fce0 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 821fce0:	defff904 	addi	sp,sp,-28
 821fce4:	dfc00615 	stw	ra,24(sp)
 821fce8:	df000515 	stw	fp,20(sp)
 821fcec:	df000504 	addi	fp,sp,20
 821fcf0:	e13ffe15 	stw	r4,-8(fp)
 821fcf4:	2805883a 	mov	r2,r5
 821fcf8:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 821fcfc:	e03ffb15 	stw	zero,-20(fp)
 821fd00:	00004806 	br	821fe24 <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 821fd04:	e0bffb17 	ldw	r2,-20(fp)
 821fd08:	1085883a 	add	r2,r2,r2
 821fd0c:	1085883a 	add	r2,r2,r2
 821fd10:	1007883a 	mov	r3,r2
 821fd14:	e0bffe17 	ldw	r2,-8(fp)
 821fd18:	10c5883a 	add	r2,r2,r3
 821fd1c:	10800017 	ldw	r2,0(r2)
 821fd20:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 821fd24:	e0bffd17 	ldw	r2,-12(fp)
 821fd28:	1000081e 	bne	r2,zero,821fd4c <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821fd2c:	01020974 	movhi	r4,2085
 821fd30:	2136e704 	addi	r4,r4,-9316
 821fd34:	82031200 	call	8203120 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 821fd38:	01020974 	movhi	r4,2085
 821fd3c:	21374c04 	addi	r4,r4,-8912
 821fd40:	82031200 	call	8203120 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821fd44:	00bfffc4 	movi	r2,-1
 821fd48:	00003a06 	br	821fe34 <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 821fd4c:	e03ffc15 	stw	zero,-16(fp)
 821fd50:	00002d06 	br	821fe08 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 821fd54:	e0bffd17 	ldw	r2,-12(fp)
 821fd58:	10c00017 	ldw	r3,0(r2)
 821fd5c:	00820974 	movhi	r2,2085
 821fd60:	10864f04 	addi	r2,r2,6460
 821fd64:	e13ffc17 	ldw	r4,-16(fp)
 821fd68:	21001224 	muli	r4,r4,72
 821fd6c:	1105883a 	add	r2,r2,r4
 821fd70:	10800017 	ldw	r2,0(r2)
 821fd74:	1880211e 	bne	r3,r2,821fdfc <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 821fd78:	00820974 	movhi	r2,2085
 821fd7c:	10864f04 	addi	r2,r2,6460
 821fd80:	e0fffc17 	ldw	r3,-16(fp)
 821fd84:	18c01224 	muli	r3,r3,72
 821fd88:	10c5883a 	add	r2,r2,r3
 821fd8c:	108002c4 	addi	r2,r2,11
 821fd90:	10800003 	ldbu	r2,0(r2)
 821fd94:	10803fcc 	andi	r2,r2,255
 821fd98:	10000826 	beq	r2,zero,821fdbc <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 821fd9c:	01020974 	movhi	r4,2085
 821fda0:	21376004 	addi	r4,r4,-8832
 821fda4:	82031200 	call	8203120 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 821fda8:	01020974 	movhi	r4,2085
 821fdac:	21377104 	addi	r4,r4,-8764
 821fdb0:	82031200 	call	8203120 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821fdb4:	00bfffc4 	movi	r2,-1
 821fdb8:	00001e06 	br	821fe34 <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 821fdbc:	00820974 	movhi	r2,2085
 821fdc0:	10864f04 	addi	r2,r2,6460
 821fdc4:	e0fffc17 	ldw	r3,-16(fp)
 821fdc8:	18c01224 	muli	r3,r3,72
 821fdcc:	10c5883a 	add	r2,r2,r3
 821fdd0:	10800344 	addi	r2,r2,13
 821fdd4:	00c00044 	movi	r3,1
 821fdd8:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 821fddc:	00820974 	movhi	r2,2085
 821fde0:	10864f04 	addi	r2,r2,6460
 821fde4:	e0fffc17 	ldw	r3,-16(fp)
 821fde8:	18c01224 	muli	r3,r3,72
 821fdec:	10c5883a 	add	r2,r2,r3
 821fdf0:	10800384 	addi	r2,r2,14
 821fdf4:	e0ffff03 	ldbu	r3,-4(fp)
 821fdf8:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 821fdfc:	e0bffc17 	ldw	r2,-16(fp)
 821fe00:	10800044 	addi	r2,r2,1
 821fe04:	e0bffc15 	stw	r2,-16(fp)
 821fe08:	d0a02d03 	ldbu	r2,-32588(gp)
 821fe0c:	10803fcc 	andi	r2,r2,255
 821fe10:	e0fffc17 	ldw	r3,-16(fp)
 821fe14:	18bfcf16 	blt	r3,r2,821fd54 <alt_tse_sys_enable_mdio_sharing+0x74>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 821fe18:	e0bffb17 	ldw	r2,-20(fp)
 821fe1c:	10800044 	addi	r2,r2,1
 821fe20:	e0bffb15 	stw	r2,-20(fp)
 821fe24:	e0bfff03 	ldbu	r2,-4(fp)
 821fe28:	e0fffb17 	ldw	r3,-20(fp)
 821fe2c:	18bfb516 	blt	r3,r2,821fd04 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 821fe30:	0005883a 	mov	r2,zero
}
 821fe34:	e037883a 	mov	sp,fp
 821fe38:	dfc00117 	ldw	ra,4(sp)
 821fe3c:	df000017 	ldw	fp,0(sp)
 821fe40:	dec00204 	addi	sp,sp,8
 821fe44:	f800283a 	ret

0821fe48 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 821fe48:	defffc04 	addi	sp,sp,-16
 821fe4c:	dfc00315 	stw	ra,12(sp)
 821fe50:	df000215 	stw	fp,8(sp)
 821fe54:	df000204 	addi	fp,sp,8
 821fe58:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 821fe5c:	e13fff17 	ldw	r4,-4(fp)
 821fe60:	82200300 	call	8220030 <alt_tse_get_mac_info>
 821fe64:	10800317 	ldw	r2,12(r2)
 821fe68:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 821fe6c:	e13ffe17 	ldw	r4,-8(fp)
 821fe70:	82232000 	call	8223200 <alt_tse_phy_get_common_speed>
}
 821fe74:	e037883a 	mov	sp,fp
 821fe78:	dfc00117 	ldw	ra,4(sp)
 821fe7c:	df000017 	ldw	fp,0(sp)
 821fe80:	dec00204 	addi	sp,sp,8
 821fe84:	f800283a 	ret

0821fe88 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 821fe88:	defffb04 	addi	sp,sp,-20
 821fe8c:	dfc00415 	stw	ra,16(sp)
 821fe90:	df000315 	stw	fp,12(sp)
 821fe94:	df000304 	addi	fp,sp,12
 821fe98:	e13ffe15 	stw	r4,-8(fp)
 821fe9c:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 821fea0:	e13ffe17 	ldw	r4,-8(fp)
 821fea4:	82200300 	call	8220030 <alt_tse_get_mac_info>
 821fea8:	10800317 	ldw	r2,12(r2)
 821feac:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 821feb0:	e17fff17 	ldw	r5,-4(fp)
 821feb4:	e13ffd17 	ldw	r4,-12(fp)
 821feb8:	82235280 	call	8223528 <alt_tse_phy_set_common_speed>
}
 821febc:	e037883a 	mov	sp,fp
 821fec0:	dfc00117 	ldw	ra,4(sp)
 821fec4:	df000017 	ldw	fp,0(sp)
 821fec8:	dec00204 	addi	sp,sp,8
 821fecc:	f800283a 	ret

0821fed0 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 821fed0:	defffd04 	addi	sp,sp,-12
 821fed4:	df000215 	stw	fp,8(sp)
 821fed8:	df000204 	addi	fp,sp,8
 821fedc:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 821fee0:	e03ffe15 	stw	zero,-8(fp)
 821fee4:	00000c06 	br	821ff18 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 821fee8:	e0bffe17 	ldw	r2,-8(fp)
 821feec:	10c01224 	muli	r3,r2,72
 821fef0:	00820974 	movhi	r2,2085
 821fef4:	10864f04 	addi	r2,r2,6460
 821fef8:	1887883a 	add	r3,r3,r2
 821fefc:	e0bfff17 	ldw	r2,-4(fp)
 821ff00:	1880021e 	bne	r3,r2,821ff0c <alt_tse_get_system_index+0x3c>
            return i;
 821ff04:	e0bffe17 	ldw	r2,-8(fp)
 821ff08:	00000806 	br	821ff2c <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 821ff0c:	e0bffe17 	ldw	r2,-8(fp)
 821ff10:	10800044 	addi	r2,r2,1
 821ff14:	e0bffe15 	stw	r2,-8(fp)
 821ff18:	d0a02d03 	ldbu	r2,-32588(gp)
 821ff1c:	10803fcc 	andi	r2,r2,255
 821ff20:	e0fffe17 	ldw	r3,-8(fp)
 821ff24:	18bff016 	blt	r3,r2,821fee8 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 821ff28:	00bfffc4 	movi	r2,-1
}
 821ff2c:	e037883a 	mov	sp,fp
 821ff30:	df000017 	ldw	fp,0(sp)
 821ff34:	dec00104 	addi	sp,sp,4
 821ff38:	f800283a 	ret

0821ff3c <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 821ff3c:	defffd04 	addi	sp,sp,-12
 821ff40:	df000215 	stw	fp,8(sp)
 821ff44:	df000204 	addi	fp,sp,8
 821ff48:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 821ff4c:	e03ffe15 	stw	zero,-8(fp)
 821ff50:	00000e06 	br	821ff8c <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 821ff54:	008209b4 	movhi	r2,2086
 821ff58:	10b58d04 	addi	r2,r2,-10700
 821ff5c:	e0fffe17 	ldw	r3,-8(fp)
 821ff60:	18c7883a 	add	r3,r3,r3
 821ff64:	18c7883a 	add	r3,r3,r3
 821ff68:	10c5883a 	add	r2,r2,r3
 821ff6c:	10c00017 	ldw	r3,0(r2)
 821ff70:	e0bfff17 	ldw	r2,-4(fp)
 821ff74:	1880021e 	bne	r3,r2,821ff80 <alt_tse_get_mac_group_index+0x44>
            return i;
 821ff78:	e0bffe17 	ldw	r2,-8(fp)
 821ff7c:	00000806 	br	821ffa0 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 821ff80:	e0bffe17 	ldw	r2,-8(fp)
 821ff84:	10800044 	addi	r2,r2,1
 821ff88:	e0bffe15 	stw	r2,-8(fp)
 821ff8c:	d0a07f43 	ldbu	r2,-32259(gp)
 821ff90:	10803fcc 	andi	r2,r2,255
 821ff94:	e0fffe17 	ldw	r3,-8(fp)
 821ff98:	18bfee16 	blt	r3,r2,821ff54 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 821ff9c:	00bfffc4 	movi	r2,-1
}
 821ffa0:	e037883a 	mov	sp,fp
 821ffa4:	df000017 	ldw	fp,0(sp)
 821ffa8:	dec00104 	addi	sp,sp,4
 821ffac:	f800283a 	ret

0821ffb0 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 821ffb0:	defffd04 	addi	sp,sp,-12
 821ffb4:	df000215 	stw	fp,8(sp)
 821ffb8:	df000204 	addi	fp,sp,8
 821ffbc:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 821ffc0:	e03ffe15 	stw	zero,-8(fp)
 821ffc4:	00000f06 	br	8220004 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 821ffc8:	e0bfff17 	ldw	r2,-4(fp)
 821ffcc:	10c00317 	ldw	r3,12(r2)
 821ffd0:	e0bffe17 	ldw	r2,-8(fp)
 821ffd4:	10800044 	addi	r2,r2,1
 821ffd8:	1085883a 	add	r2,r2,r2
 821ffdc:	1085883a 	add	r2,r2,r2
 821ffe0:	1885883a 	add	r2,r3,r2
 821ffe4:	10c00017 	ldw	r3,0(r2)
 821ffe8:	e0bfff17 	ldw	r2,-4(fp)
 821ffec:	1880021e 	bne	r3,r2,821fff8 <alt_tse_get_mac_info_index+0x48>
            return i;
 821fff0:	e0bffe17 	ldw	r2,-8(fp)
 821fff4:	00000a06 	br	8220020 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 821fff8:	e0bffe17 	ldw	r2,-8(fp)
 821fffc:	10800044 	addi	r2,r2,1
 8220000:	e0bffe15 	stw	r2,-8(fp)
 8220004:	e0bfff17 	ldw	r2,-4(fp)
 8220008:	10800317 	ldw	r2,12(r2)
 822000c:	10800003 	ldbu	r2,0(r2)
 8220010:	10803fcc 	andi	r2,r2,255
 8220014:	e0fffe17 	ldw	r3,-8(fp)
 8220018:	18bfeb16 	blt	r3,r2,821ffc8 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 822001c:	00bfffc4 	movi	r2,-1
}
 8220020:	e037883a 	mov	sp,fp
 8220024:	df000017 	ldw	fp,0(sp)
 8220028:	dec00104 	addi	sp,sp,4
 822002c:	f800283a 	ret

08220030 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 8220030:	defffa04 	addi	sp,sp,-24
 8220034:	df000515 	stw	fp,20(sp)
 8220038:	df000504 	addi	fp,sp,20
 822003c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 8220040:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 8220044:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 8220048:	e03ffb15 	stw	zero,-20(fp)
 822004c:	00002506 	br	82200e4 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 8220050:	008209b4 	movhi	r2,2086
 8220054:	10b58d04 	addi	r2,r2,-10700
 8220058:	e0fffb17 	ldw	r3,-20(fp)
 822005c:	18c7883a 	add	r3,r3,r3
 8220060:	18c7883a 	add	r3,r3,r3
 8220064:	10c5883a 	add	r2,r2,r3
 8220068:	10800017 	ldw	r2,0(r2)
 822006c:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 8220070:	e03ffc15 	stw	zero,-16(fp)
 8220074:	00001306 	br	82200c4 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 8220078:	e0fffd17 	ldw	r3,-12(fp)
 822007c:	e0bffc17 	ldw	r2,-16(fp)
 8220080:	10800044 	addi	r2,r2,1
 8220084:	1085883a 	add	r2,r2,r2
 8220088:	1085883a 	add	r2,r2,r2
 822008c:	1885883a 	add	r2,r3,r2
 8220090:	10800017 	ldw	r2,0(r2)
 8220094:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 8220098:	e0bffe17 	ldw	r2,-8(fp)
 822009c:	10800217 	ldw	r2,8(r2)
 82200a0:	10800017 	ldw	r2,0(r2)
 82200a4:	1007883a 	mov	r3,r2
 82200a8:	e0bfff17 	ldw	r2,-4(fp)
 82200ac:	1880021e 	bne	r3,r2,82200b8 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 82200b0:	e0bffe17 	ldw	r2,-8(fp)
 82200b4:	00001006 	br	82200f8 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 82200b8:	e0bffc17 	ldw	r2,-16(fp)
 82200bc:	10800044 	addi	r2,r2,1
 82200c0:	e0bffc15 	stw	r2,-16(fp)
 82200c4:	e0bffd17 	ldw	r2,-12(fp)
 82200c8:	10800003 	ldbu	r2,0(r2)
 82200cc:	10803fcc 	andi	r2,r2,255
 82200d0:	e0fffc17 	ldw	r3,-16(fp)
 82200d4:	18bfe816 	blt	r3,r2,8220078 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 82200d8:	e0bffb17 	ldw	r2,-20(fp)
 82200dc:	10800044 	addi	r2,r2,1
 82200e0:	e0bffb15 	stw	r2,-20(fp)
 82200e4:	d0a07f43 	ldbu	r2,-32259(gp)
 82200e8:	10803fcc 	andi	r2,r2,255
 82200ec:	e0fffb17 	ldw	r3,-20(fp)
 82200f0:	18bfd716 	blt	r3,r2,8220050 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 82200f4:	0005883a 	mov	r2,zero
}
 82200f8:	e037883a 	mov	sp,fp
 82200fc:	df000017 	ldw	fp,0(sp)
 8220100:	dec00104 	addi	sp,sp,4
 8220104:	f800283a 	ret

08220108 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 8220108:	defffc04 	addi	sp,sp,-16
 822010c:	df000315 	stw	fp,12(sp)
 8220110:	df000304 	addi	fp,sp,12
 8220114:	e13ffe15 	stw	r4,-8(fp)
 8220118:	2805883a 	mov	r2,r5
 822011c:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220120:	e0bffe17 	ldw	r2,-8(fp)
 8220124:	10800204 	addi	r2,r2,8
 8220128:	10800037 	ldwio	r2,0(r2)
 822012c:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 8220130:	e0bfff03 	ldbu	r2,-4(fp)
 8220134:	10800098 	cmpnei	r2,r2,2
 8220138:	1000091e 	bne	r2,zero,8220160 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 822013c:	e0bffd17 	ldw	r2,-12(fp)
 8220140:	10800214 	ori	r2,r2,8
 8220144:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220148:	e0fffd17 	ldw	r3,-12(fp)
 822014c:	00bf8034 	movhi	r2,65024
 8220150:	10bfffc4 	addi	r2,r2,-1
 8220154:	1884703a 	and	r2,r3,r2
 8220158:	e0bffd15 	stw	r2,-12(fp)
 822015c:	00001906 	br	82201c4 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 8220160:	e0bfff03 	ldbu	r2,-4(fp)
 8220164:	10800058 	cmpnei	r2,r2,1
 8220168:	10000a1e 	bne	r2,zero,8220194 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 822016c:	e0fffd17 	ldw	r3,-12(fp)
 8220170:	00bffdc4 	movi	r2,-9
 8220174:	1884703a 	and	r2,r3,r2
 8220178:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 822017c:	e0fffd17 	ldw	r3,-12(fp)
 8220180:	00bf8034 	movhi	r2,65024
 8220184:	10bfffc4 	addi	r2,r2,-1
 8220188:	1884703a 	and	r2,r3,r2
 822018c:	e0bffd15 	stw	r2,-12(fp)
 8220190:	00000c06 	br	82201c4 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 8220194:	e0bfff03 	ldbu	r2,-4(fp)
 8220198:	1000081e 	bne	r2,zero,82201bc <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 822019c:	e0fffd17 	ldw	r3,-12(fp)
 82201a0:	00bffdc4 	movi	r2,-9
 82201a4:	1884703a 	and	r2,r3,r2
 82201a8:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82201ac:	e0bffd17 	ldw	r2,-12(fp)
 82201b0:	10808034 	orhi	r2,r2,512
 82201b4:	e0bffd15 	stw	r2,-12(fp)
 82201b8:	00000206 	br	82201c4 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 82201bc:	00bffd84 	movi	r2,-10
 82201c0:	00000506 	br	82201d8 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 82201c4:	e0bffe17 	ldw	r2,-8(fp)
 82201c8:	10800204 	addi	r2,r2,8
 82201cc:	e0fffd17 	ldw	r3,-12(fp)
 82201d0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 82201d4:	0005883a 	mov	r2,zero
}
 82201d8:	e037883a 	mov	sp,fp
 82201dc:	df000017 	ldw	fp,0(sp)
 82201e0:	dec00104 	addi	sp,sp,4
 82201e4:	f800283a 	ret

082201e8 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 82201e8:	defffc04 	addi	sp,sp,-16
 82201ec:	df000315 	stw	fp,12(sp)
 82201f0:	df000304 	addi	fp,sp,12
 82201f4:	e13ffe15 	stw	r4,-8(fp)
 82201f8:	2805883a 	mov	r2,r5
 82201fc:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220200:	e0bffe17 	ldw	r2,-8(fp)
 8220204:	10800204 	addi	r2,r2,8
 8220208:	10800037 	ldwio	r2,0(r2)
 822020c:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8220210:	e0bfff03 	ldbu	r2,-4(fp)
 8220214:	1000041e 	bne	r2,zero,8220228 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8220218:	e0bffd17 	ldw	r2,-12(fp)
 822021c:	10810014 	ori	r2,r2,1024
 8220220:	e0bffd15 	stw	r2,-12(fp)
 8220224:	00000a06 	br	8220250 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 8220228:	e0bfff03 	ldbu	r2,-4(fp)
 822022c:	10800058 	cmpnei	r2,r2,1
 8220230:	1000051e 	bne	r2,zero,8220248 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8220234:	e0fffd17 	ldw	r3,-12(fp)
 8220238:	00beffc4 	movi	r2,-1025
 822023c:	1884703a 	and	r2,r3,r2
 8220240:	e0bffd15 	stw	r2,-12(fp)
 8220244:	00000206 	br	8220250 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 8220248:	00bffd84 	movi	r2,-10
 822024c:	00000506 	br	8220264 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 8220250:	e0bffe17 	ldw	r2,-8(fp)
 8220254:	10800204 	addi	r2,r2,8
 8220258:	e0fffd17 	ldw	r3,-12(fp)
 822025c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 8220260:	0005883a 	mov	r2,zero

}
 8220264:	e037883a 	mov	sp,fp
 8220268:	df000017 	ldw	fp,0(sp)
 822026c:	dec00104 	addi	sp,sp,4
 8220270:	f800283a 	ret

08220274 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 8220274:	defff404 	addi	sp,sp,-48
 8220278:	dfc00b15 	stw	ra,44(sp)
 822027c:	df000a15 	stw	fp,40(sp)
 8220280:	df000a04 	addi	fp,sp,40
 8220284:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220288:	00800044 	movi	r2,1
 822028c:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 8220290:	00800044 	movi	r2,1
 8220294:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8220298:	e0bff743 	ldbu	r2,-35(fp)
 822029c:	10c0004c 	andi	r3,r2,1
 82202a0:	e0bff703 	ldbu	r2,-36(fp)
 82202a4:	10800098 	cmpnei	r2,r2,2
 82202a8:	1000021e 	bne	r2,zero,82202b4 <getPHYSpeed+0x40>
 82202ac:	00800084 	movi	r2,2
 82202b0:	00000106 	br	82202b8 <getPHYSpeed+0x44>
 82202b4:	0005883a 	mov	r2,zero
 82202b8:	1886b03a 	or	r3,r3,r2
 82202bc:	e0bff703 	ldbu	r2,-36(fp)
 82202c0:	10800058 	cmpnei	r2,r2,1
 82202c4:	1000021e 	bne	r2,zero,82202d0 <getPHYSpeed+0x5c>
 82202c8:	00800104 	movi	r2,4
 82202cc:	00000106 	br	82202d4 <getPHYSpeed+0x60>
 82202d0:	0005883a 	mov	r2,zero
 82202d4:	1886b03a 	or	r3,r3,r2
 82202d8:	e0bff703 	ldbu	r2,-36(fp)
 82202dc:	1000021e 	bne	r2,zero,82202e8 <getPHYSpeed+0x74>
 82202e0:	00800204 	movi	r2,8
 82202e4:	00000106 	br	82202ec <getPHYSpeed+0x78>
 82202e8:	0005883a 	mov	r2,zero
 82202ec:	1886b03a 	or	r3,r3,r2
 82202f0:	e0bff703 	ldbu	r2,-36(fp)
 82202f4:	108000d8 	cmpnei	r2,r2,3
 82202f8:	1000021e 	bne	r2,zero,8220304 <getPHYSpeed+0x90>
 82202fc:	00800074 	movhi	r2,1
 8220300:	00000106 	br	8220308 <getPHYSpeed+0x94>
 8220304:	0005883a 	mov	r2,zero
 8220308:	1884b03a 	or	r2,r3,r2
 822030c:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 8220310:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 8220314:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 8220318:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 822031c:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8220320:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 8220324:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 8220328:	d0a07fc3 	ldbu	r2,-32257(gp)
 822032c:	10803fcc 	andi	r2,r2,255
 8220330:	1000031e 	bne	r2,zero,8220340 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 8220334:	82222740 	call	8222274 <alt_tse_phy_init>
        is_init = 1;
 8220338:	00800044 	movi	r2,1
 822033c:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 8220340:	e13fff17 	ldw	r4,-4(fp)
 8220344:	82200300 	call	8220030 <alt_tse_get_mac_info>
 8220348:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 822034c:	e0bffa17 	ldw	r2,-24(fp)
 8220350:	1000481e 	bne	r2,zero,8220474 <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220354:	00800044 	movi	r2,1
 8220358:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 822035c:	00800044 	movi	r2,1
 8220360:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 8220364:	e0bff743 	ldbu	r2,-35(fp)
 8220368:	10c0004c 	andi	r3,r2,1
 822036c:	e0bff703 	ldbu	r2,-36(fp)
 8220370:	10800098 	cmpnei	r2,r2,2
 8220374:	1000021e 	bne	r2,zero,8220380 <getPHYSpeed+0x10c>
 8220378:	00800084 	movi	r2,2
 822037c:	00000106 	br	8220384 <getPHYSpeed+0x110>
 8220380:	0005883a 	mov	r2,zero
 8220384:	1886b03a 	or	r3,r3,r2
 8220388:	e0bff703 	ldbu	r2,-36(fp)
 822038c:	10800058 	cmpnei	r2,r2,1
 8220390:	1000021e 	bne	r2,zero,822039c <getPHYSpeed+0x128>
 8220394:	00800104 	movi	r2,4
 8220398:	00000106 	br	82203a0 <getPHYSpeed+0x12c>
 822039c:	0005883a 	mov	r2,zero
 82203a0:	1886b03a 	or	r3,r3,r2
 82203a4:	e0bff703 	ldbu	r2,-36(fp)
 82203a8:	1000021e 	bne	r2,zero,82203b4 <getPHYSpeed+0x140>
 82203ac:	00800204 	movi	r2,8
 82203b0:	00000106 	br	82203b8 <getPHYSpeed+0x144>
 82203b4:	0005883a 	mov	r2,zero
 82203b8:	1886b03a 	or	r3,r3,r2
 82203bc:	e0bff703 	ldbu	r2,-36(fp)
 82203c0:	108000d8 	cmpnei	r2,r2,3
 82203c4:	1000021e 	bne	r2,zero,82203d0 <getPHYSpeed+0x15c>
 82203c8:	00800074 	movhi	r2,1
 82203cc:	00000106 	br	82203d4 <getPHYSpeed+0x160>
 82203d0:	0005883a 	mov	r2,zero
 82203d4:	1884b03a 	or	r2,r3,r2
 82203d8:	10802034 	orhi	r2,r2,128
 82203dc:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 82203e0:	e0bff703 	ldbu	r2,-36(fp)
 82203e4:	108000a0 	cmpeqi	r2,r2,2
 82203e8:	10000e1e 	bne	r2,zero,8220424 <getPHYSpeed+0x1b0>
 82203ec:	e0bff703 	ldbu	r2,-36(fp)
 82203f0:	10800060 	cmpeqi	r2,r2,1
 82203f4:	1000081e 	bne	r2,zero,8220418 <getPHYSpeed+0x1a4>
 82203f8:	e0bff703 	ldbu	r2,-36(fp)
 82203fc:	1000031e 	bne	r2,zero,822040c <getPHYSpeed+0x198>
 8220400:	00820974 	movhi	r2,2085
 8220404:	10b78004 	addi	r2,r2,-8704
 8220408:	00000806 	br	822042c <getPHYSpeed+0x1b8>
 822040c:	00820974 	movhi	r2,2085
 8220410:	10b78104 	addi	r2,r2,-8700
 8220414:	00000506 	br	822042c <getPHYSpeed+0x1b8>
 8220418:	00820974 	movhi	r2,2085
 822041c:	10b78304 	addi	r2,r2,-8692
 8220420:	00000206 	br	822042c <getPHYSpeed+0x1b8>
 8220424:	00820974 	movhi	r2,2085
 8220428:	10b78404 	addi	r2,r2,-8688
 822042c:	e0fff743 	ldbu	r3,-35(fp)
 8220430:	18c00058 	cmpnei	r3,r3,1
 8220434:	1800031e 	bne	r3,zero,8220444 <getPHYSpeed+0x1d0>
 8220438:	00c20974 	movhi	r3,2085
 822043c:	18f78604 	addi	r3,r3,-8680
 8220440:	00000206 	br	822044c <getPHYSpeed+0x1d8>
 8220444:	00c20974 	movhi	r3,2085
 8220448:	18f78804 	addi	r3,r3,-8672
 822044c:	180d883a 	mov	r6,r3
 8220450:	100b883a 	mov	r5,r2
 8220454:	01020974 	movhi	r4,2085
 8220458:	21378a04 	addi	r4,r4,-8664
 822045c:	8202e9c0 	call	8202e9c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 8220460:	01020974 	movhi	r4,2085
 8220464:	2137a204 	addi	r4,r4,-8568
 8220468:	82031200 	call	8203120 <puts>
        return result;
 822046c:	e0bff817 	ldw	r2,-32(fp)
 8220470:	00021d06 	br	8220ce8 <getPHYSpeed+0xa74>
    }
    
    pphy = pmac_info->pphy_info;
 8220474:	e0bffa17 	ldw	r2,-24(fp)
 8220478:	10800117 	ldw	r2,4(r2)
 822047c:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 8220480:	e0bffa17 	ldw	r2,-24(fp)
 8220484:	10800317 	ldw	r2,12(r2)
 8220488:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 822048c:	e0bffa17 	ldw	r2,-24(fp)
 8220490:	10800217 	ldw	r2,8(r2)
 8220494:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8220498:	e13ffa17 	ldw	r4,-24(fp)
 822049c:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 82204a0:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82204a4:	e13ffb17 	ldw	r4,-20(fp)
 82204a8:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 82204ac:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 82204b0:	e0bffb17 	ldw	r2,-20(fp)
 82204b4:	10800117 	ldw	r2,4(r2)
 82204b8:	10800217 	ldw	r2,8(r2)
 82204bc:	10800203 	ldbu	r2,8(r2)
 82204c0:	10803fcc 	andi	r2,r2,255
 82204c4:	10005a1e 	bne	r2,zero,8220630 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82204c8:	00800044 	movi	r2,1
 82204cc:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 82204d0:	00800044 	movi	r2,1
 82204d4:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 82204d8:	e0bff743 	ldbu	r2,-35(fp)
 82204dc:	10c0004c 	andi	r3,r2,1
 82204e0:	e0bff703 	ldbu	r2,-36(fp)
 82204e4:	10800098 	cmpnei	r2,r2,2
 82204e8:	1000021e 	bne	r2,zero,82204f4 <getPHYSpeed+0x280>
 82204ec:	00800084 	movi	r2,2
 82204f0:	00000106 	br	82204f8 <getPHYSpeed+0x284>
 82204f4:	0005883a 	mov	r2,zero
 82204f8:	1886b03a 	or	r3,r3,r2
 82204fc:	e0bff703 	ldbu	r2,-36(fp)
 8220500:	10800058 	cmpnei	r2,r2,1
 8220504:	1000021e 	bne	r2,zero,8220510 <getPHYSpeed+0x29c>
 8220508:	00800104 	movi	r2,4
 822050c:	00000106 	br	8220514 <getPHYSpeed+0x2a0>
 8220510:	0005883a 	mov	r2,zero
 8220514:	1886b03a 	or	r3,r3,r2
 8220518:	e0bff703 	ldbu	r2,-36(fp)
 822051c:	1000021e 	bne	r2,zero,8220528 <getPHYSpeed+0x2b4>
 8220520:	00800204 	movi	r2,8
 8220524:	00000106 	br	822052c <getPHYSpeed+0x2b8>
 8220528:	0005883a 	mov	r2,zero
 822052c:	1886b03a 	or	r3,r3,r2
 8220530:	e0bff703 	ldbu	r2,-36(fp)
 8220534:	108000d8 	cmpnei	r2,r2,3
 8220538:	1000021e 	bne	r2,zero,8220544 <getPHYSpeed+0x2d0>
 822053c:	00800074 	movhi	r2,1
 8220540:	00000106 	br	8220548 <getPHYSpeed+0x2d4>
 8220544:	0005883a 	mov	r2,zero
 8220548:	1884b03a 	or	r2,r3,r2
 822054c:	10801034 	orhi	r2,r2,64
 8220550:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 8220554:	010003f4 	movhi	r4,15
 8220558:	21109004 	addi	r4,r4,16960
 822055c:	82143d00 	call	82143d0 <usleep>
        if(psys->tse_phy_cfg) {
 8220560:	e0bffc17 	ldw	r2,-16(fp)
 8220564:	10801117 	ldw	r2,68(r2)
 8220568:	10000d26 	beq	r2,zero,82205a0 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 822056c:	e0bffd47 	ldb	r2,-11(fp)
 8220570:	e0fffd07 	ldb	r3,-12(fp)
 8220574:	180d883a 	mov	r6,r3
 8220578:	100b883a 	mov	r5,r2
 822057c:	01020974 	movhi	r4,2085
 8220580:	2137b304 	addi	r4,r4,-8500
 8220584:	8202e9c0 	call	8202e9c <printf>
        	result = psys->tse_phy_cfg(pmac);
 8220588:	e0bffc17 	ldw	r2,-16(fp)
 822058c:	10801117 	ldw	r2,68(r2)
 8220590:	e13fff17 	ldw	r4,-4(fp)
 8220594:	103ee83a 	callr	r2
 8220598:	e0bff815 	stw	r2,-32(fp)
 822059c:	00002206 	br	8220628 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82205a0:	e13ffd47 	ldb	r4,-11(fp)
 82205a4:	e0bff703 	ldbu	r2,-36(fp)
 82205a8:	108000a0 	cmpeqi	r2,r2,2
 82205ac:	10000e1e 	bne	r2,zero,82205e8 <getPHYSpeed+0x374>
 82205b0:	e0bff703 	ldbu	r2,-36(fp)
 82205b4:	10800060 	cmpeqi	r2,r2,1
 82205b8:	1000081e 	bne	r2,zero,82205dc <getPHYSpeed+0x368>
 82205bc:	e0bff703 	ldbu	r2,-36(fp)
 82205c0:	1000031e 	bne	r2,zero,82205d0 <getPHYSpeed+0x35c>
 82205c4:	00820974 	movhi	r2,2085
 82205c8:	10b78004 	addi	r2,r2,-8704
 82205cc:	00000806 	br	82205f0 <getPHYSpeed+0x37c>
 82205d0:	00820974 	movhi	r2,2085
 82205d4:	10b78104 	addi	r2,r2,-8700
 82205d8:	00000506 	br	82205f0 <getPHYSpeed+0x37c>
 82205dc:	00820974 	movhi	r2,2085
 82205e0:	10b78304 	addi	r2,r2,-8692
 82205e4:	00000206 	br	82205f0 <getPHYSpeed+0x37c>
 82205e8:	00820974 	movhi	r2,2085
 82205ec:	10b78404 	addi	r2,r2,-8688
 82205f0:	e0fff743 	ldbu	r3,-35(fp)
 82205f4:	18c00058 	cmpnei	r3,r3,1
 82205f8:	1800031e 	bne	r3,zero,8220608 <getPHYSpeed+0x394>
 82205fc:	00c20974 	movhi	r3,2085
 8220600:	18f78604 	addi	r3,r3,-8680
 8220604:	00000206 	br	8220610 <getPHYSpeed+0x39c>
 8220608:	00c20974 	movhi	r3,2085
 822060c:	18f78804 	addi	r3,r3,-8672
 8220610:	180f883a 	mov	r7,r3
 8220614:	100d883a 	mov	r6,r2
 8220618:	200b883a 	mov	r5,r4
 822061c:	01020974 	movhi	r4,2085
 8220620:	2137c504 	addi	r4,r4,-8428
 8220624:	8202e9c0 	call	8202e9c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 8220628:	e0bff817 	ldw	r2,-32(fp)
 822062c:	0001ae06 	br	8220ce8 <getPHYSpeed+0xa74>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220630:	e0bffb17 	ldw	r2,-20(fp)
 8220634:	10800117 	ldw	r2,4(r2)
 8220638:	10800217 	ldw	r2,8(r2)
 822063c:	10800017 	ldw	r2,0(r2)
 8220640:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 8220644:	e0bff917 	ldw	r2,-28(fp)
 8220648:	1000491e 	bne	r2,zero,8220770 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 822064c:	00800044 	movi	r2,1
 8220650:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220654:	00800044 	movi	r2,1
 8220658:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 822065c:	e0bff743 	ldbu	r2,-35(fp)
 8220660:	10c0004c 	andi	r3,r2,1
 8220664:	e0bff703 	ldbu	r2,-36(fp)
 8220668:	10800098 	cmpnei	r2,r2,2
 822066c:	1000021e 	bne	r2,zero,8220678 <getPHYSpeed+0x404>
 8220670:	00800084 	movi	r2,2
 8220674:	00000106 	br	822067c <getPHYSpeed+0x408>
 8220678:	0005883a 	mov	r2,zero
 822067c:	1886b03a 	or	r3,r3,r2
 8220680:	e0bff703 	ldbu	r2,-36(fp)
 8220684:	10800058 	cmpnei	r2,r2,1
 8220688:	1000021e 	bne	r2,zero,8220694 <getPHYSpeed+0x420>
 822068c:	00800104 	movi	r2,4
 8220690:	00000106 	br	8220698 <getPHYSpeed+0x424>
 8220694:	0005883a 	mov	r2,zero
 8220698:	1886b03a 	or	r3,r3,r2
 822069c:	e0bff703 	ldbu	r2,-36(fp)
 82206a0:	1000021e 	bne	r2,zero,82206ac <getPHYSpeed+0x438>
 82206a4:	00800204 	movi	r2,8
 82206a8:	00000106 	br	82206b0 <getPHYSpeed+0x43c>
 82206ac:	0005883a 	mov	r2,zero
 82206b0:	1886b03a 	or	r3,r3,r2
 82206b4:	e0bff703 	ldbu	r2,-36(fp)
 82206b8:	108000d8 	cmpnei	r2,r2,3
 82206bc:	1000021e 	bne	r2,zero,82206c8 <getPHYSpeed+0x454>
 82206c0:	00800074 	movhi	r2,1
 82206c4:	00000106 	br	82206cc <getPHYSpeed+0x458>
 82206c8:	0005883a 	mov	r2,zero
 82206cc:	1884b03a 	or	r2,r3,r2
 82206d0:	10800834 	orhi	r2,r2,32
 82206d4:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82206d8:	e13ffd47 	ldb	r4,-11(fp)
 82206dc:	e17ffd07 	ldb	r5,-12(fp)
 82206e0:	e0bff703 	ldbu	r2,-36(fp)
 82206e4:	108000a0 	cmpeqi	r2,r2,2
 82206e8:	10000e1e 	bne	r2,zero,8220724 <getPHYSpeed+0x4b0>
 82206ec:	e0bff703 	ldbu	r2,-36(fp)
 82206f0:	10800060 	cmpeqi	r2,r2,1
 82206f4:	1000081e 	bne	r2,zero,8220718 <getPHYSpeed+0x4a4>
 82206f8:	e0bff703 	ldbu	r2,-36(fp)
 82206fc:	1000031e 	bne	r2,zero,822070c <getPHYSpeed+0x498>
 8220700:	00820974 	movhi	r2,2085
 8220704:	10b78004 	addi	r2,r2,-8704
 8220708:	00000806 	br	822072c <getPHYSpeed+0x4b8>
 822070c:	00820974 	movhi	r2,2085
 8220710:	10b78104 	addi	r2,r2,-8700
 8220714:	00000506 	br	822072c <getPHYSpeed+0x4b8>
 8220718:	00820974 	movhi	r2,2085
 822071c:	10b78304 	addi	r2,r2,-8692
 8220720:	00000206 	br	822072c <getPHYSpeed+0x4b8>
 8220724:	00820974 	movhi	r2,2085
 8220728:	10b78404 	addi	r2,r2,-8688
 822072c:	e0fff743 	ldbu	r3,-35(fp)
 8220730:	18c00058 	cmpnei	r3,r3,1
 8220734:	1800031e 	bne	r3,zero,8220744 <getPHYSpeed+0x4d0>
 8220738:	00c20974 	movhi	r3,2085
 822073c:	18f78604 	addi	r3,r3,-8680
 8220740:	00000206 	br	822074c <getPHYSpeed+0x4d8>
 8220744:	00c20974 	movhi	r3,2085
 8220748:	18f78804 	addi	r3,r3,-8672
 822074c:	d8c00015 	stw	r3,0(sp)
 8220750:	100f883a 	mov	r7,r2
 8220754:	280d883a 	mov	r6,r5
 8220758:	200b883a 	mov	r5,r4
 822075c:	01020974 	movhi	r4,2085
 8220760:	2137d704 	addi	r4,r4,-8356
 8220764:	8202e9c0 	call	8202e9c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 8220768:	e0bff817 	ldw	r2,-32(fp)
 822076c:	00015e06 	br	8220ce8 <getPHYSpeed+0xa74>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8220770:	e0bffa17 	ldw	r2,-24(fp)
 8220774:	10800003 	ldbu	r2,0(r2)
 8220778:	10803fcc 	andi	r2,r2,255
 822077c:	10800058 	cmpnei	r2,r2,1
 8220780:	1000081e 	bne	r2,zero,82207a4 <getPHYSpeed+0x530>
			alt_tse_phy_set_adv_1000(pphy, 0);
 8220784:	000b883a 	mov	r5,zero
 8220788:	e13ff917 	ldw	r4,-28(fp)
 822078c:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220790:	01400134 	movhi	r5,4
 8220794:	29742404 	addi	r5,r5,-12144
 8220798:	e13ff917 	ldw	r4,-28(fp)
 822079c:	822238c0 	call	822238c <alt_tse_phy_restart_an>
 82207a0:	00000f06 	br	82207e0 <getPHYSpeed+0x56c>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 82207a4:	e0bffa17 	ldw	r2,-24(fp)
 82207a8:	10800003 	ldbu	r2,0(r2)
 82207ac:	10803fcc 	andi	r2,r2,255
 82207b0:	10800098 	cmpnei	r2,r2,2
 82207b4:	10000a1e 	bne	r2,zero,82207e0 <getPHYSpeed+0x56c>
			alt_tse_phy_set_adv_100(pphy, 0);
 82207b8:	000b883a 	mov	r5,zero
 82207bc:	e13ff917 	ldw	r4,-28(fp)
 82207c0:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 82207c4:	000b883a 	mov	r5,zero
 82207c8:	e13ff917 	ldw	r4,-28(fp)
 82207cc:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 82207d0:	01400134 	movhi	r5,4
 82207d4:	29742404 	addi	r5,r5,-12144
 82207d8:	e13ff917 	ldw	r4,-28(fp)
 82207dc:	822238c0 	call	822238c <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 82207e0:	01400134 	movhi	r5,4
 82207e4:	29742404 	addi	r5,r5,-12144
 82207e8:	e13ff917 	ldw	r4,-28(fp)
 82207ec:	82225480 	call	8222548 <alt_tse_phy_check_link>
 82207f0:	10bfffd8 	cmpnei	r2,r2,-1
 82207f4:	1000491e 	bne	r2,zero,822091c <getPHYSpeed+0x6a8>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82207f8:	00800044 	movi	r2,1
 82207fc:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220800:	00800044 	movi	r2,1
 8220804:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 8220808:	e0bff743 	ldbu	r2,-35(fp)
 822080c:	10c0004c 	andi	r3,r2,1
 8220810:	e0bff703 	ldbu	r2,-36(fp)
 8220814:	10800098 	cmpnei	r2,r2,2
 8220818:	1000021e 	bne	r2,zero,8220824 <getPHYSpeed+0x5b0>
 822081c:	00800084 	movi	r2,2
 8220820:	00000106 	br	8220828 <getPHYSpeed+0x5b4>
 8220824:	0005883a 	mov	r2,zero
 8220828:	1886b03a 	or	r3,r3,r2
 822082c:	e0bff703 	ldbu	r2,-36(fp)
 8220830:	10800058 	cmpnei	r2,r2,1
 8220834:	1000021e 	bne	r2,zero,8220840 <getPHYSpeed+0x5cc>
 8220838:	00800104 	movi	r2,4
 822083c:	00000106 	br	8220844 <getPHYSpeed+0x5d0>
 8220840:	0005883a 	mov	r2,zero
 8220844:	1886b03a 	or	r3,r3,r2
 8220848:	e0bff703 	ldbu	r2,-36(fp)
 822084c:	1000021e 	bne	r2,zero,8220858 <getPHYSpeed+0x5e4>
 8220850:	00800204 	movi	r2,8
 8220854:	00000106 	br	822085c <getPHYSpeed+0x5e8>
 8220858:	0005883a 	mov	r2,zero
 822085c:	1886b03a 	or	r3,r3,r2
 8220860:	e0bff703 	ldbu	r2,-36(fp)
 8220864:	108000d8 	cmpnei	r2,r2,3
 8220868:	1000021e 	bne	r2,zero,8220874 <getPHYSpeed+0x600>
 822086c:	00800074 	movhi	r2,1
 8220870:	00000106 	br	8220878 <getPHYSpeed+0x604>
 8220874:	0005883a 	mov	r2,zero
 8220878:	1884b03a 	or	r2,r3,r2
 822087c:	10800234 	orhi	r2,r2,8
 8220880:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220884:	e13ffd47 	ldb	r4,-11(fp)
 8220888:	e17ffd07 	ldb	r5,-12(fp)
 822088c:	e0bff703 	ldbu	r2,-36(fp)
 8220890:	108000a0 	cmpeqi	r2,r2,2
 8220894:	10000e1e 	bne	r2,zero,82208d0 <getPHYSpeed+0x65c>
 8220898:	e0bff703 	ldbu	r2,-36(fp)
 822089c:	10800060 	cmpeqi	r2,r2,1
 82208a0:	1000081e 	bne	r2,zero,82208c4 <getPHYSpeed+0x650>
 82208a4:	e0bff703 	ldbu	r2,-36(fp)
 82208a8:	1000031e 	bne	r2,zero,82208b8 <getPHYSpeed+0x644>
 82208ac:	00820974 	movhi	r2,2085
 82208b0:	10b78004 	addi	r2,r2,-8704
 82208b4:	00000806 	br	82208d8 <getPHYSpeed+0x664>
 82208b8:	00820974 	movhi	r2,2085
 82208bc:	10b78104 	addi	r2,r2,-8700
 82208c0:	00000506 	br	82208d8 <getPHYSpeed+0x664>
 82208c4:	00820974 	movhi	r2,2085
 82208c8:	10b78304 	addi	r2,r2,-8692
 82208cc:	00000206 	br	82208d8 <getPHYSpeed+0x664>
 82208d0:	00820974 	movhi	r2,2085
 82208d4:	10b78404 	addi	r2,r2,-8688
 82208d8:	e0fff743 	ldbu	r3,-35(fp)
 82208dc:	18c00058 	cmpnei	r3,r3,1
 82208e0:	1800031e 	bne	r3,zero,82208f0 <getPHYSpeed+0x67c>
 82208e4:	00c20974 	movhi	r3,2085
 82208e8:	18f78604 	addi	r3,r3,-8680
 82208ec:	00000206 	br	82208f8 <getPHYSpeed+0x684>
 82208f0:	00c20974 	movhi	r3,2085
 82208f4:	18f78804 	addi	r3,r3,-8672
 82208f8:	d8c00015 	stw	r3,0(sp)
 82208fc:	100f883a 	mov	r7,r2
 8220900:	280d883a 	mov	r6,r5
 8220904:	200b883a 	mov	r5,r4
 8220908:	01020974 	movhi	r4,2085
 822090c:	2137e804 	addi	r4,r4,-8288
 8220910:	8202e9c0 	call	8202e9c <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 8220914:	e0bff817 	ldw	r2,-32(fp)
 8220918:	0000f306 	br	8220ce8 <getPHYSpeed+0xa74>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 822091c:	e0bffe17 	ldw	r2,-8(fp)
 8220920:	10801004 	addi	r2,r2,64
 8220924:	e0fff917 	ldw	r3,-28(fp)
 8220928:	18c00003 	ldbu	r3,0(r3)
 822092c:	18c03fcc 	andi	r3,r3,255
 8220930:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8220934:	d8000015 	stw	zero,0(sp)
 8220938:	01c00044 	movi	r7,1
 822093c:	01800384 	movi	r6,14
 8220940:	000b883a 	mov	r5,zero
 8220944:	e13ff917 	ldw	r4,-28(fp)
 8220948:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 822094c:	e0bff917 	ldw	r2,-28(fp)
 8220950:	10800517 	ldw	r2,20(r2)
 8220954:	10002b1e 	bne	r2,zero,8220a04 <getPHYSpeed+0x790>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 8220958:	e0bffd47 	ldb	r2,-11(fp)
 822095c:	e0fffd07 	ldb	r3,-12(fp)
 8220960:	180d883a 	mov	r6,r3
 8220964:	100b883a 	mov	r5,r2
 8220968:	01020974 	movhi	r4,2085
 822096c:	2137fc04 	addi	r4,r4,-8208
 8220970:	8202e9c0 	call	8202e9c <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220974:	00800044 	movi	r2,1
 8220978:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 822097c:	00800044 	movi	r2,1
 8220980:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 8220984:	e0bff743 	ldbu	r2,-35(fp)
 8220988:	10c0004c 	andi	r3,r2,1
 822098c:	e0bff703 	ldbu	r2,-36(fp)
 8220990:	10800098 	cmpnei	r2,r2,2
 8220994:	1000021e 	bne	r2,zero,82209a0 <getPHYSpeed+0x72c>
 8220998:	00800084 	movi	r2,2
 822099c:	00000106 	br	82209a4 <getPHYSpeed+0x730>
 82209a0:	0005883a 	mov	r2,zero
 82209a4:	1886b03a 	or	r3,r3,r2
 82209a8:	e0bff703 	ldbu	r2,-36(fp)
 82209ac:	10800058 	cmpnei	r2,r2,1
 82209b0:	1000021e 	bne	r2,zero,82209bc <getPHYSpeed+0x748>
 82209b4:	00800104 	movi	r2,4
 82209b8:	00000106 	br	82209c0 <getPHYSpeed+0x74c>
 82209bc:	0005883a 	mov	r2,zero
 82209c0:	1886b03a 	or	r3,r3,r2
 82209c4:	e0bff703 	ldbu	r2,-36(fp)
 82209c8:	1000021e 	bne	r2,zero,82209d4 <getPHYSpeed+0x760>
 82209cc:	00800204 	movi	r2,8
 82209d0:	00000106 	br	82209d8 <getPHYSpeed+0x764>
 82209d4:	0005883a 	mov	r2,zero
 82209d8:	1886b03a 	or	r3,r3,r2
 82209dc:	e0bff703 	ldbu	r2,-36(fp)
 82209e0:	108000d8 	cmpnei	r2,r2,3
 82209e4:	1000021e 	bne	r2,zero,82209f0 <getPHYSpeed+0x77c>
 82209e8:	00800074 	movhi	r2,1
 82209ec:	00000106 	br	82209f4 <getPHYSpeed+0x780>
 82209f0:	0005883a 	mov	r2,zero
 82209f4:	1884b03a 	or	r2,r3,r2
 82209f8:	10800134 	orhi	r2,r2,4
 82209fc:	e0bff815 	stw	r2,-32(fp)
 8220a00:	00009406 	br	8220c54 <getPHYSpeed+0x9e0>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 8220a04:	e0bff917 	ldw	r2,-28(fp)
 8220a08:	10800517 	ldw	r2,20(r2)
 8220a0c:	10801817 	ldw	r2,96(r2)
 8220a10:	10002626 	beq	r2,zero,8220aac <getPHYSpeed+0x838>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 8220a14:	e0bff917 	ldw	r2,-28(fp)
 8220a18:	10800517 	ldw	r2,20(r2)
 8220a1c:	10801817 	ldw	r2,96(r2)
 8220a20:	e13ffe17 	ldw	r4,-8(fp)
 8220a24:	103ee83a 	callr	r2
 8220a28:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220a2c:	e0bff817 	ldw	r2,-32(fp)
 8220a30:	1080008c 	andi	r2,r2,2
 8220a34:	10000c1e 	bne	r2,zero,8220a68 <getPHYSpeed+0x7f4>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 8220a38:	e0bff817 	ldw	r2,-32(fp)
 8220a3c:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220a40:	1000071e 	bne	r2,zero,8220a60 <getPHYSpeed+0x7ec>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 8220a44:	e0bff817 	ldw	r2,-32(fp)
 8220a48:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220a4c:	10000226 	beq	r2,zero,8220a58 <getPHYSpeed+0x7e4>
 8220a50:	0005883a 	mov	r2,zero
 8220a54:	00000506 	br	8220a6c <getPHYSpeed+0x7f8>
 8220a58:	008000c4 	movi	r2,3
 8220a5c:	00000306 	br	8220a6c <getPHYSpeed+0x7f8>
 8220a60:	00800044 	movi	r2,1
 8220a64:	00000106 	br	8220a6c <getPHYSpeed+0x7f8>
 8220a68:	00800084 	movi	r2,2
 8220a6c:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 8220a70:	e0bff817 	ldw	r2,-32(fp)
 8220a74:	1080004c 	andi	r2,r2,1
 8220a78:	1004c03a 	cmpne	r2,r2,zero
 8220a7c:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 8220a80:	e0bff817 	ldw	r2,-32(fp)
 8220a84:	1080006c 	andhi	r2,r2,1
 8220a88:	10007226 	beq	r2,zero,8220c54 <getPHYSpeed+0x9e0>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 8220a8c:	e0bffd47 	ldb	r2,-11(fp)
 8220a90:	e0fffd07 	ldb	r3,-12(fp)
 8220a94:	180d883a 	mov	r6,r3
 8220a98:	100b883a 	mov	r5,r2
 8220a9c:	01020974 	movhi	r4,2085
 8220aa0:	21380a04 	addi	r4,r4,-8152
 8220aa4:	8202e9c0 	call	8202e9c <printf>
 8220aa8:	00006a06 	br	8220c54 <getPHYSpeed+0x9e0>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 8220aac:	e0bff917 	ldw	r2,-28(fp)
 8220ab0:	10800517 	ldw	r2,20(r2)
 8220ab4:	10801583 	ldbu	r2,86(r2)
 8220ab8:	10803fcc 	andi	r2,r2,255
 8220abc:	10002b1e 	bne	r2,zero,8220b6c <getPHYSpeed+0x8f8>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 8220ac0:	e0bffd47 	ldb	r2,-11(fp)
 8220ac4:	e0fffd07 	ldb	r3,-12(fp)
 8220ac8:	180d883a 	mov	r6,r3
 8220acc:	100b883a 	mov	r5,r2
 8220ad0:	01020974 	movhi	r4,2085
 8220ad4:	21381704 	addi	r4,r4,-8100
 8220ad8:	8202e9c0 	call	8202e9c <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220adc:	00800044 	movi	r2,1
 8220ae0:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220ae4:	00800044 	movi	r2,1
 8220ae8:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 8220aec:	e0bff743 	ldbu	r2,-35(fp)
 8220af0:	10c0004c 	andi	r3,r2,1
 8220af4:	e0bff703 	ldbu	r2,-36(fp)
 8220af8:	10800098 	cmpnei	r2,r2,2
 8220afc:	1000021e 	bne	r2,zero,8220b08 <getPHYSpeed+0x894>
 8220b00:	00800084 	movi	r2,2
 8220b04:	00000106 	br	8220b0c <getPHYSpeed+0x898>
 8220b08:	0005883a 	mov	r2,zero
 8220b0c:	1886b03a 	or	r3,r3,r2
 8220b10:	e0bff703 	ldbu	r2,-36(fp)
 8220b14:	10800058 	cmpnei	r2,r2,1
 8220b18:	1000021e 	bne	r2,zero,8220b24 <getPHYSpeed+0x8b0>
 8220b1c:	00800104 	movi	r2,4
 8220b20:	00000106 	br	8220b28 <getPHYSpeed+0x8b4>
 8220b24:	0005883a 	mov	r2,zero
 8220b28:	1886b03a 	or	r3,r3,r2
 8220b2c:	e0bff703 	ldbu	r2,-36(fp)
 8220b30:	1000021e 	bne	r2,zero,8220b3c <getPHYSpeed+0x8c8>
 8220b34:	00800204 	movi	r2,8
 8220b38:	00000106 	br	8220b40 <getPHYSpeed+0x8cc>
 8220b3c:	0005883a 	mov	r2,zero
 8220b40:	1886b03a 	or	r3,r3,r2
 8220b44:	e0bff703 	ldbu	r2,-36(fp)
 8220b48:	108000d8 	cmpnei	r2,r2,3
 8220b4c:	1000021e 	bne	r2,zero,8220b58 <getPHYSpeed+0x8e4>
 8220b50:	00800074 	movhi	r2,1
 8220b54:	00000106 	br	8220b5c <getPHYSpeed+0x8e8>
 8220b58:	0005883a 	mov	r2,zero
 8220b5c:	1884b03a 	or	r2,r3,r2
 8220b60:	108000b4 	orhi	r2,r2,2
 8220b64:	e0bff815 	stw	r2,-32(fp)
 8220b68:	00003a06 	br	8220c54 <getPHYSpeed+0x9e0>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8220b6c:	e0bff917 	ldw	r2,-28(fp)
 8220b70:	10800517 	ldw	r2,20(r2)
 8220b74:	10801583 	ldbu	r2,86(r2)
 8220b78:	10c03fcc 	andi	r3,r2,255
 8220b7c:	e0bff917 	ldw	r2,-28(fp)
 8220b80:	10800517 	ldw	r2,20(r2)
 8220b84:	108015c3 	ldbu	r2,87(r2)
 8220b88:	10803fcc 	andi	r2,r2,255
 8220b8c:	01c00084 	movi	r7,2
 8220b90:	100d883a 	mov	r6,r2
 8220b94:	180b883a 	mov	r5,r3
 8220b98:	e13ff917 	ldw	r4,-28(fp)
 8220b9c:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8220ba0:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8220ba4:	e0bff917 	ldw	r2,-28(fp)
 8220ba8:	10800517 	ldw	r2,20(r2)
 8220bac:	10801583 	ldbu	r2,86(r2)
 8220bb0:	10c03fcc 	andi	r3,r2,255
 8220bb4:	e0bff917 	ldw	r2,-28(fp)
 8220bb8:	10800517 	ldw	r2,20(r2)
 8220bbc:	10801603 	ldbu	r2,88(r2)
 8220bc0:	10803fcc 	andi	r2,r2,255
 8220bc4:	01c00044 	movi	r7,1
 8220bc8:	100d883a 	mov	r6,r2
 8220bcc:	180b883a 	mov	r5,r3
 8220bd0:	e13ff917 	ldw	r4,-28(fp)
 8220bd4:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8220bd8:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8220bdc:	e0bff743 	ldbu	r2,-35(fp)
 8220be0:	10c0004c 	andi	r3,r2,1
 8220be4:	e0bff703 	ldbu	r2,-36(fp)
 8220be8:	10800098 	cmpnei	r2,r2,2
 8220bec:	1000021e 	bne	r2,zero,8220bf8 <getPHYSpeed+0x984>
 8220bf0:	00800084 	movi	r2,2
 8220bf4:	00000106 	br	8220bfc <getPHYSpeed+0x988>
 8220bf8:	0005883a 	mov	r2,zero
 8220bfc:	1886b03a 	or	r3,r3,r2
 8220c00:	e0bff703 	ldbu	r2,-36(fp)
 8220c04:	10800058 	cmpnei	r2,r2,1
 8220c08:	1000021e 	bne	r2,zero,8220c14 <getPHYSpeed+0x9a0>
 8220c0c:	00800104 	movi	r2,4
 8220c10:	00000106 	br	8220c18 <getPHYSpeed+0x9a4>
 8220c14:	0005883a 	mov	r2,zero
 8220c18:	1886b03a 	or	r3,r3,r2
 8220c1c:	e0bff703 	ldbu	r2,-36(fp)
 8220c20:	1000021e 	bne	r2,zero,8220c2c <getPHYSpeed+0x9b8>
 8220c24:	00800204 	movi	r2,8
 8220c28:	00000106 	br	8220c30 <getPHYSpeed+0x9bc>
 8220c2c:	0005883a 	mov	r2,zero
 8220c30:	1886b03a 	or	r3,r3,r2
 8220c34:	e0bff703 	ldbu	r2,-36(fp)
 8220c38:	108000d8 	cmpnei	r2,r2,3
 8220c3c:	1000021e 	bne	r2,zero,8220c48 <getPHYSpeed+0x9d4>
 8220c40:	00800074 	movhi	r2,1
 8220c44:	00000106 	br	8220c4c <getPHYSpeed+0x9d8>
 8220c48:	0005883a 	mov	r2,zero
 8220c4c:	1884b03a 	or	r2,r3,r2
 8220c50:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220c54:	e13ffd47 	ldb	r4,-11(fp)
 8220c58:	e17ffd07 	ldb	r5,-12(fp)
 8220c5c:	e0bff703 	ldbu	r2,-36(fp)
 8220c60:	108000a0 	cmpeqi	r2,r2,2
 8220c64:	10000e1e 	bne	r2,zero,8220ca0 <getPHYSpeed+0xa2c>
 8220c68:	e0bff703 	ldbu	r2,-36(fp)
 8220c6c:	10800060 	cmpeqi	r2,r2,1
 8220c70:	1000081e 	bne	r2,zero,8220c94 <getPHYSpeed+0xa20>
 8220c74:	e0bff703 	ldbu	r2,-36(fp)
 8220c78:	1000031e 	bne	r2,zero,8220c88 <getPHYSpeed+0xa14>
 8220c7c:	00820974 	movhi	r2,2085
 8220c80:	10b78004 	addi	r2,r2,-8704
 8220c84:	00000806 	br	8220ca8 <getPHYSpeed+0xa34>
 8220c88:	00820974 	movhi	r2,2085
 8220c8c:	10b78104 	addi	r2,r2,-8700
 8220c90:	00000506 	br	8220ca8 <getPHYSpeed+0xa34>
 8220c94:	00820974 	movhi	r2,2085
 8220c98:	10b78304 	addi	r2,r2,-8692
 8220c9c:	00000206 	br	8220ca8 <getPHYSpeed+0xa34>
 8220ca0:	00820974 	movhi	r2,2085
 8220ca4:	10b78404 	addi	r2,r2,-8688
 8220ca8:	e0fff743 	ldbu	r3,-35(fp)
 8220cac:	18c00058 	cmpnei	r3,r3,1
 8220cb0:	1800031e 	bne	r3,zero,8220cc0 <getPHYSpeed+0xa4c>
 8220cb4:	00c20974 	movhi	r3,2085
 8220cb8:	18f78604 	addi	r3,r3,-8680
 8220cbc:	00000206 	br	8220cc8 <getPHYSpeed+0xa54>
 8220cc0:	00c20974 	movhi	r3,2085
 8220cc4:	18f78804 	addi	r3,r3,-8672
 8220cc8:	d8c00015 	stw	r3,0(sp)
 8220ccc:	100f883a 	mov	r7,r2
 8220cd0:	280d883a 	mov	r6,r5
 8220cd4:	200b883a 	mov	r5,r4
 8220cd8:	01020974 	movhi	r4,2085
 8220cdc:	21382e04 	addi	r4,r4,-8008
 8220ce0:	8202e9c0 	call	8202e9c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 8220ce4:	e0bff817 	ldw	r2,-32(fp)
}
 8220ce8:	e037883a 	mov	sp,fp
 8220cec:	dfc00117 	ldw	ra,4(sp)
 8220cf0:	df000017 	ldw	fp,0(sp)
 8220cf4:	dec00204 	addi	sp,sp,8
 8220cf8:	f800283a 	ret

08220cfc <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 8220cfc:	defffd04 	addi	sp,sp,-12
 8220d00:	df000215 	stw	fp,8(sp)
 8220d04:	df000204 	addi	fp,sp,8
 8220d08:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220d0c:	e0bfff17 	ldw	r2,-4(fp)
 8220d10:	10800617 	ldw	r2,24(r2)
 8220d14:	10800317 	ldw	r2,12(r2)
 8220d18:	10800117 	ldw	r2,4(r2)
 8220d1c:	10800217 	ldw	r2,8(r2)
 8220d20:	10800017 	ldw	r2,0(r2)
 8220d24:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8220d28:	e0bffe17 	ldw	r2,-8(fp)
 8220d2c:	10801004 	addi	r2,r2,64
 8220d30:	10800037 	ldwio	r2,0(r2)
}
 8220d34:	e037883a 	mov	sp,fp
 8220d38:	df000017 	ldw	fp,0(sp)
 8220d3c:	dec00104 	addi	sp,sp,4
 8220d40:	f800283a 	ret

08220d44 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 8220d44:	defffc04 	addi	sp,sp,-16
 8220d48:	df000315 	stw	fp,12(sp)
 8220d4c:	df000304 	addi	fp,sp,12
 8220d50:	e13ffe15 	stw	r4,-8(fp)
 8220d54:	2805883a 	mov	r2,r5
 8220d58:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220d5c:	e0bffe17 	ldw	r2,-8(fp)
 8220d60:	10800617 	ldw	r2,24(r2)
 8220d64:	10800317 	ldw	r2,12(r2)
 8220d68:	10800117 	ldw	r2,4(r2)
 8220d6c:	10800217 	ldw	r2,8(r2)
 8220d70:	10800017 	ldw	r2,0(r2)
 8220d74:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 8220d78:	e0bffd17 	ldw	r2,-12(fp)
 8220d7c:	10801004 	addi	r2,r2,64
 8220d80:	e0ffff03 	ldbu	r3,-4(fp)
 8220d84:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 8220d88:	0005883a 	mov	r2,zero
}
 8220d8c:	e037883a 	mov	sp,fp
 8220d90:	df000017 	ldw	fp,0(sp)
 8220d94:	dec00104 	addi	sp,sp,4
 8220d98:	f800283a 	ret

08220d9c <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 8220d9c:	defff604 	addi	sp,sp,-40
 8220da0:	df000915 	stw	fp,36(sp)
 8220da4:	df000904 	addi	fp,sp,36
 8220da8:	e13ffb15 	stw	r4,-20(fp)
 8220dac:	3009883a 	mov	r4,r6
 8220db0:	3807883a 	mov	r3,r7
 8220db4:	e0800117 	ldw	r2,4(fp)
 8220db8:	e17ffc05 	stb	r5,-16(fp)
 8220dbc:	e13ffd05 	stb	r4,-12(fp)
 8220dc0:	e0fffe05 	stb	r3,-8(fp)
 8220dc4:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220dc8:	e0bffb17 	ldw	r2,-20(fp)
 8220dcc:	10800617 	ldw	r2,24(r2)
 8220dd0:	10800317 	ldw	r2,12(r2)
 8220dd4:	10800117 	ldw	r2,4(r2)
 8220dd8:	10800217 	ldw	r2,8(r2)
 8220ddc:	10800017 	ldw	r2,0(r2)
 8220de0:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 8220de4:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8220de8:	e03ff815 	stw	zero,-32(fp)
 8220dec:	00000906 	br	8220e14 <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 8220df0:	e0bff70b 	ldhu	r2,-36(fp)
 8220df4:	1085883a 	add	r2,r2,r2
 8220df8:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 8220dfc:	e0bff70b 	ldhu	r2,-36(fp)
 8220e00:	10800054 	ori	r2,r2,1
 8220e04:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8220e08:	e0bff817 	ldw	r2,-32(fp)
 8220e0c:	10800044 	addi	r2,r2,1
 8220e10:	e0bff815 	stw	r2,-32(fp)
 8220e14:	e0bffe03 	ldbu	r2,-8(fp)
 8220e18:	e0fff817 	ldw	r3,-32(fp)
 8220e1c:	18bff416 	blt	r3,r2,8220df0 <alt_tse_phy_wr_mdio_reg+0x54>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 8220e20:	e0fff70b 	ldhu	r3,-36(fp)
 8220e24:	e0bffd03 	ldbu	r2,-12(fp)
 8220e28:	1884983a 	sll	r2,r3,r2
 8220e2c:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 8220e30:	e0bff917 	ldw	r2,-28(fp)
 8220e34:	10c0a004 	addi	r3,r2,640
 8220e38:	e0bffc03 	ldbu	r2,-16(fp)
 8220e3c:	1085883a 	add	r2,r2,r2
 8220e40:	1085883a 	add	r2,r2,r2
 8220e44:	1885883a 	add	r2,r3,r2
 8220e48:	10800037 	ldwio	r2,0(r2)
 8220e4c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 8220e50:	e0bff70b 	ldhu	r2,-36(fp)
 8220e54:	0084303a 	nor	r2,zero,r2
 8220e58:	1007883a 	mov	r3,r2
 8220e5c:	e0bffa0b 	ldhu	r2,-24(fp)
 8220e60:	1884703a 	and	r2,r3,r2
 8220e64:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 8220e68:	e0ffff0b 	ldhu	r3,-4(fp)
 8220e6c:	e0bffd03 	ldbu	r2,-12(fp)
 8220e70:	1884983a 	sll	r2,r3,r2
 8220e74:	1007883a 	mov	r3,r2
 8220e78:	e0bff70b 	ldhu	r2,-36(fp)
 8220e7c:	1884703a 	and	r2,r3,r2
 8220e80:	1007883a 	mov	r3,r2
 8220e84:	e0bffa0b 	ldhu	r2,-24(fp)
 8220e88:	1884b03a 	or	r2,r3,r2
 8220e8c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 8220e90:	e0bff917 	ldw	r2,-28(fp)
 8220e94:	10c0a004 	addi	r3,r2,640
 8220e98:	e0bffc03 	ldbu	r2,-16(fp)
 8220e9c:	1085883a 	add	r2,r2,r2
 8220ea0:	1085883a 	add	r2,r2,r2
 8220ea4:	1885883a 	add	r2,r3,r2
 8220ea8:	e0fffa0b 	ldhu	r3,-24(fp)
 8220eac:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 8220eb0:	0005883a 	mov	r2,zero
    
}
 8220eb4:	e037883a 	mov	sp,fp
 8220eb8:	df000017 	ldw	fp,0(sp)
 8220ebc:	dec00104 	addi	sp,sp,4
 8220ec0:	f800283a 	ret

08220ec4 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 8220ec4:	defff704 	addi	sp,sp,-36
 8220ec8:	df000815 	stw	fp,32(sp)
 8220ecc:	df000804 	addi	fp,sp,32
 8220ed0:	e13ffc15 	stw	r4,-16(fp)
 8220ed4:	2809883a 	mov	r4,r5
 8220ed8:	3007883a 	mov	r3,r6
 8220edc:	3805883a 	mov	r2,r7
 8220ee0:	e13ffd05 	stb	r4,-12(fp)
 8220ee4:	e0fffe05 	stb	r3,-8(fp)
 8220ee8:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220eec:	e0bffc17 	ldw	r2,-16(fp)
 8220ef0:	10800617 	ldw	r2,24(r2)
 8220ef4:	10800317 	ldw	r2,12(r2)
 8220ef8:	10800117 	ldw	r2,4(r2)
 8220efc:	10800217 	ldw	r2,8(r2)
 8220f00:	10800017 	ldw	r2,0(r2)
 8220f04:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 8220f08:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8220f0c:	e03ff915 	stw	zero,-28(fp)
 8220f10:	00000906 	br	8220f38 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 8220f14:	e0bff817 	ldw	r2,-32(fp)
 8220f18:	1085883a 	add	r2,r2,r2
 8220f1c:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 8220f20:	e0bff817 	ldw	r2,-32(fp)
 8220f24:	10800054 	ori	r2,r2,1
 8220f28:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8220f2c:	e0bff917 	ldw	r2,-28(fp)
 8220f30:	10800044 	addi	r2,r2,1
 8220f34:	e0bff915 	stw	r2,-28(fp)
 8220f38:	e0bfff03 	ldbu	r2,-4(fp)
 8220f3c:	e0fff917 	ldw	r3,-28(fp)
 8220f40:	18bff416 	blt	r3,r2,8220f14 <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 8220f44:	e0bffa17 	ldw	r2,-24(fp)
 8220f48:	10c0a004 	addi	r3,r2,640
 8220f4c:	e0bffd03 	ldbu	r2,-12(fp)
 8220f50:	1085883a 	add	r2,r2,r2
 8220f54:	1085883a 	add	r2,r2,r2
 8220f58:	1885883a 	add	r2,r3,r2
 8220f5c:	10800037 	ldwio	r2,0(r2)
 8220f60:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 8220f64:	e0fffb0b 	ldhu	r3,-20(fp)
 8220f68:	e0bffe03 	ldbu	r2,-8(fp)
 8220f6c:	1885d83a 	sra	r2,r3,r2
 8220f70:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 8220f74:	e0fffb0b 	ldhu	r3,-20(fp)
 8220f78:	e0bff817 	ldw	r2,-32(fp)
 8220f7c:	1884703a 	and	r2,r3,r2
}
 8220f80:	e037883a 	mov	sp,fp
 8220f84:	df000017 	ldw	fp,0(sp)
 8220f88:	dec00104 	addi	sp,sp,4
 8220f8c:	f800283a 	ret

08220f90 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 8220f90:	deff9a04 	addi	sp,sp,-408
 8220f94:	dfc06515 	stw	ra,404(sp)
 8220f98:	df006415 	stw	fp,400(sp)
 8220f9c:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 8220fa0:	e0ff9c04 	addi	r3,fp,-400
 8220fa4:	00801904 	movi	r2,100
 8220fa8:	100d883a 	mov	r6,r2
 8220fac:	000b883a 	mov	r5,zero
 8220fb0:	1809883a 	mov	r4,r3
 8220fb4:	8202cb00 	call	8202cb0 <memset>
 8220fb8:	009d9cb4 	movhi	r2,30322
 8220fbc:	10985344 	addi	r2,r2,24909
 8220fc0:	e0bf9c15 	stw	r2,-400(fp)
 8220fc4:	00881b34 	movhi	r2,8300
 8220fc8:	109b1944 	addi	r2,r2,27749
 8220fcc:	e0bf9d15 	stw	r2,-396(fp)
 8220fd0:	008c5174 	movhi	r2,12613
 8220fd4:	108e0e04 	addi	r2,r2,14392
 8220fd8:	e0bf9e15 	stw	r2,-392(fp)
 8220fdc:	00800c74 	movhi	r2,49
 8220fe0:	108c4c44 	addi	r2,r2,12593
 8220fe4:	e0bf9f15 	stw	r2,-388(fp)
 8220fe8:	e0bfa004 	addi	r2,fp,-384
 8220fec:	00c01004 	movi	r3,64
 8220ff0:	180d883a 	mov	r6,r3
 8220ff4:	000b883a 	mov	r5,zero
 8220ff8:	1009883a 	mov	r4,r2
 8220ffc:	8202cb00 	call	8202cb0 <memset>
 8221000:	009410c4 	movi	r2,20547
 8221004:	e0bfb015 	stw	r2,-320(fp)
 8221008:	00800304 	movi	r2,12
 822100c:	e0bfb105 	stb	r2,-316(fp)
 8221010:	00800084 	movi	r2,2
 8221014:	e0bfb145 	stb	r2,-315(fp)
 8221018:	00800444 	movi	r2,17
 822101c:	e0bfb185 	stb	r2,-314(fp)
 8221020:	00800384 	movi	r2,14
 8221024:	e0bfb1c5 	stb	r2,-313(fp)
 8221028:	00800344 	movi	r2,13
 822102c:	e0bfb205 	stb	r2,-312(fp)
 8221030:	00800284 	movi	r2,10
 8221034:	e0bfb245 	stb	r2,-311(fp)
 8221038:	008208b4 	movhi	r2,2082
 822103c:	108e7804 	addi	r2,r2,14816
 8221040:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 8221044:	e0bfb504 	addi	r2,fp,-300
 8221048:	00c01904 	movi	r3,100
 822104c:	180d883a 	mov	r6,r3
 8221050:	000b883a 	mov	r5,zero
 8221054:	1009883a 	mov	r4,r2
 8221058:	8202cb00 	call	8202cb0 <memset>
 822105c:	009d9cb4 	movhi	r2,30322
 8221060:	10985344 	addi	r2,r2,24909
 8221064:	e0bfb515 	stw	r2,-300(fp)
 8221068:	00881b34 	movhi	r2,8300
 822106c:	109b1944 	addi	r2,r2,27749
 8221070:	e0bfb615 	stw	r2,-296(fp)
 8221074:	00991874 	movhi	r2,25697
 8221078:	109d5444 	addi	r2,r2,30033
 822107c:	e0bfb715 	stw	r2,-292(fp)
 8221080:	00965234 	movhi	r2,22856
 8221084:	10940804 	addi	r2,r2,20512
 8221088:	e0bfb815 	stw	r2,-288(fp)
 822108c:	00914e34 	movhi	r2,17720
 8221090:	108e0804 	addi	r2,r2,14368
 8221094:	e0bfb915 	stw	r2,-284(fp)
 8221098:	008d4d34 	movhi	r2,13620
 822109c:	108c4c44 	addi	r2,r2,12593
 82210a0:	e0bfba15 	stw	r2,-280(fp)
 82210a4:	e03fbb15 	stw	zero,-276(fp)
 82210a8:	e03fbc15 	stw	zero,-272(fp)
 82210ac:	e03fbd15 	stw	zero,-268(fp)
 82210b0:	e03fbe15 	stw	zero,-264(fp)
 82210b4:	e03fbf15 	stw	zero,-260(fp)
 82210b8:	e03fc015 	stw	zero,-256(fp)
 82210bc:	e03fc115 	stw	zero,-252(fp)
 82210c0:	e03fc215 	stw	zero,-248(fp)
 82210c4:	e03fc315 	stw	zero,-244(fp)
 82210c8:	e03fc415 	stw	zero,-240(fp)
 82210cc:	e03fc515 	stw	zero,-236(fp)
 82210d0:	e03fc615 	stw	zero,-232(fp)
 82210d4:	e03fc715 	stw	zero,-228(fp)
 82210d8:	e03fc815 	stw	zero,-224(fp)
 82210dc:	009410c4 	movi	r2,20547
 82210e0:	e0bfc915 	stw	r2,-220(fp)
 82210e4:	00800344 	movi	r2,13
 82210e8:	e0bfca05 	stb	r2,-216(fp)
 82210ec:	00800084 	movi	r2,2
 82210f0:	e0bfca45 	stb	r2,-215(fp)
 82210f4:	00800444 	movi	r2,17
 82210f8:	e0bfca85 	stb	r2,-214(fp)
 82210fc:	00800384 	movi	r2,14
 8221100:	e0bfcac5 	stb	r2,-213(fp)
 8221104:	00800344 	movi	r2,13
 8221108:	e0bfcb05 	stb	r2,-212(fp)
 822110c:	00800284 	movi	r2,10
 8221110:	e0bfcb45 	stb	r2,-211(fp)
 8221114:	008208b4 	movhi	r2,2082
 8221118:	108e7804 	addi	r2,r2,14816
 822111c:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 8221120:	e0bfce04 	addi	r2,fp,-200
 8221124:	00c01904 	movi	r3,100
 8221128:	180d883a 	mov	r6,r3
 822112c:	000b883a 	mov	r5,zero
 8221130:	1009883a 	mov	r4,r2
 8221134:	8202cb00 	call	8202cb0 <memset>
 8221138:	009a5d34 	movhi	r2,26996
 822113c:	10985384 	addi	r2,r2,24910
 8221140:	e0bfce15 	stw	r2,-200(fp)
 8221144:	009b1874 	movhi	r2,27745
 8221148:	109b9bc4 	addi	r2,r2,28271
 822114c:	e0bfcf15 	stw	r2,-196(fp)
 8221150:	008e1434 	movhi	r2,14416
 8221154:	10910804 	addi	r2,r2,17440
 8221158:	e0bfd015 	stw	r2,-192(fp)
 822115c:	008d4db4 	movhi	r2,13622
 8221160:	108e0cc4 	addi	r2,r2,14387
 8221164:	e0bfd115 	stw	r2,-188(fp)
 8221168:	e03fd215 	stw	zero,-184(fp)
 822116c:	e0bfd304 	addi	r2,fp,-180
 8221170:	00c00f04 	movi	r3,60
 8221174:	180d883a 	mov	r6,r3
 8221178:	000b883a 	mov	r5,zero
 822117c:	1009883a 	mov	r4,r2
 8221180:	8202cb00 	call	8202cb0 <memset>
 8221184:	00800234 	movhi	r2,8
 8221188:	108005c4 	addi	r2,r2,23
 822118c:	e0bfe215 	stw	r2,-120(fp)
 8221190:	008001c4 	movi	r2,7
 8221194:	e0bfe305 	stb	r2,-116(fp)
 8221198:	00800284 	movi	r2,10
 822119c:	e0bfe345 	stb	r2,-115(fp)
 82211a0:	00800444 	movi	r2,17
 82211a4:	e0bfe385 	stb	r2,-114(fp)
 82211a8:	008000c4 	movi	r2,3
 82211ac:	e0bfe3c5 	stb	r2,-113(fp)
 82211b0:	00800044 	movi	r2,1
 82211b4:	e0bfe405 	stb	r2,-112(fp)
 82211b8:	00800084 	movi	r2,2
 82211bc:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 82211c0:	00820974 	movhi	r2,2085
 82211c4:	10b83a04 	addi	r2,r2,-7960
 82211c8:	e0ffe704 	addi	r3,fp,-100
 82211cc:	1009883a 	mov	r4,r2
 82211d0:	00801904 	movi	r2,100
 82211d4:	100d883a 	mov	r6,r2
 82211d8:	200b883a 	mov	r5,r4
 82211dc:	1809883a 	mov	r4,r3
 82211e0:	8202a0c0 	call	8202a0c <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 82211e4:	e13f9c04 	addi	r4,fp,-400
 82211e8:	821f1000 	call	821f100 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 82211ec:	e0bfb504 	addi	r2,fp,-300
 82211f0:	1009883a 	mov	r4,r2
 82211f4:	821f1000 	call	821f100 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 82211f8:	e0bfce04 	addi	r2,fp,-200
 82211fc:	1009883a 	mov	r4,r2
 8221200:	821f1000 	call	821f100 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 8221204:	e0bfe704 	addi	r2,fp,-100
 8221208:	1009883a 	mov	r4,r2
 822120c:	821f1000 	call	821f100 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 8221210:	d0a07f03 	ldbu	r2,-32260(gp)
 8221214:	10803fcc 	andi	r2,r2,255
}
 8221218:	e037883a 	mov	sp,fp
 822121c:	dfc00117 	ldw	ra,4(sp)
 8221220:	df000017 	ldw	fp,0(sp)
 8221224:	dec00204 	addi	sp,sp,8
 8221228:	f800283a 	ret

0822122c <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 822122c:	defffd04 	addi	sp,sp,-12
 8221230:	dfc00215 	stw	ra,8(sp)
 8221234:	df000115 	stw	fp,4(sp)
 8221238:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 822123c:	d0a07f03 	ldbu	r2,-32260(gp)
 8221240:	10803fcc 	andi	r2,r2,255
 8221244:	100b883a 	mov	r5,r2
 8221248:	01020974 	movhi	r4,2085
 822124c:	21385304 	addi	r4,r4,-7860
 8221250:	821edb80 	call	821edb8 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 8221254:	e03fff05 	stb	zero,-4(fp)
 8221258:	00006d06 	br	8221410 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 822125c:	e0bfff07 	ldb	r2,-4(fp)
 8221260:	100b883a 	mov	r5,r2
 8221264:	01020974 	movhi	r4,2085
 8221268:	21386204 	addi	r4,r4,-7800
 822126c:	821edb80 	call	821edb8 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 8221270:	e0ffff07 	ldb	r3,-4(fp)
 8221274:	008209b4 	movhi	r2,2086
 8221278:	10b59104 	addi	r2,r2,-10684
 822127c:	18c7883a 	add	r3,r3,r3
 8221280:	18c7883a 	add	r3,r3,r3
 8221284:	10c5883a 	add	r2,r2,r3
 8221288:	10800017 	ldw	r2,0(r2)
 822128c:	100b883a 	mov	r5,r2
 8221290:	01020974 	movhi	r4,2085
 8221294:	21386704 	addi	r4,r4,-7780
 8221298:	821edb80 	call	821edb8 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 822129c:	e0ffff07 	ldb	r3,-4(fp)
 82212a0:	008209b4 	movhi	r2,2086
 82212a4:	10b59104 	addi	r2,r2,-10684
 82212a8:	18c7883a 	add	r3,r3,r3
 82212ac:	18c7883a 	add	r3,r3,r3
 82212b0:	10c5883a 	add	r2,r2,r3
 82212b4:	10800017 	ldw	r2,0(r2)
 82212b8:	10801417 	ldw	r2,80(r2)
 82212bc:	100b883a 	mov	r5,r2
 82212c0:	01020974 	movhi	r4,2085
 82212c4:	21386d04 	addi	r4,r4,-7756
 82212c8:	821edb80 	call	821edb8 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 82212cc:	e0ffff07 	ldb	r3,-4(fp)
 82212d0:	008209b4 	movhi	r2,2086
 82212d4:	10b59104 	addi	r2,r2,-10684
 82212d8:	18c7883a 	add	r3,r3,r3
 82212dc:	18c7883a 	add	r3,r3,r3
 82212e0:	10c5883a 	add	r2,r2,r3
 82212e4:	10800017 	ldw	r2,0(r2)
 82212e8:	10801503 	ldbu	r2,84(r2)
 82212ec:	10803fcc 	andi	r2,r2,255
 82212f0:	100b883a 	mov	r5,r2
 82212f4:	01020974 	movhi	r4,2085
 82212f8:	21387404 	addi	r4,r4,-7728
 82212fc:	821edb80 	call	821edb8 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 8221300:	e0ffff07 	ldb	r3,-4(fp)
 8221304:	008209b4 	movhi	r2,2086
 8221308:	10b59104 	addi	r2,r2,-10684
 822130c:	18c7883a 	add	r3,r3,r3
 8221310:	18c7883a 	add	r3,r3,r3
 8221314:	10c5883a 	add	r2,r2,r3
 8221318:	10800017 	ldw	r2,0(r2)
 822131c:	10801543 	ldbu	r2,85(r2)
 8221320:	10803fcc 	andi	r2,r2,255
 8221324:	100b883a 	mov	r5,r2
 8221328:	01020974 	movhi	r4,2085
 822132c:	21387b04 	addi	r4,r4,-7700
 8221330:	821edb80 	call	821edb8 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 8221334:	e0ffff07 	ldb	r3,-4(fp)
 8221338:	008209b4 	movhi	r2,2086
 822133c:	10b59104 	addi	r2,r2,-10684
 8221340:	18c7883a 	add	r3,r3,r3
 8221344:	18c7883a 	add	r3,r3,r3
 8221348:	10c5883a 	add	r2,r2,r3
 822134c:	10800017 	ldw	r2,0(r2)
 8221350:	10801583 	ldbu	r2,86(r2)
 8221354:	10803fcc 	andi	r2,r2,255
 8221358:	100b883a 	mov	r5,r2
 822135c:	01020974 	movhi	r4,2085
 8221360:	21388204 	addi	r4,r4,-7672
 8221364:	821edb80 	call	821edb8 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 8221368:	e0ffff07 	ldb	r3,-4(fp)
 822136c:	008209b4 	movhi	r2,2086
 8221370:	10b59104 	addi	r2,r2,-10684
 8221374:	18c7883a 	add	r3,r3,r3
 8221378:	18c7883a 	add	r3,r3,r3
 822137c:	10c5883a 	add	r2,r2,r3
 8221380:	10800017 	ldw	r2,0(r2)
 8221384:	108015c3 	ldbu	r2,87(r2)
 8221388:	10803fcc 	andi	r2,r2,255
 822138c:	100b883a 	mov	r5,r2
 8221390:	01020974 	movhi	r4,2085
 8221394:	21388904 	addi	r4,r4,-7644
 8221398:	821edb80 	call	821edb8 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 822139c:	e0ffff07 	ldb	r3,-4(fp)
 82213a0:	008209b4 	movhi	r2,2086
 82213a4:	10b59104 	addi	r2,r2,-10684
 82213a8:	18c7883a 	add	r3,r3,r3
 82213ac:	18c7883a 	add	r3,r3,r3
 82213b0:	10c5883a 	add	r2,r2,r3
 82213b4:	10800017 	ldw	r2,0(r2)
 82213b8:	10801603 	ldbu	r2,88(r2)
 82213bc:	10803fcc 	andi	r2,r2,255
 82213c0:	100b883a 	mov	r5,r2
 82213c4:	01020974 	movhi	r4,2085
 82213c8:	21388f04 	addi	r4,r4,-7620
 82213cc:	821edb80 	call	821edb8 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 82213d0:	e0ffff07 	ldb	r3,-4(fp)
 82213d4:	008209b4 	movhi	r2,2086
 82213d8:	10b59104 	addi	r2,r2,-10684
 82213dc:	18c7883a 	add	r3,r3,r3
 82213e0:	18c7883a 	add	r3,r3,r3
 82213e4:	10c5883a 	add	r2,r2,r3
 82213e8:	10800017 	ldw	r2,0(r2)
 82213ec:	10801643 	ldbu	r2,89(r2)
 82213f0:	10803fcc 	andi	r2,r2,255
 82213f4:	100b883a 	mov	r5,r2
 82213f8:	01020974 	movhi	r4,2085
 82213fc:	21389504 	addi	r4,r4,-7596
 8221400:	821edb80 	call	821edb8 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 8221404:	e0bfff03 	ldbu	r2,-4(fp)
 8221408:	10800044 	addi	r2,r2,1
 822140c:	e0bfff05 	stb	r2,-4(fp)
 8221410:	e0ffff07 	ldb	r3,-4(fp)
 8221414:	d0a07f03 	ldbu	r2,-32260(gp)
 8221418:	10803fcc 	andi	r2,r2,255
 822141c:	18bf8f16 	blt	r3,r2,822125c <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 8221420:	d0a07f03 	ldbu	r2,-32260(gp)
 8221424:	10803fcc 	andi	r2,r2,255
}
 8221428:	e037883a 	mov	sp,fp
 822142c:	dfc00117 	ldw	ra,4(sp)
 8221430:	df000017 	ldw	fp,0(sp)
 8221434:	dec00204 	addi	sp,sp,8
 8221438:	f800283a 	ret

0822143c <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 822143c:	defffa04 	addi	sp,sp,-24
 8221440:	dfc00515 	stw	ra,20(sp)
 8221444:	df000415 	stw	fp,16(sp)
 8221448:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 822144c:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221450:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 8221454:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 8221458:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 822145c:	e03ffc05 	stb	zero,-16(fp)
 8221460:	00019506 	br	8221ab8 <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 8221464:	e0bffc07 	ldb	r2,-16(fp)
 8221468:	10c01224 	muli	r3,r2,72
 822146c:	00820974 	movhi	r2,2085
 8221470:	10864f04 	addi	r2,r2,6460
 8221474:	1885883a 	add	r2,r3,r2
 8221478:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 822147c:	e0bfff17 	ldw	r2,-4(fp)
 8221480:	10800517 	ldw	r2,20(r2)
 8221484:	10018926 	beq	r2,zero,8221aac <alt_tse_mac_group_init+0x670>
 8221488:	e0bfff17 	ldw	r2,-4(fp)
 822148c:	10800617 	ldw	r2,24(r2)
 8221490:	10018626 	beq	r2,zero,8221aac <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 8221494:	d0a07f43 	ldbu	r2,-32259(gp)
 8221498:	10c03fcc 	andi	r3,r2,255
 822149c:	e0bfff17 	ldw	r2,-4(fp)
 82214a0:	10800017 	ldw	r2,0(r2)
 82214a4:	100d883a 	mov	r6,r2
 82214a8:	180b883a 	mov	r5,r3
 82214ac:	01020974 	movhi	r4,2085
 82214b0:	21389b04 	addi	r4,r4,-7572
 82214b4:	8202e9c0 	call	8202e9c <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 82214b8:	01000504 	movi	r4,20
 82214bc:	824b18c0 	call	824b18c <malloc>
 82214c0:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 82214c4:	e0bffd17 	ldw	r2,-12(fp)
 82214c8:	1000081e 	bne	r2,zero,82214ec <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 82214cc:	d0a07f43 	ldbu	r2,-32259(gp)
 82214d0:	10803fcc 	andi	r2,r2,255
 82214d4:	100b883a 	mov	r5,r2
 82214d8:	01020974 	movhi	r4,2085
 82214dc:	2138a704 	addi	r4,r4,-7524
 82214e0:	8202e9c0 	call	8202e9c <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 82214e4:	00bfffc4 	movi	r2,-1
 82214e8:	00017806 	br	8221acc <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 82214ec:	e0bfff17 	ldw	r2,-4(fp)
 82214f0:	108002c3 	ldbu	r2,11(r2)
 82214f4:	10803fcc 	andi	r2,r2,255
 82214f8:	10001226 	beq	r2,zero,8221544 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 82214fc:	e0bfff17 	ldw	r2,-4(fp)
 8221500:	10c00303 	ldbu	r3,12(r2)
 8221504:	e0bffd17 	ldw	r2,-12(fp)
 8221508:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 822150c:	01020974 	movhi	r4,2085
 8221510:	2138b504 	addi	r4,r4,-7468
 8221514:	821edb80 	call	821edb8 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 8221518:	e0bffd17 	ldw	r2,-12(fp)
 822151c:	10800003 	ldbu	r2,0(r2)
 8221520:	10803fcc 	andi	r2,r2,255
 8221524:	100b883a 	mov	r5,r2
 8221528:	01020974 	movhi	r4,2085
 822152c:	2138c004 	addi	r4,r4,-7424
 8221530:	821edb80 	call	821edb8 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 8221534:	01020974 	movhi	r4,2085
 8221538:	2138cb04 	addi	r4,r4,-7380
 822153c:	821edb80 	call	821edb8 <no_printf>
 8221540:	00001f06 	br	82215c0 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 8221544:	e0bfff17 	ldw	r2,-4(fp)
 8221548:	10800343 	ldbu	r2,13(r2)
 822154c:	10803fcc 	andi	r2,r2,255
 8221550:	10001226 	beq	r2,zero,822159c <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 8221554:	e0bfff17 	ldw	r2,-4(fp)
 8221558:	10c00383 	ldbu	r3,14(r2)
 822155c:	e0bffd17 	ldw	r2,-12(fp)
 8221560:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 8221564:	01020974 	movhi	r4,2085
 8221568:	2138d604 	addi	r4,r4,-7336
 822156c:	821edb80 	call	821edb8 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 8221570:	01020974 	movhi	r4,2085
 8221574:	2138cb04 	addi	r4,r4,-7380
 8221578:	821edb80 	call	821edb8 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 822157c:	e0bffd17 	ldw	r2,-12(fp)
 8221580:	10800003 	ldbu	r2,0(r2)
 8221584:	10803fcc 	andi	r2,r2,255
 8221588:	100b883a 	mov	r5,r2
 822158c:	01020974 	movhi	r4,2085
 8221590:	2138e104 	addi	r4,r4,-7292
 8221594:	821edb80 	call	821edb8 <no_printf>
 8221598:	00000906 	br	82215c0 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 822159c:	e0bffd17 	ldw	r2,-12(fp)
 82215a0:	00c00044 	movi	r3,1
 82215a4:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 82215a8:	01020974 	movhi	r4,2085
 82215ac:	2138d604 	addi	r4,r4,-7336
 82215b0:	821edb80 	call	821edb8 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 82215b4:	01020974 	movhi	r4,2085
 82215b8:	2138ec04 	addi	r4,r4,-7248
 82215bc:	821edb80 	call	821edb8 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 82215c0:	e03ffc45 	stb	zero,-15(fp)
 82215c4:	00012206 	br	8221a50 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 82215c8:	01000404 	movi	r4,16
 82215cc:	824b18c0 	call	824b18c <malloc>
 82215d0:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 82215d4:	e0bffe17 	ldw	r2,-8(fp)
 82215d8:	10000a1e 	bne	r2,zero,8221604 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 82215dc:	d0a07f43 	ldbu	r2,-32259(gp)
 82215e0:	10803fcc 	andi	r2,r2,255
 82215e4:	e0fffc47 	ldb	r3,-15(fp)
 82215e8:	180d883a 	mov	r6,r3
 82215ec:	100b883a 	mov	r5,r2
 82215f0:	01020974 	movhi	r4,2085
 82215f4:	2138f704 	addi	r4,r4,-7204
 82215f8:	8202e9c0 	call	8202e9c <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 82215fc:	00bfffc4 	movi	r2,-1
 8221600:	00013206 	br	8221acc <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 8221604:	e0bffe17 	ldw	r2,-8(fp)
 8221608:	e0fffd17 	ldw	r3,-12(fp)
 822160c:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 8221610:	e0bffe17 	ldw	r2,-8(fp)
 8221614:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 8221618:	e0fffc07 	ldb	r3,-16(fp)
 822161c:	e0bffc47 	ldb	r2,-15(fp)
 8221620:	1885883a 	add	r2,r3,r2
 8221624:	10c01224 	muli	r3,r2,72
 8221628:	00820974 	movhi	r2,2085
 822162c:	10864f04 	addi	r2,r2,6460
 8221630:	1887883a 	add	r3,r3,r2
 8221634:	e0bffe17 	ldw	r2,-8(fp)
 8221638:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 822163c:	e0bffe17 	ldw	r2,-8(fp)
 8221640:	10800217 	ldw	r2,8(r2)
 8221644:	10800517 	ldw	r2,20(r2)
 8221648:	10000426 	beq	r2,zero,822165c <alt_tse_mac_group_init+0x220>
 822164c:	e0bffe17 	ldw	r2,-8(fp)
 8221650:	10800217 	ldw	r2,8(r2)
 8221654:	10800617 	ldw	r2,24(r2)
 8221658:	1000091e 	bne	r2,zero,8221680 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 822165c:	e0fffc07 	ldb	r3,-16(fp)
 8221660:	e0bffc47 	ldb	r2,-15(fp)
 8221664:	1885883a 	add	r2,r3,r2
 8221668:	100b883a 	mov	r5,r2
 822166c:	01020974 	movhi	r4,2085
 8221670:	21390904 	addi	r4,r4,-7132
 8221674:	8202e9c0 	call	8202e9c <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8221678:	00bfffc4 	movi	r2,-1
 822167c:	00011306 	br	8221acc <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 8221680:	e0bffe17 	ldw	r2,-8(fp)
 8221684:	10800217 	ldw	r2,8(r2)
 8221688:	10800243 	ldbu	r2,9(r2)
 822168c:	10803fcc 	andi	r2,r2,255
 8221690:	10000d26 	beq	r2,zero,82216c8 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 8221694:	e0bffe17 	ldw	r2,-8(fp)
 8221698:	10800217 	ldw	r2,8(r2)
 822169c:	10800283 	ldbu	r2,10(r2)
 82216a0:	10803fcc 	andi	r2,r2,255
 82216a4:	10000426 	beq	r2,zero,82216b8 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 82216a8:	e0bffe17 	ldw	r2,-8(fp)
 82216ac:	00c00084 	movi	r3,2
 82216b0:	10c00005 	stb	r3,0(r2)
 82216b4:	00000606 	br	82216d0 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 82216b8:	e0bffe17 	ldw	r2,-8(fp)
 82216bc:	00c00044 	movi	r3,1
 82216c0:	10c00005 	stb	r3,0(r2)
 82216c4:	00000206 	br	82216d0 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 82216c8:	e0bffe17 	ldw	r2,-8(fp)
 82216cc:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 82216d0:	e0bffe17 	ldw	r2,-8(fp)
 82216d4:	10800217 	ldw	r2,8(r2)
 82216d8:	10800343 	ldbu	r2,13(r2)
 82216dc:	10803fcc 	andi	r2,r2,255
 82216e0:	10006626 	beq	r2,zero,822187c <alt_tse_mac_group_init+0x440>
 82216e4:	e0bffe17 	ldw	r2,-8(fp)
 82216e8:	10800217 	ldw	r2,8(r2)
 82216ec:	108002c3 	ldbu	r2,11(r2)
 82216f0:	10803fcc 	andi	r2,r2,255
 82216f4:	1000611e 	bne	r2,zero,822187c <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 82216f8:	e0fffc47 	ldb	r3,-15(fp)
 82216fc:	e0bffe17 	ldw	r2,-8(fp)
 8221700:	10800217 	ldw	r2,8(r2)
 8221704:	10800017 	ldw	r2,0(r2)
 8221708:	100d883a 	mov	r6,r2
 822170c:	180b883a 	mov	r5,r3
 8221710:	01020974 	movhi	r4,2085
 8221714:	21391804 	addi	r4,r4,-7072
 8221718:	821edb80 	call	821edb8 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 822171c:	e13ffc47 	ldb	r4,-15(fp)
 8221720:	e0fffc07 	ldb	r3,-16(fp)
 8221724:	e0bffc47 	ldb	r2,-15(fp)
 8221728:	1885883a 	add	r2,r3,r2
 822172c:	100d883a 	mov	r6,r2
 8221730:	200b883a 	mov	r5,r4
 8221734:	01020974 	movhi	r4,2085
 8221738:	21392404 	addi	r4,r4,-7024
 822173c:	821edb80 	call	821edb8 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 8221740:	e0bffe17 	ldw	r2,-8(fp)
 8221744:	10800003 	ldbu	r2,0(r2)
 8221748:	10803fcc 	andi	r2,r2,255
 822174c:	10c00060 	cmpeqi	r3,r2,1
 8221750:	18000c1e 	bne	r3,zero,8221784 <alt_tse_mac_group_init+0x348>
 8221754:	10c000a0 	cmpeqi	r3,r2,2
 8221758:	1800021e 	bne	r3,zero,8221764 <alt_tse_mac_group_init+0x328>
 822175c:	10001126 	beq	r2,zero,82217a4 <alt_tse_mac_group_init+0x368>
 8221760:	00001806 	br	82217c4 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 8221764:	e0bffc47 	ldb	r2,-15(fp)
 8221768:	01820974 	movhi	r6,2085
 822176c:	31b93304 	addi	r6,r6,-6964
 8221770:	100b883a 	mov	r5,r2
 8221774:	01020974 	movhi	r4,2085
 8221778:	21393804 	addi	r4,r4,-6944
 822177c:	821edb80 	call	821edb8 <no_printf>
                            break;
 8221780:	00001806 	br	82217e4 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 8221784:	e0bffc47 	ldb	r2,-15(fp)
 8221788:	01820974 	movhi	r6,2085
 822178c:	31b94304 	addi	r6,r6,-6900
 8221790:	100b883a 	mov	r5,r2
 8221794:	01020974 	movhi	r4,2085
 8221798:	21393804 	addi	r4,r4,-6944
 822179c:	821edb80 	call	821edb8 <no_printf>
                            break;
 82217a0:	00001006 	br	82217e4 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 82217a4:	e0bffc47 	ldb	r2,-15(fp)
 82217a8:	01820974 	movhi	r6,2085
 82217ac:	31b94904 	addi	r6,r6,-6876
 82217b0:	100b883a 	mov	r5,r2
 82217b4:	01020974 	movhi	r4,2085
 82217b8:	21393804 	addi	r4,r4,-6944
 82217bc:	821edb80 	call	821edb8 <no_printf>
                            break;
 82217c0:	00000806 	br	82217e4 <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 82217c4:	e0bffc47 	ldb	r2,-15(fp)
 82217c8:	01820974 	movhi	r6,2085
 82217cc:	31b78104 	addi	r6,r6,-8700
 82217d0:	100b883a 	mov	r5,r2
 82217d4:	01020974 	movhi	r4,2085
 82217d8:	21393804 	addi	r4,r4,-6944
 82217dc:	821edb80 	call	821edb8 <no_printf>
                            break;
 82217e0:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 82217e4:	e0bffe17 	ldw	r2,-8(fp)
 82217e8:	10800217 	ldw	r2,8(r2)
 82217ec:	108003c3 	ldbu	r2,15(r2)
 82217f0:	10803fcc 	andi	r2,r2,255
 82217f4:	10008b26 	beq	r2,zero,8221a24 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 82217f8:	e0fffc47 	ldb	r3,-15(fp)
 82217fc:	e0bffe17 	ldw	r2,-8(fp)
 8221800:	10800217 	ldw	r2,8(r2)
 8221804:	108003c3 	ldbu	r2,15(r2)
 8221808:	10803fcc 	andi	r2,r2,255
 822180c:	10000326 	beq	r2,zero,822181c <alt_tse_mac_group_init+0x3e0>
 8221810:	00820974 	movhi	r2,2085
 8221814:	10b95004 	addi	r2,r2,-6848
 8221818:	00000206 	br	8221824 <alt_tse_mac_group_init+0x3e8>
 822181c:	00820974 	movhi	r2,2085
 8221820:	10b95104 	addi	r2,r2,-6844
 8221824:	100d883a 	mov	r6,r2
 8221828:	180b883a 	mov	r5,r3
 822182c:	01020974 	movhi	r4,2085
 8221830:	21395204 	addi	r4,r4,-6840
 8221834:	821edb80 	call	821edb8 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 8221838:	e0fffc47 	ldb	r3,-15(fp)
 822183c:	e0bffe17 	ldw	r2,-8(fp)
 8221840:	10800217 	ldw	r2,8(r2)
 8221844:	10800403 	ldbu	r2,16(r2)
 8221848:	10803fcc 	andi	r2,r2,255
 822184c:	10000326 	beq	r2,zero,822185c <alt_tse_mac_group_init+0x420>
 8221850:	00820974 	movhi	r2,2085
 8221854:	10b95004 	addi	r2,r2,-6848
 8221858:	00000206 	br	8221864 <alt_tse_mac_group_init+0x428>
 822185c:	00820974 	movhi	r2,2085
 8221860:	10b95104 	addi	r2,r2,-6844
 8221864:	100d883a 	mov	r6,r2
 8221868:	180b883a 	mov	r5,r3
 822186c:	01020974 	movhi	r4,2085
 8221870:	21395d04 	addi	r4,r4,-6796
 8221874:	821edb80 	call	821edb8 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221878:	00006a06 	br	8221a24 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 822187c:	e0bffc47 	ldb	r2,-15(fp)
 8221880:	1000421e 	bne	r2,zero,822198c <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 8221884:	e0bffe17 	ldw	r2,-8(fp)
 8221888:	10800003 	ldbu	r2,0(r2)
 822188c:	10803fcc 	andi	r2,r2,255
 8221890:	10c00060 	cmpeqi	r3,r2,1
 8221894:	18000a1e 	bne	r3,zero,82218c0 <alt_tse_mac_group_init+0x484>
 8221898:	10c000a0 	cmpeqi	r3,r2,2
 822189c:	1800021e 	bne	r3,zero,82218a8 <alt_tse_mac_group_init+0x46c>
 82218a0:	10000d26 	beq	r2,zero,82218d8 <alt_tse_mac_group_init+0x49c>
 82218a4:	00001206 	br	82218f0 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 82218a8:	01420974 	movhi	r5,2085
 82218ac:	29793304 	addi	r5,r5,-6964
 82218b0:	01020974 	movhi	r4,2085
 82218b4:	21396804 	addi	r4,r4,-6752
 82218b8:	821edb80 	call	821edb8 <no_printf>
	                            break;
 82218bc:	00001206 	br	8221908 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 82218c0:	01420974 	movhi	r5,2085
 82218c4:	29794304 	addi	r5,r5,-6900
 82218c8:	01020974 	movhi	r4,2085
 82218cc:	21396804 	addi	r4,r4,-6752
 82218d0:	821edb80 	call	821edb8 <no_printf>
	                            break;
 82218d4:	00000c06 	br	8221908 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 82218d8:	01420974 	movhi	r5,2085
 82218dc:	29794904 	addi	r5,r5,-6876
 82218e0:	01020974 	movhi	r4,2085
 82218e4:	21396804 	addi	r4,r4,-6752
 82218e8:	821edb80 	call	821edb8 <no_printf>
	                            break;
 82218ec:	00000606 	br	8221908 <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 82218f0:	01420974 	movhi	r5,2085
 82218f4:	29778104 	addi	r5,r5,-8700
 82218f8:	01020974 	movhi	r4,2085
 82218fc:	21396804 	addi	r4,r4,-6752
 8221900:	821edb80 	call	821edb8 <no_printf>
                                    break;
 8221904:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221908:	e0bffe17 	ldw	r2,-8(fp)
 822190c:	10800217 	ldw	r2,8(r2)
 8221910:	108003c3 	ldbu	r2,15(r2)
 8221914:	10803fcc 	andi	r2,r2,255
 8221918:	10001c26 	beq	r2,zero,822198c <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 822191c:	e0bffe17 	ldw	r2,-8(fp)
 8221920:	10800217 	ldw	r2,8(r2)
 8221924:	108003c3 	ldbu	r2,15(r2)
 8221928:	10803fcc 	andi	r2,r2,255
 822192c:	10000326 	beq	r2,zero,822193c <alt_tse_mac_group_init+0x500>
 8221930:	00820974 	movhi	r2,2085
 8221934:	10b95004 	addi	r2,r2,-6848
 8221938:	00000206 	br	8221944 <alt_tse_mac_group_init+0x508>
 822193c:	00820974 	movhi	r2,2085
 8221940:	10b95104 	addi	r2,r2,-6844
 8221944:	100b883a 	mov	r5,r2
 8221948:	01020974 	movhi	r4,2085
 822194c:	21397304 	addi	r4,r4,-6708
 8221950:	821edb80 	call	821edb8 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 8221954:	e0bffe17 	ldw	r2,-8(fp)
 8221958:	10800217 	ldw	r2,8(r2)
 822195c:	10800403 	ldbu	r2,16(r2)
 8221960:	10803fcc 	andi	r2,r2,255
 8221964:	10000326 	beq	r2,zero,8221974 <alt_tse_mac_group_init+0x538>
 8221968:	00820974 	movhi	r2,2085
 822196c:	10b95004 	addi	r2,r2,-6848
 8221970:	00000206 	br	822197c <alt_tse_mac_group_init+0x540>
 8221974:	00820974 	movhi	r2,2085
 8221978:	10b95104 	addi	r2,r2,-6844
 822197c:	100b883a 	mov	r5,r2
 8221980:	01020974 	movhi	r4,2085
 8221984:	21397e04 	addi	r4,r4,-6664
 8221988:	821edb80 	call	821edb8 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 822198c:	e0bffe17 	ldw	r2,-8(fp)
 8221990:	10800217 	ldw	r2,8(r2)
 8221994:	108002c3 	ldbu	r2,11(r2)
 8221998:	10803fcc 	andi	r2,r2,255
 822199c:	10001326 	beq	r2,zero,82219ec <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 82219a0:	e0fffc47 	ldb	r3,-15(fp)
 82219a4:	e0bffe17 	ldw	r2,-8(fp)
 82219a8:	10800217 	ldw	r2,8(r2)
 82219ac:	10800017 	ldw	r2,0(r2)
 82219b0:	100d883a 	mov	r6,r2
 82219b4:	180b883a 	mov	r5,r3
 82219b8:	01020974 	movhi	r4,2085
 82219bc:	21398904 	addi	r4,r4,-6620
 82219c0:	821edb80 	call	821edb8 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 82219c4:	e13ffc47 	ldb	r4,-15(fp)
 82219c8:	e0fffc07 	ldb	r3,-16(fp)
 82219cc:	e0bffc47 	ldb	r2,-15(fp)
 82219d0:	1885883a 	add	r2,r3,r2
 82219d4:	100d883a 	mov	r6,r2
 82219d8:	200b883a 	mov	r5,r4
 82219dc:	01020974 	movhi	r4,2085
 82219e0:	21399504 	addi	r4,r4,-6572
 82219e4:	821edb80 	call	821edb8 <no_printf>
 82219e8:	00000e06 	br	8221a24 <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 82219ec:	e0bffe17 	ldw	r2,-8(fp)
 82219f0:	10800217 	ldw	r2,8(r2)
 82219f4:	10800017 	ldw	r2,0(r2)
 82219f8:	100b883a 	mov	r5,r2
 82219fc:	01020974 	movhi	r4,2085
 8221a00:	2139a404 	addi	r4,r4,-6512
 8221a04:	821edb80 	call	821edb8 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 8221a08:	e0fffc07 	ldb	r3,-16(fp)
 8221a0c:	e0bffc47 	ldb	r2,-15(fp)
 8221a10:	1885883a 	add	r2,r3,r2
 8221a14:	100b883a 	mov	r5,r2
 8221a18:	01020974 	movhi	r4,2085
 8221a1c:	2139b004 	addi	r4,r4,-6464
 8221a20:	821edb80 	call	821edb8 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 8221a24:	e0bffc47 	ldb	r2,-15(fp)
 8221a28:	e0fffd17 	ldw	r3,-12(fp)
 8221a2c:	10800044 	addi	r2,r2,1
 8221a30:	1085883a 	add	r2,r2,r2
 8221a34:	1085883a 	add	r2,r2,r2
 8221a38:	1885883a 	add	r2,r3,r2
 8221a3c:	e0fffe17 	ldw	r3,-8(fp)
 8221a40:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 8221a44:	e0bffc43 	ldbu	r2,-15(fp)
 8221a48:	10800044 	addi	r2,r2,1
 8221a4c:	e0bffc45 	stb	r2,-15(fp)
 8221a50:	e0fffc47 	ldb	r3,-15(fp)
 8221a54:	e0bffd17 	ldw	r2,-12(fp)
 8221a58:	10800003 	ldbu	r2,0(r2)
 8221a5c:	10803fcc 	andi	r2,r2,255
 8221a60:	18bed916 	blt	r3,r2,82215c8 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 8221a64:	d0a07f43 	ldbu	r2,-32259(gp)
 8221a68:	10c03fcc 	andi	r3,r2,255
 8221a6c:	008209b4 	movhi	r2,2086
 8221a70:	10b58d04 	addi	r2,r2,-10700
 8221a74:	18c7883a 	add	r3,r3,r3
 8221a78:	18c7883a 	add	r3,r3,r3
 8221a7c:	10c5883a 	add	r2,r2,r3
 8221a80:	e0fffd17 	ldw	r3,-12(fp)
 8221a84:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 8221a88:	d0a07f43 	ldbu	r2,-32259(gp)
 8221a8c:	10800044 	addi	r2,r2,1
 8221a90:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 8221a94:	e0bffd17 	ldw	r2,-12(fp)
 8221a98:	10c00003 	ldbu	r3,0(r2)
 8221a9c:	e0bffc03 	ldbu	r2,-16(fp)
 8221aa0:	1885883a 	add	r2,r3,r2
 8221aa4:	10bfffc4 	addi	r2,r2,-1
 8221aa8:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221aac:	e0bffc03 	ldbu	r2,-16(fp)
 8221ab0:	10800044 	addi	r2,r2,1
 8221ab4:	e0bffc05 	stb	r2,-16(fp)
 8221ab8:	e0fffc07 	ldb	r3,-16(fp)
 8221abc:	d0a02d03 	ldbu	r2,-32588(gp)
 8221ac0:	10803fcc 	andi	r2,r2,255
 8221ac4:	18be6716 	blt	r3,r2,8221464 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 8221ac8:	0005883a 	mov	r2,zero
}
 8221acc:	e037883a 	mov	sp,fp
 8221ad0:	dfc00117 	ldw	ra,4(sp)
 8221ad4:	df000017 	ldw	fp,0(sp)
 8221ad8:	dec00204 	addi	sp,sp,8
 8221adc:	f800283a 	ret

08221ae0 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 8221ae0:	deffed04 	addi	sp,sp,-76
 8221ae4:	dfc01215 	stw	ra,72(sp)
 8221ae8:	df001115 	stw	fp,68(sp)
 8221aec:	df001104 	addi	fp,sp,68
 8221af0:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 8221af4:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 8221af8:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 8221afc:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 8221b00:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221b04:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 8221b08:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221b0c:	e0bfff17 	ldw	r2,-4(fp)
 8221b10:	10800117 	ldw	r2,4(r2)
 8221b14:	10800217 	ldw	r2,8(r2)
 8221b18:	10800017 	ldw	r2,0(r2)
 8221b1c:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221b20:	e0bff917 	ldw	r2,-28(fp)
 8221b24:	10801004 	addi	r2,r2,64
 8221b28:	10800037 	ldwio	r2,0(r2)
 8221b2c:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8221b30:	e13fff17 	ldw	r4,-4(fp)
 8221b34:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8221b38:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221b3c:	e03ff005 	stb	zero,-64(fp)
 8221b40:	0000cb06 	br	8221e70 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 8221b44:	e0bff917 	ldw	r2,-28(fp)
 8221b48:	10801004 	addi	r2,r2,64
 8221b4c:	e0fff003 	ldbu	r3,-64(fp)
 8221b50:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 8221b54:	e0bff917 	ldw	r2,-28(fp)
 8221b58:	1080a204 	addi	r2,r2,648
 8221b5c:	10800037 	ldwio	r2,0(r2)
 8221b60:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 8221b64:	e0bff917 	ldw	r2,-28(fp)
 8221b68:	1080a304 	addi	r2,r2,652
 8221b6c:	10800037 	ldwio	r2,0(r2)
 8221b70:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 8221b74:	e0fffc17 	ldw	r3,-16(fp)
 8221b78:	e0bff517 	ldw	r2,-44(fp)
 8221b7c:	1880b926 	beq	r3,r2,8221e64 <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 8221b80:	01000704 	movi	r4,28
 8221b84:	824b18c0 	call	824b18c <malloc>
 8221b88:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 8221b8c:	e0bff617 	ldw	r2,-40(fp)
 8221b90:	1000091e 	bne	r2,zero,8221bb8 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 8221b94:	e0bffb07 	ldb	r2,-20(fp)
 8221b98:	e0fff407 	ldb	r3,-48(fp)
 8221b9c:	180d883a 	mov	r6,r3
 8221ba0:	100b883a 	mov	r5,r2
 8221ba4:	01020974 	movhi	r4,2085
 8221ba8:	2139bf04 	addi	r4,r4,-6404
 8221bac:	8202e9c0 	call	8202e9c <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 8221bb0:	00bfffc4 	movi	r2,-1
 8221bb4:	0000ce06 	br	8221ef0 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 8221bb8:	e0bff617 	ldw	r2,-40(fp)
 8221bbc:	e0fff003 	ldbu	r3,-64(fp)
 8221bc0:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 8221bc4:	e0bffc17 	ldw	r2,-16(fp)
 8221bc8:	100691ba 	slli	r3,r2,6
 8221bcc:	e0bff517 	ldw	r2,-44(fp)
 8221bd0:	1005d2ba 	srai	r2,r2,10
 8221bd4:	10800fcc 	andi	r2,r2,63
 8221bd8:	1884b03a 	or	r2,r3,r2
 8221bdc:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 8221be0:	e0bff517 	ldw	r2,-44(fp)
 8221be4:	1005d13a 	srai	r2,r2,4
 8221be8:	10800fcc 	andi	r2,r2,63
 8221bec:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 8221bf0:	e0bff517 	ldw	r2,-44(fp)
 8221bf4:	108003cc 	andi	r2,r2,15
 8221bf8:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 8221bfc:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 8221c00:	e03ff115 	stw	zero,-60(fp)
 8221c04:	00003406 	br	8221cd8 <alt_tse_mac_get_phy+0x1f8>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 8221c08:	008209b4 	movhi	r2,2086
 8221c0c:	10b59104 	addi	r2,r2,-10684
 8221c10:	e0fff117 	ldw	r3,-60(fp)
 8221c14:	18c7883a 	add	r3,r3,r3
 8221c18:	18c7883a 	add	r3,r3,r3
 8221c1c:	10c5883a 	add	r2,r2,r3
 8221c20:	10800017 	ldw	r2,0(r2)
 8221c24:	10c01417 	ldw	r3,80(r2)
 8221c28:	e0bffd17 	ldw	r2,-12(fp)
 8221c2c:	1880271e 	bne	r3,r2,8221ccc <alt_tse_mac_get_phy+0x1ec>
 8221c30:	008209b4 	movhi	r2,2086
 8221c34:	10b59104 	addi	r2,r2,-10684
 8221c38:	e0fff117 	ldw	r3,-60(fp)
 8221c3c:	18c7883a 	add	r3,r3,r3
 8221c40:	18c7883a 	add	r3,r3,r3
 8221c44:	10c5883a 	add	r2,r2,r3
 8221c48:	10800017 	ldw	r2,0(r2)
 8221c4c:	10801503 	ldbu	r2,84(r2)
 8221c50:	10c03fcc 	andi	r3,r2,255
 8221c54:	e0bffe03 	ldbu	r2,-8(fp)
 8221c58:	18801c1e 	bne	r3,r2,8221ccc <alt_tse_mac_get_phy+0x1ec>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 8221c5c:	008209b4 	movhi	r2,2086
 8221c60:	10b59104 	addi	r2,r2,-10684
 8221c64:	e0fff117 	ldw	r3,-60(fp)
 8221c68:	18c7883a 	add	r3,r3,r3
 8221c6c:	18c7883a 	add	r3,r3,r3
 8221c70:	10c5883a 	add	r2,r2,r3
 8221c74:	10c00017 	ldw	r3,0(r2)
 8221c78:	e0bff617 	ldw	r2,-40(fp)
 8221c7c:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 8221c80:	008209b4 	movhi	r2,2086
 8221c84:	10b59104 	addi	r2,r2,-10684
 8221c88:	e0fff117 	ldw	r3,-60(fp)
 8221c8c:	18c7883a 	add	r3,r3,r3
 8221c90:	18c7883a 	add	r3,r3,r3
 8221c94:	10c5883a 	add	r2,r2,r3
 8221c98:	10800017 	ldw	r2,0(r2)
 8221c9c:	1009883a 	mov	r4,r2
 8221ca0:	e0bff003 	ldbu	r2,-64(fp)
 8221ca4:	e0fffb07 	ldb	r3,-20(fp)
 8221ca8:	180f883a 	mov	r7,r3
 8221cac:	100d883a 	mov	r6,r2
 8221cb0:	200b883a 	mov	r5,r4
 8221cb4:	01020974 	movhi	r4,2085
 8221cb8:	2139ce04 	addi	r4,r4,-6344
 8221cbc:	8202e9c0 	call	8202e9c <printf>
                    is_phy_in_profile = 1;
 8221cc0:	00800044 	movi	r2,1
 8221cc4:	e0bff205 	stb	r2,-56(fp)
                    break;
 8221cc8:	00000706 	br	8221ce8 <alt_tse_mac_get_phy+0x208>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 8221ccc:	e0bff117 	ldw	r2,-60(fp)
 8221cd0:	10800044 	addi	r2,r2,1
 8221cd4:	e0bff115 	stw	r2,-60(fp)
 8221cd8:	d0a07f03 	ldbu	r2,-32260(gp)
 8221cdc:	10803fcc 	andi	r2,r2,255
 8221ce0:	e0fff117 	ldw	r3,-60(fp)
 8221ce4:	18bfc816 	blt	r3,r2,8221c08 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 8221ce8:	e0bff203 	ldbu	r2,-56(fp)
 8221cec:	10000f1e 	bne	r2,zero,8221d2c <alt_tse_mac_get_phy+0x24c>
                pphy->pphy_profile = 0;
 8221cf0:	e0bff617 	ldw	r2,-40(fp)
 8221cf4:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 8221cf8:	e0bff003 	ldbu	r2,-64(fp)
 8221cfc:	e0fffb07 	ldb	r3,-20(fp)
 8221d00:	180d883a 	mov	r6,r3
 8221d04:	100b883a 	mov	r5,r2
 8221d08:	01020974 	movhi	r4,2085
 8221d0c:	2139de04 	addi	r4,r4,-6280
 8221d10:	8202e9c0 	call	8202e9c <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 8221d14:	01020974 	movhi	r4,2085
 8221d18:	2139ef04 	addi	r4,r4,-6212
 8221d1c:	82031200 	call	8203120 <puts>
                return_value++;
 8221d20:	e0bff317 	ldw	r2,-52(fp)
 8221d24:	10800044 	addi	r2,r2,1
 8221d28:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 8221d2c:	e0bffd17 	ldw	r2,-12(fp)
 8221d30:	100b883a 	mov	r5,r2
 8221d34:	01020974 	movhi	r4,2085
 8221d38:	2139fc04 	addi	r4,r4,-6160
 8221d3c:	821edb80 	call	821edb8 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 8221d40:	e0bffe03 	ldbu	r2,-8(fp)
 8221d44:	100b883a 	mov	r5,r2
 8221d48:	01020974 	movhi	r4,2085
 8221d4c:	213a0704 	addi	r4,r4,-6116
 8221d50:	821edb80 	call	821edb8 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 8221d54:	e0bffe43 	ldbu	r2,-7(fp)
 8221d58:	100b883a 	mov	r5,r2
 8221d5c:	01020974 	movhi	r4,2085
 8221d60:	213a1204 	addi	r4,r4,-6072
 8221d64:	821edb80 	call	821edb8 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 8221d68:	e17ff617 	ldw	r5,-40(fp)
 8221d6c:	e13fff17 	ldw	r4,-4(fp)
 8221d70:	8221f040 	call	8221f04 <alt_tse_mac_associate_phy>
 8221d74:	1000351e 	bne	r2,zero,8221e4c <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 8221d78:	e0bff617 	ldw	r2,-40(fp)
 8221d7c:	10800617 	ldw	r2,24(r2)
 8221d80:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 8221d84:	e0bff717 	ldw	r2,-36(fp)
 8221d88:	10800217 	ldw	r2,8(r2)
 8221d8c:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8221d90:	d8000015 	stw	zero,0(sp)
 8221d94:	01c00044 	movi	r7,1
 8221d98:	01800384 	movi	r6,14
 8221d9c:	000b883a 	mov	r5,zero
 8221da0:	e13ff617 	ldw	r4,-40(fp)
 8221da4:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 8221da8:	01400044 	movi	r5,1
 8221dac:	e13ff617 	ldw	r4,-40(fp)
 8221db0:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 8221db4:	01400044 	movi	r5,1
 8221db8:	e13ff617 	ldw	r4,-40(fp)
 8221dbc:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 8221dc0:	01400044 	movi	r5,1
 8221dc4:	e13ff617 	ldw	r4,-40(fp)
 8221dc8:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 8221dcc:	014003f4 	movhi	r5,15
 8221dd0:	29509004 	addi	r5,r5,16960
 8221dd4:	e13ff617 	ldw	r4,-40(fp)
 8221dd8:	822238c0 	call	822238c <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 8221ddc:	e0bff617 	ldw	r2,-40(fp)
 8221de0:	10800517 	ldw	r2,20(r2)
 8221de4:	10000f26 	beq	r2,zero,8221e24 <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 8221de8:	e0bff617 	ldw	r2,-40(fp)
 8221dec:	10800517 	ldw	r2,20(r2)
 8221df0:	10801717 	ldw	r2,92(r2)
 8221df4:	10000b26 	beq	r2,zero,8221e24 <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 8221df8:	e0bff617 	ldw	r2,-40(fp)
 8221dfc:	10800517 	ldw	r2,20(r2)
 8221e00:	100b883a 	mov	r5,r2
 8221e04:	01020974 	movhi	r4,2085
 8221e08:	213a1d04 	addi	r4,r4,-6028
 8221e0c:	821edb80 	call	821edb8 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 8221e10:	e0bff617 	ldw	r2,-40(fp)
 8221e14:	10800517 	ldw	r2,20(r2)
 8221e18:	10801717 	ldw	r2,92(r2)
 8221e1c:	e13ff917 	ldw	r4,-28(fp)
 8221e20:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 8221e24:	e0bff817 	ldw	r2,-32(fp)
 8221e28:	10801117 	ldw	r2,68(r2)
 8221e2c:	10000726 	beq	r2,zero,8221e4c <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 8221e30:	01020974 	movhi	r4,2085
 8221e34:	213a2b04 	addi	r4,r4,-5972
 8221e38:	821edb80 	call	821edb8 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 8221e3c:	e0bff817 	ldw	r2,-32(fp)
 8221e40:	10801117 	ldw	r2,68(r2)
 8221e44:	e13ff917 	ldw	r4,-28(fp)
 8221e48:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 8221e4c:	01020974 	movhi	r4,2085
 8221e50:	213a3904 	addi	r4,r4,-5916
 8221e54:	821edb80 	call	821edb8 <no_printf>
	            
            phy_info_count++;
 8221e58:	e0bff403 	ldbu	r2,-48(fp)
 8221e5c:	10800044 	addi	r2,r2,1
 8221e60:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221e64:	e0bff003 	ldbu	r2,-64(fp)
 8221e68:	10800044 	addi	r2,r2,1
 8221e6c:	e0bff005 	stb	r2,-64(fp)
 8221e70:	e0bff003 	ldbu	r2,-64(fp)
 8221e74:	10800830 	cmpltui	r2,r2,32
 8221e78:	103f321e 	bne	r2,zero,8221b44 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 8221e7c:	e0bfff17 	ldw	r2,-4(fp)
 8221e80:	10800003 	ldbu	r2,0(r2)
 8221e84:	10c03fcc 	andi	r3,r2,255
 8221e88:	e0bff407 	ldb	r2,-48(fp)
 8221e8c:	18801326 	beq	r3,r2,8221edc <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 8221e90:	e0bff407 	ldb	r2,-48(fp)
 8221e94:	1000061e 	bne	r2,zero,8221eb0 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 8221e98:	e0bffb07 	ldb	r2,-20(fp)
 8221e9c:	100b883a 	mov	r5,r2
 8221ea0:	01020974 	movhi	r4,2085
 8221ea4:	213a3a04 	addi	r4,r4,-5912
 8221ea8:	8202e9c0 	call	8202e9c <printf>
 8221eac:	00000b06 	br	8221edc <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 8221eb0:	e0fffb07 	ldb	r3,-20(fp)
 8221eb4:	e13ff407 	ldb	r4,-48(fp)
 8221eb8:	e0bfff17 	ldw	r2,-4(fp)
 8221ebc:	10800003 	ldbu	r2,0(r2)
 8221ec0:	10803fcc 	andi	r2,r2,255
 8221ec4:	100f883a 	mov	r7,r2
 8221ec8:	200d883a 	mov	r6,r4
 8221ecc:	180b883a 	mov	r5,r3
 8221ed0:	01020974 	movhi	r4,2085
 8221ed4:	213a4604 	addi	r4,r4,-5864
 8221ed8:	8202e9c0 	call	8202e9c <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8221edc:	e0bff917 	ldw	r2,-28(fp)
 8221ee0:	10801004 	addi	r2,r2,64
 8221ee4:	e0fffa17 	ldw	r3,-24(fp)
 8221ee8:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 8221eec:	e0bff317 	ldw	r2,-52(fp)
}
 8221ef0:	e037883a 	mov	sp,fp
 8221ef4:	dfc00117 	ldw	ra,4(sp)
 8221ef8:	df000017 	ldw	fp,0(sp)
 8221efc:	dec00204 	addi	sp,sp,8
 8221f00:	f800283a 	ret

08221f04 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 8221f04:	defff604 	addi	sp,sp,-40
 8221f08:	dfc00915 	stw	ra,36(sp)
 8221f0c:	df000815 	stw	fp,32(sp)
 8221f10:	df000804 	addi	fp,sp,32
 8221f14:	e13ffe15 	stw	r4,-8(fp)
 8221f18:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 8221f1c:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 8221f20:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221f24:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8221f28:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8221f2c:	e13ffe17 	ldw	r4,-8(fp)
 8221f30:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8221f34:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 8221f38:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 8221f3c:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 8221f40:	e03ff815 	stw	zero,-32(fp)
 8221f44:	00002c06 	br	8221ff8 <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 8221f48:	e0fffe17 	ldw	r3,-8(fp)
 8221f4c:	e0bff817 	ldw	r2,-32(fp)
 8221f50:	10800044 	addi	r2,r2,1
 8221f54:	1085883a 	add	r2,r2,r2
 8221f58:	1085883a 	add	r2,r2,r2
 8221f5c:	1885883a 	add	r2,r3,r2
 8221f60:	10800017 	ldw	r2,0(r2)
 8221f64:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 8221f68:	e0bffc17 	ldw	r2,-16(fp)
 8221f6c:	10800217 	ldw	r2,8(r2)
 8221f70:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 8221f74:	e0bffb17 	ldw	r2,-20(fp)
 8221f78:	10c01017 	ldw	r3,64(r2)
 8221f7c:	e0bfff17 	ldw	r2,-4(fp)
 8221f80:	10800003 	ldbu	r2,0(r2)
 8221f84:	10803fcc 	andi	r2,r2,255
 8221f88:	1880181e 	bne	r3,r2,8221fec <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8221f8c:	e13ffc17 	ldw	r4,-16(fp)
 8221f90:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 8221f94:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 8221f98:	e13ffb17 	ldw	r4,-20(fp)
 8221f9c:	821fed00 	call	821fed0 <alt_tse_get_system_index>
 8221fa0:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 8221fa4:	e0bffc17 	ldw	r2,-16(fp)
 8221fa8:	e0ffff17 	ldw	r3,-4(fp)
 8221fac:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 8221fb0:	e0bfff17 	ldw	r2,-4(fp)
 8221fb4:	e0fffc17 	ldw	r3,-16(fp)
 8221fb8:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 8221fbc:	e0bffd47 	ldb	r2,-11(fp)
 8221fc0:	e0fffd07 	ldb	r3,-12(fp)
 8221fc4:	e13ffd87 	ldb	r4,-10(fp)
 8221fc8:	200f883a 	mov	r7,r4
 8221fcc:	180d883a 	mov	r6,r3
 8221fd0:	100b883a 	mov	r5,r2
 8221fd4:	01020974 	movhi	r4,2085
 8221fd8:	213a6504 	addi	r4,r4,-5740
 8221fdc:	8202e9c0 	call	8202e9c <printf>
            is_mapped = 1;
 8221fe0:	00800044 	movi	r2,1
 8221fe4:	e0bffa05 	stb	r2,-24(fp)
            break;
 8221fe8:	00000806 	br	822200c <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 8221fec:	e0bff817 	ldw	r2,-32(fp)
 8221ff0:	10800044 	addi	r2,r2,1
 8221ff4:	e0bff815 	stw	r2,-32(fp)
 8221ff8:	e0bffe17 	ldw	r2,-8(fp)
 8221ffc:	10800003 	ldbu	r2,0(r2)
 8222000:	10803fcc 	andi	r2,r2,255
 8222004:	e0fff817 	ldw	r3,-32(fp)
 8222008:	18bfcf16 	blt	r3,r2,8221f48 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 822200c:	e0bffa03 	ldbu	r2,-24(fp)
 8222010:	10003d1e 	bne	r2,zero,8222108 <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 8222014:	e03ff815 	stw	zero,-32(fp)
 8222018:	00003606 	br	82220f4 <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 822201c:	e0fffe17 	ldw	r3,-8(fp)
 8222020:	e0bff817 	ldw	r2,-32(fp)
 8222024:	10800044 	addi	r2,r2,1
 8222028:	1085883a 	add	r2,r2,r2
 822202c:	1085883a 	add	r2,r2,r2
 8222030:	1885883a 	add	r2,r3,r2
 8222034:	10800017 	ldw	r2,0(r2)
 8222038:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 822203c:	e0bffc17 	ldw	r2,-16(fp)
 8222040:	10800217 	ldw	r2,8(r2)
 8222044:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 8222048:	e0bffb17 	ldw	r2,-20(fp)
 822204c:	10800517 	ldw	r2,20(r2)
 8222050:	10002426 	beq	r2,zero,82220e4 <alt_tse_mac_associate_phy+0x1e0>
 8222054:	e0bffb17 	ldw	r2,-20(fp)
 8222058:	10800617 	ldw	r2,24(r2)
 822205c:	10002126 	beq	r2,zero,82220e4 <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 8222060:	e0bffb17 	ldw	r2,-20(fp)
 8222064:	10801017 	ldw	r2,64(r2)
 8222068:	10bfffd8 	cmpnei	r2,r2,-1
 822206c:	10001e1e 	bne	r2,zero,82220e8 <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222070:	e13ffc17 	ldw	r4,-16(fp)
 8222074:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 8222078:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 822207c:	e13ffb17 	ldw	r4,-20(fp)
 8222080:	821fed00 	call	821fed0 <alt_tse_get_system_index>
 8222084:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 8222088:	e0bffc17 	ldw	r2,-16(fp)
 822208c:	e0ffff17 	ldw	r3,-4(fp)
 8222090:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 8222094:	e0bfff17 	ldw	r2,-4(fp)
 8222098:	e0fffc17 	ldw	r3,-16(fp)
 822209c:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 82220a0:	e0bfff17 	ldw	r2,-4(fp)
 82220a4:	10800003 	ldbu	r2,0(r2)
 82220a8:	10c03fcc 	andi	r3,r2,255
 82220ac:	e0bffb17 	ldw	r2,-20(fp)
 82220b0:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82220b4:	e0bffd47 	ldb	r2,-11(fp)
 82220b8:	e0fffd07 	ldb	r3,-12(fp)
 82220bc:	e13ffd87 	ldb	r4,-10(fp)
 82220c0:	200f883a 	mov	r7,r4
 82220c4:	180d883a 	mov	r6,r3
 82220c8:	100b883a 	mov	r5,r2
 82220cc:	01020974 	movhi	r4,2085
 82220d0:	213a7504 	addi	r4,r4,-5676
 82220d4:	8202e9c0 	call	8202e9c <printf>
                is_mapped = 1;
 82220d8:	00800044 	movi	r2,1
 82220dc:	e0bffa05 	stb	r2,-24(fp)
                break;
 82220e0:	00000906 	br	8222108 <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 82220e4:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 82220e8:	e0bff817 	ldw	r2,-32(fp)
 82220ec:	10800044 	addi	r2,r2,1
 82220f0:	e0bff815 	stw	r2,-32(fp)
 82220f4:	e0bffe17 	ldw	r2,-8(fp)
 82220f8:	10800003 	ldbu	r2,0(r2)
 82220fc:	10803fcc 	andi	r2,r2,255
 8222100:	e0fff817 	ldw	r3,-32(fp)
 8222104:	18bfc516 	blt	r3,r2,822201c <alt_tse_mac_associate_phy+0x118>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 8222108:	e0bffa03 	ldbu	r2,-24(fp)
 822210c:	1000091e 	bne	r2,zero,8222134 <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 8222110:	e0bfff17 	ldw	r2,-4(fp)
 8222114:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 8222118:	e0bffd47 	ldb	r2,-11(fp)
 822211c:	100b883a 	mov	r5,r2
 8222120:	01020974 	movhi	r4,2085
 8222124:	213a8604 	addi	r4,r4,-5608
 8222128:	8202e9c0 	call	8202e9c <printf>
        return_value = TSE_PHY_MAP_ERROR;
 822212c:	00bfffc4 	movi	r2,-1
 8222130:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 8222134:	e0bff917 	ldw	r2,-28(fp)
}
 8222138:	e037883a 	mov	sp,fp
 822213c:	dfc00117 	ldw	ra,4(sp)
 8222140:	df000017 	ldw	fp,0(sp)
 8222144:	dec00204 	addi	sp,sp,8
 8222148:	f800283a 	ret

0822214c <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 822214c:	defff804 	addi	sp,sp,-32
 8222150:	dfc00715 	stw	ra,28(sp)
 8222154:	df000615 	stw	fp,24(sp)
 8222158:	df000604 	addi	fp,sp,24
 822215c:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 8222160:	e0bfff17 	ldw	r2,-4(fp)
 8222164:	10800217 	ldw	r2,8(r2)
 8222168:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 822216c:	e0bffa17 	ldw	r2,-24(fp)
 8222170:	10800017 	ldw	r2,0(r2)
 8222174:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222178:	e0bfff17 	ldw	r2,-4(fp)
 822217c:	10800317 	ldw	r2,12(r2)
 8222180:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222184:	e13fff17 	ldw	r4,-4(fp)
 8222188:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 822218c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222190:	e13ffc17 	ldw	r4,-16(fp)
 8222194:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8222198:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 822219c:	e0bffa17 	ldw	r2,-24(fp)
 82221a0:	108003c3 	ldbu	r2,15(r2)
 82221a4:	10803fcc 	andi	r2,r2,255
 82221a8:	10002c26 	beq	r2,zero,822225c <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 82221ac:	e0bffd47 	ldb	r2,-11(fp)
 82221b0:	e0fffd07 	ldb	r3,-12(fp)
 82221b4:	180d883a 	mov	r6,r3
 82221b8:	100b883a 	mov	r5,r2
 82221bc:	01020974 	movhi	r4,2085
 82221c0:	213ab704 	addi	r4,r4,-5412
 82221c4:	8202e9c0 	call	8202e9c <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 82221c8:	e0bffb17 	ldw	r2,-20(fp)
 82221cc:	10808004 	addi	r2,r2,512
 82221d0:	10801404 	addi	r2,r2,80
 82221d4:	10800037 	ldwio	r2,0(r2)
 82221d8:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 82221dc:	e0bffa17 	ldw	r2,-24(fp)
 82221e0:	10800403 	ldbu	r2,16(r2)
 82221e4:	10803fcc 	andi	r2,r2,255
 82221e8:	10000e26 	beq	r2,zero,8222224 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 82221ec:	e0bffd47 	ldb	r2,-11(fp)
 82221f0:	e0fffd07 	ldb	r3,-12(fp)
 82221f4:	180d883a 	mov	r6,r3
 82221f8:	100b883a 	mov	r5,r2
 82221fc:	01020974 	movhi	r4,2085
 8222200:	213ac504 	addi	r4,r4,-5356
 8222204:	8202e9c0 	call	8202e9c <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 8222208:	e0bffb17 	ldw	r2,-20(fp)
 822220c:	10808004 	addi	r2,r2,512
 8222210:	10801404 	addi	r2,r2,80
 8222214:	e0fffe17 	ldw	r3,-8(fp)
 8222218:	18c000d4 	ori	r3,r3,3
 822221c:	10c00035 	stwio	r3,0(r2)
 8222220:	00000e06 	br	822225c <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 8222224:	e0bffd47 	ldb	r2,-11(fp)
 8222228:	e0fffd07 	ldb	r3,-12(fp)
 822222c:	180d883a 	mov	r6,r3
 8222230:	100b883a 	mov	r5,r2
 8222234:	01020974 	movhi	r4,2085
 8222238:	213ad104 	addi	r4,r4,-5308
 822223c:	8202e9c0 	call	8202e9c <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 8222240:	e0bffb17 	ldw	r2,-20(fp)
 8222244:	10808004 	addi	r2,r2,512
 8222248:	10801404 	addi	r2,r2,80
 822224c:	e13ffe17 	ldw	r4,-8(fp)
 8222250:	00ffff04 	movi	r3,-4
 8222254:	20c6703a 	and	r3,r4,r3
 8222258:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 822225c:	0005883a 	mov	r2,zero
}
 8222260:	e037883a 	mov	sp,fp
 8222264:	dfc00117 	ldw	ra,4(sp)
 8222268:	df000017 	ldw	fp,0(sp)
 822226c:	dec00204 	addi	sp,sp,8
 8222270:	f800283a 	ret

08222274 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 8222274:	defffb04 	addi	sp,sp,-20
 8222278:	dfc00415 	stw	ra,16(sp)
 822227c:	df000315 	stw	fp,12(sp)
 8222280:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 8222284:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 8222288:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 822228c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 8222290:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 8222294:	8220f900 	call	8220f90 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 8222298:	822122c0 	call	822122c <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 822229c:	822143c0 	call	822143c <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 82222a0:	e03ffd05 	stb	zero,-12(fp)
 82222a4:	00002f06 	br	8222364 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 82222a8:	e0fffd07 	ldb	r3,-12(fp)
 82222ac:	008209b4 	movhi	r2,2086
 82222b0:	10b58d04 	addi	r2,r2,-10700
 82222b4:	18c7883a 	add	r3,r3,r3
 82222b8:	18c7883a 	add	r3,r3,r3
 82222bc:	10c5883a 	add	r2,r2,r3
 82222c0:	10800017 	ldw	r2,0(r2)
 82222c4:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 82222c8:	e0bffe17 	ldw	r2,-8(fp)
 82222cc:	10800117 	ldw	r2,4(r2)
 82222d0:	10800217 	ldw	r2,8(r2)
 82222d4:	10800203 	ldbu	r2,8(r2)
 82222d8:	10803fcc 	andi	r2,r2,255
 82222dc:	10000326 	beq	r2,zero,82222ec <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 82222e0:	e13ffe17 	ldw	r4,-8(fp)
 82222e4:	8221ae00 	call	8221ae0 <alt_tse_mac_get_phy>
 82222e8:	00000706 	br	8222308 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 82222ec:	e0bffd07 	ldb	r2,-12(fp)
 82222f0:	e0fffd47 	ldb	r3,-11(fp)
 82222f4:	180d883a 	mov	r6,r3
 82222f8:	100b883a 	mov	r5,r2
 82222fc:	01020974 	movhi	r4,2085
 8222300:	213add04 	addi	r4,r4,-5260
 8222304:	8202e9c0 	call	8202e9c <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222308:	e03ffd45 	stb	zero,-11(fp)
 822230c:	00000d06 	br	8222344 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 8222310:	e0bffd47 	ldb	r2,-11(fp)
 8222314:	e0fffe17 	ldw	r3,-8(fp)
 8222318:	10800044 	addi	r2,r2,1
 822231c:	1085883a 	add	r2,r2,r2
 8222320:	1085883a 	add	r2,r2,r2
 8222324:	1885883a 	add	r2,r3,r2
 8222328:	10800017 	ldw	r2,0(r2)
 822232c:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 8222330:	e13fff17 	ldw	r4,-4(fp)
 8222334:	822214c0 	call	822214c <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222338:	e0bffd43 	ldbu	r2,-11(fp)
 822233c:	10800044 	addi	r2,r2,1
 8222340:	e0bffd45 	stb	r2,-11(fp)
 8222344:	e0fffd47 	ldb	r3,-11(fp)
 8222348:	e0bffe17 	ldw	r2,-8(fp)
 822234c:	10800003 	ldbu	r2,0(r2)
 8222350:	10803fcc 	andi	r2,r2,255
 8222354:	18bfee16 	blt	r3,r2,8222310 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 8222358:	e0bffd03 	ldbu	r2,-12(fp)
 822235c:	10800044 	addi	r2,r2,1
 8222360:	e0bffd05 	stb	r2,-12(fp)
 8222364:	e0fffd07 	ldb	r3,-12(fp)
 8222368:	d0a07f43 	ldbu	r2,-32259(gp)
 822236c:	10803fcc 	andi	r2,r2,255
 8222370:	18bfcd16 	blt	r3,r2,82222a8 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 8222374:	0005883a 	mov	r2,zero
}
 8222378:	e037883a 	mov	sp,fp
 822237c:	dfc00117 	ldw	ra,4(sp)
 8222380:	df000017 	ldw	fp,0(sp)
 8222384:	dec00204 	addi	sp,sp,8
 8222388:	f800283a 	ret

0822238c <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 822238c:	defff704 	addi	sp,sp,-36
 8222390:	dfc00815 	stw	ra,32(sp)
 8222394:	df000715 	stw	fp,28(sp)
 8222398:	df000704 	addi	fp,sp,28
 822239c:	e13ffe15 	stw	r4,-8(fp)
 82223a0:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82223a4:	e0bffe17 	ldw	r2,-8(fp)
 82223a8:	10800617 	ldw	r2,24(r2)
 82223ac:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82223b0:	e0bffb17 	ldw	r2,-20(fp)
 82223b4:	10800317 	ldw	r2,12(r2)
 82223b8:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82223bc:	e13ffb17 	ldw	r4,-20(fp)
 82223c0:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 82223c4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82223c8:	e13ffc17 	ldw	r4,-16(fp)
 82223cc:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 82223d0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82223d4:	e13ffe17 	ldw	r4,-8(fp)
 82223d8:	8220cfc0 	call	8220cfc <alt_tse_phy_rd_mdio_addr>
 82223dc:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82223e0:	e0bffe17 	ldw	r2,-8(fp)
 82223e4:	10800003 	ldbu	r2,0(r2)
 82223e8:	10803fcc 	andi	r2,r2,255
 82223ec:	100b883a 	mov	r5,r2
 82223f0:	e13ffe17 	ldw	r4,-8(fp)
 82223f4:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 82223f8:	01c00044 	movi	r7,1
 82223fc:	018000c4 	movi	r6,3
 8222400:	01400044 	movi	r5,1
 8222404:	e13ffe17 	ldw	r4,-8(fp)
 8222408:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 822240c:	10000d1e 	bne	r2,zero,8222444 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222410:	e0bffd47 	ldb	r2,-11(fp)
 8222414:	e0fffd07 	ldb	r3,-12(fp)
 8222418:	180d883a 	mov	r6,r3
 822241c:	100b883a 	mov	r5,r2
 8222420:	01020974 	movhi	r4,2085
 8222424:	213af304 	addi	r4,r4,-5172
 8222428:	8202e9c0 	call	8202e9c <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 822242c:	e0bffd83 	ldbu	r2,-10(fp)
 8222430:	100b883a 	mov	r5,r2
 8222434:	e13ffe17 	ldw	r4,-8(fp)
 8222438:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 822243c:	00bfff84 	movi	r2,-2
 8222440:	00003c06 	br	8222534 <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 8222444:	00800044 	movi	r2,1
 8222448:	d8800015 	stw	r2,0(sp)
 822244c:	01c00044 	movi	r7,1
 8222450:	01800304 	movi	r6,12
 8222454:	000b883a 	mov	r5,zero
 8222458:	e13ffe17 	ldw	r4,-8(fp)
 822245c:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 8222460:	00800044 	movi	r2,1
 8222464:	d8800015 	stw	r2,0(sp)
 8222468:	01c00044 	movi	r7,1
 822246c:	01800244 	movi	r6,9
 8222470:	000b883a 	mov	r5,zero
 8222474:	e13ffe17 	ldw	r4,-8(fp)
 8222478:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 822247c:	e0bffd47 	ldb	r2,-11(fp)
 8222480:	e0fffd07 	ldb	r3,-12(fp)
 8222484:	180d883a 	mov	r6,r3
 8222488:	100b883a 	mov	r5,r2
 822248c:	01020974 	movhi	r4,2085
 8222490:	213b0304 	addi	r4,r4,-5108
 8222494:	8202e9c0 	call	8202e9c <printf>
    
    alt_32 timeout = 0;
 8222498:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 822249c:	00001306 	br	82224ec <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 82224a0:	e0bffa17 	ldw	r2,-24(fp)
 82224a4:	10c00044 	addi	r3,r2,1
 82224a8:	e0fffa15 	stw	r3,-24(fp)
 82224ac:	1007883a 	mov	r3,r2
 82224b0:	e0bfff17 	ldw	r2,-4(fp)
 82224b4:	10c00d2e 	bgeu	r2,r3,82224ec <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 82224b8:	e0bffd47 	ldb	r2,-11(fp)
 82224bc:	e0fffd07 	ldb	r3,-12(fp)
 82224c0:	180d883a 	mov	r6,r3
 82224c4:	100b883a 	mov	r5,r2
 82224c8:	01020974 	movhi	r4,2085
 82224cc:	213b1504 	addi	r4,r4,-5036
 82224d0:	8202e9c0 	call	8202e9c <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82224d4:	e0bffd83 	ldbu	r2,-10(fp)
 82224d8:	100b883a 	mov	r5,r2
 82224dc:	e13ffe17 	ldw	r4,-8(fp)
 82224e0:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 82224e4:	00bfffc4 	movi	r2,-1
 82224e8:	00001206 	br	8222534 <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 82224ec:	01c00044 	movi	r7,1
 82224f0:	01800144 	movi	r6,5
 82224f4:	01400044 	movi	r5,1
 82224f8:	e13ffe17 	ldw	r4,-8(fp)
 82224fc:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222500:	103fe726 	beq	r2,zero,82224a0 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 8222504:	e0bffd47 	ldb	r2,-11(fp)
 8222508:	e0fffd07 	ldb	r3,-12(fp)
 822250c:	180d883a 	mov	r6,r3
 8222510:	100b883a 	mov	r5,r2
 8222514:	01020974 	movhi	r4,2085
 8222518:	213b2104 	addi	r4,r4,-4988
 822251c:	8202e9c0 	call	8202e9c <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222520:	e0bffd83 	ldbu	r2,-10(fp)
 8222524:	100b883a 	mov	r5,r2
 8222528:	e13ffe17 	ldw	r4,-8(fp)
 822252c:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 8222530:	0005883a 	mov	r2,zero
}
 8222534:	e037883a 	mov	sp,fp
 8222538:	dfc00117 	ldw	ra,4(sp)
 822253c:	df000017 	ldw	fp,0(sp)
 8222540:	dec00204 	addi	sp,sp,8
 8222544:	f800283a 	ret

08222548 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222548:	defff904 	addi	sp,sp,-28
 822254c:	dfc00615 	stw	ra,24(sp)
 8222550:	df000515 	stw	fp,20(sp)
 8222554:	df000504 	addi	fp,sp,20
 8222558:	e13ffe15 	stw	r4,-8(fp)
 822255c:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222560:	e0bffe17 	ldw	r2,-8(fp)
 8222564:	10800617 	ldw	r2,24(r2)
 8222568:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 822256c:	e0bffb17 	ldw	r2,-20(fp)
 8222570:	10800317 	ldw	r2,12(r2)
 8222574:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222578:	e13ffb17 	ldw	r4,-20(fp)
 822257c:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 8222580:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 8222584:	e13ffc17 	ldw	r4,-16(fp)
 8222588:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 822258c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222590:	e13ffe17 	ldw	r4,-8(fp)
 8222594:	8220cfc0 	call	8220cfc <alt_tse_phy_rd_mdio_addr>
 8222598:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 822259c:	e0bffe17 	ldw	r2,-8(fp)
 82225a0:	10800003 	ldbu	r2,0(r2)
 82225a4:	10803fcc 	andi	r2,r2,255
 82225a8:	100b883a 	mov	r5,r2
 82225ac:	e13ffe17 	ldw	r4,-8(fp)
 82225b0:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 82225b4:	e0bffd47 	ldb	r2,-11(fp)
 82225b8:	e0fffd07 	ldb	r3,-12(fp)
 82225bc:	180d883a 	mov	r6,r3
 82225c0:	100b883a 	mov	r5,r2
 82225c4:	01020974 	movhi	r4,2085
 82225c8:	213b2d04 	addi	r4,r4,-4940
 82225cc:	8202e9c0 	call	8202e9c <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 82225d0:	01c00044 	movi	r7,1
 82225d4:	01800384 	movi	r6,14
 82225d8:	000b883a 	mov	r5,zero
 82225dc:	e13ffe17 	ldw	r4,-8(fp)
 82225e0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82225e4:	1000061e 	bne	r2,zero,8222600 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 82225e8:	01c00044 	movi	r7,1
 82225ec:	01800144 	movi	r6,5
 82225f0:	01400044 	movi	r5,1
 82225f4:	e13ffe17 	ldw	r4,-8(fp)
 82225f8:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 82225fc:	1000191e 	bne	r2,zero,8222664 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 8222600:	e0bffd47 	ldb	r2,-11(fp)
 8222604:	e0fffd07 	ldb	r3,-12(fp)
 8222608:	180d883a 	mov	r6,r3
 822260c:	100b883a 	mov	r5,r2
 8222610:	01020974 	movhi	r4,2085
 8222614:	213b3804 	addi	r4,r4,-4896
 8222618:	8202e9c0 	call	8202e9c <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 822261c:	e17fff17 	ldw	r5,-4(fp)
 8222620:	e13ffe17 	ldw	r4,-8(fp)
 8222624:	822238c0 	call	822238c <alt_tse_phy_restart_an>
 8222628:	10bfffd8 	cmpnei	r2,r2,-1
 822262c:	10000d1e 	bne	r2,zero,8222664 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 8222630:	e0bffd47 	ldb	r2,-11(fp)
 8222634:	e0fffd07 	ldb	r3,-12(fp)
 8222638:	180d883a 	mov	r6,r3
 822263c:	100b883a 	mov	r5,r2
 8222640:	01020974 	movhi	r4,2085
 8222644:	213b4c04 	addi	r4,r4,-4816
 8222648:	8202e9c0 	call	8202e9c <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 822264c:	e0bffd83 	ldbu	r2,-10(fp)
 8222650:	100b883a 	mov	r5,r2
 8222654:	e13ffe17 	ldw	r4,-8(fp)
 8222658:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 822265c:	00bfffc4 	movi	r2,-1
 8222660:	00000c06 	br	8222694 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 8222664:	e0bffd47 	ldb	r2,-11(fp)
 8222668:	e0fffd07 	ldb	r3,-12(fp)
 822266c:	180d883a 	mov	r6,r3
 8222670:	100b883a 	mov	r5,r2
 8222674:	01020974 	movhi	r4,2085
 8222678:	213b5904 	addi	r4,r4,-4764
 822267c:	8202e9c0 	call	8202e9c <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222680:	e0bffd83 	ldbu	r2,-10(fp)
 8222684:	100b883a 	mov	r5,r2
 8222688:	e13ffe17 	ldw	r4,-8(fp)
 822268c:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 8222690:	0005883a 	mov	r2,zero
}
 8222694:	e037883a 	mov	sp,fp
 8222698:	dfc00117 	ldw	ra,4(sp)
 822269c:	df000017 	ldw	fp,0(sp)
 82226a0:	dec00204 	addi	sp,sp,8
 82226a4:	f800283a 	ret

082226a8 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 82226a8:	defff904 	addi	sp,sp,-28
 82226ac:	dfc00615 	stw	ra,24(sp)
 82226b0:	df000515 	stw	fp,20(sp)
 82226b4:	df000504 	addi	fp,sp,20
 82226b8:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 82226bc:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82226c0:	e0bfff17 	ldw	r2,-4(fp)
 82226c4:	10800617 	ldw	r2,24(r2)
 82226c8:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82226cc:	e0bffc17 	ldw	r2,-16(fp)
 82226d0:	10800317 	ldw	r2,12(r2)
 82226d4:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82226d8:	e13ffc17 	ldw	r4,-16(fp)
 82226dc:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 82226e0:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 82226e4:	e13ffd17 	ldw	r4,-12(fp)
 82226e8:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 82226ec:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82226f0:	e13fff17 	ldw	r4,-4(fp)
 82226f4:	8220cfc0 	call	8220cfc <alt_tse_phy_rd_mdio_addr>
 82226f8:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82226fc:	e0bfff17 	ldw	r2,-4(fp)
 8222700:	10800003 	ldbu	r2,0(r2)
 8222704:	10803fcc 	andi	r2,r2,255
 8222708:	100b883a 	mov	r5,r2
 822270c:	e13fff17 	ldw	r4,-4(fp)
 8222710:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222714:	01c00044 	movi	r7,1
 8222718:	018000c4 	movi	r6,3
 822271c:	01400044 	movi	r5,1
 8222720:	e13fff17 	ldw	r4,-4(fp)
 8222724:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222728:	10000d1e 	bne	r2,zero,8222760 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 822272c:	e0bffe47 	ldb	r2,-7(fp)
 8222730:	e0fffe07 	ldb	r3,-8(fp)
 8222734:	180d883a 	mov	r6,r3
 8222738:	100b883a 	mov	r5,r2
 822273c:	01020974 	movhi	r4,2085
 8222740:	213af304 	addi	r4,r4,-5172
 8222744:	8202e9c0 	call	8202e9c <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222748:	e0bffe83 	ldbu	r2,-6(fp)
 822274c:	100b883a 	mov	r5,r2
 8222750:	e13fff17 	ldw	r4,-4(fp)
 8222754:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 8222758:	00bfff84 	movi	r2,-2
 822275c:	00013306 	br	8222c2c <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8222760:	01400134 	movhi	r5,4
 8222764:	29742404 	addi	r5,r5,-12144
 8222768:	e13fff17 	ldw	r4,-4(fp)
 822276c:	822238c0 	call	822238c <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 8222770:	01c00044 	movi	r7,1
 8222774:	01800144 	movi	r6,5
 8222778:	01400044 	movi	r5,1
 822277c:	e13fff17 	ldw	r4,-4(fp)
 8222780:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222784:	1000021e 	bne	r2,zero,8222790 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 8222788:	00bfffc4 	movi	r2,-1
 822278c:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 8222790:	01c00044 	movi	r7,1
 8222794:	018003c4 	movi	r6,15
 8222798:	014003c4 	movi	r5,15
 822279c:	e13fff17 	ldw	r4,-4(fp)
 82227a0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82227a4:	1007883a 	mov	r3,r2
 82227a8:	e0bfff17 	ldw	r2,-4(fp)
 82227ac:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 82227b0:	01c00044 	movi	r7,1
 82227b4:	01800384 	movi	r6,14
 82227b8:	014003c4 	movi	r5,15
 82227bc:	e13fff17 	ldw	r4,-4(fp)
 82227c0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82227c4:	1007883a 	mov	r3,r2
 82227c8:	e0bfff17 	ldw	r2,-4(fp)
 82227cc:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 82227d0:	01c00044 	movi	r7,1
 82227d4:	01800344 	movi	r6,13
 82227d8:	014003c4 	movi	r5,15
 82227dc:	e13fff17 	ldw	r4,-4(fp)
 82227e0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82227e4:	1007883a 	mov	r3,r2
 82227e8:	e0bfff17 	ldw	r2,-4(fp)
 82227ec:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 82227f0:	01c00044 	movi	r7,1
 82227f4:	01800304 	movi	r6,12
 82227f8:	014003c4 	movi	r5,15
 82227fc:	e13fff17 	ldw	r4,-4(fp)
 8222800:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222804:	1007883a 	mov	r3,r2
 8222808:	e0bfff17 	ldw	r2,-4(fp)
 822280c:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222810:	01c00044 	movi	r7,1
 8222814:	018003c4 	movi	r6,15
 8222818:	01400044 	movi	r5,1
 822281c:	e13fff17 	ldw	r4,-4(fp)
 8222820:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222824:	1007883a 	mov	r3,r2
 8222828:	e0bfff17 	ldw	r2,-4(fp)
 822282c:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222830:	01c00044 	movi	r7,1
 8222834:	01800384 	movi	r6,14
 8222838:	01400044 	movi	r5,1
 822283c:	e13fff17 	ldw	r4,-4(fp)
 8222840:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222844:	1007883a 	mov	r3,r2
 8222848:	e0bfff17 	ldw	r2,-4(fp)
 822284c:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8222850:	01c00044 	movi	r7,1
 8222854:	01800344 	movi	r6,13
 8222858:	01400044 	movi	r5,1
 822285c:	e13fff17 	ldw	r4,-4(fp)
 8222860:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222864:	1007883a 	mov	r3,r2
 8222868:	e0bfff17 	ldw	r2,-4(fp)
 822286c:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 8222870:	01c00044 	movi	r7,1
 8222874:	01800284 	movi	r6,10
 8222878:	01400044 	movi	r5,1
 822287c:	e13fff17 	ldw	r4,-4(fp)
 8222880:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222884:	1007883a 	mov	r3,r2
 8222888:	e0bfff17 	ldw	r2,-4(fp)
 822288c:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 8222890:	01c00044 	movi	r7,1
 8222894:	01800244 	movi	r6,9
 8222898:	01400044 	movi	r5,1
 822289c:	e13fff17 	ldw	r4,-4(fp)
 82228a0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82228a4:	1007883a 	mov	r3,r2
 82228a8:	e0bfff17 	ldw	r2,-4(fp)
 82228ac:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 82228b0:	01c00044 	movi	r7,1
 82228b4:	01800304 	movi	r6,12
 82228b8:	01400044 	movi	r5,1
 82228bc:	e13fff17 	ldw	r4,-4(fp)
 82228c0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82228c4:	1007883a 	mov	r3,r2
 82228c8:	e0bfff17 	ldw	r2,-4(fp)
 82228cc:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 82228d0:	01c00044 	movi	r7,1
 82228d4:	018002c4 	movi	r6,11
 82228d8:	01400044 	movi	r5,1
 82228dc:	e13fff17 	ldw	r4,-4(fp)
 82228e0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82228e4:	1007883a 	mov	r3,r2
 82228e8:	e0bfff17 	ldw	r2,-4(fp)
 82228ec:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 82228f0:	01c00044 	movi	r7,1
 82228f4:	018002c4 	movi	r6,11
 82228f8:	01400284 	movi	r5,10
 82228fc:	e13fff17 	ldw	r4,-4(fp)
 8222900:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222904:	1007883a 	mov	r3,r2
 8222908:	e0bfff17 	ldw	r2,-4(fp)
 822290c:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 8222910:	01c00044 	movi	r7,1
 8222914:	01800284 	movi	r6,10
 8222918:	01400284 	movi	r5,10
 822291c:	e13fff17 	ldw	r4,-4(fp)
 8222920:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222924:	1007883a 	mov	r3,r2
 8222928:	e0bfff17 	ldw	r2,-4(fp)
 822292c:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 8222930:	01c00044 	movi	r7,1
 8222934:	01800244 	movi	r6,9
 8222938:	01400144 	movi	r5,5
 822293c:	e13fff17 	ldw	r4,-4(fp)
 8222940:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222944:	1007883a 	mov	r3,r2
 8222948:	e0bfff17 	ldw	r2,-4(fp)
 822294c:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 8222950:	01c00044 	movi	r7,1
 8222954:	01800204 	movi	r6,8
 8222958:	01400144 	movi	r5,5
 822295c:	e13fff17 	ldw	r4,-4(fp)
 8222960:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222964:	1007883a 	mov	r3,r2
 8222968:	e0bfff17 	ldw	r2,-4(fp)
 822296c:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 8222970:	01c00044 	movi	r7,1
 8222974:	018001c4 	movi	r6,7
 8222978:	01400144 	movi	r5,5
 822297c:	e13fff17 	ldw	r4,-4(fp)
 8222980:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222984:	1007883a 	mov	r3,r2
 8222988:	e0bfff17 	ldw	r2,-4(fp)
 822298c:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 8222990:	01c00044 	movi	r7,1
 8222994:	01800184 	movi	r6,6
 8222998:	01400144 	movi	r5,5
 822299c:	e13fff17 	ldw	r4,-4(fp)
 82229a0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82229a4:	1007883a 	mov	r3,r2
 82229a8:	e0bfff17 	ldw	r2,-4(fp)
 82229ac:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 82229b0:	01c00044 	movi	r7,1
 82229b4:	01800144 	movi	r6,5
 82229b8:	01400144 	movi	r5,5
 82229bc:	e13fff17 	ldw	r4,-4(fp)
 82229c0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82229c4:	1007883a 	mov	r3,r2
 82229c8:	e0bfff17 	ldw	r2,-4(fp)
 82229cc:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 82229d0:	e0bffe47 	ldb	r2,-7(fp)
 82229d4:	e0fffe07 	ldb	r3,-8(fp)
 82229d8:	180d883a 	mov	r6,r3
 82229dc:	100b883a 	mov	r5,r2
 82229e0:	01020974 	movhi	r4,2085
 82229e4:	213b6404 	addi	r4,r4,-4720
 82229e8:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 82229ec:	e0bfff17 	ldw	r2,-4(fp)
 82229f0:	10800043 	ldbu	r2,1(r2)
 82229f4:	10803fcc 	andi	r2,r2,255
 82229f8:	100b883a 	mov	r5,r2
 82229fc:	01020974 	movhi	r4,2085
 8222a00:	213b6f04 	addi	r4,r4,-4676
 8222a04:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 8222a08:	e0bfff17 	ldw	r2,-4(fp)
 8222a0c:	10800083 	ldbu	r2,2(r2)
 8222a10:	10803fcc 	andi	r2,r2,255
 8222a14:	100b883a 	mov	r5,r2
 8222a18:	01020974 	movhi	r4,2085
 8222a1c:	213b7904 	addi	r4,r4,-4636
 8222a20:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 8222a24:	e0bfff17 	ldw	r2,-4(fp)
 8222a28:	108000c3 	ldbu	r2,3(r2)
 8222a2c:	10803fcc 	andi	r2,r2,255
 8222a30:	100b883a 	mov	r5,r2
 8222a34:	01020974 	movhi	r4,2085
 8222a38:	213b8304 	addi	r4,r4,-4596
 8222a3c:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 8222a40:	e0bfff17 	ldw	r2,-4(fp)
 8222a44:	10800103 	ldbu	r2,4(r2)
 8222a48:	10803fcc 	andi	r2,r2,255
 8222a4c:	100b883a 	mov	r5,r2
 8222a50:	01020974 	movhi	r4,2085
 8222a54:	213b8d04 	addi	r4,r4,-4556
 8222a58:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 8222a5c:	e0bfff17 	ldw	r2,-4(fp)
 8222a60:	10800143 	ldbu	r2,5(r2)
 8222a64:	10803fcc 	andi	r2,r2,255
 8222a68:	100b883a 	mov	r5,r2
 8222a6c:	01020974 	movhi	r4,2085
 8222a70:	213b9704 	addi	r4,r4,-4516
 8222a74:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 8222a78:	e0bfff17 	ldw	r2,-4(fp)
 8222a7c:	10800183 	ldbu	r2,6(r2)
 8222a80:	10803fcc 	andi	r2,r2,255
 8222a84:	100b883a 	mov	r5,r2
 8222a88:	01020974 	movhi	r4,2085
 8222a8c:	213ba104 	addi	r4,r4,-4476
 8222a90:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 8222a94:	e0bfff17 	ldw	r2,-4(fp)
 8222a98:	108001c3 	ldbu	r2,7(r2)
 8222a9c:	10803fcc 	andi	r2,r2,255
 8222aa0:	100b883a 	mov	r5,r2
 8222aa4:	01020974 	movhi	r4,2085
 8222aa8:	213bab04 	addi	r4,r4,-4436
 8222aac:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 8222ab0:	e0bfff17 	ldw	r2,-4(fp)
 8222ab4:	10800203 	ldbu	r2,8(r2)
 8222ab8:	10803fcc 	andi	r2,r2,255
 8222abc:	100b883a 	mov	r5,r2
 8222ac0:	01020974 	movhi	r4,2085
 8222ac4:	213bb504 	addi	r4,r4,-4396
 8222ac8:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 8222acc:	e0bfff17 	ldw	r2,-4(fp)
 8222ad0:	10800243 	ldbu	r2,9(r2)
 8222ad4:	10803fcc 	andi	r2,r2,255
 8222ad8:	100b883a 	mov	r5,r2
 8222adc:	01020974 	movhi	r4,2085
 8222ae0:	213bbf04 	addi	r4,r4,-4356
 8222ae4:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 8222ae8:	e0bfff17 	ldw	r2,-4(fp)
 8222aec:	10800283 	ldbu	r2,10(r2)
 8222af0:	10803fcc 	andi	r2,r2,255
 8222af4:	100b883a 	mov	r5,r2
 8222af8:	01020974 	movhi	r4,2085
 8222afc:	213bc904 	addi	r4,r4,-4316
 8222b00:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 8222b04:	e0bfff17 	ldw	r2,-4(fp)
 8222b08:	108002c3 	ldbu	r2,11(r2)
 8222b0c:	10803fcc 	andi	r2,r2,255
 8222b10:	100b883a 	mov	r5,r2
 8222b14:	01020974 	movhi	r4,2085
 8222b18:	213bd304 	addi	r4,r4,-4276
 8222b1c:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "\n");
 8222b20:	01020974 	movhi	r4,2085
 8222b24:	213a3904 	addi	r4,r4,-5916
 8222b28:	821edb80 	call	821edb8 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 8222b2c:	e0bffe47 	ldb	r2,-7(fp)
 8222b30:	e0fffe07 	ldb	r3,-8(fp)
 8222b34:	180d883a 	mov	r6,r3
 8222b38:	100b883a 	mov	r5,r2
 8222b3c:	01020974 	movhi	r4,2085
 8222b40:	213bdd04 	addi	r4,r4,-4236
 8222b44:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 8222b48:	e0bfff17 	ldw	r2,-4(fp)
 8222b4c:	10800303 	ldbu	r2,12(r2)
 8222b50:	10803fcc 	andi	r2,r2,255
 8222b54:	100b883a 	mov	r5,r2
 8222b58:	01020974 	movhi	r4,2085
 8222b5c:	213b8304 	addi	r4,r4,-4596
 8222b60:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 8222b64:	e0bfff17 	ldw	r2,-4(fp)
 8222b68:	10800343 	ldbu	r2,13(r2)
 8222b6c:	10803fcc 	andi	r2,r2,255
 8222b70:	100b883a 	mov	r5,r2
 8222b74:	01020974 	movhi	r4,2085
 8222b78:	213b8d04 	addi	r4,r4,-4556
 8222b7c:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 8222b80:	e0bfff17 	ldw	r2,-4(fp)
 8222b84:	10800383 	ldbu	r2,14(r2)
 8222b88:	10803fcc 	andi	r2,r2,255
 8222b8c:	100b883a 	mov	r5,r2
 8222b90:	01020974 	movhi	r4,2085
 8222b94:	213b9704 	addi	r4,r4,-4516
 8222b98:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 8222b9c:	e0bfff17 	ldw	r2,-4(fp)
 8222ba0:	108003c3 	ldbu	r2,15(r2)
 8222ba4:	10803fcc 	andi	r2,r2,255
 8222ba8:	100b883a 	mov	r5,r2
 8222bac:	01020974 	movhi	r4,2085
 8222bb0:	213bea04 	addi	r4,r4,-4184
 8222bb4:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 8222bb8:	e0bfff17 	ldw	r2,-4(fp)
 8222bbc:	10800403 	ldbu	r2,16(r2)
 8222bc0:	10803fcc 	andi	r2,r2,255
 8222bc4:	100b883a 	mov	r5,r2
 8222bc8:	01020974 	movhi	r4,2085
 8222bcc:	213bf404 	addi	r4,r4,-4144
 8222bd0:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 8222bd4:	e0bfff17 	ldw	r2,-4(fp)
 8222bd8:	10800443 	ldbu	r2,17(r2)
 8222bdc:	10803fcc 	andi	r2,r2,255
 8222be0:	100b883a 	mov	r5,r2
 8222be4:	01020974 	movhi	r4,2085
 8222be8:	213bfe04 	addi	r4,r4,-4104
 8222bec:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 8222bf0:	e0bfff17 	ldw	r2,-4(fp)
 8222bf4:	10800483 	ldbu	r2,18(r2)
 8222bf8:	10803fcc 	andi	r2,r2,255
 8222bfc:	100b883a 	mov	r5,r2
 8222c00:	01020974 	movhi	r4,2085
 8222c04:	213c0804 	addi	r4,r4,-4064
 8222c08:	821edb80 	call	821edb8 <no_printf>
    tse_dprintf(6, "\n");
 8222c0c:	01020974 	movhi	r4,2085
 8222c10:	213a3904 	addi	r4,r4,-5916
 8222c14:	821edb80 	call	821edb8 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222c18:	e0bffe83 	ldbu	r2,-6(fp)
 8222c1c:	100b883a 	mov	r5,r2
 8222c20:	e13fff17 	ldw	r4,-4(fp)
 8222c24:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 8222c28:	e0bffb17 	ldw	r2,-20(fp)
    
}
 8222c2c:	e037883a 	mov	sp,fp
 8222c30:	dfc00117 	ldw	ra,4(sp)
 8222c34:	df000017 	ldw	fp,0(sp)
 8222c38:	dec00204 	addi	sp,sp,8
 8222c3c:	f800283a 	ret

08222c40 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 8222c40:	defff804 	addi	sp,sp,-32
 8222c44:	dfc00715 	stw	ra,28(sp)
 8222c48:	df000615 	stw	fp,24(sp)
 8222c4c:	df000604 	addi	fp,sp,24
 8222c50:	e13ffe15 	stw	r4,-8(fp)
 8222c54:	2805883a 	mov	r2,r5
 8222c58:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222c5c:	e0bffe17 	ldw	r2,-8(fp)
 8222c60:	10800617 	ldw	r2,24(r2)
 8222c64:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222c68:	e0bffb17 	ldw	r2,-20(fp)
 8222c6c:	10800317 	ldw	r2,12(r2)
 8222c70:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222c74:	e13ffb17 	ldw	r4,-20(fp)
 8222c78:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 8222c7c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222c80:	e13ffc17 	ldw	r4,-16(fp)
 8222c84:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8222c88:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222c8c:	e13ffe17 	ldw	r4,-8(fp)
 8222c90:	8220cfc0 	call	8220cfc <alt_tse_phy_rd_mdio_addr>
 8222c94:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222c98:	e0bffe17 	ldw	r2,-8(fp)
 8222c9c:	10800003 	ldbu	r2,0(r2)
 8222ca0:	10803fcc 	andi	r2,r2,255
 8222ca4:	100b883a 	mov	r5,r2
 8222ca8:	e13ffe17 	ldw	r4,-8(fp)
 8222cac:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8222cb0:	e0bfff03 	ldbu	r2,-4(fp)
 8222cb4:	10002d26 	beq	r2,zero,8222d6c <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 8222cb8:	01c00044 	movi	r7,1
 8222cbc:	01800344 	movi	r6,13
 8222cc0:	014003c4 	movi	r5,15
 8222cc4:	e13ffe17 	ldw	r4,-8(fp)
 8222cc8:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222ccc:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 8222cd0:	e0bffdc3 	ldbu	r2,-9(fp)
 8222cd4:	d8800015 	stw	r2,0(sp)
 8222cd8:	01c00044 	movi	r7,1
 8222cdc:	01800244 	movi	r6,9
 8222ce0:	01400244 	movi	r5,9
 8222ce4:	e13ffe17 	ldw	r4,-8(fp)
 8222ce8:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222cec:	e0bffd47 	ldb	r2,-11(fp)
 8222cf0:	e0fffd07 	ldb	r3,-12(fp)
 8222cf4:	e13ffdc3 	ldbu	r4,-9(fp)
 8222cf8:	200f883a 	mov	r7,r4
 8222cfc:	180d883a 	mov	r6,r3
 8222d00:	100b883a 	mov	r5,r2
 8222d04:	01020974 	movhi	r4,2085
 8222d08:	213c1204 	addi	r4,r4,-4024
 8222d0c:	821edb80 	call	821edb8 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8222d10:	01c00044 	movi	r7,1
 8222d14:	01800304 	movi	r6,12
 8222d18:	014003c4 	movi	r5,15
 8222d1c:	e13ffe17 	ldw	r4,-8(fp)
 8222d20:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222d24:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 8222d28:	e0bffdc3 	ldbu	r2,-9(fp)
 8222d2c:	d8800015 	stw	r2,0(sp)
 8222d30:	01c00044 	movi	r7,1
 8222d34:	01800204 	movi	r6,8
 8222d38:	01400244 	movi	r5,9
 8222d3c:	e13ffe17 	ldw	r4,-8(fp)
 8222d40:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222d44:	e0bffd47 	ldb	r2,-11(fp)
 8222d48:	e0fffd07 	ldb	r3,-12(fp)
 8222d4c:	e13ffdc3 	ldbu	r4,-9(fp)
 8222d50:	200f883a 	mov	r7,r4
 8222d54:	180d883a 	mov	r6,r3
 8222d58:	100b883a 	mov	r5,r2
 8222d5c:	01020974 	movhi	r4,2085
 8222d60:	213c2504 	addi	r4,r4,-3948
 8222d64:	821edb80 	call	821edb8 <no_printf>
 8222d68:	00001c06 	br	8222ddc <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 8222d6c:	d8000015 	stw	zero,0(sp)
 8222d70:	01c00044 	movi	r7,1
 8222d74:	01800244 	movi	r6,9
 8222d78:	01400244 	movi	r5,9
 8222d7c:	e13ffe17 	ldw	r4,-8(fp)
 8222d80:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8222d84:	e0bffd47 	ldb	r2,-11(fp)
 8222d88:	e0fffd07 	ldb	r3,-12(fp)
 8222d8c:	000f883a 	mov	r7,zero
 8222d90:	180d883a 	mov	r6,r3
 8222d94:	100b883a 	mov	r5,r2
 8222d98:	01020974 	movhi	r4,2085
 8222d9c:	213c1204 	addi	r4,r4,-4024
 8222da0:	821edb80 	call	821edb8 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 8222da4:	d8000015 	stw	zero,0(sp)
 8222da8:	01c00044 	movi	r7,1
 8222dac:	01800204 	movi	r6,8
 8222db0:	01400244 	movi	r5,9
 8222db4:	e13ffe17 	ldw	r4,-8(fp)
 8222db8:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8222dbc:	e0bffd47 	ldb	r2,-11(fp)
 8222dc0:	e0fffd07 	ldb	r3,-12(fp)
 8222dc4:	000f883a 	mov	r7,zero
 8222dc8:	180d883a 	mov	r6,r3
 8222dcc:	100b883a 	mov	r5,r2
 8222dd0:	01020974 	movhi	r4,2085
 8222dd4:	213c3804 	addi	r4,r4,-3872
 8222dd8:	821edb80 	call	821edb8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 8222ddc:	e0bffd83 	ldbu	r2,-10(fp)
 8222de0:	100b883a 	mov	r5,r2
 8222de4:	e13ffe17 	ldw	r4,-8(fp)
 8222de8:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 8222dec:	0005883a 	mov	r2,zero
}
 8222df0:	e037883a 	mov	sp,fp
 8222df4:	dfc00117 	ldw	ra,4(sp)
 8222df8:	df000017 	ldw	fp,0(sp)
 8222dfc:	dec00204 	addi	sp,sp,8
 8222e00:	f800283a 	ret

08222e04 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 8222e04:	defff804 	addi	sp,sp,-32
 8222e08:	dfc00715 	stw	ra,28(sp)
 8222e0c:	df000615 	stw	fp,24(sp)
 8222e10:	df000604 	addi	fp,sp,24
 8222e14:	e13ffe15 	stw	r4,-8(fp)
 8222e18:	2805883a 	mov	r2,r5
 8222e1c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222e20:	e0bffe17 	ldw	r2,-8(fp)
 8222e24:	10800617 	ldw	r2,24(r2)
 8222e28:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222e2c:	e0bffb17 	ldw	r2,-20(fp)
 8222e30:	10800317 	ldw	r2,12(r2)
 8222e34:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222e38:	e13ffb17 	ldw	r4,-20(fp)
 8222e3c:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 8222e40:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222e44:	e13ffc17 	ldw	r4,-16(fp)
 8222e48:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8222e4c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222e50:	e13ffe17 	ldw	r4,-8(fp)
 8222e54:	8220cfc0 	call	8220cfc <alt_tse_phy_rd_mdio_addr>
 8222e58:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222e5c:	e0bffe17 	ldw	r2,-8(fp)
 8222e60:	10800003 	ldbu	r2,0(r2)
 8222e64:	10803fcc 	andi	r2,r2,255
 8222e68:	100b883a 	mov	r5,r2
 8222e6c:	e13ffe17 	ldw	r4,-8(fp)
 8222e70:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8222e74:	e0bfff03 	ldbu	r2,-4(fp)
 8222e78:	10004326 	beq	r2,zero,8222f88 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222e7c:	01c00044 	movi	r7,1
 8222e80:	018003c4 	movi	r6,15
 8222e84:	01400044 	movi	r5,1
 8222e88:	e13ffe17 	ldw	r4,-8(fp)
 8222e8c:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222e90:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 8222e94:	e0bffdc3 	ldbu	r2,-9(fp)
 8222e98:	d8800015 	stw	r2,0(sp)
 8222e9c:	01c00044 	movi	r7,1
 8222ea0:	01800244 	movi	r6,9
 8222ea4:	01400104 	movi	r5,4
 8222ea8:	e13ffe17 	ldw	r4,-8(fp)
 8222eac:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 8222eb0:	e0bffd47 	ldb	r2,-11(fp)
 8222eb4:	e0fffd07 	ldb	r3,-12(fp)
 8222eb8:	e13ffdc3 	ldbu	r4,-9(fp)
 8222ebc:	200f883a 	mov	r7,r4
 8222ec0:	180d883a 	mov	r6,r3
 8222ec4:	100b883a 	mov	r5,r2
 8222ec8:	01020974 	movhi	r4,2085
 8222ecc:	213c4a04 	addi	r4,r4,-3800
 8222ed0:	821edb80 	call	821edb8 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222ed4:	01c00044 	movi	r7,1
 8222ed8:	01800384 	movi	r6,14
 8222edc:	01400044 	movi	r5,1
 8222ee0:	e13ffe17 	ldw	r4,-8(fp)
 8222ee4:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222ee8:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 8222eec:	e0bffdc3 	ldbu	r2,-9(fp)
 8222ef0:	d8800015 	stw	r2,0(sp)
 8222ef4:	01c00044 	movi	r7,1
 8222ef8:	01800204 	movi	r6,8
 8222efc:	01400104 	movi	r5,4
 8222f00:	e13ffe17 	ldw	r4,-8(fp)
 8222f04:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222f08:	e0bffd47 	ldb	r2,-11(fp)
 8222f0c:	e0fffd07 	ldb	r3,-12(fp)
 8222f10:	e13ffdc3 	ldbu	r4,-9(fp)
 8222f14:	200f883a 	mov	r7,r4
 8222f18:	180d883a 	mov	r6,r3
 8222f1c:	100b883a 	mov	r5,r2
 8222f20:	01020974 	movhi	r4,2085
 8222f24:	213c5a04 	addi	r4,r4,-3736
 8222f28:	821edb80 	call	821edb8 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8222f2c:	01c00044 	movi	r7,1
 8222f30:	01800344 	movi	r6,13
 8222f34:	01400044 	movi	r5,1
 8222f38:	e13ffe17 	ldw	r4,-8(fp)
 8222f3c:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8222f40:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 8222f44:	e0bffdc3 	ldbu	r2,-9(fp)
 8222f48:	d8800015 	stw	r2,0(sp)
 8222f4c:	01c00044 	movi	r7,1
 8222f50:	018001c4 	movi	r6,7
 8222f54:	01400104 	movi	r5,4
 8222f58:	e13ffe17 	ldw	r4,-8(fp)
 8222f5c:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222f60:	e0bffd47 	ldb	r2,-11(fp)
 8222f64:	e0fffd07 	ldb	r3,-12(fp)
 8222f68:	e13ffdc3 	ldbu	r4,-9(fp)
 8222f6c:	200f883a 	mov	r7,r4
 8222f70:	180d883a 	mov	r6,r3
 8222f74:	100b883a 	mov	r5,r2
 8222f78:	01020974 	movhi	r4,2085
 8222f7c:	213c6d04 	addi	r4,r4,-3660
 8222f80:	821edb80 	call	821edb8 <no_printf>
 8222f84:	00002a06 	br	8223030 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 8222f88:	d8000015 	stw	zero,0(sp)
 8222f8c:	01c00044 	movi	r7,1
 8222f90:	01800244 	movi	r6,9
 8222f94:	01400104 	movi	r5,4
 8222f98:	e13ffe17 	ldw	r4,-8(fp)
 8222f9c:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 8222fa0:	e0bffd47 	ldb	r2,-11(fp)
 8222fa4:	e0fffd07 	ldb	r3,-12(fp)
 8222fa8:	000f883a 	mov	r7,zero
 8222fac:	180d883a 	mov	r6,r3
 8222fb0:	100b883a 	mov	r5,r2
 8222fb4:	01020974 	movhi	r4,2085
 8222fb8:	213c4a04 	addi	r4,r4,-3800
 8222fbc:	821edb80 	call	821edb8 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 8222fc0:	d8000015 	stw	zero,0(sp)
 8222fc4:	01c00044 	movi	r7,1
 8222fc8:	01800204 	movi	r6,8
 8222fcc:	01400104 	movi	r5,4
 8222fd0:	e13ffe17 	ldw	r4,-8(fp)
 8222fd4:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8222fd8:	e0bffd47 	ldb	r2,-11(fp)
 8222fdc:	e0fffd07 	ldb	r3,-12(fp)
 8222fe0:	000f883a 	mov	r7,zero
 8222fe4:	180d883a 	mov	r6,r3
 8222fe8:	100b883a 	mov	r5,r2
 8222fec:	01020974 	movhi	r4,2085
 8222ff0:	213c5a04 	addi	r4,r4,-3736
 8222ff4:	821edb80 	call	821edb8 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 8222ff8:	d8000015 	stw	zero,0(sp)
 8222ffc:	01c00044 	movi	r7,1
 8223000:	018001c4 	movi	r6,7
 8223004:	01400104 	movi	r5,4
 8223008:	e13ffe17 	ldw	r4,-8(fp)
 822300c:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223010:	e0bffd47 	ldb	r2,-11(fp)
 8223014:	e0fffd07 	ldb	r3,-12(fp)
 8223018:	000f883a 	mov	r7,zero
 822301c:	180d883a 	mov	r6,r3
 8223020:	100b883a 	mov	r5,r2
 8223024:	01020974 	movhi	r4,2085
 8223028:	213c6d04 	addi	r4,r4,-3660
 822302c:	821edb80 	call	821edb8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 8223030:	e0bffd83 	ldbu	r2,-10(fp)
 8223034:	100b883a 	mov	r5,r2
 8223038:	e13ffe17 	ldw	r4,-8(fp)
 822303c:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 8223040:	0005883a 	mov	r2,zero
}
 8223044:	e037883a 	mov	sp,fp
 8223048:	dfc00117 	ldw	ra,4(sp)
 822304c:	df000017 	ldw	fp,0(sp)
 8223050:	dec00204 	addi	sp,sp,8
 8223054:	f800283a 	ret

08223058 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 8223058:	defff504 	addi	sp,sp,-44
 822305c:	dfc00a15 	stw	ra,40(sp)
 8223060:	df000915 	stw	fp,36(sp)
 8223064:	df000904 	addi	fp,sp,36
 8223068:	e13ffe15 	stw	r4,-8(fp)
 822306c:	2805883a 	mov	r2,r5
 8223070:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8223074:	e0bffe17 	ldw	r2,-8(fp)
 8223078:	10800617 	ldw	r2,24(r2)
 822307c:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223080:	e0bff817 	ldw	r2,-32(fp)
 8223084:	10800317 	ldw	r2,12(r2)
 8223088:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 822308c:	e13ff817 	ldw	r4,-32(fp)
 8223090:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 8223094:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223098:	e13ff917 	ldw	r4,-28(fp)
 822309c:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 82230a0:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82230a4:	e13ffe17 	ldw	r4,-8(fp)
 82230a8:	8220cfc0 	call	8220cfc <alt_tse_phy_rd_mdio_addr>
 82230ac:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82230b0:	e0bffe17 	ldw	r2,-8(fp)
 82230b4:	10800003 	ldbu	r2,0(r2)
 82230b8:	10803fcc 	andi	r2,r2,255
 82230bc:	100b883a 	mov	r5,r2
 82230c0:	e13ffe17 	ldw	r4,-8(fp)
 82230c4:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 82230c8:	e0bfff03 	ldbu	r2,-4(fp)
 82230cc:	10002926 	beq	r2,zero,8223174 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 82230d0:	01c00044 	movi	r7,1
 82230d4:	01800304 	movi	r6,12
 82230d8:	01400044 	movi	r5,1
 82230dc:	e13ffe17 	ldw	r4,-8(fp)
 82230e0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82230e4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 82230e8:	e0bffd03 	ldbu	r2,-12(fp)
 82230ec:	d8800015 	stw	r2,0(sp)
 82230f0:	01c00044 	movi	r7,1
 82230f4:	01800184 	movi	r6,6
 82230f8:	01400104 	movi	r5,4
 82230fc:	e13ffe17 	ldw	r4,-8(fp)
 8223100:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223104:	e0bffd03 	ldbu	r2,-12(fp)
 8223108:	100f883a 	mov	r7,r2
 822310c:	e1bffa17 	ldw	r6,-24(fp)
 8223110:	e17ffb17 	ldw	r5,-20(fp)
 8223114:	01020974 	movhi	r4,2085
 8223118:	213c8004 	addi	r4,r4,-3584
 822311c:	821edb80 	call	821edb8 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8223120:	01c00044 	movi	r7,1
 8223124:	018002c4 	movi	r6,11
 8223128:	01400044 	movi	r5,1
 822312c:	e13ffe17 	ldw	r4,-8(fp)
 8223130:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8223134:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 8223138:	e0bffd03 	ldbu	r2,-12(fp)
 822313c:	d8800015 	stw	r2,0(sp)
 8223140:	01c00044 	movi	r7,1
 8223144:	01800144 	movi	r6,5
 8223148:	01400104 	movi	r5,4
 822314c:	e13ffe17 	ldw	r4,-8(fp)
 8223150:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223154:	e0bffd03 	ldbu	r2,-12(fp)
 8223158:	100f883a 	mov	r7,r2
 822315c:	e1bffa17 	ldw	r6,-24(fp)
 8223160:	e17ffb17 	ldw	r5,-20(fp)
 8223164:	01020974 	movhi	r4,2085
 8223168:	213c9304 	addi	r4,r4,-3508
 822316c:	821edb80 	call	821edb8 <no_printf>
 8223170:	00001806 	br	82231d4 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 8223174:	d8000015 	stw	zero,0(sp)
 8223178:	01c00044 	movi	r7,1
 822317c:	01800184 	movi	r6,6
 8223180:	01400104 	movi	r5,4
 8223184:	e13ffe17 	ldw	r4,-8(fp)
 8223188:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 822318c:	000f883a 	mov	r7,zero
 8223190:	e1bffa17 	ldw	r6,-24(fp)
 8223194:	e17ffb17 	ldw	r5,-20(fp)
 8223198:	01020974 	movhi	r4,2085
 822319c:	213c8004 	addi	r4,r4,-3584
 82231a0:	821edb80 	call	821edb8 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 82231a4:	d8000015 	stw	zero,0(sp)
 82231a8:	01c00044 	movi	r7,1
 82231ac:	01800144 	movi	r6,5
 82231b0:	01400104 	movi	r5,4
 82231b4:	e13ffe17 	ldw	r4,-8(fp)
 82231b8:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82231bc:	000f883a 	mov	r7,zero
 82231c0:	e1bffa17 	ldw	r6,-24(fp)
 82231c4:	e17ffb17 	ldw	r5,-20(fp)
 82231c8:	01020974 	movhi	r4,2085
 82231cc:	213c9304 	addi	r4,r4,-3508
 82231d0:	821edb80 	call	821edb8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82231d4:	e0bffc17 	ldw	r2,-16(fp)
 82231d8:	10803fcc 	andi	r2,r2,255
 82231dc:	100b883a 	mov	r5,r2
 82231e0:	e13ffe17 	ldw	r4,-8(fp)
 82231e4:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 82231e8:	0005883a 	mov	r2,zero
}
 82231ec:	e037883a 	mov	sp,fp
 82231f0:	dfc00117 	ldw	ra,4(sp)
 82231f4:	df000017 	ldw	fp,0(sp)
 82231f8:	dec00204 	addi	sp,sp,8
 82231fc:	f800283a 	ret

08223200 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 8223200:	defff604 	addi	sp,sp,-40
 8223204:	dfc00915 	stw	ra,36(sp)
 8223208:	df000815 	stw	fp,32(sp)
 822320c:	df000804 	addi	fp,sp,32
 8223210:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 8223214:	00800044 	movi	r2,1
 8223218:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 822321c:	00800044 	movi	r2,1
 8223220:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 8223224:	00800044 	movi	r2,1
 8223228:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 822322c:	00800044 	movi	r2,1
 8223230:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 8223234:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 8223238:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 822323c:	e13fff17 	ldw	r4,-4(fp)
 8223240:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8223244:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 8223248:	e03ff815 	stw	zero,-32(fp)
 822324c:	00001c06 	br	82232c0 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 8223250:	e0ffff17 	ldw	r3,-4(fp)
 8223254:	e0bff817 	ldw	r2,-32(fp)
 8223258:	10800044 	addi	r2,r2,1
 822325c:	1085883a 	add	r2,r2,r2
 8223260:	1085883a 	add	r2,r2,r2
 8223264:	1885883a 	add	r2,r3,r2
 8223268:	10800017 	ldw	r2,0(r2)
 822326c:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223270:	e0bffc17 	ldw	r2,-16(fp)
 8223274:	10800117 	ldw	r2,4(r2)
 8223278:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 822327c:	e0bffd17 	ldw	r2,-12(fp)
 8223280:	10000926 	beq	r2,zero,82232a8 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 8223284:	01400044 	movi	r5,1
 8223288:	e13ffd17 	ldw	r4,-12(fp)
 822328c:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223290:	01400044 	movi	r5,1
 8223294:	e13ffd17 	ldw	r4,-12(fp)
 8223298:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 822329c:	01400044 	movi	r5,1
 82232a0:	e13ffd17 	ldw	r4,-12(fp)
 82232a4:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 82232a8:	01020974 	movhi	r4,2085
 82232ac:	213a3904 	addi	r4,r4,-5916
 82232b0:	821edb80 	call	821edb8 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 82232b4:	e0bff817 	ldw	r2,-32(fp)
 82232b8:	10800044 	addi	r2,r2,1
 82232bc:	e0bff815 	stw	r2,-32(fp)
 82232c0:	e0bfff17 	ldw	r2,-4(fp)
 82232c4:	10800003 	ldbu	r2,0(r2)
 82232c8:	10803fcc 	andi	r2,r2,255
 82232cc:	e0fff817 	ldw	r3,-32(fp)
 82232d0:	18bfdf16 	blt	r3,r2,8223250 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82232d4:	e03ff815 	stw	zero,-32(fp)
 82232d8:	00005606 	br	8223434 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 82232dc:	e0ffff17 	ldw	r3,-4(fp)
 82232e0:	e0bff817 	ldw	r2,-32(fp)
 82232e4:	10800044 	addi	r2,r2,1
 82232e8:	1085883a 	add	r2,r2,r2
 82232ec:	1085883a 	add	r2,r2,r2
 82232f0:	1885883a 	add	r2,r3,r2
 82232f4:	10800017 	ldw	r2,0(r2)
 82232f8:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 82232fc:	e0bffc17 	ldw	r2,-16(fp)
 8223300:	10800117 	ldw	r2,4(r2)
 8223304:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223308:	e0bffd17 	ldw	r2,-12(fp)
 822330c:	10004326 	beq	r2,zero,822341c <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 8223310:	e13ffd17 	ldw	r4,-12(fp)
 8223314:	82226a80 	call	82226a8 <alt_tse_phy_get_cap>
 8223318:	1000421e 	bne	r2,zero,8223424 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 822331c:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8223320:	e0bffc17 	ldw	r2,-16(fp)
 8223324:	10800003 	ldbu	r2,0(r2)
 8223328:	10803fcc 	andi	r2,r2,255
 822332c:	10800058 	cmpnei	r2,r2,1
 8223330:	1000021e 	bne	r2,zero,822333c <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 8223334:	e03ff905 	stb	zero,-28(fp)
 8223338:	00000706 	br	8223358 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 822333c:	e0bffc17 	ldw	r2,-16(fp)
 8223340:	10800003 	ldbu	r2,0(r2)
 8223344:	10803fcc 	andi	r2,r2,255
 8223348:	10800098 	cmpnei	r2,r2,2
 822334c:	1000021e 	bne	r2,zero,8223358 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 8223350:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 8223354:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 8223358:	e0bffd17 	ldw	r2,-12(fp)
 822335c:	10c000c3 	ldbu	r3,3(r2)
 8223360:	e0bffd17 	ldw	r2,-12(fp)
 8223364:	10800303 	ldbu	r2,12(r2)
 8223368:	1884703a 	and	r2,r3,r2
 822336c:	1007883a 	mov	r3,r2
 8223370:	e0bff903 	ldbu	r2,-28(fp)
 8223374:	1884703a 	and	r2,r3,r2
 8223378:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 822337c:	e0bffd17 	ldw	r2,-12(fp)
 8223380:	10c00183 	ldbu	r3,6(r2)
 8223384:	e0bffd17 	ldw	r2,-12(fp)
 8223388:	108003c3 	ldbu	r2,15(r2)
 822338c:	1884703a 	and	r2,r3,r2
 8223390:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 8223394:	e0bffd17 	ldw	r2,-12(fp)
 8223398:	10c001c3 	ldbu	r3,7(r2)
 822339c:	e0bffd17 	ldw	r2,-12(fp)
 82233a0:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82233a4:	1884703a 	and	r2,r3,r2
 82233a8:	2084b03a 	or	r2,r4,r2
 82233ac:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 82233b0:	e0bffd17 	ldw	r2,-12(fp)
 82233b4:	10c00143 	ldbu	r3,5(r2)
 82233b8:	e0bffd17 	ldw	r2,-12(fp)
 82233bc:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82233c0:	1884703a 	and	r2,r3,r2
 82233c4:	2084b03a 	or	r2,r4,r2
 82233c8:	1007883a 	mov	r3,r2
 82233cc:	e0bff943 	ldbu	r2,-27(fp)
 82233d0:	1884703a 	and	r2,r3,r2
 82233d4:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 82233d8:	e0bffd17 	ldw	r2,-12(fp)
 82233dc:	10c00283 	ldbu	r3,10(r2)
 82233e0:	e0bffd17 	ldw	r2,-12(fp)
 82233e4:	10800443 	ldbu	r2,17(r2)
 82233e8:	1884703a 	and	r2,r3,r2
 82233ec:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 82233f0:	e0bffd17 	ldw	r2,-12(fp)
 82233f4:	10c002c3 	ldbu	r3,11(r2)
 82233f8:	e0bffd17 	ldw	r2,-12(fp)
 82233fc:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 8223400:	1884703a 	and	r2,r3,r2
 8223404:	2084b03a 	or	r2,r4,r2
 8223408:	1007883a 	mov	r3,r2
 822340c:	e0bff983 	ldbu	r2,-26(fp)
 8223410:	1884703a 	and	r2,r3,r2
 8223414:	e0bff985 	stb	r2,-26(fp)
 8223418:	00000306 	br	8223428 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 822341c:	0001883a 	nop
 8223420:	00000106 	br	8223428 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 8223424:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223428:	e0bff817 	ldw	r2,-32(fp)
 822342c:	10800044 	addi	r2,r2,1
 8223430:	e0bff815 	stw	r2,-32(fp)
 8223434:	e0bfff17 	ldw	r2,-4(fp)
 8223438:	10800003 	ldbu	r2,0(r2)
 822343c:	10803fcc 	andi	r2,r2,255
 8223440:	e0fff817 	ldw	r3,-32(fp)
 8223444:	18bfa516 	blt	r3,r2,82232dc <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 8223448:	e0bffb03 	ldbu	r2,-20(fp)
 822344c:	10800058 	cmpnei	r2,r2,1
 8223450:	1000081e 	bne	r2,zero,8223474 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 8223454:	00bfffc4 	movi	r2,-1
 8223458:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 822345c:	e0bffe07 	ldb	r2,-8(fp)
 8223460:	100b883a 	mov	r5,r2
 8223464:	01020974 	movhi	r4,2085
 8223468:	213ca604 	addi	r4,r4,-3432
 822346c:	8202e9c0 	call	8202e9c <printf>
 8223470:	00002706 	br	8223510 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 8223474:	e0bff903 	ldbu	r2,-28(fp)
 8223478:	10000926 	beq	r2,zero,82234a0 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 822347c:	00800084 	movi	r2,2
 8223480:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 8223484:	e0bffe07 	ldb	r2,-8(fp)
 8223488:	0180fa04 	movi	r6,1000
 822348c:	100b883a 	mov	r5,r2
 8223490:	01020974 	movhi	r4,2085
 8223494:	213cb804 	addi	r4,r4,-3360
 8223498:	8202e9c0 	call	8202e9c <printf>
 822349c:	00001c06 	br	8223510 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 82234a0:	e0bff943 	ldbu	r2,-27(fp)
 82234a4:	10000926 	beq	r2,zero,82234cc <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 82234a8:	00800044 	movi	r2,1
 82234ac:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 82234b0:	e0bffe07 	ldb	r2,-8(fp)
 82234b4:	01801904 	movi	r6,100
 82234b8:	100b883a 	mov	r5,r2
 82234bc:	01020974 	movhi	r4,2085
 82234c0:	213cb804 	addi	r4,r4,-3360
 82234c4:	8202e9c0 	call	8202e9c <printf>
 82234c8:	00001106 	br	8223510 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 82234cc:	e0bff983 	ldbu	r2,-26(fp)
 82234d0:	10000826 	beq	r2,zero,82234f4 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 82234d4:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 82234d8:	e0bffe07 	ldb	r2,-8(fp)
 82234dc:	01800284 	movi	r6,10
 82234e0:	100b883a 	mov	r5,r2
 82234e4:	01020974 	movhi	r4,2085
 82234e8:	213cb804 	addi	r4,r4,-3360
 82234ec:	8202e9c0 	call	8202e9c <printf>
 82234f0:	00000706 	br	8223510 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 82234f4:	00bfffc4 	movi	r2,-1
 82234f8:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 82234fc:	e0bffe07 	ldb	r2,-8(fp)
 8223500:	100b883a 	mov	r5,r2
 8223504:	01020974 	movhi	r4,2085
 8223508:	213cc504 	addi	r4,r4,-3308
 822350c:	8202e9c0 	call	8202e9c <printf>

    return common_speed;
 8223510:	e0bffa17 	ldw	r2,-24(fp)
}
 8223514:	e037883a 	mov	sp,fp
 8223518:	dfc00117 	ldw	ra,4(sp)
 822351c:	df000017 	ldw	fp,0(sp)
 8223520:	dec00204 	addi	sp,sp,8
 8223524:	f800283a 	ret

08223528 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 8223528:	defff004 	addi	sp,sp,-64
 822352c:	dfc00f15 	stw	ra,60(sp)
 8223530:	df000e15 	stw	fp,56(sp)
 8223534:	dc400d15 	stw	r17,52(sp)
 8223538:	dc000c15 	stw	r16,48(sp)
 822353c:	df000e04 	addi	fp,sp,56
 8223540:	e13ffc15 	stw	r4,-16(fp)
 8223544:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 8223548:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 822354c:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 8223550:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8223554:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223558:	e13ffc17 	ldw	r4,-16(fp)
 822355c:	821ff3c0 	call	821ff3c <alt_tse_get_mac_group_index>
 8223560:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8223564:	e0bffc17 	ldw	r2,-16(fp)
 8223568:	10800117 	ldw	r2,4(r2)
 822356c:	10800217 	ldw	r2,8(r2)
 8223570:	10800017 	ldw	r2,0(r2)
 8223574:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8223578:	e0bff917 	ldw	r2,-28(fp)
 822357c:	10801004 	addi	r2,r2,64
 8223580:	10800037 	ldwio	r2,0(r2)
 8223584:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 8223588:	e0bffd17 	ldw	r2,-12(fp)
 822358c:	10000316 	blt	r2,zero,822359c <alt_tse_phy_set_common_speed+0x74>
 8223590:	e0bffd17 	ldw	r2,-12(fp)
 8223594:	108000d0 	cmplti	r2,r2,3
 8223598:	10000c1e 	bne	r2,zero,82235cc <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 822359c:	e0bff847 	ldb	r2,-31(fp)
 82235a0:	e1bffd17 	ldw	r6,-12(fp)
 82235a4:	100b883a 	mov	r5,r2
 82235a8:	01020974 	movhi	r4,2085
 82235ac:	213cd204 	addi	r4,r4,-3256
 82235b0:	8202e9c0 	call	8202e9c <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82235b4:	e0bff917 	ldw	r2,-28(fp)
 82235b8:	10801004 	addi	r2,r2,64
 82235bc:	e0fffa17 	ldw	r3,-24(fp)
 82235c0:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 82235c4:	00bfffc4 	movi	r2,-1
 82235c8:	0000fe06 	br	82239c4 <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82235cc:	e03ff315 	stw	zero,-52(fp)
 82235d0:	0000dc06 	br	8223944 <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
 82235d4:	e0fffc17 	ldw	r3,-16(fp)
 82235d8:	e0bff317 	ldw	r2,-52(fp)
 82235dc:	10800044 	addi	r2,r2,1
 82235e0:	1085883a 	add	r2,r2,r2
 82235e4:	1085883a 	add	r2,r2,r2
 82235e8:	1885883a 	add	r2,r3,r2
 82235ec:	10800017 	ldw	r2,0(r2)
 82235f0:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82235f4:	e13ff617 	ldw	r4,-40(fp)
 82235f8:	821ffb00 	call	821ffb0 <alt_tse_get_mac_info_index>
 82235fc:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 8223600:	e0bff617 	ldw	r2,-40(fp)
 8223604:	10800117 	ldw	r2,4(r2)
 8223608:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 822360c:	e0bff517 	ldw	r2,-44(fp)
 8223610:	1000c826 	beq	r2,zero,8223934 <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 8223614:	e0bff617 	ldw	r2,-40(fp)
 8223618:	10800217 	ldw	r2,8(r2)
 822361c:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223620:	e0bff517 	ldw	r2,-44(fp)
 8223624:	10800003 	ldbu	r2,0(r2)
 8223628:	10803fcc 	andi	r2,r2,255
 822362c:	100b883a 	mov	r5,r2
 8223630:	e13ff517 	ldw	r4,-44(fp)
 8223634:	8220d440 	call	8220d44 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223638:	e0bff517 	ldw	r2,-44(fp)
 822363c:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223640:	10803fcc 	andi	r2,r2,255
 8223644:	10000c1e 	bne	r2,zero,8223678 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223648:	e0bff517 	ldw	r2,-44(fp)
 822364c:	10800103 	ldbu	r2,4(r2)
 8223650:	10803fcc 	andi	r2,r2,255
 8223654:	1000081e 	bne	r2,zero,8223678 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223658:	e0bff517 	ldw	r2,-44(fp)
 822365c:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223660:	10803fcc 	andi	r2,r2,255
 8223664:	1000041e 	bne	r2,zero,8223678 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223668:	e0bff517 	ldw	r2,-44(fp)
 822366c:	10800083 	ldbu	r2,2(r2)
 8223670:	10803fcc 	andi	r2,r2,255
 8223674:	10000226 	beq	r2,zero,8223680 <alt_tse_phy_set_common_speed+0x158>
 8223678:	00800044 	movi	r2,1
 822367c:	00000106 	br	8223684 <alt_tse_phy_set_common_speed+0x15c>
 8223680:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223684:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 8223688:	e0bffb03 	ldbu	r2,-20(fp)
 822368c:	1000101e 	bne	r2,zero,82236d0 <alt_tse_phy_set_common_speed+0x1a8>
 8223690:	e0bffd17 	ldw	r2,-12(fp)
 8223694:	10800098 	cmpnei	r2,r2,2
 8223698:	10000d1e 	bne	r2,zero,82236d0 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 822369c:	e0bff847 	ldb	r2,-31(fp)
 82236a0:	e0fff807 	ldb	r3,-32(fp)
 82236a4:	180d883a 	mov	r6,r3
 82236a8:	100b883a 	mov	r5,r2
 82236ac:	01020974 	movhi	r4,2085
 82236b0:	213ce604 	addi	r4,r4,-3176
 82236b4:	8202e9c0 	call	8202e9c <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82236b8:	e0bff917 	ldw	r2,-28(fp)
 82236bc:	10801004 	addi	r2,r2,64
 82236c0:	e0fffa17 	ldw	r3,-24(fp)
 82236c4:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 82236c8:	00bfffc4 	movi	r2,-1
 82236cc:	0000bd06 	br	82239c4 <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 82236d0:	01c00044 	movi	r7,1
 82236d4:	018000c4 	movi	r6,3
 82236d8:	01400044 	movi	r5,1
 82236dc:	e13ff517 	ldw	r4,-44(fp)
 82236e0:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82236e4:	1000141e 	bne	r2,zero,8223738 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 82236e8:	e0bffb03 	ldbu	r2,-20(fp)
 82236ec:	10000926 	beq	r2,zero,8223714 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 82236f0:	e0bffd17 	ldw	r2,-12(fp)
 82236f4:	1005d07a 	srai	r2,r2,1
 82236f8:	10bfffcc 	andi	r2,r2,65535
 82236fc:	d8800015 	stw	r2,0(sp)
 8223700:	01c00044 	movi	r7,1
 8223704:	01800184 	movi	r6,6
 8223708:	000b883a 	mov	r5,zero
 822370c:	e13ff517 	ldw	r4,-44(fp)
 8223710:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 8223714:	e0bffd17 	ldw	r2,-12(fp)
 8223718:	10bfffcc 	andi	r2,r2,65535
 822371c:	d8800015 	stw	r2,0(sp)
 8223720:	01c00044 	movi	r7,1
 8223724:	01800344 	movi	r6,13
 8223728:	000b883a 	mov	r5,zero
 822372c:	e13ff517 	ldw	r4,-44(fp)
 8223730:	8220d9c0 	call	8220d9c <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 8223734:	00008006 	br	8223938 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 8223738:	e0bffd17 	ldw	r2,-12(fp)
 822373c:	10800098 	cmpnei	r2,r2,2
 8223740:	10000a1e 	bne	r2,zero,822376c <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 8223744:	01400044 	movi	r5,1
 8223748:	e13ff517 	ldw	r4,-44(fp)
 822374c:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223750:	01400044 	movi	r5,1
 8223754:	e13ff517 	ldw	r4,-44(fp)
 8223758:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 822375c:	01400044 	movi	r5,1
 8223760:	e13ff517 	ldw	r4,-44(fp)
 8223764:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
 8223768:	00002206 	br	82237f4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 822376c:	e0bffd17 	ldw	r2,-12(fp)
 8223770:	10800058 	cmpnei	r2,r2,1
 8223774:	10000a1e 	bne	r2,zero,82237a0 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223778:	000b883a 	mov	r5,zero
 822377c:	e13ff517 	ldw	r4,-44(fp)
 8223780:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223784:	01400044 	movi	r5,1
 8223788:	e13ff517 	ldw	r4,-44(fp)
 822378c:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223790:	01400044 	movi	r5,1
 8223794:	e13ff517 	ldw	r4,-44(fp)
 8223798:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
 822379c:	00001506 	br	82237f4 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 82237a0:	e0bffd17 	ldw	r2,-12(fp)
 82237a4:	10000a1e 	bne	r2,zero,82237d0 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 82237a8:	000b883a 	mov	r5,zero
 82237ac:	e13ff517 	ldw	r4,-44(fp)
 82237b0:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 82237b4:	000b883a 	mov	r5,zero
 82237b8:	e13ff517 	ldw	r4,-44(fp)
 82237bc:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 82237c0:	01400044 	movi	r5,1
 82237c4:	e13ff517 	ldw	r4,-44(fp)
 82237c8:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
 82237cc:	00000906 	br	82237f4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 82237d0:	000b883a 	mov	r5,zero
 82237d4:	e13ff517 	ldw	r4,-44(fp)
 82237d8:	8222c400 	call	8222c40 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 82237dc:	000b883a 	mov	r5,zero
 82237e0:	e13ff517 	ldw	r4,-44(fp)
 82237e4:	8222e040 	call	8222e04 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 82237e8:	000b883a 	mov	r5,zero
 82237ec:	e13ff517 	ldw	r4,-44(fp)
 82237f0:	82230580 	call	8223058 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 82237f4:	01c00044 	movi	r7,1
 82237f8:	01800144 	movi	r6,5
 82237fc:	01400044 	movi	r5,1
 8223800:	e13ff517 	ldw	r4,-44(fp)
 8223804:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8223808:	10800058 	cmpnei	r2,r2,1
 822380c:	10003b1e 	bne	r2,zero,82238fc <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 8223810:	e0bffb03 	ldbu	r2,-20(fp)
 8223814:	10000f26 	beq	r2,zero,8223854 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8223818:	e0bff517 	ldw	r2,-44(fp)
 822381c:	10800517 	ldw	r2,20(r2)
 8223820:	10801583 	ldbu	r2,86(r2)
 8223824:	10c03fcc 	andi	r3,r2,255
 8223828:	e0bff517 	ldw	r2,-44(fp)
 822382c:	10800517 	ldw	r2,20(r2)
 8223830:	108015c3 	ldbu	r2,87(r2)
 8223834:	10803fcc 	andi	r2,r2,255
 8223838:	01c00084 	movi	r7,2
 822383c:	100d883a 	mov	r6,r2
 8223840:	180b883a 	mov	r5,r3
 8223844:	e13ff517 	ldw	r4,-44(fp)
 8223848:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 822384c:	e0bff405 	stb	r2,-48(fp)
 8223850:	00000e06 	br	822388c <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 8223854:	e0bff517 	ldw	r2,-44(fp)
 8223858:	10800517 	ldw	r2,20(r2)
 822385c:	10801583 	ldbu	r2,86(r2)
 8223860:	10c03fcc 	andi	r3,r2,255
 8223864:	e0bff517 	ldw	r2,-44(fp)
 8223868:	10800517 	ldw	r2,20(r2)
 822386c:	108015c3 	ldbu	r2,87(r2)
 8223870:	10803fcc 	andi	r2,r2,255
 8223874:	01c00044 	movi	r7,1
 8223878:	100d883a 	mov	r6,r2
 822387c:	180b883a 	mov	r5,r3
 8223880:	e13ff517 	ldw	r4,-44(fp)
 8223884:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8223888:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 822388c:	e0fff403 	ldbu	r3,-48(fp)
 8223890:	e0bffd17 	ldw	r2,-12(fp)
 8223894:	18800426 	beq	r3,r2,82238a8 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8223898:	01400134 	movhi	r5,4
 822389c:	29742404 	addi	r5,r5,-12144
 82238a0:	e13ff517 	ldw	r4,-44(fp)
 82238a4:	822238c0 	call	822238c <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 82238a8:	e0bff517 	ldw	r2,-44(fp)
 82238ac:	10800517 	ldw	r2,20(r2)
 82238b0:	10801583 	ldbu	r2,86(r2)
 82238b4:	10c03fcc 	andi	r3,r2,255
 82238b8:	e0bff517 	ldw	r2,-44(fp)
 82238bc:	10800517 	ldw	r2,20(r2)
 82238c0:	10801603 	ldbu	r2,88(r2)
 82238c4:	10803fcc 	andi	r2,r2,255
 82238c8:	01c00044 	movi	r7,1
 82238cc:	100d883a 	mov	r6,r2
 82238d0:	180b883a 	mov	r5,r3
 82238d4:	e13ff517 	ldw	r4,-44(fp)
 82238d8:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 82238dc:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 82238e0:	e0bff717 	ldw	r2,-36(fp)
 82238e4:	10800017 	ldw	r2,0(r2)
 82238e8:	1007883a 	mov	r3,r2
 82238ec:	e0bffb43 	ldbu	r2,-19(fp)
 82238f0:	100b883a 	mov	r5,r2
 82238f4:	1809883a 	mov	r4,r3
 82238f8:	82201e80 	call	82201e8 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 82238fc:	e43ff847 	ldb	r16,-31(fp)
 8223900:	e47ff807 	ldb	r17,-32(fp)
 8223904:	01c00404 	movi	r7,16
 8223908:	000d883a 	mov	r6,zero
 822390c:	01400044 	movi	r5,1
 8223910:	e13ff517 	ldw	r4,-44(fp)
 8223914:	8220ec40 	call	8220ec4 <alt_tse_phy_rd_mdio_reg>
 8223918:	100f883a 	mov	r7,r2
 822391c:	880d883a 	mov	r6,r17
 8223920:	800b883a 	mov	r5,r16
 8223924:	01020974 	movhi	r4,2085
 8223928:	213cfd04 	addi	r4,r4,-3084
 822392c:	8202e9c0 	call	8202e9c <printf>
 8223930:	00000106 	br	8223938 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223934:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223938:	e0bff317 	ldw	r2,-52(fp)
 822393c:	10800044 	addi	r2,r2,1
 8223940:	e0bff315 	stw	r2,-52(fp)
 8223944:	e0bffc17 	ldw	r2,-16(fp)
 8223948:	10800003 	ldbu	r2,0(r2)
 822394c:	10803fcc 	andi	r2,r2,255
 8223950:	e0fff317 	ldw	r3,-52(fp)
 8223954:	18bf1f16 	blt	r3,r2,82235d4 <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 8223958:	e0fff847 	ldb	r3,-31(fp)
 822395c:	e0bffd17 	ldw	r2,-12(fp)
 8223960:	108000a0 	cmpeqi	r2,r2,2
 8223964:	1000071e 	bne	r2,zero,8223984 <alt_tse_phy_set_common_speed+0x45c>
 8223968:	e0bffd17 	ldw	r2,-12(fp)
 822396c:	10800058 	cmpnei	r2,r2,1
 8223970:	1000021e 	bne	r2,zero,822397c <alt_tse_phy_set_common_speed+0x454>
 8223974:	00801904 	movi	r2,100
 8223978:	00000306 	br	8223988 <alt_tse_phy_set_common_speed+0x460>
 822397c:	00800284 	movi	r2,10
 8223980:	00000106 	br	8223988 <alt_tse_phy_set_common_speed+0x460>
 8223984:	0080fa04 	movi	r2,1000
 8223988:	100d883a 	mov	r6,r2
 822398c:	180b883a 	mov	r5,r3
 8223990:	01020974 	movhi	r4,2085
 8223994:	213d0904 	addi	r4,r4,-3036
 8223998:	8202e9c0 	call	8202e9c <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 822399c:	e0bffd17 	ldw	r2,-12(fp)
 82239a0:	10803fcc 	andi	r2,r2,255
 82239a4:	100b883a 	mov	r5,r2
 82239a8:	e13ff917 	ldw	r4,-28(fp)
 82239ac:	82201080 	call	8220108 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82239b0:	e0bff917 	ldw	r2,-28(fp)
 82239b4:	10801004 	addi	r2,r2,64
 82239b8:	e0fffa17 	ldw	r3,-24(fp)
 82239bc:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 82239c0:	e0bffd17 	ldw	r2,-12(fp)
}
 82239c4:	e6fffe04 	addi	sp,fp,-8
 82239c8:	dfc00317 	ldw	ra,12(sp)
 82239cc:	df000217 	ldw	fp,8(sp)
 82239d0:	dc400117 	ldw	r17,4(sp)
 82239d4:	dc000017 	ldw	r16,0(sp)
 82239d8:	dec00404 	addi	sp,sp,16
 82239dc:	f800283a 	ret

082239e0 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 82239e0:	defffc04 	addi	sp,sp,-16
 82239e4:	dfc00315 	stw	ra,12(sp)
 82239e8:	df000215 	stw	fp,8(sp)
 82239ec:	df000204 	addi	fp,sp,8
 82239f0:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 82239f4:	e0bfff17 	ldw	r2,-4(fp)
 82239f8:	1080a104 	addi	r2,r2,644
 82239fc:	10800037 	ldwio	r2,0(r2)
 8223a00:	1080080c 	andi	r2,r2,32
 8223a04:	1000161e 	bne	r2,zero,8223a60 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 8223a08:	01020974 	movhi	r4,2085
 8223a0c:	213d1a04 	addi	r4,r4,-2968
 8223a10:	82031200 	call	8203120 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 8223a14:	e0bfff17 	ldw	r2,-4(fp)
 8223a18:	1080a004 	addi	r2,r2,640
 8223a1c:	10801004 	addi	r2,r2,64
 8223a20:	00c01e04 	movi	r3,120
 8223a24:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 8223a28:	01020974 	movhi	r4,2085
 8223a2c:	213d2304 	addi	r4,r4,-2932
 8223a30:	82031200 	call	8203120 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223a34:	e0bfff17 	ldw	r2,-4(fp)
 8223a38:	1080a004 	addi	r2,r2,640
 8223a3c:	10800037 	ldwio	r2,0(r2)
 8223a40:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 8223a44:	e0bfff17 	ldw	r2,-4(fp)
 8223a48:	1080a004 	addi	r2,r2,640
 8223a4c:	e13ffe0b 	ldhu	r4,-8(fp)
 8223a50:	00e00004 	movi	r3,-32768
 8223a54:	20c6b03a 	or	r3,r4,r3
 8223a58:	18ffffcc 	andi	r3,r3,65535
 8223a5c:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 8223a60:	0005883a 	mov	r2,zero
}
 8223a64:	e037883a 	mov	sp,fp
 8223a68:	dfc00117 	ldw	ra,4(sp)
 8223a6c:	df000017 	ldw	fp,0(sp)
 8223a70:	dec00204 	addi	sp,sp,8
 8223a74:	f800283a 	ret

08223a78 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 8223a78:	defffc04 	addi	sp,sp,-16
 8223a7c:	dfc00315 	stw	ra,12(sp)
 8223a80:	df000215 	stw	fp,8(sp)
 8223a84:	df000204 	addi	fp,sp,8
 8223a88:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223a8c:	e0bfff17 	ldw	r2,-4(fp)
 8223a90:	1080bb04 	addi	r2,r2,748
 8223a94:	10800037 	ldwio	r2,0(r2)
 8223a98:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223a9c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223aa0:	00bffc04 	movi	r2,-16
 8223aa4:	1884703a 	and	r2,r3,r2
 8223aa8:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 8223aac:	01020974 	movhi	r4,2085
 8223ab0:	213d2804 	addi	r4,r4,-2912
 8223ab4:	82031200 	call	8203120 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 8223ab8:	e0bfff17 	ldw	r2,-4(fp)
 8223abc:	1080bb04 	addi	r2,r2,748
 8223ac0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ac4:	18c003d4 	ori	r3,r3,15
 8223ac8:	18ffffcc 	andi	r3,r3,65535
 8223acc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223ad0:	01020974 	movhi	r4,2085
 8223ad4:	213d3404 	addi	r4,r4,-2864
 8223ad8:	82031200 	call	8203120 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223adc:	e0bfff17 	ldw	r2,-4(fp)
 8223ae0:	1080b404 	addi	r2,r2,720
 8223ae4:	10800037 	ldwio	r2,0(r2)
 8223ae8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223aec:	e0fffe0b 	ldhu	r3,-8(fp)
 8223af0:	00bfdf44 	movi	r2,-131
 8223af4:	1884703a 	and	r2,r3,r2
 8223af8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223afc:	e0bfff17 	ldw	r2,-4(fp)
 8223b00:	1080b404 	addi	r2,r2,720
 8223b04:	e0fffe0b 	ldhu	r3,-8(fp)
 8223b08:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223b0c:	01020974 	movhi	r4,2085
 8223b10:	213d2304 	addi	r4,r4,-2932
 8223b14:	82031200 	call	8203120 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223b18:	e0bfff17 	ldw	r2,-4(fp)
 8223b1c:	1080a004 	addi	r2,r2,640
 8223b20:	10800037 	ldwio	r2,0(r2)
 8223b24:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223b28:	e0bfff17 	ldw	r2,-4(fp)
 8223b2c:	1080a004 	addi	r2,r2,640
 8223b30:	e13ffe0b 	ldhu	r4,-8(fp)
 8223b34:	00e00004 	movi	r3,-32768
 8223b38:	20c6b03a 	or	r3,r4,r3
 8223b3c:	18ffffcc 	andi	r3,r3,65535
 8223b40:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223b44:	00800044 	movi	r2,1
}
 8223b48:	e037883a 	mov	sp,fp
 8223b4c:	dfc00117 	ldw	ra,4(sp)
 8223b50:	df000017 	ldw	fp,0(sp)
 8223b54:	dec00204 	addi	sp,sp,8
 8223b58:	f800283a 	ret

08223b5c <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 8223b5c:	defffc04 	addi	sp,sp,-16
 8223b60:	dfc00315 	stw	ra,12(sp)
 8223b64:	df000215 	stw	fp,8(sp)
 8223b68:	df000204 	addi	fp,sp,8
 8223b6c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223b70:	e0bfff17 	ldw	r2,-4(fp)
 8223b74:	1080bb04 	addi	r2,r2,748
 8223b78:	10800037 	ldwio	r2,0(r2)
 8223b7c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223b80:	e0fffe0b 	ldhu	r3,-8(fp)
 8223b84:	00bffc04 	movi	r2,-16
 8223b88:	1884703a 	and	r2,r3,r2
 8223b8c:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 8223b90:	01020974 	movhi	r4,2085
 8223b94:	213d3e04 	addi	r4,r4,-2824
 8223b98:	82031200 	call	8203120 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 8223b9c:	e0bfff17 	ldw	r2,-4(fp)
 8223ba0:	1080bb04 	addi	r2,r2,748
 8223ba4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ba8:	18c00114 	ori	r3,r3,4
 8223bac:	18ffffcc 	andi	r3,r3,65535
 8223bb0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223bb4:	01020974 	movhi	r4,2085
 8223bb8:	213d3404 	addi	r4,r4,-2864
 8223bbc:	82031200 	call	8203120 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223bc0:	e0bfff17 	ldw	r2,-4(fp)
 8223bc4:	1080b404 	addi	r2,r2,720
 8223bc8:	10800037 	ldwio	r2,0(r2)
 8223bcc:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223bd0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223bd4:	00bfdf44 	movi	r2,-131
 8223bd8:	1884703a 	and	r2,r3,r2
 8223bdc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223be0:	e0bfff17 	ldw	r2,-4(fp)
 8223be4:	1080b404 	addi	r2,r2,720
 8223be8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223bec:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223bf0:	01020974 	movhi	r4,2085
 8223bf4:	213d2304 	addi	r4,r4,-2932
 8223bf8:	82031200 	call	8203120 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223bfc:	e0bfff17 	ldw	r2,-4(fp)
 8223c00:	1080a004 	addi	r2,r2,640
 8223c04:	10800037 	ldwio	r2,0(r2)
 8223c08:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223c0c:	e0bfff17 	ldw	r2,-4(fp)
 8223c10:	1080a004 	addi	r2,r2,640
 8223c14:	e13ffe0b 	ldhu	r4,-8(fp)
 8223c18:	00e00004 	movi	r3,-32768
 8223c1c:	20c6b03a 	or	r3,r4,r3
 8223c20:	18ffffcc 	andi	r3,r3,65535
 8223c24:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223c28:	00800044 	movi	r2,1
}
 8223c2c:	e037883a 	mov	sp,fp
 8223c30:	dfc00117 	ldw	ra,4(sp)
 8223c34:	df000017 	ldw	fp,0(sp)
 8223c38:	dec00204 	addi	sp,sp,8
 8223c3c:	f800283a 	ret

08223c40 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 8223c40:	defffc04 	addi	sp,sp,-16
 8223c44:	dfc00315 	stw	ra,12(sp)
 8223c48:	df000215 	stw	fp,8(sp)
 8223c4c:	df000204 	addi	fp,sp,8
 8223c50:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223c54:	e0bfff17 	ldw	r2,-4(fp)
 8223c58:	1080bb04 	addi	r2,r2,748
 8223c5c:	10800037 	ldwio	r2,0(r2)
 8223c60:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223c64:	e0fffe0b 	ldhu	r3,-8(fp)
 8223c68:	00bffc04 	movi	r2,-16
 8223c6c:	1884703a 	and	r2,r3,r2
 8223c70:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 8223c74:	01020974 	movhi	r4,2085
 8223c78:	213d5304 	addi	r4,r4,-2740
 8223c7c:	82031200 	call	8203120 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 8223c80:	e0bfff17 	ldw	r2,-4(fp)
 8223c84:	1080bb04 	addi	r2,r2,748
 8223c88:	e0fffe0b 	ldhu	r3,-8(fp)
 8223c8c:	18c002d4 	ori	r3,r3,11
 8223c90:	18ffffcc 	andi	r3,r3,65535
 8223c94:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 8223c98:	01020974 	movhi	r4,2085
 8223c9c:	213d6204 	addi	r4,r4,-2680
 8223ca0:	82031200 	call	8203120 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 8223ca4:	e0bfff17 	ldw	r2,-4(fp)
 8223ca8:	1080b404 	addi	r2,r2,720
 8223cac:	10800037 	ldwio	r2,0(r2)
 8223cb0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223cb4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223cb8:	00bfdf44 	movi	r2,-131
 8223cbc:	1884703a 	and	r2,r3,r2
 8223cc0:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 8223cc4:	e0bffe0b 	ldhu	r2,-8(fp)
 8223cc8:	10802094 	ori	r2,r2,130
 8223ccc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 8223cd0:	e0bfff17 	ldw	r2,-4(fp)
 8223cd4:	1080b404 	addi	r2,r2,720
 8223cd8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223cdc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223ce0:	01020974 	movhi	r4,2085
 8223ce4:	213d2304 	addi	r4,r4,-2932
 8223ce8:	82031200 	call	8203120 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223cec:	e0bfff17 	ldw	r2,-4(fp)
 8223cf0:	1080a004 	addi	r2,r2,640
 8223cf4:	10800037 	ldwio	r2,0(r2)
 8223cf8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223cfc:	e0bfff17 	ldw	r2,-4(fp)
 8223d00:	1080a004 	addi	r2,r2,640
 8223d04:	e13ffe0b 	ldhu	r4,-8(fp)
 8223d08:	00e00004 	movi	r3,-32768
 8223d0c:	20c6b03a 	or	r3,r4,r3
 8223d10:	18ffffcc 	andi	r3,r3,65535
 8223d14:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223d18:	00800044 	movi	r2,1
    
}
 8223d1c:	e037883a 	mov	sp,fp
 8223d20:	dfc00117 	ldw	ra,4(sp)
 8223d24:	df000017 	ldw	fp,0(sp)
 8223d28:	dec00204 	addi	sp,sp,8
 8223d2c:	f800283a 	ret

08223d30 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 8223d30:	defffc04 	addi	sp,sp,-16
 8223d34:	df000315 	stw	fp,12(sp)
 8223d38:	df000304 	addi	fp,sp,12
 8223d3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 8223d40:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 8223d44:	e0bfff17 	ldw	r2,-4(fp)
 8223d48:	1080b004 	addi	r2,r2,704
 8223d4c:	10800037 	ldwio	r2,0(r2)
 8223d50:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 8223d54:	e0bffe17 	ldw	r2,-8(fp)
 8223d58:	1080008c 	andi	r2,r2,2
 8223d5c:	10000426 	beq	r2,zero,8223d70 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 8223d60:	e0bffd17 	ldw	r2,-12(fp)
 8223d64:	10800214 	ori	r2,r2,8
 8223d68:	e0bffd15 	stw	r2,-12(fp)
 8223d6c:	00000306 	br	8223d7c <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 8223d70:	e0bffd17 	ldw	r2,-12(fp)
 8223d74:	10800114 	ori	r2,r2,4
 8223d78:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 8223d7c:	e0bffe17 	ldw	r2,-8(fp)
 8223d80:	1080010c 	andi	r2,r2,4
 8223d84:	10000326 	beq	r2,zero,8223d94 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 8223d88:	e0bffd17 	ldw	r2,-12(fp)
 8223d8c:	10800054 	ori	r2,r2,1
 8223d90:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 8223d94:	e0bffd17 	ldw	r2,-12(fp)
}
 8223d98:	e037883a 	mov	sp,fp
 8223d9c:	df000017 	ldw	fp,0(sp)
 8223da0:	dec00104 	addi	sp,sp,4
 8223da4:	f800283a 	ret

08223da8 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 8223da8:	defffa04 	addi	sp,sp,-24
 8223dac:	dfc00515 	stw	ra,20(sp)
 8223db0:	df000415 	stw	fp,16(sp)
 8223db4:	df000404 	addi	fp,sp,16
 8223db8:	e13fff15 	stw	r4,-4(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 8223dbc:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_system_info *psys_info = 0;
 8223dc0:	e03ffe15 	stw	zero,-8(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 8223dc4:	e03ffc15 	stw	zero,-16(fp)
 8223dc8:	00001106 	br	8223e10 <altera_eth_tse_init+0x68>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 8223dcc:	008209b4 	movhi	r2,2086
 8223dd0:	10b59504 	addi	r2,r2,-10668
 8223dd4:	e0fffc17 	ldw	r3,-16(fp)
 8223dd8:	18c00324 	muli	r3,r3,12
 8223ddc:	10c5883a 	add	r2,r2,r3
 8223de0:	10c00017 	ldw	r3,0(r2)
 8223de4:	e0bfff17 	ldw	r2,-4(fp)
 8223de8:	1880061e 	bne	r3,r2,8223e04 <altera_eth_tse_init+0x5c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 8223dec:	e0bffc17 	ldw	r2,-16(fp)
 8223df0:	10c00324 	muli	r3,r2,12
 8223df4:	008209b4 	movhi	r2,2086
 8223df8:	10b59504 	addi	r2,r2,-10668
 8223dfc:	1885883a 	add	r2,r3,r2
 8223e00:	e0bffd15 	stw	r2,-12(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 8223e04:	e0bffc17 	ldw	r2,-16(fp)
 8223e08:	10800044 	addi	r2,r2,1
 8223e0c:	e0bffc15 	stw	r2,-16(fp)
 8223e10:	d0a08003 	ldbu	r2,-32256(gp)
 8223e14:	10803fcc 	andi	r2,r2,255
 8223e18:	e0fffc17 	ldw	r3,-16(fp)
 8223e1c:	18bfeb16 	blt	r3,r2,8223dcc <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 8223e20:	e0bffd17 	ldw	r2,-12(fp)
 8223e24:	1000021e 	bne	r2,zero,8223e30 <altera_eth_tse_init+0x88>
        return ENP_HARDWARE;
 8223e28:	00bff744 	movi	r2,-35
 8223e2c:	00002706 	br	8223ecc <altera_eth_tse_init+0x124>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8223e30:	e03ffc15 	stw	zero,-16(fp)
 8223e34:	00001206 	br	8223e80 <altera_eth_tse_init+0xd8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 8223e38:	00820974 	movhi	r2,2085
 8223e3c:	10864f04 	addi	r2,r2,6460
 8223e40:	e0fffc17 	ldw	r3,-16(fp)
 8223e44:	18c01224 	muli	r3,r3,72
 8223e48:	10c5883a 	add	r2,r2,r3
 8223e4c:	10c00017 	ldw	r3,0(r2)
 8223e50:	e0bffd17 	ldw	r2,-12(fp)
 8223e54:	10800117 	ldw	r2,4(r2)
 8223e58:	1880061e 	bne	r3,r2,8223e74 <altera_eth_tse_init+0xcc>
            psys_info = &tse_mac_device[i];
 8223e5c:	e0bffc17 	ldw	r2,-16(fp)
 8223e60:	10c01224 	muli	r3,r2,72
 8223e64:	00820974 	movhi	r2,2085
 8223e68:	10864f04 	addi	r2,r2,6460
 8223e6c:	1885883a 	add	r2,r3,r2
 8223e70:	e0bffe15 	stw	r2,-8(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8223e74:	e0bffc17 	ldw	r2,-16(fp)
 8223e78:	10800044 	addi	r2,r2,1
 8223e7c:	e0bffc15 	stw	r2,-16(fp)
 8223e80:	d0a02d03 	ldbu	r2,-32588(gp)
 8223e84:	10803fcc 	andi	r2,r2,255
 8223e88:	e0fffc17 	ldw	r3,-16(fp)
 8223e8c:	18bfea16 	blt	r3,r2,8223e38 <altera_eth_tse_init+0x90>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 8223e90:	e0bffe17 	ldw	r2,-8(fp)
 8223e94:	1000021e 	bne	r2,zero,8223ea0 <altera_eth_tse_init+0xf8>
        return ENP_HARDWARE;
 8223e98:	00bff744 	movi	r2,-35
 8223e9c:	00000b06 	br	8223ecc <altera_eth_tse_init+0x124>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 8223ea0:	e0bfff17 	ldw	r2,-4(fp)
 8223ea4:	11000517 	ldw	r4,20(r2)
 8223ea8:	e0bffd17 	ldw	r2,-12(fp)
 8223eac:	10800203 	ldbu	r2,8(r2)
 8223eb0:	10803fcc 	andi	r2,r2,255
 8223eb4:	10801224 	muli	r2,r2,72
 8223eb8:	e0fffe17 	ldw	r3,-8(fp)
 8223ebc:	1885883a 	add	r2,r3,r2
 8223ec0:	100b883a 	mov	r5,r2
 8223ec4:	8223ee00 	call	8223ee0 <prep_tse_mac>
    
    return SUCCESS;
 8223ec8:	0005883a 	mov	r2,zero
}
 8223ecc:	e037883a 	mov	sp,fp
 8223ed0:	dfc00117 	ldw	ra,4(sp)
 8223ed4:	df000017 	ldw	fp,0(sp)
 8223ed8:	dec00204 	addi	sp,sp,8
 8223edc:	f800283a 	ret

08223ee0 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 8223ee0:	defffb04 	addi	sp,sp,-20
 8223ee4:	dfc00415 	stw	ra,16(sp)
 8223ee8:	df000315 	stw	fp,12(sp)
 8223eec:	df000304 	addi	fp,sp,12
 8223ef0:	e13ffe15 	stw	r4,-8(fp)
 8223ef4:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 8223ef8:	e17ffe17 	ldw	r5,-8(fp)
 8223efc:	01020974 	movhi	r4,2085
 8223f00:	213d6c04 	addi	r4,r4,-2640
 8223f04:	8202e9c0 	call	8202e9c <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 8223f08:	008209b4 	movhi	r2,2086
 8223f0c:	10b5a104 	addi	r2,r2,-10620
 8223f10:	e0fffe17 	ldw	r3,-8(fp)
 8223f14:	18c01324 	muli	r3,r3,76
 8223f18:	10c5883a 	add	r2,r2,r3
 8223f1c:	10800c04 	addi	r2,r2,48
 8223f20:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 8223f24:	008209b4 	movhi	r2,2086
 8223f28:	10b5a104 	addi	r2,r2,-10620
 8223f2c:	e0fffe17 	ldw	r3,-8(fp)
 8223f30:	18c01324 	muli	r3,r3,76
 8223f34:	10c5883a 	add	r2,r2,r3
 8223f38:	10801204 	addi	r2,r2,72
 8223f3c:	e0ffff17 	ldw	r3,-4(fp)
 8223f40:	10c00015 	stw	r3,0(r2)

        ifp = nets[index];
 8223f44:	008209b4 	movhi	r2,2086
 8223f48:	10b6b204 	addi	r2,r2,-9528
 8223f4c:	e0fffe17 	ldw	r3,-8(fp)
 8223f50:	18c7883a 	add	r3,r3,r3
 8223f54:	18c7883a 	add	r3,r3,r3
 8223f58:	10c5883a 	add	r2,r2,r3
 8223f5c:	10800017 	ldw	r2,0(r2)
 8223f60:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 8223f64:	e0bffd17 	ldw	r2,-12(fp)
 8223f68:	10802717 	ldw	r2,156(r2)
 8223f6c:	00c00084 	movi	r3,2
 8223f70:	10c00615 	stw	r3,24(r2)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 8223f74:	e0bffd17 	ldw	r2,-12(fp)
 8223f78:	10802717 	ldw	r2,156(r2)
 8223f7c:	00c00084 	movi	r3,2
 8223f80:	10c00715 	stw	r3,28(r2)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 8223f84:	e0bffd17 	ldw	r2,-12(fp)
 8223f88:	10802717 	ldw	r2,156(r2)
 8223f8c:	d0e0a817 	ldw	r3,-32096(gp)
 8223f90:	10c00815 	stw	r3,32(r2)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 8223f94:	e0bffd17 	ldw	r2,-12(fp)
 8223f98:	10c02717 	ldw	r3,156(r2)
 8223f9c:	e0bffe17 	ldw	r2,-8(fp)
 8223fa0:	10801324 	muli	r2,r2,76
 8223fa4:	11000604 	addi	r4,r2,24
 8223fa8:	008209b4 	movhi	r2,2086
 8223fac:	10b5a104 	addi	r2,r2,-10620
 8223fb0:	2085883a 	add	r2,r4,r2
 8223fb4:	18800515 	stw	r2,20(r3)
        ifp->n_mib->ifDescr =       "Altera TSE MAC ethernet";
 8223fb8:	e0bffd17 	ldw	r2,-12(fp)
 8223fbc:	10c02717 	ldw	r3,156(r2)
 8223fc0:	00820974 	movhi	r2,2085
 8223fc4:	10bd7104 	addi	r2,r2,-2620
 8223fc8:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 8223fcc:	e0bffd17 	ldw	r2,-12(fp)
 8223fd0:	00c00404 	movi	r3,16
 8223fd4:	10c00815 	stw	r3,32(r2)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 8223fd8:	e0bffd17 	ldw	r2,-12(fp)
 8223fdc:	00c00184 	movi	r3,6
 8223fe0:	10c01115 	stw	r3,68(r2)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 8223fe4:	e0bffd17 	ldw	r2,-12(fp)
 8223fe8:	10802717 	ldw	r2,156(r2)
 8223fec:	00c00184 	movi	r3,6
 8223ff0:	10c00215 	stw	r3,8(r2)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 8223ff4:	e0bffd17 	ldw	r2,-12(fp)
 8223ff8:	00c17a84 	movi	r3,1514
 8223ffc:	10c00915 	stw	r3,36(r2)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 8224000:	e0fffd17 	ldw	r3,-12(fp)
 8224004:	008208b4 	movhi	r2,2082
 8224008:	10904e04 	addi	r2,r2,16696
 822400c:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 8224010:	e0bffd17 	ldw	r2,-12(fp)
 8224014:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 8224018:	e0fffd17 	ldw	r3,-12(fp)
 822401c:	008208b4 	movhi	r2,2082
 8224020:	1092e604 	addi	r2,r2,19352
 8224024:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 8224028:	e0fffd17 	ldw	r3,-12(fp)
 822402c:	008208b4 	movhi	r2,2082
 8224030:	1094da04 	addi	r2,r2,21352
 8224034:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 8224038:	e0fffd17 	ldw	r3,-12(fp)
 822403c:	008208b4 	movhi	r2,2082
 8224040:	1094ca04 	addi	r2,r2,21288
 8224044:	18800715 	stw	r2,28(r3)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 8224048:	e0bffd17 	ldw	r2,-12(fp)
 822404c:	10802a17 	ldw	r2,168(r2)
 8224050:	10c00214 	ori	r3,r2,8
 8224054:	e0bffd17 	ldw	r2,-12(fp)
 8224058:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 822405c:	008209b4 	movhi	r2,2086
 8224060:	10b6b204 	addi	r2,r2,-9528
 8224064:	e0fffe17 	ldw	r3,-8(fp)
 8224068:	18c7883a 	add	r3,r3,r3
 822406c:	18c7883a 	add	r3,r3,r3
 8224070:	10c5883a 	add	r2,r2,r3
 8224074:	10800017 	ldw	r2,0(r2)
 8224078:	10c02717 	ldw	r3,156(r2)
 822407c:	e0bffe17 	ldw	r2,-8(fp)
 8224080:	10801324 	muli	r2,r2,76
 8224084:	11000604 	addi	r4,r2,24
 8224088:	008209b4 	movhi	r2,2086
 822408c:	10b5a104 	addi	r2,r2,-10620
 8224090:	2085883a 	add	r2,r4,r2
 8224094:	18800515 	stw	r2,20(r3)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 8224098:	e0bffe17 	ldw	r2,-8(fp)
 822409c:	10801324 	muli	r2,r2,76
 82240a0:	10c00604 	addi	r3,r2,24
 82240a4:	008209b4 	movhi	r2,2086
 82240a8:	10b5a104 	addi	r2,r2,-10620
 82240ac:	1885883a 	add	r2,r3,r2
 82240b0:	100b883a 	mov	r5,r2
 82240b4:	e13ffd17 	ldw	r4,-12(fp)
 82240b8:	82010c40 	call	82010c4 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 82240bc:	008209b4 	movhi	r2,2086
 82240c0:	10b5a104 	addi	r2,r2,-10620
 82240c4:	e0fffe17 	ldw	r3,-8(fp)
 82240c8:	18c01324 	muli	r3,r3,76
 82240cc:	10c5883a 	add	r2,r2,r3
 82240d0:	e0fffe17 	ldw	r3,-8(fp)
 82240d4:	10c00015 	stw	r3,0(r2)
        tse[index].netp = ifp;
 82240d8:	008209b4 	movhi	r2,2086
 82240dc:	10b5a104 	addi	r2,r2,-10620
 82240e0:	e0fffe17 	ldw	r3,-8(fp)
 82240e4:	18c01324 	muli	r3,r3,76
 82240e8:	10c5883a 	add	r2,r2,r3
 82240ec:	10800804 	addi	r2,r2,32
 82240f0:	e0fffd17 	ldw	r3,-12(fp)
 82240f4:	10c00015 	stw	r3,0(r2)
        ifp->n_local = (void*)(&tse[index]);
 82240f8:	e0bffe17 	ldw	r2,-8(fp)
 82240fc:	10c01324 	muli	r3,r2,76
 8224100:	008209b4 	movhi	r2,2086
 8224104:	10b5a104 	addi	r2,r2,-10620
 8224108:	1887883a 	add	r3,r3,r2
 822410c:	e0bffd17 	ldw	r2,-12(fp)
 8224110:	10c02815 	stw	r3,160(r2)
    
        index++;
 8224114:	e0bffe17 	ldw	r2,-8(fp)
 8224118:	10800044 	addi	r2,r2,1
 822411c:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 8224120:	e0bffe17 	ldw	r2,-8(fp)
}
 8224124:	e037883a 	mov	sp,fp
 8224128:	dfc00117 	ldw	ra,4(sp)
 822412c:	df000017 	ldw	fp,0(sp)
 8224130:	dec00204 	addi	sp,sp,8
 8224134:	f800283a 	ret

08224138 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 8224138:	defff004 	addi	sp,sp,-64
 822413c:	dfc00f15 	stw	ra,60(sp)
 8224140:	df000e15 	stw	fp,56(sp)
 8224144:	df000e04 	addi	fp,sp,56
 8224148:	e13fff15 	stw	r4,-4(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 822414c:	e03ff815 	stw	zero,-32(fp)
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 8224150:	008209b4 	movhi	r2,2086
 8224154:	10b5a104 	addi	r2,r2,-10620
 8224158:	e0ffff17 	ldw	r3,-4(fp)
 822415c:	18c01324 	muli	r3,r3,76
 8224160:	10c5883a 	add	r2,r2,r3
 8224164:	10801204 	addi	r2,r2,72
 8224168:	10800017 	ldw	r2,0(r2)
 822416c:	e0bff915 	stw	r2,-28(fp)
   
   dprintf("[tse_mac_init]\n");
 8224170:	01020974 	movhi	r4,2085
 8224174:	213d7704 	addi	r4,r4,-2596
 8224178:	82031200 	call	8203120 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 822417c:	e0bff917 	ldw	r2,-28(fp)
 8224180:	10800783 	ldbu	r2,30(r2)
 8224184:	10803fcc 	andi	r2,r2,255
 8224188:	10800058 	cmpnei	r2,r2,1
 822418c:	10000b1e 	bne	r2,zero,82241bc <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 8224190:	e0bff917 	ldw	r2,-28(fp)
 8224194:	10800817 	ldw	r2,32(r2)
 8224198:	1009883a 	mov	r4,r2
 822419c:	008209b4 	movhi	r2,2086
 82241a0:	10b5a104 	addi	r2,r2,-10620
 82241a4:	e0ffff17 	ldw	r3,-4(fp)
 82241a8:	18c01324 	muli	r3,r3,76
 82241ac:	10c5883a 	add	r2,r2,r3
 82241b0:	10800f04 	addi	r2,r2,60
 82241b4:	11000015 	stw	r4,0(r2)
 82241b8:	00001206 	br	8224204 <tse_mac_init+0xcc>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 82241bc:	01002804 	movi	r4,160
 82241c0:	823c7580 	call	823c758 <alt_uncached_malloc>
 82241c4:	e0bff515 	stw	r2,-44(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82241c8:	00000306 	br	82241d8 <tse_mac_init+0xa0>
        {
            temp_desc++;
 82241cc:	e0bff517 	ldw	r2,-44(fp)
 82241d0:	10800044 	addi	r2,r2,1
 82241d4:	e0bff515 	stw	r2,-44(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82241d8:	e0bff517 	ldw	r2,-44(fp)
 82241dc:	108007cc 	andi	r2,r2,31
 82241e0:	103ffa1e 	bne	r2,zero,82241cc <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 82241e4:	008209b4 	movhi	r2,2086
 82241e8:	10b5a104 	addi	r2,r2,-10620
 82241ec:	e0ffff17 	ldw	r3,-4(fp)
 82241f0:	18c01324 	muli	r3,r3,76
 82241f4:	10c5883a 	add	r2,r2,r3
 82241f8:	10800f04 	addi	r2,r2,60
 82241fc:	e0fff517 	ldw	r3,-44(fp)
 8224200:	10c00015 	stw	r3,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 8224204:	e0bff917 	ldw	r2,-28(fp)
 8224208:	10800517 	ldw	r2,20(r2)
 822420c:	1009883a 	mov	r4,r2
 8224210:	821e5e80 	call	821e5e8 <alt_avalon_sgdma_open>
 8224214:	e0bffa15 	stw	r2,-24(fp)
   
   if(!sgdma_tx_dev) {
 8224218:	e0bffa17 	ldw	r2,-24(fp)
 822421c:	1000051e 	bne	r2,zero,8224234 <tse_mac_init+0xfc>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 8224220:	01020974 	movhi	r4,2085
 8224224:	213d7b04 	addi	r4,r4,-2580
 8224228:	82031200 	call	8203120 <puts>
      return ENP_RESOURCE;
 822422c:	00bffa84 	movi	r2,-22
 8224230:	00025406 	br	8224b84 <tse_mac_init+0xa4c>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 8224234:	e0bff917 	ldw	r2,-28(fp)
 8224238:	10800617 	ldw	r2,24(r2)
 822423c:	1009883a 	mov	r4,r2
 8224240:	821e5e80 	call	821e5e8 <alt_avalon_sgdma_open>
 8224244:	e0bffb15 	stw	r2,-20(fp)
   if(!sgdma_rx_dev) {
 8224248:	e0bffb17 	ldw	r2,-20(fp)
 822424c:	1000051e 	bne	r2,zero,8224264 <tse_mac_init+0x12c>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 8224250:	01020974 	movhi	r4,2085
 8224254:	213d8704 	addi	r4,r4,-2532
 8224258:	82031200 	call	8203120 <puts>
      return ENP_RESOURCE;
 822425c:	00bffa84 	movi	r2,-22
 8224260:	00024806 	br	8224b84 <tse_mac_init+0xa4c>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 8224264:	e0bfff17 	ldw	r2,-4(fp)
 8224268:	10801324 	muli	r2,r2,76
 822426c:	10c00104 	addi	r3,r2,4
 8224270:	008209b4 	movhi	r2,2086
 8224274:	10b5a104 	addi	r2,r2,-10620
 8224278:	1887883a 	add	r3,r3,r2
 822427c:	e0bff917 	ldw	r2,-28(fp)
 8224280:	10800017 	ldw	r2,0(r2)
 8224284:	e13ffa17 	ldw	r4,-24(fp)
 8224288:	e17ffb17 	ldw	r5,-20(fp)
 822428c:	d8000015 	stw	zero,0(sp)
 8224290:	280f883a 	mov	r7,r5
 8224294:	200d883a 	mov	r6,r4
 8224298:	100b883a 	mov	r5,r2
 822429c:	1809883a 	mov	r4,r3
 82242a0:	821ede80 	call	821ede8 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 82242a4:	008209b4 	movhi	r2,2086
 82242a8:	10b5a104 	addi	r2,r2,-10620
 82242ac:	e0ffff17 	ldw	r3,-4(fp)
 82242b0:	18c01324 	muli	r3,r3,76
 82242b4:	10c5883a 	add	r2,r2,r3
 82242b8:	10800304 	addi	r2,r2,12
 82242bc:	10800017 	ldw	r2,0(r2)
 82242c0:	10800317 	ldw	r2,12(r2)
 82242c4:	10800404 	addi	r2,r2,16
 82242c8:	00c00074 	movhi	r3,1
 82242cc:	10c00035 	stwio	r3,0(r2)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 82242d0:	008209b4 	movhi	r2,2086
 82242d4:	10b5a104 	addi	r2,r2,-10620
 82242d8:	e0ffff17 	ldw	r3,-4(fp)
 82242dc:	18c01324 	muli	r3,r3,76
 82242e0:	10c5883a 	add	r2,r2,r3
 82242e4:	10800304 	addi	r2,r2,12
 82242e8:	10800017 	ldw	r2,0(r2)
 82242ec:	10800317 	ldw	r2,12(r2)
 82242f0:	10800404 	addi	r2,r2,16
 82242f4:	0007883a 	mov	r3,zero
 82242f8:	10c00035 	stwio	r3,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 82242fc:	e0bff917 	ldw	r2,-28(fp)
 8224300:	1080070b 	ldhu	r2,28(r2)
 8224304:	10ffffcc 	andi	r3,r2,65535
 8224308:	008209b4 	movhi	r2,2086
 822430c:	10b5a104 	addi	r2,r2,-10620
 8224310:	e13fff17 	ldw	r4,-4(fp)
 8224314:	21001324 	muli	r4,r4,76
 8224318:	1105883a 	add	r2,r2,r4
 822431c:	10800904 	addi	r2,r2,36
 8224320:	10c00015 	stw	r3,0(r2)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 8224324:	008209b4 	movhi	r2,2086
 8224328:	10b5a104 	addi	r2,r2,-10620
 822432c:	e0ffff17 	ldw	r3,-4(fp)
 8224330:	18c01324 	muli	r3,r3,76
 8224334:	10c5883a 	add	r2,r2,r3
 8224338:	10800104 	addi	r2,r2,4
 822433c:	10800017 	ldw	r2,0(r2)
 8224340:	1009883a 	mov	r4,r2
 8224344:	82202740 	call	8220274 <getPHYSpeed>
 8224348:	e0bffc15 	stw	r2,-16(fp)
   speed = (result >> 1) & 0x07;
 822434c:	e0bffc17 	ldw	r2,-16(fp)
 8224350:	1005d07a 	srai	r2,r2,1
 8224354:	108001cc 	andi	r2,r2,7
 8224358:	e0bffd15 	stw	r2,-12(fp)
   duplex = result & 0x01;
 822435c:	e0bffc17 	ldw	r2,-16(fp)
 8224360:	1080004c 	andi	r2,r2,1
 8224364:	e0bffe15 	stw	r2,-8(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 8224368:	008209b4 	movhi	r2,2086
 822436c:	10b5a104 	addi	r2,r2,-10620
 8224370:	e0ffff17 	ldw	r3,-4(fp)
 8224374:	18c01324 	muli	r3,r3,76
 8224378:	10c5883a 	add	r2,r2,r3
 822437c:	10800104 	addi	r2,r2,4
 8224380:	10800017 	ldw	r2,0(r2)
 8224384:	10800204 	addi	r2,r2,8
 8224388:	00c800c4 	movi	r3,8195
 822438c:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 8224390:	e03ff415 	stw	zero,-48(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 8224394:	00000506 	br	82243ac <tse_mac_init+0x274>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 8224398:	e0bff417 	ldw	r2,-48(fp)
 822439c:	10c00044 	addi	r3,r2,1
 82243a0:	e0fff415 	stw	r3,-48(fp)
 82243a4:	1089c450 	cmplti	r2,r2,10001
 82243a8:	10000c26 	beq	r2,zero,82243dc <tse_mac_init+0x2a4>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 82243ac:	008209b4 	movhi	r2,2086
 82243b0:	10b5a104 	addi	r2,r2,-10620
 82243b4:	e0ffff17 	ldw	r3,-4(fp)
 82243b8:	18c01324 	muli	r3,r3,76
 82243bc:	10c5883a 	add	r2,r2,r3
 82243c0:	10800104 	addi	r2,r2,4
 82243c4:	10800017 	ldw	r2,0(r2)
 82243c8:	10800204 	addi	r2,r2,8
 82243cc:	10800037 	ldwio	r2,0(r2)
 82243d0:	1088000c 	andi	r2,r2,8192
 82243d4:	103ff01e 	bne	r2,zero,8224398 <tse_mac_init+0x260>
 82243d8:	00000106 	br	82243e0 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
 82243dc:	0001883a 	nop
     }
   }
   if(x >= 10000) {
 82243e0:	e0bff417 	ldw	r2,-48(fp)
 82243e4:	1089c410 	cmplti	r2,r2,10000
 82243e8:	1000031e 	bne	r2,zero,82243f8 <tse_mac_init+0x2c0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 82243ec:	01020974 	movhi	r4,2085
 82243f0:	213d9304 	addi	r4,r4,-2484
 82243f4:	82031200 	call	8203120 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82243f8:	008209b4 	movhi	r2,2086
 82243fc:	10b5a104 	addi	r2,r2,-10620
 8224400:	e0ffff17 	ldw	r3,-4(fp)
 8224404:	18c01324 	muli	r3,r3,76
 8224408:	10c5883a 	add	r2,r2,r3
 822440c:	10800104 	addi	r2,r2,4
 8224410:	10800017 	ldw	r2,0(r2)
 8224414:	10800204 	addi	r2,r2,8
 8224418:	10800037 	ldwio	r2,0(r2)
 822441c:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) {
 8224420:	e0bff317 	ldw	r2,-52(fp)
 8224424:	108000cc 	andi	r2,r2,3
 8224428:	10000526 	beq	r2,zero,8224440 <tse_mac_init+0x308>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 822442c:	e17ff317 	ldw	r5,-52(fp)
 8224430:	01020974 	movhi	r4,2085
 8224434:	213d9c04 	addi	r4,r4,-2448
 8224438:	8202e9c0 	call	8202e9c <printf>
 822443c:	00000506 	br	8224454 <tse_mac_init+0x31c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 8224440:	e1bff317 	ldw	r6,-52(fp)
 8224444:	e17ff417 	ldw	r5,-48(fp)
 8224448:	01020974 	movhi	r4,2085
 822444c:	213db004 	addi	r4,r4,-2368
 8224450:	8202e9c0 	call	8202e9c <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 8224454:	e0bff917 	ldw	r2,-28(fp)
 8224458:	10800903 	ldbu	r2,36(r2)
 822445c:	10803fcc 	andi	r2,r2,255
 8224460:	10800058 	cmpnei	r2,r2,1
 8224464:	1000331e 	bne	r2,zero,8224534 <tse_mac_init+0x3fc>
      int channel_loop = 0;
 8224468:	e03ff615 	stw	zero,-40(fp)
      int mac_loop = 0;
 822446c:	e03ff715 	stw	zero,-36(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224470:	e03ff615 	stw	zero,-40(fp)
 8224474:	00002b06 	br	8224524 <tse_mac_init+0x3ec>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 8224478:	e03ff715 	stw	zero,-36(fp)
 822447c:	00001b06 	br	82244ec <tse_mac_init+0x3b4>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 8224480:	008209b4 	movhi	r2,2086
 8224484:	10b58d04 	addi	r2,r2,-10700
 8224488:	e0fff617 	ldw	r3,-40(fp)
 822448c:	18c7883a 	add	r3,r3,r3
 8224490:	18c7883a 	add	r3,r3,r3
 8224494:	10c5883a 	add	r2,r2,r3
 8224498:	10c00017 	ldw	r3,0(r2)
 822449c:	e0bff717 	ldw	r2,-36(fp)
 82244a0:	10800044 	addi	r2,r2,1
 82244a4:	1085883a 	add	r2,r2,r2
 82244a8:	1085883a 	add	r2,r2,r2
 82244ac:	1885883a 	add	r2,r3,r2
 82244b0:	10800017 	ldw	r2,0(r2)
 82244b4:	10c00217 	ldw	r3,8(r2)
 82244b8:	e0bff917 	ldw	r2,-28(fp)
 82244bc:	1880081e 	bne	r3,r2,82244e0 <tse_mac_init+0x3a8>
            tse[iface].channel = mac_loop;
 82244c0:	008209b4 	movhi	r2,2086
 82244c4:	10b5a104 	addi	r2,r2,-10620
 82244c8:	e0ffff17 	ldw	r3,-4(fp)
 82244cc:	18c01324 	muli	r3,r3,76
 82244d0:	10c5883a 	add	r2,r2,r3
 82244d4:	10800d04 	addi	r2,r2,52
 82244d8:	e0fff717 	ldw	r3,-36(fp)
 82244dc:	10c00015 	stw	r3,0(r2)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 82244e0:	e0bff717 	ldw	r2,-36(fp)
 82244e4:	10800044 	addi	r2,r2,1
 82244e8:	e0bff715 	stw	r2,-36(fp)
 82244ec:	008209b4 	movhi	r2,2086
 82244f0:	10b58d04 	addi	r2,r2,-10700
 82244f4:	e0fff617 	ldw	r3,-40(fp)
 82244f8:	18c7883a 	add	r3,r3,r3
 82244fc:	18c7883a 	add	r3,r3,r3
 8224500:	10c5883a 	add	r2,r2,r3
 8224504:	10800017 	ldw	r2,0(r2)
 8224508:	10800003 	ldbu	r2,0(r2)
 822450c:	10803fcc 	andi	r2,r2,255
 8224510:	e0fff717 	ldw	r3,-36(fp)
 8224514:	18bfda16 	blt	r3,r2,8224480 <tse_mac_init+0x348>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224518:	e0bff617 	ldw	r2,-40(fp)
 822451c:	10800044 	addi	r2,r2,1
 8224520:	e0bff615 	stw	r2,-40(fp)
 8224524:	d0a07f43 	ldbu	r2,-32259(gp)
 8224528:	10803fcc 	andi	r2,r2,255
 822452c:	e0fff617 	ldw	r3,-40(fp)
 8224530:	18bfd116 	blt	r3,r2,8224478 <tse_mac_init+0x340>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 8224534:	e0bff917 	ldw	r2,-28(fp)
 8224538:	10800903 	ldbu	r2,36(r2)
 822453c:	10803fcc 	andi	r2,r2,255
 8224540:	10800058 	cmpnei	r2,r2,1
 8224544:	10000f1e 	bne	r2,zero,8224584 <tse_mac_init+0x44c>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 8224548:	e0bff917 	ldw	r2,-28(fp)
 822454c:	10800d17 	ldw	r2,52(r2)
 8224550:	1007883a 	mov	r3,r2
 8224554:	e0bff917 	ldw	r2,-28(fp)
 8224558:	10800f17 	ldw	r2,60(r2)
 822455c:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 8224560:	e0bff917 	ldw	r2,-28(fp)
 8224564:	10800d17 	ldw	r2,52(r2)
 8224568:	10800204 	addi	r2,r2,8
 822456c:	1007883a 	mov	r3,r2
 8224570:	e0bff917 	ldw	r2,-28(fp)
 8224574:	10800f17 	ldw	r2,60(r2)
 8224578:	10bfdd04 	addi	r2,r2,-140
 822457c:	18800035 	stwio	r2,0(r3)
 8224580:	00006006 	br	8224704 <tse_mac_init+0x5cc>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 8224584:	008209b4 	movhi	r2,2086
 8224588:	10b5a104 	addi	r2,r2,-10620
 822458c:	e0ffff17 	ldw	r3,-4(fp)
 8224590:	18c01324 	muli	r3,r3,76
 8224594:	10c5883a 	add	r2,r2,r3
 8224598:	10800104 	addi	r2,r2,4
 822459c:	10800017 	ldw	r2,0(r2)
 82245a0:	10800504 	addi	r2,r2,20
 82245a4:	00c17b84 	movi	r3,1518
 82245a8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 82245ac:	008209b4 	movhi	r2,2086
 82245b0:	10b5a104 	addi	r2,r2,-10620
 82245b4:	e0ffff17 	ldw	r3,-4(fp)
 82245b8:	18c01324 	muli	r3,r3,76
 82245bc:	10c5883a 	add	r2,r2,r3
 82245c0:	10800104 	addi	r2,r2,4
 82245c4:	10800017 	ldw	r2,0(r2)
 82245c8:	10800b04 	addi	r2,r2,44
 82245cc:	00c00204 	movi	r3,8
 82245d0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 82245d4:	008209b4 	movhi	r2,2086
 82245d8:	10b5a104 	addi	r2,r2,-10620
 82245dc:	e0ffff17 	ldw	r3,-4(fp)
 82245e0:	18c01324 	muli	r3,r3,76
 82245e4:	10c5883a 	add	r2,r2,r3
 82245e8:	10800104 	addi	r2,r2,4
 82245ec:	10800017 	ldw	r2,0(r2)
 82245f0:	10800c04 	addi	r2,r2,48
 82245f4:	00c00204 	movi	r3,8
 82245f8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 82245fc:	008209b4 	movhi	r2,2086
 8224600:	10b5a104 	addi	r2,r2,-10620
 8224604:	e0ffff17 	ldw	r3,-4(fp)
 8224608:	18c01324 	muli	r3,r3,76
 822460c:	10c5883a 	add	r2,r2,r3
 8224610:	10800104 	addi	r2,r2,4
 8224614:	10800017 	ldw	r2,0(r2)
 8224618:	10800d04 	addi	r2,r2,52
 822461c:	00c00204 	movi	r3,8
 8224620:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 8224624:	008209b4 	movhi	r2,2086
 8224628:	10b5a104 	addi	r2,r2,-10620
 822462c:	e0ffff17 	ldw	r3,-4(fp)
 8224630:	18c01324 	muli	r3,r3,76
 8224634:	10c5883a 	add	r2,r2,r3
 8224638:	10800104 	addi	r2,r2,4
 822463c:	10800017 	ldw	r2,0(r2)
 8224640:	10800e04 	addi	r2,r2,56
 8224644:	00c000c4 	movi	r3,3
 8224648:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 822464c:	008209b4 	movhi	r2,2086
 8224650:	10b5a104 	addi	r2,r2,-10620
 8224654:	e0ffff17 	ldw	r3,-4(fp)
 8224658:	18c01324 	muli	r3,r3,76
 822465c:	10c5883a 	add	r2,r2,r3
 8224660:	10800104 	addi	r2,r2,4
 8224664:	10800017 	ldw	r2,0(r2)
 8224668:	10800904 	addi	r2,r2,36
 822466c:	e0fff917 	ldw	r3,-28(fp)
 8224670:	18c0010b 	ldhu	r3,4(r3)
 8224674:	18ffffcc 	andi	r3,r3,65535
 8224678:	18fffc04 	addi	r3,r3,-16
 822467c:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 8224680:	008209b4 	movhi	r2,2086
 8224684:	10b5a104 	addi	r2,r2,-10620
 8224688:	e0ffff17 	ldw	r3,-4(fp)
 822468c:	18c01324 	muli	r3,r3,76
 8224690:	10c5883a 	add	r2,r2,r3
 8224694:	10800104 	addi	r2,r2,4
 8224698:	10800017 	ldw	r2,0(r2)
 822469c:	10800a04 	addi	r2,r2,40
 82246a0:	0007883a 	mov	r3,zero
 82246a4:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 82246a8:	008209b4 	movhi	r2,2086
 82246ac:	10b5a104 	addi	r2,r2,-10620
 82246b0:	e0ffff17 	ldw	r3,-4(fp)
 82246b4:	18c01324 	muli	r3,r3,76
 82246b8:	10c5883a 	add	r2,r2,r3
 82246bc:	10800104 	addi	r2,r2,4
 82246c0:	10800017 	ldw	r2,0(r2)
 82246c4:	10800704 	addi	r2,r2,28
 82246c8:	e0fff917 	ldw	r3,-28(fp)
 82246cc:	18c0018b 	ldhu	r3,6(r3)
 82246d0:	18ffffcc 	andi	r3,r3,65535
 82246d4:	18fffc04 	addi	r3,r3,-16
 82246d8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 82246dc:	008209b4 	movhi	r2,2086
 82246e0:	10b5a104 	addi	r2,r2,-10620
 82246e4:	e0ffff17 	ldw	r3,-4(fp)
 82246e8:	18c01324 	muli	r3,r3,76
 82246ec:	10c5883a 	add	r2,r2,r3
 82246f0:	10800104 	addi	r2,r2,4
 82246f4:	10800017 	ldw	r2,0(r2)
 82246f8:	10800804 	addi	r2,r2,32
 82246fc:	0007883a 	mov	r3,zero
 8224700:	10c00035 	stwio	r3,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 8224704:	008209b4 	movhi	r2,2086
 8224708:	10b5a104 	addi	r2,r2,-10620
 822470c:	e0ffff17 	ldw	r3,-4(fp)
 8224710:	18c01324 	muli	r3,r3,76
 8224714:	10c5883a 	add	r2,r2,r3
 8224718:	10800104 	addi	r2,r2,4
 822471c:	10800017 	ldw	r2,0(r2)
 8224720:	10803a04 	addi	r2,r2,232
 8224724:	00c00134 	movhi	r3,4
 8224728:	10c00035 	stwio	r3,0(r2)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 822472c:	008209b4 	movhi	r2,2086
 8224730:	10b5a104 	addi	r2,r2,-10620
 8224734:	e0ffff17 	ldw	r3,-4(fp)
 8224738:	18c01324 	muli	r3,r3,76
 822473c:	10c5883a 	add	r2,r2,r3
 8224740:	10800104 	addi	r2,r2,4
 8224744:	10800017 	ldw	r2,0(r2)
 8224748:	10803a04 	addi	r2,r2,232
 822474c:	10800037 	ldwio	r2,0(r2)
 8224750:	1080012c 	andhi	r2,r2,4
 8224754:	10001e26 	beq	r2,zero,82247d0 <tse_mac_init+0x698>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 8224758:	008209b4 	movhi	r2,2086
 822475c:	10b5a104 	addi	r2,r2,-10620
 8224760:	e0ffff17 	ldw	r3,-4(fp)
 8224764:	18c01324 	muli	r3,r3,76
 8224768:	10c5883a 	add	r2,r2,r3
 822476c:	10800a04 	addi	r2,r2,40
 8224770:	00c00044 	movi	r3,1
 8224774:	10c00015 	stw	r3,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 8224778:	008209b4 	movhi	r2,2086
 822477c:	10b5a104 	addi	r2,r2,-10620
 8224780:	e0ffff17 	ldw	r3,-4(fp)
 8224784:	18c01324 	muli	r3,r3,76
 8224788:	10c5883a 	add	r2,r2,r3
 822478c:	10800104 	addi	r2,r2,4
 8224790:	10800017 	ldw	r2,0(r2)
 8224794:	10803b04 	addi	r2,r2,236
 8224798:	00c08034 	movhi	r3,512
 822479c:	10c00035 	stwio	r3,0(r2)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 82247a0:	008209b4 	movhi	r2,2086
 82247a4:	10b5a104 	addi	r2,r2,-10620
 82247a8:	e0ffff17 	ldw	r3,-4(fp)
 82247ac:	18c01324 	muli	r3,r3,76
 82247b0:	10c5883a 	add	r2,r2,r3
 82247b4:	10800104 	addi	r2,r2,4
 82247b8:	10800017 	ldw	r2,0(r2)
 82247bc:	10803b04 	addi	r2,r2,236
 82247c0:	10800037 	ldwio	r2,0(r2)
 82247c4:	1080802c 	andhi	r2,r2,512
 82247c8:	10001d26 	beq	r2,zero,8224840 <tse_mac_init+0x708>
 82247cc:	00000d06 	br	8224804 <tse_mac_init+0x6cc>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 82247d0:	008209b4 	movhi	r2,2086
 82247d4:	10b5a104 	addi	r2,r2,-10620
 82247d8:	e0ffff17 	ldw	r3,-4(fp)
 82247dc:	18c01324 	muli	r3,r3,76
 82247e0:	10c5883a 	add	r2,r2,r3
 82247e4:	10800a04 	addi	r2,r2,40
 82247e8:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 82247ec:	01400084 	movi	r5,2
 82247f0:	01020974 	movhi	r4,2085
 82247f4:	213db804 	addi	r4,r4,-2336
 82247f8:	8202e9c0 	call	8202e9c <printf>
      return ENP_LOGIC;
 82247fc:	00bffd44 	movi	r2,-11
 8224800:	0000e006 	br	8224b84 <tse_mac_init+0xa4c>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 8224804:	008209b4 	movhi	r2,2086
 8224808:	10b5a104 	addi	r2,r2,-10620
 822480c:	e0ffff17 	ldw	r3,-4(fp)
 8224810:	18c01324 	muli	r3,r3,76
 8224814:	10c5883a 	add	r2,r2,r3
 8224818:	10800b04 	addi	r2,r2,44
 822481c:	00c00044 	movi	r3,1
 8224820:	10c00015 	stw	r3,0(r2)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 8224824:	00810034 	movhi	r2,1024
 8224828:	108080c4 	addi	r2,r2,515
 822482c:	e0bff315 	stw	r2,-52(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 8224830:	e0bffd17 	ldw	r2,-12(fp)
 8224834:	10800058 	cmpnei	r2,r2,1
 8224838:	1000171e 	bne	r2,zero,8224898 <tse_mac_init+0x760>
 822483c:	00000d06 	br	8224874 <tse_mac_init+0x73c>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 8224840:	008209b4 	movhi	r2,2086
 8224844:	10b5a104 	addi	r2,r2,-10620
 8224848:	e0ffff17 	ldw	r3,-4(fp)
 822484c:	18c01324 	muli	r3,r3,76
 8224850:	10c5883a 	add	r2,r2,r3
 8224854:	10800b04 	addi	r2,r2,44
 8224858:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 822485c:	01400084 	movi	r5,2
 8224860:	01020974 	movhi	r4,2085
 8224864:	213dd004 	addi	r4,r4,-2240
 8224868:	8202e9c0 	call	8202e9c <printf>
      return ENP_LOGIC;
 822486c:	00bffd44 	movi	r2,-11
 8224870:	0000c406 	br	8224b84 <tse_mac_init+0xa4c>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224874:	e0bff317 	ldw	r2,-52(fp)
 8224878:	10800214 	ori	r2,r2,8
 822487c:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224880:	e0fff317 	ldw	r3,-52(fp)
 8224884:	00bf8034 	movhi	r2,65024
 8224888:	10bfffc4 	addi	r2,r2,-1
 822488c:	1884703a 	and	r2,r3,r2
 8224890:	e0bff315 	stw	r2,-52(fp)
 8224894:	00002106 	br	822491c <tse_mac_init+0x7e4>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 8224898:	e0bffd17 	ldw	r2,-12(fp)
 822489c:	10800098 	cmpnei	r2,r2,2
 82248a0:	10000a1e 	bne	r2,zero,82248cc <tse_mac_init+0x794>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82248a4:	e0fff317 	ldw	r3,-52(fp)
 82248a8:	00bffdc4 	movi	r2,-9
 82248ac:	1884703a 	and	r2,r3,r2
 82248b0:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82248b4:	e0fff317 	ldw	r3,-52(fp)
 82248b8:	00bf8034 	movhi	r2,65024
 82248bc:	10bfffc4 	addi	r2,r2,-1
 82248c0:	1884703a 	and	r2,r3,r2
 82248c4:	e0bff315 	stw	r2,-52(fp)
 82248c8:	00001406 	br	822491c <tse_mac_init+0x7e4>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 82248cc:	e0bffd17 	ldw	r2,-12(fp)
 82248d0:	10800118 	cmpnei	r2,r2,4
 82248d4:	1000081e 	bne	r2,zero,82248f8 <tse_mac_init+0x7c0>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82248d8:	e0fff317 	ldw	r3,-52(fp)
 82248dc:	00bffdc4 	movi	r2,-9
 82248e0:	1884703a 	and	r2,r3,r2
 82248e4:	e0bff315 	stw	r2,-52(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82248e8:	e0bff317 	ldw	r2,-52(fp)
 82248ec:	10808034 	orhi	r2,r2,512
 82248f0:	e0bff315 	stw	r2,-52(fp)
 82248f4:	00000906 	br	822491c <tse_mac_init+0x7e4>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82248f8:	e0fff317 	ldw	r3,-52(fp)
 82248fc:	00bffdc4 	movi	r2,-9
 8224900:	1884703a 	and	r2,r3,r2
 8224904:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224908:	e0fff317 	ldw	r3,-52(fp)
 822490c:	00bf8034 	movhi	r2,65024
 8224910:	10bfffc4 	addi	r2,r2,-1
 8224914:	1884703a 	and	r2,r3,r2
 8224918:	e0bff315 	stw	r2,-52(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 822491c:	e0bffe17 	ldw	r2,-8(fp)
 8224920:	1000041e 	bne	r2,zero,8224934 <tse_mac_init+0x7fc>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224924:	e0bff317 	ldw	r2,-52(fp)
 8224928:	10810014 	ori	r2,r2,1024
 822492c:	e0bff315 	stw	r2,-52(fp)
 8224930:	00000406 	br	8224944 <tse_mac_init+0x80c>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224934:	e0fff317 	ldw	r3,-52(fp)
 8224938:	00beffc4 	movi	r2,-1025
 822493c:	1884703a 	and	r2,r3,r2
 8224940:	e0bff315 	stw	r2,-52(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 8224944:	008209b4 	movhi	r2,2086
 8224948:	10b5a104 	addi	r2,r2,-10620
 822494c:	e0ffff17 	ldw	r3,-4(fp)
 8224950:	18c01324 	muli	r3,r3,76
 8224954:	10c5883a 	add	r2,r2,r3
 8224958:	10800104 	addi	r2,r2,4
 822495c:	10800017 	ldw	r2,0(r2)
 8224960:	10800204 	addi	r2,r2,8
 8224964:	e0fff317 	ldw	r3,-52(fp)
 8224968:	10c00035 	stwio	r3,0(r2)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
 822496c:	008209b4 	movhi	r2,2086
 8224970:	10b5a104 	addi	r2,r2,-10620
 8224974:	e0ffff17 	ldw	r3,-4(fp)
 8224978:	18c01324 	muli	r3,r3,76
 822497c:	10c5883a 	add	r2,r2,r3
 8224980:	10800104 	addi	r2,r2,4
 8224984:	10800017 	ldw	r2,0(r2)
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 8224988:	10800204 	addi	r2,r2,8
 822498c:	10800037 	ldwio	r2,0(r2)
 8224990:	100b883a 	mov	r5,r2
 8224994:	01020974 	movhi	r4,2085
 8224998:	213de804 	addi	r4,r4,-2144
 822499c:	8202e9c0 	call	8202e9c <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 82249a0:	008209b4 	movhi	r2,2086
 82249a4:	10b5a104 	addi	r2,r2,-10620
 82249a8:	e0ffff17 	ldw	r3,-4(fp)
 82249ac:	18c01324 	muli	r3,r3,76
 82249b0:	10c5883a 	add	r2,r2,r3
 82249b4:	10800104 	addi	r2,r2,4
 82249b8:	10800017 	ldw	r2,0(r2)
 82249bc:	10c00304 	addi	r3,r2,12
 82249c0:	008209b4 	movhi	r2,2086
 82249c4:	10b5a104 	addi	r2,r2,-10620
 82249c8:	e13fff17 	ldw	r4,-4(fp)
 82249cc:	21001324 	muli	r4,r4,76
 82249d0:	1105883a 	add	r2,r2,r4
 82249d4:	10800604 	addi	r2,r2,24
 82249d8:	10800003 	ldbu	r2,0(r2)
 82249dc:	11003fcc 	andi	r4,r2,255
 82249e0:	008209b4 	movhi	r2,2086
 82249e4:	10b5a104 	addi	r2,r2,-10620
 82249e8:	e17fff17 	ldw	r5,-4(fp)
 82249ec:	29401324 	muli	r5,r5,76
 82249f0:	1145883a 	add	r2,r2,r5
 82249f4:	10800644 	addi	r2,r2,25
 82249f8:	10800003 	ldbu	r2,0(r2)
 82249fc:	10803fcc 	andi	r2,r2,255
 8224a00:	1004923a 	slli	r2,r2,8
 8224a04:	2088b03a 	or	r4,r4,r2
 8224a08:	008209b4 	movhi	r2,2086
 8224a0c:	10b5a104 	addi	r2,r2,-10620
 8224a10:	e17fff17 	ldw	r5,-4(fp)
 8224a14:	29401324 	muli	r5,r5,76
 8224a18:	1145883a 	add	r2,r2,r5
 8224a1c:	10800684 	addi	r2,r2,26
 8224a20:	10800003 	ldbu	r2,0(r2)
 8224a24:	10803fcc 	andi	r2,r2,255
 8224a28:	1004943a 	slli	r2,r2,16
 8224a2c:	2088b03a 	or	r4,r4,r2
 8224a30:	008209b4 	movhi	r2,2086
 8224a34:	10b5a104 	addi	r2,r2,-10620
 8224a38:	e17fff17 	ldw	r5,-4(fp)
 8224a3c:	29401324 	muli	r5,r5,76
 8224a40:	1145883a 	add	r2,r2,r5
 8224a44:	108006c4 	addi	r2,r2,27
 8224a48:	10800003 	ldbu	r2,0(r2)
 8224a4c:	10803fcc 	andi	r2,r2,255
 8224a50:	1004963a 	slli	r2,r2,24
 8224a54:	2084b03a 	or	r2,r4,r2
 8224a58:	18800035 	stwio	r2,0(r3)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 8224a5c:	008209b4 	movhi	r2,2086
 8224a60:	10b5a104 	addi	r2,r2,-10620
 8224a64:	e0ffff17 	ldw	r3,-4(fp)
 8224a68:	18c01324 	muli	r3,r3,76
 8224a6c:	10c5883a 	add	r2,r2,r3
 8224a70:	10800104 	addi	r2,r2,4
 8224a74:	10800017 	ldw	r2,0(r2)
 8224a78:	10c00404 	addi	r3,r2,16
 8224a7c:	008209b4 	movhi	r2,2086
 8224a80:	10b5a104 	addi	r2,r2,-10620
 8224a84:	e13fff17 	ldw	r4,-4(fp)
 8224a88:	21001324 	muli	r4,r4,76
 8224a8c:	1105883a 	add	r2,r2,r4
 8224a90:	10800704 	addi	r2,r2,28
 8224a94:	10800003 	ldbu	r2,0(r2)
 8224a98:	11003fcc 	andi	r4,r2,255
 8224a9c:	008209b4 	movhi	r2,2086
 8224aa0:	10b5a104 	addi	r2,r2,-10620
 8224aa4:	e17fff17 	ldw	r5,-4(fp)
 8224aa8:	29401324 	muli	r5,r5,76
 8224aac:	1145883a 	add	r2,r2,r5
 8224ab0:	10800744 	addi	r2,r2,29
 8224ab4:	10800003 	ldbu	r2,0(r2)
 8224ab8:	10803fcc 	andi	r2,r2,255
 8224abc:	1004923a 	slli	r2,r2,8
 8224ac0:	2084b03a 	or	r2,r4,r2
 8224ac4:	10bfffcc 	andi	r2,r2,65535
 8224ac8:	18800035 	stwio	r2,0(r3)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 8224acc:	008209b4 	movhi	r2,2086
 8224ad0:	10b6b204 	addi	r2,r2,-9528
 8224ad4:	e0ffff17 	ldw	r3,-4(fp)
 8224ad8:	18c7883a 	add	r3,r3,r3
 8224adc:	18c7883a 	add	r3,r3,r3
 8224ae0:	10c5883a 	add	r2,r2,r3
 8224ae4:	10800017 	ldw	r2,0(r2)
 8224ae8:	10802717 	ldw	r2,156(r2)
 8224aec:	00c00044 	movi	r3,1
 8224af0:	10c00615 	stw	r3,24(r2)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 8224af4:	008209b4 	movhi	r2,2086
 8224af8:	10b6b204 	addi	r2,r2,-9528
 8224afc:	e0ffff17 	ldw	r3,-4(fp)
 8224b00:	18c7883a 	add	r3,r3,r3
 8224b04:	18c7883a 	add	r3,r3,r3
 8224b08:	10c5883a 	add	r2,r2,r3
 8224b0c:	10800017 	ldw	r2,0(r2)
 8224b10:	10802717 	ldw	r2,156(r2)
 8224b14:	00c00044 	movi	r3,1
 8224b18:	10c00715 	stw	r3,28(r2)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224b1c:	008209b4 	movhi	r2,2086
 8224b20:	10b5a104 	addi	r2,r2,-10620
 8224b24:	e0ffff17 	ldw	r3,-4(fp)
 8224b28:	18c01324 	muli	r3,r3,76
 8224b2c:	10c5883a 	add	r2,r2,r3
 8224b30:	10800304 	addi	r2,r2,12
 8224b34:	11000017 	ldw	r4,0(r2)
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
 8224b38:	e0bfff17 	ldw	r2,-4(fp)
 8224b3c:	10c01324 	muli	r3,r2,76
 8224b40:	008209b4 	movhi	r2,2086
 8224b44:	10b5a104 	addi	r2,r2,-10620
 8224b48:	1885883a 	add	r2,r3,r2
   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224b4c:	100f883a 	mov	r7,r2
 8224b50:	01800604 	movi	r6,24
 8224b54:	014208b4 	movhi	r5,2082
 8224b58:	2953a404 	addi	r5,r5,20112
 8224b5c:	821e47c0 	call	821e47c <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 8224b60:	e0bfff17 	ldw	r2,-4(fp)
 8224b64:	10c01324 	muli	r3,r2,76
 8224b68:	008209b4 	movhi	r2,2086
 8224b6c:	10b5a104 	addi	r2,r2,-10620
 8224b70:	1885883a 	add	r2,r3,r2
 8224b74:	1009883a 	mov	r4,r2
 8224b78:	8224f3c0 	call	8224f3c <tse_sgdma_read_init>
 8224b7c:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 8224b80:	e0bff817 	ldw	r2,-32(fp)
}
 8224b84:	e037883a 	mov	sp,fp
 8224b88:	dfc00117 	ldw	ra,4(sp)
 8224b8c:	df000017 	ldw	fp,0(sp)
 8224b90:	dec00204 	addi	sp,sp,8
 8224b94:	f800283a 	ret

08224b98 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 8224b98:	defe6504 	addi	sp,sp,-1644
 8224b9c:	dfc19a15 	stw	ra,1640(sp)
 8224ba0:	df019915 	stw	fp,1636(sp)
 8224ba4:	df019904 	addi	fp,sp,1636
 8224ba8:	e13ffd15 	stw	r4,-12(fp)
 8224bac:	e17ffe15 	stw	r5,-8(fp)
 8224bb0:	e1bfff15 	stw	r6,-4(fp)
   int result,i;
   unsigned len = data_bytes;
 8224bb4:	e0bfff17 	ldw	r2,-4(fp)
 8224bb8:	e0be6e15 	stw	r2,-1608(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 8224bbc:	e0bffd17 	ldw	r2,-12(fp)
 8224bc0:	10802817 	ldw	r2,160(r2)
 8224bc4:	e0be6f15 	stw	r2,-1604(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 8224bc8:	e0be6f17 	ldw	r2,-1604(fp)
 8224bcc:	10801217 	ldw	r2,72(r2)
 8224bd0:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8224bd4:	0005303a 	rdctl	r2,status
 8224bd8:	e0be7615 	stw	r2,-1576(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8224bdc:	e0fe7617 	ldw	r3,-1576(fp)
 8224be0:	00bfff84 	movi	r2,-2
 8224be4:	1884703a 	and	r2,r3,r2
 8224be8:	1001703a 	wrctl	status,r2
  
  return context;
 8224bec:	e0be7617 	ldw	r2,-1576(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 8224bf0:	e0be7215 	stw	r2,-1592(fp)
   mi = &tse_ptr->mi;
 8224bf4:	e0be6f17 	ldw	r2,-1604(fp)
 8224bf8:	10800104 	addi	r2,r2,4
 8224bfc:	e0be7315 	stw	r2,-1588(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 8224c00:	e0be6f17 	ldw	r2,-1604(fp)
 8224c04:	10800c17 	ldw	r2,48(r2)
 8224c08:	10000926 	beq	r2,zero,8224c30 <tse_mac_raw_send+0x98>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 8224c0c:	01020974 	movhi	r4,2085
 8224c10:	213df404 	addi	r4,r4,-2096
 8224c14:	82031200 	call	8203120 <puts>
 8224c18:	e0be7217 	ldw	r2,-1592(fp)
 8224c1c:	e0be7115 	stw	r2,-1596(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8224c20:	e0be7117 	ldw	r2,-1596(fp)
 8224c24:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 8224c28:	00bffa84 	movi	r2,-22
 8224c2c:	00009306 	br	8224e7c <tse_mac_raw_send+0x2e4>
   }
 
   tse_ptr->sem = 1;  
 8224c30:	e0be6f17 	ldw	r2,-1604(fp)
 8224c34:	00c00044 	movi	r3,1
 8224c38:	10c00c15 	stw	r3,48(r2)

   if(((unsigned long)data & 0x03) == 0) 
 8224c3c:	e0bffe17 	ldw	r2,-8(fp)
 8224c40:	108000cc 	andi	r2,r2,3
 8224c44:	1000031e 	bne	r2,zero,8224c54 <tse_mac_raw_send+0xbc>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 8224c48:	e0bffe17 	ldw	r2,-8(fp)
 8224c4c:	e0be6d15 	stw	r2,-1612(fp)
 8224c50:	00001406 	br	8224ca4 <tse_mac_raw_send+0x10c>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8224c54:	e03e6c15 	stw	zero,-1616(fp)
 8224c58:	00000d06 	br	8224c90 <tse_mac_raw_send+0xf8>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 8224c5c:	e0be6c17 	ldw	r2,-1616(fp)
 8224c60:	e0fffe17 	ldw	r3,-8(fp)
 8224c64:	1885883a 	add	r2,r3,r2
 8224c68:	10800023 	ldbuio	r2,0(r2)
 8224c6c:	10803fcc 	andi	r2,r2,255
 8224c70:	1009883a 	mov	r4,r2
 8224c74:	e0fe7704 	addi	r3,fp,-1572
 8224c78:	e0be6c17 	ldw	r2,-1616(fp)
 8224c7c:	1885883a 	add	r2,r3,r2
 8224c80:	11000005 	stb	r4,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8224c84:	e0be6c17 	ldw	r2,-1616(fp)
 8224c88:	10800044 	addi	r2,r2,1
 8224c8c:	e0be6c15 	stw	r2,-1616(fp)
 8224c90:	e0fe6c17 	ldw	r3,-1616(fp)
 8224c94:	e0be6e17 	ldw	r2,-1608(fp)
 8224c98:	18bff036 	bltu	r3,r2,8224c5c <tse_mac_raw_send+0xc4>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 8224c9c:	e0be7704 	addi	r2,fp,-1572
 8224ca0:	e0be6d15 	stw	r2,-1612(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 8224ca4:	01400104 	movi	r5,4
 8224ca8:	e13e6d17 	ldw	r4,-1612(fp)
 8224cac:	823c53c0 	call	823c53c <alt_remap_cached>
 8224cb0:	e0be6d15 	stw	r2,-1612(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 8224cb4:	e0be7017 	ldw	r2,-1600(fp)
 8224cb8:	10800903 	ldbu	r2,36(r2)
 8224cbc:	10803fcc 	andi	r2,r2,255
 8224cc0:	10800058 	cmpnei	r2,r2,1
 8224cc4:	1000271e 	bne	r2,zero,8224d64 <tse_mac_raw_send+0x1cc>
 8224cc8:	e0be6e17 	ldw	r2,-1608(fp)
 8224ccc:	108003f0 	cmpltui	r2,r2,15
 8224cd0:	1000241e 	bne	r2,zero,8224d64 <tse_mac_raw_send+0x1cc>
 8224cd4:	e0be6f17 	ldw	r2,-1604(fp)
 8224cd8:	10800d17 	ldw	r2,52(r2)
 8224cdc:	1085883a 	add	r2,r2,r2
 8224ce0:	1085883a 	add	r2,r2,r2
 8224ce4:	1007883a 	mov	r3,r2
 8224ce8:	e0be7017 	ldw	r2,-1600(fp)
 8224cec:	10800b17 	ldw	r2,44(r2)
 8224cf0:	1885883a 	add	r2,r3,r2
 8224cf4:	10800037 	ldwio	r2,0(r2)
 8224cf8:	10800388 	cmpgei	r2,r2,14
 8224cfc:	1000191e 	bne	r2,zero,8224d64 <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224d00:	e0be6f17 	ldw	r2,-1604(fp)
 8224d04:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8224d08:	e0be6f17 	ldw	r2,-1604(fp)
 8224d0c:	10800f17 	ldw	r2,60(r2)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224d10:	11000804 	addi	r4,r2,32
 8224d14:	e0be6e17 	ldw	r2,-1608(fp)
 8224d18:	117fffcc 	andi	r5,r2,65535
 8224d1c:	d8000315 	stw	zero,12(sp)
 8224d20:	00800044 	movi	r2,1
 8224d24:	d8800215 	stw	r2,8(sp)
 8224d28:	00800044 	movi	r2,1
 8224d2c:	d8800115 	stw	r2,4(sp)
 8224d30:	d8000015 	stw	zero,0(sp)
 8224d34:	280f883a 	mov	r7,r5
 8224d38:	e1be6d17 	ldw	r6,-1612(fp)
 8224d3c:	200b883a 	mov	r5,r4
 8224d40:	1809883a 	mov	r4,r3
 8224d44:	821e3700 	call	821e370 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tse_mac_sTxWrite(mi,tse_ptr->desc);
 8224d48:	e0be6f17 	ldw	r2,-1604(fp)
 8224d4c:	10800f17 	ldw	r2,60(r2)
 8224d50:	100b883a 	mov	r5,r2
 8224d54:	e13e7317 	ldw	r4,-1588(fp)
 8224d58:	821ee480 	call	821ee48 <tse_mac_sTxWrite>
        result = 0;
 8224d5c:	e03e6b15 	stw	zero,-1620(fp)
 8224d60:	00001e06 	br	8224ddc <tse_mac_raw_send+0x244>
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 8224d64:	e0be6e17 	ldw	r2,-1608(fp)
 8224d68:	108003f0 	cmpltui	r2,r2,15
 8224d6c:	1000191e 	bne	r2,zero,8224dd4 <tse_mac_raw_send+0x23c>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224d70:	e0be6f17 	ldw	r2,-1604(fp)
 8224d74:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8224d78:	e0be6f17 	ldw	r2,-1604(fp)
 8224d7c:	10800f17 	ldw	r2,60(r2)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224d80:	11000804 	addi	r4,r2,32
 8224d84:	e0be6e17 	ldw	r2,-1608(fp)
 8224d88:	117fffcc 	andi	r5,r2,65535
 8224d8c:	d8000315 	stw	zero,12(sp)
 8224d90:	00800044 	movi	r2,1
 8224d94:	d8800215 	stw	r2,8(sp)
 8224d98:	00800044 	movi	r2,1
 8224d9c:	d8800115 	stw	r2,4(sp)
 8224da0:	d8000015 	stw	zero,0(sp)
 8224da4:	280f883a 	mov	r7,r5
 8224da8:	e1be6d17 	ldw	r6,-1612(fp)
 8224dac:	200b883a 	mov	r5,r4
 8224db0:	1809883a 	mov	r4,r3
 8224db4:	821e3700 	call	821e370 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tse_mac_sTxWrite(mi,tse_ptr->desc);
 8224db8:	e0be6f17 	ldw	r2,-1604(fp)
 8224dbc:	10800f17 	ldw	r2,60(r2)
 8224dc0:	100b883a 	mov	r5,r2
 8224dc4:	e13e7317 	ldw	r4,-1588(fp)
 8224dc8:	821ee480 	call	821ee48 <tse_mac_sTxWrite>
       result = 0;
 8224dcc:	e03e6b15 	stw	zero,-1620(fp)
 8224dd0:	00000206 	br	8224ddc <tse_mac_raw_send+0x244>

   } else {
       result = -3;
 8224dd4:	00bfff44 	movi	r2,-3
 8224dd8:	e0be6b15 	stw	r2,-1620(fp)
   }

   if(result < 0)   /* SGDMA not available */
 8224ddc:	e0be6b17 	ldw	r2,-1620(fp)
 8224de0:	1000120e 	bge	r2,zero,8224e2c <tse_mac_raw_send+0x294>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 8224de4:	e1be6e17 	ldw	r6,-1608(fp)
 8224de8:	e17e6b17 	ldw	r5,-1620(fp)
 8224dec:	01020974 	movhi	r4,2085
 8224df0:	213dfb04 	addi	r4,r4,-2068
 8224df4:	8202e9c0 	call	8202e9c <printf>
      net->n_mib->ifOutDiscards++;
 8224df8:	e0bffd17 	ldw	r2,-12(fp)
 8224dfc:	10802717 	ldw	r2,156(r2)
 8224e00:	10c01217 	ldw	r3,72(r2)
 8224e04:	18c00044 	addi	r3,r3,1
 8224e08:	10c01215 	stw	r3,72(r2)
      tse_ptr->sem = 0;
 8224e0c:	e0be6f17 	ldw	r2,-1604(fp)
 8224e10:	10000c15 	stw	zero,48(r2)
 8224e14:	e0be7217 	ldw	r2,-1592(fp)
 8224e18:	e0be7415 	stw	r2,-1584(fp)
 8224e1c:	e0be7417 	ldw	r2,-1584(fp)
 8224e20:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 8224e24:	00bffa84 	movi	r2,-22
 8224e28:	00001406 	br	8224e7c <tse_mac_raw_send+0x2e4>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 8224e2c:	e0bffd17 	ldw	r2,-12(fp)
 8224e30:	10802717 	ldw	r2,156(r2)
 8224e34:	e0fffd17 	ldw	r3,-12(fp)
 8224e38:	18c02717 	ldw	r3,156(r3)
 8224e3c:	19000f17 	ldw	r4,60(r3)
 8224e40:	e0ffff17 	ldw	r3,-4(fp)
 8224e44:	20c7883a 	add	r3,r4,r3
 8224e48:	10c00f15 	stw	r3,60(r2)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 8224e4c:	e0bffd17 	ldw	r2,-12(fp)
 8224e50:	10802717 	ldw	r2,156(r2)
 8224e54:	10c01017 	ldw	r3,64(r2)
 8224e58:	18c00044 	addi	r3,r3,1
 8224e5c:	10c01015 	stw	r3,64(r2)
      tse_ptr->sem = 0;
 8224e60:	e0be6f17 	ldw	r2,-1604(fp)
 8224e64:	10000c15 	stw	zero,48(r2)
 8224e68:	e0be7217 	ldw	r2,-1592(fp)
 8224e6c:	e0be7515 	stw	r2,-1580(fp)
 8224e70:	e0be7517 	ldw	r2,-1580(fp)
 8224e74:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 8224e78:	0005883a 	mov	r2,zero
   }
}
 8224e7c:	e037883a 	mov	sp,fp
 8224e80:	dfc00117 	ldw	ra,4(sp)
 8224e84:	df000017 	ldw	fp,0(sp)
 8224e88:	dec00204 	addi	sp,sp,8
 8224e8c:	f800283a 	ret

08224e90 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 8224e90:	defffa04 	addi	sp,sp,-24
 8224e94:	dfc00515 	stw	ra,20(sp)
 8224e98:	df000415 	stw	fp,16(sp)
 8224e9c:	df000404 	addi	fp,sp,16
 8224ea0:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 8224ea4:	e0bfff17 	ldw	r2,-4(fp)
 8224ea8:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 8224eac:	008209b4 	movhi	r2,2086
 8224eb0:	10b5ed04 	addi	r2,r2,-10316
 8224eb4:	10800217 	ldw	r2,8(r2)
 8224eb8:	e0bffd15 	stw	r2,-12(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 8224ebc:	e0bffc17 	ldw	r2,-16(fp)
 8224ec0:	10800317 	ldw	r2,12(r2)
 8224ec4:	10800317 	ldw	r2,12(r2)
 8224ec8:	10800037 	ldwio	r2,0(r2)
 8224ecc:	e0bffe05 	stb	r2,-8(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 8224ed0:	e0bffe03 	ldbu	r2,-8(fp)
 8224ed4:	1080030c 	andi	r2,r2,12
 8224ed8:	10001226 	beq	r2,zero,8224f24 <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 8224edc:	e13ffc17 	ldw	r4,-16(fp)
 8224ee0:	82250e80 	call	82250e8 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 8224ee4:	e0bffc17 	ldw	r2,-16(fp)
 8224ee8:	10c00317 	ldw	r3,12(r2)
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 8224eec:	e0bffc17 	ldw	r2,-16(fp)
 8224ef0:	10800f17 	ldw	r2,60(r2)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 8224ef4:	10801004 	addi	r2,r2,64
 8224ef8:	100b883a 	mov	r5,r2
 8224efc:	1809883a 	mov	r4,r3
 8224f00:	821df6c0 	call	821df6c <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 8224f04:	008209b4 	movhi	r2,2086
 8224f08:	10b5ed04 	addi	r2,r2,-10316
 8224f0c:	10800217 	ldw	r2,8(r2)
 8224f10:	e0fffd17 	ldw	r3,-12(fp)
 8224f14:	1880030e 	bge	r3,r2,8224f24 <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 8224f18:	d0a0ab17 	ldw	r2,-32084(gp)
 8224f1c:	1009883a 	mov	r4,r2
 8224f20:	821a0800 	call	821a080 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 8224f24:	0001883a 	nop
 8224f28:	e037883a 	mov	sp,fp
 8224f2c:	dfc00117 	ldw	ra,4(sp)
 8224f30:	df000017 	ldw	fp,0(sp)
 8224f34:	dec00204 	addi	sp,sp,8
 8224f38:	f800283a 	ret

08224f3c <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 8224f3c:	defffa04 	addi	sp,sp,-24
 8224f40:	dfc00515 	stw	ra,20(sp)
 8224f44:	df000415 	stw	fp,16(sp)
 8224f48:	dc000315 	stw	r16,12(sp)
 8224f4c:	df000404 	addi	fp,sp,16
 8224f50:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 8224f54:	e0bffe17 	ldw	r2,-8(fp)
 8224f58:	10000e15 	stw	zero,56(r2)
 8224f5c:	00004406 	br	8225070 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 8224f60:	e0bffe17 	ldw	r2,-8(fp)
 8224f64:	14000e17 	ldw	r16,56(r2)
 8224f68:	01017f04 	movi	r4,1532
 8224f6c:	822c6200 	call	822c620 <pk_alloc>
 8224f70:	1009883a 	mov	r4,r2
 8224f74:	e0fffe17 	ldw	r3,-8(fp)
 8224f78:	80800444 	addi	r2,r16,17
 8224f7c:	1085883a 	add	r2,r2,r2
 8224f80:	1085883a 	add	r2,r2,r2
 8224f84:	1885883a 	add	r2,r3,r2
 8224f88:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 8224f8c:	e0bffe17 	ldw	r2,-8(fp)
 8224f90:	10800e17 	ldw	r2,56(r2)
 8224f94:	e0fffe17 	ldw	r3,-8(fp)
 8224f98:	10800444 	addi	r2,r2,17
 8224f9c:	1085883a 	add	r2,r2,r2
 8224fa0:	1085883a 	add	r2,r2,r2
 8224fa4:	1885883a 	add	r2,r3,r2
 8224fa8:	10800017 	ldw	r2,0(r2)
 8224fac:	10000b1e 	bne	r2,zero,8224fdc <tse_sgdma_read_init+0xa0>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 8224fb0:	01020974 	movhi	r4,2085
 8224fb4:	213e0704 	addi	r4,r4,-2020
 8224fb8:	82031200 	call	8203120 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 8224fbc:	e0bffe17 	ldw	r2,-8(fp)
 8224fc0:	10800817 	ldw	r2,32(r2)
 8224fc4:	10802717 	ldw	r2,156(r2)
 8224fc8:	10c00c17 	ldw	r3,48(r2)
 8224fcc:	18c00044 	addi	r3,r3,1
 8224fd0:	10c00c15 	stw	r3,48(r2)
      
      return ENP_NOBUFFER;
 8224fd4:	00bffac4 	movi	r2,-21
 8224fd8:	00003d06 	br	82250d0 <tse_sgdma_read_init+0x194>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 8224fdc:	e0bffe17 	ldw	r2,-8(fp)
 8224fe0:	10800e17 	ldw	r2,56(r2)
 8224fe4:	e0fffe17 	ldw	r3,-8(fp)
 8224fe8:	10800444 	addi	r2,r2,17
 8224fec:	1085883a 	add	r2,r2,r2
 8224ff0:	1085883a 	add	r2,r2,r2
 8224ff4:	1885883a 	add	r2,r3,r2
 8224ff8:	10800017 	ldw	r2,0(r2)
 8224ffc:	10800117 	ldw	r2,4(r2)
 8225000:	01400104 	movi	r5,4
 8225004:	1009883a 	mov	r4,r2
 8225008:	823c53c0 	call	823c53c <alt_remap_cached>
 822500c:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 8225010:	e0bffe17 	ldw	r2,-8(fp)
 8225014:	10c00f17 	ldw	r3,60(r2)
 8225018:	e0bffe17 	ldw	r2,-8(fp)
 822501c:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225020:	10800084 	addi	r2,r2,2
 8225024:	1004917a 	slli	r2,r2,5
 8225028:	1889883a 	add	r4,r3,r2
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST], // pointer to "next"
 822502c:	e0bffe17 	ldw	r2,-8(fp)
 8225030:	10c00f17 	ldw	r3,60(r2)
 8225034:	e0bffe17 	ldw	r2,-8(fp)
 8225038:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 822503c:	108000c4 	addi	r2,r2,3
 8225040:	1004917a 	slli	r2,r2,5
 8225044:	1885883a 	add	r2,r3,r2
 8225048:	d8000015 	stw	zero,0(sp)
 822504c:	000f883a 	mov	r7,zero
 8225050:	e1bffd17 	ldw	r6,-12(fp)
 8225054:	100b883a 	mov	r5,r2
 8225058:	821e2980 	call	821e298 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 822505c:	e0bffe17 	ldw	r2,-8(fp)
 8225060:	10800e17 	ldw	r2,56(r2)
 8225064:	10c00044 	addi	r3,r2,1
 8225068:	e0bffe17 	ldw	r2,-8(fp)
 822506c:	10c00e15 	stw	r3,56(r2)
 8225070:	e0bffe17 	ldw	r2,-8(fp)
 8225074:	10800e17 	ldw	r2,56(r2)
 8225078:	00bfb90e 	bge	zero,r2,8224f60 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 822507c:	e0bffe17 	ldw	r2,-8(fp)
 8225080:	10800e17 	ldw	r2,56(r2)
 8225084:	100b883a 	mov	r5,r2
 8225088:	01020974 	movhi	r4,2085
 822508c:	213e1804 	addi	r4,r4,-1952
 8225090:	8202e9c0 	call	8202e9c <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 8225094:	e0bffe17 	ldw	r2,-8(fp)
 8225098:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 822509c:	e0bffe17 	ldw	r2,-8(fp)
 82250a0:	10800f17 	ldw	r2,60(r2)
 82250a4:	10c01004 	addi	r3,r2,64
 82250a8:	e0bffe17 	ldw	r2,-8(fp)
 82250ac:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 82250b0:	e0bffe17 	ldw	r2,-8(fp)
 82250b4:	10c00104 	addi	r3,r2,4
 82250b8:	e0bffe17 	ldw	r2,-8(fp)
 82250bc:	10801017 	ldw	r2,64(r2)
 82250c0:	100b883a 	mov	r5,r2
 82250c4:	1809883a 	mov	r4,r3
 82250c8:	821ef2c0 	call	821ef2c <tse_mac_aRxRead>
  
  return SUCCESS;
 82250cc:	0005883a 	mov	r2,zero
}
 82250d0:	e6ffff04 	addi	sp,fp,-4
 82250d4:	dfc00217 	ldw	ra,8(sp)
 82250d8:	df000117 	ldw	fp,4(sp)
 82250dc:	dc000017 	ldw	r16,0(sp)
 82250e0:	dec00304 	addi	sp,sp,12
 82250e4:	f800283a 	ret

082250e8 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 82250e8:	defff704 	addi	sp,sp,-36
 82250ec:	dfc00815 	stw	ra,32(sp)
 82250f0:	df000715 	stw	fp,28(sp)
 82250f4:	df000704 	addi	fp,sp,28
 82250f8:	e13fff15 	stw	r4,-4(fp)
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 82250fc:	e0bfff17 	ldw	r2,-4(fp)
 8225100:	10c00f17 	ldw	r3,60(r2)
 8225104:	e0bfff17 	ldw	r2,-4(fp)
 8225108:	10800e17 	ldw	r2,56(r2)
 822510c:	10800084 	addi	r2,r2,2
 8225110:	1004917a 	slli	r2,r2,5
 8225114:	1887883a 	add	r3,r3,r2
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 8225118:	e0bfff17 	ldw	r2,-4(fp)
 822511c:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 8225120:	e0bfff17 	ldw	r2,-4(fp)
 8225124:	10801017 	ldw	r2,64(r2)
 8225128:	10800704 	addi	r2,r2,28
 822512c:	10800037 	ldwio	r2,0(r2)
 8225130:	1005d43a 	srai	r2,r2,16
 8225134:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 8225138:	e0bfff17 	ldw	r2,-4(fp)
 822513c:	10801017 	ldw	r2,64(r2)
 8225140:	10800704 	addi	r2,r2,28
 8225144:	1080002b 	ldhuio	r2,0(r2)
 8225148:	10bfffcc 	andi	r2,r2,65535
 822514c:	10bfff84 	addi	r2,r2,-2
 8225150:	e0bffa15 	stw	r2,-24(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 8225154:	e0bfff17 	ldw	r2,-4(fp)
 8225158:	10800817 	ldw	r2,32(r2)
 822515c:	10802717 	ldw	r2,156(r2)
 8225160:	e0ffff17 	ldw	r3,-4(fp)
 8225164:	18c00817 	ldw	r3,32(r3)
 8225168:	18c02717 	ldw	r3,156(r3)
 822516c:	19000917 	ldw	r4,36(r3)
 8225170:	e0fffa17 	ldw	r3,-24(fp)
 8225174:	20c7883a 	add	r3,r4,r3
 8225178:	10c00915 	stw	r3,36(r2)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 822517c:	e0bfff17 	ldw	r2,-4(fp)
 8225180:	10800e17 	ldw	r2,56(r2)
 8225184:	e0ffff17 	ldw	r3,-4(fp)
 8225188:	10800444 	addi	r2,r2,17
 822518c:	1085883a 	add	r2,r2,r2
 8225190:	1085883a 	add	r2,r2,r2
 8225194:	1885883a 	add	r2,r3,r2
 8225198:	10800017 	ldw	r2,0(r2)
 822519c:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 82251a0:	e0bffb17 	ldw	r2,-20(fp)
 82251a4:	10800117 	ldw	r2,4(r2)
 82251a8:	10c00404 	addi	r3,r2,16
 82251ac:	e0bffb17 	ldw	r2,-20(fp)
 82251b0:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 82251b4:	e0bffa17 	ldw	r2,-24(fp)
 82251b8:	10bffc84 	addi	r2,r2,-14
 82251bc:	1007883a 	mov	r3,r2
 82251c0:	e0bffb17 	ldw	r2,-20(fp)
 82251c4:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 82251c8:	d0a0a817 	ldw	r2,-32096(gp)
 82251cc:	1007883a 	mov	r3,r2
 82251d0:	e0bffb17 	ldw	r2,-20(fp)
 82251d4:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 82251d8:	e0bfff17 	ldw	r2,-4(fp)
 82251dc:	10c00817 	ldw	r3,32(r2)
 82251e0:	e0bffb17 	ldw	r2,-20(fp)
 82251e4:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 82251e8:	e0bffb17 	ldw	r2,-20(fp)
 82251ec:	10800117 	ldw	r2,4(r2)
 82251f0:	10800084 	addi	r2,r2,2
 82251f4:	e0bffc15 	stw	r2,-16(fp)
    rx_packet->type = eth->e_type;
 82251f8:	e0bffc17 	ldw	r2,-16(fp)
 82251fc:	10c0030b 	ldhu	r3,12(r2)
 8225200:	e0bffb17 	ldw	r2,-20(fp)
 8225204:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 8225208:	e0bff903 	ldbu	r2,-28(fp)
 822520c:	10801fcc 	andi	r2,r2,127
 8225210:	1000251e 	bne	r2,zero,82252a8 <tse_mac_rcv+0x1c0>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 8225214:	01017f04 	movi	r4,1532
 8225218:	822c6200 	call	822c620 <pk_alloc>
 822521c:	e0bffd15 	stw	r2,-12(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 8225220:	e0bffd17 	ldw	r2,-12(fp)
 8225224:	10000a1e 	bne	r2,zero,8225250 <tse_mac_rcv+0x168>
        dprintf("No free buffers for rx\n");
 8225228:	01020974 	movhi	r4,2085
 822522c:	213e2904 	addi	r4,r4,-1884
 8225230:	82031200 	call	8203120 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 8225234:	e0bfff17 	ldw	r2,-4(fp)
 8225238:	10800817 	ldw	r2,32(r2)
 822523c:	10802717 	ldw	r2,156(r2)
 8225240:	10c00c17 	ldw	r3,48(r2)
 8225244:	18c00044 	addi	r3,r3,1
 8225248:	10c00c15 	stw	r3,48(r2)
 822524c:	00001906 	br	82252b4 <tse_mac_rcv+0x1cc>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 8225250:	e0bfff17 	ldw	r2,-4(fp)
 8225254:	10800e17 	ldw	r2,56(r2)
 8225258:	e0ffff17 	ldw	r3,-4(fp)
 822525c:	10800444 	addi	r2,r2,17
 8225260:	1085883a 	add	r2,r2,r2
 8225264:	1085883a 	add	r2,r2,r2
 8225268:	1885883a 	add	r2,r3,r2
 822526c:	10800017 	ldw	r2,0(r2)
 8225270:	100b883a 	mov	r5,r2
 8225274:	010209b4 	movhi	r4,2086
 8225278:	2135ed04 	addi	r4,r4,-10316
 822527c:	822cbb00 	call	822cbb0 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 8225280:	e0bfff17 	ldw	r2,-4(fp)
 8225284:	10800e17 	ldw	r2,56(r2)
 8225288:	e0ffff17 	ldw	r3,-4(fp)
 822528c:	10800444 	addi	r2,r2,17
 8225290:	1085883a 	add	r2,r2,r2
 8225294:	1085883a 	add	r2,r2,r2
 8225298:	1885883a 	add	r2,r3,r2
 822529c:	e0fffd17 	ldw	r3,-12(fp)
 82252a0:	10c00015 	stw	r3,0(r2)
 82252a4:	00000306 	br	82252b4 <tse_mac_rcv+0x1cc>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 82252a8:	01020974 	movhi	r4,2085
 82252ac:	213e2f04 	addi	r4,r4,-1860
 82252b0:	82031200 	call	8203120 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82252b4:	e0bfff17 	ldw	r2,-4(fp)
 82252b8:	10800e17 	ldw	r2,56(r2)
 82252bc:	e0ffff17 	ldw	r3,-4(fp)
 82252c0:	10800444 	addi	r2,r2,17
 82252c4:	1085883a 	add	r2,r2,r2
 82252c8:	1085883a 	add	r2,r2,r2
 82252cc:	1885883a 	add	r2,r3,r2
 82252d0:	10800017 	ldw	r2,0(r2)
 82252d4:	10800117 	ldw	r2,4(r2)
 82252d8:	01400104 	movi	r5,4
 82252dc:	1009883a 	mov	r4,r2
 82252e0:	823c53c0 	call	823c53c <alt_remap_cached>
 82252e4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 82252e8:	e0bfff17 	ldw	r2,-4(fp)
 82252ec:	10801017 	ldw	r2,64(r2)
 82252f0:	10800204 	addi	r2,r2,8
 82252f4:	e0fffe17 	ldw	r3,-8(fp)
 82252f8:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 82252fc:	e0bfff17 	ldw	r2,-4(fp)
 8225300:	10801017 	ldw	r2,64(r2)
 8225304:	10800704 	addi	r2,r2,28
 8225308:	00e04034 	movhi	r3,33024
 822530c:	10c00035 	stwio	r3,0(r2)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 8225310:	0001883a 	nop
 8225314:	e037883a 	mov	sp,fp
 8225318:	dfc00117 	ldw	ra,4(sp)
 822531c:	df000017 	ldw	fp,0(sp)
 8225320:	dec00204 	addi	sp,sp,8
 8225324:	f800283a 	ret

08225328 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 8225328:	defffc04 	addi	sp,sp,-16
 822532c:	dfc00315 	stw	ra,12(sp)
 8225330:	df000215 	stw	fp,8(sp)
 8225334:	df000204 	addi	fp,sp,8
 8225338:	e13ffe15 	stw	r4,-8(fp)
 822533c:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 8225340:	01420974 	movhi	r5,2085
 8225344:	297e3b04 	addi	r5,r5,-1812
 8225348:	e13ffe17 	ldw	r4,-8(fp)
 822534c:	8228a940 	call	8228a94 <ns_printf>
   return SUCCESS;
 8225350:	0005883a 	mov	r2,zero
}
 8225354:	e037883a 	mov	sp,fp
 8225358:	dfc00117 	ldw	ra,4(sp)
 822535c:	df000017 	ldw	fp,0(sp)
 8225360:	dec00204 	addi	sp,sp,8
 8225364:	f800283a 	ret

08225368 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 8225368:	defffc04 	addi	sp,sp,-16
 822536c:	dfc00315 	stw	ra,12(sp)
 8225370:	df000215 	stw	fp,8(sp)
 8225374:	df000204 	addi	fp,sp,8
 8225378:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 822537c:	008209b4 	movhi	r2,2086
 8225380:	10b6b204 	addi	r2,r2,-9528
 8225384:	e0ffff17 	ldw	r3,-4(fp)
 8225388:	18c7883a 	add	r3,r3,r3
 822538c:	18c7883a 	add	r3,r3,r3
 8225390:	10c5883a 	add	r2,r2,r3
 8225394:	10800017 	ldw	r2,0(r2)
 8225398:	10802717 	ldw	r2,156(r2)
 822539c:	00c00084 	movi	r3,2
 82253a0:	10c00615 	stw	r3,24(r2)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 82253a4:	008209b4 	movhi	r2,2086
 82253a8:	10b5a104 	addi	r2,r2,-10620
 82253ac:	e0ffff17 	ldw	r3,-4(fp)
 82253b0:	18c01324 	muli	r3,r3,76
 82253b4:	10c5883a 	add	r2,r2,r3
 82253b8:	10800304 	addi	r2,r2,12
 82253bc:	10800017 	ldw	r2,0(r2)
 82253c0:	000f883a 	mov	r7,zero
 82253c4:	000d883a 	mov	r6,zero
 82253c8:	000b883a 	mov	r5,zero
 82253cc:	1009883a 	mov	r4,r2
 82253d0:	821e47c0 	call	821e47c <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82253d4:	008209b4 	movhi	r2,2086
 82253d8:	10b5a104 	addi	r2,r2,-10620
 82253dc:	e0ffff17 	ldw	r3,-4(fp)
 82253e0:	18c01324 	muli	r3,r3,76
 82253e4:	10c5883a 	add	r2,r2,r3
 82253e8:	10800104 	addi	r2,r2,4
 82253ec:	10800017 	ldw	r2,0(r2)
 82253f0:	10800204 	addi	r2,r2,8
 82253f4:	10800037 	ldwio	r2,0(r2)
 82253f8:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 82253fc:	008209b4 	movhi	r2,2086
 8225400:	10b5a104 	addi	r2,r2,-10620
 8225404:	e0ffff17 	ldw	r3,-4(fp)
 8225408:	18c01324 	muli	r3,r3,76
 822540c:	10c5883a 	add	r2,r2,r3
 8225410:	10800104 	addi	r2,r2,4
 8225414:	10800017 	ldw	r2,0(r2)
 8225418:	10800204 	addi	r2,r2,8
 822541c:	e13ffe17 	ldw	r4,-8(fp)
 8225420:	00ffff44 	movi	r3,-3
 8225424:	20c6703a 	and	r3,r4,r3
 8225428:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 822542c:	008209b4 	movhi	r2,2086
 8225430:	10b6b204 	addi	r2,r2,-9528
 8225434:	e0ffff17 	ldw	r3,-4(fp)
 8225438:	18c7883a 	add	r3,r3,r3
 822543c:	18c7883a 	add	r3,r3,r3
 8225440:	10c5883a 	add	r2,r2,r3
 8225444:	10800017 	ldw	r2,0(r2)
 8225448:	10802717 	ldw	r2,156(r2)
 822544c:	00c00084 	movi	r3,2
 8225450:	10c00715 	stw	r3,28(r2)

  return SUCCESS;
 8225454:	0005883a 	mov	r2,zero
}
 8225458:	e037883a 	mov	sp,fp
 822545c:	dfc00117 	ldw	ra,4(sp)
 8225460:	df000017 	ldw	fp,0(sp)
 8225464:	dec00204 	addi	sp,sp,8
 8225468:	f800283a 	ret

0822546c <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 822546c:	defffd04 	addi	sp,sp,-12
 8225470:	dfc00215 	stw	ra,8(sp)
 8225474:	df000115 	stw	fp,4(sp)
 8225478:	df000104 	addi	fp,sp,4
 822547c:	e13fff15 	stw	r4,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 8225480:	e0bfff17 	ldw	r2,-4(fp)
 8225484:	10800808 	cmpgei	r2,r2,32
 8225488:	1000031e 	bne	r2,zero,8225498 <close+0x2c>
 822548c:	e13fff17 	ldw	r4,-4(fp)
 8225490:	823b9c80 	call	823b9c8 <alt_close>
 8225494:	00000206 	br	82254a0 <close+0x34>
 8225498:	e13fff17 	ldw	r4,-4(fp)
 822549c:	82314800 	call	8231480 <t_socketclose>
}
 82254a0:	e037883a 	mov	sp,fp
 82254a4:	dfc00117 	ldw	ra,4(sp)
 82254a8:	df000017 	ldw	fp,0(sp)
 82254ac:	dec00204 	addi	sp,sp,8
 82254b0:	f800283a 	ret

082254b4 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 82254b4:	defff504 	addi	sp,sp,-44
 82254b8:	dfc00a15 	stw	ra,40(sp)
 82254bc:	df000915 	stw	fp,36(sp)
 82254c0:	df000904 	addi	fp,sp,36
 82254c4:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 82254c8:	d0a02e17 	ldw	r2,-32584(gp)
 82254cc:	e0bff815 	stw	r2,-32(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 82254d0:	d0a02e04 	addi	r2,gp,-32584
 82254d4:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82254d8:	00003f06 	br	82255d8 <iniche_devices_init+0x124>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 82254dc:	e0bff817 	ldw	r2,-32(fp)
 82254e0:	e0fff817 	ldw	r3,-32(fp)
 82254e4:	10c00415 	stw	r3,16(r2)
        p_dev->if_num = if_count;
 82254e8:	e0bff817 	ldw	r2,-32(fp)
 82254ec:	e0ffff17 	ldw	r3,-4(fp)
 82254f0:	10c00515 	stw	r3,20(r2)
        p_dev->p_net = nets[p_dev->if_num];
 82254f4:	e0bff817 	ldw	r2,-32(fp)
 82254f8:	10c00517 	ldw	r3,20(r2)
 82254fc:	008209b4 	movhi	r2,2086
 8225500:	10b6b204 	addi	r2,r2,-9528
 8225504:	18c7883a 	add	r3,r3,r3
 8225508:	18c7883a 	add	r3,r3,r3
 822550c:	10c5883a 	add	r2,r2,r3
 8225510:	10c00017 	ldw	r3,0(r2)
 8225514:	e0bff817 	ldw	r2,-32(fp)
 8225518:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 822551c:	e0bff817 	ldw	r2,-32(fp)
 8225520:	10800317 	ldw	r2,12(r2)
 8225524:	e13ff817 	ldw	r4,-32(fp)
 8225528:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 822552c:	e0bff817 	ldw	r2,-32(fp)
 8225530:	10800617 	ldw	r2,24(r2)
 8225534:	e0bffa15 	stw	r2,-24(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 8225538:	e17ffd04 	addi	r5,fp,-12
 822553c:	e13ffc04 	addi	r4,fp,-16
 8225540:	e0fffb04 	addi	r3,fp,-20
 8225544:	e0bffe04 	addi	r2,fp,-8
 8225548:	d8800015 	stw	r2,0(sp)
 822554c:	280f883a 	mov	r7,r5
 8225550:	200d883a 	mov	r6,r4
 8225554:	180b883a 	mov	r5,r3
 8225558:	e13ff817 	ldw	r4,-32(fp)
 822555c:	82011180 	call	8201118 <get_ip_addr>
 8225560:	10001726 	beq	r2,zero,82255c0 <iniche_devices_init+0x10c>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 8225564:	e0bffe17 	ldw	r2,-8(fp)
 8225568:	10000526 	beq	r2,zero,8225580 <iniche_devices_init+0xcc>
                p_net->n_flags |= NF_DHCPC;
 822556c:	e0bffa17 	ldw	r2,-24(fp)
 8225570:	10802a17 	ldw	r2,168(r2)
 8225574:	10c04014 	ori	r3,r2,256
 8225578:	e0bffa17 	ldw	r2,-24(fp)
 822557c:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 8225580:	e0fffb17 	ldw	r3,-20(fp)
 8225584:	e0bffa17 	ldw	r2,-24(fp)
 8225588:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 822558c:	e0fffc17 	ldw	r3,-16(fp)
 8225590:	e0bffa17 	ldw	r2,-24(fp)
 8225594:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 8225598:	e0fffd17 	ldw	r3,-12(fp)
 822559c:	e0bffa17 	ldw	r2,-24(fp)
 82255a0:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 82255a4:	e0fffa17 	ldw	r3,-24(fp)
 82255a8:	00820934 	movhi	r2,2084
 82255ac:	10b3fa04 	addi	r2,r2,-12312
 82255b0:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 82255b4:	e0bffa17 	ldw	r2,-24(fp)
 82255b8:	00c00084 	movi	r3,2
 82255bc:	10c02f05 	stb	r3,188(r2)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 82255c0:	e0bfff17 	ldw	r2,-4(fp)
 82255c4:	10800044 	addi	r2,r2,1
 82255c8:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 82255cc:	e0bff817 	ldw	r2,-32(fp)
 82255d0:	10800017 	ldw	r2,0(r2)
 82255d4:	e0bff815 	stw	r2,-32(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82255d8:	e0fff817 	ldw	r3,-32(fp)
 82255dc:	e0bff917 	ldw	r2,-28(fp)
 82255e0:	18bfbe1e 	bne	r3,r2,82254dc <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 82255e4:	e0bfff17 	ldw	r2,-4(fp)
}
 82255e8:	e037883a 	mov	sp,fp
 82255ec:	dfc00117 	ldw	ra,4(sp)
 82255f0:	df000017 	ldw	fp,0(sp)
 82255f4:	dec00204 	addi	sp,sp,8
 82255f8:	f800283a 	ret

082255fc <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 82255fc:	defff904 	addi	sp,sp,-28
 8225600:	dfc00615 	stw	ra,24(sp)
 8225604:	df000515 	stw	fp,20(sp)
 8225608:	df000504 	addi	fp,sp,20
 822560c:	e13ffd15 	stw	r4,-12(fp)
 8225610:	e17ffe15 	stw	r5,-8(fp)
 8225614:	e1bfff15 	stw	r6,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225618:	e0bffd17 	ldw	r2,-12(fp)
 822561c:	10800808 	cmpgei	r2,r2,32
 8225620:	1000051e 	bne	r2,zero,8225638 <read+0x3c>
 8225624:	e1bfff17 	ldw	r6,-4(fp)
 8225628:	e17ffe17 	ldw	r5,-8(fp)
 822562c:	e13ffd17 	ldw	r4,-12(fp)
 8225630:	823c3dc0 	call	823c3dc <alt_read>
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 8225634:	00000806 	br	8225658 <read+0x5c>
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225638:	e0bfff17 	ldw	r2,-4(fp)
 822563c:	d8000115 	stw	zero,4(sp)
 8225640:	d8000015 	stw	zero,0(sp)
 8225644:	000f883a 	mov	r7,zero
 8225648:	100d883a 	mov	r6,r2
 822564c:	e17ffe17 	ldw	r5,-8(fp)
 8225650:	e13ffd17 	ldw	r4,-12(fp)
 8225654:	8227f980 	call	8227f98 <bsd_recvfrom>
}
 8225658:	e037883a 	mov	sp,fp
 822565c:	dfc00117 	ldw	ra,4(sp)
 8225660:	df000017 	ldw	fp,0(sp)
 8225664:	dec00204 	addi	sp,sp,8
 8225668:	f800283a 	ret

0822566c <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 822566c:	defffb04 	addi	sp,sp,-20
 8225670:	dfc00415 	stw	ra,16(sp)
 8225674:	df000315 	stw	fp,12(sp)
 8225678:	df000304 	addi	fp,sp,12
 822567c:	e13ffd15 	stw	r4,-12(fp)
 8225680:	e17ffe15 	stw	r5,-8(fp)
 8225684:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 8225688:	e0bffd17 	ldw	r2,-12(fp)
 822568c:	10800808 	cmpgei	r2,r2,32
 8225690:	1000051e 	bne	r2,zero,82256a8 <write+0x3c>
  {
    return alt_write (fd, ptr, len);
 8225694:	e1bfff17 	ldw	r6,-4(fp)
 8225698:	e17ffe17 	ldw	r5,-8(fp)
 822569c:	e13ffd17 	ldw	r4,-12(fp)
 82256a0:	823c7ec0 	call	823c7ec <alt_write>
 82256a4:	00000606 	br	82256c0 <write+0x54>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 82256a8:	e0bfff17 	ldw	r2,-4(fp)
 82256ac:	000f883a 	mov	r7,zero
 82256b0:	100d883a 	mov	r6,r2
 82256b4:	e17ffe17 	ldw	r5,-8(fp)
 82256b8:	e13ffd17 	ldw	r4,-12(fp)
 82256bc:	82311a40 	call	82311a4 <t_send>
  }  
}
 82256c0:	e037883a 	mov	sp,fp
 82256c4:	dfc00117 	ldw	ra,4(sp)
 82256c8:	df000017 	ldw	fp,0(sp)
 82256cc:	dec00204 	addi	sp,sp,8
 82256d0:	f800283a 	ret

082256d4 <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 82256d4:	defffc04 	addi	sp,sp,-16
 82256d8:	dfc00315 	stw	ra,12(sp)
 82256dc:	df000215 	stw	fp,8(sp)
 82256e0:	df000204 	addi	fp,sp,8
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 82256e4:	e03ffe15 	stw	zero,-8(fp)
 82256e8:	00004a06 	br	8225814 <Netinit+0x140>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 82256ec:	008209b4 	movhi	r2,2086
 82256f0:	10b6b204 	addi	r2,r2,-9528
 82256f4:	e0fffe17 	ldw	r3,-8(fp)
 82256f8:	18c7883a 	add	r3,r3,r3
 82256fc:	18c7883a 	add	r3,r3,r3
 8225700:	10c5883a 	add	r2,r2,r3
 8225704:	10800017 	ldw	r2,0(r2)
 8225708:	10802717 	ldw	r2,156(r2)
 822570c:	10800217 	ldw	r2,8(r2)
 8225710:	10800198 	cmpnei	r2,r2,6
 8225714:	1000241e 	bne	r2,zero,82257a8 <Netinit+0xd4>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 8225718:	008209b4 	movhi	r2,2086
 822571c:	10b6b204 	addi	r2,r2,-9528
 8225720:	e0fffe17 	ldw	r3,-8(fp)
 8225724:	18c7883a 	add	r3,r3,r3
 8225728:	18c7883a 	add	r3,r3,r3
 822572c:	10c5883a 	add	r2,r2,r3
 8225730:	10800017 	ldw	r2,0(r2)
 8225734:	10800917 	ldw	r2,36(r2)
 8225738:	1000091e 	bne	r2,zero,8225760 <Netinit+0x8c>
            nets[i]->n_mtu = 1514;
 822573c:	008209b4 	movhi	r2,2086
 8225740:	10b6b204 	addi	r2,r2,-9528
 8225744:	e0fffe17 	ldw	r3,-8(fp)
 8225748:	18c7883a 	add	r3,r3,r3
 822574c:	18c7883a 	add	r3,r3,r3
 8225750:	10c5883a 	add	r2,r2,r3
 8225754:	10800017 	ldw	r2,0(r2)
 8225758:	00c17a84 	movi	r3,1514
 822575c:	10c00915 	stw	r3,36(r2)

         if (nets[i]->n_lnh == 0)
 8225760:	008209b4 	movhi	r2,2086
 8225764:	10b6b204 	addi	r2,r2,-9528
 8225768:	e0fffe17 	ldw	r3,-8(fp)
 822576c:	18c7883a 	add	r3,r3,r3
 8225770:	18c7883a 	add	r3,r3,r3
 8225774:	10c5883a 	add	r2,r2,r3
 8225778:	10800017 	ldw	r2,0(r2)
 822577c:	10800817 	ldw	r2,32(r2)
 8225780:	1000091e 	bne	r2,zero,82257a8 <Netinit+0xd4>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 8225784:	008209b4 	movhi	r2,2086
 8225788:	10b6b204 	addi	r2,r2,-9528
 822578c:	e0fffe17 	ldw	r3,-8(fp)
 8225790:	18c7883a 	add	r3,r3,r3
 8225794:	18c7883a 	add	r3,r3,r3
 8225798:	10c5883a 	add	r2,r2,r3
 822579c:	10800017 	ldw	r2,0(r2)
 82257a0:	00c00404 	movi	r3,16
 82257a4:	10c00815 	stw	r3,32(r2)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 82257a8:	008209b4 	movhi	r2,2086
 82257ac:	10b6b204 	addi	r2,r2,-9528
 82257b0:	e0fffe17 	ldw	r3,-8(fp)
 82257b4:	18c7883a 	add	r3,r3,r3
 82257b8:	18c7883a 	add	r3,r3,r3
 82257bc:	10c5883a 	add	r2,r2,r3
 82257c0:	10800017 	ldw	r2,0(r2)
 82257c4:	10800817 	ldw	r2,32(r2)
 82257c8:	d0e08117 	ldw	r3,-32252(gp)
 82257cc:	10c0010e 	bge	r2,r3,82257d4 <Netinit+0x100>
 82257d0:	1805883a 	mov	r2,r3
 82257d4:	d0a08115 	stw	r2,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 82257d8:	008209b4 	movhi	r2,2086
 82257dc:	10b6b204 	addi	r2,r2,-9528
 82257e0:	e0fffe17 	ldw	r3,-8(fp)
 82257e4:	18c7883a 	add	r3,r3,r3
 82257e8:	18c7883a 	add	r3,r3,r3
 82257ec:	10c5883a 	add	r2,r2,r3
 82257f0:	10800017 	ldw	r2,0(r2)
 82257f4:	10800917 	ldw	r2,36(r2)
 82257f8:	d0e08217 	ldw	r3,-32248(gp)
 82257fc:	10c0010e 	bge	r2,r3,8225804 <Netinit+0x130>
 8225800:	1805883a 	mov	r2,r3
 8225804:	d0a08215 	stw	r2,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225808:	e0bffe17 	ldw	r2,-8(fp)
 822580c:	10800044 	addi	r2,r2,1
 8225810:	e0bffe15 	stw	r2,-8(fp)
 8225814:	d0a08417 	ldw	r2,-32240(gp)
 8225818:	1007883a 	mov	r3,r2
 822581c:	e0bffe17 	ldw	r2,-8(fp)
 8225820:	10ffb216 	blt	r2,r3,82256ec <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 8225824:	008209b4 	movhi	r2,2086
 8225828:	10b5ed04 	addi	r2,r2,-10316
 822582c:	10000115 	stw	zero,4(r2)
 8225830:	008209b4 	movhi	r2,2086
 8225834:	10b5ed04 	addi	r2,r2,-10316
 8225838:	10c00117 	ldw	r3,4(r2)
 822583c:	008209b4 	movhi	r2,2086
 8225840:	10b5ed04 	addi	r2,r2,-10316
 8225844:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 8225848:	008209b4 	movhi	r2,2086
 822584c:	10b5ed04 	addi	r2,r2,-10316
 8225850:	10000215 	stw	zero,8(r2)
 8225854:	008209b4 	movhi	r2,2086
 8225858:	10b5ed04 	addi	r2,r2,-10316
 822585c:	10c00217 	ldw	r3,8(r2)
 8225860:	008209b4 	movhi	r2,2086
 8225864:	10b5ed04 	addi	r2,r2,-10316
 8225868:	10c00415 	stw	r3,16(r2)
 822586c:	008209b4 	movhi	r2,2086
 8225870:	10b5ed04 	addi	r2,r2,-10316
 8225874:	10c00417 	ldw	r3,16(r2)
 8225878:	008209b4 	movhi	r2,2086
 822587c:	10b5ed04 	addi	r2,r2,-10316
 8225880:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8225884:	01000084 	movi	r4,2
 8225888:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   e = pk_init();
 822588c:	822c3840 	call	822c384 <pk_init>
 8225890:	e0bfff15 	stw	r2,-4(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8225894:	01000084 	movi	r4,2
 8225898:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 822589c:	e0bfff17 	ldw	r2,-4(fp)
 82258a0:	10000226 	beq	r2,zero,82258ac <Netinit+0x1d8>
      return e;
 82258a4:	e0bfff17 	ldw	r2,-4(fp)
 82258a8:	0000ff06 	br	8225ca8 <Netinit+0x5d4>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 82258ac:	010208b4 	movhi	r4,2082
 82258b0:	21178504 	addi	r4,r4,24084
 82258b4:	822675c0 	call	822675c <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 82258b8:	e03ffe15 	stw	zero,-8(fp)
 82258bc:	0000f506 	br	8225c94 <Netinit+0x5c0>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 82258c0:	008209b4 	movhi	r2,2086
 82258c4:	10b6b204 	addi	r2,r2,-9528
 82258c8:	e0fffe17 	ldw	r3,-8(fp)
 82258cc:	18c7883a 	add	r3,r3,r3
 82258d0:	18c7883a 	add	r3,r3,r3
 82258d4:	10c5883a 	add	r2,r2,r3
 82258d8:	10800017 	ldw	r2,0(r2)
 82258dc:	10800217 	ldw	r2,8(r2)
 82258e0:	10009126 	beq	r2,zero,8225b28 <Netinit+0x454>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 82258e4:	008209b4 	movhi	r2,2086
 82258e8:	10b6b204 	addi	r2,r2,-9528
 82258ec:	e0fffe17 	ldw	r3,-8(fp)
 82258f0:	18c7883a 	add	r3,r3,r3
 82258f4:	18c7883a 	add	r3,r3,r3
 82258f8:	10c5883a 	add	r2,r2,r3
 82258fc:	10800017 	ldw	r2,0(r2)
 8225900:	10800217 	ldw	r2,8(r2)
 8225904:	e13ffe17 	ldw	r4,-8(fp)
 8225908:	103ee83a 	callr	r2
 822590c:	e0bfff15 	stw	r2,-4(fp)
 8225910:	e0bfff17 	ldw	r2,-4(fp)
 8225914:	10001026 	beq	r2,zero,8225958 <Netinit+0x284>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 8225918:	e1bffe17 	ldw	r6,-8(fp)
 822591c:	e17fff17 	ldw	r5,-4(fp)
 8225920:	01020974 	movhi	r4,2085
 8225924:	213e4704 	addi	r4,r4,-1764
 8225928:	8202e9c0 	call	8202e9c <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 822592c:	008209b4 	movhi	r2,2086
 8225930:	10b6b204 	addi	r2,r2,-9528
 8225934:	e0fffe17 	ldw	r3,-8(fp)
 8225938:	18c7883a 	add	r3,r3,r3
 822593c:	18c7883a 	add	r3,r3,r3
 8225940:	10c5883a 	add	r2,r2,r3
 8225944:	10800017 	ldw	r2,0(r2)
 8225948:	10802717 	ldw	r2,156(r2)
 822594c:	00c00084 	movi	r3,2
 8225950:	10c00715 	stw	r3,28(r2)
            continue;   /* ignore ifaces which fail */
 8225954:	0000cc06 	br	8225c88 <Netinit+0x5b4>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 8225958:	008209b4 	movhi	r2,2086
 822595c:	10b6b204 	addi	r2,r2,-9528
 8225960:	e0fffe17 	ldw	r3,-8(fp)
 8225964:	18c7883a 	add	r3,r3,r3
 8225968:	18c7883a 	add	r3,r3,r3
 822596c:	10c5883a 	add	r2,r2,r3
 8225970:	10800017 	ldw	r2,0(r2)
 8225974:	10802717 	ldw	r2,156(r2)
 8225978:	10800217 	ldw	r2,8(r2)
 822597c:	10800198 	cmpnei	r2,r2,6
 8225980:	1000111e 	bne	r2,zero,82259c8 <Netinit+0x2f4>
            nets[i]->n_flags |= NF_BCAST;
 8225984:	008209b4 	movhi	r2,2086
 8225988:	10b6b204 	addi	r2,r2,-9528
 822598c:	e0fffe17 	ldw	r3,-8(fp)
 8225990:	18c7883a 	add	r3,r3,r3
 8225994:	18c7883a 	add	r3,r3,r3
 8225998:	10c5883a 	add	r2,r2,r3
 822599c:	11000017 	ldw	r4,0(r2)
 82259a0:	008209b4 	movhi	r2,2086
 82259a4:	10b6b204 	addi	r2,r2,-9528
 82259a8:	e0fffe17 	ldw	r3,-8(fp)
 82259ac:	18c7883a 	add	r3,r3,r3
 82259b0:	18c7883a 	add	r3,r3,r3
 82259b4:	10c5883a 	add	r2,r2,r3
 82259b8:	10800017 	ldw	r2,0(r2)
 82259bc:	10802a17 	ldw	r2,168(r2)
 82259c0:	10800054 	ori	r2,r2,1
 82259c4:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 82259c8:	008209b4 	movhi	r2,2086
 82259cc:	10b6b204 	addi	r2,r2,-9528
 82259d0:	e0fffe17 	ldw	r3,-8(fp)
 82259d4:	18c7883a 	add	r3,r3,r3
 82259d8:	18c7883a 	add	r3,r3,r3
 82259dc:	10c5883a 	add	r2,r2,r3
 82259e0:	10800017 	ldw	r2,0(r2)
 82259e4:	10802717 	ldw	r2,156(r2)
 82259e8:	00c00044 	movi	r3,1
 82259ec:	10c00615 	stw	r3,24(r2)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 82259f0:	008209b4 	movhi	r2,2086
 82259f4:	10b6b204 	addi	r2,r2,-9528
 82259f8:	e0fffe17 	ldw	r3,-8(fp)
 82259fc:	18c7883a 	add	r3,r3,r3
 8225a00:	18c7883a 	add	r3,r3,r3
 8225a04:	10c5883a 	add	r2,r2,r3
 8225a08:	10800017 	ldw	r2,0(r2)
 8225a0c:	10800103 	ldbu	r2,4(r2)
 8225a10:	10803fcc 	andi	r2,r2,255
 8225a14:	1080201c 	xori	r2,r2,128
 8225a18:	10bfe004 	addi	r2,r2,-128
 8225a1c:	1000421e 	bne	r2,zero,8225b28 <Netinit+0x454>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 8225a20:	008209b4 	movhi	r2,2086
 8225a24:	10b6b204 	addi	r2,r2,-9528
 8225a28:	e0fffe17 	ldw	r3,-8(fp)
 8225a2c:	18c7883a 	add	r3,r3,r3
 8225a30:	18c7883a 	add	r3,r3,r3
 8225a34:	10c5883a 	add	r2,r2,r3
 8225a38:	10800017 	ldw	r2,0(r2)
 8225a3c:	10802717 	ldw	r2,156(r2)
 8225a40:	10800217 	ldw	r2,8(r2)
 8225a44:	10800198 	cmpnei	r2,r2,6
 8225a48:	1000131e 	bne	r2,zero,8225a98 <Netinit+0x3c4>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 8225a4c:	008209b4 	movhi	r2,2086
 8225a50:	10b6b204 	addi	r2,r2,-9528
 8225a54:	e0fffe17 	ldw	r3,-8(fp)
 8225a58:	18c7883a 	add	r3,r3,r3
 8225a5c:	18c7883a 	add	r3,r3,r3
 8225a60:	10c5883a 	add	r2,r2,r3
 8225a64:	10800017 	ldw	r2,0(r2)
 8225a68:	00c01944 	movi	r3,101
 8225a6c:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 't';
 8225a70:	008209b4 	movhi	r2,2086
 8225a74:	10b6b204 	addi	r2,r2,-9528
 8225a78:	e0fffe17 	ldw	r3,-8(fp)
 8225a7c:	18c7883a 	add	r3,r3,r3
 8225a80:	18c7883a 	add	r3,r3,r3
 8225a84:	10c5883a 	add	r2,r2,r3
 8225a88:	10800017 	ldw	r2,0(r2)
 8225a8c:	00c01d04 	movi	r3,116
 8225a90:	10c00145 	stb	r3,5(r2)
 8225a94:	00001206 	br	8225ae0 <Netinit+0x40c>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 8225a98:	008209b4 	movhi	r2,2086
 8225a9c:	10b6b204 	addi	r2,r2,-9528
 8225aa0:	e0fffe17 	ldw	r3,-8(fp)
 8225aa4:	18c7883a 	add	r3,r3,r3
 8225aa8:	18c7883a 	add	r3,r3,r3
 8225aac:	10c5883a 	add	r2,r2,r3
 8225ab0:	10800017 	ldw	r2,0(r2)
 8225ab4:	00c01a44 	movi	r3,105
 8225ab8:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 'f';
 8225abc:	008209b4 	movhi	r2,2086
 8225ac0:	10b6b204 	addi	r2,r2,-9528
 8225ac4:	e0fffe17 	ldw	r3,-8(fp)
 8225ac8:	18c7883a 	add	r3,r3,r3
 8225acc:	18c7883a 	add	r3,r3,r3
 8225ad0:	10c5883a 	add	r2,r2,r3
 8225ad4:	10800017 	ldw	r2,0(r2)
 8225ad8:	00c01984 	movi	r3,102
 8225adc:	10c00145 	stb	r3,5(r2)
            }
            nets[i]->name[2] = (char)(i + '1');
 8225ae0:	008209b4 	movhi	r2,2086
 8225ae4:	10b6b204 	addi	r2,r2,-9528
 8225ae8:	e0fffe17 	ldw	r3,-8(fp)
 8225aec:	18c7883a 	add	r3,r3,r3
 8225af0:	18c7883a 	add	r3,r3,r3
 8225af4:	10c5883a 	add	r2,r2,r3
 8225af8:	10800017 	ldw	r2,0(r2)
 8225afc:	e0fffe17 	ldw	r3,-8(fp)
 8225b00:	18c00c44 	addi	r3,r3,49
 8225b04:	10c00185 	stb	r3,6(r2)
            nets[i]->name[3] = '\0';
 8225b08:	008209b4 	movhi	r2,2086
 8225b0c:	10b6b204 	addi	r2,r2,-9528
 8225b10:	e0fffe17 	ldw	r3,-8(fp)
 8225b14:	18c7883a 	add	r3,r3,r3
 8225b18:	18c7883a 	add	r3,r3,r3
 8225b1c:	10c5883a 	add	r2,r2,r3
 8225b20:	10800017 	ldw	r2,0(r2)
 8225b24:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 8225b28:	e13ffe17 	ldw	r4,-8(fp)
 8225b2c:	8225cbc0 	call	8225cbc <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 8225b30:	008209b4 	movhi	r2,2086
 8225b34:	10b6b204 	addi	r2,r2,-9528
 8225b38:	e0fffe17 	ldw	r3,-8(fp)
 8225b3c:	18c7883a 	add	r3,r3,r3
 8225b40:	18c7883a 	add	r3,r3,r3
 8225b44:	10c5883a 	add	r2,r2,r3
 8225b48:	10800017 	ldw	r2,0(r2)
 8225b4c:	10800a17 	ldw	r2,40(r2)
 8225b50:	10004d26 	beq	r2,zero,8225c88 <Netinit+0x5b4>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225b54:	008209b4 	movhi	r2,2086
 8225b58:	10b6b204 	addi	r2,r2,-9528
 8225b5c:	e0fffe17 	ldw	r3,-8(fp)
 8225b60:	18c7883a 	add	r3,r3,r3
 8225b64:	18c7883a 	add	r3,r3,r3
 8225b68:	10c5883a 	add	r2,r2,r3
 8225b6c:	11000017 	ldw	r4,0(r2)
 8225b70:	008209b4 	movhi	r2,2086
 8225b74:	10b6b204 	addi	r2,r2,-9528
 8225b78:	e0fffe17 	ldw	r3,-8(fp)
 8225b7c:	18c7883a 	add	r3,r3,r3
 8225b80:	18c7883a 	add	r3,r3,r3
 8225b84:	10c5883a 	add	r2,r2,r3
 8225b88:	10800017 	ldw	r2,0(r2)
 8225b8c:	11400a17 	ldw	r5,40(r2)
 8225b90:	008209b4 	movhi	r2,2086
 8225b94:	10b6b204 	addi	r2,r2,-9528
 8225b98:	e0fffe17 	ldw	r3,-8(fp)
 8225b9c:	18c7883a 	add	r3,r3,r3
 8225ba0:	18c7883a 	add	r3,r3,r3
 8225ba4:	10c5883a 	add	r2,r2,r3
 8225ba8:	10800017 	ldw	r2,0(r2)
 8225bac:	10800c17 	ldw	r2,48(r2)
 8225bb0:	0084303a 	nor	r2,zero,r2
 8225bb4:	2884b03a 	or	r2,r5,r2
 8225bb8:	20800e15 	stw	r2,56(r4)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 8225bbc:	008209b4 	movhi	r2,2086
 8225bc0:	10b6b204 	addi	r2,r2,-9528
 8225bc4:	e0fffe17 	ldw	r3,-8(fp)
 8225bc8:	18c7883a 	add	r3,r3,r3
 8225bcc:	18c7883a 	add	r3,r3,r3
 8225bd0:	10c5883a 	add	r2,r2,r3
 8225bd4:	11000017 	ldw	r4,0(r2)
 8225bd8:	008209b4 	movhi	r2,2086
 8225bdc:	10b6b204 	addi	r2,r2,-9528
 8225be0:	e0fffe17 	ldw	r3,-8(fp)
 8225be4:	18c7883a 	add	r3,r3,r3
 8225be8:	18c7883a 	add	r3,r3,r3
 8225bec:	10c5883a 	add	r2,r2,r3
 8225bf0:	10800017 	ldw	r2,0(r2)
 8225bf4:	11400a17 	ldw	r5,40(r2)
 8225bf8:	008209b4 	movhi	r2,2086
 8225bfc:	10b6b204 	addi	r2,r2,-9528
 8225c00:	e0fffe17 	ldw	r3,-8(fp)
 8225c04:	18c7883a 	add	r3,r3,r3
 8225c08:	18c7883a 	add	r3,r3,r3
 8225c0c:	10c5883a 	add	r2,r2,r3
 8225c10:	10800017 	ldw	r2,0(r2)
 8225c14:	10800c17 	ldw	r2,48(r2)
 8225c18:	2884703a 	and	r2,r5,r2
 8225c1c:	20800f15 	stw	r2,60(r4)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225c20:	008209b4 	movhi	r2,2086
 8225c24:	10b6b204 	addi	r2,r2,-9528
 8225c28:	e0fffe17 	ldw	r3,-8(fp)
 8225c2c:	18c7883a 	add	r3,r3,r3
 8225c30:	18c7883a 	add	r3,r3,r3
 8225c34:	10c5883a 	add	r2,r2,r3
 8225c38:	11000017 	ldw	r4,0(r2)
 8225c3c:	008209b4 	movhi	r2,2086
 8225c40:	10b6b204 	addi	r2,r2,-9528
 8225c44:	e0fffe17 	ldw	r3,-8(fp)
 8225c48:	18c7883a 	add	r3,r3,r3
 8225c4c:	18c7883a 	add	r3,r3,r3
 8225c50:	10c5883a 	add	r2,r2,r3
 8225c54:	10800017 	ldw	r2,0(r2)
 8225c58:	11400a17 	ldw	r5,40(r2)
 8225c5c:	008209b4 	movhi	r2,2086
 8225c60:	10b6b204 	addi	r2,r2,-9528
 8225c64:	e0fffe17 	ldw	r3,-8(fp)
 8225c68:	18c7883a 	add	r3,r3,r3
 8225c6c:	18c7883a 	add	r3,r3,r3
 8225c70:	10c5883a 	add	r2,r2,r3
 8225c74:	10800017 	ldw	r2,0(r2)
 8225c78:	10800c17 	ldw	r2,48(r2)
 8225c7c:	0084303a 	nor	r2,zero,r2
 8225c80:	2884b03a 	or	r2,r5,r2
 8225c84:	20801015 	stw	r2,64(r4)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8225c88:	e0bffe17 	ldw	r2,-8(fp)
 8225c8c:	10800044 	addi	r2,r2,1
 8225c90:	e0bffe15 	stw	r2,-8(fp)
 8225c94:	d0a08417 	ldw	r2,-32240(gp)
 8225c98:	1007883a 	mov	r3,r2
 8225c9c:	e0bffe17 	ldw	r2,-8(fp)
 8225ca0:	10ff0716 	blt	r2,r3,82258c0 <Netinit+0x1ec>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 8225ca4:	0005883a 	mov	r2,zero
}
 8225ca8:	e037883a 	mov	sp,fp
 8225cac:	dfc00117 	ldw	ra,4(sp)
 8225cb0:	df000017 	ldw	fp,0(sp)
 8225cb4:	dec00204 	addi	sp,sp,8
 8225cb8:	f800283a 	ret

08225cbc <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 8225cbc:	defffc04 	addi	sp,sp,-16
 8225cc0:	dfc00315 	stw	ra,12(sp)
 8225cc4:	df000215 	stw	fp,8(sp)
 8225cc8:	df000204 	addi	fp,sp,8
 8225ccc:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 8225cd0:	008209b4 	movhi	r2,2086
 8225cd4:	10b6b204 	addi	r2,r2,-9528
 8225cd8:	e0ffff17 	ldw	r3,-4(fp)
 8225cdc:	18c7883a 	add	r3,r3,r3
 8225ce0:	18c7883a 	add	r3,r3,r3
 8225ce4:	10c5883a 	add	r2,r2,r3
 8225ce8:	10800017 	ldw	r2,0(r2)
 8225cec:	10800c17 	ldw	r2,48(r2)
 8225cf0:	1000421e 	bne	r2,zero,8225dfc <fixup_subnet_mask+0x140>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 8225cf4:	008209b4 	movhi	r2,2086
 8225cf8:	10b6b204 	addi	r2,r2,-9528
 8225cfc:	e0ffff17 	ldw	r3,-4(fp)
 8225d00:	18c7883a 	add	r3,r3,r3
 8225d04:	18c7883a 	add	r3,r3,r3
 8225d08:	10c5883a 	add	r2,r2,r3
 8225d0c:	10800017 	ldw	r2,0(r2)
 8225d10:	10800a17 	ldw	r2,40(r2)
 8225d14:	1080200c 	andi	r2,r2,128
 8225d18:	1000031e 	bne	r2,zero,8225d28 <fixup_subnet_mask+0x6c>
      smask = 0xFF000000L;
 8225d1c:	00bfc034 	movhi	r2,65280
 8225d20:	e0bffe15 	stw	r2,-8(fp)
 8225d24:	00001f06 	br	8225da4 <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 8225d28:	008209b4 	movhi	r2,2086
 8225d2c:	10b6b204 	addi	r2,r2,-9528
 8225d30:	e0ffff17 	ldw	r3,-4(fp)
 8225d34:	18c7883a 	add	r3,r3,r3
 8225d38:	18c7883a 	add	r3,r3,r3
 8225d3c:	10c5883a 	add	r2,r2,r3
 8225d40:	10800017 	ldw	r2,0(r2)
 8225d44:	10800a17 	ldw	r2,40(r2)
 8225d48:	1080300c 	andi	r2,r2,192
 8225d4c:	10802018 	cmpnei	r2,r2,128
 8225d50:	1000031e 	bne	r2,zero,8225d60 <fixup_subnet_mask+0xa4>
      smask = 0xFFFF0000L;
 8225d54:	00bffff4 	movhi	r2,65535
 8225d58:	e0bffe15 	stw	r2,-8(fp)
 8225d5c:	00001106 	br	8225da4 <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 8225d60:	008209b4 	movhi	r2,2086
 8225d64:	10b6b204 	addi	r2,r2,-9528
 8225d68:	e0ffff17 	ldw	r3,-4(fp)
 8225d6c:	18c7883a 	add	r3,r3,r3
 8225d70:	18c7883a 	add	r3,r3,r3
 8225d74:	10c5883a 	add	r2,r2,r3
 8225d78:	10800017 	ldw	r2,0(r2)
 8225d7c:	10800a17 	ldw	r2,40(r2)
 8225d80:	1080380c 	andi	r2,r2,224
 8225d84:	10803018 	cmpnei	r2,r2,192
 8225d88:	1000031e 	bne	r2,zero,8225d98 <fixup_subnet_mask+0xdc>
      smask = 0xFFFFFF00L;
 8225d8c:	00bfc004 	movi	r2,-256
 8225d90:	e0bffe15 	stw	r2,-8(fp)
 8225d94:	00000306 	br	8225da4 <fixup_subnet_mask+0xe8>
   else
   {
      dtrap();    /* bad logic or setup values */
 8225d98:	822d1c80 	call	822d1c8 <dtrap>
      smask = 0xFFFFFF00L;
 8225d9c:	00bfc004 	movi	r2,-256
 8225da0:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 8225da4:	008209b4 	movhi	r2,2086
 8225da8:	10b6b204 	addi	r2,r2,-9528
 8225dac:	e0ffff17 	ldw	r3,-4(fp)
 8225db0:	18c7883a 	add	r3,r3,r3
 8225db4:	18c7883a 	add	r3,r3,r3
 8225db8:	10c5883a 	add	r2,r2,r3
 8225dbc:	10800017 	ldw	r2,0(r2)
 8225dc0:	e0fffe17 	ldw	r3,-8(fp)
 8225dc4:	1808d63a 	srli	r4,r3,24
 8225dc8:	e0fffe17 	ldw	r3,-8(fp)
 8225dcc:	1806d23a 	srli	r3,r3,8
 8225dd0:	18ffc00c 	andi	r3,r3,65280
 8225dd4:	20c8b03a 	or	r4,r4,r3
 8225dd8:	e0fffe17 	ldw	r3,-8(fp)
 8225ddc:	18ffc00c 	andi	r3,r3,65280
 8225de0:	1806923a 	slli	r3,r3,8
 8225de4:	20c8b03a 	or	r4,r4,r3
 8225de8:	e0fffe17 	ldw	r3,-8(fp)
 8225dec:	1806963a 	slli	r3,r3,24
 8225df0:	20c6b03a 	or	r3,r4,r3
 8225df4:	10c00c15 	stw	r3,48(r2)
 8225df8:	00000106 	br	8225e00 <fixup_subnet_mask+0x144>
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
      return;
 8225dfc:	0001883a 	nop
   {
      dtrap();    /* bad logic or setup values */
      smask = 0xFFFFFF00L;
   }
   nets[netnum]->snmask = htonl(smask);
}
 8225e00:	e037883a 	mov	sp,fp
 8225e04:	dfc00117 	ldw	ra,4(sp)
 8225e08:	df000017 	ldw	fp,0(sp)
 8225e0c:	dec00204 	addi	sp,sp,8
 8225e10:	f800283a 	ret

08225e14 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 8225e14:	defffc04 	addi	sp,sp,-16
 8225e18:	dfc00315 	stw	ra,12(sp)
 8225e1c:	df000215 	stw	fp,8(sp)
 8225e20:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 8225e24:	e03fff15 	stw	zero,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 8225e28:	d0a08317 	ldw	r2,-32244(gp)
 8225e2c:	1080010c 	andi	r2,r2,4
 8225e30:	10000326 	beq	r2,zero,8225e40 <netclose+0x2c>
 8225e34:	01020974 	movhi	r4,2085
 8225e38:	213e4e04 	addi	r4,r4,-1736
 8225e3c:	82031200 	call	8203120 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8225e40:	008209b4 	movhi	r2,2086
 8225e44:	10b8f304 	addi	r2,r2,-7220
 8225e48:	10800017 	ldw	r2,0(r2)
 8225e4c:	e0bffe15 	stw	r2,-8(fp)
 8225e50:	00002106 	br	8225ed8 <netclose+0xc4>
   {
      if (ifp->n_close)
 8225e54:	e0bffe17 	ldw	r2,-8(fp)
 8225e58:	10800517 	ldw	r2,20(r2)
 8225e5c:	10000f26 	beq	r2,zero,8225e9c <netclose+0x88>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 8225e60:	e0bffe17 	ldw	r2,-8(fp)
 8225e64:	10802717 	ldw	r2,156(r2)
 8225e68:	10800117 	ldw	r2,4(r2)
 8225e6c:	100b883a 	mov	r5,r2
 8225e70:	01020974 	movhi	r4,2085
 8225e74:	213e5304 	addi	r4,r4,-1716
 8225e78:	8202e9c0 	call	8202e9c <printf>
         (*(ifp->n_close))(index++);
 8225e7c:	e0bffe17 	ldw	r2,-8(fp)
 8225e80:	10c00517 	ldw	r3,20(r2)
 8225e84:	e0bfff17 	ldw	r2,-4(fp)
 8225e88:	11000044 	addi	r4,r2,1
 8225e8c:	e13fff15 	stw	r4,-4(fp)
 8225e90:	1009883a 	mov	r4,r2
 8225e94:	183ee83a 	callr	r3
 8225e98:	00000c06 	br	8225ecc <netclose+0xb8>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 8225e9c:	d0a08317 	ldw	r2,-32244(gp)
 8225ea0:	1080010c 	andi	r2,r2,4
 8225ea4:	10000626 	beq	r2,zero,8225ec0 <netclose+0xac>
 8225ea8:	e0bffe17 	ldw	r2,-8(fp)
 8225eac:	10800104 	addi	r2,r2,4
 8225eb0:	100b883a 	mov	r5,r2
 8225eb4:	01020974 	movhi	r4,2085
 8225eb8:	213e5a04 	addi	r4,r4,-1688
 8225ebc:	8202e9c0 	call	8202e9c <printf>
#endif
         index++;
 8225ec0:	e0bfff17 	ldw	r2,-4(fp)
 8225ec4:	10800044 	addi	r2,r2,1
 8225ec8:	e0bfff15 	stw	r2,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8225ecc:	e0bffe17 	ldw	r2,-8(fp)
 8225ed0:	10800017 	ldw	r2,0(r2)
 8225ed4:	e0bffe15 	stw	r2,-8(fp)
 8225ed8:	e0bffe17 	ldw	r2,-8(fp)
 8225edc:	103fdd1e 	bne	r2,zero,8225e54 <netclose+0x40>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 8225ee0:	0001883a 	nop
 8225ee4:	e037883a 	mov	sp,fp
 8225ee8:	dfc00117 	ldw	ra,4(sp)
 8225eec:	df000017 	ldw	fp,0(sp)
 8225ef0:	dec00204 	addi	sp,sp,8
 8225ef4:	f800283a 	ret

08225ef8 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 8225ef8:	defff904 	addi	sp,sp,-28
 8225efc:	dfc00615 	stw	ra,24(sp)
 8225f00:	df000515 	stw	fp,20(sp)
 8225f04:	df000504 	addi	fp,sp,20
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 8225f08:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 8225f0c:	0000d906 	br	8226274 <pktdemux+0x37c>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 8225f10:	e0fffb17 	ldw	r3,-20(fp)
 8225f14:	18800044 	addi	r2,r3,1
 8225f18:	e0bffb15 	stw	r2,-20(fp)
 8225f1c:	008209b4 	movhi	r2,2086
 8225f20:	10b75904 	addi	r2,r2,-8860
 8225f24:	10800217 	ldw	r2,8(r2)
 8225f28:	10c0020e 	bge	r2,r3,8225f34 <pktdemux+0x3c>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 8225f2c:	82294400 	call	8229440 <tk_yield>
         pkts = 0;   /* reset counter */
 8225f30:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 8225f34:	01000044 	movi	r4,1
 8225f38:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 8225f3c:	010209b4 	movhi	r4,2086
 8225f40:	2135ed04 	addi	r4,r4,-10316
 8225f44:	822caf80 	call	822caf8 <getq>
 8225f48:	e0bffc15 	stw	r2,-16(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 8225f4c:	01000044 	movi	r4,1
 8225f50:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 8225f54:	e0bffc17 	ldw	r2,-16(fp)
 8225f58:	1000031e 	bne	r2,zero,8225f68 <pktdemux+0x70>
 8225f5c:	01020974 	movhi	r4,2085
 8225f60:	213e6104 	addi	r4,r4,-1660
 8225f64:	822887c0 	call	822887c <panic>
      ifc = pkt->net;
 8225f68:	e0bffc17 	ldw	r2,-16(fp)
 8225f6c:	10800617 	ldw	r2,24(r2)
 8225f70:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 8225f74:	e0bffd17 	ldw	r2,-12(fp)
 8225f78:	10802717 	ldw	r2,156(r2)
 8225f7c:	e0bffe15 	stw	r2,-8(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 8225f80:	e0bffc17 	ldw	r2,-16(fp)
 8225f84:	10800117 	ldw	r2,4(r2)
 8225f88:	10800084 	addi	r2,r2,2
 8225f8c:	100b883a 	mov	r5,r2
 8225f90:	e13ffd17 	ldw	r4,-12(fp)
 8225f94:	823ea0c0 	call	823ea0c <isbcast>
 8225f98:	10000626 	beq	r2,zero,8225fb4 <pktdemux+0xbc>
         mib->ifInNUcastPkts++;
 8225f9c:	e0bffe17 	ldw	r2,-8(fp)
 8225fa0:	10800b17 	ldw	r2,44(r2)
 8225fa4:	10c00044 	addi	r3,r2,1
 8225fa8:	e0bffe17 	ldw	r2,-8(fp)
 8225fac:	10c00b15 	stw	r3,44(r2)
 8225fb0:	00000506 	br	8225fc8 <pktdemux+0xd0>
      else
         mib->ifInUcastPkts++;
 8225fb4:	e0bffe17 	ldw	r2,-8(fp)
 8225fb8:	10800a17 	ldw	r2,40(r2)
 8225fbc:	10c00044 	addi	r3,r2,1
 8225fc0:	e0bffe17 	ldw	r2,-8(fp)
 8225fc4:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 8225fc8:	e0bffe17 	ldw	r2,-8(fp)
 8225fcc:	10800617 	ldw	r2,24(r2)
 8225fd0:	10800098 	cmpnei	r2,r2,2
 8225fd4:	10000c1e 	bne	r2,zero,8226008 <pktdemux+0x110>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8225fd8:	01000084 	movi	r4,2
 8225fdc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 8225fe0:	e13ffc17 	ldw	r4,-16(fp)
 8225fe4:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8225fe8:	01000084 	movi	r4,2
 8225fec:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 8225ff0:	e0bffe17 	ldw	r2,-8(fp)
 8225ff4:	10800c17 	ldw	r2,48(r2)
 8225ff8:	10c00044 	addi	r3,r2,1
 8225ffc:	e0bffe17 	ldw	r2,-8(fp)
 8226000:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 8226004:	00009b06 	br	8226274 <pktdemux+0x37c>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 8226008:	e0bffc17 	ldw	r2,-16(fp)
 822600c:	10800117 	ldw	r2,4(r2)
 8226010:	10bfff04 	addi	r2,r2,-4
 8226014:	10800003 	ldbu	r2,0(r2)
 8226018:	10803fcc 	andi	r2,r2,255
 822601c:	1080201c 	xori	r2,r2,128
 8226020:	10bfe004 	addi	r2,r2,-128
 8226024:	10801358 	cmpnei	r2,r2,77
 8226028:	10000b1e 	bne	r2,zero,8226058 <pktdemux+0x160>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
 822602c:	e0bffc17 	ldw	r2,-16(fp)
 8226030:	10c00117 	ldw	r3,4(r2)
 8226034:	e0bffc17 	ldw	r2,-16(fp)
 8226038:	10800217 	ldw	r2,8(r2)
 822603c:	1885883a 	add	r2,r3,r2
 8226040:	10800003 	ldbu	r2,0(r2)
         mib->ifInDiscards++;
         continue;      /* next packet */
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 8226044:	10803fcc 	andi	r2,r2,255
 8226048:	1080201c 	xori	r2,r2,128
 822604c:	10bfe004 	addi	r2,r2,-128
 8226050:	10801360 	cmpeqi	r2,r2,77
 8226054:	1000041e 	bne	r2,zero,8226068 <pktdemux+0x170>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 8226058:	822d1c80 	call	822d1c8 <dtrap>
         panic("pktdemux: corrupt pkt");
 822605c:	01020974 	movhi	r4,2085
 8226060:	213e6704 	addi	r4,r4,-1636
 8226064:	822887c0 	call	822887c <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 8226068:	e0bffd17 	ldw	r2,-12(fp)
 822606c:	10802a17 	ldw	r2,168(r2)
 8226070:	1080020c 	andi	r2,r2,8
 8226074:	1000491e 	bne	r2,zero,822619c <pktdemux+0x2a4>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 8226078:	e0bffd17 	ldw	r2,-12(fp)
 822607c:	10802717 	ldw	r2,156(r2)
 8226080:	10800217 	ldw	r2,8(r2)
 8226084:	108001a0 	cmpeqi	r2,r2,6
 8226088:	10003626 	beq	r2,zero,8226164 <pktdemux+0x26c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 822608c:	e0bffc17 	ldw	r2,-16(fp)
 8226090:	10800117 	ldw	r2,4(r2)
 8226094:	10800084 	addi	r2,r2,2
 8226098:	e0bfff15 	stw	r2,-4(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 822609c:	e0bfff17 	ldw	r2,-4(fp)
 82260a0:	10800304 	addi	r2,r2,12
 82260a4:	10800003 	ldbu	r2,0(r2)
 82260a8:	10803fcc 	andi	r2,r2,255
 82260ac:	1080201c 	xori	r2,r2,128
 82260b0:	10bfe004 	addi	r2,r2,-128
 82260b4:	1004923a 	slli	r2,r2,8
 82260b8:	1007883a 	mov	r3,r2
 82260bc:	e0bfff17 	ldw	r2,-4(fp)
 82260c0:	10800344 	addi	r2,r2,13
 82260c4:	10800003 	ldbu	r2,0(r2)
 82260c8:	10803fcc 	andi	r2,r2,255
 82260cc:	1080201c 	xori	r2,r2,128
 82260d0:	10bfe004 	addi	r2,r2,-128
 82260d4:	10803fcc 	andi	r2,r2,255
 82260d8:	1885883a 	add	r2,r3,r2
 82260dc:	10bfffcc 	andi	r2,r2,65535
 82260e0:	1004d23a 	srli	r2,r2,8
 82260e4:	1007883a 	mov	r3,r2
 82260e8:	e0bfff17 	ldw	r2,-4(fp)
 82260ec:	10800304 	addi	r2,r2,12
 82260f0:	10800003 	ldbu	r2,0(r2)
 82260f4:	10803fcc 	andi	r2,r2,255
 82260f8:	1080201c 	xori	r2,r2,128
 82260fc:	10bfe004 	addi	r2,r2,-128
 8226100:	1004923a 	slli	r2,r2,8
 8226104:	1009883a 	mov	r4,r2
 8226108:	e0bfff17 	ldw	r2,-4(fp)
 822610c:	10800344 	addi	r2,r2,13
 8226110:	10800003 	ldbu	r2,0(r2)
 8226114:	10803fcc 	andi	r2,r2,255
 8226118:	1080201c 	xori	r2,r2,128
 822611c:	10bfe004 	addi	r2,r2,-128
 8226120:	10803fcc 	andi	r2,r2,255
 8226124:	2085883a 	add	r2,r4,r2
 8226128:	10bfffcc 	andi	r2,r2,65535
 822612c:	1004923a 	slli	r2,r2,8
 8226130:	1884b03a 	or	r2,r3,r2
 8226134:	1007883a 	mov	r3,r2
 8226138:	e0bffc17 	ldw	r2,-16(fp)
 822613c:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 8226140:	e0bffc17 	ldw	r2,-16(fp)
 8226144:	10800117 	ldw	r2,4(r2)
 8226148:	e0fffc17 	ldw	r3,-16(fp)
 822614c:	18c00617 	ldw	r3,24(r3)
 8226150:	18c00817 	ldw	r3,32(r3)
 8226154:	10c7883a 	add	r3,r2,r3
 8226158:	e0bffc17 	ldw	r2,-16(fp)
 822615c:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 8226160:	00000e06 	br	822619c <pktdemux+0x2a4>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 8226164:	e0bffd17 	ldw	r2,-12(fp)
 8226168:	10802717 	ldw	r2,156(r2)
 822616c:	10800217 	ldw	r2,8(r2)
 8226170:	100b883a 	mov	r5,r2
 8226174:	01020974 	movhi	r4,2085
 8226178:	213e6d04 	addi	r4,r4,-1612
 822617c:	8202e9c0 	call	8202e9c <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8226180:	01000084 	movi	r4,2
 8226184:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 8226188:	e13ffc17 	ldw	r4,-16(fp)
 822618c:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226190:	01000084 	movi	r4,2
 8226194:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            continue;
 8226198:	00003606 	br	8226274 <pktdemux+0x37c>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 822619c:	e0bffc17 	ldw	r2,-16(fp)
 82261a0:	1080080b 	ldhu	r2,32(r2)
 82261a4:	10bfffcc 	andi	r2,r2,65535
 82261a8:	10c00220 	cmpeqi	r3,r2,8
 82261ac:	1800031e 	bne	r3,zero,82261bc <pktdemux+0x2c4>
 82261b0:	10818220 	cmpeqi	r2,r2,1544
 82261b4:	1000081e 	bne	r2,zero,82261d8 <pktdemux+0x2e0>
 82261b8:	00000e06 	br	82261f4 <pktdemux+0x2fc>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82261bc:	0009883a 	mov	r4,zero
 82261c0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 82261c4:	e13ffc17 	ldw	r4,-16(fp)
 82261c8:	82428840 	call	8242884 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 82261cc:	0009883a 	mov	r4,zero
 82261d0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         break;
 82261d4:	00002606 	br	8226270 <pktdemux+0x378>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82261d8:	0009883a 	mov	r4,zero
 82261dc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 82261e0:	e13ffc17 	ldw	r4,-16(fp)
 82261e4:	823e1f40 	call	823e1f4 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 82261e8:	0009883a 	mov	r4,zero
 82261ec:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         break;
 82261f0:	00001f06 	br	8226270 <pktdemux+0x378>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 82261f4:	d0a08317 	ldw	r2,-32244(gp)
 82261f8:	1081000c 	andi	r2,r2,1024
 82261fc:	10001026 	beq	r2,zero,8226240 <pktdemux+0x348>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 8226200:	e0bffc17 	ldw	r2,-16(fp)
 8226204:	1080080b 	ldhu	r2,32(r2)
 8226208:	10bfffcc 	andi	r2,r2,65535
 822620c:	1004d23a 	srli	r2,r2,8
 8226210:	10bfffcc 	andi	r2,r2,65535
 8226214:	10c03fcc 	andi	r3,r2,255
 8226218:	e0bffc17 	ldw	r2,-16(fp)
 822621c:	1080080b 	ldhu	r2,32(r2)
 8226220:	10bfffcc 	andi	r2,r2,65535
 8226224:	1004923a 	slli	r2,r2,8
 8226228:	10bfffcc 	andi	r2,r2,65535
 822622c:	1884b03a 	or	r2,r3,r2
 8226230:	100b883a 	mov	r5,r2
 8226234:	01020974 	movhi	r4,2085
 8226238:	213e7504 	addi	r4,r4,-1580
 822623c:	8202e9c0 	call	8202e9c <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 8226240:	e0bffd17 	ldw	r2,-12(fp)
 8226244:	10802717 	ldw	r2,156(r2)
 8226248:	10c00e17 	ldw	r3,56(r2)
 822624c:	18c00044 	addi	r3,r3,1
 8226250:	10c00e15 	stw	r3,56(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226254:	01000084 	movi	r4,2
 8226258:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 822625c:	e13ffc17 	ldw	r4,-16(fp)
 8226260:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226264:	01000084 	movi	r4,2
 8226268:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         break;
 822626c:	0001883a 	nop
      }
      continue;
 8226270:	0001883a 	nop
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 8226274:	008209b4 	movhi	r2,2086
 8226278:	10b5ed04 	addi	r2,r2,-10316
 822627c:	10800217 	ldw	r2,8(r2)
 8226280:	103f231e 	bne	r2,zero,8225f10 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 8226284:	0001883a 	nop
 8226288:	e037883a 	mov	sp,fp
 822628c:	dfc00117 	ldw	ra,4(sp)
 8226290:	df000017 	ldw	fp,0(sp)
 8226294:	dec00204 	addi	sp,sp,8
 8226298:	f800283a 	ret

0822629c <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 822629c:	defffd04 	addi	sp,sp,-12
 82262a0:	df000215 	stw	fp,8(sp)
 82262a4:	df000204 	addi	fp,sp,8
 82262a8:	e13ffe15 	stw	r4,-8(fp)
 82262ac:	e17fff15 	stw	r5,-4(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82262b0:	d0a0a817 	ldw	r2,-32096(gp)
 82262b4:	10000c0e 	bge	r2,zero,82262e8 <c_older+0x4c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82262b8:	d0e0a817 	ldw	r3,-32096(gp)

u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82262bc:	e0bffe17 	ldw	r2,-8(fp)
 82262c0:	18800336 	bltu	r3,r2,82262d0 <c_older+0x34>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82262c4:	d0e0a817 	ldw	r3,-32096(gp)
 82262c8:	e0bfff17 	ldw	r2,-4(fp)
 82262cc:	1880062e 	bgeu	r3,r2,82262e8 <c_older+0x4c>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82262d0:	d0a0a817 	ldw	r2,-32096(gp)
u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82262d4:	e0fffe17 	ldw	r3,-8(fp)
 82262d8:	18800a36 	bltu	r3,r2,8226304 <c_older+0x68>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82262dc:	d0a0a817 	ldw	r2,-32096(gp)
 82262e0:	e0ffff17 	ldw	r3,-4(fp)
 82262e4:	18800736 	bltu	r3,r2,8226304 <c_older+0x68>
   {
      if (ct1 < ct2)
 82262e8:	e0fffe17 	ldw	r3,-8(fp)
 82262ec:	e0bfff17 	ldw	r2,-4(fp)
 82262f0:	1880022e 	bgeu	r3,r2,82262fc <c_older+0x60>
         return(ct1);      /* then smaller is oldest */
 82262f4:	e0bffe17 	ldw	r2,-8(fp)
 82262f8:	00000806 	br	822631c <c_older+0x80>
      else 
         return(ct2);
 82262fc:	e0bfff17 	ldw	r2,-4(fp)
 8226300:	00000606 	br	822631c <c_older+0x80>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 8226304:	e0fffe17 	ldw	r3,-8(fp)
 8226308:	e0bfff17 	ldw	r2,-4(fp)
 822630c:	18800236 	bltu	r3,r2,8226318 <c_older+0x7c>
      return(ct1);
 8226310:	e0bffe17 	ldw	r2,-8(fp)
 8226314:	00000106 	br	822631c <c_older+0x80>
   else
      return(ct2);
 8226318:	e0bfff17 	ldw	r2,-4(fp)
}
 822631c:	e037883a 	mov	sp,fp
 8226320:	df000017 	ldw	fp,0(sp)
 8226324:	dec00104 	addi	sp,sp,4
 8226328:	f800283a 	ret

0822632c <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 822632c:	defffb04 	addi	sp,sp,-20
 8226330:	dfc00415 	stw	ra,16(sp)
 8226334:	df000315 	stw	fp,12(sp)
 8226338:	df000304 	addi	fp,sp,12
 822633c:	e13ffe15 	stw	r4,-8(fp)
 8226340:	e17fff15 	stw	r5,-4(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 8226344:	e0bffe17 	ldw	r2,-8(fp)
 8226348:	10800617 	ldw	r2,24(r2)
 822634c:	10802717 	ldw	r2,156(r2)
 8226350:	e0bffd15 	stw	r2,-12(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 8226354:	e0bffd17 	ldw	r2,-12(fp)
 8226358:	10800617 	ldw	r2,24(r2)
 822635c:	10800098 	cmpnei	r2,r2,2
 8226360:	1000081e 	bne	r2,zero,8226384 <ip2mac+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8226364:	01000084 	movi	r4,2
 8226368:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 822636c:	e13ffe17 	ldw	r4,-8(fp)
 8226370:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226374:	01000084 	movi	r4,2
 8226378:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 822637c:	00bff7c4 	movi	r2,-33
 8226380:	00004806 	br	82264a4 <ip2mac+0x178>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 8226384:	e0bffe17 	ldw	r2,-8(fp)
 8226388:	10800617 	ldw	r2,24(r2)
 822638c:	10800817 	ldw	r2,32(r2)
 8226390:	10000826 	beq	r2,zero,82263b4 <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 8226394:	e0bffd17 	ldw	r2,-12(fp)
 8226398:	10800217 	ldw	r2,8(r2)
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 822639c:	108005e0 	cmpeqi	r2,r2,23
 82263a0:	1000041e 	bne	r2,zero,82263b4 <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
 82263a4:	e0bffd17 	ldw	r2,-12(fp)
 82263a8:	10800217 	ldw	r2,8(r2)
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 82263ac:	10800718 	cmpnei	r2,r2,28
 82263b0:	1000291e 	bne	r2,zero,8226458 <ip2mac+0x12c>
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 82263b4:	e0bffd17 	ldw	r2,-12(fp)
 82263b8:	10801017 	ldw	r2,64(r2)
 82263bc:	10c00044 	addi	r3,r2,1
 82263c0:	e0bffd17 	ldw	r2,-12(fp)
 82263c4:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 82263c8:	e0bffd17 	ldw	r2,-12(fp)
 82263cc:	10c00f17 	ldw	r3,60(r2)
 82263d0:	e0bffe17 	ldw	r2,-8(fp)
 82263d4:	10800417 	ldw	r2,16(r2)
 82263d8:	1887883a 	add	r3,r3,r2
 82263dc:	e0bffd17 	ldw	r2,-12(fp)
 82263e0:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 82263e4:	e0bffe17 	ldw	r2,-8(fp)
 82263e8:	10800617 	ldw	r2,24(r2)
 82263ec:	10800417 	ldw	r2,16(r2)
 82263f0:	10000626 	beq	r2,zero,822640c <ip2mac+0xe0>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 82263f4:	e0bffe17 	ldw	r2,-8(fp)
 82263f8:	10800617 	ldw	r2,24(r2)
 82263fc:	10800417 	ldw	r2,16(r2)
 8226400:	e13ffe17 	ldw	r4,-8(fp)
 8226404:	103ee83a 	callr	r2
 8226408:	00001106 	br	8226450 <ip2mac+0x124>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 822640c:	e0bffe17 	ldw	r2,-8(fp)
 8226410:	10800617 	ldw	r2,24(r2)
 8226414:	10800317 	ldw	r2,12(r2)
 8226418:	e0fffe17 	ldw	r3,-8(fp)
 822641c:	19000617 	ldw	r4,24(r3)
 8226420:	e0fffe17 	ldw	r3,-8(fp)
 8226424:	19400317 	ldw	r5,12(r3)
 8226428:	e0fffe17 	ldw	r3,-8(fp)
 822642c:	18c00417 	ldw	r3,16(r3)
 8226430:	180d883a 	mov	r6,r3
 8226434:	103ee83a 	callr	r2
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226438:	01000084 	movi	r4,2
 822643c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226440:	e13ffe17 	ldw	r4,-8(fp)
 8226444:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226448:	01000084 	movi	r4,2
 822644c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 8226450:	0005883a 	mov	r2,zero
 8226454:	00001306 	br	82264a4 <ip2mac+0x178>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 8226458:	e0bffe17 	ldw	r2,-8(fp)
 822645c:	10800617 	ldw	r2,24(r2)
 8226460:	10800a17 	ldw	r2,40(r2)
 8226464:	10000c1e 	bne	r2,zero,8226498 <ip2mac+0x16c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 8226468:	e0bffe17 	ldw	r2,-8(fp)
 822646c:	10800717 	ldw	r2,28(r2)
 8226470:	10bfffe0 	cmpeqi	r2,r2,-1
 8226474:	1000081e 	bne	r2,zero,8226498 <ip2mac+0x16c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226478:	01000084 	movi	r4,2
 822647c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226480:	e13ffe17 	ldw	r4,-8(fp)
 8226484:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226488:	01000084 	movi	r4,2
 822648c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 8226490:	00bff884 	movi	r2,-30
 8226494:	00000306 	br	82264a4 <ip2mac+0x178>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 8226498:	e17fff17 	ldw	r5,-4(fp)
 822649c:	e13ffe17 	ldw	r4,-8(fp)
 82264a0:	823e4580 	call	823e458 <send_via_arp>
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 82264a4:	e037883a 	mov	sp,fp
 82264a8:	dfc00117 	ldw	ra,4(sp)
 82264ac:	df000017 	ldw	fp,0(sp)
 82264b0:	dec00204 	addi	sp,sp,8
 82264b4:	f800283a 	ret

082264b8 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 82264b8:	defffc04 	addi	sp,sp,-16
 82264bc:	dfc00315 	stw	ra,12(sp)
 82264c0:	df000215 	stw	fp,8(sp)
 82264c4:	df000204 	addi	fp,sp,8
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 82264c8:	e03ffe15 	stw	zero,-8(fp)
 82264cc:	00002a06 	br	8226578 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 82264d0:	e0bffe17 	ldw	r2,-8(fp)
 82264d4:	10c03024 	muli	r3,r2,192
 82264d8:	008209b4 	movhi	r2,2086
 82264dc:	10b5f204 	addi	r2,r2,-10296
 82264e0:	1889883a 	add	r4,r3,r2
 82264e4:	008209b4 	movhi	r2,2086
 82264e8:	10b6b204 	addi	r2,r2,-9528
 82264ec:	e0fffe17 	ldw	r3,-8(fp)
 82264f0:	18c7883a 	add	r3,r3,r3
 82264f4:	18c7883a 	add	r3,r3,r3
 82264f8:	10c5883a 	add	r2,r2,r3
 82264fc:	11000015 	stw	r4,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 8226500:	008209b4 	movhi	r2,2086
 8226504:	10b6b204 	addi	r2,r2,-9528
 8226508:	e0fffe17 	ldw	r3,-8(fp)
 822650c:	18c7883a 	add	r3,r3,r3
 8226510:	18c7883a 	add	r3,r3,r3
 8226514:	10c5883a 	add	r2,r2,r3
 8226518:	11000017 	ldw	r4,0(r2)
 822651c:	008209b4 	movhi	r2,2086
 8226520:	10b6b204 	addi	r2,r2,-9528
 8226524:	e0fffe17 	ldw	r3,-8(fp)
 8226528:	18c7883a 	add	r3,r3,r3
 822652c:	18c7883a 	add	r3,r3,r3
 8226530:	10c5883a 	add	r2,r2,r3
 8226534:	10800017 	ldw	r2,0(r2)
 8226538:	10801204 	addi	r2,r2,72
 822653c:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 8226540:	008209b4 	movhi	r2,2086
 8226544:	10b6b204 	addi	r2,r2,-9528
 8226548:	e0fffe17 	ldw	r3,-8(fp)
 822654c:	18c7883a 	add	r3,r3,r3
 8226550:	18c7883a 	add	r3,r3,r3
 8226554:	10c5883a 	add	r2,r2,r3
 8226558:	10800017 	ldw	r2,0(r2)
 822655c:	100b883a 	mov	r5,r2
 8226560:	010209b4 	movhi	r4,2086
 8226564:	2138f304 	addi	r4,r4,-7220
 8226568:	822cbb00 	call	822cbb0 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 822656c:	e0bffe17 	ldw	r2,-8(fp)
 8226570:	10800044 	addi	r2,r2,1
 8226574:	e0bffe15 	stw	r2,-8(fp)
 8226578:	e0bffe17 	ldw	r2,-8(fp)
 822657c:	10800110 	cmplti	r2,r2,4
 8226580:	103fd31e 	bne	r2,zero,82264d0 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 8226584:	d0a08417 	ldw	r2,-32240(gp)
 8226588:	1009883a 	mov	r4,r2
 822658c:	82438600 	call	8243860 <prep_ifaces>
 8226590:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 8226594:	d0a08417 	ldw	r2,-32240(gp)
 8226598:	1000031e 	bne	r2,zero,82265a8 <ip_startup+0xf0>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 822659c:	00820974 	movhi	r2,2085
 82265a0:	10be8604 	addi	r2,r2,-1512
 82265a4:	00006806 	br	8226748 <ip_startup+0x290>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 82265a8:	d0a08417 	ldw	r2,-32240(gp)
 82265ac:	e0bffe15 	stw	r2,-8(fp)
 82265b0:	00001506 	br	8226608 <ip_startup+0x150>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 82265b4:	008209b4 	movhi	r2,2086
 82265b8:	10b6b204 	addi	r2,r2,-9528
 82265bc:	e0fffe17 	ldw	r3,-8(fp)
 82265c0:	18c7883a 	add	r3,r3,r3
 82265c4:	18c7883a 	add	r3,r3,r3
 82265c8:	10c5883a 	add	r2,r2,r3
 82265cc:	10800017 	ldw	r2,0(r2)
 82265d0:	100b883a 	mov	r5,r2
 82265d4:	010209b4 	movhi	r4,2086
 82265d8:	2138f304 	addi	r4,r4,-7220
 82265dc:	822cc600 	call	822cc60 <qdel>
      nets[i] = NULL;               /* remove from array */
 82265e0:	008209b4 	movhi	r2,2086
 82265e4:	10b6b204 	addi	r2,r2,-9528
 82265e8:	e0fffe17 	ldw	r3,-8(fp)
 82265ec:	18c7883a 	add	r3,r3,r3
 82265f0:	18c7883a 	add	r3,r3,r3
 82265f4:	10c5883a 	add	r2,r2,r3
 82265f8:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 82265fc:	e0bffe17 	ldw	r2,-8(fp)
 8226600:	10800044 	addi	r2,r2,1
 8226604:	e0bffe15 	stw	r2,-8(fp)
 8226608:	e0bffe17 	ldw	r2,-8(fp)
 822660c:	10800110 	cmplti	r2,r2,4
 8226610:	103fe81e 	bne	r2,zero,82265b4 <ip_startup+0xfc>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 8226614:	822d2ec0 	call	822d2ec <clock_init>
   exit_hook(clock_c);
 8226618:	010208f4 	movhi	r4,2083
 822661c:	2134c904 	addi	r4,r4,-11484
 8226620:	822675c0 	call	822675c <exit_hook>

   e = Netinit();    /* start net interface(s) */
 8226624:	82256d40 	call	82256d4 <Netinit>
 8226628:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 822662c:	e0bfff17 	ldw	r2,-4(fp)
 8226630:	10000326 	beq	r2,zero,8226640 <ip_startup+0x188>
   {
      return("unable to initialize net");
 8226634:	00820974 	movhi	r2,2085
 8226638:	10be9004 	addi	r2,r2,-1472
 822663c:	00004206 	br	8226748 <ip_startup+0x290>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 8226640:	823d5b40 	call	823d5b4 <etainit>
 8226644:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226648:	e0bfff17 	ldw	r2,-4(fp)
 822664c:	10000426 	beq	r2,zero,8226660 <ip_startup+0x1a8>
   {
      ip_exit();
 8226650:	82267cc0 	call	82267cc <ip_exit>
      return("unable to initialize arp");
 8226654:	00820974 	movhi	r2,2085
 8226658:	10be9704 	addi	r2,r2,-1444
 822665c:	00003a06 	br	8226748 <ip_startup+0x290>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 8226660:	823ec040 	call	823ec04 <ip_init>
 8226664:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226668:	e0bfff17 	ldw	r2,-4(fp)
 822666c:	10000426 	beq	r2,zero,8226680 <ip_startup+0x1c8>
   {
      ip_exit();
 8226670:	82267cc0 	call	82267cc <ip_exit>
      return("unable to initialize IP");
 8226674:	00820974 	movhi	r2,2085
 8226678:	10be9e04 	addi	r2,r2,-1416
 822667c:	00003206 	br	8226748 <ip_startup+0x290>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 8226680:	82269200 	call	8226920 <igmp_init>
 8226684:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226688:	e0bfff17 	ldw	r2,-4(fp)
 822668c:	10000326 	beq	r2,zero,822669c <ip_startup+0x1e4>
   {
      ip_exit();
 8226690:	82267cc0 	call	82267cc <ip_exit>
      return(ipmcfail_str);
 8226694:	d0a03017 	ldw	r2,-32576(gp)
 8226698:	00002b06 	br	8226748 <ip_startup+0x290>
   }

   for (i = 0; i < (int)ifNumber; i++)
 822669c:	e03ffe15 	stw	zero,-8(fp)
 82266a0:	00001b06 	br	8226710 <ip_startup+0x258>
   {
      if (nets[i]->n_mcastlist != NULL)
 82266a4:	008209b4 	movhi	r2,2086
 82266a8:	10b6b204 	addi	r2,r2,-9528
 82266ac:	e0fffe17 	ldw	r3,-8(fp)
 82266b0:	18c7883a 	add	r3,r3,r3
 82266b4:	18c7883a 	add	r3,r3,r3
 82266b8:	10c5883a 	add	r2,r2,r3
 82266bc:	10800017 	ldw	r2,0(r2)
 82266c0:	10802b17 	ldw	r2,172(r2)
 82266c4:	10000f26 	beq	r2,zero,8226704 <ip_startup+0x24c>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 82266c8:	008209b4 	movhi	r2,2086
 82266cc:	10b6b204 	addi	r2,r2,-9528
 82266d0:	e0fffe17 	ldw	r3,-8(fp)
 82266d4:	18c7883a 	add	r3,r3,r3
 82266d8:	18c7883a 	add	r3,r3,r3
 82266dc:	10c5883a 	add	r2,r2,r3
 82266e0:	10800017 	ldw	r2,0(r2)
 82266e4:	01800104 	movi	r6,4
 82266e8:	100b883a 	mov	r5,r2
 82266ec:	d1208804 	addi	r4,gp,-32224
 82266f0:	82435a40 	call	82435a4 <in_addmulti>
 82266f4:	1000031e 	bne	r2,zero,8226704 <ip_startup+0x24c>
      {
         ip_exit();
 82266f8:	82267cc0 	call	82267cc <ip_exit>
         return(ipmcfail_str);
 82266fc:	d0a03017 	ldw	r2,-32576(gp)
 8226700:	00001106 	br	8226748 <ip_startup+0x290>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 8226704:	e0bffe17 	ldw	r2,-8(fp)
 8226708:	10800044 	addi	r2,r2,1
 822670c:	e0bffe15 	stw	r2,-8(fp)
 8226710:	d0a08417 	ldw	r2,-32240(gp)
 8226714:	1007883a 	mov	r3,r2
 8226718:	e0bffe17 	ldw	r2,-8(fp)
 822671c:	10ffe116 	blt	r2,r3,82266a4 <ip_startup+0x1ec>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 8226720:	823ab140 	call	823ab14 <tcpinit>
 8226724:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226728:	e0bfff17 	ldw	r2,-4(fp)
 822672c:	10000426 	beq	r2,zero,8226740 <ip_startup+0x288>
   {
      ip_exit();
 8226730:	82267cc0 	call	82267cc <ip_exit>
      return("unable to initialize TCP");
 8226734:	00820974 	movhi	r2,2085
 8226738:	10bea404 	addi	r2,r2,-1392
 822673c:	00000206 	br	8226748 <ip_startup+0x290>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 8226740:	82439080 	call	8243908 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 8226744:	0005883a 	mov	r2,zero
}
 8226748:	e037883a 	mov	sp,fp
 822674c:	dfc00117 	ldw	ra,4(sp)
 8226750:	df000017 	ldw	fp,0(sp)
 8226754:	dec00204 	addi	sp,sp,8
 8226758:	f800283a 	ret

0822675c <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 822675c:	defffd04 	addi	sp,sp,-12
 8226760:	dfc00215 	stw	ra,8(sp)
 8226764:	df000115 	stw	fp,4(sp)
 8226768:	df000104 	addi	fp,sp,4
 822676c:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 8226770:	d0a08517 	ldw	r2,-32236(gp)
 8226774:	10800390 	cmplti	r2,r2,14
 8226778:	1000031e 	bne	r2,zero,8226788 <exit_hook+0x2c>
      panic("exit_hook");
 822677c:	01020974 	movhi	r4,2085
 8226780:	213eab04 	addi	r4,r4,-1364
 8226784:	822887c0 	call	822887c <panic>

   closers[++nclosers] = func;
 8226788:	d0a08517 	ldw	r2,-32236(gp)
 822678c:	10800044 	addi	r2,r2,1
 8226790:	d0a08515 	stw	r2,-32236(gp)
 8226794:	d0e08517 	ldw	r3,-32236(gp)
 8226798:	00820974 	movhi	r2,2085
 822679c:	10909104 	addi	r2,r2,16964
 82267a0:	18c7883a 	add	r3,r3,r3
 82267a4:	18c7883a 	add	r3,r3,r3
 82267a8:	10c5883a 	add	r2,r2,r3
 82267ac:	e0ffff17 	ldw	r3,-4(fp)
 82267b0:	10c00015 	stw	r3,0(r2)
}
 82267b4:	0001883a 	nop
 82267b8:	e037883a 	mov	sp,fp
 82267bc:	dfc00117 	ldw	ra,4(sp)
 82267c0:	df000017 	ldw	fp,0(sp)
 82267c4:	dec00204 	addi	sp,sp,8
 82267c8:	f800283a 	ret

082267cc <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 82267cc:	defffd04 	addi	sp,sp,-12
 82267d0:	dfc00215 	stw	ra,8(sp)
 82267d4:	df000115 	stw	fp,4(sp)
 82267d8:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 82267dc:	d0a08517 	ldw	r2,-32236(gp)
 82267e0:	e0bfff15 	stw	r2,-4(fp)
 82267e4:	00002506 	br	822687c <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 82267e8:	00820974 	movhi	r2,2085
 82267ec:	10909104 	addi	r2,r2,16964
 82267f0:	e0ffff17 	ldw	r3,-4(fp)
 82267f4:	18c7883a 	add	r3,r3,r3
 82267f8:	18c7883a 	add	r3,r3,r3
 82267fc:	10c5883a 	add	r2,r2,r3
 8226800:	10800017 	ldw	r2,0(r2)
 8226804:	100b883a 	mov	r5,r2
 8226808:	01020974 	movhi	r4,2085
 822680c:	213eae04 	addi	r4,r4,-1352
 8226810:	8202e9c0 	call	8202e9c <printf>
#endif
      if(closers[n])
 8226814:	00820974 	movhi	r2,2085
 8226818:	10909104 	addi	r2,r2,16964
 822681c:	e0ffff17 	ldw	r3,-4(fp)
 8226820:	18c7883a 	add	r3,r3,r3
 8226824:	18c7883a 	add	r3,r3,r3
 8226828:	10c5883a 	add	r2,r2,r3
 822682c:	10800017 	ldw	r2,0(r2)
 8226830:	10000f26 	beq	r2,zero,8226870 <ip_exit+0xa4>
      {
         (*closers[n])();
 8226834:	00820974 	movhi	r2,2085
 8226838:	10909104 	addi	r2,r2,16964
 822683c:	e0ffff17 	ldw	r3,-4(fp)
 8226840:	18c7883a 	add	r3,r3,r3
 8226844:	18c7883a 	add	r3,r3,r3
 8226848:	10c5883a 	add	r2,r2,r3
 822684c:	10800017 	ldw	r2,0(r2)
 8226850:	103ee83a 	callr	r2
         closers[n] = NULL;
 8226854:	00820974 	movhi	r2,2085
 8226858:	10909104 	addi	r2,r2,16964
 822685c:	e0ffff17 	ldw	r3,-4(fp)
 8226860:	18c7883a 	add	r3,r3,r3
 8226864:	18c7883a 	add	r3,r3,r3
 8226868:	10c5883a 	add	r2,r2,r3
 822686c:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 8226870:	e0bfff17 	ldw	r2,-4(fp)
 8226874:	10bfffc4 	addi	r2,r2,-1
 8226878:	e0bfff15 	stw	r2,-4(fp)
 822687c:	e0bfff17 	ldw	r2,-4(fp)
 8226880:	103fd91e 	bne	r2,zero,82267e8 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 8226884:	0001883a 	nop
 8226888:	e037883a 	mov	sp,fp
 822688c:	dfc00117 	ldw	ra,4(sp)
 8226890:	df000017 	ldw	fp,0(sp)
 8226894:	dec00204 	addi	sp,sp,8
 8226898:	f800283a 	ret

0822689c <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 822689c:	defffb04 	addi	sp,sp,-20
 82268a0:	dfc00415 	stw	ra,16(sp)
 82268a4:	df000315 	stw	fp,12(sp)
 82268a8:	df000304 	addi	fp,sp,12
 82268ac:	e13fff15 	stw	r4,-4(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 82268b0:	008209b4 	movhi	r2,2086
 82268b4:	10b8f304 	addi	r2,r2,-7220
 82268b8:	10800017 	ldw	r2,0(r2)
 82268bc:	e0bffe15 	stw	r2,-8(fp)
 82268c0:	e03ffd15 	stw	zero,-12(fp)
 82268c4:	00000b06 	br	82268f4 <if_netnumber+0x58>
   {
      if(ifp == nptr)
 82268c8:	e0fffe17 	ldw	r3,-8(fp)
 82268cc:	e0bfff17 	ldw	r2,-4(fp)
 82268d0:	1880021e 	bne	r3,r2,82268dc <if_netnumber+0x40>
        return (int)i;
 82268d4:	e0bffd17 	ldw	r2,-12(fp)
 82268d8:	00000c06 	br	822690c <if_netnumber+0x70>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 82268dc:	e0bffe17 	ldw	r2,-8(fp)
 82268e0:	10800017 	ldw	r2,0(r2)
 82268e4:	e0bffe15 	stw	r2,-8(fp)
 82268e8:	e0bffd17 	ldw	r2,-12(fp)
 82268ec:	10800044 	addi	r2,r2,1
 82268f0:	e0bffd15 	stw	r2,-12(fp)
 82268f4:	e0bffe17 	ldw	r2,-8(fp)
 82268f8:	103ff31e 	bne	r2,zero,82268c8 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 82268fc:	01020974 	movhi	r4,2085
 8226900:	213eb504 	addi	r4,r4,-1324
 8226904:	822887c0 	call	822887c <panic>
   return 0;
 8226908:	0005883a 	mov	r2,zero
}
 822690c:	e037883a 	mov	sp,fp
 8226910:	dfc00117 	ldw	ra,4(sp)
 8226914:	df000017 	ldw	fp,0(sp)
 8226918:	dec00204 	addi	sp,sp,8
 822691c:	f800283a 	ret

08226920 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 8226920:	defffe04 	addi	sp,sp,-8
 8226924:	df000115 	stw	fp,4(sp)
 8226928:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 822692c:	00804034 	movhi	r2,256
 8226930:	10803804 	addi	r2,r2,224
 8226934:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 8226938:	00808034 	movhi	r2,512
 822693c:	10803804 	addi	r2,r2,224
 8226940:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226944:	008209b4 	movhi	r2,2086
 8226948:	10b8f304 	addi	r2,r2,-7220
 822694c:	10800017 	ldw	r2,0(r2)
 8226950:	e0bfff15 	stw	r2,-4(fp)
 8226954:	00001006 	br	8226998 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 8226958:	e0bfff17 	ldw	r2,-4(fp)
 822695c:	10802f03 	ldbu	r2,188(r2)
 8226960:	10803fcc 	andi	r2,r2,255
 8226964:	10800058 	cmpnei	r2,r2,1
 8226968:	1000041e 	bne	r2,zero,822697c <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 822696c:	e0bfff17 	ldw	r2,-4(fp)
 8226970:	00c00044 	movi	r3,1
 8226974:	10c02d05 	stb	r3,180(r2)
 8226978:	00000406 	br	822698c <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 822697c:	e0bfff17 	ldw	r2,-4(fp)
 8226980:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 8226984:	e0bfff17 	ldw	r2,-4(fp)
 8226988:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 822698c:	e0bfff17 	ldw	r2,-4(fp)
 8226990:	10800017 	ldw	r2,0(r2)
 8226994:	e0bfff15 	stw	r2,-4(fp)
 8226998:	e0bfff17 	ldw	r2,-4(fp)
 822699c:	103fee1e 	bne	r2,zero,8226958 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 82269a0:	d0a0a817 	ldw	r2,-32096(gp)
 82269a4:	10800504 	addi	r2,r2,20
 82269a8:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 82269ac:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 82269b0:	0005883a 	mov	r2,zero
}
 82269b4:	e037883a 	mov	sp,fp
 82269b8:	df000017 	ldw	fp,0(sp)
 82269bc:	dec00104 	addi	sp,sp,4
 82269c0:	f800283a 	ret

082269c4 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 82269c4:	defffb04 	addi	sp,sp,-20
 82269c8:	dfc00415 	stw	ra,16(sp)
 82269cc:	df000315 	stw	fp,12(sp)
 82269d0:	df000304 	addi	fp,sp,12
 82269d4:	e13fff15 	stw	r4,-4(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 82269d8:	008209b4 	movhi	r2,2086
 82269dc:	10b6b604 	addi	r2,r2,-9512
 82269e0:	10800017 	ldw	r2,0(r2)
 82269e4:	10c00044 	addi	r3,r2,1
 82269e8:	008209b4 	movhi	r2,2086
 82269ec:	10b6b604 	addi	r2,r2,-9512
 82269f0:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 82269f4:	e13fff17 	ldw	r4,-4(fp)
 82269f8:	82271880 	call	8227188 <igmp_validate>
 82269fc:	e0bffd15 	stw	r2,-12(fp)
 8226a00:	e0bffd17 	ldw	r2,-12(fp)
 8226a04:	10001a1e 	bne	r2,zero,8226a70 <igmp_input+0xac>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 8226a08:	e0bfff17 	ldw	r2,-4(fp)
 8226a0c:	10800617 	ldw	r2,24(r2)
 8226a10:	10802f03 	ldbu	r2,188(r2)
 8226a14:	e0bffe05 	stb	r2,-8(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 8226a18:	e0bffe03 	ldbu	r2,-8(fp)
 8226a1c:	10c00060 	cmpeqi	r3,r2,1
 8226a20:	1800031e 	bne	r3,zero,8226a30 <igmp_input+0x6c>
 8226a24:	108000a0 	cmpeqi	r2,r2,2
 8226a28:	1000041e 	bne	r2,zero,8226a3c <igmp_input+0x78>
 8226a2c:	00000606 	br	8226a48 <igmp_input+0x84>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 8226a30:	e13fff17 	ldw	r4,-4(fp)
 8226a34:	82451600 	call	8245160 <igmpv1_input>
 8226a38:	00001506 	br	8226a90 <igmp_input+0xcc>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 8226a3c:	e13fff17 	ldw	r4,-4(fp)
 8226a40:	82454040 	call	8245404 <igmpv2_input>
 8226a44:	00001206 	br	8226a90 <igmp_input+0xcc>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 8226a48:	008209b4 	movhi	r2,2086
 8226a4c:	10b6b604 	addi	r2,r2,-9512
 8226a50:	10800d17 	ldw	r2,52(r2)
 8226a54:	10c00044 	addi	r3,r2,1
 8226a58:	008209b4 	movhi	r2,2086
 8226a5c:	10b6b604 	addi	r2,r2,-9512
 8226a60:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 8226a64:	00bfffc4 	movi	r2,-1
 8226a68:	e0bffd15 	stw	r2,-12(fp)
         break;
 8226a6c:	00000106 	br	8226a74 <igmp_input+0xb0>
     
   ++igmpstats.igmp_total_rcvd;
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226a70:	0001883a 	nop
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8226a74:	01000084 	movi	r4,2
 8226a78:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 8226a7c:	e13fff17 	ldw	r4,-4(fp)
 8226a80:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226a84:	01000084 	movi	r4,2
 8226a88:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      
   return rc;
 8226a8c:	e0bffd17 	ldw	r2,-12(fp)
}
 8226a90:	e037883a 	mov	sp,fp
 8226a94:	dfc00117 	ldw	ra,4(sp)
 8226a98:	df000017 	ldw	fp,0(sp)
 8226a9c:	dec00204 	addi	sp,sp,8
 8226aa0:	f800283a 	ret

08226aa4 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 8226aa4:	defffc04 	addi	sp,sp,-16
 8226aa8:	dfc00315 	stw	ra,12(sp)
 8226aac:	df000215 	stw	fp,8(sp)
 8226ab0:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 8226ab4:	0009883a 	mov	r4,zero
 8226ab8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 8226abc:	d0a08617 	ldw	r2,-32232(gp)
 8226ac0:	1000031e 	bne	r2,zero,8226ad0 <igmp_fasttimo+0x2c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 8226ac4:	0009883a 	mov	r4,zero
 8226ac8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return;
 8226acc:	00004d06 	br	8226c04 <igmp_fasttimo+0x160>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226ad0:	008209b4 	movhi	r2,2086
 8226ad4:	10b8f304 	addi	r2,r2,-7220
 8226ad8:	10800017 	ldw	r2,0(r2)
 8226adc:	e0bfff15 	stw	r2,-4(fp)
 8226ae0:	00004006 	br	8226be4 <igmp_fasttimo+0x140>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226ae4:	e0bfff17 	ldw	r2,-4(fp)
 8226ae8:	10802c17 	ldw	r2,176(r2)
 8226aec:	e0bffe15 	stw	r2,-8(fp)
 8226af0:	00003706 	br	8226bd0 <igmp_fasttimo+0x12c>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 8226af4:	e0bffe17 	ldw	r2,-8(fp)
 8226af8:	10800017 	ldw	r2,0(r2)
 8226afc:	10003026 	beq	r2,zero,8226bc0 <igmp_fasttimo+0x11c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 8226b00:	e0bffe17 	ldw	r2,-8(fp)
 8226b04:	10800317 	ldw	r2,12(r2)
 8226b08:	10002e26 	beq	r2,zero,8226bc4 <igmp_fasttimo+0x120>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 8226b0c:	e0bffe17 	ldw	r2,-8(fp)
 8226b10:	10800317 	ldw	r2,12(r2)
 8226b14:	10ffffc4 	addi	r3,r2,-1
 8226b18:	e0bffe17 	ldw	r2,-8(fp)
 8226b1c:	10c00315 	stw	r3,12(r2)
 8226b20:	e0bffe17 	ldw	r2,-8(fp)
 8226b24:	10800317 	ldw	r2,12(r2)
 8226b28:	1000261e 	bne	r2,zero,8226bc4 <igmp_fasttimo+0x120>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 8226b2c:	e0bfff17 	ldw	r2,-4(fp)
 8226b30:	10802d03 	ldbu	r2,180(r2)
 8226b34:	10803fcc 	andi	r2,r2,255
 8226b38:	10000426 	beq	r2,zero,8226b4c <igmp_fasttimo+0xa8>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8226b3c:	e17ffe17 	ldw	r5,-8(fp)
 8226b40:	01000484 	movi	r4,18
 8226b44:	8226c180 	call	8226c18 <igmp_send>
 8226b48:	00000306 	br	8226b58 <igmp_fasttimo+0xb4>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 8226b4c:	e17ffe17 	ldw	r5,-8(fp)
 8226b50:	01000584 	movi	r4,22
 8226b54:	8226c180 	call	8226c18 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8226b58:	e0bfff17 	ldw	r2,-4(fp)
 8226b5c:	10802f03 	ldbu	r2,188(r2)
 8226b60:	10803fcc 	andi	r2,r2,255
 8226b64:	10800098 	cmpnei	r2,r2,2
 8226b68:	1000111e 	bne	r2,zero,8226bb0 <igmp_fasttimo+0x10c>
            {
               inm->last2send_report = IGMP_TRUE;
 8226b6c:	e0bffe17 	ldw	r2,-8(fp)
 8226b70:	00c00044 	movi	r3,1
 8226b74:	10c00405 	stb	r3,16(r2)
               
               if (ifp->igmpv1_rtr_present)
 8226b78:	e0bfff17 	ldw	r2,-4(fp)
 8226b7c:	10802d03 	ldbu	r2,180(r2)
 8226b80:	10803fcc 	andi	r2,r2,255
 8226b84:	10000a26 	beq	r2,zero,8226bb0 <igmp_fasttimo+0x10c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 8226b88:	e0bfff17 	ldw	r2,-4(fp)
 8226b8c:	10c02e17 	ldw	r3,184(r2)
 8226b90:	00a71014 	movui	r2,40000
 8226b94:	1887883a 	add	r3,r3,r2
 8226b98:	d0a0a817 	ldw	r2,-32096(gp)
 8226b9c:	1880042e 	bgeu	r3,r2,8226bb0 <igmp_fasttimo+0x10c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 8226ba0:	e0bfff17 	ldw	r2,-4(fp)
 8226ba4:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 8226ba8:	e0bfff17 	ldw	r2,-4(fp)
 8226bac:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 8226bb0:	d0a08617 	ldw	r2,-32232(gp)
 8226bb4:	10bfffc4 	addi	r2,r2,-1
 8226bb8:	d0a08615 	stw	r2,-32232(gp)
 8226bbc:	00000106 	br	8226bc4 <igmp_fasttimo+0x120>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
               continue;
 8226bc0:	0001883a 	nop
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226bc4:	e0bffe17 	ldw	r2,-8(fp)
 8226bc8:	10800517 	ldw	r2,20(r2)
 8226bcc:	e0bffe15 	stw	r2,-8(fp)
 8226bd0:	e0bffe17 	ldw	r2,-8(fp)
 8226bd4:	103fc71e 	bne	r2,zero,8226af4 <igmp_fasttimo+0x50>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226bd8:	e0bfff17 	ldw	r2,-4(fp)
 8226bdc:	10800017 	ldw	r2,0(r2)
 8226be0:	e0bfff15 	stw	r2,-4(fp)
 8226be4:	e0bfff17 	ldw	r2,-4(fp)
 8226be8:	103fbe1e 	bne	r2,zero,8226ae4 <igmp_fasttimo+0x40>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226bec:	d0a0a817 	ldw	r2,-32096(gp)
 8226bf0:	10800504 	addi	r2,r2,20
 8226bf4:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8226bf8:	0009883a 	mov	r4,zero
 8226bfc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   
   return;
 8226c00:	0001883a 	nop
}
 8226c04:	e037883a 	mov	sp,fp
 8226c08:	dfc00117 	ldw	ra,4(sp)
 8226c0c:	df000017 	ldw	fp,0(sp)
 8226c10:	dec00204 	addi	sp,sp,8
 8226c14:	f800283a 	ret

08226c18 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 8226c18:	deffde04 	addi	sp,sp,-136
 8226c1c:	dfc02115 	stw	ra,132(sp)
 8226c20:	df002015 	stw	fp,128(sp)
 8226c24:	df002004 	addi	fp,sp,128
 8226c28:	2005883a 	mov	r2,r4
 8226c2c:	e17fff15 	stw	r5,-4(fp)
 8226c30:	e0bffe05 	stb	r2,-8(fp)
   struct igmp * igmp;
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 8226c34:	00800504 	movi	r2,20
 8226c38:	e0bffd05 	stb	r2,-12(fp)
 8226c3c:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 8226c40:	d0a08117 	ldw	r2,-32252(gp)
 8226c44:	10800704 	addi	r2,r2,28
 8226c48:	e0bfe205 	stb	r2,-120(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8226c4c:	e0bffe03 	ldbu	r2,-8(fp)
 8226c50:	108005e0 	cmpeqi	r2,r2,23
 8226c54:	1000031e 	bne	r2,zero,8226c64 <igmp_send+0x4c>
 8226c58:	e0bffe03 	ldbu	r2,-8(fp)
 8226c5c:	10800598 	cmpnei	r2,r2,22
 8226c60:	1000031e 	bne	r2,zero,8226c70 <igmp_send+0x58>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 8226c64:	e0bfe203 	ldbu	r2,-120(fp)
 8226c68:	10800104 	addi	r2,r2,4
 8226c6c:	e0bfe205 	stb	r2,-120(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8226c70:	01000084 	movi	r4,2
 8226c74:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 8226c78:	e0bfe203 	ldbu	r2,-120(fp)
 8226c7c:	1009883a 	mov	r4,r2
 8226c80:	822c6200 	call	822c620 <pk_alloc>
 8226c84:	e0bfe315 	stw	r2,-116(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8226c88:	01000084 	movi	r4,2
 8226c8c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 8226c90:	e0bfe317 	ldw	r2,-116(fp)
 8226c94:	1000081e 	bne	r2,zero,8226cb8 <igmp_send+0xa0>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 8226c98:	008209b4 	movhi	r2,2086
 8226c9c:	10b6b604 	addi	r2,r2,-9512
 8226ca0:	10800c17 	ldw	r2,48(r2)
 8226ca4:	10c00044 	addi	r3,r2,1
 8226ca8:	008209b4 	movhi	r2,2086
 8226cac:	10b6b604 	addi	r2,r2,-9512
 8226cb0:	10c00c15 	stw	r3,48(r2)
 8226cb4:	00007a06 	br	8226ea0 <igmp_send+0x288>
      return;
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 8226cb8:	e0bfe317 	ldw	r2,-116(fp)
 8226cbc:	10800317 	ldw	r2,12(r2)
 8226cc0:	e0bfe415 	stw	r2,-112(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 8226cc4:	e0bfff17 	ldw	r2,-4(fp)
 8226cc8:	10800117 	ldw	r2,4(r2)
 8226ccc:	10c00a17 	ldw	r3,40(r2)
 8226cd0:	e0bfe417 	ldw	r2,-112(fp)
 8226cd4:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 8226cd8:	e0bffe03 	ldbu	r2,-8(fp)
 8226cdc:	108005d8 	cmpnei	r2,r2,23
 8226ce0:	1000041e 	bne	r2,zero,8226cf4 <igmp_send+0xdc>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 8226ce4:	d0e08917 	ldw	r3,-32220(gp)
 8226ce8:	e0bfe417 	ldw	r2,-112(fp)
 8226cec:	10c00415 	stw	r3,16(r2)
 8226cf0:	00000406 	br	8226d04 <igmp_send+0xec>
   }
   else
      pip->ip_dest = inm->inm_addr;
 8226cf4:	e0bfff17 	ldw	r2,-4(fp)
 8226cf8:	10c00017 	ldw	r3,0(r2)
 8226cfc:	e0bfe417 	ldw	r2,-112(fp)
 8226d00:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 8226d04:	e0bfe417 	ldw	r2,-112(fp)
 8226d08:	10c00417 	ldw	r3,16(r2)
 8226d0c:	e0bfe317 	ldw	r2,-116(fp)
 8226d10:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 8226d14:	e0bfe317 	ldw	r2,-116(fp)
 8226d18:	10800317 	ldw	r2,12(r2)
 8226d1c:	10800504 	addi	r2,r2,20
 8226d20:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8226d24:	e0bffe03 	ldbu	r2,-8(fp)
 8226d28:	108005e0 	cmpeqi	r2,r2,23
 8226d2c:	1000031e 	bne	r2,zero,8226d3c <igmp_send+0x124>
 8226d30:	e0bffe03 	ldbu	r2,-8(fp)
 8226d34:	10800598 	cmpnei	r2,r2,22
 8226d38:	1000061e 	bne	r2,zero,8226d54 <igmp_send+0x13c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 8226d3c:	e0bfe017 	ldw	r2,-128(fp)
 8226d40:	10800104 	addi	r2,r2,4
 8226d44:	e0bfe015 	stw	r2,-128(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 8226d48:	e0bffd04 	addi	r2,fp,-12
 8226d4c:	e0bfe115 	stw	r2,-124(fp)
 8226d50:	00000306 	br	8226d60 <igmp_send+0x148>
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 8226d54:	e0bffd04 	addi	r2,fp,-12
 8226d58:	10800044 	addi	r2,r2,1
 8226d5c:	e0bfe115 	stw	r2,-124(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 8226d60:	e0bfe017 	ldw	r2,-128(fp)
 8226d64:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 8226d68:	e0bfe517 	ldw	r2,-108(fp)
 8226d6c:	e0fffe03 	ldbu	r3,-8(fp)
 8226d70:	10c00005 	stb	r3,0(r2)
   igmp->igmp_code = 0;
 8226d74:	e0bfe517 	ldw	r2,-108(fp)
 8226d78:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 8226d7c:	e0bfff17 	ldw	r2,-4(fp)
 8226d80:	10c00017 	ldw	r3,0(r2)
 8226d84:	e0bfe517 	ldw	r2,-108(fp)
 8226d88:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 8226d8c:	e0bfe517 	ldw	r2,-108(fp)
 8226d90:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 8226d94:	01400104 	movi	r5,4
 8226d98:	e13fe517 	ldw	r4,-108(fp)
 8226d9c:	82283e80 	call	82283e8 <cksum>
 8226da0:	0084303a 	nor	r2,zero,r2
 8226da4:	1007883a 	mov	r3,r2
 8226da8:	e0bfe517 	ldw	r2,-108(fp)
 8226dac:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 8226db0:	e0bfe704 	addi	r2,fp,-100
 8226db4:	e0bfe615 	stw	r2,-104(fp)
   MEMSET(imop, 0, sizeof(simo));
 8226db8:	01801604 	movi	r6,88
 8226dbc:	000b883a 	mov	r5,zero
 8226dc0:	e13fe617 	ldw	r4,-104(fp)
 8226dc4:	8202cb00 	call	8202cb0 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 8226dc8:	e0bfff17 	ldw	r2,-4(fp)
 8226dcc:	10c00117 	ldw	r3,4(r2)
 8226dd0:	e0bfe617 	ldw	r2,-104(fp)
 8226dd4:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 8226dd8:	e0bfe617 	ldw	r2,-104(fp)
 8226ddc:	00c00044 	movi	r3,1
 8226de0:	10c00105 	stb	r3,4(r2)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 8226de4:	e0bfe617 	ldw	r2,-104(fp)
 8226de8:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 8226dec:	e0bfe317 	ldw	r2,-116(fp)
 8226df0:	e0ffe017 	ldw	r3,-128(fp)
 8226df4:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 8226df8:	e0bfe317 	ldw	r2,-116(fp)
 8226dfc:	00c00204 	movi	r3,8
 8226e00:	10c00415 	stw	r3,16(r2)
   p->imo = imop;
 8226e04:	e0bfe317 	ldw	r2,-116(fp)
 8226e08:	e0ffe617 	ldw	r3,-104(fp)
 8226e0c:	10c00b15 	stw	r3,44(r2)
   
   ip_write2 (IGMP_PROT, p, optp);
 8226e10:	e1bfe117 	ldw	r6,-124(fp)
 8226e14:	e17fe317 	ldw	r5,-116(fp)
 8226e18:	01000084 	movi	r4,2
 8226e1c:	823f7c00 	call	823f7c0 <ip_write2>

   if (type == IGMPv2_LEAVE_GROUP)
 8226e20:	e0bffe03 	ldbu	r2,-8(fp)
 8226e24:	108005d8 	cmpnei	r2,r2,23
 8226e28:	1000081e 	bne	r2,zero,8226e4c <igmp_send+0x234>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 8226e2c:	008209b4 	movhi	r2,2086
 8226e30:	10b6b604 	addi	r2,r2,-9512
 8226e34:	10801717 	ldw	r2,92(r2)
 8226e38:	10c00044 	addi	r3,r2,1
 8226e3c:	008209b4 	movhi	r2,2086
 8226e40:	10b6b604 	addi	r2,r2,-9512
 8226e44:	10c01715 	stw	r3,92(r2)
 8226e48:	00001506 	br	8226ea0 <igmp_send+0x288>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 8226e4c:	e0bffe03 	ldbu	r2,-8(fp)
 8226e50:	10800598 	cmpnei	r2,r2,22
 8226e54:	1000081e 	bne	r2,zero,8226e78 <igmp_send+0x260>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 8226e58:	008209b4 	movhi	r2,2086
 8226e5c:	10b6b604 	addi	r2,r2,-9512
 8226e60:	10801817 	ldw	r2,96(r2)
 8226e64:	10c00044 	addi	r3,r2,1
 8226e68:	008209b4 	movhi	r2,2086
 8226e6c:	10b6b604 	addi	r2,r2,-9512
 8226e70:	10c01815 	stw	r3,96(r2)
 8226e74:	00000a06 	br	8226ea0 <igmp_send+0x288>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 8226e78:	e0bffe03 	ldbu	r2,-8(fp)
 8226e7c:	10800498 	cmpnei	r2,r2,18
 8226e80:	1000071e 	bne	r2,zero,8226ea0 <igmp_send+0x288>
      ++igmpstats.igmp_v1_reports_sent;
 8226e84:	008209b4 	movhi	r2,2086
 8226e88:	10b6b604 	addi	r2,r2,-9512
 8226e8c:	10801617 	ldw	r2,88(r2)
 8226e90:	10c00044 	addi	r3,r2,1
 8226e94:	008209b4 	movhi	r2,2086
 8226e98:	10b6b604 	addi	r2,r2,-9512
 8226e9c:	10c01615 	stw	r3,88(r2)
}
 8226ea0:	e037883a 	mov	sp,fp
 8226ea4:	dfc00117 	ldw	ra,4(sp)
 8226ea8:	df000017 	ldw	fp,0(sp)
 8226eac:	dec00204 	addi	sp,sp,8
 8226eb0:	f800283a 	ret

08226eb4 <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 8226eb4:	defffc04 	addi	sp,sp,-16
 8226eb8:	dfc00315 	stw	ra,12(sp)
 8226ebc:	df000215 	stw	fp,8(sp)
 8226ec0:	df000204 	addi	fp,sp,8
 8226ec4:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 8226ec8:	e0bfff17 	ldw	r2,-4(fp)
 8226ecc:	10800117 	ldw	r2,4(r2)
 8226ed0:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 8226ed4:	e0bfff17 	ldw	r2,-4(fp)
 8226ed8:	10c00017 	ldw	r3,0(r2)
 8226edc:	d0a08817 	ldw	r2,-32224(gp)
 8226ee0:	1880031e 	bne	r3,r2,8226ef0 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 8226ee4:	e0bfff17 	ldw	r2,-4(fp)
 8226ee8:	10000315 	stw	zero,12(r2)
      }

      ++igmp_timers_are_running;
   }
   
   return;
 8226eec:	00008106 	br	82270f4 <igmp_joingroup+0x240>
      inm->inm_timer = 0;
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 8226ef0:	e0bffe17 	ldw	r2,-8(fp)
 8226ef4:	10802d03 	ldbu	r2,180(r2)
 8226ef8:	10803fcc 	andi	r2,r2,255
 8226efc:	10003926 	beq	r2,zero,8226fe4 <igmp_joingroup+0x130>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8226f00:	e17fff17 	ldw	r5,-4(fp)
 8226f04:	01000484 	movi	r4,18
 8226f08:	8226c180 	call	8226c18 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8226f0c:	008209b4 	movhi	r2,2086
 8226f10:	10b8f804 	addi	r2,r2,-7200
 8226f14:	10c00217 	ldw	r3,8(r2)
 8226f18:	008209b4 	movhi	r2,2086
 8226f1c:	10b6b204 	addi	r2,r2,-9528
 8226f20:	10800017 	ldw	r2,0(r2)
 8226f24:	10800a17 	ldw	r2,40(r2)
 8226f28:	1008d63a 	srli	r4,r2,24
 8226f2c:	008209b4 	movhi	r2,2086
 8226f30:	10b6b204 	addi	r2,r2,-9528
 8226f34:	10800017 	ldw	r2,0(r2)
 8226f38:	10800a17 	ldw	r2,40(r2)
 8226f3c:	1004d23a 	srli	r2,r2,8
 8226f40:	10bfc00c 	andi	r2,r2,65280
 8226f44:	2088b03a 	or	r4,r4,r2
 8226f48:	008209b4 	movhi	r2,2086
 8226f4c:	10b6b204 	addi	r2,r2,-9528
 8226f50:	10800017 	ldw	r2,0(r2)
 8226f54:	10800a17 	ldw	r2,40(r2)
 8226f58:	10bfc00c 	andi	r2,r2,65280
 8226f5c:	1004923a 	slli	r2,r2,8
 8226f60:	2088b03a 	or	r4,r4,r2
 8226f64:	008209b4 	movhi	r2,2086
 8226f68:	10b6b204 	addi	r2,r2,-9528
 8226f6c:	10800017 	ldw	r2,0(r2)
 8226f70:	10800a17 	ldw	r2,40(r2)
 8226f74:	1004963a 	slli	r2,r2,24
 8226f78:	2084b03a 	or	r2,r4,r2
 8226f7c:	1887883a 	add	r3,r3,r2
 8226f80:	e0bfff17 	ldw	r2,-4(fp)
 8226f84:	10800017 	ldw	r2,0(r2)
 8226f88:	1008d63a 	srli	r4,r2,24
 8226f8c:	e0bfff17 	ldw	r2,-4(fp)
 8226f90:	10800017 	ldw	r2,0(r2)
 8226f94:	1004d23a 	srli	r2,r2,8
 8226f98:	10bfc00c 	andi	r2,r2,65280
 8226f9c:	2088b03a 	or	r4,r4,r2
 8226fa0:	e0bfff17 	ldw	r2,-4(fp)
 8226fa4:	10800017 	ldw	r2,0(r2)
 8226fa8:	10bfc00c 	andi	r2,r2,65280
 8226fac:	1004923a 	slli	r2,r2,8
 8226fb0:	2088b03a 	or	r4,r4,r2
 8226fb4:	e0bfff17 	ldw	r2,-4(fp)
 8226fb8:	10800017 	ldw	r2,0(r2)
 8226fbc:	1004963a 	slli	r2,r2,24
 8226fc0:	2084b03a 	or	r2,r4,r2
 8226fc4:	1885883a 	add	r2,r3,r2
 8226fc8:	01400c84 	movi	r5,50
 8226fcc:	1009883a 	mov	r4,r2
 8226fd0:	82027700 	call	8202770 <__umodsi3>
 8226fd4:	10c00044 	addi	r3,r2,1
 8226fd8:	e0bfff17 	ldw	r2,-4(fp)
 8226fdc:	10c00315 	stw	r3,12(r2)
 8226fe0:	00003806 	br	82270c4 <igmp_joingroup+0x210>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 8226fe4:	e17fff17 	ldw	r5,-4(fp)
 8226fe8:	01000584 	movi	r4,22
 8226fec:	8226c180 	call	8226c18 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 8226ff0:	008209b4 	movhi	r2,2086
 8226ff4:	10b8f804 	addi	r2,r2,-7200
 8226ff8:	10c00217 	ldw	r3,8(r2)
 8226ffc:	008209b4 	movhi	r2,2086
 8227000:	10b6b204 	addi	r2,r2,-9528
 8227004:	10800017 	ldw	r2,0(r2)
 8227008:	10800a17 	ldw	r2,40(r2)
 822700c:	1008d63a 	srli	r4,r2,24
 8227010:	008209b4 	movhi	r2,2086
 8227014:	10b6b204 	addi	r2,r2,-9528
 8227018:	10800017 	ldw	r2,0(r2)
 822701c:	10800a17 	ldw	r2,40(r2)
 8227020:	1004d23a 	srli	r2,r2,8
 8227024:	10bfc00c 	andi	r2,r2,65280
 8227028:	2088b03a 	or	r4,r4,r2
 822702c:	008209b4 	movhi	r2,2086
 8227030:	10b6b204 	addi	r2,r2,-9528
 8227034:	10800017 	ldw	r2,0(r2)
 8227038:	10800a17 	ldw	r2,40(r2)
 822703c:	10bfc00c 	andi	r2,r2,65280
 8227040:	1004923a 	slli	r2,r2,8
 8227044:	2088b03a 	or	r4,r4,r2
 8227048:	008209b4 	movhi	r2,2086
 822704c:	10b6b204 	addi	r2,r2,-9528
 8227050:	10800017 	ldw	r2,0(r2)
 8227054:	10800a17 	ldw	r2,40(r2)
 8227058:	1004963a 	slli	r2,r2,24
 822705c:	2084b03a 	or	r2,r4,r2
 8227060:	1887883a 	add	r3,r3,r2
 8227064:	e0bfff17 	ldw	r2,-4(fp)
 8227068:	10800017 	ldw	r2,0(r2)
 822706c:	1008d63a 	srli	r4,r2,24
 8227070:	e0bfff17 	ldw	r2,-4(fp)
 8227074:	10800017 	ldw	r2,0(r2)
 8227078:	1004d23a 	srli	r2,r2,8
 822707c:	10bfc00c 	andi	r2,r2,65280
 8227080:	2088b03a 	or	r4,r4,r2
 8227084:	e0bfff17 	ldw	r2,-4(fp)
 8227088:	10800017 	ldw	r2,0(r2)
 822708c:	10bfc00c 	andi	r2,r2,65280
 8227090:	1004923a 	slli	r2,r2,8
 8227094:	2088b03a 	or	r4,r4,r2
 8227098:	e0bfff17 	ldw	r2,-4(fp)
 822709c:	10800017 	ldw	r2,0(r2)
 82270a0:	1004963a 	slli	r2,r2,24
 82270a4:	2084b03a 	or	r2,r4,r2
 82270a8:	1885883a 	add	r2,r3,r2
 82270ac:	01400c84 	movi	r5,50
 82270b0:	1009883a 	mov	r4,r2
 82270b4:	82027700 	call	8202770 <__umodsi3>
 82270b8:	10c00044 	addi	r3,r2,1
 82270bc:	e0bfff17 	ldw	r2,-4(fp)
 82270c0:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 82270c4:	e0bffe17 	ldw	r2,-8(fp)
 82270c8:	10802f03 	ldbu	r2,188(r2)
 82270cc:	10803fcc 	andi	r2,r2,255
 82270d0:	10800098 	cmpnei	r2,r2,2
 82270d4:	1000031e 	bne	r2,zero,82270e4 <igmp_joingroup+0x230>
      {
         inm->last2send_report = IGMP_TRUE;
 82270d8:	e0bfff17 	ldw	r2,-4(fp)
 82270dc:	00c00044 	movi	r3,1
 82270e0:	10c00405 	stb	r3,16(r2)
      }

      ++igmp_timers_are_running;
 82270e4:	d0a08617 	ldw	r2,-32232(gp)
 82270e8:	10800044 	addi	r2,r2,1
 82270ec:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
 82270f0:	0001883a 	nop
}     
 82270f4:	e037883a 	mov	sp,fp
 82270f8:	dfc00117 	ldw	ra,4(sp)
 82270fc:	df000017 	ldw	fp,0(sp)
 8227100:	dec00204 	addi	sp,sp,8
 8227104:	f800283a 	ret

08227108 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 8227108:	defffc04 	addi	sp,sp,-16
 822710c:	dfc00315 	stw	ra,12(sp)
 8227110:	df000215 	stw	fp,8(sp)
 8227114:	df000204 	addi	fp,sp,8
 8227118:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 822711c:	e0bfff17 	ldw	r2,-4(fp)
 8227120:	10800117 	ldw	r2,4(r2)
 8227124:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 8227128:	e0bffe17 	ldw	r2,-8(fp)
 822712c:	10802f03 	ldbu	r2,188(r2)
 8227130:	10803fcc 	andi	r2,r2,255
 8227134:	10800098 	cmpnei	r2,r2,2
 8227138:	10000d1e 	bne	r2,zero,8227170 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
 822713c:	e0bffe17 	ldw	r2,-8(fp)
 8227140:	10802d03 	ldbu	r2,180(r2)
{
   NET ifp;

   ifp = inm->inm_netp;

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 8227144:	10803fcc 	andi	r2,r2,255
 8227148:	1000091e 	bne	r2,zero,8227170 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 822714c:	e0bfff17 	ldw	r2,-4(fp)
 8227150:	10800403 	ldbu	r2,16(r2)
 8227154:	10803fcc 	andi	r2,r2,255
 8227158:	10800058 	cmpnei	r2,r2,1
 822715c:	1000041e 	bne	r2,zero,8227170 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 8227160:	e17fff17 	ldw	r5,-4(fp)
 8227164:	010005c4 	movi	r4,23
 8227168:	8226c180 	call	8226c18 <igmp_send>
   }
   
   return;
 822716c:	0001883a 	nop
 8227170:	0001883a 	nop
}
 8227174:	e037883a 	mov	sp,fp
 8227178:	dfc00117 	ldw	ra,4(sp)
 822717c:	df000017 	ldw	fp,0(sp)
 8227180:	dec00204 	addi	sp,sp,8
 8227184:	f800283a 	ret

08227188 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 8227188:	defff604 	addi	sp,sp,-40
 822718c:	dfc00915 	stw	ra,36(sp)
 8227190:	df000815 	stw	fp,32(sp)
 8227194:	df000804 	addi	fp,sp,32
 8227198:	e13fff15 	stw	r4,-4(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 822719c:	e0bfff17 	ldw	r2,-4(fp)
 82271a0:	10800317 	ldw	r2,12(r2)
 82271a4:	e0bff815 	stw	r2,-32(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 82271a8:	e0bfff17 	ldw	r2,-4(fp)
 82271ac:	10c00417 	ldw	r3,16(r2)
 82271b0:	e0bff817 	ldw	r2,-32(fp)
 82271b4:	10800003 	ldbu	r2,0(r2)
 82271b8:	10803fcc 	andi	r2,r2,255
 82271bc:	108003cc 	andi	r2,r2,15
 82271c0:	1085883a 	add	r2,r2,r2
 82271c4:	1085883a 	add	r2,r2,r2
 82271c8:	1885c83a 	sub	r2,r3,r2
 82271cc:	e0bff915 	stw	r2,-28(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 82271d0:	e0bff917 	ldw	r2,-28(fp)
 82271d4:	10800220 	cmpeqi	r2,r2,8
 82271d8:	1000091e 	bne	r2,zero,8227200 <igmp_validate+0x78>
   {
      ++igmpstats.igmp_badlen_rcvd;
 82271dc:	008209b4 	movhi	r2,2086
 82271e0:	10b6b604 	addi	r2,r2,-9512
 82271e4:	10800a17 	ldw	r2,40(r2)
 82271e8:	10c00044 	addi	r3,r2,1
 82271ec:	008209b4 	movhi	r2,2086
 82271f0:	10b6b604 	addi	r2,r2,-9512
 82271f4:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 82271f8:	00bff804 	movi	r2,-32
 82271fc:	0000a306 	br	822748c <igmp_validate+0x304>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 8227200:	e0bff817 	ldw	r2,-32(fp)
 8227204:	10800003 	ldbu	r2,0(r2)
 8227208:	10803fcc 	andi	r2,r2,255
 822720c:	108003cc 	andi	r2,r2,15
 8227210:	1085883a 	add	r2,r2,r2
 8227214:	1085883a 	add	r2,r2,r2
 8227218:	1007883a 	mov	r3,r2
 822721c:	e0bff817 	ldw	r2,-32(fp)
 8227220:	10c5883a 	add	r2,r2,r3
 8227224:	e0bffa15 	stw	r2,-24(fp)
   osum = igmp->igmp_cksum;
 8227228:	e0bffa17 	ldw	r2,-24(fp)
 822722c:	1080008b 	ldhu	r2,2(r2)
 8227230:	e0bffb0d 	sth	r2,-20(fp)
   igmp->igmp_cksum = 0;
 8227234:	e0bffa17 	ldw	r2,-24(fp)
 8227238:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 822723c:	e0bff917 	ldw	r2,-28(fp)
 8227240:	1005d07a 	srai	r2,r2,1
 8227244:	100b883a 	mov	r5,r2
 8227248:	e13ffa17 	ldw	r4,-24(fp)
 822724c:	82283e80 	call	82283e8 <cksum>
 8227250:	0084303a 	nor	r2,zero,r2
 8227254:	e0bffb8d 	sth	r2,-18(fp)
   if (xsum != osum)
 8227258:	e0fffb8b 	ldhu	r3,-18(fp)
 822725c:	e0bffb0b 	ldhu	r2,-20(fp)
 8227260:	18800c26 	beq	r3,r2,8227294 <igmp_validate+0x10c>
   {
      igmp->igmp_cksum = osum;
 8227264:	e0bffa17 	ldw	r2,-24(fp)
 8227268:	e0fffb0b 	ldhu	r3,-20(fp)
 822726c:	10c0008d 	sth	r3,2(r2)
      ++igmpstats.igmp_badsum_rcvd;
 8227270:	008209b4 	movhi	r2,2086
 8227274:	10b6b604 	addi	r2,r2,-9512
 8227278:	10800b17 	ldw	r2,44(r2)
 822727c:	10c00044 	addi	r3,r2,1
 8227280:	008209b4 	movhi	r2,2086
 8227284:	10b6b604 	addi	r2,r2,-9512
 8227288:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 822728c:	00bff804 	movi	r2,-32
 8227290:	00007e06 	br	822748c <igmp_validate+0x304>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 8227294:	e0bffa17 	ldw	r2,-24(fp)
 8227298:	10800003 	ldbu	r2,0(r2)
 822729c:	e0bffc05 	stb	r2,-16(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 82272a0:	e0bffa17 	ldw	r2,-24(fp)
 82272a4:	10800117 	ldw	r2,4(r2)
 82272a8:	1006d63a 	srli	r3,r2,24
 82272ac:	e0bffa17 	ldw	r2,-24(fp)
 82272b0:	10800117 	ldw	r2,4(r2)
 82272b4:	1004d23a 	srli	r2,r2,8
 82272b8:	10bfc00c 	andi	r2,r2,65280
 82272bc:	1886b03a 	or	r3,r3,r2
 82272c0:	e0bffa17 	ldw	r2,-24(fp)
 82272c4:	10800117 	ldw	r2,4(r2)
 82272c8:	10bfc00c 	andi	r2,r2,65280
 82272cc:	1004923a 	slli	r2,r2,8
 82272d0:	1886b03a 	or	r3,r3,r2
 82272d4:	e0bffa17 	ldw	r2,-24(fp)
 82272d8:	10800117 	ldw	r2,4(r2)
 82272dc:	1004963a 	slli	r2,r2,24
 82272e0:	1884b03a 	or	r2,r3,r2
 82272e4:	e0bffd15 	stw	r2,-12(fp)
   resp_time = igmp->igmp_code;
 82272e8:	e0bffa17 	ldw	r2,-24(fp)
 82272ec:	10800043 	ldbu	r2,1(r2)
 82272f0:	e0bffe05 	stb	r2,-8(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 82272f4:	e0bffc03 	ldbu	r2,-16(fp)
 82272f8:	10800458 	cmpnei	r2,r2,17
 82272fc:	1000301e 	bne	r2,zero,82273c0 <igmp_validate+0x238>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 8227300:	e0bffe03 	ldbu	r2,-8(fp)
 8227304:	10000426 	beq	r2,zero,8227318 <igmp_validate+0x190>
 8227308:	e0bffe03 	ldbu	r2,-8(fp)
 822730c:	10000f26 	beq	r2,zero,822734c <igmp_validate+0x1c4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
 8227310:	e0bffd17 	ldw	r2,-12(fp)
 8227314:	10000d1e 	bne	r2,zero,822734c <igmp_validate+0x1c4>
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 8227318:	e0bff817 	ldw	r2,-32(fp)
 822731c:	10c00417 	ldw	r3,16(r2)
 8227320:	d0a08817 	ldw	r2,-32224(gp)
 8227324:	18800926 	beq	r3,r2,822734c <igmp_validate+0x1c4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 8227328:	008209b4 	movhi	r2,2086
 822732c:	10b6b604 	addi	r2,r2,-9512
 8227330:	10800e17 	ldw	r2,56(r2)
 8227334:	10c00044 	addi	r3,r2,1
 8227338:	008209b4 	movhi	r2,2086
 822733c:	10b6b604 	addi	r2,r2,-9512
 8227340:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 8227344:	00bff804 	movi	r2,-32
 8227348:	00005006 	br	822748c <igmp_validate+0x304>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 822734c:	e0bffe03 	ldbu	r2,-8(fp)
 8227350:	10001b26 	beq	r2,zero,82273c0 <igmp_validate+0x238>
 8227354:	e0bffd17 	ldw	r2,-12(fp)
 8227358:	10001926 	beq	r2,zero,82273c0 <igmp_validate+0x238>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 822735c:	e0bfff17 	ldw	r2,-4(fp)
 8227360:	10800617 	ldw	r2,24(r2)
 8227364:	10802f03 	ldbu	r2,188(r2)
 8227368:	10803fcc 	andi	r2,r2,255
 822736c:	10800058 	cmpnei	r2,r2,1
 8227370:	1000021e 	bne	r2,zero,822737c <igmp_validate+0x1f4>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 8227374:	00bff804 	movi	r2,-32
 8227378:	00004406 	br	822748c <igmp_validate+0x304>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 822737c:	e0bffd17 	ldw	r2,-12(fp)
 8227380:	10fc002c 	andhi	r3,r2,61440
 8227384:	00b80034 	movhi	r2,57344
 8227388:	1880041e 	bne	r3,r2,822739c <igmp_validate+0x214>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
 822738c:	e0bffa17 	ldw	r2,-24(fp)
 8227390:	10c00117 	ldw	r3,4(r2)
 8227394:	d0a08817 	ldw	r2,-32224(gp)
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 8227398:	1880091e 	bne	r3,r2,82273c0 <igmp_validate+0x238>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 822739c:	008209b4 	movhi	r2,2086
 82273a0:	10b6b604 	addi	r2,r2,-9512
 82273a4:	10801117 	ldw	r2,68(r2)
 82273a8:	10c00044 	addi	r3,r2,1
 82273ac:	008209b4 	movhi	r2,2086
 82273b0:	10b6b604 	addi	r2,r2,-9512
 82273b4:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 82273b8:	00bff804 	movi	r2,-32
 82273bc:	00003306 	br	822748c <igmp_validate+0x304>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 82273c0:	e0bffc03 	ldbu	r2,-16(fp)
 82273c4:	108004a0 	cmpeqi	r2,r2,18
 82273c8:	1000031e 	bne	r2,zero,82273d8 <igmp_validate+0x250>
 82273cc:	e0bffc03 	ldbu	r2,-16(fp)
 82273d0:	10800598 	cmpnei	r2,r2,22
 82273d4:	1000121e 	bne	r2,zero,8227420 <igmp_validate+0x298>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82273d8:	e0bffa17 	ldw	r2,-24(fp)
 82273dc:	10c00117 	ldw	r3,4(r2)
 82273e0:	e0bff817 	ldw	r2,-32(fp)
 82273e4:	10800417 	ldw	r2,16(r2)
 82273e8:	1880041e 	bne	r3,r2,82273fc <igmp_validate+0x274>
          (!IN_MULTICAST(mcgrp_addr)))
 82273ec:	e0bffd17 	ldw	r2,-12(fp)
 82273f0:	10fc002c 	andhi	r3,r2,61440
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82273f4:	00b80034 	movhi	r2,57344
 82273f8:	18800926 	beq	r3,r2,8227420 <igmp_validate+0x298>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 82273fc:	008209b4 	movhi	r2,2086
 8227400:	10b6b604 	addi	r2,r2,-9512
 8227404:	10800f17 	ldw	r2,60(r2)
 8227408:	10c00044 	addi	r3,r2,1
 822740c:	008209b4 	movhi	r2,2086
 8227410:	10b6b604 	addi	r2,r2,-9512
 8227414:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 8227418:	00bff804 	movi	r2,-32
 822741c:	00001b06 	br	822748c <igmp_validate+0x304>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8227420:	e0bffc03 	ldbu	r2,-16(fp)
 8227424:	108005e0 	cmpeqi	r2,r2,23
 8227428:	10000a1e 	bne	r2,zero,8227454 <igmp_validate+0x2cc>
 822742c:	e0bffc03 	ldbu	r2,-16(fp)
 8227430:	108005a0 	cmpeqi	r2,r2,22
 8227434:	1000071e 	bne	r2,zero,8227454 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
 8227438:	e0bffc03 	ldbu	r2,-16(fp)
 822743c:	10800458 	cmpnei	r2,r2,17
 8227440:	1000111e 	bne	r2,zero,8227488 <igmp_validate+0x300>
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
 8227444:	e0bffa17 	ldw	r2,-24(fp)
 8227448:	10800043 	ldbu	r2,1(r2)
 822744c:	10803fcc 	andi	r2,r2,255
 8227450:	10000d26 	beq	r2,zero,8227488 <igmp_validate+0x300>
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 8227454:	e13ff817 	ldw	r4,-32(fp)
 8227458:	824598c0 	call	824598c <igmpv2_chk4_rtr_alert_opt>
 822745c:	10803fcc 	andi	r2,r2,255
 8227460:	1000091e 	bne	r2,zero,8227488 <igmp_validate+0x300>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 8227464:	008209b4 	movhi	r2,2086
 8227468:	10b6b604 	addi	r2,r2,-9512
 822746c:	10801417 	ldw	r2,80(r2)
 8227470:	10c00044 	addi	r3,r2,1
 8227474:	008209b4 	movhi	r2,2086
 8227478:	10b6b604 	addi	r2,r2,-9512
 822747c:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 8227480:	00bff804 	movi	r2,-32
 8227484:	00000106 	br	822748c <igmp_validate+0x304>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 8227488:	0005883a 	mov	r2,zero
}
 822748c:	e037883a 	mov	sp,fp
 8227490:	dfc00117 	ldw	ra,4(sp)
 8227494:	df000017 	ldw	fp,0(sp)
 8227498:	dec00204 	addi	sp,sp,8
 822749c:	f800283a 	ret

082274a0 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 82274a0:	defffa04 	addi	sp,sp,-24
 82274a4:	dfc00515 	stw	ra,20(sp)
 82274a8:	df000415 	stw	fp,16(sp)
 82274ac:	df000404 	addi	fp,sp,16
 82274b0:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82274b4:	008209b4 	movhi	r2,2086
 82274b8:	10b8f304 	addi	r2,r2,-7220
 82274bc:	10800017 	ldw	r2,0(r2)
 82274c0:	e0bffe15 	stw	r2,-8(fp)
 82274c4:	00003b06 	br	82275b4 <igmp_print_stats+0x114>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
                 ifp->name, 
 82274c8:	e0bffe17 	ldw	r2,-8(fp)
 82274cc:	10c00104 	addi	r3,r2,4
                 ifp->igmp_oper_mode, 
 82274d0:	e0bffe17 	ldw	r2,-8(fp)
 82274d4:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82274d8:	11003fcc 	andi	r4,r2,255
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
 82274dc:	e0bffe17 	ldw	r2,-8(fp)
 82274e0:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82274e4:	10803fcc 	andi	r2,r2,255
 82274e8:	10800058 	cmpnei	r2,r2,1
 82274ec:	1000031e 	bne	r2,zero,82274fc <igmp_print_stats+0x5c>
 82274f0:	00820974 	movhi	r2,2085
 82274f4:	10beb804 	addi	r2,r2,-1312
 82274f8:	00000206 	br	8227504 <igmp_print_stats+0x64>
 82274fc:	00820974 	movhi	r2,2085
 8227500:	10beb904 	addi	r2,r2,-1308
 8227504:	d8800015 	stw	r2,0(sp)
 8227508:	200f883a 	mov	r7,r4
 822750c:	180d883a 	mov	r6,r3
 8227510:	01420974 	movhi	r5,2085
 8227514:	297eba04 	addi	r5,r5,-1304
 8227518:	e13fff17 	ldw	r4,-4(fp)
 822751c:	8228a940 	call	8228a94 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8227520:	e0bffe17 	ldw	r2,-8(fp)
 8227524:	10802f03 	ldbu	r2,188(r2)
 8227528:	10803fcc 	andi	r2,r2,255
 822752c:	10800098 	cmpnei	r2,r2,2
 8227530:	1000191e 	bne	r2,zero,8227598 <igmp_print_stats+0xf8>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
                    ifp->igmpv1_rtr_present,
 8227534:	e0bffe17 	ldw	r2,-8(fp)
 8227538:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 822753c:	11403fcc 	andi	r5,r2,255
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
 8227540:	e0bffe17 	ldw	r2,-8(fp)
 8227544:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227548:	10803fcc 	andi	r2,r2,255
 822754c:	10800058 	cmpnei	r2,r2,1
 8227550:	1000031e 	bne	r2,zero,8227560 <igmp_print_stats+0xc0>
 8227554:	00820974 	movhi	r2,2085
 8227558:	10bebf04 	addi	r2,r2,-1284
 822755c:	00000206 	br	8227568 <igmp_print_stats+0xc8>
 8227560:	00820974 	movhi	r2,2085
 8227564:	10bec104 	addi	r2,r2,-1276
 8227568:	e0fffe17 	ldw	r3,-8(fp)
 822756c:	18c02e17 	ldw	r3,184(r3)
 8227570:	d120a817 	ldw	r4,-32096(gp)
 8227574:	d9000115 	stw	r4,4(sp)
 8227578:	d8c00015 	stw	r3,0(sp)
 822757c:	100f883a 	mov	r7,r2
 8227580:	280d883a 	mov	r6,r5
 8227584:	01420974 	movhi	r5,2085
 8227588:	297ec304 	addi	r5,r5,-1268
 822758c:	e13fff17 	ldw	r4,-4(fp)
 8227590:	8228a940 	call	8228a94 <ns_printf>
 8227594:	00000406 	br	82275a8 <igmp_print_stats+0x108>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 8227598:	01420974 	movhi	r5,2085
 822759c:	297ece04 	addi	r5,r5,-1224
 82275a0:	e13fff17 	ldw	r4,-4(fp)
 82275a4:	8228a940 	call	8228a94 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82275a8:	e0bffe17 	ldw	r2,-8(fp)
 82275ac:	10800017 	ldw	r2,0(r2)
 82275b0:	e0bffe15 	stw	r2,-8(fp)
 82275b4:	e0bffe17 	ldw	r2,-8(fp)
 82275b8:	103fc31e 	bne	r2,zero,82274c8 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 82275bc:	008209b4 	movhi	r2,2086
 82275c0:	10b6b604 	addi	r2,r2,-9512
 82275c4:	10800017 	ldw	r2,0(r2)
 82275c8:	d0e08617 	ldw	r3,-32232(gp)
 82275cc:	180f883a 	mov	r7,r3
 82275d0:	100d883a 	mov	r6,r2
 82275d4:	01420974 	movhi	r5,2085
 82275d8:	297ecf04 	addi	r5,r5,-1220
 82275dc:	e13fff17 	ldw	r4,-4(fp)
 82275e0:	8228a940 	call	8228a94 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 82275e4:	008209b4 	movhi	r2,2086
 82275e8:	10b6b604 	addi	r2,r2,-9512
 82275ec:	10800117 	ldw	r2,4(r2)
 82275f0:	100d883a 	mov	r6,r2
 82275f4:	01420974 	movhi	r5,2085
 82275f8:	297edc04 	addi	r5,r5,-1168
 82275fc:	e13fff17 	ldw	r4,-4(fp)
 8227600:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 8227604:	008209b4 	movhi	r2,2086
 8227608:	10b6b604 	addi	r2,r2,-9512
 822760c:	10800217 	ldw	r2,8(r2)
 8227610:	100d883a 	mov	r6,r2
 8227614:	01420974 	movhi	r5,2085
 8227618:	297eed04 	addi	r5,r5,-1100
 822761c:	e13fff17 	ldw	r4,-4(fp)
 8227620:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 8227624:	008209b4 	movhi	r2,2086
 8227628:	10b6b604 	addi	r2,r2,-9512
 822762c:	10800317 	ldw	r2,12(r2)
 8227630:	100d883a 	mov	r6,r2
 8227634:	01420974 	movhi	r5,2085
 8227638:	297ef904 	addi	r5,r5,-1052
 822763c:	e13fff17 	ldw	r4,-4(fp)
 8227640:	8228a940 	call	8228a94 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 8227644:	008209b4 	movhi	r2,2086
 8227648:	10b6b604 	addi	r2,r2,-9512
 822764c:	10800417 	ldw	r2,16(r2)
 8227650:	100d883a 	mov	r6,r2
 8227654:	01420974 	movhi	r5,2085
 8227658:	297f0c04 	addi	r5,r5,-976
 822765c:	e13fff17 	ldw	r4,-4(fp)
 8227660:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 8227664:	008209b4 	movhi	r2,2086
 8227668:	10b6b604 	addi	r2,r2,-9512
 822766c:	10c00517 	ldw	r3,20(r2)
 8227670:	008209b4 	movhi	r2,2086
 8227674:	10b6b604 	addi	r2,r2,-9512
 8227678:	10800617 	ldw	r2,24(r2)
 822767c:	100f883a 	mov	r7,r2
 8227680:	180d883a 	mov	r6,r3
 8227684:	01420974 	movhi	r5,2085
 8227688:	297f1d04 	addi	r5,r5,-908
 822768c:	e13fff17 	ldw	r4,-4(fp)
 8227690:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 8227694:	008209b4 	movhi	r2,2086
 8227698:	10b6b604 	addi	r2,r2,-9512
 822769c:	10800717 	ldw	r2,28(r2)
 82276a0:	100d883a 	mov	r6,r2
 82276a4:	01420974 	movhi	r5,2085
 82276a8:	297ef904 	addi	r5,r5,-1052
 82276ac:	e13fff17 	ldw	r4,-4(fp)
 82276b0:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 82276b4:	008209b4 	movhi	r2,2086
 82276b8:	10b6b604 	addi	r2,r2,-9512
 82276bc:	10800817 	ldw	r2,32(r2)
 82276c0:	100d883a 	mov	r6,r2
 82276c4:	01420974 	movhi	r5,2085
 82276c8:	297f3004 	addi	r5,r5,-832
 82276cc:	e13fff17 	ldw	r4,-4(fp)
 82276d0:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 82276d4:	008209b4 	movhi	r2,2086
 82276d8:	10b6b604 	addi	r2,r2,-9512
 82276dc:	10800917 	ldw	r2,36(r2)
 82276e0:	100d883a 	mov	r6,r2
 82276e4:	01420974 	movhi	r5,2085
 82276e8:	297f4104 	addi	r5,r5,-764
 82276ec:	e13fff17 	ldw	r4,-4(fp)
 82276f0:	8228a940 	call	8228a94 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 82276f4:	008209b4 	movhi	r2,2086
 82276f8:	10b6b604 	addi	r2,r2,-9512
 82276fc:	10c01717 	ldw	r3,92(r2)
 8227700:	008209b4 	movhi	r2,2086
 8227704:	10b6b604 	addi	r2,r2,-9512
 8227708:	10801817 	ldw	r2,96(r2)
 822770c:	100f883a 	mov	r7,r2
 8227710:	180d883a 	mov	r6,r3
 8227714:	01420974 	movhi	r5,2085
 8227718:	297f4d04 	addi	r5,r5,-716
 822771c:	e13fff17 	ldw	r4,-4(fp)
 8227720:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 8227724:	008209b4 	movhi	r2,2086
 8227728:	10b6b604 	addi	r2,r2,-9512
 822772c:	10801617 	ldw	r2,88(r2)
 8227730:	100d883a 	mov	r6,r2
 8227734:	01420974 	movhi	r5,2085
 8227738:	297f6004 	addi	r5,r5,-640
 822773c:	e13fff17 	ldw	r4,-4(fp)
 8227740:	8228a940 	call	8228a94 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 8227744:	008209b4 	movhi	r2,2086
 8227748:	10b6b604 	addi	r2,r2,-9512
 822774c:	10800a17 	ldw	r2,40(r2)
 8227750:	100d883a 	mov	r6,r2
 8227754:	01420974 	movhi	r5,2085
 8227758:	297f6c04 	addi	r5,r5,-592
 822775c:	e13fff17 	ldw	r4,-4(fp)
 8227760:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 8227764:	008209b4 	movhi	r2,2086
 8227768:	10b6b604 	addi	r2,r2,-9512
 822776c:	10800b17 	ldw	r2,44(r2)
 8227770:	100d883a 	mov	r6,r2
 8227774:	01420974 	movhi	r5,2085
 8227778:	297f7804 	addi	r5,r5,-544
 822777c:	e13fff17 	ldw	r4,-4(fp)
 8227780:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 8227784:	008209b4 	movhi	r2,2086
 8227788:	10b6b604 	addi	r2,r2,-9512
 822778c:	10c00c17 	ldw	r3,48(r2)
 8227790:	008209b4 	movhi	r2,2086
 8227794:	10b6b604 	addi	r2,r2,-9512
 8227798:	10800d17 	ldw	r2,52(r2)
 822779c:	100f883a 	mov	r7,r2
 82277a0:	180d883a 	mov	r6,r3
 82277a4:	01420974 	movhi	r5,2085
 82277a8:	297f8404 	addi	r5,r5,-496
 82277ac:	e13fff17 	ldw	r4,-4(fp)
 82277b0:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 82277b4:	008209b4 	movhi	r2,2086
 82277b8:	10b6b604 	addi	r2,r2,-9512
 82277bc:	10c00e17 	ldw	r3,56(r2)
 82277c0:	008209b4 	movhi	r2,2086
 82277c4:	10b6b604 	addi	r2,r2,-9512
 82277c8:	10800f17 	ldw	r2,60(r2)
 82277cc:	100f883a 	mov	r7,r2
 82277d0:	180d883a 	mov	r6,r3
 82277d4:	01420974 	movhi	r5,2085
 82277d8:	297f9804 	addi	r5,r5,-416
 82277dc:	e13fff17 	ldw	r4,-4(fp)
 82277e0:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 82277e4:	008209b4 	movhi	r2,2086
 82277e8:	10b6b604 	addi	r2,r2,-9512
 82277ec:	10801117 	ldw	r2,68(r2)
 82277f0:	100d883a 	mov	r6,r2
 82277f4:	01420974 	movhi	r5,2085
 82277f8:	297fa804 	addi	r5,r5,-352
 82277fc:	e13fff17 	ldw	r4,-4(fp)
 8227800:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 8227804:	008209b4 	movhi	r2,2086
 8227808:	10b6b604 	addi	r2,r2,-9512
 822780c:	10801217 	ldw	r2,72(r2)
 8227810:	100d883a 	mov	r6,r2
 8227814:	01420974 	movhi	r5,2085
 8227818:	297fb504 	addi	r5,r5,-300
 822781c:	e13fff17 	ldw	r4,-4(fp)
 8227820:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 8227824:	008209b4 	movhi	r2,2086
 8227828:	10b6b604 	addi	r2,r2,-9512
 822782c:	10801317 	ldw	r2,76(r2)
 8227830:	100d883a 	mov	r6,r2
 8227834:	01420974 	movhi	r5,2085
 8227838:	297fc804 	addi	r5,r5,-224
 822783c:	e13fff17 	ldw	r4,-4(fp)
 8227840:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 8227844:	008209b4 	movhi	r2,2086
 8227848:	10b6b604 	addi	r2,r2,-9512
 822784c:	10801417 	ldw	r2,80(r2)
 8227850:	100d883a 	mov	r6,r2
 8227854:	01420974 	movhi	r5,2085
 8227858:	297fd904 	addi	r5,r5,-156
 822785c:	e13fff17 	ldw	r4,-4(fp)
 8227860:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 8227864:	008209b4 	movhi	r2,2086
 8227868:	10b6b604 	addi	r2,r2,-9512
 822786c:	10801017 	ldw	r2,64(r2)
 8227870:	100d883a 	mov	r6,r2
 8227874:	01420974 	movhi	r5,2085
 8227878:	297feb04 	addi	r5,r5,-84
 822787c:	e13fff17 	ldw	r4,-4(fp)
 8227880:	8228a940 	call	8228a94 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 8227884:	008209b4 	movhi	r2,2086
 8227888:	10b6b604 	addi	r2,r2,-9512
 822788c:	10801517 	ldw	r2,84(r2)
 8227890:	100d883a 	mov	r6,r2
 8227894:	01420974 	movhi	r5,2085
 8227898:	297ffb04 	addi	r5,r5,-20
 822789c:	e13fff17 	ldw	r4,-4(fp)
 82278a0:	8228a940 	call	8228a94 <ns_printf>
   
   return IGMP_OK;
 82278a4:	0005883a 	mov	r2,zero
}
 82278a8:	e037883a 	mov	sp,fp
 82278ac:	dfc00117 	ldw	ra,4(sp)
 82278b0:	df000017 	ldw	fp,0(sp)
 82278b4:	dec00204 	addi	sp,sp,8
 82278b8:	f800283a 	ret

082278bc <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 82278bc:	defff404 	addi	sp,sp,-48
 82278c0:	dfc00b15 	stw	ra,44(sp)
 82278c4:	df000a15 	stw	fp,40(sp)
 82278c8:	df000a04 	addi	fp,sp,40
 82278cc:	e13ffd15 	stw	r4,-12(fp)
 82278d0:	e17ffe15 	stw	r5,-8(fp)
 82278d4:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 82278d8:	e0bffd17 	ldw	r2,-12(fp)
 82278dc:	10bff804 	addi	r2,r2,-32
 82278e0:	1085883a 	add	r2,r2,r2
 82278e4:	1085883a 	add	r2,r2,r2
 82278e8:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 82278ec:	008209b4 	movhi	r2,2086
 82278f0:	10b7ef04 	addi	r2,r2,-8260
 82278f4:	e0bff615 	stw	r2,-40(fp)
 82278f8:	00000606 	br	8227914 <bsd_accept+0x58>
 82278fc:	e0fff617 	ldw	r3,-40(fp)
 8227900:	e0bff717 	ldw	r2,-36(fp)
 8227904:	18800626 	beq	r3,r2,8227920 <bsd_accept+0x64>
 8227908:	e0bff617 	ldw	r2,-40(fp)
 822790c:	10800017 	ldw	r2,0(r2)
 8227910:	e0bff615 	stw	r2,-40(fp)
 8227914:	e0bff617 	ldw	r2,-40(fp)
 8227918:	103ff81e 	bne	r2,zero,82278fc <bsd_accept+0x40>
 822791c:	00000106 	br	8227924 <bsd_accept+0x68>
 8227920:	0001883a 	nop
 8227924:	e0fff617 	ldw	r3,-40(fp)
 8227928:	e0bff717 	ldw	r2,-36(fp)
 822792c:	18800326 	beq	r3,r2,822793c <bsd_accept+0x80>
 8227930:	822d1c80 	call	822d1c8 <dtrap>
 8227934:	00bfffc4 	movi	r2,-1
 8227938:	00002406 	br	82279cc <bsd_accept+0x110>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 822793c:	e0bffe17 	ldw	r2,-8(fp)
 8227940:	10000726 	beq	r2,zero,8227960 <bsd_accept+0xa4>
   {
      if (addrlen == 0)
 8227944:	e0bfff17 	ldw	r2,-4(fp)
 8227948:	1000051e 	bne	r2,zero,8227960 <bsd_accept+0xa4>
      {
         so->so_error = EFAULT;
 822794c:	e0bff717 	ldw	r2,-36(fp)
 8227950:	00c00384 	movi	r3,14
 8227954:	10c00615 	stw	r3,24(r2)
         return -1;
 8227958:	00bfffc4 	movi	r2,-1
 822795c:	00001b06 	br	82279cc <bsd_accept+0x110>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 8227960:	e0bff904 	addi	r2,fp,-28
 8227964:	e1bfff17 	ldw	r6,-4(fp)
 8227968:	100b883a 	mov	r5,r2
 822796c:	e13ffd17 	ldw	r4,-12(fp)
 8227970:	82303200 	call	8230320 <t_accept>
 8227974:	e0bff815 	stw	r2,-32(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 8227978:	e0bff817 	ldw	r2,-32(fp)
 822797c:	10bfffe0 	cmpeqi	r2,r2,-1
 8227980:	1000111e 	bne	r2,zero,82279c8 <bsd_accept+0x10c>
 8227984:	e0bffe17 	ldw	r2,-8(fp)
 8227988:	10000f26 	beq	r2,zero,82279c8 <bsd_accept+0x10c>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 822798c:	e0bfff17 	ldw	r2,-4(fp)
 8227990:	10800017 	ldw	r2,0(r2)
 8227994:	10800470 	cmpltui	r2,r2,17
 8227998:	1000031e 	bne	r2,zero,82279a8 <bsd_accept+0xec>
         *addrlen = sizeof(struct sockaddr_in);
 822799c:	e0bfff17 	ldw	r2,-4(fp)
 82279a0:	00c00404 	movi	r3,16
 82279a4:	10c00015 	stw	r3,0(r2)
      MEMCPY(addr, &laddr, *addrlen);
 82279a8:	e0bfff17 	ldw	r2,-4(fp)
 82279ac:	10800017 	ldw	r2,0(r2)
 82279b0:	1007883a 	mov	r3,r2
 82279b4:	e0bff904 	addi	r2,fp,-28
 82279b8:	180d883a 	mov	r6,r3
 82279bc:	100b883a 	mov	r5,r2
 82279c0:	e13ffe17 	ldw	r4,-8(fp)
 82279c4:	8202a0c0 	call	8202a0c <memcpy>
   }

   return lret;
 82279c8:	e0bff817 	ldw	r2,-32(fp)
}
 82279cc:	e037883a 	mov	sp,fp
 82279d0:	dfc00117 	ldw	ra,4(sp)
 82279d4:	df000017 	ldw	fp,0(sp)
 82279d8:	dec00204 	addi	sp,sp,8
 82279dc:	f800283a 	ret

082279e0 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 82279e0:	defff304 	addi	sp,sp,-52
 82279e4:	dfc00c15 	stw	ra,48(sp)
 82279e8:	df000b15 	stw	fp,44(sp)
 82279ec:	df000b04 	addi	fp,sp,44
 82279f0:	e13ffd15 	stw	r4,-12(fp)
 82279f4:	e17ffe15 	stw	r5,-8(fp)
 82279f8:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 82279fc:	e0bffd17 	ldw	r2,-12(fp)
 8227a00:	10bff804 	addi	r2,r2,-32
 8227a04:	1085883a 	add	r2,r2,r2
 8227a08:	1085883a 	add	r2,r2,r2
 8227a0c:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227a10:	008209b4 	movhi	r2,2086
 8227a14:	10b7ef04 	addi	r2,r2,-8260
 8227a18:	e0bff515 	stw	r2,-44(fp)
 8227a1c:	00000606 	br	8227a38 <bsd_getpeername+0x58>
 8227a20:	e0fff517 	ldw	r3,-44(fp)
 8227a24:	e0bff617 	ldw	r2,-40(fp)
 8227a28:	18800626 	beq	r3,r2,8227a44 <bsd_getpeername+0x64>
 8227a2c:	e0bff517 	ldw	r2,-44(fp)
 8227a30:	10800017 	ldw	r2,0(r2)
 8227a34:	e0bff515 	stw	r2,-44(fp)
 8227a38:	e0bff517 	ldw	r2,-44(fp)
 8227a3c:	103ff81e 	bne	r2,zero,8227a20 <bsd_getpeername+0x40>
 8227a40:	00000106 	br	8227a48 <bsd_getpeername+0x68>
 8227a44:	0001883a 	nop
 8227a48:	e0fff517 	ldw	r3,-44(fp)
 8227a4c:	e0bff617 	ldw	r2,-40(fp)
 8227a50:	18800326 	beq	r3,r2,8227a60 <bsd_getpeername+0x80>
 8227a54:	822d1c80 	call	822d1c8 <dtrap>
 8227a58:	00bfffc4 	movi	r2,-1
 8227a5c:	00002406 	br	8227af0 <bsd_getpeername+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227a60:	e0bfff17 	ldw	r2,-4(fp)
 8227a64:	1000051e 	bne	r2,zero,8227a7c <bsd_getpeername+0x9c>
   {
      so->so_error = EFAULT;
 8227a68:	e0bff617 	ldw	r2,-40(fp)
 8227a6c:	00c00384 	movi	r3,14
 8227a70:	10c00615 	stw	r3,24(r2)
      return -1;
 8227a74:	00bfffc4 	movi	r2,-1
 8227a78:	00001d06 	br	8227af0 <bsd_getpeername+0x110>
   }
   lnamelen = *namelen;
 8227a7c:	e0bfff17 	ldw	r2,-4(fp)
 8227a80:	10800017 	ldw	r2,0(r2)
 8227a84:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 8227a88:	e0fffc04 	addi	r3,fp,-16
 8227a8c:	e0bff804 	addi	r2,fp,-32
 8227a90:	180d883a 	mov	r6,r3
 8227a94:	100b883a 	mov	r5,r2
 8227a98:	e13ffd17 	ldw	r4,-12(fp)
 8227a9c:	82307e00 	call	82307e0 <t_getpeername>
 8227aa0:	e0bff715 	stw	r2,-36(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 8227aa4:	e0bff717 	ldw	r2,-36(fp)
 8227aa8:	10bfffe0 	cmpeqi	r2,r2,-1
 8227aac:	10000f1e 	bne	r2,zero,8227aec <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227ab0:	e0bffc17 	ldw	r2,-16(fp)
 8227ab4:	10800470 	cmpltui	r2,r2,17
 8227ab8:	1000021e 	bne	r2,zero,8227ac4 <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227abc:	00800404 	movi	r2,16
 8227ac0:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 8227ac4:	e0bffc17 	ldw	r2,-16(fp)
 8227ac8:	1007883a 	mov	r3,r2
 8227acc:	e0bff804 	addi	r2,fp,-32
 8227ad0:	180d883a 	mov	r6,r3
 8227ad4:	100b883a 	mov	r5,r2
 8227ad8:	e13ffe17 	ldw	r4,-8(fp)
 8227adc:	8202a0c0 	call	8202a0c <memcpy>
      *namelen = lnamelen;
 8227ae0:	e0fffc17 	ldw	r3,-16(fp)
 8227ae4:	e0bfff17 	ldw	r2,-4(fp)
 8227ae8:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227aec:	e0bff717 	ldw	r2,-36(fp)
}
 8227af0:	e037883a 	mov	sp,fp
 8227af4:	dfc00117 	ldw	ra,4(sp)
 8227af8:	df000017 	ldw	fp,0(sp)
 8227afc:	dec00204 	addi	sp,sp,8
 8227b00:	f800283a 	ret

08227b04 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227b04:	defff304 	addi	sp,sp,-52
 8227b08:	dfc00c15 	stw	ra,48(sp)
 8227b0c:	df000b15 	stw	fp,44(sp)
 8227b10:	df000b04 	addi	fp,sp,44
 8227b14:	e13ffd15 	stw	r4,-12(fp)
 8227b18:	e17ffe15 	stw	r5,-8(fp)
 8227b1c:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227b20:	e0bffd17 	ldw	r2,-12(fp)
 8227b24:	10bff804 	addi	r2,r2,-32
 8227b28:	1085883a 	add	r2,r2,r2
 8227b2c:	1085883a 	add	r2,r2,r2
 8227b30:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227b34:	008209b4 	movhi	r2,2086
 8227b38:	10b7ef04 	addi	r2,r2,-8260
 8227b3c:	e0bff515 	stw	r2,-44(fp)
 8227b40:	00000606 	br	8227b5c <bsd_getsockname+0x58>
 8227b44:	e0fff517 	ldw	r3,-44(fp)
 8227b48:	e0bff617 	ldw	r2,-40(fp)
 8227b4c:	18800626 	beq	r3,r2,8227b68 <bsd_getsockname+0x64>
 8227b50:	e0bff517 	ldw	r2,-44(fp)
 8227b54:	10800017 	ldw	r2,0(r2)
 8227b58:	e0bff515 	stw	r2,-44(fp)
 8227b5c:	e0bff517 	ldw	r2,-44(fp)
 8227b60:	103ff81e 	bne	r2,zero,8227b44 <bsd_getsockname+0x40>
 8227b64:	00000106 	br	8227b6c <bsd_getsockname+0x68>
 8227b68:	0001883a 	nop
 8227b6c:	e0fff517 	ldw	r3,-44(fp)
 8227b70:	e0bff617 	ldw	r2,-40(fp)
 8227b74:	18800326 	beq	r3,r2,8227b84 <bsd_getsockname+0x80>
 8227b78:	822d1c80 	call	822d1c8 <dtrap>
 8227b7c:	00bfffc4 	movi	r2,-1
 8227b80:	00002406 	br	8227c14 <bsd_getsockname+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227b84:	e0bfff17 	ldw	r2,-4(fp)
 8227b88:	1000051e 	bne	r2,zero,8227ba0 <bsd_getsockname+0x9c>
   {
      so->so_error = EFAULT;
 8227b8c:	e0bff617 	ldw	r2,-40(fp)
 8227b90:	00c00384 	movi	r3,14
 8227b94:	10c00615 	stw	r3,24(r2)
      return -1;
 8227b98:	00bfffc4 	movi	r2,-1
 8227b9c:	00001d06 	br	8227c14 <bsd_getsockname+0x110>
   }
   lnamelen = *namelen;
 8227ba0:	e0bfff17 	ldw	r2,-4(fp)
 8227ba4:	10800017 	ldw	r2,0(r2)
 8227ba8:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 8227bac:	e0fffc04 	addi	r3,fp,-16
 8227bb0:	e0bff804 	addi	r2,fp,-32
 8227bb4:	180d883a 	mov	r6,r3
 8227bb8:	100b883a 	mov	r5,r2
 8227bbc:	e13ffd17 	ldw	r4,-12(fp)
 8227bc0:	82308240 	call	8230824 <t_getsockname>
 8227bc4:	e0bff715 	stw	r2,-36(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 8227bc8:	e0bff717 	ldw	r2,-36(fp)
 8227bcc:	10bfffe0 	cmpeqi	r2,r2,-1
 8227bd0:	10000f1e 	bne	r2,zero,8227c10 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227bd4:	e0bffc17 	ldw	r2,-16(fp)
 8227bd8:	10800470 	cmpltui	r2,r2,17
 8227bdc:	1000021e 	bne	r2,zero,8227be8 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227be0:	00800404 	movi	r2,16
 8227be4:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 8227be8:	e0bffc17 	ldw	r2,-16(fp)
 8227bec:	1007883a 	mov	r3,r2
 8227bf0:	e0bff804 	addi	r2,fp,-32
 8227bf4:	180d883a 	mov	r6,r3
 8227bf8:	100b883a 	mov	r5,r2
 8227bfc:	e13ffe17 	ldw	r4,-8(fp)
 8227c00:	8202a0c0 	call	8202a0c <memcpy>
      *namelen = lnamelen;
 8227c04:	e0fffc17 	ldw	r3,-16(fp)
 8227c08:	e0bfff17 	ldw	r2,-4(fp)
 8227c0c:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227c10:	e0bff717 	ldw	r2,-36(fp)
}
 8227c14:	e037883a 	mov	sp,fp
 8227c18:	dfc00117 	ldw	ra,4(sp)
 8227c1c:	df000017 	ldw	fp,0(sp)
 8227c20:	dec00204 	addi	sp,sp,8
 8227c24:	f800283a 	ret

08227c28 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 8227c28:	defffd04 	addi	sp,sp,-12
 8227c2c:	df000215 	stw	fp,8(sp)
 8227c30:	df000204 	addi	fp,sp,8
 8227c34:	e13ffe15 	stw	r4,-8(fp)
 8227c38:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(level);

   switch (name)
 8227c3c:	e0bfff17 	ldw	r2,-4(fp)
 8227c40:	10c02020 	cmpeqi	r3,r2,128
 8227c44:	1800341e 	bne	r3,zero,8227d18 <bsd_i_sockoptlen+0xf0>
 8227c48:	10c02048 	cmpgei	r3,r2,129
 8227c4c:	18001a1e 	bne	r3,zero,8227cb8 <bsd_i_sockoptlen+0x90>
 8227c50:	10c00308 	cmpgei	r3,r2,12
 8227c54:	18000e1e 	bne	r3,zero,8227c90 <bsd_i_sockoptlen+0x68>
 8227c58:	10c00288 	cmpgei	r3,r2,10
 8227c5c:	1800361e 	bne	r3,zero,8227d38 <bsd_i_sockoptlen+0x110>
 8227c60:	10c00120 	cmpeqi	r3,r2,4
 8227c64:	1800301e 	bne	r3,zero,8227d28 <bsd_i_sockoptlen+0x100>
 8227c68:	10c00148 	cmpgei	r3,r2,5
 8227c6c:	1800031e 	bne	r3,zero,8227c7c <bsd_i_sockoptlen+0x54>
 8227c70:	108000e0 	cmpeqi	r2,r2,3
 8227c74:	1000341e 	bne	r2,zero,8227d48 <bsd_i_sockoptlen+0x120>
 8227c78:	00003506 	br	8227d50 <bsd_i_sockoptlen+0x128>
 8227c7c:	10c00220 	cmpeqi	r3,r2,8
 8227c80:	1800291e 	bne	r3,zero,8227d28 <bsd_i_sockoptlen+0x100>
 8227c84:	10800260 	cmpeqi	r2,r2,9
 8227c88:	1000291e 	bne	r2,zero,8227d30 <bsd_i_sockoptlen+0x108>
 8227c8c:	00003006 	br	8227d50 <bsd_i_sockoptlen+0x128>
 8227c90:	10c00420 	cmpeqi	r3,r2,16
 8227c94:	1800241e 	bne	r3,zero,8227d28 <bsd_i_sockoptlen+0x100>
 8227c98:	10c00448 	cmpgei	r3,r2,17
 8227c9c:	1800031e 	bne	r3,zero,8227cac <bsd_i_sockoptlen+0x84>
 8227ca0:	10800388 	cmpgei	r2,r2,14
 8227ca4:	10002a1e 	bne	r2,zero,8227d50 <bsd_i_sockoptlen+0x128>
 8227ca8:	00002506 	br	8227d40 <bsd_i_sockoptlen+0x118>
 8227cac:	10800820 	cmpeqi	r2,r2,32
 8227cb0:	10001d1e 	bne	r2,zero,8227d28 <bsd_i_sockoptlen+0x100>
 8227cb4:	00002606 	br	8227d50 <bsd_i_sockoptlen+0x128>
 8227cb8:	10c401c8 	cmpgei	r3,r2,4103
 8227cbc:	18000a1e 	bne	r3,zero,8227ce8 <bsd_i_sockoptlen+0xc0>
 8227cc0:	10c40148 	cmpgei	r3,r2,4101
 8227cc4:	1800161e 	bne	r3,zero,8227d20 <bsd_i_sockoptlen+0xf8>
 8227cc8:	10c04020 	cmpeqi	r3,r2,256
 8227ccc:	1800161e 	bne	r3,zero,8227d28 <bsd_i_sockoptlen+0x100>
 8227cd0:	10c04010 	cmplti	r3,r2,256
 8227cd4:	18001e1e 	bne	r3,zero,8227d50 <bsd_i_sockoptlen+0x128>
 8227cd8:	10bbffc4 	addi	r2,r2,-4097
 8227cdc:	108000a8 	cmpgeui	r2,r2,2
 8227ce0:	10001b1e 	bne	r2,zero,8227d50 <bsd_i_sockoptlen+0x128>
 8227ce4:	00001006 	br	8227d28 <bsd_i_sockoptlen+0x100>
 8227ce8:	10c40588 	cmpgei	r3,r2,4118
 8227cec:	1800051e 	bne	r3,zero,8227d04 <bsd_i_sockoptlen+0xdc>
 8227cf0:	10c40508 	cmpgei	r3,r2,4116
 8227cf4:	1800061e 	bne	r3,zero,8227d10 <bsd_i_sockoptlen+0xe8>
 8227cf8:	10840248 	cmpgei	r2,r2,4105
 8227cfc:	1000141e 	bne	r2,zero,8227d50 <bsd_i_sockoptlen+0x128>
 8227d00:	00000906 	br	8227d28 <bsd_i_sockoptlen+0x100>
 8227d04:	108405a0 	cmpeqi	r2,r2,4118
 8227d08:	1000071e 	bne	r2,zero,8227d28 <bsd_i_sockoptlen+0x100>
 8227d0c:	00001006 	br	8227d50 <bsd_i_sockoptlen+0x128>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 8227d10:	0005883a 	mov	r2,zero
 8227d14:	00000f06 	br	8227d54 <bsd_i_sockoptlen+0x12c>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 8227d18:	00800204 	movi	r2,8
 8227d1c:	00000d06 	br	8227d54 <bsd_i_sockoptlen+0x12c>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 8227d20:	00800084 	movi	r2,2
 8227d24:	00000b06 	br	8227d54 <bsd_i_sockoptlen+0x12c>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 8227d28:	00800104 	movi	r2,4
 8227d2c:	00000906 	br	8227d54 <bsd_i_sockoptlen+0x12c>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 8227d30:	00800104 	movi	r2,4
 8227d34:	00000706 	br	8227d54 <bsd_i_sockoptlen+0x12c>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 8227d38:	00800044 	movi	r2,1
 8227d3c:	00000506 	br	8227d54 <bsd_i_sockoptlen+0x12c>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 8227d40:	00800204 	movi	r2,8
 8227d44:	00000306 	br	8227d54 <bsd_i_sockoptlen+0x12c>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 8227d48:	00800104 	movi	r2,4
 8227d4c:	00000106 	br	8227d54 <bsd_i_sockoptlen+0x12c>
   default:
      /* we don't know what type these options are */
      return 0;
 8227d50:	0005883a 	mov	r2,zero
   }
   
}
 8227d54:	e037883a 	mov	sp,fp
 8227d58:	df000017 	ldw	fp,0(sp)
 8227d5c:	dec00104 	addi	sp,sp,4
 8227d60:	f800283a 	ret

08227d64 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 8227d64:	defff504 	addi	sp,sp,-44
 8227d68:	dfc00a15 	stw	ra,40(sp)
 8227d6c:	df000915 	stw	fp,36(sp)
 8227d70:	df000904 	addi	fp,sp,36
 8227d74:	e13ffc15 	stw	r4,-16(fp)
 8227d78:	e17ffd15 	stw	r5,-12(fp)
 8227d7c:	e1bffe15 	stw	r6,-8(fp)
 8227d80:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 8227d84:	e0bffc17 	ldw	r2,-16(fp)
 8227d88:	10bff804 	addi	r2,r2,-32
 8227d8c:	1085883a 	add	r2,r2,r2
 8227d90:	1085883a 	add	r2,r2,r2
 8227d94:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8227d98:	008209b4 	movhi	r2,2086
 8227d9c:	10b7ef04 	addi	r2,r2,-8260
 8227da0:	e0bff815 	stw	r2,-32(fp)
 8227da4:	00000606 	br	8227dc0 <bsd_getsockopt+0x5c>
 8227da8:	e0fff817 	ldw	r3,-32(fp)
 8227dac:	e0bff917 	ldw	r2,-28(fp)
 8227db0:	18800626 	beq	r3,r2,8227dcc <bsd_getsockopt+0x68>
 8227db4:	e0bff817 	ldw	r2,-32(fp)
 8227db8:	10800017 	ldw	r2,0(r2)
 8227dbc:	e0bff815 	stw	r2,-32(fp)
 8227dc0:	e0bff817 	ldw	r2,-32(fp)
 8227dc4:	103ff81e 	bne	r2,zero,8227da8 <bsd_getsockopt+0x44>
 8227dc8:	00000106 	br	8227dd0 <bsd_getsockopt+0x6c>
 8227dcc:	0001883a 	nop
 8227dd0:	e0fff817 	ldw	r3,-32(fp)
 8227dd4:	e0bff917 	ldw	r2,-28(fp)
 8227dd8:	18800326 	beq	r3,r2,8227de8 <bsd_getsockopt+0x84>
 8227ddc:	822d1c80 	call	822d1c8 <dtrap>
 8227de0:	00bfffc4 	movi	r2,-1
 8227de4:	00001d06 	br	8227e5c <bsd_getsockopt+0xf8>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 8227de8:	e17ffe17 	ldw	r5,-8(fp)
 8227dec:	e13ffd17 	ldw	r4,-12(fp)
 8227df0:	8227c280 	call	8227c28 <bsd_i_sockoptlen>
 8227df4:	e0bffa15 	stw	r2,-24(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 8227df8:	e0800217 	ldw	r2,8(fp)
 8227dfc:	10000426 	beq	r2,zero,8227e10 <bsd_getsockopt+0xac>
 8227e00:	e0800217 	ldw	r2,8(fp)
 8227e04:	10c00017 	ldw	r3,0(r2)
 8227e08:	e0bffa17 	ldw	r2,-24(fp)
 8227e0c:	1880050e 	bge	r3,r2,8227e24 <bsd_getsockopt+0xc0>
   {
      so->so_error = EFAULT;
 8227e10:	e0bff917 	ldw	r2,-28(fp)
 8227e14:	00c00384 	movi	r3,14
 8227e18:	10c00615 	stw	r3,24(r2)
      return -1;
 8227e1c:	00bfffc4 	movi	r2,-1
 8227e20:	00000e06 	br	8227e5c <bsd_getsockopt+0xf8>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 8227e24:	e0bffa17 	ldw	r2,-24(fp)
 8227e28:	d8800015 	stw	r2,0(sp)
 8227e2c:	e1ffff17 	ldw	r7,-4(fp)
 8227e30:	e1bffe17 	ldw	r6,-8(fp)
 8227e34:	e17ffd17 	ldw	r5,-12(fp)
 8227e38:	e13ffc17 	ldw	r4,-16(fp)
 8227e3c:	8230c040 	call	8230c04 <t_getsockopt>
 8227e40:	e0bffb15 	stw	r2,-20(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 8227e44:	e0bffb17 	ldw	r2,-20(fp)
 8227e48:	1000031e 	bne	r2,zero,8227e58 <bsd_getsockopt+0xf4>
   {
      *optlen = loptlen;
 8227e4c:	e0800217 	ldw	r2,8(fp)
 8227e50:	e0fffa17 	ldw	r3,-24(fp)
 8227e54:	10c00015 	stw	r3,0(r2)
   }

   return e;
 8227e58:	e0bffb17 	ldw	r2,-20(fp)
   
}
 8227e5c:	e037883a 	mov	sp,fp
 8227e60:	dfc00117 	ldw	ra,4(sp)
 8227e64:	df000017 	ldw	fp,0(sp)
 8227e68:	dec00204 	addi	sp,sp,8
 8227e6c:	f800283a 	ret

08227e70 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 8227e70:	defff504 	addi	sp,sp,-44
 8227e74:	dfc00815 	stw	ra,32(sp)
 8227e78:	df000715 	stw	fp,28(sp)
 8227e7c:	df000704 	addi	fp,sp,28
 8227e80:	e13ffe15 	stw	r4,-8(fp)
 8227e84:	e17fff15 	stw	r5,-4(fp)
 8227e88:	e1800215 	stw	r6,8(fp)
 8227e8c:	e1c00315 	stw	r7,12(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 8227e90:	e0bffe17 	ldw	r2,-8(fp)
 8227e94:	10bff804 	addi	r2,r2,-32
 8227e98:	1085883a 	add	r2,r2,r2
 8227e9c:	1085883a 	add	r2,r2,r2
 8227ea0:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 8227ea4:	008209b4 	movhi	r2,2086
 8227ea8:	10b7ef04 	addi	r2,r2,-8260
 8227eac:	e0bffa15 	stw	r2,-24(fp)
 8227eb0:	00000606 	br	8227ecc <bsd_ioctl+0x5c>
 8227eb4:	e0fffa17 	ldw	r3,-24(fp)
 8227eb8:	e0bffb17 	ldw	r2,-20(fp)
 8227ebc:	18800626 	beq	r3,r2,8227ed8 <bsd_ioctl+0x68>
 8227ec0:	e0bffa17 	ldw	r2,-24(fp)
 8227ec4:	10800017 	ldw	r2,0(r2)
 8227ec8:	e0bffa15 	stw	r2,-24(fp)
 8227ecc:	e0bffa17 	ldw	r2,-24(fp)
 8227ed0:	103ff81e 	bne	r2,zero,8227eb4 <bsd_ioctl+0x44>
 8227ed4:	00000106 	br	8227edc <bsd_ioctl+0x6c>
 8227ed8:	0001883a 	nop
 8227edc:	e0fffa17 	ldw	r3,-24(fp)
 8227ee0:	e0bffb17 	ldw	r2,-20(fp)
 8227ee4:	18800326 	beq	r3,r2,8227ef4 <bsd_ioctl+0x84>
 8227ee8:	822d1c80 	call	822d1c8 <dtrap>
 8227eec:	00bfffc4 	movi	r2,-1
 8227ef0:	00001706 	br	8227f50 <bsd_ioctl+0xe0>

   va_start(argptr, request);
 8227ef4:	e0800204 	addi	r2,fp,8
 8227ef8:	e0bffc15 	stw	r2,-16(fp)

   switch (request)
 8227efc:	e0bfff17 	ldw	r2,-4(fp)
 8227f00:	108405a0 	cmpeqi	r2,r2,4118
 8227f04:	10000e26 	beq	r2,zero,8227f40 <bsd_ioctl+0xd0>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 8227f08:	e0bffc17 	ldw	r2,-16(fp)
 8227f0c:	10c00104 	addi	r3,r2,4
 8227f10:	e0fffc15 	stw	r3,-16(fp)
 8227f14:	10800017 	ldw	r2,0(r2)
 8227f18:	e0bffd15 	stw	r2,-12(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 8227f1c:	e0fffd04 	addi	r3,fp,-12
 8227f20:	00800104 	movi	r2,4
 8227f24:	d8800015 	stw	r2,0(sp)
 8227f28:	180f883a 	mov	r7,r3
 8227f2c:	01840584 	movi	r6,4118
 8227f30:	017fffc4 	movi	r5,-1
 8227f34:	e13ffe17 	ldw	r4,-8(fp)
 8227f38:	8230a440 	call	8230a44 <t_setsockopt>
 8227f3c:	00000406 	br	8227f50 <bsd_ioctl+0xe0>
   default:
      so->so_error = EINVAL;
 8227f40:	e0bffb17 	ldw	r2,-20(fp)
 8227f44:	00c00584 	movi	r3,22
 8227f48:	10c00615 	stw	r3,24(r2)
      return -1;
 8227f4c:	00bfffc4 	movi	r2,-1
   }
}
 8227f50:	e037883a 	mov	sp,fp
 8227f54:	dfc00117 	ldw	ra,4(sp)
 8227f58:	df000017 	ldw	fp,0(sp)
 8227f5c:	dec00404 	addi	sp,sp,16
 8227f60:	f800283a 	ret

08227f64 <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 8227f64:	defffd04 	addi	sp,sp,-12
 8227f68:	dfc00215 	stw	ra,8(sp)
 8227f6c:	df000115 	stw	fp,4(sp)
 8227f70:	df000104 	addi	fp,sp,4
 8227f74:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 8227f78:	e0bfff17 	ldw	r2,-4(fp)
 8227f7c:	1009883a 	mov	r4,r2
 8227f80:	82286280 	call	8228628 <print_ipad>
}
 8227f84:	e037883a 	mov	sp,fp
 8227f88:	dfc00117 	ldw	ra,4(sp)
 8227f8c:	df000017 	ldw	fp,0(sp)
 8227f90:	dec00204 	addi	sp,sp,8
 8227f94:	f800283a 	ret

08227f98 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 8227f98:	defff004 	addi	sp,sp,-64
 8227f9c:	dfc00f15 	stw	ra,60(sp)
 8227fa0:	df000e15 	stw	fp,56(sp)
 8227fa4:	df000e04 	addi	fp,sp,56
 8227fa8:	e13ffc15 	stw	r4,-16(fp)
 8227fac:	e17ffd15 	stw	r5,-12(fp)
 8227fb0:	e1bffe15 	stw	r6,-8(fp)
 8227fb4:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 8227fb8:	e03ffb15 	stw	zero,-20(fp)
   int lret;

   so = LONG2SO(s);
 8227fbc:	e0bffc17 	ldw	r2,-16(fp)
 8227fc0:	10bff804 	addi	r2,r2,-32
 8227fc4:	1085883a 	add	r2,r2,r2
 8227fc8:	1085883a 	add	r2,r2,r2
 8227fcc:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 8227fd0:	008209b4 	movhi	r2,2086
 8227fd4:	10b7ef04 	addi	r2,r2,-8260
 8227fd8:	e0bff415 	stw	r2,-48(fp)
 8227fdc:	00000606 	br	8227ff8 <bsd_recvfrom+0x60>
 8227fe0:	e0fff417 	ldw	r3,-48(fp)
 8227fe4:	e0bff517 	ldw	r2,-44(fp)
 8227fe8:	18800626 	beq	r3,r2,8228004 <bsd_recvfrom+0x6c>
 8227fec:	e0bff417 	ldw	r2,-48(fp)
 8227ff0:	10800017 	ldw	r2,0(r2)
 8227ff4:	e0bff415 	stw	r2,-48(fp)
 8227ff8:	e0bff417 	ldw	r2,-48(fp)
 8227ffc:	103ff81e 	bne	r2,zero,8227fe0 <bsd_recvfrom+0x48>
 8228000:	00000106 	br	8228008 <bsd_recvfrom+0x70>
 8228004:	0001883a 	nop
 8228008:	e0fff417 	ldw	r3,-48(fp)
 822800c:	e0bff517 	ldw	r2,-44(fp)
 8228010:	18800326 	beq	r3,r2,8228020 <bsd_recvfrom+0x88>
 8228014:	822d1c80 	call	822d1c8 <dtrap>
 8228018:	00bfffc4 	movi	r2,-1
 822801c:	00002b06 	br	82280cc <bsd_recvfrom+0x134>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 8228020:	e0800217 	ldw	r2,8(fp)
 8228024:	10000a26 	beq	r2,zero,8228050 <bsd_recvfrom+0xb8>
   {
      if (fromlen == NULL)
 8228028:	e0800317 	ldw	r2,12(fp)
 822802c:	1000051e 	bne	r2,zero,8228044 <bsd_recvfrom+0xac>
      {
         so->so_error = EFAULT;
 8228030:	e0bff517 	ldw	r2,-44(fp)
 8228034:	00c00384 	movi	r3,14
 8228038:	10c00615 	stw	r3,24(r2)
         return -1;
 822803c:	00bfffc4 	movi	r2,-1
 8228040:	00002206 	br	82280cc <bsd_recvfrom+0x134>
      }
      lfromlen = *fromlen;
 8228044:	e0800317 	ldw	r2,12(fp)
 8228048:	10800017 	ldw	r2,0(r2)
 822804c:	e0bffb15 	stw	r2,-20(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 8228050:	e0bffb04 	addi	r2,fp,-20
 8228054:	d8800115 	stw	r2,4(sp)
 8228058:	e0bff704 	addi	r2,fp,-36
 822805c:	d8800015 	stw	r2,0(sp)
 8228060:	e1ffff17 	ldw	r7,-4(fp)
 8228064:	e1bffe17 	ldw	r6,-8(fp)
 8228068:	e17ffd17 	ldw	r5,-12(fp)
 822806c:	e13ffc17 	ldw	r4,-16(fp)
 8228070:	8230e700 	call	8230e70 <t_recvfrom>
 8228074:	e0bff615 	stw	r2,-40(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 8228078:	e0bff617 	ldw	r2,-40(fp)
 822807c:	10bfffe0 	cmpeqi	r2,r2,-1
 8228080:	1000111e 	bne	r2,zero,82280c8 <bsd_recvfrom+0x130>
 8228084:	e0800217 	ldw	r2,8(fp)
 8228088:	10000f26 	beq	r2,zero,82280c8 <bsd_recvfrom+0x130>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 822808c:	e0bffb17 	ldw	r2,-20(fp)
 8228090:	10800470 	cmpltui	r2,r2,17
 8228094:	1000021e 	bne	r2,zero,82280a0 <bsd_recvfrom+0x108>
         lfromlen = sizeof(struct sockaddr_in);
 8228098:	00800404 	movi	r2,16
 822809c:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 82280a0:	e0bffb17 	ldw	r2,-20(fp)
 82280a4:	1007883a 	mov	r3,r2
 82280a8:	e0bff704 	addi	r2,fp,-36
 82280ac:	180d883a 	mov	r6,r3
 82280b0:	100b883a 	mov	r5,r2
 82280b4:	e1000217 	ldw	r4,8(fp)
 82280b8:	8202a0c0 	call	8202a0c <memcpy>
      *fromlen = lfromlen;
 82280bc:	e0fffb17 	ldw	r3,-20(fp)
 82280c0:	e0800317 	ldw	r2,12(fp)
 82280c4:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 82280c8:	e0bff617 	ldw	r2,-40(fp)
}
 82280cc:	e037883a 	mov	sp,fp
 82280d0:	dfc00117 	ldw	ra,4(sp)
 82280d4:	df000017 	ldw	fp,0(sp)
 82280d8:	dec00204 	addi	sp,sp,8
 82280dc:	f800283a 	ret

082280e0 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 82280e0:	defff804 	addi	sp,sp,-32
 82280e4:	dfc00715 	stw	ra,28(sp)
 82280e8:	df000615 	stw	fp,24(sp)
 82280ec:	df000604 	addi	fp,sp,24
 82280f0:	e13ffc15 	stw	r4,-16(fp)
 82280f4:	e17ffd15 	stw	r5,-12(fp)
 82280f8:	e1bffe15 	stw	r6,-8(fp)
 82280fc:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 8228100:	e0800217 	ldw	r2,8(fp)
 8228104:	10004b26 	beq	r2,zero,8228234 <bsd_select+0x154>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 8228108:	00801904 	movi	r2,100
 822810c:	e0bffb15 	stw	r2,-20(fp)
      if (tps >= 1000)
 8228110:	e0bffb17 	ldw	r2,-20(fp)
 8228114:	1080fa10 	cmplti	r2,r2,1000
 8228118:	10000e1e 	bne	r2,zero,8228154 <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 822811c:	e0800217 	ldw	r2,8(fp)
 8228120:	10800117 	ldw	r2,4(r2)
 8228124:	10800c84 	addi	r2,r2,50
 8228128:	01401904 	movi	r5,100
 822812c:	1009883a 	mov	r4,r2
 8228130:	82026140 	call	8202614 <__divsi3>
 8228134:	1007883a 	mov	r3,r2
 8228138:	e0bffb17 	ldw	r2,-20(fp)
 822813c:	1885383a 	mul	r2,r3,r2
 8228140:	0149c404 	movi	r5,10000
 8228144:	1009883a 	mov	r4,r2
 8228148:	82026140 	call	8202614 <__divsi3>
 822814c:	e0bffa15 	stw	r2,-24(fp)
 8228150:	00003106 	br	8228218 <bsd_select+0x138>
      }
      else if (tps >= 100)
 8228154:	e0bffb17 	ldw	r2,-20(fp)
 8228158:	10801910 	cmplti	r2,r2,100
 822815c:	10000e1e 	bne	r2,zero,8228198 <bsd_select+0xb8>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 8228160:	e0800217 	ldw	r2,8(fp)
 8228164:	10800117 	ldw	r2,4(r2)
 8228168:	10807d04 	addi	r2,r2,500
 822816c:	0140fa04 	movi	r5,1000
 8228170:	1009883a 	mov	r4,r2
 8228174:	82026140 	call	8202614 <__divsi3>
 8228178:	1007883a 	mov	r3,r2
 822817c:	e0bffb17 	ldw	r2,-20(fp)
 8228180:	1885383a 	mul	r2,r3,r2
 8228184:	0140fa04 	movi	r5,1000
 8228188:	1009883a 	mov	r4,r2
 822818c:	82026140 	call	8202614 <__divsi3>
 8228190:	e0bffa15 	stw	r2,-24(fp)
 8228194:	00002006 	br	8228218 <bsd_select+0x138>
      }
      else if (tps >= 10)
 8228198:	e0bffb17 	ldw	r2,-20(fp)
 822819c:	10800290 	cmplti	r2,r2,10
 82281a0:	10000e1e 	bne	r2,zero,82281dc <bsd_select+0xfc>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 82281a4:	e0800217 	ldw	r2,8(fp)
 82281a8:	10800117 	ldw	r2,4(r2)
 82281ac:	1084e204 	addi	r2,r2,5000
 82281b0:	0149c404 	movi	r5,10000
 82281b4:	1009883a 	mov	r4,r2
 82281b8:	82026140 	call	8202614 <__divsi3>
 82281bc:	1007883a 	mov	r3,r2
 82281c0:	e0bffb17 	ldw	r2,-20(fp)
 82281c4:	1885383a 	mul	r2,r3,r2
 82281c8:	01401904 	movi	r5,100
 82281cc:	1009883a 	mov	r4,r2
 82281d0:	82026140 	call	8202614 <__divsi3>
 82281d4:	e0bffa15 	stw	r2,-24(fp)
 82281d8:	00000f06 	br	8228218 <bsd_select+0x138>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 82281dc:	e0800217 	ldw	r2,8(fp)
 82281e0:	10c00117 	ldw	r3,4(r2)
 82281e4:	00b0d414 	movui	r2,50000
 82281e8:	1885883a 	add	r2,r3,r2
 82281ec:	014000b4 	movhi	r5,2
 82281f0:	2961a804 	addi	r5,r5,-31072
 82281f4:	1009883a 	mov	r4,r2
 82281f8:	82026140 	call	8202614 <__divsi3>
 82281fc:	1007883a 	mov	r3,r2
 8228200:	e0bffb17 	ldw	r2,-20(fp)
 8228204:	1885383a 	mul	r2,r3,r2
 8228208:	01400284 	movi	r5,10
 822820c:	1009883a 	mov	r4,r2
 8228210:	82026140 	call	8202614 <__divsi3>
 8228214:	e0bffa15 	stw	r2,-24(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 8228218:	e0800217 	ldw	r2,8(fp)
 822821c:	10800017 	ldw	r2,0(r2)
 8228220:	10801924 	muli	r2,r2,100
 8228224:	e0fffa17 	ldw	r3,-24(fp)
 8228228:	1885883a 	add	r2,r3,r2
 822822c:	e0bffa15 	stw	r2,-24(fp)
 8228230:	00000206 	br	822823c <bsd_select+0x15c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 8228234:	00bfffc4 	movi	r2,-1
 8228238:	e0bffa15 	stw	r2,-24(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 822823c:	e1fffa17 	ldw	r7,-24(fp)
 8228240:	e1bfff17 	ldw	r6,-4(fp)
 8228244:	e17ffe17 	ldw	r5,-8(fp)
 8228248:	e13ffd17 	ldw	r4,-12(fp)
 822824c:	82349280 	call	8234928 <t_select>
}
 8228250:	e037883a 	mov	sp,fp
 8228254:	dfc00117 	ldw	ra,4(sp)
 8228258:	df000017 	ldw	fp,0(sp)
 822825c:	dec00204 	addi	sp,sp,8
 8228260:	f800283a 	ret

08228264 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 8228264:	defff704 	addi	sp,sp,-36
 8228268:	dfc00815 	stw	ra,32(sp)
 822826c:	df000715 	stw	fp,28(sp)
 8228270:	df000704 	addi	fp,sp,28
 8228274:	e13ffc15 	stw	r4,-16(fp)
 8228278:	e17ffd15 	stw	r5,-12(fp)
 822827c:	e1bffe15 	stw	r6,-8(fp)
 8228280:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;

   so = LONG2SO(s);
 8228284:	e0bffc17 	ldw	r2,-16(fp)
 8228288:	10bff804 	addi	r2,r2,-32
 822828c:	1085883a 	add	r2,r2,r2
 8228290:	1085883a 	add	r2,r2,r2
 8228294:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 8228298:	008209b4 	movhi	r2,2086
 822829c:	10b7ef04 	addi	r2,r2,-8260
 82282a0:	e0bffa15 	stw	r2,-24(fp)
 82282a4:	00000606 	br	82282c0 <bsd_setsockopt+0x5c>
 82282a8:	e0fffa17 	ldw	r3,-24(fp)
 82282ac:	e0bffb17 	ldw	r2,-20(fp)
 82282b0:	18800626 	beq	r3,r2,82282cc <bsd_setsockopt+0x68>
 82282b4:	e0bffa17 	ldw	r2,-24(fp)
 82282b8:	10800017 	ldw	r2,0(r2)
 82282bc:	e0bffa15 	stw	r2,-24(fp)
 82282c0:	e0bffa17 	ldw	r2,-24(fp)
 82282c4:	103ff81e 	bne	r2,zero,82282a8 <bsd_setsockopt+0x44>
 82282c8:	00000106 	br	82282d0 <bsd_setsockopt+0x6c>
 82282cc:	0001883a 	nop
 82282d0:	e0fffa17 	ldw	r3,-24(fp)
 82282d4:	e0bffb17 	ldw	r2,-20(fp)
 82282d8:	18800326 	beq	r3,r2,82282e8 <bsd_setsockopt+0x84>
 82282dc:	822d1c80 	call	822d1c8 <dtrap>
 82282e0:	00bfffc4 	movi	r2,-1
 82282e4:	00001206 	br	8228330 <bsd_setsockopt+0xcc>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 82282e8:	e17ffe17 	ldw	r5,-8(fp)
 82282ec:	e13ffd17 	ldw	r4,-12(fp)
 82282f0:	8227c280 	call	8227c28 <bsd_i_sockoptlen>
 82282f4:	1007883a 	mov	r3,r2
 82282f8:	e0800217 	ldw	r2,8(fp)
 82282fc:	10c0050e 	bge	r2,r3,8228314 <bsd_setsockopt+0xb0>
   {
      so->so_error = EFAULT;
 8228300:	e0bffb17 	ldw	r2,-20(fp)
 8228304:	00c00384 	movi	r3,14
 8228308:	10c00615 	stw	r3,24(r2)
      return -1;
 822830c:	00bfffc4 	movi	r2,-1
 8228310:	00000706 	br	8228330 <bsd_setsockopt+0xcc>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 8228314:	e0800217 	ldw	r2,8(fp)
 8228318:	d8800015 	stw	r2,0(sp)
 822831c:	e1ffff17 	ldw	r7,-4(fp)
 8228320:	e1bffe17 	ldw	r6,-8(fp)
 8228324:	e17ffd17 	ldw	r5,-12(fp)
 8228328:	e13ffc17 	ldw	r4,-16(fp)
 822832c:	8230a440 	call	8230a44 <t_setsockopt>
}
 8228330:	e037883a 	mov	sp,fp
 8228334:	dfc00117 	ldw	ra,4(sp)
 8228338:	df000017 	ldw	fp,0(sp)
 822833c:	dec00204 	addi	sp,sp,8
 8228340:	f800283a 	ret

08228344 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 8228344:	defffa04 	addi	sp,sp,-24
 8228348:	df000515 	stw	fp,20(sp)
 822834c:	df000504 	addi	fp,sp,20
 8228350:	e13ffe15 	stw	r4,-8(fp)
 8228354:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 8228358:	e0bffe17 	ldw	r2,-8(fp)
 822835c:	e0bffb15 	stw	r2,-20(fp)
   unsigned long sum = 0;
 8228360:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 8228364:	e0bfff17 	ldw	r2,-4(fp)
 8228368:	e0bffd15 	stw	r2,-12(fp)

   while (--count >= 0)
 822836c:	00000806 	br	8228390 <ccksum+0x4c>
   {
      /*  This is the inner loop */
      sum += *addr++;
 8228370:	e0bffb17 	ldw	r2,-20(fp)
 8228374:	10c00084 	addi	r3,r2,2
 8228378:	e0fffb15 	stw	r3,-20(fp)
 822837c:	1080000b 	ldhu	r2,0(r2)
 8228380:	10bfffcc 	andi	r2,r2,65535
 8228384:	e0fffc17 	ldw	r3,-16(fp)
 8228388:	1885883a 	add	r2,r3,r2
 822838c:	e0bffc15 	stw	r2,-16(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 8228390:	e0bffd17 	ldw	r2,-12(fp)
 8228394:	10bfffc4 	addi	r2,r2,-1
 8228398:	e0bffd15 	stw	r2,-12(fp)
 822839c:	e0bffd17 	ldw	r2,-12(fp)
 82283a0:	103ff30e 	bge	r2,zero,8228370 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 82283a4:	e0bffc17 	ldw	r2,-16(fp)
 82283a8:	10ffffcc 	andi	r3,r2,65535
 82283ac:	e0bffc17 	ldw	r2,-16(fp)
 82283b0:	1004d43a 	srli	r2,r2,16
 82283b4:	1885883a 	add	r2,r3,r2
 82283b8:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 82283bc:	e0bffc17 	ldw	r2,-16(fp)
 82283c0:	10ffffcc 	andi	r3,r2,65535
 82283c4:	e0bffc17 	ldw	r2,-16(fp)
 82283c8:	1004d43a 	srli	r2,r2,16
 82283cc:	1885883a 	add	r2,r3,r2
 82283d0:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 82283d4:	e0bffc17 	ldw	r2,-16(fp)
}
 82283d8:	e037883a 	mov	sp,fp
 82283dc:	df000017 	ldw	fp,0(sp)
 82283e0:	dec00104 	addi	sp,sp,4
 82283e4:	f800283a 	ret

082283e8 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 82283e8:	defffc04 	addi	sp,sp,-16
 82283ec:	dfc00315 	stw	ra,12(sp)
 82283f0:	df000215 	stw	fp,8(sp)
 82283f4:	df000204 	addi	fp,sp,8
 82283f8:	e13ffe15 	stw	r4,-8(fp)
 82283fc:	e17fff15 	stw	r5,-4(fp)
   switch (cksum_select)
 8228400:	d0a03117 	ldw	r2,-32572(gp)
 8228404:	108000a0 	cmpeqi	r2,r2,2
 8228408:	1000041e 	bne	r2,zero,822841c <cksum+0x34>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 822840c:	e17fff17 	ldw	r5,-4(fp)
 8228410:	e13ffe17 	ldw	r4,-8(fp)
 8228414:	82283440 	call	8228344 <ccksum>
 8228418:	00000306 	br	8228428 <cksum+0x40>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 822841c:	e17fff17 	ldw	r5,-4(fp)
 8228420:	e13ffe17 	ldw	r4,-8(fp)
 8228424:	822d0340 	call	822d034 <asm_cksum>
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 8228428:	e037883a 	mov	sp,fp
 822842c:	dfc00117 	ldw	ra,4(sp)
 8228430:	df000017 	ldw	fp,0(sp)
 8228434:	dec00204 	addi	sp,sp,8
 8228438:	f800283a 	ret

0822843c <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 822843c:	defffe04 	addi	sp,sp,-8
 8228440:	dfc00115 	stw	ra,4(sp)
 8228444:	df000015 	stw	fp,0(sp)
 8228448:	d839883a 	mov	fp,sp
   dtrap();
 822844c:	822d1c80 	call	822d1c8 <dtrap>
   return 0;
 8228450:	0005883a 	mov	r2,zero
}
 8228454:	e037883a 	mov	sp,fp
 8228458:	dfc00117 	ldw	ra,4(sp)
 822845c:	df000017 	ldw	fp,0(sp)
 8228460:	dec00204 	addi	sp,sp,8
 8228464:	f800283a 	ret

08228468 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 8228468:	defffe04 	addi	sp,sp,-8
 822846c:	df000115 	stw	fp,4(sp)
 8228470:	df000104 	addi	fp,sp,4
 8228474:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 8228478:	00000306 	br	8228488 <nextarg+0x20>
 822847c:	e0bfff17 	ldw	r2,-4(fp)
 8228480:	10800044 	addi	r2,r2,1
 8228484:	e0bfff15 	stw	r2,-4(fp)
 8228488:	e0bfff17 	ldw	r2,-4(fp)
 822848c:	10800003 	ldbu	r2,0(r2)
 8228490:	10803fcc 	andi	r2,r2,255
 8228494:	1080201c 	xori	r2,r2,128
 8228498:	10bfe004 	addi	r2,r2,-128
 822849c:	10800848 	cmpgei	r2,r2,33
 82284a0:	103ff61e 	bne	r2,zero,822847c <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 82284a4:	00000306 	br	82284b4 <nextarg+0x4c>
 82284a8:	e0bfff17 	ldw	r2,-4(fp)
 82284ac:	10800044 	addi	r2,r2,1
 82284b0:	e0bfff15 	stw	r2,-4(fp)
 82284b4:	e0bfff17 	ldw	r2,-4(fp)
 82284b8:	10800003 	ldbu	r2,0(r2)
 82284bc:	10803fcc 	andi	r2,r2,255
 82284c0:	1080201c 	xori	r2,r2,128
 82284c4:	10bfe004 	addi	r2,r2,-128
 82284c8:	10800820 	cmpeqi	r2,r2,32
 82284cc:	103ff61e 	bne	r2,zero,82284a8 <nextarg+0x40>
      return (argp);
 82284d0:	e0bfff17 	ldw	r2,-4(fp)
}
 82284d4:	e037883a 	mov	sp,fp
 82284d8:	df000017 	ldw	fp,0(sp)
 82284dc:	dec00104 	addi	sp,sp,4
 82284e0:	f800283a 	ret

082284e4 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 82284e4:	defff804 	addi	sp,sp,-32
 82284e8:	dfc00715 	stw	ra,28(sp)
 82284ec:	df000615 	stw	fp,24(sp)
 82284f0:	df000604 	addi	fp,sp,24
 82284f4:	e13ffd15 	stw	r4,-12(fp)
 82284f8:	e17ffe15 	stw	r5,-8(fp)
 82284fc:	e1bfff15 	stw	r6,-4(fp)
   u_char * data  =  (u_char *)buffer;
 8228500:	e0bffe17 	ldw	r2,-8(fp)
 8228504:	e0bffa15 	stw	r2,-24(fp)
   unsigned int count;
   char  c;

   while (len)
 8228508:	00003f06 	br	8228608 <hexdump+0x124>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 822850c:	e03ffb15 	stw	zero,-20(fp)
 8228510:	00000d06 	br	8228548 <hexdump+0x64>
         ns_printf(pio, "%02x ", *(data + count));
 8228514:	e0fffa17 	ldw	r3,-24(fp)
 8228518:	e0bffb17 	ldw	r2,-20(fp)
 822851c:	1885883a 	add	r2,r3,r2
 8228520:	10800003 	ldbu	r2,0(r2)
 8228524:	10803fcc 	andi	r2,r2,255
 8228528:	100d883a 	mov	r6,r2
 822852c:	01420974 	movhi	r5,2085
 8228530:	29400b04 	addi	r5,r5,44
 8228534:	e13ffd17 	ldw	r4,-12(fp)
 8228538:	8228a940 	call	8228a94 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 822853c:	e0bffb17 	ldw	r2,-20(fp)
 8228540:	10800044 	addi	r2,r2,1
 8228544:	e0bffb15 	stw	r2,-20(fp)
 8228548:	e0bffb17 	ldw	r2,-20(fp)
 822854c:	10800428 	cmpgeui	r2,r2,16
 8228550:	1000031e 	bne	r2,zero,8228560 <hexdump+0x7c>
 8228554:	e0fffb17 	ldw	r3,-20(fp)
 8228558:	e0bfff17 	ldw	r2,-4(fp)
 822855c:	18bfed36 	bltu	r3,r2,8228514 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228560:	e03ffb15 	stw	zero,-20(fp)
 8228564:	00001606 	br	82285c0 <hexdump+0xdc>
      {
         c = *(data + count);
 8228568:	e0fffa17 	ldw	r3,-24(fp)
 822856c:	e0bffb17 	ldw	r2,-20(fp)
 8228570:	1885883a 	add	r2,r3,r2
 8228574:	10800003 	ldbu	r2,0(r2)
 8228578:	e0bffc05 	stb	r2,-16(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 822857c:	e0bffc07 	ldb	r2,-16(fp)
 8228580:	10800810 	cmplti	r2,r2,32
 8228584:	1000051e 	bne	r2,zero,822859c <hexdump+0xb8>
 8228588:	e0bffc07 	ldb	r2,-16(fp)
 822858c:	10801fe0 	cmpeqi	r2,r2,127
 8228590:	1000021e 	bne	r2,zero,822859c <hexdump+0xb8>
 8228594:	e0bffc07 	ldb	r2,-16(fp)
 8228598:	00000106 	br	82285a0 <hexdump+0xbc>
 822859c:	00800b84 	movi	r2,46
 82285a0:	100d883a 	mov	r6,r2
 82285a4:	01420974 	movhi	r5,2085
 82285a8:	29400d04 	addi	r5,r5,52
 82285ac:	e13ffd17 	ldw	r4,-12(fp)
 82285b0:	8228a940 	call	8228a94 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 82285b4:	e0bffb17 	ldw	r2,-20(fp)
 82285b8:	10800044 	addi	r2,r2,1
 82285bc:	e0bffb15 	stw	r2,-20(fp)
 82285c0:	e0bffb17 	ldw	r2,-20(fp)
 82285c4:	10800428 	cmpgeui	r2,r2,16
 82285c8:	1000031e 	bne	r2,zero,82285d8 <hexdump+0xf4>
 82285cc:	e0fffb17 	ldw	r3,-20(fp)
 82285d0:	e0bfff17 	ldw	r2,-4(fp)
 82285d4:	18bfe436 	bltu	r3,r2,8228568 <hexdump+0x84>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 82285d8:	01420974 	movhi	r5,2085
 82285dc:	29400e04 	addi	r5,r5,56
 82285e0:	e13ffd17 	ldw	r4,-12(fp)
 82285e4:	8228a940 	call	8228a94 <ns_printf>
      len -= count;
 82285e8:	e0ffff17 	ldw	r3,-4(fp)
 82285ec:	e0bffb17 	ldw	r2,-20(fp)
 82285f0:	1885c83a 	sub	r2,r3,r2
 82285f4:	e0bfff15 	stw	r2,-4(fp)
      data += count;
 82285f8:	e0fffa17 	ldw	r3,-24(fp)
 82285fc:	e0bffb17 	ldw	r2,-20(fp)
 8228600:	1885883a 	add	r2,r3,r2
 8228604:	e0bffa15 	stw	r2,-24(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 8228608:	e0bfff17 	ldw	r2,-4(fp)
 822860c:	103fbf1e 	bne	r2,zero,822850c <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 8228610:	0001883a 	nop
 8228614:	e037883a 	mov	sp,fp
 8228618:	dfc00117 	ldw	ra,4(sp)
 822861c:	df000017 	ldw	fp,0(sp)
 8228620:	dec00204 	addi	sp,sp,8
 8228624:	f800283a 	ret

08228628 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 8228628:	defffa04 	addi	sp,sp,-24
 822862c:	dfc00515 	stw	ra,20(sp)
 8228630:	df000415 	stw	fp,16(sp)
 8228634:	df000404 	addi	fp,sp,16
 8228638:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 822863c:	e0bfff17 	ldw	r2,-4(fp)
 8228640:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
    ip.ip.ipchar[0],
 8228644:	e0bffe03 	ldbu	r2,-8(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228648:	11003fcc 	andi	r4,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
 822864c:	e0bffe43 	ldbu	r2,-7(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228650:	11403fcc 	andi	r5,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
 8228654:	e0bffe83 	ldbu	r2,-6(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228658:	10803fcc 	andi	r2,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);
 822865c:	e0fffec3 	ldbu	r3,-5(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228660:	18c03fcc 	andi	r3,r3,255
 8228664:	d8c00115 	stw	r3,4(sp)
 8228668:	d8800015 	stw	r2,0(sp)
 822866c:	280f883a 	mov	r7,r5
 8228670:	200d883a 	mov	r6,r4
 8228674:	01420974 	movhi	r5,2085
 8228678:	29400f04 	addi	r5,r5,60
 822867c:	010209b4 	movhi	r4,2086
 8228680:	2136d384 	addi	r4,r4,-9394
 8228684:	82032140 	call	8203214 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 8228688:	008209b4 	movhi	r2,2086
 822868c:	10b6d384 	addi	r2,r2,-9394
}
 8228690:	e037883a 	mov	sp,fp
 8228694:	dfc00117 	ldw	ra,4(sp)
 8228698:	df000017 	ldw	fp,0(sp)
 822869c:	dec00204 	addi	sp,sp,8
 82286a0:	f800283a 	ret

082286a4 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 82286a4:	defff004 	addi	sp,sp,-64
 82286a8:	dfc00f15 	stw	ra,60(sp)
 82286ac:	df000e15 	stw	fp,56(sp)
 82286b0:	ddc00d15 	stw	r23,52(sp)
 82286b4:	dd800c15 	stw	r22,48(sp)
 82286b8:	dd400b15 	stw	r21,44(sp)
 82286bc:	dd000a15 	stw	r20,40(sp)
 82286c0:	dcc00915 	stw	r19,36(sp)
 82286c4:	dc800815 	stw	r18,32(sp)
 82286c8:	dc400715 	stw	r17,28(sp)
 82286cc:	dc000615 	stw	r16,24(sp)
 82286d0:	df000e04 	addi	fp,sp,56
 82286d4:	e13ff715 	stw	r4,-36(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 82286d8:	e0fff717 	ldw	r3,-36(fp)
 82286dc:	00947b34 	movhi	r2,20972
 82286e0:	10a147c4 	addi	r2,r2,-31457
 82286e4:	1888383a 	mulxuu	r4,r3,r2
 82286e8:	1885383a 	mul	r2,r3,r2
 82286ec:	100b883a 	mov	r5,r2
 82286f0:	200d883a 	mov	r6,r4
 82286f4:	3004d17a 	srli	r2,r6,5
 82286f8:	e0bff715 	stw	r2,-36(fp)
   seconds = (unsigned)(timetick%60);
 82286fc:	e0bff717 	ldw	r2,-36(fp)
 8228700:	01400f04 	movi	r5,60
 8228704:	1009883a 	mov	r4,r2
 8228708:	82027700 	call	8202770 <__umodsi3>
 822870c:	e0bff415 	stw	r2,-48(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 8228710:	e0fff717 	ldw	r3,-36(fp)
 8228714:	00a22274 	movhi	r2,34953
 8228718:	10a22244 	addi	r2,r2,-30583
 822871c:	1888383a 	mulxuu	r4,r3,r2
 8228720:	1885383a 	mul	r2,r3,r2
 8228724:	102d883a 	mov	r22,r2
 8228728:	202f883a 	mov	r23,r4
 822872c:	b804d17a 	srli	r2,r23,5
 8228730:	e0bff715 	stw	r2,-36(fp)
   minutes = (unsigned)(timetick%60);
 8228734:	e0fff717 	ldw	r3,-36(fp)
 8228738:	00a22274 	movhi	r2,34953
 822873c:	10a22244 	addi	r2,r2,-30583
 8228740:	1888383a 	mulxuu	r4,r3,r2
 8228744:	1885383a 	mul	r2,r3,r2
 8228748:	1029883a 	mov	r20,r2
 822874c:	202b883a 	mov	r21,r4
 8228750:	a804d17a 	srli	r2,r21,5
 8228754:	10800f24 	muli	r2,r2,60
 8228758:	1885c83a 	sub	r2,r3,r2
 822875c:	e0bff515 	stw	r2,-44(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 8228760:	e0fff717 	ldw	r3,-36(fp)
 8228764:	00a22274 	movhi	r2,34953
 8228768:	10a22244 	addi	r2,r2,-30583
 822876c:	1888383a 	mulxuu	r4,r3,r2
 8228770:	1885383a 	mul	r2,r3,r2
 8228774:	1025883a 	mov	r18,r2
 8228778:	2027883a 	mov	r19,r4
 822877c:	9804d17a 	srli	r2,r19,5
 8228780:	e0bff715 	stw	r2,-36(fp)
   hours = (unsigned)(timetick%24);
 8228784:	e0bff717 	ldw	r2,-36(fp)
 8228788:	01400604 	movi	r5,24
 822878c:	1009883a 	mov	r4,r2
 8228790:	82027700 	call	8202770 <__umodsi3>
 8228794:	e0bff615 	stw	r2,-40(fp)
   timetick = timetick/24;    /* turn timetick into days */
 8228798:	e0fff717 	ldw	r3,-36(fp)
 822879c:	00aaaaf4 	movhi	r2,43691
 82287a0:	10aaaac4 	addi	r2,r2,-21845
 82287a4:	1888383a 	mulxuu	r4,r3,r2
 82287a8:	1885383a 	mul	r2,r3,r2
 82287ac:	1021883a 	mov	r16,r2
 82287b0:	2023883a 	mov	r17,r4
 82287b4:	8804d13a 	srli	r2,r17,4
 82287b8:	e0bff715 	stw	r2,-36(fp)

   if (timetick)  /* Is there a whole number of days? */
 82287bc:	e0bff717 	ldw	r2,-36(fp)
 82287c0:	10000c26 	beq	r2,zero,82287f4 <print_uptime+0x150>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 82287c4:	e0bff417 	ldw	r2,-48(fp)
 82287c8:	d8800115 	stw	r2,4(sp)
 82287cc:	e0bff517 	ldw	r2,-44(fp)
 82287d0:	d8800015 	stw	r2,0(sp)
 82287d4:	e1fff617 	ldw	r7,-40(fp)
 82287d8:	e1bff717 	ldw	r6,-36(fp)
 82287dc:	01420974 	movhi	r5,2085
 82287e0:	29401204 	addi	r5,r5,72
 82287e4:	01020974 	movhi	r4,2085
 82287e8:	2110a004 	addi	r4,r4,17024
 82287ec:	82032140 	call	8203214 <sprintf>
 82287f0:	00001306 	br	8228840 <print_uptime+0x19c>
    timetick, hours, minutes, seconds);
   else if (hours)
 82287f4:	e0bff617 	ldw	r2,-40(fp)
 82287f8:	10000a26 	beq	r2,zero,8228824 <print_uptime+0x180>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 82287fc:	e0bff417 	ldw	r2,-48(fp)
 8228800:	d8800015 	stw	r2,0(sp)
 8228804:	e1fff517 	ldw	r7,-44(fp)
 8228808:	e1bff617 	ldw	r6,-40(fp)
 822880c:	01420974 	movhi	r5,2085
 8228810:	29401804 	addi	r5,r5,96
 8228814:	01020974 	movhi	r4,2085
 8228818:	2110a004 	addi	r4,r4,17024
 822881c:	82032140 	call	8203214 <sprintf>
 8228820:	00000706 	br	8228840 <print_uptime+0x19c>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 8228824:	e1fff417 	ldw	r7,-48(fp)
 8228828:	e1bff517 	ldw	r6,-44(fp)
 822882c:	01420974 	movhi	r5,2085
 8228830:	29401d04 	addi	r5,r5,116
 8228834:	01020974 	movhi	r4,2085
 8228838:	2110a004 	addi	r4,r4,17024
 822883c:	82032140 	call	8203214 <sprintf>
   return tistring;
 8228840:	00820974 	movhi	r2,2085
 8228844:	1090a004 	addi	r2,r2,17024
}
 8228848:	e6fff804 	addi	sp,fp,-32
 822884c:	dfc00917 	ldw	ra,36(sp)
 8228850:	df000817 	ldw	fp,32(sp)
 8228854:	ddc00717 	ldw	r23,28(sp)
 8228858:	dd800617 	ldw	r22,24(sp)
 822885c:	dd400517 	ldw	r21,20(sp)
 8228860:	dd000417 	ldw	r20,16(sp)
 8228864:	dcc00317 	ldw	r19,12(sp)
 8228868:	dc800217 	ldw	r18,8(sp)
 822886c:	dc400117 	ldw	r17,4(sp)
 8228870:	dc000017 	ldw	r16,0(sp)
 8228874:	dec00a04 	addi	sp,sp,40
 8228878:	f800283a 	ret

0822887c <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 822887c:	defffd04 	addi	sp,sp,-12
 8228880:	dfc00215 	stw	ra,8(sp)
 8228884:	df000115 	stw	fp,4(sp)
 8228888:	df000104 	addi	fp,sp,4
 822888c:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 8228890:	e17fff17 	ldw	r5,-4(fp)
 8228894:	01020974 	movhi	r4,2085
 8228898:	21002204 	addi	r4,r4,136
 822889c:	8202e9c0 	call	8202e9c <printf>
   dtrap();                   /* try to hook debugger */
 82288a0:	822d1c80 	call	822d1c8 <dtrap>
   netexit(1);                /* try to clean up */
 82288a4:	01000044 	movi	r4,1
 82288a8:	82438e00 	call	82438e0 <netexit>
}
 82288ac:	0001883a 	nop
 82288b0:	e037883a 	mov	sp,fp
 82288b4:	dfc00117 	ldw	ra,4(sp)
 82288b8:	df000017 	ldw	fp,0(sp)
 82288bc:	dec00204 	addi	sp,sp,8
 82288c0:	f800283a 	ret

082288c4 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 82288c4:	defffb04 	addi	sp,sp,-20
 82288c8:	df000415 	stw	fp,16(sp)
 82288cc:	df000404 	addi	fp,sp,16
 82288d0:	e13ffe15 	stw	r4,-8(fp)
 82288d4:	2805883a 	mov	r2,r5
 82288d8:	e0bfff05 	stb	r2,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 82288dc:	008209b4 	movhi	r2,2086
 82288e0:	10b6cf04 	addi	r2,r2,-9412
 82288e4:	e0bffd15 	stw	r2,-12(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 82288e8:	e03ffc15 	stw	zero,-16(fp)
 82288ec:	00003f06 	br	82289ec <print_eth+0x128>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 82288f0:	e0bffe17 	ldw	r2,-8(fp)
 82288f4:	10800003 	ldbu	r2,0(r2)
 82288f8:	10803fcc 	andi	r2,r2,255
 82288fc:	1004d13a 	srli	r2,r2,4
 8228900:	10800c04 	addi	r2,r2,48
 8228904:	1007883a 	mov	r3,r2
 8228908:	e0bffd17 	ldw	r2,-12(fp)
 822890c:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228910:	e0bffd17 	ldw	r2,-12(fp)
 8228914:	10800003 	ldbu	r2,0(r2)
 8228918:	10803fcc 	andi	r2,r2,255
 822891c:	1080201c 	xori	r2,r2,128
 8228920:	10bfe004 	addi	r2,r2,-128
 8228924:	10800e90 	cmplti	r2,r2,58
 8228928:	1000061e 	bne	r2,zero,8228944 <print_eth+0x80>
         (*out) += 7;
 822892c:	e0bffd17 	ldw	r2,-12(fp)
 8228930:	10800003 	ldbu	r2,0(r2)
 8228934:	108001c4 	addi	r2,r2,7
 8228938:	1007883a 	mov	r3,r2
 822893c:	e0bffd17 	ldw	r2,-12(fp)
 8228940:	10c00005 	stb	r3,0(r2)
      out++;
 8228944:	e0bffd17 	ldw	r2,-12(fp)
 8228948:	10800044 	addi	r2,r2,1
 822894c:	e0bffd15 	stw	r2,-12(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 8228950:	e0bffe17 	ldw	r2,-8(fp)
 8228954:	10800003 	ldbu	r2,0(r2)
 8228958:	108003cc 	andi	r2,r2,15
 822895c:	10800c04 	addi	r2,r2,48
 8228960:	1007883a 	mov	r3,r2
 8228964:	e0bffd17 	ldw	r2,-12(fp)
 8228968:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 822896c:	e0bffd17 	ldw	r2,-12(fp)
 8228970:	10800003 	ldbu	r2,0(r2)
 8228974:	10803fcc 	andi	r2,r2,255
 8228978:	1080201c 	xori	r2,r2,128
 822897c:	10bfe004 	addi	r2,r2,-128
 8228980:	10800e90 	cmplti	r2,r2,58
 8228984:	1000061e 	bne	r2,zero,82289a0 <print_eth+0xdc>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 8228988:	e0bffd17 	ldw	r2,-12(fp)
 822898c:	10800003 	ldbu	r2,0(r2)
 8228990:	108001c4 	addi	r2,r2,7
 8228994:	1007883a 	mov	r3,r2
 8228998:	e0bffd17 	ldw	r2,-12(fp)
 822899c:	10c00005 	stb	r3,0(r2)
      out++;
 82289a0:	e0bffd17 	ldw	r2,-12(fp)
 82289a4:	10800044 	addi	r2,r2,1
 82289a8:	e0bffd15 	stw	r2,-12(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 82289ac:	e0bfff07 	ldb	r2,-4(fp)
 82289b0:	10000826 	beq	r2,zero,82289d4 <print_eth+0x110>
 82289b4:	e0bffc17 	ldw	r2,-16(fp)
 82289b8:	10800148 	cmpgei	r2,r2,5
 82289bc:	1000051e 	bne	r2,zero,82289d4 <print_eth+0x110>
         *out++ = spacer;
 82289c0:	e0bffd17 	ldw	r2,-12(fp)
 82289c4:	10c00044 	addi	r3,r2,1
 82289c8:	e0fffd15 	stw	r3,-12(fp)
 82289cc:	e0ffff03 	ldbu	r3,-4(fp)
 82289d0:	10c00005 	stb	r3,0(r2)
      addr++;
 82289d4:	e0bffe17 	ldw	r2,-8(fp)
 82289d8:	10800044 	addi	r2,r2,1
 82289dc:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 82289e0:	e0bffc17 	ldw	r2,-16(fp)
 82289e4:	10800044 	addi	r2,r2,1
 82289e8:	e0bffc15 	stw	r2,-16(fp)
 82289ec:	e0bffc17 	ldw	r2,-16(fp)
 82289f0:	10800190 	cmplti	r2,r2,6
 82289f4:	103fbe1e 	bne	r2,zero,82288f0 <print_eth+0x2c>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 82289f8:	e0bffd17 	ldw	r2,-12(fp)
 82289fc:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 8228a00:	008209b4 	movhi	r2,2086
 8228a04:	10b6cf04 	addi	r2,r2,-9412
}
 8228a08:	e037883a 	mov	sp,fp
 8228a0c:	df000017 	ldw	fp,0(sp)
 8228a10:	dec00104 	addi	sp,sp,4
 8228a14:	f800283a 	ret

08228a18 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 8228a18:	defffd04 	addi	sp,sp,-12
 8228a1c:	df000215 	stw	fp,8(sp)
 8228a20:	df000204 	addi	fp,sp,8
 8228a24:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 8228a28:	e0bfff17 	ldw	r2,-4(fp)
 8228a2c:	e0bffe15 	stw	r2,-8(fp)
 8228a30:	00000d06 	br	8228a68 <uslash+0x50>
      if (*cp == '\\')
 8228a34:	e0bffe17 	ldw	r2,-8(fp)
 8228a38:	10800003 	ldbu	r2,0(r2)
 8228a3c:	10803fcc 	andi	r2,r2,255
 8228a40:	1080201c 	xori	r2,r2,128
 8228a44:	10bfe004 	addi	r2,r2,-128
 8228a48:	10801718 	cmpnei	r2,r2,92
 8228a4c:	1000031e 	bne	r2,zero,8228a5c <uslash+0x44>
      *cp = '/';
 8228a50:	e0bffe17 	ldw	r2,-8(fp)
 8228a54:	00c00bc4 	movi	r3,47
 8228a58:	10c00005 	stb	r3,0(r2)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 8228a5c:	e0bffe17 	ldw	r2,-8(fp)
 8228a60:	10800044 	addi	r2,r2,1
 8228a64:	e0bffe15 	stw	r2,-8(fp)
 8228a68:	e0bffe17 	ldw	r2,-8(fp)
 8228a6c:	10800003 	ldbu	r2,0(r2)
 8228a70:	10803fcc 	andi	r2,r2,255
 8228a74:	1080201c 	xori	r2,r2,128
 8228a78:	10bfe004 	addi	r2,r2,-128
 8228a7c:	103fed1e 	bne	r2,zero,8228a34 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 8228a80:	e0bfff17 	ldw	r2,-4(fp)
}
 8228a84:	e037883a 	mov	sp,fp
 8228a88:	df000017 	ldw	fp,0(sp)
 8228a8c:	dec00104 	addi	sp,sp,4
 8228a90:	f800283a 	ret

08228a94 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 8228a94:	defff304 	addi	sp,sp,-52
 8228a98:	dfc00a15 	stw	ra,40(sp)
 8228a9c:	df000915 	stw	fp,36(sp)
 8228aa0:	dc400815 	stw	r17,32(sp)
 8228aa4:	dc000715 	stw	r16,28(sp)
 8228aa8:	df000904 	addi	fp,sp,36
 8228aac:	e13ffc15 	stw	r4,-16(fp)
 8228ab0:	e17ffd15 	stw	r5,-12(fp)
 8228ab4:	e1800215 	stw	r6,8(fp)
 8228ab8:	e1c00315 	stw	r7,12(fp)
   char *   outbuf=NULL;
 8228abc:	e03ff815 	stw	zero,-32(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 8228ac0:	00802704 	movi	r2,156
 8228ac4:	e0bff715 	stw	r2,-36(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228ac8:	e0bffc17 	ldw	r2,-16(fp)
 8228acc:	e0bff915 	stw	r2,-28(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 8228ad0:	e0bff917 	ldw	r2,-28(fp)
 8228ad4:	1000091e 	bne	r2,zero,8228afc <ns_printf+0x68>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 8228ad8:	e0800204 	addi	r2,fp,8
 8228adc:	e0bffb15 	stw	r2,-20(fp)
      ret_value = vprintf(format,argList);
 8228ae0:	e0bffb17 	ldw	r2,-20(fp)
 8228ae4:	100b883a 	mov	r5,r2
 8228ae8:	e13ffd17 	ldw	r4,-12(fp)
 8228aec:	824b6540 	call	824b654 <vprintf>
 8228af0:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 8228af4:	e0bffa17 	ldw	r2,-24(fp)
 8228af8:	00003b06 	br	8228be8 <ns_printf+0x154>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 8228afc:	e0bff917 	ldw	r2,-28(fp)
 8228b00:	10800117 	ldw	r2,4(r2)
 8228b04:	1000021e 	bne	r2,zero,8228b10 <ns_printf+0x7c>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 8228b08:	00bfffc4 	movi	r2,-1
 8228b0c:	00003606 	br	8228be8 <ns_printf+0x154>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 8228b10:	e13ffd17 	ldw	r4,-12(fp)
 8228b14:	8203a5c0 	call	8203a5c <strlen>
 8228b18:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 8228b1c:	e0bffa17 	ldw	r2,-24(fp)
 8228b20:	10802710 	cmplti	r2,r2,156
 8228b24:	1000041e 	bne	r2,zero,8228b38 <ns_printf+0xa4>
   {
      buf_size += ret_value ;
 8228b28:	e0fff717 	ldw	r3,-36(fp)
 8228b2c:	e0bffa17 	ldw	r2,-24(fp)
 8228b30:	1885883a 	add	r2,r3,r2
 8228b34:	e0bff715 	stw	r2,-36(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 8228b38:	e0bff717 	ldw	r2,-36(fp)
 8228b3c:	1009883a 	mov	r4,r2
 8228b40:	822dda00 	call	822dda0 <npalloc>
 8228b44:	e0bff815 	stw	r2,-32(fp)

   if (outbuf == NULL)
 8228b48:	e0bff817 	ldw	r2,-32(fp)
 8228b4c:	1000021e 	bne	r2,zero,8228b58 <ns_printf+0xc4>
   {
      return -2;
 8228b50:	00bfff84 	movi	r2,-2
 8228b54:	00002406 	br	8228be8 <ns_printf+0x154>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 8228b58:	e0800204 	addi	r2,fp,8
 8228b5c:	e0bffb15 	stw	r2,-20(fp)
   ret_value = vsprintf(outbuf,format,argList);
 8228b60:	e0bffb17 	ldw	r2,-20(fp)
 8228b64:	100d883a 	mov	r6,r2
 8228b68:	e17ffd17 	ldw	r5,-12(fp)
 8228b6c:	e13ff817 	ldw	r4,-32(fp)
 8228b70:	824b6d00 	call	824b6d0 <vsprintf>
 8228b74:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 8228b78:	e13ff817 	ldw	r4,-32(fp)
 8228b7c:	8203a5c0 	call	8203a5c <strlen>
 8228b80:	1007883a 	mov	r3,r2
 8228b84:	e0bff717 	ldw	r2,-36(fp)
 8228b88:	10c0080e 	bge	r2,r3,8228bac <ns_printf+0x118>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 8228b8c:	01020974 	movhi	r4,2085
 8228b90:	21002504 	addi	r4,r4,148
 8228b94:	822887c0 	call	822887c <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 8228b98:	e0bff717 	ldw	r2,-36(fp)
 8228b9c:	10bfffc4 	addi	r2,r2,-1
 8228ba0:	e0fff817 	ldw	r3,-32(fp)
 8228ba4:	1885883a 	add	r2,r3,r2
 8228ba8:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 8228bac:	e0bff917 	ldw	r2,-28(fp)
 8228bb0:	14000117 	ldw	r16,4(r2)
 8228bb4:	e0bff917 	ldw	r2,-28(fp)
 8228bb8:	14400217 	ldw	r17,8(r2)
 8228bbc:	e13ff817 	ldw	r4,-32(fp)
 8228bc0:	8203a5c0 	call	8203a5c <strlen>
 8228bc4:	100d883a 	mov	r6,r2
 8228bc8:	e17ff817 	ldw	r5,-32(fp)
 8228bcc:	8809883a 	mov	r4,r17
 8228bd0:	803ee83a 	callr	r16
 8228bd4:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 8228bd8:	e13ff817 	ldw	r4,-32(fp)
 8228bdc:	822ddd40 	call	822ddd4 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 8228be0:	82294400 	call	8229440 <tk_yield>

   return ret_value ;
 8228be4:	e0bffa17 	ldw	r2,-24(fp)
}
 8228be8:	e6fffe04 	addi	sp,fp,-8
 8228bec:	dfc00317 	ldw	ra,12(sp)
 8228bf0:	df000217 	ldw	fp,8(sp)
 8228bf4:	dc400117 	ldw	r17,4(sp)
 8228bf8:	dc000017 	ldw	r16,0(sp)
 8228bfc:	dec00604 	addi	sp,sp,24
 8228c00:	f800283a 	ret

08228c04 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 8228c04:	defffb04 	addi	sp,sp,-20
 8228c08:	dfc00415 	stw	ra,16(sp)
 8228c0c:	df000315 	stw	fp,12(sp)
 8228c10:	df000304 	addi	fp,sp,12
 8228c14:	e13ffd15 	stw	r4,-12(fp)
 8228c18:	e17ffe15 	stw	r5,-8(fp)
 8228c1c:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 8228c20:	e17ffe17 	ldw	r5,-8(fp)
 8228c24:	01020974 	movhi	r4,2085
 8228c28:	21002c04 	addi	r4,r4,176
 8228c2c:	8202e9c0 	call	8202e9c <printf>
   USE_ARG(s);
   return len;
 8228c30:	e0bfff17 	ldw	r2,-4(fp)
}
 8228c34:	e037883a 	mov	sp,fp
 8228c38:	dfc00117 	ldw	ra,4(sp)
 8228c3c:	df000017 	ldw	fp,0(sp)
 8228c40:	dec00204 	addi	sp,sp,8
 8228c44:	f800283a 	ret

08228c48 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 8228c48:	defffa04 	addi	sp,sp,-24
 8228c4c:	dfc00515 	stw	ra,20(sp)
 8228c50:	df000415 	stw	fp,16(sp)
 8228c54:	df000404 	addi	fp,sp,16
 8228c58:	e13ffe15 	stw	r4,-8(fp)
 8228c5c:	e17fff15 	stw	r5,-4(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228c60:	e0bffe17 	ldw	r2,-8(fp)
 8228c64:	e0bffc15 	stw	r2,-16(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 8228c68:	e0bfff17 	ldw	r2,-4(fp)
 8228c6c:	01400504 	movi	r5,20
 8228c70:	1009883a 	mov	r4,r2
 8228c74:	82026980 	call	8202698 <__modsi3>
 8228c78:	1000231e 	bne	r2,zero,8228d08 <con_page+0xc0>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 8228c7c:	e0bffc17 	ldw	r2,-16(fp)
 8228c80:	10002126 	beq	r2,zero,8228d08 <con_page+0xc0>
 8228c84:	e0bffc17 	ldw	r2,-16(fp)
 8228c88:	10800317 	ldw	r2,12(r2)
 8228c8c:	10001e26 	beq	r2,zero,8228d08 <con_page+0xc0>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 8228c90:	01420974 	movhi	r5,2085
 8228c94:	29402d04 	addi	r5,r5,180
 8228c98:	e13ffc17 	ldw	r4,-16(fp)
 8228c9c:	8228a940 	call	8228a94 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 8228ca0:	e0bffc17 	ldw	r2,-16(fp)
 8228ca4:	10800317 	ldw	r2,12(r2)
 8228ca8:	e0fffc17 	ldw	r3,-16(fp)
 8228cac:	18c00217 	ldw	r3,8(r3)
 8228cb0:	1809883a 	mov	r4,r3
 8228cb4:	103ee83a 	callr	r2
 8228cb8:	e0bffd15 	stw	r2,-12(fp)
            if (ch == 0)
 8228cbc:	e0bffd17 	ldw	r2,-12(fp)
 8228cc0:	1000011e 	bne	r2,zero,8228cc8 <con_page+0x80>
               tk_yield();    /* Give timeslice to other processes */
 8228cc4:	82294400 	call	8229440 <tk_yield>
         } while (ch == 0) ;
 8228cc8:	e0bffd17 	ldw	r2,-12(fp)
 8228ccc:	103ff426 	beq	r2,zero,8228ca0 <con_page+0x58>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 8228cd0:	e0bffd17 	ldw	r2,-12(fp)
 8228cd4:	10bfffd8 	cmpnei	r2,r2,-1
 8228cd8:	1000021e 	bne	r2,zero,8228ce4 <con_page+0x9c>
            return 1 ;
 8228cdc:	00800044 	movi	r2,1
 8228ce0:	00000a06 	br	8228d0c <con_page+0xc4>

         ns_printf(pio,"\n");
 8228ce4:	01420974 	movhi	r5,2085
 8228ce8:	29400e04 	addi	r5,r5,56
 8228cec:	e13ffc17 	ldw	r4,-16(fp)
 8228cf0:	8228a940 	call	8228a94 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 8228cf4:	e0bffd17 	ldw	r2,-12(fp)
 8228cf8:	108006d8 	cmpnei	r2,r2,27
 8228cfc:	1000021e 	bne	r2,zero,8228d08 <con_page+0xc0>
            return 1 ;
 8228d00:	00800044 	movi	r2,1
 8228d04:	00000106 	br	8228d0c <con_page+0xc4>
      }
   }
   return  0;
 8228d08:	0005883a 	mov	r2,zero
}
 8228d0c:	e037883a 	mov	sp,fp
 8228d10:	dfc00117 	ldw	ra,4(sp)
 8228d14:	df000017 	ldw	fp,0(sp)
 8228d18:	dec00204 	addi	sp,sp,8
 8228d1c:	f800283a 	ret

08228d20 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 8228d20:	defff704 	addi	sp,sp,-36
 8228d24:	dfc00815 	stw	ra,32(sp)
 8228d28:	df000715 	stw	fp,28(sp)
 8228d2c:	df000704 	addi	fp,sp,28
 8228d30:	e13ffd15 	stw	r4,-12(fp)
 8228d34:	e17ffe15 	stw	r5,-8(fp)
 8228d38:	e1bfff15 	stw	r6,-4(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 8228d3c:	e0bffd17 	ldw	r2,-12(fp)
 8228d40:	e0bffa15 	stw	r2,-24(fp)
   char **pargv = NULL;
 8228d44:	e03ffb15 	stw	zero,-20(fp)
   *pargc_index = 0;
 8228d48:	e0bfff17 	ldw	r2,-4(fp)
 8228d4c:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 8228d50:	e0bffd17 	ldw	r2,-12(fp)
 8228d54:	1000021e 	bne	r2,zero,8228d60 <parse_args+0x40>
   {
      return (NULL);
 8228d58:	0005883a 	mov	r2,zero
 8228d5c:	00006c06 	br	8228f10 <parse_args+0x1f0>
   }
   len = strlen(buf);
 8228d60:	e13ffd17 	ldw	r4,-12(fp)
 8228d64:	8203a5c0 	call	8203a5c <strlen>
 8228d68:	e0bffc15 	stw	r2,-16(fp)
   if (len <= 0)
 8228d6c:	e0bffc17 	ldw	r2,-16(fp)
 8228d70:	00800216 	blt	zero,r2,8228d7c <parse_args+0x5c>
   {
      return (NULL);
 8228d74:	0005883a 	mov	r2,zero
 8228d78:	00006506 	br	8228f10 <parse_args+0x1f0>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 8228d7c:	e0bffe17 	ldw	r2,-8(fp)
 8228d80:	1085883a 	add	r2,r2,r2
 8228d84:	1085883a 	add	r2,r2,r2
 8228d88:	1009883a 	mov	r4,r2
 8228d8c:	822dda00 	call	822dda0 <npalloc>
 8228d90:	e0bffb15 	stw	r2,-20(fp)
   if (pargv == NULL)
 8228d94:	e0bffb17 	ldw	r2,-20(fp)
 8228d98:	1000051e 	bne	r2,zero,8228db0 <parse_args+0x90>
   {
      return (NULL);
 8228d9c:	0005883a 	mov	r2,zero
 8228da0:	00005b06 	br	8228f10 <parse_args+0x1f0>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 8228da4:	e0bffa17 	ldw	r2,-24(fp)
 8228da8:	10800044 	addi	r2,r2,1
 8228dac:	e0bffa15 	stw	r2,-24(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 8228db0:	e0bffa17 	ldw	r2,-24(fp)
 8228db4:	10800003 	ldbu	r2,0(r2)
 8228db8:	10803fcc 	andi	r2,r2,255
 8228dbc:	1080201c 	xori	r2,r2,128
 8228dc0:	10bfe004 	addi	r2,r2,-128
 8228dc4:	10800820 	cmpeqi	r2,r2,32
 8228dc8:	103ff61e 	bne	r2,zero,8228da4 <parse_args+0x84>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 8228dcc:	00003006 	br	8228e90 <parse_args+0x170>
   {
      pargv[(*pargc_index)] = bp;
 8228dd0:	e0bfff17 	ldw	r2,-4(fp)
 8228dd4:	10800017 	ldw	r2,0(r2)
 8228dd8:	1085883a 	add	r2,r2,r2
 8228ddc:	1085883a 	add	r2,r2,r2
 8228de0:	1007883a 	mov	r3,r2
 8228de4:	e0bffb17 	ldw	r2,-20(fp)
 8228de8:	10c5883a 	add	r2,r2,r3
 8228dec:	e0fffa17 	ldw	r3,-24(fp)
 8228df0:	10c00015 	stw	r3,0(r2)
      (*pargc_index)++;
 8228df4:	e0bfff17 	ldw	r2,-4(fp)
 8228df8:	10800017 	ldw	r2,0(r2)
 8228dfc:	10c00044 	addi	r3,r2,1
 8228e00:	e0bfff17 	ldw	r2,-4(fp)
 8228e04:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 8228e08:	00000306 	br	8228e18 <parse_args+0xf8>
      {
         bp++; 
 8228e0c:	e0bffa17 	ldw	r2,-24(fp)
 8228e10:	10800044 	addi	r2,r2,1
 8228e14:	e0bffa15 	stw	r2,-24(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 8228e18:	e0bffa17 	ldw	r2,-24(fp)
 8228e1c:	10800003 	ldbu	r2,0(r2)
 8228e20:	10803fcc 	andi	r2,r2,255
 8228e24:	1080201c 	xori	r2,r2,128
 8228e28:	10bfe004 	addi	r2,r2,-128
 8228e2c:	10800820 	cmpeqi	r2,r2,32
 8228e30:	10000a1e 	bne	r2,zero,8228e5c <parse_args+0x13c>
 8228e34:	e0bffa17 	ldw	r2,-24(fp)
 8228e38:	10800003 	ldbu	r2,0(r2)
 8228e3c:	10803fcc 	andi	r2,r2,255
 8228e40:	1080201c 	xori	r2,r2,128
 8228e44:	10bfe004 	addi	r2,r2,-128
 8228e48:	103ff01e 	bne	r2,zero,8228e0c <parse_args+0xec>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8228e4c:	00000306 	br	8228e5c <parse_args+0x13c>
      {
         bp++; 
 8228e50:	e0bffa17 	ldw	r2,-24(fp)
 8228e54:	10800044 	addi	r2,r2,1
 8228e58:	e0bffa15 	stw	r2,-24(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8228e5c:	e0bffa17 	ldw	r2,-24(fp)
 8228e60:	10800003 	ldbu	r2,0(r2)
 8228e64:	10803fcc 	andi	r2,r2,255
 8228e68:	1080201c 	xori	r2,r2,128
 8228e6c:	10bfe004 	addi	r2,r2,-128
 8228e70:	10800818 	cmpnei	r2,r2,32
 8228e74:	1000061e 	bne	r2,zero,8228e90 <parse_args+0x170>
 8228e78:	e0bffa17 	ldw	r2,-24(fp)
 8228e7c:	10800003 	ldbu	r2,0(r2)
 8228e80:	10803fcc 	andi	r2,r2,255
 8228e84:	1080201c 	xori	r2,r2,128
 8228e88:	10bfe004 	addi	r2,r2,-128
 8228e8c:	103ff01e 	bne	r2,zero,8228e50 <parse_args+0x130>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 8228e90:	e0bffa17 	ldw	r2,-24(fp)
 8228e94:	10800003 	ldbu	r2,0(r2)
 8228e98:	10803fcc 	andi	r2,r2,255
 8228e9c:	1080201c 	xori	r2,r2,128
 8228ea0:	10bfe004 	addi	r2,r2,-128
 8228ea4:	10000426 	beq	r2,zero,8228eb8 <parse_args+0x198>
 8228ea8:	e0bfff17 	ldw	r2,-4(fp)
 8228eac:	10c00017 	ldw	r3,0(r2)
 8228eb0:	e0bffe17 	ldw	r2,-8(fp)
 8228eb4:	18bfc616 	blt	r3,r2,8228dd0 <parse_args+0xb0>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 8228eb8:	e03ff915 	stw	zero,-28(fp)
 8228ebc:	00001006 	br	8228f00 <parse_args+0x1e0>
   {
      if (buf[i] == ' ')
 8228ec0:	e0bff917 	ldw	r2,-28(fp)
 8228ec4:	e0fffd17 	ldw	r3,-12(fp)
 8228ec8:	1885883a 	add	r2,r3,r2
 8228ecc:	10800003 	ldbu	r2,0(r2)
 8228ed0:	10803fcc 	andi	r2,r2,255
 8228ed4:	1080201c 	xori	r2,r2,128
 8228ed8:	10bfe004 	addi	r2,r2,-128
 8228edc:	10800818 	cmpnei	r2,r2,32
 8228ee0:	1000041e 	bne	r2,zero,8228ef4 <parse_args+0x1d4>
         buf[i] = '\0';
 8228ee4:	e0bff917 	ldw	r2,-28(fp)
 8228ee8:	e0fffd17 	ldw	r3,-12(fp)
 8228eec:	1885883a 	add	r2,r3,r2
 8228ef0:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 8228ef4:	e0bff917 	ldw	r2,-28(fp)
 8228ef8:	10800044 	addi	r2,r2,1
 8228efc:	e0bff915 	stw	r2,-28(fp)
 8228f00:	e0fff917 	ldw	r3,-28(fp)
 8228f04:	e0bffc17 	ldw	r2,-16(fp)
 8228f08:	18bfed16 	blt	r3,r2,8228ec0 <parse_args+0x1a0>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 8228f0c:	e0bffb17 	ldw	r2,-20(fp)
}
 8228f10:	e037883a 	mov	sp,fp
 8228f14:	dfc00117 	ldw	ra,4(sp)
 8228f18:	df000017 	ldw	fp,0(sp)
 8228f1c:	dec00204 	addi	sp,sp,8
 8228f20:	f800283a 	ret

08228f24 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 8228f24:	defffc04 	addi	sp,sp,-16
 8228f28:	dfc00315 	stw	ra,12(sp)
 8228f2c:	df000215 	stw	fp,8(sp)
 8228f30:	df000204 	addi	fp,sp,8
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 8228f34:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 8228f38:	823d00c0 	call	823d00c <prep_modules>
 8228f3c:	e0bfff15 	stw	r2,-4(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 8228f40:	e03ffe15 	stw	zero,-8(fp)
 8228f44:	00001a06 	br	8228fb0 <netmain+0x8c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 8228f48:	e0bffe17 	ldw	r2,-8(fp)
 8228f4c:	10c00624 	muli	r3,r2,24
 8228f50:	00820974 	movhi	r2,2085
 8228f54:	108d3c04 	addi	r2,r2,13552
 8228f58:	1885883a 	add	r2,r3,r2
 8228f5c:	1009883a 	mov	r4,r2
 8228f60:	822d5900 	call	822d590 <TK_NEWTASK>
 8228f64:	e0bfff15 	stw	r2,-4(fp)
      if (e != 0)
 8228f68:	e0bfff17 	ldw	r2,-4(fp)
 8228f6c:	10000d26 	beq	r2,zero,8228fa4 <netmain+0x80>
      {
         dprintf("task create error\n");
 8228f70:	01020974 	movhi	r4,2085
 8228f74:	21003f04 	addi	r4,r4,252
 8228f78:	82031200 	call	8203120 <puts>
         panic((char *)&nettasks[i].name);
 8228f7c:	e0bffe17 	ldw	r2,-8(fp)
 8228f80:	10800624 	muli	r2,r2,24
 8228f84:	10c00104 	addi	r3,r2,4
 8228f88:	00820974 	movhi	r2,2085
 8228f8c:	108d3c04 	addi	r2,r2,13552
 8228f90:	1885883a 	add	r2,r3,r2
 8228f94:	1009883a 	mov	r4,r2
 8228f98:	822887c0 	call	822887c <panic>
         return -1;  /* compiler warnings */
 8228f9c:	00bfffc4 	movi	r2,-1
 8228fa0:	00001306 	br	8228ff0 <netmain+0xcc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 8228fa4:	e0bffe17 	ldw	r2,-8(fp)
 8228fa8:	10800044 	addi	r2,r2,1
 8228fac:	e0bffe15 	stw	r2,-8(fp)
 8228fb0:	d0a03217 	ldw	r2,-32568(gp)
 8228fb4:	e0fffe17 	ldw	r3,-8(fp)
 8228fb8:	18bfe316 	blt	r3,r2,8228f48 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 8228fbc:	823d4740 	call	823d474 <create_apptasks>
 8228fc0:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0) 
 8228fc4:	e0bfff17 	ldw	r2,-4(fp)
 8228fc8:	10000826 	beq	r2,zero,8228fec <netmain+0xc8>
   {
      dprintf("task create error\n");
 8228fcc:	01020974 	movhi	r4,2085
 8228fd0:	21003f04 	addi	r4,r4,252
 8228fd4:	82031200 	call	8203120 <puts>
      panic("netmain");
 8228fd8:	01020974 	movhi	r4,2085
 8228fdc:	21004404 	addi	r4,r4,272
 8228fe0:	822887c0 	call	822887c <panic>
      return -1;  /* compiler warnings */
 8228fe4:	00bfffc4 	movi	r2,-1
 8228fe8:	00000106 	br	8228ff0 <netmain+0xcc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 8228fec:	0005883a 	mov	r2,zero
#endif
#endif   /* NO_INET_STACK */
}
 8228ff0:	e037883a 	mov	sp,fp
 8228ff4:	dfc00117 	ldw	ra,4(sp)
 8228ff8:	df000017 	ldw	fp,0(sp)
 8228ffc:	dec00204 	addi	sp,sp,8
 8229000:	f800283a 	ret

08229004 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 8229004:	defffc04 	addi	sp,sp,-16
 8229008:	dfc00315 	stw	ra,12(sp)
 822900c:	df000215 	stw	fp,8(sp)
 8229010:	df000204 	addi	fp,sp,8
 8229014:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 8229018:	823cc6c0 	call	823cc6c <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 822901c:	00800044 	movi	r2,1
 8229020:	d0a08c15 	stw	r2,-32208(gp)

   for (;;)
   {
      TK_NETRX_BLOCK();
 8229024:	d0a0ab17 	ldw	r2,-32084(gp)
 8229028:	e1bffe04 	addi	r6,fp,-8
 822902c:	01401904 	movi	r5,100
 8229030:	1009883a 	mov	r4,r2
 8229034:	8219d080 	call	8219d08 <OSSemPend>
 8229038:	e0bffe03 	ldbu	r2,-8(fp)
 822903c:	10803fcc 	andi	r2,r2,255
 8229040:	10000526 	beq	r2,zero,8229058 <tk_netmain+0x54>
 8229044:	e0bffe03 	ldbu	r2,-8(fp)
 8229048:	10803fcc 	andi	r2,r2,255
 822904c:	108002a0 	cmpeqi	r2,r2,10
 8229050:	1000011e 	bne	r2,zero,8229058 <tk_netmain+0x54>
 8229054:	822d1c80 	call	822d1c8 <dtrap>
      netmain_wakes++;  /* count wakeups */
 8229058:	d0a08a17 	ldw	r2,-32216(gp)
 822905c:	10800044 	addi	r2,r2,1
 8229060:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 8229064:	008209b4 	movhi	r2,2086
 8229068:	10b5ed04 	addi	r2,r2,-10316
 822906c:	10800217 	ldw	r2,8(r2)
 8229070:	103fec26 	beq	r2,zero,8229024 <tk_netmain+0x20>
         pktdemux();
 8229074:	8225ef80 	call	8225ef8 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 8229078:	003fea06 	br	8229024 <tk_netmain+0x20>

0822907c <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 822907c:	defffd04 	addi	sp,sp,-12
 8229080:	dfc00215 	stw	ra,8(sp)
 8229084:	df000115 	stw	fp,4(sp)
 8229088:	df000104 	addi	fp,sp,4
 822908c:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 8229090:	00000306 	br	82290a0 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 8229094:	822b9440 	call	822b944 <dhc_second>
#endif
      TK_SLEEP(1);
 8229098:	01000084 	movi	r4,2
 822909c:	821bb0c0 	call	821bb0c <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 82290a0:	d0a08c17 	ldw	r2,-32208(gp)
 82290a4:	103ffb26 	beq	r2,zero,8229094 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 82290a8:	01000084 	movi	r4,2
 82290ac:	821bb0c0 	call	821bb0c <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 82290b0:	d0a08b17 	ldw	r2,-32212(gp)
 82290b4:	10800044 	addi	r2,r2,1
 82290b8:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 82290bc:	823d0600 	call	823d060 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 82290c0:	003ff906 	br	82290a8 <tk_nettick+0x2c>

082290c4 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 82290c4:	defffe04 	addi	sp,sp,-8
 82290c8:	dfc00115 	stw	ra,4(sp)
 82290cc:	df000015 	stw	fp,0(sp)
 82290d0:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 82290d4:	01000084 	movi	r4,2
 82290d8:	821bb0c0 	call	821bb0c <OSTimeDly>
}
 82290dc:	0001883a 	nop
 82290e0:	e037883a 	mov	sp,fp
 82290e4:	dfc00117 	ldw	ra,4(sp)
 82290e8:	df000017 	ldw	fp,0(sp)
 82290ec:	dec00204 	addi	sp,sp,8
 82290f0:	f800283a 	ret

082290f4 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 82290f4:	defffc04 	addi	sp,sp,-16
 82290f8:	dfc00315 	stw	ra,12(sp)
 82290fc:	df000215 	stw	fp,8(sp)
 8229100:	df000204 	addi	fp,sp,8
 8229104:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 8229108:	e0bfff17 	ldw	r2,-4(fp)
 822910c:	10800003 	ldbu	r2,0(r2)
 8229110:	10803fcc 	andi	r2,r2,255
 8229114:	1009883a 	mov	r4,r2
 8229118:	821b4000 	call	821b400 <OSTaskResume>
 822911c:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 8229120:	e0bffe03 	ldbu	r2,-8(fp)
 8229124:	10000a26 	beq	r2,zero,8229150 <TK_OSTaskResume+0x5c>
 8229128:	e0bffe03 	ldbu	r2,-8(fp)
 822912c:	10801120 	cmpeqi	r2,r2,68
 8229130:	1000071e 	bne	r2,zero,8229150 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 8229134:	01020974 	movhi	r4,2085
 8229138:	21004604 	addi	r4,r4,280
 822913c:	82031200 	call	8203120 <puts>
      dtrap();
 8229140:	822d1c80 	call	822d1c8 <dtrap>
      panic("TK_OSTaskResume");      
 8229144:	01020974 	movhi	r4,2085
 8229148:	21005304 	addi	r4,r4,332
 822914c:	822887c0 	call	822887c <panic>
   }
#endif
}
 8229150:	0001883a 	nop
 8229154:	e037883a 	mov	sp,fp
 8229158:	dfc00117 	ldw	ra,4(sp)
 822915c:	df000017 	ldw	fp,0(sp)
 8229160:	dec00204 	addi	sp,sp,8
 8229164:	f800283a 	ret

08229168 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 8229168:	defffb04 	addi	sp,sp,-20
 822916c:	dfc00415 	stw	ra,16(sp)
 8229170:	df000315 	stw	fp,12(sp)
 8229174:	df000304 	addi	fp,sp,12
 8229178:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 822917c:	e03ffd15 	stw	zero,-12(fp)
 8229180:	00004706 	br	82292a0 <tcp_sleep+0x138>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 8229184:	008209b4 	movhi	r2,2086
 8229188:	10b79d04 	addi	r2,r2,-8588
 822918c:	e0fffd17 	ldw	r3,-12(fp)
 8229190:	18c00324 	muli	r3,r3,12
 8229194:	10c5883a 	add	r2,r2,r3
 8229198:	10800104 	addi	r2,r2,4
 822919c:	10800017 	ldw	r2,0(r2)
 82291a0:	10003c1e 	bne	r2,zero,8229294 <tcp_sleep+0x12c>
      {
         global_TCPwakeup_set[i].soc_event = event;
 82291a4:	008209b4 	movhi	r2,2086
 82291a8:	10b79d04 	addi	r2,r2,-8588
 82291ac:	e0fffd17 	ldw	r3,-12(fp)
 82291b0:	18c00324 	muli	r3,r3,12
 82291b4:	10c5883a 	add	r2,r2,r3
 82291b8:	10800104 	addi	r2,r2,4
 82291bc:	e0ffff17 	ldw	r3,-4(fp)
 82291c0:	10c00015 	stw	r3,0(r2)
         global_TCPwakeup_set[i].ctick = cticks;
 82291c4:	d0e0a817 	ldw	r3,-32096(gp)
 82291c8:	008209b4 	movhi	r2,2086
 82291cc:	10b79d04 	addi	r2,r2,-8588
 82291d0:	e13ffd17 	ldw	r4,-12(fp)
 82291d4:	21000324 	muli	r4,r4,12
 82291d8:	1105883a 	add	r2,r2,r4
 82291dc:	10c00015 	stw	r3,0(r2)
         if (i > global_TCPwakeup_setIndx)
 82291e0:	d0e0a717 	ldw	r3,-32100(gp)
 82291e4:	e0bffd17 	ldw	r2,-12(fp)
 82291e8:	1880020e 	bge	r3,r2,82291f4 <tcp_sleep+0x8c>
            global_TCPwakeup_setIndx = i;
 82291ec:	e0bffd17 	ldw	r2,-12(fp)
 82291f0:	d0a0a715 	stw	r2,-32100(gp)

         tcp_sleep_count++;
 82291f4:	d0a0a317 	ldw	r2,-32116(gp)
 82291f8:	10800044 	addi	r2,r2,1
 82291fc:	d0a0a315 	stw	r2,-32116(gp)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 8229200:	0009883a 	mov	r4,zero
 8229204:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 8229208:	008209b4 	movhi	r2,2086
 822920c:	10b79d04 	addi	r2,r2,-8588
 8229210:	e0fffd17 	ldw	r3,-12(fp)
 8229214:	18c00324 	muli	r3,r3,12
 8229218:	10c5883a 	add	r2,r2,r3
 822921c:	10800204 	addi	r2,r2,8
 8229220:	10800017 	ldw	r2,0(r2)
 8229224:	e0fffe04 	addi	r3,fp,-8
 8229228:	180d883a 	mov	r6,r3
 822922c:	01401904 	movi	r5,100
 8229230:	1009883a 	mov	r4,r2
 8229234:	8219d080 	call	8219d08 <OSSemPend>
         if (err == 10)
 8229238:	e0bffe03 	ldbu	r2,-8(fp)
 822923c:	10803fcc 	andi	r2,r2,255
 8229240:	10800298 	cmpnei	r2,r2,10
 8229244:	1000101e 	bne	r2,zero,8229288 <tcp_sleep+0x120>
         {
            ++tcp_sleep_timeout;
 8229248:	d0a08e17 	ldw	r2,-32200(gp)
 822924c:	10800044 	addi	r2,r2,1
 8229250:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 8229254:	008209b4 	movhi	r2,2086
 8229258:	10b79d04 	addi	r2,r2,-8588
 822925c:	e0fffd17 	ldw	r3,-12(fp)
 8229260:	18c00324 	muli	r3,r3,12
 8229264:	10c5883a 	add	r2,r2,r3
 8229268:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 822926c:	008209b4 	movhi	r2,2086
 8229270:	10b79d04 	addi	r2,r2,-8588
 8229274:	e0fffd17 	ldw	r3,-12(fp)
 8229278:	18c00324 	muli	r3,r3,12
 822927c:	10c5883a 	add	r2,r2,r3
 8229280:	10800104 	addi	r2,r2,4
 8229284:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 8229288:	0009883a 	mov	r4,zero
 822928c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
 8229290:	00000d06 	br	82292c8 <tcp_sleep+0x160>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229294:	e0bffd17 	ldw	r2,-12(fp)
 8229298:	10800044 	addi	r2,r2,1
 822929c:	e0bffd15 	stw	r2,-12(fp)
 82292a0:	e0bffd17 	ldw	r2,-12(fp)
 82292a4:	10800510 	cmplti	r2,r2,20
 82292a8:	103fb61e 	bne	r2,zero,8229184 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 82292ac:	e0bffd17 	ldw	r2,-12(fp)
 82292b0:	d0a0a715 	stw	r2,-32100(gp)

   UNLOCK_NET_RESOURCE(NET_RESID);
 82292b4:	0009883a 	mov	r4,zero
 82292b8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 82292bc:	82294400 	call	8229440 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 82292c0:	0009883a 	mov	r4,zero
 82292c4:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
}
 82292c8:	e037883a 	mov	sp,fp
 82292cc:	dfc00117 	ldw	ra,4(sp)
 82292d0:	df000017 	ldw	fp,0(sp)
 82292d4:	dec00204 	addi	sp,sp,8
 82292d8:	f800283a 	ret

082292dc <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 82292dc:	defffc04 	addi	sp,sp,-16
 82292e0:	dfc00315 	stw	ra,12(sp)
 82292e4:	df000215 	stw	fp,8(sp)
 82292e8:	df000204 	addi	fp,sp,8
 82292ec:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 82292f0:	82152240 	call	8215224 <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82292f4:	e03ffe15 	stw	zero,-8(fp)
 82292f8:	00002c06 	br	82293ac <tcp_wakeup+0xd0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 82292fc:	008209b4 	movhi	r2,2086
 8229300:	10b79d04 	addi	r2,r2,-8588
 8229304:	e0fffe17 	ldw	r3,-8(fp)
 8229308:	18c00324 	muli	r3,r3,12
 822930c:	10c5883a 	add	r2,r2,r3
 8229310:	10800017 	ldw	r2,0(r2)
 8229314:	10002226 	beq	r2,zero,82293a0 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
 8229318:	008209b4 	movhi	r2,2086
 822931c:	10b79d04 	addi	r2,r2,-8588
 8229320:	e0fffe17 	ldw	r3,-8(fp)
 8229324:	18c00324 	muli	r3,r3,12
 8229328:	10c5883a 	add	r2,r2,r3
 822932c:	10800104 	addi	r2,r2,4
 8229330:	10c00017 	ldw	r3,0(r2)

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 8229334:	e0bfff17 	ldw	r2,-4(fp)
 8229338:	1880191e 	bne	r3,r2,82293a0 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 822933c:	008209b4 	movhi	r2,2086
 8229340:	10b79d04 	addi	r2,r2,-8588
 8229344:	e0fffe17 	ldw	r3,-8(fp)
 8229348:	18c00324 	muli	r3,r3,12
 822934c:	10c5883a 	add	r2,r2,r3
 8229350:	10800204 	addi	r2,r2,8
 8229354:	10800017 	ldw	r2,0(r2)
 8229358:	1009883a 	mov	r4,r2
 822935c:	821a0800 	call	821a080 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 8229360:	008209b4 	movhi	r2,2086
 8229364:	10b79d04 	addi	r2,r2,-8588
 8229368:	e0fffe17 	ldw	r3,-8(fp)
 822936c:	18c00324 	muli	r3,r3,12
 8229370:	10c5883a 	add	r2,r2,r3
 8229374:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 8229378:	008209b4 	movhi	r2,2086
 822937c:	10b79d04 	addi	r2,r2,-8588
 8229380:	e0fffe17 	ldw	r3,-8(fp)
 8229384:	18c00324 	muli	r3,r3,12
 8229388:	10c5883a 	add	r2,r2,r3
 822938c:	10800104 	addi	r2,r2,4
 8229390:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 8229394:	d0a0a417 	ldw	r2,-32112(gp)
 8229398:	10800044 	addi	r2,r2,1
 822939c:	d0a0a415 	stw	r2,-32112(gp)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82293a0:	e0bffe17 	ldw	r2,-8(fp)
 82293a4:	10800044 	addi	r2,r2,1
 82293a8:	e0bffe15 	stw	r2,-8(fp)
 82293ac:	e0bffe17 	ldw	r2,-8(fp)
 82293b0:	10800510 	cmplti	r2,r2,20
 82293b4:	103fd11e 	bne	r2,zero,82292fc <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 82293b8:	82152b00 	call	82152b0 <OSSchedUnlock>
}
 82293bc:	0001883a 	nop
 82293c0:	e037883a 	mov	sp,fp
 82293c4:	dfc00117 	ldw	ra,4(sp)
 82293c8:	df000017 	ldw	fp,0(sp)
 82293cc:	dec00204 	addi	sp,sp,8
 82293d0:	f800283a 	ret

082293d4 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 82293d4:	deffe204 	addi	sp,sp,-120
 82293d8:	dfc01d15 	stw	ra,116(sp)
 82293dc:	df001c15 	stw	fp,112(sp)
 82293e0:	df001c04 	addi	fp,sp,112
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 82293e4:	e0bfe504 	addi	r2,fp,-108
 82293e8:	100b883a 	mov	r5,r2
 82293ec:	01003fc4 	movi	r4,255
 82293f0:	821b9780 	call	821b978 <OSTaskQuery>
 82293f4:	e0bfe405 	stb	r2,-112(fp)

   if (err == OS_NO_ERR)
 82293f8:	e0bfe403 	ldbu	r2,-112(fp)
 82293fc:	1000041e 	bne	r2,zero,8229410 <TK_OSTaskQuery+0x3c>
   {
      task_prio = task_data.OSTCBPrio;
 8229400:	e0bff183 	ldbu	r2,-58(fp)
 8229404:	e0bfe445 	stb	r2,-111(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 8229408:	e0bfe443 	ldbu	r2,-111(fp)
 822940c:	00000706 	br	822942c <TK_OSTaskQuery+0x58>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 8229410:	01020974 	movhi	r4,2085
 8229414:	21005704 	addi	r4,r4,348
 8229418:	8202e9c0 	call	8202e9c <printf>
      panic("TK_OSTaskQuery");
 822941c:	01020974 	movhi	r4,2085
 8229420:	21006404 	addi	r4,r4,400
 8229424:	822887c0 	call	822887c <panic>
      return 0;
 8229428:	0005883a 	mov	r2,zero
   }
   
   return task_prio;
}
 822942c:	e037883a 	mov	sp,fp
 8229430:	dfc00117 	ldw	ra,4(sp)
 8229434:	df000017 	ldw	fp,0(sp)
 8229438:	dec00204 	addi	sp,sp,8
 822943c:	f800283a 	ret

08229440 <tk_yield>:



void
tk_yield(void)
{
 8229440:	defffe04 	addi	sp,sp,-8
 8229444:	dfc00115 	stw	ra,4(sp)
 8229448:	df000015 	stw	fp,0(sp)
 822944c:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 8229450:	01000044 	movi	r4,1
 8229454:	821bb0c0 	call	821bb0c <OSTimeDly>
}
 8229458:	0001883a 	nop
 822945c:	e037883a 	mov	sp,fp
 8229460:	dfc00117 	ldw	ra,4(sp)
 8229464:	df000017 	ldw	fp,0(sp)
 8229468:	dec00204 	addi	sp,sp,8
 822946c:	f800283a 	ret

08229470 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 8229470:	deffef04 	addi	sp,sp,-68
 8229474:	dfc01015 	stw	ra,64(sp)
 8229478:	df000f15 	stw	fp,60(sp)
 822947c:	df000f04 	addi	fp,sp,60
 8229480:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 8229484:	01420974 	movhi	r5,2085
 8229488:	29406804 	addi	r5,r5,416
 822948c:	e13fff17 	ldw	r4,-4(fp)
 8229490:	8228a940 	call	8228a94 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 8229494:	d0a07017 	ldw	r2,-32320(gp)
 8229498:	100d883a 	mov	r6,r2
 822949c:	01420974 	movhi	r5,2085
 82294a0:	29406e04 	addi	r5,r5,440
 82294a4:	e13fff17 	ldw	r4,-4(fp)
 82294a8:	8228a940 	call	8228a94 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 82294ac:	01420974 	movhi	r5,2085
 82294b0:	29407604 	addi	r5,r5,472
 82294b4:	e13fff17 	ldw	r4,-4(fp)
 82294b8:	8228a940 	call	8228a94 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 82294bc:	e03ff215 	stw	zero,-56(fp)
 82294c0:	00005406 	br	8229614 <tk_stats+0x1a4>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 82294c4:	008209b4 	movhi	r2,2086
 82294c8:	10b54004 	addi	r2,r2,-11008
 82294cc:	e0fff217 	ldw	r3,-56(fp)
 82294d0:	18c7883a 	add	r3,r3,r3
 82294d4:	18c7883a 	add	r3,r3,r3
 82294d8:	10c5883a 	add	r2,r2,r3
 82294dc:	10800017 	ldw	r2,0(r2)
 82294e0:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 82294e4:	e0bff417 	ldw	r2,-48(fp)
 82294e8:	10004626 	beq	r2,zero,8229604 <tk_stats+0x194>
 82294ec:	e0bff417 	ldw	r2,-48(fp)
 82294f0:	10800058 	cmpnei	r2,r2,1
 82294f4:	10004326 	beq	r2,zero,8229604 <tk_stats+0x194>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 82294f8:	e0bff417 	ldw	r2,-48(fp)
 82294fc:	10800c83 	ldbu	r2,50(r2)
 8229500:	10803fcc 	andi	r2,r2,255
 8229504:	e13ffe44 	addi	r4,fp,-7
 8229508:	e0fff604 	addi	r3,fp,-40
 822950c:	200d883a 	mov	r6,r4
 8229510:	180b883a 	mov	r5,r3
 8229514:	1009883a 	mov	r4,r2
 8229518:	821b0b40 	call	821b0b4 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 822951c:	e0bff417 	ldw	r2,-48(fp)
 8229520:	10800c83 	ldbu	r2,50(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 8229524:	11003fcc 	andi	r4,r2,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 8229528:	e0bff417 	ldw	r2,-48(fp)
 822952c:	10800c03 	ldbu	r2,48(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 8229530:	10803fcc 	andi	r2,r2,255
 8229534:	e0fff604 	addi	r3,fp,-40
 8229538:	d8800015 	stw	r2,0(sp)
 822953c:	200f883a 	mov	r7,r4
 8229540:	180d883a 	mov	r6,r3
 8229544:	01420974 	movhi	r5,2085
 8229548:	29408604 	addi	r5,r5,536
 822954c:	e13fff17 	ldw	r4,-4(fp)
 8229550:	8228a940 	call	8228a94 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 8229554:	e0bff417 	ldw	r2,-48(fp)
 8229558:	10800217 	ldw	r2,8(r2)
 822955c:	10002426 	beq	r2,zero,82295f0 <tk_stats+0x180>
 8229560:	e0bff417 	ldw	r2,-48(fp)
 8229564:	10800317 	ldw	r2,12(r2)
 8229568:	10002126 	beq	r2,zero,82295f0 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 822956c:	e0bff417 	ldw	r2,-48(fp)
 8229570:	10800217 	ldw	r2,8(r2)
 8229574:	10800104 	addi	r2,r2,4
 8229578:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 822957c:	00000306 	br	822958c <tk_stats+0x11c>
            sp++;
 8229580:	e0bff317 	ldw	r2,-52(fp)
 8229584:	10800104 	addi	r2,r2,4
 8229588:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 822958c:	e0bff317 	ldw	r2,-52(fp)
 8229590:	10800017 	ldw	r2,0(r2)
 8229594:	103ffa26 	beq	r2,zero,8229580 <tk_stats+0x110>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 8229598:	e0bff417 	ldw	r2,-48(fp)
 822959c:	10800317 	ldw	r2,12(r2)
 82295a0:	e0fff317 	ldw	r3,-52(fp)
 82295a4:	e13ff417 	ldw	r4,-48(fp)
 82295a8:	21000217 	ldw	r4,8(r4)
 82295ac:	1907c83a 	sub	r3,r3,r4
 82295b0:	1807d0ba 	srai	r3,r3,2
 82295b4:	10c5c83a 	sub	r2,r2,r3
 82295b8:	1085883a 	add	r2,r2,r2
 82295bc:	1085883a 	add	r2,r2,r2
 82295c0:	e0bff515 	stw	r2,-44(fp)
         ns_printf(pio, "%6d,      %6d\n",
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
 82295c4:	e0bff417 	ldw	r2,-48(fp)
 82295c8:	10800317 	ldw	r2,12(r2)
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
         ns_printf(pio, "%6d,      %6d\n",
 82295cc:	1085883a 	add	r2,r2,r2
 82295d0:	1085883a 	add	r2,r2,r2
 82295d4:	e1fff517 	ldw	r7,-44(fp)
 82295d8:	100d883a 	mov	r6,r2
 82295dc:	01420974 	movhi	r5,2085
 82295e0:	29408e04 	addi	r5,r5,568
 82295e4:	e13fff17 	ldw	r4,-4(fp)
 82295e8:	8228a940 	call	8228a94 <ns_printf>
 82295ec:	00000606 	br	8229608 <tk_stats+0x198>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 82295f0:	01420974 	movhi	r5,2085
 82295f4:	29409204 	addi	r5,r5,584
 82295f8:	e13fff17 	ldw	r4,-4(fp)
 82295fc:	8228a940 	call	8228a94 <ns_printf>
 8229600:	00000106 	br	8229608 <tk_stats+0x198>
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
         continue;
 8229604:	0001883a 	nop
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 8229608:	e0bff217 	ldw	r2,-56(fp)
 822960c:	10800044 	addi	r2,r2,1
 8229610:	e0bff215 	stw	r2,-56(fp)
 8229614:	e0bff217 	ldw	r2,-56(fp)
 8229618:	10800550 	cmplti	r2,r2,21
 822961c:	103fa91e 	bne	r2,zero,82294c4 <tk_stats+0x54>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 8229620:	d0a0a317 	ldw	r2,-32116(gp)
 8229624:	d0e0a417 	ldw	r3,-32112(gp)
 8229628:	180f883a 	mov	r7,r3
 822962c:	100d883a 	mov	r6,r2
 8229630:	01420974 	movhi	r5,2085
 8229634:	29409604 	addi	r5,r5,600
 8229638:	e13fff17 	ldw	r4,-4(fp)
 822963c:	8228a940 	call	8228a94 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 8229640:	d0a0a717 	ldw	r2,-32100(gp)
 8229644:	d0e08e17 	ldw	r3,-32200(gp)
 8229648:	180f883a 	mov	r7,r3
 822964c:	100d883a 	mov	r6,r2
 8229650:	01420974 	movhi	r5,2085
 8229654:	2940a204 	addi	r5,r5,648
 8229658:	e13fff17 	ldw	r4,-4(fp)
 822965c:	8228a940 	call	8228a94 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 8229660:	0005883a 	mov	r2,zero
}
 8229664:	e037883a 	mov	sp,fp
 8229668:	dfc00117 	ldw	ra,4(sp)
 822966c:	df000017 	ldw	fp,0(sp)
 8229670:	dec00204 	addi	sp,sp,8
 8229674:	f800283a 	ret

08229678 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 8229678:	defffa04 	addi	sp,sp,-24
 822967c:	dfc00515 	stw	ra,20(sp)
 8229680:	df000415 	stw	fp,16(sp)
 8229684:	df000404 	addi	fp,sp,16
 8229688:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 822968c:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 8229690:	e17fff17 	ldw	r5,-4(fp)
 8229694:	01000d84 	movi	r4,54
 8229698:	822c2c40 	call	822c2c4 <find_opt>
 822969c:	e0bffd15 	stw	r2,-12(fp)
 82296a0:	e0bffd17 	ldw	r2,-12(fp)
 82296a4:	10001026 	beq	r2,zero,82296e8 <dhc_get_srv_ipaddr+0x70>
   {
      opts++;
 82296a8:	e0bffd17 	ldw	r2,-12(fp)
 82296ac:	10800044 	addi	r2,r2,1
 82296b0:	e0bffd15 	stw	r2,-12(fp)
      optlen = *opts;
 82296b4:	e0bffd17 	ldw	r2,-12(fp)
 82296b8:	10800003 	ldbu	r2,0(r2)
 82296bc:	e0bffe05 	stb	r2,-8(fp)
      opts++;
 82296c0:	e0bffd17 	ldw	r2,-12(fp)
 82296c4:	10800044 	addi	r2,r2,1
 82296c8:	e0bffd15 	stw	r2,-12(fp)
      srv_ipaddr = dh_getlong(opts);
 82296cc:	e13ffd17 	ldw	r4,-12(fp)
 82296d0:	822b6280 	call	822b628 <dh_getlong>
 82296d4:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 82296d8:	e0bffe03 	ldbu	r2,-8(fp)
 82296dc:	e0fffd17 	ldw	r3,-12(fp)
 82296e0:	1885883a 	add	r2,r3,r2
 82296e4:	e0bffd15 	stw	r2,-12(fp)
   }

   return (srv_ipaddr);
 82296e8:	e0bffc17 	ldw	r2,-16(fp)
} 
 82296ec:	e037883a 	mov	sp,fp
 82296f0:	dfc00117 	ldw	ra,4(sp)
 82296f4:	df000017 	ldw	fp,0(sp)
 82296f8:	dec00204 	addi	sp,sp,8
 82296fc:	f800283a 	ret

08229700 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 8229700:	defffc04 	addi	sp,sp,-16
 8229704:	dfc00315 	stw	ra,12(sp)
 8229708:	df000215 	stw	fp,8(sp)
 822970c:	df000204 	addi	fp,sp,8
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 8229710:	00bfff44 	movi	r2,-3
 8229714:	d8800015 	stw	r2,0(sp)
 8229718:	01c208f4 	movhi	r7,2083
 822971c:	39e5fe04 	addi	r7,r7,-26632
 8229720:	01801104 	movi	r6,68
 8229724:	014010c4 	movi	r5,67
 8229728:	0009883a 	mov	r4,zero
 822972c:	822cd600 	call	822cd60 <udp_open>
 8229730:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 8229734:	d0a08f17 	ldw	r2,-32196(gp)
 8229738:	1000021e 	bne	r2,zero,8229744 <dhc_init+0x44>
      return ENP_RESOURCE;
 822973c:	00bffa84 	movi	r2,-22
 8229740:	00001606 	br	822979c <dhc_init+0x9c>

   for (i = 0; i < MAXNETS; i++)
 8229744:	e03fff15 	stw	zero,-4(fp)
 8229748:	00001006 	br	822978c <dhc_init+0x8c>
   {
      dhc_states[i].state = DHCS_UNUSED;
 822974c:	008209b4 	movhi	r2,2086
 8229750:	10b6d804 	addi	r2,r2,-9376
 8229754:	e0ffff17 	ldw	r3,-4(fp)
 8229758:	18c00f24 	muli	r3,r3,60
 822975c:	10c5883a 	add	r2,r2,r3
 8229760:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 8229764:	008209b4 	movhi	r2,2086
 8229768:	10b6d804 	addi	r2,r2,-9376
 822976c:	e0ffff17 	ldw	r3,-4(fp)
 8229770:	18c00f24 	muli	r3,r3,60
 8229774:	10c5883a 	add	r2,r2,r3
 8229778:	10800104 	addi	r2,r2,4
 822977c:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 8229780:	e0bfff17 	ldw	r2,-4(fp)
 8229784:	10800044 	addi	r2,r2,1
 8229788:	e0bfff15 	stw	r2,-4(fp)
 822978c:	e0bfff17 	ldw	r2,-4(fp)
 8229790:	10800110 	cmplti	r2,r2,4
 8229794:	103fed1e 	bne	r2,zero,822974c <dhc_init+0x4c>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 8229798:	0005883a 	mov	r2,zero
}
 822979c:	e037883a 	mov	sp,fp
 82297a0:	dfc00117 	ldw	ra,4(sp)
 82297a4:	df000017 	ldw	fp,0(sp)
 82297a8:	dec00204 	addi	sp,sp,8
 82297ac:	f800283a 	ret

082297b0 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 82297b0:	defffd04 	addi	sp,sp,-12
 82297b4:	df000215 	stw	fp,8(sp)
 82297b8:	df000204 	addi	fp,sp,8
 82297bc:	e13ffe15 	stw	r4,-8(fp)
 82297c0:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 82297c4:	008209b4 	movhi	r2,2086
 82297c8:	10b6d804 	addi	r2,r2,-9376
 82297cc:	e0fffe17 	ldw	r3,-8(fp)
 82297d0:	18c00f24 	muli	r3,r3,60
 82297d4:	10c5883a 	add	r2,r2,r3
 82297d8:	10800e04 	addi	r2,r2,56
 82297dc:	e0ffff17 	ldw	r3,-4(fp)
 82297e0:	10c00015 	stw	r3,0(r2)
}
 82297e4:	0001883a 	nop
 82297e8:	e037883a 	mov	sp,fp
 82297ec:	df000017 	ldw	fp,0(sp)
 82297f0:	dec00104 	addi	sp,sp,4
 82297f4:	f800283a 	ret

082297f8 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 82297f8:	defff504 	addi	sp,sp,-44
 82297fc:	dfc00a15 	stw	ra,40(sp)
 8229800:	df000915 	stw	fp,36(sp)
 8229804:	dc000815 	stw	r16,32(sp)
 8229808:	df000904 	addi	fp,sp,36
 822980c:	e13ffd15 	stw	r4,-12(fp)
 8229810:	e17ffe15 	stw	r5,-8(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 8229814:	e0bffd17 	ldw	r2,-12(fp)
 8229818:	10800417 	ldw	r2,16(r2)
 822981c:	e0bff815 	stw	r2,-32(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 8229820:	e03ff715 	stw	zero,-36(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 8229824:	e0bffe17 	ldw	r2,-8(fp)
 8229828:	10bfff60 	cmpeqi	r2,r2,-3
 822982c:	1000031e 	bne	r2,zero,822983c <dhc_upcall+0x44>
   {
      dtrap();
 8229830:	822d1c80 	call	822d1c8 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 8229834:	00bffd44 	movi	r2,-11
 8229838:	0001d506 	br	8229f90 <dhc_upcall+0x798>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 822983c:	e0bffd17 	ldw	r2,-12(fp)
 8229840:	10800617 	ldw	r2,24(r2)
 8229844:	1009883a 	mov	r4,r2
 8229848:	822689c0 	call	822689c <if_netnumber>
 822984c:	e0bff915 	stw	r2,-28(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 8229850:	008209b4 	movhi	r2,2086
 8229854:	10b6d804 	addi	r2,r2,-9376
 8229858:	e0fff917 	ldw	r3,-28(fp)
 822985c:	18c00f24 	muli	r3,r3,60
 8229860:	10c5883a 	add	r2,r2,r3
 8229864:	10800017 	ldw	r2,0(r2)
 8229868:	1000021e 	bne	r2,zero,8229874 <dhc_upcall+0x7c>
      return ENP_NOT_MINE;
 822986c:	00800084 	movi	r2,2
 8229870:	0001c706 	br	8229f90 <dhc_upcall+0x798>

   bp = (struct bootp *)pkt->nb_prot;
 8229874:	e0bffd17 	ldw	r2,-12(fp)
 8229878:	10800317 	ldw	r2,12(r2)
 822987c:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229880:	e0bff817 	ldw	r2,-32(fp)
 8229884:	10803b30 	cmpltui	r2,r2,236
 8229888:	10000b1e 	bne	r2,zero,82298b8 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
 822988c:	e0bffa17 	ldw	r2,-24(fp)
 8229890:	10800003 	ldbu	r2,0(r2)
      return ENP_NOT_MINE;

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229894:	10803fcc 	andi	r2,r2,255
 8229898:	10800098 	cmpnei	r2,r2,2
 822989c:	1000061e 	bne	r2,zero,82298b8 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
 82298a0:	e0bffa17 	ldw	r2,-24(fp)
 82298a4:	10803b04 	addi	r2,r2,236
 82298a8:	10c00017 	ldw	r3,0(r2)

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
       (bp->op != BOOTREPLY) ||
 82298ac:	0098d534 	movhi	r2,25428
 82298b0:	10a098c4 	addi	r2,r2,-32157
 82298b4:	18800626 	beq	r3,r2,82298d0 <dhc_upcall+0xd8>
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 82298b8:	822d1c80 	call	822d1c8 <dtrap>
      dsc_errors++;
 82298bc:	d0a09017 	ldw	r2,-32192(gp)
 82298c0:	10800044 	addi	r2,r2,1
 82298c4:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 82298c8:	00800084 	movi	r2,2
 82298cc:	0001b006 	br	8229f90 <dhc_upcall+0x798>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 82298d0:	e0bffa17 	ldw	r2,-24(fp)
 82298d4:	10c00704 	addi	r3,r2,28
 82298d8:	e0bffd17 	ldw	r2,-12(fp)
 82298dc:	10800617 	ldw	r2,24(r2)
 82298e0:	11001717 	ldw	r4,92(r2)
 82298e4:	e0bffd17 	ldw	r2,-12(fp)
 82298e8:	10800617 	ldw	r2,24(r2)
 82298ec:	10801117 	ldw	r2,68(r2)
 82298f0:	100d883a 	mov	r6,r2
 82298f4:	200b883a 	mov	r5,r4
 82298f8:	1809883a 	mov	r4,r3
 82298fc:	820c0d80 	call	820c0d8 <memcmp>
 8229900:	10000226 	beq	r2,zero,822990c <dhc_upcall+0x114>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 8229904:	00800084 	movi	r2,2
 8229908:	0001a106 	br	8229f90 <dhc_upcall+0x798>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 822990c:	e0bffa17 	ldw	r2,-24(fp)
 8229910:	10803c04 	addi	r2,r2,240
 8229914:	100b883a 	mov	r5,r2
 8229918:	01000d44 	movi	r4,53
 822991c:	822c2c40 	call	822c2c4 <find_opt>
 8229920:	e0bffb15 	stw	r2,-20(fp)
   if (opts && *opts == DHOP_TYPE)
 8229924:	e0bffb17 	ldw	r2,-20(fp)
 8229928:	10001026 	beq	r2,zero,822996c <dhc_upcall+0x174>
 822992c:	e0bffb17 	ldw	r2,-20(fp)
 8229930:	10800003 	ldbu	r2,0(r2)
 8229934:	10803fcc 	andi	r2,r2,255
 8229938:	10800d58 	cmpnei	r2,r2,53
 822993c:	10000b1e 	bne	r2,zero,822996c <dhc_upcall+0x174>
   {
      dhcptype = *(opts+2);
 8229940:	e0bffb17 	ldw	r2,-20(fp)
 8229944:	10800084 	addi	r2,r2,2
 8229948:	10800003 	ldbu	r2,0(r2)
 822994c:	10803fcc 	andi	r2,r2,255
 8229950:	e0bff715 	stw	r2,-36(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 8229954:	e0bffa17 	ldw	r2,-24(fp)
 8229958:	10800003 	ldbu	r2,0(r2)
 822995c:	10800114 	ori	r2,r2,4
 8229960:	1007883a 	mov	r3,r2
 8229964:	e0bffa17 	ldw	r2,-24(fp)
 8229968:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 822996c:	e0bffa17 	ldw	r2,-24(fp)
 8229970:	10800003 	ldbu	r2,0(r2)
 8229974:	10803fcc 	andi	r2,r2,255
 8229978:	1080010c 	andi	r2,r2,4
 822997c:	10016326 	beq	r2,zero,8229f0c <dhc_upcall+0x714>
   {
      switch (dhcptype)
 8229980:	e0bff717 	ldw	r2,-36(fp)
 8229984:	10c00148 	cmpgei	r3,r2,5
 8229988:	1800051e 	bne	r3,zero,82299a0 <dhc_upcall+0x1a8>
 822998c:	10c000c8 	cmpgei	r3,r2,3
 8229990:	1800051e 	bne	r3,zero,82299a8 <dhc_upcall+0x1b0>
 8229994:	10800060 	cmpeqi	r2,r2,1
 8229998:	1000031e 	bne	r2,zero,82299a8 <dhc_upcall+0x1b0>
 822999c:	00000706 	br	82299bc <dhc_upcall+0x1c4>
 82299a0:	108001e0 	cmpeqi	r2,r2,7
 82299a4:	10000526 	beq	r2,zero,82299bc <dhc_upcall+0x1c4>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 82299a8:	d0a09017 	ldw	r2,-32192(gp)
 82299ac:	10800044 	addi	r2,r2,1
 82299b0:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 82299b4:	00800084 	movi	r2,2
 82299b8:	00017506 	br	8229f90 <dhc_upcall+0x798>
      }

      switch (dhc_states[iface].state)
 82299bc:	008209b4 	movhi	r2,2086
 82299c0:	10b6d804 	addi	r2,r2,-9376
 82299c4:	e0fff917 	ldw	r3,-28(fp)
 82299c8:	18c00f24 	muli	r3,r3,60
 82299cc:	10c5883a 	add	r2,r2,r3
 82299d0:	10800017 	ldw	r2,0(r2)
 82299d4:	10c00268 	cmpgeui	r3,r2,9
 82299d8:	1801431e 	bne	r3,zero,8229ee8 <dhc_upcall+0x6f0>
 82299dc:	100690ba 	slli	r3,r2,2
 82299e0:	008208f4 	movhi	r2,2083
 82299e4:	10a67d04 	addi	r2,r2,-26124
 82299e8:	1885883a 	add	r2,r3,r2
 82299ec:	10800017 	ldw	r2,0(r2)
 82299f0:	1000683a 	jmp	r2
 82299f4:	08229ee8 	cmpgeui	zero,at,35451
 82299f8:	08229a18 	cmpnei	zero,at,-30104
 82299fc:	08229a18 	cmpnei	zero,at,-30104
 8229a00:	08229c4c 	andi	zero,at,35441
 8229a04:	08229a2c 	andhi	zero,at,35432
 8229a08:	08229ba0 	cmpeqi	zero,at,-30098
 8229a0c:	08229a18 	cmpnei	zero,at,-30104
 8229a10:	08229ba0 	cmpeqi	zero,at,-30098
 8229a14:	08229ba0 	cmpeqi	zero,at,-30098
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 8229a18:	d0a09017 	ldw	r2,-32192(gp)
 8229a1c:	10800044 	addi	r2,r2,1
 8229a20:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229a24:	00800084 	movi	r2,2
 8229a28:	00015906 	br	8229f90 <dhc_upcall+0x798>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 8229a2c:	e0bff717 	ldw	r2,-36(fp)
 8229a30:	10800098 	cmpnei	r2,r2,2
 8229a34:	10004f1e 	bne	r2,zero,8229b74 <dhc_upcall+0x37c>
         {
            dsc_offers++;
 8229a38:	d0a09217 	ldw	r2,-32184(gp)
 8229a3c:	10800044 	addi	r2,r2,1
 8229a40:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 8229a44:	e0bffa17 	ldw	r2,-24(fp)
 8229a48:	10803c04 	addi	r2,r2,240
 8229a4c:	1009883a 	mov	r4,r2
 8229a50:	82296780 	call	8229678 <dhc_get_srv_ipaddr>
 8229a54:	1009883a 	mov	r4,r2
 8229a58:	008209b4 	movhi	r2,2086
 8229a5c:	10b6d804 	addi	r2,r2,-9376
 8229a60:	e0fff917 	ldw	r3,-28(fp)
 8229a64:	18c00f24 	muli	r3,r3,60
 8229a68:	10c5883a 	add	r2,r2,r3
 8229a6c:	10800d04 	addi	r2,r2,52
 8229a70:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229a74:	008209b4 	movhi	r2,2086
 8229a78:	10b6d804 	addi	r2,r2,-9376
 8229a7c:	e0fff917 	ldw	r3,-28(fp)
 8229a80:	18c00f24 	muli	r3,r3,60
 8229a84:	10c5883a 	add	r2,r2,r3
 8229a88:	10800d04 	addi	r2,r2,52
 8229a8c:	10800017 	ldw	r2,0(r2)
 8229a90:	10000d1e 	bne	r2,zero,8229ac8 <dhc_upcall+0x2d0>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229a94:	822d1c80 	call	822d1c8 <dtrap>
               dsc_errors++;
 8229a98:	d0a09017 	ldw	r2,-32192(gp)
 8229a9c:	10800044 	addi	r2,r2,1
 8229aa0:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229aa4:	e0bffd17 	ldw	r2,-12(fp)
 8229aa8:	10c00717 	ldw	r3,28(r2)
 8229aac:	008209b4 	movhi	r2,2086
 8229ab0:	10b6d804 	addi	r2,r2,-9376
 8229ab4:	e13ff917 	ldw	r4,-28(fp)
 8229ab8:	21000f24 	muli	r4,r4,60
 8229abc:	1105883a 	add	r2,r2,r4
 8229ac0:	10800d04 	addi	r2,r2,52
 8229ac4:	10c00015 	stw	r3,0(r2)
            }

            if (bp->hops)
 8229ac8:	e0bffa17 	ldw	r2,-24(fp)
 8229acc:	108000c3 	ldbu	r2,3(r2)
 8229ad0:	10803fcc 	andi	r2,r2,255
 8229ad4:	10000a26 	beq	r2,zero,8229b00 <dhc_upcall+0x308>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229ad8:	e0bffd17 	ldw	r2,-12(fp)
 8229adc:	10c00717 	ldw	r3,28(r2)
 8229ae0:	008209b4 	movhi	r2,2086
 8229ae4:	10b6d804 	addi	r2,r2,-9376
 8229ae8:	e13ff917 	ldw	r4,-28(fp)
 8229aec:	21000f24 	muli	r4,r4,60
 8229af0:	1105883a 	add	r2,r2,r4
 8229af4:	10800c04 	addi	r2,r2,48
 8229af8:	10c00015 	stw	r3,0(r2)
 8229afc:	00000706 	br	8229b1c <dhc_upcall+0x324>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229b00:	008209b4 	movhi	r2,2086
 8229b04:	10b6d804 	addi	r2,r2,-9376
 8229b08:	e0fff917 	ldw	r3,-28(fp)
 8229b0c:	18c00f24 	muli	r3,r3,60
 8229b10:	10c5883a 	add	r2,r2,r3
 8229b14:	10800c04 	addi	r2,r2,48
 8229b18:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 8229b1c:	e0bffd17 	ldw	r2,-12(fp)
 8229b20:	10800417 	ldw	r2,16(r2)
 8229b24:	100d883a 	mov	r6,r2
 8229b28:	e17ffa17 	ldw	r5,-24(fp)
 8229b2c:	e13ff917 	ldw	r4,-28(fp)
 8229b30:	822a6580 	call	822a658 <dhc_rx_offer>
 8229b34:	e0bffc15 	stw	r2,-16(fp)
            if (e)
 8229b38:	e0bffc17 	ldw	r2,-16(fp)
 8229b3c:	10000926 	beq	r2,zero,8229b64 <dhc_upcall+0x36c>
            {
               dsc_errors++;
 8229b40:	d0a09017 	ldw	r2,-32192(gp)
 8229b44:	10800044 	addi	r2,r2,1
 8229b48:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 8229b4c:	01400044 	movi	r5,1
 8229b50:	e13ff917 	ldw	r4,-28(fp)
 8229b54:	822c2140 	call	822c214 <dhc_set_state>
               dtrap();
 8229b58:	822d1c80 	call	822d1c8 <dtrap>
               return ENP_NOT_MINE;
 8229b5c:	00800084 	movi	r2,2
 8229b60:	00010b06 	br	8229f90 <dhc_upcall+0x798>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 8229b64:	01400144 	movi	r5,5
 8229b68:	e13ff917 	ldw	r4,-28(fp)
 8229b6c:	822c2140 	call	822c214 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 8229b70:	00010406 	br	8229f84 <dhc_upcall+0x78c>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 8229b74:	d0a09017 	ldw	r2,-32192(gp)
 8229b78:	10800044 	addi	r2,r2,1
 8229b7c:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 8229b80:	e0bff717 	ldw	r2,-36(fp)
 8229b84:	10800198 	cmpnei	r2,r2,6
 8229b88:	1000031e 	bne	r2,zero,8229b98 <dhc_upcall+0x3a0>
               dsc_naks++;
 8229b8c:	d0a09817 	ldw	r2,-32160(gp)
 8229b90:	10800044 	addi	r2,r2,1
 8229b94:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 8229b98:	00800084 	movi	r2,2
 8229b9c:	0000fc06 	br	8229f90 <dhc_upcall+0x798>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229ba0:	008209b4 	movhi	r2,2086
 8229ba4:	10b6d804 	addi	r2,r2,-9376
 8229ba8:	e0fff917 	ldw	r3,-28(fp)
 8229bac:	18c00f24 	muli	r3,r3,60
 8229bb0:	10c5883a 	add	r2,r2,r3
 8229bb4:	10800d04 	addi	r2,r2,52
 8229bb8:	14000017 	ldw	r16,0(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
 8229bbc:	e0bffa17 	ldw	r2,-24(fp)
 8229bc0:	10803c04 	addi	r2,r2,240
 8229bc4:	1009883a 	mov	r4,r2
 8229bc8:	82296780 	call	8229678 <dhc_get_srv_ipaddr>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229bcc:	80800526 	beq	r16,r2,8229be4 <dhc_upcall+0x3ec>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 8229bd0:	d0a09017 	ldw	r2,-32192(gp)
 8229bd4:	10800044 	addi	r2,r2,1
 8229bd8:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229bdc:	00800084 	movi	r2,2
 8229be0:	0000eb06 	br	8229f90 <dhc_upcall+0x798>
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229be4:	008209b4 	movhi	r2,2086
 8229be8:	10b6d804 	addi	r2,r2,-9376
 8229bec:	e0fff917 	ldw	r3,-28(fp)
 8229bf0:	18c00f24 	muli	r3,r3,60
 8229bf4:	10c5883a 	add	r2,r2,r3
 8229bf8:	10800c04 	addi	r2,r2,48
 8229bfc:	10800017 	ldw	r2,0(r2)
 8229c00:	10001226 	beq	r2,zero,8229c4c <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
 8229c04:	008209b4 	movhi	r2,2086
 8229c08:	10b6d804 	addi	r2,r2,-9376
 8229c0c:	e0fff917 	ldw	r3,-28(fp)
 8229c10:	18c00f24 	muli	r3,r3,60
 8229c14:	10c5883a 	add	r2,r2,r3
 8229c18:	10800c04 	addi	r2,r2,48
 8229c1c:	10c00017 	ldw	r3,0(r2)
 8229c20:	e0bffd17 	ldw	r2,-12(fp)
 8229c24:	10800717 	ldw	r2,28(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229c28:	18800826 	beq	r3,r2,8229c4c <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 8229c2c:	d0a09b17 	ldw	r2,-32148(gp)
 8229c30:	10800044 	addi	r2,r2,1
 8229c34:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 8229c38:	d0a09017 	ldw	r2,-32192(gp)
 8229c3c:	10800044 	addi	r2,r2,1
 8229c40:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229c44:	00800084 	movi	r2,2
 8229c48:	0000d106 	br	8229f90 <dhc_upcall+0x798>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 8229c4c:	e0bff717 	ldw	r2,-36(fp)
 8229c50:	10800158 	cmpnei	r2,r2,5
 8229c54:	1000851e 	bne	r2,zero,8229e6c <dhc_upcall+0x674>
         {
            dsc_acks++;
 8229c58:	d0a09417 	ldw	r2,-32176(gp)
 8229c5c:	10800044 	addi	r2,r2,1
 8229c60:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 8229c64:	e0bffa17 	ldw	r2,-24(fp)
 8229c68:	10803c04 	addi	r2,r2,240
 8229c6c:	100b883a 	mov	r5,r2
 8229c70:	e13ff917 	ldw	r4,-28(fp)
 8229c74:	822b6d40 	call	822b6d4 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 8229c78:	008209b4 	movhi	r2,2086
 8229c7c:	10b6d804 	addi	r2,r2,-9376
 8229c80:	e0fff917 	ldw	r3,-28(fp)
 8229c84:	18c00f24 	muli	r3,r3,60
 8229c88:	10c5883a 	add	r2,r2,r3
 8229c8c:	10800504 	addi	r2,r2,20
 8229c90:	10800017 	ldw	r2,0(r2)
 8229c94:	10bfffd8 	cmpnei	r2,r2,-1
 8229c98:	1000111e 	bne	r2,zero,8229ce0 <dhc_upcall+0x4e8>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 8229c9c:	008209b4 	movhi	r2,2086
 8229ca0:	10b6d804 	addi	r2,r2,-9376
 8229ca4:	e0fff917 	ldw	r3,-28(fp)
 8229ca8:	18c00f24 	muli	r3,r3,60
 8229cac:	10c5883a 	add	r2,r2,r3
 8229cb0:	10800604 	addi	r2,r2,24
 8229cb4:	00ffffc4 	movi	r3,-1
 8229cb8:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = DHC_INFINITY ;
 8229cbc:	008209b4 	movhi	r2,2086
 8229cc0:	10b6d804 	addi	r2,r2,-9376
 8229cc4:	e0fff917 	ldw	r3,-28(fp)
 8229cc8:	18c00f24 	muli	r3,r3,60
 8229ccc:	10c5883a 	add	r2,r2,r3
 8229cd0:	10800704 	addi	r2,r2,28
 8229cd4:	00ffffc4 	movi	r3,-1
 8229cd8:	10c00015 	stw	r3,0(r2)
 8229cdc:	00001f06 	br	8229d5c <dhc_upcall+0x564>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 8229ce0:	008209b4 	movhi	r2,2086
 8229ce4:	10b6d804 	addi	r2,r2,-9376
 8229ce8:	e0fff917 	ldw	r3,-28(fp)
 8229cec:	18c00f24 	muli	r3,r3,60
 8229cf0:	10c5883a 	add	r2,r2,r3
 8229cf4:	10800504 	addi	r2,r2,20
 8229cf8:	10800017 	ldw	r2,0(r2)
 8229cfc:	1006d07a 	srli	r3,r2,1
 8229d00:	008209b4 	movhi	r2,2086
 8229d04:	10b6d804 	addi	r2,r2,-9376
 8229d08:	e13ff917 	ldw	r4,-28(fp)
 8229d0c:	21000f24 	muli	r4,r4,60
 8229d10:	1105883a 	add	r2,r2,r4
 8229d14:	10800604 	addi	r2,r2,24
 8229d18:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 8229d1c:	008209b4 	movhi	r2,2086
 8229d20:	10b6d804 	addi	r2,r2,-9376
 8229d24:	e0fff917 	ldw	r3,-28(fp)
 8229d28:	18c00f24 	muli	r3,r3,60
 8229d2c:	10c5883a 	add	r2,r2,r3
 8229d30:	10800504 	addi	r2,r2,20
 8229d34:	10800017 	ldw	r2,0(r2)
 8229d38:	1004d0fa 	srli	r2,r2,3
 8229d3c:	10c001e4 	muli	r3,r2,7
 8229d40:	008209b4 	movhi	r2,2086
 8229d44:	10b6d804 	addi	r2,r2,-9376
 8229d48:	e13ff917 	ldw	r4,-28(fp)
 8229d4c:	21000f24 	muli	r4,r4,60
 8229d50:	1105883a 	add	r2,r2,r4
 8229d54:	10800704 	addi	r2,r2,28
 8229d58:	10c00015 	stw	r3,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 8229d5c:	d0e0a817 	ldw	r3,-32096(gp)
 8229d60:	008209b4 	movhi	r2,2086
 8229d64:	10b6d804 	addi	r2,r2,-9376
 8229d68:	e13ff917 	ldw	r4,-28(fp)
 8229d6c:	21000f24 	muli	r4,r4,60
 8229d70:	1105883a 	add	r2,r2,r4
 8229d74:	10800804 	addi	r2,r2,32
 8229d78:	10c00015 	stw	r3,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 8229d7c:	e0bffa17 	ldw	r2,-24(fp)
 8229d80:	10803c04 	addi	r2,r2,240
 8229d84:	1009883a 	mov	r4,r2
 8229d88:	82296780 	call	8229678 <dhc_get_srv_ipaddr>
 8229d8c:	1009883a 	mov	r4,r2
 8229d90:	008209b4 	movhi	r2,2086
 8229d94:	10b6d804 	addi	r2,r2,-9376
 8229d98:	e0fff917 	ldw	r3,-28(fp)
 8229d9c:	18c00f24 	muli	r3,r3,60
 8229da0:	10c5883a 	add	r2,r2,r3
 8229da4:	10800d04 	addi	r2,r2,52
 8229da8:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229dac:	008209b4 	movhi	r2,2086
 8229db0:	10b6d804 	addi	r2,r2,-9376
 8229db4:	e0fff917 	ldw	r3,-28(fp)
 8229db8:	18c00f24 	muli	r3,r3,60
 8229dbc:	10c5883a 	add	r2,r2,r3
 8229dc0:	10800d04 	addi	r2,r2,52
 8229dc4:	10800017 	ldw	r2,0(r2)
 8229dc8:	10000d1e 	bne	r2,zero,8229e00 <dhc_upcall+0x608>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229dcc:	822d1c80 	call	822d1c8 <dtrap>
               dsc_errors++;
 8229dd0:	d0a09017 	ldw	r2,-32192(gp)
 8229dd4:	10800044 	addi	r2,r2,1
 8229dd8:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229ddc:	e0bffd17 	ldw	r2,-12(fp)
 8229de0:	10c00717 	ldw	r3,28(r2)
 8229de4:	008209b4 	movhi	r2,2086
 8229de8:	10b6d804 	addi	r2,r2,-9376
 8229dec:	e13ff917 	ldw	r4,-28(fp)
 8229df0:	21000f24 	muli	r4,r4,60
 8229df4:	1105883a 	add	r2,r2,r4
 8229df8:	10800d04 	addi	r2,r2,52
 8229dfc:	10c00015 	stw	r3,0(r2)
            }
            if (bp->hops)
 8229e00:	e0bffa17 	ldw	r2,-24(fp)
 8229e04:	108000c3 	ldbu	r2,3(r2)
 8229e08:	10803fcc 	andi	r2,r2,255
 8229e0c:	10000a26 	beq	r2,zero,8229e38 <dhc_upcall+0x640>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229e10:	e0bffd17 	ldw	r2,-12(fp)
 8229e14:	10c00717 	ldw	r3,28(r2)
 8229e18:	008209b4 	movhi	r2,2086
 8229e1c:	10b6d804 	addi	r2,r2,-9376
 8229e20:	e13ff917 	ldw	r4,-28(fp)
 8229e24:	21000f24 	muli	r4,r4,60
 8229e28:	1105883a 	add	r2,r2,r4
 8229e2c:	10800c04 	addi	r2,r2,48
 8229e30:	10c00015 	stw	r3,0(r2)
 8229e34:	00000706 	br	8229e54 <dhc_upcall+0x65c>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229e38:	008209b4 	movhi	r2,2086
 8229e3c:	10b6d804 	addi	r2,r2,-9376
 8229e40:	e0fff917 	ldw	r3,-28(fp)
 8229e44:	18c00f24 	muli	r3,r3,60
 8229e48:	10c5883a 	add	r2,r2,r3
 8229e4c:	10800c04 	addi	r2,r2,48
 8229e50:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 8229e54:	e13ff917 	ldw	r4,-28(fp)
 8229e58:	822b1c00 	call	822b1c0 <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 8229e5c:	01400184 	movi	r5,6
 8229e60:	e13ff917 	ldw	r4,-28(fp)
 8229e64:	822c2140 	call	822c214 <dhc_set_state>
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 8229e68:	00004606 	br	8229f84 <dhc_upcall+0x78c>
               dhc_states[iface].rly_ipaddr = 0;

            dhc_setip(iface);
            dhc_set_state(iface,DHCS_BOUND);
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 8229e6c:	e0bff717 	ldw	r2,-36(fp)
 8229e70:	10800198 	cmpnei	r2,r2,6
 8229e74:	1000071e 	bne	r2,zero,8229e94 <dhc_upcall+0x69c>
         {
            dhc_set_state(iface,DHCS_INIT);
 8229e78:	01400044 	movi	r5,1
 8229e7c:	e13ff917 	ldw	r4,-28(fp)
 8229e80:	822c2140 	call	822c214 <dhc_set_state>
            dsc_naks++;
 8229e84:	d0a09817 	ldw	r2,-32160(gp)
 8229e88:	10800044 	addi	r2,r2,1
 8229e8c:	d0a09815 	stw	r2,-32160(gp)
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 8229e90:	00003c06 	br	8229f84 <dhc_upcall+0x78c>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 8229e94:	008209b4 	movhi	r2,2086
 8229e98:	10b6d804 	addi	r2,r2,-9376
 8229e9c:	e0fff917 	ldw	r3,-28(fp)
 8229ea0:	18c00f24 	muli	r3,r3,60
 8229ea4:	10c5883a 	add	r2,r2,r3
 8229ea8:	10800017 	ldw	r2,0(r2)
 8229eac:	10800158 	cmpnei	r2,r2,5
 8229eb0:	1000081e 	bne	r2,zero,8229ed4 <dhc_upcall+0x6dc>
 8229eb4:	e0bff717 	ldw	r2,-36(fp)
 8229eb8:	10800098 	cmpnei	r2,r2,2
 8229ebc:	1000051e 	bne	r2,zero,8229ed4 <dhc_upcall+0x6dc>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 8229ec0:	d0a09217 	ldw	r2,-32184(gp)
 8229ec4:	10800044 	addi	r2,r2,1
 8229ec8:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 8229ecc:	00800084 	movi	r2,2
 8229ed0:	00002f06 	br	8229f90 <dhc_upcall+0x798>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 8229ed4:	d0a09017 	ldw	r2,-32192(gp)
 8229ed8:	10800044 	addi	r2,r2,1
 8229edc:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229ee0:	00800084 	movi	r2,2
 8229ee4:	00002a06 	br	8229f90 <dhc_upcall+0x798>
         }
         break;
      default:    /* bad state */
         dtrap();
 8229ee8:	822d1c80 	call	822d1c8 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 8229eec:	01400044 	movi	r5,1
 8229ef0:	e13ff917 	ldw	r4,-28(fp)
 8229ef4:	822c2140 	call	822c214 <dhc_set_state>
         dsc_errors++;
 8229ef8:	d0a09017 	ldw	r2,-32192(gp)
 8229efc:	10800044 	addi	r2,r2,1
 8229f00:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 8229f04:	00bfffc4 	movi	r2,-1
 8229f08:	00002106 	br	8229f90 <dhc_upcall+0x798>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 8229f0c:	d0a09517 	ldw	r2,-32172(gp)
 8229f10:	10800044 	addi	r2,r2,1
 8229f14:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 8229f18:	e0bffa17 	ldw	r2,-24(fp)
 8229f1c:	10803c04 	addi	r2,r2,240
 8229f20:	100b883a 	mov	r5,r2
 8229f24:	e13ff917 	ldw	r4,-28(fp)
 8229f28:	822b6d40 	call	822b6d4 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 8229f2c:	e0bffa17 	ldw	r2,-24(fp)
 8229f30:	10c00417 	ldw	r3,16(r2)
 8229f34:	008209b4 	movhi	r2,2086
 8229f38:	10b6d804 	addi	r2,r2,-9376
 8229f3c:	e13ff917 	ldw	r4,-28(fp)
 8229f40:	21000f24 	muli	r4,r4,60
 8229f44:	1105883a 	add	r2,r2,r4
 8229f48:	10800904 	addi	r2,r2,36
 8229f4c:	10c00015 	stw	r3,0(r2)
      dhc_setip(iface);
 8229f50:	e13ff917 	ldw	r4,-28(fp)
 8229f54:	822b1c00 	call	822b1c0 <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 8229f58:	01400184 	movi	r5,6
 8229f5c:	e13ff917 	ldw	r4,-28(fp)
 8229f60:	822c2140 	call	822c214 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 8229f64:	008209b4 	movhi	r2,2086
 8229f68:	10b6d804 	addi	r2,r2,-9376
 8229f6c:	e0fff917 	ldw	r3,-28(fp)
 8229f70:	18c00f24 	muli	r3,r3,60
 8229f74:	10c5883a 	add	r2,r2,r3
 8229f78:	10800604 	addi	r2,r2,24
 8229f7c:	00ffffc4 	movi	r3,-1
 8229f80:	10c00015 	stw	r3,0(r2)
   }

   udp_free(pkt);
 8229f84:	e13ffd17 	ldw	r4,-12(fp)
 8229f88:	824511c0 	call	824511c <udp_free>
   return 0;
 8229f8c:	0005883a 	mov	r2,zero
}
 8229f90:	e6ffff04 	addi	sp,fp,-4
 8229f94:	dfc00217 	ldw	ra,8(sp)
 8229f98:	df000117 	ldw	fp,4(sp)
 8229f9c:	dc000017 	ldw	r16,0(sp)
 8229fa0:	dec00304 	addi	sp,sp,12
 8229fa4:	f800283a 	ret

08229fa8 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 8229fa8:	defffb04 	addi	sp,sp,-20
 8229fac:	dfc00415 	stw	ra,16(sp)
 8229fb0:	df000315 	stw	fp,12(sp)
 8229fb4:	df000304 	addi	fp,sp,12
 8229fb8:	e13ffe15 	stw	r4,-8(fp)
 8229fbc:	e17fff15 	stw	r5,-4(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 8229fc0:	01804b04 	movi	r6,300
 8229fc4:	000b883a 	mov	r5,zero
 8229fc8:	e13fff17 	ldw	r4,-4(fp)
 8229fcc:	8202cb00 	call	8202cb0 <memset>
   outbp->op = BOOTREQUEST;
 8229fd0:	e0bfff17 	ldw	r2,-4(fp)
 8229fd4:	00c00044 	movi	r3,1
 8229fd8:	10c00005 	stb	r3,0(r2)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 8229fdc:	008209b4 	movhi	r2,2086
 8229fe0:	10b6b204 	addi	r2,r2,-9528
 8229fe4:	e0fffe17 	ldw	r3,-8(fp)
 8229fe8:	18c7883a 	add	r3,r3,r3
 8229fec:	18c7883a 	add	r3,r3,r3
 8229ff0:	10c5883a 	add	r2,r2,r3
 8229ff4:	10800017 	ldw	r2,0(r2)
 8229ff8:	10802717 	ldw	r2,156(r2)
 8229ffc:	10800217 	ldw	r2,8(r2)
 822a000:	10c005e0 	cmpeqi	r3,r2,23
 822a004:	1800081e 	bne	r3,zero,822a028 <dhc_buildheader+0x80>
 822a008:	10c00720 	cmpeqi	r3,r2,28
 822a00c:	1800061e 	bne	r3,zero,822a028 <dhc_buildheader+0x80>
 822a010:	108001a0 	cmpeqi	r2,r2,6
 822a014:	10000826 	beq	r2,zero,822a038 <dhc_buildheader+0x90>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 822a018:	e0bfff17 	ldw	r2,-4(fp)
 822a01c:	00c00044 	movi	r3,1
 822a020:	10c00045 	stb	r3,1(r2)
   break;
 822a024:	00000706 	br	822a044 <dhc_buildheader+0x9c>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 822a028:	e0bfff17 	ldw	r2,-4(fp)
 822a02c:	00c00504 	movi	r3,20
 822a030:	10c00045 	stb	r3,1(r2)
   break;
 822a034:	00000306 	br	822a044 <dhc_buildheader+0x9c>
      default:
      dtrap();
 822a038:	822d1c80 	call	822d1c8 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 822a03c:	00bffd44 	movi	r2,-11
 822a040:	00004d06 	br	822a178 <dhc_buildheader+0x1d0>
   }

   addrlen = min(16, nets[iface]->n_hal);
 822a044:	008209b4 	movhi	r2,2086
 822a048:	10b6b204 	addi	r2,r2,-9528
 822a04c:	e0fffe17 	ldw	r3,-8(fp)
 822a050:	18c7883a 	add	r3,r3,r3
 822a054:	18c7883a 	add	r3,r3,r3
 822a058:	10c5883a 	add	r2,r2,r3
 822a05c:	10800017 	ldw	r2,0(r2)
 822a060:	10801117 	ldw	r2,68(r2)
 822a064:	10c00470 	cmpltui	r3,r2,17
 822a068:	1800011e 	bne	r3,zero,822a070 <dhc_buildheader+0xc8>
 822a06c:	00800404 	movi	r2,16
 822a070:	e0bffd15 	stw	r2,-12(fp)
   outbp->hlen = (u_char)addrlen;
 822a074:	e0bffd17 	ldw	r2,-12(fp)
 822a078:	1007883a 	mov	r3,r2
 822a07c:	e0bfff17 	ldw	r2,-4(fp)
 822a080:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 822a084:	e0bfff17 	ldw	r2,-4(fp)
 822a088:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 822a08c:	008209b4 	movhi	r2,2086
 822a090:	10b6d804 	addi	r2,r2,-9376
 822a094:	e0fffe17 	ldw	r3,-8(fp)
 822a098:	18c00f24 	muli	r3,r3,60
 822a09c:	10c5883a 	add	r2,r2,r3
 822a0a0:	10800017 	ldw	r2,0(r2)
 822a0a4:	108001d8 	cmpnei	r2,r2,7
 822a0a8:	1000031e 	bne	r2,zero,822a0b8 <dhc_buildheader+0x110>
      outbp->flags = 0; /* Renewing needs unicast */
 822a0ac:	e0bfff17 	ldw	r2,-4(fp)
 822a0b0:	1000028d 	sth	zero,10(r2)
 822a0b4:	00000306 	br	822a0c4 <dhc_buildheader+0x11c>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 822a0b8:	e0bfff17 	ldw	r2,-4(fp)
 822a0bc:	00c02004 	movi	r3,128
 822a0c0:	10c0028d 	sth	r3,10(r2)
   outbp->xid = dhc_states[iface].xid;
 822a0c4:	008209b4 	movhi	r2,2086
 822a0c8:	10b6d804 	addi	r2,r2,-9376
 822a0cc:	e0fffe17 	ldw	r3,-8(fp)
 822a0d0:	18c00f24 	muli	r3,r3,60
 822a0d4:	10c5883a 	add	r2,r2,r3
 822a0d8:	10800204 	addi	r2,r2,8
 822a0dc:	10c00017 	ldw	r3,0(r2)
 822a0e0:	e0bfff17 	ldw	r2,-4(fp)
 822a0e4:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 822a0e8:	008209b4 	movhi	r2,2086
 822a0ec:	10b6d804 	addi	r2,r2,-9376
 822a0f0:	e0fffe17 	ldw	r3,-8(fp)
 822a0f4:	18c00f24 	muli	r3,r3,60
 822a0f8:	10c5883a 	add	r2,r2,r3
 822a0fc:	10800304 	addi	r2,r2,12
 822a100:	10c0000b 	ldhu	r3,0(r2)
 822a104:	e0bfff17 	ldw	r2,-4(fp)
 822a108:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 822a10c:	008209b4 	movhi	r2,2086
 822a110:	10b6b204 	addi	r2,r2,-9528
 822a114:	e0fffe17 	ldw	r3,-8(fp)
 822a118:	18c7883a 	add	r3,r3,r3
 822a11c:	18c7883a 	add	r3,r3,r3
 822a120:	10c5883a 	add	r2,r2,r3
 822a124:	10800017 	ldw	r2,0(r2)
 822a128:	10801717 	ldw	r2,92(r2)
 822a12c:	1000031e 	bne	r2,zero,822a13c <dhc_buildheader+0x194>
   {
      dtrap();
 822a130:	822d1c80 	call	822d1c8 <dtrap>
      return ENP_LOGIC;
 822a134:	00bffd44 	movi	r2,-11
 822a138:	00000f06 	br	822a178 <dhc_buildheader+0x1d0>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 822a13c:	e0bfff17 	ldw	r2,-4(fp)
 822a140:	11000704 	addi	r4,r2,28
 822a144:	008209b4 	movhi	r2,2086
 822a148:	10b6b204 	addi	r2,r2,-9528
 822a14c:	e0fffe17 	ldw	r3,-8(fp)
 822a150:	18c7883a 	add	r3,r3,r3
 822a154:	18c7883a 	add	r3,r3,r3
 822a158:	10c5883a 	add	r2,r2,r3
 822a15c:	10800017 	ldw	r2,0(r2)
 822a160:	10801717 	ldw	r2,92(r2)
 822a164:	e0fffd17 	ldw	r3,-12(fp)
 822a168:	180d883a 	mov	r6,r3
 822a16c:	100b883a 	mov	r5,r2
 822a170:	8202a0c0 	call	8202a0c <memcpy>

   /* return success */
   return 0;
 822a174:	0005883a 	mov	r2,zero
}
 822a178:	e037883a 	mov	sp,fp
 822a17c:	dfc00117 	ldw	ra,4(sp)
 822a180:	df000017 	ldw	fp,0(sp)
 822a184:	dec00204 	addi	sp,sp,8
 822a188:	f800283a 	ret

0822a18c <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 822a18c:	defff404 	addi	sp,sp,-48
 822a190:	dfc00b15 	stw	ra,44(sp)
 822a194:	df000a15 	stw	fp,40(sp)
 822a198:	dc400915 	stw	r17,36(sp)
 822a19c:	dc000815 	stw	r16,32(sp)
 822a1a0:	df000a04 	addi	fp,sp,40
 822a1a4:	e13ffd15 	stw	r4,-12(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 822a1a8:	000b883a 	mov	r5,zero
 822a1ac:	01004b04 	movi	r4,300
 822a1b0:	824503c0 	call	824503c <udp_alloc>
 822a1b4:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a1b8:	e0bff817 	ldw	r2,-32(fp)
 822a1bc:	1000021e 	bne	r2,zero,822a1c8 <dhc_discover+0x3c>
      return ENP_NOMEM;
 822a1c0:	00bffb04 	movi	r2,-20
 822a1c4:	00011d06 	br	822a63c <dhc_discover+0x4b0>
   pkt->nb_plen = sizeof(struct bootp);
 822a1c8:	e0bff817 	ldw	r2,-32(fp)
 822a1cc:	00c04b04 	movi	r3,300
 822a1d0:	10c00415 	stw	r3,16(r2)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 822a1d4:	d0a03317 	ldw	r2,-32564(gp)
 822a1d8:	10c00044 	addi	r3,r2,1
 822a1dc:	d0e03315 	stw	r3,-32564(gp)
 822a1e0:	1009883a 	mov	r4,r2
 822a1e4:	008209b4 	movhi	r2,2086
 822a1e8:	10b6d804 	addi	r2,r2,-9376
 822a1ec:	e0fffd17 	ldw	r3,-12(fp)
 822a1f0:	18c00f24 	muli	r3,r3,60
 822a1f4:	10c5883a 	add	r2,r2,r3
 822a1f8:	10800204 	addi	r2,r2,8
 822a1fc:	11000015 	stw	r4,0(r2)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 822a200:	823cf580 	call	823cf58 <sysuptime>
 822a204:	1007883a 	mov	r3,r2
 822a208:	00947b34 	movhi	r2,20972
 822a20c:	10a147c4 	addi	r2,r2,-31457
 822a210:	1888383a 	mulxuu	r4,r3,r2
 822a214:	1885383a 	mul	r2,r3,r2
 822a218:	1021883a 	mov	r16,r2
 822a21c:	2023883a 	mov	r17,r4
 822a220:	8804d17a 	srli	r2,r17,5
 822a224:	1009883a 	mov	r4,r2
 822a228:	008209b4 	movhi	r2,2086
 822a22c:	10b6d804 	addi	r2,r2,-9376
 822a230:	e0fffd17 	ldw	r3,-12(fp)
 822a234:	18c00f24 	muli	r3,r3,60
 822a238:	10c5883a 	add	r2,r2,r3
 822a23c:	10800304 	addi	r2,r2,12
 822a240:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 822a244:	e0bff817 	ldw	r2,-32(fp)
 822a248:	10800317 	ldw	r2,12(r2)
 822a24c:	e0bff915 	stw	r2,-28(fp)
   e = dhc_buildheader(iface,outbp);
 822a250:	e17ff917 	ldw	r5,-28(fp)
 822a254:	e13ffd17 	ldw	r4,-12(fp)
 822a258:	8229fa80 	call	8229fa8 <dhc_buildheader>
 822a25c:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822a260:	e0bffa17 	ldw	r2,-24(fp)
 822a264:	10000226 	beq	r2,zero,822a270 <dhc_discover+0xe4>
      return e;
 822a268:	e0bffa17 	ldw	r2,-24(fp)
 822a26c:	0000f306 	br	822a63c <dhc_discover+0x4b0>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a270:	e0bff917 	ldw	r2,-28(fp)
 822a274:	10c03b04 	addi	r3,r2,236
 822a278:	0098d534 	movhi	r2,25428
 822a27c:	10a098c4 	addi	r2,r2,-32157
 822a280:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 822a284:	e0bff917 	ldw	r2,-28(fp)
 822a288:	10803c04 	addi	r2,r2,240
 822a28c:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822a290:	e0bff617 	ldw	r2,-40(fp)
 822a294:	10c00044 	addi	r3,r2,1
 822a298:	e0fff615 	stw	r3,-40(fp)
 822a29c:	00c00d44 	movi	r3,53
 822a2a0:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a2a4:	e0bff617 	ldw	r2,-40(fp)
 822a2a8:	10c00044 	addi	r3,r2,1
 822a2ac:	e0fff615 	stw	r3,-40(fp)
 822a2b0:	00c00044 	movi	r3,1
 822a2b4:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_DISCOVER;
 822a2b8:	e0bff617 	ldw	r2,-40(fp)
 822a2bc:	10c00044 	addi	r3,r2,1
 822a2c0:	e0fff615 	stw	r3,-40(fp)
 822a2c4:	00c00044 	movi	r3,1
 822a2c8:	10c00005 	stb	r3,0(r2)
   leasetime = -1L ;    /* ask for infinite lease */
 822a2cc:	00bfffc4 	movi	r2,-1
 822a2d0:	e0bffb15 	stw	r2,-20(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 822a2d4:	e0bff617 	ldw	r2,-40(fp)
 822a2d8:	10c00044 	addi	r3,r2,1
 822a2dc:	e0fff615 	stw	r3,-40(fp)
 822a2e0:	00c00cc4 	movi	r3,51
 822a2e4:	10c00005 	stb	r3,0(r2)
 822a2e8:	e0bff617 	ldw	r2,-40(fp)
 822a2ec:	10c00044 	addi	r3,r2,1
 822a2f0:	e0fff615 	stw	r3,-40(fp)
 822a2f4:	00c00104 	movi	r3,4
 822a2f8:	10c00005 	stb	r3,0(r2)
 822a2fc:	e0bff617 	ldw	r2,-40(fp)
 822a300:	108000c4 	addi	r2,r2,3
 822a304:	e0fffb04 	addi	r3,fp,-20
 822a308:	18c00003 	ldbu	r3,0(r3)
 822a30c:	10c00005 	stb	r3,0(r2)
 822a310:	e0bff617 	ldw	r2,-40(fp)
 822a314:	10c00084 	addi	r3,r2,2
 822a318:	e0bffb04 	addi	r2,fp,-20
 822a31c:	10800044 	addi	r2,r2,1
 822a320:	10800003 	ldbu	r2,0(r2)
 822a324:	18800005 	stb	r2,0(r3)
 822a328:	e0bff617 	ldw	r2,-40(fp)
 822a32c:	10c00044 	addi	r3,r2,1
 822a330:	e0bffb04 	addi	r2,fp,-20
 822a334:	10800084 	addi	r2,r2,2
 822a338:	10800003 	ldbu	r2,0(r2)
 822a33c:	18800005 	stb	r2,0(r3)
 822a340:	e0bffb04 	addi	r2,fp,-20
 822a344:	108000c4 	addi	r2,r2,3
 822a348:	10800003 	ldbu	r2,0(r2)
 822a34c:	1007883a 	mov	r3,r2
 822a350:	e0bff617 	ldw	r2,-40(fp)
 822a354:	10c00005 	stb	r3,0(r2)
 822a358:	e0bff617 	ldw	r2,-40(fp)
 822a35c:	10800104 	addi	r2,r2,4
 822a360:	e0bff615 	stw	r2,-40(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 822a364:	008209b4 	movhi	r2,2086
 822a368:	10b6b204 	addi	r2,r2,-9528
 822a36c:	e0fffd17 	ldw	r3,-12(fp)
 822a370:	18c7883a 	add	r3,r3,r3
 822a374:	18c7883a 	add	r3,r3,r3
 822a378:	10c5883a 	add	r2,r2,r3
 822a37c:	10800017 	ldw	r2,0(r2)
 822a380:	10800a17 	ldw	r2,40(r2)
 822a384:	10004e26 	beq	r2,zero,822a4c0 <dhc_discover+0x334>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 822a388:	008209b4 	movhi	r2,2086
 822a38c:	10b6b204 	addi	r2,r2,-9528
 822a390:	e0fffd17 	ldw	r3,-12(fp)
 822a394:	18c7883a 	add	r3,r3,r3
 822a398:	18c7883a 	add	r3,r3,r3
 822a39c:	10c5883a 	add	r2,r2,r3
 822a3a0:	10800017 	ldw	r2,0(r2)
 822a3a4:	10800a17 	ldw	r2,40(r2)
 822a3a8:	1008d63a 	srli	r4,r2,24
 822a3ac:	008209b4 	movhi	r2,2086
 822a3b0:	10b6b204 	addi	r2,r2,-9528
 822a3b4:	e0fffd17 	ldw	r3,-12(fp)
 822a3b8:	18c7883a 	add	r3,r3,r3
 822a3bc:	18c7883a 	add	r3,r3,r3
 822a3c0:	10c5883a 	add	r2,r2,r3
 822a3c4:	10800017 	ldw	r2,0(r2)
 822a3c8:	10800a17 	ldw	r2,40(r2)
 822a3cc:	1004d23a 	srli	r2,r2,8
 822a3d0:	10bfc00c 	andi	r2,r2,65280
 822a3d4:	2088b03a 	or	r4,r4,r2
 822a3d8:	008209b4 	movhi	r2,2086
 822a3dc:	10b6b204 	addi	r2,r2,-9528
 822a3e0:	e0fffd17 	ldw	r3,-12(fp)
 822a3e4:	18c7883a 	add	r3,r3,r3
 822a3e8:	18c7883a 	add	r3,r3,r3
 822a3ec:	10c5883a 	add	r2,r2,r3
 822a3f0:	10800017 	ldw	r2,0(r2)
 822a3f4:	10800a17 	ldw	r2,40(r2)
 822a3f8:	10bfc00c 	andi	r2,r2,65280
 822a3fc:	1004923a 	slli	r2,r2,8
 822a400:	2088b03a 	or	r4,r4,r2
 822a404:	008209b4 	movhi	r2,2086
 822a408:	10b6b204 	addi	r2,r2,-9528
 822a40c:	e0fffd17 	ldw	r3,-12(fp)
 822a410:	18c7883a 	add	r3,r3,r3
 822a414:	18c7883a 	add	r3,r3,r3
 822a418:	10c5883a 	add	r2,r2,r3
 822a41c:	10800017 	ldw	r2,0(r2)
 822a420:	10800a17 	ldw	r2,40(r2)
 822a424:	1004963a 	slli	r2,r2,24
 822a428:	2084b03a 	or	r2,r4,r2
 822a42c:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 822a430:	e0bff617 	ldw	r2,-40(fp)
 822a434:	10c00044 	addi	r3,r2,1
 822a438:	e0fff615 	stw	r3,-40(fp)
 822a43c:	00c00c84 	movi	r3,50
 822a440:	10c00005 	stb	r3,0(r2)
 822a444:	e0bff617 	ldw	r2,-40(fp)
 822a448:	10c00044 	addi	r3,r2,1
 822a44c:	e0fff615 	stw	r3,-40(fp)
 822a450:	00c00104 	movi	r3,4
 822a454:	10c00005 	stb	r3,0(r2)
 822a458:	e0bff617 	ldw	r2,-40(fp)
 822a45c:	108000c4 	addi	r2,r2,3
 822a460:	e0fffc04 	addi	r3,fp,-16
 822a464:	18c00003 	ldbu	r3,0(r3)
 822a468:	10c00005 	stb	r3,0(r2)
 822a46c:	e0bff617 	ldw	r2,-40(fp)
 822a470:	10c00084 	addi	r3,r2,2
 822a474:	e0bffc04 	addi	r2,fp,-16
 822a478:	10800044 	addi	r2,r2,1
 822a47c:	10800003 	ldbu	r2,0(r2)
 822a480:	18800005 	stb	r2,0(r3)
 822a484:	e0bff617 	ldw	r2,-40(fp)
 822a488:	10c00044 	addi	r3,r2,1
 822a48c:	e0bffc04 	addi	r2,fp,-16
 822a490:	10800084 	addi	r2,r2,2
 822a494:	10800003 	ldbu	r2,0(r2)
 822a498:	18800005 	stb	r2,0(r3)
 822a49c:	e0bffc04 	addi	r2,fp,-16
 822a4a0:	108000c4 	addi	r2,r2,3
 822a4a4:	10800003 	ldbu	r2,0(r2)
 822a4a8:	1007883a 	mov	r3,r2
 822a4ac:	e0bff617 	ldw	r2,-40(fp)
 822a4b0:	10c00005 	stb	r3,0(r2)
 822a4b4:	e0bff617 	ldw	r2,-40(fp)
 822a4b8:	10800104 	addi	r2,r2,4
 822a4bc:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822a4c0:	d0a03517 	ldw	r2,-32556(gp)
 822a4c4:	00801a0e 	bge	zero,r2,822a530 <dhc_discover+0x3a4>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822a4c8:	e0bff617 	ldw	r2,-40(fp)
 822a4cc:	10c00044 	addi	r3,r2,1
 822a4d0:	e0fff615 	stw	r3,-40(fp)
 822a4d4:	00c00dc4 	movi	r3,55
 822a4d8:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822a4dc:	e0bff617 	ldw	r2,-40(fp)
 822a4e0:	10c00044 	addi	r3,r2,1
 822a4e4:	e0fff615 	stw	r3,-40(fp)
 822a4e8:	d0e03517 	ldw	r3,-32556(gp)
 822a4ec:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822a4f0:	e03ff715 	stw	zero,-36(fp)
 822a4f4:	00000b06 	br	822a524 <dhc_discover+0x398>
         *opts++ = reqlist[i];
 822a4f8:	e0bff617 	ldw	r2,-40(fp)
 822a4fc:	10c00044 	addi	r3,r2,1
 822a500:	e0fff615 	stw	r3,-40(fp)
 822a504:	e13ff717 	ldw	r4,-36(fp)
 822a508:	d0e03404 	addi	r3,gp,-32560
 822a50c:	20c7883a 	add	r3,r4,r3
 822a510:	18c00003 	ldbu	r3,0(r3)
 822a514:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822a518:	e0bff717 	ldw	r2,-36(fp)
 822a51c:	10800044 	addi	r2,r2,1
 822a520:	e0bff715 	stw	r2,-36(fp)
 822a524:	d0a03517 	ldw	r2,-32556(gp)
 822a528:	e0fff717 	ldw	r3,-36(fp)
 822a52c:	18bff216 	blt	r3,r2,822a4f8 <dhc_discover+0x36c>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 822a530:	e0bff617 	ldw	r2,-40(fp)
 822a534:	10c00044 	addi	r3,r2,1
 822a538:	e0fff615 	stw	r3,-40(fp)
 822a53c:	00ffffc4 	movi	r3,-1
 822a540:	10c00005 	stb	r3,0(r2)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 822a544:	d0e0a817 	ldw	r3,-32096(gp)
 822a548:	008209b4 	movhi	r2,2086
 822a54c:	10b6d804 	addi	r2,r2,-9376
 822a550:	e13ffd17 	ldw	r4,-12(fp)
 822a554:	21000f24 	muli	r4,r4,60
 822a558:	1105883a 	add	r2,r2,r4
 822a55c:	10800404 	addi	r2,r2,16
 822a560:	10c00015 	stw	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 822a564:	e0bff817 	ldw	r2,-32(fp)
 822a568:	00ffffc4 	movi	r3,-1
 822a56c:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822a570:	008209b4 	movhi	r2,2086
 822a574:	10b6b204 	addi	r2,r2,-9528
 822a578:	e0fffd17 	ldw	r3,-12(fp)
 822a57c:	18c7883a 	add	r3,r3,r3
 822a580:	18c7883a 	add	r3,r3,r3
 822a584:	10c5883a 	add	r2,r2,r3
 822a588:	10c00017 	ldw	r3,0(r2)
 822a58c:	e0bff817 	ldw	r2,-32(fp)
 822a590:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 822a594:	008209b4 	movhi	r2,2086
 822a598:	10b6d804 	addi	r2,r2,-9376
 822a59c:	e0fffd17 	ldw	r3,-12(fp)
 822a5a0:	18c00f24 	muli	r3,r3,60
 822a5a4:	10c5883a 	add	r2,r2,r3
 822a5a8:	10800017 	ldw	r2,0(r2)
 822a5ac:	10800120 	cmpeqi	r2,r2,4
 822a5b0:	1000031e 	bne	r2,zero,822a5c0 <dhc_discover+0x434>
      dhc_set_state(iface, DHCS_SELECTING);
 822a5b4:	01400104 	movi	r5,4
 822a5b8:	e13ffd17 	ldw	r4,-12(fp)
 822a5bc:	822c2140 	call	822c214 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822a5c0:	e1bff817 	ldw	r6,-32(fp)
 822a5c4:	01401104 	movi	r5,68
 822a5c8:	010010c4 	movi	r4,67
 822a5cc:	8244c000 	call	8244c00 <udp_send>
   dsc_discovers++;
 822a5d0:	d0a09117 	ldw	r2,-32188(gp)
 822a5d4:	10800044 	addi	r2,r2,1
 822a5d8:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 822a5dc:	d0e0a817 	ldw	r3,-32096(gp)
 822a5e0:	008209b4 	movhi	r2,2086
 822a5e4:	10b6d804 	addi	r2,r2,-9376
 822a5e8:	e13ffd17 	ldw	r4,-12(fp)
 822a5ec:	21000f24 	muli	r4,r4,60
 822a5f0:	1105883a 	add	r2,r2,r4
 822a5f4:	10800404 	addi	r2,r2,16
 822a5f8:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822a5fc:	008209b4 	movhi	r2,2086
 822a600:	10b6d804 	addi	r2,r2,-9376
 822a604:	e0fffd17 	ldw	r3,-12(fp)
 822a608:	18c00f24 	muli	r3,r3,60
 822a60c:	10c5883a 	add	r2,r2,r3
 822a610:	10800104 	addi	r2,r2,4
 822a614:	10800017 	ldw	r2,0(r2)
 822a618:	10c00044 	addi	r3,r2,1
 822a61c:	008209b4 	movhi	r2,2086
 822a620:	10b6d804 	addi	r2,r2,-9376
 822a624:	e13ffd17 	ldw	r4,-12(fp)
 822a628:	21000f24 	muli	r4,r4,60
 822a62c:	1105883a 	add	r2,r2,r4
 822a630:	10800104 	addi	r2,r2,4
 822a634:	10c00015 	stw	r3,0(r2)

   return 0;
 822a638:	0005883a 	mov	r2,zero
}
 822a63c:	e6fffe04 	addi	sp,fp,-8
 822a640:	dfc00317 	ldw	ra,12(sp)
 822a644:	df000217 	ldw	fp,8(sp)
 822a648:	dc400117 	ldw	r17,4(sp)
 822a64c:	dc000017 	ldw	r16,0(sp)
 822a650:	dec00404 	addi	sp,sp,16
 822a654:	f800283a 	ret

0822a658 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 822a658:	defff904 	addi	sp,sp,-28
 822a65c:	dfc00615 	stw	ra,24(sp)
 822a660:	df000515 	stw	fp,20(sp)
 822a664:	df000504 	addi	fp,sp,20
 822a668:	e13ffd15 	stw	r4,-12(fp)
 822a66c:	e17ffe15 	stw	r5,-8(fp)
 822a670:	e1bfff15 	stw	r6,-4(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 822a674:	008209b4 	movhi	r2,2086
 822a678:	10b6d804 	addi	r2,r2,-9376
 822a67c:	e0fffd17 	ldw	r3,-12(fp)
 822a680:	18c00f24 	muli	r3,r3,60
 822a684:	10c5883a 	add	r2,r2,r3
 822a688:	10800204 	addi	r2,r2,8
 822a68c:	10c00017 	ldw	r3,0(r2)
 822a690:	e0bffe17 	ldw	r2,-8(fp)
 822a694:	10800117 	ldw	r2,4(r2)
 822a698:	18800226 	beq	r3,r2,822a6a4 <dhc_rx_offer+0x4c>
      return ENP_NOT_MINE;
 822a69c:	00800084 	movi	r2,2
 822a6a0:	00002106 	br	822a728 <dhc_rx_offer+0xd0>

   opts = &bp->options[4];    /* examine options after cookie */
 822a6a4:	e0bffe17 	ldw	r2,-8(fp)
 822a6a8:	10803c04 	addi	r2,r2,240
 822a6ac:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 822a6b0:	e17ffb17 	ldw	r5,-20(fp)
 822a6b4:	e13ffd17 	ldw	r4,-12(fp)
 822a6b8:	822b6d40 	call	822b6d4 <dhc_extract_opts>
 822a6bc:	e0bffc15 	stw	r2,-16(fp)
   if (e)   /* parse error? */
 822a6c0:	e0bffc17 	ldw	r2,-16(fp)
 822a6c4:	10000326 	beq	r2,zero,822a6d4 <dhc_rx_offer+0x7c>
   {
      dtrap();
 822a6c8:	822d1c80 	call	822d1c8 <dtrap>
      return e;
 822a6cc:	e0bffc17 	ldw	r2,-16(fp)
 822a6d0:	00001506 	br	822a728 <dhc_rx_offer+0xd0>
   }
   if (!bp->yiaddr)  /* require an IP address */
 822a6d4:	e0bffe17 	ldw	r2,-8(fp)
 822a6d8:	10800417 	ldw	r2,16(r2)
 822a6dc:	1000061e 	bne	r2,zero,822a6f8 <dhc_rx_offer+0xa0>
   {
      dhc_decline(iface,bp, bplen);
 822a6e0:	e1bfff17 	ldw	r6,-4(fp)
 822a6e4:	e17ffe17 	ldw	r5,-8(fp)
 822a6e8:	e13ffd17 	ldw	r4,-12(fp)
 822a6ec:	822b5200 	call	822b520 <dhc_decline>
      return ENP_NOT_MINE;
 822a6f0:	00800084 	movi	r2,2
 822a6f4:	00000c06 	br	822a728 <dhc_rx_offer+0xd0>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 822a6f8:	e0bffe17 	ldw	r2,-8(fp)
 822a6fc:	10c00417 	ldw	r3,16(r2)
 822a700:	008209b4 	movhi	r2,2086
 822a704:	10b6d804 	addi	r2,r2,-9376
 822a708:	e13ffd17 	ldw	r4,-12(fp)
 822a70c:	21000f24 	muli	r4,r4,60
 822a710:	1105883a 	add	r2,r2,r4
 822a714:	10800904 	addi	r2,r2,36
 822a718:	10c00015 	stw	r3,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 822a71c:	000b883a 	mov	r5,zero
 822a720:	e13ffd17 	ldw	r4,-12(fp)
 822a724:	822a73c0 	call	822a73c <dhc_request>
}
 822a728:	e037883a 	mov	sp,fp
 822a72c:	dfc00117 	ldw	ra,4(sp)
 822a730:	df000017 	ldw	fp,0(sp)
 822a734:	dec00204 	addi	sp,sp,8
 822a738:	f800283a 	ret

0822a73c <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 822a73c:	defff404 	addi	sp,sp,-48
 822a740:	dfc00b15 	stw	ra,44(sp)
 822a744:	df000a15 	stw	fp,40(sp)
 822a748:	df000a04 	addi	fp,sp,40
 822a74c:	e13ffe15 	stw	r4,-8(fp)
 822a750:	e17fff15 	stw	r5,-4(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 822a754:	000b883a 	mov	r5,zero
 822a758:	01008904 	movi	r4,548
 822a75c:	824503c0 	call	824503c <udp_alloc>
 822a760:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a764:	e0bff817 	ldw	r2,-32(fp)
 822a768:	1000021e 	bne	r2,zero,822a774 <dhc_request+0x38>
      return ENP_NOMEM;
 822a76c:	00bffb04 	movi	r2,-20
 822a770:	00028e06 	br	822b1ac <dhc_request+0xa70>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 822a774:	e0bff817 	ldw	r2,-32(fp)
 822a778:	00c03b04 	movi	r3,236
 822a77c:	10c00415 	stw	r3,16(r2)

   if ( xid_flag == TRUE )
 822a780:	e0bfff17 	ldw	r2,-4(fp)
 822a784:	10800058 	cmpnei	r2,r2,1
 822a788:	1000121e 	bne	r2,zero,822a7d4 <dhc_request+0x98>
   {
      dhc_states[iface].xid  = xids++;
 822a78c:	d0a03317 	ldw	r2,-32564(gp)
 822a790:	10c00044 	addi	r3,r2,1
 822a794:	d0e03315 	stw	r3,-32564(gp)
 822a798:	1009883a 	mov	r4,r2
 822a79c:	008209b4 	movhi	r2,2086
 822a7a0:	10b6d804 	addi	r2,r2,-9376
 822a7a4:	e0fffe17 	ldw	r3,-8(fp)
 822a7a8:	18c00f24 	muli	r3,r3,60
 822a7ac:	10c5883a 	add	r2,r2,r3
 822a7b0:	10800204 	addi	r2,r2,8
 822a7b4:	11000015 	stw	r4,0(r2)
      dhc_states[iface].secs = 0;
 822a7b8:	008209b4 	movhi	r2,2086
 822a7bc:	10b6d804 	addi	r2,r2,-9376
 822a7c0:	e0fffe17 	ldw	r3,-8(fp)
 822a7c4:	18c00f24 	muli	r3,r3,60
 822a7c8:	10c5883a 	add	r2,r2,r3
 822a7cc:	10800304 	addi	r2,r2,12
 822a7d0:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 822a7d4:	e0bff817 	ldw	r2,-32(fp)
 822a7d8:	10800317 	ldw	r2,12(r2)
 822a7dc:	e0bff915 	stw	r2,-28(fp)
   e     = dhc_buildheader(iface,outbp);
 822a7e0:	e17ff917 	ldw	r5,-28(fp)
 822a7e4:	e13ffe17 	ldw	r4,-8(fp)
 822a7e8:	8229fa80 	call	8229fa8 <dhc_buildheader>
 822a7ec:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822a7f0:	e0bffa17 	ldw	r2,-24(fp)
 822a7f4:	10000226 	beq	r2,zero,822a800 <dhc_request+0xc4>
      return e;
 822a7f8:	e0bffa17 	ldw	r2,-24(fp)
 822a7fc:	00026b06 	br	822b1ac <dhc_request+0xa70>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a800:	e0bff917 	ldw	r2,-28(fp)
 822a804:	10c03b04 	addi	r3,r2,236
 822a808:	0098d534 	movhi	r2,25428
 822a80c:	10a098c4 	addi	r2,r2,-32157
 822a810:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 822a814:	e0bff917 	ldw	r2,-28(fp)
 822a818:	10803c04 	addi	r2,r2,240
 822a81c:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822a820:	e0bff617 	ldw	r2,-40(fp)
 822a824:	10c00044 	addi	r3,r2,1
 822a828:	e0fff615 	stw	r3,-40(fp)
 822a82c:	00c00d44 	movi	r3,53
 822a830:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a834:	e0bff617 	ldw	r2,-40(fp)
 822a838:	10c00044 	addi	r3,r2,1
 822a83c:	e0fff615 	stw	r3,-40(fp)
 822a840:	00c00044 	movi	r3,1
 822a844:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_REQUEST;
 822a848:	e0bff617 	ldw	r2,-40(fp)
 822a84c:	10c00044 	addi	r3,r2,1
 822a850:	e0fff615 	stw	r3,-40(fp)
 822a854:	00c000c4 	movi	r3,3
 822a858:	10c00005 	stb	r3,0(r2)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822a85c:	008209b4 	movhi	r2,2086
 822a860:	10b6d804 	addi	r2,r2,-9376
 822a864:	e0fffe17 	ldw	r3,-8(fp)
 822a868:	18c00f24 	muli	r3,r3,60
 822a86c:	10c5883a 	add	r2,r2,r3
 822a870:	10800017 	ldw	r2,0(r2)
 822a874:	10800120 	cmpeqi	r2,r2,4
 822a878:	1000181e 	bne	r2,zero,822a8dc <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822a87c:	008209b4 	movhi	r2,2086
 822a880:	10b6d804 	addi	r2,r2,-9376
 822a884:	e0fffe17 	ldw	r3,-8(fp)
 822a888:	18c00f24 	muli	r3,r3,60
 822a88c:	10c5883a 	add	r2,r2,r3
 822a890:	10800017 	ldw	r2,0(r2)
   *opts++ = DHOP_TYPE;
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822a894:	10800160 	cmpeqi	r2,r2,5
 822a898:	1000101e 	bne	r2,zero,822a8dc <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822a89c:	008209b4 	movhi	r2,2086
 822a8a0:	10b6d804 	addi	r2,r2,-9376
 822a8a4:	e0fffe17 	ldw	r3,-8(fp)
 822a8a8:	18c00f24 	muli	r3,r3,60
 822a8ac:	10c5883a 	add	r2,r2,r3
 822a8b0:	10800017 	ldw	r2,0(r2)
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822a8b4:	108000e0 	cmpeqi	r2,r2,3
 822a8b8:	1000081e 	bne	r2,zero,822a8dc <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
 822a8bc:	008209b4 	movhi	r2,2086
 822a8c0:	10b6d804 	addi	r2,r2,-9376
 822a8c4:	e0fffe17 	ldw	r3,-8(fp)
 822a8c8:	18c00f24 	muli	r3,r3,60
 822a8cc:	10c5883a 	add	r2,r2,r3
 822a8d0:	10800017 	ldw	r2,0(r2)
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822a8d4:	10800098 	cmpnei	r2,r2,2
 822a8d8:	10004a1e 	bne	r2,zero,822aa04 <dhc_request+0x2c8>
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 822a8dc:	008209b4 	movhi	r2,2086
 822a8e0:	10b6d804 	addi	r2,r2,-9376
 822a8e4:	e0fffe17 	ldw	r3,-8(fp)
 822a8e8:	18c00f24 	muli	r3,r3,60
 822a8ec:	10c5883a 	add	r2,r2,r3
 822a8f0:	10800904 	addi	r2,r2,36
 822a8f4:	10800017 	ldw	r2,0(r2)
 822a8f8:	1006d63a 	srli	r3,r2,24
 822a8fc:	008209b4 	movhi	r2,2086
 822a900:	10b6d804 	addi	r2,r2,-9376
 822a904:	e13ffe17 	ldw	r4,-8(fp)
 822a908:	21000f24 	muli	r4,r4,60
 822a90c:	1105883a 	add	r2,r2,r4
 822a910:	10800904 	addi	r2,r2,36
 822a914:	10800017 	ldw	r2,0(r2)
 822a918:	1004d23a 	srli	r2,r2,8
 822a91c:	10bfc00c 	andi	r2,r2,65280
 822a920:	1886b03a 	or	r3,r3,r2
 822a924:	008209b4 	movhi	r2,2086
 822a928:	10b6d804 	addi	r2,r2,-9376
 822a92c:	e13ffe17 	ldw	r4,-8(fp)
 822a930:	21000f24 	muli	r4,r4,60
 822a934:	1105883a 	add	r2,r2,r4
 822a938:	10800904 	addi	r2,r2,36
 822a93c:	10800017 	ldw	r2,0(r2)
 822a940:	10bfc00c 	andi	r2,r2,65280
 822a944:	1004923a 	slli	r2,r2,8
 822a948:	1886b03a 	or	r3,r3,r2
 822a94c:	008209b4 	movhi	r2,2086
 822a950:	10b6d804 	addi	r2,r2,-9376
 822a954:	e13ffe17 	ldw	r4,-8(fp)
 822a958:	21000f24 	muli	r4,r4,60
 822a95c:	1105883a 	add	r2,r2,r4
 822a960:	10800904 	addi	r2,r2,36
 822a964:	10800017 	ldw	r2,0(r2)
 822a968:	1004963a 	slli	r2,r2,24
 822a96c:	1884b03a 	or	r2,r3,r2
 822a970:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 822a974:	e0bff617 	ldw	r2,-40(fp)
 822a978:	10c00044 	addi	r3,r2,1
 822a97c:	e0fff615 	stw	r3,-40(fp)
 822a980:	00c00c84 	movi	r3,50
 822a984:	10c00005 	stb	r3,0(r2)
 822a988:	e0bff617 	ldw	r2,-40(fp)
 822a98c:	10c00044 	addi	r3,r2,1
 822a990:	e0fff615 	stw	r3,-40(fp)
 822a994:	00c00104 	movi	r3,4
 822a998:	10c00005 	stb	r3,0(r2)
 822a99c:	e0bff617 	ldw	r2,-40(fp)
 822a9a0:	108000c4 	addi	r2,r2,3
 822a9a4:	e0fffd04 	addi	r3,fp,-12
 822a9a8:	18c00003 	ldbu	r3,0(r3)
 822a9ac:	10c00005 	stb	r3,0(r2)
 822a9b0:	e0bff617 	ldw	r2,-40(fp)
 822a9b4:	10c00084 	addi	r3,r2,2
 822a9b8:	e0bffd04 	addi	r2,fp,-12
 822a9bc:	10800044 	addi	r2,r2,1
 822a9c0:	10800003 	ldbu	r2,0(r2)
 822a9c4:	18800005 	stb	r2,0(r3)
 822a9c8:	e0bff617 	ldw	r2,-40(fp)
 822a9cc:	10c00044 	addi	r3,r2,1
 822a9d0:	e0bffd04 	addi	r2,fp,-12
 822a9d4:	10800084 	addi	r2,r2,2
 822a9d8:	10800003 	ldbu	r2,0(r2)
 822a9dc:	18800005 	stb	r2,0(r3)
 822a9e0:	e0bffd04 	addi	r2,fp,-12
 822a9e4:	108000c4 	addi	r2,r2,3
 822a9e8:	10800003 	ldbu	r2,0(r2)
 822a9ec:	1007883a 	mov	r3,r2
 822a9f0:	e0bff617 	ldw	r2,-40(fp)
 822a9f4:	10c00005 	stb	r3,0(r2)
 822a9f8:	e0bff617 	ldw	r2,-40(fp)
 822a9fc:	10800104 	addi	r2,r2,4
 822aa00:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].snmask)
 822aa04:	008209b4 	movhi	r2,2086
 822aa08:	10b6d804 	addi	r2,r2,-9376
 822aa0c:	e0fffe17 	ldw	r3,-8(fp)
 822aa10:	18c00f24 	muli	r3,r3,60
 822aa14:	10c5883a 	add	r2,r2,r3
 822aa18:	10800a04 	addi	r2,r2,40
 822aa1c:	10800017 	ldw	r2,0(r2)
 822aa20:	10004a26 	beq	r2,zero,822ab4c <dhc_request+0x410>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 822aa24:	008209b4 	movhi	r2,2086
 822aa28:	10b6d804 	addi	r2,r2,-9376
 822aa2c:	e0fffe17 	ldw	r3,-8(fp)
 822aa30:	18c00f24 	muli	r3,r3,60
 822aa34:	10c5883a 	add	r2,r2,r3
 822aa38:	10800a04 	addi	r2,r2,40
 822aa3c:	10800017 	ldw	r2,0(r2)
 822aa40:	1006d63a 	srli	r3,r2,24
 822aa44:	008209b4 	movhi	r2,2086
 822aa48:	10b6d804 	addi	r2,r2,-9376
 822aa4c:	e13ffe17 	ldw	r4,-8(fp)
 822aa50:	21000f24 	muli	r4,r4,60
 822aa54:	1105883a 	add	r2,r2,r4
 822aa58:	10800a04 	addi	r2,r2,40
 822aa5c:	10800017 	ldw	r2,0(r2)
 822aa60:	1004d23a 	srli	r2,r2,8
 822aa64:	10bfc00c 	andi	r2,r2,65280
 822aa68:	1886b03a 	or	r3,r3,r2
 822aa6c:	008209b4 	movhi	r2,2086
 822aa70:	10b6d804 	addi	r2,r2,-9376
 822aa74:	e13ffe17 	ldw	r4,-8(fp)
 822aa78:	21000f24 	muli	r4,r4,60
 822aa7c:	1105883a 	add	r2,r2,r4
 822aa80:	10800a04 	addi	r2,r2,40
 822aa84:	10800017 	ldw	r2,0(r2)
 822aa88:	10bfc00c 	andi	r2,r2,65280
 822aa8c:	1004923a 	slli	r2,r2,8
 822aa90:	1886b03a 	or	r3,r3,r2
 822aa94:	008209b4 	movhi	r2,2086
 822aa98:	10b6d804 	addi	r2,r2,-9376
 822aa9c:	e13ffe17 	ldw	r4,-8(fp)
 822aaa0:	21000f24 	muli	r4,r4,60
 822aaa4:	1105883a 	add	r2,r2,r4
 822aaa8:	10800a04 	addi	r2,r2,40
 822aaac:	10800017 	ldw	r2,0(r2)
 822aab0:	1004963a 	slli	r2,r2,24
 822aab4:	1884b03a 	or	r2,r3,r2
 822aab8:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 822aabc:	e0bff617 	ldw	r2,-40(fp)
 822aac0:	10c00044 	addi	r3,r2,1
 822aac4:	e0fff615 	stw	r3,-40(fp)
 822aac8:	00c00044 	movi	r3,1
 822aacc:	10c00005 	stb	r3,0(r2)
 822aad0:	e0bff617 	ldw	r2,-40(fp)
 822aad4:	10c00044 	addi	r3,r2,1
 822aad8:	e0fff615 	stw	r3,-40(fp)
 822aadc:	00c00104 	movi	r3,4
 822aae0:	10c00005 	stb	r3,0(r2)
 822aae4:	e0bff617 	ldw	r2,-40(fp)
 822aae8:	108000c4 	addi	r2,r2,3
 822aaec:	e0fffd04 	addi	r3,fp,-12
 822aaf0:	18c00003 	ldbu	r3,0(r3)
 822aaf4:	10c00005 	stb	r3,0(r2)
 822aaf8:	e0bff617 	ldw	r2,-40(fp)
 822aafc:	10c00084 	addi	r3,r2,2
 822ab00:	e0bffd04 	addi	r2,fp,-12
 822ab04:	10800044 	addi	r2,r2,1
 822ab08:	10800003 	ldbu	r2,0(r2)
 822ab0c:	18800005 	stb	r2,0(r3)
 822ab10:	e0bff617 	ldw	r2,-40(fp)
 822ab14:	10c00044 	addi	r3,r2,1
 822ab18:	e0bffd04 	addi	r2,fp,-12
 822ab1c:	10800084 	addi	r2,r2,2
 822ab20:	10800003 	ldbu	r2,0(r2)
 822ab24:	18800005 	stb	r2,0(r3)
 822ab28:	e0bffd04 	addi	r2,fp,-12
 822ab2c:	108000c4 	addi	r2,r2,3
 822ab30:	10800003 	ldbu	r2,0(r2)
 822ab34:	1007883a 	mov	r3,r2
 822ab38:	e0bff617 	ldw	r2,-40(fp)
 822ab3c:	10c00005 	stb	r3,0(r2)
 822ab40:	e0bff617 	ldw	r2,-40(fp)
 822ab44:	10800104 	addi	r2,r2,4
 822ab48:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].defgw)
 822ab4c:	008209b4 	movhi	r2,2086
 822ab50:	10b6d804 	addi	r2,r2,-9376
 822ab54:	e0fffe17 	ldw	r3,-8(fp)
 822ab58:	18c00f24 	muli	r3,r3,60
 822ab5c:	10c5883a 	add	r2,r2,r3
 822ab60:	10800b04 	addi	r2,r2,44
 822ab64:	10800017 	ldw	r2,0(r2)
 822ab68:	10004a26 	beq	r2,zero,822ac94 <dhc_request+0x558>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 822ab6c:	008209b4 	movhi	r2,2086
 822ab70:	10b6d804 	addi	r2,r2,-9376
 822ab74:	e0fffe17 	ldw	r3,-8(fp)
 822ab78:	18c00f24 	muli	r3,r3,60
 822ab7c:	10c5883a 	add	r2,r2,r3
 822ab80:	10800b04 	addi	r2,r2,44
 822ab84:	10800017 	ldw	r2,0(r2)
 822ab88:	1006d63a 	srli	r3,r2,24
 822ab8c:	008209b4 	movhi	r2,2086
 822ab90:	10b6d804 	addi	r2,r2,-9376
 822ab94:	e13ffe17 	ldw	r4,-8(fp)
 822ab98:	21000f24 	muli	r4,r4,60
 822ab9c:	1105883a 	add	r2,r2,r4
 822aba0:	10800b04 	addi	r2,r2,44
 822aba4:	10800017 	ldw	r2,0(r2)
 822aba8:	1004d23a 	srli	r2,r2,8
 822abac:	10bfc00c 	andi	r2,r2,65280
 822abb0:	1886b03a 	or	r3,r3,r2
 822abb4:	008209b4 	movhi	r2,2086
 822abb8:	10b6d804 	addi	r2,r2,-9376
 822abbc:	e13ffe17 	ldw	r4,-8(fp)
 822abc0:	21000f24 	muli	r4,r4,60
 822abc4:	1105883a 	add	r2,r2,r4
 822abc8:	10800b04 	addi	r2,r2,44
 822abcc:	10800017 	ldw	r2,0(r2)
 822abd0:	10bfc00c 	andi	r2,r2,65280
 822abd4:	1004923a 	slli	r2,r2,8
 822abd8:	1886b03a 	or	r3,r3,r2
 822abdc:	008209b4 	movhi	r2,2086
 822abe0:	10b6d804 	addi	r2,r2,-9376
 822abe4:	e13ffe17 	ldw	r4,-8(fp)
 822abe8:	21000f24 	muli	r4,r4,60
 822abec:	1105883a 	add	r2,r2,r4
 822abf0:	10800b04 	addi	r2,r2,44
 822abf4:	10800017 	ldw	r2,0(r2)
 822abf8:	1004963a 	slli	r2,r2,24
 822abfc:	1884b03a 	or	r2,r3,r2
 822ac00:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 822ac04:	e0bff617 	ldw	r2,-40(fp)
 822ac08:	10c00044 	addi	r3,r2,1
 822ac0c:	e0fff615 	stw	r3,-40(fp)
 822ac10:	00c000c4 	movi	r3,3
 822ac14:	10c00005 	stb	r3,0(r2)
 822ac18:	e0bff617 	ldw	r2,-40(fp)
 822ac1c:	10c00044 	addi	r3,r2,1
 822ac20:	e0fff615 	stw	r3,-40(fp)
 822ac24:	00c00104 	movi	r3,4
 822ac28:	10c00005 	stb	r3,0(r2)
 822ac2c:	e0bff617 	ldw	r2,-40(fp)
 822ac30:	108000c4 	addi	r2,r2,3
 822ac34:	e0fffd04 	addi	r3,fp,-12
 822ac38:	18c00003 	ldbu	r3,0(r3)
 822ac3c:	10c00005 	stb	r3,0(r2)
 822ac40:	e0bff617 	ldw	r2,-40(fp)
 822ac44:	10c00084 	addi	r3,r2,2
 822ac48:	e0bffd04 	addi	r2,fp,-12
 822ac4c:	10800044 	addi	r2,r2,1
 822ac50:	10800003 	ldbu	r2,0(r2)
 822ac54:	18800005 	stb	r2,0(r3)
 822ac58:	e0bff617 	ldw	r2,-40(fp)
 822ac5c:	10c00044 	addi	r3,r2,1
 822ac60:	e0bffd04 	addi	r2,fp,-12
 822ac64:	10800084 	addi	r2,r2,2
 822ac68:	10800003 	ldbu	r2,0(r2)
 822ac6c:	18800005 	stb	r2,0(r3)
 822ac70:	e0bffd04 	addi	r2,fp,-12
 822ac74:	108000c4 	addi	r2,r2,3
 822ac78:	10800003 	ldbu	r2,0(r2)
 822ac7c:	1007883a 	mov	r3,r2
 822ac80:	e0bff617 	ldw	r2,-40(fp)
 822ac84:	10c00005 	stb	r3,0(r2)
 822ac88:	e0bff617 	ldw	r2,-40(fp)
 822ac8c:	10800104 	addi	r2,r2,4
 822ac90:	e0bff615 	stw	r2,-40(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 822ac94:	008209b4 	movhi	r2,2086
 822ac98:	10b6d804 	addi	r2,r2,-9376
 822ac9c:	e0fffe17 	ldw	r3,-8(fp)
 822aca0:	18c00f24 	muli	r3,r3,60
 822aca4:	10c5883a 	add	r2,r2,r3
 822aca8:	10800504 	addi	r2,r2,20
 822acac:	10800017 	ldw	r2,0(r2)
 822acb0:	10003826 	beq	r2,zero,822ad94 <dhc_request+0x658>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 822acb4:	e0bff617 	ldw	r2,-40(fp)
 822acb8:	10c00044 	addi	r3,r2,1
 822acbc:	e0fff615 	stw	r3,-40(fp)
 822acc0:	00c00cc4 	movi	r3,51
 822acc4:	10c00005 	stb	r3,0(r2)
 822acc8:	e0bff617 	ldw	r2,-40(fp)
 822accc:	10c00044 	addi	r3,r2,1
 822acd0:	e0fff615 	stw	r3,-40(fp)
 822acd4:	00c00104 	movi	r3,4
 822acd8:	10c00005 	stb	r3,0(r2)
 822acdc:	e0bff617 	ldw	r2,-40(fp)
 822ace0:	10c000c4 	addi	r3,r2,3
 822ace4:	e0bffe17 	ldw	r2,-8(fp)
 822ace8:	10800f24 	muli	r2,r2,60
 822acec:	11000504 	addi	r4,r2,20
 822acf0:	008209b4 	movhi	r2,2086
 822acf4:	10b6d804 	addi	r2,r2,-9376
 822acf8:	2085883a 	add	r2,r4,r2
 822acfc:	10800003 	ldbu	r2,0(r2)
 822ad00:	18800005 	stb	r2,0(r3)
 822ad04:	e0bff617 	ldw	r2,-40(fp)
 822ad08:	10c00084 	addi	r3,r2,2
 822ad0c:	e0bffe17 	ldw	r2,-8(fp)
 822ad10:	10800f24 	muli	r2,r2,60
 822ad14:	11000504 	addi	r4,r2,20
 822ad18:	008209b4 	movhi	r2,2086
 822ad1c:	10b6d804 	addi	r2,r2,-9376
 822ad20:	2085883a 	add	r2,r4,r2
 822ad24:	10800044 	addi	r2,r2,1
 822ad28:	10800003 	ldbu	r2,0(r2)
 822ad2c:	18800005 	stb	r2,0(r3)
 822ad30:	e0bff617 	ldw	r2,-40(fp)
 822ad34:	10c00044 	addi	r3,r2,1
 822ad38:	e0bffe17 	ldw	r2,-8(fp)
 822ad3c:	10800f24 	muli	r2,r2,60
 822ad40:	11000504 	addi	r4,r2,20
 822ad44:	008209b4 	movhi	r2,2086
 822ad48:	10b6d804 	addi	r2,r2,-9376
 822ad4c:	2085883a 	add	r2,r4,r2
 822ad50:	10800084 	addi	r2,r2,2
 822ad54:	10800003 	ldbu	r2,0(r2)
 822ad58:	18800005 	stb	r2,0(r3)
 822ad5c:	e0bffe17 	ldw	r2,-8(fp)
 822ad60:	10800f24 	muli	r2,r2,60
 822ad64:	10c00504 	addi	r3,r2,20
 822ad68:	008209b4 	movhi	r2,2086
 822ad6c:	10b6d804 	addi	r2,r2,-9376
 822ad70:	1885883a 	add	r2,r3,r2
 822ad74:	108000c4 	addi	r2,r2,3
 822ad78:	10800003 	ldbu	r2,0(r2)
 822ad7c:	1007883a 	mov	r3,r2
 822ad80:	e0bff617 	ldw	r2,-40(fp)
 822ad84:	10c00005 	stb	r3,0(r2)
 822ad88:	e0bff617 	ldw	r2,-40(fp)
 822ad8c:	10800104 	addi	r2,r2,4
 822ad90:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822ad94:	d0a03517 	ldw	r2,-32556(gp)
 822ad98:	00801a0e 	bge	zero,r2,822ae04 <dhc_request+0x6c8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822ad9c:	e0bff617 	ldw	r2,-40(fp)
 822ada0:	10c00044 	addi	r3,r2,1
 822ada4:	e0fff615 	stw	r3,-40(fp)
 822ada8:	00c00dc4 	movi	r3,55
 822adac:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822adb0:	e0bff617 	ldw	r2,-40(fp)
 822adb4:	10c00044 	addi	r3,r2,1
 822adb8:	e0fff615 	stw	r3,-40(fp)
 822adbc:	d0e03517 	ldw	r3,-32556(gp)
 822adc0:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822adc4:	e03ff715 	stw	zero,-36(fp)
 822adc8:	00000b06 	br	822adf8 <dhc_request+0x6bc>
         *opts++ = reqlist[i];
 822adcc:	e0bff617 	ldw	r2,-40(fp)
 822add0:	10c00044 	addi	r3,r2,1
 822add4:	e0fff615 	stw	r3,-40(fp)
 822add8:	e13ff717 	ldw	r4,-36(fp)
 822addc:	d0e03404 	addi	r3,gp,-32560
 822ade0:	20c7883a 	add	r3,r4,r3
 822ade4:	18c00003 	ldbu	r3,0(r3)
 822ade8:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822adec:	e0bff717 	ldw	r2,-36(fp)
 822adf0:	10800044 	addi	r2,r2,1
 822adf4:	e0bff715 	stw	r2,-36(fp)
 822adf8:	d0a03517 	ldw	r2,-32556(gp)
 822adfc:	e0fff717 	ldw	r3,-36(fp)
 822ae00:	18bff216 	blt	r3,r2,822adcc <dhc_request+0x690>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 822ae04:	008209b4 	movhi	r2,2086
 822ae08:	10b6d804 	addi	r2,r2,-9376
 822ae0c:	e0fffe17 	ldw	r3,-8(fp)
 822ae10:	18c00f24 	muli	r3,r3,60
 822ae14:	10c5883a 	add	r2,r2,r3
 822ae18:	10800017 	ldw	r2,0(r2)
 822ae1c:	108001e0 	cmpeqi	r2,r2,7
 822ae20:	1000081e 	bne	r2,zero,822ae44 <dhc_request+0x708>
       || (dhc_states[iface].state == DHCS_REBINDING))
 822ae24:	008209b4 	movhi	r2,2086
 822ae28:	10b6d804 	addi	r2,r2,-9376
 822ae2c:	e0fffe17 	ldw	r3,-8(fp)
 822ae30:	18c00f24 	muli	r3,r3,60
 822ae34:	10c5883a 	add	r2,r2,r3
 822ae38:	10800017 	ldw	r2,0(r2)
 822ae3c:	10800218 	cmpnei	r2,r2,8
 822ae40:	10000a1e 	bne	r2,zero,822ae6c <dhc_request+0x730>
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 822ae44:	008209b4 	movhi	r2,2086
 822ae48:	10b6b204 	addi	r2,r2,-9528
 822ae4c:	e0fffe17 	ldw	r3,-8(fp)
 822ae50:	18c7883a 	add	r3,r3,r3
 822ae54:	18c7883a 	add	r3,r3,r3
 822ae58:	10c5883a 	add	r2,r2,r3
 822ae5c:	10800017 	ldw	r2,0(r2)
 822ae60:	10c00a17 	ldw	r3,40(r2)
 822ae64:	e0bff917 	ldw	r2,-28(fp)
 822ae68:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822ae6c:	008209b4 	movhi	r2,2086
 822ae70:	10b6d804 	addi	r2,r2,-9376
 822ae74:	e0fffe17 	ldw	r3,-8(fp)
 822ae78:	18c00f24 	muli	r3,r3,60
 822ae7c:	10c5883a 	add	r2,r2,r3
 822ae80:	10800017 	ldw	r2,0(r2)
 822ae84:	10800120 	cmpeqi	r2,r2,4
 822ae88:	1000081e 	bne	r2,zero,822aeac <dhc_request+0x770>
       (dhc_states[iface].state == DHCS_REQUESTING))
 822ae8c:	008209b4 	movhi	r2,2086
 822ae90:	10b6d804 	addi	r2,r2,-9376
 822ae94:	e0fffe17 	ldw	r3,-8(fp)
 822ae98:	18c00f24 	muli	r3,r3,60
 822ae9c:	10c5883a 	add	r2,r2,r3
 822aea0:	10800017 	ldw	r2,0(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822aea4:	10800158 	cmpnei	r2,r2,5
 822aea8:	10004a1e 	bne	r2,zero,822afd4 <dhc_request+0x898>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 822aeac:	008209b4 	movhi	r2,2086
 822aeb0:	10b6d804 	addi	r2,r2,-9376
 822aeb4:	e0fffe17 	ldw	r3,-8(fp)
 822aeb8:	18c00f24 	muli	r3,r3,60
 822aebc:	10c5883a 	add	r2,r2,r3
 822aec0:	10800d04 	addi	r2,r2,52
 822aec4:	10800017 	ldw	r2,0(r2)
 822aec8:	1006d63a 	srli	r3,r2,24
 822aecc:	008209b4 	movhi	r2,2086
 822aed0:	10b6d804 	addi	r2,r2,-9376
 822aed4:	e13ffe17 	ldw	r4,-8(fp)
 822aed8:	21000f24 	muli	r4,r4,60
 822aedc:	1105883a 	add	r2,r2,r4
 822aee0:	10800d04 	addi	r2,r2,52
 822aee4:	10800017 	ldw	r2,0(r2)
 822aee8:	1004d23a 	srli	r2,r2,8
 822aeec:	10bfc00c 	andi	r2,r2,65280
 822aef0:	1886b03a 	or	r3,r3,r2
 822aef4:	008209b4 	movhi	r2,2086
 822aef8:	10b6d804 	addi	r2,r2,-9376
 822aefc:	e13ffe17 	ldw	r4,-8(fp)
 822af00:	21000f24 	muli	r4,r4,60
 822af04:	1105883a 	add	r2,r2,r4
 822af08:	10800d04 	addi	r2,r2,52
 822af0c:	10800017 	ldw	r2,0(r2)
 822af10:	10bfc00c 	andi	r2,r2,65280
 822af14:	1004923a 	slli	r2,r2,8
 822af18:	1886b03a 	or	r3,r3,r2
 822af1c:	008209b4 	movhi	r2,2086
 822af20:	10b6d804 	addi	r2,r2,-9376
 822af24:	e13ffe17 	ldw	r4,-8(fp)
 822af28:	21000f24 	muli	r4,r4,60
 822af2c:	1105883a 	add	r2,r2,r4
 822af30:	10800d04 	addi	r2,r2,52
 822af34:	10800017 	ldw	r2,0(r2)
 822af38:	1004963a 	slli	r2,r2,24
 822af3c:	1884b03a 	or	r2,r3,r2
 822af40:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 822af44:	e0bff617 	ldw	r2,-40(fp)
 822af48:	10c00044 	addi	r3,r2,1
 822af4c:	e0fff615 	stw	r3,-40(fp)
 822af50:	00c00d84 	movi	r3,54
 822af54:	10c00005 	stb	r3,0(r2)
 822af58:	e0bff617 	ldw	r2,-40(fp)
 822af5c:	10c00044 	addi	r3,r2,1
 822af60:	e0fff615 	stw	r3,-40(fp)
 822af64:	00c00104 	movi	r3,4
 822af68:	10c00005 	stb	r3,0(r2)
 822af6c:	e0bff617 	ldw	r2,-40(fp)
 822af70:	108000c4 	addi	r2,r2,3
 822af74:	e0fffd04 	addi	r3,fp,-12
 822af78:	18c00003 	ldbu	r3,0(r3)
 822af7c:	10c00005 	stb	r3,0(r2)
 822af80:	e0bff617 	ldw	r2,-40(fp)
 822af84:	10c00084 	addi	r3,r2,2
 822af88:	e0bffd04 	addi	r2,fp,-12
 822af8c:	10800044 	addi	r2,r2,1
 822af90:	10800003 	ldbu	r2,0(r2)
 822af94:	18800005 	stb	r2,0(r3)
 822af98:	e0bff617 	ldw	r2,-40(fp)
 822af9c:	10c00044 	addi	r3,r2,1
 822afa0:	e0bffd04 	addi	r2,fp,-12
 822afa4:	10800084 	addi	r2,r2,2
 822afa8:	10800003 	ldbu	r2,0(r2)
 822afac:	18800005 	stb	r2,0(r3)
 822afb0:	e0bffd04 	addi	r2,fp,-12
 822afb4:	108000c4 	addi	r2,r2,3
 822afb8:	10800003 	ldbu	r2,0(r2)
 822afbc:	1007883a 	mov	r3,r2
 822afc0:	e0bff617 	ldw	r2,-40(fp)
 822afc4:	10c00005 	stb	r3,0(r2)
 822afc8:	e0bff617 	ldw	r2,-40(fp)
 822afcc:	10800104 	addi	r2,r2,4
 822afd0:	e0bff615 	stw	r2,-40(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 822afd4:	e0bff617 	ldw	r2,-40(fp)
 822afd8:	10c00044 	addi	r3,r2,1
 822afdc:	e0fff615 	stw	r3,-40(fp)
 822afe0:	00c01444 	movi	r3,81
 822afe4:	10c00005 	stb	r3,0(r2)
 822afe8:	00800184 	movi	r2,6
 822afec:	e0bffb15 	stw	r2,-20(fp)
 822aff0:	e0bff617 	ldw	r2,-40(fp)
 822aff4:	10c00044 	addi	r3,r2,1
 822aff8:	e0fff615 	stw	r3,-40(fp)
 822affc:	e0fffb17 	ldw	r3,-20(fp)
 822b000:	10c00005 	stb	r3,0(r2)
 822b004:	e0bffb17 	ldw	r2,-20(fp)
 822b008:	100d883a 	mov	r6,r2
 822b00c:	01420974 	movhi	r5,2085
 822b010:	2940b004 	addi	r5,r5,704
 822b014:	e13ff617 	ldw	r4,-40(fp)
 822b018:	824b3140 	call	824b314 <strncpy>
 822b01c:	e0bffb17 	ldw	r2,-20(fp)
 822b020:	e0fff617 	ldw	r3,-40(fp)
 822b024:	1885883a 	add	r2,r3,r2
 822b028:	e0bff615 	stw	r2,-40(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 822b02c:	e0bff617 	ldw	r2,-40(fp)
 822b030:	10c00044 	addi	r3,r2,1
 822b034:	e0fff615 	stw	r3,-40(fp)
 822b038:	00c00f04 	movi	r3,60
 822b03c:	10c00005 	stb	r3,0(r2)
 822b040:	d0a04b17 	ldw	r2,-32468(gp)
 822b044:	1009883a 	mov	r4,r2
 822b048:	8203a5c0 	call	8203a5c <strlen>
 822b04c:	e0bffc15 	stw	r2,-16(fp)
 822b050:	e0bff617 	ldw	r2,-40(fp)
 822b054:	10c00044 	addi	r3,r2,1
 822b058:	e0fff615 	stw	r3,-40(fp)
 822b05c:	e0fffc17 	ldw	r3,-16(fp)
 822b060:	10c00005 	stb	r3,0(r2)
 822b064:	d0a04b17 	ldw	r2,-32468(gp)
 822b068:	e0fffc17 	ldw	r3,-16(fp)
 822b06c:	180d883a 	mov	r6,r3
 822b070:	100b883a 	mov	r5,r2
 822b074:	e13ff617 	ldw	r4,-40(fp)
 822b078:	824b3140 	call	824b314 <strncpy>
 822b07c:	e0bffc17 	ldw	r2,-16(fp)
 822b080:	e0fff617 	ldw	r3,-40(fp)
 822b084:	1885883a 	add	r2,r3,r2
 822b088:	e0bff615 	stw	r2,-40(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 822b08c:	e0bff617 	ldw	r2,-40(fp)
 822b090:	10c00044 	addi	r3,r2,1
 822b094:	e0fff615 	stw	r3,-40(fp)
 822b098:	00ffffc4 	movi	r3,-1
 822b09c:	10c00005 	stb	r3,0(r2)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 822b0a0:	008209b4 	movhi	r2,2086
 822b0a4:	10b6d804 	addi	r2,r2,-9376
 822b0a8:	e0fffe17 	ldw	r3,-8(fp)
 822b0ac:	18c00f24 	muli	r3,r3,60
 822b0b0:	10c5883a 	add	r2,r2,r3
 822b0b4:	10800017 	ldw	r2,0(r2)
 822b0b8:	108001d8 	cmpnei	r2,r2,7
 822b0bc:	10000a1e 	bne	r2,zero,822b0e8 <dhc_request+0x9ac>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 822b0c0:	008209b4 	movhi	r2,2086
 822b0c4:	10b6d804 	addi	r2,r2,-9376
 822b0c8:	e0fffe17 	ldw	r3,-8(fp)
 822b0cc:	18c00f24 	muli	r3,r3,60
 822b0d0:	10c5883a 	add	r2,r2,r3
 822b0d4:	10800d04 	addi	r2,r2,52
 822b0d8:	10c00017 	ldw	r3,0(r2)
 822b0dc:	e0bff817 	ldw	r2,-32(fp)
 822b0e0:	10c00715 	stw	r3,28(r2)
 822b0e4:	00000306 	br	822b0f4 <dhc_request+0x9b8>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 822b0e8:	e0bff817 	ldw	r2,-32(fp)
 822b0ec:	00ffffc4 	movi	r3,-1
 822b0f0:	10c00715 	stw	r3,28(r2)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822b0f4:	008209b4 	movhi	r2,2086
 822b0f8:	10b6b204 	addi	r2,r2,-9528
 822b0fc:	e0fffe17 	ldw	r3,-8(fp)
 822b100:	18c7883a 	add	r3,r3,r3
 822b104:	18c7883a 	add	r3,r3,r3
 822b108:	10c5883a 	add	r2,r2,r3
 822b10c:	10c00017 	ldw	r3,0(r2)
 822b110:	e0bff817 	ldw	r2,-32(fp)
 822b114:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 822b118:	e0fff617 	ldw	r3,-40(fp)
 822b11c:	e0bff917 	ldw	r2,-28(fp)
 822b120:	1885c83a 	sub	r2,r3,r2
 822b124:	1007883a 	mov	r3,r2
 822b128:	e0bff817 	ldw	r2,-32(fp)
 822b12c:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b130:	e1bff817 	ldw	r6,-32(fp)
 822b134:	01401104 	movi	r5,68
 822b138:	010010c4 	movi	r4,67
 822b13c:	8244c000 	call	8244c00 <udp_send>
   dsc_requests++;
 822b140:	d0a09317 	ldw	r2,-32180(gp)
 822b144:	10800044 	addi	r2,r2,1
 822b148:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 822b14c:	d0e0a817 	ldw	r3,-32096(gp)
 822b150:	008209b4 	movhi	r2,2086
 822b154:	10b6d804 	addi	r2,r2,-9376
 822b158:	e13ffe17 	ldw	r4,-8(fp)
 822b15c:	21000f24 	muli	r4,r4,60
 822b160:	1105883a 	add	r2,r2,r4
 822b164:	10800404 	addi	r2,r2,16
 822b168:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822b16c:	008209b4 	movhi	r2,2086
 822b170:	10b6d804 	addi	r2,r2,-9376
 822b174:	e0fffe17 	ldw	r3,-8(fp)
 822b178:	18c00f24 	muli	r3,r3,60
 822b17c:	10c5883a 	add	r2,r2,r3
 822b180:	10800104 	addi	r2,r2,4
 822b184:	10800017 	ldw	r2,0(r2)
 822b188:	10c00044 	addi	r3,r2,1
 822b18c:	008209b4 	movhi	r2,2086
 822b190:	10b6d804 	addi	r2,r2,-9376
 822b194:	e13ffe17 	ldw	r4,-8(fp)
 822b198:	21000f24 	muli	r4,r4,60
 822b19c:	1105883a 	add	r2,r2,r4
 822b1a0:	10800104 	addi	r2,r2,4
 822b1a4:	10c00015 	stw	r3,0(r2)

   return 0;   /* return OK code */
 822b1a8:	0005883a 	mov	r2,zero
}
 822b1ac:	e037883a 	mov	sp,fp
 822b1b0:	dfc00117 	ldw	ra,4(sp)
 822b1b4:	df000017 	ldw	fp,0(sp)
 822b1b8:	dec00204 	addi	sp,sp,8
 822b1bc:	f800283a 	ret

0822b1c0 <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 822b1c0:	defffd04 	addi	sp,sp,-12
 822b1c4:	dfc00215 	stw	ra,8(sp)
 822b1c8:	df000115 	stw	fp,4(sp)
 822b1cc:	df000104 	addi	fp,sp,4
 822b1d0:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 822b1d4:	008209b4 	movhi	r2,2086
 822b1d8:	10b6b204 	addi	r2,r2,-9528
 822b1dc:	e0ffff17 	ldw	r3,-4(fp)
 822b1e0:	18c7883a 	add	r3,r3,r3
 822b1e4:	18c7883a 	add	r3,r3,r3
 822b1e8:	10c5883a 	add	r2,r2,r3
 822b1ec:	10c00017 	ldw	r3,0(r2)
 822b1f0:	008209b4 	movhi	r2,2086
 822b1f4:	10b6d804 	addi	r2,r2,-9376
 822b1f8:	e13fff17 	ldw	r4,-4(fp)
 822b1fc:	21000f24 	muli	r4,r4,60
 822b200:	1105883a 	add	r2,r2,r4
 822b204:	10800904 	addi	r2,r2,36
 822b208:	10800017 	ldw	r2,0(r2)
 822b20c:	18800a15 	stw	r2,40(r3)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 822b210:	008209b4 	movhi	r2,2086
 822b214:	10b6b204 	addi	r2,r2,-9528
 822b218:	e0ffff17 	ldw	r3,-4(fp)
 822b21c:	18c7883a 	add	r3,r3,r3
 822b220:	18c7883a 	add	r3,r3,r3
 822b224:	10c5883a 	add	r2,r2,r3
 822b228:	10c00017 	ldw	r3,0(r2)
 822b22c:	008209b4 	movhi	r2,2086
 822b230:	10b6d804 	addi	r2,r2,-9376
 822b234:	e13fff17 	ldw	r4,-4(fp)
 822b238:	21000f24 	muli	r4,r4,60
 822b23c:	1105883a 	add	r2,r2,r4
 822b240:	10800a04 	addi	r2,r2,40
 822b244:	10800017 	ldw	r2,0(r2)
 822b248:	18800c15 	stw	r2,48(r3)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 822b24c:	008209b4 	movhi	r2,2086
 822b250:	10b6b204 	addi	r2,r2,-9528
 822b254:	e0ffff17 	ldw	r3,-4(fp)
 822b258:	18c7883a 	add	r3,r3,r3
 822b25c:	18c7883a 	add	r3,r3,r3
 822b260:	10c5883a 	add	r2,r2,r3
 822b264:	10c00017 	ldw	r3,0(r2)
 822b268:	008209b4 	movhi	r2,2086
 822b26c:	10b6d804 	addi	r2,r2,-9376
 822b270:	e13fff17 	ldw	r4,-4(fp)
 822b274:	21000f24 	muli	r4,r4,60
 822b278:	1105883a 	add	r2,r2,r4
 822b27c:	10800b04 	addi	r2,r2,44
 822b280:	10800017 	ldw	r2,0(r2)
 822b284:	18800d15 	stw	r2,52(r3)

   if ( nets[iface]->snmask == 0 )
 822b288:	008209b4 	movhi	r2,2086
 822b28c:	10b6b204 	addi	r2,r2,-9528
 822b290:	e0ffff17 	ldw	r3,-4(fp)
 822b294:	18c7883a 	add	r3,r3,r3
 822b298:	18c7883a 	add	r3,r3,r3
 822b29c:	10c5883a 	add	r2,r2,r3
 822b2a0:	10800017 	ldw	r2,0(r2)
 822b2a4:	10800c17 	ldw	r2,48(r2)
 822b2a8:	1000111e 	bne	r2,zero,822b2f0 <dhc_setip+0x130>
   {
      fixup_subnet_mask(iface);
 822b2ac:	e13fff17 	ldw	r4,-4(fp)
 822b2b0:	8225cbc0 	call	8225cbc <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 822b2b4:	008209b4 	movhi	r2,2086
 822b2b8:	10b6b204 	addi	r2,r2,-9528
 822b2bc:	e0ffff17 	ldw	r3,-4(fp)
 822b2c0:	18c7883a 	add	r3,r3,r3
 822b2c4:	18c7883a 	add	r3,r3,r3
 822b2c8:	10c5883a 	add	r2,r2,r3
 822b2cc:	10800017 	ldw	r2,0(r2)
 822b2d0:	10c00c17 	ldw	r3,48(r2)
 822b2d4:	008209b4 	movhi	r2,2086
 822b2d8:	10b6d804 	addi	r2,r2,-9376
 822b2dc:	e13fff17 	ldw	r4,-4(fp)
 822b2e0:	21000f24 	muli	r4,r4,60
 822b2e4:	1105883a 	add	r2,r2,r4
 822b2e8:	10800a04 	addi	r2,r2,40
 822b2ec:	10c00015 	stw	r3,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b2f0:	008209b4 	movhi	r2,2086
 822b2f4:	10b6b204 	addi	r2,r2,-9528
 822b2f8:	e0ffff17 	ldw	r3,-4(fp)
 822b2fc:	18c7883a 	add	r3,r3,r3
 822b300:	18c7883a 	add	r3,r3,r3
 822b304:	10c5883a 	add	r2,r2,r3
 822b308:	11000017 	ldw	r4,0(r2)
 822b30c:	008209b4 	movhi	r2,2086
 822b310:	10b6b204 	addi	r2,r2,-9528
 822b314:	e0ffff17 	ldw	r3,-4(fp)
 822b318:	18c7883a 	add	r3,r3,r3
 822b31c:	18c7883a 	add	r3,r3,r3
 822b320:	10c5883a 	add	r2,r2,r3
 822b324:	10800017 	ldw	r2,0(r2)
 822b328:	11400a17 	ldw	r5,40(r2)
 822b32c:	008209b4 	movhi	r2,2086
 822b330:	10b6b204 	addi	r2,r2,-9528
 822b334:	e0ffff17 	ldw	r3,-4(fp)
 822b338:	18c7883a 	add	r3,r3,r3
 822b33c:	18c7883a 	add	r3,r3,r3
 822b340:	10c5883a 	add	r2,r2,r3
 822b344:	10800017 	ldw	r2,0(r2)
 822b348:	10800c17 	ldw	r2,48(r2)
 822b34c:	0084303a 	nor	r2,zero,r2
 822b350:	2884b03a 	or	r2,r5,r2
 822b354:	20800e15 	stw	r2,56(r4)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 822b358:	008209b4 	movhi	r2,2086
 822b35c:	10b6b204 	addi	r2,r2,-9528
 822b360:	e0ffff17 	ldw	r3,-4(fp)
 822b364:	18c7883a 	add	r3,r3,r3
 822b368:	18c7883a 	add	r3,r3,r3
 822b36c:	10c5883a 	add	r2,r2,r3
 822b370:	11000017 	ldw	r4,0(r2)
 822b374:	008209b4 	movhi	r2,2086
 822b378:	10b6b204 	addi	r2,r2,-9528
 822b37c:	e0ffff17 	ldw	r3,-4(fp)
 822b380:	18c7883a 	add	r3,r3,r3
 822b384:	18c7883a 	add	r3,r3,r3
 822b388:	10c5883a 	add	r2,r2,r3
 822b38c:	10800017 	ldw	r2,0(r2)
 822b390:	11400a17 	ldw	r5,40(r2)
 822b394:	008209b4 	movhi	r2,2086
 822b398:	10b6b204 	addi	r2,r2,-9528
 822b39c:	e0ffff17 	ldw	r3,-4(fp)
 822b3a0:	18c7883a 	add	r3,r3,r3
 822b3a4:	18c7883a 	add	r3,r3,r3
 822b3a8:	10c5883a 	add	r2,r2,r3
 822b3ac:	10800017 	ldw	r2,0(r2)
 822b3b0:	10800c17 	ldw	r2,48(r2)
 822b3b4:	2884703a 	and	r2,r5,r2
 822b3b8:	20800f15 	stw	r2,60(r4)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b3bc:	008209b4 	movhi	r2,2086
 822b3c0:	10b6b204 	addi	r2,r2,-9528
 822b3c4:	e0ffff17 	ldw	r3,-4(fp)
 822b3c8:	18c7883a 	add	r3,r3,r3
 822b3cc:	18c7883a 	add	r3,r3,r3
 822b3d0:	10c5883a 	add	r2,r2,r3
 822b3d4:	11000017 	ldw	r4,0(r2)
 822b3d8:	008209b4 	movhi	r2,2086
 822b3dc:	10b6b204 	addi	r2,r2,-9528
 822b3e0:	e0ffff17 	ldw	r3,-4(fp)
 822b3e4:	18c7883a 	add	r3,r3,r3
 822b3e8:	18c7883a 	add	r3,r3,r3
 822b3ec:	10c5883a 	add	r2,r2,r3
 822b3f0:	10800017 	ldw	r2,0(r2)
 822b3f4:	11400a17 	ldw	r5,40(r2)
 822b3f8:	008209b4 	movhi	r2,2086
 822b3fc:	10b6b204 	addi	r2,r2,-9528
 822b400:	e0ffff17 	ldw	r3,-4(fp)
 822b404:	18c7883a 	add	r3,r3,r3
 822b408:	18c7883a 	add	r3,r3,r3
 822b40c:	10c5883a 	add	r2,r2,r3
 822b410:	10800017 	ldw	r2,0(r2)
 822b414:	10800c17 	ldw	r2,48(r2)
 822b418:	0084303a 	nor	r2,zero,r2
 822b41c:	2884b03a 	or	r2,r5,r2
 822b420:	20801015 	stw	r2,64(r4)

   return 0;   /* return OK code */
 822b424:	0005883a 	mov	r2,zero
}
 822b428:	e037883a 	mov	sp,fp
 822b42c:	dfc00117 	ldw	ra,4(sp)
 822b430:	df000017 	ldw	fp,0(sp)
 822b434:	dec00204 	addi	sp,sp,8
 822b438:	f800283a 	ret

0822b43c <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 822b43c:	defffe04 	addi	sp,sp,-8
 822b440:	df000115 	stw	fp,4(sp)
 822b444:	df000104 	addi	fp,sp,4
 822b448:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 822b44c:	008209b4 	movhi	r2,2086
 822b450:	10b6b204 	addi	r2,r2,-9528
 822b454:	e0ffff17 	ldw	r3,-4(fp)
 822b458:	18c7883a 	add	r3,r3,r3
 822b45c:	18c7883a 	add	r3,r3,r3
 822b460:	10c5883a 	add	r2,r2,r3
 822b464:	10800017 	ldw	r2,0(r2)
 822b468:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 822b46c:	008209b4 	movhi	r2,2086
 822b470:	10b6b204 	addi	r2,r2,-9528
 822b474:	e0ffff17 	ldw	r3,-4(fp)
 822b478:	18c7883a 	add	r3,r3,r3
 822b47c:	18c7883a 	add	r3,r3,r3
 822b480:	10c5883a 	add	r2,r2,r3
 822b484:	10800017 	ldw	r2,0(r2)
 822b488:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 822b48c:	008209b4 	movhi	r2,2086
 822b490:	10b6b204 	addi	r2,r2,-9528
 822b494:	e0ffff17 	ldw	r3,-4(fp)
 822b498:	18c7883a 	add	r3,r3,r3
 822b49c:	18c7883a 	add	r3,r3,r3
 822b4a0:	10c5883a 	add	r2,r2,r3
 822b4a4:	10800017 	ldw	r2,0(r2)
 822b4a8:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 822b4ac:	008209b4 	movhi	r2,2086
 822b4b0:	10b6b204 	addi	r2,r2,-9528
 822b4b4:	e0ffff17 	ldw	r3,-4(fp)
 822b4b8:	18c7883a 	add	r3,r3,r3
 822b4bc:	18c7883a 	add	r3,r3,r3
 822b4c0:	10c5883a 	add	r2,r2,r3
 822b4c4:	10800017 	ldw	r2,0(r2)
 822b4c8:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 822b4cc:	008209b4 	movhi	r2,2086
 822b4d0:	10b6b204 	addi	r2,r2,-9528
 822b4d4:	e0ffff17 	ldw	r3,-4(fp)
 822b4d8:	18c7883a 	add	r3,r3,r3
 822b4dc:	18c7883a 	add	r3,r3,r3
 822b4e0:	10c5883a 	add	r2,r2,r3
 822b4e4:	10800017 	ldw	r2,0(r2)
 822b4e8:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 822b4ec:	008209b4 	movhi	r2,2086
 822b4f0:	10b6b204 	addi	r2,r2,-9528
 822b4f4:	e0ffff17 	ldw	r3,-4(fp)
 822b4f8:	18c7883a 	add	r3,r3,r3
 822b4fc:	18c7883a 	add	r3,r3,r3
 822b500:	10c5883a 	add	r2,r2,r3
 822b504:	10800017 	ldw	r2,0(r2)
 822b508:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 822b50c:	0005883a 	mov	r2,zero
}
 822b510:	e037883a 	mov	sp,fp
 822b514:	df000017 	ldw	fp,0(sp)
 822b518:	dec00104 	addi	sp,sp,4
 822b51c:	f800283a 	ret

0822b520 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 822b520:	defff804 	addi	sp,sp,-32
 822b524:	dfc00715 	stw	ra,28(sp)
 822b528:	df000615 	stw	fp,24(sp)
 822b52c:	df000604 	addi	fp,sp,24
 822b530:	e13ffd15 	stw	r4,-12(fp)
 822b534:	e17ffe15 	stw	r5,-8(fp)
 822b538:	e1bfff15 	stw	r6,-4(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 822b53c:	e0bfff17 	ldw	r2,-4(fp)
 822b540:	000b883a 	mov	r5,zero
 822b544:	1009883a 	mov	r4,r2
 822b548:	824503c0 	call	824503c <udp_alloc>
 822b54c:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 822b550:	e0bffa17 	ldw	r2,-24(fp)
 822b554:	1000021e 	bne	r2,zero,822b560 <dhc_decline+0x40>
      return ENP_NOMEM;
 822b558:	00bffb04 	movi	r2,-20
 822b55c:	00002d06 	br	822b614 <dhc_decline+0xf4>
   pkt->nb_plen = bplen;
 822b560:	e0bffa17 	ldw	r2,-24(fp)
 822b564:	e0ffff17 	ldw	r3,-4(fp)
 822b568:	10c00415 	stw	r3,16(r2)

   outbp = (struct bootp *)pkt->nb_prot;
 822b56c:	e0bffa17 	ldw	r2,-24(fp)
 822b570:	10800317 	ldw	r2,12(r2)
 822b574:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 822b578:	e1bfff17 	ldw	r6,-4(fp)
 822b57c:	e17ffe17 	ldw	r5,-8(fp)
 822b580:	e13ffb17 	ldw	r4,-20(fp)
 822b584:	8202a0c0 	call	8202a0c <memcpy>
   outbp->op = BOOTREQUEST;
 822b588:	e0bffb17 	ldw	r2,-20(fp)
 822b58c:	00c00044 	movi	r3,1
 822b590:	10c00005 	stb	r3,0(r2)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 822b594:	e0bffb17 	ldw	r2,-20(fp)
 822b598:	10803c04 	addi	r2,r2,240
 822b59c:	100b883a 	mov	r5,r2
 822b5a0:	01000d44 	movi	r4,53
 822b5a4:	822c2c40 	call	822c2c4 <find_opt>
 822b5a8:	e0bffc15 	stw	r2,-16(fp)
   opts += 2;     /* point to actual op code */
 822b5ac:	e0bffc17 	ldw	r2,-16(fp)
 822b5b0:	10800084 	addi	r2,r2,2
 822b5b4:	e0bffc15 	stw	r2,-16(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 822b5b8:	e0bffc17 	ldw	r2,-16(fp)
 822b5bc:	00c00104 	movi	r3,4
 822b5c0:	10c00005 	stb	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 822b5c4:	e0bffa17 	ldw	r2,-24(fp)
 822b5c8:	00ffffc4 	movi	r3,-1
 822b5cc:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller speced net */
 822b5d0:	008209b4 	movhi	r2,2086
 822b5d4:	10b6b204 	addi	r2,r2,-9528
 822b5d8:	e0fffd17 	ldw	r3,-12(fp)
 822b5dc:	18c7883a 	add	r3,r3,r3
 822b5e0:	18c7883a 	add	r3,r3,r3
 822b5e4:	10c5883a 	add	r2,r2,r3
 822b5e8:	10c00017 	ldw	r3,0(r2)
 822b5ec:	e0bffa17 	ldw	r2,-24(fp)
 822b5f0:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b5f4:	e1bffa17 	ldw	r6,-24(fp)
 822b5f8:	01401104 	movi	r5,68
 822b5fc:	010010c4 	movi	r4,67
 822b600:	8244c000 	call	8244c00 <udp_send>
   dsc_declines++;   /* count declines sent */
 822b604:	d0a09617 	ldw	r2,-32168(gp)
 822b608:	10800044 	addi	r2,r2,1
 822b60c:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 822b610:	0005883a 	mov	r2,zero
}
 822b614:	e037883a 	mov	sp,fp
 822b618:	dfc00117 	ldw	ra,4(sp)
 822b61c:	df000017 	ldw	fp,0(sp)
 822b620:	dec00204 	addi	sp,sp,8
 822b624:	f800283a 	ret

0822b628 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 822b628:	defffc04 	addi	sp,sp,-16
 822b62c:	df000315 	stw	fp,12(sp)
 822b630:	df000304 	addi	fp,sp,12
 822b634:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 822b638:	e0bffe04 	addi	r2,fp,-8
 822b63c:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 822b640:	e0bffd17 	ldw	r2,-12(fp)
 822b644:	10c00044 	addi	r3,r2,1
 822b648:	e0fffd15 	stw	r3,-12(fp)
 822b64c:	e0ffff17 	ldw	r3,-4(fp)
 822b650:	19000044 	addi	r4,r3,1
 822b654:	e13fff15 	stw	r4,-4(fp)
 822b658:	18c00003 	ldbu	r3,0(r3)
 822b65c:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b660:	e0bffd17 	ldw	r2,-12(fp)
 822b664:	10c00044 	addi	r3,r2,1
 822b668:	e0fffd15 	stw	r3,-12(fp)
 822b66c:	e0ffff17 	ldw	r3,-4(fp)
 822b670:	19000044 	addi	r4,r3,1
 822b674:	e13fff15 	stw	r4,-4(fp)
 822b678:	18c00003 	ldbu	r3,0(r3)
 822b67c:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b680:	e0bffd17 	ldw	r2,-12(fp)
 822b684:	10c00044 	addi	r3,r2,1
 822b688:	e0fffd15 	stw	r3,-12(fp)
 822b68c:	e0ffff17 	ldw	r3,-4(fp)
 822b690:	19000044 	addi	r4,r3,1
 822b694:	e13fff15 	stw	r4,-4(fp)
 822b698:	18c00003 	ldbu	r3,0(r3)
 822b69c:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b6a0:	e0bffd17 	ldw	r2,-12(fp)
 822b6a4:	10c00044 	addi	r3,r2,1
 822b6a8:	e0fffd15 	stw	r3,-12(fp)
 822b6ac:	e0ffff17 	ldw	r3,-4(fp)
 822b6b0:	19000044 	addi	r4,r3,1
 822b6b4:	e13fff15 	stw	r4,-4(fp)
 822b6b8:	18c00003 	ldbu	r3,0(r3)
 822b6bc:	10c00005 	stb	r3,0(r2)

   return v;
 822b6c0:	e0bffe17 	ldw	r2,-8(fp)
}
 822b6c4:	e037883a 	mov	sp,fp
 822b6c8:	df000017 	ldw	fp,0(sp)
 822b6cc:	dec00104 	addi	sp,sp,4
 822b6d0:	f800283a 	ret

0822b6d4 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 822b6d4:	defff904 	addi	sp,sp,-28
 822b6d8:	dfc00615 	stw	ra,24(sp)
 822b6dc:	df000515 	stw	fp,20(sp)
 822b6e0:	dc000415 	stw	r16,16(sp)
 822b6e4:	df000504 	addi	fp,sp,20
 822b6e8:	e13ffd15 	stw	r4,-12(fp)
 822b6ec:	e17ffe15 	stw	r5,-8(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 822b6f0:	e0bffe17 	ldw	r2,-8(fp)
 822b6f4:	10804e04 	addi	r2,r2,312
 822b6f8:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 822b6fc:	008209b4 	movhi	r2,2086
 822b700:	10b6d804 	addi	r2,r2,-9376
 822b704:	e0fffd17 	ldw	r3,-12(fp)
 822b708:	18c00f24 	muli	r3,r3,60
 822b70c:	10c5883a 	add	r2,r2,r3
 822b710:	10800a04 	addi	r2,r2,40
 822b714:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 822b718:	008209b4 	movhi	r2,2086
 822b71c:	10b6d804 	addi	r2,r2,-9376
 822b720:	e0fffd17 	ldw	r3,-12(fp)
 822b724:	18c00f24 	muli	r3,r3,60
 822b728:	10c5883a 	add	r2,r2,r3
 822b72c:	10800b04 	addi	r2,r2,44
 822b730:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 822b734:	008209b4 	movhi	r2,2086
 822b738:	10b6d804 	addi	r2,r2,-9376
 822b73c:	e0fffd17 	ldw	r3,-12(fp)
 822b740:	18c00f24 	muli	r3,r3,60
 822b744:	10c5883a 	add	r2,r2,r3
 822b748:	10800504 	addi	r2,r2,20
 822b74c:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822b750:	00007106 	br	822b918 <dhc_extract_opts+0x244>
   {
      switch (*opts++)
 822b754:	e0bffe17 	ldw	r2,-8(fp)
 822b758:	10c00044 	addi	r3,r2,1
 822b75c:	e0fffe15 	stw	r3,-8(fp)
 822b760:	10800003 	ldbu	r2,0(r2)
 822b764:	10803fcc 	andi	r2,r2,255
 822b768:	10c000e0 	cmpeqi	r3,r2,3
 822b76c:	1800201e 	bne	r3,zero,822b7f0 <dhc_extract_opts+0x11c>
 822b770:	10c00108 	cmpgei	r3,r2,4
 822b774:	1800041e 	bne	r3,zero,822b788 <dhc_extract_opts+0xb4>
 822b778:	10006726 	beq	r2,zero,822b918 <dhc_extract_opts+0x244>
 822b77c:	10800060 	cmpeqi	r2,r2,1
 822b780:	10000a1e 	bne	r2,zero,822b7ac <dhc_extract_opts+0xd8>
 822b784:	00005c06 	br	822b8f8 <dhc_extract_opts+0x224>
 822b788:	10c00ce0 	cmpeqi	r3,r2,51
 822b78c:	18002f1e 	bne	r3,zero,822b84c <dhc_extract_opts+0x178>
 822b790:	10c03fe0 	cmpeqi	r3,r2,255
 822b794:	1800031e 	bne	r3,zero,822b7a4 <dhc_extract_opts+0xd0>
 822b798:	108001a0 	cmpeqi	r2,r2,6
 822b79c:	10004c1e 	bne	r2,zero,822b8d0 <dhc_extract_opts+0x1fc>
 822b7a0:	00005506 	br	822b8f8 <dhc_extract_opts+0x224>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 822b7a4:	0005883a 	mov	r2,zero
 822b7a8:	00006006 	br	822b92c <dhc_extract_opts+0x258>
      case DHOP_SNMASK:
         opts++;
 822b7ac:	e0bffe17 	ldw	r2,-8(fp)
 822b7b0:	10800044 	addi	r2,r2,1
 822b7b4:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 822b7b8:	e13ffe17 	ldw	r4,-8(fp)
 822b7bc:	822b6280 	call	822b628 <dh_getlong>
 822b7c0:	1009883a 	mov	r4,r2
 822b7c4:	008209b4 	movhi	r2,2086
 822b7c8:	10b6d804 	addi	r2,r2,-9376
 822b7cc:	e0fffd17 	ldw	r3,-12(fp)
 822b7d0:	18c00f24 	muli	r3,r3,60
 822b7d4:	10c5883a 	add	r2,r2,r3
 822b7d8:	10800a04 	addi	r2,r2,40
 822b7dc:	11000015 	stw	r4,0(r2)
         opts += 4;
 822b7e0:	e0bffe17 	ldw	r2,-8(fp)
 822b7e4:	10800104 	addi	r2,r2,4
 822b7e8:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b7ec:	00004a06 	br	822b918 <dhc_extract_opts+0x244>
      case DHOP_ROUTER:
         optlen = *opts++;
 822b7f0:	e0bffe17 	ldw	r2,-8(fp)
 822b7f4:	10c00044 	addi	r3,r2,1
 822b7f8:	e0fffe15 	stw	r3,-8(fp)
 822b7fc:	10800003 	ldbu	r2,0(r2)
 822b800:	e0bffc05 	stb	r2,-16(fp)
         if (optlen >= 4)
 822b804:	e0bffc03 	ldbu	r2,-16(fp)
 822b808:	10800130 	cmpltui	r2,r2,4
 822b80c:	10000a1e 	bne	r2,zero,822b838 <dhc_extract_opts+0x164>
            dhc_states[iface].defgw = dh_getlong(opts);
 822b810:	e13ffe17 	ldw	r4,-8(fp)
 822b814:	822b6280 	call	822b628 <dh_getlong>
 822b818:	1009883a 	mov	r4,r2
 822b81c:	008209b4 	movhi	r2,2086
 822b820:	10b6d804 	addi	r2,r2,-9376
 822b824:	e0fffd17 	ldw	r3,-12(fp)
 822b828:	18c00f24 	muli	r3,r3,60
 822b82c:	10c5883a 	add	r2,r2,r3
 822b830:	10800b04 	addi	r2,r2,44
 822b834:	11000015 	stw	r4,0(r2)
         opts += optlen;
 822b838:	e0bffc03 	ldbu	r2,-16(fp)
 822b83c:	e0fffe17 	ldw	r3,-8(fp)
 822b840:	1885883a 	add	r2,r3,r2
 822b844:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b848:	00003306 	br	822b918 <dhc_extract_opts+0x244>
      case DHOP_LEASE:
         opts++;
 822b84c:	e0bffe17 	ldw	r2,-8(fp)
 822b850:	10800044 	addi	r2,r2,1
 822b854:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 822b858:	e13ffe17 	ldw	r4,-8(fp)
 822b85c:	822b6280 	call	822b628 <dh_getlong>
 822b860:	1004d63a 	srli	r2,r2,24
 822b864:	1021883a 	mov	r16,r2
 822b868:	e13ffe17 	ldw	r4,-8(fp)
 822b86c:	822b6280 	call	822b628 <dh_getlong>
 822b870:	1005d23a 	srai	r2,r2,8
 822b874:	10bfc00c 	andi	r2,r2,65280
 822b878:	80a0b03a 	or	r16,r16,r2
 822b87c:	e13ffe17 	ldw	r4,-8(fp)
 822b880:	822b6280 	call	822b628 <dh_getlong>
 822b884:	10bfc00c 	andi	r2,r2,65280
 822b888:	1004923a 	slli	r2,r2,8
 822b88c:	80a0b03a 	or	r16,r16,r2
 822b890:	e13ffe17 	ldw	r4,-8(fp)
 822b894:	822b6280 	call	822b628 <dh_getlong>
 822b898:	1004963a 	slli	r2,r2,24
 822b89c:	8084b03a 	or	r2,r16,r2
 822b8a0:	1009883a 	mov	r4,r2
 822b8a4:	008209b4 	movhi	r2,2086
 822b8a8:	10b6d804 	addi	r2,r2,-9376
 822b8ac:	e0fffd17 	ldw	r3,-12(fp)
 822b8b0:	18c00f24 	muli	r3,r3,60
 822b8b4:	10c5883a 	add	r2,r2,r3
 822b8b8:	10800504 	addi	r2,r2,20
 822b8bc:	11000015 	stw	r4,0(r2)
         opts += 4;
 822b8c0:	e0bffe17 	ldw	r2,-8(fp)
 822b8c4:	10800104 	addi	r2,r2,4
 822b8c8:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b8cc:	00001206 	br	822b918 <dhc_extract_opts+0x244>
      case DHOP_DNSRV:
         optlen = *opts++;
 822b8d0:	e0bffe17 	ldw	r2,-8(fp)
 822b8d4:	10c00044 	addi	r3,r2,1
 822b8d8:	e0fffe15 	stw	r3,-8(fp)
 822b8dc:	10800003 	ldbu	r2,0(r2)
 822b8e0:	e0bffc05 	stb	r2,-16(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 822b8e4:	e0bffc03 	ldbu	r2,-16(fp)
 822b8e8:	e0fffe17 	ldw	r3,-8(fp)
 822b8ec:	1885883a 	add	r2,r3,r2
 822b8f0:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b8f4:	00000806 	br	822b918 <dhc_extract_opts+0x244>
      default:
         opts += ((*opts) + 1);
 822b8f8:	e0bffe17 	ldw	r2,-8(fp)
 822b8fc:	10800003 	ldbu	r2,0(r2)
 822b900:	10803fcc 	andi	r2,r2,255
 822b904:	10800044 	addi	r2,r2,1
 822b908:	e0fffe17 	ldw	r3,-8(fp)
 822b90c:	1885883a 	add	r2,r3,r2
 822b910:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b914:	0001883a 	nop
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822b918:	e0bffe17 	ldw	r2,-8(fp)
 822b91c:	e0fffb17 	ldw	r3,-20(fp)
 822b920:	18bf8c2e 	bgeu	r3,r2,822b754 <dhc_extract_opts+0x80>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 822b924:	822d1c80 	call	822d1c8 <dtrap>
   return -1;
 822b928:	00bfffc4 	movi	r2,-1
}
 822b92c:	e6ffff04 	addi	sp,fp,-4
 822b930:	dfc00217 	ldw	ra,8(sp)
 822b934:	df000117 	ldw	fp,4(sp)
 822b938:	dc000017 	ldw	r16,0(sp)
 822b93c:	dec00304 	addi	sp,sp,12
 822b940:	f800283a 	ret

0822b944 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 822b944:	defffa04 	addi	sp,sp,-24
 822b948:	dfc00515 	stw	ra,20(sp)
 822b94c:	df000415 	stw	fp,16(sp)
 822b950:	df000404 	addi	fp,sp,16
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822b954:	e03ffc15 	stw	zero,-16(fp)
 822b958:	00014506 	br	822be70 <dhc_second+0x52c>
   {
      switch (dhc_states[iface].state)
 822b95c:	008209b4 	movhi	r2,2086
 822b960:	10b6d804 	addi	r2,r2,-9376
 822b964:	e0fffc17 	ldw	r3,-16(fp)
 822b968:	18c00f24 	muli	r3,r3,60
 822b96c:	10c5883a 	add	r2,r2,r3
 822b970:	10800017 	ldw	r2,0(r2)
 822b974:	10c00268 	cmpgeui	r3,r2,9
 822b978:	1801311e 	bne	r3,zero,822be40 <dhc_second+0x4fc>
 822b97c:	100690ba 	slli	r3,r2,2
 822b980:	008208f4 	movhi	r2,2083
 822b984:	10ae6504 	addi	r2,r2,-18028
 822b988:	1885883a 	add	r2,r3,r2
 822b98c:	10800017 	ldw	r2,0(r2)
 822b990:	1000683a 	jmp	r2
 822b994:	0822be40 	call	822be4 <OSCtxSw_SWITCH_PC+0x822ba4>
 822b998:	0822b9b8 	rdprs	zero,at,-29978
 822b99c:	0822b9e8 	cmpgeui	zero,at,35559
 822b9a0:	0822ba18 	cmpnei	zero,at,-29976
 822b9a4:	0822ba18 	cmpnei	zero,at,-29976
 822b9a8:	0822ba18 	cmpnei	zero,at,-29976
 822b9ac:	0822bc58 	cmpnei	zero,at,-29967
 822b9b0:	0822bd00 	call	822bd0 <OSCtxSw_SWITCH_PC+0x822b90>
 822b9b4:	0822bb34 	orhi	zero,at,35564
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 822b9b8:	e13ffc17 	ldw	r4,-16(fp)
 822b9bc:	822a18c0 	call	822a18c <dhc_discover>
 822b9c0:	e0bfff15 	stw	r2,-4(fp)
         /* Error while sending a discover packet */
         if (e)
 822b9c4:	e0bfff17 	ldw	r2,-4(fp)
 822b9c8:	10000326 	beq	r2,zero,822b9d8 <dhc_second+0x94>
         {
            dtrap();
 822b9cc:	822d1c80 	call	822d1c8 <dtrap>
            return e;
 822b9d0:	e0bfff17 	ldw	r2,-4(fp)
 822b9d4:	00012a06 	br	822be80 <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 822b9d8:	01400104 	movi	r5,4
 822b9dc:	e13ffc17 	ldw	r4,-16(fp)
 822b9e0:	822c2140 	call	822c214 <dhc_set_state>
         break;
 822b9e4:	00011f06 	br	822be64 <dhc_second+0x520>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 822b9e8:	e13ffc17 	ldw	r4,-16(fp)
 822b9ec:	822bf140 	call	822bf14 <dhc_reclaim>
 822b9f0:	e0bfff15 	stw	r2,-4(fp)
         if (e)
 822b9f4:	e0bfff17 	ldw	r2,-4(fp)
 822b9f8:	10000326 	beq	r2,zero,822ba08 <dhc_second+0xc4>
         {
            dtrap();
 822b9fc:	822d1c80 	call	822d1c8 <dtrap>
            return e;
 822ba00:	e0bfff17 	ldw	r2,-4(fp)
 822ba04:	00011e06 	br	822be80 <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 822ba08:	014000c4 	movi	r5,3
 822ba0c:	e13ffc17 	ldw	r4,-16(fp)
 822ba10:	822c2140 	call	822c214 <dhc_set_state>
         break;
 822ba14:	00011306 	br	822be64 <dhc_second+0x520>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 822ba18:	008209b4 	movhi	r2,2086
 822ba1c:	10b6d804 	addi	r2,r2,-9376
 822ba20:	e0fffc17 	ldw	r3,-16(fp)
 822ba24:	18c00f24 	muli	r3,r3,60
 822ba28:	10c5883a 	add	r2,r2,r3
 822ba2c:	10800104 	addi	r2,r2,4
 822ba30:	10800017 	ldw	r2,0(r2)
 822ba34:	e0bffd15 	stw	r2,-12(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 822ba38:	e0bffd17 	ldw	r2,-12(fp)
 822ba3c:	10800110 	cmplti	r2,r2,4
 822ba40:	1000021e 	bne	r2,zero,822ba4c <dhc_second+0x108>
            tries= DHC_MAX_TRIES;
 822ba44:	00800104 	movi	r2,4
 822ba48:	e0bffd15 	stw	r2,-12(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 822ba4c:	008209b4 	movhi	r2,2086
 822ba50:	10b6d804 	addi	r2,r2,-9376
 822ba54:	e0fffc17 	ldw	r3,-16(fp)
 822ba58:	18c00f24 	muli	r3,r3,60
 822ba5c:	10c5883a 	add	r2,r2,r3
 822ba60:	10800404 	addi	r2,r2,16
 822ba64:	10c00017 	ldw	r3,0(r2)
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
 822ba68:	01006404 	movi	r4,400
 822ba6c:	e0bffd17 	ldw	r2,-12(fp)
 822ba70:	2084983a 	sll	r2,r4,r2
         tries = dhc_states[iface].tries ;

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
            tries= DHC_MAX_TRIES;
         if ( cticks > (dhc_states[iface].last_tick + 
 822ba74:	1887883a 	add	r3,r3,r2
 822ba78:	d0a0a817 	ldw	r2,-32096(gp)
 822ba7c:	1880192e 	bgeu	r3,r2,822bae4 <dhc_second+0x1a0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 822ba80:	008209b4 	movhi	r2,2086
 822ba84:	10b6d804 	addi	r2,r2,-9376
 822ba88:	e0fffc17 	ldw	r3,-16(fp)
 822ba8c:	18c00f24 	muli	r3,r3,60
 822ba90:	10c5883a 	add	r2,r2,r3
 822ba94:	10800017 	ldw	r2,0(r2)
 822ba98:	10c00120 	cmpeqi	r3,r2,4
 822ba9c:	1800051e 	bne	r3,zero,822bab4 <dhc_second+0x170>
 822baa0:	10c00160 	cmpeqi	r3,r2,5
 822baa4:	1800061e 	bne	r3,zero,822bac0 <dhc_second+0x17c>
 822baa8:	108000e0 	cmpeqi	r2,r2,3
 822baac:	1000081e 	bne	r2,zero,822bad0 <dhc_second+0x18c>
 822bab0:	00000a06 	br	822badc <dhc_second+0x198>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 822bab4:	e13ffc17 	ldw	r4,-16(fp)
 822bab8:	822a18c0 	call	822a18c <dhc_discover>
               break;
 822babc:	00000906 	br	822bae4 <dhc_second+0x1a0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 822bac0:	000b883a 	mov	r5,zero
 822bac4:	e13ffc17 	ldw	r4,-16(fp)
 822bac8:	822a73c0 	call	822a73c <dhc_request>
               break;
 822bacc:	00000506 	br	822bae4 <dhc_second+0x1a0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 822bad0:	e13ffc17 	ldw	r4,-16(fp)
 822bad4:	822bf140 	call	822bf14 <dhc_reclaim>
               break;
 822bad8:	00000206 	br	822bae4 <dhc_second+0x1a0>
            default:
               dtrap(); /* bogus state */
 822badc:	822d1c80 	call	822d1c8 <dtrap>
               break;
 822bae0:	0001883a 	nop
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bae4:	e0bffd17 	ldw	r2,-12(fp)
 822bae8:	10800118 	cmpnei	r2,r2,4
 822baec:	1000d61e 	bne	r2,zero,822be48 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
 822baf0:	008209b4 	movhi	r2,2086
 822baf4:	10b6d804 	addi	r2,r2,-9376
 822baf8:	e0fffc17 	ldw	r3,-16(fp)
 822bafc:	18c00f24 	muli	r3,r3,60
 822bb00:	10c5883a 	add	r2,r2,r3
 822bb04:	10800017 	ldw	r2,0(r2)
            default:
               dtrap(); /* bogus state */
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bb08:	10800120 	cmpeqi	r2,r2,4
 822bb0c:	1000ce1e 	bne	r2,zero,822be48 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 822bb10:	01400244 	movi	r5,9
 822bb14:	e13ffc17 	ldw	r4,-16(fp)
 822bb18:	822c2140 	call	822c214 <dhc_set_state>
            dhc_resetip(iface);
 822bb1c:	e13ffc17 	ldw	r4,-16(fp)
 822bb20:	822b43c0 	call	822b43c <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bb24:	01400044 	movi	r5,1
 822bb28:	e13ffc17 	ldw	r4,-16(fp)
 822bb2c:	822c2140 	call	822c214 <dhc_set_state>
         }
         break;
 822bb30:	0000c506 	br	822be48 <dhc_second+0x504>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 822bb34:	008209b4 	movhi	r2,2086
 822bb38:	10b6d804 	addi	r2,r2,-9376
 822bb3c:	e0fffc17 	ldw	r3,-16(fp)
 822bb40:	18c00f24 	muli	r3,r3,60
 822bb44:	10c5883a 	add	r2,r2,r3
 822bb48:	10800504 	addi	r2,r2,20
 822bb4c:	10800017 	ldw	r2,0(r2)
 822bb50:	10c01924 	muli	r3,r2,100
 822bb54:	008209b4 	movhi	r2,2086
 822bb58:	10b6d804 	addi	r2,r2,-9376
 822bb5c:	e13ffc17 	ldw	r4,-16(fp)
 822bb60:	21000f24 	muli	r4,r4,60
 822bb64:	1105883a 	add	r2,r2,r4
 822bb68:	10800804 	addi	r2,r2,32
 822bb6c:	10800017 	ldw	r2,0(r2)
 822bb70:	1885883a 	add	r2,r3,r2
 822bb74:	d0e0a817 	ldw	r3,-32096(gp)
 822bb78:	18802e2e 	bgeu	r3,r2,822bc34 <dhc_second+0x2f0>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bb7c:	008209b4 	movhi	r2,2086
 822bb80:	10b6d804 	addi	r2,r2,-9376
 822bb84:	e0fffc17 	ldw	r3,-16(fp)
 822bb88:	18c00f24 	muli	r3,r3,60
 822bb8c:	10c5883a 	add	r2,r2,r3
 822bb90:	10800804 	addi	r2,r2,32
 822bb94:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].lease*TPS - 
 822bb98:	008209b4 	movhi	r2,2086
 822bb9c:	10b6d804 	addi	r2,r2,-9376
 822bba0:	e13ffc17 	ldw	r4,-16(fp)
 822bba4:	21000f24 	muli	r4,r4,60
 822bba8:	1105883a 	add	r2,r2,r4
 822bbac:	10800504 	addi	r2,r2,20
 822bbb0:	10800017 	ldw	r2,0(r2)
 822bbb4:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bbb8:	1887883a 	add	r3,r3,r2
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;
 822bbbc:	008209b4 	movhi	r2,2086
 822bbc0:	10b6d804 	addi	r2,r2,-9376
 822bbc4:	e13ffc17 	ldw	r4,-16(fp)
 822bbc8:	21000f24 	muli	r4,r4,60
 822bbcc:	1105883a 	add	r2,r2,r4
 822bbd0:	10800404 	addi	r2,r2,16
 822bbd4:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
             dhc_states[iface].lease*TPS - 
 822bbd8:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bbdc:	1004d07a 	srli	r2,r2,1
 822bbe0:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822bbe4:	e0bffe17 	ldw	r2,-8(fp)
 822bbe8:	1085dc28 	cmpgeui	r2,r2,6000
 822bbec:	1000021e 	bne	r2,zero,822bbf8 <dhc_second+0x2b4>
               half_time = 60*TPS;
 822bbf0:	0085dc04 	movi	r2,6000
 822bbf4:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822bbf8:	008209b4 	movhi	r2,2086
 822bbfc:	10b6d804 	addi	r2,r2,-9376
 822bc00:	e0fffc17 	ldw	r3,-16(fp)
 822bc04:	18c00f24 	muli	r3,r3,60
 822bc08:	10c5883a 	add	r2,r2,r3
 822bc0c:	10800404 	addi	r2,r2,16
 822bc10:	10c00017 	ldw	r3,0(r2)
 822bc14:	e0bffe17 	ldw	r2,-8(fp)
 822bc18:	1887883a 	add	r3,r3,r2
 822bc1c:	d0a0a817 	ldw	r2,-32096(gp)
 822bc20:	18808b2e 	bgeu	r3,r2,822be50 <dhc_second+0x50c>
            {
               dhc_request(iface,FALSE);
 822bc24:	000b883a 	mov	r5,zero
 822bc28:	e13ffc17 	ldw	r4,-16(fp)
 822bc2c:	822a73c0 	call	822a73c <dhc_request>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822bc30:	00008706 	br	822be50 <dhc_second+0x50c>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 822bc34:	01400244 	movi	r5,9
 822bc38:	e13ffc17 	ldw	r4,-16(fp)
 822bc3c:	822c2140 	call	822c214 <dhc_set_state>
            dhc_resetip(iface);
 822bc40:	e13ffc17 	ldw	r4,-16(fp)
 822bc44:	822b43c0 	call	822b43c <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bc48:	01400044 	movi	r5,1
 822bc4c:	e13ffc17 	ldw	r4,-16(fp)
 822bc50:	822c2140 	call	822c214 <dhc_set_state>
         }
         break;
 822bc54:	00007e06 	br	822be50 <dhc_second+0x50c>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822bc58:	008209b4 	movhi	r2,2086
 822bc5c:	10b6d804 	addi	r2,r2,-9376
 822bc60:	e0fffc17 	ldw	r3,-16(fp)
 822bc64:	18c00f24 	muli	r3,r3,60
 822bc68:	10c5883a 	add	r2,r2,r3
 822bc6c:	10800604 	addi	r2,r2,24
 822bc70:	10800017 	ldw	r2,0(r2)
 822bc74:	10bfffe0 	cmpeqi	r2,r2,-1
 822bc78:	1000771e 	bne	r2,zero,822be58 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
 822bc7c:	008209b4 	movhi	r2,2086
 822bc80:	10b6d804 	addi	r2,r2,-9376
 822bc84:	e0fffc17 	ldw	r3,-16(fp)
 822bc88:	18c00f24 	muli	r3,r3,60
 822bc8c:	10c5883a 	add	r2,r2,r3
 822bc90:	10800604 	addi	r2,r2,24
 822bc94:	10800017 	ldw	r2,0(r2)
 822bc98:	10c01924 	muli	r3,r2,100
 822bc9c:	008209b4 	movhi	r2,2086
 822bca0:	10b6d804 	addi	r2,r2,-9376
 822bca4:	e13ffc17 	ldw	r4,-16(fp)
 822bca8:	21000f24 	muli	r4,r4,60
 822bcac:	1105883a 	add	r2,r2,r4
 822bcb0:	10800804 	addi	r2,r2,32
 822bcb4:	10800017 	ldw	r2,0(r2)
 822bcb8:	1887883a 	add	r3,r3,r2
 822bcbc:	d0a0a817 	ldw	r2,-32096(gp)
         }
         break;

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822bcc0:	1880652e 	bgeu	r3,r2,822be58 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 822bcc4:	014001c4 	movi	r5,7
 822bcc8:	e13ffc17 	ldw	r4,-16(fp)
 822bccc:	822c2140 	call	822c214 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 822bcd0:	e13ffc17 	ldw	r4,-16(fp)
 822bcd4:	822bf140 	call	822bf14 <dhc_reclaim>
 822bcd8:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822bcdc:	e0bfff17 	ldw	r2,-4(fp)
 822bce0:	10000326 	beq	r2,zero,822bcf0 <dhc_second+0x3ac>
            {
               dtrap();
 822bce4:	822d1c80 	call	822d1c8 <dtrap>
               return e;
 822bce8:	e0bfff17 	ldw	r2,-4(fp)
 822bcec:	00006406 	br	822be80 <dhc_second+0x53c>
            }
            dsc_renew++;
 822bcf0:	d0a09917 	ldw	r2,-32156(gp)
 822bcf4:	10800044 	addi	r2,r2,1
 822bcf8:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 822bcfc:	00005606 	br	822be58 <dhc_second+0x514>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 822bd00:	008209b4 	movhi	r2,2086
 822bd04:	10b6d804 	addi	r2,r2,-9376
 822bd08:	e0fffc17 	ldw	r3,-16(fp)
 822bd0c:	18c00f24 	muli	r3,r3,60
 822bd10:	10c5883a 	add	r2,r2,r3
 822bd14:	10800704 	addi	r2,r2,28
 822bd18:	10800017 	ldw	r2,0(r2)
 822bd1c:	10c01924 	muli	r3,r2,100
 822bd20:	008209b4 	movhi	r2,2086
 822bd24:	10b6d804 	addi	r2,r2,-9376
 822bd28:	e13ffc17 	ldw	r4,-16(fp)
 822bd2c:	21000f24 	muli	r4,r4,60
 822bd30:	1105883a 	add	r2,r2,r4
 822bd34:	10800804 	addi	r2,r2,32
 822bd38:	10800017 	ldw	r2,0(r2)
 822bd3c:	1885883a 	add	r2,r3,r2
 822bd40:	d0e0a817 	ldw	r3,-32096(gp)
 822bd44:	18802e2e 	bgeu	r3,r2,822be00 <dhc_second+0x4bc>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bd48:	008209b4 	movhi	r2,2086
 822bd4c:	10b6d804 	addi	r2,r2,-9376
 822bd50:	e0fffc17 	ldw	r3,-16(fp)
 822bd54:	18c00f24 	muli	r3,r3,60
 822bd58:	10c5883a 	add	r2,r2,r3
 822bd5c:	10800804 	addi	r2,r2,32
 822bd60:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].t2*TPS - 
 822bd64:	008209b4 	movhi	r2,2086
 822bd68:	10b6d804 	addi	r2,r2,-9376
 822bd6c:	e13ffc17 	ldw	r4,-16(fp)
 822bd70:	21000f24 	muli	r4,r4,60
 822bd74:	1105883a 	add	r2,r2,r4
 822bd78:	10800704 	addi	r2,r2,28
 822bd7c:	10800017 	ldw	r2,0(r2)
 822bd80:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bd84:	1887883a 	add	r3,r3,r2
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;
 822bd88:	008209b4 	movhi	r2,2086
 822bd8c:	10b6d804 	addi	r2,r2,-9376
 822bd90:	e13ffc17 	ldw	r4,-16(fp)
 822bd94:	21000f24 	muli	r4,r4,60
 822bd98:	1105883a 	add	r2,r2,r4
 822bd9c:	10800404 	addi	r2,r2,16
 822bda0:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
             dhc_states[iface].t2*TPS - 
 822bda4:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bda8:	1004d07a 	srli	r2,r2,1
 822bdac:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822bdb0:	e0bffe17 	ldw	r2,-8(fp)
 822bdb4:	1085dc28 	cmpgeui	r2,r2,6000
 822bdb8:	1000021e 	bne	r2,zero,822bdc4 <dhc_second+0x480>
               half_time = 60*TPS;
 822bdbc:	0085dc04 	movi	r2,6000
 822bdc0:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822bdc4:	008209b4 	movhi	r2,2086
 822bdc8:	10b6d804 	addi	r2,r2,-9376
 822bdcc:	e0fffc17 	ldw	r3,-16(fp)
 822bdd0:	18c00f24 	muli	r3,r3,60
 822bdd4:	10c5883a 	add	r2,r2,r3
 822bdd8:	10800404 	addi	r2,r2,16
 822bddc:	10c00017 	ldw	r3,0(r2)
 822bde0:	e0bffe17 	ldw	r2,-8(fp)
 822bde4:	1887883a 	add	r3,r3,r2
 822bde8:	d0a0a817 	ldw	r2,-32096(gp)
 822bdec:	18801c2e 	bgeu	r3,r2,822be60 <dhc_second+0x51c>
            {
               dhc_request(iface,FALSE);
 822bdf0:	000b883a 	mov	r5,zero
 822bdf4:	e13ffc17 	ldw	r4,-16(fp)
 822bdf8:	822a73c0 	call	822a73c <dhc_request>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822bdfc:	00001806 	br	822be60 <dhc_second+0x51c>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 822be00:	01400204 	movi	r5,8
 822be04:	e13ffc17 	ldw	r4,-16(fp)
 822be08:	822c2140 	call	822c214 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 822be0c:	01400044 	movi	r5,1
 822be10:	e13ffc17 	ldw	r4,-16(fp)
 822be14:	822a73c0 	call	822a73c <dhc_request>
 822be18:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822be1c:	e0bfff17 	ldw	r2,-4(fp)
 822be20:	10000326 	beq	r2,zero,822be30 <dhc_second+0x4ec>
            {
               dtrap();
 822be24:	822d1c80 	call	822d1c8 <dtrap>
               return e;
 822be28:	e0bfff17 	ldw	r2,-4(fp)
 822be2c:	00001406 	br	822be80 <dhc_second+0x53c>
            }
            dsc_rebind++;
 822be30:	d0a09a17 	ldw	r2,-32152(gp)
 822be34:	10800044 	addi	r2,r2,1
 822be38:	d0a09a15 	stw	r2,-32152(gp)
         }
         break;
 822be3c:	00000806 	br	822be60 <dhc_second+0x51c>
      case DHCS_UNUSED:
      default:
         continue;
 822be40:	0001883a 	nop
 822be44:	00000706 	br	822be64 <dhc_second+0x520>
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822be48:	0001883a 	nop
 822be4c:	00000506 	br	822be64 <dhc_second+0x520>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822be50:	0001883a 	nop
 822be54:	00000306 	br	822be64 <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_renew++;
         }
         break;
 822be58:	0001883a 	nop
 822be5c:	00000106 	br	822be64 <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822be60:	0001883a 	nop
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822be64:	e0bffc17 	ldw	r2,-16(fp)
 822be68:	10800044 	addi	r2,r2,1
 822be6c:	e0bffc15 	stw	r2,-16(fp)
 822be70:	e0bffc17 	ldw	r2,-16(fp)
 822be74:	10800110 	cmplti	r2,r2,4
 822be78:	103eb81e 	bne	r2,zero,822b95c <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 822be7c:	0005883a 	mov	r2,zero
}
 822be80:	e037883a 	mov	sp,fp
 822be84:	dfc00117 	ldw	ra,4(sp)
 822be88:	df000017 	ldw	fp,0(sp)
 822be8c:	dec00204 	addi	sp,sp,8
 822be90:	f800283a 	ret

0822be94 <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 822be94:	defffd04 	addi	sp,sp,-12
 822be98:	dfc00215 	stw	ra,8(sp)
 822be9c:	df000115 	stw	fp,4(sp)
 822bea0:	df000104 	addi	fp,sp,4
 822bea4:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 822bea8:	e0bfff17 	ldw	r2,-4(fp)
 822beac:	10000316 	blt	r2,zero,822bebc <dhc_halt+0x28>
 822beb0:	e0bfff17 	ldw	r2,-4(fp)
 822beb4:	10800150 	cmplti	r2,r2,5
 822beb8:	1000021e 	bne	r2,zero,822bec4 <dhc_halt+0x30>
   {
      dtrap();
 822bebc:	822d1c80 	call	822d1c8 <dtrap>
      return;
 822bec0:	00000f06 	br	822bf00 <dhc_halt+0x6c>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 822bec4:	e0bfff17 	ldw	r2,-4(fp)
 822bec8:	10c00f24 	muli	r3,r2,60
 822becc:	008209b4 	movhi	r2,2086
 822bed0:	10b6d804 	addi	r2,r2,-9376
 822bed4:	1885883a 	add	r2,r3,r2
 822bed8:	01800f04 	movi	r6,60
 822bedc:	000b883a 	mov	r5,zero
 822bee0:	1009883a 	mov	r4,r2
 822bee4:	8202cb00 	call	8202cb0 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 822bee8:	008209b4 	movhi	r2,2086
 822beec:	10b6d804 	addi	r2,r2,-9376
 822bef0:	e0ffff17 	ldw	r3,-4(fp)
 822bef4:	18c00f24 	muli	r3,r3,60
 822bef8:	10c5883a 	add	r2,r2,r3
 822befc:	10000015 	stw	zero,0(r2)
}
 822bf00:	e037883a 	mov	sp,fp
 822bf04:	dfc00117 	ldw	ra,4(sp)
 822bf08:	df000017 	ldw	fp,0(sp)
 822bf0c:	dec00204 	addi	sp,sp,8
 822bf10:	f800283a 	ret

0822bf14 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 822bf14:	defffc04 	addi	sp,sp,-16
 822bf18:	dfc00315 	stw	ra,12(sp)
 822bf1c:	df000215 	stw	fp,8(sp)
 822bf20:	df000204 	addi	fp,sp,8
 822bf24:	e13fff15 	stw	r4,-4(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 822bf28:	008209b4 	movhi	r2,2086
 822bf2c:	10b6b204 	addi	r2,r2,-9528
 822bf30:	e0ffff17 	ldw	r3,-4(fp)
 822bf34:	18c7883a 	add	r3,r3,r3
 822bf38:	18c7883a 	add	r3,r3,r3
 822bf3c:	10c5883a 	add	r2,r2,r3
 822bf40:	10800017 	ldw	r2,0(r2)
 822bf44:	10800a17 	ldw	r2,40(r2)
 822bf48:	1000031e 	bne	r2,zero,822bf58 <dhc_reclaim+0x44>
   {
      dtrap();    /* programming bug? */
 822bf4c:	822d1c80 	call	822d1c8 <dtrap>
      return ENP_LOGIC;
 822bf50:	00bffd44 	movi	r2,-11
 822bf54:	00005806 	br	822c0b8 <dhc_reclaim+0x1a4>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 822bf58:	008209b4 	movhi	r2,2086
 822bf5c:	10b6b204 	addi	r2,r2,-9528
 822bf60:	e0ffff17 	ldw	r3,-4(fp)
 822bf64:	18c7883a 	add	r3,r3,r3
 822bf68:	18c7883a 	add	r3,r3,r3
 822bf6c:	10c5883a 	add	r2,r2,r3
 822bf70:	10800017 	ldw	r2,0(r2)
 822bf74:	10c00a17 	ldw	r3,40(r2)
 822bf78:	008209b4 	movhi	r2,2086
 822bf7c:	10b6d804 	addi	r2,r2,-9376
 822bf80:	e13fff17 	ldw	r4,-4(fp)
 822bf84:	21000f24 	muli	r4,r4,60
 822bf88:	1105883a 	add	r2,r2,r4
 822bf8c:	10800904 	addi	r2,r2,36
 822bf90:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 822bf94:	008209b4 	movhi	r2,2086
 822bf98:	10b6b204 	addi	r2,r2,-9528
 822bf9c:	e0ffff17 	ldw	r3,-4(fp)
 822bfa0:	18c7883a 	add	r3,r3,r3
 822bfa4:	18c7883a 	add	r3,r3,r3
 822bfa8:	10c5883a 	add	r2,r2,r3
 822bfac:	10800017 	ldw	r2,0(r2)
 822bfb0:	10c00c17 	ldw	r3,48(r2)
 822bfb4:	008209b4 	movhi	r2,2086
 822bfb8:	10b6d804 	addi	r2,r2,-9376
 822bfbc:	e13fff17 	ldw	r4,-4(fp)
 822bfc0:	21000f24 	muli	r4,r4,60
 822bfc4:	1105883a 	add	r2,r2,r4
 822bfc8:	10800a04 	addi	r2,r2,40
 822bfcc:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 822bfd0:	008209b4 	movhi	r2,2086
 822bfd4:	10b6b204 	addi	r2,r2,-9528
 822bfd8:	e0ffff17 	ldw	r3,-4(fp)
 822bfdc:	18c7883a 	add	r3,r3,r3
 822bfe0:	18c7883a 	add	r3,r3,r3
 822bfe4:	10c5883a 	add	r2,r2,r3
 822bfe8:	10800017 	ldw	r2,0(r2)
 822bfec:	10c00d17 	ldw	r3,52(r2)
 822bff0:	008209b4 	movhi	r2,2086
 822bff4:	10b6d804 	addi	r2,r2,-9376
 822bff8:	e13fff17 	ldw	r4,-4(fp)
 822bffc:	21000f24 	muli	r4,r4,60
 822c000:	1105883a 	add	r2,r2,r4
 822c004:	10800b04 	addi	r2,r2,44
 822c008:	10c00015 	stw	r3,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 822c00c:	008209b4 	movhi	r2,2086
 822c010:	10b6d804 	addi	r2,r2,-9376
 822c014:	e0ffff17 	ldw	r3,-4(fp)
 822c018:	18c00f24 	muli	r3,r3,60
 822c01c:	10c5883a 	add	r2,r2,r3
 822c020:	10800c04 	addi	r2,r2,48
 822c024:	10800017 	ldw	r2,0(r2)
 822c028:	10002026 	beq	r2,zero,822c0ac <dhc_reclaim+0x198>
   {
      if (dhc_states[iface].srv_ipaddr)
 822c02c:	008209b4 	movhi	r2,2086
 822c030:	10b6d804 	addi	r2,r2,-9376
 822c034:	e0ffff17 	ldw	r3,-4(fp)
 822c038:	18c00f24 	muli	r3,r3,60
 822c03c:	10c5883a 	add	r2,r2,r3
 822c040:	10800d04 	addi	r2,r2,52
 822c044:	10800017 	ldw	r2,0(r2)
 822c048:	10001726 	beq	r2,zero,822c0a8 <dhc_reclaim+0x194>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 822c04c:	008209b4 	movhi	r2,2086
 822c050:	10b6d804 	addi	r2,r2,-9376
 822c054:	e0ffff17 	ldw	r3,-4(fp)
 822c058:	18c00f24 	muli	r3,r3,60
 822c05c:	10c5883a 	add	r2,r2,r3
 822c060:	10800d04 	addi	r2,r2,52
 822c064:	11000017 	ldw	r4,0(r2)
 822c068:	008209b4 	movhi	r2,2086
 822c06c:	10b6d804 	addi	r2,r2,-9376
 822c070:	e0ffff17 	ldw	r3,-4(fp)
 822c074:	18c00f24 	muli	r3,r3,60
 822c078:	10c5883a 	add	r2,r2,r3
 822c07c:	10800c04 	addi	r2,r2,48
 822c080:	10c00017 	ldw	r3,0(r2)
 822c084:	00800084 	movi	r2,2
 822c088:	d8800015 	stw	r2,0(sp)
 822c08c:	e1ffff17 	ldw	r7,-4(fp)
 822c090:	180d883a 	mov	r6,r3
 822c094:	017fffc4 	movi	r5,-1
 822c098:	8243f840 	call	8243f84 <add_route>
 822c09c:	1000031e 	bne	r2,zero,822c0ac <dhc_reclaim+0x198>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 822c0a0:	822d1c80 	call	822d1c8 <dtrap>
 822c0a4:	00000106 	br	822c0ac <dhc_reclaim+0x198>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 822c0a8:	822d1c80 	call	822d1c8 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 822c0ac:	01400044 	movi	r5,1
 822c0b0:	e13fff17 	ldw	r4,-4(fp)
 822c0b4:	822a73c0 	call	822a73c <dhc_request>
}
 822c0b8:	e037883a 	mov	sp,fp
 822c0bc:	dfc00117 	ldw	ra,4(sp)
 822c0c0:	df000017 	ldw	fp,0(sp)
 822c0c4:	dec00204 	addi	sp,sp,8
 822c0c8:	f800283a 	ret

0822c0cc <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 822c0cc:	defffb04 	addi	sp,sp,-20
 822c0d0:	dfc00415 	stw	ra,16(sp)
 822c0d4:	df000315 	stw	fp,12(sp)
 822c0d8:	df000304 	addi	fp,sp,12
 822c0dc:	e13ffe15 	stw	r4,-8(fp)
 822c0e0:	e17fff15 	stw	r5,-4(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 822c0e4:	e0bfff17 	ldw	r2,-4(fp)
 822c0e8:	10800058 	cmpnei	r2,r2,1
 822c0ec:	1000021e 	bne	r2,zero,822c0f8 <dhc_state_init+0x2c>
 822c0f0:	00800044 	movi	r2,1
 822c0f4:	00000106 	br	822c0fc <dhc_state_init+0x30>
 822c0f8:	00800084 	movi	r2,2
 822c0fc:	e0bffd15 	stw	r2,-12(fp)
   
   dhc_set_state(iface, state);
 822c100:	e17ffd17 	ldw	r5,-12(fp)
 822c104:	e13ffe17 	ldw	r4,-8(fp)
 822c108:	822c2140 	call	822c214 <dhc_set_state>
}
 822c10c:	0001883a 	nop
 822c110:	e037883a 	mov	sp,fp
 822c114:	dfc00117 	ldw	ra,4(sp)
 822c118:	df000017 	ldw	fp,0(sp)
 822c11c:	dec00204 	addi	sp,sp,8
 822c120:	f800283a 	ret

0822c124 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 822c124:	defffe04 	addi	sp,sp,-8
 822c128:	df000115 	stw	fp,4(sp)
 822c12c:	df000104 	addi	fp,sp,4
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c130:	e03fff15 	stw	zero,-4(fp)
 822c134:	00001506 	br	822c18c <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c138:	008209b4 	movhi	r2,2086
 822c13c:	10b6d804 	addi	r2,r2,-9376
 822c140:	e0ffff17 	ldw	r3,-4(fp)
 822c144:	18c00f24 	muli	r3,r3,60
 822c148:	10c5883a 	add	r2,r2,r3
 822c14c:	10800017 	ldw	r2,0(r2)
 822c150:	10000826 	beq	r2,zero,822c174 <dhc_alldone+0x50>
          ( dhc_states[i].state == DHCS_BOUND  )  )
 822c154:	008209b4 	movhi	r2,2086
 822c158:	10b6d804 	addi	r2,r2,-9376
 822c15c:	e0ffff17 	ldw	r3,-4(fp)
 822c160:	18c00f24 	muli	r3,r3,60
 822c164:	10c5883a 	add	r2,r2,r3
 822c168:	10800017 	ldw	r2,0(r2)
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c16c:	10800198 	cmpnei	r2,r2,6
 822c170:	1000041e 	bne	r2,zero,822c184 <dhc_alldone+0x60>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c174:	e0bfff17 	ldw	r2,-4(fp)
 822c178:	10800044 	addi	r2,r2,1
 822c17c:	e0bfff15 	stw	r2,-4(fp)
 822c180:	00000206 	br	822c18c <dhc_alldone+0x68>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 822c184:	0005883a 	mov	r2,zero
 822c188:	00000406 	br	822c19c <dhc_alldone+0x78>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c18c:	e0bfff17 	ldw	r2,-4(fp)
 822c190:	10800110 	cmplti	r2,r2,4
 822c194:	103fe81e 	bne	r2,zero,822c138 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 822c198:	00800044 	movi	r2,1
}
 822c19c:	e037883a 	mov	sp,fp
 822c1a0:	df000017 	ldw	fp,0(sp)
 822c1a4:	dec00104 	addi	sp,sp,4
 822c1a8:	f800283a 	ret

0822c1ac <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 822c1ac:	defffe04 	addi	sp,sp,-8
 822c1b0:	df000115 	stw	fp,4(sp)
 822c1b4:	df000104 	addi	fp,sp,4
 822c1b8:	e13fff15 	stw	r4,-4(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c1bc:	008209b4 	movhi	r2,2086
 822c1c0:	10b6d804 	addi	r2,r2,-9376
 822c1c4:	e0ffff17 	ldw	r3,-4(fp)
 822c1c8:	18c00f24 	muli	r3,r3,60
 822c1cc:	10c5883a 	add	r2,r2,r3
 822c1d0:	10800017 	ldw	r2,0(r2)
 822c1d4:	10000826 	beq	r2,zero,822c1f8 <dhc_ifacedone+0x4c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
 822c1d8:	008209b4 	movhi	r2,2086
 822c1dc:	10b6d804 	addi	r2,r2,-9376
 822c1e0:	e0ffff17 	ldw	r3,-4(fp)
 822c1e4:	18c00f24 	muli	r3,r3,60
 822c1e8:	10c5883a 	add	r2,r2,r3
 822c1ec:	10800017 	ldw	r2,0(r2)
 */

int 
dhc_ifacedone(int iface)
{
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c1f0:	10800198 	cmpnei	r2,r2,6
 822c1f4:	1000021e 	bne	r2,zero,822c200 <dhc_ifacedone+0x54>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 822c1f8:	00800044 	movi	r2,1
 822c1fc:	00000106 	br	822c204 <dhc_ifacedone+0x58>
   }
   else
   {
      return FALSE ;
 822c200:	0005883a 	mov	r2,zero
   }
}
 822c204:	e037883a 	mov	sp,fp
 822c208:	df000017 	ldw	fp,0(sp)
 822c20c:	dec00104 	addi	sp,sp,4
 822c210:	f800283a 	ret

0822c214 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 822c214:	defffc04 	addi	sp,sp,-16
 822c218:	dfc00315 	stw	ra,12(sp)
 822c21c:	df000215 	stw	fp,8(sp)
 822c220:	df000204 	addi	fp,sp,8
 822c224:	e13ffe15 	stw	r4,-8(fp)
 822c228:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 822c22c:	e0ffff17 	ldw	r3,-4(fp)
 822c230:	008209b4 	movhi	r2,2086
 822c234:	10b6d804 	addi	r2,r2,-9376
 822c238:	e13ffe17 	ldw	r4,-8(fp)
 822c23c:	21000f24 	muli	r4,r4,60
 822c240:	1105883a 	add	r2,r2,r4
 822c244:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 822c248:	008209b4 	movhi	r2,2086
 822c24c:	10b6d804 	addi	r2,r2,-9376
 822c250:	e0fffe17 	ldw	r3,-8(fp)
 822c254:	18c00f24 	muli	r3,r3,60
 822c258:	10c5883a 	add	r2,r2,r3
 822c25c:	10800104 	addi	r2,r2,4
 822c260:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 822c264:	008209b4 	movhi	r2,2086
 822c268:	10b6d804 	addi	r2,r2,-9376
 822c26c:	e0fffe17 	ldw	r3,-8(fp)
 822c270:	18c00f24 	muli	r3,r3,60
 822c274:	10c5883a 	add	r2,r2,r3
 822c278:	10800e04 	addi	r2,r2,56
 822c27c:	10800017 	ldw	r2,0(r2)
 822c280:	10000a26 	beq	r2,zero,822c2ac <dhc_set_state+0x98>
      dhc_states[iface].callback(iface,state);
 822c284:	008209b4 	movhi	r2,2086
 822c288:	10b6d804 	addi	r2,r2,-9376
 822c28c:	e0fffe17 	ldw	r3,-8(fp)
 822c290:	18c00f24 	muli	r3,r3,60
 822c294:	10c5883a 	add	r2,r2,r3
 822c298:	10800e04 	addi	r2,r2,56
 822c29c:	10800017 	ldw	r2,0(r2)
 822c2a0:	e17fff17 	ldw	r5,-4(fp)
 822c2a4:	e13ffe17 	ldw	r4,-8(fp)
 822c2a8:	103ee83a 	callr	r2
}
 822c2ac:	0001883a 	nop
 822c2b0:	e037883a 	mov	sp,fp
 822c2b4:	dfc00117 	ldw	ra,4(sp)
 822c2b8:	df000017 	ldw	fp,0(sp)
 822c2bc:	dec00204 	addi	sp,sp,8
 822c2c0:	f800283a 	ret

0822c2c4 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 822c2c4:	defffc04 	addi	sp,sp,-16
 822c2c8:	df000315 	stw	fp,12(sp)
 822c2cc:	df000304 	addi	fp,sp,12
 822c2d0:	2005883a 	mov	r2,r4
 822c2d4:	e17fff15 	stw	r5,-4(fp)
 822c2d8:	e0bffe05 	stb	r2,-8(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 822c2dc:	e0bfff17 	ldw	r2,-4(fp)
 822c2e0:	10804e04 	addi	r2,r2,312
 822c2e4:	e0bffd15 	stw	r2,-12(fp)

   while (opts < end)
 822c2e8:	00001e06 	br	822c364 <find_opt+0xa0>
   {
      if (*opts == opcode) /* found it */
 822c2ec:	e0bfff17 	ldw	r2,-4(fp)
 822c2f0:	10800003 	ldbu	r2,0(r2)
 822c2f4:	10c03fcc 	andi	r3,r2,255
 822c2f8:	e0bffe03 	ldbu	r2,-8(fp)
 822c2fc:	1880021e 	bne	r3,r2,822c308 <find_opt+0x44>
         return opts;
 822c300:	e0bfff17 	ldw	r2,-4(fp)
 822c304:	00001b06 	br	822c374 <find_opt+0xb0>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 822c308:	e0bfff17 	ldw	r2,-4(fp)
 822c30c:	10800003 	ldbu	r2,0(r2)
 822c310:	10803fcc 	andi	r2,r2,255
 822c314:	10803fd8 	cmpnei	r2,r2,255
 822c318:	1000021e 	bne	r2,zero,822c324 <find_opt+0x60>
         return NULL;
 822c31c:	0005883a 	mov	r2,zero
 822c320:	00001406 	br	822c374 <find_opt+0xb0>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 822c324:	e0bfff17 	ldw	r2,-4(fp)
 822c328:	10800003 	ldbu	r2,0(r2)
 822c32c:	10803fcc 	andi	r2,r2,255
 822c330:	1000041e 	bne	r2,zero,822c344 <find_opt+0x80>
         opts++;
 822c334:	e0bfff17 	ldw	r2,-4(fp)
 822c338:	10800044 	addi	r2,r2,1
 822c33c:	e0bfff15 	stw	r2,-4(fp)
 822c340:	00000806 	br	822c364 <find_opt+0xa0>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 822c344:	e0bfff17 	ldw	r2,-4(fp)
 822c348:	10800044 	addi	r2,r2,1
 822c34c:	10800003 	ldbu	r2,0(r2)
 822c350:	10803fcc 	andi	r2,r2,255
 822c354:	10800084 	addi	r2,r2,2
 822c358:	e0ffff17 	ldw	r3,-4(fp)
 822c35c:	1885883a 	add	r2,r3,r2
 822c360:	e0bfff15 	stw	r2,-4(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 822c364:	e0ffff17 	ldw	r3,-4(fp)
 822c368:	e0bffd17 	ldw	r2,-12(fp)
 822c36c:	18bfdf36 	bltu	r3,r2,822c2ec <find_opt+0x28>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 822c370:	0005883a 	mov	r2,zero
}
 822c374:	e037883a 	mov	sp,fp
 822c378:	df000017 	ldw	fp,0(sp)
 822c37c:	dec00104 	addi	sp,sp,4
 822c380:	f800283a 	ret

0822c384 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 822c384:	defff804 	addi	sp,sp,-32
 822c388:	dfc00715 	stw	ra,28(sp)
 822c38c:	df000615 	stw	fp,24(sp)
 822c390:	df000604 	addi	fp,sp,24
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 822c394:	d0e03817 	ldw	r3,-32544(gp)
 822c398:	d0a03617 	ldw	r2,-32552(gp)
 822c39c:	1885883a 	add	r2,r3,r2
 822c3a0:	e0bffd15 	stw	r2,-12(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 822c3a4:	e03ffe05 	stb	zero,-8(fp)
#endif

   for (i = 0; i < numpkts; i++)
 822c3a8:	e03ffa15 	stw	zero,-24(fp)
 822c3ac:	00007a06 	br	822c598 <pk_init+0x214>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 822c3b0:	01000d04 	movi	r4,52
 822c3b4:	822dda00 	call	822dda0 <npalloc>
 822c3b8:	e0bfff15 	stw	r2,-4(fp)
      if (packet == NULL)
 822c3bc:	e0bfff17 	ldw	r2,-4(fp)
 822c3c0:	10008426 	beq	r2,zero,822c5d4 <pk_init+0x250>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 822c3c4:	e0bffa17 	ldw	r2,-24(fp)
 822c3c8:	10800f30 	cmpltui	r2,r2,60
 822c3cc:	1000051e 	bne	r2,zero,822c3e4 <pk_init+0x60>
      {
         dprintf("pk_init: bad define\n");
 822c3d0:	01020974 	movhi	r4,2085
 822c3d4:	2100b204 	addi	r4,r4,712
 822c3d8:	82031200 	call	8203120 <puts>
         return -1;
 822c3dc:	00bfffc4 	movi	r2,-1
 822c3e0:	00008a06 	br	822c60c <pk_init+0x288>
      }
      pktlog[i] = packet;     /* save for debugging */
 822c3e4:	008209b4 	movhi	r2,2086
 822c3e8:	10b71d04 	addi	r2,r2,-9100
 822c3ec:	e0fffa17 	ldw	r3,-24(fp)
 822c3f0:	18c7883a 	add	r3,r3,r3
 822c3f4:	18c7883a 	add	r3,r3,r3
 822c3f8:	10c5883a 	add	r2,r2,r3
 822c3fc:	e0ffff17 	ldw	r3,-4(fp)
 822c400:	10c00015 	stw	r3,0(r2)
#endif

      packet->nb_tstamp = 0L;
 822c404:	e0bfff17 	ldw	r2,-4(fp)
 822c408:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 822c40c:	d0a03817 	ldw	r2,-32544(gp)
 822c410:	e0fffa17 	ldw	r3,-24(fp)
 822c414:	18802f2e 	bgeu	r3,r2,822c4d4 <pk_init+0x150>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 822c418:	d0a03917 	ldw	r2,-32540(gp)
 822c41c:	10800144 	addi	r2,r2,5
 822c420:	1009883a 	mov	r4,r2
 822c424:	822de140 	call	822de14 <ncpalloc>
 822c428:	1007883a 	mov	r3,r2
 822c42c:	e0bfff17 	ldw	r2,-4(fp)
 822c430:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c434:	e0bfff17 	ldw	r2,-4(fp)
 822c438:	10800117 	ldw	r2,4(r2)
 822c43c:	10006726 	beq	r2,zero,822c5dc <pk_init+0x258>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c440:	e03ffb15 	stw	zero,-20(fp)
 822c444:	00000906 	br	822c46c <pk_init+0xe8>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c448:	e0bfff17 	ldw	r2,-4(fp)
 822c44c:	10c00117 	ldw	r3,4(r2)
 822c450:	e0bffb17 	ldw	r2,-20(fp)
 822c454:	1885883a 	add	r2,r3,r2
 822c458:	00c01344 	movi	r3,77
 822c45c:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c460:	e0bffb17 	ldw	r2,-20(fp)
 822c464:	10800044 	addi	r2,r2,1
 822c468:	e0bffb15 	stw	r2,-20(fp)
 822c46c:	e0bffb17 	ldw	r2,-20(fp)
 822c470:	10800110 	cmplti	r2,r2,4
 822c474:	103ff41e 	bne	r2,zero,822c448 <pk_init+0xc4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 822c478:	e0bfff17 	ldw	r2,-4(fp)
 822c47c:	10c00117 	ldw	r3,4(r2)
 822c480:	d0a03917 	ldw	r2,-32540(gp)
 822c484:	10800104 	addi	r2,r2,4
 822c488:	1885883a 	add	r2,r3,r2
 822c48c:	00c01344 	movi	r3,77
 822c490:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 822c494:	e0bfff17 	ldw	r2,-4(fp)
 822c498:	10800117 	ldw	r2,4(r2)
 822c49c:	10c00104 	addi	r3,r2,4
 822c4a0:	e0bfff17 	ldw	r2,-4(fp)
 822c4a4:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c4a8:	e0bfff17 	ldw	r2,-4(fp)
 822c4ac:	10800117 	ldw	r2,4(r2)
 822c4b0:	10004c26 	beq	r2,zero,822c5e4 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 822c4b4:	d0e03917 	ldw	r3,-32540(gp)
 822c4b8:	e0bfff17 	ldw	r2,-4(fp)
 822c4bc:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 822c4c0:	e17fff17 	ldw	r5,-4(fp)
 822c4c4:	010209b4 	movhi	r4,2086
 822c4c8:	21375904 	addi	r4,r4,-8860
 822c4cc:	822cbb00 	call	822cbb0 <putq>
 822c4d0:	00002e06 	br	822c58c <pk_init+0x208>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 822c4d4:	d0a03717 	ldw	r2,-32548(gp)
 822c4d8:	10800144 	addi	r2,r2,5
 822c4dc:	1009883a 	mov	r4,r2
 822c4e0:	822de140 	call	822de14 <ncpalloc>
 822c4e4:	1007883a 	mov	r3,r2
 822c4e8:	e0bfff17 	ldw	r2,-4(fp)
 822c4ec:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c4f0:	e0bfff17 	ldw	r2,-4(fp)
 822c4f4:	10800117 	ldw	r2,4(r2)
 822c4f8:	10003c26 	beq	r2,zero,822c5ec <pk_init+0x268>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c4fc:	e03ffc15 	stw	zero,-16(fp)
 822c500:	00000906 	br	822c528 <pk_init+0x1a4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c504:	e0bfff17 	ldw	r2,-4(fp)
 822c508:	10c00117 	ldw	r3,4(r2)
 822c50c:	e0bffc17 	ldw	r2,-16(fp)
 822c510:	1885883a 	add	r2,r3,r2
 822c514:	00c01344 	movi	r3,77
 822c518:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c51c:	e0bffc17 	ldw	r2,-16(fp)
 822c520:	10800044 	addi	r2,r2,1
 822c524:	e0bffc15 	stw	r2,-16(fp)
 822c528:	e0bffc17 	ldw	r2,-16(fp)
 822c52c:	10800110 	cmplti	r2,r2,4
 822c530:	103ff41e 	bne	r2,zero,822c504 <pk_init+0x180>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 822c534:	e0bfff17 	ldw	r2,-4(fp)
 822c538:	10c00117 	ldw	r3,4(r2)
 822c53c:	d0a03717 	ldw	r2,-32548(gp)
 822c540:	10800104 	addi	r2,r2,4
 822c544:	1885883a 	add	r2,r3,r2
 822c548:	00c01344 	movi	r3,77
 822c54c:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;
 822c550:	e0bfff17 	ldw	r2,-4(fp)
 822c554:	10800117 	ldw	r2,4(r2)
 822c558:	10c00104 	addi	r3,r2,4
 822c55c:	e0bfff17 	ldw	r2,-4(fp)
 822c560:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c564:	e0bfff17 	ldw	r2,-4(fp)
 822c568:	10800117 	ldw	r2,4(r2)
 822c56c:	10002126 	beq	r2,zero,822c5f4 <pk_init+0x270>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 822c570:	d0e03717 	ldw	r3,-32548(gp)
 822c574:	e0bfff17 	ldw	r2,-4(fp)
 822c578:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 822c57c:	e17fff17 	ldw	r5,-4(fp)
 822c580:	010209b4 	movhi	r4,2086
 822c584:	21371404 	addi	r4,r4,-9136
 822c588:	822cbb00 	call	822cbb0 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 822c58c:	e0bffa17 	ldw	r2,-24(fp)
 822c590:	10800044 	addi	r2,r2,1
 822c594:	e0bffa15 	stw	r2,-24(fp)
 822c598:	e0fffa17 	ldw	r3,-24(fp)
 822c59c:	e0bffd17 	ldw	r2,-12(fp)
 822c5a0:	18bf8336 	bltu	r3,r2,822c3b0 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 822c5a4:	d0a03817 	ldw	r2,-32544(gp)
 822c5a8:	1007883a 	mov	r3,r2
 822c5ac:	008209b4 	movhi	r2,2086
 822c5b0:	10b75904 	addi	r2,r2,-8860
 822c5b4:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 822c5b8:	d0a03617 	ldw	r2,-32552(gp)
 822c5bc:	1007883a 	mov	r3,r2
 822c5c0:	008209b4 	movhi	r2,2086
 822c5c4:	10b71404 	addi	r2,r2,-9136
 822c5c8:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 822c5cc:	0005883a 	mov	r2,zero
 822c5d0:	00000e06 	br	822c60c <pk_init+0x288>

   for (i = 0; i < numpkts; i++)
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
      if (packet == NULL)
         goto no_pkt_buf;
 822c5d4:	0001883a 	nop
 822c5d8:	00000706 	br	822c5f8 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c5dc:	0001883a 	nop
 822c5e0:	00000506 	br	822c5f8 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c5e4:	0001883a 	nop
 822c5e8:	00000306 	br	822c5f8 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c5ec:	0001883a 	nop
 822c5f0:	00000106 	br	822c5f8 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c5f4:	0001883a 	nop

   return 0;

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 822c5f8:	e17ffa17 	ldw	r5,-24(fp)
 822c5fc:	01020974 	movhi	r4,2085
 822c600:	2100b704 	addi	r4,r4,732
 822c604:	8202e9c0 	call	8202e9c <printf>
#endif
   return(-1);
 822c608:	00bfffc4 	movi	r2,-1
}
 822c60c:	e037883a 	mov	sp,fp
 822c610:	dfc00117 	ldw	ra,4(sp)
 822c614:	df000017 	ldw	fp,0(sp)
 822c618:	dec00204 	addi	sp,sp,8
 822c61c:	f800283a 	ret

0822c620 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 822c620:	defffc04 	addi	sp,sp,-16
 822c624:	dfc00315 	stw	ra,12(sp)
 822c628:	df000215 	stw	fp,8(sp)
 822c62c:	df000204 	addi	fp,sp,8
 822c630:	e13fff15 	stw	r4,-4(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 822c634:	d0e03917 	ldw	r3,-32540(gp)
 822c638:	e0bfff17 	ldw	r2,-4(fp)
 822c63c:	1880022e 	bgeu	r3,r2,822c648 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 822c640:	0005883a 	mov	r2,zero
 822c644:	00002206 	br	822c6d0 <pk_alloc+0xb0>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 822c648:	d0e03717 	ldw	r3,-32548(gp)
 822c64c:	e0bfff17 	ldw	r2,-4(fp)
 822c650:	18800436 	bltu	r3,r2,822c664 <pk_alloc+0x44>
 822c654:	008209b4 	movhi	r2,2086
 822c658:	10b71404 	addi	r2,r2,-9136
 822c65c:	10800217 	ldw	r2,8(r2)
 822c660:	1000051e 	bne	r2,zero,822c678 <pk_alloc+0x58>
         p = (PACKET)getq(&bigfreeq);
 822c664:	010209b4 	movhi	r4,2086
 822c668:	21375904 	addi	r4,r4,-8860
 822c66c:	822caf80 	call	822caf8 <getq>
 822c670:	e0bffe15 	stw	r2,-8(fp)
 822c674:	00000406 	br	822c688 <pk_alloc+0x68>
      else
         p = (PACKET)getq(&lilfreeq);
 822c678:	010209b4 	movhi	r4,2086
 822c67c:	21371404 	addi	r4,r4,-9136
 822c680:	822caf80 	call	822caf8 <getq>
 822c684:	e0bffe15 	stw	r2,-8(fp)

      if (!p)
 822c688:	e0bffe17 	ldw	r2,-8(fp)
 822c68c:	1000021e 	bne	r2,zero,822c698 <pk_alloc+0x78>
         return NULL;
 822c690:	0005883a 	mov	r2,zero
 822c694:	00000e06 	br	822c6d0 <pk_alloc+0xb0>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 822c698:	e0bffe17 	ldw	r2,-8(fp)
 822c69c:	10800117 	ldw	r2,4(r2)
 822c6a0:	d0e08117 	ldw	r3,-32252(gp)
 822c6a4:	10c7883a 	add	r3,r2,r3
 822c6a8:	e0bffe17 	ldw	r2,-8(fp)
 822c6ac:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 822c6b0:	e0bffe17 	ldw	r2,-8(fp)
 822c6b4:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 822c6b8:	e0bffe17 	ldw	r2,-8(fp)
 822c6bc:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 822c6c0:	e0bffe17 	ldw	r2,-8(fp)
 822c6c4:	00c00044 	movi	r3,1
 822c6c8:	10c00915 	stw	r3,36(r2)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 822c6cc:	e0bffe17 	ldw	r2,-8(fp)
}
 822c6d0:	e037883a 	mov	sp,fp
 822c6d4:	dfc00117 	ldw	ra,4(sp)
 822c6d8:	df000017 	ldw	fp,0(sp)
 822c6dc:	dec00204 	addi	sp,sp,8
 822c6e0:	f800283a 	ret

0822c6e4 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 822c6e4:	defffb04 	addi	sp,sp,-20
 822c6e8:	dfc00415 	stw	ra,16(sp)
 822c6ec:	df000315 	stw	fp,12(sp)
 822c6f0:	df000304 	addi	fp,sp,12
 822c6f4:	e13fff15 	stw	r4,-4(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 822c6f8:	e0bfff17 	ldw	r2,-4(fp)
 822c6fc:	10800017 	ldw	r2,0(r2)
 822c700:	10000e26 	beq	r2,zero,822c73c <pk_validate+0x58>
 822c704:	e0bfff17 	ldw	r2,-4(fp)
 822c708:	10800917 	ldw	r2,36(r2)
 822c70c:	10000b26 	beq	r2,zero,822c73c <pk_validate+0x58>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 822c710:	822d3a00 	call	822d3a0 <irq_Mask>
 822c714:	008209b4 	movhi	r2,2086
 822c718:	10b71904 	addi	r2,r2,-9116
 822c71c:	10800317 	ldw	r2,12(r2)
 822c720:	10c00044 	addi	r3,r2,1
 822c724:	008209b4 	movhi	r2,2086
 822c728:	10b71904 	addi	r2,r2,-9116
 822c72c:	10c00315 	stw	r3,12(r2)
 822c730:	822d4000 	call	822d400 <irq_Unmask>
      return -1;
 822c734:	00bfffc4 	movi	r2,-1
 822c738:	00008806 	br	822c95c <pk_validate+0x278>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 822c73c:	e0bfff17 	ldw	r2,-4(fp)
 822c740:	10c00217 	ldw	r3,8(r2)
 822c744:	d0a03917 	ldw	r2,-32540(gp)
 822c748:	1880201e 	bne	r3,r2,822c7cc <pk_validate+0xe8>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 822c74c:	822d3a00 	call	822d3a0 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822c750:	008209b4 	movhi	r2,2086
 822c754:	10b75904 	addi	r2,r2,-8860
 822c758:	10800017 	ldw	r2,0(r2)
 822c75c:	e0bffd15 	stw	r2,-12(fp)
 822c760:	00001606 	br	822c7bc <pk_validate+0xd8>
            if (p == pkt)
 822c764:	e0fffd17 	ldw	r3,-12(fp)
 822c768:	e0bfff17 	ldw	r2,-4(fp)
 822c76c:	1880101e 	bne	r3,r2,822c7b0 <pk_validate+0xcc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 822c770:	e17fff17 	ldw	r5,-4(fp)
 822c774:	01020974 	movhi	r4,2085
 822c778:	2100c204 	addi	r4,r4,776
 822c77c:	8202e9c0 	call	8202e9c <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 822c780:	822d4000 	call	822d400 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822c784:	822d3a00 	call	822d3a0 <irq_Mask>
 822c788:	008209b4 	movhi	r2,2086
 822c78c:	10b71904 	addi	r2,r2,-9116
 822c790:	10800217 	ldw	r2,8(r2)
 822c794:	10c00044 	addi	r3,r2,1
 822c798:	008209b4 	movhi	r2,2086
 822c79c:	10b71904 	addi	r2,r2,-9116
 822c7a0:	10c00215 	stw	r3,8(r2)
 822c7a4:	822d4000 	call	822d400 <irq_Unmask>
               return -1;
 822c7a8:	00bfffc4 	movi	r2,-1
 822c7ac:	00006b06 	br	822c95c <pk_validate+0x278>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822c7b0:	e0bffd17 	ldw	r2,-12(fp)
 822c7b4:	10800017 	ldw	r2,0(r2)
 822c7b8:	e0bffd15 	stw	r2,-12(fp)
 822c7bc:	e0bffd17 	ldw	r2,-12(fp)
 822c7c0:	103fe81e 	bne	r2,zero,822c764 <pk_validate+0x80>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 822c7c4:	822d4000 	call	822d400 <irq_Unmask>
 822c7c8:	00002f06 	br	822c888 <pk_validate+0x1a4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 822c7cc:	e0bfff17 	ldw	r2,-4(fp)
 822c7d0:	10c00217 	ldw	r3,8(r2)
 822c7d4:	d0a03717 	ldw	r2,-32548(gp)
 822c7d8:	1880201e 	bne	r3,r2,822c85c <pk_validate+0x178>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 822c7dc:	822d3a00 	call	822d3a0 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822c7e0:	008209b4 	movhi	r2,2086
 822c7e4:	10b71404 	addi	r2,r2,-9136
 822c7e8:	10800017 	ldw	r2,0(r2)
 822c7ec:	e0bffd15 	stw	r2,-12(fp)
 822c7f0:	00001606 	br	822c84c <pk_validate+0x168>
            if (p == pkt)
 822c7f4:	e0fffd17 	ldw	r3,-12(fp)
 822c7f8:	e0bfff17 	ldw	r2,-4(fp)
 822c7fc:	1880101e 	bne	r3,r2,822c840 <pk_validate+0x15c>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 822c800:	e17fff17 	ldw	r5,-4(fp)
 822c804:	01020974 	movhi	r4,2085
 822c808:	2100cc04 	addi	r4,r4,816
 822c80c:	8202e9c0 	call	8202e9c <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 822c810:	822d4000 	call	822d400 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822c814:	822d3a00 	call	822d3a0 <irq_Mask>
 822c818:	008209b4 	movhi	r2,2086
 822c81c:	10b71904 	addi	r2,r2,-9116
 822c820:	10800217 	ldw	r2,8(r2)
 822c824:	10c00044 	addi	r3,r2,1
 822c828:	008209b4 	movhi	r2,2086
 822c82c:	10b71904 	addi	r2,r2,-9116
 822c830:	10c00215 	stw	r3,8(r2)
 822c834:	822d4000 	call	822d400 <irq_Unmask>
            return -1;
 822c838:	00bfffc4 	movi	r2,-1
 822c83c:	00004706 	br	822c95c <pk_validate+0x278>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822c840:	e0bffd17 	ldw	r2,-12(fp)
 822c844:	10800017 	ldw	r2,0(r2)
 822c848:	e0bffd15 	stw	r2,-12(fp)
 822c84c:	e0bffd17 	ldw	r2,-12(fp)
 822c850:	103fe81e 	bne	r2,zero,822c7f4 <pk_validate+0x110>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 822c854:	822d4000 	call	822d400 <irq_Unmask>
 822c858:	00000b06 	br	822c888 <pk_validate+0x1a4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 822c85c:	822d3a00 	call	822d3a0 <irq_Mask>
 822c860:	008209b4 	movhi	r2,2086
 822c864:	10b71904 	addi	r2,r2,-9116
 822c868:	10800017 	ldw	r2,0(r2)
 822c86c:	10c00044 	addi	r3,r2,1
 822c870:	008209b4 	movhi	r2,2086
 822c874:	10b71904 	addi	r2,r2,-9116
 822c878:	10c00015 	stw	r3,0(r2)
 822c87c:	822d4000 	call	822d400 <irq_Unmask>
         return -1;
 822c880:	00bfffc4 	movi	r2,-1
 822c884:	00003506 	br	822c95c <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822c888:	00800104 	movi	r2,4
 822c88c:	e0bffe15 	stw	r2,-8(fp)
 822c890:	00001906 	br	822c8f8 <pk_validate+0x214>
   {
      if (*(pkt->nb_buff - j) != 'M')
 822c894:	e0bfff17 	ldw	r2,-4(fp)
 822c898:	10c00117 	ldw	r3,4(r2)
 822c89c:	e0bffe17 	ldw	r2,-8(fp)
 822c8a0:	0085c83a 	sub	r2,zero,r2
 822c8a4:	1885883a 	add	r2,r3,r2
 822c8a8:	10800003 	ldbu	r2,0(r2)
 822c8ac:	10803fcc 	andi	r2,r2,255
 822c8b0:	1080201c 	xori	r2,r2,128
 822c8b4:	10bfe004 	addi	r2,r2,-128
 822c8b8:	10801360 	cmpeqi	r2,r2,77
 822c8bc:	10000b1e 	bne	r2,zero,822c8ec <pk_validate+0x208>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822c8c0:	822d3a00 	call	822d3a0 <irq_Mask>
 822c8c4:	008209b4 	movhi	r2,2086
 822c8c8:	10b71904 	addi	r2,r2,-9116
 822c8cc:	10800117 	ldw	r2,4(r2)
 822c8d0:	10c00044 	addi	r3,r2,1
 822c8d4:	008209b4 	movhi	r2,2086
 822c8d8:	10b71904 	addi	r2,r2,-9116
 822c8dc:	10c00115 	stw	r3,4(r2)
 822c8e0:	822d4000 	call	822d400 <irq_Unmask>
         return -1;
 822c8e4:	00bfffc4 	movi	r2,-1
 822c8e8:	00001c06 	br	822c95c <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822c8ec:	e0bffe17 	ldw	r2,-8(fp)
 822c8f0:	10bfffc4 	addi	r2,r2,-1
 822c8f4:	e0bffe15 	stw	r2,-8(fp)
 822c8f8:	e0bffe17 	ldw	r2,-8(fp)
 822c8fc:	00bfe516 	blt	zero,r2,822c894 <pk_validate+0x1b0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 822c900:	e0bfff17 	ldw	r2,-4(fp)
 822c904:	10c00117 	ldw	r3,4(r2)
 822c908:	e0bfff17 	ldw	r2,-4(fp)
 822c90c:	10800217 	ldw	r2,8(r2)
 822c910:	1885883a 	add	r2,r3,r2
 822c914:	10800003 	ldbu	r2,0(r2)
 822c918:	10803fcc 	andi	r2,r2,255
 822c91c:	1080201c 	xori	r2,r2,128
 822c920:	10bfe004 	addi	r2,r2,-128
 822c924:	10801360 	cmpeqi	r2,r2,77
 822c928:	10000b1e 	bne	r2,zero,822c958 <pk_validate+0x274>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822c92c:	822d3a00 	call	822d3a0 <irq_Mask>
 822c930:	008209b4 	movhi	r2,2086
 822c934:	10b71904 	addi	r2,r2,-9116
 822c938:	10800117 	ldw	r2,4(r2)
 822c93c:	10c00044 	addi	r3,r2,1
 822c940:	008209b4 	movhi	r2,2086
 822c944:	10b71904 	addi	r2,r2,-9116
 822c948:	10c00115 	stw	r3,4(r2)
 822c94c:	822d4000 	call	822d400 <irq_Unmask>
      return -1;
 822c950:	00bfffc4 	movi	r2,-1
 822c954:	00000106 	br	822c95c <pk_validate+0x278>
   }
#endif /* NPDEBUG */

   return 0;
 822c958:	0005883a 	mov	r2,zero
}
 822c95c:	e037883a 	mov	sp,fp
 822c960:	dfc00117 	ldw	ra,4(sp)
 822c964:	df000017 	ldw	fp,0(sp)
 822c968:	dec00204 	addi	sp,sp,8
 822c96c:	f800283a 	ret

0822c970 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 822c970:	defffc04 	addi	sp,sp,-16
 822c974:	dfc00315 	stw	ra,12(sp)
 822c978:	df000215 	stw	fp,8(sp)
 822c97c:	df000204 	addi	fp,sp,8
 822c980:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 822c984:	e13fff17 	ldw	r4,-4(fp)
 822c988:	822c6e40 	call	822c6e4 <pk_validate>
 822c98c:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 822c990:	e0bffe17 	ldw	r2,-8(fp)
 822c994:	1000191e 	bne	r2,zero,822c9fc <pk_free+0x8c>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 822c998:	e0bfff17 	ldw	r2,-4(fp)
 822c99c:	10800917 	ldw	r2,36(r2)
 822c9a0:	113fffc4 	addi	r4,r2,-1
 822c9a4:	e0ffff17 	ldw	r3,-4(fp)
 822c9a8:	19000915 	stw	r4,36(r3)
 822c9ac:	108000b0 	cmpltui	r2,r2,2
 822c9b0:	10001426 	beq	r2,zero,822ca04 <pk_free+0x94>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 822c9b4:	e0bfff17 	ldw	r2,-4(fp)
 822c9b8:	10c00217 	ldw	r3,8(r2)
 822c9bc:	d0a03917 	ldw	r2,-32540(gp)
 822c9c0:	1880051e 	bne	r3,r2,822c9d8 <pk_free+0x68>
            q_add(&bigfreeq, (qp)pkt);
 822c9c4:	e17fff17 	ldw	r5,-4(fp)
 822c9c8:	010209b4 	movhi	r4,2086
 822c9cc:	21375904 	addi	r4,r4,-8860
 822c9d0:	822cbb00 	call	822cbb0 <putq>
 822c9d4:	00000c06 	br	822ca08 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 822c9d8:	e0bfff17 	ldw	r2,-4(fp)
 822c9dc:	10c00217 	ldw	r3,8(r2)
 822c9e0:	d0a03717 	ldw	r2,-32548(gp)
 822c9e4:	1880081e 	bne	r3,r2,822ca08 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 822c9e8:	e17fff17 	ldw	r5,-4(fp)
 822c9ec:	010209b4 	movhi	r4,2086
 822c9f0:	21371404 	addi	r4,r4,-9136
 822c9f4:	822cbb00 	call	822cbb0 <putq>
 822c9f8:	00000306 	br	822ca08 <pk_free+0x98>
         {
            pkt = pknext;
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
 822c9fc:	0001883a 	nop
 822ca00:	00000106 	br	822ca08 <pk_free+0x98>
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
         return;  /* packet was cloned, don't delete yet */
 822ca04:	0001883a 	nop
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 822ca08:	e037883a 	mov	sp,fp
 822ca0c:	dfc00117 	ldw	ra,4(sp)
 822ca10:	df000017 	ldw	fp,0(sp)
 822ca14:	dec00204 	addi	sp,sp,8
 822ca18:	f800283a 	ret

0822ca1c <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 822ca1c:	deffff04 	addi	sp,sp,-4
 822ca20:	df000015 	stw	fp,0(sp)
 822ca24:	d839883a 	mov	fp,sp
   return bigbufsiz;
 822ca28:	d0a03917 	ldw	r2,-32540(gp)
}
 822ca2c:	e037883a 	mov	sp,fp
 822ca30:	df000017 	ldw	fp,0(sp)
 822ca34:	dec00104 	addi	sp,sp,4
 822ca38:	f800283a 	ret

0822ca3c <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 822ca3c:	defff904 	addi	sp,sp,-28
 822ca40:	dfc00615 	stw	ra,24(sp)
 822ca44:	df000515 	stw	fp,20(sp)
 822ca48:	df000504 	addi	fp,sp,20
 822ca4c:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 822ca50:	01000084 	movi	r4,2
 822ca54:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 822ca58:	822d3a00 	call	822d3a0 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 822ca5c:	008209b4 	movhi	r2,2086
 822ca60:	10b71904 	addi	r2,r2,-9116
 822ca64:	10c00017 	ldw	r3,0(r2)
 822ca68:	e0fffb15 	stw	r3,-20(fp)
 822ca6c:	10c00117 	ldw	r3,4(r2)
 822ca70:	e0fffc15 	stw	r3,-16(fp)
 822ca74:	10c00217 	ldw	r3,8(r2)
 822ca78:	e0fffd15 	stw	r3,-12(fp)
 822ca7c:	10800317 	ldw	r2,12(r2)
 822ca80:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 822ca84:	822d4000 	call	822d400 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ca88:	01000084 	movi	r4,2
 822ca8c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 822ca90:	01420974 	movhi	r5,2085
 822ca94:	2940d604 	addi	r5,r5,856
 822ca98:	e13fff17 	ldw	r4,-4(fp)
 822ca9c:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 822caa0:	e0bffb17 	ldw	r2,-20(fp)
 822caa4:	e0fffc17 	ldw	r3,-16(fp)
 822caa8:	180f883a 	mov	r7,r3
 822caac:	100d883a 	mov	r6,r2
 822cab0:	01420974 	movhi	r5,2085
 822cab4:	2940df04 	addi	r5,r5,892
 822cab8:	e13fff17 	ldw	r4,-4(fp)
 822cabc:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 822cac0:	e0bffd17 	ldw	r2,-12(fp)
 822cac4:	e0fffe17 	ldw	r3,-8(fp)
 822cac8:	180f883a 	mov	r7,r3
 822cacc:	100d883a 	mov	r6,r2
 822cad0:	01420974 	movhi	r5,2085
 822cad4:	2940ec04 	addi	r5,r5,944
 822cad8:	e13fff17 	ldw	r4,-4(fp)
 822cadc:	8228a940 	call	8228a94 <ns_printf>

   return 0;
 822cae0:	0005883a 	mov	r2,zero
}
 822cae4:	e037883a 	mov	sp,fp
 822cae8:	dfc00117 	ldw	ra,4(sp)
 822caec:	df000017 	ldw	fp,0(sp)
 822caf0:	dec00204 	addi	sp,sp,8
 822caf4:	f800283a 	ret

0822caf8 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 822caf8:	defffc04 	addi	sp,sp,-16
 822cafc:	dfc00315 	stw	ra,12(sp)
 822cb00:	df000215 	stw	fp,8(sp)
 822cb04:	df000204 	addi	fp,sp,8
 822cb08:	e13fff15 	stw	r4,-4(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 822cb0c:	822d3a00 	call	822d3a0 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 822cb10:	e0bfff17 	ldw	r2,-4(fp)
 822cb14:	10800017 	ldw	r2,0(r2)
 822cb18:	e0bffe15 	stw	r2,-8(fp)
 822cb1c:	e0bffe17 	ldw	r2,-8(fp)
 822cb20:	1000031e 	bne	r2,zero,822cb30 <getq+0x38>
   {
      EXIT_CRIT_SECTION(q);
 822cb24:	822d4000 	call	822d400 <irq_Unmask>
      return (0);             /* yes, show none */
 822cb28:	0005883a 	mov	r2,zero
 822cb2c:	00001b06 	br	822cb9c <getq+0xa4>
   }

   q->q_head = temp->qe_next; /* else unlink */
 822cb30:	e0bffe17 	ldw	r2,-8(fp)
 822cb34:	10c00017 	ldw	r3,0(r2)
 822cb38:	e0bfff17 	ldw	r2,-4(fp)
 822cb3c:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 822cb40:	e0bffe17 	ldw	r2,-8(fp)
 822cb44:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 822cb48:	e0bfff17 	ldw	r2,-4(fp)
 822cb4c:	10800017 	ldw	r2,0(r2)
 822cb50:	1000021e 	bne	r2,zero,822cb5c <getq+0x64>
      q->q_tail = 0;          /* yes, update tail pointer too */
 822cb54:	e0bfff17 	ldw	r2,-4(fp)
 822cb58:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 822cb5c:	e0bfff17 	ldw	r2,-4(fp)
 822cb60:	10800217 	ldw	r2,8(r2)
 822cb64:	10ffffc4 	addi	r3,r2,-1
 822cb68:	e0bfff17 	ldw	r2,-4(fp)
 822cb6c:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 822cb70:	e0bfff17 	ldw	r2,-4(fp)
 822cb74:	10c00217 	ldw	r3,8(r2)
 822cb78:	e0bfff17 	ldw	r2,-4(fp)
 822cb7c:	10800417 	ldw	r2,16(r2)
 822cb80:	1880040e 	bge	r3,r2,822cb94 <getq+0x9c>
      q->q_min = q->q_len;
 822cb84:	e0bfff17 	ldw	r2,-4(fp)
 822cb88:	10c00217 	ldw	r3,8(r2)
 822cb8c:	e0bfff17 	ldw	r2,-4(fp)
 822cb90:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 822cb94:	822d4000 	call	822d400 <irq_Unmask>

   return ((void*)temp);
 822cb98:	e0bffe17 	ldw	r2,-8(fp)
}
 822cb9c:	e037883a 	mov	sp,fp
 822cba0:	dfc00117 	ldw	ra,4(sp)
 822cba4:	df000017 	ldw	fp,0(sp)
 822cba8:	dec00204 	addi	sp,sp,8
 822cbac:	f800283a 	ret

0822cbb0 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 822cbb0:	defffc04 	addi	sp,sp,-16
 822cbb4:	dfc00315 	stw	ra,12(sp)
 822cbb8:	df000215 	stw	fp,8(sp)
 822cbbc:	df000204 	addi	fp,sp,8
 822cbc0:	e13ffe15 	stw	r4,-8(fp)
 822cbc4:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 822cbc8:	822d3a00 	call	822d3a0 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 822cbcc:	e0bfff17 	ldw	r2,-4(fp)
 822cbd0:	10000015 	stw	zero,0(r2)
 822cbd4:	e0bffe17 	ldw	r2,-8(fp)
 822cbd8:	10800017 	ldw	r2,0(r2)
 822cbdc:	1000041e 	bne	r2,zero,822cbf0 <putq+0x40>
 822cbe0:	e0bffe17 	ldw	r2,-8(fp)
 822cbe4:	e0ffff17 	ldw	r3,-4(fp)
 822cbe8:	10c00015 	stw	r3,0(r2)
 822cbec:	00000406 	br	822cc00 <putq+0x50>
 822cbf0:	e0bffe17 	ldw	r2,-8(fp)
 822cbf4:	10800117 	ldw	r2,4(r2)
 822cbf8:	e0ffff17 	ldw	r3,-4(fp)
 822cbfc:	10c00015 	stw	r3,0(r2)
 822cc00:	e0bffe17 	ldw	r2,-8(fp)
 822cc04:	e0ffff17 	ldw	r3,-4(fp)
 822cc08:	10c00115 	stw	r3,4(r2)
 822cc0c:	e0bffe17 	ldw	r2,-8(fp)
 822cc10:	10800217 	ldw	r2,8(r2)
 822cc14:	10c00044 	addi	r3,r2,1
 822cc18:	e0bffe17 	ldw	r2,-8(fp)
 822cc1c:	10c00215 	stw	r3,8(r2)
 822cc20:	e0bffe17 	ldw	r2,-8(fp)
 822cc24:	10800217 	ldw	r2,8(r2)
 822cc28:	e0fffe17 	ldw	r3,-8(fp)
 822cc2c:	18c00317 	ldw	r3,12(r3)
 822cc30:	1880040e 	bge	r3,r2,822cc44 <putq+0x94>
 822cc34:	e0bffe17 	ldw	r2,-8(fp)
 822cc38:	10c00217 	ldw	r3,8(r2)
 822cc3c:	e0bffe17 	ldw	r2,-8(fp)
 822cc40:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822cc44:	822d4000 	call	822d400 <irq_Unmask>
}
 822cc48:	0001883a 	nop
 822cc4c:	e037883a 	mov	sp,fp
 822cc50:	dfc00117 	ldw	ra,4(sp)
 822cc54:	df000017 	ldw	fp,0(sp)
 822cc58:	dec00204 	addi	sp,sp,8
 822cc5c:	f800283a 	ret

0822cc60 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 822cc60:	defffa04 	addi	sp,sp,-24
 822cc64:	dfc00515 	stw	ra,20(sp)
 822cc68:	df000415 	stw	fp,16(sp)
 822cc6c:	df000404 	addi	fp,sp,16
 822cc70:	e13ffe15 	stw	r4,-8(fp)
 822cc74:	e17fff15 	stw	r5,-4(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 822cc78:	822d3a00 	call	822d3a0 <irq_Mask>
   qptr = q->q_head;
 822cc7c:	e0bffe17 	ldw	r2,-8(fp)
 822cc80:	10800017 	ldw	r2,0(r2)
 822cc84:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 822cc88:	e03ffd15 	stw	zero,-12(fp)
   while (qptr)
 822cc8c:	00002b06 	br	822cd3c <qdel+0xdc>
   {
      if (qptr == (qp)elt)
 822cc90:	e0fffc17 	ldw	r3,-16(fp)
 822cc94:	e0bfff17 	ldw	r2,-4(fp)
 822cc98:	1880231e 	bne	r3,r2,822cd28 <qdel+0xc8>
      {
         /* found our item; dequeue it */
         if (qlast)
 822cc9c:	e0bffd17 	ldw	r2,-12(fp)
 822cca0:	10000526 	beq	r2,zero,822ccb8 <qdel+0x58>
            qlast->qe_next = qptr->qe_next;
 822cca4:	e0bffc17 	ldw	r2,-16(fp)
 822cca8:	10c00017 	ldw	r3,0(r2)
 822ccac:	e0bffd17 	ldw	r2,-12(fp)
 822ccb0:	10c00015 	stw	r3,0(r2)
 822ccb4:	00000406 	br	822ccc8 <qdel+0x68>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 822ccb8:	e0bffc17 	ldw	r2,-16(fp)
 822ccbc:	10c00017 	ldw	r3,0(r2)
 822ccc0:	e0bffe17 	ldw	r2,-8(fp)
 822ccc4:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 822ccc8:	e0bffe17 	ldw	r2,-8(fp)
 822cccc:	10c00117 	ldw	r3,4(r2)
 822ccd0:	e0bfff17 	ldw	r2,-4(fp)
 822ccd4:	1880031e 	bne	r3,r2,822cce4 <qdel+0x84>
            q->q_tail = qlast;
 822ccd8:	e0bffe17 	ldw	r2,-8(fp)
 822ccdc:	e0fffd17 	ldw	r3,-12(fp)
 822cce0:	10c00115 	stw	r3,4(r2)

         /* fix queue counters */
         q->q_len--;
 822cce4:	e0bffe17 	ldw	r2,-8(fp)
 822cce8:	10800217 	ldw	r2,8(r2)
 822ccec:	10ffffc4 	addi	r3,r2,-1
 822ccf0:	e0bffe17 	ldw	r2,-8(fp)
 822ccf4:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 822ccf8:	e0bffe17 	ldw	r2,-8(fp)
 822ccfc:	10c00217 	ldw	r3,8(r2)
 822cd00:	e0bffe17 	ldw	r2,-8(fp)
 822cd04:	10800417 	ldw	r2,16(r2)
 822cd08:	1880040e 	bge	r3,r2,822cd1c <qdel+0xbc>
            q->q_min = q->q_len;
 822cd0c:	e0bffe17 	ldw	r2,-8(fp)
 822cd10:	10c00217 	ldw	r3,8(r2)
 822cd14:	e0bffe17 	ldw	r2,-8(fp)
 822cd18:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 822cd1c:	822d4000 	call	822d400 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 822cd20:	e0bfff17 	ldw	r2,-4(fp)
 822cd24:	00000906 	br	822cd4c <qdel+0xec>
      }
      qlast = qptr;
 822cd28:	e0bffc17 	ldw	r2,-16(fp)
 822cd2c:	e0bffd15 	stw	r2,-12(fp)
      qptr = qptr->qe_next;
 822cd30:	e0bffc17 	ldw	r2,-16(fp)
 822cd34:	10800017 	ldw	r2,0(r2)
 822cd38:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 822cd3c:	e0bffc17 	ldw	r2,-16(fp)
 822cd40:	103fd31e 	bne	r2,zero,822cc90 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822cd44:	822d4000 	call	822d400 <irq_Unmask>
   return NULL;   /* item not found in queue */
 822cd48:	0005883a 	mov	r2,zero
}
 822cd4c:	e037883a 	mov	sp,fp
 822cd50:	dfc00117 	ldw	ra,4(sp)
 822cd54:	df000017 	ldw	fp,0(sp)
 822cd58:	dec00204 	addi	sp,sp,8
 822cd5c:	f800283a 	ret

0822cd60 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 822cd60:	defff404 	addi	sp,sp,-48
 822cd64:	dfc00b15 	stw	ra,44(sp)
 822cd68:	df000a15 	stw	fp,40(sp)
 822cd6c:	df000a04 	addi	fp,sp,40
 822cd70:	e13ffc15 	stw	r4,-16(fp)
 822cd74:	2807883a 	mov	r3,r5
 822cd78:	3005883a 	mov	r2,r6
 822cd7c:	e1ffff15 	stw	r7,-4(fp)
 822cd80:	e0fffd0d 	sth	r3,-12(fp)
 822cd84:	e0bffe0d 	sth	r2,-8(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 822cd88:	d0a08317 	ldw	r2,-32244(gp)
 822cd8c:	1080010c 	andi	r2,r2,4
 822cd90:	10001526 	beq	r2,zero,822cde8 <udp_open+0x88>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cd94:	e0bffc17 	ldw	r2,-16(fp)
 822cd98:	12003fcc 	andi	r8,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cd9c:	e0bffc17 	ldw	r2,-16(fp)
 822cda0:	1004d23a 	srli	r2,r2,8
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cda4:	11803fcc 	andi	r6,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cda8:	e0bffc17 	ldw	r2,-16(fp)
 822cdac:	1004d43a 	srli	r2,r2,16
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cdb0:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cdb4:	e0bffc17 	ldw	r2,-16(fp)
 822cdb8:	1004d63a 	srli	r2,r2,24
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cdbc:	e0fffe0b 	ldhu	r3,-8(fp)
 822cdc0:	e13ffd0b 	ldhu	r4,-12(fp)
 822cdc4:	e1400217 	ldw	r5,8(fp)
 822cdc8:	d9400315 	stw	r5,12(sp)
 822cdcc:	d9000215 	stw	r4,8(sp)
 822cdd0:	d8c00115 	stw	r3,4(sp)
 822cdd4:	d8800015 	stw	r2,0(sp)
 822cdd8:	400b883a 	mov	r5,r8
 822cddc:	01020974 	movhi	r4,2085
 822cde0:	2100f804 	addi	r4,r4,992
 822cde4:	8202e9c0 	call	8202e9c <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 822cde8:	0009883a 	mov	r4,zero
 822cdec:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   ocon = NULL;
 822cdf0:	e03ffb15 	stw	zero,-20(fp)
   for (con = firstudp; con; con = con->u_next)
 822cdf4:	d0a09c17 	ldw	r2,-32144(gp)
 822cdf8:	e0bffa15 	stw	r2,-24(fp)
 822cdfc:	00002006 	br	822ce80 <udp_open+0x120>
   {
      ocon = con;       /* remember last con in list */
 822ce00:	e0bffa17 	ldw	r2,-24(fp)
 822ce04:	e0bffb15 	stw	r2,-20(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822ce08:	e0bffa17 	ldw	r2,-24(fp)
 822ce0c:	1080018b 	ldhu	r2,6(r2)
 822ce10:	10ffffcc 	andi	r3,r2,65535
 822ce14:	e0bffe0b 	ldhu	r2,-8(fp)
 822ce18:	1880161e 	bne	r3,r2,822ce74 <udp_open+0x114>
 822ce1c:	e0bffa17 	ldw	r2,-24(fp)
 822ce20:	1080020b 	ldhu	r2,8(r2)
 822ce24:	10ffffcc 	andi	r3,r2,65535
 822ce28:	e0bffd0b 	ldhu	r2,-12(fp)
 822ce2c:	1880111e 	bne	r3,r2,822ce74 <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822ce30:	e0bffa17 	ldw	r2,-24(fp)
 822ce34:	10800317 	ldw	r2,12(r2)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822ce38:	10000e1e 	bne	r2,zero,822ce74 <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822ce3c:	e0bffa17 	ldw	r2,-24(fp)
 822ce40:	10c00417 	ldw	r3,16(r2)
 822ce44:	e0bffc17 	ldw	r2,-16(fp)
 822ce48:	18800a1e 	bne	r3,r2,822ce74 <udp_open+0x114>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 822ce4c:	d0a08317 	ldw	r2,-32244(gp)
 822ce50:	1080050c 	andi	r2,r2,20
 822ce54:	10000326 	beq	r2,zero,822ce64 <udp_open+0x104>
            dprintf("UDP: Connection already exists.\n");
 822ce58:	01020974 	movhi	r4,2085
 822ce5c:	21010704 	addi	r4,r4,1052
 822ce60:	82031200 	call	8203120 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 822ce64:	0009883a 	mov	r4,zero
 822ce68:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return(NULL);
 822ce6c:	0005883a 	mov	r2,zero
 822ce70:	00003506 	br	822cf48 <udp_open+0x1e8>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 822ce74:	e0bffa17 	ldw	r2,-24(fp)
 822ce78:	10800017 	ldw	r2,0(r2)
 822ce7c:	e0bffa15 	stw	r2,-24(fp)
 822ce80:	e0bffa17 	ldw	r2,-24(fp)
 822ce84:	103fde1e 	bne	r2,zero,822ce00 <udp_open+0xa0>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 822ce88:	01000804 	movi	r4,32
 822ce8c:	822dda00 	call	822dda0 <npalloc>
 822ce90:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 822ce94:	e0bffa17 	ldw	r2,-24(fp)
 822ce98:	10000a1e 	bne	r2,zero,822cec4 <udp_open+0x164>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 822ce9c:	d0a08317 	ldw	r2,-32244(gp)
 822cea0:	1080010c 	andi	r2,r2,4
 822cea4:	10000326 	beq	r2,zero,822ceb4 <udp_open+0x154>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 822cea8:	01020974 	movhi	r4,2085
 822ceac:	21010f04 	addi	r4,r4,1084
 822ceb0:	82031200 	call	8203120 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 822ceb4:	0009883a 	mov	r4,zero
 822ceb8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return(NULL);
 822cebc:	0005883a 	mov	r2,zero
 822cec0:	00002106 	br	822cf48 <udp_open+0x1e8>
   }

   if (ocon)   /* ocon is end of list */
 822cec4:	e0bffb17 	ldw	r2,-20(fp)
 822cec8:	10000426 	beq	r2,zero,822cedc <udp_open+0x17c>
      ocon->u_next = con;  /* add new connection to end */
 822cecc:	e0bffb17 	ldw	r2,-20(fp)
 822ced0:	e0fffa17 	ldw	r3,-24(fp)
 822ced4:	10c00015 	stw	r3,0(r2)
 822ced8:	00000206 	br	822cee4 <udp_open+0x184>
   else  /* no list, start one */
      firstudp = con;
 822cedc:	e0bffa17 	ldw	r2,-24(fp)
 822cee0:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 822cee4:	e0bffa17 	ldw	r2,-24(fp)
 822cee8:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 822ceec:	e0bffa17 	ldw	r2,-24(fp)
 822cef0:	e0fffe0b 	ldhu	r3,-8(fp)
 822cef4:	10c0018d 	sth	r3,6(r2)
   con->u_fport = fsock;
 822cef8:	e0bffa17 	ldw	r2,-24(fp)
 822cefc:	e0fffd0b 	ldhu	r3,-12(fp)
 822cf00:	10c0020d 	sth	r3,8(r2)
   con->u_lhost = 0;
 822cf04:	e0bffa17 	ldw	r2,-24(fp)
 822cf08:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 822cf0c:	e0bffa17 	ldw	r2,-24(fp)
 822cf10:	e0fffc17 	ldw	r3,-16(fp)
 822cf14:	10c00415 	stw	r3,16(r2)
   con->u_rcv   = handler;
 822cf18:	e0bffa17 	ldw	r2,-24(fp)
 822cf1c:	e0ffff17 	ldw	r3,-4(fp)
 822cf20:	10c00515 	stw	r3,20(r2)
   con->u_data  = data;
 822cf24:	e0bffa17 	ldw	r2,-24(fp)
 822cf28:	e0c00217 	ldw	r3,8(fp)
 822cf2c:	10c00615 	stw	r3,24(r2)
   con->u_flags = UDPCF_V4;
 822cf30:	e0bffa17 	ldw	r2,-24(fp)
 822cf34:	00c00044 	movi	r3,1
 822cf38:	10c0010d 	sth	r3,4(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 822cf3c:	0009883a 	mov	r4,zero
 822cf40:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return(con);
 822cf44:	e0bffa17 	ldw	r2,-24(fp)
}
 822cf48:	e037883a 	mov	sp,fp
 822cf4c:	dfc00117 	ldw	ra,4(sp)
 822cf50:	df000017 	ldw	fp,0(sp)
 822cf54:	dec00204 	addi	sp,sp,8
 822cf58:	f800283a 	ret

0822cf5c <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 822cf5c:	defffb04 	addi	sp,sp,-20
 822cf60:	dfc00415 	stw	ra,16(sp)
 822cf64:	df000315 	stw	fp,12(sp)
 822cf68:	df000304 	addi	fp,sp,12
 822cf6c:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 822cf70:	e0bfff17 	ldw	r2,-4(fp)
 822cf74:	10000226 	beq	r2,zero,822cf80 <udp_close+0x24>
 822cf78:	d0a09c17 	ldw	r2,-32144(gp)
 822cf7c:	1000021e 	bne	r2,zero,822cf88 <udp_close+0x2c>
   {
      dtrap(); /* bad programming! */
 822cf80:	822d1c80 	call	822d1c8 <dtrap>
      return;
 822cf84:	00002606 	br	822d020 <udp_close+0xc4>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 822cf88:	0009883a 	mov	r4,zero
 822cf8c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 822cf90:	e03ffe15 	stw	zero,-8(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822cf94:	d0a09c17 	ldw	r2,-32144(gp)
 822cf98:	e0bffd15 	stw	r2,-12(fp)
 822cf9c:	00000806 	br	822cfc0 <udp_close+0x64>
   {
      if (pcon == con)  /* found connection to delete */
 822cfa0:	e0fffd17 	ldw	r3,-12(fp)
 822cfa4:	e0bfff17 	ldw	r2,-4(fp)
 822cfa8:	18800826 	beq	r3,r2,822cfcc <udp_close+0x70>
      break;
      lcon = pcon;   /* remember last connection */
 822cfac:	e0bffd17 	ldw	r2,-12(fp)
 822cfb0:	e0bffe15 	stw	r2,-8(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822cfb4:	e0bffd17 	ldw	r2,-12(fp)
 822cfb8:	10800017 	ldw	r2,0(r2)
 822cfbc:	e0bffd15 	stw	r2,-12(fp)
 822cfc0:	e0bffd17 	ldw	r2,-12(fp)
 822cfc4:	103ff61e 	bne	r2,zero,822cfa0 <udp_close+0x44>
 822cfc8:	00000106 	br	822cfd0 <udp_close+0x74>
   {
      if (pcon == con)  /* found connection to delete */
      break;
 822cfcc:	0001883a 	nop
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 822cfd0:	e0bffd17 	ldw	r2,-12(fp)
 822cfd4:	1000041e 	bne	r2,zero,822cfe8 <udp_close+0x8c>
   {
      dtrap(); /* prog error - connenction not in list */
 822cfd8:	822d1c80 	call	822d1c8 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 822cfdc:	0009883a 	mov	r4,zero
 822cfe0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return;
 822cfe4:	00000e06 	br	822d020 <udp_close+0xc4>
   }

   if (lcon)   /* in con is not head of list */
 822cfe8:	e0bffe17 	ldw	r2,-8(fp)
 822cfec:	10000526 	beq	r2,zero,822d004 <udp_close+0xa8>
      lcon->u_next = con->u_next;   /* unlink */
 822cff0:	e0bfff17 	ldw	r2,-4(fp)
 822cff4:	10c00017 	ldw	r3,0(r2)
 822cff8:	e0bffe17 	ldw	r2,-8(fp)
 822cffc:	10c00015 	stw	r3,0(r2)
 822d000:	00000306 	br	822d010 <udp_close+0xb4>
   else
      firstudp = con->u_next; /* remove from head */
 822d004:	e0bfff17 	ldw	r2,-4(fp)
 822d008:	10800017 	ldw	r2,0(r2)
 822d00c:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 822d010:	e13fff17 	ldw	r4,-4(fp)
 822d014:	822ddd40 	call	822ddd4 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 822d018:	0009883a 	mov	r4,zero
 822d01c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
}
 822d020:	e037883a 	mov	sp,fp
 822d024:	dfc00117 	ldw	ra,4(sp)
 822d028:	df000017 	ldw	fp,0(sp)
 822d02c:	dec00204 	addi	sp,sp,8
 822d030:	f800283a 	ret

0822d034 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 822d034:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 822d038:	0140620e 	bge	zero,r5,822d1c4 <done>

      mov   r6, zero		       /* carry accumulator */
 822d03c:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 822d040:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 822d044:	18000326 	beq	r3,zero,822d054 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 822d048:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 822d04c:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 822d050:	297fffc4 	addi	r5,r5,-1

0822d054 <asm1>:
 822d054:	02c208f4 	movhi	r11,2083
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 822d058:	5af46004 	addi	r11,r11,-11904
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 822d05c:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 822d060:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 822d064:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 822d068:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 822d06c:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 822d070:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 822d074:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 822d078:	5800683a 	jmp	r11

0822d07c <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 822d07c:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 822d080:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 822d084:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d088:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d08c:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 822d090:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 822d094:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d098:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d09c:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 822d0a0:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 822d0a4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d0a8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d0ac:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 822d0b0:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 822d0b4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d0b8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d0bc:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 822d0c0:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 822d0c4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d0c8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d0cc:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 822d0d0:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 822d0d4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d0d8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d0dc:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 822d0e0:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 822d0e4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d0e8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d0ec:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 822d0f0:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 822d0f4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d0f8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d0fc:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 822d100:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 822d104:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d108:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d10c:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 822d110:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 822d114:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d118:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d11c:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 822d120:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 822d124:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d128:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d12c:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 822d130:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 822d134:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d138:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d13c:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 822d140:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 822d144:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d148:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d14c:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 822d150:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 822d154:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d158:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d15c:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 822d160:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 822d164:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d168:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d16c:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 822d170:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 822d174:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d178:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d17c:	418d883a 	add	r6,r8,r6

0822d180 <loop0>:
loop0:
      subi  r5, r5, 16
 822d180:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 822d184:	283fbd0e 	bge	r5,zero,822d07c <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 822d188:	48000426 	beq	r9,zero,822d19c <fold>
      ldhu  r7, 0(r4)
 822d18c:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 822d190:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d194:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d198:	418d883a 	add	r6,r8,r6

0822d19c <fold>:
      
fold:
      srli  r7, r2, 16
 822d19c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d1a0:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 822d1a4:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 822d1a8:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 822d1ac:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d1b0:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 822d1b4:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 822d1b8:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d1bc:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 822d1c0:	3885883a 	add	r2,r7,r2

0822d1c4 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 822d1c4:	f800283a 	ret

0822d1c8 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 822d1c8:	defffe04 	addi	sp,sp,-8
 822d1cc:	dfc00115 	stw	ra,4(sp)
 822d1d0:	df000015 	stw	fp,0(sp)
 822d1d4:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 822d1d8:	01020974 	movhi	r4,2085
 822d1dc:	21011904 	addi	r4,r4,1124
 822d1e0:	82031200 	call	8203120 <puts>
}
 822d1e4:	0001883a 	nop
 822d1e8:	e037883a 	mov	sp,fp
 822d1ec:	dfc00117 	ldw	ra,4(sp)
 822d1f0:	df000017 	ldw	fp,0(sp)
 822d1f4:	dec00204 	addi	sp,sp,8
 822d1f8:	f800283a 	ret

0822d1fc <kbhit>:

int
kbhit()
{
 822d1fc:	defffd04 	addi	sp,sp,-12
 822d200:	dfc00215 	stw	ra,8(sp)
 822d204:	df000115 	stw	fp,4(sp)
 822d208:	df000104 	addi	fp,sp,4
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 822d20c:	d0a0a017 	ldw	r2,-32128(gp)
 822d210:	10000b1e 	bne	r2,zero,822d240 <kbhit+0x44>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 822d214:	01900004 	movi	r6,16384
 822d218:	01400104 	movi	r5,4
 822d21c:	0009883a 	mov	r4,zero
 822d220:	823d5140 	call	823d514 <fcntl>
 822d224:	10000426 	beq	r2,zero,822d238 <kbhit+0x3c>
      {
         printf("F_SETFL failed.\n");
 822d228:	01020974 	movhi	r4,2085
 822d22c:	21012004 	addi	r4,r4,1152
 822d230:	82031200 	call	8203120 <puts>
         dtrap();
 822d234:	822d1c80 	call	822d1c8 <dtrap>
      }
      kbd_init = 1; 
 822d238:	00800044 	movi	r2,1
 822d23c:	d0a0a015 	stw	r2,-32128(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 822d240:	d0a03a17 	ldw	r2,-32536(gp)
 822d244:	10bfffd8 	cmpnei	r2,r2,-1
 822d248:	10000b1e 	bne	r2,zero,822d278 <kbhit+0x7c>
   {
      kb = getchar();
 822d24c:	d0a00217 	ldw	r2,-32760(gp)
 822d250:	10800117 	ldw	r2,4(r2)
 822d254:	1009883a 	mov	r4,r2
 822d258:	82029840 	call	8202984 <getc>
 822d25c:	e0bfff15 	stw	r2,-4(fp)
      if (kb < 0)       /* any error means no character present */
 822d260:	e0bfff17 	ldw	r2,-4(fp)
 822d264:	1000020e 	bge	r2,zero,822d270 <kbhit+0x74>
         return (FALSE);
 822d268:	0005883a 	mov	r2,zero
 822d26c:	00000306 	br	822d27c <kbhit+0x80>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 822d270:	e0bfff17 	ldw	r2,-4(fp)
 822d274:	d0a03a15 	stw	r2,-32536(gp)
   }

   return (TRUE);
 822d278:	00800044 	movi	r2,1
}
 822d27c:	e037883a 	mov	sp,fp
 822d280:	dfc00117 	ldw	ra,4(sp)
 822d284:	df000017 	ldw	fp,0(sp)
 822d288:	dec00204 	addi	sp,sp,8
 822d28c:	f800283a 	ret

0822d290 <getch>:

int 
getch()
{
 822d290:	defffd04 	addi	sp,sp,-12
 822d294:	dfc00215 	stw	ra,8(sp)
 822d298:	df000115 	stw	fp,4(sp)
 822d29c:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 822d2a0:	d0a03a17 	ldw	r2,-32536(gp)
 822d2a4:	10bfffe0 	cmpeqi	r2,r2,-1
 822d2a8:	1000051e 	bne	r2,zero,822d2c0 <getch+0x30>
   {
      chr = kb_last;
 822d2ac:	d0a03a17 	ldw	r2,-32536(gp)
 822d2b0:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 822d2b4:	00bfffc4 	movi	r2,-1
 822d2b8:	d0a03a15 	stw	r2,-32536(gp)
 822d2bc:	00000506 	br	822d2d4 <getch+0x44>
   }
   else
      chr = getchar();
 822d2c0:	d0a00217 	ldw	r2,-32760(gp)
 822d2c4:	10800117 	ldw	r2,4(r2)
 822d2c8:	1009883a 	mov	r4,r2
 822d2cc:	82029840 	call	8202984 <getc>
 822d2d0:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 822d2d4:	e0bfff17 	ldw	r2,-4(fp)
}
 822d2d8:	e037883a 	mov	sp,fp
 822d2dc:	dfc00117 	ldw	ra,4(sp)
 822d2e0:	df000017 	ldw	fp,0(sp)
 822d2e4:	dec00204 	addi	sp,sp,8
 822d2e8:	f800283a 	ret

0822d2ec <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 822d2ec:	deffff04 	addi	sp,sp,-4
 822d2f0:	df000015 	stw	fp,0(sp)
 822d2f4:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 822d2f8:	00801904 	movi	r2,100
 822d2fc:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 822d300:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 822d304:	d020a815 	stw	zero,-32096(gp)
   cticks_initialized = 1;
 822d308:	00800044 	movi	r2,1
 822d30c:	d0a09d15 	stw	r2,-32140(gp)
}
 822d310:	0001883a 	nop
 822d314:	e037883a 	mov	sp,fp
 822d318:	df000017 	ldw	fp,0(sp)
 822d31c:	dec00104 	addi	sp,sp,4
 822d320:	f800283a 	ret

0822d324 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 822d324:	deffff04 	addi	sp,sp,-4
 822d328:	df000015 	stw	fp,0(sp)
 822d32c:	d839883a 	mov	fp,sp
   /* null */ ;
}
 822d330:	0001883a 	nop
 822d334:	e037883a 	mov	sp,fp
 822d338:	df000017 	ldw	fp,0(sp)
 822d33c:	dec00104 	addi	sp,sp,4
 822d340:	f800283a 	ret

0822d344 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 822d344:	deffff04 	addi	sp,sp,-4
 822d348:	df000015 	stw	fp,0(sp)
 822d34c:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 822d350:	d0a09d17 	ldw	r2,-32140(gp)
 822d354:	10000d26 	beq	r2,zero,822d38c <cticks_hook+0x48>
   {
      cticks_factor += TPS;
 822d358:	d0a0a117 	ldw	r2,-32124(gp)
 822d35c:	10801904 	addi	r2,r2,100
 822d360:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 822d364:	d0e0a117 	ldw	r3,-32124(gp)
 822d368:	d0a0a217 	ldw	r2,-32120(gp)
 822d36c:	18800716 	blt	r3,r2,822d38c <cticks_hook+0x48>
      {
         cticks++;
 822d370:	d0a0a817 	ldw	r2,-32096(gp)
 822d374:	10800044 	addi	r2,r2,1
 822d378:	d0a0a815 	stw	r2,-32096(gp)
         cticks_factor -= OS_TPS;
 822d37c:	d0e0a117 	ldw	r3,-32124(gp)
 822d380:	d0a0a217 	ldw	r2,-32120(gp)
 822d384:	1885c83a 	sub	r2,r3,r2
 822d388:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 822d38c:	0001883a 	nop
 822d390:	e037883a 	mov	sp,fp
 822d394:	df000017 	ldw	fp,0(sp)
 822d398:	dec00104 	addi	sp,sp,4
 822d39c:	f800283a 	ret

0822d3a0 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 822d3a0:	defffd04 	addi	sp,sp,-12
 822d3a4:	df000215 	stw	fp,8(sp)
 822d3a8:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 822d3ac:	0005303a 	rdctl	r2,status
 822d3b0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 822d3b4:	e0ffff17 	ldw	r3,-4(fp)
 822d3b8:	00bfff84 	movi	r2,-2
 822d3bc:	1884703a 	and	r2,r3,r2
 822d3c0:	1001703a 	wrctl	status,r2
  
  return context;
 822d3c4:	e0bfff17 	ldw	r2,-4(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 822d3c8:	e0bffe15 	stw	r2,-8(fp)
	
   if (++irq_level == 1)
 822d3cc:	d0a09e17 	ldw	r2,-32136(gp)
 822d3d0:	10800044 	addi	r2,r2,1
 822d3d4:	d0a09e15 	stw	r2,-32136(gp)
 822d3d8:	d0a09e17 	ldw	r2,-32136(gp)
 822d3dc:	10800058 	cmpnei	r2,r2,1
 822d3e0:	1000021e 	bne	r2,zero,822d3ec <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 822d3e4:	e0bffe17 	ldw	r2,-8(fp)
 822d3e8:	d0a09f15 	stw	r2,-32132(gp)
   }
}
 822d3ec:	0001883a 	nop
 822d3f0:	e037883a 	mov	sp,fp
 822d3f4:	df000017 	ldw	fp,0(sp)
 822d3f8:	dec00104 	addi	sp,sp,4
 822d3fc:	f800283a 	ret

0822d400 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 822d400:	defffe04 	addi	sp,sp,-8
 822d404:	df000115 	stw	fp,4(sp)
 822d408:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 822d40c:	d0a09e17 	ldw	r2,-32136(gp)
 822d410:	10bfffc4 	addi	r2,r2,-1
 822d414:	d0a09e15 	stw	r2,-32136(gp)
 822d418:	d0a09e17 	ldw	r2,-32136(gp)
 822d41c:	1000041e 	bne	r2,zero,822d430 <irq_Unmask+0x30>
   {
      alt_irq_enable_all(cpu_statusreg);
 822d420:	d0a09f17 	ldw	r2,-32132(gp)
 822d424:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 822d428:	e0bfff17 	ldw	r2,-4(fp)
 822d42c:	1001703a 	wrctl	status,r2
   }
}
 822d430:	0001883a 	nop
 822d434:	e037883a 	mov	sp,fp
 822d438:	df000017 	ldw	fp,0(sp)
 822d43c:	dec00104 	addi	sp,sp,4
 822d440:	f800283a 	ret

0822d444 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 822d444:	defffb04 	addi	sp,sp,-20
 822d448:	dfc00415 	stw	ra,16(sp)
 822d44c:	df000315 	stw	fp,12(sp)
 822d450:	df000304 	addi	fp,sp,12
 822d454:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d458:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d45c:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d460:	e0bfff17 	ldw	r2,-4(fp)
 822d464:	10002216 	blt	r2,zero,822d4f0 <LOCK_NET_RESOURCE+0xac>
 822d468:	e0bfff17 	ldw	r2,-4(fp)
 822d46c:	10800408 	cmpgei	r2,r2,16
 822d470:	10001f1e 	bne	r2,zero,822d4f0 <LOCK_NET_RESOURCE+0xac>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 822d474:	008209b4 	movhi	r2,2086
 822d478:	10b7d904 	addi	r2,r2,-8348
 822d47c:	e0ffff17 	ldw	r3,-4(fp)
 822d480:	18c7883a 	add	r3,r3,r3
 822d484:	18c7883a 	add	r3,r3,r3
 822d488:	10c5883a 	add	r2,r2,r3
 822d48c:	10800017 	ldw	r2,0(r2)
 822d490:	e0fffe04 	addi	r3,fp,-8
 822d494:	180d883a 	mov	r6,r3
 822d498:	000b883a 	mov	r5,zero
 822d49c:	1009883a 	mov	r4,r2
 822d4a0:	8219d080 	call	8219d08 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d4a4:	e0bffe03 	ldbu	r2,-8(fp)
 822d4a8:	10803fcc 	andi	r2,r2,255
 822d4ac:	10800298 	cmpnei	r2,r2,10
 822d4b0:	10000a1e 	bne	r2,zero,822d4dc <LOCK_NET_RESOURCE+0x98>
 822d4b4:	e0bffd17 	ldw	r2,-12(fp)
 822d4b8:	10800044 	addi	r2,r2,1
 822d4bc:	e0bffd15 	stw	r2,-12(fp)
 822d4c0:	e0bffd17 	ldw	r2,-12(fp)
 822d4c4:	1080fa50 	cmplti	r2,r2,1001
 822d4c8:	1000041e 	bne	r2,zero,822d4dc <LOCK_NET_RESOURCE+0x98>
         {
            panic("lock NET");   /* fatal */
 822d4cc:	01020974 	movhi	r4,2085
 822d4d0:	21012404 	addi	r4,r4,1168
 822d4d4:	822887c0 	call	822887c <panic>
 822d4d8:	00000606 	br	822d4f4 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
 822d4dc:	e0bffe03 	ldbu	r2,-8(fp)
 822d4e0:	10803fcc 	andi	r2,r2,255
 822d4e4:	108002a0 	cmpeqi	r2,r2,10
 822d4e8:	103fe21e 	bne	r2,zero,822d474 <LOCK_NET_RESOURCE+0x30>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d4ec:	00000106 	br	822d4f4 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 822d4f0:	822d1c80 	call	822d1c8 <dtrap>
}
 822d4f4:	e037883a 	mov	sp,fp
 822d4f8:	dfc00117 	ldw	ra,4(sp)
 822d4fc:	df000017 	ldw	fp,0(sp)
 822d500:	dec00204 	addi	sp,sp,8
 822d504:	f800283a 	ret

0822d508 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 822d508:	defffc04 	addi	sp,sp,-16
 822d50c:	dfc00315 	stw	ra,12(sp)
 822d510:	df000215 	stw	fp,8(sp)
 822d514:	df000204 	addi	fp,sp,8
 822d518:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d51c:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d520:	e0bfff17 	ldw	r2,-4(fp)
 822d524:	10001316 	blt	r2,zero,822d574 <UNLOCK_NET_RESOURCE+0x6c>
 822d528:	e0bfff17 	ldw	r2,-4(fp)
 822d52c:	10800408 	cmpgei	r2,r2,16
 822d530:	1000101e 	bne	r2,zero,822d574 <UNLOCK_NET_RESOURCE+0x6c>
   {
      error = OSSemPost(resid_semaphore[resid]);
 822d534:	008209b4 	movhi	r2,2086
 822d538:	10b7d904 	addi	r2,r2,-8348
 822d53c:	e0ffff17 	ldw	r3,-4(fp)
 822d540:	18c7883a 	add	r3,r3,r3
 822d544:	18c7883a 	add	r3,r3,r3
 822d548:	10c5883a 	add	r2,r2,r3
 822d54c:	10800017 	ldw	r2,0(r2)
 822d550:	1009883a 	mov	r4,r2
 822d554:	821a0800 	call	821a080 <OSSemPost>
 822d558:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d55c:	e0bffe03 	ldbu	r2,-8(fp)
 822d560:	10000526 	beq	r2,zero,822d578 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
 822d564:	01020974 	movhi	r4,2085
 822d568:	21012704 	addi	r4,r4,1180
 822d56c:	822887c0 	call	822887c <panic>
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
   {
      error = OSSemPost(resid_semaphore[resid]);
      if (error != OS_NO_ERR)
 822d570:	00000106 	br	822d578 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822d574:	822d1c80 	call	822d1c8 <dtrap>
}
 822d578:	0001883a 	nop
 822d57c:	e037883a 	mov	sp,fp
 822d580:	dfc00117 	ldw	ra,4(sp)
 822d584:	df000017 	ldw	fp,0(sp)
 822d588:	dec00204 	addi	sp,sp,8
 822d58c:	f800283a 	ret

0822d590 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 822d590:	deffee04 	addi	sp,sp,-72
 822d594:	dfc01115 	stw	ra,68(sp)
 822d598:	df001015 	stw	fp,64(sp)
 822d59c:	df001004 	addi	fp,sp,64
 822d5a0:	e13fff15 	stw	r4,-4(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 822d5a4:	e0bfff17 	ldw	r2,-4(fp)
 822d5a8:	10800417 	ldw	r2,16(r2)
 822d5ac:	1009883a 	mov	r4,r2
 822d5b0:	822dda00 	call	822dda0 <npalloc>
 822d5b4:	e0bff515 	stw	r2,-44(fp)
   if(!stack)
 822d5b8:	e0bff517 	ldw	r2,-44(fp)
 822d5bc:	1000031e 	bne	r2,zero,822d5cc <TK_NEWTASK+0x3c>
      panic("stack alloc");
 822d5c0:	01020974 	movhi	r4,2085
 822d5c4:	21012a04 	addi	r4,r4,1192
 822d5c8:	822887c0 	call	822887c <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d5cc:	e0bfff17 	ldw	r2,-4(fp)
 822d5d0:	12000217 	ldw	r8,8(r2)
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
 822d5d4:	e0bfff17 	ldw	r2,-4(fp)
 822d5d8:	10800417 	ldw	r2,16(r2)
 822d5dc:	1006d0ba 	srli	r3,r2,2
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d5e0:	00900034 	movhi	r2,16384
 822d5e4:	10bfffc4 	addi	r2,r2,-1
 822d5e8:	1885883a 	add	r2,r3,r2
 822d5ec:	1085883a 	add	r2,r2,r2
 822d5f0:	1085883a 	add	r2,r2,r2
 822d5f4:	1007883a 	mov	r3,r2
 822d5f8:	e0bff517 	ldw	r2,-44(fp)
 822d5fc:	10cb883a 	add	r5,r2,r3
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
 822d600:	e0bfff17 	ldw	r2,-4(fp)
 822d604:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d608:	11803fcc 	andi	r6,r2,255
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
 822d60c:	e0bfff17 	ldw	r2,-4(fp)
 822d610:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d614:	10bfffcc 	andi	r2,r2,65535
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
      stack, 
      (INT32U)nettask->stacksize / sizeof(OS_STK),
 822d618:	e0ffff17 	ldw	r3,-4(fp)
 822d61c:	18c00417 	ldw	r3,16(r3)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d620:	1806d0ba 	srli	r3,r3,2
 822d624:	010000c4 	movi	r4,3
 822d628:	d9000415 	stw	r4,16(sp)
 822d62c:	d8000315 	stw	zero,12(sp)
 822d630:	d8c00215 	stw	r3,8(sp)
 822d634:	e0fff517 	ldw	r3,-44(fp)
 822d638:	d8c00115 	stw	r3,4(sp)
 822d63c:	d8800015 	stw	r2,0(sp)
 822d640:	300f883a 	mov	r7,r6
 822d644:	280d883a 	mov	r6,r5
 822d648:	000b883a 	mov	r5,zero
 822d64c:	4009883a 	mov	r4,r8
 822d650:	821aa3c0 	call	821aa3c <OSTaskCreateExt>
 822d654:	e0bff605 	stb	r2,-40(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 822d658:	e0bff603 	ldbu	r2,-40(fp)
 822d65c:	10803fcc 	andi	r2,r2,255
 822d660:	10800a18 	cmpnei	r2,r2,40
 822d664:	10001c1e 	bne	r2,zero,822d6d8 <TK_NEWTASK+0x148>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, (INT8U*)curr_task, &err);
 822d668:	e0bfff17 	ldw	r2,-4(fp)
 822d66c:	10800317 	ldw	r2,12(r2)
 822d670:	10803fcc 	andi	r2,r2,255
 822d674:	e13ff644 	addi	r4,fp,-39
 822d678:	e0fff684 	addi	r3,fp,-38
 822d67c:	200d883a 	mov	r6,r4
 822d680:	180b883a 	mov	r5,r3
 822d684:	1009883a 	mov	r4,r2
 822d688:	821b0b40 	call	821b0b4 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 822d68c:	e03ffe45 	stb	zero,-7(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 822d690:	e0bfff17 	ldw	r2,-4(fp)
 822d694:	10c00117 	ldw	r3,4(r2)
 822d698:	e0bfff17 	ldw	r2,-4(fp)
 822d69c:	11000317 	ldw	r4,12(r2)
 822d6a0:	e0bfff17 	ldw	r2,-4(fp)
 822d6a4:	10800317 	ldw	r2,12(r2)
 822d6a8:	e17ff684 	addi	r5,fp,-38
 822d6ac:	d8800015 	stw	r2,0(sp)
 822d6b0:	280f883a 	mov	r7,r5
 822d6b4:	200d883a 	mov	r6,r4
 822d6b8:	180b883a 	mov	r5,r3
 822d6bc:	01020974 	movhi	r4,2085
 822d6c0:	21012d04 	addi	r4,r4,1204
 822d6c4:	8202e9c0 	call	8202e9c <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 822d6c8:	01020974 	movhi	r4,2085
 822d6cc:	21014504 	addi	r4,r4,1300
 822d6d0:	82031200 	call	8203120 <puts>
 822d6d4:	00002006 	br	822d758 <TK_NEWTASK+0x1c8>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 822d6d8:	e0bff603 	ldbu	r2,-40(fp)
 822d6dc:	10803fcc 	andi	r2,r2,255
 822d6e0:	10800a98 	cmpnei	r2,r2,42
 822d6e4:	10000e1e 	bne	r2,zero,822d720 <TK_NEWTASK+0x190>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 822d6e8:	e0bfff17 	ldw	r2,-4(fp)
 822d6ec:	10c00117 	ldw	r3,4(r2)
 822d6f0:	e0bfff17 	ldw	r2,-4(fp)
 822d6f4:	10800317 	ldw	r2,12(r2)
 822d6f8:	01c00504 	movi	r7,20
 822d6fc:	100d883a 	mov	r6,r2
 822d700:	180b883a 	mov	r5,r3
 822d704:	01020974 	movhi	r4,2085
 822d708:	21016d04 	addi	r4,r4,1460
 822d70c:	8202e9c0 	call	8202e9c <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 822d710:	01020974 	movhi	r4,2085
 822d714:	21018a04 	addi	r4,r4,1576
 822d718:	82031200 	call	8203120 <puts>
 822d71c:	00000e06 	br	822d758 <TK_NEWTASK+0x1c8>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 822d720:	e0bff603 	ldbu	r2,-40(fp)
 822d724:	10803fcc 	andi	r2,r2,255
 822d728:	10000b26 	beq	r2,zero,822d758 <TK_NEWTASK+0x1c8>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 822d72c:	e0bff603 	ldbu	r2,-40(fp)
 822d730:	10c03fcc 	andi	r3,r2,255
 822d734:	e0bfff17 	ldw	r2,-4(fp)
 822d738:	10800117 	ldw	r2,4(r2)
 822d73c:	100d883a 	mov	r6,r2
 822d740:	180b883a 	mov	r5,r3
 822d744:	01020974 	movhi	r4,2085
 822d748:	2101a904 	addi	r4,r4,1700
 822d74c:	8202e9c0 	call	8202e9c <printf>
             error, nettask->name);
      return (-1);
 822d750:	00bfffc4 	movi	r2,-1
 822d754:	00001c06 	br	822d7c8 <TK_NEWTASK+0x238>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, (INT8U*)&nettask->name[0], &error);
 822d758:	e0bfff17 	ldw	r2,-4(fp)
 822d75c:	10800317 	ldw	r2,12(r2)
 822d760:	10c03fcc 	andi	r3,r2,255
 822d764:	e0bfff17 	ldw	r2,-4(fp)
 822d768:	10800117 	ldw	r2,4(r2)
 822d76c:	e13ff604 	addi	r4,fp,-40
 822d770:	200d883a 	mov	r6,r4
 822d774:	100b883a 	mov	r5,r2
 822d778:	1809883a 	mov	r4,r3
 822d77c:	821b24c0 	call	821b24c <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 822d780:	e0bfff17 	ldw	r2,-4(fp)
 822d784:	e0fff517 	ldw	r3,-44(fp)
 822d788:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 822d78c:	e0bfff17 	ldw	r2,-4(fp)
 822d790:	10800017 	ldw	r2,0(r2)
 822d794:	e0ffff17 	ldw	r3,-4(fp)
 822d798:	18c00317 	ldw	r3,12(r3)
 822d79c:	10c00005 	stb	r3,0(r2)

   printf("Created \"%s\" task (Prio: %d)\n",
 822d7a0:	e0bfff17 	ldw	r2,-4(fp)
 822d7a4:	10c00117 	ldw	r3,4(r2)
 822d7a8:	e0bfff17 	ldw	r2,-4(fp)
 822d7ac:	10800317 	ldw	r2,12(r2)
 822d7b0:	100d883a 	mov	r6,r2
 822d7b4:	180b883a 	mov	r5,r3
 822d7b8:	01020974 	movhi	r4,2085
 822d7bc:	2101b704 	addi	r4,r4,1756
 822d7c0:	8202e9c0 	call	8202e9c <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 822d7c4:	0005883a 	mov	r2,zero
}
 822d7c8:	e037883a 	mov	sp,fp
 822d7cc:	dfc00117 	ldw	ra,4(sp)
 822d7d0:	df000017 	ldw	fp,0(sp)
 822d7d4:	dec00204 	addi	sp,sp,8
 822d7d8:	f800283a 	ret

0822d7dc <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 822d7dc:	defffb04 	addi	sp,sp,-20
 822d7e0:	dfc00415 	stw	ra,16(sp)
 822d7e4:	df000315 	stw	fp,12(sp)
 822d7e8:	df000304 	addi	fp,sp,12
 822d7ec:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d7f0:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d7f4:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822d7f8:	e0bfff17 	ldw	r2,-4(fp)
 822d7fc:	108001a8 	cmpgeui	r2,r2,6
 822d800:	10001f1e 	bne	r2,zero,822d880 <wait_app_sem+0xa4>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 822d804:	008209b4 	movhi	r2,2086
 822d808:	10b7e904 	addi	r2,r2,-8284
 822d80c:	e0ffff17 	ldw	r3,-4(fp)
 822d810:	18c7883a 	add	r3,r3,r3
 822d814:	18c7883a 	add	r3,r3,r3
 822d818:	10c5883a 	add	r2,r2,r3
 822d81c:	10800017 	ldw	r2,0(r2)
 822d820:	e0fffe04 	addi	r3,fp,-8
 822d824:	180d883a 	mov	r6,r3
 822d828:	000b883a 	mov	r5,zero
 822d82c:	1009883a 	mov	r4,r2
 822d830:	8219d080 	call	8219d08 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d834:	e0bffe03 	ldbu	r2,-8(fp)
 822d838:	10803fcc 	andi	r2,r2,255
 822d83c:	10800298 	cmpnei	r2,r2,10
 822d840:	10000a1e 	bne	r2,zero,822d86c <wait_app_sem+0x90>
 822d844:	e0bffd17 	ldw	r2,-12(fp)
 822d848:	10800044 	addi	r2,r2,1
 822d84c:	e0bffd15 	stw	r2,-12(fp)
 822d850:	e0bffd17 	ldw	r2,-12(fp)
 822d854:	1080fa50 	cmplti	r2,r2,1001
 822d858:	1000041e 	bne	r2,zero,822d86c <wait_app_sem+0x90>
         {
            panic("lock NET");   /* fatal */
 822d85c:	01020974 	movhi	r4,2085
 822d860:	21012404 	addi	r4,r4,1168
 822d864:	822887c0 	call	822887c <panic>
 822d868:	00000606 	br	822d884 <wait_app_sem+0xa8>
            return;
         }
      } while (error == 10);
 822d86c:	e0bffe03 	ldbu	r2,-8(fp)
 822d870:	10803fcc 	andi	r2,r2,255
 822d874:	108002a0 	cmpeqi	r2,r2,10
 822d878:	103fe21e 	bne	r2,zero,822d804 <wait_app_sem+0x28>
 822d87c:	00000106 	br	822d884 <wait_app_sem+0xa8>
   }
   else
      dtrap();
 822d880:	822d1c80 	call	822d1c8 <dtrap>
}
 822d884:	e037883a 	mov	sp,fp
 822d888:	dfc00117 	ldw	ra,4(sp)
 822d88c:	df000017 	ldw	fp,0(sp)
 822d890:	dec00204 	addi	sp,sp,8
 822d894:	f800283a 	ret

0822d898 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 822d898:	defffc04 	addi	sp,sp,-16
 822d89c:	dfc00315 	stw	ra,12(sp)
 822d8a0:	df000215 	stw	fp,8(sp)
 822d8a4:	df000204 	addi	fp,sp,8
 822d8a8:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822d8ac:	e0bfff17 	ldw	r2,-4(fp)
 822d8b0:	108001a8 	cmpgeui	r2,r2,6
 822d8b4:	1000101e 	bne	r2,zero,822d8f8 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 822d8b8:	008209b4 	movhi	r2,2086
 822d8bc:	10b7e904 	addi	r2,r2,-8284
 822d8c0:	e0ffff17 	ldw	r3,-4(fp)
 822d8c4:	18c7883a 	add	r3,r3,r3
 822d8c8:	18c7883a 	add	r3,r3,r3
 822d8cc:	10c5883a 	add	r2,r2,r3
 822d8d0:	10800017 	ldw	r2,0(r2)
 822d8d4:	1009883a 	mov	r4,r2
 822d8d8:	821a0800 	call	821a080 <OSSemPost>
 822d8dc:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d8e0:	e0bffe03 	ldbu	r2,-8(fp)
 822d8e4:	10000526 	beq	r2,zero,822d8fc <post_app_sem+0x64>
      {
         panic("unlock NET");
 822d8e8:	01020974 	movhi	r4,2085
 822d8ec:	21012704 	addi	r4,r4,1180
 822d8f0:	822887c0 	call	822887c <panic>
      }
   }
   else
      dtrap();
}
 822d8f4:	00000106 	br	822d8fc <post_app_sem+0x64>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822d8f8:	822d1c80 	call	822d1c8 <dtrap>
}
 822d8fc:	0001883a 	nop
 822d900:	e037883a 	mov	sp,fp
 822d904:	dfc00117 	ldw	ra,4(sp)
 822d908:	df000017 	ldw	fp,0(sp)
 822d90c:	dec00204 	addi	sp,sp,8
 822d910:	f800283a 	ret

0822d914 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 822d914:	defffd04 	addi	sp,sp,-12
 822d918:	dfc00215 	stw	ra,8(sp)
 822d91c:	df000115 	stw	fp,4(sp)
 822d920:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 822d924:	01000044 	movi	r4,1
 822d928:	82199f00 	call	82199f0 <OSSemCreate>
 822d92c:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 822d930:	d0a0aa17 	ldw	r2,-32088(gp)
 822d934:	1000031e 	bne	r2,zero,822d944 <alt_iniche_init+0x30>
      panic("mheap_sem_ptr create err"); 
 822d938:	01020974 	movhi	r4,2085
 822d93c:	2101bf04 	addi	r4,r4,1788
 822d940:	822887c0 	call	822887c <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 822d944:	0009883a 	mov	r4,zero
 822d948:	82199f00 	call	82199f0 <OSSemCreate>
 822d94c:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 822d950:	d0a0ab17 	ldw	r2,-32084(gp)
 822d954:	1000031e 	bne	r2,zero,822d964 <alt_iniche_init+0x50>
      panic("rcvdq_sem_ptr create err"); 
 822d958:	01020974 	movhi	r4,2085
 822d95c:	2101c604 	addi	r4,r4,1816
 822d960:	822887c0 	call	822887c <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822d964:	e03fff15 	stw	zero,-4(fp)
 822d968:	00001806 	br	822d9cc <alt_iniche_init+0xb8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 822d96c:	01000044 	movi	r4,1
 822d970:	82199f00 	call	82199f0 <OSSemCreate>
 822d974:	1009883a 	mov	r4,r2
 822d978:	008209b4 	movhi	r2,2086
 822d97c:	10b7d904 	addi	r2,r2,-8348
 822d980:	e0ffff17 	ldw	r3,-4(fp)
 822d984:	18c7883a 	add	r3,r3,r3
 822d988:	18c7883a 	add	r3,r3,r3
 822d98c:	10c5883a 	add	r2,r2,r3
 822d990:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 822d994:	008209b4 	movhi	r2,2086
 822d998:	10b7d904 	addi	r2,r2,-8348
 822d99c:	e0ffff17 	ldw	r3,-4(fp)
 822d9a0:	18c7883a 	add	r3,r3,r3
 822d9a4:	18c7883a 	add	r3,r3,r3
 822d9a8:	10c5883a 	add	r2,r2,r3
 822d9ac:	10800017 	ldw	r2,0(r2)
 822d9b0:	1000031e 	bne	r2,zero,822d9c0 <alt_iniche_init+0xac>
         panic("resid_semaphore create err");  
 822d9b4:	01020974 	movhi	r4,2085
 822d9b8:	2101cd04 	addi	r4,r4,1844
 822d9bc:	822887c0 	call	822887c <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822d9c0:	e0bfff17 	ldw	r2,-4(fp)
 822d9c4:	10800044 	addi	r2,r2,1
 822d9c8:	e0bfff15 	stw	r2,-4(fp)
 822d9cc:	e0bfff17 	ldw	r2,-4(fp)
 822d9d0:	10800410 	cmplti	r2,r2,16
 822d9d4:	103fe51e 	bne	r2,zero,822d96c <alt_iniche_init+0x58>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822d9d8:	e03fff15 	stw	zero,-4(fp)
 822d9dc:	00001806 	br	822da40 <alt_iniche_init+0x12c>
   {
      app_semaphore[i] = OSSemCreate(1);
 822d9e0:	01000044 	movi	r4,1
 822d9e4:	82199f00 	call	82199f0 <OSSemCreate>
 822d9e8:	1009883a 	mov	r4,r2
 822d9ec:	008209b4 	movhi	r2,2086
 822d9f0:	10b7e904 	addi	r2,r2,-8284
 822d9f4:	e0ffff17 	ldw	r3,-4(fp)
 822d9f8:	18c7883a 	add	r3,r3,r3
 822d9fc:	18c7883a 	add	r3,r3,r3
 822da00:	10c5883a 	add	r2,r2,r3
 822da04:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 822da08:	008209b4 	movhi	r2,2086
 822da0c:	10b7e904 	addi	r2,r2,-8284
 822da10:	e0ffff17 	ldw	r3,-4(fp)
 822da14:	18c7883a 	add	r3,r3,r3
 822da18:	18c7883a 	add	r3,r3,r3
 822da1c:	10c5883a 	add	r2,r2,r3
 822da20:	10800017 	ldw	r2,0(r2)
 822da24:	1000031e 	bne	r2,zero,822da34 <alt_iniche_init+0x120>
         panic("app_semaphore create err");  
 822da28:	01020974 	movhi	r4,2085
 822da2c:	2101d404 	addi	r4,r4,1872
 822da30:	822887c0 	call	822887c <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822da34:	e0bfff17 	ldw	r2,-4(fp)
 822da38:	10800044 	addi	r2,r2,1
 822da3c:	e0bfff15 	stw	r2,-4(fp)
 822da40:	e0bfff17 	ldw	r2,-4(fp)
 822da44:	10800190 	cmplti	r2,r2,6
 822da48:	103fe51e 	bne	r2,zero,822d9e0 <alt_iniche_init+0xcc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822da4c:	e03fff15 	stw	zero,-4(fp)
 822da50:	00002506 	br	822dae8 <alt_iniche_init+0x1d4>
   {
      global_TCPwakeup_set[i].ctick = 0;
 822da54:	008209b4 	movhi	r2,2086
 822da58:	10b79d04 	addi	r2,r2,-8588
 822da5c:	e0ffff17 	ldw	r3,-4(fp)
 822da60:	18c00324 	muli	r3,r3,12
 822da64:	10c5883a 	add	r2,r2,r3
 822da68:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 822da6c:	008209b4 	movhi	r2,2086
 822da70:	10b79d04 	addi	r2,r2,-8588
 822da74:	e0ffff17 	ldw	r3,-4(fp)
 822da78:	18c00324 	muli	r3,r3,12
 822da7c:	10c5883a 	add	r2,r2,r3
 822da80:	10800104 	addi	r2,r2,4
 822da84:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 822da88:	0009883a 	mov	r4,zero
 822da8c:	82199f00 	call	82199f0 <OSSemCreate>
 822da90:	1009883a 	mov	r4,r2
 822da94:	008209b4 	movhi	r2,2086
 822da98:	10b79d04 	addi	r2,r2,-8588
 822da9c:	e0ffff17 	ldw	r3,-4(fp)
 822daa0:	18c00324 	muli	r3,r3,12
 822daa4:	10c5883a 	add	r2,r2,r3
 822daa8:	10800204 	addi	r2,r2,8
 822daac:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 822dab0:	008209b4 	movhi	r2,2086
 822dab4:	10b79d04 	addi	r2,r2,-8588
 822dab8:	e0ffff17 	ldw	r3,-4(fp)
 822dabc:	18c00324 	muli	r3,r3,12
 822dac0:	10c5883a 	add	r2,r2,r3
 822dac4:	10800204 	addi	r2,r2,8
 822dac8:	10800017 	ldw	r2,0(r2)
 822dacc:	1000031e 	bne	r2,zero,822dadc <alt_iniche_init+0x1c8>
         panic("globwake_semaphore create err");  
 822dad0:	01020974 	movhi	r4,2085
 822dad4:	2101db04 	addi	r4,r4,1900
 822dad8:	822887c0 	call	822887c <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822dadc:	e0bfff17 	ldw	r2,-4(fp)
 822dae0:	10800044 	addi	r2,r2,1
 822dae4:	e0bfff15 	stw	r2,-4(fp)
 822dae8:	e0bfff17 	ldw	r2,-4(fp)
 822daec:	10800510 	cmplti	r2,r2,20
 822daf0:	103fd81e 	bne	r2,zero,822da54 <alt_iniche_init+0x140>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 822daf4:	d020a715 	stw	zero,-32100(gp)
#endif  /* TCPWAKE_RTOS */
}
 822daf8:	0001883a 	nop
 822dafc:	e037883a 	mov	sp,fp
 822db00:	dfc00117 	ldw	ra,4(sp)
 822db04:	df000017 	ldw	fp,0(sp)
 822db08:	dec00204 	addi	sp,sp,8
 822db0c:	f800283a 	ret

0822db10 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 822db10:	deffff04 	addi	sp,sp,-4
 822db14:	df000015 	stw	fp,0(sp)
 822db18:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 822db1c:	00800784 	movi	r2,30
 822db20:	d0a03815 	stw	r2,-32544(gp)
   lilbufs = MAXLILPKTS;
 822db24:	00800784 	movi	r2,30
 822db28:	d0a03615 	stw	r2,-32552(gp)
   bigbufsiz = BIGBUFSIZE;
 822db2c:	00818004 	movi	r2,1536
 822db30:	d0a03915 	stw	r2,-32540(gp)
   lilbufsiz = LILBUFSIZE;
 822db34:	00802004 	movi	r2,128
 822db38:	d0a03715 	stw	r2,-32548(gp)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 822db3c:	008208f4 	movhi	r2,2083
 822db40:	10b6df04 	addi	r2,r2,-9348
 822db44:	d0a0ca15 	stw	r2,-31960(gp)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 822db48:	0005883a 	mov	r2,zero
}
 822db4c:	e037883a 	mov	sp,fp
 822db50:	df000017 	ldw	fp,0(sp)
 822db54:	dec00104 	addi	sp,sp,4
 822db58:	f800283a 	ret

0822db5c <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 822db5c:	deffff04 	addi	sp,sp,-4
 822db60:	df000015 	stw	fp,0(sp)
 822db64:	d839883a 	mov	fp,sp
   return NULL;
 822db68:	0005883a 	mov	r2,zero
}
 822db6c:	e037883a 	mov	sp,fp
 822db70:	df000017 	ldw	fp,0(sp)
 822db74:	dec00104 	addi	sp,sp,4
 822db78:	f800283a 	ret

0822db7c <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 822db7c:	defffd04 	addi	sp,sp,-12
 822db80:	dfc00215 	stw	ra,8(sp)
 822db84:	df000115 	stw	fp,4(sp)
 822db88:	df000104 	addi	fp,sp,4
 822db8c:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 822db90:	e13fff17 	ldw	r4,-4(fp)
 822db94:	82254b40 	call	82254b4 <iniche_devices_init>
 822db98:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 822db9c:	e0bfff17 	ldw	r2,-4(fp)
}
 822dba0:	e037883a 	mov	sp,fp
 822dba4:	dfc00117 	ldw	ra,4(sp)
 822dba8:	df000017 	ldw	fp,0(sp)
 822dbac:	dec00204 	addi	sp,sp,8
 822dbb0:	f800283a 	ret

0822dbb4 <npalloc_base>:
#endif


char *
npalloc_base(unsigned size, int cacheable)
{
 822dbb4:	defff804 	addi	sp,sp,-32
 822dbb8:	dfc00715 	stw	ra,28(sp)
 822dbbc:	df000615 	stw	fp,24(sp)
 822dbc0:	df000604 	addi	fp,sp,24
 822dbc4:	e13ffe15 	stw	r4,-8(fp)
 822dbc8:	e17fff15 	stw	r5,-4(fp)
char * ptr;
void *(*alloc_rtn)(size_t size) = cacheable ? malloc : alt_uncached_malloc;
 822dbcc:	e0bfff17 	ldw	r2,-4(fp)
 822dbd0:	10000326 	beq	r2,zero,822dbe0 <npalloc_base+0x2c>
 822dbd4:	00820974 	movhi	r2,2085
 822dbd8:	10ac6304 	addi	r2,r2,-20084
 822dbdc:	00000206 	br	822dbe8 <npalloc_base+0x34>
 822dbe0:	00820934 	movhi	r2,2084
 822dbe4:	10b1d604 	addi	r2,r2,-14504
 822dbe8:	e0bffb15 	stw	r2,-20(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 822dbec:	d0a0aa17 	ldw	r2,-32088(gp)
 822dbf0:	e0fffd04 	addi	r3,fp,-12
 822dbf4:	180d883a 	mov	r6,r3
 822dbf8:	000b883a 	mov	r5,zero
 822dbfc:	1009883a 	mov	r4,r2
 822dc00:	8219d080 	call	8219d08 <OSSemPend>
   if(err)
 822dc04:	e0bffd03 	ldbu	r2,-12(fp)
 822dc08:	10803fcc 	andi	r2,r2,255
 822dc0c:	10001626 	beq	r2,zero,822dc68 <npalloc_base+0xb4>
   {
      int errct = 0;
 822dc10:	e03ffa15 	stw	zero,-24(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822dc14:	00001006 	br	822dc58 <npalloc_base+0xa4>
      {
         if(errct++ > 1000)
 822dc18:	e0bffa17 	ldw	r2,-24(fp)
 822dc1c:	10c00044 	addi	r3,r2,1
 822dc20:	e0fffa15 	stw	r3,-24(fp)
 822dc24:	1080fa50 	cmplti	r2,r2,1001
 822dc28:	1000051e 	bne	r2,zero,822dc40 <npalloc_base+0x8c>
         {
            panic("npalloc");    /* fatal? */
 822dc2c:	01020974 	movhi	r4,2085
 822dc30:	2101e304 	addi	r4,r4,1932
 822dc34:	822887c0 	call	822887c <panic>
            return NULL;
 822dc38:	0005883a 	mov	r2,zero
 822dc3c:	00001b06 	br	822dcac <npalloc_base+0xf8>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822dc40:	d0a0aa17 	ldw	r2,-32088(gp)
 822dc44:	e0fffd04 	addi	r3,fp,-12
 822dc48:	180d883a 	mov	r6,r3
 822dc4c:	000b883a 	mov	r5,zero
 822dc50:	1009883a 	mov	r4,r2
 822dc54:	8219d080 	call	8219d08 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822dc58:	e0bffd03 	ldbu	r2,-12(fp)
 822dc5c:	10803fcc 	andi	r2,r2,255
 822dc60:	108002a0 	cmpeqi	r2,r2,10
 822dc64:	103fec1e 	bne	r2,zero,822dc18 <npalloc_base+0x64>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, alloc_rtn);
#else
   ptr = (*alloc_rtn)(size);
 822dc68:	e0bffb17 	ldw	r2,-20(fp)
 822dc6c:	e13ffe17 	ldw	r4,-8(fp)
 822dc70:	103ee83a 	callr	r2
 822dc74:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 822dc78:	d0a0aa17 	ldw	r2,-32088(gp)
 822dc7c:	1009883a 	mov	r4,r2
 822dc80:	821a0800 	call	821a080 <OSSemPost>
 822dc84:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 822dc88:	e0bffc17 	ldw	r2,-16(fp)
 822dc8c:	1000021e 	bne	r2,zero,822dc98 <npalloc_base+0xe4>
      return NULL;
 822dc90:	0005883a 	mov	r2,zero
 822dc94:	00000506 	br	822dcac <npalloc_base+0xf8>

   MEMSET(ptr, 0, size);
 822dc98:	e1bffe17 	ldw	r6,-8(fp)
 822dc9c:	000b883a 	mov	r5,zero
 822dca0:	e13ffc17 	ldw	r4,-16(fp)
 822dca4:	8202cb00 	call	8202cb0 <memset>
   return ptr;      
 822dca8:	e0bffc17 	ldw	r2,-16(fp)
}
 822dcac:	e037883a 	mov	sp,fp
 822dcb0:	dfc00117 	ldw	ra,4(sp)
 822dcb4:	df000017 	ldw	fp,0(sp)
 822dcb8:	dec00204 	addi	sp,sp,8
 822dcbc:	f800283a 	ret

0822dcc0 <npfree_base>:

void
npfree_base(void *ptr, int cacheable)
{
 822dcc0:	defff904 	addi	sp,sp,-28
 822dcc4:	dfc00615 	stw	ra,24(sp)
 822dcc8:	df000515 	stw	fp,20(sp)
 822dccc:	df000504 	addi	fp,sp,20
 822dcd0:	e13ffe15 	stw	r4,-8(fp)
 822dcd4:	e17fff15 	stw	r5,-4(fp)
   void (*free_rtn)(void *ptr) = cacheable ? free : alt_uncached_free;
 822dcd8:	e0bfff17 	ldw	r2,-4(fp)
 822dcdc:	10000326 	beq	r2,zero,822dcec <npfree_base+0x2c>
 822dce0:	00820974 	movhi	r2,2085
 822dce4:	10ac6804 	addi	r2,r2,-20064
 822dce8:	00000206 	br	822dcf4 <npfree_base+0x34>
 822dcec:	00820934 	movhi	r2,2084
 822dcf0:	10b1c504 	addi	r2,r2,-14572
 822dcf4:	e0bffc15 	stw	r2,-16(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 822dcf8:	d0a0aa17 	ldw	r2,-32088(gp)
 822dcfc:	e0fffd04 	addi	r3,fp,-12
 822dd00:	180d883a 	mov	r6,r3
 822dd04:	000b883a 	mov	r5,zero
 822dd08:	1009883a 	mov	r4,r2
 822dd0c:	8219d080 	call	8219d08 <OSSemPend>
   if (err)
 822dd10:	e0bffd03 	ldbu	r2,-12(fp)
 822dd14:	10803fcc 	andi	r2,r2,255
 822dd18:	10001526 	beq	r2,zero,822dd70 <npfree_base+0xb0>
   {
      int errct = 0;
 822dd1c:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822dd20:	00000f06 	br	822dd60 <npfree_base+0xa0>
      {
         if (errct++ > 1000)
 822dd24:	e0bffb17 	ldw	r2,-20(fp)
 822dd28:	10c00044 	addi	r3,r2,1
 822dd2c:	e0fffb15 	stw	r3,-20(fp)
 822dd30:	1080fa50 	cmplti	r2,r2,1001
 822dd34:	1000041e 	bne	r2,zero,822dd48 <npfree_base+0x88>
         {
            panic("npfree");    /* fatal? */
 822dd38:	01020974 	movhi	r4,2085
 822dd3c:	2101e504 	addi	r4,r4,1940
 822dd40:	822887c0 	call	822887c <panic>
            return;
 822dd44:	00001106 	br	822dd8c <npfree_base+0xcc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822dd48:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd4c:	e0fffd04 	addi	r3,fp,-12
 822dd50:	180d883a 	mov	r6,r3
 822dd54:	000b883a 	mov	r5,zero
 822dd58:	1009883a 	mov	r4,r2
 822dd5c:	8219d080 	call	8219d08 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822dd60:	e0bffd03 	ldbu	r2,-12(fp)
 822dd64:	10803fcc 	andi	r2,r2,255
 822dd68:	108002a0 	cmpeqi	r2,r2,10
 822dd6c:	103fed1e 	bne	r2,zero,822dd24 <npfree_base+0x64>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free_rtn);
#else
   (*free_rtn)(ptr);
 822dd70:	e0bffc17 	ldw	r2,-16(fp)
 822dd74:	e13ffe17 	ldw	r4,-8(fp)
 822dd78:	103ee83a 	callr	r2
#endif

   err = OSSemPost(mheap_sem_ptr);
 822dd7c:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd80:	1009883a 	mov	r4,r2
 822dd84:	821a0800 	call	821a080 <OSSemPost>
 822dd88:	e0bffd05 	stb	r2,-12(fp)
#else
   (*free_rtn)(ptr);
#endif
#endif

}
 822dd8c:	e037883a 	mov	sp,fp
 822dd90:	dfc00117 	ldw	ra,4(sp)
 822dd94:	df000017 	ldw	fp,0(sp)
 822dd98:	dec00204 	addi	sp,sp,8
 822dd9c:	f800283a 	ret

0822dda0 <npalloc>:

char *
npalloc(unsigned size)
{
 822dda0:	defffd04 	addi	sp,sp,-12
 822dda4:	dfc00215 	stw	ra,8(sp)
 822dda8:	df000115 	stw	fp,4(sp)
 822ddac:	df000104 	addi	fp,sp,4
 822ddb0:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 1);
 822ddb4:	01400044 	movi	r5,1
 822ddb8:	e13fff17 	ldw	r4,-4(fp)
 822ddbc:	822dbb40 	call	822dbb4 <npalloc_base>
}
 822ddc0:	e037883a 	mov	sp,fp
 822ddc4:	dfc00117 	ldw	ra,4(sp)
 822ddc8:	df000017 	ldw	fp,0(sp)
 822ddcc:	dec00204 	addi	sp,sp,8
 822ddd0:	f800283a 	ret

0822ddd4 <npfree>:

void
npfree(void *ptr)
{
 822ddd4:	defffd04 	addi	sp,sp,-12
 822ddd8:	dfc00215 	stw	ra,8(sp)
 822dddc:	df000115 	stw	fp,4(sp)
 822dde0:	df000104 	addi	fp,sp,4
 822dde4:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822dde8:	e0bfff17 	ldw	r2,-4(fp)
 822ddec:	10000326 	beq	r2,zero,822ddfc <npfree+0x28>
      npfree_base(ptr, 1);
 822ddf0:	01400044 	movi	r5,1
 822ddf4:	e13fff17 	ldw	r4,-4(fp)
 822ddf8:	822dcc00 	call	822dcc0 <npfree_base>
   }
}
 822ddfc:	0001883a 	nop
 822de00:	e037883a 	mov	sp,fp
 822de04:	dfc00117 	ldw	ra,4(sp)
 822de08:	df000017 	ldw	fp,0(sp)
 822de0c:	dec00204 	addi	sp,sp,8
 822de10:	f800283a 	ret

0822de14 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 822de14:	defffd04 	addi	sp,sp,-12
 822de18:	dfc00215 	stw	ra,8(sp)
 822de1c:	df000115 	stw	fp,4(sp)
 822de20:	df000104 	addi	fp,sp,4
 822de24:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 0);
 822de28:	000b883a 	mov	r5,zero
 822de2c:	e13fff17 	ldw	r4,-4(fp)
 822de30:	822dbb40 	call	822dbb4 <npalloc_base>
}
 822de34:	e037883a 	mov	sp,fp
 822de38:	dfc00117 	ldw	ra,4(sp)
 822de3c:	df000017 	ldw	fp,0(sp)
 822de40:	dec00204 	addi	sp,sp,8
 822de44:	f800283a 	ret

0822de48 <ncpfree>:

void ncpfree(void *ptr)
{
 822de48:	defffd04 	addi	sp,sp,-12
 822de4c:	dfc00215 	stw	ra,8(sp)
 822de50:	df000115 	stw	fp,4(sp)
 822de54:	df000104 	addi	fp,sp,4
 822de58:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822de5c:	e0bfff17 	ldw	r2,-4(fp)
 822de60:	10000326 	beq	r2,zero,822de70 <ncpfree+0x28>
      npfree_base(ptr, 0);
 822de64:	000b883a 	mov	r5,zero
 822de68:	e13fff17 	ldw	r4,-4(fp)
 822de6c:	822dcc00 	call	822dcc0 <npfree_base>
   }
}
 822de70:	0001883a 	nop
 822de74:	e037883a 	mov	sp,fp
 822de78:	dfc00117 	ldw	ra,4(sp)
 822de7c:	df000017 	ldw	fp,0(sp)
 822de80:	dec00204 	addi	sp,sp,8
 822de84:	f800283a 	ret

0822de88 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 822de88:	defffc04 	addi	sp,sp,-16
 822de8c:	dfc00315 	stw	ra,12(sp)
 822de90:	df000215 	stw	fp,8(sp)
 822de94:	df000204 	addi	fp,sp,8
 822de98:	e13ffe15 	stw	r4,-8(fp)
 822de9c:	e17fff15 	stw	r5,-4(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 822dea0:	e0bffe17 	ldw	r2,-8(fp)
 822dea4:	108000a0 	cmpeqi	r2,r2,2
 822dea8:	1000031e 	bne	r2,zero,822deb8 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 822deac:	822d1c80 	call	822d1c8 <dtrap>
         return NULL;
 822deb0:	0005883a 	mov	r2,zero
 822deb4:	00001306 	br	822df04 <pffindtype+0x7c>
      }
   }

   if (type == SOCK_STREAM)
 822deb8:	e0bfff17 	ldw	r2,-4(fp)
 822debc:	10800058 	cmpnei	r2,r2,1
 822dec0:	1000031e 	bne	r2,zero,822ded0 <pffindtype+0x48>
      return &tcp_protosw;
 822dec4:	00820974 	movhi	r2,2085
 822dec8:	108d4804 	addi	r2,r2,13600
 822decc:	00000d06 	br	822df04 <pffindtype+0x7c>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 822ded0:	e0bfff17 	ldw	r2,-4(fp)
 822ded4:	10800098 	cmpnei	r2,r2,2
 822ded8:	1000031e 	bne	r2,zero,822dee8 <pffindtype+0x60>
      return &udp_protosw;
 822dedc:	00820974 	movhi	r2,2085
 822dee0:	108d4e04 	addi	r2,r2,13624
 822dee4:	00000706 	br	822df04 <pffindtype+0x7c>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 822dee8:	e0bfff17 	ldw	r2,-4(fp)
 822deec:	108000d8 	cmpnei	r2,r2,3
 822def0:	1000031e 	bne	r2,zero,822df00 <pffindtype+0x78>
      return &rawip_protosw;
 822def4:	00820974 	movhi	r2,2085
 822def8:	108d5404 	addi	r2,r2,13648
 822defc:	00000106 	br	822df04 <pffindtype+0x7c>
#endif  /* IP_RAW */
   else
      return NULL;
 822df00:	0005883a 	mov	r2,zero
}
 822df04:	e037883a 	mov	sp,fp
 822df08:	dfc00117 	ldw	ra,4(sp)
 822df0c:	df000017 	ldw	fp,0(sp)
 822df10:	dec00204 	addi	sp,sp,8
 822df14:	f800283a 	ret

0822df18 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 822df18:	defffb04 	addi	sp,sp,-20
 822df1c:	dfc00415 	stw	ra,16(sp)
 822df20:	df000315 	stw	fp,12(sp)
 822df24:	df000304 	addi	fp,sp,12
 822df28:	e13ffd15 	stw	r4,-12(fp)
 822df2c:	e17ffe15 	stw	r5,-8(fp)
 822df30:	e1bfff15 	stw	r6,-4(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 822df34:	e0bfff17 	ldw	r2,-4(fp)
 822df38:	108000d8 	cmpnei	r2,r2,3
 822df3c:	1000041e 	bne	r2,zero,822df50 <pffindproto+0x38>
      return(pffindtype(domain, type));
 822df40:	e17fff17 	ldw	r5,-4(fp)
 822df44:	e13ffd17 	ldw	r4,-12(fp)
 822df48:	822de880 	call	822de88 <pffindtype>
 822df4c:	00001e06 	br	822dfc8 <pffindproto+0xb0>
#endif

   switch (protocol)
 822df50:	e0bffe17 	ldw	r2,-8(fp)
 822df54:	10c001a0 	cmpeqi	r3,r2,6
 822df58:	1800041e 	bne	r3,zero,822df6c <pffindproto+0x54>
 822df5c:	10c00460 	cmpeqi	r3,r2,17
 822df60:	1800081e 	bne	r3,zero,822df84 <pffindproto+0x6c>
 822df64:	10001026 	beq	r2,zero,822dfa8 <pffindproto+0x90>
 822df68:	00000c06 	br	822df9c <pffindproto+0x84>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 822df6c:	e0bfff17 	ldw	r2,-4(fp)
 822df70:	10800058 	cmpnei	r2,r2,1
 822df74:	10000e26 	beq	r2,zero,822dfb0 <pffindproto+0x98>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 822df78:	822d1c80 	call	822d1c8 <dtrap>
      return NULL;
 822df7c:	0005883a 	mov	r2,zero
 822df80:	00001106 	br	822dfc8 <pffindproto+0xb0>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 822df84:	e0bfff17 	ldw	r2,-4(fp)
 822df88:	10800098 	cmpnei	r2,r2,2
 822df8c:	10000a26 	beq	r2,zero,822dfb8 <pffindproto+0xa0>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 822df90:	822d1c80 	call	822d1c8 <dtrap>
      return NULL;
 822df94:	0005883a 	mov	r2,zero
 822df98:	00000b06 	br	822dfc8 <pffindproto+0xb0>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 822df9c:	822d1c80 	call	822d1c8 <dtrap>
      return NULL;
 822dfa0:	0005883a 	mov	r2,zero
 822dfa4:	00000806 	br	822dfc8 <pffindproto+0xb0>
      dtrap();
      return NULL;
#endif /* BSD_SOCKETS */
   case 0:
      /* let protocol default based on socket type */
      break;
 822dfa8:	0001883a 	nop
 822dfac:	00000306 	br	822dfbc <pffindproto+0xa4>
   switch (protocol)
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
         break;
 822dfb0:	0001883a 	nop
 822dfb4:	00000106 	br	822dfbc <pffindproto+0xa4>
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
      return NULL;
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
         break;
 822dfb8:	0001883a 	nop
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
      return NULL;
   }
   return(pffindtype(domain, type));   /* map to findtype */
 822dfbc:	e17fff17 	ldw	r5,-4(fp)
 822dfc0:	e13ffd17 	ldw	r4,-12(fp)
 822dfc4:	822de880 	call	822de88 <pffindtype>
}
 822dfc8:	e037883a 	mov	sp,fp
 822dfcc:	dfc00117 	ldw	ra,4(sp)
 822dfd0:	df000017 	ldw	fp,0(sp)
 822dfd4:	dec00204 	addi	sp,sp,8
 822dfd8:	f800283a 	ret

0822dfdc <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 822dfdc:	defffa04 	addi	sp,sp,-24
 822dfe0:	dfc00515 	stw	ra,20(sp)
 822dfe4:	df000415 	stw	fp,16(sp)
 822dfe8:	df000404 	addi	fp,sp,16
 822dfec:	e13ffe15 	stw	r4,-8(fp)
 822dff0:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 822dff4:	e03ffc15 	stw	zero,-16(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 822dff8:	e0bffe17 	ldw	r2,-8(fp)
 822dffc:	0080030e 	bge	zero,r2,822e00c <m_getnbuf+0x30>
 822e000:	e0bffe17 	ldw	r2,-8(fp)
 822e004:	10800390 	cmplti	r2,r2,14
 822e008:	1000011e 	bne	r2,zero,822e010 <m_getnbuf+0x34>
   {
      dtrap(); /* is this OK? */
 822e00c:	822d1c80 	call	822d1c8 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 822e010:	e0bfff17 	ldw	r2,-4(fp)
 822e014:	10000d26 	beq	r2,zero,822e04c <m_getnbuf+0x70>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e018:	01000084 	movi	r4,2
 822e01c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 822e020:	e0bfff17 	ldw	r2,-4(fp)
 822e024:	10800e04 	addi	r2,r2,56
 822e028:	1009883a 	mov	r4,r2
 822e02c:	822c6200 	call	822c620 <pk_alloc>
 822e030:	e0bffc15 	stw	r2,-16(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e034:	01000084 	movi	r4,2
 822e038:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 822e03c:	e0bffc17 	ldw	r2,-16(fp)
 822e040:	1000021e 	bne	r2,zero,822e04c <m_getnbuf+0x70>
         return NULL;
 822e044:	0005883a 	mov	r2,zero
 822e048:	00004106 	br	822e150 <m_getnbuf+0x174>
   }

   m = (struct mbuf *)getq(&mfreeq);
 822e04c:	010209b4 	movhi	r4,2086
 822e050:	21380804 	addi	r4,r4,-8160
 822e054:	822caf80 	call	822caf8 <getq>
 822e058:	e0bffd15 	stw	r2,-12(fp)
   if (!m)
 822e05c:	e0bffd17 	ldw	r2,-12(fp)
 822e060:	10000a1e 	bne	r2,zero,822e08c <m_getnbuf+0xb0>
   {
      if (pkt) 
 822e064:	e0bffc17 	ldw	r2,-16(fp)
 822e068:	10000626 	beq	r2,zero,822e084 <m_getnbuf+0xa8>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822e06c:	01000084 	movi	r4,2
 822e070:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822e074:	e13ffc17 	ldw	r4,-16(fp)
 822e078:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e07c:	01000084 	movi	r4,2
 822e080:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 822e084:	0005883a 	mov	r2,zero
 822e088:	00003106 	br	822e150 <m_getnbuf+0x174>
   }
   m->m_type = type;
 822e08c:	e0bffd17 	ldw	r2,-12(fp)
 822e090:	e0fffe17 	ldw	r3,-8(fp)
 822e094:	10c00815 	stw	r3,32(r2)
   if (len == 0)
 822e098:	e0bfff17 	ldw	r2,-4(fp)
 822e09c:	1000071e 	bne	r2,zero,822e0bc <m_getnbuf+0xe0>
   {
      m->pkt = NULL;
 822e0a0:	e0bffd17 	ldw	r2,-12(fp)
 822e0a4:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 822e0a8:	e0bffd17 	ldw	r2,-12(fp)
 822e0ac:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 822e0b0:	e0bffd17 	ldw	r2,-12(fp)
 822e0b4:	10000515 	stw	zero,20(r2)
 822e0b8:	00001506 	br	822e110 <m_getnbuf+0x134>
   }
   else
   {
      m->pkt = pkt;
 822e0bc:	e0bffd17 	ldw	r2,-12(fp)
 822e0c0:	e0fffc17 	ldw	r3,-16(fp)
 822e0c4:	10c00115 	stw	r3,4(r2)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 822e0c8:	e0bffc17 	ldw	r2,-16(fp)
 822e0cc:	10800117 	ldw	r2,4(r2)
 822e0d0:	10c00e04 	addi	r3,r2,56
 822e0d4:	e0bffc17 	ldw	r2,-16(fp)
 822e0d8:	10c00315 	stw	r3,12(r2)
 822e0dc:	e0bffc17 	ldw	r2,-16(fp)
 822e0e0:	10c00317 	ldw	r3,12(r2)
 822e0e4:	e0bffd17 	ldw	r2,-12(fp)
 822e0e8:	10c00315 	stw	r3,12(r2)
 822e0ec:	e0bffd17 	ldw	r2,-12(fp)
 822e0f0:	10c00317 	ldw	r3,12(r2)
 822e0f4:	e0bffd17 	ldw	r2,-12(fp)
 822e0f8:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 822e0fc:	e0bffc17 	ldw	r2,-16(fp)
 822e100:	10800217 	ldw	r2,8(r2)
 822e104:	10fff204 	addi	r3,r2,-56
 822e108:	e0bffd17 	ldw	r2,-12(fp)
 822e10c:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 822e110:	e0bffd17 	ldw	r2,-12(fp)
 822e114:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 822e118:	e0bffd17 	ldw	r2,-12(fp)
 822e11c:	10000715 	stw	zero,28(r2)
 822e120:	e0bffd17 	ldw	r2,-12(fp)
 822e124:	10c00717 	ldw	r3,28(r2)
 822e128:	e0bffd17 	ldw	r2,-12(fp)
 822e12c:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 822e130:	d0a0ae17 	ldw	r2,-32072(gp)
 822e134:	10800044 	addi	r2,r2,1
 822e138:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 822e13c:	e17ffd17 	ldw	r5,-12(fp)
 822e140:	010209b4 	movhi	r4,2086
 822e144:	21380304 	addi	r4,r4,-8180
 822e148:	822cbb00 	call	822cbb0 <putq>
   return m;
 822e14c:	e0bffd17 	ldw	r2,-12(fp)
}
 822e150:	e037883a 	mov	sp,fp
 822e154:	dfc00117 	ldw	ra,4(sp)
 822e158:	df000017 	ldw	fp,0(sp)
 822e15c:	dec00204 	addi	sp,sp,8
 822e160:	f800283a 	ret

0822e164 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 822e164:	defffc04 	addi	sp,sp,-16
 822e168:	dfc00315 	stw	ra,12(sp)
 822e16c:	df000215 	stw	fp,8(sp)
 822e170:	df000204 	addi	fp,sp,8
 822e174:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 822e178:	008209b4 	movhi	r2,2086
 822e17c:	10b80304 	addi	r2,r2,-8180
 822e180:	10800217 	ldw	r2,8(r2)
 822e184:	00800316 	blt	zero,r2,822e194 <m_free+0x30>
      panic("mfree: q_len");
 822e188:	01020974 	movhi	r4,2085
 822e18c:	2101e704 	addi	r4,r4,1948
 822e190:	822887c0 	call	822887c <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 822e194:	e0bfff17 	ldw	r2,-4(fp)
 822e198:	10800817 	ldw	r2,32(r2)
 822e19c:	0080040e 	bge	zero,r2,822e1b0 <m_free+0x4c>
 822e1a0:	e0bfff17 	ldw	r2,-4(fp)
 822e1a4:	10800817 	ldw	r2,32(r2)
 822e1a8:	10800390 	cmplti	r2,r2,14
 822e1ac:	10000a1e 	bne	r2,zero,822e1d8 <m_free+0x74>
   {
      if (m->m_type == MT_FREE)
 822e1b0:	e0bfff17 	ldw	r2,-4(fp)
 822e1b4:	10800817 	ldw	r2,32(r2)
 822e1b8:	1000041e 	bne	r2,zero,822e1cc <m_free+0x68>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 822e1bc:	822d1c80 	call	822d1c8 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 822e1c0:	e0bfff17 	ldw	r2,-4(fp)
 822e1c4:	10800617 	ldw	r2,24(r2)
 822e1c8:	00002306 	br	822e258 <m_free+0xf4>
      }
      else
         panic("m_free: type");
 822e1cc:	01020974 	movhi	r4,2085
 822e1d0:	2101eb04 	addi	r4,r4,1964
 822e1d4:	822887c0 	call	822887c <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 822e1d8:	e0bfff17 	ldw	r2,-4(fp)
 822e1dc:	10800617 	ldw	r2,24(r2)
 822e1e0:	e0bffe15 	stw	r2,-8(fp)

   if (qdel(&mbufq, m) == NULL)
 822e1e4:	e17fff17 	ldw	r5,-4(fp)
 822e1e8:	010209b4 	movhi	r4,2086
 822e1ec:	21380304 	addi	r4,r4,-8180
 822e1f0:	822cc600 	call	822cc60 <qdel>
 822e1f4:	1000031e 	bne	r2,zero,822e204 <m_free+0xa0>
      panic("m_free: missing");
 822e1f8:	01020974 	movhi	r4,2085
 822e1fc:	2101ef04 	addi	r4,r4,1980
 822e200:	822887c0 	call	822887c <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 822e204:	e0bfff17 	ldw	r2,-4(fp)
 822e208:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 822e20c:	e0bfff17 	ldw	r2,-4(fp)
 822e210:	10800117 	ldw	r2,4(r2)
 822e214:	10000826 	beq	r2,zero,822e238 <m_free+0xd4>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e218:	01000084 	movi	r4,2
 822e21c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 822e220:	e0bfff17 	ldw	r2,-4(fp)
 822e224:	10800117 	ldw	r2,4(r2)
 822e228:	1009883a 	mov	r4,r2
 822e22c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e230:	01000084 	movi	r4,2
 822e234:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 822e238:	d0a0af17 	ldw	r2,-32068(gp)
 822e23c:	10800044 	addi	r2,r2,1
 822e240:	d0a0af15 	stw	r2,-32068(gp)
   putq(&mfreeq, (qp)m);
 822e244:	e17fff17 	ldw	r5,-4(fp)
 822e248:	010209b4 	movhi	r4,2086
 822e24c:	21380804 	addi	r4,r4,-8160
 822e250:	822cbb00 	call	822cbb0 <putq>
   return nextptr;
 822e254:	e0bffe17 	ldw	r2,-8(fp)
}
 822e258:	e037883a 	mov	sp,fp
 822e25c:	dfc00117 	ldw	ra,4(sp)
 822e260:	df000017 	ldw	fp,0(sp)
 822e264:	dec00204 	addi	sp,sp,8
 822e268:	f800283a 	ret

0822e26c <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 822e26c:	defffd04 	addi	sp,sp,-12
 822e270:	dfc00215 	stw	ra,8(sp)
 822e274:	df000115 	stw	fp,4(sp)
 822e278:	df000104 	addi	fp,sp,4
 822e27c:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 822e280:	00000306 	br	822e290 <m_freem+0x24>
      m = m_free(m);
 822e284:	e13fff17 	ldw	r4,-4(fp)
 822e288:	822e1640 	call	822e164 <m_free>
 822e28c:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 822e290:	e0bfff17 	ldw	r2,-4(fp)
 822e294:	103ffb1e 	bne	r2,zero,822e284 <m_freem+0x18>
      m = m_free(m);
}
 822e298:	0001883a 	nop
 822e29c:	e037883a 	mov	sp,fp
 822e2a0:	dfc00117 	ldw	ra,4(sp)
 822e2a4:	df000017 	ldw	fp,0(sp)
 822e2a8:	dec00204 	addi	sp,sp,8
 822e2ac:	f800283a 	ret

0822e2b0 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 822e2b0:	defff704 	addi	sp,sp,-36
 822e2b4:	dfc00815 	stw	ra,32(sp)
 822e2b8:	df000715 	stw	fp,28(sp)
 822e2bc:	df000704 	addi	fp,sp,28
 822e2c0:	e13ffd15 	stw	r4,-12(fp)
 822e2c4:	e17ffe15 	stw	r5,-8(fp)
 822e2c8:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 822e2cc:	e0bfff17 	ldw	r2,-4(fp)
 822e2d0:	1000021e 	bne	r2,zero,822e2dc <m_copy+0x2c>
      return NULL;
 822e2d4:	0005883a 	mov	r2,zero
 822e2d8:	0000ad06 	br	822e590 <m_copy+0x2e0>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 822e2dc:	e0bffe17 	ldw	r2,-8(fp)
 822e2e0:	10000516 	blt	r2,zero,822e2f8 <m_copy+0x48>
 822e2e4:	e0bfff17 	ldw	r2,-4(fp)
 822e2e8:	1000180e 	bge	r2,zero,822e34c <m_copy+0x9c>
 822e2ec:	e0bfff17 	ldw	r2,-4(fp)
 822e2f0:	10bfffe0 	cmpeqi	r2,r2,-1
 822e2f4:	1000151e 	bne	r2,zero,822e34c <m_copy+0x9c>
   {
      dtrap();
 822e2f8:	822d1c80 	call	822d1c8 <dtrap>
      return NULL;
 822e2fc:	0005883a 	mov	r2,zero
 822e300:	0000a306 	br	822e590 <m_copy+0x2e0>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 822e304:	e0bffd17 	ldw	r2,-12(fp)
 822e308:	1000031e 	bne	r2,zero,822e318 <m_copy+0x68>
      {
         dtrap();
 822e30c:	822d1c80 	call	822d1c8 <dtrap>
         return NULL;
 822e310:	0005883a 	mov	r2,zero
 822e314:	00009e06 	br	822e590 <m_copy+0x2e0>
      }
      if (off < (int)m->m_len)
 822e318:	e0bffd17 	ldw	r2,-12(fp)
 822e31c:	10800217 	ldw	r2,8(r2)
 822e320:	1007883a 	mov	r3,r2
 822e324:	e0bffe17 	ldw	r2,-8(fp)
 822e328:	10c00b16 	blt	r2,r3,822e358 <m_copy+0xa8>
         break;
      off -= m->m_len;
 822e32c:	e0fffe17 	ldw	r3,-8(fp)
 822e330:	e0bffd17 	ldw	r2,-12(fp)
 822e334:	10800217 	ldw	r2,8(r2)
 822e338:	1885c83a 	sub	r2,r3,r2
 822e33c:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e340:	e0bffd17 	ldw	r2,-12(fp)
 822e344:	10800617 	ldw	r2,24(r2)
 822e348:	e0bffd15 	stw	r2,-12(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 822e34c:	e0bffe17 	ldw	r2,-8(fp)
 822e350:	00bfec16 	blt	zero,r2,822e304 <m_copy+0x54>
 822e354:	00000106 	br	822e35c <m_copy+0xac>
      {
         dtrap();
         return NULL;
      }
      if (off < (int)m->m_len)
         break;
 822e358:	0001883a 	nop
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 822e35c:	e03ffb15 	stw	zero,-20(fp)
 822e360:	e0bffb17 	ldw	r2,-20(fp)
 822e364:	e0bffa15 	stw	r2,-24(fp)

   while (len > 0)
 822e368:	00007f06 	br	822e568 <m_copy+0x2b8>
   {
      if (m == NULL) /* at end of queue? */
 822e36c:	e0bffd17 	ldw	r2,-12(fp)
 822e370:	1000051e 	bne	r2,zero,822e388 <m_copy+0xd8>
      {
         panic("m_copy: bad len");
 822e374:	01020974 	movhi	r4,2085
 822e378:	2101f304 	addi	r4,r4,1996
 822e37c:	822887c0 	call	822887c <panic>
         return NULL;
 822e380:	0005883a 	mov	r2,zero
 822e384:	00008206 	br	822e590 <m_copy+0x2e0>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 822e388:	e0bffd17 	ldw	r2,-12(fp)
 822e38c:	10c00217 	ldw	r3,8(r2)
 822e390:	e0bffe17 	ldw	r2,-8(fp)
 822e394:	1885c83a 	sub	r2,r3,r2
 822e398:	e0ffff17 	ldw	r3,-4(fp)
 822e39c:	1880010e 	bge	r3,r2,822e3a4 <m_copy+0xf4>
 822e3a0:	1805883a 	mov	r2,r3
 822e3a4:	e0bffc15 	stw	r2,-16(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e3a8:	e0bffe17 	ldw	r2,-8(fp)
 822e3ac:	108000cc 	andi	r2,r2,3
 822e3b0:	1000051e 	bne	r2,zero,822e3c8 <m_copy+0x118>
          (m->pkt->inuse != 1))
 822e3b4:	e0bffd17 	ldw	r2,-12(fp)
 822e3b8:	10800117 	ldw	r2,4(r2)
 822e3bc:	10800917 	ldw	r2,36(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e3c0:	10800060 	cmpeqi	r2,r2,1
 822e3c4:	1000251e 	bne	r2,zero,822e45c <m_copy+0x1ac>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 822e3c8:	e0bffd17 	ldw	r2,-12(fp)
 822e3cc:	10800817 	ldw	r2,32(r2)
 822e3d0:	e17ffc17 	ldw	r5,-16(fp)
 822e3d4:	1009883a 	mov	r4,r2
 822e3d8:	822dfdc0 	call	822dfdc <m_getnbuf>
 822e3dc:	e0bff915 	stw	r2,-28(fp)
 822e3e0:	e0bff917 	ldw	r2,-28(fp)
 822e3e4:	10006426 	beq	r2,zero,822e578 <m_copy+0x2c8>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 822e3e8:	e0bff917 	ldw	r2,-28(fp)
 822e3ec:	11000317 	ldw	r4,12(r2)
 822e3f0:	e0bffd17 	ldw	r2,-12(fp)
 822e3f4:	10c00317 	ldw	r3,12(r2)
 822e3f8:	e0bffe17 	ldw	r2,-8(fp)
 822e3fc:	1885883a 	add	r2,r3,r2
 822e400:	e0fffc17 	ldw	r3,-16(fp)
 822e404:	180d883a 	mov	r6,r3
 822e408:	100b883a 	mov	r5,r2
 822e40c:	8202a0c0 	call	8202a0c <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 822e410:	e0fffc17 	ldw	r3,-16(fp)
 822e414:	e0bff917 	ldw	r2,-28(fp)
 822e418:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 822e41c:	008209b4 	movhi	r2,2086
 822e420:	10b82204 	addi	r2,r2,-8056
 822e424:	10802e17 	ldw	r2,184(r2)
 822e428:	10c00044 	addi	r3,r2,1
 822e42c:	008209b4 	movhi	r2,2086
 822e430:	10b82204 	addi	r2,r2,-8056
 822e434:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 822e438:	008209b4 	movhi	r2,2086
 822e43c:	10b82204 	addi	r2,r2,-8056
 822e440:	10c03017 	ldw	r3,192(r2)
 822e444:	e0bffc17 	ldw	r2,-16(fp)
 822e448:	1887883a 	add	r3,r3,r2
 822e44c:	008209b4 	movhi	r2,2086
 822e450:	10b82204 	addi	r2,r2,-8056
 822e454:	10c03015 	stw	r3,192(r2)
 822e458:	00003106 	br	822e520 <m_copy+0x270>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 822e45c:	e0bffd17 	ldw	r2,-12(fp)
 822e460:	10800817 	ldw	r2,32(r2)
 822e464:	000b883a 	mov	r5,zero
 822e468:	1009883a 	mov	r4,r2
 822e46c:	822dfdc0 	call	822dfdc <m_getnbuf>
 822e470:	e0bff915 	stw	r2,-28(fp)
 822e474:	e0bff917 	ldw	r2,-28(fp)
 822e478:	10004126 	beq	r2,zero,822e580 <m_copy+0x2d0>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 822e47c:	e0bffd17 	ldw	r2,-12(fp)
 822e480:	10800117 	ldw	r2,4(r2)
 822e484:	10c00917 	ldw	r3,36(r2)
 822e488:	18c00044 	addi	r3,r3,1
 822e48c:	10c00915 	stw	r3,36(r2)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 822e490:	e0bffd17 	ldw	r2,-12(fp)
 822e494:	10c00117 	ldw	r3,4(r2)
 822e498:	e0bff917 	ldw	r2,-28(fp)
 822e49c:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 822e4a0:	e0bffd17 	ldw	r2,-12(fp)
 822e4a4:	10c00417 	ldw	r3,16(r2)
 822e4a8:	e0bff917 	ldw	r2,-28(fp)
 822e4ac:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 822e4b0:	e0bffd17 	ldw	r2,-12(fp)
 822e4b4:	10c00517 	ldw	r3,20(r2)
 822e4b8:	e0bff917 	ldw	r2,-28(fp)
 822e4bc:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 822e4c0:	e0bffd17 	ldw	r2,-12(fp)
 822e4c4:	10c00317 	ldw	r3,12(r2)
 822e4c8:	e0bffe17 	ldw	r2,-8(fp)
 822e4cc:	1887883a 	add	r3,r3,r2
 822e4d0:	e0bff917 	ldw	r2,-28(fp)
 822e4d4:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 822e4d8:	e0fffc17 	ldw	r3,-16(fp)
 822e4dc:	e0bff917 	ldw	r2,-28(fp)
 822e4e0:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 822e4e4:	008209b4 	movhi	r2,2086
 822e4e8:	10b82204 	addi	r2,r2,-8056
 822e4ec:	10802f17 	ldw	r2,188(r2)
 822e4f0:	10c00044 	addi	r3,r2,1
 822e4f4:	008209b4 	movhi	r2,2086
 822e4f8:	10b82204 	addi	r2,r2,-8056
 822e4fc:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 822e500:	008209b4 	movhi	r2,2086
 822e504:	10b82204 	addi	r2,r2,-8056
 822e508:	10c03117 	ldw	r3,196(r2)
 822e50c:	e0bffc17 	ldw	r2,-16(fp)
 822e510:	1887883a 	add	r3,r3,r2
 822e514:	008209b4 	movhi	r2,2086
 822e518:	10b82204 	addi	r2,r2,-8056
 822e51c:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 822e520:	e0ffff17 	ldw	r3,-4(fp)
 822e524:	e0bffc17 	ldw	r2,-16(fp)
 822e528:	1885c83a 	sub	r2,r3,r2
 822e52c:	e0bfff15 	stw	r2,-4(fp)
      off = 0;
 822e530:	e03ffe15 	stw	zero,-8(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 822e534:	e0bffb17 	ldw	r2,-20(fp)
 822e538:	10000426 	beq	r2,zero,822e54c <m_copy+0x29c>
         tail->m_next = nb;
 822e53c:	e0bffb17 	ldw	r2,-20(fp)
 822e540:	e0fff917 	ldw	r3,-28(fp)
 822e544:	10c00615 	stw	r3,24(r2)
 822e548:	00000206 	br	822e554 <m_copy+0x2a4>
      else
         head = nb;
 822e54c:	e0bff917 	ldw	r2,-28(fp)
 822e550:	e0bffa15 	stw	r2,-24(fp)
      tail = nb;     /* always make new mbuf the tail */
 822e554:	e0bff917 	ldw	r2,-28(fp)
 822e558:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 822e55c:	e0bffd17 	ldw	r2,-12(fp)
 822e560:	10800617 	ldw	r2,24(r2)
 822e564:	e0bffd15 	stw	r2,-12(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 822e568:	e0bfff17 	ldw	r2,-4(fp)
 822e56c:	00bf7f16 	blt	zero,r2,822e36c <m_copy+0xbc>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 822e570:	e0bffa17 	ldw	r2,-24(fp)
 822e574:	00000606 	br	822e590 <m_copy+0x2e0>
       */
      if ((off & (ALIGN_TYPE - 1)) ||
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
            goto nospace;
 822e578:	0001883a 	nop
 822e57c:	00000106 	br	822e584 <m_copy+0x2d4>
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
            goto nospace;
 822e580:	0001883a 	nop
   }

   return head;

nospace:
   m_freem (head);
 822e584:	e13ffa17 	ldw	r4,-24(fp)
 822e588:	822e26c0 	call	822e26c <m_freem>
   return NULL;
 822e58c:	0005883a 	mov	r2,zero
}
 822e590:	e037883a 	mov	sp,fp
 822e594:	dfc00117 	ldw	ra,4(sp)
 822e598:	df000017 	ldw	fp,0(sp)
 822e59c:	dec00204 	addi	sp,sp,8
 822e5a0:	f800283a 	ret

0822e5a4 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 822e5a4:	defffb04 	addi	sp,sp,-20
 822e5a8:	df000415 	stw	fp,16(sp)
 822e5ac:	df000404 	addi	fp,sp,16
 822e5b0:	e13ffe15 	stw	r4,-8(fp)
 822e5b4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 822e5b8:	e0bffe17 	ldw	r2,-8(fp)
 822e5bc:	e0bffc15 	stw	r2,-16(fp)
 822e5c0:	e0bffc17 	ldw	r2,-16(fp)
 822e5c4:	10006226 	beq	r2,zero,822e750 <m_adj+0x1ac>
      return;

   if (len >= 0) 
 822e5c8:	e0bfff17 	ldw	r2,-4(fp)
 822e5cc:	10002216 	blt	r2,zero,822e658 <m_adj+0xb4>
   {
      while (m != NULL && len > 0) 
 822e5d0:	00001c06 	br	822e644 <m_adj+0xa0>
      {
         if (m->m_len <= (unsigned)len)
 822e5d4:	e0bffc17 	ldw	r2,-16(fp)
 822e5d8:	10800217 	ldw	r2,8(r2)
 822e5dc:	e0ffff17 	ldw	r3,-4(fp)
 822e5e0:	18800b36 	bltu	r3,r2,822e610 <m_adj+0x6c>
         {
            len -= m->m_len;
 822e5e4:	e0ffff17 	ldw	r3,-4(fp)
 822e5e8:	e0bffc17 	ldw	r2,-16(fp)
 822e5ec:	10800217 	ldw	r2,8(r2)
 822e5f0:	1885c83a 	sub	r2,r3,r2
 822e5f4:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 822e5f8:	e0bffc17 	ldw	r2,-16(fp)
 822e5fc:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 822e600:	e0bffc17 	ldw	r2,-16(fp)
 822e604:	10800617 	ldw	r2,24(r2)
 822e608:	e0bffc15 	stw	r2,-16(fp)
 822e60c:	00000d06 	br	822e644 <m_adj+0xa0>
         }
         else
         {
            m->m_len -= len;
 822e610:	e0bffc17 	ldw	r2,-16(fp)
 822e614:	10c00217 	ldw	r3,8(r2)
 822e618:	e0bfff17 	ldw	r2,-4(fp)
 822e61c:	1887c83a 	sub	r3,r3,r2
 822e620:	e0bffc17 	ldw	r2,-16(fp)
 822e624:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 822e628:	e0bffc17 	ldw	r2,-16(fp)
 822e62c:	10c00317 	ldw	r3,12(r2)
 822e630:	e0bfff17 	ldw	r2,-4(fp)
 822e634:	1887883a 	add	r3,r3,r2
 822e638:	e0bffc17 	ldw	r2,-16(fp)
 822e63c:	10c00315 	stw	r3,12(r2)
            break;
 822e640:	00004406 	br	822e754 <m_adj+0x1b0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 822e644:	e0bffc17 	ldw	r2,-16(fp)
 822e648:	10004226 	beq	r2,zero,822e754 <m_adj+0x1b0>
 822e64c:	e0bfff17 	ldw	r2,-4(fp)
 822e650:	00bfe016 	blt	zero,r2,822e5d4 <m_adj+0x30>
 822e654:	00003f06 	br	822e754 <m_adj+0x1b0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 822e658:	e0bfff17 	ldw	r2,-4(fp)
 822e65c:	0085c83a 	sub	r2,zero,r2
 822e660:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 822e664:	e03ffd15 	stw	zero,-12(fp)
      for (;;) 
      {
         count += m->m_len;
 822e668:	e0bffc17 	ldw	r2,-16(fp)
 822e66c:	10c00217 	ldw	r3,8(r2)
 822e670:	e0bffd17 	ldw	r2,-12(fp)
 822e674:	1885883a 	add	r2,r3,r2
 822e678:	e0bffd15 	stw	r2,-12(fp)
         if (m->m_next == (struct mbuf *)0)
 822e67c:	e0bffc17 	ldw	r2,-16(fp)
 822e680:	10800617 	ldw	r2,24(r2)
 822e684:	10000426 	beq	r2,zero,822e698 <m_adj+0xf4>
            break;
         m = m->m_next;
 822e688:	e0bffc17 	ldw	r2,-16(fp)
 822e68c:	10800617 	ldw	r2,24(r2)
 822e690:	e0bffc15 	stw	r2,-16(fp)
      }
 822e694:	003ff406 	br	822e668 <m_adj+0xc4>
      count = 0;
      for (;;) 
      {
         count += m->m_len;
         if (m->m_next == (struct mbuf *)0)
            break;
 822e698:	0001883a 	nop
         m = m->m_next;
      }
      if (m->m_len >= (unsigned)len)
 822e69c:	e0bffc17 	ldw	r2,-16(fp)
 822e6a0:	10c00217 	ldw	r3,8(r2)
 822e6a4:	e0bfff17 	ldw	r2,-4(fp)
 822e6a8:	18800736 	bltu	r3,r2,822e6c8 <m_adj+0x124>
      {
         m->m_len -= len;
 822e6ac:	e0bffc17 	ldw	r2,-16(fp)
 822e6b0:	10c00217 	ldw	r3,8(r2)
 822e6b4:	e0bfff17 	ldw	r2,-4(fp)
 822e6b8:	1887c83a 	sub	r3,r3,r2
 822e6bc:	e0bffc17 	ldw	r2,-16(fp)
 822e6c0:	10c00215 	stw	r3,8(r2)
         return;
 822e6c4:	00002306 	br	822e754 <m_adj+0x1b0>
      }
      count -= len;
 822e6c8:	e0fffd17 	ldw	r3,-12(fp)
 822e6cc:	e0bfff17 	ldw	r2,-4(fp)
 822e6d0:	1885c83a 	sub	r2,r3,r2
 822e6d4:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822e6d8:	e0bffe17 	ldw	r2,-8(fp)
 822e6dc:	e0bffc15 	stw	r2,-16(fp)
 822e6e0:	00001006 	br	822e724 <m_adj+0x180>
      {
         if (m->m_len >= (unsigned)count)
 822e6e4:	e0bffc17 	ldw	r2,-16(fp)
 822e6e8:	10c00217 	ldw	r3,8(r2)
 822e6ec:	e0bffd17 	ldw	r2,-12(fp)
 822e6f0:	18800436 	bltu	r3,r2,822e704 <m_adj+0x160>
         {
            m->m_len = count;
 822e6f4:	e0fffd17 	ldw	r3,-12(fp)
 822e6f8:	e0bffc17 	ldw	r2,-16(fp)
 822e6fc:	10c00215 	stw	r3,8(r2)
            break;
 822e700:	00000a06 	br	822e72c <m_adj+0x188>
         }
         count -= m->m_len;
 822e704:	e0fffd17 	ldw	r3,-12(fp)
 822e708:	e0bffc17 	ldw	r2,-16(fp)
 822e70c:	10800217 	ldw	r2,8(r2)
 822e710:	1885c83a 	sub	r2,r3,r2
 822e714:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822e718:	e0bffc17 	ldw	r2,-16(fp)
 822e71c:	10800617 	ldw	r2,24(r2)
 822e720:	e0bffc15 	stw	r2,-16(fp)
 822e724:	e0bffc17 	ldw	r2,-16(fp)
 822e728:	103fee1e 	bne	r2,zero,822e6e4 <m_adj+0x140>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822e72c:	00000206 	br	822e738 <m_adj+0x194>
         m->m_len = 0;
 822e730:	e0bffc17 	ldw	r2,-16(fp)
 822e734:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822e738:	e0bffc17 	ldw	r2,-16(fp)
 822e73c:	10800617 	ldw	r2,24(r2)
 822e740:	e0bffc15 	stw	r2,-16(fp)
 822e744:	e0bffc17 	ldw	r2,-16(fp)
 822e748:	103ff91e 	bne	r2,zero,822e730 <m_adj+0x18c>
 822e74c:	00000106 	br	822e754 <m_adj+0x1b0>
{
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
      return;
 822e750:	0001883a 	nop
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
         m->m_len = 0;
   }
}
 822e754:	e037883a 	mov	sp,fp
 822e758:	df000017 	ldw	fp,0(sp)
 822e75c:	dec00104 	addi	sp,sp,4
 822e760:	f800283a 	ret

0822e764 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 822e764:	defffd04 	addi	sp,sp,-12
 822e768:	df000215 	stw	fp,8(sp)
 822e76c:	df000204 	addi	fp,sp,8
 822e770:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 822e774:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 822e778:	00000806 	br	822e79c <mbuf_len+0x38>
   {
      len += m->m_len;
 822e77c:	e0bfff17 	ldw	r2,-4(fp)
 822e780:	10c00217 	ldw	r3,8(r2)
 822e784:	e0bffe17 	ldw	r2,-8(fp)
 822e788:	1885883a 	add	r2,r3,r2
 822e78c:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e790:	e0bfff17 	ldw	r2,-4(fp)
 822e794:	10800617 	ldw	r2,24(r2)
 822e798:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 822e79c:	e0bfff17 	ldw	r2,-4(fp)
 822e7a0:	103ff61e 	bne	r2,zero,822e77c <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 822e7a4:	e0bffe17 	ldw	r2,-8(fp)
}
 822e7a8:	e037883a 	mov	sp,fp
 822e7ac:	df000017 	ldw	fp,0(sp)
 822e7b0:	dec00104 	addi	sp,sp,4
 822e7b4:	f800283a 	ret

0822e7b8 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 822e7b8:	defffb04 	addi	sp,sp,-20
 822e7bc:	dfc00415 	stw	ra,16(sp)
 822e7c0:	df000315 	stw	fp,12(sp)
 822e7c4:	df000304 	addi	fp,sp,12
 822e7c8:	e13fff15 	stw	r4,-4(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822e7cc:	008209b4 	movhi	r2,2086
 822e7d0:	10b80304 	addi	r2,r2,-8180
 822e7d4:	10800017 	ldw	r2,0(r2)
 822e7d8:	e0bffd15 	stw	r2,-12(fp)
 822e7dc:	00001206 	br	822e828 <dtom+0x70>
   {
      m = (struct mbuf *)qptr;
 822e7e0:	e0bffd17 	ldw	r2,-12(fp)
 822e7e4:	e0bffe15 	stw	r2,-8(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 822e7e8:	e0bffe17 	ldw	r2,-8(fp)
 822e7ec:	10800417 	ldw	r2,16(r2)
 822e7f0:	e0ffff17 	ldw	r3,-4(fp)
 822e7f4:	18800936 	bltu	r3,r2,822e81c <dtom+0x64>
 822e7f8:	e0bffe17 	ldw	r2,-8(fp)
 822e7fc:	10c00417 	ldw	r3,16(r2)
 822e800:	e0bffe17 	ldw	r2,-8(fp)
 822e804:	10800517 	ldw	r2,20(r2)
 822e808:	1885883a 	add	r2,r3,r2
 822e80c:	e0ffff17 	ldw	r3,-4(fp)
 822e810:	1880022e 	bgeu	r3,r2,822e81c <dtom+0x64>
         return (struct mbuf *)qptr;
 822e814:	e0bffd17 	ldw	r2,-12(fp)
 822e818:	00000906 	br	822e840 <dtom+0x88>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822e81c:	e0bffd17 	ldw	r2,-12(fp)
 822e820:	10800017 	ldw	r2,0(r2)
 822e824:	e0bffd15 	stw	r2,-12(fp)
 822e828:	e0bffd17 	ldw	r2,-12(fp)
 822e82c:	103fec1e 	bne	r2,zero,822e7e0 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 822e830:	01020974 	movhi	r4,2085
 822e834:	2101f704 	addi	r4,r4,2012
 822e838:	822887c0 	call	822887c <panic>
   return NULL;
 822e83c:	0005883a 	mov	r2,zero
}
 822e840:	e037883a 	mov	sp,fp
 822e844:	dfc00117 	ldw	ra,4(sp)
 822e848:	df000017 	ldw	fp,0(sp)
 822e84c:	dec00204 	addi	sp,sp,8
 822e850:	f800283a 	ret

0822e854 <remque>:
};


void
remque (void * arg)
{
 822e854:	defffd04 	addi	sp,sp,-12
 822e858:	df000215 	stw	fp,8(sp)
 822e85c:	df000204 	addi	fp,sp,8
 822e860:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 822e864:	e0bfff17 	ldw	r2,-4(fp)
 822e868:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 822e86c:	e0bffe17 	ldw	r2,-8(fp)
 822e870:	10800117 	ldw	r2,4(r2)
 822e874:	10000e26 	beq	r2,zero,822e8b0 <remque+0x5c>
      old->prev->next = old->next;
 822e878:	e0bffe17 	ldw	r2,-8(fp)
 822e87c:	10800117 	ldw	r2,4(r2)
 822e880:	e0fffe17 	ldw	r3,-8(fp)
 822e884:	18c00017 	ldw	r3,0(r3)
 822e888:	10c00015 	stw	r3,0(r2)
   if (old->next)
 822e88c:	e0bffe17 	ldw	r2,-8(fp)
 822e890:	10800017 	ldw	r2,0(r2)
 822e894:	10000726 	beq	r2,zero,822e8b4 <remque+0x60>
      old->next->prev = old->prev;
 822e898:	e0bffe17 	ldw	r2,-8(fp)
 822e89c:	10800017 	ldw	r2,0(r2)
 822e8a0:	e0fffe17 	ldw	r3,-8(fp)
 822e8a4:	18c00117 	ldw	r3,4(r3)
 822e8a8:	10c00115 	stw	r3,4(r2)
 822e8ac:	00000106 	br	822e8b4 <remque+0x60>
remque (void * arg)
{
   struct bsdq *  old;

   old = (struct bsdq *)arg;
   if (!old->prev) return;
 822e8b0:	0001883a 	nop
      old->prev->next = old->next;
   if (old->next)
      old->next->prev = old->prev;
}
 822e8b4:	e037883a 	mov	sp,fp
 822e8b8:	df000017 	ldw	fp,0(sp)
 822e8bc:	dec00104 	addi	sp,sp,4
 822e8c0:	f800283a 	ret

0822e8c4 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 822e8c4:	defffb04 	addi	sp,sp,-20
 822e8c8:	df000415 	stw	fp,16(sp)
 822e8cc:	df000404 	addi	fp,sp,16
 822e8d0:	e13ffe15 	stw	r4,-8(fp)
 822e8d4:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 822e8d8:	e0bffe17 	ldw	r2,-8(fp)
 822e8dc:	e0bffc15 	stw	r2,-16(fp)
   prev = (struct bsdq *)p;
 822e8e0:	e0bfff17 	ldw	r2,-4(fp)
 822e8e4:	e0bffd15 	stw	r2,-12(fp)
   newe->next = prev->next;
 822e8e8:	e0bffd17 	ldw	r2,-12(fp)
 822e8ec:	10c00017 	ldw	r3,0(r2)
 822e8f0:	e0bffc17 	ldw	r2,-16(fp)
 822e8f4:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 822e8f8:	e0bffc17 	ldw	r2,-16(fp)
 822e8fc:	e0fffd17 	ldw	r3,-12(fp)
 822e900:	10c00115 	stw	r3,4(r2)
   prev->next = newe;
 822e904:	e0bffd17 	ldw	r2,-12(fp)
 822e908:	e0fffc17 	ldw	r3,-16(fp)
 822e90c:	10c00015 	stw	r3,0(r2)
   if (newe->next)
 822e910:	e0bffc17 	ldw	r2,-16(fp)
 822e914:	10800017 	ldw	r2,0(r2)
 822e918:	10000426 	beq	r2,zero,822e92c <insque+0x68>
      newe->next->prev = newe;
 822e91c:	e0bffc17 	ldw	r2,-16(fp)
 822e920:	10800017 	ldw	r2,0(r2)
 822e924:	e0fffc17 	ldw	r3,-16(fp)
 822e928:	10c00115 	stw	r3,4(r2)
}
 822e92c:	0001883a 	nop
 822e930:	e037883a 	mov	sp,fp
 822e934:	df000017 	ldw	fp,0(sp)
 822e938:	dec00104 	addi	sp,sp,4
 822e93c:	f800283a 	ret

0822e940 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 822e940:	defffb04 	addi	sp,sp,-20
 822e944:	dfc00415 	stw	ra,16(sp)
 822e948:	df000315 	stw	fp,12(sp)
 822e94c:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 822e950:	d0e03617 	ldw	r3,-32552(gp)
 822e954:	d0a03817 	ldw	r2,-32544(gp)
 822e958:	1885883a 	add	r2,r3,r2
 822e95c:	1085883a 	add	r2,r2,r2
 822e960:	108000c4 	addi	r2,r2,3
 822e964:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 822e968:	01800504 	movi	r6,20
 822e96c:	000b883a 	mov	r5,zero
 822e970:	010209b4 	movhi	r4,2086
 822e974:	2137ef04 	addi	r4,r4,-8260
 822e978:	8202cb00 	call	8202cb0 <memset>
   MEMSET(&mbufq, 0, sizeof(mbufq));
 822e97c:	01800504 	movi	r6,20
 822e980:	000b883a 	mov	r5,zero
 822e984:	010209b4 	movhi	r4,2086
 822e988:	21380304 	addi	r4,r4,-8180
 822e98c:	8202cb00 	call	8202cb0 <memset>
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 822e990:	01800504 	movi	r6,20
 822e994:	000b883a 	mov	r5,zero
 822e998:	010209b4 	movhi	r4,2086
 822e99c:	21380804 	addi	r4,r4,-8160
 822e9a0:	8202cb00 	call	8202cb0 <memset>
   for (i = 0; i < (int)bufcount; i++)
 822e9a4:	e03ffd15 	stw	zero,-12(fp)
 822e9a8:	00001506 	br	822ea00 <nptcp_init+0xc0>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 822e9ac:	01000904 	movi	r4,36
 822e9b0:	822dda00 	call	822dda0 <npalloc>
 822e9b4:	e0bfff15 	stw	r2,-4(fp)
      if (!m)  /* malloc error, bail out */
 822e9b8:	e0bfff17 	ldw	r2,-4(fp)
 822e9bc:	1000031e 	bne	r2,zero,822e9cc <nptcp_init+0x8c>
         panic("tcpinit");
 822e9c0:	01020974 	movhi	r4,2085
 822e9c4:	2101f904 	addi	r4,r4,2020
 822e9c8:	822887c0 	call	822887c <panic>
      m->m_type = MT_FREE;
 822e9cc:	e0bfff17 	ldw	r2,-4(fp)
 822e9d0:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 822e9d4:	e0bfff17 	ldw	r2,-4(fp)
 822e9d8:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 822e9dc:	e0bfff17 	ldw	r2,-4(fp)
 822e9e0:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 822e9e4:	e17fff17 	ldw	r5,-4(fp)
 822e9e8:	010209b4 	movhi	r4,2086
 822e9ec:	21380804 	addi	r4,r4,-8160
 822e9f0:	822cbb00 	call	822cbb0 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 822e9f4:	e0bffd17 	ldw	r2,-12(fp)
 822e9f8:	10800044 	addi	r2,r2,1
 822e9fc:	e0bffd15 	stw	r2,-12(fp)
 822ea00:	e0bffe17 	ldw	r2,-8(fp)
 822ea04:	e0fffd17 	ldw	r3,-12(fp)
 822ea08:	18bfe816 	blt	r3,r2,822e9ac <nptcp_init+0x6c>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 822ea0c:	e0fffe17 	ldw	r3,-8(fp)
 822ea10:	008209b4 	movhi	r2,2086
 822ea14:	10b80804 	addi	r2,r2,-8160
 822ea18:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 822ea1c:	82391000 	call	8239100 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 822ea20:	0005883a 	mov	r2,zero
}
 822ea24:	e037883a 	mov	sp,fp
 822ea28:	dfc00117 	ldw	ra,4(sp)
 822ea2c:	df000017 	ldw	fp,0(sp)
 822ea30:	dec00204 	addi	sp,sp,8
 822ea34:	f800283a 	ret

0822ea38 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 822ea38:	defff904 	addi	sp,sp,-28
 822ea3c:	dfc00615 	stw	ra,24(sp)
 822ea40:	df000515 	stw	fp,20(sp)
 822ea44:	df000504 	addi	fp,sp,20
 822ea48:	e13fff15 	stw	r4,-4(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 822ea4c:	e0bfff17 	ldw	r2,-4(fp)
 822ea50:	10800317 	ldw	r2,12(r2)
 822ea54:	e0bffb15 	stw	r2,-20(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 822ea58:	e0bffb17 	ldw	r2,-20(fp)
 822ea5c:	1080008b 	ldhu	r2,2(r2)
 822ea60:	10bfffcc 	andi	r2,r2,65535
 822ea64:	1004d23a 	srli	r2,r2,8
 822ea68:	1007883a 	mov	r3,r2
 822ea6c:	e0bffb17 	ldw	r2,-20(fp)
 822ea70:	1080008b 	ldhu	r2,2(r2)
 822ea74:	10bfffcc 	andi	r2,r2,65535
 822ea78:	1004923a 	slli	r2,r2,8
 822ea7c:	1884b03a 	or	r2,r3,r2
 822ea80:	e0bffc0d 	sth	r2,-16(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 822ea84:	e0bffb17 	ldw	r2,-20(fp)
 822ea88:	10800003 	ldbu	r2,0(r2)
 822ea8c:	10803fcc 	andi	r2,r2,255
 822ea90:	108003cc 	andi	r2,r2,15
 822ea94:	1085883a 	add	r2,r2,r2
 822ea98:	1085883a 	add	r2,r2,r2
 822ea9c:	1007883a 	mov	r3,r2
 822eaa0:	e0bffb17 	ldw	r2,-20(fp)
 822eaa4:	10c5883a 	add	r2,r2,r3
 822eaa8:	e0bffd15 	stw	r2,-12(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 822eaac:	e13ffb17 	ldw	r4,-20(fp)
 822eab0:	82478ec0 	call	82478ec <tcp_cksum>
 822eab4:	1007883a 	mov	r3,r2
 822eab8:	e0bffd17 	ldw	r2,-12(fp)
 822eabc:	1080040b 	ldhu	r2,16(r2)
 822eac0:	18ffffcc 	andi	r3,r3,65535
 822eac4:	10bfffcc 	andi	r2,r2,65535
 822eac8:	18801626 	beq	r3,r2,822eb24 <tcp_rcv+0xec>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 822eacc:	008209b4 	movhi	r2,2086
 822ead0:	10b7f404 	addi	r2,r2,-8240
 822ead4:	10800d17 	ldw	r2,52(r2)
 822ead8:	10c00044 	addi	r3,r2,1
 822eadc:	008209b4 	movhi	r2,2086
 822eae0:	10b7f404 	addi	r2,r2,-8240
 822eae4:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 822eae8:	008209b4 	movhi	r2,2086
 822eaec:	10b82204 	addi	r2,r2,-8056
 822eaf0:	10801c17 	ldw	r2,112(r2)
 822eaf4:	10c00044 	addi	r3,r2,1
 822eaf8:	008209b4 	movhi	r2,2086
 822eafc:	10b82204 	addi	r2,r2,-8056
 822eb00:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822eb04:	01000084 	movi	r4,2
 822eb08:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 822eb0c:	e13fff17 	ldw	r4,-4(fp)
 822eb10:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822eb14:	01000084 	movi	r4,2
 822eb18:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 822eb1c:	00bff804 	movi	r2,-32
 822eb20:	00003406 	br	822ebf4 <tcp_rcv+0x1bc>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 822eb24:	000b883a 	mov	r5,zero
 822eb28:	01000044 	movi	r4,1
 822eb2c:	822dfdc0 	call	822dfdc <m_getnbuf>
 822eb30:	e0bffe15 	stw	r2,-8(fp)
   if (!m_in){
 822eb34:	e0bffe17 	ldw	r2,-8(fp)
 822eb38:	1000081e 	bne	r2,zero,822eb5c <tcp_rcv+0x124>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822eb3c:	01000084 	movi	r4,2
 822eb40:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 822eb44:	e13fff17 	ldw	r4,-4(fp)
 822eb48:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822eb4c:	01000084 	movi	r4,2
 822eb50:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 822eb54:	00bffa84 	movi	r2,-22
 822eb58:	00002606 	br	822ebf4 <tcp_rcv+0x1bc>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 822eb5c:	e0bffb17 	ldw	r2,-20(fp)
 822eb60:	10800003 	ldbu	r2,0(r2)
 822eb64:	10803fcc 	andi	r2,r2,255
 822eb68:	108003cc 	andi	r2,r2,15
 822eb6c:	1085883a 	add	r2,r2,r2
 822eb70:	1085883a 	add	r2,r2,r2
 822eb74:	1007883a 	mov	r3,r2
 822eb78:	e0bffc0b 	ldhu	r2,-16(fp)
 822eb7c:	10c5c83a 	sub	r2,r2,r3
 822eb80:	e0bffc0d 	sth	r2,-16(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 822eb84:	e0bffb17 	ldw	r2,-20(fp)
 822eb88:	e0fffc0b 	ldhu	r3,-16(fp)
 822eb8c:	10c0008d 	sth	r3,2(r2)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 822eb90:	e0bffe17 	ldw	r2,-8(fp)
 822eb94:	e0ffff17 	ldw	r3,-4(fp)
 822eb98:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 822eb9c:	e0bfff17 	ldw	r2,-4(fp)
 822eba0:	10c00317 	ldw	r3,12(r2)
 822eba4:	e0bffe17 	ldw	r2,-8(fp)
 822eba8:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822ebac:	e0bfff17 	ldw	r2,-4(fp)
 822ebb0:	10c00417 	ldw	r3,16(r2)
 822ebb4:	e0bffe17 	ldw	r2,-8(fp)
 822ebb8:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 822ebbc:	e0bfff17 	ldw	r2,-4(fp)
 822ebc0:	10c00117 	ldw	r3,4(r2)
 822ebc4:	e0bffe17 	ldw	r2,-8(fp)
 822ebc8:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 822ebcc:	e0bfff17 	ldw	r2,-4(fp)
 822ebd0:	10c00217 	ldw	r3,8(r2)
 822ebd4:	e0bffe17 	ldw	r2,-8(fp)
 822ebd8:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 822ebdc:	e0bfff17 	ldw	r2,-4(fp)
 822ebe0:	10800617 	ldw	r2,24(r2)
 822ebe4:	100b883a 	mov	r5,r2
 822ebe8:	e13ffe17 	ldw	r4,-8(fp)
 822ebec:	82355b40 	call	82355b4 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 822ebf0:	0005883a 	mov	r2,zero
}
 822ebf4:	e037883a 	mov	sp,fp
 822ebf8:	dfc00117 	ldw	ra,4(sp)
 822ebfc:	df000017 	ldw	fp,0(sp)
 822ec00:	dec00204 	addi	sp,sp,8
 822ec04:	f800283a 	ret

0822ec08 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 822ec08:	defff404 	addi	sp,sp,-48
 822ec0c:	dfc00b15 	stw	ra,44(sp)
 822ec10:	df000a15 	stw	fp,40(sp)
 822ec14:	df000a04 	addi	fp,sp,40
 822ec18:	e13ffe15 	stw	r4,-8(fp)
 822ec1c:	e17fff15 	stw	r5,-4(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 822ec20:	e0bffe17 	ldw	r2,-8(fp)
 822ec24:	10800617 	ldw	r2,24(r2)
 822ec28:	10010a26 	beq	r2,zero,822f054 <ip_output+0x44c>
   {
      m1 = data;
 822ec2c:	e0bffe17 	ldw	r2,-8(fp)
 822ec30:	e0bff615 	stw	r2,-40(fp)
      m2 = data->m_next;
 822ec34:	e0bffe17 	ldw	r2,-8(fp)
 822ec38:	10800617 	ldw	r2,24(r2)
 822ec3c:	e0bff715 	stw	r2,-36(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822ec40:	00003506 	br	822ed18 <ip_output+0x110>
      {
         pkt = m1->pkt;
 822ec44:	e0bff617 	ldw	r2,-40(fp)
 822ec48:	10800117 	ldw	r2,4(r2)
 822ec4c:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822ec50:	e0bffa17 	ldw	r2,-24(fp)
 822ec54:	10c00117 	ldw	r3,4(r2)
 822ec58:	e0bffa17 	ldw	r2,-24(fp)
 822ec5c:	10800217 	ldw	r2,8(r2)
 822ec60:	1885883a 	add	r2,r3,r2
             (m1->m_data + m1->m_len + m2->m_len))
 822ec64:	e0fff617 	ldw	r3,-40(fp)
 822ec68:	19000317 	ldw	r4,12(r3)
 822ec6c:	e0fff617 	ldw	r3,-40(fp)
 822ec70:	19400217 	ldw	r5,8(r3)
 822ec74:	e0fff717 	ldw	r3,-36(fp)
 822ec78:	18c00217 	ldw	r3,8(r3)
 822ec7c:	28c7883a 	add	r3,r5,r3
 822ec80:	20c7883a 	add	r3,r4,r3

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
      {
         pkt = m1->pkt;
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822ec84:	18802b2e 	bgeu	r3,r2,822ed34 <ip_output+0x12c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 822ec88:	e0bff617 	ldw	r2,-40(fp)
 822ec8c:	10c00317 	ldw	r3,12(r2)
 822ec90:	e0bff617 	ldw	r2,-40(fp)
 822ec94:	10800217 	ldw	r2,8(r2)
 822ec98:	1887883a 	add	r3,r3,r2
 822ec9c:	e0bff717 	ldw	r2,-36(fp)
 822eca0:	11000317 	ldw	r4,12(r2)
 822eca4:	e0bff717 	ldw	r2,-36(fp)
 822eca8:	10800217 	ldw	r2,8(r2)
 822ecac:	100d883a 	mov	r6,r2
 822ecb0:	200b883a 	mov	r5,r4
 822ecb4:	1809883a 	mov	r4,r3
 822ecb8:	8202a0c0 	call	8202a0c <memcpy>
            m1->m_len += m2->m_len;
 822ecbc:	e0bff617 	ldw	r2,-40(fp)
 822ecc0:	10c00217 	ldw	r3,8(r2)
 822ecc4:	e0bff717 	ldw	r2,-36(fp)
 822ecc8:	10800217 	ldw	r2,8(r2)
 822eccc:	1887883a 	add	r3,r3,r2
 822ecd0:	e0bff617 	ldw	r2,-40(fp)
 822ecd4:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 822ecd8:	e0bff717 	ldw	r2,-36(fp)
 822ecdc:	10c00617 	ldw	r3,24(r2)
 822ece0:	e0bff617 	ldw	r2,-40(fp)
 822ece4:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 822ece8:	e13ff717 	ldw	r4,-36(fp)
 822ecec:	822e1640 	call	822e164 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 822ecf0:	e0bff617 	ldw	r2,-40(fp)
 822ecf4:	10800617 	ldw	r2,24(r2)
 822ecf8:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oappends++;
 822ecfc:	008209b4 	movhi	r2,2086
 822ed00:	10b82204 	addi	r2,r2,-8056
 822ed04:	10803317 	ldw	r2,204(r2)
 822ed08:	10c00044 	addi	r3,r2,1
 822ed0c:	008209b4 	movhi	r2,2086
 822ed10:	10b82204 	addi	r2,r2,-8056
 822ed14:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822ed18:	e0bff717 	ldw	r2,-36(fp)
 822ed1c:	10005b26 	beq	r2,zero,822ee8c <ip_output+0x284>
 822ed20:	e0bff717 	ldw	r2,-36(fp)
 822ed24:	10800217 	ldw	r2,8(r2)
 822ed28:	108002b0 	cmpltui	r2,r2,10
 822ed2c:	103fc51e 	bne	r2,zero,822ec44 <ip_output+0x3c>
 822ed30:	00005606 	br	822ee8c <ip_output+0x284>
            m_free(m2);    /* free this m2.... */
            m2 = m1->m_next;  /* ...and thread the next one */
            tcpstat.tcps_oappends++;
         }
         else     /* if won't fit, fall to next copy */
            break;
 822ed34:	0001883a 	nop
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822ed38:	00005406 	br	822ee8c <ip_output+0x284>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 822ed3c:	e0bff717 	ldw	r2,-36(fp)
 822ed40:	10800317 	ldw	r2,12(r2)
 822ed44:	1007883a 	mov	r3,r2
 822ed48:	e0bff717 	ldw	r2,-36(fp)
 822ed4c:	10800117 	ldw	r2,4(r2)
 822ed50:	10800117 	ldw	r2,4(r2)
 822ed54:	1885c83a 	sub	r2,r3,r2
 822ed58:	e0bffb15 	stw	r2,-20(fp)
         if (e < MaxLnh)
 822ed5c:	d0a08117 	ldw	r2,-32252(gp)
 822ed60:	e0fffb17 	ldw	r3,-20(fp)
 822ed64:	1880090e 	bge	r3,r2,822ed8c <ip_output+0x184>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 822ed68:	d0a08117 	ldw	r2,-32252(gp)
 822ed6c:	e1bffb17 	ldw	r6,-20(fp)
 822ed70:	100b883a 	mov	r5,r2
 822ed74:	01020974 	movhi	r4,2085
 822ed78:	2101fb04 	addi	r4,r4,2028
 822ed7c:	8202e9c0 	call	8202e9c <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 822ed80:	01020974 	movhi	r4,2085
 822ed84:	21020104 	addi	r4,r4,2052
 822ed88:	822887c0 	call	822887c <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 822ed8c:	e0bff617 	ldw	r2,-40(fp)
 822ed90:	10800217 	ldw	r2,8(r2)
 822ed94:	d0e08117 	ldw	r3,-32252(gp)
 822ed98:	e13ffb17 	ldw	r4,-20(fp)
 822ed9c:	20c7c83a 	sub	r3,r4,r3
 822eda0:	10c03c2e 	bgeu	r2,r3,822ee94 <ip_output+0x28c>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
 822eda4:	e0bff617 	ldw	r2,-40(fp)
 822eda8:	10800217 	ldw	r2,8(r2)
 822edac:	108000cc 	andi	r2,r2,3
 822edb0:	1000381e 	bne	r2,zero,822ee94 <ip_output+0x28c>
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
 822edb4:	e0bff717 	ldw	r2,-36(fp)
 822edb8:	10800317 	ldw	r2,12(r2)
 822edbc:	1007883a 	mov	r3,r2
 822edc0:	e0bff717 	ldw	r2,-36(fp)
 822edc4:	10800117 	ldw	r2,4(r2)
 822edc8:	10800117 	ldw	r2,4(r2)
 822edcc:	1885c83a 	sub	r2,r3,r2
 822edd0:	10800e18 	cmpnei	r2,r2,56
 822edd4:	10002f1e 	bne	r2,zero,822ee94 <ip_output+0x28c>
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 822edd8:	e0bff717 	ldw	r2,-36(fp)
 822eddc:	10c00317 	ldw	r3,12(r2)
 822ede0:	e0bff617 	ldw	r2,-40(fp)
 822ede4:	10800217 	ldw	r2,8(r2)
 822ede8:	0085c83a 	sub	r2,zero,r2
 822edec:	1887883a 	add	r3,r3,r2
 822edf0:	e0bff617 	ldw	r2,-40(fp)
 822edf4:	11000317 	ldw	r4,12(r2)
 822edf8:	e0bff617 	ldw	r2,-40(fp)
 822edfc:	10800217 	ldw	r2,8(r2)
 822ee00:	100d883a 	mov	r6,r2
 822ee04:	200b883a 	mov	r5,r4
 822ee08:	1809883a 	mov	r4,r3
 822ee0c:	8202a0c0 	call	8202a0c <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 822ee10:	e0bff717 	ldw	r2,-36(fp)
 822ee14:	10c00317 	ldw	r3,12(r2)
 822ee18:	e0bff617 	ldw	r2,-40(fp)
 822ee1c:	10800217 	ldw	r2,8(r2)
 822ee20:	0085c83a 	sub	r2,zero,r2
 822ee24:	1887883a 	add	r3,r3,r2
 822ee28:	e0bff717 	ldw	r2,-36(fp)
 822ee2c:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 822ee30:	e0bff717 	ldw	r2,-36(fp)
 822ee34:	10c00217 	ldw	r3,8(r2)
 822ee38:	e0bff617 	ldw	r2,-40(fp)
 822ee3c:	10800217 	ldw	r2,8(r2)
 822ee40:	1887883a 	add	r3,r3,r2
 822ee44:	e0bff717 	ldw	r2,-36(fp)
 822ee48:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 822ee4c:	e13ff617 	ldw	r4,-40(fp)
 822ee50:	822e1640 	call	822e164 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 822ee54:	e0bff717 	ldw	r2,-36(fp)
 822ee58:	e0bff615 	stw	r2,-40(fp)
 822ee5c:	e0bff617 	ldw	r2,-40(fp)
 822ee60:	e0bffe15 	stw	r2,-8(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 822ee64:	e0bff717 	ldw	r2,-36(fp)
 822ee68:	10800617 	ldw	r2,24(r2)
 822ee6c:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oprepends++;
 822ee70:	008209b4 	movhi	r2,2086
 822ee74:	10b82204 	addi	r2,r2,-8056
 822ee78:	10803217 	ldw	r2,200(r2)
 822ee7c:	10c00044 	addi	r3,r2,1
 822ee80:	008209b4 	movhi	r2,2086
 822ee84:	10b82204 	addi	r2,r2,-8056
 822ee88:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822ee8c:	e0bff717 	ldw	r2,-36(fp)
 822ee90:	103faa1e 	bne	r2,zero,822ed3c <ip_output+0x134>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 822ee94:	e0bff717 	ldw	r2,-36(fp)
 822ee98:	10006e26 	beq	r2,zero,822f054 <ip_output+0x44c>
      {
         total = 0;
 822ee9c:	e03ff915 	stw	zero,-28(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822eea0:	e0bff617 	ldw	r2,-40(fp)
 822eea4:	e0bff815 	stw	r2,-32(fp)
 822eea8:	00000806 	br	822eecc <ip_output+0x2c4>
            total += mtmp->m_len;
 822eeac:	e0bff817 	ldw	r2,-32(fp)
 822eeb0:	10c00217 	ldw	r3,8(r2)
 822eeb4:	e0bff917 	ldw	r2,-28(fp)
 822eeb8:	1885883a 	add	r2,r3,r2
 822eebc:	e0bff915 	stw	r2,-28(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822eec0:	e0bff817 	ldw	r2,-32(fp)
 822eec4:	10800617 	ldw	r2,24(r2)
 822eec8:	e0bff815 	stw	r2,-32(fp)
 822eecc:	e0bff817 	ldw	r2,-32(fp)
 822eed0:	103ff61e 	bne	r2,zero,822eeac <ip_output+0x2a4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822eed4:	01000084 	movi	r4,2
 822eed8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 822eedc:	e0bff917 	ldw	r2,-28(fp)
 822eee0:	10800e04 	addi	r2,r2,56
 822eee4:	1009883a 	mov	r4,r2
 822eee8:	822c6200 	call	822c620 <pk_alloc>
 822eeec:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822eef0:	01000084 	movi	r4,2
 822eef4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 822eef8:	e0bffa17 	ldw	r2,-24(fp)
 822eefc:	1000021e 	bne	r2,zero,822ef08 <ip_output+0x300>
            return ENOBUFS;
 822ef00:	00801a44 	movi	r2,105
 822ef04:	0000a706 	br	822f1a4 <ip_output+0x59c>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 822ef08:	e0bffa17 	ldw	r2,-24(fp)
 822ef0c:	10800117 	ldw	r2,4(r2)
 822ef10:	d0e08117 	ldw	r3,-32252(gp)
 822ef14:	10c7883a 	add	r3,r2,r3
 822ef18:	e0bffa17 	ldw	r2,-24(fp)
 822ef1c:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 822ef20:	e0bff617 	ldw	r2,-40(fp)
 822ef24:	e0bff815 	stw	r2,-32(fp)
         while (mtmp)
 822ef28:	00002906 	br	822efd0 <ip_output+0x3c8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 822ef2c:	e0bffa17 	ldw	r2,-24(fp)
 822ef30:	10c00317 	ldw	r3,12(r2)
 822ef34:	e0bff817 	ldw	r2,-32(fp)
 822ef38:	11000317 	ldw	r4,12(r2)
 822ef3c:	e0bff817 	ldw	r2,-32(fp)
 822ef40:	10800217 	ldw	r2,8(r2)
 822ef44:	100d883a 	mov	r6,r2
 822ef48:	200b883a 	mov	r5,r4
 822ef4c:	1809883a 	mov	r4,r3
 822ef50:	8202a0c0 	call	8202a0c <memcpy>
            pkt->nb_prot += mtmp->m_len;
 822ef54:	e0bffa17 	ldw	r2,-24(fp)
 822ef58:	10c00317 	ldw	r3,12(r2)
 822ef5c:	e0bff817 	ldw	r2,-32(fp)
 822ef60:	10800217 	ldw	r2,8(r2)
 822ef64:	1887883a 	add	r3,r3,r2
 822ef68:	e0bffa17 	ldw	r2,-24(fp)
 822ef6c:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 822ef70:	e0bffa17 	ldw	r2,-24(fp)
 822ef74:	10c00417 	ldw	r3,16(r2)
 822ef78:	e0bff817 	ldw	r2,-32(fp)
 822ef7c:	10800217 	ldw	r2,8(r2)
 822ef80:	1887883a 	add	r3,r3,r2
 822ef84:	e0bffa17 	ldw	r2,-24(fp)
 822ef88:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 822ef8c:	e0bff817 	ldw	r2,-32(fp)
 822ef90:	e0bff715 	stw	r2,-36(fp)
            mtmp = mtmp->m_next;
 822ef94:	e0bff817 	ldw	r2,-32(fp)
 822ef98:	10800617 	ldw	r2,24(r2)
 822ef9c:	e0bff815 	stw	r2,-32(fp)
            if (m2 != data)   /* save original head */
 822efa0:	e0fff717 	ldw	r3,-36(fp)
 822efa4:	e0bffe17 	ldw	r2,-8(fp)
 822efa8:	18800226 	beq	r3,r2,822efb4 <ip_output+0x3ac>
               m_free(m2);
 822efac:	e13ff717 	ldw	r4,-36(fp)
 822efb0:	822e1640 	call	822e164 <m_free>
            tcpstat.tcps_ocopies++;
 822efb4:	008209b4 	movhi	r2,2086
 822efb8:	10b82204 	addi	r2,r2,-8056
 822efbc:	10803417 	ldw	r2,208(r2)
 822efc0:	10c00044 	addi	r3,r2,1
 822efc4:	008209b4 	movhi	r2,2086
 822efc8:	10b82204 	addi	r2,r2,-8056
 822efcc:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 822efd0:	e0bff817 	ldw	r2,-32(fp)
 822efd4:	103fd51e 	bne	r2,zero,822ef2c <ip_output+0x324>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 822efd8:	e0bffa17 	ldw	r2,-24(fp)
 822efdc:	10c00317 	ldw	r3,12(r2)
 822efe0:	e0bff917 	ldw	r2,-28(fp)
 822efe4:	0085c83a 	sub	r2,zero,r2
 822efe8:	1887883a 	add	r3,r3,r2
 822efec:	e0bffa17 	ldw	r2,-24(fp)
 822eff0:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822eff4:	01000084 	movi	r4,2
 822eff8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 822effc:	e0bffe17 	ldw	r2,-8(fp)
 822f000:	10800117 	ldw	r2,4(r2)
 822f004:	1009883a 	mov	r4,r2
 822f008:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f00c:	01000084 	movi	r4,2
 822f010:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 822f014:	e0bffe17 	ldw	r2,-8(fp)
 822f018:	e0fffa17 	ldw	r3,-24(fp)
 822f01c:	10c00115 	stw	r3,4(r2)
         data->m_len = pkt->nb_plen;
 822f020:	e0bffa17 	ldw	r2,-24(fp)
 822f024:	10c00417 	ldw	r3,16(r2)
 822f028:	e0bffe17 	ldw	r2,-8(fp)
 822f02c:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 822f030:	e0bffe17 	ldw	r2,-8(fp)
 822f034:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 822f038:	e0bffa17 	ldw	r2,-24(fp)
 822f03c:	10c00317 	ldw	r3,12(r2)
 822f040:	e0bffe17 	ldw	r2,-8(fp)
 822f044:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 822f048:	e0fff917 	ldw	r3,-28(fp)
 822f04c:	e0bffe17 	ldw	r2,-8(fp)
 822f050:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 822f054:	e0bffe17 	ldw	r2,-8(fp)
 822f058:	10c00317 	ldw	r3,12(r2)
 822f05c:	e0bffe17 	ldw	r2,-8(fp)
 822f060:	10800117 	ldw	r2,4(r2)
 822f064:	10800117 	ldw	r2,4(r2)
 822f068:	d1208117 	ldw	r4,-32252(gp)
 822f06c:	1105883a 	add	r2,r2,r4
 822f070:	1880032e 	bgeu	r3,r2,822f080 <ip_output+0x478>
      panic("ip_output: overflow");
 822f074:	01020974 	movhi	r4,2085
 822f078:	21020604 	addi	r4,r4,2072
 822f07c:	822887c0 	call	822887c <panic>

   pkt = data->pkt;
 822f080:	e0bffe17 	ldw	r2,-8(fp)
 822f084:	10800117 	ldw	r2,4(r2)
 822f088:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 822f08c:	e0bfff17 	ldw	r2,-4(fp)
 822f090:	10000326 	beq	r2,zero,822f0a0 <ip_output+0x498>
	   pkt->soxopts = so_optsPack;   /* yup */
 822f094:	e0bffa17 	ldw	r2,-24(fp)
 822f098:	e0ffff17 	ldw	r3,-4(fp)
 822f09c:	10c00c15 	stw	r3,48(r2)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 822f0a0:	e0bffe17 	ldw	r2,-8(fp)
 822f0a4:	10800317 	ldw	r2,12(r2)
 822f0a8:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 822f0ac:	e0bffc17 	ldw	r2,-16(fp)
 822f0b0:	10c00417 	ldw	r3,16(r2)
 822f0b4:	e0bffa17 	ldw	r2,-24(fp)
 822f0b8:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 822f0bc:	e0bffc17 	ldw	r2,-16(fp)
 822f0c0:	00c01144 	movi	r3,69
 822f0c4:	10c00005 	stb	r3,0(r2)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 822f0c8:	e0bffc17 	ldw	r2,-16(fp)
 822f0cc:	1080008b 	ldhu	r2,2(r2)
 822f0d0:	10bfffcc 	andi	r2,r2,65535
 822f0d4:	1004d23a 	srli	r2,r2,8
 822f0d8:	1007883a 	mov	r3,r2
 822f0dc:	e0bffc17 	ldw	r2,-16(fp)
 822f0e0:	1080008b 	ldhu	r2,2(r2)
 822f0e4:	10bfffcc 	andi	r2,r2,65535
 822f0e8:	1004923a 	slli	r2,r2,8
 822f0ec:	1884b03a 	or	r2,r3,r2
 822f0f0:	1007883a 	mov	r3,r2
 822f0f4:	e0bffc17 	ldw	r2,-16(fp)
 822f0f8:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 822f0fc:	e0bffc17 	ldw	r2,-16(fp)
 822f100:	10800003 	ldbu	r2,0(r2)
 822f104:	10803fcc 	andi	r2,r2,255
 822f108:	108003cc 	andi	r2,r2,15
 822f10c:	1085883a 	add	r2,r2,r2
 822f110:	1085883a 	add	r2,r2,r2
 822f114:	1007883a 	mov	r3,r2
 822f118:	e0bffc17 	ldw	r2,-16(fp)
 822f11c:	10c5883a 	add	r2,r2,r3
 822f120:	e0bffd15 	stw	r2,-12(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 822f124:	e13ffc17 	ldw	r4,-16(fp)
 822f128:	82478ec0 	call	82478ec <tcp_cksum>
 822f12c:	1007883a 	mov	r3,r2
 822f130:	e0bffd17 	ldw	r2,-12(fp)
 822f134:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 822f138:	e0bffc17 	ldw	r2,-16(fp)
 822f13c:	10c00504 	addi	r3,r2,20
 822f140:	e0bffa17 	ldw	r2,-24(fp)
 822f144:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 822f148:	e0bffe17 	ldw	r2,-8(fp)
 822f14c:	10800217 	ldw	r2,8(r2)
 822f150:	10fffb04 	addi	r3,r2,-20
 822f154:	e0bffa17 	ldw	r2,-24(fp)
 822f158:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 822f15c:	e17ffa17 	ldw	r5,-24(fp)
 822f160:	01000184 	movi	r4,6
 822f164:	823f5a00 	call	823f5a0 <ip_write>
 822f168:	e0bffb15 	stw	r2,-20(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 822f16c:	e0bffe17 	ldw	r2,-8(fp)
 822f170:	10000115 	stw	zero,4(r2)
   m_freem(data);
 822f174:	e13ffe17 	ldw	r4,-8(fp)
 822f178:	822e26c0 	call	822e26c <m_freem>

   if (e < 0)
 822f17c:	e0bffb17 	ldw	r2,-20(fp)
 822f180:	1000070e 	bge	r2,zero,822f1a0 <ip_output+0x598>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 822f184:	e0bffb17 	ldw	r2,-20(fp)
 822f188:	10bffa98 	cmpnei	r2,r2,-22
 822f18c:	1000021e 	bne	r2,zero,822f198 <ip_output+0x590>
         return 0;
 822f190:	0005883a 	mov	r2,zero
 822f194:	00000306 	br	822f1a4 <ip_output+0x59c>
      return e;
 822f198:	e0bffb17 	ldw	r2,-20(fp)
 822f19c:	00000106 	br	822f1a4 <ip_output+0x59c>
   }
   else
      return 0;
 822f1a0:	0005883a 	mov	r2,zero
}
 822f1a4:	e037883a 	mov	sp,fp
 822f1a8:	dfc00117 	ldw	ra,4(sp)
 822f1ac:	df000017 	ldw	fp,0(sp)
 822f1b0:	dec00204 	addi	sp,sp,8
 822f1b4:	f800283a 	ret

0822f1b8 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 822f1b8:	defffe04 	addi	sp,sp,-8
 822f1bc:	df000115 	stw	fp,4(sp)
 822f1c0:	df000104 	addi	fp,sp,4
 822f1c4:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr == 0xffffffff)
 822f1c8:	e0bfff17 	ldw	r2,-4(fp)
 822f1cc:	10bfffd8 	cmpnei	r2,r2,-1
 822f1d0:	1000021e 	bne	r2,zero,822f1dc <in_broadcast+0x24>
      return TRUE;
 822f1d4:	00800044 	movi	r2,1
 822f1d8:	00000106 	br	822f1e0 <in_broadcast+0x28>

   return FALSE;
 822f1dc:	0005883a 	mov	r2,zero
}
 822f1e0:	e037883a 	mov	sp,fp
 822f1e4:	df000017 	ldw	fp,0(sp)
 822f1e8:	dec00104 	addi	sp,sp,4
 822f1ec:	f800283a 	ret

0822f1f0 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 822f1f0:	defffb04 	addi	sp,sp,-20
 822f1f4:	dfc00415 	stw	ra,16(sp)
 822f1f8:	df000315 	stw	fp,12(sp)
 822f1fc:	df000304 	addi	fp,sp,12
 822f200:	e13ffe15 	stw	r4,-8(fp)
 822f204:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 822f208:	e0bffe17 	ldw	r2,-8(fp)
 822f20c:	10800003 	ldbu	r2,0(r2)
 822f210:	10803fcc 	andi	r2,r2,255
 822f214:	108003cc 	andi	r2,r2,15
 822f218:	1085883a 	add	r2,r2,r2
 822f21c:	1085883a 	add	r2,r2,r2
 822f220:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 822f224:	e0bffd17 	ldw	r2,-12(fp)
 822f228:	10800548 	cmpgei	r2,r2,21
 822f22c:	10002726 	beq	r2,zero,822f2cc <np_stripoptions+0xdc>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 822f230:	e0bffd17 	ldw	r2,-12(fp)
 822f234:	10bffb04 	addi	r2,r2,-20
 822f238:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 822f23c:	e0bffe17 	ldw	r2,-8(fp)
 822f240:	1080008b 	ldhu	r2,2(r2)
 822f244:	e0fffd17 	ldw	r3,-12(fp)
 822f248:	10c5c83a 	sub	r2,r2,r3
 822f24c:	1007883a 	mov	r3,r2
 822f250:	e0bffe17 	ldw	r2,-8(fp)
 822f254:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 822f258:	e0bffe17 	ldw	r2,-8(fp)
 822f25c:	10800003 	ldbu	r2,0(r2)
 822f260:	1007883a 	mov	r3,r2
 822f264:	00bffc04 	movi	r2,-16
 822f268:	1884703a 	and	r2,r3,r2
 822f26c:	10800154 	ori	r2,r2,5
 822f270:	1007883a 	mov	r3,r2
 822f274:	e0bffe17 	ldw	r2,-8(fp)
 822f278:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 822f27c:	e0bffd17 	ldw	r2,-12(fp)
 822f280:	e0fffe17 	ldw	r3,-8(fp)
 822f284:	1885883a 	add	r2,r3,r2
 822f288:	01800504 	movi	r6,20
 822f28c:	e17ffe17 	ldw	r5,-8(fp)
 822f290:	1009883a 	mov	r4,r2
 822f294:	8202b540 	call	8202b54 <memmove>
   m->m_len -= ihlen;
 822f298:	e0bfff17 	ldw	r2,-4(fp)
 822f29c:	10c00217 	ldw	r3,8(r2)
 822f2a0:	e0bffd17 	ldw	r2,-12(fp)
 822f2a4:	1887c83a 	sub	r3,r3,r2
 822f2a8:	e0bfff17 	ldw	r2,-4(fp)
 822f2ac:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 822f2b0:	e0bfff17 	ldw	r2,-4(fp)
 822f2b4:	10c00317 	ldw	r3,12(r2)
 822f2b8:	e0bffd17 	ldw	r2,-12(fp)
 822f2bc:	1887883a 	add	r3,r3,r2
 822f2c0:	e0bfff17 	ldw	r2,-4(fp)
 822f2c4:	10c00315 	stw	r3,12(r2)
 822f2c8:	00000106 	br	822f2d0 <np_stripoptions+0xe0>
   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
      return;
 822f2cc:	0001883a 	nop

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
   m->m_len -= ihlen;
   m->m_data += ihlen;
}
 822f2d0:	e037883a 	mov	sp,fp
 822f2d4:	dfc00117 	ldw	ra,4(sp)
 822f2d8:	df000017 	ldw	fp,0(sp)
 822f2dc:	dec00204 	addi	sp,sp,8
 822f2e0:	f800283a 	ret

0822f2e4 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 822f2e4:	defff304 	addi	sp,sp,-52
 822f2e8:	dfc00c15 	stw	ra,48(sp)
 822f2ec:	df000b15 	stw	fp,44(sp)
 822f2f0:	df000b04 	addi	fp,sp,44
 822f2f4:	e13ffe15 	stw	r4,-8(fp)
 822f2f8:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 822f2fc:	e0bfff17 	ldw	r2,-4(fp)
 822f300:	10800617 	ldw	r2,24(r2)
 822f304:	1006d63a 	srli	r3,r2,24
 822f308:	e0bfff17 	ldw	r2,-4(fp)
 822f30c:	10800617 	ldw	r2,24(r2)
 822f310:	1004d23a 	srli	r2,r2,8
 822f314:	10bfc00c 	andi	r2,r2,65280
 822f318:	1886b03a 	or	r3,r3,r2
 822f31c:	e0bfff17 	ldw	r2,-4(fp)
 822f320:	10800617 	ldw	r2,24(r2)
 822f324:	10bfc00c 	andi	r2,r2,65280
 822f328:	1004923a 	slli	r2,r2,8
 822f32c:	1886b03a 	or	r3,r3,r2
 822f330:	e0bfff17 	ldw	r2,-4(fp)
 822f334:	10800617 	ldw	r2,24(r2)
 822f338:	1004963a 	slli	r2,r2,24
 822f33c:	1884b03a 	or	r2,r3,r2
 822f340:	e0bff815 	stw	r2,-32(fp)
   lhost = htonl(pdp->dip.ip_src);
 822f344:	e0bfff17 	ldw	r2,-4(fp)
 822f348:	10800517 	ldw	r2,20(r2)
 822f34c:	1006d63a 	srli	r3,r2,24
 822f350:	e0bfff17 	ldw	r2,-4(fp)
 822f354:	10800517 	ldw	r2,20(r2)
 822f358:	1004d23a 	srli	r2,r2,8
 822f35c:	10bfc00c 	andi	r2,r2,65280
 822f360:	1886b03a 	or	r3,r3,r2
 822f364:	e0bfff17 	ldw	r2,-4(fp)
 822f368:	10800517 	ldw	r2,20(r2)
 822f36c:	10bfc00c 	andi	r2,r2,65280
 822f370:	1004923a 	slli	r2,r2,8
 822f374:	1886b03a 	or	r3,r3,r2
 822f378:	e0bfff17 	ldw	r2,-4(fp)
 822f37c:	10800517 	ldw	r2,20(r2)
 822f380:	1004963a 	slli	r2,r2,24
 822f384:	1884b03a 	or	r2,r3,r2
 822f388:	e0bff915 	stw	r2,-28(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 822f38c:	e0bfff17 	ldw	r2,-4(fp)
 822f390:	10800704 	addi	r2,r2,28
 822f394:	1080000b 	ldhu	r2,0(r2)
 822f398:	10bfffcc 	andi	r2,r2,65535
 822f39c:	1004d23a 	srli	r2,r2,8
 822f3a0:	1007883a 	mov	r3,r2
 822f3a4:	e0bfff17 	ldw	r2,-4(fp)
 822f3a8:	10800704 	addi	r2,r2,28
 822f3ac:	1080000b 	ldhu	r2,0(r2)
 822f3b0:	10bfffcc 	andi	r2,r2,65535
 822f3b4:	1004923a 	slli	r2,r2,8
 822f3b8:	1884b03a 	or	r2,r3,r2
 822f3bc:	e0bffa0d 	sth	r2,-24(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 822f3c0:	e0bfff17 	ldw	r2,-4(fp)
 822f3c4:	10800784 	addi	r2,r2,30
 822f3c8:	1080000b 	ldhu	r2,0(r2)
 822f3cc:	10bfffcc 	andi	r2,r2,65535
 822f3d0:	1004d23a 	srli	r2,r2,8
 822f3d4:	1007883a 	mov	r3,r2
 822f3d8:	e0bfff17 	ldw	r2,-4(fp)
 822f3dc:	10800784 	addi	r2,r2,30
 822f3e0:	1080000b 	ldhu	r2,0(r2)
 822f3e4:	10bfffcc 	andi	r2,r2,65535
 822f3e8:	1004923a 	slli	r2,r2,8
 822f3ec:	1884b03a 	or	r2,r3,r2
 822f3f0:	e0bffa8d 	sth	r2,-22(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 822f3f4:	e0bfff17 	ldw	r2,-4(fp)
 822f3f8:	10800043 	ldbu	r2,1(r2)
 822f3fc:	10803fcc 	andi	r2,r2,255
 822f400:	1080201c 	xori	r2,r2,128
 822f404:	10bfe004 	addi	r2,r2,-128
 822f408:	10800118 	cmpnei	r2,r2,4
 822f40c:	10006e26 	beq	r2,zero,822f5c8 <so_icmpdu+0x2e4>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 822f410:	e0bfff17 	ldw	r2,-4(fp)
 822f414:	10800443 	ldbu	r2,17(r2)
 822f418:	10803fcc 	andi	r2,r2,255
 822f41c:	10800198 	cmpnei	r2,r2,6
 822f420:	1000221e 	bne	r2,zero,822f4ac <so_icmpdu+0x1c8>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 822f424:	e13ffa8b 	ldhu	r4,-22(fp)
 822f428:	e0bffa0b 	ldhu	r2,-24(fp)
 822f42c:	00c00044 	movi	r3,1
 822f430:	d8c00115 	stw	r3,4(sp)
 822f434:	d8800015 	stw	r2,0(sp)
 822f438:	e1fff917 	ldw	r7,-28(fp)
 822f43c:	200d883a 	mov	r6,r4
 822f440:	e17ff817 	ldw	r5,-32(fp)
 822f444:	010209b4 	movhi	r4,2086
 822f448:	21381704 	addi	r4,r4,-8100
 822f44c:	82480c00 	call	82480c0 <in_pcblookup>
 822f450:	e0bffb15 	stw	r2,-20(fp)
      if (inp == 0)
 822f454:	e0bffb17 	ldw	r2,-20(fp)
 822f458:	10005d26 	beq	r2,zero,822f5d0 <so_icmpdu+0x2ec>
         goto done;
      so = inp->inp_socket;
 822f45c:	e0bffb17 	ldw	r2,-20(fp)
 822f460:	10800817 	ldw	r2,32(r2)
 822f464:	e0bffc15 	stw	r2,-16(fp)
      if (so == 0)
 822f468:	e0bffc17 	ldw	r2,-16(fp)
 822f46c:	10005a26 	beq	r2,zero,822f5d8 <so_icmpdu+0x2f4>
         goto done;
      tp = intotcpcb(inp);
 822f470:	e0bffb17 	ldw	r2,-20(fp)
 822f474:	10800917 	ldw	r2,36(r2)
 822f478:	e0bffd15 	stw	r2,-12(fp)
      if (tp)
 822f47c:	e0bffd17 	ldw	r2,-12(fp)
 822f480:	10000626 	beq	r2,zero,822f49c <so_icmpdu+0x1b8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 822f484:	e0bffd17 	ldw	r2,-12(fp)
 822f488:	10800217 	ldw	r2,8(r2)
 822f48c:	10800088 	cmpgei	r2,r2,2
 822f490:	10005326 	beq	r2,zero,822f5e0 <so_icmpdu+0x2fc>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 822f494:	e13ffd17 	ldw	r4,-12(fp)
 822f498:	82398140 	call	8239814 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f49c:	e0bffc17 	ldw	r2,-16(fp)
 822f4a0:	00c01bc4 	movi	r3,111
 822f4a4:	10c00615 	stw	r3,24(r2)
 822f4a8:	00005406 	br	822f5fc <so_icmpdu+0x318>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 822f4ac:	e0bfff17 	ldw	r2,-4(fp)
 822f4b0:	10800443 	ldbu	r2,17(r2)
 822f4b4:	10803fcc 	andi	r2,r2,255
 822f4b8:	10800458 	cmpnei	r2,r2,17
 822f4bc:	10004a1e 	bne	r2,zero,822f5e8 <so_icmpdu+0x304>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f4c0:	d0a09c17 	ldw	r2,-32144(gp)
 822f4c4:	e0bff715 	stw	r2,-36(fp)
 822f4c8:	00002106 	br	822f550 <so_icmpdu+0x26c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f4cc:	e0bff717 	ldw	r2,-36(fp)
 822f4d0:	1080020b 	ldhu	r2,8(r2)
 822f4d4:	10ffffcc 	andi	r3,r2,65535
 822f4d8:	e0bffa8b 	ldhu	r2,-22(fp)
 822f4dc:	18800426 	beq	r3,r2,822f4f0 <so_icmpdu+0x20c>
 822f4e0:	e0bff717 	ldw	r2,-36(fp)
 822f4e4:	1080020b 	ldhu	r2,8(r2)
 822f4e8:	10bfffcc 	andi	r2,r2,65535
 822f4ec:	1000151e 	bne	r2,zero,822f544 <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
 822f4f0:	e0bff717 	ldw	r2,-36(fp)
 822f4f4:	10c00417 	ldw	r3,16(r2)
 822f4f8:	e0bff817 	ldw	r2,-32(fp)
 822f4fc:	1008d63a 	srli	r4,r2,24
 822f500:	e0bff817 	ldw	r2,-32(fp)
 822f504:	1004d23a 	srli	r2,r2,8
 822f508:	10bfc00c 	andi	r2,r2,65280
 822f50c:	2088b03a 	or	r4,r4,r2
 822f510:	e0bff817 	ldw	r2,-32(fp)
 822f514:	10bfc00c 	andi	r2,r2,65280
 822f518:	1004923a 	slli	r2,r2,8
 822f51c:	2088b03a 	or	r4,r4,r2
 822f520:	e0bff817 	ldw	r2,-32(fp)
 822f524:	1004963a 	slli	r2,r2,24
 822f528:	2084b03a 	or	r2,r4,r2
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f52c:	1880051e 	bne	r3,r2,822f544 <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
 822f530:	e0bff717 	ldw	r2,-36(fp)
 822f534:	1080018b 	ldhu	r2,6(r2)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
 822f538:	10ffffcc 	andi	r3,r2,65535
 822f53c:	e0bffa0b 	ldhu	r2,-24(fp)
 822f540:	18800626 	beq	r3,r2,822f55c <so_icmpdu+0x278>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f544:	e0bff717 	ldw	r2,-36(fp)
 822f548:	10800017 	ldw	r2,0(r2)
 822f54c:	e0bff715 	stw	r2,-36(fp)
 822f550:	e0bff717 	ldw	r2,-36(fp)
 822f554:	103fdd1e 	bne	r2,zero,822f4cc <so_icmpdu+0x1e8>
 822f558:	00000106 	br	822f560 <so_icmpdu+0x27c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
 822f55c:	0001883a 	nop
         }
      if (!tmp) 
 822f560:	e0bff717 	ldw	r2,-36(fp)
 822f564:	10002226 	beq	r2,zero,822f5f0 <so_icmpdu+0x30c>
         goto done;
      so = (struct socket *)tmp->u_data;
 822f568:	e0bff717 	ldw	r2,-36(fp)
 822f56c:	10800617 	ldw	r2,24(r2)
 822f570:	e0bffc15 	stw	r2,-16(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 822f574:	e0bffc17 	ldw	r2,-16(fp)
 822f578:	10800983 	ldbu	r2,38(r2)
 822f57c:	10803fcc 	andi	r2,r2,255
 822f580:	1080201c 	xori	r2,r2,128
 822f584:	10bfe004 	addi	r2,r2,-128
 822f588:	108000a0 	cmpeqi	r2,r2,2
 822f58c:	10001a26 	beq	r2,zero,822f5f8 <so_icmpdu+0x314>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f590:	e0bffc17 	ldw	r2,-16(fp)
 822f594:	00c01bc4 	movi	r3,111
 822f598:	10c00615 	stw	r3,24(r2)
      /* do a select() notify on socket here */
      sorwakeup(so);
 822f59c:	e0bffc17 	ldw	r2,-16(fp)
 822f5a0:	10800a04 	addi	r2,r2,40
 822f5a4:	100b883a 	mov	r5,r2
 822f5a8:	e13ffc17 	ldw	r4,-16(fp)
 822f5ac:	8233e780 	call	8233e78 <sbwakeup>
      sowwakeup(so);
 822f5b0:	e0bffc17 	ldw	r2,-16(fp)
 822f5b4:	10801204 	addi	r2,r2,72
 822f5b8:	100b883a 	mov	r5,r2
 822f5bc:	e13ffc17 	ldw	r4,-16(fp)
 822f5c0:	8233e780 	call	8233e78 <sbwakeup>
 822f5c4:	00000d06 	br	822f5fc <so_icmpdu+0x318>
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
    {
       goto done;
 822f5c8:	0001883a 	nop
 822f5cc:	00000b06 	br	822f5fc <so_icmpdu+0x318>
   if (pdp->dip.ip_prot == TCPTP)
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
      if (inp == 0)
         goto done;
 822f5d0:	0001883a 	nop
 822f5d4:	00000906 	br	822f5fc <so_icmpdu+0x318>
      so = inp->inp_socket;
      if (so == 0)
         goto done;
 822f5d8:	0001883a 	nop
 822f5dc:	00000706 	br	822f5fc <so_icmpdu+0x318>
      tp = intotcpcb(inp);
      if (tp)
      {
         if (tp->t_state <= TCPS_LISTEN)
         {
            goto done;
 822f5e0:	0001883a 	nop
 822f5e4:	00000506 	br	822f5fc <so_icmpdu+0x318>
      sorwakeup(so);
      sowwakeup(so);
   }
#endif   /* UDP_SOCKETS */
   else
      goto done;
 822f5e8:	0001883a 	nop
 822f5ec:	00000306 	br	822f5fc <so_icmpdu+0x318>
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
         goto done;
 822f5f0:	0001883a 	nop
 822f5f4:	00000106 	br	822f5fc <so_icmpdu+0x318>
      so = (struct socket *)tmp->u_data;
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
         goto done;
 822f5f8:	0001883a 	nop
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 822f5fc:	01000084 	movi	r4,2
 822f600:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 822f604:	e13ffe17 	ldw	r4,-8(fp)
 822f608:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f60c:	01000084 	movi	r4,2
 822f610:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return;
 822f614:	0001883a 	nop
}
 822f618:	e037883a 	mov	sp,fp
 822f61c:	dfc00117 	ldw	ra,4(sp)
 822f620:	df000017 	ldw	fp,0(sp)
 822f624:	dec00204 	addi	sp,sp,8
 822f628:	f800283a 	ret

0822f62c <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 822f62c:	defffe04 	addi	sp,sp,-8
 822f630:	dfc00115 	stw	ra,4(sp)
 822f634:	df000015 	stw	fp,0(sp)
 822f638:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 822f63c:	d0a0ad17 	ldw	r2,-32076(gp)
 822f640:	1000121e 	bne	r2,zero,822f68c <tcp_tick+0x60>
      return;
   in_tcptick++;
 822f644:	d0a0ad17 	ldw	r2,-32076(gp)
 822f648:	10800044 	addi	r2,r2,1
 822f64c:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 822f650:	0009883a 	mov	r4,zero
 822f654:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 822f658:	d0e0a817 	ldw	r3,-32096(gp)
 822f65c:	d0a0ac17 	ldw	r2,-32080(gp)
 822f660:	18800436 	bltu	r3,r2,822f674 <tcp_tick+0x48>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 822f664:	8239a3c0 	call	8239a3c <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 822f668:	d0a0a817 	ldw	r2,-32096(gp)
 822f66c:	10800c84 	addi	r2,r2,50
 822f670:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 822f674:	0009883a 	mov	r4,zero
 822f678:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 822f67c:	d0a0ad17 	ldw	r2,-32076(gp)
 822f680:	10bfffc4 	addi	r2,r2,-1
 822f684:	d0a0ad15 	stw	r2,-32076(gp)
 822f688:	00000106 	br	822f690 <tcp_tick+0x64>
void
tcp_tick()
{
   /* guard against re-entry */
   if (in_tcptick)
      return;
 822f68c:	0001883a 	nop
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);

   in_tcptick--;
}
 822f690:	e037883a 	mov	sp,fp
 822f694:	dfc00117 	ldw	ra,4(sp)
 822f698:	df000017 	ldw	fp,0(sp)
 822f69c:	dec00204 	addi	sp,sp,8
 822f6a0:	f800283a 	ret

0822f6a4 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 822f6a4:	defffd04 	addi	sp,sp,-12
 822f6a8:	df000215 	stw	fp,8(sp)
 822f6ac:	df000204 	addi	fp,sp,8
 822f6b0:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822f6b4:	d0a0cf17 	ldw	r2,-31940(gp)
 822f6b8:	e0bffe15 	stw	r2,-8(fp)
 822f6bc:	00000906 	br	822f6e4 <rawip_lookup+0x40>
      if (tmp->ipr_data == (void*)so)
 822f6c0:	e0bffe17 	ldw	r2,-8(fp)
 822f6c4:	10c00417 	ldw	r3,16(r2)
 822f6c8:	e0bfff17 	ldw	r2,-4(fp)
 822f6cc:	1880021e 	bne	r3,r2,822f6d8 <rawip_lookup+0x34>
      return (tmp);
 822f6d0:	e0bffe17 	ldw	r2,-8(fp)
 822f6d4:	00000606 	br	822f6f0 <rawip_lookup+0x4c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822f6d8:	e0bffe17 	ldw	r2,-8(fp)
 822f6dc:	10800017 	ldw	r2,0(r2)
 822f6e0:	e0bffe15 	stw	r2,-8(fp)
 822f6e4:	e0bffe17 	ldw	r2,-8(fp)
 822f6e8:	103ff51e 	bne	r2,zero,822f6c0 <rawip_lookup+0x1c>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 822f6ec:	0005883a 	mov	r2,zero
}
 822f6f0:	e037883a 	mov	sp,fp
 822f6f4:	df000017 	ldw	fp,0(sp)
 822f6f8:	dec00104 	addi	sp,sp,4
 822f6fc:	f800283a 	ret

0822f700 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 822f700:	defff504 	addi	sp,sp,-44
 822f704:	dfc00a15 	stw	ra,40(sp)
 822f708:	df000915 	stw	fp,36(sp)
 822f70c:	df000904 	addi	fp,sp,36
 822f710:	e13ffe15 	stw	r4,-8(fp)
 822f714:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 822f718:	e0bfff17 	ldw	r2,-4(fp)
 822f71c:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 822f720:	0009883a 	mov	r4,zero
 822f724:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 822f728:	e0bff717 	ldw	r2,-36(fp)
 822f72c:	10c00a17 	ldw	r3,40(r2)
 822f730:	e0bffe17 	ldw	r2,-8(fp)
 822f734:	10800417 	ldw	r2,16(r2)
 822f738:	1887883a 	add	r3,r3,r2
 822f73c:	e0bff717 	ldw	r2,-36(fp)
 822f740:	10800b17 	ldw	r2,44(r2)
 822f744:	18800436 	bltu	r3,r2,822f758 <rawip_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f748:	0009883a 	mov	r4,zero
 822f74c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f750:	00801a44 	movi	r2,105
 822f754:	00005706 	br	822f8b4 <rawip_soinput+0x1b4>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 822f758:	000b883a 	mov	r5,zero
 822f75c:	01000044 	movi	r4,1
 822f760:	822dfdc0 	call	822dfdc <m_getnbuf>
 822f764:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 822f768:	e0bff817 	ldw	r2,-32(fp)
 822f76c:	1000041e 	bne	r2,zero,822f780 <rawip_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f770:	0009883a 	mov	r4,zero
 822f774:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f778:	00801a44 	movi	r2,105
 822f77c:	00004d06 	br	822f8b4 <rawip_soinput+0x1b4>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 822f780:	e0bff817 	ldw	r2,-32(fp)
 822f784:	e0fffe17 	ldw	r3,-8(fp)
 822f788:	10c00115 	stw	r3,4(r2)
   m_in->m_base = pkt->nb_buff;
 822f78c:	e0bffe17 	ldw	r2,-8(fp)
 822f790:	10c00117 	ldw	r3,4(r2)
 822f794:	e0bff817 	ldw	r2,-32(fp)
 822f798:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 822f79c:	e0bffe17 	ldw	r2,-8(fp)
 822f7a0:	10c00217 	ldw	r3,8(r2)
 822f7a4:	e0bff817 	ldw	r2,-32(fp)
 822f7a8:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 822f7ac:	e0bffe17 	ldw	r2,-8(fp)
 822f7b0:	10c00317 	ldw	r3,12(r2)
 822f7b4:	e0bff817 	ldw	r2,-32(fp)
 822f7b8:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822f7bc:	e0bffe17 	ldw	r2,-8(fp)
 822f7c0:	10c00417 	ldw	r3,16(r2)
 822f7c4:	e0bff817 	ldw	r2,-32(fp)
 822f7c8:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 822f7cc:	e0bff717 	ldw	r2,-36(fp)
 822f7d0:	10800417 	ldw	r2,16(r2)
 822f7d4:	1088000c 	andi	r2,r2,8192
 822f7d8:	1000141e 	bne	r2,zero,822f82c <rawip_soinput+0x12c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 822f7dc:	e0bffe17 	ldw	r2,-8(fp)
 822f7e0:	10800317 	ldw	r2,12(r2)
 822f7e4:	10800003 	ldbu	r2,0(r2)
 822f7e8:	10803fcc 	andi	r2,r2,255
 822f7ec:	108003cc 	andi	r2,r2,15
 822f7f0:	1085883a 	add	r2,r2,r2
 822f7f4:	1085883a 	add	r2,r2,r2
   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
   {
      unsigned int ihl = 
 822f7f8:	e0bff915 	stw	r2,-28(fp)
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
      m_in->m_data += ihl;
 822f7fc:	e0bff817 	ldw	r2,-32(fp)
 822f800:	10c00317 	ldw	r3,12(r2)
 822f804:	e0bff917 	ldw	r2,-28(fp)
 822f808:	1887883a 	add	r3,r3,r2
 822f80c:	e0bff817 	ldw	r2,-32(fp)
 822f810:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 822f814:	e0bff817 	ldw	r2,-32(fp)
 822f818:	10c00217 	ldw	r3,8(r2)
 822f81c:	e0bff917 	ldw	r2,-28(fp)
 822f820:	1887c83a 	sub	r3,r3,r2
 822f824:	e0bff817 	ldw	r2,-32(fp)
 822f828:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 822f82c:	e0bffe17 	ldw	r2,-8(fp)
 822f830:	10800717 	ldw	r2,28(r2)
 822f834:	e0bffb15 	stw	r2,-20(fp)
   sin.sin_port = 0;
 822f838:	e03ffa8d 	sth	zero,-22(fp)
   sin.sin_family = AF_INET;
 822f83c:	00800084 	movi	r2,2
 822f840:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 822f844:	e0bff717 	ldw	r2,-36(fp)
 822f848:	10800a04 	addi	r2,r2,40
 822f84c:	e0fffa04 	addi	r3,fp,-24
 822f850:	e1bff817 	ldw	r6,-32(fp)
 822f854:	180b883a 	mov	r5,r3
 822f858:	1009883a 	mov	r4,r2
 822f85c:	82341a00 	call	82341a0 <sbappendaddr>
 822f860:	1000081e 	bne	r2,zero,822f884 <rawip_soinput+0x184>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 822f864:	e0bff817 	ldw	r2,-32(fp)
 822f868:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 822f86c:	e13ff817 	ldw	r4,-32(fp)
 822f870:	822e1640 	call	822e164 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f874:	0009883a 	mov	r4,zero
 822f878:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f87c:	00801a44 	movi	r2,105
 822f880:	00000c06 	br	822f8b4 <rawip_soinput+0x1b4>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 822f884:	e0bff717 	ldw	r2,-36(fp)
 822f888:	10800a04 	addi	r2,r2,40
 822f88c:	1009883a 	mov	r4,r2
 822f890:	82292dc0 	call	82292dc <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 822f894:	e0bff717 	ldw	r2,-36(fp)
 822f898:	10800a04 	addi	r2,r2,40
 822f89c:	100b883a 	mov	r5,r2
 822f8a0:	e13ff717 	ldw	r4,-36(fp)
 822f8a4:	8233e780 	call	8233e78 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 822f8a8:	0009883a 	mov	r4,zero
 822f8ac:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return 0;
 822f8b0:	0005883a 	mov	r2,zero
}
 822f8b4:	e037883a 	mov	sp,fp
 822f8b8:	dfc00117 	ldw	ra,4(sp)
 822f8bc:	df000017 	ldw	fp,0(sp)
 822f8c0:	dec00204 	addi	sp,sp,8
 822f8c4:	f800283a 	ret

0822f8c8 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 822f8c8:	deffef04 	addi	sp,sp,-68
 822f8cc:	dfc01015 	stw	ra,64(sp)
 822f8d0:	df000f15 	stw	fp,60(sp)
 822f8d4:	dc000e15 	stw	r16,56(sp)
 822f8d8:	df000f04 	addi	fp,sp,60
 822f8dc:	e13ffc15 	stw	r4,-16(fp)
 822f8e0:	e17ffd15 	stw	r5,-12(fp)
 822f8e4:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 822f8e8:	e0bffc17 	ldw	r2,-16(fp)
 822f8ec:	10800717 	ldw	r2,28(r2)
 822f8f0:	e0bff615 	stw	r2,-40(fp)

   switch (req) 
 822f8f4:	e0bff617 	ldw	r2,-40(fp)
 822f8f8:	10800468 	cmpgeui	r2,r2,17
 822f8fc:	1001be1e 	bne	r2,zero,822fff8 <rawip_usrreq+0x730>
 822f900:	e0bff617 	ldw	r2,-40(fp)
 822f904:	100690ba 	slli	r3,r2,2
 822f908:	008208f4 	movhi	r2,2083
 822f90c:	10be4704 	addi	r2,r2,-1764
 822f910:	1885883a 	add	r2,r3,r2
 822f914:	10800017 	ldw	r2,0(r2)
 822f918:	1000683a 	jmp	r2
 822f91c:	0822f960 	cmpeqi	zero,at,-29723
 822f920:	0822f9e8 	cmpgeui	zero,at,35815
 822f924:	0822fa24 	muli	zero,at,-29720
 822f928:	0822fff8 	rdprs	zero,at,-29697
 822f92c:	0822fa24 	muli	zero,at,-29720
 822f930:	0822fff8 	rdprs	zero,at,-29697
 822f934:	0822ffec 	andhi	zero,at,35839
 822f938:	0822fff8 	rdprs	zero,at,-29697
 822f93c:	0822ffec 	andhi	zero,at,35839
 822f940:	0822fbb0 	cmpltui	zero,at,35822
 822f944:	0822fff8 	rdprs	zero,at,-29697
 822f948:	0822fff8 	rdprs	zero,at,-29697
 822f94c:	0822fff8 	rdprs	zero,at,-29697
 822f950:	0822fff8 	rdprs	zero,at,-29697
 822f954:	0822fff8 	rdprs	zero,at,-29697
 822f958:	0822ff58 	cmpnei	zero,at,-29699
 822f95c:	0822ff58 	cmpnei	zero,at,-29699
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 822f960:	e0bffc17 	ldw	r2,-16(fp)
 822f964:	10800417 	ldw	r2,16(r2)
 822f968:	1088000c 	andi	r2,r2,8192
 822f96c:	1009883a 	mov	r4,r2
 822f970:	8243de80 	call	8243de8 <ip_raw_maxalloc>

   switch (req) 
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 822f974:	1007883a 	mov	r3,r2
 822f978:	e0bffc17 	ldw	r2,-16(fp)
 822f97c:	10c01315 	stw	r3,76(r2)
 822f980:	e0bffc17 	ldw	r2,-16(fp)
 822f984:	10c01317 	ldw	r3,76(r2)
 822f988:	e0bffc17 	ldw	r2,-16(fp)
 822f98c:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 822f990:	e0bffe17 	ldw	r2,-8(fp)
 822f994:	e0bff705 	stb	r2,-36(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f998:	0009883a 	mov	r4,zero
 822f99c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 822f9a0:	e0fff703 	ldbu	r3,-36(fp)
 822f9a4:	e0bffc17 	ldw	r2,-16(fp)
 822f9a8:	d8800015 	stw	r2,0(sp)
 822f9ac:	01c208f4 	movhi	r7,2083
 822f9b0:	39fdc004 	addi	r7,r7,-2304
 822f9b4:	000d883a 	mov	r6,zero
 822f9b8:	000b883a 	mov	r5,zero
 822f9bc:	1809883a 	mov	r4,r3
 822f9c0:	82439340 	call	8243934 <ip_raw_open>
 822f9c4:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 822f9c8:	0009883a 	mov	r4,zero
 822f9cc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      if (!ep)
 822f9d0:	e0bff817 	ldw	r2,-32(fp)
 822f9d4:	1000021e 	bne	r2,zero,822f9e0 <rawip_usrreq+0x118>
         return(EINVAL);
 822f9d8:	00800584 	movi	r2,22
 822f9dc:	00018706 	br	822fffc <rawip_usrreq+0x734>
      return 0;
 822f9e0:	0005883a 	mov	r2,zero
 822f9e4:	00018506 	br	822fffc <rawip_usrreq+0x734>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 822f9e8:	e13ffc17 	ldw	r4,-16(fp)
 822f9ec:	822f6a40 	call	822f6a4 <rawip_lookup>
 822f9f0:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822f9f4:	e0bff817 	ldw	r2,-32(fp)
 822f9f8:	1000021e 	bne	r2,zero,822fa04 <rawip_usrreq+0x13c>
         return(EINVAL);
 822f9fc:	00800584 	movi	r2,22
 822fa00:	00017e06 	br	822fffc <rawip_usrreq+0x734>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fa04:	0009883a 	mov	r4,zero
 822fa08:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 822fa0c:	e13ff817 	ldw	r4,-32(fp)
 822fa10:	8243a0c0 	call	8243a0c <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 822fa14:	0009883a 	mov	r4,zero
 822fa18:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      return 0;
 822fa1c:	0005883a 	mov	r2,zero
 822fa20:	00017606 	br	822fffc <rawip_usrreq+0x734>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 822fa24:	e0bffe17 	ldw	r2,-8(fp)
 822fa28:	1000021e 	bne	r2,zero,822fa34 <rawip_usrreq+0x16c>
         return(EINVAL);
 822fa2c:	00800584 	movi	r2,22
 822fa30:	00017206 	br	822fffc <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 822fa34:	e0bffe17 	ldw	r2,-8(fp)
 822fa38:	10800317 	ldw	r2,12(r2)
 822fa3c:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 822fa40:	e0bff917 	ldw	r2,-28(fp)
 822fa44:	1000021e 	bne	r2,zero,822fa50 <rawip_usrreq+0x188>
         return(EINVAL);
 822fa48:	00800584 	movi	r2,22
 822fa4c:	00016b06 	br	822fffc <rawip_usrreq+0x734>
      if (nam->m_len != sizeof (*sin))
 822fa50:	e0bffe17 	ldw	r2,-8(fp)
 822fa54:	10800217 	ldw	r2,8(r2)
 822fa58:	10800420 	cmpeqi	r2,r2,16
 822fa5c:	1000021e 	bne	r2,zero,822fa68 <rawip_usrreq+0x1a0>
         return(EINVAL);
 822fa60:	00800584 	movi	r2,22
 822fa64:	00016506 	br	822fffc <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 822fa68:	e13ffc17 	ldw	r4,-16(fp)
 822fa6c:	822f6a40 	call	822f6a4 <rawip_lookup>
 822fa70:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fa74:	e0bff817 	ldw	r2,-32(fp)
 822fa78:	1000021e 	bne	r2,zero,822fa84 <rawip_usrreq+0x1bc>
         return(EINVAL);
 822fa7c:	00800584 	movi	r2,22
 822fa80:	00015e06 	br	822fffc <rawip_usrreq+0x734>
      if (req == PRU_BIND)
 822fa84:	e0bff617 	ldw	r2,-40(fp)
 822fa88:	10800098 	cmpnei	r2,r2,2
 822fa8c:	1000201e 	bne	r2,zero,822fb10 <rawip_usrreq+0x248>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fa90:	e0bff917 	ldw	r2,-28(fp)
 822fa94:	10800117 	ldw	r2,4(r2)
 822fa98:	1000021e 	bne	r2,zero,822faa4 <rawip_usrreq+0x1dc>
         {
            lhost = 0L;
 822fa9c:	e03ff415 	stw	zero,-48(fp)
 822faa0:	00001706 	br	822fb00 <rawip_usrreq+0x238>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 822faa4:	e0bff917 	ldw	r2,-28(fp)
 822faa8:	10800117 	ldw	r2,4(r2)
 822faac:	e0bff415 	stw	r2,-48(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fab0:	008209b4 	movhi	r2,2086
 822fab4:	10b8f304 	addi	r2,r2,-7220
 822fab8:	10800017 	ldw	r2,0(r2)
 822fabc:	e0bff515 	stw	r2,-44(fp)
 822fac0:	00000706 	br	822fae0 <rawip_usrreq+0x218>
               if (ifp->n_ipaddr == lhost)
 822fac4:	e0bff517 	ldw	r2,-44(fp)
 822fac8:	10c00a17 	ldw	r3,40(r2)
 822facc:	e0bff417 	ldw	r2,-48(fp)
 822fad0:	18800626 	beq	r3,r2,822faec <rawip_usrreq+0x224>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fad4:	e0bff517 	ldw	r2,-44(fp)
 822fad8:	10800017 	ldw	r2,0(r2)
 822fadc:	e0bff515 	stw	r2,-44(fp)
 822fae0:	e0bff517 	ldw	r2,-44(fp)
 822fae4:	103ff71e 	bne	r2,zero,822fac4 <rawip_usrreq+0x1fc>
 822fae8:	00000106 	br	822faf0 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
 822faec:	0001883a 	nop
            if (ifp == NULL)
 822faf0:	e0bff517 	ldw	r2,-44(fp)
 822faf4:	1000021e 	bne	r2,zero,822fb00 <rawip_usrreq+0x238>
               return(EADDRNOTAVAIL);
 822faf8:	00801f44 	movi	r2,125
 822fafc:	00013f06 	br	822fffc <rawip_usrreq+0x734>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 822fb00:	e0bff817 	ldw	r2,-32(fp)
 822fb04:	e0fff417 	ldw	r3,-48(fp)
 822fb08:	10c00115 	stw	r3,4(r2)
 822fb0c:	00002606 	br	822fba8 <rawip_usrreq+0x2e0>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fb10:	e0bff917 	ldw	r2,-28(fp)
 822fb14:	10800117 	ldw	r2,4(r2)
 822fb18:	1000021e 	bne	r2,zero,822fb24 <rawip_usrreq+0x25c>
            fhost = 0L;
 822fb1c:	e03ff315 	stw	zero,-52(fp)
 822fb20:	00000306 	br	822fb30 <rawip_usrreq+0x268>
         else
            fhost = sin->sin_addr.s_addr;
 822fb24:	e0bff917 	ldw	r2,-28(fp)
 822fb28:	10800117 	ldw	r2,4(r2)
 822fb2c:	e0bff315 	stw	r2,-52(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 822fb30:	e0bff817 	ldw	r2,-32(fp)
 822fb34:	e0fff317 	ldw	r3,-52(fp)
 822fb38:	10c00215 	stw	r3,8(r2)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 822fb3c:	e0bff317 	ldw	r2,-52(fp)
 822fb40:	10000e26 	beq	r2,zero,822fb7c <rawip_usrreq+0x2b4>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 822fb44:	e0bffc17 	ldw	r2,-16(fp)
 822fb48:	10c0088b 	ldhu	r3,34(r2)
 822fb4c:	00bffcc4 	movi	r2,-13
 822fb50:	1884703a 	and	r2,r3,r2
 822fb54:	1007883a 	mov	r3,r2
 822fb58:	e0bffc17 	ldw	r2,-16(fp)
 822fb5c:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 822fb60:	e0bffc17 	ldw	r2,-16(fp)
 822fb64:	1080088b 	ldhu	r2,34(r2)
 822fb68:	10800094 	ori	r2,r2,2
 822fb6c:	1007883a 	mov	r3,r2
 822fb70:	e0bffc17 	ldw	r2,-16(fp)
 822fb74:	10c0088d 	sth	r3,34(r2)
 822fb78:	00000706 	br	822fb98 <rawip_usrreq+0x2d0>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 822fb7c:	e0bffc17 	ldw	r2,-16(fp)
 822fb80:	10c0088b 	ldhu	r3,34(r2)
 822fb84:	00bfff44 	movi	r2,-3
 822fb88:	1884703a 	and	r2,r3,r2
 822fb8c:	1007883a 	mov	r3,r2
 822fb90:	e0bffc17 	ldw	r2,-16(fp)
 822fb94:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 822fb98:	e0bffc17 	ldw	r2,-16(fp)
 822fb9c:	10800a04 	addi	r2,r2,40
 822fba0:	1009883a 	mov	r4,r2
 822fba4:	823455c0 	call	823455c <sbflush>
      }
      return 0;
 822fba8:	0005883a 	mov	r2,zero
 822fbac:	00011306 	br	822fffc <rawip_usrreq+0x734>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 822fbb0:	e0bffd17 	ldw	r2,-12(fp)
 822fbb4:	1000021e 	bne	r2,zero,822fbc0 <rawip_usrreq+0x2f8>
         return(EINVAL);
 822fbb8:	00800584 	movi	r2,22
 822fbbc:	00010f06 	br	822fffc <rawip_usrreq+0x734>

      ep = rawip_lookup(so);
 822fbc0:	e13ffc17 	ldw	r4,-16(fp)
 822fbc4:	822f6a40 	call	822f6a4 <rawip_lookup>
 822fbc8:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fbcc:	e0bff817 	ldw	r2,-32(fp)
 822fbd0:	1000041e 	bne	r2,zero,822fbe4 <rawip_usrreq+0x31c>
      {
         m_free(m);
 822fbd4:	e13ffd17 	ldw	r4,-12(fp)
 822fbd8:	822e1640 	call	822e164 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 822fbdc:	00801bc4 	movi	r2,111
 822fbe0:	00010606 	br	822fffc <rawip_usrreq+0x734>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 822fbe4:	e0bffe17 	ldw	r2,-8(fp)
 822fbe8:	10000b1e 	bne	r2,zero,822fc18 <rawip_usrreq+0x350>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 822fbec:	e0bffc17 	ldw	r2,-16(fp)
 822fbf0:	1080088b 	ldhu	r2,34(r2)
 822fbf4:	10bfffcc 	andi	r2,r2,65535
 822fbf8:	1080008c 	andi	r2,r2,2
 822fbfc:	1000021e 	bne	r2,zero,822fc08 <rawip_usrreq+0x340>
            return (ENOTCONN);
 822fc00:	00802004 	movi	r2,128
 822fc04:	0000fd06 	br	822fffc <rawip_usrreq+0x734>
         fhost = ep->ipr_faddr;
 822fc08:	e0bff817 	ldw	r2,-32(fp)
 822fc0c:	10800217 	ldw	r2,8(r2)
 822fc10:	e0bff315 	stw	r2,-52(fp)
 822fc14:	00001406 	br	822fc68 <rawip_usrreq+0x3a0>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 822fc18:	e0bffc17 	ldw	r2,-16(fp)
 822fc1c:	1080088b 	ldhu	r2,34(r2)
 822fc20:	10bfffcc 	andi	r2,r2,65535
 822fc24:	1080008c 	andi	r2,r2,2
 822fc28:	10000226 	beq	r2,zero,822fc34 <rawip_usrreq+0x36c>
            return (EISCONN);
 822fc2c:	00801fc4 	movi	r2,127
 822fc30:	0000f206 	br	822fffc <rawip_usrreq+0x734>
         if (nam->m_len != sizeof (*sin))
 822fc34:	e0bffe17 	ldw	r2,-8(fp)
 822fc38:	10800217 	ldw	r2,8(r2)
 822fc3c:	10800420 	cmpeqi	r2,r2,16
 822fc40:	1000031e 	bne	r2,zero,822fc50 <rawip_usrreq+0x388>
         {
            dtrap();
 822fc44:	822d1c80 	call	822d1c8 <dtrap>
            return (EINVAL);
 822fc48:	00800584 	movi	r2,22
 822fc4c:	0000eb06 	br	822fffc <rawip_usrreq+0x734>
         }
         sin = mtod(nam, struct sockaddr_in *);
 822fc50:	e0bffe17 	ldw	r2,-8(fp)
 822fc54:	10800317 	ldw	r2,12(r2)
 822fc58:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 822fc5c:	e0bff917 	ldw	r2,-28(fp)
 822fc60:	10800117 	ldw	r2,4(r2)
 822fc64:	e0bff315 	stw	r2,-52(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 822fc68:	e0bffd17 	ldw	r2,-12(fp)
 822fc6c:	14000217 	ldw	r16,8(r2)
 822fc70:	e0bffc17 	ldw	r2,-16(fp)
 822fc74:	10800417 	ldw	r2,16(r2)
 822fc78:	1088000c 	andi	r2,r2,8192
 822fc7c:	1009883a 	mov	r4,r2
 822fc80:	8243de80 	call	8243de8 <ip_raw_maxalloc>
 822fc84:	1400032e 	bgeu	r2,r16,822fc94 <rawip_usrreq+0x3cc>
      {
         dtrap(); /* should never happen */
 822fc88:	822d1c80 	call	822d1c8 <dtrap>
         return EMSGSIZE;  /* try to recover */
 822fc8c:	00801e84 	movi	r2,122
 822fc90:	0000da06 	br	822fffc <rawip_usrreq+0x734>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 822fc94:	e0bffd17 	ldw	r2,-12(fp)
 822fc98:	10800217 	ldw	r2,8(r2)
 822fc9c:	1007883a 	mov	r3,r2
 822fca0:	e0bffc17 	ldw	r2,-16(fp)
 822fca4:	10800417 	ldw	r2,16(r2)
 822fca8:	1088000c 	andi	r2,r2,8192
 822fcac:	100b883a 	mov	r5,r2
 822fcb0:	1809883a 	mov	r4,r3
 822fcb4:	8243cec0 	call	8243cec <ip_raw_alloc>
 822fcb8:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 822fcbc:	e0bffa17 	ldw	r2,-24(fp)
 822fcc0:	1000041e 	bne	r2,zero,822fcd4 <rawip_usrreq+0x40c>
      {
         m_free(m);
 822fcc4:	e13ffd17 	ldw	r4,-12(fp)
 822fcc8:	822e1640 	call	822e164 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 822fccc:	00801a44 	movi	r2,105
 822fcd0:	0000ca06 	br	822fffc <rawip_usrreq+0x734>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 822fcd4:	e0bffa17 	ldw	r2,-24(fp)
 822fcd8:	10c00317 	ldw	r3,12(r2)
 822fcdc:	e0bffd17 	ldw	r2,-12(fp)
 822fce0:	11000317 	ldw	r4,12(r2)
 822fce4:	e0bffd17 	ldw	r2,-12(fp)
 822fce8:	10800217 	ldw	r2,8(r2)
 822fcec:	100d883a 	mov	r6,r2
 822fcf0:	200b883a 	mov	r5,r4
 822fcf4:	1809883a 	mov	r4,r3
 822fcf8:	8202a0c0 	call	8202a0c <memcpy>
      pkt->nb_plen = m->m_len;
 822fcfc:	e0bffd17 	ldw	r2,-12(fp)
 822fd00:	10c00217 	ldw	r3,8(r2)
 822fd04:	e0bffa17 	ldw	r2,-24(fp)
 822fd08:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 822fd0c:	e13ffd17 	ldw	r4,-12(fp)
 822fd10:	822e1640 	call	822e164 <m_free>
      pkt->fhost = fhost;
 822fd14:	e0bffa17 	ldw	r2,-24(fp)
 822fd18:	e0fff317 	ldw	r3,-52(fp)
 822fd1c:	10c00715 	stw	r3,28(r2)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 822fd20:	e0bff317 	ldw	r2,-52(fp)
 822fd24:	10bfffd8 	cmpnei	r2,r2,-1
 822fd28:	10004a1e 	bne	r2,zero,822fe54 <rawip_usrreq+0x58c>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 822fd2c:	e0bff817 	ldw	r2,-32(fp)
 822fd30:	10800117 	ldw	r2,4(r2)
 822fd34:	10001026 	beq	r2,zero,822fd78 <rawip_usrreq+0x4b0>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fd38:	008209b4 	movhi	r2,2086
 822fd3c:	10b8f304 	addi	r2,r2,-7220
 822fd40:	10800017 	ldw	r2,0(r2)
 822fd44:	e0bff515 	stw	r2,-44(fp)
 822fd48:	00000806 	br	822fd6c <rawip_usrreq+0x4a4>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 822fd4c:	e0bff517 	ldw	r2,-44(fp)
 822fd50:	10c00a17 	ldw	r3,40(r2)
 822fd54:	e0bff817 	ldw	r2,-32(fp)
 822fd58:	10800117 	ldw	r2,4(r2)
 822fd5c:	18801d26 	beq	r3,r2,822fdd4 <rawip_usrreq+0x50c>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fd60:	e0bff517 	ldw	r2,-44(fp)
 822fd64:	10800017 	ldw	r2,0(r2)
 822fd68:	e0bff515 	stw	r2,-44(fp)
 822fd6c:	e0bff517 	ldw	r2,-44(fp)
 822fd70:	103ff61e 	bne	r2,zero,822fd4c <rawip_usrreq+0x484>
 822fd74:	00001a06 	br	822fde0 <rawip_usrreq+0x518>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fd78:	008209b4 	movhi	r2,2086
 822fd7c:	10b8f304 	addi	r2,r2,-7220
 822fd80:	10800017 	ldw	r2,0(r2)
 822fd84:	e0bff515 	stw	r2,-44(fp)
 822fd88:	00000f06 	br	822fdc8 <rawip_usrreq+0x500>
               if ((ifp->n_flags & NF_BCAST) &&
 822fd8c:	e0bff517 	ldw	r2,-44(fp)
 822fd90:	10802a17 	ldw	r2,168(r2)
 822fd94:	1080004c 	andi	r2,r2,1
 822fd98:	10000826 	beq	r2,zero,822fdbc <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822fd9c:	e0bff517 	ldw	r2,-44(fp)
 822fda0:	10802717 	ldw	r2,156(r2)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
 822fda4:	10000526 	beq	r2,zero,822fdbc <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822fda8:	e0bff517 	ldw	r2,-44(fp)
 822fdac:	10802717 	ldw	r2,156(r2)
 822fdb0:	10800617 	ldw	r2,24(r2)
 822fdb4:	10800058 	cmpnei	r2,r2,1
 822fdb8:	10000826 	beq	r2,zero,822fddc <rawip_usrreq+0x514>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fdbc:	e0bff517 	ldw	r2,-44(fp)
 822fdc0:	10800017 	ldw	r2,0(r2)
 822fdc4:	e0bff515 	stw	r2,-44(fp)
 822fdc8:	e0bff517 	ldw	r2,-44(fp)
 822fdcc:	103fef1e 	bne	r2,zero,822fd8c <rawip_usrreq+0x4c4>
 822fdd0:	00000306 	br	822fde0 <rawip_usrreq+0x518>
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
 822fdd4:	0001883a 	nop
 822fdd8:	00000106 	br	822fde0 <rawip_usrreq+0x518>
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 822fddc:	0001883a 	nop
         }
         if (ifp == NULL)
 822fde0:	e0bff517 	ldw	r2,-44(fp)
 822fde4:	1000181e 	bne	r2,zero,822fe48 <rawip_usrreq+0x580>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fde8:	008209b4 	movhi	r2,2086
 822fdec:	10b8f304 	addi	r2,r2,-7220
 822fdf0:	10800017 	ldw	r2,0(r2)
 822fdf4:	e0bff515 	stw	r2,-44(fp)
 822fdf8:	00000b06 	br	822fe28 <rawip_usrreq+0x560>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822fdfc:	e0bff517 	ldw	r2,-44(fp)
 822fe00:	10802717 	ldw	r2,156(r2)
 822fe04:	10000526 	beq	r2,zero,822fe1c <rawip_usrreq+0x554>
 822fe08:	e0bff517 	ldw	r2,-44(fp)
 822fe0c:	10802717 	ldw	r2,156(r2)
 822fe10:	10800617 	ldw	r2,24(r2)
 822fe14:	10800058 	cmpnei	r2,r2,1
 822fe18:	10000626 	beq	r2,zero,822fe34 <rawip_usrreq+0x56c>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fe1c:	e0bff517 	ldw	r2,-44(fp)
 822fe20:	10800017 	ldw	r2,0(r2)
 822fe24:	e0bff515 	stw	r2,-44(fp)
 822fe28:	e0bff517 	ldw	r2,-44(fp)
 822fe2c:	103ff31e 	bne	r2,zero,822fdfc <rawip_usrreq+0x534>
 822fe30:	00000106 	br	822fe38 <rawip_usrreq+0x570>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 822fe34:	0001883a 	nop
            if (ifp == NULL)
 822fe38:	e0bff517 	ldw	r2,-44(fp)
 822fe3c:	1000021e 	bne	r2,zero,822fe48 <rawip_usrreq+0x580>
               return(EADDRNOTAVAIL);
 822fe40:	00801f44 	movi	r2,125
 822fe44:	00006d06 	br	822fffc <rawip_usrreq+0x734>
         }
         pkt->net = ifp;
 822fe48:	e0bffa17 	ldw	r2,-24(fp)
 822fe4c:	e0fff517 	ldw	r3,-44(fp)
 822fe50:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 822fe54:	e0bffc17 	ldw	r2,-16(fp)
 822fe58:	10800317 	ldw	r2,12(r2)
 822fe5c:	10000426 	beq	r2,zero,822fe70 <rawip_usrreq+0x5a8>
         pkt->imo = so->inp_moptions;
 822fe60:	e0bffc17 	ldw	r2,-16(fp)
 822fe64:	10c00317 	ldw	r3,12(r2)
 822fe68:	e0bffa17 	ldw	r2,-24(fp)
 822fe6c:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 822fe70:	e0bffc17 	ldw	r2,-16(fp)
 822fe74:	10800417 	ldw	r2,16(r2)
 822fe78:	1088000c 	andi	r2,r2,8192
 822fe7c:	10000826 	beq	r2,zero,822fea0 <rawip_usrreq+0x5d8>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 822fe80:	0009883a 	mov	r4,zero
 822fe84:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 822fe88:	e13ffa17 	ldw	r4,-24(fp)
 822fe8c:	823fb440 	call	823fb44 <ip_raw_write>
 822fe90:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 822fe94:	0009883a 	mov	r4,zero
 822fe98:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
 822fe9c:	00002806 	br	822ff40 <rawip_usrreq+0x678>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 822fea0:	e0bffa17 	ldw	r2,-24(fp)
 822fea4:	10800317 	ldw	r2,12(r2)
 822fea8:	10bffb04 	addi	r2,r2,-20
 822feac:	e0bffb15 	stw	r2,-20(fp)
         if (ep->ipr_laddr)
 822feb0:	e0bff817 	ldw	r2,-32(fp)
 822feb4:	10800117 	ldw	r2,4(r2)
 822feb8:	10000526 	beq	r2,zero,822fed0 <rawip_usrreq+0x608>
            pip->ip_src = ep->ipr_laddr;
 822febc:	e0bff817 	ldw	r2,-32(fp)
 822fec0:	10c00117 	ldw	r3,4(r2)
 822fec4:	e0bffb17 	ldw	r2,-20(fp)
 822fec8:	10c00315 	stw	r3,12(r2)
 822fecc:	00000e06 	br	822ff08 <rawip_usrreq+0x640>
         else
         {
            if (fhost == 0xffffffff)
 822fed0:	e0bff317 	ldw	r2,-52(fp)
 822fed4:	10bfffd8 	cmpnei	r2,r2,-1
 822fed8:	1000061e 	bne	r2,zero,822fef4 <rawip_usrreq+0x62c>
               pip->ip_src = pkt->net->n_ipaddr;
 822fedc:	e0bffa17 	ldw	r2,-24(fp)
 822fee0:	10800617 	ldw	r2,24(r2)
 822fee4:	10c00a17 	ldw	r3,40(r2)
 822fee8:	e0bffb17 	ldw	r2,-20(fp)
 822feec:	10c00315 	stw	r3,12(r2)
 822fef0:	00000506 	br	822ff08 <rawip_usrreq+0x640>
            else
               pip->ip_src = ip_mymach(fhost);
 822fef4:	e13ff317 	ldw	r4,-52(fp)
 822fef8:	82405f00 	call	82405f0 <ip_mymach>
 822fefc:	1007883a 	mov	r3,r2
 822ff00:	e0bffb17 	ldw	r2,-20(fp)
 822ff04:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 822ff08:	e0bffb17 	ldw	r2,-20(fp)
 822ff0c:	e0fff317 	ldw	r3,-52(fp)
 822ff10:	10c00415 	stw	r3,16(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 822ff14:	0009883a 	mov	r4,zero
 822ff18:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 822ff1c:	e0bff817 	ldw	r2,-32(fp)
 822ff20:	10800503 	ldbu	r2,20(r2)
 822ff24:	10803fcc 	andi	r2,r2,255
 822ff28:	e17ffa17 	ldw	r5,-24(fp)
 822ff2c:	1009883a 	mov	r4,r2
 822ff30:	823f5a00 	call	823f5a0 <ip_write>
 822ff34:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 822ff38:	0009883a 	mov	r4,zero
 822ff3c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 822ff40:	e0bff217 	ldw	r2,-56(fp)
 822ff44:	1000020e 	bge	r2,zero,822ff50 <rawip_usrreq+0x688>
         return(e);
 822ff48:	e0bff217 	ldw	r2,-56(fp)
 822ff4c:	00002b06 	br	822fffc <rawip_usrreq+0x734>
      return 0;
 822ff50:	0005883a 	mov	r2,zero
 822ff54:	00002906 	br	822fffc <rawip_usrreq+0x734>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 822ff58:	e0bffe17 	ldw	r2,-8(fp)
 822ff5c:	1000021e 	bne	r2,zero,822ff68 <rawip_usrreq+0x6a0>
         return(EINVAL);
 822ff60:	00800584 	movi	r2,22
 822ff64:	00002506 	br	822fffc <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 822ff68:	e0bffe17 	ldw	r2,-8(fp)
 822ff6c:	10800317 	ldw	r2,12(r2)
 822ff70:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 822ff74:	e0bff917 	ldw	r2,-28(fp)
 822ff78:	1000021e 	bne	r2,zero,822ff84 <rawip_usrreq+0x6bc>
         return(EINVAL);
 822ff7c:	00800584 	movi	r2,22
 822ff80:	00001e06 	br	822fffc <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 822ff84:	e13ffc17 	ldw	r4,-16(fp)
 822ff88:	822f6a40 	call	822f6a4 <rawip_lookup>
 822ff8c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822ff90:	e0bff817 	ldw	r2,-32(fp)
 822ff94:	1000021e 	bne	r2,zero,822ffa0 <rawip_usrreq+0x6d8>
         return(EINVAL);
 822ff98:	00800584 	movi	r2,22
 822ff9c:	00001706 	br	822fffc <rawip_usrreq+0x734>
      sin->sin_port = 0;
 822ffa0:	e0bff917 	ldw	r2,-28(fp)
 822ffa4:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 822ffa8:	e0bffe17 	ldw	r2,-8(fp)
 822ffac:	00c00404 	movi	r3,16
 822ffb0:	10c00215 	stw	r3,8(r2)
      if (req == PRU_SOCKADDR)
 822ffb4:	e0bff617 	ldw	r2,-40(fp)
 822ffb8:	108003d8 	cmpnei	r2,r2,15
 822ffbc:	1000051e 	bne	r2,zero,822ffd4 <rawip_usrreq+0x70c>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 822ffc0:	e0bff817 	ldw	r2,-32(fp)
 822ffc4:	10c00117 	ldw	r3,4(r2)
 822ffc8:	e0bff917 	ldw	r2,-28(fp)
 822ffcc:	10c00115 	stw	r3,4(r2)
 822ffd0:	00000406 	br	822ffe4 <rawip_usrreq+0x71c>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 822ffd4:	e0bff817 	ldw	r2,-32(fp)
 822ffd8:	10c00217 	ldw	r3,8(r2)
 822ffdc:	e0bff917 	ldw	r2,-28(fp)
 822ffe0:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 822ffe4:	0005883a 	mov	r2,zero
 822ffe8:	00000406 	br	822fffc <rawip_usrreq+0x734>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 822ffec:	822d1c80 	call	822d1c8 <dtrap>
      return 0;
 822fff0:	0005883a 	mov	r2,zero
 822fff4:	00000106 	br	822fffc <rawip_usrreq+0x734>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 822fff8:	008017c4 	movi	r2,95
   }
}
 822fffc:	e6ffff04 	addi	sp,fp,-4
 8230000:	dfc00217 	ldw	ra,8(sp)
 8230004:	df000117 	ldw	fp,4(sp)
 8230008:	dc000017 	ldw	r16,0(sp)
 823000c:	dec00304 	addi	sp,sp,12
 8230010:	f800283a 	ret

08230014 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 8230014:	defffc04 	addi	sp,sp,-16
 8230018:	dfc00315 	stw	ra,12(sp)
 823001c:	df000215 	stw	fp,8(sp)
 8230020:	df000204 	addi	fp,sp,8
 8230024:	e13ffe15 	stw	r4,-8(fp)
 8230028:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 823002c:	e0bffe17 	ldw	r2,-8(fp)
 8230030:	10800517 	ldw	r2,20(r2)
 8230034:	10800098 	cmpnei	r2,r2,2
 8230038:	1000041e 	bne	r2,zero,823004c <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
 823003c:	e0bfff17 	ldw	r2,-4(fp)
#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 8230040:	10800428 	cmpgeui	r2,r2,16
 8230044:	1000011e 	bne	r2,zero,823004c <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 8230048:	822d1c80 	call	822d1c8 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 823004c:	0001883a 	nop
 8230050:	e037883a 	mov	sp,fp
 8230054:	dfc00117 	ldw	ra,4(sp)
 8230058:	df000017 	ldw	fp,0(sp)
 823005c:	dec00204 	addi	sp,sp,8
 8230060:	f800283a 	ret

08230064 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 8230064:	defffa04 	addi	sp,sp,-24
 8230068:	dfc00515 	stw	ra,20(sp)
 823006c:	df000415 	stw	fp,16(sp)
 8230070:	df000404 	addi	fp,sp,16
 8230074:	e13ffd15 	stw	r4,-12(fp)
 8230078:	e17ffe15 	stw	r5,-8(fp)
 823007c:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 8230080:	0009883a 	mov	r4,zero
 8230084:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 8230088:	e1bfff17 	ldw	r6,-4(fp)
 823008c:	e17ffe17 	ldw	r5,-8(fp)
 8230090:	e13ffd17 	ldw	r4,-12(fp)
 8230094:	82316680 	call	8231668 <socreate>
 8230098:	e0bffc15 	stw	r2,-16(fp)
 823009c:	e0bffc17 	ldw	r2,-16(fp)
 82300a0:	1000041e 	bne	r2,zero,82300b4 <t_socket+0x50>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 82300a4:	0009883a 	mov	r4,zero
 82300a8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82300ac:	00bfffc4 	movi	r2,-1
 82300b0:	00000706 	br	82300d0 <t_socket+0x6c>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 82300b4:	e0bffc17 	ldw	r2,-16(fp)
 82300b8:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82300bc:	0009883a 	mov	r4,zero
 82300c0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 82300c4:	e0bffc17 	ldw	r2,-16(fp)
 82300c8:	1004d0ba 	srli	r2,r2,2
 82300cc:	10800804 	addi	r2,r2,32
}
 82300d0:	e037883a 	mov	sp,fp
 82300d4:	dfc00117 	ldw	ra,4(sp)
 82300d8:	df000017 	ldw	fp,0(sp)
 82300dc:	dec00204 	addi	sp,sp,8
 82300e0:	f800283a 	ret

082300e4 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 82300e4:	defff204 	addi	sp,sp,-56
 82300e8:	dfc00d15 	stw	ra,52(sp)
 82300ec:	df000c15 	stw	fp,48(sp)
 82300f0:	df000c04 	addi	fp,sp,48
 82300f4:	e13ffd15 	stw	r4,-12(fp)
 82300f8:	e17ffe15 	stw	r5,-8(fp)
 82300fc:	e1bfff15 	stw	r6,-4(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 8230100:	e0bffd17 	ldw	r2,-12(fp)
 8230104:	10bff804 	addi	r2,r2,-32
 8230108:	1085883a 	add	r2,r2,r2
 823010c:	1085883a 	add	r2,r2,r2
 8230110:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8230114:	008209b4 	movhi	r2,2086
 8230118:	10b7ef04 	addi	r2,r2,-8260
 823011c:	e0bff515 	stw	r2,-44(fp)
 8230120:	00000606 	br	823013c <t_bind+0x58>
 8230124:	e0fff517 	ldw	r3,-44(fp)
 8230128:	e0bff617 	ldw	r2,-40(fp)
 823012c:	18800626 	beq	r3,r2,8230148 <t_bind+0x64>
 8230130:	e0bff517 	ldw	r2,-44(fp)
 8230134:	10800017 	ldw	r2,0(r2)
 8230138:	e0bff515 	stw	r2,-44(fp)
 823013c:	e0bff517 	ldw	r2,-44(fp)
 8230140:	103ff81e 	bne	r2,zero,8230124 <t_bind+0x40>
 8230144:	00000106 	br	823014c <t_bind+0x68>
 8230148:	0001883a 	nop
 823014c:	e0fff517 	ldw	r3,-44(fp)
 8230150:	e0bff617 	ldw	r2,-40(fp)
 8230154:	18800326 	beq	r3,r2,8230164 <t_bind+0x80>
 8230158:	822d1c80 	call	822d1c8 <dtrap>
 823015c:	00bfffc4 	movi	r2,-1
 8230160:	00003406 	br	8230234 <t_bind+0x150>
   DOMAIN_CHECK(so, addrlen);
 8230164:	e17fff17 	ldw	r5,-4(fp)
 8230168:	e13ff617 	ldw	r4,-40(fp)
 823016c:	82300140 	call	8230014 <DOMAIN_CHECK>

   so->so_error = 0;
 8230170:	e0bff617 	ldw	r2,-40(fp)
 8230174:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 8230178:	e0bffe17 	ldw	r2,-8(fp)
 823017c:	10000d1e 	bne	r2,zero,82301b4 <t_bind+0xd0>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 8230180:	e0bff904 	addi	r2,fp,-28
 8230184:	01800404 	movi	r6,16
 8230188:	000b883a 	mov	r5,zero
 823018c:	1009883a 	mov	r4,r2
 8230190:	8202cb00 	call	8202cb0 <memset>
      addrlen = sizeof(sa);
 8230194:	00800404 	movi	r2,16
 8230198:	e0bfff15 	stw	r2,-4(fp)
      sa.sa_family = so->so_domain;
 823019c:	e0bff617 	ldw	r2,-40(fp)
 82301a0:	10800517 	ldw	r2,20(r2)
 82301a4:	e0bff90d 	sth	r2,-28(fp)
      sap = &sa;
 82301a8:	e0bff904 	addi	r2,fp,-28
 82301ac:	e0bff415 	stw	r2,-48(fp)
 82301b0:	00000206 	br	82301bc <t_bind+0xd8>
   } else
      sap = addr;
 82301b4:	e0bffe17 	ldw	r2,-8(fp)
 82301b8:	e0bff415 	stw	r2,-48(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 82301bc:	01800244 	movi	r6,9
 82301c0:	e17fff17 	ldw	r5,-4(fp)
 82301c4:	e13ff417 	ldw	r4,-48(fp)
 82301c8:	82315440 	call	8231544 <sockargs>
 82301cc:	e0bff715 	stw	r2,-36(fp)
 82301d0:	e0bff717 	ldw	r2,-36(fp)
 82301d4:	1000051e 	bne	r2,zero,82301ec <t_bind+0x108>
   {
      so->so_error = ENOMEM;
 82301d8:	e0bff617 	ldw	r2,-40(fp)
 82301dc:	00c00304 	movi	r3,12
 82301e0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82301e4:	00bfffc4 	movi	r2,-1
 82301e8:	00001206 	br	8230234 <t_bind+0x150>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 82301ec:	0009883a 	mov	r4,zero
 82301f0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 82301f4:	e17ff717 	ldw	r5,-36(fp)
 82301f8:	e13ff617 	ldw	r4,-40(fp)
 82301fc:	82318100 	call	8231810 <sobind>
 8230200:	e0bff815 	stw	r2,-32(fp)
   m_freem(nam);
 8230204:	e13ff717 	ldw	r4,-36(fp)
 8230208:	822e26c0 	call	822e26c <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 823020c:	0009883a 	mov	r4,zero
 8230210:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230214:	e0bff817 	ldw	r2,-32(fp)
 8230218:	10000526 	beq	r2,zero,8230230 <t_bind+0x14c>
   {
      so->so_error = err;
 823021c:	e0bff617 	ldw	r2,-40(fp)
 8230220:	e0fff817 	ldw	r3,-32(fp)
 8230224:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230228:	00bfffc4 	movi	r2,-1
 823022c:	00000106 	br	8230234 <t_bind+0x150>
   }
   return 0;
 8230230:	0005883a 	mov	r2,zero
}
 8230234:	e037883a 	mov	sp,fp
 8230238:	dfc00117 	ldw	ra,4(sp)
 823023c:	df000017 	ldw	fp,0(sp)
 8230240:	dec00204 	addi	sp,sp,8
 8230244:	f800283a 	ret

08230248 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 8230248:	defff904 	addi	sp,sp,-28
 823024c:	dfc00615 	stw	ra,24(sp)
 8230250:	df000515 	stw	fp,20(sp)
 8230254:	df000504 	addi	fp,sp,20
 8230258:	e13ffe15 	stw	r4,-8(fp)
 823025c:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 8230260:	e0bffe17 	ldw	r2,-8(fp)
 8230264:	10bff804 	addi	r2,r2,-32
 8230268:	1085883a 	add	r2,r2,r2
 823026c:	1085883a 	add	r2,r2,r2
 8230270:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 8230274:	008209b4 	movhi	r2,2086
 8230278:	10b7ef04 	addi	r2,r2,-8260
 823027c:	e0bffb15 	stw	r2,-20(fp)
 8230280:	00000606 	br	823029c <t_listen+0x54>
 8230284:	e0fffb17 	ldw	r3,-20(fp)
 8230288:	e0bffc17 	ldw	r2,-16(fp)
 823028c:	18800626 	beq	r3,r2,82302a8 <t_listen+0x60>
 8230290:	e0bffb17 	ldw	r2,-20(fp)
 8230294:	10800017 	ldw	r2,0(r2)
 8230298:	e0bffb15 	stw	r2,-20(fp)
 823029c:	e0bffb17 	ldw	r2,-20(fp)
 82302a0:	103ff81e 	bne	r2,zero,8230284 <t_listen+0x3c>
 82302a4:	00000106 	br	82302ac <t_listen+0x64>
 82302a8:	0001883a 	nop
 82302ac:	e0fffb17 	ldw	r3,-20(fp)
 82302b0:	e0bffc17 	ldw	r2,-16(fp)
 82302b4:	18800326 	beq	r3,r2,82302c4 <t_listen+0x7c>
 82302b8:	822d1c80 	call	822d1c8 <dtrap>
 82302bc:	00bfffc4 	movi	r2,-1
 82302c0:	00001206 	br	823030c <t_listen+0xc4>
   so->so_error = 0;
 82302c4:	e0bffc17 	ldw	r2,-16(fp)
 82302c8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 82302cc:	0009883a 	mov	r4,zero
 82302d0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 82302d4:	e17fff17 	ldw	r5,-4(fp)
 82302d8:	e13ffc17 	ldw	r4,-16(fp)
 82302dc:	823186c0 	call	823186c <solisten>
 82302e0:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82302e4:	0009883a 	mov	r4,zero
 82302e8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 82302ec:	e0bffd17 	ldw	r2,-12(fp)
 82302f0:	10000526 	beq	r2,zero,8230308 <t_listen+0xc0>
   {
      so->so_error = err;
 82302f4:	e0bffc17 	ldw	r2,-16(fp)
 82302f8:	e0fffd17 	ldw	r3,-12(fp)
 82302fc:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230300:	00bfffc4 	movi	r2,-1
 8230304:	00000106 	br	823030c <t_listen+0xc4>
   }
   return 0;
 8230308:	0005883a 	mov	r2,zero
}
 823030c:	e037883a 	mov	sp,fp
 8230310:	dfc00117 	ldw	ra,4(sp)
 8230314:	df000017 	ldw	fp,0(sp)
 8230318:	dec00204 	addi	sp,sp,8
 823031c:	f800283a 	ret

08230320 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 8230320:	defff704 	addi	sp,sp,-36
 8230324:	dfc00815 	stw	ra,32(sp)
 8230328:	df000715 	stw	fp,28(sp)
 823032c:	df000704 	addi	fp,sp,28
 8230330:	e13ffd15 	stw	r4,-12(fp)
 8230334:	e17ffe15 	stw	r5,-8(fp)
 8230338:	e1bfff15 	stw	r6,-4(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 823033c:	e0bffd17 	ldw	r2,-12(fp)
 8230340:	10bff804 	addi	r2,r2,-32
 8230344:	1085883a 	add	r2,r2,r2
 8230348:	1085883a 	add	r2,r2,r2
 823034c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230350:	008209b4 	movhi	r2,2086
 8230354:	10b7ef04 	addi	r2,r2,-8260
 8230358:	e0bff915 	stw	r2,-28(fp)
 823035c:	00000606 	br	8230378 <t_accept+0x58>
 8230360:	e0fff917 	ldw	r3,-28(fp)
 8230364:	e0bffa17 	ldw	r2,-24(fp)
 8230368:	18800626 	beq	r3,r2,8230384 <t_accept+0x64>
 823036c:	e0bff917 	ldw	r2,-28(fp)
 8230370:	10800017 	ldw	r2,0(r2)
 8230374:	e0bff915 	stw	r2,-28(fp)
 8230378:	e0bff917 	ldw	r2,-28(fp)
 823037c:	103ff81e 	bne	r2,zero,8230360 <t_accept+0x40>
 8230380:	00000106 	br	8230388 <t_accept+0x68>
 8230384:	0001883a 	nop
 8230388:	e0fff917 	ldw	r3,-28(fp)
 823038c:	e0bffa17 	ldw	r2,-24(fp)
 8230390:	18800326 	beq	r3,r2,82303a0 <t_accept+0x80>
 8230394:	822d1c80 	call	822d1c8 <dtrap>
 8230398:	00bfffc4 	movi	r2,-1
 823039c:	00007006 	br	8230560 <t_accept+0x240>
   DOMAIN_CHECK(so, *addrlen);
 82303a0:	e0bfff17 	ldw	r2,-4(fp)
 82303a4:	10800017 	ldw	r2,0(r2)
 82303a8:	100b883a 	mov	r5,r2
 82303ac:	e13ffa17 	ldw	r4,-24(fp)
 82303b0:	82300140 	call	8230014 <DOMAIN_CHECK>

   so->so_error = 0;
 82303b4:	e0bffa17 	ldw	r2,-24(fp)
 82303b8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 82303bc:	e0bffa17 	ldw	r2,-24(fp)
 82303c0:	10800417 	ldw	r2,16(r2)
 82303c4:	1080008c 	andi	r2,r2,2
 82303c8:	1000051e 	bne	r2,zero,82303e0 <t_accept+0xc0>
   {
      so->so_error = EINVAL;
 82303cc:	e0bffa17 	ldw	r2,-24(fp)
 82303d0:	00c00584 	movi	r3,22
 82303d4:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82303d8:	00bfffc4 	movi	r2,-1
 82303dc:	00006006 	br	8230560 <t_accept+0x240>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 82303e0:	e0bffa17 	ldw	r2,-24(fp)
 82303e4:	1080088b 	ldhu	r2,34(r2)
 82303e8:	10bfffcc 	andi	r2,r2,65535
 82303ec:	1080400c 	andi	r2,r2,256
 82303f0:	10000b26 	beq	r2,zero,8230420 <t_accept+0x100>
 82303f4:	e0bffa17 	ldw	r2,-24(fp)
 82303f8:	10801e43 	ldbu	r2,121(r2)
 82303fc:	10803fcc 	andi	r2,r2,255
 8230400:	1080201c 	xori	r2,r2,128
 8230404:	10bfe004 	addi	r2,r2,-128
 8230408:	1000051e 	bne	r2,zero,8230420 <t_accept+0x100>
   {
      so->so_error = EWOULDBLOCK;
 823040c:	e0bffa17 	ldw	r2,-24(fp)
 8230410:	00c002c4 	movi	r3,11
 8230414:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230418:	00bfffc4 	movi	r2,-1
 823041c:	00005006 	br	8230560 <t_accept+0x240>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230420:	0009883a 	mov	r4,zero
 8230424:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 8230428:	00001006 	br	823046c <t_accept+0x14c>
   {
      if (so->so_state & SS_CANTRCVMORE)
 823042c:	e0bffa17 	ldw	r2,-24(fp)
 8230430:	1080088b 	ldhu	r2,34(r2)
 8230434:	10bfffcc 	andi	r2,r2,65535
 8230438:	1080080c 	andi	r2,r2,32
 823043c:	10000726 	beq	r2,zero,823045c <t_accept+0x13c>
      {
         so->so_error = ECONNABORTED;
 8230440:	e0bffa17 	ldw	r2,-24(fp)
 8230444:	00c01c44 	movi	r3,113
 8230448:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 823044c:	0009883a 	mov	r4,zero
 8230450:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230454:	00bfffc4 	movi	r2,-1
 8230458:	00004106 	br	8230560 <t_accept+0x240>
      }
      tcp_sleep ((char *)&so->so_timeo);
 823045c:	e0bffa17 	ldw	r2,-24(fp)
 8230460:	10800904 	addi	r2,r2,36
 8230464:	1009883a 	mov	r4,r2
 8230468:	82291680 	call	8229168 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 823046c:	e0bffa17 	ldw	r2,-24(fp)
 8230470:	10801e43 	ldbu	r2,121(r2)
 8230474:	10803fcc 	andi	r2,r2,255
 8230478:	1080201c 	xori	r2,r2,128
 823047c:	10bfe004 	addi	r2,r2,-128
 8230480:	1000031e 	bne	r2,zero,8230490 <t_accept+0x170>
 8230484:	e0bffa17 	ldw	r2,-24(fp)
 8230488:	10800617 	ldw	r2,24(r2)
 823048c:	103fe726 	beq	r2,zero,823042c <t_accept+0x10c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 8230490:	e0bffa17 	ldw	r2,-24(fp)
 8230494:	10800617 	ldw	r2,24(r2)
 8230498:	10000426 	beq	r2,zero,82304ac <t_accept+0x18c>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 823049c:	0009883a 	mov	r4,zero
 82304a0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82304a4:	00bfffc4 	movi	r2,-1
 82304a8:	00002d06 	br	8230560 <t_accept+0x240>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 82304ac:	01400404 	movi	r5,16
 82304b0:	01000244 	movi	r4,9
 82304b4:	822dfdc0 	call	822dfdc <m_getnbuf>
 82304b8:	e0bffb15 	stw	r2,-20(fp)
   if (nam == NULL) 
 82304bc:	e0bffb17 	ldw	r2,-20(fp)
 82304c0:	1000071e 	bne	r2,zero,82304e0 <t_accept+0x1c0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 82304c4:	0009883a 	mov	r4,zero
 82304c8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 82304cc:	e0bffa17 	ldw	r2,-24(fp)
 82304d0:	00c00304 	movi	r3,12
 82304d4:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82304d8:	00bfffc4 	movi	r2,-1
 82304dc:	00002006 	br	8230560 <t_accept+0x240>
   }
   { 
      struct socket *aso = so->so_q;
 82304e0:	e0bffa17 	ldw	r2,-24(fp)
 82304e4:	10801d17 	ldw	r2,116(r2)
 82304e8:	e0bffc15 	stw	r2,-16(fp)
      if (soqremque (aso, 1) == 0)
 82304ec:	01400044 	movi	r5,1
 82304f0:	e13ffc17 	ldw	r4,-16(fp)
 82304f4:	8233c180 	call	8233c18 <soqremque>
 82304f8:	1000031e 	bne	r2,zero,8230508 <t_accept+0x1e8>
         panic("accept");
 82304fc:	01020974 	movhi	r4,2085
 8230500:	21020b04 	addi	r4,r4,2092
 8230504:	822887c0 	call	822887c <panic>
      so = aso;
 8230508:	e0bffc17 	ldw	r2,-16(fp)
 823050c:	e0bffa15 	stw	r2,-24(fp)
   }
   (void)soaccept (so, nam);
 8230510:	e17ffb17 	ldw	r5,-20(fp)
 8230514:	e13ffa17 	ldw	r4,-24(fp)
 8230518:	8231d580 	call	8231d58 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 823051c:	e0bffe17 	ldw	r2,-8(fp)
 8230520:	10000826 	beq	r2,zero,8230544 <t_accept+0x224>
      MEMCPY(addr, nam->m_data, *addrlen);
 8230524:	e0bffb17 	ldw	r2,-20(fp)
 8230528:	10c00317 	ldw	r3,12(r2)
 823052c:	e0bfff17 	ldw	r2,-4(fp)
 8230530:	10800017 	ldw	r2,0(r2)
 8230534:	100d883a 	mov	r6,r2
 8230538:	180b883a 	mov	r5,r3
 823053c:	e13ffe17 	ldw	r4,-8(fp)
 8230540:	8202a0c0 	call	8202a0c <memcpy>
   m_freem (nam);
 8230544:	e13ffb17 	ldw	r4,-20(fp)
 8230548:	822e26c0 	call	822e26c <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 823054c:	0009883a 	mov	r4,zero
 8230550:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 8230554:	e0bffa17 	ldw	r2,-24(fp)
 8230558:	1004d0ba 	srli	r2,r2,2
 823055c:	10800804 	addi	r2,r2,32
}
 8230560:	e037883a 	mov	sp,fp
 8230564:	dfc00117 	ldw	ra,4(sp)
 8230568:	df000017 	ldw	fp,0(sp)
 823056c:	dec00204 	addi	sp,sp,8
 8230570:	f800283a 	ret

08230574 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 8230574:	defff804 	addi	sp,sp,-32
 8230578:	dfc00715 	stw	ra,28(sp)
 823057c:	df000615 	stw	fp,24(sp)
 8230580:	df000604 	addi	fp,sp,24
 8230584:	e13ffd15 	stw	r4,-12(fp)
 8230588:	e17ffe15 	stw	r5,-8(fp)
 823058c:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 8230590:	e0bffd17 	ldw	r2,-12(fp)
 8230594:	10bff804 	addi	r2,r2,-32
 8230598:	1085883a 	add	r2,r2,r2
 823059c:	1085883a 	add	r2,r2,r2
 82305a0:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82305a4:	008209b4 	movhi	r2,2086
 82305a8:	10b7ef04 	addi	r2,r2,-8260
 82305ac:	e0bffa15 	stw	r2,-24(fp)
 82305b0:	00000606 	br	82305cc <t_connect+0x58>
 82305b4:	e0fffa17 	ldw	r3,-24(fp)
 82305b8:	e0bffb17 	ldw	r2,-20(fp)
 82305bc:	18800626 	beq	r3,r2,82305d8 <t_connect+0x64>
 82305c0:	e0bffa17 	ldw	r2,-24(fp)
 82305c4:	10800017 	ldw	r2,0(r2)
 82305c8:	e0bffa15 	stw	r2,-24(fp)
 82305cc:	e0bffa17 	ldw	r2,-24(fp)
 82305d0:	103ff81e 	bne	r2,zero,82305b4 <t_connect+0x40>
 82305d4:	00000106 	br	82305dc <t_connect+0x68>
 82305d8:	0001883a 	nop
 82305dc:	e0fffa17 	ldw	r3,-24(fp)
 82305e0:	e0bffb17 	ldw	r2,-20(fp)
 82305e4:	18800326 	beq	r3,r2,82305f4 <t_connect+0x80>
 82305e8:	822d1c80 	call	822d1c8 <dtrap>
 82305ec:	00bfffc4 	movi	r2,-1
 82305f0:	00007606 	br	82307cc <t_connect+0x258>
   DOMAIN_CHECK(so, addrlen);
 82305f4:	e17fff17 	ldw	r5,-4(fp)
 82305f8:	e13ffb17 	ldw	r4,-20(fp)
 82305fc:	82300140 	call	8230014 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 8230600:	e0bffb17 	ldw	r2,-20(fp)
 8230604:	1080088b 	ldhu	r2,34(r2)
 8230608:	10bfffcc 	andi	r2,r2,65535
 823060c:	1080400c 	andi	r2,r2,256
 8230610:	10002426 	beq	r2,zero,82306a4 <t_connect+0x130>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 8230614:	e0bffb17 	ldw	r2,-20(fp)
 8230618:	1080088b 	ldhu	r2,34(r2)
 823061c:	10bfffcc 	andi	r2,r2,65535
 8230620:	1080010c 	andi	r2,r2,4
 8230624:	10000526 	beq	r2,zero,823063c <t_connect+0xc8>
      {
         so->so_error = EINPROGRESS;
 8230628:	e0bffb17 	ldw	r2,-20(fp)
 823062c:	00c01dc4 	movi	r3,119
 8230630:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8230634:	00bfffc4 	movi	r2,-1
 8230638:	00006406 	br	82307cc <t_connect+0x258>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 823063c:	e0bffb17 	ldw	r2,-20(fp)
 8230640:	1080088b 	ldhu	r2,34(r2)
 8230644:	10bfffcc 	andi	r2,r2,65535
 8230648:	1080008c 	andi	r2,r2,2
 823064c:	10000426 	beq	r2,zero,8230660 <t_connect+0xec>
      {
         so->so_error = 0;
 8230650:	e0bffb17 	ldw	r2,-20(fp)
 8230654:	10000615 	stw	zero,24(r2)
         return 0;
 8230658:	0005883a 	mov	r2,zero
 823065c:	00005b06 	br	82307cc <t_connect+0x258>
      }
      if (so->so_state & SS_WASCONNECTING)
 8230660:	e0bffb17 	ldw	r2,-20(fp)
 8230664:	1080088b 	ldhu	r2,34(r2)
 8230668:	10bfffcc 	andi	r2,r2,65535
 823066c:	1088000c 	andi	r2,r2,8192
 8230670:	10000c26 	beq	r2,zero,82306a4 <t_connect+0x130>
      {
         so->so_state &= ~SS_WASCONNECTING;
 8230674:	e0bffb17 	ldw	r2,-20(fp)
 8230678:	10c0088b 	ldhu	r3,34(r2)
 823067c:	00b7ffc4 	movi	r2,-8193
 8230680:	1884703a 	and	r2,r3,r2
 8230684:	1007883a 	mov	r3,r2
 8230688:	e0bffb17 	ldw	r2,-20(fp)
 823068c:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 8230690:	e0bffb17 	ldw	r2,-20(fp)
 8230694:	10800617 	ldw	r2,24(r2)
 8230698:	10000226 	beq	r2,zero,82306a4 <t_connect+0x130>
            return SOCKET_ERROR;
 823069c:	00bfffc4 	movi	r2,-1
 82306a0:	00004a06 	br	82307cc <t_connect+0x258>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 82306a4:	e0bffb17 	ldw	r2,-20(fp)
 82306a8:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 82306ac:	01800244 	movi	r6,9
 82306b0:	e17fff17 	ldw	r5,-4(fp)
 82306b4:	e13ffe17 	ldw	r4,-8(fp)
 82306b8:	82315440 	call	8231544 <sockargs>
 82306bc:	e0bffc15 	stw	r2,-16(fp)
 82306c0:	e0bffc17 	ldw	r2,-16(fp)
 82306c4:	1000051e 	bne	r2,zero,82306dc <t_connect+0x168>
       == NULL)
   {
      so->so_error = ENOMEM;
 82306c8:	e0bffb17 	ldw	r2,-20(fp)
 82306cc:	00c00304 	movi	r3,12
 82306d0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82306d4:	00bfffc4 	movi	r2,-1
 82306d8:	00003c06 	br	82307cc <t_connect+0x258>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 82306dc:	0009883a 	mov	r4,zero
 82306e0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 82306e4:	e17ffc17 	ldw	r5,-16(fp)
 82306e8:	e13ffb17 	ldw	r4,-20(fp)
 82306ec:	8231df00 	call	8231df0 <soconnect>
 82306f0:	1007883a 	mov	r3,r2
 82306f4:	e0bffb17 	ldw	r2,-20(fp)
 82306f8:	10c00615 	stw	r3,24(r2)
 82306fc:	e0bffb17 	ldw	r2,-20(fp)
 8230700:	10800617 	ldw	r2,24(r2)
 8230704:	10001b1e 	bne	r2,zero,8230774 <t_connect+0x200>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 8230708:	e0bffb17 	ldw	r2,-20(fp)
 823070c:	1080088b 	ldhu	r2,34(r2)
 8230710:	10bfffcc 	andi	r2,r2,65535
 8230714:	1080400c 	andi	r2,r2,256
 8230718:	10000d26 	beq	r2,zero,8230750 <t_connect+0x1dc>
 823071c:	e0bffb17 	ldw	r2,-20(fp)
 8230720:	1080088b 	ldhu	r2,34(r2)
 8230724:	10bfffcc 	andi	r2,r2,65535
 8230728:	1080010c 	andi	r2,r2,4
 823072c:	10000826 	beq	r2,zero,8230750 <t_connect+0x1dc>
   {
      so->so_error = EINPROGRESS;
 8230730:	e0bffb17 	ldw	r2,-20(fp)
 8230734:	00c01dc4 	movi	r3,119
 8230738:	10c00615 	stw	r3,24(r2)
      goto bad;
 823073c:	00000e06 	br	8230778 <t_connect+0x204>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 8230740:	e0bffb17 	ldw	r2,-20(fp)
 8230744:	10800904 	addi	r2,r2,36
 8230748:	1009883a 	mov	r4,r2
 823074c:	82291680 	call	8229168 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 8230750:	e0bffb17 	ldw	r2,-20(fp)
 8230754:	1080088b 	ldhu	r2,34(r2)
 8230758:	10bfffcc 	andi	r2,r2,65535
 823075c:	1080010c 	andi	r2,r2,4
 8230760:	10000526 	beq	r2,zero,8230778 <t_connect+0x204>
 8230764:	e0bffb17 	ldw	r2,-20(fp)
 8230768:	10800617 	ldw	r2,24(r2)
 823076c:	103ff426 	beq	r2,zero,8230740 <t_connect+0x1cc>
 8230770:	00000106 	br	8230778 <t_connect+0x204>
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   if ((so->so_error = soconnect (so, nam)) != 0)
      goto bad;
 8230774:	0001883a 	nop
   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 8230778:	e0bffb17 	ldw	r2,-20(fp)
 823077c:	10800617 	ldw	r2,24(r2)
 8230780:	10801de0 	cmpeqi	r2,r2,119
 8230784:	1000071e 	bne	r2,zero,82307a4 <t_connect+0x230>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 8230788:	e0bffb17 	ldw	r2,-20(fp)
 823078c:	10c0088b 	ldhu	r3,34(r2)
 8230790:	00b7fec4 	movi	r2,-8197
 8230794:	1884703a 	and	r2,r3,r2
 8230798:	1007883a 	mov	r3,r2
 823079c:	e0bffb17 	ldw	r2,-20(fp)
 82307a0:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 82307a4:	e13ffc17 	ldw	r4,-16(fp)
 82307a8:	822e26c0 	call	822e26c <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 82307ac:	0009883a 	mov	r4,zero
 82307b0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 82307b4:	e0bffb17 	ldw	r2,-20(fp)
 82307b8:	10800617 	ldw	r2,24(r2)
 82307bc:	10000226 	beq	r2,zero,82307c8 <t_connect+0x254>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 82307c0:	00bfffc4 	movi	r2,-1
 82307c4:	00000106 	br	82307cc <t_connect+0x258>

   }
      return 0;
 82307c8:	0005883a 	mov	r2,zero
}
 82307cc:	e037883a 	mov	sp,fp
 82307d0:	dfc00117 	ldw	ra,4(sp)
 82307d4:	df000017 	ldw	fp,0(sp)
 82307d8:	dec00204 	addi	sp,sp,8
 82307dc:	f800283a 	ret

082307e0 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 82307e0:	defffb04 	addi	sp,sp,-20
 82307e4:	dfc00415 	stw	ra,16(sp)
 82307e8:	df000315 	stw	fp,12(sp)
 82307ec:	df000304 	addi	fp,sp,12
 82307f0:	e13ffd15 	stw	r4,-12(fp)
 82307f4:	e17ffe15 	stw	r5,-8(fp)
 82307f8:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 82307fc:	01c00404 	movi	r7,16
 8230800:	e1bfff17 	ldw	r6,-4(fp)
 8230804:	e17ffe17 	ldw	r5,-8(fp)
 8230808:	e13ffd17 	ldw	r4,-12(fp)
 823080c:	82308680 	call	8230868 <t_getname>
}
 8230810:	e037883a 	mov	sp,fp
 8230814:	dfc00117 	ldw	ra,4(sp)
 8230818:	df000017 	ldw	fp,0(sp)
 823081c:	dec00204 	addi	sp,sp,8
 8230820:	f800283a 	ret

08230824 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 8230824:	defffb04 	addi	sp,sp,-20
 8230828:	dfc00415 	stw	ra,16(sp)
 823082c:	df000315 	stw	fp,12(sp)
 8230830:	df000304 	addi	fp,sp,12
 8230834:	e13ffd15 	stw	r4,-12(fp)
 8230838:	e17ffe15 	stw	r5,-8(fp)
 823083c:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 8230840:	01c003c4 	movi	r7,15
 8230844:	e1bfff17 	ldw	r6,-4(fp)
 8230848:	e17ffe17 	ldw	r5,-8(fp)
 823084c:	e13ffd17 	ldw	r4,-12(fp)
 8230850:	82308680 	call	8230868 <t_getname>
}
 8230854:	e037883a 	mov	sp,fp
 8230858:	dfc00117 	ldw	ra,4(sp)
 823085c:	df000017 	ldw	fp,0(sp)
 8230860:	dec00204 	addi	sp,sp,8
 8230864:	f800283a 	ret

08230868 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 8230868:	defff604 	addi	sp,sp,-40
 823086c:	dfc00915 	stw	ra,36(sp)
 8230870:	df000815 	stw	fp,32(sp)
 8230874:	df000804 	addi	fp,sp,32
 8230878:	e13ffc15 	stw	r4,-16(fp)
 823087c:	e17ffd15 	stw	r5,-12(fp)
 8230880:	e1bffe15 	stw	r6,-8(fp)
 8230884:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 8230888:	e0bffc17 	ldw	r2,-16(fp)
 823088c:	10bff804 	addi	r2,r2,-32
 8230890:	1085883a 	add	r2,r2,r2
 8230894:	1085883a 	add	r2,r2,r2
 8230898:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 823089c:	008209b4 	movhi	r2,2086
 82308a0:	10b7ef04 	addi	r2,r2,-8260
 82308a4:	e0bff815 	stw	r2,-32(fp)
 82308a8:	00000606 	br	82308c4 <t_getname+0x5c>
 82308ac:	e0fff817 	ldw	r3,-32(fp)
 82308b0:	e0bff917 	ldw	r2,-28(fp)
 82308b4:	18800626 	beq	r3,r2,82308d0 <t_getname+0x68>
 82308b8:	e0bff817 	ldw	r2,-32(fp)
 82308bc:	10800017 	ldw	r2,0(r2)
 82308c0:	e0bff815 	stw	r2,-32(fp)
 82308c4:	e0bff817 	ldw	r2,-32(fp)
 82308c8:	103ff81e 	bne	r2,zero,82308ac <t_getname+0x44>
 82308cc:	00000106 	br	82308d4 <t_getname+0x6c>
 82308d0:	0001883a 	nop
 82308d4:	e0fff817 	ldw	r3,-32(fp)
 82308d8:	e0bff917 	ldw	r2,-28(fp)
 82308dc:	18800326 	beq	r3,r2,82308ec <t_getname+0x84>
 82308e0:	822d1c80 	call	822d1c8 <dtrap>
 82308e4:	00bfffc4 	movi	r2,-1
 82308e8:	00005106 	br	8230a30 <t_getname+0x1c8>

   so->so_error = 0;
 82308ec:	e0bff917 	ldw	r2,-28(fp)
 82308f0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 82308f4:	e0bfff17 	ldw	r2,-4(fp)
 82308f8:	10800418 	cmpnei	r2,r2,16
 82308fc:	10000a1e 	bne	r2,zero,8230928 <t_getname+0xc0>
 8230900:	e0bff917 	ldw	r2,-28(fp)
 8230904:	1080088b 	ldhu	r2,34(r2)
 8230908:	10bfffcc 	andi	r2,r2,65535
 823090c:	1080008c 	andi	r2,r2,2
 8230910:	1000051e 	bne	r2,zero,8230928 <t_getname+0xc0>
   {
      so->so_error = ENOTCONN;
 8230914:	e0bff917 	ldw	r2,-28(fp)
 8230918:	00c02004 	movi	r3,128
 823091c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230920:	00bfffc4 	movi	r2,-1
 8230924:	00004206 	br	8230a30 <t_getname+0x1c8>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230928:	0009883a 	mov	r4,zero
 823092c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8230930:	01400404 	movi	r5,16
 8230934:	01000244 	movi	r4,9
 8230938:	822dfdc0 	call	822dfdc <m_getnbuf>
 823093c:	e0bffa15 	stw	r2,-24(fp)
   if (m == NULL) 
 8230940:	e0bffa17 	ldw	r2,-24(fp)
 8230944:	1000071e 	bne	r2,zero,8230964 <t_getname+0xfc>
   {
      so->so_error = ENOMEM;
 8230948:	e0bff917 	ldw	r2,-28(fp)
 823094c:	00c00304 	movi	r3,12
 8230950:	10c00615 	stw	r3,24(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230954:	0009883a 	mov	r4,zero
 8230958:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 823095c:	00bfffc4 	movi	r2,-1
 8230960:	00003306 	br	8230a30 <t_getname+0x1c8>
   }
   so->so_req = opcode;
 8230964:	e0bff917 	ldw	r2,-28(fp)
 8230968:	e0ffff17 	ldw	r3,-4(fp)
 823096c:	10c00715 	stw	r3,28(r2)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 8230970:	e0bff917 	ldw	r2,-28(fp)
 8230974:	10800217 	ldw	r2,8(r2)
 8230978:	10800317 	ldw	r2,12(r2)
 823097c:	e1bffa17 	ldw	r6,-24(fp)
 8230980:	000b883a 	mov	r5,zero
 8230984:	e13ff917 	ldw	r4,-28(fp)
 8230988:	103ee83a 	callr	r2
 823098c:	e0bffb15 	stw	r2,-20(fp)
 8230990:	e0bffb17 	ldw	r2,-20(fp)
 8230994:	1000191e 	bne	r2,zero,82309fc <t_getname+0x194>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 8230998:	e0bff917 	ldw	r2,-28(fp)
 823099c:	10800517 	ldw	r2,20(r2)
 82309a0:	10800098 	cmpnei	r2,r2,2
 82309a4:	1000161e 	bne	r2,zero,8230a00 <t_getname+0x198>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 82309a8:	e0bffe17 	ldw	r2,-8(fp)
 82309ac:	10800017 	ldw	r2,0(r2)
 82309b0:	10800428 	cmpgeui	r2,r2,16
 82309b4:	1000071e 	bne	r2,zero,82309d4 <t_getname+0x16c>
      {
         dtrap();    /* programming error */
 82309b8:	822d1c80 	call	822d1c8 <dtrap>
         m_freem(m);
 82309bc:	e13ffa17 	ldw	r4,-24(fp)
 82309c0:	822e26c0 	call	822e26c <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 82309c4:	0009883a 	mov	r4,zero
 82309c8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 82309cc:	00800584 	movi	r2,22
 82309d0:	00001706 	br	8230a30 <t_getname+0x1c8>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 82309d4:	e0bffa17 	ldw	r2,-24(fp)
 82309d8:	10800317 	ldw	r2,12(r2)
 82309dc:	01800404 	movi	r6,16
 82309e0:	100b883a 	mov	r5,r2
 82309e4:	e13ffd17 	ldw	r4,-12(fp)
 82309e8:	8202a0c0 	call	8202a0c <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 82309ec:	e0bffe17 	ldw	r2,-8(fp)
 82309f0:	00c00404 	movi	r3,16
 82309f4:	10c00015 	stw	r3,0(r2)
 82309f8:	00000106 	br	8230a00 <t_getname+0x198>
      UNLOCK_NET_RESOURCE(NET_RESID);
      return SOCKET_ERROR;
   }
   so->so_req = opcode;
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
      goto bad;
 82309fc:	0001883a 	nop
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 8230a00:	e13ffa17 	ldw	r4,-24(fp)
 8230a04:	822e26c0 	call	822e26c <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230a08:	0009883a 	mov	r4,zero
 8230a0c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230a10:	e0bffb17 	ldw	r2,-20(fp)
 8230a14:	10000526 	beq	r2,zero,8230a2c <t_getname+0x1c4>
   {
      so->so_error = err;
 8230a18:	e0bff917 	ldw	r2,-28(fp)
 8230a1c:	e0fffb17 	ldw	r3,-20(fp)
 8230a20:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230a24:	00bfffc4 	movi	r2,-1
 8230a28:	00000106 	br	8230a30 <t_getname+0x1c8>
   }
   return 0;
 8230a2c:	0005883a 	mov	r2,zero
}
 8230a30:	e037883a 	mov	sp,fp
 8230a34:	dfc00117 	ldw	ra,4(sp)
 8230a38:	df000017 	ldw	fp,0(sp)
 8230a3c:	dec00204 	addi	sp,sp,8
 8230a40:	f800283a 	ret

08230a44 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 8230a44:	defff704 	addi	sp,sp,-36
 8230a48:	dfc00815 	stw	ra,32(sp)
 8230a4c:	df000715 	stw	fp,28(sp)
 8230a50:	df000704 	addi	fp,sp,28
 8230a54:	e13ffc15 	stw	r4,-16(fp)
 8230a58:	e17ffd15 	stw	r5,-12(fp)
 8230a5c:	e1bffe15 	stw	r6,-8(fp)
 8230a60:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230a64:	e0bffc17 	ldw	r2,-16(fp)
 8230a68:	10bff804 	addi	r2,r2,-32
 8230a6c:	1085883a 	add	r2,r2,r2
 8230a70:	1085883a 	add	r2,r2,r2
 8230a74:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230a78:	008209b4 	movhi	r2,2086
 8230a7c:	10b7ef04 	addi	r2,r2,-8260
 8230a80:	e0bff915 	stw	r2,-28(fp)
 8230a84:	00000606 	br	8230aa0 <t_setsockopt+0x5c>
 8230a88:	e0fff917 	ldw	r3,-28(fp)
 8230a8c:	e0bffa17 	ldw	r2,-24(fp)
 8230a90:	18800626 	beq	r3,r2,8230aac <t_setsockopt+0x68>
 8230a94:	e0bff917 	ldw	r2,-28(fp)
 8230a98:	10800017 	ldw	r2,0(r2)
 8230a9c:	e0bff915 	stw	r2,-28(fp)
 8230aa0:	e0bff917 	ldw	r2,-28(fp)
 8230aa4:	103ff81e 	bne	r2,zero,8230a88 <t_setsockopt+0x44>
 8230aa8:	00000106 	br	8230ab0 <t_setsockopt+0x6c>
 8230aac:	0001883a 	nop
 8230ab0:	e0fff917 	ldw	r3,-28(fp)
 8230ab4:	e0bffa17 	ldw	r2,-24(fp)
 8230ab8:	18800326 	beq	r3,r2,8230ac8 <t_setsockopt+0x84>
 8230abc:	822d1c80 	call	822d1c8 <dtrap>
 8230ac0:	00bfffc4 	movi	r2,-1
 8230ac4:	00004a06 	br	8230bf0 <t_setsockopt+0x1ac>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230ac8:	0009883a 	mov	r4,zero
 8230acc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 8230ad0:	e0bffa17 	ldw	r2,-24(fp)
 8230ad4:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230ad8:	e0bffd17 	ldw	r2,-12(fp)
 8230adc:	10800060 	cmpeqi	r2,r2,1
 8230ae0:	10000e1e 	bne	r2,zero,8230b1c <t_setsockopt+0xd8>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 8230ae4:	e1bfff17 	ldw	r6,-4(fp)
 8230ae8:	e17ffe17 	ldw	r5,-8(fp)
 8230aec:	e13ffa17 	ldw	r4,-24(fp)
 8230af0:	8232d780 	call	8232d78 <sosetopt>
 8230af4:	e0bffb15 	stw	r2,-20(fp)
 8230af8:	e0bffb17 	ldw	r2,-20(fp)
 8230afc:	10003926 	beq	r2,zero,8230be4 <t_setsockopt+0x1a0>
      {
         so->so_error = err;
 8230b00:	e0bffa17 	ldw	r2,-24(fp)
 8230b04:	e0fffb17 	ldw	r3,-20(fp)
 8230b08:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230b0c:	0009883a 	mov	r4,zero
 8230b10:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230b14:	00bfffc4 	movi	r2,-1
 8230b18:	00003506 	br	8230bf0 <t_setsockopt+0x1ac>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 8230b1c:	e0bffa17 	ldw	r2,-24(fp)
 8230b20:	10801f17 	ldw	r2,124(r2)
 8230b24:	10000f1e 	bne	r2,zero,8230b64 <t_setsockopt+0x120>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 8230b28:	01000104 	movi	r4,4
 8230b2c:	822dda00 	call	822dda0 <npalloc>
 8230b30:	1007883a 	mov	r3,r2
 8230b34:	e0bffa17 	ldw	r2,-24(fp)
 8230b38:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 8230b3c:	e0bffa17 	ldw	r2,-24(fp)
 8230b40:	10801f17 	ldw	r2,124(r2)
 8230b44:	1000071e 	bne	r2,zero,8230b64 <t_setsockopt+0x120>
         {
            so->so_error = ENOMEM;
 8230b48:	e0bffa17 	ldw	r2,-24(fp)
 8230b4c:	00c00304 	movi	r3,12
 8230b50:	10c00615 	stw	r3,24(r2)
            UNLOCK_NET_RESOURCE (NET_RESID);
 8230b54:	0009883a 	mov	r4,zero
 8230b58:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 8230b5c:	00bfffc4 	movi	r2,-1
 8230b60:	00002306 	br	8230bf0 <t_setsockopt+0x1ac>
         }
      }
      
      if (name == IP_TTL_OPT)
 8230b64:	e0bffe17 	ldw	r2,-8(fp)
 8230b68:	10800118 	cmpnei	r2,r2,4
 8230b6c:	1000061e 	bne	r2,zero,8230b88 <t_setsockopt+0x144>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 8230b70:	e0bffa17 	ldw	r2,-24(fp)
 8230b74:	10801f17 	ldw	r2,124(r2)
 8230b78:	e0ffff17 	ldw	r3,-4(fp)
 8230b7c:	18c00017 	ldw	r3,0(r3)
 8230b80:	10c00045 	stb	r3,1(r2)
 8230b84:	00001706 	br	8230be4 <t_setsockopt+0x1a0>
      else
      if (name == IP_TOS)
 8230b88:	e0bffe17 	ldw	r2,-8(fp)
 8230b8c:	108000d8 	cmpnei	r2,r2,3
 8230b90:	1000061e 	bne	r2,zero,8230bac <t_setsockopt+0x168>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 8230b94:	e0bffa17 	ldw	r2,-24(fp)
 8230b98:	10801f17 	ldw	r2,124(r2)
 8230b9c:	e0ffff17 	ldw	r3,-4(fp)
 8230ba0:	18c00017 	ldw	r3,0(r3)
 8230ba4:	10c00005 	stb	r3,0(r2)
 8230ba8:	00000e06 	br	8230be4 <t_setsockopt+0x1a0>
	   else
	   if (name == IP_SCOPEID)
 8230bac:	e0bffe17 	ldw	r2,-8(fp)
 8230bb0:	10800398 	cmpnei	r2,r2,14
 8230bb4:	1000071e 	bne	r2,zero,8230bd4 <t_setsockopt+0x190>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 8230bb8:	e0bffa17 	ldw	r2,-24(fp)
 8230bbc:	10801f17 	ldw	r2,124(r2)
 8230bc0:	e0ffff17 	ldw	r3,-4(fp)
 8230bc4:	18c00017 	ldw	r3,0(r3)
 8230bc8:	18c03fcc 	andi	r3,r3,255
 8230bcc:	10c00115 	stw	r3,4(r2)
 8230bd0:	00000406 	br	8230be4 <t_setsockopt+0x1a0>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230bd4:	0009883a 	mov	r4,zero
 8230bd8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230bdc:	00bfffc4 	movi	r2,-1
 8230be0:	00000306 	br	8230bf0 <t_setsockopt+0x1ac>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230be4:	0009883a 	mov	r4,zero
 8230be8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return 0;
 8230bec:	0005883a 	mov	r2,zero
}
 8230bf0:	e037883a 	mov	sp,fp
 8230bf4:	dfc00117 	ldw	ra,4(sp)
 8230bf8:	df000017 	ldw	fp,0(sp)
 8230bfc:	dec00204 	addi	sp,sp,8
 8230c00:	f800283a 	ret

08230c04 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 8230c04:	defff704 	addi	sp,sp,-36
 8230c08:	dfc00815 	stw	ra,32(sp)
 8230c0c:	df000715 	stw	fp,28(sp)
 8230c10:	df000704 	addi	fp,sp,28
 8230c14:	e13ffc15 	stw	r4,-16(fp)
 8230c18:	e17ffd15 	stw	r5,-12(fp)
 8230c1c:	e1bffe15 	stw	r6,-8(fp)
 8230c20:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230c24:	e0bffc17 	ldw	r2,-16(fp)
 8230c28:	10bff804 	addi	r2,r2,-32
 8230c2c:	1085883a 	add	r2,r2,r2
 8230c30:	1085883a 	add	r2,r2,r2
 8230c34:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230c38:	008209b4 	movhi	r2,2086
 8230c3c:	10b7ef04 	addi	r2,r2,-8260
 8230c40:	e0bff915 	stw	r2,-28(fp)
 8230c44:	00000606 	br	8230c60 <t_getsockopt+0x5c>
 8230c48:	e0fff917 	ldw	r3,-28(fp)
 8230c4c:	e0bffa17 	ldw	r2,-24(fp)
 8230c50:	18800626 	beq	r3,r2,8230c6c <t_getsockopt+0x68>
 8230c54:	e0bff917 	ldw	r2,-28(fp)
 8230c58:	10800017 	ldw	r2,0(r2)
 8230c5c:	e0bff915 	stw	r2,-28(fp)
 8230c60:	e0bff917 	ldw	r2,-28(fp)
 8230c64:	103ff81e 	bne	r2,zero,8230c48 <t_getsockopt+0x44>
 8230c68:	00000106 	br	8230c70 <t_getsockopt+0x6c>
 8230c6c:	0001883a 	nop
 8230c70:	e0fff917 	ldw	r3,-28(fp)
 8230c74:	e0bffa17 	ldw	r2,-24(fp)
 8230c78:	18800326 	beq	r3,r2,8230c88 <t_getsockopt+0x84>
 8230c7c:	822d1c80 	call	822d1c8 <dtrap>
 8230c80:	00bfffc4 	movi	r2,-1
 8230c84:	00003d06 	br	8230d7c <t_getsockopt+0x178>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230c88:	0009883a 	mov	r4,zero
 8230c8c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230c90:	e0bffd17 	ldw	r2,-12(fp)
 8230c94:	10800060 	cmpeqi	r2,r2,1
 8230c98:	10000e1e 	bne	r2,zero,8230cd4 <t_getsockopt+0xd0>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 8230c9c:	e1bfff17 	ldw	r6,-4(fp)
 8230ca0:	e17ffe17 	ldw	r5,-8(fp)
 8230ca4:	e13ffa17 	ldw	r4,-24(fp)
 8230ca8:	82331a80 	call	82331a8 <sogetopt>
 8230cac:	e0bffb15 	stw	r2,-20(fp)
 8230cb0:	e0bffb17 	ldw	r2,-20(fp)
 8230cb4:	10002c26 	beq	r2,zero,8230d68 <t_getsockopt+0x164>
      {
         so->so_error = err;
 8230cb8:	e0bffa17 	ldw	r2,-24(fp)
 8230cbc:	e0fffb17 	ldw	r3,-20(fp)
 8230cc0:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230cc4:	0009883a 	mov	r4,zero
 8230cc8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230ccc:	00bfffc4 	movi	r2,-1
 8230cd0:	00002a06 	br	8230d7c <t_getsockopt+0x178>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 8230cd4:	e0bffe17 	ldw	r2,-8(fp)
 8230cd8:	10800118 	cmpnei	r2,r2,4
 8230cdc:	10000e1e 	bne	r2,zero,8230d18 <t_getsockopt+0x114>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 8230ce0:	e0bffa17 	ldw	r2,-24(fp)
 8230ce4:	10801f17 	ldw	r2,124(r2)
 8230ce8:	1000041e 	bne	r2,zero,8230cfc <t_getsockopt+0xf8>
 8230cec:	e0bfff17 	ldw	r2,-4(fp)
 8230cf0:	00c01004 	movi	r3,64
 8230cf4:	10c00015 	stw	r3,0(r2)
 8230cf8:	00001b06 	br	8230d68 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 8230cfc:	e0bffa17 	ldw	r2,-24(fp)
 8230d00:	10801f17 	ldw	r2,124(r2)
 8230d04:	10800043 	ldbu	r2,1(r2)
 8230d08:	10c03fcc 	andi	r3,r2,255
 8230d0c:	e0bfff17 	ldw	r2,-4(fp)
 8230d10:	10c00015 	stw	r3,0(r2)
 8230d14:	00001406 	br	8230d68 <t_getsockopt+0x164>
      }
      else if (name == IP_TOS)
 8230d18:	e0bffe17 	ldw	r2,-8(fp)
 8230d1c:	108000d8 	cmpnei	r2,r2,3
 8230d20:	10000d1e 	bne	r2,zero,8230d58 <t_getsockopt+0x154>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 8230d24:	e0bffa17 	ldw	r2,-24(fp)
 8230d28:	10801f17 	ldw	r2,124(r2)
 8230d2c:	1000031e 	bne	r2,zero,8230d3c <t_getsockopt+0x138>
 8230d30:	e0bfff17 	ldw	r2,-4(fp)
 8230d34:	10000015 	stw	zero,0(r2)
 8230d38:	00000b06 	br	8230d68 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 8230d3c:	e0bffa17 	ldw	r2,-24(fp)
 8230d40:	10801f17 	ldw	r2,124(r2)
 8230d44:	10800003 	ldbu	r2,0(r2)
 8230d48:	10c03fcc 	andi	r3,r2,255
 8230d4c:	e0bfff17 	ldw	r2,-4(fp)
 8230d50:	10c00015 	stw	r3,0(r2)
 8230d54:	00000406 	br	8230d68 <t_getsockopt+0x164>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230d58:	0009883a 	mov	r4,zero
 8230d5c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230d60:	00bfffc4 	movi	r2,-1
 8230d64:	00000506 	br	8230d7c <t_getsockopt+0x178>
      }
   }   
   so->so_error = 0;
 8230d68:	e0bffa17 	ldw	r2,-24(fp)
 8230d6c:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230d70:	0009883a 	mov	r4,zero
 8230d74:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return 0;
 8230d78:	0005883a 	mov	r2,zero
}
 8230d7c:	e037883a 	mov	sp,fp
 8230d80:	dfc00117 	ldw	ra,4(sp)
 8230d84:	df000017 	ldw	fp,0(sp)
 8230d88:	dec00204 	addi	sp,sp,8
 8230d8c:	f800283a 	ret

08230d90 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 8230d90:	defff604 	addi	sp,sp,-40
 8230d94:	dfc00915 	stw	ra,36(sp)
 8230d98:	df000815 	stw	fp,32(sp)
 8230d9c:	df000804 	addi	fp,sp,32
 8230da0:	e13ffc15 	stw	r4,-16(fp)
 8230da4:	e17ffd15 	stw	r5,-12(fp)
 8230da8:	e1bffe15 	stw	r6,-8(fp)
 8230dac:	e1ffff15 	stw	r7,-4(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 8230db0:	e0bffe17 	ldw	r2,-8(fp)
 8230db4:	e0bff915 	stw	r2,-28(fp)

   so = LONG2SO(s);
 8230db8:	e0bffc17 	ldw	r2,-16(fp)
 8230dbc:	10bff804 	addi	r2,r2,-32
 8230dc0:	1085883a 	add	r2,r2,r2
 8230dc4:	1085883a 	add	r2,r2,r2
 8230dc8:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 8230dcc:	e0bffa17 	ldw	r2,-24(fp)
 8230dd0:	1080088b 	ldhu	r2,34(r2)
 8230dd4:	10bfffcc 	andi	r2,r2,65535
 8230dd8:	1080038c 	andi	r2,r2,14
 8230ddc:	108000a0 	cmpeqi	r2,r2,2
 8230de0:	1000051e 	bne	r2,zero,8230df8 <t_recv+0x68>
   {
      so->so_error = EPIPE;
 8230de4:	e0bffa17 	ldw	r2,-24(fp)
 8230de8:	00c00804 	movi	r3,32
 8230dec:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230df0:	00bfffc4 	movi	r2,-1
 8230df4:	00001906 	br	8230e5c <t_recv+0xcc>
   }
   so->so_error = 0;
 8230df8:	e0bffa17 	ldw	r2,-24(fp)
 8230dfc:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8230e00:	0009883a 	mov	r4,zero
 8230e04:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 8230e08:	e0fffe04 	addi	r3,fp,-8
 8230e0c:	e0bfff17 	ldw	r2,-4(fp)
 8230e10:	d8800015 	stw	r2,0(sp)
 8230e14:	180f883a 	mov	r7,r3
 8230e18:	e1bffd17 	ldw	r6,-12(fp)
 8230e1c:	000b883a 	mov	r5,zero
 8230e20:	e13ffa17 	ldw	r4,-24(fp)
 8230e24:	82324980 	call	8232498 <soreceive>
 8230e28:	e0bffb15 	stw	r2,-20(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230e2c:	0009883a 	mov	r4,zero
 8230e30:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if(err)
 8230e34:	e0bffb17 	ldw	r2,-20(fp)
 8230e38:	10000526 	beq	r2,zero,8230e50 <t_recv+0xc0>
   {
      so->so_error = err;
 8230e3c:	e0bffa17 	ldw	r2,-24(fp)
 8230e40:	e0fffb17 	ldw	r3,-20(fp)
 8230e44:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230e48:	00bfffc4 	movi	r2,-1
 8230e4c:	00000306 	br	8230e5c <t_recv+0xcc>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 8230e50:	e0bffe17 	ldw	r2,-8(fp)
 8230e54:	e0fff917 	ldw	r3,-28(fp)
 8230e58:	1885c83a 	sub	r2,r3,r2
}
 8230e5c:	e037883a 	mov	sp,fp
 8230e60:	dfc00117 	ldw	ra,4(sp)
 8230e64:	df000017 	ldw	fp,0(sp)
 8230e68:	dec00204 	addi	sp,sp,8
 8230e6c:	f800283a 	ret

08230e70 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 8230e70:	defff404 	addi	sp,sp,-48
 8230e74:	dfc00b15 	stw	ra,44(sp)
 8230e78:	df000a15 	stw	fp,40(sp)
 8230e7c:	df000a04 	addi	fp,sp,40
 8230e80:	e13ffc15 	stw	r4,-16(fp)
 8230e84:	e17ffd15 	stw	r5,-12(fp)
 8230e88:	e1bffe15 	stw	r6,-8(fp)
 8230e8c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 8230e90:	e03ffb15 	stw	zero,-20(fp)
   int   err;
   int   sendlen = len;
 8230e94:	e0bffe17 	ldw	r2,-8(fp)
 8230e98:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 8230e9c:	e0bffc17 	ldw	r2,-16(fp)
 8230ea0:	10bff804 	addi	r2,r2,-32
 8230ea4:	1085883a 	add	r2,r2,r2
 8230ea8:	1085883a 	add	r2,r2,r2
 8230eac:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8230eb0:	008209b4 	movhi	r2,2086
 8230eb4:	10b7ef04 	addi	r2,r2,-8260
 8230eb8:	e0bff715 	stw	r2,-36(fp)
 8230ebc:	00000606 	br	8230ed8 <t_recvfrom+0x68>
 8230ec0:	e0fff717 	ldw	r3,-36(fp)
 8230ec4:	e0bff917 	ldw	r2,-28(fp)
 8230ec8:	18800626 	beq	r3,r2,8230ee4 <t_recvfrom+0x74>
 8230ecc:	e0bff717 	ldw	r2,-36(fp)
 8230ed0:	10800017 	ldw	r2,0(r2)
 8230ed4:	e0bff715 	stw	r2,-36(fp)
 8230ed8:	e0bff717 	ldw	r2,-36(fp)
 8230edc:	103ff81e 	bne	r2,zero,8230ec0 <t_recvfrom+0x50>
 8230ee0:	00000106 	br	8230ee8 <t_recvfrom+0x78>
 8230ee4:	0001883a 	nop
 8230ee8:	e0fff717 	ldw	r3,-36(fp)
 8230eec:	e0bff917 	ldw	r2,-28(fp)
 8230ef0:	18800326 	beq	r3,r2,8230f00 <t_recvfrom+0x90>
 8230ef4:	822d1c80 	call	822d1c8 <dtrap>
 8230ef8:	00bfffc4 	movi	r2,-1
 8230efc:	00002706 	br	8230f9c <t_recvfrom+0x12c>
   so->so_error = 0;
 8230f00:	e0bff917 	ldw	r2,-28(fp)
 8230f04:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8230f08:	0009883a 	mov	r4,zero
 8230f0c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 8230f10:	e13ffe04 	addi	r4,fp,-8
 8230f14:	e0fffb04 	addi	r3,fp,-20
 8230f18:	e0bfff17 	ldw	r2,-4(fp)
 8230f1c:	d8800015 	stw	r2,0(sp)
 8230f20:	200f883a 	mov	r7,r4
 8230f24:	e1bffd17 	ldw	r6,-12(fp)
 8230f28:	180b883a 	mov	r5,r3
 8230f2c:	e13ff917 	ldw	r4,-28(fp)
 8230f30:	82324980 	call	8232498 <soreceive>
 8230f34:	e0bffa15 	stw	r2,-24(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 8230f38:	e0bffb17 	ldw	r2,-20(fp)
 8230f3c:	10000b26 	beq	r2,zero,8230f6c <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 8230f40:	e0bffb17 	ldw	r2,-20(fp)
 8230f44:	10c00317 	ldw	r3,12(r2)
 8230f48:	e0800317 	ldw	r2,12(fp)
 8230f4c:	10800017 	ldw	r2,0(r2)
 8230f50:	100d883a 	mov	r6,r2
 8230f54:	180b883a 	mov	r5,r3
 8230f58:	e1000217 	ldw	r4,8(fp)
 8230f5c:	8202a0c0 	call	8202a0c <memcpy>
      m_freem (sender);
 8230f60:	e0bffb17 	ldw	r2,-20(fp)
 8230f64:	1009883a 	mov	r4,r2
 8230f68:	822e26c0 	call	822e26c <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8230f6c:	0009883a 	mov	r4,zero
 8230f70:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if(err)
 8230f74:	e0bffa17 	ldw	r2,-24(fp)
 8230f78:	10000526 	beq	r2,zero,8230f90 <t_recvfrom+0x120>
   {
      so->so_error = err;
 8230f7c:	e0bff917 	ldw	r2,-28(fp)
 8230f80:	e0fffa17 	ldw	r3,-24(fp)
 8230f84:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230f88:	00bfffc4 	movi	r2,-1
 8230f8c:	00000306 	br	8230f9c <t_recvfrom+0x12c>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 8230f90:	e0bffe17 	ldw	r2,-8(fp)
 8230f94:	e0fff817 	ldw	r3,-32(fp)
 8230f98:	1885c83a 	sub	r2,r3,r2
}
 8230f9c:	e037883a 	mov	sp,fp
 8230fa0:	dfc00117 	ldw	ra,4(sp)
 8230fa4:	df000017 	ldw	fp,0(sp)
 8230fa8:	dec00204 	addi	sp,sp,8
 8230fac:	f800283a 	ret

08230fb0 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 8230fb0:	defff404 	addi	sp,sp,-48
 8230fb4:	dfc00b15 	stw	ra,44(sp)
 8230fb8:	df000a15 	stw	fp,40(sp)
 8230fbc:	df000a04 	addi	fp,sp,40
 8230fc0:	e13ffc15 	stw	r4,-16(fp)
 8230fc4:	e17ffd15 	stw	r5,-12(fp)
 8230fc8:	e1bffe15 	stw	r6,-8(fp)
 8230fcc:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 8230fd0:	e0bffc17 	ldw	r2,-16(fp)
 8230fd4:	10bff804 	addi	r2,r2,-32
 8230fd8:	1085883a 	add	r2,r2,r2
 8230fdc:	1085883a 	add	r2,r2,r2
 8230fe0:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8230fe4:	008209b4 	movhi	r2,2086
 8230fe8:	10b7ef04 	addi	r2,r2,-8260
 8230fec:	e0bff815 	stw	r2,-32(fp)
 8230ff0:	00000606 	br	823100c <t_sendto+0x5c>
 8230ff4:	e0fff817 	ldw	r3,-32(fp)
 8230ff8:	e0bff917 	ldw	r2,-28(fp)
 8230ffc:	18800626 	beq	r3,r2,8231018 <t_sendto+0x68>
 8231000:	e0bff817 	ldw	r2,-32(fp)
 8231004:	10800017 	ldw	r2,0(r2)
 8231008:	e0bff815 	stw	r2,-32(fp)
 823100c:	e0bff817 	ldw	r2,-32(fp)
 8231010:	103ff81e 	bne	r2,zero,8230ff4 <t_sendto+0x44>
 8231014:	00000106 	br	823101c <t_sendto+0x6c>
 8231018:	0001883a 	nop
 823101c:	e0fff817 	ldw	r3,-32(fp)
 8231020:	e0bff917 	ldw	r2,-28(fp)
 8231024:	18800326 	beq	r3,r2,8231034 <t_sendto+0x84>
 8231028:	822d1c80 	call	822d1c8 <dtrap>
 823102c:	00bfffc4 	movi	r2,-1
 8231030:	00005706 	br	8231190 <t_sendto+0x1e0>
   so->so_error = 0;
 8231034:	e0bff917 	ldw	r2,-28(fp)
 8231038:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 823103c:	e0bff917 	ldw	r2,-28(fp)
 8231040:	10800983 	ldbu	r2,38(r2)
 8231044:	10803fcc 	andi	r2,r2,255
 8231048:	1080201c 	xori	r2,r2,128
 823104c:	10bfe004 	addi	r2,r2,-128
 8231050:	10c000a0 	cmpeqi	r3,r2,2
 8231054:	18000a1e 	bne	r3,zero,8231080 <t_sendto+0xd0>
 8231058:	10c000e0 	cmpeqi	r3,r2,3
 823105c:	18000b1e 	bne	r3,zero,823108c <t_sendto+0xdc>
 8231060:	10800060 	cmpeqi	r2,r2,1
 8231064:	10001026 	beq	r2,zero,82310a8 <t_sendto+0xf8>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 8231068:	e1ffff17 	ldw	r7,-4(fp)
 823106c:	e1bffe17 	ldw	r6,-8(fp)
 8231070:	e17ffd17 	ldw	r5,-12(fp)
 8231074:	e13ffc17 	ldw	r4,-16(fp)
 8231078:	82311a40 	call	82311a4 <t_send>
 823107c:	00004406 	br	8231190 <t_sendto+0x1e0>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 8231080:	82450f80 	call	82450f8 <udp_maxalloc>
 8231084:	e0bffb15 	stw	r2,-20(fp)
      break;
 8231088:	00000d06 	br	82310c0 <t_sendto+0x110>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 823108c:	e0bff917 	ldw	r2,-28(fp)
 8231090:	10800417 	ldw	r2,16(r2)
 8231094:	1088000c 	andi	r2,r2,8192
 8231098:	1009883a 	mov	r4,r2
 823109c:	8243de80 	call	8243de8 <ip_raw_maxalloc>
 82310a0:	e0bffb15 	stw	r2,-20(fp)
      break;
 82310a4:	00000606 	br	82310c0 <t_sendto+0x110>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 82310a8:	822d1c80 	call	822d1c8 <dtrap>
      so->so_error = EFAULT;
 82310ac:	e0bff917 	ldw	r2,-28(fp)
 82310b0:	00c00384 	movi	r3,14
 82310b4:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82310b8:	00bfffc4 	movi	r2,-1
 82310bc:	00003406 	br	8231190 <t_sendto+0x1e0>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 82310c0:	e0fffb17 	ldw	r3,-20(fp)
 82310c4:	e0bffe17 	ldw	r2,-8(fp)
 82310c8:	1880050e 	bge	r3,r2,82310e0 <t_sendto+0x130>
   {
      so->so_error = EMSGSIZE;
 82310cc:	e0bff917 	ldw	r2,-28(fp)
 82310d0:	00c01e84 	movi	r3,122
 82310d4:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82310d8:	00bfffc4 	movi	r2,-1
 82310dc:	00002c06 	br	8231190 <t_sendto+0x1e0>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 82310e0:	e0800217 	ldw	r2,8(fp)
 82310e4:	10000c26 	beq	r2,zero,8231118 <t_sendto+0x168>
   {
      name = sockargs(to, tolen, MT_SONAME);
 82310e8:	01800244 	movi	r6,9
 82310ec:	e1400317 	ldw	r5,12(fp)
 82310f0:	e1000217 	ldw	r4,8(fp)
 82310f4:	82315440 	call	8231544 <sockargs>
 82310f8:	e0bff715 	stw	r2,-36(fp)
      if(name == NULL)
 82310fc:	e0bff717 	ldw	r2,-36(fp)
 8231100:	1000061e 	bne	r2,zero,823111c <t_sendto+0x16c>
      {
         so->so_error = ENOMEM;
 8231104:	e0bff917 	ldw	r2,-28(fp)
 8231108:	00c00304 	movi	r3,12
 823110c:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8231110:	00bfffc4 	movi	r2,-1
 8231114:	00001e06 	br	8231190 <t_sendto+0x1e0>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 8231118:	e03ff715 	stw	zero,-36(fp)
   
   sendlen = len;
 823111c:	e0bffe17 	ldw	r2,-8(fp)
 8231120:	e0bffb15 	stw	r2,-20(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 8231124:	0009883a 	mov	r4,zero
 8231128:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 823112c:	e0fffb04 	addi	r3,fp,-20
 8231130:	e0bfff17 	ldw	r2,-4(fp)
 8231134:	d8800015 	stw	r2,0(sp)
 8231138:	180f883a 	mov	r7,r3
 823113c:	e1bffd17 	ldw	r6,-12(fp)
 8231140:	e17ff717 	ldw	r5,-36(fp)
 8231144:	e13ff917 	ldw	r4,-28(fp)
 8231148:	8231f400 	call	8231f40 <sosend>
 823114c:	e0bffa15 	stw	r2,-24(fp)

   if (name)
 8231150:	e0bff717 	ldw	r2,-36(fp)
 8231154:	10000226 	beq	r2,zero,8231160 <t_sendto+0x1b0>
      m_freem(name);
 8231158:	e13ff717 	ldw	r4,-36(fp)
 823115c:	822e26c0 	call	822e26c <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231160:	0009883a 	mov	r4,zero
 8231164:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231168:	e0bffa17 	ldw	r2,-24(fp)
 823116c:	10000526 	beq	r2,zero,8231184 <t_sendto+0x1d4>
   {
      so->so_error = err;
 8231170:	e0bff917 	ldw	r2,-28(fp)
 8231174:	e0fffa17 	ldw	r3,-24(fp)
 8231178:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 823117c:	00bfffc4 	movi	r2,-1
 8231180:	00000306 	br	8231190 <t_sendto+0x1e0>
   }

   return (len - sendlen);
 8231184:	e0bffb17 	ldw	r2,-20(fp)
 8231188:	e0fffe17 	ldw	r3,-8(fp)
 823118c:	1885c83a 	sub	r2,r3,r2
}
 8231190:	e037883a 	mov	sp,fp
 8231194:	dfc00117 	ldw	ra,4(sp)
 8231198:	df000017 	ldw	fp,0(sp)
 823119c:	dec00204 	addi	sp,sp,8
 82311a0:	f800283a 	ret

082311a4 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 82311a4:	defff104 	addi	sp,sp,-60
 82311a8:	dfc00e15 	stw	ra,56(sp)
 82311ac:	df000d15 	stw	fp,52(sp)
 82311b0:	df000d04 	addi	fp,sp,52
 82311b4:	e13ffc15 	stw	r4,-16(fp)
 82311b8:	e17ffd15 	stw	r5,-12(fp)
 82311bc:	e1bffe15 	stw	r6,-8(fp)
 82311c0:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 82311c4:	e03ff515 	stw	zero,-44(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 82311c8:	e0bffc17 	ldw	r2,-16(fp)
 82311cc:	10bff804 	addi	r2,r2,-32
 82311d0:	1085883a 	add	r2,r2,r2
 82311d4:	1085883a 	add	r2,r2,r2
 82311d8:	e0bff715 	stw	r2,-36(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 82311dc:	e0bff717 	ldw	r2,-36(fp)
 82311e0:	1080088b 	ldhu	r2,34(r2)
 82311e4:	10bfffcc 	andi	r2,r2,65535
 82311e8:	1080038c 	andi	r2,r2,14
 82311ec:	108000a0 	cmpeqi	r2,r2,2
 82311f0:	1000051e 	bne	r2,zero,8231208 <t_send+0x64>
   {
      so->so_error = EPIPE;
 82311f4:	e0bff717 	ldw	r2,-36(fp)
 82311f8:	00c00804 	movi	r3,32
 82311fc:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231200:	00bfffc4 	movi	r2,-1
 8231204:	00006306 	br	8231394 <t_send+0x1f0>
   }
   so->so_error = 0;
 8231208:	e0bff717 	ldw	r2,-36(fp)
 823120c:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 8231210:	e0bff717 	ldw	r2,-36(fp)
 8231214:	10800983 	ldbu	r2,38(r2)
 8231218:	10803fcc 	andi	r2,r2,255
 823121c:	1080201c 	xori	r2,r2,128
 8231220:	10bfe004 	addi	r2,r2,-128
 8231224:	10800060 	cmpeqi	r2,r2,1
 8231228:	1000081e 	bne	r2,zero,823124c <t_send+0xa8>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 823122c:	d8000115 	stw	zero,4(sp)
 8231230:	d8000015 	stw	zero,0(sp)
 8231234:	e1ffff17 	ldw	r7,-4(fp)
 8231238:	e1bffe17 	ldw	r6,-8(fp)
 823123c:	e17ffd17 	ldw	r5,-12(fp)
 8231240:	e13ffc17 	ldw	r4,-16(fp)
 8231244:	8230fb00 	call	8230fb0 <t_sendto>
 8231248:	00005206 	br	8231394 <t_send+0x1f0>

   maxpkt = TCP_MSS;
 823124c:	00816d04 	movi	r2,1460
 8231250:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 8231254:	e0bff717 	ldw	r2,-36(fp)
 8231258:	10800117 	ldw	r2,4(r2)
 823125c:	10004826 	beq	r2,zero,8231380 <t_send+0x1dc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 8231260:	e0bff717 	ldw	r2,-36(fp)
 8231264:	10800117 	ldw	r2,4(r2)
 8231268:	10800917 	ldw	r2,36(r2)
 823126c:	e0bff815 	stw	r2,-32(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 8231270:	e0bff817 	ldw	r2,-32(fp)
 8231274:	10800a0b 	ldhu	r2,40(r2)
 8231278:	10bfffcc 	andi	r2,r2,65535
 823127c:	10004026 	beq	r2,zero,8231380 <t_send+0x1dc>
         maxpkt = tp->t_maxseg;
 8231280:	e0bff817 	ldw	r2,-32(fp)
 8231284:	10800a0b 	ldhu	r2,40(r2)
 8231288:	10bfffcc 	andi	r2,r2,65535
 823128c:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 8231290:	00003b06 	br	8231380 <t_send+0x1dc>
   {
      if (len > maxpkt)
 8231294:	e0bffe17 	ldw	r2,-8(fp)
 8231298:	e0fff617 	ldw	r3,-40(fp)
 823129c:	1880030e 	bge	r3,r2,82312ac <t_send+0x108>
         sendlen = maxpkt;  /* take biggest block we can */
 82312a0:	e0bff617 	ldw	r2,-40(fp)
 82312a4:	e0bffb15 	stw	r2,-20(fp)
 82312a8:	00000206 	br	82312b4 <t_send+0x110>
      else
         sendlen = len;
 82312ac:	e0bffe17 	ldw	r2,-8(fp)
 82312b0:	e0bffb15 	stw	r2,-20(fp)
      sent = sendlen;
 82312b4:	e0bffb17 	ldw	r2,-20(fp)
 82312b8:	e0bff915 	stw	r2,-28(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 82312bc:	0009883a 	mov	r4,zero
 82312c0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 82312c4:	e0fffb04 	addi	r3,fp,-20
 82312c8:	e0bfff17 	ldw	r2,-4(fp)
 82312cc:	d8800015 	stw	r2,0(sp)
 82312d0:	180f883a 	mov	r7,r3
 82312d4:	e1bffd17 	ldw	r6,-12(fp)
 82312d8:	000b883a 	mov	r5,zero
 82312dc:	e13ff717 	ldw	r4,-36(fp)
 82312e0:	8231f400 	call	8231f40 <sosend>
 82312e4:	e0bffa15 	stw	r2,-24(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 82312e8:	0009883a 	mov	r4,zero
 82312ec:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 82312f0:	e0bffa17 	ldw	r2,-24(fp)
 82312f4:	10001026 	beq	r2,zero,8231338 <t_send+0x194>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 82312f8:	e0bffa17 	ldw	r2,-24(fp)
 82312fc:	10801a60 	cmpeqi	r2,r2,105
 8231300:	1000031e 	bne	r2,zero,8231310 <t_send+0x16c>
 8231304:	e0bffa17 	ldw	r2,-24(fp)
 8231308:	108002d8 	cmpnei	r2,r2,11
 823130c:	1000051e 	bne	r2,zero,8231324 <t_send+0x180>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 8231310:	e0bff517 	ldw	r2,-44(fp)
 8231314:	10000326 	beq	r2,zero,8231324 <t_send+0x180>
            {
               so->so_error = 0;
 8231318:	e0bff717 	ldw	r2,-36(fp)
 823131c:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 8231320:	00001b06 	br	8231390 <t_send+0x1ec>
            }
         }
         so->so_error = e;
 8231324:	e0bff717 	ldw	r2,-36(fp)
 8231328:	e0fffa17 	ldw	r3,-24(fp)
 823132c:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8231330:	00bfffc4 	movi	r2,-1
 8231334:	00001706 	br	8231394 <t_send+0x1f0>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 8231338:	e0bffb17 	ldw	r2,-20(fp)
 823133c:	1000131e 	bne	r2,zero,823138c <t_send+0x1e8>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 8231340:	e0bffb17 	ldw	r2,-20(fp)
 8231344:	e0fff917 	ldw	r3,-28(fp)
 8231348:	1885c83a 	sub	r2,r3,r2
 823134c:	e0bff915 	stw	r2,-28(fp)
      buf += sent;
 8231350:	e0bff917 	ldw	r2,-28(fp)
 8231354:	e0fffd17 	ldw	r3,-12(fp)
 8231358:	1885883a 	add	r2,r3,r2
 823135c:	e0bffd15 	stw	r2,-12(fp)
      len -= sent;
 8231360:	e0fffe17 	ldw	r3,-8(fp)
 8231364:	e0bff917 	ldw	r2,-28(fp)
 8231368:	1885c83a 	sub	r2,r3,r2
 823136c:	e0bffe15 	stw	r2,-8(fp)
      total_sent += sent;
 8231370:	e0fff517 	ldw	r3,-44(fp)
 8231374:	e0bff917 	ldw	r2,-28(fp)
 8231378:	1885883a 	add	r2,r3,r2
 823137c:	e0bff515 	stw	r2,-44(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 8231380:	e0bffe17 	ldw	r2,-8(fp)
 8231384:	103fc31e 	bne	r2,zero,8231294 <t_send+0xf0>
 8231388:	00000106 	br	8231390 <t_send+0x1ec>
         so->so_error = e;
         return SOCKET_ERROR;
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
         break;         /* break out of while(len) loop */
 823138c:	0001883a 	nop
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 8231390:	e0bff517 	ldw	r2,-44(fp)
}
 8231394:	e037883a 	mov	sp,fp
 8231398:	dfc00117 	ldw	ra,4(sp)
 823139c:	df000017 	ldw	fp,0(sp)
 82313a0:	dec00204 	addi	sp,sp,8
 82313a4:	f800283a 	ret

082313a8 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 82313a8:	defff904 	addi	sp,sp,-28
 82313ac:	dfc00615 	stw	ra,24(sp)
 82313b0:	df000515 	stw	fp,20(sp)
 82313b4:	df000504 	addi	fp,sp,20
 82313b8:	e13ffe15 	stw	r4,-8(fp)
 82313bc:	e17fff15 	stw	r5,-4(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 82313c0:	e0bffe17 	ldw	r2,-8(fp)
 82313c4:	10bff804 	addi	r2,r2,-32
 82313c8:	1085883a 	add	r2,r2,r2
 82313cc:	1085883a 	add	r2,r2,r2
 82313d0:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 82313d4:	008209b4 	movhi	r2,2086
 82313d8:	10b7ef04 	addi	r2,r2,-8260
 82313dc:	e0bffb15 	stw	r2,-20(fp)
 82313e0:	00000606 	br	82313fc <t_shutdown+0x54>
 82313e4:	e0fffb17 	ldw	r3,-20(fp)
 82313e8:	e0bffc17 	ldw	r2,-16(fp)
 82313ec:	18800626 	beq	r3,r2,8231408 <t_shutdown+0x60>
 82313f0:	e0bffb17 	ldw	r2,-20(fp)
 82313f4:	10800017 	ldw	r2,0(r2)
 82313f8:	e0bffb15 	stw	r2,-20(fp)
 82313fc:	e0bffb17 	ldw	r2,-20(fp)
 8231400:	103ff81e 	bne	r2,zero,82313e4 <t_shutdown+0x3c>
 8231404:	00000106 	br	823140c <t_shutdown+0x64>
 8231408:	0001883a 	nop
 823140c:	e0fffb17 	ldw	r3,-20(fp)
 8231410:	e0bffc17 	ldw	r2,-16(fp)
 8231414:	18800326 	beq	r3,r2,8231424 <t_shutdown+0x7c>
 8231418:	822d1c80 	call	822d1c8 <dtrap>
 823141c:	00bfffc4 	movi	r2,-1
 8231420:	00001206 	br	823146c <t_shutdown+0xc4>
   so->so_error = 0;
 8231424:	e0bffc17 	ldw	r2,-16(fp)
 8231428:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 823142c:	0009883a 	mov	r4,zero
 8231430:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 8231434:	e17fff17 	ldw	r5,-4(fp)
 8231438:	e13ffc17 	ldw	r4,-16(fp)
 823143c:	8232be40 	call	8232be4 <soshutdown>
 8231440:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231444:	0009883a 	mov	r4,zero
 8231448:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 823144c:	e0bffd17 	ldw	r2,-12(fp)
 8231450:	10000526 	beq	r2,zero,8231468 <t_shutdown+0xc0>
   {
      so->so_error = err;
 8231454:	e0bffc17 	ldw	r2,-16(fp)
 8231458:	e0fffd17 	ldw	r3,-12(fp)
 823145c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231460:	00bfffc4 	movi	r2,-1
 8231464:	00000106 	br	823146c <t_shutdown+0xc4>
   }
   return 0;
 8231468:	0005883a 	mov	r2,zero
}
 823146c:	e037883a 	mov	sp,fp
 8231470:	dfc00117 	ldw	ra,4(sp)
 8231474:	df000017 	ldw	fp,0(sp)
 8231478:	dec00204 	addi	sp,sp,8
 823147c:	f800283a 	ret

08231480 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 8231480:	defffa04 	addi	sp,sp,-24
 8231484:	dfc00515 	stw	ra,20(sp)
 8231488:	df000415 	stw	fp,16(sp)
 823148c:	df000404 	addi	fp,sp,16
 8231490:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8231494:	e0bfff17 	ldw	r2,-4(fp)
 8231498:	10bff804 	addi	r2,r2,-32
 823149c:	1085883a 	add	r2,r2,r2
 82314a0:	1085883a 	add	r2,r2,r2
 82314a4:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 82314a8:	008209b4 	movhi	r2,2086
 82314ac:	10b7ef04 	addi	r2,r2,-8260
 82314b0:	e0bffc15 	stw	r2,-16(fp)
 82314b4:	00000606 	br	82314d0 <t_socketclose+0x50>
 82314b8:	e0fffc17 	ldw	r3,-16(fp)
 82314bc:	e0bffd17 	ldw	r2,-12(fp)
 82314c0:	18800626 	beq	r3,r2,82314dc <t_socketclose+0x5c>
 82314c4:	e0bffc17 	ldw	r2,-16(fp)
 82314c8:	10800017 	ldw	r2,0(r2)
 82314cc:	e0bffc15 	stw	r2,-16(fp)
 82314d0:	e0bffc17 	ldw	r2,-16(fp)
 82314d4:	103ff81e 	bne	r2,zero,82314b8 <t_socketclose+0x38>
 82314d8:	00000106 	br	82314e0 <t_socketclose+0x60>
 82314dc:	0001883a 	nop
 82314e0:	e0fffc17 	ldw	r3,-16(fp)
 82314e4:	e0bffd17 	ldw	r2,-12(fp)
 82314e8:	18800326 	beq	r3,r2,82314f8 <t_socketclose+0x78>
 82314ec:	822d1c80 	call	822d1c8 <dtrap>
 82314f0:	00bfffc4 	movi	r2,-1
 82314f4:	00000e06 	br	8231530 <t_socketclose+0xb0>
   so->so_error = 0;
 82314f8:	e0bffd17 	ldw	r2,-12(fp)
 82314fc:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 8231500:	0009883a 	mov	r4,zero
 8231504:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   err = soclose(so);
 8231508:	e13ffd17 	ldw	r4,-12(fp)
 823150c:	8231a4c0 	call	8231a4c <soclose>
 8231510:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231514:	0009883a 	mov	r4,zero
 8231518:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 823151c:	e0bffe17 	ldw	r2,-8(fp)
 8231520:	10000226 	beq	r2,zero,823152c <t_socketclose+0xac>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 8231524:	00bfffc4 	movi	r2,-1
 8231528:	00000106 	br	8231530 <t_socketclose+0xb0>
   }
   return 0;
 823152c:	0005883a 	mov	r2,zero
}
 8231530:	e037883a 	mov	sp,fp
 8231534:	dfc00117 	ldw	ra,4(sp)
 8231538:	df000017 	ldw	fp,0(sp)
 823153c:	dec00204 	addi	sp,sp,8
 8231540:	f800283a 	ret

08231544 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 8231544:	defffa04 	addi	sp,sp,-24
 8231548:	dfc00515 	stw	ra,20(sp)
 823154c:	df000415 	stw	fp,16(sp)
 8231550:	df000404 	addi	fp,sp,16
 8231554:	e13ffd15 	stw	r4,-12(fp)
 8231558:	e17ffe15 	stw	r5,-8(fp)
 823155c:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 8231560:	0009883a 	mov	r4,zero
 8231564:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 8231568:	e17ffe17 	ldw	r5,-8(fp)
 823156c:	e13fff17 	ldw	r4,-4(fp)
 8231570:	822dfdc0 	call	822dfdc <m_getnbuf>
 8231574:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231578:	0009883a 	mov	r4,zero
 823157c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 8231580:	e0bffc17 	ldw	r2,-16(fp)
 8231584:	1000021e 	bne	r2,zero,8231590 <sockargs+0x4c>
      return NULL;
 8231588:	0005883a 	mov	r2,zero
 823158c:	00000b06 	br	82315bc <sockargs+0x78>
   m->m_len = arglen;
 8231590:	e0fffe17 	ldw	r3,-8(fp)
 8231594:	e0bffc17 	ldw	r2,-16(fp)
 8231598:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 823159c:	e0bffc17 	ldw	r2,-16(fp)
 82315a0:	10800317 	ldw	r2,12(r2)
 82315a4:	e0fffe17 	ldw	r3,-8(fp)
 82315a8:	180d883a 	mov	r6,r3
 82315ac:	e17ffd17 	ldw	r5,-12(fp)
 82315b0:	1009883a 	mov	r4,r2
 82315b4:	8202a0c0 	call	8202a0c <memcpy>
   return m;
 82315b8:	e0bffc17 	ldw	r2,-16(fp)
}
 82315bc:	e037883a 	mov	sp,fp
 82315c0:	dfc00117 	ldw	ra,4(sp)
 82315c4:	df000017 	ldw	fp,0(sp)
 82315c8:	dec00204 	addi	sp,sp,8
 82315cc:	f800283a 	ret

082315d0 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 82315d0:	defffa04 	addi	sp,sp,-24
 82315d4:	dfc00515 	stw	ra,20(sp)
 82315d8:	df000415 	stw	fp,16(sp)
 82315dc:	df000404 	addi	fp,sp,16
 82315e0:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 82315e4:	e0bfff17 	ldw	r2,-4(fp)
 82315e8:	10bff804 	addi	r2,r2,-32
 82315ec:	1085883a 	add	r2,r2,r2
 82315f0:	1085883a 	add	r2,r2,r2
 82315f4:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 82315f8:	00801b04 	movi	r2,108
 82315fc:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 8231600:	0009883a 	mov	r4,zero
 8231604:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231608:	008209b4 	movhi	r2,2086
 823160c:	10b7ef04 	addi	r2,r2,-8260
 8231610:	e0bffc15 	stw	r2,-16(fp)
 8231614:	00000a06 	br	8231640 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 8231618:	e0fffc17 	ldw	r3,-16(fp)
 823161c:	e0bffe17 	ldw	r2,-8(fp)
 8231620:	1880041e 	bne	r3,r2,8231634 <t_errno+0x64>
      {
         errcode = so->so_error;
 8231624:	e0bffe17 	ldw	r2,-8(fp)
 8231628:	10800617 	ldw	r2,24(r2)
 823162c:	e0bffd15 	stw	r2,-12(fp)
         break;
 8231630:	00000506 	br	8231648 <t_errno+0x78>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231634:	e0bffc17 	ldw	r2,-16(fp)
 8231638:	10800017 	ldw	r2,0(r2)
 823163c:	e0bffc15 	stw	r2,-16(fp)
 8231640:	e0bffc17 	ldw	r2,-16(fp)
 8231644:	103ff41e 	bne	r2,zero,8231618 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231648:	0009883a 	mov	r4,zero
 823164c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   return errcode;
 8231650:	e0bffd17 	ldw	r2,-12(fp)
}
 8231654:	e037883a 	mov	sp,fp
 8231658:	dfc00117 	ldw	ra,4(sp)
 823165c:	df000017 	ldw	fp,0(sp)
 8231660:	dec00204 	addi	sp,sp,8
 8231664:	f800283a 	ret

08231668 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 8231668:	defff704 	addi	sp,sp,-36
 823166c:	dfc00815 	stw	ra,32(sp)
 8231670:	df000715 	stw	fp,28(sp)
 8231674:	df000704 	addi	fp,sp,28
 8231678:	e13ffd15 	stw	r4,-12(fp)
 823167c:	e17ffe15 	stw	r5,-8(fp)
 8231680:	e1bfff15 	stw	r6,-4(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 8231684:	e0bfff17 	ldw	r2,-4(fp)
 8231688:	10000626 	beq	r2,zero,82316a4 <socreate+0x3c>
      prp = pffindproto(dom, proto, type);
 823168c:	e1bffe17 	ldw	r6,-8(fp)
 8231690:	e17fff17 	ldw	r5,-4(fp)
 8231694:	e13ffd17 	ldw	r4,-12(fp)
 8231698:	822df180 	call	822df18 <pffindproto>
 823169c:	e0bff915 	stw	r2,-28(fp)
 82316a0:	00000406 	br	82316b4 <socreate+0x4c>
   else
      prp = pffindtype(dom, type);
 82316a4:	e17ffe17 	ldw	r5,-8(fp)
 82316a8:	e13ffd17 	ldw	r4,-12(fp)
 82316ac:	822de880 	call	822de88 <pffindtype>
 82316b0:	e0bff915 	stw	r2,-28(fp)
   if (prp == 0)
 82316b4:	e0bff917 	ldw	r2,-28(fp)
 82316b8:	1000021e 	bne	r2,zero,82316c4 <socreate+0x5c>
      return NULL;
 82316bc:	0005883a 	mov	r2,zero
 82316c0:	00004e06 	br	82317fc <socreate+0x194>
   if (prp->pr_type != type)
 82316c4:	e0bff917 	ldw	r2,-28(fp)
 82316c8:	1080000b 	ldhu	r2,0(r2)
 82316cc:	10ffffcc 	andi	r3,r2,65535
 82316d0:	18e0001c 	xori	r3,r3,32768
 82316d4:	18e00004 	addi	r3,r3,-32768
 82316d8:	e0bffe17 	ldw	r2,-8(fp)
 82316dc:	18800226 	beq	r3,r2,82316e8 <socreate+0x80>
      return NULL;
 82316e0:	0005883a 	mov	r2,zero
 82316e4:	00004506 	br	82317fc <socreate+0x194>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 82316e8:	01002104 	movi	r4,132
 82316ec:	822dda00 	call	822dda0 <npalloc>
 82316f0:	e0bffa15 	stw	r2,-24(fp)
 82316f4:	e0bffa17 	ldw	r2,-24(fp)
 82316f8:	1000021e 	bne	r2,zero,8231704 <socreate+0x9c>
      return NULL;
 82316fc:	0005883a 	mov	r2,zero
 8231700:	00003e06 	br	82317fc <socreate+0x194>
   so->next = NULL;
 8231704:	e0bffa17 	ldw	r2,-24(fp)
 8231708:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 823170c:	e17ffa17 	ldw	r5,-24(fp)
 8231710:	010209b4 	movhi	r4,2086
 8231714:	2137ef04 	addi	r4,r4,-8260
 8231718:	822cbb00 	call	822cbb0 <putq>

   so->so_options = socket_defaults;
 823171c:	d0a03c0b 	ldhu	r2,-32528(gp)
 8231720:	10ffffcc 	andi	r3,r2,65535
 8231724:	e0bffa17 	ldw	r2,-24(fp)
 8231728:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 823172c:	e0bffa17 	ldw	r2,-24(fp)
 8231730:	e0fffd17 	ldw	r3,-12(fp)
 8231734:	10c00515 	stw	r3,20(r2)
   so->so_state = 0;
 8231738:	e0bffa17 	ldw	r2,-24(fp)
 823173c:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 8231740:	e0bffe17 	ldw	r2,-8(fp)
 8231744:	1007883a 	mov	r3,r2
 8231748:	e0bffa17 	ldw	r2,-24(fp)
 823174c:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 8231750:	e0bffa17 	ldw	r2,-24(fp)
 8231754:	e0fff917 	ldw	r3,-28(fp)
 8231758:	10c00215 	stw	r3,8(r2)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 823175c:	e0bffa17 	ldw	r2,-24(fp)
 8231760:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 8231764:	e0bffa17 	ldw	r2,-24(fp)
 8231768:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 823176c:	e0bff917 	ldw	r2,-28(fp)
 8231770:	10800317 	ldw	r2,12(r2)
 8231774:	e0ffff17 	ldw	r3,-4(fp)
 8231778:	180d883a 	mov	r6,r3
 823177c:	000b883a 	mov	r5,zero
 8231780:	e13ffa17 	ldw	r4,-24(fp)
 8231784:	103ee83a 	callr	r2
 8231788:	e0bffb15 	stw	r2,-20(fp)
   if (error) goto bad;
 823178c:	e0bffb17 	ldw	r2,-20(fp)
 8231790:	10000a1e 	bne	r2,zero,82317bc <socreate+0x154>

   if (so_evtmap)
 8231794:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231798:	10803fcc 	andi	r2,r2,255
 823179c:	10001626 	beq	r2,zero,82317f8 <socreate+0x190>
   {                       
      rc = (*so_evtmap_create) (so);
 82317a0:	d0a0cc17 	ldw	r2,-31952(gp)
 82317a4:	e13ffa17 	ldw	r4,-24(fp)
 82317a8:	103ee83a 	callr	r2
 82317ac:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0)
 82317b0:	e0bffc17 	ldw	r2,-16(fp)
 82317b4:	10000c26 	beq	r2,zero,82317e8 <socreate+0x180>
 82317b8:	00000106 	br	82317c0 <socreate+0x158>
   so->inp_moptions = NULL;
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
   if (error) goto bad;
 82317bc:	0001883a 	nop
   {                       
      rc = (*so_evtmap_create) (so);
      if (rc != 0)
      {
bad:   
         so->so_state |= SS_NOFDREF;
 82317c0:	e0bffa17 	ldw	r2,-24(fp)
 82317c4:	1080088b 	ldhu	r2,34(r2)
 82317c8:	10800054 	ori	r2,r2,1
 82317cc:	1007883a 	mov	r3,r2
 82317d0:	e0bffa17 	ldw	r2,-24(fp)
 82317d4:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 82317d8:	e13ffa17 	ldw	r4,-24(fp)
 82317dc:	823193c0 	call	823193c <sofree>
         return NULL;   
 82317e0:	0005883a 	mov	r2,zero
 82317e4:	00000506 	br	82317fc <socreate+0x194>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 82317e8:	82293d40 	call	82293d4 <TK_OSTaskQuery>
 82317ec:	1007883a 	mov	r3,r2
 82317f0:	e0bffa17 	ldw	r2,-24(fp)
 82317f4:	10c02005 	stb	r3,128(r2)
   }

   return so;
 82317f8:	e0bffa17 	ldw	r2,-24(fp)
}
 82317fc:	e037883a 	mov	sp,fp
 8231800:	dfc00117 	ldw	ra,4(sp)
 8231804:	df000017 	ldw	fp,0(sp)
 8231808:	dec00204 	addi	sp,sp,8
 823180c:	f800283a 	ret

08231810 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 8231810:	defffb04 	addi	sp,sp,-20
 8231814:	dfc00415 	stw	ra,16(sp)
 8231818:	df000315 	stw	fp,12(sp)
 823181c:	df000304 	addi	fp,sp,12
 8231820:	e13ffe15 	stw	r4,-8(fp)
 8231824:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 8231828:	e0bffe17 	ldw	r2,-8(fp)
 823182c:	00c00084 	movi	r3,2
 8231830:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231834:	e0bffe17 	ldw	r2,-8(fp)
 8231838:	10800217 	ldw	r2,8(r2)
 823183c:	10800317 	ldw	r2,12(r2)
 8231840:	e1bfff17 	ldw	r6,-4(fp)
 8231844:	000b883a 	mov	r5,zero
 8231848:	e13ffe17 	ldw	r4,-8(fp)
 823184c:	103ee83a 	callr	r2
 8231850:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 8231854:	e0bffd17 	ldw	r2,-12(fp)
}
 8231858:	e037883a 	mov	sp,fp
 823185c:	dfc00117 	ldw	ra,4(sp)
 8231860:	df000017 	ldw	fp,0(sp)
 8231864:	dec00204 	addi	sp,sp,8
 8231868:	f800283a 	ret

0823186c <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 823186c:	defffb04 	addi	sp,sp,-20
 8231870:	dfc00415 	stw	ra,16(sp)
 8231874:	df000315 	stw	fp,12(sp)
 8231878:	df000304 	addi	fp,sp,12
 823187c:	e13ffe15 	stw	r4,-8(fp)
 8231880:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 8231884:	e0bffe17 	ldw	r2,-8(fp)
 8231888:	00c000c4 	movi	r3,3
 823188c:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so,
 8231890:	e0bffe17 	ldw	r2,-8(fp)
 8231894:	10800217 	ldw	r2,8(r2)
 8231898:	10800317 	ldw	r2,12(r2)
 823189c:	000d883a 	mov	r6,zero
 82318a0:	000b883a 	mov	r5,zero
 82318a4:	e13ffe17 	ldw	r4,-8(fp)
 82318a8:	103ee83a 	callr	r2
 82318ac:	e0bffd15 	stw	r2,-12(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 82318b0:	e0bffd17 	ldw	r2,-12(fp)
 82318b4:	10000226 	beq	r2,zero,82318c0 <solisten+0x54>
   {
      return (error);
 82318b8:	e0bffd17 	ldw	r2,-12(fp)
 82318bc:	00001a06 	br	8231928 <solisten+0xbc>
   }
   if (so->so_q == 0) 
 82318c0:	e0bffe17 	ldw	r2,-8(fp)
 82318c4:	10801d17 	ldw	r2,116(r2)
 82318c8:	10000b1e 	bne	r2,zero,82318f8 <solisten+0x8c>
   {
      so->so_q = so;
 82318cc:	e0bffe17 	ldw	r2,-8(fp)
 82318d0:	e0fffe17 	ldw	r3,-8(fp)
 82318d4:	10c01d15 	stw	r3,116(r2)
      so->so_q0 = so;
 82318d8:	e0bffe17 	ldw	r2,-8(fp)
 82318dc:	e0fffe17 	ldw	r3,-8(fp)
 82318e0:	10c01c15 	stw	r3,112(r2)
      so->so_options |= SO_ACCEPTCONN;
 82318e4:	e0bffe17 	ldw	r2,-8(fp)
 82318e8:	10800417 	ldw	r2,16(r2)
 82318ec:	10c00094 	ori	r3,r2,2
 82318f0:	e0bffe17 	ldw	r2,-8(fp)
 82318f4:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 82318f8:	e0bfff17 	ldw	r2,-4(fp)
 82318fc:	1000010e 	bge	r2,zero,8231904 <solisten+0x98>
      backlog = 0;
 8231900:	e03fff15 	stw	zero,-4(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 8231904:	e0bfff17 	ldw	r2,-4(fp)
 8231908:	10800188 	cmpgei	r2,r2,6
 823190c:	1000021e 	bne	r2,zero,8231918 <solisten+0xac>
 8231910:	e0bfff17 	ldw	r2,-4(fp)
 8231914:	00000106 	br	823191c <solisten+0xb0>
 8231918:	00800144 	movi	r2,5
 823191c:	e0fffe17 	ldw	r3,-8(fp)
 8231920:	18801e85 	stb	r2,122(r3)
   return 0;
 8231924:	0005883a 	mov	r2,zero
}
 8231928:	e037883a 	mov	sp,fp
 823192c:	dfc00117 	ldw	ra,4(sp)
 8231930:	df000017 	ldw	fp,0(sp)
 8231934:	dec00204 	addi	sp,sp,8
 8231938:	f800283a 	ret

0823193c <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 823193c:	defffd04 	addi	sp,sp,-12
 8231940:	dfc00215 	stw	ra,8(sp)
 8231944:	df000115 	stw	fp,4(sp)
 8231948:	df000104 	addi	fp,sp,4
 823194c:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 8231950:	e0bfff17 	ldw	r2,-4(fp)
 8231954:	10800117 	ldw	r2,4(r2)
 8231958:	1000361e 	bne	r2,zero,8231a34 <sofree+0xf8>
 823195c:	e0bfff17 	ldw	r2,-4(fp)
 8231960:	1080088b 	ldhu	r2,34(r2)
 8231964:	10bfffcc 	andi	r2,r2,65535
 8231968:	1080004c 	andi	r2,r2,1
 823196c:	10003126 	beq	r2,zero,8231a34 <sofree+0xf8>
      return;
   if (so->so_head) 
 8231970:	e0bfff17 	ldw	r2,-4(fp)
 8231974:	10801b17 	ldw	r2,108(r2)
 8231978:	10000d26 	beq	r2,zero,82319b0 <sofree+0x74>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 823197c:	000b883a 	mov	r5,zero
 8231980:	e13fff17 	ldw	r4,-4(fp)
 8231984:	8233c180 	call	8233c18 <soqremque>
 8231988:	1000071e 	bne	r2,zero,82319a8 <sofree+0x6c>
 823198c:	01400044 	movi	r5,1
 8231990:	e13fff17 	ldw	r4,-4(fp)
 8231994:	8233c180 	call	8233c18 <soqremque>
 8231998:	1000031e 	bne	r2,zero,82319a8 <sofree+0x6c>
         panic("sofree");
 823199c:	01020974 	movhi	r4,2085
 82319a0:	21020d04 	addi	r4,r4,2100
 82319a4:	822887c0 	call	822887c <panic>
      so->so_head = 0;
 82319a8:	e0bfff17 	ldw	r2,-4(fp)
 82319ac:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 82319b0:	e0bfff17 	ldw	r2,-4(fp)
 82319b4:	10801204 	addi	r2,r2,72
 82319b8:	1009883a 	mov	r4,r2
 82319bc:	8233fdc0 	call	8233fdc <sbrelease>
   sorflush(so);
 82319c0:	e13fff17 	ldw	r4,-4(fp)
 82319c4:	8232c7c0 	call	8232c7c <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 82319c8:	e0bfff17 	ldw	r2,-4(fp)
 82319cc:	10800317 	ldw	r2,12(r2)
 82319d0:	10000426 	beq	r2,zero,82319e4 <sofree+0xa8>
	   ip_freemoptions(so->inp_moptions);
 82319d4:	e0bfff17 	ldw	r2,-4(fp)
 82319d8:	10800317 	ldw	r2,12(r2)
 82319dc:	1009883a 	mov	r4,r2
 82319e0:	82462d00 	call	82462d0 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 82319e4:	e0bfff17 	ldw	r2,-4(fp)
 82319e8:	10801f17 	ldw	r2,124(r2)
 82319ec:	10000426 	beq	r2,zero,8231a00 <sofree+0xc4>
      SOCOPT_FREE(so->so_optsPack);
 82319f0:	e0bfff17 	ldw	r2,-4(fp)
 82319f4:	10801f17 	ldw	r2,124(r2)
 82319f8:	1009883a 	mov	r4,r2
 82319fc:	822ddd40 	call	822ddd4 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8231a00:	e17fff17 	ldw	r5,-4(fp)
 8231a04:	010209b4 	movhi	r4,2086
 8231a08:	2137ef04 	addi	r4,r4,-8260
 8231a0c:	822cc600 	call	822cc60 <qdel>
   
   if (so_evtmap)  
 8231a10:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231a14:	10803fcc 	andi	r2,r2,255
 8231a18:	10000326 	beq	r2,zero,8231a28 <sofree+0xec>
      (*so_evtmap_delete) (so);
 8231a1c:	d0a0cd17 	ldw	r2,-31948(gp)
 8231a20:	e13fff17 	ldw	r4,-4(fp)
 8231a24:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 8231a28:	e13fff17 	ldw	r4,-4(fp)
 8231a2c:	822ddd40 	call	822ddd4 <npfree>
 8231a30:	00000106 	br	8231a38 <sofree+0xfc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
      return;
 8231a34:	0001883a 	nop
   
   if (so_evtmap)  
      (*so_evtmap_delete) (so);
   
   SOC_FREE(so);
}
 8231a38:	e037883a 	mov	sp,fp
 8231a3c:	dfc00117 	ldw	ra,4(sp)
 8231a40:	df000017 	ldw	fp,0(sp)
 8231a44:	dec00204 	addi	sp,sp,8
 8231a48:	f800283a 	ret

08231a4c <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 8231a4c:	defff904 	addi	sp,sp,-28
 8231a50:	dfc00615 	stw	ra,24(sp)
 8231a54:	df000515 	stw	fp,20(sp)
 8231a58:	df000504 	addi	fp,sp,20
 8231a5c:	e13fff15 	stw	r4,-4(fp)
   int   error =  0;
 8231a60:	e03ffb15 	stw	zero,-20(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231a64:	008209b4 	movhi	r2,2086
 8231a68:	10b7ef04 	addi	r2,r2,-8260
 8231a6c:	10800017 	ldw	r2,0(r2)
 8231a70:	e0bffc15 	stw	r2,-16(fp)
 8231a74:	00000606 	br	8231a90 <soclose+0x44>
   {
      if (so == tmpso)
 8231a78:	e0ffff17 	ldw	r3,-4(fp)
 8231a7c:	e0bffc17 	ldw	r2,-16(fp)
 8231a80:	18800626 	beq	r3,r2,8231a9c <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231a84:	e0bffc17 	ldw	r2,-16(fp)
 8231a88:	10800017 	ldw	r2,0(r2)
 8231a8c:	e0bffc15 	stw	r2,-16(fp)
 8231a90:	e0bffc17 	ldw	r2,-16(fp)
 8231a94:	103ff81e 	bne	r2,zero,8231a78 <soclose+0x2c>
 8231a98:	00000106 	br	8231aa0 <soclose+0x54>
   {
      if (so == tmpso)
         break;
 8231a9c:	0001883a 	nop
   }
   if ( tmpso == NULL)
 8231aa0:	e0bffc17 	ldw	r2,-16(fp)
 8231aa4:	1000021e 	bne	r2,zero,8231ab0 <soclose+0x64>
      return EINVAL;
 8231aa8:	00800584 	movi	r2,22
 8231aac:	00009106 	br	8231cf4 <soclose+0x2a8>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 8231ab0:	e0bfff17 	ldw	r2,-4(fp)
 8231ab4:	10800417 	ldw	r2,16(r2)
 8231ab8:	1080008c 	andi	r2,r2,2
 8231abc:	10001226 	beq	r2,zero,8231b08 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 8231ac0:	00000406 	br	8231ad4 <soclose+0x88>
         (void) soabort(so->so_q0);
 8231ac4:	e0bfff17 	ldw	r2,-4(fp)
 8231ac8:	10801c17 	ldw	r2,112(r2)
 8231acc:	1009883a 	mov	r4,r2
 8231ad0:	8231d080 	call	8231d08 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 8231ad4:	e0bfff17 	ldw	r2,-4(fp)
 8231ad8:	10c01c17 	ldw	r3,112(r2)
 8231adc:	e0bfff17 	ldw	r2,-4(fp)
 8231ae0:	18bff81e 	bne	r3,r2,8231ac4 <soclose+0x78>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231ae4:	00000406 	br	8231af8 <soclose+0xac>
         (void) soabort(so->so_q);
 8231ae8:	e0bfff17 	ldw	r2,-4(fp)
 8231aec:	10801d17 	ldw	r2,116(r2)
 8231af0:	1009883a 	mov	r4,r2
 8231af4:	8231d080 	call	8231d08 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231af8:	e0bfff17 	ldw	r2,-4(fp)
 8231afc:	10c01d17 	ldw	r3,116(r2)
 8231b00:	e0bfff17 	ldw	r2,-4(fp)
 8231b04:	18bff81e 	bne	r3,r2,8231ae8 <soclose+0x9c>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 8231b08:	e0bfff17 	ldw	r2,-4(fp)
 8231b0c:	10800983 	ldbu	r2,38(r2)
 8231b10:	10803fcc 	andi	r2,r2,255
 8231b14:	1080201c 	xori	r2,r2,128
 8231b18:	10bfe004 	addi	r2,r2,-128
 8231b1c:	10800060 	cmpeqi	r2,r2,1
 8231b20:	10000c1e 	bne	r2,zero,8231b54 <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 8231b24:	e0bfff17 	ldw	r2,-4(fp)
 8231b28:	00c00044 	movi	r3,1
 8231b2c:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so,
 8231b30:	e0bfff17 	ldw	r2,-4(fp)
 8231b34:	10800217 	ldw	r2,8(r2)
 8231b38:	10800317 	ldw	r2,12(r2)
 8231b3c:	000d883a 	mov	r6,zero
 8231b40:	000b883a 	mov	r5,zero
 8231b44:	e13fff17 	ldw	r4,-4(fp)
 8231b48:	103ee83a 	callr	r2
 8231b4c:	e0bffb15 	stw	r2,-20(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 8231b50:	00005906 	br	8231cb8 <soclose+0x26c>
   }

   if (so->so_pcb == 0)
 8231b54:	e0bfff17 	ldw	r2,-4(fp)
 8231b58:	10800117 	ldw	r2,4(r2)
 8231b5c:	10005526 	beq	r2,zero,8231cb4 <soclose+0x268>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 8231b60:	e0bfff17 	ldw	r2,-4(fp)
 8231b64:	1080088b 	ldhu	r2,34(r2)
 8231b68:	10bfffcc 	andi	r2,r2,65535
 8231b6c:	1080008c 	andi	r2,r2,2
 8231b70:	10003d26 	beq	r2,zero,8231c68 <soclose+0x21c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 8231b74:	e0bfff17 	ldw	r2,-4(fp)
 8231b78:	1080088b 	ldhu	r2,34(r2)
 8231b7c:	10bfffcc 	andi	r2,r2,65535
 8231b80:	1080020c 	andi	r2,r2,8
 8231b84:	1000051e 	bne	r2,zero,8231b9c <soclose+0x150>
      {
         error = sodisconnect(so);
 8231b88:	e13fff17 	ldw	r4,-4(fp)
 8231b8c:	8231ea80 	call	8231ea8 <sodisconnect>
 8231b90:	e0bffb15 	stw	r2,-20(fp)
         if (error)
 8231b94:	e0bffb17 	ldw	r2,-20(fp)
 8231b98:	1000301e 	bne	r2,zero,8231c5c <soclose+0x210>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 8231b9c:	e0bfff17 	ldw	r2,-4(fp)
 8231ba0:	10800417 	ldw	r2,16(r2)
 8231ba4:	1080200c 	andi	r2,r2,128
 8231ba8:	10002126 	beq	r2,zero,8231c30 <soclose+0x1e4>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231bac:	e0bfff17 	ldw	r2,-4(fp)
 8231bb0:	1080088b 	ldhu	r2,34(r2)
 8231bb4:	10bfffcc 	andi	r2,r2,65535
 8231bb8:	1080020c 	andi	r2,r2,8
 8231bbc:	10000526 	beq	r2,zero,8231bd4 <soclose+0x188>
             (so->so_state & SS_NBIO))
 8231bc0:	e0bfff17 	ldw	r2,-4(fp)
 8231bc4:	1080088b 	ldhu	r2,34(r2)
 8231bc8:	10bfffcc 	andi	r2,r2,65535
 8231bcc:	1080400c 	andi	r2,r2,256
         if (error)
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231bd0:	1000241e 	bne	r2,zero,8231c64 <soclose+0x218>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 8231bd4:	e0bfff17 	ldw	r2,-4(fp)
 8231bd8:	1080080b 	ldhu	r2,32(r2)
 8231bdc:	10bfffcc 	andi	r2,r2,65535
 8231be0:	10a0001c 	xori	r2,r2,32768
 8231be4:	10a00004 	addi	r2,r2,-32768
 8231be8:	10c01924 	muli	r3,r2,100
 8231bec:	d0a0a817 	ldw	r2,-32096(gp)
 8231bf0:	1885883a 	add	r2,r3,r2
 8231bf4:	e0bffd15 	stw	r2,-12(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231bf8:	00000406 	br	8231c0c <soclose+0x1c0>
         {
            tcp_sleep((char *)&so->so_timeo);
 8231bfc:	e0bfff17 	ldw	r2,-4(fp)
 8231c00:	10800904 	addi	r2,r2,36
 8231c04:	1009883a 	mov	r4,r2
 8231c08:	82291680 	call	8229168 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231c0c:	e0bfff17 	ldw	r2,-4(fp)
 8231c10:	1080088b 	ldhu	r2,34(r2)
 8231c14:	10bfffcc 	andi	r2,r2,65535
 8231c18:	1080008c 	andi	r2,r2,2
 8231c1c:	10001226 	beq	r2,zero,8231c68 <soclose+0x21c>
 8231c20:	d0e0a817 	ldw	r3,-32096(gp)
 8231c24:	e0bffd17 	ldw	r2,-12(fp)
 8231c28:	18bff436 	bltu	r3,r2,8231bfc <soclose+0x1b0>
 8231c2c:	00000e06 	br	8231c68 <soclose+0x21c>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 8231c30:	e0bfff17 	ldw	r2,-4(fp)
 8231c34:	10801217 	ldw	r2,72(r2)
 8231c38:	10000b26 	beq	r2,zero,8231c68 <soclose+0x21c>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 8231c3c:	e0bfff17 	ldw	r2,-4(fp)
 8231c40:	1080088b 	ldhu	r2,34(r2)
 8231c44:	10800054 	ori	r2,r2,1
 8231c48:	1007883a 	mov	r3,r2
 8231c4c:	e0bfff17 	ldw	r2,-4(fp)
 8231c50:	10c0088d 	sth	r3,34(r2)
            return 0;
 8231c54:	0005883a 	mov	r2,zero
 8231c58:	00002606 	br	8231cf4 <soclose+0x2a8>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
      {
         error = sodisconnect(so);
         if (error)
            goto drop;
 8231c5c:	0001883a 	nop
 8231c60:	00000106 	br	8231c68 <soclose+0x21c>
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
             (so->so_state & SS_NBIO))
         {
            goto drop;
 8231c64:	0001883a 	nop
            return 0;
         }
      }
   }
drop:
   if (so->so_pcb) 
 8231c68:	e0bfff17 	ldw	r2,-4(fp)
 8231c6c:	10800117 	ldw	r2,4(r2)
 8231c70:	10001126 	beq	r2,zero,8231cb8 <soclose+0x26c>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 8231c74:	e0bfff17 	ldw	r2,-4(fp)
 8231c78:	00c00044 	movi	r3,1
 8231c7c:	10c00715 	stw	r3,28(r2)
      error2 = (*so->so_proto->pr_usrreq)(so,
 8231c80:	e0bfff17 	ldw	r2,-4(fp)
 8231c84:	10800217 	ldw	r2,8(r2)
 8231c88:	10800317 	ldw	r2,12(r2)
 8231c8c:	000d883a 	mov	r6,zero
 8231c90:	000b883a 	mov	r5,zero
 8231c94:	e13fff17 	ldw	r4,-4(fp)
 8231c98:	103ee83a 	callr	r2
 8231c9c:	e0bffe15 	stw	r2,-8(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 8231ca0:	e0bffb17 	ldw	r2,-20(fp)
 8231ca4:	1000041e 	bne	r2,zero,8231cb8 <soclose+0x26c>
         error = error2;
 8231ca8:	e0bffe17 	ldw	r2,-8(fp)
 8231cac:	e0bffb15 	stw	r2,-20(fp)
 8231cb0:	00000106 	br	8231cb8 <soclose+0x26c>
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
   }

   if (so->so_pcb == 0)
      goto discard;
 8231cb4:	0001883a 	nop
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
         error = error2;
   }
discard:
   if (so->so_state & SS_NOFDREF)
 8231cb8:	e0bfff17 	ldw	r2,-4(fp)
 8231cbc:	1080088b 	ldhu	r2,34(r2)
 8231cc0:	10bfffcc 	andi	r2,r2,65535
 8231cc4:	1080004c 	andi	r2,r2,1
 8231cc8:	10000126 	beq	r2,zero,8231cd0 <soclose+0x284>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 8231ccc:	822d1c80 	call	822d1c8 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 8231cd0:	e0bfff17 	ldw	r2,-4(fp)
 8231cd4:	1080088b 	ldhu	r2,34(r2)
 8231cd8:	10800054 	ori	r2,r2,1
 8231cdc:	1007883a 	mov	r3,r2
 8231ce0:	e0bfff17 	ldw	r2,-4(fp)
 8231ce4:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 8231ce8:	e13fff17 	ldw	r4,-4(fp)
 8231cec:	823193c0 	call	823193c <sofree>
   return (error);
 8231cf0:	e0bffb17 	ldw	r2,-20(fp)
}
 8231cf4:	e037883a 	mov	sp,fp
 8231cf8:	dfc00117 	ldw	ra,4(sp)
 8231cfc:	df000017 	ldw	fp,0(sp)
 8231d00:	dec00204 	addi	sp,sp,8
 8231d04:	f800283a 	ret

08231d08 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 8231d08:	defffd04 	addi	sp,sp,-12
 8231d0c:	dfc00215 	stw	ra,8(sp)
 8231d10:	df000115 	stw	fp,4(sp)
 8231d14:	df000104 	addi	fp,sp,4
 8231d18:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 8231d1c:	e0bfff17 	ldw	r2,-4(fp)
 8231d20:	00c00284 	movi	r3,10
 8231d24:	10c00715 	stw	r3,28(r2)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8231d28:	e0bfff17 	ldw	r2,-4(fp)
 8231d2c:	10800217 	ldw	r2,8(r2)
 8231d30:	10800317 	ldw	r2,12(r2)
 8231d34:	000d883a 	mov	r6,zero
 8231d38:	000b883a 	mov	r5,zero
 8231d3c:	e13fff17 	ldw	r4,-4(fp)
 8231d40:	103ee83a 	callr	r2
}
 8231d44:	e037883a 	mov	sp,fp
 8231d48:	dfc00117 	ldw	ra,4(sp)
 8231d4c:	df000017 	ldw	fp,0(sp)
 8231d50:	dec00204 	addi	sp,sp,8
 8231d54:	f800283a 	ret

08231d58 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 8231d58:	defffb04 	addi	sp,sp,-20
 8231d5c:	dfc00415 	stw	ra,16(sp)
 8231d60:	df000315 	stw	fp,12(sp)
 8231d64:	df000304 	addi	fp,sp,12
 8231d68:	e13ffe15 	stw	r4,-8(fp)
 8231d6c:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 8231d70:	e0bffe17 	ldw	r2,-8(fp)
 8231d74:	1080088b 	ldhu	r2,34(r2)
 8231d78:	10bfffcc 	andi	r2,r2,65535
 8231d7c:	1080004c 	andi	r2,r2,1
 8231d80:	1000031e 	bne	r2,zero,8231d90 <soaccept+0x38>
      panic("soaccept");
 8231d84:	01020974 	movhi	r4,2085
 8231d88:	21020f04 	addi	r4,r4,2108
 8231d8c:	822887c0 	call	822887c <panic>
   so->so_state &= ~SS_NOFDREF;
 8231d90:	e0bffe17 	ldw	r2,-8(fp)
 8231d94:	10c0088b 	ldhu	r3,34(r2)
 8231d98:	00bfff84 	movi	r2,-2
 8231d9c:	1884703a 	and	r2,r3,r2
 8231da0:	1007883a 	mov	r3,r2
 8231da4:	e0bffe17 	ldw	r2,-8(fp)
 8231da8:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 8231dac:	e0bffe17 	ldw	r2,-8(fp)
 8231db0:	00c00144 	movi	r3,5
 8231db4:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231db8:	e0bffe17 	ldw	r2,-8(fp)
 8231dbc:	10800217 	ldw	r2,8(r2)
 8231dc0:	10800317 	ldw	r2,12(r2)
 8231dc4:	e1bfff17 	ldw	r6,-4(fp)
 8231dc8:	000b883a 	mov	r5,zero
 8231dcc:	e13ffe17 	ldw	r4,-8(fp)
 8231dd0:	103ee83a 	callr	r2
 8231dd4:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 8231dd8:	e0bffd17 	ldw	r2,-12(fp)
}
 8231ddc:	e037883a 	mov	sp,fp
 8231de0:	dfc00117 	ldw	ra,4(sp)
 8231de4:	df000017 	ldw	fp,0(sp)
 8231de8:	dec00204 	addi	sp,sp,8
 8231dec:	f800283a 	ret

08231df0 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 8231df0:	defffb04 	addi	sp,sp,-20
 8231df4:	dfc00415 	stw	ra,16(sp)
 8231df8:	df000315 	stw	fp,12(sp)
 8231dfc:	df000304 	addi	fp,sp,12
 8231e00:	e13ffe15 	stw	r4,-8(fp)
 8231e04:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 8231e08:	e0bffe17 	ldw	r2,-8(fp)
 8231e0c:	10800417 	ldw	r2,16(r2)
 8231e10:	1080008c 	andi	r2,r2,2
 8231e14:	10000226 	beq	r2,zero,8231e20 <soconnect+0x30>
      return (EOPNOTSUPP);
 8231e18:	008017c4 	movi	r2,95
 8231e1c:	00001d06 	br	8231e94 <soconnect+0xa4>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8231e20:	e0bffe17 	ldw	r2,-8(fp)
 8231e24:	1080088b 	ldhu	r2,34(r2)
 8231e28:	10bfffcc 	andi	r2,r2,65535
 8231e2c:	1080018c 	andi	r2,r2,6
 8231e30:	10000c26 	beq	r2,zero,8231e64 <soconnect+0x74>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8231e34:	e0bffe17 	ldw	r2,-8(fp)
 8231e38:	10800217 	ldw	r2,8(r2)
 8231e3c:	1080010b 	ldhu	r2,4(r2)
 8231e40:	10bfffcc 	andi	r2,r2,65535
 8231e44:	1080010c 	andi	r2,r2,4
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8231e48:	1000031e 	bne	r2,zero,8231e58 <soconnect+0x68>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
 8231e4c:	e13ffe17 	ldw	r4,-8(fp)
 8231e50:	8231ea80 	call	8231ea8 <sodisconnect>
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8231e54:	10000326 	beq	r2,zero,8231e64 <soconnect+0x74>
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 8231e58:	00801fc4 	movi	r2,127
 8231e5c:	e0bffd15 	stw	r2,-12(fp)
 8231e60:	00000b06 	br	8231e90 <soconnect+0xa0>
   }
   else
   {
      so->so_req = PRU_CONNECT;
 8231e64:	e0bffe17 	ldw	r2,-8(fp)
 8231e68:	00c00104 	movi	r3,4
 8231e6c:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231e70:	e0bffe17 	ldw	r2,-8(fp)
 8231e74:	10800217 	ldw	r2,8(r2)
 8231e78:	10800317 	ldw	r2,12(r2)
 8231e7c:	e1bfff17 	ldw	r6,-4(fp)
 8231e80:	000b883a 	mov	r5,zero
 8231e84:	e13ffe17 	ldw	r4,-8(fp)
 8231e88:	103ee83a 	callr	r2
 8231e8c:	e0bffd15 	stw	r2,-12(fp)
   }
   return error;
 8231e90:	e0bffd17 	ldw	r2,-12(fp)
}
 8231e94:	e037883a 	mov	sp,fp
 8231e98:	dfc00117 	ldw	ra,4(sp)
 8231e9c:	df000017 	ldw	fp,0(sp)
 8231ea0:	dec00204 	addi	sp,sp,8
 8231ea4:	f800283a 	ret

08231ea8 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 8231ea8:	defffc04 	addi	sp,sp,-16
 8231eac:	dfc00315 	stw	ra,12(sp)
 8231eb0:	df000215 	stw	fp,8(sp)
 8231eb4:	df000204 	addi	fp,sp,8
 8231eb8:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 8231ebc:	e0bfff17 	ldw	r2,-4(fp)
 8231ec0:	1080088b 	ldhu	r2,34(r2)
 8231ec4:	10bfffcc 	andi	r2,r2,65535
 8231ec8:	1080008c 	andi	r2,r2,2
 8231ecc:	1000031e 	bne	r2,zero,8231edc <sodisconnect+0x34>
   {
      error = ENOTCONN;
 8231ed0:	00802004 	movi	r2,128
 8231ed4:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8231ed8:	00001306 	br	8231f28 <sodisconnect+0x80>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 8231edc:	e0bfff17 	ldw	r2,-4(fp)
 8231ee0:	1080088b 	ldhu	r2,34(r2)
 8231ee4:	10bfffcc 	andi	r2,r2,65535
 8231ee8:	1080020c 	andi	r2,r2,8
 8231eec:	10000326 	beq	r2,zero,8231efc <sodisconnect+0x54>
   {
      error = EALREADY;
 8231ef0:	00801e04 	movi	r2,120
 8231ef4:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8231ef8:	00000b06 	br	8231f28 <sodisconnect+0x80>
   }
   so->so_req = PRU_DISCONNECT;
 8231efc:	e0bfff17 	ldw	r2,-4(fp)
 8231f00:	00c00184 	movi	r3,6
 8231f04:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8231f08:	e0bfff17 	ldw	r2,-4(fp)
 8231f0c:	10800217 	ldw	r2,8(r2)
 8231f10:	10800317 	ldw	r2,12(r2)
 8231f14:	000d883a 	mov	r6,zero
 8231f18:	000b883a 	mov	r5,zero
 8231f1c:	e13fff17 	ldw	r4,-4(fp)
 8231f20:	103ee83a 	callr	r2
 8231f24:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 8231f28:	e0bffe17 	ldw	r2,-8(fp)
}
 8231f2c:	e037883a 	mov	sp,fp
 8231f30:	dfc00117 	ldw	ra,4(sp)
 8231f34:	df000017 	ldw	fp,0(sp)
 8231f38:	dec00204 	addi	sp,sp,8
 8231f3c:	f800283a 	ret

08231f40 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 8231f40:	defff204 	addi	sp,sp,-56
 8231f44:	dfc00d15 	stw	ra,52(sp)
 8231f48:	df000c15 	stw	fp,48(sp)
 8231f4c:	df000c04 	addi	fp,sp,48
 8231f50:	e13ffc15 	stw	r4,-16(fp)
 8231f54:	e17ffd15 	stw	r5,-12(fp)
 8231f58:	e1bffe15 	stw	r6,-8(fp)
 8231f5c:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 8231f60:	e03ff415 	stw	zero,-48(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 8231f64:	e03ff815 	stw	zero,-32(fp)
   int   dontroute;
   int   first = 1;
 8231f68:	00800044 	movi	r2,1
 8231f6c:	e0bff915 	stw	r2,-28(fp)

   resid = *data_length;
 8231f70:	e0bfff17 	ldw	r2,-4(fp)
 8231f74:	10800017 	ldw	r2,0(r2)
 8231f78:	e0bff715 	stw	r2,-36(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 8231f7c:	e0bff717 	ldw	r2,-36(fp)
 8231f80:	1000020e 	bge	r2,zero,8231f8c <sosend+0x4c>
      return (EINVAL);
 8231f84:	00800584 	movi	r2,22
 8231f88:	00013e06 	br	8232484 <sosend+0x544>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 8231f8c:	e0bffc17 	ldw	r2,-16(fp)
 8231f90:	10800217 	ldw	r2,8(r2)
 8231f94:	1080010b 	ldhu	r2,4(r2)
 8231f98:	10bfffcc 	andi	r2,r2,65535
 8231f9c:	1080004c 	andi	r2,r2,1
 8231fa0:	10000726 	beq	r2,zero,8231fc0 <sosend+0x80>
 8231fa4:	e0bffc17 	ldw	r2,-16(fp)
 8231fa8:	10801317 	ldw	r2,76(r2)
 8231fac:	1007883a 	mov	r3,r2
 8231fb0:	e0bff717 	ldw	r2,-36(fp)
 8231fb4:	1880020e 	bge	r3,r2,8231fc0 <sosend+0x80>
      return (EMSGSIZE);
 8231fb8:	00801e84 	movi	r2,122
 8231fbc:	00013106 	br	8232484 <sosend+0x544>

   dontroute = (flags & MSG_DONTROUTE) &&
 8231fc0:	e0800217 	ldw	r2,8(fp)
 8231fc4:	1080010c 	andi	r2,r2,4
               ((so->so_options & SO_DONTROUTE) == 0) &&
 8231fc8:	10000c26 	beq	r2,zero,8231ffc <sosend+0xbc>
 8231fcc:	e0bffc17 	ldw	r2,-16(fp)
 8231fd0:	10800417 	ldw	r2,16(r2)
 8231fd4:	1080040c 	andi	r2,r2,16
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 8231fd8:	1000081e 	bne	r2,zero,8231ffc <sosend+0xbc>
               ((so->so_options & SO_DONTROUTE) == 0) &&
               (so->so_proto->pr_flags & PR_ATOMIC);
 8231fdc:	e0bffc17 	ldw	r2,-16(fp)
 8231fe0:	10800217 	ldw	r2,8(r2)
 8231fe4:	1080010b 	ldhu	r2,4(r2)
 8231fe8:	10bfffcc 	andi	r2,r2,65535
 8231fec:	1080004c 	andi	r2,r2,1

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
               ((so->so_options & SO_DONTROUTE) == 0) &&
 8231ff0:	10000226 	beq	r2,zero,8231ffc <sosend+0xbc>
 8231ff4:	00800044 	movi	r2,1
 8231ff8:	00000106 	br	8232000 <sosend+0xc0>
 8231ffc:	0005883a 	mov	r2,zero
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 8232000:	e0bffa15 	stw	r2,-24(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 8232004:	00000406 	br	8232018 <sosend+0xd8>
 8232008:	e0bffc17 	ldw	r2,-16(fp)
 823200c:	10801904 	addi	r2,r2,100
 8232010:	1009883a 	mov	r4,r2
 8232014:	82291680 	call	8229168 <tcp_sleep>
 8232018:	e0bffc17 	ldw	r2,-16(fp)
 823201c:	1080190b 	ldhu	r2,100(r2)
 8232020:	10bfffcc 	andi	r2,r2,65535
 8232024:	1080004c 	andi	r2,r2,1
 8232028:	103ff71e 	bne	r2,zero,8232008 <sosend+0xc8>
 823202c:	e0bffc17 	ldw	r2,-16(fp)
 8232030:	1080190b 	ldhu	r2,100(r2)
 8232034:	10800054 	ori	r2,r2,1
 8232038:	1007883a 	mov	r3,r2
 823203c:	e0bffc17 	ldw	r2,-16(fp)
 8232040:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 8232044:	e0bffc17 	ldw	r2,-16(fp)
 8232048:	10800617 	ldw	r2,24(r2)
 823204c:	10000626 	beq	r2,zero,8232068 <sosend+0x128>
      {
         error = so->so_error;
 8232050:	e0bffc17 	ldw	r2,-16(fp)
 8232054:	10800617 	ldw	r2,24(r2)
 8232058:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;          /* ??? */
 823205c:	e0bffc17 	ldw	r2,-16(fp)
 8232060:	10000615 	stw	zero,24(r2)
         goto release;
 8232064:	0000f706 	br	8232444 <sosend+0x504>
      }
      if (so->so_state & SS_CANTSENDMORE)
 8232068:	e0bffc17 	ldw	r2,-16(fp)
 823206c:	1080088b 	ldhu	r2,34(r2)
 8232070:	10bfffcc 	andi	r2,r2,65535
 8232074:	1080040c 	andi	r2,r2,16
 8232078:	10000326 	beq	r2,zero,8232088 <sosend+0x148>
         snderr(EPIPE);
 823207c:	00800804 	movi	r2,32
 8232080:	e0bff815 	stw	r2,-32(fp)
 8232084:	0000ef06 	br	8232444 <sosend+0x504>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 8232088:	e0bffc17 	ldw	r2,-16(fp)
 823208c:	1080088b 	ldhu	r2,34(r2)
 8232090:	10bfffcc 	andi	r2,r2,65535
 8232094:	1080008c 	andi	r2,r2,2
 8232098:	10000e1e 	bne	r2,zero,82320d4 <sosend+0x194>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 823209c:	e0bffc17 	ldw	r2,-16(fp)
 82320a0:	10800217 	ldw	r2,8(r2)
 82320a4:	1080010b 	ldhu	r2,4(r2)
 82320a8:	10bfffcc 	andi	r2,r2,65535
 82320ac:	1080010c 	andi	r2,r2,4
 82320b0:	10000326 	beq	r2,zero,82320c0 <sosend+0x180>
            snderr(ENOTCONN);
 82320b4:	00802004 	movi	r2,128
 82320b8:	e0bff815 	stw	r2,-32(fp)
 82320bc:	0000e106 	br	8232444 <sosend+0x504>
         if (nam == 0)
 82320c0:	e0bffd17 	ldw	r2,-12(fp)
 82320c4:	1000031e 	bne	r2,zero,82320d4 <sosend+0x194>
            snderr(EDESTADDRREQ);
 82320c8:	00801e44 	movi	r2,121
 82320cc:	e0bff815 	stw	r2,-32(fp)
 82320d0:	0000dc06 	br	8232444 <sosend+0x504>
      }
      if (flags & MSG_OOB)
 82320d4:	e0800217 	ldw	r2,8(fp)
 82320d8:	1080004c 	andi	r2,r2,1
 82320dc:	10000326 	beq	r2,zero,82320ec <sosend+0x1ac>
         space = 1024;
 82320e0:	00810004 	movi	r2,1024
 82320e4:	e0bff615 	stw	r2,-40(fp)
 82320e8:	00004706 	br	8232208 <sosend+0x2c8>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 82320ec:	e0bffc17 	ldw	r2,-16(fp)
 82320f0:	10801317 	ldw	r2,76(r2)
 82320f4:	1007883a 	mov	r3,r2
 82320f8:	e0bffc17 	ldw	r2,-16(fp)
 82320fc:	10801217 	ldw	r2,72(r2)
 8232100:	1885c83a 	sub	r2,r3,r2
 8232104:	10000616 	blt	r2,zero,8232120 <sosend+0x1e0>
 8232108:	e0bffc17 	ldw	r2,-16(fp)
 823210c:	10c01317 	ldw	r3,76(r2)
 8232110:	e0bffc17 	ldw	r2,-16(fp)
 8232114:	10801217 	ldw	r2,72(r2)
 8232118:	1885c83a 	sub	r2,r3,r2
 823211c:	00000106 	br	8232124 <sosend+0x1e4>
 8232120:	0005883a 	mov	r2,zero
 8232124:	e0bff615 	stw	r2,-40(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 8232128:	e0bffc17 	ldw	r2,-16(fp)
 823212c:	10800217 	ldw	r2,8(r2)
 8232130:	1080010b 	ldhu	r2,4(r2)
 8232134:	10bfffcc 	andi	r2,r2,65535
 8232138:	1080004c 	andi	r2,r2,1
 823213c:	10000326 	beq	r2,zero,823214c <sosend+0x20c>
 8232140:	e0fff617 	ldw	r3,-40(fp)
 8232144:	e0bff717 	ldw	r2,-36(fp)
 8232148:	18801216 	blt	r3,r2,8232194 <sosend+0x254>
 823214c:	e0bff717 	ldw	r2,-36(fp)
 8232150:	10815e10 	cmplti	r2,r2,1400
 8232154:	10002c1e 	bne	r2,zero,8232208 <sosend+0x2c8>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232158:	e0bff617 	ldw	r2,-40(fp)
 823215c:	10815e08 	cmpgei	r2,r2,1400
 8232160:	1000291e 	bne	r2,zero,8232208 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
 8232164:	e0bffc17 	ldw	r2,-16(fp)
 8232168:	10801217 	ldw	r2,72(r2)
         space = 1024;
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 823216c:	10815e30 	cmpltui	r2,r2,1400
 8232170:	1000251e 	bne	r2,zero,8232208 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 8232174:	e0bffc17 	ldw	r2,-16(fp)
 8232178:	1080088b 	ldhu	r2,34(r2)
 823217c:	10bfffcc 	andi	r2,r2,65535
 8232180:	1080400c 	andi	r2,r2,256
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
 8232184:	1000201e 	bne	r2,zero,8232208 <sosend+0x2c8>
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
 8232188:	e0800217 	ldw	r2,8(fp)
 823218c:	1080080c 	andi	r2,r2,32
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 8232190:	10001d1e 	bne	r2,zero,8232208 <sosend+0x2c8>
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 8232194:	e0bffc17 	ldw	r2,-16(fp)
 8232198:	1080088b 	ldhu	r2,34(r2)
 823219c:	10bfffcc 	andi	r2,r2,65535
 82321a0:	1080400c 	andi	r2,r2,256
 82321a4:	1000031e 	bne	r2,zero,82321b4 <sosend+0x274>
 82321a8:	e0800217 	ldw	r2,8(fp)
 82321ac:	1080080c 	andi	r2,r2,32
 82321b0:	10000526 	beq	r2,zero,82321c8 <sosend+0x288>
            {
               if (first)
 82321b4:	e0bff917 	ldw	r2,-28(fp)
 82321b8:	10009d26 	beq	r2,zero,8232430 <sosend+0x4f0>
                  error = EWOULDBLOCK;
 82321bc:	008002c4 	movi	r2,11
 82321c0:	e0bff815 	stw	r2,-32(fp)
               goto release;
 82321c4:	00009a06 	br	8232430 <sosend+0x4f0>
            }
            sbunlock(&so->so_snd);
 82321c8:	e0bffc17 	ldw	r2,-16(fp)
 82321cc:	10c0190b 	ldhu	r3,100(r2)
 82321d0:	00bfff84 	movi	r2,-2
 82321d4:	1884703a 	and	r2,r3,r2
 82321d8:	1007883a 	mov	r3,r2
 82321dc:	e0bffc17 	ldw	r2,-16(fp)
 82321e0:	10c0190d 	sth	r3,100(r2)
 82321e4:	e0bffc17 	ldw	r2,-16(fp)
 82321e8:	10801904 	addi	r2,r2,100
 82321ec:	1009883a 	mov	r4,r2
 82321f0:	82292dc0 	call	82292dc <tcp_wakeup>
            sbwait(&so->so_snd);
 82321f4:	e0bffc17 	ldw	r2,-16(fp)
 82321f8:	10801204 	addi	r2,r2,72
 82321fc:	1009883a 	mov	r4,r2
 8232200:	8233e0c0 	call	8233e0c <sbwait>
            goto restart;
 8232204:	003f7f06 	br	8232004 <sosend+0xc4>
         }
      }
      if ( space <= 0 ) 
 8232208:	e0bff617 	ldw	r2,-40(fp)
 823220c:	00805e16 	blt	zero,r2,8232388 <sosend+0x448>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 8232210:	e0bffc17 	ldw	r2,-16(fp)
 8232214:	1080088b 	ldhu	r2,34(r2)
 8232218:	10bfffcc 	andi	r2,r2,65535
 823221c:	1080400c 	andi	r2,r2,256
 8232220:	1000031e 	bne	r2,zero,8232230 <sosend+0x2f0>
 8232224:	e0800217 	ldw	r2,8(fp)
 8232228:	1080080c 	andi	r2,r2,32
 823222c:	10000526 	beq	r2,zero,8232244 <sosend+0x304>
         {
            if (first)     /* report first error */
 8232230:	e0bff917 	ldw	r2,-28(fp)
 8232234:	10008026 	beq	r2,zero,8232438 <sosend+0x4f8>
               error = EWOULDBLOCK;
 8232238:	008002c4 	movi	r2,11
 823223c:	e0bff815 	stw	r2,-32(fp)
            goto release;
 8232240:	00007d06 	br	8232438 <sosend+0x4f8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 8232244:	e0bffc17 	ldw	r2,-16(fp)
 8232248:	10c0190b 	ldhu	r3,100(r2)
 823224c:	00bfff84 	movi	r2,-2
 8232250:	1884703a 	and	r2,r3,r2
 8232254:	1007883a 	mov	r3,r2
 8232258:	e0bffc17 	ldw	r2,-16(fp)
 823225c:	10c0190d 	sth	r3,100(r2)
 8232260:	e0bffc17 	ldw	r2,-16(fp)
 8232264:	10801904 	addi	r2,r2,100
 8232268:	1009883a 	mov	r4,r2
 823226c:	82292dc0 	call	82292dc <tcp_wakeup>
         sbwait(&so->so_snd);
 8232270:	e0bffc17 	ldw	r2,-16(fp)
 8232274:	10801204 	addi	r2,r2,72
 8232278:	1009883a 	mov	r4,r2
 823227c:	8233e0c0 	call	8233e0c <sbwait>
         goto restart;
 8232280:	003f6006 	br	8232004 <sosend+0xc4>
      }

      while (space > 0) 
      {
         len = resid;
 8232284:	e0bff717 	ldw	r2,-36(fp)
 8232288:	e0bffb15 	stw	r2,-20(fp)
         if ( so->so_type == SOCK_STREAM )
 823228c:	e0bffc17 	ldw	r2,-16(fp)
 8232290:	10800983 	ldbu	r2,38(r2)
 8232294:	10803fcc 	andi	r2,r2,255
 8232298:	1080201c 	xori	r2,r2,128
 823229c:	10bfe004 	addi	r2,r2,-128
 82322a0:	10800058 	cmpnei	r2,r2,1
 82322a4:	1000171e 	bne	r2,zero,8232304 <sosend+0x3c4>
         {
            m = m_getwithdata(MT_TXDATA, len);
 82322a8:	e17ffb17 	ldw	r5,-20(fp)
 82322ac:	01000084 	movi	r4,2
 82322b0:	822dfdc0 	call	822dfdc <m_getnbuf>
 82322b4:	e0bff515 	stw	r2,-44(fp)
            if (!m)   
 82322b8:	e0bff517 	ldw	r2,-44(fp)
 82322bc:	1000031e 	bne	r2,zero,82322cc <sosend+0x38c>
               snderr(ENOBUFS);
 82322c0:	00801a44 	movi	r2,105
 82322c4:	e0bff815 	stw	r2,-32(fp)
 82322c8:	00005e06 	br	8232444 <sosend+0x504>
            MEMCPY(m->m_data, data, len);
 82322cc:	e0bff517 	ldw	r2,-44(fp)
 82322d0:	10800317 	ldw	r2,12(r2)
 82322d4:	e0fffb17 	ldw	r3,-20(fp)
 82322d8:	180d883a 	mov	r6,r3
 82322dc:	e17ffe17 	ldw	r5,-8(fp)
 82322e0:	1009883a 	mov	r4,r2
 82322e4:	8202a0c0 	call	8202a0c <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 82322e8:	e0bffc17 	ldw	r2,-16(fp)
 82322ec:	1080190b 	ldhu	r2,100(r2)
 82322f0:	10802014 	ori	r2,r2,128
 82322f4:	1007883a 	mov	r3,r2
 82322f8:	e0bffc17 	ldw	r2,-16(fp)
 82322fc:	10c0190d 	sth	r3,100(r2)
 8232300:	00000706 	br	8232320 <sosend+0x3e0>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 8232304:	000b883a 	mov	r5,zero
 8232308:	01000084 	movi	r4,2
 823230c:	822dfdc0 	call	822dfdc <m_getnbuf>
 8232310:	e0bff515 	stw	r2,-44(fp)
            m->m_data = data;
 8232314:	e0bff517 	ldw	r2,-44(fp)
 8232318:	e0fffe17 	ldw	r3,-8(fp)
 823231c:	10c00315 	stw	r3,12(r2)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 8232320:	e0bfff17 	ldw	r2,-4(fp)
 8232324:	10c00017 	ldw	r3,0(r2)
 8232328:	e0bffb17 	ldw	r2,-20(fp)
 823232c:	1887c83a 	sub	r3,r3,r2
 8232330:	e0bfff17 	ldw	r2,-4(fp)
 8232334:	10c00015 	stw	r3,0(r2)
         resid -= len;
 8232338:	e0fff717 	ldw	r3,-36(fp)
 823233c:	e0bffb17 	ldw	r2,-20(fp)
 8232340:	1885c83a 	sub	r2,r3,r2
 8232344:	e0bff715 	stw	r2,-36(fp)
         data += len;
 8232348:	e0bffb17 	ldw	r2,-20(fp)
 823234c:	e0fffe17 	ldw	r3,-8(fp)
 8232350:	1885883a 	add	r2,r3,r2
 8232354:	e0bffe15 	stw	r2,-8(fp)
         m->m_len = len;
 8232358:	e0fffb17 	ldw	r3,-20(fp)
 823235c:	e0bff517 	ldw	r2,-44(fp)
 8232360:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 8232364:	e0bff417 	ldw	r2,-48(fp)
 8232368:	1000021e 	bne	r2,zero,8232374 <sosend+0x434>
            head = m;
 823236c:	e0bff517 	ldw	r2,-44(fp)
 8232370:	e0bff415 	stw	r2,-48(fp)
         if (error)
 8232374:	e0bff817 	ldw	r2,-32(fp)
 8232378:	1000311e 	bne	r2,zero,8232440 <sosend+0x500>
            goto release;
         if (*data_length <= 0)
 823237c:	e0bfff17 	ldw	r2,-4(fp)
 8232380:	10800017 	ldw	r2,0(r2)
 8232384:	0080030e 	bge	zero,r2,8232394 <sosend+0x454>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 8232388:	e0bff617 	ldw	r2,-40(fp)
 823238c:	00bfbd16 	blt	zero,r2,8232284 <sosend+0x344>
 8232390:	00000106 	br	8232398 <sosend+0x458>
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
         if (*data_length <= 0)
            break;
 8232394:	0001883a 	nop
      }

      if (dontroute)
 8232398:	e0bffa17 	ldw	r2,-24(fp)
 823239c:	10000526 	beq	r2,zero,82323b4 <sosend+0x474>
         so->so_options |= SO_DONTROUTE;
 82323a0:	e0bffc17 	ldw	r2,-16(fp)
 82323a4:	10800417 	ldw	r2,16(r2)
 82323a8:	10c00414 	ori	r3,r2,16
 82323ac:	e0bffc17 	ldw	r2,-16(fp)
 82323b0:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 82323b4:	e0800217 	ldw	r2,8(fp)
 82323b8:	1080004c 	andi	r2,r2,1
 82323bc:	10000226 	beq	r2,zero,82323c8 <sosend+0x488>
 82323c0:	00800384 	movi	r2,14
 82323c4:	00000106 	br	82323cc <sosend+0x48c>
 82323c8:	00800244 	movi	r2,9
 82323cc:	e0fffc17 	ldw	r3,-16(fp)
 82323d0:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 82323d4:	e0bffc17 	ldw	r2,-16(fp)
 82323d8:	10800217 	ldw	r2,8(r2)
 82323dc:	10800317 	ldw	r2,12(r2)
 82323e0:	e1bffd17 	ldw	r6,-12(fp)
 82323e4:	e17ff417 	ldw	r5,-48(fp)
 82323e8:	e13ffc17 	ldw	r4,-16(fp)
 82323ec:	103ee83a 	callr	r2
 82323f0:	e0bff815 	stw	r2,-32(fp)

      if (dontroute)
 82323f4:	e0bffa17 	ldw	r2,-24(fp)
 82323f8:	10000626 	beq	r2,zero,8232414 <sosend+0x4d4>
         so->so_options &= ~SO_DONTROUTE;
 82323fc:	e0bffc17 	ldw	r2,-16(fp)
 8232400:	10c00417 	ldw	r3,16(r2)
 8232404:	00bffbc4 	movi	r2,-17
 8232408:	1886703a 	and	r3,r3,r2
 823240c:	e0bffc17 	ldw	r2,-16(fp)
 8232410:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 8232414:	e03ff415 	stw	zero,-48(fp)
      first = 0;
 8232418:	e03ff915 	stw	zero,-28(fp)
   } while ((resid != 0) && (error == 0));
 823241c:	e0bff717 	ldw	r2,-36(fp)
 8232420:	10000826 	beq	r2,zero,8232444 <sosend+0x504>
 8232424:	e0bff817 	ldw	r2,-32(fp)
 8232428:	103f0626 	beq	r2,zero,8232044 <sosend+0x104>
 823242c:	00000506 	br	8232444 <sosend+0x504>
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
            {
               if (first)
                  error = EWOULDBLOCK;
               goto release;
 8232430:	0001883a 	nop
 8232434:	00000306 	br	8232444 <sosend+0x504>
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
         {
            if (first)     /* report first error */
               error = EWOULDBLOCK;
            goto release;
 8232438:	0001883a 	nop
 823243c:	00000106 	br	8232444 <sosend+0x504>
         data += len;
         m->m_len = len;
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
 8232440:	0001883a 	nop
      head = (struct mbuf *)NULL;
      first = 0;
   } while ((resid != 0) && (error == 0));

release:
   sbunlock(&so->so_snd);  
 8232444:	e0bffc17 	ldw	r2,-16(fp)
 8232448:	10c0190b 	ldhu	r3,100(r2)
 823244c:	00bfff84 	movi	r2,-2
 8232450:	1884703a 	and	r2,r3,r2
 8232454:	1007883a 	mov	r3,r2
 8232458:	e0bffc17 	ldw	r2,-16(fp)
 823245c:	10c0190d 	sth	r3,100(r2)
 8232460:	e0bffc17 	ldw	r2,-16(fp)
 8232464:	10801904 	addi	r2,r2,100
 8232468:	1009883a 	mov	r4,r2
 823246c:	82292dc0 	call	82292dc <tcp_wakeup>
   if (head)
 8232470:	e0bff417 	ldw	r2,-48(fp)
 8232474:	10000226 	beq	r2,zero,8232480 <sosend+0x540>
      m_freem(head);
 8232478:	e13ff417 	ldw	r4,-48(fp)
 823247c:	822e26c0 	call	822e26c <m_freem>
   return error;
 8232480:	e0bff817 	ldw	r2,-32(fp)
}
 8232484:	e037883a 	mov	sp,fp
 8232488:	dfc00117 	ldw	ra,4(sp)
 823248c:	df000017 	ldw	fp,0(sp)
 8232490:	dec00204 	addi	sp,sp,8
 8232494:	f800283a 	ret

08232498 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 8232498:	defff204 	addi	sp,sp,-56
 823249c:	dfc00d15 	stw	ra,52(sp)
 82324a0:	df000c15 	stw	fp,48(sp)
 82324a4:	df000c04 	addi	fp,sp,48
 82324a8:	e13ffc15 	stw	r4,-16(fp)
 82324ac:	e17ffd15 	stw	r5,-12(fp)
 82324b0:	e1bffe15 	stw	r6,-8(fp)
 82324b4:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 82324b8:	e03ff615 	stw	zero,-40(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 82324bc:	e0bffc17 	ldw	r2,-16(fp)
 82324c0:	10800217 	ldw	r2,8(r2)
 82324c4:	e0bffa15 	stw	r2,-24(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 82324c8:	e0bffd17 	ldw	r2,-12(fp)
 82324cc:	10000226 	beq	r2,zero,82324d8 <soreceive+0x40>
      *aname = 0;
 82324d0:	e0bffd17 	ldw	r2,-12(fp)
 82324d4:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 82324d8:	e0800217 	ldw	r2,8(fp)
 82324dc:	1080004c 	andi	r2,r2,1
 82324e0:	10004626 	beq	r2,zero,82325fc <soreceive+0x164>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 82324e4:	000b883a 	mov	r5,zero
 82324e8:	01000044 	movi	r4,1
 82324ec:	822dfdc0 	call	822dfdc <m_getnbuf>
 82324f0:	e0bff415 	stw	r2,-48(fp)
      if (m == NULL)
 82324f4:	e0bff417 	ldw	r2,-48(fp)
 82324f8:	1000021e 	bne	r2,zero,8232504 <soreceive+0x6c>
         return ENOBUFS;
 82324fc:	00801a44 	movi	r2,105
 8232500:	0001b306 	br	8232bd0 <soreceive+0x738>
      lflags = flags & MSG_PEEK;
 8232504:	e0800217 	ldw	r2,8(fp)
 8232508:	1080008c 	andi	r2,r2,2
 823250c:	e0bffb15 	stw	r2,-20(fp)

      so->so_req = PRU_RCVOOB;
 8232510:	e0bffc17 	ldw	r2,-16(fp)
 8232514:	00c00344 	movi	r3,13
 8232518:	10c00715 	stw	r3,28(r2)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 823251c:	e0bffa17 	ldw	r2,-24(fp)
 8232520:	10800317 	ldw	r2,12(r2)
 8232524:	e0fffb17 	ldw	r3,-20(fp)
 8232528:	180d883a 	mov	r6,r3
 823252c:	e17ff417 	ldw	r5,-48(fp)
 8232530:	e13ffc17 	ldw	r4,-16(fp)
 8232534:	103ee83a 	callr	r2
 8232538:	e0bff615 	stw	r2,-40(fp)
      if (error == 0)
 823253c:	e0bff617 	ldw	r2,-40(fp)
 8232540:	1000231e 	bne	r2,zero,82325d0 <soreceive+0x138>
      {
         do 
         {
            len = *datalen;
 8232544:	e0bfff17 	ldw	r2,-4(fp)
 8232548:	10800017 	ldw	r2,0(r2)
 823254c:	e0bff515 	stw	r2,-44(fp)
            if (len > (int)m->m_len)
 8232550:	e0bff417 	ldw	r2,-48(fp)
 8232554:	10800217 	ldw	r2,8(r2)
 8232558:	1007883a 	mov	r3,r2
 823255c:	e0bff517 	ldw	r2,-44(fp)
 8232560:	1880030e 	bge	r3,r2,8232570 <soreceive+0xd8>
               len = m->m_len;
 8232564:	e0bff417 	ldw	r2,-48(fp)
 8232568:	10800217 	ldw	r2,8(r2)
 823256c:	e0bff515 	stw	r2,-44(fp)

            MEMCPY(data, mtod(m, char*), len);
 8232570:	e0bff417 	ldw	r2,-48(fp)
 8232574:	10800317 	ldw	r2,12(r2)
 8232578:	e0fff517 	ldw	r3,-44(fp)
 823257c:	180d883a 	mov	r6,r3
 8232580:	100b883a 	mov	r5,r2
 8232584:	e13ffe17 	ldw	r4,-8(fp)
 8232588:	8202a0c0 	call	8202a0c <memcpy>
            data += len;
 823258c:	e0bff517 	ldw	r2,-44(fp)
 8232590:	e0fffe17 	ldw	r3,-8(fp)
 8232594:	1885883a 	add	r2,r3,r2
 8232598:	e0bffe15 	stw	r2,-8(fp)
            *datalen = len;
 823259c:	e0bfff17 	ldw	r2,-4(fp)
 82325a0:	e0fff517 	ldw	r3,-44(fp)
 82325a4:	10c00015 	stw	r3,0(r2)
            m = m_free(m);
 82325a8:	e13ff417 	ldw	r4,-48(fp)
 82325ac:	822e1640 	call	822e164 <m_free>
 82325b0:	e0bff415 	stw	r2,-48(fp)
         } while (*datalen && (error == 0) && m);
 82325b4:	e0bfff17 	ldw	r2,-4(fp)
 82325b8:	10800017 	ldw	r2,0(r2)
 82325bc:	10000426 	beq	r2,zero,82325d0 <soreceive+0x138>
 82325c0:	e0bff617 	ldw	r2,-40(fp)
 82325c4:	1000021e 	bne	r2,zero,82325d0 <soreceive+0x138>
 82325c8:	e0bff417 	ldw	r2,-48(fp)
 82325cc:	103fdd1e 	bne	r2,zero,8232544 <soreceive+0xac>
      }

      if (m)
 82325d0:	e0bff417 	ldw	r2,-48(fp)
 82325d4:	10000226 	beq	r2,zero,82325e0 <soreceive+0x148>
         m_freem(m);
 82325d8:	e13ff417 	ldw	r4,-48(fp)
 82325dc:	822e26c0 	call	822e26c <m_freem>
      return (error);
 82325e0:	e0bff617 	ldw	r2,-40(fp)
 82325e4:	00017a06 	br	8232bd0 <soreceive+0x738>
   }

restart:
   sblock (&so->so_rcv);
 82325e8:	00000406 	br	82325fc <soreceive+0x164>
 82325ec:	e0bffc17 	ldw	r2,-16(fp)
 82325f0:	10801104 	addi	r2,r2,68
 82325f4:	1009883a 	mov	r4,r2
 82325f8:	82291680 	call	8229168 <tcp_sleep>
 82325fc:	e0bffc17 	ldw	r2,-16(fp)
 8232600:	1080110b 	ldhu	r2,68(r2)
 8232604:	10bfffcc 	andi	r2,r2,65535
 8232608:	1080004c 	andi	r2,r2,1
 823260c:	103ff71e 	bne	r2,zero,82325ec <soreceive+0x154>
 8232610:	e0bffc17 	ldw	r2,-16(fp)
 8232614:	1080110b 	ldhu	r2,68(r2)
 8232618:	10800054 	ori	r2,r2,1
 823261c:	1007883a 	mov	r3,r2
 8232620:	e0bffc17 	ldw	r2,-16(fp)
 8232624:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 8232628:	e0bffc17 	ldw	r2,-16(fp)
 823262c:	10800a17 	ldw	r2,40(r2)
 8232630:	10003a1e 	bne	r2,zero,823271c <soreceive+0x284>
   {
      if (so->so_error) 
 8232634:	e0bffc17 	ldw	r2,-16(fp)
 8232638:	10800617 	ldw	r2,24(r2)
 823263c:	10000626 	beq	r2,zero,8232658 <soreceive+0x1c0>
      {
         error = so->so_error;
 8232640:	e0bffc17 	ldw	r2,-16(fp)
 8232644:	10800617 	ldw	r2,24(r2)
 8232648:	e0bff615 	stw	r2,-40(fp)
         so->so_error = 0;
 823264c:	e0bffc17 	ldw	r2,-16(fp)
 8232650:	10000615 	stw	zero,24(r2)
         goto release;
 8232654:	00015206 	br	8232ba0 <soreceive+0x708>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8232658:	e0bffc17 	ldw	r2,-16(fp)
 823265c:	1080088b 	ldhu	r2,34(r2)
 8232660:	10bfffcc 	andi	r2,r2,65535
 8232664:	1080080c 	andi	r2,r2,32
 8232668:	10014a1e 	bne	r2,zero,8232b94 <soreceive+0x6fc>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 823266c:	e0bffc17 	ldw	r2,-16(fp)
 8232670:	1080088b 	ldhu	r2,34(r2)
 8232674:	10bfffcc 	andi	r2,r2,65535
 8232678:	1080008c 	andi	r2,r2,2
 823267c:	1000091e 	bne	r2,zero,82326a4 <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
 8232680:	e0bffc17 	ldw	r2,-16(fp)
 8232684:	10800217 	ldw	r2,8(r2)
 8232688:	1080010b 	ldhu	r2,4(r2)
 823268c:	10bfffcc 	andi	r2,r2,65535
 8232690:	1080010c 	andi	r2,r2,4
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 8232694:	10000326 	beq	r2,zero,82326a4 <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 8232698:	00802004 	movi	r2,128
 823269c:	e0bff615 	stw	r2,-40(fp)
         goto release;
 82326a0:	00013f06 	br	8232ba0 <soreceive+0x708>
      }
      if (*datalen == 0)
 82326a4:	e0bfff17 	ldw	r2,-4(fp)
 82326a8:	10800017 	ldw	r2,0(r2)
 82326ac:	10013b26 	beq	r2,zero,8232b9c <soreceive+0x704>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 82326b0:	e0bffc17 	ldw	r2,-16(fp)
 82326b4:	1080088b 	ldhu	r2,34(r2)
 82326b8:	10bfffcc 	andi	r2,r2,65535
 82326bc:	1080400c 	andi	r2,r2,256
 82326c0:	1000031e 	bne	r2,zero,82326d0 <soreceive+0x238>
 82326c4:	e0800217 	ldw	r2,8(fp)
 82326c8:	1080080c 	andi	r2,r2,32
 82326cc:	10000326 	beq	r2,zero,82326dc <soreceive+0x244>
      {
         error = EWOULDBLOCK;
 82326d0:	008002c4 	movi	r2,11
 82326d4:	e0bff615 	stw	r2,-40(fp)
         goto release;
 82326d8:	00013106 	br	8232ba0 <soreceive+0x708>
      }
      sbunlock(&so->so_rcv);
 82326dc:	e0bffc17 	ldw	r2,-16(fp)
 82326e0:	10c0110b 	ldhu	r3,68(r2)
 82326e4:	00bfff84 	movi	r2,-2
 82326e8:	1884703a 	and	r2,r3,r2
 82326ec:	1007883a 	mov	r3,r2
 82326f0:	e0bffc17 	ldw	r2,-16(fp)
 82326f4:	10c0110d 	sth	r3,68(r2)
 82326f8:	e0bffc17 	ldw	r2,-16(fp)
 82326fc:	10801104 	addi	r2,r2,68
 8232700:	1009883a 	mov	r4,r2
 8232704:	82292dc0 	call	82292dc <tcp_wakeup>
      sbwait(&so->so_rcv);
 8232708:	e0bffc17 	ldw	r2,-16(fp)
 823270c:	10800a04 	addi	r2,r2,40
 8232710:	1009883a 	mov	r4,r2
 8232714:	8233e0c0 	call	8233e0c <sbwait>
      goto restart;
 8232718:	003fb306 	br	82325e8 <soreceive+0x150>
   }
   m = so->so_rcv.sb_mb;
 823271c:	e0bffc17 	ldw	r2,-16(fp)
 8232720:	10801017 	ldw	r2,64(r2)
 8232724:	e0bff415 	stw	r2,-48(fp)
   if (m == 0)
 8232728:	e0bff417 	ldw	r2,-48(fp)
 823272c:	1000031e 	bne	r2,zero,823273c <soreceive+0x2a4>
      panic("sorecv 1");
 8232730:	01020974 	movhi	r4,2085
 8232734:	21021204 	addi	r4,r4,2120
 8232738:	822887c0 	call	822887c <panic>
   nextrecord = m->m_act;
 823273c:	e0bff417 	ldw	r2,-48(fp)
 8232740:	10800717 	ldw	r2,28(r2)
 8232744:	e0bff815 	stw	r2,-32(fp)
   if (pr->pr_flags & PR_ADDR) 
 8232748:	e0bffa17 	ldw	r2,-24(fp)
 823274c:	1080010b 	ldhu	r2,4(r2)
 8232750:	10bfffcc 	andi	r2,r2,65535
 8232754:	1080008c 	andi	r2,r2,2
 8232758:	10004226 	beq	r2,zero,8232864 <soreceive+0x3cc>
   {
      if (m->m_type != MT_SONAME) 
 823275c:	e0bff417 	ldw	r2,-48(fp)
 8232760:	10800817 	ldw	r2,32(r2)
 8232764:	10800260 	cmpeqi	r2,r2,9
 8232768:	1000091e 	bne	r2,zero,8232790 <soreceive+0x2f8>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 823276c:	e0bff417 	ldw	r2,-48(fp)
 8232770:	10800817 	ldw	r2,32(r2)
 8232774:	100b883a 	mov	r5,r2
 8232778:	01020974 	movhi	r4,2085
 823277c:	21021504 	addi	r4,r4,2132
 8232780:	8202e9c0 	call	8202e9c <printf>
         panic("sorecv 2");
 8232784:	01020974 	movhi	r4,2085
 8232788:	21021b04 	addi	r4,r4,2156
 823278c:	822887c0 	call	822887c <panic>
      }
      if (flags & MSG_PEEK) 
 8232790:	e0800217 	ldw	r2,8(fp)
 8232794:	1080008c 	andi	r2,r2,2
 8232798:	10000f26 	beq	r2,zero,82327d8 <soreceive+0x340>
      {
         if (aname)
 823279c:	e0bffd17 	ldw	r2,-12(fp)
 82327a0:	10000926 	beq	r2,zero,82327c8 <soreceive+0x330>
            *aname = m_copy (m, 0, m->m_len);
 82327a4:	e0bff417 	ldw	r2,-48(fp)
 82327a8:	10800217 	ldw	r2,8(r2)
 82327ac:	100d883a 	mov	r6,r2
 82327b0:	000b883a 	mov	r5,zero
 82327b4:	e13ff417 	ldw	r4,-48(fp)
 82327b8:	822e2b00 	call	822e2b0 <m_copy>
 82327bc:	1007883a 	mov	r3,r2
 82327c0:	e0bffd17 	ldw	r2,-12(fp)
 82327c4:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 82327c8:	e0bff417 	ldw	r2,-48(fp)
 82327cc:	10800617 	ldw	r2,24(r2)
 82327d0:	e0bff415 	stw	r2,-48(fp)
 82327d4:	00002306 	br	8232864 <soreceive+0x3cc>
      } else 
      {
         sbfree (&so->so_rcv, m);
 82327d8:	e0bffc17 	ldw	r2,-16(fp)
 82327dc:	10c00a17 	ldw	r3,40(r2)
 82327e0:	e0bff417 	ldw	r2,-48(fp)
 82327e4:	10800217 	ldw	r2,8(r2)
 82327e8:	1887c83a 	sub	r3,r3,r2
 82327ec:	e0bffc17 	ldw	r2,-16(fp)
 82327f0:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 82327f4:	e0bffd17 	ldw	r2,-12(fp)
 82327f8:	10000d26 	beq	r2,zero,8232830 <soreceive+0x398>
         {
            *aname = m;
 82327fc:	e0bffd17 	ldw	r2,-12(fp)
 8232800:	e0fff417 	ldw	r3,-48(fp)
 8232804:	10c00015 	stw	r3,0(r2)
            m = m->m_next;
 8232808:	e0bff417 	ldw	r2,-48(fp)
 823280c:	10800617 	ldw	r2,24(r2)
 8232810:	e0bff415 	stw	r2,-48(fp)
            (*aname)->m_next = 0;
 8232814:	e0bffd17 	ldw	r2,-12(fp)
 8232818:	10800017 	ldw	r2,0(r2)
 823281c:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 8232820:	e0bffc17 	ldw	r2,-16(fp)
 8232824:	e0fff417 	ldw	r3,-48(fp)
 8232828:	10c01015 	stw	r3,64(r2)
 823282c:	00000806 	br	8232850 <soreceive+0x3b8>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 8232830:	e13ff417 	ldw	r4,-48(fp)
 8232834:	822e1640 	call	822e164 <m_free>
 8232838:	1007883a 	mov	r3,r2
 823283c:	e0bffc17 	ldw	r2,-16(fp)
 8232840:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 8232844:	e0bffc17 	ldw	r2,-16(fp)
 8232848:	10801017 	ldw	r2,64(r2)
 823284c:	e0bff415 	stw	r2,-48(fp)
         }
         if (m)
 8232850:	e0bff417 	ldw	r2,-48(fp)
 8232854:	10000326 	beq	r2,zero,8232864 <soreceive+0x3cc>
            m->m_act = nextrecord;
 8232858:	e0bff417 	ldw	r2,-48(fp)
 823285c:	e0fff817 	ldw	r3,-32(fp)
 8232860:	10c00715 	stw	r3,28(r2)
      }
   }
   moff = 0;
 8232864:	e03ff915 	stw	zero,-28(fp)
   offset = 0;
 8232868:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 823286c:	00009e06 	br	8232ae8 <soreceive+0x650>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 8232870:	e0bff417 	ldw	r2,-48(fp)
 8232874:	10800817 	ldw	r2,32(r2)
 8232878:	10800060 	cmpeqi	r2,r2,1
 823287c:	1000071e 	bne	r2,zero,823289c <soreceive+0x404>
 8232880:	e0bff417 	ldw	r2,-48(fp)
 8232884:	10800817 	ldw	r2,32(r2)
 8232888:	108000e0 	cmpeqi	r2,r2,3
 823288c:	1000031e 	bne	r2,zero,823289c <soreceive+0x404>
         panic("sorecv 3");
 8232890:	01020974 	movhi	r4,2085
 8232894:	21021e04 	addi	r4,r4,2168
 8232898:	822887c0 	call	822887c <panic>
      len = *datalen;
 823289c:	e0bfff17 	ldw	r2,-4(fp)
 82328a0:	10800017 	ldw	r2,0(r2)
 82328a4:	e0bff515 	stw	r2,-44(fp)
      so->so_state &= ~SS_RCVATMARK;
 82328a8:	e0bffc17 	ldw	r2,-16(fp)
 82328ac:	10c0088b 	ldhu	r3,34(r2)
 82328b0:	00bfefc4 	movi	r2,-65
 82328b4:	1884703a 	and	r2,r3,r2
 82328b8:	1007883a 	mov	r3,r2
 82328bc:	e0bffc17 	ldw	r2,-16(fp)
 82328c0:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 82328c4:	e0bffc17 	ldw	r2,-16(fp)
 82328c8:	10801a17 	ldw	r2,104(r2)
 82328cc:	10000c26 	beq	r2,zero,8232900 <soreceive+0x468>
 82328d0:	e0bffc17 	ldw	r2,-16(fp)
 82328d4:	10c01a17 	ldw	r3,104(r2)
 82328d8:	e0bff717 	ldw	r2,-36(fp)
 82328dc:	1885c83a 	sub	r2,r3,r2
 82328e0:	1007883a 	mov	r3,r2
 82328e4:	e0bff517 	ldw	r2,-44(fp)
 82328e8:	1880050e 	bge	r3,r2,8232900 <soreceive+0x468>
         len = (int)(so->so_oobmark - offset);
 82328ec:	e0bffc17 	ldw	r2,-16(fp)
 82328f0:	10c01a17 	ldw	r3,104(r2)
 82328f4:	e0bff717 	ldw	r2,-36(fp)
 82328f8:	1885c83a 	sub	r2,r3,r2
 82328fc:	e0bff515 	stw	r2,-44(fp)
      if (len > (int)(m->m_len - moff))
 8232900:	e0bff417 	ldw	r2,-48(fp)
 8232904:	10c00217 	ldw	r3,8(r2)
 8232908:	e0bff917 	ldw	r2,-28(fp)
 823290c:	1885c83a 	sub	r2,r3,r2
 8232910:	1007883a 	mov	r3,r2
 8232914:	e0bff517 	ldw	r2,-44(fp)
 8232918:	1880050e 	bge	r3,r2,8232930 <soreceive+0x498>
         len = m->m_len - moff;
 823291c:	e0bff417 	ldw	r2,-48(fp)
 8232920:	10c00217 	ldw	r3,8(r2)
 8232924:	e0bff917 	ldw	r2,-28(fp)
 8232928:	1885c83a 	sub	r2,r3,r2
 823292c:	e0bff515 	stw	r2,-44(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 8232930:	e0bff417 	ldw	r2,-48(fp)
 8232934:	10c00317 	ldw	r3,12(r2)
 8232938:	e0bff917 	ldw	r2,-28(fp)
 823293c:	1885883a 	add	r2,r3,r2
 8232940:	e0fff517 	ldw	r3,-44(fp)
 8232944:	180d883a 	mov	r6,r3
 8232948:	100b883a 	mov	r5,r2
 823294c:	e13ffe17 	ldw	r4,-8(fp)
 8232950:	8202a0c0 	call	8202a0c <memcpy>
      data += len;
 8232954:	e0bff517 	ldw	r2,-44(fp)
 8232958:	e0fffe17 	ldw	r3,-8(fp)
 823295c:	1885883a 	add	r2,r3,r2
 8232960:	e0bffe15 	stw	r2,-8(fp)
      *datalen -= len;
 8232964:	e0bfff17 	ldw	r2,-4(fp)
 8232968:	10c00017 	ldw	r3,0(r2)
 823296c:	e0bff517 	ldw	r2,-44(fp)
 8232970:	1887c83a 	sub	r3,r3,r2
 8232974:	e0bfff17 	ldw	r2,-4(fp)
 8232978:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 823297c:	e0bff417 	ldw	r2,-48(fp)
 8232980:	10c00217 	ldw	r3,8(r2)
 8232984:	e0bff917 	ldw	r2,-28(fp)
 8232988:	1885c83a 	sub	r2,r3,r2
 823298c:	1007883a 	mov	r3,r2
 8232990:	e0bff517 	ldw	r2,-44(fp)
 8232994:	1880201e 	bne	r3,r2,8232a18 <soreceive+0x580>
      {
         if (flags & MSG_PEEK) 
 8232998:	e0800217 	ldw	r2,8(fp)
 823299c:	1080008c 	andi	r2,r2,2
 82329a0:	10000526 	beq	r2,zero,82329b8 <soreceive+0x520>
         {
            m = m->m_next;
 82329a4:	e0bff417 	ldw	r2,-48(fp)
 82329a8:	10800617 	ldw	r2,24(r2)
 82329ac:	e0bff415 	stw	r2,-48(fp)
            moff = 0;
 82329b0:	e03ff915 	stw	zero,-28(fp)
 82329b4:	00003206 	br	8232a80 <soreceive+0x5e8>
         } else 
         {
            nextrecord = m->m_act;
 82329b8:	e0bff417 	ldw	r2,-48(fp)
 82329bc:	10800717 	ldw	r2,28(r2)
 82329c0:	e0bff815 	stw	r2,-32(fp)
            sbfree(&so->so_rcv, m);
 82329c4:	e0bffc17 	ldw	r2,-16(fp)
 82329c8:	10c00a17 	ldw	r3,40(r2)
 82329cc:	e0bff417 	ldw	r2,-48(fp)
 82329d0:	10800217 	ldw	r2,8(r2)
 82329d4:	1887c83a 	sub	r3,r3,r2
 82329d8:	e0bffc17 	ldw	r2,-16(fp)
 82329dc:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 82329e0:	e13ff417 	ldw	r4,-48(fp)
 82329e4:	822e1640 	call	822e164 <m_free>
 82329e8:	1007883a 	mov	r3,r2
 82329ec:	e0bffc17 	ldw	r2,-16(fp)
 82329f0:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 82329f4:	e0bffc17 	ldw	r2,-16(fp)
 82329f8:	10801017 	ldw	r2,64(r2)
 82329fc:	e0bff415 	stw	r2,-48(fp)
            }
            if (m)
 8232a00:	e0bff417 	ldw	r2,-48(fp)
 8232a04:	10001e26 	beq	r2,zero,8232a80 <soreceive+0x5e8>
               m->m_act = nextrecord;
 8232a08:	e0bff417 	ldw	r2,-48(fp)
 8232a0c:	e0fff817 	ldw	r3,-32(fp)
 8232a10:	10c00715 	stw	r3,28(r2)
 8232a14:	00001a06 	br	8232a80 <soreceive+0x5e8>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 8232a18:	e0800217 	ldw	r2,8(fp)
 8232a1c:	1080008c 	andi	r2,r2,2
 8232a20:	10000526 	beq	r2,zero,8232a38 <soreceive+0x5a0>
            moff += len;
 8232a24:	e0fff917 	ldw	r3,-28(fp)
 8232a28:	e0bff517 	ldw	r2,-44(fp)
 8232a2c:	1885883a 	add	r2,r3,r2
 8232a30:	e0bff915 	stw	r2,-28(fp)
 8232a34:	00001206 	br	8232a80 <soreceive+0x5e8>
         else 
         {
            m->m_data += len;
 8232a38:	e0bff417 	ldw	r2,-48(fp)
 8232a3c:	10c00317 	ldw	r3,12(r2)
 8232a40:	e0bff517 	ldw	r2,-44(fp)
 8232a44:	1887883a 	add	r3,r3,r2
 8232a48:	e0bff417 	ldw	r2,-48(fp)
 8232a4c:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 8232a50:	e0bff417 	ldw	r2,-48(fp)
 8232a54:	10c00217 	ldw	r3,8(r2)
 8232a58:	e0bff517 	ldw	r2,-44(fp)
 8232a5c:	1887c83a 	sub	r3,r3,r2
 8232a60:	e0bff417 	ldw	r2,-48(fp)
 8232a64:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 8232a68:	e0bffc17 	ldw	r2,-16(fp)
 8232a6c:	10c00a17 	ldw	r3,40(r2)
 8232a70:	e0bff517 	ldw	r2,-44(fp)
 8232a74:	1887c83a 	sub	r3,r3,r2
 8232a78:	e0bffc17 	ldw	r2,-16(fp)
 8232a7c:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 8232a80:	e0bffc17 	ldw	r2,-16(fp)
 8232a84:	10801a17 	ldw	r2,104(r2)
 8232a88:	10001726 	beq	r2,zero,8232ae8 <soreceive+0x650>
      {
         if ((flags & MSG_PEEK) == 0) 
 8232a8c:	e0800217 	ldw	r2,8(fp)
 8232a90:	1080008c 	andi	r2,r2,2
 8232a94:	1000101e 	bne	r2,zero,8232ad8 <soreceive+0x640>
         {
            so->so_oobmark -= len;
 8232a98:	e0bffc17 	ldw	r2,-16(fp)
 8232a9c:	10c01a17 	ldw	r3,104(r2)
 8232aa0:	e0bff517 	ldw	r2,-44(fp)
 8232aa4:	1887c83a 	sub	r3,r3,r2
 8232aa8:	e0bffc17 	ldw	r2,-16(fp)
 8232aac:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 8232ab0:	e0bffc17 	ldw	r2,-16(fp)
 8232ab4:	10801a17 	ldw	r2,104(r2)
 8232ab8:	10000b1e 	bne	r2,zero,8232ae8 <soreceive+0x650>
            {
               so->so_state |= SS_RCVATMARK;
 8232abc:	e0bffc17 	ldw	r2,-16(fp)
 8232ac0:	1080088b 	ldhu	r2,34(r2)
 8232ac4:	10801014 	ori	r2,r2,64
 8232ac8:	1007883a 	mov	r3,r2
 8232acc:	e0bffc17 	ldw	r2,-16(fp)
 8232ad0:	10c0088d 	sth	r3,34(r2)
               break;
 8232ad4:	00000b06 	br	8232b04 <soreceive+0x66c>
            }
         } else
            offset += len;
 8232ad8:	e0fff717 	ldw	r3,-36(fp)
 8232adc:	e0bff517 	ldw	r2,-44(fp)
 8232ae0:	1885883a 	add	r2,r3,r2
 8232ae4:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 8232ae8:	e0bff417 	ldw	r2,-48(fp)
 8232aec:	10000526 	beq	r2,zero,8232b04 <soreceive+0x66c>
 8232af0:	e0bfff17 	ldw	r2,-4(fp)
 8232af4:	10800017 	ldw	r2,0(r2)
 8232af8:	0080020e 	bge	zero,r2,8232b04 <soreceive+0x66c>
 8232afc:	e0bff617 	ldw	r2,-40(fp)
 8232b00:	103f5b26 	beq	r2,zero,8232870 <soreceive+0x3d8>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 8232b04:	e0800217 	ldw	r2,8(fp)
 8232b08:	1080008c 	andi	r2,r2,2
 8232b0c:	1000241e 	bne	r2,zero,8232ba0 <soreceive+0x708>
   {
      if (m == 0)
 8232b10:	e0bff417 	ldw	r2,-48(fp)
 8232b14:	1000041e 	bne	r2,zero,8232b28 <soreceive+0x690>
         so->so_rcv.sb_mb = nextrecord;
 8232b18:	e0bffc17 	ldw	r2,-16(fp)
 8232b1c:	e0fff817 	ldw	r3,-32(fp)
 8232b20:	10c01015 	stw	r3,64(r2)
 8232b24:	00000906 	br	8232b4c <soreceive+0x6b4>
      else if (pr->pr_flags & PR_ATOMIC)
 8232b28:	e0bffa17 	ldw	r2,-24(fp)
 8232b2c:	1080010b 	ldhu	r2,4(r2)
 8232b30:	10bfffcc 	andi	r2,r2,65535
 8232b34:	1080004c 	andi	r2,r2,1
 8232b38:	10000426 	beq	r2,zero,8232b4c <soreceive+0x6b4>
         (void) sbdroprecord(&so->so_rcv);
 8232b3c:	e0bffc17 	ldw	r2,-16(fp)
 8232b40:	10800a04 	addi	r2,r2,40
 8232b44:	1009883a 	mov	r4,r2
 8232b48:	82348980 	call	8234898 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 8232b4c:	e0bffa17 	ldw	r2,-24(fp)
 8232b50:	1080010b 	ldhu	r2,4(r2)
 8232b54:	10bfffcc 	andi	r2,r2,65535
 8232b58:	1080020c 	andi	r2,r2,8
 8232b5c:	10001026 	beq	r2,zero,8232ba0 <soreceive+0x708>
 8232b60:	e0bffc17 	ldw	r2,-16(fp)
 8232b64:	10800117 	ldw	r2,4(r2)
 8232b68:	10000d26 	beq	r2,zero,8232ba0 <soreceive+0x708>
      {
         so->so_req = PRU_RCVD;
 8232b6c:	e0bffc17 	ldw	r2,-16(fp)
 8232b70:	00c00204 	movi	r3,8
 8232b74:	10c00715 	stw	r3,28(r2)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 8232b78:	e0bffa17 	ldw	r2,-24(fp)
 8232b7c:	10800317 	ldw	r2,12(r2)
 8232b80:	000d883a 	mov	r6,zero
 8232b84:	000b883a 	mov	r5,zero
 8232b88:	e13ffc17 	ldw	r4,-16(fp)
 8232b8c:	103ee83a 	callr	r2
 8232b90:	00000306 	br	8232ba0 <soreceive+0x708>
         error = so->so_error;
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
 8232b94:	0001883a 	nop
 8232b98:	00000106 	br	8232ba0 <soreceive+0x708>
      {
         error = ENOTCONN;
         goto release;
      }
      if (*datalen == 0)
         goto release;
 8232b9c:	0001883a 	nop
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 8232ba0:	e0bffc17 	ldw	r2,-16(fp)
 8232ba4:	10c0110b 	ldhu	r3,68(r2)
 8232ba8:	00bfff84 	movi	r2,-2
 8232bac:	1884703a 	and	r2,r3,r2
 8232bb0:	1007883a 	mov	r3,r2
 8232bb4:	e0bffc17 	ldw	r2,-16(fp)
 8232bb8:	10c0110d 	sth	r3,68(r2)
 8232bbc:	e0bffc17 	ldw	r2,-16(fp)
 8232bc0:	10801104 	addi	r2,r2,68
 8232bc4:	1009883a 	mov	r4,r2
 8232bc8:	82292dc0 	call	82292dc <tcp_wakeup>
   return (error);
 8232bcc:	e0bff617 	ldw	r2,-40(fp)
}
 8232bd0:	e037883a 	mov	sp,fp
 8232bd4:	dfc00117 	ldw	ra,4(sp)
 8232bd8:	df000017 	ldw	fp,0(sp)
 8232bdc:	dec00204 	addi	sp,sp,8
 8232be0:	f800283a 	ret

08232be4 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 8232be4:	defffc04 	addi	sp,sp,-16
 8232be8:	dfc00315 	stw	ra,12(sp)
 8232bec:	df000215 	stw	fp,8(sp)
 8232bf0:	df000204 	addi	fp,sp,8
 8232bf4:	e13ffe15 	stw	r4,-8(fp)
 8232bf8:	e17fff15 	stw	r5,-4(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 8232bfc:	e0bfff17 	ldw	r2,-4(fp)
 8232c00:	10800044 	addi	r2,r2,1
 8232c04:	e0bfff15 	stw	r2,-4(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 8232c08:	e0bfff17 	ldw	r2,-4(fp)
 8232c0c:	1080004c 	andi	r2,r2,1
 8232c10:	10000226 	beq	r2,zero,8232c1c <soshutdown+0x38>
      sorflush(so);
 8232c14:	e13ffe17 	ldw	r4,-8(fp)
 8232c18:	8232c7c0 	call	8232c7c <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 8232c1c:	e0bfff17 	ldw	r2,-4(fp)
 8232c20:	1080008c 	andi	r2,r2,2
 8232c24:	10000f26 	beq	r2,zero,8232c64 <soshutdown+0x80>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 8232c28:	e0bffe17 	ldw	r2,-8(fp)
 8232c2c:	10801204 	addi	r2,r2,72
 8232c30:	1009883a 	mov	r4,r2
 8232c34:	823455c0 	call	823455c <sbflush>
      so->so_req = PRU_SHUTDOWN;
 8232c38:	e0bffe17 	ldw	r2,-8(fp)
 8232c3c:	00c001c4 	movi	r3,7
 8232c40:	10c00715 	stw	r3,28(r2)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 8232c44:	e0bffe17 	ldw	r2,-8(fp)
 8232c48:	10800217 	ldw	r2,8(r2)
 8232c4c:	10800317 	ldw	r2,12(r2)
 8232c50:	000d883a 	mov	r6,zero
 8232c54:	000b883a 	mov	r5,zero
 8232c58:	e13ffe17 	ldw	r4,-8(fp)
 8232c5c:	103ee83a 	callr	r2
 8232c60:	00000106 	br	8232c68 <soshutdown+0x84>
   }

   return 0;
 8232c64:	0005883a 	mov	r2,zero
}
 8232c68:	e037883a 	mov	sp,fp
 8232c6c:	dfc00117 	ldw	ra,4(sp)
 8232c70:	df000017 	ldw	fp,0(sp)
 8232c74:	dec00204 	addi	sp,sp,8
 8232c78:	f800283a 	ret

08232c7c <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 8232c7c:	defffb04 	addi	sp,sp,-20
 8232c80:	dfc00415 	stw	ra,16(sp)
 8232c84:	df000315 	stw	fp,12(sp)
 8232c88:	df000304 	addi	fp,sp,12
 8232c8c:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 8232c90:	e0bfff17 	ldw	r2,-4(fp)
 8232c94:	10800a04 	addi	r2,r2,40
 8232c98:	e0bffd15 	stw	r2,-12(fp)
   int   s;

   sblock(sb);
 8232c9c:	00000406 	br	8232cb0 <sorflush+0x34>
 8232ca0:	e0bffd17 	ldw	r2,-12(fp)
 8232ca4:	10800704 	addi	r2,r2,28
 8232ca8:	1009883a 	mov	r4,r2
 8232cac:	82291680 	call	8229168 <tcp_sleep>
 8232cb0:	e0bffd17 	ldw	r2,-12(fp)
 8232cb4:	1080070b 	ldhu	r2,28(r2)
 8232cb8:	10bfffcc 	andi	r2,r2,65535
 8232cbc:	1080004c 	andi	r2,r2,1
 8232cc0:	103ff71e 	bne	r2,zero,8232ca0 <sorflush+0x24>
 8232cc4:	e0bffd17 	ldw	r2,-12(fp)
 8232cc8:	1080070b 	ldhu	r2,28(r2)
 8232ccc:	10800054 	ori	r2,r2,1
 8232cd0:	1007883a 	mov	r3,r2
 8232cd4:	e0bffd17 	ldw	r2,-12(fp)
 8232cd8:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 8232cdc:	e13fff17 	ldw	r4,-4(fp)
 8232ce0:	8233d780 	call	8233d78 <socantrcvmore>
   sbunlock(sb);
 8232ce4:	e0bffd17 	ldw	r2,-12(fp)
 8232ce8:	10c0070b 	ldhu	r3,28(r2)
 8232cec:	00bfff84 	movi	r2,-2
 8232cf0:	1884703a 	and	r2,r3,r2
 8232cf4:	1007883a 	mov	r3,r2
 8232cf8:	e0bffd17 	ldw	r2,-12(fp)
 8232cfc:	10c0070d 	sth	r3,28(r2)
 8232d00:	e0bffd17 	ldw	r2,-12(fp)
 8232d04:	10800704 	addi	r2,r2,28
 8232d08:	1009883a 	mov	r4,r2
 8232d0c:	82292dc0 	call	82292dc <tcp_wakeup>
   sbrelease(sb);
 8232d10:	e13ffd17 	ldw	r4,-12(fp)
 8232d14:	8233fdc0 	call	8233fdc <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 8232d18:	01800804 	movi	r6,32
 8232d1c:	000b883a 	mov	r5,zero
 8232d20:	e13ffd17 	ldw	r4,-12(fp)
 8232d24:	8202cb00 	call	8202cb0 <memset>
   s = so->so_error;
 8232d28:	e0bfff17 	ldw	r2,-4(fp)
 8232d2c:	10800617 	ldw	r2,24(r2)
 8232d30:	e0bffe15 	stw	r2,-8(fp)
   so->so_error = ESHUTDOWN;
 8232d34:	e0bfff17 	ldw	r2,-4(fp)
 8232d38:	00c01b84 	movi	r3,110
 8232d3c:	10c00615 	stw	r3,24(r2)
   sorwakeup(so);
 8232d40:	e0bfff17 	ldw	r2,-4(fp)
 8232d44:	10800a04 	addi	r2,r2,40
 8232d48:	100b883a 	mov	r5,r2
 8232d4c:	e13fff17 	ldw	r4,-4(fp)
 8232d50:	8233e780 	call	8233e78 <sbwakeup>
   so->so_error = s;
 8232d54:	e0bfff17 	ldw	r2,-4(fp)
 8232d58:	e0fffe17 	ldw	r3,-8(fp)
 8232d5c:	10c00615 	stw	r3,24(r2)
}
 8232d60:	0001883a 	nop
 8232d64:	e037883a 	mov	sp,fp
 8232d68:	dfc00117 	ldw	ra,4(sp)
 8232d6c:	df000017 	ldw	fp,0(sp)
 8232d70:	dec00204 	addi	sp,sp,8
 8232d74:	f800283a 	ret

08232d78 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 8232d78:	defff604 	addi	sp,sp,-40
 8232d7c:	dfc00915 	stw	ra,36(sp)
 8232d80:	df000815 	stw	fp,32(sp)
 8232d84:	df000804 	addi	fp,sp,32
 8232d88:	e13ffd15 	stw	r4,-12(fp)
 8232d8c:	e17ffe15 	stw	r5,-8(fp)
 8232d90:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 8232d94:	e03ff815 	stw	zero,-32(fp)

   switch (optname) 
 8232d98:	e0bffe17 	ldw	r2,-8(fp)
 8232d9c:	10c08020 	cmpeqi	r3,r2,512
 8232da0:	18003b1e 	bne	r3,zero,8232e90 <sosetopt+0x118>
 8232da4:	10c08048 	cmpgei	r3,r2,513
 8232da8:	1800171e 	bne	r3,zero,8232e08 <sosetopt+0x90>
 8232dac:	10c00388 	cmpgei	r3,r2,14
 8232db0:	1800091e 	bne	r3,zero,8232dd8 <sosetopt+0x60>
 8232db4:	10c00248 	cmpgei	r3,r2,9
 8232db8:	1800831e 	bne	r3,zero,8232fc8 <sosetopt+0x250>
 8232dbc:	10c00120 	cmpeqi	r3,r2,4
 8232dc0:	1800331e 	bne	r3,zero,8232e90 <sosetopt+0x118>
 8232dc4:	10c00220 	cmpeqi	r3,r2,8
 8232dc8:	1800311e 	bne	r3,zero,8232e90 <sosetopt+0x118>
 8232dcc:	108000a0 	cmpeqi	r2,r2,2
 8232dd0:	1000831e 	bne	r2,zero,8232fe0 <sosetopt+0x268>
 8232dd4:	0000ea06 	br	8233180 <sosetopt+0x408>
 8232dd8:	10c00820 	cmpeqi	r3,r2,32
 8232ddc:	18002c1e 	bne	r3,zero,8232e90 <sosetopt+0x118>
 8232de0:	10c00848 	cmpgei	r3,r2,33
 8232de4:	1800031e 	bne	r3,zero,8232df4 <sosetopt+0x7c>
 8232de8:	10800420 	cmpeqi	r2,r2,16
 8232dec:	1000281e 	bne	r2,zero,8232e90 <sosetopt+0x118>
 8232df0:	0000e306 	br	8233180 <sosetopt+0x408>
 8232df4:	10c02020 	cmpeqi	r3,r2,128
 8232df8:	1800201e 	bne	r3,zero,8232e7c <sosetopt+0x104>
 8232dfc:	10804020 	cmpeqi	r2,r2,256
 8232e00:	1000231e 	bne	r2,zero,8232e90 <sosetopt+0x118>
 8232e04:	0000de06 	br	8233180 <sosetopt+0x408>
 8232e08:	10c40520 	cmpeqi	r3,r2,4116
 8232e0c:	1800481e 	bne	r3,zero,8232f30 <sosetopt+0x1b8>
 8232e10:	10c40548 	cmpgei	r3,r2,4117
 8232e14:	18000b1e 	bne	r3,zero,8232e44 <sosetopt+0xcc>
 8232e18:	10c401a0 	cmpeqi	r3,r2,4102
 8232e1c:	18003f1e 	bne	r3,zero,8232f1c <sosetopt+0x1a4>
 8232e20:	10c401c8 	cmpgei	r3,r2,4103
 8232e24:	1800041e 	bne	r3,zero,8232e38 <sosetopt+0xc0>
 8232e28:	10bbffc4 	addi	r2,r2,-4097
 8232e2c:	108000a8 	cmpgeui	r2,r2,2
 8232e30:	1000d31e 	bne	r2,zero,8233180 <sosetopt+0x408>
 8232e34:	00002806 	br	8232ed8 <sosetopt+0x160>
 8232e38:	10840420 	cmpeqi	r2,r2,4112
 8232e3c:	1000a91e 	bne	r2,zero,82330e4 <sosetopt+0x36c>
 8232e40:	0000cf06 	br	8233180 <sosetopt+0x408>
 8232e44:	10c800e0 	cmpeqi	r3,r2,8195
 8232e48:	1800a61e 	bne	r3,zero,82330e4 <sosetopt+0x36c>
 8232e4c:	10c80108 	cmpgei	r3,r2,8196
 8232e50:	1800051e 	bne	r3,zero,8232e68 <sosetopt+0xf0>
 8232e54:	10c40560 	cmpeqi	r3,r2,4117
 8232e58:	18003c1e 	bne	r3,zero,8232f4c <sosetopt+0x1d4>
 8232e5c:	108405a0 	cmpeqi	r2,r2,4118
 8232e60:	1000421e 	bne	r2,zero,8232f6c <sosetopt+0x1f4>
 8232e64:	0000c606 	br	8233180 <sosetopt+0x408>
 8232e68:	10c80120 	cmpeqi	r3,r2,8196
 8232e6c:	1800711e 	bne	r3,zero,8233034 <sosetopt+0x2bc>
 8232e70:	10900020 	cmpeqi	r2,r2,16384
 8232e74:	1000061e 	bne	r2,zero,8232e90 <sosetopt+0x118>
 8232e78:	0000c106 	br	8233180 <sosetopt+0x408>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 8232e7c:	e0bfff17 	ldw	r2,-4(fp)
 8232e80:	10800117 	ldw	r2,4(r2)
 8232e84:	1007883a 	mov	r3,r2
 8232e88:	e0bffd17 	ldw	r2,-12(fp)
 8232e8c:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 8232e90:	e0bfff17 	ldw	r2,-4(fp)
 8232e94:	10800017 	ldw	r2,0(r2)
 8232e98:	10000726 	beq	r2,zero,8232eb8 <sosetopt+0x140>
         so->so_options |= optname;
 8232e9c:	e0bffd17 	ldw	r2,-12(fp)
 8232ea0:	10c00417 	ldw	r3,16(r2)
 8232ea4:	e0bffe17 	ldw	r2,-8(fp)
 8232ea8:	1886b03a 	or	r3,r3,r2
 8232eac:	e0bffd17 	ldw	r2,-12(fp)
 8232eb0:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~optname;
      break;
 8232eb4:	0000b606 	br	8233190 <sosetopt+0x418>
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
         so->so_options |= optname;
      else
         so->so_options &= ~optname;
 8232eb8:	e0bffd17 	ldw	r2,-12(fp)
 8232ebc:	10800417 	ldw	r2,16(r2)
 8232ec0:	e0fffe17 	ldw	r3,-8(fp)
 8232ec4:	00c6303a 	nor	r3,zero,r3
 8232ec8:	10c6703a 	and	r3,r2,r3
 8232ecc:	e0bffd17 	ldw	r2,-12(fp)
 8232ed0:	10c00415 	stw	r3,16(r2)
      break;
 8232ed4:	0000ae06 	br	8233190 <sosetopt+0x418>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8232ed8:	e0bffe17 	ldw	r2,-8(fp)
 8232edc:	10840058 	cmpnei	r2,r2,4097
 8232ee0:	1000031e 	bne	r2,zero,8232ef0 <sosetopt+0x178>
 8232ee4:	e0bffd17 	ldw	r2,-12(fp)
 8232ee8:	10801204 	addi	r2,r2,72
 8232eec:	00000206 	br	8232ef8 <sosetopt+0x180>
 8232ef0:	e0bffd17 	ldw	r2,-12(fp)
 8232ef4:	10800a04 	addi	r2,r2,40
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
 8232ef8:	e0ffff17 	ldw	r3,-4(fp)
 8232efc:	18c00017 	ldw	r3,0(r3)
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8232f00:	180b883a 	mov	r5,r3
 8232f04:	1009883a 	mov	r4,r2
 8232f08:	8233f8c0 	call	8233f8c <sbreserve>
 8232f0c:	10009f1e 	bne	r2,zero,823318c <sosetopt+0x414>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 8232f10:	00801a44 	movi	r2,105
 8232f14:	e0bff815 	stw	r2,-32(fp)
         goto bad;
 8232f18:	00009d06 	br	8233190 <sosetopt+0x418>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 8232f1c:	e0bfff17 	ldw	r2,-4(fp)
 8232f20:	10c0000b 	ldhu	r3,0(r2)
 8232f24:	e0bffd17 	ldw	r2,-12(fp)
 8232f28:	10c0118d 	sth	r3,70(r2)
      break;
 8232f2c:	00009806 	br	8233190 <sosetopt+0x418>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 8232f30:	e0bffd17 	ldw	r2,-12(fp)
 8232f34:	1080088b 	ldhu	r2,34(r2)
 8232f38:	10804014 	ori	r2,r2,256
 8232f3c:	1007883a 	mov	r3,r2
 8232f40:	e0bffd17 	ldw	r2,-12(fp)
 8232f44:	10c0088d 	sth	r3,34(r2)
      break;
 8232f48:	00009106 	br	8233190 <sosetopt+0x418>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 8232f4c:	e0bffd17 	ldw	r2,-12(fp)
 8232f50:	10c0088b 	ldhu	r3,34(r2)
 8232f54:	00bfbfc4 	movi	r2,-257
 8232f58:	1884703a 	and	r2,r3,r2
 8232f5c:	1007883a 	mov	r3,r2
 8232f60:	e0bffd17 	ldw	r2,-12(fp)
 8232f64:	10c0088d 	sth	r3,34(r2)
      break;
 8232f68:	00008906 	br	8233190 <sosetopt+0x418>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 8232f6c:	e0bfff17 	ldw	r2,-4(fp)
 8232f70:	1000031e 	bne	r2,zero,8232f80 <sosetopt+0x208>
      {
         error = ENP_PARAM;
 8232f74:	00bffd84 	movi	r2,-10
 8232f78:	e0bff815 	stw	r2,-32(fp)
         break;
 8232f7c:	00008406 	br	8233190 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 8232f80:	e0bfff17 	ldw	r2,-4(fp)
 8232f84:	10800017 	ldw	r2,0(r2)
 8232f88:	10000726 	beq	r2,zero,8232fa8 <sosetopt+0x230>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 8232f8c:	e0bffd17 	ldw	r2,-12(fp)
 8232f90:	1080088b 	ldhu	r2,34(r2)
 8232f94:	10804014 	ori	r2,r2,256
 8232f98:	1007883a 	mov	r3,r2
 8232f9c:	e0bffd17 	ldw	r2,-12(fp)
 8232fa0:	10c0088d 	sth	r3,34(r2)
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
      break;
 8232fa4:	00007a06 	br	8233190 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 8232fa8:	e0bffd17 	ldw	r2,-12(fp)
 8232fac:	10c0088b 	ldhu	r3,34(r2)
 8232fb0:	00bfbfc4 	movi	r2,-257
 8232fb4:	1884703a 	and	r2,r3,r2
 8232fb8:	1007883a 	mov	r3,r2
 8232fbc:	e0bffd17 	ldw	r2,-12(fp)
 8232fc0:	10c0088d 	sth	r3,34(r2)
      break;
 8232fc4:	00007206 	br	8233190 <sosetopt+0x418>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 8232fc8:	e1bfff17 	ldw	r6,-4(fp)
 8232fcc:	e17ffd17 	ldw	r5,-12(fp)
 8232fd0:	e13ffe17 	ldw	r4,-8(fp)
 8232fd4:	8245c000 	call	8245c00 <ip_setmoptions>
 8232fd8:	e0bff815 	stw	r2,-32(fp)
      break;
 8232fdc:	00006c06 	br	8233190 <sosetopt+0x418>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 8232fe0:	e0bfff17 	ldw	r2,-4(fp)
 8232fe4:	1000031e 	bne	r2,zero,8232ff4 <sosetopt+0x27c>
      {
         error = ENP_PARAM;
 8232fe8:	00bffd84 	movi	r2,-10
 8232fec:	e0bff815 	stw	r2,-32(fp)
         break;
 8232ff0:	00006706 	br	8233190 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 8232ff4:	e0bfff17 	ldw	r2,-4(fp)
 8232ff8:	10800017 	ldw	r2,0(r2)
 8232ffc:	10000626 	beq	r2,zero,8233018 <sosetopt+0x2a0>
         so->so_options |= SO_HDRINCL;
 8233000:	e0bffd17 	ldw	r2,-12(fp)
 8233004:	10800417 	ldw	r2,16(r2)
 8233008:	10c80014 	ori	r3,r2,8192
 823300c:	e0bffd17 	ldw	r2,-12(fp)
 8233010:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~SO_HDRINCL;
      break;
 8233014:	00005e06 	br	8233190 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
         so->so_options |= SO_HDRINCL;
      else
         so->so_options &= ~SO_HDRINCL;
 8233018:	e0bffd17 	ldw	r2,-12(fp)
 823301c:	10c00417 	ldw	r3,16(r2)
 8233020:	00b7ffc4 	movi	r2,-8193
 8233024:	1886703a 	and	r3,r3,r2
 8233028:	e0bffd17 	ldw	r2,-12(fp)
 823302c:	10c00415 	stw	r3,16(r2)
      break;
 8233030:	00005706 	br	8233190 <sosetopt+0x418>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233034:	e0bffd17 	ldw	r2,-12(fp)
 8233038:	10800983 	ldbu	r2,38(r2)
 823303c:	10803fcc 	andi	r2,r2,255
 8233040:	1080201c 	xori	r2,r2,128
 8233044:	10bfe004 	addi	r2,r2,-128
 8233048:	10800060 	cmpeqi	r2,r2,1
 823304c:	1000031e 	bne	r2,zero,823305c <sosetopt+0x2e4>
      {
         error = EINVAL;
 8233050:	00800584 	movi	r2,22
 8233054:	e0bff815 	stw	r2,-32(fp)
         break;
 8233058:	00004d06 	br	8233190 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 823305c:	e0bffd17 	ldw	r2,-12(fp)
 8233060:	10800117 	ldw	r2,4(r2)
 8233064:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 8233068:	e0bff917 	ldw	r2,-28(fp)
 823306c:	10800917 	ldw	r2,36(r2)
 8233070:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 8233074:	e0bffa17 	ldw	r2,-24(fp)
 8233078:	1000031e 	bne	r2,zero,8233088 <sosetopt+0x310>
      {
         error = ENOTCONN;
 823307c:	00802004 	movi	r2,128
 8233080:	e0bff815 	stw	r2,-32(fp)
         break;
 8233084:	00004206 	br	8233190 <sosetopt+0x418>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 8233088:	e0bfff17 	ldw	r2,-4(fp)
 823308c:	1000031e 	bne	r2,zero,823309c <sosetopt+0x324>
      {
         error = ENP_PARAM;
 8233090:	00bffd84 	movi	r2,-10
 8233094:	e0bff815 	stw	r2,-32(fp)
         break;
 8233098:	00003d06 	br	8233190 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 823309c:	e0bfff17 	ldw	r2,-4(fp)
 82330a0:	10800017 	ldw	r2,0(r2)
 82330a4:	10000726 	beq	r2,zero,82330c4 <sosetopt+0x34c>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 82330a8:	e0bffa17 	ldw	r2,-24(fp)
 82330ac:	10800b0b 	ldhu	r2,44(r2)
 82330b0:	10800114 	ori	r2,r2,4
 82330b4:	1007883a 	mov	r3,r2
 82330b8:	e0bffa17 	ldw	r2,-24(fp)
 82330bc:	10c00b0d 	sth	r3,44(r2)
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */

      break;
 82330c0:	00003306 	br	8233190 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 82330c4:	e0bffa17 	ldw	r2,-24(fp)
 82330c8:	10c00b0b 	ldhu	r3,44(r2)
 82330cc:	00bffec4 	movi	r2,-5
 82330d0:	1884703a 	and	r2,r3,r2
 82330d4:	1007883a 	mov	r3,r2
 82330d8:	e0bffa17 	ldw	r2,-24(fp)
 82330dc:	10c00b0d 	sth	r3,44(r2)

      break;
 82330e0:	00002b06 	br	8233190 <sosetopt+0x418>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82330e4:	e0bffd17 	ldw	r2,-12(fp)
 82330e8:	10800983 	ldbu	r2,38(r2)
 82330ec:	10803fcc 	andi	r2,r2,255
 82330f0:	1080201c 	xori	r2,r2,128
 82330f4:	10bfe004 	addi	r2,r2,-128
 82330f8:	10800060 	cmpeqi	r2,r2,1
 82330fc:	1000031e 	bne	r2,zero,823310c <sosetopt+0x394>
      {
         error = EINVAL;
 8233100:	00800584 	movi	r2,22
 8233104:	e0bff815 	stw	r2,-32(fp)
         break;
 8233108:	00002106 	br	8233190 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 823310c:	e0bffd17 	ldw	r2,-12(fp)
 8233110:	10800117 	ldw	r2,4(r2)
 8233114:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 8233118:	e0bffb17 	ldw	r2,-20(fp)
 823311c:	10800917 	ldw	r2,36(r2)
 8233120:	e0bffc15 	stw	r2,-16(fp)
      if(!tp)
 8233124:	e0bffc17 	ldw	r2,-16(fp)
 8233128:	1000031e 	bne	r2,zero,8233138 <sosetopt+0x3c0>
      {
         error = ENOTCONN;
 823312c:	00802004 	movi	r2,128
 8233130:	e0bff815 	stw	r2,-32(fp)
         break;
 8233134:	00001606 	br	8233190 <sosetopt+0x418>
      }
      if (tp->t_state != TCPS_CLOSED)
 8233138:	e0bffc17 	ldw	r2,-16(fp)
 823313c:	10800217 	ldw	r2,8(r2)
 8233140:	10000326 	beq	r2,zero,8233150 <sosetopt+0x3d8>
      {
         error = EINVAL;
 8233144:	00800584 	movi	r2,22
 8233148:	e0bff815 	stw	r2,-32(fp)
         break;
 823314c:	00001006 	br	8233190 <sosetopt+0x418>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 8233150:	e0bfff17 	ldw	r2,-4(fp)
 8233154:	10800017 	ldw	r2,0(r2)
 8233158:	1007883a 	mov	r3,r2
 823315c:	e0bffc17 	ldw	r2,-16(fp)
 8233160:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 8233164:	e0bffc17 	ldw	r2,-16(fp)
 8233168:	10800b0b 	ldhu	r2,44(r2)
 823316c:	10810014 	ori	r2,r2,1024
 8233170:	1007883a 	mov	r3,r2
 8233174:	e0bffc17 	ldw	r2,-16(fp)
 8233178:	10c00b0d 	sth	r3,44(r2)
      break;
 823317c:	00000406 	br	8233190 <sosetopt+0x418>
   }
   default:
      error = ENOPROTOOPT;
 8233180:	00801b44 	movi	r2,109
 8233184:	e0bff815 	stw	r2,-32(fp)
      break;
 8233188:	00000106 	br	8233190 <sosetopt+0x418>
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
         goto bad;
      }
      break;
 823318c:	0001883a 	nop
   default:
      error = ENOPROTOOPT;
      break;
   }
bad:
   return (error);
 8233190:	e0bff817 	ldw	r2,-32(fp)
}
 8233194:	e037883a 	mov	sp,fp
 8233198:	dfc00117 	ldw	ra,4(sp)
 823319c:	df000017 	ldw	fp,0(sp)
 82331a0:	dec00204 	addi	sp,sp,8
 82331a4:	f800283a 	ret

082331a8 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 82331a8:	defff504 	addi	sp,sp,-44
 82331ac:	dfc00a15 	stw	ra,40(sp)
 82331b0:	df000915 	stw	fp,36(sp)
 82331b4:	df000904 	addi	fp,sp,36
 82331b8:	e13ffd15 	stw	r4,-12(fp)
 82331bc:	e17ffe15 	stw	r5,-8(fp)
 82331c0:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 82331c4:	e03ff715 	stw	zero,-36(fp)

   /* sanity check the val parameter */
   if (!val)
 82331c8:	e0bfff17 	ldw	r2,-4(fp)
 82331cc:	1000021e 	bne	r2,zero,82331d8 <sogetopt+0x30>
   {
      return ENP_PARAM;
 82331d0:	00bffd84 	movi	r2,-10
 82331d4:	00011906 	br	823363c <sogetopt+0x494>
   }

   switch (optname) 
 82331d8:	e0bffe17 	ldw	r2,-8(fp)
 82331dc:	10c400e0 	cmpeqi	r3,r2,4099
 82331e0:	1800701e 	bne	r3,zero,82333a4 <sogetopt+0x1fc>
 82331e4:	10c40108 	cmpgei	r3,r2,4100
 82331e8:	1800201e 	bne	r3,zero,823326c <sogetopt+0xc4>
 82331ec:	10c00420 	cmpeqi	r3,r2,16
 82331f0:	1800641e 	bne	r3,zero,8233384 <sogetopt+0x1dc>
 82331f4:	10c00448 	cmpgei	r3,r2,17
 82331f8:	18000c1e 	bne	r3,zero,823322c <sogetopt+0x84>
 82331fc:	10c00220 	cmpeqi	r3,r2,8
 8233200:	1800601e 	bne	r3,zero,8233384 <sogetopt+0x1dc>
 8233204:	10c00248 	cmpgei	r3,r2,9
 8233208:	1800051e 	bne	r3,zero,8233220 <sogetopt+0x78>
 823320c:	10c000a0 	cmpeqi	r3,r2,2
 8233210:	1800d61e 	bne	r3,zero,823356c <sogetopt+0x3c4>
 8233214:	10800120 	cmpeqi	r2,r2,4
 8233218:	10005a1e 	bne	r2,zero,8233384 <sogetopt+0x1dc>
 823321c:	00010406 	br	8233630 <sogetopt+0x488>
 8233220:	10800308 	cmpgei	r2,r2,12
 8233224:	1001021e 	bne	r2,zero,8233630 <sogetopt+0x488>
 8233228:	0000ca06 	br	8233554 <sogetopt+0x3ac>
 823322c:	10c04020 	cmpeqi	r3,r2,256
 8233230:	1800541e 	bne	r3,zero,8233384 <sogetopt+0x1dc>
 8233234:	10c04048 	cmpgei	r3,r2,257
 8233238:	1800051e 	bne	r3,zero,8233250 <sogetopt+0xa8>
 823323c:	10c00820 	cmpeqi	r3,r2,32
 8233240:	1800501e 	bne	r3,zero,8233384 <sogetopt+0x1dc>
 8233244:	10802020 	cmpeqi	r2,r2,128
 8233248:	10003f1e 	bne	r2,zero,8233348 <sogetopt+0x1a0>
 823324c:	0000f806 	br	8233630 <sogetopt+0x488>
 8233250:	10c40060 	cmpeqi	r3,r2,4097
 8233254:	18005f1e 	bne	r3,zero,82333d4 <sogetopt+0x22c>
 8233258:	10c40088 	cmpgei	r3,r2,4098
 823325c:	1800631e 	bne	r3,zero,82333ec <sogetopt+0x244>
 8233260:	10808020 	cmpeqi	r2,r2,512
 8233264:	1000471e 	bne	r2,zero,8233384 <sogetopt+0x1dc>
 8233268:	0000f106 	br	8233630 <sogetopt+0x488>
 823326c:	10c40420 	cmpeqi	r3,r2,4112
 8233270:	18007f1e 	bne	r3,zero,8233470 <sogetopt+0x2c8>
 8233274:	10c40448 	cmpgei	r3,r2,4113
 8233278:	1800101e 	bne	r3,zero,82332bc <sogetopt+0x114>
 823327c:	10c401a0 	cmpeqi	r3,r2,4102
 8233280:	18009b1e 	bne	r3,zero,82334f0 <sogetopt+0x348>
 8233284:	10c401c8 	cmpgei	r3,r2,4103
 8233288:	1800051e 	bne	r3,zero,82332a0 <sogetopt+0xf8>
 823328c:	10c40120 	cmpeqi	r3,r2,4100
 8233290:	18004a1e 	bne	r3,zero,82333bc <sogetopt+0x214>
 8233294:	10840160 	cmpeqi	r2,r2,4101
 8233298:	1000901e 	bne	r2,zero,82334dc <sogetopt+0x334>
 823329c:	0000e406 	br	8233630 <sogetopt+0x488>
 82332a0:	10c40220 	cmpeqi	r3,r2,4104
 82332a4:	1800631e 	bne	r3,zero,8233434 <sogetopt+0x28c>
 82332a8:	10c40210 	cmplti	r3,r2,4104
 82332ac:	1800691e 	bne	r3,zero,8233454 <sogetopt+0x2ac>
 82332b0:	10840260 	cmpeqi	r2,r2,4105
 82332b4:	1000931e 	bne	r2,zero,8233504 <sogetopt+0x35c>
 82332b8:	0000dd06 	br	8233630 <sogetopt+0x488>
 82332bc:	10c404e0 	cmpeqi	r3,r2,4115
 82332c0:	18000e1e 	bne	r3,zero,82332fc <sogetopt+0x154>
 82332c4:	10c40508 	cmpgei	r3,r2,4116
 82332c8:	1800051e 	bne	r3,zero,82332e0 <sogetopt+0x138>
 82332cc:	10c40460 	cmpeqi	r3,r2,4113
 82332d0:	18004c1e 	bne	r3,zero,8233404 <sogetopt+0x25c>
 82332d4:	108404a0 	cmpeqi	r2,r2,4114
 82332d8:	1000501e 	bne	r2,zero,823341c <sogetopt+0x274>
 82332dc:	0000d406 	br	8233630 <sogetopt+0x488>
 82332e0:	10c800e0 	cmpeqi	r3,r2,8195
 82332e4:	1800621e 	bne	r3,zero,8233470 <sogetopt+0x2c8>
 82332e8:	10c80120 	cmpeqi	r3,r2,8196
 82332ec:	1800aa1e 	bne	r3,zero,8233598 <sogetopt+0x3f0>
 82332f0:	108405a0 	cmpeqi	r2,r2,4118
 82332f4:	10008b1e 	bne	r2,zero,8233524 <sogetopt+0x37c>
 82332f8:	0000cd06 	br	8233630 <sogetopt+0x488>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 82332fc:	e0bffd17 	ldw	r2,-12(fp)
 8233300:	1080088b 	ldhu	r2,34(r2)
 8233304:	10bfffcc 	andi	r2,r2,65535
 8233308:	1080008c 	andi	r2,r2,2
 823330c:	10000726 	beq	r2,zero,823332c <sogetopt+0x184>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 8233310:	e0bffd17 	ldw	r2,-12(fp)
 8233314:	10800117 	ldw	r2,4(r2)
 8233318:	10800a17 	ldw	r2,40(r2)
 823331c:	10c00a17 	ldw	r3,40(r2)
 8233320:	e0bfff17 	ldw	r2,-4(fp)
 8233324:	10c00015 	stw	r3,0(r2)
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
      break;
 8233328:	0000c306 	br	8233638 <sogetopt+0x490>
      if (so->so_state & SS_ISCONNECTED)
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 823332c:	008209b4 	movhi	r2,2086
 8233330:	10b6b204 	addi	r2,r2,-9528
 8233334:	10800017 	ldw	r2,0(r2)
 8233338:	10c00a17 	ldw	r3,40(r2)
 823333c:	e0bfff17 	ldw	r2,-4(fp)
 8233340:	10c00015 	stw	r3,0(r2)
      break;
 8233344:	0000bc06 	br	8233638 <sogetopt+0x490>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 8233348:	e0bfff17 	ldw	r2,-4(fp)
 823334c:	e0bff815 	stw	r2,-32(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 8233350:	e0bffd17 	ldw	r2,-12(fp)
 8233354:	10800417 	ldw	r2,16(r2)
 8233358:	10c0200c 	andi	r3,r2,128
 823335c:	e0bff817 	ldw	r2,-32(fp)
 8233360:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 8233364:	e0bffd17 	ldw	r2,-12(fp)
 8233368:	1080080b 	ldhu	r2,32(r2)
 823336c:	10ffffcc 	andi	r3,r2,65535
 8233370:	18e0001c 	xori	r3,r3,32768
 8233374:	18e00004 	addi	r3,r3,-32768
 8233378:	e0bff817 	ldw	r2,-32(fp)
 823337c:	10c00115 	stw	r3,4(r2)
      }
      break;
 8233380:	0000ad06 	br	8233638 <sogetopt+0x490>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 8233384:	e0bffd17 	ldw	r2,-12(fp)
 8233388:	10c00417 	ldw	r3,16(r2)
 823338c:	e0bffe17 	ldw	r2,-8(fp)
 8233390:	1884703a 	and	r2,r3,r2
 8233394:	1007883a 	mov	r3,r2
 8233398:	e0bfff17 	ldw	r2,-4(fp)
 823339c:	10c00015 	stw	r3,0(r2)
      break;
 82333a0:	0000a506 	br	8233638 <sogetopt+0x490>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 82333a4:	e0bffd17 	ldw	r2,-12(fp)
 82333a8:	10801617 	ldw	r2,88(r2)
 82333ac:	1007883a 	mov	r3,r2
 82333b0:	e0bfff17 	ldw	r2,-4(fp)
 82333b4:	10c00015 	stw	r3,0(r2)
      break;
 82333b8:	00009f06 	br	8233638 <sogetopt+0x490>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 82333bc:	e0bffd17 	ldw	r2,-12(fp)
 82333c0:	10800e17 	ldw	r2,56(r2)
 82333c4:	1007883a 	mov	r3,r2
 82333c8:	e0bfff17 	ldw	r2,-4(fp)
 82333cc:	10c00015 	stw	r3,0(r2)
      break;
 82333d0:	00009906 	br	8233638 <sogetopt+0x490>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 82333d4:	e0bffd17 	ldw	r2,-12(fp)
 82333d8:	10801317 	ldw	r2,76(r2)
 82333dc:	1007883a 	mov	r3,r2
 82333e0:	e0bfff17 	ldw	r2,-4(fp)
 82333e4:	10c00015 	stw	r3,0(r2)
      break;
 82333e8:	00009306 	br	8233638 <sogetopt+0x490>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 82333ec:	e0bffd17 	ldw	r2,-12(fp)
 82333f0:	10800b17 	ldw	r2,44(r2)
 82333f4:	1007883a 	mov	r3,r2
 82333f8:	e0bfff17 	ldw	r2,-4(fp)
 82333fc:	10c00015 	stw	r3,0(r2)
      break;
 8233400:	00008d06 	br	8233638 <sogetopt+0x490>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 8233404:	e0bffd17 	ldw	r2,-12(fp)
 8233408:	10800a17 	ldw	r2,40(r2)
 823340c:	1007883a 	mov	r3,r2
 8233410:	e0bfff17 	ldw	r2,-4(fp)
 8233414:	10c00015 	stw	r3,0(r2)
      break;
 8233418:	00008706 	br	8233638 <sogetopt+0x490>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 823341c:	e0bffd17 	ldw	r2,-12(fp)
 8233420:	10801217 	ldw	r2,72(r2)
 8233424:	1007883a 	mov	r3,r2
 8233428:	e0bfff17 	ldw	r2,-4(fp)
 823342c:	10c00015 	stw	r3,0(r2)
      break;
 8233430:	00008106 	br	8233638 <sogetopt+0x490>

   case SO_TYPE:
      *(int *)val = so->so_type;
 8233434:	e0bffd17 	ldw	r2,-12(fp)
 8233438:	10800983 	ldbu	r2,38(r2)
 823343c:	10c03fcc 	andi	r3,r2,255
 8233440:	18c0201c 	xori	r3,r3,128
 8233444:	18ffe004 	addi	r3,r3,-128
 8233448:	e0bfff17 	ldw	r2,-4(fp)
 823344c:	10c00015 	stw	r3,0(r2)
      break;
 8233450:	00007906 	br	8233638 <sogetopt+0x490>

   case SO_ERROR:
      *(int *)val = so->so_error;
 8233454:	e0bffd17 	ldw	r2,-12(fp)
 8233458:	10c00617 	ldw	r3,24(r2)
 823345c:	e0bfff17 	ldw	r2,-4(fp)
 8233460:	10c00015 	stw	r3,0(r2)
      so->so_error = 0;
 8233464:	e0bffd17 	ldw	r2,-12(fp)
 8233468:	10000615 	stw	zero,24(r2)
      break;
 823346c:	00007206 	br	8233638 <sogetopt+0x490>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233470:	e0bffd17 	ldw	r2,-12(fp)
 8233474:	10800983 	ldbu	r2,38(r2)
 8233478:	10803fcc 	andi	r2,r2,255
 823347c:	1080201c 	xori	r2,r2,128
 8233480:	10bfe004 	addi	r2,r2,-128
 8233484:	10800060 	cmpeqi	r2,r2,1
 8233488:	1000031e 	bne	r2,zero,8233498 <sogetopt+0x2f0>
      {
         error = EINVAL;
 823348c:	00800584 	movi	r2,22
 8233490:	e0bff715 	stw	r2,-36(fp)
         break;
 8233494:	00006806 	br	8233638 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233498:	e0bffd17 	ldw	r2,-12(fp)
 823349c:	10800117 	ldw	r2,4(r2)
 82334a0:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 82334a4:	e0bff917 	ldw	r2,-28(fp)
 82334a8:	10800917 	ldw	r2,36(r2)
 82334ac:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 82334b0:	e0bffa17 	ldw	r2,-24(fp)
 82334b4:	1000031e 	bne	r2,zero,82334c4 <sogetopt+0x31c>
      {
         error = ENOTCONN;
 82334b8:	00802004 	movi	r2,128
 82334bc:	e0bff715 	stw	r2,-36(fp)
         break;
 82334c0:	00005d06 	br	8233638 <sogetopt+0x490>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 82334c4:	e0bffa17 	ldw	r2,-24(fp)
 82334c8:	10800a0b 	ldhu	r2,40(r2)
 82334cc:	10ffffcc 	andi	r3,r2,65535
 82334d0:	e0bfff17 	ldw	r2,-4(fp)
 82334d4:	10c00015 	stw	r3,0(r2)
      break;
 82334d8:	00005706 	br	8233638 <sogetopt+0x490>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 82334dc:	e0bffd17 	ldw	r2,-12(fp)
 82334e0:	10c0198b 	ldhu	r3,102(r2)
 82334e4:	e0bfff17 	ldw	r2,-4(fp)
 82334e8:	10c0000d 	sth	r3,0(r2)
      break;
 82334ec:	00005206 	br	8233638 <sogetopt+0x490>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 82334f0:	e0bffd17 	ldw	r2,-12(fp)
 82334f4:	10c0118b 	ldhu	r3,70(r2)
 82334f8:	e0bfff17 	ldw	r2,-4(fp)
 82334fc:	10c0000d 	sth	r3,0(r2)
      break;
 8233500:	00004d06 	br	8233638 <sogetopt+0x490>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 8233504:	e0bffd17 	ldw	r2,-12(fp)
 8233508:	108009c3 	ldbu	r2,39(r2)
 823350c:	10c03fcc 	andi	r3,r2,255
 8233510:	18c0201c 	xori	r3,r3,128
 8233514:	18ffe004 	addi	r3,r3,-128
 8233518:	e0bfff17 	ldw	r2,-4(fp)
 823351c:	10c00015 	stw	r3,0(r2)
      break;
 8233520:	00004506 	br	8233638 <sogetopt+0x490>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 8233524:	e0bffd17 	ldw	r2,-12(fp)
 8233528:	1080088b 	ldhu	r2,34(r2)
 823352c:	10bfffcc 	andi	r2,r2,65535
 8233530:	1080400c 	andi	r2,r2,256
 8233534:	10000426 	beq	r2,zero,8233548 <sogetopt+0x3a0>
         *(int *)val = 1;   /* return 1 in val */
 8233538:	e0bfff17 	ldw	r2,-4(fp)
 823353c:	00c00044 	movi	r3,1
 8233540:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;     /* return 0 in val */
      break;
 8233544:	00003c06 	br	8233638 <sogetopt+0x490>
   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
         *(int *)val = 1;   /* return 1 in val */
      else
         *(int *)val = 0;     /* return 0 in val */
 8233548:	e0bfff17 	ldw	r2,-4(fp)
 823354c:	10000015 	stw	zero,0(r2)
      break;
 8233550:	00003906 	br	8233638 <sogetopt+0x490>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 8233554:	e1bfff17 	ldw	r6,-4(fp)
 8233558:	e17ffd17 	ldw	r5,-12(fp)
 823355c:	e13ffe17 	ldw	r4,-8(fp)
 8233560:	82461c80 	call	82461c8 <ip_getmoptions>
 8233564:	e0bff715 	stw	r2,-36(fp)
      break;
 8233568:	00003306 	br	8233638 <sogetopt+0x490>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 823356c:	e0bffd17 	ldw	r2,-12(fp)
 8233570:	10800417 	ldw	r2,16(r2)
 8233574:	1088000c 	andi	r2,r2,8192
 8233578:	10000426 	beq	r2,zero,823358c <sogetopt+0x3e4>
         *(int *)val = 1;
 823357c:	e0bfff17 	ldw	r2,-4(fp)
 8233580:	00c00044 	movi	r3,1
 8233584:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;
      break;
 8233588:	00002b06 	br	8233638 <sogetopt+0x490>
   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
         *(int *)val = 1;
      else
         *(int *)val = 0;
 823358c:	e0bfff17 	ldw	r2,-4(fp)
 8233590:	10000015 	stw	zero,0(r2)
      break;
 8233594:	00002806 	br	8233638 <sogetopt+0x490>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233598:	e0bffd17 	ldw	r2,-12(fp)
 823359c:	10800983 	ldbu	r2,38(r2)
 82335a0:	10803fcc 	andi	r2,r2,255
 82335a4:	1080201c 	xori	r2,r2,128
 82335a8:	10bfe004 	addi	r2,r2,-128
 82335ac:	10800060 	cmpeqi	r2,r2,1
 82335b0:	1000031e 	bne	r2,zero,82335c0 <sogetopt+0x418>
      {
         error = EINVAL;
 82335b4:	00800584 	movi	r2,22
 82335b8:	e0bff715 	stw	r2,-36(fp)
         break;
 82335bc:	00001e06 	br	8233638 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82335c0:	e0bffd17 	ldw	r2,-12(fp)
 82335c4:	10800117 	ldw	r2,4(r2)
 82335c8:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 82335cc:	e0bffb17 	ldw	r2,-20(fp)
 82335d0:	10800917 	ldw	r2,36(r2)
 82335d4:	e0bffc15 	stw	r2,-16(fp)
      if (!tp)
 82335d8:	e0bffc17 	ldw	r2,-16(fp)
 82335dc:	1000031e 	bne	r2,zero,82335ec <sogetopt+0x444>
      {
         error = ENOTCONN;
 82335e0:	00802004 	movi	r2,128
 82335e4:	e0bff715 	stw	r2,-36(fp)
         break;
 82335e8:	00001306 	br	8233638 <sogetopt+0x490>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 82335ec:	e0bfff17 	ldw	r2,-4(fp)
 82335f0:	1000031e 	bne	r2,zero,8233600 <sogetopt+0x458>
      {
         error = ENP_PARAM;
 82335f4:	00bffd84 	movi	r2,-10
 82335f8:	e0bff715 	stw	r2,-36(fp)
         break;
 82335fc:	00000e06 	br	8233638 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 8233600:	e0bffc17 	ldw	r2,-16(fp)
 8233604:	10800b0b 	ldhu	r2,44(r2)
 8233608:	10bfffcc 	andi	r2,r2,65535
 823360c:	1080010c 	andi	r2,r2,4
 8233610:	10000426 	beq	r2,zero,8233624 <sogetopt+0x47c>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 8233614:	e0bfff17 	ldw	r2,-4(fp)
 8233618:	00c00044 	movi	r3,1
 823361c:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */

      break;
 8233620:	00000506 	br	8233638 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 8233624:	e0bfff17 	ldw	r2,-4(fp)
 8233628:	10000015 	stw	zero,0(r2)

      break;
 823362c:	00000206 	br	8233638 <sogetopt+0x490>
   }

   default:
      return ENOPROTOOPT;
 8233630:	00801b44 	movi	r2,109
 8233634:	00000106 	br	823363c <sogetopt+0x494>
   }
   return error;     /* no error */
 8233638:	e0bff717 	ldw	r2,-36(fp)
}
 823363c:	e037883a 	mov	sp,fp
 8233640:	dfc00117 	ldw	ra,4(sp)
 8233644:	df000017 	ldw	fp,0(sp)
 8233648:	dec00204 	addi	sp,sp,8
 823364c:	f800283a 	ret

08233650 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 8233650:	defffd04 	addi	sp,sp,-12
 8233654:	dfc00215 	stw	ra,8(sp)
 8233658:	df000115 	stw	fp,4(sp)
 823365c:	df000104 	addi	fp,sp,4
 8233660:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 8233664:	e0bfff17 	ldw	r2,-4(fp)
 8233668:	00c03644 	movi	r3,217
 823366c:	10c00615 	stw	r3,24(r2)
   sorwakeup (so);
 8233670:	e0bfff17 	ldw	r2,-4(fp)
 8233674:	10800a04 	addi	r2,r2,40
 8233678:	100b883a 	mov	r5,r2
 823367c:	e13fff17 	ldw	r4,-4(fp)
 8233680:	8233e780 	call	8233e78 <sbwakeup>
}
 8233684:	0001883a 	nop
 8233688:	e037883a 	mov	sp,fp
 823368c:	dfc00117 	ldw	ra,4(sp)
 8233690:	df000017 	ldw	fp,0(sp)
 8233694:	dec00204 	addi	sp,sp,8
 8233698:	f800283a 	ret

0823369c <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 823369c:	defffd04 	addi	sp,sp,-12
 82336a0:	dfc00215 	stw	ra,8(sp)
 82336a4:	df000115 	stw	fp,4(sp)
 82336a8:	df000104 	addi	fp,sp,4
 82336ac:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 82336b0:	e0bfff17 	ldw	r2,-4(fp)
 82336b4:	10c0088b 	ldhu	r3,34(r2)
 82336b8:	00bffd44 	movi	r2,-11
 82336bc:	1884703a 	and	r2,r3,r2
 82336c0:	1007883a 	mov	r3,r2
 82336c4:	e0bfff17 	ldw	r2,-4(fp)
 82336c8:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 82336cc:	e0bfff17 	ldw	r2,-4(fp)
 82336d0:	1080088b 	ldhu	r2,34(r2)
 82336d4:	10800114 	ori	r2,r2,4
 82336d8:	1007883a 	mov	r3,r2
 82336dc:	e0bfff17 	ldw	r2,-4(fp)
 82336e0:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 82336e4:	e0bfff17 	ldw	r2,-4(fp)
 82336e8:	10800904 	addi	r2,r2,36
 82336ec:	1009883a 	mov	r4,r2
 82336f0:	82292dc0 	call	82292dc <tcp_wakeup>
}
 82336f4:	0001883a 	nop
 82336f8:	e037883a 	mov	sp,fp
 82336fc:	dfc00117 	ldw	ra,4(sp)
 8233700:	df000017 	ldw	fp,0(sp)
 8233704:	dec00204 	addi	sp,sp,8
 8233708:	f800283a 	ret

0823370c <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 823370c:	defffc04 	addi	sp,sp,-16
 8233710:	dfc00315 	stw	ra,12(sp)
 8233714:	df000215 	stw	fp,8(sp)
 8233718:	df000204 	addi	fp,sp,8
 823371c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 8233720:	e0bfff17 	ldw	r2,-4(fp)
 8233724:	10801b17 	ldw	r2,108(r2)
 8233728:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 823372c:	e0bffe17 	ldw	r2,-8(fp)
 8233730:	10001426 	beq	r2,zero,8233784 <soisconnected+0x78>
   {
      if (soqremque(so, 0) == 0)
 8233734:	000b883a 	mov	r5,zero
 8233738:	e13fff17 	ldw	r4,-4(fp)
 823373c:	8233c180 	call	8233c18 <soqremque>
 8233740:	1000031e 	bne	r2,zero,8233750 <soisconnected+0x44>
         panic("soisconnected");
 8233744:	01020974 	movhi	r4,2085
 8233748:	21022104 	addi	r4,r4,2180
 823374c:	822887c0 	call	822887c <panic>
      soqinsque(head, so, 1);
 8233750:	01800044 	movi	r6,1
 8233754:	e17fff17 	ldw	r5,-4(fp)
 8233758:	e13ffe17 	ldw	r4,-8(fp)
 823375c:	8233b6c0 	call	8233b6c <soqinsque>
      sorwakeup(head);
 8233760:	e0bffe17 	ldw	r2,-8(fp)
 8233764:	10800a04 	addi	r2,r2,40
 8233768:	100b883a 	mov	r5,r2
 823376c:	e13ffe17 	ldw	r4,-8(fp)
 8233770:	8233e780 	call	8233e78 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 8233774:	e0bffe17 	ldw	r2,-8(fp)
 8233778:	10800904 	addi	r2,r2,36
 823377c:	1009883a 	mov	r4,r2
 8233780:	82292dc0 	call	82292dc <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 8233784:	e0bfff17 	ldw	r2,-4(fp)
 8233788:	10c0088b 	ldhu	r3,34(r2)
 823378c:	00bffcc4 	movi	r2,-13
 8233790:	1884703a 	and	r2,r3,r2
 8233794:	1007883a 	mov	r3,r2
 8233798:	e0bfff17 	ldw	r2,-4(fp)
 823379c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 82337a0:	e0bfff17 	ldw	r2,-4(fp)
 82337a4:	1080088b 	ldhu	r2,34(r2)
 82337a8:	10800094 	ori	r2,r2,2
 82337ac:	1007883a 	mov	r3,r2
 82337b0:	e0bfff17 	ldw	r2,-4(fp)
 82337b4:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 82337b8:	e0bfff17 	ldw	r2,-4(fp)
 82337bc:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 82337c0:	e0bfff17 	ldw	r2,-4(fp)
 82337c4:	10800904 	addi	r2,r2,36
 82337c8:	1009883a 	mov	r4,r2
 82337cc:	82292dc0 	call	82292dc <tcp_wakeup>
   sorwakeup (so);
 82337d0:	e0bfff17 	ldw	r2,-4(fp)
 82337d4:	10800a04 	addi	r2,r2,40
 82337d8:	100b883a 	mov	r5,r2
 82337dc:	e13fff17 	ldw	r4,-4(fp)
 82337e0:	8233e780 	call	8233e78 <sbwakeup>
   sowwakeup (so);
 82337e4:	e0bfff17 	ldw	r2,-4(fp)
 82337e8:	10801204 	addi	r2,r2,72
 82337ec:	100b883a 	mov	r5,r2
 82337f0:	e13fff17 	ldw	r4,-4(fp)
 82337f4:	8233e780 	call	8233e78 <sbwakeup>
}
 82337f8:	0001883a 	nop
 82337fc:	e037883a 	mov	sp,fp
 8233800:	dfc00117 	ldw	ra,4(sp)
 8233804:	df000017 	ldw	fp,0(sp)
 8233808:	dec00204 	addi	sp,sp,8
 823380c:	f800283a 	ret

08233810 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 8233810:	defffd04 	addi	sp,sp,-12
 8233814:	dfc00215 	stw	ra,8(sp)
 8233818:	df000115 	stw	fp,4(sp)
 823381c:	df000104 	addi	fp,sp,4
 8233820:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 8233824:	e0bfff17 	ldw	r2,-4(fp)
 8233828:	10c0088b 	ldhu	r3,34(r2)
 823382c:	00bffec4 	movi	r2,-5
 8233830:	1884703a 	and	r2,r3,r2
 8233834:	1007883a 	mov	r3,r2
 8233838:	e0bfff17 	ldw	r2,-4(fp)
 823383c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233840:	e0bfff17 	ldw	r2,-4(fp)
 8233844:	1080088b 	ldhu	r2,34(r2)
 8233848:	10800e14 	ori	r2,r2,56
 823384c:	1007883a 	mov	r3,r2
 8233850:	e0bfff17 	ldw	r2,-4(fp)
 8233854:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 8233858:	e0bfff17 	ldw	r2,-4(fp)
 823385c:	10800904 	addi	r2,r2,36
 8233860:	1009883a 	mov	r4,r2
 8233864:	82292dc0 	call	82292dc <tcp_wakeup>
   sowwakeup (so);
 8233868:	e0bfff17 	ldw	r2,-4(fp)
 823386c:	10801204 	addi	r2,r2,72
 8233870:	100b883a 	mov	r5,r2
 8233874:	e13fff17 	ldw	r4,-4(fp)
 8233878:	8233e780 	call	8233e78 <sbwakeup>
   sorwakeup (so);
 823387c:	e0bfff17 	ldw	r2,-4(fp)
 8233880:	10800a04 	addi	r2,r2,40
 8233884:	100b883a 	mov	r5,r2
 8233888:	e13fff17 	ldw	r4,-4(fp)
 823388c:	8233e780 	call	8233e78 <sbwakeup>
}
 8233890:	0001883a 	nop
 8233894:	e037883a 	mov	sp,fp
 8233898:	dfc00117 	ldw	ra,4(sp)
 823389c:	df000017 	ldw	fp,0(sp)
 82338a0:	dec00204 	addi	sp,sp,8
 82338a4:	f800283a 	ret

082338a8 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 82338a8:	defffd04 	addi	sp,sp,-12
 82338ac:	dfc00215 	stw	ra,8(sp)
 82338b0:	df000115 	stw	fp,4(sp)
 82338b4:	df000104 	addi	fp,sp,4
 82338b8:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 82338bc:	e0bfff17 	ldw	r2,-4(fp)
 82338c0:	1080088b 	ldhu	r2,34(r2)
 82338c4:	10bfffcc 	andi	r2,r2,65535
 82338c8:	1080010c 	andi	r2,r2,4
 82338cc:	10000626 	beq	r2,zero,82338e8 <soisdisconnected+0x40>
      so->so_state |= SS_WASCONNECTING;
 82338d0:	e0bfff17 	ldw	r2,-4(fp)
 82338d4:	1080088b 	ldhu	r2,34(r2)
 82338d8:	10880014 	ori	r2,r2,8192
 82338dc:	1007883a 	mov	r3,r2
 82338e0:	e0bfff17 	ldw	r2,-4(fp)
 82338e4:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 82338e8:	e0bfff17 	ldw	r2,-4(fp)
 82338ec:	10c0088b 	ldhu	r3,34(r2)
 82338f0:	00bffc44 	movi	r2,-15
 82338f4:	1884703a 	and	r2,r3,r2
 82338f8:	1007883a 	mov	r3,r2
 82338fc:	e0bfff17 	ldw	r2,-4(fp)
 8233900:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233904:	e0bfff17 	ldw	r2,-4(fp)
 8233908:	1080088b 	ldhu	r2,34(r2)
 823390c:	10800c14 	ori	r2,r2,48
 8233910:	1007883a 	mov	r3,r2
 8233914:	e0bfff17 	ldw	r2,-4(fp)
 8233918:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 823391c:	e0bfff17 	ldw	r2,-4(fp)
 8233920:	10800904 	addi	r2,r2,36
 8233924:	1009883a 	mov	r4,r2
 8233928:	82292dc0 	call	82292dc <tcp_wakeup>
   sowwakeup (so);
 823392c:	e0bfff17 	ldw	r2,-4(fp)
 8233930:	10801204 	addi	r2,r2,72
 8233934:	100b883a 	mov	r5,r2
 8233938:	e13fff17 	ldw	r4,-4(fp)
 823393c:	8233e780 	call	8233e78 <sbwakeup>
   sorwakeup (so);
 8233940:	e0bfff17 	ldw	r2,-4(fp)
 8233944:	10800a04 	addi	r2,r2,40
 8233948:	100b883a 	mov	r5,r2
 823394c:	e13fff17 	ldw	r4,-4(fp)
 8233950:	8233e780 	call	8233e78 <sbwakeup>
}
 8233954:	0001883a 	nop
 8233958:	e037883a 	mov	sp,fp
 823395c:	dfc00117 	ldw	ra,4(sp)
 8233960:	df000017 	ldw	fp,0(sp)
 8233964:	dec00204 	addi	sp,sp,8
 8233968:	f800283a 	ret

0823396c <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 823396c:	defffb04 	addi	sp,sp,-20
 8233970:	dfc00415 	stw	ra,16(sp)
 8233974:	df000315 	stw	fp,12(sp)
 8233978:	df000304 	addi	fp,sp,12
 823397c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 8233980:	e0bfff17 	ldw	r2,-4(fp)
 8233984:	10801e43 	ldbu	r2,121(r2)
 8233988:	10c03fcc 	andi	r3,r2,255
 823398c:	18c0201c 	xori	r3,r3,128
 8233990:	18ffe004 	addi	r3,r3,-128
 8233994:	e0bfff17 	ldw	r2,-4(fp)
 8233998:	10801e03 	ldbu	r2,120(r2)
 823399c:	10803fcc 	andi	r2,r2,255
 82339a0:	1080201c 	xori	r2,r2,128
 82339a4:	10bfe004 	addi	r2,r2,-128
 82339a8:	1889883a 	add	r4,r3,r2
 82339ac:	e0bfff17 	ldw	r2,-4(fp)
 82339b0:	10801e83 	ldbu	r2,122(r2)
 82339b4:	10c03fcc 	andi	r3,r2,255
 82339b8:	18c0201c 	xori	r3,r3,128
 82339bc:	18ffe004 	addi	r3,r3,-128
 82339c0:	1805883a 	mov	r2,r3
 82339c4:	1085883a 	add	r2,r2,r2
 82339c8:	10c5883a 	add	r2,r2,r3
 82339cc:	1006d7fa 	srli	r3,r2,31
 82339d0:	1885883a 	add	r2,r3,r2
 82339d4:	1005d07a 	srai	r2,r2,1
 82339d8:	11005b16 	blt	r2,r4,8233b48 <sonewconn+0x1dc>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 82339dc:	01002104 	movi	r4,132
 82339e0:	822dda00 	call	822dda0 <npalloc>
 82339e4:	e0bffd15 	stw	r2,-12(fp)
 82339e8:	e0bffd17 	ldw	r2,-12(fp)
 82339ec:	10005826 	beq	r2,zero,8233b50 <sonewconn+0x1e4>
      goto bad;
   so->next = NULL;
 82339f0:	e0bffd17 	ldw	r2,-12(fp)
 82339f4:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 82339f8:	e17ffd17 	ldw	r5,-12(fp)
 82339fc:	010209b4 	movhi	r4,2086
 8233a00:	2137ef04 	addi	r4,r4,-8260
 8233a04:	822cbb00 	call	822cbb0 <putq>
   so->so_type = head->so_type;
 8233a08:	e0bfff17 	ldw	r2,-4(fp)
 8233a0c:	10c00983 	ldbu	r3,38(r2)
 8233a10:	e0bffd17 	ldw	r2,-12(fp)
 8233a14:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 8233a18:	e0bfff17 	ldw	r2,-4(fp)
 8233a1c:	10c00417 	ldw	r3,16(r2)
 8233a20:	00bfff44 	movi	r2,-3
 8233a24:	1886703a 	and	r3,r3,r2
 8233a28:	e0bffd17 	ldw	r2,-12(fp)
 8233a2c:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 8233a30:	e0bfff17 	ldw	r2,-4(fp)
 8233a34:	10c0080b 	ldhu	r3,32(r2)
 8233a38:	e0bffd17 	ldw	r2,-12(fp)
 8233a3c:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 8233a40:	e0bfff17 	ldw	r2,-4(fp)
 8233a44:	1080088b 	ldhu	r2,34(r2)
 8233a48:	10800054 	ori	r2,r2,1
 8233a4c:	1007883a 	mov	r3,r2
 8233a50:	e0bffd17 	ldw	r2,-12(fp)
 8233a54:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 8233a58:	e0bfff17 	ldw	r2,-4(fp)
 8233a5c:	10c00217 	ldw	r3,8(r2)
 8233a60:	e0bffd17 	ldw	r2,-12(fp)
 8233a64:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 8233a68:	e0bfff17 	ldw	r2,-4(fp)
 8233a6c:	10c0090b 	ldhu	r3,36(r2)
 8233a70:	e0bffd17 	ldw	r2,-12(fp)
 8233a74:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 8233a78:	d0e04117 	ldw	r3,-32508(gp)
 8233a7c:	e0bffd17 	ldw	r2,-12(fp)
 8233a80:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 8233a84:	d0e04017 	ldw	r3,-32512(gp)
 8233a88:	e0bffd17 	ldw	r2,-12(fp)
 8233a8c:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 8233a90:	000d883a 	mov	r6,zero
 8233a94:	e17ffd17 	ldw	r5,-12(fp)
 8233a98:	e13fff17 	ldw	r4,-4(fp)
 8233a9c:	8233b6c0 	call	8233b6c <soqinsque>
   so->so_req = PRU_ATTACH;
 8233aa0:	e0bffd17 	ldw	r2,-12(fp)
 8233aa4:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 8233aa8:	e0bfff17 	ldw	r2,-4(fp)
 8233aac:	10c00517 	ldw	r3,20(r2)
 8233ab0:	e0bffd17 	ldw	r2,-12(fp)
 8233ab4:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 8233ab8:	e0bffd17 	ldw	r2,-12(fp)
 8233abc:	10800217 	ldw	r2,8(r2)
 8233ac0:	10800317 	ldw	r2,12(r2)
 8233ac4:	000d883a 	mov	r6,zero
 8233ac8:	000b883a 	mov	r5,zero
 8233acc:	e13ffd17 	ldw	r4,-12(fp)
 8233ad0:	103ee83a 	callr	r2
 8233ad4:	10000f1e 	bne	r2,zero,8233b14 <sonewconn+0x1a8>
      goto bad2;
   if (so_evtmap)
 8233ad8:	d0a0ce03 	ldbu	r2,-31944(gp)
 8233adc:	10803fcc 	andi	r2,r2,255
 8233ae0:	10000a26 	beq	r2,zero,8233b0c <sonewconn+0x1a0>
   {
      rc = (*so_evtmap_create) (so);                       
 8233ae4:	d0a0cc17 	ldw	r2,-31952(gp)
 8233ae8:	e13ffd17 	ldw	r4,-12(fp)
 8233aec:	103ee83a 	callr	r2
 8233af0:	e0bffe15 	stw	r2,-8(fp)
      if (rc != 0) goto bad2;
 8233af4:	e0bffe17 	ldw	r2,-8(fp)
 8233af8:	1000081e 	bne	r2,zero,8233b1c <sonewconn+0x1b0>
      so->owner = head->owner;
 8233afc:	e0bfff17 	ldw	r2,-4(fp)
 8233b00:	10c02003 	ldbu	r3,128(r2)
 8233b04:	e0bffd17 	ldw	r2,-12(fp)
 8233b08:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 8233b0c:	e0bffd17 	ldw	r2,-12(fp)
 8233b10:	00001106 	br	8233b58 <sonewconn+0x1ec>
   soqinsque (head, so, 0);
   so->so_req = PRU_ATTACH;
   so->so_domain = head->so_domain;

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
      goto bad2;
 8233b14:	0001883a 	nop
 8233b18:	00000106 	br	8233b20 <sonewconn+0x1b4>
   if (so_evtmap)
   {
      rc = (*so_evtmap_create) (so);                       
      if (rc != 0) goto bad2;
 8233b1c:	0001883a 	nop
      so->owner = head->owner;
   }
   return (so);
   
bad2:
   (void) soqremque (so, 0);
 8233b20:	000b883a 	mov	r5,zero
 8233b24:	e13ffd17 	ldw	r4,-12(fp)
 8233b28:	8233c180 	call	8233c18 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8233b2c:	e17ffd17 	ldw	r5,-12(fp)
 8233b30:	010209b4 	movhi	r4,2086
 8233b34:	2137ef04 	addi	r4,r4,-8260
 8233b38:	822cc600 	call	822cc60 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 8233b3c:	e13ffd17 	ldw	r4,-12(fp)
 8233b40:	822ddd40 	call	822ddd4 <npfree>
 8233b44:	00000306 	br	8233b54 <sonewconn+0x1e8>
{
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
      goto bad;
 8233b48:	0001883a 	nop
 8233b4c:	00000106 	br	8233b54 <sonewconn+0x1e8>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
      goto bad;
 8233b50:	0001883a 	nop
bad2:
   (void) soqremque (so, 0);
   qdel(&soq, so);   /* Delete the socket entry from the queue */
   SOC_FREE(so);  /* Free the socket structure */
bad:
   return ((struct socket *)0);
 8233b54:	0005883a 	mov	r2,zero
}
 8233b58:	e037883a 	mov	sp,fp
 8233b5c:	dfc00117 	ldw	ra,4(sp)
 8233b60:	df000017 	ldw	fp,0(sp)
 8233b64:	dec00204 	addi	sp,sp,8
 8233b68:	f800283a 	ret

08233b6c <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 8233b6c:	defffc04 	addi	sp,sp,-16
 8233b70:	df000315 	stw	fp,12(sp)
 8233b74:	df000304 	addi	fp,sp,12
 8233b78:	e13ffd15 	stw	r4,-12(fp)
 8233b7c:	e17ffe15 	stw	r5,-8(fp)
 8233b80:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 8233b84:	e0bffe17 	ldw	r2,-8(fp)
 8233b88:	e0fffd17 	ldw	r3,-12(fp)
 8233b8c:	10c01b15 	stw	r3,108(r2)
   if (q == 0) 
 8233b90:	e0bfff17 	ldw	r2,-4(fp)
 8233b94:	10000e1e 	bne	r2,zero,8233bd0 <soqinsque+0x64>
   {
      head->so_q0len++;
 8233b98:	e0bffd17 	ldw	r2,-12(fp)
 8233b9c:	10801e03 	ldbu	r2,120(r2)
 8233ba0:	10800044 	addi	r2,r2,1
 8233ba4:	1007883a 	mov	r3,r2
 8233ba8:	e0bffd17 	ldw	r2,-12(fp)
 8233bac:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 8233bb0:	e0bffd17 	ldw	r2,-12(fp)
 8233bb4:	10c01c17 	ldw	r3,112(r2)
 8233bb8:	e0bffe17 	ldw	r2,-8(fp)
 8233bbc:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 8233bc0:	e0bffd17 	ldw	r2,-12(fp)
 8233bc4:	e0fffe17 	ldw	r3,-8(fp)
 8233bc8:	10c01c15 	stw	r3,112(r2)
   {
      head->so_qlen++;
      so->so_q = head->so_q;
      head->so_q = so;
   }
}
 8233bcc:	00000d06 	br	8233c04 <soqinsque+0x98>
      head->so_q0len++;
      so->so_q0 = head->so_q0;
      head->so_q0 = so;
   } else 
   {
      head->so_qlen++;
 8233bd0:	e0bffd17 	ldw	r2,-12(fp)
 8233bd4:	10801e43 	ldbu	r2,121(r2)
 8233bd8:	10800044 	addi	r2,r2,1
 8233bdc:	1007883a 	mov	r3,r2
 8233be0:	e0bffd17 	ldw	r2,-12(fp)
 8233be4:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 8233be8:	e0bffd17 	ldw	r2,-12(fp)
 8233bec:	10c01d17 	ldw	r3,116(r2)
 8233bf0:	e0bffe17 	ldw	r2,-8(fp)
 8233bf4:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 8233bf8:	e0bffd17 	ldw	r2,-12(fp)
 8233bfc:	e0fffe17 	ldw	r3,-8(fp)
 8233c00:	10c01d15 	stw	r3,116(r2)
   }
}
 8233c04:	0001883a 	nop
 8233c08:	e037883a 	mov	sp,fp
 8233c0c:	df000017 	ldw	fp,0(sp)
 8233c10:	dec00104 	addi	sp,sp,4
 8233c14:	f800283a 	ret

08233c18 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 8233c18:	defffa04 	addi	sp,sp,-24
 8233c1c:	df000515 	stw	fp,20(sp)
 8233c20:	df000504 	addi	fp,sp,20
 8233c24:	e13ffe15 	stw	r4,-8(fp)
 8233c28:	e17fff15 	stw	r5,-4(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 8233c2c:	e0bffe17 	ldw	r2,-8(fp)
 8233c30:	10801b17 	ldw	r2,108(r2)
 8233c34:	e0bffc15 	stw	r2,-16(fp)
   prev = head;
 8233c38:	e0bffc17 	ldw	r2,-16(fp)
 8233c3c:	e0bffb15 	stw	r2,-20(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 8233c40:	e0bfff17 	ldw	r2,-4(fp)
 8233c44:	10000326 	beq	r2,zero,8233c54 <soqremque+0x3c>
 8233c48:	e0bffb17 	ldw	r2,-20(fp)
 8233c4c:	10801d17 	ldw	r2,116(r2)
 8233c50:	00000206 	br	8233c5c <soqremque+0x44>
 8233c54:	e0bffb17 	ldw	r2,-20(fp)
 8233c58:	10801c17 	ldw	r2,112(r2)
 8233c5c:	e0bffd15 	stw	r2,-12(fp)
      if (next == so)
 8233c60:	e0fffd17 	ldw	r3,-12(fp)
 8233c64:	e0bffe17 	ldw	r2,-8(fp)
 8233c68:	18800826 	beq	r3,r2,8233c8c <soqremque+0x74>
         break;
      if (next == head)
 8233c6c:	e0fffd17 	ldw	r3,-12(fp)
 8233c70:	e0bffc17 	ldw	r2,-16(fp)
 8233c74:	1880021e 	bne	r3,r2,8233c80 <soqremque+0x68>
         return (0);
 8233c78:	0005883a 	mov	r2,zero
 8233c7c:	00002406 	br	8233d10 <soqremque+0xf8>
      prev = next;
 8233c80:	e0bffd17 	ldw	r2,-12(fp)
 8233c84:	e0bffb15 	stw	r2,-20(fp)
   }
 8233c88:	003fed06 	br	8233c40 <soqremque+0x28>
   prev = head;
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
      if (next == so)
         break;
 8233c8c:	0001883a 	nop
      if (next == head)
         return (0);
      prev = next;
   }
   if (q == 0) 
 8233c90:	e0bfff17 	ldw	r2,-4(fp)
 8233c94:	10000b1e 	bne	r2,zero,8233cc4 <soqremque+0xac>
   {
      prev->so_q0 = next->so_q0;
 8233c98:	e0bffd17 	ldw	r2,-12(fp)
 8233c9c:	10c01c17 	ldw	r3,112(r2)
 8233ca0:	e0bffb17 	ldw	r2,-20(fp)
 8233ca4:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 8233ca8:	e0bffc17 	ldw	r2,-16(fp)
 8233cac:	10801e03 	ldbu	r2,120(r2)
 8233cb0:	10bfffc4 	addi	r2,r2,-1
 8233cb4:	1007883a 	mov	r3,r2
 8233cb8:	e0bffc17 	ldw	r2,-16(fp)
 8233cbc:	10c01e05 	stb	r3,120(r2)
 8233cc0:	00000a06 	br	8233cec <soqremque+0xd4>
   } else 
   {
      prev->so_q = next->so_q;
 8233cc4:	e0bffd17 	ldw	r2,-12(fp)
 8233cc8:	10c01d17 	ldw	r3,116(r2)
 8233ccc:	e0bffb17 	ldw	r2,-20(fp)
 8233cd0:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 8233cd4:	e0bffc17 	ldw	r2,-16(fp)
 8233cd8:	10801e43 	ldbu	r2,121(r2)
 8233cdc:	10bfffc4 	addi	r2,r2,-1
 8233ce0:	1007883a 	mov	r3,r2
 8233ce4:	e0bffc17 	ldw	r2,-16(fp)
 8233ce8:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 8233cec:	e0bffd17 	ldw	r2,-12(fp)
 8233cf0:	10001d15 	stw	zero,116(r2)
 8233cf4:	e0bffd17 	ldw	r2,-12(fp)
 8233cf8:	10c01d17 	ldw	r3,116(r2)
 8233cfc:	e0bffd17 	ldw	r2,-12(fp)
 8233d00:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 8233d04:	e0bffd17 	ldw	r2,-12(fp)
 8233d08:	10001b15 	stw	zero,108(r2)
   return 1;
 8233d0c:	00800044 	movi	r2,1
}
 8233d10:	e037883a 	mov	sp,fp
 8233d14:	df000017 	ldw	fp,0(sp)
 8233d18:	dec00104 	addi	sp,sp,4
 8233d1c:	f800283a 	ret

08233d20 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 8233d20:	defffd04 	addi	sp,sp,-12
 8233d24:	dfc00215 	stw	ra,8(sp)
 8233d28:	df000115 	stw	fp,4(sp)
 8233d2c:	df000104 	addi	fp,sp,4
 8233d30:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 8233d34:	e0bfff17 	ldw	r2,-4(fp)
 8233d38:	1080088b 	ldhu	r2,34(r2)
 8233d3c:	10800414 	ori	r2,r2,16
 8233d40:	1007883a 	mov	r3,r2
 8233d44:	e0bfff17 	ldw	r2,-4(fp)
 8233d48:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 8233d4c:	e0bfff17 	ldw	r2,-4(fp)
 8233d50:	10801204 	addi	r2,r2,72
 8233d54:	100b883a 	mov	r5,r2
 8233d58:	e13fff17 	ldw	r4,-4(fp)
 8233d5c:	8233e780 	call	8233e78 <sbwakeup>
}
 8233d60:	0001883a 	nop
 8233d64:	e037883a 	mov	sp,fp
 8233d68:	dfc00117 	ldw	ra,4(sp)
 8233d6c:	df000017 	ldw	fp,0(sp)
 8233d70:	dec00204 	addi	sp,sp,8
 8233d74:	f800283a 	ret

08233d78 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 8233d78:	defffd04 	addi	sp,sp,-12
 8233d7c:	dfc00215 	stw	ra,8(sp)
 8233d80:	df000115 	stw	fp,4(sp)
 8233d84:	df000104 	addi	fp,sp,4
 8233d88:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 8233d8c:	e0bfff17 	ldw	r2,-4(fp)
 8233d90:	1080088b 	ldhu	r2,34(r2)
 8233d94:	10800814 	ori	r2,r2,32
 8233d98:	1007883a 	mov	r3,r2
 8233d9c:	e0bfff17 	ldw	r2,-4(fp)
 8233da0:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 8233da4:	e0bfff17 	ldw	r2,-4(fp)
 8233da8:	10800a04 	addi	r2,r2,40
 8233dac:	100b883a 	mov	r5,r2
 8233db0:	e13fff17 	ldw	r4,-4(fp)
 8233db4:	8233e780 	call	8233e78 <sbwakeup>
}
 8233db8:	0001883a 	nop
 8233dbc:	e037883a 	mov	sp,fp
 8233dc0:	dfc00117 	ldw	ra,4(sp)
 8233dc4:	df000017 	ldw	fp,0(sp)
 8233dc8:	dec00204 	addi	sp,sp,8
 8233dcc:	f800283a 	ret

08233dd0 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 8233dd0:	defffe04 	addi	sp,sp,-8
 8233dd4:	df000115 	stw	fp,4(sp)
 8233dd8:	df000104 	addi	fp,sp,4
 8233ddc:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 8233de0:	e0bfff17 	ldw	r2,-4(fp)
 8233de4:	1080070b 	ldhu	r2,28(r2)
 8233de8:	10800214 	ori	r2,r2,8
 8233dec:	1007883a 	mov	r3,r2
 8233df0:	e0bfff17 	ldw	r2,-4(fp)
 8233df4:	10c0070d 	sth	r3,28(r2)
}
 8233df8:	0001883a 	nop
 8233dfc:	e037883a 	mov	sp,fp
 8233e00:	df000017 	ldw	fp,0(sp)
 8233e04:	dec00104 	addi	sp,sp,4
 8233e08:	f800283a 	ret

08233e0c <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 8233e0c:	defffd04 	addi	sp,sp,-12
 8233e10:	dfc00215 	stw	ra,8(sp)
 8233e14:	df000115 	stw	fp,4(sp)
 8233e18:	df000104 	addi	fp,sp,4
 8233e1c:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 8233e20:	e0bfff17 	ldw	r2,-4(fp)
 8233e24:	1080070b 	ldhu	r2,28(r2)
 8233e28:	10800114 	ori	r2,r2,4
 8233e2c:	1007883a 	mov	r3,r2
 8233e30:	e0bfff17 	ldw	r2,-4(fp)
 8233e34:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 8233e38:	e0bfff17 	ldw	r2,-4(fp)
 8233e3c:	1009883a 	mov	r4,r2
 8233e40:	82291680 	call	8229168 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 8233e44:	e0bfff17 	ldw	r2,-4(fp)
 8233e48:	10c0070b 	ldhu	r3,28(r2)
 8233e4c:	00bffec4 	movi	r2,-5
 8233e50:	1884703a 	and	r2,r3,r2
 8233e54:	1007883a 	mov	r3,r2
 8233e58:	e0bfff17 	ldw	r2,-4(fp)
 8233e5c:	10c0070d 	sth	r3,28(r2)
}
 8233e60:	0001883a 	nop
 8233e64:	e037883a 	mov	sp,fp
 8233e68:	dfc00117 	ldw	ra,4(sp)
 8233e6c:	df000017 	ldw	fp,0(sp)
 8233e70:	dec00204 	addi	sp,sp,8
 8233e74:	f800283a 	ret

08233e78 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 8233e78:	defffc04 	addi	sp,sp,-16
 8233e7c:	dfc00315 	stw	ra,12(sp)
 8233e80:	df000215 	stw	fp,8(sp)
 8233e84:	df000204 	addi	fp,sp,8
 8233e88:	e13ffe15 	stw	r4,-8(fp)
 8233e8c:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 8233e90:	e0bfff17 	ldw	r2,-4(fp)
 8233e94:	1080070b 	ldhu	r2,28(r2)
 8233e98:	10bfffcc 	andi	r2,r2,65535
 8233e9c:	1080020c 	andi	r2,r2,8
 8233ea0:	10000a26 	beq	r2,zero,8233ecc <sbwakeup+0x54>
   {
      select_wait = 0;
 8233ea4:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 8233ea8:	d120b004 	addi	r4,gp,-32064
 8233eac:	82292dc0 	call	82292dc <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 8233eb0:	e0bfff17 	ldw	r2,-4(fp)
 8233eb4:	10c0070b 	ldhu	r3,28(r2)
 8233eb8:	00bffdc4 	movi	r2,-9
 8233ebc:	1884703a 	and	r2,r3,r2
 8233ec0:	1007883a 	mov	r3,r2
 8233ec4:	e0bfff17 	ldw	r2,-4(fp)
 8233ec8:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 8233ecc:	e0bfff17 	ldw	r2,-4(fp)
 8233ed0:	1080070b 	ldhu	r2,28(r2)
 8233ed4:	10bfffcc 	andi	r2,r2,65535
 8233ed8:	1080010c 	andi	r2,r2,4
 8233edc:	10000326 	beq	r2,zero,8233eec <sbwakeup+0x74>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 8233ee0:	e0bfff17 	ldw	r2,-4(fp)
 8233ee4:	1009883a 	mov	r4,r2
 8233ee8:	82292dc0 	call	82292dc <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 8233eec:	0001883a 	nop
 8233ef0:	e037883a 	mov	sp,fp
 8233ef4:	dfc00117 	ldw	ra,4(sp)
 8233ef8:	df000017 	ldw	fp,0(sp)
 8233efc:	dec00204 	addi	sp,sp,8
 8233f00:	f800283a 	ret

08233f04 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 8233f04:	defffb04 	addi	sp,sp,-20
 8233f08:	dfc00415 	stw	ra,16(sp)
 8233f0c:	df000315 	stw	fp,12(sp)
 8233f10:	df000304 	addi	fp,sp,12
 8233f14:	e13ffd15 	stw	r4,-12(fp)
 8233f18:	e17ffe15 	stw	r5,-8(fp)
 8233f1c:	e1bfff15 	stw	r6,-4(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 8233f20:	e0bffd17 	ldw	r2,-12(fp)
 8233f24:	10801204 	addi	r2,r2,72
 8233f28:	e17ffe17 	ldw	r5,-8(fp)
 8233f2c:	1009883a 	mov	r4,r2
 8233f30:	8233f8c0 	call	8233f8c <sbreserve>
 8233f34:	10000e26 	beq	r2,zero,8233f70 <soreserve+0x6c>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 8233f38:	e0bffd17 	ldw	r2,-12(fp)
 8233f3c:	10800a04 	addi	r2,r2,40
 8233f40:	e17fff17 	ldw	r5,-4(fp)
 8233f44:	1009883a 	mov	r4,r2
 8233f48:	8233f8c0 	call	8233f8c <sbreserve>
 8233f4c:	10000226 	beq	r2,zero,8233f58 <soreserve+0x54>
      goto bad2;
   return (0);
 8233f50:	0005883a 	mov	r2,zero
 8233f54:	00000806 	br	8233f78 <soreserve+0x74>
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
      goto bad2;
 8233f58:	0001883a 	nop
   return (0);
bad2:
   sbrelease(&so->so_snd);
 8233f5c:	e0bffd17 	ldw	r2,-12(fp)
 8233f60:	10801204 	addi	r2,r2,72
 8233f64:	1009883a 	mov	r4,r2
 8233f68:	8233fdc0 	call	8233fdc <sbrelease>
 8233f6c:	00000106 	br	8233f74 <soreserve+0x70>
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
 8233f70:	0001883a 	nop
      goto bad2;
   return (0);
bad2:
   sbrelease(&so->so_snd);
bad:
   return (ENOBUFS);
 8233f74:	00801a44 	movi	r2,105
}
 8233f78:	e037883a 	mov	sp,fp
 8233f7c:	dfc00117 	ldw	ra,4(sp)
 8233f80:	df000017 	ldw	fp,0(sp)
 8233f84:	dec00204 	addi	sp,sp,8
 8233f88:	f800283a 	ret

08233f8c <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 8233f8c:	defffd04 	addi	sp,sp,-12
 8233f90:	df000215 	stw	fp,8(sp)
 8233f94:	df000204 	addi	fp,sp,8
 8233f98:	e13ffe15 	stw	r4,-8(fp)
 8233f9c:	e17fff15 	stw	r5,-4(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 8233fa0:	e0bffe17 	ldw	r2,-8(fp)
 8233fa4:	e0ffff17 	ldw	r3,-4(fp)
 8233fa8:	10c00115 	stw	r3,4(r2)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 8233fac:	e0bfff17 	ldw	r2,-4(fp)
 8233fb0:	1085883a 	add	r2,r2,r2
 8233fb4:	10d00070 	cmpltui	r3,r2,16385
 8233fb8:	1800011e 	bne	r3,zero,8233fc0 <sbreserve+0x34>
 8233fbc:	00900004 	movi	r2,16384
 8233fc0:	e0fffe17 	ldw	r3,-8(fp)
 8233fc4:	18800315 	stw	r2,12(r3)
   return (1);
 8233fc8:	00800044 	movi	r2,1
}
 8233fcc:	e037883a 	mov	sp,fp
 8233fd0:	df000017 	ldw	fp,0(sp)
 8233fd4:	dec00104 	addi	sp,sp,4
 8233fd8:	f800283a 	ret

08233fdc <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 8233fdc:	defffd04 	addi	sp,sp,-12
 8233fe0:	dfc00215 	stw	ra,8(sp)
 8233fe4:	df000115 	stw	fp,4(sp)
 8233fe8:	df000104 	addi	fp,sp,4
 8233fec:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 8233ff0:	e13fff17 	ldw	r4,-4(fp)
 8233ff4:	823455c0 	call	823455c <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 8233ff8:	e0bfff17 	ldw	r2,-4(fp)
 8233ffc:	10000315 	stw	zero,12(r2)
 8234000:	e0bfff17 	ldw	r2,-4(fp)
 8234004:	10c00317 	ldw	r3,12(r2)
 8234008:	e0bfff17 	ldw	r2,-4(fp)
 823400c:	10c00115 	stw	r3,4(r2)
}
 8234010:	0001883a 	nop
 8234014:	e037883a 	mov	sp,fp
 8234018:	dfc00117 	ldw	ra,4(sp)
 823401c:	df000017 	ldw	fp,0(sp)
 8234020:	dec00204 	addi	sp,sp,8
 8234024:	f800283a 	ret

08234028 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 8234028:	defffb04 	addi	sp,sp,-20
 823402c:	dfc00415 	stw	ra,16(sp)
 8234030:	df000315 	stw	fp,12(sp)
 8234034:	df000304 	addi	fp,sp,12
 8234038:	e13ffe15 	stw	r4,-8(fp)
 823403c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 8234040:	e0bfff17 	ldw	r2,-4(fp)
 8234044:	10001a26 	beq	r2,zero,82340b0 <sbappend+0x88>
      return;
   ENTER_CRIT_SECTION(sb);
 8234048:	822d3a00 	call	822d3a0 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 823404c:	e0bffe17 	ldw	r2,-8(fp)
 8234050:	10800617 	ldw	r2,24(r2)
 8234054:	e0bffd15 	stw	r2,-12(fp)
 8234058:	e0bffd17 	ldw	r2,-12(fp)
 823405c:	10000e26 	beq	r2,zero,8234098 <sbappend+0x70>
   {
      while (n->m_act)
 8234060:	00000306 	br	8234070 <sbappend+0x48>
         n = n->m_act;
 8234064:	e0bffd17 	ldw	r2,-12(fp)
 8234068:	10800717 	ldw	r2,28(r2)
 823406c:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234070:	e0bffd17 	ldw	r2,-12(fp)
 8234074:	10800717 	ldw	r2,28(r2)
 8234078:	103ffa1e 	bne	r2,zero,8234064 <sbappend+0x3c>
         n = n->m_act;
      while (n->m_next)
 823407c:	00000306 	br	823408c <sbappend+0x64>
         n = n->m_next;
 8234080:	e0bffd17 	ldw	r2,-12(fp)
 8234084:	10800617 	ldw	r2,24(r2)
 8234088:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 823408c:	e0bffd17 	ldw	r2,-12(fp)
 8234090:	10800617 	ldw	r2,24(r2)
 8234094:	103ffa1e 	bne	r2,zero,8234080 <sbappend+0x58>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 8234098:	e1bffd17 	ldw	r6,-12(fp)
 823409c:	e17fff17 	ldw	r5,-4(fp)
 82340a0:	e13ffe17 	ldw	r4,-8(fp)
 82340a4:	823437c0 	call	823437c <sbcompress>
   EXIT_CRIT_SECTION(sb);
 82340a8:	822d4000 	call	822d400 <irq_Unmask>
 82340ac:	00000106 	br	82340b4 <sbappend+0x8c>
sbappend(struct sockbuf * sb, struct mbuf * m)
{
   struct mbuf *  n;

   if (m == 0)
      return;
 82340b0:	0001883a 	nop
      while (n->m_next)
         n = n->m_next;
   }
   sbcompress(sb, m, n);
   EXIT_CRIT_SECTION(sb);
}
 82340b4:	e037883a 	mov	sp,fp
 82340b8:	dfc00117 	ldw	ra,4(sp)
 82340bc:	df000017 	ldw	fp,0(sp)
 82340c0:	dec00204 	addi	sp,sp,8
 82340c4:	f800283a 	ret

082340c8 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 82340c8:	defffb04 	addi	sp,sp,-20
 82340cc:	dfc00415 	stw	ra,16(sp)
 82340d0:	df000315 	stw	fp,12(sp)
 82340d4:	df000304 	addi	fp,sp,12
 82340d8:	e13ffe15 	stw	r4,-8(fp)
 82340dc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 82340e0:	e0bfff17 	ldw	r2,-4(fp)
 82340e4:	10002826 	beq	r2,zero,8234188 <sbappendrecord+0xc0>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 82340e8:	822d3a00 	call	822d3a0 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 82340ec:	e0bffe17 	ldw	r2,-8(fp)
 82340f0:	10800617 	ldw	r2,24(r2)
 82340f4:	e0bffd15 	stw	r2,-12(fp)
 82340f8:	e0bffd17 	ldw	r2,-12(fp)
 82340fc:	10000726 	beq	r2,zero,823411c <sbappendrecord+0x54>
      while (m->m_act)
 8234100:	00000306 	br	8234110 <sbappendrecord+0x48>
      m = m->m_act;
 8234104:	e0bffd17 	ldw	r2,-12(fp)
 8234108:	10800717 	ldw	r2,28(r2)
 823410c:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 8234110:	e0bffd17 	ldw	r2,-12(fp)
 8234114:	10800717 	ldw	r2,28(r2)
 8234118:	103ffa1e 	bne	r2,zero,8234104 <sbappendrecord+0x3c>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 823411c:	e0bffe17 	ldw	r2,-8(fp)
 8234120:	10c00017 	ldw	r3,0(r2)
 8234124:	e0bfff17 	ldw	r2,-4(fp)
 8234128:	10800217 	ldw	r2,8(r2)
 823412c:	1887883a 	add	r3,r3,r2
 8234130:	e0bffe17 	ldw	r2,-8(fp)
 8234134:	10c00015 	stw	r3,0(r2)
   if (m)
 8234138:	e0bffd17 	ldw	r2,-12(fp)
 823413c:	10000426 	beq	r2,zero,8234150 <sbappendrecord+0x88>
      m->m_act = m0;
 8234140:	e0bffd17 	ldw	r2,-12(fp)
 8234144:	e0ffff17 	ldw	r3,-4(fp)
 8234148:	10c00715 	stw	r3,28(r2)
 823414c:	00000306 	br	823415c <sbappendrecord+0x94>
   else
      sb->sb_mb = m0;
 8234150:	e0bffe17 	ldw	r2,-8(fp)
 8234154:	e0ffff17 	ldw	r3,-4(fp)
 8234158:	10c00615 	stw	r3,24(r2)
   m = m0->m_next;
 823415c:	e0bfff17 	ldw	r2,-4(fp)
 8234160:	10800617 	ldw	r2,24(r2)
 8234164:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 8234168:	e0bfff17 	ldw	r2,-4(fp)
 823416c:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 8234170:	e1bfff17 	ldw	r6,-4(fp)
 8234174:	e17ffd17 	ldw	r5,-12(fp)
 8234178:	e13ffe17 	ldw	r4,-8(fp)
 823417c:	823437c0 	call	823437c <sbcompress>
   EXIT_CRIT_SECTION(sb);
 8234180:	822d4000 	call	822d400 <irq_Unmask>
 8234184:	00000106 	br	823418c <sbappendrecord+0xc4>
   struct mbuf *  m0)
{
   struct mbuf *  m;

   if (m0 == 0)
      return;
 8234188:	0001883a 	nop
      sb->sb_mb = m0;
   m = m0->m_next;
   m0->m_next = 0;
   sbcompress(sb, m, m0);
   EXIT_CRIT_SECTION(sb);
}
 823418c:	e037883a 	mov	sp,fp
 8234190:	dfc00117 	ldw	ra,4(sp)
 8234194:	df000017 	ldw	fp,0(sp)
 8234198:	dec00204 	addi	sp,sp,8
 823419c:	f800283a 	ret

082341a0 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 82341a0:	defff804 	addi	sp,sp,-32
 82341a4:	dfc00715 	stw	ra,28(sp)
 82341a8:	df000615 	stw	fp,24(sp)
 82341ac:	df000604 	addi	fp,sp,24
 82341b0:	e13ffd15 	stw	r4,-12(fp)
 82341b4:	e17ffe15 	stw	r5,-8(fp)
 82341b8:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 82341bc:	00800404 	movi	r2,16
 82341c0:	e0bffc15 	stw	r2,-16(fp)

   ENTER_CRIT_SECTION(sb);
 82341c4:	822d3a00 	call	822d3a0 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 82341c8:	e0bfff17 	ldw	r2,-4(fp)
 82341cc:	e0bffa15 	stw	r2,-24(fp)
 82341d0:	00000806 	br	82341f4 <sbappendaddr+0x54>
      space += m->m_len;
 82341d4:	e0bffa17 	ldw	r2,-24(fp)
 82341d8:	10c00217 	ldw	r3,8(r2)
 82341dc:	e0bffc17 	ldw	r2,-16(fp)
 82341e0:	1885883a 	add	r2,r3,r2
 82341e4:	e0bffc15 	stw	r2,-16(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 82341e8:	e0bffa17 	ldw	r2,-24(fp)
 82341ec:	10800617 	ldw	r2,24(r2)
 82341f0:	e0bffa15 	stw	r2,-24(fp)
 82341f4:	e0bffa17 	ldw	r2,-24(fp)
 82341f8:	103ff61e 	bne	r2,zero,82341d4 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 82341fc:	e0bffd17 	ldw	r2,-12(fp)
 8234200:	10800117 	ldw	r2,4(r2)
 8234204:	1007883a 	mov	r3,r2
 8234208:	e0bffd17 	ldw	r2,-12(fp)
 823420c:	10800017 	ldw	r2,0(r2)
 8234210:	1885c83a 	sub	r2,r3,r2
 8234214:	10000716 	blt	r2,zero,8234234 <sbappendaddr+0x94>
 8234218:	e0bffd17 	ldw	r2,-12(fp)
 823421c:	10c00117 	ldw	r3,4(r2)
 8234220:	e0bffd17 	ldw	r2,-12(fp)
 8234224:	10800017 	ldw	r2,0(r2)
 8234228:	1885c83a 	sub	r2,r3,r2
 823422c:	1007883a 	mov	r3,r2
 8234230:	00000106 	br	8234238 <sbappendaddr+0x98>
 8234234:	0007883a 	mov	r3,zero
 8234238:	e0bffc17 	ldw	r2,-16(fp)
 823423c:	1880030e 	bge	r3,r2,823424c <sbappendaddr+0xac>
   {
      EXIT_CRIT_SECTION(sb);
 8234240:	822d4000 	call	822d400 <irq_Unmask>
      return (0);
 8234244:	0005883a 	mov	r2,zero
 8234248:	00004706 	br	8234368 <sbappendaddr+0x1c8>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 823424c:	01400404 	movi	r5,16
 8234250:	01000244 	movi	r4,9
 8234254:	822dfdc0 	call	822dfdc <m_getnbuf>
 8234258:	e0bffa15 	stw	r2,-24(fp)
 823425c:	e0bffa17 	ldw	r2,-24(fp)
 8234260:	1000031e 	bne	r2,zero,8234270 <sbappendaddr+0xd0>
   {
      EXIT_CRIT_SECTION(sb);
 8234264:	822d4000 	call	822d400 <irq_Unmask>
      return 0;
 8234268:	0005883a 	mov	r2,zero
 823426c:	00003e06 	br	8234368 <sbappendaddr+0x1c8>
   }
   *mtod(m, struct sockaddr *) = *asa;
 8234270:	e0bffa17 	ldw	r2,-24(fp)
 8234274:	10800317 	ldw	r2,12(r2)
 8234278:	e0fffe17 	ldw	r3,-8(fp)
 823427c:	1900000b 	ldhu	r4,0(r3)
 8234280:	1100000d 	sth	r4,0(r2)
 8234284:	1900008b 	ldhu	r4,2(r3)
 8234288:	1100008d 	sth	r4,2(r2)
 823428c:	1900010b 	ldhu	r4,4(r3)
 8234290:	1100010d 	sth	r4,4(r2)
 8234294:	1900018b 	ldhu	r4,6(r3)
 8234298:	1100018d 	sth	r4,6(r2)
 823429c:	1900020b 	ldhu	r4,8(r3)
 82342a0:	1100020d 	sth	r4,8(r2)
 82342a4:	1900028b 	ldhu	r4,10(r3)
 82342a8:	1100028d 	sth	r4,10(r2)
 82342ac:	1900030b 	ldhu	r4,12(r3)
 82342b0:	1100030d 	sth	r4,12(r2)
 82342b4:	18c0038b 	ldhu	r3,14(r3)
 82342b8:	10c0038d 	sth	r3,14(r2)
   m->m_len = sizeof (*asa);
 82342bc:	e0bffa17 	ldw	r2,-24(fp)
 82342c0:	00c00404 	movi	r3,16
 82342c4:	10c00215 	stw	r3,8(r2)
   sballoc (sb, m);
 82342c8:	e0bffd17 	ldw	r2,-12(fp)
 82342cc:	10c00017 	ldw	r3,0(r2)
 82342d0:	e0bffa17 	ldw	r2,-24(fp)
 82342d4:	10800217 	ldw	r2,8(r2)
 82342d8:	1887883a 	add	r3,r3,r2
 82342dc:	e0bffd17 	ldw	r2,-12(fp)
 82342e0:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 82342e4:	e0bffd17 	ldw	r2,-12(fp)
 82342e8:	10800617 	ldw	r2,24(r2)
 82342ec:	e0bffb15 	stw	r2,-20(fp)
 82342f0:	e0bffb17 	ldw	r2,-20(fp)
 82342f4:	10000b26 	beq	r2,zero,8234324 <sbappendaddr+0x184>
   {
      while (n->m_act)
 82342f8:	00000306 	br	8234308 <sbappendaddr+0x168>
         n = n->m_act;
 82342fc:	e0bffb17 	ldw	r2,-20(fp)
 8234300:	10800717 	ldw	r2,28(r2)
 8234304:	e0bffb15 	stw	r2,-20(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234308:	e0bffb17 	ldw	r2,-20(fp)
 823430c:	10800717 	ldw	r2,28(r2)
 8234310:	103ffa1e 	bne	r2,zero,82342fc <sbappendaddr+0x15c>
         n = n->m_act;
      n->m_act = m;
 8234314:	e0bffb17 	ldw	r2,-20(fp)
 8234318:	e0fffa17 	ldw	r3,-24(fp)
 823431c:	10c00715 	stw	r3,28(r2)
 8234320:	00000306 	br	8234330 <sbappendaddr+0x190>
   } else
      sb->sb_mb = m;
 8234324:	e0bffd17 	ldw	r2,-12(fp)
 8234328:	e0fffa17 	ldw	r3,-24(fp)
 823432c:	10c00615 	stw	r3,24(r2)
   if (m->m_next)
 8234330:	e0bffa17 	ldw	r2,-24(fp)
 8234334:	10800617 	ldw	r2,24(r2)
 8234338:	10000326 	beq	r2,zero,8234348 <sbappendaddr+0x1a8>
      m = m->m_next;
 823433c:	e0bffa17 	ldw	r2,-24(fp)
 8234340:	10800617 	ldw	r2,24(r2)
 8234344:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 8234348:	e0bfff17 	ldw	r2,-4(fp)
 823434c:	10000426 	beq	r2,zero,8234360 <sbappendaddr+0x1c0>
      sbcompress(sb, m0, m);
 8234350:	e1bffa17 	ldw	r6,-24(fp)
 8234354:	e17fff17 	ldw	r5,-4(fp)
 8234358:	e13ffd17 	ldw	r4,-12(fp)
 823435c:	823437c0 	call	823437c <sbcompress>

   EXIT_CRIT_SECTION(sb);
 8234360:	822d4000 	call	822d400 <irq_Unmask>
   return (1);
 8234364:	00800044 	movi	r2,1
}
 8234368:	e037883a 	mov	sp,fp
 823436c:	dfc00117 	ldw	ra,4(sp)
 8234370:	df000017 	ldw	fp,0(sp)
 8234374:	dec00204 	addi	sp,sp,8
 8234378:	f800283a 	ret

0823437c <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 823437c:	defffb04 	addi	sp,sp,-20
 8234380:	dfc00415 	stw	ra,16(sp)
 8234384:	df000315 	stw	fp,12(sp)
 8234388:	df000304 	addi	fp,sp,12
 823438c:	e13ffd15 	stw	r4,-12(fp)
 8234390:	e17ffe15 	stw	r5,-8(fp)
 8234394:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 8234398:	00006806 	br	823453c <sbcompress+0x1c0>
   {
      if (m->m_len == 0) 
 823439c:	e0bffe17 	ldw	r2,-8(fp)
 82343a0:	10800217 	ldw	r2,8(r2)
 82343a4:	1000041e 	bne	r2,zero,82343b8 <sbcompress+0x3c>
      {
         m = m_free(m);
 82343a8:	e13ffe17 	ldw	r4,-8(fp)
 82343ac:	822e1640 	call	822e164 <m_free>
 82343b0:	e0bffe15 	stw	r2,-8(fp)
         continue;
 82343b4:	00006106 	br	823453c <sbcompress+0x1c0>
      }
      if (m->m_type != MT_RXDATA && 
 82343b8:	e0bffe17 	ldw	r2,-8(fp)
 82343bc:	10800817 	ldw	r2,32(r2)
 82343c0:	10800060 	cmpeqi	r2,r2,1
 82343c4:	1000111e 	bne	r2,zero,823440c <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
 82343c8:	e0bffe17 	ldw	r2,-8(fp)
 82343cc:	10800817 	ldw	r2,32(r2)
      if (m->m_len == 0) 
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
 82343d0:	108000a0 	cmpeqi	r2,r2,2
 82343d4:	10000d1e 	bne	r2,zero,823440c <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
 82343d8:	e0bffe17 	ldw	r2,-8(fp)
 82343dc:	10800817 	ldw	r2,32(r2)
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
          m->m_type != MT_TXDATA && 
 82343e0:	10800260 	cmpeqi	r2,r2,9
 82343e4:	1000091e 	bne	r2,zero,823440c <sbcompress+0x90>
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 82343e8:	e0bffe17 	ldw	r2,-8(fp)
 82343ec:	10800817 	ldw	r2,32(r2)
 82343f0:	100b883a 	mov	r5,r2
 82343f4:	01020974 	movhi	r4,2085
 82343f8:	21022504 	addi	r4,r4,2196
 82343fc:	8202e9c0 	call	8202e9c <printf>
         panic ("sbcomp:bad");
 8234400:	01020974 	movhi	r4,2085
 8234404:	21022a04 	addi	r4,r4,2216
 8234408:	822887c0 	call	822887c <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 823440c:	e0bfff17 	ldw	r2,-4(fp)
 8234410:	10003326 	beq	r2,zero,82344e0 <sbcompress+0x164>
 8234414:	e0bffd17 	ldw	r2,-12(fp)
 8234418:	1080070b 	ldhu	r2,28(r2)
 823441c:	10bfffcc 	andi	r2,r2,65535
 8234420:	1080200c 	andi	r2,r2,128
 8234424:	10002e26 	beq	r2,zero,82344e0 <sbcompress+0x164>
          ((n->m_len + m->m_len) <
 8234428:	e0bfff17 	ldw	r2,-4(fp)
 823442c:	10c00217 	ldw	r3,8(r2)
 8234430:	e0bffe17 	ldw	r2,-8(fp)
 8234434:	10800217 	ldw	r2,8(r2)
 8234438:	1887883a 	add	r3,r3,r2
          n->m_memsz - (n->m_data - n->m_base) ) ) 
 823443c:	e0bfff17 	ldw	r2,-4(fp)
 8234440:	10800517 	ldw	r2,20(r2)
 8234444:	e13fff17 	ldw	r4,-4(fp)
 8234448:	21000317 	ldw	r4,12(r4)
 823444c:	200b883a 	mov	r5,r4
 8234450:	e13fff17 	ldw	r4,-4(fp)
 8234454:	21000417 	ldw	r4,16(r4)
 8234458:	2909c83a 	sub	r4,r5,r4
 823445c:	1105c83a 	sub	r2,r2,r4
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 8234460:	18801f2e 	bgeu	r3,r2,82344e0 <sbcompress+0x164>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 8234464:	e0bfff17 	ldw	r2,-4(fp)
 8234468:	10c00317 	ldw	r3,12(r2)
 823446c:	e0bfff17 	ldw	r2,-4(fp)
 8234470:	10800217 	ldw	r2,8(r2)
 8234474:	1887883a 	add	r3,r3,r2
 8234478:	e0bffe17 	ldw	r2,-8(fp)
 823447c:	11000317 	ldw	r4,12(r2)
 8234480:	e0bffe17 	ldw	r2,-8(fp)
 8234484:	10800217 	ldw	r2,8(r2)
 8234488:	100d883a 	mov	r6,r2
 823448c:	200b883a 	mov	r5,r4
 8234490:	1809883a 	mov	r4,r3
 8234494:	8202a0c0 	call	8202a0c <memcpy>
         sballoc(sb, m);
 8234498:	e0bffd17 	ldw	r2,-12(fp)
 823449c:	10c00017 	ldw	r3,0(r2)
 82344a0:	e0bffe17 	ldw	r2,-8(fp)
 82344a4:	10800217 	ldw	r2,8(r2)
 82344a8:	1887883a 	add	r3,r3,r2
 82344ac:	e0bffd17 	ldw	r2,-12(fp)
 82344b0:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 82344b4:	e0bfff17 	ldw	r2,-4(fp)
 82344b8:	10c00217 	ldw	r3,8(r2)
 82344bc:	e0bffe17 	ldw	r2,-8(fp)
 82344c0:	10800217 	ldw	r2,8(r2)
 82344c4:	1887883a 	add	r3,r3,r2
 82344c8:	e0bfff17 	ldw	r2,-4(fp)
 82344cc:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 82344d0:	e13ffe17 	ldw	r4,-8(fp)
 82344d4:	822e1640 	call	822e164 <m_free>
 82344d8:	e0bffe15 	stw	r2,-8(fp)
         continue;
 82344dc:	00001706 	br	823453c <sbcompress+0x1c0>
      }
      sballoc(sb, m);
 82344e0:	e0bffd17 	ldw	r2,-12(fp)
 82344e4:	10c00017 	ldw	r3,0(r2)
 82344e8:	e0bffe17 	ldw	r2,-8(fp)
 82344ec:	10800217 	ldw	r2,8(r2)
 82344f0:	1887883a 	add	r3,r3,r2
 82344f4:	e0bffd17 	ldw	r2,-12(fp)
 82344f8:	10c00015 	stw	r3,0(r2)
      if (n)
 82344fc:	e0bfff17 	ldw	r2,-4(fp)
 8234500:	10000426 	beq	r2,zero,8234514 <sbcompress+0x198>
         n->m_next = m;
 8234504:	e0bfff17 	ldw	r2,-4(fp)
 8234508:	e0fffe17 	ldw	r3,-8(fp)
 823450c:	10c00615 	stw	r3,24(r2)
 8234510:	00000306 	br	8234520 <sbcompress+0x1a4>
      else
         sb->sb_mb = m;
 8234514:	e0bffd17 	ldw	r2,-12(fp)
 8234518:	e0fffe17 	ldw	r3,-8(fp)
 823451c:	10c00615 	stw	r3,24(r2)
      n = m;
 8234520:	e0bffe17 	ldw	r2,-8(fp)
 8234524:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 8234528:	e0bffe17 	ldw	r2,-8(fp)
 823452c:	10800617 	ldw	r2,24(r2)
 8234530:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 8234534:	e0bfff17 	ldw	r2,-4(fp)
 8234538:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 823453c:	e0bffe17 	ldw	r2,-8(fp)
 8234540:	103f961e 	bne	r2,zero,823439c <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 8234544:	0001883a 	nop
 8234548:	e037883a 	mov	sp,fp
 823454c:	dfc00117 	ldw	ra,4(sp)
 8234550:	df000017 	ldw	fp,0(sp)
 8234554:	dec00204 	addi	sp,sp,8
 8234558:	f800283a 	ret

0823455c <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 823455c:	defffd04 	addi	sp,sp,-12
 8234560:	dfc00215 	stw	ra,8(sp)
 8234564:	df000115 	stw	fp,4(sp)
 8234568:	df000104 	addi	fp,sp,4
 823456c:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 8234570:	822d3a00 	call	822d3a0 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 8234574:	e0bfff17 	ldw	r2,-4(fp)
 8234578:	1080070b 	ldhu	r2,28(r2)
 823457c:	10bfffcc 	andi	r2,r2,65535
 8234580:	1080004c 	andi	r2,r2,1
 8234584:	10000926 	beq	r2,zero,82345ac <sbflush+0x50>
      panic("sbflush");
 8234588:	01020974 	movhi	r4,2085
 823458c:	21022d04 	addi	r4,r4,2228
 8234590:	822887c0 	call	822887c <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 8234594:	00000506 	br	82345ac <sbflush+0x50>
      sbdrop (sb, (int)sb->sb_cc);
 8234598:	e0bfff17 	ldw	r2,-4(fp)
 823459c:	10800017 	ldw	r2,0(r2)
 82345a0:	100b883a 	mov	r5,r2
 82345a4:	e13fff17 	ldw	r4,-4(fp)
 82345a8:	82345e00 	call	82345e0 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82345ac:	e0bfff17 	ldw	r2,-4(fp)
 82345b0:	10800217 	ldw	r2,8(r2)
 82345b4:	103ff81e 	bne	r2,zero,8234598 <sbflush+0x3c>
 82345b8:	e0bfff17 	ldw	r2,-4(fp)
 82345bc:	10800017 	ldw	r2,0(r2)
 82345c0:	103ff51e 	bne	r2,zero,8234598 <sbflush+0x3c>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 82345c4:	822d4000 	call	822d400 <irq_Unmask>
}
 82345c8:	0001883a 	nop
 82345cc:	e037883a 	mov	sp,fp
 82345d0:	dfc00117 	ldw	ra,4(sp)
 82345d4:	df000017 	ldw	fp,0(sp)
 82345d8:	dec00204 	addi	sp,sp,8
 82345dc:	f800283a 	ret

082345e0 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 82345e0:	defff904 	addi	sp,sp,-28
 82345e4:	dfc00615 	stw	ra,24(sp)
 82345e8:	df000515 	stw	fp,20(sp)
 82345ec:	df000504 	addi	fp,sp,20
 82345f0:	e13ffe15 	stw	r4,-8(fp)
 82345f4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 82345f8:	822d3a00 	call	822d3a0 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 82345fc:	e0bffe17 	ldw	r2,-8(fp)
 8234600:	10800617 	ldw	r2,24(r2)
 8234604:	e0bffb15 	stw	r2,-20(fp)
 8234608:	e0bffb17 	ldw	r2,-20(fp)
 823460c:	10000426 	beq	r2,zero,8234620 <sbdrop+0x40>
      next = m->m_act;
 8234610:	e0bffb17 	ldw	r2,-20(fp)
 8234614:	10800717 	ldw	r2,28(r2)
 8234618:	e0bffc15 	stw	r2,-16(fp)
 823461c:	00003706 	br	82346fc <sbdrop+0x11c>
   else
      next = NULL;
 8234620:	e03ffc15 	stw	zero,-16(fp)
   while (len > 0) 
 8234624:	00003506 	br	82346fc <sbdrop+0x11c>
   {
      if (m == 0) 
 8234628:	e0bffb17 	ldw	r2,-20(fp)
 823462c:	10000b1e 	bne	r2,zero,823465c <sbdrop+0x7c>
      {
         if (next == 0)
 8234630:	e0bffc17 	ldw	r2,-16(fp)
 8234634:	1000031e 	bne	r2,zero,8234644 <sbdrop+0x64>
            panic("sbdrop");
 8234638:	01020974 	movhi	r4,2085
 823463c:	21022f04 	addi	r4,r4,2236
 8234640:	822887c0 	call	822887c <panic>
         m = next;
 8234644:	e0bffc17 	ldw	r2,-16(fp)
 8234648:	e0bffb15 	stw	r2,-20(fp)
         next = m->m_act;
 823464c:	e0bffb17 	ldw	r2,-20(fp)
 8234650:	10800717 	ldw	r2,28(r2)
 8234654:	e0bffc15 	stw	r2,-16(fp)
         continue;
 8234658:	00002806 	br	82346fc <sbdrop+0x11c>
      }
      if (m->m_len > (unsigned)len) 
 823465c:	e0bffb17 	ldw	r2,-20(fp)
 8234660:	10800217 	ldw	r2,8(r2)
 8234664:	e0ffff17 	ldw	r3,-4(fp)
 8234668:	1880132e 	bgeu	r3,r2,82346b8 <sbdrop+0xd8>
      {
         m->m_len -= len;
 823466c:	e0bffb17 	ldw	r2,-20(fp)
 8234670:	10c00217 	ldw	r3,8(r2)
 8234674:	e0bfff17 	ldw	r2,-4(fp)
 8234678:	1887c83a 	sub	r3,r3,r2
 823467c:	e0bffb17 	ldw	r2,-20(fp)
 8234680:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 8234684:	e0bffb17 	ldw	r2,-20(fp)
 8234688:	10c00317 	ldw	r3,12(r2)
 823468c:	e0bfff17 	ldw	r2,-4(fp)
 8234690:	1887883a 	add	r3,r3,r2
 8234694:	e0bffb17 	ldw	r2,-20(fp)
 8234698:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 823469c:	e0bffe17 	ldw	r2,-8(fp)
 82346a0:	10c00017 	ldw	r3,0(r2)
 82346a4:	e0bfff17 	ldw	r2,-4(fp)
 82346a8:	1887c83a 	sub	r3,r3,r2
 82346ac:	e0bffe17 	ldw	r2,-8(fp)
 82346b0:	10c00015 	stw	r3,0(r2)
         break;
 82346b4:	00001306 	br	8234704 <sbdrop+0x124>
      }
      len -= m->m_len;
 82346b8:	e0ffff17 	ldw	r3,-4(fp)
 82346bc:	e0bffb17 	ldw	r2,-20(fp)
 82346c0:	10800217 	ldw	r2,8(r2)
 82346c4:	1885c83a 	sub	r2,r3,r2
 82346c8:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 82346cc:	e0bffe17 	ldw	r2,-8(fp)
 82346d0:	10c00017 	ldw	r3,0(r2)
 82346d4:	e0bffb17 	ldw	r2,-20(fp)
 82346d8:	10800217 	ldw	r2,8(r2)
 82346dc:	1887c83a 	sub	r3,r3,r2
 82346e0:	e0bffe17 	ldw	r2,-8(fp)
 82346e4:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 82346e8:	e13ffb17 	ldw	r4,-20(fp)
 82346ec:	822e1640 	call	822e164 <m_free>
 82346f0:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 82346f4:	e0bffd17 	ldw	r2,-12(fp)
 82346f8:	e0bffb15 	stw	r2,-20(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 82346fc:	e0bfff17 	ldw	r2,-4(fp)
 8234700:	00bfc916 	blt	zero,r2,8234628 <sbdrop+0x48>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234704:	00000c06 	br	8234738 <sbdrop+0x158>
   {
      sbfree(sb, m);
 8234708:	e0bffe17 	ldw	r2,-8(fp)
 823470c:	10c00017 	ldw	r3,0(r2)
 8234710:	e0bffb17 	ldw	r2,-20(fp)
 8234714:	10800217 	ldw	r2,8(r2)
 8234718:	1887c83a 	sub	r3,r3,r2
 823471c:	e0bffe17 	ldw	r2,-8(fp)
 8234720:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234724:	e13ffb17 	ldw	r4,-20(fp)
 8234728:	822e1640 	call	822e164 <m_free>
 823472c:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234730:	e0bffd17 	ldw	r2,-12(fp)
 8234734:	e0bffb15 	stw	r2,-20(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234738:	e0bffb17 	ldw	r2,-20(fp)
 823473c:	10000326 	beq	r2,zero,823474c <sbdrop+0x16c>
 8234740:	e0bffb17 	ldw	r2,-20(fp)
 8234744:	10800217 	ldw	r2,8(r2)
 8234748:	103fef26 	beq	r2,zero,8234708 <sbdrop+0x128>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 823474c:	e0bffb17 	ldw	r2,-20(fp)
 8234750:	10000726 	beq	r2,zero,8234770 <sbdrop+0x190>
   {
      sb->sb_mb = m;
 8234754:	e0bffe17 	ldw	r2,-8(fp)
 8234758:	e0fffb17 	ldw	r3,-20(fp)
 823475c:	10c00615 	stw	r3,24(r2)
      m->m_act = next;
 8234760:	e0bffb17 	ldw	r2,-20(fp)
 8234764:	e0fffc17 	ldw	r3,-16(fp)
 8234768:	10c00715 	stw	r3,28(r2)
 823476c:	00000306 	br	823477c <sbdrop+0x19c>
   } else
      sb->sb_mb = next;
 8234770:	e0bffe17 	ldw	r2,-8(fp)
 8234774:	e0fffc17 	ldw	r3,-16(fp)
 8234778:	10c00615 	stw	r3,24(r2)
   EXIT_CRIT_SECTION(sb);
 823477c:	822d4000 	call	822d400 <irq_Unmask>
}
 8234780:	0001883a 	nop
 8234784:	e037883a 	mov	sp,fp
 8234788:	dfc00117 	ldw	ra,4(sp)
 823478c:	df000017 	ldw	fp,0(sp)
 8234790:	dec00204 	addi	sp,sp,8
 8234794:	f800283a 	ret

08234798 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 8234798:	defff904 	addi	sp,sp,-28
 823479c:	dfc00615 	stw	ra,24(sp)
 82347a0:	df000515 	stw	fp,20(sp)
 82347a4:	df000504 	addi	fp,sp,20
 82347a8:	e13ffe15 	stw	r4,-8(fp)
 82347ac:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 82347b0:	822d3a00 	call	822d3a0 <irq_Mask>
   len = mbuf_len(m);
 82347b4:	e13fff17 	ldw	r4,-4(fp)
 82347b8:	822e7640 	call	822e764 <mbuf_len>
 82347bc:	e0bffd15 	stw	r2,-12(fp)
   if (len > 0)
 82347c0:	e0bffd17 	ldw	r2,-12(fp)
 82347c4:	0080070e 	bge	zero,r2,82347e4 <sbdropend+0x4c>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 82347c8:	e0bffe17 	ldw	r2,-8(fp)
 82347cc:	10c00617 	ldw	r3,24(r2)
 82347d0:	e0bffd17 	ldw	r2,-12(fp)
 82347d4:	0085c83a 	sub	r2,zero,r2
 82347d8:	100b883a 	mov	r5,r2
 82347dc:	1809883a 	mov	r4,r3
 82347e0:	822e5a40 	call	822e5a4 <m_adj>
   nmb = sb->sb_mb;
 82347e4:	e0bffe17 	ldw	r2,-8(fp)
 82347e8:	10800617 	ldw	r2,24(r2)
 82347ec:	e0bffb15 	stw	r2,-20(fp)
   pmb = NULL;
 82347f0:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 82347f4:	e0bffe17 	ldw	r2,-8(fp)
 82347f8:	10800617 	ldw	r2,24(r2)
 82347fc:	10800217 	ldw	r2,8(r2)
 8234800:	1000081e 	bne	r2,zero,8234824 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 8234804:	e0bffe17 	ldw	r2,-8(fp)
 8234808:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 823480c:	00000506 	br	8234824 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 8234810:	e0bffb17 	ldw	r2,-20(fp)
 8234814:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 8234818:	e0bffb17 	ldw	r2,-20(fp)
 823481c:	10800617 	ldw	r2,24(r2)
 8234820:	e0bffb15 	stw	r2,-20(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234824:	e0bffb17 	ldw	r2,-20(fp)
 8234828:	10000326 	beq	r2,zero,8234838 <sbdropend+0xa0>
 823482c:	e0bffb17 	ldw	r2,-20(fp)
 8234830:	10800217 	ldw	r2,8(r2)
 8234834:	103ff61e 	bne	r2,zero,8234810 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 8234838:	e0bffb17 	ldw	r2,-20(fp)
 823483c:	10000926 	beq	r2,zero,8234864 <sbdropend+0xcc>
 8234840:	e0bffb17 	ldw	r2,-20(fp)
 8234844:	10800217 	ldw	r2,8(r2)
 8234848:	1000061e 	bne	r2,zero,8234864 <sbdropend+0xcc>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 823484c:	e0bffc17 	ldw	r2,-16(fp)
 8234850:	10000226 	beq	r2,zero,823485c <sbdropend+0xc4>
         pmb->m_next = NULL;
 8234854:	e0bffc17 	ldw	r2,-16(fp)
 8234858:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 823485c:	e13ffb17 	ldw	r4,-20(fp)
 8234860:	822e26c0 	call	822e26c <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 8234864:	e0bffe17 	ldw	r2,-8(fp)
 8234868:	10c00017 	ldw	r3,0(r2)
 823486c:	e0bffd17 	ldw	r2,-12(fp)
 8234870:	1887c83a 	sub	r3,r3,r2
 8234874:	e0bffe17 	ldw	r2,-8(fp)
 8234878:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 823487c:	822d4000 	call	822d400 <irq_Unmask>
}
 8234880:	0001883a 	nop
 8234884:	e037883a 	mov	sp,fp
 8234888:	dfc00117 	ldw	ra,4(sp)
 823488c:	df000017 	ldw	fp,0(sp)
 8234890:	dec00204 	addi	sp,sp,8
 8234894:	f800283a 	ret

08234898 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 8234898:	defffb04 	addi	sp,sp,-20
 823489c:	dfc00415 	stw	ra,16(sp)
 82348a0:	df000315 	stw	fp,12(sp)
 82348a4:	df000304 	addi	fp,sp,12
 82348a8:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 82348ac:	822d3a00 	call	822d3a0 <irq_Mask>
   m = sb->sb_mb;
 82348b0:	e0bfff17 	ldw	r2,-4(fp)
 82348b4:	10800617 	ldw	r2,24(r2)
 82348b8:	e0bffd15 	stw	r2,-12(fp)
   if (m)
 82348bc:	e0bffd17 	ldw	r2,-12(fp)
 82348c0:	10001226 	beq	r2,zero,823490c <sbdroprecord+0x74>
   {  sb->sb_mb = m->m_act;
 82348c4:	e0bffd17 	ldw	r2,-12(fp)
 82348c8:	10c00717 	ldw	r3,28(r2)
 82348cc:	e0bfff17 	ldw	r2,-4(fp)
 82348d0:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 82348d4:	e0bfff17 	ldw	r2,-4(fp)
 82348d8:	10c00017 	ldw	r3,0(r2)
 82348dc:	e0bffd17 	ldw	r2,-12(fp)
 82348e0:	10800217 	ldw	r2,8(r2)
 82348e4:	1887c83a 	sub	r3,r3,r2
 82348e8:	e0bfff17 	ldw	r2,-4(fp)
 82348ec:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 82348f0:	e13ffd17 	ldw	r4,-12(fp)
 82348f4:	822e1640 	call	822e164 <m_free>
 82348f8:	e0bffe15 	stw	r2,-8(fp)
      } while ((m = mn) != NULL);
 82348fc:	e0bffe17 	ldw	r2,-8(fp)
 8234900:	e0bffd15 	stw	r2,-12(fp)
 8234904:	e0bffd17 	ldw	r2,-12(fp)
 8234908:	103ff21e 	bne	r2,zero,82348d4 <sbdroprecord+0x3c>
         }
   EXIT_CRIT_SECTION(sb);
 823490c:	822d4000 	call	822d400 <irq_Unmask>
}
 8234910:	0001883a 	nop
 8234914:	e037883a 	mov	sp,fp
 8234918:	dfc00117 	ldw	ra,4(sp)
 823491c:	df000017 	ldw	fp,0(sp)
 8234920:	dec00204 	addi	sp,sp,8
 8234924:	f800283a 	ret

08234928 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 8234928:	defe7204 	addi	sp,sp,-1592
 823492c:	dfc18d15 	stw	ra,1588(sp)
 8234930:	df018c15 	stw	fp,1584(sp)
 8234934:	df018c04 	addi	fp,sp,1584
 8234938:	e13ffc15 	stw	r4,-16(fp)
 823493c:	e17ffd15 	stw	r5,-12(fp)
 8234940:	e1bffe15 	stw	r6,-8(fp)
 8234944:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 8234948:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 823494c:	e0be7604 	addi	r2,fp,-1576
 8234950:	0180c304 	movi	r6,780
 8234954:	000b883a 	mov	r5,zero
 8234958:	1009883a 	mov	r4,r2
 823495c:	8202cb00 	call	8202cb0 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 8234960:	e0bf3904 	addi	r2,fp,-796
 8234964:	0180c304 	movi	r6,780
 8234968:	000b883a 	mov	r5,zero
 823496c:	1009883a 	mov	r4,r2
 8234970:	8202cb00 	call	8202cb0 <memset>

   if (in)
 8234974:	e0bffc17 	ldw	r2,-16(fp)
 8234978:	10000526 	beq	r2,zero,8234990 <t_select+0x68>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 823497c:	e0bf3904 	addi	r2,fp,-796
 8234980:	01804104 	movi	r6,260
 8234984:	e17ffc17 	ldw	r5,-16(fp)
 8234988:	1009883a 	mov	r4,r2
 823498c:	8202a0c0 	call	8202a0c <memcpy>
   if (out)
 8234990:	e0bffd17 	ldw	r2,-12(fp)
 8234994:	10000626 	beq	r2,zero,82349b0 <t_select+0x88>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 8234998:	e0bf3904 	addi	r2,fp,-796
 823499c:	10804104 	addi	r2,r2,260
 82349a0:	01804104 	movi	r6,260
 82349a4:	e17ffd17 	ldw	r5,-12(fp)
 82349a8:	1009883a 	mov	r4,r2
 82349ac:	8202a0c0 	call	8202a0c <memcpy>
   if (ex)
 82349b0:	e0bffe17 	ldw	r2,-8(fp)
 82349b4:	10000626 	beq	r2,zero,82349d0 <t_select+0xa8>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 82349b8:	e0bf3904 	addi	r2,fp,-796
 82349bc:	10808204 	addi	r2,r2,520
 82349c0:	01804104 	movi	r6,260
 82349c4:	e17ffe17 	ldw	r5,-8(fp)
 82349c8:	1009883a 	mov	r4,r2
 82349cc:	8202a0c0 	call	8202a0c <memcpy>
   tmo = cticks + tv;
 82349d0:	d0e0a817 	ldw	r3,-32096(gp)
 82349d4:	e0bfff17 	ldw	r2,-4(fp)
 82349d8:	1885883a 	add	r2,r3,r2
 82349dc:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 82349e0:	e0bf3917 	ldw	r2,-796(fp)
 82349e4:	10000c1e 	bne	r2,zero,8234a18 <t_select+0xf0>
 82349e8:	e0bf7a17 	ldw	r2,-536(fp)
 82349ec:	10000a1e 	bne	r2,zero,8234a18 <t_select+0xf0>
       (ibits[2].fd_count == 0))
 82349f0:	e0bfbb17 	ldw	r2,-276(fp)
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 82349f4:	1000081e 	bne	r2,zero,8234a18 <t_select+0xf0>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 82349f8:	e0bfff17 	ldw	r2,-4(fp)
 82349fc:	00801f0e 	bge	zero,r2,8234a7c <t_select+0x154>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 8234a00:	e0bfff17 	ldw	r2,-4(fp)
 8234a04:	10800044 	addi	r2,r2,1
 8234a08:	10bfffcc 	andi	r2,r2,65535
 8234a0c:	1009883a 	mov	r4,r2
 8234a10:	821bb0c0 	call	821bb0c <OSTimeDly>

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234a14:	00001906 	br	8234a7c <t_select+0x154>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 8234a18:	0009883a 	mov	r4,zero
 8234a1c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234a20:	00000a06 	br	8234a4c <t_select+0x124>
      {
         if (tv != -1L) 
 8234a24:	e0bfff17 	ldw	r2,-4(fp)
 8234a28:	10bfffe0 	cmpeqi	r2,r2,-1
 8234a2c:	1000031e 	bne	r2,zero,8234a3c <t_select+0x114>
         {
            if (tmo <= cticks)
 8234a30:	d0e0a817 	ldw	r3,-32096(gp)
 8234a34:	e0be7517 	ldw	r2,-1580(fp)
 8234a38:	18800d2e 	bgeu	r3,r2,8234a70 <t_select+0x148>
               break;
         }
         select_wait = 1;
 8234a3c:	00800044 	movi	r2,1
 8234a40:	d0a0b00d 	sth	r2,-32064(gp)
         tcp_sleep (&select_wait);
 8234a44:	d120b004 	addi	r4,gp,-32064
 8234a48:	82291680 	call	8229168 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234a4c:	e0fe7604 	addi	r3,fp,-1576
 8234a50:	e0bf3904 	addi	r2,fp,-796
 8234a54:	180b883a 	mov	r5,r3
 8234a58:	1009883a 	mov	r4,r2
 8234a5c:	8234af80 	call	8234af8 <sock_selscan>
 8234a60:	e0be7415 	stw	r2,-1584(fp)
 8234a64:	e0be7417 	ldw	r2,-1584(fp)
 8234a68:	103fee26 	beq	r2,zero,8234a24 <t_select+0xfc>
 8234a6c:	00000106 	br	8234a74 <t_select+0x14c>
      {
         if (tv != -1L) 
         {
            if (tmo <= cticks)
               break;
 8234a70:	0001883a 	nop
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 8234a74:	0009883a 	mov	r4,zero
 8234a78:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 8234a7c:	e0be7417 	ldw	r2,-1584(fp)
 8234a80:	10001716 	blt	r2,zero,8234ae0 <t_select+0x1b8>
   {
      if (in)
 8234a84:	e0bffc17 	ldw	r2,-16(fp)
 8234a88:	10000526 	beq	r2,zero,8234aa0 <t_select+0x178>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 8234a8c:	e0be7604 	addi	r2,fp,-1576
 8234a90:	01804104 	movi	r6,260
 8234a94:	100b883a 	mov	r5,r2
 8234a98:	e13ffc17 	ldw	r4,-16(fp)
 8234a9c:	8202a0c0 	call	8202a0c <memcpy>
      if (out)
 8234aa0:	e0bffd17 	ldw	r2,-12(fp)
 8234aa4:	10000626 	beq	r2,zero,8234ac0 <t_select+0x198>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 8234aa8:	e0be7604 	addi	r2,fp,-1576
 8234aac:	10804104 	addi	r2,r2,260
 8234ab0:	01804104 	movi	r6,260
 8234ab4:	100b883a 	mov	r5,r2
 8234ab8:	e13ffd17 	ldw	r4,-12(fp)
 8234abc:	8202a0c0 	call	8202a0c <memcpy>
      if (ex)
 8234ac0:	e0bffe17 	ldw	r2,-8(fp)
 8234ac4:	10000626 	beq	r2,zero,8234ae0 <t_select+0x1b8>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 8234ac8:	e0be7604 	addi	r2,fp,-1576
 8234acc:	10808204 	addi	r2,r2,520
 8234ad0:	01804104 	movi	r6,260
 8234ad4:	100b883a 	mov	r5,r2
 8234ad8:	e13ffe17 	ldw	r4,-8(fp)
 8234adc:	8202a0c0 	call	8202a0c <memcpy>
   }
   return retval;
 8234ae0:	e0be7417 	ldw	r2,-1584(fp)
}
 8234ae4:	e037883a 	mov	sp,fp
 8234ae8:	dfc00117 	ldw	ra,4(sp)
 8234aec:	df000017 	ldw	fp,0(sp)
 8234af0:	dec00204 	addi	sp,sp,8
 8234af4:	f800283a 	ret

08234af8 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 8234af8:	defff604 	addi	sp,sp,-40
 8234afc:	dfc00915 	stw	ra,36(sp)
 8234b00:	df000815 	stw	fp,32(sp)
 8234b04:	df000804 	addi	fp,sp,32
 8234b08:	e13ffe15 	stw	r4,-8(fp)
 8234b0c:	e17fff15 	stw	r5,-4(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 8234b10:	e03ffa15 	stw	zero,-24(fp)
   int   num_sel  =  0;
 8234b14:	e03ffb15 	stw	zero,-20(fp)

   for (which = 0; which < 3; which++)
 8234b18:	e03ff815 	stw	zero,-32(fp)
 8234b1c:	00003d06 	br	8234c14 <sock_selscan+0x11c>
   {
      switch (which)
 8234b20:	e0bff817 	ldw	r2,-32(fp)
 8234b24:	10c00060 	cmpeqi	r3,r2,1
 8234b28:	1800061e 	bne	r3,zero,8234b44 <sock_selscan+0x4c>
 8234b2c:	10c000a0 	cmpeqi	r3,r2,2
 8234b30:	1800071e 	bne	r3,zero,8234b50 <sock_selscan+0x58>
 8234b34:	1000081e 	bne	r2,zero,8234b58 <sock_selscan+0x60>
      {
      case 0:
         flag = SOREAD; break;
 8234b38:	00800044 	movi	r2,1
 8234b3c:	e0bffa15 	stw	r2,-24(fp)
 8234b40:	00000506 	br	8234b58 <sock_selscan+0x60>

      case 1:
         flag = SOWRITE; break;
 8234b44:	00800084 	movi	r2,2
 8234b48:	e0bffa15 	stw	r2,-24(fp)
 8234b4c:	00000206 	br	8234b58 <sock_selscan+0x60>

      case 2:
         flag = 0; break;
 8234b50:	e03ffa15 	stw	zero,-24(fp)
 8234b54:	0001883a 	nop
      }
      in = &ibits [which];
 8234b58:	e0bff817 	ldw	r2,-32(fp)
 8234b5c:	10804124 	muli	r2,r2,260
 8234b60:	e0fffe17 	ldw	r3,-8(fp)
 8234b64:	1885883a 	add	r2,r3,r2
 8234b68:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 8234b6c:	e0bff817 	ldw	r2,-32(fp)
 8234b70:	10804124 	muli	r2,r2,260
 8234b74:	e0ffff17 	ldw	r3,-4(fp)
 8234b78:	1885883a 	add	r2,r3,r2
 8234b7c:	e0bffd15 	stw	r2,-12(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234b80:	e03ff915 	stw	zero,-28(fp)
 8234b84:	00001b06 	br	8234bf4 <sock_selscan+0xfc>
      {
         if (sock_select (in->fd_array[sock], flag))
 8234b88:	e0fffc17 	ldw	r3,-16(fp)
 8234b8c:	e0bff917 	ldw	r2,-28(fp)
 8234b90:	10800044 	addi	r2,r2,1
 8234b94:	1085883a 	add	r2,r2,r2
 8234b98:	1085883a 	add	r2,r2,r2
 8234b9c:	1885883a 	add	r2,r3,r2
 8234ba0:	10800017 	ldw	r2,0(r2)
 8234ba4:	e17ffa17 	ldw	r5,-24(fp)
 8234ba8:	1009883a 	mov	r4,r2
 8234bac:	8234c380 	call	8234c38 <sock_select>
 8234bb0:	10000d26 	beq	r2,zero,8234be8 <sock_selscan+0xf0>
         {
            FD_SET(in->fd_array[sock], out);
 8234bb4:	e0fffc17 	ldw	r3,-16(fp)
 8234bb8:	e0bff917 	ldw	r2,-28(fp)
 8234bbc:	10800044 	addi	r2,r2,1
 8234bc0:	1085883a 	add	r2,r2,r2
 8234bc4:	1085883a 	add	r2,r2,r2
 8234bc8:	1885883a 	add	r2,r3,r2
 8234bcc:	10800017 	ldw	r2,0(r2)
 8234bd0:	e17ffd17 	ldw	r5,-12(fp)
 8234bd4:	1009883a 	mov	r4,r2
 8234bd8:	82350500 	call	8235050 <ifd_set>
            num_sel++;
 8234bdc:	e0bffb17 	ldw	r2,-20(fp)
 8234be0:	10800044 	addi	r2,r2,1
 8234be4:	e0bffb15 	stw	r2,-20(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234be8:	e0bff917 	ldw	r2,-28(fp)
 8234bec:	10800044 	addi	r2,r2,1
 8234bf0:	e0bff915 	stw	r2,-28(fp)
 8234bf4:	e0bffc17 	ldw	r2,-16(fp)
 8234bf8:	10800017 	ldw	r2,0(r2)
 8234bfc:	1007883a 	mov	r3,r2
 8234c00:	e0bff917 	ldw	r2,-28(fp)
 8234c04:	10ffe016 	blt	r2,r3,8234b88 <sock_selscan+0x90>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 8234c08:	e0bff817 	ldw	r2,-32(fp)
 8234c0c:	10800044 	addi	r2,r2,1
 8234c10:	e0bff815 	stw	r2,-32(fp)
 8234c14:	e0bff817 	ldw	r2,-32(fp)
 8234c18:	108000d0 	cmplti	r2,r2,3
 8234c1c:	103fc01e 	bne	r2,zero,8234b20 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 8234c20:	e0bffb17 	ldw	r2,-20(fp)
}
 8234c24:	e037883a 	mov	sp,fp
 8234c28:	dfc00117 	ldw	ra,4(sp)
 8234c2c:	df000017 	ldw	fp,0(sp)
 8234c30:	dec00204 	addi	sp,sp,8
 8234c34:	f800283a 	ret

08234c38 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 8234c38:	defffa04 	addi	sp,sp,-24
 8234c3c:	dfc00515 	stw	ra,20(sp)
 8234c40:	df000415 	stw	fp,16(sp)
 8234c44:	df000404 	addi	fp,sp,16
 8234c48:	e13ffe15 	stw	r4,-8(fp)
 8234c4c:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   ready =  0;
 8234c50:	e03ffc15 	stw	zero,-16(fp)

   so = LONG2SO(sock);
 8234c54:	e0bffe17 	ldw	r2,-8(fp)
 8234c58:	10bff804 	addi	r2,r2,-32
 8234c5c:	1085883a 	add	r2,r2,r2
 8234c60:	1085883a 	add	r2,r2,r2
 8234c64:	e0bffd15 	stw	r2,-12(fp)

   switch (flag) 
 8234c68:	e0bfff17 	ldw	r2,-4(fp)
 8234c6c:	10c00060 	cmpeqi	r3,r2,1
 8234c70:	1800041e 	bne	r3,zero,8234c84 <sock_select+0x4c>
 8234c74:	10c000a0 	cmpeqi	r3,r2,2
 8234c78:	1800201e 	bne	r3,zero,8234cfc <sock_select+0xc4>
 8234c7c:	10004326 	beq	r2,zero,8234d8c <sock_select+0x154>
 8234c80:	00006006 	br	8234e04 <sock_select+0x1cc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 8234c84:	e0bffd17 	ldw	r2,-12(fp)
 8234c88:	10800a17 	ldw	r2,40(r2)
 8234c8c:	10000326 	beq	r2,zero,8234c9c <sock_select+0x64>
      {
         ready = 1;
 8234c90:	00800044 	movi	r2,1
 8234c94:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234c98:	00005a06 	br	8234e04 <sock_select+0x1cc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8234c9c:	e0bffd17 	ldw	r2,-12(fp)
 8234ca0:	1080088b 	ldhu	r2,34(r2)
 8234ca4:	10bfffcc 	andi	r2,r2,65535
 8234ca8:	1080080c 	andi	r2,r2,32
 8234cac:	10000326 	beq	r2,zero,8234cbc <sock_select+0x84>
      {  ready = 1;
 8234cb0:	00800044 	movi	r2,1
 8234cb4:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234cb8:	00005206 	br	8234e04 <sock_select+0x1cc>
      }
      if (so->so_qlen)  /* attach is ready */
 8234cbc:	e0bffd17 	ldw	r2,-12(fp)
 8234cc0:	10801e43 	ldbu	r2,121(r2)
 8234cc4:	10803fcc 	andi	r2,r2,255
 8234cc8:	1080201c 	xori	r2,r2,128
 8234ccc:	10bfe004 	addi	r2,r2,-128
 8234cd0:	10000326 	beq	r2,zero,8234ce0 <sock_select+0xa8>
      {
         ready = 1;
 8234cd4:	00800044 	movi	r2,1
 8234cd8:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234cdc:	00004906 	br	8234e04 <sock_select+0x1cc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 8234ce0:	e0bffd17 	ldw	r2,-12(fp)
 8234ce4:	1080110b 	ldhu	r2,68(r2)
 8234ce8:	10800214 	ori	r2,r2,8
 8234cec:	1007883a 	mov	r3,r2
 8234cf0:	e0bffd17 	ldw	r2,-12(fp)
 8234cf4:	10c0110d 	sth	r3,68(r2)
      break;
 8234cf8:	00004206 	br	8234e04 <sock_select+0x1cc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8234cfc:	e0bffd17 	ldw	r2,-12(fp)
 8234d00:	10801317 	ldw	r2,76(r2)
 8234d04:	1007883a 	mov	r3,r2
 8234d08:	e0bffd17 	ldw	r2,-12(fp)
 8234d0c:	10801217 	ldw	r2,72(r2)
 8234d10:	1885c83a 	sub	r2,r3,r2
 8234d14:	10001816 	blt	r2,zero,8234d78 <sock_select+0x140>
 8234d18:	e0bffd17 	ldw	r2,-12(fp)
 8234d1c:	10c01317 	ldw	r3,76(r2)
 8234d20:	e0bffd17 	ldw	r2,-12(fp)
 8234d24:	10801217 	ldw	r2,72(r2)
 8234d28:	18801326 	beq	r3,r2,8234d78 <sock_select+0x140>
          ((((so)->so_state&SS_ISCONNECTED) || 
 8234d2c:	e0bffd17 	ldw	r2,-12(fp)
 8234d30:	1080088b 	ldhu	r2,34(r2)
 8234d34:	10bfffcc 	andi	r2,r2,65535
 8234d38:	1080008c 	andi	r2,r2,2
      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8234d3c:	10000b1e 	bne	r2,zero,8234d6c <sock_select+0x134>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8234d40:	e0bffd17 	ldw	r2,-12(fp)
 8234d44:	10800217 	ldw	r2,8(r2)
 8234d48:	1080010b 	ldhu	r2,4(r2)
 8234d4c:	10bfffcc 	andi	r2,r2,65535
 8234d50:	1080010c 	andi	r2,r2,4
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
 8234d54:	10000526 	beq	r2,zero,8234d6c <sock_select+0x134>
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
 8234d58:	e0bffd17 	ldw	r2,-12(fp)
 8234d5c:	1080088b 	ldhu	r2,34(r2)
 8234d60:	10bfffcc 	andi	r2,r2,65535
 8234d64:	1080040c 	andi	r2,r2,16
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8234d68:	10000326 	beq	r2,zero,8234d78 <sock_select+0x140>
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 8234d6c:	00800044 	movi	r2,1
 8234d70:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234d74:	00002306 	br	8234e04 <sock_select+0x1cc>
      }
      sbselqueue (&so->so_snd);
 8234d78:	e0bffd17 	ldw	r2,-12(fp)
 8234d7c:	10801204 	addi	r2,r2,72
 8234d80:	1009883a 	mov	r4,r2
 8234d84:	8233dd00 	call	8233dd0 <sbselqueue>
      break;
 8234d88:	00001e06 	br	8234e04 <sock_select+0x1cc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 8234d8c:	e0bffd17 	ldw	r2,-12(fp)
 8234d90:	10801a17 	ldw	r2,104(r2)
 8234d94:	1000051e 	bne	r2,zero,8234dac <sock_select+0x174>
 8234d98:	e0bffd17 	ldw	r2,-12(fp)
 8234d9c:	1080088b 	ldhu	r2,34(r2)
 8234da0:	10bfffcc 	andi	r2,r2,65535
 8234da4:	1080100c 	andi	r2,r2,64
 8234da8:	10000326 	beq	r2,zero,8234db8 <sock_select+0x180>
      {
         ready = 1;
 8234dac:	00800044 	movi	r2,1
 8234db0:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234db4:	00001306 	br	8234e04 <sock_select+0x1cc>
      }
      if (so->so_error &&
 8234db8:	e0bffd17 	ldw	r2,-12(fp)
 8234dbc:	10800617 	ldw	r2,24(r2)
 8234dc0:	10000b26 	beq	r2,zero,8234df0 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
 8234dc4:	e0bffd17 	ldw	r2,-12(fp)
 8234dc8:	10800617 	ldw	r2,24(r2)
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
 8234dcc:	10801de0 	cmpeqi	r2,r2,119
 8234dd0:	1000071e 	bne	r2,zero,8234df0 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
 8234dd4:	e0bffd17 	ldw	r2,-12(fp)
 8234dd8:	10800617 	ldw	r2,24(r2)
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
          (so->so_error != EINPROGRESS) &&
 8234ddc:	108002e0 	cmpeqi	r2,r2,11
 8234de0:	1000031e 	bne	r2,zero,8234df0 <sock_select+0x1b8>
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 8234de4:	00800044 	movi	r2,1
 8234de8:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234dec:	00000506 	br	8234e04 <sock_select+0x1cc>
      }
      sbselqueue(&so->so_rcv);
 8234df0:	e0bffd17 	ldw	r2,-12(fp)
 8234df4:	10800a04 	addi	r2,r2,40
 8234df8:	1009883a 	mov	r4,r2
 8234dfc:	8233dd00 	call	8233dd0 <sbselqueue>
      break;
 8234e00:	0001883a 	nop
   }

   return ready;
 8234e04:	e0bffc17 	ldw	r2,-16(fp)
}
 8234e08:	e037883a 	mov	sp,fp
 8234e0c:	dfc00117 	ldw	ra,4(sp)
 8234e10:	df000017 	ldw	fp,0(sp)
 8234e14:	dec00204 	addi	sp,sp,8
 8234e18:	f800283a 	ret

08234e1c <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 8234e1c:	defff804 	addi	sp,sp,-32
 8234e20:	dfc00715 	stw	ra,28(sp)
 8234e24:	df000615 	stw	fp,24(sp)
 8234e28:	df000604 	addi	fp,sp,24
 8234e2c:	e13ffc15 	stw	r4,-16(fp)
 8234e30:	e17ffd15 	stw	r5,-12(fp)
 8234e34:	e1bffe15 	stw	r6,-8(fp)
 8234e38:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8234e3c:	e0bffc17 	ldw	r2,-16(fp)
 8234e40:	10800017 	ldw	r2,0(r2)
 8234e44:	e0bffa15 	stw	r2,-24(fp)
 8234e48:	00001c06 	br	8234ebc <in_pcbnotify+0xa0>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8234e4c:	e0bffa17 	ldw	r2,-24(fp)
 8234e50:	10c00317 	ldw	r3,12(r2)
 8234e54:	e0bffd17 	ldw	r2,-12(fp)
 8234e58:	10800017 	ldw	r2,0(r2)
 8234e5c:	1880031e 	bne	r3,r2,8234e6c <in_pcbnotify+0x50>
          inp->inp_socket == 0) 
 8234e60:	e0bffa17 	ldw	r2,-24(fp)
 8234e64:	10800817 	ldw	r2,32(r2)
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8234e68:	1000041e 	bne	r2,zero,8234e7c <in_pcbnotify+0x60>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 8234e6c:	e0bffa17 	ldw	r2,-24(fp)
 8234e70:	10800017 	ldw	r2,0(r2)
 8234e74:	e0bffa15 	stw	r2,-24(fp)
         continue;
 8234e78:	00001006 	br	8234ebc <in_pcbnotify+0xa0>
      }
      if (errnum) 
 8234e7c:	e0bffe17 	ldw	r2,-8(fp)
 8234e80:	10000426 	beq	r2,zero,8234e94 <in_pcbnotify+0x78>
         inp->inp_socket->so_error = errnum;
 8234e84:	e0bffa17 	ldw	r2,-24(fp)
 8234e88:	10800817 	ldw	r2,32(r2)
 8234e8c:	e0fffe17 	ldw	r3,-8(fp)
 8234e90:	10c00615 	stw	r3,24(r2)
      oinp = inp;
 8234e94:	e0bffa17 	ldw	r2,-24(fp)
 8234e98:	e0bffb15 	stw	r2,-20(fp)
      inp = inp->inp_next;
 8234e9c:	e0bffa17 	ldw	r2,-24(fp)
 8234ea0:	10800017 	ldw	r2,0(r2)
 8234ea4:	e0bffa15 	stw	r2,-24(fp)
      if (notify)
 8234ea8:	e0bfff17 	ldw	r2,-4(fp)
 8234eac:	10000326 	beq	r2,zero,8234ebc <in_pcbnotify+0xa0>
         (*notify)(oinp);
 8234eb0:	e0bfff17 	ldw	r2,-4(fp)
 8234eb4:	e13ffb17 	ldw	r4,-20(fp)
 8234eb8:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8234ebc:	e0fffa17 	ldw	r3,-24(fp)
 8234ec0:	e0bffc17 	ldw	r2,-16(fp)
 8234ec4:	18bfe11e 	bne	r3,r2,8234e4c <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 8234ec8:	0001883a 	nop
 8234ecc:	e037883a 	mov	sp,fp
 8234ed0:	dfc00117 	ldw	ra,4(sp)
 8234ed4:	df000017 	ldw	fp,0(sp)
 8234ed8:	dec00204 	addi	sp,sp,8
 8234edc:	f800283a 	ret

08234ee0 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 8234ee0:	defffd04 	addi	sp,sp,-12
 8234ee4:	dfc00215 	stw	ra,8(sp)
 8234ee8:	df000115 	stw	fp,4(sp)
 8234eec:	df000104 	addi	fp,sp,4
 8234ef0:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 8234ef4:	e0bfff17 	ldw	r2,-4(fp)
 8234ef8:	10800817 	ldw	r2,32(r2)
 8234efc:	10800904 	addi	r2,r2,36
 8234f00:	1009883a 	mov	r4,r2
 8234f04:	82292dc0 	call	82292dc <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 8234f08:	e0bfff17 	ldw	r2,-4(fp)
 8234f0c:	10c00817 	ldw	r3,32(r2)
 8234f10:	e0bfff17 	ldw	r2,-4(fp)
 8234f14:	10800817 	ldw	r2,32(r2)
 8234f18:	10800a04 	addi	r2,r2,40
 8234f1c:	100b883a 	mov	r5,r2
 8234f20:	1809883a 	mov	r4,r3
 8234f24:	8233e780 	call	8233e78 <sbwakeup>
   sowwakeup(inp->inp_socket);
 8234f28:	e0bfff17 	ldw	r2,-4(fp)
 8234f2c:	10c00817 	ldw	r3,32(r2)
 8234f30:	e0bfff17 	ldw	r2,-4(fp)
 8234f34:	10800817 	ldw	r2,32(r2)
 8234f38:	10801204 	addi	r2,r2,72
 8234f3c:	100b883a 	mov	r5,r2
 8234f40:	1809883a 	mov	r4,r3
 8234f44:	8233e780 	call	8233e78 <sbwakeup>
}
 8234f48:	0001883a 	nop
 8234f4c:	e037883a 	mov	sp,fp
 8234f50:	dfc00117 	ldw	ra,4(sp)
 8234f54:	df000017 	ldw	fp,0(sp)
 8234f58:	dec00204 	addi	sp,sp,8
 8234f5c:	f800283a 	ret

08234f60 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 8234f60:	defffb04 	addi	sp,sp,-20
 8234f64:	dfc00415 	stw	ra,16(sp)
 8234f68:	df000315 	stw	fp,12(sp)
 8234f6c:	df000304 	addi	fp,sp,12
 8234f70:	e13ffe15 	stw	r4,-8(fp)
 8234f74:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 8234f78:	e03ffd15 	stw	zero,-12(fp)
 8234f7c:	00002a06 	br	8235028 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 8234f80:	e0ffff17 	ldw	r3,-4(fp)
 8234f84:	e0bffd17 	ldw	r2,-12(fp)
 8234f88:	10800044 	addi	r2,r2,1
 8234f8c:	1085883a 	add	r2,r2,r2
 8234f90:	1085883a 	add	r2,r2,r2
 8234f94:	1885883a 	add	r2,r3,r2
 8234f98:	10c00017 	ldw	r3,0(r2)
 8234f9c:	e0bffe17 	ldw	r2,-8(fp)
 8234fa0:	18801e1e 	bne	r3,r2,823501c <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 8234fa4:	00001206 	br	8234ff0 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 8234fa8:	e0bffd17 	ldw	r2,-12(fp)
 8234fac:	10800044 	addi	r2,r2,1
 8234fb0:	e0ffff17 	ldw	r3,-4(fp)
 8234fb4:	10800044 	addi	r2,r2,1
 8234fb8:	1085883a 	add	r2,r2,r2
 8234fbc:	1085883a 	add	r2,r2,r2
 8234fc0:	1885883a 	add	r2,r3,r2
 8234fc4:	10c00017 	ldw	r3,0(r2)
 8234fc8:	e13fff17 	ldw	r4,-4(fp)
 8234fcc:	e0bffd17 	ldw	r2,-12(fp)
 8234fd0:	10800044 	addi	r2,r2,1
 8234fd4:	1085883a 	add	r2,r2,r2
 8234fd8:	1085883a 	add	r2,r2,r2
 8234fdc:	2085883a 	add	r2,r4,r2
 8234fe0:	10c00015 	stw	r3,0(r2)
            i++;
 8234fe4:	e0bffd17 	ldw	r2,-12(fp)
 8234fe8:	10800044 	addi	r2,r2,1
 8234fec:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 8234ff0:	e0bffd17 	ldw	r2,-12(fp)
 8234ff4:	10c00044 	addi	r3,r2,1
 8234ff8:	e0bfff17 	ldw	r2,-4(fp)
 8234ffc:	10800017 	ldw	r2,0(r2)
 8235000:	18bfe936 	bltu	r3,r2,8234fa8 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 8235004:	e0bfff17 	ldw	r2,-4(fp)
 8235008:	10800017 	ldw	r2,0(r2)
 823500c:	10ffffc4 	addi	r3,r2,-1
 8235010:	e0bfff17 	ldw	r2,-4(fp)
 8235014:	10c00015 	stw	r3,0(r2)
         return;
 8235018:	00000806 	br	823503c <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 823501c:	e0bffd17 	ldw	r2,-12(fp)
 8235020:	10800044 	addi	r2,r2,1
 8235024:	e0bffd15 	stw	r2,-12(fp)
 8235028:	e0bfff17 	ldw	r2,-4(fp)
 823502c:	10800017 	ldw	r2,0(r2)
 8235030:	e0fffd17 	ldw	r3,-12(fp)
 8235034:	18bfd236 	bltu	r3,r2,8234f80 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 8235038:	822d1c80 	call	822d1c8 <dtrap>
#endif
}
 823503c:	e037883a 	mov	sp,fp
 8235040:	dfc00117 	ldw	ra,4(sp)
 8235044:	df000017 	ldw	fp,0(sp)
 8235048:	dec00204 	addi	sp,sp,8
 823504c:	f800283a 	ret

08235050 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 8235050:	defffc04 	addi	sp,sp,-16
 8235054:	dfc00315 	stw	ra,12(sp)
 8235058:	df000215 	stw	fp,8(sp)
 823505c:	df000204 	addi	fp,sp,8
 8235060:	e13ffe15 	stw	r4,-8(fp)
 8235064:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 8235068:	e0bfff17 	ldw	r2,-4(fp)
 823506c:	10800017 	ldw	r2,0(r2)
 8235070:	10801028 	cmpgeui	r2,r2,64
 8235074:	10000d1e 	bne	r2,zero,82350ac <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 8235078:	e0bfff17 	ldw	r2,-4(fp)
 823507c:	10800017 	ldw	r2,0(r2)
 8235080:	11000044 	addi	r4,r2,1
 8235084:	e0ffff17 	ldw	r3,-4(fp)
 8235088:	19000015 	stw	r4,0(r3)
 823508c:	e0ffff17 	ldw	r3,-4(fp)
 8235090:	10800044 	addi	r2,r2,1
 8235094:	1085883a 	add	r2,r2,r2
 8235098:	1085883a 	add	r2,r2,r2
 823509c:	1885883a 	add	r2,r3,r2
 82350a0:	e0fffe17 	ldw	r3,-8(fp)
 82350a4:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
   else
      dtrap();
#endif
}
 82350a8:	00000106 	br	82350b0 <ifd_set+0x60>
{
   if (set->fd_count < FD_SETSIZE)
      set->fd_array[set->fd_count++] = sock;
#ifdef NPDEBUG
   else
      dtrap();
 82350ac:	822d1c80 	call	822d1c8 <dtrap>
#endif
}
 82350b0:	0001883a 	nop
 82350b4:	e037883a 	mov	sp,fp
 82350b8:	dfc00117 	ldw	ra,4(sp)
 82350bc:	df000017 	ldw	fp,0(sp)
 82350c0:	dec00204 	addi	sp,sp,8
 82350c4:	f800283a 	ret

082350c8 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 82350c8:	defffc04 	addi	sp,sp,-16
 82350cc:	df000315 	stw	fp,12(sp)
 82350d0:	df000304 	addi	fp,sp,12
 82350d4:	e13ffe15 	stw	r4,-8(fp)
 82350d8:	e17fff15 	stw	r5,-4(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 82350dc:	e03ffd15 	stw	zero,-12(fp)
 82350e0:	00000e06 	br	823511c <ifd_isset+0x54>
   {
      if (set->fd_array[i] == sock)
 82350e4:	e0ffff17 	ldw	r3,-4(fp)
 82350e8:	e0bffd17 	ldw	r2,-12(fp)
 82350ec:	10800044 	addi	r2,r2,1
 82350f0:	1085883a 	add	r2,r2,r2
 82350f4:	1085883a 	add	r2,r2,r2
 82350f8:	1885883a 	add	r2,r3,r2
 82350fc:	10c00017 	ldw	r3,0(r2)
 8235100:	e0bffe17 	ldw	r2,-8(fp)
 8235104:	1880021e 	bne	r3,r2,8235110 <ifd_isset+0x48>
         return TRUE;
 8235108:	00800044 	movi	r2,1
 823510c:	00000806 	br	8235130 <ifd_isset+0x68>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 8235110:	e0bffd17 	ldw	r2,-12(fp)
 8235114:	10800044 	addi	r2,r2,1
 8235118:	e0bffd15 	stw	r2,-12(fp)
 823511c:	e0bfff17 	ldw	r2,-4(fp)
 8235120:	10800017 	ldw	r2,0(r2)
 8235124:	e0fffd17 	ldw	r3,-12(fp)
 8235128:	18bfee36 	bltu	r3,r2,82350e4 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 823512c:	0005883a 	mov	r2,zero
}
 8235130:	e037883a 	mov	sp,fp
 8235134:	df000017 	ldw	fp,0(sp)
 8235138:	dec00104 	addi	sp,sp,4
 823513c:	f800283a 	ret

08235140 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 8235140:	defffc04 	addi	sp,sp,-16
 8235144:	dfc00315 	stw	ra,12(sp)
 8235148:	df000215 	stw	fp,8(sp)
 823514c:	df000204 	addi	fp,sp,8
 8235150:	e13ffe15 	stw	r4,-8(fp)
 8235154:	e17fff15 	stw	r5,-4(fp)
   if (i < set->fd_count)
 8235158:	e0bfff17 	ldw	r2,-4(fp)
 823515c:	10800017 	ldw	r2,0(r2)
 8235160:	e0fffe17 	ldw	r3,-8(fp)
 8235164:	1880082e 	bgeu	r3,r2,8235188 <ifd_get+0x48>
      return set->fd_array[i];
 8235168:	e0ffff17 	ldw	r3,-4(fp)
 823516c:	e0bffe17 	ldw	r2,-8(fp)
 8235170:	10800044 	addi	r2,r2,1
 8235174:	1085883a 	add	r2,r2,r2
 8235178:	1085883a 	add	r2,r2,r2
 823517c:	1885883a 	add	r2,r3,r2
 8235180:	10800017 	ldw	r2,0(r2)
 8235184:	00000206 	br	8235190 <ifd_get+0x50>
   else
   {
#ifdef NPDEBUG
      dtrap();
 8235188:	822d1c80 	call	822d1c8 <dtrap>
#endif
      return INVALID_SOCKET;
 823518c:	00bfffc4 	movi	r2,-1
   }
}
 8235190:	e037883a 	mov	sp,fp
 8235194:	dfc00117 	ldw	ra,4(sp)
 8235198:	df000017 	ldw	fp,0(sp)
 823519c:	dec00204 	addi	sp,sp,8
 82351a0:	f800283a 	ret

082351a4 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 82351a4:	defff504 	addi	sp,sp,-44
 82351a8:	dfc00a15 	stw	ra,40(sp)
 82351ac:	df000915 	stw	fp,36(sp)
 82351b0:	df000904 	addi	fp,sp,36
 82351b4:	e13ffd15 	stw	r4,-12(fp)
 82351b8:	e17ffe15 	stw	r5,-8(fp)
 82351bc:	e1bfff15 	stw	r6,-4(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 82351c0:	e0bffd17 	ldw	r2,-12(fp)
 82351c4:	10800d17 	ldw	r2,52(r2)
 82351c8:	10800817 	ldw	r2,32(r2)
 82351cc:	e0bff815 	stw	r2,-32(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 82351d0:	e0bffe17 	ldw	r2,-8(fp)
 82351d4:	1000a426 	beq	r2,zero,8235468 <tcp_reass+0x2c4>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 82351d8:	e0bffd17 	ldw	r2,-12(fp)
 82351dc:	10800017 	ldw	r2,0(r2)
 82351e0:	e0bff715 	stw	r2,-36(fp)
 82351e4:	00000906 	br	823520c <tcp_reass+0x68>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 82351e8:	e0bff717 	ldw	r2,-36(fp)
 82351ec:	10c00617 	ldw	r3,24(r2)
 82351f0:	e0bffe17 	ldw	r2,-8(fp)
 82351f4:	10800617 	ldw	r2,24(r2)
 82351f8:	1885c83a 	sub	r2,r3,r2
 82351fc:	00800716 	blt	zero,r2,823521c <tcp_reass+0x78>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 8235200:	e0bff717 	ldw	r2,-36(fp)
 8235204:	10800017 	ldw	r2,0(r2)
 8235208:	e0bff715 	stw	r2,-36(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 823520c:	e0fff717 	ldw	r3,-36(fp)
 8235210:	e0bffd17 	ldw	r2,-12(fp)
 8235214:	18bff41e 	bne	r3,r2,82351e8 <tcp_reass+0x44>
 8235218:	00000106 	br	8235220 <tcp_reass+0x7c>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
      break;
 823521c:	0001883a 	nop
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 8235220:	e0bff717 	ldw	r2,-36(fp)
 8235224:	10c00117 	ldw	r3,4(r2)
 8235228:	e0bffd17 	ldw	r2,-12(fp)
 823522c:	18803f26 	beq	r3,r2,823532c <tcp_reass+0x188>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 8235230:	e0bff717 	ldw	r2,-36(fp)
 8235234:	10800117 	ldw	r2,4(r2)
 8235238:	e0bff715 	stw	r2,-36(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 823523c:	e0bff717 	ldw	r2,-36(fp)
 8235240:	10c00617 	ldw	r3,24(r2)
 8235244:	e0bff717 	ldw	r2,-36(fp)
 8235248:	1080028b 	ldhu	r2,10(r2)
 823524c:	10bfffcc 	andi	r2,r2,65535
 8235250:	1887883a 	add	r3,r3,r2
 8235254:	e0bffe17 	ldw	r2,-8(fp)
 8235258:	10800617 	ldw	r2,24(r2)
 823525c:	1885c83a 	sub	r2,r3,r2
 8235260:	e0bff915 	stw	r2,-28(fp)
      if (i > 0) 
 8235264:	e0bff917 	ldw	r2,-28(fp)
 8235268:	00802d0e 	bge	zero,r2,8235320 <tcp_reass+0x17c>
      {
         if (i >= (long)ti->ti_len) 
 823526c:	e0bffe17 	ldw	r2,-8(fp)
 8235270:	1080028b 	ldhu	r2,10(r2)
 8235274:	10bfffcc 	andi	r2,r2,65535
 8235278:	e0fff917 	ldw	r3,-28(fp)
 823527c:	18801816 	blt	r3,r2,82352e0 <tcp_reass+0x13c>
         {
            tcpstat.tcps_rcvduppack++;
 8235280:	008209b4 	movhi	r2,2086
 8235284:	10b82204 	addi	r2,r2,-8056
 8235288:	10801f17 	ldw	r2,124(r2)
 823528c:	10c00044 	addi	r3,r2,1
 8235290:	008209b4 	movhi	r2,2086
 8235294:	10b82204 	addi	r2,r2,-8056
 8235298:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 823529c:	008209b4 	movhi	r2,2086
 82352a0:	10b82204 	addi	r2,r2,-8056
 82352a4:	10c02017 	ldw	r3,128(r2)
 82352a8:	e0bffe17 	ldw	r2,-8(fp)
 82352ac:	1080028b 	ldhu	r2,10(r2)
 82352b0:	10bfffcc 	andi	r2,r2,65535
 82352b4:	1887883a 	add	r3,r3,r2
 82352b8:	008209b4 	movhi	r2,2086
 82352bc:	10b82204 	addi	r2,r2,-8056
 82352c0:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 82352c4:	008025c4 	movi	r2,151
 82352c8:	d0a0b215 	stw	r2,-32056(gp)
 82352cc:	0001883a 	nop
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
      sorwakeup(so);
   return (flags);
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 82352d0:	e13fff17 	ldw	r4,-4(fp)
 82352d4:	822e26c0 	call	822e26c <m_freem>
   return (0);
 82352d8:	0005883a 	mov	r2,zero
 82352dc:	0000b006 	br	82355a0 <tcp_reass+0x3fc>
         {
            tcpstat.tcps_rcvduppack++;
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
            GOTO_DROP;
         }
         m_adj (ti_mbuf, (int)i);
 82352e0:	e17ff917 	ldw	r5,-28(fp)
 82352e4:	e13fff17 	ldw	r4,-4(fp)
 82352e8:	822e5a40 	call	822e5a4 <m_adj>
         ti->ti_len -= (short)i;
 82352ec:	e0bffe17 	ldw	r2,-8(fp)
 82352f0:	1080028b 	ldhu	r2,10(r2)
 82352f4:	e0fff917 	ldw	r3,-28(fp)
 82352f8:	10c5c83a 	sub	r2,r2,r3
 82352fc:	1007883a 	mov	r3,r2
 8235300:	e0bffe17 	ldw	r2,-8(fp)
 8235304:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 8235308:	e0bffe17 	ldw	r2,-8(fp)
 823530c:	10c00617 	ldw	r3,24(r2)
 8235310:	e0bff917 	ldw	r2,-28(fp)
 8235314:	1887883a 	add	r3,r3,r2
 8235318:	e0bffe17 	ldw	r2,-8(fp)
 823531c:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 8235320:	e0bff717 	ldw	r2,-36(fp)
 8235324:	10800017 	ldw	r2,0(r2)
 8235328:	e0bff715 	stw	r2,-36(fp)
   }
   tcpstat.tcps_rcvoopack++;
 823532c:	008209b4 	movhi	r2,2086
 8235330:	10b82204 	addi	r2,r2,-8056
 8235334:	10802317 	ldw	r2,140(r2)
 8235338:	10c00044 	addi	r3,r2,1
 823533c:	008209b4 	movhi	r2,2086
 8235340:	10b82204 	addi	r2,r2,-8056
 8235344:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 8235348:	008209b4 	movhi	r2,2086
 823534c:	10b82204 	addi	r2,r2,-8056
 8235350:	10c02417 	ldw	r3,144(r2)
 8235354:	e0bffe17 	ldw	r2,-8(fp)
 8235358:	1080028b 	ldhu	r2,10(r2)
 823535c:	10bfffcc 	andi	r2,r2,65535
 8235360:	1887883a 	add	r3,r3,r2
 8235364:	008209b4 	movhi	r2,2086
 8235368:	10b82204 	addi	r2,r2,-8056
 823536c:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235370:	00003206 	br	823543c <tcp_reass+0x298>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 8235374:	e0bffe17 	ldw	r2,-8(fp)
 8235378:	10c00617 	ldw	r3,24(r2)
 823537c:	e0bffe17 	ldw	r2,-8(fp)
 8235380:	1080028b 	ldhu	r2,10(r2)
 8235384:	10bfffcc 	andi	r2,r2,65535
 8235388:	1887883a 	add	r3,r3,r2
 823538c:	e0bff717 	ldw	r2,-36(fp)
 8235390:	10800617 	ldw	r2,24(r2)
 8235394:	1885c83a 	sub	r2,r3,r2
 8235398:	e0bffa15 	stw	r2,-24(fp)
      if (i <= 0)
 823539c:	e0bffa17 	ldw	r2,-24(fp)
 82353a0:	00802a0e 	bge	zero,r2,823544c <tcp_reass+0x2a8>
         break;
      if (i < (int)(q->ti_len))
 82353a4:	e0bff717 	ldw	r2,-36(fp)
 82353a8:	1080028b 	ldhu	r2,10(r2)
 82353ac:	10bfffcc 	andi	r2,r2,65535
 82353b0:	e0fffa17 	ldw	r3,-24(fp)
 82353b4:	1880130e 	bge	r3,r2,8235404 <tcp_reass+0x260>
      {
         q->ti_seq += i;
 82353b8:	e0bff717 	ldw	r2,-36(fp)
 82353bc:	10c00617 	ldw	r3,24(r2)
 82353c0:	e0bffa17 	ldw	r2,-24(fp)
 82353c4:	1887883a 	add	r3,r3,r2
 82353c8:	e0bff717 	ldw	r2,-36(fp)
 82353cc:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 82353d0:	e0bff717 	ldw	r2,-36(fp)
 82353d4:	1080028b 	ldhu	r2,10(r2)
 82353d8:	e0fffa17 	ldw	r3,-24(fp)
 82353dc:	10c5c83a 	sub	r2,r2,r3
 82353e0:	1007883a 	mov	r3,r2
 82353e4:	e0bff717 	ldw	r2,-36(fp)
 82353e8:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 82353ec:	e13ff717 	ldw	r4,-36(fp)
 82353f0:	822e7b80 	call	822e7b8 <dtom>
 82353f4:	e17ffa17 	ldw	r5,-24(fp)
 82353f8:	1009883a 	mov	r4,r2
 82353fc:	822e5a40 	call	822e5a4 <m_adj>
         break;
 8235400:	00001306 	br	8235450 <tcp_reass+0x2ac>
      }
      q = (struct tcpiphdr *)q->ti_next;
 8235404:	e0bff717 	ldw	r2,-36(fp)
 8235408:	10800017 	ldw	r2,0(r2)
 823540c:	e0bff715 	stw	r2,-36(fp)
      m = dtom(q->ti_prev);
 8235410:	e0bff717 	ldw	r2,-36(fp)
 8235414:	10800117 	ldw	r2,4(r2)
 8235418:	1009883a 	mov	r4,r2
 823541c:	822e7b80 	call	822e7b8 <dtom>
 8235420:	e0bffb15 	stw	r2,-20(fp)
      remque (q->ti_prev);
 8235424:	e0bff717 	ldw	r2,-36(fp)
 8235428:	10800117 	ldw	r2,4(r2)
 823542c:	1009883a 	mov	r4,r2
 8235430:	822e8540 	call	822e854 <remque>
      m_freem (m);
 8235434:	e13ffb17 	ldw	r4,-20(fp)
 8235438:	822e26c0 	call	822e26c <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 823543c:	e0fff717 	ldw	r3,-36(fp)
 8235440:	e0bffd17 	ldw	r2,-12(fp)
 8235444:	18bfcb1e 	bne	r3,r2,8235374 <tcp_reass+0x1d0>
 8235448:	00000106 	br	8235450 <tcp_reass+0x2ac>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
      if (i <= 0)
         break;
 823544c:	0001883a 	nop
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 8235450:	e0bff717 	ldw	r2,-36(fp)
 8235454:	10800117 	ldw	r2,4(r2)
 8235458:	100b883a 	mov	r5,r2
 823545c:	e13ffe17 	ldw	r4,-8(fp)
 8235460:	822e8c40 	call	822e8c4 <insque>
 8235464:	00000106 	br	823546c <tcp_reass+0x2c8>
   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
      goto present;
 8235468:	0001883a 	nop
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 823546c:	e0bffd17 	ldw	r2,-12(fp)
 8235470:	10800217 	ldw	r2,8(r2)
 8235474:	108000c8 	cmpgei	r2,r2,3
 8235478:	1000021e 	bne	r2,zero,8235484 <tcp_reass+0x2e0>
      return (0);
 823547c:	0005883a 	mov	r2,zero
 8235480:	00004706 	br	82355a0 <tcp_reass+0x3fc>
   ti = tp->seg_next;
 8235484:	e0bffd17 	ldw	r2,-12(fp)
 8235488:	10800017 	ldw	r2,0(r2)
 823548c:	e0bffe15 	stw	r2,-8(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 8235490:	e0fffe17 	ldw	r3,-8(fp)
 8235494:	e0bffd17 	ldw	r2,-12(fp)
 8235498:	18800526 	beq	r3,r2,82354b0 <tcp_reass+0x30c>
 823549c:	e0bffe17 	ldw	r2,-8(fp)
 82354a0:	10c00617 	ldw	r3,24(r2)
 82354a4:	e0bffd17 	ldw	r2,-12(fp)
 82354a8:	10801617 	ldw	r2,88(r2)
 82354ac:	18800226 	beq	r3,r2,82354b8 <tcp_reass+0x314>
      return (0);
 82354b0:	0005883a 	mov	r2,zero
 82354b4:	00003a06 	br	82355a0 <tcp_reass+0x3fc>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 82354b8:	e0bffd17 	ldw	r2,-12(fp)
 82354bc:	10800217 	ldw	r2,8(r2)
 82354c0:	108000d8 	cmpnei	r2,r2,3
 82354c4:	1000061e 	bne	r2,zero,82354e0 <tcp_reass+0x33c>
 82354c8:	e0bffe17 	ldw	r2,-8(fp)
 82354cc:	1080028b 	ldhu	r2,10(r2)
 82354d0:	10bfffcc 	andi	r2,r2,65535
 82354d4:	10000226 	beq	r2,zero,82354e0 <tcp_reass+0x33c>
      return (0);
 82354d8:	0005883a 	mov	r2,zero
 82354dc:	00003006 	br	82355a0 <tcp_reass+0x3fc>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 82354e0:	e0bffd17 	ldw	r2,-12(fp)
 82354e4:	10c01617 	ldw	r3,88(r2)
 82354e8:	e0bffe17 	ldw	r2,-8(fp)
 82354ec:	1080028b 	ldhu	r2,10(r2)
 82354f0:	10bfffcc 	andi	r2,r2,65535
 82354f4:	1887883a 	add	r3,r3,r2
 82354f8:	e0bffd17 	ldw	r2,-12(fp)
 82354fc:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 8235500:	e0bffe17 	ldw	r2,-8(fp)
 8235504:	10800843 	ldbu	r2,33(r2)
 8235508:	10803fcc 	andi	r2,r2,255
 823550c:	1080004c 	andi	r2,r2,1
 8235510:	e0bffc15 	stw	r2,-16(fp)
      remque(ti);
 8235514:	e13ffe17 	ldw	r4,-8(fp)
 8235518:	822e8540 	call	822e854 <remque>
      m = dtom(ti);
 823551c:	e13ffe17 	ldw	r4,-8(fp)
 8235520:	822e7b80 	call	822e7b8 <dtom>
 8235524:	e0bffb15 	stw	r2,-20(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 8235528:	e0bffe17 	ldw	r2,-8(fp)
 823552c:	10800017 	ldw	r2,0(r2)
 8235530:	e0bffe15 	stw	r2,-8(fp)
      if (so->so_state & SS_CANTRCVMORE)
 8235534:	e0bff817 	ldw	r2,-32(fp)
 8235538:	1080088b 	ldhu	r2,34(r2)
 823553c:	10bfffcc 	andi	r2,r2,65535
 8235540:	1080080c 	andi	r2,r2,32
 8235544:	10000326 	beq	r2,zero,8235554 <tcp_reass+0x3b0>
         m_freem (m);
 8235548:	e13ffb17 	ldw	r4,-20(fp)
 823554c:	822e26c0 	call	822e26c <m_freem>
 8235550:	00000506 	br	8235568 <tcp_reass+0x3c4>
      else
         sbappend (&so->so_rcv, m);
 8235554:	e0bff817 	ldw	r2,-32(fp)
 8235558:	10800a04 	addi	r2,r2,40
 823555c:	e17ffb17 	ldw	r5,-20(fp)
 8235560:	1009883a 	mov	r4,r2
 8235564:	82340280 	call	8234028 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 8235568:	e0fffe17 	ldw	r3,-8(fp)
 823556c:	e0bffd17 	ldw	r2,-12(fp)
 8235570:	18800526 	beq	r3,r2,8235588 <tcp_reass+0x3e4>
 8235574:	e0bffe17 	ldw	r2,-8(fp)
 8235578:	10c00617 	ldw	r3,24(r2)
 823557c:	e0bffd17 	ldw	r2,-12(fp)
 8235580:	10801617 	ldw	r2,88(r2)
 8235584:	18bfd626 	beq	r3,r2,82354e0 <tcp_reass+0x33c>
      sorwakeup(so);
 8235588:	e0bff817 	ldw	r2,-32(fp)
 823558c:	10800a04 	addi	r2,r2,40
 8235590:	100b883a 	mov	r5,r2
 8235594:	e13ff817 	ldw	r4,-32(fp)
 8235598:	8233e780 	call	8233e78 <sbwakeup>
   return (flags);
 823559c:	e0bffc17 	ldw	r2,-16(fp)
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
   return (0);
}
 82355a0:	e037883a 	mov	sp,fp
 82355a4:	dfc00117 	ldw	ra,4(sp)
 82355a8:	df000017 	ldw	fp,0(sp)
 82355ac:	dec00204 	addi	sp,sp,8
 82355b0:	f800283a 	ret

082355b4 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 82355b4:	deffdf04 	addi	sp,sp,-132
 82355b8:	dfc02015 	stw	ra,128(sp)
 82355bc:	df001f15 	stw	fp,124(sp)
 82355c0:	df001f04 	addi	fp,sp,124
 82355c4:	e13ffe15 	stw	r4,-8(fp)
 82355c8:	e17fff15 	stw	r5,-4(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 82355cc:	e03fe515 	stw	zero,-108(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 82355d0:	e03fe615 	stw	zero,-104(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 82355d4:	e03fe815 	stw	zero,-96(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 82355d8:	e03feb15 	stw	zero,-84(fp)
   int   dropsocket  =  0;
 82355dc:	e03fec15 	stw	zero,-80(fp)
   long  iss   =  0;
 82355e0:	e03fed15 	stw	zero,-76(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 82355e4:	008209b4 	movhi	r2,2086
 82355e8:	10b82204 	addi	r2,r2,-8056
 82355ec:	10801917 	ldw	r2,100(r2)
 82355f0:	10c00044 	addi	r3,r2,1
 82355f4:	008209b4 	movhi	r2,2086
 82355f8:	10b82204 	addi	r2,r2,-8056
 82355fc:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 8235600:	008209b4 	movhi	r2,2086
 8235604:	10b7f404 	addi	r2,r2,-8240
 8235608:	10800917 	ldw	r2,36(r2)
 823560c:	10c00044 	addi	r3,r2,1
 8235610:	008209b4 	movhi	r2,2086
 8235614:	10b7f404 	addi	r2,r2,-8240
 8235618:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 823561c:	e0bffe17 	ldw	r2,-8(fp)
 8235620:	10800317 	ldw	r2,12(r2)
 8235624:	e0bfe315 	stw	r2,-116(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 8235628:	e0bfe317 	ldw	r2,-116(fp)
 823562c:	10800003 	ldbu	r2,0(r2)
 8235630:	10803fcc 	andi	r2,r2,255
 8235634:	108011b0 	cmpltui	r2,r2,70
 8235638:	1000061e 	bne	r2,zero,8235654 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 823563c:	e17ffe17 	ldw	r5,-8(fp)
 8235640:	e13fe317 	ldw	r4,-116(fp)
 8235644:	822f1f00 	call	822f1f0 <np_stripoptions>
         pip = mtod(m, struct ip *);
 8235648:	e0bffe17 	ldw	r2,-8(fp)
 823564c:	10800317 	ldw	r2,12(r2)
 8235650:	e0bfe315 	stw	r2,-116(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 8235654:	e0bffe17 	ldw	r2,-8(fp)
 8235658:	10800217 	ldw	r2,8(r2)
 823565c:	10800a28 	cmpgeui	r2,r2,40
 8235660:	1000081e 	bne	r2,zero,8235684 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 8235664:	008209b4 	movhi	r2,2086
 8235668:	10b82204 	addi	r2,r2,-8056
 823566c:	10801e17 	ldw	r2,120(r2)
 8235670:	10c00044 	addi	r3,r2,1
 8235674:	008209b4 	movhi	r2,2086
 8235678:	10b82204 	addi	r2,r2,-8056
 823567c:	10c01e15 	stw	r3,120(r2)
         return;
 8235680:	00089306 	br	82378d0 <tcp_input+0x231c>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 8235684:	e0bfe317 	ldw	r2,-116(fp)
 8235688:	1080008b 	ldhu	r2,2(r2)
 823568c:	10bfffcc 	andi	r2,r2,65535
 8235690:	e0bff115 	stw	r2,-60(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 8235694:	e0bffe17 	ldw	r2,-8(fp)
 8235698:	10800317 	ldw	r2,12(r2)
 823569c:	e0bff215 	stw	r2,-56(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 82356a0:	e0bffe17 	ldw	r2,-8(fp)
 82356a4:	10800117 	ldw	r2,4(r2)
 82356a8:	10800117 	ldw	r2,4(r2)
 82356ac:	e0fff217 	ldw	r3,-56(fp)
 82356b0:	1880032e 	bgeu	r3,r2,82356c0 <tcp_input+0x10c>
      {
         panic("tcp_input");
 82356b4:	01020974 	movhi	r4,2085
 82356b8:	21023104 	addi	r4,r4,2244
 82356bc:	822887c0 	call	822887c <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 82356c0:	e0bff217 	ldw	r2,-56(fp)
 82356c4:	10800803 	ldbu	r2,32(r2)
 82356c8:	10803fcc 	andi	r2,r2,255
 82356cc:	1004d13a 	srli	r2,r2,4
 82356d0:	10803fcc 	andi	r2,r2,255
 82356d4:	1085883a 	add	r2,r2,r2
 82356d8:	1085883a 	add	r2,r2,r2
 82356dc:	e0bff315 	stw	r2,-52(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 82356e0:	e0bff317 	ldw	r2,-52(fp)
 82356e4:	10800530 	cmpltui	r2,r2,20
 82356e8:	1000031e 	bne	r2,zero,82356f8 <tcp_input+0x144>
 82356ec:	e0bff317 	ldw	r2,-52(fp)
 82356f0:	e0fff117 	ldw	r3,-60(fp)
 82356f4:	1880110e 	bge	r3,r2,823573c <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 82356f8:	008209b4 	movhi	r2,2086
 82356fc:	10b82204 	addi	r2,r2,-8056
 8235700:	10801d17 	ldw	r2,116(r2)
 8235704:	10c00044 	addi	r3,r2,1
 8235708:	008209b4 	movhi	r2,2086
 823570c:	10b82204 	addi	r2,r2,-8056
 8235710:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 8235714:	008209b4 	movhi	r2,2086
 8235718:	10b7f404 	addi	r2,r2,-8240
 823571c:	10800d17 	ldw	r2,52(r2)
 8235720:	10c00044 	addi	r3,r2,1
 8235724:	008209b4 	movhi	r2,2086
 8235728:	10b7f404 	addi	r2,r2,-8240
 823572c:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 8235730:	00805784 	movi	r2,350
 8235734:	d0a0b215 	stw	r2,-32056(gp)
 8235738:	00085006 	br	823787c <tcp_input+0x22c8>
   }
   tlen -= (int)off;
 823573c:	e0fff117 	ldw	r3,-60(fp)
 8235740:	e0bff317 	ldw	r2,-52(fp)
 8235744:	1885c83a 	sub	r2,r3,r2
 8235748:	e0bff115 	stw	r2,-60(fp)
   ti->ti_len = (u_short)tlen;
 823574c:	e0bff117 	ldw	r2,-60(fp)
 8235750:	1007883a 	mov	r3,r2
 8235754:	e0bff217 	ldw	r2,-56(fp)
 8235758:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 823575c:	e0bff317 	ldw	r2,-52(fp)
 8235760:	10800570 	cmpltui	r2,r2,21
 8235764:	1000331e 	bne	r2,zero,8235834 <tcp_input+0x280>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 8235768:	e0bff317 	ldw	r2,-52(fp)
 823576c:	10bffb04 	addi	r2,r2,-20
 8235770:	e0bff415 	stw	r2,-48(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 8235774:	e17ff417 	ldw	r5,-48(fp)
 8235778:	01000044 	movi	r4,1
 823577c:	822dfdc0 	call	822dfdc <m_getnbuf>
 8235780:	e0bfe515 	stw	r2,-108(fp)
      if (om == 0)
 8235784:	e0bfe517 	ldw	r2,-108(fp)
 8235788:	1000031e 	bne	r2,zero,8235798 <tcp_input+0x1e4>
         GOTO_DROP;
 823578c:	00805a84 	movi	r2,362
 8235790:	d0a0b215 	stw	r2,-32056(gp)
 8235794:	00083906 	br	823787c <tcp_input+0x22c8>
      om->m_len = olen;       /* set mbuf length */
 8235798:	e0fff417 	ldw	r3,-48(fp)
 823579c:	e0bfe517 	ldw	r2,-108(fp)
 82357a0:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 82357a4:	e0bffe17 	ldw	r2,-8(fp)
 82357a8:	10800117 	ldw	r2,4(r2)
 82357ac:	1080080b 	ldhu	r2,32(r2)
 82357b0:	10ffffcc 	andi	r3,r2,65535
 82357b4:	00b76194 	movui	r2,56710
 82357b8:	1880051e 	bne	r3,r2,82357d0 <tcp_input+0x21c>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 82357bc:	e0bffe17 	ldw	r2,-8(fp)
 82357c0:	10800317 	ldw	r2,12(r2)
 82357c4:	10800504 	addi	r2,r2,20
 82357c8:	e0bfee15 	stw	r2,-72(fp)
 82357cc:	00000406 	br	82357e0 <tcp_input+0x22c>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 82357d0:	e0bffe17 	ldw	r2,-8(fp)
 82357d4:	10800317 	ldw	r2,12(r2)
 82357d8:	10800a04 	addi	r2,r2,40
 82357dc:	e0bfee15 	stw	r2,-72(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 82357e0:	e0bfe517 	ldw	r2,-108(fp)
 82357e4:	10800317 	ldw	r2,12(r2)
 82357e8:	e0fff417 	ldw	r3,-48(fp)
 82357ec:	180d883a 	mov	r6,r3
 82357f0:	e17fee17 	ldw	r5,-72(fp)
 82357f4:	1009883a 	mov	r4,r2
 82357f8:	8202a0c0 	call	8202a0c <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 82357fc:	e0bffe17 	ldw	r2,-8(fp)
 8235800:	10c00317 	ldw	r3,12(r2)
 8235804:	e0bfe517 	ldw	r2,-108(fp)
 8235808:	10800217 	ldw	r2,8(r2)
 823580c:	1887883a 	add	r3,r3,r2
 8235810:	e0bffe17 	ldw	r2,-8(fp)
 8235814:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 8235818:	e0bffe17 	ldw	r2,-8(fp)
 823581c:	10c00217 	ldw	r3,8(r2)
 8235820:	e0bfe517 	ldw	r2,-108(fp)
 8235824:	10800217 	ldw	r2,8(r2)
 8235828:	1887c83a 	sub	r3,r3,r2
 823582c:	e0bffe17 	ldw	r2,-8(fp)
 8235830:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 8235834:	e0bff217 	ldw	r2,-56(fp)
 8235838:	10800843 	ldbu	r2,33(r2)
 823583c:	10803fcc 	andi	r2,r2,255
 8235840:	e0bfe715 	stw	r2,-100(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 8235844:	e0bff217 	ldw	r2,-56(fp)
 8235848:	10800617 	ldw	r2,24(r2)
 823584c:	1006d63a 	srli	r3,r2,24
 8235850:	e0bff217 	ldw	r2,-56(fp)
 8235854:	10800617 	ldw	r2,24(r2)
 8235858:	1004d23a 	srli	r2,r2,8
 823585c:	10bfc00c 	andi	r2,r2,65280
 8235860:	1886b03a 	or	r3,r3,r2
 8235864:	e0bff217 	ldw	r2,-56(fp)
 8235868:	10800617 	ldw	r2,24(r2)
 823586c:	10bfc00c 	andi	r2,r2,65280
 8235870:	1004923a 	slli	r2,r2,8
 8235874:	1886b03a 	or	r3,r3,r2
 8235878:	e0bff217 	ldw	r2,-56(fp)
 823587c:	10800617 	ldw	r2,24(r2)
 8235880:	1004963a 	slli	r2,r2,24
 8235884:	1886b03a 	or	r3,r3,r2
 8235888:	e0bff217 	ldw	r2,-56(fp)
 823588c:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 8235890:	e0bff217 	ldw	r2,-56(fp)
 8235894:	10800717 	ldw	r2,28(r2)
 8235898:	1006d63a 	srli	r3,r2,24
 823589c:	e0bff217 	ldw	r2,-56(fp)
 82358a0:	10800717 	ldw	r2,28(r2)
 82358a4:	1004d23a 	srli	r2,r2,8
 82358a8:	10bfc00c 	andi	r2,r2,65280
 82358ac:	1886b03a 	or	r3,r3,r2
 82358b0:	e0bff217 	ldw	r2,-56(fp)
 82358b4:	10800717 	ldw	r2,28(r2)
 82358b8:	10bfc00c 	andi	r2,r2,65280
 82358bc:	1004923a 	slli	r2,r2,8
 82358c0:	1886b03a 	or	r3,r3,r2
 82358c4:	e0bff217 	ldw	r2,-56(fp)
 82358c8:	10800717 	ldw	r2,28(r2)
 82358cc:	1004963a 	slli	r2,r2,24
 82358d0:	1886b03a 	or	r3,r3,r2
 82358d4:	e0bff217 	ldw	r2,-56(fp)
 82358d8:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 82358dc:	e0bff217 	ldw	r2,-56(fp)
 82358e0:	1080098b 	ldhu	r2,38(r2)
 82358e4:	10bfffcc 	andi	r2,r2,65535
 82358e8:	1004d23a 	srli	r2,r2,8
 82358ec:	1007883a 	mov	r3,r2
 82358f0:	e0bff217 	ldw	r2,-56(fp)
 82358f4:	1080098b 	ldhu	r2,38(r2)
 82358f8:	10bfffcc 	andi	r2,r2,65535
 82358fc:	1004923a 	slli	r2,r2,8
 8235900:	1884b03a 	or	r2,r3,r2
 8235904:	1007883a 	mov	r3,r2
 8235908:	e0bff217 	ldw	r2,-56(fp)
 823590c:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 8235910:	e0bffe17 	ldw	r2,-8(fp)
 8235914:	10800117 	ldw	r2,4(r2)
 8235918:	1080080b 	ldhu	r2,32(r2)
 823591c:	10bfffcc 	andi	r2,r2,65535
 8235920:	10800220 	cmpeqi	r2,r2,8
 8235924:	10002226 	beq	r2,zero,82359b0 <tcp_input+0x3fc>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 8235928:	e0bffe17 	ldw	r2,-8(fp)
 823592c:	10800317 	ldw	r2,12(r2)
 8235930:	10c00a04 	addi	r3,r2,40
 8235934:	e0bffe17 	ldw	r2,-8(fp)
 8235938:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 823593c:	e0bffe17 	ldw	r2,-8(fp)
 8235940:	10800217 	ldw	r2,8(r2)
 8235944:	10fff604 	addi	r3,r2,-40
 8235948:	e0bffe17 	ldw	r2,-8(fp)
 823594c:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235950:	e0bff217 	ldw	r2,-56(fp)
 8235954:	11000317 	ldw	r4,12(r2)
 8235958:	e0bff217 	ldw	r2,-56(fp)
 823595c:	1080050b 	ldhu	r2,20(r2)
 8235960:	117fffcc 	andi	r5,r2,65535
 8235964:	e0bff217 	ldw	r2,-56(fp)
 8235968:	11800417 	ldw	r6,16(r2)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 823596c:	e0bff217 	ldw	r2,-56(fp)
 8235970:	1080058b 	ldhu	r2,22(r2)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235974:	10bfffcc 	andi	r2,r2,65535
 8235978:	00c00044 	movi	r3,1
 823597c:	d8c00115 	stw	r3,4(sp)
 8235980:	d8800015 	stw	r2,0(sp)
 8235984:	300f883a 	mov	r7,r6
 8235988:	280d883a 	mov	r6,r5
 823598c:	200b883a 	mov	r5,r4
 8235990:	010209b4 	movhi	r4,2086
 8235994:	21381704 	addi	r4,r4,-8100
 8235998:	82480c00 	call	82480c0 <in_pcblookup>
 823599c:	e0bfe415 	stw	r2,-112(fp)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
 82359a0:	0001883a 	nop
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 82359a4:	e0bfe417 	ldw	r2,-112(fp)
 82359a8:	1000061e 	bne	r2,zero,82359c4 <tcp_input+0x410>
 82359ac:	00000206 	br	82359b8 <tcp_input+0x404>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 82359b0:	822d1c80 	call	822d1c8 <dtrap>
      return;
 82359b4:	0007c606 	br	82378d0 <tcp_input+0x231c>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 82359b8:	00806b04 	movi	r2,428
 82359bc:	d0a0b215 	stw	r2,-32056(gp)
 82359c0:	00076d06 	br	8237778 <tcp_input+0x21c4>
   tp = intotcpcb (inp);
 82359c4:	e0bfe417 	ldw	r2,-112(fp)
 82359c8:	10800917 	ldw	r2,36(r2)
 82359cc:	e0bfe615 	stw	r2,-104(fp)
   if (tp == 0)
 82359d0:	e0bfe617 	ldw	r2,-104(fp)
 82359d4:	1000031e 	bne	r2,zero,82359e4 <tcp_input+0x430>
      GOTO_DROPWITHRESET;
 82359d8:	00806bc4 	movi	r2,431
 82359dc:	d0a0b215 	stw	r2,-32056(gp)
 82359e0:	00076506 	br	8237778 <tcp_input+0x21c4>
   if (tp->t_state == TCPS_CLOSED)
 82359e4:	e0bfe617 	ldw	r2,-104(fp)
 82359e8:	10800217 	ldw	r2,8(r2)
 82359ec:	1000031e 	bne	r2,zero,82359fc <tcp_input+0x448>
      GOTO_DROP;
 82359f0:	00806c44 	movi	r2,433
 82359f4:	d0a0b215 	stw	r2,-32056(gp)
 82359f8:	0007a006 	br	823787c <tcp_input+0x22c8>
   so = inp->inp_socket;
 82359fc:	e0bfe417 	ldw	r2,-112(fp)
 8235a00:	10800817 	ldw	r2,32(r2)
 8235a04:	e0bfe815 	stw	r2,-96(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 8235a08:	e0bff217 	ldw	r2,-56(fp)
 8235a0c:	1080088b 	ldhu	r2,34(r2)
 8235a10:	10bfffcc 	andi	r2,r2,65535
 8235a14:	1004d23a 	srli	r2,r2,8
 8235a18:	10bfffcc 	andi	r2,r2,65535
 8235a1c:	10c03fcc 	andi	r3,r2,255
 8235a20:	e0bff217 	ldw	r2,-56(fp)
 8235a24:	1080088b 	ldhu	r2,34(r2)
 8235a28:	10bfffcc 	andi	r2,r2,65535
 8235a2c:	1004923a 	slli	r2,r2,8
 8235a30:	10bfffcc 	andi	r2,r2,65535
 8235a34:	1884b03a 	or	r2,r3,r2
 8235a38:	e0bff515 	stw	r2,-44(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 8235a3c:	e0bfe817 	ldw	r2,-96(fp)
 8235a40:	10800417 	ldw	r2,16(r2)
 8235a44:	1080008c 	andi	r2,r2,2
 8235a48:	10002c26 	beq	r2,zero,8235afc <tcp_input+0x548>
   {
      so = sonewconn(so);
 8235a4c:	e13fe817 	ldw	r4,-96(fp)
 8235a50:	823396c0 	call	823396c <sonewconn>
 8235a54:	e0bfe815 	stw	r2,-96(fp)
      if (so == 0)
 8235a58:	e0bfe817 	ldw	r2,-96(fp)
 8235a5c:	1000031e 	bne	r2,zero,8235a6c <tcp_input+0x4b8>
         GOTO_DROP;
 8235a60:	00807344 	movi	r2,461
 8235a64:	d0a0b215 	stw	r2,-32056(gp)
 8235a68:	00078406 	br	823787c <tcp_input+0x22c8>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 8235a6c:	e0bfec17 	ldw	r2,-80(fp)
 8235a70:	10800044 	addi	r2,r2,1
 8235a74:	e0bfec15 	stw	r2,-80(fp)

      inp = (struct inpcb *)so->so_pcb;
 8235a78:	e0bfe817 	ldw	r2,-96(fp)
 8235a7c:	10800117 	ldw	r2,4(r2)
 8235a80:	e0bfe415 	stw	r2,-112(fp)
      inp->ifp = ifp;      /* save iface to peer */
 8235a84:	e0bfe417 	ldw	r2,-112(fp)
 8235a88:	e0ffff17 	ldw	r3,-4(fp)
 8235a8c:	10c00a15 	stw	r3,40(r2)

      switch(so->so_domain)
 8235a90:	e0bfe817 	ldw	r2,-96(fp)
 8235a94:	10800517 	ldw	r2,20(r2)
 8235a98:	108000a0 	cmpeqi	r2,r2,2
 8235a9c:	10000d26 	beq	r2,zero,8235ad4 <tcp_input+0x520>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 8235aa0:	e0bfe417 	ldw	r2,-112(fp)
 8235aa4:	e0fff217 	ldw	r3,-56(fp)
 8235aa8:	18c00417 	ldw	r3,16(r3)
 8235aac:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8235ab0:	e0bfff17 	ldw	r2,-4(fp)
 8235ab4:	10c00917 	ldw	r3,36(r2)
 8235ab8:	e0bfff17 	ldw	r2,-4(fp)
 8235abc:	10800817 	ldw	r2,32(r2)
 8235ac0:	10800a04 	addi	r2,r2,40
 8235ac4:	1887c83a 	sub	r3,r3,r2
 8235ac8:	e0bfe417 	ldw	r2,-112(fp)
 8235acc:	10c00615 	stw	r3,24(r2)
#endif   /* IP_PMTU */
         break;
 8235ad0:	0001883a 	nop
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 8235ad4:	e0bff217 	ldw	r2,-56(fp)
 8235ad8:	10c0058b 	ldhu	r3,22(r2)
 8235adc:	e0bfe417 	ldw	r2,-112(fp)
 8235ae0:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 8235ae4:	e0bfe417 	ldw	r2,-112(fp)
 8235ae8:	10800917 	ldw	r2,36(r2)
 8235aec:	e0bfe615 	stw	r2,-104(fp)
      tp->t_state = TCPS_LISTEN;
 8235af0:	e0bfe617 	ldw	r2,-104(fp)
 8235af4:	00c00044 	movi	r3,1
 8235af8:	10c00215 	stw	r3,8(r2)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 8235afc:	e0bfe617 	ldw	r2,-104(fp)
 8235b00:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 8235b04:	d0e03e17 	ldw	r3,-32520(gp)
 8235b08:	e0bfe617 	ldw	r2,-104(fp)
 8235b0c:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 8235b10:	e0bfe517 	ldw	r2,-108(fp)
 8235b14:	10000926 	beq	r2,zero,8235b3c <tcp_input+0x588>
 8235b18:	e0bfe617 	ldw	r2,-104(fp)
 8235b1c:	10800217 	ldw	r2,8(r2)
 8235b20:	10800060 	cmpeqi	r2,r2,1
 8235b24:	1000051e 	bne	r2,zero,8235b3c <tcp_input+0x588>
   {
      tcp_dooptions(tp, om, ti);
 8235b28:	e1bff217 	ldw	r6,-56(fp)
 8235b2c:	e17fe517 	ldw	r5,-108(fp)
 8235b30:	e13fe617 	ldw	r4,-104(fp)
 8235b34:	82378e40 	call	82378e4 <tcp_dooptions>
      om = 0;
 8235b38:	e03fe515 	stw	zero,-108(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 8235b3c:	e0bff217 	ldw	r2,-56(fp)
 8235b40:	10c00717 	ldw	r3,28(r2)
 8235b44:	e0bfe617 	ldw	r2,-104(fp)
 8235b48:	10800e17 	ldw	r2,56(r2)
 8235b4c:	1885c83a 	sub	r2,r3,r2
 8235b50:	e0bff615 	stw	r2,-40(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 8235b54:	e0bfe817 	ldw	r2,-96(fp)
 8235b58:	10800b17 	ldw	r2,44(r2)
 8235b5c:	1007883a 	mov	r3,r2
 8235b60:	e0bfe817 	ldw	r2,-96(fp)
 8235b64:	10800a17 	ldw	r2,40(r2)
 8235b68:	1885c83a 	sub	r2,r3,r2
 8235b6c:	10000616 	blt	r2,zero,8235b88 <tcp_input+0x5d4>
 8235b70:	e0bfe817 	ldw	r2,-96(fp)
 8235b74:	10c00b17 	ldw	r3,44(r2)
 8235b78:	e0bfe817 	ldw	r2,-96(fp)
 8235b7c:	10800a17 	ldw	r2,40(r2)
 8235b80:	1885c83a 	sub	r2,r3,r2
 8235b84:	00000106 	br	8235b8c <tcp_input+0x5d8>
 8235b88:	0005883a 	mov	r2,zero
 8235b8c:	e0bfef15 	stw	r2,-68(fp)
      if (win < 0)
 8235b90:	e0bfef17 	ldw	r2,-68(fp)
 8235b94:	1000010e 	bge	r2,zero,8235b9c <tcp_input+0x5e8>
         win = 0;
 8235b98:	e03fef15 	stw	zero,-68(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 8235b9c:	e0bfe617 	ldw	r2,-104(fp)
 8235ba0:	10c01917 	ldw	r3,100(r2)
 8235ba4:	e0bfe617 	ldw	r2,-104(fp)
 8235ba8:	10801617 	ldw	r2,88(r2)
 8235bac:	1885c83a 	sub	r2,r3,r2
 8235bb0:	e0ffef17 	ldw	r3,-68(fp)
 8235bb4:	10c0012e 	bgeu	r2,r3,8235bbc <tcp_input+0x608>
 8235bb8:	1805883a 	mov	r2,r3
 8235bbc:	e0ffe617 	ldw	r3,-104(fp)
 8235bc0:	18801515 	stw	r2,84(r3)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235bc4:	e0bfe617 	ldw	r2,-104(fp)
 8235bc8:	10800217 	ldw	r2,8(r2)
 8235bcc:	10800118 	cmpnei	r2,r2,4
 8235bd0:	1001021e 	bne	r2,zero,8235fdc <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235bd4:	e0bfe717 	ldw	r2,-100(fp)
 8235bd8:	10800dcc 	andi	r2,r2,55
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235bdc:	10800418 	cmpnei	r2,r2,16
 8235be0:	1000fe1e 	bne	r2,zero,8235fdc <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
 8235be4:	e0bff217 	ldw	r2,-56(fp)
 8235be8:	10c00617 	ldw	r3,24(r2)
 8235bec:	e0bfe617 	ldw	r2,-104(fp)
 8235bf0:	10801617 	ldw	r2,88(r2)
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235bf4:	1880f91e 	bne	r3,r2,8235fdc <tcp_input+0xa28>
       (ti->ti_seq == tp->rcv_nxt) &&
 8235bf8:	e0bff517 	ldw	r2,-44(fp)
 8235bfc:	1000f726 	beq	r2,zero,8235fdc <tcp_input+0xa28>
       (rx_win && rx_win == tp->snd_wnd) &&
 8235c00:	e0bfe617 	ldw	r2,-104(fp)
 8235c04:	10c01417 	ldw	r3,80(r2)
 8235c08:	e0bff517 	ldw	r2,-44(fp)
 8235c0c:	1880f31e 	bne	r3,r2,8235fdc <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
 8235c10:	e0bfe617 	ldw	r2,-104(fp)
 8235c14:	10c00f17 	ldw	r3,60(r2)
 8235c18:	e0bfe617 	ldw	r2,-104(fp)
 8235c1c:	10801a17 	ldw	r2,104(r2)
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
 8235c20:	1880ee1e 	bne	r3,r2,8235fdc <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 8235c24:	e0bff217 	ldw	r2,-56(fp)
 8235c28:	1080028b 	ldhu	r2,10(r2)
 8235c2c:	10bfffcc 	andi	r2,r2,65535
 8235c30:	1000611e 	bne	r2,zero,8235db8 <tcp_input+0x804>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8235c34:	e0bff217 	ldw	r2,-56(fp)
 8235c38:	10c00717 	ldw	r3,28(r2)
 8235c3c:	e0bfe617 	ldw	r2,-104(fp)
 8235c40:	10800e17 	ldw	r2,56(r2)
 8235c44:	1885c83a 	sub	r2,r3,r2
 8235c48:	0080e40e 	bge	zero,r2,8235fdc <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8235c4c:	e0bff217 	ldw	r2,-56(fp)
 8235c50:	10c00717 	ldw	r3,28(r2)
 8235c54:	e0bfe617 	ldw	r2,-104(fp)
 8235c58:	10801a17 	ldw	r2,104(r2)
 8235c5c:	1885c83a 	sub	r2,r3,r2
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8235c60:	0080de16 	blt	zero,r2,8235fdc <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
             tp->snd_cwnd >= tp->snd_wnd) 
 8235c64:	e0bfe617 	ldw	r2,-104(fp)
 8235c68:	10c01b17 	ldw	r3,108(r2)
 8235c6c:	e0bfe617 	ldw	r2,-104(fp)
 8235c70:	10801417 	ldw	r2,80(r2)
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8235c74:	1880d936 	bltu	r3,r2,8235fdc <tcp_input+0xa28>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 8235c78:	008209b4 	movhi	r2,2086
 8235c7c:	10b82204 	addi	r2,r2,-8056
 8235c80:	10803517 	ldw	r2,212(r2)
 8235c84:	10c00044 	addi	r3,r2,1
 8235c88:	008209b4 	movhi	r2,2086
 8235c8c:	10b82204 	addi	r2,r2,-8056
 8235c90:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 8235c94:	e0bfe617 	ldw	r2,-104(fp)
 8235c98:	10801e17 	ldw	r2,120(r2)
 8235c9c:	10000826 	beq	r2,zero,8235cc0 <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8235ca0:	e0bff217 	ldw	r2,-56(fp)
 8235ca4:	10c00717 	ldw	r3,28(r2)
 8235ca8:	e0bfe617 	ldw	r2,-104(fp)
 8235cac:	10801f17 	ldw	r2,124(r2)
 8235cb0:	1885c83a 	sub	r2,r3,r2
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
            if (tp->t_rttick && 
 8235cb4:	0080020e 	bge	zero,r2,8235cc0 <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 8235cb8:	e13fe617 	ldw	r4,-104(fp)
 8235cbc:	8237b980 	call	8237b98 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 8235cc0:	008209b4 	movhi	r2,2086
 8235cc4:	10b82204 	addi	r2,r2,-8056
 8235cc8:	10802b17 	ldw	r2,172(r2)
 8235ccc:	10c00044 	addi	r3,r2,1
 8235cd0:	008209b4 	movhi	r2,2086
 8235cd4:	10b82204 	addi	r2,r2,-8056
 8235cd8:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 8235cdc:	008209b4 	movhi	r2,2086
 8235ce0:	10b82204 	addi	r2,r2,-8056
 8235ce4:	10c02c17 	ldw	r3,176(r2)
 8235ce8:	e0bff617 	ldw	r2,-40(fp)
 8235cec:	1887883a 	add	r3,r3,r2
 8235cf0:	008209b4 	movhi	r2,2086
 8235cf4:	10b82204 	addi	r2,r2,-8056
 8235cf8:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 8235cfc:	e0bfe817 	ldw	r2,-96(fp)
 8235d00:	10801204 	addi	r2,r2,72
 8235d04:	e17ff617 	ldw	r5,-40(fp)
 8235d08:	1009883a 	mov	r4,r2
 8235d0c:	82345e00 	call	82345e0 <sbdrop>
            tp->snd_una = ti->ti_ack;
 8235d10:	e0bff217 	ldw	r2,-56(fp)
 8235d14:	10c00717 	ldw	r3,28(r2)
 8235d18:	e0bfe617 	ldw	r2,-104(fp)
 8235d1c:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 8235d20:	e13ffe17 	ldw	r4,-8(fp)
 8235d24:	822e26c0 	call	822e26c <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 8235d28:	e0bfe617 	ldw	r2,-104(fp)
 8235d2c:	10c00e17 	ldw	r3,56(r2)
 8235d30:	e0bfe617 	ldw	r2,-104(fp)
 8235d34:	10801a17 	ldw	r2,104(r2)
 8235d38:	1880031e 	bne	r3,r2,8235d48 <tcp_input+0x794>
               tp->t_timer[TCPT_REXMT] = 0;
 8235d3c:	e0bfe617 	ldw	r2,-104(fp)
 8235d40:	10000315 	stw	zero,12(r2)
 8235d44:	00000706 	br	8235d64 <tcp_input+0x7b0>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 8235d48:	e0bfe617 	ldw	r2,-104(fp)
 8235d4c:	10800417 	ldw	r2,16(r2)
 8235d50:	1000041e 	bne	r2,zero,8235d64 <tcp_input+0x7b0>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8235d54:	e0bfe617 	ldw	r2,-104(fp)
 8235d58:	10c00817 	ldw	r3,32(r2)
 8235d5c:	e0bfe617 	ldw	r2,-104(fp)
 8235d60:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8235d64:	e0bfe817 	ldw	r2,-96(fp)
 8235d68:	1080190b 	ldhu	r2,100(r2)
 8235d6c:	10bfffcc 	andi	r2,r2,65535
 8235d70:	1080030c 	andi	r2,r2,12
 8235d74:	10000526 	beq	r2,zero,8235d8c <tcp_input+0x7d8>
               sowwakeup(so);
 8235d78:	e0bfe817 	ldw	r2,-96(fp)
 8235d7c:	10801204 	addi	r2,r2,72
 8235d80:	100b883a 	mov	r5,r2
 8235d84:	e13fe817 	ldw	r4,-96(fp)
 8235d88:	8233e780 	call	8233e78 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 8235d8c:	e0bfe817 	ldw	r2,-96(fp)
 8235d90:	10801217 	ldw	r2,72(r2)
 8235d94:	e0ffe617 	ldw	r3,-104(fp)
 8235d98:	19000f17 	ldw	r4,60(r3)
 8235d9c:	e0ffe617 	ldw	r3,-104(fp)
 8235da0:	18c00e17 	ldw	r3,56(r3)
 8235da4:	20c7c83a 	sub	r3,r4,r3
 8235da8:	1886c02e 	bgeu	r3,r2,82378ac <tcp_input+0x22f8>
               (void) tcp_output(tp);
 8235dac:	e13fe617 	ldw	r4,-104(fp)
 8235db0:	8237f340 	call	8237f34 <tcp_output>
            return;
 8235db4:	0006bd06 	br	82378ac <tcp_input+0x22f8>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8235db8:	e0bff217 	ldw	r2,-56(fp)
 8235dbc:	10c00717 	ldw	r3,28(r2)
 8235dc0:	e0bfe617 	ldw	r2,-104(fp)
 8235dc4:	10800e17 	ldw	r2,56(r2)
 8235dc8:	1880841e 	bne	r3,r2,8235fdc <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
 8235dcc:	e0bfe617 	ldw	r2,-104(fp)
 8235dd0:	10c00017 	ldw	r3,0(r2)
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8235dd4:	e0bfe617 	ldw	r2,-104(fp)
 8235dd8:	1880801e 	bne	r3,r2,8235fdc <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
          ti->ti_len <= sbspace(&so->so_rcv))
 8235ddc:	e0bff217 	ldw	r2,-56(fp)
 8235de0:	1080028b 	ldhu	r2,10(r2)
 8235de4:	10ffffcc 	andi	r3,r2,65535
 8235de8:	e0bfe817 	ldw	r2,-96(fp)
 8235dec:	10800b17 	ldw	r2,44(r2)
 8235df0:	1009883a 	mov	r4,r2
 8235df4:	e0bfe817 	ldw	r2,-96(fp)
 8235df8:	10800a17 	ldw	r2,40(r2)
 8235dfc:	2085c83a 	sub	r2,r4,r2
 8235e00:	10000616 	blt	r2,zero,8235e1c <tcp_input+0x868>
 8235e04:	e0bfe817 	ldw	r2,-96(fp)
 8235e08:	11000b17 	ldw	r4,44(r2)
 8235e0c:	e0bfe817 	ldw	r2,-96(fp)
 8235e10:	10800a17 	ldw	r2,40(r2)
 8235e14:	2085c83a 	sub	r2,r4,r2
 8235e18:	00000106 	br	8235e20 <tcp_input+0x86c>
 8235e1c:	0005883a 	mov	r2,zero
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
          tp->seg_next == (struct tcpiphdr *)tp &&
 8235e20:	10c06e36 	bltu	r2,r3,8235fdc <tcp_input+0xa28>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 8235e24:	e0bfe617 	ldw	r2,-104(fp)
 8235e28:	10801517 	ldw	r2,84(r2)
 8235e2c:	10000c1e 	bne	r2,zero,8235e60 <tcp_input+0x8ac>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 8235e30:	008209b4 	movhi	r2,2086
 8235e34:	10b82204 	addi	r2,r2,-8056
 8235e38:	10802817 	ldw	r2,160(r2)
 8235e3c:	10c00044 	addi	r3,r2,1
 8235e40:	008209b4 	movhi	r2,2086
 8235e44:	10b82204 	addi	r2,r2,-8056
 8235e48:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 8235e4c:	e13ffe17 	ldw	r4,-8(fp)
 8235e50:	822e26c0 	call	822e26c <m_freem>
            tcp_output(tp);   /* send the ack now... */
 8235e54:	e13fe617 	ldw	r4,-104(fp)
 8235e58:	8237f340 	call	8237f34 <tcp_output>
            return;
 8235e5c:	00069c06 	br	82378d0 <tcp_input+0x231c>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 8235e60:	008209b4 	movhi	r2,2086
 8235e64:	10b82204 	addi	r2,r2,-8056
 8235e68:	10803617 	ldw	r2,216(r2)
 8235e6c:	10c00044 	addi	r3,r2,1
 8235e70:	008209b4 	movhi	r2,2086
 8235e74:	10b82204 	addi	r2,r2,-8056
 8235e78:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 8235e7c:	e0bfe617 	ldw	r2,-104(fp)
 8235e80:	10c01617 	ldw	r3,88(r2)
 8235e84:	e0bff217 	ldw	r2,-56(fp)
 8235e88:	1080028b 	ldhu	r2,10(r2)
 8235e8c:	10bfffcc 	andi	r2,r2,65535
 8235e90:	1887883a 	add	r3,r3,r2
 8235e94:	e0bfe617 	ldw	r2,-104(fp)
 8235e98:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 8235e9c:	008209b4 	movhi	r2,2086
 8235ea0:	10b82204 	addi	r2,r2,-8056
 8235ea4:	10801a17 	ldw	r2,104(r2)
 8235ea8:	10c00044 	addi	r3,r2,1
 8235eac:	008209b4 	movhi	r2,2086
 8235eb0:	10b82204 	addi	r2,r2,-8056
 8235eb4:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8235eb8:	008209b4 	movhi	r2,2086
 8235ebc:	10b82204 	addi	r2,r2,-8056
 8235ec0:	10c01b17 	ldw	r3,108(r2)
 8235ec4:	e0bff217 	ldw	r2,-56(fp)
 8235ec8:	1080028b 	ldhu	r2,10(r2)
 8235ecc:	10bfffcc 	andi	r2,r2,65535
 8235ed0:	1887883a 	add	r3,r3,r2
 8235ed4:	008209b4 	movhi	r2,2086
 8235ed8:	10b82204 	addi	r2,r2,-8056
 8235edc:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 8235ee0:	e0bfe817 	ldw	r2,-96(fp)
 8235ee4:	10800a04 	addi	r2,r2,40
 8235ee8:	e17ffe17 	ldw	r5,-8(fp)
 8235eec:	1009883a 	mov	r4,r2
 8235ef0:	82340280 	call	8234028 <sbappend>
         sorwakeup(so);
 8235ef4:	e0bfe817 	ldw	r2,-96(fp)
 8235ef8:	10800a04 	addi	r2,r2,40
 8235efc:	100b883a 	mov	r5,r2
 8235f00:	e13fe817 	ldw	r4,-96(fp)
 8235f04:	8233e780 	call	8233e78 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 8235f08:	e0bfe717 	ldw	r2,-100(fp)
 8235f0c:	1080020c 	andi	r2,r2,8
 8235f10:	10000726 	beq	r2,zero,8235f30 <tcp_input+0x97c>
            tp->t_flags |= TF_ACKNOW;
 8235f14:	e0bfe617 	ldw	r2,-104(fp)
 8235f18:	10800b0b 	ldhu	r2,44(r2)
 8235f1c:	10800054 	ori	r2,r2,1
 8235f20:	1007883a 	mov	r3,r2
 8235f24:	e0bfe617 	ldw	r2,-104(fp)
 8235f28:	10c00b0d 	sth	r3,44(r2)
 8235f2c:	00000606 	br	8235f48 <tcp_input+0x994>
         else
            tp->t_flags |= TF_DELACK;
 8235f30:	e0bfe617 	ldw	r2,-104(fp)
 8235f34:	10800b0b 	ldhu	r2,44(r2)
 8235f38:	10800094 	ori	r2,r2,2
 8235f3c:	1007883a 	mov	r3,r2
 8235f40:	e0bfe617 	ldw	r2,-104(fp)
 8235f44:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 8235f48:	e0bfe617 	ldw	r2,-104(fp)
 8235f4c:	10c01517 	ldw	r3,84(r2)
 8235f50:	e0bfe617 	ldw	r2,-104(fp)
 8235f54:	11001617 	ldw	r4,88(r2)
 8235f58:	e0bfe617 	ldw	r2,-104(fp)
 8235f5c:	10801917 	ldw	r2,100(r2)
 8235f60:	2085c83a 	sub	r2,r4,r2
 8235f64:	1885883a 	add	r2,r3,r2
 8235f68:	e0bff715 	stw	r2,-36(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 8235f6c:	e0bfe617 	ldw	r2,-104(fp)
 8235f70:	10800a0b 	ldhu	r2,40(r2)
 8235f74:	10bfffcc 	andi	r2,r2,65535
 8235f78:	1085883a 	add	r2,r2,r2
 8235f7c:	1007883a 	mov	r3,r2
 8235f80:	e0bff717 	ldw	r2,-36(fp)
 8235f84:	10c0050e 	bge	r2,r3,8235f9c <tcp_input+0x9e8>
             (tp->t_flags & TF_ACKNOW))
 8235f88:	e0bfe617 	ldw	r2,-104(fp)
 8235f8c:	10800b0b 	ldhu	r2,44(r2)
 8235f90:	10bfffcc 	andi	r2,r2,65535
 8235f94:	1080004c 	andi	r2,r2,1
            tp->t_flags |= TF_DELACK;

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 8235f98:	10064626 	beq	r2,zero,82378b4 <tcp_input+0x2300>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 8235f9c:	e0bfe617 	ldw	r2,-104(fp)
 8235fa0:	10800b0b 	ldhu	r2,44(r2)
 8235fa4:	10800054 	ori	r2,r2,1
 8235fa8:	1007883a 	mov	r3,r2
 8235fac:	e0bfe617 	ldw	r2,-104(fp)
 8235fb0:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 8235fb4:	e0bfe617 	ldw	r2,-104(fp)
 8235fb8:	10c00b0b 	ldhu	r3,44(r2)
 8235fbc:	00bfff44 	movi	r2,-3
 8235fc0:	1884703a 	and	r2,r3,r2
 8235fc4:	1007883a 	mov	r3,r2
 8235fc8:	e0bfe617 	ldw	r2,-104(fp)
 8235fcc:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 8235fd0:	e13fe617 	ldw	r4,-104(fp)
 8235fd4:	8237f340 	call	8237f34 <tcp_output>
         }

         return;
 8235fd8:	00063606 	br	82378b4 <tcp_input+0x2300>
      }
   }

   switch (tp->t_state) 
 8235fdc:	e0bfe617 	ldw	r2,-104(fp)
 8235fe0:	10800217 	ldw	r2,8(r2)
 8235fe4:	10c00060 	cmpeqi	r3,r2,1
 8235fe8:	1800031e 	bne	r3,zero,8235ff8 <tcp_input+0xa44>
 8235fec:	108000a0 	cmpeqi	r2,r2,2
 8235ff0:	1000aa1e 	bne	r2,zero,823629c <tcp_input+0xce8>
 8235ff4:	00017e06 	br	82365f0 <tcp_input+0x103c>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 8235ff8:	e0bfe717 	ldw	r2,-100(fp)
 8235ffc:	1080010c 	andi	r2,r2,4
 8236000:	10000326 	beq	r2,zero,8236010 <tcp_input+0xa5c>
            GOTO_DROP;
 8236004:	0080bec4 	movi	r2,763
 8236008:	d0a0b215 	stw	r2,-32056(gp)
 823600c:	00061b06 	br	823787c <tcp_input+0x22c8>
         if (tiflags & TH_ACK)
 8236010:	e0bfe717 	ldw	r2,-100(fp)
 8236014:	1080040c 	andi	r2,r2,16
 8236018:	10000326 	beq	r2,zero,8236028 <tcp_input+0xa74>
            GOTO_DROPWITHRESET;
 823601c:	0080bf44 	movi	r2,765
 8236020:	d0a0b215 	stw	r2,-32056(gp)
 8236024:	0005d406 	br	8237778 <tcp_input+0x21c4>
         if ((tiflags & TH_SYN) == 0)
 8236028:	e0bfe717 	ldw	r2,-100(fp)
 823602c:	1080008c 	andi	r2,r2,2
 8236030:	1000031e 	bne	r2,zero,8236040 <tcp_input+0xa8c>
            GOTO_DROP;
 8236034:	0080bfc4 	movi	r2,767
 8236038:	d0a0b215 	stw	r2,-32056(gp)
 823603c:	00060f06 	br	823787c <tcp_input+0x22c8>
         if(in_broadcast(ti->ti_dst.s_addr))
 8236040:	e0bff217 	ldw	r2,-56(fp)
 8236044:	10800417 	ldw	r2,16(r2)
 8236048:	1009883a 	mov	r4,r2
 823604c:	822f1b80 	call	822f1b8 <in_broadcast>
 8236050:	10000326 	beq	r2,zero,8236060 <tcp_input+0xaac>
            GOTO_DROP;
 8236054:	0080c044 	movi	r2,769
 8236058:	d0a0b215 	stw	r2,-32056(gp)
 823605c:	00060706 	br	823787c <tcp_input+0x22c8>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8236060:	01400404 	movi	r5,16
 8236064:	01000244 	movi	r4,9
 8236068:	822dfdc0 	call	822dfdc <m_getnbuf>
 823606c:	e0bffa15 	stw	r2,-24(fp)
         if (am == NULL)
 8236070:	e0bffa17 	ldw	r2,-24(fp)
 8236074:	1000031e 	bne	r2,zero,8236084 <tcp_input+0xad0>
            GOTO_DROP;
 8236078:	0080c104 	movi	r2,772
 823607c:	d0a0b215 	stw	r2,-32056(gp)
 8236080:	0005fe06 	br	823787c <tcp_input+0x22c8>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 8236084:	e0bfe417 	ldw	r2,-112(fp)
 8236088:	10800817 	ldw	r2,32(r2)
 823608c:	10800517 	ldw	r2,20(r2)
 8236090:	10800098 	cmpnei	r2,r2,2
 8236094:	10002c1e 	bne	r2,zero,8236148 <tcp_input+0xb94>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 8236098:	e0bffa17 	ldw	r2,-24(fp)
 823609c:	00c00404 	movi	r3,16
 82360a0:	10c00215 	stw	r3,8(r2)
         sin = mtod(am, struct sockaddr_in *);
 82360a4:	e0bffa17 	ldw	r2,-24(fp)
 82360a8:	10800317 	ldw	r2,12(r2)
 82360ac:	e0bffb15 	stw	r2,-20(fp)
         sin->sin_family = AF_INET;
 82360b0:	e0bffb17 	ldw	r2,-20(fp)
 82360b4:	00c00084 	movi	r3,2
 82360b8:	10c0000d 	sth	r3,0(r2)
         sin->sin_addr = ti->ti_src;
 82360bc:	e0bffb17 	ldw	r2,-20(fp)
 82360c0:	e0fff217 	ldw	r3,-56(fp)
 82360c4:	18c00317 	ldw	r3,12(r3)
 82360c8:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 82360cc:	e0bff217 	ldw	r2,-56(fp)
 82360d0:	10c0050b 	ldhu	r3,20(r2)
 82360d4:	e0bffb17 	ldw	r2,-20(fp)
 82360d8:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 82360dc:	e0bfe417 	ldw	r2,-112(fp)
 82360e0:	10800417 	ldw	r2,16(r2)
 82360e4:	e0bffd15 	stw	r2,-12(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 82360e8:	e0bfe417 	ldw	r2,-112(fp)
 82360ec:	10800417 	ldw	r2,16(r2)
 82360f0:	1000041e 	bne	r2,zero,8236104 <tcp_input+0xb50>
            inp->inp_laddr = ti->ti_dst;
 82360f4:	e0bfe417 	ldw	r2,-112(fp)
 82360f8:	e0fff217 	ldw	r3,-56(fp)
 82360fc:	18c00417 	ldw	r3,16(r3)
 8236100:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 8236104:	e17ffa17 	ldw	r5,-24(fp)
 8236108:	e13fe417 	ldw	r4,-112(fp)
 823610c:	8247d7c0 	call	8247d7c <in_pcbconnect>
 8236110:	10000826 	beq	r2,zero,8236134 <tcp_input+0xb80>
         {
            inp->inp_laddr = laddr;
 8236114:	e0bfe417 	ldw	r2,-112(fp)
 8236118:	e0fffd17 	ldw	r3,-12(fp)
 823611c:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 8236120:	e13ffa17 	ldw	r4,-24(fp)
 8236124:	822e1640 	call	822e164 <m_free>
            GOTO_DROP;
 8236128:	0080c684 	movi	r2,794
 823612c:	d0a0b215 	stw	r2,-32056(gp)
 8236130:	0005d206 	br	823787c <tcp_input+0x22c8>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 8236134:	e0bfe417 	ldw	r2,-112(fp)
 8236138:	e0ffff17 	ldw	r3,-4(fp)
 823613c:	10c00a15 	stw	r3,40(r2)
         
         (void) m_free (am);
 8236140:	e13ffa17 	ldw	r4,-24(fp)
 8236144:	822e1640 	call	822e164 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 8236148:	e13fe617 	ldw	r4,-104(fp)
 823614c:	82391540 	call	8239154 <tcp_template>
 8236150:	1007883a 	mov	r3,r2
 8236154:	e0bfe617 	ldw	r2,-104(fp)
 8236158:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 823615c:	e0bfe617 	ldw	r2,-104(fp)
 8236160:	10800c17 	ldw	r2,48(r2)
 8236164:	1000071e 	bne	r2,zero,8236184 <tcp_input+0xbd0>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 8236168:	01401a44 	movi	r5,105
 823616c:	e13fe617 	ldw	r4,-104(fp)
 8236170:	82397680 	call	8239768 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 8236174:	e03fec15 	stw	zero,-80(fp)
            GOTO_DROP;
 8236178:	0080d1c4 	movi	r2,839
 823617c:	d0a0b215 	stw	r2,-32056(gp)
 8236180:	0005be06 	br	823787c <tcp_input+0x22c8>
         }
         if (om) 
 8236184:	e0bfe517 	ldw	r2,-108(fp)
 8236188:	10000526 	beq	r2,zero,82361a0 <tcp_input+0xbec>
         {
            tcp_dooptions(tp, om, ti);
 823618c:	e1bff217 	ldw	r6,-56(fp)
 8236190:	e17fe517 	ldw	r5,-108(fp)
 8236194:	e13fe617 	ldw	r4,-104(fp)
 8236198:	82378e40 	call	82378e4 <tcp_dooptions>
            om = 0;
 823619c:	e03fe515 	stw	zero,-108(fp)
         }
         if (iss)
 82361a0:	e0bfed17 	ldw	r2,-76(fp)
 82361a4:	10000426 	beq	r2,zero,82361b8 <tcp_input+0xc04>
            tp->iss = iss;
 82361a8:	e0ffed17 	ldw	r3,-76(fp)
 82361ac:	e0bfe617 	ldw	r2,-104(fp)
 82361b0:	10c01315 	stw	r3,76(r2)
 82361b4:	00000306 	br	82361c4 <tcp_input+0xc10>
         else
            tp->iss = tcp_iss;
 82361b8:	d0e0b517 	ldw	r3,-32044(gp)
 82361bc:	e0bfe617 	ldw	r2,-104(fp)
 82361c0:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 82361c4:	d0e0b517 	ldw	r3,-32044(gp)
 82361c8:	00be9fd4 	movui	r2,64127
 82361cc:	1885883a 	add	r2,r3,r2
 82361d0:	d0a0b515 	stw	r2,-32044(gp)
         tp->irs = ti->ti_seq;
 82361d4:	e0bff217 	ldw	r2,-56(fp)
 82361d8:	10c00617 	ldw	r3,24(r2)
 82361dc:	e0bfe617 	ldw	r2,-104(fp)
 82361e0:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 82361e4:	e0bfe617 	ldw	r2,-104(fp)
 82361e8:	10c01317 	ldw	r3,76(r2)
 82361ec:	e0bfe617 	ldw	r2,-104(fp)
 82361f0:	10c01015 	stw	r3,64(r2)
 82361f4:	e0bfe617 	ldw	r2,-104(fp)
 82361f8:	10c01017 	ldw	r3,64(r2)
 82361fc:	e0bfe617 	ldw	r2,-104(fp)
 8236200:	10c01a15 	stw	r3,104(r2)
 8236204:	e0bfe617 	ldw	r2,-104(fp)
 8236208:	10c01a17 	ldw	r3,104(r2)
 823620c:	e0bfe617 	ldw	r2,-104(fp)
 8236210:	10c00f15 	stw	r3,60(r2)
 8236214:	e0bfe617 	ldw	r2,-104(fp)
 8236218:	10c00f17 	ldw	r3,60(r2)
 823621c:	e0bfe617 	ldw	r2,-104(fp)
 8236220:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 8236224:	e0bfe617 	ldw	r2,-104(fp)
 8236228:	10801817 	ldw	r2,96(r2)
 823622c:	10c00044 	addi	r3,r2,1
 8236230:	e0bfe617 	ldw	r2,-104(fp)
 8236234:	10c01615 	stw	r3,88(r2)
 8236238:	e0bfe617 	ldw	r2,-104(fp)
 823623c:	10c01617 	ldw	r3,88(r2)
 8236240:	e0bfe617 	ldw	r2,-104(fp)
 8236244:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 8236248:	e0bfe617 	ldw	r2,-104(fp)
 823624c:	10800b0b 	ldhu	r2,44(r2)
 8236250:	10800054 	ori	r2,r2,1
 8236254:	1007883a 	mov	r3,r2
 8236258:	e0bfe617 	ldw	r2,-104(fp)
 823625c:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 8236260:	e0bfe617 	ldw	r2,-104(fp)
 8236264:	00c000c4 	movi	r3,3
 8236268:	10c00215 	stw	r3,8(r2)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 823626c:	e0bfe617 	ldw	r2,-104(fp)
 8236270:	00c02584 	movi	r3,150
 8236274:	10c00515 	stw	r3,20(r2)
         dropsocket = 0;      /* committed to socket */
 8236278:	e03fec15 	stw	zero,-80(fp)
         tcpstat.tcps_accepts++;
 823627c:	008209b4 	movhi	r2,2086
 8236280:	10b82204 	addi	r2,r2,-8056
 8236284:	10800117 	ldw	r2,4(r2)
 8236288:	10c00044 	addi	r3,r2,1
 823628c:	008209b4 	movhi	r2,2086
 8236290:	10b82204 	addi	r2,r2,-8056
 8236294:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 8236298:	00009006 	br	82364dc <tcp_input+0xf28>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 823629c:	e0bfe417 	ldw	r2,-112(fp)
 82362a0:	e0ffff17 	ldw	r3,-4(fp)
 82362a4:	10c00a15 	stw	r3,40(r2)
      if ((tiflags & TH_ACK) &&
 82362a8:	e0bfe717 	ldw	r2,-100(fp)
 82362ac:	1080040c 	andi	r2,r2,16
 82362b0:	10000f26 	beq	r2,zero,82362f0 <tcp_input+0xd3c>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 82362b4:	e0bff217 	ldw	r2,-56(fp)
 82362b8:	10c00717 	ldw	r3,28(r2)
 82362bc:	e0bfe617 	ldw	r2,-104(fp)
 82362c0:	10801317 	ldw	r2,76(r2)
 82362c4:	1885c83a 	sub	r2,r3,r2
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
 82362c8:	0080060e 	bge	zero,r2,82362e4 <tcp_input+0xd30>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
 82362cc:	e0bff217 	ldw	r2,-56(fp)
 82362d0:	10c00717 	ldw	r3,28(r2)
 82362d4:	e0bfe617 	ldw	r2,-104(fp)
 82362d8:	10801a17 	ldw	r2,104(r2)
 82362dc:	1885c83a 	sub	r2,r3,r2
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 82362e0:	0080030e 	bge	zero,r2,82362f0 <tcp_input+0xd3c>
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 82362e4:	0080dc04 	movi	r2,880
 82362e8:	d0a0b215 	stw	r2,-32056(gp)
 82362ec:	00052206 	br	8237778 <tcp_input+0x21c4>
      }
      if (tiflags & TH_RST) 
 82362f0:	e0bfe717 	ldw	r2,-100(fp)
 82362f4:	1080010c 	andi	r2,r2,4
 82362f8:	10000926 	beq	r2,zero,8236320 <tcp_input+0xd6c>
      {
         if (tiflags & TH_ACK)
 82362fc:	e0bfe717 	ldw	r2,-100(fp)
 8236300:	1080040c 	andi	r2,r2,16
 8236304:	10000326 	beq	r2,zero,8236314 <tcp_input+0xd60>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 8236308:	01401bc4 	movi	r5,111
 823630c:	e13fe617 	ldw	r4,-104(fp)
 8236310:	82397680 	call	8239768 <tcp_drop>
         GOTO_DROP;
 8236314:	0080dd84 	movi	r2,886
 8236318:	d0a0b215 	stw	r2,-32056(gp)
 823631c:	00055706 	br	823787c <tcp_input+0x22c8>
      }
      if ((tiflags & TH_SYN) == 0)
 8236320:	e0bfe717 	ldw	r2,-100(fp)
 8236324:	1080008c 	andi	r2,r2,2
 8236328:	1000031e 	bne	r2,zero,8236338 <tcp_input+0xd84>
         GOTO_DROP;
 823632c:	0080de44 	movi	r2,889
 8236330:	d0a0b215 	stw	r2,-32056(gp)
 8236334:	00055106 	br	823787c <tcp_input+0x22c8>
      if (tiflags & TH_ACK) 
 8236338:	e0bfe717 	ldw	r2,-100(fp)
 823633c:	1080040c 	andi	r2,r2,16
 8236340:	10000e26 	beq	r2,zero,823637c <tcp_input+0xdc8>
      {
         tp->snd_una = ti->ti_ack;
 8236344:	e0bff217 	ldw	r2,-56(fp)
 8236348:	10c00717 	ldw	r3,28(r2)
 823634c:	e0bfe617 	ldw	r2,-104(fp)
 8236350:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 8236354:	e0bfe617 	ldw	r2,-104(fp)
 8236358:	10c00f17 	ldw	r3,60(r2)
 823635c:	e0bfe617 	ldw	r2,-104(fp)
 8236360:	10800e17 	ldw	r2,56(r2)
 8236364:	1885c83a 	sub	r2,r3,r2
 8236368:	1000040e 	bge	r2,zero,823637c <tcp_input+0xdc8>
            tp->snd_nxt = tp->snd_una;
 823636c:	e0bfe617 	ldw	r2,-104(fp)
 8236370:	10c00e17 	ldw	r3,56(r2)
 8236374:	e0bfe617 	ldw	r2,-104(fp)
 8236378:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 823637c:	e0bfe617 	ldw	r2,-104(fp)
 8236380:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 8236384:	e0bff217 	ldw	r2,-56(fp)
 8236388:	10c00617 	ldw	r3,24(r2)
 823638c:	e0bfe617 	ldw	r2,-104(fp)
 8236390:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 8236394:	e0bfe617 	ldw	r2,-104(fp)
 8236398:	10801817 	ldw	r2,96(r2)
 823639c:	10c00044 	addi	r3,r2,1
 82363a0:	e0bfe617 	ldw	r2,-104(fp)
 82363a4:	10c01615 	stw	r3,88(r2)
 82363a8:	e0bfe617 	ldw	r2,-104(fp)
 82363ac:	10c01617 	ldw	r3,88(r2)
 82363b0:	e0bfe617 	ldw	r2,-104(fp)
 82363b4:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 82363b8:	e0bfe417 	ldw	r2,-112(fp)
 82363bc:	10c00417 	ldw	r3,16(r2)
 82363c0:	e0bff217 	ldw	r2,-56(fp)
 82363c4:	10800417 	ldw	r2,16(r2)
 82363c8:	18801726 	beq	r3,r2,8236428 <tcp_input+0xe74>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 82363cc:	e0bffe17 	ldw	r2,-8(fp)
 82363d0:	10800117 	ldw	r2,4(r2)
 82363d4:	10800617 	ldw	r2,24(r2)
 82363d8:	10001326 	beq	r2,zero,8236428 <tcp_input+0xe74>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
 82363dc:	e0bffe17 	ldw	r2,-8(fp)
 82363e0:	10800117 	ldw	r2,4(r2)
 82363e4:	10800617 	ldw	r2,24(r2)
 82363e8:	10c00a17 	ldw	r3,40(r2)
 82363ec:	e0bff217 	ldw	r2,-56(fp)
 82363f0:	10800417 	ldw	r2,16(r2)
 82363f4:	18800c1e 	bne	r3,r2,8236428 <tcp_input+0xe74>
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 82363f8:	e0bfe417 	ldw	r2,-112(fp)
 82363fc:	e0fff217 	ldw	r3,-56(fp)
 8236400:	18c00417 	ldw	r3,16(r3)
 8236404:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 8236408:	e0bfe617 	ldw	r2,-104(fp)
 823640c:	10800c17 	ldw	r2,48(r2)
 8236410:	10000526 	beq	r2,zero,8236428 <tcp_input+0xe74>
               tp->t_template->ti_src = ti->ti_dst;
 8236414:	e0bfe617 	ldw	r2,-104(fp)
 8236418:	10800c17 	ldw	r2,48(r2)
 823641c:	e0fff217 	ldw	r3,-56(fp)
 8236420:	18c00417 	ldw	r3,16(r3)
 8236424:	10c00315 	stw	r3,12(r2)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 8236428:	e0bfe617 	ldw	r2,-104(fp)
 823642c:	10800b0b 	ldhu	r2,44(r2)
 8236430:	10800054 	ori	r2,r2,1
 8236434:	1007883a 	mov	r3,r2
 8236438:	e0bfe617 	ldw	r2,-104(fp)
 823643c:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 8236440:	e0bfe717 	ldw	r2,-100(fp)
 8236444:	1080040c 	andi	r2,r2,16
 8236448:	10002126 	beq	r2,zero,82364d0 <tcp_input+0xf1c>
 823644c:	e0bfe617 	ldw	r2,-104(fp)
 8236450:	10c00e17 	ldw	r3,56(r2)
 8236454:	e0bfe617 	ldw	r2,-104(fp)
 8236458:	10801317 	ldw	r2,76(r2)
 823645c:	1885c83a 	sub	r2,r3,r2
 8236460:	00801b0e 	bge	zero,r2,82364d0 <tcp_input+0xf1c>
      {
         tcpstat.tcps_connects++;
 8236464:	008209b4 	movhi	r2,2086
 8236468:	10b82204 	addi	r2,r2,-8056
 823646c:	10800217 	ldw	r2,8(r2)
 8236470:	10c00044 	addi	r3,r2,1
 8236474:	008209b4 	movhi	r2,2086
 8236478:	10b82204 	addi	r2,r2,-8056
 823647c:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 8236480:	e0bfe617 	ldw	r2,-104(fp)
 8236484:	00c00104 	movi	r3,4
 8236488:	10c00215 	stw	r3,8(r2)
         soisconnected (so);
 823648c:	e13fe817 	ldw	r4,-96(fp)
 8236490:	823370c0 	call	823370c <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 8236494:	e13fe817 	ldw	r4,-96(fp)
 8236498:	8237e3c0 	call	8237e3c <tcp_mss>
 823649c:	1007883a 	mov	r3,r2
 82364a0:	e0bfe617 	ldw	r2,-104(fp)
 82364a4:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 82364a8:	e1bffe17 	ldw	r6,-8(fp)
 82364ac:	000b883a 	mov	r5,zero
 82364b0:	e13fe617 	ldw	r4,-104(fp)
 82364b4:	82351a40 	call	82351a4 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 82364b8:	e0bfe617 	ldw	r2,-104(fp)
 82364bc:	10801e17 	ldw	r2,120(r2)
 82364c0:	10000626 	beq	r2,zero,82364dc <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
 82364c4:	e13fe617 	ldw	r4,-104(fp)
 82364c8:	8237b980 	call	8237b98 <tcp_xmit_timer>
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 82364cc:	00000306 	br	82364dc <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 82364d0:	e0bfe617 	ldw	r2,-104(fp)
 82364d4:	00c000c4 	movi	r3,3
 82364d8:	10c00215 	stw	r3,8(r2)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 82364dc:	e0bff217 	ldw	r2,-56(fp)
 82364e0:	10800617 	ldw	r2,24(r2)
 82364e4:	10c00044 	addi	r3,r2,1
 82364e8:	e0bff217 	ldw	r2,-56(fp)
 82364ec:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 82364f0:	e0bff217 	ldw	r2,-56(fp)
 82364f4:	1080028b 	ldhu	r2,10(r2)
 82364f8:	10bfffcc 	andi	r2,r2,65535
 82364fc:	e0ffe617 	ldw	r3,-104(fp)
 8236500:	18c01517 	ldw	r3,84(r3)
 8236504:	1880302e 	bgeu	r3,r2,82365c8 <tcp_input+0x1014>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 8236508:	e0bff217 	ldw	r2,-56(fp)
 823650c:	1080028b 	ldhu	r2,10(r2)
 8236510:	10ffffcc 	andi	r3,r2,65535
 8236514:	e0bfe617 	ldw	r2,-104(fp)
 8236518:	10801517 	ldw	r2,84(r2)
 823651c:	10bfffcc 	andi	r2,r2,65535
 8236520:	1885c83a 	sub	r2,r3,r2
 8236524:	e0bfe915 	stw	r2,-92(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 8236528:	e0bffe17 	ldw	r2,-8(fp)
 823652c:	10800217 	ldw	r2,8(r2)
 8236530:	10000626 	beq	r2,zero,823654c <tcp_input+0xf98>
         {
            m_adj(m, -todrop);
 8236534:	e0bfe917 	ldw	r2,-92(fp)
 8236538:	0085c83a 	sub	r2,zero,r2
 823653c:	100b883a 	mov	r5,r2
 8236540:	e13ffe17 	ldw	r4,-8(fp)
 8236544:	822e5a40 	call	822e5a4 <m_adj>
 8236548:	00000706 	br	8236568 <tcp_input+0xfb4>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 823654c:	e0bffe17 	ldw	r2,-8(fp)
 8236550:	10c00617 	ldw	r3,24(r2)
 8236554:	e0bfe917 	ldw	r2,-92(fp)
 8236558:	0085c83a 	sub	r2,zero,r2
 823655c:	100b883a 	mov	r5,r2
 8236560:	1809883a 	mov	r4,r3
 8236564:	822e5a40 	call	822e5a4 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 8236568:	e0bfe617 	ldw	r2,-104(fp)
 823656c:	10801517 	ldw	r2,84(r2)
 8236570:	1007883a 	mov	r3,r2
 8236574:	e0bff217 	ldw	r2,-56(fp)
 8236578:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 823657c:	e0ffe717 	ldw	r3,-100(fp)
 8236580:	00bfff84 	movi	r2,-2
 8236584:	1884703a 	and	r2,r3,r2
 8236588:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpackafterwin++;
 823658c:	008209b4 	movhi	r2,2086
 8236590:	10b82204 	addi	r2,r2,-8056
 8236594:	10802517 	ldw	r2,148(r2)
 8236598:	10c00044 	addi	r3,r2,1
 823659c:	008209b4 	movhi	r2,2086
 82365a0:	10b82204 	addi	r2,r2,-8056
 82365a4:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 82365a8:	008209b4 	movhi	r2,2086
 82365ac:	10b82204 	addi	r2,r2,-8056
 82365b0:	10c02617 	ldw	r3,152(r2)
 82365b4:	e0bfe917 	ldw	r2,-92(fp)
 82365b8:	1887883a 	add	r3,r3,r2
 82365bc:	008209b4 	movhi	r2,2086
 82365c0:	10b82204 	addi	r2,r2,-8056
 82365c4:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 82365c8:	e0bff217 	ldw	r2,-56(fp)
 82365cc:	10800617 	ldw	r2,24(r2)
 82365d0:	10ffffc4 	addi	r3,r2,-1
 82365d4:	e0bfe617 	ldw	r2,-104(fp)
 82365d8:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 82365dc:	e0bff217 	ldw	r2,-56(fp)
 82365e0:	10c00617 	ldw	r3,24(r2)
 82365e4:	e0bfe617 	ldw	r2,-104(fp)
 82365e8:	10c01715 	stw	r3,92(r2)
      goto step6;
 82365ec:	0002ee06 	br	82371a8 <tcp_input+0x1bf4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 82365f0:	e0bfe617 	ldw	r2,-104(fp)
 82365f4:	10c01617 	ldw	r3,88(r2)
 82365f8:	e0bff217 	ldw	r2,-56(fp)
 82365fc:	10800617 	ldw	r2,24(r2)
 8236600:	1885c83a 	sub	r2,r3,r2
 8236604:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236608:	e0bfe917 	ldw	r2,-92(fp)
 823660c:	0080910e 	bge	zero,r2,8236854 <tcp_input+0x12a0>
   {
      if (tiflags & TH_SYN) 
 8236610:	e0bfe717 	ldw	r2,-100(fp)
 8236614:	1080008c 	andi	r2,r2,2
 8236618:	10001c26 	beq	r2,zero,823668c <tcp_input+0x10d8>
      {
         tiflags &= ~TH_SYN;
 823661c:	e0ffe717 	ldw	r3,-100(fp)
 8236620:	00bfff44 	movi	r2,-3
 8236624:	1884703a 	and	r2,r3,r2
 8236628:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_seq++;
 823662c:	e0bff217 	ldw	r2,-56(fp)
 8236630:	10800617 	ldw	r2,24(r2)
 8236634:	10c00044 	addi	r3,r2,1
 8236638:	e0bff217 	ldw	r2,-56(fp)
 823663c:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 8236640:	e0bff217 	ldw	r2,-56(fp)
 8236644:	1080098b 	ldhu	r2,38(r2)
 8236648:	10bfffcc 	andi	r2,r2,65535
 823664c:	108000b0 	cmpltui	r2,r2,2
 8236650:	1000071e 	bne	r2,zero,8236670 <tcp_input+0x10bc>
            ti->ti_urp--;
 8236654:	e0bff217 	ldw	r2,-56(fp)
 8236658:	1080098b 	ldhu	r2,38(r2)
 823665c:	10bfffc4 	addi	r2,r2,-1
 8236660:	1007883a 	mov	r3,r2
 8236664:	e0bff217 	ldw	r2,-56(fp)
 8236668:	10c0098d 	sth	r3,38(r2)
 823666c:	00000406 	br	8236680 <tcp_input+0x10cc>
         else
            tiflags &= ~TH_URG;
 8236670:	e0ffe717 	ldw	r3,-100(fp)
 8236674:	00bff7c4 	movi	r2,-33
 8236678:	1884703a 	and	r2,r3,r2
 823667c:	e0bfe715 	stw	r2,-100(fp)
         todrop--;
 8236680:	e0bfe917 	ldw	r2,-92(fp)
 8236684:	10bfffc4 	addi	r2,r2,-1
 8236688:	e0bfe915 	stw	r2,-92(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 823668c:	e0bff217 	ldw	r2,-56(fp)
 8236690:	1080028b 	ldhu	r2,10(r2)
 8236694:	10ffffcc 	andi	r3,r2,65535
 8236698:	e0bfe917 	ldw	r2,-92(fp)
 823669c:	18800816 	blt	r3,r2,82366c0 <tcp_input+0x110c>
          ((todrop == (int)ti->ti_len) && 
 82366a0:	e0bff217 	ldw	r2,-56(fp)
 82366a4:	1080028b 	ldhu	r2,10(r2)
 82366a8:	10ffffcc 	andi	r3,r2,65535
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 82366ac:	e0bfe917 	ldw	r2,-92(fp)
 82366b0:	1880351e 	bne	r3,r2,8236788 <tcp_input+0x11d4>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
 82366b4:	e0bfe717 	ldw	r2,-100(fp)
 82366b8:	1080004c 	andi	r2,r2,1
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
          ((todrop == (int)ti->ti_len) && 
 82366bc:	1000321e 	bne	r2,zero,8236788 <tcp_input+0x11d4>
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 82366c0:	008209b4 	movhi	r2,2086
 82366c4:	10b82204 	addi	r2,r2,-8056
 82366c8:	10801f17 	ldw	r2,124(r2)
 82366cc:	10c00044 	addi	r3,r2,1
 82366d0:	008209b4 	movhi	r2,2086
 82366d4:	10b82204 	addi	r2,r2,-8056
 82366d8:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 82366dc:	008209b4 	movhi	r2,2086
 82366e0:	10b82204 	addi	r2,r2,-8056
 82366e4:	10c02017 	ldw	r3,128(r2)
 82366e8:	e0bff217 	ldw	r2,-56(fp)
 82366ec:	1080028b 	ldhu	r2,10(r2)
 82366f0:	10bfffcc 	andi	r2,r2,65535
 82366f4:	1887883a 	add	r3,r3,r2
 82366f8:	008209b4 	movhi	r2,2086
 82366fc:	10b82204 	addi	r2,r2,-8056
 8236700:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236704:	e0bfe717 	ldw	r2,-100(fp)
 8236708:	1080004c 	andi	r2,r2,1
 823670c:	10000626 	beq	r2,zero,8236728 <tcp_input+0x1174>
 8236710:	e0bff217 	ldw	r2,-56(fp)
 8236714:	1080028b 	ldhu	r2,10(r2)
 8236718:	10bfffcc 	andi	r2,r2,65535
 823671c:	10c00044 	addi	r3,r2,1
 8236720:	e0bfe917 	ldw	r2,-92(fp)
 8236724:	18800926 	beq	r3,r2,823674c <tcp_input+0x1198>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236728:	e0bfe717 	ldw	r2,-100(fp)
 823672c:	1080010c 	andi	r2,r2,4
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236730:	10040026 	beq	r2,zero,8237734 <tcp_input+0x2180>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236734:	e0bff217 	ldw	r2,-56(fp)
 8236738:	10c00617 	ldw	r3,24(r2)
 823673c:	e0bfe617 	ldw	r2,-104(fp)
 8236740:	10801617 	ldw	r2,88(r2)
 8236744:	10bfffc4 	addi	r2,r2,-1
 8236748:	1883fa1e 	bne	r3,r2,8237734 <tcp_input+0x2180>
         {
            todrop = ti->ti_len;
 823674c:	e0bff217 	ldw	r2,-56(fp)
 8236750:	1080028b 	ldhu	r2,10(r2)
 8236754:	10bfffcc 	andi	r2,r2,65535
 8236758:	e0bfe915 	stw	r2,-92(fp)
            tiflags &= ~TH_FIN;
 823675c:	e0ffe717 	ldw	r3,-100(fp)
 8236760:	00bfff84 	movi	r2,-2
 8236764:	1884703a 	and	r2,r3,r2
 8236768:	e0bfe715 	stw	r2,-100(fp)
            tp->t_flags |= TF_ACKNOW;
 823676c:	e0bfe617 	ldw	r2,-104(fp)
 8236770:	10800b0b 	ldhu	r2,44(r2)
 8236774:	10800054 	ori	r2,r2,1
 8236778:	1007883a 	mov	r3,r2
 823677c:	e0bfe617 	ldw	r2,-104(fp)
 8236780:	10c00b0d 	sth	r3,44(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236784:	00000f06 	br	82367c4 <tcp_input+0x1210>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 8236788:	008209b4 	movhi	r2,2086
 823678c:	10b82204 	addi	r2,r2,-8056
 8236790:	10802117 	ldw	r2,132(r2)
 8236794:	10c00044 	addi	r3,r2,1
 8236798:	008209b4 	movhi	r2,2086
 823679c:	10b82204 	addi	r2,r2,-8056
 82367a0:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 82367a4:	008209b4 	movhi	r2,2086
 82367a8:	10b82204 	addi	r2,r2,-8056
 82367ac:	10c02217 	ldw	r3,136(r2)
 82367b0:	e0bfe917 	ldw	r2,-92(fp)
 82367b4:	1887883a 	add	r3,r3,r2
 82367b8:	008209b4 	movhi	r2,2086
 82367bc:	10b82204 	addi	r2,r2,-8056
 82367c0:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 82367c4:	e17fe917 	ldw	r5,-92(fp)
 82367c8:	e13ffe17 	ldw	r4,-8(fp)
 82367cc:	822e5a40 	call	822e5a4 <m_adj>
      ti->ti_seq += todrop;
 82367d0:	e0bff217 	ldw	r2,-56(fp)
 82367d4:	10c00617 	ldw	r3,24(r2)
 82367d8:	e0bfe917 	ldw	r2,-92(fp)
 82367dc:	1887883a 	add	r3,r3,r2
 82367e0:	e0bff217 	ldw	r2,-56(fp)
 82367e4:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 82367e8:	e0bff217 	ldw	r2,-56(fp)
 82367ec:	1080028b 	ldhu	r2,10(r2)
 82367f0:	e0ffe917 	ldw	r3,-92(fp)
 82367f4:	10c5c83a 	sub	r2,r2,r3
 82367f8:	1007883a 	mov	r3,r2
 82367fc:	e0bff217 	ldw	r2,-56(fp)
 8236800:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 8236804:	e0bff217 	ldw	r2,-56(fp)
 8236808:	1080098b 	ldhu	r2,38(r2)
 823680c:	10bfffcc 	andi	r2,r2,65535
 8236810:	e0ffe917 	ldw	r3,-92(fp)
 8236814:	18ffffcc 	andi	r3,r3,65535
 8236818:	1880080e 	bge	r3,r2,823683c <tcp_input+0x1288>
         ti->ti_urp -= (u_short)todrop;
 823681c:	e0bff217 	ldw	r2,-56(fp)
 8236820:	1080098b 	ldhu	r2,38(r2)
 8236824:	e0ffe917 	ldw	r3,-92(fp)
 8236828:	10c5c83a 	sub	r2,r2,r3
 823682c:	1007883a 	mov	r3,r2
 8236830:	e0bff217 	ldw	r2,-56(fp)
 8236834:	10c0098d 	sth	r3,38(r2)
 8236838:	00000606 	br	8236854 <tcp_input+0x12a0>
      else 
      {
         tiflags &= ~TH_URG;
 823683c:	e0ffe717 	ldw	r3,-100(fp)
 8236840:	00bff7c4 	movi	r2,-33
 8236844:	1884703a 	and	r2,r3,r2
 8236848:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_urp = 0;
 823684c:	e0bff217 	ldw	r2,-56(fp)
 8236850:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236854:	e0bfe817 	ldw	r2,-96(fp)
 8236858:	1080088b 	ldhu	r2,34(r2)
 823685c:	10bfffcc 	andi	r2,r2,65535
 8236860:	1080004c 	andi	r2,r2,1
 8236864:	10001526 	beq	r2,zero,82368bc <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236868:	e0bfe617 	ldw	r2,-104(fp)
 823686c:	10800217 	ldw	r2,8(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236870:	10800190 	cmplti	r2,r2,6
 8236874:	1000111e 	bne	r2,zero,82368bc <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236878:	e0bff217 	ldw	r2,-56(fp)
 823687c:	1080028b 	ldhu	r2,10(r2)
 8236880:	10bfffcc 	andi	r2,r2,65535
 8236884:	10000d26 	beq	r2,zero,82368bc <tcp_input+0x1308>
   {
      tp = tcp_close(tp);
 8236888:	e13fe617 	ldw	r4,-104(fp)
 823688c:	82398140 	call	8239814 <tcp_close>
 8236890:	e0bfe615 	stw	r2,-104(fp)
      tcpstat.tcps_rcvafterclose++;
 8236894:	008209b4 	movhi	r2,2086
 8236898:	10b82204 	addi	r2,r2,-8056
 823689c:	10802717 	ldw	r2,156(r2)
 82368a0:	10c00044 	addi	r3,r2,1
 82368a4:	008209b4 	movhi	r2,2086
 82368a8:	10b82204 	addi	r2,r2,-8056
 82368ac:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 82368b0:	00810444 	movi	r2,1041
 82368b4:	d0a0b215 	stw	r2,-32056(gp)
 82368b8:	0003af06 	br	8237778 <tcp_input+0x21c4>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 82368bc:	e0bff217 	ldw	r2,-56(fp)
 82368c0:	10c00617 	ldw	r3,24(r2)
 82368c4:	e0bff217 	ldw	r2,-56(fp)
 82368c8:	1080028b 	ldhu	r2,10(r2)
 82368cc:	10bfffcc 	andi	r2,r2,65535
 82368d0:	10a0001c 	xori	r2,r2,32768
 82368d4:	10a00004 	addi	r2,r2,-32768
 82368d8:	1887883a 	add	r3,r3,r2
 82368dc:	e0bfe617 	ldw	r2,-104(fp)
 82368e0:	11001617 	ldw	r4,88(r2)
 82368e4:	e0bfe617 	ldw	r2,-104(fp)
 82368e8:	10801517 	ldw	r2,84(r2)
 82368ec:	2085883a 	add	r2,r4,r2
 82368f0:	1885c83a 	sub	r2,r3,r2
 82368f4:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 82368f8:	e0bfe917 	ldw	r2,-92(fp)
 82368fc:	0080690e 	bge	zero,r2,8236aa4 <tcp_input+0x14f0>
   {
      tcpstat.tcps_rcvpackafterwin++;
 8236900:	008209b4 	movhi	r2,2086
 8236904:	10b82204 	addi	r2,r2,-8056
 8236908:	10802517 	ldw	r2,148(r2)
 823690c:	10c00044 	addi	r3,r2,1
 8236910:	008209b4 	movhi	r2,2086
 8236914:	10b82204 	addi	r2,r2,-8056
 8236918:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 823691c:	e0bff217 	ldw	r2,-56(fp)
 8236920:	1080028b 	ldhu	r2,10(r2)
 8236924:	10bfffcc 	andi	r2,r2,65535
 8236928:	e0ffe917 	ldw	r3,-92(fp)
 823692c:	18803a16 	blt	r3,r2,8236a18 <tcp_input+0x1464>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 8236930:	008209b4 	movhi	r2,2086
 8236934:	10b82204 	addi	r2,r2,-8056
 8236938:	10c02617 	ldw	r3,152(r2)
 823693c:	e0bff217 	ldw	r2,-56(fp)
 8236940:	1080028b 	ldhu	r2,10(r2)
 8236944:	10bfffcc 	andi	r2,r2,65535
 8236948:	1887883a 	add	r3,r3,r2
 823694c:	008209b4 	movhi	r2,2086
 8236950:	10b82204 	addi	r2,r2,-8056
 8236954:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236958:	e0bfe717 	ldw	r2,-100(fp)
 823695c:	1080008c 	andi	r2,r2,2
 8236960:	10001726 	beq	r2,zero,82369c0 <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
 8236964:	e0bfe617 	ldw	r2,-104(fp)
 8236968:	10800217 	ldw	r2,8(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 823696c:	10800298 	cmpnei	r2,r2,10
 8236970:	1000131e 	bne	r2,zero,82369c0 <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
 8236974:	e0bff217 	ldw	r2,-56(fp)
 8236978:	10c00617 	ldw	r3,24(r2)
 823697c:	e0bfe617 	ldw	r2,-104(fp)
 8236980:	10801617 	ldw	r2,88(r2)
 8236984:	1885c83a 	sub	r2,r3,r2
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
             tp->t_state == TCPS_TIME_WAIT &&
 8236988:	00800d0e 	bge	zero,r2,82369c0 <tcp_input+0x140c>
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 823698c:	e0bfe617 	ldw	r2,-104(fp)
 8236990:	10c01617 	ldw	r3,88(r2)
 8236994:	008000b4 	movhi	r2,2
 8236998:	10bd3fc4 	addi	r2,r2,-2817
 823699c:	1885883a 	add	r2,r3,r2
 82369a0:	e0bfed15 	stw	r2,-76(fp)
            if (iss & 0xff000000)
 82369a4:	e0bfed17 	ldw	r2,-76(fp)
 82369a8:	10bfc02c 	andhi	r2,r2,65280
 82369ac:	10000126 	beq	r2,zero,82369b4 <tcp_input+0x1400>
            {
               iss = 0L;
 82369b0:	e03fed15 	stw	zero,-76(fp)
            }
            (void) tcp_close(tp);
 82369b4:	e13fe617 	ldw	r4,-104(fp)
 82369b8:	82398140 	call	8239814 <tcp_close>
            goto findpcb;
 82369bc:	003bd406 	br	8235910 <tcp_input+0x35c>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 82369c0:	e0bfe617 	ldw	r2,-104(fp)
 82369c4:	10801517 	ldw	r2,84(r2)
 82369c8:	10035a1e 	bne	r2,zero,8237734 <tcp_input+0x2180>
 82369cc:	e0bff217 	ldw	r2,-56(fp)
 82369d0:	10c00617 	ldw	r3,24(r2)
 82369d4:	e0bfe617 	ldw	r2,-104(fp)
 82369d8:	10801617 	ldw	r2,88(r2)
 82369dc:	1883551e 	bne	r3,r2,8237734 <tcp_input+0x2180>
         {
            tp->t_flags |= TF_ACKNOW;
 82369e0:	e0bfe617 	ldw	r2,-104(fp)
 82369e4:	10800b0b 	ldhu	r2,44(r2)
 82369e8:	10800054 	ori	r2,r2,1
 82369ec:	1007883a 	mov	r3,r2
 82369f0:	e0bfe617 	ldw	r2,-104(fp)
 82369f4:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 82369f8:	008209b4 	movhi	r2,2086
 82369fc:	10b82204 	addi	r2,r2,-8056
 8236a00:	10802817 	ldw	r2,160(r2)
 8236a04:	10c00044 	addi	r3,r2,1
 8236a08:	008209b4 	movhi	r2,2086
 8236a0c:	10b82204 	addi	r2,r2,-8056
 8236a10:	10c02815 	stw	r3,160(r2)
 8236a14:	00000806 	br	8236a38 <tcp_input+0x1484>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 8236a18:	008209b4 	movhi	r2,2086
 8236a1c:	10b82204 	addi	r2,r2,-8056
 8236a20:	10c02617 	ldw	r3,152(r2)
 8236a24:	e0bfe917 	ldw	r2,-92(fp)
 8236a28:	1887883a 	add	r3,r3,r2
 8236a2c:	008209b4 	movhi	r2,2086
 8236a30:	10b82204 	addi	r2,r2,-8056
 8236a34:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 8236a38:	e0bffe17 	ldw	r2,-8(fp)
 8236a3c:	10800217 	ldw	r2,8(r2)
 8236a40:	10000626 	beq	r2,zero,8236a5c <tcp_input+0x14a8>
      {
         m_adj(m, -todrop);
 8236a44:	e0bfe917 	ldw	r2,-92(fp)
 8236a48:	0085c83a 	sub	r2,zero,r2
 8236a4c:	100b883a 	mov	r5,r2
 8236a50:	e13ffe17 	ldw	r4,-8(fp)
 8236a54:	822e5a40 	call	822e5a4 <m_adj>
 8236a58:	00000706 	br	8236a78 <tcp_input+0x14c4>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 8236a5c:	e0bffe17 	ldw	r2,-8(fp)
 8236a60:	10c00617 	ldw	r3,24(r2)
 8236a64:	e0bfe917 	ldw	r2,-92(fp)
 8236a68:	0085c83a 	sub	r2,zero,r2
 8236a6c:	100b883a 	mov	r5,r2
 8236a70:	1809883a 	mov	r4,r3
 8236a74:	822e5a40 	call	822e5a4 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 8236a78:	e0bff217 	ldw	r2,-56(fp)
 8236a7c:	1080028b 	ldhu	r2,10(r2)
 8236a80:	e0ffe917 	ldw	r3,-92(fp)
 8236a84:	10c5c83a 	sub	r2,r2,r3
 8236a88:	1007883a 	mov	r3,r2
 8236a8c:	e0bff217 	ldw	r2,-56(fp)
 8236a90:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 8236a94:	e0ffe717 	ldw	r3,-100(fp)
 8236a98:	00bffd84 	movi	r2,-10
 8236a9c:	1884703a 	and	r2,r3,r2
 8236aa0:	e0bfe715 	stw	r2,-100(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 8236aa4:	e0bfe717 	ldw	r2,-100(fp)
 8236aa8:	1080010c 	andi	r2,r2,4
 8236aac:	10003426 	beq	r2,zero,8236b80 <tcp_input+0x15cc>
   {
      switch (tp->t_state) 
 8236ab0:	e0bfe617 	ldw	r2,-104(fp)
 8236ab4:	10800217 	ldw	r2,8(r2)
 8236ab8:	10bfff44 	addi	r2,r2,-3
 8236abc:	10c00228 	cmpgeui	r3,r2,8
 8236ac0:	18002f1e 	bne	r3,zero,8236b80 <tcp_input+0x15cc>
 8236ac4:	100690ba 	slli	r3,r2,2
 8236ac8:	008208f4 	movhi	r2,2083
 8236acc:	109ab704 	addi	r2,r2,27356
 8236ad0:	1885883a 	add	r2,r3,r2
 8236ad4:	10800017 	ldw	r2,0(r2)
 8236ad8:	1000683a 	jmp	r2
 8236adc:	08236afc 	xorhi	zero,at,36267
 8236ae0:	08236b0c 	andi	zero,at,36268
 8236ae4:	08236b28 	cmpgeui	zero,at,36268
 8236ae8:	08236b28 	cmpgeui	zero,at,36268
 8236aec:	08236b6c 	andhi	zero,at,36269
 8236af0:	08236b6c 	andhi	zero,at,36269
 8236af4:	08236b28 	cmpgeui	zero,at,36268
 8236af8:	08236b6c 	andhi	zero,at,36269
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 8236afc:	e0bfe817 	ldw	r2,-96(fp)
 8236b00:	00c01bc4 	movi	r3,111
 8236b04:	10c00615 	stw	r3,24(r2)
         goto close;
 8236b08:	00000a06 	br	8236b34 <tcp_input+0x1580>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236b0c:	008209b4 	movhi	r2,2086
 8236b10:	10b7f404 	addi	r2,r2,-8240
 8236b14:	10800717 	ldw	r2,28(r2)
 8236b18:	10c00044 	addi	r3,r2,1
 8236b1c:	008209b4 	movhi	r2,2086
 8236b20:	10b7f404 	addi	r2,r2,-8240
 8236b24:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 8236b28:	e0bfe817 	ldw	r2,-96(fp)
 8236b2c:	00c01a04 	movi	r3,104
 8236b30:	10c00615 	stw	r3,24(r2)
         close:
         tp->t_state = TCPS_CLOSED;
 8236b34:	e0bfe617 	ldw	r2,-104(fp)
 8236b38:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 8236b3c:	008209b4 	movhi	r2,2086
 8236b40:	10b82204 	addi	r2,r2,-8056
 8236b44:	10800317 	ldw	r2,12(r2)
 8236b48:	10c00044 	addi	r3,r2,1
 8236b4c:	008209b4 	movhi	r2,2086
 8236b50:	10b82204 	addi	r2,r2,-8056
 8236b54:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 8236b58:	e13fe617 	ldw	r4,-104(fp)
 8236b5c:	82398140 	call	8239814 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 8236b60:	00812204 	movi	r2,1160
 8236b64:	d0a0b215 	stw	r2,-32056(gp)
 8236b68:	00034406 	br	823787c <tcp_input+0x22c8>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 8236b6c:	e13fe617 	ldw	r4,-104(fp)
 8236b70:	82398140 	call	8239814 <tcp_close>
         GOTO_DROP;
 8236b74:	00812384 	movi	r2,1166
 8236b78:	d0a0b215 	stw	r2,-32056(gp)
 8236b7c:	00033f06 	br	823787c <tcp_input+0x22c8>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 8236b80:	e0bfe717 	ldw	r2,-100(fp)
 8236b84:	1080008c 	andi	r2,r2,2
 8236b88:	10000726 	beq	r2,zero,8236ba8 <tcp_input+0x15f4>
   {
      tp = tcp_drop(tp, ECONNRESET);
 8236b8c:	01401a04 	movi	r5,104
 8236b90:	e13fe617 	ldw	r4,-104(fp)
 8236b94:	82397680 	call	8239768 <tcp_drop>
 8236b98:	e0bfe615 	stw	r2,-104(fp)
      GOTO_DROPWITHRESET;
 8236b9c:	00812b04 	movi	r2,1196
 8236ba0:	d0a0b215 	stw	r2,-32056(gp)
 8236ba4:	0002f406 	br	8237778 <tcp_input+0x21c4>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 8236ba8:	e0bfe717 	ldw	r2,-100(fp)
 8236bac:	1080040c 	andi	r2,r2,16
 8236bb0:	1000031e 	bne	r2,zero,8236bc0 <tcp_input+0x160c>
      GOTO_DROP;
 8236bb4:	00812d04 	movi	r2,1204
 8236bb8:	d0a0b215 	stw	r2,-32056(gp)
 8236bbc:	00032f06 	br	823787c <tcp_input+0x22c8>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 8236bc0:	e0bfe617 	ldw	r2,-104(fp)
 8236bc4:	10800217 	ldw	r2,8(r2)
 8236bc8:	10c000e0 	cmpeqi	r3,r2,3
 8236bcc:	1800051e 	bne	r3,zero,8236be4 <tcp_input+0x1630>
 8236bd0:	10c000d0 	cmplti	r3,r2,3
 8236bd4:	1801741e 	bne	r3,zero,82371a8 <tcp_input+0x1bf4>
 8236bd8:	108002c8 	cmpgei	r2,r2,11
 8236bdc:	1001721e 	bne	r2,zero,82371a8 <tcp_input+0x1bf4>
 8236be0:	00003006 	br	8236ca4 <tcp_input+0x16f0>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236be4:	e0bfe617 	ldw	r2,-104(fp)
 8236be8:	10c00e17 	ldw	r3,56(r2)
 8236bec:	e0bff217 	ldw	r2,-56(fp)
 8236bf0:	10800717 	ldw	r2,28(r2)
 8236bf4:	1885c83a 	sub	r2,r3,r2
 8236bf8:	00800616 	blt	zero,r2,8236c14 <tcp_input+0x1660>
          SEQ_GT(ti->ti_ack, tp->snd_max))
 8236bfc:	e0bff217 	ldw	r2,-56(fp)
 8236c00:	10c00717 	ldw	r3,28(r2)
 8236c04:	e0bfe617 	ldw	r2,-104(fp)
 8236c08:	10801a17 	ldw	r2,104(r2)
 8236c0c:	1885c83a 	sub	r2,r3,r2
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236c10:	00800a0e 	bge	zero,r2,8236c3c <tcp_input+0x1688>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236c14:	008209b4 	movhi	r2,2086
 8236c18:	10b7f404 	addi	r2,r2,-8240
 8236c1c:	10800717 	ldw	r2,28(r2)
 8236c20:	10c00044 	addi	r3,r2,1
 8236c24:	008209b4 	movhi	r2,2086
 8236c28:	10b7f404 	addi	r2,r2,-8240
 8236c2c:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 8236c30:	00813184 	movi	r2,1222
 8236c34:	d0a0b215 	stw	r2,-32056(gp)
 8236c38:	0002cf06 	br	8237778 <tcp_input+0x21c4>
      }
      tcpstat.tcps_connects++;
 8236c3c:	008209b4 	movhi	r2,2086
 8236c40:	10b82204 	addi	r2,r2,-8056
 8236c44:	10800217 	ldw	r2,8(r2)
 8236c48:	10c00044 	addi	r3,r2,1
 8236c4c:	008209b4 	movhi	r2,2086
 8236c50:	10b82204 	addi	r2,r2,-8056
 8236c54:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 8236c58:	e0bfe617 	ldw	r2,-104(fp)
 8236c5c:	00c00104 	movi	r3,4
 8236c60:	10c00215 	stw	r3,8(r2)
      soisconnected(so);
 8236c64:	e13fe817 	ldw	r4,-96(fp)
 8236c68:	823370c0 	call	823370c <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 8236c6c:	e13fe817 	ldw	r4,-96(fp)
 8236c70:	8237e3c0 	call	8237e3c <tcp_mss>
 8236c74:	1007883a 	mov	r3,r2
 8236c78:	e0bfe617 	ldw	r2,-104(fp)
 8236c7c:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 8236c80:	e1bffe17 	ldw	r6,-8(fp)
 8236c84:	000b883a 	mov	r5,zero
 8236c88:	e13fe617 	ldw	r4,-104(fp)
 8236c8c:	82351a40 	call	82351a4 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 8236c90:	e0bff217 	ldw	r2,-56(fp)
 8236c94:	10800617 	ldw	r2,24(r2)
 8236c98:	10ffffc4 	addi	r3,r2,-1
 8236c9c:	e0bfe617 	ldw	r2,-104(fp)
 8236ca0:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 8236ca4:	e0bff217 	ldw	r2,-56(fp)
 8236ca8:	10c00717 	ldw	r3,28(r2)
 8236cac:	e0bfe617 	ldw	r2,-104(fp)
 8236cb0:	10800e17 	ldw	r2,56(r2)
 8236cb4:	1885c83a 	sub	r2,r3,r2
 8236cb8:	00806316 	blt	zero,r2,8236e48 <tcp_input+0x1894>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 8236cbc:	e0bff217 	ldw	r2,-56(fp)
 8236cc0:	1080028b 	ldhu	r2,10(r2)
 8236cc4:	10bfffcc 	andi	r2,r2,65535
 8236cc8:	10005a1e 	bne	r2,zero,8236e34 <tcp_input+0x1880>
 8236ccc:	e0bfe617 	ldw	r2,-104(fp)
 8236cd0:	10c01417 	ldw	r3,80(r2)
 8236cd4:	e0bff517 	ldw	r2,-44(fp)
 8236cd8:	1880561e 	bne	r3,r2,8236e34 <tcp_input+0x1880>
         {
            tcpstat.tcps_rcvdupack++;
 8236cdc:	008209b4 	movhi	r2,2086
 8236ce0:	10b82204 	addi	r2,r2,-8056
 8236ce4:	10802917 	ldw	r2,164(r2)
 8236ce8:	10c00044 	addi	r3,r2,1
 8236cec:	008209b4 	movhi	r2,2086
 8236cf0:	10b82204 	addi	r2,r2,-8056
 8236cf4:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236cf8:	e0bfe617 	ldw	r2,-104(fp)
 8236cfc:	10800317 	ldw	r2,12(r2)
 8236d00:	10000526 	beq	r2,zero,8236d18 <tcp_input+0x1764>
                ti->ti_ack != tp->snd_una)
 8236d04:	e0bff217 	ldw	r2,-56(fp)
 8236d08:	10c00717 	ldw	r3,28(r2)
 8236d0c:	e0bfe617 	ldw	r2,-104(fp)
 8236d10:	10800e17 	ldw	r2,56(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236d14:	18800326 	beq	r3,r2,8236d24 <tcp_input+0x1770>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 8236d18:	e0bfe617 	ldw	r2,-104(fp)
 8236d1c:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236d20:	00004706 	br	8236e40 <tcp_input+0x188c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 8236d24:	e0bfe617 	ldw	r2,-104(fp)
 8236d28:	10800917 	ldw	r2,36(r2)
 8236d2c:	10c00044 	addi	r3,r2,1
 8236d30:	e0bfe617 	ldw	r2,-104(fp)
 8236d34:	10c00915 	stw	r3,36(r2)
 8236d38:	e0bfe617 	ldw	r2,-104(fp)
 8236d3c:	10c00917 	ldw	r3,36(r2)
 8236d40:	d0a03c83 	ldbu	r2,-32526(gp)
 8236d44:	10803fcc 	andi	r2,r2,255
 8236d48:	1080201c 	xori	r2,r2,128
 8236d4c:	10bfe004 	addi	r2,r2,-128
 8236d50:	18803b1e 	bne	r3,r2,8236e40 <tcp_input+0x188c>
            {
               tcp_seq onxt = tp->snd_nxt;
 8236d54:	e0bfe617 	ldw	r2,-104(fp)
 8236d58:	10800f17 	ldw	r2,60(r2)
 8236d5c:	e0bff815 	stw	r2,-32(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8236d60:	e0bfe617 	ldw	r2,-104(fp)
 8236d64:	11001417 	ldw	r4,80(r2)
 8236d68:	e0bfe617 	ldw	r2,-104(fp)
 8236d6c:	10c01b17 	ldw	r3,108(r2)
 8236d70:	2005883a 	mov	r2,r4
 8236d74:	1880012e 	bgeu	r3,r2,8236d7c <tcp_input+0x17c8>
 8236d78:	1805883a 	mov	r2,r3
 8236d7c:	1006d07a 	srli	r3,r2,1
               tp->t_maxseg;
 8236d80:	e0bfe617 	ldw	r2,-104(fp)
 8236d84:	10800a0b 	ldhu	r2,40(r2)
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8236d88:	10bfffcc 	andi	r2,r2,65535
 8236d8c:	100b883a 	mov	r5,r2
 8236d90:	1809883a 	mov	r4,r3
 8236d94:	820270c0 	call	820270c <__udivsi3>
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
 8236d98:	e0bff00d 	sth	r2,-64(fp)
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;

               if (win < 2)
 8236d9c:	e0bff00b 	ldhu	r2,-64(fp)
 8236da0:	108000a8 	cmpgeui	r2,r2,2
 8236da4:	1000021e 	bne	r2,zero,8236db0 <tcp_input+0x17fc>
                  win = 2;
 8236da8:	00800084 	movi	r2,2
 8236dac:	e0bff00d 	sth	r2,-64(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 8236db0:	e0bfe617 	ldw	r2,-104(fp)
 8236db4:	10c00a0b 	ldhu	r3,40(r2)
 8236db8:	e0bff00b 	ldhu	r2,-64(fp)
 8236dbc:	1885383a 	mul	r2,r3,r2
 8236dc0:	10ffffcc 	andi	r3,r2,65535
 8236dc4:	e0bfe617 	ldw	r2,-104(fp)
 8236dc8:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 8236dcc:	e0bfe617 	ldw	r2,-104(fp)
 8236dd0:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 8236dd4:	e0bfe617 	ldw	r2,-104(fp)
 8236dd8:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 8236ddc:	e0bff217 	ldw	r2,-56(fp)
 8236de0:	10c00717 	ldw	r3,28(r2)
 8236de4:	e0bfe617 	ldw	r2,-104(fp)
 8236de8:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 8236dec:	e0bfe617 	ldw	r2,-104(fp)
 8236df0:	10800a0b 	ldhu	r2,40(r2)
 8236df4:	10ffffcc 	andi	r3,r2,65535
 8236df8:	e0bfe617 	ldw	r2,-104(fp)
 8236dfc:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 8236e00:	e13fe617 	ldw	r4,-104(fp)
 8236e04:	8237f340 	call	8237f34 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 8236e08:	e0bfe617 	ldw	r2,-104(fp)
 8236e0c:	10800f17 	ldw	r2,60(r2)
 8236e10:	e0fff817 	ldw	r3,-32(fp)
 8236e14:	1885c83a 	sub	r2,r3,r2
 8236e18:	0080030e 	bge	zero,r2,8236e28 <tcp_input+0x1874>
                  tp->snd_nxt = onxt;
 8236e1c:	e0bfe617 	ldw	r2,-104(fp)
 8236e20:	e0fff817 	ldw	r3,-32(fp)
 8236e24:	10c00f15 	stw	r3,60(r2)
               GOTO_DROP;
 8236e28:	00814544 	movi	r2,1301
 8236e2c:	d0a0b215 	stw	r2,-32056(gp)
 8236e30:	00029206 	br	823787c <tcp_input+0x22c8>
            }
         } else
            tp->t_dupacks = 0;
 8236e34:	e0bfe617 	ldw	r2,-104(fp)
 8236e38:	10000915 	stw	zero,36(r2)
         break;
 8236e3c:	0000da06 	br	82371a8 <tcp_input+0x1bf4>
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236e40:	0001883a 	nop
                  tp->snd_nxt = onxt;
               GOTO_DROP;
            }
         } else
            tp->t_dupacks = 0;
         break;
 8236e44:	0000d806 	br	82371a8 <tcp_input+0x1bf4>
      }
      tp->t_dupacks = 0;
 8236e48:	e0bfe617 	ldw	r2,-104(fp)
 8236e4c:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 8236e50:	e0bff217 	ldw	r2,-56(fp)
 8236e54:	10c00717 	ldw	r3,28(r2)
 8236e58:	e0bfe617 	ldw	r2,-104(fp)
 8236e5c:	10801a17 	ldw	r2,104(r2)
 8236e60:	1885c83a 	sub	r2,r3,r2
 8236e64:	0080080e 	bge	zero,r2,8236e88 <tcp_input+0x18d4>
      {
         tcpstat.tcps_rcvacktoomuch++;
 8236e68:	008209b4 	movhi	r2,2086
 8236e6c:	10b82204 	addi	r2,r2,-8056
 8236e70:	10802a17 	ldw	r2,168(r2)
 8236e74:	10c00044 	addi	r3,r2,1
 8236e78:	008209b4 	movhi	r2,2086
 8236e7c:	10b82204 	addi	r2,r2,-8056
 8236e80:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 8236e84:	00022b06 	br	8237734 <tcp_input+0x2180>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 8236e88:	e0bff217 	ldw	r2,-56(fp)
 8236e8c:	10c00717 	ldw	r3,28(r2)
 8236e90:	e0bfe617 	ldw	r2,-104(fp)
 8236e94:	10800e17 	ldw	r2,56(r2)
 8236e98:	1885c83a 	sub	r2,r3,r2
 8236e9c:	e0bff615 	stw	r2,-40(fp)
      tcpstat.tcps_rcvackpack++;
 8236ea0:	008209b4 	movhi	r2,2086
 8236ea4:	10b82204 	addi	r2,r2,-8056
 8236ea8:	10802b17 	ldw	r2,172(r2)
 8236eac:	10c00044 	addi	r3,r2,1
 8236eb0:	008209b4 	movhi	r2,2086
 8236eb4:	10b82204 	addi	r2,r2,-8056
 8236eb8:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 8236ebc:	008209b4 	movhi	r2,2086
 8236ec0:	10b82204 	addi	r2,r2,-8056
 8236ec4:	10c02c17 	ldw	r3,176(r2)
 8236ec8:	e0bff617 	ldw	r2,-40(fp)
 8236ecc:	1887883a 	add	r3,r3,r2
 8236ed0:	008209b4 	movhi	r2,2086
 8236ed4:	10b82204 	addi	r2,r2,-8056
 8236ed8:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8236edc:	e0bfe617 	ldw	r2,-104(fp)
 8236ee0:	10801e17 	ldw	r2,120(r2)
 8236ee4:	10000826 	beq	r2,zero,8236f08 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8236ee8:	e0bff217 	ldw	r2,-56(fp)
 8236eec:	10c00717 	ldw	r3,28(r2)
 8236ef0:	e0bfe617 	ldw	r2,-104(fp)
 8236ef4:	10801f17 	ldw	r2,124(r2)
 8236ef8:	1885c83a 	sub	r2,r3,r2
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8236efc:	0080020e 	bge	zero,r2,8236f08 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 8236f00:	e13fe617 	ldw	r4,-104(fp)
 8236f04:	8237b980 	call	8237b98 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 8236f08:	e0bff217 	ldw	r2,-56(fp)
 8236f0c:	10c00717 	ldw	r3,28(r2)
 8236f10:	e0bfe617 	ldw	r2,-104(fp)
 8236f14:	10801a17 	ldw	r2,104(r2)
 8236f18:	1880051e 	bne	r3,r2,8236f30 <tcp_input+0x197c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 8236f1c:	e0bfe617 	ldw	r2,-104(fp)
 8236f20:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 8236f24:	00800044 	movi	r2,1
 8236f28:	e0bfeb15 	stw	r2,-84(fp)
 8236f2c:	00000706 	br	8236f4c <tcp_input+0x1998>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 8236f30:	e0bfe617 	ldw	r2,-104(fp)
 8236f34:	10800417 	ldw	r2,16(r2)
 8236f38:	1000041e 	bne	r2,zero,8236f4c <tcp_input+0x1998>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8236f3c:	e0bfe617 	ldw	r2,-104(fp)
 8236f40:	10c00817 	ldw	r3,32(r2)
 8236f44:	e0bfe617 	ldw	r2,-104(fp)
 8236f48:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 8236f4c:	e0bfe617 	ldw	r2,-104(fp)
 8236f50:	10801b17 	ldw	r2,108(r2)
 8236f54:	e0bff915 	stw	r2,-28(fp)
         u_short  incr  =  tp->t_maxseg;
 8236f58:	e0bfe617 	ldw	r2,-104(fp)
 8236f5c:	10800a0b 	ldhu	r2,40(r2)
 8236f60:	e0bff08d 	sth	r2,-62(fp)

         if (cw > tp->snd_ssthresh)
 8236f64:	e0bfe617 	ldw	r2,-104(fp)
 8236f68:	10c01c17 	ldw	r3,112(r2)
 8236f6c:	e0bff917 	ldw	r2,-28(fp)
 8236f70:	18800a2e 	bgeu	r3,r2,8236f9c <tcp_input+0x19e8>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 8236f74:	e0fff08b 	ldhu	r3,-62(fp)
 8236f78:	e0bff08b 	ldhu	r2,-62(fp)
 8236f7c:	1885383a 	mul	r2,r3,r2
 8236f80:	e17ff917 	ldw	r5,-28(fp)
 8236f84:	1009883a 	mov	r4,r2
 8236f88:	820270c0 	call	820270c <__udivsi3>
 8236f8c:	10c00428 	cmpgeui	r3,r2,16
 8236f90:	1800011e 	bne	r3,zero,8236f98 <tcp_input+0x19e4>
 8236f94:	00800404 	movi	r2,16
 8236f98:	e0bff08d 	sth	r2,-62(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 8236f9c:	e0fff08b 	ldhu	r3,-62(fp)
 8236fa0:	e0bff917 	ldw	r2,-28(fp)
 8236fa4:	1885883a 	add	r2,r3,r2
 8236fa8:	10d80070 	cmpltui	r3,r2,24577
 8236fac:	1800011e 	bne	r3,zero,8236fb4 <tcp_input+0x1a00>
 8236fb0:	00980004 	movi	r2,24576
 8236fb4:	e0ffe617 	ldw	r3,-104(fp)
 8236fb8:	18801b15 	stw	r2,108(r3)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 8236fbc:	e0bfe817 	ldw	r2,-96(fp)
 8236fc0:	10801217 	ldw	r2,72(r2)
 8236fc4:	1007883a 	mov	r3,r2
 8236fc8:	e0bff617 	ldw	r2,-40(fp)
 8236fcc:	1880120e 	bge	r3,r2,8237018 <tcp_input+0x1a64>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 8236fd0:	e0bfe617 	ldw	r2,-104(fp)
 8236fd4:	10c01417 	ldw	r3,80(r2)
 8236fd8:	e0bfe817 	ldw	r2,-96(fp)
 8236fdc:	10801217 	ldw	r2,72(r2)
 8236fe0:	10bfffcc 	andi	r2,r2,65535
 8236fe4:	1887c83a 	sub	r3,r3,r2
 8236fe8:	e0bfe617 	ldw	r2,-104(fp)
 8236fec:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 8236ff0:	e0bfe817 	ldw	r2,-96(fp)
 8236ff4:	10c01204 	addi	r3,r2,72
 8236ff8:	e0bfe817 	ldw	r2,-96(fp)
 8236ffc:	10801217 	ldw	r2,72(r2)
 8237000:	100b883a 	mov	r5,r2
 8237004:	1809883a 	mov	r4,r3
 8237008:	82345e00 	call	82345e0 <sbdrop>
         ourfinisacked = 1;
 823700c:	00800044 	movi	r2,1
 8237010:	e0bfea15 	stw	r2,-88(fp)
 8237014:	00000d06 	br	823704c <tcp_input+0x1a98>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 8237018:	e0bfe817 	ldw	r2,-96(fp)
 823701c:	10801204 	addi	r2,r2,72
 8237020:	e17ff617 	ldw	r5,-40(fp)
 8237024:	1009883a 	mov	r4,r2
 8237028:	82345e00 	call	82345e0 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 823702c:	e0bfe617 	ldw	r2,-104(fp)
 8237030:	10c01417 	ldw	r3,80(r2)
 8237034:	e0bff617 	ldw	r2,-40(fp)
 8237038:	10bfffcc 	andi	r2,r2,65535
 823703c:	1887c83a 	sub	r3,r3,r2
 8237040:	e0bfe617 	ldw	r2,-104(fp)
 8237044:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 8237048:	e03fea15 	stw	zero,-88(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 823704c:	e0bfe817 	ldw	r2,-96(fp)
 8237050:	1080190b 	ldhu	r2,100(r2)
 8237054:	10bfffcc 	andi	r2,r2,65535
 8237058:	1080030c 	andi	r2,r2,12
 823705c:	10000526 	beq	r2,zero,8237074 <tcp_input+0x1ac0>
         sowwakeup(so);
 8237060:	e0bfe817 	ldw	r2,-96(fp)
 8237064:	10801204 	addi	r2,r2,72
 8237068:	100b883a 	mov	r5,r2
 823706c:	e13fe817 	ldw	r4,-96(fp)
 8237070:	8233e780 	call	8233e78 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 8237074:	e0bff217 	ldw	r2,-56(fp)
 8237078:	10c00717 	ldw	r3,28(r2)
 823707c:	e0bfe617 	ldw	r2,-104(fp)
 8237080:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 8237084:	e0bfe617 	ldw	r2,-104(fp)
 8237088:	10c00f17 	ldw	r3,60(r2)
 823708c:	e0bfe617 	ldw	r2,-104(fp)
 8237090:	10800e17 	ldw	r2,56(r2)
 8237094:	1885c83a 	sub	r2,r3,r2
 8237098:	1000040e 	bge	r2,zero,82370ac <tcp_input+0x1af8>
         tp->snd_nxt = tp->snd_una;
 823709c:	e0bfe617 	ldw	r2,-104(fp)
 82370a0:	10c00e17 	ldw	r3,56(r2)
 82370a4:	e0bfe617 	ldw	r2,-104(fp)
 82370a8:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 82370ac:	e0bfe617 	ldw	r2,-104(fp)
 82370b0:	10800217 	ldw	r2,8(r2)
 82370b4:	10c001e0 	cmpeqi	r3,r2,7
 82370b8:	18001a1e 	bne	r3,zero,8237124 <tcp_input+0x1b70>
 82370bc:	10c00208 	cmpgei	r3,r2,8
 82370c0:	1800031e 	bne	r3,zero,82370d0 <tcp_input+0x1b1c>
 82370c4:	108001a0 	cmpeqi	r2,r2,6
 82370c8:	1000061e 	bne	r2,zero,82370e4 <tcp_input+0x1b30>
 82370cc:	00003606 	br	82371a8 <tcp_input+0x1bf4>
 82370d0:	10c00220 	cmpeqi	r3,r2,8
 82370d4:	1800221e 	bne	r3,zero,8237160 <tcp_input+0x1bac>
 82370d8:	108002a0 	cmpeqi	r2,r2,10
 82370dc:	1000271e 	bne	r2,zero,823717c <tcp_input+0x1bc8>
 82370e0:	00003106 	br	82371a8 <tcp_input+0x1bf4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 82370e4:	e0bfea17 	ldw	r2,-88(fp)
 82370e8:	10002a26 	beq	r2,zero,8237194 <tcp_input+0x1be0>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 82370ec:	e0bfe817 	ldw	r2,-96(fp)
 82370f0:	1080088b 	ldhu	r2,34(r2)
 82370f4:	10bfffcc 	andi	r2,r2,65535
 82370f8:	1080080c 	andi	r2,r2,32
 82370fc:	10000526 	beq	r2,zero,8237114 <tcp_input+0x1b60>
            {
               soisdisconnected(so);
 8237100:	e13fe817 	ldw	r4,-96(fp)
 8237104:	82338a80 	call	82338a8 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 8237108:	d0e0b417 	ldw	r3,-32048(gp)
 823710c:	e0bfe617 	ldw	r2,-104(fp)
 8237110:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 8237114:	e0bfe617 	ldw	r2,-104(fp)
 8237118:	00c00244 	movi	r3,9
 823711c:	10c00215 	stw	r3,8(r2)
         }
         break;
 8237120:	00001c06 	br	8237194 <tcp_input+0x1be0>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 8237124:	e0bfea17 	ldw	r2,-88(fp)
 8237128:	10001c26 	beq	r2,zero,823719c <tcp_input+0x1be8>
         {
            tp->t_state = TCPS_TIME_WAIT;
 823712c:	e0bfe617 	ldw	r2,-104(fp)
 8237130:	00c00284 	movi	r3,10
 8237134:	10c00215 	stw	r3,8(r2)
            tcp_canceltimers(tp);
 8237138:	e13fe617 	ldw	r4,-104(fp)
 823713c:	8239cac0 	call	8239cac <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237140:	d0a03b17 	ldw	r2,-32532(gp)
 8237144:	1085883a 	add	r2,r2,r2
 8237148:	1007883a 	mov	r3,r2
 823714c:	e0bfe617 	ldw	r2,-104(fp)
 8237150:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 8237154:	e13fe817 	ldw	r4,-96(fp)
 8237158:	82338a80 	call	82338a8 <soisdisconnected>
         }
         break;
 823715c:	00000f06 	br	823719c <tcp_input+0x1be8>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 8237160:	e0bfea17 	ldw	r2,-88(fp)
 8237164:	10000f26 	beq	r2,zero,82371a4 <tcp_input+0x1bf0>
         {
            SETTP(tp, tcp_close(tp));
 8237168:	e13fe617 	ldw	r4,-104(fp)
 823716c:	82398140 	call	8239814 <tcp_close>
            GOTO_DROP;
 8237170:	00816644 	movi	r2,1433
 8237174:	d0a0b215 	stw	r2,-32056(gp)
 8237178:	0001c006 	br	823787c <tcp_input+0x22c8>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 823717c:	d0a03b17 	ldw	r2,-32532(gp)
 8237180:	1085883a 	add	r2,r2,r2
 8237184:	1007883a 	mov	r3,r2
 8237188:	e0bfe617 	ldw	r2,-104(fp)
 823718c:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 8237190:	00016806 	br	8237734 <tcp_input+0x2180>
               soisdisconnected(so);
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
            }
            tp->t_state = TCPS_FIN_WAIT_2;
         }
         break;
 8237194:	0001883a 	nop
 8237198:	00000306 	br	82371a8 <tcp_input+0x1bf4>
            tp->t_state = TCPS_TIME_WAIT;
            tcp_canceltimers(tp);
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
            soisdisconnected(so);
         }
         break;
 823719c:	0001883a 	nop
 82371a0:	00000106 	br	82371a8 <tcp_input+0x1bf4>
         if (ourfinisacked) 
         {
            SETTP(tp, tcp_close(tp));
            GOTO_DROP;
         }
         break;
 82371a4:	0001883a 	nop
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82371a8:	e0bfe717 	ldw	r2,-100(fp)
 82371ac:	1080040c 	andi	r2,r2,16
 82371b0:	10004426 	beq	r2,zero,82372c4 <tcp_input+0x1d10>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82371b4:	e0bfe617 	ldw	r2,-104(fp)
 82371b8:	10c01117 	ldw	r3,68(r2)
 82371bc:	e0bff217 	ldw	r2,-56(fp)
 82371c0:	10800617 	ldw	r2,24(r2)
 82371c4:	1885c83a 	sub	r2,r3,r2
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82371c8:	10001416 	blt	r2,zero,823721c <tcp_input+0x1c68>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82371cc:	e0bfe617 	ldw	r2,-104(fp)
 82371d0:	10c01117 	ldw	r3,68(r2)
 82371d4:	e0bff217 	ldw	r2,-56(fp)
 82371d8:	10800617 	ldw	r2,24(r2)
 82371dc:	1880391e 	bne	r3,r2,82372c4 <tcp_input+0x1d10>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 82371e0:	e0bfe617 	ldw	r2,-104(fp)
 82371e4:	10c01217 	ldw	r3,72(r2)
 82371e8:	e0bff217 	ldw	r2,-56(fp)
 82371ec:	10800717 	ldw	r2,28(r2)
 82371f0:	1885c83a 	sub	r2,r3,r2
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82371f4:	10000916 	blt	r2,zero,823721c <tcp_input+0x1c68>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 82371f8:	e0bfe617 	ldw	r2,-104(fp)
 82371fc:	10c01217 	ldw	r3,72(r2)
 8237200:	e0bff217 	ldw	r2,-56(fp)
 8237204:	10800717 	ldw	r2,28(r2)
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 8237208:	18802e1e 	bne	r3,r2,82372c4 <tcp_input+0x1d10>
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 823720c:	e0bfe617 	ldw	r2,-104(fp)
 8237210:	10c01417 	ldw	r3,80(r2)
 8237214:	e0bff517 	ldw	r2,-44(fp)
 8237218:	18802a2e 	bgeu	r3,r2,82372c4 <tcp_input+0x1d10>
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 823721c:	e0bff217 	ldw	r2,-56(fp)
 8237220:	1080028b 	ldhu	r2,10(r2)
 8237224:	10bfffcc 	andi	r2,r2,65535
 8237228:	1000101e 	bne	r2,zero,823726c <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
 823722c:	e0bfe617 	ldw	r2,-104(fp)
 8237230:	10c01217 	ldw	r3,72(r2)
 8237234:	e0bff217 	ldw	r2,-56(fp)
 8237238:	10800717 	ldw	r2,28(r2)
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 823723c:	18800b1e 	bne	r3,r2,823726c <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
 8237240:	e0bfe617 	ldw	r2,-104(fp)
 8237244:	10c01417 	ldw	r3,80(r2)
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
          (tp->snd_wl2 == ti->ti_ack) &&
 8237248:	e0bff517 	ldw	r2,-44(fp)
 823724c:	1880072e 	bgeu	r3,r2,823726c <tcp_input+0x1cb8>
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 8237250:	008209b4 	movhi	r2,2086
 8237254:	10b82204 	addi	r2,r2,-8056
 8237258:	10802d17 	ldw	r2,180(r2)
 823725c:	10c00044 	addi	r3,r2,1
 8237260:	008209b4 	movhi	r2,2086
 8237264:	10b82204 	addi	r2,r2,-8056
 8237268:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 823726c:	e0bfe617 	ldw	r2,-104(fp)
 8237270:	e0fff517 	ldw	r3,-44(fp)
 8237274:	10c01415 	stw	r3,80(r2)
      tp->snd_wl1 = ti->ti_seq;
 8237278:	e0bff217 	ldw	r2,-56(fp)
 823727c:	10c00617 	ldw	r3,24(r2)
 8237280:	e0bfe617 	ldw	r2,-104(fp)
 8237284:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 8237288:	e0bff217 	ldw	r2,-56(fp)
 823728c:	10c00717 	ldw	r3,28(r2)
 8237290:	e0bfe617 	ldw	r2,-104(fp)
 8237294:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 8237298:	e0bfe617 	ldw	r2,-104(fp)
 823729c:	10801417 	ldw	r2,80(r2)
 82372a0:	e0ffe617 	ldw	r3,-104(fp)
 82372a4:	18c02317 	ldw	r3,140(r3)
 82372a8:	1880042e 	bgeu	r3,r2,82372bc <tcp_input+0x1d08>
         tp->max_sndwnd = tp->snd_wnd;
 82372ac:	e0bfe617 	ldw	r2,-104(fp)
 82372b0:	10c01417 	ldw	r3,80(r2)
 82372b4:	e0bfe617 	ldw	r2,-104(fp)
 82372b8:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 82372bc:	00800044 	movi	r2,1
 82372c0:	e0bfeb15 	stw	r2,-84(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 82372c4:	e0bfe717 	ldw	r2,-100(fp)
 82372c8:	1080080c 	andi	r2,r2,32
 82372cc:	10005626 	beq	r2,zero,8237428 <tcp_input+0x1e74>
 82372d0:	e0bff217 	ldw	r2,-56(fp)
 82372d4:	1080098b 	ldhu	r2,38(r2)
 82372d8:	10bfffcc 	andi	r2,r2,65535
 82372dc:	10005226 	beq	r2,zero,8237428 <tcp_input+0x1e74>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 82372e0:	e0bfe617 	ldw	r2,-104(fp)
 82372e4:	10800217 	ldw	r2,8(r2)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 82372e8:	10800288 	cmpgei	r2,r2,10
 82372ec:	10004e1e 	bne	r2,zero,8237428 <tcp_input+0x1e74>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 82372f0:	e0bff217 	ldw	r2,-56(fp)
 82372f4:	1080098b 	ldhu	r2,38(r2)
 82372f8:	10ffffcc 	andi	r3,r2,65535
 82372fc:	e0bfe817 	ldw	r2,-96(fp)
 8237300:	10800a17 	ldw	r2,40(r2)
 8237304:	1885883a 	add	r2,r3,r2
 8237308:	10900070 	cmpltui	r2,r2,16385
 823730c:	1000071e 	bne	r2,zero,823732c <tcp_input+0x1d78>
      {
         ti->ti_urp = 0;         /* XXX */
 8237310:	e0bff217 	ldw	r2,-56(fp)
 8237314:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 8237318:	e0ffe717 	ldw	r3,-100(fp)
 823731c:	00bff7c4 	movi	r2,-33
 8237320:	1884703a 	and	r2,r3,r2
 8237324:	e0bfe715 	stw	r2,-100(fp)
         goto dodata;         /* XXX */
 8237328:	00004b06 	br	8237458 <tcp_input+0x1ea4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 823732c:	e0bff217 	ldw	r2,-56(fp)
 8237330:	10c00617 	ldw	r3,24(r2)
 8237334:	e0bff217 	ldw	r2,-56(fp)
 8237338:	1080098b 	ldhu	r2,38(r2)
 823733c:	10bfffcc 	andi	r2,r2,65535
 8237340:	1887883a 	add	r3,r3,r2
 8237344:	e0bfe617 	ldw	r2,-104(fp)
 8237348:	10801717 	ldw	r2,92(r2)
 823734c:	1885c83a 	sub	r2,r3,r2
 8237350:	0080250e 	bge	zero,r2,82373e8 <tcp_input+0x1e34>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 8237354:	e0bff217 	ldw	r2,-56(fp)
 8237358:	10c00617 	ldw	r3,24(r2)
 823735c:	e0bff217 	ldw	r2,-56(fp)
 8237360:	1080098b 	ldhu	r2,38(r2)
 8237364:	10bfffcc 	andi	r2,r2,65535
 8237368:	1887883a 	add	r3,r3,r2
 823736c:	e0bfe617 	ldw	r2,-104(fp)
 8237370:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 8237374:	e0bfe817 	ldw	r2,-96(fp)
 8237378:	10c00a17 	ldw	r3,40(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
 823737c:	e0bfe617 	ldw	r2,-104(fp)
 8237380:	11001717 	ldw	r4,92(r2)
 8237384:	e0bfe617 	ldw	r2,-104(fp)
 8237388:	10801617 	ldw	r2,88(r2)
 823738c:	2085c83a 	sub	r2,r4,r2
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 8237390:	1885883a 	add	r2,r3,r2
         (tp->rcv_up - tp->rcv_nxt) - 1;
 8237394:	10ffffc4 	addi	r3,r2,-1
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 8237398:	e0bfe817 	ldw	r2,-96(fp)
 823739c:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 82373a0:	e0bfe817 	ldw	r2,-96(fp)
 82373a4:	10801a17 	ldw	r2,104(r2)
 82373a8:	1000061e 	bne	r2,zero,82373c4 <tcp_input+0x1e10>
            so->so_state |= SS_RCVATMARK;
 82373ac:	e0bfe817 	ldw	r2,-96(fp)
 82373b0:	1080088b 	ldhu	r2,34(r2)
 82373b4:	10801014 	ori	r2,r2,64
 82373b8:	1007883a 	mov	r3,r2
 82373bc:	e0bfe817 	ldw	r2,-96(fp)
 82373c0:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 82373c4:	e13fe817 	ldw	r4,-96(fp)
 82373c8:	82336500 	call	8233650 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 82373cc:	e0bfe617 	ldw	r2,-104(fp)
 82373d0:	10c02403 	ldbu	r3,144(r2)
 82373d4:	00bfff04 	movi	r2,-4
 82373d8:	1884703a 	and	r2,r3,r2
 82373dc:	1007883a 	mov	r3,r2
 82373e0:	e0bfe617 	ldw	r2,-104(fp)
 82373e4:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 82373e8:	e0bff217 	ldw	r2,-56(fp)
 82373ec:	1100098b 	ldhu	r4,38(r2)
 82373f0:	e0bff217 	ldw	r2,-56(fp)
 82373f4:	10c0028b 	ldhu	r3,10(r2)
 82373f8:	20bfffcc 	andi	r2,r4,65535
 82373fc:	18ffffcc 	andi	r3,r3,65535
 8237400:	18801436 	bltu	r3,r2,8237454 <tcp_input+0x1ea0>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
 8237404:	e0bfe817 	ldw	r2,-96(fp)
 8237408:	10800417 	ldw	r2,16(r2)
 823740c:	1080400c 	andi	r2,r2,256
 8237410:	1000101e 	bne	r2,zero,8237454 <tcp_input+0x1ea0>
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 8237414:	e1bffe17 	ldw	r6,-8(fp)
 8237418:	e17ff217 	ldw	r5,-56(fp)
 823741c:	e13fe817 	ldw	r4,-96(fp)
 8237420:	8237a6c0 	call	8237a6c <tcp_pulloutofband>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237424:	00000b06 	br	8237454 <tcp_input+0x1ea0>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 8237428:	e0bfe617 	ldw	r2,-104(fp)
 823742c:	10c01617 	ldw	r3,88(r2)
 8237430:	e0bfe617 	ldw	r2,-104(fp)
 8237434:	10801717 	ldw	r2,92(r2)
 8237438:	1885c83a 	sub	r2,r3,r2
 823743c:	0080060e 	bge	zero,r2,8237458 <tcp_input+0x1ea4>
      tp->rcv_up = tp->rcv_nxt;
 8237440:	e0bfe617 	ldw	r2,-104(fp)
 8237444:	10c01617 	ldw	r3,88(r2)
 8237448:	e0bfe617 	ldw	r2,-104(fp)
 823744c:	10c01715 	stw	r3,92(r2)
 8237450:	00000106 	br	8237458 <tcp_input+0x1ea4>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237454:	0001883a 	nop
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 8237458:	e0bff217 	ldw	r2,-56(fp)
 823745c:	1080028b 	ldhu	r2,10(r2)
 8237460:	10bfffcc 	andi	r2,r2,65535
 8237464:	1000031e 	bne	r2,zero,8237474 <tcp_input+0x1ec0>
 8237468:	e0bfe717 	ldw	r2,-100(fp)
 823746c:	1080004c 	andi	r2,r2,1
 8237470:	10005e26 	beq	r2,zero,82375ec <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 8237474:	e0bfe617 	ldw	r2,-104(fp)
 8237478:	10800217 	ldw	r2,8(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 823747c:	10800288 	cmpgei	r2,r2,10
 8237480:	10005a1e 	bne	r2,zero,82375ec <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 8237484:	e0bff217 	ldw	r2,-56(fp)
 8237488:	10c00617 	ldw	r3,24(r2)
 823748c:	e0bfe617 	ldw	r2,-104(fp)
 8237490:	10801617 	ldw	r2,88(r2)
 8237494:	1880371e 	bne	r3,r2,8237574 <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 8237498:	e0bfe617 	ldw	r2,-104(fp)
 823749c:	10c00017 	ldw	r3,0(r2)
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 82374a0:	e0bfe617 	ldw	r2,-104(fp)
 82374a4:	1880331e 	bne	r3,r2,8237574 <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
         (tp->t_state == TCPS_ESTABLISHED))
 82374a8:	e0bfe617 	ldw	r2,-104(fp)
 82374ac:	10800217 	ldw	r2,8(r2)
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82374b0:	10800118 	cmpnei	r2,r2,4
 82374b4:	10002f1e 	bne	r2,zero,8237574 <tcp_input+0x1fc0>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 82374b8:	e0bfe617 	ldw	r2,-104(fp)
 82374bc:	10800b0b 	ldhu	r2,44(r2)
 82374c0:	10800054 	ori	r2,r2,1
 82374c4:	1007883a 	mov	r3,r2
 82374c8:	e0bfe617 	ldw	r2,-104(fp)
 82374cc:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 82374d0:	e0bfe617 	ldw	r2,-104(fp)
 82374d4:	10c01617 	ldw	r3,88(r2)
 82374d8:	e0bff217 	ldw	r2,-56(fp)
 82374dc:	1080028b 	ldhu	r2,10(r2)
 82374e0:	10bfffcc 	andi	r2,r2,65535
 82374e4:	1887883a 	add	r3,r3,r2
 82374e8:	e0bfe617 	ldw	r2,-104(fp)
 82374ec:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 82374f0:	e0bff217 	ldw	r2,-56(fp)
 82374f4:	10800843 	ldbu	r2,33(r2)
 82374f8:	10803fcc 	andi	r2,r2,255
 82374fc:	1080004c 	andi	r2,r2,1
 8237500:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpack++;
 8237504:	008209b4 	movhi	r2,2086
 8237508:	10b82204 	addi	r2,r2,-8056
 823750c:	10801a17 	ldw	r2,104(r2)
 8237510:	10c00044 	addi	r3,r2,1
 8237514:	008209b4 	movhi	r2,2086
 8237518:	10b82204 	addi	r2,r2,-8056
 823751c:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8237520:	008209b4 	movhi	r2,2086
 8237524:	10b82204 	addi	r2,r2,-8056
 8237528:	10c01b17 	ldw	r3,108(r2)
 823752c:	e0bff217 	ldw	r2,-56(fp)
 8237530:	1080028b 	ldhu	r2,10(r2)
 8237534:	10bfffcc 	andi	r2,r2,65535
 8237538:	1887883a 	add	r3,r3,r2
 823753c:	008209b4 	movhi	r2,2086
 8237540:	10b82204 	addi	r2,r2,-8056
 8237544:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 8237548:	e0bfe817 	ldw	r2,-96(fp)
 823754c:	10800a04 	addi	r2,r2,40
 8237550:	e17ffe17 	ldw	r5,-8(fp)
 8237554:	1009883a 	mov	r4,r2
 8237558:	82340280 	call	8234028 <sbappend>
         sorwakeup(so);
 823755c:	e0bfe817 	ldw	r2,-96(fp)
 8237560:	10800a04 	addi	r2,r2,40
 8237564:	100b883a 	mov	r5,r2
 8237568:	e13fe817 	ldw	r4,-96(fp)
 823756c:	8233e780 	call	8233e78 <sbwakeup>
 8237570:	00000b06 	br	82375a0 <tcp_input+0x1fec>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 8237574:	e1bffe17 	ldw	r6,-8(fp)
 8237578:	e17ff217 	ldw	r5,-56(fp)
 823757c:	e13fe617 	ldw	r4,-104(fp)
 8237580:	82351a40 	call	82351a4 <tcp_reass>
 8237584:	e0bfe715 	stw	r2,-100(fp)
         tp->t_flags |= TF_ACKNOW;
 8237588:	e0bfe617 	ldw	r2,-104(fp)
 823758c:	10800b0b 	ldhu	r2,44(r2)
 8237590:	10800054 	ori	r2,r2,1
 8237594:	1007883a 	mov	r3,r2
 8237598:	e0bfe617 	ldw	r2,-104(fp)
 823759c:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 82375a0:	e0bfe817 	ldw	r2,-96(fp)
 82375a4:	10c00b17 	ldw	r3,44(r2)
 82375a8:	e0bfe617 	ldw	r2,-104(fp)
 82375ac:	11001617 	ldw	r4,88(r2)
 82375b0:	e0bfe617 	ldw	r2,-104(fp)
 82375b4:	10801917 	ldw	r2,100(r2)
 82375b8:	2085c83a 	sub	r2,r4,r2
 82375bc:	1885883a 	add	r2,r3,r2
 82375c0:	e0bffc15 	stw	r2,-16(fp)
      if (len > (int)tp->max_rcvd)
 82375c4:	e0bfe617 	ldw	r2,-104(fp)
 82375c8:	10802217 	ldw	r2,136(r2)
 82375cc:	1007883a 	mov	r3,r2
 82375d0:	e0bffc17 	ldw	r2,-16(fp)
 82375d4:	18800b0e 	bge	r3,r2,8237604 <tcp_input+0x2050>
         tp->max_rcvd = (u_short)len;
 82375d8:	e0bffc17 	ldw	r2,-16(fp)
 82375dc:	10ffffcc 	andi	r3,r2,65535
 82375e0:	e0bfe617 	ldw	r2,-104(fp)
 82375e4:	10c02215 	stw	r3,136(r2)
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
      if (len > (int)tp->max_rcvd)
 82375e8:	00000606 	br	8237604 <tcp_input+0x2050>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 82375ec:	e13ffe17 	ldw	r4,-8(fp)
 82375f0:	822e26c0 	call	822e26c <m_freem>
      tiflags &= ~TH_FIN;
 82375f4:	e0ffe717 	ldw	r3,-100(fp)
 82375f8:	00bfff84 	movi	r2,-2
 82375fc:	1884703a 	and	r2,r3,r2
 8237600:	e0bfe715 	stw	r2,-100(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 8237604:	e0bfe717 	ldw	r2,-100(fp)
 8237608:	1080004c 	andi	r2,r2,1
 823760c:	10003f26 	beq	r2,zero,823770c <tcp_input+0x2158>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 8237610:	e0bfe617 	ldw	r2,-104(fp)
 8237614:	10800217 	ldw	r2,8(r2)
 8237618:	10800288 	cmpgei	r2,r2,10
 823761c:	10000d1e 	bne	r2,zero,8237654 <tcp_input+0x20a0>
      {
         socantrcvmore(so);
 8237620:	e13fe817 	ldw	r4,-96(fp)
 8237624:	8233d780 	call	8233d78 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 8237628:	e0bfe617 	ldw	r2,-104(fp)
 823762c:	10800b0b 	ldhu	r2,44(r2)
 8237630:	10800054 	ori	r2,r2,1
 8237634:	1007883a 	mov	r3,r2
 8237638:	e0bfe617 	ldw	r2,-104(fp)
 823763c:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 8237640:	e0bfe617 	ldw	r2,-104(fp)
 8237644:	10801617 	ldw	r2,88(r2)
 8237648:	10c00044 	addi	r3,r2,1
 823764c:	e0bfe617 	ldw	r2,-104(fp)
 8237650:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 8237654:	e0bfe617 	ldw	r2,-104(fp)
 8237658:	10800217 	ldw	r2,8(r2)
 823765c:	10bfff44 	addi	r2,r2,-3
 8237660:	10c00228 	cmpgeui	r3,r2,8
 8237664:	1800291e 	bne	r3,zero,823770c <tcp_input+0x2158>
 8237668:	100690ba 	slli	r3,r2,2
 823766c:	008208f4 	movhi	r2,2083
 8237670:	109da004 	addi	r2,r2,30336
 8237674:	1885883a 	add	r2,r3,r2
 8237678:	10800017 	ldw	r2,0(r2)
 823767c:	1000683a 	jmp	r2
 8237680:	082376a0 	cmpeqi	zero,at,-29222
 8237684:	082376a0 	cmpeqi	zero,at,-29222
 8237688:	0823770c 	andi	zero,at,36316
 823768c:	082376b0 	cmpltui	zero,at,36314
 8237690:	0823770c 	andi	zero,at,36316
 8237694:	0823770c 	andi	zero,at,36316
 8237698:	082376c0 	call	82376c <OSCtxSw_SWITCH_PC+0x82372c>
 823769c:	082376f4 	orhi	zero,at,36315
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 82376a0:	e0bfe617 	ldw	r2,-104(fp)
 82376a4:	00c00144 	movi	r3,5
 82376a8:	10c00215 	stw	r3,8(r2)
         break;
 82376ac:	00001706 	br	823770c <tcp_input+0x2158>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 82376b0:	e0bfe617 	ldw	r2,-104(fp)
 82376b4:	00c001c4 	movi	r3,7
 82376b8:	10c00215 	stw	r3,8(r2)
         break;
 82376bc:	00001306 	br	823770c <tcp_input+0x2158>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 82376c0:	e0bfe617 	ldw	r2,-104(fp)
 82376c4:	00c00284 	movi	r3,10
 82376c8:	10c00215 	stw	r3,8(r2)
         tcp_canceltimers(tp);
 82376cc:	e13fe617 	ldw	r4,-104(fp)
 82376d0:	8239cac0 	call	8239cac <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 82376d4:	d0a03b17 	ldw	r2,-32532(gp)
 82376d8:	1085883a 	add	r2,r2,r2
 82376dc:	1007883a 	mov	r3,r2
 82376e0:	e0bfe617 	ldw	r2,-104(fp)
 82376e4:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 82376e8:	e13fe817 	ldw	r4,-96(fp)
 82376ec:	82338a80 	call	82338a8 <soisdisconnected>
         break;
 82376f0:	00000606 	br	823770c <tcp_input+0x2158>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 82376f4:	d0a03b17 	ldw	r2,-32532(gp)
 82376f8:	1085883a 	add	r2,r2,r2
 82376fc:	1007883a 	mov	r3,r2
 8237700:	e0bfe617 	ldw	r2,-104(fp)
 8237704:	10c00615 	stw	r3,24(r2)
         break;
 8237708:	0001883a 	nop
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 823770c:	e0bfeb17 	ldw	r2,-84(fp)
 8237710:	1000051e 	bne	r2,zero,8237728 <tcp_input+0x2174>
 8237714:	e0bfe617 	ldw	r2,-104(fp)
 8237718:	10800b0b 	ldhu	r2,44(r2)
 823771c:	10bfffcc 	andi	r2,r2,65535
 8237720:	1080004c 	andi	r2,r2,1
 8237724:	10006526 	beq	r2,zero,82378bc <tcp_input+0x2308>
      (void) tcp_output(tp);
 8237728:	e13fe617 	ldw	r4,-104(fp)
 823772c:	8237f340 	call	8237f34 <tcp_output>
   return;
 8237730:	00006206 	br	82378bc <tcp_input+0x2308>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 8237734:	e0bfe717 	ldw	r2,-100(fp)
 8237738:	1080010c 	andi	r2,r2,4
 823773c:	10000326 	beq	r2,zero,823774c <tcp_input+0x2198>
      GOTO_DROP;
 8237740:	0081a904 	movi	r2,1700
 8237744:	d0a0b215 	stw	r2,-32056(gp)
 8237748:	00004c06 	br	823787c <tcp_input+0x22c8>
   m_freem (m);
 823774c:	e13ffe17 	ldw	r4,-8(fp)
 8237750:	822e26c0 	call	822e26c <m_freem>
   tp->t_flags |= TF_ACKNOW;
 8237754:	e0bfe617 	ldw	r2,-104(fp)
 8237758:	10800b0b 	ldhu	r2,44(r2)
 823775c:	10800054 	ori	r2,r2,1
 8237760:	1007883a 	mov	r3,r2
 8237764:	e0bfe617 	ldw	r2,-104(fp)
 8237768:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 823776c:	e13fe617 	ldw	r4,-104(fp)
 8237770:	8237f340 	call	8237f34 <tcp_output>
   return;
 8237774:	00005606 	br	82378d0 <tcp_input+0x231c>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 8237778:	008209b4 	movhi	r2,2086
 823777c:	10b7f404 	addi	r2,r2,-8240
 8237780:	10800d17 	ldw	r2,52(r2)
 8237784:	10c00044 	addi	r3,r2,1
 8237788:	008209b4 	movhi	r2,2086
 823778c:	10b7f404 	addi	r2,r2,-8240
 8237790:	10c00d15 	stw	r3,52(r2)
   if (om) 
 8237794:	e0bfe517 	ldw	r2,-108(fp)
 8237798:	10000326 	beq	r2,zero,82377a8 <tcp_input+0x21f4>
   {
      (void) m_free(om);
 823779c:	e13fe517 	ldw	r4,-108(fp)
 82377a0:	822e1640 	call	822e164 <m_free>
      om = 0;
 82377a4:	e03fe515 	stw	zero,-108(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 82377a8:	e0bfe717 	ldw	r2,-100(fp)
 82377ac:	1080010c 	andi	r2,r2,4
 82377b0:	10000326 	beq	r2,zero,82377c0 <tcp_input+0x220c>
      GOTO_DROP;
 82377b4:	0081ad04 	movi	r2,1716
 82377b8:	d0a0b215 	stw	r2,-32056(gp)
 82377bc:	00002f06 	br	823787c <tcp_input+0x22c8>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 82377c0:	e0bff217 	ldw	r2,-56(fp)
 82377c4:	10800417 	ldw	r2,16(r2)
 82377c8:	1009883a 	mov	r4,r2
 82377cc:	822f1b80 	call	822f1b8 <in_broadcast>
 82377d0:	10000326 	beq	r2,zero,82377e0 <tcp_input+0x222c>
      GOTO_DROP;
 82377d4:	0081af44 	movi	r2,1725
 82377d8:	d0a0b215 	stw	r2,-32056(gp)
 82377dc:	00002706 	br	823787c <tcp_input+0x22c8>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 82377e0:	e0bfe717 	ldw	r2,-100(fp)
 82377e4:	1080040c 	andi	r2,r2,16
 82377e8:	10000c26 	beq	r2,zero,823781c <tcp_input+0x2268>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 82377ec:	e0bff217 	ldw	r2,-56(fp)
 82377f0:	10c00717 	ldw	r3,28(r2)
 82377f4:	e0bffe17 	ldw	r2,-8(fp)
 82377f8:	d8800115 	stw	r2,4(sp)
 82377fc:	00800104 	movi	r2,4
 8237800:	d8800015 	stw	r2,0(sp)
 8237804:	180f883a 	mov	r7,r3
 8237808:	000d883a 	mov	r6,zero
 823780c:	e17ff217 	ldw	r5,-56(fp)
 8237810:	e13fe617 	ldw	r4,-104(fp)
 8237814:	823925c0 	call	823925c <tcp_respond>
 8237818:	00001306 	br	8237868 <tcp_input+0x22b4>
   else
   {
      if (tiflags & TH_SYN)
 823781c:	e0bfe717 	ldw	r2,-100(fp)
 8237820:	1080008c 	andi	r2,r2,2
 8237824:	10000526 	beq	r2,zero,823783c <tcp_input+0x2288>
         ti->ti_seq++;
 8237828:	e0bff217 	ldw	r2,-56(fp)
 823782c:	10800617 	ldw	r2,24(r2)
 8237830:	10c00044 	addi	r3,r2,1
 8237834:	e0bff217 	ldw	r2,-56(fp)
 8237838:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 823783c:	e0bff217 	ldw	r2,-56(fp)
 8237840:	10c00617 	ldw	r3,24(r2)
 8237844:	e0bffe17 	ldw	r2,-8(fp)
 8237848:	d8800115 	stw	r2,4(sp)
 823784c:	00800504 	movi	r2,20
 8237850:	d8800015 	stw	r2,0(sp)
 8237854:	000f883a 	mov	r7,zero
 8237858:	180d883a 	mov	r6,r3
 823785c:	e17ff217 	ldw	r5,-56(fp)
 8237860:	e13fe617 	ldw	r4,-104(fp)
 8237864:	823925c0 	call	823925c <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 8237868:	e0bfec17 	ldw	r2,-80(fp)
 823786c:	10001526 	beq	r2,zero,82378c4 <tcp_input+0x2310>
      (void) soabort(so);
 8237870:	e13fe817 	ldw	r4,-96(fp)
 8237874:	8231d080 	call	8231d08 <soabort>
   return;
 8237878:	00001206 	br	82378c4 <tcp_input+0x2310>

drop:
   if (om)
 823787c:	e0bfe517 	ldw	r2,-108(fp)
 8237880:	10000226 	beq	r2,zero,823788c <tcp_input+0x22d8>
      (void) m_free(om);
 8237884:	e13fe517 	ldw	r4,-108(fp)
 8237888:	822e1640 	call	822e164 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 823788c:	e13ffe17 	ldw	r4,-8(fp)
 8237890:	822e26c0 	call	822e26c <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 8237894:	e0bfec17 	ldw	r2,-80(fp)
 8237898:	10000c26 	beq	r2,zero,82378cc <tcp_input+0x2318>
      (void) soabort(so);
 823789c:	e13fe817 	ldw	r4,-96(fp)
 82378a0:	8231d080 	call	8231d08 <soabort>
   return;
 82378a4:	0001883a 	nop
 82378a8:	00000806 	br	82378cc <tcp_input+0x2318>
            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
 82378ac:	0001883a 	nop
 82378b0:	00000706 	br	82378d0 <tcp_input+0x231c>
            tp->t_flags |= TF_ACKNOW;
            tp->t_flags &= ~TF_DELACK;
            tcp_output(tp);   /* send the ack now... */
         }

         return;
 82378b4:	0001883a 	nop
 82378b8:	00000506 	br	82378d0 <tcp_input+0x231c>
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
      (void) tcp_output(tp);
   return;
 82378bc:	0001883a 	nop
 82378c0:	00000306 	br	82378d0 <tcp_input+0x231c>
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
   }
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 82378c4:	0001883a 	nop
 82378c8:	00000106 	br	82378d0 <tcp_input+0x231c>
#endif
   m_freem(m);
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 82378cc:	0001883a 	nop
}
 82378d0:	e037883a 	mov	sp,fp
 82378d4:	dfc00117 	ldw	ra,4(sp)
 82378d8:	df000017 	ldw	fp,0(sp)
 82378dc:	dec00204 	addi	sp,sp,8
 82378e0:	f800283a 	ret

082378e4 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 82378e4:	defff404 	addi	sp,sp,-48
 82378e8:	dfc00b15 	stw	ra,44(sp)
 82378ec:	df000a15 	stw	fp,40(sp)
 82378f0:	dc000915 	stw	r16,36(sp)
 82378f4:	df000a04 	addi	fp,sp,40
 82378f8:	e13ffc15 	stw	r4,-16(fp)
 82378fc:	e17ffd15 	stw	r5,-12(fp)
 8237900:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 8237904:	e0bffc17 	ldw	r2,-16(fp)
 8237908:	10800d17 	ldw	r2,52(r2)
 823790c:	10800817 	ldw	r2,32(r2)
 8237910:	e0bff915 	stw	r2,-28(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 8237914:	e0bffd17 	ldw	r2,-12(fp)
 8237918:	10800317 	ldw	r2,12(r2)
 823791c:	e0bff615 	stw	r2,-40(fp)
   cnt = om->m_len;
 8237920:	e0bffd17 	ldw	r2,-12(fp)
 8237924:	10800217 	ldw	r2,8(r2)
 8237928:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 823792c:	00004006 	br	8237a30 <tcp_dooptions+0x14c>
   {
      opt = cp[0];
 8237930:	e0bff617 	ldw	r2,-40(fp)
 8237934:	10800003 	ldbu	r2,0(r2)
 8237938:	10803fcc 	andi	r2,r2,255
 823793c:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 8237940:	e0bffa17 	ldw	r2,-24(fp)
 8237944:	10003d26 	beq	r2,zero,8237a3c <tcp_dooptions+0x158>
         break;
      if (opt == TCPOPT_NOP)
 8237948:	e0bffa17 	ldw	r2,-24(fp)
 823794c:	10800058 	cmpnei	r2,r2,1
 8237950:	1000031e 	bne	r2,zero,8237960 <tcp_dooptions+0x7c>
         optlen = 1;
 8237954:	00800044 	movi	r2,1
 8237958:	e0bff715 	stw	r2,-36(fp)
 823795c:	00000706 	br	823797c <tcp_dooptions+0x98>
      else 
      {
         optlen = cp[1];
 8237960:	e0bff617 	ldw	r2,-40(fp)
 8237964:	10800044 	addi	r2,r2,1
 8237968:	10800003 	ldbu	r2,0(r2)
 823796c:	10803fcc 	andi	r2,r2,255
 8237970:	e0bff715 	stw	r2,-36(fp)
         if (optlen <= 0)
 8237974:	e0bff717 	ldw	r2,-36(fp)
 8237978:	0080320e 	bge	zero,r2,8237a44 <tcp_dooptions+0x160>
            break;
      }

      switch (opt) 
 823797c:	e0bffa17 	ldw	r2,-24(fp)
 8237980:	108000a0 	cmpeqi	r2,r2,2
 8237984:	1000011e 	bne	r2,zero,823798c <tcp_dooptions+0xa8>
         }
         break;
#endif   /* TCP_TIMESTAMP */

      default:
         break;
 8237988:	00002106 	br	8237a10 <tcp_dooptions+0x12c>
      switch (opt) 
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 823798c:	e0bff717 	ldw	r2,-36(fp)
 8237990:	10800120 	cmpeqi	r2,r2,4
 8237994:	10001b26 	beq	r2,zero,8237a04 <tcp_dooptions+0x120>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 8237998:	e0bffe17 	ldw	r2,-8(fp)
 823799c:	10800843 	ldbu	r2,33(r2)
 82379a0:	10803fcc 	andi	r2,r2,255
 82379a4:	1080008c 	andi	r2,r2,2
 82379a8:	10001826 	beq	r2,zero,8237a0c <tcp_dooptions+0x128>
            continue;
         mssval = *(u_short *)(cp + 2);
 82379ac:	e0bff617 	ldw	r2,-40(fp)
 82379b0:	1080008b 	ldhu	r2,2(r2)
 82379b4:	e0bffb0d 	sth	r2,-20(fp)
         mssval = ntohs(mssval);
 82379b8:	e0bffb0b 	ldhu	r2,-20(fp)
 82379bc:	1004d23a 	srli	r2,r2,8
 82379c0:	1007883a 	mov	r3,r2
 82379c4:	e0bffb0b 	ldhu	r2,-20(fp)
 82379c8:	1004923a 	slli	r2,r2,8
 82379cc:	1884b03a 	or	r2,r3,r2
 82379d0:	e0bffb0d 	sth	r2,-20(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 82379d4:	e43ffb0b 	ldhu	r16,-20(fp)
 82379d8:	e13ff917 	ldw	r4,-28(fp)
 82379dc:	8237e3c0 	call	8237e3c <tcp_mss>
 82379e0:	10bfffcc 	andi	r2,r2,65535
 82379e4:	1400030e 	bge	r2,r16,82379f4 <tcp_dooptions+0x110>
 82379e8:	e13ff917 	ldw	r4,-28(fp)
 82379ec:	8237e3c0 	call	8237e3c <tcp_mss>
 82379f0:	00000106 	br	82379f8 <tcp_dooptions+0x114>
 82379f4:	e0bffb0b 	ldhu	r2,-20(fp)
 82379f8:	e0fffc17 	ldw	r3,-16(fp)
 82379fc:	18800a0d 	sth	r2,40(r3)
         break;
 8237a00:	00000306 	br	8237a10 <tcp_dooptions+0x12c>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
            continue;
 8237a04:	0001883a 	nop
 8237a08:	00000106 	br	8237a10 <tcp_dooptions+0x12c>
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
            continue;
 8237a0c:	0001883a 	nop
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237a10:	e0fff817 	ldw	r3,-32(fp)
 8237a14:	e0bff717 	ldw	r2,-36(fp)
 8237a18:	1885c83a 	sub	r2,r3,r2
 8237a1c:	e0bff815 	stw	r2,-32(fp)
 8237a20:	e0bff717 	ldw	r2,-36(fp)
 8237a24:	e0fff617 	ldw	r3,-40(fp)
 8237a28:	1885883a 	add	r2,r3,r2
 8237a2c:	e0bff615 	stw	r2,-40(fp)
 8237a30:	e0bff817 	ldw	r2,-32(fp)
 8237a34:	00bfbe16 	blt	zero,r2,8237930 <tcp_dooptions+0x4c>
 8237a38:	00000306 	br	8237a48 <tcp_dooptions+0x164>
   {
      opt = cp[0];
      if (opt == TCPOPT_EOL)
         break;
 8237a3c:	0001883a 	nop
 8237a40:	00000106 	br	8237a48 <tcp_dooptions+0x164>
         optlen = 1;
      else 
      {
         optlen = cp[1];
         if (optlen <= 0)
            break;
 8237a44:	0001883a 	nop

      default:
         break;
      }
   }
   (void) m_free(om);
 8237a48:	e13ffd17 	ldw	r4,-12(fp)
 8237a4c:	822e1640 	call	822e164 <m_free>
      if(!gotstamp)
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
 8237a50:	0001883a 	nop
}
 8237a54:	e6ffff04 	addi	sp,fp,-4
 8237a58:	dfc00217 	ldw	ra,8(sp)
 8237a5c:	df000117 	ldw	fp,4(sp)
 8237a60:	dc000017 	ldw	r16,0(sp)
 8237a64:	dec00304 	addi	sp,sp,12
 8237a68:	f800283a 	ret

08237a6c <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 8237a6c:	defff804 	addi	sp,sp,-32
 8237a70:	dfc00715 	stw	ra,28(sp)
 8237a74:	df000615 	stw	fp,24(sp)
 8237a78:	df000604 	addi	fp,sp,24
 8237a7c:	e13ffd15 	stw	r4,-12(fp)
 8237a80:	e17ffe15 	stw	r5,-8(fp)
 8237a84:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 8237a88:	e0bffe17 	ldw	r2,-8(fp)
 8237a8c:	1080098b 	ldhu	r2,38(r2)
 8237a90:	10bfffcc 	andi	r2,r2,65535
 8237a94:	10bfffc4 	addi	r2,r2,-1
 8237a98:	e0bffa15 	stw	r2,-24(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237a9c:	00003206 	br	8237b68 <tcp_pulloutofband+0xfc>
   {
      if (m->m_len > (unsigned)cnt) 
 8237aa0:	e0bfff17 	ldw	r2,-4(fp)
 8237aa4:	10800217 	ldw	r2,8(r2)
 8237aa8:	e0fffa17 	ldw	r3,-24(fp)
 8237aac:	1880242e 	bgeu	r3,r2,8237b40 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 8237ab0:	e0bfff17 	ldw	r2,-4(fp)
 8237ab4:	10c00317 	ldw	r3,12(r2)
 8237ab8:	e0bffa17 	ldw	r2,-24(fp)
 8237abc:	1885883a 	add	r2,r3,r2
 8237ac0:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 8237ac4:	e0bffd17 	ldw	r2,-12(fp)
 8237ac8:	10800117 	ldw	r2,4(r2)
 8237acc:	10800917 	ldw	r2,36(r2)
 8237ad0:	e0bffc15 	stw	r2,-16(fp)

         tp->t_iobc = *cp;
 8237ad4:	e0bffb17 	ldw	r2,-20(fp)
 8237ad8:	10c00003 	ldbu	r3,0(r2)
 8237adc:	e0bffc17 	ldw	r2,-16(fp)
 8237ae0:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 8237ae4:	e0bffc17 	ldw	r2,-16(fp)
 8237ae8:	10802403 	ldbu	r2,144(r2)
 8237aec:	10800054 	ori	r2,r2,1
 8237af0:	1007883a 	mov	r3,r2
 8237af4:	e0bffc17 	ldw	r2,-16(fp)
 8237af8:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 8237afc:	e0bffb17 	ldw	r2,-20(fp)
 8237b00:	11000044 	addi	r4,r2,1
 8237b04:	e0bfff17 	ldw	r2,-4(fp)
 8237b08:	10c00217 	ldw	r3,8(r2)
 8237b0c:	e0bffa17 	ldw	r2,-24(fp)
 8237b10:	1885c83a 	sub	r2,r3,r2
 8237b14:	10bfffc4 	addi	r2,r2,-1
 8237b18:	100d883a 	mov	r6,r2
 8237b1c:	200b883a 	mov	r5,r4
 8237b20:	e13ffb17 	ldw	r4,-20(fp)
 8237b24:	8202a0c0 	call	8202a0c <memcpy>
         m->m_len--;
 8237b28:	e0bfff17 	ldw	r2,-4(fp)
 8237b2c:	10800217 	ldw	r2,8(r2)
 8237b30:	10ffffc4 	addi	r3,r2,-1
 8237b34:	e0bfff17 	ldw	r2,-4(fp)
 8237b38:	10c00215 	stw	r3,8(r2)
         return;
 8237b3c:	00001106 	br	8237b84 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 8237b40:	e0fffa17 	ldw	r3,-24(fp)
 8237b44:	e0bfff17 	ldw	r2,-4(fp)
 8237b48:	10800217 	ldw	r2,8(r2)
 8237b4c:	1885c83a 	sub	r2,r3,r2
 8237b50:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
 8237b54:	e0bfff17 	ldw	r2,-4(fp)
 8237b58:	10800617 	ldw	r2,24(r2)
 8237b5c:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 8237b60:	e0bfff17 	ldw	r2,-4(fp)
 8237b64:	10000326 	beq	r2,zero,8237b74 <tcp_pulloutofband+0x108>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237b68:	e0bffa17 	ldw	r2,-24(fp)
 8237b6c:	103fcc0e 	bge	r2,zero,8237aa0 <tcp_pulloutofband+0x34>
 8237b70:	00000106 	br	8237b78 <tcp_pulloutofband+0x10c>
         return;
      }
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
 8237b74:	0001883a 	nop
   }
   panic("tcp_pulloutofband");
 8237b78:	01020974 	movhi	r4,2085
 8237b7c:	21023404 	addi	r4,r4,2256
 8237b80:	822887c0 	call	822887c <panic>
}
 8237b84:	e037883a 	mov	sp,fp
 8237b88:	dfc00117 	ldw	ra,4(sp)
 8237b8c:	df000017 	ldw	fp,0(sp)
 8237b90:	dec00204 	addi	sp,sp,8
 8237b94:	f800283a 	ret

08237b98 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 8237b98:	defffb04 	addi	sp,sp,-20
 8237b9c:	dfc00415 	stw	ra,16(sp)
 8237ba0:	df000315 	stw	fp,12(sp)
 8237ba4:	df000304 	addi	fp,sp,12
 8237ba8:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 8237bac:	e0bfff17 	ldw	r2,-4(fp)
 8237bb0:	10801e17 	ldw	r2,120(r2)
 8237bb4:	1000021e 	bne	r2,zero,8237bc0 <tcp_xmit_timer+0x28>
 8237bb8:	822d1c80 	call	822d1c8 <dtrap>
 8237bbc:	00008806 	br	8237de0 <tcp_xmit_timer+0x248>
#endif

   tcpstat.tcps_rttupdated++;
 8237bc0:	008209b4 	movhi	r2,2086
 8237bc4:	10b82204 	addi	r2,r2,-8056
 8237bc8:	10800717 	ldw	r2,28(r2)
 8237bcc:	10c00044 	addi	r3,r2,1
 8237bd0:	008209b4 	movhi	r2,2086
 8237bd4:	10b82204 	addi	r2,r2,-8056
 8237bd8:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 8237bdc:	d0e0a817 	ldw	r3,-32096(gp)
 8237be0:	e0bfff17 	ldw	r2,-4(fp)
 8237be4:	10801e17 	ldw	r2,120(r2)
 8237be8:	1887c83a 	sub	r3,r3,r2
 8237bec:	00947b34 	movhi	r2,20972
 8237bf0:	10a147c4 	addi	r2,r2,-31457
 8237bf4:	1888383a 	mulxuu	r4,r3,r2
 8237bf8:	1885383a 	mul	r2,r3,r2
 8237bfc:	100b883a 	mov	r5,r2
 8237c00:	200d883a 	mov	r6,r4
 8237c04:	3004d13a 	srli	r2,r6,4
 8237c08:	e0bffe15 	stw	r2,-8(fp)
   if(tp->t_srtt != 0)
 8237c0c:	e0bfff17 	ldw	r2,-4(fp)
 8237c10:	10802017 	ldw	r2,128(r2)
 8237c14:	10004626 	beq	r2,zero,8237d30 <tcp_xmit_timer+0x198>
   {
      if(rtt == 0)      /* fast path for small round trip */
 8237c18:	e0bffe17 	ldw	r2,-8(fp)
 8237c1c:	1000131e 	bne	r2,zero,8237c6c <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 8237c20:	e0bfff17 	ldw	r2,-4(fp)
 8237c24:	10802017 	ldw	r2,128(r2)
 8237c28:	10800090 	cmplti	r2,r2,2
 8237c2c:	1000051e 	bne	r2,zero,8237c44 <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 8237c30:	e0bfff17 	ldw	r2,-4(fp)
 8237c34:	10802017 	ldw	r2,128(r2)
 8237c38:	10ffffc4 	addi	r3,r2,-1
 8237c3c:	e0bfff17 	ldw	r2,-4(fp)
 8237c40:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 8237c44:	e0bfff17 	ldw	r2,-4(fp)
 8237c48:	10802117 	ldw	r2,132(r2)
 8237c4c:	10800090 	cmplti	r2,r2,2
 8237c50:	1000441e 	bne	r2,zero,8237d64 <tcp_xmit_timer+0x1cc>
            tp->t_rttvar--;
 8237c54:	e0bfff17 	ldw	r2,-4(fp)
 8237c58:	10802117 	ldw	r2,132(r2)
 8237c5c:	10ffffc4 	addi	r3,r2,-1
 8237c60:	e0bfff17 	ldw	r2,-4(fp)
 8237c64:	10c02115 	stw	r3,132(r2)
 8237c68:	00003e06 	br	8237d64 <tcp_xmit_timer+0x1cc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 8237c6c:	e0bffe17 	ldw	r2,-8(fp)
 8237c70:	10bfffc4 	addi	r2,r2,-1
 8237c74:	1085883a 	add	r2,r2,r2
 8237c78:	1085883a 	add	r2,r2,r2
 8237c7c:	1007883a 	mov	r3,r2
 8237c80:	e0bfff17 	ldw	r2,-4(fp)
 8237c84:	10802017 	ldw	r2,128(r2)
 8237c88:	1005d0fa 	srai	r2,r2,3
 8237c8c:	1885c83a 	sub	r2,r3,r2
 8237c90:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_srtt += delta) <= 0)
 8237c94:	e0bfff17 	ldw	r2,-4(fp)
 8237c98:	10c02017 	ldw	r3,128(r2)
 8237c9c:	e0bffd17 	ldw	r2,-12(fp)
 8237ca0:	1887883a 	add	r3,r3,r2
 8237ca4:	e0bfff17 	ldw	r2,-4(fp)
 8237ca8:	10c02015 	stw	r3,128(r2)
 8237cac:	e0bfff17 	ldw	r2,-4(fp)
 8237cb0:	10802017 	ldw	r2,128(r2)
 8237cb4:	00800316 	blt	zero,r2,8237cc4 <tcp_xmit_timer+0x12c>
         tp->t_srtt = 1;
 8237cb8:	e0bfff17 	ldw	r2,-4(fp)
 8237cbc:	00c00044 	movi	r3,1
 8237cc0:	10c02015 	stw	r3,128(r2)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 8237cc4:	e0bffd17 	ldw	r2,-12(fp)
 8237cc8:	1000030e 	bge	r2,zero,8237cd8 <tcp_xmit_timer+0x140>
         delta = -delta;
 8237ccc:	e0bffd17 	ldw	r2,-12(fp)
 8237cd0:	0085c83a 	sub	r2,zero,r2
 8237cd4:	e0bffd15 	stw	r2,-12(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 8237cd8:	e0bfff17 	ldw	r2,-4(fp)
 8237cdc:	10802117 	ldw	r2,132(r2)
 8237ce0:	1005d07a 	srai	r2,r2,1
 8237ce4:	10bfffcc 	andi	r2,r2,65535
 8237ce8:	10a0001c 	xori	r2,r2,32768
 8237cec:	10a00004 	addi	r2,r2,-32768
 8237cf0:	e0fffd17 	ldw	r3,-12(fp)
 8237cf4:	1885c83a 	sub	r2,r3,r2
 8237cf8:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_rttvar += delta) <= 0)
 8237cfc:	e0bfff17 	ldw	r2,-4(fp)
 8237d00:	10c02117 	ldw	r3,132(r2)
 8237d04:	e0bffd17 	ldw	r2,-12(fp)
 8237d08:	1887883a 	add	r3,r3,r2
 8237d0c:	e0bfff17 	ldw	r2,-4(fp)
 8237d10:	10c02115 	stw	r3,132(r2)
 8237d14:	e0bfff17 	ldw	r2,-4(fp)
 8237d18:	10802117 	ldw	r2,132(r2)
 8237d1c:	00801116 	blt	zero,r2,8237d64 <tcp_xmit_timer+0x1cc>
         tp->t_rttvar = 1;
 8237d20:	e0bfff17 	ldw	r2,-4(fp)
 8237d24:	00c00044 	movi	r3,1
 8237d28:	10c02115 	stw	r3,132(r2)
 8237d2c:	00000d06 	br	8237d64 <tcp_xmit_timer+0x1cc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 8237d30:	e0bffe17 	ldw	r2,-8(fp)
 8237d34:	00800216 	blt	zero,r2,8237d40 <tcp_xmit_timer+0x1a8>
         rtt = 1;
 8237d38:	00800044 	movi	r2,1
 8237d3c:	e0bffe15 	stw	r2,-8(fp)
      tp->t_srtt = rtt << 3;
 8237d40:	e0bffe17 	ldw	r2,-8(fp)
 8237d44:	100690fa 	slli	r3,r2,3
 8237d48:	e0bfff17 	ldw	r2,-4(fp)
 8237d4c:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 8237d50:	e0bffe17 	ldw	r2,-8(fp)
 8237d54:	1085883a 	add	r2,r2,r2
 8237d58:	1007883a 	mov	r3,r2
 8237d5c:	e0bfff17 	ldw	r2,-4(fp)
 8237d60:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 8237d64:	e0bfff17 	ldw	r2,-4(fp)
 8237d68:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 8237d6c:	e0bfff17 	ldw	r2,-4(fp)
 8237d70:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 8237d74:	e0bfff17 	ldw	r2,-4(fp)
 8237d78:	10802017 	ldw	r2,128(r2)
 8237d7c:	1007d0ba 	srai	r3,r2,2
 8237d80:	e0bfff17 	ldw	r2,-4(fp)
 8237d84:	10802117 	ldw	r2,132(r2)
 8237d88:	1885883a 	add	r2,r3,r2
 8237d8c:	1005d07a 	srai	r2,r2,1
 8237d90:	10ffffcc 	andi	r3,r2,65535
 8237d94:	18e0001c 	xori	r3,r3,32768
 8237d98:	18e00004 	addi	r3,r3,-32768
 8237d9c:	e0bfff17 	ldw	r2,-4(fp)
 8237da0:	10c00815 	stw	r3,32(r2)
 8237da4:	e0bfff17 	ldw	r2,-4(fp)
 8237da8:	10800817 	ldw	r2,32(r2)
 8237dac:	10800088 	cmpgei	r2,r2,2
 8237db0:	1000041e 	bne	r2,zero,8237dc4 <tcp_xmit_timer+0x22c>
 8237db4:	e0bfff17 	ldw	r2,-4(fp)
 8237db8:	00c00084 	movi	r3,2
 8237dbc:	10c00815 	stw	r3,32(r2)
 8237dc0:	00000706 	br	8237de0 <tcp_xmit_timer+0x248>
 8237dc4:	e0bfff17 	ldw	r2,-4(fp)
 8237dc8:	10800817 	ldw	r2,32(r2)
 8237dcc:	10802050 	cmplti	r2,r2,129
 8237dd0:	1000031e 	bne	r2,zero,8237de0 <tcp_xmit_timer+0x248>
 8237dd4:	e0bfff17 	ldw	r2,-4(fp)
 8237dd8:	00c02004 	movi	r3,128
 8237ddc:	10c00815 	stw	r3,32(r2)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 8237de0:	e037883a 	mov	sp,fp
 8237de4:	dfc00117 	ldw	ra,4(sp)
 8237de8:	df000017 	ldw	fp,0(sp)
 8237dec:	dec00204 	addi	sp,sp,8
 8237df0:	f800283a 	ret

08237df4 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 8237df4:	defffd04 	addi	sp,sp,-12
 8237df8:	df000215 	stw	fp,8(sp)
 8237dfc:	df000204 	addi	fp,sp,8
 8237e00:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 8237e04:	e0bfff17 	ldw	r2,-4(fp)
 8237e08:	10800117 	ldw	r2,4(r2)
 8237e0c:	10800a17 	ldw	r2,40(r2)
 8237e10:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 8237e14:	e0bffe17 	ldw	r2,-8(fp)
 8237e18:	10c00917 	ldw	r3,36(r2)
 8237e1c:	e0bffe17 	ldw	r2,-8(fp)
 8237e20:	10800817 	ldw	r2,32(r2)
 8237e24:	10800a04 	addi	r2,r2,40
 8237e28:	1885c83a 	sub	r2,r3,r2
}
 8237e2c:	e037883a 	mov	sp,fp
 8237e30:	df000017 	ldw	fp,0(sp)
 8237e34:	dec00104 	addi	sp,sp,4
 8237e38:	f800283a 	ret

08237e3c <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 8237e3c:	defffa04 	addi	sp,sp,-24
 8237e40:	dfc00515 	stw	ra,20(sp)
 8237e44:	df000415 	stw	fp,16(sp)
 8237e48:	df000404 	addi	fp,sp,16
 8237e4c:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 8237e50:	e0bfff17 	ldw	r2,-4(fp)
 8237e54:	10000726 	beq	r2,zero,8237e74 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
 8237e58:	e0bfff17 	ldw	r2,-4(fp)
 8237e5c:	10800117 	ldw	r2,4(r2)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 8237e60:	10000426 	beq	r2,zero,8237e74 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
 8237e64:	e0bfff17 	ldw	r2,-4(fp)
 8237e68:	10800117 	ldw	r2,4(r2)
 8237e6c:	10800a17 	ldw	r2,40(r2)
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
       (so->so_pcb == NULL) ||
 8237e70:	1000061e 	bne	r2,zero,8237e8c <tcp_mss+0x50>
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 8237e74:	e0bfff17 	ldw	r2,-4(fp)
 8237e78:	10800517 	ldw	r2,20(r2)
 8237e7c:	10800098 	cmpnei	r2,r2,2
 8237e80:	1000021e 	bne	r2,zero,8237e8c <tcp_mss+0x50>
         return TCP_MSS;            /* user defined */
 8237e84:	00816d04 	movi	r2,1460
 8237e88:	00002506 	br	8237f20 <tcp_mss+0xe4>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 8237e8c:	e13fff17 	ldw	r4,-4(fp)
 8237e90:	8237df40 	call	8237df4 <ip4_tcpmss>
 8237e94:	e0bffc15 	stw	r2,-16(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 8237e98:	e0bffc17 	ldw	r2,-16(fp)
 8237e9c:	10816d50 	cmplti	r2,r2,1461
 8237ea0:	1000021e 	bne	r2,zero,8237eac <tcp_mss+0x70>
      mss = TCP_MSS;
 8237ea4:	00816d04 	movi	r2,1460
 8237ea8:	e0bffc15 	stw	r2,-16(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 8237eac:	e0bfff17 	ldw	r2,-4(fp)
 8237eb0:	10800117 	ldw	r2,4(r2)
 8237eb4:	e0bffd15 	stw	r2,-12(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 8237eb8:	e0bffd17 	ldw	r2,-12(fp)
 8237ebc:	10800917 	ldw	r2,36(r2)
 8237ec0:	e0bffe15 	stw	r2,-8(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 8237ec4:	e0bffe17 	ldw	r2,-8(fp)
 8237ec8:	10800b0b 	ldhu	r2,44(r2)
 8237ecc:	10bfffcc 	andi	r2,r2,65535
 8237ed0:	1081000c 	andi	r2,r2,1024
 8237ed4:	10000426 	beq	r2,zero,8237ee8 <tcp_mss+0xac>
      return tp->t_maxseg;    /* yup */
 8237ed8:	e0bffe17 	ldw	r2,-8(fp)
 8237edc:	10800a0b 	ldhu	r2,40(r2)
 8237ee0:	10bfffcc 	andi	r2,r2,65535
 8237ee4:	00000e06 	br	8237f20 <tcp_mss+0xe4>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 8237ee8:	e0bffe17 	ldw	r2,-8(fp)
 8237eec:	10800a0b 	ldhu	r2,40(r2)
 8237ef0:	10bfffcc 	andi	r2,r2,65535
 8237ef4:	10000926 	beq	r2,zero,8237f1c <tcp_mss+0xe0>
 8237ef8:	e0bffe17 	ldw	r2,-8(fp)
 8237efc:	10800a0b 	ldhu	r2,40(r2)
 8237f00:	10ffffcc 	andi	r3,r2,65535
 8237f04:	e0bffc17 	ldw	r2,-16(fp)
 8237f08:	1880040e 	bge	r3,r2,8237f1c <tcp_mss+0xe0>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 8237f0c:	e0bffe17 	ldw	r2,-8(fp)
 8237f10:	10800a0b 	ldhu	r2,40(r2)
 8237f14:	10bfffcc 	andi	r2,r2,65535
 8237f18:	e0bffc15 	stw	r2,-16(fp)
   }

   return mss;
 8237f1c:	e0bffc17 	ldw	r2,-16(fp)
}
 8237f20:	e037883a 	mov	sp,fp
 8237f24:	dfc00117 	ldw	ra,4(sp)
 8237f28:	df000017 	ldw	fp,0(sp)
 8237f2c:	dec00204 	addi	sp,sp,8
 8237f30:	f800283a 	ret

08237f34 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 8237f34:	deffe804 	addi	sp,sp,-96
 8237f38:	dfc01715 	stw	ra,92(sp)
 8237f3c:	df001615 	stw	fp,88(sp)
 8237f40:	df001604 	addi	fp,sp,88
 8237f44:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8237f48:	e0bfff17 	ldw	r2,-4(fp)
 8237f4c:	10800d17 	ldw	r2,52(r2)
 8237f50:	10800817 	ldw	r2,32(r2)
 8237f54:	e0bff215 	stw	r2,-56(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 8237f58:	e03fee15 	stw	zero,-72(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 8237f5c:	e0bfff17 	ldw	r2,-4(fp)
 8237f60:	10c01a17 	ldw	r3,104(r2)
 8237f64:	e0bfff17 	ldw	r2,-4(fp)
 8237f68:	10800e17 	ldw	r2,56(r2)
 8237f6c:	1885003a 	cmpeq	r2,r3,r2
 8237f70:	10803fcc 	andi	r2,r2,255
 8237f74:	e0bff315 	stw	r2,-52(fp)

again:
   sendalot = 0;
 8237f78:	e03fef15 	stw	zero,-68(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 8237f7c:	e0bfff17 	ldw	r2,-4(fp)
 8237f80:	10c00f17 	ldw	r3,60(r2)
 8237f84:	e0bfff17 	ldw	r2,-4(fp)
 8237f88:	10800e17 	ldw	r2,56(r2)
 8237f8c:	1885c83a 	sub	r2,r3,r2
 8237f90:	e0bff415 	stw	r2,-48(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 8237f94:	e0bfff17 	ldw	r2,-4(fp)
 8237f98:	10801417 	ldw	r2,80(r2)
 8237f9c:	e0bfeb15 	stw	r2,-84(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 8237fa0:	e0bfff17 	ldw	r2,-4(fp)
 8237fa4:	10801b17 	ldw	r2,108(r2)
 8237fa8:	1007883a 	mov	r3,r2
 8237fac:	e0bfeb17 	ldw	r2,-84(fp)
 8237fb0:	1880060e 	bge	r3,r2,8237fcc <tcp_output+0x98>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 8237fb4:	e0bfff17 	ldw	r2,-4(fp)
 8237fb8:	10801b17 	ldw	r2,108(r2)
 8237fbc:	1007883a 	mov	r3,r2
 8237fc0:	00bfff04 	movi	r2,-4
 8237fc4:	1884703a 	and	r2,r3,r2
 8237fc8:	e0bfeb15 	stw	r2,-84(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 8237fcc:	e0bfff17 	ldw	r2,-4(fp)
 8237fd0:	10800a83 	ldbu	r2,42(r2)
 8237fd4:	10803fcc 	andi	r2,r2,255
 8237fd8:	1080201c 	xori	r2,r2,128
 8237fdc:	10bfe004 	addi	r2,r2,-128
 8237fe0:	10000926 	beq	r2,zero,8238008 <tcp_output+0xd4>
   {
      if (win == 0)
 8237fe4:	e0bfeb17 	ldw	r2,-84(fp)
 8237fe8:	1000031e 	bne	r2,zero,8237ff8 <tcp_output+0xc4>
         win = 1;
 8237fec:	00800044 	movi	r2,1
 8237ff0:	e0bfeb15 	stw	r2,-84(fp)
 8237ff4:	00000406 	br	8238008 <tcp_output+0xd4>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 8237ff8:	e0bfff17 	ldw	r2,-4(fp)
 8237ffc:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 8238000:	e0bfff17 	ldw	r2,-4(fp)
 8238004:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 8238008:	e0bff217 	ldw	r2,-56(fp)
 823800c:	10801217 	ldw	r2,72(r2)
 8238010:	e0ffeb17 	ldw	r3,-84(fp)
 8238014:	1880012e 	bgeu	r3,r2,823801c <tcp_output+0xe8>
 8238018:	1805883a 	mov	r2,r3
 823801c:	1007883a 	mov	r3,r2
 8238020:	e0bff417 	ldw	r2,-48(fp)
 8238024:	1885c83a 	sub	r2,r3,r2
 8238028:	e0bfea15 	stw	r2,-88(fp)
   }

   flags = tcp_outflags[tp->t_state];
 823802c:	e0bfff17 	ldw	r2,-4(fp)
 8238030:	10c00217 	ldw	r3,8(r2)
 8238034:	00820974 	movhi	r2,2085
 8238038:	108d5a04 	addi	r2,r2,13672
 823803c:	10c5883a 	add	r2,r2,r3
 8238040:	10800003 	ldbu	r2,0(r2)
 8238044:	10803fcc 	andi	r2,r2,255
 8238048:	e0bfec15 	stw	r2,-80(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 823804c:	e0bfec17 	ldw	r2,-80(fp)
 8238050:	1080008c 	andi	r2,r2,2
 8238054:	10000926 	beq	r2,zero,823807c <tcp_output+0x148>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 8238058:	e0ffee17 	ldw	r3,-72(fp)
 823805c:	d0a0b304 	addi	r2,gp,-32052
 8238060:	1885883a 	add	r2,r3,r2
 8238064:	e1fff217 	ldw	r7,-56(fp)
 8238068:	e1bfec17 	ldw	r6,-80(fp)
 823806c:	100b883a 	mov	r5,r2
 8238070:	e13fff17 	ldw	r4,-4(fp)
 8238074:	82390380 	call	8239038 <bld_options>
 8238078:	e0bfee15 	stw	r2,-72(fp)
   }
#endif

   if (len < 0)
 823807c:	e0bfea17 	ldw	r2,-88(fp)
 8238080:	1000090e 	bge	r2,zero,82380a8 <tcp_output+0x174>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 8238084:	e03fea15 	stw	zero,-88(fp)
      if (win == 0) 
 8238088:	e0bfeb17 	ldw	r2,-84(fp)
 823808c:	1000061e 	bne	r2,zero,82380a8 <tcp_output+0x174>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 8238090:	e0bfff17 	ldw	r2,-4(fp)
 8238094:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 8238098:	e0bfff17 	ldw	r2,-4(fp)
 823809c:	10c00e17 	ldw	r3,56(r2)
 82380a0:	e0bfff17 	ldw	r2,-4(fp)
 82380a4:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 82380a8:	e0bfff17 	ldw	r2,-4(fp)
 82380ac:	10800a0b 	ldhu	r2,40(r2)
 82380b0:	10ffffcc 	andi	r3,r2,65535
 82380b4:	e0bfea17 	ldw	r2,-88(fp)
 82380b8:	1880060e 	bge	r3,r2,82380d4 <tcp_output+0x1a0>
   {
      len = tp->t_maxseg;
 82380bc:	e0bfff17 	ldw	r2,-4(fp)
 82380c0:	10800a0b 	ldhu	r2,40(r2)
 82380c4:	10bfffcc 	andi	r2,r2,65535
 82380c8:	e0bfea15 	stw	r2,-88(fp)
      sendalot = 1;
 82380cc:	00800044 	movi	r2,1
 82380d0:	e0bfef15 	stw	r2,-68(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 82380d4:	e0bfff17 	ldw	r2,-4(fp)
 82380d8:	10c00f17 	ldw	r3,60(r2)
 82380dc:	e0bfea17 	ldw	r2,-88(fp)
 82380e0:	1887883a 	add	r3,r3,r2
 82380e4:	e0bfff17 	ldw	r2,-4(fp)
 82380e8:	11000e17 	ldw	r4,56(r2)
 82380ec:	e0bff217 	ldw	r2,-56(fp)
 82380f0:	10801217 	ldw	r2,72(r2)
 82380f4:	2085883a 	add	r2,r4,r2
 82380f8:	1885c83a 	sub	r2,r3,r2
 82380fc:	1000040e 	bge	r2,zero,8238110 <tcp_output+0x1dc>
      flags &= ~TH_FIN;
 8238100:	e0ffec17 	ldw	r3,-80(fp)
 8238104:	00bfff84 	movi	r2,-2
 8238108:	1884703a 	and	r2,r3,r2
 823810c:	e0bfec15 	stw	r2,-80(fp)
   win = (long)(sbspace(&so->so_rcv));
 8238110:	e0bff217 	ldw	r2,-56(fp)
 8238114:	10800b17 	ldw	r2,44(r2)
 8238118:	1007883a 	mov	r3,r2
 823811c:	e0bff217 	ldw	r2,-56(fp)
 8238120:	10800a17 	ldw	r2,40(r2)
 8238124:	1885c83a 	sub	r2,r3,r2
 8238128:	10000616 	blt	r2,zero,8238144 <tcp_output+0x210>
 823812c:	e0bff217 	ldw	r2,-56(fp)
 8238130:	10c00b17 	ldw	r3,44(r2)
 8238134:	e0bff217 	ldw	r2,-56(fp)
 8238138:	10800a17 	ldw	r2,40(r2)
 823813c:	1885c83a 	sub	r2,r3,r2
 8238140:	00000106 	br	8238148 <tcp_output+0x214>
 8238144:	0005883a 	mov	r2,zero
 8238148:	e0bfeb15 	stw	r2,-84(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 823814c:	e0bfec17 	ldw	r2,-80(fp)
 8238150:	1080004c 	andi	r2,r2,1
 8238154:	10000d26 	beq	r2,zero,823818c <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
 8238158:	e0bff217 	ldw	r2,-56(fp)
 823815c:	10801217 	ldw	r2,72(r2)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238160:	10000a1e 	bne	r2,zero,823818c <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 8238164:	e0bfff17 	ldw	r2,-4(fp)
 8238168:	10800b0b 	ldhu	r2,44(r2)
 823816c:	10bfffcc 	andi	r2,r2,65535
 8238170:	1080040c 	andi	r2,r2,16
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
       (so->so_snd.sb_cc == 0) &&
 8238174:	10007926 	beq	r2,zero,823835c <tcp_output+0x428>
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 8238178:	e0bfff17 	ldw	r2,-4(fp)
 823817c:	10c00f17 	ldw	r3,60(r2)
 8238180:	e0bfff17 	ldw	r2,-4(fp)
 8238184:	10800e17 	ldw	r2,56(r2)
 8238188:	18807426 	beq	r3,r2,823835c <tcp_output+0x428>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 823818c:	e0bfff17 	ldw	r2,-4(fp)
 8238190:	10800b0b 	ldhu	r2,44(r2)
 8238194:	10bfffcc 	andi	r2,r2,65535
 8238198:	1080004c 	andi	r2,r2,1
 823819c:	10005c1e 	bne	r2,zero,8238310 <tcp_output+0x3dc>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 82381a0:	e0bfec17 	ldw	r2,-80(fp)
 82381a4:	1080018c 	andi	r2,r2,6
 82381a8:	10005b1e 	bne	r2,zero,8238318 <tcp_output+0x3e4>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 82381ac:	e0bfff17 	ldw	r2,-4(fp)
 82381b0:	10c01017 	ldw	r3,64(r2)
 82381b4:	e0bfff17 	ldw	r2,-4(fp)
 82381b8:	10800e17 	ldw	r2,56(r2)
 82381bc:	1885c83a 	sub	r2,r3,r2
 82381c0:	00805716 	blt	zero,r2,8238320 <tcp_output+0x3ec>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 82381c4:	e0bfea17 	ldw	r2,-88(fp)
 82381c8:	10002426 	beq	r2,zero,823825c <tcp_output+0x328>
   {
      if (len == (int)tp->t_maxseg)
 82381cc:	e0bfff17 	ldw	r2,-4(fp)
 82381d0:	10800a0b 	ldhu	r2,40(r2)
 82381d4:	10ffffcc 	andi	r3,r2,65535
 82381d8:	e0bfea17 	ldw	r2,-88(fp)
 82381dc:	18805226 	beq	r3,r2,8238328 <tcp_output+0x3f4>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 82381e0:	e0bff317 	ldw	r2,-52(fp)
 82381e4:	1000051e 	bne	r2,zero,82381fc <tcp_output+0x2c8>
 82381e8:	e0bfff17 	ldw	r2,-4(fp)
 82381ec:	10800b0b 	ldhu	r2,44(r2)
 82381f0:	10bfffcc 	andi	r2,r2,65535
 82381f4:	1080010c 	andi	r2,r2,4
 82381f8:	10000626 	beq	r2,zero,8238214 <tcp_output+0x2e0>
          len + off >= (int)so->so_snd.sb_cc)
 82381fc:	e0ffea17 	ldw	r3,-88(fp)
 8238200:	e0bff417 	ldw	r2,-48(fp)
 8238204:	1885883a 	add	r2,r3,r2
 8238208:	e0fff217 	ldw	r3,-56(fp)
 823820c:	18c01217 	ldw	r3,72(r3)
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 8238210:	10c0470e 	bge	r2,r3,8238330 <tcp_output+0x3fc>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 8238214:	e0bfff17 	ldw	r2,-4(fp)
 8238218:	10800a83 	ldbu	r2,42(r2)
 823821c:	10803fcc 	andi	r2,r2,255
 8238220:	1080201c 	xori	r2,r2,128
 8238224:	10bfe004 	addi	r2,r2,-128
 8238228:	1000431e 	bne	r2,zero,8238338 <tcp_output+0x404>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 823822c:	e0bfff17 	ldw	r2,-4(fp)
 8238230:	10802317 	ldw	r2,140(r2)
 8238234:	1004d07a 	srli	r2,r2,1
 8238238:	1007883a 	mov	r3,r2
 823823c:	e0bfea17 	ldw	r2,-88(fp)
 8238240:	10c03f0e 	bge	r2,r3,8238340 <tcp_output+0x40c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 8238244:	e0bfff17 	ldw	r2,-4(fp)
 8238248:	10c00f17 	ldw	r3,60(r2)
 823824c:	e0bfff17 	ldw	r2,-4(fp)
 8238250:	10801a17 	ldw	r2,104(r2)
 8238254:	1885c83a 	sub	r2,r3,r2
 8238258:	10003b16 	blt	r2,zero,8238348 <tcp_output+0x414>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 823825c:	e0bfeb17 	ldw	r2,-84(fp)
 8238260:	00801c0e 	bge	zero,r2,82382d4 <tcp_output+0x3a0>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 8238264:	e0bfff17 	ldw	r2,-4(fp)
 8238268:	10c01617 	ldw	r3,88(r2)
 823826c:	e0bfff17 	ldw	r2,-4(fp)
 8238270:	10801917 	ldw	r2,100(r2)
 8238274:	1885c83a 	sub	r2,r3,r2
 8238278:	1007883a 	mov	r3,r2
 823827c:	e0bfeb17 	ldw	r2,-84(fp)
 8238280:	1885883a 	add	r2,r3,r2
 8238284:	e0bffd15 	stw	r2,-12(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 8238288:	e0bff217 	ldw	r2,-56(fp)
 823828c:	10800a17 	ldw	r2,40(r2)
 8238290:	1000071e 	bne	r2,zero,82382b0 <tcp_output+0x37c>
 8238294:	e0bfff17 	ldw	r2,-4(fp)
 8238298:	10800a0b 	ldhu	r2,40(r2)
 823829c:	10bfffcc 	andi	r2,r2,65535
 82382a0:	1085883a 	add	r2,r2,r2
 82382a4:	1007883a 	mov	r3,r2
 82382a8:	e0bffd17 	ldw	r2,-12(fp)
 82382ac:	10c0280e 	bge	r2,r3,8238350 <tcp_output+0x41c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 82382b0:	e0bffd17 	ldw	r2,-12(fp)
 82382b4:	10c01924 	muli	r3,r2,100
 82382b8:	e0bff217 	ldw	r2,-56(fp)
 82382bc:	10800b17 	ldw	r2,44(r2)
 82382c0:	100b883a 	mov	r5,r2
 82382c4:	1809883a 	mov	r4,r3
 82382c8:	820270c0 	call	820270c <__udivsi3>
 82382cc:	108008f0 	cmpltui	r2,r2,35
 82382d0:	10002126 	beq	r2,zero,8238358 <tcp_output+0x424>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 82382d4:	e0bff217 	ldw	r2,-56(fp)
 82382d8:	10801217 	ldw	r2,72(r2)
 82382dc:	10000a26 	beq	r2,zero,8238308 <tcp_output+0x3d4>
 82382e0:	e0bfff17 	ldw	r2,-4(fp)
 82382e4:	10800317 	ldw	r2,12(r2)
 82382e8:	1000071e 	bne	r2,zero,8238308 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
 82382ec:	e0bfff17 	ldw	r2,-4(fp)
 82382f0:	10800417 	ldw	r2,16(r2)
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 82382f4:	1000041e 	bne	r2,zero,8238308 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 82382f8:	e0bfff17 	ldw	r2,-4(fp)
 82382fc:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 8238300:	e13fff17 	ldw	r4,-4(fp)
 8238304:	8238f380 	call	8238f38 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 8238308:	0005883a 	mov	r2,zero
 823830c:	00030506 	br	8238f24 <tcp_output+0xff0>
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
      goto send;
 8238310:	0001883a 	nop
 8238314:	00001106 	br	823835c <tcp_output+0x428>
   if (flags & (TH_SYN|TH_RST))
      goto send;
 8238318:	0001883a 	nop
 823831c:	00000f06 	br	823835c <tcp_output+0x428>
   if (SEQ_GT(tp->snd_up, tp->snd_una))
      goto send;
 8238320:	0001883a 	nop
 8238324:	00000d06 	br	823835c <tcp_output+0x428>
    * to send into a small window), then must resend.
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
 8238328:	0001883a 	nop
 823832c:	00000b06 	br	823835c <tcp_output+0x428>
      if ((idle || tp->t_flags & TF_NODELAY) &&
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
 8238330:	0001883a 	nop
 8238334:	00000906 	br	823835c <tcp_output+0x428>
      }
      if (tp->t_force)
         goto send;
 8238338:	0001883a 	nop
 823833c:	00000706 	br	823835c <tcp_output+0x428>
      if (len >= (int)(tp->max_sndwnd / 2))
         goto send;
 8238340:	0001883a 	nop
 8238344:	00000506 	br	823835c <tcp_output+0x428>
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
         goto send;
 8238348:	0001883a 	nop
 823834c:	00000306 	br	823835c <tcp_output+0x428>
   if (win > 0)
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
         goto send;
 8238350:	0001883a 	nop
 8238354:	00000106 	br	823835c <tcp_output+0x428>
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
         goto send;
 8238358:	0001883a 	nop
    * No reason to send a segment, just return.
    */
   return (0);

send:
   ENTER_CRIT_SECTION(tp);
 823835c:	822d3a00 	call	822d3a0 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 8238360:	e0bff417 	ldw	r2,-48(fp)
 8238364:	e0bff115 	stw	r2,-60(fp)
   sendm = so->so_snd.sb_mb;
 8238368:	e0bff217 	ldw	r2,-56(fp)
 823836c:	10801817 	ldw	r2,96(r2)
 8238370:	e0bff015 	stw	r2,-64(fp)
   if (len)
 8238374:	e0bfea17 	ldw	r2,-88(fp)
 8238378:	10005526 	beq	r2,zero,82384d0 <tcp_output+0x59c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 823837c:	00000a06 	br	82383a8 <tcp_output+0x474>
      {
         bufoff -= sendm->m_len;
 8238380:	e0fff117 	ldw	r3,-60(fp)
 8238384:	e0bff017 	ldw	r2,-64(fp)
 8238388:	10800217 	ldw	r2,8(r2)
 823838c:	1885c83a 	sub	r2,r3,r2
 8238390:	e0bff115 	stw	r2,-60(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 8238394:	e0bff117 	ldw	r2,-60(fp)
 8238398:	10000616 	blt	r2,zero,82383b4 <tcp_output+0x480>
            break;
         sendm = sendm->m_next;
 823839c:	e0bff017 	ldw	r2,-64(fp)
 82383a0:	10800617 	ldw	r2,24(r2)
 82383a4:	e0bff015 	stw	r2,-64(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 82383a8:	e0bff017 	ldw	r2,-64(fp)
 82383ac:	103ff41e 	bne	r2,zero,8238380 <tcp_output+0x44c>
 82383b0:	00000106 	br	82383b8 <tcp_output+0x484>
      {
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
 82383b4:	0001883a 	nop
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 82383b8:	e0bff017 	ldw	r2,-64(fp)
 82383bc:	1000011e 	bne	r2,zero,82383c4 <tcp_output+0x490>
 82383c0:	822d1c80 	call	822d1c8 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 82383c4:	e0bff017 	ldw	r2,-64(fp)
 82383c8:	10c00217 	ldw	r3,8(r2)
 82383cc:	e0bff117 	ldw	r2,-60(fp)
 82383d0:	1885883a 	add	r2,r3,r2
 82383d4:	e0bff115 	stw	r2,-60(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 82383d8:	e0bff017 	ldw	r2,-64(fp)
 82383dc:	10800617 	ldw	r2,24(r2)
 82383e0:	10000b26 	beq	r2,zero,8238410 <tcp_output+0x4dc>
 82383e4:	e0bff017 	ldw	r2,-64(fp)
 82383e8:	10800217 	ldw	r2,8(r2)
 82383ec:	1007883a 	mov	r3,r2
 82383f0:	e0bfea17 	ldw	r2,-88(fp)
 82383f4:	1880060e 	bge	r3,r2,8238410 <tcp_output+0x4dc>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 82383f8:	e0ffec17 	ldw	r3,-80(fp)
 82383fc:	00bfff84 	movi	r2,-2
 8238400:	1884703a 	and	r2,r3,r2
 8238404:	e0bfec15 	stw	r2,-80(fp)
         sendalot = 1;     /* set to send more segments */
 8238408:	00800044 	movi	r2,1
 823840c:	e0bfef15 	stw	r2,-68(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 8238410:	e0bfec17 	ldw	r2,-80(fp)
 8238414:	1080004c 	andi	r2,r2,1
 8238418:	10000826 	beq	r2,zero,823843c <tcp_output+0x508>
 823841c:	e0bff217 	ldw	r2,-56(fp)
 8238420:	10801217 	ldw	r2,72(r2)
 8238424:	e0ffea17 	ldw	r3,-88(fp)
 8238428:	1880042e 	bgeu	r3,r2,823843c <tcp_output+0x508>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 823842c:	e0ffec17 	ldw	r3,-80(fp)
 8238430:	00bfff84 	movi	r2,-2
 8238434:	1884703a 	and	r2,r3,r2
 8238438:	e0bfec15 	stw	r2,-80(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 823843c:	e0bff017 	ldw	r2,-64(fp)
 8238440:	10800217 	ldw	r2,8(r2)
 8238444:	e0ffea17 	ldw	r3,-88(fp)
 8238448:	1880010e 	bge	r3,r2,8238450 <tcp_output+0x51c>
 823844c:	1805883a 	mov	r2,r3
 8238450:	e0bfea15 	stw	r2,-88(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 8238454:	e0bff117 	ldw	r2,-60(fp)
 8238458:	1000081e 	bne	r2,zero,823847c <tcp_output+0x548>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
 823845c:	e0bff017 	ldw	r2,-64(fp)
 8238460:	10800317 	ldw	r2,12(r2)
 8238464:	1007883a 	mov	r3,r2
 8238468:	e0bff017 	ldw	r2,-64(fp)
 823846c:	10800417 	ldw	r2,16(r2)
 8238470:	1885c83a 	sub	r2,r3,r2
 8238474:	108000cc 	andi	r2,r2,3
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 8238478:	10001526 	beq	r2,zero,82384d0 <tcp_output+0x59c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 823847c:	e0bff017 	ldw	r2,-64(fp)
 8238480:	10c00217 	ldw	r3,8(r2)
 8238484:	e0bff117 	ldw	r2,-60(fp)
 8238488:	1885c83a 	sub	r2,r3,r2
 823848c:	e0ffea17 	ldw	r3,-88(fp)
 8238490:	1880010e 	bge	r3,r2,8238498 <tcp_output+0x564>
 8238494:	1805883a 	mov	r2,r3
 8238498:	e0bfea15 	stw	r2,-88(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 823849c:	d0a03717 	ldw	r2,-32548(gp)
 82384a0:	10bff204 	addi	r2,r2,-56
 82384a4:	1007883a 	mov	r3,r2
 82384a8:	e0bfea17 	ldw	r2,-88(fp)
 82384ac:	1880080e 	bge	r3,r2,82384d0 <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
 82384b0:	008209b4 	movhi	r2,2086
 82384b4:	10b75904 	addi	r2,r2,-8860
 82384b8:	10800217 	ldw	r2,8(r2)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82384bc:	10800088 	cmpgei	r2,r2,2
 82384c0:	1000031e 	bne	r2,zero,82384d0 <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 82384c4:	d0a03717 	ldw	r2,-32548(gp)
 82384c8:	10bff204 	addi	r2,r2,-56
 82384cc:	e0bfea15 	stw	r2,-88(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 82384d0:	e0bfea17 	ldw	r2,-88(fp)
 82384d4:	10003626 	beq	r2,zero,82385b0 <tcp_output+0x67c>
 82384d8:	e0bff117 	ldw	r2,-60(fp)
 82384dc:	1000341e 	bne	r2,zero,82385b0 <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
 82384e0:	e0bff017 	ldw	r2,-64(fp)
 82384e4:	10800117 	ldw	r2,4(r2)
 82384e8:	10800917 	ldw	r2,36(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 82384ec:	10800058 	cmpnei	r2,r2,1
 82384f0:	10002f1e 	bne	r2,zero,82385b0 <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 82384f4:	e0bff017 	ldw	r2,-64(fp)
 82384f8:	10800317 	ldw	r2,12(r2)
 82384fc:	1007883a 	mov	r3,r2
 8238500:	e0bff017 	ldw	r2,-64(fp)
 8238504:	10800417 	ldw	r2,16(r2)
 8238508:	1885c83a 	sub	r2,r3,r2
 823850c:	108000cc 	andi	r2,r2,3

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
       (sendm->pkt->inuse == 1) &&
 8238510:	1000271e 	bne	r2,zero,82385b0 <tcp_output+0x67c>
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 8238514:	e0bfee17 	ldw	r2,-72(fp)
 8238518:	1000251e 	bne	r2,zero,82385b0 <tcp_output+0x67c>
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 823851c:	000b883a 	mov	r5,zero
 8238520:	01000084 	movi	r4,2
 8238524:	822dfdc0 	call	822dfdc <m_getnbuf>
 8238528:	e0bfed15 	stw	r2,-76(fp)
      if (!m)
 823852c:	e0bfed17 	ldw	r2,-76(fp)
 8238530:	1000031e 	bne	r2,zero,8238540 <tcp_output+0x60c>
      {
         EXIT_CRIT_SECTION(tp);
 8238534:	822d4000 	call	822d400 <irq_Unmask>
         return (ENOBUFS);
 8238538:	00801a44 	movi	r2,105
 823853c:	00027906 	br	8238f24 <tcp_output+0xff0>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 8238540:	e0bff017 	ldw	r2,-64(fp)
 8238544:	10c00117 	ldw	r3,4(r2)
 8238548:	e0bfed17 	ldw	r2,-76(fp)
 823854c:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 8238550:	e0bfed17 	ldw	r2,-76(fp)
 8238554:	10800117 	ldw	r2,4(r2)
 8238558:	10c00917 	ldw	r3,36(r2)
 823855c:	18c00044 	addi	r3,r3,1
 8238560:	10c00915 	stw	r3,36(r2)
      m->m_base = sendm->m_base; /* clone mbuf members */
 8238564:	e0bff017 	ldw	r2,-64(fp)
 8238568:	10c00417 	ldw	r3,16(r2)
 823856c:	e0bfed17 	ldw	r2,-76(fp)
 8238570:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 8238574:	e0bff017 	ldw	r2,-64(fp)
 8238578:	10c00517 	ldw	r3,20(r2)
 823857c:	e0bfed17 	ldw	r2,-76(fp)
 8238580:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 8238584:	e0bfea17 	ldw	r2,-88(fp)
 8238588:	10800a04 	addi	r2,r2,40
 823858c:	1007883a 	mov	r3,r2
 8238590:	e0bfed17 	ldw	r2,-76(fp)
 8238594:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 8238598:	e0bff017 	ldw	r2,-64(fp)
 823859c:	10800317 	ldw	r2,12(r2)
 82385a0:	10fff604 	addi	r3,r2,-40
 82385a4:	e0bfed17 	ldw	r2,-76(fp)
 82385a8:	10c00315 	stw	r3,12(r2)
 82385ac:	00002706 	br	823864c <tcp_output+0x718>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 82385b0:	d0a08117 	ldw	r2,-32252(gp)
 82385b4:	10800a04 	addi	r2,r2,40
 82385b8:	100b883a 	mov	r5,r2
 82385bc:	010000c4 	movi	r4,3
 82385c0:	822dfdc0 	call	822dfdc <m_getnbuf>
 82385c4:	e0bfed15 	stw	r2,-76(fp)
      if (m ==(struct mbuf *)NULL)
 82385c8:	e0bfed17 	ldw	r2,-76(fp)
 82385cc:	1000031e 	bne	r2,zero,82385dc <tcp_output+0x6a8>
      {
         EXIT_CRIT_SECTION(tp);
 82385d0:	822d4000 	call	822d400 <irq_Unmask>
         return ENOBUFS;
 82385d4:	00801a44 	movi	r2,105
 82385d8:	00025206 	br	8238f24 <tcp_output+0xff0>
      }

      m->m_len = TCPIPHDRSZ;
 82385dc:	e0bfed17 	ldw	r2,-76(fp)
 82385e0:	00c00a04 	movi	r3,40
 82385e4:	10c00215 	stw	r3,8(r2)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 82385e8:	e0bfed17 	ldw	r2,-76(fp)
 82385ec:	10800317 	ldw	r2,12(r2)
 82385f0:	d0e08117 	ldw	r3,-32252(gp)
 82385f4:	10c7883a 	add	r3,r2,r3
 82385f8:	e0bfed17 	ldw	r2,-76(fp)
 82385fc:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 8238600:	e0bfea17 	ldw	r2,-88(fp)
 8238604:	10001126 	beq	r2,zero,823864c <tcp_output+0x718>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 8238608:	e0bff217 	ldw	r2,-56(fp)
 823860c:	10801817 	ldw	r2,96(r2)
 8238610:	e1bfea17 	ldw	r6,-88(fp)
 8238614:	e17ff417 	ldw	r5,-48(fp)
 8238618:	1009883a 	mov	r4,r2
 823861c:	822e2b00 	call	822e2b0 <m_copy>
 8238620:	1007883a 	mov	r3,r2
 8238624:	e0bfed17 	ldw	r2,-76(fp)
 8238628:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 823862c:	e0bfed17 	ldw	r2,-76(fp)
 8238630:	10800617 	ldw	r2,24(r2)
 8238634:	1000051e 	bne	r2,zero,823864c <tcp_output+0x718>
         {
            m_freem(m);
 8238638:	e13fed17 	ldw	r4,-76(fp)
 823863c:	822e26c0 	call	822e26c <m_freem>
            EXIT_CRIT_SECTION(tp);
 8238640:	822d4000 	call	822d400 <irq_Unmask>
            return ENOBUFS;
 8238644:	00801a44 	movi	r2,105
 8238648:	00023606 	br	8238f24 <tcp_output+0xff0>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 823864c:	822d4000 	call	822d400 <irq_Unmask>

   if (len) 
 8238650:	e0bfea17 	ldw	r2,-88(fp)
 8238654:	10003726 	beq	r2,zero,8238734 <tcp_output+0x800>
   {
      if (tp->t_force && len == 1)
 8238658:	e0bfff17 	ldw	r2,-4(fp)
 823865c:	10800a83 	ldbu	r2,42(r2)
 8238660:	10803fcc 	andi	r2,r2,255
 8238664:	1080201c 	xori	r2,r2,128
 8238668:	10bfe004 	addi	r2,r2,-128
 823866c:	10000b26 	beq	r2,zero,823869c <tcp_output+0x768>
 8238670:	e0bfea17 	ldw	r2,-88(fp)
 8238674:	10800058 	cmpnei	r2,r2,1
 8238678:	1000081e 	bne	r2,zero,823869c <tcp_output+0x768>
         tcpstat.tcps_sndprobe++;
 823867c:	008209b4 	movhi	r2,2086
 8238680:	10b82204 	addi	r2,r2,-8056
 8238684:	10801517 	ldw	r2,84(r2)
 8238688:	10c00044 	addi	r3,r2,1
 823868c:	008209b4 	movhi	r2,2086
 8238690:	10b82204 	addi	r2,r2,-8056
 8238694:	10c01515 	stw	r3,84(r2)
 8238698:	00005306 	br	82387e8 <tcp_output+0x8b4>
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 823869c:	e0bfff17 	ldw	r2,-4(fp)
 82386a0:	10c00f17 	ldw	r3,60(r2)
 82386a4:	e0bfff17 	ldw	r2,-4(fp)
 82386a8:	10801a17 	ldw	r2,104(r2)
 82386ac:	1885c83a 	sub	r2,r3,r2
 82386b0:	1000100e 	bge	r2,zero,82386f4 <tcp_output+0x7c0>
      {
         tcpstat.tcps_sndrexmitpack++;
 82386b4:	008209b4 	movhi	r2,2086
 82386b8:	10b82204 	addi	r2,r2,-8056
 82386bc:	10801217 	ldw	r2,72(r2)
 82386c0:	10c00044 	addi	r3,r2,1
 82386c4:	008209b4 	movhi	r2,2086
 82386c8:	10b82204 	addi	r2,r2,-8056
 82386cc:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 82386d0:	008209b4 	movhi	r2,2086
 82386d4:	10b82204 	addi	r2,r2,-8056
 82386d8:	10c01317 	ldw	r3,76(r2)
 82386dc:	e0bfea17 	ldw	r2,-88(fp)
 82386e0:	1887883a 	add	r3,r3,r2
 82386e4:	008209b4 	movhi	r2,2086
 82386e8:	10b82204 	addi	r2,r2,-8056
 82386ec:	10c01315 	stw	r3,76(r2)
 82386f0:	00003d06 	br	82387e8 <tcp_output+0x8b4>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 82386f4:	008209b4 	movhi	r2,2086
 82386f8:	10b82204 	addi	r2,r2,-8056
 82386fc:	10801017 	ldw	r2,64(r2)
 8238700:	10c00044 	addi	r3,r2,1
 8238704:	008209b4 	movhi	r2,2086
 8238708:	10b82204 	addi	r2,r2,-8056
 823870c:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 8238710:	008209b4 	movhi	r2,2086
 8238714:	10b82204 	addi	r2,r2,-8056
 8238718:	10c01117 	ldw	r3,68(r2)
 823871c:	e0bfea17 	ldw	r2,-88(fp)
 8238720:	1887883a 	add	r3,r3,r2
 8238724:	008209b4 	movhi	r2,2086
 8238728:	10b82204 	addi	r2,r2,-8056
 823872c:	10c01115 	stw	r3,68(r2)
 8238730:	00002d06 	br	82387e8 <tcp_output+0x8b4>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 8238734:	e0bfff17 	ldw	r2,-4(fp)
 8238738:	10800b0b 	ldhu	r2,44(r2)
 823873c:	10bfffcc 	andi	r2,r2,65535
 8238740:	1080004c 	andi	r2,r2,1
 8238744:	10000826 	beq	r2,zero,8238768 <tcp_output+0x834>
   {
      tcpstat.tcps_sndacks++;
 8238748:	008209b4 	movhi	r2,2086
 823874c:	10b82204 	addi	r2,r2,-8056
 8238750:	10801417 	ldw	r2,80(r2)
 8238754:	10c00044 	addi	r3,r2,1
 8238758:	008209b4 	movhi	r2,2086
 823875c:	10b82204 	addi	r2,r2,-8056
 8238760:	10c01415 	stw	r3,80(r2)
 8238764:	00002006 	br	82387e8 <tcp_output+0x8b4>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 8238768:	e0bfec17 	ldw	r2,-80(fp)
 823876c:	108001cc 	andi	r2,r2,7
 8238770:	10000826 	beq	r2,zero,8238794 <tcp_output+0x860>
      tcpstat.tcps_sndctrl++;
 8238774:	008209b4 	movhi	r2,2086
 8238778:	10b82204 	addi	r2,r2,-8056
 823877c:	10801817 	ldw	r2,96(r2)
 8238780:	10c00044 	addi	r3,r2,1
 8238784:	008209b4 	movhi	r2,2086
 8238788:	10b82204 	addi	r2,r2,-8056
 823878c:	10c01815 	stw	r3,96(r2)
 8238790:	00001506 	br	82387e8 <tcp_output+0x8b4>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 8238794:	e0bfff17 	ldw	r2,-4(fp)
 8238798:	10c01017 	ldw	r3,64(r2)
 823879c:	e0bfff17 	ldw	r2,-4(fp)
 82387a0:	10800e17 	ldw	r2,56(r2)
 82387a4:	1885c83a 	sub	r2,r3,r2
 82387a8:	0080080e 	bge	zero,r2,82387cc <tcp_output+0x898>
      tcpstat.tcps_sndurg++;
 82387ac:	008209b4 	movhi	r2,2086
 82387b0:	10b82204 	addi	r2,r2,-8056
 82387b4:	10801617 	ldw	r2,88(r2)
 82387b8:	10c00044 	addi	r3,r2,1
 82387bc:	008209b4 	movhi	r2,2086
 82387c0:	10b82204 	addi	r2,r2,-8056
 82387c4:	10c01615 	stw	r3,88(r2)
 82387c8:	00000706 	br	82387e8 <tcp_output+0x8b4>
   else
      tcpstat.tcps_sndwinup++;
 82387cc:	008209b4 	movhi	r2,2086
 82387d0:	10b82204 	addi	r2,r2,-8056
 82387d4:	10801717 	ldw	r2,92(r2)
 82387d8:	10c00044 	addi	r3,r2,1
 82387dc:	008209b4 	movhi	r2,2086
 82387e0:	10b82204 	addi	r2,r2,-8056
 82387e4:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 82387e8:	e0bfed17 	ldw	r2,-76(fp)
 82387ec:	10800317 	ldw	r2,12(r2)
 82387f0:	e0bff515 	stw	r2,-44(fp)
   if ((char *)ti < m->pkt->nb_buff)
 82387f4:	e0bfed17 	ldw	r2,-76(fp)
 82387f8:	10800117 	ldw	r2,4(r2)
 82387fc:	10800117 	ldw	r2,4(r2)
 8238800:	e0fff517 	ldw	r3,-44(fp)
 8238804:	1880032e 	bgeu	r3,r2,8238814 <tcp_output+0x8e0>
   {
      panic("tcp_out- packet ptr underflow\n");
 8238808:	01020974 	movhi	r4,2085
 823880c:	21023904 	addi	r4,r4,2276
 8238810:	822887c0 	call	822887c <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 8238814:	e0bfed17 	ldw	r2,-76(fp)
 8238818:	e0bff615 	stw	r2,-40(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 823881c:	e0bfff17 	ldw	r2,-4(fp)
 8238820:	10800c17 	ldw	r2,48(r2)
 8238824:	1000031e 	bne	r2,zero,8238834 <tcp_output+0x900>
      panic("tcp_output");
 8238828:	01020974 	movhi	r4,2085
 823882c:	21024104 	addi	r4,r4,2308
 8238830:	822887c0 	call	822887c <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 8238834:	e0bfff17 	ldw	r2,-4(fp)
 8238838:	10800c17 	ldw	r2,48(r2)
 823883c:	01800a04 	movi	r6,40
 8238840:	100b883a 	mov	r5,r2
 8238844:	e13ff517 	ldw	r4,-44(fp)
 8238848:	8202a0c0 	call	8202a0c <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 823884c:	e0bfec17 	ldw	r2,-80(fp)
 8238850:	1080004c 	andi	r2,r2,1
 8238854:	10000f26 	beq	r2,zero,8238894 <tcp_output+0x960>
 8238858:	e0bfff17 	ldw	r2,-4(fp)
 823885c:	10800b0b 	ldhu	r2,44(r2)
 8238860:	10bfffcc 	andi	r2,r2,65535
 8238864:	1080040c 	andi	r2,r2,16
 8238868:	10000a26 	beq	r2,zero,8238894 <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
 823886c:	e0bfff17 	ldw	r2,-4(fp)
 8238870:	10c00f17 	ldw	r3,60(r2)
 8238874:	e0bfff17 	ldw	r2,-4(fp)
 8238878:	10801a17 	ldw	r2,104(r2)
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 823887c:	1880051e 	bne	r3,r2,8238894 <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 8238880:	e0bfff17 	ldw	r2,-4(fp)
 8238884:	10800f17 	ldw	r2,60(r2)
 8238888:	10ffffc4 	addi	r3,r2,-1
 823888c:	e0bfff17 	ldw	r2,-4(fp)
 8238890:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 8238894:	e0bfff17 	ldw	r2,-4(fp)
 8238898:	10800f17 	ldw	r2,60(r2)
 823889c:	1006d63a 	srli	r3,r2,24
 82388a0:	e0bfff17 	ldw	r2,-4(fp)
 82388a4:	10800f17 	ldw	r2,60(r2)
 82388a8:	1004d23a 	srli	r2,r2,8
 82388ac:	10bfc00c 	andi	r2,r2,65280
 82388b0:	1886b03a 	or	r3,r3,r2
 82388b4:	e0bfff17 	ldw	r2,-4(fp)
 82388b8:	10800f17 	ldw	r2,60(r2)
 82388bc:	10bfc00c 	andi	r2,r2,65280
 82388c0:	1004923a 	slli	r2,r2,8
 82388c4:	1886b03a 	or	r3,r3,r2
 82388c8:	e0bfff17 	ldw	r2,-4(fp)
 82388cc:	10800f17 	ldw	r2,60(r2)
 82388d0:	1004963a 	slli	r2,r2,24
 82388d4:	1886b03a 	or	r3,r3,r2
 82388d8:	e0bff517 	ldw	r2,-44(fp)
 82388dc:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 82388e0:	e0bfff17 	ldw	r2,-4(fp)
 82388e4:	10801617 	ldw	r2,88(r2)
 82388e8:	1006d63a 	srli	r3,r2,24
 82388ec:	e0bfff17 	ldw	r2,-4(fp)
 82388f0:	10801617 	ldw	r2,88(r2)
 82388f4:	1004d23a 	srli	r2,r2,8
 82388f8:	10bfc00c 	andi	r2,r2,65280
 82388fc:	1886b03a 	or	r3,r3,r2
 8238900:	e0bfff17 	ldw	r2,-4(fp)
 8238904:	10801617 	ldw	r2,88(r2)
 8238908:	10bfc00c 	andi	r2,r2,65280
 823890c:	1004923a 	slli	r2,r2,8
 8238910:	1886b03a 	or	r3,r3,r2
 8238914:	e0bfff17 	ldw	r2,-4(fp)
 8238918:	10801617 	ldw	r2,88(r2)
 823891c:	1004963a 	slli	r2,r2,24
 8238920:	1886b03a 	or	r3,r3,r2
 8238924:	e0bff517 	ldw	r2,-44(fp)
 8238928:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 823892c:	e0bfec17 	ldw	r2,-80(fp)
 8238930:	1080008c 	andi	r2,r2,2
 8238934:	10002426 	beq	r2,zero,82389c8 <tcp_output+0xa94>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 8238938:	e0bff217 	ldw	r2,-56(fp)
 823893c:	10800117 	ldw	r2,4(r2)
 8238940:	e0bff715 	stw	r2,-36(fp)

      switch(so->so_domain)
 8238944:	e0bff217 	ldw	r2,-56(fp)
 8238948:	10800517 	ldw	r2,20(r2)
 823894c:	108000a0 	cmpeqi	r2,r2,2
 8238950:	10001a26 	beq	r2,zero,82389bc <tcp_output+0xa88>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 8238954:	e0bfec17 	ldw	r2,-80(fp)
 8238958:	1080040c 	andi	r2,r2,16
 823895c:	1000191e 	bne	r2,zero,82389c4 <tcp_output+0xa90>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 8238960:	e0bff517 	ldw	r2,-44(fp)
 8238964:	10800417 	ldw	r2,16(r2)
 8238968:	e0fffe04 	addi	r3,fp,-8
 823896c:	180b883a 	mov	r5,r3
 8238970:	1009883a 	mov	r4,r2
 8238974:	824093c0 	call	824093c <iproute>
 8238978:	e0bff815 	stw	r2,-32(fp)
               if(ifp)
 823897c:	e0bff817 	ldw	r2,-32(fp)
 8238980:	10000926 	beq	r2,zero,82389a8 <tcp_output+0xa74>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8238984:	e0bff817 	ldw	r2,-32(fp)
 8238988:	10c00917 	ldw	r3,36(r2)
 823898c:	e0bff817 	ldw	r2,-32(fp)
 8238990:	10800817 	ldw	r2,32(r2)
 8238994:	10800a04 	addi	r2,r2,40
 8238998:	1887c83a 	sub	r3,r3,r2
 823899c:	e0bff717 	ldw	r2,-36(fp)
 82389a0:	10c00615 	stw	r3,24(r2)
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 82389a4:	00000706 	br	82389c4 <tcp_output+0xa90>
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
               if(ifp)
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 82389a8:	e0bff717 	ldw	r2,-36(fp)
 82389ac:	00c09104 	movi	r3,580
 82389b0:	10c00615 	stw	r3,24(r2)
            }
#endif   /* IP_PMTU */
         }
         break;
 82389b4:	0001883a 	nop
 82389b8:	00000206 	br	82389c4 <tcp_output+0xa90>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 82389bc:	822d1c80 	call	822d1c8 <dtrap>
 82389c0:	00000106 	br	82389c8 <tcp_output+0xa94>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 82389c4:	0001883a 	nop
         dtrap();    /* bad domain setting */
      }
   }

   /* fill in options if any are set */
   if (optlen)
 82389c8:	e0bfee17 	ldw	r2,-72(fp)
 82389cc:	10002b26 	beq	r2,zero,8238a7c <tcp_output+0xb48>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 82389d0:	01404004 	movi	r5,256
 82389d4:	01000084 	movi	r4,2
 82389d8:	822dfdc0 	call	822dfdc <m_getnbuf>
 82389dc:	e0bff915 	stw	r2,-28(fp)
      if (mopt == NULL) 
 82389e0:	e0bff917 	ldw	r2,-28(fp)
 82389e4:	1000041e 	bne	r2,zero,82389f8 <tcp_output+0xac4>
      {
         m_freem(m);
 82389e8:	e13fed17 	ldw	r4,-76(fp)
 82389ec:	822e26c0 	call	822e26c <m_freem>
         return (ENOBUFS);
 82389f0:	00801a44 	movi	r2,105
 82389f4:	00014b06 	br	8238f24 <tcp_output+0xff0>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 82389f8:	e0bff617 	ldw	r2,-40(fp)
 82389fc:	10c00617 	ldw	r3,24(r2)
 8238a00:	e0bff917 	ldw	r2,-28(fp)
 8238a04:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 8238a08:	e0bff617 	ldw	r2,-40(fp)
 8238a0c:	e0fff917 	ldw	r3,-28(fp)
 8238a10:	10c00615 	stw	r3,24(r2)

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238a14:	00000606 	br	8238a30 <tcp_output+0xafc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 8238a18:	e0bfee17 	ldw	r2,-72(fp)
 8238a1c:	10c00044 	addi	r3,r2,1
 8238a20:	e0ffee15 	stw	r3,-72(fp)
 8238a24:	d0e0b304 	addi	r3,gp,-32052
 8238a28:	10c5883a 	add	r2,r2,r3
 8238a2c:	10000005 	stb	zero,0(r2)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238a30:	e0bfee17 	ldw	r2,-72(fp)
 8238a34:	108000cc 	andi	r2,r2,3
 8238a38:	103ff71e 	bne	r2,zero,8238a18 <tcp_output+0xae4>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 8238a3c:	e0bff917 	ldw	r2,-28(fp)
 8238a40:	10800317 	ldw	r2,12(r2)
 8238a44:	e1bfee17 	ldw	r6,-72(fp)
 8238a48:	d160b304 	addi	r5,gp,-32052
 8238a4c:	1009883a 	mov	r4,r2
 8238a50:	8202a0c0 	call	8202a0c <memcpy>
      mopt->m_len = optlen;
 8238a54:	e0bff917 	ldw	r2,-28(fp)
 8238a58:	e0ffee17 	ldw	r3,-72(fp)
 8238a5c:	10c00215 	stw	r3,8(r2)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 8238a60:	e0bfee17 	ldw	r2,-72(fp)
 8238a64:	10800504 	addi	r2,r2,20
 8238a68:	1004d0ba 	srli	r2,r2,2
 8238a6c:	1004913a 	slli	r2,r2,4
 8238a70:	1007883a 	mov	r3,r2
 8238a74:	e0bff517 	ldw	r2,-44(fp)
 8238a78:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 8238a7c:	e0bfec17 	ldw	r2,-80(fp)
 8238a80:	1007883a 	mov	r3,r2
 8238a84:	e0bff517 	ldw	r2,-44(fp)
 8238a88:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 8238a8c:	e0bff217 	ldw	r2,-56(fp)
 8238a90:	10800b17 	ldw	r2,44(r2)
 8238a94:	1004d0ba 	srli	r2,r2,2
 8238a98:	1007883a 	mov	r3,r2
 8238a9c:	e0bfeb17 	ldw	r2,-84(fp)
 8238aa0:	10c0060e 	bge	r2,r3,8238abc <tcp_output+0xb88>
 8238aa4:	e0bfff17 	ldw	r2,-4(fp)
 8238aa8:	10800a0b 	ldhu	r2,40(r2)
 8238aac:	10bfffcc 	andi	r2,r2,65535
 8238ab0:	e0ffeb17 	ldw	r3,-84(fp)
 8238ab4:	1880010e 	bge	r3,r2,8238abc <tcp_output+0xb88>
      win = 0;
 8238ab8:	e03feb15 	stw	zero,-84(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 8238abc:	e0bfff17 	ldw	r2,-4(fp)
 8238ac0:	10c01917 	ldw	r3,100(r2)
 8238ac4:	e0bfff17 	ldw	r2,-4(fp)
 8238ac8:	10801617 	ldw	r2,88(r2)
 8238acc:	1885c83a 	sub	r2,r3,r2
 8238ad0:	1007883a 	mov	r3,r2
 8238ad4:	e0bfeb17 	ldw	r2,-84(fp)
 8238ad8:	10c0060e 	bge	r2,r3,8238af4 <tcp_output+0xbc0>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 8238adc:	e0bfff17 	ldw	r2,-4(fp)
 8238ae0:	10c01917 	ldw	r3,100(r2)
 8238ae4:	e0bfff17 	ldw	r2,-4(fp)
 8238ae8:	10801617 	ldw	r2,88(r2)
 8238aec:	1885c83a 	sub	r2,r3,r2
 8238af0:	e0bfeb15 	stw	r2,-84(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 8238af4:	008209b4 	movhi	r2,2086
 8238af8:	10b75904 	addi	r2,r2,-8860
 8238afc:	10800217 	ldw	r2,8(r2)
 8238b00:	1000021e 	bne	r2,zero,8238b0c <tcp_output+0xbd8>
   {
      win = 0;
 8238b04:	e03feb15 	stw	zero,-84(fp)
 8238b08:	00001006 	br	8238b4c <tcp_output+0xc18>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 8238b0c:	008209b4 	movhi	r2,2086
 8238b10:	10b75904 	addi	r2,r2,-8860
 8238b14:	10800217 	ldw	r2,8(r2)
 8238b18:	10bfffc4 	addi	r2,r2,-1
 8238b1c:	d0e03917 	ldw	r3,-32540(gp)
 8238b20:	10c7383a 	mul	r3,r2,r3
 8238b24:	e0bfeb17 	ldw	r2,-84(fp)
 8238b28:	1880080e 	bge	r3,r2,8238b4c <tcp_output+0xc18>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 8238b2c:	008209b4 	movhi	r2,2086
 8238b30:	10b75904 	addi	r2,r2,-8860
 8238b34:	10800217 	ldw	r2,8(r2)
 8238b38:	10bfffc4 	addi	r2,r2,-1
 8238b3c:	1007883a 	mov	r3,r2
 8238b40:	d0a03917 	ldw	r2,-32540(gp)
 8238b44:	1885383a 	mul	r2,r3,r2
 8238b48:	e0bfeb15 	stw	r2,-84(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 8238b4c:	e0bfeb17 	ldw	r2,-84(fp)
 8238b50:	10bfffcc 	andi	r2,r2,65535
 8238b54:	1005d23a 	srai	r2,r2,8
 8238b58:	10803fcc 	andi	r2,r2,255
 8238b5c:	1007883a 	mov	r3,r2
 8238b60:	e0bfeb17 	ldw	r2,-84(fp)
 8238b64:	10bfffcc 	andi	r2,r2,65535
 8238b68:	1004923a 	slli	r2,r2,8
 8238b6c:	1884b03a 	or	r2,r3,r2
 8238b70:	1007883a 	mov	r3,r2
 8238b74:	e0bff517 	ldw	r2,-44(fp)
 8238b78:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 8238b7c:	e0bfff17 	ldw	r2,-4(fp)
 8238b80:	10c01017 	ldw	r3,64(r2)
 8238b84:	e0bfff17 	ldw	r2,-4(fp)
 8238b88:	10800f17 	ldw	r2,60(r2)
 8238b8c:	1885c83a 	sub	r2,r3,r2
 8238b90:	00801c0e 	bge	zero,r2,8238c04 <tcp_output+0xcd0>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 8238b94:	e0bfff17 	ldw	r2,-4(fp)
 8238b98:	10801017 	ldw	r2,64(r2)
 8238b9c:	1007883a 	mov	r3,r2
 8238ba0:	e0bfff17 	ldw	r2,-4(fp)
 8238ba4:	10800f17 	ldw	r2,60(r2)
 8238ba8:	1885c83a 	sub	r2,r3,r2
 8238bac:	10bfffcc 	andi	r2,r2,65535
 8238bb0:	1004d23a 	srli	r2,r2,8
 8238bb4:	1007883a 	mov	r3,r2
 8238bb8:	e0bfff17 	ldw	r2,-4(fp)
 8238bbc:	10801017 	ldw	r2,64(r2)
 8238bc0:	1009883a 	mov	r4,r2
 8238bc4:	e0bfff17 	ldw	r2,-4(fp)
 8238bc8:	10800f17 	ldw	r2,60(r2)
 8238bcc:	2085c83a 	sub	r2,r4,r2
 8238bd0:	10bfffcc 	andi	r2,r2,65535
 8238bd4:	1004923a 	slli	r2,r2,8
 8238bd8:	1884b03a 	or	r2,r3,r2
 8238bdc:	1007883a 	mov	r3,r2
 8238be0:	e0bff517 	ldw	r2,-44(fp)
 8238be4:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 8238be8:	e0bff517 	ldw	r2,-44(fp)
 8238bec:	10800843 	ldbu	r2,33(r2)
 8238bf0:	10800814 	ori	r2,r2,32
 8238bf4:	1007883a 	mov	r3,r2
 8238bf8:	e0bff517 	ldw	r2,-44(fp)
 8238bfc:	10c00845 	stb	r3,33(r2)
 8238c00:	00000406 	br	8238c14 <tcp_output+0xce0>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 8238c04:	e0bfff17 	ldw	r2,-4(fp)
 8238c08:	10c00e17 	ldw	r3,56(r2)
 8238c0c:	e0bfff17 	ldw	r2,-4(fp)
 8238c10:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 8238c14:	e0bfea17 	ldw	r2,-88(fp)
 8238c18:	10000c26 	beq	r2,zero,8238c4c <tcp_output+0xd18>
 8238c1c:	e0fff417 	ldw	r3,-48(fp)
 8238c20:	e0bfea17 	ldw	r2,-88(fp)
 8238c24:	1885883a 	add	r2,r3,r2
 8238c28:	e0fff217 	ldw	r3,-56(fp)
 8238c2c:	18c01217 	ldw	r3,72(r3)
 8238c30:	10c0061e 	bne	r2,r3,8238c4c <tcp_output+0xd18>
      ti->ti_flags |= TH_PUSH;
 8238c34:	e0bff517 	ldw	r2,-44(fp)
 8238c38:	10800843 	ldbu	r2,33(r2)
 8238c3c:	10800214 	ori	r2,r2,8
 8238c40:	1007883a 	mov	r3,r2
 8238c44:	e0bff517 	ldw	r2,-44(fp)
 8238c48:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 8238c4c:	e0bfff17 	ldw	r2,-4(fp)
 8238c50:	10800a83 	ldbu	r2,42(r2)
 8238c54:	10803fcc 	andi	r2,r2,255
 8238c58:	1080201c 	xori	r2,r2,128
 8238c5c:	10bfe004 	addi	r2,r2,-128
 8238c60:	10000326 	beq	r2,zero,8238c70 <tcp_output+0xd3c>
 8238c64:	e0bfff17 	ldw	r2,-4(fp)
 8238c68:	10800417 	ldw	r2,16(r2)
 8238c6c:	10004d1e 	bne	r2,zero,8238da4 <tcp_output+0xe70>
   {
      tcp_seq startseq = tp->snd_nxt;
 8238c70:	e0bfff17 	ldw	r2,-4(fp)
 8238c74:	10800f17 	ldw	r2,60(r2)
 8238c78:	e0bffa15 	stw	r2,-24(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 8238c7c:	e0bfec17 	ldw	r2,-80(fp)
 8238c80:	1080008c 	andi	r2,r2,2
 8238c84:	10000526 	beq	r2,zero,8238c9c <tcp_output+0xd68>
         tp->snd_nxt++;
 8238c88:	e0bfff17 	ldw	r2,-4(fp)
 8238c8c:	10800f17 	ldw	r2,60(r2)
 8238c90:	10c00044 	addi	r3,r2,1
 8238c94:	e0bfff17 	ldw	r2,-4(fp)
 8238c98:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 8238c9c:	e0bfec17 	ldw	r2,-80(fp)
 8238ca0:	1080004c 	andi	r2,r2,1
 8238ca4:	10000b26 	beq	r2,zero,8238cd4 <tcp_output+0xda0>
      {
         tp->snd_nxt++;
 8238ca8:	e0bfff17 	ldw	r2,-4(fp)
 8238cac:	10800f17 	ldw	r2,60(r2)
 8238cb0:	10c00044 	addi	r3,r2,1
 8238cb4:	e0bfff17 	ldw	r2,-4(fp)
 8238cb8:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 8238cbc:	e0bfff17 	ldw	r2,-4(fp)
 8238cc0:	10800b0b 	ldhu	r2,44(r2)
 8238cc4:	10800414 	ori	r2,r2,16
 8238cc8:	1007883a 	mov	r3,r2
 8238ccc:	e0bfff17 	ldw	r2,-4(fp)
 8238cd0:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 8238cd4:	e0bfff17 	ldw	r2,-4(fp)
 8238cd8:	10c00f17 	ldw	r3,60(r2)
 8238cdc:	e0bfea17 	ldw	r2,-88(fp)
 8238ce0:	1887883a 	add	r3,r3,r2
 8238ce4:	e0bfff17 	ldw	r2,-4(fp)
 8238ce8:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 8238cec:	e0bfff17 	ldw	r2,-4(fp)
 8238cf0:	10c00f17 	ldw	r3,60(r2)
 8238cf4:	e0bfff17 	ldw	r2,-4(fp)
 8238cf8:	10801a17 	ldw	r2,104(r2)
 8238cfc:	1885c83a 	sub	r2,r3,r2
 8238d00:	0080140e 	bge	zero,r2,8238d54 <tcp_output+0xe20>
      {
         tp->snd_max = tp->snd_nxt;
 8238d04:	e0bfff17 	ldw	r2,-4(fp)
 8238d08:	10c00f17 	ldw	r3,60(r2)
 8238d0c:	e0bfff17 	ldw	r2,-4(fp)
 8238d10:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 8238d14:	e0bfff17 	ldw	r2,-4(fp)
 8238d18:	10801e17 	ldw	r2,120(r2)
 8238d1c:	10000d1e 	bne	r2,zero,8238d54 <tcp_output+0xe20>
         {
            tp->t_rttick = cticks;
 8238d20:	d0e0a817 	ldw	r3,-32096(gp)
 8238d24:	e0bfff17 	ldw	r2,-4(fp)
 8238d28:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 8238d2c:	e0bfff17 	ldw	r2,-4(fp)
 8238d30:	e0fffa17 	ldw	r3,-24(fp)
 8238d34:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_segstimed++;
 8238d38:	008209b4 	movhi	r2,2086
 8238d3c:	10b82204 	addi	r2,r2,-8056
 8238d40:	10800617 	ldw	r2,24(r2)
 8238d44:	10c00044 	addi	r3,r2,1
 8238d48:	008209b4 	movhi	r2,2086
 8238d4c:	10b82204 	addi	r2,r2,-8056
 8238d50:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8238d54:	e0bfff17 	ldw	r2,-4(fp)
 8238d58:	10800317 	ldw	r2,12(r2)
 8238d5c:	1000201e 	bne	r2,zero,8238de0 <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
 8238d60:	e0bfff17 	ldw	r2,-4(fp)
 8238d64:	10c00f17 	ldw	r3,60(r2)
 8238d68:	e0bfff17 	ldw	r2,-4(fp)
 8238d6c:	10800e17 	ldw	r2,56(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8238d70:	18801b26 	beq	r3,r2,8238de0 <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8238d74:	e0bfff17 	ldw	r2,-4(fp)
 8238d78:	10c00817 	ldw	r3,32(r2)
 8238d7c:	e0bfff17 	ldw	r2,-4(fp)
 8238d80:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 8238d84:	e0bfff17 	ldw	r2,-4(fp)
 8238d88:	10800417 	ldw	r2,16(r2)
 8238d8c:	10001426 	beq	r2,zero,8238de0 <tcp_output+0xeac>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 8238d90:	e0bfff17 	ldw	r2,-4(fp)
 8238d94:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 8238d98:	e0bfff17 	ldw	r2,-4(fp)
 8238d9c:	10000715 	stw	zero,28(r2)
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 8238da0:	00000f06 	br	8238de0 <tcp_output+0xeac>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 8238da4:	e0bfff17 	ldw	r2,-4(fp)
 8238da8:	10c00f17 	ldw	r3,60(r2)
 8238dac:	e0bfea17 	ldw	r2,-88(fp)
 8238db0:	1887883a 	add	r3,r3,r2
 8238db4:	e0bfff17 	ldw	r2,-4(fp)
 8238db8:	10801a17 	ldw	r2,104(r2)
 8238dbc:	1885c83a 	sub	r2,r3,r2
 8238dc0:	0080080e 	bge	zero,r2,8238de4 <tcp_output+0xeb0>
         tp->snd_max = tp->snd_nxt + len;
 8238dc4:	e0bfff17 	ldw	r2,-4(fp)
 8238dc8:	10c00f17 	ldw	r3,60(r2)
 8238dcc:	e0bfea17 	ldw	r2,-88(fp)
 8238dd0:	1887883a 	add	r3,r3,r2
 8238dd4:	e0bfff17 	ldw	r2,-4(fp)
 8238dd8:	10c01a15 	stw	r3,104(r2)
 8238ddc:	00000106 	br	8238de4 <tcp_output+0xeb0>
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 8238de0:	0001883a 	nop
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 8238de4:	e03ffb15 	stw	zero,-20(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 8238de8:	e0bfed17 	ldw	r2,-76(fp)
 8238dec:	10800317 	ldw	r2,12(r2)
 8238df0:	e0bffc15 	stw	r2,-16(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 8238df4:	e0bfee17 	ldw	r2,-72(fp)
 8238df8:	1007883a 	mov	r3,r2
 8238dfc:	e0bfea17 	ldw	r2,-88(fp)
 8238e00:	1885883a 	add	r2,r3,r2
 8238e04:	10800a04 	addi	r2,r2,40
 8238e08:	1007883a 	mov	r3,r2
 8238e0c:	e0bffc17 	ldw	r2,-16(fp)
 8238e10:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 8238e14:	e0bff217 	ldw	r2,-56(fp)
 8238e18:	10801f17 	ldw	r2,124(r2)
 8238e1c:	100b883a 	mov	r5,r2
 8238e20:	e13fed17 	ldw	r4,-76(fp)
 8238e24:	822ec080 	call	822ec08 <ip_output>
 8238e28:	e0bffb15 	stw	r2,-20(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 8238e2c:	e0bffb17 	ldw	r2,-20(fp)
 8238e30:	10001326 	beq	r2,zero,8238e80 <tcp_output+0xf4c>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 8238e34:	e0bffb17 	ldw	r2,-20(fp)
 8238e38:	10801a58 	cmpnei	r2,r2,105
 8238e3c:	10000e1e 	bne	r2,zero,8238e78 <tcp_output+0xf44>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 8238e40:	e0bfed17 	ldw	r2,-76(fp)
 8238e44:	10800817 	ldw	r2,32(r2)
 8238e48:	1000031e 	bne	r2,zero,8238e58 <tcp_output+0xf24>
            m = m->m_next;
 8238e4c:	e0bfed17 	ldw	r2,-76(fp)
 8238e50:	10800617 	ldw	r2,24(r2)
 8238e54:	e0bfed15 	stw	r2,-76(fp)
         m_freem(m); /* free the mbuf chain */
 8238e58:	e13fed17 	ldw	r4,-76(fp)
 8238e5c:	822e26c0 	call	822e26c <m_freem>
         tcp_quench(tp->t_inpcb);
 8238e60:	e0bfff17 	ldw	r2,-4(fp)
 8238e64:	10800d17 	ldw	r2,52(r2)
 8238e68:	1009883a 	mov	r4,r2
 8238e6c:	82399040 	call	8239904 <tcp_quench>
         return (error);
 8238e70:	e0bffb17 	ldw	r2,-20(fp)
 8238e74:	00002b06 	br	8238f24 <tcp_output+0xff0>
      }
      return (error);
 8238e78:	e0bffb17 	ldw	r2,-20(fp)
 8238e7c:	00002906 	br	8238f24 <tcp_output+0xff0>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 8238e80:	008209b4 	movhi	r2,2086
 8238e84:	10b7f404 	addi	r2,r2,-8240
 8238e88:	10800a17 	ldw	r2,40(r2)
 8238e8c:	10c00044 	addi	r3,r2,1
 8238e90:	008209b4 	movhi	r2,2086
 8238e94:	10b7f404 	addi	r2,r2,-8240
 8238e98:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 8238e9c:	008209b4 	movhi	r2,2086
 8238ea0:	10b82204 	addi	r2,r2,-8056
 8238ea4:	10800f17 	ldw	r2,60(r2)
 8238ea8:	10c00044 	addi	r3,r2,1
 8238eac:	008209b4 	movhi	r2,2086
 8238eb0:	10b82204 	addi	r2,r2,-8056
 8238eb4:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 8238eb8:	e0bfeb17 	ldw	r2,-84(fp)
 8238ebc:	00800e0e 	bge	zero,r2,8238ef8 <tcp_output+0xfc4>
 8238ec0:	e0bfff17 	ldw	r2,-4(fp)
 8238ec4:	10c01617 	ldw	r3,88(r2)
 8238ec8:	e0bfeb17 	ldw	r2,-84(fp)
 8238ecc:	1887883a 	add	r3,r3,r2
 8238ed0:	e0bfff17 	ldw	r2,-4(fp)
 8238ed4:	10801917 	ldw	r2,100(r2)
 8238ed8:	1885c83a 	sub	r2,r3,r2
 8238edc:	0080060e 	bge	zero,r2,8238ef8 <tcp_output+0xfc4>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 8238ee0:	e0bfff17 	ldw	r2,-4(fp)
 8238ee4:	10c01617 	ldw	r3,88(r2)
 8238ee8:	e0bfeb17 	ldw	r2,-84(fp)
 8238eec:	1887883a 	add	r3,r3,r2
 8238ef0:	e0bfff17 	ldw	r2,-4(fp)
 8238ef4:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 8238ef8:	e0bfff17 	ldw	r2,-4(fp)
 8238efc:	10c00b0b 	ldhu	r3,44(r2)
 8238f00:	00bfef04 	movi	r2,-68
 8238f04:	1884703a 	and	r2,r3,r2
 8238f08:	1007883a 	mov	r3,r2
 8238f0c:	e0bfff17 	ldw	r2,-4(fp)
 8238f10:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 8238f14:	e0bfef17 	ldw	r2,-68(fp)
 8238f18:	10000126 	beq	r2,zero,8238f20 <tcp_output+0xfec>
      goto again;
 8238f1c:	003c1606 	br	8237f78 <tcp_output+0x44>
   return (0);
 8238f20:	0005883a 	mov	r2,zero
}
 8238f24:	e037883a 	mov	sp,fp
 8238f28:	dfc00117 	ldw	ra,4(sp)
 8238f2c:	df000017 	ldw	fp,0(sp)
 8238f30:	dec00204 	addi	sp,sp,8
 8238f34:	f800283a 	ret

08238f38 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 8238f38:	defffc04 	addi	sp,sp,-16
 8238f3c:	dfc00315 	stw	ra,12(sp)
 8238f40:	df000215 	stw	fp,8(sp)
 8238f44:	df000204 	addi	fp,sp,8
 8238f48:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8238f4c:	e0bfff17 	ldw	r2,-4(fp)
 8238f50:	10802017 	ldw	r2,128(r2)
 8238f54:	1007d0ba 	srai	r3,r2,2
 8238f58:	e0bfff17 	ldw	r2,-4(fp)
 8238f5c:	10802117 	ldw	r2,132(r2)
 8238f60:	1885883a 	add	r2,r3,r2
 8238f64:	1005d07a 	srai	r2,r2,1
 8238f68:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 8238f6c:	e0bfff17 	ldw	r2,-4(fp)
 8238f70:	10800317 	ldw	r2,12(r2)
 8238f74:	10000326 	beq	r2,zero,8238f84 <tcp_setpersist+0x4c>
      panic("tcp_output REXMT");
 8238f78:	01020974 	movhi	r4,2085
 8238f7c:	21024404 	addi	r4,r4,2320
 8238f80:	822887c0 	call	822887c <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 8238f84:	e0bffe17 	ldw	r2,-8(fp)
 8238f88:	1009883a 	mov	r4,r2
 8238f8c:	e0bfff17 	ldw	r2,-4(fp)
 8238f90:	10c00717 	ldw	r3,28(r2)
 8238f94:	00820974 	movhi	r2,2085
 8238f98:	108d5cc4 	addi	r2,r2,13683
 8238f9c:	10c5883a 	add	r2,r2,r3
 8238fa0:	10800003 	ldbu	r2,0(r2)
 8238fa4:	10803fcc 	andi	r2,r2,255
 8238fa8:	2085383a 	mul	r2,r4,r2
 8238fac:	10ffffcc 	andi	r3,r2,65535
 8238fb0:	18e0001c 	xori	r3,r3,32768
 8238fb4:	18e00004 	addi	r3,r3,-32768
 8238fb8:	e0bfff17 	ldw	r2,-4(fp)
 8238fbc:	10c00415 	stw	r3,16(r2)
 8238fc0:	e0bfff17 	ldw	r2,-4(fp)
 8238fc4:	10800417 	ldw	r2,16(r2)
 8238fc8:	10800288 	cmpgei	r2,r2,10
 8238fcc:	1000041e 	bne	r2,zero,8238fe0 <tcp_setpersist+0xa8>
 8238fd0:	e0bfff17 	ldw	r2,-4(fp)
 8238fd4:	00c00284 	movi	r3,10
 8238fd8:	10c00415 	stw	r3,16(r2)
 8238fdc:	00000706 	br	8238ffc <tcp_setpersist+0xc4>
 8238fe0:	e0bfff17 	ldw	r2,-4(fp)
 8238fe4:	10800417 	ldw	r2,16(r2)
 8238fe8:	10801e50 	cmplti	r2,r2,121
 8238fec:	1000031e 	bne	r2,zero,8238ffc <tcp_setpersist+0xc4>
 8238ff0:	e0bfff17 	ldw	r2,-4(fp)
 8238ff4:	00c01e04 	movi	r3,120
 8238ff8:	10c00415 	stw	r3,16(r2)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 8238ffc:	e0bfff17 	ldw	r2,-4(fp)
 8239000:	10800717 	ldw	r2,28(r2)
 8239004:	10800308 	cmpgei	r2,r2,12
 8239008:	1000051e 	bne	r2,zero,8239020 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 823900c:	e0bfff17 	ldw	r2,-4(fp)
 8239010:	10800717 	ldw	r2,28(r2)
 8239014:	10c00044 	addi	r3,r2,1
 8239018:	e0bfff17 	ldw	r2,-4(fp)
 823901c:	10c00715 	stw	r3,28(r2)

}
 8239020:	0001883a 	nop
 8239024:	e037883a 	mov	sp,fp
 8239028:	dfc00117 	ldw	ra,4(sp)
 823902c:	df000017 	ldw	fp,0(sp)
 8239030:	dec00204 	addi	sp,sp,8
 8239034:	f800283a 	ret

08239038 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 8239038:	defff804 	addi	sp,sp,-32
 823903c:	dfc00715 	stw	ra,28(sp)
 8239040:	df000615 	stw	fp,24(sp)
 8239044:	df000604 	addi	fp,sp,24
 8239048:	e13ffc15 	stw	r4,-16(fp)
 823904c:	e17ffd15 	stw	r5,-12(fp)
 8239050:	e1bffe15 	stw	r6,-8(fp)
 8239054:	e1ffff15 	stw	r7,-4(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 8239058:	e0bffc17 	ldw	r2,-16(fp)
 823905c:	10800b0b 	ldhu	r2,44(r2)
 8239060:	10bfffcc 	andi	r2,r2,65535
 8239064:	1080020c 	andi	r2,r2,8
 8239068:	10000226 	beq	r2,zero,8239074 <bld_options+0x3c>
      return 0;
 823906c:	0005883a 	mov	r2,zero
 8239070:	00001e06 	br	82390ec <bld_options+0xb4>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 8239074:	e0bffe17 	ldw	r2,-8(fp)
 8239078:	1080008c 	andi	r2,r2,2
 823907c:	10001926 	beq	r2,zero,82390e4 <bld_options+0xac>
   {
      mss   =  (u_short)tcp_mss(so);
 8239080:	e13fff17 	ldw	r4,-4(fp)
 8239084:	8237e3c0 	call	8237e3c <tcp_mss>
 8239088:	e0bffb0d 	sth	r2,-20(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 823908c:	e0bffd17 	ldw	r2,-12(fp)
 8239090:	00c00084 	movi	r3,2
 8239094:	10c00005 	stb	r3,0(r2)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 8239098:	e0bffd17 	ldw	r2,-12(fp)
 823909c:	10800044 	addi	r2,r2,1
 82390a0:	00c00104 	movi	r3,4
 82390a4:	10c00005 	stb	r3,0(r2)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 82390a8:	e0bffd17 	ldw	r2,-12(fp)
 82390ac:	10800084 	addi	r2,r2,2
 82390b0:	e0fffb0b 	ldhu	r3,-20(fp)
 82390b4:	1806d23a 	srli	r3,r3,8
 82390b8:	10c00005 	stb	r3,0(r2)
      *(cp + 3)  = (u_char) (mss & 0xff);
 82390bc:	e0bffd17 	ldw	r2,-12(fp)
 82390c0:	108000c4 	addi	r2,r2,3
 82390c4:	e0fffb0b 	ldhu	r3,-20(fp)
 82390c8:	10c00005 	stb	r3,0(r2)
      len = 4;
 82390cc:	00800104 	movi	r2,4
 82390d0:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 82390d4:	e0bffd17 	ldw	r2,-12(fp)
 82390d8:	10800104 	addi	r2,r2,4
 82390dc:	e0bffd15 	stw	r2,-12(fp)
 82390e0:	00000106 	br	82390e8 <bld_options+0xb0>
   }
   else
      len = 0;
 82390e4:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 82390e8:	e0bffa17 	ldw	r2,-24(fp)
}
 82390ec:	e037883a 	mov	sp,fp
 82390f0:	dfc00117 	ldw	ra,4(sp)
 82390f4:	df000017 	ldw	fp,0(sp)
 82390f8:	dec00204 	addi	sp,sp,8
 82390fc:	f800283a 	ret

08239100 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 8239100:	deffff04 	addi	sp,sp,-4
 8239104:	df000015 	stw	fp,0(sp)
 8239108:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 823910c:	00800044 	movi	r2,1
 8239110:	d0a0b515 	stw	r2,-32044(gp)
   tcb.inp_next = tcb.inp_prev = &tcb;
 8239114:	008209b4 	movhi	r2,2086
 8239118:	10b81704 	addi	r2,r2,-8100
 823911c:	00c209b4 	movhi	r3,2086
 8239120:	18f81704 	addi	r3,r3,-8100
 8239124:	10c00115 	stw	r3,4(r2)
 8239128:	008209b4 	movhi	r2,2086
 823912c:	10b81704 	addi	r2,r2,-8100
 8239130:	10c00117 	ldw	r3,4(r2)
 8239134:	008209b4 	movhi	r2,2086
 8239138:	10b81704 	addi	r2,r2,-8100
 823913c:	10c00015 	stw	r3,0(r2)
}
 8239140:	0001883a 	nop
 8239144:	e037883a 	mov	sp,fp
 8239148:	df000017 	ldw	fp,0(sp)
 823914c:	dec00104 	addi	sp,sp,4
 8239150:	f800283a 	ret

08239154 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 8239154:	defffb04 	addi	sp,sp,-20
 8239158:	dfc00415 	stw	ra,16(sp)
 823915c:	df000315 	stw	fp,12(sp)
 8239160:	df000304 	addi	fp,sp,12
 8239164:	e13fff15 	stw	r4,-4(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 8239168:	e0bfff17 	ldw	r2,-4(fp)
 823916c:	10800d17 	ldw	r2,52(r2)
 8239170:	e0bffe15 	stw	r2,-8(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 8239174:	e0bfff17 	ldw	r2,-4(fp)
 8239178:	10800c17 	ldw	r2,48(r2)
 823917c:	e0bffd15 	stw	r2,-12(fp)
 8239180:	e0bffd17 	ldw	r2,-12(fp)
 8239184:	1000071e 	bne	r2,zero,82391a4 <tcp_template+0x50>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 8239188:	01000a04 	movi	r4,40
 823918c:	822dda00 	call	822dda0 <npalloc>
 8239190:	e0bffd15 	stw	r2,-12(fp)
      if (n == NULL)
 8239194:	e0bffd17 	ldw	r2,-12(fp)
 8239198:	1000021e 	bne	r2,zero,82391a4 <tcp_template+0x50>
         return (0);
 823919c:	0005883a 	mov	r2,zero
 82391a0:	00002906 	br	8239248 <tcp_template+0xf4>
   }
   n->ti_next = n->ti_prev = 0;
 82391a4:	e0bffd17 	ldw	r2,-12(fp)
 82391a8:	10000115 	stw	zero,4(r2)
 82391ac:	e0bffd17 	ldw	r2,-12(fp)
 82391b0:	10c00117 	ldw	r3,4(r2)
 82391b4:	e0bffd17 	ldw	r2,-12(fp)
 82391b8:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 82391bc:	e0bffd17 	ldw	r2,-12(fp)
 82391c0:	00c50004 	movi	r3,5120
 82391c4:	10c0028d 	sth	r3,10(r2)
   n->ti_src = inp->inp_laddr;
 82391c8:	e0bffd17 	ldw	r2,-12(fp)
 82391cc:	e0fffe17 	ldw	r3,-8(fp)
 82391d0:	18c00417 	ldw	r3,16(r3)
 82391d4:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 82391d8:	e0bffd17 	ldw	r2,-12(fp)
 82391dc:	e0fffe17 	ldw	r3,-8(fp)
 82391e0:	18c00317 	ldw	r3,12(r3)
 82391e4:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 82391e8:	e0bffe17 	ldw	r2,-8(fp)
 82391ec:	10c0078b 	ldhu	r3,30(r2)
 82391f0:	e0bffd17 	ldw	r2,-12(fp)
 82391f4:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 82391f8:	e0bffe17 	ldw	r2,-8(fp)
 82391fc:	10c0070b 	ldhu	r3,28(r2)
 8239200:	e0bffd17 	ldw	r2,-12(fp)
 8239204:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 8239208:	e0bffd17 	ldw	r2,-12(fp)
 823920c:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 8239210:	e0bffd17 	ldw	r2,-12(fp)
 8239214:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 8239218:	e0bffd17 	ldw	r2,-12(fp)
 823921c:	00c01404 	movi	r3,80
 8239220:	10c00805 	stb	r3,32(r2)
   n->ti_flags = 0;
 8239224:	e0bffd17 	ldw	r2,-12(fp)
 8239228:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 823922c:	e0bffd17 	ldw	r2,-12(fp)
 8239230:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 8239234:	e0bffd17 	ldw	r2,-12(fp)
 8239238:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 823923c:	e0bffd17 	ldw	r2,-12(fp)
 8239240:	1000098d 	sth	zero,38(r2)
   return (n);
 8239244:	e0bffd17 	ldw	r2,-12(fp)
}
 8239248:	e037883a 	mov	sp,fp
 823924c:	dfc00117 	ldw	ra,4(sp)
 8239250:	df000017 	ldw	fp,0(sp)
 8239254:	dec00204 	addi	sp,sp,8
 8239258:	f800283a 	ret

0823925c <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 823925c:	defff204 	addi	sp,sp,-56
 8239260:	dfc00d15 	stw	ra,52(sp)
 8239264:	df000c15 	stw	fp,48(sp)
 8239268:	df000c04 	addi	fp,sp,48
 823926c:	e13ffc15 	stw	r4,-16(fp)
 8239270:	e17ffd15 	stw	r5,-12(fp)
 8239274:	e1bffe15 	stw	r6,-8(fp)
 8239278:	e1ffff15 	stw	r7,-4(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 823927c:	e03ff615 	stw	zero,-40(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 8239280:	e0bffc17 	ldw	r2,-16(fp)
 8239284:	10001726 	beq	r2,zero,82392e4 <tcp_respond+0x88>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 8239288:	e0bffc17 	ldw	r2,-16(fp)
 823928c:	10800d17 	ldw	r2,52(r2)
 8239290:	10800817 	ldw	r2,32(r2)
 8239294:	10800b17 	ldw	r2,44(r2)
 8239298:	1007883a 	mov	r3,r2
 823929c:	e0bffc17 	ldw	r2,-16(fp)
 82392a0:	10800d17 	ldw	r2,52(r2)
 82392a4:	10800817 	ldw	r2,32(r2)
 82392a8:	10800a17 	ldw	r2,40(r2)
 82392ac:	1885c83a 	sub	r2,r3,r2
 82392b0:	10000a16 	blt	r2,zero,82392dc <tcp_respond+0x80>
 82392b4:	e0bffc17 	ldw	r2,-16(fp)
 82392b8:	10800d17 	ldw	r2,52(r2)
 82392bc:	10800817 	ldw	r2,32(r2)
 82392c0:	10c00b17 	ldw	r3,44(r2)
 82392c4:	e0bffc17 	ldw	r2,-16(fp)
 82392c8:	10800d17 	ldw	r2,52(r2)
 82392cc:	10800817 	ldw	r2,32(r2)
 82392d0:	10800a17 	ldw	r2,40(r2)
 82392d4:	1885c83a 	sub	r2,r3,r2
 82392d8:	00000106 	br	82392e0 <tcp_respond+0x84>
 82392dc:	0005883a 	mov	r2,zero
 82392e0:	e0bff615 	stw	r2,-40(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 82392e4:	e0800217 	ldw	r2,8(fp)
 82392e8:	1000261e 	bne	r2,zero,8239384 <tcp_respond+0x128>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 82392ec:	01401004 	movi	r5,64
 82392f0:	010000c4 	movi	r4,3
 82392f4:	822dfdc0 	call	822dfdc <m_getnbuf>
 82392f8:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 82392fc:	e0bff717 	ldw	r2,-36(fp)
 8239300:	1000d026 	beq	r2,zero,8239644 <tcp_respond+0x3e8>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 8239304:	00800044 	movi	r2,1
 8239308:	e0bff415 	stw	r2,-48(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 823930c:	e0bff417 	ldw	r2,-48(fp)
 8239310:	10800a04 	addi	r2,r2,40
 8239314:	1007883a 	mov	r3,r2
 8239318:	e0bff717 	ldw	r2,-36(fp)
 823931c:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 8239320:	e0bff717 	ldw	r2,-36(fp)
 8239324:	10800317 	ldw	r2,12(r2)
 8239328:	e0bff815 	stw	r2,-32(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 823932c:	e0bff717 	ldw	r2,-36(fp)
 8239330:	10800117 	ldw	r2,4(r2)
 8239334:	10800117 	ldw	r2,4(r2)
 8239338:	e0fff817 	ldw	r3,-32(fp)
 823933c:	1880032e 	bgeu	r3,r2,823934c <tcp_respond+0xf0>
      {
         panic("tcp_respond- packet ptr underflow\n");
 8239340:	01020974 	movhi	r4,2085
 8239344:	21024904 	addi	r4,r4,2340
 8239348:	822887c0 	call	822887c <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 823934c:	01800a04 	movi	r6,40
 8239350:	e17ffd17 	ldw	r5,-12(fp)
 8239354:	e13ff817 	ldw	r4,-32(fp)
 8239358:	8202a0c0 	call	8202a0c <memcpy>
      ti = tmp_thdr;
 823935c:	e0bff817 	ldw	r2,-32(fp)
 8239360:	e0bffd15 	stw	r2,-12(fp)
      flags = TH_ACK;
 8239364:	00800404 	movi	r2,16
 8239368:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 823936c:	e0bffc17 	ldw	r2,-16(fp)
 8239370:	10800d17 	ldw	r2,52(r2)
 8239374:	10800817 	ldw	r2,32(r2)
 8239378:	10800517 	ldw	r2,20(r2)
 823937c:	e0bff515 	stw	r2,-44(fp)
 8239380:	00003b06 	br	8239470 <tcp_respond+0x214>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 8239384:	e0800317 	ldw	r2,12(fp)
 8239388:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 823938c:	e0bff717 	ldw	r2,-36(fp)
 8239390:	10800117 	ldw	r2,4(r2)
 8239394:	1080080b 	ldhu	r2,32(r2)
 8239398:	10bfffcc 	andi	r2,r2,65535
 823939c:	10800218 	cmpnei	r2,r2,8
 82393a0:	1000031e 	bne	r2,zero,82393b0 <tcp_respond+0x154>
         domain = AF_INET;
 82393a4:	00800084 	movi	r2,2
 82393a8:	e0bff515 	stw	r2,-44(fp)
 82393ac:	00000206 	br	82393b8 <tcp_respond+0x15c>
      else
         domain = AF_INET6;
 82393b0:	008000c4 	movi	r2,3
 82393b4:	e0bff515 	stw	r2,-44(fp)

      m_freem(m->m_next);
 82393b8:	e0bff717 	ldw	r2,-36(fp)
 82393bc:	10800617 	ldw	r2,24(r2)
 82393c0:	1009883a 	mov	r4,r2
 82393c4:	822e26c0 	call	822e26c <m_freem>
      m->m_next = 0;
 82393c8:	e0bff717 	ldw	r2,-36(fp)
 82393cc:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 82393d0:	e03ff415 	stw	zero,-48(fp)
      m->m_len = TCPIPHDRSZ;
 82393d4:	e0bff717 	ldw	r2,-36(fp)
 82393d8:	00c00a04 	movi	r3,40
 82393dc:	10c00215 	stw	r3,8(r2)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 82393e0:	e0bffd17 	ldw	r2,-12(fp)
 82393e4:	1080058b 	ldhu	r2,22(r2)
 82393e8:	e0bff90d 	sth	r2,-28(fp)
 82393ec:	e0bffd17 	ldw	r2,-12(fp)
 82393f0:	10c0050b 	ldhu	r3,20(r2)
 82393f4:	e0bffd17 	ldw	r2,-12(fp)
 82393f8:	10c0058d 	sth	r3,22(r2)
 82393fc:	e0bffd17 	ldw	r2,-12(fp)
 8239400:	e0fff90b 	ldhu	r3,-28(fp)
 8239404:	10c0050d 	sth	r3,20(r2)
      if(m->pkt->type == IPTP)
 8239408:	e0bff717 	ldw	r2,-36(fp)
 823940c:	10800117 	ldw	r2,4(r2)
 8239410:	1080080b 	ldhu	r2,32(r2)
 8239414:	10bfffcc 	andi	r2,r2,65535
 8239418:	10800218 	cmpnei	r2,r2,8
 823941c:	10000a1e 	bne	r2,zero,8239448 <tcp_respond+0x1ec>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 8239420:	e0bffd17 	ldw	r2,-12(fp)
 8239424:	10800417 	ldw	r2,16(r2)
 8239428:	e0bffa15 	stw	r2,-24(fp)
 823942c:	e0bffd17 	ldw	r2,-12(fp)
 8239430:	10c00317 	ldw	r3,12(r2)
 8239434:	e0bffd17 	ldw	r2,-12(fp)
 8239438:	10c00415 	stw	r3,16(r2)
 823943c:	e0bffd17 	ldw	r2,-12(fp)
 8239440:	e0fffa17 	ldw	r3,-24(fp)
 8239444:	10c00315 	stw	r3,12(r2)
      if (flags & TH_RST)  /* count resets in MIB */
 8239448:	e0800217 	ldw	r2,8(fp)
 823944c:	1080010c 	andi	r2,r2,4
 8239450:	10000726 	beq	r2,zero,8239470 <tcp_respond+0x214>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 8239454:	008209b4 	movhi	r2,2086
 8239458:	10b7f404 	addi	r2,r2,-8240
 823945c:	10800e17 	ldw	r2,56(r2)
 8239460:	10c00044 	addi	r3,r2,1
 8239464:	008209b4 	movhi	r2,2086
 8239468:	10b7f404 	addi	r2,r2,-8240
 823946c:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 8239470:	e0bfff17 	ldw	r2,-4(fp)
 8239474:	1006d63a 	srli	r3,r2,24
 8239478:	e0bfff17 	ldw	r2,-4(fp)
 823947c:	1004d23a 	srli	r2,r2,8
 8239480:	10bfc00c 	andi	r2,r2,65280
 8239484:	1886b03a 	or	r3,r3,r2
 8239488:	e0bfff17 	ldw	r2,-4(fp)
 823948c:	10bfc00c 	andi	r2,r2,65280
 8239490:	1004923a 	slli	r2,r2,8
 8239494:	1886b03a 	or	r3,r3,r2
 8239498:	e0bfff17 	ldw	r2,-4(fp)
 823949c:	1004963a 	slli	r2,r2,24
 82394a0:	1886b03a 	or	r3,r3,r2
 82394a4:	e0bffd17 	ldw	r2,-12(fp)
 82394a8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 82394ac:	e0bffe17 	ldw	r2,-8(fp)
 82394b0:	1006d63a 	srli	r3,r2,24
 82394b4:	e0bffe17 	ldw	r2,-8(fp)
 82394b8:	1004d23a 	srli	r2,r2,8
 82394bc:	10bfc00c 	andi	r2,r2,65280
 82394c0:	1886b03a 	or	r3,r3,r2
 82394c4:	e0bffe17 	ldw	r2,-8(fp)
 82394c8:	10bfc00c 	andi	r2,r2,65280
 82394cc:	1004923a 	slli	r2,r2,8
 82394d0:	1886b03a 	or	r3,r3,r2
 82394d4:	e0bffe17 	ldw	r2,-8(fp)
 82394d8:	1004963a 	slli	r2,r2,24
 82394dc:	1886b03a 	or	r3,r3,r2
 82394e0:	e0bffd17 	ldw	r2,-12(fp)
 82394e4:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 82394e8:	e0bffd17 	ldw	r2,-12(fp)
 82394ec:	00c01404 	movi	r3,80
 82394f0:	10c00805 	stb	r3,32(r2)
   ti->ti_flags = (u_char)flags;
 82394f4:	e0800217 	ldw	r2,8(fp)
 82394f8:	1007883a 	mov	r3,r2
 82394fc:	e0bffd17 	ldw	r2,-12(fp)
 8239500:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 8239504:	e0bff617 	ldw	r2,-40(fp)
 8239508:	10bfffcc 	andi	r2,r2,65535
 823950c:	1005d23a 	srai	r2,r2,8
 8239510:	10803fcc 	andi	r2,r2,255
 8239514:	1007883a 	mov	r3,r2
 8239518:	e0bff617 	ldw	r2,-40(fp)
 823951c:	10bfffcc 	andi	r2,r2,65535
 8239520:	1004923a 	slli	r2,r2,8
 8239524:	1884b03a 	or	r2,r3,r2
 8239528:	1007883a 	mov	r3,r2
 823952c:	e0bffd17 	ldw	r2,-12(fp)
 8239530:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 8239534:	e0bffd17 	ldw	r2,-12(fp)
 8239538:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 823953c:	e0bff517 	ldw	r2,-44(fp)
 8239540:	108000a0 	cmpeqi	r2,r2,2
 8239544:	10003b26 	beq	r2,zero,8239634 <tcp_respond+0x3d8>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 8239548:	e0bffd17 	ldw	r2,-12(fp)
 823954c:	e0bffb15 	stw	r2,-20(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 8239550:	e0bff417 	ldw	r2,-48(fp)
 8239554:	10800a04 	addi	r2,r2,40
 8239558:	1007883a 	mov	r3,r2
 823955c:	e0bffb17 	ldw	r2,-20(fp)
 8239560:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 8239564:	e0bff717 	ldw	r2,-36(fp)
 8239568:	10800117 	ldw	r2,4(r2)
 823956c:	10800117 	ldw	r2,4(r2)
 8239570:	d0e08117 	ldw	r3,-32252(gp)
 8239574:	10c5883a 	add	r2,r2,r3
 8239578:	e0fffb17 	ldw	r3,-20(fp)
 823957c:	18800436 	bltu	r3,r2,8239590 <tcp_respond+0x334>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 8239580:	e0bff717 	ldw	r2,-36(fp)
 8239584:	e0fffb17 	ldw	r3,-20(fp)
 8239588:	10c00315 	stw	r3,12(r2)
 823958c:	00001106 	br	82395d4 <tcp_respond+0x378>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 8239590:	e0bff717 	ldw	r2,-36(fp)
 8239594:	10800117 	ldw	r2,4(r2)
 8239598:	e0fff717 	ldw	r3,-36(fp)
 823959c:	18c00117 	ldw	r3,4(r3)
 82395a0:	18c00117 	ldw	r3,4(r3)
 82395a4:	d1208117 	ldw	r4,-32252(gp)
 82395a8:	1907883a 	add	r3,r3,r4
 82395ac:	10c00315 	stw	r3,12(r2)
 82395b0:	10c00317 	ldw	r3,12(r2)
 82395b4:	e0bff717 	ldw	r2,-36(fp)
 82395b8:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 82395bc:	e0bff717 	ldw	r2,-36(fp)
 82395c0:	10800317 	ldw	r2,12(r2)
 82395c4:	01800a04 	movi	r6,40
 82395c8:	e17ffb17 	ldw	r5,-20(fp)
 82395cc:	1009883a 	mov	r4,r2
 82395d0:	8202b540 	call	8202b54 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 82395d4:	e0bffc17 	ldw	r2,-16(fp)
 82395d8:	1000031e 	bne	r2,zero,82395e8 <tcp_respond+0x38c>
              m_freem(m);
 82395dc:	e13ff717 	ldw	r4,-36(fp)
 82395e0:	822e26c0 	call	822e26c <m_freem>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 82395e4:	00001506 	br	823963c <tcp_respond+0x3e0>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 82395e8:	e0bffc17 	ldw	r2,-16(fp)
 82395ec:	10800d17 	ldw	r2,52(r2)
 82395f0:	10000c26 	beq	r2,zero,8239624 <tcp_respond+0x3c8>
 82395f4:	e0bffc17 	ldw	r2,-16(fp)
 82395f8:	10800d17 	ldw	r2,52(r2)
 82395fc:	10800817 	ldw	r2,32(r2)
 8239600:	10000826 	beq	r2,zero,8239624 <tcp_respond+0x3c8>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 8239604:	e0bffc17 	ldw	r2,-16(fp)
 8239608:	10800d17 	ldw	r2,52(r2)
 823960c:	10800817 	ldw	r2,32(r2)
 8239610:	10801f17 	ldw	r2,124(r2)
 8239614:	100b883a 	mov	r5,r2
 8239618:	e13ff717 	ldw	r4,-36(fp)
 823961c:	822ec080 	call	822ec08 <ip_output>
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 8239620:	00000606 	br	823963c <tcp_respond+0x3e0>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 8239624:	000b883a 	mov	r5,zero
 8239628:	e13ff717 	ldw	r4,-36(fp)
 823962c:	822ec080 	call	822ec08 <ip_output>
		 }

         break;
 8239630:	00000206 	br	823963c <tcp_respond+0x3e0>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 8239634:	822d1c80 	call	822d1c8 <dtrap>
         break;
 8239638:	0001883a 	nop
   }
   return;
 823963c:	0001883a 	nop
 8239640:	00000106 	br	8239648 <tcp_respond+0x3ec>
   if (flags == 0)   /* sending keepalive from timer */
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
      if (m == NULL)
         return;
 8239644:	0001883a 	nop
      default:
         dtrap();
         break;
   }
   return;
}
 8239648:	e037883a 	mov	sp,fp
 823964c:	dfc00117 	ldw	ra,4(sp)
 8239650:	df000017 	ldw	fp,0(sp)
 8239654:	dec00204 	addi	sp,sp,8
 8239658:	f800283a 	ret

0823965c <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 823965c:	defffb04 	addi	sp,sp,-20
 8239660:	dfc00415 	stw	ra,16(sp)
 8239664:	df000315 	stw	fp,12(sp)
 8239668:	df000304 	addi	fp,sp,12
 823966c:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 8239670:	01002504 	movi	r4,148
 8239674:	822dda00 	call	822dda0 <npalloc>
 8239678:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 823967c:	e0bffd17 	ldw	r2,-12(fp)
 8239680:	1000021e 	bne	r2,zero,823968c <tcp_newtcpcb+0x30>
      return (struct tcpcb *)NULL;
 8239684:	0005883a 	mov	r2,zero
 8239688:	00003206 	br	8239754 <tcp_newtcpcb+0xf8>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 823968c:	e0bffd17 	ldw	r2,-12(fp)
 8239690:	e0fffd17 	ldw	r3,-12(fp)
 8239694:	10c00115 	stw	r3,4(r2)
 8239698:	e0bffd17 	ldw	r2,-12(fp)
 823969c:	10c00117 	ldw	r3,4(r2)
 82396a0:	e0bffd17 	ldw	r2,-12(fp)
 82396a4:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 82396a8:	e0bffd17 	ldw	r2,-12(fp)
 82396ac:	00c16d04 	movi	r3,1460
 82396b0:	10c00a0d 	sth	r3,40(r2)
   tp->t_flags = 0;        /* sends options! */
 82396b4:	e0bffd17 	ldw	r2,-12(fp)
 82396b8:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 82396bc:	e0bffd17 	ldw	r2,-12(fp)
 82396c0:	e0ffff17 	ldw	r3,-4(fp)
 82396c4:	10c00d15 	stw	r3,52(r2)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 82396c8:	e0bffd17 	ldw	r2,-12(fp)
 82396cc:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 82396d0:	e0bffd17 	ldw	r2,-12(fp)
 82396d4:	00c00604 	movi	r3,24
 82396d8:	10c02115 	stw	r3,132(r2)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 82396dc:	00800304 	movi	r2,12
 82396e0:	e0bffe0d 	sth	r2,-8(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 82396e4:	e0fffe0f 	ldh	r3,-8(fp)
 82396e8:	e0bffd17 	ldw	r2,-12(fp)
 82396ec:	10c00815 	stw	r3,32(r2)
 82396f0:	e0bffd17 	ldw	r2,-12(fp)
 82396f4:	10800817 	ldw	r2,32(r2)
 82396f8:	10800088 	cmpgei	r2,r2,2
 82396fc:	1000041e 	bne	r2,zero,8239710 <tcp_newtcpcb+0xb4>
 8239700:	e0bffd17 	ldw	r2,-12(fp)
 8239704:	00c00084 	movi	r3,2
 8239708:	10c00815 	stw	r3,32(r2)
 823970c:	00000706 	br	823972c <tcp_newtcpcb+0xd0>
 8239710:	e0bffd17 	ldw	r2,-12(fp)
 8239714:	10800817 	ldw	r2,32(r2)
 8239718:	10802050 	cmplti	r2,r2,129
 823971c:	1000031e 	bne	r2,zero,823972c <tcp_newtcpcb+0xd0>
 8239720:	e0bffd17 	ldw	r2,-12(fp)
 8239724:	00c02004 	movi	r3,128
 8239728:	10c00815 	stw	r3,32(r2)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 823972c:	e0bffd17 	ldw	r2,-12(fp)
 8239730:	00c2da04 	movi	r3,2920
 8239734:	10c01b15 	stw	r3,108(r2)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 8239738:	e0bffd17 	ldw	r2,-12(fp)
 823973c:	00ffffd4 	movui	r3,65535
 8239740:	10c01c15 	stw	r3,112(r2)

   inp->inp_ppcb = (char *)tp;
 8239744:	e0bfff17 	ldw	r2,-4(fp)
 8239748:	e0fffd17 	ldw	r3,-12(fp)
 823974c:	10c00915 	stw	r3,36(r2)
   return (tp);
 8239750:	e0bffd17 	ldw	r2,-12(fp)
}
 8239754:	e037883a 	mov	sp,fp
 8239758:	dfc00117 	ldw	ra,4(sp)
 823975c:	df000017 	ldw	fp,0(sp)
 8239760:	dec00204 	addi	sp,sp,8
 8239764:	f800283a 	ret

08239768 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 8239768:	defffb04 	addi	sp,sp,-20
 823976c:	dfc00415 	stw	ra,16(sp)
 8239770:	df000315 	stw	fp,12(sp)
 8239774:	df000304 	addi	fp,sp,12
 8239778:	e13ffe15 	stw	r4,-8(fp)
 823977c:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8239780:	e0bffe17 	ldw	r2,-8(fp)
 8239784:	10800d17 	ldw	r2,52(r2)
 8239788:	10800817 	ldw	r2,32(r2)
 823978c:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 8239790:	e0bffe17 	ldw	r2,-8(fp)
 8239794:	10800217 	ldw	r2,8(r2)
 8239798:	108000d0 	cmplti	r2,r2,3
 823979c:	10000c1e 	bne	r2,zero,82397d0 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 82397a0:	e0bffe17 	ldw	r2,-8(fp)
 82397a4:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 82397a8:	e13ffe17 	ldw	r4,-8(fp)
 82397ac:	8237f340 	call	8237f34 <tcp_output>
      tcpstat.tcps_drops++;
 82397b0:	008209b4 	movhi	r2,2086
 82397b4:	10b82204 	addi	r2,r2,-8056
 82397b8:	10800317 	ldw	r2,12(r2)
 82397bc:	10c00044 	addi	r3,r2,1
 82397c0:	008209b4 	movhi	r2,2086
 82397c4:	10b82204 	addi	r2,r2,-8056
 82397c8:	10c00315 	stw	r3,12(r2)
 82397cc:	00000706 	br	82397ec <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 82397d0:	008209b4 	movhi	r2,2086
 82397d4:	10b82204 	addi	r2,r2,-8056
 82397d8:	10800417 	ldw	r2,16(r2)
 82397dc:	10c00044 	addi	r3,r2,1
 82397e0:	008209b4 	movhi	r2,2086
 82397e4:	10b82204 	addi	r2,r2,-8056
 82397e8:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 82397ec:	e0bffd17 	ldw	r2,-12(fp)
 82397f0:	e0ffff17 	ldw	r3,-4(fp)
 82397f4:	10c00615 	stw	r3,24(r2)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 82397f8:	e13ffe17 	ldw	r4,-8(fp)
 82397fc:	82398140 	call	8239814 <tcp_close>
}
 8239800:	e037883a 	mov	sp,fp
 8239804:	dfc00117 	ldw	ra,4(sp)
 8239808:	df000017 	ldw	fp,0(sp)
 823980c:	dec00204 	addi	sp,sp,8
 8239810:	f800283a 	ret

08239814 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 8239814:	defff904 	addi	sp,sp,-28
 8239818:	dfc00615 	stw	ra,24(sp)
 823981c:	df000515 	stw	fp,20(sp)
 8239820:	df000504 	addi	fp,sp,20
 8239824:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 8239828:	e0bfff17 	ldw	r2,-4(fp)
 823982c:	10800d17 	ldw	r2,52(r2)
 8239830:	e0bffc15 	stw	r2,-16(fp)
   struct socket *   so =  inp->inp_socket;
 8239834:	e0bffc17 	ldw	r2,-16(fp)
 8239838:	10800817 	ldw	r2,32(r2)
 823983c:	e0bffd15 	stw	r2,-12(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 8239840:	e0bfff17 	ldw	r2,-4(fp)
 8239844:	10800017 	ldw	r2,0(r2)
 8239848:	e0bffb15 	stw	r2,-20(fp)
   while (t != (struct tcpiphdr *)tp) 
 823984c:	00000e06 	br	8239888 <tcp_close+0x74>
   {
      t = (struct tcpiphdr *)t->ti_next;
 8239850:	e0bffb17 	ldw	r2,-20(fp)
 8239854:	10800017 	ldw	r2,0(r2)
 8239858:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(t->ti_prev);
 823985c:	e0bffb17 	ldw	r2,-20(fp)
 8239860:	10800117 	ldw	r2,4(r2)
 8239864:	1009883a 	mov	r4,r2
 8239868:	822e7b80 	call	822e7b8 <dtom>
 823986c:	e0bffe15 	stw	r2,-8(fp)
      remque(t->ti_prev);
 8239870:	e0bffb17 	ldw	r2,-20(fp)
 8239874:	10800117 	ldw	r2,4(r2)
 8239878:	1009883a 	mov	r4,r2
 823987c:	822e8540 	call	822e854 <remque>
      m_freem (m);
 8239880:	e13ffe17 	ldw	r4,-8(fp)
 8239884:	822e26c0 	call	822e26c <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 8239888:	e0fffb17 	ldw	r3,-20(fp)
 823988c:	e0bfff17 	ldw	r2,-4(fp)
 8239890:	18bfef1e 	bne	r3,r2,8239850 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 8239894:	e0bfff17 	ldw	r2,-4(fp)
 8239898:	10800c17 	ldw	r2,48(r2)
 823989c:	10000426 	beq	r2,zero,82398b0 <tcp_close+0x9c>
      TPH_FREE (tp->t_template);
 82398a0:	e0bfff17 	ldw	r2,-4(fp)
 82398a4:	10800c17 	ldw	r2,48(r2)
 82398a8:	1009883a 	mov	r4,r2
 82398ac:	822ddd40 	call	822ddd4 <npfree>
   TCB_FREE (tp);
 82398b0:	e13fff17 	ldw	r4,-4(fp)
 82398b4:	822ddd40 	call	822ddd4 <npfree>
   inp->inp_ppcb = 0;
 82398b8:	e0bffc17 	ldw	r2,-16(fp)
 82398bc:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 82398c0:	e13ffd17 	ldw	r4,-12(fp)
 82398c4:	82338a80 	call	82338a8 <soisdisconnected>
   in_pcbdetach(inp);
 82398c8:	e13ffc17 	ldw	r4,-16(fp)
 82398cc:	8247b140 	call	8247b14 <in_pcbdetach>
   tcpstat.tcps_closed++;
 82398d0:	008209b4 	movhi	r2,2086
 82398d4:	10b82204 	addi	r2,r2,-8056
 82398d8:	10800517 	ldw	r2,20(r2)
 82398dc:	10c00044 	addi	r3,r2,1
 82398e0:	008209b4 	movhi	r2,2086
 82398e4:	10b82204 	addi	r2,r2,-8056
 82398e8:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 82398ec:	0005883a 	mov	r2,zero
}
 82398f0:	e037883a 	mov	sp,fp
 82398f4:	dfc00117 	ldw	ra,4(sp)
 82398f8:	df000017 	ldw	fp,0(sp)
 82398fc:	dec00204 	addi	sp,sp,8
 8239900:	f800283a 	ret

08239904 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 8239904:	defffd04 	addi	sp,sp,-12
 8239908:	df000215 	stw	fp,8(sp)
 823990c:	df000204 	addi	fp,sp,8
 8239910:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 8239914:	e0bfff17 	ldw	r2,-4(fp)
 8239918:	10800917 	ldw	r2,36(r2)
 823991c:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 8239920:	e0bffe17 	ldw	r2,-8(fp)
 8239924:	10000526 	beq	r2,zero,823993c <tcp_quench+0x38>
      tp->snd_cwnd = tp->t_maxseg;
 8239928:	e0bffe17 	ldw	r2,-8(fp)
 823992c:	10800a0b 	ldhu	r2,40(r2)
 8239930:	10ffffcc 	andi	r3,r2,65535
 8239934:	e0bffe17 	ldw	r2,-8(fp)
 8239938:	10c01b15 	stw	r3,108(r2)
}
 823993c:	0001883a 	nop
 8239940:	e037883a 	mov	sp,fp
 8239944:	df000017 	ldw	fp,0(sp)
 8239948:	dec00104 	addi	sp,sp,4
 823994c:	f800283a 	ret

08239950 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 8239950:	defffc04 	addi	sp,sp,-16
 8239954:	df000315 	stw	fp,12(sp)
 8239958:	df000304 	addi	fp,sp,12
 823995c:	e13ffe15 	stw	r4,-8(fp)
 8239960:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 8239964:	e0bffe17 	ldw	r2,-8(fp)
 8239968:	108000c4 	addi	r2,r2,3
 823996c:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239970:	e03ffd15 	stw	zero,-12(fp)
 8239974:	00000b06 	br	82399a4 <tcp_putseq+0x54>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 8239978:	e0bffe17 	ldw	r2,-8(fp)
 823997c:	10ffffc4 	addi	r3,r2,-1
 8239980:	e0fffe15 	stw	r3,-8(fp)
 8239984:	e0ffff17 	ldw	r3,-4(fp)
 8239988:	10c00005 	stb	r3,0(r2)
      seq >>= 8;
 823998c:	e0bfff17 	ldw	r2,-4(fp)
 8239990:	1004d23a 	srli	r2,r2,8
 8239994:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239998:	e0bffd17 	ldw	r2,-12(fp)
 823999c:	10800044 	addi	r2,r2,1
 82399a0:	e0bffd15 	stw	r2,-12(fp)
 82399a4:	e0bffd17 	ldw	r2,-12(fp)
 82399a8:	10800110 	cmplti	r2,r2,4
 82399ac:	103ff21e 	bne	r2,zero,8239978 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 82399b0:	e0bffe17 	ldw	r2,-8(fp)
 82399b4:	10800144 	addi	r2,r2,5
}
 82399b8:	e037883a 	mov	sp,fp
 82399bc:	df000017 	ldw	fp,0(sp)
 82399c0:	dec00104 	addi	sp,sp,4
 82399c4:	f800283a 	ret

082399c8 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 82399c8:	defffc04 	addi	sp,sp,-16
 82399cc:	df000315 	stw	fp,12(sp)
 82399d0:	df000304 	addi	fp,sp,12
 82399d4:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 82399d8:	e03ffe15 	stw	zero,-8(fp)

   for(i = 0; i < 4; i++)
 82399dc:	e03ffd15 	stw	zero,-12(fp)
 82399e0:	00000e06 	br	8239a1c <tcp_getseq+0x54>
   {
      seq <<= 8;
 82399e4:	e0bffe17 	ldw	r2,-8(fp)
 82399e8:	1004923a 	slli	r2,r2,8
 82399ec:	e0bffe15 	stw	r2,-8(fp)
      seq += (u_long)*(cp++);
 82399f0:	e0bfff17 	ldw	r2,-4(fp)
 82399f4:	10c00044 	addi	r3,r2,1
 82399f8:	e0ffff15 	stw	r3,-4(fp)
 82399fc:	10800003 	ldbu	r2,0(r2)
 8239a00:	10803fcc 	andi	r2,r2,255
 8239a04:	e0fffe17 	ldw	r3,-8(fp)
 8239a08:	1885883a 	add	r2,r3,r2
 8239a0c:	e0bffe15 	stw	r2,-8(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 8239a10:	e0bffd17 	ldw	r2,-12(fp)
 8239a14:	10800044 	addi	r2,r2,1
 8239a18:	e0bffd15 	stw	r2,-12(fp)
 8239a1c:	e0bffd17 	ldw	r2,-12(fp)
 8239a20:	10800110 	cmplti	r2,r2,4
 8239a24:	103fef1e 	bne	r2,zero,82399e4 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 8239a28:	e0bffe17 	ldw	r2,-8(fp)
}
 8239a2c:	e037883a 	mov	sp,fp
 8239a30:	df000017 	ldw	fp,0(sp)
 8239a34:	dec00104 	addi	sp,sp,4
 8239a38:	f800283a 	ret

08239a3c <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 8239a3c:	defff704 	addi	sp,sp,-36
 8239a40:	dfc00815 	stw	ra,32(sp)
 8239a44:	df000715 	stw	fp,28(sp)
 8239a48:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 8239a4c:	d0a03f17 	ldw	r2,-32516(gp)
 8239a50:	100490fa 	slli	r2,r2,3
 8239a54:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239a58:	008209b4 	movhi	r2,2086
 8239a5c:	10b7ef04 	addi	r2,r2,-8260
 8239a60:	10800017 	ldw	r2,0(r2)
 8239a64:	e0bffa15 	stw	r2,-24(fp)
 8239a68:	00008006 	br	8239c6c <tcp_slowtimo+0x230>
   {
      sonext = so->next;
 8239a6c:	e0bffa17 	ldw	r2,-24(fp)
 8239a70:	10800017 	ldw	r2,0(r2)
 8239a74:	e0bffb15 	stw	r2,-20(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 8239a78:	e0bffa17 	ldw	r2,-24(fp)
 8239a7c:	10800983 	ldbu	r2,38(r2)
 8239a80:	10803fcc 	andi	r2,r2,255
 8239a84:	1080201c 	xori	r2,r2,128
 8239a88:	10bfe004 	addi	r2,r2,-128
 8239a8c:	10800058 	cmpnei	r2,r2,1
 8239a90:	1000461e 	bne	r2,zero,8239bac <tcp_slowtimo+0x170>
      {
         ip = so->so_pcb;
 8239a94:	e0bffa17 	ldw	r2,-24(fp)
 8239a98:	10800117 	ldw	r2,4(r2)
 8239a9c:	e0bffc15 	stw	r2,-16(fp)
         if (!ip)
 8239aa0:	e0bffc17 	ldw	r2,-16(fp)
 8239aa4:	10006a26 	beq	r2,zero,8239c50 <tcp_slowtimo+0x214>
            continue;
         ipnxt = ip->inp_next;
 8239aa8:	e0bffc17 	ldw	r2,-16(fp)
 8239aac:	10800017 	ldw	r2,0(r2)
 8239ab0:	e0bffd15 	stw	r2,-12(fp)

         tp = intotcpcb(so->so_pcb);
 8239ab4:	e0bffa17 	ldw	r2,-24(fp)
 8239ab8:	10800117 	ldw	r2,4(r2)
 8239abc:	10800917 	ldw	r2,36(r2)
 8239ac0:	e0bffe15 	stw	r2,-8(fp)
         if (!tp)
 8239ac4:	e0bffe17 	ldw	r2,-8(fp)
 8239ac8:	10006326 	beq	r2,zero,8239c58 <tcp_slowtimo+0x21c>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239acc:	e03ff915 	stw	zero,-28(fp)
 8239ad0:	00002e06 	br	8239b8c <tcp_slowtimo+0x150>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 8239ad4:	e0fffe17 	ldw	r3,-8(fp)
 8239ad8:	e0bff917 	ldw	r2,-28(fp)
 8239adc:	108000c4 	addi	r2,r2,3
 8239ae0:	1085883a 	add	r2,r2,r2
 8239ae4:	1085883a 	add	r2,r2,r2
 8239ae8:	1885883a 	add	r2,r3,r2
 8239aec:	10800017 	ldw	r2,0(r2)
 8239af0:	10002326 	beq	r2,zero,8239b80 <tcp_slowtimo+0x144>
 8239af4:	e0fffe17 	ldw	r3,-8(fp)
 8239af8:	e0bff917 	ldw	r2,-28(fp)
 8239afc:	108000c4 	addi	r2,r2,3
 8239b00:	1085883a 	add	r2,r2,r2
 8239b04:	1085883a 	add	r2,r2,r2
 8239b08:	1885883a 	add	r2,r3,r2
 8239b0c:	10800017 	ldw	r2,0(r2)
 8239b10:	10ffffc4 	addi	r3,r2,-1
 8239b14:	e13ffe17 	ldw	r4,-8(fp)
 8239b18:	e0bff917 	ldw	r2,-28(fp)
 8239b1c:	108000c4 	addi	r2,r2,3
 8239b20:	1085883a 	add	r2,r2,r2
 8239b24:	1085883a 	add	r2,r2,r2
 8239b28:	2085883a 	add	r2,r4,r2
 8239b2c:	10c00015 	stw	r3,0(r2)
 8239b30:	e0fffe17 	ldw	r3,-8(fp)
 8239b34:	e0bff917 	ldw	r2,-28(fp)
 8239b38:	108000c4 	addi	r2,r2,3
 8239b3c:	1085883a 	add	r2,r2,r2
 8239b40:	1085883a 	add	r2,r2,r2
 8239b44:	1885883a 	add	r2,r3,r2
 8239b48:	10800017 	ldw	r2,0(r2)
 8239b4c:	10000c1e 	bne	r2,zero,8239b80 <tcp_slowtimo+0x144>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 8239b50:	e0bffa17 	ldw	r2,-24(fp)
 8239b54:	00c004c4 	movi	r3,19
 8239b58:	10c00715 	stw	r3,28(r2)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 8239b5c:	e0bff917 	ldw	r2,-28(fp)
 8239b60:	100d883a 	mov	r6,r2
 8239b64:	000b883a 	mov	r5,zero
 8239b68:	e13ffa17 	ldw	r4,-24(fp)
 8239b6c:	823a18c0 	call	823a18c <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 8239b70:	e0bffd17 	ldw	r2,-12(fp)
 8239b74:	10c00117 	ldw	r3,4(r2)
 8239b78:	e0bffc17 	ldw	r2,-16(fp)
 8239b7c:	1880381e 	bne	r3,r2,8239c60 <tcp_slowtimo+0x224>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239b80:	e0bff917 	ldw	r2,-28(fp)
 8239b84:	10800044 	addi	r2,r2,1
 8239b88:	e0bff915 	stw	r2,-28(fp)
 8239b8c:	e0bff917 	ldw	r2,-28(fp)
 8239b90:	10800110 	cmplti	r2,r2,4
 8239b94:	103fcf1e 	bne	r2,zero,8239ad4 <tcp_slowtimo+0x98>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 8239b98:	e0bffe17 	ldw	r2,-8(fp)
 8239b9c:	10801d17 	ldw	r2,116(r2)
 8239ba0:	10c00044 	addi	r3,r2,1
 8239ba4:	e0bffe17 	ldw	r2,-8(fp)
 8239ba8:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 8239bac:	e0bffa17 	ldw	r2,-24(fp)
 8239bb0:	10800a04 	addi	r2,r2,40
 8239bb4:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239bb8:	e0bfff17 	ldw	r2,-4(fp)
 8239bbc:	1080070b 	ldhu	r2,28(r2)
 8239bc0:	10bfffcc 	andi	r2,r2,65535
 8239bc4:	1080020c 	andi	r2,r2,8
 8239bc8:	10000a26 	beq	r2,zero,8239bf4 <tcp_slowtimo+0x1b8>
      {
         select_wait = 0;
 8239bcc:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239bd0:	d120b004 	addi	r4,gp,-32064
 8239bd4:	82292dc0 	call	82292dc <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239bd8:	e0bfff17 	ldw	r2,-4(fp)
 8239bdc:	10c0070b 	ldhu	r3,28(r2)
 8239be0:	00bffdc4 	movi	r2,-9
 8239be4:	1884703a 	and	r2,r3,r2
 8239be8:	1007883a 	mov	r3,r2
 8239bec:	e0bfff17 	ldw	r2,-4(fp)
 8239bf0:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 8239bf4:	e0bffa17 	ldw	r2,-24(fp)
 8239bf8:	10801204 	addi	r2,r2,72
 8239bfc:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239c00:	e0bfff17 	ldw	r2,-4(fp)
 8239c04:	1080070b 	ldhu	r2,28(r2)
 8239c08:	10bfffcc 	andi	r2,r2,65535
 8239c0c:	1080020c 	andi	r2,r2,8
 8239c10:	10000a26 	beq	r2,zero,8239c3c <tcp_slowtimo+0x200>
      {
         select_wait = 0;         
 8239c14:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239c18:	d120b004 	addi	r4,gp,-32064
 8239c1c:	82292dc0 	call	82292dc <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239c20:	e0bfff17 	ldw	r2,-4(fp)
 8239c24:	10c0070b 	ldhu	r3,28(r2)
 8239c28:	00bffdc4 	movi	r2,-9
 8239c2c:	1884703a 	and	r2,r3,r2
 8239c30:	1007883a 	mov	r3,r2
 8239c34:	e0bfff17 	ldw	r2,-4(fp)
 8239c38:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 8239c3c:	e0bffa17 	ldw	r2,-24(fp)
 8239c40:	10800904 	addi	r2,r2,36
 8239c44:	1009883a 	mov	r4,r2
 8239c48:	82292dc0 	call	82292dc <tcp_wakeup>
 8239c4c:	00000506 	br	8239c64 <tcp_slowtimo+0x228>
       */
      if (so->so_type == SOCK_STREAM)
      {
         ip = so->so_pcb;
         if (!ip)
            continue;
 8239c50:	0001883a 	nop
 8239c54:	00000306 	br	8239c64 <tcp_slowtimo+0x228>
         ipnxt = ip->inp_next;

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;
 8239c58:	0001883a 	nop
 8239c5c:	00000106 	br	8239c64 <tcp_slowtimo+0x228>
               (void) tcp_usrreq(so, (struct mbuf *)0, 
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
                  goto tpgone;
 8239c60:	0001883a 	nop
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239c64:	e0bffb17 	ldw	r2,-20(fp)
 8239c68:	e0bffa15 	stw	r2,-24(fp)
 8239c6c:	e0bffa17 	ldw	r2,-24(fp)
 8239c70:	103f7e1e 	bne	r2,zero,8239a6c <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 8239c74:	d0e0b517 	ldw	r3,-32044(gp)
 8239c78:	00be9fd4 	movui	r2,64127
 8239c7c:	1885883a 	add	r2,r3,r2
 8239c80:	d0a0b515 	stw	r2,-32044(gp)

   if (tcp_iss & 0xff000000)
 8239c84:	d0a0b517 	ldw	r2,-32044(gp)
 8239c88:	10bfc02c 	andhi	r2,r2,65280
 8239c8c:	10000126 	beq	r2,zero,8239c94 <tcp_slowtimo+0x258>
      tcp_iss = 0L;
 8239c90:	d020b515 	stw	zero,-32044(gp)
}
 8239c94:	0001883a 	nop
 8239c98:	e037883a 	mov	sp,fp
 8239c9c:	dfc00117 	ldw	ra,4(sp)
 8239ca0:	df000017 	ldw	fp,0(sp)
 8239ca4:	dec00204 	addi	sp,sp,8
 8239ca8:	f800283a 	ret

08239cac <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 8239cac:	defffd04 	addi	sp,sp,-12
 8239cb0:	df000215 	stw	fp,8(sp)
 8239cb4:	df000204 	addi	fp,sp,8
 8239cb8:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 8239cbc:	e03ffe15 	stw	zero,-8(fp)
 8239cc0:	00000a06 	br	8239cec <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 8239cc4:	e0ffff17 	ldw	r3,-4(fp)
 8239cc8:	e0bffe17 	ldw	r2,-8(fp)
 8239ccc:	108000c4 	addi	r2,r2,3
 8239cd0:	1085883a 	add	r2,r2,r2
 8239cd4:	1085883a 	add	r2,r2,r2
 8239cd8:	1885883a 	add	r2,r3,r2
 8239cdc:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 8239ce0:	e0bffe17 	ldw	r2,-8(fp)
 8239ce4:	10800044 	addi	r2,r2,1
 8239ce8:	e0bffe15 	stw	r2,-8(fp)
 8239cec:	e0bffe17 	ldw	r2,-8(fp)
 8239cf0:	10800110 	cmplti	r2,r2,4
 8239cf4:	103ff31e 	bne	r2,zero,8239cc4 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 8239cf8:	0001883a 	nop
 8239cfc:	e037883a 	mov	sp,fp
 8239d00:	df000017 	ldw	fp,0(sp)
 8239d04:	dec00104 	addi	sp,sp,4
 8239d08:	f800283a 	ret

08239d0c <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 8239d0c:	defff804 	addi	sp,sp,-32
 8239d10:	dfc00715 	stw	ra,28(sp)
 8239d14:	df000615 	stw	fp,24(sp)
 8239d18:	df000604 	addi	fp,sp,24
 8239d1c:	e13ffe15 	stw	r4,-8(fp)
 8239d20:	e17fff15 	stw	r5,-4(fp)
   int   rexmt;

   switch (timer) 
 8239d24:	e0bfff17 	ldw	r2,-4(fp)
 8239d28:	10c00060 	cmpeqi	r3,r2,1
 8239d2c:	1800b21e 	bne	r3,zero,8239ff8 <tcp_timers+0x2ec>
 8239d30:	10c00088 	cmpgei	r3,r2,2
 8239d34:	1800021e 	bne	r3,zero,8239d40 <tcp_timers+0x34>
 8239d38:	10001826 	beq	r2,zero,8239d9c <tcp_timers+0x90>
 8239d3c:	00010d06 	br	823a174 <tcp_timers+0x468>
 8239d40:	10c000a0 	cmpeqi	r3,r2,2
 8239d44:	1800bd1e 	bne	r3,zero,823a03c <tcp_timers+0x330>
 8239d48:	108000e0 	cmpeqi	r2,r2,3
 8239d4c:	10010926 	beq	r2,zero,823a174 <tcp_timers+0x468>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 8239d50:	e0bffe17 	ldw	r2,-8(fp)
 8239d54:	10800217 	ldw	r2,8(r2)
 8239d58:	108002a0 	cmpeqi	r2,r2,10
 8239d5c:	10000b1e 	bne	r2,zero,8239d8c <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
 8239d60:	e0bffe17 	ldw	r2,-8(fp)
 8239d64:	10801d17 	ldw	r2,116(r2)
 8239d68:	d0e0b417 	ldw	r3,-32048(gp)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 8239d6c:	18800716 	blt	r3,r2,8239d8c <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 8239d70:	d0a03f17 	ldw	r2,-32516(gp)
 8239d74:	10ffffcc 	andi	r3,r2,65535
 8239d78:	18e0001c 	xori	r3,r3,32768
 8239d7c:	18e00004 	addi	r3,r3,-32768
 8239d80:	e0bffe17 	ldw	r2,-8(fp)
 8239d84:	10c00615 	stw	r3,24(r2)
      }
      else
         tp = tcp_close(tp);
      break;
 8239d88:	0000fa06 	br	823a174 <tcp_timers+0x468>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 8239d8c:	e13ffe17 	ldw	r4,-8(fp)
 8239d90:	82398140 	call	8239814 <tcp_close>
 8239d94:	e0bffe15 	stw	r2,-8(fp)
      break;
 8239d98:	0000f606 	br	823a174 <tcp_timers+0x468>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 8239d9c:	008209b4 	movhi	r2,2086
 8239da0:	10b7f404 	addi	r2,r2,-8240
 8239da4:	10800b17 	ldw	r2,44(r2)
 8239da8:	10c00044 	addi	r3,r2,1
 8239dac:	008209b4 	movhi	r2,2086
 8239db0:	10b7f404 	addi	r2,r2,-8240
 8239db4:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 8239db8:	e0bffe17 	ldw	r2,-8(fp)
 8239dbc:	10800717 	ldw	r2,28(r2)
 8239dc0:	10c00044 	addi	r3,r2,1
 8239dc4:	e0bffe17 	ldw	r2,-8(fp)
 8239dc8:	10c00715 	stw	r3,28(r2)
 8239dcc:	e0bffe17 	ldw	r2,-8(fp)
 8239dd0:	10800717 	ldw	r2,28(r2)
 8239dd4:	10800350 	cmplti	r2,r2,13
 8239dd8:	10000f1e 	bne	r2,zero,8239e18 <tcp_timers+0x10c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 8239ddc:	e0bffe17 	ldw	r2,-8(fp)
 8239de0:	00c00304 	movi	r3,12
 8239de4:	10c00715 	stw	r3,28(r2)
         tcpstat.tcps_timeoutdrop++;
 8239de8:	008209b4 	movhi	r2,2086
 8239dec:	10b82204 	addi	r2,r2,-8056
 8239df0:	10800917 	ldw	r2,36(r2)
 8239df4:	10c00044 	addi	r3,r2,1
 8239df8:	008209b4 	movhi	r2,2086
 8239dfc:	10b82204 	addi	r2,r2,-8056
 8239e00:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 8239e04:	01401d04 	movi	r5,116
 8239e08:	e13ffe17 	ldw	r4,-8(fp)
 8239e0c:	82397680 	call	8239768 <tcp_drop>
 8239e10:	e0bffe15 	stw	r2,-8(fp)
         break;
 8239e14:	0000d706 	br	823a174 <tcp_timers+0x468>
      }
      tcpstat.tcps_rexmttimeo++;
 8239e18:	008209b4 	movhi	r2,2086
 8239e1c:	10b82204 	addi	r2,r2,-8056
 8239e20:	10800a17 	ldw	r2,40(r2)
 8239e24:	10c00044 	addi	r3,r2,1
 8239e28:	008209b4 	movhi	r2,2086
 8239e2c:	10b82204 	addi	r2,r2,-8056
 8239e30:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8239e34:	e0bffe17 	ldw	r2,-8(fp)
 8239e38:	10802017 	ldw	r2,128(r2)
 8239e3c:	1007d0ba 	srai	r3,r2,2
 8239e40:	e0bffe17 	ldw	r2,-8(fp)
 8239e44:	10802117 	ldw	r2,132(r2)
 8239e48:	1885883a 	add	r2,r3,r2
 8239e4c:	1005d07a 	srai	r2,r2,1
 8239e50:	e0bffd15 	stw	r2,-12(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 8239e54:	e0bffe17 	ldw	r2,-8(fp)
 8239e58:	10c00717 	ldw	r3,28(r2)
 8239e5c:	00820974 	movhi	r2,2085
 8239e60:	108d5cc4 	addi	r2,r2,13683
 8239e64:	10c5883a 	add	r2,r2,r3
 8239e68:	10800003 	ldbu	r2,0(r2)
 8239e6c:	10803fcc 	andi	r2,r2,255
 8239e70:	e0fffd17 	ldw	r3,-12(fp)
 8239e74:	1885383a 	mul	r2,r3,r2
 8239e78:	e0bffd15 	stw	r2,-12(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 8239e7c:	e0bffd17 	ldw	r2,-12(fp)
 8239e80:	10ffffcc 	andi	r3,r2,65535
 8239e84:	18e0001c 	xori	r3,r3,32768
 8239e88:	18e00004 	addi	r3,r3,-32768
 8239e8c:	e0bffe17 	ldw	r2,-8(fp)
 8239e90:	10c00815 	stw	r3,32(r2)
 8239e94:	e0bffe17 	ldw	r2,-8(fp)
 8239e98:	10800817 	ldw	r2,32(r2)
 8239e9c:	10800088 	cmpgei	r2,r2,2
 8239ea0:	1000041e 	bne	r2,zero,8239eb4 <tcp_timers+0x1a8>
 8239ea4:	e0bffe17 	ldw	r2,-8(fp)
 8239ea8:	00c00084 	movi	r3,2
 8239eac:	10c00815 	stw	r3,32(r2)
 8239eb0:	00000706 	br	8239ed0 <tcp_timers+0x1c4>
 8239eb4:	e0bffe17 	ldw	r2,-8(fp)
 8239eb8:	10800817 	ldw	r2,32(r2)
 8239ebc:	10802050 	cmplti	r2,r2,129
 8239ec0:	1000031e 	bne	r2,zero,8239ed0 <tcp_timers+0x1c4>
 8239ec4:	e0bffe17 	ldw	r2,-8(fp)
 8239ec8:	00c02004 	movi	r3,128
 8239ecc:	10c00815 	stw	r3,32(r2)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8239ed0:	e0bffe17 	ldw	r2,-8(fp)
 8239ed4:	10c00817 	ldw	r3,32(r2)
 8239ed8:	e0bffe17 	ldw	r2,-8(fp)
 8239edc:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 8239ee0:	e0bffe17 	ldw	r2,-8(fp)
 8239ee4:	10800717 	ldw	r2,28(r2)
 8239ee8:	10800110 	cmplti	r2,r2,4
 8239eec:	10000f1e 	bne	r2,zero,8239f2c <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
 8239ef0:	e0bffe17 	ldw	r2,-8(fp)
 8239ef4:	10800b0b 	ldhu	r2,44(r2)
 8239ef8:	10bfffcc 	andi	r2,r2,65535
 8239efc:	1080400c 	andi	r2,r2,256
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 8239f00:	10000a1e 	bne	r2,zero,8239f2c <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 8239f04:	e0bffe17 	ldw	r2,-8(fp)
 8239f08:	10c02117 	ldw	r3,132(r2)
 8239f0c:	e0bffe17 	ldw	r2,-8(fp)
 8239f10:	10802017 	ldw	r2,128(r2)
 8239f14:	1005d0ba 	srai	r2,r2,2
 8239f18:	1887883a 	add	r3,r3,r2
 8239f1c:	e0bffe17 	ldw	r2,-8(fp)
 8239f20:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 8239f24:	e0bffe17 	ldw	r2,-8(fp)
 8239f28:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 8239f2c:	e0bffe17 	ldw	r2,-8(fp)
 8239f30:	10c00e17 	ldw	r3,56(r2)
 8239f34:	e0bffe17 	ldw	r2,-8(fp)
 8239f38:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 8239f3c:	e0bffe17 	ldw	r2,-8(fp)
 8239f40:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 8239f44:	e0bffe17 	ldw	r2,-8(fp)
 8239f48:	10800d17 	ldw	r2,52(r2)
 8239f4c:	10800817 	ldw	r2,32(r2)
 8239f50:	10800417 	ldw	r2,16(r2)
 8239f54:	1090000c 	andi	r2,r2,16384
 8239f58:	1000241e 	bne	r2,zero,8239fec <tcp_timers+0x2e0>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 8239f5c:	e0bffe17 	ldw	r2,-8(fp)
 8239f60:	11001417 	ldw	r4,80(r2)
 8239f64:	e0bffe17 	ldw	r2,-8(fp)
 8239f68:	10c01b17 	ldw	r3,108(r2)
 8239f6c:	2005883a 	mov	r2,r4
 8239f70:	1880012e 	bgeu	r3,r2,8239f78 <tcp_timers+0x26c>
 8239f74:	1805883a 	mov	r2,r3
 8239f78:	e0bffc15 	stw	r2,-16(fp)
         win = win / 2 / tp->t_maxseg;
 8239f7c:	e0bffc17 	ldw	r2,-16(fp)
 8239f80:	1006d07a 	srli	r3,r2,1
 8239f84:	e0bffe17 	ldw	r2,-8(fp)
 8239f88:	10800a0b 	ldhu	r2,40(r2)
 8239f8c:	10bfffcc 	andi	r2,r2,65535
 8239f90:	100b883a 	mov	r5,r2
 8239f94:	1809883a 	mov	r4,r3
 8239f98:	820270c0 	call	820270c <__udivsi3>
 8239f9c:	e0bffc15 	stw	r2,-16(fp)
         if (win < 2)
 8239fa0:	e0bffc17 	ldw	r2,-16(fp)
 8239fa4:	108000a8 	cmpgeui	r2,r2,2
 8239fa8:	1000021e 	bne	r2,zero,8239fb4 <tcp_timers+0x2a8>
            win = 2;
 8239fac:	00800084 	movi	r2,2
 8239fb0:	e0bffc15 	stw	r2,-16(fp)
         tp->snd_cwnd = tp->t_maxseg;
 8239fb4:	e0bffe17 	ldw	r2,-8(fp)
 8239fb8:	10800a0b 	ldhu	r2,40(r2)
 8239fbc:	10ffffcc 	andi	r3,r2,65535
 8239fc0:	e0bffe17 	ldw	r2,-8(fp)
 8239fc4:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 8239fc8:	e0bffc17 	ldw	r2,-16(fp)
 8239fcc:	10ffffcc 	andi	r3,r2,65535
 8239fd0:	e0bffe17 	ldw	r2,-8(fp)
 8239fd4:	10800a0b 	ldhu	r2,40(r2)
 8239fd8:	10bfffcc 	andi	r2,r2,65535
 8239fdc:	1885383a 	mul	r2,r3,r2
 8239fe0:	1007883a 	mov	r3,r2
 8239fe4:	e0bffe17 	ldw	r2,-8(fp)
 8239fe8:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 8239fec:	e13ffe17 	ldw	r4,-8(fp)
 8239ff0:	8237f340 	call	8237f34 <tcp_output>
      break;
 8239ff4:	00005f06 	br	823a174 <tcp_timers+0x468>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 8239ff8:	008209b4 	movhi	r2,2086
 8239ffc:	10b82204 	addi	r2,r2,-8056
 823a000:	10800b17 	ldw	r2,44(r2)
 823a004:	10c00044 	addi	r3,r2,1
 823a008:	008209b4 	movhi	r2,2086
 823a00c:	10b82204 	addi	r2,r2,-8056
 823a010:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 823a014:	e13ffe17 	ldw	r4,-8(fp)
 823a018:	8238f380 	call	8238f38 <tcp_setpersist>
      tp->t_force = 1;
 823a01c:	e0bffe17 	ldw	r2,-8(fp)
 823a020:	00c00044 	movi	r3,1
 823a024:	10c00a85 	stb	r3,42(r2)
      (void) tcp_output(tp);
 823a028:	e13ffe17 	ldw	r4,-8(fp)
 823a02c:	8237f340 	call	8237f34 <tcp_output>
      tp->t_force = 0;
 823a030:	e0bffe17 	ldw	r2,-8(fp)
 823a034:	10000a85 	stb	zero,42(r2)
      break;
 823a038:	00004e06 	br	823a174 <tcp_timers+0x468>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 823a03c:	008209b4 	movhi	r2,2086
 823a040:	10b82204 	addi	r2,r2,-8056
 823a044:	10800c17 	ldw	r2,48(r2)
 823a048:	10c00044 	addi	r3,r2,1
 823a04c:	008209b4 	movhi	r2,2086
 823a050:	10b82204 	addi	r2,r2,-8056
 823a054:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 823a058:	e0bffe17 	ldw	r2,-8(fp)
 823a05c:	10800217 	ldw	r2,8(r2)
 823a060:	10800108 	cmpgei	r2,r2,4
 823a064:	10003426 	beq	r2,zero,823a138 <tcp_timers+0x42c>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a068:	e0bffe17 	ldw	r2,-8(fp)
 823a06c:	10800d17 	ldw	r2,52(r2)
 823a070:	10800817 	ldw	r2,32(r2)
 823a074:	10800417 	ldw	r2,16(r2)
 823a078:	1080020c 	andi	r2,r2,8
 823a07c:	10002726 	beq	r2,zero,823a11c <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
 823a080:	e0bffe17 	ldw	r2,-8(fp)
 823a084:	10800217 	ldw	r2,8(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a088:	10800188 	cmpgei	r2,r2,6
 823a08c:	1000231e 	bne	r2,zero,823a11c <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 823a090:	e0bffe17 	ldw	r2,-8(fp)
 823a094:	10c01d17 	ldw	r3,116(r2)
 823a098:	d1203e17 	ldw	r4,-32520(gp)
 823a09c:	d0a0b417 	ldw	r2,-32048(gp)
 823a0a0:	2085883a 	add	r2,r4,r2
 823a0a4:	1880260e 	bge	r3,r2,823a140 <tcp_timers+0x434>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 823a0a8:	008209b4 	movhi	r2,2086
 823a0ac:	10b82204 	addi	r2,r2,-8056
 823a0b0:	10800d17 	ldw	r2,52(r2)
 823a0b4:	10c00044 	addi	r3,r2,1
 823a0b8:	008209b4 	movhi	r2,2086
 823a0bc:	10b82204 	addi	r2,r2,-8056
 823a0c0:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a0c4:	e0bffe17 	ldw	r2,-8(fp)
 823a0c8:	10c00c17 	ldw	r3,48(r2)
 823a0cc:	e0bffe17 	ldw	r2,-8(fp)
 823a0d0:	10801617 	ldw	r2,88(r2)
 823a0d4:	113fffc4 	addi	r4,r2,-1
            tp->snd_una - 1, 0, (struct mbuf *)NULL);
 823a0d8:	e0bffe17 	ldw	r2,-8(fp)
 823a0dc:	10800e17 	ldw	r2,56(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a0e0:	10bfffc4 	addi	r2,r2,-1
 823a0e4:	d8000115 	stw	zero,4(sp)
 823a0e8:	d8000015 	stw	zero,0(sp)
 823a0ec:	100f883a 	mov	r7,r2
 823a0f0:	200d883a 	mov	r6,r4
 823a0f4:	180b883a 	mov	r5,r3
 823a0f8:	e13ffe17 	ldw	r4,-8(fp)
 823a0fc:	823925c0 	call	823925c <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 823a100:	d0a03f17 	ldw	r2,-32516(gp)
 823a104:	10ffffcc 	andi	r3,r2,65535
 823a108:	18e0001c 	xori	r3,r3,32768
 823a10c:	18e00004 	addi	r3,r3,-32768
 823a110:	e0bffe17 	ldw	r2,-8(fp)
 823a114:	10c00515 	stw	r3,20(r2)
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
 823a118:	00001606 	br	823a174 <tcp_timers+0x468>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 823a11c:	d0a03e17 	ldw	r2,-32520(gp)
 823a120:	10ffffcc 	andi	r3,r2,65535
 823a124:	18e0001c 	xori	r3,r3,32768
 823a128:	18e00004 	addi	r3,r3,-32768
 823a12c:	e0bffe17 	ldw	r2,-8(fp)
 823a130:	10c00515 	stw	r3,20(r2)
      break;
 823a134:	00000f06 	br	823a174 <tcp_timers+0x468>
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
 823a138:	0001883a 	nop
 823a13c:	00000106 	br	823a144 <tcp_timers+0x438>
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
            goto dropit;
 823a140:	0001883a 	nop
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
      dropit:
      tcpstat.tcps_keepdrops++;
 823a144:	008209b4 	movhi	r2,2086
 823a148:	10b82204 	addi	r2,r2,-8056
 823a14c:	10800e17 	ldw	r2,56(r2)
 823a150:	10c00044 	addi	r3,r2,1
 823a154:	008209b4 	movhi	r2,2086
 823a158:	10b82204 	addi	r2,r2,-8056
 823a15c:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 823a160:	01401d04 	movi	r5,116
 823a164:	e13ffe17 	ldw	r4,-8(fp)
 823a168:	82397680 	call	8239768 <tcp_drop>
 823a16c:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a170:	0001883a 	nop
   }
   return tp;
 823a174:	e0bffe17 	ldw	r2,-8(fp)
}
 823a178:	e037883a 	mov	sp,fp
 823a17c:	dfc00117 	ldw	ra,4(sp)
 823a180:	df000017 	ldw	fp,0(sp)
 823a184:	dec00204 	addi	sp,sp,8
 823a188:	f800283a 	ret

0823a18c <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823a18c:	defff604 	addi	sp,sp,-40
 823a190:	dfc00915 	stw	ra,36(sp)
 823a194:	df000815 	stw	fp,32(sp)
 823a198:	df000804 	addi	fp,sp,32
 823a19c:	e13ffd15 	stw	r4,-12(fp)
 823a1a0:	e17ffe15 	stw	r5,-8(fp)
 823a1a4:	e1bfff15 	stw	r6,-4(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 823a1a8:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 823a1ac:	e0bffd17 	ldw	r2,-12(fp)
 823a1b0:	10800717 	ldw	r2,28(r2)
 823a1b4:	e0bffa15 	stw	r2,-24(fp)
   inp = sotoinpcb(so);
 823a1b8:	e0bffd17 	ldw	r2,-12(fp)
 823a1bc:	10800117 	ldw	r2,4(r2)
 823a1c0:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 823a1c4:	e0bffb17 	ldw	r2,-20(fp)
 823a1c8:	1000041e 	bne	r2,zero,823a1dc <tcp_usrreq+0x50>
 823a1cc:	e0bffa17 	ldw	r2,-24(fp)
 823a1d0:	10000226 	beq	r2,zero,823a1dc <tcp_usrreq+0x50>
   {
      return (EINVAL);
 823a1d4:	00800584 	movi	r2,22
 823a1d8:	00019c06 	br	823a84c <tcp_usrreq+0x6c0>
   }

   if (inp)
 823a1dc:	e0bffb17 	ldw	r2,-20(fp)
 823a1e0:	10000426 	beq	r2,zero,823a1f4 <tcp_usrreq+0x68>
      tp = intotcpcb(inp);
 823a1e4:	e0bffb17 	ldw	r2,-20(fp)
 823a1e8:	10800917 	ldw	r2,36(r2)
 823a1ec:	e0bff815 	stw	r2,-32(fp)
 823a1f0:	00000706 	br	823a210 <tcp_usrreq+0x84>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 823a1f4:	e0bffa17 	ldw	r2,-24(fp)
 823a1f8:	1000021e 	bne	r2,zero,823a204 <tcp_usrreq+0x78>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 823a1fc:	e03ff815 	stw	zero,-32(fp)
 823a200:	00000306 	br	823a210 <tcp_usrreq+0x84>
      else
      {
         dtrap(); /* programming error? */
 823a204:	822d1c80 	call	822d1c8 <dtrap>
         return EINVAL;
 823a208:	00800584 	movi	r2,22
 823a20c:	00018f06 	br	823a84c <tcp_usrreq+0x6c0>
      }
   }

   switch (req) 
 823a210:	e0bffa17 	ldw	r2,-24(fp)
 823a214:	10800528 	cmpgeui	r2,r2,20
 823a218:	1001761e 	bne	r2,zero,823a7f4 <tcp_usrreq+0x668>
 823a21c:	e0bffa17 	ldw	r2,-24(fp)
 823a220:	100690ba 	slli	r3,r2,2
 823a224:	00820934 	movhi	r2,2084
 823a228:	10a88e04 	addi	r2,r2,-24008
 823a22c:	1885883a 	add	r2,r3,r2
 823a230:	10800017 	ldw	r2,0(r2)
 823a234:	1000683a 	jmp	r2
 823a238:	0823a288 	cmpgei	zero,at,-29046
 823a23c:	0823a2e8 	cmpgeui	zero,at,36491
 823a240:	0823a310 	cmplti	zero,at,-29044
 823a244:	0823a348 	cmpgei	zero,at,-29043
 823a248:	0823a380 	call	823a38 <OSCtxSw_SWITCH_PC+0x8239f8>
 823a24c:	0823a4d8 	cmpnei	zero,at,-29037
 823a250:	0823a4cc 	andi	zero,at,36499
 823a254:	0823a588 	cmpgei	zero,at,-29034
 823a258:	0823a5b4 	orhi	zero,at,36502
 823a25c:	0823a5c0 	call	823a5c <OSCtxSw_SWITCH_PC+0x823a1c>
 823a260:	0823a61c 	xori	zero,at,36504
 823a264:	0823a7f4 	orhi	zero,at,36511
 823a268:	0823a62c 	andhi	zero,at,36504
 823a26c:	0823a638 	rdprs	zero,at,-29032
 823a270:	0823a6f0 	cmpltui	zero,at,36507
 823a274:	0823a7c0 	call	823a7c <OSCtxSw_SWITCH_PC+0x823a3c>
 823a278:	0823a7d0 	cmplti	zero,at,-29025
 823a27c:	0823a4c0 	call	823a4c <OSCtxSw_SWITCH_PC+0x823a0c>
 823a280:	0823a7f4 	orhi	zero,at,36511
 823a284:	0823a7e0 	cmpeqi	zero,at,-29025
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 823a288:	e0bffb17 	ldw	r2,-20(fp)
 823a28c:	10000326 	beq	r2,zero,823a29c <tcp_usrreq+0x110>
      {
         error = EISCONN;
 823a290:	00801fc4 	movi	r2,127
 823a294:	e0bff915 	stw	r2,-28(fp)
         break;
 823a298:	00016b06 	br	823a848 <tcp_usrreq+0x6bc>
      }
      error = tcp_attach(so);
 823a29c:	e13ffd17 	ldw	r4,-12(fp)
 823a2a0:	823a8600 	call	823a860 <tcp_attach>
 823a2a4:	e0bff915 	stw	r2,-28(fp)
      if (error)
 823a2a8:	e0bff917 	ldw	r2,-28(fp)
 823a2ac:	1001551e 	bne	r2,zero,823a804 <tcp_usrreq+0x678>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823a2b0:	e0bffd17 	ldw	r2,-12(fp)
 823a2b4:	10800417 	ldw	r2,16(r2)
 823a2b8:	1080200c 	andi	r2,r2,128
 823a2bc:	10015326 	beq	r2,zero,823a80c <tcp_usrreq+0x680>
 823a2c0:	e0bffd17 	ldw	r2,-12(fp)
 823a2c4:	1080080b 	ldhu	r2,32(r2)
 823a2c8:	10bfffcc 	andi	r2,r2,65535
 823a2cc:	10a0001c 	xori	r2,r2,32768
 823a2d0:	10a00004 	addi	r2,r2,-32768
 823a2d4:	10014d1e 	bne	r2,zero,823a80c <tcp_usrreq+0x680>
         so->so_linger = TCP_LINGERTIME;
 823a2d8:	e0bffd17 	ldw	r2,-12(fp)
 823a2dc:	00c01e04 	movi	r3,120
 823a2e0:	10c0080d 	sth	r3,32(r2)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a2e4:	00014906 	br	823a80c <tcp_usrreq+0x680>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 823a2e8:	e0bff817 	ldw	r2,-32(fp)
 823a2ec:	10800217 	ldw	r2,8(r2)
 823a2f0:	10800090 	cmplti	r2,r2,2
 823a2f4:	1000031e 	bne	r2,zero,823a304 <tcp_usrreq+0x178>
         SETTP(tp, tcp_disconnect(tp));
 823a2f8:	e13ff817 	ldw	r4,-32(fp)
 823a2fc:	823a9780 	call	823a978 <tcp_disconnect>
      else
         SETTP(tp, tcp_close(tp));
      break;
 823a300:	00015106 	br	823a848 <tcp_usrreq+0x6bc>
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
         SETTP(tp, tcp_disconnect(tp));
      else
         SETTP(tp, tcp_close(tp));
 823a304:	e13ff817 	ldw	r4,-32(fp)
 823a308:	82398140 	call	8239814 <tcp_close>
      break;
 823a30c:	00014e06 	br	823a848 <tcp_usrreq+0x6bc>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 823a310:	e0bffb17 	ldw	r2,-20(fp)
 823a314:	10800817 	ldw	r2,32(r2)
 823a318:	10800517 	ldw	r2,20(r2)
 823a31c:	10800098 	cmpnei	r2,r2,2
 823a320:	1000051e 	bne	r2,zero,823a338 <tcp_usrreq+0x1ac>
      {
         error = in_pcbbind(inp, nam);
 823a324:	e17fff17 	ldw	r5,-4(fp)
 823a328:	e13ffb17 	ldw	r4,-20(fp)
 823a32c:	8247b6c0 	call	8247b6c <in_pcbbind>
 823a330:	e0bff915 	stw	r2,-28(fp)
         break;
 823a334:	00014406 	br	823a848 <tcp_usrreq+0x6bc>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 823a338:	822d1c80 	call	822d1c8 <dtrap>
      error = EINVAL;
 823a33c:	00800584 	movi	r2,22
 823a340:	e0bff915 	stw	r2,-28(fp)
      break;
 823a344:	00014006 	br	823a848 <tcp_usrreq+0x6bc>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 823a348:	e0bffb17 	ldw	r2,-20(fp)
 823a34c:	1080078b 	ldhu	r2,30(r2)
 823a350:	10bfffcc 	andi	r2,r2,65535
 823a354:	1000041e 	bne	r2,zero,823a368 <tcp_usrreq+0x1dc>
         error = in_pcbbind(inp, (struct mbuf *)0);
 823a358:	000b883a 	mov	r5,zero
 823a35c:	e13ffb17 	ldw	r4,-20(fp)
 823a360:	8247b6c0 	call	8247b6c <in_pcbbind>
 823a364:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 823a368:	e0bff917 	ldw	r2,-28(fp)
 823a36c:	1001291e 	bne	r2,zero,823a814 <tcp_usrreq+0x688>
         tp->t_state = TCPS_LISTEN;
 823a370:	e0bff817 	ldw	r2,-32(fp)
 823a374:	00c00044 	movi	r3,1
 823a378:	10c00215 	stw	r3,8(r2)
      break;
 823a37c:	00012506 	br	823a814 <tcp_usrreq+0x688>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 823a380:	e0bffb17 	ldw	r2,-20(fp)
 823a384:	1080078b 	ldhu	r2,30(r2)
 823a388:	10bfffcc 	andi	r2,r2,65535
 823a38c:	1000061e 	bne	r2,zero,823a3a8 <tcp_usrreq+0x21c>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 823a390:	000b883a 	mov	r5,zero
 823a394:	e13ffb17 	ldw	r4,-20(fp)
 823a398:	8247b6c0 	call	8247b6c <in_pcbbind>
 823a39c:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 823a3a0:	e0bff917 	ldw	r2,-28(fp)
 823a3a4:	10011d1e 	bne	r2,zero,823a81c <tcp_usrreq+0x690>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 823a3a8:	e17fff17 	ldw	r5,-4(fp)
 823a3ac:	e13ffb17 	ldw	r4,-20(fp)
 823a3b0:	8247d7c0 	call	8247d7c <in_pcbconnect>
 823a3b4:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 823a3b8:	e0bff917 	ldw	r2,-28(fp)
 823a3bc:	1001191e 	bne	r2,zero,823a824 <tcp_usrreq+0x698>
         break;
      tp->t_template = tcp_template(tp);
 823a3c0:	e13ff817 	ldw	r4,-32(fp)
 823a3c4:	82391540 	call	8239154 <tcp_template>
 823a3c8:	1007883a 	mov	r3,r2
 823a3cc:	e0bff817 	ldw	r2,-32(fp)
 823a3d0:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 823a3d4:	e0bff817 	ldw	r2,-32(fp)
 823a3d8:	10800c17 	ldw	r2,48(r2)
 823a3dc:	1000051e 	bne	r2,zero,823a3f4 <tcp_usrreq+0x268>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 823a3e0:	e13ffb17 	ldw	r4,-20(fp)
 823a3e4:	8247f5c0 	call	8247f5c <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 823a3e8:	00801a44 	movi	r2,105
 823a3ec:	e0bff915 	stw	r2,-28(fp)
         break;
 823a3f0:	00011506 	br	823a848 <tcp_usrreq+0x6bc>
      }

      soisconnecting(so);
 823a3f4:	e13ffd17 	ldw	r4,-12(fp)
 823a3f8:	823369c0 	call	823369c <soisconnecting>
      tcpstat.tcps_connattempt++;
 823a3fc:	008209b4 	movhi	r2,2086
 823a400:	10b82204 	addi	r2,r2,-8056
 823a404:	10800017 	ldw	r2,0(r2)
 823a408:	10c00044 	addi	r3,r2,1
 823a40c:	008209b4 	movhi	r2,2086
 823a410:	10b82204 	addi	r2,r2,-8056
 823a414:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 823a418:	e0bff817 	ldw	r2,-32(fp)
 823a41c:	00c00084 	movi	r3,2
 823a420:	10c00215 	stw	r3,8(r2)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 823a424:	e0bff817 	ldw	r2,-32(fp)
 823a428:	00c02584 	movi	r3,150
 823a42c:	10c00515 	stw	r3,20(r2)
      tp->iss = tcp_iss; 
 823a430:	d0e0b517 	ldw	r3,-32044(gp)
 823a434:	e0bff817 	ldw	r2,-32(fp)
 823a438:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 823a43c:	d0e0b517 	ldw	r3,-32044(gp)
 823a440:	00be9fd4 	movui	r2,64127
 823a444:	1885883a 	add	r2,r3,r2
 823a448:	d0a0b515 	stw	r2,-32044(gp)
      tcp_sendseqinit(tp);
 823a44c:	e0bff817 	ldw	r2,-32(fp)
 823a450:	10c01317 	ldw	r3,76(r2)
 823a454:	e0bff817 	ldw	r2,-32(fp)
 823a458:	10c01015 	stw	r3,64(r2)
 823a45c:	e0bff817 	ldw	r2,-32(fp)
 823a460:	10c01017 	ldw	r3,64(r2)
 823a464:	e0bff817 	ldw	r2,-32(fp)
 823a468:	10c01a15 	stw	r3,104(r2)
 823a46c:	e0bff817 	ldw	r2,-32(fp)
 823a470:	10c01a17 	ldw	r3,104(r2)
 823a474:	e0bff817 	ldw	r2,-32(fp)
 823a478:	10c00f15 	stw	r3,60(r2)
 823a47c:	e0bff817 	ldw	r2,-32(fp)
 823a480:	10c00f17 	ldw	r3,60(r2)
 823a484:	e0bff817 	ldw	r2,-32(fp)
 823a488:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 823a48c:	e13ff817 	ldw	r4,-32(fp)
 823a490:	8237f340 	call	8237f34 <tcp_output>
 823a494:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 823a498:	e0bff917 	ldw	r2,-28(fp)
 823a49c:	1000e31e 	bne	r2,zero,823a82c <tcp_usrreq+0x6a0>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 823a4a0:	008209b4 	movhi	r2,2086
 823a4a4:	10b7f404 	addi	r2,r2,-8240
 823a4a8:	10800417 	ldw	r2,16(r2)
 823a4ac:	10c00044 	addi	r3,r2,1
 823a4b0:	008209b4 	movhi	r2,2086
 823a4b4:	10b7f404 	addi	r2,r2,-8240
 823a4b8:	10c00415 	stw	r3,16(r2)
      break;
 823a4bc:	0000db06 	br	823a82c <tcp_usrreq+0x6a0>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 823a4c0:	008017c4 	movi	r2,95
 823a4c4:	e0bff915 	stw	r2,-28(fp)
      break;
 823a4c8:	0000df06 	br	823a848 <tcp_usrreq+0x6bc>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 823a4cc:	e13ff817 	ldw	r4,-32(fp)
 823a4d0:	823a9780 	call	823a978 <tcp_disconnect>
      break;
 823a4d4:	0000dc06 	br	823a848 <tcp_usrreq+0x6bc>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 823a4d8:	e0bfff17 	ldw	r2,-4(fp)
 823a4dc:	10800317 	ldw	r2,12(r2)
 823a4e0:	e0bffc15 	stw	r2,-16(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 823a4e4:	e0bffd17 	ldw	r2,-12(fp)
 823a4e8:	10800517 	ldw	r2,20(r2)
 823a4ec:	10800098 	cmpnei	r2,r2,2
 823a4f0:	10000e1e 	bne	r2,zero,823a52c <tcp_usrreq+0x3a0>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 823a4f4:	e0bfff17 	ldw	r2,-4(fp)
 823a4f8:	00c00404 	movi	r3,16
 823a4fc:	10c00215 	stw	r3,8(r2)
            sin->sin_family = AF_INET;
 823a500:	e0bffc17 	ldw	r2,-16(fp)
 823a504:	00c00084 	movi	r3,2
 823a508:	10c0000d 	sth	r3,0(r2)
            sin->sin_port = inp->inp_fport;
 823a50c:	e0bffb17 	ldw	r2,-20(fp)
 823a510:	10c0070b 	ldhu	r3,28(r2)
 823a514:	e0bffc17 	ldw	r2,-16(fp)
 823a518:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 823a51c:	e0bffc17 	ldw	r2,-16(fp)
 823a520:	e0fffb17 	ldw	r3,-20(fp)
 823a524:	18c00317 	ldw	r3,12(r3)
 823a528:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a52c:	e0bffd17 	ldw	r2,-12(fp)
 823a530:	10800517 	ldw	r2,20(r2)
 823a534:	108000a0 	cmpeqi	r2,r2,2
 823a538:	10000b1e 	bne	r2,zero,823a568 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
 823a53c:	e0bffd17 	ldw	r2,-12(fp)
 823a540:	10800517 	ldw	r2,20(r2)
            sin->sin_family = AF_INET;
            sin->sin_port = inp->inp_fport;
            sin->sin_addr = inp->inp_faddr;
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a544:	108000e0 	cmpeqi	r2,r2,3
 823a548:	1000071e 	bne	r2,zero,823a568 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 823a54c:	e0bffd17 	ldw	r2,-12(fp)
 823a550:	10800517 	ldw	r2,20(r2)
 823a554:	100b883a 	mov	r5,r2
 823a558:	01020974 	movhi	r4,2085
 823a55c:	21025204 	addi	r4,r4,2376
 823a560:	8202e9c0 	call	8202e9c <printf>
            dtrap();
 823a564:	822d1c80 	call	822d1c8 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 823a568:	008209b4 	movhi	r2,2086
 823a56c:	10b7f404 	addi	r2,r2,-8240
 823a570:	10800517 	ldw	r2,20(r2)
 823a574:	10c00044 	addi	r3,r2,1
 823a578:	008209b4 	movhi	r2,2086
 823a57c:	10b7f404 	addi	r2,r2,-8240
 823a580:	10c00515 	stw	r3,20(r2)
         break;
 823a584:	0000b006 	br	823a848 <tcp_usrreq+0x6bc>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 823a588:	e13ffd17 	ldw	r4,-12(fp)
 823a58c:	8233d200 	call	8233d20 <socantsendmore>
      tp = tcp_usrclosed(tp);
 823a590:	e13ff817 	ldw	r4,-32(fp)
 823a594:	823aa440 	call	823aa44 <tcp_usrclosed>
 823a598:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 823a59c:	e0bff817 	ldw	r2,-32(fp)
 823a5a0:	1000a426 	beq	r2,zero,823a834 <tcp_usrreq+0x6a8>
         error = tcp_output(tp);
 823a5a4:	e13ff817 	ldw	r4,-32(fp)
 823a5a8:	8237f340 	call	8237f34 <tcp_output>
 823a5ac:	e0bff915 	stw	r2,-28(fp)
      break;
 823a5b0:	0000a006 	br	823a834 <tcp_usrreq+0x6a8>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 823a5b4:	e13ff817 	ldw	r4,-32(fp)
 823a5b8:	8237f340 	call	8237f34 <tcp_output>
      break;
 823a5bc:	0000a206 	br	823a848 <tcp_usrreq+0x6bc>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 823a5c0:	e0bffd17 	ldw	r2,-12(fp)
 823a5c4:	10800117 	ldw	r2,4(r2)
 823a5c8:	1000031e 	bne	r2,zero,823a5d8 <tcp_usrreq+0x44c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a5cc:	00800804 	movi	r2,32
 823a5d0:	e0bff915 	stw	r2,-28(fp)
         break;
 823a5d4:	00009c06 	br	823a848 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
 823a5d8:	e0bffd17 	ldw	r2,-12(fp)
 823a5dc:	10801204 	addi	r2,r2,72
 823a5e0:	e17ffe17 	ldw	r5,-8(fp)
 823a5e4:	1009883a 	mov	r4,r2
 823a5e8:	82340280 	call	8234028 <sbappend>
      error = tcp_output(tp);
 823a5ec:	e13ff817 	ldw	r4,-32(fp)
 823a5f0:	8237f340 	call	8237f34 <tcp_output>
 823a5f4:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a5f8:	e0bff917 	ldw	r2,-28(fp)
 823a5fc:	10801a58 	cmpnei	r2,r2,105
 823a600:	10008e1e 	bne	r2,zero,823a83c <tcp_usrreq+0x6b0>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a604:	e0bffd17 	ldw	r2,-12(fp)
 823a608:	10801204 	addi	r2,r2,72
 823a60c:	e17ffe17 	ldw	r5,-8(fp)
 823a610:	1009883a 	mov	r4,r2
 823a614:	82347980 	call	8234798 <sbdropend>
      break;
 823a618:	00008806 	br	823a83c <tcp_usrreq+0x6b0>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 823a61c:	01401c44 	movi	r5,113
 823a620:	e13ff817 	ldw	r4,-32(fp)
 823a624:	82397680 	call	8239768 <tcp_drop>
      break;
 823a628:	00008706 	br	823a848 <tcp_usrreq+0x6bc>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 823a62c:	822d1c80 	call	822d1c8 <dtrap>
      return (0);
 823a630:	0005883a 	mov	r2,zero
 823a634:	00008506 	br	823a84c <tcp_usrreq+0x6c0>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823a638:	e0bffd17 	ldw	r2,-12(fp)
 823a63c:	10801a17 	ldw	r2,104(r2)
 823a640:	1000051e 	bne	r2,zero,823a658 <tcp_usrreq+0x4cc>
          (so->so_state & SS_RCVATMARK) == 0) ||
 823a644:	e0bffd17 	ldw	r2,-12(fp)
 823a648:	1080088b 	ldhu	r2,34(r2)
 823a64c:	10bfffcc 	andi	r2,r2,65535
 823a650:	1080100c 	andi	r2,r2,64
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823a654:	10000926 	beq	r2,zero,823a67c <tcp_usrreq+0x4f0>
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823a658:	e0bffd17 	ldw	r2,-12(fp)
 823a65c:	10800417 	ldw	r2,16(r2)
 823a660:	1080400c 	andi	r2,r2,256
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
 823a664:	1000051e 	bne	r2,zero,823a67c <tcp_usrreq+0x4f0>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
 823a668:	e0bff817 	ldw	r2,-32(fp)
 823a66c:	10802403 	ldbu	r2,144(r2)
 823a670:	10803fcc 	andi	r2,r2,255
 823a674:	1080008c 	andi	r2,r2,2

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823a678:	10000326 	beq	r2,zero,823a688 <tcp_usrreq+0x4fc>
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 823a67c:	00800584 	movi	r2,22
 823a680:	e0bff915 	stw	r2,-28(fp)
         break;
 823a684:	00007006 	br	823a848 <tcp_usrreq+0x6bc>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 823a688:	e0bff817 	ldw	r2,-32(fp)
 823a68c:	10802403 	ldbu	r2,144(r2)
 823a690:	10803fcc 	andi	r2,r2,255
 823a694:	1080004c 	andi	r2,r2,1
 823a698:	1000031e 	bne	r2,zero,823a6a8 <tcp_usrreq+0x51c>
      {
         error = EWOULDBLOCK;
 823a69c:	008002c4 	movi	r2,11
 823a6a0:	e0bff915 	stw	r2,-28(fp)
         break;
 823a6a4:	00006806 	br	823a848 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
 823a6a8:	e0bffe17 	ldw	r2,-8(fp)
 823a6ac:	00c00044 	movi	r3,1
 823a6b0:	10c00215 	stw	r3,8(r2)
      *mtod(m, char *) = tp->t_iobc;
 823a6b4:	e0bffe17 	ldw	r2,-8(fp)
 823a6b8:	10800317 	ldw	r2,12(r2)
 823a6bc:	e0fff817 	ldw	r3,-32(fp)
 823a6c0:	18c02443 	ldbu	r3,145(r3)
 823a6c4:	10c00005 	stb	r3,0(r2)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 823a6c8:	e0bfff17 	ldw	r2,-4(fp)
 823a6cc:	1080008c 	andi	r2,r2,2
 823a6d0:	10005c1e 	bne	r2,zero,823a844 <tcp_usrreq+0x6b8>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 823a6d4:	e0bff817 	ldw	r2,-32(fp)
 823a6d8:	10802403 	ldbu	r2,144(r2)
 823a6dc:	108000dc 	xori	r2,r2,3
 823a6e0:	1007883a 	mov	r3,r2
 823a6e4:	e0bff817 	ldw	r2,-32(fp)
 823a6e8:	10c02405 	stb	r3,144(r2)
      break;
 823a6ec:	00005506 	br	823a844 <tcp_usrreq+0x6b8>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 823a6f0:	e0bffd17 	ldw	r2,-12(fp)
 823a6f4:	10800117 	ldw	r2,4(r2)
 823a6f8:	1000031e 	bne	r2,zero,823a708 <tcp_usrreq+0x57c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a6fc:	00800804 	movi	r2,32
 823a700:	e0bff915 	stw	r2,-28(fp)
         break;
 823a704:	00005006 	br	823a848 <tcp_usrreq+0x6bc>
      }
      if (sbspace(&so->so_snd) == 0) 
 823a708:	e0bffd17 	ldw	r2,-12(fp)
 823a70c:	10801317 	ldw	r2,76(r2)
 823a710:	1007883a 	mov	r3,r2
 823a714:	e0bffd17 	ldw	r2,-12(fp)
 823a718:	10801217 	ldw	r2,72(r2)
 823a71c:	1885c83a 	sub	r2,r3,r2
 823a720:	10000516 	blt	r2,zero,823a738 <tcp_usrreq+0x5ac>
 823a724:	e0bffd17 	ldw	r2,-12(fp)
 823a728:	10c01317 	ldw	r3,76(r2)
 823a72c:	e0bffd17 	ldw	r2,-12(fp)
 823a730:	10801217 	ldw	r2,72(r2)
 823a734:	1880051e 	bne	r3,r2,823a74c <tcp_usrreq+0x5c0>
      {
         m_freem(m);
 823a738:	e13ffe17 	ldw	r4,-8(fp)
 823a73c:	822e26c0 	call	822e26c <m_freem>
         error = ENOBUFS;
 823a740:	00801a44 	movi	r2,105
 823a744:	e0bff915 	stw	r2,-28(fp)
         break;
 823a748:	00003f06 	br	823a848 <tcp_usrreq+0x6bc>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 823a74c:	e0bffd17 	ldw	r2,-12(fp)
 823a750:	10801204 	addi	r2,r2,72
 823a754:	e17ffe17 	ldw	r5,-8(fp)
 823a758:	1009883a 	mov	r4,r2
 823a75c:	82340280 	call	8234028 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 823a760:	e0bff817 	ldw	r2,-32(fp)
 823a764:	10c00e17 	ldw	r3,56(r2)
 823a768:	e0bffd17 	ldw	r2,-12(fp)
 823a76c:	10801217 	ldw	r2,72(r2)
 823a770:	1887883a 	add	r3,r3,r2
 823a774:	e0bff817 	ldw	r2,-32(fp)
 823a778:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 823a77c:	e0bff817 	ldw	r2,-32(fp)
 823a780:	00c00044 	movi	r3,1
 823a784:	10c00a85 	stb	r3,42(r2)
      error = tcp_output(tp);
 823a788:	e13ff817 	ldw	r4,-32(fp)
 823a78c:	8237f340 	call	8237f34 <tcp_output>
 823a790:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a794:	e0bff917 	ldw	r2,-28(fp)
 823a798:	10801a58 	cmpnei	r2,r2,105
 823a79c:	1000051e 	bne	r2,zero,823a7b4 <tcp_usrreq+0x628>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a7a0:	e0bffd17 	ldw	r2,-12(fp)
 823a7a4:	10801204 	addi	r2,r2,72
 823a7a8:	e17ffe17 	ldw	r5,-8(fp)
 823a7ac:	1009883a 	mov	r4,r2
 823a7b0:	82347980 	call	8234798 <sbdropend>
      tp->t_force = 0;
 823a7b4:	e0bff817 	ldw	r2,-32(fp)
 823a7b8:	10000a85 	stb	zero,42(r2)
      break;
 823a7bc:	00002206 	br	823a848 <tcp_usrreq+0x6bc>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 823a7c0:	e17fff17 	ldw	r5,-4(fp)
 823a7c4:	e13ffb17 	ldw	r4,-20(fp)
 823a7c8:	8247fb80 	call	8247fb8 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 823a7cc:	00001e06 	br	823a848 <tcp_usrreq+0x6bc>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 823a7d0:	e17fff17 	ldw	r5,-4(fp)
 823a7d4:	e13ffb17 	ldw	r4,-20(fp)
 823a7d8:	824803c0 	call	824803c <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 823a7dc:	00001a06 	br	823a848 <tcp_usrreq+0x6bc>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 823a7e0:	e0bfff17 	ldw	r2,-4(fp)
 823a7e4:	100b883a 	mov	r5,r2
 823a7e8:	e13ff817 	ldw	r4,-32(fp)
 823a7ec:	8239d0c0 	call	8239d0c <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 823a7f0:	00001506 	br	823a848 <tcp_usrreq+0x6bc>

      default:
      panic("tcp_usrreq");
 823a7f4:	01020974 	movhi	r4,2085
 823a7f8:	21025a04 	addi	r4,r4,2408
 823a7fc:	822887c0 	call	822887c <panic>
 823a800:	00001106 	br	823a848 <tcp_usrreq+0x6bc>
         error = EISCONN;
         break;
      }
      error = tcp_attach(so);
      if (error)
         break;
 823a804:	0001883a 	nop
 823a808:	00000f06 	br	823a848 <tcp_usrreq+0x6bc>
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
         so->so_linger = TCP_LINGERTIME;
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a80c:	0001883a 	nop
 823a810:	00000d06 	br	823a848 <tcp_usrreq+0x6bc>
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
         error = in_pcbbind(inp, (struct mbuf *)0);
      if (error == 0)
         tp->t_state = TCPS_LISTEN;
      break;
 823a814:	0001883a 	nop
 823a818:	00000b06 	br	823a848 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
            break;
 823a81c:	0001883a 	nop
 823a820:	00000906 	br	823a848 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
         break;
 823a824:	0001883a 	nop
 823a828:	00000706 	br	823a848 <tcp_usrreq+0x6bc>
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
      tcp_sendseqinit(tp);
      error = tcp_output(tp);
      if (!error)
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
      break;
 823a82c:	0001883a 	nop
 823a830:	00000506 	br	823a848 <tcp_usrreq+0x6bc>
   case PRU_SHUTDOWN:
      socantsendmore(so);
      tp = tcp_usrclosed(tp);
      if (tp)
         error = tcp_output(tp);
      break;
 823a834:	0001883a 	nop
 823a838:	00000306 	br	823a848 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
      error = tcp_output(tp);
      if (error == ENOBUFS)
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
      break;
 823a83c:	0001883a 	nop
 823a840:	00000106 	br	823a848 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
      *mtod(m, char *) = tp->t_iobc;
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
      break;
 823a844:	0001883a 	nop
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 823a848:	e0bff917 	ldw	r2,-28(fp)
}
 823a84c:	e037883a 	mov	sp,fp
 823a850:	dfc00117 	ldw	ra,4(sp)
 823a854:	df000017 	ldw	fp,0(sp)
 823a858:	dec00204 	addi	sp,sp,8
 823a85c:	f800283a 	ret

0823a860 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 823a860:	defff904 	addi	sp,sp,-28
 823a864:	dfc00615 	stw	ra,24(sp)
 823a868:	df000515 	stw	fp,20(sp)
 823a86c:	df000504 	addi	fp,sp,20
 823a870:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 823a874:	e0bfff17 	ldw	r2,-4(fp)
 823a878:	10801317 	ldw	r2,76(r2)
 823a87c:	10000326 	beq	r2,zero,823a88c <tcp_attach+0x2c>
 823a880:	e0bfff17 	ldw	r2,-4(fp)
 823a884:	10800b17 	ldw	r2,44(r2)
 823a888:	10000b1e 	bne	r2,zero,823a8b8 <tcp_attach+0x58>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 823a88c:	d0a04017 	ldw	r2,-32512(gp)
 823a890:	d0e04117 	ldw	r3,-32508(gp)
 823a894:	180d883a 	mov	r6,r3
 823a898:	100b883a 	mov	r5,r2
 823a89c:	e13fff17 	ldw	r4,-4(fp)
 823a8a0:	8233f040 	call	8233f04 <soreserve>
 823a8a4:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 823a8a8:	e0bffb17 	ldw	r2,-20(fp)
 823a8ac:	10000226 	beq	r2,zero,823a8b8 <tcp_attach+0x58>
         return (error);
 823a8b0:	e0bffb17 	ldw	r2,-20(fp)
 823a8b4:	00002b06 	br	823a964 <tcp_attach+0x104>
   }
   error = in_pcballoc(so, &tcb);
 823a8b8:	014209b4 	movhi	r5,2086
 823a8bc:	29781704 	addi	r5,r5,-8100
 823a8c0:	e13fff17 	ldw	r4,-4(fp)
 823a8c4:	8247a8c0 	call	8247a8c <in_pcballoc>
 823a8c8:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 823a8cc:	e0bffb17 	ldw	r2,-20(fp)
 823a8d0:	10000226 	beq	r2,zero,823a8dc <tcp_attach+0x7c>
      return (error);
 823a8d4:	e0bffb17 	ldw	r2,-20(fp)
 823a8d8:	00002206 	br	823a964 <tcp_attach+0x104>
   inp = sotoinpcb(so);
 823a8dc:	e0bfff17 	ldw	r2,-4(fp)
 823a8e0:	10800117 	ldw	r2,4(r2)
 823a8e4:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 823a8e8:	e13ffc17 	ldw	r4,-16(fp)
 823a8ec:	823965c0 	call	823965c <tcp_newtcpcb>
 823a8f0:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 823a8f4:	e0bffd17 	ldw	r2,-12(fp)
 823a8f8:	1000171e 	bne	r2,zero,823a958 <tcp_attach+0xf8>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 823a8fc:	e0bfff17 	ldw	r2,-4(fp)
 823a900:	1080088b 	ldhu	r2,34(r2)
 823a904:	10bfffcc 	andi	r2,r2,65535
 823a908:	1080004c 	andi	r2,r2,1
 823a90c:	e0bffe15 	stw	r2,-8(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 823a910:	e0bfff17 	ldw	r2,-4(fp)
 823a914:	10c0088b 	ldhu	r3,34(r2)
 823a918:	00bfff84 	movi	r2,-2
 823a91c:	1884703a 	and	r2,r3,r2
 823a920:	1007883a 	mov	r3,r2
 823a924:	e0bfff17 	ldw	r2,-4(fp)
 823a928:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 823a92c:	e13ffc17 	ldw	r4,-16(fp)
 823a930:	8247b140 	call	8247b14 <in_pcbdetach>
      so->so_state |= nofd;
 823a934:	e0bfff17 	ldw	r2,-4(fp)
 823a938:	1080088b 	ldhu	r2,34(r2)
 823a93c:	e0fffe17 	ldw	r3,-8(fp)
 823a940:	10c4b03a 	or	r2,r2,r3
 823a944:	1007883a 	mov	r3,r2
 823a948:	e0bfff17 	ldw	r2,-4(fp)
 823a94c:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 823a950:	00801a44 	movi	r2,105
 823a954:	00000306 	br	823a964 <tcp_attach+0x104>
   }
   tp->t_state = TCPS_CLOSED;
 823a958:	e0bffd17 	ldw	r2,-12(fp)
 823a95c:	10000215 	stw	zero,8(r2)
   return (0);
 823a960:	0005883a 	mov	r2,zero
}
 823a964:	e037883a 	mov	sp,fp
 823a968:	dfc00117 	ldw	ra,4(sp)
 823a96c:	df000017 	ldw	fp,0(sp)
 823a970:	dec00204 	addi	sp,sp,8
 823a974:	f800283a 	ret

0823a978 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 823a978:	defffc04 	addi	sp,sp,-16
 823a97c:	dfc00315 	stw	ra,12(sp)
 823a980:	df000215 	stw	fp,8(sp)
 823a984:	df000204 	addi	fp,sp,8
 823a988:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823a98c:	e0bfff17 	ldw	r2,-4(fp)
 823a990:	10800d17 	ldw	r2,52(r2)
 823a994:	10800817 	ldw	r2,32(r2)
 823a998:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 823a99c:	e0bfff17 	ldw	r2,-4(fp)
 823a9a0:	10800217 	ldw	r2,8(r2)
 823a9a4:	10800108 	cmpgei	r2,r2,4
 823a9a8:	1000041e 	bne	r2,zero,823a9bc <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 823a9ac:	e13fff17 	ldw	r4,-4(fp)
 823a9b0:	82398140 	call	8239814 <tcp_close>
 823a9b4:	e0bfff15 	stw	r2,-4(fp)
 823a9b8:	00001c06 	br	823aa2c <tcp_disconnect+0xb4>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823a9bc:	e0bffe17 	ldw	r2,-8(fp)
 823a9c0:	10800417 	ldw	r2,16(r2)
 823a9c4:	1080200c 	andi	r2,r2,128
 823a9c8:	10000b26 	beq	r2,zero,823a9f8 <tcp_disconnect+0x80>
 823a9cc:	e0bffe17 	ldw	r2,-8(fp)
 823a9d0:	1080080b 	ldhu	r2,32(r2)
 823a9d4:	10bfffcc 	andi	r2,r2,65535
 823a9d8:	10a0001c 	xori	r2,r2,32768
 823a9dc:	10a00004 	addi	r2,r2,-32768
 823a9e0:	1000051e 	bne	r2,zero,823a9f8 <tcp_disconnect+0x80>
      tp = tcp_drop(tp, 0);
 823a9e4:	000b883a 	mov	r5,zero
 823a9e8:	e13fff17 	ldw	r4,-4(fp)
 823a9ec:	82397680 	call	8239768 <tcp_drop>
 823a9f0:	e0bfff15 	stw	r2,-4(fp)
 823a9f4:	00000d06 	br	823aa2c <tcp_disconnect+0xb4>
   else 
   {
      soisdisconnecting(so);
 823a9f8:	e13ffe17 	ldw	r4,-8(fp)
 823a9fc:	82338100 	call	8233810 <soisdisconnecting>
      sbflush(&so->so_rcv);
 823aa00:	e0bffe17 	ldw	r2,-8(fp)
 823aa04:	10800a04 	addi	r2,r2,40
 823aa08:	1009883a 	mov	r4,r2
 823aa0c:	823455c0 	call	823455c <sbflush>
      tp = tcp_usrclosed(tp);
 823aa10:	e13fff17 	ldw	r4,-4(fp)
 823aa14:	823aa440 	call	823aa44 <tcp_usrclosed>
 823aa18:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 823aa1c:	e0bfff17 	ldw	r2,-4(fp)
 823aa20:	10000226 	beq	r2,zero,823aa2c <tcp_disconnect+0xb4>
         (void) tcp_output(tp);
 823aa24:	e13fff17 	ldw	r4,-4(fp)
 823aa28:	8237f340 	call	8237f34 <tcp_output>
   }
   return (tp);
 823aa2c:	e0bfff17 	ldw	r2,-4(fp)
}
 823aa30:	e037883a 	mov	sp,fp
 823aa34:	dfc00117 	ldw	ra,4(sp)
 823aa38:	df000017 	ldw	fp,0(sp)
 823aa3c:	dec00204 	addi	sp,sp,8
 823aa40:	f800283a 	ret

0823aa44 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 823aa44:	defffd04 	addi	sp,sp,-12
 823aa48:	dfc00215 	stw	ra,8(sp)
 823aa4c:	df000115 	stw	fp,4(sp)
 823aa50:	df000104 	addi	fp,sp,4
 823aa54:	e13fff15 	stw	r4,-4(fp)

   switch (tp->t_state) 
 823aa58:	e0bfff17 	ldw	r2,-4(fp)
 823aa5c:	10800217 	ldw	r2,8(r2)
 823aa60:	10c001a8 	cmpgeui	r3,r2,6
 823aa64:	18001a1e 	bne	r3,zero,823aad0 <tcp_usrclosed+0x8c>
 823aa68:	100690ba 	slli	r3,r2,2
 823aa6c:	00820934 	movhi	r2,2084
 823aa70:	10aaa004 	addi	r2,r2,-21888
 823aa74:	1885883a 	add	r2,r3,r2
 823aa78:	10800017 	ldw	r2,0(r2)
 823aa7c:	1000683a 	jmp	r2
 823aa80:	0823aa98 	cmpnei	zero,at,-29014
 823aa84:	0823aa98 	cmpnei	zero,at,-29014
 823aa88:	0823aa98 	cmpnei	zero,at,-29014
 823aa8c:	0823aab0 	cmpltui	zero,at,36522
 823aa90:	0823aab0 	cmpltui	zero,at,36522
 823aa94:	0823aac0 	call	823aac <OSCtxSw_SWITCH_PC+0x823a6c>
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 823aa98:	e0bfff17 	ldw	r2,-4(fp)
 823aa9c:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 823aaa0:	e13fff17 	ldw	r4,-4(fp)
 823aaa4:	82398140 	call	8239814 <tcp_close>
 823aaa8:	e0bfff15 	stw	r2,-4(fp)
      break;
 823aaac:	00000806 	br	823aad0 <tcp_usrclosed+0x8c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 823aab0:	e0bfff17 	ldw	r2,-4(fp)
 823aab4:	00c00184 	movi	r3,6
 823aab8:	10c00215 	stw	r3,8(r2)
      break;
 823aabc:	00000406 	br	823aad0 <tcp_usrclosed+0x8c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 823aac0:	e0bfff17 	ldw	r2,-4(fp)
 823aac4:	00c00204 	movi	r3,8
 823aac8:	10c00215 	stw	r3,8(r2)
      break;
 823aacc:	0001883a 	nop
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 823aad0:	e0bfff17 	ldw	r2,-4(fp)
 823aad4:	10000926 	beq	r2,zero,823aafc <tcp_usrclosed+0xb8>
 823aad8:	e0bfff17 	ldw	r2,-4(fp)
 823aadc:	10800217 	ldw	r2,8(r2)
 823aae0:	10800250 	cmplti	r2,r2,9
 823aae4:	1000051e 	bne	r2,zero,823aafc <tcp_usrclosed+0xb8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 823aae8:	e0bfff17 	ldw	r2,-4(fp)
 823aaec:	10800d17 	ldw	r2,52(r2)
 823aaf0:	10800817 	ldw	r2,32(r2)
 823aaf4:	1009883a 	mov	r4,r2
 823aaf8:	82338a80 	call	82338a8 <soisdisconnected>
   return (tp);
 823aafc:	e0bfff17 	ldw	r2,-4(fp)
}
 823ab00:	e037883a 	mov	sp,fp
 823ab04:	dfc00117 	ldw	ra,4(sp)
 823ab08:	df000017 	ldw	fp,0(sp)
 823ab0c:	dec00204 	addi	sp,sp,8
 823ab10:	f800283a 	ret

0823ab14 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 823ab14:	defffd04 	addi	sp,sp,-12
 823ab18:	dfc00215 	stw	ra,8(sp)
 823ab1c:	df000115 	stw	fp,4(sp)
 823ab20:	df000104 	addi	fp,sp,4
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 823ab24:	822e9400 	call	822e940 <nptcp_init>
 823ab28:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 823ab2c:	e0bfff17 	ldw	r2,-4(fp)
 823ab30:	10000226 	beq	r2,zero,823ab3c <tcpinit+0x28>
      return e;
 823ab34:	e0bfff17 	ldw	r2,-4(fp)
 823ab38:	00000106 	br	823ab40 <tcpinit+0x2c>

   return 0;   /* good return */
 823ab3c:	0005883a 	mov	r2,zero
}
 823ab40:	e037883a 	mov	sp,fp
 823ab44:	dfc00117 	ldw	ra,4(sp)
 823ab48:	df000017 	ldw	fp,0(sp)
 823ab4c:	dec00204 	addi	sp,sp,8
 823ab50:	f800283a 	ret

0823ab54 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 823ab54:	defffd04 	addi	sp,sp,-12
 823ab58:	df000215 	stw	fp,8(sp)
 823ab5c:	df000204 	addi	fp,sp,8
 823ab60:	e13fff15 	stw	r4,-4(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823ab64:	d0a09c17 	ldw	r2,-32144(gp)
 823ab68:	e0bffe15 	stw	r2,-8(fp)
 823ab6c:	00000906 	br	823ab94 <udp_lookup+0x40>
      if (tmp->u_data == (void*)so)
 823ab70:	e0bffe17 	ldw	r2,-8(fp)
 823ab74:	10c00617 	ldw	r3,24(r2)
 823ab78:	e0bfff17 	ldw	r2,-4(fp)
 823ab7c:	1880021e 	bne	r3,r2,823ab88 <udp_lookup+0x34>
      return (tmp);
 823ab80:	e0bffe17 	ldw	r2,-8(fp)
 823ab84:	00000606 	br	823aba0 <udp_lookup+0x4c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823ab88:	e0bffe17 	ldw	r2,-8(fp)
 823ab8c:	10800017 	ldw	r2,0(r2)
 823ab90:	e0bffe15 	stw	r2,-8(fp)
 823ab94:	e0bffe17 	ldw	r2,-8(fp)
 823ab98:	103ff51e 	bne	r2,zero,823ab70 <udp_lookup+0x1c>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 823ab9c:	0005883a 	mov	r2,zero
}
 823aba0:	e037883a 	mov	sp,fp
 823aba4:	df000017 	ldw	fp,0(sp)
 823aba8:	dec00104 	addi	sp,sp,4
 823abac:	f800283a 	ret

0823abb0 <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 823abb0:	defff504 	addi	sp,sp,-44
 823abb4:	dfc00a15 	stw	ra,40(sp)
 823abb8:	df000915 	stw	fp,36(sp)
 823abbc:	df000904 	addi	fp,sp,36
 823abc0:	e13ffe15 	stw	r4,-8(fp)
 823abc4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 823abc8:	e0bfff17 	ldw	r2,-4(fp)
 823abcc:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 823abd0:	0009883a 	mov	r4,zero
 823abd4:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 823abd8:	e0bff717 	ldw	r2,-36(fp)
 823abdc:	10c00a17 	ldw	r3,40(r2)
 823abe0:	e0bffe17 	ldw	r2,-8(fp)
 823abe4:	10800417 	ldw	r2,16(r2)
 823abe8:	1887883a 	add	r3,r3,r2
 823abec:	e0bff717 	ldw	r2,-36(fp)
 823abf0:	10800b17 	ldw	r2,44(r2)
 823abf4:	18800436 	bltu	r3,r2,823ac08 <udp_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823abf8:	0009883a 	mov	r4,zero
 823abfc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ac00:	00801a44 	movi	r2,105
 823ac04:	00004d06 	br	823ad3c <udp_soinput+0x18c>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 823ac08:	000b883a 	mov	r5,zero
 823ac0c:	01000044 	movi	r4,1
 823ac10:	822dfdc0 	call	822dfdc <m_getnbuf>
 823ac14:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 823ac18:	e0bff817 	ldw	r2,-32(fp)
 823ac1c:	1000041e 	bne	r2,zero,823ac30 <udp_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ac20:	0009883a 	mov	r4,zero
 823ac24:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ac28:	00801a44 	movi	r2,105
 823ac2c:	00004306 	br	823ad3c <udp_soinput+0x18c>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 823ac30:	e0bff817 	ldw	r2,-32(fp)
 823ac34:	e0fffe17 	ldw	r3,-8(fp)
 823ac38:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 823ac3c:	e0bffe17 	ldw	r2,-8(fp)
 823ac40:	10c00317 	ldw	r3,12(r2)
 823ac44:	e0bff817 	ldw	r2,-32(fp)
 823ac48:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 823ac4c:	e0bffe17 	ldw	r2,-8(fp)
 823ac50:	10c00417 	ldw	r3,16(r2)
 823ac54:	e0bff817 	ldw	r2,-32(fp)
 823ac58:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 823ac5c:	e0bffe17 	ldw	r2,-8(fp)
 823ac60:	10c00117 	ldw	r3,4(r2)
 823ac64:	e0bff817 	ldw	r2,-32(fp)
 823ac68:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 823ac6c:	e0bffe17 	ldw	r2,-8(fp)
 823ac70:	10c00217 	ldw	r3,8(r2)
 823ac74:	e0bff817 	ldw	r2,-32(fp)
 823ac78:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 823ac7c:	e0bffe17 	ldw	r2,-8(fp)
 823ac80:	10800717 	ldw	r2,28(r2)
 823ac84:	e0bffb15 	stw	r2,-20(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 823ac88:	e0bffe17 	ldw	r2,-8(fp)
 823ac8c:	10800317 	ldw	r2,12(r2)
 823ac90:	10bffe04 	addi	r2,r2,-8
 823ac94:	e0bff915 	stw	r2,-28(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 823ac98:	e0bff917 	ldw	r2,-28(fp)
 823ac9c:	1080000b 	ldhu	r2,0(r2)
 823aca0:	10bfffcc 	andi	r2,r2,65535
 823aca4:	1004d23a 	srli	r2,r2,8
 823aca8:	1007883a 	mov	r3,r2
 823acac:	e0bff917 	ldw	r2,-28(fp)
 823acb0:	1080000b 	ldhu	r2,0(r2)
 823acb4:	10bfffcc 	andi	r2,r2,65535
 823acb8:	1004923a 	slli	r2,r2,8
 823acbc:	1884b03a 	or	r2,r3,r2
 823acc0:	e0bffa8d 	sth	r2,-22(fp)
   sin.sin_family = AF_INET;
 823acc4:	00800084 	movi	r2,2
 823acc8:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 823accc:	e0bff717 	ldw	r2,-36(fp)
 823acd0:	10800a04 	addi	r2,r2,40
 823acd4:	e0fffa04 	addi	r3,fp,-24
 823acd8:	e1bff817 	ldw	r6,-32(fp)
 823acdc:	180b883a 	mov	r5,r3
 823ace0:	1009883a 	mov	r4,r2
 823ace4:	82341a00 	call	82341a0 <sbappendaddr>
 823ace8:	1000081e 	bne	r2,zero,823ad0c <udp_soinput+0x15c>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 823acec:	e0bff817 	ldw	r2,-32(fp)
 823acf0:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 823acf4:	e13ff817 	ldw	r4,-32(fp)
 823acf8:	822e1640 	call	822e164 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823acfc:	0009883a 	mov	r4,zero
 823ad00:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ad04:	00801a44 	movi	r2,105
 823ad08:	00000c06 	br	823ad3c <udp_soinput+0x18c>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 823ad0c:	e0bff717 	ldw	r2,-36(fp)
 823ad10:	10800a04 	addi	r2,r2,40
 823ad14:	1009883a 	mov	r4,r2
 823ad18:	82292dc0 	call	82292dc <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 823ad1c:	e0bff717 	ldw	r2,-36(fp)
 823ad20:	10800a04 	addi	r2,r2,40
 823ad24:	100b883a 	mov	r5,r2
 823ad28:	e13ff717 	ldw	r4,-36(fp)
 823ad2c:	8233e780 	call	8233e78 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 823ad30:	0009883a 	mov	r4,zero
 823ad34:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return 0;
 823ad38:	0005883a 	mov	r2,zero
}
 823ad3c:	e037883a 	mov	sp,fp
 823ad40:	dfc00117 	ldw	ra,4(sp)
 823ad44:	df000017 	ldw	fp,0(sp)
 823ad48:	dec00204 	addi	sp,sp,8
 823ad4c:	f800283a 	ret

0823ad50 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823ad50:	defff804 	addi	sp,sp,-32
 823ad54:	dfc00715 	stw	ra,28(sp)
 823ad58:	df000615 	stw	fp,24(sp)
 823ad5c:	df000604 	addi	fp,sp,24
 823ad60:	e13ffd15 	stw	r4,-12(fp)
 823ad64:	e17ffe15 	stw	r5,-8(fp)
 823ad68:	e1bfff15 	stw	r6,-4(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 823ad6c:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 823ad70:	e0bffd17 	ldw	r2,-12(fp)
 823ad74:	10800717 	ldw	r2,28(r2)
 823ad78:	e0bffc15 	stw	r2,-16(fp)

   switch (req) 
 823ad7c:	e0bffc17 	ldw	r2,-16(fp)
 823ad80:	10800468 	cmpgeui	r2,r2,17
 823ad84:	10007b1e 	bne	r2,zero,823af74 <udp_usrreq+0x224>
 823ad88:	e0bffc17 	ldw	r2,-16(fp)
 823ad8c:	100690ba 	slli	r3,r2,2
 823ad90:	00820934 	movhi	r2,2084
 823ad94:	10ab6904 	addi	r2,r2,-21084
 823ad98:	1885883a 	add	r2,r3,r2
 823ad9c:	10800017 	ldw	r2,0(r2)
 823ada0:	1000683a 	jmp	r2
 823ada4:	0823ade8 	cmpgeui	zero,at,36535
 823ada8:	0823ae6c 	andhi	zero,at,36537
 823adac:	0823aea8 	cmpgeui	zero,at,36538
 823adb0:	0823af74 	orhi	zero,at,36541
 823adb4:	0823aea8 	cmpgeui	zero,at,36538
 823adb8:	0823af74 	orhi	zero,at,36541
 823adbc:	0823af68 	cmpgeui	zero,at,36541
 823adc0:	0823af74 	orhi	zero,at,36541
 823adc4:	0823af68 	cmpgeui	zero,at,36541
 823adc8:	0823aee8 	cmpgeui	zero,at,36539
 823adcc:	0823af74 	orhi	zero,at,36541
 823add0:	0823af74 	orhi	zero,at,36541
 823add4:	0823af74 	orhi	zero,at,36541
 823add8:	0823af74 	orhi	zero,at,36541
 823addc:	0823af74 	orhi	zero,at,36541
 823ade0:	0823af28 	cmpgeui	zero,at,36540
 823ade4:	0823af28 	cmpgeui	zero,at,36540
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 823ade8:	82450f80 	call	82450f8 <udp_maxalloc>
 823adec:	1007883a 	mov	r3,r2
 823adf0:	e0bffd17 	ldw	r2,-12(fp)
 823adf4:	10c01315 	stw	r3,76(r2)
 823adf8:	e0bffd17 	ldw	r2,-12(fp)
 823adfc:	10c01317 	ldw	r3,76(r2)
 823ae00:	e0bffd17 	ldw	r2,-12(fp)
 823ae04:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 823ae08:	e0bffd17 	ldw	r2,-12(fp)
 823ae0c:	10800517 	ldw	r2,20(r2)
 823ae10:	10800098 	cmpnei	r2,r2,2
 823ae14:	10000f1e 	bne	r2,zero,823ae54 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 823ae18:	0009883a 	mov	r4,zero
 823ae1c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 823ae20:	8244f8c0 	call	8244f8c <udp_socket>
 823ae24:	10ffffcc 	andi	r3,r2,65535
 823ae28:	e0bffd17 	ldw	r2,-12(fp)
 823ae2c:	d8800015 	stw	r2,0(sp)
 823ae30:	01c20934 	movhi	r7,2084
 823ae34:	39eaec04 	addi	r7,r7,-21584
 823ae38:	180d883a 	mov	r6,r3
 823ae3c:	000b883a 	mov	r5,zero
 823ae40:	0009883a 	mov	r4,zero
 823ae44:	822cd600 	call	822cd60 <udp_open>
 823ae48:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 823ae4c:	0009883a 	mov	r4,zero
 823ae50:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 823ae54:	e0bffb17 	ldw	r2,-20(fp)
 823ae58:	1000021e 	bne	r2,zero,823ae64 <udp_usrreq+0x114>
         return(EINVAL);
 823ae5c:	00800584 	movi	r2,22
 823ae60:	00004506 	br	823af78 <udp_usrreq+0x228>
      return 0;
 823ae64:	0005883a 	mov	r2,zero
 823ae68:	00004306 	br	823af78 <udp_usrreq+0x228>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 823ae6c:	e13ffd17 	ldw	r4,-12(fp)
 823ae70:	823ab540 	call	823ab54 <udp_lookup>
 823ae74:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 823ae78:	e0bffb17 	ldw	r2,-20(fp)
 823ae7c:	1000021e 	bne	r2,zero,823ae88 <udp_usrreq+0x138>
         return(EINVAL);
 823ae80:	00800584 	movi	r2,22
 823ae84:	00003c06 	br	823af78 <udp_usrreq+0x228>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ae88:	0009883a 	mov	r4,zero
 823ae8c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 823ae90:	e13ffb17 	ldw	r4,-20(fp)
 823ae94:	822cf5c0 	call	822cf5c <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 823ae98:	0009883a 	mov	r4,zero
 823ae9c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      return 0;
 823aea0:	0005883a 	mov	r2,zero
 823aea4:	00003406 	br	823af78 <udp_usrreq+0x228>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 823aea8:	e0bfff17 	ldw	r2,-4(fp)
 823aeac:	1000021e 	bne	r2,zero,823aeb8 <udp_usrreq+0x168>
         return(EINVAL);
 823aeb0:	00800584 	movi	r2,22
 823aeb4:	00003006 	br	823af78 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823aeb8:	e0bffd17 	ldw	r2,-12(fp)
 823aebc:	10800517 	ldw	r2,20(r2)
 823aec0:	10800098 	cmpnei	r2,r2,2
 823aec4:	1000051e 	bne	r2,zero,823aedc <udp_usrreq+0x18c>
        return udp4_sockbind(so, nam, req );
 823aec8:	e1bffc17 	ldw	r6,-16(fp)
 823aecc:	e17fff17 	ldw	r5,-4(fp)
 823aed0:	e13ffd17 	ldw	r4,-12(fp)
 823aed4:	823af8c0 	call	823af8c <udp4_sockbind>
 823aed8:	00002706 	br	823af78 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823aedc:	822d1c80 	call	822d1c8 <dtrap>
      return EINVAL;
 823aee0:	00800584 	movi	r2,22
 823aee4:	00002406 	br	823af78 <udp_usrreq+0x228>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 823aee8:	e0bffe17 	ldw	r2,-8(fp)
 823aeec:	1000021e 	bne	r2,zero,823aef8 <udp_usrreq+0x1a8>
         return(EINVAL);
 823aef0:	00800584 	movi	r2,22
 823aef4:	00002006 	br	823af78 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823aef8:	e0bffd17 	ldw	r2,-12(fp)
 823aefc:	10800517 	ldw	r2,20(r2)
 823af00:	10800098 	cmpnei	r2,r2,2
 823af04:	1000051e 	bne	r2,zero,823af1c <udp_usrreq+0x1cc>
        return udp4_socksend(so, m, nam );
 823af08:	e1bfff17 	ldw	r6,-4(fp)
 823af0c:	e17ffe17 	ldw	r5,-8(fp)
 823af10:	e13ffd17 	ldw	r4,-12(fp)
 823af14:	823b2600 	call	823b260 <udp4_socksend>
 823af18:	00001706 	br	823af78 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 823af1c:	822d1c80 	call	822d1c8 <dtrap>
      return EINVAL;
 823af20:	00800584 	movi	r2,22
 823af24:	00001406 	br	823af78 <udp_usrreq+0x228>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 823af28:	e0bfff17 	ldw	r2,-4(fp)
 823af2c:	1000021e 	bne	r2,zero,823af38 <udp_usrreq+0x1e8>
         return(EINVAL);
 823af30:	00800584 	movi	r2,22
 823af34:	00001006 	br	823af78 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823af38:	e0bffd17 	ldw	r2,-12(fp)
 823af3c:	10800517 	ldw	r2,20(r2)
 823af40:	10800098 	cmpnei	r2,r2,2
 823af44:	1000051e 	bne	r2,zero,823af5c <udp_usrreq+0x20c>
        return udp4_sockaddr(so, nam, req );
 823af48:	e1bffc17 	ldw	r6,-16(fp)
 823af4c:	e17fff17 	ldw	r5,-4(fp)
 823af50:	e13ffd17 	ldw	r4,-12(fp)
 823af54:	823b5e00 	call	823b5e0 <udp4_sockaddr>
 823af58:	00000706 	br	823af78 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823af5c:	822d1c80 	call	822d1c8 <dtrap>
      return EINVAL;
 823af60:	00800584 	movi	r2,22
 823af64:	00000406 	br	823af78 <udp_usrreq+0x228>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 823af68:	822d1c80 	call	822d1c8 <dtrap>
      return 0;
 823af6c:	0005883a 	mov	r2,zero
 823af70:	00000106 	br	823af78 <udp_usrreq+0x228>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 823af74:	008017c4 	movi	r2,95
   }
}
 823af78:	e037883a 	mov	sp,fp
 823af7c:	dfc00117 	ldw	ra,4(sp)
 823af80:	df000017 	ldw	fp,0(sp)
 823af84:	dec00204 	addi	sp,sp,8
 823af88:	f800283a 	ret

0823af8c <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 823af8c:	defff304 	addi	sp,sp,-52
 823af90:	dfc00c15 	stw	ra,48(sp)
 823af94:	df000b15 	stw	fp,44(sp)
 823af98:	df000b04 	addi	fp,sp,44
 823af9c:	e13ffd15 	stw	r4,-12(fp)
 823afa0:	e17ffe15 	stw	r5,-8(fp)
 823afa4:	e1bfff15 	stw	r6,-4(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 823afa8:	e0bffe17 	ldw	r2,-8(fp)
 823afac:	10800317 	ldw	r2,12(r2)
 823afb0:	e0bffa15 	stw	r2,-24(fp)
  if (sin == NULL)
 823afb4:	e0bffa17 	ldw	r2,-24(fp)
 823afb8:	1000021e 	bne	r2,zero,823afc4 <udp4_sockbind+0x38>
    return(EINVAL);
 823afbc:	00800584 	movi	r2,22
 823afc0:	0000a206 	br	823b24c <udp4_sockbind+0x2c0>
  if (nam->m_len != sizeof (*sin))
 823afc4:	e0bffe17 	ldw	r2,-8(fp)
 823afc8:	10800217 	ldw	r2,8(r2)
 823afcc:	10800420 	cmpeqi	r2,r2,16
 823afd0:	1000021e 	bne	r2,zero,823afdc <udp4_sockbind+0x50>
    return(EINVAL);
 823afd4:	00800584 	movi	r2,22
 823afd8:	00009c06 	br	823b24c <udp4_sockbind+0x2c0>
  udpconn = udp_lookup(so);
 823afdc:	e13ffd17 	ldw	r4,-12(fp)
 823afe0:	823ab540 	call	823ab54 <udp_lookup>
 823afe4:	e0bffb15 	stw	r2,-20(fp)
  if (!udpconn)
 823afe8:	e0bffb17 	ldw	r2,-20(fp)
 823afec:	1000021e 	bne	r2,zero,823aff8 <udp4_sockbind+0x6c>
     return(EINVAL);
 823aff0:	00800584 	movi	r2,22
 823aff4:	00009506 	br	823b24c <udp4_sockbind+0x2c0>
  if (req == PRU_BIND)
 823aff8:	e0bfff17 	ldw	r2,-4(fp)
 823affc:	10800098 	cmpnei	r2,r2,2
 823b000:	1000531e 	bne	r2,zero,823b150 <udp4_sockbind+0x1c4>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 823b004:	e0bffa17 	ldw	r2,-24(fp)
 823b008:	1080008b 	ldhu	r2,2(r2)
 823b00c:	10bfffcc 	andi	r2,r2,65535
 823b010:	10000b1e 	bne	r2,zero,823b040 <udp4_sockbind+0xb4>
    {
      if (udpconn->u_lport != 0)
 823b014:	e0bffb17 	ldw	r2,-20(fp)
 823b018:	1080018b 	ldhu	r2,6(r2)
 823b01c:	10bfffcc 	andi	r2,r2,65535
 823b020:	10000426 	beq	r2,zero,823b034 <udp4_sockbind+0xa8>
        lport = udpconn->u_lport;
 823b024:	e0bffb17 	ldw	r2,-20(fp)
 823b028:	1080018b 	ldhu	r2,6(r2)
 823b02c:	e0bff60d 	sth	r2,-40(fp)
 823b030:	00000e06 	br	823b06c <udp4_sockbind+0xe0>
      else
        lport = udp_socket();
 823b034:	8244f8c0 	call	8244f8c <udp_socket>
 823b038:	e0bff60d 	sth	r2,-40(fp)
 823b03c:	00000b06 	br	823b06c <udp4_sockbind+0xe0>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 823b040:	e0bffa17 	ldw	r2,-24(fp)
 823b044:	1080008b 	ldhu	r2,2(r2)
 823b048:	10bfffcc 	andi	r2,r2,65535
 823b04c:	1004d23a 	srli	r2,r2,8
 823b050:	1007883a 	mov	r3,r2
 823b054:	e0bffa17 	ldw	r2,-24(fp)
 823b058:	1080008b 	ldhu	r2,2(r2)
 823b05c:	10bfffcc 	andi	r2,r2,65535
 823b060:	1004923a 	slli	r2,r2,8
 823b064:	1884b03a 	or	r2,r3,r2
 823b068:	e0bff60d 	sth	r2,-40(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b06c:	e0bffa17 	ldw	r2,-24(fp)
 823b070:	10800117 	ldw	r2,4(r2)
 823b074:	1000021e 	bne	r2,zero,823b080 <udp4_sockbind+0xf4>
    {
      lhost = 0L;
 823b078:	e03ff815 	stw	zero,-32(fp)
 823b07c:	00001706 	br	823b0dc <udp4_sockbind+0x150>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 823b080:	e0bffa17 	ldw	r2,-24(fp)
 823b084:	10800117 	ldw	r2,4(r2)
 823b088:	e0bff815 	stw	r2,-32(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b08c:	008209b4 	movhi	r2,2086
 823b090:	10b8f304 	addi	r2,r2,-7220
 823b094:	10800017 	ldw	r2,0(r2)
 823b098:	e0bff915 	stw	r2,-28(fp)
 823b09c:	00000706 	br	823b0bc <udp4_sockbind+0x130>
        if (ifp->n_ipaddr == lhost)
 823b0a0:	e0bff917 	ldw	r2,-28(fp)
 823b0a4:	10c00a17 	ldw	r3,40(r2)
 823b0a8:	e0bff817 	ldw	r2,-32(fp)
 823b0ac:	18800626 	beq	r3,r2,823b0c8 <udp4_sockbind+0x13c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b0b0:	e0bff917 	ldw	r2,-28(fp)
 823b0b4:	10800017 	ldw	r2,0(r2)
 823b0b8:	e0bff915 	stw	r2,-28(fp)
 823b0bc:	e0bff917 	ldw	r2,-28(fp)
 823b0c0:	103ff71e 	bne	r2,zero,823b0a0 <udp4_sockbind+0x114>
 823b0c4:	00000106 	br	823b0cc <udp4_sockbind+0x140>
        if (ifp->n_ipaddr == lhost)
          break;
 823b0c8:	0001883a 	nop
      if (ifp == NULL)
 823b0cc:	e0bff917 	ldw	r2,-28(fp)
 823b0d0:	1000021e 	bne	r2,zero,823b0dc <udp4_sockbind+0x150>
        return(EADDRNOTAVAIL);
 823b0d4:	00801f44 	movi	r2,125
 823b0d8:	00005c06 	br	823b24c <udp4_sockbind+0x2c0>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 823b0dc:	e0bffd17 	ldw	r2,-12(fp)
 823b0e0:	10800417 	ldw	r2,16(r2)
 823b0e4:	1080010c 	andi	r2,r2,4
 823b0e8:	1000121e 	bne	r2,zero,823b134 <udp4_sockbind+0x1a8>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b0ec:	d0a09c17 	ldw	r2,-32144(gp)
 823b0f0:	e0bff515 	stw	r2,-44(fp)
 823b0f4:	00000d06 	br	823b12c <udp4_sockbind+0x1a0>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 823b0f8:	e0bff517 	ldw	r2,-44(fp)
 823b0fc:	1080018b 	ldhu	r2,6(r2)
 823b100:	10ffffcc 	andi	r3,r2,65535
 823b104:	e0bff60b 	ldhu	r2,-40(fp)
 823b108:	1880051e 	bne	r3,r2,823b120 <udp4_sockbind+0x194>
 823b10c:	e0fff517 	ldw	r3,-44(fp)
 823b110:	e0bffb17 	ldw	r2,-20(fp)
 823b114:	18800226 	beq	r3,r2,823b120 <udp4_sockbind+0x194>
          return(EADDRINUSE);
 823b118:	00801c04 	movi	r2,112
 823b11c:	00004b06 	br	823b24c <udp4_sockbind+0x2c0>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b120:	e0bff517 	ldw	r2,-44(fp)
 823b124:	10800017 	ldw	r2,0(r2)
 823b128:	e0bff515 	stw	r2,-44(fp)
 823b12c:	e0bff517 	ldw	r2,-44(fp)
 823b130:	103ff11e 	bne	r2,zero,823b0f8 <udp4_sockbind+0x16c>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 823b134:	e0bffb17 	ldw	r2,-20(fp)
 823b138:	e0fff60b 	ldhu	r3,-40(fp)
 823b13c:	10c0018d 	sth	r3,6(r2)
    udpconn->u_lhost = lhost;
 823b140:	e0bffb17 	ldw	r2,-20(fp)
 823b144:	e0fff817 	ldw	r3,-32(fp)
 823b148:	10c00315 	stw	r3,12(r2)
 823b14c:	00003e06 	br	823b248 <udp4_sockbind+0x2bc>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 823b150:	e0bffa17 	ldw	r2,-24(fp)
 823b154:	1080008b 	ldhu	r2,2(r2)
 823b158:	10bfffcc 	andi	r2,r2,65535
 823b15c:	1004d23a 	srli	r2,r2,8
 823b160:	1007883a 	mov	r3,r2
 823b164:	e0bffa17 	ldw	r2,-24(fp)
 823b168:	1080008b 	ldhu	r2,2(r2)
 823b16c:	10bfffcc 	andi	r2,r2,65535
 823b170:	1004923a 	slli	r2,r2,8
 823b174:	1884b03a 	or	r2,r3,r2
 823b178:	e0bffc0d 	sth	r2,-16(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b17c:	e0bffa17 	ldw	r2,-24(fp)
 823b180:	10800117 	ldw	r2,4(r2)
 823b184:	1000021e 	bne	r2,zero,823b190 <udp4_sockbind+0x204>
      fhost = 0L;
 823b188:	e03ff715 	stw	zero,-36(fp)
 823b18c:	00000306 	br	823b19c <udp4_sockbind+0x210>
    else
      fhost = sin->sin_addr.s_addr;
 823b190:	e0bffa17 	ldw	r2,-24(fp)
 823b194:	10800117 	ldw	r2,4(r2)
 823b198:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 823b19c:	e13ff717 	ldw	r4,-36(fp)
 823b1a0:	82405f00 	call	82405f0 <ip_mymach>
 823b1a4:	e0bff815 	stw	r2,-32(fp)
    if (lhost == 0)
 823b1a8:	e0bff817 	ldw	r2,-32(fp)
 823b1ac:	1000021e 	bne	r2,zero,823b1b8 <udp4_sockbind+0x22c>
      return(ENETUNREACH);
 823b1b0:	00801c84 	movi	r2,114
 823b1b4:	00002506 	br	823b24c <udp4_sockbind+0x2c0>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 823b1b8:	e0bffb17 	ldw	r2,-20(fp)
 823b1bc:	1080018b 	ldhu	r2,6(r2)
 823b1c0:	e0bff60d 	sth	r2,-40(fp)
    if (lport == 0)
 823b1c4:	e0bff60b 	ldhu	r2,-40(fp)
 823b1c8:	1000021e 	bne	r2,zero,823b1d4 <udp4_sockbind+0x248>
      lport = udp_socket();
 823b1cc:	8244f8c0 	call	8244f8c <udp_socket>
 823b1d0:	e0bff60d 	sth	r2,-40(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 823b1d4:	e0bffb17 	ldw	r2,-20(fp)
 823b1d8:	e0fff817 	ldw	r3,-32(fp)
 823b1dc:	10c00315 	stw	r3,12(r2)
    udpconn->u_lport = lport;
 823b1e0:	e0bffb17 	ldw	r2,-20(fp)
 823b1e4:	e0fff60b 	ldhu	r3,-40(fp)
 823b1e8:	10c0018d 	sth	r3,6(r2)
    udpconn->u_fhost = fhost;
 823b1ec:	e0bffb17 	ldw	r2,-20(fp)
 823b1f0:	e0fff717 	ldw	r3,-36(fp)
 823b1f4:	10c00415 	stw	r3,16(r2)
    udpconn->u_fport = fport;
 823b1f8:	e0bffb17 	ldw	r2,-20(fp)
 823b1fc:	e0fffc0b 	ldhu	r3,-16(fp)
 823b200:	10c0020d 	sth	r3,8(r2)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 823b204:	e0bffd17 	ldw	r2,-12(fp)
 823b208:	10c0088b 	ldhu	r3,34(r2)
 823b20c:	00bffcc4 	movi	r2,-13
 823b210:	1884703a 	and	r2,r3,r2
 823b214:	1007883a 	mov	r3,r2
 823b218:	e0bffd17 	ldw	r2,-12(fp)
 823b21c:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 823b220:	e0bffd17 	ldw	r2,-12(fp)
 823b224:	1080088b 	ldhu	r2,34(r2)
 823b228:	10800094 	ori	r2,r2,2
 823b22c:	1007883a 	mov	r3,r2
 823b230:	e0bffd17 	ldw	r2,-12(fp)
 823b234:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 823b238:	e0bffd17 	ldw	r2,-12(fp)
 823b23c:	10800a04 	addi	r2,r2,40
 823b240:	1009883a 	mov	r4,r2
 823b244:	823455c0 	call	823455c <sbflush>
  }
  return 0;
 823b248:	0005883a 	mov	r2,zero
}
 823b24c:	e037883a 	mov	sp,fp
 823b250:	dfc00117 	ldw	ra,4(sp)
 823b254:	df000017 	ldw	fp,0(sp)
 823b258:	dec00204 	addi	sp,sp,8
 823b25c:	f800283a 	ret

0823b260 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 823b260:	defff304 	addi	sp,sp,-52
 823b264:	dfc00c15 	stw	ra,48(sp)
 823b268:	df000b15 	stw	fp,44(sp)
 823b26c:	dc000a15 	stw	r16,40(sp)
 823b270:	df000b04 	addi	fp,sp,44
 823b274:	e13ffc15 	stw	r4,-16(fp)
 823b278:	e17ffd15 	stw	r5,-12(fp)
 823b27c:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 823b280:	e13ffc17 	ldw	r4,-16(fp)
 823b284:	823ab540 	call	823ab54 <udp_lookup>
 823b288:	e0bff815 	stw	r2,-32(fp)
  if (!udpconn)
 823b28c:	e0bff817 	ldw	r2,-32(fp)
 823b290:	1000041e 	bne	r2,zero,823b2a4 <udp4_socksend+0x44>
  {
    m_free(m);
 823b294:	e13ffd17 	ldw	r4,-12(fp)
 823b298:	822e1640 	call	822e164 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 823b29c:	00801bc4 	movi	r2,111
 823b2a0:	0000c906 	br	823b5c8 <udp4_socksend+0x368>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 823b2a4:	e0bffe17 	ldw	r2,-8(fp)
 823b2a8:	10000e1e 	bne	r2,zero,823b2e4 <udp4_socksend+0x84>
  { 
    if (so->so_state & SS_ISCONNECTED)
 823b2ac:	e0bffc17 	ldw	r2,-16(fp)
 823b2b0:	1080088b 	ldhu	r2,34(r2)
 823b2b4:	10bfffcc 	andi	r2,r2,65535
 823b2b8:	1080008c 	andi	r2,r2,2
 823b2bc:	10000726 	beq	r2,zero,823b2dc <udp4_socksend+0x7c>
    {
      fport = udpconn->u_fport;
 823b2c0:	e0bff817 	ldw	r2,-32(fp)
 823b2c4:	1080020b 	ldhu	r2,8(r2)
 823b2c8:	e0bff50d 	sth	r2,-44(fp)
      fhost = udpconn->u_fhost;
 823b2cc:	e0bff817 	ldw	r2,-32(fp)
 823b2d0:	10800417 	ldw	r2,16(r2)
 823b2d4:	e0bff615 	stw	r2,-40(fp)
 823b2d8:	00002806 	br	823b37c <udp4_socksend+0x11c>
    }
    else
      return (EINVAL);
 823b2dc:	00800584 	movi	r2,22
 823b2e0:	0000b906 	br	823b5c8 <udp4_socksend+0x368>
  }
  else if(nam->m_len != sizeof (*sin))
 823b2e4:	e0bffe17 	ldw	r2,-8(fp)
 823b2e8:	10800217 	ldw	r2,8(r2)
 823b2ec:	10800420 	cmpeqi	r2,r2,16
 823b2f0:	1000031e 	bne	r2,zero,823b300 <udp4_socksend+0xa0>
  {
    dtrap();
 823b2f4:	822d1c80 	call	822d1c8 <dtrap>
    return (EINVAL);
 823b2f8:	00800584 	movi	r2,22
 823b2fc:	0000b206 	br	823b5c8 <udp4_socksend+0x368>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 823b300:	e0bffe17 	ldw	r2,-8(fp)
 823b304:	10800317 	ldw	r2,12(r2)
 823b308:	e0bff915 	stw	r2,-28(fp)
    fhost = sin->sin_addr.s_addr;
 823b30c:	e0bff917 	ldw	r2,-28(fp)
 823b310:	10800117 	ldw	r2,4(r2)
 823b314:	e0bff615 	stw	r2,-40(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 823b318:	e0bff917 	ldw	r2,-28(fp)
 823b31c:	1080008b 	ldhu	r2,2(r2)
 823b320:	10bfffcc 	andi	r2,r2,65535
 823b324:	10000c26 	beq	r2,zero,823b358 <udp4_socksend+0xf8>
      fport = ntohs(sin->sin_port);
 823b328:	e0bff917 	ldw	r2,-28(fp)
 823b32c:	1080008b 	ldhu	r2,2(r2)
 823b330:	10bfffcc 	andi	r2,r2,65535
 823b334:	1004d23a 	srli	r2,r2,8
 823b338:	1007883a 	mov	r3,r2
 823b33c:	e0bff917 	ldw	r2,-28(fp)
 823b340:	1080008b 	ldhu	r2,2(r2)
 823b344:	10bfffcc 	andi	r2,r2,65535
 823b348:	1004923a 	slli	r2,r2,8
 823b34c:	1884b03a 	or	r2,r3,r2
 823b350:	e0bff50d 	sth	r2,-44(fp)
 823b354:	00000906 	br	823b37c <udp4_socksend+0x11c>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 823b358:	e0bff817 	ldw	r2,-32(fp)
 823b35c:	1080020b 	ldhu	r2,8(r2)
 823b360:	10bfffcc 	andi	r2,r2,65535
 823b364:	1000021e 	bne	r2,zero,823b370 <udp4_socksend+0x110>
        return (EINVAL);
 823b368:	00800584 	movi	r2,22
 823b36c:	00009606 	br	823b5c8 <udp4_socksend+0x368>
      fport = udpconn->u_fport;
 823b370:	e0bff817 	ldw	r2,-32(fp)
 823b374:	1080020b 	ldhu	r2,8(r2)
 823b378:	e0bff50d 	sth	r2,-44(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 823b37c:	e0bffd17 	ldw	r2,-12(fp)
 823b380:	14000217 	ldw	r16,8(r2)
 823b384:	82450f80 	call	82450f8 <udp_maxalloc>
 823b388:	1400032e 	bgeu	r2,r16,823b398 <udp4_socksend+0x138>
  {
    dtrap(); /* should never happen */
 823b38c:	822d1c80 	call	822d1c8 <dtrap>
    return EMSGSIZE;  /* try to recover */
 823b390:	00801e84 	movi	r2,122
 823b394:	00008c06 	br	823b5c8 <udp4_socksend+0x368>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 823b398:	e0bffd17 	ldw	r2,-12(fp)
 823b39c:	10800217 	ldw	r2,8(r2)
 823b3a0:	000b883a 	mov	r5,zero
 823b3a4:	1009883a 	mov	r4,r2
 823b3a8:	824503c0 	call	824503c <udp_alloc>
 823b3ac:	e0bffa15 	stw	r2,-24(fp)
  if (!pkt)
 823b3b0:	e0bffa17 	ldw	r2,-24(fp)
 823b3b4:	1000041e 	bne	r2,zero,823b3c8 <udp4_socksend+0x168>
  {
    m_free(m);
 823b3b8:	e13ffd17 	ldw	r4,-12(fp)
 823b3bc:	822e1640 	call	822e164 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 823b3c0:	00801a44 	movi	r2,105
 823b3c4:	00008006 	br	823b5c8 <udp4_socksend+0x368>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 823b3c8:	e0bffa17 	ldw	r2,-24(fp)
 823b3cc:	10c00317 	ldw	r3,12(r2)
 823b3d0:	e0bffd17 	ldw	r2,-12(fp)
 823b3d4:	11000317 	ldw	r4,12(r2)
 823b3d8:	e0bffd17 	ldw	r2,-12(fp)
 823b3dc:	10800217 	ldw	r2,8(r2)
 823b3e0:	100d883a 	mov	r6,r2
 823b3e4:	200b883a 	mov	r5,r4
 823b3e8:	1809883a 	mov	r4,r3
 823b3ec:	8202a0c0 	call	8202a0c <memcpy>
  pkt->nb_plen = m->m_len;
 823b3f0:	e0bffd17 	ldw	r2,-12(fp)
 823b3f4:	10c00217 	ldw	r3,8(r2)
 823b3f8:	e0bffa17 	ldw	r2,-24(fp)
 823b3fc:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 823b400:	e13ffd17 	ldw	r4,-12(fp)
 823b404:	822e1640 	call	822e164 <m_free>
  pkt->fhost = fhost;
 823b408:	e0bffa17 	ldw	r2,-24(fp)
 823b40c:	e0fff617 	ldw	r3,-40(fp)
 823b410:	10c00715 	stw	r3,28(r2)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 823b414:	e0bff617 	ldw	r2,-40(fp)
 823b418:	10bfffd8 	cmpnei	r2,r2,-1
 823b41c:	10004a1e 	bne	r2,zero,823b548 <udp4_socksend+0x2e8>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 823b420:	e0bff817 	ldw	r2,-32(fp)
 823b424:	10800317 	ldw	r2,12(r2)
 823b428:	10001026 	beq	r2,zero,823b46c <udp4_socksend+0x20c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b42c:	008209b4 	movhi	r2,2086
 823b430:	10b8f304 	addi	r2,r2,-7220
 823b434:	10800017 	ldw	r2,0(r2)
 823b438:	e0bff715 	stw	r2,-36(fp)
 823b43c:	00000806 	br	823b460 <udp4_socksend+0x200>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 823b440:	e0bff717 	ldw	r2,-36(fp)
 823b444:	10c00a17 	ldw	r3,40(r2)
 823b448:	e0bff817 	ldw	r2,-32(fp)
 823b44c:	10800317 	ldw	r2,12(r2)
 823b450:	18801d26 	beq	r3,r2,823b4c8 <udp4_socksend+0x268>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b454:	e0bff717 	ldw	r2,-36(fp)
 823b458:	10800017 	ldw	r2,0(r2)
 823b45c:	e0bff715 	stw	r2,-36(fp)
 823b460:	e0bff717 	ldw	r2,-36(fp)
 823b464:	103ff61e 	bne	r2,zero,823b440 <udp4_socksend+0x1e0>
 823b468:	00001a06 	br	823b4d4 <udp4_socksend+0x274>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b46c:	008209b4 	movhi	r2,2086
 823b470:	10b8f304 	addi	r2,r2,-7220
 823b474:	10800017 	ldw	r2,0(r2)
 823b478:	e0bff715 	stw	r2,-36(fp)
 823b47c:	00000f06 	br	823b4bc <udp4_socksend+0x25c>
        if ((ifp->n_flags & NF_BCAST) &&
 823b480:	e0bff717 	ldw	r2,-36(fp)
 823b484:	10802a17 	ldw	r2,168(r2)
 823b488:	1080004c 	andi	r2,r2,1
 823b48c:	10000826 	beq	r2,zero,823b4b0 <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b490:	e0bff717 	ldw	r2,-36(fp)
 823b494:	10802717 	ldw	r2,156(r2)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
 823b498:	10000526 	beq	r2,zero,823b4b0 <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b49c:	e0bff717 	ldw	r2,-36(fp)
 823b4a0:	10802717 	ldw	r2,156(r2)
 823b4a4:	10800617 	ldw	r2,24(r2)
 823b4a8:	10800058 	cmpnei	r2,r2,1
 823b4ac:	10000826 	beq	r2,zero,823b4d0 <udp4_socksend+0x270>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b4b0:	e0bff717 	ldw	r2,-36(fp)
 823b4b4:	10800017 	ldw	r2,0(r2)
 823b4b8:	e0bff715 	stw	r2,-36(fp)
 823b4bc:	e0bff717 	ldw	r2,-36(fp)
 823b4c0:	103fef1e 	bne	r2,zero,823b480 <udp4_socksend+0x220>
 823b4c4:	00000306 	br	823b4d4 <udp4_socksend+0x274>
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
 823b4c8:	0001883a 	nop
 823b4cc:	00000106 	br	823b4d4 <udp4_socksend+0x274>
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
 823b4d0:	0001883a 	nop
    }
    if (ifp == NULL)
 823b4d4:	e0bff717 	ldw	r2,-36(fp)
 823b4d8:	1000181e 	bne	r2,zero,823b53c <udp4_socksend+0x2dc>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b4dc:	008209b4 	movhi	r2,2086
 823b4e0:	10b8f304 	addi	r2,r2,-7220
 823b4e4:	10800017 	ldw	r2,0(r2)
 823b4e8:	e0bff715 	stw	r2,-36(fp)
 823b4ec:	00000b06 	br	823b51c <udp4_socksend+0x2bc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b4f0:	e0bff717 	ldw	r2,-36(fp)
 823b4f4:	10802717 	ldw	r2,156(r2)
 823b4f8:	10000526 	beq	r2,zero,823b510 <udp4_socksend+0x2b0>
 823b4fc:	e0bff717 	ldw	r2,-36(fp)
 823b500:	10802717 	ldw	r2,156(r2)
 823b504:	10800617 	ldw	r2,24(r2)
 823b508:	10800058 	cmpnei	r2,r2,1
 823b50c:	10000626 	beq	r2,zero,823b528 <udp4_socksend+0x2c8>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b510:	e0bff717 	ldw	r2,-36(fp)
 823b514:	10800017 	ldw	r2,0(r2)
 823b518:	e0bff715 	stw	r2,-36(fp)
 823b51c:	e0bff717 	ldw	r2,-36(fp)
 823b520:	103ff31e 	bne	r2,zero,823b4f0 <udp4_socksend+0x290>
 823b524:	00000106 	br	823b52c <udp4_socksend+0x2cc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
 823b528:	0001883a 	nop
      if (ifp == NULL)
 823b52c:	e0bff717 	ldw	r2,-36(fp)
 823b530:	1000021e 	bne	r2,zero,823b53c <udp4_socksend+0x2dc>
        return(EADDRNOTAVAIL);
 823b534:	00801f44 	movi	r2,125
 823b538:	00002306 	br	823b5c8 <udp4_socksend+0x368>
    }
    pkt->net = ifp;
 823b53c:	e0bffa17 	ldw	r2,-24(fp)
 823b540:	e0fff717 	ldw	r3,-36(fp)
 823b544:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 823b548:	e0bffc17 	ldw	r2,-16(fp)
 823b54c:	10800317 	ldw	r2,12(r2)
 823b550:	10000426 	beq	r2,zero,823b564 <udp4_socksend+0x304>
     pkt->imo = so->inp_moptions;
 823b554:	e0bffc17 	ldw	r2,-16(fp)
 823b558:	10c00317 	ldw	r3,12(r2)
 823b55c:	e0bffa17 	ldw	r2,-24(fp)
 823b560:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 823b564:	e0bffc17 	ldw	r2,-16(fp)
 823b568:	10801f17 	ldw	r2,124(r2)
 823b56c:	10000426 	beq	r2,zero,823b580 <udp4_socksend+0x320>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 823b570:	e0bffc17 	ldw	r2,-16(fp)
 823b574:	10c01f17 	ldw	r3,124(r2)
 823b578:	e0bffa17 	ldw	r2,-24(fp)
 823b57c:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 823b580:	0009883a 	mov	r4,zero
 823b584:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 823b588:	e0fff50b 	ldhu	r3,-44(fp)
 823b58c:	e0bff817 	ldw	r2,-32(fp)
 823b590:	1080018b 	ldhu	r2,6(r2)
 823b594:	10bfffcc 	andi	r2,r2,65535
 823b598:	e1bffa17 	ldw	r6,-24(fp)
 823b59c:	100b883a 	mov	r5,r2
 823b5a0:	1809883a 	mov	r4,r3
 823b5a4:	8244c000 	call	8244c00 <udp_send>
 823b5a8:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 823b5ac:	0009883a 	mov	r4,zero
 823b5b0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
  if (e < 0) 
 823b5b4:	e0bffb17 	ldw	r2,-20(fp)
 823b5b8:	1000020e 	bge	r2,zero,823b5c4 <udp4_socksend+0x364>
     return(e);
 823b5bc:	e0bffb17 	ldw	r2,-20(fp)
 823b5c0:	00000106 	br	823b5c8 <udp4_socksend+0x368>
  return 0;
 823b5c4:	0005883a 	mov	r2,zero
}
 823b5c8:	e6ffff04 	addi	sp,fp,-4
 823b5cc:	dfc00217 	ldw	ra,8(sp)
 823b5d0:	df000117 	ldw	fp,4(sp)
 823b5d4:	dc000017 	ldw	r16,0(sp)
 823b5d8:	dec00304 	addi	sp,sp,12
 823b5dc:	f800283a 	ret

0823b5e0 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 823b5e0:	defff904 	addi	sp,sp,-28
 823b5e4:	dfc00615 	stw	ra,24(sp)
 823b5e8:	df000515 	stw	fp,20(sp)
 823b5ec:	df000504 	addi	fp,sp,20
 823b5f0:	e13ffd15 	stw	r4,-12(fp)
 823b5f4:	e17ffe15 	stw	r5,-8(fp)
 823b5f8:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 823b5fc:	e0bffe17 	ldw	r2,-8(fp)
 823b600:	10800317 	ldw	r2,12(r2)
 823b604:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 823b608:	e0bffb17 	ldw	r2,-20(fp)
 823b60c:	1000021e 	bne	r2,zero,823b618 <udp4_sockaddr+0x38>
     return(EINVAL);
 823b610:	00800584 	movi	r2,22
 823b614:	00003706 	br	823b6f4 <udp4_sockaddr+0x114>
  udpconn = udp_lookup(so);
 823b618:	e13ffd17 	ldw	r4,-12(fp)
 823b61c:	823ab540 	call	823ab54 <udp_lookup>
 823b620:	e0bffc15 	stw	r2,-16(fp)
  if (!udpconn)
 823b624:	e0bffc17 	ldw	r2,-16(fp)
 823b628:	1000021e 	bne	r2,zero,823b634 <udp4_sockaddr+0x54>
     return(EINVAL);
 823b62c:	00800584 	movi	r2,22
 823b630:	00003006 	br	823b6f4 <udp4_sockaddr+0x114>
  nam->m_len = sizeof(*sin);
 823b634:	e0bffe17 	ldw	r2,-8(fp)
 823b638:	00c00404 	movi	r3,16
 823b63c:	10c00215 	stw	r3,8(r2)
  if (req == PRU_SOCKADDR)
 823b640:	e0bfff17 	ldw	r2,-4(fp)
 823b644:	108003d8 	cmpnei	r2,r2,15
 823b648:	1000151e 	bne	r2,zero,823b6a0 <udp4_sockaddr+0xc0>
  {
     sin->sin_family = AF_INET;
 823b64c:	e0bffb17 	ldw	r2,-20(fp)
 823b650:	00c00084 	movi	r3,2
 823b654:	10c0000d 	sth	r3,0(r2)
     sin->sin_port = htons(udpconn->u_lport);
 823b658:	e0bffc17 	ldw	r2,-16(fp)
 823b65c:	1080018b 	ldhu	r2,6(r2)
 823b660:	10bfffcc 	andi	r2,r2,65535
 823b664:	1004d23a 	srli	r2,r2,8
 823b668:	1007883a 	mov	r3,r2
 823b66c:	e0bffc17 	ldw	r2,-16(fp)
 823b670:	1080018b 	ldhu	r2,6(r2)
 823b674:	10bfffcc 	andi	r2,r2,65535
 823b678:	1004923a 	slli	r2,r2,8
 823b67c:	1884b03a 	or	r2,r3,r2
 823b680:	1007883a 	mov	r3,r2
 823b684:	e0bffb17 	ldw	r2,-20(fp)
 823b688:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 823b68c:	e0bffc17 	ldw	r2,-16(fp)
 823b690:	10c00317 	ldw	r3,12(r2)
 823b694:	e0bffb17 	ldw	r2,-20(fp)
 823b698:	10c00115 	stw	r3,4(r2)
 823b69c:	00001406 	br	823b6f0 <udp4_sockaddr+0x110>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 823b6a0:	e0bffb17 	ldw	r2,-20(fp)
 823b6a4:	00c00084 	movi	r3,2
 823b6a8:	10c0000d 	sth	r3,0(r2)
    sin->sin_port = htons(udpconn->u_fport);
 823b6ac:	e0bffc17 	ldw	r2,-16(fp)
 823b6b0:	1080020b 	ldhu	r2,8(r2)
 823b6b4:	10bfffcc 	andi	r2,r2,65535
 823b6b8:	1004d23a 	srli	r2,r2,8
 823b6bc:	1007883a 	mov	r3,r2
 823b6c0:	e0bffc17 	ldw	r2,-16(fp)
 823b6c4:	1080020b 	ldhu	r2,8(r2)
 823b6c8:	10bfffcc 	andi	r2,r2,65535
 823b6cc:	1004923a 	slli	r2,r2,8
 823b6d0:	1884b03a 	or	r2,r3,r2
 823b6d4:	1007883a 	mov	r3,r2
 823b6d8:	e0bffb17 	ldw	r2,-20(fp)
 823b6dc:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 823b6e0:	e0bffc17 	ldw	r2,-16(fp)
 823b6e4:	10c00417 	ldw	r3,16(r2)
 823b6e8:	e0bffb17 	ldw	r2,-20(fp)
 823b6ec:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 823b6f0:	0005883a 	mov	r2,zero
}
 823b6f4:	e037883a 	mov	sp,fp
 823b6f8:	dfc00117 	ldw	ra,4(sp)
 823b6fc:	df000017 	ldw	fp,0(sp)
 823b700:	dec00204 	addi	sp,sp,8
 823b704:	f800283a 	ret

0823b708 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 823b708:	defff504 	addi	sp,sp,-44
 823b70c:	df000a15 	stw	fp,40(sp)
 823b710:	df000a04 	addi	fp,sp,40
 823b714:	e13ffc15 	stw	r4,-16(fp)
 823b718:	e17ffd15 	stw	r5,-12(fp)
 823b71c:	e1bffe15 	stw	r6,-8(fp)
 823b720:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 823b724:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823b728:	d0a0b817 	ldw	r2,-32032(gp)
  
  if (alt_ticks_per_second ())
 823b72c:	10003c26 	beq	r2,zero,823b820 <alt_alarm_start+0x118>
  {
    if (alarm)
 823b730:	e0bffc17 	ldw	r2,-16(fp)
 823b734:	10003826 	beq	r2,zero,823b818 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 823b738:	e0bffc17 	ldw	r2,-16(fp)
 823b73c:	e0fffe17 	ldw	r3,-8(fp)
 823b740:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 823b744:	e0bffc17 	ldw	r2,-16(fp)
 823b748:	e0ffff17 	ldw	r3,-4(fp)
 823b74c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823b750:	0005303a 	rdctl	r2,status
 823b754:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823b758:	e0fff917 	ldw	r3,-28(fp)
 823b75c:	00bfff84 	movi	r2,-2
 823b760:	1884703a 	and	r2,r3,r2
 823b764:	1001703a 	wrctl	status,r2
  
  return context;
 823b768:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 823b76c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 823b770:	d0a0b917 	ldw	r2,-32028(gp)
      
      current_nticks = alt_nticks();
 823b774:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 823b778:	e0fffd17 	ldw	r3,-12(fp)
 823b77c:	e0bff617 	ldw	r2,-40(fp)
 823b780:	1885883a 	add	r2,r3,r2
 823b784:	10c00044 	addi	r3,r2,1
 823b788:	e0bffc17 	ldw	r2,-16(fp)
 823b78c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 823b790:	e0bffc17 	ldw	r2,-16(fp)
 823b794:	10c00217 	ldw	r3,8(r2)
 823b798:	e0bff617 	ldw	r2,-40(fp)
 823b79c:	1880042e 	bgeu	r3,r2,823b7b0 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 823b7a0:	e0bffc17 	ldw	r2,-16(fp)
 823b7a4:	00c00044 	movi	r3,1
 823b7a8:	10c00405 	stb	r3,16(r2)
 823b7ac:	00000206 	br	823b7b8 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 823b7b0:	e0bffc17 	ldw	r2,-16(fp)
 823b7b4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 823b7b8:	e0bffc17 	ldw	r2,-16(fp)
 823b7bc:	d0e04904 	addi	r3,gp,-32476
 823b7c0:	e0fffa15 	stw	r3,-24(fp)
 823b7c4:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823b7c8:	e0bffb17 	ldw	r2,-20(fp)
 823b7cc:	e0fffa17 	ldw	r3,-24(fp)
 823b7d0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823b7d4:	e0bffa17 	ldw	r2,-24(fp)
 823b7d8:	10c00017 	ldw	r3,0(r2)
 823b7dc:	e0bffb17 	ldw	r2,-20(fp)
 823b7e0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823b7e4:	e0bffa17 	ldw	r2,-24(fp)
 823b7e8:	10800017 	ldw	r2,0(r2)
 823b7ec:	e0fffb17 	ldw	r3,-20(fp)
 823b7f0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823b7f4:	e0bffa17 	ldw	r2,-24(fp)
 823b7f8:	e0fffb17 	ldw	r3,-20(fp)
 823b7fc:	10c00015 	stw	r3,0(r2)
 823b800:	e0bff817 	ldw	r2,-32(fp)
 823b804:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823b808:	e0bff717 	ldw	r2,-36(fp)
 823b80c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 823b810:	0005883a 	mov	r2,zero
 823b814:	00000306 	br	823b824 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 823b818:	00bffa84 	movi	r2,-22
 823b81c:	00000106 	br	823b824 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 823b820:	00bfde84 	movi	r2,-134
  }
}
 823b824:	e037883a 	mov	sp,fp
 823b828:	df000017 	ldw	fp,0(sp)
 823b82c:	dec00104 	addi	sp,sp,4
 823b830:	f800283a 	ret

0823b834 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 823b834:	defffa04 	addi	sp,sp,-24
 823b838:	dfc00515 	stw	ra,20(sp)
 823b83c:	df000415 	stw	fp,16(sp)
 823b840:	df000404 	addi	fp,sp,16
 823b844:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 823b848:	008000c4 	movi	r2,3
 823b84c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 823b850:	e0fffd17 	ldw	r3,-12(fp)
 823b854:	008003f4 	movhi	r2,15
 823b858:	10909004 	addi	r2,r2,16960
 823b85c:	1885383a 	mul	r2,r3,r2
 823b860:	100b883a 	mov	r5,r2
 823b864:	0100bef4 	movhi	r4,763
 823b868:	213c2004 	addi	r4,r4,-3968
 823b86c:	820270c0 	call	820270c <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 823b870:	100b883a 	mov	r5,r2
 823b874:	01200034 	movhi	r4,32768
 823b878:	213fffc4 	addi	r4,r4,-1
 823b87c:	820270c0 	call	820270c <__udivsi3>
 823b880:	100b883a 	mov	r5,r2
 823b884:	e13fff17 	ldw	r4,-4(fp)
 823b888:	820270c0 	call	820270c <__udivsi3>
 823b88c:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 823b890:	e0bffe17 	ldw	r2,-8(fp)
 823b894:	10002a26 	beq	r2,zero,823b940 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 823b898:	e03ffc15 	stw	zero,-16(fp)
 823b89c:	00001706 	br	823b8fc <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 823b8a0:	00a00034 	movhi	r2,32768
 823b8a4:	10bfffc4 	addi	r2,r2,-1
 823b8a8:	10bfffc4 	addi	r2,r2,-1
 823b8ac:	103ffe1e 	bne	r2,zero,823b8a8 <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 823b8b0:	e0fffd17 	ldw	r3,-12(fp)
 823b8b4:	008003f4 	movhi	r2,15
 823b8b8:	10909004 	addi	r2,r2,16960
 823b8bc:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 823b8c0:	100b883a 	mov	r5,r2
 823b8c4:	0100bef4 	movhi	r4,763
 823b8c8:	213c2004 	addi	r4,r4,-3968
 823b8cc:	820270c0 	call	820270c <__udivsi3>
 823b8d0:	100b883a 	mov	r5,r2
 823b8d4:	01200034 	movhi	r4,32768
 823b8d8:	213fffc4 	addi	r4,r4,-1
 823b8dc:	820270c0 	call	820270c <__udivsi3>
 823b8e0:	1007883a 	mov	r3,r2
 823b8e4:	e0bfff17 	ldw	r2,-4(fp)
 823b8e8:	10c5c83a 	sub	r2,r2,r3
 823b8ec:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 823b8f0:	e0bffc17 	ldw	r2,-16(fp)
 823b8f4:	10800044 	addi	r2,r2,1
 823b8f8:	e0bffc15 	stw	r2,-16(fp)
 823b8fc:	e0fffc17 	ldw	r3,-16(fp)
 823b900:	e0bffe17 	ldw	r2,-8(fp)
 823b904:	18bfe616 	blt	r3,r2,823b8a0 <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 823b908:	e0fffd17 	ldw	r3,-12(fp)
 823b90c:	008003f4 	movhi	r2,15
 823b910:	10909004 	addi	r2,r2,16960
 823b914:	1885383a 	mul	r2,r3,r2
 823b918:	100b883a 	mov	r5,r2
 823b91c:	0100bef4 	movhi	r4,763
 823b920:	213c2004 	addi	r4,r4,-3968
 823b924:	820270c0 	call	820270c <__udivsi3>
 823b928:	1007883a 	mov	r3,r2
 823b92c:	e0bfff17 	ldw	r2,-4(fp)
 823b930:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 823b934:	10bfffc4 	addi	r2,r2,-1
 823b938:	103ffe1e 	bne	r2,zero,823b934 <alt_busy_sleep+0x100>
 823b93c:	00000d06 	br	823b974 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 823b940:	e0fffd17 	ldw	r3,-12(fp)
 823b944:	008003f4 	movhi	r2,15
 823b948:	10909004 	addi	r2,r2,16960
 823b94c:	1885383a 	mul	r2,r3,r2
 823b950:	100b883a 	mov	r5,r2
 823b954:	0100bef4 	movhi	r4,763
 823b958:	213c2004 	addi	r4,r4,-3968
 823b95c:	820270c0 	call	820270c <__udivsi3>
 823b960:	1007883a 	mov	r3,r2
 823b964:	e0bfff17 	ldw	r2,-4(fp)
 823b968:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 823b96c:	10bfffc4 	addi	r2,r2,-1
 823b970:	00bffe16 	blt	zero,r2,823b96c <alt_busy_sleep+0x138>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 823b974:	0005883a 	mov	r2,zero
}
 823b978:	e037883a 	mov	sp,fp
 823b97c:	dfc00117 	ldw	ra,4(sp)
 823b980:	df000017 	ldw	fp,0(sp)
 823b984:	dec00204 	addi	sp,sp,8
 823b988:	f800283a 	ret

0823b98c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823b98c:	defffe04 	addi	sp,sp,-8
 823b990:	dfc00115 	stw	ra,4(sp)
 823b994:	df000015 	stw	fp,0(sp)
 823b998:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823b99c:	d0a04717 	ldw	r2,-32484(gp)
 823b9a0:	10000326 	beq	r2,zero,823b9b0 <alt_get_errno+0x24>
 823b9a4:	d0a04717 	ldw	r2,-32484(gp)
 823b9a8:	103ee83a 	callr	r2
 823b9ac:	00000106 	br	823b9b4 <alt_get_errno+0x28>
 823b9b0:	d0a06304 	addi	r2,gp,-32372
}
 823b9b4:	e037883a 	mov	sp,fp
 823b9b8:	dfc00117 	ldw	ra,4(sp)
 823b9bc:	df000017 	ldw	fp,0(sp)
 823b9c0:	dec00204 	addi	sp,sp,8
 823b9c4:	f800283a 	ret

0823b9c8 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 823b9c8:	defffb04 	addi	sp,sp,-20
 823b9cc:	dfc00415 	stw	ra,16(sp)
 823b9d0:	df000315 	stw	fp,12(sp)
 823b9d4:	df000304 	addi	fp,sp,12
 823b9d8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 823b9dc:	e0bfff17 	ldw	r2,-4(fp)
 823b9e0:	10000616 	blt	r2,zero,823b9fc <alt_close+0x34>
 823b9e4:	e0bfff17 	ldw	r2,-4(fp)
 823b9e8:	10c00324 	muli	r3,r2,12
 823b9ec:	00820974 	movhi	r2,2085
 823b9f0:	108d6a04 	addi	r2,r2,13736
 823b9f4:	1885883a 	add	r2,r3,r2
 823b9f8:	00000106 	br	823ba00 <alt_close+0x38>
 823b9fc:	0005883a 	mov	r2,zero
 823ba00:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 823ba04:	e0bffd17 	ldw	r2,-12(fp)
 823ba08:	10001926 	beq	r2,zero,823ba70 <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 823ba0c:	e0bffd17 	ldw	r2,-12(fp)
 823ba10:	10800017 	ldw	r2,0(r2)
 823ba14:	10800417 	ldw	r2,16(r2)
 823ba18:	10000626 	beq	r2,zero,823ba34 <alt_close+0x6c>
 823ba1c:	e0bffd17 	ldw	r2,-12(fp)
 823ba20:	10800017 	ldw	r2,0(r2)
 823ba24:	10800417 	ldw	r2,16(r2)
 823ba28:	e13ffd17 	ldw	r4,-12(fp)
 823ba2c:	103ee83a 	callr	r2
 823ba30:	00000106 	br	823ba38 <alt_close+0x70>
 823ba34:	0005883a 	mov	r2,zero
 823ba38:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 823ba3c:	e13fff17 	ldw	r4,-4(fp)
 823ba40:	823c4d80 	call	823c4d8 <alt_release_fd>
    if (rval < 0)
 823ba44:	e0bffe17 	ldw	r2,-8(fp)
 823ba48:	1000070e 	bge	r2,zero,823ba68 <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 823ba4c:	823b98c0 	call	823b98c <alt_get_errno>
 823ba50:	1007883a 	mov	r3,r2
 823ba54:	e0bffe17 	ldw	r2,-8(fp)
 823ba58:	0085c83a 	sub	r2,zero,r2
 823ba5c:	18800015 	stw	r2,0(r3)
      return -1;
 823ba60:	00bfffc4 	movi	r2,-1
 823ba64:	00000706 	br	823ba84 <alt_close+0xbc>
    }
    return 0;
 823ba68:	0005883a 	mov	r2,zero
 823ba6c:	00000506 	br	823ba84 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 823ba70:	823b98c0 	call	823b98c <alt_get_errno>
 823ba74:	1007883a 	mov	r3,r2
 823ba78:	00801444 	movi	r2,81
 823ba7c:	18800015 	stw	r2,0(r3)
    return -1;
 823ba80:	00bfffc4 	movi	r2,-1
  }
}
 823ba84:	e037883a 	mov	sp,fp
 823ba88:	dfc00117 	ldw	ra,4(sp)
 823ba8c:	df000017 	ldw	fp,0(sp)
 823ba90:	dec00204 	addi	sp,sp,8
 823ba94:	f800283a 	ret

0823ba98 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 823ba98:	defffb04 	addi	sp,sp,-20
 823ba9c:	df000415 	stw	fp,16(sp)
 823baa0:	df000404 	addi	fp,sp,16
 823baa4:	e13ffe15 	stw	r4,-8(fp)
 823baa8:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 823baac:	e0fffe17 	ldw	r3,-8(fp)
 823bab0:	e0bfff17 	ldw	r2,-4(fp)
 823bab4:	1885883a 	add	r2,r3,r2
 823bab8:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823babc:	e0bffe17 	ldw	r2,-8(fp)
 823bac0:	e0bffc15 	stw	r2,-16(fp)
 823bac4:	00000506 	br	823badc <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 823bac8:	e0bffc17 	ldw	r2,-16(fp)
 823bacc:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bad0:	e0bffc17 	ldw	r2,-16(fp)
 823bad4:	10800804 	addi	r2,r2,32
 823bad8:	e0bffc15 	stw	r2,-16(fp)
 823badc:	e0fffc17 	ldw	r3,-16(fp)
 823bae0:	e0bffd17 	ldw	r2,-12(fp)
 823bae4:	18bff836 	bltu	r3,r2,823bac8 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 823bae8:	e0bffe17 	ldw	r2,-8(fp)
 823baec:	108007cc 	andi	r2,r2,31
 823baf0:	10000226 	beq	r2,zero,823bafc <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 823baf4:	e0bffc17 	ldw	r2,-16(fp)
 823baf8:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 823bafc:	0001883a 	nop
 823bb00:	e037883a 	mov	sp,fp
 823bb04:	df000017 	ldw	fp,0(sp)
 823bb08:	dec00104 	addi	sp,sp,4
 823bb0c:	f800283a 	ret

0823bb10 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 823bb10:	defffc04 	addi	sp,sp,-16
 823bb14:	df000315 	stw	fp,12(sp)
 823bb18:	df000304 	addi	fp,sp,12
 823bb1c:	e13ffd15 	stw	r4,-12(fp)
 823bb20:	e17ffe15 	stw	r5,-8(fp)
 823bb24:	e1bfff15 	stw	r6,-4(fp)
  return len;
 823bb28:	e0bfff17 	ldw	r2,-4(fp)
}
 823bb2c:	e037883a 	mov	sp,fp
 823bb30:	df000017 	ldw	fp,0(sp)
 823bb34:	dec00104 	addi	sp,sp,4
 823bb38:	f800283a 	ret

0823bb3c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823bb3c:	defffe04 	addi	sp,sp,-8
 823bb40:	dfc00115 	stw	ra,4(sp)
 823bb44:	df000015 	stw	fp,0(sp)
 823bb48:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823bb4c:	d0a04717 	ldw	r2,-32484(gp)
 823bb50:	10000326 	beq	r2,zero,823bb60 <alt_get_errno+0x24>
 823bb54:	d0a04717 	ldw	r2,-32484(gp)
 823bb58:	103ee83a 	callr	r2
 823bb5c:	00000106 	br	823bb64 <alt_get_errno+0x28>
 823bb60:	d0a06304 	addi	r2,gp,-32372
}
 823bb64:	e037883a 	mov	sp,fp
 823bb68:	dfc00117 	ldw	ra,4(sp)
 823bb6c:	df000017 	ldw	fp,0(sp)
 823bb70:	dec00204 	addi	sp,sp,8
 823bb74:	f800283a 	ret

0823bb78 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 823bb78:	defffa04 	addi	sp,sp,-24
 823bb7c:	dfc00515 	stw	ra,20(sp)
 823bb80:	df000415 	stw	fp,16(sp)
 823bb84:	df000404 	addi	fp,sp,16
 823bb88:	e13ffe15 	stw	r4,-8(fp)
 823bb8c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 823bb90:	e0bffe17 	ldw	r2,-8(fp)
 823bb94:	10000326 	beq	r2,zero,823bba4 <alt_dev_llist_insert+0x2c>
 823bb98:	e0bffe17 	ldw	r2,-8(fp)
 823bb9c:	10800217 	ldw	r2,8(r2)
 823bba0:	1000061e 	bne	r2,zero,823bbbc <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 823bba4:	823bb3c0 	call	823bb3c <alt_get_errno>
 823bba8:	1007883a 	mov	r3,r2
 823bbac:	00800584 	movi	r2,22
 823bbb0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 823bbb4:	00bffa84 	movi	r2,-22
 823bbb8:	00001306 	br	823bc08 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 823bbbc:	e0bffe17 	ldw	r2,-8(fp)
 823bbc0:	e0ffff17 	ldw	r3,-4(fp)
 823bbc4:	e0fffc15 	stw	r3,-16(fp)
 823bbc8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823bbcc:	e0bffd17 	ldw	r2,-12(fp)
 823bbd0:	e0fffc17 	ldw	r3,-16(fp)
 823bbd4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823bbd8:	e0bffc17 	ldw	r2,-16(fp)
 823bbdc:	10c00017 	ldw	r3,0(r2)
 823bbe0:	e0bffd17 	ldw	r2,-12(fp)
 823bbe4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823bbe8:	e0bffc17 	ldw	r2,-16(fp)
 823bbec:	10800017 	ldw	r2,0(r2)
 823bbf0:	e0fffd17 	ldw	r3,-12(fp)
 823bbf4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823bbf8:	e0bffc17 	ldw	r2,-16(fp)
 823bbfc:	e0fffd17 	ldw	r3,-12(fp)
 823bc00:	10c00015 	stw	r3,0(r2)

  return 0;  
 823bc04:	0005883a 	mov	r2,zero
}
 823bc08:	e037883a 	mov	sp,fp
 823bc0c:	dfc00117 	ldw	ra,4(sp)
 823bc10:	df000017 	ldw	fp,0(sp)
 823bc14:	dec00204 	addi	sp,sp,8
 823bc18:	f800283a 	ret

0823bc1c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 823bc1c:	defffd04 	addi	sp,sp,-12
 823bc20:	dfc00215 	stw	ra,8(sp)
 823bc24:	df000115 	stw	fp,4(sp)
 823bc28:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bc2c:	00820974 	movhi	r2,2085
 823bc30:	10ae7304 	addi	r2,r2,-17972
 823bc34:	e0bfff15 	stw	r2,-4(fp)
 823bc38:	00000606 	br	823bc54 <_do_ctors+0x38>
        (*ctor) (); 
 823bc3c:	e0bfff17 	ldw	r2,-4(fp)
 823bc40:	10800017 	ldw	r2,0(r2)
 823bc44:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bc48:	e0bfff17 	ldw	r2,-4(fp)
 823bc4c:	10bfff04 	addi	r2,r2,-4
 823bc50:	e0bfff15 	stw	r2,-4(fp)
 823bc54:	e0ffff17 	ldw	r3,-4(fp)
 823bc58:	00820974 	movhi	r2,2085
 823bc5c:	10ae7404 	addi	r2,r2,-17968
 823bc60:	18bff62e 	bgeu	r3,r2,823bc3c <_do_ctors+0x20>
        (*ctor) (); 
}
 823bc64:	0001883a 	nop
 823bc68:	e037883a 	mov	sp,fp
 823bc6c:	dfc00117 	ldw	ra,4(sp)
 823bc70:	df000017 	ldw	fp,0(sp)
 823bc74:	dec00204 	addi	sp,sp,8
 823bc78:	f800283a 	ret

0823bc7c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 823bc7c:	defffd04 	addi	sp,sp,-12
 823bc80:	dfc00215 	stw	ra,8(sp)
 823bc84:	df000115 	stw	fp,4(sp)
 823bc88:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bc8c:	00820974 	movhi	r2,2085
 823bc90:	10ae7304 	addi	r2,r2,-17972
 823bc94:	e0bfff15 	stw	r2,-4(fp)
 823bc98:	00000606 	br	823bcb4 <_do_dtors+0x38>
        (*dtor) (); 
 823bc9c:	e0bfff17 	ldw	r2,-4(fp)
 823bca0:	10800017 	ldw	r2,0(r2)
 823bca4:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bca8:	e0bfff17 	ldw	r2,-4(fp)
 823bcac:	10bfff04 	addi	r2,r2,-4
 823bcb0:	e0bfff15 	stw	r2,-4(fp)
 823bcb4:	e0ffff17 	ldw	r3,-4(fp)
 823bcb8:	00820974 	movhi	r2,2085
 823bcbc:	10ae7404 	addi	r2,r2,-17968
 823bcc0:	18bff62e 	bgeu	r3,r2,823bc9c <_do_dtors+0x20>
        (*dtor) (); 
}
 823bcc4:	0001883a 	nop
 823bcc8:	e037883a 	mov	sp,fp
 823bccc:	dfc00117 	ldw	ra,4(sp)
 823bcd0:	df000017 	ldw	fp,0(sp)
 823bcd4:	dec00204 	addi	sp,sp,8
 823bcd8:	f800283a 	ret

0823bcdc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 823bcdc:	defffa04 	addi	sp,sp,-24
 823bce0:	dfc00515 	stw	ra,20(sp)
 823bce4:	df000415 	stw	fp,16(sp)
 823bce8:	df000404 	addi	fp,sp,16
 823bcec:	e13ffe15 	stw	r4,-8(fp)
 823bcf0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 823bcf4:	e0bfff17 	ldw	r2,-4(fp)
 823bcf8:	10800017 	ldw	r2,0(r2)
 823bcfc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 823bd00:	e13ffe17 	ldw	r4,-8(fp)
 823bd04:	8203a5c0 	call	8203a5c <strlen>
 823bd08:	10800044 	addi	r2,r2,1
 823bd0c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bd10:	00000d06 	br	823bd48 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 823bd14:	e0bffc17 	ldw	r2,-16(fp)
 823bd18:	10800217 	ldw	r2,8(r2)
 823bd1c:	e0fffd17 	ldw	r3,-12(fp)
 823bd20:	180d883a 	mov	r6,r3
 823bd24:	e17ffe17 	ldw	r5,-8(fp)
 823bd28:	1009883a 	mov	r4,r2
 823bd2c:	820c0d80 	call	820c0d8 <memcmp>
 823bd30:	1000021e 	bne	r2,zero,823bd3c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 823bd34:	e0bffc17 	ldw	r2,-16(fp)
 823bd38:	00000706 	br	823bd58 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 823bd3c:	e0bffc17 	ldw	r2,-16(fp)
 823bd40:	10800017 	ldw	r2,0(r2)
 823bd44:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bd48:	e0fffc17 	ldw	r3,-16(fp)
 823bd4c:	e0bfff17 	ldw	r2,-4(fp)
 823bd50:	18bff01e 	bne	r3,r2,823bd14 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 823bd54:	0005883a 	mov	r2,zero
}
 823bd58:	e037883a 	mov	sp,fp
 823bd5c:	dfc00117 	ldw	ra,4(sp)
 823bd60:	df000017 	ldw	fp,0(sp)
 823bd64:	dec00204 	addi	sp,sp,8
 823bd68:	f800283a 	ret

0823bd6c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823bd6c:	defff904 	addi	sp,sp,-28
 823bd70:	dfc00615 	stw	ra,24(sp)
 823bd74:	df000515 	stw	fp,20(sp)
 823bd78:	df000504 	addi	fp,sp,20
 823bd7c:	e13ffc15 	stw	r4,-16(fp)
 823bd80:	e17ffd15 	stw	r5,-12(fp)
 823bd84:	e1bffe15 	stw	r6,-8(fp)
 823bd88:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 823bd8c:	e0800217 	ldw	r2,8(fp)
 823bd90:	d8800015 	stw	r2,0(sp)
 823bd94:	e1ffff17 	ldw	r7,-4(fp)
 823bd98:	e1bffe17 	ldw	r6,-8(fp)
 823bd9c:	e17ffd17 	ldw	r5,-12(fp)
 823bda0:	e13ffc17 	ldw	r4,-16(fp)
 823bda4:	823bf1c0 	call	823bf1c <alt_iic_isr_register>
}  
 823bda8:	e037883a 	mov	sp,fp
 823bdac:	dfc00117 	ldw	ra,4(sp)
 823bdb0:	df000017 	ldw	fp,0(sp)
 823bdb4:	dec00204 	addi	sp,sp,8
 823bdb8:	f800283a 	ret

0823bdbc <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 823bdbc:	defff904 	addi	sp,sp,-28
 823bdc0:	df000615 	stw	fp,24(sp)
 823bdc4:	df000604 	addi	fp,sp,24
 823bdc8:	e13ffe15 	stw	r4,-8(fp)
 823bdcc:	e17fff15 	stw	r5,-4(fp)
 823bdd0:	e0bfff17 	ldw	r2,-4(fp)
 823bdd4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bdd8:	0005303a 	rdctl	r2,status
 823bddc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bde0:	e0fffb17 	ldw	r3,-20(fp)
 823bde4:	00bfff84 	movi	r2,-2
 823bde8:	1884703a 	and	r2,r3,r2
 823bdec:	1001703a 	wrctl	status,r2
  
  return context;
 823bdf0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823bdf4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 823bdf8:	00c00044 	movi	r3,1
 823bdfc:	e0bffa17 	ldw	r2,-24(fp)
 823be00:	1884983a 	sll	r2,r3,r2
 823be04:	1007883a 	mov	r3,r2
 823be08:	d0a0b717 	ldw	r2,-32036(gp)
 823be0c:	1884b03a 	or	r2,r3,r2
 823be10:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823be14:	d0a0b717 	ldw	r2,-32036(gp)
 823be18:	100170fa 	wrctl	ienable,r2
 823be1c:	e0bffc17 	ldw	r2,-16(fp)
 823be20:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823be24:	e0bffd17 	ldw	r2,-12(fp)
 823be28:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823be2c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 823be30:	0001883a 	nop
}
 823be34:	e037883a 	mov	sp,fp
 823be38:	df000017 	ldw	fp,0(sp)
 823be3c:	dec00104 	addi	sp,sp,4
 823be40:	f800283a 	ret

0823be44 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 823be44:	defff904 	addi	sp,sp,-28
 823be48:	df000615 	stw	fp,24(sp)
 823be4c:	df000604 	addi	fp,sp,24
 823be50:	e13ffe15 	stw	r4,-8(fp)
 823be54:	e17fff15 	stw	r5,-4(fp)
 823be58:	e0bfff17 	ldw	r2,-4(fp)
 823be5c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823be60:	0005303a 	rdctl	r2,status
 823be64:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823be68:	e0fffb17 	ldw	r3,-20(fp)
 823be6c:	00bfff84 	movi	r2,-2
 823be70:	1884703a 	and	r2,r3,r2
 823be74:	1001703a 	wrctl	status,r2
  
  return context;
 823be78:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823be7c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 823be80:	00c00044 	movi	r3,1
 823be84:	e0bffa17 	ldw	r2,-24(fp)
 823be88:	1884983a 	sll	r2,r3,r2
 823be8c:	0084303a 	nor	r2,zero,r2
 823be90:	1007883a 	mov	r3,r2
 823be94:	d0a0b717 	ldw	r2,-32036(gp)
 823be98:	1884703a 	and	r2,r3,r2
 823be9c:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823bea0:	d0a0b717 	ldw	r2,-32036(gp)
 823bea4:	100170fa 	wrctl	ienable,r2
 823bea8:	e0bffc17 	ldw	r2,-16(fp)
 823beac:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823beb0:	e0bffd17 	ldw	r2,-12(fp)
 823beb4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823beb8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 823bebc:	0001883a 	nop
}
 823bec0:	e037883a 	mov	sp,fp
 823bec4:	df000017 	ldw	fp,0(sp)
 823bec8:	dec00104 	addi	sp,sp,4
 823becc:	f800283a 	ret

0823bed0 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 823bed0:	defffc04 	addi	sp,sp,-16
 823bed4:	df000315 	stw	fp,12(sp)
 823bed8:	df000304 	addi	fp,sp,12
 823bedc:	e13ffe15 	stw	r4,-8(fp)
 823bee0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 823bee4:	000530fa 	rdctl	r2,ienable
 823bee8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 823beec:	00c00044 	movi	r3,1
 823bef0:	e0bfff17 	ldw	r2,-4(fp)
 823bef4:	1884983a 	sll	r2,r3,r2
 823bef8:	1007883a 	mov	r3,r2
 823befc:	e0bffd17 	ldw	r2,-12(fp)
 823bf00:	1884703a 	and	r2,r3,r2
 823bf04:	1004c03a 	cmpne	r2,r2,zero
 823bf08:	10803fcc 	andi	r2,r2,255
}
 823bf0c:	e037883a 	mov	sp,fp
 823bf10:	df000017 	ldw	fp,0(sp)
 823bf14:	dec00104 	addi	sp,sp,4
 823bf18:	f800283a 	ret

0823bf1c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823bf1c:	defff504 	addi	sp,sp,-44
 823bf20:	dfc00a15 	stw	ra,40(sp)
 823bf24:	df000915 	stw	fp,36(sp)
 823bf28:	df000904 	addi	fp,sp,36
 823bf2c:	e13ffc15 	stw	r4,-16(fp)
 823bf30:	e17ffd15 	stw	r5,-12(fp)
 823bf34:	e1bffe15 	stw	r6,-8(fp)
 823bf38:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 823bf3c:	00bffa84 	movi	r2,-22
 823bf40:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 823bf44:	e0bffd17 	ldw	r2,-12(fp)
 823bf48:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 823bf4c:	e0bff817 	ldw	r2,-32(fp)
 823bf50:	10800808 	cmpgei	r2,r2,32
 823bf54:	1000271e 	bne	r2,zero,823bff4 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bf58:	0005303a 	rdctl	r2,status
 823bf5c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bf60:	e0fffb17 	ldw	r3,-20(fp)
 823bf64:	00bfff84 	movi	r2,-2
 823bf68:	1884703a 	and	r2,r3,r2
 823bf6c:	1001703a 	wrctl	status,r2
  
  return context;
 823bf70:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 823bf74:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 823bf78:	008209b4 	movhi	r2,2086
 823bf7c:	10b85a04 	addi	r2,r2,-7832
 823bf80:	e0fff817 	ldw	r3,-32(fp)
 823bf84:	180690fa 	slli	r3,r3,3
 823bf88:	10c5883a 	add	r2,r2,r3
 823bf8c:	e0fffe17 	ldw	r3,-8(fp)
 823bf90:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 823bf94:	008209b4 	movhi	r2,2086
 823bf98:	10b85a04 	addi	r2,r2,-7832
 823bf9c:	e0fff817 	ldw	r3,-32(fp)
 823bfa0:	180690fa 	slli	r3,r3,3
 823bfa4:	10c5883a 	add	r2,r2,r3
 823bfa8:	10800104 	addi	r2,r2,4
 823bfac:	e0ffff17 	ldw	r3,-4(fp)
 823bfb0:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 823bfb4:	e0bffe17 	ldw	r2,-8(fp)
 823bfb8:	10000526 	beq	r2,zero,823bfd0 <alt_iic_isr_register+0xb4>
 823bfbc:	e0bff817 	ldw	r2,-32(fp)
 823bfc0:	100b883a 	mov	r5,r2
 823bfc4:	e13ffc17 	ldw	r4,-16(fp)
 823bfc8:	823bdbc0 	call	823bdbc <alt_ic_irq_enable>
 823bfcc:	00000406 	br	823bfe0 <alt_iic_isr_register+0xc4>
 823bfd0:	e0bff817 	ldw	r2,-32(fp)
 823bfd4:	100b883a 	mov	r5,r2
 823bfd8:	e13ffc17 	ldw	r4,-16(fp)
 823bfdc:	823be440 	call	823be44 <alt_ic_irq_disable>
 823bfe0:	e0bff715 	stw	r2,-36(fp)
 823bfe4:	e0bffa17 	ldw	r2,-24(fp)
 823bfe8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bfec:	e0bff917 	ldw	r2,-28(fp)
 823bff0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 823bff4:	e0bff717 	ldw	r2,-36(fp)
}
 823bff8:	e037883a 	mov	sp,fp
 823bffc:	dfc00117 	ldw	ra,4(sp)
 823c000:	df000017 	ldw	fp,0(sp)
 823c004:	dec00204 	addi	sp,sp,8
 823c008:	f800283a 	ret

0823c00c <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 823c00c:	defff904 	addi	sp,sp,-28
 823c010:	dfc00615 	stw	ra,24(sp)
 823c014:	df000515 	stw	fp,20(sp)
 823c018:	df000504 	addi	fp,sp,20
 823c01c:	e13ffc15 	stw	r4,-16(fp)
 823c020:	e17ffd15 	stw	r5,-12(fp)
 823c024:	e1bffe15 	stw	r6,-8(fp)
 823c028:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 823c02c:	e1bfff17 	ldw	r6,-4(fp)
 823c030:	e17ffe17 	ldw	r5,-8(fp)
 823c034:	e13ffd17 	ldw	r4,-12(fp)
 823c038:	823c24c0 	call	823c24c <open>
 823c03c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 823c040:	e0bffb17 	ldw	r2,-20(fp)
 823c044:	10001c16 	blt	r2,zero,823c0b8 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 823c048:	00820974 	movhi	r2,2085
 823c04c:	108d6a04 	addi	r2,r2,13736
 823c050:	e0fffb17 	ldw	r3,-20(fp)
 823c054:	18c00324 	muli	r3,r3,12
 823c058:	10c5883a 	add	r2,r2,r3
 823c05c:	10c00017 	ldw	r3,0(r2)
 823c060:	e0bffc17 	ldw	r2,-16(fp)
 823c064:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 823c068:	00820974 	movhi	r2,2085
 823c06c:	108d6a04 	addi	r2,r2,13736
 823c070:	e0fffb17 	ldw	r3,-20(fp)
 823c074:	18c00324 	muli	r3,r3,12
 823c078:	10c5883a 	add	r2,r2,r3
 823c07c:	10800104 	addi	r2,r2,4
 823c080:	10c00017 	ldw	r3,0(r2)
 823c084:	e0bffc17 	ldw	r2,-16(fp)
 823c088:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 823c08c:	00820974 	movhi	r2,2085
 823c090:	108d6a04 	addi	r2,r2,13736
 823c094:	e0fffb17 	ldw	r3,-20(fp)
 823c098:	18c00324 	muli	r3,r3,12
 823c09c:	10c5883a 	add	r2,r2,r3
 823c0a0:	10800204 	addi	r2,r2,8
 823c0a4:	10c00017 	ldw	r3,0(r2)
 823c0a8:	e0bffc17 	ldw	r2,-16(fp)
 823c0ac:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 823c0b0:	e13ffb17 	ldw	r4,-20(fp)
 823c0b4:	823c4d80 	call	823c4d8 <alt_release_fd>
  }
} 
 823c0b8:	0001883a 	nop
 823c0bc:	e037883a 	mov	sp,fp
 823c0c0:	dfc00117 	ldw	ra,4(sp)
 823c0c4:	df000017 	ldw	fp,0(sp)
 823c0c8:	dec00204 	addi	sp,sp,8
 823c0cc:	f800283a 	ret

0823c0d0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 823c0d0:	defffb04 	addi	sp,sp,-20
 823c0d4:	dfc00415 	stw	ra,16(sp)
 823c0d8:	df000315 	stw	fp,12(sp)
 823c0dc:	df000304 	addi	fp,sp,12
 823c0e0:	e13ffd15 	stw	r4,-12(fp)
 823c0e4:	e17ffe15 	stw	r5,-8(fp)
 823c0e8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 823c0ec:	01c07fc4 	movi	r7,511
 823c0f0:	01800044 	movi	r6,1
 823c0f4:	e17ffd17 	ldw	r5,-12(fp)
 823c0f8:	01020974 	movhi	r4,2085
 823c0fc:	210d6d04 	addi	r4,r4,13748
 823c100:	823c00c0 	call	823c00c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 823c104:	01c07fc4 	movi	r7,511
 823c108:	000d883a 	mov	r6,zero
 823c10c:	e17ffe17 	ldw	r5,-8(fp)
 823c110:	01020974 	movhi	r4,2085
 823c114:	210d6a04 	addi	r4,r4,13736
 823c118:	823c00c0 	call	823c00c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 823c11c:	01c07fc4 	movi	r7,511
 823c120:	01800044 	movi	r6,1
 823c124:	e17fff17 	ldw	r5,-4(fp)
 823c128:	01020974 	movhi	r4,2085
 823c12c:	210d7004 	addi	r4,r4,13760
 823c130:	823c00c0 	call	823c00c <alt_open_fd>
}  
 823c134:	0001883a 	nop
 823c138:	e037883a 	mov	sp,fp
 823c13c:	dfc00117 	ldw	ra,4(sp)
 823c140:	df000017 	ldw	fp,0(sp)
 823c144:	dec00204 	addi	sp,sp,8
 823c148:	f800283a 	ret

0823c14c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c14c:	defffe04 	addi	sp,sp,-8
 823c150:	dfc00115 	stw	ra,4(sp)
 823c154:	df000015 	stw	fp,0(sp)
 823c158:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c15c:	d0a04717 	ldw	r2,-32484(gp)
 823c160:	10000326 	beq	r2,zero,823c170 <alt_get_errno+0x24>
 823c164:	d0a04717 	ldw	r2,-32484(gp)
 823c168:	103ee83a 	callr	r2
 823c16c:	00000106 	br	823c174 <alt_get_errno+0x28>
 823c170:	d0a06304 	addi	r2,gp,-32372
}
 823c174:	e037883a 	mov	sp,fp
 823c178:	dfc00117 	ldw	ra,4(sp)
 823c17c:	df000017 	ldw	fp,0(sp)
 823c180:	dec00204 	addi	sp,sp,8
 823c184:	f800283a 	ret

0823c188 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 823c188:	defffd04 	addi	sp,sp,-12
 823c18c:	df000215 	stw	fp,8(sp)
 823c190:	df000204 	addi	fp,sp,8
 823c194:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 823c198:	e0bfff17 	ldw	r2,-4(fp)
 823c19c:	10800217 	ldw	r2,8(r2)
 823c1a0:	10d00034 	orhi	r3,r2,16384
 823c1a4:	e0bfff17 	ldw	r2,-4(fp)
 823c1a8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c1ac:	e03ffe15 	stw	zero,-8(fp)
 823c1b0:	00001d06 	br	823c228 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c1b4:	00820974 	movhi	r2,2085
 823c1b8:	108d6a04 	addi	r2,r2,13736
 823c1bc:	e0fffe17 	ldw	r3,-8(fp)
 823c1c0:	18c00324 	muli	r3,r3,12
 823c1c4:	10c5883a 	add	r2,r2,r3
 823c1c8:	10c00017 	ldw	r3,0(r2)
 823c1cc:	e0bfff17 	ldw	r2,-4(fp)
 823c1d0:	10800017 	ldw	r2,0(r2)
 823c1d4:	1880111e 	bne	r3,r2,823c21c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c1d8:	00820974 	movhi	r2,2085
 823c1dc:	108d6a04 	addi	r2,r2,13736
 823c1e0:	e0fffe17 	ldw	r3,-8(fp)
 823c1e4:	18c00324 	muli	r3,r3,12
 823c1e8:	10c5883a 	add	r2,r2,r3
 823c1ec:	10800204 	addi	r2,r2,8
 823c1f0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c1f4:	1000090e 	bge	r2,zero,823c21c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 823c1f8:	e0bffe17 	ldw	r2,-8(fp)
 823c1fc:	10c00324 	muli	r3,r2,12
 823c200:	00820974 	movhi	r2,2085
 823c204:	108d6a04 	addi	r2,r2,13736
 823c208:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c20c:	e0bfff17 	ldw	r2,-4(fp)
 823c210:	18800226 	beq	r3,r2,823c21c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 823c214:	00bffcc4 	movi	r2,-13
 823c218:	00000806 	br	823c23c <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c21c:	e0bffe17 	ldw	r2,-8(fp)
 823c220:	10800044 	addi	r2,r2,1
 823c224:	e0bffe15 	stw	r2,-8(fp)
 823c228:	d0a04617 	ldw	r2,-32488(gp)
 823c22c:	1007883a 	mov	r3,r2
 823c230:	e0bffe17 	ldw	r2,-8(fp)
 823c234:	18bfdf2e 	bgeu	r3,r2,823c1b4 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 823c238:	0005883a 	mov	r2,zero
}
 823c23c:	e037883a 	mov	sp,fp
 823c240:	df000017 	ldw	fp,0(sp)
 823c244:	dec00104 	addi	sp,sp,4
 823c248:	f800283a 	ret

0823c24c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 823c24c:	defff604 	addi	sp,sp,-40
 823c250:	dfc00915 	stw	ra,36(sp)
 823c254:	df000815 	stw	fp,32(sp)
 823c258:	df000804 	addi	fp,sp,32
 823c25c:	e13ffd15 	stw	r4,-12(fp)
 823c260:	e17ffe15 	stw	r5,-8(fp)
 823c264:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 823c268:	00bfffc4 	movi	r2,-1
 823c26c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 823c270:	00bffb44 	movi	r2,-19
 823c274:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 823c278:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 823c27c:	d1604404 	addi	r5,gp,-32496
 823c280:	e13ffd17 	ldw	r4,-12(fp)
 823c284:	823bcdc0 	call	823bcdc <alt_find_dev>
 823c288:	e0bff815 	stw	r2,-32(fp)
 823c28c:	e0bff817 	ldw	r2,-32(fp)
 823c290:	1000051e 	bne	r2,zero,823c2a8 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 823c294:	e13ffd17 	ldw	r4,-12(fp)
 823c298:	8249d780 	call	8249d78 <alt_find_file>
 823c29c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 823c2a0:	00800044 	movi	r2,1
 823c2a4:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 823c2a8:	e0bff817 	ldw	r2,-32(fp)
 823c2ac:	10002926 	beq	r2,zero,823c354 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 823c2b0:	e13ff817 	ldw	r4,-32(fp)
 823c2b4:	8249e800 	call	8249e80 <alt_get_fd>
 823c2b8:	e0bff915 	stw	r2,-28(fp)
 823c2bc:	e0bff917 	ldw	r2,-28(fp)
 823c2c0:	1000030e 	bge	r2,zero,823c2d0 <open+0x84>
    {
      status = index;
 823c2c4:	e0bff917 	ldw	r2,-28(fp)
 823c2c8:	e0bffa15 	stw	r2,-24(fp)
 823c2cc:	00002306 	br	823c35c <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 823c2d0:	e0bff917 	ldw	r2,-28(fp)
 823c2d4:	10c00324 	muli	r3,r2,12
 823c2d8:	00820974 	movhi	r2,2085
 823c2dc:	108d6a04 	addi	r2,r2,13736
 823c2e0:	1885883a 	add	r2,r3,r2
 823c2e4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 823c2e8:	e0fffe17 	ldw	r3,-8(fp)
 823c2ec:	00900034 	movhi	r2,16384
 823c2f0:	10bfffc4 	addi	r2,r2,-1
 823c2f4:	1886703a 	and	r3,r3,r2
 823c2f8:	e0bffc17 	ldw	r2,-16(fp)
 823c2fc:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 823c300:	e0bffb17 	ldw	r2,-20(fp)
 823c304:	1000051e 	bne	r2,zero,823c31c <open+0xd0>
 823c308:	e13ffc17 	ldw	r4,-16(fp)
 823c30c:	823c1880 	call	823c188 <alt_file_locked>
 823c310:	e0bffa15 	stw	r2,-24(fp)
 823c314:	e0bffa17 	ldw	r2,-24(fp)
 823c318:	10001016 	blt	r2,zero,823c35c <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 823c31c:	e0bff817 	ldw	r2,-32(fp)
 823c320:	10800317 	ldw	r2,12(r2)
 823c324:	10000826 	beq	r2,zero,823c348 <open+0xfc>
 823c328:	e0bff817 	ldw	r2,-32(fp)
 823c32c:	10800317 	ldw	r2,12(r2)
 823c330:	e1ffff17 	ldw	r7,-4(fp)
 823c334:	e1bffe17 	ldw	r6,-8(fp)
 823c338:	e17ffd17 	ldw	r5,-12(fp)
 823c33c:	e13ffc17 	ldw	r4,-16(fp)
 823c340:	103ee83a 	callr	r2
 823c344:	00000106 	br	823c34c <open+0x100>
 823c348:	0005883a 	mov	r2,zero
 823c34c:	e0bffa15 	stw	r2,-24(fp)
 823c350:	00000206 	br	823c35c <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 823c354:	00bffb44 	movi	r2,-19
 823c358:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 823c35c:	e0bffa17 	ldw	r2,-24(fp)
 823c360:	1000090e 	bge	r2,zero,823c388 <open+0x13c>
  {
    alt_release_fd (index);  
 823c364:	e13ff917 	ldw	r4,-28(fp)
 823c368:	823c4d80 	call	823c4d8 <alt_release_fd>
    ALT_ERRNO = -status;
 823c36c:	823c14c0 	call	823c14c <alt_get_errno>
 823c370:	1007883a 	mov	r3,r2
 823c374:	e0bffa17 	ldw	r2,-24(fp)
 823c378:	0085c83a 	sub	r2,zero,r2
 823c37c:	18800015 	stw	r2,0(r3)
    return -1;
 823c380:	00bfffc4 	movi	r2,-1
 823c384:	00000106 	br	823c38c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 823c388:	e0bff917 	ldw	r2,-28(fp)
}
 823c38c:	e037883a 	mov	sp,fp
 823c390:	dfc00117 	ldw	ra,4(sp)
 823c394:	df000017 	ldw	fp,0(sp)
 823c398:	dec00204 	addi	sp,sp,8
 823c39c:	f800283a 	ret

0823c3a0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c3a0:	defffe04 	addi	sp,sp,-8
 823c3a4:	dfc00115 	stw	ra,4(sp)
 823c3a8:	df000015 	stw	fp,0(sp)
 823c3ac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c3b0:	d0a04717 	ldw	r2,-32484(gp)
 823c3b4:	10000326 	beq	r2,zero,823c3c4 <alt_get_errno+0x24>
 823c3b8:	d0a04717 	ldw	r2,-32484(gp)
 823c3bc:	103ee83a 	callr	r2
 823c3c0:	00000106 	br	823c3c8 <alt_get_errno+0x28>
 823c3c4:	d0a06304 	addi	r2,gp,-32372
}
 823c3c8:	e037883a 	mov	sp,fp
 823c3cc:	dfc00117 	ldw	ra,4(sp)
 823c3d0:	df000017 	ldw	fp,0(sp)
 823c3d4:	dec00204 	addi	sp,sp,8
 823c3d8:	f800283a 	ret

0823c3dc <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 823c3dc:	defff904 	addi	sp,sp,-28
 823c3e0:	dfc00615 	stw	ra,24(sp)
 823c3e4:	df000515 	stw	fp,20(sp)
 823c3e8:	df000504 	addi	fp,sp,20
 823c3ec:	e13ffd15 	stw	r4,-12(fp)
 823c3f0:	e17ffe15 	stw	r5,-8(fp)
 823c3f4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c3f8:	e0bffd17 	ldw	r2,-12(fp)
 823c3fc:	10000616 	blt	r2,zero,823c418 <alt_read+0x3c>
 823c400:	e0bffd17 	ldw	r2,-12(fp)
 823c404:	10c00324 	muli	r3,r2,12
 823c408:	00820974 	movhi	r2,2085
 823c40c:	108d6a04 	addi	r2,r2,13736
 823c410:	1885883a 	add	r2,r3,r2
 823c414:	00000106 	br	823c41c <alt_read+0x40>
 823c418:	0005883a 	mov	r2,zero
 823c41c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c420:	e0bffb17 	ldw	r2,-20(fp)
 823c424:	10002226 	beq	r2,zero,823c4b0 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c428:	e0bffb17 	ldw	r2,-20(fp)
 823c42c:	10800217 	ldw	r2,8(r2)
 823c430:	108000cc 	andi	r2,r2,3
 823c434:	10800060 	cmpeqi	r2,r2,1
 823c438:	1000181e 	bne	r2,zero,823c49c <alt_read+0xc0>
        (fd->dev->read))
 823c43c:	e0bffb17 	ldw	r2,-20(fp)
 823c440:	10800017 	ldw	r2,0(r2)
 823c444:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c448:	10001426 	beq	r2,zero,823c49c <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 823c44c:	e0bffb17 	ldw	r2,-20(fp)
 823c450:	10800017 	ldw	r2,0(r2)
 823c454:	10800517 	ldw	r2,20(r2)
 823c458:	e0ffff17 	ldw	r3,-4(fp)
 823c45c:	180d883a 	mov	r6,r3
 823c460:	e17ffe17 	ldw	r5,-8(fp)
 823c464:	e13ffb17 	ldw	r4,-20(fp)
 823c468:	103ee83a 	callr	r2
 823c46c:	e0bffc15 	stw	r2,-16(fp)
 823c470:	e0bffc17 	ldw	r2,-16(fp)
 823c474:	1000070e 	bge	r2,zero,823c494 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 823c478:	823c3a00 	call	823c3a0 <alt_get_errno>
 823c47c:	1007883a 	mov	r3,r2
 823c480:	e0bffc17 	ldw	r2,-16(fp)
 823c484:	0085c83a 	sub	r2,zero,r2
 823c488:	18800015 	stw	r2,0(r3)
          return -1;
 823c48c:	00bfffc4 	movi	r2,-1
 823c490:	00000c06 	br	823c4c4 <alt_read+0xe8>
        }
        return rval;
 823c494:	e0bffc17 	ldw	r2,-16(fp)
 823c498:	00000a06 	br	823c4c4 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 823c49c:	823c3a00 	call	823c3a0 <alt_get_errno>
 823c4a0:	1007883a 	mov	r3,r2
 823c4a4:	00800344 	movi	r2,13
 823c4a8:	18800015 	stw	r2,0(r3)
 823c4ac:	00000406 	br	823c4c0 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 823c4b0:	823c3a00 	call	823c3a0 <alt_get_errno>
 823c4b4:	1007883a 	mov	r3,r2
 823c4b8:	00801444 	movi	r2,81
 823c4bc:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c4c0:	00bfffc4 	movi	r2,-1
}
 823c4c4:	e037883a 	mov	sp,fp
 823c4c8:	dfc00117 	ldw	ra,4(sp)
 823c4cc:	df000017 	ldw	fp,0(sp)
 823c4d0:	dec00204 	addi	sp,sp,8
 823c4d4:	f800283a 	ret

0823c4d8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 823c4d8:	defffe04 	addi	sp,sp,-8
 823c4dc:	df000115 	stw	fp,4(sp)
 823c4e0:	df000104 	addi	fp,sp,4
 823c4e4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 823c4e8:	e0bfff17 	ldw	r2,-4(fp)
 823c4ec:	108000d0 	cmplti	r2,r2,3
 823c4f0:	10000d1e 	bne	r2,zero,823c528 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 823c4f4:	00820974 	movhi	r2,2085
 823c4f8:	108d6a04 	addi	r2,r2,13736
 823c4fc:	e0ffff17 	ldw	r3,-4(fp)
 823c500:	18c00324 	muli	r3,r3,12
 823c504:	10c5883a 	add	r2,r2,r3
 823c508:	10800204 	addi	r2,r2,8
 823c50c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 823c510:	00820974 	movhi	r2,2085
 823c514:	108d6a04 	addi	r2,r2,13736
 823c518:	e0ffff17 	ldw	r3,-4(fp)
 823c51c:	18c00324 	muli	r3,r3,12
 823c520:	10c5883a 	add	r2,r2,r3
 823c524:	10000015 	stw	zero,0(r2)
  }
}
 823c528:	0001883a 	nop
 823c52c:	e037883a 	mov	sp,fp
 823c530:	df000017 	ldw	fp,0(sp)
 823c534:	dec00104 	addi	sp,sp,4
 823c538:	f800283a 	ret

0823c53c <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 823c53c:	defffd04 	addi	sp,sp,-12
 823c540:	df000215 	stw	fp,8(sp)
 823c544:	df000204 	addi	fp,sp,8
 823c548:	e13ffe15 	stw	r4,-8(fp)
 823c54c:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 823c550:	e0fffe17 	ldw	r3,-8(fp)
 823c554:	00a00034 	movhi	r2,32768
 823c558:	10bfffc4 	addi	r2,r2,-1
 823c55c:	1884703a 	and	r2,r3,r2
}
 823c560:	e037883a 	mov	sp,fp
 823c564:	df000017 	ldw	fp,0(sp)
 823c568:	dec00104 	addi	sp,sp,4
 823c56c:	f800283a 	ret

0823c570 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 823c570:	defffa04 	addi	sp,sp,-24
 823c574:	df000515 	stw	fp,20(sp)
 823c578:	df000504 	addi	fp,sp,20
 823c57c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c580:	0005303a 	rdctl	r2,status
 823c584:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c588:	e0fffc17 	ldw	r3,-16(fp)
 823c58c:	00bfff84 	movi	r2,-2
 823c590:	1884703a 	and	r2,r3,r2
 823c594:	1001703a 	wrctl	status,r2
  
  return context;
 823c598:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 823c59c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 823c5a0:	e0bfff17 	ldw	r2,-4(fp)
 823c5a4:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 823c5a8:	e0bffd17 	ldw	r2,-12(fp)
 823c5ac:	10800017 	ldw	r2,0(r2)
 823c5b0:	e0fffd17 	ldw	r3,-12(fp)
 823c5b4:	18c00117 	ldw	r3,4(r3)
 823c5b8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 823c5bc:	e0bffd17 	ldw	r2,-12(fp)
 823c5c0:	10800117 	ldw	r2,4(r2)
 823c5c4:	e0fffd17 	ldw	r3,-12(fp)
 823c5c8:	18c00017 	ldw	r3,0(r3)
 823c5cc:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 823c5d0:	e0bffd17 	ldw	r2,-12(fp)
 823c5d4:	e0fffd17 	ldw	r3,-12(fp)
 823c5d8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 823c5dc:	e0bffd17 	ldw	r2,-12(fp)
 823c5e0:	e0fffd17 	ldw	r3,-12(fp)
 823c5e4:	10c00015 	stw	r3,0(r2)
 823c5e8:	e0bffb17 	ldw	r2,-20(fp)
 823c5ec:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c5f0:	e0bffe17 	ldw	r2,-8(fp)
 823c5f4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 823c5f8:	0001883a 	nop
 823c5fc:	e037883a 	mov	sp,fp
 823c600:	df000017 	ldw	fp,0(sp)
 823c604:	dec00104 	addi	sp,sp,4
 823c608:	f800283a 	ret

0823c60c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 823c60c:	defffb04 	addi	sp,sp,-20
 823c610:	dfc00415 	stw	ra,16(sp)
 823c614:	df000315 	stw	fp,12(sp)
 823c618:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 823c61c:	d0a04917 	ldw	r2,-32476(gp)
 823c620:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 823c624:	d0a0b917 	ldw	r2,-32028(gp)
 823c628:	10800044 	addi	r2,r2,1
 823c62c:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c630:	00002e06 	br	823c6ec <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 823c634:	e0bffd17 	ldw	r2,-12(fp)
 823c638:	10800017 	ldw	r2,0(r2)
 823c63c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 823c640:	e0bffd17 	ldw	r2,-12(fp)
 823c644:	10800403 	ldbu	r2,16(r2)
 823c648:	10803fcc 	andi	r2,r2,255
 823c64c:	10000426 	beq	r2,zero,823c660 <alt_tick+0x54>
 823c650:	d0a0b917 	ldw	r2,-32028(gp)
 823c654:	1000021e 	bne	r2,zero,823c660 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 823c658:	e0bffd17 	ldw	r2,-12(fp)
 823c65c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 823c660:	e0bffd17 	ldw	r2,-12(fp)
 823c664:	10800217 	ldw	r2,8(r2)
 823c668:	d0e0b917 	ldw	r3,-32028(gp)
 823c66c:	18801d36 	bltu	r3,r2,823c6e4 <alt_tick+0xd8>
 823c670:	e0bffd17 	ldw	r2,-12(fp)
 823c674:	10800403 	ldbu	r2,16(r2)
 823c678:	10803fcc 	andi	r2,r2,255
 823c67c:	1000191e 	bne	r2,zero,823c6e4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 823c680:	e0bffd17 	ldw	r2,-12(fp)
 823c684:	10800317 	ldw	r2,12(r2)
 823c688:	e0fffd17 	ldw	r3,-12(fp)
 823c68c:	18c00517 	ldw	r3,20(r3)
 823c690:	1809883a 	mov	r4,r3
 823c694:	103ee83a 	callr	r2
 823c698:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 823c69c:	e0bfff17 	ldw	r2,-4(fp)
 823c6a0:	1000031e 	bne	r2,zero,823c6b0 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 823c6a4:	e13ffd17 	ldw	r4,-12(fp)
 823c6a8:	823c5700 	call	823c570 <alt_alarm_stop>
 823c6ac:	00000d06 	br	823c6e4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 823c6b0:	e0bffd17 	ldw	r2,-12(fp)
 823c6b4:	10c00217 	ldw	r3,8(r2)
 823c6b8:	e0bfff17 	ldw	r2,-4(fp)
 823c6bc:	1887883a 	add	r3,r3,r2
 823c6c0:	e0bffd17 	ldw	r2,-12(fp)
 823c6c4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 823c6c8:	e0bffd17 	ldw	r2,-12(fp)
 823c6cc:	10c00217 	ldw	r3,8(r2)
 823c6d0:	d0a0b917 	ldw	r2,-32028(gp)
 823c6d4:	1880032e 	bgeu	r3,r2,823c6e4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 823c6d8:	e0bffd17 	ldw	r2,-12(fp)
 823c6dc:	00c00044 	movi	r3,1
 823c6e0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 823c6e4:	e0bffe17 	ldw	r2,-8(fp)
 823c6e8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c6ec:	e0fffd17 	ldw	r3,-12(fp)
 823c6f0:	d0a04904 	addi	r2,gp,-32476
 823c6f4:	18bfcf1e 	bne	r3,r2,823c634 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 823c6f8:	82154ac0 	call	82154ac <OSTimeTick>
}
 823c6fc:	0001883a 	nop
 823c700:	e037883a 	mov	sp,fp
 823c704:	dfc00117 	ldw	ra,4(sp)
 823c708:	df000017 	ldw	fp,0(sp)
 823c70c:	dec00204 	addi	sp,sp,8
 823c710:	f800283a 	ret

0823c714 <alt_uncached_free>:
/*
 * Free a block of uncached memory.
 */

void alt_uncached_free (volatile void* ptr)
{
 823c714:	defffd04 	addi	sp,sp,-12
 823c718:	dfc00215 	stw	ra,8(sp)
 823c71c:	df000115 	stw	fp,4(sp)
 823c720:	df000104 	addi	fp,sp,4
 823c724:	e13fff15 	stw	r4,-4(fp)
  free ((void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK));
 823c728:	e0ffff17 	ldw	r3,-4(fp)
 823c72c:	00a00034 	movhi	r2,32768
 823c730:	10bfffc4 	addi	r2,r2,-1
 823c734:	1884703a 	and	r2,r3,r2
 823c738:	1009883a 	mov	r4,r2
 823c73c:	824b1a00 	call	824b1a0 <free>
}
 823c740:	0001883a 	nop
 823c744:	e037883a 	mov	sp,fp
 823c748:	dfc00117 	ldw	ra,4(sp)
 823c74c:	df000017 	ldw	fp,0(sp)
 823c750:	dec00204 	addi	sp,sp,8
 823c754:	f800283a 	ret

0823c758 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 823c758:	defffc04 	addi	sp,sp,-16
 823c75c:	dfc00315 	stw	ra,12(sp)
 823c760:	df000215 	stw	fp,8(sp)
 823c764:	df000204 	addi	fp,sp,8
 823c768:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
 823c76c:	e13fff17 	ldw	r4,-4(fp)
 823c770:	824b18c0 	call	824b18c <malloc>
 823c774:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
 823c778:	e17fff17 	ldw	r5,-4(fp)
 823c77c:	e13ffe17 	ldw	r4,-8(fp)
 823c780:	823ba980 	call	823ba98 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 823c784:	e0bffe17 	ldw	r2,-8(fp)
 823c788:	10000326 	beq	r2,zero,823c798 <alt_uncached_malloc+0x40>
 823c78c:	e0bffe17 	ldw	r2,-8(fp)
 823c790:	10a00034 	orhi	r2,r2,32768
 823c794:	00000106 	br	823c79c <alt_uncached_malloc+0x44>
 823c798:	0005883a 	mov	r2,zero
}
 823c79c:	e037883a 	mov	sp,fp
 823c7a0:	dfc00117 	ldw	ra,4(sp)
 823c7a4:	df000017 	ldw	fp,0(sp)
 823c7a8:	dec00204 	addi	sp,sp,8
 823c7ac:	f800283a 	ret

0823c7b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c7b0:	defffe04 	addi	sp,sp,-8
 823c7b4:	dfc00115 	stw	ra,4(sp)
 823c7b8:	df000015 	stw	fp,0(sp)
 823c7bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c7c0:	d0a04717 	ldw	r2,-32484(gp)
 823c7c4:	10000326 	beq	r2,zero,823c7d4 <alt_get_errno+0x24>
 823c7c8:	d0a04717 	ldw	r2,-32484(gp)
 823c7cc:	103ee83a 	callr	r2
 823c7d0:	00000106 	br	823c7d8 <alt_get_errno+0x28>
 823c7d4:	d0a06304 	addi	r2,gp,-32372
}
 823c7d8:	e037883a 	mov	sp,fp
 823c7dc:	dfc00117 	ldw	ra,4(sp)
 823c7e0:	df000017 	ldw	fp,0(sp)
 823c7e4:	dec00204 	addi	sp,sp,8
 823c7e8:	f800283a 	ret

0823c7ec <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 823c7ec:	defff904 	addi	sp,sp,-28
 823c7f0:	dfc00615 	stw	ra,24(sp)
 823c7f4:	df000515 	stw	fp,20(sp)
 823c7f8:	df000504 	addi	fp,sp,20
 823c7fc:	e13ffd15 	stw	r4,-12(fp)
 823c800:	e17ffe15 	stw	r5,-8(fp)
 823c804:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c808:	e0bffd17 	ldw	r2,-12(fp)
 823c80c:	10000616 	blt	r2,zero,823c828 <alt_write+0x3c>
 823c810:	e0bffd17 	ldw	r2,-12(fp)
 823c814:	10c00324 	muli	r3,r2,12
 823c818:	00820974 	movhi	r2,2085
 823c81c:	108d6a04 	addi	r2,r2,13736
 823c820:	1885883a 	add	r2,r3,r2
 823c824:	00000106 	br	823c82c <alt_write+0x40>
 823c828:	0005883a 	mov	r2,zero
 823c82c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c830:	e0bffb17 	ldw	r2,-20(fp)
 823c834:	10002126 	beq	r2,zero,823c8bc <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 823c838:	e0bffb17 	ldw	r2,-20(fp)
 823c83c:	10800217 	ldw	r2,8(r2)
 823c840:	108000cc 	andi	r2,r2,3
 823c844:	10001826 	beq	r2,zero,823c8a8 <alt_write+0xbc>
 823c848:	e0bffb17 	ldw	r2,-20(fp)
 823c84c:	10800017 	ldw	r2,0(r2)
 823c850:	10800617 	ldw	r2,24(r2)
 823c854:	10001426 	beq	r2,zero,823c8a8 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 823c858:	e0bffb17 	ldw	r2,-20(fp)
 823c85c:	10800017 	ldw	r2,0(r2)
 823c860:	10800617 	ldw	r2,24(r2)
 823c864:	e0ffff17 	ldw	r3,-4(fp)
 823c868:	180d883a 	mov	r6,r3
 823c86c:	e17ffe17 	ldw	r5,-8(fp)
 823c870:	e13ffb17 	ldw	r4,-20(fp)
 823c874:	103ee83a 	callr	r2
 823c878:	e0bffc15 	stw	r2,-16(fp)
 823c87c:	e0bffc17 	ldw	r2,-16(fp)
 823c880:	1000070e 	bge	r2,zero,823c8a0 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 823c884:	823c7b00 	call	823c7b0 <alt_get_errno>
 823c888:	1007883a 	mov	r3,r2
 823c88c:	e0bffc17 	ldw	r2,-16(fp)
 823c890:	0085c83a 	sub	r2,zero,r2
 823c894:	18800015 	stw	r2,0(r3)
        return -1;
 823c898:	00bfffc4 	movi	r2,-1
 823c89c:	00000c06 	br	823c8d0 <alt_write+0xe4>
      }
      return rval;
 823c8a0:	e0bffc17 	ldw	r2,-16(fp)
 823c8a4:	00000a06 	br	823c8d0 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 823c8a8:	823c7b00 	call	823c7b0 <alt_get_errno>
 823c8ac:	1007883a 	mov	r3,r2
 823c8b0:	00800344 	movi	r2,13
 823c8b4:	18800015 	stw	r2,0(r3)
 823c8b8:	00000406 	br	823c8cc <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 823c8bc:	823c7b00 	call	823c7b0 <alt_get_errno>
 823c8c0:	1007883a 	mov	r3,r2
 823c8c4:	00801444 	movi	r2,81
 823c8c8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c8cc:	00bfffc4 	movi	r2,-1
}
 823c8d0:	e037883a 	mov	sp,fp
 823c8d4:	dfc00117 	ldw	ra,4(sp)
 823c8d8:	df000017 	ldw	fp,0(sp)
 823c8dc:	dec00204 	addi	sp,sp,8
 823c8e0:	f800283a 	ret

0823c8e4 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 823c8e4:	deffff04 	addi	sp,sp,-4
 823c8e8:	df000015 	stw	fp,0(sp)
 823c8ec:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 823c8f0:	000170fa 	wrctl	ienable,zero
}
 823c8f4:	0001883a 	nop
 823c8f8:	e037883a 	mov	sp,fp
 823c8fc:	df000017 	ldw	fp,0(sp)
 823c900:	dec00104 	addi	sp,sp,4
 823c904:	f800283a 	ret

0823c908 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 823c908:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 823c90c:	d0e00217 	ldw	r3,-32760(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 823c910:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 823c914:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 823c918:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 823c91c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 823c920:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 823c924:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 823c928:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 823c92c:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 823c930:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 823c934:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 823c938:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 823c93c:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 823c940:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823c944:	823cb7c0 	call	823cb7c <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 823c948:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 823c94c:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 823c950:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 823c954:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 823c958:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 823c95c:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 823c960:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 823c964:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 823c968:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 823c96c:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 823c970:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 823c974:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 823c978:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 823c97c:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 823c980:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 823c984:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 823c988:	d0e00215 	stw	r3,-32760(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 823c98c:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 823c990:	f800283a 	ret

0823c994 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 823c994:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 823c998:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 823c99c:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 823c9a0:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823c9a4:	823cb7c0 	call	823cb7c <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 823c9a8:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 823c9ac:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 823c9b0:	003fe506 	br	823c948 <OSCtxSw+0x40>

0823c9b4 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 823c9b4:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 823c9b8:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 823c9bc:	10800054 	ori	r2,r2,1
      wrctl status, r2
 823c9c0:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 823c9c4:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 823c9c8:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 823c9cc:	dec00204 	addi	sp,sp,8

      callr r2
 823c9d0:	103ee83a 	callr	r2

      nop
 823c9d4:	0001883a 	nop

0823c9d8 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 823c9d8:	defff704 	addi	sp,sp,-36
 823c9dc:	dfc00815 	stw	ra,32(sp)
 823c9e0:	df000715 	stw	fp,28(sp)
 823c9e4:	df000704 	addi	fp,sp,28
 823c9e8:	e13ffc15 	stw	r4,-16(fp)
 823c9ec:	e17ffd15 	stw	r5,-12(fp)
 823c9f0:	e1bffe15 	stw	r6,-8(fp)
 823c9f4:	3805883a 	mov	r2,r7
 823c9f8:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 823c9fc:	e0fffe17 	ldw	r3,-8(fp)
 823ca00:	00bfff04 	movi	r2,-4
 823ca04:	1884703a 	and	r2,r3,r2
 823ca08:	10bef704 	addi	r2,r2,-1060
 823ca0c:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 823ca10:	01810904 	movi	r6,1060
 823ca14:	000b883a 	mov	r5,zero
 823ca18:	e13ff917 	ldw	r4,-28(fp)
 823ca1c:	8202cb00 	call	8202cb0 <memset>
 823ca20:	e0bff917 	ldw	r2,-28(fp)
 823ca24:	10c0bb04 	addi	r3,r2,748
 823ca28:	e0bff917 	ldw	r2,-28(fp)
 823ca2c:	10c00115 	stw	r3,4(r2)
 823ca30:	e0bff917 	ldw	r2,-28(fp)
 823ca34:	10c0d504 	addi	r3,r2,852
 823ca38:	e0bff917 	ldw	r2,-28(fp)
 823ca3c:	10c00215 	stw	r3,8(r2)
 823ca40:	e0bff917 	ldw	r2,-28(fp)
 823ca44:	10c0ef04 	addi	r3,r2,956
 823ca48:	e0bff917 	ldw	r2,-28(fp)
 823ca4c:	10c00315 	stw	r3,12(r2)
 823ca50:	e0fff917 	ldw	r3,-28(fp)
 823ca54:	00820974 	movhi	r2,2085
 823ca58:	10826004 	addi	r2,r2,2432
 823ca5c:	18800d15 	stw	r2,52(r3)
 823ca60:	e0bff917 	ldw	r2,-28(fp)
 823ca64:	00c00044 	movi	r3,1
 823ca68:	10c02915 	stw	r3,164(r2)
 823ca6c:	10002a15 	stw	zero,168(r2)
 823ca70:	e0bff917 	ldw	r2,-28(fp)
 823ca74:	00ccc384 	movi	r3,13070
 823ca78:	10c02b0d 	sth	r3,172(r2)
 823ca7c:	e0bff917 	ldw	r2,-28(fp)
 823ca80:	00eaf344 	movi	r3,-21555
 823ca84:	10c02b8d 	sth	r3,174(r2)
 823ca88:	e0bff917 	ldw	r2,-28(fp)
 823ca8c:	00c48d04 	movi	r3,4660
 823ca90:	10c02c0d 	sth	r3,176(r2)
 823ca94:	e0bff917 	ldw	r2,-28(fp)
 823ca98:	00f99b44 	movi	r3,-6547
 823ca9c:	10c02c8d 	sth	r3,178(r2)
 823caa0:	e0bff917 	ldw	r2,-28(fp)
 823caa4:	00f7bb04 	movi	r3,-8468
 823caa8:	10c02d0d 	sth	r3,180(r2)
 823caac:	e0bff917 	ldw	r2,-28(fp)
 823cab0:	00c00144 	movi	r3,5
 823cab4:	10c02d8d 	sth	r3,182(r2)
 823cab8:	e0bff917 	ldw	r2,-28(fp)
 823cabc:	00c002c4 	movi	r3,11
 823cac0:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 823cac4:	e0bff917 	ldw	r2,-28(fp)
 823cac8:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 823cacc:	e0bffa17 	ldw	r2,-24(fp)
 823cad0:	10bff304 	addi	r2,r2,-52
 823cad4:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 823cad8:	e0bffb17 	ldw	r2,-20(fp)
 823cadc:	10800c04 	addi	r2,r2,48
 823cae0:	e0fffc17 	ldw	r3,-16(fp)
 823cae4:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 823cae8:	e0bffb17 	ldw	r2,-20(fp)
 823caec:	10800b04 	addi	r2,r2,44
 823caf0:	e0fffd17 	ldw	r3,-12(fp)
 823caf4:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 823caf8:	e0bffb17 	ldw	r2,-20(fp)
 823cafc:	10800a04 	addi	r2,r2,40
 823cb00:	e0fff917 	ldw	r3,-28(fp)
 823cb04:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 823cb08:	00820934 	movhi	r2,2084
 823cb0c:	10b26d04 	addi	r2,r2,-13900
 823cb10:	10c00104 	addi	r3,r2,4
 823cb14:	e0bffb17 	ldw	r2,-20(fp)
 823cb18:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 823cb1c:	e0bffb17 	ldw	r2,-20(fp)
}
 823cb20:	e037883a 	mov	sp,fp
 823cb24:	dfc00117 	ldw	ra,4(sp)
 823cb28:	df000017 	ldw	fp,0(sp)
 823cb2c:	dec00204 	addi	sp,sp,8
 823cb30:	f800283a 	ret

0823cb34 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 823cb34:	defffe04 	addi	sp,sp,-8
 823cb38:	df000115 	stw	fp,4(sp)
 823cb3c:	df000104 	addi	fp,sp,4
 823cb40:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 823cb44:	0001883a 	nop
 823cb48:	e037883a 	mov	sp,fp
 823cb4c:	df000017 	ldw	fp,0(sp)
 823cb50:	dec00104 	addi	sp,sp,4
 823cb54:	f800283a 	ret

0823cb58 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 823cb58:	defffe04 	addi	sp,sp,-8
 823cb5c:	df000115 	stw	fp,4(sp)
 823cb60:	df000104 	addi	fp,sp,4
 823cb64:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 823cb68:	0001883a 	nop
 823cb6c:	e037883a 	mov	sp,fp
 823cb70:	df000017 	ldw	fp,0(sp)
 823cb74:	dec00104 	addi	sp,sp,4
 823cb78:	f800283a 	ret

0823cb7c <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 823cb7c:	deffff04 	addi	sp,sp,-4
 823cb80:	df000015 	stw	fp,0(sp)
 823cb84:	d839883a 	mov	fp,sp
}
 823cb88:	0001883a 	nop
 823cb8c:	e037883a 	mov	sp,fp
 823cb90:	df000017 	ldw	fp,0(sp)
 823cb94:	dec00104 	addi	sp,sp,4
 823cb98:	f800283a 	ret

0823cb9c <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 823cb9c:	deffff04 	addi	sp,sp,-4
 823cba0:	df000015 	stw	fp,0(sp)
 823cba4:	d839883a 	mov	fp,sp
}
 823cba8:	0001883a 	nop
 823cbac:	e037883a 	mov	sp,fp
 823cbb0:	df000017 	ldw	fp,0(sp)
 823cbb4:	dec00104 	addi	sp,sp,4
 823cbb8:	f800283a 	ret

0823cbbc <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 823cbbc:	defffe04 	addi	sp,sp,-8
 823cbc0:	dfc00115 	stw	ra,4(sp)
 823cbc4:	df000015 	stw	fp,0(sp)
 823cbc8:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 823cbcc:	822d3440 	call	822d344 <cticks_hook>
#endif
}
 823cbd0:	0001883a 	nop
 823cbd4:	e037883a 	mov	sp,fp
 823cbd8:	dfc00117 	ldw	ra,4(sp)
 823cbdc:	df000017 	ldw	fp,0(sp)
 823cbe0:	dec00204 	addi	sp,sp,8
 823cbe4:	f800283a 	ret

0823cbe8 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 823cbe8:	deffff04 	addi	sp,sp,-4
 823cbec:	df000015 	stw	fp,0(sp)
 823cbf0:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 823cbf4:	0001883a 	nop
 823cbf8:	e037883a 	mov	sp,fp
 823cbfc:	df000017 	ldw	fp,0(sp)
 823cc00:	dec00104 	addi	sp,sp,4
 823cc04:	f800283a 	ret

0823cc08 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 823cc08:	deffff04 	addi	sp,sp,-4
 823cc0c:	df000015 	stw	fp,0(sp)
 823cc10:	d839883a 	mov	fp,sp
}
 823cc14:	0001883a 	nop
 823cc18:	e037883a 	mov	sp,fp
 823cc1c:	df000017 	ldw	fp,0(sp)
 823cc20:	dec00104 	addi	sp,sp,4
 823cc24:	f800283a 	ret

0823cc28 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 823cc28:	deffff04 	addi	sp,sp,-4
 823cc2c:	df000015 	stw	fp,0(sp)
 823cc30:	d839883a 	mov	fp,sp
}
 823cc34:	0001883a 	nop
 823cc38:	e037883a 	mov	sp,fp
 823cc3c:	df000017 	ldw	fp,0(sp)
 823cc40:	dec00104 	addi	sp,sp,4
 823cc44:	f800283a 	ret

0823cc48 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 823cc48:	defffe04 	addi	sp,sp,-8
 823cc4c:	df000115 	stw	fp,4(sp)
 823cc50:	df000104 	addi	fp,sp,4
 823cc54:	e13fff15 	stw	r4,-4(fp)
}
 823cc58:	0001883a 	nop
 823cc5c:	e037883a 	mov	sp,fp
 823cc60:	df000017 	ldw	fp,0(sp)
 823cc64:	dec00104 	addi	sp,sp,4
 823cc68:	f800283a 	ret

0823cc6c <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 823cc6c:	defffb04 	addi	sp,sp,-20
 823cc70:	dfc00415 	stw	ra,16(sp)
 823cc74:	df000315 	stw	fp,12(sp)
 823cc78:	dc000215 	stw	r16,8(sp)
 823cc7c:	df000304 	addi	fp,sp,12
   int   e = 0;
 823cc80:	e03ffd15 	stw	zero,-12(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 823cc84:	d0a04b17 	ldw	r2,-32468(gp)
 823cc88:	1009883a 	mov	r4,r2
 823cc8c:	82031200 	call	8203120 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 823cc90:	01020974 	movhi	r4,2085
 823cc94:	21026c04 	addi	r4,r4,2480
 823cc98:	82031200 	call	8203120 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 823cc9c:	822db100 	call	822db10 <pre_task_setup>
 823cca0:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823cca4:	e0bffe17 	ldw	r2,-8(fp)
 823cca8:	10000226 	beq	r2,zero,823ccb4 <netmain_init+0x48>
      panic(msg);
 823ccac:	e13ffe17 	ldw	r4,-8(fp)
 823ccb0:	822887c0 	call	822887c <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 823ccb4:	82264b80 	call	82264b8 <ip_startup>
 823ccb8:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823ccbc:	e0bffe17 	ldw	r2,-8(fp)
 823ccc0:	10000726 	beq	r2,zero,823cce0 <netmain_init+0x74>
   {
      printf("inet startup error: %s\n", msg);
 823ccc4:	e17ffe17 	ldw	r5,-8(fp)
 823ccc8:	01020974 	movhi	r4,2085
 823cccc:	21027e04 	addi	r4,r4,2552
 823ccd0:	8202e9c0 	call	8202e9c <printf>
      panic("IP");
 823ccd4:	01020974 	movhi	r4,2085
 823ccd8:	21028404 	addi	r4,r4,2576
 823ccdc:	822887c0 	call	822887c <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 823cce0:	8246db80 	call	8246db8 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 823cce4:	82463580 	call	8246358 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 823cce8:	d0208315 	stw	zero,-32244(gp)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823ccec:	008209b4 	movhi	r2,2086
 823ccf0:	10b8f304 	addi	r2,r2,-7220
 823ccf4:	10800017 	ldw	r2,0(r2)
 823ccf8:	14000104 	addi	r16,r2,4
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 823ccfc:	008209b4 	movhi	r2,2086
 823cd00:	10b8f304 	addi	r2,r2,-7220
 823cd04:	10800017 	ldw	r2,0(r2)
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823cd08:	10800a17 	ldw	r2,40(r2)
 823cd0c:	1009883a 	mov	r4,r2
 823cd10:	82286280 	call	8228628 <print_ipad>
 823cd14:	100d883a 	mov	r6,r2
 823cd18:	800b883a 	mov	r5,r16
 823cd1c:	01020974 	movhi	r4,2085
 823cd20:	21028504 	addi	r4,r4,2580
 823cd24:	8202e9c0 	call	8202e9c <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 823cd28:	822db5c0 	call	822db5c <post_task_setup>
 823cd2c:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823cd30:	e0bffe17 	ldw	r2,-8(fp)
 823cd34:	10000226 	beq	r2,zero,823cd40 <netmain_init+0xd4>
      panic(msg);
 823cd38:	e13ffe17 	ldw	r4,-8(fp)
 823cd3c:	822887c0 	call	822887c <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 823cd40:	8246a400 	call	8246a40 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 823cd44:	0001883a 	nop
 823cd48:	e6ffff04 	addi	sp,fp,-4
 823cd4c:	dfc00217 	ldw	ra,8(sp)
 823cd50:	df000117 	ldw	fp,4(sp)
 823cd54:	dc000017 	ldw	r16,0(sp)
 823cd58:	dec00304 	addi	sp,sp,12
 823cd5c:	f800283a 	ret

0823cd60 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 823cd60:	defffb04 	addi	sp,sp,-20
 823cd64:	dfc00415 	stw	ra,16(sp)
 823cd68:	df000315 	stw	fp,12(sp)
 823cd6c:	dc000215 	stw	r16,8(sp)
 823cd70:	df000304 	addi	fp,sp,12
 823cd74:	e13ffd15 	stw	r4,-12(fp)
 823cd78:	e17ffe15 	stw	r5,-8(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 823cd7c:	e0bffe17 	ldw	r2,-8(fp)
 823cd80:	10800003 	ldbu	r2,0(r2)
 823cd84:	10c03fcc 	andi	r3,r2,255
 823cd88:	18c0201c 	xori	r3,r3,128
 823cd8c:	18ffe004 	addi	r3,r3,-128
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 823cd90:	00820974 	movhi	r2,2085
 823cd94:	108dca04 	addi	r2,r2,14120
 823cd98:	18c7883a 	add	r3,r3,r3
 823cd9c:	18c7883a 	add	r3,r3,r3
 823cda0:	10c5883a 	add	r2,r2,r3
 823cda4:	14000017 	ldw	r16,0(r2)
 823cda8:	e0bffd17 	ldw	r2,-12(fp)
 823cdac:	10800717 	ldw	r2,28(r2)
 823cdb0:	1009883a 	mov	r4,r2
 823cdb4:	82286280 	call	8228628 <print_ipad>
 823cdb8:	100d883a 	mov	r6,r2
 823cdbc:	800b883a 	mov	r5,r16
 823cdc0:	01020974 	movhi	r4,2085
 823cdc4:	21029504 	addi	r4,r4,2644
 823cdc8:	8202e9c0 	call	8202e9c <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 823cdcc:	d0a04c17 	ldw	r2,-32464(gp)
 823cdd0:	1009883a 	mov	r4,r2
 823cdd4:	8202e9c0 	call	8202e9c <printf>
}
 823cdd8:	0001883a 	nop
 823cddc:	e6ffff04 	addi	sp,fp,-4
 823cde0:	dfc00217 	ldw	ra,8(sp)
 823cde4:	df000117 	ldw	fp,4(sp)
 823cde8:	dc000017 	ldw	r16,0(sp)
 823cdec:	dec00304 	addi	sp,sp,12
 823cdf0:	f800283a 	ret

0823cdf4 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 823cdf4:	defff904 	addi	sp,sp,-28
 823cdf8:	dfc00615 	stw	ra,24(sp)
 823cdfc:	df000515 	stw	fp,20(sp)
 823ce00:	dc000415 	stw	r16,16(sp)
 823ce04:	df000504 	addi	fp,sp,20
 823ce08:	e13ffe15 	stw	r4,-8(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823ce0c:	e03ffc15 	stw	zero,-16(fp)
 823ce10:	008209b4 	movhi	r2,2086
 823ce14:	10b8f304 	addi	r2,r2,-7220
 823ce18:	10800017 	ldw	r2,0(r2)
 823ce1c:	e0bffd15 	stw	r2,-12(fp)
 823ce20:	00002506 	br	823ceb8 <station_state+0xc4>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
 823ce24:	e0bffd17 	ldw	r2,-12(fp)
 823ce28:	14000104 	addi	r16,r2,4
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 823ce2c:	e0bffd17 	ldw	r2,-12(fp)
 823ce30:	10800a17 	ldw	r2,40(r2)
 823ce34:	1009883a 	mov	r4,r2
 823ce38:	82286280 	call	8228628 <print_ipad>
 823ce3c:	d8800015 	stw	r2,0(sp)
 823ce40:	800f883a 	mov	r7,r16
 823ce44:	e1bffc17 	ldw	r6,-16(fp)
 823ce48:	01420974 	movhi	r5,2085
 823ce4c:	29429e04 	addi	r5,r5,2680
 823ce50:	e13ffe17 	ldw	r4,-8(fp)
 823ce54:	8228a940 	call	8228a94 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 823ce58:	e0bffd17 	ldw	r2,-12(fp)
 823ce5c:	10800c17 	ldw	r2,48(r2)
 823ce60:	1009883a 	mov	r4,r2
 823ce64:	82286280 	call	8228628 <print_ipad>
 823ce68:	100d883a 	mov	r6,r2
 823ce6c:	01420974 	movhi	r5,2085
 823ce70:	2942a504 	addi	r5,r5,2708
 823ce74:	e13ffe17 	ldw	r4,-8(fp)
 823ce78:	8228a940 	call	8228a94 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 823ce7c:	e0bffd17 	ldw	r2,-12(fp)
 823ce80:	10800d17 	ldw	r2,52(r2)
 823ce84:	1009883a 	mov	r4,r2
 823ce88:	82286280 	call	8228628 <print_ipad>
 823ce8c:	100d883a 	mov	r6,r2
 823ce90:	01420974 	movhi	r5,2085
 823ce94:	2942a804 	addi	r5,r5,2720
 823ce98:	e13ffe17 	ldw	r4,-8(fp)
 823ce9c:	8228a940 	call	8228a94 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823cea0:	e0bffd17 	ldw	r2,-12(fp)
 823cea4:	10800017 	ldw	r2,0(r2)
 823cea8:	e0bffd15 	stw	r2,-12(fp)
 823ceac:	e0bffc17 	ldw	r2,-16(fp)
 823ceb0:	10800044 	addi	r2,r2,1
 823ceb4:	e0bffc15 	stw	r2,-16(fp)
 823ceb8:	e0bffd17 	ldw	r2,-12(fp)
 823cebc:	103fd91e 	bne	r2,zero,823ce24 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 823cec0:	d0a0a817 	ldw	r2,-32096(gp)
 823cec4:	100d883a 	mov	r6,r2
 823cec8:	01420974 	movhi	r5,2085
 823cecc:	2942ab04 	addi	r5,r5,2732
 823ced0:	e13ffe17 	ldw	r4,-8(fp)
 823ced4:	8228a940 	call	8228a94 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 823ced8:	d0e04d17 	ldw	r3,-32460(gp)
 823cedc:	d0a04d17 	ldw	r2,-32460(gp)
 823cee0:	108002a4 	muli	r2,r2,10
 823cee4:	100f883a 	mov	r7,r2
 823cee8:	180d883a 	mov	r6,r3
 823ceec:	01420974 	movhi	r5,2085
 823cef0:	2942b104 	addi	r5,r5,2756
 823cef4:	e13ffe17 	ldw	r4,-8(fp)
 823cef8:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 823cefc:	d0a0ba17 	ldw	r2,-32024(gp)
 823cf00:	1009883a 	mov	r4,r2
 823cf04:	82286280 	call	8228628 <print_ipad>
 823cf08:	100d883a 	mov	r6,r2
 823cf0c:	01420974 	movhi	r5,2085
 823cf10:	2942bd04 	addi	r5,r5,2804
 823cf14:	e13ffe17 	ldw	r4,-8(fp)
 823cf18:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 823cf1c:	d0a04e17 	ldw	r2,-32456(gp)
 823cf20:	100d883a 	mov	r6,r2
 823cf24:	01420974 	movhi	r5,2085
 823cf28:	2942c404 	addi	r5,r5,2832
 823cf2c:	e13ffe17 	ldw	r4,-8(fp)
 823cf30:	8228a940 	call	8228a94 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 823cf34:	e13ffe17 	ldw	r4,-8(fp)
 823cf38:	823d4980 	call	823d498 <task_stats>

   return 0;
 823cf3c:	0005883a 	mov	r2,zero
}
 823cf40:	e6ffff04 	addi	sp,fp,-4
 823cf44:	dfc00217 	ldw	ra,8(sp)
 823cf48:	df000117 	ldw	fp,4(sp)
 823cf4c:	dc000017 	ldw	r16,0(sp)
 823cf50:	dec00304 	addi	sp,sp,12
 823cf54:	f800283a 	ret

0823cf58 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 823cf58:	deffff04 	addi	sp,sp,-4
 823cf5c:	df000015 	stw	fp,0(sp)
 823cf60:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 823cf64:	d160a817 	ldw	r5,-32096(gp)
 823cf68:	00947b34 	movhi	r2,20972
 823cf6c:	10a147c4 	addi	r2,r2,-31457
 823cf70:	288c383a 	mulxuu	r6,r5,r2
 823cf74:	2885383a 	mul	r2,r5,r2
 823cf78:	1007883a 	mov	r3,r2
 823cf7c:	3009883a 	mov	r4,r6
 823cf80:	2004d17a 	srli	r2,r4,5
 823cf84:	10801924 	muli	r2,r2,100
}
 823cf88:	e037883a 	mov	sp,fp
 823cf8c:	df000017 	ldw	fp,0(sp)
 823cf90:	dec00104 	addi	sp,sp,4
 823cf94:	f800283a 	ret

0823cf98 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 823cf98:	defffe04 	addi	sp,sp,-8
 823cf9c:	dfc00115 	stw	ra,4(sp)
 823cfa0:	df000015 	stw	fp,0(sp)
 823cfa4:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 823cfa8:	d0a0bb17 	ldw	r2,-32020(gp)
 823cfac:	1000081e 	bne	r2,zero,823cfd0 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 823cfb0:	d0a0bb17 	ldw	r2,-32020(gp)
 823cfb4:	10800044 	addi	r2,r2,1
 823cfb8:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 823cfbc:	8225ef80 	call	8225ef8 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 823cfc0:	d0a0bb17 	ldw	r2,-32020(gp)
 823cfc4:	10bfffc4 	addi	r2,r2,-1
 823cfc8:	d0a0bb15 	stw	r2,-32020(gp)
 823cfcc:	00000106 	br	823cfd4 <packet_check+0x3c>

void
packet_check(void)
{
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
      return;           /* do not re-enter pktdemux(), packet will wait... */
 823cfd0:	0001883a 	nop
   inside_pktdemux++;   /* set re-entrany flag */
   pktdemux();          /* process low level packet input */
   inside_pktdemux--;   /* clear re-entrany flag */
}
 823cfd4:	e037883a 	mov	sp,fp
 823cfd8:	dfc00117 	ldw	ra,4(sp)
 823cfdc:	df000017 	ldw	fp,0(sp)
 823cfe0:	dec00204 	addi	sp,sp,8
 823cfe4:	f800283a 	ret

0823cfe8 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 823cfe8:	defffe04 	addi	sp,sp,-8
 823cfec:	df000115 	stw	fp,4(sp)
 823cff0:	df000104 	addi	fp,sp,4
 823cff4:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 823cff8:	0005883a 	mov	r2,zero
}
 823cffc:	e037883a 	mov	sp,fp
 823d000:	df000017 	ldw	fp,0(sp)
 823d004:	dec00104 	addi	sp,sp,4
 823d008:	f800283a 	ret

0823d00c <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 823d00c:	defffd04 	addi	sp,sp,-12
 823d010:	dfc00215 	stw	ra,8(sp)
 823d014:	df000115 	stw	fp,4(sp)
 823d018:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 823d01c:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 823d020:	8249bf80 	call	8249bf8 <prep_vfs>
 823d024:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 823d028:	e0bfff17 	ldw	r2,-4(fp)
 823d02c:	10000626 	beq	r2,zero,823d048 <prep_modules+0x3c>
   {
      dprintf("VFS Module prep failed\n");
 823d030:	01020974 	movhi	r4,2085
 823d034:	2102cc04 	addi	r4,r4,2864
 823d038:	82031200 	call	8203120 <puts>
      panic("prep_modules");
 823d03c:	01020974 	movhi	r4,2085
 823d040:	2102d204 	addi	r4,r4,2888
 823d044:	822887c0 	call	822887c <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 823d048:	0005883a 	mov	r2,zero
}
 823d04c:	e037883a 	mov	sp,fp
 823d050:	dfc00117 	ldw	ra,4(sp)
 823d054:	df000017 	ldw	fp,0(sp)
 823d058:	dec00204 	addi	sp,sp,8
 823d05c:	f800283a 	ret

0823d060 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 823d060:	defffe04 	addi	sp,sp,-8
 823d064:	dfc00115 	stw	ra,4(sp)
 823d068:	df000015 	stw	fp,0(sp)
 823d06c:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 823d070:	d0e0c917 	ldw	r3,-31964(gp)
 823d074:	d0a0a817 	ldw	r2,-32096(gp)
 823d078:	1880012e 	bgeu	r3,r2,823d080 <inet_timer+0x20>
      ip_reasm_process_timer_tick ();
 823d07c:	82421200 	call	8242120 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 823d080:	822f62c0 	call	822f62c <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 823d084:	823d0ec0 	call	823d0ec <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 823d088:	d0e08717 	ldw	r3,-32228(gp)
 823d08c:	d0a0a817 	ldw	r2,-32096(gp)
 823d090:	1880012e 	bgeu	r3,r2,823d098 <inet_timer+0x38>
      igmp_fasttimo();
 823d094:	8226aa40 	call	8226aa4 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d098:	d0e0bc17 	ldw	r3,-32016(gp)
 823d09c:	d0a0a817 	ldw	r2,-32096(gp)
 823d0a0:	18800436 	bltu	r3,r2,823d0b4 <inet_timer+0x54>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
 823d0a4:	d0a0a817 	ldw	r2,-32096(gp)
 823d0a8:	10c0fa04 	addi	r3,r2,1000
 823d0ac:	d0a0bc17 	ldw	r2,-32016(gp)
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d0b0:	1880082e 	bgeu	r3,r2,823d0d4 <inet_timer+0x74>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 823d0b4:	d0a0a817 	ldw	r2,-32096(gp)
 823d0b8:	10801904 	addi	r2,r2,100
 823d0bc:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 823d0c0:	d0a0bd17 	ldw	r2,-32012(gp)
 823d0c4:	10000226 	beq	r2,zero,823d0d0 <inet_timer+0x70>
         (*port_1s_callout)();
 823d0c8:	d0a0bd17 	ldw	r2,-32012(gp)
 823d0cc:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 823d0d0:	822b9440 	call	822b944 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 823d0d4:	0001883a 	nop
 823d0d8:	e037883a 	mov	sp,fp
 823d0dc:	dfc00117 	ldw	ra,4(sp)
 823d0e0:	df000017 	ldw	fp,0(sp)
 823d0e4:	dec00204 	addi	sp,sp,8
 823d0e8:	f800283a 	ret

0823d0ec <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 823d0ec:	defffc04 	addi	sp,sp,-16
 823d0f0:	dfc00315 	stw	ra,12(sp)
 823d0f4:	df000215 	stw	fp,8(sp)
 823d0f8:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 823d0fc:	e03fff15 	stw	zero,-4(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 823d100:	d0a0be17 	ldw	r2,-32008(gp)
 823d104:	0080560e 	bge	zero,r2,823d260 <check_interval_timers+0x174>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d108:	e03ffe15 	stw	zero,-8(fp)
 823d10c:	00004f06 	br	823d24c <check_interval_timers+0x160>
      {
         if (intimers[i].callback)   /* is this timer active? */
 823d110:	008209b4 	movhi	r2,2086
 823d114:	10b89a04 	addi	r2,r2,-7576
 823d118:	e0fffe17 	ldw	r3,-8(fp)
 823d11c:	18c00524 	muli	r3,r3,20
 823d120:	10c5883a 	add	r2,r2,r3
 823d124:	10800017 	ldw	r2,0(r2)
 823d128:	10004526 	beq	r2,zero,823d240 <check_interval_timers+0x154>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 823d12c:	008209b4 	movhi	r2,2086
 823d130:	10b89a04 	addi	r2,r2,-7576
 823d134:	e0fffe17 	ldw	r3,-8(fp)
 823d138:	18c00524 	muli	r3,r3,20
 823d13c:	10c5883a 	add	r2,r2,r3
 823d140:	10800304 	addi	r2,r2,12
 823d144:	10c00017 	ldw	r3,0(r2)
 823d148:	d0a0a817 	ldw	r2,-32096(gp)
 823d14c:	1880362e 	bgeu	r3,r2,823d228 <check_interval_timers+0x13c>
 823d150:	008209b4 	movhi	r2,2086
 823d154:	10b89a04 	addi	r2,r2,-7576
 823d158:	e0fffe17 	ldw	r3,-8(fp)
 823d15c:	18c00524 	muli	r3,r3,20
 823d160:	10c5883a 	add	r2,r2,r3
 823d164:	10800404 	addi	r2,r2,16
 823d168:	10800017 	ldw	r2,0(r2)
 823d16c:	10002e1e 	bne	r2,zero,823d228 <check_interval_timers+0x13c>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 823d170:	008209b4 	movhi	r2,2086
 823d174:	10b89a04 	addi	r2,r2,-7576
 823d178:	e0fffe17 	ldw	r3,-8(fp)
 823d17c:	18c00524 	muli	r3,r3,20
 823d180:	10c5883a 	add	r2,r2,r3
 823d184:	10800204 	addi	r2,r2,8
 823d188:	10c00017 	ldw	r3,0(r2)
 823d18c:	d0a0a817 	ldw	r2,-32096(gp)
 823d190:	1887883a 	add	r3,r3,r2
 823d194:	008209b4 	movhi	r2,2086
 823d198:	10b89a04 	addi	r2,r2,-7576
 823d19c:	e13ffe17 	ldw	r4,-8(fp)
 823d1a0:	21000524 	muli	r4,r4,20
 823d1a4:	1105883a 	add	r2,r2,r4
 823d1a8:	10800304 	addi	r2,r2,12
 823d1ac:	10c00015 	stw	r3,0(r2)
               intimers[i].inuse = TRUE;
 823d1b0:	008209b4 	movhi	r2,2086
 823d1b4:	10b89a04 	addi	r2,r2,-7576
 823d1b8:	e0fffe17 	ldw	r3,-8(fp)
 823d1bc:	18c00524 	muli	r3,r3,20
 823d1c0:	10c5883a 	add	r2,r2,r3
 823d1c4:	10800404 	addi	r2,r2,16
 823d1c8:	00c00044 	movi	r3,1
 823d1cc:	10c00015 	stw	r3,0(r2)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 823d1d0:	008209b4 	movhi	r2,2086
 823d1d4:	10b89a04 	addi	r2,r2,-7576
 823d1d8:	e0fffe17 	ldw	r3,-8(fp)
 823d1dc:	18c00524 	muli	r3,r3,20
 823d1e0:	10c5883a 	add	r2,r2,r3
 823d1e4:	10c00017 	ldw	r3,0(r2)
 823d1e8:	008209b4 	movhi	r2,2086
 823d1ec:	10b89a04 	addi	r2,r2,-7576
 823d1f0:	e13ffe17 	ldw	r4,-8(fp)
 823d1f4:	21000524 	muli	r4,r4,20
 823d1f8:	1105883a 	add	r2,r2,r4
 823d1fc:	10800104 	addi	r2,r2,4
 823d200:	10800017 	ldw	r2,0(r2)
 823d204:	1009883a 	mov	r4,r2
 823d208:	183ee83a 	callr	r3
               intimers[i].inuse = FALSE;
 823d20c:	008209b4 	movhi	r2,2086
 823d210:	10b89a04 	addi	r2,r2,-7576
 823d214:	e0fffe17 	ldw	r3,-8(fp)
 823d218:	18c00524 	muli	r3,r3,20
 823d21c:	10c5883a 	add	r2,r2,r3
 823d220:	10800404 	addi	r2,r2,16
 823d224:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 823d228:	e0bfff17 	ldw	r2,-4(fp)
 823d22c:	10800044 	addi	r2,r2,1
 823d230:	e0bfff15 	stw	r2,-4(fp)
 823d234:	d0a0be17 	ldw	r2,-32008(gp)
 823d238:	e0ffff17 	ldw	r3,-4(fp)
 823d23c:	1880070e 	bge	r3,r2,823d25c <check_interval_timers+0x170>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d240:	e0bffe17 	ldw	r2,-8(fp)
 823d244:	10800044 	addi	r2,r2,1
 823d248:	e0bffe15 	stw	r2,-8(fp)
 823d24c:	e0bffe17 	ldw	r2,-8(fp)
 823d250:	10800150 	cmplti	r2,r2,5
 823d254:	103fae1e 	bne	r2,zero,823d110 <check_interval_timers+0x24>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 823d258:	00000106 	br	823d260 <check_interval_timers+0x174>
               intimers[i].callback(intimers[i].parm);      /* call user routine */
               intimers[i].inuse = FALSE;
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
               break;
 823d25c:	0001883a 	nop
         }
      }
   }
}
 823d260:	0001883a 	nop
 823d264:	e037883a 	mov	sp,fp
 823d268:	dfc00117 	ldw	ra,4(sp)
 823d26c:	df000017 	ldw	fp,0(sp)
 823d270:	dec00204 	addi	sp,sp,8
 823d274:	f800283a 	ret

0823d278 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 823d278:	defffa04 	addi	sp,sp,-24
 823d27c:	dfc00515 	stw	ra,20(sp)
 823d280:	df000415 	stw	fp,16(sp)
 823d284:	df000404 	addi	fp,sp,16
 823d288:	e13ffd15 	stw	r4,-12(fp)
 823d28c:	e17ffe15 	stw	r5,-8(fp)
 823d290:	e1bfff15 	stw	r6,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d294:	e03ffc15 	stw	zero,-16(fp)
 823d298:	00004606 	br	823d3b4 <in_timerset+0x13c>
   {
      if(intimers[i].callback == NULL)
 823d29c:	008209b4 	movhi	r2,2086
 823d2a0:	10b89a04 	addi	r2,r2,-7576
 823d2a4:	e0fffc17 	ldw	r3,-16(fp)
 823d2a8:	18c00524 	muli	r3,r3,20
 823d2ac:	10c5883a 	add	r2,r2,r3
 823d2b0:	10800017 	ldw	r2,0(r2)
 823d2b4:	10003c1e 	bne	r2,zero,823d3a8 <in_timerset+0x130>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 823d2b8:	008209b4 	movhi	r2,2086
 823d2bc:	10b89a04 	addi	r2,r2,-7576
 823d2c0:	e0fffc17 	ldw	r3,-16(fp)
 823d2c4:	18c00524 	muli	r3,r3,20
 823d2c8:	10c5883a 	add	r2,r2,r3
 823d2cc:	e0fffd17 	ldw	r3,-12(fp)
 823d2d0:	10c00015 	stw	r3,0(r2)
         intimers[i].parm = parm;
 823d2d4:	008209b4 	movhi	r2,2086
 823d2d8:	10b89a04 	addi	r2,r2,-7576
 823d2dc:	e0fffc17 	ldw	r3,-16(fp)
 823d2e0:	18c00524 	muli	r3,r3,20
 823d2e4:	10c5883a 	add	r2,r2,r3
 823d2e8:	10800104 	addi	r2,r2,4
 823d2ec:	e0ffff17 	ldw	r3,-4(fp)
 823d2f0:	10c00015 	stw	r3,0(r2)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 823d2f4:	e0bffe17 	ldw	r2,-8(fp)
 823d2f8:	10801924 	muli	r2,r2,100
 823d2fc:	0140fa04 	movi	r5,1000
 823d300:	1009883a 	mov	r4,r2
 823d304:	82026140 	call	8202614 <__divsi3>
 823d308:	1009883a 	mov	r4,r2
 823d30c:	008209b4 	movhi	r2,2086
 823d310:	10b89a04 	addi	r2,r2,-7576
 823d314:	e0fffc17 	ldw	r3,-16(fp)
 823d318:	18c00524 	muli	r3,r3,20
 823d31c:	10c5883a 	add	r2,r2,r3
 823d320:	10800204 	addi	r2,r2,8
 823d324:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 823d328:	008209b4 	movhi	r2,2086
 823d32c:	10b89a04 	addi	r2,r2,-7576
 823d330:	e0fffc17 	ldw	r3,-16(fp)
 823d334:	18c00524 	muli	r3,r3,20
 823d338:	10c5883a 	add	r2,r2,r3
 823d33c:	10800204 	addi	r2,r2,8
 823d340:	10c00017 	ldw	r3,0(r2)
 823d344:	d0a0a817 	ldw	r2,-32096(gp)
 823d348:	1887883a 	add	r3,r3,r2
 823d34c:	008209b4 	movhi	r2,2086
 823d350:	10b89a04 	addi	r2,r2,-7576
 823d354:	e13ffc17 	ldw	r4,-16(fp)
 823d358:	21000524 	muli	r4,r4,20
 823d35c:	1105883a 	add	r2,r2,r4
 823d360:	10800304 	addi	r2,r2,12
 823d364:	10c00015 	stw	r3,0(r2)
		 intimers[i].inuse = FALSE;
 823d368:	008209b4 	movhi	r2,2086
 823d36c:	10b89a04 	addi	r2,r2,-7576
 823d370:	e0fffc17 	ldw	r3,-16(fp)
 823d374:	18c00524 	muli	r3,r3,20
 823d378:	10c5883a 	add	r2,r2,r3
 823d37c:	10800404 	addi	r2,r2,16
 823d380:	10000015 	stw	zero,0(r2)
         numtimers++;
 823d384:	d0a0be17 	ldw	r2,-32008(gp)
 823d388:	10800044 	addi	r2,r2,1
 823d38c:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 823d390:	e0bffc17 	ldw	r2,-16(fp)
 823d394:	10c00524 	muli	r3,r2,20
 823d398:	008209b4 	movhi	r2,2086
 823d39c:	10b89a04 	addi	r2,r2,-7576
 823d3a0:	1885883a 	add	r2,r3,r2
 823d3a4:	00000706 	br	823d3c4 <in_timerset+0x14c>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d3a8:	e0bffc17 	ldw	r2,-16(fp)
 823d3ac:	10800044 	addi	r2,r2,1
 823d3b0:	e0bffc15 	stw	r2,-16(fp)
 823d3b4:	e0bffc17 	ldw	r2,-16(fp)
 823d3b8:	10800150 	cmplti	r2,r2,5
 823d3bc:	103fb71e 	bne	r2,zero,823d29c <in_timerset+0x24>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 823d3c0:	0005883a 	mov	r2,zero
}
 823d3c4:	e037883a 	mov	sp,fp
 823d3c8:	dfc00117 	ldw	ra,4(sp)
 823d3cc:	df000017 	ldw	fp,0(sp)
 823d3d0:	dec00204 	addi	sp,sp,8
 823d3d4:	f800283a 	ret

0823d3d8 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 823d3d8:	defffc04 	addi	sp,sp,-16
 823d3dc:	dfc00315 	stw	ra,12(sp)
 823d3e0:	df000215 	stw	fp,8(sp)
 823d3e4:	df000204 	addi	fp,sp,8
 823d3e8:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d3ec:	e03ffe15 	stw	zero,-8(fp)
 823d3f0:	00001606 	br	823d44c <in_timerkill+0x74>
   {
      if(timer == (long)&intimers[i])
 823d3f4:	e0bffe17 	ldw	r2,-8(fp)
 823d3f8:	10c00524 	muli	r3,r2,20
 823d3fc:	008209b4 	movhi	r2,2086
 823d400:	10b89a04 	addi	r2,r2,-7576
 823d404:	1885883a 	add	r2,r3,r2
 823d408:	1007883a 	mov	r3,r2
 823d40c:	e0bfff17 	ldw	r2,-4(fp)
 823d410:	18800b1e 	bne	r3,r2,823d440 <in_timerkill+0x68>
      {
         intimers[i].callback = NULL;
 823d414:	008209b4 	movhi	r2,2086
 823d418:	10b89a04 	addi	r2,r2,-7576
 823d41c:	e0fffe17 	ldw	r3,-8(fp)
 823d420:	18c00524 	muli	r3,r3,20
 823d424:	10c5883a 	add	r2,r2,r3
 823d428:	10000015 	stw	zero,0(r2)
         numtimers--;
 823d42c:	d0a0be17 	ldw	r2,-32008(gp)
 823d430:	10bfffc4 	addi	r2,r2,-1
 823d434:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 823d438:	0005883a 	mov	r2,zero
 823d43c:	00000806 	br	823d460 <in_timerkill+0x88>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d440:	e0bffe17 	ldw	r2,-8(fp)
 823d444:	10800044 	addi	r2,r2,1
 823d448:	e0bffe15 	stw	r2,-8(fp)
 823d44c:	e0bffe17 	ldw	r2,-8(fp)
 823d450:	10800150 	cmplti	r2,r2,5
 823d454:	103fe71e 	bne	r2,zero,823d3f4 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 823d458:	822d1c80 	call	822d1c8 <dtrap>
   return ENP_PARAM;
 823d45c:	00bffd84 	movi	r2,-10
}
 823d460:	e037883a 	mov	sp,fp
 823d464:	dfc00117 	ldw	ra,4(sp)
 823d468:	df000017 	ldw	fp,0(sp)
 823d46c:	dec00204 	addi	sp,sp,8
 823d470:	f800283a 	ret

0823d474 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 823d474:	defffe04 	addi	sp,sp,-8
 823d478:	df000115 	stw	fp,4(sp)
 823d47c:	df000104 	addi	fp,sp,4
int e = 0;
 823d480:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 823d484:	e0bfff17 	ldw	r2,-4(fp)
}
 823d488:	e037883a 	mov	sp,fp
 823d48c:	df000017 	ldw	fp,0(sp)
 823d490:	dec00104 	addi	sp,sp,4
 823d494:	f800283a 	ret

0823d498 <task_stats>:
 */


void
task_stats(void * pio)
{
 823d498:	defffd04 	addi	sp,sp,-12
 823d49c:	dfc00215 	stw	ra,8(sp)
 823d4a0:	df000115 	stw	fp,4(sp)
 823d4a4:	df000104 	addi	fp,sp,4
 823d4a8:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 823d4ac:	01420974 	movhi	r5,2085
 823d4b0:	2942d604 	addi	r5,r5,2904
 823d4b4:	e13fff17 	ldw	r4,-4(fp)
 823d4b8:	8228a940 	call	8228a94 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 823d4bc:	d0a08a17 	ldw	r2,-32216(gp)
 823d4c0:	100d883a 	mov	r6,r2
 823d4c4:	01420974 	movhi	r5,2085
 823d4c8:	2942da04 	addi	r5,r5,2920
 823d4cc:	e13fff17 	ldw	r4,-4(fp)
 823d4d0:	8228a940 	call	8228a94 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 823d4d4:	d0a08b17 	ldw	r2,-32212(gp)
 823d4d8:	100d883a 	mov	r6,r2
 823d4dc:	01420974 	movhi	r5,2085
 823d4e0:	2942de04 	addi	r5,r5,2936
 823d4e4:	e13fff17 	ldw	r4,-4(fp)
 823d4e8:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 823d4ec:	01420974 	movhi	r5,2085
 823d4f0:	2942e204 	addi	r5,r5,2952
 823d4f4:	e13fff17 	ldw	r4,-4(fp)
 823d4f8:	8228a940 	call	8228a94 <ns_printf>
}
 823d4fc:	0001883a 	nop
 823d500:	e037883a 	mov	sp,fp
 823d504:	dfc00117 	ldw	ra,4(sp)
 823d508:	df000017 	ldw	fp,0(sp)
 823d50c:	dec00204 	addi	sp,sp,8
 823d510:	f800283a 	ret

0823d514 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 823d514:	defff804 	addi	sp,sp,-32
 823d518:	dfc00515 	stw	ra,20(sp)
 823d51c:	df000415 	stw	fp,16(sp)
 823d520:	df000404 	addi	fp,sp,16
 823d524:	e13ffe15 	stw	r4,-8(fp)
 823d528:	e17fff15 	stw	r5,-4(fp)
 823d52c:	e1800215 	stw	r6,8(fp)
 823d530:	e1c00315 	stw	r7,12(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 823d534:	e0bffe17 	ldw	r2,-8(fp)
 823d538:	10800808 	cmpgei	r2,r2,32
 823d53c:	10000c1e 	bne	r2,zero,823d570 <fcntl+0x5c>
  {
    va_start(argp, cmd);
 823d540:	e0800204 	addi	r2,fp,8
 823d544:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d548:	e0bffd17 	ldw	r2,-12(fp)
 823d54c:	10c00104 	addi	r3,r2,4
 823d550:	e0fffd15 	stw	r3,-12(fp)
 823d554:	10800017 	ldw	r2,0(r2)
 823d558:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 823d55c:	e1bffc17 	ldw	r6,-16(fp)
 823d560:	e17fff17 	ldw	r5,-4(fp)
 823d564:	e13ffe17 	ldw	r4,-8(fp)
 823d568:	8249c580 	call	8249c58 <alt_fcntl>
 823d56c:	00000c06 	br	823d5a0 <fcntl+0x8c>
  }
  else
  {
    va_start(argp, cmd);
 823d570:	e0800204 	addi	r2,fp,8
 823d574:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d578:	e0bffd17 	ldw	r2,-12(fp)
 823d57c:	10c00104 	addi	r3,r2,4
 823d580:	e0fffd15 	stw	r3,-12(fp)
 823d584:	10800017 	ldw	r2,0(r2)
 823d588:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 823d58c:	e0bfff17 	ldw	r2,-4(fp)
 823d590:	e1bffc17 	ldw	r6,-16(fp)
 823d594:	100b883a 	mov	r5,r2
 823d598:	e13ffe17 	ldw	r4,-8(fp)
 823d59c:	8227e700 	call	8227e70 <bsd_ioctl>
  }
}
 823d5a0:	e037883a 	mov	sp,fp
 823d5a4:	dfc00117 	ldw	ra,4(sp)
 823d5a8:	df000017 	ldw	fp,0(sp)
 823d5ac:	dec00404 	addi	sp,sp,16
 823d5b0:	f800283a 	ret

0823d5b4 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 823d5b4:	defffe04 	addi	sp,sp,-8
 823d5b8:	dfc00115 	stw	ra,4(sp)
 823d5bc:	df000015 	stw	fp,0(sp)
 823d5c0:	d839883a 	mov	fp,sp
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 823d5c4:	01018204 	movi	r4,1544
 823d5c8:	823eae00 	call	823eae0 <reg_type>
 823d5cc:	10000526 	beq	r2,zero,823d5e4 <etainit+0x30>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 823d5d0:	01020974 	movhi	r4,2085
 823d5d4:	2102e304 	addi	r4,r4,2956
 823d5d8:	82031200 	call	8203120 <puts>
#endif
      return (1);
 823d5dc:	00800044 	movi	r2,1
 823d5e0:	00000106 	br	823d5e8 <etainit+0x34>
   }
   return (0);
 823d5e4:	0005883a 	mov	r2,zero
}
 823d5e8:	e037883a 	mov	sp,fp
 823d5ec:	dfc00117 	ldw	ra,4(sp)
 823d5f0:	df000017 	ldw	fp,0(sp)
 823d5f4:	dec00204 	addi	sp,sp,8
 823d5f8:	f800283a 	ret

0823d5fc <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 823d5fc:	defff904 	addi	sp,sp,-28
 823d600:	dfc00615 	stw	ra,24(sp)
 823d604:	df000515 	stw	fp,20(sp)
 823d608:	df000504 	addi	fp,sp,20
 823d60c:	e13ffe15 	stw	r4,-8(fp)
 823d610:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823d614:	e0bffe17 	ldw	r2,-8(fp)
 823d618:	10800617 	ldw	r2,24(r2)
 823d61c:	10802717 	ldw	r2,156(r2)
 823d620:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 823d624:	d0e0a817 	ldw	r3,-32096(gp)
 823d628:	e0bfff17 	ldw	r2,-4(fp)
 823d62c:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 823d630:	e0bffe17 	ldw	r2,-8(fp)
 823d634:	10800317 	ldw	r2,12(r2)
 823d638:	10fffc04 	addi	r3,r2,-16
 823d63c:	e0bffe17 	ldw	r2,-8(fp)
 823d640:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 823d644:	e0bffe17 	ldw	r2,-8(fp)
 823d648:	10800417 	ldw	r2,16(r2)
 823d64c:	10c00404 	addi	r3,r2,16
 823d650:	e0bffe17 	ldw	r2,-8(fp)
 823d654:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 823d658:	e0bffe17 	ldw	r2,-8(fp)
 823d65c:	10800317 	ldw	r2,12(r2)
 823d660:	10800084 	addi	r2,r2,2
 823d664:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 823d668:	e0bffe17 	ldw	r2,-8(fp)
 823d66c:	10800117 	ldw	r2,4(r2)
 823d670:	e0fffd17 	ldw	r3,-12(fp)
 823d674:	1880032e 	bgeu	r3,r2,823d684 <et_send+0x88>
      panic("et_send: prepend");
 823d678:	01020974 	movhi	r4,2085
 823d67c:	2102ef04 	addi	r4,r4,3004
 823d680:	822887c0 	call	822887c <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 823d684:	e0bfff17 	ldw	r2,-4(fp)
 823d688:	10800104 	addi	r2,r2,4
 823d68c:	01800184 	movi	r6,6
 823d690:	100b883a 	mov	r5,r2
 823d694:	e13ffd17 	ldw	r4,-12(fp)
 823d698:	8202b540 	call	8202b54 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 823d69c:	e0bffd17 	ldw	r2,-12(fp)
 823d6a0:	10c00184 	addi	r3,r2,6
 823d6a4:	e0bffc17 	ldw	r2,-16(fp)
 823d6a8:	10800517 	ldw	r2,20(r2)
 823d6ac:	01800184 	movi	r6,6
 823d6b0:	100b883a 	mov	r5,r2
 823d6b4:	1809883a 	mov	r4,r3
 823d6b8:	8202b540 	call	8202b54 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 823d6bc:	e0bfff17 	ldw	r2,-4(fp)
 823d6c0:	1080070b 	ldhu	r2,28(r2)
 823d6c4:	10bfffcc 	andi	r2,r2,65535
 823d6c8:	108000cc 	andi	r2,r2,3
 823d6cc:	108000a0 	cmpeqi	r2,r2,2
 823d6d0:	1000041e 	bne	r2,zero,823d6e4 <et_send+0xe8>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 823d6d4:	e0bffd17 	ldw	r2,-12(fp)
 823d6d8:	10800304 	addi	r2,r2,12
 823d6dc:	00c00204 	movi	r3,8
 823d6e0:	10c00005 	stb	r3,0(r2)
 823d6e4:	e0bffd17 	ldw	r2,-12(fp)
 823d6e8:	10800344 	addi	r2,r2,13
 823d6ec:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 823d6f0:	e0bffe17 	ldw	r2,-8(fp)
 823d6f4:	10800617 	ldw	r2,24(r2)
 823d6f8:	10800417 	ldw	r2,16(r2)
 823d6fc:	10000726 	beq	r2,zero,823d71c <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 823d700:	e0bffe17 	ldw	r2,-8(fp)
 823d704:	10800617 	ldw	r2,24(r2)
 823d708:	10800417 	ldw	r2,16(r2)
 823d70c:	e13ffe17 	ldw	r4,-8(fp)
 823d710:	103ee83a 	callr	r2
 823d714:	e0bffb15 	stw	r2,-20(fp)
 823d718:	00001206 	br	823d764 <et_send+0x168>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 823d71c:	e0bffe17 	ldw	r2,-8(fp)
 823d720:	10800617 	ldw	r2,24(r2)
 823d724:	10800317 	ldw	r2,12(r2)
 823d728:	e0fffe17 	ldw	r3,-8(fp)
 823d72c:	19000617 	ldw	r4,24(r3)
 823d730:	e0fffe17 	ldw	r3,-8(fp)
 823d734:	19400317 	ldw	r5,12(r3)
 823d738:	e0fffe17 	ldw	r3,-8(fp)
 823d73c:	18c00417 	ldw	r3,16(r3)
 823d740:	180d883a 	mov	r6,r3
 823d744:	103ee83a 	callr	r2
 823d748:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823d74c:	01000084 	movi	r4,2
 823d750:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823d754:	e13ffe17 	ldw	r4,-8(fp)
 823d758:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823d75c:	01000084 	movi	r4,2
 823d760:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 823d764:	e0bffb17 	ldw	r2,-20(fp)
}
 823d768:	e037883a 	mov	sp,fp
 823d76c:	dfc00117 	ldw	ra,4(sp)
 823d770:	df000017 	ldw	fp,0(sp)
 823d774:	dec00204 	addi	sp,sp,8
 823d778:	f800283a 	ret

0823d77c <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 823d77c:	defffb04 	addi	sp,sp,-20
 823d780:	dfc00415 	stw	ra,16(sp)
 823d784:	df000315 	stw	fp,12(sp)
 823d788:	df000304 	addi	fp,sp,12
 823d78c:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 823d790:	e0bfff17 	ldw	r2,-4(fp)
 823d794:	10800417 	ldw	r2,16(r2)
 823d798:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;
 823d79c:	e0bfff17 	ldw	r2,-4(fp)
 823d7a0:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823d7a4:	01000084 	movi	r4,2
 823d7a8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 823d7ac:	00000906 	br	823d7d4 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 823d7b0:	e0bffd17 	ldw	r2,-12(fp)
 823d7b4:	10800017 	ldw	r2,0(r2)
 823d7b8:	e0bffe15 	stw	r2,-8(fp)
      tmppkt->next = (PACKET)NULL;
 823d7bc:	e0bffd17 	ldw	r2,-12(fp)
 823d7c0:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 823d7c4:	e13ffd17 	ldw	r4,-12(fp)
 823d7c8:	822c9700 	call	822c970 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 823d7cc:	e0bffe17 	ldw	r2,-8(fp)
 823d7d0:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 823d7d4:	e0bffd17 	ldw	r2,-12(fp)
 823d7d8:	103ff51e 	bne	r2,zero,823d7b0 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 823d7dc:	e0bfff17 	ldw	r2,-4(fp)
 823d7e0:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823d7e4:	01000084 	movi	r4,2
 823d7e8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
}
 823d7ec:	0001883a 	nop
 823d7f0:	e037883a 	mov	sp,fp
 823d7f4:	dfc00117 	ldw	ra,4(sp)
 823d7f8:	df000017 	ldw	fp,0(sp)
 823d7fc:	dec00204 	addi	sp,sp,8
 823d800:	f800283a 	ret

0823d804 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 823d804:	defffc04 	addi	sp,sp,-16
 823d808:	dfc00315 	stw	ra,12(sp)
 823d80c:	df000215 	stw	fp,8(sp)
 823d810:	df000204 	addi	fp,sp,8
 823d814:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 823d818:	e0bfff17 	ldw	r2,-4(fp)
 823d81c:	10800417 	ldw	r2,16(r2)
 823d820:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823d824:	00000906 	br	823d84c <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 823d828:	e0bffe17 	ldw	r2,-8(fp)
 823d82c:	10c00017 	ldw	r3,0(r2)
 823d830:	e0bfff17 	ldw	r2,-4(fp)
 823d834:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 823d838:	e0bffe17 	ldw	r2,-8(fp)
 823d83c:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 823d840:	e17fff17 	ldw	r5,-4(fp)
 823d844:	e13ffe17 	ldw	r4,-8(fp)
 823d848:	823d5fc0 	call	823d5fc <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823d84c:	e0bfff17 	ldw	r2,-4(fp)
 823d850:	10800417 	ldw	r2,16(r2)
 823d854:	e0bffe15 	stw	r2,-8(fp)
 823d858:	e0bffe17 	ldw	r2,-8(fp)
 823d85c:	103ff21e 	bne	r2,zero,823d828 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 823d860:	0001883a 	nop
 823d864:	e037883a 	mov	sp,fp
 823d868:	dfc00117 	ldw	ra,4(sp)
 823d86c:	df000017 	ldw	fp,0(sp)
 823d870:	dec00204 	addi	sp,sp,8
 823d874:	f800283a 	ret

0823d878 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 823d878:	defff404 	addi	sp,sp,-48
 823d87c:	dfc00b15 	stw	ra,44(sp)
 823d880:	df000a15 	stw	fp,40(sp)
 823d884:	df000a04 	addi	fp,sp,40
 823d888:	e13ffe15 	stw	r4,-8(fp)
 823d88c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 823d890:	e0bffe17 	ldw	r2,-8(fp)
 823d894:	10800617 	ldw	r2,24(r2)
 823d898:	e0bff615 	stw	r2,-40(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823d89c:	e0bffe17 	ldw	r2,-8(fp)
 823d8a0:	10800617 	ldw	r2,24(r2)
 823d8a4:	10802717 	ldw	r2,156(r2)
 823d8a8:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823d8ac:	e0bfff17 	ldw	r2,-4(fp)
 823d8b0:	10bfffe0 	cmpeqi	r2,r2,-1
 823d8b4:	1000191e 	bne	r2,zero,823d91c <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
 823d8b8:	e0bff617 	ldw	r2,-40(fp)
 823d8bc:	10800c17 	ldw	r2,48(r2)
 823d8c0:	0086303a 	nor	r3,zero,r2
 823d8c4:	e0bfff17 	ldw	r2,-4(fp)
 823d8c8:	1886703a 	and	r3,r3,r2
 823d8cc:	e0bff617 	ldw	r2,-40(fp)
 823d8d0:	10800c17 	ldw	r2,48(r2)
 823d8d4:	0084303a 	nor	r2,zero,r2
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823d8d8:	18801026 	beq	r3,r2,823d91c <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
       || (IN_MULTICAST(ntohl(dest_ip)) ))
 823d8dc:	e0bfff17 	ldw	r2,-4(fp)
 823d8e0:	1006d63a 	srli	r3,r2,24
 823d8e4:	e0bfff17 	ldw	r2,-4(fp)
 823d8e8:	1004d23a 	srli	r2,r2,8
 823d8ec:	10bfc00c 	andi	r2,r2,65280
 823d8f0:	1886b03a 	or	r3,r3,r2
 823d8f4:	e0bfff17 	ldw	r2,-4(fp)
 823d8f8:	10bfc00c 	andi	r2,r2,65280
 823d8fc:	1004923a 	slli	r2,r2,8
 823d900:	1886b03a 	or	r3,r3,r2
 823d904:	e0bfff17 	ldw	r2,-4(fp)
 823d908:	1004963a 	slli	r2,r2,24
 823d90c:	1884b03a 	or	r2,r3,r2
 823d910:	10fc002c 	andhi	r3,r2,61440
 823d914:	00b80034 	movhi	r2,57344
 823d918:	1880391e 	bne	r3,r2,823da00 <send_arp+0x188>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 823d91c:	e0bffe17 	ldw	r2,-8(fp)
 823d920:	10800617 	ldw	r2,24(r2)
 823d924:	100b883a 	mov	r5,r2
 823d928:	e13fff17 	ldw	r4,-4(fp)
 823d92c:	823de380 	call	823de38 <make_arp_entry>
 823d930:	e0bff915 	stw	r2,-28(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 823d934:	e0bff917 	ldw	r2,-28(fp)
 823d938:	10800104 	addi	r2,r2,4
 823d93c:	01800184 	movi	r6,6
 823d940:	01403fc4 	movi	r5,255
 823d944:	1009883a 	mov	r4,r2
 823d948:	8202cb00 	call	8202cb0 <memset>
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 823d94c:	e0bffe17 	ldw	r2,-8(fp)
 823d950:	10800617 	ldw	r2,24(r2)
 823d954:	10802b17 	ldw	r2,172(r2)
 823d958:	10002526 	beq	r2,zero,823d9f0 <send_arp+0x178>
 823d95c:	e0bfff17 	ldw	r2,-4(fp)
 823d960:	1006d63a 	srli	r3,r2,24
 823d964:	e0bfff17 	ldw	r2,-4(fp)
 823d968:	1004d23a 	srli	r2,r2,8
 823d96c:	10bfc00c 	andi	r2,r2,65280
 823d970:	1886b03a 	or	r3,r3,r2
 823d974:	e0bfff17 	ldw	r2,-4(fp)
 823d978:	10bfc00c 	andi	r2,r2,65280
 823d97c:	1004923a 	slli	r2,r2,8
 823d980:	1886b03a 	or	r3,r3,r2
 823d984:	e0bfff17 	ldw	r2,-4(fp)
 823d988:	1004963a 	slli	r2,r2,24
 823d98c:	1884b03a 	or	r2,r3,r2
 823d990:	10fc002c 	andhi	r3,r2,61440
 823d994:	00b80034 	movhi	r2,57344
 823d998:	1880151e 	bne	r3,r2,823d9f0 <send_arp+0x178>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 823d99c:	e0bfff17 	ldw	r2,-4(fp)
 823d9a0:	e0bffd15 	stw	r2,-12(fp)
         oldest->t_phy_addr[0] = 0x01;
 823d9a4:	e0bff917 	ldw	r2,-28(fp)
 823d9a8:	00c00044 	movi	r3,1
 823d9ac:	10c00105 	stb	r3,4(r2)
         oldest->t_phy_addr[1] = 0x00;
 823d9b0:	e0bff917 	ldw	r2,-28(fp)
 823d9b4:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 823d9b8:	e0bff917 	ldw	r2,-28(fp)
 823d9bc:	00c01784 	movi	r3,94
 823d9c0:	10c00185 	stb	r3,6(r2)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 823d9c4:	e0bffd43 	ldbu	r2,-11(fp)
 823d9c8:	10801fcc 	andi	r2,r2,127
 823d9cc:	1007883a 	mov	r3,r2
 823d9d0:	e0bff917 	ldw	r2,-28(fp)
 823d9d4:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 823d9d8:	e0fffd83 	ldbu	r3,-10(fp)
 823d9dc:	e0bff917 	ldw	r2,-28(fp)
 823d9e0:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 823d9e4:	e0fffdc3 	ldbu	r3,-9(fp)
 823d9e8:	e0bff917 	ldw	r2,-28(fp)
 823d9ec:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 823d9f0:	e17ff917 	ldw	r5,-28(fp)
 823d9f4:	e13ffe17 	ldw	r4,-8(fp)
 823d9f8:	823d5fc0 	call	823d5fc <et_send>
 823d9fc:	0000ae06 	br	823dcb8 <send_arp+0x440>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823da00:	e0bffe17 	ldw	r2,-8(fp)
 823da04:	10c00717 	ldw	r3,28(r2)
 823da08:	e0bffe17 	ldw	r2,-8(fp)
 823da0c:	10800617 	ldw	r2,24(r2)
 823da10:	10800a17 	ldw	r2,40(r2)
 823da14:	18800d1e 	bne	r3,r2,823da4c <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
 823da18:	e0bffe17 	ldw	r2,-8(fp)
 823da1c:	10800717 	ldw	r2,28(r2)
 823da20:	10803fcc 	andi	r2,r2,255

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823da24:	10801fe0 	cmpeqi	r2,r2,127
 823da28:	1000081e 	bne	r2,zero,823da4c <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823da2c:	01000084 	movi	r4,2
 823da30:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823da34:	e13ffe17 	ldw	r4,-8(fp)
 823da38:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823da3c:	01000084 	movi	r4,2
 823da40:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 823da44:	00bff7c4 	movi	r2,-33
 823da48:	00009b06 	br	823dcb8 <send_arp+0x440>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823da4c:	01000084 	movi	r4,2
 823da50:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823da54:	01000c04 	movi	r4,48
 823da58:	822c6200 	call	822c620 <pk_alloc>
 823da5c:	e0bff815 	stw	r2,-32(fp)
   if (!arppkt)
 823da60:	e0bff817 	ldw	r2,-32(fp)
 823da64:	1000061e 	bne	r2,zero,823da80 <send_arp+0x208>
   {
      pk_free(pkt);
 823da68:	e13ffe17 	ldw	r4,-8(fp)
 823da6c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823da70:	01000084 	movi	r4,2
 823da74:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823da78:	00bffa84 	movi	r2,-22
 823da7c:	00008e06 	br	823dcb8 <send_arp+0x440>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823da80:	01000084 	movi	r4,2
 823da84:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823da88:	e0bff817 	ldw	r2,-32(fp)
 823da8c:	10c00117 	ldw	r3,4(r2)
 823da90:	e0bff817 	ldw	r2,-32(fp)
 823da94:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823da98:	e0bff817 	ldw	r2,-32(fp)
 823da9c:	00c00c04 	movi	r3,48
 823daa0:	10c00415 	stw	r3,16(r2)
   arppkt->net = pkt->net;
 823daa4:	e0bffe17 	ldw	r2,-8(fp)
 823daa8:	10c00617 	ldw	r3,24(r2)
 823daac:	e0bff817 	ldw	r2,-32(fp)
 823dab0:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 823dab4:	e0bffe17 	ldw	r2,-8(fp)
 823dab8:	10800617 	ldw	r2,24(r2)
 823dabc:	100b883a 	mov	r5,r2
 823dac0:	e13fff17 	ldw	r4,-4(fp)
 823dac4:	823de380 	call	823de38 <make_arp_entry>
 823dac8:	e0bff915 	stw	r2,-28(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 823dacc:	e0bff917 	ldw	r2,-28(fp)
 823dad0:	e0fffe17 	ldw	r3,-8(fp)
 823dad4:	10c00415 	stw	r3,16(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823dad8:	e0bff817 	ldw	r2,-32(fp)
 823dadc:	10800117 	ldw	r2,4(r2)
 823dae0:	10800084 	addi	r2,r2,2
 823dae4:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823dae8:	e0bff817 	ldw	r2,-32(fp)
 823daec:	10800117 	ldw	r2,4(r2)
 823daf0:	10800404 	addi	r2,r2,16
 823daf4:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823daf8:	e0bffb17 	ldw	r2,-20(fp)
 823dafc:	00c04004 	movi	r3,256
 823db00:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823db04:	e0bffb17 	ldw	r2,-20(fp)
 823db08:	00c00204 	movi	r3,8
 823db0c:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823db10:	e0bffb17 	ldw	r2,-20(fp)
 823db14:	00c00184 	movi	r3,6
 823db18:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823db1c:	e0bffb17 	ldw	r2,-20(fp)
 823db20:	00c00104 	movi	r3,4
 823db24:	10c00145 	stb	r3,5(r2)
   arphdr->ar_op = ARREQ;
 823db28:	e0bffb17 	ldw	r2,-20(fp)
 823db2c:	00c04004 	movi	r3,256
 823db30:	10c0018d 	sth	r3,6(r2)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 823db34:	e0bffb17 	ldw	r2,-20(fp)
 823db38:	e0ffff17 	ldw	r3,-4(fp)
 823db3c:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 823db40:	e0bffe17 	ldw	r2,-8(fp)
 823db44:	10800617 	ldw	r2,24(r2)
 823db48:	10c00a17 	ldw	r3,40(r2)
 823db4c:	e0bffb17 	ldw	r2,-20(fp)
 823db50:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823db54:	e0bffb17 	ldw	r2,-20(fp)
 823db58:	10c00204 	addi	r3,r2,8
 823db5c:	e0bff717 	ldw	r2,-36(fp)
 823db60:	10800517 	ldw	r2,20(r2)
 823db64:	01800184 	movi	r6,6
 823db68:	100b883a 	mov	r5,r2
 823db6c:	1809883a 	mov	r4,r3
 823db70:	8202b540 	call	8202b54 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823db74:	01800184 	movi	r6,6
 823db78:	01403fc4 	movi	r5,255
 823db7c:	e13ffa17 	ldw	r4,-24(fp)
 823db80:	8202cb00 	call	8202cb0 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823db84:	e0bffa17 	ldw	r2,-24(fp)
 823db88:	10c00184 	addi	r3,r2,6
 823db8c:	e0bff717 	ldw	r2,-36(fp)
 823db90:	10800517 	ldw	r2,20(r2)
 823db94:	01800184 	movi	r6,6
 823db98:	100b883a 	mov	r5,r2
 823db9c:	1809883a 	mov	r4,r3
 823dba0:	8202b540 	call	8202b54 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823dba4:	e0bffa17 	ldw	r2,-24(fp)
 823dba8:	10800304 	addi	r2,r2,12
 823dbac:	00c00204 	movi	r3,8
 823dbb0:	10c00005 	stb	r3,0(r2)
 823dbb4:	e0bffa17 	ldw	r2,-24(fp)
 823dbb8:	10800344 	addi	r2,r2,13
 823dbbc:	00c00184 	movi	r3,6
 823dbc0:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823dbc4:	e0bffb17 	ldw	r2,-20(fp)
 823dbc8:	e0bffc15 	stw	r2,-16(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823dbcc:	e0bffc17 	ldw	r2,-16(fp)
 823dbd0:	10c00204 	addi	r3,r2,8
 823dbd4:	e0bffb17 	ldw	r2,-20(fp)
 823dbd8:	10800204 	addi	r2,r2,8
 823dbdc:	01800184 	movi	r6,6
 823dbe0:	100b883a 	mov	r5,r2
 823dbe4:	1809883a 	mov	r4,r3
 823dbe8:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823dbec:	e0bffc17 	ldw	r2,-16(fp)
 823dbf0:	10c00384 	addi	r3,r2,14
 823dbf4:	e0bffb17 	ldw	r2,-20(fp)
 823dbf8:	10800404 	addi	r2,r2,16
 823dbfc:	01800104 	movi	r6,4
 823dc00:	100b883a 	mov	r5,r2
 823dc04:	1809883a 	mov	r4,r3
 823dc08:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823dc0c:	e0bffc17 	ldw	r2,-16(fp)
 823dc10:	10c00484 	addi	r3,r2,18
 823dc14:	e0bffb17 	ldw	r2,-20(fp)
 823dc18:	10800504 	addi	r2,r2,20
 823dc1c:	01800184 	movi	r6,6
 823dc20:	100b883a 	mov	r5,r2
 823dc24:	1809883a 	mov	r4,r3
 823dc28:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823dc2c:	e0bffc17 	ldw	r2,-16(fp)
 823dc30:	10c00604 	addi	r3,r2,24
 823dc34:	e0bffb17 	ldw	r2,-20(fp)
 823dc38:	10800704 	addi	r2,r2,28
 823dc3c:	01800104 	movi	r6,4
 823dc40:	100b883a 	mov	r5,r2
 823dc44:	1809883a 	mov	r4,r3
 823dc48:	8202b540 	call	8202b54 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823dc4c:	e0bff617 	ldw	r2,-40(fp)
 823dc50:	10800417 	ldw	r2,16(r2)
 823dc54:	10000526 	beq	r2,zero,823dc6c <send_arp+0x3f4>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823dc58:	e0bff617 	ldw	r2,-40(fp)
 823dc5c:	10800417 	ldw	r2,16(r2)
 823dc60:	e13ff817 	ldw	r4,-32(fp)
 823dc64:	103ee83a 	callr	r2
 823dc68:	00000f06 	br	823dca8 <send_arp+0x430>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823dc6c:	e0bff617 	ldw	r2,-40(fp)
 823dc70:	10800317 	ldw	r2,12(r2)
 823dc74:	e0fff817 	ldw	r3,-32(fp)
 823dc78:	19000617 	ldw	r4,24(r3)
 823dc7c:	e0fff817 	ldw	r3,-32(fp)
 823dc80:	18c00117 	ldw	r3,4(r3)
 823dc84:	01800c04 	movi	r6,48
 823dc88:	180b883a 	mov	r5,r3
 823dc8c:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823dc90:	01000084 	movi	r4,2
 823dc94:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823dc98:	e13ff817 	ldw	r4,-32(fp)
 823dc9c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dca0:	01000084 	movi	r4,2
 823dca4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823dca8:	d0a0c317 	ldw	r2,-31988(gp)
 823dcac:	10800044 	addi	r2,r2,1
 823dcb0:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823dcb4:	00800044 	movi	r2,1
}
 823dcb8:	e037883a 	mov	sp,fp
 823dcbc:	dfc00117 	ldw	ra,4(sp)
 823dcc0:	df000017 	ldw	fp,0(sp)
 823dcc4:	dec00204 	addi	sp,sp,8
 823dcc8:	f800283a 	ret

0823dccc <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 823dccc:	defff804 	addi	sp,sp,-32
 823dcd0:	dfc00715 	stw	ra,28(sp)
 823dcd4:	df000615 	stw	fp,24(sp)
 823dcd8:	df000604 	addi	fp,sp,24
 823dcdc:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 823dce0:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 823dce4:	e03ffc15 	stw	zero,-16(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 823dce8:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823dcec:	d0a0a817 	ldw	r2,-32096(gp)
 823dcf0:	e0bffe15 	stw	r2,-8(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823dcf4:	008209b4 	movhi	r2,2086
 823dcf8:	10b8b304 	addi	r2,r2,-7476
 823dcfc:	e0bffa15 	stw	r2,-24(fp)
 823dd00:	00003b06 	br	823ddf0 <find_oldest_arp+0x124>
   {
      /* age out old, pending entries */
      if (tp->pending)
 823dd04:	e0bffa17 	ldw	r2,-24(fp)
 823dd08:	10800417 	ldw	r2,16(r2)
 823dd0c:	10000b26 	beq	r2,zero,823dd3c <find_oldest_arp+0x70>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 823dd10:	e0bffa17 	ldw	r2,-24(fp)
 823dd14:	10800517 	ldw	r2,20(r2)
 823dd18:	e0fffe17 	ldw	r3,-8(fp)
 823dd1c:	1885c83a 	sub	r2,r3,r2
 823dd20:	10801970 	cmpltui	r2,r2,101
 823dd24:	1000171e 	bne	r2,zero,823dd84 <find_oldest_arp+0xb8>
         {
            arp_free_pending(tp);   /* free pending packets */
 823dd28:	e13ffa17 	ldw	r4,-24(fp)
 823dd2c:	823d77c0 	call	823d77c <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823dd30:	e0bffa17 	ldw	r2,-24(fp)
 823dd34:	10000015 	stw	zero,0(r2)
 823dd38:	00001206 	br	823dd84 <find_oldest_arp+0xb8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823dd3c:	e0bffa17 	ldw	r2,-24(fp)
 823dd40:	10800017 	ldw	r2,0(r2)
 823dd44:	10000f26 	beq	r2,zero,823dd84 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823dd48:	e0bffa17 	ldw	r2,-24(fp)
 823dd4c:	10800517 	ldw	r2,20(r2)
 823dd50:	e0fffe17 	ldw	r3,-8(fp)
 823dd54:	1885c83a 	sub	r2,r3,r2
 823dd58:	1007883a 	mov	r3,r2
 823dd5c:	d0a04f17 	ldw	r2,-32452(gp)
         {
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823dd60:	18800816 	blt	r3,r2,823dd84 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
 823dd64:	e0bffa17 	ldw	r2,-24(fp)
 823dd68:	10800617 	ldw	r2,24(r2)
 823dd6c:	e0fffe17 	ldw	r3,-8(fp)
 823dd70:	1885c83a 	sub	r2,r3,r2
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823dd74:	10801910 	cmplti	r2,r2,100
 823dd78:	1000021e 	bne	r2,zero,823dd84 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823dd7c:	e0bffa17 	ldw	r2,-24(fp)
 823dd80:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 823dd84:	e0bffa17 	ldw	r2,-24(fp)
 823dd88:	10c00017 	ldw	r3,0(r2)
 823dd8c:	e0bfff17 	ldw	r2,-4(fp)
 823dd90:	1880031e 	bne	r3,r2,823dda0 <find_oldest_arp+0xd4>
      {
         exact = tp;
 823dd94:	e0bffa17 	ldw	r2,-24(fp)
 823dd98:	e0bffb15 	stw	r2,-20(fp)
 823dd9c:	00001106 	br	823dde4 <find_oldest_arp+0x118>
      }
      else if (tp->t_pro_addr != 0)
 823dda0:	e0bffa17 	ldw	r2,-24(fp)
 823dda4:	10800017 	ldw	r2,0(r2)
 823dda8:	10000a26 	beq	r2,zero,823ddd4 <find_oldest_arp+0x108>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 823ddac:	e0bffc17 	ldw	r2,-16(fp)
 823ddb0:	10000526 	beq	r2,zero,823ddc8 <find_oldest_arp+0xfc>
 823ddb4:	e0bffa17 	ldw	r2,-24(fp)
 823ddb8:	10c00617 	ldw	r3,24(r2)
 823ddbc:	e0bffc17 	ldw	r2,-16(fp)
 823ddc0:	10800617 	ldw	r2,24(r2)
 823ddc4:	1880072e 	bgeu	r3,r2,823dde4 <find_oldest_arp+0x118>
            oldest = tp;
 823ddc8:	e0bffa17 	ldw	r2,-24(fp)
 823ddcc:	e0bffc15 	stw	r2,-16(fp)
 823ddd0:	00000406 	br	823dde4 <find_oldest_arp+0x118>
      }
      else if (!empty)
 823ddd4:	e0bffd17 	ldw	r2,-12(fp)
 823ddd8:	1000021e 	bne	r2,zero,823dde4 <find_oldest_arp+0x118>
         empty = tp;          /* grab first empty slot */
 823dddc:	e0bffa17 	ldw	r2,-24(fp)
 823dde0:	e0bffd15 	stw	r2,-12(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823dde4:	e0bffa17 	ldw	r2,-24(fp)
 823dde8:	10800804 	addi	r2,r2,32
 823ddec:	e0bffa15 	stw	r2,-24(fp)
 823ddf0:	e0fffa17 	ldw	r3,-24(fp)
 823ddf4:	008209b4 	movhi	r2,2086
 823ddf8:	10b8f304 	addi	r2,r2,-7220
 823ddfc:	18bfc136 	bltu	r3,r2,823dd04 <find_oldest_arp+0x38>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 823de00:	e0bffb17 	ldw	r2,-20(fp)
 823de04:	1000061e 	bne	r2,zero,823de20 <find_oldest_arp+0x154>
 823de08:	e0bffd17 	ldw	r2,-12(fp)
 823de0c:	10000226 	beq	r2,zero,823de18 <find_oldest_arp+0x14c>
 823de10:	e0bffd17 	ldw	r2,-12(fp)
 823de14:	00000306 	br	823de24 <find_oldest_arp+0x158>
 823de18:	e0bffc17 	ldw	r2,-16(fp)
 823de1c:	00000106 	br	823de24 <find_oldest_arp+0x158>
 823de20:	e0bffb17 	ldw	r2,-20(fp)
}
 823de24:	e037883a 	mov	sp,fp
 823de28:	dfc00117 	ldw	ra,4(sp)
 823de2c:	df000017 	ldw	fp,0(sp)
 823de30:	dec00204 	addi	sp,sp,8
 823de34:	f800283a 	ret

0823de38 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 823de38:	defffa04 	addi	sp,sp,-24
 823de3c:	dfc00515 	stw	ra,20(sp)
 823de40:	df000415 	stw	fp,16(sp)
 823de44:	df000404 	addi	fp,sp,16
 823de48:	e13ffe15 	stw	r4,-8(fp)
 823de4c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 823de50:	d0a0a817 	ldw	r2,-32096(gp)
 823de54:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 823de58:	e13ffe17 	ldw	r4,-8(fp)
 823de5c:	823dccc0 	call	823dccc <find_oldest_arp>
 823de60:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 823de64:	e0bffd17 	ldw	r2,-12(fp)
 823de68:	10800417 	ldw	r2,16(r2)
 823de6c:	10000626 	beq	r2,zero,823de88 <make_arp_entry+0x50>
 823de70:	e0bffd17 	ldw	r2,-12(fp)
 823de74:	10c00017 	ldw	r3,0(r2)
 823de78:	e0bffe17 	ldw	r2,-8(fp)
 823de7c:	18800226 	beq	r3,r2,823de88 <make_arp_entry+0x50>
   {
      arp_free_pending(oldest);
 823de80:	e13ffd17 	ldw	r4,-12(fp)
 823de84:	823d77c0 	call	823d77c <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 823de88:	e0bffd17 	ldw	r2,-12(fp)
 823de8c:	e0fffe17 	ldw	r3,-8(fp)
 823de90:	10c00015 	stw	r3,0(r2)
   oldest->net = net;
 823de94:	e0bffd17 	ldw	r2,-12(fp)
 823de98:	e0ffff17 	ldw	r3,-4(fp)
 823de9c:	10c00315 	stw	r3,12(r2)
   oldest->flags = 0;
 823dea0:	e0bffd17 	ldw	r2,-12(fp)
 823dea4:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 823dea8:	e0bffd17 	ldw	r2,-12(fp)
 823deac:	10800104 	addi	r2,r2,4
 823deb0:	01800184 	movi	r6,6
 823deb4:	000b883a 	mov	r5,zero
 823deb8:	1009883a 	mov	r4,r2
 823debc:	8202cb00 	call	8202cb0 <memset>
   oldest->createtime = oldest->lasttime = lticks;
 823dec0:	e0bffd17 	ldw	r2,-12(fp)
 823dec4:	e0fffc17 	ldw	r3,-16(fp)
 823dec8:	10c00615 	stw	r3,24(r2)
 823decc:	e0bffd17 	ldw	r2,-12(fp)
 823ded0:	10c00617 	ldw	r3,24(r2)
 823ded4:	e0bffd17 	ldw	r2,-12(fp)
 823ded8:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 823dedc:	d0a0bf17 	ldw	r2,-32004(gp)
 823dee0:	1000071e 	bne	r2,zero,823df00 <make_arp_entry+0xc8>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 823dee4:	000d883a 	mov	r6,zero
 823dee8:	0149c404 	movi	r5,10000
 823deec:	01020934 	movhi	r4,2084
 823def0:	21397604 	addi	r4,r4,-6696
 823def4:	823d2780 	call	823d278 <in_timerset>
 823def8:	d0a0bf15 	stw	r2,-32004(gp)
 823defc:	00000706 	br	823df1c <make_arp_entry+0xe4>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823df00:	d0a0bf17 	ldw	r2,-32004(gp)
 823df04:	1009883a 	mov	r4,r2
              ((struct intimer *)arp_timer)->interval + lticks;
 823df08:	d0a0bf17 	ldw	r2,-32004(gp)
 823df0c:	10c00217 	ldw	r3,8(r2)
 823df10:	e0bffc17 	ldw	r2,-16(fp)
 823df14:	1885883a 	add	r2,r3,r2
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823df18:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 823df1c:	e0bffd17 	ldw	r2,-12(fp)
}
 823df20:	e037883a 	mov	sp,fp
 823df24:	dfc00117 	ldw	ra,4(sp)
 823df28:	df000017 	ldw	fp,0(sp)
 823df2c:	dec00204 	addi	sp,sp,8
 823df30:	f800283a 	ret

0823df34 <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 823df34:	defff704 	addi	sp,sp,-36
 823df38:	dfc00815 	stw	ra,32(sp)
 823df3c:	df000715 	stw	fp,28(sp)
 823df40:	df000704 	addi	fp,sp,28
 823df44:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823df48:	01000084 	movi	r4,2
 823df4c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 823df50:	01000c04 	movi	r4,48
 823df54:	822c6200 	call	822c620 <pk_alloc>
 823df58:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823df5c:	01000084 	movi	r4,2
 823df60:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 823df64:	e0bff917 	ldw	r2,-28(fp)
 823df68:	1000021e 	bne	r2,zero,823df74 <arpReply+0x40>
   {
      dtrap();
 823df6c:	822d1c80 	call	822d1c8 <dtrap>
      return;
 823df70:	00009b06 	br	823e1e0 <arpReply+0x2ac>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 823df74:	e0bfff17 	ldw	r2,-4(fp)
 823df78:	10c00617 	ldw	r3,24(r2)
 823df7c:	e0bff917 	ldw	r2,-28(fp)
 823df80:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823df84:	e0bfff17 	ldw	r2,-4(fp)
 823df88:	10800317 	ldw	r2,12(r2)
 823df8c:	10bffc84 	addi	r2,r2,-14
 823df90:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 823df94:	e0bff917 	ldw	r2,-28(fp)
 823df98:	10800117 	ldw	r2,4(r2)
 823df9c:	10800084 	addi	r2,r2,2
 823dfa0:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 823dfa4:	e0bffb17 	ldw	r2,-20(fp)
 823dfa8:	10800304 	addi	r2,r2,12
 823dfac:	00c00204 	movi	r3,8
 823dfb0:	10c00005 	stb	r3,0(r2)
 823dfb4:	e0bffb17 	ldw	r2,-20(fp)
 823dfb8:	10800344 	addi	r2,r2,13
 823dfbc:	00c00184 	movi	r3,6
 823dfc0:	10c00005 	stb	r3,0(r2)
      in = (struct arp_hdr *)(pkt->nb_prot);
 823dfc4:	e0bfff17 	ldw	r2,-4(fp)
 823dfc8:	10800317 	ldw	r2,12(r2)
 823dfcc:	e0bffc15 	stw	r2,-16(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 823dfd0:	e0bff917 	ldw	r2,-28(fp)
 823dfd4:	10800117 	ldw	r2,4(r2)
 823dfd8:	10800404 	addi	r2,r2,16
 823dfdc:	e0bffd15 	stw	r2,-12(fp)
      outpkt->nb_plen = arpsize;
 823dfe0:	e0bff917 	ldw	r2,-28(fp)
 823dfe4:	00c00c04 	movi	r3,48
 823dfe8:	10c00415 	stw	r3,16(r2)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823dfec:	e0bffd17 	ldw	r2,-12(fp)
 823dff0:	00c04004 	movi	r3,256
 823dff4:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 823dff8:	e0bffd17 	ldw	r2,-12(fp)
 823dffc:	00c00204 	movi	r3,8
 823e000:	10c0008d 	sth	r3,2(r2)
   out->ar_hln = 6;
 823e004:	e0bffd17 	ldw	r2,-12(fp)
 823e008:	00c00184 	movi	r3,6
 823e00c:	10c00105 	stb	r3,4(r2)
   out->ar_pln = 4;
 823e010:	e0bffd17 	ldw	r2,-12(fp)
 823e014:	00c00104 	movi	r3,4
 823e018:	10c00145 	stb	r3,5(r2)
   out->ar_op = ARREP;
 823e01c:	e0bffd17 	ldw	r2,-12(fp)
 823e020:	00c08004 	movi	r3,512
 823e024:	10c0018d 	sth	r3,6(r2)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 823e028:	e0bffc17 	ldw	r2,-16(fp)
 823e02c:	10c00417 	ldw	r3,16(r2)
 823e030:	e0bffd17 	ldw	r2,-12(fp)
 823e034:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 823e038:	e0bffc17 	ldw	r2,-16(fp)
 823e03c:	10c00717 	ldw	r3,28(r2)
 823e040:	e0bffd17 	ldw	r2,-12(fp)
 823e044:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 823e048:	e0bffd17 	ldw	r2,-12(fp)
 823e04c:	10c00504 	addi	r3,r2,20
 823e050:	e0bffc17 	ldw	r2,-16(fp)
 823e054:	10800204 	addi	r2,r2,8
 823e058:	01800184 	movi	r6,6
 823e05c:	100b883a 	mov	r5,r2
 823e060:	1809883a 	mov	r4,r3
 823e064:	8202b540 	call	8202b54 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 823e068:	e0bffd17 	ldw	r2,-12(fp)
 823e06c:	10c00204 	addi	r3,r2,8
 823e070:	e0bff917 	ldw	r2,-28(fp)
 823e074:	10800617 	ldw	r2,24(r2)
 823e078:	10802717 	ldw	r2,156(r2)
 823e07c:	10800517 	ldw	r2,20(r2)
 823e080:	01800184 	movi	r6,6
 823e084:	100b883a 	mov	r5,r2
 823e088:	1809883a 	mov	r4,r3
 823e08c:	8202b540 	call	8202b54 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 823e090:	e0bffa17 	ldw	r2,-24(fp)
 823e094:	10800184 	addi	r2,r2,6
 823e098:	01800184 	movi	r6,6
 823e09c:	100b883a 	mov	r5,r2
 823e0a0:	e13ffb17 	ldw	r4,-20(fp)
 823e0a4:	8202b540 	call	8202b54 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 823e0a8:	e0bffb17 	ldw	r2,-20(fp)
 823e0ac:	10c00184 	addi	r3,r2,6
 823e0b0:	e0bff917 	ldw	r2,-28(fp)
 823e0b4:	10800617 	ldw	r2,24(r2)
 823e0b8:	10802717 	ldw	r2,156(r2)
 823e0bc:	10800517 	ldw	r2,20(r2)
 823e0c0:	01800184 	movi	r6,6
 823e0c4:	100b883a 	mov	r5,r2
 823e0c8:	1809883a 	mov	r4,r3
 823e0cc:	8202b540 	call	8202b54 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 823e0d0:	e0bffd17 	ldw	r2,-12(fp)
 823e0d4:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 823e0d8:	e0bffe17 	ldw	r2,-8(fp)
 823e0dc:	10c00204 	addi	r3,r2,8
 823e0e0:	e0bffd17 	ldw	r2,-12(fp)
 823e0e4:	10800204 	addi	r2,r2,8
 823e0e8:	01800184 	movi	r6,6
 823e0ec:	100b883a 	mov	r5,r2
 823e0f0:	1809883a 	mov	r4,r3
 823e0f4:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 823e0f8:	e0bffe17 	ldw	r2,-8(fp)
 823e0fc:	10c00384 	addi	r3,r2,14
 823e100:	e0bffd17 	ldw	r2,-12(fp)
 823e104:	10800404 	addi	r2,r2,16
 823e108:	01800104 	movi	r6,4
 823e10c:	100b883a 	mov	r5,r2
 823e110:	1809883a 	mov	r4,r3
 823e114:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 823e118:	e0bffe17 	ldw	r2,-8(fp)
 823e11c:	10c00484 	addi	r3,r2,18
 823e120:	e0bffd17 	ldw	r2,-12(fp)
 823e124:	10800504 	addi	r2,r2,20
 823e128:	01800184 	movi	r6,6
 823e12c:	100b883a 	mov	r5,r2
 823e130:	1809883a 	mov	r4,r3
 823e134:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 823e138:	e0bffe17 	ldw	r2,-8(fp)
 823e13c:	10c00604 	addi	r3,r2,24
 823e140:	e0bffd17 	ldw	r2,-12(fp)
 823e144:	10800704 	addi	r2,r2,28
 823e148:	01800104 	movi	r6,4
 823e14c:	100b883a 	mov	r5,r2
 823e150:	1809883a 	mov	r4,r3
 823e154:	8202b540 	call	8202b54 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 823e158:	e0bff917 	ldw	r2,-28(fp)
 823e15c:	10800617 	ldw	r2,24(r2)
 823e160:	10800417 	ldw	r2,16(r2)
 823e164:	10000a26 	beq	r2,zero,823e190 <arpReply+0x25c>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 823e168:	e0bff917 	ldw	r2,-28(fp)
 823e16c:	10c00117 	ldw	r3,4(r2)
 823e170:	e0bff917 	ldw	r2,-28(fp)
 823e174:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 823e178:	e0bff917 	ldw	r2,-28(fp)
 823e17c:	10800617 	ldw	r2,24(r2)
 823e180:	10800417 	ldw	r2,16(r2)
 823e184:	e13ff917 	ldw	r4,-28(fp)
 823e188:	103ee83a 	callr	r2
 823e18c:	00001106 	br	823e1d4 <arpReply+0x2a0>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 823e190:	e0bff917 	ldw	r2,-28(fp)
 823e194:	10800617 	ldw	r2,24(r2)
 823e198:	10800317 	ldw	r2,12(r2)
 823e19c:	e0ffff17 	ldw	r3,-4(fp)
 823e1a0:	19000617 	ldw	r4,24(r3)
 823e1a4:	e0fff917 	ldw	r3,-28(fp)
 823e1a8:	19400117 	ldw	r5,4(r3)
 823e1ac:	e0fff917 	ldw	r3,-28(fp)
 823e1b0:	18c00417 	ldw	r3,16(r3)
 823e1b4:	180d883a 	mov	r6,r3
 823e1b8:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e1bc:	01000084 	movi	r4,2
 823e1c0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 823e1c4:	e13ff917 	ldw	r4,-28(fp)
 823e1c8:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e1cc:	01000084 	movi	r4,2
 823e1d0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 823e1d4:	d0a0c517 	ldw	r2,-31980(gp)
 823e1d8:	10800044 	addi	r2,r2,1
 823e1dc:	d0a0c515 	stw	r2,-31980(gp)
}
 823e1e0:	e037883a 	mov	sp,fp
 823e1e4:	dfc00117 	ldw	ra,4(sp)
 823e1e8:	df000017 	ldw	fp,0(sp)
 823e1ec:	dec00204 	addi	sp,sp,8
 823e1f0:	f800283a 	ret

0823e1f4 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 823e1f4:	defff904 	addi	sp,sp,-28
 823e1f8:	dfc00615 	stw	ra,24(sp)
 823e1fc:	df000515 	stw	fp,20(sp)
 823e200:	df000504 	addi	fp,sp,20
 823e204:	e13fff15 	stw	r4,-4(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e208:	e0bfff17 	ldw	r2,-4(fp)
 823e20c:	10800317 	ldw	r2,12(r2)
 823e210:	10bffc84 	addi	r2,r2,-14
 823e214:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 823e218:	e0bfff17 	ldw	r2,-4(fp)
 823e21c:	10800317 	ldw	r2,12(r2)
 823e220:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e224:	e0bffd17 	ldw	r2,-12(fp)
 823e228:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 823e22c:	e0bffd17 	ldw	r2,-12(fp)
 823e230:	10c00704 	addi	r3,r2,28
 823e234:	e0bffe17 	ldw	r2,-8(fp)
 823e238:	10800604 	addi	r2,r2,24
 823e23c:	01800104 	movi	r6,4
 823e240:	100b883a 	mov	r5,r2
 823e244:	1809883a 	mov	r4,r3
 823e248:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 823e24c:	e0bffd17 	ldw	r2,-12(fp)
 823e250:	10c00504 	addi	r3,r2,20
 823e254:	e0bffe17 	ldw	r2,-8(fp)
 823e258:	10800484 	addi	r2,r2,18
 823e25c:	01800184 	movi	r6,6
 823e260:	100b883a 	mov	r5,r2
 823e264:	1809883a 	mov	r4,r3
 823e268:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 823e26c:	e0bffd17 	ldw	r2,-12(fp)
 823e270:	10c00404 	addi	r3,r2,16
 823e274:	e0bffe17 	ldw	r2,-8(fp)
 823e278:	10800384 	addi	r2,r2,14
 823e27c:	01800104 	movi	r6,4
 823e280:	100b883a 	mov	r5,r2
 823e284:	1809883a 	mov	r4,r3
 823e288:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 823e28c:	e0bffd17 	ldw	r2,-12(fp)
 823e290:	10c00204 	addi	r3,r2,8
 823e294:	e0bffe17 	ldw	r2,-8(fp)
 823e298:	10800204 	addi	r2,r2,8
 823e29c:	01800184 	movi	r6,6
 823e2a0:	100b883a 	mov	r5,r2
 823e2a4:	1809883a 	mov	r4,r3
 823e2a8:	8202b540 	call	8202b54 <memmove>
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e2ac:	e0bffd17 	ldw	r2,-12(fp)
 823e2b0:	10c00717 	ldw	r3,28(r2)
 823e2b4:	e0bfff17 	ldw	r2,-4(fp)
 823e2b8:	10800617 	ldw	r2,24(r2)
 823e2bc:	10800a17 	ldw	r2,40(r2)
 823e2c0:	18801c26 	beq	r3,r2,823e334 <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
 823e2c4:	e0bffd17 	ldw	r2,-12(fp)
 823e2c8:	10800717 	ldw	r2,28(r2)
 823e2cc:	1006d63a 	srli	r3,r2,24
 823e2d0:	e0bffd17 	ldw	r2,-12(fp)
 823e2d4:	10800717 	ldw	r2,28(r2)
 823e2d8:	1004d23a 	srli	r2,r2,8
 823e2dc:	10bfc00c 	andi	r2,r2,65280
 823e2e0:	1886b03a 	or	r3,r3,r2
 823e2e4:	e0bffd17 	ldw	r2,-12(fp)
 823e2e8:	10800717 	ldw	r2,28(r2)
 823e2ec:	10bfc00c 	andi	r2,r2,65280
 823e2f0:	1004923a 	slli	r2,r2,8
 823e2f4:	1886b03a 	or	r3,r3,r2
 823e2f8:	e0bffd17 	ldw	r2,-12(fp)
 823e2fc:	10800717 	ldw	r2,28(r2)
 823e300:	1004963a 	slli	r2,r2,24
 823e304:	1884b03a 	or	r2,r3,r2
 823e308:	10fc002c 	andhi	r3,r2,61440
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e30c:	00b80034 	movhi	r2,57344
 823e310:	18800826 	beq	r3,r2,823e334 <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e314:	01000084 	movi	r4,2
 823e318:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 823e31c:	e13fff17 	ldw	r4,-4(fp)
 823e320:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e324:	01000084 	movi	r4,2
 823e328:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 823e32c:	00800084 	movi	r2,2
 823e330:	00004406 	br	823e444 <arprcv+0x250>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 823e334:	e0bffd17 	ldw	r2,-12(fp)
 823e338:	1080018b 	ldhu	r2,6(r2)
 823e33c:	10bfffcc 	andi	r2,r2,65535
 823e340:	10804018 	cmpnei	r2,r2,256
 823e344:	10000d1e 	bne	r2,zero,823e37c <arprcv+0x188>
   {
      arpReqsIn++;   /* count these */
 823e348:	d0a0c217 	ldw	r2,-31992(gp)
 823e34c:	10800044 	addi	r2,r2,1
 823e350:	d0a0c215 	stw	r2,-31992(gp)
      arpReply(pkt); /* send arp reply */
 823e354:	e13fff17 	ldw	r4,-4(fp)
 823e358:	823df340 	call	823df34 <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 823e35c:	e0bffd17 	ldw	r2,-12(fp)
 823e360:	10c00417 	ldw	r3,16(r2)
 823e364:	e0bfff17 	ldw	r2,-4(fp)
 823e368:	10800617 	ldw	r2,24(r2)
 823e36c:	100b883a 	mov	r5,r2
 823e370:	1809883a 	mov	r4,r3
 823e374:	823de380 	call	823de38 <make_arp_entry>
 823e378:	00000306 	br	823e388 <arprcv+0x194>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 823e37c:	d0a0c417 	ldw	r2,-31984(gp)
 823e380:	10800044 	addi	r2,r2,1
 823e384:	d0a0c415 	stw	r2,-31984(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e388:	008209b4 	movhi	r2,2086
 823e38c:	10b8b304 	addi	r2,r2,-7476
 823e390:	e0bffb15 	stw	r2,-20(fp)
 823e394:	00002006 	br	823e418 <arprcv+0x224>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 823e398:	e0bffb17 	ldw	r2,-20(fp)
 823e39c:	10c00017 	ldw	r3,0(r2)
 823e3a0:	e0bffd17 	ldw	r2,-12(fp)
 823e3a4:	10800417 	ldw	r2,16(r2)
 823e3a8:	1880181e 	bne	r3,r2,823e40c <arprcv+0x218>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 823e3ac:	e0bffb17 	ldw	r2,-20(fp)
 823e3b0:	10c00104 	addi	r3,r2,4
 823e3b4:	e0bffd17 	ldw	r2,-12(fp)
 823e3b8:	10800204 	addi	r2,r2,8
 823e3bc:	01800184 	movi	r6,6
 823e3c0:	100b883a 	mov	r5,r2
 823e3c4:	1809883a 	mov	r4,r3
 823e3c8:	8202b540 	call	8202b54 <memmove>
         tp->lasttime = cticks;
 823e3cc:	d0e0a817 	ldw	r3,-32096(gp)
 823e3d0:	e0bffb17 	ldw	r2,-20(fp)
 823e3d4:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 823e3d8:	e0bffb17 	ldw	r2,-20(fp)
 823e3dc:	10800417 	ldw	r2,16(r2)
 823e3e0:	10000226 	beq	r2,zero,823e3ec <arprcv+0x1f8>
         {
            arp_send_pending(tp);
 823e3e4:	e13ffb17 	ldw	r4,-20(fp)
 823e3e8:	823d8040 	call	823d804 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823e3ec:	01000084 	movi	r4,2
 823e3f0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 823e3f4:	e13fff17 	ldw	r4,-4(fp)
 823e3f8:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e3fc:	01000084 	movi	r4,2
 823e400:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

         return (0);
 823e404:	0005883a 	mov	r2,zero
 823e408:	00000e06 	br	823e444 <arprcv+0x250>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e40c:	e0bffb17 	ldw	r2,-20(fp)
 823e410:	10800804 	addi	r2,r2,32
 823e414:	e0bffb15 	stw	r2,-20(fp)
 823e418:	e0fffb17 	ldw	r3,-20(fp)
 823e41c:	008209b4 	movhi	r2,2086
 823e420:	10b8f304 	addi	r2,r2,-7220
 823e424:	18bfdc36 	bltu	r3,r2,823e398 <arprcv+0x1a4>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e428:	01000084 	movi	r4,2
 823e42c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 823e430:	e13fff17 	ldw	r4,-4(fp)
 823e434:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e438:	01000084 	movi	r4,2
 823e43c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 823e440:	00800084 	movi	r2,2
}
 823e444:	e037883a 	mov	sp,fp
 823e448:	dfc00117 	ldw	ra,4(sp)
 823e44c:	df000017 	ldw	fp,0(sp)
 823e450:	dec00204 	addi	sp,sp,8
 823e454:	f800283a 	ret

0823e458 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 823e458:	defff804 	addi	sp,sp,-32
 823e45c:	dfc00715 	stw	ra,28(sp)
 823e460:	df000615 	stw	fp,24(sp)
 823e464:	df000604 	addi	fp,sp,24
 823e468:	e13ffe15 	stw	r4,-8(fp)
 823e46c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 823e470:	d0a0a817 	ldw	r2,-32096(gp)
 823e474:	e0bffd15 	stw	r2,-12(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 823e478:	e0bfff17 	ldw	r2,-4(fp)
 823e47c:	1000081e 	bne	r2,zero,823e4a0 <send_via_arp+0x48>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e480:	01000084 	movi	r4,2
 823e484:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823e488:	e13ffe17 	ldw	r4,-8(fp)
 823e48c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e490:	01000084 	movi	r4,2
 823e494:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 823e498:	00bffa84 	movi	r2,-22
 823e49c:	00004906 	br	823e5c4 <send_via_arp+0x16c>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 823e4a0:	d0a0c117 	ldw	r2,-31996(gp)
 823e4a4:	e0fffd17 	ldw	r3,-12(fp)
 823e4a8:	1885c83a 	sub	r2,r3,r2
 823e4ac:	10801970 	cmpltui	r2,r2,101
 823e4b0:	1000011e 	bne	r2,zero,823e4b8 <send_via_arp+0x60>
      arpcache = (struct arptabent *)NULL;
 823e4b4:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 823e4b8:	d0a0c017 	ldw	r2,-32000(gp)
 823e4bc:	10000726 	beq	r2,zero,823e4dc <send_via_arp+0x84>
 823e4c0:	d0a0c017 	ldw	r2,-32000(gp)
 823e4c4:	10c00017 	ldw	r3,0(r2)
 823e4c8:	e0bfff17 	ldw	r2,-4(fp)
 823e4cc:	1880031e 	bne	r3,r2,823e4dc <send_via_arp+0x84>
      tp = arpcache;
 823e4d0:	d0a0c017 	ldw	r2,-32000(gp)
 823e4d4:	e0bffa15 	stw	r2,-24(fp)
 823e4d8:	00000306 	br	823e4e8 <send_via_arp+0x90>
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 823e4dc:	e13fff17 	ldw	r4,-4(fp)
 823e4e0:	823dccc0 	call	823dccc <find_oldest_arp>
 823e4e4:	e0bffa15 	stw	r2,-24(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 823e4e8:	e0bffa17 	ldw	r2,-24(fp)
 823e4ec:	10c00017 	ldw	r3,0(r2)
 823e4f0:	e0bfff17 	ldw	r2,-4(fp)
 823e4f4:	18802e1e 	bne	r3,r2,823e5b0 <send_via_arp+0x158>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 823e4f8:	e0bffa17 	ldw	r2,-24(fp)
 823e4fc:	10800417 	ldw	r2,16(r2)
 823e500:	10002226 	beq	r2,zero,823e58c <send_via_arp+0x134>
      {
         if (lilfreeq.q_len < 2)
 823e504:	008209b4 	movhi	r2,2086
 823e508:	10b71404 	addi	r2,r2,-9136
 823e50c:	10800217 	ldw	r2,8(r2)
 823e510:	10800088 	cmpgei	r2,r2,2
 823e514:	1000091e 	bne	r2,zero,823e53c <send_via_arp+0xe4>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823e518:	01000084 	movi	r4,2
 823e51c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 823e520:	e13ffe17 	ldw	r4,-8(fp)
 823e524:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e528:	01000084 	movi	r4,2
 823e52c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 823e530:	00bffa84 	movi	r2,-22
 823e534:	e0bffb15 	stw	r2,-20(fp)
 823e538:	00002106 	br	823e5c0 <send_via_arp+0x168>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 823e53c:	e0bffa17 	ldw	r2,-24(fp)
 823e540:	10800417 	ldw	r2,16(r2)
 823e544:	e0bffc15 	stw	r2,-16(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e548:	00000306 	br	823e558 <send_via_arp+0x100>
               tmppkt = tmppkt->next;
 823e54c:	e0bffc17 	ldw	r2,-16(fp)
 823e550:	10800017 	ldw	r2,0(r2)
 823e554:	e0bffc15 	stw	r2,-16(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e558:	e0bffc17 	ldw	r2,-16(fp)
 823e55c:	10800017 	ldw	r2,0(r2)
 823e560:	103ffa1e 	bne	r2,zero,823e54c <send_via_arp+0xf4>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 823e564:	e0bffc17 	ldw	r2,-16(fp)
 823e568:	e0fffe17 	ldw	r3,-8(fp)
 823e56c:	10c00015 	stw	r3,0(r2)
            if (pkt->next)
 823e570:	e0bffe17 	ldw	r2,-8(fp)
 823e574:	10800017 	ldw	r2,0(r2)
 823e578:	10000126 	beq	r2,zero,823e580 <send_via_arp+0x128>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 823e57c:	822d1c80 	call	822d1c8 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 823e580:	00800044 	movi	r2,1
 823e584:	e0bffb15 	stw	r2,-20(fp)
 823e588:	00000d06 	br	823e5c0 <send_via_arp+0x168>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 823e58c:	e0bffa17 	ldw	r2,-24(fp)
 823e590:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 823e594:	e0bffd17 	ldw	r2,-12(fp)
 823e598:	d0a0c115 	stw	r2,-31996(gp)
         err = et_send(pkt, tp);
 823e59c:	e17ffa17 	ldw	r5,-24(fp)
 823e5a0:	e13ffe17 	ldw	r4,-8(fp)
 823e5a4:	823d5fc0 	call	823d5fc <et_send>
 823e5a8:	e0bffb15 	stw	r2,-20(fp)
 823e5ac:	00000406 	br	823e5c0 <send_via_arp+0x168>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 823e5b0:	e17fff17 	ldw	r5,-4(fp)
 823e5b4:	e13ffe17 	ldw	r4,-8(fp)
 823e5b8:	823d8780 	call	823d878 <send_arp>
 823e5bc:	e0bffb15 	stw	r2,-20(fp)

   return (err);
 823e5c0:	e0bffb17 	ldw	r2,-20(fp)
}
 823e5c4:	e037883a 	mov	sp,fp
 823e5c8:	dfc00117 	ldw	ra,4(sp)
 823e5cc:	df000017 	ldw	fp,0(sp)
 823e5d0:	dec00204 	addi	sp,sp,8
 823e5d4:	f800283a 	ret

0823e5d8 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 823e5d8:	defffa04 	addi	sp,sp,-24
 823e5dc:	dfc00515 	stw	ra,20(sp)
 823e5e0:	df000415 	stw	fp,16(sp)
 823e5e4:	df000404 	addi	fp,sp,16
 823e5e8:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 823e5ec:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e5f0:	d0a0a817 	ldw	r2,-32096(gp)
 823e5f4:	e0bffe15 	stw	r2,-8(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e5f8:	008209b4 	movhi	r2,2086
 823e5fc:	10b8b304 	addi	r2,r2,-7476
 823e600:	e0bffc15 	stw	r2,-16(fp)
 823e604:	00002706 	br	823e6a4 <cb_arpent_tmo+0xcc>
   {
      if (tp->t_pro_addr != 0)
 823e608:	e0bffc17 	ldw	r2,-16(fp)
 823e60c:	10800017 	ldw	r2,0(r2)
 823e610:	10002126 	beq	r2,zero,823e698 <cb_arpent_tmo+0xc0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 823e614:	e0bffc17 	ldw	r2,-16(fp)
 823e618:	10800417 	ldw	r2,16(r2)
 823e61c:	10000b26 	beq	r2,zero,823e64c <cb_arpent_tmo+0x74>
 823e620:	e0bffc17 	ldw	r2,-16(fp)
 823e624:	10800517 	ldw	r2,20(r2)
 823e628:	e0fffe17 	ldw	r3,-8(fp)
 823e62c:	1885c83a 	sub	r2,r3,r2
 823e630:	10801970 	cmpltui	r2,r2,101
 823e634:	1000051e 	bne	r2,zero,823e64c <cb_arpent_tmo+0x74>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 823e638:	e13ffc17 	ldw	r4,-16(fp)
 823e63c:	823d77c0 	call	823d77c <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e640:	e0bffc17 	ldw	r2,-16(fp)
 823e644:	10000015 	stw	zero,0(r2)
 823e648:	00001306 	br	823e698 <cb_arpent_tmo+0xc0>
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e64c:	e0bffc17 	ldw	r2,-16(fp)
 823e650:	10800517 	ldw	r2,20(r2)
 823e654:	e0fffe17 	ldw	r3,-8(fp)
 823e658:	1885c83a 	sub	r2,r3,r2
 823e65c:	1007883a 	mov	r3,r2
 823e660:	d0a04f17 	ldw	r2,-32452(gp)
 823e664:	18800916 	blt	r3,r2,823e68c <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
 823e668:	e0bffc17 	ldw	r2,-16(fp)
 823e66c:	10800617 	ldw	r2,24(r2)
 823e670:	e0fffe17 	ldw	r3,-8(fp)
 823e674:	1885c83a 	sub	r2,r3,r2
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e678:	10801910 	cmplti	r2,r2,100
 823e67c:	1000031e 	bne	r2,zero,823e68c <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e680:	e0bffc17 	ldw	r2,-16(fp)
 823e684:	10000015 	stw	zero,0(r2)
 823e688:	00000306 	br	823e698 <cb_arpent_tmo+0xc0>
         }
         else
            arp_count++;
 823e68c:	e0bffd17 	ldw	r2,-12(fp)
 823e690:	10800044 	addi	r2,r2,1
 823e694:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e698:	e0bffc17 	ldw	r2,-16(fp)
 823e69c:	10800804 	addi	r2,r2,32
 823e6a0:	e0bffc15 	stw	r2,-16(fp)
 823e6a4:	e0fffc17 	ldw	r3,-16(fp)
 823e6a8:	008209b4 	movhi	r2,2086
 823e6ac:	10b8f304 	addi	r2,r2,-7220
 823e6b0:	18bfd536 	bltu	r3,r2,823e608 <cb_arpent_tmo+0x30>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 823e6b4:	e0bffd17 	ldw	r2,-12(fp)
 823e6b8:	1000041e 	bne	r2,zero,823e6cc <cb_arpent_tmo+0xf4>
   {
      in_timerkill(arp_timer);
 823e6bc:	d0a0bf17 	ldw	r2,-32004(gp)
 823e6c0:	1009883a 	mov	r4,r2
 823e6c4:	823d3d80 	call	823d3d8 <in_timerkill>
      arp_timer = 0;
 823e6c8:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 823e6cc:	0001883a 	nop
 823e6d0:	e037883a 	mov	sp,fp
 823e6d4:	dfc00117 	ldw	ra,4(sp)
 823e6d8:	df000017 	ldw	fp,0(sp)
 823e6dc:	dec00204 	addi	sp,sp,8
 823e6e0:	f800283a 	ret

0823e6e4 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 823e6e4:	defff704 	addi	sp,sp,-36
 823e6e8:	dfc00815 	stw	ra,32(sp)
 823e6ec:	df000715 	stw	fp,28(sp)
 823e6f0:	df000704 	addi	fp,sp,28
 823e6f4:	e13ffe15 	stw	r4,-8(fp)
 823e6f8:	e17fff15 	stw	r5,-4(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 823e6fc:	e0bffe17 	ldw	r2,-8(fp)
 823e700:	10802717 	ldw	r2,156(r2)
 823e704:	e0bff915 	stw	r2,-28(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823e708:	01000084 	movi	r4,2
 823e70c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823e710:	01000c04 	movi	r4,48
 823e714:	822c6200 	call	822c620 <pk_alloc>
 823e718:	e0bffa15 	stw	r2,-24(fp)
   if (!arppkt)
 823e71c:	e0bffa17 	ldw	r2,-24(fp)
 823e720:	1000041e 	bne	r2,zero,823e734 <grat_arp+0x50>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e724:	01000084 	movi	r4,2
 823e728:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823e72c:	00bffa84 	movi	r2,-22
 823e730:	00009506 	br	823e988 <grat_arp+0x2a4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e734:	01000084 	movi	r4,2
 823e738:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823e73c:	e0bffa17 	ldw	r2,-24(fp)
 823e740:	10c00117 	ldw	r3,4(r2)
 823e744:	e0bffa17 	ldw	r2,-24(fp)
 823e748:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823e74c:	e0bffa17 	ldw	r2,-24(fp)
 823e750:	00c00c04 	movi	r3,48
 823e754:	10c00415 	stw	r3,16(r2)
   arppkt->net = net;
 823e758:	e0bffa17 	ldw	r2,-24(fp)
 823e75c:	e0fffe17 	ldw	r3,-8(fp)
 823e760:	10c00615 	stw	r3,24(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823e764:	e0bffa17 	ldw	r2,-24(fp)
 823e768:	10800117 	ldw	r2,4(r2)
 823e76c:	10800084 	addi	r2,r2,2
 823e770:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823e774:	e0bffa17 	ldw	r2,-24(fp)
 823e778:	10800117 	ldw	r2,4(r2)
 823e77c:	10800404 	addi	r2,r2,16
 823e780:	e0bffc15 	stw	r2,-16(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e784:	e0bffc17 	ldw	r2,-16(fp)
 823e788:	00c04004 	movi	r3,256
 823e78c:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823e790:	e0bffc17 	ldw	r2,-16(fp)
 823e794:	00c00204 	movi	r3,8
 823e798:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823e79c:	e0bffc17 	ldw	r2,-16(fp)
 823e7a0:	00c00184 	movi	r3,6
 823e7a4:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823e7a8:	e0bffc17 	ldw	r2,-16(fp)
 823e7ac:	00c00104 	movi	r3,4
 823e7b0:	10c00145 	stb	r3,5(r2)
   
   /* ARP req? */
   if (flag == 0)
 823e7b4:	e0bfff17 	ldw	r2,-4(fp)
 823e7b8:	1000041e 	bne	r2,zero,823e7cc <grat_arp+0xe8>
      /* yup */
      arphdr->ar_op = ARREQ;
 823e7bc:	e0bffc17 	ldw	r2,-16(fp)
 823e7c0:	00c04004 	movi	r3,256
 823e7c4:	10c0018d 	sth	r3,6(r2)
 823e7c8:	00000306 	br	823e7d8 <grat_arp+0xf4>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 823e7cc:	e0bffc17 	ldw	r2,-16(fp)
 823e7d0:	00c08004 	movi	r3,512
 823e7d4:	10c0018d 	sth	r3,6(r2)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 823e7d8:	e0bffe17 	ldw	r2,-8(fp)
 823e7dc:	10c00a17 	ldw	r3,40(r2)
 823e7e0:	e0bffc17 	ldw	r2,-16(fp)
 823e7e4:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 823e7e8:	e0bffe17 	ldw	r2,-8(fp)
 823e7ec:	10c00a17 	ldw	r3,40(r2)
 823e7f0:	e0bffc17 	ldw	r2,-16(fp)
 823e7f4:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823e7f8:	e0bffc17 	ldw	r2,-16(fp)
 823e7fc:	10c00204 	addi	r3,r2,8
 823e800:	e0bff917 	ldw	r2,-28(fp)
 823e804:	10800517 	ldw	r2,20(r2)
 823e808:	01800184 	movi	r6,6
 823e80c:	100b883a 	mov	r5,r2
 823e810:	1809883a 	mov	r4,r3
 823e814:	8202b540 	call	8202b54 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823e818:	01800184 	movi	r6,6
 823e81c:	01403fc4 	movi	r5,255
 823e820:	e13ffb17 	ldw	r4,-20(fp)
 823e824:	8202cb00 	call	8202cb0 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823e828:	e0bffb17 	ldw	r2,-20(fp)
 823e82c:	10c00184 	addi	r3,r2,6
 823e830:	e0bff917 	ldw	r2,-28(fp)
 823e834:	10800517 	ldw	r2,20(r2)
 823e838:	01800184 	movi	r6,6
 823e83c:	100b883a 	mov	r5,r2
 823e840:	1809883a 	mov	r4,r3
 823e844:	8202b540 	call	8202b54 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823e848:	e0bffb17 	ldw	r2,-20(fp)
 823e84c:	10800304 	addi	r2,r2,12
 823e850:	00c00204 	movi	r3,8
 823e854:	10c00005 	stb	r3,0(r2)
 823e858:	e0bffb17 	ldw	r2,-20(fp)
 823e85c:	10800344 	addi	r2,r2,13
 823e860:	00c00184 	movi	r3,6
 823e864:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e868:	e0bffc17 	ldw	r2,-16(fp)
 823e86c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823e870:	e0bffd17 	ldw	r2,-12(fp)
 823e874:	10c00204 	addi	r3,r2,8
 823e878:	e0bffc17 	ldw	r2,-16(fp)
 823e87c:	10800204 	addi	r2,r2,8
 823e880:	01800184 	movi	r6,6
 823e884:	100b883a 	mov	r5,r2
 823e888:	1809883a 	mov	r4,r3
 823e88c:	8202b540 	call	8202b54 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823e890:	e0bffd17 	ldw	r2,-12(fp)
 823e894:	10c00384 	addi	r3,r2,14
 823e898:	e0bffc17 	ldw	r2,-16(fp)
 823e89c:	10800404 	addi	r2,r2,16
 823e8a0:	01800104 	movi	r6,4
 823e8a4:	100b883a 	mov	r5,r2
 823e8a8:	1809883a 	mov	r4,r3
 823e8ac:	8202b540 	call	8202b54 <memmove>

   /* ARP req? */
   if (flag == 0)
 823e8b0:	e0bfff17 	ldw	r2,-4(fp)
 823e8b4:	1000091e 	bne	r2,zero,823e8dc <grat_arp+0x1f8>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823e8b8:	e0bffd17 	ldw	r2,-12(fp)
 823e8bc:	10c00484 	addi	r3,r2,18
 823e8c0:	e0bffc17 	ldw	r2,-16(fp)
 823e8c4:	10800504 	addi	r2,r2,20
 823e8c8:	01800184 	movi	r6,6
 823e8cc:	100b883a 	mov	r5,r2
 823e8d0:	1809883a 	mov	r4,r3
 823e8d4:	8202b540 	call	8202b54 <memmove>
 823e8d8:	00000806 	br	823e8fc <grat_arp+0x218>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 823e8dc:	e0bffd17 	ldw	r2,-12(fp)
 823e8e0:	10c00484 	addi	r3,r2,18
 823e8e4:	e0bffc17 	ldw	r2,-16(fp)
 823e8e8:	10800204 	addi	r2,r2,8
 823e8ec:	01800184 	movi	r6,6
 823e8f0:	100b883a 	mov	r5,r2
 823e8f4:	1809883a 	mov	r4,r3
 823e8f8:	8202b540 	call	8202b54 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823e8fc:	e0bffd17 	ldw	r2,-12(fp)
 823e900:	10c00604 	addi	r3,r2,24
 823e904:	e0bffc17 	ldw	r2,-16(fp)
 823e908:	10800704 	addi	r2,r2,28
 823e90c:	01800104 	movi	r6,4
 823e910:	100b883a 	mov	r5,r2
 823e914:	1809883a 	mov	r4,r3
 823e918:	8202b540 	call	8202b54 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823e91c:	e0bffe17 	ldw	r2,-8(fp)
 823e920:	10800417 	ldw	r2,16(r2)
 823e924:	10000526 	beq	r2,zero,823e93c <grat_arp+0x258>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823e928:	e0bffe17 	ldw	r2,-8(fp)
 823e92c:	10800417 	ldw	r2,16(r2)
 823e930:	e13ffa17 	ldw	r4,-24(fp)
 823e934:	103ee83a 	callr	r2
 823e938:	00000f06 	br	823e978 <grat_arp+0x294>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823e93c:	e0bffe17 	ldw	r2,-8(fp)
 823e940:	10800317 	ldw	r2,12(r2)
 823e944:	e0fffa17 	ldw	r3,-24(fp)
 823e948:	19000617 	ldw	r4,24(r3)
 823e94c:	e0fffa17 	ldw	r3,-24(fp)
 823e950:	18c00117 	ldw	r3,4(r3)
 823e954:	01800c04 	movi	r6,48
 823e958:	180b883a 	mov	r5,r3
 823e95c:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e960:	01000084 	movi	r4,2
 823e964:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823e968:	e13ffa17 	ldw	r4,-24(fp)
 823e96c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e970:	01000084 	movi	r4,2
 823e974:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823e978:	d0a0c317 	ldw	r2,-31988(gp)
 823e97c:	10800044 	addi	r2,r2,1
 823e980:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823e984:	00800044 	movi	r2,1
}
 823e988:	e037883a 	mov	sp,fp
 823e98c:	dfc00117 	ldw	ra,4(sp)
 823e990:	df000017 	ldw	fp,0(sp)
 823e994:	dec00204 	addi	sp,sp,8
 823e998:	f800283a 	ret

0823e99c <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 823e99c:	defffc04 	addi	sp,sp,-16
 823e9a0:	dfc00315 	stw	ra,12(sp)
 823e9a4:	df000215 	stw	fp,8(sp)
 823e9a8:	df000204 	addi	fp,sp,8
 823e9ac:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823e9b0:	008209b4 	movhi	r2,2086
 823e9b4:	10b8f304 	addi	r2,r2,-7220
 823e9b8:	10800017 	ldw	r2,0(r2)
 823e9bc:	e0bffe15 	stw	r2,-8(fp)
 823e9c0:	00000906 	br	823e9e8 <if_getbynum+0x4c>
   {
      if(ifnum-- == 0)
 823e9c4:	e0bfff17 	ldw	r2,-4(fp)
 823e9c8:	10ffffc4 	addi	r3,r2,-1
 823e9cc:	e0ffff15 	stw	r3,-4(fp)
 823e9d0:	1000021e 	bne	r2,zero,823e9dc <if_getbynum+0x40>
         return ifp;
 823e9d4:	e0bffe17 	ldw	r2,-8(fp)
 823e9d8:	00000706 	br	823e9f8 <if_getbynum+0x5c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823e9dc:	e0bffe17 	ldw	r2,-8(fp)
 823e9e0:	10800017 	ldw	r2,0(r2)
 823e9e4:	e0bffe15 	stw	r2,-8(fp)
 823e9e8:	e0bffe17 	ldw	r2,-8(fp)
 823e9ec:	103ff51e 	bne	r2,zero,823e9c4 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 823e9f0:	822d1c80 	call	822d1c8 <dtrap>
   return NULL;   /* list is not long enough */
 823e9f4:	0005883a 	mov	r2,zero
}
 823e9f8:	e037883a 	mov	sp,fp
 823e9fc:	dfc00117 	ldw	ra,4(sp)
 823ea00:	df000017 	ldw	fp,0(sp)
 823ea04:	dec00204 	addi	sp,sp,8
 823ea08:	f800283a 	ret

0823ea0c <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 823ea0c:	defffd04 	addi	sp,sp,-12
 823ea10:	df000215 	stw	fp,8(sp)
 823ea14:	df000204 	addi	fp,sp,8
 823ea18:	e13ffe15 	stw	r4,-8(fp)
 823ea1c:	e17fff15 	stw	r5,-4(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 823ea20:	e0bfff17 	ldw	r2,-4(fp)
 823ea24:	108000cc 	andi	r2,r2,3
 823ea28:	10000e26 	beq	r2,zero,823ea64 <isbcast+0x58>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 823ea2c:	e0bfff17 	ldw	r2,-4(fp)
 823ea30:	1080000b 	ldhu	r2,0(r2)
 823ea34:	10ffffcc 	andi	r3,r2,65535
 823ea38:	00bfffd4 	movui	r2,65535
 823ea3c:	18800226 	beq	r3,r2,823ea48 <isbcast+0x3c>
         return(FALSE);
 823ea40:	0005883a 	mov	r2,zero
 823ea44:	00002206 	br	823ead0 <isbcast+0xc4>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 823ea48:	e0bfff17 	ldw	r2,-4(fp)
 823ea4c:	10800084 	addi	r2,r2,2
 823ea50:	10800017 	ldw	r2,0(r2)
 823ea54:	10bfffe0 	cmpeqi	r2,r2,-1
 823ea58:	1000101e 	bne	r2,zero,823ea9c <isbcast+0x90>
         return FALSE;
 823ea5c:	0005883a 	mov	r2,zero
 823ea60:	00001b06 	br	823ead0 <isbcast+0xc4>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 823ea64:	e0bfff17 	ldw	r2,-4(fp)
 823ea68:	10800017 	ldw	r2,0(r2)
 823ea6c:	10bfffe0 	cmpeqi	r2,r2,-1
 823ea70:	1000021e 	bne	r2,zero,823ea7c <isbcast+0x70>
         return FALSE;
 823ea74:	0005883a 	mov	r2,zero
 823ea78:	00001506 	br	823ead0 <isbcast+0xc4>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 823ea7c:	e0bfff17 	ldw	r2,-4(fp)
 823ea80:	10800104 	addi	r2,r2,4
 823ea84:	1080000b 	ldhu	r2,0(r2)
 823ea88:	10ffffcc 	andi	r3,r2,65535
 823ea8c:	00bfffd4 	movui	r2,65535
 823ea90:	18800226 	beq	r3,r2,823ea9c <isbcast+0x90>
         return(FALSE);
 823ea94:	0005883a 	mov	r2,zero
 823ea98:	00000d06 	br	823ead0 <isbcast+0xc4>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823ea9c:	e0bffe17 	ldw	r2,-8(fp)
 823eaa0:	10802717 	ldw	r2,156(r2)
 823eaa4:	10800217 	ldw	r2,8(r2)
 823eaa8:	108005e0 	cmpeqi	r2,r2,23
 823eaac:	1000051e 	bne	r2,zero,823eac4 <isbcast+0xb8>
       (ifc->n_mib->ifType == SLIP))
 823eab0:	e0bffe17 	ldw	r2,-8(fp)
 823eab4:	10802717 	ldw	r2,156(r2)
 823eab8:	10800217 	ldw	r2,8(r2)
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
         return(FALSE);
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823eabc:	10800718 	cmpnei	r2,r2,28
 823eac0:	1000021e 	bne	r2,zero,823eacc <isbcast+0xc0>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 823eac4:	0005883a 	mov	r2,zero
 823eac8:	00000106 	br	823ead0 <isbcast+0xc4>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 823eacc:	00800044 	movi	r2,1
}
 823ead0:	e037883a 	mov	sp,fp
 823ead4:	df000017 	ldw	fp,0(sp)
 823ead8:	dec00104 	addi	sp,sp,4
 823eadc:	f800283a 	ret

0823eae0 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 823eae0:	defffb04 	addi	sp,sp,-20
 823eae4:	dfc00415 	stw	ra,16(sp)
 823eae8:	df000315 	stw	fp,12(sp)
 823eaec:	df000304 	addi	fp,sp,12
 823eaf0:	2005883a 	mov	r2,r4
 823eaf4:	e0bfff0d 	sth	r2,-4(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823eaf8:	008209b4 	movhi	r2,2086
 823eafc:	10b8f304 	addi	r2,r2,-7220
 823eb00:	10800017 	ldw	r2,0(r2)
 823eb04:	e0bffd15 	stw	r2,-12(fp)
 823eb08:	00001106 	br	823eb50 <reg_type+0x70>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 823eb0c:	e0bffd17 	ldw	r2,-12(fp)
 823eb10:	10800617 	ldw	r2,24(r2)
 823eb14:	10000b26 	beq	r2,zero,823eb44 <reg_type+0x64>
      {
         e = (ifp->n_reg_type)(type, ifp);
 823eb18:	e0bffd17 	ldw	r2,-12(fp)
 823eb1c:	10800617 	ldw	r2,24(r2)
 823eb20:	e0ffff0b 	ldhu	r3,-4(fp)
 823eb24:	e17ffd17 	ldw	r5,-12(fp)
 823eb28:	1809883a 	mov	r4,r3
 823eb2c:	103ee83a 	callr	r2
 823eb30:	e0bffe15 	stw	r2,-8(fp)
         if (e)
 823eb34:	e0bffe17 	ldw	r2,-8(fp)
 823eb38:	10000226 	beq	r2,zero,823eb44 <reg_type+0x64>
            return e;   /* bails out if error */
 823eb3c:	e0bffe17 	ldw	r2,-8(fp)
 823eb40:	00000606 	br	823eb5c <reg_type+0x7c>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823eb44:	e0bffd17 	ldw	r2,-12(fp)
 823eb48:	10800017 	ldw	r2,0(r2)
 823eb4c:	e0bffd15 	stw	r2,-12(fp)
 823eb50:	e0bffd17 	ldw	r2,-12(fp)
 823eb54:	103fed1e 	bne	r2,zero,823eb0c <reg_type+0x2c>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 823eb58:	0005883a 	mov	r2,zero
}
 823eb5c:	e037883a 	mov	sp,fp
 823eb60:	dfc00117 	ldw	ra,4(sp)
 823eb64:	df000017 	ldw	fp,0(sp)
 823eb68:	dec00204 	addi	sp,sp,8
 823eb6c:	f800283a 	ret

0823eb70 <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 823eb70:	defffa04 	addi	sp,sp,-24
 823eb74:	dfc00515 	stw	ra,20(sp)
 823eb78:	df000415 	stw	fp,16(sp)
 823eb7c:	df000404 	addi	fp,sp,16
 823eb80:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 823eb84:	008209b4 	movhi	r2,2086
 823eb88:	10b7ef04 	addi	r2,r2,-8260
 823eb8c:	10800017 	ldw	r2,0(r2)
 823eb90:	e0bffc15 	stw	r2,-16(fp)
   while(so)
 823eb94:	00001306 	br	823ebe4 <if_killsocks+0x74>
   {
      if(so->so_pcb)
 823eb98:	e0bffc17 	ldw	r2,-16(fp)
 823eb9c:	10800117 	ldw	r2,4(r2)
 823eba0:	10000526 	beq	r2,zero,823ebb8 <if_killsocks+0x48>
         so_ifp = so->so_pcb->ifp;
 823eba4:	e0bffc17 	ldw	r2,-16(fp)
 823eba8:	10800117 	ldw	r2,4(r2)
 823ebac:	10800a17 	ldw	r2,40(r2)
 823ebb0:	e0bffd15 	stw	r2,-12(fp)
 823ebb4:	00000106 	br	823ebbc <if_killsocks+0x4c>
      else
         so_ifp = NULL;
 823ebb8:	e03ffd15 	stw	zero,-12(fp)
      next = (struct socket *)so->next;
 823ebbc:	e0bffc17 	ldw	r2,-16(fp)
 823ebc0:	10800017 	ldw	r2,0(r2)
 823ebc4:	e0bffe15 	stw	r2,-8(fp)
      if (so_ifp == ifp)
 823ebc8:	e0fffd17 	ldw	r3,-12(fp)
 823ebcc:	e0bfff17 	ldw	r2,-4(fp)
 823ebd0:	1880021e 	bne	r3,r2,823ebdc <if_killsocks+0x6c>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 823ebd4:	e13ffc17 	ldw	r4,-16(fp)
 823ebd8:	8231d080 	call	8231d08 <soabort>
      }
      so = next;
 823ebdc:	e0bffe17 	ldw	r2,-8(fp)
 823ebe0:	e0bffc15 	stw	r2,-16(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 823ebe4:	e0bffc17 	ldw	r2,-16(fp)
 823ebe8:	103feb1e 	bne	r2,zero,823eb98 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 823ebec:	0001883a 	nop
 823ebf0:	e037883a 	mov	sp,fp
 823ebf4:	dfc00117 	ldw	ra,4(sp)
 823ebf8:	df000017 	ldw	fp,0(sp)
 823ebfc:	dec00204 	addi	sp,sp,8
 823ec00:	f800283a 	ret

0823ec04 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 823ec04:	defffe04 	addi	sp,sp,-8
 823ec08:	dfc00115 	stw	ra,4(sp)
 823ec0c:	df000015 	stw	fp,0(sp)
 823ec10:	d839883a 	mov	fp,sp

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 823ec14:	01000204 	movi	r4,8
 823ec18:	823eae00 	call	823eae0 <reg_type>
 823ec1c:	10000526 	beq	r2,zero,823ec34 <ip_init+0x30>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 823ec20:	01020974 	movhi	r4,2085
 823ec24:	2102f404 	addi	r4,r4,3024
 823ec28:	82031200 	call	8203120 <puts>
#endif
      return(1);
 823ec2c:	00800044 	movi	r2,1
 823ec30:	00002906 	br	823ecd8 <ip_init+0xd4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 823ec34:	01801404 	movi	r6,80
 823ec38:	000b883a 	mov	r5,zero
 823ec3c:	010209b4 	movhi	r4,2086
 823ec40:	2138f804 	addi	r4,r4,-7200
 823ec44:	8202cb00 	call	8202cb0 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 823ec48:	008209b4 	movhi	r2,2086
 823ec4c:	10b8f804 	addi	r2,r2,-7200
 823ec50:	00c00084 	movi	r3,2
 823ec54:	10c00015 	stw	r3,0(r2)
   ip_mib.ipDefaultTTL = IP_TTL;
 823ec58:	008209b4 	movhi	r2,2086
 823ec5c:	10b8f804 	addi	r2,r2,-7200
 823ec60:	00c01004 	movi	r3,64
 823ec64:	10c00115 	stw	r3,4(r2)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 823ec68:	d0a05117 	ldw	r2,-32444(gp)
 823ec6c:	10800f24 	muli	r2,r2,60
 823ec70:	1009883a 	mov	r4,r2
 823ec74:	822dda00 	call	822dda0 <npalloc>
 823ec78:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 823ec7c:	d0a0c617 	ldw	r2,-31976(gp)
 823ec80:	1000051e 	bne	r2,zero,823ec98 <ip_init+0x94>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 823ec84:	01020974 	movhi	r4,2085
 823ec88:	21030104 	addi	r4,r4,3076
 823ec8c:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 823ec90:	00bffb04 	movi	r2,-20
 823ec94:	00001006 	br	823ecd8 <ip_init+0xd4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 823ec98:	d0e0c617 	ldw	r3,-31976(gp)
 823ec9c:	d0a05117 	ldw	r2,-32444(gp)
 823eca0:	10800f24 	muli	r2,r2,60
 823eca4:	100d883a 	mov	r6,r2
 823eca8:	000b883a 	mov	r5,zero
 823ecac:	1809883a 	mov	r4,r3
 823ecb0:	8202cb00 	call	8202cb0 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 823ecb4:	008209b4 	movhi	r2,2086
 823ecb8:	10b8f804 	addi	r2,r2,-7200
 823ecbc:	00c00044 	movi	r3,1
 823ecc0:	10c00015 	stw	r3,0(r2)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 823ecc4:	008209b4 	movhi	r2,2086
 823ecc8:	10b8f804 	addi	r2,r2,-7200
 823eccc:	00c01e04 	movi	r3,120
 823ecd0:	10c00c15 	stw	r3,48(r2)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 823ecd4:	0005883a 	mov	r2,zero
}
 823ecd8:	e037883a 	mov	sp,fp
 823ecdc:	dfc00117 	ldw	ra,4(sp)
 823ece0:	df000017 	ldw	fp,0(sp)
 823ece4:	dec00204 	addi	sp,sp,8
 823ece8:	f800283a 	ret

0823ecec <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 823ecec:	defff804 	addi	sp,sp,-32
 823ecf0:	dfc00715 	stw	ra,28(sp)
 823ecf4:	df000615 	stw	fp,24(sp)
 823ecf8:	df000604 	addi	fp,sp,24
 823ecfc:	e13ffc15 	stw	r4,-16(fp)
 823ed00:	e17ffd15 	stw	r5,-12(fp)
 823ed04:	3007883a 	mov	r3,r6
 823ed08:	3805883a 	mov	r2,r7
 823ed0c:	e0fffe05 	stb	r3,-8(fp)
 823ed10:	e0bfff0d 	sth	r2,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 823ed14:	e0bffc17 	ldw	r2,-16(fp)
 823ed18:	10800317 	ldw	r2,12(r2)
 823ed1c:	10fffb04 	addi	r3,r2,-20
 823ed20:	e0bffc17 	ldw	r2,-16(fp)
 823ed24:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823ed28:	e0bffc17 	ldw	r2,-16(fp)
 823ed2c:	10800417 	ldw	r2,16(r2)
 823ed30:	10c00504 	addi	r3,r2,20
 823ed34:	e0bffc17 	ldw	r2,-16(fp)
 823ed38:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 823ed3c:	e0bffc17 	ldw	r2,-16(fp)
 823ed40:	10800317 	ldw	r2,12(r2)
 823ed44:	e0bffa15 	stw	r2,-24(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823ed48:	e0bffa17 	ldw	r2,-24(fp)
 823ed4c:	00c01144 	movi	r3,69
 823ed50:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 823ed54:	e0bffa17 	ldw	r2,-24(fp)
 823ed58:	e0ffff0b 	ldhu	r3,-4(fp)
 823ed5c:	10c0018d 	sth	r3,6(r2)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 823ed60:	e0bffd17 	ldw	r2,-12(fp)
 823ed64:	10bfffcc 	andi	r2,r2,65535
 823ed68:	1005d23a 	srai	r2,r2,8
 823ed6c:	10803fcc 	andi	r2,r2,255
 823ed70:	1007883a 	mov	r3,r2
 823ed74:	e0bffd17 	ldw	r2,-12(fp)
 823ed78:	10bfffcc 	andi	r2,r2,65535
 823ed7c:	1004923a 	slli	r2,r2,8
 823ed80:	1884b03a 	or	r2,r3,r2
 823ed84:	1007883a 	mov	r3,r2
 823ed88:	e0bffa17 	ldw	r2,-24(fp)
 823ed8c:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 823ed90:	e0bffc17 	ldw	r2,-16(fp)
 823ed94:	10800417 	ldw	r2,16(r2)
 823ed98:	10bfffcc 	andi	r2,r2,65535
 823ed9c:	1005d23a 	srai	r2,r2,8
 823eda0:	10803fcc 	andi	r2,r2,255
 823eda4:	1007883a 	mov	r3,r2
 823eda8:	e0bffc17 	ldw	r2,-16(fp)
 823edac:	10800417 	ldw	r2,16(r2)
 823edb0:	10bfffcc 	andi	r2,r2,65535
 823edb4:	1004923a 	slli	r2,r2,8
 823edb8:	1884b03a 	or	r2,r3,r2
 823edbc:	1007883a 	mov	r3,r2
 823edc0:	e0bffa17 	ldw	r2,-24(fp)
 823edc4:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 823edc8:	e0bffa17 	ldw	r2,-24(fp)
 823edcc:	e0fffe03 	ldbu	r3,-8(fp)
 823edd0:	10c00245 	stb	r3,9(r2)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823edd4:	e0bffc17 	ldw	r2,-16(fp)
 823edd8:	10800c17 	ldw	r2,48(r2)
 823eddc:	e0bffb15 	stw	r2,-20(fp)
 823ede0:	e0bffb17 	ldw	r2,-20(fp)
 823ede4:	10001126 	beq	r2,zero,823ee2c <ip_bldhead+0x140>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823ede8:	e0bffb17 	ldw	r2,-20(fp)
 823edec:	10800043 	ldbu	r2,1(r2)
 823edf0:	10803fcc 	andi	r2,r2,255
 823edf4:	10000526 	beq	r2,zero,823ee0c <ip_bldhead+0x120>
         pip->ip_time = sopts->ip_ttl;
 823edf8:	e0bffb17 	ldw	r2,-20(fp)
 823edfc:	10c00043 	ldbu	r3,1(r2)
 823ee00:	e0bffa17 	ldw	r2,-24(fp)
 823ee04:	10c00205 	stb	r3,8(r2)
 823ee08:	00000306 	br	823ee18 <ip_bldhead+0x12c>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 823ee0c:	e0bffa17 	ldw	r2,-24(fp)
 823ee10:	00c01004 	movi	r3,64
 823ee14:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823ee18:	e0bffb17 	ldw	r2,-20(fp)
 823ee1c:	10c00003 	ldbu	r3,0(r2)
 823ee20:	e0bffa17 	ldw	r2,-24(fp)
 823ee24:	10c00045 	stb	r3,1(r2)
 823ee28:	00000506 	br	823ee40 <ip_bldhead+0x154>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 823ee2c:	e0bffa17 	ldw	r2,-24(fp)
 823ee30:	00c01004 	movi	r3,64
 823ee34:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823ee38:	e0bffa17 	ldw	r2,-24(fp)
 823ee3c:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 823ee40:	e0bffa17 	ldw	r2,-24(fp)
 823ee44:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823ee48:	01400284 	movi	r5,10
 823ee4c:	e13ffa17 	ldw	r4,-24(fp)
 823ee50:	82283e80 	call	82283e8 <cksum>
 823ee54:	0084303a 	nor	r2,zero,r2
 823ee58:	1007883a 	mov	r3,r2
 823ee5c:	e0bffa17 	ldw	r2,-24(fp)
 823ee60:	10c0028d 	sth	r3,10(r2)
}
 823ee64:	0001883a 	nop
 823ee68:	e037883a 	mov	sp,fp
 823ee6c:	dfc00117 	ldw	ra,4(sp)
 823ee70:	df000017 	ldw	fp,0(sp)
 823ee74:	dec00204 	addi	sp,sp,8
 823ee78:	f800283a 	ret

0823ee7c <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 823ee7c:	defff004 	addi	sp,sp,-64
 823ee80:	dfc00f15 	stw	ra,60(sp)
 823ee84:	df000e15 	stw	fp,56(sp)
 823ee88:	df000e04 	addi	fp,sp,56
 823ee8c:	e13fff15 	stw	r4,-4(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 823ee90:	e0bfff17 	ldw	r2,-4(fp)
 823ee94:	10800717 	ldw	r2,28(r2)
 823ee98:	1006d63a 	srli	r3,r2,24
 823ee9c:	e0bfff17 	ldw	r2,-4(fp)
 823eea0:	10800717 	ldw	r2,28(r2)
 823eea4:	1004d23a 	srli	r2,r2,8
 823eea8:	10bfc00c 	andi	r2,r2,65280
 823eeac:	1886b03a 	or	r3,r3,r2
 823eeb0:	e0bfff17 	ldw	r2,-4(fp)
 823eeb4:	10800717 	ldw	r2,28(r2)
 823eeb8:	10bfc00c 	andi	r2,r2,65280
 823eebc:	1004923a 	slli	r2,r2,8
 823eec0:	1886b03a 	or	r3,r3,r2
 823eec4:	e0bfff17 	ldw	r2,-4(fp)
 823eec8:	10800717 	ldw	r2,28(r2)
 823eecc:	1004963a 	slli	r2,r2,24
 823eed0:	1884b03a 	or	r2,r3,r2
 823eed4:	10fc002c 	andhi	r3,r2,61440
 823eed8:	00b80034 	movhi	r2,57344
 823eedc:	1880a81e 	bne	r3,r2,823f180 <ip_write_internal+0x304>
   {
      if (p->imo != NULL)
 823eee0:	e0bfff17 	ldw	r2,-4(fp)
 823eee4:	10800b17 	ldw	r2,44(r2)
 823eee8:	10001426 	beq	r2,zero,823ef3c <ip_write_internal+0xc0>
         if (p->imo->imo_multicast_netp)
 823eeec:	e0bfff17 	ldw	r2,-4(fp)
 823eef0:	10800b17 	ldw	r2,44(r2)
 823eef4:	10800017 	ldw	r2,0(r2)
 823eef8:	10000626 	beq	r2,zero,823ef14 <ip_write_internal+0x98>
            p->net = p->imo->imo_multicast_netp;
 823eefc:	e0bfff17 	ldw	r2,-4(fp)
 823ef00:	10800b17 	ldw	r2,44(r2)
 823ef04:	10c00017 	ldw	r3,0(r2)
 823ef08:	e0bfff17 	ldw	r2,-4(fp)
 823ef0c:	10c00615 	stw	r3,24(r2)
 823ef10:	00002506 	br	823efa8 <ip_write_internal+0x12c>
         else
            p->net = iproute(p->fhost, &firsthop);
 823ef14:	e0bfff17 	ldw	r2,-4(fp)
 823ef18:	10800717 	ldw	r2,28(r2)
 823ef1c:	e0fffe04 	addi	r3,fp,-8
 823ef20:	180b883a 	mov	r5,r3
 823ef24:	1009883a 	mov	r4,r2
 823ef28:	824093c0 	call	824093c <iproute>
 823ef2c:	1007883a 	mov	r3,r2
 823ef30:	e0bfff17 	ldw	r2,-4(fp)
 823ef34:	10c00615 	stw	r3,24(r2)
 823ef38:	00001b06 	br	823efa8 <ip_write_internal+0x12c>
      else
      {
         for (i = 0; i < ifNumber; i++)
 823ef3c:	e03ff515 	stw	zero,-44(fp)
 823ef40:	00001606 	br	823ef9c <ip_write_internal+0x120>
            if (nets[i]->n_mcastlist)
 823ef44:	008209b4 	movhi	r2,2086
 823ef48:	10b6b204 	addi	r2,r2,-9528
 823ef4c:	e0fff517 	ldw	r3,-44(fp)
 823ef50:	18c7883a 	add	r3,r3,r3
 823ef54:	18c7883a 	add	r3,r3,r3
 823ef58:	10c5883a 	add	r2,r2,r3
 823ef5c:	10800017 	ldw	r2,0(r2)
 823ef60:	10802b17 	ldw	r2,172(r2)
 823ef64:	10000a26 	beq	r2,zero,823ef90 <ip_write_internal+0x114>
            {
               p->net = nets[i];
 823ef68:	008209b4 	movhi	r2,2086
 823ef6c:	10b6b204 	addi	r2,r2,-9528
 823ef70:	e0fff517 	ldw	r3,-44(fp)
 823ef74:	18c7883a 	add	r3,r3,r3
 823ef78:	18c7883a 	add	r3,r3,r3
 823ef7c:	10c5883a 	add	r2,r2,r3
 823ef80:	10c00017 	ldw	r3,0(r2)
 823ef84:	e0bfff17 	ldw	r2,-4(fp)
 823ef88:	10c00615 	stw	r3,24(r2)
               break;
 823ef8c:	00000606 	br	823efa8 <ip_write_internal+0x12c>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 823ef90:	e0bff517 	ldw	r2,-44(fp)
 823ef94:	10800044 	addi	r2,r2,1
 823ef98:	e0bff515 	stw	r2,-44(fp)
 823ef9c:	d0a08417 	ldw	r2,-32240(gp)
 823efa0:	e0fff517 	ldw	r3,-44(fp)
 823efa4:	18bfe736 	bltu	r3,r2,823ef44 <ip_write_internal+0xc8>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 823efa8:	e0bfff17 	ldw	r2,-4(fp)
 823efac:	10800617 	ldw	r2,24(r2)
 823efb0:	10000426 	beq	r2,zero,823efc4 <ip_write_internal+0x148>
 823efb4:	e0bfff17 	ldw	r2,-4(fp)
 823efb8:	10800617 	ldw	r2,24(r2)
 823efbc:	10802b17 	ldw	r2,172(r2)
 823efc0:	10002c1e 	bne	r2,zero,823f074 <ip_write_internal+0x1f8>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823efc4:	d0a08317 	ldw	r2,-32244(gp)
 823efc8:	1080840c 	andi	r2,r2,528
 823efcc:	10001a26 	beq	r2,zero,823f038 <ip_write_internal+0x1bc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823efd0:	e0bfff17 	ldw	r2,-4(fp)
 823efd4:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823efd8:	e0bfff17 	ldw	r2,-4(fp)
 823efdc:	10800717 	ldw	r2,28(r2)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823efe0:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823efe4:	e0bfff17 	ldw	r2,-4(fp)
 823efe8:	10800717 	ldw	r2,28(r2)
 823efec:	1004d23a 	srli	r2,r2,8
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823eff0:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823eff4:	e0ffff17 	ldw	r3,-4(fp)
 823eff8:	18c00717 	ldw	r3,28(r3)
 823effc:	1806d43a 	srli	r3,r3,16
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f000:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f004:	e13fff17 	ldw	r4,-4(fp)
 823f008:	21000717 	ldw	r4,28(r4)
 823f00c:	2008d63a 	srli	r4,r4,24
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f010:	d9000215 	stw	r4,8(sp)
 823f014:	d8c00115 	stw	r3,4(sp)
 823f018:	d8800015 	stw	r2,0(sp)
 823f01c:	300f883a 	mov	r7,r6
 823f020:	280d883a 	mov	r6,r5
 823f024:	e17fff17 	ldw	r5,-4(fp)
 823f028:	01020974 	movhi	r4,2085
 823f02c:	21030b04 	addi	r4,r4,3116
 823f030:	8202e9c0 	call	8202e9c <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f034:	822d1c80 	call	822d1c8 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 823f038:	008209b4 	movhi	r2,2086
 823f03c:	10b8f804 	addi	r2,r2,-7200
 823f040:	10800b17 	ldw	r2,44(r2)
 823f044:	10c00044 	addi	r3,r2,1
 823f048:	008209b4 	movhi	r2,2086
 823f04c:	10b8f804 	addi	r2,r2,-7200
 823f050:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f054:	01000084 	movi	r4,2
 823f058:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f05c:	e13fff17 	ldw	r4,-4(fp)
 823f060:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f064:	01000084 	movi	r4,2
 823f068:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f06c:	00bff7c4 	movi	r2,-33
 823f070:	00014606 	br	823f58c <ip_write_internal+0x710>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 823f074:	e0bfff17 	ldw	r2,-4(fp)
 823f078:	10c00717 	ldw	r3,28(r2)
 823f07c:	e0bfff17 	ldw	r2,-4(fp)
 823f080:	10800617 	ldw	r2,24(r2)
 823f084:	100b883a 	mov	r5,r2
 823f088:	1809883a 	mov	r4,r3
 823f08c:	82437fc0 	call	82437fc <lookup_mcast>
 823f090:	e0bff715 	stw	r2,-36(fp)
      if ((inm != NULL) &&
 823f094:	e0bff717 	ldw	r2,-36(fp)
 823f098:	10001b26 	beq	r2,zero,823f108 <ip_write_internal+0x28c>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f09c:	e0bfff17 	ldw	r2,-4(fp)
 823f0a0:	10800b17 	ldw	r2,44(r2)
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
      if ((inm != NULL) &&
 823f0a4:	10000526 	beq	r2,zero,823f0bc <ip_write_internal+0x240>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f0a8:	e0bfff17 	ldw	r2,-4(fp)
 823f0ac:	10800b17 	ldw	r2,44(r2)
 823f0b0:	10800143 	ldbu	r2,5(r2)
 823f0b4:	10803fcc 	andi	r2,r2,255
 823f0b8:	10001326 	beq	r2,zero,823f108 <ip_write_internal+0x28c>
      {
         p->type = IPTP;
 823f0bc:	e0bfff17 	ldw	r2,-4(fp)
 823f0c0:	00c00204 	movi	r3,8
 823f0c4:	10c0080d 	sth	r3,32(r2)
         pkt2 = ip_copypkt(p);
 823f0c8:	e13fff17 	ldw	r4,-4(fp)
 823f0cc:	8240b140 	call	8240b14 <ip_copypkt>
 823f0d0:	e0bff815 	stw	r2,-32(fp)
         if (pkt2)
 823f0d4:	e0bff817 	ldw	r2,-32(fp)
 823f0d8:	10000b26 	beq	r2,zero,823f108 <ip_write_internal+0x28c>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 823f0dc:	01000044 	movi	r4,1
 823f0e0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 823f0e4:	e17ff817 	ldw	r5,-32(fp)
 823f0e8:	010209b4 	movhi	r4,2086
 823f0ec:	2135ed04 	addi	r4,r4,-10316
 823f0f0:	822cbb00 	call	822cbb0 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f0f4:	01000044 	movi	r4,1
 823f0f8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 823f0fc:	d0a0ab17 	ldw	r2,-32084(gp)
 823f100:	1009883a 	mov	r4,r2
 823f104:	821a0800 	call	821a080 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 823f108:	e0bfff17 	ldw	r2,-4(fp)
 823f10c:	10800317 	ldw	r2,12(r2)
 823f110:	e0bff915 	stw	r2,-28(fp)
      if ((pip->ip_time == 0) || 
 823f114:	e0bff917 	ldw	r2,-28(fp)
 823f118:	10800203 	ldbu	r2,8(r2)
 823f11c:	10803fcc 	andi	r2,r2,255
 823f120:	10000b26 	beq	r2,zero,823f150 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f124:	e0bfff17 	ldw	r2,-4(fp)
 823f128:	10800717 	ldw	r2,28(r2)
 823f12c:	10803fcc 	andi	r2,r2,255
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
 823f130:	10801fe0 	cmpeqi	r2,r2,127
 823f134:	1000061e 	bne	r2,zero,823f150 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
 823f138:	e0bfff17 	ldw	r2,-4(fp)
 823f13c:	10c00717 	ldw	r3,28(r2)
 823f140:	e0bfff17 	ldw	r2,-4(fp)
 823f144:	10800617 	ldw	r2,24(r2)
 823f148:	10800a17 	ldw	r2,40(r2)
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f14c:	1880081e 	bne	r3,r2,823f170 <ip_write_internal+0x2f4>
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f150:	01000084 	movi	r4,2
 823f154:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f158:	e13fff17 	ldw	r4,-4(fp)
 823f15c:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f160:	01000084 	movi	r4,2
 823f164:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 823f168:	0005883a 	mov	r2,zero
 823f16c:	00010706 	br	823f58c <ip_write_internal+0x710>
      }

      firsthop = p->fhost;
 823f170:	e0bfff17 	ldw	r2,-4(fp)
 823f174:	10800717 	ldw	r2,28(r2)
 823f178:	e0bffe15 	stw	r2,-8(fp)

      goto sendit;
 823f17c:	00004006 	br	823f280 <ip_write_internal+0x404>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 823f180:	e0bfff17 	ldw	r2,-4(fp)
 823f184:	10800717 	ldw	r2,28(r2)
 823f188:	10bfffd8 	cmpnei	r2,r2,-1
 823f18c:	1000041e 	bne	r2,zero,823f1a0 <ip_write_internal+0x324>
   {
      firsthop = p->fhost;
 823f190:	e0bfff17 	ldw	r2,-4(fp)
 823f194:	10800717 	ldw	r2,28(r2)
 823f198:	e0bffe15 	stw	r2,-8(fp)
 823f19c:	00003806 	br	823f280 <ip_write_internal+0x404>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 823f1a0:	e0bfff17 	ldw	r2,-4(fp)
 823f1a4:	10800717 	ldw	r2,28(r2)
 823f1a8:	e0fffe04 	addi	r3,fp,-8
 823f1ac:	180b883a 	mov	r5,r3
 823f1b0:	1009883a 	mov	r4,r2
 823f1b4:	824093c0 	call	824093c <iproute>
 823f1b8:	1007883a 	mov	r3,r2
 823f1bc:	e0bfff17 	ldw	r2,-4(fp)
 823f1c0:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 823f1c4:	e0bfff17 	ldw	r2,-4(fp)
 823f1c8:	10800617 	ldw	r2,24(r2)
 823f1cc:	10002c1e 	bne	r2,zero,823f280 <ip_write_internal+0x404>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f1d0:	d0a08317 	ldw	r2,-32244(gp)
 823f1d4:	1080840c 	andi	r2,r2,528
 823f1d8:	10001a26 	beq	r2,zero,823f244 <ip_write_internal+0x3c8>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f1dc:	e0bfff17 	ldw	r2,-4(fp)
 823f1e0:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f1e4:	e0bfff17 	ldw	r2,-4(fp)
 823f1e8:	10800717 	ldw	r2,28(r2)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f1ec:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f1f0:	e0bfff17 	ldw	r2,-4(fp)
 823f1f4:	10800717 	ldw	r2,28(r2)
 823f1f8:	1004d23a 	srli	r2,r2,8
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f1fc:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f200:	e0ffff17 	ldw	r3,-4(fp)
 823f204:	18c00717 	ldw	r3,28(r3)
 823f208:	1806d43a 	srli	r3,r3,16
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f20c:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f210:	e13fff17 	ldw	r4,-4(fp)
 823f214:	21000717 	ldw	r4,28(r4)
 823f218:	2008d63a 	srli	r4,r4,24
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f21c:	d9000215 	stw	r4,8(sp)
 823f220:	d8c00115 	stw	r3,4(sp)
 823f224:	d8800015 	stw	r2,0(sp)
 823f228:	300f883a 	mov	r7,r6
 823f22c:	280d883a 	mov	r6,r5
 823f230:	e17fff17 	ldw	r5,-4(fp)
 823f234:	01020974 	movhi	r4,2085
 823f238:	21030b04 	addi	r4,r4,3116
 823f23c:	8202e9c0 	call	8202e9c <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f240:	822d1c80 	call	822d1c8 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 823f244:	008209b4 	movhi	r2,2086
 823f248:	10b8f804 	addi	r2,r2,-7200
 823f24c:	10800b17 	ldw	r2,44(r2)
 823f250:	10c00044 	addi	r3,r2,1
 823f254:	008209b4 	movhi	r2,2086
 823f258:	10b8f804 	addi	r2,r2,-7200
 823f25c:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f260:	01000084 	movi	r4,2
 823f264:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f268:	e13fff17 	ldw	r4,-4(fp)
 823f26c:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f270:	01000084 	movi	r4,2
 823f274:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f278:	00bff7c4 	movi	r2,-33
 823f27c:	0000c306 	br	823f58c <ip_write_internal+0x710>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 823f280:	d0a08317 	ldw	r2,-32244(gp)
 823f284:	1080800c 	andi	r2,r2,512
 823f288:	10002926 	beq	r2,zero,823f330 <ip_write_internal+0x4b4>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f28c:	e0bfff17 	ldw	r2,-4(fp)
 823f290:	11000417 	ldw	r4,16(r2)
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f294:	e0bfff17 	ldw	r2,-4(fp)
 823f298:	10800717 	ldw	r2,28(r2)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f29c:	11403fcc 	andi	r5,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f2a0:	e0bfff17 	ldw	r2,-4(fp)
 823f2a4:	10800717 	ldw	r2,28(r2)
 823f2a8:	1004d23a 	srli	r2,r2,8
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f2ac:	11803fcc 	andi	r6,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f2b0:	e0bfff17 	ldw	r2,-4(fp)
 823f2b4:	10800717 	ldw	r2,28(r2)
 823f2b8:	1004d43a 	srli	r2,r2,16
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f2bc:	10803fcc 	andi	r2,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f2c0:	e0ffff17 	ldw	r3,-4(fp)
 823f2c4:	18c00717 	ldw	r3,28(r3)
 823f2c8:	1806d63a 	srli	r3,r3,24
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f2cc:	d8c00115 	stw	r3,4(sp)
 823f2d0:	d8800015 	stw	r2,0(sp)
 823f2d4:	300f883a 	mov	r7,r6
 823f2d8:	280d883a 	mov	r6,r5
 823f2dc:	200b883a 	mov	r5,r4
 823f2e0:	01020974 	movhi	r4,2085
 823f2e4:	21031b04 	addi	r4,r4,3180
 823f2e8:	8202e9c0 	call	8202e9c <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 823f2ec:	e0bffe17 	ldw	r2,-8(fp)
 823f2f0:	10c03fcc 	andi	r3,r2,255
 823f2f4:	e0bffe17 	ldw	r2,-8(fp)
 823f2f8:	1004d23a 	srli	r2,r2,8
 823f2fc:	11003fcc 	andi	r4,r2,255
 823f300:	e0bffe17 	ldw	r2,-8(fp)
 823f304:	1004d43a 	srli	r2,r2,16
 823f308:	11403fcc 	andi	r5,r2,255
 823f30c:	e0bffe17 	ldw	r2,-8(fp)
 823f310:	1004d63a 	srli	r2,r2,24
 823f314:	d8800015 	stw	r2,0(sp)
 823f318:	280f883a 	mov	r7,r5
 823f31c:	200d883a 	mov	r6,r4
 823f320:	180b883a 	mov	r5,r3
 823f324:	01020974 	movhi	r4,2085
 823f328:	21032404 	addi	r4,r4,3216
 823f32c:	8202e9c0 	call	8202e9c <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f330:	e0bfff17 	ldw	r2,-4(fp)
 823f334:	10800617 	ldw	r2,24(r2)
 823f338:	10c00a17 	ldw	r3,40(r2)
 823f33c:	e0bfff17 	ldw	r2,-4(fp)
 823f340:	10800717 	ldw	r2,28(r2)
 823f344:	1880271e 	bne	r3,r2,823f3e4 <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
 823f348:	e0bfff17 	ldw	r2,-4(fp)
 823f34c:	10800717 	ldw	r2,28(r2)
 823f350:	10803fcc 	andi	r2,r2,255
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f354:	10801fe0 	cmpeqi	r2,r2,127
 823f358:	1000221e 	bne	r2,zero,823f3e4 <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 823f35c:	e0bfff17 	ldw	r2,-4(fp)
 823f360:	10800617 	ldw	r2,24(r2)
 823f364:	10802a17 	ldw	r2,168(r2)
 823f368:	1080020c 	andi	r2,r2,8
 823f36c:	1000091e 	bne	r2,zero,823f394 <ip_write_internal+0x518>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 823f370:	822d1c80 	call	822d1c8 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f374:	01000084 	movi	r4,2
 823f378:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f37c:	e13fff17 	ldw	r4,-4(fp)
 823f380:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f384:	01000084 	movi	r4,2
 823f388:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 823f38c:	00bffd44 	movi	r2,-11
 823f390:	00007e06 	br	823f58c <ip_write_internal+0x710>
      }
      p->type = IPTP;
 823f394:	e0bfff17 	ldw	r2,-4(fp)
 823f398:	00c00204 	movi	r3,8
 823f39c:	10c0080d 	sth	r3,32(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 823f3a0:	0009883a 	mov	r4,zero
 823f3a4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 823f3a8:	01000044 	movi	r4,1
 823f3ac:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 823f3b0:	e17fff17 	ldw	r5,-4(fp)
 823f3b4:	010209b4 	movhi	r4,2086
 823f3b8:	2135ed04 	addi	r4,r4,-10316
 823f3bc:	822cbb00 	call	822cbb0 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f3c0:	01000044 	movi	r4,1
 823f3c4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 823f3c8:	0009883a 	mov	r4,zero
 823f3cc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 823f3d0:	d0a0ab17 	ldw	r2,-32084(gp)
 823f3d4:	1009883a 	mov	r4,r2
 823f3d8:	821a0800 	call	821a080 <OSSemPost>

      return SUCCESS;
 823f3dc:	0005883a 	mov	r2,zero
 823f3e0:	00006a06 	br	823f58c <ip_write_internal+0x710>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 823f3e4:	e0bfff17 	ldw	r2,-4(fp)
 823f3e8:	10800a17 	ldw	r2,40(r2)
 823f3ec:	1080040c 	andi	r2,r2,16
 823f3f0:	1005003a 	cmpeq	r2,r2,zero
 823f3f4:	e0bffa05 	stb	r2,-24(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 823f3f8:	822ca1c0 	call	822ca1c <pk_get_max_intrsafe_buf_len>
 823f3fc:	e0bffb15 	stw	r2,-20(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 823f400:	e0bffa03 	ldbu	r2,-24(fp)
 823f404:	1000081e 	bne	r2,zero,823f428 <ip_write_internal+0x5ac>
       limit = MIN(maxbuflen,p->net->n_mtu);
 823f408:	e0bfff17 	ldw	r2,-4(fp)
 823f40c:	10800617 	ldw	r2,24(r2)
 823f410:	10800917 	ldw	r2,36(r2)
 823f414:	e0fffb17 	ldw	r3,-20(fp)
 823f418:	1880012e 	bgeu	r3,r2,823f420 <ip_write_internal+0x5a4>
 823f41c:	1805883a 	mov	r2,r3
 823f420:	e0bff615 	stw	r2,-40(fp)
 823f424:	00000406 	br	823f438 <ip_write_internal+0x5bc>
   else
       limit = p->net->n_mtu;
 823f428:	e0bfff17 	ldw	r2,-4(fp)
 823f42c:	10800617 	ldw	r2,24(r2)
 823f430:	10800917 	ldw	r2,36(r2)
 823f434:	e0bff615 	stw	r2,-40(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 823f438:	e0bfff17 	ldw	r2,-4(fp)
 823f43c:	10800417 	ldw	r2,16(r2)
 823f440:	e0ffff17 	ldw	r3,-4(fp)
 823f444:	18c00617 	ldw	r3,24(r3)
 823f448:	18c00817 	ldw	r3,32(r3)
 823f44c:	10c5883a 	add	r2,r2,r3
 823f450:	e0fff617 	ldw	r3,-40(fp)
 823f454:	1880072e 	bgeu	r3,r2,823f474 <ip_write_internal+0x5f8>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 823f458:	e0bffe17 	ldw	r2,-8(fp)
 823f45c:	100b883a 	mov	r5,r2
 823f460:	e13fff17 	ldw	r4,-4(fp)
 823f464:	824002c0 	call	824002c <ip_fragment>
 823f468:	e0bffc15 	stw	r2,-16(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 823f46c:	e0bffc17 	ldw	r2,-16(fp)
 823f470:	00004606 	br	823f58c <ip_write_internal+0x710>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 823f474:	e0bffa03 	ldbu	r2,-24(fp)
 823f478:	1000401e 	bne	r2,zero,823f57c <ip_write_internal+0x700>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f47c:	01000084 	movi	r4,2
 823f480:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 823f484:	e0bfff17 	ldw	r2,-4(fp)
 823f488:	10800417 	ldw	r2,16(r2)
 823f48c:	e0ffff17 	ldw	r3,-4(fp)
 823f490:	18c00617 	ldw	r3,24(r3)
 823f494:	18c00817 	ldw	r3,32(r3)
 823f498:	10c5883a 	add	r2,r2,r3
 823f49c:	1009883a 	mov	r4,r2
 823f4a0:	822c6200 	call	822c620 <pk_alloc>
 823f4a4:	e0bffd15 	stw	r2,-12(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f4a8:	01000084 	movi	r4,2
 823f4ac:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 823f4b0:	e0bffd17 	ldw	r2,-12(fp)
 823f4b4:	1000081e 	bne	r2,zero,823f4d8 <ip_write_internal+0x65c>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f4b8:	01000084 	movi	r4,2
 823f4bc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(p);
 823f4c0:	e13fff17 	ldw	r4,-4(fp)
 823f4c4:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f4c8:	01000084 	movi	r4,2
 823f4cc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 823f4d0:	00bffac4 	movi	r2,-21
 823f4d4:	00002d06 	br	823f58c <ip_write_internal+0x710>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 823f4d8:	e0bffd17 	ldw	r2,-12(fp)
 823f4dc:	10800117 	ldw	r2,4(r2)
 823f4e0:	e0ffff17 	ldw	r3,-4(fp)
 823f4e4:	18c00617 	ldw	r3,24(r3)
 823f4e8:	18c00817 	ldw	r3,32(r3)
 823f4ec:	10c7883a 	add	r3,r2,r3
 823f4f0:	e0bffd17 	ldw	r2,-12(fp)
 823f4f4:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 823f4f8:	e0bffd17 	ldw	r2,-12(fp)
 823f4fc:	10c00317 	ldw	r3,12(r2)
 823f500:	e0bfff17 	ldw	r2,-4(fp)
 823f504:	11000317 	ldw	r4,12(r2)
 823f508:	e0bfff17 	ldw	r2,-4(fp)
 823f50c:	10800417 	ldw	r2,16(r2)
 823f510:	100d883a 	mov	r6,r2
 823f514:	200b883a 	mov	r5,r4
 823f518:	1809883a 	mov	r4,r3
 823f51c:	8202a0c0 	call	8202a0c <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 823f520:	e0bfff17 	ldw	r2,-4(fp)
 823f524:	10c00417 	ldw	r3,16(r2)
 823f528:	e0bffd17 	ldw	r2,-12(fp)
 823f52c:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 823f530:	e0bfff17 	ldw	r2,-4(fp)
 823f534:	10c00617 	ldw	r3,24(r2)
 823f538:	e0bffd17 	ldw	r2,-12(fp)
 823f53c:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 823f540:	e0bfff17 	ldw	r2,-4(fp)
 823f544:	10c00717 	ldw	r3,28(r2)
 823f548:	e0bffd17 	ldw	r2,-12(fp)
 823f54c:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f550:	01000084 	movi	r4,2
 823f554:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(p);
 823f558:	e13fff17 	ldw	r4,-4(fp)
 823f55c:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f560:	01000084 	movi	r4,2
 823f564:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 823f568:	e0bffe17 	ldw	r2,-8(fp)
 823f56c:	100b883a 	mov	r5,r2
 823f570:	e13ffd17 	ldw	r4,-12(fp)
 823f574:	822632c0 	call	822632c <ip2mac>
 823f578:	00000406 	br	823f58c <ip_write_internal+0x710>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 823f57c:	e0bffe17 	ldw	r2,-8(fp)
 823f580:	100b883a 	mov	r5,r2
 823f584:	e13fff17 	ldw	r4,-4(fp)
 823f588:	822632c0 	call	822632c <ip2mac>
      }
   }
}
 823f58c:	e037883a 	mov	sp,fp
 823f590:	dfc00117 	ldw	ra,4(sp)
 823f594:	df000017 	ldw	fp,0(sp)
 823f598:	dec00204 	addi	sp,sp,8
 823f59c:	f800283a 	ret

0823f5a0 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 823f5a0:	defff904 	addi	sp,sp,-28
 823f5a4:	dfc00615 	stw	ra,24(sp)
 823f5a8:	df000515 	stw	fp,20(sp)
 823f5ac:	df000504 	addi	fp,sp,20
 823f5b0:	2005883a 	mov	r2,r4
 823f5b4:	e17fff15 	stw	r5,-4(fp)
 823f5b8:	e0bffe05 	stb	r2,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f5bc:	008209b4 	movhi	r2,2086
 823f5c0:	10b8f804 	addi	r2,r2,-7200
 823f5c4:	10800917 	ldw	r2,36(r2)
 823f5c8:	10c00044 	addi	r3,r2,1
 823f5cc:	008209b4 	movhi	r2,2086
 823f5d0:	10b8f804 	addi	r2,r2,-7200
 823f5d4:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 823f5d8:	e0bfff17 	ldw	r2,-4(fp)
 823f5dc:	10800317 	ldw	r2,12(r2)
 823f5e0:	10fffb04 	addi	r3,r2,-20
 823f5e4:	e0bfff17 	ldw	r2,-4(fp)
 823f5e8:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f5ec:	e0bfff17 	ldw	r2,-4(fp)
 823f5f0:	10800417 	ldw	r2,16(r2)
 823f5f4:	10c00504 	addi	r3,r2,20
 823f5f8:	e0bfff17 	ldw	r2,-4(fp)
 823f5fc:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 823f600:	e0bfff17 	ldw	r2,-4(fp)
 823f604:	10800317 	ldw	r2,12(r2)
 823f608:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823f60c:	e0bffc17 	ldw	r2,-16(fp)
 823f610:	00c01144 	movi	r3,69
 823f614:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 823f618:	e0bffc17 	ldw	r2,-16(fp)
 823f61c:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823f620:	d0a05017 	ldw	r2,-32448(gp)
 823f624:	10bfffcc 	andi	r2,r2,65535
 823f628:	1005d23a 	srai	r2,r2,8
 823f62c:	10803fcc 	andi	r2,r2,255
 823f630:	1007883a 	mov	r3,r2
 823f634:	d0a05017 	ldw	r2,-32448(gp)
 823f638:	10bfffcc 	andi	r2,r2,65535
 823f63c:	1004923a 	slli	r2,r2,8
 823f640:	1884b03a 	or	r2,r3,r2
 823f644:	1007883a 	mov	r3,r2
 823f648:	e0bffc17 	ldw	r2,-16(fp)
 823f64c:	10c0010d 	sth	r3,4(r2)
   uid++;
 823f650:	d0a05017 	ldw	r2,-32448(gp)
 823f654:	10800044 	addi	r2,r2,1
 823f658:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823f65c:	e0bfff17 	ldw	r2,-4(fp)
 823f660:	10800417 	ldw	r2,16(r2)
 823f664:	10bfffcc 	andi	r2,r2,65535
 823f668:	1005d23a 	srai	r2,r2,8
 823f66c:	10803fcc 	andi	r2,r2,255
 823f670:	1007883a 	mov	r3,r2
 823f674:	e0bfff17 	ldw	r2,-4(fp)
 823f678:	10800417 	ldw	r2,16(r2)
 823f67c:	10bfffcc 	andi	r2,r2,65535
 823f680:	1004923a 	slli	r2,r2,8
 823f684:	1884b03a 	or	r2,r3,r2
 823f688:	1007883a 	mov	r3,r2
 823f68c:	e0bffc17 	ldw	r2,-16(fp)
 823f690:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823f694:	e0bffc17 	ldw	r2,-16(fp)
 823f698:	e0fffe03 	ldbu	r3,-8(fp)
 823f69c:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823f6a0:	e0bffc17 	ldw	r2,-16(fp)
 823f6a4:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823f6a8:	00801004 	movi	r2,64
 823f6ac:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823f6b0:	e0bfff17 	ldw	r2,-4(fp)
 823f6b4:	10800717 	ldw	r2,28(r2)
 823f6b8:	1006d63a 	srli	r3,r2,24
 823f6bc:	e0bfff17 	ldw	r2,-4(fp)
 823f6c0:	10800717 	ldw	r2,28(r2)
 823f6c4:	1004d23a 	srli	r2,r2,8
 823f6c8:	10bfc00c 	andi	r2,r2,65280
 823f6cc:	1886b03a 	or	r3,r3,r2
 823f6d0:	e0bfff17 	ldw	r2,-4(fp)
 823f6d4:	10800717 	ldw	r2,28(r2)
 823f6d8:	10bfc00c 	andi	r2,r2,65280
 823f6dc:	1004923a 	slli	r2,r2,8
 823f6e0:	1886b03a 	or	r3,r3,r2
 823f6e4:	e0bfff17 	ldw	r2,-4(fp)
 823f6e8:	10800717 	ldw	r2,28(r2)
 823f6ec:	1004963a 	slli	r2,r2,24
 823f6f0:	1884b03a 	or	r2,r3,r2
 823f6f4:	10fc002c 	andhi	r3,r2,61440
 823f6f8:	00b80034 	movhi	r2,57344
 823f6fc:	1880071e 	bne	r3,r2,823f71c <ip_write+0x17c>
 823f700:	e0bfff17 	ldw	r2,-4(fp)
 823f704:	10800b17 	ldw	r2,44(r2)
 823f708:	10000426 	beq	r2,zero,823f71c <ip_write+0x17c>
      ttl = p->imo->imo_multicast_ttl;
 823f70c:	e0bfff17 	ldw	r2,-4(fp)
 823f710:	10800b17 	ldw	r2,44(r2)
 823f714:	10800103 	ldbu	r2,4(r2)
 823f718:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823f71c:	e0bfff17 	ldw	r2,-4(fp)
 823f720:	10800c17 	ldw	r2,48(r2)
 823f724:	e0bffd15 	stw	r2,-12(fp)
 823f728:	e0bffd17 	ldw	r2,-12(fp)
 823f72c:	10001126 	beq	r2,zero,823f774 <ip_write+0x1d4>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823f730:	e0bffd17 	ldw	r2,-12(fp)
 823f734:	10800043 	ldbu	r2,1(r2)
 823f738:	10803fcc 	andi	r2,r2,255
 823f73c:	10000526 	beq	r2,zero,823f754 <ip_write+0x1b4>
         pip->ip_time = sopts->ip_ttl;
 823f740:	e0bffd17 	ldw	r2,-12(fp)
 823f744:	10c00043 	ldbu	r3,1(r2)
 823f748:	e0bffc17 	ldw	r2,-16(fp)
 823f74c:	10c00205 	stb	r3,8(r2)
 823f750:	00000306 	br	823f760 <ip_write+0x1c0>
	  else
         pip->ip_time = ttl;
 823f754:	e0bffc17 	ldw	r2,-16(fp)
 823f758:	e0fffb03 	ldbu	r3,-20(fp)
 823f75c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823f760:	e0bffd17 	ldw	r2,-12(fp)
 823f764:	10c00003 	ldbu	r3,0(r2)
 823f768:	e0bffc17 	ldw	r2,-16(fp)
 823f76c:	10c00045 	stb	r3,1(r2)
 823f770:	00000506 	br	823f788 <ip_write+0x1e8>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 823f774:	e0bffc17 	ldw	r2,-16(fp)
 823f778:	e0fffb03 	ldbu	r3,-20(fp)
 823f77c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823f780:	e0bffc17 	ldw	r2,-16(fp)
 823f784:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 823f788:	01400284 	movi	r5,10
 823f78c:	e13ffc17 	ldw	r4,-16(fp)
 823f790:	82283e80 	call	82283e8 <cksum>
 823f794:	0084303a 	nor	r2,zero,r2
 823f798:	1007883a 	mov	r3,r2
 823f79c:	e0bffc17 	ldw	r2,-16(fp)
 823f7a0:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823f7a4:	e13fff17 	ldw	r4,-4(fp)
 823f7a8:	823ee7c0 	call	823ee7c <ip_write_internal>
}
 823f7ac:	e037883a 	mov	sp,fp
 823f7b0:	dfc00117 	ldw	ra,4(sp)
 823f7b4:	df000017 	ldw	fp,0(sp)
 823f7b8:	dec00204 	addi	sp,sp,8
 823f7bc:	f800283a 	ret

0823f7c0 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 823f7c0:	defff604 	addi	sp,sp,-40
 823f7c4:	dfc00915 	stw	ra,36(sp)
 823f7c8:	df000815 	stw	fp,32(sp)
 823f7cc:	df000804 	addi	fp,sp,32
 823f7d0:	2005883a 	mov	r2,r4
 823f7d4:	e17ffe15 	stw	r5,-8(fp)
 823f7d8:	e1bfff15 	stw	r6,-4(fp)
 823f7dc:	e0bffd05 	stb	r2,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 823f7e0:	00800504 	movi	r2,20
 823f7e4:	e0bff845 	stb	r2,-31(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f7e8:	008209b4 	movhi	r2,2086
 823f7ec:	10b8f804 	addi	r2,r2,-7200
 823f7f0:	10800917 	ldw	r2,36(r2)
 823f7f4:	10c00044 	addi	r3,r2,1
 823f7f8:	008209b4 	movhi	r2,2086
 823f7fc:	10b8f804 	addi	r2,r2,-7200
 823f800:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823f804:	e0bfff17 	ldw	r2,-4(fp)
 823f808:	e0bff915 	stw	r2,-28(fp)
 823f80c:	00000d06 	br	823f844 <ip_write2+0x84>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 823f810:	e0bff917 	ldw	r2,-28(fp)
 823f814:	10800003 	ldbu	r2,0(r2)
 823f818:	10803fcc 	andi	r2,r2,255
 823f81c:	10800520 	cmpeqi	r2,r2,20
 823f820:	1000011e 	bne	r2,zero,823f828 <ip_write2+0x68>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823f824:	00000406 	br	823f838 <ip_write2+0x78>
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 823f828:	e0bff843 	ldbu	r2,-31(fp)
 823f82c:	10800104 	addi	r2,r2,4
 823f830:	e0bff845 	stb	r2,-31(fp)
            break;
 823f834:	0001883a 	nop
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823f838:	e0bff917 	ldw	r2,-28(fp)
 823f83c:	10800044 	addi	r2,r2,1
 823f840:	e0bff915 	stw	r2,-28(fp)
 823f844:	e0bff917 	ldw	r2,-28(fp)
 823f848:	10800003 	ldbu	r2,0(r2)
 823f84c:	10803fcc 	andi	r2,r2,255
 823f850:	103fef1e 	bne	r2,zero,823f810 <ip_write2+0x50>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 823f854:	e0bff843 	ldbu	r2,-31(fp)
 823f858:	108000cc 	andi	r2,r2,3
 823f85c:	10000726 	beq	r2,zero,823f87c <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 823f860:	e0bff843 	ldbu	r2,-31(fp)
 823f864:	108000cc 	andi	r2,r2,3
 823f868:	1007883a 	mov	r3,r2
 823f86c:	00800104 	movi	r2,4
 823f870:	10c5c83a 	sub	r2,r2,r3
 823f874:	e0bffa05 	stb	r2,-24(fp)
 823f878:	00000106 	br	823f880 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 823f87c:	e03ffa05 	stb	zero,-24(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 823f880:	e0bffe17 	ldw	r2,-8(fp)
 823f884:	10c00317 	ldw	r3,12(r2)
 823f888:	e13ff843 	ldbu	r4,-31(fp)
 823f88c:	e0bffa03 	ldbu	r2,-24(fp)
 823f890:	2085883a 	add	r2,r4,r2
 823f894:	0085c83a 	sub	r2,zero,r2
 823f898:	1887883a 	add	r3,r3,r2
 823f89c:	e0bffe17 	ldw	r2,-8(fp)
 823f8a0:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 823f8a4:	e0bffe17 	ldw	r2,-8(fp)
 823f8a8:	10800417 	ldw	r2,16(r2)
 823f8ac:	e13ff843 	ldbu	r4,-31(fp)
 823f8b0:	e0fffa03 	ldbu	r3,-24(fp)
 823f8b4:	20c7883a 	add	r3,r4,r3
 823f8b8:	10c7883a 	add	r3,r2,r3
 823f8bc:	e0bffe17 	ldw	r2,-8(fp)
 823f8c0:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 823f8c4:	e0bffe17 	ldw	r2,-8(fp)
 823f8c8:	10800317 	ldw	r2,12(r2)
 823f8cc:	e0bffb15 	stw	r2,-20(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 823f8d0:	e0fff843 	ldbu	r3,-31(fp)
 823f8d4:	e0bffa03 	ldbu	r2,-24(fp)
 823f8d8:	1885883a 	add	r2,r3,r2
 823f8dc:	1005d0ba 	srai	r2,r2,2
 823f8e0:	10801014 	ori	r2,r2,64
 823f8e4:	1007883a 	mov	r3,r2
 823f8e8:	e0bffb17 	ldw	r2,-20(fp)
 823f8ec:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 823f8f0:	e0bffb17 	ldw	r2,-20(fp)
 823f8f4:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823f8f8:	d0a05017 	ldw	r2,-32448(gp)
 823f8fc:	10bfffcc 	andi	r2,r2,65535
 823f900:	1005d23a 	srai	r2,r2,8
 823f904:	10803fcc 	andi	r2,r2,255
 823f908:	1007883a 	mov	r3,r2
 823f90c:	d0a05017 	ldw	r2,-32448(gp)
 823f910:	10bfffcc 	andi	r2,r2,65535
 823f914:	1004923a 	slli	r2,r2,8
 823f918:	1884b03a 	or	r2,r3,r2
 823f91c:	1007883a 	mov	r3,r2
 823f920:	e0bffb17 	ldw	r2,-20(fp)
 823f924:	10c0010d 	sth	r3,4(r2)
   uid++;
 823f928:	d0a05017 	ldw	r2,-32448(gp)
 823f92c:	10800044 	addi	r2,r2,1
 823f930:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823f934:	e0bffe17 	ldw	r2,-8(fp)
 823f938:	10800417 	ldw	r2,16(r2)
 823f93c:	10bfffcc 	andi	r2,r2,65535
 823f940:	1005d23a 	srai	r2,r2,8
 823f944:	10803fcc 	andi	r2,r2,255
 823f948:	1007883a 	mov	r3,r2
 823f94c:	e0bffe17 	ldw	r2,-8(fp)
 823f950:	10800417 	ldw	r2,16(r2)
 823f954:	10bfffcc 	andi	r2,r2,65535
 823f958:	1004923a 	slli	r2,r2,8
 823f95c:	1884b03a 	or	r2,r3,r2
 823f960:	1007883a 	mov	r3,r2
 823f964:	e0bffb17 	ldw	r2,-20(fp)
 823f968:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823f96c:	e0bffb17 	ldw	r2,-20(fp)
 823f970:	e0fffd03 	ldbu	r3,-12(fp)
 823f974:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823f978:	e0bffb17 	ldw	r2,-20(fp)
 823f97c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823f980:	00801004 	movi	r2,64
 823f984:	e0bff805 	stb	r2,-32(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823f988:	e0bffe17 	ldw	r2,-8(fp)
 823f98c:	10800717 	ldw	r2,28(r2)
 823f990:	1006d63a 	srli	r3,r2,24
 823f994:	e0bffe17 	ldw	r2,-8(fp)
 823f998:	10800717 	ldw	r2,28(r2)
 823f99c:	1004d23a 	srli	r2,r2,8
 823f9a0:	10bfc00c 	andi	r2,r2,65280
 823f9a4:	1886b03a 	or	r3,r3,r2
 823f9a8:	e0bffe17 	ldw	r2,-8(fp)
 823f9ac:	10800717 	ldw	r2,28(r2)
 823f9b0:	10bfc00c 	andi	r2,r2,65280
 823f9b4:	1004923a 	slli	r2,r2,8
 823f9b8:	1886b03a 	or	r3,r3,r2
 823f9bc:	e0bffe17 	ldw	r2,-8(fp)
 823f9c0:	10800717 	ldw	r2,28(r2)
 823f9c4:	1004963a 	slli	r2,r2,24
 823f9c8:	1884b03a 	or	r2,r3,r2
 823f9cc:	10fc002c 	andhi	r3,r2,61440
 823f9d0:	00b80034 	movhi	r2,57344
 823f9d4:	1880071e 	bne	r3,r2,823f9f4 <ip_write2+0x234>
 823f9d8:	e0bffe17 	ldw	r2,-8(fp)
 823f9dc:	10800b17 	ldw	r2,44(r2)
 823f9e0:	10000426 	beq	r2,zero,823f9f4 <ip_write2+0x234>
      ttl = p->imo->imo_multicast_ttl;
 823f9e4:	e0bffe17 	ldw	r2,-8(fp)
 823f9e8:	10800b17 	ldw	r2,44(r2)
 823f9ec:	10800103 	ldbu	r2,4(r2)
 823f9f0:	e0bff805 	stb	r2,-32(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 823f9f4:	e0bffe17 	ldw	r2,-8(fp)
 823f9f8:	10800c17 	ldw	r2,48(r2)
 823f9fc:	e0bffc15 	stw	r2,-16(fp)
 823fa00:	e0bffc17 	ldw	r2,-16(fp)
 823fa04:	10001126 	beq	r2,zero,823fa4c <ip_write2+0x28c>
   {
      if (sopts->ip_ttl)
 823fa08:	e0bffc17 	ldw	r2,-16(fp)
 823fa0c:	10800043 	ldbu	r2,1(r2)
 823fa10:	10803fcc 	andi	r2,r2,255
 823fa14:	10000526 	beq	r2,zero,823fa2c <ip_write2+0x26c>
         pip->ip_time = sopts->ip_ttl;
 823fa18:	e0bffc17 	ldw	r2,-16(fp)
 823fa1c:	10c00043 	ldbu	r3,1(r2)
 823fa20:	e0bffb17 	ldw	r2,-20(fp)
 823fa24:	10c00205 	stb	r3,8(r2)
 823fa28:	00000306 	br	823fa38 <ip_write2+0x278>
      else
         pip->ip_time = ttl;
 823fa2c:	e0bffb17 	ldw	r2,-20(fp)
 823fa30:	e0fff803 	ldbu	r3,-32(fp)
 823fa34:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fa38:	e0bffc17 	ldw	r2,-16(fp)
 823fa3c:	10c00003 	ldbu	r3,0(r2)
 823fa40:	e0bffb17 	ldw	r2,-20(fp)
 823fa44:	10c00045 	stb	r3,1(r2)
 823fa48:	00000506 	br	823fa60 <ip_write2+0x2a0>
   }
   else
   {
      pip->ip_time = ttl;
 823fa4c:	e0bffb17 	ldw	r2,-20(fp)
 823fa50:	e0fff803 	ldbu	r3,-32(fp)
 823fa54:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fa58:	e0bffb17 	ldw	r2,-20(fp)
 823fa5c:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fa60:	e0bffe17 	ldw	r2,-8(fp)
 823fa64:	10800317 	ldw	r2,12(r2)
 823fa68:	10800504 	addi	r2,r2,20
 823fa6c:	e0bff915 	stw	r2,-28(fp)
 823fa70:	00001006 	br	823fab4 <ip_write2+0x2f4>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 823fa74:	e0bfff17 	ldw	r2,-4(fp)
 823fa78:	10800003 	ldbu	r2,0(r2)
 823fa7c:	10803fcc 	andi	r2,r2,255
 823fa80:	10800520 	cmpeqi	r2,r2,20
 823fa84:	1000011e 	bne	r2,zero,823fa8c <ip_write2+0x2cc>
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fa88:	00000706 	br	823faa8 <ip_write2+0x2e8>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 823fa8c:	e0bff917 	ldw	r2,-28(fp)
 823fa90:	00c12504 	movi	r3,1172
 823fa94:	10c00015 	stw	r3,0(r2)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 823fa98:	e0bff917 	ldw	r2,-28(fp)
 823fa9c:	10800104 	addi	r2,r2,4
 823faa0:	e0bff915 	stw	r2,-28(fp)
            break;
 823faa4:	0001883a 	nop
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823faa8:	e0bfff17 	ldw	r2,-4(fp)
 823faac:	10800044 	addi	r2,r2,1
 823fab0:	e0bfff15 	stw	r2,-4(fp)
 823fab4:	e0bfff17 	ldw	r2,-4(fp)
 823fab8:	10800003 	ldbu	r2,0(r2)
 823fabc:	10803fcc 	andi	r2,r2,255
 823fac0:	103fec1e 	bne	r2,zero,823fa74 <ip_write2+0x2b4>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 823fac4:	e03ffa45 	stb	zero,-23(fp)
 823fac8:	00000706 	br	823fae8 <ip_write2+0x328>
 823facc:	e0bffa43 	ldbu	r2,-23(fp)
 823fad0:	e0fff917 	ldw	r3,-28(fp)
 823fad4:	1885883a 	add	r2,r3,r2
 823fad8:	10000005 	stb	zero,0(r2)
 823fadc:	e0bffa43 	ldbu	r2,-23(fp)
 823fae0:	10800044 	addi	r2,r2,1
 823fae4:	e0bffa45 	stb	r2,-23(fp)
 823fae8:	e0fffa43 	ldbu	r3,-23(fp)
 823faec:	e0bffa03 	ldbu	r2,-24(fp)
 823faf0:	18bff636 	bltu	r3,r2,823facc <ip_write2+0x30c>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 823faf4:	e0fff843 	ldbu	r3,-31(fp)
 823faf8:	e0bffa03 	ldbu	r2,-24(fp)
 823fafc:	1885883a 	add	r2,r3,r2
 823fb00:	1006d7fa 	srli	r3,r2,31
 823fb04:	1885883a 	add	r2,r3,r2
 823fb08:	1005d07a 	srai	r2,r2,1
 823fb0c:	100b883a 	mov	r5,r2
 823fb10:	e13ffb17 	ldw	r4,-20(fp)
 823fb14:	82283e80 	call	82283e8 <cksum>
 823fb18:	0084303a 	nor	r2,zero,r2
 823fb1c:	1007883a 	mov	r3,r2
 823fb20:	e0bffb17 	ldw	r2,-20(fp)
 823fb24:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 823fb28:	e13ffe17 	ldw	r4,-8(fp)
 823fb2c:	823ee7c0 	call	823ee7c <ip_write_internal>
}
 823fb30:	e037883a 	mov	sp,fp
 823fb34:	dfc00117 	ldw	ra,4(sp)
 823fb38:	df000017 	ldw	fp,0(sp)
 823fb3c:	dec00204 	addi	sp,sp,8
 823fb40:	f800283a 	ret

0823fb44 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 823fb44:	defffc04 	addi	sp,sp,-16
 823fb48:	dfc00315 	stw	ra,12(sp)
 823fb4c:	df000215 	stw	fp,8(sp)
 823fb50:	df000204 	addi	fp,sp,8
 823fb54:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823fb58:	008209b4 	movhi	r2,2086
 823fb5c:	10b8f804 	addi	r2,r2,-7200
 823fb60:	10800917 	ldw	r2,36(r2)
 823fb64:	10c00044 	addi	r3,r2,1
 823fb68:	008209b4 	movhi	r2,2086
 823fb6c:	10b8f804 	addi	r2,r2,-7200
 823fb70:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 823fb74:	e0bfff17 	ldw	r2,-4(fp)
 823fb78:	10800317 	ldw	r2,12(r2)
 823fb7c:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 823fb80:	e0bffe17 	ldw	r2,-8(fp)
 823fb84:	1080010b 	ldhu	r2,4(r2)
 823fb88:	10bfffcc 	andi	r2,r2,65535
 823fb8c:	10000f1e 	bne	r2,zero,823fbcc <ip_raw_write+0x88>
   {
      pip->ip_id = htons((unshort)uid);
 823fb90:	d0a05017 	ldw	r2,-32448(gp)
 823fb94:	10bfffcc 	andi	r2,r2,65535
 823fb98:	1005d23a 	srai	r2,r2,8
 823fb9c:	10803fcc 	andi	r2,r2,255
 823fba0:	1007883a 	mov	r3,r2
 823fba4:	d0a05017 	ldw	r2,-32448(gp)
 823fba8:	10bfffcc 	andi	r2,r2,65535
 823fbac:	1004923a 	slli	r2,r2,8
 823fbb0:	1884b03a 	or	r2,r3,r2
 823fbb4:	1007883a 	mov	r3,r2
 823fbb8:	e0bffe17 	ldw	r2,-8(fp)
 823fbbc:	10c0010d 	sth	r3,4(r2)
      uid++;
 823fbc0:	d0a05017 	ldw	r2,-32448(gp)
 823fbc4:	10800044 	addi	r2,r2,1
 823fbc8:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fbcc:	e0bffe17 	ldw	r2,-8(fp)
 823fbd0:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823fbd4:	01400284 	movi	r5,10
 823fbd8:	e13ffe17 	ldw	r4,-8(fp)
 823fbdc:	82283e80 	call	82283e8 <cksum>
 823fbe0:	0084303a 	nor	r2,zero,r2
 823fbe4:	1007883a 	mov	r3,r2
 823fbe8:	e0bffe17 	ldw	r2,-8(fp)
 823fbec:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823fbf0:	e13fff17 	ldw	r4,-4(fp)
 823fbf4:	823ee7c0 	call	823ee7c <ip_write_internal>
}
 823fbf8:	e037883a 	mov	sp,fp
 823fbfc:	dfc00117 	ldw	ra,4(sp)
 823fc00:	df000017 	ldw	fp,0(sp)
 823fc04:	dec00204 	addi	sp,sp,8
 823fc08:	f800283a 	ret

0823fc0c <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 823fc0c:	defff104 	addi	sp,sp,-60
 823fc10:	dfc00e15 	stw	ra,56(sp)
 823fc14:	df000d15 	stw	fp,52(sp)
 823fc18:	df000d04 	addi	fp,sp,52
 823fc1c:	e13ffe15 	stw	r4,-8(fp)
 823fc20:	e17fff15 	stw	r5,-4(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 823fc24:	008209b4 	movhi	r2,2086
 823fc28:	10b8f804 	addi	r2,r2,-7200
 823fc2c:	10801017 	ldw	r2,64(r2)
 823fc30:	10c00044 	addi	r3,r2,1
 823fc34:	008209b4 	movhi	r2,2086
 823fc38:	10b8f804 	addi	r2,r2,-7200
 823fc3c:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 823fc40:	e0bffe17 	ldw	r2,-8(fp)
 823fc44:	10800317 	ldw	r2,12(r2)
 823fc48:	e0bff815 	stw	r2,-32(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 823fc4c:	e0bff817 	ldw	r2,-32(fp)
 823fc50:	10800003 	ldbu	r2,0(r2)
 823fc54:	10803fcc 	andi	r2,r2,255
 823fc58:	108003cc 	andi	r2,r2,15
 823fc5c:	1085883a 	add	r2,r2,r2
 823fc60:	1085883a 	add	r2,r2,r2
 823fc64:	e0bff915 	stw	r2,-28(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 823fc68:	e0bffe17 	ldw	r2,-8(fp)
 823fc6c:	10800417 	ldw	r2,16(r2)
 823fc70:	1007883a 	mov	r3,r2
 823fc74:	e0bff917 	ldw	r2,-28(fp)
 823fc78:	1885c83a 	sub	r2,r3,r2
 823fc7c:	e0bff515 	stw	r2,-44(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 823fc80:	e0bffe17 	ldw	r2,-8(fp)
 823fc84:	10800617 	ldw	r2,24(r2)
 823fc88:	10c00917 	ldw	r3,36(r2)
 823fc8c:	e0bffe17 	ldw	r2,-8(fp)
 823fc90:	10800617 	ldw	r2,24(r2)
 823fc94:	11000817 	ldw	r4,32(r2)
 823fc98:	e0bff917 	ldw	r2,-28(fp)
 823fc9c:	2085883a 	add	r2,r4,r2
 823fca0:	10800204 	addi	r2,r2,8
 823fca4:	1885c83a 	sub	r2,r3,r2
 823fca8:	e0bffa15 	stw	r2,-24(fp)
   if (maxipsize < 64)  /* to small to use */
 823fcac:	e0bffa17 	ldw	r2,-24(fp)
 823fcb0:	10801028 	cmpgeui	r2,r2,64
 823fcb4:	1000031e 	bne	r2,zero,823fcc4 <ip_fragment_lc+0xb8>
   {
      dtrap();    /* probably bad programming */
 823fcb8:	822d1c80 	call	822d1c8 <dtrap>
      return ENP_LOGIC;
 823fcbc:	00bffd44 	movi	r2,-11
 823fcc0:	0000d506 	br	8240018 <ip_fragment_lc+0x40c>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 823fcc4:	e0bffe17 	ldw	r2,-8(fp)
 823fcc8:	10800417 	ldw	r2,16(r2)
 823fccc:	e17ffa17 	ldw	r5,-24(fp)
 823fcd0:	1009883a 	mov	r4,r2
 823fcd4:	820270c0 	call	820270c <__udivsi3>
 823fcd8:	10800044 	addi	r2,r2,1
 823fcdc:	e0bffb15 	stw	r2,-20(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 823fce0:	e0bffe17 	ldw	r2,-8(fp)
 823fce4:	10c00417 	ldw	r3,16(r2)
 823fce8:	e0bffb17 	ldw	r2,-20(fp)
 823fcec:	1885883a 	add	r2,r3,r2
 823fcf0:	10bfffc4 	addi	r2,r2,-1
 823fcf4:	e17ffb17 	ldw	r5,-20(fp)
 823fcf8:	1009883a 	mov	r4,r2
 823fcfc:	820270c0 	call	820270c <__udivsi3>
 823fd00:	10c001c4 	addi	r3,r2,7
 823fd04:	00bffe04 	movi	r2,-8
 823fd08:	1884703a 	and	r2,r3,r2
 823fd0c:	e0bffc15 	stw	r2,-16(fp)
   foffset = 0;
 823fd10:	e03ff315 	stw	zero,-52(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 823fd14:	e0bff817 	ldw	r2,-32(fp)
 823fd18:	1080018b 	ldhu	r2,6(r2)
 823fd1c:	10bfffcc 	andi	r2,r2,65535
 823fd20:	1004d23a 	srli	r2,r2,8
 823fd24:	1007883a 	mov	r3,r2
 823fd28:	e0bff817 	ldw	r2,-32(fp)
 823fd2c:	1080018b 	ldhu	r2,6(r2)
 823fd30:	10bfffcc 	andi	r2,r2,65535
 823fd34:	1004923a 	slli	r2,r2,8
 823fd38:	1884b03a 	or	r2,r3,r2
 823fd3c:	e0bffd0d 	sth	r2,-12(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 823fd40:	e0fffd0b 	ldhu	r3,-12(fp)
 823fd44:	00bffff4 	movhi	r2,65535
 823fd48:	1087ffc4 	addi	r2,r2,8191
 823fd4c:	1884703a 	and	r2,r3,r2
 823fd50:	10000826 	beq	r2,zero,823fd74 <ip_fragment_lc+0x168>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 823fd54:	e0fffd0b 	ldhu	r3,-12(fp)
 823fd58:	00bffff4 	movhi	r2,65535
 823fd5c:	1087ffc4 	addi	r2,r2,8191
 823fd60:	1884703a 	and	r2,r3,r2
 823fd64:	e0bff315 	stw	r2,-52(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 823fd68:	e0bff317 	ldw	r2,-52(fp)
 823fd6c:	100490fa 	slli	r2,r2,3
 823fd70:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 823fd74:	e0bffe17 	ldw	r2,-8(fp)
 823fd78:	e0bff615 	stw	r2,-40(fp)
   e = 0;
 823fd7c:	e03ff715 	stw	zero,-36(fp)
   while (left > 1)  /* more data left to send? */
 823fd80:	0000a106 	br	8240008 <ip_fragment_lc+0x3fc>
   {
      p = pkt2;  /* move next fragment up */
 823fd84:	e0bff617 	ldw	r2,-40(fp)
 823fd88:	e0bffe15 	stw	r2,-8(fp)
      pip = (struct ip *)(p->nb_prot);
 823fd8c:	e0bffe17 	ldw	r2,-8(fp)
 823fd90:	10800317 	ldw	r2,12(r2)
 823fd94:	e0bff815 	stw	r2,-32(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 823fd98:	e0bffc17 	ldw	r2,-16(fp)
 823fd9c:	e0fff517 	ldw	r3,-44(fp)
 823fda0:	1880010e 	bge	r3,r2,823fda8 <ip_fragment_lc+0x19c>
 823fda4:	1805883a 	mov	r2,r3
 823fda8:	e0fff917 	ldw	r3,-28(fp)
 823fdac:	10c5883a 	add	r2,r2,r3
 823fdb0:	1007883a 	mov	r3,r2
 823fdb4:	e0bffe17 	ldw	r2,-8(fp)
 823fdb8:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 823fdbc:	e0fff517 	ldw	r3,-44(fp)
 823fdc0:	e0bffc17 	ldw	r2,-16(fp)
 823fdc4:	1885c83a 	sub	r2,r3,r2
 823fdc8:	e0bff515 	stw	r2,-44(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 823fdcc:	e0bffe17 	ldw	r2,-8(fp)
 823fdd0:	10800417 	ldw	r2,16(r2)
 823fdd4:	10bfffcc 	andi	r2,r2,65535
 823fdd8:	1005d23a 	srai	r2,r2,8
 823fddc:	10803fcc 	andi	r2,r2,255
 823fde0:	1007883a 	mov	r3,r2
 823fde4:	e0bffe17 	ldw	r2,-8(fp)
 823fde8:	10800417 	ldw	r2,16(r2)
 823fdec:	10bfffcc 	andi	r2,r2,65535
 823fdf0:	1004923a 	slli	r2,r2,8
 823fdf4:	1884b03a 	or	r2,r3,r2
 823fdf8:	1007883a 	mov	r3,r2
 823fdfc:	e0bff817 	ldw	r2,-32(fp)
 823fe00:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 823fe04:	e0bff317 	ldw	r2,-52(fp)
 823fe08:	1004d0fa 	srli	r2,r2,3
 823fe0c:	e0bff40d 	sth	r2,-48(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 823fe10:	e0bff517 	ldw	r2,-44(fp)
 823fe14:	10800090 	cmplti	r2,r2,2
 823fe18:	1000021e 	bne	r2,zero,823fe24 <ip_fragment_lc+0x218>
 823fe1c:	00880004 	movi	r2,8192
 823fe20:	00000106 	br	823fe28 <ip_fragment_lc+0x21c>
 823fe24:	0005883a 	mov	r2,zero
 823fe28:	e0fff40b 	ldhu	r3,-48(fp)
 823fe2c:	10c4b03a 	or	r2,r2,r3
 823fe30:	e0bff40d 	sth	r2,-48(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 823fe34:	e0bffd0b 	ldhu	r2,-12(fp)
 823fe38:	1088000c 	andi	r2,r2,8192
 823fe3c:	10000326 	beq	r2,zero,823fe4c <ip_fragment_lc+0x240>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 823fe40:	e0bff40b 	ldhu	r2,-48(fp)
 823fe44:	10880014 	ori	r2,r2,8192
 823fe48:	e0bff40d 	sth	r2,-48(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 823fe4c:	e0bff40b 	ldhu	r2,-48(fp)
 823fe50:	1004d23a 	srli	r2,r2,8
 823fe54:	1007883a 	mov	r3,r2
 823fe58:	e0bff40b 	ldhu	r2,-48(fp)
 823fe5c:	1004923a 	slli	r2,r2,8
 823fe60:	1884b03a 	or	r2,r3,r2
 823fe64:	1007883a 	mov	r3,r2
 823fe68:	e0bff817 	ldw	r2,-32(fp)
 823fe6c:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 823fe70:	e0bff517 	ldw	r2,-44(fp)
 823fe74:	10800090 	cmplti	r2,r2,2
 823fe78:	10003e1e 	bne	r2,zero,823ff74 <ip_fragment_lc+0x368>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823fe7c:	01000084 	movi	r4,2
 823fe80:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 823fe84:	e0fff517 	ldw	r3,-44(fp)
 823fe88:	e0bff917 	ldw	r2,-28(fp)
 823fe8c:	1887883a 	add	r3,r3,r2
 823fe90:	d0a08117 	ldw	r2,-32252(gp)
 823fe94:	1885883a 	add	r2,r3,r2
 823fe98:	1009883a 	mov	r4,r2
 823fe9c:	822c6200 	call	822c620 <pk_alloc>
 823fea0:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823fea4:	01000084 	movi	r4,2
 823fea8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 823feac:	e0bff617 	ldw	r2,-40(fp)
 823feb0:	1000101e 	bne	r2,zero,823fef4 <ip_fragment_lc+0x2e8>
         {
            dtrap();
 823feb4:	822d1c80 	call	822d1c8 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823feb8:	01000084 	movi	r4,2
 823febc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(p);
 823fec0:	e13ffe17 	ldw	r4,-8(fp)
 823fec4:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823fec8:	01000084 	movi	r4,2
 823fecc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 823fed0:	008209b4 	movhi	r2,2086
 823fed4:	10b8f804 	addi	r2,r2,-7200
 823fed8:	10801117 	ldw	r2,68(r2)
 823fedc:	10c00044 	addi	r3,r2,1
 823fee0:	008209b4 	movhi	r2,2086
 823fee4:	10b8f804 	addi	r2,r2,-7200
 823fee8:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 823feec:	00bffa84 	movi	r2,-22
 823fef0:	00004906 	br	8240018 <ip_fragment_lc+0x40c>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 823fef4:	e0bffe17 	ldw	r2,-8(fp)
 823fef8:	10c00617 	ldw	r3,24(r2)
 823fefc:	e0bff617 	ldw	r2,-40(fp)
 823ff00:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 823ff04:	e0bffe17 	ldw	r2,-8(fp)
 823ff08:	10c00717 	ldw	r3,28(r2)
 823ff0c:	e0bff617 	ldw	r2,-40(fp)
 823ff10:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 823ff14:	e0bff617 	ldw	r2,-40(fp)
 823ff18:	10c00317 	ldw	r3,12(r2)
 823ff1c:	e0bffe17 	ldw	r2,-8(fp)
 823ff20:	10800317 	ldw	r2,12(r2)
 823ff24:	e13ff917 	ldw	r4,-28(fp)
 823ff28:	200d883a 	mov	r6,r4
 823ff2c:	100b883a 	mov	r5,r2
 823ff30:	1809883a 	mov	r4,r3
 823ff34:	8202a0c0 	call	8202a0c <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 823ff38:	e0bff617 	ldw	r2,-40(fp)
 823ff3c:	10c00317 	ldw	r3,12(r2)
 823ff40:	e0bff917 	ldw	r2,-28(fp)
 823ff44:	188f883a 	add	r7,r3,r2
 823ff48:	e0bffe17 	ldw	r2,-8(fp)
 823ff4c:	10c00317 	ldw	r3,12(r2)
 823ff50:	e13ff917 	ldw	r4,-28(fp)
 823ff54:	e0bffc17 	ldw	r2,-16(fp)
 823ff58:	2085883a 	add	r2,r4,r2
 823ff5c:	1885883a 	add	r2,r3,r2
 823ff60:	e0fff517 	ldw	r3,-44(fp)
 823ff64:	180d883a 	mov	r6,r3
 823ff68:	100b883a 	mov	r5,r2
 823ff6c:	3809883a 	mov	r4,r7
 823ff70:	8202a0c0 	call	8202a0c <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 823ff74:	e0bff817 	ldw	r2,-32(fp)
 823ff78:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 823ff7c:	01400284 	movi	r5,10
 823ff80:	e13ff817 	ldw	r4,-32(fp)
 823ff84:	82283e80 	call	82283e8 <cksum>
 823ff88:	0084303a 	nor	r2,zero,r2
 823ff8c:	1007883a 	mov	r3,r2
 823ff90:	e0bff817 	ldw	r2,-32(fp)
 823ff94:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 823ff98:	e17fff17 	ldw	r5,-4(fp)
 823ff9c:	e13ffe17 	ldw	r4,-8(fp)
 823ffa0:	822632c0 	call	822632c <ip2mac>
 823ffa4:	e0bff715 	stw	r2,-36(fp)
      ip_mib.ipFragCreates++;
 823ffa8:	008209b4 	movhi	r2,2086
 823ffac:	10b8f804 	addi	r2,r2,-7200
 823ffb0:	10801217 	ldw	r2,72(r2)
 823ffb4:	10c00044 	addi	r3,r2,1
 823ffb8:	008209b4 	movhi	r2,2086
 823ffbc:	10b8f804 	addi	r2,r2,-7200
 823ffc0:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 823ffc4:	e0bff717 	ldw	r2,-36(fp)
 823ffc8:	10000b0e 	bge	r2,zero,823fff8 <ip_fragment_lc+0x3ec>
      {
         if (left > 1) 
 823ffcc:	e0bff517 	ldw	r2,-44(fp)
 823ffd0:	10800090 	cmplti	r2,r2,2
 823ffd4:	1000061e 	bne	r2,zero,823fff0 <ip_fragment_lc+0x3e4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823ffd8:	01000084 	movi	r4,2
 823ffdc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 823ffe0:	e13ff617 	ldw	r4,-40(fp)
 823ffe4:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ffe8:	01000084 	movi	r4,2
 823ffec:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         }
         return e;
 823fff0:	e0bff717 	ldw	r2,-36(fp)
 823fff4:	00000806 	br	8240018 <ip_fragment_lc+0x40c>
      }
      foffset += fragsize;    /* offset for next fragment */
 823fff8:	e0fff317 	ldw	r3,-52(fp)
 823fffc:	e0bffc17 	ldw	r2,-16(fp)
 8240000:	1885883a 	add	r2,r3,r2
 8240004:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 8240008:	e0bff517 	ldw	r2,-44(fp)
 824000c:	10800088 	cmpgei	r2,r2,2
 8240010:	103f5c1e 	bne	r2,zero,823fd84 <ip_fragment_lc+0x178>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 8240014:	e0bff717 	ldw	r2,-36(fp)
}
 8240018:	e037883a 	mov	sp,fp
 824001c:	dfc00117 	ldw	ra,4(sp)
 8240020:	df000017 	ldw	fp,0(sp)
 8240024:	dec00204 	addi	sp,sp,8
 8240028:	f800283a 	ret

0824002c <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 824002c:	defff004 	addi	sp,sp,-64
 8240030:	dfc00f15 	stw	ra,60(sp)
 8240034:	df000e15 	stw	fp,56(sp)
 8240038:	df000e04 	addi	fp,sp,56
 824003c:	e13ffe15 	stw	r4,-8(fp)
 8240040:	e17fff15 	stw	r5,-4(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 8240044:	e0bffe17 	ldw	r2,-8(fp)
 8240048:	10800317 	ldw	r2,12(r2)
 824004c:	e0bff515 	stw	r2,-44(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 8240050:	e0bff517 	ldw	r2,-44(fp)
 8240054:	1080018b 	ldhu	r2,6(r2)
 8240058:	10bfffcc 	andi	r2,r2,65535
 824005c:	1004d23a 	srli	r2,r2,8
 8240060:	10bfffcc 	andi	r2,r2,65535
 8240064:	10c03fcc 	andi	r3,r2,255
 8240068:	e0bff517 	ldw	r2,-44(fp)
 824006c:	1080018b 	ldhu	r2,6(r2)
 8240070:	10bfffcc 	andi	r2,r2,65535
 8240074:	1004923a 	slli	r2,r2,8
 8240078:	10bfffcc 	andi	r2,r2,65535
 824007c:	1884b03a 	or	r2,r3,r2
 8240080:	1090000c 	andi	r2,r2,16384
 8240084:	10001c26 	beq	r2,zero,82400f8 <ip_fragment+0xcc>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240088:	01000084 	movi	r4,2
 824008c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 8240090:	e13ffe17 	ldw	r4,-8(fp)
 8240094:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240098:	01000084 	movi	r4,2
 824009c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 82400a0:	008209b4 	movhi	r2,2086
 82400a4:	10b8f804 	addi	r2,r2,-7200
 82400a8:	10801117 	ldw	r2,68(r2)
 82400ac:	10c00044 	addi	r3,r2,1
 82400b0:	008209b4 	movhi	r2,2086
 82400b4:	10b8f804 	addi	r2,r2,-7200
 82400b8:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82400bc:	e0bff517 	ldw	r2,-44(fp)
 82400c0:	10c00317 	ldw	r3,12(r2)
 82400c4:	e0bffe17 	ldw	r2,-8(fp)
 82400c8:	10800617 	ldw	r2,24(r2)
 82400cc:	11000a17 	ldw	r4,40(r2)
 82400d0:	e0bffe17 	ldw	r2,-8(fp)
 82400d4:	10800617 	ldw	r2,24(r2)
 82400d8:	d8800015 	stw	r2,0(sp)
 82400dc:	01c00104 	movi	r7,4
 82400e0:	e1bff517 	ldw	r6,-44(fp)
 82400e4:	200b883a 	mov	r5,r4
 82400e8:	1809883a 	mov	r4,r3
 82400ec:	824aac00 	call	824aac0 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 82400f0:	0005883a 	mov	r2,zero
 82400f4:	00013906 	br	82405dc <ip_fragment+0x5b0>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 82400f8:	822ca1c0 	call	822ca1c <pk_get_max_intrsafe_buf_len>
 82400fc:	e0bff615 	stw	r2,-40(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 8240100:	e0bffe17 	ldw	r2,-8(fp)
 8240104:	10800617 	ldw	r2,24(r2)
 8240108:	10800917 	ldw	r2,36(r2)
 824010c:	1007883a 	mov	r3,r2
 8240110:	e0bff617 	ldw	r2,-40(fp)
 8240114:	10c0022e 	bgeu	r2,r3,8240120 <ip_fragment+0xf4>
 8240118:	e0bff617 	ldw	r2,-40(fp)
 824011c:	00000306 	br	824012c <ip_fragment+0x100>
 8240120:	e0bffe17 	ldw	r2,-8(fp)
 8240124:	10800617 	ldw	r2,24(r2)
 8240128:	10800917 	ldw	r2,36(r2)
 824012c:	e0bff70d 	sth	r2,-36(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 8240130:	e0bff517 	ldw	r2,-44(fp)
 8240134:	10800003 	ldbu	r2,0(r2)
 8240138:	108003cc 	andi	r2,r2,15
 824013c:	1085883a 	add	r2,r2,r2
 8240140:	1085883a 	add	r2,r2,r2
 8240144:	e0bff785 	stb	r2,-34(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 8240148:	e0bffe17 	ldw	r2,-8(fp)
 824014c:	10800617 	ldw	r2,24(r2)
 8240150:	10800817 	ldw	r2,32(r2)
 8240154:	e0bff7c5 	stb	r2,-33(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 8240158:	e0bff783 	ldbu	r2,-34(fp)
 824015c:	e0fff70b 	ldhu	r3,-36(fp)
 8240160:	1885c83a 	sub	r2,r3,r2
 8240164:	1007883a 	mov	r3,r2
 8240168:	e0bff7c3 	ldbu	r2,-33(fp)
 824016c:	1885c83a 	sub	r2,r3,r2
 8240170:	e0bff80d 	sth	r2,-32(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 8240174:	e0fff80b 	ldhu	r3,-32(fp)
 8240178:	00bffe04 	movi	r2,-8
 824017c:	1884703a 	and	r2,r3,r2
 8240180:	e0bff80d 	sth	r2,-32(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 8240184:	e0bff517 	ldw	r2,-44(fp)
 8240188:	1080008b 	ldhu	r2,2(r2)
 824018c:	10bfffcc 	andi	r2,r2,65535
 8240190:	1004d23a 	srli	r2,r2,8
 8240194:	1007883a 	mov	r3,r2
 8240198:	e0bff517 	ldw	r2,-44(fp)
 824019c:	1080008b 	ldhu	r2,2(r2)
 82401a0:	10bfffcc 	andi	r2,r2,65535
 82401a4:	1004923a 	slli	r2,r2,8
 82401a8:	1884b03a 	or	r2,r3,r2
 82401ac:	1007883a 	mov	r3,r2
 82401b0:	e0bff783 	ldbu	r2,-34(fp)
 82401b4:	1885c83a 	sub	r2,r3,r2
 82401b8:	e0bff88d 	sth	r2,-30(fp)
   num_frags = (total_payload_len / useable_payload_len);
 82401bc:	e0bff88b 	ldhu	r2,-30(fp)
 82401c0:	e0fff80b 	ldhu	r3,-32(fp)
 82401c4:	180b883a 	mov	r5,r3
 82401c8:	1009883a 	mov	r4,r2
 82401cc:	820270c0 	call	820270c <__udivsi3>
 82401d0:	e0bff30d 	sth	r2,-52(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 82401d4:	e0bff88b 	ldhu	r2,-30(fp)
 82401d8:	e0fff80b 	ldhu	r3,-32(fp)
 82401dc:	180b883a 	mov	r5,r3
 82401e0:	1009883a 	mov	r4,r2
 82401e4:	82027700 	call	8202770 <__umodsi3>
 82401e8:	e0bff90d 	sth	r2,-28(fp)
 82401ec:	e0bff90b 	ldhu	r2,-28(fp)
 82401f0:	10000326 	beq	r2,zero,8240200 <ip_fragment+0x1d4>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 82401f4:	e0bff30b 	ldhu	r2,-52(fp)
 82401f8:	10800044 	addi	r2,r2,1
 82401fc:	e0bff30d 	sth	r2,-52(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 8240200:	e0bff30b 	ldhu	r2,-52(fp)
 8240204:	10800128 	cmpgeui	r2,r2,4
 8240208:	1000081e 	bne	r2,zero,824022c <ip_fragment+0x200>
 824020c:	e0bffe17 	ldw	r2,-8(fp)
 8240210:	10800a17 	ldw	r2,40(r2)
 8240214:	1080040c 	andi	r2,r2,16
 8240218:	1000041e 	bne	r2,zero,824022c <ip_fragment+0x200>
   {
      return (ip_fragment_lc (p, firsthop));
 824021c:	e17fff17 	ldw	r5,-4(fp)
 8240220:	e13ffe17 	ldw	r4,-8(fp)
 8240224:	823fc0c0 	call	823fc0c <ip_fragment_lc>
 8240228:	0000ec06 	br	82405dc <ip_fragment+0x5b0>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 824022c:	e0bff517 	ldw	r2,-44(fp)
 8240230:	1080018b 	ldhu	r2,6(r2)
 8240234:	10bfffcc 	andi	r2,r2,65535
 8240238:	1004d23a 	srli	r2,r2,8
 824023c:	10bfffcc 	andi	r2,r2,65535
 8240240:	10c03fcc 	andi	r3,r2,255
 8240244:	e0bff517 	ldw	r2,-44(fp)
 8240248:	1080018b 	ldhu	r2,6(r2)
 824024c:	10bfffcc 	andi	r2,r2,65535
 8240250:	1004923a 	slli	r2,r2,8
 8240254:	10bfffcc 	andi	r2,r2,65535
 8240258:	1884b03a 	or	r2,r3,r2
 824025c:	100490fa 	slli	r2,r2,3
 8240260:	e0bff98d 	sth	r2,-26(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 8240264:	e0bff517 	ldw	r2,-44(fp)
 8240268:	1080018b 	ldhu	r2,6(r2)
 824026c:	10bfffcc 	andi	r2,r2,65535
 8240270:	1004d23a 	srli	r2,r2,8
 8240274:	1007883a 	mov	r3,r2
 8240278:	e0bff517 	ldw	r2,-44(fp)
 824027c:	1080018b 	ldhu	r2,6(r2)
 8240280:	10bfffcc 	andi	r2,r2,65535
 8240284:	1004923a 	slli	r2,r2,8
 8240288:	1884b03a 	or	r2,r3,r2
 824028c:	1088000c 	andi	r2,r2,8192
 8240290:	e0bffa0d 	sth	r2,-24(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 8240294:	e03ff38d 	sth	zero,-50(fp)
 8240298:	0000bf06 	br	8240598 <ip_fragment+0x56c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824029c:	01000084 	movi	r4,2
 82402a0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 82402a4:	e0fff80b 	ldhu	r3,-32(fp)
 82402a8:	e0bff783 	ldbu	r2,-34(fp)
 82402ac:	1887883a 	add	r3,r3,r2
 82402b0:	e0bff7c3 	ldbu	r2,-33(fp)
 82402b4:	1885883a 	add	r2,r3,r2
 82402b8:	1009883a 	mov	r4,r2
 82402bc:	822c6200 	call	822c620 <pk_alloc>
 82402c0:	e0bffb15 	stw	r2,-20(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82402c4:	01000084 	movi	r4,2
 82402c8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 82402cc:	e0bffb17 	ldw	r2,-20(fp)
 82402d0:	10000f1e 	bne	r2,zero,8240310 <ip_fragment+0x2e4>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82402d4:	01000084 	movi	r4,2
 82402d8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 82402dc:	e13ffe17 	ldw	r4,-8(fp)
 82402e0:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82402e4:	01000084 	movi	r4,2
 82402e8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 82402ec:	008209b4 	movhi	r2,2086
 82402f0:	10b8f804 	addi	r2,r2,-7200
 82402f4:	10801117 	ldw	r2,68(r2)
 82402f8:	10c00044 	addi	r3,r2,1
 82402fc:	008209b4 	movhi	r2,2086
 8240300:	10b8f804 	addi	r2,r2,-7200
 8240304:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 8240308:	00bffac4 	movi	r2,-21
 824030c:	0000b306 	br	82405dc <ip_fragment+0x5b0>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 8240310:	e0bffb17 	ldw	r2,-20(fp)
 8240314:	10c00117 	ldw	r3,4(r2)
 8240318:	e0bff7c3 	ldbu	r2,-33(fp)
 824031c:	1887883a 	add	r3,r3,r2
 8240320:	e0bffe17 	ldw	r2,-8(fp)
 8240324:	10800317 	ldw	r2,12(r2)
 8240328:	e13ff783 	ldbu	r4,-34(fp)
 824032c:	200d883a 	mov	r6,r4
 8240330:	100b883a 	mov	r5,r2
 8240334:	1809883a 	mov	r4,r3
 8240338:	8202a0c0 	call	8202a0c <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 824033c:	e0fff38b 	ldhu	r3,-50(fp)
 8240340:	e0bff30b 	ldhu	r2,-52(fp)
 8240344:	10bfffc4 	addi	r2,r2,-1
 8240348:	1880030e 	bge	r3,r2,8240358 <ip_fragment+0x32c>
         {
            amt_to_copy = useable_payload_len;
 824034c:	e0bff80b 	ldhu	r2,-32(fp)
 8240350:	e0bff40d 	sth	r2,-48(fp)
 8240354:	00000606 	br	8240370 <ip_fragment+0x344>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 8240358:	e0bff90b 	ldhu	r2,-28(fp)
 824035c:	1000021e 	bne	r2,zero,8240368 <ip_fragment+0x33c>
 8240360:	e0bff80b 	ldhu	r2,-32(fp)
 8240364:	00000106 	br	824036c <ip_fragment+0x340>
 8240368:	e0bff90b 	ldhu	r2,-28(fp)
 824036c:	e0bff40d 	sth	r2,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 8240370:	e0bffb17 	ldw	r2,-20(fp)
 8240374:	10c00117 	ldw	r3,4(r2)
 8240378:	e13ff7c3 	ldbu	r4,-33(fp)
 824037c:	e0bff783 	ldbu	r2,-34(fp)
 8240380:	2085883a 	add	r2,r4,r2
 8240384:	188f883a 	add	r7,r3,r2
 8240388:	e0bffe17 	ldw	r2,-8(fp)
 824038c:	10c00317 	ldw	r3,12(r2)
 8240390:	e0bff783 	ldbu	r2,-34(fp)
 8240394:	e17ff80b 	ldhu	r5,-32(fp)
 8240398:	e13ff38b 	ldhu	r4,-50(fp)
 824039c:	2909383a 	mul	r4,r5,r4
 82403a0:	1105883a 	add	r2,r2,r4
 82403a4:	1885883a 	add	r2,r3,r2
 82403a8:	e0fff40b 	ldhu	r3,-48(fp)
 82403ac:	180d883a 	mov	r6,r3
 82403b0:	100b883a 	mov	r5,r2
 82403b4:	3809883a 	mov	r4,r7
 82403b8:	8202a0c0 	call	8202a0c <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 82403bc:	e0bffb17 	ldw	r2,-20(fp)
 82403c0:	10c00117 	ldw	r3,4(r2)
 82403c4:	e0bff7c3 	ldbu	r2,-33(fp)
 82403c8:	1887883a 	add	r3,r3,r2
 82403cc:	e0bffb17 	ldw	r2,-20(fp)
 82403d0:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 82403d4:	e0fff783 	ldbu	r3,-34(fp)
 82403d8:	e0bff40b 	ldhu	r2,-48(fp)
 82403dc:	1885883a 	add	r2,r3,r2
 82403e0:	1007883a 	mov	r3,r2
 82403e4:	e0bffb17 	ldw	r2,-20(fp)
 82403e8:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 82403ec:	e0bffe17 	ldw	r2,-8(fp)
 82403f0:	10c00617 	ldw	r3,24(r2)
 82403f4:	e0bffb17 	ldw	r2,-20(fp)
 82403f8:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 82403fc:	e0bffe17 	ldw	r2,-8(fp)
 8240400:	10c00717 	ldw	r3,28(r2)
 8240404:	e0bffb17 	ldw	r2,-20(fp)
 8240408:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 824040c:	e0bffb17 	ldw	r2,-20(fp)
 8240410:	00c20004 	movi	r3,2048
 8240414:	10c0080d 	sth	r3,32(r2)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 8240418:	e0bffb17 	ldw	r2,-20(fp)
 824041c:	10800317 	ldw	r2,12(r2)
 8240420:	e0bffc15 	stw	r2,-16(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 8240424:	e0bffb17 	ldw	r2,-20(fp)
 8240428:	10800417 	ldw	r2,16(r2)
 824042c:	1004d23a 	srli	r2,r2,8
 8240430:	10803fcc 	andi	r2,r2,255
 8240434:	1007883a 	mov	r3,r2
 8240438:	e0bffb17 	ldw	r2,-20(fp)
 824043c:	10800417 	ldw	r2,16(r2)
 8240440:	1004923a 	slli	r2,r2,8
 8240444:	1884b03a 	or	r2,r3,r2
 8240448:	1007883a 	mov	r3,r2
 824044c:	e0bffc17 	ldw	r2,-16(fp)
 8240450:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 8240454:	e0fff98b 	ldhu	r3,-26(fp)
 8240458:	e13ff80b 	ldhu	r4,-32(fp)
 824045c:	e0bff38b 	ldhu	r2,-50(fp)
 8240460:	2085383a 	mul	r2,r4,r2
 8240464:	1885883a 	add	r2,r3,r2
 8240468:	1005d2fa 	srai	r2,r2,11
 824046c:	10803fcc 	andi	r2,r2,255
 8240470:	100b883a 	mov	r5,r2
 8240474:	e0fff98b 	ldhu	r3,-26(fp)
 8240478:	e13ff80b 	ldhu	r4,-32(fp)
 824047c:	e0bff38b 	ldhu	r2,-50(fp)
 8240480:	2085383a 	mul	r2,r4,r2
 8240484:	1885883a 	add	r2,r3,r2
 8240488:	1005d0fa 	srai	r2,r2,3
 824048c:	1004923a 	slli	r2,r2,8
 8240490:	2884b03a 	or	r2,r5,r2
 8240494:	1007883a 	mov	r3,r2
 8240498:	e0bffc17 	ldw	r2,-16(fp)
 824049c:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 82404a0:	e0fff38b 	ldhu	r3,-50(fp)
 82404a4:	e0bff30b 	ldhu	r2,-52(fp)
 82404a8:	10bfffc4 	addi	r2,r2,-1
 82404ac:	1880070e 	bge	r3,r2,82404cc <ip_fragment+0x4a0>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82404b0:	e0bffc17 	ldw	r2,-16(fp)
 82404b4:	1080018b 	ldhu	r2,6(r2)
 82404b8:	10800814 	ori	r2,r2,32
 82404bc:	1007883a 	mov	r3,r2
 82404c0:	e0bffc17 	ldw	r2,-16(fp)
 82404c4:	10c0018d 	sth	r3,6(r2)
 82404c8:	00000806 	br	82404ec <ip_fragment+0x4c0>
         }
         else
         {
            if (parent_mf)
 82404cc:	e0bffa0b 	ldhu	r2,-24(fp)
 82404d0:	10000626 	beq	r2,zero,82404ec <ip_fragment+0x4c0>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82404d4:	e0bffc17 	ldw	r2,-16(fp)
 82404d8:	1080018b 	ldhu	r2,6(r2)
 82404dc:	10800814 	ori	r2,r2,32
 82404e0:	1007883a 	mov	r3,r2
 82404e4:	e0bffc17 	ldw	r2,-16(fp)
 82404e8:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 82404ec:	e0bffc17 	ldw	r2,-16(fp)
 82404f0:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 82404f4:	e0bff783 	ldbu	r2,-34(fp)
 82404f8:	1004d07a 	srli	r2,r2,1
 82404fc:	10803fcc 	andi	r2,r2,255
 8240500:	100b883a 	mov	r5,r2
 8240504:	e13ffc17 	ldw	r4,-16(fp)
 8240508:	82283e80 	call	82283e8 <cksum>
 824050c:	0084303a 	nor	r2,zero,r2
 8240510:	1007883a 	mov	r3,r2
 8240514:	e0bffc17 	ldw	r2,-16(fp)
 8240518:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 824051c:	008209b4 	movhi	r2,2086
 8240520:	10b8f804 	addi	r2,r2,-7200
 8240524:	10801217 	ldw	r2,72(r2)
 8240528:	10c00044 	addi	r3,r2,1
 824052c:	008209b4 	movhi	r2,2086
 8240530:	10b8f804 	addi	r2,r2,-7200
 8240534:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 8240538:	e17fff17 	ldw	r5,-4(fp)
 824053c:	e13ffb17 	ldw	r4,-20(fp)
 8240540:	822632c0 	call	822632c <ip2mac>
 8240544:	e0bffd15 	stw	r2,-12(fp)
         if (e < 0)
 8240548:	e0bffd17 	ldw	r2,-12(fp)
 824054c:	10000f0e 	bge	r2,zero,824058c <ip_fragment+0x560>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8240550:	01000084 	movi	r4,2
 8240554:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(p);
 8240558:	e13ffe17 	ldw	r4,-8(fp)
 824055c:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240560:	01000084 	movi	r4,2
 8240564:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 8240568:	008209b4 	movhi	r2,2086
 824056c:	10b8f804 	addi	r2,r2,-7200
 8240570:	10801117 	ldw	r2,68(r2)
 8240574:	10c00044 	addi	r3,r2,1
 8240578:	008209b4 	movhi	r2,2086
 824057c:	10b8f804 	addi	r2,r2,-7200
 8240580:	10c01115 	stw	r3,68(r2)
            return e;
 8240584:	e0bffd17 	ldw	r2,-12(fp)
 8240588:	00001406 	br	82405dc <ip_fragment+0x5b0>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 824058c:	e0bff38b 	ldhu	r2,-50(fp)
 8240590:	10800044 	addi	r2,r2,1
 8240594:	e0bff38d 	sth	r2,-50(fp)
 8240598:	e0fff38b 	ldhu	r3,-50(fp)
 824059c:	e0bff30b 	ldhu	r2,-52(fp)
 82405a0:	18bf3e36 	bltu	r3,r2,824029c <ip_fragment+0x270>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82405a4:	01000084 	movi	r4,2
 82405a8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 82405ac:	e13ffe17 	ldw	r4,-8(fp)
 82405b0:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82405b4:	01000084 	movi	r4,2
 82405b8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 82405bc:	008209b4 	movhi	r2,2086
 82405c0:	10b8f804 	addi	r2,r2,-7200
 82405c4:	10801017 	ldw	r2,64(r2)
 82405c8:	10c00044 	addi	r3,r2,1
 82405cc:	008209b4 	movhi	r2,2086
 82405d0:	10b8f804 	addi	r2,r2,-7200
 82405d4:	10c01015 	stw	r3,64(r2)

   return 0;
 82405d8:	0005883a 	mov	r2,zero
}
 82405dc:	e037883a 	mov	sp,fp
 82405e0:	dfc00117 	ldw	ra,4(sp)
 82405e4:	df000017 	ldw	fp,0(sp)
 82405e8:	dec00204 	addi	sp,sp,8
 82405ec:	f800283a 	ret

082405f0 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 82405f0:	defffa04 	addi	sp,sp,-24
 82405f4:	dfc00515 	stw	ra,20(sp)
 82405f8:	df000415 	stw	fp,16(sp)
 82405fc:	df000404 	addi	fp,sp,16
 8240600:	e13fff15 	stw	r4,-4(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 8240604:	e0bffe04 	addi	r2,fp,-8
 8240608:	100b883a 	mov	r5,r2
 824060c:	e13fff17 	ldw	r4,-4(fp)
 8240610:	824093c0 	call	824093c <iproute>
 8240614:	e0bffd15 	stw	r2,-12(fp)
   if (tnet == 0)
 8240618:	e0bffd17 	ldw	r2,-12(fp)
 824061c:	1000161e 	bne	r2,zero,8240678 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 8240620:	d0a08317 	ldw	r2,-32244(gp)
 8240624:	1080050c 	andi	r2,r2,20
 8240628:	10001126 	beq	r2,zero,8240670 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824062c:	e0bfff17 	ldw	r2,-4(fp)
 8240630:	10c03fcc 	andi	r3,r2,255
 8240634:	e0bfff17 	ldw	r2,-4(fp)
 8240638:	1004d23a 	srli	r2,r2,8
 824063c:	11003fcc 	andi	r4,r2,255
 8240640:	e0bfff17 	ldw	r2,-4(fp)
 8240644:	1004d43a 	srli	r2,r2,16
 8240648:	11403fcc 	andi	r5,r2,255
 824064c:	e0bfff17 	ldw	r2,-4(fp)
 8240650:	1004d63a 	srli	r2,r2,24
 8240654:	d8800015 	stw	r2,0(sp)
 8240658:	280f883a 	mov	r7,r5
 824065c:	200d883a 	mov	r6,r4
 8240660:	180b883a 	mov	r5,r3
 8240664:	01020974 	movhi	r4,2085
 8240668:	21032904 	addi	r4,r4,3236
 824066c:	8202e9c0 	call	8202e9c <printf>
#endif   /* NPDEBUG */
      return 0L;
 8240670:	0005883a 	mov	r2,zero
 8240674:	00000206 	br	8240680 <ip_mymach+0x90>
   }
   return tnet->n_ipaddr;
 8240678:	e0bffd17 	ldw	r2,-12(fp)
 824067c:	10800a17 	ldw	r2,40(r2)
#endif /* MULTI_HOMED */
}
 8240680:	e037883a 	mov	sp,fp
 8240684:	dfc00117 	ldw	ra,4(sp)
 8240688:	df000017 	ldw	fp,0(sp)
 824068c:	dec00204 	addi	sp,sp,8
 8240690:	f800283a 	ret

08240694 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 8240694:	defff704 	addi	sp,sp,-36
 8240698:	dfc00815 	stw	ra,32(sp)
 824069c:	df000715 	stw	fp,28(sp)
 82406a0:	df000704 	addi	fp,sp,28
 82406a4:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 82406a8:	e0bfff17 	ldw	r2,-4(fp)
 82406ac:	10800317 	ldw	r2,12(r2)
 82406b0:	e0bffc15 	stw	r2,-16(fp)
   osum = pip->ip_chksum;
 82406b4:	e0bffc17 	ldw	r2,-16(fp)
 82406b8:	1080028b 	ldhu	r2,10(r2)
 82406bc:	e0bffd0d 	sth	r2,-12(fp)
   pip->ip_chksum = 0;
 82406c0:	e0bffc17 	ldw	r2,-16(fp)
 82406c4:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 82406c8:	e0bffc17 	ldw	r2,-16(fp)
 82406cc:	10800003 	ldbu	r2,0(r2)
 82406d0:	10803fcc 	andi	r2,r2,255
 82406d4:	108003cc 	andi	r2,r2,15
 82406d8:	1085883a 	add	r2,r2,r2
 82406dc:	1085883a 	add	r2,r2,r2
 82406e0:	1005d07a 	srai	r2,r2,1
 82406e4:	100b883a 	mov	r5,r2
 82406e8:	e13ffc17 	ldw	r4,-16(fp)
 82406ec:	82283e80 	call	82283e8 <cksum>
 82406f0:	0084303a 	nor	r2,zero,r2
 82406f4:	e0bffd8d 	sth	r2,-10(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 82406f8:	e0fffd0b 	ldhu	r3,-12(fp)
 82406fc:	e0bffd8b 	ldhu	r2,-10(fp)
 8240700:	18800126 	beq	r3,r2,8240708 <ip_dump+0x74>
   {
      dtrap();
 8240704:	822d1c80 	call	822d1c8 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 8240708:	01420974 	movhi	r5,2085
 824070c:	29433204 	addi	r5,r5,3272
 8240710:	0009883a 	mov	r4,zero
 8240714:	8228a940 	call	8228a94 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 8240718:	e0bffc17 	ldw	r2,-16(fp)
 824071c:	e0bffe15 	stw	r2,-8(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240720:	e0bffe17 	ldw	r2,-8(fp)
 8240724:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240728:	11403fcc 	andi	r5,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 824072c:	e0bffe17 	ldw	r2,-8(fp)
 8240730:	10800044 	addi	r2,r2,1
 8240734:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240738:	11803fcc 	andi	r6,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 824073c:	e0bffc17 	ldw	r2,-16(fp)
 8240740:	1080008b 	ldhu	r2,2(r2)
 8240744:	10bfffcc 	andi	r2,r2,65535
 8240748:	1004d23a 	srli	r2,r2,8
 824074c:	10bfffcc 	andi	r2,r2,65535
 8240750:	10c03fcc 	andi	r3,r2,255
 8240754:	e0bffc17 	ldw	r2,-16(fp)
 8240758:	1080008b 	ldhu	r2,2(r2)
 824075c:	10bfffcc 	andi	r2,r2,65535
 8240760:	1004923a 	slli	r2,r2,8
 8240764:	10bfffcc 	andi	r2,r2,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240768:	1884b03a 	or	r2,r3,r2
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 824076c:	e0fffc17 	ldw	r3,-16(fp)
 8240770:	18c0010b 	ldhu	r3,4(r3)
 8240774:	18ffffcc 	andi	r3,r3,65535
 8240778:	1806d23a 	srli	r3,r3,8
 824077c:	18ffffcc 	andi	r3,r3,65535
 8240780:	19003fcc 	andi	r4,r3,255
 8240784:	e0fffc17 	ldw	r3,-16(fp)
 8240788:	18c0010b 	ldhu	r3,4(r3)
 824078c:	18ffffcc 	andi	r3,r3,65535
 8240790:	1806923a 	slli	r3,r3,8
 8240794:	18ffffcc 	andi	r3,r3,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240798:	20c6b03a 	or	r3,r4,r3
 824079c:	d8c00115 	stw	r3,4(sp)
 82407a0:	d8800015 	stw	r2,0(sp)
 82407a4:	300f883a 	mov	r7,r6
 82407a8:	280d883a 	mov	r6,r5
 82407ac:	01420974 	movhi	r5,2085
 82407b0:	29433704 	addi	r5,r5,3292
 82407b4:	0009883a 	mov	r4,zero
 82407b8:	8228a940 	call	8228a94 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 82407bc:	e0bffe17 	ldw	r2,-8(fp)
 82407c0:	10800184 	addi	r2,r2,6
 82407c4:	1080000b 	ldhu	r2,0(r2)
 82407c8:	10bfffcc 	andi	r2,r2,65535
 82407cc:	1004d23a 	srli	r2,r2,8
 82407d0:	10bfffcc 	andi	r2,r2,65535
 82407d4:	10c03fcc 	andi	r3,r2,255
 82407d8:	e0bffe17 	ldw	r2,-8(fp)
 82407dc:	10800184 	addi	r2,r2,6
 82407e0:	1080000b 	ldhu	r2,0(r2)
 82407e4:	10bfffcc 	andi	r2,r2,65535
 82407e8:	1004923a 	slli	r2,r2,8
 82407ec:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 82407f0:	188cb03a 	or	r6,r3,r2
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 82407f4:	e0bffc17 	ldw	r2,-16(fp)
 82407f8:	10800203 	ldbu	r2,8(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 82407fc:	11c03fcc 	andi	r7,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240800:	e0bffc17 	ldw	r2,-16(fp)
 8240804:	10800243 	ldbu	r2,9(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240808:	10c03fcc 	andi	r3,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
 824080c:	e0bffd0b 	ldhu	r2,-12(fp)
 8240810:	1004d23a 	srli	r2,r2,8
 8240814:	10bfffcc 	andi	r2,r2,65535
 8240818:	11003fcc 	andi	r4,r2,255
 824081c:	e0bffd0b 	ldhu	r2,-12(fp)
 8240820:	1004923a 	slli	r2,r2,8
 8240824:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240828:	2088b03a 	or	r4,r4,r2
 824082c:	e17ffd0b 	ldhu	r5,-12(fp)
 8240830:	e0bffd8b 	ldhu	r2,-10(fp)
 8240834:	2880031e 	bne	r5,r2,8240844 <ip_dump+0x1b0>
 8240838:	00820974 	movhi	r2,2085
 824083c:	10834304 	addi	r2,r2,3340
 8240840:	00000206 	br	824084c <ip_dump+0x1b8>
 8240844:	00820974 	movhi	r2,2085
 8240848:	10834404 	addi	r2,r2,3344
 824084c:	d8800215 	stw	r2,8(sp)
 8240850:	d9000115 	stw	r4,4(sp)
 8240854:	d8c00015 	stw	r3,0(sp)
 8240858:	01420974 	movhi	r5,2085
 824085c:	29434504 	addi	r5,r5,3348
 8240860:	0009883a 	mov	r4,zero
 8240864:	8228a940 	call	8228a94 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 8240868:	e0bffc17 	ldw	r2,-16(fp)
 824086c:	10800317 	ldw	r2,12(r2)
 8240870:	11003fcc 	andi	r4,r2,255
 8240874:	e0bffc17 	ldw	r2,-16(fp)
 8240878:	10800317 	ldw	r2,12(r2)
 824087c:	1004d23a 	srli	r2,r2,8
 8240880:	11403fcc 	andi	r5,r2,255
 8240884:	e0bffc17 	ldw	r2,-16(fp)
 8240888:	10800317 	ldw	r2,12(r2)
 824088c:	1004d43a 	srli	r2,r2,16
 8240890:	10803fcc 	andi	r2,r2,255
 8240894:	e0fffc17 	ldw	r3,-16(fp)
 8240898:	18c00317 	ldw	r3,12(r3)
 824089c:	1806d63a 	srli	r3,r3,24
 82408a0:	d8c00115 	stw	r3,4(sp)
 82408a4:	d8800015 	stw	r2,0(sp)
 82408a8:	280f883a 	mov	r7,r5
 82408ac:	200d883a 	mov	r6,r4
 82408b0:	01420974 	movhi	r5,2085
 82408b4:	29435504 	addi	r5,r5,3412
 82408b8:	0009883a 	mov	r4,zero
 82408bc:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 82408c0:	e0bffc17 	ldw	r2,-16(fp)
 82408c4:	10800417 	ldw	r2,16(r2)
 82408c8:	11003fcc 	andi	r4,r2,255
 82408cc:	e0bffc17 	ldw	r2,-16(fp)
 82408d0:	10800417 	ldw	r2,16(r2)
 82408d4:	1004d23a 	srli	r2,r2,8
 82408d8:	11403fcc 	andi	r5,r2,255
 82408dc:	e0bffc17 	ldw	r2,-16(fp)
 82408e0:	10800417 	ldw	r2,16(r2)
 82408e4:	1004d43a 	srli	r2,r2,16
 82408e8:	10803fcc 	andi	r2,r2,255
 82408ec:	e0fffc17 	ldw	r3,-16(fp)
 82408f0:	18c00417 	ldw	r3,16(r3)
 82408f4:	1806d63a 	srli	r3,r3,24
 82408f8:	d8c00115 	stw	r3,4(sp)
 82408fc:	d8800015 	stw	r2,0(sp)
 8240900:	280f883a 	mov	r7,r5
 8240904:	200d883a 	mov	r6,r4
 8240908:	01420974 	movhi	r5,2085
 824090c:	29435a04 	addi	r5,r5,3432
 8240910:	0009883a 	mov	r4,zero
 8240914:	8228a940 	call	8228a94 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 8240918:	e0bffc17 	ldw	r2,-16(fp)
 824091c:	e0fffd0b 	ldhu	r3,-12(fp)
 8240920:	10c0028d 	sth	r3,10(r2)
}
 8240924:	0001883a 	nop
 8240928:	e037883a 	mov	sp,fp
 824092c:	dfc00117 	ldw	ra,4(sp)
 8240930:	df000017 	ldw	fp,0(sp)
 8240934:	dec00204 	addi	sp,sp,8
 8240938:	f800283a 	ret

0824093c <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 824093c:	defff804 	addi	sp,sp,-32
 8240940:	dfc00715 	stw	ra,28(sp)
 8240944:	df000615 	stw	fp,24(sp)
 8240948:	df000604 	addi	fp,sp,24
 824094c:	e13ffe15 	stw	r4,-8(fp)
 8240950:	e17fff15 	stw	r5,-4(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 8240954:	e0bffe17 	ldw	r2,-8(fp)
 8240958:	1000021e 	bne	r2,zero,8240964 <iproute+0x28>
      return NULL;
 824095c:	0005883a 	mov	r2,zero
 8240960:	00006706 	br	8240b00 <iproute+0x1c4>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 8240964:	d0a0c617 	ldw	r2,-31976(gp)
 8240968:	1000021e 	bne	r2,zero,8240974 <iproute+0x38>
      return NULL;
 824096c:	0005883a 	mov	r2,zero
 8240970:	00006306 	br	8240b00 <iproute+0x1c4>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 8240974:	d0a0d017 	ldw	r2,-31936(gp)
 8240978:	10000e26 	beq	r2,zero,82409b4 <iproute+0x78>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 824097c:	d0a0d017 	ldw	r2,-31936(gp)
 8240980:	10c00017 	ldw	r3,0(r2)
 8240984:	e0bffe17 	ldw	r2,-8(fp)
 8240988:	18800a1e 	bne	r3,r2,82409b4 <iproute+0x78>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 824098c:	d0a0d017 	ldw	r2,-31936(gp)
 8240990:	10c00617 	ldw	r3,24(r2)
 8240994:	e0bfff17 	ldw	r2,-4(fp)
 8240998:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 824099c:	d0a0d017 	ldw	r2,-31936(gp)
 82409a0:	d0e0a817 	ldw	r3,-32096(gp)
 82409a4:	10c00915 	stw	r3,36(r2)
         return(cachedRoute->ifp); /* net to send on */
 82409a8:	d0a0d017 	ldw	r2,-31936(gp)
 82409ac:	10800e17 	ldw	r2,56(r2)
 82409b0:	00005306 	br	8240b00 <iproute+0x1c4>
      }
   }

   rtp = rt_lookup(host);
 82409b4:	e13ffe17 	ldw	r4,-8(fp)
 82409b8:	8243e300 	call	8243e30 <rt_lookup>
 82409bc:	e0bffd15 	stw	r2,-12(fp)
   if(rtp)
 82409c0:	e0bffd17 	ldw	r2,-12(fp)
 82409c4:	10000926 	beq	r2,zero,82409ec <iproute+0xb0>
   {
      cachedRoute = rtp;
 82409c8:	e0bffd17 	ldw	r2,-12(fp)
 82409cc:	d0a0d015 	stw	r2,-31936(gp)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 82409d0:	e0bffd17 	ldw	r2,-12(fp)
 82409d4:	10c00617 	ldw	r3,24(r2)
 82409d8:	e0bfff17 	ldw	r2,-4(fp)
 82409dc:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 82409e0:	e0bffd17 	ldw	r2,-12(fp)
 82409e4:	10800e17 	ldw	r2,56(r2)
 82409e8:	00004506 	br	8240b00 <iproute+0x1c4>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 82409ec:	008209b4 	movhi	r2,2086
 82409f0:	10b8f304 	addi	r2,r2,-7220
 82409f4:	10800017 	ldw	r2,0(r2)
 82409f8:	e0bffc15 	stw	r2,-16(fp)
   i = 0;
 82409fc:	e03ffb15 	stw	zero,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240a00:	00002406 	br	8240a94 <iproute+0x158>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240a04:	e0bffc17 	ldw	r2,-16(fp)
 8240a08:	10800c17 	ldw	r2,48(r2)
 8240a0c:	10001b26 	beq	r2,zero,8240a7c <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
 8240a10:	e0bffc17 	ldw	r2,-16(fp)
 8240a14:	10800a17 	ldw	r2,40(r2)
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240a18:	10001826 	beq	r2,zero,8240a7c <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
 8240a1c:	e0bffc17 	ldw	r2,-16(fp)
 8240a20:	10c00a17 	ldw	r3,40(r2)
 8240a24:	e0bffe17 	ldw	r2,-8(fp)
 8240a28:	1886f03a 	xor	r3,r3,r2
 8240a2c:	e0bffc17 	ldw	r2,-16(fp)
 8240a30:	10800c17 	ldw	r2,48(r2)
 8240a34:	1884703a 	and	r2,r3,r2
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
         (ifp->n_ipaddr != 0) && 
 8240a38:	1000101e 	bne	r2,zero,8240a7c <iproute+0x140>
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 8240a3c:	00800044 	movi	r2,1
 8240a40:	d8800015 	stw	r2,0(sp)
 8240a44:	e1fffb17 	ldw	r7,-20(fp)
 8240a48:	e1bffe17 	ldw	r6,-8(fp)
 8240a4c:	017fffc4 	movi	r5,-1
 8240a50:	e13ffe17 	ldw	r4,-8(fp)
 8240a54:	8243f840 	call	8243f84 <add_route>
 8240a58:	d0a0d015 	stw	r2,-31936(gp)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 8240a5c:	d0a0d017 	ldw	r2,-31936(gp)
 8240a60:	1000011e 	bne	r2,zero,8240a68 <iproute+0x12c>
            dtrap();
 8240a64:	822d1c80 	call	822d1c8 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 8240a68:	e0bfff17 	ldw	r2,-4(fp)
 8240a6c:	e0fffe17 	ldw	r3,-8(fp)
 8240a70:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240a74:	e0bffc17 	ldw	r2,-16(fp)
 8240a78:	00002106 	br	8240b00 <iproute+0x1c4>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240a7c:	e0bffc17 	ldw	r2,-16(fp)
 8240a80:	10800017 	ldw	r2,0(r2)
 8240a84:	e0bffc15 	stw	r2,-16(fp)
 8240a88:	e0bffb17 	ldw	r2,-20(fp)
 8240a8c:	10800044 	addi	r2,r2,1
 8240a90:	e0bffb15 	stw	r2,-20(fp)
 8240a94:	e0bffc17 	ldw	r2,-16(fp)
 8240a98:	103fda1e 	bne	r2,zero,8240a04 <iproute+0xc8>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 8240a9c:	008209b4 	movhi	r2,2086
 8240aa0:	10b8f304 	addi	r2,r2,-7220
 8240aa4:	10800017 	ldw	r2,0(r2)
 8240aa8:	e0bffc15 	stw	r2,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240aac:	00000c06 	br	8240ae0 <iproute+0x1a4>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 8240ab0:	e0bffc17 	ldw	r2,-16(fp)
 8240ab4:	10800d17 	ldw	r2,52(r2)
 8240ab8:	10000626 	beq	r2,zero,8240ad4 <iproute+0x198>
      {
         *hop1 = ifp->n_defgw;
 8240abc:	e0bffc17 	ldw	r2,-16(fp)
 8240ac0:	10c00d17 	ldw	r3,52(r2)
 8240ac4:	e0bfff17 	ldw	r2,-4(fp)
 8240ac8:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240acc:	e0bffc17 	ldw	r2,-16(fp)
 8240ad0:	00000b06 	br	8240b00 <iproute+0x1c4>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240ad4:	e0bffc17 	ldw	r2,-16(fp)
 8240ad8:	10800017 	ldw	r2,0(r2)
 8240adc:	e0bffc15 	stw	r2,-16(fp)
 8240ae0:	e0bffc17 	ldw	r2,-16(fp)
 8240ae4:	103ff21e 	bne	r2,zero,8240ab0 <iproute+0x174>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 8240ae8:	e0bfff17 	ldw	r2,-4(fp)
 8240aec:	e0fffe17 	ldw	r3,-8(fp)
 8240af0:	10c00015 	stw	r3,0(r2)
   return((NET)(netlist.q_head));
 8240af4:	008209b4 	movhi	r2,2086
 8240af8:	10b8f304 	addi	r2,r2,-7220
 8240afc:	10800017 	ldw	r2,0(r2)
#endif   /* STRICT_SUBNETTING */
}
 8240b00:	e037883a 	mov	sp,fp
 8240b04:	dfc00117 	ldw	ra,4(sp)
 8240b08:	df000017 	ldw	fp,0(sp)
 8240b0c:	dec00204 	addi	sp,sp,8
 8240b10:	f800283a 	ret

08240b14 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 8240b14:	defffb04 	addi	sp,sp,-20
 8240b18:	dfc00415 	stw	ra,16(sp)
 8240b1c:	df000315 	stw	fp,12(sp)
 8240b20:	df000304 	addi	fp,sp,12
 8240b24:	e13fff15 	stw	r4,-4(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 8240b28:	e0bfff17 	ldw	r2,-4(fp)
 8240b2c:	10800417 	ldw	r2,16(r2)
 8240b30:	e0ffff17 	ldw	r3,-4(fp)
 8240b34:	18c00317 	ldw	r3,12(r3)
 8240b38:	1809883a 	mov	r4,r3
 8240b3c:	e0ffff17 	ldw	r3,-4(fp)
 8240b40:	18c00117 	ldw	r3,4(r3)
 8240b44:	20c7c83a 	sub	r3,r4,r3
 8240b48:	10c5883a 	add	r2,r2,r3
 8240b4c:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8240b50:	01000084 	movi	r4,2
 8240b54:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 8240b58:	e0bffd17 	ldw	r2,-12(fp)
 8240b5c:	1009883a 	mov	r4,r2
 8240b60:	822c6200 	call	822c620 <pk_alloc>
 8240b64:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240b68:	01000084 	movi	r4,2
 8240b6c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 8240b70:	e0bffe17 	ldw	r2,-8(fp)
 8240b74:	1000061e 	bne	r2,zero,8240b90 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 8240b78:	e17ffd17 	ldw	r5,-12(fp)
 8240b7c:	01020974 	movhi	r4,2085
 8240b80:	21035f04 	addi	r4,r4,3452
 8240b84:	8202e9c0 	call	8202e9c <printf>
#endif
      return NULL;
 8240b88:	0005883a 	mov	r2,zero
 8240b8c:	00002906 	br	8240c34 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 8240b90:	e0bffe17 	ldw	r2,-8(fp)
 8240b94:	10c00117 	ldw	r3,4(r2)
 8240b98:	e0bfff17 	ldw	r2,-4(fp)
 8240b9c:	10800117 	ldw	r2,4(r2)
 8240ba0:	e13ffd17 	ldw	r4,-12(fp)
 8240ba4:	200d883a 	mov	r6,r4
 8240ba8:	100b883a 	mov	r5,r2
 8240bac:	1809883a 	mov	r4,r3
 8240bb0:	8202a0c0 	call	8202a0c <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 8240bb4:	e0bffe17 	ldw	r2,-8(fp)
 8240bb8:	10800117 	ldw	r2,4(r2)
 8240bbc:	e0ffff17 	ldw	r3,-4(fp)
 8240bc0:	18c00317 	ldw	r3,12(r3)
 8240bc4:	1809883a 	mov	r4,r3
 8240bc8:	e0ffff17 	ldw	r3,-4(fp)
 8240bcc:	18c00117 	ldw	r3,4(r3)
 8240bd0:	20c7c83a 	sub	r3,r4,r3
 8240bd4:	10c7883a 	add	r3,r2,r3
 8240bd8:	e0bffe17 	ldw	r2,-8(fp)
 8240bdc:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 8240be0:	e0bfff17 	ldw	r2,-4(fp)
 8240be4:	10c00417 	ldw	r3,16(r2)
 8240be8:	e0bffe17 	ldw	r2,-8(fp)
 8240bec:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 8240bf0:	e0bfff17 	ldw	r2,-4(fp)
 8240bf4:	10c00617 	ldw	r3,24(r2)
 8240bf8:	e0bffe17 	ldw	r2,-8(fp)
 8240bfc:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 8240c00:	e0bfff17 	ldw	r2,-4(fp)
 8240c04:	10c00717 	ldw	r3,28(r2)
 8240c08:	e0bffe17 	ldw	r2,-8(fp)
 8240c0c:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 8240c10:	e0bfff17 	ldw	r2,-4(fp)
 8240c14:	10c0080b 	ldhu	r3,32(r2)
 8240c18:	e0bffe17 	ldw	r2,-8(fp)
 8240c1c:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 8240c20:	e0bfff17 	ldw	r2,-4(fp)
 8240c24:	10c00517 	ldw	r3,20(r2)
 8240c28:	e0bffe17 	ldw	r2,-8(fp)
 8240c2c:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 8240c30:	e0bffe17 	ldw	r2,-8(fp)
}
 8240c34:	e037883a 	mov	sp,fp
 8240c38:	dfc00117 	ldw	ra,4(sp)
 8240c3c:	df000017 	ldw	fp,0(sp)
 8240c40:	dec00204 	addi	sp,sp,8
 8240c44:	f800283a 	ret

08240c48 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 8240c48:	defffa04 	addi	sp,sp,-24
 8240c4c:	df000515 	stw	fp,20(sp)
 8240c50:	df000504 	addi	fp,sp,20
 8240c54:	e13fff15 	stw	r4,-4(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 8240c58:	e0bfff17 	ldw	r2,-4(fp)
 8240c5c:	10800317 	ldw	r2,12(r2)
 8240c60:	e0bffc15 	stw	r2,-16(fp)
   dest = pip->ip_dest;
 8240c64:	e0bfff17 	ldw	r2,-4(fp)
 8240c68:	10800417 	ldw	r2,16(r2)
 8240c6c:	e0bffd15 	stw	r2,-12(fp)
   prot = pip->ip_prot;
 8240c70:	e0bfff17 	ldw	r2,-4(fp)
 8240c74:	10800243 	ldbu	r2,9(r2)
 8240c78:	e0bffe05 	stb	r2,-8(fp)
   id = pip->ip_id;
 8240c7c:	e0bfff17 	ldw	r2,-4(fp)
 8240c80:	1080010b 	ldhu	r2,4(r2)
 8240c84:	e0bffe8d 	sth	r2,-6(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8240c88:	d0a0c817 	ldw	r2,-31968(gp)
 8240c8c:	e0bffb15 	stw	r2,-20(fp)
 8240c90:	00001706 	br	8240cf0 <ip_reasm_match_frag_with_ire+0xa8>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8240c94:	e0bffb17 	ldw	r2,-20(fp)
 8240c98:	10c00117 	ldw	r3,4(r2)
 8240c9c:	e0bffc17 	ldw	r2,-16(fp)
 8240ca0:	1880101e 	bne	r3,r2,8240ce4 <ip_reasm_match_frag_with_ire+0x9c>
 8240ca4:	e0bffb17 	ldw	r2,-20(fp)
 8240ca8:	10c00217 	ldw	r3,8(r2)
 8240cac:	e0bffd17 	ldw	r2,-12(fp)
 8240cb0:	18800c1e 	bne	r3,r2,8240ce4 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8240cb4:	e0bffb17 	ldw	r2,-20(fp)
 8240cb8:	10800383 	ldbu	r2,14(r2)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8240cbc:	10c03fcc 	andi	r3,r2,255
 8240cc0:	e0bffe03 	ldbu	r2,-8(fp)
 8240cc4:	1880071e 	bne	r3,r2,8240ce4 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8240cc8:	e0bffb17 	ldw	r2,-20(fp)
 8240ccc:	1080030b 	ldhu	r2,12(r2)
 8240cd0:	10ffffcc 	andi	r3,r2,65535
 8240cd4:	e0bffe8b 	ldhu	r2,-6(fp)
 8240cd8:	1880021e 	bne	r3,r2,8240ce4 <ip_reasm_match_frag_with_ire+0x9c>
         {
         return tmpp; /* we've found a match */
 8240cdc:	e0bffb17 	ldw	r2,-20(fp)
 8240ce0:	00000606 	br	8240cfc <ip_reasm_match_frag_with_ire+0xb4>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8240ce4:	e0bffb17 	ldw	r2,-20(fp)
 8240ce8:	10800017 	ldw	r2,0(r2)
 8240cec:	e0bffb15 	stw	r2,-20(fp)
 8240cf0:	e0bffb17 	ldw	r2,-20(fp)
 8240cf4:	103fe71e 	bne	r2,zero,8240c94 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 8240cf8:	0005883a 	mov	r2,zero
}
 8240cfc:	e037883a 	mov	sp,fp
 8240d00:	df000017 	ldw	fp,0(sp)
 8240d04:	dec00104 	addi	sp,sp,4
 8240d08:	f800283a 	ret

08240d0c <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 8240d0c:	defffc04 	addi	sp,sp,-16
 8240d10:	df000315 	stw	fp,12(sp)
 8240d14:	df000304 	addi	fp,sp,12
 8240d18:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 8240d1c:	e0bfff17 	ldw	r2,-4(fp)
 8240d20:	1080018b 	ldhu	r2,6(r2)
 8240d24:	10bfffcc 	andi	r2,r2,65535
 8240d28:	1004d23a 	srli	r2,r2,8
 8240d2c:	10bfffcc 	andi	r2,r2,65535
 8240d30:	10c03fcc 	andi	r3,r2,255
 8240d34:	e0bfff17 	ldw	r2,-4(fp)
 8240d38:	1080018b 	ldhu	r2,6(r2)
 8240d3c:	10bfffcc 	andi	r2,r2,65535
 8240d40:	1004923a 	slli	r2,r2,8
 8240d44:	10bfffcc 	andi	r2,r2,65535
 8240d48:	1884b03a 	or	r2,r3,r2
 8240d4c:	1088000c 	andi	r2,r2,8192
 8240d50:	1005d37a 	srai	r2,r2,13
 8240d54:	e0bffe0d 	sth	r2,-8(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 8240d58:	e0bfff17 	ldw	r2,-4(fp)
 8240d5c:	1080018b 	ldhu	r2,6(r2)
 8240d60:	10bfffcc 	andi	r2,r2,65535
 8240d64:	1004d23a 	srli	r2,r2,8
 8240d68:	1007883a 	mov	r3,r2
 8240d6c:	e0bfff17 	ldw	r2,-4(fp)
 8240d70:	1080018b 	ldhu	r2,6(r2)
 8240d74:	10bfffcc 	andi	r2,r2,65535
 8240d78:	1004923a 	slli	r2,r2,8
 8240d7c:	1884b03a 	or	r2,r3,r2
 8240d80:	1087ffcc 	andi	r2,r2,8191
 8240d84:	e0bffe8d 	sth	r2,-6(fp)

  if (mf == 0)
 8240d88:	e0bffe0b 	ldhu	r2,-8(fp)
 8240d8c:	1000071e 	bne	r2,zero,8240dac <ip_reasm_determine_type_of_frag+0xa0>
     {
     if (foff == 0) {rc = IP_CP;}
 8240d90:	e0bffe8b 	ldhu	r2,-6(fp)
 8240d94:	1000021e 	bne	r2,zero,8240da0 <ip_reasm_determine_type_of_frag+0x94>
 8240d98:	e03ffd15 	stw	zero,-12(fp)
 8240d9c:	00000a06 	br	8240dc8 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_LF;}
 8240da0:	00800144 	movi	r2,5
 8240da4:	e0bffd15 	stw	r2,-12(fp)
 8240da8:	00000706 	br	8240dc8 <ip_reasm_determine_type_of_frag+0xbc>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 8240dac:	e0bffe8b 	ldhu	r2,-6(fp)
 8240db0:	1000031e 	bne	r2,zero,8240dc0 <ip_reasm_determine_type_of_frag+0xb4>
 8240db4:	00800044 	movi	r2,1
 8240db8:	e0bffd15 	stw	r2,-12(fp)
 8240dbc:	00000206 	br	8240dc8 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_MF;}
 8240dc0:	008000c4 	movi	r2,3
 8240dc4:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 8240dc8:	e0bffd17 	ldw	r2,-12(fp)
}
 8240dcc:	e037883a 	mov	sp,fp
 8240dd0:	df000017 	ldw	fp,0(sp)
 8240dd4:	dec00104 	addi	sp,sp,4
 8240dd8:	f800283a 	ret

08240ddc <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 8240ddc:	defffe04 	addi	sp,sp,-8
 8240de0:	df000115 	stw	fp,4(sp)
 8240de4:	df000104 	addi	fp,sp,4
 8240de8:	2005883a 	mov	r2,r4
 8240dec:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8240df0:	d0a0c717 	ldw	r2,-31972(gp)
 8240df4:	00c001b4 	movhi	r3,6
 8240df8:	1880072e 	bgeu	r3,r2,8240e18 <ip_reasm_check_mem_useage+0x3c>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8240dfc:	008209b4 	movhi	r2,2086
 8240e00:	10b90c04 	addi	r2,r2,-7120
 8240e04:	10800217 	ldw	r2,8(r2)
 8240e08:	10c00044 	addi	r3,r2,1
 8240e0c:	008209b4 	movhi	r2,2086
 8240e10:	10b90c04 	addi	r2,r2,-7120
 8240e14:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8240e18:	d0e0c717 	ldw	r3,-31972(gp)
 8240e1c:	008001b4 	movhi	r2,6
 8240e20:	18800526 	beq	r3,r2,8240e38 <ip_reasm_check_mem_useage+0x5c>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
 8240e24:	e0ffff0b 	ldhu	r3,-4(fp)
 8240e28:	d0a0c717 	ldw	r2,-31972(gp)
 8240e2c:	1885883a 	add	r2,r3,r2
      ++ire_stats.bad_max_mem;
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8240e30:	00c001b4 	movhi	r3,6
 8240e34:	1880092e 	bgeu	r3,r2,8240e5c <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 8240e38:	008209b4 	movhi	r2,2086
 8240e3c:	10b90c04 	addi	r2,r2,-7120
 8240e40:	10800317 	ldw	r2,12(r2)
 8240e44:	10c00044 	addi	r3,r2,1
 8240e48:	008209b4 	movhi	r2,2086
 8240e4c:	10b90c04 	addi	r2,r2,-7120
 8240e50:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 8240e54:	00bffa84 	movi	r2,-22
 8240e58:	00000106 	br	8240e60 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 8240e5c:	0005883a 	mov	r2,zero
}
 8240e60:	e037883a 	mov	sp,fp
 8240e64:	df000017 	ldw	fp,0(sp)
 8240e68:	dec00104 	addi	sp,sp,4
 8240e6c:	f800283a 	ret

08240e70 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 8240e70:	defffe04 	addi	sp,sp,-8
 8240e74:	df000115 	stw	fp,4(sp)
 8240e78:	df000104 	addi	fp,sp,4
 8240e7c:	2005883a 	mov	r2,r4
 8240e80:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8240e84:	d0a0c717 	ldw	r2,-31972(gp)
 8240e88:	00c001b4 	movhi	r3,6
 8240e8c:	1880092e 	bgeu	r3,r2,8240eb4 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8240e90:	008209b4 	movhi	r2,2086
 8240e94:	10b90c04 	addi	r2,r2,-7120
 8240e98:	10800217 	ldw	r2,8(r2)
 8240e9c:	10c00044 	addi	r3,r2,1
 8240ea0:	008209b4 	movhi	r2,2086
 8240ea4:	10b90c04 	addi	r2,r2,-7120
 8240ea8:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 8240eac:	00bffa84 	movi	r2,-22
 8240eb0:	00001306 	br	8240f00 <ip_reasm_incr_mem_useage+0x90>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 8240eb4:	e0ffff0b 	ldhu	r3,-4(fp)
 8240eb8:	d0a0c717 	ldw	r2,-31972(gp)
 8240ebc:	1885883a 	add	r2,r3,r2
 8240ec0:	00c001b4 	movhi	r3,6
 8240ec4:	1880092e 	bgeu	r3,r2,8240eec <ip_reasm_incr_mem_useage+0x7c>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 8240ec8:	008209b4 	movhi	r2,2086
 8240ecc:	10b90c04 	addi	r2,r2,-7120
 8240ed0:	10800417 	ldw	r2,16(r2)
 8240ed4:	10c00044 	addi	r3,r2,1
 8240ed8:	008209b4 	movhi	r2,2086
 8240edc:	10b90c04 	addi	r2,r2,-7120
 8240ee0:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 8240ee4:	00bffa84 	movi	r2,-22
 8240ee8:	00000506 	br	8240f00 <ip_reasm_incr_mem_useage+0x90>
   }

   ipr_curr_mem += increment;
 8240eec:	e0ffff0b 	ldhu	r3,-4(fp)
 8240ef0:	d0a0c717 	ldw	r2,-31972(gp)
 8240ef4:	1885883a 	add	r2,r3,r2
 8240ef8:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 8240efc:	0005883a 	mov	r2,zero
}
 8240f00:	e037883a 	mov	sp,fp
 8240f04:	df000017 	ldw	fp,0(sp)
 8240f08:	dec00104 	addi	sp,sp,4
 8240f0c:	f800283a 	ret

08240f10 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 8240f10:	defffe04 	addi	sp,sp,-8
 8240f14:	df000115 	stw	fp,4(sp)
 8240f18:	df000104 	addi	fp,sp,4
 8240f1c:	2005883a 	mov	r2,r4
 8240f20:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8240f24:	d0a0c717 	ldw	r2,-31972(gp)
 8240f28:	00c001b4 	movhi	r3,6
 8240f2c:	1880092e 	bgeu	r3,r2,8240f54 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8240f30:	008209b4 	movhi	r2,2086
 8240f34:	10b90c04 	addi	r2,r2,-7120
 8240f38:	10800217 	ldw	r2,8(r2)
 8240f3c:	10c00044 	addi	r3,r2,1
 8240f40:	008209b4 	movhi	r2,2086
 8240f44:	10b90c04 	addi	r2,r2,-7120
 8240f48:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 8240f4c:	00bffa84 	movi	r2,-22
 8240f50:	00001106 	br	8240f98 <ip_reasm_decr_mem_useage+0x88>
   }
   if (ipr_curr_mem < decrement)
 8240f54:	e0bfff0b 	ldhu	r2,-4(fp)
 8240f58:	d0e0c717 	ldw	r3,-31972(gp)
 8240f5c:	1880092e 	bgeu	r3,r2,8240f84 <ip_reasm_decr_mem_useage+0x74>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 8240f60:	008209b4 	movhi	r2,2086
 8240f64:	10b90c04 	addi	r2,r2,-7120
 8240f68:	10800517 	ldw	r2,20(r2)
 8240f6c:	10c00044 	addi	r3,r2,1
 8240f70:	008209b4 	movhi	r2,2086
 8240f74:	10b90c04 	addi	r2,r2,-7120
 8240f78:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 8240f7c:	00bffa84 	movi	r2,-22
 8240f80:	00000506 	br	8240f98 <ip_reasm_decr_mem_useage+0x88>
   }

   ipr_curr_mem -= decrement;
 8240f84:	d0e0c717 	ldw	r3,-31972(gp)
 8240f88:	e0bfff0b 	ldhu	r2,-4(fp)
 8240f8c:	1885c83a 	sub	r2,r3,r2
 8240f90:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 8240f94:	0005883a 	mov	r2,zero
}
 8240f98:	e037883a 	mov	sp,fp
 8240f9c:	df000017 	ldw	fp,0(sp)
 8240fa0:	dec00104 	addi	sp,sp,4
 8240fa4:	f800283a 	ret

08240fa8 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 8240fa8:	defff704 	addi	sp,sp,-36
 8240fac:	dfc00815 	stw	ra,32(sp)
 8240fb0:	df000715 	stw	fp,28(sp)
 8240fb4:	df000704 	addi	fp,sp,28
 8240fb8:	e13fff15 	stw	r4,-4(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 8240fbc:	e0bfff17 	ldw	r2,-4(fp)
 8240fc0:	10800217 	ldw	r2,8(r2)
 8240fc4:	10802204 	addi	r2,r2,136
 8240fc8:	10bfffcc 	andi	r2,r2,65535
 8240fcc:	1009883a 	mov	r4,r2
 8240fd0:	8240ddc0 	call	8240ddc <ip_reasm_check_mem_useage>
 8240fd4:	e0bff915 	stw	r2,-28(fp)
 8240fd8:	e0bff917 	ldw	r2,-28(fp)
 8240fdc:	10000f26 	beq	r2,zero,824101c <ip_reasm_process_first_fragment+0x74>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8240fe0:	01000084 	movi	r4,2
 8240fe4:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free (p);
 8240fe8:	e13fff17 	ldw	r4,-4(fp)
 8240fec:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8240ff0:	01000084 	movi	r4,2
 8240ff4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8240ff8:	008209b4 	movhi	r2,2086
 8240ffc:	10b8f804 	addi	r2,r2,-7200
 8241000:	10800f17 	ldw	r2,60(r2)
 8241004:	10c00044 	addi	r3,r2,1
 8241008:	008209b4 	movhi	r2,2086
 824100c:	10b8f804 	addi	r2,r2,-7200
 8241010:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241014:	e0bff917 	ldw	r2,-28(fp)
 8241018:	00008c06 	br	824124c <ip_reasm_process_first_fragment+0x2a4>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 824101c:	01002204 	movi	r4,136
 8241020:	822dda00 	call	822dda0 <npalloc>
 8241024:	e0bffa15 	stw	r2,-24(fp)
   if (irep == 0) 
 8241028:	e0bffa17 	ldw	r2,-24(fp)
 824102c:	10000f1e 	bne	r2,zero,824106c <ip_reasm_process_first_fragment+0xc4>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241030:	01000084 	movi	r4,2
 8241034:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241038:	e13fff17 	ldw	r4,-4(fp)
 824103c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241040:	01000084 	movi	r4,2
 8241044:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241048:	008209b4 	movhi	r2,2086
 824104c:	10b8f804 	addi	r2,r2,-7200
 8241050:	10800f17 	ldw	r2,60(r2)
 8241054:	10c00044 	addi	r3,r2,1
 8241058:	008209b4 	movhi	r2,2086
 824105c:	10b8f804 	addi	r2,r2,-7200
 8241060:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 8241064:	00bffa84 	movi	r2,-22
 8241068:	00007806 	br	824124c <ip_reasm_process_first_fragment+0x2a4>
   }

   pip = ip_head(p);
 824106c:	e0bfff17 	ldw	r2,-4(fp)
 8241070:	10800317 	ldw	r2,12(r2)
 8241074:	e0bffb15 	stw	r2,-20(fp)
   iphlen = ip_hlen(pip);
 8241078:	e0bffb17 	ldw	r2,-20(fp)
 824107c:	10800003 	ldbu	r2,0(r2)
 8241080:	108003cc 	andi	r2,r2,15
 8241084:	1085883a 	add	r2,r2,r2
 8241088:	1085883a 	add	r2,r2,r2
 824108c:	e0bffc05 	stb	r2,-16(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 8241090:	e13ffb17 	ldw	r4,-20(fp)
 8241094:	8240d0c0 	call	8240d0c <ip_reasm_determine_type_of_frag>
 8241098:	e0bffd15 	stw	r2,-12(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 824109c:	e0bffb17 	ldw	r2,-20(fp)
 82410a0:	1080018b 	ldhu	r2,6(r2)
 82410a4:	10bfffcc 	andi	r2,r2,65535
 82410a8:	1004d23a 	srli	r2,r2,8
 82410ac:	10bfffcc 	andi	r2,r2,65535
 82410b0:	10c03fcc 	andi	r3,r2,255
 82410b4:	e0bffb17 	ldw	r2,-20(fp)
 82410b8:	1080018b 	ldhu	r2,6(r2)
 82410bc:	10bfffcc 	andi	r2,r2,65535
 82410c0:	1004923a 	slli	r2,r2,8
 82410c4:	10bfffcc 	andi	r2,r2,65535
 82410c8:	1884b03a 	or	r2,r3,r2
 82410cc:	100490fa 	slli	r2,r2,3
 82410d0:	e0bffe0d 	sth	r2,-8(fp)
   total_len = ntohs(pip->ip_len);
 82410d4:	e0bffb17 	ldw	r2,-20(fp)
 82410d8:	1080008b 	ldhu	r2,2(r2)
 82410dc:	10bfffcc 	andi	r2,r2,65535
 82410e0:	1004d23a 	srli	r2,r2,8
 82410e4:	1007883a 	mov	r3,r2
 82410e8:	e0bffb17 	ldw	r2,-20(fp)
 82410ec:	1080008b 	ldhu	r2,2(r2)
 82410f0:	10bfffcc 	andi	r2,r2,65535
 82410f4:	1004923a 	slli	r2,r2,8
 82410f8:	1884b03a 	or	r2,r3,r2
 82410fc:	e0bffe8d 	sth	r2,-6(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 8241100:	e0bffb17 	ldw	r2,-20(fp)
 8241104:	10c00317 	ldw	r3,12(r2)
 8241108:	e0bffa17 	ldw	r2,-24(fp)
 824110c:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 8241110:	e0bffb17 	ldw	r2,-20(fp)
 8241114:	10c00417 	ldw	r3,16(r2)
 8241118:	e0bffa17 	ldw	r2,-24(fp)
 824111c:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 8241120:	e0bffb17 	ldw	r2,-20(fp)
 8241124:	10c00243 	ldbu	r3,9(r2)
 8241128:	e0bffa17 	ldw	r2,-24(fp)
 824112c:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 8241130:	e0bffb17 	ldw	r2,-20(fp)
 8241134:	10c0010b 	ldhu	r3,4(r2)
 8241138:	e0bffa17 	ldw	r2,-24(fp)
 824113c:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 8241140:	e0bffd17 	ldw	r2,-12(fp)
 8241144:	10800158 	cmpnei	r2,r2,5
 8241148:	10000a1e 	bne	r2,zero,8241174 <ip_reasm_process_first_fragment+0x1cc>
      {
      irep->length = frag_offset + (total_len - iphlen);
 824114c:	e0bffc03 	ldbu	r2,-16(fp)
 8241150:	e0fffe8b 	ldhu	r3,-6(fp)
 8241154:	1885c83a 	sub	r2,r3,r2
 8241158:	1007883a 	mov	r3,r2
 824115c:	e0bffe0b 	ldhu	r2,-8(fp)
 8241160:	1885883a 	add	r2,r3,r2
 8241164:	1007883a 	mov	r3,r2
 8241168:	e0bffa17 	ldw	r2,-24(fp)
 824116c:	10c0040d 	sth	r3,16(r2)
 8241170:	00000a06 	br	824119c <ip_reasm_process_first_fragment+0x1f4>
      }
   else if (ftype == IP_FF)
 8241174:	e0bffd17 	ldw	r2,-12(fp)
 8241178:	10800058 	cmpnei	r2,r2,1
 824117c:	1000071e 	bne	r2,zero,824119c <ip_reasm_process_first_fragment+0x1f4>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 8241180:	e0bfff17 	ldw	r2,-4(fp)
 8241184:	10c00117 	ldw	r3,4(r2)
 8241188:	e0bffa17 	ldw	r2,-24(fp)
 824118c:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241190:	e0bffa17 	ldw	r2,-24(fp)
 8241194:	e0fffb17 	ldw	r3,-20(fp)
 8241198:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 824119c:	e0bffc03 	ldbu	r2,-16(fp)
 82411a0:	e0fffe8b 	ldhu	r3,-6(fp)
 82411a4:	1885c83a 	sub	r2,r3,r2
 82411a8:	1007883a 	mov	r3,r2
 82411ac:	e0bffa17 	ldw	r2,-24(fp)
 82411b0:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 82411b4:	e0bffa17 	ldw	r2,-24(fp)
 82411b8:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 82411bc:	e0bffa17 	ldw	r2,-24(fp)
 82411c0:	10802103 	ldbu	r2,132(r2)
 82411c4:	10800054 	ori	r2,r2,1
 82411c8:	1007883a 	mov	r3,r2
 82411cc:	e0bffa17 	ldw	r2,-24(fp)
 82411d0:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 82411d4:	e0bffa17 	ldw	r2,-24(fp)
 82411d8:	e0ffff17 	ldw	r3,-4(fp)
 82411dc:	10c00715 	stw	r3,28(r2)
   irep->rfq.frag_offset[0] = frag_offset;
 82411e0:	e0bffa17 	ldw	r2,-24(fp)
 82411e4:	e0fffe0b 	ldhu	r3,-8(fp)
 82411e8:	10c0170d 	sth	r3,92(r2)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 82411ec:	e0bfff17 	ldw	r2,-4(fp)
 82411f0:	10c00317 	ldw	r3,12(r2)
 82411f4:	e0bffc03 	ldbu	r2,-16(fp)
 82411f8:	1887883a 	add	r3,r3,r2
 82411fc:	e0bfff17 	ldw	r2,-4(fp)
 8241200:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 8241204:	e0bfff17 	ldw	r2,-4(fp)
 8241208:	10c00417 	ldw	r3,16(r2)
 824120c:	e0bffc03 	ldbu	r2,-16(fp)
 8241210:	1887c83a 	sub	r3,r3,r2
 8241214:	e0bfff17 	ldw	r2,-4(fp)
 8241218:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 824121c:	d0e0c817 	ldw	r3,-31968(gp)
 8241220:	e0bffa17 	ldw	r2,-24(fp)
 8241224:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 8241228:	e0bffa17 	ldw	r2,-24(fp)
 824122c:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 8241230:	e0bfff17 	ldw	r2,-4(fp)
 8241234:	10800217 	ldw	r2,8(r2)
 8241238:	10802204 	addi	r2,r2,136
 824123c:	10bfffcc 	andi	r2,r2,65535
 8241240:	1009883a 	mov	r4,r2
 8241244:	8240e700 	call	8240e70 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 8241248:	0005883a 	mov	r2,zero
}
 824124c:	e037883a 	mov	sp,fp
 8241250:	dfc00117 	ldw	ra,4(sp)
 8241254:	df000017 	ldw	fp,0(sp)
 8241258:	dec00204 	addi	sp,sp,8
 824125c:	f800283a 	ret

08241260 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 8241260:	defff904 	addi	sp,sp,-28
 8241264:	dfc00615 	stw	ra,24(sp)
 8241268:	df000515 	stw	fp,20(sp)
 824126c:	df000504 	addi	fp,sp,20
 8241270:	e13fff15 	stw	r4,-4(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 8241274:	e0bfff17 	ldw	r2,-4(fp)
 8241278:	10800317 	ldw	r2,12(r2)
 824127c:	e0bffb15 	stw	r2,-20(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 8241280:	e13ffb17 	ldw	r4,-20(fp)
 8241284:	8240c480 	call	8240c48 <ip_reasm_match_frag_with_ire>
 8241288:	e0bffc15 	stw	r2,-16(fp)

   if (!irep)
 824128c:	e0bffc17 	ldw	r2,-16(fp)
 8241290:	1000071e 	bne	r2,zero,82412b0 <ip_reassm+0x50>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 8241294:	e13fff17 	ldw	r4,-4(fp)
 8241298:	8240fa80 	call	8240fa8 <ip_reasm_process_first_fragment>
 824129c:	e0bffd15 	stw	r2,-12(fp)
 82412a0:	e0bffd17 	ldw	r2,-12(fp)
 82412a4:	10000a26 	beq	r2,zero,82412d0 <ip_reassm+0x70>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 82412a8:	e0bffd17 	ldw	r2,-12(fp)
 82412ac:	00000906 	br	82412d4 <ip_reassm+0x74>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 82412b0:	e17ffc17 	ldw	r5,-16(fp)
 82412b4:	e13fff17 	ldw	r4,-4(fp)
 82412b8:	824184c0 	call	824184c <ip_reasm_process_subsequent_fragments>
 82412bc:	e0bffe15 	stw	r2,-8(fp)
 82412c0:	e0bffe17 	ldw	r2,-8(fp)
 82412c4:	10000226 	beq	r2,zero,82412d0 <ip_reassm+0x70>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 82412c8:	e0bffe17 	ldw	r2,-8(fp)
 82412cc:	00000106 	br	82412d4 <ip_reassm+0x74>
      }
   }

   return IPREASM_OK;
 82412d0:	0005883a 	mov	r2,zero
}
 82412d4:	e037883a 	mov	sp,fp
 82412d8:	dfc00117 	ldw	ra,4(sp)
 82412dc:	df000017 	ldw	fp,0(sp)
 82412e0:	dec00204 	addi	sp,sp,8
 82412e4:	f800283a 	ret

082412e8 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 82412e8:	defff204 	addi	sp,sp,-56
 82412ec:	dfc00d15 	stw	ra,52(sp)
 82412f0:	df000c15 	stw	fp,48(sp)
 82412f4:	df000c04 	addi	fp,sp,48
 82412f8:	e13ffc15 	stw	r4,-16(fp)
 82412fc:	e17ffd15 	stw	r5,-12(fp)
 8241300:	e1bffe15 	stw	r6,-8(fp)
 8241304:	e1ffff15 	stw	r7,-4(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241308:	e13ffd17 	ldw	r4,-12(fp)
 824130c:	8241d7c0 	call	8241d7c <ip_reasm_find_ire>
 8241310:	10803fcc 	andi	r2,r2,255
 8241314:	10800060 	cmpeqi	r2,r2,1
 8241318:	10000f1e 	bne	r2,zero,8241358 <ip_reasm_compute_overlap+0x70>
      {
      ++ire_stats.bad_irep;
 824131c:	008209b4 	movhi	r2,2086
 8241320:	10b90c04 	addi	r2,r2,-7120
 8241324:	10800017 	ldw	r2,0(r2)
 8241328:	10c00044 	addi	r3,r2,1
 824132c:	008209b4 	movhi	r2,2086
 8241330:	10b90c04 	addi	r2,r2,-7120
 8241334:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241338:	01000084 	movi	r4,2
 824133c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241340:	e13ffc17 	ldw	r4,-16(fp)
 8241344:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241348:	01000084 	movi	r4,2
 824134c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 8241350:	00800044 	movi	r2,1
 8241354:	00013806 	br	8241838 <ip_reasm_compute_overlap+0x550>
      }

   jrip = ip_head(p);
 8241358:	e0bffc17 	ldw	r2,-16(fp)
 824135c:	10800317 	ldw	r2,12(r2)
 8241360:	e0bff715 	stw	r2,-36(fp)
   iphlen = ip_hlen (jrip);
 8241364:	e0bff717 	ldw	r2,-36(fp)
 8241368:	10800003 	ldbu	r2,0(r2)
 824136c:	108003cc 	andi	r2,r2,15
 8241370:	1085883a 	add	r2,r2,r2
 8241374:	1085883a 	add	r2,r2,r2
 8241378:	e0bff805 	stb	r2,-32(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 824137c:	e0bff717 	ldw	r2,-36(fp)
 8241380:	1080018b 	ldhu	r2,6(r2)
 8241384:	10bfffcc 	andi	r2,r2,65535
 8241388:	1004d23a 	srli	r2,r2,8
 824138c:	10bfffcc 	andi	r2,r2,65535
 8241390:	10c03fcc 	andi	r3,r2,255
 8241394:	e0bff717 	ldw	r2,-36(fp)
 8241398:	1080018b 	ldhu	r2,6(r2)
 824139c:	10bfffcc 	andi	r2,r2,65535
 82413a0:	1004923a 	slli	r2,r2,8
 82413a4:	10bfffcc 	andi	r2,r2,65535
 82413a8:	1884b03a 	or	r2,r3,r2
 82413ac:	100490fa 	slli	r2,r2,3
 82413b0:	e0bff50d 	sth	r2,-44(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 82413b4:	e0bff717 	ldw	r2,-36(fp)
 82413b8:	1080008b 	ldhu	r2,2(r2)
 82413bc:	10bfffcc 	andi	r2,r2,65535
 82413c0:	1004d23a 	srli	r2,r2,8
 82413c4:	1007883a 	mov	r3,r2
 82413c8:	e0bff717 	ldw	r2,-36(fp)
 82413cc:	1080008b 	ldhu	r2,2(r2)
 82413d0:	10bfffcc 	andi	r2,r2,65535
 82413d4:	1004923a 	slli	r2,r2,8
 82413d8:	1884b03a 	or	r2,r3,r2
 82413dc:	1007883a 	mov	r3,r2
 82413e0:	e0bff803 	ldbu	r2,-32(fp)
 82413e4:	1885c83a 	sub	r2,r3,r2
 82413e8:	1007883a 	mov	r3,r2
 82413ec:	e0bff50b 	ldhu	r2,-44(fp)
 82413f0:	1885883a 	add	r2,r3,r2
 82413f4:	10bfffc4 	addi	r2,r2,-1
 82413f8:	e0bff58d 	sth	r2,-42(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 82413fc:	e0bffc17 	ldw	r2,-16(fp)
 8241400:	10c00317 	ldw	r3,12(r2)
 8241404:	e0bff803 	ldbu	r2,-32(fp)
 8241408:	1887883a 	add	r3,r3,r2
 824140c:	e0bffc17 	ldw	r2,-16(fp)
 8241410:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 8241414:	e0bffc17 	ldw	r2,-16(fp)
 8241418:	10c00417 	ldw	r3,16(r2)
 824141c:	e0bff803 	ldbu	r2,-32(fp)
 8241420:	1887c83a 	sub	r3,r3,r2
 8241424:	e0bffc17 	ldw	r2,-16(fp)
 8241428:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 824142c:	e0800217 	ldw	r2,8(fp)
 8241430:	e0fff50b 	ldhu	r3,-44(fp)
 8241434:	10c0000d 	sth	r3,0(r2)
   *indexp = INVALID_FRAG_INDEX;
 8241438:	e0bffe17 	ldw	r2,-8(fp)
 824143c:	00c00404 	movi	r3,16
 8241440:	10c0000d 	sth	r3,0(r2)
   *last_rfqpp = 0;
 8241444:	e0bfff17 	ldw	r2,-4(fp)
 8241448:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 824144c:	e0800317 	ldw	r2,12(fp)
 8241450:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 8241454:	e0bffd17 	ldw	r2,-12(fp)
 8241458:	10800604 	addi	r2,r2,24
 824145c:	e0bff415 	stw	r2,-48(fp)

   while (rfqp)
 8241460:	0000ef06 	br	8241820 <ip_reasm_compute_overlap+0x538>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241464:	e03ff60d 	sth	zero,-40(fp)
 8241468:	0000dd06 	br	82417e0 <ip_reasm_compute_overlap+0x4f8>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 824146c:	e0bff60b 	ldhu	r2,-40(fp)
 8241470:	e0fff417 	ldw	r3,-48(fp)
 8241474:	10800044 	addi	r2,r2,1
 8241478:	1085883a 	add	r2,r2,r2
 824147c:	1085883a 	add	r2,r2,r2
 8241480:	1885883a 	add	r2,r3,r2
 8241484:	10800017 	ldw	r2,0(r2)
 8241488:	e0bff915 	stw	r2,-28(fp)
 824148c:	e0bff917 	ldw	r2,-28(fp)
 8241490:	1000c026 	beq	r2,zero,8241794 <ip_reasm_compute_overlap+0x4ac>
            {
            currstart = rfqp->frag_offset[i];
 8241494:	e0bff60b 	ldhu	r2,-40(fp)
 8241498:	e0fff417 	ldw	r3,-48(fp)
 824149c:	10800884 	addi	r2,r2,34
 82414a0:	1085883a 	add	r2,r2,r2
 82414a4:	1885883a 	add	r2,r3,r2
 82414a8:	1080000b 	ldhu	r2,0(r2)
 82414ac:	e0bffa0d 	sth	r2,-24(fp)
            currend = currstart + currpkt->nb_plen - 1;
 82414b0:	e0bff917 	ldw	r2,-28(fp)
 82414b4:	10800417 	ldw	r2,16(r2)
 82414b8:	1007883a 	mov	r3,r2
 82414bc:	e0bffa0b 	ldhu	r2,-24(fp)
 82414c0:	1885883a 	add	r2,r3,r2
 82414c4:	10bfffc4 	addi	r2,r2,-1
 82414c8:	e0bffa8d 	sth	r2,-22(fp)

            if (currstart < jrstart)
 82414cc:	e0fffa0b 	ldhu	r3,-24(fp)
 82414d0:	e0bff50b 	ldhu	r2,-44(fp)
 82414d4:	18802b2e 	bgeu	r3,r2,8241584 <ip_reasm_compute_overlap+0x29c>
               {
               if (currend < jrend) /* cases A1 and A2 */
 82414d8:	e0fffa8b 	ldhu	r3,-22(fp)
 82414dc:	e0bff58b 	ldhu	r2,-42(fp)
 82414e0:	1880202e 	bgeu	r3,r2,8241564 <ip_reasm_compute_overlap+0x27c>
                  {
                  if (currend < jrstart) /* A1 */
 82414e4:	e0fffa8b 	ldhu	r3,-22(fp)
 82414e8:	e0bff50b 	ldhu	r2,-44(fp)
 82414ec:	1880b936 	bltu	r3,r2,82417d4 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 82414f0:	e0fffa8b 	ldhu	r3,-22(fp)
 82414f4:	e0bff50b 	ldhu	r2,-44(fp)
 82414f8:	1885c83a 	sub	r2,r3,r2
 82414fc:	10800044 	addi	r2,r2,1
 8241500:	e0bffb0d 	sth	r2,-20(fp)
                     p->nb_prot += drop_len;
 8241504:	e0bffc17 	ldw	r2,-16(fp)
 8241508:	10c00317 	ldw	r3,12(r2)
 824150c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241510:	1887883a 	add	r3,r3,r2
 8241514:	e0bffc17 	ldw	r2,-16(fp)
 8241518:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 824151c:	e0bffc17 	ldw	r2,-16(fp)
 8241520:	10c00417 	ldw	r3,16(r2)
 8241524:	e0bffb0b 	ldhu	r2,-20(fp)
 8241528:	1887c83a 	sub	r3,r3,r2
 824152c:	e0bffc17 	ldw	r2,-16(fp)
 8241530:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 8241534:	e0fff50b 	ldhu	r3,-44(fp)
 8241538:	e0bffb0b 	ldhu	r2,-20(fp)
 824153c:	1885883a 	add	r2,r3,r2
 8241540:	e0bff50d 	sth	r2,-44(fp)
                     jrend = jrstart + p->nb_plen - 1;
 8241544:	e0bffc17 	ldw	r2,-16(fp)
 8241548:	10800417 	ldw	r2,16(r2)
 824154c:	1007883a 	mov	r3,r2
 8241550:	e0bff50b 	ldhu	r2,-44(fp)
 8241554:	1885883a 	add	r2,r3,r2
 8241558:	10bfffc4 	addi	r2,r2,-1
 824155c:	e0bff58d 	sth	r2,-42(fp)
 8241560:	00009c06 	br	82417d4 <ip_reasm_compute_overlap+0x4ec>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241564:	01000084 	movi	r4,2
 8241568:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
                  pk_free (p);
 824156c:	e13ffc17 	ldw	r4,-16(fp)
 8241570:	822c9700 	call	822c970 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241574:	01000084 	movi	r4,2
 8241578:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 824157c:	0005883a 	mov	r2,zero
 8241580:	0000ad06 	br	8241838 <ip_reasm_compute_overlap+0x550>
                  }
               }
            else if (currstart > jrstart)
 8241584:	e0bffa0b 	ldhu	r2,-24(fp)
 8241588:	e0fff50b 	ldhu	r3,-44(fp)
 824158c:	18804e2e 	bgeu	r3,r2,82416c8 <ip_reasm_compute_overlap+0x3e0>
               {
               if (currend > jrend) /* cases B1 and B2 */
 8241590:	e0bffa8b 	ldhu	r2,-22(fp)
 8241594:	e0fff58b 	ldhu	r3,-42(fp)
 8241598:	1880112e 	bgeu	r3,r2,82415e0 <ip_reasm_compute_overlap+0x2f8>
                  {
                  if (currstart > jrend) /* B1 */
 824159c:	e0bffa0b 	ldhu	r2,-24(fp)
 82415a0:	e0fff58b 	ldhu	r3,-42(fp)
 82415a4:	18808b36 	bltu	r3,r2,82417d4 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 82415a8:	e0fffa0b 	ldhu	r3,-24(fp)
 82415ac:	e0bff50b 	ldhu	r2,-44(fp)
 82415b0:	1885c83a 	sub	r2,r3,r2
 82415b4:	1007883a 	mov	r3,r2
 82415b8:	e0bffc17 	ldw	r2,-16(fp)
 82415bc:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 82415c0:	e0bffc17 	ldw	r2,-16(fp)
 82415c4:	10800417 	ldw	r2,16(r2)
 82415c8:	1007883a 	mov	r3,r2
 82415cc:	e0bff50b 	ldhu	r2,-44(fp)
 82415d0:	1885883a 	add	r2,r3,r2
 82415d4:	10bfffc4 	addi	r2,r2,-1
 82415d8:	e0bff58d 	sth	r2,-42(fp)
 82415dc:	00007d06 	br	82417d4 <ip_reasm_compute_overlap+0x4ec>
                     }
                  }
               else if (currend == jrend) /* F1 */
 82415e0:	e0fffa8b 	ldhu	r3,-22(fp)
 82415e4:	e0bff58b 	ldhu	r2,-42(fp)
 82415e8:	18800e1e 	bne	r3,r2,8241624 <ip_reasm_compute_overlap+0x33c>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 82415ec:	e0fffa0b 	ldhu	r3,-24(fp)
 82415f0:	e0bff50b 	ldhu	r2,-44(fp)
 82415f4:	1885c83a 	sub	r2,r3,r2
 82415f8:	1007883a 	mov	r3,r2
 82415fc:	e0bffc17 	ldw	r2,-16(fp)
 8241600:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 8241604:	e0bffc17 	ldw	r2,-16(fp)
 8241608:	10800417 	ldw	r2,16(r2)
 824160c:	1007883a 	mov	r3,r2
 8241610:	e0bff50b 	ldhu	r2,-44(fp)
 8241614:	1885883a 	add	r2,r3,r2
 8241618:	10bfffc4 	addi	r2,r2,-1
 824161c:	e0bff58d 	sth	r2,-42(fp)
 8241620:	00006c06 	br	82417d4 <ip_reasm_compute_overlap+0x4ec>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 8241624:	e0bff917 	ldw	r2,-28(fp)
 8241628:	10800217 	ldw	r2,8(r2)
 824162c:	10bfffcc 	andi	r2,r2,65535
 8241630:	1009883a 	mov	r4,r2
 8241634:	8240f100 	call	8240f10 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 8241638:	e0bffd17 	ldw	r2,-12(fp)
 824163c:	1080048b 	ldhu	r2,18(r2)
 8241640:	e0fff917 	ldw	r3,-28(fp)
 8241644:	18c00417 	ldw	r3,16(r3)
 8241648:	10c5c83a 	sub	r2,r2,r3
 824164c:	1007883a 	mov	r3,r2
 8241650:	e0bffd17 	ldw	r2,-12(fp)
 8241654:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241658:	01000084 	movi	r4,2
 824165c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 8241660:	e13ff917 	ldw	r4,-28(fp)
 8241664:	822c9700 	call	822c970 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241668:	01000084 	movi	r4,2
 824166c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 8241670:	e0bff60b 	ldhu	r2,-40(fp)
 8241674:	e0fff417 	ldw	r3,-48(fp)
 8241678:	10800044 	addi	r2,r2,1
 824167c:	1085883a 	add	r2,r2,r2
 8241680:	1085883a 	add	r2,r2,r2
 8241684:	1885883a 	add	r2,r3,r2
 8241688:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 824168c:	e0bffe17 	ldw	r2,-8(fp)
 8241690:	1080000b 	ldhu	r2,0(r2)
 8241694:	10bfffcc 	andi	r2,r2,65535
 8241698:	10800418 	cmpnei	r2,r2,16
 824169c:	1000061e 	bne	r2,zero,82416b8 <ip_reasm_compute_overlap+0x3d0>
                     {
                     *indexp = i;
 82416a0:	e0bffe17 	ldw	r2,-8(fp)
 82416a4:	e0fff60b 	ldhu	r3,-40(fp)
 82416a8:	10c0000d 	sth	r3,0(r2)
                     *last_rfqpp = rfqp;
 82416ac:	e0bfff17 	ldw	r2,-4(fp)
 82416b0:	e0fff417 	ldw	r3,-48(fp)
 82416b4:	10c00015 	stw	r3,0(r2)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 82416b8:	e0800317 	ldw	r2,12(fp)
 82416bc:	00c00044 	movi	r3,1
 82416c0:	10c00005 	stb	r3,0(r2)
 82416c4:	00004306 	br	82417d4 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 82416c8:	e0fffa8b 	ldhu	r3,-22(fp)
 82416cc:	e0bff58b 	ldhu	r2,-42(fp)
 82416d0:	1880081e 	bne	r3,r2,82416f4 <ip_reasm_compute_overlap+0x40c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 82416d4:	01000084 	movi	r4,2
 82416d8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
                  pk_free (p);
 82416dc:	e13ffc17 	ldw	r4,-16(fp)
 82416e0:	822c9700 	call	822c970 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82416e4:	01000084 	movi	r4,2
 82416e8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 82416ec:	0005883a 	mov	r2,zero
 82416f0:	00005106 	br	8241838 <ip_reasm_compute_overlap+0x550>
                  }
               else if (currend > jrend) /* case D1 */
 82416f4:	e0bffa8b 	ldhu	r2,-22(fp)
 82416f8:	e0fff58b 	ldhu	r3,-42(fp)
 82416fc:	1880082e 	bgeu	r3,r2,8241720 <ip_reasm_compute_overlap+0x438>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241700:	01000084 	movi	r4,2
 8241704:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241708:	e13ffc17 	ldw	r4,-16(fp)
 824170c:	822c9700 	call	822c970 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241710:	01000084 	movi	r4,2
 8241714:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241718:	0005883a 	mov	r2,zero
 824171c:	00004606 	br	8241838 <ip_reasm_compute_overlap+0x550>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 8241720:	e0fffa8b 	ldhu	r3,-22(fp)
 8241724:	e0bff50b 	ldhu	r2,-44(fp)
 8241728:	1885c83a 	sub	r2,r3,r2
 824172c:	10800044 	addi	r2,r2,1
 8241730:	e0bffb0d 	sth	r2,-20(fp)
                  p->nb_prot += drop_len;
 8241734:	e0bffc17 	ldw	r2,-16(fp)
 8241738:	10c00317 	ldw	r3,12(r2)
 824173c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241740:	1887883a 	add	r3,r3,r2
 8241744:	e0bffc17 	ldw	r2,-16(fp)
 8241748:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 824174c:	e0bffc17 	ldw	r2,-16(fp)
 8241750:	10c00417 	ldw	r3,16(r2)
 8241754:	e0bffb0b 	ldhu	r2,-20(fp)
 8241758:	1887c83a 	sub	r3,r3,r2
 824175c:	e0bffc17 	ldw	r2,-16(fp)
 8241760:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 8241764:	e0fff50b 	ldhu	r3,-44(fp)
 8241768:	e0bffb0b 	ldhu	r2,-20(fp)
 824176c:	1885883a 	add	r2,r3,r2
 8241770:	e0bff50d 	sth	r2,-44(fp)
                  jrend = jrstart + p->nb_plen - 1;
 8241774:	e0bffc17 	ldw	r2,-16(fp)
 8241778:	10800417 	ldw	r2,16(r2)
 824177c:	1007883a 	mov	r3,r2
 8241780:	e0bff50b 	ldhu	r2,-44(fp)
 8241784:	1885883a 	add	r2,r3,r2
 8241788:	10bfffc4 	addi	r2,r2,-1
 824178c:	e0bff58d 	sth	r2,-42(fp)
 8241790:	00001006 	br	82417d4 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 8241794:	e0bffe17 	ldw	r2,-8(fp)
 8241798:	1080000b 	ldhu	r2,0(r2)
 824179c:	10bfffcc 	andi	r2,r2,65535
 82417a0:	10800418 	cmpnei	r2,r2,16
 82417a4:	1000061e 	bne	r2,zero,82417c0 <ip_reasm_compute_overlap+0x4d8>
               {
               *indexp = i;
 82417a8:	e0bffe17 	ldw	r2,-8(fp)
 82417ac:	e0fff60b 	ldhu	r3,-40(fp)
 82417b0:	10c0000d 	sth	r3,0(r2)
               *last_rfqpp = rfqp;               
 82417b4:	e0bfff17 	ldw	r2,-4(fp)
 82417b8:	e0fff417 	ldw	r3,-48(fp)
 82417bc:	10c00015 	stw	r3,0(r2)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 82417c0:	e0bffd17 	ldw	r2,-12(fp)
 82417c4:	10802103 	ldbu	r2,132(r2)
 82417c8:	10803fcc 	andi	r2,r2,255
 82417cc:	1080004c 	andi	r2,r2,1
 82417d0:	1000071e 	bne	r2,zero,82417f0 <ip_reasm_compute_overlap+0x508>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82417d4:	e0bff60b 	ldhu	r2,-40(fp)
 82417d8:	10800044 	addi	r2,r2,1
 82417dc:	e0bff60d 	sth	r2,-40(fp)
 82417e0:	e0bff60b 	ldhu	r2,-40(fp)
 82417e4:	10800430 	cmpltui	r2,r2,16
 82417e8:	103f201e 	bne	r2,zero,824146c <ip_reasm_compute_overlap+0x184>
 82417ec:	00000106 	br	82417f4 <ip_reasm_compute_overlap+0x50c>
               *indexp = i;
               *last_rfqpp = rfqp;               
               }
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 82417f0:	0001883a 	nop
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 82417f4:	e0bffe17 	ldw	r2,-8(fp)
 82417f8:	1080000b 	ldhu	r2,0(r2)
 82417fc:	10bfffcc 	andi	r2,r2,65535
 8241800:	10800418 	cmpnei	r2,r2,16
 8241804:	1000031e 	bne	r2,zero,8241814 <ip_reasm_compute_overlap+0x52c>
         {
         *last_rfqpp = rfqp;
 8241808:	e0bfff17 	ldw	r2,-4(fp)
 824180c:	e0fff417 	ldw	r3,-48(fp)
 8241810:	10c00015 	stw	r3,0(r2)
         }
      rfqp = rfqp->next;
 8241814:	e0bff417 	ldw	r2,-48(fp)
 8241818:	10800017 	ldw	r2,0(r2)
 824181c:	e0bff415 	stw	r2,-48(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 8241820:	e0bff417 	ldw	r2,-48(fp)
 8241824:	103f0f1e 	bne	r2,zero,8241464 <ip_reasm_compute_overlap+0x17c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 8241828:	e0800217 	ldw	r2,8(fp)
 824182c:	e0fff50b 	ldhu	r3,-44(fp)
 8241830:	10c0000d 	sth	r3,0(r2)

   return IPREASM_ACCEPT_FRAG;
 8241834:	00800084 	movi	r2,2
}
 8241838:	e037883a 	mov	sp,fp
 824183c:	dfc00117 	ldw	ra,4(sp)
 8241840:	df000017 	ldw	fp,0(sp)
 8241844:	dec00204 	addi	sp,sp,8
 8241848:	f800283a 	ret

0824184c <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 824184c:	defff104 	addi	sp,sp,-60
 8241850:	dfc00e15 	stw	ra,56(sp)
 8241854:	df000d15 	stw	fp,52(sp)
 8241858:	df000d04 	addi	fp,sp,52
 824185c:	e13ffe15 	stw	r4,-8(fp)
 8241860:	e17fff15 	stw	r5,-4(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 8241864:	e03ff515 	stw	zero,-44(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241868:	e13fff17 	ldw	r4,-4(fp)
 824186c:	8241d7c0 	call	8241d7c <ip_reasm_find_ire>
 8241870:	10803fcc 	andi	r2,r2,255
 8241874:	10800060 	cmpeqi	r2,r2,1
 8241878:	1000161e 	bne	r2,zero,82418d4 <ip_reasm_process_subsequent_fragments+0x88>
      {
      ++ire_stats.bad_irep;
 824187c:	008209b4 	movhi	r2,2086
 8241880:	10b90c04 	addi	r2,r2,-7120
 8241884:	10800017 	ldw	r2,0(r2)
 8241888:	10c00044 	addi	r3,r2,1
 824188c:	008209b4 	movhi	r2,2086
 8241890:	10b90c04 	addi	r2,r2,-7120
 8241894:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241898:	01000084 	movi	r4,2
 824189c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free (p);
 82418a0:	e13ffe17 	ldw	r4,-8(fp)
 82418a4:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82418a8:	01000084 	movi	r4,2
 82418ac:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 82418b0:	008209b4 	movhi	r2,2086
 82418b4:	10b8f804 	addi	r2,r2,-7200
 82418b8:	10800f17 	ldw	r2,60(r2)
 82418bc:	10c00044 	addi	r3,r2,1
 82418c0:	008209b4 	movhi	r2,2086
 82418c4:	10b8f804 	addi	r2,r2,-7200
 82418c8:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 82418cc:	00bffd84 	movi	r2,-10
 82418d0:	00012506 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>
      }

   pip = ip_head(p);
 82418d4:	e0bffe17 	ldw	r2,-8(fp)
 82418d8:	10800317 	ldw	r2,12(r2)
 82418dc:	e0bff615 	stw	r2,-40(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 82418e0:	e13ff617 	ldw	r4,-40(fp)
 82418e4:	8240d0c0 	call	8240d0c <ip_reasm_determine_type_of_frag>
 82418e8:	e0bff715 	stw	r2,-36(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 82418ec:	e0bff717 	ldw	r2,-36(fp)
 82418f0:	10800158 	cmpnei	r2,r2,5
 82418f4:	1000251e 	bne	r2,zero,824198c <ip_reasm_process_subsequent_fragments+0x140>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 82418f8:	e0bff617 	ldw	r2,-40(fp)
 82418fc:	1080018b 	ldhu	r2,6(r2)
 8241900:	10bfffcc 	andi	r2,r2,65535
 8241904:	1004d23a 	srli	r2,r2,8
 8241908:	10bfffcc 	andi	r2,r2,65535
 824190c:	10c03fcc 	andi	r3,r2,255
 8241910:	e0bff617 	ldw	r2,-40(fp)
 8241914:	1080018b 	ldhu	r2,6(r2)
 8241918:	10bfffcc 	andi	r2,r2,65535
 824191c:	1004923a 	slli	r2,r2,8
 8241920:	10bfffcc 	andi	r2,r2,65535
 8241924:	1884b03a 	or	r2,r3,r2
 8241928:	100490fa 	slli	r2,r2,3
 824192c:	1007883a 	mov	r3,r2
 8241930:	e0bff617 	ldw	r2,-40(fp)
 8241934:	1080008b 	ldhu	r2,2(r2)
 8241938:	10bfffcc 	andi	r2,r2,65535
 824193c:	1004d23a 	srli	r2,r2,8
 8241940:	1009883a 	mov	r4,r2
 8241944:	e0bff617 	ldw	r2,-40(fp)
 8241948:	1080008b 	ldhu	r2,2(r2)
 824194c:	10bfffcc 	andi	r2,r2,65535
 8241950:	1004923a 	slli	r2,r2,8
 8241954:	2084b03a 	or	r2,r4,r2
 8241958:	1009883a 	mov	r4,r2
 824195c:	e0bff617 	ldw	r2,-40(fp)
 8241960:	10800003 	ldbu	r2,0(r2)
 8241964:	10803fcc 	andi	r2,r2,255
 8241968:	108003cc 	andi	r2,r2,15
 824196c:	1085883a 	add	r2,r2,r2
 8241970:	1085883a 	add	r2,r2,r2
 8241974:	2085c83a 	sub	r2,r4,r2
 8241978:	1885883a 	add	r2,r3,r2
 824197c:	1007883a 	mov	r3,r2
 8241980:	e0bfff17 	ldw	r2,-4(fp)
 8241984:	10c0040d 	sth	r3,16(r2)
 8241988:	00000a06 	br	82419b4 <ip_reasm_process_subsequent_fragments+0x168>
      }
   else if (ftype == IP_FF)
 824198c:	e0bff717 	ldw	r2,-36(fp)
 8241990:	10800058 	cmpnei	r2,r2,1
 8241994:	1000071e 	bne	r2,zero,82419b4 <ip_reasm_process_subsequent_fragments+0x168>
      {
      irep->l2_hdr = p->nb_buff;
 8241998:	e0bffe17 	ldw	r2,-8(fp)
 824199c:	10c00117 	ldw	r3,4(r2)
 82419a0:	e0bfff17 	ldw	r2,-4(fp)
 82419a4:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 82419a8:	e0bfff17 	ldw	r2,-4(fp)
 82419ac:	e0fff617 	ldw	r3,-40(fp)
 82419b0:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 82419b4:	e13ffc04 	addi	r4,fp,-16
 82419b8:	e0fffb04 	addi	r3,fp,-20
 82419bc:	e0bffd84 	addi	r2,fp,-10
 82419c0:	d8800115 	stw	r2,4(sp)
 82419c4:	e0bffd04 	addi	r2,fp,-12
 82419c8:	d8800015 	stw	r2,0(sp)
 82419cc:	200f883a 	mov	r7,r4
 82419d0:	180d883a 	mov	r6,r3
 82419d4:	e17fff17 	ldw	r5,-4(fp)
 82419d8:	e13ffe17 	ldw	r4,-8(fp)
 82419dc:	82412e80 	call	82412e8 <ip_reasm_compute_overlap>
 82419e0:	e0bff815 	stw	r2,-32(fp)
 82419e4:	e0bff817 	ldw	r2,-32(fp)
 82419e8:	108000a0 	cmpeqi	r2,r2,2
 82419ec:	1000091e 	bne	r2,zero,8241a14 <ip_reasm_process_subsequent_fragments+0x1c8>
      {
      switch (rc2)
 82419f0:	e0bff817 	ldw	r2,-32(fp)
 82419f4:	10c00060 	cmpeqi	r3,r2,1
 82419f8:	1800031e 	bne	r3,zero,8241a08 <ip_reasm_process_subsequent_fragments+0x1bc>
 82419fc:	00800436 	bltu	zero,r2,8241a10 <ip_reasm_process_subsequent_fragments+0x1c4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 8241a00:	0005883a 	mov	r2,zero
 8241a04:	0000d806 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 8241a08:	00bffd84 	movi	r2,-10
 8241a0c:	0000d606 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>
          * Altera Niche Stack Nios port modification:
          * Handle IPREASM_ACCEPT_FRAG case (will never
          * get here per if() above) to remove build warning.
          */
         case IPREASM_ACCEPT_FRAG:
            while(0);
 8241a10:	0001883a 	nop
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 8241a14:	e0bffe17 	ldw	r2,-8(fp)
 8241a18:	10800217 	ldw	r2,8(r2)
 8241a1c:	10bfffcc 	andi	r2,r2,65535
 8241a20:	1009883a 	mov	r4,r2
 8241a24:	8240ddc0 	call	8240ddc <ip_reasm_check_mem_useage>
 8241a28:	e0bff915 	stw	r2,-28(fp)
 8241a2c:	e0bff917 	ldw	r2,-28(fp)
 8241a30:	10001126 	beq	r2,zero,8241a78 <ip_reasm_process_subsequent_fragments+0x22c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241a34:	01000084 	movi	r4,2
 8241a38:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241a3c:	e13ffe17 	ldw	r4,-8(fp)
 8241a40:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241a44:	01000084 	movi	r4,2
 8241a48:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 8241a4c:	e13fff17 	ldw	r4,-4(fp)
 8241a50:	82421f80 	call	82421f8 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 8241a54:	008209b4 	movhi	r2,2086
 8241a58:	10b8f804 	addi	r2,r2,-7200
 8241a5c:	10800f17 	ldw	r2,60(r2)
 8241a60:	10c00044 	addi	r3,r2,1
 8241a64:	008209b4 	movhi	r2,2086
 8241a68:	10b8f804 	addi	r2,r2,-7200
 8241a6c:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241a70:	e0bff917 	ldw	r2,-28(fp)
 8241a74:	0000bc06 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 8241a78:	e0bffb0b 	ldhu	r2,-20(fp)
 8241a7c:	10bfffcc 	andi	r2,r2,65535
 8241a80:	10800420 	cmpeqi	r2,r2,16
 8241a84:	1000121e 	bne	r2,zero,8241ad0 <ip_reasm_process_subsequent_fragments+0x284>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 8241a88:	e0fffc17 	ldw	r3,-16(fp)
 8241a8c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241a90:	10bfffcc 	andi	r2,r2,65535
 8241a94:	10800044 	addi	r2,r2,1
 8241a98:	1085883a 	add	r2,r2,r2
 8241a9c:	1085883a 	add	r2,r2,r2
 8241aa0:	1885883a 	add	r2,r3,r2
 8241aa4:	e0fffe17 	ldw	r3,-8(fp)
 8241aa8:	10c00015 	stw	r3,0(r2)
      rfqp->frag_offset[index] = frag_offset;
 8241aac:	e13ffc17 	ldw	r4,-16(fp)
 8241ab0:	e0bffb0b 	ldhu	r2,-20(fp)
 8241ab4:	10bfffcc 	andi	r2,r2,65535
 8241ab8:	e0fffd0b 	ldhu	r3,-12(fp)
 8241abc:	10800884 	addi	r2,r2,34
 8241ac0:	1085883a 	add	r2,r2,r2
 8241ac4:	2085883a 	add	r2,r4,r2
 8241ac8:	10c0000d 	sth	r3,0(r2)
 8241acc:	00003906 	br	8241bb4 <ip_reasm_process_subsequent_fragments+0x368>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 8241ad0:	e0bffe17 	ldw	r2,-8(fp)
 8241ad4:	10800217 	ldw	r2,8(r2)
 8241ad8:	10801904 	addi	r2,r2,100
 8241adc:	10bfffcc 	andi	r2,r2,65535
 8241ae0:	1009883a 	mov	r4,r2
 8241ae4:	8240ddc0 	call	8240ddc <ip_reasm_check_mem_useage>
 8241ae8:	e0bff915 	stw	r2,-28(fp)
 8241aec:	e0bff917 	ldw	r2,-28(fp)
 8241af0:	10001126 	beq	r2,zero,8241b38 <ip_reasm_process_subsequent_fragments+0x2ec>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241af4:	01000084 	movi	r4,2
 8241af8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free (p);
 8241afc:	e13ffe17 	ldw	r4,-8(fp)
 8241b00:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241b04:	01000084 	movi	r4,2
 8241b08:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241b0c:	e13fff17 	ldw	r4,-4(fp)
 8241b10:	82421f80 	call	82421f8 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241b14:	008209b4 	movhi	r2,2086
 8241b18:	10b8f804 	addi	r2,r2,-7200
 8241b1c:	10800f17 	ldw	r2,60(r2)
 8241b20:	10c00044 	addi	r3,r2,1
 8241b24:	008209b4 	movhi	r2,2086
 8241b28:	10b8f804 	addi	r2,r2,-7200
 8241b2c:	10c00f15 	stw	r3,60(r2)
         return rc;
 8241b30:	e0bff917 	ldw	r2,-28(fp)
 8241b34:	00008c06 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 8241b38:	01001904 	movi	r4,100
 8241b3c:	822dda00 	call	822dda0 <npalloc>
 8241b40:	e0bff515 	stw	r2,-44(fp)
      if (new_rfqp == 0)
 8241b44:	e0bff517 	ldw	r2,-44(fp)
 8241b48:	1000111e 	bne	r2,zero,8241b90 <ip_reasm_process_subsequent_fragments+0x344>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241b4c:	01000084 	movi	r4,2
 8241b50:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free (p);
 8241b54:	e13ffe17 	ldw	r4,-8(fp)
 8241b58:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241b5c:	01000084 	movi	r4,2
 8241b60:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241b64:	e13fff17 	ldw	r4,-4(fp)
 8241b68:	82421f80 	call	82421f8 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241b6c:	008209b4 	movhi	r2,2086
 8241b70:	10b8f804 	addi	r2,r2,-7200
 8241b74:	10800f17 	ldw	r2,60(r2)
 8241b78:	10c00044 	addi	r3,r2,1
 8241b7c:	008209b4 	movhi	r2,2086
 8241b80:	10b8f804 	addi	r2,r2,-7200
 8241b84:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 8241b88:	00bffa84 	movi	r2,-22
 8241b8c:	00007606 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 8241b90:	e0bff517 	ldw	r2,-44(fp)
 8241b94:	e0fffe17 	ldw	r3,-8(fp)
 8241b98:	10c00115 	stw	r3,4(r2)
         new_rfqp->frag_offset[0] = frag_offset;
 8241b9c:	e0fffd0b 	ldhu	r3,-12(fp)
 8241ba0:	e0bff517 	ldw	r2,-44(fp)
 8241ba4:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 8241ba8:	e0bffc17 	ldw	r2,-16(fp)
 8241bac:	e0fff517 	ldw	r3,-44(fp)
 8241bb0:	10c00015 	stw	r3,0(r2)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 8241bb4:	e0bffd83 	ldbu	r2,-10(fp)
 8241bb8:	10803fcc 	andi	r2,r2,255
 8241bbc:	10001426 	beq	r2,zero,8241c10 <ip_reasm_process_subsequent_fragments+0x3c4>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 8241bc0:	e13fff17 	ldw	r4,-4(fp)
 8241bc4:	82423ac0 	call	82423ac <ip_reasm_mark_compact_rfq>
 8241bc8:	e0bff915 	stw	r2,-28(fp)
 8241bcc:	e0bff917 	ldw	r2,-28(fp)
 8241bd0:	10000f26 	beq	r2,zero,8241c10 <ip_reasm_process_subsequent_fragments+0x3c4>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 8241bd4:	01000084 	movi	r4,2
 8241bd8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free (p);
 8241bdc:	e13ffe17 	ldw	r4,-8(fp)
 8241be0:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241be4:	01000084 	movi	r4,2
 8241be8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 8241bec:	008209b4 	movhi	r2,2086
 8241bf0:	10b8f804 	addi	r2,r2,-7200
 8241bf4:	10800f17 	ldw	r2,60(r2)
 8241bf8:	10c00044 	addi	r3,r2,1
 8241bfc:	008209b4 	movhi	r2,2086
 8241c00:	10b8f804 	addi	r2,r2,-7200
 8241c04:	10c00f15 	stw	r3,60(r2)
            return rc;
 8241c08:	e0bff917 	ldw	r2,-28(fp)
 8241c0c:	00005606 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 8241c10:	e0bfff17 	ldw	r2,-4(fp)
 8241c14:	1080048b 	ldhu	r2,18(r2)
 8241c18:	e0fffe17 	ldw	r3,-8(fp)
 8241c1c:	18c00417 	ldw	r3,16(r3)
 8241c20:	10c5883a 	add	r2,r2,r3
 8241c24:	1007883a 	mov	r3,r2
 8241c28:	e0bfff17 	ldw	r2,-4(fp)
 8241c2c:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 8241c30:	e0bffe17 	ldw	r2,-8(fp)
 8241c34:	10800217 	ldw	r2,8(r2)
 8241c38:	1007883a 	mov	r3,r2
 8241c3c:	e0bff517 	ldw	r2,-44(fp)
 8241c40:	1000021e 	bne	r2,zero,8241c4c <ip_reasm_process_subsequent_fragments+0x400>
 8241c44:	0005883a 	mov	r2,zero
 8241c48:	00000106 	br	8241c50 <ip_reasm_process_subsequent_fragments+0x404>
 8241c4c:	00801904 	movi	r2,100
 8241c50:	1885883a 	add	r2,r3,r2
 8241c54:	10bfffcc 	andi	r2,r2,65535
 8241c58:	1009883a 	mov	r4,r2
 8241c5c:	8240e700 	call	8240e70 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 8241c60:	e0bfff17 	ldw	r2,-4(fp)
 8241c64:	1080040b 	ldhu	r2,16(r2)
 8241c68:	10bfffcc 	andi	r2,r2,65535
 8241c6c:	10003d26 	beq	r2,zero,8241d64 <ip_reasm_process_subsequent_fragments+0x518>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 8241c70:	e0bfff17 	ldw	r2,-4(fp)
 8241c74:	10c0048b 	ldhu	r3,18(r2)
 8241c78:	e0bfff17 	ldw	r2,-4(fp)
 8241c7c:	1080040b 	ldhu	r2,16(r2)
 8241c80:	18ffffcc 	andi	r3,r3,65535
 8241c84:	10bfffcc 	andi	r2,r2,65535
 8241c88:	1880361e 	bne	r3,r2,8241d64 <ip_reasm_process_subsequent_fragments+0x518>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 8241c8c:	e0bfff17 	ldw	r2,-4(fp)
 8241c90:	10802017 	ldw	r2,128(r2)
 8241c94:	e0bff615 	stw	r2,-40(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241c98:	01000084 	movi	r4,2
 8241c9c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 8241ca0:	e0bfff17 	ldw	r2,-4(fp)
 8241ca4:	1080040b 	ldhu	r2,16(r2)
 8241ca8:	10ffffcc 	andi	r3,r2,65535
 8241cac:	e0bfff17 	ldw	r2,-4(fp)
 8241cb0:	10802017 	ldw	r2,128(r2)
 8241cb4:	1009883a 	mov	r4,r2
 8241cb8:	e0bfff17 	ldw	r2,-4(fp)
 8241cbc:	10801f17 	ldw	r2,124(r2)
 8241cc0:	2085c83a 	sub	r2,r4,r2
 8241cc4:	1887883a 	add	r3,r3,r2
 8241cc8:	e0bff617 	ldw	r2,-40(fp)
 8241ccc:	10800003 	ldbu	r2,0(r2)
 8241cd0:	10803fcc 	andi	r2,r2,255
 8241cd4:	108003cc 	andi	r2,r2,15
 8241cd8:	1085883a 	add	r2,r2,r2
 8241cdc:	1085883a 	add	r2,r2,r2
 8241ce0:	1885883a 	add	r2,r3,r2
 8241ce4:	1009883a 	mov	r4,r2
 8241ce8:	822c6200 	call	822c620 <pk_alloc>
 8241cec:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241cf0:	01000084 	movi	r4,2
 8241cf4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 8241cf8:	e0bffa17 	ldw	r2,-24(fp)
 8241cfc:	10000b1e 	bne	r2,zero,8241d2c <ip_reasm_process_subsequent_fragments+0x4e0>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 8241d00:	e13fff17 	ldw	r4,-4(fp)
 8241d04:	82421f80 	call	82421f8 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 8241d08:	008209b4 	movhi	r2,2086
 8241d0c:	10b8f804 	addi	r2,r2,-7200
 8241d10:	10800f17 	ldw	r2,60(r2)
 8241d14:	10c00044 	addi	r3,r2,1
 8241d18:	008209b4 	movhi	r2,2086
 8241d1c:	10b8f804 	addi	r2,r2,-7200
 8241d20:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 8241d24:	00bffac4 	movi	r2,-21
 8241d28:	00000f06 	br	8241d68 <ip_reasm_process_subsequent_fragments+0x51c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 8241d2c:	e17fff17 	ldw	r5,-4(fp)
 8241d30:	e13ffa17 	ldw	r4,-24(fp)
 8241d34:	8241dd40 	call	8241dd4 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 8241d38:	e13fff17 	ldw	r4,-4(fp)
 8241d3c:	82421f80 	call	82421f8 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 8241d40:	008209b4 	movhi	r2,2086
 8241d44:	10b8f804 	addi	r2,r2,-7200
 8241d48:	10800e17 	ldw	r2,56(r2)
 8241d4c:	10c00044 	addi	r3,r2,1
 8241d50:	008209b4 	movhi	r2,2086
 8241d54:	10b8f804 	addi	r2,r2,-7200
 8241d58:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 8241d5c:	e13ffa17 	ldw	r4,-24(fp)
 8241d60:	82431d00 	call	82431d0 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 8241d64:	0005883a 	mov	r2,zero
}
 8241d68:	e037883a 	mov	sp,fp
 8241d6c:	dfc00117 	ldw	ra,4(sp)
 8241d70:	df000017 	ldw	fp,0(sp)
 8241d74:	dec00204 	addi	sp,sp,8
 8241d78:	f800283a 	ret

08241d7c <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 8241d7c:	defffd04 	addi	sp,sp,-12
 8241d80:	df000215 	stw	fp,8(sp)
 8241d84:	df000204 	addi	fp,sp,8
 8241d88:	e13fff15 	stw	r4,-4(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241d8c:	d0a0c817 	ldw	r2,-31968(gp)
 8241d90:	e0bffe15 	stw	r2,-8(fp)
 8241d94:	00000806 	br	8241db8 <ip_reasm_find_ire+0x3c>
      {
      if (tmpp == irep) 
 8241d98:	e0fffe17 	ldw	r3,-8(fp)
 8241d9c:	e0bfff17 	ldw	r2,-4(fp)
 8241da0:	1880021e 	bne	r3,r2,8241dac <ip_reasm_find_ire+0x30>
         {
         return IPREASM_TRUE;
 8241da4:	00800044 	movi	r2,1
 8241da8:	00000606 	br	8241dc4 <ip_reasm_find_ire+0x48>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241dac:	e0bffe17 	ldw	r2,-8(fp)
 8241db0:	10800017 	ldw	r2,0(r2)
 8241db4:	e0bffe15 	stw	r2,-8(fp)
 8241db8:	e0bffe17 	ldw	r2,-8(fp)
 8241dbc:	103ff61e 	bne	r2,zero,8241d98 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 8241dc0:	0005883a 	mov	r2,zero
}
 8241dc4:	e037883a 	mov	sp,fp
 8241dc8:	df000017 	ldw	fp,0(sp)
 8241dcc:	dec00104 	addi	sp,sp,4
 8241dd0:	f800283a 	ret

08241dd4 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 8241dd4:	defff504 	addi	sp,sp,-44
 8241dd8:	dfc00a15 	stw	ra,40(sp)
 8241ddc:	df000915 	stw	fp,36(sp)
 8241de0:	df000904 	addi	fp,sp,36
 8241de4:	e13ffe15 	stw	r4,-8(fp)
 8241de8:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 8241dec:	e03ff915 	stw	zero,-28(fp)

   pip = (struct ip *) irep->l3_hdr;
 8241df0:	e0bfff17 	ldw	r2,-4(fp)
 8241df4:	10802017 	ldw	r2,128(r2)
 8241df8:	e0bffa15 	stw	r2,-24(fp)
   iphlen = ip_hlen (pip);
 8241dfc:	e0bffa17 	ldw	r2,-24(fp)
 8241e00:	10800003 	ldbu	r2,0(r2)
 8241e04:	108003cc 	andi	r2,r2,15
 8241e08:	1085883a 	add	r2,r2,r2
 8241e0c:	1085883a 	add	r2,r2,r2
 8241e10:	e0bffb05 	stb	r2,-20(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 8241e14:	e0bfff17 	ldw	r2,-4(fp)
 8241e18:	10802017 	ldw	r2,128(r2)
 8241e1c:	1007883a 	mov	r3,r2
 8241e20:	e0bfff17 	ldw	r2,-4(fp)
 8241e24:	10801f17 	ldw	r2,124(r2)
 8241e28:	1885c83a 	sub	r2,r3,r2
 8241e2c:	1007883a 	mov	r3,r2
 8241e30:	e0bffb03 	ldbu	r2,-20(fp)
 8241e34:	1885883a 	add	r2,r3,r2
 8241e38:	e0bffb45 	stb	r2,-19(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 8241e3c:	e0bffe17 	ldw	r2,-8(fp)
 8241e40:	10c00117 	ldw	r3,4(r2)
 8241e44:	e0bfff17 	ldw	r2,-4(fp)
 8241e48:	10801f17 	ldw	r2,124(r2)
 8241e4c:	e13ffb43 	ldbu	r4,-19(fp)
 8241e50:	200d883a 	mov	r6,r4
 8241e54:	100b883a 	mov	r5,r2
 8241e58:	1809883a 	mov	r4,r3
 8241e5c:	8202a0c0 	call	8202a0c <memcpy>

   rfqp = &(irep->rfq);
 8241e60:	e0bfff17 	ldw	r2,-4(fp)
 8241e64:	10800604 	addi	r2,r2,24
 8241e68:	e0bff715 	stw	r2,-36(fp)
   writep = reassy_pkt->nb_buff + offset;
 8241e6c:	e0bffe17 	ldw	r2,-8(fp)
 8241e70:	10c00117 	ldw	r3,4(r2)
 8241e74:	e0bffb43 	ldbu	r2,-19(fp)
 8241e78:	1885883a 	add	r2,r3,r2
 8241e7c:	e0bffc15 	stw	r2,-16(fp)

   while (rfqp)
 8241e80:	00004506 	br	8241f98 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241e84:	e03ff80d 	sth	zero,-32(fp)
 8241e88:	00003b06 	br	8241f78 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a4>
         {
         if ((p = rfqp->bufp [i]) != 0)
 8241e8c:	e0bff80b 	ldhu	r2,-32(fp)
 8241e90:	e0fff717 	ldw	r3,-36(fp)
 8241e94:	10800044 	addi	r2,r2,1
 8241e98:	1085883a 	add	r2,r2,r2
 8241e9c:	1085883a 	add	r2,r2,r2
 8241ea0:	1885883a 	add	r2,r3,r2
 8241ea4:	10800017 	ldw	r2,0(r2)
 8241ea8:	e0bffd15 	stw	r2,-12(fp)
 8241eac:	e0bffd17 	ldw	r2,-12(fp)
 8241eb0:	10002926 	beq	r2,zero,8241f58 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 8241eb4:	e0bff80b 	ldhu	r2,-32(fp)
 8241eb8:	e0fff717 	ldw	r3,-36(fp)
 8241ebc:	10800884 	addi	r2,r2,34
 8241ec0:	1085883a 	add	r2,r2,r2
 8241ec4:	1885883a 	add	r2,r3,r2
 8241ec8:	1080000b 	ldhu	r2,0(r2)
 8241ecc:	10bfffcc 	andi	r2,r2,65535
 8241ed0:	e0fffc17 	ldw	r3,-16(fp)
 8241ed4:	1887883a 	add	r3,r3,r2
 8241ed8:	e0bffd17 	ldw	r2,-12(fp)
 8241edc:	11000317 	ldw	r4,12(r2)
 8241ee0:	e0bffd17 	ldw	r2,-12(fp)
 8241ee4:	10800417 	ldw	r2,16(r2)
 8241ee8:	100d883a 	mov	r6,r2
 8241eec:	200b883a 	mov	r5,r4
 8241ef0:	1809883a 	mov	r4,r3
 8241ef4:	8202a0c0 	call	8202a0c <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 8241ef8:	e0bff917 	ldw	r2,-28(fp)
 8241efc:	1000031e 	bne	r2,zero,8241f0c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x138>
 8241f00:	e0bffd17 	ldw	r2,-12(fp)
 8241f04:	e0bff915 	stw	r2,-28(fp)
 8241f08:	00000b06 	br	8241f38 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 8241f0c:	e0bffd17 	ldw	r2,-12(fp)
 8241f10:	10800217 	ldw	r2,8(r2)
 8241f14:	10bfffcc 	andi	r2,r2,65535
 8241f18:	1009883a 	mov	r4,r2
 8241f1c:	8240f100 	call	8240f10 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 8241f20:	01000084 	movi	r4,2
 8241f24:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
               pk_free (p);
 8241f28:	e13ffd17 	ldw	r4,-12(fp)
 8241f2c:	822c9700 	call	822c970 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241f30:	01000084 	movi	r4,2
 8241f34:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 8241f38:	e0bff80b 	ldhu	r2,-32(fp)
 8241f3c:	e0fff717 	ldw	r3,-36(fp)
 8241f40:	10800044 	addi	r2,r2,1
 8241f44:	1085883a 	add	r2,r2,r2
 8241f48:	1085883a 	add	r2,r2,r2
 8241f4c:	1885883a 	add	r2,r3,r2
 8241f50:	10000015 	stw	zero,0(r2)
 8241f54:	00000506 	br	8241f6c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x198>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8241f58:	e0bfff17 	ldw	r2,-4(fp)
 8241f5c:	10802103 	ldbu	r2,132(r2)
 8241f60:	10803fcc 	andi	r2,r2,255
 8241f64:	1080004c 	andi	r2,r2,1
 8241f68:	1000071e 	bne	r2,zero,8241f88 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b4>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241f6c:	e0bff80b 	ldhu	r2,-32(fp)
 8241f70:	10800044 	addi	r2,r2,1
 8241f74:	e0bff80d 	sth	r2,-32(fp)
 8241f78:	e0bff80b 	ldhu	r2,-32(fp)
 8241f7c:	10800430 	cmpltui	r2,r2,16
 8241f80:	103fc21e 	bne	r2,zero,8241e8c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb8>
 8241f84:	00000106 	br	8241f8c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8241f88:	0001883a 	nop
               }
            }
          }

      rfqp = rfqp->next;
 8241f8c:	e0bff717 	ldw	r2,-36(fp)
 8241f90:	10800017 	ldw	r2,0(r2)
 8241f94:	e0bff715 	stw	r2,-36(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 8241f98:	e0bff717 	ldw	r2,-36(fp)
 8241f9c:	103fb91e 	bne	r2,zero,8241e84 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb0>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 8241fa0:	e0bffe17 	ldw	r2,-8(fp)
 8241fa4:	10800117 	ldw	r2,4(r2)
 8241fa8:	e0ffff17 	ldw	r3,-4(fp)
 8241fac:	18c02017 	ldw	r3,128(r3)
 8241fb0:	1809883a 	mov	r4,r3
 8241fb4:	e0ffff17 	ldw	r3,-4(fp)
 8241fb8:	18c01f17 	ldw	r3,124(r3)
 8241fbc:	20c7c83a 	sub	r3,r4,r3
 8241fc0:	10c7883a 	add	r3,r2,r3
 8241fc4:	e0bffe17 	ldw	r2,-8(fp)
 8241fc8:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 8241fcc:	e0bfff17 	ldw	r2,-4(fp)
 8241fd0:	1080040b 	ldhu	r2,16(r2)
 8241fd4:	10ffffcc 	andi	r3,r2,65535
 8241fd8:	e0bffb03 	ldbu	r2,-20(fp)
 8241fdc:	1885883a 	add	r2,r3,r2
 8241fe0:	1007883a 	mov	r3,r2
 8241fe4:	e0bffe17 	ldw	r2,-8(fp)
 8241fe8:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 8241fec:	d0a0a817 	ldw	r2,-32096(gp)
 8241ff0:	1007883a 	mov	r3,r2
 8241ff4:	e0bffe17 	ldw	r2,-8(fp)
 8241ff8:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 8241ffc:	e0bffe17 	ldw	r2,-8(fp)
 8242000:	10c00a17 	ldw	r3,40(r2)
 8242004:	e0bff917 	ldw	r2,-28(fp)
 8242008:	10800a17 	ldw	r2,40(r2)
 824200c:	108000cc 	andi	r2,r2,3
 8242010:	1886b03a 	or	r3,r3,r2
 8242014:	e0bffe17 	ldw	r2,-8(fp)
 8242018:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 824201c:	e0bff917 	ldw	r2,-28(fp)
 8242020:	10c00617 	ldw	r3,24(r2)
 8242024:	e0bffe17 	ldw	r2,-8(fp)
 8242028:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 824202c:	e0bff917 	ldw	r2,-28(fp)
 8242030:	10c0080b 	ldhu	r3,32(r2)
 8242034:	e0bffe17 	ldw	r2,-8(fp)
 8242038:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 824203c:	e0bff917 	ldw	r2,-28(fp)
 8242040:	10800217 	ldw	r2,8(r2)
 8242044:	10bfffcc 	andi	r2,r2,65535
 8242048:	1009883a 	mov	r4,r2
 824204c:	8240f100 	call	8240f10 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8242050:	01000084 	movi	r4,2
 8242054:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 8242058:	e13ff917 	ldw	r4,-28(fp)
 824205c:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242060:	01000084 	movi	r4,2
 8242064:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 8242068:	e0bffe17 	ldw	r2,-8(fp)
 824206c:	10800317 	ldw	r2,12(r2)
 8242070:	e0bffa15 	stw	r2,-24(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 8242074:	e0bffe17 	ldw	r2,-8(fp)
 8242078:	10800417 	ldw	r2,16(r2)
 824207c:	1004d23a 	srli	r2,r2,8
 8242080:	10803fcc 	andi	r2,r2,255
 8242084:	1007883a 	mov	r3,r2
 8242088:	e0bffe17 	ldw	r2,-8(fp)
 824208c:	10800417 	ldw	r2,16(r2)
 8242090:	1004923a 	slli	r2,r2,8
 8242094:	1884b03a 	or	r2,r3,r2
 8242098:	1007883a 	mov	r3,r2
 824209c:	e0bffa17 	ldw	r2,-24(fp)
 82420a0:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 82420a4:	e0bffa17 	ldw	r2,-24(fp)
 82420a8:	10c0018b 	ldhu	r3,6(r2)
 82420ac:	00bff7c4 	movi	r2,-33
 82420b0:	1884703a 	and	r2,r3,r2
 82420b4:	1007883a 	mov	r3,r2
 82420b8:	e0bffa17 	ldw	r2,-24(fp)
 82420bc:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 82420c0:	e0bffa17 	ldw	r2,-24(fp)
 82420c4:	1080018b 	ldhu	r2,6(r2)
 82420c8:	1080380c 	andi	r2,r2,224
 82420cc:	1007883a 	mov	r3,r2
 82420d0:	e0bffa17 	ldw	r2,-24(fp)
 82420d4:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 82420d8:	e0bffa17 	ldw	r2,-24(fp)
 82420dc:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 82420e0:	e0bffb03 	ldbu	r2,-20(fp)
 82420e4:	1004d07a 	srli	r2,r2,1
 82420e8:	10803fcc 	andi	r2,r2,255
 82420ec:	100b883a 	mov	r5,r2
 82420f0:	e13ffa17 	ldw	r4,-24(fp)
 82420f4:	82283e80 	call	82283e8 <cksum>
 82420f8:	0084303a 	nor	r2,zero,r2
 82420fc:	1007883a 	mov	r3,r2
 8242100:	e0bffa17 	ldw	r2,-24(fp)
 8242104:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 8242108:	0005883a 	mov	r2,zero
}
 824210c:	e037883a 	mov	sp,fp
 8242110:	dfc00117 	ldw	ra,4(sp)
 8242114:	df000017 	ldw	fp,0(sp)
 8242118:	dec00204 	addi	sp,sp,8
 824211c:	f800283a 	ret

08242120 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 8242120:	defffc04 	addi	sp,sp,-16
 8242124:	dfc00315 	stw	ra,12(sp)
 8242128:	df000215 	stw	fp,8(sp)
 824212c:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 8242130:	0009883a 	mov	r4,zero
 8242134:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 8242138:	d0a0c817 	ldw	r2,-31968(gp)
 824213c:	e0bffe15 	stw	r2,-8(fp)
 8242140:	00002006 	br	82421c4 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 8242144:	e0bffe17 	ldw	r2,-8(fp)
 8242148:	10800017 	ldw	r2,0(r2)
 824214c:	e0bfff15 	stw	r2,-4(fp)
      ++tmpp->age;
 8242150:	e0bffe17 	ldw	r2,-8(fp)
 8242154:	10800517 	ldw	r2,20(r2)
 8242158:	10c00044 	addi	r3,r2,1
 824215c:	e0bffe17 	ldw	r2,-8(fp)
 8242160:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 8242164:	e0bffe17 	ldw	r2,-8(fp)
 8242168:	10800517 	ldw	r2,20(r2)
 824216c:	10801e18 	cmpnei	r2,r2,120
 8242170:	1000121e 	bne	r2,zero,82421bc <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 8242174:	008209b4 	movhi	r2,2086
 8242178:	10b90c04 	addi	r2,r2,-7120
 824217c:	10800117 	ldw	r2,4(r2)
 8242180:	10c00044 	addi	r3,r2,1
 8242184:	008209b4 	movhi	r2,2086
 8242188:	10b90c04 	addi	r2,r2,-7120
 824218c:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 8242190:	e13ffe17 	ldw	r4,-8(fp)
 8242194:	82428340 	call	8242834 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 8242198:	e13ffe17 	ldw	r4,-8(fp)
 824219c:	82421f80 	call	82421f8 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 82421a0:	008209b4 	movhi	r2,2086
 82421a4:	10b8f804 	addi	r2,r2,-7200
 82421a8:	10800f17 	ldw	r2,60(r2)
 82421ac:	10c00044 	addi	r3,r2,1
 82421b0:	008209b4 	movhi	r2,2086
 82421b4:	10b8f804 	addi	r2,r2,-7200
 82421b8:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 82421bc:	e0bfff17 	ldw	r2,-4(fp)
 82421c0:	e0bffe15 	stw	r2,-8(fp)
 82421c4:	e0bffe17 	ldw	r2,-8(fp)
 82421c8:	103fde1e 	bne	r2,zero,8242144 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 82421cc:	d0a0a817 	ldw	r2,-32096(gp)
 82421d0:	10801904 	addi	r2,r2,100
 82421d4:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 82421d8:	0009883a 	mov	r4,zero
 82421dc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 82421e0:	0005883a 	mov	r2,zero
}
 82421e4:	e037883a 	mov	sp,fp
 82421e8:	dfc00117 	ldw	ra,4(sp)
 82421ec:	df000017 	ldw	fp,0(sp)
 82421f0:	dec00204 	addi	sp,sp,8
 82421f4:	f800283a 	ret

082421f8 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 82421f8:	defff604 	addi	sp,sp,-40
 82421fc:	dfc00915 	stw	ra,36(sp)
 8242200:	df000815 	stw	fp,32(sp)
 8242204:	df000804 	addi	fp,sp,32
 8242208:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 824220c:	e03ffb15 	stw	zero,-20(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242210:	d0a0c817 	ldw	r2,-31968(gp)
 8242214:	e0bffa15 	stw	r2,-24(fp)
 8242218:	00001406 	br	824226c <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 824221c:	e0fffa17 	ldw	r3,-24(fp)
 8242220:	e0bfff17 	ldw	r2,-4(fp)
 8242224:	18800c1e 	bne	r3,r2,8242258 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 8242228:	d0a0c817 	ldw	r2,-31968(gp)
 824222c:	e0fffa17 	ldw	r3,-24(fp)
 8242230:	1880041e 	bne	r3,r2,8242244 <ip_reasm_delete_ire+0x4c>
 8242234:	e0bfff17 	ldw	r2,-4(fp)
 8242238:	10800017 	ldw	r2,0(r2)
 824223c:	d0a0c815 	stw	r2,-31968(gp)
         else prev_tmpp->next = irep->next;
         break;
 8242240:	00000c06 	br	8242274 <ip_reasm_delete_ire+0x7c>
      {
      if (tmpp == irep) 
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
         else prev_tmpp->next = irep->next;
 8242244:	e0bfff17 	ldw	r2,-4(fp)
 8242248:	10c00017 	ldw	r3,0(r2)
 824224c:	e0bffb17 	ldw	r2,-20(fp)
 8242250:	10c00015 	stw	r3,0(r2)
         break;
 8242254:	00000706 	br	8242274 <ip_reasm_delete_ire+0x7c>
         }
      prev_tmpp = tmpp;
 8242258:	e0bffa17 	ldw	r2,-24(fp)
 824225c:	e0bffb15 	stw	r2,-20(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242260:	e0bffa17 	ldw	r2,-24(fp)
 8242264:	10800017 	ldw	r2,0(r2)
 8242268:	e0bffa15 	stw	r2,-24(fp)
 824226c:	e0bffa17 	ldw	r2,-24(fp)
 8242270:	103fea1e 	bne	r2,zero,824221c <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 8242274:	e0bffa17 	ldw	r2,-24(fp)
 8242278:	1000091e 	bne	r2,zero,82422a0 <ip_reasm_delete_ire+0xa8>
      {
      ++ire_stats.bad_irep;
 824227c:	008209b4 	movhi	r2,2086
 8242280:	10b90c04 	addi	r2,r2,-7120
 8242284:	10800017 	ldw	r2,0(r2)
 8242288:	10c00044 	addi	r3,r2,1
 824228c:	008209b4 	movhi	r2,2086
 8242290:	10b90c04 	addi	r2,r2,-7120
 8242294:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 8242298:	00bffd84 	movi	r2,-10
 824229c:	00003e06 	br	8242398 <ip_reasm_delete_ire+0x1a0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 82422a0:	e0bfff17 	ldw	r2,-4(fp)
 82422a4:	10800604 	addi	r2,r2,24
 82422a8:	e0bffc15 	stw	r2,-16(fp)
 82422ac:	e0bffc17 	ldw	r2,-16(fp)
 82422b0:	e0bff815 	stw	r2,-32(fp)

   while (rfqp)
 82422b4:	00003106 	br	824237c <ip_reasm_delete_ire+0x184>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82422b8:	e03ff90d 	sth	zero,-28(fp)
 82422bc:	00001e06 	br	8242338 <ip_reasm_delete_ire+0x140>
         {
         if ((p = rfqp->bufp [i]) != 0)
 82422c0:	e0bff90b 	ldhu	r2,-28(fp)
 82422c4:	e0fff817 	ldw	r3,-32(fp)
 82422c8:	10800044 	addi	r2,r2,1
 82422cc:	1085883a 	add	r2,r2,r2
 82422d0:	1085883a 	add	r2,r2,r2
 82422d4:	1885883a 	add	r2,r3,r2
 82422d8:	10800017 	ldw	r2,0(r2)
 82422dc:	e0bffd15 	stw	r2,-12(fp)
 82422e0:	e0bffd17 	ldw	r2,-12(fp)
 82422e4:	10000c26 	beq	r2,zero,8242318 <ip_reasm_delete_ire+0x120>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 82422e8:	e0bffd17 	ldw	r2,-12(fp)
 82422ec:	10800217 	ldw	r2,8(r2)
 82422f0:	10bfffcc 	andi	r2,r2,65535
 82422f4:	1009883a 	mov	r4,r2
 82422f8:	8240f100 	call	8240f10 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 82422fc:	01000084 	movi	r4,2
 8242300:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free (p);
 8242304:	e13ffd17 	ldw	r4,-12(fp)
 8242308:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 824230c:	01000084 	movi	r4,2
 8242310:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
 8242314:	00000506 	br	824232c <ip_reasm_delete_ire+0x134>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242318:	e0bfff17 	ldw	r2,-4(fp)
 824231c:	10802103 	ldbu	r2,132(r2)
 8242320:	10803fcc 	andi	r2,r2,255
 8242324:	1080004c 	andi	r2,r2,1
 8242328:	1000071e 	bne	r2,zero,8242348 <ip_reasm_delete_ire+0x150>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824232c:	e0bff90b 	ldhu	r2,-28(fp)
 8242330:	10800044 	addi	r2,r2,1
 8242334:	e0bff90d 	sth	r2,-28(fp)
 8242338:	e0bff90b 	ldhu	r2,-28(fp)
 824233c:	10800430 	cmpltui	r2,r2,16
 8242340:	103fdf1e 	bne	r2,zero,82422c0 <ip_reasm_delete_ire+0xc8>
 8242344:	00000106 	br	824234c <ip_reasm_delete_ire+0x154>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242348:	0001883a 	nop
               }
            }
          }

       prev_rfqp = rfqp;
 824234c:	e0bff817 	ldw	r2,-32(fp)
 8242350:	e0bffe15 	stw	r2,-8(fp)
       rfqp = rfqp->next;
 8242354:	e0bff817 	ldw	r2,-32(fp)
 8242358:	10800017 	ldw	r2,0(r2)
 824235c:	e0bff815 	stw	r2,-32(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 8242360:	e0fffe17 	ldw	r3,-8(fp)
 8242364:	e0bffc17 	ldw	r2,-16(fp)
 8242368:	18800426 	beq	r3,r2,824237c <ip_reasm_delete_ire+0x184>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 824236c:	01001904 	movi	r4,100
 8242370:	8240f100 	call	8240f10 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 8242374:	e13ffe17 	ldw	r4,-8(fp)
 8242378:	822ddd40 	call	822ddd4 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 824237c:	e0bff817 	ldw	r2,-32(fp)
 8242380:	103fcd1e 	bne	r2,zero,82422b8 <ip_reasm_delete_ire+0xc0>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 8242384:	01002204 	movi	r4,136
 8242388:	8240f100 	call	8240f10 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 824238c:	e13fff17 	ldw	r4,-4(fp)
 8242390:	822ddd40 	call	822ddd4 <npfree>

   return IPREASM_OK;
 8242394:	0005883a 	mov	r2,zero
}
 8242398:	e037883a 	mov	sp,fp
 824239c:	dfc00117 	ldw	ra,4(sp)
 82423a0:	df000017 	ldw	fp,0(sp)
 82423a4:	dec00204 	addi	sp,sp,8
 82423a8:	f800283a 	ret

082423ac <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 82423ac:	defffb04 	addi	sp,sp,-20
 82423b0:	dfc00415 	stw	ra,16(sp)
 82423b4:	df000315 	stw	fp,12(sp)
 82423b8:	df000304 	addi	fp,sp,12
 82423bc:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 82423c0:	e03ffe85 	stb	zero,-6(fp)
   u_char compact = IPREASM_TRUE;
 82423c4:	00800044 	movi	r2,1
 82423c8:	e0bffec5 	stb	r2,-5(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 82423cc:	e13fff17 	ldw	r4,-4(fp)
 82423d0:	8241d7c0 	call	8241d7c <ip_reasm_find_ire>
 82423d4:	10803fcc 	andi	r2,r2,255
 82423d8:	10800060 	cmpeqi	r2,r2,1
 82423dc:	1000091e 	bne	r2,zero,8242404 <ip_reasm_mark_compact_rfq+0x58>
   {
      ++ire_stats.bad_irep;
 82423e0:	008209b4 	movhi	r2,2086
 82423e4:	10b90c04 	addi	r2,r2,-7120
 82423e8:	10800017 	ldw	r2,0(r2)
 82423ec:	10c00044 	addi	r3,r2,1
 82423f0:	008209b4 	movhi	r2,2086
 82423f4:	10b90c04 	addi	r2,r2,-7120
 82423f8:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 82423fc:	00bffd84 	movi	r2,-10
 8242400:	00003106 	br	82424c8 <ip_reasm_mark_compact_rfq+0x11c>
   }

   rfqp = &(irep->rfq);
 8242404:	e0bfff17 	ldw	r2,-4(fp)
 8242408:	10800604 	addi	r2,r2,24
 824240c:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 8242410:	00001a06 	br	824247c <ip_reasm_mark_compact_rfq+0xd0>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242414:	e03ffe0d 	sth	zero,-8(fp)
 8242418:	00001206 	br	8242464 <ip_reasm_mark_compact_rfq+0xb8>
         {
         if (rfqp->bufp [i] == 0)
 824241c:	e0bffe0b 	ldhu	r2,-8(fp)
 8242420:	e0fffd17 	ldw	r3,-12(fp)
 8242424:	10800044 	addi	r2,r2,1
 8242428:	1085883a 	add	r2,r2,r2
 824242c:	1085883a 	add	r2,r2,r2
 8242430:	1885883a 	add	r2,r3,r2
 8242434:	10800017 	ldw	r2,0(r2)
 8242438:	1000031e 	bne	r2,zero,8242448 <ip_reasm_mark_compact_rfq+0x9c>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 824243c:	00800044 	movi	r2,1
 8242440:	e0bffe85 	stb	r2,-6(fp)
 8242444:	00000406 	br	8242458 <ip_reasm_mark_compact_rfq+0xac>
            }
         else
            {
            if (empty_slot_discovered) 
 8242448:	e0bffe83 	ldbu	r2,-6(fp)
 824244c:	10000226 	beq	r2,zero,8242458 <ip_reasm_mark_compact_rfq+0xac>
               {
               compact = IPREASM_FALSE;
 8242450:	e03ffec5 	stb	zero,-5(fp)
               break;
 8242454:	00000606 	br	8242470 <ip_reasm_mark_compact_rfq+0xc4>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242458:	e0bffe0b 	ldhu	r2,-8(fp)
 824245c:	10800044 	addi	r2,r2,1
 8242460:	e0bffe0d 	sth	r2,-8(fp)
 8242464:	e0bffe0b 	ldhu	r2,-8(fp)
 8242468:	10800430 	cmpltui	r2,r2,16
 824246c:	103feb1e 	bne	r2,zero,824241c <ip_reasm_mark_compact_rfq+0x70>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 8242470:	e0bffd17 	ldw	r2,-12(fp)
 8242474:	10800017 	ldw	r2,0(r2)
 8242478:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 824247c:	e0bffd17 	ldw	r2,-12(fp)
 8242480:	103fe41e 	bne	r2,zero,8242414 <ip_reasm_mark_compact_rfq+0x68>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 8242484:	e0bffec3 	ldbu	r2,-5(fp)
 8242488:	10000726 	beq	r2,zero,82424a8 <ip_reasm_mark_compact_rfq+0xfc>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 824248c:	e0bfff17 	ldw	r2,-4(fp)
 8242490:	10802103 	ldbu	r2,132(r2)
 8242494:	10800054 	ori	r2,r2,1
 8242498:	1007883a 	mov	r3,r2
 824249c:	e0bfff17 	ldw	r2,-4(fp)
 82424a0:	10c02105 	stb	r3,132(r2)
 82424a4:	00000706 	br	82424c4 <ip_reasm_mark_compact_rfq+0x118>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 82424a8:	e0bfff17 	ldw	r2,-4(fp)
 82424ac:	10c02103 	ldbu	r3,132(r2)
 82424b0:	00bfff84 	movi	r2,-2
 82424b4:	1884703a 	and	r2,r3,r2
 82424b8:	1007883a 	mov	r3,r2
 82424bc:	e0bfff17 	ldw	r2,-4(fp)
 82424c0:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 82424c4:	0005883a 	mov	r2,zero
}
 82424c8:	e037883a 	mov	sp,fp
 82424cc:	dfc00117 	ldw	ra,4(sp)
 82424d0:	df000017 	ldw	fp,0(sp)
 82424d4:	dec00204 	addi	sp,sp,8
 82424d8:	f800283a 	ret

082424dc <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 82424dc:	deffeb04 	addi	sp,sp,-84
 82424e0:	dfc01415 	stw	ra,80(sp)
 82424e4:	df001315 	stw	fp,76(sp)
 82424e8:	dc401215 	stw	r17,72(sp)
 82424ec:	dc001115 	stw	r16,68(sp)
 82424f0:	df001304 	addi	fp,sp,76
 82424f4:	e13ffd15 	stw	r4,-12(fp)
   unsigned long ticks_elapsed = cticks;
 82424f8:	d0a0a817 	ldw	r2,-32096(gp)
 82424fc:	e0bffb15 	stw	r2,-20(fp)
   u_short size_ire = sizeof(IRE);
 8242500:	00802204 	movi	r2,136
 8242504:	e0bffc0d 	sth	r2,-16(fp)
   u_short size_rfq = sizeof(RFQ);
 8242508:	00801904 	movi	r2,100
 824250c:	e0bffc8d 	sth	r2,-14(fp)
   IREP tmpp;
   u_short count = 0;
 8242510:	e03ff80d 	sth	zero,-32(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 8242514:	e03ffa0d 	sth	zero,-24(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 8242518:	01420974 	movhi	r5,2085
 824251c:	29436b04 	addi	r5,r5,3500
 8242520:	e13ffd17 	ldw	r4,-12(fp)
 8242524:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 8242528:	d160c717 	ldw	r5,-31972(gp)
 824252c:	e0fffb17 	ldw	r3,-20(fp)
 8242530:	00947b34 	movhi	r2,20972
 8242534:	10a147c4 	addi	r2,r2,-31457
 8242538:	1888383a 	mulxuu	r4,r3,r2
 824253c:	1885383a 	mul	r2,r3,r2
 8242540:	1021883a 	mov	r16,r2
 8242544:	2023883a 	mov	r17,r4
 8242548:	8804d17a 	srli	r2,r17,5
 824254c:	e0fffc0b 	ldhu	r3,-16(fp)
 8242550:	e13ffc8b 	ldhu	r4,-14(fp)
 8242554:	d9000215 	stw	r4,8(sp)
 8242558:	d8c00115 	stw	r3,4(sp)
 824255c:	d8800015 	stw	r2,0(sp)
 8242560:	e1fffb17 	ldw	r7,-20(fp)
 8242564:	280d883a 	mov	r6,r5
 8242568:	01420974 	movhi	r5,2085
 824256c:	29437204 	addi	r5,r5,3528
 8242570:	e13ffd17 	ldw	r4,-12(fp)
 8242574:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 8242578:	008209b4 	movhi	r2,2086
 824257c:	10b90c04 	addi	r2,r2,-7120
 8242580:	11800117 	ldw	r6,4(r2)
 8242584:	008209b4 	movhi	r2,2086
 8242588:	10b90c04 	addi	r2,r2,-7120
 824258c:	11c00017 	ldw	r7,0(r2)
 8242590:	008209b4 	movhi	r2,2086
 8242594:	10b90c04 	addi	r2,r2,-7120
 8242598:	10c00217 	ldw	r3,8(r2)
 824259c:	008209b4 	movhi	r2,2086
 82425a0:	10b90c04 	addi	r2,r2,-7120
 82425a4:	11000317 	ldw	r4,12(r2)
 82425a8:	008209b4 	movhi	r2,2086
 82425ac:	10b90c04 	addi	r2,r2,-7120
 82425b0:	11400417 	ldw	r5,16(r2)
 82425b4:	008209b4 	movhi	r2,2086
 82425b8:	10b90c04 	addi	r2,r2,-7120
 82425bc:	10800517 	ldw	r2,20(r2)
 82425c0:	d8800315 	stw	r2,12(sp)
 82425c4:	d9400215 	stw	r5,8(sp)
 82425c8:	d9000115 	stw	r4,4(sp)
 82425cc:	d8c00015 	stw	r3,0(sp)
 82425d0:	01420974 	movhi	r5,2085
 82425d4:	29438204 	addi	r5,r5,3592
 82425d8:	e13ffd17 	ldw	r4,-12(fp)
 82425dc:	8228a940 	call	8228a94 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 82425e0:	d0a0c817 	ldw	r2,-31968(gp)
 82425e4:	100d883a 	mov	r6,r2
 82425e8:	01420974 	movhi	r5,2085
 82425ec:	29439704 	addi	r5,r5,3676
 82425f0:	e13ffd17 	ldw	r4,-12(fp)
 82425f4:	8228a940 	call	8228a94 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82425f8:	d0a0c817 	ldw	r2,-31968(gp)
 82425fc:	e0bff715 	stw	r2,-36(fp)
 8242600:	00007c06 	br	82427f4 <ipr_stats+0x318>
      {
      ++count;
 8242604:	e0bff80b 	ldhu	r2,-32(fp)
 8242608:	10800044 	addi	r2,r2,1
 824260c:	e0bff80d 	sth	r2,-32(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 8242610:	e0bff717 	ldw	r2,-36(fp)
 8242614:	10800604 	addi	r2,r2,24
 8242618:	e0bff915 	stw	r2,-28(fp)
      while (rfqp)
 824261c:	00001e06 	br	8242698 <ipr_stats+0x1bc>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242620:	e03ffa8d 	sth	zero,-22(fp)
 8242624:	00001406 	br	8242678 <ipr_stats+0x19c>
            {
            if (rfqp->bufp [i] != 0)
 8242628:	e0bffa8b 	ldhu	r2,-22(fp)
 824262c:	e0fff917 	ldw	r3,-28(fp)
 8242630:	10800044 	addi	r2,r2,1
 8242634:	1085883a 	add	r2,r2,r2
 8242638:	1085883a 	add	r2,r2,r2
 824263c:	1885883a 	add	r2,r3,r2
 8242640:	10800017 	ldw	r2,0(r2)
 8242644:	10000426 	beq	r2,zero,8242658 <ipr_stats+0x17c>
               {
               ++frag_count;            
 8242648:	e0bffa0b 	ldhu	r2,-24(fp)
 824264c:	10800044 	addi	r2,r2,1
 8242650:	e0bffa0d 	sth	r2,-24(fp)
 8242654:	00000506 	br	824266c <ipr_stats+0x190>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 8242658:	e0bff717 	ldw	r2,-36(fp)
 824265c:	10802103 	ldbu	r2,132(r2)
 8242660:	10803fcc 	andi	r2,r2,255
 8242664:	1080004c 	andi	r2,r2,1
 8242668:	1000071e 	bne	r2,zero,8242688 <ipr_stats+0x1ac>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824266c:	e0bffa8b 	ldhu	r2,-22(fp)
 8242670:	10800044 	addi	r2,r2,1
 8242674:	e0bffa8d 	sth	r2,-22(fp)
 8242678:	e0bffa8b 	ldhu	r2,-22(fp)
 824267c:	10800430 	cmpltui	r2,r2,16
 8242680:	103fe91e 	bne	r2,zero,8242628 <ipr_stats+0x14c>
 8242684:	00000106 	br	824268c <ipr_stats+0x1b0>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
                  {
                  break;
 8242688:	0001883a 	nop
                  }
               }
            }
         rfqp = rfqp->next;
 824268c:	e0bff917 	ldw	r2,-28(fp)
 8242690:	10800017 	ldw	r2,0(r2)
 8242694:	e0bff915 	stw	r2,-28(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 8242698:	e0bff917 	ldw	r2,-28(fp)
 824269c:	103fe01e 	bne	r2,zero,8242620 <ipr_stats+0x144>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 82426a0:	e33ffa0b 	ldhu	r12,-24(fp)
 82426a4:	e0bff717 	ldw	r2,-36(fp)
 82426a8:	10800117 	ldw	r2,4(r2)
 82426ac:	1006d63a 	srli	r3,r2,24
 82426b0:	e0bff717 	ldw	r2,-36(fp)
 82426b4:	10800117 	ldw	r2,4(r2)
 82426b8:	1004d23a 	srli	r2,r2,8
 82426bc:	10bfc00c 	andi	r2,r2,65280
 82426c0:	1886b03a 	or	r3,r3,r2
 82426c4:	e0bff717 	ldw	r2,-36(fp)
 82426c8:	10800117 	ldw	r2,4(r2)
 82426cc:	10bfc00c 	andi	r2,r2,65280
 82426d0:	1004923a 	slli	r2,r2,8
 82426d4:	1886b03a 	or	r3,r3,r2
 82426d8:	e0bff717 	ldw	r2,-36(fp)
 82426dc:	10800117 	ldw	r2,4(r2)
 82426e0:	1004963a 	slli	r2,r2,24
 82426e4:	1884b03a 	or	r2,r3,r2
 82426e8:	e0fff717 	ldw	r3,-36(fp)
 82426ec:	18c00217 	ldw	r3,8(r3)
 82426f0:	1808d63a 	srli	r4,r3,24
 82426f4:	e0fff717 	ldw	r3,-36(fp)
 82426f8:	18c00217 	ldw	r3,8(r3)
 82426fc:	1806d23a 	srli	r3,r3,8
 8242700:	18ffc00c 	andi	r3,r3,65280
 8242704:	20c8b03a 	or	r4,r4,r3
 8242708:	e0fff717 	ldw	r3,-36(fp)
 824270c:	18c00217 	ldw	r3,8(r3)
 8242710:	18ffc00c 	andi	r3,r3,65280
 8242714:	1806923a 	slli	r3,r3,8
 8242718:	20c8b03a 	or	r4,r4,r3
 824271c:	e0fff717 	ldw	r3,-36(fp)
 8242720:	18c00217 	ldw	r3,8(r3)
 8242724:	1806963a 	slli	r3,r3,24
 8242728:	20c6b03a 	or	r3,r4,r3
 824272c:	e13ff717 	ldw	r4,-36(fp)
 8242730:	21000383 	ldbu	r4,14(r4)
 8242734:	21003fcc 	andi	r4,r4,255
 8242738:	e17ff717 	ldw	r5,-36(fp)
 824273c:	2940030b 	ldhu	r5,12(r5)
 8242740:	297fffcc 	andi	r5,r5,65535
 8242744:	280ad23a 	srli	r5,r5,8
 8242748:	297fffcc 	andi	r5,r5,65535
 824274c:	29803fcc 	andi	r6,r5,255
 8242750:	e17ff717 	ldw	r5,-36(fp)
 8242754:	2940030b 	ldhu	r5,12(r5)
 8242758:	297fffcc 	andi	r5,r5,65535
 824275c:	280a923a 	slli	r5,r5,8
 8242760:	297fffcc 	andi	r5,r5,65535
 8242764:	314ab03a 	or	r5,r6,r5
 8242768:	e1bff717 	ldw	r6,-36(fp)
 824276c:	3180040b 	ldhu	r6,16(r6)
 8242770:	31bfffcc 	andi	r6,r6,65535
 8242774:	e1fff717 	ldw	r7,-36(fp)
 8242778:	39c0048b 	ldhu	r7,18(r7)
 824277c:	39ffffcc 	andi	r7,r7,65535
 8242780:	e23ff717 	ldw	r8,-36(fp)
 8242784:	42000517 	ldw	r8,20(r8)
 8242788:	e27ff717 	ldw	r9,-36(fp)
 824278c:	4a401f17 	ldw	r9,124(r9)
 8242790:	e2bff717 	ldw	r10,-36(fp)
 8242794:	52802017 	ldw	r10,128(r10)
 8242798:	e2fff717 	ldw	r11,-36(fp)
 824279c:	5ac02103 	ldbu	r11,132(r11)
 82427a0:	5ac03fcc 	andi	r11,r11,255
 82427a4:	5ac0004c 	andi	r11,r11,1
 82427a8:	dac00915 	stw	r11,36(sp)
 82427ac:	da800815 	stw	r10,32(sp)
 82427b0:	da400715 	stw	r9,28(sp)
 82427b4:	da000615 	stw	r8,24(sp)
 82427b8:	d9c00515 	stw	r7,20(sp)
 82427bc:	d9800415 	stw	r6,16(sp)
 82427c0:	d9400315 	stw	r5,12(sp)
 82427c4:	d9000215 	stw	r4,8(sp)
 82427c8:	d8c00115 	stw	r3,4(sp)
 82427cc:	d8800015 	stw	r2,0(sp)
 82427d0:	600f883a 	mov	r7,r12
 82427d4:	e1bff717 	ldw	r6,-36(fp)
 82427d8:	01420974 	movhi	r5,2085
 82427dc:	29439d04 	addi	r5,r5,3700
 82427e0:	e13ffd17 	ldw	r4,-12(fp)
 82427e4:	8228a940 	call	8228a94 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82427e8:	e0bff717 	ldw	r2,-36(fp)
 82427ec:	10800017 	ldw	r2,0(r2)
 82427f0:	e0bff715 	stw	r2,-36(fp)
 82427f4:	e0bff717 	ldw	r2,-36(fp)
 82427f8:	103f821e 	bne	r2,zero,8242604 <ipr_stats+0x128>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 82427fc:	e0bff80b 	ldhu	r2,-32(fp)
 8242800:	100d883a 	mov	r6,r2
 8242804:	01420974 	movhi	r5,2085
 8242808:	2943b804 	addi	r5,r5,3808
 824280c:	e13ffd17 	ldw	r4,-12(fp)
 8242810:	8228a940 	call	8228a94 <ns_printf>

   return IPREASM_OK;
 8242814:	0005883a 	mov	r2,zero
}
 8242818:	e6fffe04 	addi	sp,fp,-8
 824281c:	dfc00317 	ldw	ra,12(sp)
 8242820:	df000217 	ldw	fp,8(sp)
 8242824:	dc400117 	ldw	r17,4(sp)
 8242828:	dc000017 	ldw	r16,0(sp)
 824282c:	dec00404 	addi	sp,sp,16
 8242830:	f800283a 	ret

08242834 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 8242834:	defffc04 	addi	sp,sp,-16
 8242838:	dfc00315 	stw	ra,12(sp)
 824283c:	df000215 	stw	fp,8(sp)
 8242840:	df000204 	addi	fp,sp,8
 8242844:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 8242848:	e0bfff17 	ldw	r2,-4(fp)
 824284c:	10801f17 	ldw	r2,124(r2)
 8242850:	10000626 	beq	r2,zero,824286c <ip_reasm_send_icmp_timex+0x38>
      {
      pip = (struct ip *) irep->l3_hdr;
 8242854:	e0bfff17 	ldw	r2,-4(fp)
 8242858:	10802017 	ldw	r2,128(r2)
 824285c:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 8242860:	01400044 	movi	r5,1
 8242864:	e13ffe17 	ldw	r4,-8(fp)
 8242868:	824adc00 	call	824adc0 <icmp_timex>
      }

   return IPREASM_OK;
 824286c:	0005883a 	mov	r2,zero
}
 8242870:	e037883a 	mov	sp,fp
 8242874:	dfc00117 	ldw	ra,4(sp)
 8242878:	df000017 	ldw	fp,0(sp)
 824287c:	dec00204 	addi	sp,sp,8
 8242880:	f800283a 	ret

08242884 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 8242884:	defff404 	addi	sp,sp,-48
 8242888:	dfc00b15 	stw	ra,44(sp)
 824288c:	df000a15 	stw	fp,40(sp)
 8242890:	dc000915 	stw	r16,36(sp)
 8242894:	df000a04 	addi	fp,sp,40
 8242898:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 824289c:	00bfffc4 	movi	r2,-1
 82428a0:	e0bff715 	stw	r2,-36(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 82428a4:	d0a08317 	ldw	r2,-32244(gp)
 82428a8:	1081000c 	andi	r2,r2,1024
 82428ac:	10000e26 	beq	r2,zero,82428e8 <ip_rcv+0x64>
 82428b0:	d0a08317 	ldw	r2,-32244(gp)
 82428b4:	1080800c 	andi	r2,r2,512
 82428b8:	10000b26 	beq	r2,zero,82428e8 <ip_rcv+0x64>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
         p->nb_plen, net_num(p->net));
 82428bc:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 82428c0:	14000417 	ldw	r16,16(r2)
         p->nb_plen, net_num(p->net));
 82428c4:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 82428c8:	10800617 	ldw	r2,24(r2)
 82428cc:	1009883a 	mov	r4,r2
 82428d0:	822689c0 	call	822689c <if_netnumber>
 82428d4:	100d883a 	mov	r6,r2
 82428d8:	800b883a 	mov	r5,r16
 82428dc:	01020974 	movhi	r4,2085
 82428e0:	2103c104 	addi	r4,r4,3844
 82428e4:	8202e9c0 	call	8202e9c <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   ip_mib.ipInReceives++;
 82428e8:	008209b4 	movhi	r2,2086
 82428ec:	10b8f804 	addi	r2,r2,-7200
 82428f0:	10800217 	ldw	r2,8(r2)
 82428f4:	10c00044 	addi	r3,r2,1
 82428f8:	008209b4 	movhi	r2,2086
 82428fc:	10b8f804 	addi	r2,r2,-7200
 8242900:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 8242904:	e0bffe17 	ldw	r2,-8(fp)
 8242908:	10800317 	ldw	r2,12(r2)
 824290c:	e0bff815 	stw	r2,-32(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 8242910:	e0bffe17 	ldw	r2,-8(fp)
 8242914:	10800417 	ldw	r2,16(r2)
 8242918:	e0fff817 	ldw	r3,-32(fp)
 824291c:	18c0008b 	ldhu	r3,2(r3)
 8242920:	18ffffcc 	andi	r3,r3,65535
 8242924:	1806d23a 	srli	r3,r3,8
 8242928:	18ffffcc 	andi	r3,r3,65535
 824292c:	19003fcc 	andi	r4,r3,255
 8242930:	e0fff817 	ldw	r3,-32(fp)
 8242934:	18c0008b 	ldhu	r3,2(r3)
 8242938:	18ffffcc 	andi	r3,r3,65535
 824293c:	1806923a 	slli	r3,r3,8
 8242940:	18ffffcc 	andi	r3,r3,65535
 8242944:	20c6b03a 	or	r3,r4,r3
 8242948:	10c01f2e 	bgeu	r2,r3,82429c8 <ip_rcv+0x144>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824294c:	d0a08317 	ldw	r2,-32244(gp)
 8242950:	1081000c 	andi	r2,r2,1024
 8242954:	10000c26 	beq	r2,zero,8242988 <ip_rcv+0x104>
 8242958:	d0a08317 	ldw	r2,-32244(gp)
 824295c:	1080800c 	andi	r2,r2,512
 8242960:	10000926 	beq	r2,zero,8242988 <ip_rcv+0x104>
      {
         dprintf("ip_rcv: bad pkt len\n");
 8242964:	01020974 	movhi	r4,2085
 8242968:	2103ca04 	addi	r4,r4,3880
 824296c:	82031200 	call	8203120 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242970:	d0a08317 	ldw	r2,-32244(gp)
 8242974:	1080008c 	andi	r2,r2,2
 8242978:	10000326 	beq	r2,zero,8242988 <ip_rcv+0x104>
 824297c:	e0bffe17 	ldw	r2,-8(fp)
 8242980:	1009883a 	mov	r4,r2
 8242984:	82406940 	call	8240694 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242988:	008209b4 	movhi	r2,2086
 824298c:	10b8f804 	addi	r2,r2,-7200
 8242990:	10800317 	ldw	r2,12(r2)
 8242994:	10c00044 	addi	r3,r2,1
 8242998:	008209b4 	movhi	r2,2086
 824299c:	10b8f804 	addi	r2,r2,-7200
 82429a0:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 82429a4:	01000084 	movi	r4,2
 82429a8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 82429ac:	e0bffe17 	ldw	r2,-8(fp)
 82429b0:	1009883a 	mov	r4,r2
 82429b4:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82429b8:	01000084 	movi	r4,2
 82429bc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 82429c0:	00bff804 	movi	r2,-32
 82429c4:	00008906 	br	8242bec <ip_rcv+0x368>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 82429c8:	e0bff817 	ldw	r2,-32(fp)
 82429cc:	1080008b 	ldhu	r2,2(r2)
 82429d0:	10bfffcc 	andi	r2,r2,65535
 82429d4:	1004d23a 	srli	r2,r2,8
 82429d8:	10bfffcc 	andi	r2,r2,65535
 82429dc:	10c03fcc 	andi	r3,r2,255
 82429e0:	e0bff817 	ldw	r2,-32(fp)
 82429e4:	1080008b 	ldhu	r2,2(r2)
 82429e8:	10bfffcc 	andi	r2,r2,65535
 82429ec:	1004923a 	slli	r2,r2,8
 82429f0:	10bfffcc 	andi	r2,r2,65535
 82429f4:	1884b03a 	or	r2,r3,r2
 82429f8:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 82429fc:	e0bffe17 	ldw	r2,-8(fp)
 8242a00:	e0fff917 	ldw	r3,-28(fp)
 8242a04:	10c00415 	stw	r3,16(r2)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 8242a08:	e0bff817 	ldw	r2,-32(fp)
 8242a0c:	10800003 	ldbu	r2,0(r2)
 8242a10:	10803fcc 	andi	r2,r2,255
 8242a14:	1004d13a 	srli	r2,r2,4
 8242a18:	10803fcc 	andi	r2,r2,255
 8242a1c:	10800120 	cmpeqi	r2,r2,4
 8242a20:	10001f1e 	bne	r2,zero,8242aa0 <ip_rcv+0x21c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242a24:	d0a08317 	ldw	r2,-32244(gp)
 8242a28:	1081000c 	andi	r2,r2,1024
 8242a2c:	10000c26 	beq	r2,zero,8242a60 <ip_rcv+0x1dc>
 8242a30:	d0a08317 	ldw	r2,-32244(gp)
 8242a34:	1080800c 	andi	r2,r2,512
 8242a38:	10000926 	beq	r2,zero,8242a60 <ip_rcv+0x1dc>
      {
         dprintf("ip_rcv: bad version number\n");
 8242a3c:	01020974 	movhi	r4,2085
 8242a40:	2103cf04 	addi	r4,r4,3900
 8242a44:	82031200 	call	8203120 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242a48:	d0a08317 	ldw	r2,-32244(gp)
 8242a4c:	1080008c 	andi	r2,r2,2
 8242a50:	10000326 	beq	r2,zero,8242a60 <ip_rcv+0x1dc>
 8242a54:	e0bffe17 	ldw	r2,-8(fp)
 8242a58:	1009883a 	mov	r4,r2
 8242a5c:	82406940 	call	8240694 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242a60:	008209b4 	movhi	r2,2086
 8242a64:	10b8f804 	addi	r2,r2,-7200
 8242a68:	10800317 	ldw	r2,12(r2)
 8242a6c:	10c00044 	addi	r3,r2,1
 8242a70:	008209b4 	movhi	r2,2086
 8242a74:	10b8f804 	addi	r2,r2,-7200
 8242a78:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242a7c:	01000084 	movi	r4,2
 8242a80:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242a84:	e0bffe17 	ldw	r2,-8(fp)
 8242a88:	1009883a 	mov	r4,r2
 8242a8c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242a90:	01000084 	movi	r4,2
 8242a94:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242a98:	00bff804 	movi	r2,-32
 8242a9c:	00005306 	br	8242bec <ip_rcv+0x368>
   }

   csum = pip->ip_chksum;
 8242aa0:	e0bff817 	ldw	r2,-32(fp)
 8242aa4:	1080028b 	ldhu	r2,10(r2)
 8242aa8:	e0bffa0d 	sth	r2,-24(fp)
   pip->ip_chksum = 0;
 8242aac:	e0bff817 	ldw	r2,-32(fp)
 8242ab0:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 8242ab4:	e0bff817 	ldw	r2,-32(fp)
 8242ab8:	10800003 	ldbu	r2,0(r2)
 8242abc:	10803fcc 	andi	r2,r2,255
 8242ac0:	108003cc 	andi	r2,r2,15
 8242ac4:	1085883a 	add	r2,r2,r2
 8242ac8:	1085883a 	add	r2,r2,r2
 8242acc:	e0bffb15 	stw	r2,-20(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 8242ad0:	e0bffb17 	ldw	r2,-20(fp)
 8242ad4:	1004d07a 	srli	r2,r2,1
 8242ad8:	100b883a 	mov	r5,r2
 8242adc:	e13ff817 	ldw	r4,-32(fp)
 8242ae0:	82283e80 	call	82283e8 <cksum>
 8242ae4:	0084303a 	nor	r2,zero,r2
 8242ae8:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 8242aec:	e0fffa0b 	ldhu	r3,-24(fp)
 8242af0:	e0bffc0b 	ldhu	r2,-16(fp)
 8242af4:	18802226 	beq	r3,r2,8242b80 <ip_rcv+0x2fc>
   {
      pip->ip_chksum = csum;
 8242af8:	e0bff817 	ldw	r2,-32(fp)
 8242afc:	e0fffa0b 	ldhu	r3,-24(fp)
 8242b00:	10c0028d 	sth	r3,10(r2)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242b04:	d0a08317 	ldw	r2,-32244(gp)
 8242b08:	1081000c 	andi	r2,r2,1024
 8242b0c:	10000c26 	beq	r2,zero,8242b40 <ip_rcv+0x2bc>
 8242b10:	d0a08317 	ldw	r2,-32244(gp)
 8242b14:	1080800c 	andi	r2,r2,512
 8242b18:	10000926 	beq	r2,zero,8242b40 <ip_rcv+0x2bc>
      {
         dprintf("ip_rcv: bad xsum\n");
 8242b1c:	01020974 	movhi	r4,2085
 8242b20:	2103d604 	addi	r4,r4,3928
 8242b24:	82031200 	call	8203120 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242b28:	d0a08317 	ldw	r2,-32244(gp)
 8242b2c:	1080008c 	andi	r2,r2,2
 8242b30:	10000326 	beq	r2,zero,8242b40 <ip_rcv+0x2bc>
 8242b34:	e0bffe17 	ldw	r2,-8(fp)
 8242b38:	1009883a 	mov	r4,r2
 8242b3c:	82406940 	call	8240694 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242b40:	008209b4 	movhi	r2,2086
 8242b44:	10b8f804 	addi	r2,r2,-7200
 8242b48:	10800317 	ldw	r2,12(r2)
 8242b4c:	10c00044 	addi	r3,r2,1
 8242b50:	008209b4 	movhi	r2,2086
 8242b54:	10b8f804 	addi	r2,r2,-7200
 8242b58:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242b5c:	01000084 	movi	r4,2
 8242b60:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242b64:	e0bffe17 	ldw	r2,-8(fp)
 8242b68:	1009883a 	mov	r4,r2
 8242b6c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242b70:	01000084 	movi	r4,2
 8242b74:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242b78:	00bff804 	movi	r2,-32
 8242b7c:	00001b06 	br	8242bec <ip_rcv+0x368>
   }

   pip->ip_chksum = csum;
 8242b80:	e0bff817 	ldw	r2,-32(fp)
 8242b84:	e0fffa0b 	ldhu	r3,-24(fp)
 8242b88:	10c0028d 	sth	r3,10(r2)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 8242b8c:	00800044 	movi	r2,1
 8242b90:	e0bffc8d 	sth	r2,-14(fp)
    pktp = &p;
 8242b94:	e0bffe04 	addi	r2,fp,-8
 8242b98:	e0bffd15 	stw	r2,-12(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242b9c:	e03ff605 	stb	zero,-40(fp)
 8242ba0:	00000d06 	br	8242bd8 <ip_rcv+0x354>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 8242ba4:	e0bff603 	ldbu	r2,-40(fp)
 8242ba8:	1085883a 	add	r2,r2,r2
 8242bac:	1085883a 	add	r2,r2,r2
 8242bb0:	1007883a 	mov	r3,r2
 8242bb4:	e0bffd17 	ldw	r2,-12(fp)
 8242bb8:	10c5883a 	add	r2,r2,r3
 8242bbc:	10800017 	ldw	r2,0(r2)
 8242bc0:	1009883a 	mov	r4,r2
 8242bc4:	8242c040 	call	8242c04 <ip_rcv_phase2>
 8242bc8:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242bcc:	e0bff603 	ldbu	r2,-40(fp)
 8242bd0:	10800044 	addi	r2,r2,1
 8242bd4:	e0bff605 	stb	r2,-40(fp)
 8242bd8:	e0bff603 	ldbu	r2,-40(fp)
 8242bdc:	10ffffcc 	andi	r3,r2,65535
 8242be0:	e0bffc8b 	ldhu	r2,-14(fp)
 8242be4:	18bfef36 	bltu	r3,r2,8242ba4 <ip_rcv+0x320>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 8242be8:	e0bff717 	ldw	r2,-36(fp)
}
 8242bec:	e6ffff04 	addi	sp,fp,-4
 8242bf0:	dfc00217 	ldw	ra,8(sp)
 8242bf4:	df000117 	ldw	fp,4(sp)
 8242bf8:	dc000017 	ldw	r16,0(sp)
 8242bfc:	dec00304 	addi	sp,sp,12
 8242c00:	f800283a 	ret

08242c04 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 8242c04:	defff504 	addi	sp,sp,-44
 8242c08:	dfc00a15 	stw	ra,40(sp)
 8242c0c:	df000915 	stw	fp,36(sp)
 8242c10:	df000904 	addi	fp,sp,36
 8242c14:	e13fff15 	stw	r4,-4(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 8242c18:	e0bfff17 	ldw	r2,-4(fp)
 8242c1c:	10800317 	ldw	r2,12(r2)
 8242c20:	e0bff815 	stw	r2,-32(fp)
   nt = p->net;      /* which interface it came in on */
 8242c24:	e0bfff17 	ldw	r2,-4(fp)
 8242c28:	10800617 	ldw	r2,24(r2)
 8242c2c:	e0bff915 	stw	r2,-28(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 8242c30:	e0bff817 	ldw	r2,-32(fp)
 8242c34:	10800417 	ldw	r2,16(r2)
 8242c38:	1006d63a 	srli	r3,r2,24
 8242c3c:	e0bff817 	ldw	r2,-32(fp)
 8242c40:	10800417 	ldw	r2,16(r2)
 8242c44:	1004d23a 	srli	r2,r2,8
 8242c48:	10bfc00c 	andi	r2,r2,65280
 8242c4c:	1886b03a 	or	r3,r3,r2
 8242c50:	e0bff817 	ldw	r2,-32(fp)
 8242c54:	10800417 	ldw	r2,16(r2)
 8242c58:	10bfc00c 	andi	r2,r2,65280
 8242c5c:	1004923a 	slli	r2,r2,8
 8242c60:	1886b03a 	or	r3,r3,r2
 8242c64:	e0bff817 	ldw	r2,-32(fp)
 8242c68:	10800417 	ldw	r2,16(r2)
 8242c6c:	1004963a 	slli	r2,r2,24
 8242c70:	1884b03a 	or	r2,r3,r2
 8242c74:	10fc002c 	andhi	r3,r2,61440
 8242c78:	00b80034 	movhi	r2,57344
 8242c7c:	1880171e 	bne	r3,r2,8242cdc <ip_rcv_phase2+0xd8>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 8242c80:	e0bff817 	ldw	r2,-32(fp)
 8242c84:	10800417 	ldw	r2,16(r2)
 8242c88:	e17ff917 	ldw	r5,-28(fp)
 8242c8c:	1009883a 	mov	r4,r2
 8242c90:	82437fc0 	call	82437fc <lookup_mcast>
 8242c94:	e0bffa15 	stw	r2,-24(fp)
      if (inm == NULL) 
 8242c98:	e0bffa17 	ldw	r2,-24(fp)
 8242c9c:	1001081e 	bne	r2,zero,82430c0 <ip_rcv_phase2+0x4bc>
      {
         ip_mib.ipOutNoRoutes++;
 8242ca0:	008209b4 	movhi	r2,2086
 8242ca4:	10b8f804 	addi	r2,r2,-7200
 8242ca8:	10800b17 	ldw	r2,44(r2)
 8242cac:	10c00044 	addi	r3,r2,1
 8242cb0:	008209b4 	movhi	r2,2086
 8242cb4:	10b8f804 	addi	r2,r2,-7200
 8242cb8:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8242cbc:	01000084 	movi	r4,2
 8242cc0:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 8242cc4:	e13fff17 	ldw	r4,-4(fp)
 8242cc8:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242ccc:	01000084 	movi	r4,2
 8242cd0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 8242cd4:	00800084 	movi	r2,2
 8242cd8:	00013806 	br	82431bc <ip_rcv_phase2+0x5b8>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8242cdc:	e0bff817 	ldw	r2,-32(fp)
 8242ce0:	10c00417 	ldw	r3,16(r2)
 8242ce4:	e0bff917 	ldw	r2,-28(fp)
 8242ce8:	10800a17 	ldw	r2,40(r2)
 8242cec:	1880f726 	beq	r3,r2,82430cc <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8242cf0:	e0bff817 	ldw	r2,-32(fp)
 8242cf4:	10800417 	ldw	r2,16(r2)
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8242cf8:	10bfffe0 	cmpeqi	r2,r2,-1
 8242cfc:	1000f31e 	bne	r2,zero,82430cc <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8242d00:	e0bff817 	ldw	r2,-32(fp)
 8242d04:	10c00417 	ldw	r3,16(r2)
 8242d08:	e0bff917 	ldw	r2,-28(fp)
 8242d0c:	10800e17 	ldw	r2,56(r2)
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8242d10:	1880ee26 	beq	r3,r2,82430cc <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8242d14:	e0bff817 	ldw	r2,-32(fp)
 8242d18:	10c00417 	ldw	r3,16(r2)
 8242d1c:	e0bff917 	ldw	r2,-28(fp)
 8242d20:	10800f17 	ldw	r2,60(r2)
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8242d24:	1880e926 	beq	r3,r2,82430cc <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8242d28:	e0bff817 	ldw	r2,-32(fp)
 8242d2c:	10c00417 	ldw	r3,16(r2)
 8242d30:	e0bff917 	ldw	r2,-28(fp)
 8242d34:	10801017 	ldw	r2,64(r2)
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8242d38:	1880e426 	beq	r3,r2,82430cc <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
 8242d3c:	e0bff917 	ldw	r2,-28(fp)
 8242d40:	10c00a17 	ldw	r3,40(r2)
 8242d44:	e0bff917 	ldw	r2,-28(fp)
 8242d48:	10800c17 	ldw	r2,48(r2)
 8242d4c:	0084303a 	nor	r2,zero,r2
 8242d50:	1884703a 	and	r2,r3,r2

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8242d54:	1000dd26 	beq	r2,zero,82430cc <ip_rcv_phase2+0x4c8>
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242d58:	d0a08317 	ldw	r2,-32244(gp)
 8242d5c:	1081000c 	andi	r2,r2,1024
 8242d60:	10001826 	beq	r2,zero,8242dc4 <ip_rcv_phase2+0x1c0>
 8242d64:	d0a08317 	ldw	r2,-32244(gp)
 8242d68:	1080800c 	andi	r2,r2,512
 8242d6c:	10001526 	beq	r2,zero,8242dc4 <ip_rcv_phase2+0x1c0>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
       PUSH_IPADDR(pip->ip_dest));
 8242d70:	e0bff817 	ldw	r2,-32(fp)
 8242d74:	10800417 	ldw	r2,16(r2)
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242d78:	10c03fcc 	andi	r3,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242d7c:	e0bff817 	ldw	r2,-32(fp)
 8242d80:	10800417 	ldw	r2,16(r2)
 8242d84:	1004d23a 	srli	r2,r2,8
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242d88:	11003fcc 	andi	r4,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242d8c:	e0bff817 	ldw	r2,-32(fp)
 8242d90:	10800417 	ldw	r2,16(r2)
 8242d94:	1004d43a 	srli	r2,r2,16
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242d98:	11403fcc 	andi	r5,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242d9c:	e0bff817 	ldw	r2,-32(fp)
 8242da0:	10800417 	ldw	r2,16(r2)
 8242da4:	1004d63a 	srli	r2,r2,24
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242da8:	d8800015 	stw	r2,0(sp)
 8242dac:	280f883a 	mov	r7,r5
 8242db0:	200d883a 	mov	r6,r4
 8242db4:	180b883a 	mov	r5,r3
 8242db8:	01020974 	movhi	r4,2085
 8242dbc:	2103db04 	addi	r4,r4,3948
 8242dc0:	8202e9c0 	call	8202e9c <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 8242dc4:	008209b4 	movhi	r2,2086
 8242dc8:	10b8f804 	addi	r2,r2,-7200
 8242dcc:	10800017 	ldw	r2,0(r2)
 8242dd0:	10800098 	cmpnei	r2,r2,2
 8242dd4:	10000f1e 	bne	r2,zero,8242e14 <ip_rcv_phase2+0x210>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8242dd8:	008209b4 	movhi	r2,2086
 8242ddc:	10b8f804 	addi	r2,r2,-7200
 8242de0:	10800a17 	ldw	r2,40(r2)
 8242de4:	10c00044 	addi	r3,r2,1
 8242de8:	008209b4 	movhi	r2,2086
 8242dec:	10b8f804 	addi	r2,r2,-7200
 8242df0:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8242df4:	01000084 	movi	r4,2
 8242df8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
         pk_free(p);
 8242dfc:	e13fff17 	ldw	r4,-4(fp)
 8242e00:	822c9700 	call	822c970 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242e04:	01000084 	movi	r4,2
 8242e08:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 8242e0c:	00bff7c4 	movi	r2,-33
 8242e10:	0000ea06 	br	82431bc <ip_rcv_phase2+0x5b8>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 8242e14:	008209b4 	movhi	r2,2086
 8242e18:	10b8f804 	addi	r2,r2,-7200
 8242e1c:	10800517 	ldw	r2,20(r2)
 8242e20:	10c00044 	addi	r3,r2,1
 8242e24:	008209b4 	movhi	r2,2086
 8242e28:	10b8f804 	addi	r2,r2,-7200
 8242e2c:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 8242e30:	e0bff817 	ldw	r2,-32(fp)
 8242e34:	10800203 	ldbu	r2,8(r2)
 8242e38:	10803fcc 	andi	r2,r2,255
 8242e3c:	108000a8 	cmpgeui	r2,r2,2
 8242e40:	10001c1e 	bne	r2,zero,8242eb4 <ip_rcv_phase2+0x2b0>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8242e44:	008209b4 	movhi	r2,2086
 8242e48:	10b8f804 	addi	r2,r2,-7200
 8242e4c:	10800a17 	ldw	r2,40(r2)
 8242e50:	10c00044 	addi	r3,r2,1
 8242e54:	008209b4 	movhi	r2,2086
 8242e58:	10b8f804 	addi	r2,r2,-7200
 8242e5c:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 8242e60:	e0bff817 	ldw	r2,-32(fp)
 8242e64:	10c00317 	ldw	r3,12(r2)
 8242e68:	e0bfff17 	ldw	r2,-4(fp)
 8242e6c:	10800617 	ldw	r2,24(r2)
 8242e70:	11000a17 	ldw	r4,40(r2)
 8242e74:	e0bfff17 	ldw	r2,-4(fp)
 8242e78:	10800617 	ldw	r2,24(r2)
 8242e7c:	d8800015 	stw	r2,0(sp)
 8242e80:	01c2c004 	movi	r7,2816
 8242e84:	e1bff817 	ldw	r6,-32(fp)
 8242e88:	200b883a 	mov	r5,r4
 8242e8c:	1809883a 	mov	r4,r3
 8242e90:	824aac00 	call	824aac0 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8242e94:	01000084 	movi	r4,2
 8242e98:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(p);
 8242e9c:	e13fff17 	ldw	r4,-4(fp)
 8242ea0:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242ea4:	01000084 	movi	r4,2
 8242ea8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8242eac:	00bff7c4 	movi	r2,-33
 8242eb0:	0000c206 	br	82431bc <ip_rcv_phase2+0x5b8>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 8242eb4:	e0bff817 	ldw	r2,-32(fp)
 8242eb8:	10c00417 	ldw	r3,16(r2)
 8242ebc:	e0bfff17 	ldw	r2,-4(fp)
 8242ec0:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 8242ec4:	e0bfff17 	ldw	r2,-4(fp)
 8242ec8:	10800717 	ldw	r2,28(r2)
 8242ecc:	e0fffe04 	addi	r3,fp,-8
 8242ed0:	180b883a 	mov	r5,r3
 8242ed4:	1009883a 	mov	r4,r2
 8242ed8:	824093c0 	call	824093c <iproute>
 8242edc:	e0bffb15 	stw	r2,-20(fp)
 8242ee0:	e0bffb17 	ldw	r2,-20(fp)
 8242ee4:	10000f1e 	bne	r2,zero,8242f24 <ip_rcv_phase2+0x320>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 8242ee8:	008209b4 	movhi	r2,2086
 8242eec:	10b8f804 	addi	r2,r2,-7200
 8242ef0:	10800b17 	ldw	r2,44(r2)
 8242ef4:	10c00044 	addi	r3,r2,1
 8242ef8:	008209b4 	movhi	r2,2086
 8242efc:	10b8f804 	addi	r2,r2,-7200
 8242f00:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8242f04:	01000084 	movi	r4,2
 8242f08:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
            pk_free(p);
 8242f0c:	e13fff17 	ldw	r4,-4(fp)
 8242f10:	822c9700 	call	822c970 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242f14:	01000084 	movi	r4,2
 8242f18:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8242f1c:	00bff7c4 	movi	r2,-33
 8242f20:	0000a606 	br	82431bc <ip_rcv_phase2+0x5b8>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 8242f24:	e0bff817 	ldw	r2,-32(fp)
 8242f28:	10c00417 	ldw	r3,16(r2)
 8242f2c:	e0bffb17 	ldw	r2,-20(fp)
 8242f30:	10800a17 	ldw	r2,40(r2)
 8242f34:	18806426 	beq	r3,r2,82430c8 <ip_rcv_phase2+0x4c4>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8242f38:	e0bff817 	ldw	r2,-32(fp)
 8242f3c:	10c00417 	ldw	r3,16(r2)
 8242f40:	e0bffb17 	ldw	r2,-20(fp)
 8242f44:	10800e17 	ldw	r2,56(r2)
 8242f48:	18806026 	beq	r3,r2,82430cc <ip_rcv_phase2+0x4c8>
            (pip->ip_dest == p->net->n_netbr))
 8242f4c:	e0bff817 	ldw	r2,-32(fp)
 8242f50:	10c00417 	ldw	r3,16(r2)
 8242f54:	e0bfff17 	ldw	r2,-4(fp)
 8242f58:	10800617 	ldw	r2,24(r2)
 8242f5c:	10800e17 	ldw	r2,56(r2)
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8242f60:	18805a26 	beq	r3,r2,82430cc <ip_rcv_phase2+0x4c8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 8242f64:	e0bfff17 	ldw	r2,-4(fp)
 8242f68:	e0fffb17 	ldw	r3,-20(fp)
 8242f6c:	10c00615 	stw	r3,24(r2)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 8242f70:	e0bfff17 	ldw	r2,-4(fp)
 8242f74:	10800417 	ldw	r2,16(r2)
 8242f78:	e0ffff17 	ldw	r3,-4(fp)
 8242f7c:	18c00617 	ldw	r3,24(r3)
 8242f80:	18c00817 	ldw	r3,32(r3)
 8242f84:	10c5883a 	add	r2,r2,r3
 8242f88:	e0fffb17 	ldw	r3,-20(fp)
 8242f8c:	18c00917 	ldw	r3,36(r3)
 8242f90:	1880372e 	bgeu	r3,r2,8243070 <ip_rcv_phase2+0x46c>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 8242f94:	e0bff817 	ldw	r2,-32(fp)
 8242f98:	1080018b 	ldhu	r2,6(r2)
 8242f9c:	10bfffcc 	andi	r2,r2,65535
 8242fa0:	1004d23a 	srli	r2,r2,8
 8242fa4:	10bfffcc 	andi	r2,r2,65535
 8242fa8:	10c03fcc 	andi	r3,r2,255
 8242fac:	e0bff817 	ldw	r2,-32(fp)
 8242fb0:	1080018b 	ldhu	r2,6(r2)
 8242fb4:	10bfffcc 	andi	r2,r2,65535
 8242fb8:	1004923a 	slli	r2,r2,8
 8242fbc:	10bfffcc 	andi	r2,r2,65535
 8242fc0:	1884b03a 	or	r2,r3,r2
 8242fc4:	1090000c 	andi	r2,r2,16384
 8242fc8:	10001c26 	beq	r2,zero,824303c <ip_rcv_phase2+0x438>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 8242fcc:	e0bff817 	ldw	r2,-32(fp)
 8242fd0:	10c00317 	ldw	r3,12(r2)
 8242fd4:	e0bfff17 	ldw	r2,-4(fp)
 8242fd8:	10800617 	ldw	r2,24(r2)
 8242fdc:	11000a17 	ldw	r4,40(r2)
 8242fe0:	e0bfff17 	ldw	r2,-4(fp)
 8242fe4:	10800617 	ldw	r2,24(r2)
 8242fe8:	d8800015 	stw	r2,0(sp)
 8242fec:	01c00104 	movi	r7,4
 8242ff0:	e1bff817 	ldw	r6,-32(fp)
 8242ff4:	200b883a 	mov	r5,r4
 8242ff8:	1809883a 	mov	r4,r3
 8242ffc:	824aac00 	call	824aac0 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 8243000:	008209b4 	movhi	r2,2086
 8243004:	10b8f804 	addi	r2,r2,-7200
 8243008:	10801117 	ldw	r2,68(r2)
 824300c:	10c00044 	addi	r3,r2,1
 8243010:	008209b4 	movhi	r2,2086
 8243014:	10b8f804 	addi	r2,r2,-7200
 8243018:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 824301c:	01000084 	movi	r4,2
 8243020:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
               pk_free(p);
 8243024:	e13fff17 	ldw	r4,-4(fp)
 8243028:	822c9700 	call	822c970 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824302c:	01000084 	movi	r4,2
 8243030:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 8243034:	00bffd44 	movi	r2,-11
 8243038:	00006006 	br	82431bc <ip_rcv_phase2+0x5b8>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 824303c:	e0bff817 	ldw	r2,-32(fp)
 8243040:	10800203 	ldbu	r2,8(r2)
 8243044:	10bfffc4 	addi	r2,r2,-1
 8243048:	1007883a 	mov	r3,r2
 824304c:	e0bff817 	ldw	r2,-32(fp)
 8243050:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 8243054:	e0bffe17 	ldw	r2,-8(fp)
 8243058:	100b883a 	mov	r5,r2
 824305c:	e13fff17 	ldw	r4,-4(fp)
 8243060:	824002c0 	call	824002c <ip_fragment>
 8243064:	e0bffc15 	stw	r2,-16(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 8243068:	e0bffc17 	ldw	r2,-16(fp)
 824306c:	00005306 	br	82431bc <ip_rcv_phase2+0x5b8>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 8243070:	e0bff817 	ldw	r2,-32(fp)
 8243074:	10800203 	ldbu	r2,8(r2)
 8243078:	10bfffc4 	addi	r2,r2,-1
 824307c:	1007883a 	mov	r3,r2
 8243080:	e0bff817 	ldw	r2,-32(fp)
 8243084:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 8243088:	e0bff817 	ldw	r2,-32(fp)
 824308c:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 8243090:	01400284 	movi	r5,10
 8243094:	e13ff817 	ldw	r4,-32(fp)
 8243098:	82283e80 	call	82283e8 <cksum>
 824309c:	0084303a 	nor	r2,zero,r2
 82430a0:	1007883a 	mov	r3,r2
 82430a4:	e0bff817 	ldw	r2,-32(fp)
 82430a8:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 82430ac:	e0bffe17 	ldw	r2,-8(fp)
 82430b0:	100b883a 	mov	r5,r2
 82430b4:	e13fff17 	ldw	r4,-4(fp)
 82430b8:	822632c0 	call	822632c <ip2mac>
 82430bc:	00003f06 	br	82431bc <ip_rcv_phase2+0x5b8>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
      }
      else
         goto ours;
 82430c0:	0001883a 	nop
 82430c4:	00000106 	br	82430cc <ip_rcv_phase2+0x4c8>
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
            goto ours;
 82430c8:	0001883a 	nop
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 82430cc:	e0bff817 	ldw	r2,-32(fp)
 82430d0:	1080018b 	ldhu	r2,6(r2)
 82430d4:	10bfffcc 	andi	r2,r2,65535
 82430d8:	1004d23a 	srli	r2,r2,8
 82430dc:	1007883a 	mov	r3,r2
 82430e0:	e0bff817 	ldw	r2,-32(fp)
 82430e4:	1080018b 	ldhu	r2,6(r2)
 82430e8:	10bfffcc 	andi	r2,r2,65535
 82430ec:	1004923a 	slli	r2,r2,8
 82430f0:	1884b03a 	or	r2,r3,r2
 82430f4:	e0bffd0d 	sth	r2,-12(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 82430f8:	e0bffd0b 	ldhu	r2,-12(fp)
 82430fc:	1088000c 	andi	r2,r2,8192
 8243100:	1000051e 	bne	r2,zero,8243118 <ip_rcv_phase2+0x514>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
 8243104:	e0fffd0b 	ldhu	r3,-12(fp)
 8243108:	00bffff4 	movhi	r2,65535
 824310c:	1087ffc4 	addi	r2,r2,8191
 8243110:	1884703a 	and	r2,r3,r2
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 8243114:	10002726 	beq	r2,zero,82431b4 <ip_rcv_phase2+0x5b0>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243118:	d0a08317 	ldw	r2,-32244(gp)
 824311c:	1081000c 	andi	r2,r2,1024
 8243120:	10001a26 	beq	r2,zero,824318c <ip_rcv_phase2+0x588>
 8243124:	d0a08317 	ldw	r2,-32244(gp)
 8243128:	1080800c 	andi	r2,r2,512
 824312c:	10001726 	beq	r2,zero,824318c <ip_rcv_phase2+0x588>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
          PUSH_IPADDR(pip->ip_src));
 8243130:	e0bff817 	ldw	r2,-32(fp)
 8243134:	10800317 	ldw	r2,12(r2)
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243138:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pip->ip_src));
 824313c:	e0bff817 	ldw	r2,-32(fp)
 8243140:	10800317 	ldw	r2,12(r2)
 8243144:	1004d23a 	srli	r2,r2,8
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243148:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(pip->ip_src));
 824314c:	e0bff817 	ldw	r2,-32(fp)
 8243150:	10800317 	ldw	r2,12(r2)
 8243154:	1004d43a 	srli	r2,r2,16
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243158:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pip->ip_src));
 824315c:	e0bff817 	ldw	r2,-32(fp)
 8243160:	10800317 	ldw	r2,12(r2)
 8243164:	1004d63a 	srli	r2,r2,24
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243168:	d8800015 	stw	r2,0(sp)
 824316c:	280f883a 	mov	r7,r5
 8243170:	200d883a 	mov	r6,r4
 8243174:	180b883a 	mov	r5,r3
 8243178:	01020974 	movhi	r4,2085
 824317c:	2103e704 	addi	r4,r4,3996
 8243180:	8202e9c0 	call	8202e9c <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 8243184:	e13fff17 	ldw	r4,-4(fp)
 8243188:	82406940 	call	8240694 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 824318c:	008209b4 	movhi	r2,2086
 8243190:	10b8f804 	addi	r2,r2,-7200
 8243194:	10800d17 	ldw	r2,52(r2)
 8243198:	10c00044 	addi	r3,r2,1
 824319c:	008209b4 	movhi	r2,2086
 82431a0:	10b8f804 	addi	r2,r2,-7200
 82431a4:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 82431a8:	e13fff17 	ldw	r4,-4(fp)
 82431ac:	82412600 	call	8241260 <ip_reassm>
 82431b0:	00000206 	br	82431bc <ip_rcv_phase2+0x5b8>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 82431b4:	e13fff17 	ldw	r4,-4(fp)
 82431b8:	82431d00 	call	82431d0 <ip_demux>
}
 82431bc:	e037883a 	mov	sp,fp
 82431c0:	dfc00117 	ldw	ra,4(sp)
 82431c4:	df000017 	ldw	fp,0(sp)
 82431c8:	dec00204 	addi	sp,sp,8
 82431cc:	f800283a 	ret

082431d0 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 82431d0:	defff904 	addi	sp,sp,-28
 82431d4:	dfc00615 	stw	ra,24(sp)
 82431d8:	df000515 	stw	fp,20(sp)
 82431dc:	df000504 	addi	fp,sp,20
 82431e0:	e13fff15 	stw	r4,-4(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 82431e4:	e0bfff17 	ldw	r2,-4(fp)
 82431e8:	10800317 	ldw	r2,12(r2)
 82431ec:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 82431f0:	e0bffe17 	ldw	r2,-8(fp)
 82431f4:	10800003 	ldbu	r2,0(r2)
 82431f8:	10803fcc 	andi	r2,r2,255
 82431fc:	10801160 	cmpeqi	r2,r2,69
 8243200:	1000131e 	bne	r2,zero,8243250 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 8243204:	e0bffe17 	ldw	r2,-8(fp)
 8243208:	10800003 	ldbu	r2,0(r2)
 824320c:	10803fcc 	andi	r2,r2,255
 8243210:	10801170 	cmpltui	r2,r2,69
 8243214:	1000051e 	bne	r2,zero,824322c <ip_demux+0x5c>
         (pip->ip_ver_ihl > 0x47))
 8243218:	e0bffe17 	ldw	r2,-8(fp)
 824321c:	10800003 	ldbu	r2,0(r2)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
   {
      if((pip->ip_ver_ihl < 0x45) ||
 8243220:	10803fcc 	andi	r2,r2,255
 8243224:	10801230 	cmpltui	r2,r2,72
 8243228:	1000091e 	bne	r2,zero,8243250 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 824322c:	e0bffe17 	ldw	r2,-8(fp)
 8243230:	10800003 	ldbu	r2,0(r2)
 8243234:	10803fcc 	andi	r2,r2,255
 8243238:	100b883a 	mov	r5,r2
 824323c:	01020974 	movhi	r4,2085
 8243240:	2103f004 	addi	r4,r4,4032
 8243244:	8202e9c0 	call	8202e9c <printf>
         return ENP_LOGIC;
 8243248:	00bffd44 	movi	r2,-11
 824324c:	0000d006 	br	8243590 <ip_demux+0x3c0>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 8243250:	e0bffe17 	ldw	r2,-8(fp)
 8243254:	10c00317 	ldw	r3,12(r2)
 8243258:	e0bfff17 	ldw	r2,-4(fp)
 824325c:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243260:	d0a08317 	ldw	r2,-32244(gp)
 8243264:	1081000c 	andi	r2,r2,1024
 8243268:	10002126 	beq	r2,zero,82432f0 <ip_demux+0x120>
 824326c:	d0a08317 	ldw	r2,-32244(gp)
 8243270:	1080800c 	andi	r2,r2,512
 8243274:	10001e26 	beq	r2,zero,82432f0 <ip_demux+0x120>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243278:	e0bffe17 	ldw	r2,-8(fp)
 824327c:	10800243 	ldbu	r2,9(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243280:	11003fcc 	andi	r4,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243284:	e0bffe17 	ldw	r2,-8(fp)
 8243288:	10800317 	ldw	r2,12(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 824328c:	11403fcc 	andi	r5,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243290:	e0bffe17 	ldw	r2,-8(fp)
 8243294:	10800317 	ldw	r2,12(r2)
 8243298:	1004d23a 	srli	r2,r2,8
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 824329c:	11803fcc 	andi	r6,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 82432a0:	e0bffe17 	ldw	r2,-8(fp)
 82432a4:	10800317 	ldw	r2,12(r2)
 82432a8:	1004d43a 	srli	r2,r2,16
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82432ac:	10803fcc 	andi	r2,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 82432b0:	e0fffe17 	ldw	r3,-8(fp)
 82432b4:	18c00317 	ldw	r3,12(r3)
 82432b8:	1806d63a 	srli	r3,r3,24
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82432bc:	d8c00115 	stw	r3,4(sp)
 82432c0:	d8800015 	stw	r2,0(sp)
 82432c4:	300f883a 	mov	r7,r6
 82432c8:	280d883a 	mov	r6,r5
 82432cc:	200b883a 	mov	r5,r4
 82432d0:	01020974 	movhi	r4,2085
 82432d4:	2103f704 	addi	r4,r4,4060
 82432d8:	8202e9c0 	call	8202e9c <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 82432dc:	d0a08317 	ldw	r2,-32244(gp)
 82432e0:	1080008c 	andi	r2,r2,2
 82432e4:	10000226 	beq	r2,zero,82432f0 <ip_demux+0x120>
 82432e8:	e13fff17 	ldw	r4,-4(fp)
 82432ec:	82406940 	call	8240694 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 82432f0:	e0bffe17 	ldw	r2,-8(fp)
 82432f4:	10800243 	ldbu	r2,9(r2)
 82432f8:	10803fcc 	andi	r2,r2,255
 82432fc:	10c000a0 	cmpeqi	r3,r2,2
 8243300:	18001f1e 	bne	r3,zero,8243380 <ip_demux+0x1b0>
 8243304:	10c000c8 	cmpgei	r3,r2,3
 8243308:	1800031e 	bne	r3,zero,8243318 <ip_demux+0x148>
 824330c:	10800060 	cmpeqi	r2,r2,1
 8243310:	1000101e 	bne	r2,zero,8243354 <ip_demux+0x184>
 8243314:	00003006 	br	82433d8 <ip_demux+0x208>
 8243318:	10c001a0 	cmpeqi	r3,r2,6
 824331c:	1800231e 	bne	r3,zero,82433ac <ip_demux+0x1dc>
 8243320:	10800460 	cmpeqi	r2,r2,17
 8243324:	10002c26 	beq	r2,zero,82433d8 <ip_demux+0x208>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 8243328:	008209b4 	movhi	r2,2086
 824332c:	10b8f804 	addi	r2,r2,-7200
 8243330:	10800817 	ldw	r2,32(r2)
 8243334:	10c00044 	addi	r3,r2,1
 8243338:	008209b4 	movhi	r2,2086
 824333c:	10b8f804 	addi	r2,r2,-7200
 8243340:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 8243344:	e13fff17 	ldw	r4,-4(fp)
 8243348:	82444580 	call	8244458 <udpdemux>
 824334c:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243350:	00002c06 	br	8243404 <ip_demux+0x234>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 8243354:	008209b4 	movhi	r2,2086
 8243358:	10b8f804 	addi	r2,r2,-7200
 824335c:	10800817 	ldw	r2,32(r2)
 8243360:	10c00044 	addi	r3,r2,1
 8243364:	008209b4 	movhi	r2,2086
 8243368:	10b8f804 	addi	r2,r2,-7200
 824336c:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 8243370:	e13fff17 	ldw	r4,-4(fp)
 8243374:	8249f5c0 	call	8249f5c <icmprcv>
 8243378:	e0bffd15 	stw	r2,-12(fp)
      break;
 824337c:	00002106 	br	8243404 <ip_demux+0x234>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 8243380:	008209b4 	movhi	r2,2086
 8243384:	10b8f804 	addi	r2,r2,-7200
 8243388:	10800817 	ldw	r2,32(r2)
 824338c:	10c00044 	addi	r3,r2,1
 8243390:	008209b4 	movhi	r2,2086
 8243394:	10b8f804 	addi	r2,r2,-7200
 8243398:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 824339c:	e13fff17 	ldw	r4,-4(fp)
 82433a0:	82269c40 	call	82269c4 <igmp_input>
 82433a4:	e0bffd15 	stw	r2,-12(fp)
      break;
 82433a8:	00001606 	br	8243404 <ip_demux+0x234>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 82433ac:	008209b4 	movhi	r2,2086
 82433b0:	10b8f804 	addi	r2,r2,-7200
 82433b4:	10800817 	ldw	r2,32(r2)
 82433b8:	10c00044 	addi	r3,r2,1
 82433bc:	008209b4 	movhi	r2,2086
 82433c0:	10b8f804 	addi	r2,r2,-7200
 82433c4:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 82433c8:	e13fff17 	ldw	r4,-4(fp)
 82433cc:	822ea380 	call	822ea38 <tcp_rcv>
 82433d0:	e0bffd15 	stw	r2,-12(fp)
      break;
 82433d4:	00000b06 	br	8243404 <ip_demux+0x234>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 82433d8:	008209b4 	movhi	r2,2086
 82433dc:	10b8f804 	addi	r2,r2,-7200
 82433e0:	10800817 	ldw	r2,32(r2)
 82433e4:	10c00044 	addi	r3,r2,1
 82433e8:	008209b4 	movhi	r2,2086
 82433ec:	10b8f804 	addi	r2,r2,-7200
 82433f0:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 82433f4:	e13fff17 	ldw	r4,-4(fp)
 82433f8:	8243ac80 	call	8243ac8 <ip_raw_input>
 82433fc:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243400:	0001883a 	nop
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 8243404:	e0bffd17 	ldw	r2,-12(fp)
 8243408:	10bffda0 	cmpeqi	r2,r2,-10
 824340c:	1000021e 	bne	r2,zero,8243418 <ip_demux+0x248>
   {
      return err;
 8243410:	e0bffd17 	ldw	r2,-12(fp)
 8243414:	00005e06 	br	8243590 <ip_demux+0x3c0>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243418:	e0bffe17 	ldw	r2,-8(fp)
 824341c:	10800417 	ldw	r2,16(r2)
 8243420:	10bfffe0 	cmpeqi	r2,r2,-1
 8243424:	10004c1e 	bne	r2,zero,8243558 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243428:	e0bffe17 	ldw	r2,-8(fp)
 824342c:	10800417 	ldw	r2,16(r2)
 8243430:	1006d63a 	srli	r3,r2,24
 8243434:	e0bffe17 	ldw	r2,-8(fp)
 8243438:	10800417 	ldw	r2,16(r2)
 824343c:	1004d23a 	srli	r2,r2,8
 8243440:	10bfc00c 	andi	r2,r2,65280
 8243444:	1886b03a 	or	r3,r3,r2
 8243448:	e0bffe17 	ldw	r2,-8(fp)
 824344c:	10800417 	ldw	r2,16(r2)
 8243450:	10bfc00c 	andi	r2,r2,65280
 8243454:	1004923a 	slli	r2,r2,8
 8243458:	1886b03a 	or	r3,r3,r2
 824345c:	e0bffe17 	ldw	r2,-8(fp)
 8243460:	10800417 	ldw	r2,16(r2)
 8243464:	1004963a 	slli	r2,r2,24
 8243468:	1884b03a 	or	r2,r3,r2
 824346c:	10fc002c 	andhi	r3,r2,61440

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243470:	00b80034 	movhi	r2,57344
 8243474:	18803826 	beq	r3,r2,8243558 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 8243478:	e0bffe17 	ldw	r2,-8(fp)
 824347c:	10c00417 	ldw	r3,16(r2)
 8243480:	e0bfff17 	ldw	r2,-4(fp)
 8243484:	10800617 	ldw	r2,24(r2)
 8243488:	10800e17 	ldw	r2,56(r2)
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 824348c:	18803226 	beq	r3,r2,8243558 <ip_demux+0x388>
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8243490:	e0bffe17 	ldw	r2,-8(fp)
 8243494:	10c00417 	ldw	r3,16(r2)
 8243498:	e0bfff17 	ldw	r2,-4(fp)
 824349c:	10800617 	ldw	r2,24(r2)
 82434a0:	10800f17 	ldw	r2,60(r2)
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 82434a4:	18802c26 	beq	r3,r2,8243558 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82434a8:	e0bffe17 	ldw	r2,-8(fp)
 82434ac:	10c00417 	ldw	r3,16(r2)
 82434b0:	e0bfff17 	ldw	r2,-4(fp)
 82434b4:	10800617 	ldw	r2,24(r2)
 82434b8:	10801017 	ldw	r2,64(r2)
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 82434bc:	18802626 	beq	r3,r2,8243558 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
 82434c0:	e0bfff17 	ldw	r2,-4(fp)
 82434c4:	10800617 	ldw	r2,24(r2)
 82434c8:	10c00a17 	ldw	r3,40(r2)
 82434cc:	e0bfff17 	ldw	r2,-4(fp)
 82434d0:	10800617 	ldw	r2,24(r2)
 82434d4:	10801017 	ldw	r2,64(r2)
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82434d8:	18801f26 	beq	r3,r2,8243558 <ip_demux+0x388>
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 82434dc:	d0a08317 	ldw	r2,-32244(gp)
 82434e0:	1081000c 	andi	r2,r2,1024
 82434e4:	10000f26 	beq	r2,zero,8243524 <ip_demux+0x354>
 82434e8:	d0a08317 	ldw	r2,-32244(gp)
 82434ec:	1080800c 	andi	r2,r2,512
 82434f0:	10000c26 	beq	r2,zero,8243524 <ip_demux+0x354>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 82434f4:	e0bffe17 	ldw	r2,-8(fp)
 82434f8:	10800243 	ldbu	r2,9(r2)
 82434fc:	10803fcc 	andi	r2,r2,255
 8243500:	100b883a 	mov	r5,r2
 8243504:	01020974 	movhi	r4,2085
 8243508:	21040104 	addi	r4,r4,4100
 824350c:	8202e9c0 	call	8202e9c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 8243510:	d0a08317 	ldw	r2,-32244(gp)
 8243514:	1080008c 	andi	r2,r2,2
 8243518:	10000226 	beq	r2,zero,8243524 <ip_demux+0x354>
 824351c:	e13fff17 	ldw	r4,-4(fp)
 8243520:	82406940 	call	8240694 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 8243524:	e0bffe17 	ldw	r2,-8(fp)
 8243528:	10c00317 	ldw	r3,12(r2)
 824352c:	e0bfff17 	ldw	r2,-4(fp)
 8243530:	10800617 	ldw	r2,24(r2)
 8243534:	11000a17 	ldw	r4,40(r2)
 8243538:	e0bfff17 	ldw	r2,-4(fp)
 824353c:	10800617 	ldw	r2,24(r2)
 8243540:	d8800015 	stw	r2,0(sp)
 8243544:	01c00084 	movi	r7,2
 8243548:	e1bffe17 	ldw	r6,-8(fp)
 824354c:	200b883a 	mov	r5,r4
 8243550:	1809883a 	mov	r4,r3
 8243554:	824aac00 	call	824aac0 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 8243558:	008209b4 	movhi	r2,2086
 824355c:	10b8f804 	addi	r2,r2,-7200
 8243560:	10800617 	ldw	r2,24(r2)
 8243564:	10c00044 	addi	r3,r2,1
 8243568:	008209b4 	movhi	r2,2086
 824356c:	10b8f804 	addi	r2,r2,-7200
 8243570:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243574:	01000084 	movi	r4,2
 8243578:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 824357c:	e13fff17 	ldw	r4,-4(fp)
 8243580:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243584:	01000084 	movi	r4,2
 8243588:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 824358c:	00800084 	movi	r2,2
}
 8243590:	e037883a 	mov	sp,fp
 8243594:	dfc00117 	ldw	ra,4(sp)
 8243598:	df000017 	ldw	fp,0(sp)
 824359c:	dec00204 	addi	sp,sp,8
 82435a0:	f800283a 	ret

082435a4 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 82435a4:	defff904 	addi	sp,sp,-28
 82435a8:	dfc00615 	stw	ra,24(sp)
 82435ac:	df000515 	stw	fp,20(sp)
 82435b0:	df000504 	addi	fp,sp,20
 82435b4:	e13ffd15 	stw	r4,-12(fp)
 82435b8:	e17ffe15 	stw	r5,-8(fp)
 82435bc:	e1bfff15 	stw	r6,-4(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 82435c0:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 82435c4:	e0bffd17 	ldw	r2,-12(fp)
 82435c8:	10000326 	beq	r2,zero,82435d8 <in_addmulti+0x34>
 82435cc:	e0bffd17 	ldw	r2,-12(fp)
 82435d0:	10800017 	ldw	r2,0(r2)
 82435d4:	1000021e 	bne	r2,zero,82435e0 <in_addmulti+0x3c>
      return ((struct in_multi *)NULL);  
 82435d8:	0005883a 	mov	r2,zero
 82435dc:	00003f06 	br	82436dc <in_addmulti+0x138>

   ENTER_CRIT_SECTION(netp);
 82435e0:	822d3a00 	call	822d3a0 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 82435e4:	e0bfff17 	ldw	r2,-4(fp)
 82435e8:	108001a0 	cmpeqi	r2,r2,6
 82435ec:	1000061e 	bne	r2,zero,8243608 <in_addmulti+0x64>
      inm = lookup_mcast(*ap, netp);
 82435f0:	e0bffd17 	ldw	r2,-12(fp)
 82435f4:	10800017 	ldw	r2,0(r2)
 82435f8:	e17ffe17 	ldw	r5,-8(fp)
 82435fc:	1009883a 	mov	r4,r2
 8243600:	82437fc0 	call	82437fc <lookup_mcast>
 8243604:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 8243608:	e0bffb17 	ldw	r2,-20(fp)
 824360c:	10000626 	beq	r2,zero,8243628 <in_addmulti+0x84>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 8243610:	e0bffb17 	ldw	r2,-20(fp)
 8243614:	10800217 	ldw	r2,8(r2)
 8243618:	10c00044 	addi	r3,r2,1
 824361c:	e0bffb17 	ldw	r2,-20(fp)
 8243620:	10c00215 	stw	r3,8(r2)
 8243624:	00002b06 	br	82436d4 <in_addmulti+0x130>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 8243628:	01000604 	movi	r4,24
 824362c:	822dda00 	call	822dda0 <npalloc>
 8243630:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 8243634:	e0bffb17 	ldw	r2,-20(fp)
 8243638:	1000031e 	bne	r2,zero,8243648 <in_addmulti+0xa4>
      {
         EXIT_CRIT_SECTION(netp);
 824363c:	822d4000 	call	822d400 <irq_Unmask>
         return ((struct in_multi *)NULL);
 8243640:	0005883a 	mov	r2,zero
 8243644:	00002506 	br	82436dc <in_addmulti+0x138>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 8243648:	e0bfff17 	ldw	r2,-4(fp)
 824364c:	108001a0 	cmpeqi	r2,r2,6
 8243650:	1000041e 	bne	r2,zero,8243664 <in_addmulti+0xc0>
         inm->inm_addr = *ap;
 8243654:	e0bffd17 	ldw	r2,-12(fp)
 8243658:	10c00017 	ldw	r3,0(r2)
 824365c:	e0bffb17 	ldw	r2,-20(fp)
 8243660:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 8243664:	e0bffb17 	ldw	r2,-20(fp)
 8243668:	e0fffe17 	ldw	r3,-8(fp)
 824366c:	10c00115 	stw	r3,4(r2)
      inm->inm_refcount = 1;
 8243670:	e0bffb17 	ldw	r2,-20(fp)
 8243674:	00c00044 	movi	r3,1
 8243678:	10c00215 	stw	r3,8(r2)
      inm->inm_next = netp->mc_list;
 824367c:	e0bffe17 	ldw	r2,-8(fp)
 8243680:	10c02c17 	ldw	r3,176(r2)
 8243684:	e0bffb17 	ldw	r2,-20(fp)
 8243688:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 824368c:	e0bffe17 	ldw	r2,-8(fp)
 8243690:	e0fffb17 	ldw	r3,-20(fp)
 8243694:	10c02c15 	stw	r3,176(r2)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 8243698:	e0bffe17 	ldw	r2,-8(fp)
 824369c:	10802b17 	ldw	r2,172(r2)
 82436a0:	10000626 	beq	r2,zero,82436bc <in_addmulti+0x118>
         error = netp->n_mcastlist(inm);
 82436a4:	e0bffe17 	ldw	r2,-8(fp)
 82436a8:	10802b17 	ldw	r2,172(r2)
 82436ac:	e13ffb17 	ldw	r4,-20(fp)
 82436b0:	103ee83a 	callr	r2
 82436b4:	e0bffc15 	stw	r2,-16(fp)
 82436b8:	00000106 	br	82436c0 <in_addmulti+0x11c>
      else
         error = 0;
 82436bc:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 82436c0:	e0bffb17 	ldw	r2,-20(fp)
 82436c4:	10800017 	ldw	r2,0(r2)
 82436c8:	10000226 	beq	r2,zero,82436d4 <in_addmulti+0x130>
 82436cc:	e13ffb17 	ldw	r4,-20(fp)
 82436d0:	8226eb40 	call	8226eb4 <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 82436d4:	822d4000 	call	822d400 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 82436d8:	e0bffb17 	ldw	r2,-20(fp)
}
 82436dc:	e037883a 	mov	sp,fp
 82436e0:	dfc00117 	ldw	ra,4(sp)
 82436e4:	df000017 	ldw	fp,0(sp)
 82436e8:	dec00204 	addi	sp,sp,8
 82436ec:	f800283a 	ret

082436f0 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 82436f0:	defffa04 	addi	sp,sp,-24
 82436f4:	dfc00515 	stw	ra,20(sp)
 82436f8:	df000415 	stw	fp,16(sp)
 82436fc:	df000404 	addi	fp,sp,16
 8243700:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 8243704:	e0bfff17 	ldw	r2,-4(fp)
 8243708:	10800117 	ldw	r2,4(r2)
 824370c:	e0bffe15 	stw	r2,-8(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 8243710:	822d3a00 	call	822d3a0 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 8243714:	e0bfff17 	ldw	r2,-4(fp)
 8243718:	10800217 	ldw	r2,8(r2)
 824371c:	10ffffc4 	addi	r3,r2,-1
 8243720:	e0bfff17 	ldw	r2,-4(fp)
 8243724:	10c00215 	stw	r3,8(r2)
 8243728:	e0bfff17 	ldw	r2,-4(fp)
 824372c:	10800217 	ldw	r2,8(r2)
 8243730:	10002b1e 	bne	r2,zero,82437e0 <in_delmulti+0xf0>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243734:	e0bffe17 	ldw	r2,-8(fp)
 8243738:	10802c17 	ldw	r2,176(r2)
 824373c:	e0bffc15 	stw	r2,-16(fp)
 8243740:	00001406 	br	8243794 <in_delmulti+0xa4>
      {
         if(p == inm)   /* inm is first in mc_list */
 8243744:	e0fffc17 	ldw	r3,-16(fp)
 8243748:	e0bfff17 	ldw	r2,-4(fp)
 824374c:	1880051e 	bne	r3,r2,8243764 <in_delmulti+0x74>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 8243750:	e0bffc17 	ldw	r2,-16(fp)
 8243754:	10c00517 	ldw	r3,20(r2)
 8243758:	e0bffe17 	ldw	r2,-8(fp)
 824375c:	10c02c15 	stw	r3,176(r2)
            break;
 8243760:	00000e06 	br	824379c <in_delmulti+0xac>
         }
         else if(p->inm_next == inm)   /* inm is next */
 8243764:	e0bffc17 	ldw	r2,-16(fp)
 8243768:	10c00517 	ldw	r3,20(r2)
 824376c:	e0bfff17 	ldw	r2,-4(fp)
 8243770:	1880051e 	bne	r3,r2,8243788 <in_delmulti+0x98>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 8243774:	e0bfff17 	ldw	r2,-4(fp)
 8243778:	10c00517 	ldw	r3,20(r2)
 824377c:	e0bffc17 	ldw	r2,-16(fp)
 8243780:	10c00515 	stw	r3,20(r2)
            break;
 8243784:	00000506 	br	824379c <in_delmulti+0xac>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243788:	e0bffc17 	ldw	r2,-16(fp)
 824378c:	10800517 	ldw	r2,20(r2)
 8243790:	e0bffc15 	stw	r2,-16(fp)
 8243794:	e0bffc17 	ldw	r2,-16(fp)
 8243798:	103fea1e 	bne	r2,zero,8243744 <in_delmulti+0x54>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 824379c:	e0bffe17 	ldw	r2,-8(fp)
 82437a0:	10802b17 	ldw	r2,172(r2)
 82437a4:	10000626 	beq	r2,zero,82437c0 <in_delmulti+0xd0>
         error = netp->n_mcastlist(inm);
 82437a8:	e0bffe17 	ldw	r2,-8(fp)
 82437ac:	10802b17 	ldw	r2,172(r2)
 82437b0:	e13fff17 	ldw	r4,-4(fp)
 82437b4:	103ee83a 	callr	r2
 82437b8:	e0bffd15 	stw	r2,-12(fp)
 82437bc:	00000106 	br	82437c4 <in_delmulti+0xd4>
      else
         error = 0;
 82437c0:	e03ffd15 	stw	zero,-12(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 82437c4:	e0bfff17 	ldw	r2,-4(fp)
 82437c8:	10800017 	ldw	r2,0(r2)
 82437cc:	10000226 	beq	r2,zero,82437d8 <in_delmulti+0xe8>
 82437d0:	e13fff17 	ldw	r4,-4(fp)
 82437d4:	82271080 	call	8227108 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 82437d8:	e13fff17 	ldw	r4,-4(fp)
 82437dc:	822ddd40 	call	822ddd4 <npfree>
   }

   EXIT_CRIT_SECTION(inm);
 82437e0:	822d4000 	call	822d400 <irq_Unmask>
   USE_ARG(error);
}
 82437e4:	0001883a 	nop
 82437e8:	e037883a 	mov	sp,fp
 82437ec:	dfc00117 	ldw	ra,4(sp)
 82437f0:	df000017 	ldw	fp,0(sp)
 82437f4:	dec00204 	addi	sp,sp,8
 82437f8:	f800283a 	ret

082437fc <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 82437fc:	defffc04 	addi	sp,sp,-16
 8243800:	df000315 	stw	fp,12(sp)
 8243804:	df000304 	addi	fp,sp,12
 8243808:	e13ffe15 	stw	r4,-8(fp)
 824380c:	e17fff15 	stw	r5,-4(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243810:	e0bfff17 	ldw	r2,-4(fp)
 8243814:	10802c17 	ldw	r2,176(r2)
 8243818:	e0bffd15 	stw	r2,-12(fp)
 824381c:	00000906 	br	8243844 <lookup_mcast+0x48>
   {
      if(imp->inm_addr == addr)
 8243820:	e0bffd17 	ldw	r2,-12(fp)
 8243824:	10c00017 	ldw	r3,0(r2)
 8243828:	e0bffe17 	ldw	r2,-8(fp)
 824382c:	1880021e 	bne	r3,r2,8243838 <lookup_mcast+0x3c>
         return imp;
 8243830:	e0bffd17 	ldw	r2,-12(fp)
 8243834:	00000606 	br	8243850 <lookup_mcast+0x54>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243838:	e0bffd17 	ldw	r2,-12(fp)
 824383c:	10800517 	ldw	r2,20(r2)
 8243840:	e0bffd15 	stw	r2,-12(fp)
 8243844:	e0bffd17 	ldw	r2,-12(fp)
 8243848:	103ff51e 	bne	r2,zero,8243820 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 824384c:	0005883a 	mov	r2,zero
}
 8243850:	e037883a 	mov	sp,fp
 8243854:	df000017 	ldw	fp,0(sp)
 8243858:	dec00104 	addi	sp,sp,4
 824385c:	f800283a 	ret

08243860 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 8243860:	defffd04 	addi	sp,sp,-12
 8243864:	dfc00215 	stw	ra,8(sp)
 8243868:	df000115 	stw	fp,4(sp)
 824386c:	df000104 	addi	fp,sp,4
 8243870:	e13fff15 	stw	r4,-4(fp)
   if (port_prep)
 8243874:	d0a0ca17 	ldw	r2,-31960(gp)
 8243878:	10000426 	beq	r2,zero,824388c <prep_ifaces+0x2c>
      ifaces_found = port_prep(ifaces_found);
 824387c:	d0a0ca17 	ldw	r2,-31960(gp)
 8243880:	e13fff17 	ldw	r4,-4(fp)
 8243884:	103ee83a 	callr	r2
 8243888:	e0bfff15 	stw	r2,-4(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 824388c:	e0bfff17 	ldw	r2,-4(fp)
 8243890:	d0a08415 	stw	r2,-32240(gp)

   initmsg("prepped %u interface%s, initializing...\n", 
 8243894:	e0bfff17 	ldw	r2,-4(fp)
 8243898:	10800058 	cmpnei	r2,r2,1
 824389c:	1000031e 	bne	r2,zero,82438ac <prep_ifaces+0x4c>
 82438a0:	00820974 	movhi	r2,2085
 82438a4:	10840904 	addi	r2,r2,4132
 82438a8:	00000206 	br	82438b4 <prep_ifaces+0x54>
 82438ac:	00820974 	movhi	r2,2085
 82438b0:	10840a04 	addi	r2,r2,4136
 82438b4:	100d883a 	mov	r6,r2
 82438b8:	e17fff17 	ldw	r5,-4(fp)
 82438bc:	01020974 	movhi	r4,2085
 82438c0:	21040b04 	addi	r4,r4,4140
 82438c4:	8202e9c0 	call	8202e9c <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 82438c8:	e0bfff17 	ldw	r2,-4(fp)
}
 82438cc:	e037883a 	mov	sp,fp
 82438d0:	dfc00117 	ldw	ra,4(sp)
 82438d4:	df000017 	ldw	fp,0(sp)
 82438d8:	dec00204 	addi	sp,sp,8
 82438dc:	f800283a 	ret

082438e0 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 82438e0:	defffd04 	addi	sp,sp,-12
 82438e4:	dfc00215 	stw	ra,8(sp)
 82438e8:	df000115 	stw	fp,4(sp)
 82438ec:	df000104 	addi	fp,sp,4
 82438f0:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 82438f4:	00800044 	movi	r2,1
 82438f8:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 82438fc:	82267cc0 	call	82267cc <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 8243900:	e13fff17 	ldw	r4,-4(fp)
 8243904:	824b1540 	call	824b154 <exit>

08243908 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 8243908:	deffff04 	addi	sp,sp,-4
 824390c:	df000015 	stw	fp,0(sp)
 8243910:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 8243914:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 8243918:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 824391c:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 8243920:	0001883a 	nop
 8243924:	e037883a 	mov	sp,fp
 8243928:	df000017 	ldw	fp,0(sp)
 824392c:	dec00104 	addi	sp,sp,4
 8243930:	f800283a 	ret

08243934 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 8243934:	defff904 	addi	sp,sp,-28
 8243938:	dfc00615 	stw	ra,24(sp)
 824393c:	df000515 	stw	fp,20(sp)
 8243940:	df000504 	addi	fp,sp,20
 8243944:	2005883a 	mov	r2,r4
 8243948:	e17ffd15 	stw	r5,-12(fp)
 824394c:	e1bffe15 	stw	r6,-8(fp)
 8243950:	e1ffff15 	stw	r7,-4(fp)
 8243954:	e0bffc05 	stb	r2,-16(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243958:	0009883a 	mov	r4,zero
 824395c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 8243960:	01000604 	movi	r4,24
 8243964:	822dda00 	call	822dda0 <npalloc>
 8243968:	e0bffb15 	stw	r2,-20(fp)
   if (ep == NULL)
 824396c:	e0bffb17 	ldw	r2,-20(fp)
 8243970:	10000a1e 	bne	r2,zero,824399c <ip_raw_open+0x68>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 8243974:	d0a08317 	ldw	r2,-32244(gp)
 8243978:	1080010c 	andi	r2,r2,4
 824397c:	10000326 	beq	r2,zero,824398c <ip_raw_open+0x58>
         dprintf("IP: Couldn't allocate ep storage.\n");
 8243980:	01020974 	movhi	r4,2085
 8243984:	21041604 	addi	r4,r4,4184
 8243988:	82031200 	call	8203120 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 824398c:	0009883a 	mov	r4,zero
 8243990:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ep;
 8243994:	e0bffb17 	ldw	r2,-20(fp)
 8243998:	00001706 	br	82439f8 <ip_raw_open+0xc4>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 824399c:	e0bffb17 	ldw	r2,-20(fp)
 82439a0:	e0fffd17 	ldw	r3,-12(fp)
 82439a4:	10c00115 	stw	r3,4(r2)
   ep->ipr_faddr = faddr;
 82439a8:	e0bffb17 	ldw	r2,-20(fp)
 82439ac:	e0fffe17 	ldw	r3,-8(fp)
 82439b0:	10c00215 	stw	r3,8(r2)
   ep->ipr_prot = prot;
 82439b4:	e0bffb17 	ldw	r2,-20(fp)
 82439b8:	e0fffc03 	ldbu	r3,-16(fp)
 82439bc:	10c00505 	stb	r3,20(r2)
   ep->ipr_rcv = handler;
 82439c0:	e0bffb17 	ldw	r2,-20(fp)
 82439c4:	e0ffff17 	ldw	r3,-4(fp)
 82439c8:	10c00315 	stw	r3,12(r2)
   ep->ipr_data = data;
 82439cc:	e0bffb17 	ldw	r2,-20(fp)
 82439d0:	e0c00217 	ldw	r3,8(fp)
 82439d4:	10c00415 	stw	r3,16(r2)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 82439d8:	d0e0cf17 	ldw	r3,-31940(gp)
 82439dc:	e0bffb17 	ldw	r2,-20(fp)
 82439e0:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 82439e4:	e0bffb17 	ldw	r2,-20(fp)
 82439e8:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 82439ec:	0009883a 	mov	r4,zero
 82439f0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return ep;
 82439f4:	e0bffb17 	ldw	r2,-20(fp)
}
 82439f8:	e037883a 	mov	sp,fp
 82439fc:	dfc00117 	ldw	ra,4(sp)
 8243a00:	df000017 	ldw	fp,0(sp)
 8243a04:	dec00204 	addi	sp,sp,8
 8243a08:	f800283a 	ret

08243a0c <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 8243a0c:	defffb04 	addi	sp,sp,-20
 8243a10:	dfc00415 	stw	ra,16(sp)
 8243a14:	df000315 	stw	fp,12(sp)
 8243a18:	df000304 	addi	fp,sp,12
 8243a1c:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243a20:	0009883a 	mov	r4,zero
 8243a24:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243a28:	e03ffd15 	stw	zero,-12(fp)
 8243a2c:	d0a0cf17 	ldw	r2,-31940(gp)
 8243a30:	e0bffe15 	stw	r2,-8(fp)
 8243a34:	00000806 	br	8243a58 <ip_raw_close+0x4c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 8243a38:	e0fffe17 	ldw	r3,-8(fp)
 8243a3c:	e0bfff17 	ldw	r2,-4(fp)
 8243a40:	18800826 	beq	r3,r2,8243a64 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 8243a44:	e0bffe17 	ldw	r2,-8(fp)
 8243a48:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 8243a4c:	e0bffe17 	ldw	r2,-8(fp)
 8243a50:	10800017 	ldw	r2,0(r2)
 8243a54:	e0bffe15 	stw	r2,-8(fp)
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243a58:	e0bffe17 	ldw	r2,-8(fp)
 8243a5c:	103ff61e 	bne	r2,zero,8243a38 <ip_raw_close+0x2c>
 8243a60:	00000106 	br	8243a68 <ip_raw_close+0x5c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
         break;
 8243a64:	0001883a 	nop
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 8243a68:	e0bffe17 	ldw	r2,-8(fp)
 8243a6c:	1000041e 	bne	r2,zero,8243a80 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 8243a70:	822d1c80 	call	822d1c8 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243a74:	0009883a 	mov	r4,zero
 8243a78:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return;
 8243a7c:	00000d06 	br	8243ab4 <ip_raw_close+0xa8>
   }

   /* unlink it from the list */
   if (prev_ep)
 8243a80:	e0bffd17 	ldw	r2,-12(fp)
 8243a84:	10000426 	beq	r2,zero,8243a98 <ip_raw_close+0x8c>
      prev_ep = curr_ep->ipr_next;
 8243a88:	e0bffe17 	ldw	r2,-8(fp)
 8243a8c:	10800017 	ldw	r2,0(r2)
 8243a90:	e0bffd15 	stw	r2,-12(fp)
 8243a94:	00000306 	br	8243aa4 <ip_raw_close+0x98>
   else
      ipraw_eps = curr_ep->ipr_next;
 8243a98:	e0bffe17 	ldw	r2,-8(fp)
 8243a9c:	10800017 	ldw	r2,0(r2)
 8243aa0:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 8243aa4:	e13ffe17 	ldw	r4,-8(fp)
 8243aa8:	822ddd40 	call	822ddd4 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243aac:	0009883a 	mov	r4,zero
 8243ab0:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
}
 8243ab4:	e037883a 	mov	sp,fp
 8243ab8:	dfc00117 	ldw	ra,4(sp)
 8243abc:	df000017 	ldw	fp,0(sp)
 8243ac0:	dec00204 	addi	sp,sp,8
 8243ac4:	f800283a 	ret

08243ac8 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 8243ac8:	defff604 	addi	sp,sp,-40
 8243acc:	dfc00915 	stw	ra,36(sp)
 8243ad0:	df000815 	stw	fp,32(sp)
 8243ad4:	df000804 	addi	fp,sp,32
 8243ad8:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 8243adc:	e03ff915 	stw	zero,-28(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 8243ae0:	e03ffb15 	stw	zero,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 8243ae4:	e0bfff17 	ldw	r2,-4(fp)
 8243ae8:	10800317 	ldw	r2,12(r2)
 8243aec:	e0bffc15 	stw	r2,-16(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243af0:	d0a0cf17 	ldw	r2,-31940(gp)
 8243af4:	e0bff815 	stw	r2,-32(fp)
 8243af8:	00004c06 	br	8243c2c <ip_raw_input+0x164>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 8243afc:	e0bff817 	ldw	r2,-32(fp)
 8243b00:	10800017 	ldw	r2,0(r2)
 8243b04:	e0bffd15 	stw	r2,-12(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 8243b08:	e0bff817 	ldw	r2,-32(fp)
 8243b0c:	10800503 	ldbu	r2,20(r2)
 8243b10:	10803fcc 	andi	r2,r2,255
 8243b14:	10000726 	beq	r2,zero,8243b34 <ip_raw_input+0x6c>
 8243b18:	e0bff817 	ldw	r2,-32(fp)
 8243b1c:	10c00503 	ldbu	r3,20(r2)
 8243b20:	e0bffc17 	ldw	r2,-16(fp)
 8243b24:	10800243 	ldbu	r2,9(r2)
 8243b28:	18c03fcc 	andi	r3,r3,255
 8243b2c:	10803fcc 	andi	r2,r2,255
 8243b30:	1880371e 	bne	r3,r2,8243c10 <ip_raw_input+0x148>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 8243b34:	e0bff817 	ldw	r2,-32(fp)
 8243b38:	10800117 	ldw	r2,4(r2)
 8243b3c:	10000526 	beq	r2,zero,8243b54 <ip_raw_input+0x8c>
 8243b40:	e0bff817 	ldw	r2,-32(fp)
 8243b44:	10c00117 	ldw	r3,4(r2)
 8243b48:	e0bffc17 	ldw	r2,-16(fp)
 8243b4c:	10800417 	ldw	r2,16(r2)
 8243b50:	1880311e 	bne	r3,r2,8243c18 <ip_raw_input+0x150>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 8243b54:	e0bff817 	ldw	r2,-32(fp)
 8243b58:	10800217 	ldw	r2,8(r2)
 8243b5c:	10000526 	beq	r2,zero,8243b74 <ip_raw_input+0xac>
 8243b60:	e0bff817 	ldw	r2,-32(fp)
 8243b64:	10c00217 	ldw	r3,8(r2)
 8243b68:	e0bffc17 	ldw	r2,-16(fp)
 8243b6c:	10800317 	ldw	r2,12(r2)
 8243b70:	18802b1e 	bne	r3,r2,8243c20 <ip_raw_input+0x158>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 8243b74:	e0bff817 	ldw	r2,-32(fp)
 8243b78:	10800317 	ldw	r2,12(r2)
 8243b7c:	10002926 	beq	r2,zero,8243c24 <ip_raw_input+0x15c>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243b80:	e0bff917 	ldw	r2,-28(fp)
 8243b84:	10001f26 	beq	r2,zero,8243c04 <ip_raw_input+0x13c>
 8243b88:	e0bff917 	ldw	r2,-28(fp)
 8243b8c:	10800317 	ldw	r2,12(r2)
 8243b90:	10001c26 	beq	r2,zero,8243c04 <ip_raw_input+0x13c>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 8243b94:	e13fff17 	ldw	r4,-4(fp)
 8243b98:	8240b140 	call	8240b14 <ip_copypkt>
 8243b9c:	e0bffe15 	stw	r2,-8(fp)
            if (p2)
 8243ba0:	e0bffe17 	ldw	r2,-8(fp)
 8243ba4:	10001726 	beq	r2,zero,8243c04 <ip_raw_input+0x13c>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 8243ba8:	0009883a 	mov	r4,zero
 8243bac:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 8243bb0:	e0bff917 	ldw	r2,-28(fp)
 8243bb4:	10800317 	ldw	r2,12(r2)
 8243bb8:	e0fff917 	ldw	r3,-28(fp)
 8243bbc:	18c00417 	ldw	r3,16(r3)
 8243bc0:	180b883a 	mov	r5,r3
 8243bc4:	e13ffe17 	ldw	r4,-8(fp)
 8243bc8:	103ee83a 	callr	r2
 8243bcc:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 8243bd0:	0009883a 	mov	r4,zero
 8243bd4:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
               if (err)
 8243bd8:	e0bffa17 	ldw	r2,-24(fp)
 8243bdc:	10000726 	beq	r2,zero,8243bfc <ip_raw_input+0x134>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 8243be0:	01000084 	movi	r4,2
 8243be4:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 8243be8:	e13ffe17 	ldw	r4,-8(fp)
 8243bec:	822c9700 	call	822c970 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243bf0:	01000084 	movi	r4,2
 8243bf4:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
 8243bf8:	00000206 	br	8243c04 <ip_raw_input+0x13c>
               }
               else
                  delivered = 1;
 8243bfc:	00800044 	movi	r2,1
 8243c00:	e0bffb15 	stw	r2,-20(fp)
            }
         }
         matched_ep = ep;
 8243c04:	e0bff817 	ldw	r2,-32(fp)
 8243c08:	e0bff915 	stw	r2,-28(fp)
 8243c0c:	00000506 	br	8243c24 <ip_raw_input+0x15c>
      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
         continue;
 8243c10:	0001883a 	nop
 8243c14:	00000306 	br	8243c24 <ip_raw_input+0x15c>
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
         continue;
 8243c18:	0001883a 	nop
 8243c1c:	00000106 	br	8243c24 <ip_raw_input+0x15c>
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
         continue;
 8243c20:	0001883a 	nop

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243c24:	e0bffd17 	ldw	r2,-12(fp)
 8243c28:	e0bff815 	stw	r2,-32(fp)
 8243c2c:	e0bff817 	ldw	r2,-32(fp)
 8243c30:	103fb21e 	bne	r2,zero,8243afc <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243c34:	e0bff917 	ldw	r2,-28(fp)
 8243c38:	10001426 	beq	r2,zero,8243c8c <ip_raw_input+0x1c4>
 8243c3c:	e0bff917 	ldw	r2,-28(fp)
 8243c40:	10800317 	ldw	r2,12(r2)
 8243c44:	10001126 	beq	r2,zero,8243c8c <ip_raw_input+0x1c4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243c48:	0009883a 	mov	r4,zero
 8243c4c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 8243c50:	e0bff917 	ldw	r2,-28(fp)
 8243c54:	10800317 	ldw	r2,12(r2)
 8243c58:	e0fff917 	ldw	r3,-28(fp)
 8243c5c:	18c00417 	ldw	r3,16(r3)
 8243c60:	180b883a 	mov	r5,r3
 8243c64:	e13fff17 	ldw	r4,-4(fp)
 8243c68:	103ee83a 	callr	r2
 8243c6c:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 8243c70:	0009883a 	mov	r4,zero
 8243c74:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      if (err == 0)
 8243c78:	e0bffa17 	ldw	r2,-24(fp)
 8243c7c:	10000c1e 	bne	r2,zero,8243cb0 <ip_raw_input+0x1e8>
         delivered = 1;
 8243c80:	00800044 	movi	r2,1
 8243c84:	e0bffb15 	stw	r2,-20(fp)
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
      LOCK_NET_RESOURCE(NET_RESID);
      if (err == 0)
 8243c88:	00000906 	br	8243cb0 <ip_raw_input+0x1e8>
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 8243c8c:	00bffd84 	movi	r2,-10
 8243c90:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 8243c94:	008209b4 	movhi	r2,2086
 8243c98:	10b8f804 	addi	r2,r2,-7200
 8243c9c:	10800617 	ldw	r2,24(r2)
 8243ca0:	10c00044 	addi	r3,r2,1
 8243ca4:	008209b4 	movhi	r2,2086
 8243ca8:	10b8f804 	addi	r2,r2,-7200
 8243cac:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 8243cb0:	e0bffb17 	ldw	r2,-20(fp)
 8243cb4:	1000071e 	bne	r2,zero,8243cd4 <ip_raw_input+0x20c>
      ip_mib.ipInDelivers--;
 8243cb8:	008209b4 	movhi	r2,2086
 8243cbc:	10b8f804 	addi	r2,r2,-7200
 8243cc0:	10800817 	ldw	r2,32(r2)
 8243cc4:	10ffffc4 	addi	r3,r2,-1
 8243cc8:	008209b4 	movhi	r2,2086
 8243ccc:	10b8f804 	addi	r2,r2,-7200
 8243cd0:	10c00815 	stw	r3,32(r2)

   return err;
 8243cd4:	e0bffa17 	ldw	r2,-24(fp)
}
 8243cd8:	e037883a 	mov	sp,fp
 8243cdc:	dfc00117 	ldw	ra,4(sp)
 8243ce0:	df000017 	ldw	fp,0(sp)
 8243ce4:	dec00204 	addi	sp,sp,8
 8243ce8:	f800283a 	ret

08243cec <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 8243cec:	defffa04 	addi	sp,sp,-24
 8243cf0:	dfc00515 	stw	ra,20(sp)
 8243cf4:	df000415 	stw	fp,16(sp)
 8243cf8:	df000404 	addi	fp,sp,16
 8243cfc:	e13ffe15 	stw	r4,-8(fp)
 8243d00:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 8243d04:	e0bffe17 	ldw	r2,-8(fp)
 8243d08:	10c00044 	addi	r3,r2,1
 8243d0c:	00bfff84 	movi	r2,-2
 8243d10:	1884703a 	and	r2,r3,r2
 8243d14:	e0bffc15 	stw	r2,-16(fp)
   if (!hdrincl)
 8243d18:	e0bfff17 	ldw	r2,-4(fp)
 8243d1c:	1000031e 	bne	r2,zero,8243d2c <ip_raw_alloc+0x40>
      len += IPHSIZ;
 8243d20:	e0bffc17 	ldw	r2,-16(fp)
 8243d24:	10800504 	addi	r2,r2,20
 8243d28:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243d2c:	01000084 	movi	r4,2
 8243d30:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 8243d34:	d0e08117 	ldw	r3,-32252(gp)
 8243d38:	e0bffc17 	ldw	r2,-16(fp)
 8243d3c:	1885883a 	add	r2,r3,r2
 8243d40:	1009883a 	mov	r4,r2
 8243d44:	822c6200 	call	822c620 <pk_alloc>
 8243d48:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243d4c:	01000084 	movi	r4,2
 8243d50:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   if (p)
 8243d54:	e0bffd17 	ldw	r2,-12(fp)
 8243d58:	10000c26 	beq	r2,zero,8243d8c <ip_raw_alloc+0xa0>
   {
      if (!hdrincl)
 8243d5c:	e0bfff17 	ldw	r2,-4(fp)
 8243d60:	10000a1e 	bne	r2,zero,8243d8c <ip_raw_alloc+0xa0>
      {
         p->nb_prot += IPHSIZ;
 8243d64:	e0bffd17 	ldw	r2,-12(fp)
 8243d68:	10800317 	ldw	r2,12(r2)
 8243d6c:	10c00504 	addi	r3,r2,20
 8243d70:	e0bffd17 	ldw	r2,-12(fp)
 8243d74:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 8243d78:	e0bffd17 	ldw	r2,-12(fp)
 8243d7c:	10800417 	ldw	r2,16(r2)
 8243d80:	10fffb04 	addi	r3,r2,-20
 8243d84:	e0bffd17 	ldw	r2,-12(fp)
 8243d88:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 8243d8c:	e0bffd17 	ldw	r2,-12(fp)
}
 8243d90:	e037883a 	mov	sp,fp
 8243d94:	dfc00117 	ldw	ra,4(sp)
 8243d98:	df000017 	ldw	fp,0(sp)
 8243d9c:	dec00204 	addi	sp,sp,8
 8243da0:	f800283a 	ret

08243da4 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 8243da4:	defffd04 	addi	sp,sp,-12
 8243da8:	dfc00215 	stw	ra,8(sp)
 8243dac:	df000115 	stw	fp,4(sp)
 8243db0:	df000104 	addi	fp,sp,4
 8243db4:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243db8:	01000084 	movi	r4,2
 8243dbc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 8243dc0:	e13fff17 	ldw	r4,-4(fp)
 8243dc4:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243dc8:	01000084 	movi	r4,2
 8243dcc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
}
 8243dd0:	0001883a 	nop
 8243dd4:	e037883a 	mov	sp,fp
 8243dd8:	dfc00117 	ldw	ra,4(sp)
 8243ddc:	df000017 	ldw	fp,0(sp)
 8243de0:	dec00204 	addi	sp,sp,8
 8243de4:	f800283a 	ret

08243de8 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 8243de8:	defffd04 	addi	sp,sp,-12
 8243dec:	df000215 	stw	fp,8(sp)
 8243df0:	df000204 	addi	fp,sp,8
 8243df4:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 8243df8:	d0a03917 	ldw	r2,-32540(gp)
 8243dfc:	d0e08117 	ldw	r3,-32252(gp)
 8243e00:	10c5c83a 	sub	r2,r2,r3
 8243e04:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 8243e08:	e0bfff17 	ldw	r2,-4(fp)
 8243e0c:	1000031e 	bne	r2,zero,8243e1c <ip_raw_maxalloc+0x34>
      len -= IPHSIZ;
 8243e10:	e0bffe17 	ldw	r2,-8(fp)
 8243e14:	10bffb04 	addi	r2,r2,-20
 8243e18:	e0bffe15 	stw	r2,-8(fp)
   return len;
 8243e1c:	e0bffe17 	ldw	r2,-8(fp)
}
 8243e20:	e037883a 	mov	sp,fp
 8243e24:	df000017 	ldw	fp,0(sp)
 8243e28:	dec00104 	addi	sp,sp,4
 8243e2c:	f800283a 	ret

08243e30 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 8243e30:	defff804 	addi	sp,sp,-32
 8243e34:	df000715 	stw	fp,28(sp)
 8243e38:	df000704 	addi	fp,sp,28
 8243e3c:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 8243e40:	e03ffb05 	stb	zero,-20(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 8243e44:	e03ffa15 	stw	zero,-24(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8243e48:	d0a0c617 	ldw	r2,-31976(gp)
 8243e4c:	e0bff915 	stw	r2,-28(fp)
 8243e50:	00003a06 	br	8243f3c <rt_lookup+0x10c>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 8243e54:	e0bff917 	ldw	r2,-28(fp)
 8243e58:	10800617 	ldw	r2,24(r2)
 8243e5c:	10003326 	beq	r2,zero,8243f2c <rt_lookup+0xfc>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 8243e60:	e0bff917 	ldw	r2,-28(fp)
 8243e64:	10800a17 	ldw	r2,40(r2)
 8243e68:	e0bffd15 	stw	r2,-12(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 8243e6c:	e0bff917 	ldw	r2,-28(fp)
 8243e70:	10c00017 	ldw	r3,0(r2)
 8243e74:	e0bfff17 	ldw	r2,-4(fp)
 8243e78:	1886f03a 	xor	r3,r3,r2
 8243e7c:	e0bffd17 	ldw	r2,-12(fp)
 8243e80:	1884703a 	and	r2,r3,r2
 8243e84:	10002a1e 	bne	r2,zero,8243f30 <rt_lookup+0x100>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8243e88:	e03ffb45 	stb	zero,-19(fp)
 8243e8c:	00a00034 	movhi	r2,32768
 8243e90:	e0bffc15 	stw	r2,-16(fp)
 8243e94:	00001806 	br	8243ef8 <rt_lookup+0xc8>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 8243e98:	e0bffd17 	ldw	r2,-12(fp)
 8243e9c:	1006d63a 	srli	r3,r2,24
 8243ea0:	e0bffd17 	ldw	r2,-12(fp)
 8243ea4:	1004d23a 	srli	r2,r2,8
 8243ea8:	10bfc00c 	andi	r2,r2,65280
 8243eac:	1886b03a 	or	r3,r3,r2
 8243eb0:	e0bffd17 	ldw	r2,-12(fp)
 8243eb4:	10bfc00c 	andi	r2,r2,65280
 8243eb8:	1004923a 	slli	r2,r2,8
 8243ebc:	1886b03a 	or	r3,r3,r2
 8243ec0:	e0bffd17 	ldw	r2,-12(fp)
 8243ec4:	1004963a 	slli	r2,r2,24
 8243ec8:	1886b03a 	or	r3,r3,r2
 8243ecc:	e0bffc17 	ldw	r2,-16(fp)
 8243ed0:	1884703a 	and	r2,r3,r2
 8243ed4:	e0bffe15 	stw	r2,-8(fp)
            if (extracted_bit) ++curr_bits_matched;
 8243ed8:	e0bffe17 	ldw	r2,-8(fp)
 8243edc:	10000326 	beq	r2,zero,8243eec <rt_lookup+0xbc>
 8243ee0:	e0bffb43 	ldbu	r2,-19(fp)
 8243ee4:	10800044 	addi	r2,r2,1
 8243ee8:	e0bffb45 	stb	r2,-19(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8243eec:	e0bffc17 	ldw	r2,-16(fp)
 8243ef0:	1004d07a 	srli	r2,r2,1
 8243ef4:	e0bffc15 	stw	r2,-16(fp)
 8243ef8:	e0bffc17 	ldw	r2,-16(fp)
 8243efc:	103fe61e 	bne	r2,zero,8243e98 <rt_lookup+0x68>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 8243f00:	e0bffb43 	ldbu	r2,-19(fp)
 8243f04:	e0fffb03 	ldbu	r3,-20(fp)
 8243f08:	1880092e 	bgeu	r3,r2,8243f30 <rt_lookup+0x100>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 8243f0c:	e0bffb43 	ldbu	r2,-19(fp)
 8243f10:	e0bffb05 	stb	r2,-20(fp)
            netmatch = rtp;
 8243f14:	e0bff917 	ldw	r2,-28(fp)
 8243f18:	e0bffa15 	stw	r2,-24(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 8243f1c:	e0bffb03 	ldbu	r2,-20(fp)
 8243f20:	10800818 	cmpnei	r2,r2,32
 8243f24:	10000c26 	beq	r2,zero,8243f58 <rt_lookup+0x128>
 8243f28:	00000106 	br	8243f30 <rt_lookup+0x100>

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
         continue;
 8243f2c:	0001883a 	nop
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8243f30:	e0bff917 	ldw	r2,-28(fp)
 8243f34:	10800f04 	addi	r2,r2,60
 8243f38:	e0bff915 	stw	r2,-28(fp)
 8243f3c:	d0e0c617 	ldw	r3,-31976(gp)
 8243f40:	d0a05117 	ldw	r2,-32444(gp)
 8243f44:	10800f24 	muli	r2,r2,60
 8243f48:	1885883a 	add	r2,r3,r2
 8243f4c:	e0fff917 	ldw	r3,-28(fp)
 8243f50:	18bfc036 	bltu	r3,r2,8243e54 <rt_lookup+0x24>
 8243f54:	00000106 	br	8243f5c <rt_lookup+0x12c>
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
            netmatch = rtp;
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
               break;
 8243f58:	0001883a 	nop
         }
      }
   }

   if (netmatch)
 8243f5c:	e0bffa17 	ldw	r2,-24(fp)
 8243f60:	10000326 	beq	r2,zero,8243f70 <rt_lookup+0x140>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 8243f64:	d0e0a817 	ldw	r3,-32096(gp)
 8243f68:	e0bffa17 	ldw	r2,-24(fp)
 8243f6c:	10c00915 	stw	r3,36(r2)

   return netmatch;
 8243f70:	e0bffa17 	ldw	r2,-24(fp)
}
 8243f74:	e037883a 	mov	sp,fp
 8243f78:	df000017 	ldw	fp,0(sp)
 8243f7c:	dec00104 	addi	sp,sp,4
 8243f80:	f800283a 	ret

08243f84 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 8243f84:	defff704 	addi	sp,sp,-36
 8243f88:	dfc00815 	stw	ra,32(sp)
 8243f8c:	df000715 	stw	fp,28(sp)
 8243f90:	df000704 	addi	fp,sp,28
 8243f94:	e13ffc15 	stw	r4,-16(fp)
 8243f98:	e17ffd15 	stw	r5,-12(fp)
 8243f9c:	e1bffe15 	stw	r6,-8(fp)
 8243fa0:	e1ffff15 	stw	r7,-4(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 8243fa4:	e03ffa15 	stw	zero,-24(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 8243fa8:	e13fff17 	ldw	r4,-4(fp)
 8243fac:	823e99c0 	call	823e99c <if_getbynum>
 8243fb0:	e0bffb15 	stw	r2,-20(fp)
   if(!ifp)
 8243fb4:	e0bffb17 	ldw	r2,-20(fp)
 8243fb8:	1000021e 	bne	r2,zero,8243fc4 <add_route+0x40>
      return NULL;
 8243fbc:	0005883a 	mov	r2,zero
 8243fc0:	0000db06 	br	8244330 <add_route+0x3ac>

   if (rt_mib == NULL)
 8243fc4:	d0a0c617 	ldw	r2,-31976(gp)
 8243fc8:	1000021e 	bne	r2,zero,8243fd4 <add_route+0x50>
      return NULL;
 8243fcc:	0005883a 	mov	r2,zero
 8243fd0:	0000d706 	br	8244330 <add_route+0x3ac>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 8243fd4:	e0bffc17 	ldw	r2,-16(fp)
 8243fd8:	10000226 	beq	r2,zero,8243fe4 <add_route+0x60>
 8243fdc:	e0bffd17 	ldw	r2,-12(fp)
 8243fe0:	1000221e 	bne	r2,zero,824406c <add_route+0xe8>
   {
      dtrap();    /* bad configuration? */
 8243fe4:	822d1c80 	call	822d1c8 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
	      htonl(dest), htonl(mask) );
 8243fe8:	e0bffc17 	ldw	r2,-16(fp)
 8243fec:	1006d63a 	srli	r3,r2,24
 8243ff0:	e0bffc17 	ldw	r2,-16(fp)
 8243ff4:	1004d23a 	srli	r2,r2,8
 8243ff8:	10bfc00c 	andi	r2,r2,65280
 8243ffc:	1886b03a 	or	r3,r3,r2
 8244000:	e0bffc17 	ldw	r2,-16(fp)
 8244004:	10bfc00c 	andi	r2,r2,65280
 8244008:	1004923a 	slli	r2,r2,8
 824400c:	1886b03a 	or	r3,r3,r2
 8244010:	e0bffc17 	ldw	r2,-16(fp)
 8244014:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244018:	1888b03a 	or	r4,r3,r2
	      htonl(dest), htonl(mask) );
 824401c:	e0bffd17 	ldw	r2,-12(fp)
 8244020:	1006d63a 	srli	r3,r2,24
 8244024:	e0bffd17 	ldw	r2,-12(fp)
 8244028:	1004d23a 	srli	r2,r2,8
 824402c:	10bfc00c 	andi	r2,r2,65280
 8244030:	1886b03a 	or	r3,r3,r2
 8244034:	e0bffd17 	ldw	r2,-12(fp)
 8244038:	10bfc00c 	andi	r2,r2,65280
 824403c:	1004923a 	slli	r2,r2,8
 8244040:	1886b03a 	or	r3,r3,r2
 8244044:	e0bffd17 	ldw	r2,-12(fp)
 8244048:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 824404c:	1884b03a 	or	r2,r3,r2
 8244050:	100d883a 	mov	r6,r2
 8244054:	200b883a 	mov	r5,r4
 8244058:	01020974 	movhi	r4,2085
 824405c:	21041f04 	addi	r4,r4,4220
 8244060:	8202e9c0 	call	8202e9c <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 8244064:	0005883a 	mov	r2,zero
 8244068:	0000b106 	br	8244330 <add_route+0x3ac>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824406c:	d0a0c617 	ldw	r2,-31976(gp)
 8244070:	e0bff915 	stw	r2,-28(fp)
 8244074:	00006a06 	br	8244220 <add_route+0x29c>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 8244078:	e0bff917 	ldw	r2,-28(fp)
 824407c:	10c00017 	ldw	r3,0(r2)
 8244080:	e0bffc17 	ldw	r2,-16(fp)
 8244084:	1880151e 	bne	r3,r2,82440dc <add_route+0x158>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 8244088:	e0bff917 	ldw	r2,-28(fp)
 824408c:	e0fffe17 	ldw	r3,-8(fp)
 8244090:	10c00615 	stw	r3,24(r2)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 8244094:	d0e0a817 	ldw	r3,-32096(gp)
 8244098:	e0bff917 	ldw	r2,-28(fp)
 824409c:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 82440a0:	e0bfff17 	ldw	r2,-4(fp)
 82440a4:	10c00044 	addi	r3,r2,1
 82440a8:	e0bff917 	ldw	r2,-28(fp)
 82440ac:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 82440b0:	e0bff917 	ldw	r2,-28(fp)
 82440b4:	e0c00217 	ldw	r3,8(fp)
 82440b8:	10c00815 	stw	r3,32(r2)
         rtp->ipRouteMask = mask;
 82440bc:	e0bff917 	ldw	r2,-28(fp)
 82440c0:	e0fffd17 	ldw	r3,-12(fp)
 82440c4:	10c00a15 	stw	r3,40(r2)
         rtp->ifp = ifp;
 82440c8:	e0bff917 	ldw	r2,-28(fp)
 82440cc:	e0fffb17 	ldw	r3,-20(fp)
 82440d0:	10c00e15 	stw	r3,56(r2)
         return(rtp);   /* just update and exit */
 82440d4:	e0bff917 	ldw	r2,-28(fp)
 82440d8:	00009506 	br	8244330 <add_route+0x3ac>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 82440dc:	e0bffa17 	ldw	r2,-24(fp)
 82440e0:	10000326 	beq	r2,zero,82440f0 <add_route+0x16c>
 82440e4:	e0bffa17 	ldw	r2,-24(fp)
 82440e8:	10800817 	ldw	r2,32(r2)
 82440ec:	10004926 	beq	r2,zero,8244214 <add_route+0x290>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 82440f0:	e0bff917 	ldw	r2,-28(fp)
 82440f4:	10800617 	ldw	r2,24(r2)
 82440f8:	1000051e 	bne	r2,zero,8244110 <add_route+0x18c>
         {
            newrt = rtp;   /* record empty route for use */
 82440fc:	e0bff917 	ldw	r2,-28(fp)
 8244100:	e0bffa15 	stw	r2,-24(fp)
            newrt->ipRouteProto = 0;
 8244104:	e0bffa17 	ldw	r2,-24(fp)
 8244108:	10000815 	stw	zero,32(r2)
            continue;
 824410c:	00004106 	br	8244214 <add_route+0x290>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 8244110:	00820974 	movhi	r2,2085
 8244114:	108dd004 	addi	r2,r2,14144
 8244118:	e0c00217 	ldw	r3,8(fp)
 824411c:	10c5883a 	add	r2,r2,r3
 8244120:	11000003 	ldbu	r4,0(r2)
 8244124:	e0bff917 	ldw	r2,-28(fp)
 8244128:	10c00817 	ldw	r3,32(r2)
 824412c:	00820974 	movhi	r2,2085
 8244130:	108dd004 	addi	r2,r2,14144
 8244134:	10c5883a 	add	r2,r2,r3
 8244138:	10800003 	ldbu	r2,0(r2)
 824413c:	20c03fcc 	andi	r3,r4,255
 8244140:	10803fcc 	andi	r2,r2,255
 8244144:	18803336 	bltu	r3,r2,8244214 <add_route+0x290>
         {
            if (!newrt)
 8244148:	e0bffa17 	ldw	r2,-24(fp)
 824414c:	1000031e 	bne	r2,zero,824415c <add_route+0x1d8>
            {
               newrt = rtp;
 8244150:	e0bff917 	ldw	r2,-28(fp)
 8244154:	e0bffa15 	stw	r2,-24(fp)
               continue;
 8244158:	00002e06 	br	8244214 <add_route+0x290>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 824415c:	e0bff917 	ldw	r2,-28(fp)
 8244160:	10c00817 	ldw	r3,32(r2)
 8244164:	00820974 	movhi	r2,2085
 8244168:	108dd004 	addi	r2,r2,14144
 824416c:	10c5883a 	add	r2,r2,r3
 8244170:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 8244174:	e0bffa17 	ldw	r2,-24(fp)
 8244178:	10c00817 	ldw	r3,32(r2)
 824417c:	00820974 	movhi	r2,2085
 8244180:	108dd004 	addi	r2,r2,14144
 8244184:	10c5883a 	add	r2,r2,r3
 8244188:	10800003 	ldbu	r2,0(r2)
               newrt = rtp;
               continue;
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 824418c:	20c03fcc 	andi	r3,r4,255
 8244190:	10803fcc 	andi	r2,r2,255
 8244194:	1880032e 	bgeu	r3,r2,82441a4 <add_route+0x220>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 8244198:	e0bff917 	ldw	r2,-28(fp)
 824419c:	e0bffa15 	stw	r2,-24(fp)
 82441a0:	00001c06 	br	8244214 <add_route+0x290>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82441a4:	e0bff917 	ldw	r2,-28(fp)
 82441a8:	10c00817 	ldw	r3,32(r2)
 82441ac:	00820974 	movhi	r2,2085
 82441b0:	108dd004 	addi	r2,r2,14144
 82441b4:	10c5883a 	add	r2,r2,r3
 82441b8:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 82441bc:	e0bffa17 	ldw	r2,-24(fp)
 82441c0:	10c00817 	ldw	r3,32(r2)
 82441c4:	00820974 	movhi	r2,2085
 82441c8:	108dd004 	addi	r2,r2,14144
 82441cc:	10c5883a 	add	r2,r2,r3
 82441d0:	10800003 	ldbu	r2,0(r2)
            if (rtp_priority[rtp->ipRouteProto] < 
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82441d4:	20c03fcc 	andi	r3,r4,255
 82441d8:	10803fcc 	andi	r2,r2,255
 82441dc:	18800d1e 	bne	r3,r2,8244214 <add_route+0x290>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 82441e0:	e0bff917 	ldw	r2,-28(fp)
 82441e4:	10c00917 	ldw	r3,36(r2)
 82441e8:	e0bffa17 	ldw	r2,-24(fp)
 82441ec:	10800917 	ldw	r2,36(r2)
 82441f0:	100b883a 	mov	r5,r2
 82441f4:	1809883a 	mov	r4,r3
 82441f8:	822629c0 	call	822629c <c_older>
 82441fc:	1007883a 	mov	r3,r2
 8244200:	e0bff917 	ldw	r2,-28(fp)
 8244204:	10800917 	ldw	r2,36(r2)
 8244208:	1880021e 	bne	r3,r2,8244214 <add_route+0x290>
                  newrt = rtp;   /* got an older one */
 824420c:	e0bff917 	ldw	r2,-28(fp)
 8244210:	e0bffa15 	stw	r2,-24(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244214:	e0bff917 	ldw	r2,-28(fp)
 8244218:	10800f04 	addi	r2,r2,60
 824421c:	e0bff915 	stw	r2,-28(fp)
 8244220:	d0e0c617 	ldw	r3,-31976(gp)
 8244224:	d0a05117 	ldw	r2,-32444(gp)
 8244228:	10800f24 	muli	r2,r2,60
 824422c:	1885883a 	add	r2,r3,r2
 8244230:	e0fff917 	ldw	r3,-28(fp)
 8244234:	18bf9036 	bltu	r3,r2,8244078 <add_route+0xf4>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 8244238:	e0bffa17 	ldw	r2,-24(fp)
 824423c:	10002926 	beq	r2,zero,82442e4 <add_route+0x360>
      rtp = newrt;   /* create new entry in lowest priority slot */
 8244240:	e0bffa17 	ldw	r2,-24(fp)
 8244244:	e0bff915 	stw	r2,-28(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 8244248:	e0bff917 	ldw	r2,-28(fp)
 824424c:	e0fffb17 	ldw	r3,-20(fp)
 8244250:	10c00e15 	stw	r3,56(r2)
   rtp->ipRouteDest = dest;
 8244254:	e0bff917 	ldw	r2,-28(fp)
 8244258:	e0fffc17 	ldw	r3,-16(fp)
 824425c:	10c00015 	stw	r3,0(r2)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 8244260:	e13ffb17 	ldw	r4,-20(fp)
 8244264:	822689c0 	call	822689c <if_netnumber>
 8244268:	10c00044 	addi	r3,r2,1
 824426c:	e0bff917 	ldw	r2,-28(fp)
 8244270:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 8244274:	008209b4 	movhi	r2,2086
 8244278:	10b8f804 	addi	r2,r2,-7200
 824427c:	10800117 	ldw	r2,4(r2)
 8244280:	1007883a 	mov	r3,r2
 8244284:	e0bff917 	ldw	r2,-28(fp)
 8244288:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 824428c:	e0bff917 	ldw	r2,-28(fp)
 8244290:	00ffffc4 	movi	r3,-1
 8244294:	10c00315 	stw	r3,12(r2)
   rtp->ipRouteMetric3 = -1;
 8244298:	e0bff917 	ldw	r2,-28(fp)
 824429c:	00ffffc4 	movi	r3,-1
 82442a0:	10c00415 	stw	r3,16(r2)
   rtp->ipRouteMetric4 = -1;
 82442a4:	e0bff917 	ldw	r2,-28(fp)
 82442a8:	00ffffc4 	movi	r3,-1
 82442ac:	10c00515 	stw	r3,20(r2)
   rtp->ipRouteNextHop = nexthop;
 82442b0:	e0bff917 	ldw	r2,-28(fp)
 82442b4:	e0fffe17 	ldw	r3,-8(fp)
 82442b8:	10c00615 	stw	r3,24(r2)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 82442bc:	e0bff917 	ldw	r2,-28(fp)
 82442c0:	e0c00217 	ldw	r3,8(fp)
 82442c4:	10c00815 	stw	r3,32(r2)

   if ((dest & mask) == (nexthop & mask))
 82442c8:	e0fffc17 	ldw	r3,-16(fp)
 82442cc:	e0bffe17 	ldw	r2,-8(fp)
 82442d0:	1886f03a 	xor	r3,r3,r2
 82442d4:	e0bffd17 	ldw	r2,-12(fp)
 82442d8:	1884703a 	and	r2,r3,r2
 82442dc:	1000071e 	bne	r2,zero,82442fc <add_route+0x378>
 82442e0:	00000206 	br	82442ec <add_route+0x368>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 82442e4:	0005883a 	mov	r2,zero
 82442e8:	00001106 	br	8244330 <add_route+0x3ac>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 82442ec:	e0bff917 	ldw	r2,-28(fp)
 82442f0:	00c000c4 	movi	r3,3
 82442f4:	10c00715 	stw	r3,28(r2)
 82442f8:	00000306 	br	8244308 <add_route+0x384>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 82442fc:	e0bff917 	ldw	r2,-28(fp)
 8244300:	00c00104 	movi	r3,4
 8244304:	10c00715 	stw	r3,28(r2)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 8244308:	d0e0a817 	ldw	r3,-32096(gp)
 824430c:	e0bff917 	ldw	r2,-28(fp)
 8244310:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 8244314:	e0bff917 	ldw	r2,-28(fp)
 8244318:	e0fffd17 	ldw	r3,-12(fp)
 824431c:	10c00a15 	stw	r3,40(r2)
   rtp->ipRouteMetric5 = -1;
 8244320:	e0bff917 	ldw	r2,-28(fp)
 8244324:	00ffffc4 	movi	r3,-1
 8244328:	10c00b15 	stw	r3,44(r2)
   return(rtp);
 824432c:	e0bff917 	ldw	r2,-28(fp)
}
 8244330:	e037883a 	mov	sp,fp
 8244334:	dfc00117 	ldw	ra,4(sp)
 8244338:	df000017 	ldw	fp,0(sp)
 824433c:	dec00204 	addi	sp,sp,8
 8244340:	f800283a 	ret

08244344 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 8244344:	defff804 	addi	sp,sp,-32
 8244348:	dfc00715 	stw	ra,28(sp)
 824434c:	df000615 	stw	fp,24(sp)
 8244350:	df000604 	addi	fp,sp,24
 8244354:	e13ffd15 	stw	r4,-12(fp)
 8244358:	e17ffe15 	stw	r5,-8(fp)
 824435c:	e1bfff15 	stw	r6,-4(fp)
   RTMIB rtp;
   int   retval   =  0;
 8244360:	e03ffb15 	stw	zero,-20(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 8244364:	e0bfff17 	ldw	r2,-4(fp)
 8244368:	10bfffd8 	cmpnei	r2,r2,-1
 824436c:	1000021e 	bne	r2,zero,8244378 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 8244370:	e03ffc15 	stw	zero,-16(fp)
 8244374:	00000306 	br	8244384 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 8244378:	e13fff17 	ldw	r4,-4(fp)
 824437c:	823e99c0 	call	823e99c <if_getbynum>
 8244380:	e0bffc15 	stw	r2,-16(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 8244384:	d0a0c617 	ldw	r2,-31976(gp)
 8244388:	1000021e 	bne	r2,zero,8244394 <del_route+0x50>
      return 0;
 824438c:	0005883a 	mov	r2,zero
 8244390:	00002c06 	br	8244444 <del_route+0x100>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244394:	d0a0c617 	ldw	r2,-31976(gp)
 8244398:	e0bffa15 	stw	r2,-24(fp)
 824439c:	00002206 	br	8244428 <del_route+0xe4>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 82443a0:	e0bffa17 	ldw	r2,-24(fp)
 82443a4:	10800617 	ldw	r2,24(r2)
 82443a8:	10001926 	beq	r2,zero,8244410 <del_route+0xcc>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 82443ac:	e0bffc17 	ldw	r2,-16(fp)
 82443b0:	10000426 	beq	r2,zero,82443c4 <del_route+0x80>
 82443b4:	e0bffa17 	ldw	r2,-24(fp)
 82443b8:	10c00e17 	ldw	r3,56(r2)
 82443bc:	e0bffc17 	ldw	r2,-16(fp)
 82443c0:	1880151e 	bne	r3,r2,8244418 <del_route+0xd4>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 82443c4:	e0bffa17 	ldw	r2,-24(fp)
 82443c8:	10c00017 	ldw	r3,0(r2)
 82443cc:	e0bffd17 	ldw	r2,-12(fp)
 82443d0:	1886f03a 	xor	r3,r3,r2
 82443d4:	e0bffe17 	ldw	r2,-8(fp)
 82443d8:	1884703a 	and	r2,r3,r2
 82443dc:	1000071e 	bne	r2,zero,82443fc <del_route+0xb8>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 82443e0:	01800f04 	movi	r6,60
 82443e4:	000b883a 	mov	r5,zero
 82443e8:	e13ffa17 	ldw	r4,-24(fp)
 82443ec:	8202cb00 	call	8202cb0 <memset>
         retval++;
 82443f0:	e0bffb17 	ldw	r2,-20(fp)
 82443f4:	10800044 	addi	r2,r2,1
 82443f8:	e0bffb15 	stw	r2,-20(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 82443fc:	d0e0d017 	ldw	r3,-31936(gp)
 8244400:	e0bffa17 	ldw	r2,-24(fp)
 8244404:	1880051e 	bne	r3,r2,824441c <del_route+0xd8>
         cachedRoute = NULL;
 8244408:	d020d015 	stw	zero,-31936(gp)
 824440c:	00000306 	br	824441c <del_route+0xd8>
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
         continue;
 8244410:	0001883a 	nop
 8244414:	00000106 	br	824441c <del_route+0xd8>
      if(ifp != NULL && ifp != rtp->ifp)
         continue;   /* interface didn't match */
 8244418:	0001883a 	nop
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824441c:	e0bffa17 	ldw	r2,-24(fp)
 8244420:	10800f04 	addi	r2,r2,60
 8244424:	e0bffa15 	stw	r2,-24(fp)
 8244428:	d0e0c617 	ldw	r3,-31976(gp)
 824442c:	d0a05117 	ldw	r2,-32444(gp)
 8244430:	10800f24 	muli	r2,r2,60
 8244434:	1885883a 	add	r2,r3,r2
 8244438:	e0fffa17 	ldw	r3,-24(fp)
 824443c:	18bfd836 	bltu	r3,r2,82443a0 <del_route+0x5c>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 8244440:	e0bffb17 	ldw	r2,-20(fp)
}
 8244444:	e037883a 	mov	sp,fp
 8244448:	dfc00117 	ldw	ra,4(sp)
 824444c:	df000017 	ldw	fp,0(sp)
 8244450:	dec00204 	addi	sp,sp,8
 8244454:	f800283a 	ret

08244458 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 8244458:	deffec04 	addi	sp,sp,-80
 824445c:	dfc01315 	stw	ra,76(sp)
 8244460:	df001215 	stw	fp,72(sp)
 8244464:	df001204 	addi	fp,sp,72
 8244468:	e13fff15 	stw	r4,-4(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 824446c:	e0bfff17 	ldw	r2,-4(fp)
 8244470:	10800317 	ldw	r2,12(r2)
 8244474:	e0bff615 	stw	r2,-40(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 8244478:	e0bff617 	ldw	r2,-40(fp)
 824447c:	10800003 	ldbu	r2,0(r2)
 8244480:	10803fcc 	andi	r2,r2,255
 8244484:	108003cc 	andi	r2,r2,15
 8244488:	1085883a 	add	r2,r2,r2
 824448c:	1085883a 	add	r2,r2,r2
 8244490:	1007883a 	mov	r3,r2
 8244494:	e0bff617 	ldw	r2,-40(fp)
 8244498:	10c5883a 	add	r2,r2,r3
 824449c:	e0bff715 	stw	r2,-36(fp)
   plen = htons(pup->ud_len);
 82444a0:	e0bff717 	ldw	r2,-36(fp)
 82444a4:	1080010b 	ldhu	r2,4(r2)
 82444a8:	10bfffcc 	andi	r2,r2,65535
 82444ac:	1004d23a 	srli	r2,r2,8
 82444b0:	10bfffcc 	andi	r2,r2,65535
 82444b4:	10c03fcc 	andi	r3,r2,255
 82444b8:	e0bff717 	ldw	r2,-36(fp)
 82444bc:	1080010b 	ldhu	r2,4(r2)
 82444c0:	10bfffcc 	andi	r2,r2,65535
 82444c4:	1004923a 	slli	r2,r2,8
 82444c8:	10bfffcc 	andi	r2,r2,65535
 82444cc:	1884b03a 	or	r2,r3,r2
 82444d0:	e0bff815 	stw	r2,-32(fp)

   if (plen > p->nb_plen)
 82444d4:	e0bfff17 	ldw	r2,-4(fp)
 82444d8:	10c00417 	ldw	r3,16(r2)
 82444dc:	e0bff817 	ldw	r2,-32(fp)
 82444e0:	1880252e 	bgeu	r3,r2,8244578 <udpdemux+0x120>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 82444e4:	d0a08317 	ldw	r2,-32244(gp)
 82444e8:	1081000c 	andi	r2,r2,1024
 82444ec:	10001726 	beq	r2,zero,824454c <udpdemux+0xf4>
 82444f0:	d0a08317 	ldw	r2,-32244(gp)
 82444f4:	1080400c 	andi	r2,r2,256
 82444f8:	10001426 	beq	r2,zero,824454c <udpdemux+0xf4>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 82444fc:	e0bfff17 	ldw	r2,-4(fp)
 8244500:	11000417 	ldw	r4,16(r2)
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 8244504:	e0bff717 	ldw	r2,-36(fp)
 8244508:	1080010b 	ldhu	r2,4(r2)
 824450c:	10bfffcc 	andi	r2,r2,65535
 8244510:	1004d23a 	srli	r2,r2,8
 8244514:	10bfffcc 	andi	r2,r2,65535
 8244518:	10c03fcc 	andi	r3,r2,255
 824451c:	e0bff717 	ldw	r2,-36(fp)
 8244520:	1080010b 	ldhu	r2,4(r2)
 8244524:	10bfffcc 	andi	r2,r2,65535
 8244528:	1004923a 	slli	r2,r2,8
 824452c:	10bfffcc 	andi	r2,r2,65535
 8244530:	1884b03a 	or	r2,r3,r2
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 8244534:	10800204 	addi	r2,r2,8
 8244538:	100d883a 	mov	r6,r2
 824453c:	200b883a 	mov	r5,r4
 8244540:	01020974 	movhi	r4,2085
 8244544:	21042d04 	addi	r4,r4,4276
 8244548:	8202e9c0 	call	8202e9c <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 824454c:	008209b4 	movhi	r2,2086
 8244550:	10b91204 	addi	r2,r2,-7096
 8244554:	10800217 	ldw	r2,8(r2)
 8244558:	10c00044 	addi	r3,r2,1
 824455c:	008209b4 	movhi	r2,2086
 8244560:	10b91204 	addi	r2,r2,-7096
 8244564:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244568:	e13fff17 	ldw	r4,-4(fp)
 824456c:	824511c0 	call	824511c <udp_free>
      return ENP_BAD_HEADER;
 8244570:	00bff804 	movi	r2,-32
 8244574:	00019d06 	br	8244bec <udpdemux+0x794>
   }

   osum = pup->ud_cksum;
 8244578:	e0bff717 	ldw	r2,-36(fp)
 824457c:	1080018b 	ldhu	r2,6(r2)
 8244580:	e0bff90d 	sth	r2,-28(fp)
   /* did other guy use checksumming? */
   if (osum)
 8244584:	e0bff90b 	ldhu	r2,-28(fp)
 8244588:	10005826 	beq	r2,zero,82446ec <udpdemux+0x294>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 824458c:	e0bff817 	ldw	r2,-32(fp)
 8244590:	1080004c 	andi	r2,r2,1
 8244594:	10000426 	beq	r2,zero,82445a8 <udpdemux+0x150>
 8244598:	e0fff717 	ldw	r3,-36(fp)
 824459c:	e0bff817 	ldw	r2,-32(fp)
 82445a0:	1885883a 	add	r2,r3,r2
 82445a4:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 82445a8:	e0bfff17 	ldw	r2,-4(fp)
 82445ac:	10800717 	ldw	r2,28(r2)
 82445b0:	e0bffc15 	stw	r2,-16(fp)
      php.ph_dest = pip->ip_dest;
 82445b4:	e0bff617 	ldw	r2,-40(fp)
 82445b8:	10800417 	ldw	r2,16(r2)
 82445bc:	e0bffd15 	stw	r2,-12(fp)
      php.ph_zero = 0;
 82445c0:	e03ffe05 	stb	zero,-8(fp)
      php.ph_prot = UDP_PROT;
 82445c4:	00800444 	movi	r2,17
 82445c8:	e0bffe45 	stb	r2,-7(fp)
      php.ph_len  = pup->ud_len;
 82445cc:	e0bff717 	ldw	r2,-36(fp)
 82445d0:	1080010b 	ldhu	r2,4(r2)
 82445d4:	e0bffe8d 	sth	r2,-6(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 82445d8:	e0bffc04 	addi	r2,fp,-16
 82445dc:	01400184 	movi	r5,6
 82445e0:	1009883a 	mov	r4,r2
 82445e4:	82283e80 	call	82283e8 <cksum>
 82445e8:	1007883a 	mov	r3,r2
 82445ec:	e0bff717 	ldw	r2,-36(fp)
 82445f0:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 82445f4:	e0bff817 	ldw	r2,-32(fp)
 82445f8:	10800044 	addi	r2,r2,1
 82445fc:	1004d07a 	srli	r2,r2,1
 8244600:	100b883a 	mov	r5,r2
 8244604:	e13ff717 	ldw	r4,-36(fp)
 8244608:	82283e80 	call	82283e8 <cksum>
 824460c:	0084303a 	nor	r2,zero,r2
 8244610:	e0bff30d 	sth	r2,-52(fp)
      if (!xsum)
 8244614:	e0bff30b 	ldhu	r2,-52(fp)
 8244618:	1000021e 	bne	r2,zero,8244624 <udpdemux+0x1cc>
         xsum = 0xffff;
 824461c:	00bfffc4 	movi	r2,-1
 8244620:	e0bff30d 	sth	r2,-52(fp)
      pup->ud_cksum = osum;
 8244624:	e0bff717 	ldw	r2,-36(fp)
 8244628:	e0fff90b 	ldhu	r3,-28(fp)
 824462c:	10c0018d 	sth	r3,6(r2)
      if (xsum != osum)
 8244630:	e0fff30b 	ldhu	r3,-52(fp)
 8244634:	e0bff90b 	ldhu	r2,-28(fp)
 8244638:	18802c26 	beq	r3,r2,82446ec <udpdemux+0x294>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 824463c:	d0a08317 	ldw	r2,-32244(gp)
 8244640:	1081000c 	andi	r2,r2,1024
 8244644:	10001e26 	beq	r2,zero,82446c0 <udpdemux+0x268>
 8244648:	d0a08317 	ldw	r2,-32244(gp)
 824464c:	1080400c 	andi	r2,r2,256
 8244650:	10001b26 	beq	r2,zero,82446c0 <udpdemux+0x268>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244654:	e17ff90b 	ldhu	r5,-28(fp)
 8244658:	e1bff30b 	ldhu	r6,-52(fp)
                    osum, xsum, PUSH_IPADDR(p->fhost));
 824465c:	e0bfff17 	ldw	r2,-4(fp)
 8244660:	10800717 	ldw	r2,28(r2)
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244664:	11c03fcc 	andi	r7,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244668:	e0bfff17 	ldw	r2,-4(fp)
 824466c:	10800717 	ldw	r2,28(r2)
 8244670:	1004d23a 	srli	r2,r2,8
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244674:	10803fcc 	andi	r2,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244678:	e0ffff17 	ldw	r3,-4(fp)
 824467c:	18c00717 	ldw	r3,28(r3)
 8244680:	1806d43a 	srli	r3,r3,16
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244684:	18c03fcc 	andi	r3,r3,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244688:	e13fff17 	ldw	r4,-4(fp)
 824468c:	21000717 	ldw	r4,28(r4)
 8244690:	2008d63a 	srli	r4,r4,24
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244694:	d9000215 	stw	r4,8(sp)
 8244698:	d8c00115 	stw	r3,4(sp)
 824469c:	d8800015 	stw	r2,0(sp)
 82446a0:	01020974 	movhi	r4,2085
 82446a4:	21043704 	addi	r4,r4,4316
 82446a8:	8202e9c0 	call	8202e9c <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 82446ac:	d0a08317 	ldw	r2,-32244(gp)
 82446b0:	1080008c 	andi	r2,r2,2
 82446b4:	10000226 	beq	r2,zero,82446c0 <udpdemux+0x268>
               ip_dump(p);
 82446b8:	e13fff17 	ldw	r4,-4(fp)
 82446bc:	82406940 	call	8240694 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 82446c0:	008209b4 	movhi	r2,2086
 82446c4:	10b91204 	addi	r2,r2,-7096
 82446c8:	10800217 	ldw	r2,8(r2)
 82446cc:	10c00044 	addi	r3,r2,1
 82446d0:	008209b4 	movhi	r2,2086
 82446d4:	10b91204 	addi	r2,r2,-7096
 82446d8:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 82446dc:	e13fff17 	ldw	r4,-4(fp)
 82446e0:	824511c0 	call	824511c <udp_free>
         return ENP_BAD_HEADER;
 82446e4:	00bff804 	movi	r2,-32
 82446e8:	00014006 	br	8244bec <udpdemux+0x794>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 82446ec:	e13ff717 	ldw	r4,-36(fp)
 82446f0:	8244e980 	call	8244e98 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 82446f4:	e0bff617 	ldw	r2,-40(fp)
 82446f8:	10800003 	ldbu	r2,0(r2)
 82446fc:	10803fcc 	andi	r2,r2,255
 8244700:	108003cc 	andi	r2,r2,15
 8244704:	1085883a 	add	r2,r2,r2
 8244708:	1085883a 	add	r2,r2,r2
 824470c:	10800204 	addi	r2,r2,8
 8244710:	e0bff415 	stw	r2,-48(fp)
   p->nb_plen -= e;
 8244714:	e0bfff17 	ldw	r2,-4(fp)
 8244718:	10c00417 	ldw	r3,16(r2)
 824471c:	e0bff417 	ldw	r2,-48(fp)
 8244720:	1887c83a 	sub	r3,r3,r2
 8244724:	e0bfff17 	ldw	r2,-4(fp)
 8244728:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 824472c:	e0bfff17 	ldw	r2,-4(fp)
 8244730:	10c00317 	ldw	r3,12(r2)
 8244734:	e0bff417 	ldw	r2,-48(fp)
 8244738:	1887883a 	add	r3,r3,r2
 824473c:	e0bfff17 	ldw	r2,-4(fp)
 8244740:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244744:	d0a08317 	ldw	r2,-32244(gp)
 8244748:	1081000c 	andi	r2,r2,1024
 824474c:	10001f26 	beq	r2,zero,82447cc <udpdemux+0x374>
 8244750:	d0a08317 	ldw	r2,-32244(gp)
 8244754:	1080400c 	andi	r2,r2,256
 8244758:	10001c26 	beq	r2,zero,82447cc <udpdemux+0x374>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 824475c:	e0bfff17 	ldw	r2,-4(fp)
 8244760:	10800717 	ldw	r2,28(r2)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244764:	11803fcc 	andi	r6,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244768:	e0bfff17 	ldw	r2,-4(fp)
 824476c:	10800717 	ldw	r2,28(r2)
 8244770:	1004d23a 	srli	r2,r2,8
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244774:	11c03fcc 	andi	r7,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244778:	e0bfff17 	ldw	r2,-4(fp)
 824477c:	10800717 	ldw	r2,28(r2)
 8244780:	1004d43a 	srli	r2,r2,16
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244784:	10803fcc 	andi	r2,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244788:	e0ffff17 	ldw	r3,-4(fp)
 824478c:	18c00717 	ldw	r3,28(r3)
 8244790:	1806d63a 	srli	r3,r3,24
 8244794:	e13ff717 	ldw	r4,-36(fp)
 8244798:	2100000b 	ldhu	r4,0(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 824479c:	213fffcc 	andi	r4,r4,65535
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 82447a0:	e17ff717 	ldw	r5,-36(fp)
 82447a4:	2940008b 	ldhu	r5,2(r5)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 82447a8:	297fffcc 	andi	r5,r5,65535
 82447ac:	d9400315 	stw	r5,12(sp)
 82447b0:	d9000215 	stw	r4,8(sp)
 82447b4:	d8c00115 	stw	r3,4(sp)
 82447b8:	d8800015 	stw	r2,0(sp)
 82447bc:	e17ff817 	ldw	r5,-32(fp)
 82447c0:	01020974 	movhi	r4,2085
 82447c4:	21044504 	addi	r4,r4,4372
 82447c8:	8202e9c0 	call	8202e9c <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 82447cc:	d0a09c17 	ldw	r2,-32144(gp)
 82447d0:	e0bff215 	stw	r2,-56(fp)
 82447d4:	0000ae06 	br	8244a90 <udpdemux+0x638>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 82447d8:	e0bff217 	ldw	r2,-56(fp)
 82447dc:	1080018b 	ldhu	r2,6(r2)
 82447e0:	10bfffcc 	andi	r2,r2,65535
 82447e4:	10000726 	beq	r2,zero,8244804 <udpdemux+0x3ac>
 82447e8:	e0bff217 	ldw	r2,-56(fp)
 82447ec:	10c0018b 	ldhu	r3,6(r2)
 82447f0:	e0bff717 	ldw	r2,-36(fp)
 82447f4:	1080008b 	ldhu	r2,2(r2)
 82447f8:	18ffffcc 	andi	r3,r3,65535
 82447fc:	10bfffcc 	andi	r2,r2,65535
 8244800:	1880991e 	bne	r3,r2,8244a68 <udpdemux+0x610>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 8244804:	e0bff217 	ldw	r2,-56(fp)
 8244808:	1080020b 	ldhu	r2,8(r2)
 824480c:	10bfffcc 	andi	r2,r2,65535
 8244810:	10000726 	beq	r2,zero,8244830 <udpdemux+0x3d8>
 8244814:	e0bff217 	ldw	r2,-56(fp)
 8244818:	10c0020b 	ldhu	r3,8(r2)
 824481c:	e0bff717 	ldw	r2,-36(fp)
 8244820:	1080000b 	ldhu	r2,0(r2)
 8244824:	18ffffcc 	andi	r3,r3,65535
 8244828:	10bfffcc 	andi	r2,r2,65535
 824482c:	1880901e 	bne	r3,r2,8244a70 <udpdemux+0x618>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 8244830:	e0bff217 	ldw	r2,-56(fp)
 8244834:	10800417 	ldw	r2,16(r2)
 8244838:	10000526 	beq	r2,zero,8244850 <udpdemux+0x3f8>
 824483c:	e0bff217 	ldw	r2,-56(fp)
 8244840:	10c00417 	ldw	r3,16(r2)
 8244844:	e0bfff17 	ldw	r2,-4(fp)
 8244848:	10800717 	ldw	r2,28(r2)
 824484c:	18808a1e 	bne	r3,r2,8244a78 <udpdemux+0x620>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 8244850:	e0bff617 	ldw	r2,-40(fp)
 8244854:	10800417 	ldw	r2,16(r2)
 8244858:	1006d63a 	srli	r3,r2,24
 824485c:	e0bff617 	ldw	r2,-40(fp)
 8244860:	10800417 	ldw	r2,16(r2)
 8244864:	1004d23a 	srli	r2,r2,8
 8244868:	10bfc00c 	andi	r2,r2,65280
 824486c:	1886b03a 	or	r3,r3,r2
 8244870:	e0bff617 	ldw	r2,-40(fp)
 8244874:	10800417 	ldw	r2,16(r2)
 8244878:	10bfc00c 	andi	r2,r2,65280
 824487c:	1004923a 	slli	r2,r2,8
 8244880:	1886b03a 	or	r3,r3,r2
 8244884:	e0bff617 	ldw	r2,-40(fp)
 8244888:	10800417 	ldw	r2,16(r2)
 824488c:	1004963a 	slli	r2,r2,24
 8244890:	1884b03a 	or	r2,r3,r2
 8244894:	10fc002c 	andhi	r3,r2,61440
 8244898:	00b80034 	movhi	r2,57344
 824489c:	1880301e 	bne	r3,r2,8244960 <udpdemux+0x508>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 82448a0:	e0bff217 	ldw	r2,-56(fp)
 82448a4:	10800617 	ldw	r2,24(r2)
 82448a8:	e0bffa15 	stw	r2,-24(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 82448ac:	e0bff217 	ldw	r2,-56(fp)
 82448b0:	10c00517 	ldw	r3,20(r2)
 82448b4:	00820934 	movhi	r2,2084
 82448b8:	10aaec04 	addi	r2,r2,-21584
 82448bc:	1880281e 	bne	r3,r2,8244960 <udpdemux+0x508>
 82448c0:	e0bffa17 	ldw	r2,-24(fp)
 82448c4:	10800317 	ldw	r2,12(r2)
 82448c8:	10002526 	beq	r2,zero,8244960 <udpdemux+0x508>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 82448cc:	e0bffa17 	ldw	r2,-24(fp)
 82448d0:	10800317 	ldw	r2,12(r2)
 82448d4:	e0bffb15 	stw	r2,-20(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 82448d8:	e03ff50d 	sth	zero,-44(fp)
 82448dc:	00001906 	br	8244944 <udpdemux+0x4ec>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 82448e0:	e0bff50b 	ldhu	r2,-44(fp)
 82448e4:	e0fffb17 	ldw	r3,-20(fp)
 82448e8:	10800084 	addi	r2,r2,2
 82448ec:	1085883a 	add	r2,r2,r2
 82448f0:	1085883a 	add	r2,r2,r2
 82448f4:	1885883a 	add	r2,r3,r2
 82448f8:	10800017 	ldw	r2,0(r2)
 82448fc:	10c00117 	ldw	r3,4(r2)
 8244900:	e0bfff17 	ldw	r2,-4(fp)
 8244904:	10800617 	ldw	r2,24(r2)
 8244908:	18800b1e 	bne	r3,r2,8244938 <udpdemux+0x4e0>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
 824490c:	e0bff50b 	ldhu	r2,-44(fp)
 8244910:	e0fffb17 	ldw	r3,-20(fp)
 8244914:	10800084 	addi	r2,r2,2
 8244918:	1085883a 	add	r2,r2,r2
 824491c:	1085883a 	add	r2,r2,r2
 8244920:	1885883a 	add	r2,r3,r2
 8244924:	10800017 	ldw	r2,0(r2)
 8244928:	10c00017 	ldw	r3,0(r2)
 824492c:	e0bff617 	ldw	r2,-40(fp)
 8244930:	10800417 	ldw	r2,16(r2)
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244934:	18800926 	beq	r3,r2,824495c <udpdemux+0x504>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244938:	e0bff50b 	ldhu	r2,-44(fp)
 824493c:	10800044 	addi	r2,r2,1
 8244940:	e0bff50d 	sth	r2,-44(fp)
 8244944:	e0bffb17 	ldw	r2,-20(fp)
 8244948:	1080018b 	ldhu	r2,6(r2)
 824494c:	10bfffcc 	andi	r2,r2,65535
 8244950:	e0fff50b 	ldhu	r3,-44(fp)
 8244954:	18bfe236 	bltu	r3,r2,82448e0 <udpdemux+0x488>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 8244958:	00004a06 	br	8244a84 <udpdemux+0x62c>
            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
 824495c:	0001883a 	nop
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 8244960:	e0bff617 	ldw	r2,-40(fp)
 8244964:	10800417 	ldw	r2,16(r2)
 8244968:	1006d63a 	srli	r3,r2,24
 824496c:	e0bff617 	ldw	r2,-40(fp)
 8244970:	10800417 	ldw	r2,16(r2)
 8244974:	1004d23a 	srli	r2,r2,8
 8244978:	10bfc00c 	andi	r2,r2,65280
 824497c:	1886b03a 	or	r3,r3,r2
 8244980:	e0bff617 	ldw	r2,-40(fp)
 8244984:	10800417 	ldw	r2,16(r2)
 8244988:	10bfc00c 	andi	r2,r2,65280
 824498c:	1004923a 	slli	r2,r2,8
 8244990:	1886b03a 	or	r3,r3,r2
 8244994:	e0bff617 	ldw	r2,-40(fp)
 8244998:	10800417 	ldw	r2,16(r2)
 824499c:	1004963a 	slli	r2,r2,24
 82449a0:	1884b03a 	or	r2,r3,r2
 82449a4:	10fc002c 	andhi	r3,r2,61440
 82449a8:	00b80034 	movhi	r2,57344
 82449ac:	18800826 	beq	r3,r2,82449d0 <udpdemux+0x578>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 82449b0:	e0bff217 	ldw	r2,-56(fp)
 82449b4:	10800317 	ldw	r2,12(r2)
 82449b8:	10000526 	beq	r2,zero,82449d0 <udpdemux+0x578>
 82449bc:	e0bff217 	ldw	r2,-56(fp)
 82449c0:	10c00317 	ldw	r3,12(r2)
 82449c4:	e0bff617 	ldw	r2,-40(fp)
 82449c8:	10800417 	ldw	r2,16(r2)
 82449cc:	18802c1e 	bne	r3,r2,8244a80 <udpdemux+0x628>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 82449d0:	008209b4 	movhi	r2,2086
 82449d4:	10b91204 	addi	r2,r2,-7096
 82449d8:	10800017 	ldw	r2,0(r2)
 82449dc:	10c00044 	addi	r3,r2,1
 82449e0:	008209b4 	movhi	r2,2086
 82449e4:	10b91204 	addi	r2,r2,-7096
 82449e8:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 82449ec:	e0bff217 	ldw	r2,-56(fp)
 82449f0:	10800517 	ldw	r2,20(r2)
 82449f4:	10000d26 	beq	r2,zero,8244a2c <udpdemux+0x5d4>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 82449f8:	0009883a 	mov	r4,zero
 82449fc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 8244a00:	e0bff217 	ldw	r2,-56(fp)
 8244a04:	10800517 	ldw	r2,20(r2)
 8244a08:	e0fff217 	ldw	r3,-56(fp)
 8244a0c:	18c00617 	ldw	r3,24(r3)
 8244a10:	180b883a 	mov	r5,r3
 8244a14:	e13fff17 	ldw	r4,-4(fp)
 8244a18:	103ee83a 	callr	r2
 8244a1c:	e0bff415 	stw	r2,-48(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8244a20:	0009883a 	mov	r4,zero
 8244a24:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
 8244a28:	00000206 	br	8244a34 <udpdemux+0x5dc>
      }
      else
         e = ENP_LOGIC;
 8244a2c:	00bffd44 	movi	r2,-11
 8244a30:	e0bff415 	stw	r2,-48(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 8244a34:	e0bff417 	ldw	r2,-48(fp)
 8244a38:	10000926 	beq	r2,zero,8244a60 <udpdemux+0x608>
      {
         udp_mib.udpInErrors++;
 8244a3c:	008209b4 	movhi	r2,2086
 8244a40:	10b91204 	addi	r2,r2,-7096
 8244a44:	10800217 	ldw	r2,8(r2)
 8244a48:	10c00044 	addi	r3,r2,1
 8244a4c:	008209b4 	movhi	r2,2086
 8244a50:	10b91204 	addi	r2,r2,-7096
 8244a54:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244a58:	e13fff17 	ldw	r4,-4(fp)
 8244a5c:	824511c0 	call	824511c <udp_free>
      }

      return(e);
 8244a60:	e0bff417 	ldw	r2,-48(fp)
 8244a64:	00006106 	br	8244bec <udpdemux+0x794>
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
         continue;
 8244a68:	0001883a 	nop
 8244a6c:	00000506 	br	8244a84 <udpdemux+0x62c>
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
         continue;
 8244a70:	0001883a 	nop
 8244a74:	00000306 	br	8244a84 <udpdemux+0x62c>
      if (con->u_fhost && (con->u_fhost != p->fhost))
         continue;
 8244a78:	0001883a 	nop
 8244a7c:	00000106 	br	8244a84 <udpdemux+0x62c>
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
            continue;
 8244a80:	0001883a 	nop
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244a84:	e0bff217 	ldw	r2,-56(fp)
 8244a88:	10800017 	ldw	r2,0(r2)
 8244a8c:	e0bff215 	stw	r2,-56(fp)
 8244a90:	e0bff217 	ldw	r2,-56(fp)
 8244a94:	103f501e 	bne	r2,zero,82447d8 <udpdemux+0x380>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244a98:	e0bff617 	ldw	r2,-40(fp)
 8244a9c:	10800417 	ldw	r2,16(r2)
 8244aa0:	10bfffe0 	cmpeqi	r2,r2,-1
 8244aa4:	1000121e 	bne	r2,zero,8244af0 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244aa8:	e0bff617 	ldw	r2,-40(fp)
 8244aac:	10c00417 	ldw	r3,16(r2)
 8244ab0:	e0bfff17 	ldw	r2,-4(fp)
 8244ab4:	10800617 	ldw	r2,24(r2)
 8244ab8:	10800e17 	ldw	r2,56(r2)

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244abc:	18800c26 	beq	r3,r2,8244af0 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244ac0:	e0bff617 	ldw	r2,-40(fp)
 8244ac4:	10c00417 	ldw	r3,16(r2)
 8244ac8:	e0bfff17 	ldw	r2,-4(fp)
 8244acc:	10800617 	ldw	r2,24(r2)
 8244ad0:	10800f17 	ldw	r2,60(r2)
   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244ad4:	18800626 	beq	r3,r2,8244af0 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
 8244ad8:	e0bff617 	ldw	r2,-40(fp)
 8244adc:	10c00417 	ldw	r3,16(r2)
 8244ae0:	e0bfff17 	ldw	r2,-4(fp)
 8244ae4:	10800617 	ldw	r2,24(r2)
 8244ae8:	10801017 	ldw	r2,64(r2)
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244aec:	1880141e 	bne	r3,r2,8244b40 <udpdemux+0x6e8>
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244af0:	d0a08317 	ldw	r2,-32244(gp)
 8244af4:	1081000c 	andi	r2,r2,1024
 8244af8:	10000626 	beq	r2,zero,8244b14 <udpdemux+0x6bc>
 8244afc:	d0a08317 	ldw	r2,-32244(gp)
 8244b00:	1080400c 	andi	r2,r2,256
 8244b04:	10000326 	beq	r2,zero,8244b14 <udpdemux+0x6bc>
         dprintf("UDP: ignoring ip broadcast\n");
 8244b08:	01020974 	movhi	r4,2085
 8244b0c:	21044f04 	addi	r4,r4,4412
 8244b10:	82031200 	call	8203120 <puts>
#endif
      udp_mib.udpInErrors++;
 8244b14:	008209b4 	movhi	r2,2086
 8244b18:	10b91204 	addi	r2,r2,-7096
 8244b1c:	10800217 	ldw	r2,8(r2)
 8244b20:	10c00044 	addi	r3,r2,1
 8244b24:	008209b4 	movhi	r2,2086
 8244b28:	10b91204 	addi	r2,r2,-7096
 8244b2c:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244b30:	e13fff17 	ldw	r4,-4(fp)
 8244b34:	824511c0 	call	824511c <udp_free>
      return ENP_NOT_MINE;
 8244b38:	00800084 	movi	r2,2
 8244b3c:	00002b06 	br	8244bec <udpdemux+0x794>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244b40:	d0a08317 	ldw	r2,-32244(gp)
 8244b44:	1081000c 	andi	r2,r2,1024
 8244b48:	10000f26 	beq	r2,zero,8244b88 <udpdemux+0x730>
 8244b4c:	d0a08317 	ldw	r2,-32244(gp)
 8244b50:	1080400c 	andi	r2,r2,256
 8244b54:	10000c26 	beq	r2,zero,8244b88 <udpdemux+0x730>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 8244b58:	e0bff717 	ldw	r2,-36(fp)
 8244b5c:	1080008b 	ldhu	r2,2(r2)
 8244b60:	10bfffcc 	andi	r2,r2,65535
 8244b64:	100b883a 	mov	r5,r2
 8244b68:	01020974 	movhi	r4,2085
 8244b6c:	21045604 	addi	r4,r4,4440
 8244b70:	8202e9c0 	call	8202e9c <printf>
      if (NDEBUG & DUMP) 
 8244b74:	d0a08317 	ldw	r2,-32244(gp)
 8244b78:	1080008c 	andi	r2,r2,2
 8244b7c:	10000226 	beq	r2,zero,8244b88 <udpdemux+0x730>
         ip_dump(p);
 8244b80:	e13fff17 	ldw	r4,-4(fp)
 8244b84:	82406940 	call	8240694 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244b88:	e13ff717 	ldw	r4,-36(fp)
 8244b8c:	8244e980 	call	8244e98 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 8244b90:	e0bfff17 	ldw	r2,-4(fp)
 8244b94:	10c00717 	ldw	r3,28(r2)
 8244b98:	e0bfff17 	ldw	r2,-4(fp)
 8244b9c:	10800617 	ldw	r2,24(r2)
 8244ba0:	11000a17 	ldw	r4,40(r2)
 8244ba4:	e0bfff17 	ldw	r2,-4(fp)
 8244ba8:	10800617 	ldw	r2,24(r2)
 8244bac:	d8800015 	stw	r2,0(sp)
 8244bb0:	01c000c4 	movi	r7,3
 8244bb4:	e1bff617 	ldw	r6,-40(fp)
 8244bb8:	200b883a 	mov	r5,r4
 8244bbc:	1809883a 	mov	r4,r3
 8244bc0:	824aac00 	call	824aac0 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 8244bc4:	008209b4 	movhi	r2,2086
 8244bc8:	10b91204 	addi	r2,r2,-7096
 8244bcc:	10800117 	ldw	r2,4(r2)
 8244bd0:	10c00044 	addi	r3,r2,1
 8244bd4:	008209b4 	movhi	r2,2086
 8244bd8:	10b91204 	addi	r2,r2,-7096
 8244bdc:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 8244be0:	e13fff17 	ldw	r4,-4(fp)
 8244be4:	824511c0 	call	824511c <udp_free>
   return ENP_NOT_MINE;
 8244be8:	00800084 	movi	r2,2
}
 8244bec:	e037883a 	mov	sp,fp
 8244bf0:	dfc00117 	ldw	ra,4(sp)
 8244bf4:	df000017 	ldw	fp,0(sp)
 8244bf8:	dec00204 	addi	sp,sp,8
 8244bfc:	f800283a 	ret

08244c00 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 8244c00:	deffef04 	addi	sp,sp,-68
 8244c04:	dfc01015 	stw	ra,64(sp)
 8244c08:	df000f15 	stw	fp,60(sp)
 8244c0c:	df000f04 	addi	fp,sp,60
 8244c10:	2007883a 	mov	r3,r4
 8244c14:	2805883a 	mov	r2,r5
 8244c18:	e1bfff15 	stw	r6,-4(fp)
 8244c1c:	e0fffd0d 	sth	r3,-12(fp)
 8244c20:	e0bffe0d 	sth	r2,-8(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 8244c24:	d0a08317 	ldw	r2,-32244(gp)
 8244c28:	1080410c 	andi	r2,r2,260
 8244c2c:	10001a26 	beq	r2,zero,8244c98 <udp_send+0x98>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244c30:	e0bfff17 	ldw	r2,-4(fp)
 8244c34:	12000417 	ldw	r8,16(r2)
 8244c38:	e1bffe0b 	ldhu	r6,-8(fp)
    PUSH_IPADDR(p->fhost), fport);
 8244c3c:	e0bfff17 	ldw	r2,-4(fp)
 8244c40:	10800717 	ldw	r2,28(r2)
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244c44:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244c48:	e0bfff17 	ldw	r2,-4(fp)
 8244c4c:	10800717 	ldw	r2,28(r2)
 8244c50:	1004d23a 	srli	r2,r2,8
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244c54:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244c58:	e0ffff17 	ldw	r3,-4(fp)
 8244c5c:	18c00717 	ldw	r3,28(r3)
 8244c60:	1806d43a 	srli	r3,r3,16
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244c64:	18c03fcc 	andi	r3,r3,255
    PUSH_IPADDR(p->fhost), fport);
 8244c68:	e13fff17 	ldw	r4,-4(fp)
 8244c6c:	21000717 	ldw	r4,28(r4)
 8244c70:	2008d63a 	srli	r4,r4,24
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244c74:	e17ffd0b 	ldhu	r5,-12(fp)
 8244c78:	d9400315 	stw	r5,12(sp)
 8244c7c:	d9000215 	stw	r4,8(sp)
 8244c80:	d8c00115 	stw	r3,4(sp)
 8244c84:	d8800015 	stw	r2,0(sp)
 8244c88:	400b883a 	mov	r5,r8
 8244c8c:	01020974 	movhi	r4,2085
 8244c90:	21045d04 	addi	r4,r4,4468
 8244c94:	8202e9c0 	call	8202e9c <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 8244c98:	0009883a 	mov	r4,zero
 8244c9c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 8244ca0:	e0bfff17 	ldw	r2,-4(fp)
 8244ca4:	10800317 	ldw	r2,12(r2)
 8244ca8:	10fffe04 	addi	r3,r2,-8
 8244cac:	e0bfff17 	ldw	r2,-4(fp)
 8244cb0:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 8244cb4:	e0bfff17 	ldw	r2,-4(fp)
 8244cb8:	10800317 	ldw	r2,12(r2)
 8244cbc:	e0bff615 	stw	r2,-40(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 8244cc0:	e0bfff17 	ldw	r2,-4(fp)
 8244cc4:	10800417 	ldw	r2,16(r2)
 8244cc8:	10800204 	addi	r2,r2,8
 8244ccc:	e0bff715 	stw	r2,-36(fp)
   p->nb_plen = udplen;
 8244cd0:	e0fff717 	ldw	r3,-36(fp)
 8244cd4:	e0bfff17 	ldw	r2,-4(fp)
 8244cd8:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 8244cdc:	e0bff717 	ldw	r2,-36(fp)
 8244ce0:	1080004c 	andi	r2,r2,1
 8244ce4:	10000426 	beq	r2,zero,8244cf8 <udp_send+0xf8>
 8244ce8:	e0bff717 	ldw	r2,-36(fp)
 8244cec:	e0fff617 	ldw	r3,-40(fp)
 8244cf0:	1885883a 	add	r2,r3,r2
 8244cf4:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 8244cf8:	e0bff717 	ldw	r2,-36(fp)
 8244cfc:	1007883a 	mov	r3,r2
 8244d00:	e0bff617 	ldw	r2,-40(fp)
 8244d04:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 8244d08:	e0bff617 	ldw	r2,-40(fp)
 8244d0c:	e0fffe0b 	ldhu	r3,-8(fp)
 8244d10:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = fport;
 8244d14:	e0bff617 	ldw	r2,-40(fp)
 8244d18:	e0fffd0b 	ldhu	r3,-12(fp)
 8244d1c:	10c0008d 	sth	r3,2(r2)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244d20:	e13ff617 	ldw	r4,-40(fp)
 8244d24:	8244e980 	call	8244e98 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 8244d28:	e0bfff17 	ldw	r2,-4(fp)
 8244d2c:	10800717 	ldw	r2,28(r2)
 8244d30:	10bfffd8 	cmpnei	r2,r2,-1
 8244d34:	10000f1e 	bne	r2,zero,8244d74 <udp_send+0x174>
   {
      if (!p->net)
 8244d38:	e0bfff17 	ldw	r2,-4(fp)
 8244d3c:	10800617 	ldw	r2,24(r2)
 8244d40:	1000071e 	bne	r2,zero,8244d60 <udp_send+0x160>
      {
         dtrap();    /* programmer forgot to select iface */
 8244d44:	822d1c80 	call	822d1c8 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 8244d48:	e13fff17 	ldw	r4,-4(fp)
 8244d4c:	824511c0 	call	824511c <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244d50:	0009883a 	mov	r4,zero
 8244d54:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 8244d58:	00bff784 	movi	r2,-34
 8244d5c:	00004906 	br	8244e84 <udp_send+0x284>
      }
      src_ip = p->net->n_ipaddr;
 8244d60:	e0bfff17 	ldw	r2,-4(fp)
 8244d64:	10800617 	ldw	r2,24(r2)
 8244d68:	10800a17 	ldw	r2,40(r2)
 8244d6c:	e0bff515 	stw	r2,-44(fp)
 8244d70:	00000506 	br	8244d88 <udp_send+0x188>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 8244d74:	e0bfff17 	ldw	r2,-4(fp)
 8244d78:	10800717 	ldw	r2,28(r2)
 8244d7c:	1009883a 	mov	r4,r2
 8244d80:	82405f00 	call	82405f0 <ip_mymach>
 8244d84:	e0bff515 	stw	r2,-44(fp)
   php.ph_src = src_ip;
 8244d88:	e0bff517 	ldw	r2,-44(fp)
 8244d8c:	e0bffa15 	stw	r2,-24(fp)
   php.ph_dest = p->fhost;
 8244d90:	e0bfff17 	ldw	r2,-4(fp)
 8244d94:	10800717 	ldw	r2,28(r2)
 8244d98:	e0bffb15 	stw	r2,-20(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 8244d9c:	e03ffc05 	stb	zero,-16(fp)
   php.ph_prot = UDP_PROT;
 8244da0:	00800444 	movi	r2,17
 8244da4:	e0bffc45 	stb	r2,-15(fp)
   php.ph_len = pup->ud_len;
 8244da8:	e0bff617 	ldw	r2,-40(fp)
 8244dac:	1080010b 	ldhu	r2,4(r2)
 8244db0:	e0bffc8d 	sth	r2,-14(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 8244db4:	e0bffa04 	addi	r2,fp,-24
 8244db8:	01400184 	movi	r5,6
 8244dbc:	1009883a 	mov	r4,r2
 8244dc0:	82283e80 	call	82283e8 <cksum>
 8244dc4:	1007883a 	mov	r3,r2
 8244dc8:	e0bff617 	ldw	r2,-40(fp)
 8244dcc:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 8244dd0:	e0bff717 	ldw	r2,-36(fp)
 8244dd4:	10800044 	addi	r2,r2,1
 8244dd8:	1005d07a 	srai	r2,r2,1
 8244ddc:	100b883a 	mov	r5,r2
 8244de0:	e13ff617 	ldw	r4,-40(fp)
 8244de4:	82283e80 	call	82283e8 <cksum>
 8244de8:	0084303a 	nor	r2,zero,r2
 8244dec:	1007883a 	mov	r3,r2
 8244df0:	e0bff617 	ldw	r2,-40(fp)
 8244df4:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 8244df8:	e0bff617 	ldw	r2,-40(fp)
 8244dfc:	1080018b 	ldhu	r2,6(r2)
 8244e00:	10bfffcc 	andi	r2,r2,65535
 8244e04:	1000031e 	bne	r2,zero,8244e14 <udp_send+0x214>
      pup->ud_cksum = 0xffff;
 8244e08:	e0bff617 	ldw	r2,-40(fp)
 8244e0c:	00ffffc4 	movi	r3,-1
 8244e10:	10c0018d 	sth	r3,6(r2)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 8244e14:	e0bfff17 	ldw	r2,-4(fp)
 8244e18:	10800317 	ldw	r2,12(r2)
 8244e1c:	10bffb04 	addi	r2,r2,-20
 8244e20:	e0bff815 	stw	r2,-32(fp)
   pip->ip_src = src_ip;
 8244e24:	e0bff817 	ldw	r2,-32(fp)
 8244e28:	e0fff517 	ldw	r3,-44(fp)
 8244e2c:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = p->fhost;
 8244e30:	e0bfff17 	ldw	r2,-4(fp)
 8244e34:	10c00717 	ldw	r3,28(r2)
 8244e38:	e0bff817 	ldw	r2,-32(fp)
 8244e3c:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 8244e40:	008209b4 	movhi	r2,2086
 8244e44:	10b91204 	addi	r2,r2,-7096
 8244e48:	10800317 	ldw	r2,12(r2)
 8244e4c:	10c00044 	addi	r3,r2,1
 8244e50:	008209b4 	movhi	r2,2086
 8244e54:	10b91204 	addi	r2,r2,-7096
 8244e58:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 8244e5c:	e0fff717 	ldw	r3,-36(fp)
 8244e60:	e0bfff17 	ldw	r2,-4(fp)
 8244e64:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 8244e68:	e17fff17 	ldw	r5,-4(fp)
 8244e6c:	01000444 	movi	r4,17
 8244e70:	823f5a00 	call	823f5a0 <ip_write>
 8244e74:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8244e78:	0009883a 	mov	r4,zero
 8244e7c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   return e;
 8244e80:	e0bff917 	ldw	r2,-28(fp)
}
 8244e84:	e037883a 	mov	sp,fp
 8244e88:	dfc00117 	ldw	ra,4(sp)
 8244e8c:	df000017 	ldw	fp,0(sp)
 8244e90:	dec00204 	addi	sp,sp,8
 8244e94:	f800283a 	ret

08244e98 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 8244e98:	defffe04 	addi	sp,sp,-8
 8244e9c:	df000115 	stw	fp,4(sp)
 8244ea0:	df000104 	addi	fp,sp,4
 8244ea4:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 8244ea8:	e0bfff17 	ldw	r2,-4(fp)
 8244eac:	1080000b 	ldhu	r2,0(r2)
 8244eb0:	10bfffcc 	andi	r2,r2,65535
 8244eb4:	1004d23a 	srli	r2,r2,8
 8244eb8:	1007883a 	mov	r3,r2
 8244ebc:	e0bfff17 	ldw	r2,-4(fp)
 8244ec0:	1080000b 	ldhu	r2,0(r2)
 8244ec4:	10bfffcc 	andi	r2,r2,65535
 8244ec8:	1004923a 	slli	r2,r2,8
 8244ecc:	1884b03a 	or	r2,r3,r2
 8244ed0:	1007883a 	mov	r3,r2
 8244ed4:	e0bfff17 	ldw	r2,-4(fp)
 8244ed8:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 8244edc:	e0bfff17 	ldw	r2,-4(fp)
 8244ee0:	1080008b 	ldhu	r2,2(r2)
 8244ee4:	10bfffcc 	andi	r2,r2,65535
 8244ee8:	1004d23a 	srli	r2,r2,8
 8244eec:	1007883a 	mov	r3,r2
 8244ef0:	e0bfff17 	ldw	r2,-4(fp)
 8244ef4:	1080008b 	ldhu	r2,2(r2)
 8244ef8:	10bfffcc 	andi	r2,r2,65535
 8244efc:	1004923a 	slli	r2,r2,8
 8244f00:	1884b03a 	or	r2,r3,r2
 8244f04:	1007883a 	mov	r3,r2
 8244f08:	e0bfff17 	ldw	r2,-4(fp)
 8244f0c:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 8244f10:	e0bfff17 	ldw	r2,-4(fp)
 8244f14:	1080010b 	ldhu	r2,4(r2)
 8244f18:	10bfffcc 	andi	r2,r2,65535
 8244f1c:	1004d23a 	srli	r2,r2,8
 8244f20:	1007883a 	mov	r3,r2
 8244f24:	e0bfff17 	ldw	r2,-4(fp)
 8244f28:	1080010b 	ldhu	r2,4(r2)
 8244f2c:	10bfffcc 	andi	r2,r2,65535
 8244f30:	1004923a 	slli	r2,r2,8
 8244f34:	1884b03a 	or	r2,r3,r2
 8244f38:	1007883a 	mov	r3,r2
 8244f3c:	e0bfff17 	ldw	r2,-4(fp)
 8244f40:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 8244f44:	e0bfff17 	ldw	r2,-4(fp)
 8244f48:	1080018b 	ldhu	r2,6(r2)
 8244f4c:	10bfffcc 	andi	r2,r2,65535
 8244f50:	1004d23a 	srli	r2,r2,8
 8244f54:	1007883a 	mov	r3,r2
 8244f58:	e0bfff17 	ldw	r2,-4(fp)
 8244f5c:	1080018b 	ldhu	r2,6(r2)
 8244f60:	10bfffcc 	andi	r2,r2,65535
 8244f64:	1004923a 	slli	r2,r2,8
 8244f68:	1884b03a 	or	r2,r3,r2
 8244f6c:	1007883a 	mov	r3,r2
 8244f70:	e0bfff17 	ldw	r2,-4(fp)
 8244f74:	10c0018d 	sth	r3,6(r2)
}
 8244f78:	0001883a 	nop
 8244f7c:	e037883a 	mov	sp,fp
 8244f80:	df000017 	ldw	fp,0(sp)
 8244f84:	dec00104 	addi	sp,sp,4
 8244f88:	f800283a 	ret

08244f8c <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 8244f8c:	defffe04 	addi	sp,sp,-8
 8244f90:	df000115 	stw	fp,4(sp)
 8244f94:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 8244f98:	d0a0d10b 	ldhu	r2,-31932(gp)
 8244f9c:	10bfffcc 	andi	r2,r2,65535
 8244fa0:	10812c28 	cmpgeui	r2,r2,1200
 8244fa4:	10000a1e 	bne	r2,zero,8244fd0 <udp_socket+0x44>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 8244fa8:	d0a0a817 	ldw	r2,-32096(gp)
 8244fac:	109fffcc 	andi	r2,r2,32767
 8244fb0:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 8244fb4:	d0a0d10b 	ldhu	r2,-31932(gp)
 8244fb8:	10bfffcc 	andi	r2,r2,65535
 8244fbc:	10812c28 	cmpgeui	r2,r2,1200
 8244fc0:	1000031e 	bne	r2,zero,8244fd0 <udp_socket+0x44>
         usocket += MINSOCKET;
 8244fc4:	d0a0d10b 	ldhu	r2,-31932(gp)
 8244fc8:	10812c04 	addi	r2,r2,1200
 8244fcc:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 8244fd0:	d0a09c17 	ldw	r2,-32144(gp)
 8244fd4:	e0bfff15 	stw	r2,-4(fp)
 8244fd8:	00000f06 	br	8245018 <udp_socket+0x8c>
   {
      if (tmp->u_lport == usocket)
 8244fdc:	e0bfff17 	ldw	r2,-4(fp)
 8244fe0:	10c0018b 	ldhu	r3,6(r2)
 8244fe4:	d0a0d10b 	ldhu	r2,-31932(gp)
 8244fe8:	18ffffcc 	andi	r3,r3,65535
 8244fec:	10bfffcc 	andi	r2,r2,65535
 8244ff0:	1880061e 	bne	r3,r2,824500c <udp_socket+0x80>
      {
         usocket++;     /* bump socket number */
 8244ff4:	d0a0d10b 	ldhu	r2,-31932(gp)
 8244ff8:	10800044 	addi	r2,r2,1
 8244ffc:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 8245000:	d0a09c17 	ldw	r2,-32144(gp)
 8245004:	e0bfff15 	stw	r2,-4(fp)
         continue;
 8245008:	0001883a 	nop
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 824500c:	e0bfff17 	ldw	r2,-4(fp)
 8245010:	10800017 	ldw	r2,0(r2)
 8245014:	e0bfff15 	stw	r2,-4(fp)
 8245018:	e0bfff17 	ldw	r2,-4(fp)
 824501c:	103fef1e 	bne	r2,zero,8244fdc <udp_socket+0x50>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 8245020:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245024:	10c00044 	addi	r3,r2,1
 8245028:	d0e0d10d 	sth	r3,-31932(gp)
}
 824502c:	e037883a 	mov	sp,fp
 8245030:	df000017 	ldw	fp,0(sp)
 8245034:	dec00104 	addi	sp,sp,4
 8245038:	f800283a 	ret

0824503c <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 824503c:	defffa04 	addi	sp,sp,-24
 8245040:	dfc00515 	stw	ra,20(sp)
 8245044:	df000415 	stw	fp,16(sp)
 8245048:	df000404 	addi	fp,sp,16
 824504c:	e13ffe15 	stw	r4,-8(fp)
 8245050:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 8245054:	e0bffe17 	ldw	r2,-8(fp)
 8245058:	10800244 	addi	r2,r2,9
 824505c:	1007883a 	mov	r3,r2
 8245060:	00bfff84 	movi	r2,-2
 8245064:	1884703a 	and	r2,r3,r2
 8245068:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824506c:	01000084 	movi	r4,2
 8245070:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 8245074:	e0bffc17 	ldw	r2,-16(fp)
 8245078:	10c00904 	addi	r3,r2,36
 824507c:	e0bfff17 	ldw	r2,-4(fp)
 8245080:	1885883a 	add	r2,r3,r2
 8245084:	1009883a 	mov	r4,r2
 8245088:	822c6200 	call	822c620 <pk_alloc>
 824508c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245090:	01000084 	movi	r4,2
 8245094:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 8245098:	e0bffd17 	ldw	r2,-12(fp)
 824509c:	10001026 	beq	r2,zero,82450e0 <udp_alloc+0xa4>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 82450a0:	e0bfff17 	ldw	r2,-4(fp)
 82450a4:	1005d0ba 	srai	r2,r2,2
 82450a8:	10800704 	addi	r2,r2,28
 82450ac:	e0bffc15 	stw	r2,-16(fp)
      p->nb_prot += len;
 82450b0:	e0bffd17 	ldw	r2,-12(fp)
 82450b4:	10c00317 	ldw	r3,12(r2)
 82450b8:	e0bffc17 	ldw	r2,-16(fp)
 82450bc:	1887883a 	add	r3,r3,r2
 82450c0:	e0bffd17 	ldw	r2,-12(fp)
 82450c4:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 82450c8:	e0bffd17 	ldw	r2,-12(fp)
 82450cc:	10c00417 	ldw	r3,16(r2)
 82450d0:	e0bffc17 	ldw	r2,-16(fp)
 82450d4:	1887c83a 	sub	r3,r3,r2
 82450d8:	e0bffd17 	ldw	r2,-12(fp)
 82450dc:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 82450e0:	e0bffd17 	ldw	r2,-12(fp)
}
 82450e4:	e037883a 	mov	sp,fp
 82450e8:	dfc00117 	ldw	ra,4(sp)
 82450ec:	df000017 	ldw	fp,0(sp)
 82450f0:	dec00204 	addi	sp,sp,8
 82450f4:	f800283a 	ret

082450f8 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 82450f8:	deffff04 	addi	sp,sp,-4
 82450fc:	df000015 	stw	fp,0(sp)
 8245100:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 8245104:	d0a03917 	ldw	r2,-32540(gp)
 8245108:	10bff704 	addi	r2,r2,-36
#endif
}
 824510c:	e037883a 	mov	sp,fp
 8245110:	df000017 	ldw	fp,0(sp)
 8245114:	dec00104 	addi	sp,sp,4
 8245118:	f800283a 	ret

0824511c <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 824511c:	defffd04 	addi	sp,sp,-12
 8245120:	dfc00215 	stw	ra,8(sp)
 8245124:	df000115 	stw	fp,4(sp)
 8245128:	df000104 	addi	fp,sp,4
 824512c:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245130:	01000084 	movi	r4,2
 8245134:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 8245138:	e13fff17 	ldw	r4,-4(fp)
 824513c:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245140:	01000084 	movi	r4,2
 8245144:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
}
 8245148:	0001883a 	nop
 824514c:	e037883a 	mov	sp,fp
 8245150:	dfc00117 	ldw	ra,4(sp)
 8245154:	df000017 	ldw	fp,0(sp)
 8245158:	dec00204 	addi	sp,sp,8
 824515c:	f800283a 	ret

08245160 <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 8245160:	defff804 	addi	sp,sp,-32
 8245164:	dfc00715 	stw	ra,28(sp)
 8245168:	df000615 	stw	fp,24(sp)
 824516c:	df000604 	addi	fp,sp,24
 8245170:	e13fff15 	stw	r4,-4(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 8245174:	e0bfff17 	ldw	r2,-4(fp)
 8245178:	10800617 	ldw	r2,24(r2)
 824517c:	e0bffc15 	stw	r2,-16(fp)
   int rc;
         
   pip = ip_head (p);
 8245180:	e0bfff17 	ldw	r2,-4(fp)
 8245184:	10800317 	ldw	r2,12(r2)
 8245188:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 824518c:	e0bffd17 	ldw	r2,-12(fp)
 8245190:	10800003 	ldbu	r2,0(r2)
 8245194:	10803fcc 	andi	r2,r2,255
 8245198:	108003cc 	andi	r2,r2,15
 824519c:	1085883a 	add	r2,r2,r2
 82451a0:	1085883a 	add	r2,r2,r2
 82451a4:	1007883a 	mov	r3,r2
 82451a8:	e0bffd17 	ldw	r2,-12(fp)
 82451ac:	10c5883a 	add	r2,r2,r3
 82451b0:	e0bffe15 	stw	r2,-8(fp)

   switch (igmp->igmp_type) 
 82451b4:	e0bffe17 	ldw	r2,-8(fp)
 82451b8:	10800003 	ldbu	r2,0(r2)
 82451bc:	10803fcc 	andi	r2,r2,255
 82451c0:	10c00460 	cmpeqi	r3,r2,17
 82451c4:	1800031e 	bne	r3,zero,82451d4 <igmpv1_input+0x74>
 82451c8:	108004a0 	cmpeqi	r2,r2,18
 82451cc:	1000571e 	bne	r2,zero,824532c <igmpv1_input+0x1cc>
 82451d0:	00007606 	br	82453ac <igmpv1_input+0x24c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 82451d4:	008209b4 	movhi	r2,2086
 82451d8:	10b6b604 	addi	r2,r2,-9512
 82451dc:	10800117 	ldw	r2,4(r2)
 82451e0:	10c00044 	addi	r3,r2,1
 82451e4:	008209b4 	movhi	r2,2086
 82451e8:	10b6b604 	addi	r2,r2,-9512
 82451ec:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82451f0:	e0bffc17 	ldw	r2,-16(fp)
 82451f4:	10802c17 	ldw	r2,176(r2)
 82451f8:	e0bffa15 	stw	r2,-24(fp)
 82451fc:	00004706 	br	824531c <igmpv1_input+0x1bc>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 8245200:	e0bffa17 	ldw	r2,-24(fp)
 8245204:	10800017 	ldw	r2,0(r2)
 8245208:	10004026 	beq	r2,zero,824530c <igmpv1_input+0x1ac>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 824520c:	e0bffa17 	ldw	r2,-24(fp)
 8245210:	10c00017 	ldw	r3,0(r2)
 8245214:	d0a08817 	ldw	r2,-32224(gp)
 8245218:	18803d26 	beq	r3,r2,8245310 <igmpv1_input+0x1b0>
         {
            if (inm->inm_timer == 0)
 824521c:	e0bffa17 	ldw	r2,-24(fp)
 8245220:	10800317 	ldw	r2,12(r2)
 8245224:	10003a1e 	bne	r2,zero,8245310 <igmpv1_input+0x1b0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8245228:	008209b4 	movhi	r2,2086
 824522c:	10b8f804 	addi	r2,r2,-7200
 8245230:	10c00217 	ldw	r3,8(r2)
 8245234:	008209b4 	movhi	r2,2086
 8245238:	10b6b204 	addi	r2,r2,-9528
 824523c:	10800017 	ldw	r2,0(r2)
 8245240:	10800a17 	ldw	r2,40(r2)
 8245244:	1008d63a 	srli	r4,r2,24
 8245248:	008209b4 	movhi	r2,2086
 824524c:	10b6b204 	addi	r2,r2,-9528
 8245250:	10800017 	ldw	r2,0(r2)
 8245254:	10800a17 	ldw	r2,40(r2)
 8245258:	1004d23a 	srli	r2,r2,8
 824525c:	10bfc00c 	andi	r2,r2,65280
 8245260:	2088b03a 	or	r4,r4,r2
 8245264:	008209b4 	movhi	r2,2086
 8245268:	10b6b204 	addi	r2,r2,-9528
 824526c:	10800017 	ldw	r2,0(r2)
 8245270:	10800a17 	ldw	r2,40(r2)
 8245274:	10bfc00c 	andi	r2,r2,65280
 8245278:	1004923a 	slli	r2,r2,8
 824527c:	2088b03a 	or	r4,r4,r2
 8245280:	008209b4 	movhi	r2,2086
 8245284:	10b6b204 	addi	r2,r2,-9528
 8245288:	10800017 	ldw	r2,0(r2)
 824528c:	10800a17 	ldw	r2,40(r2)
 8245290:	1004963a 	slli	r2,r2,24
 8245294:	2084b03a 	or	r2,r4,r2
 8245298:	1887883a 	add	r3,r3,r2
 824529c:	e0bffa17 	ldw	r2,-24(fp)
 82452a0:	10800017 	ldw	r2,0(r2)
 82452a4:	1008d63a 	srli	r4,r2,24
 82452a8:	e0bffa17 	ldw	r2,-24(fp)
 82452ac:	10800017 	ldw	r2,0(r2)
 82452b0:	1004d23a 	srli	r2,r2,8
 82452b4:	10bfc00c 	andi	r2,r2,65280
 82452b8:	2088b03a 	or	r4,r4,r2
 82452bc:	e0bffa17 	ldw	r2,-24(fp)
 82452c0:	10800017 	ldw	r2,0(r2)
 82452c4:	10bfc00c 	andi	r2,r2,65280
 82452c8:	1004923a 	slli	r2,r2,8
 82452cc:	2088b03a 	or	r4,r4,r2
 82452d0:	e0bffa17 	ldw	r2,-24(fp)
 82452d4:	10800017 	ldw	r2,0(r2)
 82452d8:	1004963a 	slli	r2,r2,24
 82452dc:	2084b03a 	or	r2,r4,r2
 82452e0:	1885883a 	add	r2,r3,r2
 82452e4:	01400c84 	movi	r5,50
 82452e8:	1009883a 	mov	r4,r2
 82452ec:	82027700 	call	8202770 <__umodsi3>
 82452f0:	10c00044 	addi	r3,r2,1
 82452f4:	e0bffa17 	ldw	r2,-24(fp)
 82452f8:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 82452fc:	d0a08617 	ldw	r2,-32232(gp)
 8245300:	10800044 	addi	r2,r2,1
 8245304:	d0a08615 	stw	r2,-32232(gp)
 8245308:	00000106 	br	8245310 <igmpv1_input+0x1b0>
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
            continue;
 824530c:	0001883a 	nop
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245310:	e0bffa17 	ldw	r2,-24(fp)
 8245314:	10800517 	ldw	r2,20(r2)
 8245318:	e0bffa15 	stw	r2,-24(fp)
 824531c:	e0bffa17 	ldw	r2,-24(fp)
 8245320:	103fb71e 	bne	r2,zero,8245200 <igmpv1_input+0xa0>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 8245324:	e03ffb15 	stw	zero,-20(fp)
      break;
 8245328:	00002a06 	br	82453d4 <igmpv1_input+0x274>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 824532c:	008209b4 	movhi	r2,2086
 8245330:	10b6b604 	addi	r2,r2,-9512
 8245334:	10800217 	ldw	r2,8(r2)
 8245338:	10c00044 	addi	r3,r2,1
 824533c:	008209b4 	movhi	r2,2086
 8245340:	10b6b604 	addi	r2,r2,-9512
 8245344:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 8245348:	e0bffe17 	ldw	r2,-8(fp)
 824534c:	10800117 	ldw	r2,4(r2)
 8245350:	e17ffc17 	ldw	r5,-16(fp)
 8245354:	1009883a 	mov	r4,r2
 8245358:	82437fc0 	call	82437fc <lookup_mcast>
 824535c:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL) 
 8245360:	e0bffa17 	ldw	r2,-24(fp)
 8245364:	10000f26 	beq	r2,zero,82453a4 <igmpv1_input+0x244>
      {
         if (inm->inm_timer > 0)
 8245368:	e0bffa17 	ldw	r2,-24(fp)
 824536c:	10800317 	ldw	r2,12(r2)
 8245370:	10000c26 	beq	r2,zero,82453a4 <igmpv1_input+0x244>
         {
            inm->inm_timer = 0;
 8245374:	e0bffa17 	ldw	r2,-24(fp)
 8245378:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 824537c:	d0a08617 	ldw	r2,-32232(gp)
 8245380:	10bfffc4 	addi	r2,r2,-1
 8245384:	d0a08615 	stw	r2,-32232(gp)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 8245388:	008209b4 	movhi	r2,2086
 824538c:	10b6b604 	addi	r2,r2,-9512
 8245390:	10800317 	ldw	r2,12(r2)
 8245394:	10c00044 	addi	r3,r2,1
 8245398:	008209b4 	movhi	r2,2086
 824539c:	10b6b604 	addi	r2,r2,-9512
 82453a0:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 82453a4:	e03ffb15 	stw	zero,-20(fp)
      break;
 82453a8:	00000a06 	br	82453d4 <igmpv1_input+0x274>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 82453ac:	008209b4 	movhi	r2,2086
 82453b0:	10b6b604 	addi	r2,r2,-9512
 82453b4:	10801017 	ldw	r2,64(r2)
 82453b8:	10c00044 	addi	r3,r2,1
 82453bc:	008209b4 	movhi	r2,2086
 82453c0:	10b6b604 	addi	r2,r2,-9512
 82453c4:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 82453c8:	00bfffc4 	movi	r2,-1
 82453cc:	e0bffb15 	stw	r2,-20(fp)
      break;   
 82453d0:	0001883a 	nop
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82453d4:	01000084 	movi	r4,2
 82453d8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 82453dc:	e13fff17 	ldw	r4,-4(fp)
 82453e0:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82453e4:	01000084 	movi	r4,2
 82453e8:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      
   return rc;
 82453ec:	e0bffb17 	ldw	r2,-20(fp)
}
 82453f0:	e037883a 	mov	sp,fp
 82453f4:	dfc00117 	ldw	ra,4(sp)
 82453f8:	df000017 	ldw	fp,0(sp)
 82453fc:	dec00204 	addi	sp,sp,8
 8245400:	f800283a 	ret

08245404 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 8245404:	defff904 	addi	sp,sp,-28
 8245408:	dfc00615 	stw	ra,24(sp)
 824540c:	df000515 	stw	fp,20(sp)
 8245410:	df000504 	addi	fp,sp,20
 8245414:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   u_char type;
   int rc;

   pip = ip_head (p);    
 8245418:	e0bfff17 	ldw	r2,-4(fp)
 824541c:	10800317 	ldw	r2,12(r2)
 8245420:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 8245424:	e0bffc17 	ldw	r2,-16(fp)
 8245428:	10800003 	ldbu	r2,0(r2)
 824542c:	10803fcc 	andi	r2,r2,255
 8245430:	108003cc 	andi	r2,r2,15
 8245434:	1085883a 	add	r2,r2,r2
 8245438:	1085883a 	add	r2,r2,r2
 824543c:	1007883a 	mov	r3,r2
 8245440:	e0bffc17 	ldw	r2,-16(fp)
 8245444:	10c5883a 	add	r2,r2,r3
 8245448:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 824544c:	e0bffd17 	ldw	r2,-12(fp)
 8245450:	10800003 	ldbu	r2,0(r2)
 8245454:	e0bffe05 	stb	r2,-8(fp)

   switch (type) 
 8245458:	e0bffe03 	ldbu	r2,-8(fp)
 824545c:	10c004a0 	cmpeqi	r3,r2,18
 8245460:	18000e1e 	bne	r3,zero,824549c <igmpv2_input+0x98>
 8245464:	10c004c8 	cmpgei	r3,r2,19
 8245468:	1800031e 	bne	r3,zero,8245478 <igmpv2_input+0x74>
 824546c:	10800460 	cmpeqi	r2,r2,17
 8245470:	1000061e 	bne	r2,zero,824548c <igmpv2_input+0x88>
 8245474:	00001606 	br	82454d0 <igmpv2_input+0xcc>
 8245478:	10c005a0 	cmpeqi	r3,r2,22
 824547c:	1800071e 	bne	r3,zero,824549c <igmpv2_input+0x98>
 8245480:	108005e0 	cmpeqi	r2,r2,23
 8245484:	1000091e 	bne	r2,zero,82454ac <igmpv2_input+0xa8>
 8245488:	00001106 	br	82454d0 <igmpv2_input+0xcc>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 824548c:	e13fff17 	ldw	r4,-4(fp)
 8245490:	824565c0 	call	824565c <igmpv2_process_query>
 8245494:	e0bffb15 	stw	r2,-20(fp)
         break;
 8245498:	00001706 	br	82454f8 <igmpv2_input+0xf4>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 824549c:	e13fff17 	ldw	r4,-4(fp)
 82454a0:	82455280 	call	8245528 <igmpv2_process_report>
 82454a4:	e0bffb15 	stw	r2,-20(fp)
         break;
 82454a8:	00001306 	br	82454f8 <igmpv2_input+0xf4>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 82454ac:	008209b4 	movhi	r2,2086
 82454b0:	10b6b604 	addi	r2,r2,-9512
 82454b4:	10800917 	ldw	r2,36(r2)
 82454b8:	10c00044 	addi	r3,r2,1
 82454bc:	008209b4 	movhi	r2,2086
 82454c0:	10b6b604 	addi	r2,r2,-9512
 82454c4:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 82454c8:	e03ffb15 	stw	zero,-20(fp)
         break;               
 82454cc:	00000a06 	br	82454f8 <igmpv2_input+0xf4>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 82454d0:	008209b4 	movhi	r2,2086
 82454d4:	10b6b604 	addi	r2,r2,-9512
 82454d8:	10801517 	ldw	r2,84(r2)
 82454dc:	10c00044 	addi	r3,r2,1
 82454e0:	008209b4 	movhi	r2,2086
 82454e4:	10b6b604 	addi	r2,r2,-9512
 82454e8:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 82454ec:	00bfffc4 	movi	r2,-1
 82454f0:	e0bffb15 	stw	r2,-20(fp)
         break;
 82454f4:	0001883a 	nop
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82454f8:	01000084 	movi	r4,2
 82454fc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   pk_free(p);
 8245500:	e13fff17 	ldw	r4,-4(fp)
 8245504:	822c9700 	call	822c970 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245508:	01000084 	movi	r4,2
 824550c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
   
   return rc;
 8245510:	e0bffb17 	ldw	r2,-20(fp)
}
 8245514:	e037883a 	mov	sp,fp
 8245518:	dfc00117 	ldw	ra,4(sp)
 824551c:	df000017 	ldw	fp,0(sp)
 8245520:	dec00204 	addi	sp,sp,8
 8245524:	f800283a 	ret

08245528 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 8245528:	defff904 	addi	sp,sp,-28
 824552c:	dfc00615 	stw	ra,24(sp)
 8245530:	df000515 	stw	fp,20(sp)
 8245534:	df000504 	addi	fp,sp,20
 8245538:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 824553c:	e0bfff17 	ldw	r2,-4(fp)
 8245540:	10800617 	ldw	r2,24(r2)
 8245544:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 8245548:	e0bfff17 	ldw	r2,-4(fp)
 824554c:	10800317 	ldw	r2,12(r2)
 8245550:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 8245554:	e0bffc17 	ldw	r2,-16(fp)
 8245558:	10800003 	ldbu	r2,0(r2)
 824555c:	10803fcc 	andi	r2,r2,255
 8245560:	108003cc 	andi	r2,r2,15
 8245564:	1085883a 	add	r2,r2,r2
 8245568:	1085883a 	add	r2,r2,r2
 824556c:	1007883a 	mov	r3,r2
 8245570:	e0bffc17 	ldw	r2,-16(fp)
 8245574:	10c5883a 	add	r2,r2,r3
 8245578:	e0bffd15 	stw	r2,-12(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 824557c:	e0bffd17 	ldw	r2,-12(fp)
 8245580:	10800117 	ldw	r2,4(r2)
 8245584:	e17ffb17 	ldw	r5,-20(fp)
 8245588:	1009883a 	mov	r4,r2
 824558c:	82437fc0 	call	82437fc <lookup_mcast>
 8245590:	e0bffe15 	stw	r2,-8(fp)
   if (inm != NULL) 
 8245594:	e0bffe17 	ldw	r2,-8(fp)
 8245598:	10002326 	beq	r2,zero,8245628 <igmpv2_process_report+0x100>
   {
      if (inm->inm_timer != 0)
 824559c:	e0bffe17 	ldw	r2,-8(fp)
 82455a0:	10800317 	ldw	r2,12(r2)
 82455a4:	10001826 	beq	r2,zero,8245608 <igmpv2_process_report+0xe0>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82455a8:	e0bffb17 	ldw	r2,-20(fp)
 82455ac:	10802d03 	ldbu	r2,180(r2)
 82455b0:	10803fcc 	andi	r2,r2,255
 82455b4:	10000526 	beq	r2,zero,82455cc <igmpv2_process_report+0xa4>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
 82455b8:	e0bffd17 	ldw	r2,-12(fp)
 82455bc:	10800003 	ldbu	r2,0(r2)
   if (inm != NULL) 
   {
      if (inm->inm_timer != 0)
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82455c0:	10803fcc 	andi	r2,r2,255
 82455c4:	108005a0 	cmpeqi	r2,r2,22
 82455c8:	10001e1e 	bne	r2,zero,8245644 <igmpv2_process_report+0x11c>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 82455cc:	e0bffe17 	ldw	r2,-8(fp)
 82455d0:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 82455d4:	d0a08617 	ldw	r2,-32232(gp)
 82455d8:	10bfffc4 	addi	r2,r2,-1
 82455dc:	d0a08615 	stw	r2,-32232(gp)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 82455e0:	e0bffe17 	ldw	r2,-8(fp)
 82455e4:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 82455e8:	008209b4 	movhi	r2,2086
 82455ec:	10b6b604 	addi	r2,r2,-9512
 82455f0:	10800717 	ldw	r2,28(r2)
 82455f4:	10c00044 	addi	r3,r2,1
 82455f8:	008209b4 	movhi	r2,2086
 82455fc:	10b6b604 	addi	r2,r2,-9512
 8245600:	10c00715 	stw	r3,28(r2)
 8245604:	00000f06 	br	8245644 <igmpv2_process_report+0x11c>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 8245608:	008209b4 	movhi	r2,2086
 824560c:	10b6b604 	addi	r2,r2,-9512
 8245610:	10800817 	ldw	r2,32(r2)
 8245614:	10c00044 	addi	r3,r2,1
 8245618:	008209b4 	movhi	r2,2086
 824561c:	10b6b604 	addi	r2,r2,-9512
 8245620:	10c00815 	stw	r3,32(r2)
 8245624:	00000706 	br	8245644 <igmpv2_process_report+0x11c>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 8245628:	008209b4 	movhi	r2,2086
 824562c:	10b6b604 	addi	r2,r2,-9512
 8245630:	10801317 	ldw	r2,76(r2)
 8245634:	10c00044 	addi	r3,r2,1
 8245638:	008209b4 	movhi	r2,2086
 824563c:	10b6b604 	addi	r2,r2,-9512
 8245640:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 8245644:	0005883a 	mov	r2,zero
}
 8245648:	e037883a 	mov	sp,fp
 824564c:	dfc00117 	ldw	ra,4(sp)
 8245650:	df000017 	ldw	fp,0(sp)
 8245654:	dec00204 	addi	sp,sp,8
 8245658:	f800283a 	ret

0824565c <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 824565c:	defff804 	addi	sp,sp,-32
 8245660:	dfc00715 	stw	ra,28(sp)
 8245664:	df000615 	stw	fp,24(sp)
 8245668:	df000604 	addi	fp,sp,24
 824566c:	e13fff15 	stw	r4,-4(fp)
   NET netp;
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;

   netp = p->net;
 8245670:	e0bfff17 	ldw	r2,-4(fp)
 8245674:	10800617 	ldw	r2,24(r2)
 8245678:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 824567c:	e0bfff17 	ldw	r2,-4(fp)
 8245680:	10800317 	ldw	r2,12(r2)
 8245684:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245688:	e0bffd17 	ldw	r2,-12(fp)
 824568c:	10800003 	ldbu	r2,0(r2)
 8245690:	10803fcc 	andi	r2,r2,255
 8245694:	108003cc 	andi	r2,r2,15
 8245698:	1085883a 	add	r2,r2,r2
 824569c:	1085883a 	add	r2,r2,r2
 82456a0:	1007883a 	mov	r3,r2
 82456a4:	e0bffd17 	ldw	r2,-12(fp)
 82456a8:	10c5883a 	add	r2,r2,r3
 82456ac:	e0bffe15 	stw	r2,-8(fp)

   if (igmp->igmp_code == 0)
 82456b0:	e0bffe17 	ldw	r2,-8(fp)
 82456b4:	10800043 	ldbu	r2,1(r2)
 82456b8:	10803fcc 	andi	r2,r2,255
 82456bc:	1000121e 	bne	r2,zero,8245708 <igmpv2_process_query+0xac>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 82456c0:	e0bffc17 	ldw	r2,-16(fp)
 82456c4:	00c00044 	movi	r3,1
 82456c8:	10c02d05 	stb	r3,180(r2)
      netp->igmpv1_query_rcvd_time = cticks;      
 82456cc:	d0e0a817 	ldw	r3,-32096(gp)
 82456d0:	e0bffc17 	ldw	r2,-16(fp)
 82456d4:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 82456d8:	008209b4 	movhi	r2,2086
 82456dc:	10b6b604 	addi	r2,r2,-9512
 82456e0:	10800417 	ldw	r2,16(r2)
 82456e4:	10c00044 	addi	r3,r2,1
 82456e8:	008209b4 	movhi	r2,2086
 82456ec:	10b6b604 	addi	r2,r2,-9512
 82456f0:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 82456f4:	00800c84 	movi	r2,50
 82456f8:	e0bffa0d 	sth	r2,-24(fp)
      process_all = IGMP_TRUE;
 82456fc:	00800044 	movi	r2,1
 8245700:	e0bffa85 	stb	r2,-22(fp)
 8245704:	00001d06 	br	824577c <igmpv2_process_query+0x120>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 8245708:	e0bffe17 	ldw	r2,-8(fp)
 824570c:	10800117 	ldw	r2,4(r2)
 8245710:	10000a1e 	bne	r2,zero,824573c <igmpv2_process_query+0xe0>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 8245714:	008209b4 	movhi	r2,2086
 8245718:	10b6b604 	addi	r2,r2,-9512
 824571c:	10800517 	ldw	r2,20(r2)
 8245720:	10c00044 	addi	r3,r2,1
 8245724:	008209b4 	movhi	r2,2086
 8245728:	10b6b604 	addi	r2,r2,-9512
 824572c:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 8245730:	00800044 	movi	r2,1
 8245734:	e0bffa85 	stb	r2,-22(fp)
 8245738:	00000806 	br	824575c <igmpv2_process_query+0x100>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 824573c:	008209b4 	movhi	r2,2086
 8245740:	10b6b604 	addi	r2,r2,-9512
 8245744:	10800617 	ldw	r2,24(r2)
 8245748:	10c00044 	addi	r3,r2,1
 824574c:	008209b4 	movhi	r2,2086
 8245750:	10b6b604 	addi	r2,r2,-9512
 8245754:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 8245758:	e03ffa85 	stb	zero,-22(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 824575c:	e0bffe17 	ldw	r2,-8(fp)
 8245760:	10800043 	ldbu	r2,1(r2)
 8245764:	10803fcc 	andi	r2,r2,255
 8245768:	10800164 	muli	r2,r2,5
 824576c:	01400284 	movi	r5,10
 8245770:	1009883a 	mov	r4,r2
 8245774:	82026140 	call	8202614 <__divsi3>
 8245778:	e0bffa0d 	sth	r2,-24(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 824577c:	e0bffa83 	ldbu	r2,-22(fp)
 8245780:	10001726 	beq	r2,zero,82457e0 <igmpv2_process_query+0x184>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245784:	e0bffc17 	ldw	r2,-16(fp)
 8245788:	10802c17 	ldw	r2,176(r2)
 824578c:	e0bffb15 	stw	r2,-20(fp)
 8245790:	00001006 	br	82457d4 <igmpv2_process_query+0x178>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 8245794:	e0bffb17 	ldw	r2,-20(fp)
 8245798:	10800017 	ldw	r2,0(r2)
 824579c:	10000926 	beq	r2,zero,82457c4 <igmpv2_process_query+0x168>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 82457a0:	e0bffb17 	ldw	r2,-20(fp)
 82457a4:	10c00017 	ldw	r3,0(r2)
 82457a8:	d0a08817 	ldw	r2,-32224(gp)
 82457ac:	18800626 	beq	r3,r2,82457c8 <igmpv2_process_query+0x16c>
            igmpv2_chk_set_timer (inm, max_resp_time);
 82457b0:	e0bffa0b 	ldhu	r2,-24(fp)
 82457b4:	100b883a 	mov	r5,r2
 82457b8:	e13ffb17 	ldw	r4,-20(fp)
 82457bc:	82458480 	call	8245848 <igmpv2_chk_set_timer>
 82457c0:	00000106 	br	82457c8 <igmpv2_process_query+0x16c>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 82457c4:	0001883a 	nop
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82457c8:	e0bffb17 	ldw	r2,-20(fp)
 82457cc:	10800517 	ldw	r2,20(r2)
 82457d0:	e0bffb15 	stw	r2,-20(fp)
 82457d4:	e0bffb17 	ldw	r2,-20(fp)
 82457d8:	103fee1e 	bne	r2,zero,8245794 <igmpv2_process_query+0x138>
 82457dc:	00001406 	br	8245830 <igmpv2_process_query+0x1d4>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 82457e0:	e0bffe17 	ldw	r2,-8(fp)
 82457e4:	10800117 	ldw	r2,4(r2)
 82457e8:	e17ffc17 	ldw	r5,-16(fp)
 82457ec:	1009883a 	mov	r4,r2
 82457f0:	82437fc0 	call	82437fc <lookup_mcast>
 82457f4:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL)
 82457f8:	e0bffb17 	ldw	r2,-20(fp)
 82457fc:	10000526 	beq	r2,zero,8245814 <igmpv2_process_query+0x1b8>
         igmpv2_chk_set_timer (inm, max_resp_time);
 8245800:	e0bffa0b 	ldhu	r2,-24(fp)
 8245804:	100b883a 	mov	r5,r2
 8245808:	e13ffb17 	ldw	r4,-20(fp)
 824580c:	82458480 	call	8245848 <igmpv2_chk_set_timer>
 8245810:	00000706 	br	8245830 <igmpv2_process_query+0x1d4>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 8245814:	008209b4 	movhi	r2,2086
 8245818:	10b6b604 	addi	r2,r2,-9512
 824581c:	10801217 	ldw	r2,72(r2)
 8245820:	10c00044 	addi	r3,r2,1
 8245824:	008209b4 	movhi	r2,2086
 8245828:	10b6b604 	addi	r2,r2,-9512
 824582c:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 8245830:	0005883a 	mov	r2,zero
}
 8245834:	e037883a 	mov	sp,fp
 8245838:	dfc00117 	ldw	ra,4(sp)
 824583c:	df000017 	ldw	fp,0(sp)
 8245840:	dec00204 	addi	sp,sp,8
 8245844:	f800283a 	ret

08245848 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 8245848:	defffc04 	addi	sp,sp,-16
 824584c:	dfc00315 	stw	ra,12(sp)
 8245850:	df000215 	stw	fp,8(sp)
 8245854:	df000204 	addi	fp,sp,8
 8245858:	e13ffe15 	stw	r4,-8(fp)
 824585c:	2805883a 	mov	r2,r5
 8245860:	e0bfff0d 	sth	r2,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245864:	e0bffe17 	ldw	r2,-8(fp)
 8245868:	10800317 	ldw	r2,12(r2)
 824586c:	e0ffff0b 	ldhu	r3,-4(fp)
 8245870:	18800336 	bltu	r3,r2,8245880 <igmpv2_chk_set_timer+0x38>
       (inm->inm_timer == 0))
 8245874:	e0bffe17 	ldw	r2,-8(fp)
 8245878:	10800317 	ldw	r2,12(r2)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 824587c:	10003d1e 	bne	r2,zero,8245974 <igmpv2_chk_set_timer+0x12c>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 8245880:	e0bffe17 	ldw	r2,-8(fp)
 8245884:	10800317 	ldw	r2,12(r2)
 8245888:	1000031e 	bne	r2,zero,8245898 <igmpv2_chk_set_timer+0x50>
 824588c:	d0a08617 	ldw	r2,-32232(gp)
 8245890:	10800044 	addi	r2,r2,1
 8245894:	d0a08615 	stw	r2,-32232(gp)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 8245898:	008209b4 	movhi	r2,2086
 824589c:	10b8f804 	addi	r2,r2,-7200
 82458a0:	10c00217 	ldw	r3,8(r2)
 82458a4:	008209b4 	movhi	r2,2086
 82458a8:	10b6b204 	addi	r2,r2,-9528
 82458ac:	10800017 	ldw	r2,0(r2)
 82458b0:	10800a17 	ldw	r2,40(r2)
 82458b4:	1008d63a 	srli	r4,r2,24
 82458b8:	008209b4 	movhi	r2,2086
 82458bc:	10b6b204 	addi	r2,r2,-9528
 82458c0:	10800017 	ldw	r2,0(r2)
 82458c4:	10800a17 	ldw	r2,40(r2)
 82458c8:	1004d23a 	srli	r2,r2,8
 82458cc:	10bfc00c 	andi	r2,r2,65280
 82458d0:	2088b03a 	or	r4,r4,r2
 82458d4:	008209b4 	movhi	r2,2086
 82458d8:	10b6b204 	addi	r2,r2,-9528
 82458dc:	10800017 	ldw	r2,0(r2)
 82458e0:	10800a17 	ldw	r2,40(r2)
 82458e4:	10bfc00c 	andi	r2,r2,65280
 82458e8:	1004923a 	slli	r2,r2,8
 82458ec:	2088b03a 	or	r4,r4,r2
 82458f0:	008209b4 	movhi	r2,2086
 82458f4:	10b6b204 	addi	r2,r2,-9528
 82458f8:	10800017 	ldw	r2,0(r2)
 82458fc:	10800a17 	ldw	r2,40(r2)
 8245900:	1004963a 	slli	r2,r2,24
 8245904:	2084b03a 	or	r2,r4,r2
 8245908:	1887883a 	add	r3,r3,r2
 824590c:	e0bffe17 	ldw	r2,-8(fp)
 8245910:	10800017 	ldw	r2,0(r2)
 8245914:	1008d63a 	srli	r4,r2,24
 8245918:	e0bffe17 	ldw	r2,-8(fp)
 824591c:	10800017 	ldw	r2,0(r2)
 8245920:	1004d23a 	srli	r2,r2,8
 8245924:	10bfc00c 	andi	r2,r2,65280
 8245928:	2088b03a 	or	r4,r4,r2
 824592c:	e0bffe17 	ldw	r2,-8(fp)
 8245930:	10800017 	ldw	r2,0(r2)
 8245934:	10bfc00c 	andi	r2,r2,65280
 8245938:	1004923a 	slli	r2,r2,8
 824593c:	2088b03a 	or	r4,r4,r2
 8245940:	e0bffe17 	ldw	r2,-8(fp)
 8245944:	10800017 	ldw	r2,0(r2)
 8245948:	1004963a 	slli	r2,r2,24
 824594c:	2084b03a 	or	r2,r4,r2
 8245950:	1885883a 	add	r2,r3,r2
 8245954:	e0ffff0b 	ldhu	r3,-4(fp)
 8245958:	180b883a 	mov	r5,r3
 824595c:	1009883a 	mov	r4,r2
 8245960:	82027700 	call	8202770 <__umodsi3>
 8245964:	10c00044 	addi	r3,r2,1
 8245968:	e0bffe17 	ldw	r2,-8(fp)
 824596c:	10c00315 	stw	r3,12(r2)
   }

   return;
 8245970:	0001883a 	nop
 8245974:	0001883a 	nop
}
 8245978:	e037883a 	mov	sp,fp
 824597c:	dfc00117 	ldw	ra,4(sp)
 8245980:	df000017 	ldw	fp,0(sp)
 8245984:	dec00204 	addi	sp,sp,8
 8245988:	f800283a 	ret

0824598c <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 824598c:	defffb04 	addi	sp,sp,-20
 8245990:	df000415 	stw	fp,16(sp)
 8245994:	df000404 	addi	fp,sp,16
 8245998:	e13fff15 	stw	r4,-4(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 824599c:	e0bfff17 	ldw	r2,-4(fp)
 82459a0:	10800003 	ldbu	r2,0(r2)
 82459a4:	108003cc 	andi	r2,r2,15
 82459a8:	1085883a 	add	r2,r2,r2
 82459ac:	1085883a 	add	r2,r2,r2
 82459b0:	10bffb04 	addi	r2,r2,-20
 82459b4:	e0bffd05 	stb	r2,-12(fp)

   if (total_optlen > 0)
 82459b8:	e0bffd03 	ldbu	r2,-12(fp)
 82459bc:	10003e26 	beq	r2,zero,8245ab8 <igmpv2_chk4_rtr_alert_opt+0x12c>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 82459c0:	e0bfff17 	ldw	r2,-4(fp)
 82459c4:	10800504 	addi	r2,r2,20
 82459c8:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 82459cc:	00003806 	br	8245ab0 <igmpv2_chk4_rtr_alert_opt+0x124>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 82459d0:	e0bffc17 	ldw	r2,-16(fp)
 82459d4:	10800003 	ldbu	r2,0(r2)
 82459d8:	108007cc 	andi	r2,r2,31
 82459dc:	e0bffd85 	stb	r2,-10(fp)
         switch (optval)
 82459e0:	e0bffd83 	ldbu	r2,-10(fp)
 82459e4:	10c00060 	cmpeqi	r3,r2,1
 82459e8:	1800071e 	bne	r3,zero,8245a08 <igmpv2_chk4_rtr_alert_opt+0x7c>
 82459ec:	10c00520 	cmpeqi	r3,r2,20
 82459f0:	1800081e 	bne	r3,zero,8245a14 <igmpv2_chk4_rtr_alert_opt+0x88>
 82459f4:	1000201e 	bne	r2,zero,8245a78 <igmpv2_chk4_rtr_alert_opt+0xec>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 82459f8:	00800044 	movi	r2,1
 82459fc:	e0bffd45 	stb	r2,-11(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 8245a00:	0005883a 	mov	r2,zero
 8245a04:	00002d06 	br	8245abc <igmpv2_chk4_rtr_alert_opt+0x130>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 8245a08:	00800044 	movi	r2,1
 8245a0c:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245a10:	00001f06 	br	8245a90 <igmpv2_chk4_rtr_alert_opt+0x104>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 8245a14:	e0bffc17 	ldw	r2,-16(fp)
 8245a18:	e0bffe15 	stw	r2,-8(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 8245a1c:	e0bffe17 	ldw	r2,-8(fp)
 8245a20:	10800017 	ldw	r2,0(r2)
 8245a24:	1006d63a 	srli	r3,r2,24
 8245a28:	e0bffe17 	ldw	r2,-8(fp)
 8245a2c:	10800017 	ldw	r2,0(r2)
 8245a30:	1004d23a 	srli	r2,r2,8
 8245a34:	10bfc00c 	andi	r2,r2,65280
 8245a38:	1886b03a 	or	r3,r3,r2
 8245a3c:	e0bffe17 	ldw	r2,-8(fp)
 8245a40:	10800017 	ldw	r2,0(r2)
 8245a44:	10bfc00c 	andi	r2,r2,65280
 8245a48:	1004923a 	slli	r2,r2,8
 8245a4c:	1886b03a 	or	r3,r3,r2
 8245a50:	e0bffe17 	ldw	r2,-8(fp)
 8245a54:	10800017 	ldw	r2,0(r2)
 8245a58:	1004963a 	slli	r2,r2,24
 8245a5c:	1886b03a 	or	r3,r3,r2
 8245a60:	00a50134 	movhi	r2,37892
 8245a64:	1880021e 	bne	r3,r2,8245a70 <igmpv2_chk4_rtr_alert_opt+0xe4>
                  /* found the option, return success */
                  return IGMP_TRUE;
 8245a68:	00800044 	movi	r2,1
 8245a6c:	00001306 	br	8245abc <igmpv2_chk4_rtr_alert_opt+0x130>
               else return IGMP_FALSE;
 8245a70:	0005883a 	mov	r2,zero
 8245a74:	00001106 	br	8245abc <igmpv2_chk4_rtr_alert_opt+0x130>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 8245a78:	e0bffc17 	ldw	r2,-16(fp)
 8245a7c:	10800044 	addi	r2,r2,1
 8245a80:	10800003 	ldbu	r2,0(r2)
 8245a84:	10800084 	addi	r2,r2,2
 8245a88:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245a8c:	0001883a 	nop
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 8245a90:	e0bffd43 	ldbu	r2,-11(fp)
 8245a94:	e0fffc17 	ldw	r3,-16(fp)
 8245a98:	1885883a 	add	r2,r3,r2
 8245a9c:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 8245aa0:	e0fffd03 	ldbu	r3,-12(fp)
 8245aa4:	e0bffd43 	ldbu	r2,-11(fp)
 8245aa8:	1885c83a 	sub	r2,r3,r2
 8245aac:	e0bffd05 	stb	r2,-12(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 8245ab0:	e0bffd03 	ldbu	r2,-12(fp)
 8245ab4:	103fc61e 	bne	r2,zero,82459d0 <igmpv2_chk4_rtr_alert_opt+0x44>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 8245ab8:	0005883a 	mov	r2,zero
}
 8245abc:	e037883a 	mov	sp,fp
 8245ac0:	df000017 	ldw	fp,0(sp)
 8245ac4:	dec00104 	addi	sp,sp,4
 8245ac8:	f800283a 	ret

08245acc <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 8245acc:	defffc04 	addi	sp,sp,-16
 8245ad0:	df000315 	stw	fp,12(sp)
 8245ad4:	df000304 	addi	fp,sp,12
 8245ad8:	e13ffe15 	stw	r4,-8(fp)
 8245adc:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 8245ae0:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 8245ae4:	e0fffd0b 	ldhu	r3,-12(fp)
 8245ae8:	008209b4 	movhi	r2,2086
 8245aec:	10b6b204 	addi	r2,r2,-9528
 8245af0:	18c7883a 	add	r3,r3,r3
 8245af4:	18c7883a 	add	r3,r3,r3
 8245af8:	10c5883a 	add	r2,r2,r3
 8245afc:	10c00017 	ldw	r3,0(r2)
 8245b00:	e0bfff17 	ldw	r2,-4(fp)
 8245b04:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 8245b08:	e0bffe17 	ldw	r2,-8(fp)
 8245b0c:	10002e1e 	bne	r2,zero,8245bc8 <IPADDR_TO_NETP+0xfc>
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245b10:	e03ffd0d 	sth	zero,-12(fp)
 8245b14:	00001606 	br	8245b70 <IPADDR_TO_NETP+0xa4>
      {
         if (nets[idx]->n_mcastlist)
 8245b18:	e0fffd0b 	ldhu	r3,-12(fp)
 8245b1c:	008209b4 	movhi	r2,2086
 8245b20:	10b6b204 	addi	r2,r2,-9528
 8245b24:	18c7883a 	add	r3,r3,r3
 8245b28:	18c7883a 	add	r3,r3,r3
 8245b2c:	10c5883a 	add	r2,r2,r3
 8245b30:	10800017 	ldw	r2,0(r2)
 8245b34:	10802b17 	ldw	r2,172(r2)
 8245b38:	10000a26 	beq	r2,zero,8245b64 <IPADDR_TO_NETP+0x98>
         {
            *netp = nets[idx];
 8245b3c:	e0fffd0b 	ldhu	r3,-12(fp)
 8245b40:	008209b4 	movhi	r2,2086
 8245b44:	10b6b204 	addi	r2,r2,-9528
 8245b48:	18c7883a 	add	r3,r3,r3
 8245b4c:	18c7883a 	add	r3,r3,r3
 8245b50:	10c5883a 	add	r2,r2,r3
 8245b54:	10c00017 	ldw	r3,0(r2)
 8245b58:	e0bfff17 	ldw	r2,-4(fp)
 8245b5c:	10c00015 	stw	r3,0(r2)
            break;
 8245b60:	00002206 	br	8245bec <IPADDR_TO_NETP+0x120>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245b64:	e0bffd0b 	ldhu	r2,-12(fp)
 8245b68:	10800044 	addi	r2,r2,1
 8245b6c:	e0bffd0d 	sth	r2,-12(fp)
 8245b70:	e0fffd0b 	ldhu	r3,-12(fp)
 8245b74:	d0a08417 	ldw	r2,-32240(gp)
 8245b78:	18bfe736 	bltu	r3,r2,8245b18 <IPADDR_TO_NETP+0x4c>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245b7c:	00001b06 	br	8245bec <IPADDR_TO_NETP+0x120>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 8245b80:	e0bffd0b 	ldhu	r2,-12(fp)
 8245b84:	10800044 	addi	r2,r2,1
 8245b88:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 8245b8c:	e0fffd0b 	ldhu	r3,-12(fp)
 8245b90:	d0a08417 	ldw	r2,-32240(gp)
 8245b94:	18800336 	bltu	r3,r2,8245ba4 <IPADDR_TO_NETP+0xd8>
         {
            *netp = NULL;
 8245b98:	e0bfff17 	ldw	r2,-4(fp)
 8245b9c:	10000015 	stw	zero,0(r2)
            break;
 8245ba0:	00001206 	br	8245bec <IPADDR_TO_NETP+0x120>
         }
         else
            *netp = nets[idx];
 8245ba4:	e0fffd0b 	ldhu	r3,-12(fp)
 8245ba8:	008209b4 	movhi	r2,2086
 8245bac:	10b6b204 	addi	r2,r2,-9528
 8245bb0:	18c7883a 	add	r3,r3,r3
 8245bb4:	18c7883a 	add	r3,r3,r3
 8245bb8:	10c5883a 	add	r2,r2,r3
 8245bbc:	10c00017 	ldw	r3,0(r2)
 8245bc0:	e0bfff17 	ldw	r2,-4(fp)
 8245bc4:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 8245bc8:	e0bfff17 	ldw	r2,-4(fp)
 8245bcc:	10800017 	ldw	r2,0(r2)
 8245bd0:	10000626 	beq	r2,zero,8245bec <IPADDR_TO_NETP+0x120>
 8245bd4:	e0bfff17 	ldw	r2,-4(fp)
 8245bd8:	10800017 	ldw	r2,0(r2)
 8245bdc:	10c00a17 	ldw	r3,40(r2)
 8245be0:	e0bffe17 	ldw	r2,-8(fp)
 8245be4:	18bfe61e 	bne	r3,r2,8245b80 <IPADDR_TO_NETP+0xb4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245be8:	00000006 	br	8245bec <IPADDR_TO_NETP+0x120>
 8245bec:	0001883a 	nop
 8245bf0:	e037883a 	mov	sp,fp
 8245bf4:	df000017 	ldw	fp,0(sp)
 8245bf8:	dec00104 	addi	sp,sp,4
 8245bfc:	f800283a 	ret

08245c00 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 8245c00:	defff304 	addi	sp,sp,-52
 8245c04:	dfc00c15 	stw	ra,48(sp)
 8245c08:	df000b15 	stw	fp,44(sp)
 8245c0c:	dc000a15 	stw	r16,40(sp)
 8245c10:	df000b04 	addi	fp,sp,44
 8245c14:	e13ffc15 	stw	r4,-16(fp)
 8245c18:	e17ffd15 	stw	r5,-12(fp)
 8245c1c:	e1bffe15 	stw	r6,-8(fp)
   int   error =  0;
 8245c20:	e03ff515 	stw	zero,-44(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 8245c24:	e03ffb15 	stw	zero,-20(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 8245c28:	e0bffd17 	ldw	r2,-12(fp)
 8245c2c:	10800317 	ldw	r2,12(r2)
 8245c30:	e0bff715 	stw	r2,-36(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 8245c34:	e0bffd17 	ldw	r2,-12(fp)
 8245c38:	10800304 	addi	r2,r2,12
 8245c3c:	e0bff815 	stw	r2,-32(fp)
   ip_addr addr;


   if (imo == NULL) 
 8245c40:	e0bff717 	ldw	r2,-36(fp)
 8245c44:	1000141e 	bne	r2,zero,8245c98 <ip_setmoptions+0x98>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 8245c48:	01001604 	movi	r4,88
 8245c4c:	822dda00 	call	822dda0 <npalloc>
 8245c50:	e0bff715 	stw	r2,-36(fp)

      if (imo == NULL)
 8245c54:	e0bff717 	ldw	r2,-36(fp)
 8245c58:	1000021e 	bne	r2,zero,8245c64 <ip_setmoptions+0x64>
         return (ENOBUFS);
 8245c5c:	00801a44 	movi	r2,105
 8245c60:	00015306 	br	82461b0 <ip_setmoptions+0x5b0>
      *imop = imo;
 8245c64:	e0bff817 	ldw	r2,-32(fp)
 8245c68:	e0fff717 	ldw	r3,-36(fp)
 8245c6c:	10c00015 	stw	r3,0(r2)
      imo->imo_multicast_netp = NULL;
 8245c70:	e0bff717 	ldw	r2,-36(fp)
 8245c74:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 8245c78:	e0bff717 	ldw	r2,-36(fp)
 8245c7c:	00c00044 	movi	r3,1
 8245c80:	10c00105 	stb	r3,4(r2)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 8245c84:	e0bff717 	ldw	r2,-36(fp)
 8245c88:	00c00044 	movi	r3,1
 8245c8c:	10c00145 	stb	r3,5(r2)
      imo->imo_num_memberships = 0;
 8245c90:	e0bff717 	ldw	r2,-36(fp)
 8245c94:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 8245c98:	e0bffc17 	ldw	r2,-16(fp)
 8245c9c:	10bffdc4 	addi	r2,r2,-9
 8245ca0:	10c00168 	cmpgeui	r3,r2,5
 8245ca4:	1801261e 	bne	r3,zero,8246140 <ip_setmoptions+0x540>
 8245ca8:	100690ba 	slli	r3,r2,2
 8245cac:	00820934 	movhi	r2,2084
 8245cb0:	10973004 	addi	r2,r2,23744
 8245cb4:	1885883a 	add	r2,r3,r2
 8245cb8:	10800017 	ldw	r2,0(r2)
 8245cbc:	1000683a 	jmp	r2
 8245cc0:	08245cd4 	ori	zero,at,37235
 8245cc4:	08245d3c 	xorhi	zero,at,37236
 8245cc8:	08245d50 	cmplti	zero,at,-28299
 8245ccc:	08245d84 	addi	zero,at,-28298
 8245cd0:	08245f58 	cmpnei	zero,at,-28291

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 8245cd4:	e0bffe17 	ldw	r2,-8(fp)
 8245cd8:	10800017 	ldw	r2,0(r2)
 8245cdc:	e0bff915 	stw	r2,-28(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 8245ce0:	e0bff917 	ldw	r2,-28(fp)
 8245ce4:	1000031e 	bne	r2,zero,8245cf4 <ip_setmoptions+0xf4>
      {
         imo->imo_multicast_netp = NULL;
 8245ce8:	e0bff717 	ldw	r2,-36(fp)
 8245cec:	10000015 	stw	zero,0(r2)
         break;
 8245cf0:	00011706 	br	8246150 <ip_setmoptions+0x550>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 8245cf4:	e0bffb04 	addi	r2,fp,-20
 8245cf8:	100b883a 	mov	r5,r2
 8245cfc:	e13ff917 	ldw	r4,-28(fp)
 8245d00:	8245acc0 	call	8245acc <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 8245d04:	e0bffb17 	ldw	r2,-20(fp)
 8245d08:	10000326 	beq	r2,zero,8245d18 <ip_setmoptions+0x118>
 8245d0c:	e0bffb17 	ldw	r2,-20(fp)
 8245d10:	10802b17 	ldw	r2,172(r2)
 8245d14:	1000031e 	bne	r2,zero,8245d24 <ip_setmoptions+0x124>
      {
         error = EADDRNOTAVAIL;
 8245d18:	00801f44 	movi	r2,125
 8245d1c:	e0bff515 	stw	r2,-44(fp)
         break;
 8245d20:	00010b06 	br	8246150 <ip_setmoptions+0x550>
      }
      if (addr != AADDR) 
 8245d24:	e0bff917 	ldw	r2,-28(fp)
 8245d28:	10010826 	beq	r2,zero,824614c <ip_setmoptions+0x54c>
         imo->imo_multicast_netp = netp;
 8245d2c:	e0fffb17 	ldw	r3,-20(fp)
 8245d30:	e0bff717 	ldw	r2,-36(fp)
 8245d34:	10c00015 	stw	r3,0(r2)
      break;
 8245d38:	00010406 	br	824614c <ip_setmoptions+0x54c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 8245d3c:	e0bffe17 	ldw	r2,-8(fp)
 8245d40:	10c00003 	ldbu	r3,0(r2)
 8245d44:	e0bff717 	ldw	r2,-36(fp)
 8245d48:	10c00105 	stb	r3,4(r2)
      break;
 8245d4c:	00010006 	br	8246150 <ip_setmoptions+0x550>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 8245d50:	e0bffe17 	ldw	r2,-8(fp)
 8245d54:	10800003 	ldbu	r2,0(r2)
 8245d58:	10803fcc 	andi	r2,r2,255
 8245d5c:	108000b0 	cmpltui	r2,r2,2
 8245d60:	1000031e 	bne	r2,zero,8245d70 <ip_setmoptions+0x170>
      {
         error = EINVAL;
 8245d64:	00800584 	movi	r2,22
 8245d68:	e0bff515 	stw	r2,-44(fp)
         break;
 8245d6c:	0000f806 	br	8246150 <ip_setmoptions+0x550>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 8245d70:	e0bffe17 	ldw	r2,-8(fp)
 8245d74:	10c00003 	ldbu	r3,0(r2)
 8245d78:	e0bff717 	ldw	r2,-36(fp)
 8245d7c:	10c00145 	stb	r3,5(r2)
      break;
 8245d80:	0000f306 	br	8246150 <ip_setmoptions+0x550>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8245d84:	e0bffe17 	ldw	r2,-8(fp)
 8245d88:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8245d8c:	e0bffa17 	ldw	r2,-24(fp)
 8245d90:	10800017 	ldw	r2,0(r2)
 8245d94:	1006d63a 	srli	r3,r2,24
 8245d98:	e0bffa17 	ldw	r2,-24(fp)
 8245d9c:	10800017 	ldw	r2,0(r2)
 8245da0:	1004d23a 	srli	r2,r2,8
 8245da4:	10bfc00c 	andi	r2,r2,65280
 8245da8:	1886b03a 	or	r3,r3,r2
 8245dac:	e0bffa17 	ldw	r2,-24(fp)
 8245db0:	10800017 	ldw	r2,0(r2)
 8245db4:	10bfc00c 	andi	r2,r2,65280
 8245db8:	1004923a 	slli	r2,r2,8
 8245dbc:	1886b03a 	or	r3,r3,r2
 8245dc0:	e0bffa17 	ldw	r2,-24(fp)
 8245dc4:	10800017 	ldw	r2,0(r2)
 8245dc8:	1004963a 	slli	r2,r2,24
 8245dcc:	1884b03a 	or	r2,r3,r2
 8245dd0:	10fc002c 	andhi	r3,r2,61440
 8245dd4:	00b80034 	movhi	r2,57344
 8245dd8:	18800326 	beq	r3,r2,8245de8 <ip_setmoptions+0x1e8>
      {
         error = EINVAL;
 8245ddc:	00800584 	movi	r2,22
 8245de0:	e0bff515 	stw	r2,-44(fp)
         break;
 8245de4:	0000da06 	br	8246150 <ip_setmoptions+0x550>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 8245de8:	e0bffa17 	ldw	r2,-24(fp)
 8245dec:	10800117 	ldw	r2,4(r2)
 8245df0:	e0fffb04 	addi	r3,fp,-20
 8245df4:	180b883a 	mov	r5,r3
 8245df8:	1009883a 	mov	r4,r2
 8245dfc:	8245acc0 	call	8245acc <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 8245e00:	e0bffb17 	ldw	r2,-20(fp)
 8245e04:	10000326 	beq	r2,zero,8245e14 <ip_setmoptions+0x214>
 8245e08:	e0bffb17 	ldw	r2,-20(fp)
 8245e0c:	10802b17 	ldw	r2,172(r2)
 8245e10:	1000031e 	bne	r2,zero,8245e20 <ip_setmoptions+0x220>
      {
         error = EADDRNOTAVAIL;
 8245e14:	00801f44 	movi	r2,125
 8245e18:	e0bff515 	stw	r2,-44(fp)
         break;
 8245e1c:	0000cc06 	br	8246150 <ip_setmoptions+0x550>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8245e20:	e03ff60d 	sth	zero,-40(fp)
 8245e24:	00001806 	br	8245e88 <ip_setmoptions+0x288>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8245e28:	e0bff60b 	ldhu	r2,-40(fp)
 8245e2c:	e0fff717 	ldw	r3,-36(fp)
 8245e30:	10800084 	addi	r2,r2,2
 8245e34:	1085883a 	add	r2,r2,r2
 8245e38:	1085883a 	add	r2,r2,r2
 8245e3c:	1885883a 	add	r2,r3,r2
 8245e40:	10800017 	ldw	r2,0(r2)
 8245e44:	10c00117 	ldw	r3,4(r2)
 8245e48:	e0bffb17 	ldw	r2,-20(fp)
 8245e4c:	18800b1e 	bne	r3,r2,8245e7c <ip_setmoptions+0x27c>
             imo->imo_membership[i]->inm_addr
 8245e50:	e0bff60b 	ldhu	r2,-40(fp)
 8245e54:	e0fff717 	ldw	r3,-36(fp)
 8245e58:	10800084 	addi	r2,r2,2
 8245e5c:	1085883a 	add	r2,r2,r2
 8245e60:	1085883a 	add	r2,r2,r2
 8245e64:	1885883a 	add	r2,r3,r2
 8245e68:	10800017 	ldw	r2,0(r2)
 8245e6c:	10c00017 	ldw	r3,0(r2)
             == mreq->imr_multiaddr)
 8245e70:	e0bffa17 	ldw	r2,-24(fp)
 8245e74:	10800017 	ldw	r2,0(r2)
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8245e78:	18800926 	beq	r3,r2,8245ea0 <ip_setmoptions+0x2a0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8245e7c:	e0bff60b 	ldhu	r2,-40(fp)
 8245e80:	10800044 	addi	r2,r2,1
 8245e84:	e0bff60d 	sth	r2,-40(fp)
 8245e88:	e0bff717 	ldw	r2,-36(fp)
 8245e8c:	1080018b 	ldhu	r2,6(r2)
 8245e90:	10bfffcc 	andi	r2,r2,65535
 8245e94:	e0fff60b 	ldhu	r3,-40(fp)
 8245e98:	18bfe336 	bltu	r3,r2,8245e28 <ip_setmoptions+0x228>
 8245e9c:	00000106 	br	8245ea4 <ip_setmoptions+0x2a4>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
             imo->imo_membership[i]->inm_addr
             == mreq->imr_multiaddr)
         {
            break;
 8245ea0:	0001883a 	nop
         }
      }
      if (i < imo->imo_num_memberships) 
 8245ea4:	e0bff717 	ldw	r2,-36(fp)
 8245ea8:	1080018b 	ldhu	r2,6(r2)
 8245eac:	10bfffcc 	andi	r2,r2,65535
 8245eb0:	e0fff60b 	ldhu	r3,-40(fp)
 8245eb4:	1880032e 	bgeu	r3,r2,8245ec4 <ip_setmoptions+0x2c4>
      {
         error = EADDRINUSE;
 8245eb8:	00801c04 	movi	r2,112
 8245ebc:	e0bff515 	stw	r2,-44(fp)
         break;
 8245ec0:	0000a306 	br	8246150 <ip_setmoptions+0x550>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 8245ec4:	e0bff60b 	ldhu	r2,-40(fp)
 8245ec8:	10800518 	cmpnei	r2,r2,20
 8245ecc:	1000031e 	bne	r2,zero,8245edc <ip_setmoptions+0x2dc>
      {
         error = ETOOMANYREFS;
 8245ed0:	00802044 	movi	r2,129
 8245ed4:	e0bff515 	stw	r2,-44(fp)
         break;
 8245ed8:	00009d06 	br	8246150 <ip_setmoptions+0x550>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 8245edc:	e43ff60b 	ldhu	r16,-40(fp)
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
 8245ee0:	e0bffa17 	ldw	r2,-24(fp)
 8245ee4:	e0fffb17 	ldw	r3,-20(fp)
 8245ee8:	01800104 	movi	r6,4
 8245eec:	180b883a 	mov	r5,r3
 8245ef0:	1009883a 	mov	r4,r2
 8245ef4:	82435a40 	call	82435a4 <in_addmulti>
 8245ef8:	1009883a 	mov	r4,r2
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 8245efc:	e0fff717 	ldw	r3,-36(fp)
 8245f00:	80800084 	addi	r2,r16,2
 8245f04:	1085883a 	add	r2,r2,r2
 8245f08:	1085883a 	add	r2,r2,r2
 8245f0c:	1885883a 	add	r2,r3,r2
 8245f10:	11000015 	stw	r4,0(r2)
 8245f14:	e0fff717 	ldw	r3,-36(fp)
 8245f18:	80800084 	addi	r2,r16,2
 8245f1c:	1085883a 	add	r2,r2,r2
 8245f20:	1085883a 	add	r2,r2,r2
 8245f24:	1885883a 	add	r2,r3,r2
 8245f28:	10800017 	ldw	r2,0(r2)
 8245f2c:	1000031e 	bne	r2,zero,8245f3c <ip_setmoptions+0x33c>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 8245f30:	00801a44 	movi	r2,105
 8245f34:	e0bff515 	stw	r2,-44(fp)
         break;
 8245f38:	00008506 	br	8246150 <ip_setmoptions+0x550>
      }
      ++imo->imo_num_memberships;
 8245f3c:	e0bff717 	ldw	r2,-36(fp)
 8245f40:	1080018b 	ldhu	r2,6(r2)
 8245f44:	10800044 	addi	r2,r2,1
 8245f48:	1007883a 	mov	r3,r2
 8245f4c:	e0bff717 	ldw	r2,-36(fp)
 8245f50:	10c0018d 	sth	r3,6(r2)
      break;
 8245f54:	00007e06 	br	8246150 <ip_setmoptions+0x550>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8245f58:	e0bffe17 	ldw	r2,-8(fp)
 8245f5c:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8245f60:	e0bffa17 	ldw	r2,-24(fp)
 8245f64:	10800017 	ldw	r2,0(r2)
 8245f68:	1006d63a 	srli	r3,r2,24
 8245f6c:	e0bffa17 	ldw	r2,-24(fp)
 8245f70:	10800017 	ldw	r2,0(r2)
 8245f74:	1004d23a 	srli	r2,r2,8
 8245f78:	10bfc00c 	andi	r2,r2,65280
 8245f7c:	1886b03a 	or	r3,r3,r2
 8245f80:	e0bffa17 	ldw	r2,-24(fp)
 8245f84:	10800017 	ldw	r2,0(r2)
 8245f88:	10bfc00c 	andi	r2,r2,65280
 8245f8c:	1004923a 	slli	r2,r2,8
 8245f90:	1886b03a 	or	r3,r3,r2
 8245f94:	e0bffa17 	ldw	r2,-24(fp)
 8245f98:	10800017 	ldw	r2,0(r2)
 8245f9c:	1004963a 	slli	r2,r2,24
 8245fa0:	1884b03a 	or	r2,r3,r2
 8245fa4:	10fc002c 	andhi	r3,r2,61440
 8245fa8:	00b80034 	movhi	r2,57344
 8245fac:	18800326 	beq	r3,r2,8245fbc <ip_setmoptions+0x3bc>
      {
         error = EINVAL;
 8245fb0:	00800584 	movi	r2,22
 8245fb4:	e0bff515 	stw	r2,-44(fp)
         break;
 8245fb8:	00006506 	br	8246150 <ip_setmoptions+0x550>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 8245fbc:	e0bffa17 	ldw	r2,-24(fp)
 8245fc0:	10800117 	ldw	r2,4(r2)
 8245fc4:	e0fffb04 	addi	r3,fp,-20
 8245fc8:	180b883a 	mov	r5,r3
 8245fcc:	1009883a 	mov	r4,r2
 8245fd0:	8245acc0 	call	8245acc <IPADDR_TO_NETP>
      if (netp == NULL) 
 8245fd4:	e0bffb17 	ldw	r2,-20(fp)
 8245fd8:	1000031e 	bne	r2,zero,8245fe8 <ip_setmoptions+0x3e8>
      {
         error = EADDRNOTAVAIL;
 8245fdc:	00801f44 	movi	r2,125
 8245fe0:	e0bff515 	stw	r2,-44(fp)
         break;
 8245fe4:	00005a06 	br	8246150 <ip_setmoptions+0x550>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8245fe8:	e03ff60d 	sth	zero,-40(fp)
 8245fec:	00001a06 	br	8246058 <ip_setmoptions+0x458>
      {
         if ((netp == NULL ||
 8245ff0:	e0bffb17 	ldw	r2,-20(fp)
 8245ff4:	10000a26 	beq	r2,zero,8246020 <ip_setmoptions+0x420>
             imo->imo_membership[i]->inm_netp == netp) &&
 8245ff8:	e0bff60b 	ldhu	r2,-40(fp)
 8245ffc:	e0fff717 	ldw	r3,-36(fp)
 8246000:	10800084 	addi	r2,r2,2
 8246004:	1085883a 	add	r2,r2,r2
 8246008:	1085883a 	add	r2,r2,r2
 824600c:	1885883a 	add	r2,r3,r2
 8246010:	10800017 	ldw	r2,0(r2)
 8246014:	10c00117 	ldw	r3,4(r2)
 8246018:	e0bffb17 	ldw	r2,-20(fp)
      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
 824601c:	18800b1e 	bne	r3,r2,824604c <ip_setmoptions+0x44c>
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
 8246020:	e0bff60b 	ldhu	r2,-40(fp)
 8246024:	e0fff717 	ldw	r3,-36(fp)
 8246028:	10800084 	addi	r2,r2,2
 824602c:	1085883a 	add	r2,r2,r2
 8246030:	1085883a 	add	r2,r2,r2
 8246034:	1885883a 	add	r2,r3,r2
 8246038:	10800017 	ldw	r2,0(r2)
 824603c:	10c00017 	ldw	r3,0(r2)
             mreq->imr_multiaddr)
 8246040:	e0bffa17 	ldw	r2,-24(fp)
 8246044:	10800017 	ldw	r2,0(r2)
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
 8246048:	18800926 	beq	r3,r2,8246070 <ip_setmoptions+0x470>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 824604c:	e0bff60b 	ldhu	r2,-40(fp)
 8246050:	10800044 	addi	r2,r2,1
 8246054:	e0bff60d 	sth	r2,-40(fp)
 8246058:	e0bff717 	ldw	r2,-36(fp)
 824605c:	1080018b 	ldhu	r2,6(r2)
 8246060:	10bfffcc 	andi	r2,r2,65535
 8246064:	e0fff60b 	ldhu	r3,-40(fp)
 8246068:	18bfe136 	bltu	r3,r2,8245ff0 <ip_setmoptions+0x3f0>
 824606c:	00000106 	br	8246074 <ip_setmoptions+0x474>
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
             mreq->imr_multiaddr)
         {
            break;
 8246070:	0001883a 	nop
         }
      }
      if (i == imo->imo_num_memberships) 
 8246074:	e0bff717 	ldw	r2,-36(fp)
 8246078:	1080018b 	ldhu	r2,6(r2)
 824607c:	10ffffcc 	andi	r3,r2,65535
 8246080:	e0bff60b 	ldhu	r2,-40(fp)
 8246084:	1880031e 	bne	r3,r2,8246094 <ip_setmoptions+0x494>
      {
         error = EADDRNOTAVAIL;
 8246088:	00801f44 	movi	r2,125
 824608c:	e0bff515 	stw	r2,-44(fp)
         break;
 8246090:	00002f06 	br	8246150 <ip_setmoptions+0x550>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 8246094:	e0bff60b 	ldhu	r2,-40(fp)
 8246098:	e0fff717 	ldw	r3,-36(fp)
 824609c:	10800084 	addi	r2,r2,2
 82460a0:	1085883a 	add	r2,r2,r2
 82460a4:	1085883a 	add	r2,r2,r2
 82460a8:	1885883a 	add	r2,r3,r2
 82460ac:	10800017 	ldw	r2,0(r2)
 82460b0:	1009883a 	mov	r4,r2
 82460b4:	82436f00 	call	82436f0 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 82460b8:	e0bff60b 	ldhu	r2,-40(fp)
 82460bc:	10800044 	addi	r2,r2,1
 82460c0:	e0bff60d 	sth	r2,-40(fp)
 82460c4:	00001206 	br	8246110 <ip_setmoptions+0x510>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 82460c8:	e0bff60b 	ldhu	r2,-40(fp)
 82460cc:	117fffc4 	addi	r5,r2,-1
 82460d0:	e0bff60b 	ldhu	r2,-40(fp)
 82460d4:	e0fff717 	ldw	r3,-36(fp)
 82460d8:	10800084 	addi	r2,r2,2
 82460dc:	1085883a 	add	r2,r2,r2
 82460e0:	1085883a 	add	r2,r2,r2
 82460e4:	1885883a 	add	r2,r3,r2
 82460e8:	10c00017 	ldw	r3,0(r2)
 82460ec:	e13ff717 	ldw	r4,-36(fp)
 82460f0:	28800084 	addi	r2,r5,2
 82460f4:	1085883a 	add	r2,r2,r2
 82460f8:	1085883a 	add	r2,r2,r2
 82460fc:	2085883a 	add	r2,r4,r2
 8246100:	10c00015 	stw	r3,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 8246104:	e0bff60b 	ldhu	r2,-40(fp)
 8246108:	10800044 	addi	r2,r2,1
 824610c:	e0bff60d 	sth	r2,-40(fp)
 8246110:	e0bff717 	ldw	r2,-36(fp)
 8246114:	1080018b 	ldhu	r2,6(r2)
 8246118:	10bfffcc 	andi	r2,r2,65535
 824611c:	e0fff60b 	ldhu	r3,-40(fp)
 8246120:	18bfe936 	bltu	r3,r2,82460c8 <ip_setmoptions+0x4c8>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 8246124:	e0bff717 	ldw	r2,-36(fp)
 8246128:	1080018b 	ldhu	r2,6(r2)
 824612c:	10bfffc4 	addi	r2,r2,-1
 8246130:	1007883a 	mov	r3,r2
 8246134:	e0bff717 	ldw	r2,-36(fp)
 8246138:	10c0018d 	sth	r3,6(r2)
      break;
 824613c:	00000406 	br	8246150 <ip_setmoptions+0x550>

      default:
      error = EOPNOTSUPP;
 8246140:	008017c4 	movi	r2,95
 8246144:	e0bff515 	stw	r2,-44(fp)
      break;
 8246148:	00000106 	br	8246150 <ip_setmoptions+0x550>
         error = EADDRNOTAVAIL;
         break;
      }
      if (addr != AADDR) 
         imo->imo_multicast_netp = netp;
      break;
 824614c:	0001883a 	nop
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 8246150:	e0bff717 	ldw	r2,-36(fp)
 8246154:	10800017 	ldw	r2,0(r2)
 8246158:	1000141e 	bne	r2,zero,82461ac <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 824615c:	e0bff717 	ldw	r2,-36(fp)
 8246160:	10800103 	ldbu	r2,4(r2)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 8246164:	10803fcc 	andi	r2,r2,255
 8246168:	10800058 	cmpnei	r2,r2,1
 824616c:	10000f1e 	bne	r2,zero,82461ac <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246170:	e0bff717 	ldw	r2,-36(fp)
 8246174:	10800143 	ldbu	r2,5(r2)

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246178:	10803fcc 	andi	r2,r2,255
 824617c:	10800058 	cmpnei	r2,r2,1
 8246180:	10000a1e 	bne	r2,zero,82461ac <ip_setmoptions+0x5ac>
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
 8246184:	e0bff717 	ldw	r2,-36(fp)
 8246188:	1080018b 	ldhu	r2,6(r2)
      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 824618c:	10bfffcc 	andi	r2,r2,65535
 8246190:	1000061e 	bne	r2,zero,82461ac <ip_setmoptions+0x5ac>
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 8246194:	e0bff817 	ldw	r2,-32(fp)
 8246198:	10800017 	ldw	r2,0(r2)
 824619c:	1009883a 	mov	r4,r2
 82461a0:	822ddd40 	call	822ddd4 <npfree>
      *imop = NULL;
 82461a4:	e0bff817 	ldw	r2,-32(fp)
 82461a8:	10000015 	stw	zero,0(r2)
   }
   return (error);
 82461ac:	e0bff517 	ldw	r2,-44(fp)
}
 82461b0:	e6ffff04 	addi	sp,fp,-4
 82461b4:	dfc00217 	ldw	ra,8(sp)
 82461b8:	df000117 	ldw	fp,4(sp)
 82461bc:	dc000017 	ldw	r16,0(sp)
 82461c0:	dec00304 	addi	sp,sp,12
 82461c4:	f800283a 	ret

082461c8 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 82461c8:	defff804 	addi	sp,sp,-32
 82461cc:	df000715 	stw	fp,28(sp)
 82461d0:	df000704 	addi	fp,sp,28
 82461d4:	e13ffd15 	stw	r4,-12(fp)
 82461d8:	e17ffe15 	stw	r5,-8(fp)
 82461dc:	e1bfff15 	stw	r6,-4(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 82461e0:	e0bffe17 	ldw	r2,-8(fp)
 82461e4:	10800317 	ldw	r2,12(r2)
 82461e8:	e0bff915 	stw	r2,-28(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 82461ec:	e0bffd17 	ldw	r2,-12(fp)
 82461f0:	10c002a0 	cmpeqi	r3,r2,10
 82461f4:	1800151e 	bne	r3,zero,824624c <ip_getmoptions+0x84>
 82461f8:	10c002e0 	cmpeqi	r3,r2,11
 82461fc:	1800211e 	bne	r3,zero,8246284 <ip_getmoptions+0xbc>
 8246200:	10800260 	cmpeqi	r2,r2,9
 8246204:	10002d26 	beq	r2,zero,82462bc <ip_getmoptions+0xf4>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 8246208:	e0bfff17 	ldw	r2,-4(fp)
 824620c:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 8246210:	e0bff917 	ldw	r2,-28(fp)
 8246214:	10000326 	beq	r2,zero,8246224 <ip_getmoptions+0x5c>
 8246218:	e0bff917 	ldw	r2,-28(fp)
 824621c:	10800017 	ldw	r2,0(r2)
 8246220:	1000031e 	bne	r2,zero,8246230 <ip_getmoptions+0x68>
         *addr = AADDR;
 8246224:	e0bffa17 	ldw	r2,-24(fp)
 8246228:	10000015 	stw	zero,0(r2)
 824622c:	00000506 	br	8246244 <ip_getmoptions+0x7c>
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 8246230:	e0bff917 	ldw	r2,-28(fp)
 8246234:	10800017 	ldw	r2,0(r2)
 8246238:	10c00a17 	ldw	r3,40(r2)
 824623c:	e0bffa17 	ldw	r2,-24(fp)
 8246240:	10c00015 	stw	r3,0(r2)
      return (0);
 8246244:	0005883a 	mov	r2,zero
 8246248:	00001d06 	br	82462c0 <ip_getmoptions+0xf8>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 824624c:	e0bfff17 	ldw	r2,-4(fp)
 8246250:	e0bffb15 	stw	r2,-20(fp)
      if (imo == NULL)
 8246254:	e0bff917 	ldw	r2,-28(fp)
 8246258:	1000041e 	bne	r2,zero,824626c <ip_getmoptions+0xa4>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 824625c:	e0bffb17 	ldw	r2,-20(fp)
 8246260:	00c00044 	movi	r3,1
 8246264:	10c00005 	stb	r3,0(r2)
 8246268:	00000406 	br	824627c <ip_getmoptions+0xb4>
      else
         *ttl = imo->imo_multicast_ttl;
 824626c:	e0bff917 	ldw	r2,-28(fp)
 8246270:	10c00103 	ldbu	r3,4(r2)
 8246274:	e0bffb17 	ldw	r2,-20(fp)
 8246278:	10c00005 	stb	r3,0(r2)
      return (0);
 824627c:	0005883a 	mov	r2,zero
 8246280:	00000f06 	br	82462c0 <ip_getmoptions+0xf8>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 8246284:	e0bfff17 	ldw	r2,-4(fp)
 8246288:	e0bffc15 	stw	r2,-16(fp)
      if (imo == NULL)
 824628c:	e0bff917 	ldw	r2,-28(fp)
 8246290:	1000041e 	bne	r2,zero,82462a4 <ip_getmoptions+0xdc>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 8246294:	e0bffc17 	ldw	r2,-16(fp)
 8246298:	00c00044 	movi	r3,1
 824629c:	10c00005 	stb	r3,0(r2)
 82462a0:	00000406 	br	82462b4 <ip_getmoptions+0xec>
      else
         *loop = imo->imo_multicast_loop;
 82462a4:	e0bff917 	ldw	r2,-28(fp)
 82462a8:	10c00143 	ldbu	r3,5(r2)
 82462ac:	e0bffc17 	ldw	r2,-16(fp)
 82462b0:	10c00005 	stb	r3,0(r2)
      return (0);
 82462b4:	0005883a 	mov	r2,zero
 82462b8:	00000106 	br	82462c0 <ip_getmoptions+0xf8>

      default:
      return (EOPNOTSUPP);
 82462bc:	008017c4 	movi	r2,95
   }
}
 82462c0:	e037883a 	mov	sp,fp
 82462c4:	df000017 	ldw	fp,0(sp)
 82462c8:	dec00104 	addi	sp,sp,4
 82462cc:	f800283a 	ret

082462d0 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 82462d0:	defffc04 	addi	sp,sp,-16
 82462d4:	dfc00315 	stw	ra,12(sp)
 82462d8:	df000215 	stw	fp,8(sp)
 82462dc:	df000204 	addi	fp,sp,8
 82462e0:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 82462e4:	e0bfff17 	ldw	r2,-4(fp)
 82462e8:	10001526 	beq	r2,zero,8246340 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 82462ec:	e03ffe0d 	sth	zero,-8(fp)
 82462f0:	00000c06 	br	8246324 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 82462f4:	e0bffe0b 	ldhu	r2,-8(fp)
 82462f8:	e0ffff17 	ldw	r3,-4(fp)
 82462fc:	10800084 	addi	r2,r2,2
 8246300:	1085883a 	add	r2,r2,r2
 8246304:	1085883a 	add	r2,r2,r2
 8246308:	1885883a 	add	r2,r3,r2
 824630c:	10800017 	ldw	r2,0(r2)
 8246310:	1009883a 	mov	r4,r2
 8246314:	82436f00 	call	82436f0 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 8246318:	e0bffe0b 	ldhu	r2,-8(fp)
 824631c:	10800044 	addi	r2,r2,1
 8246320:	e0bffe0d 	sth	r2,-8(fp)
 8246324:	e0bfff17 	ldw	r2,-4(fp)
 8246328:	1080018b 	ldhu	r2,6(r2)
 824632c:	10bfffcc 	andi	r2,r2,65535
 8246330:	e0fffe0b 	ldhu	r3,-8(fp)
 8246334:	18bfef36 	bltu	r3,r2,82462f4 <ip_freemoptions+0x24>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 8246338:	e13fff17 	ldw	r4,-4(fp)
 824633c:	822ddd40 	call	822ddd4 <npfree>
   }
}
 8246340:	0001883a 	nop
 8246344:	e037883a 	mov	sp,fp
 8246348:	dfc00117 	ldw	ra,4(sp)
 824634c:	df000017 	ldw	fp,0(sp)
 8246350:	dec00204 	addi	sp,sp,8
 8246354:	f800283a 	ret

08246358 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 8246358:	defffe04 	addi	sp,sp,-8
 824635c:	dfc00115 	stw	ra,4(sp)
 8246360:	df000015 	stw	fp,0(sp)
 8246364:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 8246368:	01020974 	movhi	r4,2085
 824636c:	21046704 	addi	r4,r4,4508
 8246370:	82031200 	call	8203120 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 8246374:	0001883a 	nop
 8246378:	e037883a 	mov	sp,fp
 824637c:	dfc00117 	ldw	ra,4(sp)
 8246380:	df000017 	ldw	fp,0(sp)
 8246384:	dec00204 	addi	sp,sp,8
 8246388:	f800283a 	ret

0824638c <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 824638c:	defede04 	addi	sp,sp,-1160
 8246390:	dfc12115 	stw	ra,1156(sp)
 8246394:	df012015 	stw	fp,1152(sp)
 8246398:	df012004 	addi	fp,sp,1152
 824639c:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 82463a0:	009cdcf4 	movhi	r2,29555
 82463a4:	10995344 	addi	r2,r2,25933
 82463a8:	e0bff215 	stw	r2,-56(fp)
 82463ac:	00881974 	movhi	r2,8293
 82463b0:	1099d844 	addi	r2,r2,26465
 82463b4:	e0bff315 	stw	r2,-52(fp)
 82463b8:	00989b74 	movhi	r2,25197
 82463bc:	109d5b84 	addi	r2,r2,30062
 82463c0:	e0bff415 	stw	r2,-48(fp)
 82463c4:	00880eb4 	movhi	r2,8250
 82463c8:	109c9944 	addi	r2,r2,29285
 82463cc:	e0bff515 	stw	r2,-44(fp)
 82463d0:	00880834 	movhi	r2,8224
 82463d4:	10880804 	addi	r2,r2,8224
 82463d8:	e0bff615 	stw	r2,-40(fp)
 82463dc:	00880834 	movhi	r2,8224
 82463e0:	10880804 	addi	r2,r2,8224
 82463e4:	e0bff715 	stw	r2,-36(fp)
 82463e8:	00880834 	movhi	r2,8224
 82463ec:	10880804 	addi	r2,r2,8224
 82463f0:	e0bff815 	stw	r2,-32(fp)
 82463f4:	00800804 	movi	r2,32
 82463f8:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 82463fc:	000d883a 	mov	r6,zero
 8246400:	01400084 	movi	r5,2
 8246404:	01000084 	movi	r4,2
 8246408:	82300640 	call	8230064 <t_socket>
 824640c:	e0bee315 	stw	r2,-1140(fp)

   if (s == INVALID_SOCKET) 
 8246410:	e0bee317 	ldw	r2,-1140(fp)
 8246414:	10bfffd8 	cmpnei	r2,r2,-1
 8246418:	1000091e 	bne	r2,zero,8246440 <u_mctest_run+0xb4>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 824641c:	e13ee317 	ldw	r4,-1140(fp)
 8246420:	82315d00 	call	82315d0 <t_errno>
 8246424:	100d883a 	mov	r6,r2
 8246428:	01420974 	movhi	r5,2085
 824642c:	29446c04 	addi	r5,r5,4528
 8246430:	e13fff17 	ldw	r4,-4(fp)
 8246434:	8228a940 	call	8228a94 <ns_printf>
      exit(1);
 8246438:	01000044 	movi	r4,1
 824643c:	824b1540 	call	824b154 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 8246440:	00800044 	movi	r2,1
 8246444:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 8246448:	e0fffa04 	addi	r3,fp,-24
 824644c:	00800104 	movi	r2,4
 8246450:	d8800015 	stw	r2,0(sp)
 8246454:	180f883a 	mov	r7,r3
 8246458:	01800104 	movi	r6,4
 824645c:	017fffc4 	movi	r5,-1
 8246460:	e13ee317 	ldw	r4,-1140(fp)
 8246464:	8230a440 	call	8230a44 <t_setsockopt>
 8246468:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 824646c:	e0bee417 	ldw	r2,-1136(fp)
 8246470:	10bfffd8 	cmpnei	r2,r2,-1
 8246474:	1000071e 	bne	r2,zero,8246494 <u_mctest_run+0x108>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 8246478:	e13ee317 	ldw	r4,-1140(fp)
 824647c:	82315d00 	call	82315d0 <t_errno>
 8246480:	100d883a 	mov	r6,r2
 8246484:	01420974 	movhi	r5,2085
 8246488:	29447304 	addi	r5,r5,4556
 824648c:	e13fff17 	ldw	r4,-4(fp)
 8246490:	8228a940 	call	8228a94 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 8246494:	00800084 	movi	r2,2
 8246498:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 824649c:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 82464a0:	00a00344 	movi	r2,-32755
 82464a4:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 82464a8:	e0bee604 	addi	r2,fp,-1128
 82464ac:	01800404 	movi	r6,16
 82464b0:	100b883a 	mov	r5,r2
 82464b4:	e13ee317 	ldw	r4,-1140(fp)
 82464b8:	82300e40 	call	82300e4 <t_bind>
 82464bc:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82464c0:	e0bee417 	ldw	r2,-1136(fp)
 82464c4:	10bfffd8 	cmpnei	r2,r2,-1
 82464c8:	1000061e 	bne	r2,zero,82464e4 <u_mctest_run+0x158>
   {
      printf ("t_bind() failed, Err: %d\n",
 82464cc:	e13ee317 	ldw	r4,-1140(fp)
 82464d0:	82315d00 	call	82315d0 <t_errno>
 82464d4:	100b883a 	mov	r5,r2
 82464d8:	01020974 	movhi	r4,2085
 82464dc:	21047f04 	addi	r4,r4,4604
 82464e0:	8202e9c0 	call	8202e9c <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 82464e4:	01820974 	movhi	r6,2085
 82464e8:	31848604 	addi	r6,r6,4632
 82464ec:	01420974 	movhi	r5,2085
 82464f0:	29448904 	addi	r5,r5,4644
 82464f4:	e13fff17 	ldw	r4,-4(fp)
 82464f8:	8228a940 	call	8228a94 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 82464fc:	01020974 	movhi	r4,2085
 8246500:	21048604 	addi	r4,r4,4632
 8246504:	82474680 	call	8247468 <inet_addr>
 8246508:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 824650c:	008209b4 	movhi	r2,2086
 8246510:	10b5f204 	addi	r2,r2,-10296
 8246514:	10800a17 	ldw	r2,40(r2)
 8246518:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 824651c:	e0fffb04 	addi	r3,fp,-20
 8246520:	00800204 	movi	r2,8
 8246524:	d8800015 	stw	r2,0(sp)
 8246528:	180f883a 	mov	r7,r3
 824652c:	01800304 	movi	r6,12
 8246530:	000b883a 	mov	r5,zero
 8246534:	e13ee317 	ldw	r4,-1140(fp)
 8246538:	8230a440 	call	8230a44 <t_setsockopt>
 824653c:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246540:	e0bee417 	ldw	r2,-1136(fp)
 8246544:	10bfffd8 	cmpnei	r2,r2,-1
 8246548:	1000071e 	bne	r2,zero,8246568 <u_mctest_run+0x1dc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 824654c:	e13ee317 	ldw	r4,-1140(fp)
 8246550:	82315d00 	call	82315d0 <t_errno>
 8246554:	100d883a 	mov	r6,r2
 8246558:	01420974 	movhi	r5,2085
 824655c:	29449104 	addi	r5,r5,4676
 8246560:	e13fff17 	ldw	r4,-4(fp)
 8246564:	8228a940 	call	8228a94 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 8246568:	82294400 	call	8229440 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 824656c:	01820974 	movhi	r6,2085
 8246570:	31849e04 	addi	r6,r6,4728
 8246574:	01420974 	movhi	r5,2085
 8246578:	29448904 	addi	r5,r5,4644
 824657c:	e13fff17 	ldw	r4,-4(fp)
 8246580:	8228a940 	call	8228a94 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 8246584:	01020974 	movhi	r4,2085
 8246588:	21049e04 	addi	r4,r4,4728
 824658c:	82474680 	call	8247468 <inet_addr>
 8246590:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246594:	008209b4 	movhi	r2,2086
 8246598:	10b5f204 	addi	r2,r2,-10296
 824659c:	10800a17 	ldw	r2,40(r2)
 82465a0:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 82465a4:	e0fffb04 	addi	r3,fp,-20
 82465a8:	00800204 	movi	r2,8
 82465ac:	d8800015 	stw	r2,0(sp)
 82465b0:	180f883a 	mov	r7,r3
 82465b4:	01800304 	movi	r6,12
 82465b8:	000b883a 	mov	r5,zero
 82465bc:	e13ee317 	ldw	r4,-1140(fp)
 82465c0:	8230a440 	call	8230a44 <t_setsockopt>
 82465c4:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 82465c8:	e0bee417 	ldw	r2,-1136(fp)
 82465cc:	10bfffd8 	cmpnei	r2,r2,-1
 82465d0:	1000071e 	bne	r2,zero,82465f0 <u_mctest_run+0x264>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 82465d4:	e13ee317 	ldw	r4,-1140(fp)
 82465d8:	82315d00 	call	82315d0 <t_errno>
 82465dc:	100d883a 	mov	r6,r2
 82465e0:	01420974 	movhi	r5,2085
 82465e4:	29449104 	addi	r5,r5,4676
 82465e8:	e13fff17 	ldw	r4,-4(fp)
 82465ec:	8228a940 	call	8228a94 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 82465f0:	82294400 	call	8229440 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 82465f4:	01820974 	movhi	r6,2085
 82465f8:	3184a104 	addi	r6,r6,4740
 82465fc:	01420974 	movhi	r5,2085
 8246600:	29448904 	addi	r5,r5,4644
 8246604:	e13fff17 	ldw	r4,-4(fp)
 8246608:	8228a940 	call	8228a94 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 824660c:	01020974 	movhi	r4,2085
 8246610:	2104a104 	addi	r4,r4,4740
 8246614:	82474680 	call	8247468 <inet_addr>
 8246618:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 824661c:	008209b4 	movhi	r2,2086
 8246620:	10b5f204 	addi	r2,r2,-10296
 8246624:	10800a17 	ldw	r2,40(r2)
 8246628:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 824662c:	e0fffb04 	addi	r3,fp,-20
 8246630:	00800204 	movi	r2,8
 8246634:	d8800015 	stw	r2,0(sp)
 8246638:	180f883a 	mov	r7,r3
 824663c:	01800304 	movi	r6,12
 8246640:	000b883a 	mov	r5,zero
 8246644:	e13ee317 	ldw	r4,-1140(fp)
 8246648:	8230a440 	call	8230a44 <t_setsockopt>
 824664c:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246650:	e0bee417 	ldw	r2,-1136(fp)
 8246654:	10bfffd8 	cmpnei	r2,r2,-1
 8246658:	1000071e 	bne	r2,zero,8246678 <u_mctest_run+0x2ec>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 824665c:	e13ee317 	ldw	r4,-1140(fp)
 8246660:	82315d00 	call	82315d0 <t_errno>
 8246664:	100d883a 	mov	r6,r2
 8246668:	01420974 	movhi	r5,2085
 824666c:	29449104 	addi	r5,r5,4676
 8246670:	e13fff17 	ldw	r4,-4(fp)
 8246674:	8228a940 	call	8228a94 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 8246678:	82294400 	call	8229440 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 824667c:	00800084 	movi	r2,2
 8246680:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 8246684:	e0fffd04 	addi	r3,fp,-12
 8246688:	00800044 	movi	r2,1
 824668c:	d8800015 	stw	r2,0(sp)
 8246690:	180f883a 	mov	r7,r3
 8246694:	01800284 	movi	r6,10
 8246698:	000b883a 	mov	r5,zero
 824669c:	e13ee317 	ldw	r4,-1140(fp)
 82466a0:	8230a440 	call	8230a44 <t_setsockopt>
 82466a4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82466a8:	e0bee417 	ldw	r2,-1136(fp)
 82466ac:	10bfffd8 	cmpnei	r2,r2,-1
 82466b0:	1000071e 	bne	r2,zero,82466d0 <u_mctest_run+0x344>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 82466b4:	e13ee317 	ldw	r4,-1140(fp)
 82466b8:	82315d00 	call	82315d0 <t_errno>
 82466bc:	100d883a 	mov	r6,r2
 82466c0:	01420974 	movhi	r5,2085
 82466c4:	2944a404 	addi	r5,r5,4752
 82466c8:	e13fff17 	ldw	r4,-4(fp)
 82466cc:	8228a940 	call	8228a94 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 82466d0:	00800044 	movi	r2,1
 82466d4:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 82466d8:	e0fffd04 	addi	r3,fp,-12
 82466dc:	00800044 	movi	r2,1
 82466e0:	d8800015 	stw	r2,0(sp)
 82466e4:	180f883a 	mov	r7,r3
 82466e8:	018002c4 	movi	r6,11
 82466ec:	000b883a 	mov	r5,zero
 82466f0:	e13ee317 	ldw	r4,-1140(fp)
 82466f4:	8230a440 	call	8230a44 <t_setsockopt>
 82466f8:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82466fc:	e0bee417 	ldw	r2,-1136(fp)
 8246700:	10bfffd8 	cmpnei	r2,r2,-1
 8246704:	1000071e 	bne	r2,zero,8246724 <u_mctest_run+0x398>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 8246708:	e13ee317 	ldw	r4,-1140(fp)
 824670c:	82315d00 	call	82315d0 <t_errno>
 8246710:	100d883a 	mov	r6,r2
 8246714:	01420974 	movhi	r5,2085
 8246718:	2944b104 	addi	r5,r5,4804
 824671c:	e13fff17 	ldw	r4,-4(fp)
 8246720:	8228a940 	call	8228a94 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 8246724:	00800084 	movi	r2,2
 8246728:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 824672c:	01020974 	movhi	r4,2085
 8246730:	21049e04 	addi	r4,r4,4728
 8246734:	82474680 	call	8247468 <inet_addr>
 8246738:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 824673c:	00a00344 	movi	r2,-32755
 8246740:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 8246744:	01820974 	movhi	r6,2085
 8246748:	31849e04 	addi	r6,r6,4728
 824674c:	01420974 	movhi	r5,2085
 8246750:	2944be04 	addi	r5,r5,4856
 8246754:	e13fff17 	ldw	r4,-4(fp)
 8246758:	8228a940 	call	8228a94 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 824675c:	e03ee215 	stw	zero,-1144(fp)
 8246760:	00008606 	br	824697c <u_mctest_run+0x5f0>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 8246764:	d0a05217 	ldw	r2,-32440(gp)
 8246768:	10c00044 	addi	r3,r2,1
 824676c:	d0e05215 	stw	r3,-32440(gp)
 8246770:	e0fff204 	addi	r3,fp,-56
 8246774:	18c00404 	addi	r3,r3,16
 8246778:	100d883a 	mov	r6,r2
 824677c:	01420974 	movhi	r5,2085
 8246780:	2944cd04 	addi	r5,r5,4916
 8246784:	1809883a 	mov	r4,r3
 8246788:	82032140 	call	8203214 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 824678c:	e0fff204 	addi	r3,fp,-56
 8246790:	00800404 	movi	r2,16
 8246794:	d8800115 	stw	r2,4(sp)
 8246798:	e0beea04 	addi	r2,fp,-1112
 824679c:	d8800015 	stw	r2,0(sp)
 82467a0:	000f883a 	mov	r7,zero
 82467a4:	01800784 	movi	r6,30
 82467a8:	180b883a 	mov	r5,r3
 82467ac:	e13ee317 	ldw	r4,-1140(fp)
 82467b0:	8230fb00 	call	8230fb0 <t_sendto>
 82467b4:	e0bee415 	stw	r2,-1136(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 82467b8:	e0bee417 	ldw	r2,-1136(fp)
 82467bc:	1000080e 	bge	r2,zero,82467e0 <u_mctest_run+0x454>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 82467c0:	e13ee317 	ldw	r4,-1140(fp)
 82467c4:	82315d00 	call	82315d0 <t_errno>
 82467c8:	100d883a 	mov	r6,r2
 82467cc:	01420974 	movhi	r5,2085
 82467d0:	2944ce04 	addi	r5,r5,4920
 82467d4:	e13fff17 	ldw	r4,-4(fp)
 82467d8:	8228a940 	call	8228a94 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 82467dc:	00006a06 	br	8246988 <u_mctest_run+0x5fc>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 82467e0:	00800044 	movi	r2,1
 82467e4:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 82467e8:	e0fffa04 	addi	r3,fp,-24
 82467ec:	00800104 	movi	r2,4
 82467f0:	d8800015 	stw	r2,0(sp)
 82467f4:	180f883a 	mov	r7,r3
 82467f8:	01840584 	movi	r6,4118
 82467fc:	017fffc4 	movi	r5,-1
 8246800:	e13ee317 	ldw	r4,-1140(fp)
 8246804:	8230a440 	call	8230a44 <t_setsockopt>
 8246808:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 824680c:	e0bee417 	ldw	r2,-1136(fp)
 8246810:	10bfffd8 	cmpnei	r2,r2,-1
 8246814:	1000071e 	bne	r2,zero,8246834 <u_mctest_run+0x4a8>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 8246818:	e13ee317 	ldw	r4,-1140(fp)
 824681c:	82315d00 	call	82315d0 <t_errno>
 8246820:	100d883a 	mov	r6,r2
 8246824:	01420974 	movhi	r5,2085
 8246828:	2944d604 	addi	r5,r5,4952
 824682c:	e13fff17 	ldw	r4,-4(fp)
 8246830:	8228a940 	call	8228a94 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 8246834:	d0a0a817 	ldw	r2,-32096(gp)
 8246838:	10807d04 	addi	r2,r2,500
 824683c:	e0bee515 	stw	r2,-1132(fp)

      while (cticks < endtime)
 8246840:	00003406 	br	8246914 <u_mctest_run+0x588>
      {
         int sa_size = sizeof(struct sockaddr_in);
 8246844:	00800404 	movi	r2,16
 8246848:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 824684c:	82294400 	call	8229440 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 8246850:	e0fef204 	addi	r3,fp,-1080
 8246854:	e0bffe04 	addi	r2,fp,-8
 8246858:	d8800115 	stw	r2,4(sp)
 824685c:	e0beee04 	addi	r2,fp,-1096
 8246860:	d8800015 	stw	r2,0(sp)
 8246864:	000f883a 	mov	r7,zero
 8246868:	01810004 	movi	r6,1024
 824686c:	180b883a 	mov	r5,r3
 8246870:	e13ee317 	ldw	r4,-1140(fp)
 8246874:	8230e700 	call	8230e70 <t_recvfrom>
 8246878:	e0bee415 	stw	r2,-1136(fp)
         if (iRet < 0) 
 824687c:	e0bee417 	ldw	r2,-1136(fp)
 8246880:	10000c0e 	bge	r2,zero,82468b4 <u_mctest_run+0x528>
         {
            if (t_errno(s) != EWOULDBLOCK)
 8246884:	e13ee317 	ldw	r4,-1140(fp)
 8246888:	82315d00 	call	82315d0 <t_errno>
 824688c:	108002e0 	cmpeqi	r2,r2,11
 8246890:	1000081e 	bne	r2,zero,82468b4 <u_mctest_run+0x528>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 8246894:	e13ee317 	ldw	r4,-1140(fp)
 8246898:	82315d00 	call	82315d0 <t_errno>
 824689c:	100d883a 	mov	r6,r2
 82468a0:	01420974 	movhi	r5,2085
 82468a4:	2944e204 	addi	r5,r5,5000
 82468a8:	e13fff17 	ldw	r4,-4(fp)
 82468ac:	8228a940 	call	8228a94 <ns_printf>
 82468b0:	00003506 	br	8246988 <u_mctest_run+0x5fc>
               /*     exit(1); */
               goto exitloop;
            }
         }
         if (iRet > 0)
 82468b4:	e0bee417 	ldw	r2,-1136(fp)
 82468b8:	0080160e 	bge	zero,r2,8246914 <u_mctest_run+0x588>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 82468bc:	e0beef17 	ldw	r2,-1092(fp)
 82468c0:	1009883a 	mov	r4,r2
 82468c4:	82286280 	call	8228628 <print_ipad>
 82468c8:	1009883a 	mov	r4,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 82468cc:	e0beee8b 	ldhu	r2,-1094(fp)
 82468d0:	10bfffcc 	andi	r2,r2,65535
 82468d4:	1004d23a 	srli	r2,r2,8
 82468d8:	10bfffcc 	andi	r2,r2,65535
 82468dc:	10c03fcc 	andi	r3,r2,255
 82468e0:	e0beee8b 	ldhu	r2,-1094(fp)
 82468e4:	10bfffcc 	andi	r2,r2,65535
 82468e8:	1004923a 	slli	r2,r2,8
 82468ec:	10bfffcc 	andi	r2,r2,65535
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 82468f0:	1886b03a 	or	r3,r3,r2
 82468f4:	e0bef204 	addi	r2,fp,-1080
 82468f8:	d8800015 	stw	r2,0(sp)
 82468fc:	180f883a 	mov	r7,r3
 8246900:	200d883a 	mov	r6,r4
 8246904:	01420974 	movhi	r5,2085
 8246908:	2944ea04 	addi	r5,r5,5032
 824690c:	e13fff17 	ldw	r4,-4(fp)
 8246910:	8228a940 	call	8228a94 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 8246914:	d0e0a817 	ldw	r3,-32096(gp)
 8246918:	e0bee517 	ldw	r2,-1132(fp)
 824691c:	18bfc936 	bltu	r3,r2,8246844 <u_mctest_run+0x4b8>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 8246920:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 8246924:	e0fffd04 	addi	r3,fp,-12
 8246928:	00800044 	movi	r2,1
 824692c:	d8800015 	stw	r2,0(sp)
 8246930:	180f883a 	mov	r7,r3
 8246934:	01840584 	movi	r6,4118
 8246938:	017fffc4 	movi	r5,-1
 824693c:	e13ee317 	ldw	r4,-1140(fp)
 8246940:	8230a440 	call	8230a44 <t_setsockopt>
 8246944:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246948:	e0bee417 	ldw	r2,-1136(fp)
 824694c:	10bfffd8 	cmpnei	r2,r2,-1
 8246950:	1000071e 	bne	r2,zero,8246970 <u_mctest_run+0x5e4>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 8246954:	e13ee317 	ldw	r4,-1140(fp)
 8246958:	82315d00 	call	82315d0 <t_errno>
 824695c:	100d883a 	mov	r6,r2
 8246960:	01420974 	movhi	r5,2085
 8246964:	2944f104 	addi	r5,r5,5060
 8246968:	e13fff17 	ldw	r4,-4(fp)
 824696c:	8228a940 	call	8228a94 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246970:	e0bee217 	ldw	r2,-1144(fp)
 8246974:	10800044 	addi	r2,r2,1
 8246978:	e0bee215 	stw	r2,-1144(fp)
 824697c:	e0bee217 	ldw	r2,-1144(fp)
 8246980:	108000d0 	cmplti	r2,r2,3
 8246984:	103f771e 	bne	r2,zero,8246764 <u_mctest_run+0x3d8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 8246988:	01020974 	movhi	r4,2085
 824698c:	21048604 	addi	r4,r4,4632
 8246990:	82474680 	call	8247468 <inet_addr>
 8246994:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246998:	008209b4 	movhi	r2,2086
 824699c:	10b5f204 	addi	r2,r2,-10296
 82469a0:	10800a17 	ldw	r2,40(r2)
 82469a4:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 82469a8:	e0fffb04 	addi	r3,fp,-20
 82469ac:	00800204 	movi	r2,8
 82469b0:	d8800015 	stw	r2,0(sp)
 82469b4:	180f883a 	mov	r7,r3
 82469b8:	01800344 	movi	r6,13
 82469bc:	000b883a 	mov	r5,zero
 82469c0:	e13ee317 	ldw	r4,-1140(fp)
 82469c4:	8230a440 	call	8230a44 <t_setsockopt>
 82469c8:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82469cc:	e0bee417 	ldw	r2,-1136(fp)
 82469d0:	10bfffd8 	cmpnei	r2,r2,-1
 82469d4:	1000071e 	bne	r2,zero,82469f4 <u_mctest_run+0x668>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 82469d8:	e13ee317 	ldw	r4,-1140(fp)
 82469dc:	82315d00 	call	82315d0 <t_errno>
 82469e0:	100d883a 	mov	r6,r2
 82469e4:	01420974 	movhi	r5,2085
 82469e8:	2944fd04 	addi	r5,r5,5108
 82469ec:	e13fff17 	ldw	r4,-4(fp)
 82469f0:	8228a940 	call	8228a94 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 82469f4:	e13ee317 	ldw	r4,-1140(fp)
 82469f8:	82314800 	call	8231480 <t_socketclose>
 82469fc:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246a00:	e0bee417 	ldw	r2,-1136(fp)
 8246a04:	10bfffd8 	cmpnei	r2,r2,-1
 8246a08:	1000071e 	bne	r2,zero,8246a28 <u_mctest_run+0x69c>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 8246a0c:	e13ee317 	ldw	r4,-1140(fp)
 8246a10:	82315d00 	call	82315d0 <t_errno>
 8246a14:	100d883a 	mov	r6,r2
 8246a18:	01420974 	movhi	r5,2085
 8246a1c:	29450a04 	addi	r5,r5,5160
 8246a20:	e13fff17 	ldw	r4,-4(fp)
 8246a24:	8228a940 	call	8228a94 <ns_printf>
   }

   return(0);
 8246a28:	0005883a 	mov	r2,zero
}  /* end main() */  
 8246a2c:	e037883a 	mov	sp,fp
 8246a30:	dfc00117 	ldw	ra,4(sp)
 8246a34:	df000017 	ldw	fp,0(sp)
 8246a38:	dec00204 	addi	sp,sp,8
 8246a3c:	f800283a 	ret

08246a40 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 8246a40:	defff604 	addi	sp,sp,-40
 8246a44:	dfc00915 	stw	ra,36(sp)
 8246a48:	df000815 	stw	fp,32(sp)
 8246a4c:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 8246a50:	e03ff915 	stw	zero,-28(fp)

   e = dhc_init();
 8246a54:	82297000 	call	8229700 <dhc_init>
 8246a58:	e0bffa15 	stw	r2,-24(fp)

   if (e)
 8246a5c:	e0bffa17 	ldw	r2,-24(fp)
 8246a60:	10000526 	beq	r2,zero,8246a78 <dhc_setup+0x38>
   {
      printf("Error starting DHCP client code.\n");
 8246a64:	01020974 	movhi	r4,2085
 8246a68:	21051304 	addi	r4,r4,5196
 8246a6c:	82031200 	call	8203120 <puts>
      netexit(1);
 8246a70:	01000044 	movi	r4,1
 8246a74:	82438e00 	call	82438e0 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 8246a78:	d0a0a817 	ldw	r2,-32096(gp)
 8246a7c:	e0bffb15 	stw	r2,-20(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246a80:	e03ff815 	stw	zero,-32(fp)
 8246a84:	00005006 	br	8246bc8 <dhc_setup+0x188>
   {
      if (!nets[iface])
 8246a88:	008209b4 	movhi	r2,2086
 8246a8c:	10b6b204 	addi	r2,r2,-9528
 8246a90:	e0fff817 	ldw	r3,-32(fp)
 8246a94:	18c7883a 	add	r3,r3,r3
 8246a98:	18c7883a 	add	r3,r3,r3
 8246a9c:	10c5883a 	add	r2,r2,r3
 8246aa0:	10800017 	ldw	r2,0(r2)
 8246aa4:	10004226 	beq	r2,zero,8246bb0 <dhc_setup+0x170>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 8246aa8:	008209b4 	movhi	r2,2086
 8246aac:	10b6b204 	addi	r2,r2,-9528
 8246ab0:	e0fff817 	ldw	r3,-32(fp)
 8246ab4:	18c7883a 	add	r3,r3,r3
 8246ab8:	18c7883a 	add	r3,r3,r3
 8246abc:	10c5883a 	add	r2,r2,r3
 8246ac0:	10800017 	ldw	r2,0(r2)
 8246ac4:	10802a17 	ldw	r2,168(r2)
 8246ac8:	1080400c 	andi	r2,r2,256
 8246acc:	10003a26 	beq	r2,zero,8246bb8 <dhc_setup+0x178>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 8246ad0:	008209b4 	movhi	r2,2086
 8246ad4:	10b6d804 	addi	r2,r2,-9376
 8246ad8:	e0fff817 	ldw	r3,-32(fp)
 8246adc:	18c00f24 	muli	r3,r3,60
 8246ae0:	10c5883a 	add	r2,r2,r3
 8246ae4:	10800e04 	addi	r2,r2,56
 8246ae8:	10800017 	ldw	r2,0(r2)
 8246aec:	1000041e 	bne	r2,zero,8246b00 <dhc_setup+0xc0>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 8246af0:	01420934 	movhi	r5,2084
 8246af4:	295b2904 	addi	r5,r5,27812
 8246af8:	e13ff817 	ldw	r4,-32(fp)
 8246afc:	82297b00 	call	82297b0 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 8246b00:	008209b4 	movhi	r2,2086
 8246b04:	10b6b204 	addi	r2,r2,-9528
 8246b08:	e0fff817 	ldw	r3,-32(fp)
 8246b0c:	18c7883a 	add	r3,r3,r3
 8246b10:	18c7883a 	add	r3,r3,r3
 8246b14:	10c5883a 	add	r2,r2,r3
 8246b18:	10800017 	ldw	r2,0(r2)
 8246b1c:	10c00a17 	ldw	r3,40(r2)
 8246b20:	e0bff817 	ldw	r2,-32(fp)
 8246b24:	1085883a 	add	r2,r2,r2
 8246b28:	1085883a 	add	r2,r2,r2
 8246b2c:	e13ff804 	addi	r4,fp,-32
 8246b30:	2085883a 	add	r2,r4,r2
 8246b34:	10800404 	addi	r2,r2,16
 8246b38:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 8246b3c:	e0bff817 	ldw	r2,-32(fp)
 8246b40:	1085883a 	add	r2,r2,r2
 8246b44:	1085883a 	add	r2,r2,r2
 8246b48:	e0fff804 	addi	r3,fp,-32
 8246b4c:	1885883a 	add	r2,r3,r2
 8246b50:	10800404 	addi	r2,r2,16
 8246b54:	10800017 	ldw	r2,0(r2)
 8246b58:	1000041e 	bne	r2,zero,8246b6c <dhc_setup+0x12c>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 8246b5c:	01400044 	movi	r5,1
 8246b60:	e13ff817 	ldw	r4,-32(fp)
 8246b64:	822c0cc0 	call	822c0cc <dhc_state_init>
 8246b68:	00000306 	br	8246b78 <dhc_setup+0x138>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 8246b6c:	000b883a 	mov	r5,zero
 8246b70:	e13ff817 	ldw	r4,-32(fp)
 8246b74:	822c0cc0 	call	822c0cc <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 8246b78:	822b9440 	call	822b944 <dhc_second>
 8246b7c:	e0bffa15 	stw	r2,-24(fp)
      if (e)
 8246b80:	e0bffa17 	ldw	r2,-24(fp)
 8246b84:	10000626 	beq	r2,zero,8246ba0 <dhc_setup+0x160>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 8246b88:	e17ff817 	ldw	r5,-32(fp)
 8246b8c:	01020974 	movhi	r4,2085
 8246b90:	21051c04 	addi	r4,r4,5232
 8246b94:	8202e9c0 	call	8202e9c <printf>
         netexit(1);
 8246b98:	01000044 	movi	r4,1
 8246b9c:	82438e00 	call	82438e0 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 8246ba0:	e0bff917 	ldw	r2,-28(fp)
 8246ba4:	10800044 	addi	r2,r2,1
 8246ba8:	e0bff915 	stw	r2,-28(fp)
 8246bac:	00000306 	br	8246bbc <dhc_setup+0x17c>
   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
   {
      if (!nets[iface])
         continue; /* no valid iface for this network */
 8246bb0:	0001883a 	nop
 8246bb4:	00000106 	br	8246bbc <dhc_setup+0x17c>
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
         continue;
 8246bb8:	0001883a 	nop
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246bbc:	e0bff817 	ldw	r2,-32(fp)
 8246bc0:	10800044 	addi	r2,r2,1
 8246bc4:	e0bff815 	stw	r2,-32(fp)
 8246bc8:	e0bff817 	ldw	r2,-32(fp)
 8246bcc:	10800110 	cmplti	r2,r2,4
 8246bd0:	103fad1e 	bne	r2,zero,8246a88 <dhc_setup+0x48>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 8246bd4:	e0bff917 	ldw	r2,-28(fp)
 8246bd8:	10002c26 	beq	r2,zero,8246c8c <dhc_setup+0x24c>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246bdc:	00000206 	br	8246be8 <dhc_setup+0x1a8>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 8246be0:	82294400 	call	8229440 <tk_yield>
      pktdemux();
 8246be4:	8225ef80 	call	8225ef8 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246be8:	d0e0a817 	ldw	r3,-32096(gp)
 8246bec:	e0bffb17 	ldw	r2,-20(fp)
 8246bf0:	1885c83a 	sub	r2,r3,r2
 8246bf4:	108cb228 	cmpgeui	r2,r2,13000
 8246bf8:	1000021e 	bne	r2,zero,8246c04 <dhc_setup+0x1c4>
      (dhc_alldone() == FALSE))
 8246bfc:	822c1240 	call	822c124 <dhc_alldone>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246c00:	103ff726 	beq	r2,zero,8246be0 <dhc_setup+0x1a0>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 8246c04:	822c1240 	call	822c124 <dhc_alldone>
 8246c08:	1000211e 	bne	r2,zero,8246c90 <dhc_setup+0x250>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 8246c0c:	01020974 	movhi	r4,2085
 8246c10:	21052604 	addi	r4,r4,5272
 8246c14:	82031200 	call	8203120 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246c18:	e03ff815 	stw	zero,-32(fp)
 8246c1c:	00001706 	br	8246c7c <dhc_setup+0x23c>
      {
         if (dhc_ifacedone(iface) == FALSE)
 8246c20:	e13ff817 	ldw	r4,-32(fp)
 8246c24:	822c1ac0 	call	822c1ac <dhc_ifacedone>
 8246c28:	1000111e 	bne	r2,zero,8246c70 <dhc_setup+0x230>
         {
            dhc_halt(iface);
 8246c2c:	e13ff817 	ldw	r4,-32(fp)
 8246c30:	822be940 	call	822be94 <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 8246c34:	008209b4 	movhi	r2,2086
 8246c38:	10b6b204 	addi	r2,r2,-9528
 8246c3c:	e0fff817 	ldw	r3,-32(fp)
 8246c40:	18c7883a 	add	r3,r3,r3
 8246c44:	18c7883a 	add	r3,r3,r3
 8246c48:	10c5883a 	add	r2,r2,r3
 8246c4c:	10c00017 	ldw	r3,0(r2)
 8246c50:	e0bff817 	ldw	r2,-32(fp)
 8246c54:	1085883a 	add	r2,r2,r2
 8246c58:	1085883a 	add	r2,r2,r2
 8246c5c:	e13ff804 	addi	r4,fp,-32
 8246c60:	2085883a 	add	r2,r4,r2
 8246c64:	10800404 	addi	r2,r2,16
 8246c68:	10800017 	ldw	r2,0(r2)
 8246c6c:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246c70:	e0bff817 	ldw	r2,-32(fp)
 8246c74:	10800044 	addi	r2,r2,1
 8246c78:	e0bff815 	stw	r2,-32(fp)
 8246c7c:	e0bff817 	ldw	r2,-32(fp)
 8246c80:	10800110 	cmplti	r2,r2,4
 8246c84:	103fe61e 	bne	r2,zero,8246c20 <dhc_setup+0x1e0>
 8246c88:	00000106 	br	8246c90 <dhc_setup+0x250>
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
      return;
 8246c8c:	0001883a 	nop
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 8246c90:	e037883a 	mov	sp,fp
 8246c94:	dfc00117 	ldw	ra,4(sp)
 8246c98:	df000017 	ldw	fp,0(sp)
 8246c9c:	dec00204 	addi	sp,sp,8
 8246ca0:	f800283a 	ret

08246ca4 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 8246ca4:	defffc04 	addi	sp,sp,-16
 8246ca8:	dfc00315 	stw	ra,12(sp)
 8246cac:	df000215 	stw	fp,8(sp)
 8246cb0:	df000204 	addi	fp,sp,8
 8246cb4:	e13ffe15 	stw	r4,-8(fp)
 8246cb8:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 8246cbc:	e0bfff17 	ldw	r2,-4(fp)
 8246cc0:	10800198 	cmpnei	r2,r2,6
 8246cc4:	1000361e 	bne	r2,zero,8246da0 <dhc_main_ipset+0xfc>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
              nets[iface]->name);
 8246cc8:	008209b4 	movhi	r2,2086
 8246ccc:	10b6b204 	addi	r2,r2,-9528
 8246cd0:	e0fffe17 	ldw	r3,-8(fp)
 8246cd4:	18c7883a 	add	r3,r3,r3
 8246cd8:	18c7883a 	add	r3,r3,r3
 8246cdc:	10c5883a 	add	r2,r2,r3
 8246ce0:	10800017 	ldw	r2,0(r2)
 8246ce4:	10800104 	addi	r2,r2,4
dhc_main_ipset(int iface, int state)
{
   if ( state == DHCS_BOUND )
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 8246ce8:	100b883a 	mov	r5,r2
 8246cec:	01020974 	movhi	r4,2085
 8246cf0:	21053404 	addi	r4,r4,5328
 8246cf4:	8202e9c0 	call	8202e9c <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 8246cf8:	008209b4 	movhi	r2,2086
 8246cfc:	10b6b204 	addi	r2,r2,-9528
 8246d00:	e0fffe17 	ldw	r3,-8(fp)
 8246d04:	18c7883a 	add	r3,r3,r3
 8246d08:	18c7883a 	add	r3,r3,r3
 8246d0c:	10c5883a 	add	r2,r2,r3
 8246d10:	10800017 	ldw	r2,0(r2)
 8246d14:	10800a17 	ldw	r2,40(r2)
 8246d18:	1009883a 	mov	r4,r2
 8246d1c:	82286280 	call	8228628 <print_ipad>
 8246d20:	100b883a 	mov	r5,r2
 8246d24:	01020974 	movhi	r4,2085
 8246d28:	21054204 	addi	r4,r4,5384
 8246d2c:	8202e9c0 	call	8202e9c <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 8246d30:	008209b4 	movhi	r2,2086
 8246d34:	10b6b204 	addi	r2,r2,-9528
 8246d38:	e0fffe17 	ldw	r3,-8(fp)
 8246d3c:	18c7883a 	add	r3,r3,r3
 8246d40:	18c7883a 	add	r3,r3,r3
 8246d44:	10c5883a 	add	r2,r2,r3
 8246d48:	10800017 	ldw	r2,0(r2)
 8246d4c:	10800c17 	ldw	r2,48(r2)
 8246d50:	1009883a 	mov	r4,r2
 8246d54:	82286280 	call	8228628 <print_ipad>
 8246d58:	100b883a 	mov	r5,r2
 8246d5c:	01020974 	movhi	r4,2085
 8246d60:	21054704 	addi	r4,r4,5404
 8246d64:	8202e9c0 	call	8202e9c <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 8246d68:	008209b4 	movhi	r2,2086
 8246d6c:	10b6b204 	addi	r2,r2,-9528
 8246d70:	e0fffe17 	ldw	r3,-8(fp)
 8246d74:	18c7883a 	add	r3,r3,r3
 8246d78:	18c7883a 	add	r3,r3,r3
 8246d7c:	10c5883a 	add	r2,r2,r3
 8246d80:	10800017 	ldw	r2,0(r2)
 8246d84:	10800d17 	ldw	r2,52(r2)
 8246d88:	1009883a 	mov	r4,r2
 8246d8c:	82286280 	call	8228628 <print_ipad>
 8246d90:	100b883a 	mov	r5,r2
 8246d94:	01020974 	movhi	r4,2085
 8246d98:	21054c04 	addi	r4,r4,5424
 8246d9c:	8202e9c0 	call	8202e9c <printf>
   }
   return 0;
 8246da0:	0005883a 	mov	r2,zero
}
 8246da4:	e037883a 	mov	sp,fp
 8246da8:	dfc00117 	ldw	ra,4(sp)
 8246dac:	df000017 	ldw	fp,0(sp)
 8246db0:	dec00204 	addi	sp,sp,8
 8246db4:	f800283a 	ret

08246db8 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 8246db8:	deffff04 	addi	sp,sp,-4
 8246dbc:	df000015 	stw	fp,0(sp)
 8246dc0:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 8246dc4:	d0e0d417 	ldw	r3,-31920(gp)
 8246dc8:	00820974 	movhi	r2,2085
 8246dcc:	108dd304 	addi	r2,r2,14156
 8246dd0:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 8246dd4:	00820974 	movhi	r2,2085
 8246dd8:	108dd304 	addi	r2,r2,14156
 8246ddc:	d0a0d415 	stw	r2,-31920(gp)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 8246de0:	d0e0d617 	ldw	r3,-31912(gp)
 8246de4:	00820974 	movhi	r2,2085
 8246de8:	108ddc04 	addi	r2,r2,14192
 8246dec:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 8246df0:	00820974 	movhi	r2,2085
 8246df4:	108dfd04 	addi	r2,r2,14324
 8246df8:	d0a0d615 	stw	r2,-31912(gp)

   return 0;
 8246dfc:	0005883a 	mov	r2,zero
}
 8246e00:	e037883a 	mov	sp,fp
 8246e04:	df000017 	ldw	fp,0(sp)
 8246e08:	dec00104 	addi	sp,sp,4
 8246e0c:	f800283a 	ret

08246e10 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 8246e10:	defffd04 	addi	sp,sp,-12
 8246e14:	df000215 	stw	fp,8(sp)
 8246e18:	df000204 	addi	fp,sp,8
 8246e1c:	e13ffe15 	stw	r4,-8(fp)
 8246e20:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 8246e24:	0005883a 	mov	r2,zero
}
 8246e28:	e037883a 	mov	sp,fp
 8246e2c:	df000017 	ldw	fp,0(sp)
 8246e30:	dec00104 	addi	sp,sp,4
 8246e34:	f800283a 	ret

08246e38 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 8246e38:	defffe04 	addi	sp,sp,-8
 8246e3c:	df000115 	stw	fp,4(sp)
 8246e40:	df000104 	addi	fp,sp,4
 8246e44:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 8246e48:	0001883a 	nop
 8246e4c:	e037883a 	mov	sp,fp
 8246e50:	df000017 	ldw	fp,0(sp)
 8246e54:	dec00104 	addi	sp,sp,4
 8246e58:	f800283a 	ret

08246e5c <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8246e5c:	defff704 	addi	sp,sp,-36
 8246e60:	dfc00815 	stw	ra,32(sp)
 8246e64:	df000715 	stw	fp,28(sp)
 8246e68:	df000704 	addi	fp,sp,28
 8246e6c:	e13ffc15 	stw	r4,-16(fp)
 8246e70:	e17ffd15 	stw	r5,-12(fp)
 8246e74:	e1bffe15 	stw	r6,-8(fp)
 8246e78:	e1ffff15 	stw	r7,-4(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 8246e7c:	00800834 	movhi	r2,32
 8246e80:	e0bffa15 	stw	r2,-24(fp)
   if(vfd && vfd->file)
 8246e84:	e0bfff17 	ldw	r2,-4(fp)
 8246e88:	10000726 	beq	r2,zero,8246ea8 <md_fread+0x4c>
 8246e8c:	e0bfff17 	ldw	r2,-4(fp)
 8246e90:	10800117 	ldw	r2,4(r2)
 8246e94:	10000426 	beq	r2,zero,8246ea8 <md_fread+0x4c>
   {
      file_size = vfd->file->real_size; 
 8246e98:	e0bfff17 	ldw	r2,-4(fp)
 8246e9c:	10800117 	ldw	r2,4(r2)
 8246ea0:	10800717 	ldw	r2,28(r2)
 8246ea4:	e0bffa15 	stw	r2,-24(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 8246ea8:	e0bfff17 	ldw	r2,-4(fp)
 8246eac:	10800217 	ldw	r2,8(r2)
 8246eb0:	1007883a 	mov	r3,r2
 8246eb4:	e0bfff17 	ldw	r2,-4(fp)
 8246eb8:	10800117 	ldw	r2,4(r2)
 8246ebc:	10800617 	ldw	r2,24(r2)
 8246ec0:	1885c83a 	sub	r2,r3,r2
 8246ec4:	e0bffb15 	stw	r2,-20(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 8246ec8:	e0fffe17 	ldw	r3,-8(fp)
 8246ecc:	e0bffd17 	ldw	r2,-12(fp)
 8246ed0:	1885383a 	mul	r2,r3,r2
 8246ed4:	e0bff915 	stw	r2,-28(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 8246ed8:	e0fffb17 	ldw	r3,-20(fp)
 8246edc:	e0bff917 	ldw	r2,-28(fp)
 8246ee0:	1885883a 	add	r2,r3,r2
 8246ee4:	e0fffa17 	ldw	r3,-24(fp)
 8246ee8:	1880042e 	bgeu	r3,r2,8246efc <md_fread+0xa0>
      bcount = ((u_long)file_size - location);
 8246eec:	e0fffa17 	ldw	r3,-24(fp)
 8246ef0:	e0bffb17 	ldw	r2,-20(fp)
 8246ef4:	1885c83a 	sub	r2,r3,r2
 8246ef8:	e0bff915 	stw	r2,-28(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 8246efc:	e0fffb17 	ldw	r3,-20(fp)
 8246f00:	e0bffa17 	ldw	r2,-24(fp)
 8246f04:	1880052e 	bgeu	r3,r2,8246f1c <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 8246f08:	e0bff917 	ldw	r2,-28(fp)
 8246f0c:	10bfffec 	andhi	r2,r2,65535
   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
      bcount = ((u_long)file_size - location);

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 8246f10:	1000021e 	bne	r2,zero,8246f1c <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 8246f14:	e0bff917 	ldw	r2,-28(fp)
 8246f18:	1000021e 	bne	r2,zero,8246f24 <md_fread+0xc8>
      (bcount == 0))
   {
      return 0;
 8246f1c:	0005883a 	mov	r2,zero
 8246f20:	00002006 	br	8246fa4 <md_fread+0x148>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 8246f24:	e0bfff17 	ldw	r2,-4(fp)
 8246f28:	10800117 	ldw	r2,4(r2)
 8246f2c:	1080058b 	ldhu	r2,22(r2)
 8246f30:	10bfffcc 	andi	r2,r2,65535
 8246f34:	10a0001c 	xori	r2,r2,32768
 8246f38:	10a00004 	addi	r2,r2,-32768
 8246f3c:	10001016 	blt	r2,zero,8246f80 <md_fread+0x124>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 8246f40:	e0bfff17 	ldw	r2,-4(fp)
 8246f44:	10800117 	ldw	r2,4(r2)
 8246f48:	10800103 	ldbu	r2,4(r2)
 8246f4c:	10803fcc 	andi	r2,r2,255
 8246f50:	1080201c 	xori	r2,r2,128
 8246f54:	10bfe004 	addi	r2,r2,-128
 8246f58:	10801b58 	cmpnei	r2,r2,109
 8246f5c:	1000081e 	bne	r2,zero,8246f80 <md_fread+0x124>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 8246f60:	e0bfff17 	ldw	r2,-4(fp)
 8246f64:	10c00217 	ldw	r3,8(r2)
 8246f68:	00800834 	movhi	r2,32
 8246f6c:	1885883a 	add	r2,r3,r2
 8246f70:	e1bff917 	ldw	r6,-28(fp)
 8246f74:	100b883a 	mov	r5,r2
 8246f78:	e13ffc17 	ldw	r4,-16(fp)
 8246f7c:	8202a0c0 	call	8202a0c <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 8246f80:	e0bfff17 	ldw	r2,-4(fp)
 8246f84:	10c00217 	ldw	r3,8(r2)
 8246f88:	e0bff917 	ldw	r2,-28(fp)
 8246f8c:	1887883a 	add	r3,r3,r2
 8246f90:	e0bfff17 	ldw	r2,-4(fp)
 8246f94:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 8246f98:	e17ffd17 	ldw	r5,-12(fp)
 8246f9c:	e13ff917 	ldw	r4,-28(fp)
 8246fa0:	820270c0 	call	820270c <__udivsi3>
}
 8246fa4:	e037883a 	mov	sp,fp
 8246fa8:	dfc00117 	ldw	ra,4(sp)
 8246fac:	df000017 	ldw	fp,0(sp)
 8246fb0:	dec00204 	addi	sp,sp,8
 8246fb4:	f800283a 	ret

08246fb8 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8246fb8:	defffb04 	addi	sp,sp,-20
 8246fbc:	df000415 	stw	fp,16(sp)
 8246fc0:	df000404 	addi	fp,sp,16
 8246fc4:	e13ffc15 	stw	r4,-16(fp)
 8246fc8:	e17ffd15 	stw	r5,-12(fp)
 8246fcc:	e1bffe15 	stw	r6,-8(fp)
 8246fd0:	e1ffff15 	stw	r7,-4(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 8246fd4:	e0bfff17 	ldw	r2,-4(fp)
 8246fd8:	10800117 	ldw	r2,4(r2)
 8246fdc:	10800103 	ldbu	r2,4(r2)
 8246fe0:	10803fcc 	andi	r2,r2,255
 8246fe4:	1080201c 	xori	r2,r2,128
 8246fe8:	10bfe004 	addi	r2,r2,-128
 8246fec:	10801b58 	cmpnei	r2,r2,109
 8246ff0:	1000021e 	bne	r2,zero,8246ffc <md_fwrite+0x44>
      return 0;   /* not writable device */
 8246ff4:	0005883a 	mov	r2,zero
 8246ff8:	00000906 	br	8247020 <md_fwrite+0x68>

   vfd->cmploc += (items * size);   /* adjust location */
 8246ffc:	e0bfff17 	ldw	r2,-4(fp)
 8247000:	10c00217 	ldw	r3,8(r2)
 8247004:	e13ffe17 	ldw	r4,-8(fp)
 8247008:	e0bffd17 	ldw	r2,-12(fp)
 824700c:	2085383a 	mul	r2,r4,r2
 8247010:	1887883a 	add	r3,r3,r2
 8247014:	e0bfff17 	ldw	r2,-4(fp)
 8247018:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 824701c:	e0bffe17 	ldw	r2,-8(fp)
}
 8247020:	e037883a 	mov	sp,fp
 8247024:	df000017 	ldw	fp,0(sp)
 8247028:	dec00104 	addi	sp,sp,4
 824702c:	f800283a 	ret

08247030 <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 8247030:	defffc04 	addi	sp,sp,-16
 8247034:	df000315 	stw	fp,12(sp)
 8247038:	df000304 	addi	fp,sp,12
 824703c:	e13ffd15 	stw	r4,-12(fp)
 8247040:	e17ffe15 	stw	r5,-8(fp)
 8247044:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 8247048:	0005883a 	mov	r2,zero
}
 824704c:	e037883a 	mov	sp,fp
 8247050:	df000017 	ldw	fp,0(sp)
 8247054:	dec00104 	addi	sp,sp,4
 8247058:	f800283a 	ret

0824705c <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 824705c:	defffe04 	addi	sp,sp,-8
 8247060:	df000115 	stw	fp,4(sp)
 8247064:	df000104 	addi	fp,sp,4
 8247068:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 824706c:	00800834 	movhi	r2,32
}
 8247070:	e037883a 	mov	sp,fp
 8247074:	df000017 	ldw	fp,0(sp)
 8247078:	dec00104 	addi	sp,sp,4
 824707c:	f800283a 	ret

08247080 <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 8247080:	defffc04 	addi	sp,sp,-16
 8247084:	df000315 	stw	fp,12(sp)
 8247088:	df000304 	addi	fp,sp,12
 824708c:	e13fff15 	stw	r4,-4(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 8247090:	e03ffd15 	stw	zero,-12(fp)

   location = vfd->cmploc - vfd->file->data;
 8247094:	e0bfff17 	ldw	r2,-4(fp)
 8247098:	10800217 	ldw	r2,8(r2)
 824709c:	1007883a 	mov	r3,r2
 82470a0:	e0bfff17 	ldw	r2,-4(fp)
 82470a4:	10800117 	ldw	r2,4(r2)
 82470a8:	10800617 	ldw	r2,24(r2)
 82470ac:	1885c83a 	sub	r2,r3,r2
 82470b0:	e0bffe15 	stw	r2,-8(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 82470b4:	e0bfff17 	ldw	r2,-4(fp)
 82470b8:	10800117 	ldw	r2,4(r2)
 82470bc:	10800717 	ldw	r2,28(r2)
 82470c0:	e0fffe17 	ldw	r3,-8(fp)
 82470c4:	18800236 	bltu	r3,r2,82470d0 <md_fgetc+0x50>
      return EOF;
 82470c8:	00bfffc4 	movi	r2,-1
 82470cc:	00001a06 	br	8247138 <md_fgetc+0xb8>

   if (!(vfd->file->flags & VF_NODATA))
 82470d0:	e0bfff17 	ldw	r2,-4(fp)
 82470d4:	10800117 	ldw	r2,4(r2)
 82470d8:	1080058b 	ldhu	r2,22(r2)
 82470dc:	10bfffcc 	andi	r2,r2,65535
 82470e0:	10a0001c 	xori	r2,r2,32768
 82470e4:	10a00004 	addi	r2,r2,-32768
 82470e8:	10000d16 	blt	r2,zero,8247120 <md_fgetc+0xa0>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 82470ec:	e0bfff17 	ldw	r2,-4(fp)
 82470f0:	10800117 	ldw	r2,4(r2)
 82470f4:	10800103 	ldbu	r2,4(r2)
 82470f8:	10803fcc 	andi	r2,r2,255
 82470fc:	1080201c 	xori	r2,r2,128
 8247100:	10bfe004 	addi	r2,r2,-128
 8247104:	10801b58 	cmpnei	r2,r2,109
 8247108:	1000051e 	bne	r2,zero,8247120 <md_fgetc+0xa0>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 824710c:	e0bfff17 	ldw	r2,-4(fp)
 8247110:	10800217 	ldw	r2,8(r2)
 8247114:	10800003 	ldbu	r2,0(r2)
 8247118:	10803fcc 	andi	r2,r2,255
 824711c:	e0bffd15 	stw	r2,-12(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 8247120:	e0bfff17 	ldw	r2,-4(fp)
 8247124:	10800217 	ldw	r2,8(r2)
 8247128:	10c00044 	addi	r3,r2,1
 824712c:	e0bfff17 	ldw	r2,-4(fp)
 8247130:	10c00215 	stw	r3,8(r2)
   return retval;
 8247134:	e0bffd17 	ldw	r2,-12(fp)
}
 8247138:	e037883a 	mov	sp,fp
 824713c:	df000017 	ldw	fp,0(sp)
 8247140:	dec00104 	addi	sp,sp,4
 8247144:	f800283a 	ret

08247148 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 8247148:	defffe04 	addi	sp,sp,-8
 824714c:	df000115 	stw	fp,4(sp)
 8247150:	df000104 	addi	fp,sp,4
 8247154:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 8247158:	0005883a 	mov	r2,zero
}
 824715c:	e037883a 	mov	sp,fp
 8247160:	df000017 	ldw	fp,0(sp)
 8247164:	dec00104 	addi	sp,sp,4
 8247168:	f800283a 	ret

0824716c <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 824716c:	defff604 	addi	sp,sp,-40
 8247170:	dfc00915 	stw	ra,36(sp)
 8247174:	df000815 	stw	fp,32(sp)
 8247178:	df000804 	addi	fp,sp,32
 824717c:	e13ffd15 	stw	r4,-12(fp)
 8247180:	e17ffe15 	stw	r5,-8(fp)
 8247184:	e1bfff15 	stw	r6,-4(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 8247188:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 824718c:	00820974 	movhi	r2,2085
 8247190:	10855104 	addi	r2,r2,5444
 8247194:	e0bffa15 	stw	r2,-24(fp)

   cp = stringin;
 8247198:	e0bfff17 	ldw	r2,-4(fp)
 824719c:	e0bff815 	stw	r2,-32(fp)
   while (*cp)
 82471a0:	00002506 	br	8247238 <parse_ipad+0xcc>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 82471a4:	e0bff817 	ldw	r2,-32(fp)
 82471a8:	10800003 	ldbu	r2,0(r2)
 82471ac:	10803fcc 	andi	r2,r2,255
 82471b0:	1080201c 	xori	r2,r2,128
 82471b4:	10bfe004 	addi	r2,r2,-128
 82471b8:	10800e88 	cmpgei	r2,r2,58
 82471bc:	10000e1e 	bne	r2,zero,82471f8 <parse_ipad+0x8c>
 82471c0:	e0bff817 	ldw	r2,-32(fp)
 82471c4:	10800003 	ldbu	r2,0(r2)
 82471c8:	10803fcc 	andi	r2,r2,255
 82471cc:	1080201c 	xori	r2,r2,128
 82471d0:	10bfe004 	addi	r2,r2,-128
 82471d4:	10800b90 	cmplti	r2,r2,46
 82471d8:	1000071e 	bne	r2,zero,82471f8 <parse_ipad+0x8c>
 82471dc:	e0bff817 	ldw	r2,-32(fp)
 82471e0:	10800003 	ldbu	r2,0(r2)
 82471e4:	10803fcc 	andi	r2,r2,255
 82471e8:	1080201c 	xori	r2,r2,128
 82471ec:	10bfe004 	addi	r2,r2,-128
 82471f0:	10800bd8 	cmpnei	r2,r2,47
 82471f4:	1000031e 	bne	r2,zero,8247204 <parse_ipad+0x98>
         return("all chars must be digits (0-9) or dots (.)");
 82471f8:	00820974 	movhi	r2,2085
 82471fc:	10855a04 	addi	r2,r2,5480
 8247200:	00009406 	br	8247454 <parse_ipad+0x2e8>
      if (*cp == '.')dots++;
 8247204:	e0bff817 	ldw	r2,-32(fp)
 8247208:	10800003 	ldbu	r2,0(r2)
 824720c:	10803fcc 	andi	r2,r2,255
 8247210:	1080201c 	xori	r2,r2,128
 8247214:	10bfe004 	addi	r2,r2,-128
 8247218:	10800b98 	cmpnei	r2,r2,46
 824721c:	1000031e 	bne	r2,zero,824722c <parse_ipad+0xc0>
 8247220:	e0bff917 	ldw	r2,-28(fp)
 8247224:	10800044 	addi	r2,r2,1
 8247228:	e0bff915 	stw	r2,-28(fp)
         cp++;
 824722c:	e0bff817 	ldw	r2,-32(fp)
 8247230:	10800044 	addi	r2,r2,1
 8247234:	e0bff815 	stw	r2,-32(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 8247238:	e0bff817 	ldw	r2,-32(fp)
 824723c:	10800003 	ldbu	r2,0(r2)
 8247240:	10803fcc 	andi	r2,r2,255
 8247244:	1080201c 	xori	r2,r2,128
 8247248:	10bfe004 	addi	r2,r2,-128
 824724c:	103fd51e 	bne	r2,zero,82471a4 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 8247250:	e0bff917 	ldw	r2,-28(fp)
 8247254:	0080030e 	bge	zero,r2,8247264 <parse_ipad+0xf8>
 8247258:	e0bff917 	ldw	r2,-28(fp)
 824725c:	10800110 	cmplti	r2,r2,4
 8247260:	1000031e 	bne	r2,zero,8247270 <parse_ipad+0x104>
      return("string must contain 1 - 3 dots (.)");
 8247264:	00820974 	movhi	r2,2085
 8247268:	10856504 	addi	r2,r2,5524
 824726c:	00007906 	br	8247454 <parse_ipad+0x2e8>

   cp = stringin;
 8247270:	e0bfff17 	ldw	r2,-4(fp)
 8247274:	e0bff815 	stw	r2,-32(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 8247278:	e13ff817 	ldw	r4,-32(fp)
 824727c:	824b13c0 	call	824b13c <atoi>
 8247280:	e0bffb15 	stw	r2,-20(fp)
 8247284:	e0bffb17 	ldw	r2,-20(fp)
 8247288:	10804010 	cmplti	r2,r2,256
 824728c:	1000021e 	bne	r2,zero,8247298 <parse_ipad+0x12c>
      return(toobig);
 8247290:	e0bffa17 	ldw	r2,-24(fp)
 8247294:	00006f06 	br	8247454 <parse_ipad+0x2e8>

   retval.c[0] = (u_char)number;
 8247298:	e0bffb17 	ldw	r2,-20(fp)
 824729c:	e0bffc05 	stb	r2,-16(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 82472a0:	00000306 	br	82472b0 <parse_ipad+0x144>
 82472a4:	e0bff817 	ldw	r2,-32(fp)
 82472a8:	10800044 	addi	r2,r2,1
 82472ac:	e0bff815 	stw	r2,-32(fp)
 82472b0:	e0bff817 	ldw	r2,-32(fp)
 82472b4:	10800003 	ldbu	r2,0(r2)
 82472b8:	10803fcc 	andi	r2,r2,255
 82472bc:	1080201c 	xori	r2,r2,128
 82472c0:	10bfe004 	addi	r2,r2,-128
 82472c4:	10800b98 	cmpnei	r2,r2,46
 82472c8:	103ff61e 	bne	r2,zero,82472a4 <parse_ipad+0x138>
      cp++;             /* point past dot */
 82472cc:	e0bff817 	ldw	r2,-32(fp)
 82472d0:	10800044 	addi	r2,r2,1
 82472d4:	e0bff815 	stw	r2,-32(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 82472d8:	e0bff917 	ldw	r2,-28(fp)
 82472dc:	10800060 	cmpeqi	r2,r2,1
 82472e0:	1000031e 	bne	r2,zero,82472f0 <parse_ipad+0x184>
 82472e4:	e0bff917 	ldw	r2,-28(fp)
 82472e8:	10800098 	cmpnei	r2,r2,2
 82472ec:	1000021e 	bne	r2,zero,82472f8 <parse_ipad+0x18c>
 82472f0:	e03ffc45 	stb	zero,-15(fp)
 82472f4:	00001806 	br	8247358 <parse_ipad+0x1ec>
      else
   {
      number = atoi(cp);
 82472f8:	e13ff817 	ldw	r4,-32(fp)
 82472fc:	824b13c0 	call	824b13c <atoi>
 8247300:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247304:	00000306 	br	8247314 <parse_ipad+0x1a8>
 8247308:	e0bff817 	ldw	r2,-32(fp)
 824730c:	10800044 	addi	r2,r2,1
 8247310:	e0bff815 	stw	r2,-32(fp)
 8247314:	e0bff817 	ldw	r2,-32(fp)
 8247318:	10800003 	ldbu	r2,0(r2)
 824731c:	10803fcc 	andi	r2,r2,255
 8247320:	1080201c 	xori	r2,r2,128
 8247324:	10bfe004 	addi	r2,r2,-128
 8247328:	10800b98 	cmpnei	r2,r2,46
 824732c:	103ff61e 	bne	r2,zero,8247308 <parse_ipad+0x19c>
         cp++;             /* point past dot */
 8247330:	e0bff817 	ldw	r2,-32(fp)
 8247334:	10800044 	addi	r2,r2,1
 8247338:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 824733c:	e0bffb17 	ldw	r2,-20(fp)
 8247340:	10804010 	cmplti	r2,r2,256
 8247344:	1000021e 	bne	r2,zero,8247350 <parse_ipad+0x1e4>
 8247348:	e0bffa17 	ldw	r2,-24(fp)
 824734c:	00004106 	br	8247454 <parse_ipad+0x2e8>
         retval.c[1] = (u_char)number;
 8247350:	e0bffb17 	ldw	r2,-20(fp)
 8247354:	e0bffc45 	stb	r2,-15(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 8247358:	e0bff917 	ldw	r2,-28(fp)
 824735c:	10800058 	cmpnei	r2,r2,1
 8247360:	1000021e 	bne	r2,zero,824736c <parse_ipad+0x200>
 8247364:	e03ffc85 	stb	zero,-14(fp)
 8247368:	00001806 	br	82473cc <parse_ipad+0x260>
      else
   {
      number = atoi(cp);
 824736c:	e13ff817 	ldw	r4,-32(fp)
 8247370:	824b13c0 	call	824b13c <atoi>
 8247374:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247378:	00000306 	br	8247388 <parse_ipad+0x21c>
 824737c:	e0bff817 	ldw	r2,-32(fp)
 8247380:	10800044 	addi	r2,r2,1
 8247384:	e0bff815 	stw	r2,-32(fp)
 8247388:	e0bff817 	ldw	r2,-32(fp)
 824738c:	10800003 	ldbu	r2,0(r2)
 8247390:	10803fcc 	andi	r2,r2,255
 8247394:	1080201c 	xori	r2,r2,128
 8247398:	10bfe004 	addi	r2,r2,-128
 824739c:	10800b98 	cmpnei	r2,r2,46
 82473a0:	103ff61e 	bne	r2,zero,824737c <parse_ipad+0x210>
         cp++;             /* point past dot */
 82473a4:	e0bff817 	ldw	r2,-32(fp)
 82473a8:	10800044 	addi	r2,r2,1
 82473ac:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 82473b0:	e0bffb17 	ldw	r2,-20(fp)
 82473b4:	10804010 	cmplti	r2,r2,256
 82473b8:	1000021e 	bne	r2,zero,82473c4 <parse_ipad+0x258>
 82473bc:	e0bffa17 	ldw	r2,-24(fp)
 82473c0:	00002406 	br	8247454 <parse_ipad+0x2e8>
         retval.c[2] = (u_char)number;
 82473c4:	e0bffb17 	ldw	r2,-20(fp)
 82473c8:	e0bffc85 	stb	r2,-14(fp)
   }

   if ((number = atoi(cp)) > 255)
 82473cc:	e13ff817 	ldw	r4,-32(fp)
 82473d0:	824b13c0 	call	824b13c <atoi>
 82473d4:	e0bffb15 	stw	r2,-20(fp)
 82473d8:	e0bffb17 	ldw	r2,-20(fp)
 82473dc:	10804010 	cmplti	r2,r2,256
 82473e0:	1000021e 	bne	r2,zero,82473ec <parse_ipad+0x280>
      return(toobig);
 82473e4:	e0bffa17 	ldw	r2,-24(fp)
 82473e8:	00001a06 	br	8247454 <parse_ipad+0x2e8>
   retval.c[3] = (u_char)number;
 82473ec:	e0bffb17 	ldw	r2,-20(fp)
 82473f0:	e0bffcc5 	stb	r2,-13(fp)

   if (retval.c[0] < 128) *sbits = 8;
 82473f4:	e0bffc03 	ldbu	r2,-16(fp)
 82473f8:	10803fcc 	andi	r2,r2,255
 82473fc:	1080201c 	xori	r2,r2,128
 8247400:	10bfe004 	addi	r2,r2,-128
 8247404:	10000416 	blt	r2,zero,8247418 <parse_ipad+0x2ac>
 8247408:	e0bffe17 	ldw	r2,-8(fp)
 824740c:	00c00204 	movi	r3,8
 8247410:	10c00015 	stw	r3,0(r2)
 8247414:	00000b06 	br	8247444 <parse_ipad+0x2d8>
      else if(retval.c[0] < 192) *sbits = 16;
 8247418:	e0bffc03 	ldbu	r2,-16(fp)
 824741c:	10803fcc 	andi	r2,r2,255
 8247420:	10803028 	cmpgeui	r2,r2,192
 8247424:	1000041e 	bne	r2,zero,8247438 <parse_ipad+0x2cc>
 8247428:	e0bffe17 	ldw	r2,-8(fp)
 824742c:	00c00404 	movi	r3,16
 8247430:	10c00015 	stw	r3,0(r2)
 8247434:	00000306 	br	8247444 <parse_ipad+0x2d8>
      else *sbits = 24;
 8247438:	e0bffe17 	ldw	r2,-8(fp)
 824743c:	00c00604 	movi	r3,24
 8247440:	10c00015 	stw	r3,0(r2)

      *ipout = retval.l;      /* everything went OK, return number */
 8247444:	e0fffc17 	ldw	r3,-16(fp)
 8247448:	e0bffd17 	ldw	r2,-12(fp)
 824744c:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 8247450:	0005883a 	mov	r2,zero
}
 8247454:	e037883a 	mov	sp,fp
 8247458:	dfc00117 	ldw	ra,4(sp)
 824745c:	df000017 	ldw	fp,0(sp)
 8247460:	dec00204 	addi	sp,sp,8
 8247464:	f800283a 	ret

08247468 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 8247468:	defffb04 	addi	sp,sp,-20
 824746c:	dfc00415 	stw	ra,16(sp)
 8247470:	df000315 	stw	fp,12(sp)
 8247474:	df000304 	addi	fp,sp,12
 8247478:	e13fff15 	stw	r4,-4(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 824747c:	e17fff17 	ldw	r5,-4(fp)
 8247480:	01020974 	movhi	r4,2085
 8247484:	2110a604 	addi	r4,r4,17048
 8247488:	824b1b40 	call	824b1b4 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 824748c:	e0bffe04 	addi	r2,fp,-8
 8247490:	01820974 	movhi	r6,2085
 8247494:	3190a604 	addi	r6,r6,17048
 8247498:	100b883a 	mov	r5,r2
 824749c:	e13ffd04 	addi	r4,fp,-12
 82474a0:	824716c0 	call	824716c <parse_ipad>
 82474a4:	1000021e 	bne	r2,zero,82474b0 <inet_addr+0x48>
   {
      return ipaddr ;
 82474a8:	e0bffd17 	ldw	r2,-12(fp)
 82474ac:	00000106 	br	82474b4 <inet_addr+0x4c>
   }
   else
   {
      return (u_long)NULL ;
 82474b0:	0005883a 	mov	r2,zero
   }
}
 82474b4:	e037883a 	mov	sp,fp
 82474b8:	dfc00117 	ldw	ra,4(sp)
 82474bc:	df000017 	ldw	fp,0(sp)
 82474c0:	dec00204 	addi	sp,sp,8
 82474c4:	f800283a 	ret

082474c8 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 82474c8:	defffe04 	addi	sp,sp,-8
 82474cc:	df000115 	stw	fp,4(sp)
 82474d0:	df000104 	addi	fp,sp,4
 82474d4:	e13fff15 	stw	r4,-4(fp)
   val &= 0x0f;
 82474d8:	e0bfff17 	ldw	r2,-4(fp)
 82474dc:	108003cc 	andi	r2,r2,15
 82474e0:	e0bfff15 	stw	r2,-4(fp)
   if(val < 10)
 82474e4:	e0bfff17 	ldw	r2,-4(fp)
 82474e8:	10800288 	cmpgei	r2,r2,10
 82474ec:	1000031e 	bne	r2,zero,82474fc <hextoa+0x34>
      return (char)(val + '0');
 82474f0:	e0bfff17 	ldw	r2,-4(fp)
 82474f4:	10800c04 	addi	r2,r2,48
 82474f8:	00000206 	br	8247504 <hextoa+0x3c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 82474fc:	e0bfff17 	ldw	r2,-4(fp)
 8247500:	10800dc4 	addi	r2,r2,55
}
 8247504:	e037883a 	mov	sp,fp
 8247508:	df000017 	ldw	fp,0(sp)
 824750c:	dec00104 	addi	sp,sp,4
 8247510:	f800283a 	ret

08247514 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 8247514:	defff804 	addi	sp,sp,-32
 8247518:	dfc00715 	stw	ra,28(sp)
 824751c:	df000615 	stw	fp,24(sp)
 8247520:	df000604 	addi	fp,sp,24
 8247524:	e13ffd15 	stw	r4,-12(fp)
 8247528:	e17ffe15 	stw	r5,-8(fp)
 824752c:	e1bfff15 	stw	r6,-4(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 8247530:	e0bffd17 	ldw	r2,-12(fp)
 8247534:	10800098 	cmpnei	r2,r2,2
 8247538:	1000151e 	bne	r2,zero,8247590 <inet_pton+0x7c>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 824753c:	e0fffc04 	addi	r3,fp,-16
 8247540:	e0bffb04 	addi	r2,fp,-20
 8247544:	e1bffe17 	ldw	r6,-8(fp)
 8247548:	180b883a 	mov	r5,r3
 824754c:	1009883a 	mov	r4,r2
 8247550:	824716c0 	call	824716c <parse_ipad>
 8247554:	e0bffa15 	stw	r2,-24(fp)
      if(err == NULL)
 8247558:	e0bffa17 	ldw	r2,-24(fp)
 824755c:	1000071e 	bne	r2,zero,824757c <inet_pton+0x68>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 8247560:	e0bffb04 	addi	r2,fp,-20
 8247564:	01800104 	movi	r6,4
 8247568:	100b883a 	mov	r5,r2
 824756c:	e13fff17 	ldw	r4,-4(fp)
 8247570:	8202a0c0 	call	8202a0c <memcpy>
         return 0;
 8247574:	0005883a 	mov	r2,zero
 8247578:	00000606 	br	8247594 <inet_pton+0x80>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 824757c:	00820974 	movhi	r2,2085
 8247580:	10856f04 	addi	r2,r2,5564
 8247584:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 8247588:	00800044 	movi	r2,1
 824758c:	00000106 	br	8247594 <inet_pton+0x80>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 8247590:	0005883a 	mov	r2,zero
}
 8247594:	e037883a 	mov	sp,fp
 8247598:	dfc00117 	ldw	ra,4(sp)
 824759c:	df000017 	ldw	fp,0(sp)
 82475a0:	dec00204 	addi	sp,sp,8
 82475a4:	f800283a 	ret

082475a8 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 82475a8:	defff804 	addi	sp,sp,-32
 82475ac:	dfc00715 	stw	ra,28(sp)
 82475b0:	df000615 	stw	fp,24(sp)
 82475b4:	df000604 	addi	fp,sp,24
 82475b8:	e13ffc15 	stw	r4,-16(fp)
 82475bc:	e17ffd15 	stw	r5,-12(fp)
 82475c0:	e1bffe15 	stw	r6,-8(fp)
 82475c4:	e1ffff15 	stw	r7,-4(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 82475c8:	e0bffc17 	ldw	r2,-16(fp)
 82475cc:	10800098 	cmpnei	r2,r2,2
 82475d0:	1000101e 	bne	r2,zero,8247614 <inet_ntop+0x6c>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 82475d4:	e0bffd17 	ldw	r2,-12(fp)
 82475d8:	10800017 	ldw	r2,0(r2)
 82475dc:	e0bffa15 	stw	r2,-24(fp)
      cp = print_ipad(ip4addr);
 82475e0:	e13ffa17 	ldw	r4,-24(fp)
 82475e4:	82286280 	call	8228628 <print_ipad>
 82475e8:	e0bffb15 	stw	r2,-20(fp)
      if (strlen(cp) < size)
 82475ec:	e13ffb17 	ldw	r4,-20(fp)
 82475f0:	8203a5c0 	call	8203a5c <strlen>
 82475f4:	1007883a 	mov	r3,r2
 82475f8:	e0bfff17 	ldw	r2,-4(fp)
 82475fc:	1880052e 	bgeu	r3,r2,8247614 <inet_ntop+0x6c>
      {
         strcpy(str, cp);
 8247600:	e17ffb17 	ldw	r5,-20(fp)
 8247604:	e13ffe17 	ldw	r4,-8(fp)
 8247608:	824b1b40 	call	824b1b4 <strcpy>
         return (str);
 824760c:	e0bffe17 	ldw	r2,-8(fp)
 8247610:	00000106 	br	8247618 <inet_ntop+0x70>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 8247614:	0005883a 	mov	r2,zero
}
 8247618:	e037883a 	mov	sp,fp
 824761c:	dfc00117 	ldw	ra,4(sp)
 8247620:	df000017 	ldw	fp,0(sp)
 8247624:	dec00204 	addi	sp,sp,8
 8247628:	f800283a 	ret

0824762c <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 824762c:	defffc04 	addi	sp,sp,-16
 8247630:	dfc00315 	stw	ra,12(sp)
 8247634:	df000215 	stw	fp,8(sp)
 8247638:	df000204 	addi	fp,sp,8
 824763c:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr->sa_family == AF_INET)
 8247640:	e0bfff17 	ldw	r2,-4(fp)
 8247644:	1080000b 	ldhu	r2,0(r2)
 8247648:	10bfffcc 	andi	r2,r2,65535
 824764c:	10800098 	cmpnei	r2,r2,2
 8247650:	1000071e 	bne	r2,zero,8247670 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 8247654:	e0bfff17 	ldw	r2,-4(fp)
 8247658:	e0bffe15 	stw	r2,-8(fp)
      return print_ipad(addr->sin_addr.s_addr);
 824765c:	e0bffe17 	ldw	r2,-8(fp)
 8247660:	10800117 	ldw	r2,4(r2)
 8247664:	1009883a 	mov	r4,r2
 8247668:	82286280 	call	8228628 <print_ipad>
 824766c:	00000106 	br	8247674 <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 8247670:	0005883a 	mov	r2,zero
}
 8247674:	e037883a 	mov	sp,fp
 8247678:	dfc00117 	ldw	ra,4(sp)
 824767c:	df000017 	ldw	fp,0(sp)
 8247680:	dec00204 	addi	sp,sp,8
 8247684:	f800283a 	ret

08247688 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 8247688:	defffb04 	addi	sp,sp,-20
 824768c:	dfc00415 	stw	ra,16(sp)
 8247690:	df000315 	stw	fp,12(sp)
 8247694:	df000304 	addi	fp,sp,12
 8247698:	e13ffe15 	stw	r4,-8(fp)
 824769c:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 82476a0:	e0bfff17 	ldw	r2,-4(fp)
 82476a4:	00c00084 	movi	r3,2
 82476a8:	10c0000d 	sth	r3,0(r2)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 82476ac:	e0bffe17 	ldw	r2,-8(fp)
 82476b0:	10800044 	addi	r2,r2,1
 82476b4:	10800003 	ldbu	r2,0(r2)
 82476b8:	10803fcc 	andi	r2,r2,255
 82476bc:	1080201c 	xori	r2,r2,128
 82476c0:	10bfe004 	addi	r2,r2,-128
 82476c4:	10800ba0 	cmpeqi	r2,r2,46
 82476c8:	1000101e 	bne	r2,zero,824770c <inet46_addr+0x84>
 82476cc:	e0bffe17 	ldw	r2,-8(fp)
 82476d0:	10800084 	addi	r2,r2,2
 82476d4:	10800003 	ldbu	r2,0(r2)
 82476d8:	10803fcc 	andi	r2,r2,255
 82476dc:	1080201c 	xori	r2,r2,128
 82476e0:	10bfe004 	addi	r2,r2,-128
 82476e4:	10800ba0 	cmpeqi	r2,r2,46
 82476e8:	1000081e 	bne	r2,zero,824770c <inet46_addr+0x84>
 82476ec:	e0bffe17 	ldw	r2,-8(fp)
 82476f0:	108000c4 	addi	r2,r2,3
 82476f4:	10800003 	ldbu	r2,0(r2)
 82476f8:	10803fcc 	andi	r2,r2,255
 82476fc:	1080201c 	xori	r2,r2,128
 8247700:	10bfe004 	addi	r2,r2,-128
 8247704:	10800b98 	cmpnei	r2,r2,46
 8247708:	10000a1e 	bne	r2,zero,8247734 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 824770c:	e0bfff17 	ldw	r2,-4(fp)
 8247710:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 8247714:	e13ffe17 	ldw	r4,-8(fp)
 8247718:	82474680 	call	8247468 <inet_addr>
 824771c:	1007883a 	mov	r3,r2
 8247720:	e0bffd17 	ldw	r2,-12(fp)
 8247724:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 8247728:	e0bffd17 	ldw	r2,-12(fp)
 824772c:	00c00084 	movi	r3,2
 8247730:	10c0000d 	sth	r3,0(r2)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 8247734:	0005883a 	mov	r2,zero
}
 8247738:	e037883a 	mov	sp,fp
 824773c:	dfc00117 	ldw	ra,4(sp)
 8247740:	df000017 	ldw	fp,0(sp)
 8247744:	dec00204 	addi	sp,sp,8
 8247748:	f800283a 	ret

0824774c <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 824774c:	defffc04 	addi	sp,sp,-16
 8247750:	df000315 	stw	fp,12(sp)
 8247754:	df000304 	addi	fp,sp,12
 8247758:	e13ffe15 	stw	r4,-8(fp)
 824775c:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 8247760:	e0bffe17 	ldw	r2,-8(fp)
 8247764:	1080000b 	ldhu	r2,0(r2)
 8247768:	10bfffcc 	andi	r2,r2,65535
 824776c:	10800098 	cmpnei	r2,r2,2
 8247770:	10000c1e 	bne	r2,zero,82477a4 <inet_setport+0x58>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 8247774:	e0bffe17 	ldw	r2,-8(fp)
 8247778:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 824777c:	e0bfff17 	ldw	r2,-4(fp)
 8247780:	1005d23a 	srai	r2,r2,8
 8247784:	10803fcc 	andi	r2,r2,255
 8247788:	1007883a 	mov	r3,r2
 824778c:	e0bfff17 	ldw	r2,-4(fp)
 8247790:	1004923a 	slli	r2,r2,8
 8247794:	1884b03a 	or	r2,r3,r2
 8247798:	1007883a 	mov	r3,r2
 824779c:	e0bffd17 	ldw	r2,-12(fp)
 82477a0:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 82477a4:	0001883a 	nop
 82477a8:	e037883a 	mov	sp,fp
 82477ac:	df000017 	ldw	fp,0(sp)
 82477b0:	dec00104 	addi	sp,sp,4
 82477b4:	f800283a 	ret

082477b8 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 82477b8:	defff904 	addi	sp,sp,-28
 82477bc:	df000615 	stw	fp,24(sp)
 82477c0:	df000604 	addi	fp,sp,24
 82477c4:	e13fff15 	stw	r4,-4(fp)
   const char *cp = p;
 82477c8:	e0bfff17 	ldw	r2,-4(fp)
 82477cc:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 82477d0:	e0bffe04 	addi	r2,fp,-8
 82477d4:	e0bffd15 	stw	r2,-12(fp)
   int n = 0;
 82477d8:	e03ffb15 	stw	zero,-20(fp)
   unsigned short v = 0;
 82477dc:	e03ffc0d 	sth	zero,-16(fp)
   dw = 0;
 82477e0:	e03ffe15 	stw	zero,-8(fp)
   while(*cp)
 82477e4:	00003106 	br	82478ac <convert_ip+0xf4>
   {
      if( *cp == '.')
 82477e8:	e0bffa17 	ldw	r2,-24(fp)
 82477ec:	10800003 	ldbu	r2,0(r2)
 82477f0:	10803fcc 	andi	r2,r2,255
 82477f4:	1080201c 	xori	r2,r2,128
 82477f8:	10bfe004 	addi	r2,r2,-128
 82477fc:	10800b98 	cmpnei	r2,r2,46
 8247800:	10000e1e 	bne	r2,zero,824783c <convert_ip+0x84>
      {
         lpb[n] = (unsigned char) v;
 8247804:	e0bffb17 	ldw	r2,-20(fp)
 8247808:	e0fffd17 	ldw	r3,-12(fp)
 824780c:	1885883a 	add	r2,r3,r2
 8247810:	e0fffc0b 	ldhu	r3,-16(fp)
 8247814:	10c00005 	stb	r3,0(r2)
         v = 0;
 8247818:	e03ffc0d 	sth	zero,-16(fp)
         n++;
 824781c:	e0bffb17 	ldw	r2,-20(fp)
 8247820:	10800044 	addi	r2,r2,1
 8247824:	e0bffb15 	stw	r2,-20(fp)
         if(n > 3)
 8247828:	e0bffb17 	ldw	r2,-20(fp)
 824782c:	10800110 	cmplti	r2,r2,4
 8247830:	10001b1e 	bne	r2,zero,82478a0 <convert_ip+0xe8>
         {
            return dw;
 8247834:	e0bffe17 	ldw	r2,-8(fp)
 8247838:	00002806 	br	82478dc <convert_ip+0x124>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 824783c:	e0bffa17 	ldw	r2,-24(fp)
 8247840:	10800003 	ldbu	r2,0(r2)
 8247844:	10803fcc 	andi	r2,r2,255
 8247848:	1080201c 	xori	r2,r2,128
 824784c:	10bfe004 	addi	r2,r2,-128
 8247850:	10800c10 	cmplti	r2,r2,48
 8247854:	1000121e 	bne	r2,zero,82478a0 <convert_ip+0xe8>
 8247858:	e0bffa17 	ldw	r2,-24(fp)
 824785c:	10800003 	ldbu	r2,0(r2)
 8247860:	10803fcc 	andi	r2,r2,255
 8247864:	1080201c 	xori	r2,r2,128
 8247868:	10bfe004 	addi	r2,r2,-128
 824786c:	10800e88 	cmpgei	r2,r2,58
 8247870:	10000b1e 	bne	r2,zero,82478a0 <convert_ip+0xe8>
      {
         v = (v * 10) + (*cp - '0');
 8247874:	e0bffc0b 	ldhu	r2,-16(fp)
 8247878:	108002a4 	muli	r2,r2,10
 824787c:	1007883a 	mov	r3,r2
 8247880:	e0bffa17 	ldw	r2,-24(fp)
 8247884:	10800003 	ldbu	r2,0(r2)
 8247888:	10803fcc 	andi	r2,r2,255
 824788c:	1080201c 	xori	r2,r2,128
 8247890:	10bfe004 	addi	r2,r2,-128
 8247894:	1885883a 	add	r2,r3,r2
 8247898:	10bff404 	addi	r2,r2,-48
 824789c:	e0bffc0d 	sth	r2,-16(fp)
      }
      cp++;
 82478a0:	e0bffa17 	ldw	r2,-24(fp)
 82478a4:	10800044 	addi	r2,r2,1
 82478a8:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 82478ac:	e0bffa17 	ldw	r2,-24(fp)
 82478b0:	10800003 	ldbu	r2,0(r2)
 82478b4:	10803fcc 	andi	r2,r2,255
 82478b8:	1080201c 	xori	r2,r2,128
 82478bc:	10bfe004 	addi	r2,r2,-128
 82478c0:	103fc91e 	bne	r2,zero,82477e8 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 82478c4:	e0bffb17 	ldw	r2,-20(fp)
 82478c8:	e0fffd17 	ldw	r3,-12(fp)
 82478cc:	1885883a 	add	r2,r3,r2
 82478d0:	e0fffc0b 	ldhu	r3,-16(fp)
 82478d4:	10c00005 	stb	r3,0(r2)
   return dw;
 82478d8:	e0bffe17 	ldw	r2,-8(fp)
}  /* convert_ip() */
 82478dc:	e037883a 	mov	sp,fp
 82478e0:	df000017 	ldw	fp,0(sp)
 82478e4:	dec00104 	addi	sp,sp,4
 82478e8:	f800283a 	ret

082478ec <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 82478ec:	defff704 	addi	sp,sp,-36
 82478f0:	dfc00815 	stw	ra,32(sp)
 82478f4:	df000715 	stw	fp,28(sp)
 82478f8:	df000704 	addi	fp,sp,28
 82478fc:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 8247900:	e03ffa15 	stw	zero,-24(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 8247904:	e03ffb05 	stb	zero,-20(fp)

   iphlen = (unshort)ip_hlen(pip);
 8247908:	e0bfff17 	ldw	r2,-4(fp)
 824790c:	10800003 	ldbu	r2,0(r2)
 8247910:	10803fcc 	andi	r2,r2,255
 8247914:	108003cc 	andi	r2,r2,15
 8247918:	1085883a 	add	r2,r2,r2
 824791c:	1085883a 	add	r2,r2,r2
 8247920:	e0bffc0d 	sth	r2,-16(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 8247924:	e0bfff17 	ldw	r2,-4(fp)
 8247928:	1080008b 	ldhu	r2,2(r2)
 824792c:	10bfffcc 	andi	r2,r2,65535
 8247930:	1004d23a 	srli	r2,r2,8
 8247934:	1007883a 	mov	r3,r2
 8247938:	e0bfff17 	ldw	r2,-4(fp)
 824793c:	1080008b 	ldhu	r2,2(r2)
 8247940:	10bfffcc 	andi	r2,r2,65535
 8247944:	1004923a 	slli	r2,r2,8
 8247948:	1884b03a 	or	r2,r3,r2
 824794c:	1007883a 	mov	r3,r2
 8247950:	e0bffc0b 	ldhu	r2,-16(fp)
 8247954:	1885c83a 	sub	r2,r3,r2
 8247958:	e0bff90d 	sth	r2,-28(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 824795c:	e0bfff17 	ldw	r2,-4(fp)
 8247960:	10800003 	ldbu	r2,0(r2)
 8247964:	10803fcc 	andi	r2,r2,255
 8247968:	108003cc 	andi	r2,r2,15
 824796c:	1085883a 	add	r2,r2,r2
 8247970:	1085883a 	add	r2,r2,r2
 8247974:	1007883a 	mov	r3,r2
 8247978:	e0bfff17 	ldw	r2,-4(fp)
 824797c:	10c5883a 	add	r2,r2,r3
 8247980:	e0bffd15 	stw	r2,-12(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 8247984:	e0bffd17 	ldw	r2,-12(fp)
 8247988:	1080040b 	ldhu	r2,16(r2)
 824798c:	e0bffe0d 	sth	r2,-8(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 8247990:	e0bff90b 	ldhu	r2,-28(fp)
 8247994:	10800184 	addi	r2,r2,6
 8247998:	1005d23a 	srai	r2,r2,8
 824799c:	10803fcc 	andi	r2,r2,255
 82479a0:	1007883a 	mov	r3,r2
 82479a4:	e0bff90b 	ldhu	r2,-28(fp)
 82479a8:	10800184 	addi	r2,r2,6
 82479ac:	1004923a 	slli	r2,r2,8
 82479b0:	1884b03a 	or	r2,r3,r2
 82479b4:	1007883a 	mov	r3,r2
 82479b8:	e0bffd17 	ldw	r2,-12(fp)
 82479bc:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 82479c0:	e0bff90b 	ldhu	r2,-28(fp)
 82479c4:	1080004c 	andi	r2,r2,1
 82479c8:	10000e26 	beq	r2,zero,8247a04 <tcp_cksum+0x118>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 82479cc:	e0fffc0b 	ldhu	r3,-16(fp)
 82479d0:	e0bff90b 	ldhu	r2,-28(fp)
 82479d4:	1885883a 	add	r2,r3,r2
 82479d8:	e0ffff17 	ldw	r3,-4(fp)
 82479dc:	1885883a 	add	r2,r3,r2
 82479e0:	e0bffa15 	stw	r2,-24(fp)
      oddchar = *tcpdata;
 82479e4:	e0bffa17 	ldw	r2,-24(fp)
 82479e8:	10800003 	ldbu	r2,0(r2)
 82479ec:	e0bffb05 	stb	r2,-20(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 82479f0:	e0bffa17 	ldw	r2,-24(fp)
 82479f4:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 82479f8:	e0bff90b 	ldhu	r2,-28(fp)
 82479fc:	10800044 	addi	r2,r2,1
 8247a00:	e0bff90d 	sth	r2,-28(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 8247a04:	e0bffd17 	ldw	r2,-12(fp)
 8247a08:	10fffe04 	addi	r3,r2,-8
 8247a0c:	e0bff90b 	ldhu	r2,-28(fp)
 8247a10:	10800204 	addi	r2,r2,8
 8247a14:	1005d07a 	srai	r2,r2,1
 8247a18:	100b883a 	mov	r5,r2
 8247a1c:	1809883a 	mov	r4,r3
 8247a20:	82283e80 	call	82283e8 <cksum>
 8247a24:	0084303a 	nor	r2,zero,r2
 8247a28:	e0bffb8d 	sth	r2,-18(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 8247a2c:	e0fffb8b 	ldhu	r3,-18(fp)
 8247a30:	e0bffe0b 	ldhu	r2,-8(fp)
 8247a34:	18800726 	beq	r3,r2,8247a54 <tcp_cksum+0x168>
 8247a38:	e0fffe0b 	ldhu	r3,-8(fp)
 8247a3c:	00bfffd4 	movui	r2,65535
 8247a40:	1880041e 	bne	r3,r2,8247a54 <tcp_cksum+0x168>
 8247a44:	e0bffb8b 	ldhu	r2,-18(fp)
 8247a48:	1000021e 	bne	r2,zero,8247a54 <tcp_cksum+0x168>
      newsum = 0xffff;
 8247a4c:	00bfffc4 	movi	r2,-1
 8247a50:	e0bffb8d 	sth	r2,-18(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 8247a54:	e0bffd17 	ldw	r2,-12(fp)
 8247a58:	e0fffe0b 	ldhu	r3,-8(fp)
 8247a5c:	10c0040d 	sth	r3,16(r2)
   if (oddchar)
 8247a60:	e0bffb07 	ldb	r2,-20(fp)
 8247a64:	10000326 	beq	r2,zero,8247a74 <tcp_cksum+0x188>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 8247a68:	e0bffa17 	ldw	r2,-24(fp)
 8247a6c:	e0fffb03 	ldbu	r3,-20(fp)
 8247a70:	10c00005 	stb	r3,0(r2)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 8247a74:	e0bffb8b 	ldhu	r2,-18(fp)
}
 8247a78:	e037883a 	mov	sp,fp
 8247a7c:	dfc00117 	ldw	ra,4(sp)
 8247a80:	df000017 	ldw	fp,0(sp)
 8247a84:	dec00204 	addi	sp,sp,8
 8247a88:	f800283a 	ret

08247a8c <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 8247a8c:	defffb04 	addi	sp,sp,-20
 8247a90:	dfc00415 	stw	ra,16(sp)
 8247a94:	df000315 	stw	fp,12(sp)
 8247a98:	df000304 	addi	fp,sp,12
 8247a9c:	e13ffe15 	stw	r4,-8(fp)
 8247aa0:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 8247aa4:	01000b04 	movi	r4,44
 8247aa8:	822dda00 	call	822dda0 <npalloc>
 8247aac:	e0bffd15 	stw	r2,-12(fp)
   if (inp == 0)
 8247ab0:	e0bffd17 	ldw	r2,-12(fp)
 8247ab4:	1000021e 	bne	r2,zero,8247ac0 <in_pcballoc+0x34>
      return ENOMEM;
 8247ab8:	00800304 	movi	r2,12
 8247abc:	00001006 	br	8247b00 <in_pcballoc+0x74>
   inp->inp_head = head;
 8247ac0:	e0bffd17 	ldw	r2,-12(fp)
 8247ac4:	e0ffff17 	ldw	r3,-4(fp)
 8247ac8:	10c00215 	stw	r3,8(r2)
   inp->inp_socket = so;
 8247acc:	e0bffd17 	ldw	r2,-12(fp)
 8247ad0:	e0fffe17 	ldw	r3,-8(fp)
 8247ad4:	10c00815 	stw	r3,32(r2)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 8247ad8:	e0bffd17 	ldw	r2,-12(fp)
 8247adc:	00c08004 	movi	r3,512
 8247ae0:	10c00615 	stw	r3,24(r2)
   insque(inp, head);
 8247ae4:	e17fff17 	ldw	r5,-4(fp)
 8247ae8:	e13ffd17 	ldw	r4,-12(fp)
 8247aec:	822e8c40 	call	822e8c4 <insque>
   so->so_pcb = inp;
 8247af0:	e0bffe17 	ldw	r2,-8(fp)
 8247af4:	e0fffd17 	ldw	r3,-12(fp)
 8247af8:	10c00115 	stw	r3,4(r2)
   return 0;
 8247afc:	0005883a 	mov	r2,zero
}
 8247b00:	e037883a 	mov	sp,fp
 8247b04:	dfc00117 	ldw	ra,4(sp)
 8247b08:	df000017 	ldw	fp,0(sp)
 8247b0c:	dec00204 	addi	sp,sp,8
 8247b10:	f800283a 	ret

08247b14 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 8247b14:	defffc04 	addi	sp,sp,-16
 8247b18:	dfc00315 	stw	ra,12(sp)
 8247b1c:	df000215 	stw	fp,8(sp)
 8247b20:	df000204 	addi	fp,sp,8
 8247b24:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247b28:	e0bfff17 	ldw	r2,-4(fp)
 8247b2c:	10800817 	ldw	r2,32(r2)
 8247b30:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 8247b34:	e0bffe17 	ldw	r2,-8(fp)
 8247b38:	10000115 	stw	zero,4(r2)
   sofree(so);
 8247b3c:	e13ffe17 	ldw	r4,-8(fp)
 8247b40:	823193c0 	call	823193c <sofree>
   remque(inp);
 8247b44:	e13fff17 	ldw	r4,-4(fp)
 8247b48:	822e8540 	call	822e854 <remque>
   INP_FREE (inp);
 8247b4c:	e13fff17 	ldw	r4,-4(fp)
 8247b50:	822ddd40 	call	822ddd4 <npfree>
}
 8247b54:	0001883a 	nop
 8247b58:	e037883a 	mov	sp,fp
 8247b5c:	dfc00117 	ldw	ra,4(sp)
 8247b60:	df000017 	ldw	fp,0(sp)
 8247b64:	dec00204 	addi	sp,sp,8
 8247b68:	f800283a 	ret

08247b6c <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8247b6c:	defff504 	addi	sp,sp,-44
 8247b70:	dfc00a15 	stw	ra,40(sp)
 8247b74:	df000915 	stw	fp,36(sp)
 8247b78:	df000904 	addi	fp,sp,36
 8247b7c:	e13ffe15 	stw	r4,-8(fp)
 8247b80:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247b84:	e0bffe17 	ldw	r2,-8(fp)
 8247b88:	10800817 	ldw	r2,32(r2)
 8247b8c:	e0bffb15 	stw	r2,-20(fp)
   struct inpcb * head  =  inp->inp_head;
 8247b90:	e0bffe17 	ldw	r2,-8(fp)
 8247b94:	10800217 	ldw	r2,8(r2)
 8247b98:	e0bffc15 	stw	r2,-16(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 8247b9c:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 8247ba0:	e0bffe17 	ldw	r2,-8(fp)
 8247ba4:	1080078b 	ldhu	r2,30(r2)
 8247ba8:	10bfffcc 	andi	r2,r2,65535
 8247bac:	1000031e 	bne	r2,zero,8247bbc <in_pcbbind+0x50>
 8247bb0:	e0bffe17 	ldw	r2,-8(fp)
 8247bb4:	10800417 	ldw	r2,16(r2)
 8247bb8:	10000226 	beq	r2,zero,8247bc4 <in_pcbbind+0x58>
      return (EINVAL);
 8247bbc:	00800584 	movi	r2,22
 8247bc0:	00006906 	br	8247d68 <in_pcbbind+0x1fc>
   if (nam == 0)
 8247bc4:	e0bfff17 	ldw	r2,-4(fp)
 8247bc8:	10003926 	beq	r2,zero,8247cb0 <in_pcbbind+0x144>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 8247bcc:	e0bfff17 	ldw	r2,-4(fp)
 8247bd0:	10800317 	ldw	r2,12(r2)
 8247bd4:	e0bffd15 	stw	r2,-12(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 8247bd8:	e0bffd17 	ldw	r2,-12(fp)
 8247bdc:	10800117 	ldw	r2,4(r2)
 8247be0:	10000a26 	beq	r2,zero,8247c0c <in_pcbbind+0xa0>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 8247be4:	e0bffd17 	ldw	r2,-12(fp)
 8247be8:	10800117 	ldw	r2,4(r2)
 8247bec:	1009883a 	mov	r4,r2
 8247bf0:	82405f00 	call	82405f0 <ip_mymach>
 8247bf4:	1007883a 	mov	r3,r2
 8247bf8:	e0bffd17 	ldw	r2,-12(fp)
 8247bfc:	10800117 	ldw	r2,4(r2)
 8247c00:	18800226 	beq	r3,r2,8247c0c <in_pcbbind+0xa0>
      return (EADDRNOTAVAIL);
 8247c04:	00801f44 	movi	r2,125
 8247c08:	00005706 	br	8247d68 <in_pcbbind+0x1fc>
   }
   lport = sin->sin_port;
 8247c0c:	e0bffd17 	ldw	r2,-12(fp)
 8247c10:	1080008b 	ldhu	r2,2(r2)
 8247c14:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 8247c18:	e0bff90b 	ldhu	r2,-28(fp)
 8247c1c:	10001f26 	beq	r2,zero,8247c9c <in_pcbbind+0x130>
   {
      int   wild  =  0;
 8247c20:	e03ffa15 	stw	zero,-24(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247c24:	e0bffb17 	ldw	r2,-20(fp)
 8247c28:	10800417 	ldw	r2,16(r2)
 8247c2c:	1080010c 	andi	r2,r2,4
 8247c30:	10000c1e 	bne	r2,zero,8247c64 <in_pcbbind+0xf8>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247c34:	e0bffb17 	ldw	r2,-20(fp)
 8247c38:	10800217 	ldw	r2,8(r2)
 8247c3c:	1080010b 	ldhu	r2,4(r2)
 8247c40:	10bfffcc 	andi	r2,r2,65535
 8247c44:	1080010c 	andi	r2,r2,4
   if (lport) 
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247c48:	10000426 	beq	r2,zero,8247c5c <in_pcbbind+0xf0>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
 8247c4c:	e0bffb17 	ldw	r2,-20(fp)
 8247c50:	10800417 	ldw	r2,16(r2)
 8247c54:	1080008c 	andi	r2,r2,2
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247c58:	1000021e 	bne	r2,zero,8247c64 <in_pcbbind+0xf8>
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 8247c5c:	00800044 	movi	r2,1
 8247c60:	e0bffa15 	stw	r2,-24(fp)
      }
      if (in_pcblookup(head,
 8247c64:	e0bffd17 	ldw	r2,-12(fp)
 8247c68:	11000117 	ldw	r4,4(r2)
 8247c6c:	e0bff90b 	ldhu	r2,-28(fp)
 8247c70:	e0fffa17 	ldw	r3,-24(fp)
 8247c74:	d8c00115 	stw	r3,4(sp)
 8247c78:	d8800015 	stw	r2,0(sp)
 8247c7c:	200f883a 	mov	r7,r4
 8247c80:	000d883a 	mov	r6,zero
 8247c84:	000b883a 	mov	r5,zero
 8247c88:	e13ffc17 	ldw	r4,-16(fp)
 8247c8c:	82480c00 	call	82480c0 <in_pcblookup>
 8247c90:	10000226 	beq	r2,zero,8247c9c <in_pcbbind+0x130>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 8247c94:	00801c04 	movi	r2,112
 8247c98:	00003306 	br	8247d68 <in_pcbbind+0x1fc>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 8247c9c:	e0bffe17 	ldw	r2,-8(fp)
 8247ca0:	e0fffd17 	ldw	r3,-12(fp)
 8247ca4:	18c00117 	ldw	r3,4(r3)
 8247ca8:	10c00415 	stw	r3,16(r2)
 8247cac:	00000106 	br	8247cb4 <in_pcbbind+0x148>


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
      return (EINVAL);
   if (nam == 0)
      goto noname;
 8247cb0:	0001883a 	nop
         return (EADDRINUSE);
      }
   }
   inp->inp_laddr = sin->sin_addr;
noname:
   if (lport == 0)
 8247cb4:	e0bff90b 	ldhu	r2,-28(fp)
 8247cb8:	1000271e 	bne	r2,zero,8247d58 <in_pcbbind+0x1ec>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8247cbc:	e0bffc17 	ldw	r2,-16(fp)
 8247cc0:	1080078b 	ldhu	r2,30(r2)
 8247cc4:	10c00044 	addi	r3,r2,1
 8247cc8:	1809883a 	mov	r4,r3
 8247ccc:	e0fffc17 	ldw	r3,-16(fp)
 8247cd0:	1900078d 	sth	r4,30(r3)
 8247cd4:	10bfffcc 	andi	r2,r2,65535
 8247cd8:	10810030 	cmpltui	r2,r2,1024
 8247cdc:	1000051e 	bne	r2,zero,8247cf4 <in_pcbbind+0x188>
             head->inp_lport > IPPORT_USERRESERVED)
 8247ce0:	e0bffc17 	ldw	r2,-16(fp)
 8247ce4:	1080078b 	ldhu	r2,30(r2)
noname:
   if (lport == 0)
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8247ce8:	10bfffcc 	andi	r2,r2,65535
 8247cec:	1084e270 	cmpltui	r2,r2,5001
 8247cf0:	1000031e 	bne	r2,zero,8247d00 <in_pcbbind+0x194>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 8247cf4:	e0bffc17 	ldw	r2,-16(fp)
 8247cf8:	00c10004 	movi	r3,1024
 8247cfc:	10c0078d 	sth	r3,30(r2)
         }
         lport = htons(head->inp_lport);
 8247d00:	e0bffc17 	ldw	r2,-16(fp)
 8247d04:	1080078b 	ldhu	r2,30(r2)
 8247d08:	10bfffcc 	andi	r2,r2,65535
 8247d0c:	1004d23a 	srli	r2,r2,8
 8247d10:	1007883a 	mov	r3,r2
 8247d14:	e0bffc17 	ldw	r2,-16(fp)
 8247d18:	1080078b 	ldhu	r2,30(r2)
 8247d1c:	10bfffcc 	andi	r2,r2,65535
 8247d20:	1004923a 	slli	r2,r2,8
 8247d24:	1884b03a 	or	r2,r3,r2
 8247d28:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 8247d2c:	e0bffe17 	ldw	r2,-8(fp)
 8247d30:	10c00417 	ldw	r3,16(r2)
 8247d34:	e0bff90b 	ldhu	r2,-28(fp)
 8247d38:	d8000115 	stw	zero,4(sp)
 8247d3c:	d8800015 	stw	r2,0(sp)
 8247d40:	180f883a 	mov	r7,r3
 8247d44:	000d883a 	mov	r6,zero
 8247d48:	000b883a 	mov	r5,zero
 8247d4c:	e13ffc17 	ldw	r4,-16(fp)
 8247d50:	82480c00 	call	82480c0 <in_pcblookup>
 8247d54:	103fd91e 	bne	r2,zero,8247cbc <in_pcbbind+0x150>
   }
   inp->inp_lport = lport;
 8247d58:	e0bffe17 	ldw	r2,-8(fp)
 8247d5c:	e0fff90b 	ldhu	r3,-28(fp)
 8247d60:	10c0078d 	sth	r3,30(r2)
   return (0);
 8247d64:	0005883a 	mov	r2,zero
}
 8247d68:	e037883a 	mov	sp,fp
 8247d6c:	dfc00117 	ldw	ra,4(sp)
 8247d70:	df000017 	ldw	fp,0(sp)
 8247d74:	dec00204 	addi	sp,sp,8
 8247d78:	f800283a 	ret

08247d7c <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8247d7c:	defff604 	addi	sp,sp,-40
 8247d80:	dfc00915 	stw	ra,36(sp)
 8247d84:	df000815 	stw	fp,32(sp)
 8247d88:	df000804 	addi	fp,sp,32
 8247d8c:	e13ffe15 	stw	r4,-8(fp)
 8247d90:	e17fff15 	stw	r5,-4(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 8247d94:	e0bfff17 	ldw	r2,-4(fp)
 8247d98:	10800317 	ldw	r2,12(r2)
 8247d9c:	e0bffb15 	stw	r2,-20(fp)

   if (nam->m_len < sizeof (*sin))
 8247da0:	e0bfff17 	ldw	r2,-4(fp)
 8247da4:	10800217 	ldw	r2,8(r2)
 8247da8:	10800428 	cmpgeui	r2,r2,16
 8247dac:	1000021e 	bne	r2,zero,8247db8 <in_pcbconnect+0x3c>
      return (EINVAL);
 8247db0:	00800584 	movi	r2,22
 8247db4:	00006406 	br	8247f48 <in_pcbconnect+0x1cc>
   if (sin->sin_family != AF_INET)
 8247db8:	e0bffb17 	ldw	r2,-20(fp)
 8247dbc:	1080000b 	ldhu	r2,0(r2)
 8247dc0:	10bfffcc 	andi	r2,r2,65535
 8247dc4:	10a0001c 	xori	r2,r2,32768
 8247dc8:	10a00004 	addi	r2,r2,-32768
 8247dcc:	108000a0 	cmpeqi	r2,r2,2
 8247dd0:	1000021e 	bne	r2,zero,8247ddc <in_pcbconnect+0x60>
      return (EAFNOSUPPORT);
 8247dd4:	00801a84 	movi	r2,106
 8247dd8:	00005b06 	br	8247f48 <in_pcbconnect+0x1cc>
   if (sin->sin_port == 0)
 8247ddc:	e0bffb17 	ldw	r2,-20(fp)
 8247de0:	1080008b 	ldhu	r2,2(r2)
 8247de4:	10bfffcc 	andi	r2,r2,65535
 8247de8:	1000021e 	bne	r2,zero,8247df4 <in_pcbconnect+0x78>
      return (EADDRNOTAVAIL);
 8247dec:	00801f44 	movi	r2,125
 8247df0:	00005506 	br	8247f48 <in_pcbconnect+0x1cc>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 8247df4:	e0bffb17 	ldw	r2,-20(fp)
 8247df8:	10800117 	ldw	r2,4(r2)
 8247dfc:	10000d1e 	bne	r2,zero,8247e34 <in_pcbconnect+0xb8>
   {
      if (inp && inp->ifp)
 8247e00:	e0bffe17 	ldw	r2,-8(fp)
 8247e04:	10000926 	beq	r2,zero,8247e2c <in_pcbconnect+0xb0>
 8247e08:	e0bffe17 	ldw	r2,-8(fp)
 8247e0c:	10800a17 	ldw	r2,40(r2)
 8247e10:	10000626 	beq	r2,zero,8247e2c <in_pcbconnect+0xb0>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 8247e14:	e0bffe17 	ldw	r2,-8(fp)
 8247e18:	10800a17 	ldw	r2,40(r2)
 8247e1c:	10c00a17 	ldw	r3,40(r2)
 8247e20:	e0bffb17 	ldw	r2,-20(fp)
 8247e24:	10c00115 	stw	r3,4(r2)
 8247e28:	00000806 	br	8247e4c <in_pcbconnect+0xd0>
      else
         return (EADDRNOTAVAIL);
 8247e2c:	00801f44 	movi	r2,125
 8247e30:	00004506 	br	8247f48 <in_pcbconnect+0x1cc>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 8247e34:	e0bffb17 	ldw	r2,-20(fp)
 8247e38:	10800117 	ldw	r2,4(r2)
 8247e3c:	10bfffd8 	cmpnei	r2,r2,-1
 8247e40:	1000021e 	bne	r2,zero,8247e4c <in_pcbconnect+0xd0>
      return (EADDRNOTAVAIL);
 8247e44:	00801f44 	movi	r2,125
 8247e48:	00003f06 	br	8247f48 <in_pcbconnect+0x1cc>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 8247e4c:	e0bffe17 	ldw	r2,-8(fp)
 8247e50:	10800417 	ldw	r2,16(r2)
 8247e54:	10000f1e 	bne	r2,zero,8247e94 <in_pcbconnect+0x118>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 8247e58:	e0bffb17 	ldw	r2,-20(fp)
 8247e5c:	10800117 	ldw	r2,4(r2)
 8247e60:	e0fffd04 	addi	r3,fp,-12
 8247e64:	180b883a 	mov	r5,r3
 8247e68:	1009883a 	mov	r4,r2
 8247e6c:	824093c0 	call	824093c <iproute>
 8247e70:	e0bffc15 	stw	r2,-16(fp)
      if (!npnet)
 8247e74:	e0bffc17 	ldw	r2,-16(fp)
 8247e78:	1000021e 	bne	r2,zero,8247e84 <in_pcbconnect+0x108>
         return EADDRNOTAVAIL;
 8247e7c:	00801f44 	movi	r2,125
 8247e80:	00003106 	br	8247f48 <in_pcbconnect+0x1cc>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 8247e84:	e0bffc17 	ldw	r2,-16(fp)
 8247e88:	10800a17 	ldw	r2,40(r2)
 8247e8c:	e0bffa15 	stw	r2,-24(fp)
 8247e90:	00000306 	br	8247ea0 <in_pcbconnect+0x124>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 8247e94:	e0bffe17 	ldw	r2,-8(fp)
 8247e98:	10800417 	ldw	r2,16(r2)
 8247e9c:	e0bffa15 	stw	r2,-24(fp)

   if (in_pcblookup(inp->inp_head,
 8247ea0:	e0bffe17 	ldw	r2,-8(fp)
 8247ea4:	10c00217 	ldw	r3,8(r2)
 8247ea8:	e0bffb17 	ldw	r2,-20(fp)
 8247eac:	11000117 	ldw	r4,4(r2)
       sin->sin_addr.s_addr,
       sin->sin_port,
 8247eb0:	e0bffb17 	ldw	r2,-20(fp)
 8247eb4:	1080008b 	ldhu	r2,2(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 8247eb8:	117fffcc 	andi	r5,r2,65535
       sin->sin_addr.s_addr,
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
 8247ebc:	e0bffe17 	ldw	r2,-8(fp)
 8247ec0:	1080078b 	ldhu	r2,30(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 8247ec4:	10bfffcc 	andi	r2,r2,65535
 8247ec8:	d8000115 	stw	zero,4(sp)
 8247ecc:	d8800015 	stw	r2,0(sp)
 8247ed0:	e1fffa17 	ldw	r7,-24(fp)
 8247ed4:	280d883a 	mov	r6,r5
 8247ed8:	200b883a 	mov	r5,r4
 8247edc:	1809883a 	mov	r4,r3
 8247ee0:	82480c00 	call	82480c0 <in_pcblookup>
 8247ee4:	10000226 	beq	r2,zero,8247ef0 <in_pcbconnect+0x174>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 8247ee8:	00801c04 	movi	r2,112
 8247eec:	00001606 	br	8247f48 <in_pcbconnect+0x1cc>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 8247ef0:	e0bffe17 	ldw	r2,-8(fp)
 8247ef4:	10800417 	ldw	r2,16(r2)
 8247ef8:	10000a1e 	bne	r2,zero,8247f24 <in_pcbconnect+0x1a8>
   {
      if (inp->inp_lport == 0)
 8247efc:	e0bffe17 	ldw	r2,-8(fp)
 8247f00:	1080078b 	ldhu	r2,30(r2)
 8247f04:	10bfffcc 	andi	r2,r2,65535
 8247f08:	1000031e 	bne	r2,zero,8247f18 <in_pcbconnect+0x19c>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 8247f0c:	000b883a 	mov	r5,zero
 8247f10:	e13ffe17 	ldw	r4,-8(fp)
 8247f14:	8247b6c0 	call	8247b6c <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 8247f18:	e0bffe17 	ldw	r2,-8(fp)
 8247f1c:	e0fffa17 	ldw	r3,-24(fp)
 8247f20:	10c00415 	stw	r3,16(r2)
   }
   inp->inp_faddr = sin->sin_addr;
 8247f24:	e0bffe17 	ldw	r2,-8(fp)
 8247f28:	e0fffb17 	ldw	r3,-20(fp)
 8247f2c:	18c00117 	ldw	r3,4(r3)
 8247f30:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 8247f34:	e0bffb17 	ldw	r2,-20(fp)
 8247f38:	10c0008b 	ldhu	r3,2(r2)
 8247f3c:	e0bffe17 	ldw	r2,-8(fp)
 8247f40:	10c0070d 	sth	r3,28(r2)
   return 0;
 8247f44:	0005883a 	mov	r2,zero
}
 8247f48:	e037883a 	mov	sp,fp
 8247f4c:	dfc00117 	ldw	ra,4(sp)
 8247f50:	df000017 	ldw	fp,0(sp)
 8247f54:	dec00204 	addi	sp,sp,8
 8247f58:	f800283a 	ret

08247f5c <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 8247f5c:	defffd04 	addi	sp,sp,-12
 8247f60:	dfc00215 	stw	ra,8(sp)
 8247f64:	df000115 	stw	fp,4(sp)
 8247f68:	df000104 	addi	fp,sp,4
 8247f6c:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 8247f70:	e0bfff17 	ldw	r2,-4(fp)
 8247f74:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 8247f78:	e0bfff17 	ldw	r2,-4(fp)
 8247f7c:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 8247f80:	e0bfff17 	ldw	r2,-4(fp)
 8247f84:	10800817 	ldw	r2,32(r2)
 8247f88:	1080088b 	ldhu	r2,34(r2)
 8247f8c:	10bfffcc 	andi	r2,r2,65535
 8247f90:	1080004c 	andi	r2,r2,1
 8247f94:	10000226 	beq	r2,zero,8247fa0 <in_pcbdisconnect+0x44>
      in_pcbdetach (inp);
 8247f98:	e13fff17 	ldw	r4,-4(fp)
 8247f9c:	8247b140 	call	8247b14 <in_pcbdetach>
}
 8247fa0:	0001883a 	nop
 8247fa4:	e037883a 	mov	sp,fp
 8247fa8:	dfc00117 	ldw	ra,4(sp)
 8247fac:	df000017 	ldw	fp,0(sp)
 8247fb0:	dec00204 	addi	sp,sp,8
 8247fb4:	f800283a 	ret

08247fb8 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8247fb8:	defffb04 	addi	sp,sp,-20
 8247fbc:	dfc00415 	stw	ra,16(sp)
 8247fc0:	df000315 	stw	fp,12(sp)
 8247fc4:	df000304 	addi	fp,sp,12
 8247fc8:	e13ffe15 	stw	r4,-8(fp)
 8247fcc:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 8247fd0:	e0bfff17 	ldw	r2,-4(fp)
 8247fd4:	00c00404 	movi	r3,16
 8247fd8:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 8247fdc:	e0bfff17 	ldw	r2,-4(fp)
 8247fe0:	10800317 	ldw	r2,12(r2)
 8247fe4:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 8247fe8:	01800404 	movi	r6,16
 8247fec:	000b883a 	mov	r5,zero
 8247ff0:	e13ffd17 	ldw	r4,-12(fp)
 8247ff4:	8202cb00 	call	8202cb0 <memset>
   sin->sin_family = AF_INET;
 8247ff8:	e0bffd17 	ldw	r2,-12(fp)
 8247ffc:	00c00084 	movi	r3,2
 8248000:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_lport;
 8248004:	e0bffe17 	ldw	r2,-8(fp)
 8248008:	10c0078b 	ldhu	r3,30(r2)
 824800c:	e0bffd17 	ldw	r2,-12(fp)
 8248010:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 8248014:	e0bffd17 	ldw	r2,-12(fp)
 8248018:	e0fffe17 	ldw	r3,-8(fp)
 824801c:	18c00417 	ldw	r3,16(r3)
 8248020:	10c00115 	stw	r3,4(r2)
}
 8248024:	0001883a 	nop
 8248028:	e037883a 	mov	sp,fp
 824802c:	dfc00117 	ldw	ra,4(sp)
 8248030:	df000017 	ldw	fp,0(sp)
 8248034:	dec00204 	addi	sp,sp,8
 8248038:	f800283a 	ret

0824803c <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 824803c:	defffb04 	addi	sp,sp,-20
 8248040:	dfc00415 	stw	ra,16(sp)
 8248044:	df000315 	stw	fp,12(sp)
 8248048:	df000304 	addi	fp,sp,12
 824804c:	e13ffe15 	stw	r4,-8(fp)
 8248050:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 8248054:	e0bfff17 	ldw	r2,-4(fp)
 8248058:	00c00404 	movi	r3,16
 824805c:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 8248060:	e0bfff17 	ldw	r2,-4(fp)
 8248064:	10800317 	ldw	r2,12(r2)
 8248068:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 824806c:	01800404 	movi	r6,16
 8248070:	000b883a 	mov	r5,zero
 8248074:	e13ffd17 	ldw	r4,-12(fp)
 8248078:	8202cb00 	call	8202cb0 <memset>
   sin->sin_family = AF_INET;
 824807c:	e0bffd17 	ldw	r2,-12(fp)
 8248080:	00c00084 	movi	r3,2
 8248084:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_fport;
 8248088:	e0bffe17 	ldw	r2,-8(fp)
 824808c:	10c0070b 	ldhu	r3,28(r2)
 8248090:	e0bffd17 	ldw	r2,-12(fp)
 8248094:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 8248098:	e0bffd17 	ldw	r2,-12(fp)
 824809c:	e0fffe17 	ldw	r3,-8(fp)
 82480a0:	18c00317 	ldw	r3,12(r3)
 82480a4:	10c00115 	stw	r3,4(r2)
}
 82480a8:	0001883a 	nop
 82480ac:	e037883a 	mov	sp,fp
 82480b0:	dfc00117 	ldw	ra,4(sp)
 82480b4:	df000017 	ldw	fp,0(sp)
 82480b8:	dec00204 	addi	sp,sp,8
 82480bc:	f800283a 	ret

082480c0 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 82480c0:	defff504 	addi	sp,sp,-44
 82480c4:	df000a15 	stw	fp,40(sp)
 82480c8:	df000a04 	addi	fp,sp,40
 82480cc:	e13ffb15 	stw	r4,-20(fp)
 82480d0:	e17ffc15 	stw	r5,-16(fp)
 82480d4:	3007883a 	mov	r3,r6
 82480d8:	e1fffe15 	stw	r7,-8(fp)
 82480dc:	e0800117 	ldw	r2,4(fp)
 82480e0:	e0fffd0d 	sth	r3,-12(fp)
 82480e4:	e0bfff0d 	sth	r2,-4(fp)
   struct inpcb * inp, *   match =  0;
 82480e8:	e03ff715 	stw	zero,-36(fp)
   unshort  fport =  xfport; 
 82480ec:	e0bffd0b 	ldhu	r2,-12(fp)
 82480f0:	e0bffa0d 	sth	r2,-24(fp)
   unshort  lport =  xlport;
 82480f4:	e0bfff0b 	ldhu	r2,-4(fp)
 82480f8:	e0bffa8d 	sth	r2,-22(fp)
   int   matchwild   =  3;
 82480fc:	008000c4 	movi	r2,3
 8248100:	e0bff815 	stw	r2,-32(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 8248104:	e0bffb17 	ldw	r2,-20(fp)
 8248108:	10800017 	ldw	r2,0(r2)
 824810c:	e0bff615 	stw	r2,-40(fp)
 8248110:	00004f06 	br	8248250 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 8248114:	e0bff617 	ldw	r2,-40(fp)
 8248118:	1080078b 	ldhu	r2,30(r2)
 824811c:	10ffffcc 	andi	r3,r2,65535
 8248120:	e0bffa8b 	ldhu	r2,-22(fp)
 8248124:	1880401e 	bne	r3,r2,8248228 <in_pcblookup+0x168>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 8248128:	e0bff617 	ldw	r2,-40(fp)
 824812c:	10800817 	ldw	r2,32(r2)
 8248130:	10800517 	ldw	r2,20(r2)
 8248134:	108000a0 	cmpeqi	r2,r2,2
 8248138:	10003d26 	beq	r2,zero,8248230 <in_pcblookup+0x170>
         continue;

      wildcard = 0;
 824813c:	e03ff915 	stw	zero,-28(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 8248140:	e0bff617 	ldw	r2,-40(fp)
 8248144:	10800417 	ldw	r2,16(r2)
 8248148:	10000b26 	beq	r2,zero,8248178 <in_pcblookup+0xb8>
      {
         if (laddr == INADDR_ANY)
 824814c:	e0bffe17 	ldw	r2,-8(fp)
 8248150:	1000041e 	bne	r2,zero,8248164 <in_pcblookup+0xa4>
            wildcard++;
 8248154:	e0bff917 	ldw	r2,-28(fp)
 8248158:	10800044 	addi	r2,r2,1
 824815c:	e0bff915 	stw	r2,-28(fp)
 8248160:	00000a06 	br	824818c <in_pcblookup+0xcc>
         else if (inp->inp_laddr.s_addr != laddr)
 8248164:	e0bff617 	ldw	r2,-40(fp)
 8248168:	10c00417 	ldw	r3,16(r2)
 824816c:	e0bffe17 	ldw	r2,-8(fp)
 8248170:	18800626 	beq	r3,r2,824818c <in_pcblookup+0xcc>
            continue;
 8248174:	00003306 	br	8248244 <in_pcblookup+0x184>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 8248178:	e0bffe17 	ldw	r2,-8(fp)
 824817c:	10000326 	beq	r2,zero,824818c <in_pcblookup+0xcc>
            wildcard++;
 8248180:	e0bff917 	ldw	r2,-28(fp)
 8248184:	10800044 	addi	r2,r2,1
 8248188:	e0bff915 	stw	r2,-28(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 824818c:	e0bff617 	ldw	r2,-40(fp)
 8248190:	10800317 	ldw	r2,12(r2)
 8248194:	10001026 	beq	r2,zero,82481d8 <in_pcblookup+0x118>
      {
         if (faddr == INADDR_ANY)
 8248198:	e0bffc17 	ldw	r2,-16(fp)
 824819c:	1000041e 	bne	r2,zero,82481b0 <in_pcblookup+0xf0>
            wildcard++;
 82481a0:	e0bff917 	ldw	r2,-28(fp)
 82481a4:	10800044 	addi	r2,r2,1
 82481a8:	e0bff915 	stw	r2,-28(fp)
 82481ac:	00000f06 	br	82481ec <in_pcblookup+0x12c>
         else if (inp->inp_faddr.s_addr != faddr ||
 82481b0:	e0bff617 	ldw	r2,-40(fp)
 82481b4:	10c00317 	ldw	r3,12(r2)
 82481b8:	e0bffc17 	ldw	r2,-16(fp)
 82481bc:	18801e1e 	bne	r3,r2,8248238 <in_pcblookup+0x178>
             inp->inp_fport != fport)
 82481c0:	e0bff617 	ldw	r2,-40(fp)
 82481c4:	1080070b 	ldhu	r2,28(r2)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
      {
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
 82481c8:	10ffffcc 	andi	r3,r2,65535
 82481cc:	e0bffa0b 	ldhu	r2,-24(fp)
 82481d0:	18800626 	beq	r3,r2,82481ec <in_pcblookup+0x12c>
             inp->inp_fport != fport)
         {
            continue;
 82481d4:	00001806 	br	8248238 <in_pcblookup+0x178>
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 82481d8:	e0bffc17 	ldw	r2,-16(fp)
 82481dc:	10000326 	beq	r2,zero,82481ec <in_pcblookup+0x12c>
            wildcard++;
 82481e0:	e0bff917 	ldw	r2,-28(fp)
 82481e4:	10800044 	addi	r2,r2,1
 82481e8:	e0bff915 	stw	r2,-28(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 82481ec:	e0bff917 	ldw	r2,-28(fp)
 82481f0:	10000326 	beq	r2,zero,8248200 <in_pcblookup+0x140>
 82481f4:	e0800217 	ldw	r2,8(fp)
 82481f8:	1080004c 	andi	r2,r2,1
 82481fc:	10001026 	beq	r2,zero,8248240 <in_pcblookup+0x180>
         continue;
      if (wildcard < matchwild) 
 8248200:	e0fff917 	ldw	r3,-28(fp)
 8248204:	e0bff817 	ldw	r2,-32(fp)
 8248208:	18800e0e 	bge	r3,r2,8248244 <in_pcblookup+0x184>
      {
         match = inp;
 824820c:	e0bff617 	ldw	r2,-40(fp)
 8248210:	e0bff715 	stw	r2,-36(fp)
         matchwild = wildcard;
 8248214:	e0bff917 	ldw	r2,-28(fp)
 8248218:	e0bff815 	stw	r2,-32(fp)
         if (matchwild == 0)
 824821c:	e0bff817 	ldw	r2,-32(fp)
 8248220:	10000f26 	beq	r2,zero,8248260 <in_pcblookup+0x1a0>
 8248224:	00000706 	br	8248244 <in_pcblookup+0x184>
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
   {
      if (inp->inp_lport != lport)
         continue;
 8248228:	0001883a 	nop
 824822c:	00000506 	br	8248244 <in_pcblookup+0x184>

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
         continue;
 8248230:	0001883a 	nop
 8248234:	00000306 	br	8248244 <in_pcblookup+0x184>
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
             inp->inp_fport != fport)
         {
            continue;
 8248238:	0001883a 	nop
 824823c:	00000106 	br	8248244 <in_pcblookup+0x184>
      {
         if (faddr != INADDR_ANY)
            wildcard++;
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
         continue;
 8248240:	0001883a 	nop
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 8248244:	e0bff617 	ldw	r2,-40(fp)
 8248248:	10800017 	ldw	r2,0(r2)
 824824c:	e0bff615 	stw	r2,-40(fp)
 8248250:	e0fff617 	ldw	r3,-40(fp)
 8248254:	e0bffb17 	ldw	r2,-20(fp)
 8248258:	18bfae1e 	bne	r3,r2,8248114 <in_pcblookup+0x54>
 824825c:	00000106 	br	8248264 <in_pcblookup+0x1a4>
      if (wildcard < matchwild) 
      {
         match = inp;
         matchwild = wildcard;
         if (matchwild == 0)
            break;
 8248260:	0001883a 	nop
      }
   }
   if (match == NULL)
 8248264:	e0bff717 	ldw	r2,-36(fp)
 8248268:	1000021e 	bne	r2,zero,8248274 <in_pcblookup+0x1b4>
      return match;
 824826c:	e0bff717 	ldw	r2,-36(fp)
 8248270:	00002406 	br	8248304 <in_pcblookup+0x244>

   if (head->inp_next == match)  /* got cache hit? */
 8248274:	e0bffb17 	ldw	r2,-20(fp)
 8248278:	10c00017 	ldw	r3,0(r2)
 824827c:	e0bff717 	ldw	r2,-36(fp)
 8248280:	1880041e 	bne	r3,r2,8248294 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 8248284:	d0a0d217 	ldw	r2,-31928(gp)
 8248288:	10800044 	addi	r2,r2,1
 824828c:	d0a0d215 	stw	r2,-31928(gp)
 8248290:	00001b06 	br	8248300 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 8248294:	d0a0d317 	ldw	r2,-31924(gp)
 8248298:	10800044 	addi	r2,r2,1
 824829c:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 82482a0:	e0bff717 	ldw	r2,-36(fp)
 82482a4:	10800017 	ldw	r2,0(r2)
 82482a8:	e0fff717 	ldw	r3,-36(fp)
 82482ac:	18c00117 	ldw	r3,4(r3)
 82482b0:	10c00115 	stw	r3,4(r2)
      match->inp_prev->inp_next = match->inp_next;
 82482b4:	e0bff717 	ldw	r2,-36(fp)
 82482b8:	10800117 	ldw	r2,4(r2)
 82482bc:	e0fff717 	ldw	r3,-36(fp)
 82482c0:	18c00017 	ldw	r3,0(r3)
 82482c4:	10c00015 	stw	r3,0(r2)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 82482c8:	e0bffb17 	ldw	r2,-20(fp)
 82482cc:	10c00017 	ldw	r3,0(r2)
 82482d0:	e0bff717 	ldw	r2,-36(fp)
 82482d4:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 82482d8:	e0bffb17 	ldw	r2,-20(fp)
 82482dc:	e0fff717 	ldw	r3,-36(fp)
 82482e0:	10c00015 	stw	r3,0(r2)
      match->inp_prev = head;
 82482e4:	e0bff717 	ldw	r2,-36(fp)
 82482e8:	e0fffb17 	ldw	r3,-20(fp)
 82482ec:	10c00115 	stw	r3,4(r2)
      match->inp_next->inp_prev = match;
 82482f0:	e0bff717 	ldw	r2,-36(fp)
 82482f4:	10800017 	ldw	r2,0(r2)
 82482f8:	e0fff717 	ldw	r3,-36(fp)
 82482fc:	10c00115 	stw	r3,4(r2)
   }
   return (match);
 8248300:	e0bff717 	ldw	r2,-36(fp)
}
 8248304:	e037883a 	mov	sp,fp
 8248308:	df000017 	ldw	fp,0(sp)
 824830c:	dec00104 	addi	sp,sp,4
 8248310:	f800283a 	ret

08248314 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 8248314:	defffe04 	addi	sp,sp,-8
 8248318:	df000115 	stw	fp,4(sp)
 824831c:	df000104 	addi	fp,sp,4
 8248320:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 8248324:	e0bfff17 	ldw	r2,-4(fp)
 8248328:	d0a0d715 	stw	r2,-31908(gp)
}
 824832c:	0001883a 	nop
 8248330:	e037883a 	mov	sp,fp
 8248334:	df000017 	ldw	fp,0(sp)
 8248338:	dec00104 	addi	sp,sp,4
 824833c:	f800283a 	ret

08248340 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 8248340:	deffff04 	addi	sp,sp,-4
 8248344:	df000015 	stw	fp,0(sp)
 8248348:	d839883a 	mov	fp,sp
   return vfopen_error;
 824834c:	d0a0d717 	ldw	r2,-31908(gp)
}
 8248350:	e037883a 	mov	sp,fp
 8248354:	df000017 	ldw	fp,0(sp)
 8248358:	dec00104 	addi	sp,sp,4
 824835c:	f800283a 	ret

08248360 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 8248360:	defffd04 	addi	sp,sp,-12
 8248364:	dfc00215 	stw	ra,8(sp)
 8248368:	df000115 	stw	fp,4(sp)
 824836c:	df000104 	addi	fp,sp,4
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 8248370:	d0a0d917 	ldw	r2,-31900(gp)
 8248374:	10803ff0 	cmpltui	r2,r2,255
 8248378:	1000021e 	bne	r2,zero,8248384 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 824837c:	0005883a 	mov	r2,zero
 8248380:	00000e06 	br	82483bc <vf_alloc_and_link_vop+0x5c>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 8248384:	01000504 	movi	r4,20
 8248388:	822dda00 	call	822dda0 <npalloc>
 824838c:	e0bfff15 	stw	r2,-4(fp)

   /* if the allocation succeeded */
   if (vop)
 8248390:	e0bfff17 	ldw	r2,-4(fp)
 8248394:	10000826 	beq	r2,zero,82483b8 <vf_alloc_and_link_vop+0x58>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 8248398:	d0e0d517 	ldw	r3,-31916(gp)
 824839c:	e0bfff17 	ldw	r2,-4(fp)
 82483a0:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 82483a4:	e0bfff17 	ldw	r2,-4(fp)
 82483a8:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 82483ac:	d0a0d917 	ldw	r2,-31900(gp)
 82483b0:	10800044 	addi	r2,r2,1
 82483b4:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 82483b8:	e0bfff17 	ldw	r2,-4(fp)
}
 82483bc:	e037883a 	mov	sp,fp
 82483c0:	dfc00117 	ldw	ra,4(sp)
 82483c4:	df000017 	ldw	fp,0(sp)
 82483c8:	dec00204 	addi	sp,sp,8
 82483cc:	f800283a 	ret

082483d0 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 82483d0:	defff904 	addi	sp,sp,-28
 82483d4:	dfc00615 	stw	ra,24(sp)
 82483d8:	df000515 	stw	fp,20(sp)
 82483dc:	df000504 	addi	fp,sp,20
 82483e0:	e13fff15 	stw	r4,-4(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 82483e4:	d0e0da17 	ldw	r3,-31896(gp)
 82483e8:	e0bfff17 	ldw	r2,-4(fp)
 82483ec:	1885883a 	add	r2,r3,r2
 82483f0:	00ffffd4 	movui	r3,65535
 82483f4:	1880022e 	bgeu	r3,r2,8248400 <vf_alloc_buffer+0x30>
      return NULL;
 82483f8:	0005883a 	mov	r2,zero
 82483fc:	00002106 	br	8248484 <vf_alloc_buffer+0xb4>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 8248400:	00800104 	movi	r2,4
 8248404:	e0bffb15 	stw	r2,-20(fp)
   int_size = sizeof(unsigned int);
 8248408:	00800104 	movi	r2,4
 824840c:	e0bffc15 	stw	r2,-16(fp)
   if (long_size > int_size)
 8248410:	e0bffb17 	ldw	r2,-20(fp)
 8248414:	e0fffc17 	ldw	r3,-16(fp)
 8248418:	1880102e 	bgeu	r3,r2,824845c <vf_alloc_buffer+0x8c>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 824841c:	e0bffc17 	ldw	r2,-16(fp)
 8248420:	108000a0 	cmpeqi	r2,r2,2
 8248424:	10000826 	beq	r2,zero,8248448 <vf_alloc_buffer+0x78>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 8248428:	00bffff4 	movhi	r2,65535
 824842c:	e0bffd15 	stw	r2,-12(fp)
         break;
 8248430:	0001883a 	nop
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 8248434:	e0ffff17 	ldw	r3,-4(fp)
 8248438:	e0bffd17 	ldw	r2,-12(fp)
 824843c:	1884703a 	and	r2,r3,r2
 8248440:	10000626 	beq	r2,zero,824845c <vf_alloc_buffer+0x8c>
 8248444:	00000306 	br	8248454 <vf_alloc_buffer+0x84>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 8248448:	822d1c80 	call	822d1c8 <dtrap>
         return NULL;
 824844c:	0005883a 	mov	r2,zero
 8248450:	00000c06 	br	8248484 <vf_alloc_buffer+0xb4>
      }

      if (size & mem_mask)
         return NULL;
 8248454:	0005883a 	mov	r2,zero
 8248458:	00000a06 	br	8248484 <vf_alloc_buffer+0xb4>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 824845c:	e13fff17 	ldw	r4,-4(fp)
 8248460:	822dda00 	call	822dda0 <npalloc>
 8248464:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (buffer)
 8248468:	e0bffe17 	ldw	r2,-8(fp)
 824846c:	10000426 	beq	r2,zero,8248480 <vf_alloc_buffer+0xb0>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 8248470:	d0e0da17 	ldw	r3,-31896(gp)
 8248474:	e0bfff17 	ldw	r2,-4(fp)
 8248478:	1885883a 	add	r2,r3,r2
 824847c:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 8248480:	e0bffe17 	ldw	r2,-8(fp)
}
 8248484:	e037883a 	mov	sp,fp
 8248488:	dfc00117 	ldw	ra,4(sp)
 824848c:	df000017 	ldw	fp,0(sp)
 8248490:	dec00204 	addi	sp,sp,8
 8248494:	f800283a 	ret

08248498 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 8248498:	defffc04 	addi	sp,sp,-16
 824849c:	dfc00315 	stw	ra,12(sp)
 82484a0:	df000215 	stw	fp,8(sp)
 82484a4:	df000204 	addi	fp,sp,8
 82484a8:	e13ffe15 	stw	r4,-8(fp)
 82484ac:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 82484b0:	e0bffe17 	ldw	r2,-8(fp)
 82484b4:	10000226 	beq	r2,zero,82484c0 <vf_free_buffer+0x28>
      npfree(buffer);
 82484b8:	e13ffe17 	ldw	r4,-8(fp)
 82484bc:	822ddd40 	call	822ddd4 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 82484c0:	d0e0da17 	ldw	r3,-31896(gp)
 82484c4:	e0bfff17 	ldw	r2,-4(fp)
 82484c8:	1885c83a 	sub	r2,r3,r2
 82484cc:	d0a0da15 	stw	r2,-31896(gp)
}
 82484d0:	0001883a 	nop
 82484d4:	e037883a 	mov	sp,fp
 82484d8:	dfc00117 	ldw	ra,4(sp)
 82484dc:	df000017 	ldw	fp,0(sp)
 82484e0:	dec00204 	addi	sp,sp,8
 82484e4:	f800283a 	ret

082484e8 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 82484e8:	defff904 	addi	sp,sp,-28
 82484ec:	dfc00615 	stw	ra,24(sp)
 82484f0:	df000515 	stw	fp,20(sp)
 82484f4:	df000504 	addi	fp,sp,20
 82484f8:	e13ffe15 	stw	r4,-8(fp)
 82484fc:	e17fff15 	stw	r5,-4(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 8248500:	0009883a 	mov	r4,zero
 8248504:	82483140 	call	8248314 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 8248508:	01400fc4 	movi	r5,63
 824850c:	e13ffe17 	ldw	r4,-8(fp)
 8248510:	82032800 	call	8203280 <strchr>
 8248514:	10000326 	beq	r2,zero,8248524 <vfopen_locked+0x3c>
   {
      dtrap();
 8248518:	822d1c80 	call	822d1c8 <dtrap>
      return NULL;
 824851c:	0005883a 	mov	r2,zero
 8248520:	0000ba06 	br	824880c <vfopen_locked+0x324>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 8248524:	e13ffe17 	ldw	r4,-8(fp)
 8248528:	824976c0 	call	824976c <vfslookup_locked>
 824852c:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 8248530:	e0bffc17 	ldw	r2,-16(fp)
 8248534:	10004a26 	beq	r2,zero,8248660 <vfopen_locked+0x178>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 8248538:	e0bfff17 	ldw	r2,-4(fp)
 824853c:	10800003 	ldbu	r2,0(r2)
 8248540:	10803fcc 	andi	r2,r2,255
 8248544:	1080201c 	xori	r2,r2,128
 8248548:	10bfe004 	addi	r2,r2,-128
 824854c:	10801dd8 	cmpnei	r2,r2,119
 8248550:	1000091e 	bne	r2,zero,8248578 <vfopen_locked+0x90>
 8248554:	e0bffc17 	ldw	r2,-16(fp)
 8248558:	1080058b 	ldhu	r2,22(r2)
 824855c:	10bfffcc 	andi	r2,r2,65535
 8248560:	1080080c 	andi	r2,r2,32
 8248564:	1000041e 	bne	r2,zero,8248578 <vfopen_locked+0x90>
      {
         set_vfopen_error(ENP_FILEIO);
 8248568:	013ff984 	movi	r4,-26
 824856c:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248570:	0005883a 	mov	r2,zero
 8248574:	0000a506 	br	824880c <vfopen_locked+0x324>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248578:	82483600 	call	8248360 <vf_alloc_and_link_vop>
 824857c:	e0bffd15 	stw	r2,-12(fp)

      /* check for failure */
      if (!vop)
 8248580:	e0bffd17 	ldw	r2,-12(fp)
 8248584:	1000041e 	bne	r2,zero,8248598 <vfopen_locked+0xb0>
      {
         set_vfopen_error(ENP_NOMEM);
 8248588:	013ffb04 	movi	r4,-20
 824858c:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248590:	0005883a 	mov	r2,zero
 8248594:	00009d06 	br	824880c <vfopen_locked+0x324>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 8248598:	e0bffd17 	ldw	r2,-12(fp)
 824859c:	e0fffc17 	ldw	r3,-16(fp)
 82485a0:	10c00115 	stw	r3,4(r2)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 82485a4:	e0bffc17 	ldw	r2,-16(fp)
 82485a8:	10c00617 	ldw	r3,24(r2)
 82485ac:	e0bffd17 	ldw	r2,-12(fp)
 82485b0:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 82485b4:	e0bfff17 	ldw	r2,-4(fp)
 82485b8:	10800003 	ldbu	r2,0(r2)
 82485bc:	10803fcc 	andi	r2,r2,255
 82485c0:	1080201c 	xori	r2,r2,128
 82485c4:	10bfe004 	addi	r2,r2,-128
 82485c8:	10801858 	cmpnei	r2,r2,97
 82485cc:	10000a1e 	bne	r2,zero,82485f8 <vfopen_locked+0x110>
      {
         if (vfp->data)
 82485d0:	e0bffc17 	ldw	r2,-16(fp)
 82485d4:	10800617 	ldw	r2,24(r2)
 82485d8:	10000726 	beq	r2,zero,82485f8 <vfopen_locked+0x110>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 82485dc:	e0bffc17 	ldw	r2,-16(fp)
 82485e0:	10c00617 	ldw	r3,24(r2)
 82485e4:	e0bffc17 	ldw	r2,-16(fp)
 82485e8:	10800817 	ldw	r2,32(r2)
 82485ec:	1887883a 	add	r3,r3,r2
 82485f0:	e0bffd17 	ldw	r2,-12(fp)
 82485f4:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 82485f8:	e0bfff17 	ldw	r2,-4(fp)
 82485fc:	10800003 	ldbu	r2,0(r2)
 8248600:	10803fcc 	andi	r2,r2,255
 8248604:	1080201c 	xori	r2,r2,128
 8248608:	10bfe004 	addi	r2,r2,-128
 824860c:	10801dd8 	cmpnei	r2,r2,119
 8248610:	1000111e 	bne	r2,zero,8248658 <vfopen_locked+0x170>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 8248614:	e0bffc17 	ldw	r2,-16(fp)
 8248618:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 824861c:	e0bffc17 	ldw	r2,-16(fp)
 8248620:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 8248624:	e0bffc17 	ldw	r2,-16(fp)
 8248628:	1080058b 	ldhu	r2,22(r2)
 824862c:	10808014 	ori	r2,r2,512
 8248630:	1007883a 	mov	r3,r2
 8248634:	e0bffc17 	ldw	r2,-16(fp)
 8248638:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 824863c:	e0bffc17 	ldw	r2,-16(fp)
 8248640:	10c0058b 	ldhu	r3,22(r2)
 8248644:	00bfff84 	movi	r2,-2
 8248648:	1884703a 	and	r2,r3,r2
 824864c:	1007883a 	mov	r3,r2
 8248650:	e0bffc17 	ldw	r2,-16(fp)
 8248654:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 8248658:	e0bffd17 	ldw	r2,-12(fp)
 824865c:	00006b06 	br	824880c <vfopen_locked+0x324>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 8248660:	e0bfff17 	ldw	r2,-4(fp)
 8248664:	10800003 	ldbu	r2,0(r2)
 8248668:	10803fcc 	andi	r2,r2,255
 824866c:	1080201c 	xori	r2,r2,128
 8248670:	10bfe004 	addi	r2,r2,-128
 8248674:	10801ca0 	cmpeqi	r2,r2,114
 8248678:	1000121e 	bne	r2,zero,82486c4 <vfopen_locked+0x1dc>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 824867c:	d0a0d417 	ldw	r2,-31920(gp)
 8248680:	e0bffb15 	stw	r2,-20(fp)
 8248684:	00000d06 	br	82486bc <vfopen_locked+0x1d4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 8248688:	e0bffb17 	ldw	r2,-20(fp)
 824868c:	10800117 	ldw	r2,4(r2)
 8248690:	e17fff17 	ldw	r5,-4(fp)
 8248694:	e13ffe17 	ldw	r4,-8(fp)
 8248698:	103ee83a 	callr	r2
 824869c:	e0bffd15 	stw	r2,-12(fp)
 82486a0:	e0bffd17 	ldw	r2,-12(fp)
 82486a4:	10000226 	beq	r2,zero,82486b0 <vfopen_locked+0x1c8>
         {
            return vop;
 82486a8:	e0bffd17 	ldw	r2,-12(fp)
 82486ac:	00005706 	br	824880c <vfopen_locked+0x324>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 82486b0:	e0bffb17 	ldw	r2,-20(fp)
 82486b4:	10800017 	ldw	r2,0(r2)
 82486b8:	e0bffb15 	stw	r2,-20(fp)
 82486bc:	e0bffb17 	ldw	r2,-20(fp)
 82486c0:	103ff11e 	bne	r2,zero,8248688 <vfopen_locked+0x1a0>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 82486c4:	e0bfff17 	ldw	r2,-4(fp)
 82486c8:	10800003 	ldbu	r2,0(r2)
 82486cc:	10803fcc 	andi	r2,r2,255
 82486d0:	1080201c 	xori	r2,r2,128
 82486d4:	10bfe004 	addi	r2,r2,-128
 82486d8:	10801ca0 	cmpeqi	r2,r2,114
 82486dc:	1000481e 	bne	r2,zero,8248800 <vfopen_locked+0x318>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 82486e0:	d0a0db17 	ldw	r2,-31892(gp)
 82486e4:	10803ff0 	cmpltui	r2,r2,255
 82486e8:	1000041e 	bne	r2,zero,82486fc <vfopen_locked+0x214>
      {
         set_vfopen_error(ENP_NOMEM);
 82486ec:	013ffb04 	movi	r4,-20
 82486f0:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 82486f4:	0005883a 	mov	r2,zero
 82486f8:	00004406 	br	824880c <vfopen_locked+0x324>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 82486fc:	e13ffe17 	ldw	r4,-8(fp)
 8248700:	8203a5c0 	call	8203a5c <strlen>
 8248704:	10800470 	cmpltui	r2,r2,17
 8248708:	1000041e 	bne	r2,zero,824871c <vfopen_locked+0x234>
      {
         set_vfopen_error(ENP_PARAM);
 824870c:	013ffd84 	movi	r4,-10
 8248710:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248714:	0005883a 	mov	r2,zero
 8248718:	00003c06 	br	824880c <vfopen_locked+0x324>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 824871c:	01000b04 	movi	r4,44
 8248720:	822dda00 	call	822dda0 <npalloc>
 8248724:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 8248728:	e0bffc17 	ldw	r2,-16(fp)
 824872c:	1000041e 	bne	r2,zero,8248740 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_NOMEM);
 8248730:	013ffb04 	movi	r4,-20
 8248734:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248738:	0005883a 	mov	r2,zero
 824873c:	00003306 	br	824880c <vfopen_locked+0x324>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248740:	82483600 	call	8248360 <vf_alloc_and_link_vop>
 8248744:	e0bffd15 	stw	r2,-12(fp)

      /* check for memory allocation failure */
      if (!vop)
 8248748:	e0bffd17 	ldw	r2,-12(fp)
 824874c:	1000061e 	bne	r2,zero,8248768 <vfopen_locked+0x280>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 8248750:	e13ffc17 	ldw	r4,-16(fp)
 8248754:	822ddd40 	call	822ddd4 <npfree>
         set_vfopen_error(ENP_NOMEM);
 8248758:	013ffb04 	movi	r4,-20
 824875c:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248760:	0005883a 	mov	r2,zero
 8248764:	00002906 	br	824880c <vfopen_locked+0x324>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 8248768:	d0e0d617 	ldw	r3,-31912(gp)
 824876c:	e0bffc17 	ldw	r2,-16(fp)
 8248770:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 8248774:	e0bffc17 	ldw	r2,-16(fp)
 8248778:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 824877c:	d0a0db17 	ldw	r2,-31892(gp)
 8248780:	10800044 	addi	r2,r2,1
 8248784:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 8248788:	e0bffe17 	ldw	r2,-8(fp)
 824878c:	10800003 	ldbu	r2,0(r2)
 8248790:	10803fcc 	andi	r2,r2,255
 8248794:	1080201c 	xori	r2,r2,128
 8248798:	10bfe004 	addi	r2,r2,-128
 824879c:	10800be0 	cmpeqi	r2,r2,47
 82487a0:	1000071e 	bne	r2,zero,82487c0 <vfopen_locked+0x2d8>
 82487a4:	e0bffe17 	ldw	r2,-8(fp)
 82487a8:	10800003 	ldbu	r2,0(r2)
 82487ac:	10803fcc 	andi	r2,r2,255
 82487b0:	1080201c 	xori	r2,r2,128
 82487b4:	10bfe004 	addi	r2,r2,-128
 82487b8:	10801718 	cmpnei	r2,r2,92
 82487bc:	1000031e 	bne	r2,zero,82487cc <vfopen_locked+0x2e4>
         name++;
 82487c0:	e0bffe17 	ldw	r2,-8(fp)
 82487c4:	10800044 	addi	r2,r2,1
 82487c8:	e0bffe15 	stw	r2,-8(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 82487cc:	e0bffc17 	ldw	r2,-16(fp)
 82487d0:	10800104 	addi	r2,r2,4
 82487d4:	e17ffe17 	ldw	r5,-8(fp)
 82487d8:	1009883a 	mov	r4,r2
 82487dc:	824b1b40 	call	824b1b4 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 82487e0:	e0bffc17 	ldw	r2,-16(fp)
 82487e4:	00c0d804 	movi	r3,864
 82487e8:	10c0058d 	sth	r3,22(r2)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 82487ec:	e0bffd17 	ldw	r2,-12(fp)
 82487f0:	e0fffc17 	ldw	r3,-16(fp)
 82487f4:	10c00115 	stw	r3,4(r2)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 82487f8:	e0bffd17 	ldw	r2,-12(fp)
 82487fc:	00000306 	br	824880c <vfopen_locked+0x324>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 8248800:	013ff9c4 	movi	r4,-25
 8248804:	82483140 	call	8248314 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 8248808:	0005883a 	mov	r2,zero

#endif   /* HT_LOCALFS */
}
 824880c:	e037883a 	mov	sp,fp
 8248810:	dfc00117 	ldw	ra,4(sp)
 8248814:	df000017 	ldw	fp,0(sp)
 8248818:	dec00204 	addi	sp,sp,8
 824881c:	f800283a 	ret

08248820 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 8248820:	defffb04 	addi	sp,sp,-20
 8248824:	dfc00415 	stw	ra,16(sp)
 8248828:	df000315 	stw	fp,12(sp)
 824882c:	df000304 	addi	fp,sp,12
 8248830:	e13ffe15 	stw	r4,-8(fp)
 8248834:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248838:	01000144 	movi	r4,5
 824883c:	822d7dc0 	call	822d7dc <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 8248840:	e17fff17 	ldw	r5,-4(fp)
 8248844:	e13ffe17 	ldw	r4,-8(fp)
 8248848:	82484e80 	call	82484e8 <vfopen_locked>
 824884c:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 8248850:	01000144 	movi	r4,5
 8248854:	822d8980 	call	822d898 <post_app_sem>

   return vfd;
 8248858:	e0bffd17 	ldw	r2,-12(fp)
}
 824885c:	e037883a 	mov	sp,fp
 8248860:	dfc00117 	ldw	ra,4(sp)
 8248864:	df000017 	ldw	fp,0(sp)
 8248868:	dec00204 	addi	sp,sp,8
 824886c:	f800283a 	ret

08248870 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 8248870:	defff804 	addi	sp,sp,-32
 8248874:	dfc00715 	stw	ra,28(sp)
 8248878:	df000615 	stw	fp,24(sp)
 824887c:	df000604 	addi	fp,sp,24
 8248880:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 8248884:	e03ffb15 	stw	zero,-20(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 8248888:	d0a0d517 	ldw	r2,-31916(gp)
 824888c:	e0bffa15 	stw	r2,-24(fp)
   while (vtmp)
 8248890:	00000806 	br	82488b4 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 8248894:	e0ffff17 	ldw	r3,-4(fp)
 8248898:	e0bffa17 	ldw	r2,-24(fp)
 824889c:	18800826 	beq	r3,r2,82488c0 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 82488a0:	e0bffa17 	ldw	r2,-24(fp)
 82488a4:	e0bffb15 	stw	r2,-20(fp)
      vtmp = vtmp->next;
 82488a8:	e0bffa17 	ldw	r2,-24(fp)
 82488ac:	10800017 	ldw	r2,0(r2)
 82488b0:	e0bffa15 	stw	r2,-24(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 82488b4:	e0bffa17 	ldw	r2,-24(fp)
 82488b8:	103ff61e 	bne	r2,zero,8248894 <vfclose_locked+0x24>
 82488bc:	00000106 	br	82488c4 <vfclose_locked+0x54>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
         break;
 82488c0:	0001883a 	nop
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 82488c4:	e0ffff17 	ldw	r3,-4(fp)
 82488c8:	e0bffa17 	ldw	r2,-24(fp)
 82488cc:	1880511e 	bne	r3,r2,8248a14 <vfclose_locked+0x1a4>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 82488d0:	e0bfff17 	ldw	r2,-4(fp)
 82488d4:	10800117 	ldw	r2,4(r2)
 82488d8:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 82488dc:	e0bffc17 	ldw	r2,-16(fp)
 82488e0:	10003826 	beq	r2,zero,82489c4 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 82488e4:	e0bffc17 	ldw	r2,-16(fp)
 82488e8:	10800a17 	ldw	r2,40(r2)
 82488ec:	10000826 	beq	r2,zero,8248910 <vfclose_locked+0xa0>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 82488f0:	e0bffc17 	ldw	r2,-16(fp)
 82488f4:	10800a17 	ldw	r2,40(r2)
 82488f8:	e0bffd15 	stw	r2,-12(fp)

         vfs->r_fclose(vfd);
 82488fc:	e0bffd17 	ldw	r2,-12(fp)
 8248900:	10800217 	ldw	r2,8(r2)
 8248904:	e13fff17 	ldw	r4,-4(fp)
 8248908:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 824890c:	00003006 	br	82489d0 <vfclose_locked+0x160>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248910:	e0bffc17 	ldw	r2,-16(fp)
 8248914:	1080058b 	ldhu	r2,22(r2)
 8248918:	10bfffcc 	andi	r2,r2,65535
 824891c:	1080200c 	andi	r2,r2,128
 8248920:	10002a26 	beq	r2,zero,82489cc <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248924:	e0bffc17 	ldw	r2,-16(fp)
 8248928:	10c00917 	ldw	r3,36(r2)
 824892c:	e0bffc17 	ldw	r2,-16(fp)
 8248930:	10800817 	ldw	r2,32(r2)
 8248934:	1885c83a 	sub	r2,r3,r2

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248938:	10804030 	cmpltui	r2,r2,256
 824893c:	1000231e 	bne	r2,zero,82489cc <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
          vfp->data) /* this last test is a sanity check */
 8248940:	e0bffc17 	ldw	r2,-16(fp)
 8248944:	10800617 	ldw	r2,24(r2)
      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248948:	10002026 	beq	r2,zero,82489cc <vfclose_locked+0x15c>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 824894c:	e0bffc17 	ldw	r2,-16(fp)
 8248950:	10800817 	ldw	r2,32(r2)
 8248954:	1009883a 	mov	r4,r2
 8248958:	82483d00 	call	82483d0 <vf_alloc_buffer>
 824895c:	e0bffe15 	stw	r2,-8(fp)

         /* if the allocation worked */
         if (new_buffer)
 8248960:	e0bffe17 	ldw	r2,-8(fp)
 8248964:	10001926 	beq	r2,zero,82489cc <vfclose_locked+0x15c>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8248968:	e0bffc17 	ldw	r2,-16(fp)
 824896c:	10c00617 	ldw	r3,24(r2)
 8248970:	e0bffc17 	ldw	r2,-16(fp)
 8248974:	10800817 	ldw	r2,32(r2)
 8248978:	100d883a 	mov	r6,r2
 824897c:	180b883a 	mov	r5,r3
 8248980:	e13ffe17 	ldw	r4,-8(fp)
 8248984:	8202a0c0 	call	8202a0c <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 8248988:	e0bffc17 	ldw	r2,-16(fp)
 824898c:	10c00617 	ldw	r3,24(r2)
 8248990:	e0bffc17 	ldw	r2,-16(fp)
 8248994:	10800917 	ldw	r2,36(r2)
 8248998:	100b883a 	mov	r5,r2
 824899c:	1809883a 	mov	r4,r3
 82489a0:	82484980 	call	8248498 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 82489a4:	e0bffc17 	ldw	r2,-16(fp)
 82489a8:	e0fffe17 	ldw	r3,-8(fp)
 82489ac:	10c00615 	stw	r3,24(r2)
            vfp->buf_size = vfp->comp_size;
 82489b0:	e0bffc17 	ldw	r2,-16(fp)
 82489b4:	10c00817 	ldw	r3,32(r2)
 82489b8:	e0bffc17 	ldw	r2,-16(fp)
 82489bc:	10c00915 	stw	r3,36(r2)
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 82489c0:	00000206 	br	82489cc <vfclose_locked+0x15c>
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
         break;
 82489c4:	0001883a 	nop
 82489c8:	00000106 	br	82489d0 <vfclose_locked+0x160>
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 82489cc:	0001883a 	nop

   }

   if (vlast)  /* unlink from list of open files */
 82489d0:	e0bffb17 	ldw	r2,-20(fp)
 82489d4:	10000526 	beq	r2,zero,82489ec <vfclose_locked+0x17c>
      vlast->next = vtmp->next;
 82489d8:	e0bffa17 	ldw	r2,-24(fp)
 82489dc:	10c00017 	ldw	r3,0(r2)
 82489e0:	e0bffb17 	ldw	r2,-20(fp)
 82489e4:	10c00015 	stw	r3,0(r2)
 82489e8:	00000306 	br	82489f8 <vfclose_locked+0x188>
   else
      vfiles = vtmp->next;
 82489ec:	e0bffa17 	ldw	r2,-24(fp)
 82489f0:	10800017 	ldw	r2,0(r2)
 82489f4:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 82489f8:	e13ffa17 	ldw	r4,-24(fp)
 82489fc:	822ddd40 	call	822ddd4 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 8248a00:	d0a0d917 	ldw	r2,-31900(gp)
 8248a04:	10bfffc4 	addi	r2,r2,-1
 8248a08:	d0a0d915 	stw	r2,-31900(gp)
   return;
 8248a0c:	0001883a 	nop
 8248a10:	00000106 	br	8248a18 <vfclose_locked+0x1a8>

#ifdef HT_LOCALFS
      /* default to call on local system */
      fclose((FILE*)vfd);
#endif   /* HT_LOCALFS */
      return;
 8248a14:	0001883a 	nop
   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
   /* decrement the number of open files */
   vfs_open_files--;
   return;
}
 8248a18:	e037883a 	mov	sp,fp
 8248a1c:	dfc00117 	ldw	ra,4(sp)
 8248a20:	df000017 	ldw	fp,0(sp)
 8248a24:	dec00204 	addi	sp,sp,8
 8248a28:	f800283a 	ret

08248a2c <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 8248a2c:	defffd04 	addi	sp,sp,-12
 8248a30:	dfc00215 	stw	ra,8(sp)
 8248a34:	df000115 	stw	fp,4(sp)
 8248a38:	df000104 	addi	fp,sp,4
 8248a3c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248a40:	01000144 	movi	r4,5
 8248a44:	822d7dc0 	call	822d7dc <wait_app_sem>

   vfclose_locked(vfd);
 8248a48:	e13fff17 	ldw	r4,-4(fp)
 8248a4c:	82488700 	call	8248870 <vfclose_locked>

   vfs_unlock();
 8248a50:	01000144 	movi	r4,5
 8248a54:	822d8980 	call	822d898 <post_app_sem>
}
 8248a58:	0001883a 	nop
 8248a5c:	e037883a 	mov	sp,fp
 8248a60:	dfc00117 	ldw	ra,4(sp)
 8248a64:	df000017 	ldw	fp,0(sp)
 8248a68:	dec00204 	addi	sp,sp,8
 8248a6c:	f800283a 	ret

08248a70 <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 8248a70:	defffd04 	addi	sp,sp,-12
 8248a74:	dfc00215 	stw	ra,8(sp)
 8248a78:	df000115 	stw	fp,4(sp)
 8248a7c:	df000104 	addi	fp,sp,4
 8248a80:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248a84:	01000144 	movi	r4,5
 8248a88:	822d7dc0 	call	822d7dc <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 8248a8c:	01020974 	movhi	r4,2085
 8248a90:	21057604 	addi	r4,r4,5592
 8248a94:	82031200 	call	8203120 <puts>

   vfs_unlock();
 8248a98:	01000144 	movi	r4,5
 8248a9c:	822d8980 	call	822d898 <post_app_sem>
   return(0);
 8248aa0:	0005883a 	mov	r2,zero
}
 8248aa4:	e037883a 	mov	sp,fp
 8248aa8:	dfc00117 	ldw	ra,4(sp)
 8248aac:	df000017 	ldw	fp,0(sp)
 8248ab0:	dec00204 	addi	sp,sp,8
 8248ab4:	f800283a 	ret

08248ab8 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 8248ab8:	defff904 	addi	sp,sp,-28
 8248abc:	dfc00615 	stw	ra,24(sp)
 8248ac0:	df000515 	stw	fp,20(sp)
 8248ac4:	df000504 	addi	fp,sp,20
 8248ac8:	e13ffd15 	stw	r4,-12(fp)
 8248acc:	e17ffe15 	stw	r5,-8(fp)
 8248ad0:	e1bfff15 	stw	r6,-4(fp)
   int   c   = EOF;
 8248ad4:	00bfffc4 	movi	r2,-1
 8248ad8:	e0bffb15 	stw	r2,-20(fp)
   char* ret = s;
 8248adc:	e0bffd17 	ldw	r2,-12(fp)
 8248ae0:	e0bffc15 	stw	r2,-16(fp)

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248ae4:	00000b06 	br	8248b14 <vfgets+0x5c>
      if (( *ret ++ = c) == '\n')
 8248ae8:	e0bffc17 	ldw	r2,-16(fp)
 8248aec:	10c00044 	addi	r3,r2,1
 8248af0:	e0fffc15 	stw	r3,-16(fp)
 8248af4:	e0fffb17 	ldw	r3,-20(fp)
 8248af8:	10c00005 	stb	r3,0(r2)
 8248afc:	10800003 	ldbu	r2,0(r2)
 8248b00:	10803fcc 	andi	r2,r2,255
 8248b04:	1080201c 	xori	r2,r2,128
 8248b08:	10bfe004 	addi	r2,r2,-128
 8248b0c:	10800298 	cmpnei	r2,r2,10
 8248b10:	10000c26 	beq	r2,zero,8248b44 <vfgets+0x8c>
char * vfgets(char * s, int lim, VFILE * fp) 
{
   int   c   = EOF;
   char* ret = s;

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248b14:	e0bffe17 	ldw	r2,-8(fp)
 8248b18:	10bfffc4 	addi	r2,r2,-1
 8248b1c:	e0bffe15 	stw	r2,-8(fp)
 8248b20:	e0bffe17 	ldw	r2,-8(fp)
 8248b24:	0080080e 	bge	zero,r2,8248b48 <vfgets+0x90>
 8248b28:	e13fff17 	ldw	r4,-4(fp)
 8248b2c:	82497240 	call	8249724 <vgetc>
 8248b30:	e0bffb15 	stw	r2,-20(fp)
 8248b34:	e0bffb17 	ldw	r2,-20(fp)
 8248b38:	10bfffd8 	cmpnei	r2,r2,-1
 8248b3c:	103fea1e 	bne	r2,zero,8248ae8 <vfgets+0x30>
 8248b40:	00000106 	br	8248b48 <vfgets+0x90>
      if (( *ret ++ = c) == '\n')
         break;
 8248b44:	0001883a 	nop
   *ret = '\0';
 8248b48:	e0bffc17 	ldw	r2,-16(fp)
 8248b4c:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 8248b50:	e0bffb17 	ldw	r2,-20(fp)
 8248b54:	10bfffd8 	cmpnei	r2,r2,-1
 8248b58:	1000031e 	bne	r2,zero,8248b68 <vfgets+0xb0>
 8248b5c:	e0fffc17 	ldw	r3,-16(fp)
 8248b60:	e0bffd17 	ldw	r2,-12(fp)
 8248b64:	18800226 	beq	r3,r2,8248b70 <vfgets+0xb8>
 8248b68:	e0bffd17 	ldw	r2,-12(fp)
 8248b6c:	00000106 	br	8248b74 <vfgets+0xbc>
 8248b70:	0005883a 	mov	r2,zero
}
 8248b74:	e037883a 	mov	sp,fp
 8248b78:	dfc00117 	ldw	ra,4(sp)
 8248b7c:	df000017 	ldw	fp,0(sp)
 8248b80:	dec00204 	addi	sp,sp,8
 8248b84:	f800283a 	ret

08248b88 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 8248b88:	defffc04 	addi	sp,sp,-16
 8248b8c:	dfc00315 	stw	ra,12(sp)
 8248b90:	df000215 	stw	fp,8(sp)
 8248b94:	df000204 	addi	fp,sp,8
 8248b98:	e13fff15 	stw	r4,-4(fp)
   int c = 0;
 8248b9c:	e03ffe15 	stw	zero,-8(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 8248ba0:	e13fff17 	ldw	r4,-4(fp)
 8248ba4:	82497240 	call	8249724 <vgetc>
 8248ba8:	e0bffe15 	stw	r2,-8(fp)
 8248bac:	e0bffe17 	ldw	r2,-8(fp)
 8248bb0:	10bfffd8 	cmpnei	r2,r2,-1
 8248bb4:	1000021e 	bne	r2,zero,8248bc0 <vfeof+0x38>
   {
      return 1;
 8248bb8:	00800044 	movi	r2,1
 8248bbc:	00000106 	br	8248bc4 <vfeof+0x3c>
   }   
   return 0;
 8248bc0:	0005883a 	mov	r2,zero
}
 8248bc4:	e037883a 	mov	sp,fp
 8248bc8:	dfc00117 	ldw	ra,4(sp)
 8248bcc:	df000017 	ldw	fp,0(sp)
 8248bd0:	dec00204 	addi	sp,sp,8
 8248bd4:	f800283a 	ret

08248bd8 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 8248bd8:	defffd04 	addi	sp,sp,-12
 8248bdc:	df000215 	stw	fp,8(sp)
 8248be0:	df000204 	addi	fp,sp,8
 8248be4:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248be8:	d0a0d517 	ldw	r2,-31916(gp)
 8248bec:	e0bffe15 	stw	r2,-8(fp)
 8248bf0:	00000906 	br	8248c18 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 8248bf4:	e0bffe17 	ldw	r2,-8(fp)
 8248bf8:	10c00117 	ldw	r3,4(r2)
 8248bfc:	e0bfff17 	ldw	r2,-4(fp)
 8248c00:	1880021e 	bne	r3,r2,8248c0c <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 8248c04:	e0bffe17 	ldw	r2,-8(fp)
 8248c08:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248c0c:	e0bffe17 	ldw	r2,-8(fp)
 8248c10:	10800017 	ldw	r2,0(r2)
 8248c14:	e0bffe15 	stw	r2,-8(fp)
 8248c18:	e0bffe17 	ldw	r2,-8(fp)
 8248c1c:	103ff51e 	bne	r2,zero,8248bf4 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 8248c20:	0001883a 	nop
 8248c24:	e037883a 	mov	sp,fp
 8248c28:	df000017 	ldw	fp,0(sp)
 8248c2c:	dec00104 	addi	sp,sp,4
 8248c30:	f800283a 	ret

08248c34 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 8248c34:	defff604 	addi	sp,sp,-40
 8248c38:	dfc00915 	stw	ra,36(sp)
 8248c3c:	df000815 	stw	fp,32(sp)
 8248c40:	df000804 	addi	fp,sp,32
 8248c44:	e13fff15 	stw	r4,-4(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 8248c48:	e03ff815 	stw	zero,-32(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 8248c4c:	e13fff17 	ldw	r4,-4(fp)
 8248c50:	8203a5c0 	call	8203a5c <strlen>
 8248c54:	10800044 	addi	r2,r2,1
 8248c58:	1009883a 	mov	r4,r2
 8248c5c:	824b18c0 	call	824b18c <malloc>
 8248c60:	e0bffb15 	stw	r2,-20(fp)
   strcpy(name, const_name);
 8248c64:	e17fff17 	ldw	r5,-4(fp)
 8248c68:	e13ffb17 	ldw	r4,-20(fp)
 8248c6c:	824b1b40 	call	824b1b4 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248c70:	01000144 	movi	r4,5
 8248c74:	822d7dc0 	call	822d7dc <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 8248c78:	e13ffb17 	ldw	r4,-20(fp)
 8248c7c:	824976c0 	call	824976c <vfslookup_locked>
 8248c80:	e0bffc15 	stw	r2,-16(fp)
 8248c84:	e0bffc17 	ldw	r2,-16(fp)
 8248c88:	1000061e 	bne	r2,zero,8248ca4 <vunlink+0x70>
   {
      vfs_unlock();
 8248c8c:	01000144 	movi	r4,5
 8248c90:	822d8980 	call	822d898 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 8248c94:	e13ffb17 	ldw	r4,-20(fp)
 8248c98:	824b1a00 	call	824b1a0 <free>
      return -1;
 8248c9c:	00bfffc4 	movi	r2,-1
 8248ca0:	00005f06 	br	8248e20 <vunlink+0x1ec>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 8248ca4:	e0bffc17 	ldw	r2,-16(fp)
 8248ca8:	10800017 	ldw	r2,0(r2)
 8248cac:	e0bffd15 	stw	r2,-12(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 8248cb0:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8248cb4:	d0a0d617 	ldw	r2,-31912(gp)
 8248cb8:	e0bff915 	stw	r2,-28(fp)
 8248cbc:	00000806 	br	8248ce0 <vunlink+0xac>
   {
      if (vtmp == vfp)
 8248cc0:	e0fff917 	ldw	r3,-28(fp)
 8248cc4:	e0bffc17 	ldw	r2,-16(fp)
 8248cc8:	18800826 	beq	r3,r2,8248cec <vunlink+0xb8>
         break;
      vflast = vtmp;
 8248ccc:	e0bff917 	ldw	r2,-28(fp)
 8248cd0:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8248cd4:	e0bff917 	ldw	r2,-28(fp)
 8248cd8:	10800017 	ldw	r2,0(r2)
 8248cdc:	e0bff915 	stw	r2,-28(fp)
 8248ce0:	e0bff917 	ldw	r2,-28(fp)
 8248ce4:	103ff61e 	bne	r2,zero,8248cc0 <vunlink+0x8c>
 8248ce8:	00000106 	br	8248cf0 <vunlink+0xbc>
   {
      if (vtmp == vfp)
         break;
 8248cec:	0001883a 	nop
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 8248cf0:	e0bff917 	ldw	r2,-28(fp)
 8248cf4:	1000071e 	bne	r2,zero,8248d14 <vunlink+0xe0>
   {
      dtrap();
 8248cf8:	822d1c80 	call	822d1c8 <dtrap>
      vfs_unlock();
 8248cfc:	01000144 	movi	r4,5
 8248d00:	822d8980 	call	822d898 <post_app_sem>
      free(name);
 8248d04:	e13ffb17 	ldw	r4,-20(fp)
 8248d08:	824b1a00 	call	824b1a0 <free>
      return -1;
 8248d0c:	00bfffc4 	movi	r2,-1
 8248d10:	00004306 	br	8248e20 <vunlink+0x1ec>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 8248d14:	e0bffc17 	ldw	r2,-16(fp)
 8248d18:	10800a17 	ldw	r2,40(r2)
 8248d1c:	10000926 	beq	r2,zero,8248d44 <vunlink+0x110>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 8248d20:	e0bffc17 	ldw	r2,-16(fp)
 8248d24:	10800a17 	ldw	r2,40(r2)
 8248d28:	e0bffe15 	stw	r2,-8(fp)

         rc = vfs->r_unlink(name);
 8248d2c:	e0bffe17 	ldw	r2,-8(fp)
 8248d30:	10800817 	ldw	r2,32(r2)
 8248d34:	e13ffb17 	ldw	r4,-20(fp)
 8248d38:	103ee83a 	callr	r2
 8248d3c:	e0bff815 	stw	r2,-32(fp)
         break;   /* break to list deletion code after end of phoney loop */
 8248d40:	00002606 	br	8248ddc <vunlink+0x1a8>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 8248d44:	e0bffc17 	ldw	r2,-16(fp)
 8248d48:	1080058b 	ldhu	r2,22(r2)
 8248d4c:	10bfffcc 	andi	r2,r2,65535
 8248d50:	1080080c 	andi	r2,r2,32
 8248d54:	1000061e 	bne	r2,zero,8248d70 <vunlink+0x13c>
      {
         vfs_unlock();
 8248d58:	01000144 	movi	r4,5
 8248d5c:	822d8980 	call	822d898 <post_app_sem>
         free(name);
 8248d60:	e13ffb17 	ldw	r4,-20(fp)
 8248d64:	824b1a00 	call	824b1a0 <free>
         return -1;
 8248d68:	00bfffc4 	movi	r2,-1
 8248d6c:	00002c06 	br	8248e20 <vunlink+0x1ec>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 8248d70:	e0bffc17 	ldw	r2,-16(fp)
 8248d74:	1080058b 	ldhu	r2,22(r2)
 8248d78:	10bfffcc 	andi	r2,r2,65535
 8248d7c:	1080200c 	andi	r2,r2,128
 8248d80:	10000a26 	beq	r2,zero,8248dac <vunlink+0x178>
 8248d84:	e0bffc17 	ldw	r2,-16(fp)
 8248d88:	10800617 	ldw	r2,24(r2)
 8248d8c:	10000726 	beq	r2,zero,8248dac <vunlink+0x178>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8248d90:	e0bffc17 	ldw	r2,-16(fp)
 8248d94:	10c00617 	ldw	r3,24(r2)
 8248d98:	e0bffc17 	ldw	r2,-16(fp)
 8248d9c:	10800917 	ldw	r2,36(r2)
 8248da0:	100b883a 	mov	r5,r2
 8248da4:	1809883a 	mov	r4,r3
 8248da8:	82484980 	call	8248498 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 8248dac:	e0bffc17 	ldw	r2,-16(fp)
 8248db0:	1080058b 	ldhu	r2,22(r2)
 8248db4:	10bfffcc 	andi	r2,r2,65535
 8248db8:	1080100c 	andi	r2,r2,64
 8248dbc:	10000526 	beq	r2,zero,8248dd4 <vunlink+0x1a0>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 8248dc0:	d0a0db17 	ldw	r2,-31892(gp)
 8248dc4:	10bfffc4 	addi	r2,r2,-1
 8248dc8:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 8248dcc:	e13ffc17 	ldw	r4,-16(fp)
 8248dd0:	822ddd40 	call	822ddd4 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 8248dd4:	e03ff815 	stw	zero,-32(fp)

      break;
 8248dd8:	0001883a 	nop
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 8248ddc:	e0bffa17 	ldw	r2,-24(fp)
 8248de0:	10000426 	beq	r2,zero,8248df4 <vunlink+0x1c0>
      vflast->next = vfnext;
 8248de4:	e0bffa17 	ldw	r2,-24(fp)
 8248de8:	e0fffd17 	ldw	r3,-12(fp)
 8248dec:	10c00015 	stw	r3,0(r2)
 8248df0:	00000206 	br	8248dfc <vunlink+0x1c8>
   else
      vfsfiles = vfnext;
 8248df4:	e0bffd17 	ldw	r2,-12(fp)
 8248df8:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 8248dfc:	e13ffc17 	ldw	r4,-16(fp)
 8248e00:	8248bd80 	call	8248bd8 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 8248e04:	00800044 	movi	r2,1
 8248e08:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 8248e0c:	01000144 	movi	r4,5
 8248e10:	822d8980 	call	822d898 <post_app_sem>
   free(name);
 8248e14:	e13ffb17 	ldw	r4,-20(fp)
 8248e18:	824b1a00 	call	824b1a0 <free>
   return rc;
 8248e1c:	e0bff817 	ldw	r2,-32(fp)
}
 8248e20:	e037883a 	mov	sp,fp
 8248e24:	dfc00117 	ldw	ra,4(sp)
 8248e28:	df000017 	ldw	fp,0(sp)
 8248e2c:	dec00204 	addi	sp,sp,8
 8248e30:	f800283a 	ret

08248e34 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8248e34:	defff604 	addi	sp,sp,-40
 8248e38:	dfc00915 	stw	ra,36(sp)
 8248e3c:	df000815 	stw	fp,32(sp)
 8248e40:	df000804 	addi	fp,sp,32
 8248e44:	e13ffc15 	stw	r4,-16(fp)
 8248e48:	e17ffd15 	stw	r5,-12(fp)
 8248e4c:	e1bffe15 	stw	r6,-8(fp)
 8248e50:	e1ffff15 	stw	r7,-4(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8248e54:	01000144 	movi	r4,5
 8248e58:	822d7dc0 	call	822d7dc <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 8248e5c:	e13fff17 	ldw	r4,-4(fp)
 8248e60:	8249aa40 	call	8249aa4 <isvfile_locked>
 8248e64:	10004e26 	beq	r2,zero,8248fa0 <vfread+0x16c>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 8248e68:	e0bfff17 	ldw	r2,-4(fp)
 8248e6c:	10800117 	ldw	r2,4(r2)
 8248e70:	1000041e 	bne	r2,zero,8248e84 <vfread+0x50>
      {
         vfs_unlock();
 8248e74:	01000144 	movi	r4,5
 8248e78:	822d8980 	call	822d898 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8248e7c:	0005883a 	mov	r2,zero
 8248e80:	00004a06 	br	8248fac <vfread+0x178>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 8248e84:	e0bfff17 	ldw	r2,-4(fp)
 8248e88:	10800117 	ldw	r2,4(r2)
 8248e8c:	10800a17 	ldw	r2,40(r2)
 8248e90:	10001026 	beq	r2,zero,8248ed4 <vfread+0xa0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 8248e94:	e0bfff17 	ldw	r2,-4(fp)
 8248e98:	10800117 	ldw	r2,4(r2)
 8248e9c:	10800a17 	ldw	r2,40(r2)
 8248ea0:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 8248ea4:	e0bff917 	ldw	r2,-28(fp)
 8248ea8:	10800317 	ldw	r2,12(r2)
 8248eac:	e1ffff17 	ldw	r7,-4(fp)
 8248eb0:	e1bffe17 	ldw	r6,-8(fp)
 8248eb4:	e17ffd17 	ldw	r5,-12(fp)
 8248eb8:	e13ffc17 	ldw	r4,-16(fp)
 8248ebc:	103ee83a 	callr	r2
 8248ec0:	e0bffa15 	stw	r2,-24(fp)
         vfs_unlock();
 8248ec4:	01000144 	movi	r4,5
 8248ec8:	822d8980 	call	822d898 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 8248ecc:	e0bffa17 	ldw	r2,-24(fp)
 8248ed0:	00003606 	br	8248fac <vfread+0x178>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 8248ed4:	e0bfff17 	ldw	r2,-4(fp)
 8248ed8:	10800117 	ldw	r2,4(r2)
 8248edc:	10800617 	ldw	r2,24(r2)
 8248ee0:	1000041e 	bne	r2,zero,8248ef4 <vfread+0xc0>
      {
         vfs_unlock();
 8248ee4:	01000144 	movi	r4,5
 8248ee8:	822d8980 	call	822d898 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8248eec:	0005883a 	mov	r2,zero
 8248ef0:	00002e06 	br	8248fac <vfread+0x178>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 8248ef4:	e0fffe17 	ldw	r3,-8(fp)
 8248ef8:	e0bffd17 	ldw	r2,-12(fp)
 8248efc:	1885383a 	mul	r2,r3,r2
 8248f00:	e0bff815 	stw	r2,-32(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 8248f04:	e0bfff17 	ldw	r2,-4(fp)
 8248f08:	10800217 	ldw	r2,8(r2)
 8248f0c:	1007883a 	mov	r3,r2
 8248f10:	e0bfff17 	ldw	r2,-4(fp)
 8248f14:	10800117 	ldw	r2,4(r2)
 8248f18:	10800617 	ldw	r2,24(r2)
 8248f1c:	1885c83a 	sub	r2,r3,r2
 8248f20:	e0bffb15 	stw	r2,-20(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 8248f24:	e0fffb17 	ldw	r3,-20(fp)
 8248f28:	e0bff817 	ldw	r2,-32(fp)
 8248f2c:	1885883a 	add	r2,r3,r2
 8248f30:	e0ffff17 	ldw	r3,-4(fp)
 8248f34:	18c00117 	ldw	r3,4(r3)
 8248f38:	18c00817 	ldw	r3,32(r3)
 8248f3c:	1880062e 	bgeu	r3,r2,8248f58 <vfread+0x124>
            bcount = (unsigned)(vfd->file->comp_size - location);
 8248f40:	e0bfff17 	ldw	r2,-4(fp)
 8248f44:	10800117 	ldw	r2,4(r2)
 8248f48:	10c00817 	ldw	r3,32(r2)
 8248f4c:	e0bffb17 	ldw	r2,-20(fp)
 8248f50:	1885c83a 	sub	r2,r3,r2
 8248f54:	e0bff815 	stw	r2,-32(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 8248f58:	e0bfff17 	ldw	r2,-4(fp)
 8248f5c:	10800217 	ldw	r2,8(r2)
 8248f60:	e1bff817 	ldw	r6,-32(fp)
 8248f64:	100b883a 	mov	r5,r2
 8248f68:	e13ffc17 	ldw	r4,-16(fp)
 8248f6c:	8202a0c0 	call	8202a0c <memcpy>
         vfd->cmploc += bcount;
 8248f70:	e0bfff17 	ldw	r2,-4(fp)
 8248f74:	10c00217 	ldw	r3,8(r2)
 8248f78:	e0bff817 	ldw	r2,-32(fp)
 8248f7c:	1887883a 	add	r3,r3,r2
 8248f80:	e0bfff17 	ldw	r2,-4(fp)
 8248f84:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 8248f88:	01000144 	movi	r4,5
 8248f8c:	822d8980 	call	822d898 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 8248f90:	e17ffd17 	ldw	r5,-12(fp)
 8248f94:	e13ff817 	ldw	r4,-32(fp)
 8248f98:	820270c0 	call	820270c <__udivsi3>
 8248f9c:	00000306 	br	8248fac <vfread+0x178>
   }

   vfs_unlock();
 8248fa0:	01000144 	movi	r4,5
 8248fa4:	822d8980 	call	822d898 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 8248fa8:	0005883a 	mov	r2,zero
#endif   /* HT_LOCALFS */
}
 8248fac:	e037883a 	mov	sp,fp
 8248fb0:	dfc00117 	ldw	ra,4(sp)
 8248fb4:	df000017 	ldw	fp,0(sp)
 8248fb8:	dec00204 	addi	sp,sp,8
 8248fbc:	f800283a 	ret

08248fc0 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8248fc0:	defff204 	addi	sp,sp,-56
 8248fc4:	dfc00d15 	stw	ra,52(sp)
 8248fc8:	df000c15 	stw	fp,48(sp)
 8248fcc:	df000c04 	addi	fp,sp,48
 8248fd0:	e13ffc15 	stw	r4,-16(fp)
 8248fd4:	e17ffd15 	stw	r5,-12(fp)
 8248fd8:	e1bffe15 	stw	r6,-8(fp)
 8248fdc:	e1ffff15 	stw	r7,-4(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 8248fe0:	e13fff17 	ldw	r4,-4(fp)
 8248fe4:	8249aa40 	call	8249aa4 <isvfile_locked>
 8248fe8:	1000021e 	bne	r2,zero,8248ff4 <vfwrite_locked+0x34>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 8248fec:	00800244 	movi	r2,9
 8248ff0:	0000da06 	br	824935c <vfwrite_locked+0x39c>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 8248ff4:	e0bfff17 	ldw	r2,-4(fp)
 8248ff8:	10800117 	ldw	r2,4(r2)
 8248ffc:	10800a17 	ldw	r2,40(r2)
 8249000:	10000e26 	beq	r2,zero,824903c <vfwrite_locked+0x7c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 8249004:	e0bfff17 	ldw	r2,-4(fp)
 8249008:	10800117 	ldw	r2,4(r2)
 824900c:	10800a17 	ldw	r2,40(r2)
 8249010:	e0bff415 	stw	r2,-48(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 8249014:	e0bff417 	ldw	r2,-48(fp)
 8249018:	10800417 	ldw	r2,16(r2)
 824901c:	e1ffff17 	ldw	r7,-4(fp)
 8249020:	e1bffe17 	ldw	r6,-8(fp)
 8249024:	e17ffd17 	ldw	r5,-12(fp)
 8249028:	e13ffc17 	ldw	r4,-16(fp)
 824902c:	103ee83a 	callr	r2
 8249030:	e0bff515 	stw	r2,-44(fp)
      return rc;
 8249034:	e0bff517 	ldw	r2,-44(fp)
 8249038:	0000c806 	br	824935c <vfwrite_locked+0x39c>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 824903c:	e0bfff17 	ldw	r2,-4(fp)
 8249040:	10800117 	ldw	r2,4(r2)
 8249044:	1000021e 	bne	r2,zero,8249050 <vfwrite_locked+0x90>
   {
      return 0;
 8249048:	0005883a 	mov	r2,zero
 824904c:	0000c306 	br	824935c <vfwrite_locked+0x39c>
   }

   vfp = vfd->file;
 8249050:	e0bfff17 	ldw	r2,-4(fp)
 8249054:	10800117 	ldw	r2,4(r2)
 8249058:	e0bff615 	stw	r2,-40(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 824905c:	e0bff617 	ldw	r2,-40(fp)
 8249060:	1080058b 	ldhu	r2,22(r2)
 8249064:	10bfffcc 	andi	r2,r2,65535
 8249068:	1080080c 	andi	r2,r2,32
 824906c:	1000051e 	bne	r2,zero,8249084 <vfwrite_locked+0xc4>
   {
      vfd->error = ENP_FILEIO;
 8249070:	e0bfff17 	ldw	r2,-4(fp)
 8249074:	00fff984 	movi	r3,-26
 8249078:	10c00415 	stw	r3,16(r2)
      return 0;
 824907c:	0005883a 	mov	r2,zero
 8249080:	0000b606 	br	824935c <vfwrite_locked+0x39c>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 8249084:	e0fffd17 	ldw	r3,-12(fp)
 8249088:	e0bffe17 	ldw	r2,-8(fp)
 824908c:	1885383a 	mul	r2,r3,r2
 8249090:	e0bff715 	stw	r2,-36(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 8249094:	e0bff717 	ldw	r2,-36(fp)
 8249098:	1000021e 	bne	r2,zero,82490a4 <vfwrite_locked+0xe4>
   {
      return 0;
 824909c:	0005883a 	mov	r2,zero
 82490a0:	0000ae06 	br	824935c <vfwrite_locked+0x39c>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 82490a4:	e0bff617 	ldw	r2,-40(fp)
 82490a8:	10800617 	ldw	r2,24(r2)
 82490ac:	10003d1e 	bne	r2,zero,82491a4 <vfwrite_locked+0x1e4>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 82490b0:	e0bff717 	ldw	r2,-36(fp)
 82490b4:	10bfffc4 	addi	r2,r2,-1
 82490b8:	1004d37a 	srli	r2,r2,13
 82490bc:	10800044 	addi	r2,r2,1
 82490c0:	1004937a 	slli	r2,r2,13
 82490c4:	e0bff815 	stw	r2,-32(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 82490c8:	e13ff817 	ldw	r4,-32(fp)
 82490cc:	82483d00 	call	82483d0 <vf_alloc_buffer>
 82490d0:	1007883a 	mov	r3,r2
 82490d4:	e0bff617 	ldw	r2,-40(fp)
 82490d8:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 82490dc:	e0bff617 	ldw	r2,-40(fp)
 82490e0:	10800617 	ldw	r2,24(r2)
 82490e4:	1000051e 	bne	r2,zero,82490fc <vfwrite_locked+0x13c>
      {
         vfd->error = ENP_NOMEM;
 82490e8:	e0bfff17 	ldw	r2,-4(fp)
 82490ec:	00fffb04 	movi	r3,-20
 82490f0:	10c00415 	stw	r3,16(r2)
         return 0;
 82490f4:	0005883a 	mov	r2,zero
 82490f8:	00009806 	br	824935c <vfwrite_locked+0x39c>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 82490fc:	e0bff617 	ldw	r2,-40(fp)
 8249100:	e0fff817 	ldw	r3,-32(fp)
 8249104:	10c00915 	stw	r3,36(r2)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 8249108:	e0bff617 	ldw	r2,-40(fp)
 824910c:	e0fff717 	ldw	r3,-36(fp)
 8249110:	10c00715 	stw	r3,28(r2)
      vfp->comp_size = bcount;
 8249114:	e0bff617 	ldw	r2,-40(fp)
 8249118:	e0fff717 	ldw	r3,-36(fp)
 824911c:	10c00815 	stw	r3,32(r2)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 8249120:	e0bff617 	ldw	r2,-40(fp)
 8249124:	10c00617 	ldw	r3,24(r2)
 8249128:	e0bff717 	ldw	r2,-36(fp)
 824912c:	1887883a 	add	r3,r3,r2
 8249130:	e0bfff17 	ldw	r2,-4(fp)
 8249134:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 8249138:	e0bff617 	ldw	r2,-40(fp)
 824913c:	10c0058b 	ldhu	r3,22(r2)
 8249140:	00bfff84 	movi	r2,-2
 8249144:	1884703a 	and	r2,r3,r2
 8249148:	1007883a 	mov	r3,r2
 824914c:	e0bff617 	ldw	r2,-40(fp)
 8249150:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 8249154:	e0bff617 	ldw	r2,-40(fp)
 8249158:	1080058b 	ldhu	r2,22(r2)
 824915c:	10808014 	ori	r2,r2,512
 8249160:	1007883a 	mov	r3,r2
 8249164:	e0bff617 	ldw	r2,-40(fp)
 8249168:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 824916c:	e0bff617 	ldw	r2,-40(fp)
 8249170:	1080058b 	ldhu	r2,22(r2)
 8249174:	10802014 	ori	r2,r2,128
 8249178:	1007883a 	mov	r3,r2
 824917c:	e0bff617 	ldw	r2,-40(fp)
 8249180:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 8249184:	e0bff617 	ldw	r2,-40(fp)
 8249188:	10800617 	ldw	r2,24(r2)
 824918c:	e1bff717 	ldw	r6,-36(fp)
 8249190:	e17ffc17 	ldw	r5,-16(fp)
 8249194:	1009883a 	mov	r4,r2
 8249198:	8202a0c0 	call	8202a0c <memcpy>

      /* return the number of "items" written */
      return items;
 824919c:	e0bffe17 	ldw	r2,-8(fp)
 82491a0:	00006e06 	br	824935c <vfwrite_locked+0x39c>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 82491a4:	e0bfff17 	ldw	r2,-4(fp)
 82491a8:	10800217 	ldw	r2,8(r2)
 82491ac:	1007883a 	mov	r3,r2
 82491b0:	e0bff617 	ldw	r2,-40(fp)
 82491b4:	10800617 	ldw	r2,24(r2)
 82491b8:	1885c83a 	sub	r2,r3,r2
 82491bc:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 82491c0:	e0fff917 	ldw	r3,-28(fp)
 82491c4:	e0bff717 	ldw	r2,-36(fp)
 82491c8:	1885883a 	add	r2,r3,r2
 82491cc:	e0fff617 	ldw	r3,-40(fp)
 82491d0:	18c00917 	ldw	r3,36(r3)
 82491d4:	1880382e 	bgeu	r3,r2,82492b8 <vfwrite_locked+0x2f8>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 82491d8:	e0fff917 	ldw	r3,-28(fp)
 82491dc:	e0bff717 	ldw	r2,-36(fp)
 82491e0:	1885883a 	add	r2,r3,r2
 82491e4:	10bfffc4 	addi	r2,r2,-1
 82491e8:	1004d37a 	srli	r2,r2,13
 82491ec:	10800044 	addi	r2,r2,1
 82491f0:	1004937a 	slli	r2,r2,13
 82491f4:	e0bffa15 	stw	r2,-24(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 82491f8:	e13ffa17 	ldw	r4,-24(fp)
 82491fc:	82483d00 	call	82483d0 <vf_alloc_buffer>
 8249200:	e0bffb15 	stw	r2,-20(fp)

      /* check for allocation failure */
      if (!new_buffer)
 8249204:	e0bffb17 	ldw	r2,-20(fp)
 8249208:	1000051e 	bne	r2,zero,8249220 <vfwrite_locked+0x260>
      {
         vfd->error = ENP_NOMEM;
 824920c:	e0bfff17 	ldw	r2,-4(fp)
 8249210:	00fffb04 	movi	r3,-20
 8249214:	10c00415 	stw	r3,16(r2)
         return 0;
 8249218:	0005883a 	mov	r2,zero
 824921c:	00004f06 	br	824935c <vfwrite_locked+0x39c>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8249220:	e0bff617 	ldw	r2,-40(fp)
 8249224:	10c00617 	ldw	r3,24(r2)
 8249228:	e0bff617 	ldw	r2,-40(fp)
 824922c:	10800817 	ldw	r2,32(r2)
 8249230:	100d883a 	mov	r6,r2
 8249234:	180b883a 	mov	r5,r3
 8249238:	e13ffb17 	ldw	r4,-20(fp)
 824923c:	8202a0c0 	call	8202a0c <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 8249240:	e0bff617 	ldw	r2,-40(fp)
 8249244:	1080058b 	ldhu	r2,22(r2)
 8249248:	10bfffcc 	andi	r2,r2,65535
 824924c:	1080200c 	andi	r2,r2,128
 8249250:	10000726 	beq	r2,zero,8249270 <vfwrite_locked+0x2b0>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8249254:	e0bff617 	ldw	r2,-40(fp)
 8249258:	10c00617 	ldw	r3,24(r2)
 824925c:	e0bff617 	ldw	r2,-40(fp)
 8249260:	10800917 	ldw	r2,36(r2)
 8249264:	100b883a 	mov	r5,r2
 8249268:	1809883a 	mov	r4,r3
 824926c:	82484980 	call	8248498 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 8249270:	e0bff617 	ldw	r2,-40(fp)
 8249274:	e0fffb17 	ldw	r3,-20(fp)
 8249278:	10c00615 	stw	r3,24(r2)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 824927c:	e0bff617 	ldw	r2,-40(fp)
 8249280:	e0fffa17 	ldw	r3,-24(fp)
 8249284:	10c00915 	stw	r3,36(r2)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249288:	e0bff617 	ldw	r2,-40(fp)
 824928c:	1080058b 	ldhu	r2,22(r2)
 8249290:	10802014 	ori	r2,r2,128
 8249294:	1007883a 	mov	r3,r2
 8249298:	e0bff617 	ldw	r2,-40(fp)
 824929c:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 82492a0:	e0bff617 	ldw	r2,-40(fp)
 82492a4:	10c00617 	ldw	r3,24(r2)
 82492a8:	e0bff917 	ldw	r2,-28(fp)
 82492ac:	1887883a 	add	r3,r3,r2
 82492b0:	e0bfff17 	ldw	r2,-4(fp)
 82492b4:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 82492b8:	e0bfff17 	ldw	r2,-4(fp)
 82492bc:	10800217 	ldw	r2,8(r2)
 82492c0:	e1bff717 	ldw	r6,-36(fp)
 82492c4:	e17ffc17 	ldw	r5,-16(fp)
 82492c8:	1009883a 	mov	r4,r2
 82492cc:	8202a0c0 	call	8202a0c <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 82492d0:	e0bfff17 	ldw	r2,-4(fp)
 82492d4:	10c00217 	ldw	r3,8(r2)
 82492d8:	e0bff717 	ldw	r2,-36(fp)
 82492dc:	1887883a 	add	r3,r3,r2
 82492e0:	e0bfff17 	ldw	r2,-4(fp)
 82492e4:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 82492e8:	e0fff917 	ldw	r3,-28(fp)
 82492ec:	e0bff717 	ldw	r2,-36(fp)
 82492f0:	1885883a 	add	r2,r3,r2
 82492f4:	e0fff617 	ldw	r3,-40(fp)
 82492f8:	18c00817 	ldw	r3,32(r3)
 82492fc:	1880052e 	bgeu	r3,r2,8249314 <vfwrite_locked+0x354>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 8249300:	e0fff917 	ldw	r3,-28(fp)
 8249304:	e0bff717 	ldw	r2,-36(fp)
 8249308:	1887883a 	add	r3,r3,r2
 824930c:	e0bff617 	ldw	r2,-40(fp)
 8249310:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 8249314:	e0bff617 	ldw	r2,-40(fp)
 8249318:	10c00817 	ldw	r3,32(r2)
 824931c:	e0bff617 	ldw	r2,-40(fp)
 8249320:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 8249324:	e0bff617 	ldw	r2,-40(fp)
 8249328:	10c0058b 	ldhu	r3,22(r2)
 824932c:	00bfff84 	movi	r2,-2
 8249330:	1884703a 	and	r2,r3,r2
 8249334:	1007883a 	mov	r3,r2
 8249338:	e0bff617 	ldw	r2,-40(fp)
 824933c:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 8249340:	e0bff617 	ldw	r2,-40(fp)
 8249344:	1080058b 	ldhu	r2,22(r2)
 8249348:	10808014 	ori	r2,r2,512
 824934c:	1007883a 	mov	r3,r2
 8249350:	e0bff617 	ldw	r2,-40(fp)
 8249354:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 8249358:	e0bffe17 	ldw	r2,-8(fp)

#endif   /* HT_RWVFS */
}
 824935c:	e037883a 	mov	sp,fp
 8249360:	dfc00117 	ldw	ra,4(sp)
 8249364:	df000017 	ldw	fp,0(sp)
 8249368:	dec00204 	addi	sp,sp,8
 824936c:	f800283a 	ret

08249370 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8249370:	defff904 	addi	sp,sp,-28
 8249374:	dfc00615 	stw	ra,24(sp)
 8249378:	df000515 	stw	fp,20(sp)
 824937c:	df000504 	addi	fp,sp,20
 8249380:	e13ffc15 	stw	r4,-16(fp)
 8249384:	e17ffd15 	stw	r5,-12(fp)
 8249388:	e1bffe15 	stw	r6,-8(fp)
 824938c:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8249390:	01000144 	movi	r4,5
 8249394:	822d7dc0 	call	822d7dc <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 8249398:	e1ffff17 	ldw	r7,-4(fp)
 824939c:	e1bffe17 	ldw	r6,-8(fp)
 82493a0:	e17ffd17 	ldw	r5,-12(fp)
 82493a4:	e13ffc17 	ldw	r4,-16(fp)
 82493a8:	8248fc00 	call	8248fc0 <vfwrite_locked>
 82493ac:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 82493b0:	01000144 	movi	r4,5
 82493b4:	822d8980 	call	822d898 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 82493b8:	e0bffb17 	ldw	r2,-20(fp)
}
 82493bc:	e037883a 	mov	sp,fp
 82493c0:	dfc00117 	ldw	ra,4(sp)
 82493c4:	df000017 	ldw	fp,0(sp)
 82493c8:	dec00204 	addi	sp,sp,8
 82493cc:	f800283a 	ret

082493d0 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 82493d0:	defff904 	addi	sp,sp,-28
 82493d4:	dfc00615 	stw	ra,24(sp)
 82493d8:	df000515 	stw	fp,20(sp)
 82493dc:	df000504 	addi	fp,sp,20
 82493e0:	e13ffd15 	stw	r4,-12(fp)
 82493e4:	e17ffe15 	stw	r5,-8(fp)
 82493e8:	e1bfff15 	stw	r6,-4(fp)
   /* lock the VFS */
   vfs_lock();
 82493ec:	01000144 	movi	r4,5
 82493f0:	822d7dc0 	call	822d7dc <wait_app_sem>

   if (isvfile_locked(vfd))
 82493f4:	e13ffd17 	ldw	r4,-12(fp)
 82493f8:	8249aa40 	call	8249aa4 <isvfile_locked>
 82493fc:	10003f26 	beq	r2,zero,82494fc <vfseek+0x12c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 8249400:	e0bffd17 	ldw	r2,-12(fp)
 8249404:	10800117 	ldw	r2,4(r2)
 8249408:	1000041e 	bne	r2,zero,824941c <vfseek+0x4c>
      {
         vfs_unlock();
 824940c:	01000144 	movi	r4,5
 8249410:	822d8980 	call	822d898 <post_app_sem>
         return -1;
 8249414:	00bfffc4 	movi	r2,-1
 8249418:	00003b06 	br	8249508 <vfseek+0x138>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 824941c:	e0bffd17 	ldw	r2,-12(fp)
 8249420:	10800117 	ldw	r2,4(r2)
 8249424:	10800a17 	ldw	r2,40(r2)
 8249428:	10000f26 	beq	r2,zero,8249468 <vfseek+0x98>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 824942c:	e0bffd17 	ldw	r2,-12(fp)
 8249430:	10800117 	ldw	r2,4(r2)
 8249434:	10800a17 	ldw	r2,40(r2)
 8249438:	e0bffb15 	stw	r2,-20(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 824943c:	e0bffb17 	ldw	r2,-20(fp)
 8249440:	10800517 	ldw	r2,20(r2)
 8249444:	e1bfff17 	ldw	r6,-4(fp)
 8249448:	e17ffe17 	ldw	r5,-8(fp)
 824944c:	e13ffd17 	ldw	r4,-12(fp)
 8249450:	103ee83a 	callr	r2
 8249454:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 8249458:	01000144 	movi	r4,5
 824945c:	822d8980 	call	822d898 <post_app_sem>
         return rc;
 8249460:	e0bffc17 	ldw	r2,-16(fp)
 8249464:	00002806 	br	8249508 <vfseek+0x138>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 8249468:	e0bfff17 	ldw	r2,-4(fp)
 824946c:	10c00060 	cmpeqi	r3,r2,1
 8249470:	18000b1e 	bne	r3,zero,82494a0 <vfseek+0xd0>
 8249474:	10c000a0 	cmpeqi	r3,r2,2
 8249478:	1800101e 	bne	r3,zero,82494bc <vfseek+0xec>
 824947c:	10001b1e 	bne	r2,zero,82494ec <vfseek+0x11c>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 8249480:	e0bffd17 	ldw	r2,-12(fp)
 8249484:	10800117 	ldw	r2,4(r2)
 8249488:	10c00617 	ldw	r3,24(r2)
 824948c:	e0bffe17 	ldw	r2,-8(fp)
 8249490:	1887883a 	add	r3,r3,r2
 8249494:	e0bffd17 	ldw	r2,-12(fp)
 8249498:	10c00215 	stw	r3,8(r2)
         break;
 824949c:	00001306 	br	82494ec <vfseek+0x11c>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 82494a0:	e0bffd17 	ldw	r2,-12(fp)
 82494a4:	10c00217 	ldw	r3,8(r2)
 82494a8:	e0bffe17 	ldw	r2,-8(fp)
 82494ac:	1887883a 	add	r3,r3,r2
 82494b0:	e0bffd17 	ldw	r2,-12(fp)
 82494b4:	10c00215 	stw	r3,8(r2)
         break;
 82494b8:	00000c06 	br	82494ec <vfseek+0x11c>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 82494bc:	e0bffd17 	ldw	r2,-12(fp)
 82494c0:	10800117 	ldw	r2,4(r2)
 82494c4:	10c00617 	ldw	r3,24(r2)
 82494c8:	e0bffd17 	ldw	r2,-12(fp)
 82494cc:	10800117 	ldw	r2,4(r2)
 82494d0:	11000817 	ldw	r4,32(r2)
 82494d4:	e0bffe17 	ldw	r2,-8(fp)
 82494d8:	2085883a 	add	r2,r4,r2
 82494dc:	1887883a 	add	r3,r3,r2
 82494e0:	e0bffd17 	ldw	r2,-12(fp)
 82494e4:	10c00215 	stw	r3,8(r2)
         break;
 82494e8:	0001883a 	nop
      }
      vfs_unlock();
 82494ec:	01000144 	movi	r4,5
 82494f0:	822d8980 	call	822d898 <post_app_sem>
      return(0);
 82494f4:	0005883a 	mov	r2,zero
 82494f8:	00000306 	br	8249508 <vfseek+0x138>
   }

   vfs_unlock();
 82494fc:	01000144 	movi	r4,5
 8249500:	822d8980 	call	822d898 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 8249504:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249508:	e037883a 	mov	sp,fp
 824950c:	dfc00117 	ldw	ra,4(sp)
 8249510:	df000017 	ldw	fp,0(sp)
 8249514:	dec00204 	addi	sp,sp,8
 8249518:	f800283a 	ret

0824951c <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 824951c:	defffb04 	addi	sp,sp,-20
 8249520:	dfc00415 	stw	ra,16(sp)
 8249524:	df000315 	stw	fp,12(sp)
 8249528:	df000304 	addi	fp,sp,12
 824952c:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249530:	01000144 	movi	r4,5
 8249534:	822d7dc0 	call	822d7dc <wait_app_sem>

   if (isvfile_locked(vfd))
 8249538:	e13fff17 	ldw	r4,-4(fp)
 824953c:	8249aa40 	call	8249aa4 <isvfile_locked>
 8249540:	10003226 	beq	r2,zero,824960c <vftell+0xf0>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 8249544:	e0bfff17 	ldw	r2,-4(fp)
 8249548:	10800117 	ldw	r2,4(r2)
 824954c:	1000041e 	bne	r2,zero,8249560 <vftell+0x44>
      {
         vfs_unlock();
 8249550:	01000144 	movi	r4,5
 8249554:	822d8980 	call	822d898 <post_app_sem>
         return -1;
 8249558:	00bfffc4 	movi	r2,-1
 824955c:	00002e06 	br	8249618 <vftell+0xfc>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249560:	e0bfff17 	ldw	r2,-4(fp)
 8249564:	10800117 	ldw	r2,4(r2)
 8249568:	10800a17 	ldw	r2,40(r2)
 824956c:	10000d26 	beq	r2,zero,82495a4 <vftell+0x88>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249570:	e0bfff17 	ldw	r2,-4(fp)
 8249574:	10800117 	ldw	r2,4(r2)
 8249578:	10800a17 	ldw	r2,40(r2)
 824957c:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 8249580:	e0bffd17 	ldw	r2,-12(fp)
 8249584:	10800617 	ldw	r2,24(r2)
 8249588:	e13fff17 	ldw	r4,-4(fp)
 824958c:	103ee83a 	callr	r2
 8249590:	e0bffe15 	stw	r2,-8(fp)
         vfs_unlock();
 8249594:	01000144 	movi	r4,5
 8249598:	822d8980 	call	822d898 <post_app_sem>
         return rc;
 824959c:	e0bffe17 	ldw	r2,-8(fp)
 82495a0:	00001d06 	br	8249618 <vftell+0xfc>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 82495a4:	e0bfff17 	ldw	r2,-4(fp)
 82495a8:	10c00217 	ldw	r3,8(r2)
 82495ac:	e0bfff17 	ldw	r2,-4(fp)
 82495b0:	10800117 	ldw	r2,4(r2)
 82495b4:	11000617 	ldw	r4,24(r2)
 82495b8:	e0bfff17 	ldw	r2,-4(fp)
 82495bc:	10800117 	ldw	r2,4(r2)
 82495c0:	10800817 	ldw	r2,32(r2)
 82495c4:	2085883a 	add	r2,r4,r2
 82495c8:	1880061e 	bne	r3,r2,82495e4 <vftell+0xc8>
      {
         vfs_unlock();
 82495cc:	01000144 	movi	r4,5
 82495d0:	822d8980 	call	822d898 <post_app_sem>

         return vfd->file->comp_size;
 82495d4:	e0bfff17 	ldw	r2,-4(fp)
 82495d8:	10800117 	ldw	r2,4(r2)
 82495dc:	10800817 	ldw	r2,32(r2)
 82495e0:	00000d06 	br	8249618 <vftell+0xfc>
      }
      else
      {
         vfs_unlock();
 82495e4:	01000144 	movi	r4,5
 82495e8:	822d8980 	call	822d898 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 82495ec:	e0bfff17 	ldw	r2,-4(fp)
 82495f0:	10800217 	ldw	r2,8(r2)
 82495f4:	1007883a 	mov	r3,r2
 82495f8:	e0bfff17 	ldw	r2,-4(fp)
 82495fc:	10800117 	ldw	r2,4(r2)
 8249600:	10800617 	ldw	r2,24(r2)
 8249604:	1885c83a 	sub	r2,r3,r2
 8249608:	00000306 	br	8249618 <vftell+0xfc>
      }
   }

   vfs_unlock();
 824960c:	01000144 	movi	r4,5
 8249610:	822d8980 	call	822d898 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 8249614:	00800244 	movi	r2,9
#endif   /* HT_LOCALFS */
}
 8249618:	e037883a 	mov	sp,fp
 824961c:	dfc00117 	ldw	ra,4(sp)
 8249620:	df000017 	ldw	fp,0(sp)
 8249624:	dec00204 	addi	sp,sp,8
 8249628:	f800283a 	ret

0824962c <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 824962c:	defffb04 	addi	sp,sp,-20
 8249630:	dfc00415 	stw	ra,16(sp)
 8249634:	df000315 	stw	fp,12(sp)
 8249638:	df000304 	addi	fp,sp,12
 824963c:	e13fff15 	stw	r4,-4(fp)
   int   chr;

   if (isvfile_locked(vfd))
 8249640:	e13fff17 	ldw	r4,-4(fp)
 8249644:	8249aa40 	call	8249aa4 <isvfile_locked>
 8249648:	10002f26 	beq	r2,zero,8249708 <vgetc_locked+0xdc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 824964c:	e0bfff17 	ldw	r2,-4(fp)
 8249650:	10800117 	ldw	r2,4(r2)
 8249654:	1000021e 	bne	r2,zero,8249660 <vgetc_locked+0x34>
      {
         return EOF;
 8249658:	00bfffc4 	movi	r2,-1
 824965c:	00002c06 	br	8249710 <vgetc_locked+0xe4>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249660:	e0bfff17 	ldw	r2,-4(fp)
 8249664:	10800117 	ldw	r2,4(r2)
 8249668:	10800a17 	ldw	r2,40(r2)
 824966c:	10000926 	beq	r2,zero,8249694 <vgetc_locked+0x68>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249670:	e0bfff17 	ldw	r2,-4(fp)
 8249674:	10800117 	ldw	r2,4(r2)
 8249678:	10800a17 	ldw	r2,40(r2)
 824967c:	e0bffe15 	stw	r2,-8(fp)
         return (vfp->r_fgetc(vfd));
 8249680:	e0bffe17 	ldw	r2,-8(fp)
 8249684:	10800717 	ldw	r2,28(r2)
 8249688:	e13fff17 	ldw	r4,-4(fp)
 824968c:	103ee83a 	callr	r2
 8249690:	00001f06 	br	8249710 <vgetc_locked+0xe4>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 8249694:	e0bfff17 	ldw	r2,-4(fp)
 8249698:	10800117 	ldw	r2,4(r2)
 824969c:	10800617 	ldw	r2,24(r2)
 82496a0:	1000021e 	bne	r2,zero,82496ac <vgetc_locked+0x80>
         return EOF;
 82496a4:	00bfffc4 	movi	r2,-1
 82496a8:	00001906 	br	8249710 <vgetc_locked+0xe4>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 82496ac:	e0bfff17 	ldw	r2,-4(fp)
 82496b0:	10c00217 	ldw	r3,8(r2)
 82496b4:	e0bfff17 	ldw	r2,-4(fp)
 82496b8:	10800117 	ldw	r2,4(r2)
 82496bc:	11000617 	ldw	r4,24(r2)
 82496c0:	e0bfff17 	ldw	r2,-4(fp)
 82496c4:	10800117 	ldw	r2,4(r2)
 82496c8:	10800817 	ldw	r2,32(r2)
 82496cc:	2085883a 	add	r2,r4,r2
 82496d0:	18800336 	bltu	r3,r2,82496e0 <vgetc_locked+0xb4>
            chr = EOF;
 82496d4:	00bfffc4 	movi	r2,-1
 82496d8:	e0bffd15 	stw	r2,-12(fp)
 82496dc:	00000806 	br	8249700 <vgetc_locked+0xd4>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 82496e0:	e0bfff17 	ldw	r2,-4(fp)
 82496e4:	10800217 	ldw	r2,8(r2)
 82496e8:	11000044 	addi	r4,r2,1
 82496ec:	e0ffff17 	ldw	r3,-4(fp)
 82496f0:	19000215 	stw	r4,8(r3)
 82496f4:	10800003 	ldbu	r2,0(r2)
 82496f8:	10803fcc 	andi	r2,r2,255
 82496fc:	e0bffd15 	stw	r2,-12(fp)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 8249700:	e0bffd17 	ldw	r2,-12(fp)
 8249704:	00000206 	br	8249710 <vgetc_locked+0xe4>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 8249708:	822d1c80 	call	822d1c8 <dtrap>
   return EOF;
 824970c:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249710:	e037883a 	mov	sp,fp
 8249714:	dfc00117 	ldw	ra,4(sp)
 8249718:	df000017 	ldw	fp,0(sp)
 824971c:	dec00204 	addi	sp,sp,8
 8249720:	f800283a 	ret

08249724 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 8249724:	defffc04 	addi	sp,sp,-16
 8249728:	dfc00315 	stw	ra,12(sp)
 824972c:	df000215 	stw	fp,8(sp)
 8249730:	df000204 	addi	fp,sp,8
 8249734:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249738:	01000144 	movi	r4,5
 824973c:	822d7dc0 	call	822d7dc <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 8249740:	e13fff17 	ldw	r4,-4(fp)
 8249744:	824962c0 	call	824962c <vgetc_locked>
 8249748:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 824974c:	01000144 	movi	r4,5
 8249750:	822d8980 	call	822d898 <post_app_sem>
   return rc;
 8249754:	e0bffe17 	ldw	r2,-8(fp)
}
 8249758:	e037883a 	mov	sp,fp
 824975c:	dfc00117 	ldw	ra,4(sp)
 8249760:	df000017 	ldw	fp,0(sp)
 8249764:	dec00204 	addi	sp,sp,8
 8249768:	f800283a 	ret

0824976c <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 824976c:	defffb04 	addi	sp,sp,-20
 8249770:	dfc00415 	stw	ra,16(sp)
 8249774:	df000315 	stw	fp,12(sp)
 8249778:	df000304 	addi	fp,sp,12
 824977c:	e13fff15 	stw	r4,-4(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 8249780:	e0bfff17 	ldw	r2,-4(fp)
 8249784:	10800003 	ldbu	r2,0(r2)
 8249788:	10803fcc 	andi	r2,r2,255
 824978c:	1080201c 	xori	r2,r2,128
 8249790:	10bfe004 	addi	r2,r2,-128
 8249794:	10800be0 	cmpeqi	r2,r2,47
 8249798:	1000071e 	bne	r2,zero,82497b8 <vfslookup_locked+0x4c>
 824979c:	e0bfff17 	ldw	r2,-4(fp)
 82497a0:	10800003 	ldbu	r2,0(r2)
 82497a4:	10803fcc 	andi	r2,r2,255
 82497a8:	1080201c 	xori	r2,r2,128
 82497ac:	10bfe004 	addi	r2,r2,-128
 82497b0:	10801718 	cmpnei	r2,r2,92
 82497b4:	1000191e 	bne	r2,zero,824981c <vfslookup_locked+0xb0>
   {
      cp = strippath(name);
 82497b8:	e13fff17 	ldw	r4,-4(fp)
 82497bc:	82498d80 	call	82498d8 <strippath>
 82497c0:	e0bffe15 	stw	r2,-8(fp)

      if (!cp) /* strippath coundn't match our path */
 82497c4:	e0bffe17 	ldw	r2,-8(fp)
 82497c8:	1000121e 	bne	r2,zero,8249814 <vfslookup_locked+0xa8>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 82497cc:	e0bfff17 	ldw	r2,-4(fp)
 82497d0:	10800003 	ldbu	r2,0(r2)
 82497d4:	10803fcc 	andi	r2,r2,255
 82497d8:	1080201c 	xori	r2,r2,128
 82497dc:	10bfe004 	addi	r2,r2,-128
 82497e0:	10800be0 	cmpeqi	r2,r2,47
 82497e4:	1000071e 	bne	r2,zero,8249804 <vfslookup_locked+0x98>
 82497e8:	e0bfff17 	ldw	r2,-4(fp)
 82497ec:	10800003 	ldbu	r2,0(r2)
 82497f0:	10803fcc 	andi	r2,r2,255
 82497f4:	1080201c 	xori	r2,r2,128
 82497f8:	10bfe004 	addi	r2,r2,-128
 82497fc:	10801718 	cmpnei	r2,r2,92
 8249800:	1000061e 	bne	r2,zero,824981c <vfslookup_locked+0xb0>
            name++;
 8249804:	e0bfff17 	ldw	r2,-4(fp)
 8249808:	10800044 	addi	r2,r2,1
 824980c:	e0bfff15 	stw	r2,-4(fp)
 8249810:	00000206 	br	824981c <vfslookup_locked+0xb0>
      }
      else
         name = cp ;
 8249814:	e0bffe17 	ldw	r2,-8(fp)
 8249818:	e0bfff15 	stw	r2,-4(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 824981c:	01400fc4 	movi	r5,63
 8249820:	e13fff17 	ldw	r4,-4(fp)
 8249824:	82032800 	call	8203280 <strchr>
 8249828:	10000326 	beq	r2,zero,8249838 <vfslookup_locked+0xcc>
   {
      dtrap(); /* is this still allowed? */
 824982c:	822d1c80 	call	822d1c8 <dtrap>
      return NULL;
 8249830:	0005883a 	mov	r2,zero
 8249834:	00001106 	br	824987c <vfslookup_locked+0x110>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249838:	d0a0d617 	ldw	r2,-31912(gp)
 824983c:	e0bffd15 	stw	r2,-12(fp)
 8249840:	00000b06 	br	8249870 <vfslookup_locked+0x104>
   {
      if (strcmp(name, vp->name) == 0)
 8249844:	e0bffd17 	ldw	r2,-12(fp)
 8249848:	10800104 	addi	r2,r2,4
 824984c:	100b883a 	mov	r5,r2
 8249850:	e13fff17 	ldw	r4,-4(fp)
 8249854:	820daa80 	call	820daa8 <strcmp>
 8249858:	1000021e 	bne	r2,zero,8249864 <vfslookup_locked+0xf8>
         return vp;
 824985c:	e0bffd17 	ldw	r2,-12(fp)
 8249860:	00000606 	br	824987c <vfslookup_locked+0x110>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249864:	e0bffd17 	ldw	r2,-12(fp)
 8249868:	10800017 	ldw	r2,0(r2)
 824986c:	e0bffd15 	stw	r2,-12(fp)
 8249870:	e0bffd17 	ldw	r2,-12(fp)
 8249874:	103ff31e 	bne	r2,zero,8249844 <vfslookup_locked+0xd8>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 8249878:	0005883a 	mov	r2,zero
}
 824987c:	e037883a 	mov	sp,fp
 8249880:	dfc00117 	ldw	ra,4(sp)
 8249884:	df000017 	ldw	fp,0(sp)
 8249888:	dec00204 	addi	sp,sp,8
 824988c:	f800283a 	ret

08249890 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 8249890:	defffc04 	addi	sp,sp,-16
 8249894:	dfc00315 	stw	ra,12(sp)
 8249898:	df000215 	stw	fp,8(sp)
 824989c:	df000204 	addi	fp,sp,8
 82498a0:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 82498a4:	01000144 	movi	r4,5
 82498a8:	822d7dc0 	call	822d7dc <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 82498ac:	e13fff17 	ldw	r4,-4(fp)
 82498b0:	824976c0 	call	824976c <vfslookup_locked>
 82498b4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 82498b8:	01000144 	movi	r4,5
 82498bc:	822d8980 	call	822d898 <post_app_sem>
   return vp;
 82498c0:	e0bffe17 	ldw	r2,-8(fp)
}
 82498c4:	e037883a 	mov	sp,fp
 82498c8:	dfc00117 	ldw	ra,4(sp)
 82498cc:	df000017 	ldw	fp,0(sp)
 82498d0:	dec00204 	addi	sp,sp,8
 82498d4:	f800283a 	ret

082498d8 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 82498d8:	defff904 	addi	sp,sp,-28
 82498dc:	dfc00615 	stw	ra,24(sp)
 82498e0:	df000515 	stw	fp,20(sp)
 82498e4:	df000504 	addi	fp,sp,20
 82498e8:	e13fff15 	stw	r4,-4(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 82498ec:	e13fff17 	ldw	r4,-4(fp)
 82498f0:	8228a180 	call	8228a18 <uslash>
 82498f4:	e0bffc15 	stw	r2,-16(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 82498f8:	d0a05517 	ldw	r2,-32428(gp)
 82498fc:	e0bffb15 	stw	r2,-20(fp)
   while (*path && *ntmp)
 8249900:	00003a06 	br	82499ec <strippath+0x114>
   {
      while (*path == '/') path++;   /* strip leading slash */
 8249904:	e0bffb17 	ldw	r2,-20(fp)
 8249908:	10800044 	addi	r2,r2,1
 824990c:	e0bffb15 	stw	r2,-20(fp)
 8249910:	e0bffb17 	ldw	r2,-20(fp)
 8249914:	10800003 	ldbu	r2,0(r2)
 8249918:	10803fcc 	andi	r2,r2,255
 824991c:	1080201c 	xori	r2,r2,128
 8249920:	10bfe004 	addi	r2,r2,-128
 8249924:	10800be0 	cmpeqi	r2,r2,47
 8249928:	103ff61e 	bne	r2,zero,8249904 <strippath+0x2c>
         if (*path == 0)
 824992c:	e0bffb17 	ldw	r2,-20(fp)
 8249930:	10800003 	ldbu	r2,0(r2)
 8249934:	10803fcc 	andi	r2,r2,255
 8249938:	1080201c 	xori	r2,r2,128
 824993c:	10bfe004 	addi	r2,r2,-128
 8249940:	10003726 	beq	r2,zero,8249a20 <strippath+0x148>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 8249944:	01400bc4 	movi	r5,47
 8249948:	e13ffb17 	ldw	r4,-20(fp)
 824994c:	82032800 	call	8203280 <strchr>
 8249950:	e0bffe15 	stw	r2,-8(fp)
      if (ptmp)
 8249954:	e0bffe17 	ldw	r2,-8(fp)
 8249958:	10000526 	beq	r2,zero,8249970 <strippath+0x98>
         dirlen = ptmp - path;
 824995c:	e0fffe17 	ldw	r3,-8(fp)
 8249960:	e0bffb17 	ldw	r2,-20(fp)
 8249964:	1885c83a 	sub	r2,r3,r2
 8249968:	e0bffd15 	stw	r2,-12(fp)
 824996c:	00000706 	br	824998c <strippath+0xb4>
      else
         dirlen = strlen(path);
 8249970:	e13ffb17 	ldw	r4,-20(fp)
 8249974:	8203a5c0 	call	8203a5c <strlen>
 8249978:	e0bffd15 	stw	r2,-12(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 824997c:	00000306 	br	824998c <strippath+0xb4>
 8249980:	e0bffc17 	ldw	r2,-16(fp)
 8249984:	10800044 	addi	r2,r2,1
 8249988:	e0bffc15 	stw	r2,-16(fp)
 824998c:	e0bffc17 	ldw	r2,-16(fp)
 8249990:	10800003 	ldbu	r2,0(r2)
 8249994:	10803fcc 	andi	r2,r2,255
 8249998:	1080201c 	xori	r2,r2,128
 824999c:	10bfe004 	addi	r2,r2,-128
 82499a0:	10800be0 	cmpeqi	r2,r2,47
 82499a4:	103ff61e 	bne	r2,zero,8249980 <strippath+0xa8>
         if (strncmp(ntmp, path, dirlen) == 0)
 82499a8:	e0bffd17 	ldw	r2,-12(fp)
 82499ac:	100d883a 	mov	r6,r2
 82499b0:	e17ffb17 	ldw	r5,-20(fp)
 82499b4:	e13ffc17 	ldw	r4,-16(fp)
 82499b8:	824b2440 	call	824b244 <strncmp>
 82499bc:	1000091e 	bne	r2,zero,82499e4 <strippath+0x10c>
      {
         path += dirlen;
 82499c0:	e0bffd17 	ldw	r2,-12(fp)
 82499c4:	e0fffb17 	ldw	r3,-20(fp)
 82499c8:	1885883a 	add	r2,r3,r2
 82499cc:	e0bffb15 	stw	r2,-20(fp)
         ntmp += dirlen;
 82499d0:	e0bffd17 	ldw	r2,-12(fp)
 82499d4:	e0fffc17 	ldw	r3,-16(fp)
 82499d8:	1885883a 	add	r2,r3,r2
 82499dc:	e0bffc15 	stw	r2,-16(fp)
 82499e0:	00000206 	br	82499ec <strippath+0x114>
      }
      else
         return NULL;   /* didn't match */
 82499e4:	0005883a 	mov	r2,zero
 82499e8:	00002906 	br	8249a90 <strippath+0x1b8>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 82499ec:	e0bffb17 	ldw	r2,-20(fp)
 82499f0:	10800003 	ldbu	r2,0(r2)
 82499f4:	10803fcc 	andi	r2,r2,255
 82499f8:	1080201c 	xori	r2,r2,128
 82499fc:	10bfe004 	addi	r2,r2,-128
 8249a00:	10000826 	beq	r2,zero,8249a24 <strippath+0x14c>
 8249a04:	e0bffc17 	ldw	r2,-16(fp)
 8249a08:	10800003 	ldbu	r2,0(r2)
 8249a0c:	10803fcc 	andi	r2,r2,255
 8249a10:	1080201c 	xori	r2,r2,128
 8249a14:	10bfe004 	addi	r2,r2,-128
 8249a18:	103fbd1e 	bne	r2,zero,8249910 <strippath+0x38>
 8249a1c:	00000106 	br	8249a24 <strippath+0x14c>
   {
      while (*path == '/') path++;   /* strip leading slash */
         if (*path == 0)
         break;
 8249a20:	0001883a 	nop
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 8249a24:	e0bffb17 	ldw	r2,-20(fp)
 8249a28:	10800003 	ldbu	r2,0(r2)
 8249a2c:	10803fcc 	andi	r2,r2,255
 8249a30:	1080201c 	xori	r2,r2,128
 8249a34:	10bfe004 	addi	r2,r2,-128
 8249a38:	1000141e 	bne	r2,zero,8249a8c <strippath+0x1b4>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249a3c:	00000306 	br	8249a4c <strippath+0x174>
         ntmp++;
 8249a40:	e0bffc17 	ldw	r2,-16(fp)
 8249a44:	10800044 	addi	r2,r2,1
 8249a48:	e0bffc15 	stw	r2,-16(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249a4c:	e0bffc17 	ldw	r2,-16(fp)
 8249a50:	10800003 	ldbu	r2,0(r2)
 8249a54:	10803fcc 	andi	r2,r2,255
 8249a58:	1080201c 	xori	r2,r2,128
 8249a5c:	10bfe004 	addi	r2,r2,-128
 8249a60:	10801720 	cmpeqi	r2,r2,92
 8249a64:	103ff61e 	bne	r2,zero,8249a40 <strippath+0x168>
 8249a68:	e0bffc17 	ldw	r2,-16(fp)
 8249a6c:	10800003 	ldbu	r2,0(r2)
 8249a70:	10803fcc 	andi	r2,r2,255
 8249a74:	1080201c 	xori	r2,r2,128
 8249a78:	10bfe004 	addi	r2,r2,-128
 8249a7c:	10800be0 	cmpeqi	r2,r2,47
 8249a80:	103fef1e 	bne	r2,zero,8249a40 <strippath+0x168>
         ntmp++;
      return ntmp;
 8249a84:	e0bffc17 	ldw	r2,-16(fp)
 8249a88:	00000106 	br	8249a90 <strippath+0x1b8>
   }
   else
      return NULL;
 8249a8c:	0005883a 	mov	r2,zero
}
 8249a90:	e037883a 	mov	sp,fp
 8249a94:	dfc00117 	ldw	ra,4(sp)
 8249a98:	df000017 	ldw	fp,0(sp)
 8249a9c:	dec00204 	addi	sp,sp,8
 8249aa0:	f800283a 	ret

08249aa4 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 8249aa4:	defffd04 	addi	sp,sp,-12
 8249aa8:	df000215 	stw	fp,8(sp)
 8249aac:	df000204 	addi	fp,sp,8
 8249ab0:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249ab4:	d0a0d517 	ldw	r2,-31916(gp)
 8249ab8:	e0bffe15 	stw	r2,-8(fp)
 8249abc:	00000806 	br	8249ae0 <isvfile_locked+0x3c>
      if (vtmp == vfp)
 8249ac0:	e0fffe17 	ldw	r3,-8(fp)
 8249ac4:	e0bfff17 	ldw	r2,-4(fp)
 8249ac8:	1880021e 	bne	r3,r2,8249ad4 <isvfile_locked+0x30>
      return TRUE;
 8249acc:	00800044 	movi	r2,1
 8249ad0:	00000606 	br	8249aec <isvfile_locked+0x48>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249ad4:	e0bffe17 	ldw	r2,-8(fp)
 8249ad8:	10800017 	ldw	r2,0(r2)
 8249adc:	e0bffe15 	stw	r2,-8(fp)
 8249ae0:	e0bffe17 	ldw	r2,-8(fp)
 8249ae4:	103ff61e 	bne	r2,zero,8249ac0 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 8249ae8:	0005883a 	mov	r2,zero
}
 8249aec:	e037883a 	mov	sp,fp
 8249af0:	df000017 	ldw	fp,0(sp)
 8249af4:	dec00104 	addi	sp,sp,4
 8249af8:	f800283a 	ret

08249afc <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 8249afc:	defffc04 	addi	sp,sp,-16
 8249b00:	dfc00315 	stw	ra,12(sp)
 8249b04:	df000215 	stw	fp,8(sp)
 8249b08:	df000204 	addi	fp,sp,8
 8249b0c:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249b10:	01000144 	movi	r4,5
 8249b14:	822d7dc0 	call	822d7dc <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 8249b18:	e13fff17 	ldw	r4,-4(fp)
 8249b1c:	8249aa40 	call	8249aa4 <isvfile_locked>
 8249b20:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249b24:	01000144 	movi	r4,5
 8249b28:	822d8980 	call	822d898 <post_app_sem>
   return rc;
 8249b2c:	e0bffe17 	ldw	r2,-8(fp)
}
 8249b30:	e037883a 	mov	sp,fp
 8249b34:	dfc00117 	ldw	ra,4(sp)
 8249b38:	df000017 	ldw	fp,0(sp)
 8249b3c:	dec00204 	addi	sp,sp,8
 8249b40:	f800283a 	ret

08249b44 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 8249b44:	defffd04 	addi	sp,sp,-12
 8249b48:	dfc00215 	stw	ra,8(sp)
 8249b4c:	df000115 	stw	fp,4(sp)
 8249b50:	df000104 	addi	fp,sp,4
 8249b54:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249b58:	01000144 	movi	r4,5
 8249b5c:	822d7dc0 	call	822d7dc <wait_app_sem>

   if (isvfile_locked(vfd))
 8249b60:	e13fff17 	ldw	r4,-4(fp)
 8249b64:	8249aa40 	call	8249aa4 <isvfile_locked>
 8249b68:	10000526 	beq	r2,zero,8249b80 <vferror+0x3c>
   {
      vfs_unlock();
 8249b6c:	01000144 	movi	r4,5
 8249b70:	822d8980 	call	822d898 <post_app_sem>

      return vfd->error;
 8249b74:	e0bfff17 	ldw	r2,-4(fp)
 8249b78:	10800417 	ldw	r2,16(r2)
 8249b7c:	00000306 	br	8249b8c <vferror+0x48>
   }

   vfs_unlock();
 8249b80:	01000144 	movi	r4,5
 8249b84:	822d8980 	call	822d898 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 8249b88:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249b8c:	e037883a 	mov	sp,fp
 8249b90:	dfc00117 	ldw	ra,4(sp)
 8249b94:	df000017 	ldw	fp,0(sp)
 8249b98:	dec00204 	addi	sp,sp,8
 8249b9c:	f800283a 	ret

08249ba0 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 8249ba0:	defffd04 	addi	sp,sp,-12
 8249ba4:	dfc00215 	stw	ra,8(sp)
 8249ba8:	df000115 	stw	fp,4(sp)
 8249bac:	df000104 	addi	fp,sp,4
 8249bb0:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249bb4:	01000144 	movi	r4,5
 8249bb8:	822d7dc0 	call	822d7dc <wait_app_sem>

   if (isvfile_locked(vfd))
 8249bbc:	e13fff17 	ldw	r4,-4(fp)
 8249bc0:	8249aa40 	call	8249aa4 <isvfile_locked>
 8249bc4:	10000526 	beq	r2,zero,8249bdc <vclearerr+0x3c>
   {
      vfs_unlock();
 8249bc8:	01000144 	movi	r4,5
 8249bcc:	822d8980 	call	822d898 <post_app_sem>

      vfd->error = 0;
 8249bd0:	e0bfff17 	ldw	r2,-4(fp)
 8249bd4:	10000415 	stw	zero,16(r2)
      return;
 8249bd8:	00000206 	br	8249be4 <vclearerr+0x44>
   }

   vfs_unlock();
 8249bdc:	01000144 	movi	r4,5
 8249be0:	822d8980 	call	822d898 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 8249be4:	e037883a 	mov	sp,fp
 8249be8:	dfc00117 	ldw	ra,4(sp)
 8249bec:	df000017 	ldw	fp,0(sp)
 8249bf0:	dec00204 	addi	sp,sp,8
 8249bf4:	f800283a 	ret

08249bf8 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 8249bf8:	defffe04 	addi	sp,sp,-8
 8249bfc:	df000115 	stw	fp,4(sp)
 8249c00:	df000104 	addi	fp,sp,4
int e = 0;
 8249c04:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 8249c08:	e0bfff17 	ldw	r2,-4(fp)
}
 8249c0c:	e037883a 	mov	sp,fp
 8249c10:	df000017 	ldw	fp,0(sp)
 8249c14:	dec00104 	addi	sp,sp,4
 8249c18:	f800283a 	ret

08249c1c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8249c1c:	defffe04 	addi	sp,sp,-8
 8249c20:	dfc00115 	stw	ra,4(sp)
 8249c24:	df000015 	stw	fp,0(sp)
 8249c28:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8249c2c:	d0a04717 	ldw	r2,-32484(gp)
 8249c30:	10000326 	beq	r2,zero,8249c40 <alt_get_errno+0x24>
 8249c34:	d0a04717 	ldw	r2,-32484(gp)
 8249c38:	103ee83a 	callr	r2
 8249c3c:	00000106 	br	8249c44 <alt_get_errno+0x28>
 8249c40:	d0a06304 	addi	r2,gp,-32372
}
 8249c44:	e037883a 	mov	sp,fp
 8249c48:	dfc00117 	ldw	ra,4(sp)
 8249c4c:	df000017 	ldw	fp,0(sp)
 8249c50:	dec00204 	addi	sp,sp,8
 8249c54:	f800283a 	ret

08249c58 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 8249c58:	defff704 	addi	sp,sp,-36
 8249c5c:	dfc00615 	stw	ra,24(sp)
 8249c60:	df000515 	stw	fp,20(sp)
 8249c64:	df000504 	addi	fp,sp,20
 8249c68:	e13ffe15 	stw	r4,-8(fp)
 8249c6c:	e17fff15 	stw	r5,-4(fp)
 8249c70:	e1800215 	stw	r6,8(fp)
 8249c74:	e1c00315 	stw	r7,12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8249c78:	e0bffe17 	ldw	r2,-8(fp)
 8249c7c:	10000616 	blt	r2,zero,8249c98 <alt_fcntl+0x40>
 8249c80:	e0bffe17 	ldw	r2,-8(fp)
 8249c84:	10c00324 	muli	r3,r2,12
 8249c88:	00820974 	movhi	r2,2085
 8249c8c:	108d6a04 	addi	r2,r2,13736
 8249c90:	1885883a 	add	r2,r3,r2
 8249c94:	00000106 	br	8249c9c <alt_fcntl+0x44>
 8249c98:	0005883a 	mov	r2,zero
 8249c9c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 8249ca0:	e0bffb17 	ldw	r2,-20(fp)
 8249ca4:	10002a26 	beq	r2,zero,8249d50 <alt_fcntl+0xf8>
  {
    switch (cmd)
 8249ca8:	e0bfff17 	ldw	r2,-4(fp)
 8249cac:	10c000e0 	cmpeqi	r3,r2,3
 8249cb0:	1800031e 	bne	r3,zero,8249cc0 <alt_fcntl+0x68>
 8249cb4:	10800120 	cmpeqi	r2,r2,4
 8249cb8:	1000071e 	bne	r2,zero,8249cd8 <alt_fcntl+0x80>
 8249cbc:	00001e06 	br	8249d38 <alt_fcntl+0xe0>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 8249cc0:	e0bffb17 	ldw	r2,-20(fp)
 8249cc4:	10c00217 	ldw	r3,8(r2)
 8249cc8:	00900034 	movhi	r2,16384
 8249ccc:	10bfffc4 	addi	r2,r2,-1
 8249cd0:	1884703a 	and	r2,r3,r2
 8249cd4:	00002306 	br	8249d64 <alt_fcntl+0x10c>
    case F_SETFL:
      va_start(argp, cmd);
 8249cd8:	e0800204 	addi	r2,fp,8
 8249cdc:	e0bffd15 	stw	r2,-12(fp)
      flags = va_arg(argp, long);
 8249ce0:	e0bffd17 	ldw	r2,-12(fp)
 8249ce4:	10c00104 	addi	r3,r2,4
 8249ce8:	e0fffd15 	stw	r3,-12(fp)
 8249cec:	10800017 	ldw	r2,0(r2)
 8249cf0:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 8249cf4:	e0bffb17 	ldw	r2,-20(fp)
 8249cf8:	10c00217 	ldw	r3,8(r2)
 8249cfc:	00affdc4 	movi	r2,-16393
 8249d00:	1886703a 	and	r3,r3,r2
 8249d04:	e0bffb17 	ldw	r2,-20(fp)
 8249d08:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 8249d0c:	e0bffb17 	ldw	r2,-20(fp)
 8249d10:	10800217 	ldw	r2,8(r2)
 8249d14:	1007883a 	mov	r3,r2
 8249d18:	e0bffc17 	ldw	r2,-16(fp)
 8249d1c:	1090020c 	andi	r2,r2,16392
 8249d20:	1884b03a 	or	r2,r3,r2
 8249d24:	1007883a 	mov	r3,r2
 8249d28:	e0bffb17 	ldw	r2,-20(fp)
 8249d2c:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 8249d30:	0005883a 	mov	r2,zero
 8249d34:	00000b06 	br	8249d64 <alt_fcntl+0x10c>
    default:
      ALT_ERRNO = EINVAL;
 8249d38:	8249c1c0 	call	8249c1c <alt_get_errno>
 8249d3c:	1007883a 	mov	r3,r2
 8249d40:	00800584 	movi	r2,22
 8249d44:	18800015 	stw	r2,0(r3)
      return -1;
 8249d48:	00bfffc4 	movi	r2,-1
 8249d4c:	00000506 	br	8249d64 <alt_fcntl+0x10c>
    }
  }

  ALT_ERRNO = EBADFD;
 8249d50:	8249c1c0 	call	8249c1c <alt_get_errno>
 8249d54:	1007883a 	mov	r3,r2
 8249d58:	00801444 	movi	r2,81
 8249d5c:	18800015 	stw	r2,0(r3)
  return -1;
 8249d60:	00bfffc4 	movi	r2,-1
}
 8249d64:	e037883a 	mov	sp,fp
 8249d68:	dfc00117 	ldw	ra,4(sp)
 8249d6c:	df000017 	ldw	fp,0(sp)
 8249d70:	dec00404 	addi	sp,sp,16
 8249d74:	f800283a 	ret

08249d78 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 8249d78:	defffb04 	addi	sp,sp,-20
 8249d7c:	dfc00415 	stw	ra,16(sp)
 8249d80:	df000315 	stw	fp,12(sp)
 8249d84:	df000304 	addi	fp,sp,12
 8249d88:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 8249d8c:	d0a04217 	ldw	r2,-32504(gp)
 8249d90:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 8249d94:	00003106 	br	8249e5c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 8249d98:	e0bffd17 	ldw	r2,-12(fp)
 8249d9c:	10800217 	ldw	r2,8(r2)
 8249da0:	1009883a 	mov	r4,r2
 8249da4:	8203a5c0 	call	8203a5c <strlen>
 8249da8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 8249dac:	e0bffd17 	ldw	r2,-12(fp)
 8249db0:	10c00217 	ldw	r3,8(r2)
 8249db4:	e0bffe17 	ldw	r2,-8(fp)
 8249db8:	10bfffc4 	addi	r2,r2,-1
 8249dbc:	1885883a 	add	r2,r3,r2
 8249dc0:	10800003 	ldbu	r2,0(r2)
 8249dc4:	10803fcc 	andi	r2,r2,255
 8249dc8:	1080201c 	xori	r2,r2,128
 8249dcc:	10bfe004 	addi	r2,r2,-128
 8249dd0:	10800bd8 	cmpnei	r2,r2,47
 8249dd4:	1000031e 	bne	r2,zero,8249de4 <alt_find_file+0x6c>
    {
      len -= 1;
 8249dd8:	e0bffe17 	ldw	r2,-8(fp)
 8249ddc:	10bfffc4 	addi	r2,r2,-1
 8249de0:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 8249de4:	e0bffe17 	ldw	r2,-8(fp)
 8249de8:	e0ffff17 	ldw	r3,-4(fp)
 8249dec:	1885883a 	add	r2,r3,r2
 8249df0:	10800003 	ldbu	r2,0(r2)
 8249df4:	10803fcc 	andi	r2,r2,255
 8249df8:	1080201c 	xori	r2,r2,128
 8249dfc:	10bfe004 	addi	r2,r2,-128
 8249e00:	10800be0 	cmpeqi	r2,r2,47
 8249e04:	1000081e 	bne	r2,zero,8249e28 <alt_find_file+0xb0>
 8249e08:	e0bffe17 	ldw	r2,-8(fp)
 8249e0c:	e0ffff17 	ldw	r3,-4(fp)
 8249e10:	1885883a 	add	r2,r3,r2
 8249e14:	10800003 	ldbu	r2,0(r2)
 8249e18:	10803fcc 	andi	r2,r2,255
 8249e1c:	1080201c 	xori	r2,r2,128
 8249e20:	10bfe004 	addi	r2,r2,-128
 8249e24:	10000a1e 	bne	r2,zero,8249e50 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 8249e28:	e0bffd17 	ldw	r2,-12(fp)
 8249e2c:	10800217 	ldw	r2,8(r2)
 8249e30:	e0fffe17 	ldw	r3,-8(fp)
 8249e34:	180d883a 	mov	r6,r3
 8249e38:	e17fff17 	ldw	r5,-4(fp)
 8249e3c:	1009883a 	mov	r4,r2
 8249e40:	820c0d80 	call	820c0d8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 8249e44:	1000021e 	bne	r2,zero,8249e50 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 8249e48:	e0bffd17 	ldw	r2,-12(fp)
 8249e4c:	00000706 	br	8249e6c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 8249e50:	e0bffd17 	ldw	r2,-12(fp)
 8249e54:	10800017 	ldw	r2,0(r2)
 8249e58:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 8249e5c:	e0fffd17 	ldw	r3,-12(fp)
 8249e60:	d0a04204 	addi	r2,gp,-32504
 8249e64:	18bfcc1e 	bne	r3,r2,8249d98 <alt_find_file+0x20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 8249e68:	0005883a 	mov	r2,zero
}
 8249e6c:	e037883a 	mov	sp,fp
 8249e70:	dfc00117 	ldw	ra,4(sp)
 8249e74:	df000017 	ldw	fp,0(sp)
 8249e78:	dec00204 	addi	sp,sp,8
 8249e7c:	f800283a 	ret

08249e80 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 8249e80:	defff904 	addi	sp,sp,-28
 8249e84:	dfc00615 	stw	ra,24(sp)
 8249e88:	df000515 	stw	fp,20(sp)
 8249e8c:	df000504 	addi	fp,sp,20
 8249e90:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 8249e94:	00bffa04 	movi	r2,-24
 8249e98:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 8249e9c:	d0a0b617 	ldw	r2,-32040(gp)
 8249ea0:	e0bffd15 	stw	r2,-12(fp)
 8249ea4:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 8249ea8:	e0bffe0b 	ldhu	r2,-8(fp)
 8249eac:	e0fffe84 	addi	r3,fp,-6
 8249eb0:	180d883a 	mov	r6,r3
 8249eb4:	100b883a 	mov	r5,r2
 8249eb8:	e13ffd17 	ldw	r4,-12(fp)
 8249ebc:	8219d080 	call	8219d08 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 8249ec0:	e03ffb15 	stw	zero,-20(fp)
 8249ec4:	00001906 	br	8249f2c <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
 8249ec8:	00820974 	movhi	r2,2085
 8249ecc:	108d6a04 	addi	r2,r2,13736
 8249ed0:	e0fffb17 	ldw	r3,-20(fp)
 8249ed4:	18c00324 	muli	r3,r3,12
 8249ed8:	10c5883a 	add	r2,r2,r3
 8249edc:	10800017 	ldw	r2,0(r2)
 8249ee0:	10000f1e 	bne	r2,zero,8249f20 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
 8249ee4:	00820974 	movhi	r2,2085
 8249ee8:	108d6a04 	addi	r2,r2,13736
 8249eec:	e0fffb17 	ldw	r3,-20(fp)
 8249ef0:	18c00324 	muli	r3,r3,12
 8249ef4:	10c5883a 	add	r2,r2,r3
 8249ef8:	e0ffff17 	ldw	r3,-4(fp)
 8249efc:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 8249f00:	d0e04617 	ldw	r3,-32488(gp)
 8249f04:	e0bffb17 	ldw	r2,-20(fp)
 8249f08:	1880020e 	bge	r3,r2,8249f14 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
 8249f0c:	e0bffb17 	ldw	r2,-20(fp)
 8249f10:	d0a04615 	stw	r2,-32488(gp)
      }
      rc = i;
 8249f14:	e0bffb17 	ldw	r2,-20(fp)
 8249f18:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 8249f1c:	00000606 	br	8249f38 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 8249f20:	e0bffb17 	ldw	r2,-20(fp)
 8249f24:	10800044 	addi	r2,r2,1
 8249f28:	e0bffb15 	stw	r2,-20(fp)
 8249f2c:	e0bffb17 	ldw	r2,-20(fp)
 8249f30:	10800810 	cmplti	r2,r2,32
 8249f34:	103fe41e 	bne	r2,zero,8249ec8 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 8249f38:	d0a0b617 	ldw	r2,-32040(gp)
 8249f3c:	1009883a 	mov	r4,r2
 8249f40:	821a0800 	call	821a080 <OSSemPost>

  return rc;
 8249f44:	e0bffc17 	ldw	r2,-16(fp)
}
 8249f48:	e037883a 	mov	sp,fp
 8249f4c:	dfc00117 	ldw	ra,4(sp)
 8249f50:	df000017 	ldw	fp,0(sp)
 8249f54:	dec00204 	addi	sp,sp,8
 8249f58:	f800283a 	ret

08249f5c <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 8249f5c:	deffef04 	addi	sp,sp,-68
 8249f60:	dfc01015 	stw	ra,64(sp)
 8249f64:	df000f15 	stw	fp,60(sp)
 8249f68:	dc400e15 	stw	r17,56(sp)
 8249f6c:	dc000d15 	stw	r16,52(sp)
 8249f70:	df000f04 	addi	fp,sp,60
 8249f74:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 8249f78:	e03ff305 	stb	zero,-52(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 8249f7c:	008209b4 	movhi	r2,2086
 8249f80:	10b91604 	addi	r2,r2,-7080
 8249f84:	10800017 	ldw	r2,0(r2)
 8249f88:	10c00044 	addi	r3,r2,1
 8249f8c:	008209b4 	movhi	r2,2086
 8249f90:	10b91604 	addi	r2,r2,-7080
 8249f94:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 8249f98:	e0bffd17 	ldw	r2,-12(fp)
 8249f9c:	10800317 	ldw	r2,12(r2)
 8249fa0:	e0bff415 	stw	r2,-48(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 8249fa4:	e0bffd17 	ldw	r2,-12(fp)
 8249fa8:	10c00417 	ldw	r3,16(r2)
 8249fac:	e0bff417 	ldw	r2,-48(fp)
 8249fb0:	10800003 	ldbu	r2,0(r2)
 8249fb4:	10803fcc 	andi	r2,r2,255
 8249fb8:	108003cc 	andi	r2,r2,15
 8249fbc:	1085883a 	add	r2,r2,r2
 8249fc0:	1085883a 	add	r2,r2,r2
 8249fc4:	1885c83a 	sub	r2,r3,r2
 8249fc8:	e0bff515 	stw	r2,-44(fp)
   host = p->fhost;                       /* filled in by IP layer */
 8249fcc:	e0bffd17 	ldw	r2,-12(fp)
 8249fd0:	10800717 	ldw	r2,28(r2)
 8249fd4:	e0bff615 	stw	r2,-40(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8249fd8:	d0a08317 	ldw	r2,-32244(gp)
 8249fdc:	1081000c 	andi	r2,r2,1024
 8249fe0:	10001526 	beq	r2,zero,824a038 <icmprcv+0xdc>
 8249fe4:	d0a08317 	ldw	r2,-32244(gp)
 8249fe8:	1080800c 	andi	r2,r2,512
 8249fec:	10001226 	beq	r2,zero,824a038 <icmprcv+0xdc>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 8249ff0:	e0bff617 	ldw	r2,-40(fp)
 8249ff4:	11003fcc 	andi	r4,r2,255
 8249ff8:	e0bff617 	ldw	r2,-40(fp)
 8249ffc:	1004d23a 	srli	r2,r2,8
 824a000:	11403fcc 	andi	r5,r2,255
 824a004:	e0bff617 	ldw	r2,-40(fp)
 824a008:	1004d43a 	srli	r2,r2,16
 824a00c:	10803fcc 	andi	r2,r2,255
 824a010:	e0fff617 	ldw	r3,-40(fp)
 824a014:	1806d63a 	srli	r3,r3,24
 824a018:	d8c00115 	stw	r3,4(sp)
 824a01c:	d8800015 	stw	r2,0(sp)
 824a020:	280f883a 	mov	r7,r5
 824a024:	200d883a 	mov	r6,r4
 824a028:	e17ff517 	ldw	r5,-44(fp)
 824a02c:	01020974 	movhi	r4,2085
 824a030:	21058304 	addi	r4,r4,5644
 824a034:	8202e9c0 	call	8202e9c <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 824a038:	e0bff417 	ldw	r2,-48(fp)
 824a03c:	10800003 	ldbu	r2,0(r2)
 824a040:	10803fcc 	andi	r2,r2,255
 824a044:	108003cc 	andi	r2,r2,15
 824a048:	1085883a 	add	r2,r2,r2
 824a04c:	1085883a 	add	r2,r2,r2
 824a050:	1007883a 	mov	r3,r2
 824a054:	e0bff417 	ldw	r2,-48(fp)
 824a058:	10c5883a 	add	r2,r2,r3
 824a05c:	e0bff715 	stw	r2,-36(fp)

   osum = e->pchksum;
 824a060:	e0bff717 	ldw	r2,-36(fp)
 824a064:	1080008b 	ldhu	r2,2(r2)
 824a068:	e0bff80d 	sth	r2,-32(fp)
   e->pchksum = 0;
 824a06c:	e0bff717 	ldw	r2,-36(fp)
 824a070:	1000008d 	sth	zero,2(r2)

   if (len&1)
 824a074:	e0bff517 	ldw	r2,-44(fp)
 824a078:	1080004c 	andi	r2,r2,1
 824a07c:	10000926 	beq	r2,zero,824a0a4 <icmprcv+0x148>
   {
      sav_ch = *(((char *) e) + len);
 824a080:	e0fff717 	ldw	r3,-36(fp)
 824a084:	e0bff517 	ldw	r2,-44(fp)
 824a088:	1885883a 	add	r2,r3,r2
 824a08c:	10800003 	ldbu	r2,0(r2)
 824a090:	e0bff305 	stb	r2,-52(fp)
      ((char *)e)[len] = 0;
 824a094:	e0fff717 	ldw	r3,-36(fp)
 824a098:	e0bff517 	ldw	r2,-44(fp)
 824a09c:	1885883a 	add	r2,r3,r2
 824a0a0:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 824a0a4:	e0bff517 	ldw	r2,-44(fp)
 824a0a8:	10800044 	addi	r2,r2,1
 824a0ac:	1004d07a 	srli	r2,r2,1
 824a0b0:	100b883a 	mov	r5,r2
 824a0b4:	e13ff717 	ldw	r4,-36(fp)
 824a0b8:	82283e80 	call	82283e8 <cksum>
 824a0bc:	0084303a 	nor	r2,zero,r2
 824a0c0:	e0bff88d 	sth	r2,-30(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 824a0c4:	e0bff517 	ldw	r2,-44(fp)
 824a0c8:	1080004c 	andi	r2,r2,1
 824a0cc:	10000526 	beq	r2,zero,824a0e4 <icmprcv+0x188>
 824a0d0:	e0fff717 	ldw	r3,-36(fp)
 824a0d4:	e0bff517 	ldw	r2,-44(fp)
 824a0d8:	1885883a 	add	r2,r3,r2
 824a0dc:	e0fff303 	ldbu	r3,-52(fp)
 824a0e0:	10c00005 	stb	r3,0(r2)
   if (xsum != osum)
 824a0e4:	e0fff88b 	ldhu	r3,-30(fp)
 824a0e8:	e0bff80b 	ldhu	r2,-32(fp)
 824a0ec:	18802426 	beq	r3,r2,824a180 <icmprcv+0x224>
   {
      e->pchksum = osum;
 824a0f0:	e0bff717 	ldw	r2,-36(fp)
 824a0f4:	e0fff80b 	ldhu	r3,-32(fp)
 824a0f8:	10c0008d 	sth	r3,2(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a0fc:	d0a08317 	ldw	r2,-32244(gp)
 824a100:	1081000c 	andi	r2,r2,1024
 824a104:	10000f26 	beq	r2,zero,824a144 <icmprcv+0x1e8>
 824a108:	d0a08317 	ldw	r2,-32244(gp)
 824a10c:	1080800c 	andi	r2,r2,512
 824a110:	10000c26 	beq	r2,zero,824a144 <icmprcv+0x1e8>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 824a114:	e0bff80b 	ldhu	r2,-32(fp)
 824a118:	e0fff88b 	ldhu	r3,-30(fp)
 824a11c:	180d883a 	mov	r6,r3
 824a120:	100b883a 	mov	r5,r2
 824a124:	01020974 	movhi	r4,2085
 824a128:	21058b04 	addi	r4,r4,5676
 824a12c:	8202e9c0 	call	8202e9c <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 824a130:	d0a08317 	ldw	r2,-32244(gp)
 824a134:	1080008c 	andi	r2,r2,2
 824a138:	10000226 	beq	r2,zero,824a144 <icmprcv+0x1e8>
 824a13c:	e13ffd17 	ldw	r4,-12(fp)
 824a140:	82406940 	call	8240694 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 824a144:	008209b4 	movhi	r2,2086
 824a148:	10b91604 	addi	r2,r2,-7080
 824a14c:	10800117 	ldw	r2,4(r2)
 824a150:	10c00044 	addi	r3,r2,1
 824a154:	008209b4 	movhi	r2,2086
 824a158:	10b91604 	addi	r2,r2,-7080
 824a15c:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a160:	01000084 	movi	r4,2
 824a164:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a168:	e13ffd17 	ldw	r4,-12(fp)
 824a16c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a170:	01000084 	movi	r4,2
 824a174:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 824a178:	00bff804 	movi	r2,-32
 824a17c:	00024906 	br	824aaa4 <icmprcv+0xb48>
   }

   e->pchksum = osum;
 824a180:	e0bff717 	ldw	r2,-36(fp)
 824a184:	e0fff80b 	ldhu	r3,-32(fp)
 824a188:	10c0008d 	sth	r3,2(r2)

   switch (e->ptype) 
 824a18c:	e0bff717 	ldw	r2,-36(fp)
 824a190:	10800003 	ldbu	r2,0(r2)
 824a194:	10803fcc 	andi	r2,r2,255
 824a198:	1080201c 	xori	r2,r2,128
 824a19c:	10bfe004 	addi	r2,r2,-128
 824a1a0:	10c00428 	cmpgeui	r3,r2,16
 824a1a4:	1802251e 	bne	r3,zero,824aa3c <icmprcv+0xae0>
 824a1a8:	100690ba 	slli	r3,r2,2
 824a1ac:	00820974 	movhi	r2,2085
 824a1b0:	10a87004 	addi	r2,r2,-24128
 824a1b4:	1885883a 	add	r2,r3,r2
 824a1b8:	10800017 	ldw	r2,0(r2)
 824a1bc:	1000683a 	jmp	r2
 824a1c0:	0824a474 	orhi	zero,at,37521
 824a1c4:	0824aa3c 	xorhi	zero,at,37544
 824a1c8:	0824aa3c 	xorhi	zero,at,37544
 824a1cc:	0824a49c 	xori	zero,at,37522
 824a1d0:	0824a598 	cmpnei	zero,at,-28010
 824a1d4:	0824a634 	orhi	zero,at,37528
 824a1d8:	0824aa3c 	xorhi	zero,at,37544
 824a1dc:	0824aa3c 	xorhi	zero,at,37544
 824a1e0:	0824a200 	call	824a20 <OSCtxSw_SWITCH_PC+0x8249e0>
 824a1e4:	0824aa3c 	xorhi	zero,at,37544
 824a1e8:	0824aa3c 	xorhi	zero,at,37544
 824a1ec:	0824a768 	cmpgeui	zero,at,37533
 824a1f0:	0824a870 	cmpltui	zero,at,37537
 824a1f4:	0824a8d4 	ori	zero,at,37539
 824a1f8:	0824aa3c 	xorhi	zero,at,37544
 824a1fc:	0824aa08 	cmpgei	zero,at,-27992
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 824a200:	008209b4 	movhi	r2,2086
 824a204:	10b91604 	addi	r2,r2,-7080
 824a208:	10800717 	ldw	r2,28(r2)
 824a20c:	10c00044 	addi	r3,r2,1
 824a210:	008209b4 	movhi	r2,2086
 824a214:	10b91604 	addi	r2,r2,-7080
 824a218:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a21c:	d0a08317 	ldw	r2,-32244(gp)
 824a220:	1081000c 	andi	r2,r2,1024
 824a224:	10001426 	beq	r2,zero,824a278 <icmprcv+0x31c>
 824a228:	d0a08317 	ldw	r2,-32244(gp)
 824a22c:	1080800c 	andi	r2,r2,512
 824a230:	10001126 	beq	r2,zero,824a278 <icmprcv+0x31c>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a234:	e0bff617 	ldw	r2,-40(fp)
 824a238:	10c03fcc 	andi	r3,r2,255
 824a23c:	e0bff617 	ldw	r2,-40(fp)
 824a240:	1004d23a 	srli	r2,r2,8
 824a244:	11003fcc 	andi	r4,r2,255
 824a248:	e0bff617 	ldw	r2,-40(fp)
 824a24c:	1004d43a 	srli	r2,r2,16
 824a250:	11403fcc 	andi	r5,r2,255
 824a254:	e0bff617 	ldw	r2,-40(fp)
 824a258:	1004d63a 	srli	r2,r2,24
 824a25c:	d8800015 	stw	r2,0(sp)
 824a260:	280f883a 	mov	r7,r5
 824a264:	200d883a 	mov	r6,r4
 824a268:	180b883a 	mov	r5,r3
 824a26c:	01020974 	movhi	r4,2085
 824a270:	21059604 	addi	r4,r4,5720
 824a274:	8202e9c0 	call	8202e9c <printf>
#endif
      e->ptype = ECHOREP;
 824a278:	e0bff717 	ldw	r2,-36(fp)
 824a27c:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 824a280:	e0bff717 	ldw	r2,-36(fp)
 824a284:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 824a288:	e0bff517 	ldw	r2,-44(fp)
 824a28c:	1080004c 	andi	r2,r2,1
 824a290:	10000926 	beq	r2,zero,824a2b8 <icmprcv+0x35c>
      {
         sav_ch = *(((char *) e) + len);
 824a294:	e0fff717 	ldw	r3,-36(fp)
 824a298:	e0bff517 	ldw	r2,-44(fp)
 824a29c:	1885883a 	add	r2,r3,r2
 824a2a0:	10800003 	ldbu	r2,0(r2)
 824a2a4:	e0bff305 	stb	r2,-52(fp)
         ((char *)e)[len] = 0;
 824a2a8:	e0fff717 	ldw	r3,-36(fp)
 824a2ac:	e0bff517 	ldw	r2,-44(fp)
 824a2b0:	1885883a 	add	r2,r3,r2
 824a2b4:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 824a2b8:	e0bff517 	ldw	r2,-44(fp)
 824a2bc:	10800044 	addi	r2,r2,1
 824a2c0:	1004d07a 	srli	r2,r2,1
 824a2c4:	100b883a 	mov	r5,r2
 824a2c8:	e13ff717 	ldw	r4,-36(fp)
 824a2cc:	82283e80 	call	82283e8 <cksum>
 824a2d0:	0084303a 	nor	r2,zero,r2
 824a2d4:	1007883a 	mov	r3,r2
 824a2d8:	e0bff717 	ldw	r2,-36(fp)
 824a2dc:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 824a2e0:	e0bff517 	ldw	r2,-44(fp)
 824a2e4:	1080004c 	andi	r2,r2,1
 824a2e8:	10000526 	beq	r2,zero,824a300 <icmprcv+0x3a4>
 824a2ec:	e0fff717 	ldw	r3,-36(fp)
 824a2f0:	e0bff517 	ldw	r2,-44(fp)
 824a2f4:	1885883a 	add	r2,r3,r2
 824a2f8:	e0fff303 	ldbu	r3,-52(fp)
 824a2fc:	10c00005 	stb	r3,0(r2)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a300:	e0bff417 	ldw	r2,-48(fp)
 824a304:	10800417 	ldw	r2,16(r2)
 824a308:	10bfffe0 	cmpeqi	r2,r2,-1
 824a30c:	10001f1e 	bne	r2,zero,824a38c <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a310:	e0bff417 	ldw	r2,-48(fp)
 824a314:	10800417 	ldw	r2,16(r2)
 824a318:	1006d63a 	srli	r3,r2,24
 824a31c:	e0bff417 	ldw	r2,-48(fp)
 824a320:	10800417 	ldw	r2,16(r2)
 824a324:	1004d23a 	srli	r2,r2,8
 824a328:	10bfc00c 	andi	r2,r2,65280
 824a32c:	1886b03a 	or	r3,r3,r2
 824a330:	e0bff417 	ldw	r2,-48(fp)
 824a334:	10800417 	ldw	r2,16(r2)
 824a338:	10bfc00c 	andi	r2,r2,65280
 824a33c:	1004923a 	slli	r2,r2,8
 824a340:	1886b03a 	or	r3,r3,r2
 824a344:	e0bff417 	ldw	r2,-48(fp)
 824a348:	10800417 	ldw	r2,16(r2)
 824a34c:	1004963a 	slli	r2,r2,24
 824a350:	1884b03a 	or	r2,r3,r2
 824a354:	10fc002c 	andhi	r3,r2,61440
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a358:	00b80034 	movhi	r2,57344
 824a35c:	18800b26 	beq	r3,r2,824a38c <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
 824a360:	e0bff417 	ldw	r2,-48(fp)
 824a364:	10c00417 	ldw	r3,16(r2)
 824a368:	e0bffd17 	ldw	r2,-12(fp)
 824a36c:	10800617 	ldw	r2,24(r2)
 824a370:	11000a17 	ldw	r4,40(r2)
 824a374:	e0bffd17 	ldw	r2,-12(fp)
 824a378:	10800617 	ldw	r2,24(r2)
 824a37c:	10800c17 	ldw	r2,48(r2)
 824a380:	0084303a 	nor	r2,zero,r2
 824a384:	2084b03a 	or	r2,r4,r2
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a388:	1880061e 	bne	r3,r2,824a3a4 <icmprcv+0x448>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 824a38c:	e0bffd17 	ldw	r2,-12(fp)
 824a390:	10800617 	ldw	r2,24(r2)
 824a394:	10c00a17 	ldw	r3,40(r2)
 824a398:	e0bff417 	ldw	r2,-48(fp)
 824a39c:	10c00315 	stw	r3,12(r2)
 824a3a0:	00000406 	br	824a3b4 <icmprcv+0x458>
      }
      else pip->ip_src = pip->ip_dest;
 824a3a4:	e0bff417 	ldw	r2,-48(fp)
 824a3a8:	10c00417 	ldw	r3,16(r2)
 824a3ac:	e0bff417 	ldw	r2,-48(fp)
 824a3b0:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 824a3b4:	e0bff417 	ldw	r2,-48(fp)
 824a3b8:	e0fff617 	ldw	r3,-40(fp)
 824a3bc:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutEchoReps++;
 824a3c0:	008209b4 	movhi	r2,2086
 824a3c4:	10b91604 	addi	r2,r2,-7080
 824a3c8:	10801517 	ldw	r2,84(r2)
 824a3cc:	10c00044 	addi	r3,r2,1
 824a3d0:	008209b4 	movhi	r2,2086
 824a3d4:	10b91604 	addi	r2,r2,-7080
 824a3d8:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 824a3dc:	008209b4 	movhi	r2,2086
 824a3e0:	10b91604 	addi	r2,r2,-7080
 824a3e4:	10800d17 	ldw	r2,52(r2)
 824a3e8:	10c00044 	addi	r3,r2,1
 824a3ec:	008209b4 	movhi	r2,2086
 824a3f0:	10b91604 	addi	r2,r2,-7080
 824a3f4:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 824a3f8:	e0bffd17 	ldw	r2,-12(fp)
 824a3fc:	e0fff617 	ldw	r3,-40(fp)
 824a400:	10c00715 	stw	r3,28(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824a404:	e0bffd17 	ldw	r2,-12(fp)
 824a408:	10c00317 	ldw	r3,12(r2)
 824a40c:	e0bff417 	ldw	r2,-48(fp)
 824a410:	10800003 	ldbu	r2,0(r2)
 824a414:	10803fcc 	andi	r2,r2,255
 824a418:	108003cc 	andi	r2,r2,15
 824a41c:	1085883a 	add	r2,r2,r2
 824a420:	1085883a 	add	r2,r2,r2
 824a424:	1887883a 	add	r3,r3,r2
 824a428:	e0bffd17 	ldw	r2,-12(fp)
 824a42c:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 824a430:	e0bffd17 	ldw	r2,-12(fp)
 824a434:	e0fff517 	ldw	r3,-44(fp)
 824a438:	10c00415 	stw	r3,16(r2)

      i = ip_write(ICMP_PROT, p);
 824a43c:	e17ffd17 	ldw	r5,-12(fp)
 824a440:	01000044 	movi	r4,1
 824a444:	823f5a00 	call	823f5a0 <ip_write>
 824a448:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824a44c:	e0bff917 	ldw	r2,-28(fp)
 824a450:	1000060e 	bge	r2,zero,824a46c <icmprcv+0x510>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 824a454:	d0a08317 	ldw	r2,-32244(gp)
 824a458:	1081000c 	andi	r2,r2,1024
 824a45c:	10000326 	beq	r2,zero,824a46c <icmprcv+0x510>
            dprintf("icmp: reply failed\n");
 824a460:	01020974 	movhi	r4,2085
 824a464:	21059f04 	addi	r4,r4,5756
 824a468:	82031200 	call	8203120 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 824a46c:	0005883a 	mov	r2,zero
 824a470:	00018c06 	br	824aaa4 <icmprcv+0xb48>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 824a474:	008209b4 	movhi	r2,2086
 824a478:	10b91604 	addi	r2,r2,-7080
 824a47c:	10800817 	ldw	r2,32(r2)
 824a480:	10c00044 	addi	r3,r2,1
 824a484:	008209b4 	movhi	r2,2086
 824a488:	10b91604 	addi	r2,r2,-7080
 824a48c:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 824a490:	e13ffd17 	ldw	r4,-12(fp)
 824a494:	8243ac80 	call	8243ac8 <ip_raw_input>
 824a498:	00018206 	br	824aaa4 <icmprcv+0xb48>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 824a49c:	008209b4 	movhi	r2,2086
 824a4a0:	10b91604 	addi	r2,r2,-7080
 824a4a4:	10800217 	ldw	r2,8(r2)
 824a4a8:	10c00044 	addi	r3,r2,1
 824a4ac:	008209b4 	movhi	r2,2086
 824a4b0:	10b91604 	addi	r2,r2,-7080
 824a4b4:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 824a4b8:	e0bff717 	ldw	r2,-36(fp)
 824a4bc:	e0bffa15 	stw	r2,-24(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a4c0:	d0a08317 	ldw	r2,-32244(gp)
 824a4c4:	1081000c 	andi	r2,r2,1024
 824a4c8:	10002f26 	beq	r2,zero,824a588 <icmprcv+0x62c>
      {
         dprintf("ICMP: got dest unreachable type ");
 824a4cc:	01020974 	movhi	r4,2085
 824a4d0:	2105a404 	addi	r4,r4,5776
 824a4d4:	8202e9c0 	call	8202e9c <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a4d8:	e0bffa17 	ldw	r2,-24(fp)
 824a4dc:	10800043 	ldbu	r2,1(r2)
 824a4e0:	11003fcc 	andi	r4,r2,255
 824a4e4:	2100201c 	xori	r4,r4,128
 824a4e8:	213fe004 	addi	r4,r4,-128
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a4ec:	e0bffa17 	ldw	r2,-24(fp)
 824a4f0:	10800617 	ldw	r2,24(r2)
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a4f4:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a4f8:	e0bffa17 	ldw	r2,-24(fp)
 824a4fc:	10800617 	ldw	r2,24(r2)
 824a500:	1004d23a 	srli	r2,r2,8
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a504:	11803fcc 	andi	r6,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a508:	e0bffa17 	ldw	r2,-24(fp)
 824a50c:	10800617 	ldw	r2,24(r2)
 824a510:	1004d43a 	srli	r2,r2,16
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a514:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a518:	e0fffa17 	ldw	r3,-24(fp)
 824a51c:	18c00617 	ldw	r3,24(r3)
 824a520:	1806d63a 	srli	r3,r3,24
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a524:	d8c00115 	stw	r3,4(sp)
 824a528:	d8800015 	stw	r2,0(sp)
 824a52c:	300f883a 	mov	r7,r6
 824a530:	280d883a 	mov	r6,r5
 824a534:	200b883a 	mov	r5,r4
 824a538:	01020974 	movhi	r4,2085
 824a53c:	2105ad04 	addi	r4,r4,5812
 824a540:	8202e9c0 	call	8202e9c <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a544:	e0bff617 	ldw	r2,-40(fp)
 824a548:	10c03fcc 	andi	r3,r2,255
 824a54c:	e0bff617 	ldw	r2,-40(fp)
 824a550:	1004d23a 	srli	r2,r2,8
 824a554:	11003fcc 	andi	r4,r2,255
 824a558:	e0bff617 	ldw	r2,-40(fp)
 824a55c:	1004d43a 	srli	r2,r2,16
 824a560:	11403fcc 	andi	r5,r2,255
 824a564:	e0bff617 	ldw	r2,-40(fp)
 824a568:	1004d63a 	srli	r2,r2,24
 824a56c:	d8800015 	stw	r2,0(sp)
 824a570:	280f883a 	mov	r7,r5
 824a574:	200d883a 	mov	r6,r4
 824a578:	180b883a 	mov	r5,r3
 824a57c:	01020974 	movhi	r4,2085
 824a580:	2105b204 	addi	r4,r4,5832
 824a584:	8202e9c0 	call	8202e9c <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 824a588:	e17ffa17 	ldw	r5,-24(fp)
 824a58c:	e13ffd17 	ldw	r4,-12(fp)
 824a590:	824b0d40 	call	824b0d4 <icmp_du>
      break;
 824a594:	00014206 	br	824aaa0 <icmprcv+0xb44>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 824a598:	008209b4 	movhi	r2,2086
 824a59c:	10b91604 	addi	r2,r2,-7080
 824a5a0:	10800517 	ldw	r2,20(r2)
 824a5a4:	10c00044 	addi	r3,r2,1
 824a5a8:	008209b4 	movhi	r2,2086
 824a5ac:	10b91604 	addi	r2,r2,-7080
 824a5b0:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a5b4:	d0a08317 	ldw	r2,-32244(gp)
 824a5b8:	1081000c 	andi	r2,r2,1024
 824a5bc:	10001626 	beq	r2,zero,824a618 <icmprcv+0x6bc>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a5c0:	e0bff617 	ldw	r2,-40(fp)
 824a5c4:	10c03fcc 	andi	r3,r2,255
 824a5c8:	e0bff617 	ldw	r2,-40(fp)
 824a5cc:	1004d23a 	srli	r2,r2,8
 824a5d0:	11003fcc 	andi	r4,r2,255
 824a5d4:	e0bff617 	ldw	r2,-40(fp)
 824a5d8:	1004d43a 	srli	r2,r2,16
 824a5dc:	11403fcc 	andi	r5,r2,255
 824a5e0:	e0bff617 	ldw	r2,-40(fp)
 824a5e4:	1004d63a 	srli	r2,r2,24
 824a5e8:	d8800015 	stw	r2,0(sp)
 824a5ec:	280f883a 	mov	r7,r5
 824a5f0:	200d883a 	mov	r6,r4
 824a5f4:	180b883a 	mov	r5,r3
 824a5f8:	01020974 	movhi	r4,2085
 824a5fc:	2105b704 	addi	r4,r4,5852
 824a600:	8202e9c0 	call	8202e9c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824a604:	d0a08317 	ldw	r2,-32244(gp)
 824a608:	1080008c 	andi	r2,r2,2
 824a60c:	10000226 	beq	r2,zero,824a618 <icmprcv+0x6bc>
 824a610:	e13ffd17 	ldw	r4,-12(fp)
 824a614:	82406940 	call	8240694 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a618:	01000084 	movi	r4,2
 824a61c:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a620:	e13ffd17 	ldw	r4,-12(fp)
 824a624:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a628:	01000084 	movi	r4,2
 824a62c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      break;
 824a630:	00011b06 	br	824aaa0 <icmprcv+0xb44>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 824a634:	008209b4 	movhi	r2,2086
 824a638:	10b91604 	addi	r2,r2,-7080
 824a63c:	10800617 	ldw	r2,24(r2)
 824a640:	10c00044 	addi	r3,r2,1
 824a644:	008209b4 	movhi	r2,2086
 824a648:	10b91604 	addi	r2,r2,-7080
 824a64c:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 824a650:	e0bff717 	ldw	r2,-36(fp)
 824a654:	e0bffb15 	stw	r2,-20(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a658:	d0a08317 	ldw	r2,-32244(gp)
 824a65c:	1081000c 	andi	r2,r2,1024
 824a660:	10002a26 	beq	r2,zero,824a70c <icmprcv+0x7b0>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a664:	e0bffb17 	ldw	r2,-20(fp)
 824a668:	10800617 	ldw	r2,24(r2)
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a66c:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a670:	e0bffb17 	ldw	r2,-20(fp)
 824a674:	10800617 	ldw	r2,24(r2)
 824a678:	1004d23a 	srli	r2,r2,8
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a67c:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a680:	e0bffb17 	ldw	r2,-20(fp)
 824a684:	10800617 	ldw	r2,24(r2)
 824a688:	1004d43a 	srli	r2,r2,16
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a68c:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a690:	e0bffb17 	ldw	r2,-20(fp)
 824a694:	10800617 	ldw	r2,24(r2)
 824a698:	1004d63a 	srli	r2,r2,24
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a69c:	d8800015 	stw	r2,0(sp)
 824a6a0:	280f883a 	mov	r7,r5
 824a6a4:	200d883a 	mov	r6,r4
 824a6a8:	180b883a 	mov	r5,r3
 824a6ac:	01020974 	movhi	r4,2085
 824a6b0:	2105c104 	addi	r4,r4,5892
 824a6b4:	8202e9c0 	call	8202e9c <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 824a6b8:	e0bffb17 	ldw	r2,-20(fp)
 824a6bc:	10800117 	ldw	r2,4(r2)
 824a6c0:	10c03fcc 	andi	r3,r2,255
 824a6c4:	e0bffb17 	ldw	r2,-20(fp)
 824a6c8:	10800117 	ldw	r2,4(r2)
 824a6cc:	1004d23a 	srli	r2,r2,8
 824a6d0:	11003fcc 	andi	r4,r2,255
 824a6d4:	e0bffb17 	ldw	r2,-20(fp)
 824a6d8:	10800117 	ldw	r2,4(r2)
 824a6dc:	1004d43a 	srli	r2,r2,16
 824a6e0:	11403fcc 	andi	r5,r2,255
 824a6e4:	e0bffb17 	ldw	r2,-20(fp)
 824a6e8:	10800117 	ldw	r2,4(r2)
 824a6ec:	1004d63a 	srli	r2,r2,24
 824a6f0:	d8800015 	stw	r2,0(sp)
 824a6f4:	280f883a 	mov	r7,r5
 824a6f8:	200d883a 	mov	r6,r4
 824a6fc:	180b883a 	mov	r5,r3
 824a700:	01020974 	movhi	r4,2085
 824a704:	2105cb04 	addi	r4,r4,5932
 824a708:	8202e9c0 	call	8202e9c <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 824a70c:	e0bffb17 	ldw	r2,-20(fp)
 824a710:	14000617 	ldw	r16,24(r2)
 824a714:	e0bffb17 	ldw	r2,-20(fp)
 824a718:	14400117 	ldw	r17,4(r2)
 824a71c:	e0bffd17 	ldw	r2,-12(fp)
 824a720:	10800617 	ldw	r2,24(r2)
 824a724:	1009883a 	mov	r4,r2
 824a728:	822689c0 	call	822689c <if_netnumber>
 824a72c:	1007883a 	mov	r3,r2
 824a730:	00800104 	movi	r2,4
 824a734:	d8800015 	stw	r2,0(sp)
 824a738:	180f883a 	mov	r7,r3
 824a73c:	880d883a 	mov	r6,r17
 824a740:	017fffc4 	movi	r5,-1
 824a744:	8009883a 	mov	r4,r16
 824a748:	8243f840 	call	8243f84 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a74c:	01000084 	movi	r4,2
 824a750:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a754:	e13ffd17 	ldw	r4,-12(fp)
 824a758:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a75c:	01000084 	movi	r4,2
 824a760:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      break;
 824a764:	0000ce06 	br	824aaa0 <icmprcv+0xb44>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 824a768:	008209b4 	movhi	r2,2086
 824a76c:	10b91604 	addi	r2,r2,-7080
 824a770:	10800317 	ldw	r2,12(r2)
 824a774:	10c00044 	addi	r3,r2,1
 824a778:	008209b4 	movhi	r2,2086
 824a77c:	10b91604 	addi	r2,r2,-7080
 824a780:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a784:	d0a08317 	ldw	r2,-32244(gp)
 824a788:	1081000c 	andi	r2,r2,1024
 824a78c:	10003126 	beq	r2,zero,824a854 <icmprcv+0x8f8>
      {
         struct timex * pt =  (struct  timex *)e;
 824a790:	e0bff717 	ldw	r2,-36(fp)
 824a794:	e0bffc15 	stw	r2,-16(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
          PUSH_IPADDR(p->fhost));
 824a798:	e0bffd17 	ldw	r2,-12(fp)
 824a79c:	10800717 	ldw	r2,28(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824a7a0:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(p->fhost));
 824a7a4:	e0bffd17 	ldw	r2,-12(fp)
 824a7a8:	10800717 	ldw	r2,28(r2)
 824a7ac:	1004d23a 	srli	r2,r2,8
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824a7b0:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(p->fhost));
 824a7b4:	e0bffd17 	ldw	r2,-12(fp)
 824a7b8:	10800717 	ldw	r2,28(r2)
 824a7bc:	1004d43a 	srli	r2,r2,16
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824a7c0:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(p->fhost));
 824a7c4:	e0bffd17 	ldw	r2,-12(fp)
 824a7c8:	10800717 	ldw	r2,28(r2)
 824a7cc:	1004d63a 	srli	r2,r2,24
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824a7d0:	d8800015 	stw	r2,0(sp)
 824a7d4:	280f883a 	mov	r7,r5
 824a7d8:	200d883a 	mov	r6,r4
 824a7dc:	180b883a 	mov	r5,r3
 824a7e0:	01020974 	movhi	r4,2085
 824a7e4:	2105cf04 	addi	r4,r4,5948
 824a7e8:	8202e9c0 	call	8202e9c <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 824a7ec:	e0bffc17 	ldw	r2,-16(fp)
 824a7f0:	10800617 	ldw	r2,24(r2)
 824a7f4:	10c03fcc 	andi	r3,r2,255
 824a7f8:	e0bffc17 	ldw	r2,-16(fp)
 824a7fc:	10800617 	ldw	r2,24(r2)
 824a800:	1004d23a 	srli	r2,r2,8
 824a804:	11003fcc 	andi	r4,r2,255
 824a808:	e0bffc17 	ldw	r2,-16(fp)
 824a80c:	10800617 	ldw	r2,24(r2)
 824a810:	1004d43a 	srli	r2,r2,16
 824a814:	11403fcc 	andi	r5,r2,255
 824a818:	e0bffc17 	ldw	r2,-16(fp)
 824a81c:	10800617 	ldw	r2,24(r2)
 824a820:	1004d63a 	srli	r2,r2,24
 824a824:	d8800015 	stw	r2,0(sp)
 824a828:	280f883a 	mov	r7,r5
 824a82c:	200d883a 	mov	r6,r4
 824a830:	180b883a 	mov	r5,r3
 824a834:	01020974 	movhi	r4,2085
 824a838:	2105d804 	addi	r4,r4,5984
 824a83c:	8202e9c0 	call	8202e9c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824a840:	d0a08317 	ldw	r2,-32244(gp)
 824a844:	1080008c 	andi	r2,r2,2
 824a848:	10000226 	beq	r2,zero,824a854 <icmprcv+0x8f8>
 824a84c:	e13ffd17 	ldw	r4,-12(fp)
 824a850:	82406940 	call	8240694 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a854:	01000084 	movi	r4,2
 824a858:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a85c:	e13ffd17 	ldw	r4,-12(fp)
 824a860:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a864:	01000084 	movi	r4,2
 824a868:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      break;
 824a86c:	00008c06 	br	824aaa0 <icmprcv+0xb44>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 824a870:	008209b4 	movhi	r2,2086
 824a874:	10b91604 	addi	r2,r2,-7080
 824a878:	10800417 	ldw	r2,16(r2)
 824a87c:	10c00044 	addi	r3,r2,1
 824a880:	008209b4 	movhi	r2,2086
 824a884:	10b91604 	addi	r2,r2,-7080
 824a888:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a88c:	d0a08317 	ldw	r2,-32244(gp)
 824a890:	1081000c 	andi	r2,r2,1024
 824a894:	10000326 	beq	r2,zero,824a8a4 <icmprcv+0x948>
         dprintf("ICMP: got param problem message\n");
 824a898:	01020974 	movhi	r4,2085
 824a89c:	2105dd04 	addi	r4,r4,6004
 824a8a0:	82031200 	call	8203120 <puts>
      if (NDEBUG & DUMP)
 824a8a4:	d0a08317 	ldw	r2,-32244(gp)
 824a8a8:	1080008c 	andi	r2,r2,2
 824a8ac:	10000226 	beq	r2,zero,824a8b8 <icmprcv+0x95c>
      {
         ip_dump(p);
 824a8b0:	e13ffd17 	ldw	r4,-12(fp)
 824a8b4:	82406940 	call	8240694 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a8b8:	01000084 	movi	r4,2
 824a8bc:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a8c0:	e13ffd17 	ldw	r4,-12(fp)
 824a8c4:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a8c8:	01000084 	movi	r4,2
 824a8cc:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      break;
 824a8d0:	00007306 	br	824aaa0 <icmprcv+0xb44>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 824a8d4:	008209b4 	movhi	r2,2086
 824a8d8:	10b91604 	addi	r2,r2,-7080
 824a8dc:	10800917 	ldw	r2,36(r2)
 824a8e0:	10c00044 	addi	r3,r2,1
 824a8e4:	008209b4 	movhi	r2,2086
 824a8e8:	10b91604 	addi	r2,r2,-7080
 824a8ec:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a8f0:	d0a08317 	ldw	r2,-32244(gp)
 824a8f4:	1081000c 	andi	r2,r2,1024
 824a8f8:	10000326 	beq	r2,zero,824a908 <icmprcv+0x9ac>
         dprintf("ICMP: got timestamp request\n");
 824a8fc:	01020974 	movhi	r4,2085
 824a900:	2105e504 	addi	r4,r4,6036
 824a904:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 824a908:	e0bff717 	ldw	r2,-36(fp)
 824a90c:	00c00384 	movi	r3,14
 824a910:	10c00005 	stb	r3,0(r2)
      e->pchksum = 0;
 824a914:	e0bff717 	ldw	r2,-36(fp)
 824a918:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 824a91c:	01400284 	movi	r5,10
 824a920:	e13ff717 	ldw	r4,-36(fp)
 824a924:	82283e80 	call	82283e8 <cksum>
 824a928:	0084303a 	nor	r2,zero,r2
 824a92c:	1007883a 	mov	r3,r2
 824a930:	e0bff717 	ldw	r2,-36(fp)
 824a934:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 824a938:	e0bff417 	ldw	r2,-48(fp)
 824a93c:	10c00417 	ldw	r3,16(r2)
 824a940:	e0bff417 	ldw	r2,-48(fp)
 824a944:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 824a948:	e0bff417 	ldw	r2,-48(fp)
 824a94c:	e0fff617 	ldw	r3,-40(fp)
 824a950:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutMsgs++;
 824a954:	008209b4 	movhi	r2,2086
 824a958:	10b91604 	addi	r2,r2,-7080
 824a95c:	10800d17 	ldw	r2,52(r2)
 824a960:	10c00044 	addi	r3,r2,1
 824a964:	008209b4 	movhi	r2,2086
 824a968:	10b91604 	addi	r2,r2,-7080
 824a96c:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 824a970:	008209b4 	movhi	r2,2086
 824a974:	10b91604 	addi	r2,r2,-7080
 824a978:	10801717 	ldw	r2,92(r2)
 824a97c:	10c00044 	addi	r3,r2,1
 824a980:	008209b4 	movhi	r2,2086
 824a984:	10b91604 	addi	r2,r2,-7080
 824a988:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824a98c:	e0bffd17 	ldw	r2,-12(fp)
 824a990:	10c00317 	ldw	r3,12(r2)
 824a994:	e0bff417 	ldw	r2,-48(fp)
 824a998:	10800003 	ldbu	r2,0(r2)
 824a99c:	10803fcc 	andi	r2,r2,255
 824a9a0:	108003cc 	andi	r2,r2,15
 824a9a4:	1085883a 	add	r2,r2,r2
 824a9a8:	1085883a 	add	r2,r2,r2
 824a9ac:	1887883a 	add	r3,r3,r2
 824a9b0:	e0bffd17 	ldw	r2,-12(fp)
 824a9b4:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 824a9b8:	e0bffd17 	ldw	r2,-12(fp)
 824a9bc:	00c00504 	movi	r3,20
 824a9c0:	10c00415 	stw	r3,16(r2)
      p->fhost = host;
 824a9c4:	e0bffd17 	ldw	r2,-12(fp)
 824a9c8:	e0fff617 	ldw	r3,-40(fp)
 824a9cc:	10c00715 	stw	r3,28(r2)
      i = ip_write(ICMP_PROT, p);
 824a9d0:	e17ffd17 	ldw	r5,-12(fp)
 824a9d4:	01000044 	movi	r4,1
 824a9d8:	823f5a00 	call	823f5a0 <ip_write>
 824a9dc:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824a9e0:	e0bff917 	ldw	r2,-28(fp)
 824a9e4:	1000060e 	bge	r2,zero,824aa00 <icmprcv+0xaa4>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 824a9e8:	d0a08317 	ldw	r2,-32244(gp)
 824a9ec:	1081000c 	andi	r2,r2,1024
 824a9f0:	10000326 	beq	r2,zero,824aa00 <icmprcv+0xaa4>
            dprintf("icmp: can't send timestamp reply\n");
 824a9f4:	01020974 	movhi	r4,2085
 824a9f8:	2105ec04 	addi	r4,r4,6064
 824a9fc:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 824aa00:	0005883a 	mov	r2,zero
 824aa04:	00002706 	br	824aaa4 <icmprcv+0xb48>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824aa08:	d0a08317 	ldw	r2,-32244(gp)
 824aa0c:	1081000c 	andi	r2,r2,1024
 824aa10:	10000326 	beq	r2,zero,824aa20 <icmprcv+0xac4>
         dprintf("icmp: got info request\n");
 824aa14:	01020974 	movhi	r4,2085
 824aa18:	2105f504 	addi	r4,r4,6100
 824aa1c:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824aa20:	01000084 	movi	r4,2
 824aa24:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824aa28:	e13ffd17 	ldw	r4,-12(fp)
 824aa2c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aa30:	01000084 	movi	r4,2
 824aa34:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      break;
 824aa38:	00001906 	br	824aaa0 <icmprcv+0xb44>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824aa3c:	d0a08317 	ldw	r2,-32244(gp)
 824aa40:	1081000c 	andi	r2,r2,1024
 824aa44:	10000e26 	beq	r2,zero,824aa80 <icmprcv+0xb24>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 824aa48:	e0bff717 	ldw	r2,-36(fp)
 824aa4c:	10800003 	ldbu	r2,0(r2)
 824aa50:	10803fcc 	andi	r2,r2,255
 824aa54:	1080201c 	xori	r2,r2,128
 824aa58:	10bfe004 	addi	r2,r2,-128
 824aa5c:	100b883a 	mov	r5,r2
 824aa60:	01020974 	movhi	r4,2085
 824aa64:	2105fb04 	addi	r4,r4,6124
 824aa68:	8202e9c0 	call	8202e9c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824aa6c:	d0a08317 	ldw	r2,-32244(gp)
 824aa70:	1080008c 	andi	r2,r2,2
 824aa74:	10000226 	beq	r2,zero,824aa80 <icmprcv+0xb24>
 824aa78:	e13ffd17 	ldw	r4,-12(fp)
 824aa7c:	82406940 	call	8240694 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824aa80:	01000084 	movi	r4,2
 824aa84:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
      pk_free(p);
 824aa88:	e13ffd17 	ldw	r4,-12(fp)
 824aa8c:	822c9700 	call	822c970 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aa90:	01000084 	movi	r4,2
 824aa94:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 824aa98:	00800084 	movi	r2,2
 824aa9c:	00000106 	br	824aaa4 <icmprcv+0xb48>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 824aaa0:	00800084 	movi	r2,2
#endif   /* FULL_ICMP */
}
 824aaa4:	e6fffe04 	addi	sp,fp,-8
 824aaa8:	dfc00317 	ldw	ra,12(sp)
 824aaac:	df000217 	ldw	fp,8(sp)
 824aab0:	dc400117 	ldw	r17,4(sp)
 824aab4:	dc000017 	ldw	r16,0(sp)
 824aab8:	dec00404 	addi	sp,sp,16
 824aabc:	f800283a 	ret

0824aac0 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 824aac0:	defff404 	addi	sp,sp,-48
 824aac4:	dfc00b15 	stw	ra,44(sp)
 824aac8:	df000a15 	stw	fp,40(sp)
 824aacc:	df000a04 	addi	fp,sp,40
 824aad0:	e13ffc15 	stw	r4,-16(fp)
 824aad4:	e17ffd15 	stw	r5,-12(fp)
 824aad8:	e1bffe15 	stw	r6,-8(fp)
 824aadc:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824aae0:	d0a08317 	ldw	r2,-32244(gp)
 824aae4:	1080040c 	andi	r2,r2,16
 824aae8:	10001a26 	beq	r2,zero,824ab54 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824aaec:	e0bfff17 	ldw	r2,-4(fp)
 824aaf0:	10c03fcc 	andi	r3,r2,255
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824aaf4:	00820974 	movhi	r2,2085
 824aaf8:	108e2804 	addi	r2,r2,14496
 824aafc:	18c7883a 	add	r3,r3,r3
 824ab00:	18c7883a 	add	r3,r3,r3
 824ab04:	10c5883a 	add	r2,r2,r3
 824ab08:	11000017 	ldw	r4,0(r2)
 824ab0c:	e0bffc17 	ldw	r2,-16(fp)
 824ab10:	11403fcc 	andi	r5,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ab14:	e0bffc17 	ldw	r2,-16(fp)
 824ab18:	1004d23a 	srli	r2,r2,8
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ab1c:	11803fcc 	andi	r6,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ab20:	e0bffc17 	ldw	r2,-16(fp)
 824ab24:	1004d43a 	srli	r2,r2,16
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ab28:	10803fcc 	andi	r2,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ab2c:	e0fffc17 	ldw	r3,-16(fp)
 824ab30:	1806d63a 	srli	r3,r3,24
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ab34:	d8c00115 	stw	r3,4(sp)
 824ab38:	d8800015 	stw	r2,0(sp)
 824ab3c:	300f883a 	mov	r7,r6
 824ab40:	280d883a 	mov	r6,r5
 824ab44:	200b883a 	mov	r5,r4
 824ab48:	01020974 	movhi	r4,2085
 824ab4c:	21061504 	addi	r4,r4,6228
 824ab50:	8202e9c0 	call	8202e9c <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 824ab54:	01000084 	movi	r4,2
 824ab58:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 824ab5c:	01008504 	movi	r4,532
 824ab60:	822c6200 	call	822c620 <pk_alloc>
 824ab64:	e0bff815 	stw	r2,-32(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ab68:	01000084 	movi	r4,2
 824ab6c:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824ab70:	e0bff817 	ldw	r2,-32(fp)
 824ab74:	10000e1e 	bne	r2,zero,824abb0 <icmp_destun+0xf0>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824ab78:	d0a08317 	ldw	r2,-32244(gp)
 824ab7c:	1080800c 	andi	r2,r2,512
 824ab80:	10000326 	beq	r2,zero,824ab90 <icmp_destun+0xd0>
         dprintf("icmp: can't alloc pkt\n");
 824ab84:	01020974 	movhi	r4,2085
 824ab88:	21062204 	addi	r4,r4,6280
 824ab8c:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824ab90:	008209b4 	movhi	r2,2086
 824ab94:	10b91604 	addi	r2,r2,-7080
 824ab98:	10800e17 	ldw	r2,56(r2)
 824ab9c:	10c00044 	addi	r3,r2,1
 824aba0:	008209b4 	movhi	r2,2086
 824aba4:	10b91604 	addi	r2,r2,-7080
 824aba8:	10c00e15 	stw	r3,56(r2)
      return;
 824abac:	00007f06 	br	824adac <icmp_destun+0x2ec>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824abb0:	e0bff817 	ldw	r2,-32(fp)
 824abb4:	10800317 	ldw	r2,12(r2)
 824abb8:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 824abbc:	e0bff917 	ldw	r2,-28(fp)
 824abc0:	e0fffd17 	ldw	r3,-12(fp)
 824abc4:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = host;
 824abc8:	e0bff917 	ldw	r2,-28(fp)
 824abcc:	e0fffc17 	ldw	r3,-16(fp)
 824abd0:	10c00415 	stw	r3,16(r2)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 824abd4:	e0bff817 	ldw	r2,-32(fp)
 824abd8:	10800317 	ldw	r2,12(r2)
 824abdc:	10c00504 	addi	r3,r2,20
 824abe0:	e0bff817 	ldw	r2,-32(fp)
 824abe4:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 824abe8:	e0bff817 	ldw	r2,-32(fp)
 824abec:	10800417 	ldw	r2,16(r2)
 824abf0:	10fffb04 	addi	r3,r2,-20
 824abf4:	e0bff817 	ldw	r2,-32(fp)
 824abf8:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 824abfc:	e0bff817 	ldw	r2,-32(fp)
 824ac00:	e0c00217 	ldw	r3,8(fp)
 824ac04:	10c00615 	stw	r3,24(r2)

   d = (struct destun *)p->nb_prot;
 824ac08:	e0bff817 	ldw	r2,-32(fp)
 824ac0c:	10800317 	ldw	r2,12(r2)
 824ac10:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 824ac14:	e0bfff17 	ldw	r2,-4(fp)
 824ac18:	10bfc00c 	andi	r2,r2,65280
 824ac1c:	10000626 	beq	r2,zero,824ac38 <icmp_destun+0x178>
      d->dtype = (char)(typecode >>8);  /* then use it */
 824ac20:	e0bfff17 	ldw	r2,-4(fp)
 824ac24:	1004d23a 	srli	r2,r2,8
 824ac28:	1007883a 	mov	r3,r2
 824ac2c:	e0bffa17 	ldw	r2,-24(fp)
 824ac30:	10c00005 	stb	r3,0(r2)
 824ac34:	00000306 	br	824ac44 <icmp_destun+0x184>
   else                                 /* else use default */
      d->dtype = DESTIN;
 824ac38:	e0bffa17 	ldw	r2,-24(fp)
 824ac3c:	00c000c4 	movi	r3,3
 824ac40:	10c00005 	stb	r3,0(r2)
   d->dcode = (char)(typecode & 0xFF);
 824ac44:	e0bfff17 	ldw	r2,-4(fp)
 824ac48:	1007883a 	mov	r3,r2
 824ac4c:	e0bffa17 	ldw	r2,-24(fp)
 824ac50:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 824ac54:	e0bffa17 	ldw	r2,-24(fp)
 824ac58:	1000018d 	sth	zero,6(r2)
 824ac5c:	e0bffa17 	ldw	r2,-24(fp)
 824ac60:	10c0018b 	ldhu	r3,6(r2)
 824ac64:	e0bffa17 	ldw	r2,-24(fp)
 824ac68:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 824ac6c:	e0bfff17 	ldw	r2,-4(fp)
 824ac70:	10803fcc 	andi	r2,r2,255
 824ac74:	10800118 	cmpnei	r2,r2,4
 824ac78:	1000121e 	bne	r2,zero,824acc4 <icmp_destun+0x204>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 824ac7c:	e0800217 	ldw	r2,8(fp)
 824ac80:	10c00917 	ldw	r3,36(r2)
 824ac84:	e0800217 	ldw	r2,8(fp)
 824ac88:	10800817 	ldw	r2,32(r2)
 824ac8c:	1885c83a 	sub	r2,r3,r2
 824ac90:	1005d23a 	srai	r2,r2,8
 824ac94:	10803fcc 	andi	r2,r2,255
 824ac98:	1009883a 	mov	r4,r2
 824ac9c:	e0800217 	ldw	r2,8(fp)
 824aca0:	10c00917 	ldw	r3,36(r2)
 824aca4:	e0800217 	ldw	r2,8(fp)
 824aca8:	10800817 	ldw	r2,32(r2)
 824acac:	1885c83a 	sub	r2,r3,r2
 824acb0:	1004923a 	slli	r2,r2,8
 824acb4:	2084b03a 	or	r2,r4,r2
 824acb8:	1007883a 	mov	r3,r2
 824acbc:	e0bffa17 	ldw	r2,-24(fp)
 824acc0:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 824acc4:	e0bffa17 	ldw	r2,-24(fp)
 824acc8:	10800204 	addi	r2,r2,8
 824accc:	01800704 	movi	r6,28
 824acd0:	e17ffe17 	ldw	r5,-8(fp)
 824acd4:	1009883a 	mov	r4,r2
 824acd8:	8202a0c0 	call	8202a0c <memcpy>

   d->dchksum = 0;
 824acdc:	e0bffa17 	ldw	r2,-24(fp)
 824ace0:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 824ace4:	01400484 	movi	r5,18
 824ace8:	e13ffa17 	ldw	r4,-24(fp)
 824acec:	82283e80 	call	82283e8 <cksum>
 824acf0:	0084303a 	nor	r2,zero,r2
 824acf4:	1007883a 	mov	r3,r2
 824acf8:	e0bffa17 	ldw	r2,-24(fp)
 824acfc:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 824ad00:	e0bff817 	ldw	r2,-32(fp)
 824ad04:	00c00904 	movi	r3,36
 824ad08:	10c00415 	stw	r3,16(r2)
   p->fhost = host;
 824ad0c:	e0bff817 	ldw	r2,-32(fp)
 824ad10:	e0fffc17 	ldw	r3,-16(fp)
 824ad14:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824ad18:	e17ff817 	ldw	r5,-32(fp)
 824ad1c:	01000044 	movi	r4,1
 824ad20:	823f5a00 	call	823f5a0 <ip_write>
 824ad24:	e0bffb15 	stw	r2,-20(fp)
   if (i < 0)
 824ad28:	e0bffb17 	ldw	r2,-20(fp)
 824ad2c:	10000e0e 	bge	r2,zero,824ad68 <icmp_destun+0x2a8>
   {
      icmp_mib.icmpOutErrors++;
 824ad30:	008209b4 	movhi	r2,2086
 824ad34:	10b91604 	addi	r2,r2,-7080
 824ad38:	10800e17 	ldw	r2,56(r2)
 824ad3c:	10c00044 	addi	r3,r2,1
 824ad40:	008209b4 	movhi	r2,2086
 824ad44:	10b91604 	addi	r2,r2,-7080
 824ad48:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824ad4c:	d0a08317 	ldw	r2,-32244(gp)
 824ad50:	1080860c 	andi	r2,r2,536
 824ad54:	10001426 	beq	r2,zero,824ada8 <icmp_destun+0x2e8>
         dprintf("ICMP: Can't send dest unreachable\n");
 824ad58:	01020974 	movhi	r4,2085
 824ad5c:	21062804 	addi	r4,r4,6304
 824ad60:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG  */
      return;
 824ad64:	00001006 	br	824ada8 <icmp_destun+0x2e8>
   }
   icmp_mib.icmpOutMsgs++;
 824ad68:	008209b4 	movhi	r2,2086
 824ad6c:	10b91604 	addi	r2,r2,-7080
 824ad70:	10800d17 	ldw	r2,52(r2)
 824ad74:	10c00044 	addi	r3,r2,1
 824ad78:	008209b4 	movhi	r2,2086
 824ad7c:	10b91604 	addi	r2,r2,-7080
 824ad80:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 824ad84:	008209b4 	movhi	r2,2086
 824ad88:	10b91604 	addi	r2,r2,-7080
 824ad8c:	10800f17 	ldw	r2,60(r2)
 824ad90:	10c00044 	addi	r3,r2,1
 824ad94:	008209b4 	movhi	r2,2086
 824ad98:	10b91604 	addi	r2,r2,-7080
 824ad9c:	10c00f15 	stw	r3,60(r2)
   return;
 824ada0:	0001883a 	nop
 824ada4:	00000106 	br	824adac <icmp_destun+0x2ec>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send dest unreachable\n");
#endif   /* NPDEBUG  */
      return;
 824ada8:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutDestUnreachs++;
   return;
}
 824adac:	e037883a 	mov	sp,fp
 824adb0:	dfc00117 	ldw	ra,4(sp)
 824adb4:	df000017 	ldw	fp,0(sp)
 824adb8:	dec00204 	addi	sp,sp,8
 824adbc:	f800283a 	ret

0824adc0 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 824adc0:	defff504 	addi	sp,sp,-44
 824adc4:	dfc00a15 	stw	ra,40(sp)
 824adc8:	df000915 	stw	fp,36(sp)
 824adcc:	df000904 	addi	fp,sp,36
 824add0:	e13ffe15 	stw	r4,-8(fp)
 824add4:	2805883a 	mov	r2,r5
 824add8:	e0bfff05 	stb	r2,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824addc:	d0a08317 	ldw	r2,-32244(gp)
 824ade0:	1080040c 	andi	r2,r2,16
 824ade4:	10003026 	beq	r2,zero,824aea8 <icmp_timex+0xe8>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824ade8:	e17fff07 	ldb	r5,-4(fp)
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824adec:	e0bffe17 	ldw	r2,-8(fp)
 824adf0:	10800317 	ldw	r2,12(r2)
 824adf4:	1004d23a 	srli	r2,r2,8
 824adf8:	10c03fcc 	andi	r3,r2,255
 824adfc:	e0bffe17 	ldw	r2,-8(fp)
 824ae00:	10800317 	ldw	r2,12(r2)
 824ae04:	1004923a 	slli	r2,r2,8
 824ae08:	10bfffcc 	andi	r2,r2,65535
 824ae0c:	1884b03a 	or	r2,r3,r2
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824ae10:	11803fcc 	andi	r6,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824ae14:	e0bffe17 	ldw	r2,-8(fp)
 824ae18:	10800317 	ldw	r2,12(r2)
 824ae1c:	1004d23a 	srli	r2,r2,8
 824ae20:	10c03fcc 	andi	r3,r2,255
 824ae24:	e0bffe17 	ldw	r2,-8(fp)
 824ae28:	10800317 	ldw	r2,12(r2)
 824ae2c:	1004923a 	slli	r2,r2,8
 824ae30:	10bfffcc 	andi	r2,r2,65535
 824ae34:	1884b03a 	or	r2,r3,r2
 824ae38:	1004d23a 	srli	r2,r2,8
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824ae3c:	11c03fcc 	andi	r7,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824ae40:	e0bffe17 	ldw	r2,-8(fp)
 824ae44:	10800317 	ldw	r2,12(r2)
 824ae48:	1004d23a 	srli	r2,r2,8
 824ae4c:	10c03fcc 	andi	r3,r2,255
 824ae50:	e0bffe17 	ldw	r2,-8(fp)
 824ae54:	10800317 	ldw	r2,12(r2)
 824ae58:	1004923a 	slli	r2,r2,8
 824ae5c:	10bfffcc 	andi	r2,r2,65535
 824ae60:	1884b03a 	or	r2,r3,r2
 824ae64:	1004d43a 	srli	r2,r2,16
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824ae68:	10803fcc 	andi	r2,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824ae6c:	e0fffe17 	ldw	r3,-8(fp)
 824ae70:	18c00317 	ldw	r3,12(r3)
 824ae74:	1806d23a 	srli	r3,r3,8
 824ae78:	19003fcc 	andi	r4,r3,255
 824ae7c:	e0fffe17 	ldw	r3,-8(fp)
 824ae80:	18c00317 	ldw	r3,12(r3)
 824ae84:	1806923a 	slli	r3,r3,8
 824ae88:	18ffffcc 	andi	r3,r3,65535
 824ae8c:	20c6b03a 	or	r3,r4,r3
 824ae90:	1806d63a 	srli	r3,r3,24
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824ae94:	d8c00115 	stw	r3,4(sp)
 824ae98:	d8800015 	stw	r2,0(sp)
 824ae9c:	01020974 	movhi	r4,2085
 824aea0:	21063104 	addi	r4,r4,6340
 824aea4:	8202e9c0 	call	8202e9c <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 824aea8:	e0bffe17 	ldw	r2,-8(fp)
 824aeac:	10800003 	ldbu	r2,0(r2)
 824aeb0:	108003cc 	andi	r2,r2,15
 824aeb4:	1085883a 	add	r2,r2,r2
 824aeb8:	1085883a 	add	r2,r2,r2
 824aebc:	10800404 	addi	r2,r2,16
 824aec0:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824aec4:	01000084 	movi	r4,2
 824aec8:	822d4440 	call	822d444 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 824aecc:	e0bff903 	ldbu	r2,-28(fp)
 824aed0:	d0e08117 	ldw	r3,-32252(gp)
 824aed4:	10c5883a 	add	r2,r2,r3
 824aed8:	10800504 	addi	r2,r2,20
 824aedc:	1009883a 	mov	r4,r2
 824aee0:	822c6200 	call	822c620 <pk_alloc>
 824aee4:	e0bffa15 	stw	r2,-24(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aee8:	01000084 	movi	r4,2
 824aeec:	822d5080 	call	822d508 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824aef0:	e0bffa17 	ldw	r2,-24(fp)
 824aef4:	10000e1e 	bne	r2,zero,824af30 <icmp_timex+0x170>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824aef8:	d0a08317 	ldw	r2,-32244(gp)
 824aefc:	1080800c 	andi	r2,r2,512
 824af00:	10000326 	beq	r2,zero,824af10 <icmp_timex+0x150>
         dprintf("icmp: can't alloc pkt\n");
 824af04:	01020974 	movhi	r4,2085
 824af08:	21062204 	addi	r4,r4,6280
 824af0c:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824af10:	008209b4 	movhi	r2,2086
 824af14:	10b91604 	addi	r2,r2,-7080
 824af18:	10800e17 	ldw	r2,56(r2)
 824af1c:	10c00044 	addi	r3,r2,1
 824af20:	008209b4 	movhi	r2,2086
 824af24:	10b91604 	addi	r2,r2,-7080
 824af28:	10c00e15 	stw	r3,56(r2)
      return;
 824af2c:	00006406 	br	824b0c0 <icmp_timex+0x300>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824af30:	e0bffa17 	ldw	r2,-24(fp)
 824af34:	10800317 	ldw	r2,12(r2)
 824af38:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 824af3c:	e0bffe17 	ldw	r2,-8(fp)
 824af40:	10c00417 	ldw	r3,16(r2)
 824af44:	e0bffb17 	ldw	r2,-20(fp)
 824af48:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 824af4c:	e0bffe17 	ldw	r2,-8(fp)
 824af50:	10c00317 	ldw	r3,12(r2)
 824af54:	e0bffb17 	ldw	r2,-20(fp)
 824af58:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 824af5c:	e0bffa17 	ldw	r2,-24(fp)
 824af60:	10800317 	ldw	r2,12(r2)
 824af64:	10c00504 	addi	r3,r2,20
 824af68:	e0bffa17 	ldw	r2,-24(fp)
 824af6c:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 824af70:	e0bffa17 	ldw	r2,-24(fp)
 824af74:	10800317 	ldw	r2,12(r2)
 824af78:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 824af7c:	e0bffc17 	ldw	r2,-16(fp)
 824af80:	00c002c4 	movi	r3,11
 824af84:	10c00005 	stb	r3,0(r2)
   tx->tcode = code;
 824af88:	e0bffc17 	ldw	r2,-16(fp)
 824af8c:	e0ffff03 	ldbu	r3,-4(fp)
 824af90:	10c00045 	stb	r3,1(r2)
   tx->tno1 = tx->tno2 = 0;
 824af94:	e0bffc17 	ldw	r2,-16(fp)
 824af98:	1000018d 	sth	zero,6(r2)
 824af9c:	e0bffc17 	ldw	r2,-16(fp)
 824afa0:	10c0018b 	ldhu	r3,6(r2)
 824afa4:	e0bffc17 	ldw	r2,-16(fp)
 824afa8:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 824afac:	e0bffc17 	ldw	r2,-16(fp)
 824afb0:	10c00204 	addi	r3,r2,8
 824afb4:	e0bffe17 	ldw	r2,-8(fp)
 824afb8:	10800003 	ldbu	r2,0(r2)
 824afbc:	10803fcc 	andi	r2,r2,255
 824afc0:	108003cc 	andi	r2,r2,15
 824afc4:	1085883a 	add	r2,r2,r2
 824afc8:	1085883a 	add	r2,r2,r2
 824afcc:	10800204 	addi	r2,r2,8
 824afd0:	100d883a 	mov	r6,r2
 824afd4:	e17ffe17 	ldw	r5,-8(fp)
 824afd8:	1809883a 	mov	r4,r3
 824afdc:	8202a0c0 	call	8202a0c <memcpy>

   tx->tchksum = 0;
 824afe0:	e0bffc17 	ldw	r2,-16(fp)
 824afe4:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 824afe8:	e0bff903 	ldbu	r2,-28(fp)
 824afec:	1004d07a 	srli	r2,r2,1
 824aff0:	10803fcc 	andi	r2,r2,255
 824aff4:	100b883a 	mov	r5,r2
 824aff8:	e13ffc17 	ldw	r4,-16(fp)
 824affc:	82283e80 	call	82283e8 <cksum>
 824b000:	0084303a 	nor	r2,zero,r2
 824b004:	1007883a 	mov	r3,r2
 824b008:	e0bffc17 	ldw	r2,-16(fp)
 824b00c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 824b010:	e0fff903 	ldbu	r3,-28(fp)
 824b014:	e0bffa17 	ldw	r2,-24(fp)
 824b018:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 824b01c:	e0bffb17 	ldw	r2,-20(fp)
 824b020:	10c00417 	ldw	r3,16(r2)
 824b024:	e0bffa17 	ldw	r2,-24(fp)
 824b028:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b02c:	e17ffa17 	ldw	r5,-24(fp)
 824b030:	01000044 	movi	r4,1
 824b034:	823f5a00 	call	823f5a0 <ip_write>
 824b038:	e0bffd15 	stw	r2,-12(fp)
   if (i < 0)
 824b03c:	e0bffd17 	ldw	r2,-12(fp)
 824b040:	10000e0e 	bge	r2,zero,824b07c <icmp_timex+0x2bc>
   {
      icmp_mib.icmpOutErrors++;
 824b044:	008209b4 	movhi	r2,2086
 824b048:	10b91604 	addi	r2,r2,-7080
 824b04c:	10800e17 	ldw	r2,56(r2)
 824b050:	10c00044 	addi	r3,r2,1
 824b054:	008209b4 	movhi	r2,2086
 824b058:	10b91604 	addi	r2,r2,-7080
 824b05c:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b060:	d0a08317 	ldw	r2,-32244(gp)
 824b064:	1080860c 	andi	r2,r2,536
 824b068:	10001426 	beq	r2,zero,824b0bc <icmp_timex+0x2fc>
         dprintf("ICMP: Can't send Time Exceeded\n");
 824b06c:	01020974 	movhi	r4,2085
 824b070:	21064104 	addi	r4,r4,6404
 824b074:	82031200 	call	8203120 <puts>
#endif   /* NPDEBUG  */
      return;
 824b078:	00001006 	br	824b0bc <icmp_timex+0x2fc>
   }
   icmp_mib.icmpOutMsgs++;
 824b07c:	008209b4 	movhi	r2,2086
 824b080:	10b91604 	addi	r2,r2,-7080
 824b084:	10800d17 	ldw	r2,52(r2)
 824b088:	10c00044 	addi	r3,r2,1
 824b08c:	008209b4 	movhi	r2,2086
 824b090:	10b91604 	addi	r2,r2,-7080
 824b094:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 824b098:	008209b4 	movhi	r2,2086
 824b09c:	10b91604 	addi	r2,r2,-7080
 824b0a0:	10801017 	ldw	r2,64(r2)
 824b0a4:	10c00044 	addi	r3,r2,1
 824b0a8:	008209b4 	movhi	r2,2086
 824b0ac:	10b91604 	addi	r2,r2,-7080
 824b0b0:	10c01015 	stw	r3,64(r2)
   return;
 824b0b4:	0001883a 	nop
 824b0b8:	00000106 	br	824b0c0 <icmp_timex+0x300>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send Time Exceeded\n");
#endif   /* NPDEBUG  */
      return;
 824b0bc:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutTimeExcds++;
   return;
}
 824b0c0:	e037883a 	mov	sp,fp
 824b0c4:	dfc00117 	ldw	ra,4(sp)
 824b0c8:	df000017 	ldw	fp,0(sp)
 824b0cc:	dec00204 	addi	sp,sp,8
 824b0d0:	f800283a 	ret

0824b0d4 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 824b0d4:	defffc04 	addi	sp,sp,-16
 824b0d8:	dfc00315 	stw	ra,12(sp)
 824b0dc:	df000215 	stw	fp,8(sp)
 824b0e0:	df000204 	addi	fp,sp,8
 824b0e4:	e13ffe15 	stw	r4,-8(fp)
 824b0e8:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 824b0ec:	d0a0dc17 	ldw	r2,-31888(gp)
 824b0f0:	10000426 	beq	r2,zero,824b104 <icmp_du+0x30>
      icmpdu_hook(p, pdp);
 824b0f4:	d0a0dc17 	ldw	r2,-31888(gp)
 824b0f8:	e17fff17 	ldw	r5,-4(fp)
 824b0fc:	e13ffe17 	ldw	r4,-8(fp)
 824b100:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 824b104:	e17fff17 	ldw	r5,-4(fp)
 824b108:	e13ffe17 	ldw	r4,-8(fp)
 824b10c:	822f2e40 	call	822f2e4 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 824b110:	0001883a 	nop
 824b114:	e037883a 	mov	sp,fp
 824b118:	dfc00117 	ldw	ra,4(sp)
 824b11c:	df000017 	ldw	fp,0(sp)
 824b120:	dec00204 	addi	sp,sp,8
 824b124:	f800283a 	ret

0824b128 <atexit>:
 824b128:	200b883a 	mov	r5,r4
 824b12c:	000f883a 	mov	r7,zero
 824b130:	000d883a 	mov	r6,zero
 824b134:	0009883a 	mov	r4,zero
 824b138:	824b6ec1 	jmpi	824b6ec <__register_exitproc>

0824b13c <atoi>:
 824b13c:	01800284 	movi	r6,10
 824b140:	000b883a 	mov	r5,zero
 824b144:	824b6381 	jmpi	824b638 <strtol>

0824b148 <_atoi_r>:
 824b148:	01c00284 	movi	r7,10
 824b14c:	000d883a 	mov	r6,zero
 824b150:	824b4001 	jmpi	824b400 <_strtol_r>

0824b154 <exit>:
 824b154:	defffe04 	addi	sp,sp,-8
 824b158:	000b883a 	mov	r5,zero
 824b15c:	dc000015 	stw	r16,0(sp)
 824b160:	dfc00115 	stw	ra,4(sp)
 824b164:	2021883a 	mov	r16,r4
 824b168:	824b8040 	call	824b804 <__call_exitprocs>
 824b16c:	00820974 	movhi	r2,2085
 824b170:	108e2f04 	addi	r2,r2,14524
 824b174:	11000017 	ldw	r4,0(r2)
 824b178:	20800f17 	ldw	r2,60(r4)
 824b17c:	10000126 	beq	r2,zero,824b184 <exit+0x30>
 824b180:	103ee83a 	callr	r2
 824b184:	8009883a 	mov	r4,r16
 824b188:	824b99c0 	call	824b99c <_exit>

0824b18c <malloc>:
 824b18c:	00820974 	movhi	r2,2085
 824b190:	108e3004 	addi	r2,r2,14528
 824b194:	200b883a 	mov	r5,r4
 824b198:	11000017 	ldw	r4,0(r2)
 824b19c:	820b7e81 	jmpi	820b7e8 <_malloc_r>

0824b1a0 <free>:
 824b1a0:	00820974 	movhi	r2,2085
 824b1a4:	108e3004 	addi	r2,r2,14528
 824b1a8:	200b883a 	mov	r5,r4
 824b1ac:	11000017 	ldw	r4,0(r2)
 824b1b0:	820abfc1 	jmpi	820abfc <_free_r>

0824b1b4 <strcpy>:
 824b1b4:	2906b03a 	or	r3,r5,r4
 824b1b8:	18c000cc 	andi	r3,r3,3
 824b1bc:	2005883a 	mov	r2,r4
 824b1c0:	1800161e 	bne	r3,zero,824b21c <strcpy+0x68>
 824b1c4:	29c00017 	ldw	r7,0(r5)
 824b1c8:	02ffbff4 	movhi	r11,65279
 824b1cc:	5affbfc4 	addi	r11,r11,-257
 824b1d0:	02a02074 	movhi	r10,32897
 824b1d4:	01c6303a 	nor	r3,zero,r7
 824b1d8:	3ac9883a 	add	r4,r7,r11
 824b1dc:	52a02004 	addi	r10,r10,-32640
 824b1e0:	20c6703a 	and	r3,r4,r3
 824b1e4:	1a86703a 	and	r3,r3,r10
 824b1e8:	18000c1e 	bne	r3,zero,824b21c <strcpy+0x68>
 824b1ec:	1011883a 	mov	r8,r2
 824b1f0:	41c00015 	stw	r7,0(r8)
 824b1f4:	29400104 	addi	r5,r5,4
 824b1f8:	29c00017 	ldw	r7,0(r5)
 824b1fc:	41800104 	addi	r6,r8,4
 824b200:	3011883a 	mov	r8,r6
 824b204:	3ad3883a 	add	r9,r7,r11
 824b208:	01c6303a 	nor	r3,zero,r7
 824b20c:	48c6703a 	and	r3,r9,r3
 824b210:	1a86703a 	and	r3,r3,r10
 824b214:	183ff626 	beq	r3,zero,824b1f0 <strcpy+0x3c>
 824b218:	00000106 	br	824b220 <strcpy+0x6c>
 824b21c:	100d883a 	mov	r6,r2
 824b220:	28c00003 	ldbu	r3,0(r5)
 824b224:	31800044 	addi	r6,r6,1
 824b228:	29400044 	addi	r5,r5,1
 824b22c:	30ffffc5 	stb	r3,-1(r6)
 824b230:	18c03fcc 	andi	r3,r3,255
 824b234:	18c0201c 	xori	r3,r3,128
 824b238:	18ffe004 	addi	r3,r3,-128
 824b23c:	183ff81e 	bne	r3,zero,824b220 <strcpy+0x6c>
 824b240:	f800283a 	ret

0824b244 <strncmp>:
 824b244:	30003126 	beq	r6,zero,824b30c <strncmp+0xc8>
 824b248:	2144b03a 	or	r2,r4,r5
 824b24c:	108000cc 	andi	r2,r2,3
 824b250:	10001e1e 	bne	r2,zero,824b2cc <strncmp+0x88>
 824b254:	024000c4 	movi	r9,3
 824b258:	49801c2e 	bgeu	r9,r6,824b2cc <strncmp+0x88>
 824b25c:	20800017 	ldw	r2,0(r4)
 824b260:	28c00017 	ldw	r3,0(r5)
 824b264:	10c0191e 	bne	r2,r3,824b2cc <strncmp+0x88>
 824b268:	31bfff04 	addi	r6,r6,-4
 824b26c:	30002726 	beq	r6,zero,824b30c <strncmp+0xc8>
 824b270:	02ffbff4 	movhi	r11,65279
 824b274:	5affbfc4 	addi	r11,r11,-257
 824b278:	0086303a 	nor	r3,zero,r2
 824b27c:	02a02074 	movhi	r10,32897
 824b280:	12c5883a 	add	r2,r2,r11
 824b284:	52a02004 	addi	r10,r10,-32640
 824b288:	10c4703a 	and	r2,r2,r3
 824b28c:	1284703a 	and	r2,r2,r10
 824b290:	10000b26 	beq	r2,zero,824b2c0 <strncmp+0x7c>
 824b294:	00001d06 	br	824b30c <strncmp+0xc8>
 824b298:	20c00017 	ldw	r3,0(r4)
 824b29c:	29c00017 	ldw	r7,0(r5)
 824b2a0:	1ad1883a 	add	r8,r3,r11
 824b2a4:	00c4303a 	nor	r2,zero,r3
 824b2a8:	4084703a 	and	r2,r8,r2
 824b2ac:	1284703a 	and	r2,r2,r10
 824b2b0:	19c0061e 	bne	r3,r7,824b2cc <strncmp+0x88>
 824b2b4:	31bfff04 	addi	r6,r6,-4
 824b2b8:	30001426 	beq	r6,zero,824b30c <strncmp+0xc8>
 824b2bc:	1000131e 	bne	r2,zero,824b30c <strncmp+0xc8>
 824b2c0:	21000104 	addi	r4,r4,4
 824b2c4:	29400104 	addi	r5,r5,4
 824b2c8:	49bff336 	bltu	r9,r6,824b298 <strncmp+0x54>
 824b2cc:	28800007 	ldb	r2,0(r5)
 824b2d0:	20c00007 	ldb	r3,0(r4)
 824b2d4:	31bfffc4 	addi	r6,r6,-1
 824b2d8:	10c0081e 	bne	r2,r3,824b2fc <strncmp+0xb8>
 824b2dc:	30000b26 	beq	r6,zero,824b30c <strncmp+0xc8>
 824b2e0:	10000a26 	beq	r2,zero,824b30c <strncmp+0xc8>
 824b2e4:	21000044 	addi	r4,r4,1
 824b2e8:	29400044 	addi	r5,r5,1
 824b2ec:	20800007 	ldb	r2,0(r4)
 824b2f0:	28c00007 	ldb	r3,0(r5)
 824b2f4:	31bfffc4 	addi	r6,r6,-1
 824b2f8:	10fff826 	beq	r2,r3,824b2dc <strncmp+0x98>
 824b2fc:	20800003 	ldbu	r2,0(r4)
 824b300:	28c00003 	ldbu	r3,0(r5)
 824b304:	10c5c83a 	sub	r2,r2,r3
 824b308:	f800283a 	ret
 824b30c:	0005883a 	mov	r2,zero
 824b310:	f800283a 	ret

0824b314 <strncpy>:
 824b314:	2906b03a 	or	r3,r5,r4
 824b318:	18c000cc 	andi	r3,r3,3
 824b31c:	2005883a 	mov	r2,r4
 824b320:	18002c1e 	bne	r3,zero,824b3d4 <strncpy+0xc0>
 824b324:	010000c4 	movi	r4,3
 824b328:	21802a2e 	bgeu	r4,r6,824b3d4 <strncpy+0xc0>
 824b32c:	033fbff4 	movhi	r12,65279
 824b330:	02e02074 	movhi	r11,32897
 824b334:	633fbfc4 	addi	r12,r12,-257
 824b338:	5ae02004 	addi	r11,r11,-32640
 824b33c:	100f883a 	mov	r7,r2
 824b340:	2a000017 	ldw	r8,0(r5)
 824b344:	3815883a 	mov	r10,r7
 824b348:	4313883a 	add	r9,r8,r12
 824b34c:	0206303a 	nor	r3,zero,r8
 824b350:	48c6703a 	and	r3,r9,r3
 824b354:	1ac6703a 	and	r3,r3,r11
 824b358:	1800261e 	bne	r3,zero,824b3f4 <strncpy+0xe0>
 824b35c:	39c00104 	addi	r7,r7,4
 824b360:	52000015 	stw	r8,0(r10)
 824b364:	31bfff04 	addi	r6,r6,-4
 824b368:	3811883a 	mov	r8,r7
 824b36c:	29400104 	addi	r5,r5,4
 824b370:	21bff336 	bltu	r4,r6,824b340 <strncpy+0x2c>
 824b374:	30001e26 	beq	r6,zero,824b3f0 <strncpy+0xdc>
 824b378:	29c00003 	ldbu	r7,0(r5)
 824b37c:	31bfffc4 	addi	r6,r6,-1
 824b380:	40c00044 	addi	r3,r8,1
 824b384:	41c00005 	stb	r7,0(r8)
 824b388:	39c03fcc 	andi	r7,r7,255
 824b38c:	39c0201c 	xori	r7,r7,128
 824b390:	39ffe004 	addi	r7,r7,-128
 824b394:	29400044 	addi	r5,r5,1
 824b398:	38001026 	beq	r7,zero,824b3dc <strncpy+0xc8>
 824b39c:	1811883a 	mov	r8,r3
 824b3a0:	00000906 	br	824b3c8 <strncpy+0xb4>
 824b3a4:	29c00003 	ldbu	r7,0(r5)
 824b3a8:	31bfffc4 	addi	r6,r6,-1
 824b3ac:	29400044 	addi	r5,r5,1
 824b3b0:	41c00005 	stb	r7,0(r8)
 824b3b4:	39c03fcc 	andi	r7,r7,255
 824b3b8:	39c0201c 	xori	r7,r7,128
 824b3bc:	39ffe004 	addi	r7,r7,-128
 824b3c0:	1811883a 	mov	r8,r3
 824b3c4:	38000526 	beq	r7,zero,824b3dc <strncpy+0xc8>
 824b3c8:	18c00044 	addi	r3,r3,1
 824b3cc:	303ff51e 	bne	r6,zero,824b3a4 <strncpy+0x90>
 824b3d0:	f800283a 	ret
 824b3d4:	1011883a 	mov	r8,r2
 824b3d8:	003fe606 	br	824b374 <strncpy+0x60>
 824b3dc:	30000726 	beq	r6,zero,824b3fc <strncpy+0xe8>
 824b3e0:	198d883a 	add	r6,r3,r6
 824b3e4:	18000005 	stb	zero,0(r3)
 824b3e8:	18c00044 	addi	r3,r3,1
 824b3ec:	19bffd1e 	bne	r3,r6,824b3e4 <strncpy+0xd0>
 824b3f0:	f800283a 	ret
 824b3f4:	3811883a 	mov	r8,r7
 824b3f8:	003fdf06 	br	824b378 <strncpy+0x64>
 824b3fc:	f800283a 	ret

0824b400 <_strtol_r>:
 824b400:	00820974 	movhi	r2,2085
 824b404:	defff404 	addi	sp,sp,-48
 824b408:	108e2e04 	addi	r2,r2,14520
 824b40c:	dd400715 	stw	r21,28(sp)
 824b410:	15400017 	ldw	r21,0(r2)
 824b414:	dd800815 	stw	r22,32(sp)
 824b418:	dd000615 	stw	r20,24(sp)
 824b41c:	dcc00515 	stw	r19,20(sp)
 824b420:	d9000015 	stw	r4,0(sp)
 824b424:	dfc00b15 	stw	ra,44(sp)
 824b428:	df000a15 	stw	fp,40(sp)
 824b42c:	ddc00915 	stw	r23,36(sp)
 824b430:	dc800415 	stw	r18,16(sp)
 824b434:	dc400315 	stw	r17,12(sp)
 824b438:	dc000215 	stw	r16,8(sp)
 824b43c:	2829883a 	mov	r20,r5
 824b440:	3027883a 	mov	r19,r6
 824b444:	382d883a 	mov	r22,r7
 824b448:	2809883a 	mov	r4,r5
 824b44c:	24000003 	ldbu	r16,0(r4)
 824b450:	24400044 	addi	r17,r4,1
 824b454:	2007883a 	mov	r3,r4
 824b458:	ac05883a 	add	r2,r21,r16
 824b45c:	10800043 	ldbu	r2,1(r2)
 824b460:	8809883a 	mov	r4,r17
 824b464:	1080020c 	andi	r2,r2,8
 824b468:	103ff81e 	bne	r2,zero,824b44c <_strtol_r+0x4c>
 824b46c:	00800b44 	movi	r2,45
 824b470:	80805826 	beq	r16,r2,824b5d4 <_strtol_r+0x1d4>
 824b474:	00800ac4 	movi	r2,43
 824b478:	80805a26 	beq	r16,r2,824b5e4 <_strtol_r+0x1e4>
 824b47c:	0039883a 	mov	fp,zero
 824b480:	b0004426 	beq	r22,zero,824b594 <_strtol_r+0x194>
 824b484:	00800404 	movi	r2,16
 824b488:	b0806026 	beq	r22,r2,824b60c <_strtol_r+0x20c>
 824b48c:	b02f883a 	mov	r23,r22
 824b490:	00a00034 	movhi	r2,32768
 824b494:	e025003a 	cmpeq	r18,fp,zero
 824b498:	14a5c83a 	sub	r18,r2,r18
 824b49c:	b80b883a 	mov	r5,r23
 824b4a0:	9009883a 	mov	r4,r18
 824b4a4:	82027700 	call	8202770 <__umodsi3>
 824b4a8:	b80b883a 	mov	r5,r23
 824b4ac:	9009883a 	mov	r4,r18
 824b4b0:	d8800115 	stw	r2,4(sp)
 824b4b4:	820270c0 	call	820270c <__udivsi3>
 824b4b8:	ac07883a 	add	r3,r21,r16
 824b4bc:	18c00043 	ldbu	r3,1(r3)
 824b4c0:	880b883a 	mov	r5,r17
 824b4c4:	000d883a 	mov	r6,zero
 824b4c8:	1a00010c 	andi	r8,r3,4
 824b4cc:	0009883a 	mov	r4,zero
 824b4d0:	02800044 	movi	r10,1
 824b4d4:	027fffc4 	movi	r9,-1
 824b4d8:	d9c00117 	ldw	r7,4(sp)
 824b4dc:	40000e26 	beq	r8,zero,824b518 <_strtol_r+0x118>
 824b4e0:	843ff404 	addi	r16,r16,-48
 824b4e4:	8580120e 	bge	r16,r22,824b530 <_strtol_r+0x130>
 824b4e8:	32400526 	beq	r6,r9,824b500 <_strtol_r+0x100>
 824b4ec:	11002536 	bltu	r2,r4,824b584 <_strtol_r+0x184>
 824b4f0:	20802326 	beq	r4,r2,824b580 <_strtol_r+0x180>
 824b4f4:	25c9383a 	mul	r4,r4,r23
 824b4f8:	01800044 	movi	r6,1
 824b4fc:	8109883a 	add	r4,r16,r4
 824b500:	2c000003 	ldbu	r16,0(r5)
 824b504:	29400044 	addi	r5,r5,1
 824b508:	ac07883a 	add	r3,r21,r16
 824b50c:	18c00043 	ldbu	r3,1(r3)
 824b510:	1a00010c 	andi	r8,r3,4
 824b514:	403ff21e 	bne	r8,zero,824b4e0 <_strtol_r+0xe0>
 824b518:	18c000cc 	andi	r3,r3,3
 824b51c:	18000426 	beq	r3,zero,824b530 <_strtol_r+0x130>
 824b520:	1a801a26 	beq	r3,r10,824b58c <_strtol_r+0x18c>
 824b524:	00c015c4 	movi	r3,87
 824b528:	80e1c83a 	sub	r16,r16,r3
 824b52c:	85bfee16 	blt	r16,r22,824b4e8 <_strtol_r+0xe8>
 824b530:	00bfffc4 	movi	r2,-1
 824b534:	30801e26 	beq	r6,r2,824b5b0 <_strtol_r+0x1b0>
 824b538:	e0001b1e 	bne	fp,zero,824b5a8 <_strtol_r+0x1a8>
 824b53c:	2005883a 	mov	r2,r4
 824b540:	98000326 	beq	r19,zero,824b550 <_strtol_r+0x150>
 824b544:	3000211e 	bne	r6,zero,824b5cc <_strtol_r+0x1cc>
 824b548:	a00b883a 	mov	r5,r20
 824b54c:	99400015 	stw	r5,0(r19)
 824b550:	dfc00b17 	ldw	ra,44(sp)
 824b554:	df000a17 	ldw	fp,40(sp)
 824b558:	ddc00917 	ldw	r23,36(sp)
 824b55c:	dd800817 	ldw	r22,32(sp)
 824b560:	dd400717 	ldw	r21,28(sp)
 824b564:	dd000617 	ldw	r20,24(sp)
 824b568:	dcc00517 	ldw	r19,20(sp)
 824b56c:	dc800417 	ldw	r18,16(sp)
 824b570:	dc400317 	ldw	r17,12(sp)
 824b574:	dc000217 	ldw	r16,8(sp)
 824b578:	dec00c04 	addi	sp,sp,48
 824b57c:	f800283a 	ret
 824b580:	3c3fdc0e 	bge	r7,r16,824b4f4 <_strtol_r+0xf4>
 824b584:	01bfffc4 	movi	r6,-1
 824b588:	003fdd06 	br	824b500 <_strtol_r+0x100>
 824b58c:	00c00dc4 	movi	r3,55
 824b590:	003fe506 	br	824b528 <_strtol_r+0x128>
 824b594:	00800c04 	movi	r2,48
 824b598:	80801626 	beq	r16,r2,824b5f4 <_strtol_r+0x1f4>
 824b59c:	05800284 	movi	r22,10
 824b5a0:	b02f883a 	mov	r23,r22
 824b5a4:	003fba06 	br	824b490 <_strtol_r+0x90>
 824b5a8:	0109c83a 	sub	r4,zero,r4
 824b5ac:	003fe306 	br	824b53c <_strtol_r+0x13c>
 824b5b0:	d9000017 	ldw	r4,0(sp)
 824b5b4:	00c00884 	movi	r3,34
 824b5b8:	e005003a 	cmpeq	r2,fp,zero
 824b5bc:	20c00015 	stw	r3,0(r4)
 824b5c0:	00e00034 	movhi	r3,32768
 824b5c4:	1885c83a 	sub	r2,r3,r2
 824b5c8:	983fe126 	beq	r19,zero,824b550 <_strtol_r+0x150>
 824b5cc:	297fffc4 	addi	r5,r5,-1
 824b5d0:	003fde06 	br	824b54c <_strtol_r+0x14c>
 824b5d4:	1c400084 	addi	r17,r3,2
 824b5d8:	1c000043 	ldbu	r16,1(r3)
 824b5dc:	07000044 	movi	fp,1
 824b5e0:	003fa706 	br	824b480 <_strtol_r+0x80>
 824b5e4:	1c400084 	addi	r17,r3,2
 824b5e8:	1c000043 	ldbu	r16,1(r3)
 824b5ec:	0039883a 	mov	fp,zero
 824b5f0:	003fa306 	br	824b480 <_strtol_r+0x80>
 824b5f4:	88800003 	ldbu	r2,0(r17)
 824b5f8:	00c01604 	movi	r3,88
 824b5fc:	108037cc 	andi	r2,r2,223
 824b600:	10c00826 	beq	r2,r3,824b624 <_strtol_r+0x224>
 824b604:	05800204 	movi	r22,8
 824b608:	003fa006 	br	824b48c <_strtol_r+0x8c>
 824b60c:	00800c04 	movi	r2,48
 824b610:	80bf9e1e 	bne	r16,r2,824b48c <_strtol_r+0x8c>
 824b614:	88800003 	ldbu	r2,0(r17)
 824b618:	00c01604 	movi	r3,88
 824b61c:	108037cc 	andi	r2,r2,223
 824b620:	10ff9a1e 	bne	r2,r3,824b48c <_strtol_r+0x8c>
 824b624:	05c00404 	movi	r23,16
 824b628:	8c000043 	ldbu	r16,1(r17)
 824b62c:	b82d883a 	mov	r22,r23
 824b630:	8c400084 	addi	r17,r17,2
 824b634:	003f9606 	br	824b490 <_strtol_r+0x90>

0824b638 <strtol>:
 824b638:	00820974 	movhi	r2,2085
 824b63c:	108e3004 	addi	r2,r2,14528
 824b640:	300f883a 	mov	r7,r6
 824b644:	280d883a 	mov	r6,r5
 824b648:	200b883a 	mov	r5,r4
 824b64c:	11000017 	ldw	r4,0(r2)
 824b650:	824b4001 	jmpi	824b400 <_strtol_r>

0824b654 <vprintf>:
 824b654:	00820974 	movhi	r2,2085
 824b658:	108e3004 	addi	r2,r2,14528
 824b65c:	200d883a 	mov	r6,r4
 824b660:	11000017 	ldw	r4,0(r2)
 824b664:	280f883a 	mov	r7,r5
 824b668:	21400217 	ldw	r5,8(r4)
 824b66c:	824b9841 	jmpi	824b984 <_vfprintf_r>

0824b670 <_vprintf_r>:
 824b670:	300f883a 	mov	r7,r6
 824b674:	280d883a 	mov	r6,r5
 824b678:	21400217 	ldw	r5,8(r4)
 824b67c:	824b9841 	jmpi	824b984 <_vfprintf_r>

0824b680 <_vsprintf_r>:
 824b680:	00a00034 	movhi	r2,32768
 824b684:	deffe504 	addi	sp,sp,-108
 824b688:	10bfffc4 	addi	r2,r2,-1
 824b68c:	2807883a 	mov	r3,r5
 824b690:	02008204 	movi	r8,520
 824b694:	d8800215 	stw	r2,8(sp)
 824b698:	d8800515 	stw	r2,20(sp)
 824b69c:	d80b883a 	mov	r5,sp
 824b6a0:	00bfffc4 	movi	r2,-1
 824b6a4:	d8c00015 	stw	r3,0(sp)
 824b6a8:	d8c00415 	stw	r3,16(sp)
 824b6ac:	dfc01a15 	stw	ra,104(sp)
 824b6b0:	da00030d 	sth	r8,12(sp)
 824b6b4:	d880038d 	sth	r2,14(sp)
 824b6b8:	82043580 	call	8204358 <___svfprintf_internal_r>
 824b6bc:	d8c00017 	ldw	r3,0(sp)
 824b6c0:	18000005 	stb	zero,0(r3)
 824b6c4:	dfc01a17 	ldw	ra,104(sp)
 824b6c8:	dec01b04 	addi	sp,sp,108
 824b6cc:	f800283a 	ret

0824b6d0 <vsprintf>:
 824b6d0:	00820974 	movhi	r2,2085
 824b6d4:	108e3004 	addi	r2,r2,14528
 824b6d8:	300f883a 	mov	r7,r6
 824b6dc:	280d883a 	mov	r6,r5
 824b6e0:	200b883a 	mov	r5,r4
 824b6e4:	11000017 	ldw	r4,0(r2)
 824b6e8:	824b6801 	jmpi	824b680 <_vsprintf_r>

0824b6ec <__register_exitproc>:
 824b6ec:	defffa04 	addi	sp,sp,-24
 824b6f0:	dc000315 	stw	r16,12(sp)
 824b6f4:	04020974 	movhi	r16,2085
 824b6f8:	840e2f04 	addi	r16,r16,14524
 824b6fc:	80c00017 	ldw	r3,0(r16)
 824b700:	dc400415 	stw	r17,16(sp)
 824b704:	dfc00515 	stw	ra,20(sp)
 824b708:	18805217 	ldw	r2,328(r3)
 824b70c:	2023883a 	mov	r17,r4
 824b710:	10003726 	beq	r2,zero,824b7f0 <__register_exitproc+0x104>
 824b714:	10c00117 	ldw	r3,4(r2)
 824b718:	010007c4 	movi	r4,31
 824b71c:	20c00e16 	blt	r4,r3,824b758 <__register_exitproc+0x6c>
 824b720:	1a000044 	addi	r8,r3,1
 824b724:	8800221e 	bne	r17,zero,824b7b0 <__register_exitproc+0xc4>
 824b728:	18c00084 	addi	r3,r3,2
 824b72c:	18c7883a 	add	r3,r3,r3
 824b730:	18c7883a 	add	r3,r3,r3
 824b734:	12000115 	stw	r8,4(r2)
 824b738:	10c7883a 	add	r3,r2,r3
 824b73c:	19400015 	stw	r5,0(r3)
 824b740:	0005883a 	mov	r2,zero
 824b744:	dfc00517 	ldw	ra,20(sp)
 824b748:	dc400417 	ldw	r17,16(sp)
 824b74c:	dc000317 	ldw	r16,12(sp)
 824b750:	dec00604 	addi	sp,sp,24
 824b754:	f800283a 	ret
 824b758:	00820974 	movhi	r2,2085
 824b75c:	10ac6304 	addi	r2,r2,-20084
 824b760:	10002626 	beq	r2,zero,824b7fc <__register_exitproc+0x110>
 824b764:	01006404 	movi	r4,400
 824b768:	d9400015 	stw	r5,0(sp)
 824b76c:	d9800115 	stw	r6,4(sp)
 824b770:	d9c00215 	stw	r7,8(sp)
 824b774:	824b18c0 	call	824b18c <malloc>
 824b778:	d9400017 	ldw	r5,0(sp)
 824b77c:	d9800117 	ldw	r6,4(sp)
 824b780:	d9c00217 	ldw	r7,8(sp)
 824b784:	10001d26 	beq	r2,zero,824b7fc <__register_exitproc+0x110>
 824b788:	81000017 	ldw	r4,0(r16)
 824b78c:	10000115 	stw	zero,4(r2)
 824b790:	02000044 	movi	r8,1
 824b794:	22405217 	ldw	r9,328(r4)
 824b798:	0007883a 	mov	r3,zero
 824b79c:	12400015 	stw	r9,0(r2)
 824b7a0:	20805215 	stw	r2,328(r4)
 824b7a4:	10006215 	stw	zero,392(r2)
 824b7a8:	10006315 	stw	zero,396(r2)
 824b7ac:	883fde26 	beq	r17,zero,824b728 <__register_exitproc+0x3c>
 824b7b0:	18c9883a 	add	r4,r3,r3
 824b7b4:	2109883a 	add	r4,r4,r4
 824b7b8:	1109883a 	add	r4,r2,r4
 824b7bc:	21802215 	stw	r6,136(r4)
 824b7c0:	01800044 	movi	r6,1
 824b7c4:	12406217 	ldw	r9,392(r2)
 824b7c8:	30cc983a 	sll	r6,r6,r3
 824b7cc:	4992b03a 	or	r9,r9,r6
 824b7d0:	12406215 	stw	r9,392(r2)
 824b7d4:	21c04215 	stw	r7,264(r4)
 824b7d8:	01000084 	movi	r4,2
 824b7dc:	893fd21e 	bne	r17,r4,824b728 <__register_exitproc+0x3c>
 824b7e0:	11006317 	ldw	r4,396(r2)
 824b7e4:	218cb03a 	or	r6,r4,r6
 824b7e8:	11806315 	stw	r6,396(r2)
 824b7ec:	003fce06 	br	824b728 <__register_exitproc+0x3c>
 824b7f0:	18805304 	addi	r2,r3,332
 824b7f4:	18805215 	stw	r2,328(r3)
 824b7f8:	003fc606 	br	824b714 <__register_exitproc+0x28>
 824b7fc:	00bfffc4 	movi	r2,-1
 824b800:	003fd006 	br	824b744 <__register_exitproc+0x58>

0824b804 <__call_exitprocs>:
 824b804:	defff504 	addi	sp,sp,-44
 824b808:	df000915 	stw	fp,36(sp)
 824b80c:	dd400615 	stw	r21,24(sp)
 824b810:	dc800315 	stw	r18,12(sp)
 824b814:	dfc00a15 	stw	ra,40(sp)
 824b818:	ddc00815 	stw	r23,32(sp)
 824b81c:	dd800715 	stw	r22,28(sp)
 824b820:	dd000515 	stw	r20,20(sp)
 824b824:	dcc00415 	stw	r19,16(sp)
 824b828:	dc400215 	stw	r17,8(sp)
 824b82c:	dc000115 	stw	r16,4(sp)
 824b830:	d9000015 	stw	r4,0(sp)
 824b834:	2839883a 	mov	fp,r5
 824b838:	04800044 	movi	r18,1
 824b83c:	057fffc4 	movi	r21,-1
 824b840:	00820974 	movhi	r2,2085
 824b844:	108e2f04 	addi	r2,r2,14524
 824b848:	12000017 	ldw	r8,0(r2)
 824b84c:	45005217 	ldw	r20,328(r8)
 824b850:	44c05204 	addi	r19,r8,328
 824b854:	a0001c26 	beq	r20,zero,824b8c8 <__call_exitprocs+0xc4>
 824b858:	a0800117 	ldw	r2,4(r20)
 824b85c:	15ffffc4 	addi	r23,r2,-1
 824b860:	b8000d16 	blt	r23,zero,824b898 <__call_exitprocs+0x94>
 824b864:	14000044 	addi	r16,r2,1
 824b868:	8421883a 	add	r16,r16,r16
 824b86c:	8421883a 	add	r16,r16,r16
 824b870:	84402004 	addi	r17,r16,128
 824b874:	a463883a 	add	r17,r20,r17
 824b878:	a421883a 	add	r16,r20,r16
 824b87c:	e0001e26 	beq	fp,zero,824b8f8 <__call_exitprocs+0xf4>
 824b880:	80804017 	ldw	r2,256(r16)
 824b884:	e0801c26 	beq	fp,r2,824b8f8 <__call_exitprocs+0xf4>
 824b888:	bdffffc4 	addi	r23,r23,-1
 824b88c:	843fff04 	addi	r16,r16,-4
 824b890:	8c7fff04 	addi	r17,r17,-4
 824b894:	bd7ff91e 	bne	r23,r21,824b87c <__call_exitprocs+0x78>
 824b898:	00820974 	movhi	r2,2085
 824b89c:	10ac6804 	addi	r2,r2,-20064
 824b8a0:	10000926 	beq	r2,zero,824b8c8 <__call_exitprocs+0xc4>
 824b8a4:	a0800117 	ldw	r2,4(r20)
 824b8a8:	1000301e 	bne	r2,zero,824b96c <__call_exitprocs+0x168>
 824b8ac:	a0800017 	ldw	r2,0(r20)
 824b8b0:	10003226 	beq	r2,zero,824b97c <__call_exitprocs+0x178>
 824b8b4:	a009883a 	mov	r4,r20
 824b8b8:	98800015 	stw	r2,0(r19)
 824b8bc:	824b1a00 	call	824b1a0 <free>
 824b8c0:	9d000017 	ldw	r20,0(r19)
 824b8c4:	a03fe41e 	bne	r20,zero,824b858 <__call_exitprocs+0x54>
 824b8c8:	dfc00a17 	ldw	ra,40(sp)
 824b8cc:	df000917 	ldw	fp,36(sp)
 824b8d0:	ddc00817 	ldw	r23,32(sp)
 824b8d4:	dd800717 	ldw	r22,28(sp)
 824b8d8:	dd400617 	ldw	r21,24(sp)
 824b8dc:	dd000517 	ldw	r20,20(sp)
 824b8e0:	dcc00417 	ldw	r19,16(sp)
 824b8e4:	dc800317 	ldw	r18,12(sp)
 824b8e8:	dc400217 	ldw	r17,8(sp)
 824b8ec:	dc000117 	ldw	r16,4(sp)
 824b8f0:	dec00b04 	addi	sp,sp,44
 824b8f4:	f800283a 	ret
 824b8f8:	a0800117 	ldw	r2,4(r20)
 824b8fc:	80c00017 	ldw	r3,0(r16)
 824b900:	10bfffc4 	addi	r2,r2,-1
 824b904:	15c01426 	beq	r2,r23,824b958 <__call_exitprocs+0x154>
 824b908:	80000015 	stw	zero,0(r16)
 824b90c:	183fde26 	beq	r3,zero,824b888 <__call_exitprocs+0x84>
 824b910:	95c8983a 	sll	r4,r18,r23
 824b914:	a0806217 	ldw	r2,392(r20)
 824b918:	a5800117 	ldw	r22,4(r20)
 824b91c:	2084703a 	and	r2,r4,r2
 824b920:	10000b26 	beq	r2,zero,824b950 <__call_exitprocs+0x14c>
 824b924:	a0806317 	ldw	r2,396(r20)
 824b928:	2088703a 	and	r4,r4,r2
 824b92c:	20000c1e 	bne	r4,zero,824b960 <__call_exitprocs+0x15c>
 824b930:	89400017 	ldw	r5,0(r17)
 824b934:	d9000017 	ldw	r4,0(sp)
 824b938:	183ee83a 	callr	r3
 824b93c:	a0800117 	ldw	r2,4(r20)
 824b940:	15bfbf1e 	bne	r2,r22,824b840 <__call_exitprocs+0x3c>
 824b944:	98800017 	ldw	r2,0(r19)
 824b948:	153fcf26 	beq	r2,r20,824b888 <__call_exitprocs+0x84>
 824b94c:	003fbc06 	br	824b840 <__call_exitprocs+0x3c>
 824b950:	183ee83a 	callr	r3
 824b954:	003ff906 	br	824b93c <__call_exitprocs+0x138>
 824b958:	a5c00115 	stw	r23,4(r20)
 824b95c:	003feb06 	br	824b90c <__call_exitprocs+0x108>
 824b960:	89000017 	ldw	r4,0(r17)
 824b964:	183ee83a 	callr	r3
 824b968:	003ff406 	br	824b93c <__call_exitprocs+0x138>
 824b96c:	a0800017 	ldw	r2,0(r20)
 824b970:	a027883a 	mov	r19,r20
 824b974:	1029883a 	mov	r20,r2
 824b978:	003fb606 	br	824b854 <__call_exitprocs+0x50>
 824b97c:	0005883a 	mov	r2,zero
 824b980:	003ffb06 	br	824b970 <__call_exitprocs+0x16c>

0824b984 <_vfprintf_r>:
 824b984:	deffff04 	addi	sp,sp,-4
 824b988:	dfc00015 	stw	ra,0(sp)
 824b98c:	82065380 	call	8206538 <___vfprintf_internal_r>
 824b990:	dfc00017 	ldw	ra,0(sp)
 824b994:	dec00104 	addi	sp,sp,4
 824b998:	f800283a 	ret

0824b99c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 824b99c:	defffd04 	addi	sp,sp,-12
 824b9a0:	df000215 	stw	fp,8(sp)
 824b9a4:	df000204 	addi	fp,sp,8
 824b9a8:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 824b9ac:	d0206b45 	stb	zero,-32339(gp)
 824b9b0:	e0bfff17 	ldw	r2,-4(fp)
 824b9b4:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 824b9b8:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 824b9bc:	10000226 	beq	r2,zero,824b9c8 <_exit+0x2c>
    ALT_SIM_FAIL();
 824b9c0:	002af070 	cmpltui	zero,zero,43969
 824b9c4:	00000106 	br	824b9cc <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 824b9c8:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 824b9cc:	003fff06 	br	824b9cc <_exit+0x30>
