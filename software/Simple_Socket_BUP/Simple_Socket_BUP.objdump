
Simple_Socket_BUP.elf:     file format elf32-littlenios2
Simple_Socket_BUP.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08200200

Program Header:
    LOAD off    0x00001000 vaddr 0x04a80000 paddr 0x04a80000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001060 vaddr 0x08200060 paddr 0x08200060 align 2**12
         filesz 0x00053bd0 memsz 0x0005e680 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  04a80000  04a80000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  08200060  08200060  00001060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004ba20  08200200  08200200  00001200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005f24  0824bc20  0824bc20  0004cc20  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020ec  08251b44  08251b44  00052b44  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000aab0  08253c30  08253c30  00054c30  2**2
                  ALLOC, SMALL_DATA
  6 .ext_flash    00000000  04a80020  04a80020  00054c30  2**0
                  CONTENTS
  7 .descriptor_memory 00000000  08000000  08000000  00054c30  2**0
                  CONTENTS
  8 .onchip_ram   00000000  0825e6e0  0825e6e0  00054c30  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00054c30  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001d18  00000000  00000000  00054c58  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00067021  00000000  00000000  00056970  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00015607  00000000  00000000  000bd991  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001da7b  00000000  00000000  000d2f98  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00008908  00000000  00000000  000f0a14  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000bace  00000000  00000000  000f931c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001ef9a  00000000  00000000  00104dea  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  00123d84  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001e98  00000000  00000000  00123dd8  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000006  00000000  00000000  00130462  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  00130468  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0013046b  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0013046c  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0013046d  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00130471  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  00130475  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  00130479  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  00130484  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  0013048f  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 0000001a  00000000  00000000  0013049a  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000023  00000000  00000000  001304b4  2**0
                  CONTENTS, READONLY
 31 .jdi          00006f06  00000000  00000000  001304d7  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     000bd54f  00000000  00000000  001373dd  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04a80000 l    d  .entry	00000000 .entry
08200060 l    d  .exceptions	00000000 .exceptions
08200200 l    d  .text	00000000 .text
0824bc20 l    d  .rodata	00000000 .rodata
08251b44 l    d  .rwdata	00000000 .rwdata
08253c30 l    d  .bss	00000000 .bss
04a80020 l    d  .ext_flash	00000000 .ext_flash
08000000 l    d  .descriptor_memory	00000000 .descriptor_memory
0825e6e0 l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simple_Socket_BUP_bsp//obj/HAL/src/crt0.o
08200244 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
082000d4 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
08253c3c l     O .bss	00000004 SSSCommand.4950
08253e4c l     O .bss	000005f0 conn.4980
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 ctype_.c
0824ced7 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
08251c7c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strstr.c
08203d44 l     F .text	00000104 critical_factorization
08203e48 l     F .text	000003b0 two_way_long_needle
00000000 l    df *ABS*	00000000 vfprintf.c
0824d7a6 l     O .rodata	00000010 zeroes.4389
0824d7b6 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824d7c6 l     O .rodata	00000010 zeroes.4404
0820899c l     F .text	000000bc __sbprintf
0824d7d6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
08208d04 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0820a834 l     F .text	00000008 __fp_unlock
0820a848 l     F .text	0000019c __sinit.part.1
0820a9e4 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
082520c0 l     O .rwdata	00000020 lc_ctype_charset
082520a0 l     O .rwdata	00000020 lc_message_charset
082520e0 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 mprec.c
0824d804 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0820d904 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824d938 l     O .rodata	00000010 blanks.4332
0824d928 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 vfprintf.c
0820f1e0 l     F .text	000000fc __sprint_r.part.0
0824d958 l     O .rodata	00000010 blanks.4348
0824d948 l     O .rodata	00000010 zeroes.4349
0821076c l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
082141d8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
082142c4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
082143a4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
08253afc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
08253b00 l     O .rwdata	00000004 lockid
08253c74 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
08253b04 l     O .rwdata	00000004 lockid
08253c7c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
08215f1c l     F .text	00000048 OS_InitMisc
08215f64 l     F .text	0000006c OS_InitRdyList
082160d0 l     F .text	000000e4 OS_InitTCBList
08215e3c l     F .text	000000e0 OS_InitEventList
08215fd0 l     F .text	00000080 OS_InitTaskIdle
08216050 l     F .text	00000080 OS_InitTaskStat
08216340 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
08218068 l     F .text	000000f4 OS_FlagTaskRdy
08217e28 l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0821c118 l     F .text	00000034 alt_dev_reg
08252520 l     O .rwdata	0000106c jtag_uart_0
0825358c l     O .rwdata	00000124 lcd
082536b0 l     O .rwdata	00000030 sgdma_rx
082536e0 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0821c668 l     F .text	000002a4 altera_avalon_jtag_uart_irq
0821c90c l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
08253b80 l     O .rwdata	00000004 colstart
0821d0e8 l     F .text	000000b8 lcd_write_command
0821d1a0 l     F .text	000000d8 lcd_write_data
0821d278 l     F .text	000000d0 lcd_clear_screen
0821d348 l     F .text	000001ec lcd_repaint_screen
0821d534 l     F .text	000000cc lcd_scroll_up
0821d600 l     F .text	000002ac lcd_handle_escape
0821ddbc l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0821e048 l     F .text	0000003c alt_get_errno
0821ec78 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0821eddc l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
08253cd6 l     O .bss	00000001 tse_system_count.4813
08253cd7 l     O .bss	00000001 is_init.4895
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
08254464 l     O .bss	0000003c closers
08253cec l     O .bss	00000004 nclosers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
08253b9c l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
082544a0 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0822b740 l     F .text	000000ac dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
00000000 l    df *ABS*	00000000 asm_cksum.o
0822d2dc l       .text	00000000 done
0822d16c l       .text	00000000 asm1
0822d298 l       .text	00000000 loop0
0822d194 l       .text	00000000 loop
0822d2b4 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
08253d58 l     O .bss	00000004 kbd_init.4233
08253d54 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
08253d8c l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0823165c l     F .text	0000008c sockargs
08230980 l     F .text	000001dc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
08239150 l     F .text	000000c8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0823b94c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
0823bad0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0823bafc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0823bfcc l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0823c10c l     F .text	0000003c alt_get_errno
0823c148 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
0823c360 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_free.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0823c8a8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 allports.c
08253dc4 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0823d1e4 l     F .text	0000018c check_interval_timers
08253dd0 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
08253dd4 l     O .bss	00000004 arp_timer
08253ddc l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
08253c18 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
08253e1c l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
08253c20 l     O .rwdata	00000004 iCounter.4951
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
082544b8 l     O .bss	0000001e nearBuf.4578
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
08249e6c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
08253ac0 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintfr_1.c
00000000 l    df *ABS*	00000000 alt_exit.c
08203298 g     F .text	00000018 putchar
0825e1dc g     O .bss	00000014 soq
0820d228 g     F .text	00000074 _mprec_log10
08220148 g     F .text	000000d8 alt_tse_get_mac_info
08253b52 g     O .rwdata	00000002 OSTaskNameSize
0820d314 g     F .text	0000008c __any_on
08210d08 g     F .text	00000054 _isatty_r
0824d810 g     O .rodata	00000028 __mprec_tinytens
0823ef74 g     F .text	00000724 ip_write_internal
082144b4 g     F .text	000000bc alt_main
0824b404 g     F .text	00000090 strcpy
0822ca88 g     F .text	000000ac pk_free
082032b0 g     F .text	000000c0 _puts_r
0825e388 g     O .bss	00000100 alt_irq
08253960 g     O .rwdata	00000009 rtp_priority
08210d5c g     F .text	00000060 _lseek_r
0824b010 g     F .text	00000314 icmp_timex
0822e384 g     F .text	00000044 m_freem
0824981c g     F .text	00000048 vgetc
0822d43c g     F .text	00000020 clock_c
08253da4 g     O .bss	00000004 tcp_optionbuf
0823ea94 g     F .text	00000070 if_getbynum
08218888 g     F .text	000000cc OS_MemInit
08253d44 g     O .bss	00000004 dsc_rlyerrs
08253d34 g     O .bss	00000004 dsc_releases
082294ec g     F .text	0000006c TK_OSTaskQuery
0822d14c g       .text	00000000 asm_cksum
08223d58 g     F .text	000000f0 marvell_cfg_rgmii
0821c0b8 g     F .text	00000060 OSTimeSet
08249724 g     F .text	000000f8 vgetc_locked
0822dc74 g     F .text	00000020 post_task_setup
082425d4 g     F .text	00000358 ipr_stats
0823a978 g     F .text	00000118 tcp_attach
08253bac g     O .rwdata	00000004 reqlist_len
0822f744 g     F .text	00000078 tcp_tick
08228740 g     F .text	0000007c print_ipad
082293f4 g     F .text	000000f8 tcp_wakeup
08212c48 g     F .text	00000088 .hidden __eqdf2
08253c34 g     O .bss	00000004 last_flash_sector_offset
08253cf0 g     O .bss	00000004 igmp_timers_are_running
08200d98 g     F .text	000000e4 led_bit_toggle
08237b84 g     F .text	0000012c tcp_pulloutofband
08221344 g     F .text	00000210 alt_tse_phy_print_profile
08214b90 g     F .text	00000610 OSEventPendMulti
0825e6e0 g       *ABS*	00000000 __alt_heap_start
0823cc2c g     F .text	00000024 OSTaskCreateHook
0822c2c4 g     F .text	00000068 dhc_ifacedone
08223af8 g     F .text	00000098 marvell_phy_cfg
0824297c g     F .text	00000380 ip_rcv
082494c8 g     F .text	0000014c vfseek
08233d30 g     F .text	00000108 soqremque
08244550 g     F .text	000007a8 udpdemux
08225480 g     F .text	00000104 tse_mac_close
082030ec g     F .text	0000003c printf
08253df0 g     O .bss	00000004 rt_mib
08253b2a g     O .rwdata	00000002 OSMboxEn
0822c1e4 g     F .text	00000058 dhc_state_init
0824b920 g     F .text	0000001c vsprintf
0821e1a8 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
082151f8 g     F .text	0000004c OSIntEnter
08210e1c g     F .text	0000009c _wcrtomb_r
0820dc94 g     F .text	0000005c __sseek
0820ab84 g     F .text	00000010 __sinit
082437e8 g     F .text	0000010c in_delmulti
08208a58 g     F .text	00000140 __swbuf_r
08253e08 g     O .bss	00000004 so_evtmap_create
08253b3a g     O .rwdata	00000002 OSQEn
08247b84 g     F .text	00000088 in_pcballoc
08253bc8 g     O .rwdata	00000002 socket_defaults
0820b7a0 g     F .text	0000007c _setlocale_r
0823d970 g     F .text	00000454 send_arp
0820a9ec g     F .text	00000068 __sfmoreglue
082485e0 g     F .text	00000338 vfopen_locked
08253c40 g     O .bss	00000004 SSSLEDCommandQ
08214864 g     F .text	000000cc __malloc_unlock
0823cc94 g     F .text	00000020 OSTaskStatHook
0823d104 g     F .text	00000054 prep_modules
08227d40 g     F .text	0000013c bsd_i_sockoptlen
08253c84 g     O .bss	00000001 OSLockNesting
08253ba4 g     O .rwdata	00000004 xids
08203c90 g     F .text	0000001c strerror
0822038c g     F .text	00000a88 getPHYSpeed
08248b24 g     F .text	00000044 vfclose
0825e27c g     O .bss	0000002c tcb
08253b78 g     O .rwdata	00000002 OSDataSize
0823c4fc g     F .text	00000034 alt_remap_cached
08253c85 g     O .bss	00000001 OSRunning
0823e7dc g     F .text	000002b8 grat_arp
08201118 g     F .text	0000005c get_ip_addr
0824760c g     F .text	00000094 inet_pton
0823ebd8 g     F .text	00000090 reg_type
0825dd80 g     O .bss	000000f0 dhc_states
08226bbc g     F .text	00000174 igmp_fasttimo
08248cd0 g     F .text	0000005c vunlink_flag_open_files
0822bfac g     F .text	00000080 dhc_halt
0821e8c0 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
08253d28 g     O .bss	00000004 dsc_acks
0825e2a8 g     O .bss	000000e0 tcpstat
08241ecc g     F .text	0000034c ip_reasm_copy_queued_fragments_into_reassy_buffer
0822e8d0 g     F .text	0000009c dtom
08239050 g     F .text	00000100 tcp_setpersist
08230d1c g     F .text	0000018c t_getsockopt
08202da4 g     F .text	0000015c memmove
08253d38 g     O .bss	00000004 dsc_naks
0822ed20 g     F .text	000005b0 ip_output
0823cce0 g     F .text	00000020 OSInitHookBegin
0824b324 g     F .text	00000054 icmp_du
08253ba0 g     O .rwdata	00000004 num_net_tasks
08253e2c g     O .bss	00000004 vfiles
08253b70 g     O .rwdata	00000002 OSTmrSize
08246d9c g     F .text	00000114 dhc_main_ipset
0820ab6c g     F .text	00000018 _cleanup
082410a0 g     F .text	000002b8 ip_reasm_process_first_fragment
0820c3a4 g     F .text	000000a8 _Balloc
08201614 g     F .text	00000198 get_board_mac_addr
08253c88 g     O .bss	00000004 OSIdleCtr
08253c44 g     O .bss	00000004 SSSLEDLightshowSem
08222d58 g     F .text	000001c4 alt_tse_phy_set_adv_1000
08253b8c g     O .rwdata	00000001 max_mac_system
08245cf8 g     F .text	000005c8 ip_setmoptions
0821f3fc g     F .text	000009fc alt_tse_system_add_sys
08212cd0 g     F .text	000000dc .hidden __gtdf2
08247128 g     F .text	0000002c md_fseek
0823caac g       .text	00000000 OSStartTsk
08216688 g     F .text	000002d4 OS_TCBInit
08241358 g     F .text	00000088 ip_reassm
0822c02c g     F .text	000001b8 dhc_reclaim
0825e668 g     O .bss	00000010 udp_mib
04a80000 g     F .entry	00000000 __reset
082314c0 g     F .text	000000d8 t_shutdown
082024c0 g     F .text	000001f0 sss_handle_receive
08230f88 g     F .text	00000140 t_recvfrom
08253b76 g     O .rwdata	00000002 OSTmrWheelTblSize
08246484 g     F .text	000006b4 u_mctest_run
0821e410 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
08243958 g     F .text	00000080 prep_ifaces
08253d0c g     O .bss	00000001 to_netmain
0822c738 g     F .text	000000c4 pk_alloc
08253b16 g     O .rwdata	00000002 OSEventSize
08200a10 g     F .text	00000298 alt_SSSErrorHandler
08253c8c g     O .bss	00000001 OSPrioHighRdy
08210cac g     F .text	0000005c _fstat_r
08251b5c g     O .rwdata	00000120 tse_mac_device
08229194 g     F .text	00000048 tk_nettick
0823cc50 g     F .text	00000024 OSTaskDelHook
08253c64 g     O .bss	00000004 errno
082033f8 g     F .text	00000014 __srget
08234f34 g     F .text	000000c4 in_pcbnotify
0820dc10 g     F .text	00000008 __seofread
0823ca8c g       .text	00000000 OSStartHighRdy
0825de70 g     O .bss	00000014 lilfreeq
08200248 g     F .text	00000564 alt_uCOSIIErrorHandler
08243a00 g     F .text	0000002c evtmap_setup
0821ab54 g     F .text	000001e4 OSTaskCreateExt
08253d10 g     O .bss	00000004 tcp_sleep_timeout
082346f8 g     F .text	000001b8 sbdrop
08253e04 g     O .bss	00000004 net_system_exit
0825e678 g     O .bss	00000068 icmp_mib
0820dfa4 g     F .text	0000123c ___svfiprintf_internal_r
08239ae0 g     F .text	00000074 tcp_getseq
08243de4 g     F .text	000000b8 ip_raw_alloc
08223640 g     F .text	000004b8 alt_tse_phy_set_common_speed
08217970 g     F .text	00000060 OSFlagPendGetFlagsRdy
08253b56 g     O .rwdata	00000002 OSTaskStatStkSize
0825d854 g     O .bss	00000010 pmac_groups
0822a854 g     F .text	00000a84 dhc_request
082325b0 g     F .text	0000074c soreceive
08216aec g     F .text	00000308 OSFlagAccept
08218ec0 g     F .text	000000b8 OSQFlush
08218954 g     F .text	00000140 OSQAccept
08253c6c g     O .bss	00000004 alt_argv
0825bad8 g       *ABS*	00000000 _gp
0824292c g     F .text	00000050 ip_reasm_send_icmp_timex
0823c770 g     F .text	00000138 usleep
08248b68 g     F .text	00000048 vfflush
0825e184 g     O .bss	00000040 resid_semaphore
082285fc g     F .text	00000144 hexdump
08240f68 g     F .text	000000a0 ip_reasm_incr_mem_useage
08227220 g     F .text	00000080 igmp_leavegroup
0821a9a8 g     F .text	000001ac OSTaskCreate
0821a4b8 g     F .text	000004f0 OSTaskChangePrio
08253c80 g     O .bss	00000004 alt_heapsem
0823992c g     F .text	000000f0 tcp_close
0821695c g     F .text	00000190 OSDebugInit
0821ad38 g     F .text	00000344 OSTaskDel
08249c3c g     F .text	0000005c vferror
0823c718 g     F .text	00000058 alt_uncached_malloc
0821ef00 g     F .text	00000060 tse_mac_initTransInfo2
08245134 g     F .text	000000bc udp_alloc
082537c8 g     O .rwdata	00000180 alt_fd_list
0825a550 g     O .bss	00000370 OSFlagTbl
08253d90 g     O .bss	00000008 mbstat
08202b64 g     F .text	00000070 _getc_r
08202bd4 g     F .text	00000088 getc
08203290 g     F .text	00000008 _putchar_r
08215c1c g     F .text	000000b8 OS_EventTaskRemove
08245940 g     F .text	00000144 igmpv2_chk_set_timer
082291dc g     F .text	00000030 TK_OSTimeDly
0823bc9c g     F .text	00000090 alt_find_dev
08202c5c g     F .text	00000148 memcpy
0821f174 g     F .text	00000054 tse_mac_setMIImode
08253d40 g     O .bss	00000004 dsc_rebind
0823d590 g     F .text	0000007c task_stats
0823012c g     F .text	00000050 DOMAIN_CHECK
0822f2d0 g     F .text	00000038 in_broadcast
08253b40 g     O .rwdata	00000002 OSRdyTblSize
08220e14 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
08253e28 g     O .bss	00000004 vfsystems
08245084 g     F .text	000000b0 udp_socket
08253ce0 g     O .bss	00000004 MaxMtu
08234c10 g     F .text	00000140 sock_selscan
0820a83c g     F .text	0000000c _cleanup_r
08213f34 g     F .text	000000dc .hidden __floatsidf
08240d40 g     F .text	000000c4 ip_reasm_match_frag_with_ire
08233e90 g     F .text	00000058 socantrcvmore
0821ef60 g     F .text	000000e4 tse_mac_sTxWrite
08201da0 g     F .text	00000720 sss_exec_command
082030a8 g     F .text	00000014 perror
0823c090 g     F .text	0000007c alt_io_redirect
08212dac g     F .text	000000f4 .hidden __ltdf2
08253d6c g     O .bss	00000004 netq_intmask
082475c0 g     F .text	0000004c hextoa
0824bc20 g       *ABS*	00000000 __DTOR_END__
082312bc g     F .text	00000204 t_send
0823b988 g     F .text	000000d0 alt_close
08253d98 g     O .bss	00000002 select_wait
08203370 g     F .text	00000014 puts
08228d1c g     F .text	00000044 std_out
0825d874 g     O .bss	00000030 tse_iniche_dev_driver_data
08249864 g     F .text	00000124 vfslookup_locked
08231e70 g     F .text	00000098 soaccept
08214930 g     F .text	00000120 OSEventNameGet
08253b24 g     O .rwdata	00000002 OSFlagMax
08203634 g     F .text	0000065c _strerror_r
0825e1f0 g     O .bss	0000003c tcpmib
082316e8 g     F .text	00000098 t_errno
08243a2c g     F .text	000000d8 ip_raw_open
0820daf4 g     F .text	00000074 __fpclassifyd
0822b638 g     F .text	00000108 dhc_decline
0820d184 g     F .text	000000a4 __ratio
08215244 g     F .text	000000f8 OSIntExit
08253c1c g     O .rwdata	00000004 ipRoutes
08248c80 g     F .text	00000050 vfeof
08210750 g     F .text	0000001c __vfiprintf_internal
08239dc4 g     F .text	00000060 tcp_canceltimers
0822a0c0 g     F .text	000001e4 dhc_buildheader
08253b5e g     O .rwdata	00000002 OSTCBSize
0821e508 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
08253c8d g     O .bss	00000001 OSPrioCur
0821cb68 g     F .text	000002bc altera_avalon_jtag_uart_read
0824b3dc g     F .text	00000014 malloc
08253e24 g     O .bss	00000004 inpcb_cachemiss
082030bc g     F .text	00000030 _printf_r
08247780 g     F .text	000000c4 inet46_addr
08253e20 g     O .bss	00000004 inpcb_cachehits
0820295c g     F .text	00000064 .hidden __udivsi3
08253788 g     O .rwdata	0000000b tcp_outflags
0825d8a4 g     O .bss	00000130 tse
08214300 g     F .text	000000a4 isatty
0821fdf8 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
08253b44 g     O .rwdata	00000002 OSStkWidth
0824d860 g     O .rodata	000000c8 __mprec_tens
08248458 g     F .text	00000070 vf_alloc_and_link_vop
08253b38 g     O .rwdata	00000002 OSPtrSize
08253df4 g     O .bss	00000004 ipr_curr_mem
08226874 g     F .text	00000070 exit_hook
08253cf4 g     O .bss	00000004 igmp_cticks
082200c8 g     F .text	00000080 alt_tse_get_mac_info_index
08253d80 g     O .bss	00000004 mheap_sem_ptr
08237f0c g     F .text	00000048 ip4_tcpmss
0820b81c g     F .text	0000000c __locale_charset
08253b18 g     O .rwdata	00000002 OSEventTblSize
0825e5ec g     O .bss	00000014 netlist
08232cfc g     F .text	00000098 soshutdown
0823ca00 g       .text	00000000 OSCtxSw
0823d090 g     F .text	00000050 packet_check
0822b2d8 g     F .text	0000027c dhc_setip
0825e22c g     O .bss	00000014 mbufq
08231e20 g     F .text	00000050 soabort
08253c60 g     O .bss	00000004 __malloc_top_pad
08253c90 g     O .bss	00000004 OSTCBList
0822cd78 g     F .text	00000100 qdel
0823ceec g     F .text	00000164 station_state
08243f28 g     F .text	00000154 rt_lookup
08253db0 g     O .bss	00000004 alt_fd_list_lock
08253ae4 g     O .rwdata	00000004 __mb_cur_max
082272a0 g     F .text	00000318 igmp_validate
0820b84c g     F .text	0000000c _localeconv_r
082265d0 g     F .text	000002a4 ip_startup
08230438 g     F .text	00000254 t_accept
08233928 g     F .text	00000098 soisdisconnecting
0820c7b0 g     F .text	0000003c __i2b
0820b15c g     F .text	000004bc __sfvwrite_r
0821e640 g     F .text	0000005c alt_avalon_sgdma_stop
08226010 g     F .text	000003a4 pktdemux
0825a8c0 g     O .bss	00000c30 OSMemTbl
08253c94 g     O .bss	00000001 OSTickStepState
08220eb4 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0822d314 g     F .text	00000094 kbhit
08230b5c g     F .text	000001c0 t_setsockopt
0820db68 g     F .text	00000054 _sbrk_r
08253948 g     O .rwdata	00000018 icmpdu_types
08221554 g     F .text	000006a4 alt_tse_mac_group_init
08248d2c g     F .text	00000200 vunlink
08224250 g     F .text	00000a60 tse_mac_init
08253b3c g     O .rwdata	00000002 OSQMax
0822845c g     F .text	000000a4 ccksum
082484c8 g     F .text	000000c8 vf_alloc_buffer
08253e18 g     O .bss	00000004 cachedRoute
08253bb0 g     O .rwdata	00000004 lilbufs
0825b4f0 g     O .bss	00000800 OSTaskStatStk
08247154 g     F .text	00000024 md_ftell
08228500 g     F .text	00000054 cksum
082184c4 g     F .text	000000f0 OSMemNameGet
08231a54 g     F .text	00000110 sofree
08253ce8 g     O .bss	00000004 ifNumber
08253b1c g     O .rwdata	00000002 OSFlagEn
08210dbc g     F .text	00000060 _read_r
08253b62 g     O .rwdata	00000002 OSTimeTickHookEn
0823ba58 g     F .text	00000078 alt_dcache_flush
08219370 g     F .text	00000168 OSQPost
0821815c g     F .text	000000a4 OS_FlagUnlink
08253bf0 g     O .rwdata	00000004 alt_max_fd
08216208 g     F .text	00000068 OS_MemCopy
08253bb8 g     O .rwdata	00000004 bigbufs
0823aa90 g     F .text	000000cc tcp_disconnect
08216270 g     F .text	000000d0 OS_Sched
082109a0 g     F .text	000000f0 _fclose_r
082183d4 g     F .text	000000f0 OSMemGet
0821b364 g     F .text	000001b4 OSTaskNameSet
0820a804 g     F .text	00000030 fflush
08253c5c g     O .bss	00000004 __malloc_max_sbrked_mem
08253c98 g     O .bss	00000004 OSCtxSwCtr
0825dcf8 g     O .bss	00000064 igmpstats
0823ccb4 g     F .text	0000002c OSTimeTickHook
0822a770 g     F .text	000000e4 dhc_rx_offer
08227e7c g     F .text	0000010c bsd_getsockopt
08253b26 g     O .rwdata	00000002 OSFlagNameSize
0825e650 g     O .bss	00000018 ire_stats
08200ef0 g     F .text	000001d4 LEDManagementTask
0823acc8 g     F .text	000001a0 udp_soinput
0822ccc8 g     F .text	000000b0 putq
08215cd4 g     F .text	00000100 OS_EventTaskRemoveMulti
08253d08 g     O .bss	00000004 iniche_net_ready
08211ab4 g     F .text	000008ac .hidden __adddf3
08215acc g     F .text	00000150 OS_EventTaskWaitMulti
08249bf4 g     F .text	00000048 isvfile
08232e90 g     F .text	00000430 sosetopt
0822903c g     F .text	000000e0 netmain
08237f54 g     F .text	000000f8 tcp_mss
0820cf2c g     F .text	0000010c __b2d
08247264 g     F .text	000002fc parse_ipad
08248438 g     F .text	00000020 get_vfopen_error
08253b3e g     O .rwdata	00000002 OSQSize
0821157c g     F .text	00000538 .hidden __umoddi3
082143e0 g     F .text	000000d4 lseek
0823d158 g     F .text	0000008c inet_timer
08219e20 g     F .text	0000020c OSSemPend
082210a8 g     F .text	0000029c alt_tse_phy_add_profile_default
082227c0 g     F .text	00000598 alt_tse_phy_get_cap
08201abc g     F .text	0000021c sss_send_menu
08253adc g     O .rwdata	00000004 _global_impure_ptr
082289dc g     F .text	00000154 print_eth
08248918 g     F .text	00000050 vfopen
0823c39c g     F .text	000000fc alt_read
0820d3a0 g     F .text	00000564 _realloc_r
082007ac g     F .text	00000264 alt_NetworkErrorHandler
08253b28 g     O .rwdata	00000002 OSLowestPrio
0825e6e0 g       *ABS*	00000000 __bss_end
0823bedc g     F .text	000000f0 alt_iic_isr_register
0821e084 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0822e27c g     F .text	00000108 m_free
0823cd40 g     F .text	00000024 OSTCBInitHook
08225440 g     F .text	00000040 tse_mac_stats
0822c7fc g     F .text	0000028c pk_validate
08253b6e g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0823c5cc g     F .text	00000108 alt_tick
082481b8 g     F .text	00000254 in_pcblookup
0822c3dc g     F .text	000000c0 find_opt
08211004 g     F .text	00000578 .hidden __udivdi3
0822e0f4 g     F .text	00000188 m_getnbuf
0822cb54 g     F .text	000000bc dump_buf_estats
08210c08 g     F .text	00000024 _fputwc_r
08222660 g     F .text	00000160 alt_tse_phy_check_link
08253dec g     O .bss	00000004 arpRepsOut
08253b10 g     O .rwdata	00000002 OSEventEn
0824d838 g     O .rodata	00000028 __mprec_bigtens
0820c594 g     F .text	00000104 __s2b
08253b6a g     O .rwdata	00000002 OSTmrCfgNameSize
08214010 g     F .text	000000a8 .hidden __floatunsidf
0823cd64 g     F .text	000000f4 netmain_init
08223c74 g     F .text	000000e4 marvell_cfg_sgmii
082224a4 g     F .text	000001bc alt_tse_phy_restart_an
0820cc6c g     F .text	00000060 __mcmp
08253d24 g     O .bss	00000004 dsc_requests
08239374 g     F .text	00000400 tcp_respond
0823b0a4 g     F .text	000002d4 udp4_sockbind
08253d70 g     O .bss	00000004 old_mode
08226fcc g     F .text	00000254 igmp_joingroup
0822f3fc g     F .text	00000348 so_icmpdu
0820aba4 g     F .text	00000018 __fp_lock_all
08253e38 g     O .bss	00000004 vfs_dir_stale
0823be90 g     F .text	0000004c alt_ic_irq_enabled
0825d864 g     O .bss	00000010 pphy_profiles
08242218 g     F .text	000000d8 ip_reasm_process_timer_tick
08249c98 g     F .text	00000058 vclearerr
0822837c g     F .text	000000e0 bsd_setsockopt
0822e87c g     F .text	00000054 mbuf_len
08217f88 g     F .text	000000e0 OS_FlagInit
0823c530 g     F .text	0000009c alt_alarm_stop
082499d0 g     F .text	000001cc strippath
08253ba8 g     O .rwdata	00000004 reqlist
08229280 g     F .text	00000174 tcp_sleep
0824b888 g     F .text	0000001c strtol
08229910 g     F .text	000007b0 dhc_upcall
0823ab5c g     F .text	000000d0 tcp_usrclosed
08000000 g       *ABS*	00000000 __alt_mem_descriptor_memory
08253d5c g     O .bss	00000004 cticks_factor
08253b4c g     O .rwdata	00000002 OSTaskIdleStkSize
08247c64 g     F .text	00000210 in_pcbbind
08253db4 g     O .bss	00000004 alt_irq_active
08219a58 g     F .text	000000b0 OSSemAccept
082186c8 g     F .text	000000d8 OSMemPut
08218200 g     F .text	000001d4 OSMemCreate
08253c9c g     O .bss	00000004 OSIdleCtrMax
0820012c g     F .exceptions	000000d4 alt_irq_handler
082537a0 g     O .rwdata	00000028 alt_dev_null
08253bca g     O .rwdata	00000001 tcprexmtthresh
08253b60 g     O .rwdata	00000002 OSTicksPerSec
0823ec68 g     F .text	00000094 if_killsocks
0823f698 g     F .text	00000220 ip_write
08242cfc g     F .text	000005cc ip_rcv_phase2
0823093c g     F .text	00000044 t_getsockname
0823068c g     F .text	0000026c t_connect
08253bc4 g     O .rwdata	00000004 TCPTV_MSL
0825de84 g     O .bss	00000010 memestats
0822238c g     F .text	00000118 alt_tse_phy_init
0822d3a8 g     F .text	0000005c getch
08253a40 g     O .rwdata	00000080 vfs_root_path
082308f8 g     F .text	00000044 t_getpeername
0821e69c g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
08241008 g     F .text	00000098 ip_reasm_decr_mem_useage
0823401c g     F .text	00000088 soreserve
0823ca00 g       .text	00000000 OSIntCtxSw
0822deb8 g     F .text	00000034 npalloc
0820c698 g     F .text	00000068 __hi0bits
08253e14 g     O .bss	00000004 ipraw_eps
0822c49c g     F .text	0000029c pk_init
08246f54 g     F .text	0000015c md_fread
08224cb0 g     F .text	000002f8 tse_mac_raw_send
08213eb4 g     F .text	00000080 .hidden __fixdfsi
0825e488 g     O .bss	00000064 intimers
082340f4 g     F .text	0000004c sbrelease
08235078 g     F .text	000000f0 ifd_clr
082349b0 g     F .text	00000090 sbdroprecord
08228b30 g     F .text	0000007c uslash
0823c8e4 g     F .text	000000f8 alt_write
08253de8 g     O .bss	00000004 arpRepsIn
08229790 g     F .text	00000088 dhc_get_srv_ipaddr
0823d370 g     F .text	00000160 in_timerset
08253ca0 g     O .bss	00000004 OSTCBFreeList
0821a02c g     F .text	0000016c OSSemPendAbort
0823804c g     F .text	00001004 tcp_output
08253dc0 g     O .bss	00000004 activehost
08253be8 g     O .rwdata	00000008 alt_dev_list
08228e38 g     F .text	00000204 parse_args
08253d74 g     O .bss	00000004 global_TCPwakeup_setIndx
0820abd4 g     F .text	00000044 _fputc_r
08225784 g     F .text	00000068 write
0821e7e0 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0822deec g     F .text	00000040 npfree
08203128 g     F .text	000000a0 _putc_r
0823e02c g     F .text	000002c0 arpReply
08228580 g     F .text	0000007c nextarg
08253b64 g     O .rwdata	00000002 OSVersionNbr
08241944 g     F .text	00000530 ip_reasm_process_subsequent_fragments
08253c28 g     O .rwdata	00000004 pton_error
08253d18 g     O .bss	00000004 dsc_errors
082544d8 g     O .bss	00002000 SSSInitialTaskStk
0825d9d4 g     O .bss	00000014 rcvdq
08234ff8 g     F .text	00000080 tcp_notify
08214214 g     F .text	000000b0 fstat
08202a40 g     F .text	00000024 fprintf
08231f08 g     F .text	000000b8 soconnect
08243ee0 g     F .text	00000048 ip_raw_maxalloc
08212dac g     F .text	000000f4 .hidden __ledf2
08223e48 g     F .text	00000078 DP83848C_link_status_read
0822a2a4 g     F .text	000004cc dhc_discover
082018d8 g     F .text	000000a4 SSSCreateOSDataStructs
08248134 g     F .text	00000084 in_setpeeraddr
08253b0c g     O .rwdata	00000004 OSEndiannessTest
0822d404 g     F .text	00000038 clock_init
08248bb0 g     F .text	000000d0 vfgets
0823d6f4 g     F .text	00000180 et_send
0820c9e4 g     F .text	00000140 __pow5mult
0820f2f4 g     F .text	0000145c ___vfiprintf_internal_r
08253c54 g     O .bss	00000004 __nlocale_changed
082029c0 g     F .text	00000058 .hidden __umodsi3
08247560 g     F .text	00000060 inet_addr
08240ed4 g     F .text	00000094 ip_reasm_check_mem_useage
08232d94 g     F .text	000000fc sorflush
0824b8a4 g     F .text	0000001c vprintf
0825df98 g     O .bss	000000fc global_tcb_ext
0823fd04 g     F .text	00000420 ip_fragment_lc
0825d9e8 g     O .bss	00000300 netstatic
082301fc g     F .text	00000164 t_bind
0821e488 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
08253b1e g     O .rwdata	00000002 OSFlagGrpSize
0822d074 g     F .text	000000d8 udp_close
0821e594 g     F .text	00000054 alt_avalon_sgdma_register_callback
0822da2c g     F .text	000001fc alt_iniche_init
0825e6e0 g       *ABS*	00000000 end
0822d620 g     F .text	00000088 UNLOCK_NET_RESOURCE
08223ff8 g     F .text	00000258 prep_tse_mac
08230ea8 g     F .text	000000e0 t_recv
0821d8ac g     F .text	00000510 altera_avalon_lcd_16207_write
08248f2c g     F .text	0000018c vfread
08225f2c g     F .text	000000e4 netclose
082026b0 g     F .text	000001b4 SSSSimpleSocketServerTask
0824b398 g     F .text	0000000c _atoi_r
0821f218 g     F .text	000001e4 alt_tse_phy_add_profile
08253bd4 g     O .rwdata	00000004 tcp_keepintvl
0821c520 g     F .text	00000148 altera_avalon_jtag_uart_init
082164d8 g     F .text	000000e4 OS_TaskStat
08253d1c g     O .bss	00000004 dsc_discovers
08253b7c g     O .rwdata	00000004 tse_mac_name
08253740 g     O .rwdata	00000018 tcp_protosw
0824bc20 g       *ABS*	00000000 __CTOR_LIST__
08253e34 g     O .bss	00000004 vfopen_error
08380000 g       *ABS*	00000000 __alt_stack_pointer
08253da8 g     O .bss	00000004 tcp_maxidle
08253d48 g     O .bss	00000004 firstudp
0821e860 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0821ee54 g     F .text	0000007c alt_avalon_timer_sc_init
082140b8 g     F .text	00000064 .hidden __clzsi2
0821ce24 g     F .text	000002c4 altera_avalon_jtag_uart_write
0821e2b8 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0820ab94 g     F .text	00000004 __sfp_lock_acquire
0820c244 g     F .text	000000e4 memchr
082161b4 g     F .text	00000054 OS_MemClr
08206788 g     F .text	000021f8 ___vfprintf_internal_r
0823cad0 g     F .text	0000015c OSTaskStkInit
0820340c g     F .text	00000058 _sprintf_r
0821e3b0 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0820ae4c g     F .text	00000310 _free_r
08245a84 g     F .text	00000140 igmpv2_chk4_rtr_alert_opt
0820b828 g     F .text	00000010 __locale_mb_cur_max
08231598 g     F .text	000000c4 t_socketclose
082564d8 g     O .bss	00002000 LED7SegLightshowTaskStk
08215824 g     F .text	00000198 OS_EventTaskRdy
0824ba54 g     F .text	00000180 __call_exitprocs
08203384 g     F .text	00000074 __srget_r
08224fa8 g     F .text	000000ac tse_sgdmaRx_isr
08253ca4 g     O .bss	00000001 OSCPUUsage
0825dce8 g     O .bss	00000010 nets
0822d55c g     F .text	000000c4 LOCK_NET_RESOURCE
0822b554 g     F .text	000000e4 dhc_resetip
08253c50 g     O .bss	00000004 __mlocale_changed
08225200 g     F .text	00000240 tse_mac_rcv
0823017c g     F .text	00000080 t_socket
08253ae8 g     O .rwdata	00000004 __malloc_sbrk_base
08200200 g     F .text	00000048 _start
0823d6ac g     F .text	00000048 etainit
08253db8 g     O .bss	00000004 _alt_tick_rate
0823d0e0 g     F .text	00000024 mcastlist
08218f78 g     F .text	0000028c OSQPend
082041f8 g     F .text	000003b0 strstr
0825de94 g     O .bss	000000f0 pktlog
08245620 g     F .text	00000134 igmpv2_process_report
082351e0 g     F .text	00000078 ifd_isset
0824443c g     F .text	00000114 del_route
0821e700 g     F .text	00000054 alt_avalon_sgdma_open
08206780 g     F .text	00000008 _user_strerror
0821bc24 g     F .text	00000104 OSTimeDly
082010c4 g     F .text	00000054 get_mac_addr
08231984 g     F .text	000000d0 solisten
0820cb24 g     F .text	00000148 __lshift
08253dbc g     O .bss	00000004 _alt_nticks
08220fdc g     F .text	000000cc alt_tse_phy_rd_mdio_reg
08225714 g     F .text	00000070 read
0821c184 g     F .text	00000238 alt_sys_init
08239a1c g     F .text	0000004c tcp_quench
0820ddd4 g     F .text	000001d0 __ssprint_r
08228bac g     F .text	00000170 ns_printf
0823eb04 g     F .text	000000d4 isbcast
0822d6a8 g     F .text	0000024c TK_NEWTASK
0824b93c g     F .text	00000118 __register_exitproc
08253ca5 g     O .bss	00000001 OSTaskCtr
08240e04 g     F .text	000000d0 ip_reasm_determine_type_of_frag
08253cd4 g     O .bss	00000001 phy_profile_count
0824b494 g     F .text	000000d0 strncmp
08220054 g     F .text	00000074 alt_tse_get_mac_group_index
0821bd28 g     F .text	00000160 OSTimeDlyHMSM
08243b04 g     F .text	000000bc ip_raw_close
0820c7ec g     F .text	000001f8 __multiply
08253990 g     O .rwdata	000000b0 mdlist
0821ca10 g     F .text	00000068 altera_avalon_jtag_uart_close
08226adc g     F .text	000000e0 igmp_input
0823fc3c g     F .text	000000c8 ip_raw_write
082490b8 g     F .text	000003b0 vfwrite_locked
0824b564 g     F .text	000000ec strncpy
08253d20 g     O .bss	00000004 dsc_offers
0825443c g     O .bss	00000028 __malloc_current_mallinfo
08253b12 g     O .rwdata	00000002 OSEventMax
08247844 g     F .text	0000006c inet_setport
0820d038 g     F .text	0000014c __d2b
0821a198 g     F .text	00000110 OSSemPost
082379fc g     F .text	00000188 tcp_dooptions
08253c48 g     O .bss	00000004 SSSLEDEventFlag
08233824 g     F .text	00000104 soisconnected
082153c8 g     F .text	000000dc OSSchedUnlock
082439d8 g     F .text	00000028 netexit
08201174 g     F .text	000001bc get_serial_number
08253d04 g     O .bss	00000004 nettick_wakes
08220e5c g     F .text	00000058 alt_tse_phy_wr_mdio_addr
08253d9c g     O .bss	00000001 tcpprintfs
0823d4d0 g     F .text	0000009c in_timerkill
082454fc g     F .text	00000124 igmpv2_input
08253d30 g     O .bss	00000004 dsc_declines
0821c3bc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
08228554 g     F .text	0000002c do_trap
0824a0d0 g     F .text	000000dc alt_get_fd
08227f88 g     F .text	000000f4 bsd_ioctl
08253ca8 g     O .bss	00000004 OSMemFreeList
08215514 g     F .text	000000b0 OSStatInit
0822eb50 g     F .text	000001d0 tcp_rcv
08228994 g     F .text	00000048 panic
08253e3c g     O .bss	00000004 vfs_open_files
08249d14 g     F .text	00000158 alt_busy_sleep
08226444 g     F .text	0000018c ip2mac
08217d64 g     F .text	000000c4 OSFlagQuery
08234d50 g     F .text	000001e4 sock_select
08246b38 g     F .text	00000264 dhc_setup
08239218 g     F .text	00000054 tcp_init
08253d78 g     O .bss	00000004 cticks
08253d0d g     O .bss	00000001 to_nettick
08253b48 g     O .rwdata	00000002 OSTaskCreateExtEn
08210888 g     F .text	00000054 _close_r
082257ec g     F .text	000005e8 Netinit
0822dc94 g     F .text	00000038 prep_armintcp
0824369c g     F .text	0000014c in_addmulti
0823926c g     F .text	00000108 tcp_template
08223318 g     F .text	00000328 alt_tse_phy_get_common_speed
0822e96c g     F .text	00000070 remque
0824b8c0 g     F .text	00000010 _vprintf_r
082352bc g     F .text	00000410 tcp_reass
082479e4 g     F .text	000001a0 tcp_cksum
0823b378 g     F .text	00000380 udp4_socksend
08248968 g     F .text	000001bc vfclose_locked
08235168 g     F .text	00000078 ifd_set
0820c328 g     F .text	0000007c memcmp
08215804 g     F .text	00000020 OS_Dummy
0821c47c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0822c32c g     F .text	000000b0 dhc_set_state
08253ce4 g     O .bss	00000004 NDEBUG
0825e6e0 g       *ABS*	00000000 __alt_stack_base
08253c38 g     O .bss	00000004 last_flash_sector
0821c4cc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
082340a4 g     F .text	00000050 sbreserve
08253cd5 g     O .bss	00000001 mac_group_count
08243bc0 g     F .text	00000224 ip_raw_input
08202a64 g     F .text	000000cc _fwrite_r
08253bb4 g     O .rwdata	00000004 lilbufsiz
08235258 g     F .text	00000064 ifd_get
08233f90 g     F .text	0000008c sbwakeup
08208bb0 g     F .text	00000154 __swsetup_r
08223ec0 g     F .text	00000138 altera_eth_tse_init
0825bcf0 g     O .bss	000001e0 OSQTbl
08237cb0 g     F .text	0000025c tcp_xmit_timer
08225054 g     F .text	000001ac tse_sgdma_read_init
08212360 g     F .text	000008e8 .hidden __divdf3
0820aa54 g     F .text	00000118 __sfp
082014d8 g     F .text	0000013c generate_mac_addr
0823ede4 g     F .text	00000190 ip_bldhead
0820d29c g     F .text	00000078 __copybits
08234140 g     F .text	000000a0 sbappend
08252118 g     O .rwdata	00000408 __malloc_av_
0820aba0 g     F .text	00000004 __sinit_lock_release
08253cac g     O .bss	00000004 OSTCBHighRdy
08212ea0 g     F .text	00000718 .hidden __muldf3
0823f8b8 g     F .text	00000384 ip_write2
0820dbbc g     F .text	00000054 __sread
08253c14 g     O .rwdata	00000004 arp_ageout
08253cb0 g     O .bss	00000004 OSQFreeList
08221bf8 g     F .text	00000424 alt_tse_mac_get_phy
0823ecfc g     F .text	000000e8 ip_init
08249fc8 g     F .text	00000108 alt_find_file
08243e9c g     F .text	00000044 ip_raw_free
0823df30 g     F .text	000000fc make_arp_entry
0823bb38 g     F .text	000000a4 alt_dev_llist_insert
08214744 g     F .text	00000120 __malloc_lock
08202a18 g     F .text	00000028 _fprintf_r
08214570 g     F .text	000000b0 sbrk
0823ac6c g     F .text	0000005c udp_lookup
082045a8 g     F .text	000021d8 ___svfprintf_internal_r
0821e5e8 g     F .text	00000058 alt_avalon_sgdma_start
08214a50 g     F .text	00000140 OSEventNameSet
0820a7a8 g     F .text	0000005c _fflush_r
08220300 g     F .text	0000008c alt_tse_mac_set_duplex
082108dc g     F .text	000000c4 _calloc_r
0822ddd8 g     F .text	000000e0 npfree_base
08253cb4 g     O .bss	00000001 OSRdyGrp
08246f08 g     F .text	00000028 md_fopen
08253758 g     O .rwdata	00000018 udp_protosw
08253af4 g     O .rwdata	00000008 alt_flash_dev_list
082480b0 g     F .text	00000084 in_setsockaddr
08253c30 g       *ABS*	00000000 __bss_start
08200e7c g     F .text	00000074 LED7SegLightshowTask
082341e0 g     F .text	000000d8 sbappendrecord
0825e600 g     O .bss	00000050 ip_mib
08202f00 g     F .text	00000128 memset
08231fc0 g     F .text	00000098 sodisconnect
08200d18 g     F .text	00000080 main
08253c70 g     O .bss	00000004 alt_envp
08253c58 g     O .bss	00000004 __malloc_max_total_mem
08201a4c g     F .text	00000070 sss_reset_connection
0822e6bc g     F .text	000001c0 m_adj
0821c41c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08208b98 g     F .text	00000018 __swbuf
08247178 g     F .text	000000c8 md_fgetc
0824da7c g     O .rodata	00000100 OSUnMapTbl
0824078c g     F .text	000002a8 ip_dump
08229588 g     F .text	00000208 tk_stats
08253b90 g     O .rwdata	00000008 alt_iniche_dev_list
082584d8 g     O .bss	00000078 SSSLEDCommandQTbl
0821de68 g     F .text	00000180 altera_avalon_lcd_16207_init
08253b84 g     O .rwdata	00000008 alt_sgdma_list
08253b42 g     O .rwdata	00000002 OSSemEn
08253d60 g     O .bss	00000004 OS_TPS
0822f9e0 g     F .text	0000074c rawip_usrreq
082179d0 g     F .text	00000394 OSFlagPost
0820dcf0 g     F .text	00000008 __sclose
08247724 g     F .text	0000005c print46_addr
08380000 g       *ABS*	00000000 __alt_heap_limit
08210a90 g     F .text	00000014 fclose
082159bc g     F .text	00000110 OS_EventTaskWait
0824b650 g     F .text	00000238 _strtol_r
082287bc g     F .text	000001d8 print_uptime
082165bc g     F .text	000000cc OS_TaskStatStkChk
0821b07c g     F .text	00000150 OSTaskDelReq
08208f04 g     F .text	00001688 _dtoa_r
0820ba38 g     F .text	0000080c _malloc_r
08247240 g     F .text	00000024 md_unlink
0821f0ec g     F .text	00000088 tse_mac_SwReset
08210f78 g     F .text	00000030 __ascii_wctomb
08247c0c g     F .text	00000058 in_pcbdetach
08253bf4 g     O .rwdata	00000004 alt_errno
08253c24 g     O .rwdata	00000004 mdlist_size
082154a4 g     F .text	00000070 OSStart
08246450 g     F .text	00000034 u_mctest_init
082146e4 g     F .text	00000060 __env_unlock
0820b618 g     F .text	000000c4 _fwalk
0821b518 g     F .text	000001d4 OSTaskResume
082187a0 g     F .text	000000e8 OSMemQuery
082478b0 g     F .text	00000134 convert_ip
0823ddc4 g     F .text	0000016c find_oldest_arp
08253b54 g     O .rwdata	00000002 OSTaskStatEn
08253de0 g     O .bss	00000004 arpReqsIn
08248590 g     F .text	00000050 vf_free_buffer
08249ea8 g     F .text	00000120 alt_fcntl
08253b2e g     O .rwdata	00000002 OSMemMax
082194d8 g     F .text	00000170 OSQPostFront
0822d2e0 g     F .text	00000034 dtrap
08253bc0 g     O .rwdata	00000004 kb_last
082031c8 g     F .text	000000c8 putc
08202864 g     F .text	00000084 .hidden __divsi3
0821ffa0 g     F .text	00000048 alt_tse_mac_set_common_speed
08253cb5 g     O .bss	00000003 OSRdyTbl
08253b08 g     O .rwdata	00000002 OSDebugEn
0822dccc g     F .text	0000010c npalloc_base
082268e4 g     F .text	000000d0 ip_exit
0820ad28 g     F .text	00000124 _malloc_trim_r
0824bc20 g       *ABS*	00000000 __CTOR_END__
08253b20 g     O .rwdata	00000002 OSFlagNodeSize
08253d14 g     O .bss	00000004 dhc_conn
0822d45c g     F .text	0000005c cticks_hook
08253b68 g     O .rwdata	00000002 OSTmrCfgMax
0823d050 g     F .text	00000040 sysuptime
0820dcf8 g     F .text	000000dc strcmp
08201330 g     F .text	000001a8 generate_and_store_mac_addr
082422f0 g     F .text	000001b4 ip_reasm_delete_ire
08218a94 g     F .text	000001ac OSQCreate
0822d4b8 g     F .text	00000060 irq_Mask
0821b1cc g     F .text	00000198 OSTaskNameGet
08253dc8 g     O .bss	00000004 nextppp
08253d50 g     O .bss	00000004 irq_level
08225dd4 g     F .text	00000158 fixup_subnet_mask
08219648 g     F .text	0000020c OSQPostOpt
082155c4 g     F .text	00000220 OSTimeTick
08240c0c g     F .text	00000134 ip_copypkt
0822c23c g     F .text	00000088 dhc_alldone
08253b50 g     O .rwdata	00000002 OSTaskMax
0824bc20 g       *ABS*	00000000 __DTOR_LIST__
08219b08 g     F .text	000000d8 OSSemCreate
08253cf8 g     O .bss	00000004 igmp_all_hosts_group
08253b74 g     O .rwdata	00000002 OSTmrWheelSize
08233ee8 g     F .text	0000003c sbselqueue
08253d00 g     O .bss	00000004 netmain_wakes
0823e2ec g     F .text	00000264 arprcv
0822920c g     F .text	00000074 TK_OSTaskResume
082275b8 g     F .text	0000041c igmp_print_stats
08212c48 g     F .text	00000088 .hidden __nedf2
0822dfa0 g     F .text	00000090 pffindtype
08253b4a g     O .rwdata	00000002 OSTaskDelEn
08253bd8 g     O .rwdata	00000004 tcp_sendspace
08249614 g     F .text	00000110 vftell
0825dd5c g     O .bss	00000012 eth_prt_buf
0821a2a8 g     F .text	00000110 OSSemQuery
08218c40 g     F .text	00000280 OSQDel
08219204 g     F .text	0000016c OSQPendAbort
0821c14c g     F .text	00000038 alt_irq_init
0821ff60 g     F .text	00000040 alt_tse_mac_get_common_speed
0825e1c4 g     O .bss	00000018 app_semaphore
0823c498 g     F .text	00000064 alt_release_fd
0822d9b0 g     F .text	0000007c post_app_sem
08226a38 g     F .text	000000a4 igmp_init
08203464 g     F .text	0000006c sprintf
0824d968 g     O .rodata	00000100 .hidden __clz_tab
08253d3c g     O .bss	00000004 dsc_renew
082470b0 g     F .text	00000078 md_fwrite
08253c4c g     O .bss	00000004 _PathLocale
08253d64 g     O .bss	00000004 tcp_sleep_count
0822e9dc g     F .text	0000007c insque
0824b378 g     F .text	00000014 atexit
08253e30 g     O .bss	00000004 vfsfiles
08210828 g     F .text	00000060 _write_r
0824b8d0 g     F .text	00000050 _vsprintf_r
08244cf8 g     F .text	00000298 udp_send
0821533c g     F .text	0000008c OSSchedLock
08226d30 g     F .text	0000029c igmp_send
0820b858 g     F .text	00000018 setlocale
08216df4 g     F .text	00000108 OSFlagCreate
08258550 g     O .bss	00002000 LEDManagementTaskStk
0822d518 g     F .text	00000044 irq_Unmask
08230360 g     F .text	000000d8 t_listen
08253ae0 g     O .rwdata	00000004 _impure_ptr
08251b44 g     O .rwdata	00000018 ssstask
08253c68 g     O .bss	00000004 alt_argc
0823a2a4 g     F .text	000006d4 tcp_usrreq
0823ae68 g     F .text	0000023c udp_usrreq
0822df2c g     F .text	00000034 ncpalloc
0820a58c g     F .text	0000021c __sflush_r
0823bc3c g     F .text	00000060 _do_dtors
0820b844 g     F .text	00000008 __locale_cjk_lang
08253b1a g     O .rwdata	00000002 OSEventMultiEn
08253c0c g     O .rwdata	00000004 pingdelay
0823d8fc g     F .text	00000074 arp_send_pending
0825d774 g     O .bss	000000e0 tse_mac_if
08245258 g     F .text	000002a4 igmpv1_input
0820d920 g     F .text	000001d4 __srefill_r
0822dc28 g     F .text	0000004c pre_task_setup
08253d84 g     O .bss	00000004 rcvdq_sem_ptr
08227c1c g     F .text	00000124 bsd_getsockname
082424a4 g     F .text	00000130 ip_reasm_mark_compact_rfq
082017ac g     F .text	0000012c FindLastFlashSectorOffset
08216efc g     F .text	00000248 OSFlagDel
08253cb8 g     O .bss	00000004 OSEventFreeList
082298c8 g     F .text	00000048 dhc_set_callback
08200060 g       .exceptions	00000000 alt_irq_entry
08253dd8 g     O .bss	00000004 arpcache
0824ad10 g     F .text	00000300 icmp_destun
082438f4 g     F .text	00000064 lookup_mcast
08249988 g     F .text	00000048 vfslookup
082432c8 g     F .text	000003d4 ip_demux
0820cec8 g     F .text	00000064 __ulp
08253d68 g     O .bss	00000004 tcp_wakeup_count
082173b8 g     F .text	000005b8 OSFlagPend
08253b66 g     O .rwdata	00000002 OSTmrEn
0820abbc g     F .text	00000018 __fp_unlock_all
0822d8f4 g     F .text	000000bc wait_app_sem
0821dfe8 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
0820ac18 g     F .text	0000005c fputc
08253b98 g     O .rwdata	00000004 ipmcfail_str
08253d7c g     O .bss	00000004 memtrapsize
0822e3c8 g     F .text	000002f4 m_copy
08253be0 g     O .rwdata	00000008 alt_fs_list
0825e240 g     O .bss	00000014 mfreeq
082163b4 g     F .text	00000074 OS_StrCopy
08231928 g     F .text	0000005c sobind
08246eb0 g     F .text	00000058 init_memdev
08253c30 g     O .bss	00000001 to_ssstask
0822ea58 g     F .text	000000f8 nptcp_init
08253b30 g     O .rwdata	00000002 OSMemNameSize
0825e094 g     O .bss	000000f0 global_TCPwakeup_set
0823cd00 g     F .text	00000020 OSInitHookEnd
082339c0 g     F .text	000000c4 soisdisconnected
0823d874 g     F .text	00000088 arp_free_pending
08253b5c g     O .rwdata	00000002 OSTCBPrioTblMax
0820b870 g     F .text	0000000c localeconv
08231b64 g     F .text	000002bc soclose
0825df84 g     O .bss	00000014 bigfreeq
08253b58 g     O .rwdata	00000002 OSTaskStatStkChkEn
08253c08 g     O .rwdata	00000004 prompt
08253bd0 g     O .rwdata	00000004 tcp_keepidle
08223170 g     F .text	000001a8 alt_tse_phy_set_adv_10
0822f818 g     F .text	000001c8 rawip_soinput
0823bd2c g     F .text	00000050 alt_ic_isr_register
08249468 g     F .text	00000060 vfwrite
08253b2c g     O .rwdata	00000002 OSMemEn
08233c84 g     F .text	000000ac soqinsque
08253e0c g     O .bss	00000004 so_evtmap_delete
08202b30 g     F .text	00000034 fwrite
08253b36 g     O .rwdata	00000002 OSMutexEn
08253df8 g     O .bss	00000004 h_ireq
08253c30 g       *ABS*	00000000 _edata
08240124 g     F .text	000005c4 ip_fragment
082255cc g     F .text	00000148 iniche_devices_init
0825e254 g     O .bss	00000028 tcp_saveti
08228d60 g     F .text	000000d8 con_page
0825e6e0 g       *ABS*	00000000 _end
082332c0 g     F .text	000004a8 sogetopt
0821411c g     F .text	00000068 alt_flash_open_dev
08253cbc g     O .bss	00000001 OSIntNesting
0822201c g     F .text	00000248 alt_tse_mac_associate_phy
08253710 g     O .rwdata	00000030 nettasks
0822cb34 g     F .text	00000020 pk_get_max_intrsafe_buf_len
08210aa4 g     F .text	00000164 __fputwc
08240a34 g     F .text	000001d8 iproute
0822f308 g     F .text	000000f4 np_stripoptions
08253e10 g     O .bss	00000001 so_evtmap
0821ca78 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0820ac74 g     F .text	0000009c _fputs_r
0821be88 g     F .text	000001d4 OSTimeDlyResume
0820197c g     F .text	000000d0 SSSCreateTasks
0824407c g     F .text	000003c0 add_route
0821726c g     F .text	0000014c OSFlagNameSet
082263b4 g     F .text	00000090 c_older
08234674 g     F .text	00000084 sbflush
08246f30 g     F .text	00000024 md_fclose
08229558 g     F .text	00000030 tk_yield
08201cd8 g     F .text	000000c8 sss_handle_accept
0821b6ec g     F .text	000001c0 OSTaskStkChk
0823be04 g     F .text	0000008c alt_ic_irq_disable
08232058 g     F .text	00000558 sosend
08253b32 g     O .rwdata	00000002 OSMemSize
082406e8 g     F .text	000000a4 ip_mymach
0821e754 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0820dc18 g     F .text	0000007c __swrite
08253d4c g     O .bss	00000004 cticks_initialized
08253c10 g     O .rwdata	00000004 deflength
082310c8 g     F .text	000001f4 t_sendto
08253aec g     O .rwdata	00000004 __malloc_trim_threshold
08203028 g     F .text	00000080 _perror_r
0823c9dc g     F .text	00000024 altera_nios2_qsys_irq_init
0820b838 g     F .text	0000000c __locale_msgcharset
08253cc0 g     O .bss	00000004 OSTCBCur
08231780 g     F .text	000001a8 socreate
0824b3a4 g     F .text	00000038 exit
0825e4ec g     O .bss	00000100 arp_table
08253e48 g     O .bss	00000004 icmpdu_hook
08253b34 g     O .rwdata	00000002 OSMemTblSize
0820b6dc g     F .text	000000c4 _fwalk_reent
0823d56c g     F .text	00000024 create_apptasks
08253bcc g     O .rwdata	00000004 tcp_ttl
0820cccc g     F .text	000001fc __mdiff
08214184 g     F .text	00000054 alt_flash_close_dev
0822df60 g     F .text	00000040 ncpfree
082028e8 g     F .text	00000074 .hidden __modsi3
08253cdc g     O .bss	00000004 MaxLnh
08253ad8 g     O .rwdata	00000004 __ctype_ptr__
0821f1c8 g     F .text	00000050 tse_mac_setGMIImode
082476a0 g     F .text	00000084 inet_ntop
082451f0 g     F .text	00000024 udp_maxalloc
08223b90 g     F .text	000000e4 marvell_cfg_gmii
08380000 g       *ABS*	00000000 __alt_data_end
08200060 g     F .exceptions	00000000 alt_exception
0820ab98 g     F .text	00000004 __sfp_lock_release
082151a0 g     F .text	00000058 OSInit
08222264 g     F .text	00000128 alt_tse_phy_cfg_pcs
0821ba90 g     F .text	00000124 OSTaskQuery
0823ce58 g     F .text	00000094 icmp_port_du
08253dac g     O .bss	00000004 tcp_iss
082199b0 g     F .text	000000a8 OS_QInit
0824b38c g     F .text	0000000c atoi
08253bbc g     O .rwdata	00000004 bigbufsiz
08216428 g     F .text	00000054 OS_StrLen
08239a68 g     F .text	00000078 tcp_putseq
082185b4 g     F .text	00000114 OSMemNameSet
0824cdd6 g     O .rodata	00000101 _ctype_
08200000 g       *ABS*	00000000 __alt_mem_onchip_ram
082342b8 g     F .text	000001dc sbappendaddr
00000000 g       *ABS*	00000000 __alt_mem_ext_flash
08253e40 g     O .bss	00000004 vfs_total_rw_space
082462c0 g     F .text	00000108 ip_getmoptions
08253b4e g     O .rwdata	00000002 OSTaskProfileEn
08244f90 g     F .text	000000f4 udpswap
08253cc4 g     O .bss	00000004 OSTime
08253d88 g     O .bss	00000004 nextslow
08239b54 g     F .text	00000270 tcp_slowtimo
08239774 g     F .text	0000010c tcp_newtcpcb
0823e550 g     F .text	00000180 send_via_arp
08229818 g     F .text	000000b0 dhc_init
08241e74 g     F .text	00000058 ip_reasm_find_ire
0825bed0 g     O .bss	00000800 OSTaskIdleStk
0824bbec g     F .text	00000034 _exit
08249b9c g     F .text	00000058 isvfile_locked
082281f8 g     F .text	00000184 bsd_select
0823b820 g     F .text	0000012c alt_alarm_start
08217144 g     F .text	00000128 OSFlagNameGet
08245214 g     F .text	00000044 udp_free
0822cc10 g     F .text	000000b8 getq
08249cf0 g     F .text	00000024 prep_vfs
0821c05c g     F .text	0000005c OSTimeGet
08253c04 g     O .rwdata	00000004 name
082348b0 g     F .text	00000100 sbdropend
0820b87c g     F .text	000001bc __smakebuf_r
0823e6d0 g     F .text	0000010c cb_arpent_tmo
08203cac g     F .text	00000098 strlen
08245bc4 g     F .text	00000134 IPADDR_TO_NETP
0822807c g     F .text	00000034 bsd_inet_ntoa
0823cc74 g     F .text	00000020 OSTaskSwHook
0823c20c g     F .text	00000154 open
0822ce78 g     F .text	000001fc udp_open
0825c6d0 g     O .bss	00000b40 OSEventTbl
08233e38 g     F .text	00000058 socantsendmore
08253e44 g     O .bss	00000004 vfs_total_dyna_files
08212cd0 g     F .text	000000dc .hidden __gedf2
0823c6d4 g     F .text	00000044 alt_uncached_free
0825d210 g     O .bss	00000510 OSTCBTbl
08253de4 g     O .bss	00000004 arpReqsOut
0821a3b8 g     F .text	00000100 OSSemSet
08253c2c g     O .rwdata	00000004 http_root_path
0822b7ec g     F .text	00000270 dhc_extract_opts
082413e0 g     F .text	00000564 ip_reasm_compute_overlap
08253af0 g     O .rwdata	00000004 __wctomb
0820f2dc g     F .text	00000018 __sprint_r
0821f044 g     F .text	000000a8 tse_mac_aRxRead
082034d0 g     F .text	00000164 strchr
0825dd6e g     O .bss	00000012 ipreturn
08253e00 g     O .bss	00000004 port_prep
08253793 g     O .rwdata	0000000d tcp_backoff
082337b4 g     F .text	00000070 soisconnecting
08200ca8 g     F .text	00000070 SSSInitialTask
0820ad10 g     F .text	00000018 fputs
08253bf8 g     O .rwdata	00000004 alt_priority_mask
08245754 g     F .text	000001ec igmpv2_process_query
08234a40 g     F .text	000001d0 t_select
08219be0 g     F .text	00000240 OSSemDel
0823b6f8 g     F .text	00000128 udp4_sockaddr
08253cc8 g     O .bss	00000004 OSFlagFreeList
08247e74 g     F .text	000001e0 in_pcbconnect
08253da0 g     O .bss	00000004 dropline
08253dfc g     O .bss	00000004 ire_cticks
0823bd7c g     F .text	00000088 alt_ic_irq_enable
08253b14 g     O .rwdata	00000002 OSEventNameSize
08208980 g     F .text	0000001c __vfprintf_internal
0822911c g     F .text	00000078 tk_netmain
08248054 g     F .text	0000005c in_pcbdisconnect
08253ccc g     O .bss	00000001 OSStatRdy
0825d720 g     O .bss	00000054 OSTCBPrioTbl
08210fa8 g     F .text	0000005c _wctomb_r
08214620 g     F .text	000000c4 __env_lock
08253b5a g     O .rwdata	00000002 OSTaskSwHookEn
0825396c g     O .rwdata	00000024 mdio
08220220 g     F .text	000000e0 alt_tse_mac_set_speed
0821e32c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
082279d4 g     F .text	00000124 bsd_accept
08253bdc g     O .rwdata	00000004 tcp_recvspace
082135b8 g     F .text	000008fc .hidden __subdf3
0824bbd4 g     F .text	00000018 _vfprintf_r
0823ac2c g     F .text	00000040 tcpinit
08253cfc g     O .bss	00000004 igmp_all_rtrs_group
0822f7bc g     F .text	0000005c rawip_lookup
0823d60c g     F .text	000000a0 fcntl
0820c700 g     F .text	000000b0 __lo0bits
08234494 g     F .text	000001e0 sbcompress
08253bfc g     O .rwdata	00000008 alt_alarm_list
08239880 g     F .text	000000ac tcp_drop
08253b22 g     O .rwdata	00000002 OSFlagWidth
0823bbdc g     F .text	00000060 _do_ctors
08222f1c g     F .text	00000254 alt_tse_phy_set_adv_100
08239e24 g     F .text	00000480 tcp_timers
082269b4 g     F .text	00000084 if_netnumber
082463c8 g     F .text	00000088 ip_freemoptions
08233768 g     F .text	0000004c sohasoutofband
08210eb8 g     F .text	000000c0 wcrtomb
082356cc g     F .text	00002330 tcp_input
08227af8 g     F .text	00000124 bsd_getpeername
082280b0 g     F .text	00000148 bsd_recvfrom
08225584 g     F .text	00000048 close
08253d2c g     O .bss	00000004 dsc_bpreplys
08253c78 g     O .bss	00000004 alt_envsem
08253cd0 g     O .bss	00000004 OSIdleCtrRun
082157e4 g     F .text	00000020 OSVersion
08253b6c g     O .rwdata	00000002 OSTmrCfgWheelSize
0821bbb4 g     F .text	00000070 OS_TaskStkClr
0824840c g     F .text	0000002c set_vfopen_error
08253b46 g     O .rwdata	00000002 OSTaskCreateEn
0821ffe8 g     F .text	0000006c alt_tse_get_system_index
08253770 g     O .rwdata	00000018 rawip_protosw
08233f24 g     F .text	0000006c sbwait
08215dd4 g     F .text	00000068 OS_EventWaitListInit
0822ba5c g     F .text	00000550 dhc_second
0821ed34 g     F .text	000000a8 alt_avalon_sgdma_init
08253dcc g     O .bss	00000004 port_1s_callout
08210c2c g     F .text	00000080 fputwc
0823cd20 g     F .text	00000020 OSTaskIdleHook
0824b3f0 g     F .text	00000014 free
0820ab9c g     F .text	00000004 __sinit_lock_acquire
08253cd8 g     O .bss	00000001 number_of_tse_mac
0820c474 g     F .text	00000120 __multadd
0821b8ac g     F .text	000001e4 OSTaskSuspend
0820c44c g     F .text	00000028 _Bfree
0821eed0 g     F .text	00000030 no_printf
08233a84 g     F .text	00000200 sonewconn
0824a1ac g     F .text	00000b64 icmprcv
0822e030 g     F .text	000000c4 pffindproto
0821647c g     F .text	0000005c OS_TaskIdle
08253b72 g     O .rwdata	00000002 OSTmrTblSize
08219854 g     F .text	0000015c OSQQuery



Disassembly of section .exceptions:

08200060 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8200060:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8200064:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8200068:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 820006c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8200070:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8200074:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8200078:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 820007c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8200080:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8200084:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8200088:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 820008c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8200090:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8200094:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8200098:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 820009c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 82000a0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 82000a4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 82000a8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 82000ac:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 82000b0:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 82000b4:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 82000b8:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 82000bc:	10000326 	beq	r2,zero,82000cc <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 82000c0:	20000226 	beq	r4,zero,82000cc <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 82000c4:	820012c0 	call	820012c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 82000c8:	00000306 	br	82000d8 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 82000cc:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 82000d0:	e8bfff17 	ldw	r2,-4(ea)

082000d4 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 82000d4:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 82000d8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 82000dc:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 82000e0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 82000e4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 82000e8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 82000ec:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 82000f0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 82000f4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 82000f8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 82000fc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 8200100:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 8200104:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 8200108:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 820010c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 8200110:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 8200114:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 8200118:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 820011c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 8200120:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 8200124:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 8200128:	ef80083a 	eret

0820012c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 820012c:	defff904 	addi	sp,sp,-28
 8200130:	dfc00615 	stw	ra,24(sp)
 8200134:	df000515 	stw	fp,20(sp)
 8200138:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 820013c:	82151f80 	call	82151f8 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8200140:	0005313a 	rdctl	r2,ipending
 8200144:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8200148:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 820014c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8200150:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8200154:	00800044 	movi	r2,1
 8200158:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 820015c:	e0fffb17 	ldw	r3,-20(fp)
 8200160:	e0bffc17 	ldw	r2,-16(fp)
 8200164:	1884703a 	and	r2,r3,r2
 8200168:	10001426 	beq	r2,zero,82001bc <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 820016c:	008209b4 	movhi	r2,2086
 8200170:	10b8e204 	addi	r2,r2,-7288
 8200174:	e0fffd17 	ldw	r3,-12(fp)
 8200178:	180690fa 	slli	r3,r3,3
 820017c:	10c5883a 	add	r2,r2,r3
 8200180:	10c00017 	ldw	r3,0(r2)
 8200184:	008209b4 	movhi	r2,2086
 8200188:	10b8e204 	addi	r2,r2,-7288
 820018c:	e13ffd17 	ldw	r4,-12(fp)
 8200190:	200890fa 	slli	r4,r4,3
 8200194:	1105883a 	add	r2,r2,r4
 8200198:	10800104 	addi	r2,r2,4
 820019c:	10800017 	ldw	r2,0(r2)
 82001a0:	1009883a 	mov	r4,r2
 82001a4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 82001a8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 82001ac:	0005313a 	rdctl	r2,ipending
 82001b0:	e0bfff15 	stw	r2,-4(fp)

  return active;
 82001b4:	e0bfff17 	ldw	r2,-4(fp)
 82001b8:	00000706 	br	82001d8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 82001bc:	e0bffc17 	ldw	r2,-16(fp)
 82001c0:	1085883a 	add	r2,r2,r2
 82001c4:	e0bffc15 	stw	r2,-16(fp)
      i++;
 82001c8:	e0bffd17 	ldw	r2,-12(fp)
 82001cc:	10800044 	addi	r2,r2,1
 82001d0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 82001d4:	003fe106 	br	820015c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 82001d8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 82001dc:	e0bffb17 	ldw	r2,-20(fp)
 82001e0:	103fdb1e 	bne	r2,zero,8200150 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 82001e4:	82152440 	call	8215244 <OSIntExit>
}
 82001e8:	0001883a 	nop
 82001ec:	e037883a 	mov	sp,fp
 82001f0:	dfc00117 	ldw	ra,4(sp)
 82001f4:	df000017 	ldw	fp,0(sp)
 82001f8:	dec00204 	addi	sp,sp,8
 82001fc:	f800283a 	ret

Disassembly of section .text:

08200200 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8200200:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 8200204:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 8200208:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 820020c:	00bffd16 	blt	zero,r2,8200204 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8200210:	06c20e34 	movhi	sp,2104
    ori sp, sp, %lo(__alt_stack_pointer)
 8200214:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8200218:	06820974 	movhi	gp,2085
    ori gp, gp, %lo(_gp)
 820021c:	d6aeb614 	ori	gp,gp,47832
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8200220:	00820974 	movhi	r2,2085
    ori r2, r2, %lo(__bss_start)
 8200224:	108f0c14 	ori	r2,r2,15408

    movhi r3, %hi(__bss_end)
 8200228:	00c20974 	movhi	r3,2085
    ori r3, r3, %lo(__bss_end)
 820022c:	18f9b814 	ori	r3,r3,59104

    beq r2, r3, 1f
 8200230:	10c00326 	beq	r2,r3,8200240 <_start+0x40>

0:
    stw zero, (r2)
 8200234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 8200238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 820023c:	10fffd36 	bltu	r2,r3,8200234 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8200240:	82144b40 	call	82144b4 <alt_main>

08200244 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 8200244:	003fff06 	br	8200244 <alt_after_alt_main>

08200248 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 8200248:	defffb04 	addi	sp,sp,-20
 820024c:	dfc00415 	stw	ra,16(sp)
 8200250:	df000315 	stw	fp,12(sp)
 8200254:	df000304 	addi	fp,sp,12
 8200258:	2005883a 	mov	r2,r4
 820025c:	e17fff15 	stw	r5,-4(fp)
 8200260:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 8200264:	e0bffe03 	ldbu	r2,-8(fp)
 8200268:	10014a26 	beq	r2,zero,8200794 <alt_uCOSIIErrorHandler+0x54c>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 820026c:	00800084 	movi	r2,2
 8200270:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200274:	821533c0 	call	821533c <OSSchedLock>
      
   switch (error_code)
 8200278:	e0bffe03 	ldbu	r2,-8(fp)
 820027c:	10c00a20 	cmpeqi	r3,r2,40
 8200280:	1800261e 	bne	r3,zero,820031c <alt_uCOSIIErrorHandler+0xd4>
 8200284:	10c00a48 	cmpgei	r3,r2,41
 8200288:	1800121e 	bne	r3,zero,82002d4 <alt_uCOSIIErrorHandler+0x8c>
 820028c:	10c00120 	cmpeqi	r3,r2,4
 8200290:	1800601e 	bne	r3,zero,8200414 <alt_uCOSIIErrorHandler+0x1cc>
 8200294:	10c00148 	cmpgei	r3,r2,5
 8200298:	1800071e 	bne	r3,zero,82002b8 <alt_uCOSIIErrorHandler+0x70>
 820029c:	10c000a0 	cmpeqi	r3,r2,2
 82002a0:	18007a1e 	bne	r3,zero,820048c <alt_uCOSIIErrorHandler+0x244>
 82002a4:	10c000c8 	cmpgei	r3,r2,3
 82002a8:	1800631e 	bne	r3,zero,8200438 <alt_uCOSIIErrorHandler+0x1f0>
 82002ac:	10800060 	cmpeqi	r2,r2,1
 82002b0:	10004d1e 	bne	r2,zero,82003e8 <alt_uCOSIIErrorHandler+0x1a0>
 82002b4:	0000bc06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002b8:	10c00520 	cmpeqi	r3,r2,20
 82002bc:	1800401e 	bne	r3,zero,82003c0 <alt_uCOSIIErrorHandler+0x178>
 82002c0:	10c007a0 	cmpeqi	r3,r2,30
 82002c4:	1800961e 	bne	r3,zero,8200520 <alt_uCOSIIErrorHandler+0x2d8>
 82002c8:	108002a0 	cmpeqi	r2,r2,10
 82002cc:	1000651e 	bne	r2,zero,8200464 <alt_uCOSIIErrorHandler+0x21c>
 82002d0:	0000b506 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002d4:	10c01020 	cmpeqi	r3,r2,64
 82002d8:	1800881e 	bne	r3,zero,82004fc <alt_uCOSIIErrorHandler+0x2b4>
 82002dc:	10c01048 	cmpgei	r3,r2,65
 82002e0:	1800071e 	bne	r3,zero,8200300 <alt_uCOSIIErrorHandler+0xb8>
 82002e4:	10c00f60 	cmpeqi	r3,r2,61
 82002e8:	18007a1e 	bne	r3,zero,82004d4 <alt_uCOSIIErrorHandler+0x28c>
 82002ec:	10c00fa0 	cmpeqi	r3,r2,62
 82002f0:	18006f1e 	bne	r3,zero,82004b0 <alt_uCOSIIErrorHandler+0x268>
 82002f4:	10800aa0 	cmpeqi	r2,r2,42
 82002f8:	1000111e 	bne	r2,zero,8200340 <alt_uCOSIIErrorHandler+0xf8>
 82002fc:	0000aa06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 8200300:	10c01920 	cmpeqi	r3,r2,100
 8200304:	1800901e 	bne	r3,zero,8200548 <alt_uCOSIIErrorHandler+0x300>
 8200308:	10c03fe0 	cmpeqi	r3,r2,255
 820030c:	1800991e 	bne	r3,zero,8200574 <alt_uCOSIIErrorHandler+0x32c>
 8200310:	108010a0 	cmpeqi	r2,r2,66
 8200314:	10001a1e 	bne	r2,zero,8200380 <alt_uCOSIIErrorHandler+0x138>
 8200318:	0000a306 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 820031c:	d0a00217 	ldw	r2,-32760(gp)
 8200320:	10800317 	ldw	r2,12(r2)
 8200324:	100f883a 	mov	r7,r2
 8200328:	01800c44 	movi	r6,49
 820032c:	01400044 	movi	r5,1
 8200330:	01020974 	movhi	r4,2085
 8200334:	212f0804 	addi	r4,r4,-17376
 8200338:	8202b300 	call	8202b30 <fwrite>
         break;
 820033c:	0000b106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 8200340:	d0a00217 	ldw	r2,-32760(gp)
 8200344:	10800317 	ldw	r2,12(r2)
 8200348:	100f883a 	mov	r7,r2
 820034c:	01800c44 	movi	r6,49
 8200350:	01400044 	movi	r5,1
 8200354:	01020974 	movhi	r4,2085
 8200358:	212f1504 	addi	r4,r4,-17324
 820035c:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 8200360:	d0a00217 	ldw	r2,-32760(gp)
 8200364:	10800317 	ldw	r2,12(r2)
 8200368:	01800504 	movi	r6,20
 820036c:	01420974 	movhi	r5,2085
 8200370:	296f2204 	addi	r5,r5,-17272
 8200374:	1009883a 	mov	r4,r2
 8200378:	8202a400 	call	8202a40 <fprintf>
            OS_LOWEST_PRIO);
         break;
 820037c:	0000a106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 8200380:	d0a00217 	ldw	r2,-32760(gp)
 8200384:	10800317 	ldw	r2,12(r2)
 8200388:	100f883a 	mov	r7,r2
 820038c:	01800a04 	movi	r6,40
 8200390:	01400044 	movi	r5,1
 8200394:	01020974 	movhi	r4,2085
 8200398:	212f2f04 	addi	r4,r4,-17220
 820039c:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 82003a0:	d0a00217 	ldw	r2,-32760(gp)
 82003a4:	10800317 	ldw	r2,12(r2)
 82003a8:	01800284 	movi	r6,10
 82003ac:	01420974 	movhi	r5,2085
 82003b0:	296f3a04 	addi	r5,r5,-17176
 82003b4:	1009883a 	mov	r4,r2
 82003b8:	8202a400 	call	8202a40 <fprintf>
         break;
 82003bc:	00009106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_MBOX_FULL:
         fault_level = NONE;
 82003c0:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 82003c4:	d0a00217 	ldw	r2,-32760(gp)
 82003c8:	10800317 	ldw	r2,12(r2)
 82003cc:	100f883a 	mov	r7,r2
 82003d0:	01800c84 	movi	r6,50
 82003d4:	01400044 	movi	r5,1
 82003d8:	01020974 	movhi	r4,2085
 82003dc:	212f4304 	addi	r4,r4,-17140
 82003e0:	8202b300 	call	8202b30 <fwrite>
         break;
 82003e4:	00008706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 82003e8:	00800044 	movi	r2,1
 82003ec:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, 
 82003f0:	d0a00217 	ldw	r2,-32760(gp)
 82003f4:	10800317 	ldw	r2,12(r2)
 82003f8:	100f883a 	mov	r7,r2
 82003fc:	01801244 	movi	r6,73
 8200400:	01400044 	movi	r5,1
 8200404:	01020974 	movhi	r4,2085
 8200408:	212f5004 	addi	r4,r4,-17088
 820040c:	8202b300 	call	8202b30 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 8200410:	00007c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 8200414:	d0a00217 	ldw	r2,-32760(gp)
 8200418:	10800317 	ldw	r2,12(r2)
 820041c:	100f883a 	mov	r7,r2
 8200420:	01800c44 	movi	r6,49
 8200424:	01400044 	movi	r5,1
 8200428:	01020974 	movhi	r4,2085
 820042c:	212f6304 	addi	r4,r4,-17012
 8200430:	8202b300 	call	8202b30 <fwrite>
         break;
 8200434:	00007306 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 8200438:	00800044 	movi	r2,1
 820043c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 8200440:	d0a00217 	ldw	r2,-32760(gp)
 8200444:	10800317 	ldw	r2,12(r2)
 8200448:	100f883a 	mov	r7,r2
 820044c:	01800a44 	movi	r6,41
 8200450:	01400044 	movi	r5,1
 8200454:	01020974 	movhi	r4,2085
 8200458:	212f7004 	addi	r4,r4,-16960
 820045c:	8202b300 	call	8202b30 <fwrite>
         break;
 8200460:	00006806 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TIMEOUT:
         fault_level = NONE;
 8200464:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 8200468:	d0a00217 	ldw	r2,-32760(gp)
 820046c:	10800317 	ldw	r2,12(r2)
 8200470:	100f883a 	mov	r7,r2
 8200474:	01800a04 	movi	r6,40
 8200478:	01400044 	movi	r5,1
 820047c:	01020974 	movhi	r4,2085
 8200480:	212f7b04 	addi	r4,r4,-16916
 8200484:	8202b300 	call	8202b30 <fwrite>
         break;
 8200488:	00005e06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 820048c:	d0a00217 	ldw	r2,-32760(gp)
 8200490:	10800317 	ldw	r2,12(r2)
 8200494:	100f883a 	mov	r7,r2
 8200498:	01800b04 	movi	r6,44
 820049c:	01400044 	movi	r5,1
 82004a0:	01020974 	movhi	r4,2085
 82004a4:	212f8604 	addi	r4,r4,-16872
 82004a8:	8202b300 	call	8202b30 <fwrite>
         break;
 82004ac:	00005506 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 82004b0:	d0a00217 	ldw	r2,-32760(gp)
 82004b4:	10800317 	ldw	r2,12(r2)
 82004b8:	100f883a 	mov	r7,r2
 82004bc:	01800884 	movi	r6,34
 82004c0:	01400044 	movi	r5,1
 82004c4:	01020974 	movhi	r4,2085
 82004c8:	212f9204 	addi	r4,r4,-16824
 82004cc:	8202b300 	call	8202b30 <fwrite>
         break;
 82004d0:	00004c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 82004d4:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 82004d8:	d0a00217 	ldw	r2,-32760(gp)
 82004dc:	10800317 	ldw	r2,12(r2)
 82004e0:	100f883a 	mov	r7,r2
 82004e4:	01800bc4 	movi	r6,47
 82004e8:	01400044 	movi	r5,1
 82004ec:	01020974 	movhi	r4,2085
 82004f0:	212f9b04 	addi	r4,r4,-16788
 82004f4:	8202b300 	call	8202b30 <fwrite>
         break;
 82004f8:	00004206 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 82004fc:	d0a00217 	ldw	r2,-32760(gp)
 8200500:	10800317 	ldw	r2,12(r2)
 8200504:	100f883a 	mov	r7,r2
 8200508:	018009c4 	movi	r6,39
 820050c:	01400044 	movi	r5,1
 8200510:	01020974 	movhi	r4,2085
 8200514:	212fa704 	addi	r4,r4,-16740
 8200518:	8202b300 	call	8202b30 <fwrite>
         break;
 820051c:	00003906 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_Q_FULL:
         fault_level = NONE;
 8200520:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 8200524:	d0a00217 	ldw	r2,-32760(gp)
 8200528:	10800317 	ldw	r2,12(r2)
 820052c:	100f883a 	mov	r7,r2
 8200530:	01800a84 	movi	r6,42
 8200534:	01400044 	movi	r5,1
 8200538:	01020974 	movhi	r4,2085
 820053c:	212fb104 	addi	r4,r4,-16700
 8200540:	8202b300 	call	8202b30 <fwrite>
         break;
 8200544:	00002f06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 8200548:	00800044 	movi	r2,1
 820054c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 8200550:	d0a00217 	ldw	r2,-32760(gp)
 8200554:	10800317 	ldw	r2,12(r2)
 8200558:	100f883a 	mov	r7,r2
 820055c:	01800c04 	movi	r6,48
 8200560:	01400044 	movi	r5,1
 8200564:	01020974 	movhi	r4,2085
 8200568:	212fbc04 	addi	r4,r4,-16656
 820056c:	8202b300 	call	8202b30 <fwrite>
         break;
 8200570:	00002406 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200574:	00800084 	movi	r2,2
 8200578:	e0bffd15 	stw	r2,-12(fp)
         printf(
 820057c:	01020974 	movhi	r4,2085
 8200580:	212fc904 	addi	r4,r4,-16604
 8200584:	82030ec0 	call	82030ec <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 8200588:	d0a00217 	ldw	r2,-32760(gp)
 820058c:	10800317 	ldw	r2,12(r2)
 8200590:	e1bfff17 	ldw	r6,-4(fp)
 8200594:	01420974 	movhi	r5,2085
 8200598:	296fd904 	addi	r5,r5,-16540
 820059c:	1009883a 	mov	r4,r2
 82005a0:	8202a400 	call	8202a40 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 82005a4:	00001706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 82005a8:	01020974 	movhi	r4,2085
 82005ac:	212fe404 	addi	r4,r4,-16496
 82005b0:	82033700 	call	8203370 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 82005b4:	d0a00217 	ldw	r2,-32760(gp)
 82005b8:	10800317 	ldw	r2,12(r2)
 82005bc:	100f883a 	mov	r7,r2
 82005c0:	01800404 	movi	r6,16
 82005c4:	01400044 	movi	r5,1
 82005c8:	01020974 	movhi	r4,2085
 82005cc:	212ff204 	addi	r4,r4,-16440
 82005d0:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 82005d4:	d0a00217 	ldw	r2,-32760(gp)
 82005d8:	10800317 	ldw	r2,12(r2)
 82005dc:	e0fffe03 	ldbu	r3,-8(fp)
 82005e0:	180d883a 	mov	r6,r3
 82005e4:	01420974 	movhi	r5,2085
 82005e8:	296ff704 	addi	r5,r5,-16420
 82005ec:	1009883a 	mov	r4,r2
 82005f0:	8202a400 	call	8202a40 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 82005f4:	01020974 	movhi	r4,2085
 82005f8:	212ffc04 	addi	r4,r4,-16400
 82005fc:	82030a80 	call	82030a8 <perror>
         break;
 8200600:	0001883a 	nop

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 8200604:	e0bffd17 	ldw	r2,-12(fp)
 8200608:	10c00060 	cmpeqi	r3,r2,1
 820060c:	1800041e 	bne	r3,zero,8200620 <alt_uCOSIIErrorHandler+0x3d8>
 8200610:	00803a2e 	bgeu	zero,r2,82006fc <alt_uCOSIIErrorHandler+0x4b4>
 8200614:	108000a0 	cmpeqi	r2,r2,2
 8200618:	10001c1e 	bne	r2,zero,820068c <alt_uCOSIIErrorHandler+0x444>
 820061c:	00005106 	br	8200764 <alt_uCOSIIErrorHandler+0x51c>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 8200620:	01020974 	movhi	r4,2085
 8200624:	21300a04 	addi	r4,r4,-16344
 8200628:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 820062c:	d0a00217 	ldw	r2,-32760(gp)
 8200630:	10800317 	ldw	r2,12(r2)
 8200634:	100f883a 	mov	r7,r2
 8200638:	01800904 	movi	r6,36
 820063c:	01400044 	movi	r5,1
 8200640:	01020974 	movhi	r4,2085
 8200644:	21301704 	addi	r4,r4,-16292
 8200648:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 820064c:	d0a00217 	ldw	r2,-32760(gp)
 8200650:	10800317 	ldw	r2,12(r2)
 8200654:	100f883a 	mov	r7,r2
 8200658:	01800a04 	movi	r6,40
 820065c:	01400044 	movi	r5,1
 8200660:	01020974 	movhi	r4,2085
 8200664:	21302104 	addi	r4,r4,-16252
 8200668:	8202b300 	call	8202b30 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 820066c:	82153c80 	call	82153c8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200670:	01003fc4 	movi	r4,255
 8200674:	821ad380 	call	821ad38 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200678:	e0bffe03 	ldbu	r2,-8(fp)
 820067c:	000b883a 	mov	r5,zero
 8200680:	1009883a 	mov	r4,r2
 8200684:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200688:	00004106 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 820068c:	01020974 	movhi	r4,2085
 8200690:	21302c04 	addi	r4,r4,-16208
 8200694:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 8200698:	d0a00217 	ldw	r2,-32760(gp)
 820069c:	10800317 	ldw	r2,12(r2)
 82006a0:	100f883a 	mov	r7,r2
 82006a4:	01800984 	movi	r6,38
 82006a8:	01400044 	movi	r5,1
 82006ac:	01020974 	movhi	r4,2085
 82006b0:	21303a04 	addi	r4,r4,-16152
 82006b4:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 82006b8:	d0a00217 	ldw	r2,-32760(gp)
 82006bc:	10800317 	ldw	r2,12(r2)
 82006c0:	100f883a 	mov	r7,r2
 82006c4:	01800bc4 	movi	r6,47
 82006c8:	01400044 	movi	r5,1
 82006cc:	01020974 	movhi	r4,2085
 82006d0:	21304404 	addi	r4,r4,-16112
 82006d4:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 82006d8:	d0a00217 	ldw	r2,-32760(gp)
 82006dc:	10800317 	ldw	r2,12(r2)
 82006e0:	100f883a 	mov	r7,r2
 82006e4:	01800cc4 	movi	r6,51
 82006e8:	01400044 	movi	r5,1
 82006ec:	01020974 	movhi	r4,2085
 82006f0:	21305004 	addi	r4,r4,-16064
 82006f4:	8202b300 	call	8202b30 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 82006f8:	003fff06 	br	82006f8 <alt_uCOSIIErrorHandler+0x4b0>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 82006fc:	d0a00217 	ldw	r2,-32760(gp)
 8200700:	10800317 	ldw	r2,12(r2)
 8200704:	100f883a 	mov	r7,r2
 8200708:	01800904 	movi	r6,36
 820070c:	01400044 	movi	r5,1
 8200710:	01020974 	movhi	r4,2085
 8200714:	21305d04 	addi	r4,r4,-16012
 8200718:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 820071c:	d0a00217 	ldw	r2,-32760(gp)
 8200720:	10800317 	ldw	r2,12(r2)
 8200724:	100f883a 	mov	r7,r2
 8200728:	01800c84 	movi	r6,50
 820072c:	01400044 	movi	r5,1
 8200730:	01020974 	movhi	r4,2085
 8200734:	21306704 	addi	r4,r4,-15972
 8200738:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, 
 820073c:	d0a00217 	ldw	r2,-32760(gp)
 8200740:	10800317 	ldw	r2,12(r2)
 8200744:	100f883a 	mov	r7,r2
 8200748:	01800f84 	movi	r6,62
 820074c:	01400044 	movi	r5,1
 8200750:	01020974 	movhi	r4,2085
 8200754:	21307404 	addi	r4,r4,-15920
 8200758:	8202b300 	call	8202b30 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 820075c:	82153c80 	call	82153c8 <OSSchedUnlock>
         return;   
 8200760:	00000d06 	br	8200798 <alt_uCOSIIErrorHandler+0x550>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200764:	01020974 	movhi	r4,2085
 8200768:	21308404 	addi	r4,r4,-15856
 820076c:	82033700 	call	8203370 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 8200770:	d0a00217 	ldw	r2,-32760(gp)
 8200774:	10800317 	ldw	r2,12(r2)
 8200778:	100f883a 	mov	r7,r2
 820077c:	01800ac4 	movi	r6,43
 8200780:	01400044 	movi	r5,1
 8200784:	01020974 	movhi	r4,2085
 8200788:	21309204 	addi	r4,r4,-15800
 820078c:	8202b300 	call	8202b30 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200790:	003fff06 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
{
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
   {
      return;
 8200794:	0001883a 	nop
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200798:	e037883a 	mov	sp,fp
 820079c:	dfc00117 	ldw	ra,4(sp)
 82007a0:	df000017 	ldw	fp,0(sp)
 82007a4:	dec00204 	addi	sp,sp,8
 82007a8:	f800283a 	ret

082007ac <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 82007ac:	defffb04 	addi	sp,sp,-20
 82007b0:	dfc00415 	stw	ra,16(sp)
 82007b4:	df000315 	stw	fp,12(sp)
 82007b8:	df000304 	addi	fp,sp,12
 82007bc:	2005883a 	mov	r2,r4
 82007c0:	e17fff15 	stw	r5,-4(fp)
 82007c4:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 82007c8:	e0bffe03 	ldbu	r2,-8(fp)
 82007cc:	10008a26 	beq	r2,zero,82009f8 <alt_NetworkErrorHandler+0x24c>
   {
      return;
   }

   fault_level = SYSTEM;   
 82007d0:	00800084 	movi	r2,2
 82007d4:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 82007d8:	821533c0 	call	821533c <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 82007dc:	e0bffe03 	ldbu	r2,-8(fp)
 82007e0:	10803fd8 	cmpnei	r2,r2,255
 82007e4:	1000101e 	bne	r2,zero,8200828 <alt_NetworkErrorHandler+0x7c>
   {
      fault_level = SYSTEM;
 82007e8:	00800084 	movi	r2,2
 82007ec:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 82007f0:	01020974 	movhi	r4,2085
 82007f4:	21309d04 	addi	r4,r4,-15756
 82007f8:	82030ec0 	call	82030ec <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 82007fc:	d0a00217 	ldw	r2,-32760(gp)
 8200800:	10800317 	ldw	r2,12(r2)
 8200804:	e1bfff17 	ldw	r6,-4(fp)
 8200808:	01420974 	movhi	r5,2085
 820080c:	2970ac04 	addi	r5,r5,-15696
 8200810:	1009883a 	mov	r4,r2
 8200814:	8202a400 	call	8202a40 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 8200818:	01020974 	movhi	r4,2085
 820081c:	2130b004 	addi	r4,r4,-15680
 8200820:	82030a80 	call	82030a8 <perror>
 8200824:	00001006 	br	8200868 <alt_NetworkErrorHandler+0xbc>
   }
   else 
   {
      fault_level = TASK;
 8200828:	00800044 	movi	r2,1
 820082c:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR.\n");    
 8200830:	01020974 	movhi	r4,2085
 8200834:	2130b604 	addi	r4,r4,-15656
 8200838:	82033700 	call	8203370 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 820083c:	d0a00217 	ldw	r2,-32760(gp)
 8200840:	10800317 	ldw	r2,12(r2)
 8200844:	e0fffe03 	ldbu	r3,-8(fp)
 8200848:	180d883a 	mov	r6,r3
 820084c:	01420974 	movhi	r5,2085
 8200850:	2970bc04 	addi	r5,r5,-15632
 8200854:	1009883a 	mov	r4,r2
 8200858:	8202a400 	call	8202a40 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 820085c:	01020974 	movhi	r4,2085
 8200860:	2130b004 	addi	r4,r4,-15680
 8200864:	82030a80 	call	82030a8 <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200868:	e0bffd17 	ldw	r2,-12(fp)
 820086c:	10c00060 	cmpeqi	r3,r2,1
 8200870:	1800041e 	bne	r3,zero,8200884 <alt_NetworkErrorHandler+0xd8>
 8200874:	00803a2e 	bgeu	zero,r2,8200960 <alt_NetworkErrorHandler+0x1b4>
 8200878:	108000a0 	cmpeqi	r2,r2,2
 820087c:	10001c1e 	bne	r2,zero,82008f0 <alt_NetworkErrorHandler+0x144>
 8200880:	00005106 	br	82009c8 <alt_NetworkErrorHandler+0x21c>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 8200884:	01020974 	movhi	r4,2085
 8200888:	2130c304 	addi	r4,r4,-15604
 820088c:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 8200890:	d0a00217 	ldw	r2,-32760(gp)
 8200894:	10800317 	ldw	r2,12(r2)
 8200898:	100f883a 	mov	r7,r2
 820089c:	018007c4 	movi	r6,31
 82008a0:	01400044 	movi	r5,1
 82008a4:	01020974 	movhi	r4,2085
 82008a8:	2130cf04 	addi	r4,r4,-15556
 82008ac:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 82008b0:	d0a00217 	ldw	r2,-32760(gp)
 82008b4:	10800317 	ldw	r2,12(r2)
 82008b8:	100f883a 	mov	r7,r2
 82008bc:	018008c4 	movi	r6,35
 82008c0:	01400044 	movi	r5,1
 82008c4:	01020974 	movhi	r4,2085
 82008c8:	2130d704 	addi	r4,r4,-15524
 82008cc:	8202b300 	call	8202b30 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 82008d0:	82153c80 	call	82153c8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 82008d4:	01003fc4 	movi	r4,255
 82008d8:	821ad380 	call	821ad38 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 82008dc:	e0bffe03 	ldbu	r2,-8(fp)
 82008e0:	000b883a 	mov	r5,zero
 82008e4:	1009883a 	mov	r4,r2
 82008e8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 82008ec:	00004106 	br	82009f4 <alt_NetworkErrorHandler+0x248>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 82008f0:	01020974 	movhi	r4,2085
 82008f4:	2130e004 	addi	r4,r4,-15488
 82008f8:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 82008fc:	d0a00217 	ldw	r2,-32760(gp)
 8200900:	10800317 	ldw	r2,12(r2)
 8200904:	100f883a 	mov	r7,r2
 8200908:	01800884 	movi	r6,34
 820090c:	01400044 	movi	r5,1
 8200910:	01020974 	movhi	r4,2085
 8200914:	2130ec04 	addi	r4,r4,-15440
 8200918:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 820091c:	d0a00217 	ldw	r2,-32760(gp)
 8200920:	10800317 	ldw	r2,12(r2)
 8200924:	100f883a 	mov	r7,r2
 8200928:	01800a84 	movi	r6,42
 820092c:	01400044 	movi	r5,1
 8200930:	01020974 	movhi	r4,2085
 8200934:	2130f504 	addi	r4,r4,-15404
 8200938:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 820093c:	d0a00217 	ldw	r2,-32760(gp)
 8200940:	10800317 	ldw	r2,12(r2)
 8200944:	100f883a 	mov	r7,r2
 8200948:	01800b84 	movi	r6,46
 820094c:	01400044 	movi	r5,1
 8200950:	01020974 	movhi	r4,2085
 8200954:	21310004 	addi	r4,r4,-15360
 8200958:	8202b300 	call	8202b30 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 820095c:	003fff06 	br	820095c <alt_NetworkErrorHandler+0x1b0>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 8200960:	d0a00217 	ldw	r2,-32760(gp)
 8200964:	10800317 	ldw	r2,12(r2)
 8200968:	100f883a 	mov	r7,r2
 820096c:	01800804 	movi	r6,32
 8200970:	01400044 	movi	r5,1
 8200974:	01020974 	movhi	r4,2085
 8200978:	21310c04 	addi	r4,r4,-15312
 820097c:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 8200980:	d0a00217 	ldw	r2,-32760(gp)
 8200984:	10800317 	ldw	r2,12(r2)
 8200988:	100f883a 	mov	r7,r2
 820098c:	01800d84 	movi	r6,54
 8200990:	01400044 	movi	r5,1
 8200994:	01020974 	movhi	r4,2085
 8200998:	21311504 	addi	r4,r4,-15276
 820099c:	8202b300 	call	8202b30 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 82009a0:	d0a00217 	ldw	r2,-32760(gp)
 82009a4:	10800317 	ldw	r2,12(r2)
 82009a8:	100f883a 	mov	r7,r2
 82009ac:	01800e44 	movi	r6,57
 82009b0:	01400044 	movi	r5,1
 82009b4:	01020974 	movhi	r4,2085
 82009b8:	21312304 	addi	r4,r4,-15220
 82009bc:	8202b300 	call	8202b30 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 82009c0:	82153c80 	call	82153c8 <OSSchedUnlock>
         return;
 82009c4:	00000d06 	br	82009fc <alt_NetworkErrorHandler+0x250>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 82009c8:	01020974 	movhi	r4,2085
 82009cc:	21313204 	addi	r4,r4,-15160
 82009d0:	82033700 	call	8203370 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 82009d4:	d0a00217 	ldw	r2,-32760(gp)
 82009d8:	10800317 	ldw	r2,12(r2)
 82009dc:	100f883a 	mov	r7,r2
 82009e0:	01800984 	movi	r6,38
 82009e4:	01400044 	movi	r5,1
 82009e8:	01020974 	movhi	r4,2085
 82009ec:	21313f04 	addi	r4,r4,-15108
 82009f0:	8202b300 	call	8202b30 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 82009f4:	003fff06 	br	82009f4 <alt_NetworkErrorHandler+0x248>
{
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
   {
      return;
 82009f8:	0001883a 	nop
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 82009fc:	e037883a 	mov	sp,fp
 8200a00:	dfc00117 	ldw	ra,4(sp)
 8200a04:	df000017 	ldw	fp,0(sp)
 8200a08:	dec00204 	addi	sp,sp,8
 8200a0c:	f800283a 	ret

08200a10 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 8200a10:	defffb04 	addi	sp,sp,-20
 8200a14:	dfc00415 	stw	ra,16(sp)
 8200a18:	df000315 	stw	fp,12(sp)
 8200a1c:	df000304 	addi	fp,sp,12
 8200a20:	2005883a 	mov	r2,r4
 8200a24:	e17fff15 	stw	r5,-4(fp)
 8200a28:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 8200a2c:	e0bffe03 	ldbu	r2,-8(fp)
 8200a30:	10009726 	beq	r2,zero,8200c90 <alt_SSSErrorHandler+0x280>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 8200a34:	e0bffe03 	ldbu	r2,-8(fp)
 8200a38:	1000021e 	bne	r2,zero,8200a44 <alt_SSSErrorHandler+0x34>
 8200a3c:	0005883a 	mov	r2,zero
 8200a40:	00000106 	br	8200a48 <alt_SSSErrorHandler+0x38>
 8200a44:	00800084 	movi	r2,2
 8200a48:	e0bffd15 	stw	r2,-12(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200a4c:	821533c0 	call	821533c <OSSchedLock>
   switch (error_code)
 8200a50:	e0bffe03 	ldbu	r2,-8(fp)
 8200a54:	10c007a0 	cmpeqi	r3,r2,30
 8200a58:	18000f1e 	bne	r3,zero,8200a98 <alt_SSSErrorHandler+0x88>
 8200a5c:	10803fe0 	cmpeqi	r2,r2,255
 8200a60:	10001726 	beq	r2,zero,8200ac0 <alt_SSSErrorHandler+0xb0>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200a64:	00800084 	movi	r2,2
 8200a68:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 8200a6c:	01020974 	movhi	r4,2085
 8200a70:	21314904 	addi	r4,r4,-15068
 8200a74:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 8200a78:	d0a00217 	ldw	r2,-32760(gp)
 8200a7c:	10800317 	ldw	r2,12(r2)
 8200a80:	e1bfff17 	ldw	r6,-4(fp)
 8200a84:	01420974 	movhi	r5,2085
 8200a88:	29715704 	addi	r5,r5,-15012
 8200a8c:	1009883a 	mov	r4,r2
 8200a90:	8202a400 	call	8202a40 <fprintf>
         break;
 8200a94:	00001a06 	br	8200b00 <alt_SSSErrorHandler+0xf0>
         
      case OS_Q_FULL:
         fault_level = NONE;
 8200a98:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 8200a9c:	d0a00217 	ldw	r2,-32760(gp)
 8200aa0:	10800317 	ldw	r2,12(r2)
 8200aa4:	100f883a 	mov	r7,r2
 8200aa8:	01800c84 	movi	r6,50
 8200aac:	01400044 	movi	r5,1
 8200ab0:	01020974 	movhi	r4,2085
 8200ab4:	21315a04 	addi	r4,r4,-15000
 8200ab8:	8202b300 	call	8202b30 <fwrite>
         break;
 8200abc:	00001006 	br	8200b00 <alt_SSSErrorHandler+0xf0>
      
      default:
         fault_level = SYSTEM;
 8200ac0:	00800084 	movi	r2,2
 8200ac4:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR.\n");    
 8200ac8:	01020974 	movhi	r4,2085
 8200acc:	21316704 	addi	r4,r4,-14948
 8200ad0:	82033700 	call	8203370 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 8200ad4:	d0a00217 	ldw	r2,-32760(gp)
 8200ad8:	10800317 	ldw	r2,12(r2)
 8200adc:	e0fffe03 	ldbu	r3,-8(fp)
 8200ae0:	180d883a 	mov	r6,r3
 8200ae4:	01420974 	movhi	r5,2085
 8200ae8:	29716c04 	addi	r5,r5,-14928
 8200aec:	1009883a 	mov	r4,r2
 8200af0:	8202a400 	call	8202a40 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 8200af4:	01020974 	movhi	r4,2085
 8200af8:	21317204 	addi	r4,r4,-14904
 8200afc:	82030a80 	call	82030a8 <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200b00:	e0bffd17 	ldw	r2,-12(fp)
 8200b04:	10c00060 	cmpeqi	r3,r2,1
 8200b08:	1800041e 	bne	r3,zero,8200b1c <alt_SSSErrorHandler+0x10c>
 8200b0c:	00803a2e 	bgeu	zero,r2,8200bf8 <alt_SSSErrorHandler+0x1e8>
 8200b10:	108000a0 	cmpeqi	r2,r2,2
 8200b14:	10001c1e 	bne	r2,zero,8200b88 <alt_SSSErrorHandler+0x178>
 8200b18:	00005106 	br	8200c60 <alt_SSSErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 8200b1c:	01020974 	movhi	r4,2085
 8200b20:	21317704 	addi	r4,r4,-14884
 8200b24:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 8200b28:	d0a00217 	ldw	r2,-32760(gp)
 8200b2c:	10800317 	ldw	r2,12(r2)
 8200b30:	100f883a 	mov	r7,r2
 8200b34:	018006c4 	movi	r6,27
 8200b38:	01400044 	movi	r5,1
 8200b3c:	01020974 	movhi	r4,2085
 8200b40:	21318204 	addi	r4,r4,-14840
 8200b44:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 8200b48:	d0a00217 	ldw	r2,-32760(gp)
 8200b4c:	10800317 	ldw	r2,12(r2)
 8200b50:	100f883a 	mov	r7,r2
 8200b54:	018007c4 	movi	r6,31
 8200b58:	01400044 	movi	r5,1
 8200b5c:	01020974 	movhi	r4,2085
 8200b60:	21318904 	addi	r4,r4,-14812
 8200b64:	8202b300 	call	8202b30 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 8200b68:	82153c80 	call	82153c8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200b6c:	01003fc4 	movi	r4,255
 8200b70:	821ad380 	call	821ad38 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200b74:	e0bffe03 	ldbu	r2,-8(fp)
 8200b78:	000b883a 	mov	r5,zero
 8200b7c:	1009883a 	mov	r4,r2
 8200b80:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200b84:	00004106 	br	8200c8c <alt_SSSErrorHandler+0x27c>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 8200b88:	01020974 	movhi	r4,2085
 8200b8c:	21319104 	addi	r4,r4,-14780
 8200b90:	82030ec0 	call	82030ec <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 8200b94:	d0a00217 	ldw	r2,-32760(gp)
 8200b98:	10800317 	ldw	r2,12(r2)
 8200b9c:	100f883a 	mov	r7,r2
 8200ba0:	01800784 	movi	r6,30
 8200ba4:	01400044 	movi	r5,1
 8200ba8:	01020974 	movhi	r4,2085
 8200bac:	21319c04 	addi	r4,r4,-14736
 8200bb0:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 8200bb4:	d0a00217 	ldw	r2,-32760(gp)
 8200bb8:	10800317 	ldw	r2,12(r2)
 8200bbc:	100f883a 	mov	r7,r2
 8200bc0:	01800984 	movi	r6,38
 8200bc4:	01400044 	movi	r5,1
 8200bc8:	01020974 	movhi	r4,2085
 8200bcc:	2131a404 	addi	r4,r4,-14704
 8200bd0:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 8200bd4:	d0a00217 	ldw	r2,-32760(gp)
 8200bd8:	10800317 	ldw	r2,12(r2)
 8200bdc:	100f883a 	mov	r7,r2
 8200be0:	01800a84 	movi	r6,42
 8200be4:	01400044 	movi	r5,1
 8200be8:	01020974 	movhi	r4,2085
 8200bec:	2131ae04 	addi	r4,r4,-14664
 8200bf0:	8202b300 	call	8202b30 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 8200bf4:	003fff06 	br	8200bf4 <alt_SSSErrorHandler+0x1e4>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 8200bf8:	d0a00217 	ldw	r2,-32760(gp)
 8200bfc:	10800317 	ldw	r2,12(r2)
 8200c00:	100f883a 	mov	r7,r2
 8200c04:	018006c4 	movi	r6,27
 8200c08:	01400044 	movi	r5,1
 8200c0c:	01020974 	movhi	r4,2085
 8200c10:	2131b904 	addi	r4,r4,-14620
 8200c14:	8202b300 	call	8202b30 <fwrite>
         fprintf(stderr, 
 8200c18:	d0a00217 	ldw	r2,-32760(gp)
 8200c1c:	10800317 	ldw	r2,12(r2)
 8200c20:	100f883a 	mov	r7,r2
 8200c24:	01800f44 	movi	r6,61
 8200c28:	01400044 	movi	r5,1
 8200c2c:	01020974 	movhi	r4,2085
 8200c30:	2131c004 	addi	r4,r4,-14592
 8200c34:	8202b300 	call	8202b30 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 8200c38:	d0a00217 	ldw	r2,-32760(gp)
 8200c3c:	10800317 	ldw	r2,12(r2)
 8200c40:	100f883a 	mov	r7,r2
 8200c44:	01800b84 	movi	r6,46
 8200c48:	01400044 	movi	r5,1
 8200c4c:	01020974 	movhi	r4,2085
 8200c50:	2131d004 	addi	r4,r4,-14528
 8200c54:	8202b300 	call	8202b30 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 8200c58:	82153c80 	call	82153c8 <OSSchedUnlock>
         return;         
 8200c5c:	00000d06 	br	8200c94 <alt_SSSErrorHandler+0x284>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200c60:	01020974 	movhi	r4,2085
 8200c64:	2131dc04 	addi	r4,r4,-14480
 8200c68:	82033700 	call	8203370 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 8200c6c:	d0a00217 	ldw	r2,-32760(gp)
 8200c70:	10800317 	ldw	r2,12(r2)
 8200c74:	100f883a 	mov	r7,r2
 8200c78:	01800844 	movi	r6,33
 8200c7c:	01400044 	movi	r5,1
 8200c80:	01020974 	movhi	r4,2085
 8200c84:	2131e804 	addi	r4,r4,-14432
 8200c88:	8202b300 	call	8202b30 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200c8c:	003fff06 	br	8200c8c <alt_SSSErrorHandler+0x27c>
{
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
   {
      return;
 8200c90:	0001883a 	nop
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200c94:	e037883a 	mov	sp,fp
 8200c98:	dfc00117 	ldw	ra,4(sp)
 8200c9c:	df000017 	ldw	fp,0(sp)
 8200ca0:	dec00204 	addi	sp,sp,8
 8200ca4:	f800283a 	ret

08200ca8 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 8200ca8:	defffc04 	addi	sp,sp,-16
 8200cac:	dfc00315 	stw	ra,12(sp)
 8200cb0:	df000215 	stw	fp,8(sp)
 8200cb4:	df000204 	addi	fp,sp,8
 8200cb8:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 8200cbc:	822da2c0 	call	822da2c <alt_iniche_init>
  netmain(); 
 8200cc0:	822903c0 	call	822903c <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cc4:	00000206 	br	8200cd0 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 8200cc8:	01000084 	movi	r4,2
 8200ccc:	821bc240 	call	821bc24 <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cd0:	d0a08c17 	ldw	r2,-32208(gp)
 8200cd4:	103ffc26 	beq	r2,zero,8200cc8 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 8200cd8:	01020974 	movhi	r4,2085
 8200cdc:	2131f704 	addi	r4,r4,-14372
 8200ce0:	82033700 	call	8203370 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 8200ce4:	01020974 	movhi	r4,2085
 8200ce8:	2106d104 	addi	r4,r4,6980
 8200cec:	822d6a80 	call	822d6a8 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 8200cf0:	82018d80 	call	82018d8 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 8200cf4:	820197c0 	call	820197c <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 8200cf8:	01003fc4 	movi	r4,255
 8200cfc:	821ad380 	call	821ad38 <OSTaskDel>
 8200d00:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d04:	e0bffe03 	ldbu	r2,-8(fp)
 8200d08:	000b883a 	mov	r5,zero
 8200d0c:	1009883a 	mov	r4,r2
 8200d10:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 8200d14:	003fff06 	br	8200d14 <SSSInitialTask+0x6c>

08200d18 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 8200d18:	defff504 	addi	sp,sp,-44
 8200d1c:	dfc00a15 	stw	ra,40(sp)
 8200d20:	df000915 	stw	fp,36(sp)
 8200d24:	df000904 	addi	fp,sp,36
 8200d28:	e13ffd15 	stw	r4,-12(fp)
 8200d2c:	e17ffe15 	stw	r5,-8(fp)
 8200d30:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 8200d34:	0009883a 	mov	r4,zero
 8200d38:	821c0b80 	call	821c0b8 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 8200d3c:	d8000415 	stw	zero,16(sp)
 8200d40:	d8000315 	stw	zero,12(sp)
 8200d44:	00820004 	movi	r2,2048
 8200d48:	d8800215 	stw	r2,8(sp)
 8200d4c:	00820974 	movhi	r2,2085
 8200d50:	10913604 	addi	r2,r2,17624
 8200d54:	d8800115 	stw	r2,4(sp)
 8200d58:	00800144 	movi	r2,5
 8200d5c:	d8800015 	stw	r2,0(sp)
 8200d60:	01c00144 	movi	r7,5
 8200d64:	01820974 	movhi	r6,2085
 8200d68:	31993604 	addi	r6,r6,25816
 8200d6c:	000b883a 	mov	r5,zero
 8200d70:	01020834 	movhi	r4,2080
 8200d74:	21032a04 	addi	r4,r4,3240
 8200d78:	821ab540 	call	821ab54 <OSTaskCreateExt>
 8200d7c:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d80:	e0bffc03 	ldbu	r2,-16(fp)
 8200d84:	000b883a 	mov	r5,zero
 8200d88:	1009883a 	mov	r4,r2
 8200d8c:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 8200d90:	82154a40 	call	82154a4 <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 8200d94:	003fff06 	br	8200d94 <main+0x7c>

08200d98 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 8200d98:	defffc04 	addi	sp,sp,-16
 8200d9c:	dfc00315 	stw	ra,12(sp)
 8200da0:	df000215 	stw	fp,8(sp)
 8200da4:	df000204 	addi	fp,sp,8
 8200da8:	2005883a 	mov	r2,r4
 8200dac:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 8200db0:	d0a05c17 	ldw	r2,-32400(gp)
 8200db4:	e0fffe84 	addi	r3,fp,-6
 8200db8:	180b883a 	mov	r5,r3
 8200dbc:	1009883a 	mov	r4,r2
 8200dc0:	8217d640 	call	8217d64 <OSFlagQuery>
 8200dc4:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 8200dc8:	e0bffe83 	ldbu	r2,-6(fp)
 8200dcc:	10803fcc 	andi	r2,r2,255
 8200dd0:	000b883a 	mov	r5,zero
 8200dd4:	1009883a 	mov	r4,r2
 8200dd8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 8200ddc:	e0ffff0b 	ldhu	r3,-4(fp)
 8200de0:	e0bffe0b 	ldhu	r2,-8(fp)
 8200de4:	1884703a 	and	r2,r3,r2
 8200de8:	10bfffcc 	andi	r2,r2,65535
 8200dec:	10000f26 	beq	r2,zero,8200e2c <led_bit_toggle+0x94>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 8200df0:	d0a05c17 	ldw	r2,-32400(gp)
 8200df4:	e0ffff0b 	ldhu	r3,-4(fp)
 8200df8:	e13ffe84 	addi	r4,fp,-6
 8200dfc:	200f883a 	mov	r7,r4
 8200e00:	000d883a 	mov	r6,zero
 8200e04:	180b883a 	mov	r5,r3
 8200e08:	1009883a 	mov	r4,r2
 8200e0c:	82179d00 	call	82179d0 <OSFlagPost>
 8200e10:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e14:	e0bffe83 	ldbu	r2,-6(fp)
 8200e18:	10803fcc 	andi	r2,r2,255
 8200e1c:	000b883a 	mov	r5,zero
 8200e20:	1009883a 	mov	r4,r2
 8200e24:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e28:	00000f06 	br	8200e68 <led_bit_toggle+0xd0>
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
       alt_uCOSIIErrorHandler(error_code, 0);
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 8200e2c:	d0a05c17 	ldw	r2,-32400(gp)
 8200e30:	e0ffff0b 	ldhu	r3,-4(fp)
 8200e34:	e13ffe84 	addi	r4,fp,-6
 8200e38:	200f883a 	mov	r7,r4
 8200e3c:	01800044 	movi	r6,1
 8200e40:	180b883a 	mov	r5,r3
 8200e44:	1009883a 	mov	r4,r2
 8200e48:	82179d00 	call	82179d0 <OSFlagPost>
 8200e4c:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e50:	e0bffe83 	ldbu	r2,-6(fp)
 8200e54:	10803fcc 	andi	r2,r2,255
 8200e58:	000b883a 	mov	r5,zero
 8200e5c:	1009883a 	mov	r4,r2
 8200e60:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e64:	0001883a 	nop
}
 8200e68:	e037883a 	mov	sp,fp
 8200e6c:	dfc00117 	ldw	ra,4(sp)
 8200e70:	df000017 	ldw	fp,0(sp)
 8200e74:	dec00204 	addi	sp,sp,8
 8200e78:	f800283a 	ret

08200e7c <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 8200e7c:	defffd04 	addi	sp,sp,-12
 8200e80:	dfc00215 	stw	ra,8(sp)
 8200e84:	df000115 	stw	fp,4(sp)
 8200e88:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 8200e8c:	01c00c84 	movi	r7,50
 8200e90:	000d883a 	mov	r6,zero
 8200e94:	000b883a 	mov	r5,zero
 8200e98:	0009883a 	mov	r4,zero
 8200e9c:	821bd280 	call	821bd28 <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8200ea0:	d0a05b17 	ldw	r2,-32404(gp)
 8200ea4:	e1bfff04 	addi	r6,fp,-4
 8200ea8:	000b883a 	mov	r5,zero
 8200eac:	1009883a 	mov	r4,r2
 8200eb0:	8219e200 	call	8219e20 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 8200eb4:	e0bfff03 	ldbu	r2,-4(fp)
 8200eb8:	10803fcc 	andi	r2,r2,255
 8200ebc:	000b883a 	mov	r5,zero
 8200ec0:	1009883a 	mov	r4,r2
 8200ec4:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 8200ec8:	d0a05b17 	ldw	r2,-32404(gp)
 8200ecc:	1009883a 	mov	r4,r2
 8200ed0:	821a1980 	call	821a198 <OSSemPost>
 8200ed4:	e0bfff05 	stb	r2,-4(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 8200ed8:	e0bfff03 	ldbu	r2,-4(fp)
 8200edc:	10803fcc 	andi	r2,r2,255
 8200ee0:	000b883a 	mov	r5,zero
 8200ee4:	1009883a 	mov	r4,r2
 8200ee8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      
   }
 8200eec:	003fe706 	br	8200e8c <LED7SegLightshowTask+0x10>

08200ef0 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 8200ef0:	defffb04 	addi	sp,sp,-20
 8200ef4:	dfc00415 	stw	ra,16(sp)
 8200ef8:	df000315 	stw	fp,12(sp)
 8200efc:	df000304 	addi	fp,sp,12
  
  INT32U led_command; 
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  SSSLEDLightshowActive = OS_TRUE;
 8200f00:	00800044 	movi	r2,1
 8200f04:	e0bffd05 	stb	r2,-12(fp)
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 8200f08:	d0a05a17 	ldw	r2,-32408(gp)
 8200f0c:	e0ffff04 	addi	r3,fp,-4
 8200f10:	180d883a 	mov	r6,r3
 8200f14:	000b883a 	mov	r5,zero
 8200f18:	1009883a 	mov	r4,r2
 8200f1c:	8218f780 	call	8218f78 <OSQPend>
 8200f20:	e0bffe15 	stw	r2,-8(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 8200f24:	e0bfff03 	ldbu	r2,-4(fp)
 8200f28:	10803fcc 	andi	r2,r2,255
 8200f2c:	000b883a 	mov	r5,zero
 8200f30:	1009883a 	mov	r4,r2
 8200f34:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 8200f38:	e0bffe17 	ldw	r2,-8(fp)
 8200f3c:	10bff404 	addi	r2,r2,-48
 8200f40:	10c00928 	cmpgeui	r3,r2,36
 8200f44:	18005d1e 	bne	r3,zero,82010bc <LEDManagementTask+0x1cc>
 8200f48:	100690ba 	slli	r3,r2,2
 8200f4c:	00820834 	movhi	r2,2080
 8200f50:	1083d804 	addi	r2,r2,3936
 8200f54:	1885883a 	add	r2,r3,r2
 8200f58:	10800017 	ldw	r2,0(r2)
 8200f5c:	1000683a 	jmp	r2
 8200f60:	08200ff0 	cmpltui	zero,at,32831
 8200f64:	08200ffc 	xorhi	zero,at,32831
 8200f68:	08201008 	cmpgei	zero,at,-32704
 8200f6c:	08201014 	ori	zero,at,32832
 8200f70:	08201020 	cmpeqi	zero,at,-32704
 8200f74:	0820102c 	andhi	zero,at,32832
 8200f78:	08201038 	rdprs	zero,at,-32704
 8200f7c:	08201044 	addi	zero,at,-32703
 8200f80:	082010bc 	xorhi	zero,at,32834
 8200f84:	082010bc 	xorhi	zero,at,32834
 8200f88:	082010bc 	xorhi	zero,at,32834
 8200f8c:	082010bc 	xorhi	zero,at,32834
 8200f90:	082010bc 	xorhi	zero,at,32834
 8200f94:	082010bc 	xorhi	zero,at,32834
 8200f98:	082010bc 	xorhi	zero,at,32834
 8200f9c:	082010bc 	xorhi	zero,at,32834
 8200fa0:	082010bc 	xorhi	zero,at,32834
 8200fa4:	082010bc 	xorhi	zero,at,32834
 8200fa8:	082010bc 	xorhi	zero,at,32834
 8200fac:	082010bc 	xorhi	zero,at,32834
 8200fb0:	082010bc 	xorhi	zero,at,32834
 8200fb4:	082010bc 	xorhi	zero,at,32834
 8200fb8:	082010bc 	xorhi	zero,at,32834
 8200fbc:	082010bc 	xorhi	zero,at,32834
 8200fc0:	082010bc 	xorhi	zero,at,32834
 8200fc4:	082010bc 	xorhi	zero,at,32834
 8200fc8:	082010bc 	xorhi	zero,at,32834
 8200fcc:	082010bc 	xorhi	zero,at,32834
 8200fd0:	082010bc 	xorhi	zero,at,32834
 8200fd4:	082010bc 	xorhi	zero,at,32834
 8200fd8:	082010bc 	xorhi	zero,at,32834
 8200fdc:	082010bc 	xorhi	zero,at,32834
 8200fe0:	082010bc 	xorhi	zero,at,32834
 8200fe4:	082010bc 	xorhi	zero,at,32834
 8200fe8:	082010bc 	xorhi	zero,at,32834
 8200fec:	08201050 	cmplti	zero,at,-32703
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 8200ff0:	01000044 	movi	r4,1
 8200ff4:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8200ff8:	00003106 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 8200ffc:	01000084 	movi	r4,2
 8201000:	8200d980 	call	8200d98 <led_bit_toggle>
         break;   
 8201004:	00002e06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 8201008:	01000104 	movi	r4,4
 820100c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201010:	00002b06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 8201014:	01000204 	movi	r4,8
 8201018:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820101c:	00002806 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 8201020:	01000404 	movi	r4,16
 8201024:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201028:	00002506 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 820102c:	01000804 	movi	r4,32
 8201030:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201034:	00002206 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 8201038:	01001004 	movi	r4,64
 820103c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201040:	00001f06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 8201044:	01002004 	movi	r4,128
 8201048:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820104c:	00001c06 	br	82010c0 <LEDManagementTask+0x1d0>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 8201050:	e0bffd03 	ldbu	r2,-12(fp)
 8201054:	10000c1e 	bne	r2,zero,8201088 <LEDManagementTask+0x198>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 8201058:	d0a05b17 	ldw	r2,-32404(gp)
 820105c:	1009883a 	mov	r4,r2
 8201060:	821a1980 	call	821a198 <OSSemPost>
 8201064:	e0bfff05 	stb	r2,-4(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 8201068:	e0bfff03 	ldbu	r2,-4(fp)
 820106c:	10803fcc 	andi	r2,r2,255
 8201070:	000b883a 	mov	r5,zero
 8201074:	1009883a 	mov	r4,r2
 8201078:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 820107c:	00800044 	movi	r2,1
 8201080:	e0bffd05 	stb	r2,-12(fp)
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
             alt_uCOSIIErrorHandler(error_code, 0); 
             SSSLEDLightshowActive = OS_FALSE;
         }     
         break;
 8201084:	00000e06 	br	82010c0 <LEDManagementTask+0x1d0>
             alt_uCOSIIErrorHandler(error_code, 0);
             SSSLEDLightshowActive = OS_TRUE;
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8201088:	d0a05b17 	ldw	r2,-32404(gp)
 820108c:	e0ffff04 	addi	r3,fp,-4
 8201090:	180d883a 	mov	r6,r3
 8201094:	000b883a 	mov	r5,zero
 8201098:	1009883a 	mov	r4,r2
 820109c:	8219e200 	call	8219e20 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 82010a0:	e0bfff03 	ldbu	r2,-4(fp)
 82010a4:	10803fcc 	andi	r2,r2,255
 82010a8:	000b883a 	mov	r5,zero
 82010ac:	1009883a 	mov	r4,r2
 82010b0:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 82010b4:	e03ffd05 	stb	zero,-12(fp)
         }     
         break;
 82010b8:	00000106 	br	82010c0 <LEDManagementTask+0x1d0>
      default:     
        /* Discard unknown LED commands. */
        break;
 82010bc:	0001883a 	nop
    } /* switch led_command */
  } /* while(1) */
 82010c0:	003f9106 	br	8200f08 <LEDManagementTask+0x18>

082010c4 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 82010c4:	defffb04 	addi	sp,sp,-20
 82010c8:	dfc00415 	stw	ra,16(sp)
 82010cc:	df000315 	stw	fp,12(sp)
 82010d0:	df000304 	addi	fp,sp,12
 82010d4:	e13ffe15 	stw	r4,-8(fp)
 82010d8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 82010dc:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 82010e0:	e13fff17 	ldw	r4,-4(fp)
 82010e4:	82016140 	call	8201614 <get_board_mac_addr>
 82010e8:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 82010ec:	e0bffd17 	ldw	r2,-12(fp)
 82010f0:	10000326 	beq	r2,zero,8201100 <get_mac_addr+0x3c>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 82010f4:	e13fff17 	ldw	r4,-4(fp)
 82010f8:	82014d80 	call	82014d8 <generate_mac_addr>
 82010fc:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 8201100:	e0bffd17 	ldw	r2,-12(fp)
}
 8201104:	e037883a 	mov	sp,fp
 8201108:	dfc00117 	ldw	ra,4(sp)
 820110c:	df000017 	ldw	fp,0(sp)
 8201110:	dec00204 	addi	sp,sp,8
 8201114:	f800283a 	ret

08201118 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 8201118:	defffb04 	addi	sp,sp,-20
 820111c:	df000415 	stw	fp,16(sp)
 8201120:	df000404 	addi	fp,sp,16
 8201124:	e13ffc15 	stw	r4,-16(fp)
 8201128:	e17ffd15 	stw	r5,-12(fp)
 820112c:	e1bffe15 	stw	r6,-8(fp)
 8201130:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 8201134:	e0bffd17 	ldw	r2,-12(fp)
 8201138:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 820113c:	e0bfff17 	ldw	r2,-4(fp)
 8201140:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 8201144:	e0fffe17 	ldw	r3,-8(fp)
 8201148:	00804034 	movhi	r2,256
 820114c:	10bfffc4 	addi	r2,r2,-1
 8201150:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 8201154:	e0800117 	ldw	r2,4(fp)
 8201158:	00c00044 	movi	r3,1
 820115c:	10c00015 	stw	r3,0(r2)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 8201160:	00800044 	movi	r2,1
}
 8201164:	e037883a 	mov	sp,fp
 8201168:	df000017 	ldw	fp,0(sp)
 820116c:	dec00104 	addi	sp,sp,4
 8201170:	f800283a 	ret

08201174 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 8201174:	defff904 	addi	sp,sp,-28
 8201178:	dfc00615 	stw	ra,24(sp)
 820117c:	df000515 	stw	fp,20(sp)
 8201180:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 8201184:	e03ffb15 	stw	zero,-20(fp)
    char serial_number[9];
    int i = 0;
 8201188:	e03ffc15 	stw	zero,-16(fp)
    
    while(!ser_num)
 820118c:	00006006 	br	8201310 <get_serial_number+0x19c>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 8201190:	01020974 	movhi	r4,2085
 8201194:	21320004 	addi	r4,r4,-14336
 8201198:	82033700 	call	8203370 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 820119c:	01020974 	movhi	r4,2085
 82011a0:	21321004 	addi	r4,r4,-14272
 82011a4:	82033700 	call	8203370 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 82011a8:	01020974 	movhi	r4,2085
 82011ac:	21322004 	addi	r4,r4,-14208
 82011b0:	82030ec0 	call	82030ec <printf>
        
        for(i=0; i<9; i++)
 82011b4:	e03ffc15 	stw	zero,-16(fp)
 82011b8:	00002606 	br	8201254 <get_serial_number+0xe0>
        {
            serial_number[i] = getchar();
 82011bc:	d0a00217 	ldw	r2,-32760(gp)
 82011c0:	10800117 	ldw	r2,4(r2)
 82011c4:	1009883a 	mov	r4,r2
 82011c8:	8202bd40 	call	8202bd4 <getc>
 82011cc:	1009883a 	mov	r4,r2
 82011d0:	e0fffd04 	addi	r3,fp,-12
 82011d4:	e0bffc17 	ldw	r2,-16(fp)
 82011d8:	1885883a 	add	r2,r3,r2
 82011dc:	11000005 	stb	r4,0(r2)
            putchar(serial_number[i]);
 82011e0:	e0fffd04 	addi	r3,fp,-12
 82011e4:	e0bffc17 	ldw	r2,-16(fp)
 82011e8:	1885883a 	add	r2,r3,r2
 82011ec:	10800003 	ldbu	r2,0(r2)
 82011f0:	10c03fcc 	andi	r3,r2,255
 82011f4:	18c0201c 	xori	r3,r3,128
 82011f8:	18ffe004 	addi	r3,r3,-128
 82011fc:	d0a00217 	ldw	r2,-32760(gp)
 8201200:	10800217 	ldw	r2,8(r2)
 8201204:	100b883a 	mov	r5,r2
 8201208:	1809883a 	mov	r4,r3
 820120c:	82031c80 	call	82031c8 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 8201210:	e0fffd04 	addi	r3,fp,-12
 8201214:	e0bffc17 	ldw	r2,-16(fp)
 8201218:	1885883a 	add	r2,r3,r2
 820121c:	10800003 	ldbu	r2,0(r2)
 8201220:	10803fcc 	andi	r2,r2,255
 8201224:	1080201c 	xori	r2,r2,128
 8201228:	10bfe004 	addi	r2,r2,-128
 820122c:	10800218 	cmpnei	r2,r2,8
 8201230:	1000051e 	bne	r2,zero,8201248 <get_serial_number+0xd4>
 8201234:	e0bffc17 	ldw	r2,-16(fp)
 8201238:	10000316 	blt	r2,zero,8201248 <get_serial_number+0xd4>
            {
                i--;
 820123c:	e0bffc17 	ldw	r2,-16(fp)
 8201240:	10bfffc4 	addi	r2,r2,-1
 8201244:	e0bffc15 	stw	r2,-16(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 8201248:	e0bffc17 	ldw	r2,-16(fp)
 820124c:	10800044 	addi	r2,r2,1
 8201250:	e0bffc15 	stw	r2,-16(fp)
 8201254:	e0bffc17 	ldw	r2,-16(fp)
 8201258:	10800250 	cmplti	r2,r2,9
 820125c:	103fd71e 	bne	r2,zero,82011bc <get_serial_number+0x48>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 8201260:	01000284 	movi	r4,10
 8201264:	82032980 	call	8203298 <putchar>
                
        for(i=0; i<9; i++)
 8201268:	e03ffc15 	stw	zero,-16(fp)
 820126c:	00002506 	br	8201304 <get_serial_number+0x190>
        {
            if (isdigit(serial_number[i]))
 8201270:	d0e00017 	ldw	r3,-32768(gp)
 8201274:	e13ffd04 	addi	r4,fp,-12
 8201278:	e0bffc17 	ldw	r2,-16(fp)
 820127c:	2085883a 	add	r2,r4,r2
 8201280:	10800003 	ldbu	r2,0(r2)
 8201284:	10803fcc 	andi	r2,r2,255
 8201288:	1080201c 	xori	r2,r2,128
 820128c:	10bfe004 	addi	r2,r2,-128
 8201290:	10800044 	addi	r2,r2,1
 8201294:	1885883a 	add	r2,r3,r2
 8201298:	10800003 	ldbu	r2,0(r2)
 820129c:	10803fcc 	andi	r2,r2,255
 82012a0:	1080010c 	andi	r2,r2,4
 82012a4:	10000f26 	beq	r2,zero,82012e4 <get_serial_number+0x170>
            {
                ser_num *= 10;
 82012a8:	e0bffb17 	ldw	r2,-20(fp)
 82012ac:	108002a4 	muli	r2,r2,10
 82012b0:	e0bffb15 	stw	r2,-20(fp)
                ser_num += serial_number[i] - '0';
 82012b4:	e0fffd04 	addi	r3,fp,-12
 82012b8:	e0bffc17 	ldw	r2,-16(fp)
 82012bc:	1885883a 	add	r2,r3,r2
 82012c0:	10800003 	ldbu	r2,0(r2)
 82012c4:	10c03fcc 	andi	r3,r2,255
 82012c8:	18c0201c 	xori	r3,r3,128
 82012cc:	18ffe004 	addi	r3,r3,-128
 82012d0:	e0bffb17 	ldw	r2,-20(fp)
 82012d4:	1885883a 	add	r2,r3,r2
 82012d8:	10bff404 	addi	r2,r2,-48
 82012dc:	e0bffb15 	stw	r2,-20(fp)
 82012e0:	00000506 	br	82012f8 <get_serial_number+0x184>
            }
            else
            {
                ser_num = 0;
 82012e4:	e03ffb15 	stw	zero,-20(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 82012e8:	01020974 	movhi	r4,2085
 82012ec:	21322e04 	addi	r4,r4,-14152
 82012f0:	82033700 	call	8203370 <puts>
                break;
 82012f4:	00000606 	br	8201310 <get_serial_number+0x19c>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 82012f8:	e0bffc17 	ldw	r2,-16(fp)
 82012fc:	10800044 	addi	r2,r2,1
 8201300:	e0bffc15 	stw	r2,-16(fp)
 8201304:	e0bffc17 	ldw	r2,-16(fp)
 8201308:	10800250 	cmplti	r2,r2,9
 820130c:	103fd81e 	bne	r2,zero,8201270 <get_serial_number+0xfc>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 8201310:	e0bffb17 	ldw	r2,-20(fp)
 8201314:	103f9e26 	beq	r2,zero,8201190 <get_serial_number+0x1c>
                break;
            }
        }
    }
    
    return ser_num;
 8201318:	e0bffb17 	ldw	r2,-20(fp)
}
 820131c:	e037883a 	mov	sp,fp
 8201320:	dfc00117 	ldw	ra,4(sp)
 8201324:	df000017 	ldw	fp,0(sp)
 8201328:	dec00204 	addi	sp,sp,8
 820132c:	f800283a 	ret

08201330 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 8201330:	deffef04 	addi	sp,sp,-68
 8201334:	dfc01015 	stw	ra,64(sp)
 8201338:	df000f15 	stw	fp,60(sp)
 820133c:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 8201340:	00bfffc4 	movi	r2,-1
 8201344:	e0bff115 	stw	r2,-60(fp)
    alt_u32 ser_num = 0;
 8201348:	e03ff215 	stw	zero,-56(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 820134c:	01020974 	movhi	r4,2085
 8201350:	21323d04 	addi	r4,r4,-14092
 8201354:	82033700 	call	8203370 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 8201358:	01020974 	movhi	r4,2085
 820135c:	21324d04 	addi	r4,r4,-14028
 8201360:	82033700 	call	8203370 <puts>
    printf("static network settings\n\n");
 8201364:	01020974 	movhi	r4,2085
 8201368:	21325e04 	addi	r4,r4,-13960
 820136c:	82033700 	call	8203370 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201370:	0081d734 	movhi	r2,1884
 8201374:	10b34544 	addi	r2,r2,-13035
 8201378:	e0bff215 	stw	r2,-56(fp)
  
    if (ser_num)
 820137c:	e0bff217 	ldw	r2,-56(fp)
 8201380:	10004f26 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 8201384:	00bfff84 	movi	r2,-2
 8201388:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 820138c:	00801684 	movi	r2,90
 8201390:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 8201394:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 8201398:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 820139c:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 82013a0:	008001c4 	movi	r2,7
 82013a4:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 82013a8:	00bffb44 	movi	r2,-19
 82013ac:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 82013b0:	00bfffc4 	movi	r2,-1
 82013b4:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 82013b8:	e0bff217 	ldw	r2,-56(fp)
 82013bc:	10bfc00c 	andi	r2,r2,65280
 82013c0:	1004d23a 	srli	r2,r2,8
 82013c4:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 82013c8:	e0bff217 	ldw	r2,-56(fp)
 82013cc:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 82013d0:	00bfffc4 	movi	r2,-1
 82013d4:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 82013d8:	00bfffc4 	movi	r2,-1
 82013dc:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 82013e0:	e03ffb05 	stb	zero,-20(fp)
        flash_content[13] = IPADDR1;
 82013e4:	e03ffb45 	stb	zero,-19(fp)
        flash_content[14] = IPADDR2;
 82013e8:	e03ffb85 	stb	zero,-18(fp)
        flash_content[15] = IPADDR3;
 82013ec:	e03ffbc5 	stb	zero,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 82013f0:	00bfffc4 	movi	r2,-1
 82013f4:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 82013f8:	00bfffc4 	movi	r2,-1
 82013fc:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 8201400:	00bfffc4 	movi	r2,-1
 8201404:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 8201408:	00bfffc4 	movi	r2,-1
 820140c:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 8201410:	00bfffc4 	movi	r2,-1
 8201414:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 8201418:	00bfffc4 	movi	r2,-1
 820141c:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 8201420:	00bfffc4 	movi	r2,-1
 8201424:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 8201428:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 820142c:	e03ffe05 	stb	zero,-8(fp)
        flash_content[25] = GWADDR1;
 8201430:	e03ffe45 	stb	zero,-7(fp)
        flash_content[26] = GWADDR2;
 8201434:	e03ffe85 	stb	zero,-6(fp)
        flash_content[27] = GWADDR3;
 8201438:	e03ffec5 	stb	zero,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 820143c:	00bfffc4 	movi	r2,-1
 8201440:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 8201444:	00bfffc4 	movi	r2,-1
 8201448:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 820144c:	00bfffc4 	movi	r2,-1
 8201450:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 8201454:	00bfffc4 	movi	r2,-1
 8201458:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 820145c:	01020974 	movhi	r4,2085
 8201460:	21326504 	addi	r4,r4,-13932
 8201464:	821411c0 	call	821411c <alt_flash_open_dev>
 8201468:	e0bff315 	stw	r2,-52(fp)
        if (flash_handle)
 820146c:	e0bff317 	ldw	r2,-52(fp)
 8201470:	10001326 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
        {
            alt_write_flash(flash_handle,
 8201474:	d0a05717 	ldw	r2,-32420(gp)
 8201478:	1007883a 	mov	r3,r2
 820147c:	e0bff317 	ldw	r2,-52(fp)
 8201480:	e0bff415 	stw	r2,-48(fp)
 8201484:	e0fff515 	stw	r3,-44(fp)
 8201488:	e0bff804 	addi	r2,fp,-32
 820148c:	e0bff615 	stw	r2,-40(fp)
 8201490:	00800804 	movi	r2,32
 8201494:	e0bff715 	stw	r2,-36(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 8201498:	e0bff417 	ldw	r2,-48(fp)
 820149c:	10800517 	ldw	r2,20(r2)
 82014a0:	e1fff717 	ldw	r7,-36(fp)
 82014a4:	e1bff617 	ldw	r6,-40(fp)
 82014a8:	e17ff517 	ldw	r5,-44(fp)
 82014ac:	e13ff417 	ldw	r4,-48(fp)
 82014b0:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 82014b4:	e13ff317 	ldw	r4,-52(fp)
 82014b8:	82141840 	call	8214184 <alt_flash_close_dev>
            error = 0;
 82014bc:	e03ff115 	stw	zero,-60(fp)
        }
    }

    return error;    
 82014c0:	e0bff117 	ldw	r2,-60(fp)
}
 82014c4:	e037883a 	mov	sp,fp
 82014c8:	dfc00117 	ldw	ra,4(sp)
 82014cc:	df000017 	ldw	fp,0(sp)
 82014d0:	dec00204 	addi	sp,sp,8
 82014d4:	f800283a 	ret

082014d8 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 82014d8:	defff804 	addi	sp,sp,-32
 82014dc:	dfc00715 	stw	ra,28(sp)
 82014e0:	df000615 	stw	fp,24(sp)
 82014e4:	df000604 	addi	fp,sp,24
 82014e8:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 82014ec:	00bfffc4 	movi	r2,-1
 82014f0:	e0bffd15 	stw	r2,-12(fp)
    alt_u32 ser_num = 0;
 82014f4:	e03ffe15 	stw	zero,-8(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 82014f8:	01020974 	movhi	r4,2085
 82014fc:	21326904 	addi	r4,r4,-13916
 8201500:	82033700 	call	8203370 <puts>
    printf("a MAC address.\n\n");
 8201504:	01020974 	movhi	r4,2085
 8201508:	21327904 	addi	r4,r4,-13852
 820150c:	82033700 	call	8203370 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201510:	0081d734 	movhi	r2,1884
 8201514:	10b34544 	addi	r2,r2,-13035
 8201518:	e0bffe15 	stw	r2,-8(fp)
  
    if (ser_num)
 820151c:	e0bffe17 	ldw	r2,-8(fp)
 8201520:	10003626 	beq	r2,zero,82015fc <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 8201524:	e0bfff17 	ldw	r2,-4(fp)
 8201528:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 820152c:	e0bfff17 	ldw	r2,-4(fp)
 8201530:	10800044 	addi	r2,r2,1
 8201534:	00c001c4 	movi	r3,7
 8201538:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = 0xed;
 820153c:	e0bfff17 	ldw	r2,-4(fp)
 8201540:	10800084 	addi	r2,r2,2
 8201544:	00fffb44 	movi	r3,-19
 8201548:	10c00005 	stb	r3,0(r2)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 820154c:	e0bfff17 	ldw	r2,-4(fp)
 8201550:	108000c4 	addi	r2,r2,3
 8201554:	00ffffc4 	movi	r3,-1
 8201558:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 820155c:	e0bfff17 	ldw	r2,-4(fp)
 8201560:	10800104 	addi	r2,r2,4
 8201564:	e0fffe17 	ldw	r3,-8(fp)
 8201568:	18ffc00c 	andi	r3,r3,65280
 820156c:	1806d23a 	srli	r3,r3,8
 8201570:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = ser_num & 0xff;
 8201574:	e0bfff17 	ldw	r2,-4(fp)
 8201578:	10800144 	addi	r2,r2,5
 820157c:	e0fffe17 	ldw	r3,-8(fp)
 8201580:	10c00005 	stb	r3,0(r2)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201584:	e0bfff17 	ldw	r2,-4(fp)
 8201588:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820158c:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 8201590:	e0bfff17 	ldw	r2,-4(fp)
 8201594:	10800044 	addi	r2,r2,1
 8201598:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820159c:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 82015a0:	e0bfff17 	ldw	r2,-4(fp)
 82015a4:	10800084 	addi	r2,r2,2
 82015a8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015ac:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 82015b0:	e0bfff17 	ldw	r2,-4(fp)
 82015b4:	108000c4 	addi	r2,r2,3
 82015b8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015bc:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 82015c0:	e0ffff17 	ldw	r3,-4(fp)
 82015c4:	18c00104 	addi	r3,r3,4
 82015c8:	18c00003 	ldbu	r3,0(r3)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015cc:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 82015d0:	e13fff17 	ldw	r4,-4(fp)
 82015d4:	21000144 	addi	r4,r4,5
 82015d8:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015dc:	21003fcc 	andi	r4,r4,255
 82015e0:	d9000215 	stw	r4,8(sp)
 82015e4:	d8c00115 	stw	r3,4(sp)
 82015e8:	d8800015 	stw	r2,0(sp)
 82015ec:	01020974 	movhi	r4,2085
 82015f0:	21327d04 	addi	r4,r4,-13836
 82015f4:	82030ec0 	call	82030ec <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 82015f8:	e03ffd15 	stw	zero,-12(fp)
    }
  
    return error;    
 82015fc:	e0bffd17 	ldw	r2,-12(fp)
}
 8201600:	e037883a 	mov	sp,fp
 8201604:	dfc00117 	ldw	ra,4(sp)
 8201608:	df000017 	ldw	fp,0(sp)
 820160c:	dec00204 	addi	sp,sp,8
 8201610:	f800283a 	ret

08201614 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 8201614:	defff804 	addi	sp,sp,-32
 8201618:	dfc00715 	stw	ra,28(sp)
 820161c:	df000615 	stw	fp,24(sp)
 8201620:	df000604 	addi	fp,sp,24
 8201624:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 8201628:	e03ffd15 	stw	zero,-12(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 820162c:	d1205704 	addi	r4,gp,-32420
 8201630:	82017ac0 	call	82017ac <FindLastFlashSectorOffset>
 8201634:	e0bffd15 	stw	r2,-12(fp)
    if (!error)
 8201638:	e0bffd17 	ldw	r2,-12(fp)
 820163c:	1000021e 	bne	r2,zero,8201648 <get_board_mac_addr+0x34>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 8201640:	d0a05717 	ldw	r2,-32420(gp)
 8201644:	d0a05815 	stw	r2,-32416(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 8201648:	e0bffd17 	ldw	r2,-12(fp)
 820164c:	1000081e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 8201650:	d0a05817 	ldw	r2,-32416(gp)
 8201654:	10800037 	ldwio	r2,0(r2)
 8201658:	e0bffe15 	stw	r2,-8(fp)
        if (signature != 0x00005afe)
 820165c:	e0bffe17 	ldw	r2,-8(fp)
 8201660:	1096bfa0 	cmpeqi	r2,r2,23294
 8201664:	1000021e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
        {
          error = generate_and_store_mac_addr();
 8201668:	82013300 	call	8201330 <generate_and_store_mac_addr>
 820166c:	e0bffd15 	stw	r2,-12(fp)
        }
    }
  
    if (!error)
 8201670:	e0bffd17 	ldw	r2,-12(fp)
 8201674:	1000471e 	bne	r2,zero,8201794 <get_board_mac_addr+0x180>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 8201678:	d0a05817 	ldw	r2,-32416(gp)
 820167c:	10800104 	addi	r2,r2,4
 8201680:	10800023 	ldbuio	r2,0(r2)
 8201684:	10803fcc 	andi	r2,r2,255
 8201688:	1007883a 	mov	r3,r2
 820168c:	e0bfff17 	ldw	r2,-4(fp)
 8201690:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 8201694:	e0bfff17 	ldw	r2,-4(fp)
 8201698:	10800044 	addi	r2,r2,1
 820169c:	d0e05817 	ldw	r3,-32416(gp)
 82016a0:	18c00144 	addi	r3,r3,5
 82016a4:	18c00023 	ldbuio	r3,0(r3)
 82016a8:	18c03fcc 	andi	r3,r3,255
 82016ac:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 82016b0:	e0bfff17 	ldw	r2,-4(fp)
 82016b4:	10800084 	addi	r2,r2,2
 82016b8:	d0e05817 	ldw	r3,-32416(gp)
 82016bc:	18c00184 	addi	r3,r3,6
 82016c0:	18c00023 	ldbuio	r3,0(r3)
 82016c4:	18c03fcc 	andi	r3,r3,255
 82016c8:	10c00005 	stb	r3,0(r2)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 82016cc:	e0bfff17 	ldw	r2,-4(fp)
 82016d0:	108000c4 	addi	r2,r2,3
 82016d4:	d0e05817 	ldw	r3,-32416(gp)
 82016d8:	18c001c4 	addi	r3,r3,7
 82016dc:	18c00023 	ldbuio	r3,0(r3)
 82016e0:	18c03fcc 	andi	r3,r3,255
 82016e4:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 82016e8:	e0bfff17 	ldw	r2,-4(fp)
 82016ec:	10800104 	addi	r2,r2,4
 82016f0:	d0e05817 	ldw	r3,-32416(gp)
 82016f4:	18c00204 	addi	r3,r3,8
 82016f8:	18c00023 	ldbuio	r3,0(r3)
 82016fc:	18c03fcc 	andi	r3,r3,255
 8201700:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 8201704:	e0bfff17 	ldw	r2,-4(fp)
 8201708:	10800144 	addi	r2,r2,5
 820170c:	d0e05817 	ldw	r3,-32416(gp)
 8201710:	18c00244 	addi	r3,r3,9
 8201714:	18c00023 	ldbuio	r3,0(r3)
 8201718:	18c03fcc 	andi	r3,r3,255
 820171c:	10c00005 	stb	r3,0(r2)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201720:	e0bfff17 	ldw	r2,-4(fp)
 8201724:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201728:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 820172c:	e0bfff17 	ldw	r2,-4(fp)
 8201730:	10800044 	addi	r2,r2,1
 8201734:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201738:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 820173c:	e0bfff17 	ldw	r2,-4(fp)
 8201740:	10800084 	addi	r2,r2,2
 8201744:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201748:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 820174c:	e0bfff17 	ldw	r2,-4(fp)
 8201750:	108000c4 	addi	r2,r2,3
 8201754:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201758:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 820175c:	e0ffff17 	ldw	r3,-4(fp)
 8201760:	18c00104 	addi	r3,r3,4
 8201764:	18c00003 	ldbu	r3,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201768:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 820176c:	e13fff17 	ldw	r4,-4(fp)
 8201770:	21000144 	addi	r4,r4,5
 8201774:	21000003 	ldbu	r4,0(r4)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201778:	21003fcc 	andi	r4,r4,255
 820177c:	d9000215 	stw	r4,8(sp)
 8201780:	d8c00115 	stw	r3,4(sp)
 8201784:	d8800015 	stw	r2,0(sp)
 8201788:	01020974 	movhi	r4,2085
 820178c:	21327d04 	addi	r4,r4,-13836
 8201790:	82030ec0 	call	82030ec <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 8201794:	e0bffd17 	ldw	r2,-12(fp)
}
 8201798:	e037883a 	mov	sp,fp
 820179c:	dfc00117 	ldw	ra,4(sp)
 82017a0:	df000017 	ldw	fp,0(sp)
 82017a4:	dec00204 	addi	sp,sp,8
 82017a8:	f800283a 	ret

082017ac <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 82017ac:	defff304 	addi	sp,sp,-52
 82017b0:	dfc00c15 	stw	ra,48(sp)
 82017b4:	df000b15 	stw	fp,44(sp)
 82017b8:	df000b04 	addi	fp,sp,44
 82017bc:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 82017c0:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 82017c4:	01020974 	movhi	r4,2085
 82017c8:	21326504 	addi	r4,r4,-13932
 82017cc:	821411c0 	call	821411c <alt_flash_open_dev>
 82017d0:	e0bff915 	stw	r2,-28(fp)
    if (fd <= 0)
 82017d4:	e0bff917 	ldw	r2,-28(fp)
 82017d8:	1000021e 	bne	r2,zero,82017e4 <FindLastFlashSectorOffset+0x38>
        error = -1;
 82017dc:	00bfffc4 	movi	r2,-1
 82017e0:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 82017e4:	e0bff817 	ldw	r2,-32(fp)
 82017e8:	10000d1e 	bne	r2,zero,8201820 <FindLastFlashSectorOffset+0x74>
 82017ec:	e0bff917 	ldw	r2,-28(fp)
 82017f0:	e0bffa15 	stw	r2,-24(fp)
 82017f4:	e0bffd04 	addi	r2,fp,-12
 82017f8:	e0bffb15 	stw	r2,-20(fp)
 82017fc:	e0bffe04 	addi	r2,fp,-8
 8201800:	e0bffc15 	stw	r2,-16(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 8201804:	e0bffa17 	ldw	r2,-24(fp)
 8201808:	10800717 	ldw	r2,28(r2)
 820180c:	e1bffc17 	ldw	r6,-16(fp)
 8201810:	e17ffb17 	ldw	r5,-20(fp)
 8201814:	e13ffa17 	ldw	r4,-24(fp)
 8201818:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 820181c:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 8201820:	e0bff817 	ldw	r2,-32(fp)
 8201824:	1000211e 	bne	r2,zero,82018ac <FindLastFlashSectorOffset+0x100>
    {
        pLastRegion = &(regions[0]);
 8201828:	e0bffd17 	ldw	r2,-12(fp)
 820182c:	e0bff515 	stw	r2,-44(fp)
        for (n = 1; n < numRegions; n++)
 8201830:	00800044 	movi	r2,1
 8201834:	e0bff715 	stw	r2,-36(fp)
 8201838:	00001006 	br	820187c <FindLastFlashSectorOffset+0xd0>
        {
            if (regions[n].offset > pLastRegion->offset)
 820183c:	e0fffd17 	ldw	r3,-12(fp)
 8201840:	e0bff717 	ldw	r2,-36(fp)
 8201844:	1004913a 	slli	r2,r2,4
 8201848:	1885883a 	add	r2,r3,r2
 820184c:	10800017 	ldw	r2,0(r2)
 8201850:	e0fff517 	ldw	r3,-44(fp)
 8201854:	18c00017 	ldw	r3,0(r3)
 8201858:	1880050e 	bge	r3,r2,8201870 <FindLastFlashSectorOffset+0xc4>
                pLastRegion = &(regions[n]);
 820185c:	e0fffd17 	ldw	r3,-12(fp)
 8201860:	e0bff717 	ldw	r2,-36(fp)
 8201864:	1004913a 	slli	r2,r2,4
 8201868:	1885883a 	add	r2,r3,r2
 820186c:	e0bff515 	stw	r2,-44(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 8201870:	e0bff717 	ldw	r2,-36(fp)
 8201874:	10800044 	addi	r2,r2,1
 8201878:	e0bff715 	stw	r2,-36(fp)
 820187c:	e0bffe17 	ldw	r2,-8(fp)
 8201880:	e0fff717 	ldw	r3,-36(fp)
 8201884:	18bfed16 	blt	r3,r2,820183c <FindLastFlashSectorOffset+0x90>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 8201888:	e0bff517 	ldw	r2,-44(fp)
 820188c:	10c00017 	ldw	r3,0(r2)
                                + pLastRegion->region_size
 8201890:	e0bff517 	ldw	r2,-44(fp)
 8201894:	10800117 	ldw	r2,4(r2)
 8201898:	1887883a 	add	r3,r3,r2
                                - pLastRegion->block_size;
 820189c:	e0bff517 	ldw	r2,-44(fp)
 82018a0:	10800317 	ldw	r2,12(r2)
        for (n = 1; n < numRegions; n++)
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 82018a4:	1885c83a 	sub	r2,r3,r2
 82018a8:	e0bff615 	stw	r2,-40(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 82018ac:	e0bff817 	ldw	r2,-32(fp)
 82018b0:	1000031e 	bne	r2,zero,82018c0 <FindLastFlashSectorOffset+0x114>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 82018b4:	e0fff617 	ldw	r3,-40(fp)
 82018b8:	e0bfff17 	ldw	r2,-4(fp)
 82018bc:	10c00015 	stw	r3,0(r2)

    return (error);
 82018c0:	e0bff817 	ldw	r2,-32(fp)
}
 82018c4:	e037883a 	mov	sp,fp
 82018c8:	dfc00117 	ldw	ra,4(sp)
 82018cc:	df000017 	ldw	fp,0(sp)
 82018d0:	dec00204 	addi	sp,sp,8
 82018d4:	f800283a 	ret

082018d8 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 82018d8:	defffd04 	addi	sp,sp,-12
 82018dc:	dfc00215 	stw	ra,8(sp)
 82018e0:	df000115 	stw	fp,4(sp)
 82018e4:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 82018e8:	01400784 	movi	r5,30
 82018ec:	010209b4 	movhi	r4,2086
 82018f0:	21213604 	addi	r4,r4,-31528
 82018f4:	8218a940 	call	8218a94 <OSQCreate>
 82018f8:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 82018fc:	d0a05a17 	ldw	r2,-32408(gp)
 8201900:	1000041e 	bne	r2,zero,8201914 <SSSCreateOSDataStructs+0x3c>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201904:	01420974 	movhi	r5,2085
 8201908:	29728c04 	addi	r5,r5,-13776
 820190c:	01003fc4 	movi	r4,255
 8201910:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 8201914:	01000044 	movi	r4,1
 8201918:	8219b080 	call	8219b08 <OSSemCreate>
 820191c:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 8201920:	d0a05b17 	ldw	r2,-32404(gp)
 8201924:	1000041e 	bne	r2,zero,8201938 <SSSCreateOSDataStructs+0x60>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201928:	01420974 	movhi	r5,2085
 820192c:	29729504 	addi	r5,r5,-13740
 8201930:	01003fc4 	movi	r4,255
 8201934:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 8201938:	e17fff04 	addi	r5,fp,-4
 820193c:	0009883a 	mov	r4,zero
 8201940:	8216df40 	call	8216df4 <OSFlagCreate>
 8201944:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 8201948:	d0a05c17 	ldw	r2,-32400(gp)
 820194c:	1000051e 	bne	r2,zero,8201964 <SSSCreateOSDataStructs+0x8c>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 8201950:	e0bfff03 	ldbu	r2,-4(fp)
 8201954:	10803fcc 	andi	r2,r2,255
 8201958:	000b883a 	mov	r5,zero
 820195c:	1009883a 	mov	r4,r2
 8201960:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  }
}
 8201964:	0001883a 	nop
 8201968:	e037883a 	mov	sp,fp
 820196c:	dfc00117 	ldw	ra,4(sp)
 8201970:	df000017 	ldw	fp,0(sp)
 8201974:	dec00204 	addi	sp,sp,8
 8201978:	f800283a 	ret

0820197c <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 820197c:	defff804 	addi	sp,sp,-32
 8201980:	dfc00715 	stw	ra,28(sp)
 8201984:	df000615 	stw	fp,24(sp)
 8201988:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 820198c:	d8000415 	stw	zero,16(sp)
 8201990:	d8000315 	stw	zero,12(sp)
 8201994:	00820004 	movi	r2,2048
 8201998:	d8800215 	stw	r2,8(sp)
 820199c:	00820974 	movhi	r2,2085
 82019a0:	10993604 	addi	r2,r2,25816
 82019a4:	d8800115 	stw	r2,4(sp)
 82019a8:	00800484 	movi	r2,18
 82019ac:	d8800015 	stw	r2,0(sp)
 82019b0:	01c00484 	movi	r7,18
 82019b4:	018209b4 	movhi	r6,2086
 82019b8:	31a13504 	addi	r6,r6,-31532
 82019bc:	000b883a 	mov	r5,zero
 82019c0:	01020834 	movhi	r4,2080
 82019c4:	21039f04 	addi	r4,r4,3708
 82019c8:	821ab540 	call	821ab54 <OSTaskCreateExt>
 82019cc:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 82019d0:	e0bfff03 	ldbu	r2,-4(fp)
 82019d4:	000b883a 	mov	r5,zero
 82019d8:	1009883a 	mov	r4,r2
 82019dc:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 82019e0:	d8000415 	stw	zero,16(sp)
 82019e4:	d8000315 	stw	zero,12(sp)
 82019e8:	00820004 	movi	r2,2048
 82019ec:	d8800215 	stw	r2,8(sp)
 82019f0:	008209b4 	movhi	r2,2086
 82019f4:	10a15404 	addi	r2,r2,-31408
 82019f8:	d8800115 	stw	r2,4(sp)
 82019fc:	008001c4 	movi	r2,7
 8201a00:	d8800015 	stw	r2,0(sp)
 8201a04:	01c001c4 	movi	r7,7
 8201a08:	018209b4 	movhi	r6,2086
 8201a0c:	31a95304 	addi	r6,r6,-23220
 8201a10:	000b883a 	mov	r5,zero
 8201a14:	01020834 	movhi	r4,2080
 8201a18:	2103bc04 	addi	r4,r4,3824
 8201a1c:	821ab540 	call	821ab54 <OSTaskCreateExt>
 8201a20:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 8201a24:	e0bfff03 	ldbu	r2,-4(fp)
 8201a28:	000b883a 	mov	r5,zero
 8201a2c:	1009883a 	mov	r4,r2
 8201a30:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

}
 8201a34:	0001883a 	nop
 8201a38:	e037883a 	mov	sp,fp
 8201a3c:	dfc00117 	ldw	ra,4(sp)
 8201a40:	df000017 	ldw	fp,0(sp)
 8201a44:	dec00204 	addi	sp,sp,8
 8201a48:	f800283a 	ret

08201a4c <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 8201a4c:	defffd04 	addi	sp,sp,-12
 8201a50:	dfc00215 	stw	ra,8(sp)
 8201a54:	df000115 	stw	fp,4(sp)
 8201a58:	df000104 	addi	fp,sp,4
 8201a5c:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 8201a60:	01817c04 	movi	r6,1520
 8201a64:	000b883a 	mov	r5,zero
 8201a68:	e13fff17 	ldw	r4,-4(fp)
 8201a6c:	8202f000 	call	8202f00 <memset>

  conn->fd = -1;
 8201a70:	e0bfff17 	ldw	r2,-4(fp)
 8201a74:	00ffffc4 	movi	r3,-1
 8201a78:	10c00115 	stw	r3,4(r2)
  conn->state = READY;
 8201a7c:	e0bfff17 	ldw	r2,-4(fp)
 8201a80:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 8201a84:	e0bfff17 	ldw	r2,-4(fp)
 8201a88:	10c00304 	addi	r3,r2,12
 8201a8c:	e0bfff17 	ldw	r2,-4(fp)
 8201a90:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 8201a94:	e0bfff17 	ldw	r2,-4(fp)
 8201a98:	10c00304 	addi	r3,r2,12
 8201a9c:	e0bfff17 	ldw	r2,-4(fp)
 8201aa0:	10c17a15 	stw	r3,1512(r2)
  return;
 8201aa4:	0001883a 	nop
}
 8201aa8:	e037883a 	mov	sp,fp
 8201aac:	dfc00117 	ldw	ra,4(sp)
 8201ab0:	df000017 	ldw	fp,0(sp)
 8201ab4:	dec00204 	addi	sp,sp,8
 8201ab8:	f800283a 	ret

08201abc <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 8201abc:	defe8504 	addi	sp,sp,-1516
 8201ac0:	dfc17a15 	stw	ra,1512(sp)
 8201ac4:	df017915 	stw	fp,1508(sp)
 8201ac8:	df017904 	addi	fp,sp,1508
 8201acc:	e13fff15 	stw	r4,-4(fp)
  char  tx_buf[SSS_TX_BUF_SIZE];
  char *tx_wr_pos = tx_buf;
 8201ad0:	e0be8804 	addi	r2,fp,-1504
 8201ad4:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201ad8:	e0fe8717 	ldw	r3,-1508(fp)
 8201adc:	00820974 	movhi	r2,2085
 8201ae0:	10b29f04 	addi	r2,r2,-13700
 8201ae4:	1009883a 	mov	r4,r2
 8201ae8:	00800904 	movi	r2,36
 8201aec:	100d883a 	mov	r6,r2
 8201af0:	200b883a 	mov	r5,r4
 8201af4:	1809883a 	mov	r4,r3
 8201af8:	8202c5c0 	call	8202c5c <memcpy>
 8201afc:	008008c4 	movi	r2,35
 8201b00:	1007883a 	mov	r3,r2
 8201b04:	e0be8717 	ldw	r2,-1508(fp)
 8201b08:	10c5883a 	add	r2,r2,r3
 8201b0c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Nios II Simple Socket Server Menu\n\r");
 8201b10:	e0fe8717 	ldw	r3,-1508(fp)
 8201b14:	00820974 	movhi	r2,2085
 8201b18:	10b2a804 	addi	r2,r2,-13664
 8201b1c:	1009883a 	mov	r4,r2
 8201b20:	00800904 	movi	r2,36
 8201b24:	100d883a 	mov	r6,r2
 8201b28:	200b883a 	mov	r5,r4
 8201b2c:	1809883a 	mov	r4,r3
 8201b30:	8202c5c0 	call	8202c5c <memcpy>
 8201b34:	008008c4 	movi	r2,35
 8201b38:	1007883a 	mov	r3,r2
 8201b3c:	e0be8717 	ldw	r2,-1508(fp)
 8201b40:	10c5883a 	add	r2,r2,r3
 8201b44:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201b48:	e0fe8717 	ldw	r3,-1508(fp)
 8201b4c:	00820974 	movhi	r2,2085
 8201b50:	10b29f04 	addi	r2,r2,-13700
 8201b54:	1009883a 	mov	r4,r2
 8201b58:	00800904 	movi	r2,36
 8201b5c:	100d883a 	mov	r6,r2
 8201b60:	200b883a 	mov	r5,r4
 8201b64:	1809883a 	mov	r4,r3
 8201b68:	8202c5c0 	call	8202c5c <memcpy>
 8201b6c:	008008c4 	movi	r2,35
 8201b70:	1007883a 	mov	r3,r2
 8201b74:	e0be8717 	ldw	r2,-1508(fp)
 8201b78:	10c5883a 	add	r2,r2,r3
 8201b7c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"0-7: Toggle board LEDs D0 - D7\n\r");
 8201b80:	e0fe8717 	ldw	r3,-1508(fp)
 8201b84:	00820974 	movhi	r2,2085
 8201b88:	10b2b104 	addi	r2,r2,-13628
 8201b8c:	1009883a 	mov	r4,r2
 8201b90:	00800844 	movi	r2,33
 8201b94:	100d883a 	mov	r6,r2
 8201b98:	200b883a 	mov	r5,r4
 8201b9c:	1809883a 	mov	r4,r3
 8201ba0:	8202c5c0 	call	8202c5c <memcpy>
 8201ba4:	00800804 	movi	r2,32
 8201ba8:	1007883a 	mov	r3,r2
 8201bac:	e0be8717 	ldw	r2,-1508(fp)
 8201bb0:	10c5883a 	add	r2,r2,r3
 8201bb4:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"S: 7-Segment LED Light Show\n\r");
 8201bb8:	e0fe8717 	ldw	r3,-1508(fp)
 8201bbc:	00820974 	movhi	r2,2085
 8201bc0:	10b2ba04 	addi	r2,r2,-13592
 8201bc4:	1009883a 	mov	r4,r2
 8201bc8:	00800784 	movi	r2,30
 8201bcc:	100d883a 	mov	r6,r2
 8201bd0:	200b883a 	mov	r5,r4
 8201bd4:	1809883a 	mov	r4,r3
 8201bd8:	8202c5c0 	call	8202c5c <memcpy>
 8201bdc:	00800744 	movi	r2,29
 8201be0:	1007883a 	mov	r3,r2
 8201be4:	e0be8717 	ldw	r2,-1508(fp)
 8201be8:	10c5883a 	add	r2,r2,r3
 8201bec:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Q: Terminate session\n\r");
 8201bf0:	e0fe8717 	ldw	r3,-1508(fp)
 8201bf4:	00820974 	movhi	r2,2085
 8201bf8:	10b2c204 	addi	r2,r2,-13560
 8201bfc:	1009883a 	mov	r4,r2
 8201c00:	008005c4 	movi	r2,23
 8201c04:	100d883a 	mov	r6,r2
 8201c08:	200b883a 	mov	r5,r4
 8201c0c:	1809883a 	mov	r4,r3
 8201c10:	8202c5c0 	call	8202c5c <memcpy>
 8201c14:	00800584 	movi	r2,22
 8201c18:	1007883a 	mov	r3,r2
 8201c1c:	e0be8717 	ldw	r2,-1508(fp)
 8201c20:	10c5883a 	add	r2,r2,r3
 8201c24:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201c28:	e0fe8717 	ldw	r3,-1508(fp)
 8201c2c:	00820974 	movhi	r2,2085
 8201c30:	10b29f04 	addi	r2,r2,-13700
 8201c34:	1009883a 	mov	r4,r2
 8201c38:	00800904 	movi	r2,36
 8201c3c:	100d883a 	mov	r6,r2
 8201c40:	200b883a 	mov	r5,r4
 8201c44:	1809883a 	mov	r4,r3
 8201c48:	8202c5c0 	call	8202c5c <memcpy>
 8201c4c:	008008c4 	movi	r2,35
 8201c50:	1007883a 	mov	r3,r2
 8201c54:	e0be8717 	ldw	r2,-1508(fp)
 8201c58:	10c5883a 	add	r2,r2,r3
 8201c5c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 8201c60:	e0fe8717 	ldw	r3,-1508(fp)
 8201c64:	00820974 	movhi	r2,2085
 8201c68:	10b2c804 	addi	r2,r2,-13536
 8201c6c:	1009883a 	mov	r4,r2
 8201c70:	00800904 	movi	r2,36
 8201c74:	100d883a 	mov	r6,r2
 8201c78:	200b883a 	mov	r5,r4
 8201c7c:	1809883a 	mov	r4,r3
 8201c80:	8202c5c0 	call	8202c5c <memcpy>
 8201c84:	008008c4 	movi	r2,35
 8201c88:	1007883a 	mov	r3,r2
 8201c8c:	e0be8717 	ldw	r2,-1508(fp)
 8201c90:	10c5883a 	add	r2,r2,r3
 8201c94:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 8201c98:	e0bfff17 	ldw	r2,-4(fp)
 8201c9c:	11000117 	ldw	r4,4(r2)
 8201ca0:	e0fe8717 	ldw	r3,-1508(fp)
 8201ca4:	e0be8804 	addi	r2,fp,-1504
 8201ca8:	1887c83a 	sub	r3,r3,r2
 8201cac:	e0be8804 	addi	r2,fp,-1504
 8201cb0:	000f883a 	mov	r7,zero
 8201cb4:	180d883a 	mov	r6,r3
 8201cb8:	100b883a 	mov	r5,r2
 8201cbc:	82312bc0 	call	82312bc <t_send>
  
  return;
 8201cc0:	0001883a 	nop
}
 8201cc4:	e037883a 	mov	sp,fp
 8201cc8:	dfc00117 	ldw	ra,4(sp)
 8201ccc:	df000017 	ldw	fp,0(sp)
 8201cd0:	dec00204 	addi	sp,sp,8
 8201cd4:	f800283a 	ret

08201cd8 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 8201cd8:	defff604 	addi	sp,sp,-40
 8201cdc:	dfc00915 	stw	ra,36(sp)
 8201ce0:	df000815 	stw	fp,32(sp)
 8201ce4:	df000804 	addi	fp,sp,32
 8201ce8:	e13ffe15 	stw	r4,-8(fp)
 8201cec:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 8201cf0:	00800404 	movi	r2,16
 8201cf4:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 8201cf8:	e0bfff17 	ldw	r2,-4(fp)
 8201cfc:	10800117 	ldw	r2,4(r2)
 8201d00:	10bfffd8 	cmpnei	r2,r2,-1
 8201d04:	10001a1e 	bne	r2,zero,8201d70 <sss_handle_accept+0x98>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 8201d08:	e0fff904 	addi	r3,fp,-28
 8201d0c:	e0bffa04 	addi	r2,fp,-24
 8201d10:	180d883a 	mov	r6,r3
 8201d14:	100b883a 	mov	r5,r2
 8201d18:	e13ffe17 	ldw	r4,-8(fp)
 8201d1c:	82279d40 	call	82279d4 <bsd_accept>
 8201d20:	e0bff815 	stw	r2,-32(fp)
 8201d24:	e0bff817 	ldw	r2,-32(fp)
 8201d28:	1000050e 	bge	r2,zero,8201d40 <sss_handle_accept+0x68>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 8201d2c:	01420974 	movhi	r5,2085
 8201d30:	2972d104 	addi	r5,r5,-13500
 8201d34:	01003fc4 	movi	r4,255
 8201d38:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201d3c:	00001306 	br	8201d8c <sss_handle_accept+0xb4>
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 8201d40:	e0bfff17 	ldw	r2,-4(fp)
 8201d44:	e0fff817 	ldw	r3,-32(fp)
 8201d48:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 8201d4c:	e13fff17 	ldw	r4,-4(fp)
 8201d50:	8201abc0 	call	8201abc <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 8201d54:	e13ffb17 	ldw	r4,-20(fp)
 8201d58:	822807c0 	call	822807c <bsd_inet_ntoa>
 8201d5c:	100b883a 	mov	r5,r2
 8201d60:	01020974 	movhi	r4,2085
 8201d64:	2132da04 	addi	r4,r4,-13464
 8201d68:	82030ec0 	call	82030ec <printf>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201d6c:	00000706 	br	8201d8c <sss_handle_accept+0xb4>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 8201d70:	e13ffb17 	ldw	r4,-20(fp)
 8201d74:	822807c0 	call	822807c <bsd_inet_ntoa>
 8201d78:	100b883a 	mov	r5,r2
 8201d7c:	01020974 	movhi	r4,2085
 8201d80:	2132e904 	addi	r4,r4,-13404
 8201d84:	82030ec0 	call	82030ec <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201d88:	0001883a 	nop
}
 8201d8c:	e037883a 	mov	sp,fp
 8201d90:	dfc00117 	ldw	ra,4(sp)
 8201d94:	df000017 	ldw	fp,0(sp)
 8201d98:	dec00204 	addi	sp,sp,8
 8201d9c:	f800283a 	ret

08201da0 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 8201da0:	defb9104 	addi	sp,sp,-4540
 8201da4:	dfc46e15 	stw	ra,4536(sp)
 8201da8:	df046d15 	stw	fp,4532(sp)
 8201dac:	df046d04 	addi	fp,sp,4532
 8201db0:	e13fff15 	stw	r4,-4(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 8201db4:	e0bfff17 	ldw	r2,-4(fp)
 8201db8:	10817b17 	ldw	r2,1516(r2)
 8201dbc:	1007883a 	mov	r3,r2
 8201dc0:	e0bfff17 	ldw	r2,-4(fp)
 8201dc4:	10817a17 	ldw	r2,1512(r2)
 8201dc8:	1885c83a 	sub	r2,r3,r2
 8201dcc:	e0bb9315 	stw	r2,-4532(fp)

   char  tx_buf[SSS_TX_BUF_SIZE];
   char *tx_wr_pos = tx_buf;
 8201dd0:	e0bb9a04 	addi	r2,fp,-4504
 8201dd4:	e0bb9415 	stw	r2,-4528(fp)

   char text_buf[SSS_TX_BUF_SIZE];
   char *text = text_buf;
 8201dd8:	e0bd1104 	addi	r2,fp,-3004
 8201ddc:	e0bb9515 	stw	r2,-4524(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 8201de0:	00800c04 	movi	r2,48
 8201de4:	d0a05915 	stw	r2,-32412(gp)



   while(bytes_to_process--)
 8201de8:	00002206 	br	8201e74 <sss_exec_command+0xd4>
   {
      SSSCommand = tolower(*(conn->rx_rd_pos++));
 8201dec:	e0bfff17 	ldw	r2,-4(fp)
 8201df0:	10817a17 	ldw	r2,1512(r2)
 8201df4:	11000044 	addi	r4,r2,1
 8201df8:	e0ffff17 	ldw	r3,-4(fp)
 8201dfc:	19017a15 	stw	r4,1512(r3)
 8201e00:	10800003 	ldbu	r2,0(r2)
 8201e04:	e0bb9885 	stb	r2,-4510(fp)
 8201e08:	d0e00017 	ldw	r3,-32768(gp)
 8201e0c:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e10:	10800044 	addi	r2,r2,1
 8201e14:	1885883a 	add	r2,r3,r2
 8201e18:	10800003 	ldbu	r2,0(r2)
 8201e1c:	10803fcc 	andi	r2,r2,255
 8201e20:	108000cc 	andi	r2,r2,3
 8201e24:	10800058 	cmpnei	r2,r2,1
 8201e28:	1000031e 	bne	r2,zero,8201e38 <sss_exec_command+0x98>
 8201e2c:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e30:	10800804 	addi	r2,r2,32
 8201e34:	00000106 	br	8201e3c <sss_exec_command+0x9c>
 8201e38:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e3c:	d0a05915 	stw	r2,-32412(gp)

	  text += sprintf(text,"%c",(char)SSSCommand);
 8201e40:	d0a05917 	ldw	r2,-32412(gp)
 8201e44:	10803fcc 	andi	r2,r2,255
 8201e48:	1080201c 	xori	r2,r2,128
 8201e4c:	10bfe004 	addi	r2,r2,-128
 8201e50:	100d883a 	mov	r6,r2
 8201e54:	01420974 	movhi	r5,2085
 8201e58:	2972f804 	addi	r5,r5,-13344
 8201e5c:	e13b9517 	ldw	r4,-4524(fp)
 8201e60:	82034640 	call	8203464 <sprintf>
 8201e64:	1007883a 	mov	r3,r2
 8201e68:	e0bb9517 	ldw	r2,-4524(fp)
 8201e6c:	10c5883a 	add	r2,r2,r3
 8201e70:	e0bb9515 	stw	r2,-4524(fp)
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;



   while(bytes_to_process--)
 8201e74:	e0bb9317 	ldw	r2,-4532(fp)
 8201e78:	10ffffc4 	addi	r3,r2,-1
 8201e7c:	e0fb9315 	stw	r3,-4532(fp)
 8201e80:	103fda1e 	bne	r2,zero,8201dec <sss_exec_command+0x4c>

	  text += sprintf(text,"%c",(char)SSSCommand);

   }

   alt_u8 startValue = IORD_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE);
 8201e84:	00824034 	movhi	r2,2304
 8201e88:	10801004 	addi	r2,r2,64
 8201e8c:	10800037 	ldwio	r2,0(r2)
 8201e90:	e0bb98c5 	stb	r2,-4509(fp)

   alt_u8 endValue = startValue;
 8201e94:	e0bb98c3 	ldbu	r2,-4509(fp)
 8201e98:	e0bb9605 	stb	r2,-4520(fp)

   if(strstr(text_buf, "acquire") != NULL){
 8201e9c:	e0bd1104 	addi	r2,fp,-3004
 8201ea0:	01420974 	movhi	r5,2085
 8201ea4:	2972f904 	addi	r5,r5,-13340
 8201ea8:	1009883a 	mov	r4,r2
 8201eac:	82041f80 	call	82041f8 <strstr>
 8201eb0:	10006b26 	beq	r2,zero,8202060 <sss_exec_command+0x2c0>
	   endValue ^= (-1 ^ endValue) & (1 << 0);
 8201eb4:	e0bb9603 	ldbu	r2,-4520(fp)
 8201eb8:	1080004c 	andi	r2,r2,1
 8201ebc:	1005003a 	cmpeq	r2,r2,zero
 8201ec0:	1007883a 	mov	r3,r2
 8201ec4:	e0bb9603 	ldbu	r2,-4520(fp)
 8201ec8:	1884f03a 	xor	r2,r3,r2
 8201ecc:	e0bb9605 	stb	r2,-4520(fp)


	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8201ed0:	e0fb9603 	ldbu	r3,-4520(fp)
 8201ed4:	00824034 	movhi	r2,2304
 8201ed8:	10801004 	addi	r2,r2,64
 8201edc:	10c00035 	stwio	r3,0(r2)


	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;
 8201ee0:	e0be8804 	addi	r2,fp,-1504
 8201ee4:	e0bb9715 	stw	r2,-4516(fp)



	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8201ee8:	00800044 	movi	r2,1
 8201eec:	e0bb980d 	sth	r2,-4512(fp)
 8201ef0:	00002c06 	br	8201fa4 <sss_exec_command+0x204>

		   //request the ith sample of the waveform
		   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, i);
 8201ef4:	e0fb980b 	ldhu	r3,-4512(fp)
 8201ef8:	00824034 	movhi	r2,2304
 8201efc:	10801804 	addi	r2,r2,96
 8201f00:	10c00035 	stwio	r3,0(r2)

		   //usleep(10);

		   alt_u16 sample = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8201f04:	00824034 	movhi	r2,2304
 8201f08:	10801404 	addi	r2,r2,80
 8201f0c:	10800037 	ldwio	r2,0(r2)
 8201f10:	e0bb990d 	sth	r2,-4508(fp)

		   //printf("%d\t", i);
		   //printf("%d\n", sample);

		   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\n", sample);
 8201f14:	e0bb990b 	ldhu	r2,-4508(fp)
 8201f18:	100d883a 	mov	r6,r2
 8201f1c:	01420974 	movhi	r5,2085
 8201f20:	2972fb04 	addi	r5,r5,-13332
 8201f24:	e13b9717 	ldw	r4,-4516(fp)
 8201f28:	82034640 	call	8203464 <sprintf>
 8201f2c:	1007883a 	mov	r3,r2
 8201f30:	e0bb9717 	ldw	r2,-4516(fp)
 8201f34:	10c5883a 	add	r2,r2,r3
 8201f38:	e0bb9715 	stw	r2,-4516(fp)

		   //send data every 100 samples.
		   if(i%100==0){
 8201f3c:	e0bb980b 	ldhu	r2,-4512(fp)
 8201f40:	01401904 	movi	r5,100
 8201f44:	1009883a 	mov	r4,r2
 8201f48:	82029c00 	call	82029c0 <__umodsi3>
 8201f4c:	10bfffcc 	andi	r2,r2,65535
 8201f50:	1000111e 	bne	r2,zero,8201f98 <sss_exec_command+0x1f8>
			   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 8201f54:	e0bfff17 	ldw	r2,-4(fp)
 8201f58:	11000117 	ldw	r4,4(r2)
 8201f5c:	e0fb9717 	ldw	r3,-4516(fp)
 8201f60:	e0be8804 	addi	r2,fp,-1504
 8201f64:	1887c83a 	sub	r3,r3,r2
 8201f68:	e0be8804 	addi	r2,fp,-1504
 8201f6c:	000f883a 	mov	r7,zero
 8201f70:	180d883a 	mov	r6,r3
 8201f74:	100b883a 	mov	r5,r2
 8201f78:	82312bc0 	call	82312bc <t_send>

			   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8201f7c:	e0be8804 	addi	r2,fp,-1504
 8201f80:	01817704 	movi	r6,1500
 8201f84:	000b883a 	mov	r5,zero
 8201f88:	1009883a 	mov	r4,r2
 8201f8c:	8202f000 	call	8202f00 <memset>
			   tx_wr_pos_data = tx_buf_data;
 8201f90:	e0be8804 	addi	r2,fp,-1504
 8201f94:	e0bb9715 	stw	r2,-4516(fp)
	   char *tx_wr_pos_data = tx_buf_data;



	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8201f98:	e0bb980b 	ldhu	r2,-4512(fp)
 8201f9c:	10800044 	addi	r2,r2,1
 8201fa0:	e0bb980d 	sth	r2,-4512(fp)
 8201fa4:	e0bb980b 	ldhu	r2,-4512(fp)
 8201fa8:	1080fa70 	cmpltui	r2,r2,1001
 8201fac:	103fd11e 	bne	r2,zero,8201ef4 <sss_exec_command+0x154>
			   tx_wr_pos_data = tx_buf_data;

		   }

	   }
	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 1001);
 8201fb0:	00c0fa44 	movi	r3,1001
 8201fb4:	00824034 	movhi	r2,2304
 8201fb8:	10801804 	addi	r2,r2,96
 8201fbc:	10c00035 	stwio	r3,0(r2)
	   //usleep(10);
	   alt_u16 waveNum = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8201fc0:	00824034 	movhi	r2,2304
 8201fc4:	10801404 	addi	r2,r2,80
 8201fc8:	10800037 	ldwio	r2,0(r2)
 8201fcc:	e0bb998d 	sth	r2,-4506(fp)
	   //printf("%d\n", waveNum);


	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 0);
 8201fd0:	0007883a 	mov	r3,zero
 8201fd4:	00824034 	movhi	r2,2304
 8201fd8:	10801804 	addi	r2,r2,96
 8201fdc:	10c00035 	stwio	r3,0(r2)

	   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8201fe0:	e0be8804 	addi	r2,fp,-1504
 8201fe4:	01817704 	movi	r6,1500
 8201fe8:	000b883a 	mov	r5,zero
 8201fec:	1009883a 	mov	r4,r2
 8201ff0:	8202f000 	call	8202f00 <memset>
	   tx_wr_pos_data = tx_buf_data;
 8201ff4:	e0be8804 	addi	r2,fp,-1504
 8201ff8:	e0bb9715 	stw	r2,-4516(fp)

	   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\ncomplete\n",waveNum);
 8201ffc:	e0bb998b 	ldhu	r2,-4506(fp)
 8202000:	100d883a 	mov	r6,r2
 8202004:	01420974 	movhi	r5,2085
 8202008:	2972fc04 	addi	r5,r5,-13328
 820200c:	e13b9717 	ldw	r4,-4516(fp)
 8202010:	82034640 	call	8203464 <sprintf>
 8202014:	1007883a 	mov	r3,r2
 8202018:	e0bb9717 	ldw	r2,-4516(fp)
 820201c:	10c5883a 	add	r2,r2,r3
 8202020:	e0bb9715 	stw	r2,-4516(fp)

	   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 8202024:	e0bfff17 	ldw	r2,-4(fp)
 8202028:	11000117 	ldw	r4,4(r2)
 820202c:	e0fb9717 	ldw	r3,-4516(fp)
 8202030:	e0be8804 	addi	r2,fp,-1504
 8202034:	1887c83a 	sub	r3,r3,r2
 8202038:	e0be8804 	addi	r2,fp,-1504
 820203c:	000f883a 	mov	r7,zero
 8202040:	180d883a 	mov	r6,r3
 8202044:	100b883a 	mov	r5,r2
 8202048:	82312bc0 	call	82312bc <t_send>

	   //reset the control pio

	   endValue ^= (-0 ^ endValue) & (1 << 0);
 820204c:	e0fb9603 	ldbu	r3,-4520(fp)
 8202050:	00bfff84 	movi	r2,-2
 8202054:	1884703a 	and	r2,r3,r2
 8202058:	e0bb9605 	stb	r2,-4520(fp)
 820205c:	00010406 	br	8202470 <sss_exec_command+0x6d0>
   } else if( strstr(text_buf, "delay")) {
 8202060:	e0bd1104 	addi	r2,fp,-3004
 8202064:	01420974 	movhi	r5,2085
 8202068:	29730004 	addi	r5,r5,-13312
 820206c:	1009883a 	mov	r4,r2
 8202070:	82041f80 	call	82041f8 <strstr>
 8202074:	10003526 	beq	r2,zero,820214c <sss_exec_command+0x3ac>
	   if ( strstr(text_buf, ":on")){
 8202078:	e0bd1104 	addi	r2,fp,-3004
 820207c:	01420974 	movhi	r5,2085
 8202080:	29730204 	addi	r5,r5,-13304
 8202084:	1009883a 	mov	r4,r2
 8202088:	82041f80 	call	82041f8 <strstr>
 820208c:	10001626 	beq	r2,zero,82020e8 <sss_exec_command+0x348>
		   tx_wr_pos += sprintf(tx_wr_pos, "Enabling delay\n");
 8202090:	e0fb9417 	ldw	r3,-4528(fp)
 8202094:	00820974 	movhi	r2,2085
 8202098:	10b30304 	addi	r2,r2,-13300
 820209c:	1009883a 	mov	r4,r2
 82020a0:	00800404 	movi	r2,16
 82020a4:	100d883a 	mov	r6,r2
 82020a8:	200b883a 	mov	r5,r4
 82020ac:	1809883a 	mov	r4,r3
 82020b0:	8202c5c0 	call	8202c5c <memcpy>
 82020b4:	008003c4 	movi	r2,15
 82020b8:	1007883a 	mov	r3,r2
 82020bc:	e0bb9417 	ldw	r2,-4528(fp)
 82020c0:	10c5883a 	add	r2,r2,r3
 82020c4:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-1 ^ endValue) & (1 << 3);
 82020c8:	e0bb9603 	ldbu	r2,-4520(fp)
 82020cc:	0084303a 	nor	r2,zero,r2
 82020d0:	1080020c 	andi	r2,r2,8
 82020d4:	1007883a 	mov	r3,r2
 82020d8:	e0bb9603 	ldbu	r2,-4520(fp)
 82020dc:	1884f03a 	xor	r2,r3,r2
 82020e0:	e0bb9605 	stb	r2,-4520(fp)
 82020e4:	0000e206 	br	8202470 <sss_exec_command+0x6d0>

	   } else if ( strstr(text_buf, ":off")){
 82020e8:	e0bd1104 	addi	r2,fp,-3004
 82020ec:	01420974 	movhi	r5,2085
 82020f0:	29730704 	addi	r5,r5,-13284
 82020f4:	1009883a 	mov	r4,r2
 82020f8:	82041f80 	call	82041f8 <strstr>
 82020fc:	1000dc26 	beq	r2,zero,8202470 <sss_exec_command+0x6d0>
		   tx_wr_pos += sprintf(tx_wr_pos, "Disabling delay\n");
 8202100:	e0fb9417 	ldw	r3,-4528(fp)
 8202104:	00820974 	movhi	r2,2085
 8202108:	10b30904 	addi	r2,r2,-13276
 820210c:	1009883a 	mov	r4,r2
 8202110:	00800444 	movi	r2,17
 8202114:	100d883a 	mov	r6,r2
 8202118:	200b883a 	mov	r5,r4
 820211c:	1809883a 	mov	r4,r3
 8202120:	8202c5c0 	call	8202c5c <memcpy>
 8202124:	00800404 	movi	r2,16
 8202128:	1007883a 	mov	r3,r2
 820212c:	e0bb9417 	ldw	r2,-4528(fp)
 8202130:	10c5883a 	add	r2,r2,r3
 8202134:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-0 ^ endValue) & (1 << 3);
 8202138:	e0fb9603 	ldbu	r3,-4520(fp)
 820213c:	00bffdc4 	movi	r2,-9
 8202140:	1884703a 	and	r2,r3,r2
 8202144:	e0bb9605 	stb	r2,-4520(fp)
 8202148:	0000c906 	br	8202470 <sss_exec_command+0x6d0>
	   }
   } else if( strstr(text_buf, "trig")) {
 820214c:	e0bd1104 	addi	r2,fp,-3004
 8202150:	01420974 	movhi	r5,2085
 8202154:	29730e04 	addi	r5,r5,-13256
 8202158:	1009883a 	mov	r4,r2
 820215c:	82041f80 	call	82041f8 <strstr>
 8202160:	10008926 	beq	r2,zero,8202388 <sss_exec_command+0x5e8>
	   if( strstr(text_buf, ":source")) {
 8202164:	e0bd1104 	addi	r2,fp,-3004
 8202168:	01420974 	movhi	r5,2085
 820216c:	29731004 	addi	r5,r5,-13248
 8202170:	1009883a 	mov	r4,r2
 8202174:	82041f80 	call	82041f8 <strstr>
 8202178:	10004826 	beq	r2,zero,820229c <sss_exec_command+0x4fc>
	   	   if ( strstr(text_buf, ":self")){
 820217c:	e0bd1104 	addi	r2,fp,-3004
 8202180:	01420974 	movhi	r5,2085
 8202184:	29731204 	addi	r5,r5,-13240
 8202188:	1009883a 	mov	r4,r2
 820218c:	82041f80 	call	82041f8 <strstr>
 8202190:	10002926 	beq	r2,zero,8202238 <sss_exec_command+0x498>
			   tx_wr_pos += sprintf(tx_wr_pos, "Self trigger\n");
 8202194:	e0bb9417 	ldw	r2,-4528(fp)
 8202198:	00c014c4 	movi	r3,83
 820219c:	10c00005 	stb	r3,0(r2)
 82021a0:	00c01944 	movi	r3,101
 82021a4:	10c00045 	stb	r3,1(r2)
 82021a8:	00c01b04 	movi	r3,108
 82021ac:	10c00085 	stb	r3,2(r2)
 82021b0:	00c01984 	movi	r3,102
 82021b4:	10c000c5 	stb	r3,3(r2)
 82021b8:	00c00804 	movi	r3,32
 82021bc:	10c00105 	stb	r3,4(r2)
 82021c0:	00c01d04 	movi	r3,116
 82021c4:	10c00145 	stb	r3,5(r2)
 82021c8:	00c01c84 	movi	r3,114
 82021cc:	10c00185 	stb	r3,6(r2)
 82021d0:	00c01a44 	movi	r3,105
 82021d4:	10c001c5 	stb	r3,7(r2)
 82021d8:	00c019c4 	movi	r3,103
 82021dc:	10c00205 	stb	r3,8(r2)
 82021e0:	00c019c4 	movi	r3,103
 82021e4:	10c00245 	stb	r3,9(r2)
 82021e8:	00c01944 	movi	r3,101
 82021ec:	10c00285 	stb	r3,10(r2)
 82021f0:	00c01c84 	movi	r3,114
 82021f4:	10c002c5 	stb	r3,11(r2)
 82021f8:	00c00284 	movi	r3,10
 82021fc:	10c00305 	stb	r3,12(r2)
 8202200:	10000345 	stb	zero,13(r2)
 8202204:	00800344 	movi	r2,13
 8202208:	1007883a 	mov	r3,r2
 820220c:	e0bb9417 	ldw	r2,-4528(fp)
 8202210:	10c5883a 	add	r2,r2,r3
 8202214:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-1 ^ endValue) & (1 << 1);
 8202218:	e0bb9603 	ldbu	r2,-4520(fp)
 820221c:	0084303a 	nor	r2,zero,r2
 8202220:	1080008c 	andi	r2,r2,2
 8202224:	1007883a 	mov	r3,r2
 8202228:	e0bb9603 	ldbu	r2,-4520(fp)
 820222c:	1884f03a 	xor	r2,r3,r2
 8202230:	e0bb9605 	stb	r2,-4520(fp)
 8202234:	00008e06 	br	8202470 <sss_exec_command+0x6d0>

	   	   } else if ( strstr(text_buf, ":ext")){
 8202238:	e0bd1104 	addi	r2,fp,-3004
 820223c:	01420974 	movhi	r5,2085
 8202240:	29731404 	addi	r5,r5,-13232
 8202244:	1009883a 	mov	r4,r2
 8202248:	82041f80 	call	82041f8 <strstr>
 820224c:	10008826 	beq	r2,zero,8202470 <sss_exec_command+0x6d0>
			   tx_wr_pos += sprintf(tx_wr_pos, "External trigger\n");
 8202250:	e0fb9417 	ldw	r3,-4528(fp)
 8202254:	00820974 	movhi	r2,2085
 8202258:	10b31604 	addi	r2,r2,-13224
 820225c:	1009883a 	mov	r4,r2
 8202260:	00800484 	movi	r2,18
 8202264:	100d883a 	mov	r6,r2
 8202268:	200b883a 	mov	r5,r4
 820226c:	1809883a 	mov	r4,r3
 8202270:	8202c5c0 	call	8202c5c <memcpy>
 8202274:	00800444 	movi	r2,17
 8202278:	1007883a 	mov	r3,r2
 820227c:	e0bb9417 	ldw	r2,-4528(fp)
 8202280:	10c5883a 	add	r2,r2,r3
 8202284:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-0 ^ endValue) & (1 << 1);
 8202288:	e0fb9603 	ldbu	r3,-4520(fp)
 820228c:	00bfff44 	movi	r2,-3
 8202290:	1884703a 	and	r2,r3,r2
 8202294:	e0bb9605 	stb	r2,-4520(fp)
 8202298:	00007506 	br	8202470 <sss_exec_command+0x6d0>
	   	   }
	   } else if( strstr(text_buf, ":slope")) {
 820229c:	e0bd1104 	addi	r2,fp,-3004
 82022a0:	01420974 	movhi	r5,2085
 82022a4:	29731b04 	addi	r5,r5,-13204
 82022a8:	1009883a 	mov	r4,r2
 82022ac:	82041f80 	call	82041f8 <strstr>
 82022b0:	10006f26 	beq	r2,zero,8202470 <sss_exec_command+0x6d0>
		   if ( strstr(text_buf, ":pos")){
 82022b4:	e0bd1104 	addi	r2,fp,-3004
 82022b8:	01420974 	movhi	r5,2085
 82022bc:	29731d04 	addi	r5,r5,-13196
 82022c0:	1009883a 	mov	r4,r2
 82022c4:	82041f80 	call	82041f8 <strstr>
 82022c8:	10001626 	beq	r2,zero,8202324 <sss_exec_command+0x584>
			   tx_wr_pos += sprintf(tx_wr_pos, "Positive trigger\n");
 82022cc:	e0fb9417 	ldw	r3,-4528(fp)
 82022d0:	00820974 	movhi	r2,2085
 82022d4:	10b31f04 	addi	r2,r2,-13188
 82022d8:	1009883a 	mov	r4,r2
 82022dc:	00800484 	movi	r2,18
 82022e0:	100d883a 	mov	r6,r2
 82022e4:	200b883a 	mov	r5,r4
 82022e8:	1809883a 	mov	r4,r3
 82022ec:	8202c5c0 	call	8202c5c <memcpy>
 82022f0:	00800444 	movi	r2,17
 82022f4:	1007883a 	mov	r3,r2
 82022f8:	e0bb9417 	ldw	r2,-4528(fp)
 82022fc:	10c5883a 	add	r2,r2,r3
 8202300:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-1 ^ endValue) & (1 << 2);
 8202304:	e0bb9603 	ldbu	r2,-4520(fp)
 8202308:	0084303a 	nor	r2,zero,r2
 820230c:	1080010c 	andi	r2,r2,4
 8202310:	1007883a 	mov	r3,r2
 8202314:	e0bb9603 	ldbu	r2,-4520(fp)
 8202318:	1884f03a 	xor	r2,r3,r2
 820231c:	e0bb9605 	stb	r2,-4520(fp)
 8202320:	00005306 	br	8202470 <sss_exec_command+0x6d0>

		   } else if ( strstr(text_buf, ":neg")){
 8202324:	e0bd1104 	addi	r2,fp,-3004
 8202328:	01420974 	movhi	r5,2085
 820232c:	29732404 	addi	r5,r5,-13168
 8202330:	1009883a 	mov	r4,r2
 8202334:	82041f80 	call	82041f8 <strstr>
 8202338:	10004d26 	beq	r2,zero,8202470 <sss_exec_command+0x6d0>
			   tx_wr_pos += sprintf(tx_wr_pos, "negative trigger\n");
 820233c:	e0fb9417 	ldw	r3,-4528(fp)
 8202340:	00820974 	movhi	r2,2085
 8202344:	10b32604 	addi	r2,r2,-13160
 8202348:	1009883a 	mov	r4,r2
 820234c:	00800484 	movi	r2,18
 8202350:	100d883a 	mov	r6,r2
 8202354:	200b883a 	mov	r5,r4
 8202358:	1809883a 	mov	r4,r3
 820235c:	8202c5c0 	call	8202c5c <memcpy>
 8202360:	00800444 	movi	r2,17
 8202364:	1007883a 	mov	r3,r2
 8202368:	e0bb9417 	ldw	r2,-4528(fp)
 820236c:	10c5883a 	add	r2,r2,r3
 8202370:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-0 ^ endValue) & (1 << 2);
 8202374:	e0fb9603 	ldbu	r3,-4520(fp)
 8202378:	00bffec4 	movi	r2,-5
 820237c:	1884703a 	and	r2,r3,r2
 8202380:	e0bb9605 	stb	r2,-4520(fp)
 8202384:	00003a06 	br	8202470 <sss_exec_command+0x6d0>
		   }
	   }
   } else if ( strstr(text_buf, "quit") != NULL){
 8202388:	e0bd1104 	addi	r2,fp,-3004
 820238c:	01420974 	movhi	r5,2085
 8202390:	29732b04 	addi	r5,r5,-13140
 8202394:	1009883a 	mov	r4,r2
 8202398:	82041f80 	call	82041f8 <strstr>
 820239c:	10001226 	beq	r2,zero,82023e8 <sss_exec_command+0x648>
	   tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 82023a0:	e0fb9417 	ldw	r3,-4528(fp)
 82023a4:	00820974 	movhi	r2,2085
 82023a8:	10b32d04 	addi	r2,r2,-13132
 82023ac:	1009883a 	mov	r4,r2
 82023b0:	008006c4 	movi	r2,27
 82023b4:	100d883a 	mov	r6,r2
 82023b8:	200b883a 	mov	r5,r4
 82023bc:	1809883a 	mov	r4,r3
 82023c0:	8202c5c0 	call	8202c5c <memcpy>
 82023c4:	00800684 	movi	r2,26
 82023c8:	1007883a 	mov	r3,r2
 82023cc:	e0bb9417 	ldw	r2,-4528(fp)
 82023d0:	10c5883a 	add	r2,r2,r3
 82023d4:	e0bb9415 	stw	r2,-4528(fp)
	   conn->close = 1;
 82023d8:	e0bfff17 	ldw	r2,-4(fp)
 82023dc:	00c00044 	movi	r3,1
 82023e0:	10c00215 	stw	r3,8(r2)
 82023e4:	00002206 	br	8202470 <sss_exec_command+0x6d0>
   } else if ( strstr(text_buf, "*rst") != NULL){
 82023e8:	e0bd1104 	addi	r2,fp,-3004
 82023ec:	01420974 	movhi	r5,2085
 82023f0:	29733404 	addi	r5,r5,-13104
 82023f4:	1009883a 	mov	r4,r2
 82023f8:	82041f80 	call	82041f8 <strstr>
 82023fc:	10001c26 	beq	r2,zero,8202470 <sss_exec_command+0x6d0>
	   tx_wr_pos += sprintf(tx_wr_pos, "Resetting\n");
 8202400:	e0bb9417 	ldw	r2,-4528(fp)
 8202404:	00c01484 	movi	r3,82
 8202408:	10c00005 	stb	r3,0(r2)
 820240c:	00c01944 	movi	r3,101
 8202410:	10c00045 	stb	r3,1(r2)
 8202414:	00c01cc4 	movi	r3,115
 8202418:	10c00085 	stb	r3,2(r2)
 820241c:	00c01944 	movi	r3,101
 8202420:	10c000c5 	stb	r3,3(r2)
 8202424:	00c01d04 	movi	r3,116
 8202428:	10c00105 	stb	r3,4(r2)
 820242c:	00c01d04 	movi	r3,116
 8202430:	10c00145 	stb	r3,5(r2)
 8202434:	00c01a44 	movi	r3,105
 8202438:	10c00185 	stb	r3,6(r2)
 820243c:	00c01b84 	movi	r3,110
 8202440:	10c001c5 	stb	r3,7(r2)
 8202444:	00c019c4 	movi	r3,103
 8202448:	10c00205 	stb	r3,8(r2)
 820244c:	00c00284 	movi	r3,10
 8202450:	10c00245 	stb	r3,9(r2)
 8202454:	10000285 	stb	zero,10(r2)
 8202458:	00800284 	movi	r2,10
 820245c:	1007883a 	mov	r3,r2
 8202460:	e0bb9417 	ldw	r2,-4528(fp)
 8202464:	10c5883a 	add	r2,r2,r3
 8202468:	e0bb9415 	stw	r2,-4528(fp)
	   endValue=0;
 820246c:	e03b9605 	stb	zero,-4520(fp)

   }



   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8202470:	e0fb9603 	ldbu	r3,-4520(fp)
 8202474:	00824034 	movhi	r2,2304
 8202478:	10801004 	addi	r2,r2,64
 820247c:	10c00035 	stwio	r3,0(r2)
	   printf("Hello Sam!");
   }

*/

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 8202480:	e0bfff17 	ldw	r2,-4(fp)
 8202484:	11000117 	ldw	r4,4(r2)
 8202488:	e0fb9417 	ldw	r3,-4528(fp)
 820248c:	e0bb9a04 	addi	r2,fp,-4504
 8202490:	1887c83a 	sub	r3,r3,r2
 8202494:	e0bb9a04 	addi	r2,fp,-4504
 8202498:	000f883a 	mov	r7,zero
 820249c:	180d883a 	mov	r6,r3
 82024a0:	100b883a 	mov	r5,r2
 82024a4:	82312bc0 	call	82312bc <t_send>
  
  return;
 82024a8:	0001883a 	nop
}
 82024ac:	e037883a 	mov	sp,fp
 82024b0:	dfc00117 	ldw	ra,4(sp)
 82024b4:	df000017 	ldw	fp,0(sp)
 82024b8:	dec00204 	addi	sp,sp,8
 82024bc:	f800283a 	ret

082024c0 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 82024c0:	defffa04 	addi	sp,sp,-24
 82024c4:	dfc00515 	stw	ra,20(sp)
 82024c8:	df000415 	stw	fp,16(sp)
 82024cc:	df000404 	addi	fp,sp,16
 82024d0:	e13fff15 	stw	r4,-4(fp)
  int data_used = 0, rx_code = 0;
 82024d4:	e03ffc15 	stw	zero,-16(fp)
 82024d8:	e03ffd15 	stw	zero,-12(fp)
  char *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 82024dc:	e0bfff17 	ldw	r2,-4(fp)
 82024e0:	10c00304 	addi	r3,r2,12
 82024e4:	e0bfff17 	ldw	r2,-4(fp)
 82024e8:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 82024ec:	e0bfff17 	ldw	r2,-4(fp)
 82024f0:	10c00304 	addi	r3,r2,12
 82024f4:	e0bfff17 	ldw	r2,-4(fp)
 82024f8:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 82024fc:	01020974 	movhi	r4,2085
 8202500:	21333604 	addi	r4,r4,-13096
 8202504:	82033700 	call	8203370 <puts>
  
  while(conn->state != CLOSE)
 8202508:	00005606 	br	8202664 <sss_handle_receive+0x1a4>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr((const char*)conn->rx_buffer, '\n');
 820250c:	e0bfff17 	ldw	r2,-4(fp)
 8202510:	10800304 	addi	r2,r2,12
 8202514:	01400284 	movi	r5,10
 8202518:	1009883a 	mov	r4,r2
 820251c:	82034d00 	call	82034d0 <strchr>
 8202520:	e0bffe15 	stw	r2,-8(fp)
      
    if(lf_addr)
 8202524:	e0bffe17 	ldw	r2,-8(fp)
 8202528:	10000326 	beq	r2,zero,8202538 <sss_handle_receive+0x78>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 820252c:	e13fff17 	ldw	r4,-4(fp)
 8202530:	8201da00 	call	8201da0 <sss_exec_command>
 8202534:	00001c06 	br	82025a8 <sss_handle_receive+0xe8>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, (char*)conn->rx_wr_pos, 
 8202538:	e0bfff17 	ldw	r2,-4(fp)
 820253c:	11000117 	ldw	r4,4(r2)
 8202540:	e0bfff17 	ldw	r2,-4(fp)
 8202544:	11417b17 	ldw	r5,1516(r2)
 8202548:	e0bfff17 	ldw	r2,-4(fp)
 820254c:	10817b17 	ldw	r2,1516(r2)
 8202550:	1007883a 	mov	r3,r2
 8202554:	e0bfff17 	ldw	r2,-4(fp)
 8202558:	10800304 	addi	r2,r2,12
 820255c:	1885c83a 	sub	r2,r3,r2
 8202560:	00c176c4 	movi	r3,1499
 8202564:	1885c83a 	sub	r2,r3,r2
 8202568:	000f883a 	mov	r7,zero
 820256c:	100d883a 	mov	r6,r2
 8202570:	8230ea80 	call	8230ea8 <t_recv>
 8202574:	e0bffd15 	stw	r2,-12(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 8202578:	e0bffd17 	ldw	r2,-12(fp)
 820257c:	00800a0e 	bge	zero,r2,82025a8 <sss_handle_receive+0xe8>
      {
        conn->rx_wr_pos += rx_code;
 8202580:	e0bfff17 	ldw	r2,-4(fp)
 8202584:	10c17b17 	ldw	r3,1516(r2)
 8202588:	e0bffd17 	ldw	r2,-12(fp)
 820258c:	1887883a 	add	r3,r3,r2
 8202590:	e0bfff17 	ldw	r2,-4(fp)
 8202594:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 8202598:	e0bfff17 	ldw	r2,-4(fp)
 820259c:	10817b17 	ldw	r2,1516(r2)
 82025a0:	10800044 	addi	r2,r2,1
 82025a4:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 82025a8:	e0bfff17 	ldw	r2,-4(fp)
 82025ac:	10800217 	ldw	r2,8(r2)
 82025b0:	10000226 	beq	r2,zero,82025bc <sss_handle_receive+0xfc>
 82025b4:	00800084 	movi	r2,2
 82025b8:	00000106 	br	82025c0 <sss_handle_receive+0x100>
 82025bc:	0005883a 	mov	r2,zero
 82025c0:	e0ffff17 	ldw	r3,-4(fp)
 82025c4:	18800015 	stw	r2,0(r3)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 82025c8:	e0bfff17 	ldw	r2,-4(fp)
 82025cc:	10817a17 	ldw	r2,1512(r2)
 82025d0:	1007883a 	mov	r3,r2
 82025d4:	e0bfff17 	ldw	r2,-4(fp)
 82025d8:	10800304 	addi	r2,r2,12
 82025dc:	1885c83a 	sub	r2,r3,r2
 82025e0:	e0bffc15 	stw	r2,-16(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 82025e4:	e0bfff17 	ldw	r2,-4(fp)
 82025e8:	10c00304 	addi	r3,r2,12
 82025ec:	e0bfff17 	ldw	r2,-4(fp)
 82025f0:	11017a17 	ldw	r4,1512(r2)
       conn->rx_wr_pos - conn->rx_rd_pos);
 82025f4:	e0bfff17 	ldw	r2,-4(fp)
 82025f8:	10817b17 	ldw	r2,1516(r2)
 82025fc:	100b883a 	mov	r5,r2
 8202600:	e0bfff17 	ldw	r2,-4(fp)
 8202604:	10817a17 	ldw	r2,1512(r2)
 8202608:	2885c83a 	sub	r2,r5,r2
     */
    conn->state = conn->close ? CLOSE : READY;

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 820260c:	100d883a 	mov	r6,r2
 8202610:	200b883a 	mov	r5,r4
 8202614:	1809883a 	mov	r4,r3
 8202618:	8202da40 	call	8202da4 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 820261c:	e0bfff17 	ldw	r2,-4(fp)
 8202620:	10c00304 	addi	r3,r2,12
 8202624:	e0bfff17 	ldw	r2,-4(fp)
 8202628:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 820262c:	e0bfff17 	ldw	r2,-4(fp)
 8202630:	10c17b17 	ldw	r3,1516(r2)
 8202634:	e0bffc17 	ldw	r2,-16(fp)
 8202638:	0085c83a 	sub	r2,zero,r2
 820263c:	1887883a 	add	r3,r3,r2
 8202640:	e0bfff17 	ldw	r2,-4(fp)
 8202644:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 8202648:	e0bfff17 	ldw	r2,-4(fp)
 820264c:	10817b17 	ldw	r2,1516(r2)
 8202650:	e0fffc17 	ldw	r3,-16(fp)
 8202654:	180d883a 	mov	r6,r3
 8202658:	000b883a 	mov	r5,zero
 820265c:	1009883a 	mov	r4,r2
 8202660:	8202f000 	call	8202f00 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 8202664:	e0bfff17 	ldw	r2,-4(fp)
 8202668:	10800017 	ldw	r2,0(r2)
 820266c:	10800098 	cmpnei	r2,r2,2
 8202670:	103fa61e 	bne	r2,zero,820250c <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 8202674:	01020974 	movhi	r4,2085
 8202678:	21334004 	addi	r4,r4,-13056
 820267c:	82033700 	call	8203370 <puts>
  close(conn->fd);
 8202680:	e0bfff17 	ldw	r2,-4(fp)
 8202684:	10800117 	ldw	r2,4(r2)
 8202688:	1009883a 	mov	r4,r2
 820268c:	82255840 	call	8225584 <close>
  sss_reset_connection(conn);
 8202690:	e13fff17 	ldw	r4,-4(fp)
 8202694:	8201a4c0 	call	8201a4c <sss_reset_connection>
  
  return;
 8202698:	0001883a 	nop
}
 820269c:	e037883a 	mov	sp,fp
 82026a0:	dfc00117 	ldw	ra,4(sp)
 82026a4:	df000017 	ldw	fp,0(sp)
 82026a8:	dec00204 	addi	sp,sp,8
 82026ac:	f800283a 	ret

082026b0 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 82026b0:	deffb604 	addi	sp,sp,-296
 82026b4:	dfc04915 	stw	ra,292(sp)
 82026b8:	df004815 	stw	fp,288(sp)
 82026bc:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 82026c0:	000d883a 	mov	r6,zero
 82026c4:	01400044 	movi	r5,1
 82026c8:	01000084 	movi	r4,2
 82026cc:	823017c0 	call	823017c <t_socket>
 82026d0:	e0bfba15 	stw	r2,-280(fp)
 82026d4:	e0bfba17 	ldw	r2,-280(fp)
 82026d8:	1000040e 	bge	r2,zero,82026ec <SSSSimpleSocketServerTask+0x3c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 82026dc:	01420974 	movhi	r5,2085
 82026e0:	29734a04 	addi	r5,r5,-13016
 82026e4:	01003fc4 	movi	r4,255
 82026e8:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 82026ec:	00800084 	movi	r2,2
 82026f0:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 82026f4:	00878004 	movi	r2,7680
 82026f8:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 82026fc:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 8202700:	e0bfbb04 	addi	r2,fp,-276
 8202704:	01800404 	movi	r6,16
 8202708:	100b883a 	mov	r5,r2
 820270c:	e13fba17 	ldw	r4,-280(fp)
 8202710:	82301fc0 	call	82301fc <t_bind>
 8202714:	1000040e 	bge	r2,zero,8202728 <SSSSimpleSocketServerTask+0x78>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 8202718:	01420974 	movhi	r5,2085
 820271c:	29735304 	addi	r5,r5,-12980
 8202720:	01003fc4 	movi	r4,255
 8202724:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 8202728:	01400044 	movi	r5,1
 820272c:	e13fba17 	ldw	r4,-280(fp)
 8202730:	82303600 	call	8230360 <t_listen>
 8202734:	1000040e 	bge	r2,zero,8202748 <SSSSimpleSocketServerTask+0x98>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 8202738:	01420974 	movhi	r5,2085
 820273c:	29735904 	addi	r5,r5,-12956
 8202740:	01003fc4 	movi	r4,255
 8202744:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 8202748:	01020974 	movhi	r4,2085
 820274c:	210f9304 	addi	r4,r4,15948
 8202750:	8201a4c0 	call	8201a4c <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 8202754:	01400784 	movi	r5,30
 8202758:	01020974 	movhi	r4,2085
 820275c:	21336004 	addi	r4,r4,-12928
 8202760:	82030ec0 	call	82030ec <printf>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 8202764:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 8202768:	e0bfbf04 	addi	r2,fp,-260
 820276c:	100b883a 	mov	r5,r2
 8202770:	e13fba17 	ldw	r4,-280(fp)
 8202774:	82351680 	call	8235168 <ifd_set>
    max_socket = fd_listen+1;
 8202778:	e0bfba17 	ldw	r2,-280(fp)
 820277c:	10800044 	addi	r2,r2,1
 8202780:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 8202784:	00820974 	movhi	r2,2085
 8202788:	108f9304 	addi	r2,r2,15948
 820278c:	10800117 	ldw	r2,4(r2)
 8202790:	10bfffe0 	cmpeqi	r2,r2,-1
 8202794:	1000111e 	bne	r2,zero,82027dc <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 8202798:	00820974 	movhi	r2,2085
 820279c:	108f9304 	addi	r2,r2,15948
 82027a0:	10800117 	ldw	r2,4(r2)
 82027a4:	e0ffbf04 	addi	r3,fp,-260
 82027a8:	180b883a 	mov	r5,r3
 82027ac:	1009883a 	mov	r4,r2
 82027b0:	82351680 	call	8235168 <ifd_set>
      if (max_socket <= conn.fd)
 82027b4:	00820974 	movhi	r2,2085
 82027b8:	108f9304 	addi	r2,r2,15948
 82027bc:	10c00117 	ldw	r3,4(r2)
 82027c0:	e0bfb917 	ldw	r2,-284(fp)
 82027c4:	18800516 	blt	r3,r2,82027dc <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 82027c8:	00820974 	movhi	r2,2085
 82027cc:	108f9304 	addi	r2,r2,15948
 82027d0:	10800117 	ldw	r2,4(r2)
 82027d4:	10800044 	addi	r2,r2,1
 82027d8:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 82027dc:	e0bfbf04 	addi	r2,fp,-260
 82027e0:	d8000015 	stw	zero,0(sp)
 82027e4:	000f883a 	mov	r7,zero
 82027e8:	000d883a 	mov	r6,zero
 82027ec:	100b883a 	mov	r5,r2
 82027f0:	e13fb917 	ldw	r4,-284(fp)
 82027f4:	82281f80 	call	82281f8 <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 82027f8:	e0bfbf04 	addi	r2,fp,-260
 82027fc:	100b883a 	mov	r5,r2
 8202800:	e13fba17 	ldw	r4,-280(fp)
 8202804:	82351e00 	call	82351e0 <ifd_isset>
 8202808:	10000526 	beq	r2,zero,8202820 <SSSSimpleSocketServerTask+0x170>
    {
      sss_handle_accept(fd_listen, &conn);
 820280c:	01420974 	movhi	r5,2085
 8202810:	294f9304 	addi	r5,r5,15948
 8202814:	e13fba17 	ldw	r4,-280(fp)
 8202818:	8201cd80 	call	8201cd8 <sss_handle_accept>
 820281c:	003fd106 	br	8202764 <SSSSimpleSocketServerTask+0xb4>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 8202820:	00820974 	movhi	r2,2085
 8202824:	108f9304 	addi	r2,r2,15948
 8202828:	10800117 	ldw	r2,4(r2)
 820282c:	10bfffe0 	cmpeqi	r2,r2,-1
 8202830:	103fcc1e 	bne	r2,zero,8202764 <SSSSimpleSocketServerTask+0xb4>
 8202834:	00820974 	movhi	r2,2085
 8202838:	108f9304 	addi	r2,r2,15948
 820283c:	10800117 	ldw	r2,4(r2)
 8202840:	e0ffbf04 	addi	r3,fp,-260
 8202844:	180b883a 	mov	r5,r3
 8202848:	1009883a 	mov	r4,r2
 820284c:	82351e00 	call	82351e0 <ifd_isset>
 8202850:	103fc426 	beq	r2,zero,8202764 <SSSSimpleSocketServerTask+0xb4>
      {
        sss_handle_receive(&conn);
 8202854:	01020974 	movhi	r4,2085
 8202858:	210f9304 	addi	r4,r4,15948
 820285c:	82024c00 	call	82024c0 <sss_handle_receive>
      }
    }
  } /* while(1) */
 8202860:	003fc006 	br	8202764 <SSSSimpleSocketServerTask+0xb4>

08202864 <__divsi3>:
 8202864:	20001b16 	blt	r4,zero,82028d4 <__divsi3+0x70>
 8202868:	000f883a 	mov	r7,zero
 820286c:	28001616 	blt	r5,zero,82028c8 <__divsi3+0x64>
 8202870:	200d883a 	mov	r6,r4
 8202874:	29001a2e 	bgeu	r5,r4,82028e0 <__divsi3+0x7c>
 8202878:	00800804 	movi	r2,32
 820287c:	00c00044 	movi	r3,1
 8202880:	00000106 	br	8202888 <__divsi3+0x24>
 8202884:	10000d26 	beq	r2,zero,82028bc <__divsi3+0x58>
 8202888:	294b883a 	add	r5,r5,r5
 820288c:	10bfffc4 	addi	r2,r2,-1
 8202890:	18c7883a 	add	r3,r3,r3
 8202894:	293ffb36 	bltu	r5,r4,8202884 <__divsi3+0x20>
 8202898:	0005883a 	mov	r2,zero
 820289c:	18000726 	beq	r3,zero,82028bc <__divsi3+0x58>
 82028a0:	0005883a 	mov	r2,zero
 82028a4:	31400236 	bltu	r6,r5,82028b0 <__divsi3+0x4c>
 82028a8:	314dc83a 	sub	r6,r6,r5
 82028ac:	10c4b03a 	or	r2,r2,r3
 82028b0:	1806d07a 	srli	r3,r3,1
 82028b4:	280ad07a 	srli	r5,r5,1
 82028b8:	183ffa1e 	bne	r3,zero,82028a4 <__divsi3+0x40>
 82028bc:	38000126 	beq	r7,zero,82028c4 <__divsi3+0x60>
 82028c0:	0085c83a 	sub	r2,zero,r2
 82028c4:	f800283a 	ret
 82028c8:	014bc83a 	sub	r5,zero,r5
 82028cc:	39c0005c 	xori	r7,r7,1
 82028d0:	003fe706 	br	8202870 <__divsi3+0xc>
 82028d4:	0109c83a 	sub	r4,zero,r4
 82028d8:	01c00044 	movi	r7,1
 82028dc:	003fe306 	br	820286c <__divsi3+0x8>
 82028e0:	00c00044 	movi	r3,1
 82028e4:	003fee06 	br	82028a0 <__divsi3+0x3c>

082028e8 <__modsi3>:
 82028e8:	20001716 	blt	r4,zero,8202948 <__modsi3+0x60>
 82028ec:	000f883a 	mov	r7,zero
 82028f0:	2005883a 	mov	r2,r4
 82028f4:	28001216 	blt	r5,zero,8202940 <__modsi3+0x58>
 82028f8:	2900162e 	bgeu	r5,r4,8202954 <__modsi3+0x6c>
 82028fc:	01800804 	movi	r6,32
 8202900:	00c00044 	movi	r3,1
 8202904:	00000106 	br	820290c <__modsi3+0x24>
 8202908:	30000a26 	beq	r6,zero,8202934 <__modsi3+0x4c>
 820290c:	294b883a 	add	r5,r5,r5
 8202910:	31bfffc4 	addi	r6,r6,-1
 8202914:	18c7883a 	add	r3,r3,r3
 8202918:	293ffb36 	bltu	r5,r4,8202908 <__modsi3+0x20>
 820291c:	18000526 	beq	r3,zero,8202934 <__modsi3+0x4c>
 8202920:	1806d07a 	srli	r3,r3,1
 8202924:	11400136 	bltu	r2,r5,820292c <__modsi3+0x44>
 8202928:	1145c83a 	sub	r2,r2,r5
 820292c:	280ad07a 	srli	r5,r5,1
 8202930:	183ffb1e 	bne	r3,zero,8202920 <__modsi3+0x38>
 8202934:	38000126 	beq	r7,zero,820293c <__modsi3+0x54>
 8202938:	0085c83a 	sub	r2,zero,r2
 820293c:	f800283a 	ret
 8202940:	014bc83a 	sub	r5,zero,r5
 8202944:	003fec06 	br	82028f8 <__modsi3+0x10>
 8202948:	0109c83a 	sub	r4,zero,r4
 820294c:	01c00044 	movi	r7,1
 8202950:	003fe706 	br	82028f0 <__modsi3+0x8>
 8202954:	00c00044 	movi	r3,1
 8202958:	003ff106 	br	8202920 <__modsi3+0x38>

0820295c <__udivsi3>:
 820295c:	200d883a 	mov	r6,r4
 8202960:	2900152e 	bgeu	r5,r4,82029b8 <__udivsi3+0x5c>
 8202964:	28001416 	blt	r5,zero,82029b8 <__udivsi3+0x5c>
 8202968:	00800804 	movi	r2,32
 820296c:	00c00044 	movi	r3,1
 8202970:	00000206 	br	820297c <__udivsi3+0x20>
 8202974:	10000e26 	beq	r2,zero,82029b0 <__udivsi3+0x54>
 8202978:	28000516 	blt	r5,zero,8202990 <__udivsi3+0x34>
 820297c:	294b883a 	add	r5,r5,r5
 8202980:	10bfffc4 	addi	r2,r2,-1
 8202984:	18c7883a 	add	r3,r3,r3
 8202988:	293ffa36 	bltu	r5,r4,8202974 <__udivsi3+0x18>
 820298c:	18000826 	beq	r3,zero,82029b0 <__udivsi3+0x54>
 8202990:	0005883a 	mov	r2,zero
 8202994:	31400236 	bltu	r6,r5,82029a0 <__udivsi3+0x44>
 8202998:	314dc83a 	sub	r6,r6,r5
 820299c:	10c4b03a 	or	r2,r2,r3
 82029a0:	1806d07a 	srli	r3,r3,1
 82029a4:	280ad07a 	srli	r5,r5,1
 82029a8:	183ffa1e 	bne	r3,zero,8202994 <__udivsi3+0x38>
 82029ac:	f800283a 	ret
 82029b0:	0005883a 	mov	r2,zero
 82029b4:	f800283a 	ret
 82029b8:	00c00044 	movi	r3,1
 82029bc:	003ff406 	br	8202990 <__udivsi3+0x34>

082029c0 <__umodsi3>:
 82029c0:	2005883a 	mov	r2,r4
 82029c4:	2900122e 	bgeu	r5,r4,8202a10 <__umodsi3+0x50>
 82029c8:	28001116 	blt	r5,zero,8202a10 <__umodsi3+0x50>
 82029cc:	01800804 	movi	r6,32
 82029d0:	00c00044 	movi	r3,1
 82029d4:	00000206 	br	82029e0 <__umodsi3+0x20>
 82029d8:	30000c26 	beq	r6,zero,8202a0c <__umodsi3+0x4c>
 82029dc:	28000516 	blt	r5,zero,82029f4 <__umodsi3+0x34>
 82029e0:	294b883a 	add	r5,r5,r5
 82029e4:	31bfffc4 	addi	r6,r6,-1
 82029e8:	18c7883a 	add	r3,r3,r3
 82029ec:	293ffa36 	bltu	r5,r4,82029d8 <__umodsi3+0x18>
 82029f0:	18000626 	beq	r3,zero,8202a0c <__umodsi3+0x4c>
 82029f4:	1806d07a 	srli	r3,r3,1
 82029f8:	11400136 	bltu	r2,r5,8202a00 <__umodsi3+0x40>
 82029fc:	1145c83a 	sub	r2,r2,r5
 8202a00:	280ad07a 	srli	r5,r5,1
 8202a04:	183ffb1e 	bne	r3,zero,82029f4 <__umodsi3+0x34>
 8202a08:	f800283a 	ret
 8202a0c:	f800283a 	ret
 8202a10:	00c00044 	movi	r3,1
 8202a14:	003ff706 	br	82029f4 <__umodsi3+0x34>

08202a18 <_fprintf_r>:
 8202a18:	defffe04 	addi	sp,sp,-8
 8202a1c:	2809883a 	mov	r4,r5
 8202a20:	300b883a 	mov	r5,r6
 8202a24:	dfc00015 	stw	ra,0(sp)
 8202a28:	d9c00115 	stw	r7,4(sp)
 8202a2c:	d9800104 	addi	r6,sp,4
 8202a30:	82089800 	call	8208980 <__vfprintf_internal>
 8202a34:	dfc00017 	ldw	ra,0(sp)
 8202a38:	dec00204 	addi	sp,sp,8
 8202a3c:	f800283a 	ret

08202a40 <fprintf>:
 8202a40:	defffd04 	addi	sp,sp,-12
 8202a44:	dfc00015 	stw	ra,0(sp)
 8202a48:	d9800115 	stw	r6,4(sp)
 8202a4c:	d9c00215 	stw	r7,8(sp)
 8202a50:	d9800104 	addi	r6,sp,4
 8202a54:	82089800 	call	8208980 <__vfprintf_internal>
 8202a58:	dfc00017 	ldw	ra,0(sp)
 8202a5c:	dec00304 	addi	sp,sp,12
 8202a60:	f800283a 	ret

08202a64 <_fwrite_r>:
 8202a64:	defff504 	addi	sp,sp,-44
 8202a68:	dc800815 	stw	r18,32(sp)
 8202a6c:	39a5383a 	mul	r18,r7,r6
 8202a70:	d8800304 	addi	r2,sp,12
 8202a74:	d8800015 	stw	r2,0(sp)
 8202a78:	00800044 	movi	r2,1
 8202a7c:	dcc00915 	stw	r19,36(sp)
 8202a80:	dc400715 	stw	r17,28(sp)
 8202a84:	dc000615 	stw	r16,24(sp)
 8202a88:	d9400315 	stw	r5,12(sp)
 8202a8c:	dfc00a15 	stw	ra,40(sp)
 8202a90:	dc800415 	stw	r18,16(sp)
 8202a94:	dc800215 	stw	r18,8(sp)
 8202a98:	d8800115 	stw	r2,4(sp)
 8202a9c:	3027883a 	mov	r19,r6
 8202aa0:	3821883a 	mov	r16,r7
 8202aa4:	2023883a 	mov	r17,r4
 8202aa8:	d9400b17 	ldw	r5,44(sp)
 8202aac:	20000226 	beq	r4,zero,8202ab8 <_fwrite_r+0x54>
 8202ab0:	20800e17 	ldw	r2,56(r4)
 8202ab4:	10001a26 	beq	r2,zero,8202b20 <_fwrite_r+0xbc>
 8202ab8:	2880030b 	ldhu	r2,12(r5)
 8202abc:	10c8000c 	andi	r3,r2,8192
 8202ac0:	1800061e 	bne	r3,zero,8202adc <_fwrite_r+0x78>
 8202ac4:	29001917 	ldw	r4,100(r5)
 8202ac8:	00f7ffc4 	movi	r3,-8193
 8202acc:	10880014 	ori	r2,r2,8192
 8202ad0:	20c6703a 	and	r3,r4,r3
 8202ad4:	2880030d 	sth	r2,12(r5)
 8202ad8:	28c01915 	stw	r3,100(r5)
 8202adc:	d80d883a 	mov	r6,sp
 8202ae0:	8809883a 	mov	r4,r17
 8202ae4:	820b15c0 	call	820b15c <__sfvwrite_r>
 8202ae8:	10000b26 	beq	r2,zero,8202b18 <_fwrite_r+0xb4>
 8202aec:	d9000217 	ldw	r4,8(sp)
 8202af0:	980b883a 	mov	r5,r19
 8202af4:	9109c83a 	sub	r4,r18,r4
 8202af8:	820295c0 	call	820295c <__udivsi3>
 8202afc:	dfc00a17 	ldw	ra,40(sp)
 8202b00:	dcc00917 	ldw	r19,36(sp)
 8202b04:	dc800817 	ldw	r18,32(sp)
 8202b08:	dc400717 	ldw	r17,28(sp)
 8202b0c:	dc000617 	ldw	r16,24(sp)
 8202b10:	dec00b04 	addi	sp,sp,44
 8202b14:	f800283a 	ret
 8202b18:	8005883a 	mov	r2,r16
 8202b1c:	003ff706 	br	8202afc <_fwrite_r+0x98>
 8202b20:	d9400515 	stw	r5,20(sp)
 8202b24:	820ab840 	call	820ab84 <__sinit>
 8202b28:	d9400517 	ldw	r5,20(sp)
 8202b2c:	003fe206 	br	8202ab8 <_fwrite_r+0x54>

08202b30 <fwrite>:
 8202b30:	defffe04 	addi	sp,sp,-8
 8202b34:	00820974 	movhi	r2,2085
 8202b38:	d9c00015 	stw	r7,0(sp)
 8202b3c:	108eb804 	addi	r2,r2,15072
 8202b40:	300f883a 	mov	r7,r6
 8202b44:	280d883a 	mov	r6,r5
 8202b48:	200b883a 	mov	r5,r4
 8202b4c:	11000017 	ldw	r4,0(r2)
 8202b50:	dfc00115 	stw	ra,4(sp)
 8202b54:	8202a640 	call	8202a64 <_fwrite_r>
 8202b58:	dfc00117 	ldw	ra,4(sp)
 8202b5c:	dec00204 	addi	sp,sp,8
 8202b60:	f800283a 	ret

08202b64 <_getc_r>:
 8202b64:	defffd04 	addi	sp,sp,-12
 8202b68:	dc000115 	stw	r16,4(sp)
 8202b6c:	dfc00215 	stw	ra,8(sp)
 8202b70:	2021883a 	mov	r16,r4
 8202b74:	20000226 	beq	r4,zero,8202b80 <_getc_r+0x1c>
 8202b78:	20800e17 	ldw	r2,56(r4)
 8202b7c:	10000c26 	beq	r2,zero,8202bb0 <_getc_r+0x4c>
 8202b80:	28800117 	ldw	r2,4(r5)
 8202b84:	10bfffc4 	addi	r2,r2,-1
 8202b88:	28800115 	stw	r2,4(r5)
 8202b8c:	10000c16 	blt	r2,zero,8202bc0 <_getc_r+0x5c>
 8202b90:	28800017 	ldw	r2,0(r5)
 8202b94:	10c00044 	addi	r3,r2,1
 8202b98:	28c00015 	stw	r3,0(r5)
 8202b9c:	10800003 	ldbu	r2,0(r2)
 8202ba0:	dfc00217 	ldw	ra,8(sp)
 8202ba4:	dc000117 	ldw	r16,4(sp)
 8202ba8:	dec00304 	addi	sp,sp,12
 8202bac:	f800283a 	ret
 8202bb0:	d9400015 	stw	r5,0(sp)
 8202bb4:	820ab840 	call	820ab84 <__sinit>
 8202bb8:	d9400017 	ldw	r5,0(sp)
 8202bbc:	003ff006 	br	8202b80 <_getc_r+0x1c>
 8202bc0:	8009883a 	mov	r4,r16
 8202bc4:	dfc00217 	ldw	ra,8(sp)
 8202bc8:	dc000117 	ldw	r16,4(sp)
 8202bcc:	dec00304 	addi	sp,sp,12
 8202bd0:	82033841 	jmpi	8203384 <__srget_r>

08202bd4 <getc>:
 8202bd4:	00820974 	movhi	r2,2085
 8202bd8:	defffd04 	addi	sp,sp,-12
 8202bdc:	108eb804 	addi	r2,r2,15072
 8202be0:	dc400115 	stw	r17,4(sp)
 8202be4:	14400017 	ldw	r17,0(r2)
 8202be8:	dc000015 	stw	r16,0(sp)
 8202bec:	dfc00215 	stw	ra,8(sp)
 8202bf0:	2021883a 	mov	r16,r4
 8202bf4:	88000226 	beq	r17,zero,8202c00 <getc+0x2c>
 8202bf8:	88800e17 	ldw	r2,56(r17)
 8202bfc:	10000d26 	beq	r2,zero,8202c34 <getc+0x60>
 8202c00:	80800117 	ldw	r2,4(r16)
 8202c04:	10bfffc4 	addi	r2,r2,-1
 8202c08:	80800115 	stw	r2,4(r16)
 8202c0c:	10000c16 	blt	r2,zero,8202c40 <getc+0x6c>
 8202c10:	80800017 	ldw	r2,0(r16)
 8202c14:	10c00044 	addi	r3,r2,1
 8202c18:	80c00015 	stw	r3,0(r16)
 8202c1c:	10800003 	ldbu	r2,0(r2)
 8202c20:	dfc00217 	ldw	ra,8(sp)
 8202c24:	dc400117 	ldw	r17,4(sp)
 8202c28:	dc000017 	ldw	r16,0(sp)
 8202c2c:	dec00304 	addi	sp,sp,12
 8202c30:	f800283a 	ret
 8202c34:	8809883a 	mov	r4,r17
 8202c38:	820ab840 	call	820ab84 <__sinit>
 8202c3c:	003ff006 	br	8202c00 <getc+0x2c>
 8202c40:	800b883a 	mov	r5,r16
 8202c44:	8809883a 	mov	r4,r17
 8202c48:	dfc00217 	ldw	ra,8(sp)
 8202c4c:	dc400117 	ldw	r17,4(sp)
 8202c50:	dc000017 	ldw	r16,0(sp)
 8202c54:	dec00304 	addi	sp,sp,12
 8202c58:	82033841 	jmpi	8203384 <__srget_r>

08202c5c <memcpy>:
 8202c5c:	defffd04 	addi	sp,sp,-12
 8202c60:	dfc00215 	stw	ra,8(sp)
 8202c64:	dc400115 	stw	r17,4(sp)
 8202c68:	dc000015 	stw	r16,0(sp)
 8202c6c:	00c003c4 	movi	r3,15
 8202c70:	2005883a 	mov	r2,r4
 8202c74:	1980452e 	bgeu	r3,r6,8202d8c <memcpy+0x130>
 8202c78:	2906b03a 	or	r3,r5,r4
 8202c7c:	18c000cc 	andi	r3,r3,3
 8202c80:	1800441e 	bne	r3,zero,8202d94 <memcpy+0x138>
 8202c84:	347ffc04 	addi	r17,r6,-16
 8202c88:	8822d13a 	srli	r17,r17,4
 8202c8c:	28c00104 	addi	r3,r5,4
 8202c90:	23400104 	addi	r13,r4,4
 8202c94:	8820913a 	slli	r16,r17,4
 8202c98:	2b000204 	addi	r12,r5,8
 8202c9c:	22c00204 	addi	r11,r4,8
 8202ca0:	84000504 	addi	r16,r16,20
 8202ca4:	2a800304 	addi	r10,r5,12
 8202ca8:	22400304 	addi	r9,r4,12
 8202cac:	2c21883a 	add	r16,r5,r16
 8202cb0:	2811883a 	mov	r8,r5
 8202cb4:	200f883a 	mov	r7,r4
 8202cb8:	41000017 	ldw	r4,0(r8)
 8202cbc:	1fc00017 	ldw	ra,0(r3)
 8202cc0:	63c00017 	ldw	r15,0(r12)
 8202cc4:	39000015 	stw	r4,0(r7)
 8202cc8:	53800017 	ldw	r14,0(r10)
 8202ccc:	6fc00015 	stw	ra,0(r13)
 8202cd0:	5bc00015 	stw	r15,0(r11)
 8202cd4:	4b800015 	stw	r14,0(r9)
 8202cd8:	18c00404 	addi	r3,r3,16
 8202cdc:	39c00404 	addi	r7,r7,16
 8202ce0:	42000404 	addi	r8,r8,16
 8202ce4:	6b400404 	addi	r13,r13,16
 8202ce8:	63000404 	addi	r12,r12,16
 8202cec:	5ac00404 	addi	r11,r11,16
 8202cf0:	52800404 	addi	r10,r10,16
 8202cf4:	4a400404 	addi	r9,r9,16
 8202cf8:	1c3fef1e 	bne	r3,r16,8202cb8 <memcpy+0x5c>
 8202cfc:	89c00044 	addi	r7,r17,1
 8202d00:	380e913a 	slli	r7,r7,4
 8202d04:	310003cc 	andi	r4,r6,15
 8202d08:	02c000c4 	movi	r11,3
 8202d0c:	11c7883a 	add	r3,r2,r7
 8202d10:	29cb883a 	add	r5,r5,r7
 8202d14:	5900212e 	bgeu	r11,r4,8202d9c <memcpy+0x140>
 8202d18:	1813883a 	mov	r9,r3
 8202d1c:	2811883a 	mov	r8,r5
 8202d20:	200f883a 	mov	r7,r4
 8202d24:	42800017 	ldw	r10,0(r8)
 8202d28:	4a400104 	addi	r9,r9,4
 8202d2c:	39ffff04 	addi	r7,r7,-4
 8202d30:	4abfff15 	stw	r10,-4(r9)
 8202d34:	42000104 	addi	r8,r8,4
 8202d38:	59fffa36 	bltu	r11,r7,8202d24 <memcpy+0xc8>
 8202d3c:	213fff04 	addi	r4,r4,-4
 8202d40:	2008d0ba 	srli	r4,r4,2
 8202d44:	318000cc 	andi	r6,r6,3
 8202d48:	21000044 	addi	r4,r4,1
 8202d4c:	2109883a 	add	r4,r4,r4
 8202d50:	2109883a 	add	r4,r4,r4
 8202d54:	1907883a 	add	r3,r3,r4
 8202d58:	290b883a 	add	r5,r5,r4
 8202d5c:	30000626 	beq	r6,zero,8202d78 <memcpy+0x11c>
 8202d60:	198d883a 	add	r6,r3,r6
 8202d64:	29c00003 	ldbu	r7,0(r5)
 8202d68:	18c00044 	addi	r3,r3,1
 8202d6c:	29400044 	addi	r5,r5,1
 8202d70:	19ffffc5 	stb	r7,-1(r3)
 8202d74:	19bffb1e 	bne	r3,r6,8202d64 <memcpy+0x108>
 8202d78:	dfc00217 	ldw	ra,8(sp)
 8202d7c:	dc400117 	ldw	r17,4(sp)
 8202d80:	dc000017 	ldw	r16,0(sp)
 8202d84:	dec00304 	addi	sp,sp,12
 8202d88:	f800283a 	ret
 8202d8c:	2007883a 	mov	r3,r4
 8202d90:	003ff206 	br	8202d5c <memcpy+0x100>
 8202d94:	2007883a 	mov	r3,r4
 8202d98:	003ff106 	br	8202d60 <memcpy+0x104>
 8202d9c:	200d883a 	mov	r6,r4
 8202da0:	003fee06 	br	8202d5c <memcpy+0x100>

08202da4 <memmove>:
 8202da4:	2005883a 	mov	r2,r4
 8202da8:	29000b2e 	bgeu	r5,r4,8202dd8 <memmove+0x34>
 8202dac:	298f883a 	add	r7,r5,r6
 8202db0:	21c0092e 	bgeu	r4,r7,8202dd8 <memmove+0x34>
 8202db4:	2187883a 	add	r3,r4,r6
 8202db8:	198bc83a 	sub	r5,r3,r6
 8202dbc:	30004826 	beq	r6,zero,8202ee0 <memmove+0x13c>
 8202dc0:	39ffffc4 	addi	r7,r7,-1
 8202dc4:	39000003 	ldbu	r4,0(r7)
 8202dc8:	18ffffc4 	addi	r3,r3,-1
 8202dcc:	19000005 	stb	r4,0(r3)
 8202dd0:	28fffb1e 	bne	r5,r3,8202dc0 <memmove+0x1c>
 8202dd4:	f800283a 	ret
 8202dd8:	00c003c4 	movi	r3,15
 8202ddc:	1980412e 	bgeu	r3,r6,8202ee4 <memmove+0x140>
 8202de0:	2886b03a 	or	r3,r5,r2
 8202de4:	18c000cc 	andi	r3,r3,3
 8202de8:	1800401e 	bne	r3,zero,8202eec <memmove+0x148>
 8202dec:	33fffc04 	addi	r15,r6,-16
 8202df0:	781ed13a 	srli	r15,r15,4
 8202df4:	28c00104 	addi	r3,r5,4
 8202df8:	13400104 	addi	r13,r2,4
 8202dfc:	781c913a 	slli	r14,r15,4
 8202e00:	2b000204 	addi	r12,r5,8
 8202e04:	12c00204 	addi	r11,r2,8
 8202e08:	73800504 	addi	r14,r14,20
 8202e0c:	2a800304 	addi	r10,r5,12
 8202e10:	12400304 	addi	r9,r2,12
 8202e14:	2b9d883a 	add	r14,r5,r14
 8202e18:	2811883a 	mov	r8,r5
 8202e1c:	100f883a 	mov	r7,r2
 8202e20:	41000017 	ldw	r4,0(r8)
 8202e24:	39c00404 	addi	r7,r7,16
 8202e28:	18c00404 	addi	r3,r3,16
 8202e2c:	393ffc15 	stw	r4,-16(r7)
 8202e30:	193ffc17 	ldw	r4,-16(r3)
 8202e34:	6b400404 	addi	r13,r13,16
 8202e38:	5ac00404 	addi	r11,r11,16
 8202e3c:	693ffc15 	stw	r4,-16(r13)
 8202e40:	61000017 	ldw	r4,0(r12)
 8202e44:	4a400404 	addi	r9,r9,16
 8202e48:	42000404 	addi	r8,r8,16
 8202e4c:	593ffc15 	stw	r4,-16(r11)
 8202e50:	51000017 	ldw	r4,0(r10)
 8202e54:	63000404 	addi	r12,r12,16
 8202e58:	52800404 	addi	r10,r10,16
 8202e5c:	493ffc15 	stw	r4,-16(r9)
 8202e60:	1bbfef1e 	bne	r3,r14,8202e20 <memmove+0x7c>
 8202e64:	79000044 	addi	r4,r15,1
 8202e68:	2008913a 	slli	r4,r4,4
 8202e6c:	328003cc 	andi	r10,r6,15
 8202e70:	02c000c4 	movi	r11,3
 8202e74:	1107883a 	add	r3,r2,r4
 8202e78:	290b883a 	add	r5,r5,r4
 8202e7c:	5a801e2e 	bgeu	r11,r10,8202ef8 <memmove+0x154>
 8202e80:	1813883a 	mov	r9,r3
 8202e84:	2811883a 	mov	r8,r5
 8202e88:	500f883a 	mov	r7,r10
 8202e8c:	41000017 	ldw	r4,0(r8)
 8202e90:	4a400104 	addi	r9,r9,4
 8202e94:	39ffff04 	addi	r7,r7,-4
 8202e98:	493fff15 	stw	r4,-4(r9)
 8202e9c:	42000104 	addi	r8,r8,4
 8202ea0:	59fffa36 	bltu	r11,r7,8202e8c <memmove+0xe8>
 8202ea4:	513fff04 	addi	r4,r10,-4
 8202ea8:	2008d0ba 	srli	r4,r4,2
 8202eac:	318000cc 	andi	r6,r6,3
 8202eb0:	21000044 	addi	r4,r4,1
 8202eb4:	2109883a 	add	r4,r4,r4
 8202eb8:	2109883a 	add	r4,r4,r4
 8202ebc:	1907883a 	add	r3,r3,r4
 8202ec0:	290b883a 	add	r5,r5,r4
 8202ec4:	30000b26 	beq	r6,zero,8202ef4 <memmove+0x150>
 8202ec8:	198d883a 	add	r6,r3,r6
 8202ecc:	29c00003 	ldbu	r7,0(r5)
 8202ed0:	18c00044 	addi	r3,r3,1
 8202ed4:	29400044 	addi	r5,r5,1
 8202ed8:	19ffffc5 	stb	r7,-1(r3)
 8202edc:	19bffb1e 	bne	r3,r6,8202ecc <memmove+0x128>
 8202ee0:	f800283a 	ret
 8202ee4:	1007883a 	mov	r3,r2
 8202ee8:	003ff606 	br	8202ec4 <memmove+0x120>
 8202eec:	1007883a 	mov	r3,r2
 8202ef0:	003ff506 	br	8202ec8 <memmove+0x124>
 8202ef4:	f800283a 	ret
 8202ef8:	500d883a 	mov	r6,r10
 8202efc:	003ff106 	br	8202ec4 <memmove+0x120>

08202f00 <memset>:
 8202f00:	20c000cc 	andi	r3,r4,3
 8202f04:	2005883a 	mov	r2,r4
 8202f08:	18004426 	beq	r3,zero,820301c <memset+0x11c>
 8202f0c:	31ffffc4 	addi	r7,r6,-1
 8202f10:	30004026 	beq	r6,zero,8203014 <memset+0x114>
 8202f14:	2813883a 	mov	r9,r5
 8202f18:	200d883a 	mov	r6,r4
 8202f1c:	2007883a 	mov	r3,r4
 8202f20:	00000406 	br	8202f34 <memset+0x34>
 8202f24:	3a3fffc4 	addi	r8,r7,-1
 8202f28:	31800044 	addi	r6,r6,1
 8202f2c:	38003926 	beq	r7,zero,8203014 <memset+0x114>
 8202f30:	400f883a 	mov	r7,r8
 8202f34:	18c00044 	addi	r3,r3,1
 8202f38:	32400005 	stb	r9,0(r6)
 8202f3c:	1a0000cc 	andi	r8,r3,3
 8202f40:	403ff81e 	bne	r8,zero,8202f24 <memset+0x24>
 8202f44:	010000c4 	movi	r4,3
 8202f48:	21c02d2e 	bgeu	r4,r7,8203000 <memset+0x100>
 8202f4c:	29003fcc 	andi	r4,r5,255
 8202f50:	200c923a 	slli	r6,r4,8
 8202f54:	3108b03a 	or	r4,r6,r4
 8202f58:	200c943a 	slli	r6,r4,16
 8202f5c:	218cb03a 	or	r6,r4,r6
 8202f60:	010003c4 	movi	r4,15
 8202f64:	21c0182e 	bgeu	r4,r7,8202fc8 <memset+0xc8>
 8202f68:	3b3ffc04 	addi	r12,r7,-16
 8202f6c:	6018d13a 	srli	r12,r12,4
 8202f70:	1a000104 	addi	r8,r3,4
 8202f74:	1ac00204 	addi	r11,r3,8
 8202f78:	6008913a 	slli	r4,r12,4
 8202f7c:	1a800304 	addi	r10,r3,12
 8202f80:	1813883a 	mov	r9,r3
 8202f84:	21000504 	addi	r4,r4,20
 8202f88:	1909883a 	add	r4,r3,r4
 8202f8c:	49800015 	stw	r6,0(r9)
 8202f90:	41800015 	stw	r6,0(r8)
 8202f94:	59800015 	stw	r6,0(r11)
 8202f98:	51800015 	stw	r6,0(r10)
 8202f9c:	42000404 	addi	r8,r8,16
 8202fa0:	4a400404 	addi	r9,r9,16
 8202fa4:	5ac00404 	addi	r11,r11,16
 8202fa8:	52800404 	addi	r10,r10,16
 8202fac:	413ff71e 	bne	r8,r4,8202f8c <memset+0x8c>
 8202fb0:	63000044 	addi	r12,r12,1
 8202fb4:	6018913a 	slli	r12,r12,4
 8202fb8:	39c003cc 	andi	r7,r7,15
 8202fbc:	010000c4 	movi	r4,3
 8202fc0:	1b07883a 	add	r3,r3,r12
 8202fc4:	21c00e2e 	bgeu	r4,r7,8203000 <memset+0x100>
 8202fc8:	1813883a 	mov	r9,r3
 8202fcc:	3811883a 	mov	r8,r7
 8202fd0:	010000c4 	movi	r4,3
 8202fd4:	49800015 	stw	r6,0(r9)
 8202fd8:	423fff04 	addi	r8,r8,-4
 8202fdc:	4a400104 	addi	r9,r9,4
 8202fe0:	223ffc36 	bltu	r4,r8,8202fd4 <memset+0xd4>
 8202fe4:	393fff04 	addi	r4,r7,-4
 8202fe8:	2008d0ba 	srli	r4,r4,2
 8202fec:	39c000cc 	andi	r7,r7,3
 8202ff0:	21000044 	addi	r4,r4,1
 8202ff4:	2109883a 	add	r4,r4,r4
 8202ff8:	2109883a 	add	r4,r4,r4
 8202ffc:	1907883a 	add	r3,r3,r4
 8203000:	38000526 	beq	r7,zero,8203018 <memset+0x118>
 8203004:	19cf883a 	add	r7,r3,r7
 8203008:	19400005 	stb	r5,0(r3)
 820300c:	18c00044 	addi	r3,r3,1
 8203010:	38fffd1e 	bne	r7,r3,8203008 <memset+0x108>
 8203014:	f800283a 	ret
 8203018:	f800283a 	ret
 820301c:	2007883a 	mov	r3,r4
 8203020:	300f883a 	mov	r7,r6
 8203024:	003fc706 	br	8202f44 <memset+0x44>

08203028 <_perror_r>:
 8203028:	defffd04 	addi	sp,sp,-12
 820302c:	dc000115 	stw	r16,4(sp)
 8203030:	dfc00215 	stw	ra,8(sp)
 8203034:	2021883a 	mov	r16,r4
 8203038:	28000326 	beq	r5,zero,8203048 <_perror_r+0x20>
 820303c:	28c00007 	ldb	r3,0(r5)
 8203040:	2805883a 	mov	r2,r5
 8203044:	1800101e 	bne	r3,zero,8203088 <_perror_r+0x60>
 8203048:	81400017 	ldw	r5,0(r16)
 820304c:	d80f883a 	mov	r7,sp
 8203050:	01800044 	movi	r6,1
 8203054:	8009883a 	mov	r4,r16
 8203058:	82036340 	call	8203634 <_strerror_r>
 820305c:	10000326 	beq	r2,zero,820306c <_perror_r+0x44>
 8203060:	81400317 	ldw	r5,12(r16)
 8203064:	1009883a 	mov	r4,r2
 8203068:	820ad100 	call	820ad10 <fputs>
 820306c:	81400317 	ldw	r5,12(r16)
 8203070:	01000284 	movi	r4,10
 8203074:	820ac180 	call	820ac18 <fputc>
 8203078:	dfc00217 	ldw	ra,8(sp)
 820307c:	dc000117 	ldw	r16,4(sp)
 8203080:	dec00304 	addi	sp,sp,12
 8203084:	f800283a 	ret
 8203088:	21400317 	ldw	r5,12(r4)
 820308c:	1009883a 	mov	r4,r2
 8203090:	820ad100 	call	820ad10 <fputs>
 8203094:	81400317 	ldw	r5,12(r16)
 8203098:	01020974 	movhi	r4,2085
 820309c:	21341704 	addi	r4,r4,-12196
 82030a0:	820ad100 	call	820ad10 <fputs>
 82030a4:	003fe806 	br	8203048 <_perror_r+0x20>

082030a8 <perror>:
 82030a8:	00820974 	movhi	r2,2085
 82030ac:	108eb804 	addi	r2,r2,15072
 82030b0:	200b883a 	mov	r5,r4
 82030b4:	11000017 	ldw	r4,0(r2)
 82030b8:	82030281 	jmpi	8203028 <_perror_r>

082030bc <_printf_r>:
 82030bc:	defffd04 	addi	sp,sp,-12
 82030c0:	2805883a 	mov	r2,r5
 82030c4:	dfc00015 	stw	ra,0(sp)
 82030c8:	d9800115 	stw	r6,4(sp)
 82030cc:	d9c00215 	stw	r7,8(sp)
 82030d0:	21400217 	ldw	r5,8(r4)
 82030d4:	d9c00104 	addi	r7,sp,4
 82030d8:	100d883a 	mov	r6,r2
 82030dc:	82067880 	call	8206788 <___vfprintf_internal_r>
 82030e0:	dfc00017 	ldw	ra,0(sp)
 82030e4:	dec00304 	addi	sp,sp,12
 82030e8:	f800283a 	ret

082030ec <printf>:
 82030ec:	defffc04 	addi	sp,sp,-16
 82030f0:	dfc00015 	stw	ra,0(sp)
 82030f4:	d9400115 	stw	r5,4(sp)
 82030f8:	d9800215 	stw	r6,8(sp)
 82030fc:	d9c00315 	stw	r7,12(sp)
 8203100:	00820974 	movhi	r2,2085
 8203104:	108eb804 	addi	r2,r2,15072
 8203108:	10800017 	ldw	r2,0(r2)
 820310c:	200b883a 	mov	r5,r4
 8203110:	d9800104 	addi	r6,sp,4
 8203114:	11000217 	ldw	r4,8(r2)
 8203118:	82089800 	call	8208980 <__vfprintf_internal>
 820311c:	dfc00017 	ldw	ra,0(sp)
 8203120:	dec00404 	addi	sp,sp,16
 8203124:	f800283a 	ret

08203128 <_putc_r>:
 8203128:	defffc04 	addi	sp,sp,-16
 820312c:	dc000215 	stw	r16,8(sp)
 8203130:	dfc00315 	stw	ra,12(sp)
 8203134:	2021883a 	mov	r16,r4
 8203138:	20000226 	beq	r4,zero,8203144 <_putc_r+0x1c>
 820313c:	20800e17 	ldw	r2,56(r4)
 8203140:	10001b26 	beq	r2,zero,82031b0 <_putc_r+0x88>
 8203144:	30800217 	ldw	r2,8(r6)
 8203148:	10bfffc4 	addi	r2,r2,-1
 820314c:	30800215 	stw	r2,8(r6)
 8203150:	10000a16 	blt	r2,zero,820317c <_putc_r+0x54>
 8203154:	30800017 	ldw	r2,0(r6)
 8203158:	11400005 	stb	r5,0(r2)
 820315c:	30800017 	ldw	r2,0(r6)
 8203160:	10c00044 	addi	r3,r2,1
 8203164:	30c00015 	stw	r3,0(r6)
 8203168:	10800003 	ldbu	r2,0(r2)
 820316c:	dfc00317 	ldw	ra,12(sp)
 8203170:	dc000217 	ldw	r16,8(sp)
 8203174:	dec00404 	addi	sp,sp,16
 8203178:	f800283a 	ret
 820317c:	30c00617 	ldw	r3,24(r6)
 8203180:	10c00616 	blt	r2,r3,820319c <_putc_r+0x74>
 8203184:	30800017 	ldw	r2,0(r6)
 8203188:	00c00284 	movi	r3,10
 820318c:	11400005 	stb	r5,0(r2)
 8203190:	30800017 	ldw	r2,0(r6)
 8203194:	11400003 	ldbu	r5,0(r2)
 8203198:	28fff11e 	bne	r5,r3,8203160 <_putc_r+0x38>
 820319c:	8009883a 	mov	r4,r16
 82031a0:	dfc00317 	ldw	ra,12(sp)
 82031a4:	dc000217 	ldw	r16,8(sp)
 82031a8:	dec00404 	addi	sp,sp,16
 82031ac:	8208a581 	jmpi	8208a58 <__swbuf_r>
 82031b0:	d9400015 	stw	r5,0(sp)
 82031b4:	d9800115 	stw	r6,4(sp)
 82031b8:	820ab840 	call	820ab84 <__sinit>
 82031bc:	d9800117 	ldw	r6,4(sp)
 82031c0:	d9400017 	ldw	r5,0(sp)
 82031c4:	003fdf06 	br	8203144 <_putc_r+0x1c>

082031c8 <putc>:
 82031c8:	00820974 	movhi	r2,2085
 82031cc:	defffc04 	addi	sp,sp,-16
 82031d0:	108eb804 	addi	r2,r2,15072
 82031d4:	dc000115 	stw	r16,4(sp)
 82031d8:	14000017 	ldw	r16,0(r2)
 82031dc:	dc400215 	stw	r17,8(sp)
 82031e0:	dfc00315 	stw	ra,12(sp)
 82031e4:	2023883a 	mov	r17,r4
 82031e8:	80000226 	beq	r16,zero,82031f4 <putc+0x2c>
 82031ec:	80800e17 	ldw	r2,56(r16)
 82031f0:	10001a26 	beq	r2,zero,820325c <putc+0x94>
 82031f4:	28800217 	ldw	r2,8(r5)
 82031f8:	10bfffc4 	addi	r2,r2,-1
 82031fc:	28800215 	stw	r2,8(r5)
 8203200:	10000b16 	blt	r2,zero,8203230 <putc+0x68>
 8203204:	28800017 	ldw	r2,0(r5)
 8203208:	14400005 	stb	r17,0(r2)
 820320c:	28800017 	ldw	r2,0(r5)
 8203210:	10c00044 	addi	r3,r2,1
 8203214:	28c00015 	stw	r3,0(r5)
 8203218:	10800003 	ldbu	r2,0(r2)
 820321c:	dfc00317 	ldw	ra,12(sp)
 8203220:	dc400217 	ldw	r17,8(sp)
 8203224:	dc000117 	ldw	r16,4(sp)
 8203228:	dec00404 	addi	sp,sp,16
 820322c:	f800283a 	ret
 8203230:	28c00617 	ldw	r3,24(r5)
 8203234:	10c00e16 	blt	r2,r3,8203270 <putc+0xa8>
 8203238:	28800017 	ldw	r2,0(r5)
 820323c:	01000284 	movi	r4,10
 8203240:	14400005 	stb	r17,0(r2)
 8203244:	28800017 	ldw	r2,0(r5)
 8203248:	10c00003 	ldbu	r3,0(r2)
 820324c:	193ff01e 	bne	r3,r4,8203210 <putc+0x48>
 8203250:	280d883a 	mov	r6,r5
 8203254:	180b883a 	mov	r5,r3
 8203258:	00000706 	br	8203278 <putc+0xb0>
 820325c:	8009883a 	mov	r4,r16
 8203260:	d9400015 	stw	r5,0(sp)
 8203264:	820ab840 	call	820ab84 <__sinit>
 8203268:	d9400017 	ldw	r5,0(sp)
 820326c:	003fe106 	br	82031f4 <putc+0x2c>
 8203270:	280d883a 	mov	r6,r5
 8203274:	880b883a 	mov	r5,r17
 8203278:	8009883a 	mov	r4,r16
 820327c:	dfc00317 	ldw	ra,12(sp)
 8203280:	dc400217 	ldw	r17,8(sp)
 8203284:	dc000117 	ldw	r16,4(sp)
 8203288:	dec00404 	addi	sp,sp,16
 820328c:	8208a581 	jmpi	8208a58 <__swbuf_r>

08203290 <_putchar_r>:
 8203290:	21800217 	ldw	r6,8(r4)
 8203294:	82031281 	jmpi	8203128 <_putc_r>

08203298 <putchar>:
 8203298:	00820974 	movhi	r2,2085
 820329c:	108eb804 	addi	r2,r2,15072
 82032a0:	200b883a 	mov	r5,r4
 82032a4:	11000017 	ldw	r4,0(r2)
 82032a8:	21800217 	ldw	r6,8(r4)
 82032ac:	82031281 	jmpi	8203128 <_putc_r>

082032b0 <_puts_r>:
 82032b0:	defff604 	addi	sp,sp,-40
 82032b4:	dc000715 	stw	r16,28(sp)
 82032b8:	2021883a 	mov	r16,r4
 82032bc:	2809883a 	mov	r4,r5
 82032c0:	dc400815 	stw	r17,32(sp)
 82032c4:	dfc00915 	stw	ra,36(sp)
 82032c8:	2823883a 	mov	r17,r5
 82032cc:	8203cac0 	call	8203cac <strlen>
 82032d0:	10c00044 	addi	r3,r2,1
 82032d4:	d8800115 	stw	r2,4(sp)
 82032d8:	00820974 	movhi	r2,2085
 82032dc:	10b41804 	addi	r2,r2,-12192
 82032e0:	d8800215 	stw	r2,8(sp)
 82032e4:	00800044 	movi	r2,1
 82032e8:	d8800315 	stw	r2,12(sp)
 82032ec:	00800084 	movi	r2,2
 82032f0:	dc400015 	stw	r17,0(sp)
 82032f4:	d8c00615 	stw	r3,24(sp)
 82032f8:	dec00415 	stw	sp,16(sp)
 82032fc:	d8800515 	stw	r2,20(sp)
 8203300:	80000226 	beq	r16,zero,820330c <_puts_r+0x5c>
 8203304:	80800e17 	ldw	r2,56(r16)
 8203308:	10001426 	beq	r2,zero,820335c <_puts_r+0xac>
 820330c:	81400217 	ldw	r5,8(r16)
 8203310:	2880030b 	ldhu	r2,12(r5)
 8203314:	10c8000c 	andi	r3,r2,8192
 8203318:	1800061e 	bne	r3,zero,8203334 <_puts_r+0x84>
 820331c:	29001917 	ldw	r4,100(r5)
 8203320:	00f7ffc4 	movi	r3,-8193
 8203324:	10880014 	ori	r2,r2,8192
 8203328:	20c6703a 	and	r3,r4,r3
 820332c:	2880030d 	sth	r2,12(r5)
 8203330:	28c01915 	stw	r3,100(r5)
 8203334:	d9800404 	addi	r6,sp,16
 8203338:	8009883a 	mov	r4,r16
 820333c:	820b15c0 	call	820b15c <__sfvwrite_r>
 8203340:	1000091e 	bne	r2,zero,8203368 <_puts_r+0xb8>
 8203344:	00800284 	movi	r2,10
 8203348:	dfc00917 	ldw	ra,36(sp)
 820334c:	dc400817 	ldw	r17,32(sp)
 8203350:	dc000717 	ldw	r16,28(sp)
 8203354:	dec00a04 	addi	sp,sp,40
 8203358:	f800283a 	ret
 820335c:	8009883a 	mov	r4,r16
 8203360:	820ab840 	call	820ab84 <__sinit>
 8203364:	003fe906 	br	820330c <_puts_r+0x5c>
 8203368:	00bfffc4 	movi	r2,-1
 820336c:	003ff606 	br	8203348 <_puts_r+0x98>

08203370 <puts>:
 8203370:	00820974 	movhi	r2,2085
 8203374:	108eb804 	addi	r2,r2,15072
 8203378:	200b883a 	mov	r5,r4
 820337c:	11000017 	ldw	r4,0(r2)
 8203380:	82032b01 	jmpi	82032b0 <_puts_r>

08203384 <__srget_r>:
 8203384:	defffd04 	addi	sp,sp,-12
 8203388:	dc400115 	stw	r17,4(sp)
 820338c:	dc000015 	stw	r16,0(sp)
 8203390:	dfc00215 	stw	ra,8(sp)
 8203394:	2023883a 	mov	r17,r4
 8203398:	2821883a 	mov	r16,r5
 820339c:	20000226 	beq	r4,zero,82033a8 <__srget_r+0x24>
 82033a0:	20800e17 	ldw	r2,56(r4)
 82033a4:	10001026 	beq	r2,zero,82033e8 <__srget_r+0x64>
 82033a8:	800b883a 	mov	r5,r16
 82033ac:	8809883a 	mov	r4,r17
 82033b0:	820d9200 	call	820d920 <__srefill_r>
 82033b4:	10000e1e 	bne	r2,zero,82033f0 <__srget_r+0x6c>
 82033b8:	80c00017 	ldw	r3,0(r16)
 82033bc:	80800117 	ldw	r2,4(r16)
 82033c0:	19000044 	addi	r4,r3,1
 82033c4:	10bfffc4 	addi	r2,r2,-1
 82033c8:	80800115 	stw	r2,4(r16)
 82033cc:	81000015 	stw	r4,0(r16)
 82033d0:	18800003 	ldbu	r2,0(r3)
 82033d4:	dfc00217 	ldw	ra,8(sp)
 82033d8:	dc400117 	ldw	r17,4(sp)
 82033dc:	dc000017 	ldw	r16,0(sp)
 82033e0:	dec00304 	addi	sp,sp,12
 82033e4:	f800283a 	ret
 82033e8:	820ab840 	call	820ab84 <__sinit>
 82033ec:	003fee06 	br	82033a8 <__srget_r+0x24>
 82033f0:	00bfffc4 	movi	r2,-1
 82033f4:	003ff706 	br	82033d4 <__srget_r+0x50>

082033f8 <__srget>:
 82033f8:	00820974 	movhi	r2,2085
 82033fc:	108eb804 	addi	r2,r2,15072
 8203400:	200b883a 	mov	r5,r4
 8203404:	11000017 	ldw	r4,0(r2)
 8203408:	82033841 	jmpi	8203384 <__srget_r>

0820340c <_sprintf_r>:
 820340c:	deffe404 	addi	sp,sp,-112
 8203410:	2807883a 	mov	r3,r5
 8203414:	dfc01a15 	stw	ra,104(sp)
 8203418:	d9c01b15 	stw	r7,108(sp)
 820341c:	00a00034 	movhi	r2,32768
 8203420:	10bfffc4 	addi	r2,r2,-1
 8203424:	02008204 	movi	r8,520
 8203428:	d8800215 	stw	r2,8(sp)
 820342c:	d8800515 	stw	r2,20(sp)
 8203430:	d9c01b04 	addi	r7,sp,108
 8203434:	d80b883a 	mov	r5,sp
 8203438:	00bfffc4 	movi	r2,-1
 820343c:	d8c00015 	stw	r3,0(sp)
 8203440:	d8c00415 	stw	r3,16(sp)
 8203444:	da00030d 	sth	r8,12(sp)
 8203448:	d880038d 	sth	r2,14(sp)
 820344c:	82045a80 	call	82045a8 <___svfprintf_internal_r>
 8203450:	d8c00017 	ldw	r3,0(sp)
 8203454:	18000005 	stb	zero,0(r3)
 8203458:	dfc01a17 	ldw	ra,104(sp)
 820345c:	dec01c04 	addi	sp,sp,112
 8203460:	f800283a 	ret

08203464 <sprintf>:
 8203464:	deffe304 	addi	sp,sp,-116
 8203468:	2007883a 	mov	r3,r4
 820346c:	dfc01a15 	stw	ra,104(sp)
 8203470:	d9801b15 	stw	r6,108(sp)
 8203474:	d9c01c15 	stw	r7,112(sp)
 8203478:	01020974 	movhi	r4,2085
 820347c:	210eb804 	addi	r4,r4,15072
 8203480:	21000017 	ldw	r4,0(r4)
 8203484:	00a00034 	movhi	r2,32768
 8203488:	10bfffc4 	addi	r2,r2,-1
 820348c:	280d883a 	mov	r6,r5
 8203490:	02008204 	movi	r8,520
 8203494:	d8800215 	stw	r2,8(sp)
 8203498:	d8800515 	stw	r2,20(sp)
 820349c:	d9c01b04 	addi	r7,sp,108
 82034a0:	d80b883a 	mov	r5,sp
 82034a4:	00bfffc4 	movi	r2,-1
 82034a8:	d8c00015 	stw	r3,0(sp)
 82034ac:	d8c00415 	stw	r3,16(sp)
 82034b0:	da00030d 	sth	r8,12(sp)
 82034b4:	d880038d 	sth	r2,14(sp)
 82034b8:	82045a80 	call	82045a8 <___svfprintf_internal_r>
 82034bc:	d8c00017 	ldw	r3,0(sp)
 82034c0:	18000005 	stb	zero,0(r3)
 82034c4:	dfc01a17 	ldw	ra,104(sp)
 82034c8:	dec01d04 	addi	sp,sp,116
 82034cc:	f800283a 	ret

082034d0 <strchr>:
 82034d0:	2ac03fcc 	andi	r11,r5,255
 82034d4:	2813883a 	mov	r9,r5
 82034d8:	208000cc 	andi	r2,r4,3
 82034dc:	58003726 	beq	r11,zero,82035bc <strchr+0xec>
 82034e0:	10000b26 	beq	r2,zero,8203510 <strchr+0x40>
 82034e4:	20800003 	ldbu	r2,0(r4)
 82034e8:	10003226 	beq	r2,zero,82035b4 <strchr+0xe4>
 82034ec:	28c03fcc 	andi	r3,r5,255
 82034f0:	5880041e 	bne	r11,r2,8203504 <strchr+0x34>
 82034f4:	00004d06 	br	820362c <strchr+0x15c>
 82034f8:	20800003 	ldbu	r2,0(r4)
 82034fc:	10002d26 	beq	r2,zero,82035b4 <strchr+0xe4>
 8203500:	18804a26 	beq	r3,r2,820362c <strchr+0x15c>
 8203504:	21000044 	addi	r4,r4,1
 8203508:	208000cc 	andi	r2,r4,3
 820350c:	103ffa1e 	bne	r2,zero,82034f8 <strchr+0x28>
 8203510:	29403fcc 	andi	r5,r5,255
 8203514:	2814923a 	slli	r10,r5,8
 8203518:	20800017 	ldw	r2,0(r4)
 820351c:	01bfbff4 	movhi	r6,65279
 8203520:	2a8ab03a 	or	r5,r5,r10
 8203524:	2814943a 	slli	r10,r5,16
 8203528:	31bfbfc4 	addi	r6,r6,-257
 820352c:	119b883a 	add	r13,r2,r6
 8203530:	5154b03a 	or	r10,r10,r5
 8203534:	008e303a 	nor	r7,zero,r2
 8203538:	5084f03a 	xor	r2,r10,r2
 820353c:	1191883a 	add	r8,r2,r6
 8203540:	0086303a 	nor	r3,zero,r2
 8203544:	03202074 	movhi	r12,32897
 8203548:	69ca703a 	and	r5,r13,r7
 820354c:	40c4703a 	and	r2,r8,r3
 8203550:	63202004 	addi	r12,r12,-32640
 8203554:	2884b03a 	or	r2,r5,r2
 8203558:	1304703a 	and	r2,r2,r12
 820355c:	10000c1e 	bne	r2,zero,8203590 <strchr+0xc0>
 8203560:	21000104 	addi	r4,r4,4
 8203564:	20c00017 	ldw	r3,0(r4)
 8203568:	50c4f03a 	xor	r2,r10,r3
 820356c:	1991883a 	add	r8,r3,r6
 8203570:	00ca303a 	nor	r5,zero,r3
 8203574:	118f883a 	add	r7,r2,r6
 8203578:	0086303a 	nor	r3,zero,r2
 820357c:	414a703a 	and	r5,r8,r5
 8203580:	38c4703a 	and	r2,r7,r3
 8203584:	2884b03a 	or	r2,r5,r2
 8203588:	1304703a 	and	r2,r2,r12
 820358c:	103ff426 	beq	r2,zero,8203560 <strchr+0x90>
 8203590:	20800003 	ldbu	r2,0(r4)
 8203594:	10000726 	beq	r2,zero,82035b4 <strchr+0xe4>
 8203598:	58802426 	beq	r11,r2,820362c <strchr+0x15c>
 820359c:	48c03fcc 	andi	r3,r9,255
 82035a0:	00000106 	br	82035a8 <strchr+0xd8>
 82035a4:	18802126 	beq	r3,r2,820362c <strchr+0x15c>
 82035a8:	21000044 	addi	r4,r4,1
 82035ac:	20800003 	ldbu	r2,0(r4)
 82035b0:	103ffc1e 	bne	r2,zero,82035a4 <strchr+0xd4>
 82035b4:	0005883a 	mov	r2,zero
 82035b8:	f800283a 	ret
 82035bc:	10000526 	beq	r2,zero,82035d4 <strchr+0x104>
 82035c0:	20800003 	ldbu	r2,0(r4)
 82035c4:	10001926 	beq	r2,zero,820362c <strchr+0x15c>
 82035c8:	21000044 	addi	r4,r4,1
 82035cc:	208000cc 	andi	r2,r4,3
 82035d0:	103ffb1e 	bne	r2,zero,82035c0 <strchr+0xf0>
 82035d4:	20800017 	ldw	r2,0(r4)
 82035d8:	01bfbff4 	movhi	r6,65279
 82035dc:	31bfbfc4 	addi	r6,r6,-257
 82035e0:	0086303a 	nor	r3,zero,r2
 82035e4:	01602074 	movhi	r5,32897
 82035e8:	1185883a 	add	r2,r2,r6
 82035ec:	29602004 	addi	r5,r5,-32640
 82035f0:	10c4703a 	and	r2,r2,r3
 82035f4:	1144703a 	and	r2,r2,r5
 82035f8:	1000071e 	bne	r2,zero,8203618 <strchr+0x148>
 82035fc:	21000104 	addi	r4,r4,4
 8203600:	20800017 	ldw	r2,0(r4)
 8203604:	1187883a 	add	r3,r2,r6
 8203608:	0084303a 	nor	r2,zero,r2
 820360c:	1884703a 	and	r2,r3,r2
 8203610:	1144703a 	and	r2,r2,r5
 8203614:	103ff926 	beq	r2,zero,82035fc <strchr+0x12c>
 8203618:	20800003 	ldbu	r2,0(r4)
 820361c:	10000326 	beq	r2,zero,820362c <strchr+0x15c>
 8203620:	21000044 	addi	r4,r4,1
 8203624:	20800003 	ldbu	r2,0(r4)
 8203628:	103ffd1e 	bne	r2,zero,8203620 <strchr+0x150>
 820362c:	2005883a 	mov	r2,r4
 8203630:	f800283a 	ret

08203634 <_strerror_r>:
 8203634:	deffff04 	addi	sp,sp,-4
 8203638:	2807883a 	mov	r3,r5
 820363c:	dfc00015 	stw	ra,0(sp)
 8203640:	00802384 	movi	r2,142
 8203644:	300b883a 	mov	r5,r6
 8203648:	10c18736 	bltu	r2,r3,8203c68 <_strerror_r+0x634>
 820364c:	181090ba 	slli	r8,r3,2
 8203650:	00820834 	movhi	r2,2080
 8203654:	108d9904 	addi	r2,r2,13924
 8203658:	4085883a 	add	r2,r8,r2
 820365c:	10800017 	ldw	r2,0(r2)
 8203660:	1000683a 	jmp	r2
 8203664:	082038a0 	cmpeqi	zero,at,-32542
 8203668:	08203c5c 	xori	zero,at,33009
 820366c:	08203c50 	cmplti	zero,at,-32527
 8203670:	08203c44 	addi	zero,at,-32527
 8203674:	08203c38 	rdprs	zero,at,-32528
 8203678:	08203c2c 	andhi	zero,at,33008
 820367c:	08203c20 	cmpeqi	zero,at,-32528
 8203680:	08203c14 	ori	zero,at,33008
 8203684:	08203c08 	cmpgei	zero,at,-32528
 8203688:	08203bfc 	xorhi	zero,at,33007
 820368c:	08203bf0 	cmpltui	zero,at,33007
 8203690:	08203be4 	muli	zero,at,-32529
 8203694:	08203bd8 	cmpnei	zero,at,-32529
 8203698:	08203bcc 	andi	zero,at,33007
 820369c:	08203bc0 	call	8203bc <OSCtxSw_SWITCH_PC+0x82037c>
 82036a0:	08203c68 	cmpgeui	zero,at,33009
 82036a4:	08203bb4 	orhi	zero,at,33006
 82036a8:	08203ba8 	cmpgeui	zero,at,33006
 82036ac:	08203b9c 	xori	zero,at,33006
 82036b0:	08203b90 	cmplti	zero,at,-32530
 82036b4:	08203b84 	addi	zero,at,-32530
 82036b8:	08203b78 	rdprs	zero,at,-32531
 82036bc:	08203b6c 	andhi	zero,at,33005
 82036c0:	08203b60 	cmpeqi	zero,at,-32531
 82036c4:	08203b54 	ori	zero,at,33005
 82036c8:	08203b48 	cmpgei	zero,at,-32531
 82036cc:	08203b3c 	xorhi	zero,at,33004
 82036d0:	08203b30 	cmpltui	zero,at,33004
 82036d4:	08203b24 	muli	zero,at,-32532
 82036d8:	08203b18 	cmpnei	zero,at,-32532
 82036dc:	08203b0c 	andi	zero,at,33004
 82036e0:	08203b00 	call	8203b0 <OSCtxSw_SWITCH_PC+0x820370>
 82036e4:	08203af4 	orhi	zero,at,33003
 82036e8:	08203ae8 	cmpgeui	zero,at,33003
 82036ec:	08203adc 	xori	zero,at,33003
 82036f0:	08203ad0 	cmplti	zero,at,-32533
 82036f4:	08203ac4 	addi	zero,at,-32533
 82036f8:	08203c68 	cmpgeui	zero,at,33009
 82036fc:	08203c68 	cmpgeui	zero,at,33009
 8203700:	08203c68 	cmpgeui	zero,at,33009
 8203704:	08203c68 	cmpgeui	zero,at,33009
 8203708:	08203c68 	cmpgeui	zero,at,33009
 820370c:	08203c68 	cmpgeui	zero,at,33009
 8203710:	08203c68 	cmpgeui	zero,at,33009
 8203714:	08203c68 	cmpgeui	zero,at,33009
 8203718:	08203ab8 	rdprs	zero,at,-32534
 820371c:	08203aac 	andhi	zero,at,33002
 8203720:	08203c68 	cmpgeui	zero,at,33009
 8203724:	08203c68 	cmpgeui	zero,at,33009
 8203728:	08203c68 	cmpgeui	zero,at,33009
 820372c:	08203c68 	cmpgeui	zero,at,33009
 8203730:	08203c68 	cmpgeui	zero,at,33009
 8203734:	08203c68 	cmpgeui	zero,at,33009
 8203738:	08203c68 	cmpgeui	zero,at,33009
 820373c:	08203c68 	cmpgeui	zero,at,33009
 8203740:	08203c68 	cmpgeui	zero,at,33009
 8203744:	08203c68 	cmpgeui	zero,at,33009
 8203748:	08203c68 	cmpgeui	zero,at,33009
 820374c:	08203c68 	cmpgeui	zero,at,33009
 8203750:	08203c68 	cmpgeui	zero,at,33009
 8203754:	08203aa0 	cmpeqi	zero,at,-32534
 8203758:	08203a94 	ori	zero,at,33002
 820375c:	08203a88 	cmpgei	zero,at,-32534
 8203760:	08203a7c 	xorhi	zero,at,33001
 8203764:	08203c68 	cmpgeui	zero,at,33009
 8203768:	08203c68 	cmpgeui	zero,at,33009
 820376c:	08203c68 	cmpgeui	zero,at,33009
 8203770:	08203a70 	cmpltui	zero,at,33001
 8203774:	08203c68 	cmpgeui	zero,at,33009
 8203778:	08203c68 	cmpgeui	zero,at,33009
 820377c:	08203c68 	cmpgeui	zero,at,33009
 8203780:	08203a64 	muli	zero,at,-32535
 8203784:	08203c68 	cmpgeui	zero,at,33009
 8203788:	08203c68 	cmpgeui	zero,at,33009
 820378c:	08203a58 	cmpnei	zero,at,-32535
 8203790:	08203c68 	cmpgeui	zero,at,33009
 8203794:	08203c68 	cmpgeui	zero,at,33009
 8203798:	08203a4c 	andi	zero,at,33001
 820379c:	08203c68 	cmpgeui	zero,at,33009
 82037a0:	08203c68 	cmpgeui	zero,at,33009
 82037a4:	08203c68 	cmpgeui	zero,at,33009
 82037a8:	08203c68 	cmpgeui	zero,at,33009
 82037ac:	08203c68 	cmpgeui	zero,at,33009
 82037b0:	08203c68 	cmpgeui	zero,at,33009
 82037b4:	08203c68 	cmpgeui	zero,at,33009
 82037b8:	08203c68 	cmpgeui	zero,at,33009
 82037bc:	08203c68 	cmpgeui	zero,at,33009
 82037c0:	08203c68 	cmpgeui	zero,at,33009
 82037c4:	08203a40 	call	8203a4 <OSCtxSw_SWITCH_PC+0x820364>
 82037c8:	08203c68 	cmpgeui	zero,at,33009
 82037cc:	08203a34 	orhi	zero,at,33000
 82037d0:	08203a28 	cmpgeui	zero,at,33000
 82037d4:	08203a1c 	xori	zero,at,33000
 82037d8:	08203c68 	cmpgeui	zero,at,33009
 82037dc:	08203c68 	cmpgeui	zero,at,33009
 82037e0:	08203a10 	cmplti	zero,at,-32536
 82037e4:	08203c68 	cmpgeui	zero,at,33009
 82037e8:	08203c68 	cmpgeui	zero,at,33009
 82037ec:	08203c68 	cmpgeui	zero,at,33009
 82037f0:	08203c68 	cmpgeui	zero,at,33009
 82037f4:	08203c68 	cmpgeui	zero,at,33009
 82037f8:	08203c68 	cmpgeui	zero,at,33009
 82037fc:	08203c68 	cmpgeui	zero,at,33009
 8203800:	08203c68 	cmpgeui	zero,at,33009
 8203804:	08203a04 	addi	zero,at,-32536
 8203808:	082039f8 	rdprs	zero,at,-32537
 820380c:	082039ec 	andhi	zero,at,32999
 8203810:	082039e0 	cmpeqi	zero,at,-32537
 8203814:	082039d4 	ori	zero,at,32999
 8203818:	082039c8 	cmpgei	zero,at,-32537
 820381c:	08203c68 	cmpgeui	zero,at,33009
 8203820:	082039bc 	xorhi	zero,at,32998
 8203824:	082039b0 	cmpltui	zero,at,32998
 8203828:	082039a4 	muli	zero,at,-32538
 820382c:	08203998 	cmpnei	zero,at,-32538
 8203830:	0820398c 	andi	zero,at,32998
 8203834:	08203980 	call	820398 <OSCtxSw_SWITCH_PC+0x820358>
 8203838:	08203974 	orhi	zero,at,32997
 820383c:	08203968 	cmpgeui	zero,at,32997
 8203840:	0820395c 	xori	zero,at,32997
 8203844:	08203950 	cmplti	zero,at,-32539
 8203848:	08203944 	addi	zero,at,-32539
 820384c:	08203938 	rdprs	zero,at,-32540
 8203850:	0820392c 	andhi	zero,at,32996
 8203854:	08203c68 	cmpgeui	zero,at,33009
 8203858:	08203920 	cmpeqi	zero,at,-32540
 820385c:	08203914 	ori	zero,at,32996
 8203860:	08203908 	cmpgei	zero,at,-32540
 8203864:	082038fc 	xorhi	zero,at,32995
 8203868:	08203c68 	cmpgeui	zero,at,33009
 820386c:	08203c68 	cmpgeui	zero,at,33009
 8203870:	08203c68 	cmpgeui	zero,at,33009
 8203874:	08203c68 	cmpgeui	zero,at,33009
 8203878:	08203c68 	cmpgeui	zero,at,33009
 820387c:	082038f0 	cmpltui	zero,at,32995
 8203880:	08203c68 	cmpgeui	zero,at,33009
 8203884:	08203c68 	cmpgeui	zero,at,33009
 8203888:	08203c68 	cmpgeui	zero,at,33009
 820388c:	082038e4 	muli	zero,at,-32541
 8203890:	082038d8 	cmpnei	zero,at,-32541
 8203894:	082038cc 	andi	zero,at,32995
 8203898:	082038c0 	call	82038c <OSCtxSw_SWITCH_PC+0x82034c>
 820389c:	082038b4 	orhi	zero,at,32994
 82038a0:	00820974 	movhi	r2,2085
 82038a4:	10b41904 	addi	r2,r2,-12188
 82038a8:	dfc00017 	ldw	ra,0(sp)
 82038ac:	dec00104 	addi	sp,sp,4
 82038b0:	f800283a 	ret
 82038b4:	00820974 	movhi	r2,2085
 82038b8:	10b5b604 	addi	r2,r2,-10536
 82038bc:	003ffa06 	br	82038a8 <_strerror_r+0x274>
 82038c0:	00820974 	movhi	r2,2085
 82038c4:	10b5b004 	addi	r2,r2,-10560
 82038c8:	003ff706 	br	82038a8 <_strerror_r+0x274>
 82038cc:	00820974 	movhi	r2,2085
 82038d0:	10b5ab04 	addi	r2,r2,-10580
 82038d4:	003ff406 	br	82038a8 <_strerror_r+0x274>
 82038d8:	00820974 	movhi	r2,2085
 82038dc:	10b5c404 	addi	r2,r2,-10480
 82038e0:	003ff106 	br	82038a8 <_strerror_r+0x274>
 82038e4:	00820974 	movhi	r2,2085
 82038e8:	10b50204 	addi	r2,r2,-11256
 82038ec:	003fee06 	br	82038a8 <_strerror_r+0x274>
 82038f0:	00820974 	movhi	r2,2085
 82038f4:	10b4d004 	addi	r2,r2,-11456
 82038f8:	003feb06 	br	82038a8 <_strerror_r+0x274>
 82038fc:	00820974 	movhi	r2,2085
 8203900:	10b59e04 	addi	r2,r2,-10632
 8203904:	003fe806 	br	82038a8 <_strerror_r+0x274>
 8203908:	00820974 	movhi	r2,2085
 820390c:	10b5a404 	addi	r2,r2,-10608
 8203910:	003fe506 	br	82038a8 <_strerror_r+0x274>
 8203914:	00820974 	movhi	r2,2085
 8203918:	10b49f04 	addi	r2,r2,-11652
 820391c:	003fe206 	br	82038a8 <_strerror_r+0x274>
 8203920:	00820974 	movhi	r2,2085
 8203924:	10b58f04 	addi	r2,r2,-10692
 8203928:	003fdf06 	br	82038a8 <_strerror_r+0x274>
 820392c:	00820974 	movhi	r2,2085
 8203930:	10b52c04 	addi	r2,r2,-11088
 8203934:	003fdc06 	br	82038a8 <_strerror_r+0x274>
 8203938:	00820974 	movhi	r2,2085
 820393c:	10b5ce04 	addi	r2,r2,-10440
 8203940:	003fd906 	br	82038a8 <_strerror_r+0x274>
 8203944:	00820974 	movhi	r2,2085
 8203948:	10b45104 	addi	r2,r2,-11964
 820394c:	003fd606 	br	82038a8 <_strerror_r+0x274>
 8203950:	00820974 	movhi	r2,2085
 8203954:	10b44304 	addi	r2,r2,-12020
 8203958:	003fd306 	br	82038a8 <_strerror_r+0x274>
 820395c:	00820974 	movhi	r2,2085
 8203960:	10b48504 	addi	r2,r2,-11756
 8203964:	003fd006 	br	82038a8 <_strerror_r+0x274>
 8203968:	00820974 	movhi	r2,2085
 820396c:	10b4c504 	addi	r2,r2,-11500
 8203970:	003fcd06 	br	82038a8 <_strerror_r+0x274>
 8203974:	00820974 	movhi	r2,2085
 8203978:	10b48104 	addi	r2,r2,-11772
 820397c:	003fca06 	br	82038a8 <_strerror_r+0x274>
 8203980:	00820974 	movhi	r2,2085
 8203984:	10b5d304 	addi	r2,r2,-10420
 8203988:	003fc706 	br	82038a8 <_strerror_r+0x274>
 820398c:	00820974 	movhi	r2,2085
 8203990:	10b49604 	addi	r2,r2,-11688
 8203994:	003fc406 	br	82038a8 <_strerror_r+0x274>
 8203998:	00820974 	movhi	r2,2085
 820399c:	10b50b04 	addi	r2,r2,-11220
 82039a0:	003fc106 	br	82038a8 <_strerror_r+0x274>
 82039a4:	00820974 	movhi	r2,2085
 82039a8:	10b59504 	addi	r2,r2,-10668
 82039ac:	003fbe06 	br	82038a8 <_strerror_r+0x274>
 82039b0:	00820974 	movhi	r2,2085
 82039b4:	10b58904 	addi	r2,r2,-10716
 82039b8:	003fbb06 	br	82038a8 <_strerror_r+0x274>
 82039bc:	00820974 	movhi	r2,2085
 82039c0:	10b57d04 	addi	r2,r2,-10764
 82039c4:	003fb806 	br	82038a8 <_strerror_r+0x274>
 82039c8:	00820974 	movhi	r2,2085
 82039cc:	10b57704 	addi	r2,r2,-10788
 82039d0:	003fb506 	br	82038a8 <_strerror_r+0x274>
 82039d4:	00820974 	movhi	r2,2085
 82039d8:	10b56f04 	addi	r2,r2,-10820
 82039dc:	003fb206 	br	82038a8 <_strerror_r+0x274>
 82039e0:	00820974 	movhi	r2,2085
 82039e4:	10b56704 	addi	r2,r2,-10852
 82039e8:	003faf06 	br	82038a8 <_strerror_r+0x274>
 82039ec:	00820974 	movhi	r2,2085
 82039f0:	10b55b04 	addi	r2,r2,-10900
 82039f4:	003fac06 	br	82038a8 <_strerror_r+0x274>
 82039f8:	00820974 	movhi	r2,2085
 82039fc:	10b55204 	addi	r2,r2,-10936
 8203a00:	003fa906 	br	82038a8 <_strerror_r+0x274>
 8203a04:	00820974 	movhi	r2,2085
 8203a08:	10b58204 	addi	r2,r2,-10744
 8203a0c:	003fa606 	br	82038a8 <_strerror_r+0x274>
 8203a10:	00820974 	movhi	r2,2085
 8203a14:	10b5bb04 	addi	r2,r2,-10516
 8203a18:	003fa306 	br	82038a8 <_strerror_r+0x274>
 8203a1c:	00820974 	movhi	r2,2085
 8203a20:	10b54c04 	addi	r2,r2,-10960
 8203a24:	003fa006 	br	82038a8 <_strerror_r+0x274>
 8203a28:	00820974 	movhi	r2,2085
 8203a2c:	10b54504 	addi	r2,r2,-10988
 8203a30:	003f9d06 	br	82038a8 <_strerror_r+0x274>
 8203a34:	00820974 	movhi	r2,2085
 8203a38:	10b54004 	addi	r2,r2,-11008
 8203a3c:	003f9a06 	br	82038a8 <_strerror_r+0x274>
 8203a40:	00820974 	movhi	r2,2085
 8203a44:	10b53904 	addi	r2,r2,-11036
 8203a48:	003f9706 	br	82038a8 <_strerror_r+0x274>
 8203a4c:	00820974 	movhi	r2,2085
 8203a50:	10b53604 	addi	r2,r2,-11048
 8203a54:	003f9406 	br	82038a8 <_strerror_r+0x274>
 8203a58:	00820974 	movhi	r2,2085
 8203a5c:	10b53104 	addi	r2,r2,-11068
 8203a60:	003f9106 	br	82038a8 <_strerror_r+0x274>
 8203a64:	00820974 	movhi	r2,2085
 8203a68:	10b52804 	addi	r2,r2,-11104
 8203a6c:	003f8e06 	br	82038a8 <_strerror_r+0x274>
 8203a70:	00820974 	movhi	r2,2085
 8203a74:	10b52204 	addi	r2,r2,-11128
 8203a78:	003f8b06 	br	82038a8 <_strerror_r+0x274>
 8203a7c:	00820974 	movhi	r2,2085
 8203a80:	10b51d04 	addi	r2,r2,-11148
 8203a84:	003f8806 	br	82038a8 <_strerror_r+0x274>
 8203a88:	00820974 	movhi	r2,2085
 8203a8c:	10b51704 	addi	r2,r2,-11172
 8203a90:	003f8506 	br	82038a8 <_strerror_r+0x274>
 8203a94:	00820974 	movhi	r2,2085
 8203a98:	10b55904 	addi	r2,r2,-10908
 8203a9c:	003f8206 	br	82038a8 <_strerror_r+0x274>
 8203aa0:	00820974 	movhi	r2,2085
 8203aa4:	10b51304 	addi	r2,r2,-11188
 8203aa8:	003f7f06 	br	82038a8 <_strerror_r+0x274>
 8203aac:	00820974 	movhi	r2,2085
 8203ab0:	10b51104 	addi	r2,r2,-11196
 8203ab4:	003f7c06 	br	82038a8 <_strerror_r+0x274>
 8203ab8:	00820974 	movhi	r2,2085
 8203abc:	10b50804 	addi	r2,r2,-11232
 8203ac0:	003f7906 	br	82038a8 <_strerror_r+0x274>
 8203ac4:	00820974 	movhi	r2,2085
 8203ac8:	10b4fd04 	addi	r2,r2,-11276
 8203acc:	003f7606 	br	82038a8 <_strerror_r+0x274>
 8203ad0:	00820974 	movhi	r2,2085
 8203ad4:	10b4f604 	addi	r2,r2,-11304
 8203ad8:	003f7306 	br	82038a8 <_strerror_r+0x274>
 8203adc:	00820974 	movhi	r2,2085
 8203ae0:	10b4f104 	addi	r2,r2,-11324
 8203ae4:	003f7006 	br	82038a8 <_strerror_r+0x274>
 8203ae8:	00820974 	movhi	r2,2085
 8203aec:	10b4e504 	addi	r2,r2,-11372
 8203af0:	003f6d06 	br	82038a8 <_strerror_r+0x274>
 8203af4:	00820974 	movhi	r2,2085
 8203af8:	10b4e204 	addi	r2,r2,-11384
 8203afc:	003f6a06 	br	82038a8 <_strerror_r+0x274>
 8203b00:	00820974 	movhi	r2,2085
 8203b04:	10b4de04 	addi	r2,r2,-11400
 8203b08:	003f6706 	br	82038a8 <_strerror_r+0x274>
 8203b0c:	00820974 	movhi	r2,2085
 8203b10:	10b4d804 	addi	r2,r2,-11424
 8203b14:	003f6406 	br	82038a8 <_strerror_r+0x274>
 8203b18:	00820974 	movhi	r2,2085
 8203b1c:	10b4d404 	addi	r2,r2,-11440
 8203b20:	003f6106 	br	82038a8 <_strerror_r+0x274>
 8203b24:	00820974 	movhi	r2,2085
 8203b28:	10b4ca04 	addi	r2,r2,-11480
 8203b2c:	003f5e06 	br	82038a8 <_strerror_r+0x274>
 8203b30:	00820974 	movhi	r2,2085
 8203b34:	10b4c104 	addi	r2,r2,-11516
 8203b38:	003f5b06 	br	82038a8 <_strerror_r+0x274>
 8203b3c:	00820974 	movhi	r2,2085
 8203b40:	10b4bd04 	addi	r2,r2,-11532
 8203b44:	003f5806 	br	82038a8 <_strerror_r+0x274>
 8203b48:	00820974 	movhi	r2,2085
 8203b4c:	10b4b704 	addi	r2,r2,-11556
 8203b50:	003f5506 	br	82038a8 <_strerror_r+0x274>
 8203b54:	00820974 	movhi	r2,2085
 8203b58:	10b4af04 	addi	r2,r2,-11588
 8203b5c:	003f5206 	br	82038a8 <_strerror_r+0x274>
 8203b60:	00820974 	movhi	r2,2085
 8203b64:	10b4a704 	addi	r2,r2,-11620
 8203b68:	003f4f06 	br	82038a8 <_strerror_r+0x274>
 8203b6c:	00820974 	movhi	r2,2085
 8203b70:	10b49104 	addi	r2,r2,-11708
 8203b74:	003f4c06 	br	82038a8 <_strerror_r+0x274>
 8203b78:	00820974 	movhi	r2,2085
 8203b7c:	10b48d04 	addi	r2,r2,-11724
 8203b80:	003f4906 	br	82038a8 <_strerror_r+0x274>
 8203b84:	00820974 	movhi	r2,2085
 8203b88:	10b47d04 	addi	r2,r2,-11788
 8203b8c:	003f4606 	br	82038a8 <_strerror_r+0x274>
 8203b90:	00820974 	movhi	r2,2085
 8203b94:	10b47904 	addi	r2,r2,-11804
 8203b98:	003f4306 	br	82038a8 <_strerror_r+0x274>
 8203b9c:	00820974 	movhi	r2,2085
 8203ba0:	10b47404 	addi	r2,r2,-11824
 8203ba4:	003f4006 	br	82038a8 <_strerror_r+0x274>
 8203ba8:	00820974 	movhi	r2,2085
 8203bac:	10b47104 	addi	r2,r2,-11836
 8203bb0:	003f3d06 	br	82038a8 <_strerror_r+0x274>
 8203bb4:	00820974 	movhi	r2,2085
 8203bb8:	10b46b04 	addi	r2,r2,-11860
 8203bbc:	003f3a06 	br	82038a8 <_strerror_r+0x274>
 8203bc0:	00820974 	movhi	r2,2085
 8203bc4:	10b46804 	addi	r2,r2,-11872
 8203bc8:	003f3706 	br	82038a8 <_strerror_r+0x274>
 8203bcc:	00820974 	movhi	r2,2085
 8203bd0:	10b46304 	addi	r2,r2,-11892
 8203bd4:	003f3406 	br	82038a8 <_strerror_r+0x274>
 8203bd8:	00820974 	movhi	r2,2085
 8203bdc:	10b45e04 	addi	r2,r2,-11912
 8203be0:	003f3106 	br	82038a8 <_strerror_r+0x274>
 8203be4:	00820974 	movhi	r2,2085
 8203be8:	10b45904 	addi	r2,r2,-11932
 8203bec:	003f2e06 	br	82038a8 <_strerror_r+0x274>
 8203bf0:	00820974 	movhi	r2,2085
 8203bf4:	10b44e04 	addi	r2,r2,-11976
 8203bf8:	003f2b06 	br	82038a8 <_strerror_r+0x274>
 8203bfc:	00820974 	movhi	r2,2085
 8203c00:	10b44a04 	addi	r2,r2,-11992
 8203c04:	003f2806 	br	82038a8 <_strerror_r+0x274>
 8203c08:	00820974 	movhi	r2,2085
 8203c0c:	10b43e04 	addi	r2,r2,-12040
 8203c10:	003f2506 	br	82038a8 <_strerror_r+0x274>
 8203c14:	00820974 	movhi	r2,2085
 8203c18:	10b43904 	addi	r2,r2,-12060
 8203c1c:	003f2206 	br	82038a8 <_strerror_r+0x274>
 8203c20:	00820974 	movhi	r2,2085
 8203c24:	10b43204 	addi	r2,r2,-12088
 8203c28:	003f1f06 	br	82038a8 <_strerror_r+0x274>
 8203c2c:	00820974 	movhi	r2,2085
 8203c30:	10b42f04 	addi	r2,r2,-12100
 8203c34:	003f1c06 	br	82038a8 <_strerror_r+0x274>
 8203c38:	00820974 	movhi	r2,2085
 8203c3c:	10b42904 	addi	r2,r2,-12124
 8203c40:	003f1906 	br	82038a8 <_strerror_r+0x274>
 8203c44:	00820974 	movhi	r2,2085
 8203c48:	10b42504 	addi	r2,r2,-12140
 8203c4c:	003f1606 	br	82038a8 <_strerror_r+0x274>
 8203c50:	00820974 	movhi	r2,2085
 8203c54:	10b41e04 	addi	r2,r2,-12168
 8203c58:	003f1306 	br	82038a8 <_strerror_r+0x274>
 8203c5c:	00820974 	movhi	r2,2085
 8203c60:	10b41b04 	addi	r2,r2,-12180
 8203c64:	003f1006 	br	82038a8 <_strerror_r+0x274>
 8203c68:	38000726 	beq	r7,zero,8203c88 <_strerror_r+0x654>
 8203c6c:	380d883a 	mov	r6,r7
 8203c70:	1809883a 	mov	r4,r3
 8203c74:	82067800 	call	8206780 <_user_strerror>
 8203c78:	103f0b1e 	bne	r2,zero,82038a8 <_strerror_r+0x274>
 8203c7c:	00820974 	movhi	r2,2085
 8203c80:	10b5e104 	addi	r2,r2,-10364
 8203c84:	003f0806 	br	82038a8 <_strerror_r+0x274>
 8203c88:	200f883a 	mov	r7,r4
 8203c8c:	003ff706 	br	8203c6c <_strerror_r+0x638>

08203c90 <strerror>:
 8203c90:	00820974 	movhi	r2,2085
 8203c94:	108eb804 	addi	r2,r2,15072
 8203c98:	200b883a 	mov	r5,r4
 8203c9c:	11000017 	ldw	r4,0(r2)
 8203ca0:	000f883a 	mov	r7,zero
 8203ca4:	000d883a 	mov	r6,zero
 8203ca8:	82036341 	jmpi	8203634 <_strerror_r>

08203cac <strlen>:
 8203cac:	208000cc 	andi	r2,r4,3
 8203cb0:	10002026 	beq	r2,zero,8203d34 <strlen+0x88>
 8203cb4:	20800007 	ldb	r2,0(r4)
 8203cb8:	10002026 	beq	r2,zero,8203d3c <strlen+0x90>
 8203cbc:	2005883a 	mov	r2,r4
 8203cc0:	00000206 	br	8203ccc <strlen+0x20>
 8203cc4:	10c00007 	ldb	r3,0(r2)
 8203cc8:	18001826 	beq	r3,zero,8203d2c <strlen+0x80>
 8203ccc:	10800044 	addi	r2,r2,1
 8203cd0:	10c000cc 	andi	r3,r2,3
 8203cd4:	183ffb1e 	bne	r3,zero,8203cc4 <strlen+0x18>
 8203cd8:	10c00017 	ldw	r3,0(r2)
 8203cdc:	01ffbff4 	movhi	r7,65279
 8203ce0:	39ffbfc4 	addi	r7,r7,-257
 8203ce4:	00ca303a 	nor	r5,zero,r3
 8203ce8:	01a02074 	movhi	r6,32897
 8203cec:	19c7883a 	add	r3,r3,r7
 8203cf0:	31a02004 	addi	r6,r6,-32640
 8203cf4:	1946703a 	and	r3,r3,r5
 8203cf8:	1986703a 	and	r3,r3,r6
 8203cfc:	1800091e 	bne	r3,zero,8203d24 <strlen+0x78>
 8203d00:	10800104 	addi	r2,r2,4
 8203d04:	10c00017 	ldw	r3,0(r2)
 8203d08:	19cb883a 	add	r5,r3,r7
 8203d0c:	00c6303a 	nor	r3,zero,r3
 8203d10:	28c6703a 	and	r3,r5,r3
 8203d14:	1986703a 	and	r3,r3,r6
 8203d18:	183ff926 	beq	r3,zero,8203d00 <strlen+0x54>
 8203d1c:	00000106 	br	8203d24 <strlen+0x78>
 8203d20:	10800044 	addi	r2,r2,1
 8203d24:	10c00007 	ldb	r3,0(r2)
 8203d28:	183ffd1e 	bne	r3,zero,8203d20 <strlen+0x74>
 8203d2c:	1105c83a 	sub	r2,r2,r4
 8203d30:	f800283a 	ret
 8203d34:	2005883a 	mov	r2,r4
 8203d38:	003fe706 	br	8203cd8 <strlen+0x2c>
 8203d3c:	0005883a 	mov	r2,zero
 8203d40:	f800283a 	ret

08203d44 <critical_factorization>:
 8203d44:	02c00044 	movi	r11,1
 8203d48:	5811883a 	mov	r8,r11
 8203d4c:	0013883a 	mov	r9,zero
 8203d50:	00bfffc4 	movi	r2,-1
 8203d54:	2087883a 	add	r3,r4,r2
 8203d58:	1a0f883a 	add	r7,r3,r8
 8203d5c:	4a07883a 	add	r3,r9,r8
 8203d60:	20d5883a 	add	r10,r4,r3
 8203d64:	1940102e 	bgeu	r3,r5,8203da8 <critical_factorization+0x64>
 8203d68:	52800003 	ldbu	r10,0(r10)
 8203d6c:	39c00003 	ldbu	r7,0(r7)
 8203d70:	51c0042e 	bgeu	r10,r7,8203d84 <critical_factorization+0x40>
 8203d74:	1897c83a 	sub	r11,r3,r2
 8203d78:	1813883a 	mov	r9,r3
 8203d7c:	02000044 	movi	r8,1
 8203d80:	003ff406 	br	8203d54 <critical_factorization+0x10>
 8203d84:	51c00526 	beq	r10,r7,8203d9c <critical_factorization+0x58>
 8203d88:	02c00044 	movi	r11,1
 8203d8c:	4805883a 	mov	r2,r9
 8203d90:	5811883a 	mov	r8,r11
 8203d94:	4ad3883a 	add	r9,r9,r11
 8203d98:	003fee06 	br	8203d54 <critical_factorization+0x10>
 8203d9c:	42c02226 	beq	r8,r11,8203e28 <critical_factorization+0xe4>
 8203da0:	42000044 	addi	r8,r8,1
 8203da4:	003feb06 	br	8203d54 <critical_factorization+0x10>
 8203da8:	03000044 	movi	r12,1
 8203dac:	32c00015 	stw	r11,0(r6)
 8203db0:	6011883a 	mov	r8,r12
 8203db4:	0013883a 	mov	r9,zero
 8203db8:	02ffffc4 	movi	r11,-1
 8203dbc:	22c7883a 	add	r3,r4,r11
 8203dc0:	1a0f883a 	add	r7,r3,r8
 8203dc4:	4a07883a 	add	r3,r9,r8
 8203dc8:	20d5883a 	add	r10,r4,r3
 8203dcc:	1940102e 	bgeu	r3,r5,8203e10 <critical_factorization+0xcc>
 8203dd0:	52800003 	ldbu	r10,0(r10)
 8203dd4:	39c00003 	ldbu	r7,0(r7)
 8203dd8:	3a80042e 	bgeu	r7,r10,8203dec <critical_factorization+0xa8>
 8203ddc:	1ad9c83a 	sub	r12,r3,r11
 8203de0:	1813883a 	mov	r9,r3
 8203de4:	02000044 	movi	r8,1
 8203de8:	003ff406 	br	8203dbc <critical_factorization+0x78>
 8203dec:	51c00526 	beq	r10,r7,8203e04 <critical_factorization+0xc0>
 8203df0:	03000044 	movi	r12,1
 8203df4:	4817883a 	mov	r11,r9
 8203df8:	6011883a 	mov	r8,r12
 8203dfc:	4b13883a 	add	r9,r9,r12
 8203e00:	003fee06 	br	8203dbc <critical_factorization+0x78>
 8203e04:	43000c26 	beq	r8,r12,8203e38 <critical_factorization+0xf4>
 8203e08:	42000044 	addi	r8,r8,1
 8203e0c:	003feb06 	br	8203dbc <critical_factorization+0x78>
 8203e10:	5ac00044 	addi	r11,r11,1
 8203e14:	10800044 	addi	r2,r2,1
 8203e18:	58800236 	bltu	r11,r2,8203e24 <critical_factorization+0xe0>
 8203e1c:	33000015 	stw	r12,0(r6)
 8203e20:	5805883a 	mov	r2,r11
 8203e24:	f800283a 	ret
 8203e28:	4017883a 	mov	r11,r8
 8203e2c:	1813883a 	mov	r9,r3
 8203e30:	02000044 	movi	r8,1
 8203e34:	003fc706 	br	8203d54 <critical_factorization+0x10>
 8203e38:	4019883a 	mov	r12,r8
 8203e3c:	1813883a 	mov	r9,r3
 8203e40:	02000044 	movi	r8,1
 8203e44:	003fdd06 	br	8203dbc <critical_factorization+0x78>

08203e48 <two_way_long_needle>:
 8203e48:	defef104 	addi	sp,sp,-1084
 8203e4c:	dc810715 	stw	r18,1052(sp)
 8203e50:	dc410615 	stw	r17,1048(sp)
 8203e54:	dc810004 	addi	r18,sp,1024
 8203e58:	3023883a 	mov	r17,r6
 8203e5c:	2807883a 	mov	r3,r5
 8203e60:	ddc10c15 	stw	r23,1072(sp)
 8203e64:	900d883a 	mov	r6,r18
 8203e68:	202f883a 	mov	r23,r4
 8203e6c:	380b883a 	mov	r5,r7
 8203e70:	8809883a 	mov	r4,r17
 8203e74:	dd810b15 	stw	r22,1068(sp)
 8203e78:	dc010515 	stw	r16,1044(sp)
 8203e7c:	d8c10415 	stw	r3,1040(sp)
 8203e80:	dfc10e15 	stw	ra,1080(sp)
 8203e84:	df010d15 	stw	fp,1076(sp)
 8203e88:	dd410a15 	stw	r21,1064(sp)
 8203e8c:	dd010915 	stw	r20,1060(sp)
 8203e90:	dcc10815 	stw	r19,1056(sp)
 8203e94:	382d883a 	mov	r22,r7
 8203e98:	8203d440 	call	8203d44 <critical_factorization>
 8203e9c:	d8c10417 	ldw	r3,1040(sp)
 8203ea0:	1021883a 	mov	r16,r2
 8203ea4:	d805883a 	mov	r2,sp
 8203ea8:	15800015 	stw	r22,0(r2)
 8203eac:	10800104 	addi	r2,r2,4
 8203eb0:	90bffd1e 	bne	r18,r2,8203ea8 <two_way_long_needle+0x60>
 8203eb4:	b0000b26 	beq	r22,zero,8203ee4 <two_way_long_needle+0x9c>
 8203eb8:	b17fffc4 	addi	r5,r22,-1
 8203ebc:	8809883a 	mov	r4,r17
 8203ec0:	8d8d883a 	add	r6,r17,r22
 8203ec4:	20800003 	ldbu	r2,0(r4)
 8203ec8:	21000044 	addi	r4,r4,1
 8203ecc:	1085883a 	add	r2,r2,r2
 8203ed0:	1085883a 	add	r2,r2,r2
 8203ed4:	d885883a 	add	r2,sp,r2
 8203ed8:	11400015 	stw	r5,0(r2)
 8203edc:	297fffc4 	addi	r5,r5,-1
 8203ee0:	21bff81e 	bne	r4,r6,8203ec4 <two_way_long_needle+0x7c>
 8203ee4:	d9410017 	ldw	r5,1024(sp)
 8203ee8:	800d883a 	mov	r6,r16
 8203eec:	8809883a 	mov	r4,r17
 8203ef0:	894b883a 	add	r5,r17,r5
 8203ef4:	d8c10415 	stw	r3,1040(sp)
 8203ef8:	820c3280 	call	820c328 <memcmp>
 8203efc:	d8c10417 	ldw	r3,1040(sp)
 8203f00:	10006a1e 	bne	r2,zero,82040ac <two_way_long_needle+0x264>
 8203f04:	84bfffc4 	addi	r18,r16,-1
 8203f08:	8c85883a 	add	r2,r17,r18
 8203f0c:	d8810215 	stw	r2,1032(sp)
 8203f10:	00800044 	movi	r2,1
 8203f14:	813fff84 	addi	r4,r16,-2
 8203f18:	1405c83a 	sub	r2,r2,r16
 8203f1c:	0029883a 	mov	r20,zero
 8203f20:	0039883a 	mov	fp,zero
 8203f24:	b57fffc4 	addi	r21,r22,-1
 8203f28:	d9010115 	stw	r4,1028(sp)
 8203f2c:	d8810315 	stw	r2,1036(sp)
 8203f30:	00000706 	br	8203f50 <two_way_long_needle+0x108>
 8203f34:	a0000326 	beq	r20,zero,8203f44 <two_way_long_needle+0xfc>
 8203f38:	d8c10017 	ldw	r3,1024(sp)
 8203f3c:	10c0012e 	bgeu	r2,r3,8203f44 <two_way_long_needle+0xfc>
 8203f40:	b0c5c83a 	sub	r2,r22,r3
 8203f44:	e0b9883a 	add	fp,fp,r2
 8203f48:	0029883a 	mov	r20,zero
 8203f4c:	9807883a 	mov	r3,r19
 8203f50:	e5a7883a 	add	r19,fp,r22
 8203f54:	98cdc83a 	sub	r6,r19,r3
 8203f58:	000b883a 	mov	r5,zero
 8203f5c:	b8c9883a 	add	r4,r23,r3
 8203f60:	820c2440 	call	820c244 <memchr>
 8203f64:	1000441e 	bne	r2,zero,8204078 <two_way_long_needle+0x230>
 8203f68:	98004326 	beq	r19,zero,8204078 <two_way_long_needle+0x230>
 8203f6c:	bcc5883a 	add	r2,r23,r19
 8203f70:	10bfffc3 	ldbu	r2,-1(r2)
 8203f74:	1085883a 	add	r2,r2,r2
 8203f78:	1085883a 	add	r2,r2,r2
 8203f7c:	d885883a 	add	r2,sp,r2
 8203f80:	10800017 	ldw	r2,0(r2)
 8203f84:	103feb1e 	bne	r2,zero,8203f34 <two_way_long_needle+0xec>
 8203f88:	a015883a 	mov	r10,r20
 8203f8c:	a400012e 	bgeu	r20,r16,8203f94 <two_way_long_needle+0x14c>
 8203f90:	8015883a 	mov	r10,r16
 8203f94:	5540152e 	bgeu	r10,r21,8203fec <two_way_long_needle+0x1a4>
 8203f98:	bf05883a 	add	r2,r23,fp
 8203f9c:	8a87883a 	add	r3,r17,r10
 8203fa0:	1285883a 	add	r2,r2,r10
 8203fa4:	18c00003 	ldbu	r3,0(r3)
 8203fa8:	10800003 	ldbu	r2,0(r2)
 8203fac:	18802d1e 	bne	r3,r2,8204064 <two_way_long_needle+0x21c>
 8203fb0:	e1400044 	addi	r5,fp,1
 8203fb4:	50800044 	addi	r2,r10,1
 8203fb8:	2a8b883a 	add	r5,r5,r10
 8203fbc:	888d883a 	add	r6,r17,r2
 8203fc0:	b94b883a 	add	r5,r23,r5
 8203fc4:	00000706 	br	8203fe4 <two_way_long_needle+0x19c>
 8203fc8:	31000003 	ldbu	r4,0(r6)
 8203fcc:	28c00003 	ldbu	r3,0(r5)
 8203fd0:	31800044 	addi	r6,r6,1
 8203fd4:	21003fcc 	andi	r4,r4,255
 8203fd8:	29400044 	addi	r5,r5,1
 8203fdc:	20c0211e 	bne	r4,r3,8204064 <two_way_long_needle+0x21c>
 8203fe0:	10800044 	addi	r2,r2,1
 8203fe4:	1015883a 	mov	r10,r2
 8203fe8:	157ff736 	bltu	r2,r21,8203fc8 <two_way_long_needle+0x180>
 8203fec:	900d883a 	mov	r6,r18
 8203ff0:	a4007d2e 	bgeu	r20,r16,82041e8 <two_way_long_needle+0x3a0>
 8203ff4:	d9410217 	ldw	r5,1032(sp)
 8203ff8:	bf05883a 	add	r2,r23,fp
 8203ffc:	1485883a 	add	r2,r2,r18
 8204000:	28c00003 	ldbu	r3,0(r5)
 8204004:	10800003 	ldbu	r2,0(r2)
 8204008:	1880771e 	bne	r3,r2,82041e8 <two_way_long_needle+0x3a0>
 820400c:	d8c10117 	ldw	r3,1028(sp)
 8204010:	a2ffffc4 	addi	r11,r20,-1
 8204014:	8ad7883a 	add	r11,r17,r11
 8204018:	e0cb883a 	add	r5,fp,r3
 820401c:	88c5883a 	add	r2,r17,r3
 8204020:	b94b883a 	add	r5,r23,r5
 8204024:	00000706 	br	8204044 <two_way_long_needle+0x1fc>
 8204028:	11000003 	ldbu	r4,0(r2)
 820402c:	28c00003 	ldbu	r3,0(r5)
 8204030:	10bfffc4 	addi	r2,r2,-1
 8204034:	21003fcc 	andi	r4,r4,255
 8204038:	297fffc4 	addi	r5,r5,-1
 820403c:	20c0031e 	bne	r4,r3,820404c <two_way_long_needle+0x204>
 8204040:	500d883a 	mov	r6,r10
 8204044:	32bfffc4 	addi	r10,r6,-1
 8204048:	58bff71e 	bne	r11,r2,8204028 <two_way_long_needle+0x1e0>
 820404c:	a2400044 	addi	r9,r20,1
 8204050:	32406736 	bltu	r6,r9,82041f0 <two_way_long_needle+0x3a8>
 8204054:	da410017 	ldw	r9,1024(sp)
 8204058:	e279883a 	add	fp,fp,r9
 820405c:	b269c83a 	sub	r20,r22,r9
 8204060:	003fba06 	br	8203f4c <two_way_long_needle+0x104>
 8204064:	d8c10317 	ldw	r3,1036(sp)
 8204068:	0029883a 	mov	r20,zero
 820406c:	1f39883a 	add	fp,r3,fp
 8204070:	e2b9883a 	add	fp,fp,r10
 8204074:	003fb506 	br	8203f4c <two_way_long_needle+0x104>
 8204078:	0005883a 	mov	r2,zero
 820407c:	dfc10e17 	ldw	ra,1080(sp)
 8204080:	df010d17 	ldw	fp,1076(sp)
 8204084:	ddc10c17 	ldw	r23,1072(sp)
 8204088:	dd810b17 	ldw	r22,1068(sp)
 820408c:	dd410a17 	ldw	r21,1064(sp)
 8204090:	dd010917 	ldw	r20,1060(sp)
 8204094:	dcc10817 	ldw	r19,1056(sp)
 8204098:	dc810717 	ldw	r18,1052(sp)
 820409c:	dc410617 	ldw	r17,1048(sp)
 82040a0:	dc010517 	ldw	r16,1044(sp)
 82040a4:	dec10f04 	addi	sp,sp,1084
 82040a8:	f800283a 	ret
 82040ac:	b405c83a 	sub	r2,r22,r16
 82040b0:	14004b36 	bltu	r2,r16,82041e0 <two_way_long_needle+0x398>
 82040b4:	10800044 	addi	r2,r2,1
 82040b8:	84bfffc4 	addi	r18,r16,-1
 82040bc:	d8810015 	stw	r2,1024(sp)
 82040c0:	00800044 	movi	r2,1
 82040c4:	8c89883a 	add	r4,r17,r18
 82040c8:	817fff84 	addi	r5,r16,-2
 82040cc:	1405c83a 	sub	r2,r2,r16
 82040d0:	0029883a 	mov	r20,zero
 82040d4:	b73fffc4 	addi	fp,r22,-1
 82040d8:	d9010215 	stw	r4,1032(sp)
 82040dc:	d9410115 	stw	r5,1028(sp)
 82040e0:	8d7fffc4 	addi	r21,r17,-1
 82040e4:	d8810315 	stw	r2,1036(sp)
 82040e8:	a5a7883a 	add	r19,r20,r22
 82040ec:	98cdc83a 	sub	r6,r19,r3
 82040f0:	000b883a 	mov	r5,zero
 82040f4:	b8c9883a 	add	r4,r23,r3
 82040f8:	820c2440 	call	820c244 <memchr>
 82040fc:	103fde1e 	bne	r2,zero,8204078 <two_way_long_needle+0x230>
 8204100:	983fdd26 	beq	r19,zero,8204078 <two_way_long_needle+0x230>
 8204104:	bcc5883a 	add	r2,r23,r19
 8204108:	10bfffc3 	ldbu	r2,-1(r2)
 820410c:	1085883a 	add	r2,r2,r2
 8204110:	1085883a 	add	r2,r2,r2
 8204114:	d885883a 	add	r2,sp,r2
 8204118:	10800017 	ldw	r2,0(r2)
 820411c:	1000291e 	bne	r2,zero,82041c4 <two_way_long_needle+0x37c>
 8204120:	bd05883a 	add	r2,r23,r20
 8204124:	8700142e 	bgeu	r16,fp,8204178 <two_way_long_needle+0x330>
 8204128:	8c07883a 	add	r3,r17,r16
 820412c:	140b883a 	add	r5,r2,r16
 8204130:	19000003 	ldbu	r4,0(r3)
 8204134:	28c00003 	ldbu	r3,0(r5)
 8204138:	800d883a 	mov	r6,r16
 820413c:	20c0241e 	bne	r4,r3,82041d0 <two_way_long_needle+0x388>
 8204140:	81400044 	addi	r5,r16,1
 8204144:	a155883a 	add	r10,r20,r5
 8204148:	ba95883a 	add	r10,r23,r10
 820414c:	894b883a 	add	r5,r17,r5
 8204150:	800d883a 	mov	r6,r16
 8204154:	00000606 	br	8204170 <two_way_long_needle+0x328>
 8204158:	29000003 	ldbu	r4,0(r5)
 820415c:	50c00003 	ldbu	r3,0(r10)
 8204160:	29400044 	addi	r5,r5,1
 8204164:	21003fcc 	andi	r4,r4,255
 8204168:	52800044 	addi	r10,r10,1
 820416c:	20c0181e 	bne	r4,r3,82041d0 <two_way_long_needle+0x388>
 8204170:	31800044 	addi	r6,r6,1
 8204174:	373ff836 	bltu	r6,fp,8204158 <two_way_long_needle+0x310>
 8204178:	00ffffc4 	movi	r3,-1
 820417c:	90ffbf26 	beq	r18,r3,820407c <two_way_long_needle+0x234>
 8204180:	d9410217 	ldw	r5,1032(sp)
 8204184:	1487883a 	add	r3,r2,r18
 8204188:	18c00003 	ldbu	r3,0(r3)
 820418c:	29000003 	ldbu	r4,0(r5)
 8204190:	20c00b1e 	bne	r4,r3,82041c0 <two_way_long_needle+0x378>
 8204194:	d8c10117 	ldw	r3,1028(sp)
 8204198:	a0cd883a 	add	r6,r20,r3
 820419c:	b98d883a 	add	r6,r23,r6
 82041a0:	88c7883a 	add	r3,r17,r3
 82041a4:	1d7fb526 	beq	r3,r21,820407c <two_way_long_needle+0x234>
 82041a8:	19400003 	ldbu	r5,0(r3)
 82041ac:	31000003 	ldbu	r4,0(r6)
 82041b0:	18ffffc4 	addi	r3,r3,-1
 82041b4:	29403fcc 	andi	r5,r5,255
 82041b8:	31bfffc4 	addi	r6,r6,-1
 82041bc:	293ff926 	beq	r5,r4,82041a4 <two_way_long_needle+0x35c>
 82041c0:	d8810017 	ldw	r2,1024(sp)
 82041c4:	a0a9883a 	add	r20,r20,r2
 82041c8:	9807883a 	mov	r3,r19
 82041cc:	003fc606 	br	82040e8 <two_way_long_needle+0x2a0>
 82041d0:	d8c10317 	ldw	r3,1036(sp)
 82041d4:	1d11883a 	add	r8,r3,r20
 82041d8:	41a9883a 	add	r20,r8,r6
 82041dc:	003ffa06 	br	82041c8 <two_way_long_needle+0x380>
 82041e0:	8005883a 	mov	r2,r16
 82041e4:	003fb306 	br	82040b4 <two_way_long_needle+0x26c>
 82041e8:	800d883a 	mov	r6,r16
 82041ec:	003f9706 	br	820404c <two_way_long_needle+0x204>
 82041f0:	bf05883a 	add	r2,r23,fp
 82041f4:	003fa106 	br	820407c <two_way_long_needle+0x234>

082041f8 <strstr>:
 82041f8:	21800007 	ldb	r6,0(r4)
 82041fc:	30009226 	beq	r6,zero,8204448 <strstr+0x250>
 8204200:	28c00007 	ldb	r3,0(r5)
 8204204:	18000f26 	beq	r3,zero,8204244 <strstr+0x4c>
 8204208:	280f883a 	mov	r7,r5
 820420c:	2011883a 	mov	r8,r4
 8204210:	02400044 	movi	r9,1
 8204214:	00000206 	br	8204220 <strstr+0x28>
 8204218:	38c00007 	ldb	r3,0(r7)
 820421c:	18000826 	beq	r3,zero,8204240 <strstr+0x48>
 8204220:	42000044 	addi	r8,r8,1
 8204224:	1987003a 	cmpeq	r3,r3,r6
 8204228:	41800007 	ldb	r6,0(r8)
 820422c:	39c00044 	addi	r7,r7,1
 8204230:	48d2703a 	and	r9,r9,r3
 8204234:	303ff81e 	bne	r6,zero,8204218 <strstr+0x20>
 8204238:	38800007 	ldb	r2,0(r7)
 820423c:	1000841e 	bne	r2,zero,8204450 <strstr+0x258>
 8204240:	48000226 	beq	r9,zero,820424c <strstr+0x54>
 8204244:	2005883a 	mov	r2,r4
 8204248:	f800283a 	ret
 820424c:	defff104 	addi	sp,sp,-60
 8204250:	ddc00c15 	stw	r23,48(sp)
 8204254:	dd800b15 	stw	r22,44(sp)
 8204258:	dd400a15 	stw	r21,40(sp)
 820425c:	dc000515 	stw	r16,20(sp)
 8204260:	dfc00e15 	stw	ra,56(sp)
 8204264:	df000d15 	stw	fp,52(sp)
 8204268:	dd000915 	stw	r20,36(sp)
 820426c:	dcc00815 	stw	r19,32(sp)
 8204270:	dc800715 	stw	r18,28(sp)
 8204274:	dc400615 	stw	r17,24(sp)
 8204278:	282d883a 	mov	r22,r5
 820427c:	29400007 	ldb	r5,0(r5)
 8204280:	202b883a 	mov	r21,r4
 8204284:	21000044 	addi	r4,r4,1
 8204288:	3da1c83a 	sub	r16,r7,r22
 820428c:	82034d00 	call	82034d0 <strchr>
 8204290:	102f883a 	mov	r23,r2
 8204294:	10007526 	beq	r2,zero,820446c <strstr+0x274>
 8204298:	00c00044 	movi	r3,1
 820429c:	80c00a26 	beq	r16,r3,82042c8 <strstr+0xd0>
 82042a0:	ac09883a 	add	r4,r21,r16
 82042a4:	20800136 	bltu	r4,r2,82042ac <strstr+0xb4>
 82042a8:	2087c83a 	sub	r3,r4,r2
 82042ac:	008007c4 	movi	r2,31
 82042b0:	1400112e 	bgeu	r2,r16,82042f8 <strstr+0x100>
 82042b4:	800f883a 	mov	r7,r16
 82042b8:	b00d883a 	mov	r6,r22
 82042bc:	180b883a 	mov	r5,r3
 82042c0:	b809883a 	mov	r4,r23
 82042c4:	8203e480 	call	8203e48 <two_way_long_needle>
 82042c8:	dfc00e17 	ldw	ra,56(sp)
 82042cc:	df000d17 	ldw	fp,52(sp)
 82042d0:	ddc00c17 	ldw	r23,48(sp)
 82042d4:	dd800b17 	ldw	r22,44(sp)
 82042d8:	dd400a17 	ldw	r21,40(sp)
 82042dc:	dd000917 	ldw	r20,36(sp)
 82042e0:	dcc00817 	ldw	r19,32(sp)
 82042e4:	dc800717 	ldw	r18,28(sp)
 82042e8:	dc400617 	ldw	r17,24(sp)
 82042ec:	dc000517 	ldw	r16,20(sp)
 82042f0:	dec00f04 	addi	sp,sp,60
 82042f4:	f800283a 	ret
 82042f8:	d80d883a 	mov	r6,sp
 82042fc:	800b883a 	mov	r5,r16
 8204300:	b009883a 	mov	r4,r22
 8204304:	d8c00415 	stw	r3,16(sp)
 8204308:	8203d440 	call	8203d44 <critical_factorization>
 820430c:	d9400017 	ldw	r5,0(sp)
 8204310:	100d883a 	mov	r6,r2
 8204314:	b009883a 	mov	r4,r22
 8204318:	b14b883a 	add	r5,r22,r5
 820431c:	1039883a 	mov	fp,r2
 8204320:	820c3280 	call	820c328 <memcmp>
 8204324:	d8c00417 	ldw	r3,16(sp)
 8204328:	1000521e 	bne	r2,zero,8204474 <strstr+0x27c>
 820432c:	e47fffc4 	addi	r17,fp,-1
 8204330:	04c00044 	movi	r19,1
 8204334:	b445883a 	add	r2,r22,r17
 8204338:	9f27c83a 	sub	r19,r19,fp
 820433c:	0029883a 	mov	r20,zero
 8204340:	002b883a 	mov	r21,zero
 8204344:	d8800215 	stw	r2,8(sp)
 8204348:	e4bfff84 	addi	r18,fp,-2
 820434c:	dcc00115 	stw	r19,4(sp)
 8204350:	8567883a 	add	r19,r16,r21
 8204354:	98cdc83a 	sub	r6,r19,r3
 8204358:	000b883a 	mov	r5,zero
 820435c:	b8c9883a 	add	r4,r23,r3
 8204360:	820c2440 	call	820c244 <memchr>
 8204364:	1000411e 	bne	r2,zero,820446c <strstr+0x274>
 8204368:	98004026 	beq	r19,zero,820446c <strstr+0x274>
 820436c:	e00b883a 	mov	r5,fp
 8204370:	e500012e 	bgeu	fp,r20,8204378 <strstr+0x180>
 8204374:	a00b883a 	mov	r5,r20
 8204378:	2c00152e 	bgeu	r5,r16,82043d0 <strstr+0x1d8>
 820437c:	b947883a 	add	r3,r23,r5
 8204380:	1d47883a 	add	r3,r3,r21
 8204384:	b145883a 	add	r2,r22,r5
 8204388:	18c00003 	ldbu	r3,0(r3)
 820438c:	10800003 	ldbu	r2,0(r2)
 8204390:	1880311e 	bne	r3,r2,8204458 <strstr+0x260>
 8204394:	a8800044 	addi	r2,r21,1
 8204398:	28c00044 	addi	r3,r5,1
 820439c:	1145883a 	add	r2,r2,r5
 82043a0:	b0c9883a 	add	r4,r22,r3
 82043a4:	b885883a 	add	r2,r23,r2
 82043a8:	00000706 	br	82043c8 <strstr+0x1d0>
 82043ac:	21c00003 	ldbu	r7,0(r4)
 82043b0:	11800003 	ldbu	r6,0(r2)
 82043b4:	21000044 	addi	r4,r4,1
 82043b8:	39c03fcc 	andi	r7,r7,255
 82043bc:	10800044 	addi	r2,r2,1
 82043c0:	3980251e 	bne	r7,r6,8204458 <strstr+0x260>
 82043c4:	18c00044 	addi	r3,r3,1
 82043c8:	180b883a 	mov	r5,r3
 82043cc:	1c3ff736 	bltu	r3,r16,82043ac <strstr+0x1b4>
 82043d0:	880d883a 	mov	r6,r17
 82043d4:	a700702e 	bgeu	r20,fp,8204598 <strstr+0x3a0>
 82043d8:	d9000217 	ldw	r4,8(sp)
 82043dc:	bd45883a 	add	r2,r23,r21
 82043e0:	1445883a 	add	r2,r2,r17
 82043e4:	20c00003 	ldbu	r3,0(r4)
 82043e8:	10800003 	ldbu	r2,0(r2)
 82043ec:	18806a1e 	bne	r3,r2,8204598 <strstr+0x3a0>
 82043f0:	954b883a 	add	r5,r18,r21
 82043f4:	a2bfffc4 	addi	r10,r20,-1
 82043f8:	b485883a 	add	r2,r22,r18
 82043fc:	b94b883a 	add	r5,r23,r5
 8204400:	b295883a 	add	r10,r22,r10
 8204404:	00000706 	br	8204424 <strstr+0x22c>
 8204408:	11000003 	ldbu	r4,0(r2)
 820440c:	28c00003 	ldbu	r3,0(r5)
 8204410:	10bfffc4 	addi	r2,r2,-1
 8204414:	21003fcc 	andi	r4,r4,255
 8204418:	297fffc4 	addi	r5,r5,-1
 820441c:	20c0031e 	bne	r4,r3,820442c <strstr+0x234>
 8204420:	380d883a 	mov	r6,r7
 8204424:	31ffffc4 	addi	r7,r6,-1
 8204428:	12bff71e 	bne	r2,r10,8204408 <strstr+0x210>
 820442c:	a2000044 	addi	r8,r20,1
 8204430:	32005b36 	bltu	r6,r8,82045a0 <strstr+0x3a8>
 8204434:	da000017 	ldw	r8,0(sp)
 8204438:	aa2b883a 	add	r21,r21,r8
 820443c:	8229c83a 	sub	r20,r16,r8
 8204440:	9807883a 	mov	r3,r19
 8204444:	003fc206 	br	8204350 <strstr+0x158>
 8204448:	28800007 	ldb	r2,0(r5)
 820444c:	103f7d26 	beq	r2,zero,8204244 <strstr+0x4c>
 8204450:	0005883a 	mov	r2,zero
 8204454:	f800283a 	ret
 8204458:	d8c00117 	ldw	r3,4(sp)
 820445c:	0029883a 	mov	r20,zero
 8204460:	1d6b883a 	add	r21,r3,r21
 8204464:	a96b883a 	add	r21,r21,r5
 8204468:	003ff506 	br	8204440 <strstr+0x248>
 820446c:	0005883a 	mov	r2,zero
 8204470:	003f9506 	br	82042c8 <strstr+0xd0>
 8204474:	8705c83a 	sub	r2,r16,fp
 8204478:	1700012e 	bgeu	r2,fp,8204480 <strstr+0x288>
 820447c:	e005883a 	mov	r2,fp
 8204480:	10800044 	addi	r2,r2,1
 8204484:	e4bfffc4 	addi	r18,fp,-1
 8204488:	05000044 	movi	r20,1
 820448c:	a729c83a 	sub	r20,r20,fp
 8204490:	d8800015 	stw	r2,0(sp)
 8204494:	b48b883a 	add	r5,r22,r18
 8204498:	e0bfff84 	addi	r2,fp,-2
 820449c:	dd000215 	stw	r20,8(sp)
 82044a0:	002b883a 	mov	r21,zero
 82044a4:	e4400044 	addi	r17,fp,1
 82044a8:	d9400315 	stw	r5,12(sp)
 82044ac:	d8800115 	stw	r2,4(sp)
 82044b0:	b53fffc4 	addi	r20,r22,-1
 82044b4:	8567883a 	add	r19,r16,r21
 82044b8:	98cdc83a 	sub	r6,r19,r3
 82044bc:	000b883a 	mov	r5,zero
 82044c0:	b8c9883a 	add	r4,r23,r3
 82044c4:	820c2440 	call	820c244 <memchr>
 82044c8:	103fe81e 	bne	r2,zero,820446c <strstr+0x274>
 82044cc:	983fe726 	beq	r19,zero,820446c <strstr+0x274>
 82044d0:	e400132e 	bgeu	fp,r16,8204520 <strstr+0x328>
 82044d4:	bf07883a 	add	r3,r23,fp
 82044d8:	1d47883a 	add	r3,r3,r21
 82044dc:	b705883a 	add	r2,r22,fp
 82044e0:	18c00003 	ldbu	r3,0(r3)
 82044e4:	10800003 	ldbu	r2,0(r2)
 82044e8:	1880241e 	bne	r3,r2,820457c <strstr+0x384>
 82044ec:	ac45883a 	add	r2,r21,r17
 82044f0:	b44b883a 	add	r5,r22,r17
 82044f4:	b885883a 	add	r2,r23,r2
 82044f8:	e009883a 	mov	r4,fp
 82044fc:	00000606 	br	8204518 <strstr+0x320>
 8204500:	29800003 	ldbu	r6,0(r5)
 8204504:	10c00003 	ldbu	r3,0(r2)
 8204508:	29400044 	addi	r5,r5,1
 820450c:	31803fcc 	andi	r6,r6,255
 8204510:	10800044 	addi	r2,r2,1
 8204514:	30c01a1e 	bne	r6,r3,8204580 <strstr+0x388>
 8204518:	21000044 	addi	r4,r4,1
 820451c:	243ff836 	bltu	r4,r16,8204500 <strstr+0x308>
 8204520:	00bfffc4 	movi	r2,-1
 8204524:	bd49883a 	add	r4,r23,r21
 8204528:	90801926 	beq	r18,r2,8204590 <strstr+0x398>
 820452c:	d9400317 	ldw	r5,12(sp)
 8204530:	2485883a 	add	r2,r4,r18
 8204534:	10800003 	ldbu	r2,0(r2)
 8204538:	28c00003 	ldbu	r3,0(r5)
 820453c:	18800b1e 	bne	r3,r2,820456c <strstr+0x374>
 8204540:	d8c00117 	ldw	r3,4(sp)
 8204544:	a8c5883a 	add	r2,r21,r3
 8204548:	b885883a 	add	r2,r23,r2
 820454c:	b0c7883a 	add	r3,r22,r3
 8204550:	1d000f26 	beq	r3,r20,8204590 <strstr+0x398>
 8204554:	19800003 	ldbu	r6,0(r3)
 8204558:	11400003 	ldbu	r5,0(r2)
 820455c:	18ffffc4 	addi	r3,r3,-1
 8204560:	31803fcc 	andi	r6,r6,255
 8204564:	10bfffc4 	addi	r2,r2,-1
 8204568:	317ff926 	beq	r6,r5,8204550 <strstr+0x358>
 820456c:	d8800017 	ldw	r2,0(sp)
 8204570:	a8ab883a 	add	r21,r21,r2
 8204574:	9807883a 	mov	r3,r19
 8204578:	003fce06 	br	82044b4 <strstr+0x2bc>
 820457c:	e009883a 	mov	r4,fp
 8204580:	d8c00217 	ldw	r3,8(sp)
 8204584:	1d4f883a 	add	r7,r3,r21
 8204588:	392b883a 	add	r21,r7,r4
 820458c:	003ff906 	br	8204574 <strstr+0x37c>
 8204590:	2005883a 	mov	r2,r4
 8204594:	003f4c06 	br	82042c8 <strstr+0xd0>
 8204598:	e00d883a 	mov	r6,fp
 820459c:	003fa306 	br	820442c <strstr+0x234>
 82045a0:	bd45883a 	add	r2,r23,r21
 82045a4:	003f4806 	br	82042c8 <strstr+0xd0>

082045a8 <___svfprintf_internal_r>:
 82045a8:	deffb704 	addi	sp,sp,-292
 82045ac:	dfc04815 	stw	ra,288(sp)
 82045b0:	ddc04615 	stw	r23,280(sp)
 82045b4:	d9402c15 	stw	r5,176(sp)
 82045b8:	d9003915 	stw	r4,228(sp)
 82045bc:	302f883a 	mov	r23,r6
 82045c0:	d9c02d15 	stw	r7,180(sp)
 82045c4:	df004715 	stw	fp,284(sp)
 82045c8:	dd804515 	stw	r22,276(sp)
 82045cc:	dd404415 	stw	r21,272(sp)
 82045d0:	dd004315 	stw	r20,268(sp)
 82045d4:	dcc04215 	stw	r19,264(sp)
 82045d8:	dc804115 	stw	r18,260(sp)
 82045dc:	dc404015 	stw	r17,256(sp)
 82045e0:	dc003f15 	stw	r16,252(sp)
 82045e4:	820b84c0 	call	820b84c <_localeconv_r>
 82045e8:	10800017 	ldw	r2,0(r2)
 82045ec:	1009883a 	mov	r4,r2
 82045f0:	d8803415 	stw	r2,208(sp)
 82045f4:	8203cac0 	call	8203cac <strlen>
 82045f8:	d8c02c17 	ldw	r3,176(sp)
 82045fc:	d8803815 	stw	r2,224(sp)
 8204600:	1880030b 	ldhu	r2,12(r3)
 8204604:	1080200c 	andi	r2,r2,128
 8204608:	10000226 	beq	r2,zero,8204614 <___svfprintf_internal_r+0x6c>
 820460c:	18800417 	ldw	r2,16(r3)
 8204610:	10067f26 	beq	r2,zero,8206010 <___svfprintf_internal_r+0x1a68>
 8204614:	dcc03917 	ldw	r19,228(sp)
 8204618:	d8c00404 	addi	r3,sp,16
 820461c:	05420974 	movhi	r21,2085
 8204620:	d9001e04 	addi	r4,sp,120
 8204624:	ad75e984 	addi	r21,r21,-10330
 8204628:	d8c01e15 	stw	r3,120(sp)
 820462c:	d8002015 	stw	zero,128(sp)
 8204630:	d8001f15 	stw	zero,124(sp)
 8204634:	d8003315 	stw	zero,204(sp)
 8204638:	d8003615 	stw	zero,216(sp)
 820463c:	d8003715 	stw	zero,220(sp)
 8204640:	1811883a 	mov	r8,r3
 8204644:	d8003a15 	stw	zero,232(sp)
 8204648:	d8003b15 	stw	zero,236(sp)
 820464c:	d8002f15 	stw	zero,188(sp)
 8204650:	d9002815 	stw	r4,160(sp)
 8204654:	b8800007 	ldb	r2,0(r23)
 8204658:	10026726 	beq	r2,zero,8204ff8 <___svfprintf_internal_r+0xa50>
 820465c:	00c00944 	movi	r3,37
 8204660:	b821883a 	mov	r16,r23
 8204664:	10c0021e 	bne	r2,r3,8204670 <___svfprintf_internal_r+0xc8>
 8204668:	00001406 	br	82046bc <___svfprintf_internal_r+0x114>
 820466c:	10c00326 	beq	r2,r3,820467c <___svfprintf_internal_r+0xd4>
 8204670:	84000044 	addi	r16,r16,1
 8204674:	80800007 	ldb	r2,0(r16)
 8204678:	103ffc1e 	bne	r2,zero,820466c <___svfprintf_internal_r+0xc4>
 820467c:	85e3c83a 	sub	r17,r16,r23
 8204680:	88000e26 	beq	r17,zero,82046bc <___svfprintf_internal_r+0x114>
 8204684:	d8c02017 	ldw	r3,128(sp)
 8204688:	d8801f17 	ldw	r2,124(sp)
 820468c:	45c00015 	stw	r23,0(r8)
 8204690:	1c47883a 	add	r3,r3,r17
 8204694:	10800044 	addi	r2,r2,1
 8204698:	d8c02015 	stw	r3,128(sp)
 820469c:	44400115 	stw	r17,4(r8)
 82046a0:	d8801f15 	stw	r2,124(sp)
 82046a4:	00c001c4 	movi	r3,7
 82046a8:	18809716 	blt	r3,r2,8204908 <___svfprintf_internal_r+0x360>
 82046ac:	42000204 	addi	r8,r8,8
 82046b0:	d9402f17 	ldw	r5,188(sp)
 82046b4:	2c4b883a 	add	r5,r5,r17
 82046b8:	d9402f15 	stw	r5,188(sp)
 82046bc:	80800007 	ldb	r2,0(r16)
 82046c0:	10009826 	beq	r2,zero,8204924 <___svfprintf_internal_r+0x37c>
 82046c4:	84400047 	ldb	r17,1(r16)
 82046c8:	00bfffc4 	movi	r2,-1
 82046cc:	85c00044 	addi	r23,r16,1
 82046d0:	d8002785 	stb	zero,158(sp)
 82046d4:	0007883a 	mov	r3,zero
 82046d8:	000f883a 	mov	r7,zero
 82046dc:	d8802915 	stw	r2,164(sp)
 82046e0:	d8003115 	stw	zero,196(sp)
 82046e4:	0025883a 	mov	r18,zero
 82046e8:	01401604 	movi	r5,88
 82046ec:	01800244 	movi	r6,9
 82046f0:	02800a84 	movi	r10,42
 82046f4:	02401b04 	movi	r9,108
 82046f8:	bdc00044 	addi	r23,r23,1
 82046fc:	88bff804 	addi	r2,r17,-32
 8204700:	2882f036 	bltu	r5,r2,82052c4 <___svfprintf_internal_r+0xd1c>
 8204704:	100490ba 	slli	r2,r2,2
 8204708:	01020834 	movhi	r4,2080
 820470c:	2111c704 	addi	r4,r4,18204
 8204710:	1105883a 	add	r2,r2,r4
 8204714:	10800017 	ldw	r2,0(r2)
 8204718:	1000683a 	jmp	r2
 820471c:	0820522c 	andhi	zero,at,33096
 8204720:	082052c4 	addi	zero,at,-32437
 8204724:	082052c4 	addi	zero,at,-32437
 8204728:	08205220 	cmpeqi	zero,at,-32440
 820472c:	082052c4 	addi	zero,at,-32437
 8204730:	082052c4 	addi	zero,at,-32437
 8204734:	082052c4 	addi	zero,at,-32437
 8204738:	082052c4 	addi	zero,at,-32437
 820473c:	082052c4 	addi	zero,at,-32437
 8204740:	082052c4 	addi	zero,at,-32437
 8204744:	08204980 	call	820498 <OSCtxSw_SWITCH_PC+0x820458>
 8204748:	0820515c 	xori	zero,at,33093
 820474c:	082052c4 	addi	zero,at,-32437
 8204750:	08204890 	cmplti	zero,at,-32478
 8204754:	082049a8 	cmpgeui	zero,at,33062
 8204758:	082052c4 	addi	zero,at,-32437
 820475c:	08204a1c 	xori	zero,at,33064
 8204760:	082049e8 	cmpgeui	zero,at,33063
 8204764:	082049e8 	cmpgeui	zero,at,33063
 8204768:	082049e8 	cmpgeui	zero,at,33063
 820476c:	082049e8 	cmpgeui	zero,at,33063
 8204770:	082049e8 	cmpgeui	zero,at,33063
 8204774:	082049e8 	cmpgeui	zero,at,33063
 8204778:	082049e8 	cmpgeui	zero,at,33063
 820477c:	082049e8 	cmpgeui	zero,at,33063
 8204780:	082049e8 	cmpgeui	zero,at,33063
 8204784:	082052c4 	addi	zero,at,-32437
 8204788:	082052c4 	addi	zero,at,-32437
 820478c:	082052c4 	addi	zero,at,-32437
 8204790:	082052c4 	addi	zero,at,-32437
 8204794:	082052c4 	addi	zero,at,-32437
 8204798:	082052c4 	addi	zero,at,-32437
 820479c:	082052c4 	addi	zero,at,-32437
 82047a0:	082052c4 	addi	zero,at,-32437
 82047a4:	082052c4 	addi	zero,at,-32437
 82047a8:	082052c4 	addi	zero,at,-32437
 82047ac:	08204ad4 	ori	zero,at,33067
 82047b0:	08204a28 	cmpgeui	zero,at,33064
 82047b4:	082052c4 	addi	zero,at,-32437
 82047b8:	08204a28 	cmpgeui	zero,at,33064
 82047bc:	082052c4 	addi	zero,at,-32437
 82047c0:	082052c4 	addi	zero,at,-32437
 82047c4:	082052c4 	addi	zero,at,-32437
 82047c8:	082052c4 	addi	zero,at,-32437
 82047cc:	08204ac8 	cmpgei	zero,at,-32469
 82047d0:	082052c4 	addi	zero,at,-32437
 82047d4:	082052c4 	addi	zero,at,-32437
 82047d8:	08204b90 	cmplti	zero,at,-32466
 82047dc:	082052c4 	addi	zero,at,-32437
 82047e0:	082052c4 	addi	zero,at,-32437
 82047e4:	082052c4 	addi	zero,at,-32437
 82047e8:	082052c4 	addi	zero,at,-32437
 82047ec:	082052c4 	addi	zero,at,-32437
 82047f0:	08205000 	call	820500 <OSCtxSw_SWITCH_PC+0x8204c0>
 82047f4:	082052c4 	addi	zero,at,-32437
 82047f8:	082052c4 	addi	zero,at,-32437
 82047fc:	08205060 	cmpeqi	zero,at,-32447
 8204800:	082052c4 	addi	zero,at,-32437
 8204804:	082052c4 	addi	zero,at,-32437
 8204808:	082052c4 	addi	zero,at,-32437
 820480c:	082052c4 	addi	zero,at,-32437
 8204810:	082052c4 	addi	zero,at,-32437
 8204814:	082052c4 	addi	zero,at,-32437
 8204818:	082052c4 	addi	zero,at,-32437
 820481c:	082052c4 	addi	zero,at,-32437
 8204820:	082052c4 	addi	zero,at,-32437
 8204824:	082052c4 	addi	zero,at,-32437
 8204828:	08205110 	cmplti	zero,at,-32444
 820482c:	0820524c 	andi	zero,at,33097
 8204830:	08204a28 	cmpgeui	zero,at,33064
 8204834:	08204a28 	cmpgeui	zero,at,33064
 8204838:	08204a28 	cmpgeui	zero,at,33064
 820483c:	082052a0 	cmpeqi	zero,at,-32438
 8204840:	0820524c 	andi	zero,at,33097
 8204844:	082052c4 	addi	zero,at,-32437
 8204848:	082052c4 	addi	zero,at,-32437
 820484c:	0820525c 	xori	zero,at,33097
 8204850:	082052c4 	addi	zero,at,-32437
 8204854:	0820526c 	andhi	zero,at,33097
 8204858:	0820514c 	andi	zero,at,33093
 820485c:	0820489c 	xori	zero,at,33058
 8204860:	0820516c 	andhi	zero,at,33093
 8204864:	082052c4 	addi	zero,at,-32437
 8204868:	08205178 	rdprs	zero,at,-32443
 820486c:	082052c4 	addi	zero,at,-32437
 8204870:	082051d4 	ori	zero,at,33095
 8204874:	082052c4 	addi	zero,at,-32437
 8204878:	082052c4 	addi	zero,at,-32437
 820487c:	082051e4 	muli	zero,at,-32441
 8204880:	d9003117 	ldw	r4,196(sp)
 8204884:	d8802d15 	stw	r2,180(sp)
 8204888:	0109c83a 	sub	r4,zero,r4
 820488c:	d9003115 	stw	r4,196(sp)
 8204890:	94800114 	ori	r18,r18,4
 8204894:	bc400007 	ldb	r17,0(r23)
 8204898:	003f9706 	br	82046f8 <___svfprintf_internal_r+0x150>
 820489c:	00800c04 	movi	r2,48
 82048a0:	d9002d17 	ldw	r4,180(sp)
 82048a4:	d9402917 	ldw	r5,164(sp)
 82048a8:	d8802705 	stb	r2,156(sp)
 82048ac:	00801e04 	movi	r2,120
 82048b0:	d8802745 	stb	r2,157(sp)
 82048b4:	d8002785 	stb	zero,158(sp)
 82048b8:	20c00104 	addi	r3,r4,4
 82048bc:	25000017 	ldw	r20,0(r4)
 82048c0:	002d883a 	mov	r22,zero
 82048c4:	90800094 	ori	r2,r18,2
 82048c8:	28028616 	blt	r5,zero,82052e4 <___svfprintf_internal_r+0xd3c>
 82048cc:	00bfdfc4 	movi	r2,-129
 82048d0:	90a4703a 	and	r18,r18,r2
 82048d4:	d8c02d15 	stw	r3,180(sp)
 82048d8:	94800094 	ori	r18,r18,2
 82048dc:	a002731e 	bne	r20,zero,82052ac <___svfprintf_internal_r+0xd04>
 82048e0:	00820974 	movhi	r2,2085
 82048e4:	10b5e204 	addi	r2,r2,-10360
 82048e8:	d8803a15 	stw	r2,232(sp)
 82048ec:	04401e04 	movi	r17,120
 82048f0:	d8c02917 	ldw	r3,164(sp)
 82048f4:	0039883a 	mov	fp,zero
 82048f8:	1801d526 	beq	r3,zero,8205050 <___svfprintf_internal_r+0xaa8>
 82048fc:	0029883a 	mov	r20,zero
 8204900:	002d883a 	mov	r22,zero
 8204904:	0001f106 	br	82050cc <___svfprintf_internal_r+0xb24>
 8204908:	d9402c17 	ldw	r5,176(sp)
 820490c:	d9801e04 	addi	r6,sp,120
 8204910:	9809883a 	mov	r4,r19
 8204914:	820ddd40 	call	820ddd4 <__ssprint_r>
 8204918:	1000081e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 820491c:	da000404 	addi	r8,sp,16
 8204920:	003f6306 	br	82046b0 <___svfprintf_internal_r+0x108>
 8204924:	d8802017 	ldw	r2,128(sp)
 8204928:	10000426 	beq	r2,zero,820493c <___svfprintf_internal_r+0x394>
 820492c:	d9402c17 	ldw	r5,176(sp)
 8204930:	d9003917 	ldw	r4,228(sp)
 8204934:	d9801e04 	addi	r6,sp,120
 8204938:	820ddd40 	call	820ddd4 <__ssprint_r>
 820493c:	d8802c17 	ldw	r2,176(sp)
 8204940:	10c0030b 	ldhu	r3,12(r2)
 8204944:	d8802f17 	ldw	r2,188(sp)
 8204948:	18c0100c 	andi	r3,r3,64
 820494c:	1805f51e 	bne	r3,zero,8206124 <___svfprintf_internal_r+0x1b7c>
 8204950:	dfc04817 	ldw	ra,288(sp)
 8204954:	df004717 	ldw	fp,284(sp)
 8204958:	ddc04617 	ldw	r23,280(sp)
 820495c:	dd804517 	ldw	r22,276(sp)
 8204960:	dd404417 	ldw	r21,272(sp)
 8204964:	dd004317 	ldw	r20,268(sp)
 8204968:	dcc04217 	ldw	r19,264(sp)
 820496c:	dc804117 	ldw	r18,260(sp)
 8204970:	dc404017 	ldw	r17,256(sp)
 8204974:	dc003f17 	ldw	r16,252(sp)
 8204978:	dec04904 	addi	sp,sp,292
 820497c:	f800283a 	ret
 8204980:	d8802d17 	ldw	r2,180(sp)
 8204984:	d9002d17 	ldw	r4,180(sp)
 8204988:	10800017 	ldw	r2,0(r2)
 820498c:	d8803115 	stw	r2,196(sp)
 8204990:	20800104 	addi	r2,r4,4
 8204994:	d9003117 	ldw	r4,196(sp)
 8204998:	203fb916 	blt	r4,zero,8204880 <___svfprintf_internal_r+0x2d8>
 820499c:	d8802d15 	stw	r2,180(sp)
 82049a0:	bc400007 	ldb	r17,0(r23)
 82049a4:	003f5406 	br	82046f8 <___svfprintf_internal_r+0x150>
 82049a8:	bc400007 	ldb	r17,0(r23)
 82049ac:	bac00044 	addi	r11,r23,1
 82049b0:	8a873926 	beq	r17,r10,8206698 <___svfprintf_internal_r+0x20f0>
 82049b4:	88bff404 	addi	r2,r17,-48
 82049b8:	0009883a 	mov	r4,zero
 82049bc:	30868836 	bltu	r6,r2,82063e0 <___svfprintf_internal_r+0x1e38>
 82049c0:	5c400007 	ldb	r17,0(r11)
 82049c4:	210002a4 	muli	r4,r4,10
 82049c8:	5dc00044 	addi	r23,r11,1
 82049cc:	b817883a 	mov	r11,r23
 82049d0:	2089883a 	add	r4,r4,r2
 82049d4:	88bff404 	addi	r2,r17,-48
 82049d8:	30bff92e 	bgeu	r6,r2,82049c0 <___svfprintf_internal_r+0x418>
 82049dc:	2005d716 	blt	r4,zero,820613c <___svfprintf_internal_r+0x1b94>
 82049e0:	d9002915 	stw	r4,164(sp)
 82049e4:	003f4506 	br	82046fc <___svfprintf_internal_r+0x154>
 82049e8:	b809883a 	mov	r4,r23
 82049ec:	d8003115 	stw	zero,196(sp)
 82049f0:	88bff404 	addi	r2,r17,-48
 82049f4:	0017883a 	mov	r11,zero
 82049f8:	24400007 	ldb	r17,0(r4)
 82049fc:	5ac002a4 	muli	r11,r11,10
 8204a00:	bdc00044 	addi	r23,r23,1
 8204a04:	b809883a 	mov	r4,r23
 8204a08:	12d7883a 	add	r11,r2,r11
 8204a0c:	88bff404 	addi	r2,r17,-48
 8204a10:	30bff92e 	bgeu	r6,r2,82049f8 <___svfprintf_internal_r+0x450>
 8204a14:	dac03115 	stw	r11,196(sp)
 8204a18:	003f3806 	br	82046fc <___svfprintf_internal_r+0x154>
 8204a1c:	94802014 	ori	r18,r18,128
 8204a20:	bc400007 	ldb	r17,0(r23)
 8204a24:	003f3406 	br	82046f8 <___svfprintf_internal_r+0x150>
 8204a28:	18c03fcc 	andi	r3,r3,255
 8204a2c:	1807471e 	bne	r3,zero,820674c <___svfprintf_internal_r+0x21a4>
 8204a30:	9080020c 	andi	r2,r18,8
 8204a34:	10047d26 	beq	r2,zero,8205c2c <___svfprintf_internal_r+0x1684>
 8204a38:	d8c02d17 	ldw	r3,180(sp)
 8204a3c:	d9002d17 	ldw	r4,180(sp)
 8204a40:	d9402d17 	ldw	r5,180(sp)
 8204a44:	18c00017 	ldw	r3,0(r3)
 8204a48:	21000117 	ldw	r4,4(r4)
 8204a4c:	29400204 	addi	r5,r5,8
 8204a50:	d8c03615 	stw	r3,216(sp)
 8204a54:	d9003715 	stw	r4,220(sp)
 8204a58:	d9402d15 	stw	r5,180(sp)
 8204a5c:	d9003617 	ldw	r4,216(sp)
 8204a60:	d9403717 	ldw	r5,220(sp)
 8204a64:	da003e15 	stw	r8,248(sp)
 8204a68:	04000044 	movi	r16,1
 8204a6c:	820daf40 	call	820daf4 <__fpclassifyd>
 8204a70:	da003e17 	ldw	r8,248(sp)
 8204a74:	14044b1e 	bne	r2,r16,8205ba4 <___svfprintf_internal_r+0x15fc>
 8204a78:	d9003617 	ldw	r4,216(sp)
 8204a7c:	d9403717 	ldw	r5,220(sp)
 8204a80:	000d883a 	mov	r6,zero
 8204a84:	000f883a 	mov	r7,zero
 8204a88:	8212dac0 	call	8212dac <__ledf2>
 8204a8c:	da003e17 	ldw	r8,248(sp)
 8204a90:	1005f316 	blt	r2,zero,8206260 <___svfprintf_internal_r+0x1cb8>
 8204a94:	df002783 	ldbu	fp,158(sp)
 8204a98:	008011c4 	movi	r2,71
 8204a9c:	1445590e 	bge	r2,r17,8206004 <___svfprintf_internal_r+0x1a5c>
 8204aa0:	04020974 	movhi	r16,2085
 8204aa4:	8435da04 	addi	r16,r16,-10392
 8204aa8:	00c000c4 	movi	r3,3
 8204aac:	00bfdfc4 	movi	r2,-129
 8204ab0:	d8c02a15 	stw	r3,168(sp)
 8204ab4:	90a4703a 	and	r18,r18,r2
 8204ab8:	d8c02e15 	stw	r3,184(sp)
 8204abc:	d8002915 	stw	zero,164(sp)
 8204ac0:	d8003215 	stw	zero,200(sp)
 8204ac4:	00006606 	br	8204c60 <___svfprintf_internal_r+0x6b8>
 8204ac8:	94800214 	ori	r18,r18,8
 8204acc:	bc400007 	ldb	r17,0(r23)
 8204ad0:	003f0906 	br	82046f8 <___svfprintf_internal_r+0x150>
 8204ad4:	18c03fcc 	andi	r3,r3,255
 8204ad8:	1807181e 	bne	r3,zero,820673c <___svfprintf_internal_r+0x2194>
 8204adc:	94800414 	ori	r18,r18,16
 8204ae0:	9080080c 	andi	r2,r18,32
 8204ae4:	10039626 	beq	r2,zero,8205940 <___svfprintf_internal_r+0x1398>
 8204ae8:	d9402d17 	ldw	r5,180(sp)
 8204aec:	28800117 	ldw	r2,4(r5)
 8204af0:	2d000017 	ldw	r20,0(r5)
 8204af4:	29400204 	addi	r5,r5,8
 8204af8:	d9402d15 	stw	r5,180(sp)
 8204afc:	102d883a 	mov	r22,r2
 8204b00:	10039816 	blt	r2,zero,8205964 <___svfprintf_internal_r+0x13bc>
 8204b04:	d9402917 	ldw	r5,164(sp)
 8204b08:	df002783 	ldbu	fp,158(sp)
 8204b0c:	2803ab16 	blt	r5,zero,82059bc <___svfprintf_internal_r+0x1414>
 8204b10:	00ffdfc4 	movi	r3,-129
 8204b14:	a584b03a 	or	r2,r20,r22
 8204b18:	90e4703a 	and	r18,r18,r3
 8204b1c:	10014a26 	beq	r2,zero,8205048 <___svfprintf_internal_r+0xaa0>
 8204b20:	b0034b26 	beq	r22,zero,8205850 <___svfprintf_internal_r+0x12a8>
 8204b24:	dc402a15 	stw	r17,168(sp)
 8204b28:	dc001e04 	addi	r16,sp,120
 8204b2c:	b023883a 	mov	r17,r22
 8204b30:	402d883a 	mov	r22,r8
 8204b34:	a009883a 	mov	r4,r20
 8204b38:	880b883a 	mov	r5,r17
 8204b3c:	01800284 	movi	r6,10
 8204b40:	000f883a 	mov	r7,zero
 8204b44:	821157c0 	call	821157c <__umoddi3>
 8204b48:	10800c04 	addi	r2,r2,48
 8204b4c:	843fffc4 	addi	r16,r16,-1
 8204b50:	a009883a 	mov	r4,r20
 8204b54:	880b883a 	mov	r5,r17
 8204b58:	80800005 	stb	r2,0(r16)
 8204b5c:	01800284 	movi	r6,10
 8204b60:	000f883a 	mov	r7,zero
 8204b64:	82110040 	call	8211004 <__udivdi3>
 8204b68:	1029883a 	mov	r20,r2
 8204b6c:	10c4b03a 	or	r2,r2,r3
 8204b70:	1823883a 	mov	r17,r3
 8204b74:	103fef1e 	bne	r2,zero,8204b34 <___svfprintf_internal_r+0x58c>
 8204b78:	d8c02817 	ldw	r3,160(sp)
 8204b7c:	dc402a17 	ldw	r17,168(sp)
 8204b80:	b011883a 	mov	r8,r22
 8204b84:	1c07c83a 	sub	r3,r3,r16
 8204b88:	d8c02e15 	stw	r3,184(sp)
 8204b8c:	00002e06 	br	8204c48 <___svfprintf_internal_r+0x6a0>
 8204b90:	18c03fcc 	andi	r3,r3,255
 8204b94:	1806e71e 	bne	r3,zero,8206734 <___svfprintf_internal_r+0x218c>
 8204b98:	94800414 	ori	r18,r18,16
 8204b9c:	9080080c 	andi	r2,r18,32
 8204ba0:	1002d426 	beq	r2,zero,82056f4 <___svfprintf_internal_r+0x114c>
 8204ba4:	d9402d17 	ldw	r5,180(sp)
 8204ba8:	d8c02917 	ldw	r3,164(sp)
 8204bac:	d8002785 	stb	zero,158(sp)
 8204bb0:	28800204 	addi	r2,r5,8
 8204bb4:	2d000017 	ldw	r20,0(r5)
 8204bb8:	2d800117 	ldw	r22,4(r5)
 8204bbc:	18041516 	blt	r3,zero,8205c14 <___svfprintf_internal_r+0x166c>
 8204bc0:	013fdfc4 	movi	r4,-129
 8204bc4:	a586b03a 	or	r3,r20,r22
 8204bc8:	d8802d15 	stw	r2,180(sp)
 8204bcc:	9124703a 	and	r18,r18,r4
 8204bd0:	1802d51e 	bne	r3,zero,8205728 <___svfprintf_internal_r+0x1180>
 8204bd4:	d9402917 	ldw	r5,164(sp)
 8204bd8:	0039883a 	mov	fp,zero
 8204bdc:	2806be26 	beq	r5,zero,82066d8 <___svfprintf_internal_r+0x2130>
 8204be0:	0029883a 	mov	r20,zero
 8204be4:	002d883a 	mov	r22,zero
 8204be8:	dc001e04 	addi	r16,sp,120
 8204bec:	a006d0fa 	srli	r3,r20,3
 8204bf0:	b008977a 	slli	r4,r22,29
 8204bf4:	b02cd0fa 	srli	r22,r22,3
 8204bf8:	a50001cc 	andi	r20,r20,7
 8204bfc:	a0800c04 	addi	r2,r20,48
 8204c00:	843fffc4 	addi	r16,r16,-1
 8204c04:	20e8b03a 	or	r20,r4,r3
 8204c08:	80800005 	stb	r2,0(r16)
 8204c0c:	a586b03a 	or	r3,r20,r22
 8204c10:	183ff61e 	bne	r3,zero,8204bec <___svfprintf_internal_r+0x644>
 8204c14:	90c0004c 	andi	r3,r18,1
 8204c18:	18013926 	beq	r3,zero,8205100 <___svfprintf_internal_r+0xb58>
 8204c1c:	10803fcc 	andi	r2,r2,255
 8204c20:	1080201c 	xori	r2,r2,128
 8204c24:	10bfe004 	addi	r2,r2,-128
 8204c28:	00c00c04 	movi	r3,48
 8204c2c:	10c13426 	beq	r2,r3,8205100 <___svfprintf_internal_r+0xb58>
 8204c30:	80ffffc5 	stb	r3,-1(r16)
 8204c34:	d8c02817 	ldw	r3,160(sp)
 8204c38:	80bfffc4 	addi	r2,r16,-1
 8204c3c:	1021883a 	mov	r16,r2
 8204c40:	1887c83a 	sub	r3,r3,r2
 8204c44:	d8c02e15 	stw	r3,184(sp)
 8204c48:	d8802e17 	ldw	r2,184(sp)
 8204c4c:	d9002917 	ldw	r4,164(sp)
 8204c50:	1100010e 	bge	r2,r4,8204c58 <___svfprintf_internal_r+0x6b0>
 8204c54:	2005883a 	mov	r2,r4
 8204c58:	d8802a15 	stw	r2,168(sp)
 8204c5c:	d8003215 	stw	zero,200(sp)
 8204c60:	e7003fcc 	andi	fp,fp,255
 8204c64:	e700201c 	xori	fp,fp,128
 8204c68:	e73fe004 	addi	fp,fp,-128
 8204c6c:	e0000326 	beq	fp,zero,8204c7c <___svfprintf_internal_r+0x6d4>
 8204c70:	d8c02a17 	ldw	r3,168(sp)
 8204c74:	18c00044 	addi	r3,r3,1
 8204c78:	d8c02a15 	stw	r3,168(sp)
 8204c7c:	90c0008c 	andi	r3,r18,2
 8204c80:	d8c02b15 	stw	r3,172(sp)
 8204c84:	18000326 	beq	r3,zero,8204c94 <___svfprintf_internal_r+0x6ec>
 8204c88:	d8c02a17 	ldw	r3,168(sp)
 8204c8c:	18c00084 	addi	r3,r3,2
 8204c90:	d8c02a15 	stw	r3,168(sp)
 8204c94:	90c0210c 	andi	r3,r18,132
 8204c98:	d8c03015 	stw	r3,192(sp)
 8204c9c:	1801a11e 	bne	r3,zero,8205324 <___svfprintf_internal_r+0xd7c>
 8204ca0:	d9003117 	ldw	r4,196(sp)
 8204ca4:	d8c02a17 	ldw	r3,168(sp)
 8204ca8:	20e9c83a 	sub	r20,r4,r3
 8204cac:	05019d0e 	bge	zero,r20,8205324 <___svfprintf_internal_r+0xd7c>
 8204cb0:	02400404 	movi	r9,16
 8204cb4:	d8c02017 	ldw	r3,128(sp)
 8204cb8:	d8801f17 	ldw	r2,124(sp)
 8204cbc:	4d051b0e 	bge	r9,r20,820612c <___svfprintf_internal_r+0x1b84>
 8204cc0:	01420974 	movhi	r5,2085
 8204cc4:	2975ed84 	addi	r5,r5,-10314
 8204cc8:	dc403c15 	stw	r17,240(sp)
 8204ccc:	d9403515 	stw	r5,212(sp)
 8204cd0:	a023883a 	mov	r17,r20
 8204cd4:	482d883a 	mov	r22,r9
 8204cd8:	9029883a 	mov	r20,r18
 8204cdc:	070001c4 	movi	fp,7
 8204ce0:	8025883a 	mov	r18,r16
 8204ce4:	dc002c17 	ldw	r16,176(sp)
 8204ce8:	00000306 	br	8204cf8 <___svfprintf_internal_r+0x750>
 8204cec:	8c7ffc04 	addi	r17,r17,-16
 8204cf0:	42000204 	addi	r8,r8,8
 8204cf4:	b440130e 	bge	r22,r17,8204d44 <___svfprintf_internal_r+0x79c>
 8204cf8:	01020974 	movhi	r4,2085
 8204cfc:	18c00404 	addi	r3,r3,16
 8204d00:	10800044 	addi	r2,r2,1
 8204d04:	2135ed84 	addi	r4,r4,-10314
 8204d08:	41000015 	stw	r4,0(r8)
 8204d0c:	45800115 	stw	r22,4(r8)
 8204d10:	d8c02015 	stw	r3,128(sp)
 8204d14:	d8801f15 	stw	r2,124(sp)
 8204d18:	e0bff40e 	bge	fp,r2,8204cec <___svfprintf_internal_r+0x744>
 8204d1c:	d9801e04 	addi	r6,sp,120
 8204d20:	800b883a 	mov	r5,r16
 8204d24:	9809883a 	mov	r4,r19
 8204d28:	820ddd40 	call	820ddd4 <__ssprint_r>
 8204d2c:	103f031e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8204d30:	8c7ffc04 	addi	r17,r17,-16
 8204d34:	d8c02017 	ldw	r3,128(sp)
 8204d38:	d8801f17 	ldw	r2,124(sp)
 8204d3c:	da000404 	addi	r8,sp,16
 8204d40:	b47fed16 	blt	r22,r17,8204cf8 <___svfprintf_internal_r+0x750>
 8204d44:	9021883a 	mov	r16,r18
 8204d48:	a025883a 	mov	r18,r20
 8204d4c:	8829883a 	mov	r20,r17
 8204d50:	dc403c17 	ldw	r17,240(sp)
 8204d54:	d9403517 	ldw	r5,212(sp)
 8204d58:	a0c7883a 	add	r3,r20,r3
 8204d5c:	10800044 	addi	r2,r2,1
 8204d60:	41400015 	stw	r5,0(r8)
 8204d64:	45000115 	stw	r20,4(r8)
 8204d68:	d8c02015 	stw	r3,128(sp)
 8204d6c:	d8801f15 	stw	r2,124(sp)
 8204d70:	010001c4 	movi	r4,7
 8204d74:	20829f16 	blt	r4,r2,82057f4 <___svfprintf_internal_r+0x124c>
 8204d78:	df002787 	ldb	fp,158(sp)
 8204d7c:	42000204 	addi	r8,r8,8
 8204d80:	e0000c26 	beq	fp,zero,8204db4 <___svfprintf_internal_r+0x80c>
 8204d84:	d8801f17 	ldw	r2,124(sp)
 8204d88:	d9002784 	addi	r4,sp,158
 8204d8c:	18c00044 	addi	r3,r3,1
 8204d90:	10800044 	addi	r2,r2,1
 8204d94:	41000015 	stw	r4,0(r8)
 8204d98:	01000044 	movi	r4,1
 8204d9c:	41000115 	stw	r4,4(r8)
 8204da0:	d8c02015 	stw	r3,128(sp)
 8204da4:	d8801f15 	stw	r2,124(sp)
 8204da8:	010001c4 	movi	r4,7
 8204dac:	20823816 	blt	r4,r2,8205690 <___svfprintf_internal_r+0x10e8>
 8204db0:	42000204 	addi	r8,r8,8
 8204db4:	d8802b17 	ldw	r2,172(sp)
 8204db8:	10000c26 	beq	r2,zero,8204dec <___svfprintf_internal_r+0x844>
 8204dbc:	d8801f17 	ldw	r2,124(sp)
 8204dc0:	d9002704 	addi	r4,sp,156
 8204dc4:	18c00084 	addi	r3,r3,2
 8204dc8:	10800044 	addi	r2,r2,1
 8204dcc:	41000015 	stw	r4,0(r8)
 8204dd0:	01000084 	movi	r4,2
 8204dd4:	41000115 	stw	r4,4(r8)
 8204dd8:	d8c02015 	stw	r3,128(sp)
 8204ddc:	d8801f15 	stw	r2,124(sp)
 8204de0:	010001c4 	movi	r4,7
 8204de4:	20823216 	blt	r4,r2,82056b0 <___svfprintf_internal_r+0x1108>
 8204de8:	42000204 	addi	r8,r8,8
 8204dec:	d9003017 	ldw	r4,192(sp)
 8204df0:	00802004 	movi	r2,128
 8204df4:	20819726 	beq	r4,r2,8205454 <___svfprintf_internal_r+0xeac>
 8204df8:	d9402917 	ldw	r5,164(sp)
 8204dfc:	d8802e17 	ldw	r2,184(sp)
 8204e00:	28adc83a 	sub	r22,r5,r2
 8204e04:	05802f0e 	bge	zero,r22,8204ec4 <___svfprintf_internal_r+0x91c>
 8204e08:	07000404 	movi	fp,16
 8204e0c:	d8801f17 	ldw	r2,124(sp)
 8204e10:	e583c00e 	bge	fp,r22,8205d14 <___svfprintf_internal_r+0x176c>
 8204e14:	01420974 	movhi	r5,2085
 8204e18:	2975e984 	addi	r5,r5,-10330
 8204e1c:	dc402915 	stw	r17,164(sp)
 8204e20:	d9402b15 	stw	r5,172(sp)
 8204e24:	b023883a 	mov	r17,r22
 8204e28:	050001c4 	movi	r20,7
 8204e2c:	902d883a 	mov	r22,r18
 8204e30:	8025883a 	mov	r18,r16
 8204e34:	dc002c17 	ldw	r16,176(sp)
 8204e38:	00000306 	br	8204e48 <___svfprintf_internal_r+0x8a0>
 8204e3c:	8c7ffc04 	addi	r17,r17,-16
 8204e40:	42000204 	addi	r8,r8,8
 8204e44:	e440110e 	bge	fp,r17,8204e8c <___svfprintf_internal_r+0x8e4>
 8204e48:	18c00404 	addi	r3,r3,16
 8204e4c:	10800044 	addi	r2,r2,1
 8204e50:	45400015 	stw	r21,0(r8)
 8204e54:	47000115 	stw	fp,4(r8)
 8204e58:	d8c02015 	stw	r3,128(sp)
 8204e5c:	d8801f15 	stw	r2,124(sp)
 8204e60:	a0bff60e 	bge	r20,r2,8204e3c <___svfprintf_internal_r+0x894>
 8204e64:	d9801e04 	addi	r6,sp,120
 8204e68:	800b883a 	mov	r5,r16
 8204e6c:	9809883a 	mov	r4,r19
 8204e70:	820ddd40 	call	820ddd4 <__ssprint_r>
 8204e74:	103eb11e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8204e78:	8c7ffc04 	addi	r17,r17,-16
 8204e7c:	d8c02017 	ldw	r3,128(sp)
 8204e80:	d8801f17 	ldw	r2,124(sp)
 8204e84:	da000404 	addi	r8,sp,16
 8204e88:	e47fef16 	blt	fp,r17,8204e48 <___svfprintf_internal_r+0x8a0>
 8204e8c:	9021883a 	mov	r16,r18
 8204e90:	b025883a 	mov	r18,r22
 8204e94:	882d883a 	mov	r22,r17
 8204e98:	dc402917 	ldw	r17,164(sp)
 8204e9c:	d9002b17 	ldw	r4,172(sp)
 8204ea0:	1d87883a 	add	r3,r3,r22
 8204ea4:	10800044 	addi	r2,r2,1
 8204ea8:	41000015 	stw	r4,0(r8)
 8204eac:	45800115 	stw	r22,4(r8)
 8204eb0:	d8c02015 	stw	r3,128(sp)
 8204eb4:	d8801f15 	stw	r2,124(sp)
 8204eb8:	010001c4 	movi	r4,7
 8204ebc:	2081ec16 	blt	r4,r2,8205670 <___svfprintf_internal_r+0x10c8>
 8204ec0:	42000204 	addi	r8,r8,8
 8204ec4:	9080400c 	andi	r2,r18,256
 8204ec8:	1001181e 	bne	r2,zero,820532c <___svfprintf_internal_r+0xd84>
 8204ecc:	d9402e17 	ldw	r5,184(sp)
 8204ed0:	d8801f17 	ldw	r2,124(sp)
 8204ed4:	44000015 	stw	r16,0(r8)
 8204ed8:	1947883a 	add	r3,r3,r5
 8204edc:	10800044 	addi	r2,r2,1
 8204ee0:	41400115 	stw	r5,4(r8)
 8204ee4:	d8c02015 	stw	r3,128(sp)
 8204ee8:	d8801f15 	stw	r2,124(sp)
 8204eec:	010001c4 	movi	r4,7
 8204ef0:	2081d116 	blt	r4,r2,8205638 <___svfprintf_internal_r+0x1090>
 8204ef4:	42000204 	addi	r8,r8,8
 8204ef8:	9480010c 	andi	r18,r18,4
 8204efc:	90003226 	beq	r18,zero,8204fc8 <___svfprintf_internal_r+0xa20>
 8204f00:	d9403117 	ldw	r5,196(sp)
 8204f04:	d8802a17 	ldw	r2,168(sp)
 8204f08:	28a1c83a 	sub	r16,r5,r2
 8204f0c:	04002e0e 	bge	zero,r16,8204fc8 <___svfprintf_internal_r+0xa20>
 8204f10:	04400404 	movi	r17,16
 8204f14:	d8801f17 	ldw	r2,124(sp)
 8204f18:	8c04b90e 	bge	r17,r16,8206200 <___svfprintf_internal_r+0x1c58>
 8204f1c:	01420974 	movhi	r5,2085
 8204f20:	2975ed84 	addi	r5,r5,-10314
 8204f24:	d9403515 	stw	r5,212(sp)
 8204f28:	048001c4 	movi	r18,7
 8204f2c:	dd002c17 	ldw	r20,176(sp)
 8204f30:	00000306 	br	8204f40 <___svfprintf_internal_r+0x998>
 8204f34:	843ffc04 	addi	r16,r16,-16
 8204f38:	42000204 	addi	r8,r8,8
 8204f3c:	8c00130e 	bge	r17,r16,8204f8c <___svfprintf_internal_r+0x9e4>
 8204f40:	01020974 	movhi	r4,2085
 8204f44:	18c00404 	addi	r3,r3,16
 8204f48:	10800044 	addi	r2,r2,1
 8204f4c:	2135ed84 	addi	r4,r4,-10314
 8204f50:	41000015 	stw	r4,0(r8)
 8204f54:	44400115 	stw	r17,4(r8)
 8204f58:	d8c02015 	stw	r3,128(sp)
 8204f5c:	d8801f15 	stw	r2,124(sp)
 8204f60:	90bff40e 	bge	r18,r2,8204f34 <___svfprintf_internal_r+0x98c>
 8204f64:	d9801e04 	addi	r6,sp,120
 8204f68:	a00b883a 	mov	r5,r20
 8204f6c:	9809883a 	mov	r4,r19
 8204f70:	820ddd40 	call	820ddd4 <__ssprint_r>
 8204f74:	103e711e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8204f78:	843ffc04 	addi	r16,r16,-16
 8204f7c:	d8c02017 	ldw	r3,128(sp)
 8204f80:	d8801f17 	ldw	r2,124(sp)
 8204f84:	da000404 	addi	r8,sp,16
 8204f88:	8c3fed16 	blt	r17,r16,8204f40 <___svfprintf_internal_r+0x998>
 8204f8c:	d9403517 	ldw	r5,212(sp)
 8204f90:	1c07883a 	add	r3,r3,r16
 8204f94:	10800044 	addi	r2,r2,1
 8204f98:	41400015 	stw	r5,0(r8)
 8204f9c:	44000115 	stw	r16,4(r8)
 8204fa0:	d8c02015 	stw	r3,128(sp)
 8204fa4:	d8801f15 	stw	r2,124(sp)
 8204fa8:	010001c4 	movi	r4,7
 8204fac:	2080060e 	bge	r4,r2,8204fc8 <___svfprintf_internal_r+0xa20>
 8204fb0:	d9402c17 	ldw	r5,176(sp)
 8204fb4:	d9801e04 	addi	r6,sp,120
 8204fb8:	9809883a 	mov	r4,r19
 8204fbc:	820ddd40 	call	820ddd4 <__ssprint_r>
 8204fc0:	103e5e1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8204fc4:	d8c02017 	ldw	r3,128(sp)
 8204fc8:	d8803117 	ldw	r2,196(sp)
 8204fcc:	d9002a17 	ldw	r4,168(sp)
 8204fd0:	1100010e 	bge	r2,r4,8204fd8 <___svfprintf_internal_r+0xa30>
 8204fd4:	2005883a 	mov	r2,r4
 8204fd8:	d9402f17 	ldw	r5,188(sp)
 8204fdc:	288b883a 	add	r5,r5,r2
 8204fe0:	d9402f15 	stw	r5,188(sp)
 8204fe4:	18019c1e 	bne	r3,zero,8205658 <___svfprintf_internal_r+0x10b0>
 8204fe8:	b8800007 	ldb	r2,0(r23)
 8204fec:	d8001f15 	stw	zero,124(sp)
 8204ff0:	da000404 	addi	r8,sp,16
 8204ff4:	103d991e 	bne	r2,zero,820465c <___svfprintf_internal_r+0xb4>
 8204ff8:	b821883a 	mov	r16,r23
 8204ffc:	003daf06 	br	82046bc <___svfprintf_internal_r+0x114>
 8205000:	18c03fcc 	andi	r3,r3,255
 8205004:	1805c71e 	bne	r3,zero,8206724 <___svfprintf_internal_r+0x217c>
 8205008:	94800414 	ori	r18,r18,16
 820500c:	9080080c 	andi	r2,r18,32
 8205010:	10020126 	beq	r2,zero,8205818 <___svfprintf_internal_r+0x1270>
 8205014:	d8802d17 	ldw	r2,180(sp)
 8205018:	d9002917 	ldw	r4,164(sp)
 820501c:	d8002785 	stb	zero,158(sp)
 8205020:	10c00204 	addi	r3,r2,8
 8205024:	15000017 	ldw	r20,0(r2)
 8205028:	15800117 	ldw	r22,4(r2)
 820502c:	20038e16 	blt	r4,zero,8205e68 <___svfprintf_internal_r+0x18c0>
 8205030:	013fdfc4 	movi	r4,-129
 8205034:	a584b03a 	or	r2,r20,r22
 8205038:	d8c02d15 	stw	r3,180(sp)
 820503c:	9124703a 	and	r18,r18,r4
 8205040:	0039883a 	mov	fp,zero
 8205044:	103eb61e 	bne	r2,zero,8204b20 <___svfprintf_internal_r+0x578>
 8205048:	d8802917 	ldw	r2,164(sp)
 820504c:	1002c81e 	bne	r2,zero,8205b70 <___svfprintf_internal_r+0x15c8>
 8205050:	d8002915 	stw	zero,164(sp)
 8205054:	d8002e15 	stw	zero,184(sp)
 8205058:	dc001e04 	addi	r16,sp,120
 820505c:	003efa06 	br	8204c48 <___svfprintf_internal_r+0x6a0>
 8205060:	18c03fcc 	andi	r3,r3,255
 8205064:	1805ad1e 	bne	r3,zero,820671c <___svfprintf_internal_r+0x2174>
 8205068:	01420974 	movhi	r5,2085
 820506c:	2975dd04 	addi	r5,r5,-10380
 8205070:	d9403a15 	stw	r5,232(sp)
 8205074:	9080080c 	andi	r2,r18,32
 8205078:	10006126 	beq	r2,zero,8205200 <___svfprintf_internal_r+0xc58>
 820507c:	d8802d17 	ldw	r2,180(sp)
 8205080:	15000017 	ldw	r20,0(r2)
 8205084:	15800117 	ldw	r22,4(r2)
 8205088:	10800204 	addi	r2,r2,8
 820508c:	d8802d15 	stw	r2,180(sp)
 8205090:	9080004c 	andi	r2,r18,1
 8205094:	10018e26 	beq	r2,zero,82056d0 <___svfprintf_internal_r+0x1128>
 8205098:	a584b03a 	or	r2,r20,r22
 820509c:	10030926 	beq	r2,zero,8205cc4 <___svfprintf_internal_r+0x171c>
 82050a0:	d8c02917 	ldw	r3,164(sp)
 82050a4:	00800c04 	movi	r2,48
 82050a8:	d8802705 	stb	r2,156(sp)
 82050ac:	dc402745 	stb	r17,157(sp)
 82050b0:	d8002785 	stb	zero,158(sp)
 82050b4:	90800094 	ori	r2,r18,2
 82050b8:	18048716 	blt	r3,zero,82062d8 <___svfprintf_internal_r+0x1d30>
 82050bc:	00bfdfc4 	movi	r2,-129
 82050c0:	90a4703a 	and	r18,r18,r2
 82050c4:	94800094 	ori	r18,r18,2
 82050c8:	0039883a 	mov	fp,zero
 82050cc:	d9003a17 	ldw	r4,232(sp)
 82050d0:	dc001e04 	addi	r16,sp,120
 82050d4:	a08003cc 	andi	r2,r20,15
 82050d8:	b006973a 	slli	r3,r22,28
 82050dc:	2085883a 	add	r2,r4,r2
 82050e0:	a028d13a 	srli	r20,r20,4
 82050e4:	10800003 	ldbu	r2,0(r2)
 82050e8:	b02cd13a 	srli	r22,r22,4
 82050ec:	843fffc4 	addi	r16,r16,-1
 82050f0:	1d28b03a 	or	r20,r3,r20
 82050f4:	80800005 	stb	r2,0(r16)
 82050f8:	a584b03a 	or	r2,r20,r22
 82050fc:	103ff51e 	bne	r2,zero,82050d4 <___svfprintf_internal_r+0xb2c>
 8205100:	d8c02817 	ldw	r3,160(sp)
 8205104:	1c07c83a 	sub	r3,r3,r16
 8205108:	d8c02e15 	stw	r3,184(sp)
 820510c:	003ece06 	br	8204c48 <___svfprintf_internal_r+0x6a0>
 8205110:	d8c02d17 	ldw	r3,180(sp)
 8205114:	d9002d17 	ldw	r4,180(sp)
 8205118:	d8002785 	stb	zero,158(sp)
 820511c:	18800017 	ldw	r2,0(r3)
 8205120:	21000104 	addi	r4,r4,4
 8205124:	00c00044 	movi	r3,1
 8205128:	d8c02a15 	stw	r3,168(sp)
 820512c:	d8801405 	stb	r2,80(sp)
 8205130:	d9002d15 	stw	r4,180(sp)
 8205134:	d8c02e15 	stw	r3,184(sp)
 8205138:	d8002915 	stw	zero,164(sp)
 820513c:	d8003215 	stw	zero,200(sp)
 8205140:	dc001404 	addi	r16,sp,80
 8205144:	0039883a 	mov	fp,zero
 8205148:	003ecc06 	br	8204c7c <___svfprintf_internal_r+0x6d4>
 820514c:	18c03fcc 	andi	r3,r3,255
 8205150:	183e9226 	beq	r3,zero,8204b9c <___svfprintf_internal_r+0x5f4>
 8205154:	d9c02785 	stb	r7,158(sp)
 8205158:	003e9006 	br	8204b9c <___svfprintf_internal_r+0x5f4>
 820515c:	00c00044 	movi	r3,1
 8205160:	01c00ac4 	movi	r7,43
 8205164:	bc400007 	ldb	r17,0(r23)
 8205168:	003d6306 	br	82046f8 <___svfprintf_internal_r+0x150>
 820516c:	94800814 	ori	r18,r18,32
 8205170:	bc400007 	ldb	r17,0(r23)
 8205174:	003d6006 	br	82046f8 <___svfprintf_internal_r+0x150>
 8205178:	d8c02d17 	ldw	r3,180(sp)
 820517c:	d8002785 	stb	zero,158(sp)
 8205180:	1c000017 	ldw	r16,0(r3)
 8205184:	1d000104 	addi	r20,r3,4
 8205188:	80040f26 	beq	r16,zero,82061c8 <___svfprintf_internal_r+0x1c20>
 820518c:	d9002917 	ldw	r4,164(sp)
 8205190:	2003dc16 	blt	r4,zero,8206104 <___svfprintf_internal_r+0x1b5c>
 8205194:	200d883a 	mov	r6,r4
 8205198:	000b883a 	mov	r5,zero
 820519c:	8009883a 	mov	r4,r16
 82051a0:	da003e15 	stw	r8,248(sp)
 82051a4:	820c2440 	call	820c244 <memchr>
 82051a8:	da003e17 	ldw	r8,248(sp)
 82051ac:	10045826 	beq	r2,zero,8206310 <___svfprintf_internal_r+0x1d68>
 82051b0:	1405c83a 	sub	r2,r2,r16
 82051b4:	d8802e15 	stw	r2,184(sp)
 82051b8:	1003d816 	blt	r2,zero,820611c <___svfprintf_internal_r+0x1b74>
 82051bc:	df002783 	ldbu	fp,158(sp)
 82051c0:	d8802a15 	stw	r2,168(sp)
 82051c4:	dd002d15 	stw	r20,180(sp)
 82051c8:	d8002915 	stw	zero,164(sp)
 82051cc:	d8003215 	stw	zero,200(sp)
 82051d0:	003ea306 	br	8204c60 <___svfprintf_internal_r+0x6b8>
 82051d4:	18c03fcc 	andi	r3,r3,255
 82051d8:	183f8c26 	beq	r3,zero,820500c <___svfprintf_internal_r+0xa64>
 82051dc:	d9c02785 	stb	r7,158(sp)
 82051e0:	003f8a06 	br	820500c <___svfprintf_internal_r+0xa64>
 82051e4:	18c03fcc 	andi	r3,r3,255
 82051e8:	1805631e 	bne	r3,zero,8206778 <___svfprintf_internal_r+0x21d0>
 82051ec:	01420974 	movhi	r5,2085
 82051f0:	2975e204 	addi	r5,r5,-10360
 82051f4:	d9403a15 	stw	r5,232(sp)
 82051f8:	9080080c 	andi	r2,r18,32
 82051fc:	103f9f1e 	bne	r2,zero,820507c <___svfprintf_internal_r+0xad4>
 8205200:	9080040c 	andi	r2,r18,16
 8205204:	10029c26 	beq	r2,zero,8205c78 <___svfprintf_internal_r+0x16d0>
 8205208:	d8c02d17 	ldw	r3,180(sp)
 820520c:	002d883a 	mov	r22,zero
 8205210:	1d000017 	ldw	r20,0(r3)
 8205214:	18c00104 	addi	r3,r3,4
 8205218:	d8c02d15 	stw	r3,180(sp)
 820521c:	003f9c06 	br	8205090 <___svfprintf_internal_r+0xae8>
 8205220:	94800054 	ori	r18,r18,1
 8205224:	bc400007 	ldb	r17,0(r23)
 8205228:	003d3306 	br	82046f8 <___svfprintf_internal_r+0x150>
 820522c:	38803fcc 	andi	r2,r7,255
 8205230:	1080201c 	xori	r2,r2,128
 8205234:	10bfe004 	addi	r2,r2,-128
 8205238:	1002971e 	bne	r2,zero,8205c98 <___svfprintf_internal_r+0x16f0>
 820523c:	00c00044 	movi	r3,1
 8205240:	01c00804 	movi	r7,32
 8205244:	bc400007 	ldb	r17,0(r23)
 8205248:	003d2b06 	br	82046f8 <___svfprintf_internal_r+0x150>
 820524c:	18c03fcc 	andi	r3,r3,255
 8205250:	183e2326 	beq	r3,zero,8204ae0 <___svfprintf_internal_r+0x538>
 8205254:	d9c02785 	stb	r7,158(sp)
 8205258:	003e2106 	br	8204ae0 <___svfprintf_internal_r+0x538>
 820525c:	bc400007 	ldb	r17,0(r23)
 8205260:	8a430426 	beq	r17,r9,8205e74 <___svfprintf_internal_r+0x18cc>
 8205264:	94800414 	ori	r18,r18,16
 8205268:	003d2306 	br	82046f8 <___svfprintf_internal_r+0x150>
 820526c:	18c03fcc 	andi	r3,r3,255
 8205270:	18053f1e 	bne	r3,zero,8206770 <___svfprintf_internal_r+0x21c8>
 8205274:	9080080c 	andi	r2,r18,32
 8205278:	10028926 	beq	r2,zero,8205ca0 <___svfprintf_internal_r+0x16f8>
 820527c:	d9402d17 	ldw	r5,180(sp)
 8205280:	d9002f17 	ldw	r4,188(sp)
 8205284:	28800017 	ldw	r2,0(r5)
 8205288:	2007d7fa 	srai	r3,r4,31
 820528c:	29400104 	addi	r5,r5,4
 8205290:	d9402d15 	stw	r5,180(sp)
 8205294:	11000015 	stw	r4,0(r2)
 8205298:	10c00115 	stw	r3,4(r2)
 820529c:	003ced06 	br	8204654 <___svfprintf_internal_r+0xac>
 82052a0:	94801014 	ori	r18,r18,64
 82052a4:	bc400007 	ldb	r17,0(r23)
 82052a8:	003d1306 	br	82046f8 <___svfprintf_internal_r+0x150>
 82052ac:	01020974 	movhi	r4,2085
 82052b0:	2135e204 	addi	r4,r4,-10360
 82052b4:	0039883a 	mov	fp,zero
 82052b8:	d9003a15 	stw	r4,232(sp)
 82052bc:	04401e04 	movi	r17,120
 82052c0:	003f8206 	br	82050cc <___svfprintf_internal_r+0xb24>
 82052c4:	18c03fcc 	andi	r3,r3,255
 82052c8:	1805221e 	bne	r3,zero,8206754 <___svfprintf_internal_r+0x21ac>
 82052cc:	883d9526 	beq	r17,zero,8204924 <___svfprintf_internal_r+0x37c>
 82052d0:	00c00044 	movi	r3,1
 82052d4:	d8c02a15 	stw	r3,168(sp)
 82052d8:	dc401405 	stb	r17,80(sp)
 82052dc:	d8002785 	stb	zero,158(sp)
 82052e0:	003f9406 	br	8205134 <___svfprintf_internal_r+0xb8c>
 82052e4:	01020974 	movhi	r4,2085
 82052e8:	2135e204 	addi	r4,r4,-10360
 82052ec:	d9003a15 	stw	r4,232(sp)
 82052f0:	d8c02d15 	stw	r3,180(sp)
 82052f4:	1025883a 	mov	r18,r2
 82052f8:	04401e04 	movi	r17,120
 82052fc:	a584b03a 	or	r2,r20,r22
 8205300:	1000fa1e 	bne	r2,zero,82056ec <___svfprintf_internal_r+0x1144>
 8205304:	0039883a 	mov	fp,zero
 8205308:	00800084 	movi	r2,2
 820530c:	10803fcc 	andi	r2,r2,255
 8205310:	00c00044 	movi	r3,1
 8205314:	10c21626 	beq	r2,r3,8205b70 <___svfprintf_internal_r+0x15c8>
 8205318:	00c00084 	movi	r3,2
 820531c:	10fe301e 	bne	r2,r3,8204be0 <___svfprintf_internal_r+0x638>
 8205320:	003d7606 	br	82048fc <___svfprintf_internal_r+0x354>
 8205324:	d8c02017 	ldw	r3,128(sp)
 8205328:	003e9506 	br	8204d80 <___svfprintf_internal_r+0x7d8>
 820532c:	00801944 	movi	r2,101
 8205330:	14407c0e 	bge	r2,r17,8205524 <___svfprintf_internal_r+0xf7c>
 8205334:	d9003617 	ldw	r4,216(sp)
 8205338:	d9403717 	ldw	r5,220(sp)
 820533c:	000d883a 	mov	r6,zero
 8205340:	000f883a 	mov	r7,zero
 8205344:	d8c03d15 	stw	r3,244(sp)
 8205348:	da003e15 	stw	r8,248(sp)
 820534c:	8212c480 	call	8212c48 <__eqdf2>
 8205350:	d8c03d17 	ldw	r3,244(sp)
 8205354:	da003e17 	ldw	r8,248(sp)
 8205358:	1000f51e 	bne	r2,zero,8205730 <___svfprintf_internal_r+0x1188>
 820535c:	d8801f17 	ldw	r2,124(sp)
 8205360:	01020974 	movhi	r4,2085
 8205364:	2135e904 	addi	r4,r4,-10332
 8205368:	18c00044 	addi	r3,r3,1
 820536c:	10800044 	addi	r2,r2,1
 8205370:	41000015 	stw	r4,0(r8)
 8205374:	01000044 	movi	r4,1
 8205378:	41000115 	stw	r4,4(r8)
 820537c:	d8c02015 	stw	r3,128(sp)
 8205380:	d8801f15 	stw	r2,124(sp)
 8205384:	010001c4 	movi	r4,7
 8205388:	20826616 	blt	r4,r2,8205d24 <___svfprintf_internal_r+0x177c>
 820538c:	42000204 	addi	r8,r8,8
 8205390:	d8802617 	ldw	r2,152(sp)
 8205394:	d9403317 	ldw	r5,204(sp)
 8205398:	11400216 	blt	r2,r5,82053a4 <___svfprintf_internal_r+0xdfc>
 820539c:	9080004c 	andi	r2,r18,1
 82053a0:	103ed526 	beq	r2,zero,8204ef8 <___svfprintf_internal_r+0x950>
 82053a4:	d8803817 	ldw	r2,224(sp)
 82053a8:	d9003417 	ldw	r4,208(sp)
 82053ac:	d9403817 	ldw	r5,224(sp)
 82053b0:	1887883a 	add	r3,r3,r2
 82053b4:	d8801f17 	ldw	r2,124(sp)
 82053b8:	41000015 	stw	r4,0(r8)
 82053bc:	41400115 	stw	r5,4(r8)
 82053c0:	10800044 	addi	r2,r2,1
 82053c4:	d8c02015 	stw	r3,128(sp)
 82053c8:	d8801f15 	stw	r2,124(sp)
 82053cc:	010001c4 	movi	r4,7
 82053d0:	2082af16 	blt	r4,r2,8205e90 <___svfprintf_internal_r+0x18e8>
 82053d4:	42000204 	addi	r8,r8,8
 82053d8:	d8803317 	ldw	r2,204(sp)
 82053dc:	143fffc4 	addi	r16,r2,-1
 82053e0:	043ec50e 	bge	zero,r16,8204ef8 <___svfprintf_internal_r+0x950>
 82053e4:	04400404 	movi	r17,16
 82053e8:	d8801f17 	ldw	r2,124(sp)
 82053ec:	8c00860e 	bge	r17,r16,8205608 <___svfprintf_internal_r+0x1060>
 82053f0:	01420974 	movhi	r5,2085
 82053f4:	2975e984 	addi	r5,r5,-10330
 82053f8:	d9402b15 	stw	r5,172(sp)
 82053fc:	058001c4 	movi	r22,7
 8205400:	dd002c17 	ldw	r20,176(sp)
 8205404:	00000306 	br	8205414 <___svfprintf_internal_r+0xe6c>
 8205408:	42000204 	addi	r8,r8,8
 820540c:	843ffc04 	addi	r16,r16,-16
 8205410:	8c00800e 	bge	r17,r16,8205614 <___svfprintf_internal_r+0x106c>
 8205414:	18c00404 	addi	r3,r3,16
 8205418:	10800044 	addi	r2,r2,1
 820541c:	45400015 	stw	r21,0(r8)
 8205420:	44400115 	stw	r17,4(r8)
 8205424:	d8c02015 	stw	r3,128(sp)
 8205428:	d8801f15 	stw	r2,124(sp)
 820542c:	b0bff60e 	bge	r22,r2,8205408 <___svfprintf_internal_r+0xe60>
 8205430:	d9801e04 	addi	r6,sp,120
 8205434:	a00b883a 	mov	r5,r20
 8205438:	9809883a 	mov	r4,r19
 820543c:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205440:	103d3e1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205444:	d8c02017 	ldw	r3,128(sp)
 8205448:	d8801f17 	ldw	r2,124(sp)
 820544c:	da000404 	addi	r8,sp,16
 8205450:	003fee06 	br	820540c <___svfprintf_internal_r+0xe64>
 8205454:	d9403117 	ldw	r5,196(sp)
 8205458:	d8802a17 	ldw	r2,168(sp)
 820545c:	28adc83a 	sub	r22,r5,r2
 8205460:	05be650e 	bge	zero,r22,8204df8 <___svfprintf_internal_r+0x850>
 8205464:	07000404 	movi	fp,16
 8205468:	d8801f17 	ldw	r2,124(sp)
 820546c:	e583a20e 	bge	fp,r22,82062f8 <___svfprintf_internal_r+0x1d50>
 8205470:	01420974 	movhi	r5,2085
 8205474:	2975e984 	addi	r5,r5,-10330
 8205478:	dc403015 	stw	r17,192(sp)
 820547c:	d9402b15 	stw	r5,172(sp)
 8205480:	b023883a 	mov	r17,r22
 8205484:	050001c4 	movi	r20,7
 8205488:	902d883a 	mov	r22,r18
 820548c:	8025883a 	mov	r18,r16
 8205490:	dc002c17 	ldw	r16,176(sp)
 8205494:	00000306 	br	82054a4 <___svfprintf_internal_r+0xefc>
 8205498:	8c7ffc04 	addi	r17,r17,-16
 820549c:	42000204 	addi	r8,r8,8
 82054a0:	e440110e 	bge	fp,r17,82054e8 <___svfprintf_internal_r+0xf40>
 82054a4:	18c00404 	addi	r3,r3,16
 82054a8:	10800044 	addi	r2,r2,1
 82054ac:	45400015 	stw	r21,0(r8)
 82054b0:	47000115 	stw	fp,4(r8)
 82054b4:	d8c02015 	stw	r3,128(sp)
 82054b8:	d8801f15 	stw	r2,124(sp)
 82054bc:	a0bff60e 	bge	r20,r2,8205498 <___svfprintf_internal_r+0xef0>
 82054c0:	d9801e04 	addi	r6,sp,120
 82054c4:	800b883a 	mov	r5,r16
 82054c8:	9809883a 	mov	r4,r19
 82054cc:	820ddd40 	call	820ddd4 <__ssprint_r>
 82054d0:	103d1a1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82054d4:	8c7ffc04 	addi	r17,r17,-16
 82054d8:	d8c02017 	ldw	r3,128(sp)
 82054dc:	d8801f17 	ldw	r2,124(sp)
 82054e0:	da000404 	addi	r8,sp,16
 82054e4:	e47fef16 	blt	fp,r17,82054a4 <___svfprintf_internal_r+0xefc>
 82054e8:	9021883a 	mov	r16,r18
 82054ec:	b025883a 	mov	r18,r22
 82054f0:	882d883a 	mov	r22,r17
 82054f4:	dc403017 	ldw	r17,192(sp)
 82054f8:	d9002b17 	ldw	r4,172(sp)
 82054fc:	1d87883a 	add	r3,r3,r22
 8205500:	10800044 	addi	r2,r2,1
 8205504:	41000015 	stw	r4,0(r8)
 8205508:	45800115 	stw	r22,4(r8)
 820550c:	d8c02015 	stw	r3,128(sp)
 8205510:	d8801f15 	stw	r2,124(sp)
 8205514:	010001c4 	movi	r4,7
 8205518:	20819a16 	blt	r4,r2,8205b84 <___svfprintf_internal_r+0x15dc>
 820551c:	42000204 	addi	r8,r8,8
 8205520:	003e3506 	br	8204df8 <___svfprintf_internal_r+0x850>
 8205524:	d9403317 	ldw	r5,204(sp)
 8205528:	00800044 	movi	r2,1
 820552c:	18c00044 	addi	r3,r3,1
 8205530:	1141710e 	bge	r2,r5,8205af8 <___svfprintf_internal_r+0x1550>
 8205534:	dc401f17 	ldw	r17,124(sp)
 8205538:	00800044 	movi	r2,1
 820553c:	40800115 	stw	r2,4(r8)
 8205540:	8c400044 	addi	r17,r17,1
 8205544:	44000015 	stw	r16,0(r8)
 8205548:	d8c02015 	stw	r3,128(sp)
 820554c:	dc401f15 	stw	r17,124(sp)
 8205550:	008001c4 	movi	r2,7
 8205554:	14417416 	blt	r2,r17,8205b28 <___svfprintf_internal_r+0x1580>
 8205558:	42000204 	addi	r8,r8,8
 820555c:	d8803817 	ldw	r2,224(sp)
 8205560:	d9003417 	ldw	r4,208(sp)
 8205564:	8c400044 	addi	r17,r17,1
 8205568:	10c7883a 	add	r3,r2,r3
 820556c:	40800115 	stw	r2,4(r8)
 8205570:	41000015 	stw	r4,0(r8)
 8205574:	d8c02015 	stw	r3,128(sp)
 8205578:	dc401f15 	stw	r17,124(sp)
 820557c:	008001c4 	movi	r2,7
 8205580:	14417216 	blt	r2,r17,8205b4c <___svfprintf_internal_r+0x15a4>
 8205584:	45800204 	addi	r22,r8,8
 8205588:	d9003617 	ldw	r4,216(sp)
 820558c:	d9403717 	ldw	r5,220(sp)
 8205590:	000d883a 	mov	r6,zero
 8205594:	000f883a 	mov	r7,zero
 8205598:	d8c03d15 	stw	r3,244(sp)
 820559c:	8212c480 	call	8212c48 <__eqdf2>
 82055a0:	d8c03d17 	ldw	r3,244(sp)
 82055a4:	1000b326 	beq	r2,zero,8205874 <___svfprintf_internal_r+0x12cc>
 82055a8:	d9403317 	ldw	r5,204(sp)
 82055ac:	84000044 	addi	r16,r16,1
 82055b0:	8c400044 	addi	r17,r17,1
 82055b4:	28bfffc4 	addi	r2,r5,-1
 82055b8:	1887883a 	add	r3,r3,r2
 82055bc:	b0800115 	stw	r2,4(r22)
 82055c0:	b4000015 	stw	r16,0(r22)
 82055c4:	d8c02015 	stw	r3,128(sp)
 82055c8:	dc401f15 	stw	r17,124(sp)
 82055cc:	008001c4 	movi	r2,7
 82055d0:	1440d216 	blt	r2,r17,820591c <___svfprintf_internal_r+0x1374>
 82055d4:	b5800204 	addi	r22,r22,8
 82055d8:	d9003b17 	ldw	r4,236(sp)
 82055dc:	df0022c4 	addi	fp,sp,139
 82055e0:	8c400044 	addi	r17,r17,1
 82055e4:	20c7883a 	add	r3,r4,r3
 82055e8:	b7000015 	stw	fp,0(r22)
 82055ec:	b1000115 	stw	r4,4(r22)
 82055f0:	d8c02015 	stw	r3,128(sp)
 82055f4:	dc401f15 	stw	r17,124(sp)
 82055f8:	008001c4 	movi	r2,7
 82055fc:	14400e16 	blt	r2,r17,8205638 <___svfprintf_internal_r+0x1090>
 8205600:	b2000204 	addi	r8,r22,8
 8205604:	003e3c06 	br	8204ef8 <___svfprintf_internal_r+0x950>
 8205608:	01020974 	movhi	r4,2085
 820560c:	2135e984 	addi	r4,r4,-10330
 8205610:	d9002b15 	stw	r4,172(sp)
 8205614:	d9002b17 	ldw	r4,172(sp)
 8205618:	1c07883a 	add	r3,r3,r16
 820561c:	44000115 	stw	r16,4(r8)
 8205620:	41000015 	stw	r4,0(r8)
 8205624:	10800044 	addi	r2,r2,1
 8205628:	d8c02015 	stw	r3,128(sp)
 820562c:	d8801f15 	stw	r2,124(sp)
 8205630:	010001c4 	movi	r4,7
 8205634:	20be2f0e 	bge	r4,r2,8204ef4 <___svfprintf_internal_r+0x94c>
 8205638:	d9402c17 	ldw	r5,176(sp)
 820563c:	d9801e04 	addi	r6,sp,120
 8205640:	9809883a 	mov	r4,r19
 8205644:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205648:	103cbc1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 820564c:	d8c02017 	ldw	r3,128(sp)
 8205650:	da000404 	addi	r8,sp,16
 8205654:	003e2806 	br	8204ef8 <___svfprintf_internal_r+0x950>
 8205658:	d9402c17 	ldw	r5,176(sp)
 820565c:	d9801e04 	addi	r6,sp,120
 8205660:	9809883a 	mov	r4,r19
 8205664:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205668:	103e5f26 	beq	r2,zero,8204fe8 <___svfprintf_internal_r+0xa40>
 820566c:	003cb306 	br	820493c <___svfprintf_internal_r+0x394>
 8205670:	d9402c17 	ldw	r5,176(sp)
 8205674:	d9801e04 	addi	r6,sp,120
 8205678:	9809883a 	mov	r4,r19
 820567c:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205680:	103cae1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205684:	d8c02017 	ldw	r3,128(sp)
 8205688:	da000404 	addi	r8,sp,16
 820568c:	003e0d06 	br	8204ec4 <___svfprintf_internal_r+0x91c>
 8205690:	d9402c17 	ldw	r5,176(sp)
 8205694:	d9801e04 	addi	r6,sp,120
 8205698:	9809883a 	mov	r4,r19
 820569c:	820ddd40 	call	820ddd4 <__ssprint_r>
 82056a0:	103ca61e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82056a4:	d8c02017 	ldw	r3,128(sp)
 82056a8:	da000404 	addi	r8,sp,16
 82056ac:	003dc106 	br	8204db4 <___svfprintf_internal_r+0x80c>
 82056b0:	d9402c17 	ldw	r5,176(sp)
 82056b4:	d9801e04 	addi	r6,sp,120
 82056b8:	9809883a 	mov	r4,r19
 82056bc:	820ddd40 	call	820ddd4 <__ssprint_r>
 82056c0:	103c9e1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82056c4:	d8c02017 	ldw	r3,128(sp)
 82056c8:	da000404 	addi	r8,sp,16
 82056cc:	003dc706 	br	8204dec <___svfprintf_internal_r+0x844>
 82056d0:	d8802917 	ldw	r2,164(sp)
 82056d4:	d8002785 	stb	zero,158(sp)
 82056d8:	103f0816 	blt	r2,zero,82052fc <___svfprintf_internal_r+0xd54>
 82056dc:	00ffdfc4 	movi	r3,-129
 82056e0:	a584b03a 	or	r2,r20,r22
 82056e4:	90e4703a 	and	r18,r18,r3
 82056e8:	103c8126 	beq	r2,zero,82048f0 <___svfprintf_internal_r+0x348>
 82056ec:	0039883a 	mov	fp,zero
 82056f0:	003e7606 	br	82050cc <___svfprintf_internal_r+0xb24>
 82056f4:	9080040c 	andi	r2,r18,16
 82056f8:	10013d26 	beq	r2,zero,8205bf0 <___svfprintf_internal_r+0x1648>
 82056fc:	d9002d17 	ldw	r4,180(sp)
 8205700:	d9402917 	ldw	r5,164(sp)
 8205704:	d8002785 	stb	zero,158(sp)
 8205708:	20800104 	addi	r2,r4,4
 820570c:	25000017 	ldw	r20,0(r4)
 8205710:	002d883a 	mov	r22,zero
 8205714:	28013f16 	blt	r5,zero,8205c14 <___svfprintf_internal_r+0x166c>
 8205718:	00ffdfc4 	movi	r3,-129
 820571c:	d8802d15 	stw	r2,180(sp)
 8205720:	90e4703a 	and	r18,r18,r3
 8205724:	a03d2b26 	beq	r20,zero,8204bd4 <___svfprintf_internal_r+0x62c>
 8205728:	0039883a 	mov	fp,zero
 820572c:	003d2e06 	br	8204be8 <___svfprintf_internal_r+0x640>
 8205730:	dc402617 	ldw	r17,152(sp)
 8205734:	0441830e 	bge	zero,r17,8205d44 <___svfprintf_internal_r+0x179c>
 8205738:	dc403217 	ldw	r17,200(sp)
 820573c:	d8803317 	ldw	r2,204(sp)
 8205740:	1440010e 	bge	r2,r17,8205748 <___svfprintf_internal_r+0x11a0>
 8205744:	1023883a 	mov	r17,r2
 8205748:	04400a0e 	bge	zero,r17,8205774 <___svfprintf_internal_r+0x11cc>
 820574c:	d8801f17 	ldw	r2,124(sp)
 8205750:	1c47883a 	add	r3,r3,r17
 8205754:	44000015 	stw	r16,0(r8)
 8205758:	10800044 	addi	r2,r2,1
 820575c:	44400115 	stw	r17,4(r8)
 8205760:	d8c02015 	stw	r3,128(sp)
 8205764:	d8801f15 	stw	r2,124(sp)
 8205768:	010001c4 	movi	r4,7
 820576c:	20827516 	blt	r4,r2,8206144 <___svfprintf_internal_r+0x1b9c>
 8205770:	42000204 	addi	r8,r8,8
 8205774:	88027b16 	blt	r17,zero,8206164 <___svfprintf_internal_r+0x1bbc>
 8205778:	d9003217 	ldw	r4,200(sp)
 820577c:	2463c83a 	sub	r17,r4,r17
 8205780:	0440990e 	bge	zero,r17,82059e8 <___svfprintf_internal_r+0x1440>
 8205784:	05800404 	movi	r22,16
 8205788:	d8801f17 	ldw	r2,124(sp)
 820578c:	b441530e 	bge	r22,r17,8205cdc <___svfprintf_internal_r+0x1734>
 8205790:	01020974 	movhi	r4,2085
 8205794:	2135e984 	addi	r4,r4,-10330
 8205798:	d9002b15 	stw	r4,172(sp)
 820579c:	070001c4 	movi	fp,7
 82057a0:	dd002c17 	ldw	r20,176(sp)
 82057a4:	00000306 	br	82057b4 <___svfprintf_internal_r+0x120c>
 82057a8:	42000204 	addi	r8,r8,8
 82057ac:	8c7ffc04 	addi	r17,r17,-16
 82057b0:	b4414d0e 	bge	r22,r17,8205ce8 <___svfprintf_internal_r+0x1740>
 82057b4:	18c00404 	addi	r3,r3,16
 82057b8:	10800044 	addi	r2,r2,1
 82057bc:	45400015 	stw	r21,0(r8)
 82057c0:	45800115 	stw	r22,4(r8)
 82057c4:	d8c02015 	stw	r3,128(sp)
 82057c8:	d8801f15 	stw	r2,124(sp)
 82057cc:	e0bff60e 	bge	fp,r2,82057a8 <___svfprintf_internal_r+0x1200>
 82057d0:	d9801e04 	addi	r6,sp,120
 82057d4:	a00b883a 	mov	r5,r20
 82057d8:	9809883a 	mov	r4,r19
 82057dc:	820ddd40 	call	820ddd4 <__ssprint_r>
 82057e0:	103c561e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82057e4:	d8c02017 	ldw	r3,128(sp)
 82057e8:	d8801f17 	ldw	r2,124(sp)
 82057ec:	da000404 	addi	r8,sp,16
 82057f0:	003fee06 	br	82057ac <___svfprintf_internal_r+0x1204>
 82057f4:	d9402c17 	ldw	r5,176(sp)
 82057f8:	d9801e04 	addi	r6,sp,120
 82057fc:	9809883a 	mov	r4,r19
 8205800:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205804:	103c4d1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205808:	d8c02017 	ldw	r3,128(sp)
 820580c:	df002787 	ldb	fp,158(sp)
 8205810:	da000404 	addi	r8,sp,16
 8205814:	003d5a06 	br	8204d80 <___svfprintf_internal_r+0x7d8>
 8205818:	9080040c 	andi	r2,r18,16
 820581c:	10005c26 	beq	r2,zero,8205990 <___svfprintf_internal_r+0x13e8>
 8205820:	d9402d17 	ldw	r5,180(sp)
 8205824:	d8c02917 	ldw	r3,164(sp)
 8205828:	d8002785 	stb	zero,158(sp)
 820582c:	28800104 	addi	r2,r5,4
 8205830:	2d000017 	ldw	r20,0(r5)
 8205834:	002d883a 	mov	r22,zero
 8205838:	18005e16 	blt	r3,zero,82059b4 <___svfprintf_internal_r+0x140c>
 820583c:	00ffdfc4 	movi	r3,-129
 8205840:	d8802d15 	stw	r2,180(sp)
 8205844:	90e4703a 	and	r18,r18,r3
 8205848:	0039883a 	mov	fp,zero
 820584c:	a03dfe26 	beq	r20,zero,8205048 <___svfprintf_internal_r+0xaa0>
 8205850:	00800244 	movi	r2,9
 8205854:	153cb336 	bltu	r2,r20,8204b24 <___svfprintf_internal_r+0x57c>
 8205858:	a5000c04 	addi	r20,r20,48
 820585c:	dc001dc4 	addi	r16,sp,119
 8205860:	dd001dc5 	stb	r20,119(sp)
 8205864:	d8c02817 	ldw	r3,160(sp)
 8205868:	1c07c83a 	sub	r3,r3,r16
 820586c:	d8c02e15 	stw	r3,184(sp)
 8205870:	003cf506 	br	8204c48 <___svfprintf_internal_r+0x6a0>
 8205874:	d8803317 	ldw	r2,204(sp)
 8205878:	143fffc4 	addi	r16,r2,-1
 820587c:	043f560e 	bge	zero,r16,82055d8 <___svfprintf_internal_r+0x1030>
 8205880:	07000404 	movi	fp,16
 8205884:	e403530e 	bge	fp,r16,82065d4 <___svfprintf_internal_r+0x202c>
 8205888:	01420974 	movhi	r5,2085
 820588c:	2975e984 	addi	r5,r5,-10330
 8205890:	d9402b15 	stw	r5,172(sp)
 8205894:	01c001c4 	movi	r7,7
 8205898:	dd002c17 	ldw	r20,176(sp)
 820589c:	00000306 	br	82058ac <___svfprintf_internal_r+0x1304>
 82058a0:	843ffc04 	addi	r16,r16,-16
 82058a4:	b5800204 	addi	r22,r22,8
 82058a8:	e400130e 	bge	fp,r16,82058f8 <___svfprintf_internal_r+0x1350>
 82058ac:	18c00404 	addi	r3,r3,16
 82058b0:	8c400044 	addi	r17,r17,1
 82058b4:	b5400015 	stw	r21,0(r22)
 82058b8:	b7000115 	stw	fp,4(r22)
 82058bc:	d8c02015 	stw	r3,128(sp)
 82058c0:	dc401f15 	stw	r17,124(sp)
 82058c4:	3c7ff60e 	bge	r7,r17,82058a0 <___svfprintf_internal_r+0x12f8>
 82058c8:	d9801e04 	addi	r6,sp,120
 82058cc:	a00b883a 	mov	r5,r20
 82058d0:	9809883a 	mov	r4,r19
 82058d4:	d9c03d15 	stw	r7,244(sp)
 82058d8:	820ddd40 	call	820ddd4 <__ssprint_r>
 82058dc:	d9c03d17 	ldw	r7,244(sp)
 82058e0:	103c161e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82058e4:	843ffc04 	addi	r16,r16,-16
 82058e8:	d8c02017 	ldw	r3,128(sp)
 82058ec:	dc401f17 	ldw	r17,124(sp)
 82058f0:	dd800404 	addi	r22,sp,16
 82058f4:	e43fed16 	blt	fp,r16,82058ac <___svfprintf_internal_r+0x1304>
 82058f8:	d8802b17 	ldw	r2,172(sp)
 82058fc:	1c07883a 	add	r3,r3,r16
 8205900:	8c400044 	addi	r17,r17,1
 8205904:	b0800015 	stw	r2,0(r22)
 8205908:	b4000115 	stw	r16,4(r22)
 820590c:	d8c02015 	stw	r3,128(sp)
 8205910:	dc401f15 	stw	r17,124(sp)
 8205914:	008001c4 	movi	r2,7
 8205918:	147f2e0e 	bge	r2,r17,82055d4 <___svfprintf_internal_r+0x102c>
 820591c:	d9402c17 	ldw	r5,176(sp)
 8205920:	d9801e04 	addi	r6,sp,120
 8205924:	9809883a 	mov	r4,r19
 8205928:	820ddd40 	call	820ddd4 <__ssprint_r>
 820592c:	103c031e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205930:	d8c02017 	ldw	r3,128(sp)
 8205934:	dc401f17 	ldw	r17,124(sp)
 8205938:	dd800404 	addi	r22,sp,16
 820593c:	003f2606 	br	82055d8 <___svfprintf_internal_r+0x1030>
 8205940:	9080040c 	andi	r2,r18,16
 8205944:	1000c326 	beq	r2,zero,8205c54 <___svfprintf_internal_r+0x16ac>
 8205948:	d8802d17 	ldw	r2,180(sp)
 820594c:	15000017 	ldw	r20,0(r2)
 8205950:	10800104 	addi	r2,r2,4
 8205954:	d8802d15 	stw	r2,180(sp)
 8205958:	a02dd7fa 	srai	r22,r20,31
 820595c:	b005883a 	mov	r2,r22
 8205960:	103c680e 	bge	r2,zero,8204b04 <___svfprintf_internal_r+0x55c>
 8205964:	0529c83a 	sub	r20,zero,r20
 8205968:	a004c03a 	cmpne	r2,r20,zero
 820596c:	05adc83a 	sub	r22,zero,r22
 8205970:	b0adc83a 	sub	r22,r22,r2
 8205974:	d8802917 	ldw	r2,164(sp)
 8205978:	07000b44 	movi	fp,45
 820597c:	df002785 	stb	fp,158(sp)
 8205980:	10022e16 	blt	r2,zero,820623c <___svfprintf_internal_r+0x1c94>
 8205984:	00bfdfc4 	movi	r2,-129
 8205988:	90a4703a 	and	r18,r18,r2
 820598c:	003c6406 	br	8204b20 <___svfprintf_internal_r+0x578>
 8205990:	9080100c 	andi	r2,r18,64
 8205994:	d8002785 	stb	zero,158(sp)
 8205998:	10012526 	beq	r2,zero,8205e30 <___svfprintf_internal_r+0x1888>
 820599c:	d9002d17 	ldw	r4,180(sp)
 82059a0:	d9402917 	ldw	r5,164(sp)
 82059a4:	002d883a 	mov	r22,zero
 82059a8:	20800104 	addi	r2,r4,4
 82059ac:	2500000b 	ldhu	r20,0(r4)
 82059b0:	283fa20e 	bge	r5,zero,820583c <___svfprintf_internal_r+0x1294>
 82059b4:	d8802d15 	stw	r2,180(sp)
 82059b8:	0039883a 	mov	fp,zero
 82059bc:	a584b03a 	or	r2,r20,r22
 82059c0:	103c571e 	bne	r2,zero,8204b20 <___svfprintf_internal_r+0x578>
 82059c4:	00800044 	movi	r2,1
 82059c8:	003e5006 	br	820530c <___svfprintf_internal_r+0xd64>
 82059cc:	d9402c17 	ldw	r5,176(sp)
 82059d0:	d9801e04 	addi	r6,sp,120
 82059d4:	9809883a 	mov	r4,r19
 82059d8:	820ddd40 	call	820ddd4 <__ssprint_r>
 82059dc:	103bd71e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82059e0:	d8c02017 	ldw	r3,128(sp)
 82059e4:	da000404 	addi	r8,sp,16
 82059e8:	d9003217 	ldw	r4,200(sp)
 82059ec:	d8802617 	ldw	r2,152(sp)
 82059f0:	d9403317 	ldw	r5,204(sp)
 82059f4:	8123883a 	add	r17,r16,r4
 82059f8:	11400216 	blt	r2,r5,8205a04 <___svfprintf_internal_r+0x145c>
 82059fc:	9100004c 	andi	r4,r18,1
 8205a00:	20000d26 	beq	r4,zero,8205a38 <___svfprintf_internal_r+0x1490>
 8205a04:	d9003817 	ldw	r4,224(sp)
 8205a08:	d9403417 	ldw	r5,208(sp)
 8205a0c:	1907883a 	add	r3,r3,r4
 8205a10:	d9001f17 	ldw	r4,124(sp)
 8205a14:	41400015 	stw	r5,0(r8)
 8205a18:	d9403817 	ldw	r5,224(sp)
 8205a1c:	21000044 	addi	r4,r4,1
 8205a20:	d8c02015 	stw	r3,128(sp)
 8205a24:	41400115 	stw	r5,4(r8)
 8205a28:	d9001f15 	stw	r4,124(sp)
 8205a2c:	014001c4 	movi	r5,7
 8205a30:	2901dc16 	blt	r5,r4,82061a4 <___svfprintf_internal_r+0x1bfc>
 8205a34:	42000204 	addi	r8,r8,8
 8205a38:	d9003317 	ldw	r4,204(sp)
 8205a3c:	8121883a 	add	r16,r16,r4
 8205a40:	2085c83a 	sub	r2,r4,r2
 8205a44:	8461c83a 	sub	r16,r16,r17
 8205a48:	1400010e 	bge	r2,r16,8205a50 <___svfprintf_internal_r+0x14a8>
 8205a4c:	1021883a 	mov	r16,r2
 8205a50:	04000a0e 	bge	zero,r16,8205a7c <___svfprintf_internal_r+0x14d4>
 8205a54:	d9001f17 	ldw	r4,124(sp)
 8205a58:	1c07883a 	add	r3,r3,r16
 8205a5c:	44400015 	stw	r17,0(r8)
 8205a60:	21000044 	addi	r4,r4,1
 8205a64:	44000115 	stw	r16,4(r8)
 8205a68:	d8c02015 	stw	r3,128(sp)
 8205a6c:	d9001f15 	stw	r4,124(sp)
 8205a70:	014001c4 	movi	r5,7
 8205a74:	2901e616 	blt	r5,r4,8206210 <___svfprintf_internal_r+0x1c68>
 8205a78:	42000204 	addi	r8,r8,8
 8205a7c:	8001f616 	blt	r16,zero,8206258 <___svfprintf_internal_r+0x1cb0>
 8205a80:	1421c83a 	sub	r16,r2,r16
 8205a84:	043d1c0e 	bge	zero,r16,8204ef8 <___svfprintf_internal_r+0x950>
 8205a88:	04400404 	movi	r17,16
 8205a8c:	d8801f17 	ldw	r2,124(sp)
 8205a90:	8c3edd0e 	bge	r17,r16,8205608 <___svfprintf_internal_r+0x1060>
 8205a94:	01420974 	movhi	r5,2085
 8205a98:	2975e984 	addi	r5,r5,-10330
 8205a9c:	d9402b15 	stw	r5,172(sp)
 8205aa0:	058001c4 	movi	r22,7
 8205aa4:	dd002c17 	ldw	r20,176(sp)
 8205aa8:	00000306 	br	8205ab8 <___svfprintf_internal_r+0x1510>
 8205aac:	42000204 	addi	r8,r8,8
 8205ab0:	843ffc04 	addi	r16,r16,-16
 8205ab4:	8c3ed70e 	bge	r17,r16,8205614 <___svfprintf_internal_r+0x106c>
 8205ab8:	18c00404 	addi	r3,r3,16
 8205abc:	10800044 	addi	r2,r2,1
 8205ac0:	45400015 	stw	r21,0(r8)
 8205ac4:	44400115 	stw	r17,4(r8)
 8205ac8:	d8c02015 	stw	r3,128(sp)
 8205acc:	d8801f15 	stw	r2,124(sp)
 8205ad0:	b0bff60e 	bge	r22,r2,8205aac <___svfprintf_internal_r+0x1504>
 8205ad4:	d9801e04 	addi	r6,sp,120
 8205ad8:	a00b883a 	mov	r5,r20
 8205adc:	9809883a 	mov	r4,r19
 8205ae0:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205ae4:	103b951e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205ae8:	d8c02017 	ldw	r3,128(sp)
 8205aec:	d8801f17 	ldw	r2,124(sp)
 8205af0:	da000404 	addi	r8,sp,16
 8205af4:	003fee06 	br	8205ab0 <___svfprintf_internal_r+0x1508>
 8205af8:	9088703a 	and	r4,r18,r2
 8205afc:	203e8d1e 	bne	r4,zero,8205534 <___svfprintf_internal_r+0xf8c>
 8205b00:	dc401f17 	ldw	r17,124(sp)
 8205b04:	40800115 	stw	r2,4(r8)
 8205b08:	44000015 	stw	r16,0(r8)
 8205b0c:	8c400044 	addi	r17,r17,1
 8205b10:	d8c02015 	stw	r3,128(sp)
 8205b14:	dc401f15 	stw	r17,124(sp)
 8205b18:	008001c4 	movi	r2,7
 8205b1c:	147f7f16 	blt	r2,r17,820591c <___svfprintf_internal_r+0x1374>
 8205b20:	45800204 	addi	r22,r8,8
 8205b24:	003eac06 	br	82055d8 <___svfprintf_internal_r+0x1030>
 8205b28:	d9402c17 	ldw	r5,176(sp)
 8205b2c:	d9801e04 	addi	r6,sp,120
 8205b30:	9809883a 	mov	r4,r19
 8205b34:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205b38:	103b801e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205b3c:	d8c02017 	ldw	r3,128(sp)
 8205b40:	dc401f17 	ldw	r17,124(sp)
 8205b44:	da000404 	addi	r8,sp,16
 8205b48:	003e8406 	br	820555c <___svfprintf_internal_r+0xfb4>
 8205b4c:	d9402c17 	ldw	r5,176(sp)
 8205b50:	d9801e04 	addi	r6,sp,120
 8205b54:	9809883a 	mov	r4,r19
 8205b58:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205b5c:	103b771e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205b60:	d8c02017 	ldw	r3,128(sp)
 8205b64:	dc401f17 	ldw	r17,124(sp)
 8205b68:	dd800404 	addi	r22,sp,16
 8205b6c:	003e8606 	br	8205588 <___svfprintf_internal_r+0xfe0>
 8205b70:	0029883a 	mov	r20,zero
 8205b74:	a5000c04 	addi	r20,r20,48
 8205b78:	dc001dc4 	addi	r16,sp,119
 8205b7c:	dd001dc5 	stb	r20,119(sp)
 8205b80:	003f3806 	br	8205864 <___svfprintf_internal_r+0x12bc>
 8205b84:	d9402c17 	ldw	r5,176(sp)
 8205b88:	d9801e04 	addi	r6,sp,120
 8205b8c:	9809883a 	mov	r4,r19
 8205b90:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205b94:	103b691e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205b98:	d8c02017 	ldw	r3,128(sp)
 8205b9c:	da000404 	addi	r8,sp,16
 8205ba0:	003c9506 	br	8204df8 <___svfprintf_internal_r+0x850>
 8205ba4:	d9003617 	ldw	r4,216(sp)
 8205ba8:	d9403717 	ldw	r5,220(sp)
 8205bac:	da003e15 	stw	r8,248(sp)
 8205bb0:	820daf40 	call	820daf4 <__fpclassifyd>
 8205bb4:	da003e17 	ldw	r8,248(sp)
 8205bb8:	1000bd1e 	bne	r2,zero,8205eb0 <___svfprintf_internal_r+0x1908>
 8205bbc:	008011c4 	movi	r2,71
 8205bc0:	14411e0e 	bge	r2,r17,820603c <___svfprintf_internal_r+0x1a94>
 8205bc4:	04020974 	movhi	r16,2085
 8205bc8:	8435dc04 	addi	r16,r16,-10384
 8205bcc:	00c000c4 	movi	r3,3
 8205bd0:	00bfdfc4 	movi	r2,-129
 8205bd4:	d8c02a15 	stw	r3,168(sp)
 8205bd8:	90a4703a 	and	r18,r18,r2
 8205bdc:	df002783 	ldbu	fp,158(sp)
 8205be0:	d8c02e15 	stw	r3,184(sp)
 8205be4:	d8002915 	stw	zero,164(sp)
 8205be8:	d8003215 	stw	zero,200(sp)
 8205bec:	003c1c06 	br	8204c60 <___svfprintf_internal_r+0x6b8>
 8205bf0:	9080100c 	andi	r2,r18,64
 8205bf4:	d8002785 	stb	zero,158(sp)
 8205bf8:	10009426 	beq	r2,zero,8205e4c <___svfprintf_internal_r+0x18a4>
 8205bfc:	d8c02d17 	ldw	r3,180(sp)
 8205c00:	d9002917 	ldw	r4,164(sp)
 8205c04:	002d883a 	mov	r22,zero
 8205c08:	18800104 	addi	r2,r3,4
 8205c0c:	1d00000b 	ldhu	r20,0(r3)
 8205c10:	203ec10e 	bge	r4,zero,8205718 <___svfprintf_internal_r+0x1170>
 8205c14:	a586b03a 	or	r3,r20,r22
 8205c18:	d8802d15 	stw	r2,180(sp)
 8205c1c:	183ec21e 	bne	r3,zero,8205728 <___svfprintf_internal_r+0x1180>
 8205c20:	0039883a 	mov	fp,zero
 8205c24:	0005883a 	mov	r2,zero
 8205c28:	003db806 	br	820530c <___svfprintf_internal_r+0xd64>
 8205c2c:	d8802d17 	ldw	r2,180(sp)
 8205c30:	d8c02d17 	ldw	r3,180(sp)
 8205c34:	d9002d17 	ldw	r4,180(sp)
 8205c38:	10800017 	ldw	r2,0(r2)
 8205c3c:	18c00117 	ldw	r3,4(r3)
 8205c40:	21000204 	addi	r4,r4,8
 8205c44:	d8803615 	stw	r2,216(sp)
 8205c48:	d8c03715 	stw	r3,220(sp)
 8205c4c:	d9002d15 	stw	r4,180(sp)
 8205c50:	003b8206 	br	8204a5c <___svfprintf_internal_r+0x4b4>
 8205c54:	9080100c 	andi	r2,r18,64
 8205c58:	10010726 	beq	r2,zero,8206078 <___svfprintf_internal_r+0x1ad0>
 8205c5c:	d8c02d17 	ldw	r3,180(sp)
 8205c60:	1d00000f 	ldh	r20,0(r3)
 8205c64:	18c00104 	addi	r3,r3,4
 8205c68:	d8c02d15 	stw	r3,180(sp)
 8205c6c:	a02dd7fa 	srai	r22,r20,31
 8205c70:	b005883a 	mov	r2,r22
 8205c74:	003ba206 	br	8204b00 <___svfprintf_internal_r+0x558>
 8205c78:	9080100c 	andi	r2,r18,64
 8205c7c:	10010526 	beq	r2,zero,8206094 <___svfprintf_internal_r+0x1aec>
 8205c80:	d9002d17 	ldw	r4,180(sp)
 8205c84:	002d883a 	mov	r22,zero
 8205c88:	2500000b 	ldhu	r20,0(r4)
 8205c8c:	21000104 	addi	r4,r4,4
 8205c90:	d9002d15 	stw	r4,180(sp)
 8205c94:	003cfe06 	br	8205090 <___svfprintf_internal_r+0xae8>
 8205c98:	bc400007 	ldb	r17,0(r23)
 8205c9c:	003a9606 	br	82046f8 <___svfprintf_internal_r+0x150>
 8205ca0:	9080040c 	andi	r2,r18,16
 8205ca4:	10010126 	beq	r2,zero,82060ac <___svfprintf_internal_r+0x1b04>
 8205ca8:	d9402d17 	ldw	r5,180(sp)
 8205cac:	d8c02f17 	ldw	r3,188(sp)
 8205cb0:	28800017 	ldw	r2,0(r5)
 8205cb4:	29400104 	addi	r5,r5,4
 8205cb8:	d9402d15 	stw	r5,180(sp)
 8205cbc:	10c00015 	stw	r3,0(r2)
 8205cc0:	003a6406 	br	8204654 <___svfprintf_internal_r+0xac>
 8205cc4:	d9002917 	ldw	r4,164(sp)
 8205cc8:	d8002785 	stb	zero,158(sp)
 8205ccc:	203d8d16 	blt	r4,zero,8205304 <___svfprintf_internal_r+0xd5c>
 8205cd0:	00bfdfc4 	movi	r2,-129
 8205cd4:	90a4703a 	and	r18,r18,r2
 8205cd8:	003b0506 	br	82048f0 <___svfprintf_internal_r+0x348>
 8205cdc:	01420974 	movhi	r5,2085
 8205ce0:	2975e984 	addi	r5,r5,-10330
 8205ce4:	d9402b15 	stw	r5,172(sp)
 8205ce8:	d9402b17 	ldw	r5,172(sp)
 8205cec:	1c47883a 	add	r3,r3,r17
 8205cf0:	10800044 	addi	r2,r2,1
 8205cf4:	41400015 	stw	r5,0(r8)
 8205cf8:	44400115 	stw	r17,4(r8)
 8205cfc:	d8c02015 	stw	r3,128(sp)
 8205d00:	d8801f15 	stw	r2,124(sp)
 8205d04:	010001c4 	movi	r4,7
 8205d08:	20bf3016 	blt	r4,r2,82059cc <___svfprintf_internal_r+0x1424>
 8205d0c:	42000204 	addi	r8,r8,8
 8205d10:	003f3506 	br	82059e8 <___svfprintf_internal_r+0x1440>
 8205d14:	01020974 	movhi	r4,2085
 8205d18:	2135e984 	addi	r4,r4,-10330
 8205d1c:	d9002b15 	stw	r4,172(sp)
 8205d20:	003c5e06 	br	8204e9c <___svfprintf_internal_r+0x8f4>
 8205d24:	d9402c17 	ldw	r5,176(sp)
 8205d28:	d9801e04 	addi	r6,sp,120
 8205d2c:	9809883a 	mov	r4,r19
 8205d30:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205d34:	103b011e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205d38:	d8c02017 	ldw	r3,128(sp)
 8205d3c:	da000404 	addi	r8,sp,16
 8205d40:	003d9306 	br	8205390 <___svfprintf_internal_r+0xde8>
 8205d44:	d8801f17 	ldw	r2,124(sp)
 8205d48:	01420974 	movhi	r5,2085
 8205d4c:	01000044 	movi	r4,1
 8205d50:	18c00044 	addi	r3,r3,1
 8205d54:	10800044 	addi	r2,r2,1
 8205d58:	2975e904 	addi	r5,r5,-10332
 8205d5c:	41000115 	stw	r4,4(r8)
 8205d60:	41400015 	stw	r5,0(r8)
 8205d64:	d8c02015 	stw	r3,128(sp)
 8205d68:	d8801f15 	stw	r2,124(sp)
 8205d6c:	010001c4 	movi	r4,7
 8205d70:	2080b516 	blt	r4,r2,8206048 <___svfprintf_internal_r+0x1aa0>
 8205d74:	42000204 	addi	r8,r8,8
 8205d78:	8800041e 	bne	r17,zero,8205d8c <___svfprintf_internal_r+0x17e4>
 8205d7c:	d8803317 	ldw	r2,204(sp)
 8205d80:	1000021e 	bne	r2,zero,8205d8c <___svfprintf_internal_r+0x17e4>
 8205d84:	9080004c 	andi	r2,r18,1
 8205d88:	103c5b26 	beq	r2,zero,8204ef8 <___svfprintf_internal_r+0x950>
 8205d8c:	d9003817 	ldw	r4,224(sp)
 8205d90:	d8801f17 	ldw	r2,124(sp)
 8205d94:	d9403417 	ldw	r5,208(sp)
 8205d98:	20c7883a 	add	r3,r4,r3
 8205d9c:	10800044 	addi	r2,r2,1
 8205da0:	41000115 	stw	r4,4(r8)
 8205da4:	41400015 	stw	r5,0(r8)
 8205da8:	d8c02015 	stw	r3,128(sp)
 8205dac:	d8801f15 	stw	r2,124(sp)
 8205db0:	010001c4 	movi	r4,7
 8205db4:	20818016 	blt	r4,r2,82063b8 <___svfprintf_internal_r+0x1e10>
 8205db8:	42000204 	addi	r8,r8,8
 8205dbc:	0463c83a 	sub	r17,zero,r17
 8205dc0:	0440cb0e 	bge	zero,r17,82060f0 <___svfprintf_internal_r+0x1b48>
 8205dc4:	05800404 	movi	r22,16
 8205dc8:	b440e80e 	bge	r22,r17,820616c <___svfprintf_internal_r+0x1bc4>
 8205dcc:	01420974 	movhi	r5,2085
 8205dd0:	2975e984 	addi	r5,r5,-10330
 8205dd4:	d9402b15 	stw	r5,172(sp)
 8205dd8:	070001c4 	movi	fp,7
 8205ddc:	dd002c17 	ldw	r20,176(sp)
 8205de0:	00000306 	br	8205df0 <___svfprintf_internal_r+0x1848>
 8205de4:	42000204 	addi	r8,r8,8
 8205de8:	8c7ffc04 	addi	r17,r17,-16
 8205dec:	b440e20e 	bge	r22,r17,8206178 <___svfprintf_internal_r+0x1bd0>
 8205df0:	18c00404 	addi	r3,r3,16
 8205df4:	10800044 	addi	r2,r2,1
 8205df8:	45400015 	stw	r21,0(r8)
 8205dfc:	45800115 	stw	r22,4(r8)
 8205e00:	d8c02015 	stw	r3,128(sp)
 8205e04:	d8801f15 	stw	r2,124(sp)
 8205e08:	e0bff60e 	bge	fp,r2,8205de4 <___svfprintf_internal_r+0x183c>
 8205e0c:	d9801e04 	addi	r6,sp,120
 8205e10:	a00b883a 	mov	r5,r20
 8205e14:	9809883a 	mov	r4,r19
 8205e18:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205e1c:	103ac71e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205e20:	d8c02017 	ldw	r3,128(sp)
 8205e24:	d8801f17 	ldw	r2,124(sp)
 8205e28:	da000404 	addi	r8,sp,16
 8205e2c:	003fee06 	br	8205de8 <___svfprintf_internal_r+0x1840>
 8205e30:	d8c02d17 	ldw	r3,180(sp)
 8205e34:	d9002917 	ldw	r4,164(sp)
 8205e38:	002d883a 	mov	r22,zero
 8205e3c:	18800104 	addi	r2,r3,4
 8205e40:	1d000017 	ldw	r20,0(r3)
 8205e44:	203e7d0e 	bge	r4,zero,820583c <___svfprintf_internal_r+0x1294>
 8205e48:	003eda06 	br	82059b4 <___svfprintf_internal_r+0x140c>
 8205e4c:	d9402d17 	ldw	r5,180(sp)
 8205e50:	d8c02917 	ldw	r3,164(sp)
 8205e54:	002d883a 	mov	r22,zero
 8205e58:	28800104 	addi	r2,r5,4
 8205e5c:	2d000017 	ldw	r20,0(r5)
 8205e60:	183e2d0e 	bge	r3,zero,8205718 <___svfprintf_internal_r+0x1170>
 8205e64:	003f6b06 	br	8205c14 <___svfprintf_internal_r+0x166c>
 8205e68:	d8c02d15 	stw	r3,180(sp)
 8205e6c:	0039883a 	mov	fp,zero
 8205e70:	003ed206 	br	82059bc <___svfprintf_internal_r+0x1414>
 8205e74:	bc400043 	ldbu	r17,1(r23)
 8205e78:	94800814 	ori	r18,r18,32
 8205e7c:	bdc00044 	addi	r23,r23,1
 8205e80:	8c403fcc 	andi	r17,r17,255
 8205e84:	8c40201c 	xori	r17,r17,128
 8205e88:	8c7fe004 	addi	r17,r17,-128
 8205e8c:	003a1a06 	br	82046f8 <___svfprintf_internal_r+0x150>
 8205e90:	d9402c17 	ldw	r5,176(sp)
 8205e94:	d9801e04 	addi	r6,sp,120
 8205e98:	9809883a 	mov	r4,r19
 8205e9c:	820ddd40 	call	820ddd4 <__ssprint_r>
 8205ea0:	103aa61e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8205ea4:	d8c02017 	ldw	r3,128(sp)
 8205ea8:	da000404 	addi	r8,sp,16
 8205eac:	003d4a06 	br	82053d8 <___svfprintf_internal_r+0xe30>
 8205eb0:	d9002917 	ldw	r4,164(sp)
 8205eb4:	05bff7c4 	movi	r22,-33
 8205eb8:	00bfffc4 	movi	r2,-1
 8205ebc:	8dac703a 	and	r22,r17,r22
 8205ec0:	20806a26 	beq	r4,r2,820606c <___svfprintf_internal_r+0x1ac4>
 8205ec4:	008011c4 	movi	r2,71
 8205ec8:	b0813726 	beq	r22,r2,82063a8 <___svfprintf_internal_r+0x1e00>
 8205ecc:	d9003717 	ldw	r4,220(sp)
 8205ed0:	90c04014 	ori	r3,r18,256
 8205ed4:	d8c02b15 	stw	r3,172(sp)
 8205ed8:	20015d16 	blt	r4,zero,8206450 <___svfprintf_internal_r+0x1ea8>
 8205edc:	dd003717 	ldw	r20,220(sp)
 8205ee0:	d8002a05 	stb	zero,168(sp)
 8205ee4:	00801984 	movi	r2,102
 8205ee8:	88814026 	beq	r17,r2,82063ec <___svfprintf_internal_r+0x1e44>
 8205eec:	00801184 	movi	r2,70
 8205ef0:	88817126 	beq	r17,r2,82064b8 <___svfprintf_internal_r+0x1f10>
 8205ef4:	00801144 	movi	r2,69
 8205ef8:	b0816226 	beq	r22,r2,8206484 <___svfprintf_internal_r+0x1edc>
 8205efc:	d8c02917 	ldw	r3,164(sp)
 8205f00:	d8802104 	addi	r2,sp,132
 8205f04:	d8800315 	stw	r2,12(sp)
 8205f08:	d9403617 	ldw	r5,216(sp)
 8205f0c:	d8802504 	addi	r2,sp,148
 8205f10:	d8800215 	stw	r2,8(sp)
 8205f14:	d8802604 	addi	r2,sp,152
 8205f18:	d8c00015 	stw	r3,0(sp)
 8205f1c:	d8800115 	stw	r2,4(sp)
 8205f20:	01c00084 	movi	r7,2
 8205f24:	a00d883a 	mov	r6,r20
 8205f28:	9809883a 	mov	r4,r19
 8205f2c:	d8c03d15 	stw	r3,244(sp)
 8205f30:	da003e15 	stw	r8,248(sp)
 8205f34:	8208f040 	call	8208f04 <_dtoa_r>
 8205f38:	1021883a 	mov	r16,r2
 8205f3c:	008019c4 	movi	r2,103
 8205f40:	d8c03d17 	ldw	r3,244(sp)
 8205f44:	da003e17 	ldw	r8,248(sp)
 8205f48:	8880e726 	beq	r17,r2,82062e8 <___svfprintf_internal_r+0x1d40>
 8205f4c:	008011c4 	movi	r2,71
 8205f50:	8880d426 	beq	r17,r2,82062a4 <___svfprintf_internal_r+0x1cfc>
 8205f54:	80f9883a 	add	fp,r16,r3
 8205f58:	d9003617 	ldw	r4,216(sp)
 8205f5c:	000d883a 	mov	r6,zero
 8205f60:	000f883a 	mov	r7,zero
 8205f64:	a00b883a 	mov	r5,r20
 8205f68:	da003e15 	stw	r8,248(sp)
 8205f6c:	8212c480 	call	8212c48 <__eqdf2>
 8205f70:	da003e17 	ldw	r8,248(sp)
 8205f74:	1000e426 	beq	r2,zero,8206308 <___svfprintf_internal_r+0x1d60>
 8205f78:	d8802117 	ldw	r2,132(sp)
 8205f7c:	1700062e 	bgeu	r2,fp,8205f98 <___svfprintf_internal_r+0x19f0>
 8205f80:	01000c04 	movi	r4,48
 8205f84:	10c00044 	addi	r3,r2,1
 8205f88:	d8c02115 	stw	r3,132(sp)
 8205f8c:	11000005 	stb	r4,0(r2)
 8205f90:	d8802117 	ldw	r2,132(sp)
 8205f94:	173ffb36 	bltu	r2,fp,8205f84 <___svfprintf_internal_r+0x19dc>
 8205f98:	1405c83a 	sub	r2,r2,r16
 8205f9c:	d8803315 	stw	r2,204(sp)
 8205fa0:	008011c4 	movi	r2,71
 8205fa4:	b080c526 	beq	r22,r2,82062bc <___svfprintf_internal_r+0x1d14>
 8205fa8:	00801944 	movi	r2,101
 8205fac:	1441d90e 	bge	r2,r17,8206714 <___svfprintf_internal_r+0x216c>
 8205fb0:	d8c02617 	ldw	r3,152(sp)
 8205fb4:	00801984 	movi	r2,102
 8205fb8:	d8c03215 	stw	r3,200(sp)
 8205fbc:	88813426 	beq	r17,r2,8206490 <___svfprintf_internal_r+0x1ee8>
 8205fc0:	d8c03217 	ldw	r3,200(sp)
 8205fc4:	d9003317 	ldw	r4,204(sp)
 8205fc8:	19012516 	blt	r3,r4,8206460 <___svfprintf_internal_r+0x1eb8>
 8205fcc:	9480004c 	andi	r18,r18,1
 8205fd0:	9001841e 	bne	r18,zero,82065e4 <___svfprintf_internal_r+0x203c>
 8205fd4:	1805883a 	mov	r2,r3
 8205fd8:	1801cc16 	blt	r3,zero,820670c <___svfprintf_internal_r+0x2164>
 8205fdc:	d8c03217 	ldw	r3,200(sp)
 8205fe0:	044019c4 	movi	r17,103
 8205fe4:	d8c02e15 	stw	r3,184(sp)
 8205fe8:	df002a07 	ldb	fp,168(sp)
 8205fec:	e000a61e 	bne	fp,zero,8206288 <___svfprintf_internal_r+0x1ce0>
 8205ff0:	df002783 	ldbu	fp,158(sp)
 8205ff4:	d8802a15 	stw	r2,168(sp)
 8205ff8:	dc802b17 	ldw	r18,172(sp)
 8205ffc:	d8002915 	stw	zero,164(sp)
 8206000:	003b1706 	br	8204c60 <___svfprintf_internal_r+0x6b8>
 8206004:	04020974 	movhi	r16,2085
 8206008:	8435d904 	addi	r16,r16,-10396
 820600c:	003aa606 	br	8204aa8 <___svfprintf_internal_r+0x500>
 8206010:	d9003917 	ldw	r4,228(sp)
 8206014:	04001004 	movi	r16,64
 8206018:	800b883a 	mov	r5,r16
 820601c:	820ba380 	call	820ba38 <_malloc_r>
 8206020:	d9002c17 	ldw	r4,176(sp)
 8206024:	20800015 	stw	r2,0(r4)
 8206028:	20800415 	stw	r2,16(r4)
 820602c:	1001cb26 	beq	r2,zero,820675c <___svfprintf_internal_r+0x21b4>
 8206030:	d8802c17 	ldw	r2,176(sp)
 8206034:	14000515 	stw	r16,20(r2)
 8206038:	00397606 	br	8204614 <___svfprintf_internal_r+0x6c>
 820603c:	04020974 	movhi	r16,2085
 8206040:	8435db04 	addi	r16,r16,-10388
 8206044:	003ee106 	br	8205bcc <___svfprintf_internal_r+0x1624>
 8206048:	d9402c17 	ldw	r5,176(sp)
 820604c:	d9801e04 	addi	r6,sp,120
 8206050:	9809883a 	mov	r4,r19
 8206054:	820ddd40 	call	820ddd4 <__ssprint_r>
 8206058:	103a381e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 820605c:	dc402617 	ldw	r17,152(sp)
 8206060:	d8c02017 	ldw	r3,128(sp)
 8206064:	da000404 	addi	r8,sp,16
 8206068:	003f4306 	br	8205d78 <___svfprintf_internal_r+0x17d0>
 820606c:	01400184 	movi	r5,6
 8206070:	d9402915 	stw	r5,164(sp)
 8206074:	003f9506 	br	8205ecc <___svfprintf_internal_r+0x1924>
 8206078:	d9002d17 	ldw	r4,180(sp)
 820607c:	25000017 	ldw	r20,0(r4)
 8206080:	21000104 	addi	r4,r4,4
 8206084:	d9002d15 	stw	r4,180(sp)
 8206088:	a02dd7fa 	srai	r22,r20,31
 820608c:	b005883a 	mov	r2,r22
 8206090:	003a9b06 	br	8204b00 <___svfprintf_internal_r+0x558>
 8206094:	d9402d17 	ldw	r5,180(sp)
 8206098:	002d883a 	mov	r22,zero
 820609c:	2d000017 	ldw	r20,0(r5)
 82060a0:	29400104 	addi	r5,r5,4
 82060a4:	d9402d15 	stw	r5,180(sp)
 82060a8:	003bf906 	br	8205090 <___svfprintf_internal_r+0xae8>
 82060ac:	9480100c 	andi	r18,r18,64
 82060b0:	90006e26 	beq	r18,zero,820626c <___svfprintf_internal_r+0x1cc4>
 82060b4:	d9002d17 	ldw	r4,180(sp)
 82060b8:	d9402f17 	ldw	r5,188(sp)
 82060bc:	20800017 	ldw	r2,0(r4)
 82060c0:	21000104 	addi	r4,r4,4
 82060c4:	d9002d15 	stw	r4,180(sp)
 82060c8:	1140000d 	sth	r5,0(r2)
 82060cc:	00396106 	br	8204654 <___svfprintf_internal_r+0xac>
 82060d0:	d9402c17 	ldw	r5,176(sp)
 82060d4:	d9801e04 	addi	r6,sp,120
 82060d8:	9809883a 	mov	r4,r19
 82060dc:	820ddd40 	call	820ddd4 <__ssprint_r>
 82060e0:	103a161e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82060e4:	d8c02017 	ldw	r3,128(sp)
 82060e8:	d8801f17 	ldw	r2,124(sp)
 82060ec:	da000404 	addi	r8,sp,16
 82060f0:	d9403317 	ldw	r5,204(sp)
 82060f4:	10800044 	addi	r2,r2,1
 82060f8:	44000015 	stw	r16,0(r8)
 82060fc:	28c7883a 	add	r3,r5,r3
 8206100:	003b7706 	br	8204ee0 <___svfprintf_internal_r+0x938>
 8206104:	8009883a 	mov	r4,r16
 8206108:	da003e15 	stw	r8,248(sp)
 820610c:	8203cac0 	call	8203cac <strlen>
 8206110:	d8802e15 	stw	r2,184(sp)
 8206114:	da003e17 	ldw	r8,248(sp)
 8206118:	103c280e 	bge	r2,zero,82051bc <___svfprintf_internal_r+0xc14>
 820611c:	0005883a 	mov	r2,zero
 8206120:	003c2606 	br	82051bc <___svfprintf_internal_r+0xc14>
 8206124:	00bfffc4 	movi	r2,-1
 8206128:	003a0906 	br	8204950 <___svfprintf_internal_r+0x3a8>
 820612c:	01020974 	movhi	r4,2085
 8206130:	2135ed84 	addi	r4,r4,-10314
 8206134:	d9003515 	stw	r4,212(sp)
 8206138:	003b0606 	br	8204d54 <___svfprintf_internal_r+0x7ac>
 820613c:	013fffc4 	movi	r4,-1
 8206140:	003a2706 	br	82049e0 <___svfprintf_internal_r+0x438>
 8206144:	d9402c17 	ldw	r5,176(sp)
 8206148:	d9801e04 	addi	r6,sp,120
 820614c:	9809883a 	mov	r4,r19
 8206150:	820ddd40 	call	820ddd4 <__ssprint_r>
 8206154:	1039f91e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8206158:	d8c02017 	ldw	r3,128(sp)
 820615c:	da000404 	addi	r8,sp,16
 8206160:	003d8406 	br	8205774 <___svfprintf_internal_r+0x11cc>
 8206164:	0023883a 	mov	r17,zero
 8206168:	003d8306 	br	8205778 <___svfprintf_internal_r+0x11d0>
 820616c:	01020974 	movhi	r4,2085
 8206170:	2135e984 	addi	r4,r4,-10330
 8206174:	d9002b15 	stw	r4,172(sp)
 8206178:	d9002b17 	ldw	r4,172(sp)
 820617c:	1c47883a 	add	r3,r3,r17
 8206180:	10800044 	addi	r2,r2,1
 8206184:	41000015 	stw	r4,0(r8)
 8206188:	44400115 	stw	r17,4(r8)
 820618c:	d8c02015 	stw	r3,128(sp)
 8206190:	d8801f15 	stw	r2,124(sp)
 8206194:	010001c4 	movi	r4,7
 8206198:	20bfcd16 	blt	r4,r2,82060d0 <___svfprintf_internal_r+0x1b28>
 820619c:	42000204 	addi	r8,r8,8
 82061a0:	003fd306 	br	82060f0 <___svfprintf_internal_r+0x1b48>
 82061a4:	d9402c17 	ldw	r5,176(sp)
 82061a8:	d9801e04 	addi	r6,sp,120
 82061ac:	9809883a 	mov	r4,r19
 82061b0:	820ddd40 	call	820ddd4 <__ssprint_r>
 82061b4:	1039e11e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82061b8:	d8802617 	ldw	r2,152(sp)
 82061bc:	d8c02017 	ldw	r3,128(sp)
 82061c0:	da000404 	addi	r8,sp,16
 82061c4:	003e1c06 	br	8205a38 <___svfprintf_internal_r+0x1490>
 82061c8:	d8802917 	ldw	r2,164(sp)
 82061cc:	00c00184 	movi	r3,6
 82061d0:	1880012e 	bgeu	r3,r2,82061d8 <___svfprintf_internal_r+0x1c30>
 82061d4:	1805883a 	mov	r2,r3
 82061d8:	d8802e15 	stw	r2,184(sp)
 82061dc:	1000f316 	blt	r2,zero,82065ac <___svfprintf_internal_r+0x2004>
 82061e0:	04020974 	movhi	r16,2085
 82061e4:	d8802a15 	stw	r2,168(sp)
 82061e8:	dd002d15 	stw	r20,180(sp)
 82061ec:	d8002915 	stw	zero,164(sp)
 82061f0:	d8003215 	stw	zero,200(sp)
 82061f4:	8435e704 	addi	r16,r16,-10340
 82061f8:	0039883a 	mov	fp,zero
 82061fc:	003a9f06 	br	8204c7c <___svfprintf_internal_r+0x6d4>
 8206200:	01020974 	movhi	r4,2085
 8206204:	2135ed84 	addi	r4,r4,-10314
 8206208:	d9003515 	stw	r4,212(sp)
 820620c:	003b5f06 	br	8204f8c <___svfprintf_internal_r+0x9e4>
 8206210:	d9402c17 	ldw	r5,176(sp)
 8206214:	d9801e04 	addi	r6,sp,120
 8206218:	9809883a 	mov	r4,r19
 820621c:	820ddd40 	call	820ddd4 <__ssprint_r>
 8206220:	1039c61e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 8206224:	d8802617 	ldw	r2,152(sp)
 8206228:	d9403317 	ldw	r5,204(sp)
 820622c:	d8c02017 	ldw	r3,128(sp)
 8206230:	da000404 	addi	r8,sp,16
 8206234:	2885c83a 	sub	r2,r5,r2
 8206238:	003e1006 	br	8205a7c <___svfprintf_internal_r+0x14d4>
 820623c:	00800044 	movi	r2,1
 8206240:	10803fcc 	andi	r2,r2,255
 8206244:	00c00044 	movi	r3,1
 8206248:	10fa3526 	beq	r2,r3,8204b20 <___svfprintf_internal_r+0x578>
 820624c:	00c00084 	movi	r3,2
 8206250:	10fb9e26 	beq	r2,r3,82050cc <___svfprintf_internal_r+0xb24>
 8206254:	003a6406 	br	8204be8 <___svfprintf_internal_r+0x640>
 8206258:	0021883a 	mov	r16,zero
 820625c:	003e0806 	br	8205a80 <___svfprintf_internal_r+0x14d8>
 8206260:	07000b44 	movi	fp,45
 8206264:	df002785 	stb	fp,158(sp)
 8206268:	003a0b06 	br	8204a98 <___svfprintf_internal_r+0x4f0>
 820626c:	d8c02d17 	ldw	r3,180(sp)
 8206270:	d9002f17 	ldw	r4,188(sp)
 8206274:	18800017 	ldw	r2,0(r3)
 8206278:	18c00104 	addi	r3,r3,4
 820627c:	d8c02d15 	stw	r3,180(sp)
 8206280:	11000015 	stw	r4,0(r2)
 8206284:	0038f306 	br	8204654 <___svfprintf_internal_r+0xac>
 8206288:	00c00b44 	movi	r3,45
 820628c:	d8c02785 	stb	r3,158(sp)
 8206290:	d8802a15 	stw	r2,168(sp)
 8206294:	dc802b17 	ldw	r18,172(sp)
 8206298:	d8002915 	stw	zero,164(sp)
 820629c:	07000b44 	movi	fp,45
 82062a0:	003a7306 	br	8204c70 <___svfprintf_internal_r+0x6c8>
 82062a4:	9080004c 	andi	r2,r18,1
 82062a8:	1000941e 	bne	r2,zero,82064fc <___svfprintf_internal_r+0x1f54>
 82062ac:	d8802117 	ldw	r2,132(sp)
 82062b0:	1405c83a 	sub	r2,r2,r16
 82062b4:	d8803315 	stw	r2,204(sp)
 82062b8:	b441161e 	bne	r22,r17,8206714 <___svfprintf_internal_r+0x216c>
 82062bc:	dd802617 	ldw	r22,152(sp)
 82062c0:	00bfff44 	movi	r2,-3
 82062c4:	b0801a16 	blt	r22,r2,8206330 <___svfprintf_internal_r+0x1d88>
 82062c8:	d9402917 	ldw	r5,164(sp)
 82062cc:	2d801816 	blt	r5,r22,8206330 <___svfprintf_internal_r+0x1d88>
 82062d0:	dd803215 	stw	r22,200(sp)
 82062d4:	003f3a06 	br	8205fc0 <___svfprintf_internal_r+0x1a18>
 82062d8:	1025883a 	mov	r18,r2
 82062dc:	0039883a 	mov	fp,zero
 82062e0:	00800084 	movi	r2,2
 82062e4:	003fd606 	br	8206240 <___svfprintf_internal_r+0x1c98>
 82062e8:	9080004c 	andi	r2,r18,1
 82062ec:	103f191e 	bne	r2,zero,8205f54 <___svfprintf_internal_r+0x19ac>
 82062f0:	d8802117 	ldw	r2,132(sp)
 82062f4:	003f2806 	br	8205f98 <___svfprintf_internal_r+0x19f0>
 82062f8:	01020974 	movhi	r4,2085
 82062fc:	2135e984 	addi	r4,r4,-10330
 8206300:	d9002b15 	stw	r4,172(sp)
 8206304:	003c7c06 	br	82054f8 <___svfprintf_internal_r+0xf50>
 8206308:	e005883a 	mov	r2,fp
 820630c:	003f2206 	br	8205f98 <___svfprintf_internal_r+0x19f0>
 8206310:	d9402917 	ldw	r5,164(sp)
 8206314:	df002783 	ldbu	fp,158(sp)
 8206318:	dd002d15 	stw	r20,180(sp)
 820631c:	d9402a15 	stw	r5,168(sp)
 8206320:	d9402e15 	stw	r5,184(sp)
 8206324:	d8002915 	stw	zero,164(sp)
 8206328:	d8003215 	stw	zero,200(sp)
 820632c:	003a4c06 	br	8204c60 <___svfprintf_internal_r+0x6b8>
 8206330:	8c7fff84 	addi	r17,r17,-2
 8206334:	b5bfffc4 	addi	r22,r22,-1
 8206338:	dd802615 	stw	r22,152(sp)
 820633c:	dc4022c5 	stb	r17,139(sp)
 8206340:	b000c316 	blt	r22,zero,8206650 <___svfprintf_internal_r+0x20a8>
 8206344:	00800ac4 	movi	r2,43
 8206348:	d8802305 	stb	r2,140(sp)
 820634c:	00800244 	movi	r2,9
 8206350:	15806e16 	blt	r2,r22,820650c <___svfprintf_internal_r+0x1f64>
 8206354:	00800c04 	movi	r2,48
 8206358:	b5800c04 	addi	r22,r22,48
 820635c:	d8802345 	stb	r2,141(sp)
 8206360:	dd802385 	stb	r22,142(sp)
 8206364:	d88023c4 	addi	r2,sp,143
 8206368:	df0022c4 	addi	fp,sp,139
 820636c:	d8c03317 	ldw	r3,204(sp)
 8206370:	1739c83a 	sub	fp,r2,fp
 8206374:	d9003317 	ldw	r4,204(sp)
 8206378:	e0c7883a 	add	r3,fp,r3
 820637c:	df003b15 	stw	fp,236(sp)
 8206380:	d8c02e15 	stw	r3,184(sp)
 8206384:	00800044 	movi	r2,1
 8206388:	1100b70e 	bge	r2,r4,8206668 <___svfprintf_internal_r+0x20c0>
 820638c:	d8c02e17 	ldw	r3,184(sp)
 8206390:	18c00044 	addi	r3,r3,1
 8206394:	d8c02e15 	stw	r3,184(sp)
 8206398:	1805883a 	mov	r2,r3
 820639c:	1800b016 	blt	r3,zero,8206660 <___svfprintf_internal_r+0x20b8>
 82063a0:	d8003215 	stw	zero,200(sp)
 82063a4:	003f1006 	br	8205fe8 <___svfprintf_internal_r+0x1a40>
 82063a8:	d8802917 	ldw	r2,164(sp)
 82063ac:	103ec71e 	bne	r2,zero,8205ecc <___svfprintf_internal_r+0x1924>
 82063b0:	dc002915 	stw	r16,164(sp)
 82063b4:	003ec506 	br	8205ecc <___svfprintf_internal_r+0x1924>
 82063b8:	d9402c17 	ldw	r5,176(sp)
 82063bc:	d9801e04 	addi	r6,sp,120
 82063c0:	9809883a 	mov	r4,r19
 82063c4:	820ddd40 	call	820ddd4 <__ssprint_r>
 82063c8:	10395c1e 	bne	r2,zero,820493c <___svfprintf_internal_r+0x394>
 82063cc:	dc402617 	ldw	r17,152(sp)
 82063d0:	d8c02017 	ldw	r3,128(sp)
 82063d4:	d8801f17 	ldw	r2,124(sp)
 82063d8:	da000404 	addi	r8,sp,16
 82063dc:	003e7706 	br	8205dbc <___svfprintf_internal_r+0x1814>
 82063e0:	582f883a 	mov	r23,r11
 82063e4:	d8002915 	stw	zero,164(sp)
 82063e8:	0038c406 	br	82046fc <___svfprintf_internal_r+0x154>
 82063ec:	d8c02917 	ldw	r3,164(sp)
 82063f0:	d8802104 	addi	r2,sp,132
 82063f4:	d8800315 	stw	r2,12(sp)
 82063f8:	d9403617 	ldw	r5,216(sp)
 82063fc:	d8802504 	addi	r2,sp,148
 8206400:	d8800215 	stw	r2,8(sp)
 8206404:	d8802604 	addi	r2,sp,152
 8206408:	d8c00015 	stw	r3,0(sp)
 820640c:	9809883a 	mov	r4,r19
 8206410:	d8800115 	stw	r2,4(sp)
 8206414:	01c000c4 	movi	r7,3
 8206418:	a00d883a 	mov	r6,r20
 820641c:	da003e15 	stw	r8,248(sp)
 8206420:	8208f040 	call	8208f04 <_dtoa_r>
 8206424:	d9002917 	ldw	r4,164(sp)
 8206428:	da003e17 	ldw	r8,248(sp)
 820642c:	1021883a 	mov	r16,r2
 8206430:	1139883a 	add	fp,r2,r4
 8206434:	2007883a 	mov	r3,r4
 8206438:	81000007 	ldb	r4,0(r16)
 820643c:	00800c04 	movi	r2,48
 8206440:	20806f26 	beq	r4,r2,8206600 <___svfprintf_internal_r+0x2058>
 8206444:	d8c02617 	ldw	r3,152(sp)
 8206448:	e0f9883a 	add	fp,fp,r3
 820644c:	003ec206 	br	8205f58 <___svfprintf_internal_r+0x19b0>
 8206450:	00c00b44 	movi	r3,45
 8206454:	2520003c 	xorhi	r20,r4,32768
 8206458:	d8c02a05 	stb	r3,168(sp)
 820645c:	003ea106 	br	8205ee4 <___svfprintf_internal_r+0x193c>
 8206460:	d8c03217 	ldw	r3,200(sp)
 8206464:	00c0890e 	bge	zero,r3,820668c <___svfprintf_internal_r+0x20e4>
 8206468:	00800044 	movi	r2,1
 820646c:	d9003317 	ldw	r4,204(sp)
 8206470:	1105883a 	add	r2,r2,r4
 8206474:	d8802e15 	stw	r2,184(sp)
 8206478:	10005f16 	blt	r2,zero,82065f8 <___svfprintf_internal_r+0x2050>
 820647c:	044019c4 	movi	r17,103
 8206480:	003ed906 	br	8205fe8 <___svfprintf_internal_r+0x1a40>
 8206484:	d9002917 	ldw	r4,164(sp)
 8206488:	20c00044 	addi	r3,r4,1
 820648c:	003e9c06 	br	8205f00 <___svfprintf_internal_r+0x1958>
 8206490:	d9002917 	ldw	r4,164(sp)
 8206494:	00c0680e 	bge	zero,r3,8206638 <___svfprintf_internal_r+0x2090>
 8206498:	2000461e 	bne	r4,zero,82065b4 <___svfprintf_internal_r+0x200c>
 820649c:	9480004c 	andi	r18,r18,1
 82064a0:	9000441e 	bne	r18,zero,82065b4 <___svfprintf_internal_r+0x200c>
 82064a4:	1805883a 	mov	r2,r3
 82064a8:	1800a016 	blt	r3,zero,820672c <___svfprintf_internal_r+0x2184>
 82064ac:	d8c03217 	ldw	r3,200(sp)
 82064b0:	d8c02e15 	stw	r3,184(sp)
 82064b4:	003ecc06 	br	8205fe8 <___svfprintf_internal_r+0x1a40>
 82064b8:	d9402917 	ldw	r5,164(sp)
 82064bc:	d8802104 	addi	r2,sp,132
 82064c0:	d8800315 	stw	r2,12(sp)
 82064c4:	d9400015 	stw	r5,0(sp)
 82064c8:	d8802504 	addi	r2,sp,148
 82064cc:	d9403617 	ldw	r5,216(sp)
 82064d0:	d8800215 	stw	r2,8(sp)
 82064d4:	d8802604 	addi	r2,sp,152
 82064d8:	d8800115 	stw	r2,4(sp)
 82064dc:	01c000c4 	movi	r7,3
 82064e0:	a00d883a 	mov	r6,r20
 82064e4:	9809883a 	mov	r4,r19
 82064e8:	da003e15 	stw	r8,248(sp)
 82064ec:	8208f040 	call	8208f04 <_dtoa_r>
 82064f0:	d8c02917 	ldw	r3,164(sp)
 82064f4:	da003e17 	ldw	r8,248(sp)
 82064f8:	1021883a 	mov	r16,r2
 82064fc:	00801184 	movi	r2,70
 8206500:	80f9883a 	add	fp,r16,r3
 8206504:	88bfcc26 	beq	r17,r2,8206438 <___svfprintf_internal_r+0x1e90>
 8206508:	003e9306 	br	8205f58 <___svfprintf_internal_r+0x19b0>
 820650c:	df0022c4 	addi	fp,sp,139
 8206510:	dc002915 	stw	r16,164(sp)
 8206514:	9829883a 	mov	r20,r19
 8206518:	e021883a 	mov	r16,fp
 820651c:	4027883a 	mov	r19,r8
 8206520:	b009883a 	mov	r4,r22
 8206524:	01400284 	movi	r5,10
 8206528:	82028e80 	call	82028e8 <__modsi3>
 820652c:	10800c04 	addi	r2,r2,48
 8206530:	843fffc4 	addi	r16,r16,-1
 8206534:	b009883a 	mov	r4,r22
 8206538:	01400284 	movi	r5,10
 820653c:	80800005 	stb	r2,0(r16)
 8206540:	82028640 	call	8202864 <__divsi3>
 8206544:	102d883a 	mov	r22,r2
 8206548:	00800244 	movi	r2,9
 820654c:	15bff416 	blt	r2,r22,8206520 <___svfprintf_internal_r+0x1f78>
 8206550:	9811883a 	mov	r8,r19
 8206554:	b0800c04 	addi	r2,r22,48
 8206558:	a027883a 	mov	r19,r20
 820655c:	8029883a 	mov	r20,r16
 8206560:	a17fffc4 	addi	r5,r20,-1
 8206564:	a0bfffc5 	stb	r2,-1(r20)
 8206568:	dc002917 	ldw	r16,164(sp)
 820656c:	2f00752e 	bgeu	r5,fp,8206744 <___svfprintf_internal_r+0x219c>
 8206570:	d9c02384 	addi	r7,sp,142
 8206574:	3d0fc83a 	sub	r7,r7,r20
 8206578:	d9002344 	addi	r4,sp,141
 820657c:	e1cf883a 	add	r7,fp,r7
 8206580:	00000106 	br	8206588 <___svfprintf_internal_r+0x1fe0>
 8206584:	28800003 	ldbu	r2,0(r5)
 8206588:	20800005 	stb	r2,0(r4)
 820658c:	21000044 	addi	r4,r4,1
 8206590:	29400044 	addi	r5,r5,1
 8206594:	21fffb1e 	bne	r4,r7,8206584 <___svfprintf_internal_r+0x1fdc>
 8206598:	d8802304 	addi	r2,sp,140
 820659c:	1505c83a 	sub	r2,r2,r20
 82065a0:	d8c02344 	addi	r3,sp,141
 82065a4:	1885883a 	add	r2,r3,r2
 82065a8:	003f7006 	br	820636c <___svfprintf_internal_r+0x1dc4>
 82065ac:	0005883a 	mov	r2,zero
 82065b0:	003f0b06 	br	82061e0 <___svfprintf_internal_r+0x1c38>
 82065b4:	d9002917 	ldw	r4,164(sp)
 82065b8:	d8c03217 	ldw	r3,200(sp)
 82065bc:	20800044 	addi	r2,r4,1
 82065c0:	1885883a 	add	r2,r3,r2
 82065c4:	d8802e15 	stw	r2,184(sp)
 82065c8:	103e870e 	bge	r2,zero,8205fe8 <___svfprintf_internal_r+0x1a40>
 82065cc:	0005883a 	mov	r2,zero
 82065d0:	003e8506 	br	8205fe8 <___svfprintf_internal_r+0x1a40>
 82065d4:	01020974 	movhi	r4,2085
 82065d8:	2135e984 	addi	r4,r4,-10330
 82065dc:	d9002b15 	stw	r4,172(sp)
 82065e0:	003cc506 	br	82058f8 <___svfprintf_internal_r+0x1350>
 82065e4:	d8c03217 	ldw	r3,200(sp)
 82065e8:	18c00044 	addi	r3,r3,1
 82065ec:	d8c02e15 	stw	r3,184(sp)
 82065f0:	1805883a 	mov	r2,r3
 82065f4:	183fa10e 	bge	r3,zero,820647c <___svfprintf_internal_r+0x1ed4>
 82065f8:	0005883a 	mov	r2,zero
 82065fc:	003f9f06 	br	820647c <___svfprintf_internal_r+0x1ed4>
 8206600:	d9003617 	ldw	r4,216(sp)
 8206604:	000d883a 	mov	r6,zero
 8206608:	000f883a 	mov	r7,zero
 820660c:	a00b883a 	mov	r5,r20
 8206610:	d8c03d15 	stw	r3,244(sp)
 8206614:	da003e15 	stw	r8,248(sp)
 8206618:	8212c480 	call	8212c48 <__eqdf2>
 820661c:	d8c03d17 	ldw	r3,244(sp)
 8206620:	da003e17 	ldw	r8,248(sp)
 8206624:	103f8726 	beq	r2,zero,8206444 <___svfprintf_internal_r+0x1e9c>
 8206628:	00800044 	movi	r2,1
 820662c:	10c7c83a 	sub	r3,r2,r3
 8206630:	d8c02615 	stw	r3,152(sp)
 8206634:	003f8406 	br	8206448 <___svfprintf_internal_r+0x1ea0>
 8206638:	20000e1e 	bne	r4,zero,8206674 <___svfprintf_internal_r+0x20cc>
 820663c:	9480004c 	andi	r18,r18,1
 8206640:	90000c1e 	bne	r18,zero,8206674 <___svfprintf_internal_r+0x20cc>
 8206644:	00800044 	movi	r2,1
 8206648:	d8802e15 	stw	r2,184(sp)
 820664c:	003e6606 	br	8205fe8 <___svfprintf_internal_r+0x1a40>
 8206650:	00800b44 	movi	r2,45
 8206654:	05adc83a 	sub	r22,zero,r22
 8206658:	d8802305 	stb	r2,140(sp)
 820665c:	003f3b06 	br	820634c <___svfprintf_internal_r+0x1da4>
 8206660:	0005883a 	mov	r2,zero
 8206664:	003f4e06 	br	82063a0 <___svfprintf_internal_r+0x1df8>
 8206668:	90a4703a 	and	r18,r18,r2
 820666c:	903f4a26 	beq	r18,zero,8206398 <___svfprintf_internal_r+0x1df0>
 8206670:	003f4606 	br	820638c <___svfprintf_internal_r+0x1de4>
 8206674:	d8c02917 	ldw	r3,164(sp)
 8206678:	18c00084 	addi	r3,r3,2
 820667c:	d8c02e15 	stw	r3,184(sp)
 8206680:	1805883a 	mov	r2,r3
 8206684:	183e580e 	bge	r3,zero,8205fe8 <___svfprintf_internal_r+0x1a40>
 8206688:	003fd006 	br	82065cc <___svfprintf_internal_r+0x2024>
 820668c:	00800084 	movi	r2,2
 8206690:	10c5c83a 	sub	r2,r2,r3
 8206694:	003f7506 	br	820646c <___svfprintf_internal_r+0x1ec4>
 8206698:	d8802d17 	ldw	r2,180(sp)
 820669c:	d9002d17 	ldw	r4,180(sp)
 82066a0:	bc400043 	ldbu	r17,1(r23)
 82066a4:	10800017 	ldw	r2,0(r2)
 82066a8:	582f883a 	mov	r23,r11
 82066ac:	d8802915 	stw	r2,164(sp)
 82066b0:	20800104 	addi	r2,r4,4
 82066b4:	d9002917 	ldw	r4,164(sp)
 82066b8:	d8802d15 	stw	r2,180(sp)
 82066bc:	203df00e 	bge	r4,zero,8205e80 <___svfprintf_internal_r+0x18d8>
 82066c0:	8c403fcc 	andi	r17,r17,255
 82066c4:	00bfffc4 	movi	r2,-1
 82066c8:	8c40201c 	xori	r17,r17,128
 82066cc:	d8802915 	stw	r2,164(sp)
 82066d0:	8c7fe004 	addi	r17,r17,-128
 82066d4:	00380806 	br	82046f8 <___svfprintf_internal_r+0x150>
 82066d8:	9080004c 	andi	r2,r18,1
 82066dc:	0039883a 	mov	fp,zero
 82066e0:	10000726 	beq	r2,zero,8206700 <___svfprintf_internal_r+0x2158>
 82066e4:	d8c02817 	ldw	r3,160(sp)
 82066e8:	dc001dc4 	addi	r16,sp,119
 82066ec:	00800c04 	movi	r2,48
 82066f0:	1c07c83a 	sub	r3,r3,r16
 82066f4:	d8801dc5 	stb	r2,119(sp)
 82066f8:	d8c02e15 	stw	r3,184(sp)
 82066fc:	00395206 	br	8204c48 <___svfprintf_internal_r+0x6a0>
 8206700:	d8002e15 	stw	zero,184(sp)
 8206704:	dc001e04 	addi	r16,sp,120
 8206708:	00394f06 	br	8204c48 <___svfprintf_internal_r+0x6a0>
 820670c:	0005883a 	mov	r2,zero
 8206710:	003e3206 	br	8205fdc <___svfprintf_internal_r+0x1a34>
 8206714:	dd802617 	ldw	r22,152(sp)
 8206718:	003f0606 	br	8206334 <___svfprintf_internal_r+0x1d8c>
 820671c:	d9c02785 	stb	r7,158(sp)
 8206720:	003a5106 	br	8205068 <___svfprintf_internal_r+0xac0>
 8206724:	d9c02785 	stb	r7,158(sp)
 8206728:	003a3706 	br	8205008 <___svfprintf_internal_r+0xa60>
 820672c:	0005883a 	mov	r2,zero
 8206730:	003f5e06 	br	82064ac <___svfprintf_internal_r+0x1f04>
 8206734:	d9c02785 	stb	r7,158(sp)
 8206738:	00391706 	br	8204b98 <___svfprintf_internal_r+0x5f0>
 820673c:	d9c02785 	stb	r7,158(sp)
 8206740:	0038e606 	br	8204adc <___svfprintf_internal_r+0x534>
 8206744:	d8802344 	addi	r2,sp,141
 8206748:	003f0806 	br	820636c <___svfprintf_internal_r+0x1dc4>
 820674c:	d9c02785 	stb	r7,158(sp)
 8206750:	0038b706 	br	8204a30 <___svfprintf_internal_r+0x488>
 8206754:	d9c02785 	stb	r7,158(sp)
 8206758:	003adc06 	br	82052cc <___svfprintf_internal_r+0xd24>
 820675c:	d9403917 	ldw	r5,228(sp)
 8206760:	00800304 	movi	r2,12
 8206764:	28800015 	stw	r2,0(r5)
 8206768:	00bfffc4 	movi	r2,-1
 820676c:	00387806 	br	8204950 <___svfprintf_internal_r+0x3a8>
 8206770:	d9c02785 	stb	r7,158(sp)
 8206774:	003abf06 	br	8205274 <___svfprintf_internal_r+0xccc>
 8206778:	d9c02785 	stb	r7,158(sp)
 820677c:	003a9b06 	br	82051ec <___svfprintf_internal_r+0xc44>

08206780 <_user_strerror>:
 8206780:	0005883a 	mov	r2,zero
 8206784:	f800283a 	ret

08206788 <___vfprintf_internal_r>:
 8206788:	deffb804 	addi	sp,sp,-288
 820678c:	dfc04715 	stw	ra,284(sp)
 8206790:	ddc04515 	stw	r23,276(sp)
 8206794:	dd404315 	stw	r21,268(sp)
 8206798:	d9002c15 	stw	r4,176(sp)
 820679c:	282f883a 	mov	r23,r5
 82067a0:	302b883a 	mov	r21,r6
 82067a4:	d9c02d15 	stw	r7,180(sp)
 82067a8:	df004615 	stw	fp,280(sp)
 82067ac:	dd804415 	stw	r22,272(sp)
 82067b0:	dd004215 	stw	r20,264(sp)
 82067b4:	dcc04115 	stw	r19,260(sp)
 82067b8:	dc804015 	stw	r18,256(sp)
 82067bc:	dc403f15 	stw	r17,252(sp)
 82067c0:	dc003e15 	stw	r16,248(sp)
 82067c4:	820b84c0 	call	820b84c <_localeconv_r>
 82067c8:	10800017 	ldw	r2,0(r2)
 82067cc:	1009883a 	mov	r4,r2
 82067d0:	d8803415 	stw	r2,208(sp)
 82067d4:	8203cac0 	call	8203cac <strlen>
 82067d8:	d8803715 	stw	r2,220(sp)
 82067dc:	d8802c17 	ldw	r2,176(sp)
 82067e0:	10000226 	beq	r2,zero,82067ec <___vfprintf_internal_r+0x64>
 82067e4:	10800e17 	ldw	r2,56(r2)
 82067e8:	1000f926 	beq	r2,zero,8206bd0 <___vfprintf_internal_r+0x448>
 82067ec:	b880030b 	ldhu	r2,12(r23)
 82067f0:	10c8000c 	andi	r3,r2,8192
 82067f4:	1800061e 	bne	r3,zero,8206810 <___vfprintf_internal_r+0x88>
 82067f8:	b9001917 	ldw	r4,100(r23)
 82067fc:	00f7ffc4 	movi	r3,-8193
 8206800:	10880014 	ori	r2,r2,8192
 8206804:	20c6703a 	and	r3,r4,r3
 8206808:	b880030d 	sth	r2,12(r23)
 820680c:	b8c01915 	stw	r3,100(r23)
 8206810:	10c0020c 	andi	r3,r2,8
 8206814:	1800c126 	beq	r3,zero,8206b1c <___vfprintf_internal_r+0x394>
 8206818:	b8c00417 	ldw	r3,16(r23)
 820681c:	1800bf26 	beq	r3,zero,8206b1c <___vfprintf_internal_r+0x394>
 8206820:	1080068c 	andi	r2,r2,26
 8206824:	00c00284 	movi	r3,10
 8206828:	10c0c426 	beq	r2,r3,8206b3c <___vfprintf_internal_r+0x3b4>
 820682c:	d8c00404 	addi	r3,sp,16
 8206830:	05020974 	movhi	r20,2085
 8206834:	d9001e04 	addi	r4,sp,120
 8206838:	a535f184 	addi	r20,r20,-10298
 820683c:	d8c01e15 	stw	r3,120(sp)
 8206840:	d8002015 	stw	zero,128(sp)
 8206844:	d8001f15 	stw	zero,124(sp)
 8206848:	d8003315 	stw	zero,204(sp)
 820684c:	d8003615 	stw	zero,216(sp)
 8206850:	d8003815 	stw	zero,224(sp)
 8206854:	1811883a 	mov	r8,r3
 8206858:	d8003915 	stw	zero,228(sp)
 820685c:	d8003a15 	stw	zero,232(sp)
 8206860:	d8002f15 	stw	zero,188(sp)
 8206864:	d9002815 	stw	r4,160(sp)
 8206868:	a8800007 	ldb	r2,0(r21)
 820686c:	10027b26 	beq	r2,zero,820725c <___vfprintf_internal_r+0xad4>
 8206870:	00c00944 	movi	r3,37
 8206874:	a821883a 	mov	r16,r21
 8206878:	10c0021e 	bne	r2,r3,8206884 <___vfprintf_internal_r+0xfc>
 820687c:	00001406 	br	82068d0 <___vfprintf_internal_r+0x148>
 8206880:	10c00326 	beq	r2,r3,8206890 <___vfprintf_internal_r+0x108>
 8206884:	84000044 	addi	r16,r16,1
 8206888:	80800007 	ldb	r2,0(r16)
 820688c:	103ffc1e 	bne	r2,zero,8206880 <___vfprintf_internal_r+0xf8>
 8206890:	8563c83a 	sub	r17,r16,r21
 8206894:	88000e26 	beq	r17,zero,82068d0 <___vfprintf_internal_r+0x148>
 8206898:	d8c02017 	ldw	r3,128(sp)
 820689c:	d8801f17 	ldw	r2,124(sp)
 82068a0:	45400015 	stw	r21,0(r8)
 82068a4:	1c47883a 	add	r3,r3,r17
 82068a8:	10800044 	addi	r2,r2,1
 82068ac:	d8c02015 	stw	r3,128(sp)
 82068b0:	44400115 	stw	r17,4(r8)
 82068b4:	d8801f15 	stw	r2,124(sp)
 82068b8:	00c001c4 	movi	r3,7
 82068bc:	1880a716 	blt	r3,r2,8206b5c <___vfprintf_internal_r+0x3d4>
 82068c0:	42000204 	addi	r8,r8,8
 82068c4:	d9402f17 	ldw	r5,188(sp)
 82068c8:	2c4b883a 	add	r5,r5,r17
 82068cc:	d9402f15 	stw	r5,188(sp)
 82068d0:	80800007 	ldb	r2,0(r16)
 82068d4:	1000a826 	beq	r2,zero,8206b78 <___vfprintf_internal_r+0x3f0>
 82068d8:	84400047 	ldb	r17,1(r16)
 82068dc:	00bfffc4 	movi	r2,-1
 82068e0:	85400044 	addi	r21,r16,1
 82068e4:	d8002785 	stb	zero,158(sp)
 82068e8:	0007883a 	mov	r3,zero
 82068ec:	000f883a 	mov	r7,zero
 82068f0:	d8802915 	stw	r2,164(sp)
 82068f4:	d8003115 	stw	zero,196(sp)
 82068f8:	0025883a 	mov	r18,zero
 82068fc:	01401604 	movi	r5,88
 8206900:	01800244 	movi	r6,9
 8206904:	02800a84 	movi	r10,42
 8206908:	02401b04 	movi	r9,108
 820690c:	ad400044 	addi	r21,r21,1
 8206910:	88bff804 	addi	r2,r17,-32
 8206914:	28830436 	bltu	r5,r2,8207528 <___vfprintf_internal_r+0xda0>
 8206918:	100490ba 	slli	r2,r2,2
 820691c:	01020834 	movhi	r4,2080
 8206920:	211a4c04 	addi	r4,r4,26928
 8206924:	1105883a 	add	r2,r2,r4
 8206928:	10800017 	ldw	r2,0(r2)
 820692c:	1000683a 	jmp	r2
 8206930:	08207448 	cmpgei	zero,at,-32303
 8206934:	08207528 	cmpgeui	zero,at,33236
 8206938:	08207528 	cmpgeui	zero,at,33236
 820693c:	08207468 	cmpgeui	zero,at,33233
 8206940:	08207528 	cmpgeui	zero,at,33236
 8206944:	08207528 	cmpgeui	zero,at,33236
 8206948:	08207528 	cmpgeui	zero,at,33236
 820694c:	08207528 	cmpgeui	zero,at,33236
 8206950:	08207528 	cmpgeui	zero,at,33236
 8206954:	08207528 	cmpgeui	zero,at,33236
 8206958:	08206bdc 	xori	zero,at,33199
 820695c:	08207384 	addi	zero,at,-32306
 8206960:	08207528 	cmpgeui	zero,at,33236
 8206964:	08206aa4 	muli	zero,at,-32342
 8206968:	08206c04 	addi	zero,at,-32336
 820696c:	08207528 	cmpgeui	zero,at,33236
 8206970:	08206c44 	addi	zero,at,-32335
 8206974:	08206c50 	cmplti	zero,at,-32335
 8206978:	08206c50 	cmplti	zero,at,-32335
 820697c:	08206c50 	cmplti	zero,at,-32335
 8206980:	08206c50 	cmplti	zero,at,-32335
 8206984:	08206c50 	cmplti	zero,at,-32335
 8206988:	08206c50 	cmplti	zero,at,-32335
 820698c:	08206c50 	cmplti	zero,at,-32335
 8206990:	08206c50 	cmplti	zero,at,-32335
 8206994:	08206c50 	cmplti	zero,at,-32335
 8206998:	08207528 	cmpgeui	zero,at,33236
 820699c:	08207528 	cmpgeui	zero,at,33236
 82069a0:	08207528 	cmpgeui	zero,at,33236
 82069a4:	08207528 	cmpgeui	zero,at,33236
 82069a8:	08207528 	cmpgeui	zero,at,33236
 82069ac:	08207528 	cmpgeui	zero,at,33236
 82069b0:	08207528 	cmpgeui	zero,at,33236
 82069b4:	08207528 	cmpgeui	zero,at,33236
 82069b8:	08207528 	cmpgeui	zero,at,33236
 82069bc:	08207528 	cmpgeui	zero,at,33236
 82069c0:	08206c84 	addi	zero,at,-32334
 82069c4:	08206d40 	call	8206d4 <OSCtxSw_SWITCH_PC+0x820694>
 82069c8:	08207528 	cmpgeui	zero,at,33236
 82069cc:	08206d40 	call	8206d4 <OSCtxSw_SWITCH_PC+0x820694>
 82069d0:	08207528 	cmpgeui	zero,at,33236
 82069d4:	08207528 	cmpgeui	zero,at,33236
 82069d8:	08207528 	cmpgeui	zero,at,33236
 82069dc:	08207528 	cmpgeui	zero,at,33236
 82069e0:	08206de0 	cmpeqi	zero,at,-32329
 82069e4:	08207528 	cmpgeui	zero,at,33236
 82069e8:	08207528 	cmpgeui	zero,at,33236
 82069ec:	08206dec 	andhi	zero,at,33207
 82069f0:	08207528 	cmpgeui	zero,at,33236
 82069f4:	08207528 	cmpgeui	zero,at,33236
 82069f8:	08207528 	cmpgeui	zero,at,33236
 82069fc:	08207528 	cmpgeui	zero,at,33236
 8206a00:	08207528 	cmpgeui	zero,at,33236
 8206a04:	08207264 	muli	zero,at,-32311
 8206a08:	08207528 	cmpgeui	zero,at,33236
 8206a0c:	08207528 	cmpgeui	zero,at,33236
 8206a10:	082072c4 	addi	zero,at,-32309
 8206a14:	08207528 	cmpgeui	zero,at,33236
 8206a18:	08207528 	cmpgeui	zero,at,33236
 8206a1c:	08207528 	cmpgeui	zero,at,33236
 8206a20:	08207528 	cmpgeui	zero,at,33236
 8206a24:	08207528 	cmpgeui	zero,at,33236
 8206a28:	08207528 	cmpgeui	zero,at,33236
 8206a2c:	08207528 	cmpgeui	zero,at,33236
 8206a30:	08207528 	cmpgeui	zero,at,33236
 8206a34:	08207528 	cmpgeui	zero,at,33236
 8206a38:	08207528 	cmpgeui	zero,at,33236
 8206a3c:	082074d4 	ori	zero,at,33235
 8206a40:	08207474 	orhi	zero,at,33233
 8206a44:	08206d40 	call	8206d4 <OSCtxSw_SWITCH_PC+0x820694>
 8206a48:	08206d40 	call	8206d4 <OSCtxSw_SWITCH_PC+0x820694>
 8206a4c:	08206d40 	call	8206d4 <OSCtxSw_SWITCH_PC+0x820694>
 8206a50:	08207484 	addi	zero,at,-32302
 8206a54:	08207474 	orhi	zero,at,33233
 8206a58:	08207528 	cmpgeui	zero,at,33236
 8206a5c:	08207528 	cmpgeui	zero,at,33236
 8206a60:	08207490 	cmplti	zero,at,-32302
 8206a64:	08207528 	cmpgeui	zero,at,33236
 8206a68:	082074a0 	cmpeqi	zero,at,-32302
 8206a6c:	08207374 	orhi	zero,at,33229
 8206a70:	08206ab0 	cmpltui	zero,at,33194
 8206a74:	08207394 	ori	zero,at,33230
 8206a78:	08207528 	cmpgeui	zero,at,33236
 8206a7c:	082073a0 	cmpeqi	zero,at,-32306
 8206a80:	08207528 	cmpgeui	zero,at,33236
 8206a84:	082073fc 	xorhi	zero,at,33231
 8206a88:	08207528 	cmpgeui	zero,at,33236
 8206a8c:	08207528 	cmpgeui	zero,at,33236
 8206a90:	0820740c 	andi	zero,at,33232
 8206a94:	d9003117 	ldw	r4,196(sp)
 8206a98:	d8802d15 	stw	r2,180(sp)
 8206a9c:	0109c83a 	sub	r4,zero,r4
 8206aa0:	d9003115 	stw	r4,196(sp)
 8206aa4:	94800114 	ori	r18,r18,4
 8206aa8:	ac400007 	ldb	r17,0(r21)
 8206aac:	003f9706 	br	820690c <___vfprintf_internal_r+0x184>
 8206ab0:	00800c04 	movi	r2,48
 8206ab4:	d9002d17 	ldw	r4,180(sp)
 8206ab8:	d9402917 	ldw	r5,164(sp)
 8206abc:	d8802705 	stb	r2,156(sp)
 8206ac0:	00801e04 	movi	r2,120
 8206ac4:	d8802745 	stb	r2,157(sp)
 8206ac8:	d8002785 	stb	zero,158(sp)
 8206acc:	20c00104 	addi	r3,r4,4
 8206ad0:	24c00017 	ldw	r19,0(r4)
 8206ad4:	002d883a 	mov	r22,zero
 8206ad8:	90800094 	ori	r2,r18,2
 8206adc:	28029a16 	blt	r5,zero,8207548 <___vfprintf_internal_r+0xdc0>
 8206ae0:	00bfdfc4 	movi	r2,-129
 8206ae4:	90a4703a 	and	r18,r18,r2
 8206ae8:	d8c02d15 	stw	r3,180(sp)
 8206aec:	94800094 	ori	r18,r18,2
 8206af0:	9802871e 	bne	r19,zero,8207510 <___vfprintf_internal_r+0xd88>
 8206af4:	00820974 	movhi	r2,2085
 8206af8:	10b5e204 	addi	r2,r2,-10360
 8206afc:	d8803915 	stw	r2,228(sp)
 8206b00:	04401e04 	movi	r17,120
 8206b04:	d8802917 	ldw	r2,164(sp)
 8206b08:	0039883a 	mov	fp,zero
 8206b0c:	1001e926 	beq	r2,zero,82072b4 <___vfprintf_internal_r+0xb2c>
 8206b10:	0027883a 	mov	r19,zero
 8206b14:	002d883a 	mov	r22,zero
 8206b18:	00020506 	br	8207330 <___vfprintf_internal_r+0xba8>
 8206b1c:	d9002c17 	ldw	r4,176(sp)
 8206b20:	b80b883a 	mov	r5,r23
 8206b24:	8208bb00 	call	8208bb0 <__swsetup_r>
 8206b28:	1005ac1e 	bne	r2,zero,82081dc <___vfprintf_internal_r+0x1a54>
 8206b2c:	b880030b 	ldhu	r2,12(r23)
 8206b30:	00c00284 	movi	r3,10
 8206b34:	1080068c 	andi	r2,r2,26
 8206b38:	10ff3c1e 	bne	r2,r3,820682c <___vfprintf_internal_r+0xa4>
 8206b3c:	b880038f 	ldh	r2,14(r23)
 8206b40:	103f3a16 	blt	r2,zero,820682c <___vfprintf_internal_r+0xa4>
 8206b44:	d9c02d17 	ldw	r7,180(sp)
 8206b48:	d9002c17 	ldw	r4,176(sp)
 8206b4c:	a80d883a 	mov	r6,r21
 8206b50:	b80b883a 	mov	r5,r23
 8206b54:	820899c0 	call	820899c <__sbprintf>
 8206b58:	00001106 	br	8206ba0 <___vfprintf_internal_r+0x418>
 8206b5c:	d9002c17 	ldw	r4,176(sp)
 8206b60:	d9801e04 	addi	r6,sp,120
 8206b64:	b80b883a 	mov	r5,r23
 8206b68:	820f2dc0 	call	820f2dc <__sprint_r>
 8206b6c:	1000081e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8206b70:	da000404 	addi	r8,sp,16
 8206b74:	003f5306 	br	82068c4 <___vfprintf_internal_r+0x13c>
 8206b78:	d8802017 	ldw	r2,128(sp)
 8206b7c:	10000426 	beq	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8206b80:	d9002c17 	ldw	r4,176(sp)
 8206b84:	d9801e04 	addi	r6,sp,120
 8206b88:	b80b883a 	mov	r5,r23
 8206b8c:	820f2dc0 	call	820f2dc <__sprint_r>
 8206b90:	b880030b 	ldhu	r2,12(r23)
 8206b94:	1080100c 	andi	r2,r2,64
 8206b98:	1005901e 	bne	r2,zero,82081dc <___vfprintf_internal_r+0x1a54>
 8206b9c:	d8802f17 	ldw	r2,188(sp)
 8206ba0:	dfc04717 	ldw	ra,284(sp)
 8206ba4:	df004617 	ldw	fp,280(sp)
 8206ba8:	ddc04517 	ldw	r23,276(sp)
 8206bac:	dd804417 	ldw	r22,272(sp)
 8206bb0:	dd404317 	ldw	r21,268(sp)
 8206bb4:	dd004217 	ldw	r20,264(sp)
 8206bb8:	dcc04117 	ldw	r19,260(sp)
 8206bbc:	dc804017 	ldw	r18,256(sp)
 8206bc0:	dc403f17 	ldw	r17,252(sp)
 8206bc4:	dc003e17 	ldw	r16,248(sp)
 8206bc8:	dec04804 	addi	sp,sp,288
 8206bcc:	f800283a 	ret
 8206bd0:	d9002c17 	ldw	r4,176(sp)
 8206bd4:	820ab840 	call	820ab84 <__sinit>
 8206bd8:	003f0406 	br	82067ec <___vfprintf_internal_r+0x64>
 8206bdc:	d8802d17 	ldw	r2,180(sp)
 8206be0:	d9002d17 	ldw	r4,180(sp)
 8206be4:	10800017 	ldw	r2,0(r2)
 8206be8:	d8803115 	stw	r2,196(sp)
 8206bec:	20800104 	addi	r2,r4,4
 8206bf0:	d9003117 	ldw	r4,196(sp)
 8206bf4:	203fa716 	blt	r4,zero,8206a94 <___vfprintf_internal_r+0x30c>
 8206bf8:	d8802d15 	stw	r2,180(sp)
 8206bfc:	ac400007 	ldb	r17,0(r21)
 8206c00:	003f4206 	br	820690c <___vfprintf_internal_r+0x184>
 8206c04:	ac400007 	ldb	r17,0(r21)
 8206c08:	aac00044 	addi	r11,r21,1
 8206c0c:	8a872826 	beq	r17,r10,82088b0 <___vfprintf_internal_r+0x2128>
 8206c10:	88bff404 	addi	r2,r17,-48
 8206c14:	0009883a 	mov	r4,zero
 8206c18:	30867d36 	bltu	r6,r2,8208610 <___vfprintf_internal_r+0x1e88>
 8206c1c:	5c400007 	ldb	r17,0(r11)
 8206c20:	210002a4 	muli	r4,r4,10
 8206c24:	5d400044 	addi	r21,r11,1
 8206c28:	a817883a 	mov	r11,r21
 8206c2c:	2089883a 	add	r4,r4,r2
 8206c30:	88bff404 	addi	r2,r17,-48
 8206c34:	30bff92e 	bgeu	r6,r2,8206c1c <___vfprintf_internal_r+0x494>
 8206c38:	2005c916 	blt	r4,zero,8208360 <___vfprintf_internal_r+0x1bd8>
 8206c3c:	d9002915 	stw	r4,164(sp)
 8206c40:	003f3306 	br	8206910 <___vfprintf_internal_r+0x188>
 8206c44:	94802014 	ori	r18,r18,128
 8206c48:	ac400007 	ldb	r17,0(r21)
 8206c4c:	003f2f06 	br	820690c <___vfprintf_internal_r+0x184>
 8206c50:	a809883a 	mov	r4,r21
 8206c54:	d8003115 	stw	zero,196(sp)
 8206c58:	88bff404 	addi	r2,r17,-48
 8206c5c:	0017883a 	mov	r11,zero
 8206c60:	24400007 	ldb	r17,0(r4)
 8206c64:	5ac002a4 	muli	r11,r11,10
 8206c68:	ad400044 	addi	r21,r21,1
 8206c6c:	a809883a 	mov	r4,r21
 8206c70:	12d7883a 	add	r11,r2,r11
 8206c74:	88bff404 	addi	r2,r17,-48
 8206c78:	30bff92e 	bgeu	r6,r2,8206c60 <___vfprintf_internal_r+0x4d8>
 8206c7c:	dac03115 	stw	r11,196(sp)
 8206c80:	003f2306 	br	8206910 <___vfprintf_internal_r+0x188>
 8206c84:	18c03fcc 	andi	r3,r3,255
 8206c88:	18072b1e 	bne	r3,zero,8208938 <___vfprintf_internal_r+0x21b0>
 8206c8c:	94800414 	ori	r18,r18,16
 8206c90:	9080080c 	andi	r2,r18,32
 8206c94:	10037b26 	beq	r2,zero,8207a84 <___vfprintf_internal_r+0x12fc>
 8206c98:	d9402d17 	ldw	r5,180(sp)
 8206c9c:	28800117 	ldw	r2,4(r5)
 8206ca0:	2cc00017 	ldw	r19,0(r5)
 8206ca4:	29400204 	addi	r5,r5,8
 8206ca8:	d9402d15 	stw	r5,180(sp)
 8206cac:	102d883a 	mov	r22,r2
 8206cb0:	10044b16 	blt	r2,zero,8207de0 <___vfprintf_internal_r+0x1658>
 8206cb4:	d9402917 	ldw	r5,164(sp)
 8206cb8:	df002783 	ldbu	fp,158(sp)
 8206cbc:	2803bc16 	blt	r5,zero,8207bb0 <___vfprintf_internal_r+0x1428>
 8206cc0:	00ffdfc4 	movi	r3,-129
 8206cc4:	9d84b03a 	or	r2,r19,r22
 8206cc8:	90e4703a 	and	r18,r18,r3
 8206ccc:	10017726 	beq	r2,zero,82072ac <___vfprintf_internal_r+0xb24>
 8206cd0:	b0038326 	beq	r22,zero,8207ae0 <___vfprintf_internal_r+0x1358>
 8206cd4:	dc402a15 	stw	r17,168(sp)
 8206cd8:	dc001e04 	addi	r16,sp,120
 8206cdc:	b023883a 	mov	r17,r22
 8206ce0:	402d883a 	mov	r22,r8
 8206ce4:	9809883a 	mov	r4,r19
 8206ce8:	880b883a 	mov	r5,r17
 8206cec:	01800284 	movi	r6,10
 8206cf0:	000f883a 	mov	r7,zero
 8206cf4:	821157c0 	call	821157c <__umoddi3>
 8206cf8:	10800c04 	addi	r2,r2,48
 8206cfc:	843fffc4 	addi	r16,r16,-1
 8206d00:	9809883a 	mov	r4,r19
 8206d04:	880b883a 	mov	r5,r17
 8206d08:	80800005 	stb	r2,0(r16)
 8206d0c:	01800284 	movi	r6,10
 8206d10:	000f883a 	mov	r7,zero
 8206d14:	82110040 	call	8211004 <__udivdi3>
 8206d18:	1027883a 	mov	r19,r2
 8206d1c:	10c4b03a 	or	r2,r2,r3
 8206d20:	1823883a 	mov	r17,r3
 8206d24:	103fef1e 	bne	r2,zero,8206ce4 <___vfprintf_internal_r+0x55c>
 8206d28:	d8c02817 	ldw	r3,160(sp)
 8206d2c:	dc402a17 	ldw	r17,168(sp)
 8206d30:	b011883a 	mov	r8,r22
 8206d34:	1c07c83a 	sub	r3,r3,r16
 8206d38:	d8c02e15 	stw	r3,184(sp)
 8206d3c:	00005906 	br	8206ea4 <___vfprintf_internal_r+0x71c>
 8206d40:	18c03fcc 	andi	r3,r3,255
 8206d44:	1806fa1e 	bne	r3,zero,8208930 <___vfprintf_internal_r+0x21a8>
 8206d48:	9080020c 	andi	r2,r18,8
 8206d4c:	10048a26 	beq	r2,zero,8207f78 <___vfprintf_internal_r+0x17f0>
 8206d50:	d8c02d17 	ldw	r3,180(sp)
 8206d54:	d9002d17 	ldw	r4,180(sp)
 8206d58:	d9402d17 	ldw	r5,180(sp)
 8206d5c:	18c00017 	ldw	r3,0(r3)
 8206d60:	21000117 	ldw	r4,4(r4)
 8206d64:	29400204 	addi	r5,r5,8
 8206d68:	d8c03615 	stw	r3,216(sp)
 8206d6c:	d9003815 	stw	r4,224(sp)
 8206d70:	d9402d15 	stw	r5,180(sp)
 8206d74:	d9003617 	ldw	r4,216(sp)
 8206d78:	d9403817 	ldw	r5,224(sp)
 8206d7c:	da003d15 	stw	r8,244(sp)
 8206d80:	04000044 	movi	r16,1
 8206d84:	820daf40 	call	820daf4 <__fpclassifyd>
 8206d88:	da003d17 	ldw	r8,244(sp)
 8206d8c:	14041f1e 	bne	r2,r16,8207e0c <___vfprintf_internal_r+0x1684>
 8206d90:	d9003617 	ldw	r4,216(sp)
 8206d94:	d9403817 	ldw	r5,224(sp)
 8206d98:	000d883a 	mov	r6,zero
 8206d9c:	000f883a 	mov	r7,zero
 8206da0:	8212dac0 	call	8212dac <__ledf2>
 8206da4:	da003d17 	ldw	r8,244(sp)
 8206da8:	1005be16 	blt	r2,zero,82084a4 <___vfprintf_internal_r+0x1d1c>
 8206dac:	df002783 	ldbu	fp,158(sp)
 8206db0:	008011c4 	movi	r2,71
 8206db4:	1445330e 	bge	r2,r17,8208284 <___vfprintf_internal_r+0x1afc>
 8206db8:	04020974 	movhi	r16,2085
 8206dbc:	8435da04 	addi	r16,r16,-10392
 8206dc0:	00c000c4 	movi	r3,3
 8206dc4:	00bfdfc4 	movi	r2,-129
 8206dc8:	d8c02a15 	stw	r3,168(sp)
 8206dcc:	90a4703a 	and	r18,r18,r2
 8206dd0:	d8c02e15 	stw	r3,184(sp)
 8206dd4:	d8002915 	stw	zero,164(sp)
 8206dd8:	d8003215 	stw	zero,200(sp)
 8206ddc:	00003706 	br	8206ebc <___vfprintf_internal_r+0x734>
 8206de0:	94800214 	ori	r18,r18,8
 8206de4:	ac400007 	ldb	r17,0(r21)
 8206de8:	003ec806 	br	820690c <___vfprintf_internal_r+0x184>
 8206dec:	18c03fcc 	andi	r3,r3,255
 8206df0:	1806db1e 	bne	r3,zero,8208960 <___vfprintf_internal_r+0x21d8>
 8206df4:	94800414 	ori	r18,r18,16
 8206df8:	9080080c 	andi	r2,r18,32
 8206dfc:	1002d826 	beq	r2,zero,8207960 <___vfprintf_internal_r+0x11d8>
 8206e00:	d9402d17 	ldw	r5,180(sp)
 8206e04:	d8c02917 	ldw	r3,164(sp)
 8206e08:	d8002785 	stb	zero,158(sp)
 8206e0c:	28800204 	addi	r2,r5,8
 8206e10:	2cc00017 	ldw	r19,0(r5)
 8206e14:	2d800117 	ldw	r22,4(r5)
 8206e18:	18048f16 	blt	r3,zero,8208058 <___vfprintf_internal_r+0x18d0>
 8206e1c:	013fdfc4 	movi	r4,-129
 8206e20:	9d86b03a 	or	r3,r19,r22
 8206e24:	d8802d15 	stw	r2,180(sp)
 8206e28:	9124703a 	and	r18,r18,r4
 8206e2c:	1802d91e 	bne	r3,zero,8207994 <___vfprintf_internal_r+0x120c>
 8206e30:	d8c02917 	ldw	r3,164(sp)
 8206e34:	0039883a 	mov	fp,zero
 8206e38:	1805c326 	beq	r3,zero,8208548 <___vfprintf_internal_r+0x1dc0>
 8206e3c:	0027883a 	mov	r19,zero
 8206e40:	002d883a 	mov	r22,zero
 8206e44:	dc001e04 	addi	r16,sp,120
 8206e48:	9806d0fa 	srli	r3,r19,3
 8206e4c:	b008977a 	slli	r4,r22,29
 8206e50:	b02cd0fa 	srli	r22,r22,3
 8206e54:	9cc001cc 	andi	r19,r19,7
 8206e58:	98800c04 	addi	r2,r19,48
 8206e5c:	843fffc4 	addi	r16,r16,-1
 8206e60:	20e6b03a 	or	r19,r4,r3
 8206e64:	80800005 	stb	r2,0(r16)
 8206e68:	9d86b03a 	or	r3,r19,r22
 8206e6c:	183ff61e 	bne	r3,zero,8206e48 <___vfprintf_internal_r+0x6c0>
 8206e70:	90c0004c 	andi	r3,r18,1
 8206e74:	18013b26 	beq	r3,zero,8207364 <___vfprintf_internal_r+0xbdc>
 8206e78:	10803fcc 	andi	r2,r2,255
 8206e7c:	1080201c 	xori	r2,r2,128
 8206e80:	10bfe004 	addi	r2,r2,-128
 8206e84:	00c00c04 	movi	r3,48
 8206e88:	10c13626 	beq	r2,r3,8207364 <___vfprintf_internal_r+0xbdc>
 8206e8c:	80ffffc5 	stb	r3,-1(r16)
 8206e90:	d8c02817 	ldw	r3,160(sp)
 8206e94:	80bfffc4 	addi	r2,r16,-1
 8206e98:	1021883a 	mov	r16,r2
 8206e9c:	1887c83a 	sub	r3,r3,r2
 8206ea0:	d8c02e15 	stw	r3,184(sp)
 8206ea4:	d8802e17 	ldw	r2,184(sp)
 8206ea8:	d9002917 	ldw	r4,164(sp)
 8206eac:	1100010e 	bge	r2,r4,8206eb4 <___vfprintf_internal_r+0x72c>
 8206eb0:	2005883a 	mov	r2,r4
 8206eb4:	d8802a15 	stw	r2,168(sp)
 8206eb8:	d8003215 	stw	zero,200(sp)
 8206ebc:	e7003fcc 	andi	fp,fp,255
 8206ec0:	e700201c 	xori	fp,fp,128
 8206ec4:	e73fe004 	addi	fp,fp,-128
 8206ec8:	e0000326 	beq	fp,zero,8206ed8 <___vfprintf_internal_r+0x750>
 8206ecc:	d8c02a17 	ldw	r3,168(sp)
 8206ed0:	18c00044 	addi	r3,r3,1
 8206ed4:	d8c02a15 	stw	r3,168(sp)
 8206ed8:	90c0008c 	andi	r3,r18,2
 8206edc:	d8c02b15 	stw	r3,172(sp)
 8206ee0:	18000326 	beq	r3,zero,8206ef0 <___vfprintf_internal_r+0x768>
 8206ee4:	d8c02a17 	ldw	r3,168(sp)
 8206ee8:	18c00084 	addi	r3,r3,2
 8206eec:	d8c02a15 	stw	r3,168(sp)
 8206ef0:	90c0210c 	andi	r3,r18,132
 8206ef4:	d8c03015 	stw	r3,192(sp)
 8206ef8:	1801a31e 	bne	r3,zero,8207588 <___vfprintf_internal_r+0xe00>
 8206efc:	d9003117 	ldw	r4,196(sp)
 8206f00:	d8c02a17 	ldw	r3,168(sp)
 8206f04:	20e7c83a 	sub	r19,r4,r3
 8206f08:	04c19f0e 	bge	zero,r19,8207588 <___vfprintf_internal_r+0xe00>
 8206f0c:	02400404 	movi	r9,16
 8206f10:	d8c02017 	ldw	r3,128(sp)
 8206f14:	d8801f17 	ldw	r2,124(sp)
 8206f18:	4cc50d0e 	bge	r9,r19,8208350 <___vfprintf_internal_r+0x1bc8>
 8206f1c:	01420974 	movhi	r5,2085
 8206f20:	2975f584 	addi	r5,r5,-10282
 8206f24:	dc403b15 	stw	r17,236(sp)
 8206f28:	d9403515 	stw	r5,212(sp)
 8206f2c:	9823883a 	mov	r17,r19
 8206f30:	482d883a 	mov	r22,r9
 8206f34:	9027883a 	mov	r19,r18
 8206f38:	070001c4 	movi	fp,7
 8206f3c:	8025883a 	mov	r18,r16
 8206f40:	dc002c17 	ldw	r16,176(sp)
 8206f44:	00000306 	br	8206f54 <___vfprintf_internal_r+0x7cc>
 8206f48:	8c7ffc04 	addi	r17,r17,-16
 8206f4c:	42000204 	addi	r8,r8,8
 8206f50:	b440130e 	bge	r22,r17,8206fa0 <___vfprintf_internal_r+0x818>
 8206f54:	01020974 	movhi	r4,2085
 8206f58:	18c00404 	addi	r3,r3,16
 8206f5c:	10800044 	addi	r2,r2,1
 8206f60:	2135f584 	addi	r4,r4,-10282
 8206f64:	41000015 	stw	r4,0(r8)
 8206f68:	45800115 	stw	r22,4(r8)
 8206f6c:	d8c02015 	stw	r3,128(sp)
 8206f70:	d8801f15 	stw	r2,124(sp)
 8206f74:	e0bff40e 	bge	fp,r2,8206f48 <___vfprintf_internal_r+0x7c0>
 8206f78:	d9801e04 	addi	r6,sp,120
 8206f7c:	b80b883a 	mov	r5,r23
 8206f80:	8009883a 	mov	r4,r16
 8206f84:	820f2dc0 	call	820f2dc <__sprint_r>
 8206f88:	103f011e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8206f8c:	8c7ffc04 	addi	r17,r17,-16
 8206f90:	d8c02017 	ldw	r3,128(sp)
 8206f94:	d8801f17 	ldw	r2,124(sp)
 8206f98:	da000404 	addi	r8,sp,16
 8206f9c:	b47fed16 	blt	r22,r17,8206f54 <___vfprintf_internal_r+0x7cc>
 8206fa0:	9021883a 	mov	r16,r18
 8206fa4:	9825883a 	mov	r18,r19
 8206fa8:	8827883a 	mov	r19,r17
 8206fac:	dc403b17 	ldw	r17,236(sp)
 8206fb0:	d9403517 	ldw	r5,212(sp)
 8206fb4:	98c7883a 	add	r3,r19,r3
 8206fb8:	10800044 	addi	r2,r2,1
 8206fbc:	41400015 	stw	r5,0(r8)
 8206fc0:	44c00115 	stw	r19,4(r8)
 8206fc4:	d8c02015 	stw	r3,128(sp)
 8206fc8:	d8801f15 	stw	r2,124(sp)
 8206fcc:	010001c4 	movi	r4,7
 8206fd0:	2082a316 	blt	r4,r2,8207a60 <___vfprintf_internal_r+0x12d8>
 8206fd4:	df002787 	ldb	fp,158(sp)
 8206fd8:	42000204 	addi	r8,r8,8
 8206fdc:	e0000c26 	beq	fp,zero,8207010 <___vfprintf_internal_r+0x888>
 8206fe0:	d8801f17 	ldw	r2,124(sp)
 8206fe4:	d9002784 	addi	r4,sp,158
 8206fe8:	18c00044 	addi	r3,r3,1
 8206fec:	10800044 	addi	r2,r2,1
 8206ff0:	41000015 	stw	r4,0(r8)
 8206ff4:	01000044 	movi	r4,1
 8206ff8:	41000115 	stw	r4,4(r8)
 8206ffc:	d8c02015 	stw	r3,128(sp)
 8207000:	d8801f15 	stw	r2,124(sp)
 8207004:	010001c4 	movi	r4,7
 8207008:	20823c16 	blt	r4,r2,82078fc <___vfprintf_internal_r+0x1174>
 820700c:	42000204 	addi	r8,r8,8
 8207010:	d8802b17 	ldw	r2,172(sp)
 8207014:	10000c26 	beq	r2,zero,8207048 <___vfprintf_internal_r+0x8c0>
 8207018:	d8801f17 	ldw	r2,124(sp)
 820701c:	d9002704 	addi	r4,sp,156
 8207020:	18c00084 	addi	r3,r3,2
 8207024:	10800044 	addi	r2,r2,1
 8207028:	41000015 	stw	r4,0(r8)
 820702c:	01000084 	movi	r4,2
 8207030:	41000115 	stw	r4,4(r8)
 8207034:	d8c02015 	stw	r3,128(sp)
 8207038:	d8801f15 	stw	r2,124(sp)
 820703c:	010001c4 	movi	r4,7
 8207040:	20823616 	blt	r4,r2,820791c <___vfprintf_internal_r+0x1194>
 8207044:	42000204 	addi	r8,r8,8
 8207048:	d9003017 	ldw	r4,192(sp)
 820704c:	00802004 	movi	r2,128
 8207050:	20819926 	beq	r4,r2,82076b8 <___vfprintf_internal_r+0xf30>
 8207054:	d9402917 	ldw	r5,164(sp)
 8207058:	d8802e17 	ldw	r2,184(sp)
 820705c:	28adc83a 	sub	r22,r5,r2
 8207060:	0580310e 	bge	zero,r22,8207128 <___vfprintf_internal_r+0x9a0>
 8207064:	07000404 	movi	fp,16
 8207068:	d8801f17 	ldw	r2,124(sp)
 820706c:	e584140e 	bge	fp,r22,82080c0 <___vfprintf_internal_r+0x1938>
 8207070:	01420974 	movhi	r5,2085
 8207074:	2975f184 	addi	r5,r5,-10298
 8207078:	dc402915 	stw	r17,164(sp)
 820707c:	d9402b15 	stw	r5,172(sp)
 8207080:	b023883a 	mov	r17,r22
 8207084:	04c001c4 	movi	r19,7
 8207088:	a82d883a 	mov	r22,r21
 820708c:	902b883a 	mov	r21,r18
 8207090:	8025883a 	mov	r18,r16
 8207094:	dc002c17 	ldw	r16,176(sp)
 8207098:	00000306 	br	82070a8 <___vfprintf_internal_r+0x920>
 820709c:	8c7ffc04 	addi	r17,r17,-16
 82070a0:	42000204 	addi	r8,r8,8
 82070a4:	e440110e 	bge	fp,r17,82070ec <___vfprintf_internal_r+0x964>
 82070a8:	18c00404 	addi	r3,r3,16
 82070ac:	10800044 	addi	r2,r2,1
 82070b0:	45000015 	stw	r20,0(r8)
 82070b4:	47000115 	stw	fp,4(r8)
 82070b8:	d8c02015 	stw	r3,128(sp)
 82070bc:	d8801f15 	stw	r2,124(sp)
 82070c0:	98bff60e 	bge	r19,r2,820709c <___vfprintf_internal_r+0x914>
 82070c4:	d9801e04 	addi	r6,sp,120
 82070c8:	b80b883a 	mov	r5,r23
 82070cc:	8009883a 	mov	r4,r16
 82070d0:	820f2dc0 	call	820f2dc <__sprint_r>
 82070d4:	103eae1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82070d8:	8c7ffc04 	addi	r17,r17,-16
 82070dc:	d8c02017 	ldw	r3,128(sp)
 82070e0:	d8801f17 	ldw	r2,124(sp)
 82070e4:	da000404 	addi	r8,sp,16
 82070e8:	e47fef16 	blt	fp,r17,82070a8 <___vfprintf_internal_r+0x920>
 82070ec:	9021883a 	mov	r16,r18
 82070f0:	a825883a 	mov	r18,r21
 82070f4:	b02b883a 	mov	r21,r22
 82070f8:	882d883a 	mov	r22,r17
 82070fc:	dc402917 	ldw	r17,164(sp)
 8207100:	d9002b17 	ldw	r4,172(sp)
 8207104:	1d87883a 	add	r3,r3,r22
 8207108:	10800044 	addi	r2,r2,1
 820710c:	41000015 	stw	r4,0(r8)
 8207110:	45800115 	stw	r22,4(r8)
 8207114:	d8c02015 	stw	r3,128(sp)
 8207118:	d8801f15 	stw	r2,124(sp)
 820711c:	010001c4 	movi	r4,7
 8207120:	2081ee16 	blt	r4,r2,82078dc <___vfprintf_internal_r+0x1154>
 8207124:	42000204 	addi	r8,r8,8
 8207128:	9080400c 	andi	r2,r18,256
 820712c:	1001181e 	bne	r2,zero,8207590 <___vfprintf_internal_r+0xe08>
 8207130:	d9402e17 	ldw	r5,184(sp)
 8207134:	d8801f17 	ldw	r2,124(sp)
 8207138:	44000015 	stw	r16,0(r8)
 820713c:	1947883a 	add	r3,r3,r5
 8207140:	10800044 	addi	r2,r2,1
 8207144:	41400115 	stw	r5,4(r8)
 8207148:	d8c02015 	stw	r3,128(sp)
 820714c:	d8801f15 	stw	r2,124(sp)
 8207150:	010001c4 	movi	r4,7
 8207154:	2081d316 	blt	r4,r2,82078a4 <___vfprintf_internal_r+0x111c>
 8207158:	42000204 	addi	r8,r8,8
 820715c:	9480010c 	andi	r18,r18,4
 8207160:	90003226 	beq	r18,zero,820722c <___vfprintf_internal_r+0xaa4>
 8207164:	d9403117 	ldw	r5,196(sp)
 8207168:	d8802a17 	ldw	r2,168(sp)
 820716c:	28a1c83a 	sub	r16,r5,r2
 8207170:	04002e0e 	bge	zero,r16,820722c <___vfprintf_internal_r+0xaa4>
 8207174:	04400404 	movi	r17,16
 8207178:	d8801f17 	ldw	r2,124(sp)
 820717c:	8c04a20e 	bge	r17,r16,8208408 <___vfprintf_internal_r+0x1c80>
 8207180:	01420974 	movhi	r5,2085
 8207184:	2975f584 	addi	r5,r5,-10282
 8207188:	d9403515 	stw	r5,212(sp)
 820718c:	048001c4 	movi	r18,7
 8207190:	dcc02c17 	ldw	r19,176(sp)
 8207194:	00000306 	br	82071a4 <___vfprintf_internal_r+0xa1c>
 8207198:	843ffc04 	addi	r16,r16,-16
 820719c:	42000204 	addi	r8,r8,8
 82071a0:	8c00130e 	bge	r17,r16,82071f0 <___vfprintf_internal_r+0xa68>
 82071a4:	01020974 	movhi	r4,2085
 82071a8:	18c00404 	addi	r3,r3,16
 82071ac:	10800044 	addi	r2,r2,1
 82071b0:	2135f584 	addi	r4,r4,-10282
 82071b4:	41000015 	stw	r4,0(r8)
 82071b8:	44400115 	stw	r17,4(r8)
 82071bc:	d8c02015 	stw	r3,128(sp)
 82071c0:	d8801f15 	stw	r2,124(sp)
 82071c4:	90bff40e 	bge	r18,r2,8207198 <___vfprintf_internal_r+0xa10>
 82071c8:	d9801e04 	addi	r6,sp,120
 82071cc:	b80b883a 	mov	r5,r23
 82071d0:	9809883a 	mov	r4,r19
 82071d4:	820f2dc0 	call	820f2dc <__sprint_r>
 82071d8:	103e6d1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82071dc:	843ffc04 	addi	r16,r16,-16
 82071e0:	d8c02017 	ldw	r3,128(sp)
 82071e4:	d8801f17 	ldw	r2,124(sp)
 82071e8:	da000404 	addi	r8,sp,16
 82071ec:	8c3fed16 	blt	r17,r16,82071a4 <___vfprintf_internal_r+0xa1c>
 82071f0:	d9403517 	ldw	r5,212(sp)
 82071f4:	1c07883a 	add	r3,r3,r16
 82071f8:	10800044 	addi	r2,r2,1
 82071fc:	41400015 	stw	r5,0(r8)
 8207200:	44000115 	stw	r16,4(r8)
 8207204:	d8c02015 	stw	r3,128(sp)
 8207208:	d8801f15 	stw	r2,124(sp)
 820720c:	010001c4 	movi	r4,7
 8207210:	2080060e 	bge	r4,r2,820722c <___vfprintf_internal_r+0xaa4>
 8207214:	d9002c17 	ldw	r4,176(sp)
 8207218:	d9801e04 	addi	r6,sp,120
 820721c:	b80b883a 	mov	r5,r23
 8207220:	820f2dc0 	call	820f2dc <__sprint_r>
 8207224:	103e5a1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207228:	d8c02017 	ldw	r3,128(sp)
 820722c:	d8803117 	ldw	r2,196(sp)
 8207230:	d9002a17 	ldw	r4,168(sp)
 8207234:	1100010e 	bge	r2,r4,820723c <___vfprintf_internal_r+0xab4>
 8207238:	2005883a 	mov	r2,r4
 820723c:	d9402f17 	ldw	r5,188(sp)
 8207240:	288b883a 	add	r5,r5,r2
 8207244:	d9402f15 	stw	r5,188(sp)
 8207248:	18019e1e 	bne	r3,zero,82078c4 <___vfprintf_internal_r+0x113c>
 820724c:	a8800007 	ldb	r2,0(r21)
 8207250:	d8001f15 	stw	zero,124(sp)
 8207254:	da000404 	addi	r8,sp,16
 8207258:	103d851e 	bne	r2,zero,8206870 <___vfprintf_internal_r+0xe8>
 820725c:	a821883a 	mov	r16,r21
 8207260:	003d9b06 	br	82068d0 <___vfprintf_internal_r+0x148>
 8207264:	18c03fcc 	andi	r3,r3,255
 8207268:	1805c11e 	bne	r3,zero,8208970 <___vfprintf_internal_r+0x21e8>
 820726c:	94800414 	ori	r18,r18,16
 8207270:	9080080c 	andi	r2,r18,32
 8207274:	10020c26 	beq	r2,zero,8207aa8 <___vfprintf_internal_r+0x1320>
 8207278:	d8802d17 	ldw	r2,180(sp)
 820727c:	d9002917 	ldw	r4,164(sp)
 8207280:	d8002785 	stb	zero,158(sp)
 8207284:	10c00204 	addi	r3,r2,8
 8207288:	14c00017 	ldw	r19,0(r2)
 820728c:	15800117 	ldw	r22,4(r2)
 8207290:	20040f16 	blt	r4,zero,82082d0 <___vfprintf_internal_r+0x1b48>
 8207294:	013fdfc4 	movi	r4,-129
 8207298:	9d84b03a 	or	r2,r19,r22
 820729c:	d8c02d15 	stw	r3,180(sp)
 82072a0:	9124703a 	and	r18,r18,r4
 82072a4:	0039883a 	mov	fp,zero
 82072a8:	103e891e 	bne	r2,zero,8206cd0 <___vfprintf_internal_r+0x548>
 82072ac:	d9002917 	ldw	r4,164(sp)
 82072b0:	2002c11e 	bne	r4,zero,8207db8 <___vfprintf_internal_r+0x1630>
 82072b4:	d8002915 	stw	zero,164(sp)
 82072b8:	d8002e15 	stw	zero,184(sp)
 82072bc:	dc001e04 	addi	r16,sp,120
 82072c0:	003ef806 	br	8206ea4 <___vfprintf_internal_r+0x71c>
 82072c4:	18c03fcc 	andi	r3,r3,255
 82072c8:	18059d1e 	bne	r3,zero,8208940 <___vfprintf_internal_r+0x21b8>
 82072cc:	01420974 	movhi	r5,2085
 82072d0:	2975dd04 	addi	r5,r5,-10380
 82072d4:	d9403915 	stw	r5,228(sp)
 82072d8:	9080080c 	andi	r2,r18,32
 82072dc:	10005226 	beq	r2,zero,8207428 <___vfprintf_internal_r+0xca0>
 82072e0:	d8802d17 	ldw	r2,180(sp)
 82072e4:	14c00017 	ldw	r19,0(r2)
 82072e8:	15800117 	ldw	r22,4(r2)
 82072ec:	10800204 	addi	r2,r2,8
 82072f0:	d8802d15 	stw	r2,180(sp)
 82072f4:	9080004c 	andi	r2,r18,1
 82072f8:	10019026 	beq	r2,zero,820793c <___vfprintf_internal_r+0x11b4>
 82072fc:	9d84b03a 	or	r2,r19,r22
 8207300:	10036926 	beq	r2,zero,82080a8 <___vfprintf_internal_r+0x1920>
 8207304:	d8c02917 	ldw	r3,164(sp)
 8207308:	00800c04 	movi	r2,48
 820730c:	d8802705 	stb	r2,156(sp)
 8207310:	dc402745 	stb	r17,157(sp)
 8207314:	d8002785 	stb	zero,158(sp)
 8207318:	90800094 	ori	r2,r18,2
 820731c:	18045d16 	blt	r3,zero,8208494 <___vfprintf_internal_r+0x1d0c>
 8207320:	00bfdfc4 	movi	r2,-129
 8207324:	90a4703a 	and	r18,r18,r2
 8207328:	94800094 	ori	r18,r18,2
 820732c:	0039883a 	mov	fp,zero
 8207330:	d9003917 	ldw	r4,228(sp)
 8207334:	dc001e04 	addi	r16,sp,120
 8207338:	988003cc 	andi	r2,r19,15
 820733c:	b006973a 	slli	r3,r22,28
 8207340:	2085883a 	add	r2,r4,r2
 8207344:	9826d13a 	srli	r19,r19,4
 8207348:	10800003 	ldbu	r2,0(r2)
 820734c:	b02cd13a 	srli	r22,r22,4
 8207350:	843fffc4 	addi	r16,r16,-1
 8207354:	1ce6b03a 	or	r19,r3,r19
 8207358:	80800005 	stb	r2,0(r16)
 820735c:	9d84b03a 	or	r2,r19,r22
 8207360:	103ff51e 	bne	r2,zero,8207338 <___vfprintf_internal_r+0xbb0>
 8207364:	d8c02817 	ldw	r3,160(sp)
 8207368:	1c07c83a 	sub	r3,r3,r16
 820736c:	d8c02e15 	stw	r3,184(sp)
 8207370:	003ecc06 	br	8206ea4 <___vfprintf_internal_r+0x71c>
 8207374:	18c03fcc 	andi	r3,r3,255
 8207378:	183e9f26 	beq	r3,zero,8206df8 <___vfprintf_internal_r+0x670>
 820737c:	d9c02785 	stb	r7,158(sp)
 8207380:	003e9d06 	br	8206df8 <___vfprintf_internal_r+0x670>
 8207384:	00c00044 	movi	r3,1
 8207388:	01c00ac4 	movi	r7,43
 820738c:	ac400007 	ldb	r17,0(r21)
 8207390:	003d5e06 	br	820690c <___vfprintf_internal_r+0x184>
 8207394:	94800814 	ori	r18,r18,32
 8207398:	ac400007 	ldb	r17,0(r21)
 820739c:	003d5b06 	br	820690c <___vfprintf_internal_r+0x184>
 82073a0:	d8c02d17 	ldw	r3,180(sp)
 82073a4:	d8002785 	stb	zero,158(sp)
 82073a8:	1c000017 	ldw	r16,0(r3)
 82073ac:	1cc00104 	addi	r19,r3,4
 82073b0:	80041926 	beq	r16,zero,8208418 <___vfprintf_internal_r+0x1c90>
 82073b4:	d9002917 	ldw	r4,164(sp)
 82073b8:	2003d016 	blt	r4,zero,82082fc <___vfprintf_internal_r+0x1b74>
 82073bc:	200d883a 	mov	r6,r4
 82073c0:	000b883a 	mov	r5,zero
 82073c4:	8009883a 	mov	r4,r16
 82073c8:	da003d15 	stw	r8,244(sp)
 82073cc:	820c2440 	call	820c244 <memchr>
 82073d0:	da003d17 	ldw	r8,244(sp)
 82073d4:	10045426 	beq	r2,zero,8208528 <___vfprintf_internal_r+0x1da0>
 82073d8:	1405c83a 	sub	r2,r2,r16
 82073dc:	d8802e15 	stw	r2,184(sp)
 82073e0:	1003cc16 	blt	r2,zero,8208314 <___vfprintf_internal_r+0x1b8c>
 82073e4:	df002783 	ldbu	fp,158(sp)
 82073e8:	d8802a15 	stw	r2,168(sp)
 82073ec:	dcc02d15 	stw	r19,180(sp)
 82073f0:	d8002915 	stw	zero,164(sp)
 82073f4:	d8003215 	stw	zero,200(sp)
 82073f8:	003eb006 	br	8206ebc <___vfprintf_internal_r+0x734>
 82073fc:	18c03fcc 	andi	r3,r3,255
 8207400:	183f9b26 	beq	r3,zero,8207270 <___vfprintf_internal_r+0xae8>
 8207404:	d9c02785 	stb	r7,158(sp)
 8207408:	003f9906 	br	8207270 <___vfprintf_internal_r+0xae8>
 820740c:	18c03fcc 	andi	r3,r3,255
 8207410:	1805551e 	bne	r3,zero,8208968 <___vfprintf_internal_r+0x21e0>
 8207414:	01420974 	movhi	r5,2085
 8207418:	2975e204 	addi	r5,r5,-10360
 820741c:	d9403915 	stw	r5,228(sp)
 8207420:	9080080c 	andi	r2,r18,32
 8207424:	103fae1e 	bne	r2,zero,82072e0 <___vfprintf_internal_r+0xb58>
 8207428:	9080040c 	andi	r2,r18,16
 820742c:	1002de26 	beq	r2,zero,8207fa8 <___vfprintf_internal_r+0x1820>
 8207430:	d8c02d17 	ldw	r3,180(sp)
 8207434:	002d883a 	mov	r22,zero
 8207438:	1cc00017 	ldw	r19,0(r3)
 820743c:	18c00104 	addi	r3,r3,4
 8207440:	d8c02d15 	stw	r3,180(sp)
 8207444:	003fab06 	br	82072f4 <___vfprintf_internal_r+0xb6c>
 8207448:	38803fcc 	andi	r2,r7,255
 820744c:	1080201c 	xori	r2,r2,128
 8207450:	10bfe004 	addi	r2,r2,-128
 8207454:	1002d21e 	bne	r2,zero,8207fa0 <___vfprintf_internal_r+0x1818>
 8207458:	00c00044 	movi	r3,1
 820745c:	01c00804 	movi	r7,32
 8207460:	ac400007 	ldb	r17,0(r21)
 8207464:	003d2906 	br	820690c <___vfprintf_internal_r+0x184>
 8207468:	94800054 	ori	r18,r18,1
 820746c:	ac400007 	ldb	r17,0(r21)
 8207470:	003d2606 	br	820690c <___vfprintf_internal_r+0x184>
 8207474:	18c03fcc 	andi	r3,r3,255
 8207478:	183e0526 	beq	r3,zero,8206c90 <___vfprintf_internal_r+0x508>
 820747c:	d9c02785 	stb	r7,158(sp)
 8207480:	003e0306 	br	8206c90 <___vfprintf_internal_r+0x508>
 8207484:	94801014 	ori	r18,r18,64
 8207488:	ac400007 	ldb	r17,0(r21)
 820748c:	003d1f06 	br	820690c <___vfprintf_internal_r+0x184>
 8207490:	ac400007 	ldb	r17,0(r21)
 8207494:	8a438726 	beq	r17,r9,82082b4 <___vfprintf_internal_r+0x1b2c>
 8207498:	94800414 	ori	r18,r18,16
 820749c:	003d1b06 	br	820690c <___vfprintf_internal_r+0x184>
 82074a0:	18c03fcc 	andi	r3,r3,255
 82074a4:	1805341e 	bne	r3,zero,8208978 <___vfprintf_internal_r+0x21f0>
 82074a8:	9080080c 	andi	r2,r18,32
 82074ac:	1002cd26 	beq	r2,zero,8207fe4 <___vfprintf_internal_r+0x185c>
 82074b0:	d9402d17 	ldw	r5,180(sp)
 82074b4:	d9002f17 	ldw	r4,188(sp)
 82074b8:	28800017 	ldw	r2,0(r5)
 82074bc:	2007d7fa 	srai	r3,r4,31
 82074c0:	29400104 	addi	r5,r5,4
 82074c4:	d9402d15 	stw	r5,180(sp)
 82074c8:	11000015 	stw	r4,0(r2)
 82074cc:	10c00115 	stw	r3,4(r2)
 82074d0:	003ce506 	br	8206868 <___vfprintf_internal_r+0xe0>
 82074d4:	d8c02d17 	ldw	r3,180(sp)
 82074d8:	d9002d17 	ldw	r4,180(sp)
 82074dc:	d8002785 	stb	zero,158(sp)
 82074e0:	18800017 	ldw	r2,0(r3)
 82074e4:	21000104 	addi	r4,r4,4
 82074e8:	00c00044 	movi	r3,1
 82074ec:	d8c02a15 	stw	r3,168(sp)
 82074f0:	d8801405 	stb	r2,80(sp)
 82074f4:	d9002d15 	stw	r4,180(sp)
 82074f8:	d8c02e15 	stw	r3,184(sp)
 82074fc:	d8002915 	stw	zero,164(sp)
 8207500:	d8003215 	stw	zero,200(sp)
 8207504:	dc001404 	addi	r16,sp,80
 8207508:	0039883a 	mov	fp,zero
 820750c:	003e7206 	br	8206ed8 <___vfprintf_internal_r+0x750>
 8207510:	01020974 	movhi	r4,2085
 8207514:	2135e204 	addi	r4,r4,-10360
 8207518:	0039883a 	mov	fp,zero
 820751c:	d9003915 	stw	r4,228(sp)
 8207520:	04401e04 	movi	r17,120
 8207524:	003f8206 	br	8207330 <___vfprintf_internal_r+0xba8>
 8207528:	18c03fcc 	andi	r3,r3,255
 820752c:	1805061e 	bne	r3,zero,8208948 <___vfprintf_internal_r+0x21c0>
 8207530:	883d9126 	beq	r17,zero,8206b78 <___vfprintf_internal_r+0x3f0>
 8207534:	00c00044 	movi	r3,1
 8207538:	d8c02a15 	stw	r3,168(sp)
 820753c:	dc401405 	stb	r17,80(sp)
 8207540:	d8002785 	stb	zero,158(sp)
 8207544:	003fec06 	br	82074f8 <___vfprintf_internal_r+0xd70>
 8207548:	01420974 	movhi	r5,2085
 820754c:	2975e204 	addi	r5,r5,-10360
 8207550:	d9403915 	stw	r5,228(sp)
 8207554:	d8c02d15 	stw	r3,180(sp)
 8207558:	1025883a 	mov	r18,r2
 820755c:	04401e04 	movi	r17,120
 8207560:	9d84b03a 	or	r2,r19,r22
 8207564:	1000fc1e 	bne	r2,zero,8207958 <___vfprintf_internal_r+0x11d0>
 8207568:	0039883a 	mov	fp,zero
 820756c:	00800084 	movi	r2,2
 8207570:	10803fcc 	andi	r2,r2,255
 8207574:	00c00044 	movi	r3,1
 8207578:	10c20f26 	beq	r2,r3,8207db8 <___vfprintf_internal_r+0x1630>
 820757c:	00c00084 	movi	r3,2
 8207580:	10fd6326 	beq	r2,r3,8206b10 <___vfprintf_internal_r+0x388>
 8207584:	003e2d06 	br	8206e3c <___vfprintf_internal_r+0x6b4>
 8207588:	d8c02017 	ldw	r3,128(sp)
 820758c:	003e9306 	br	8206fdc <___vfprintf_internal_r+0x854>
 8207590:	00801944 	movi	r2,101
 8207594:	14407e0e 	bge	r2,r17,8207790 <___vfprintf_internal_r+0x1008>
 8207598:	d9003617 	ldw	r4,216(sp)
 820759c:	d9403817 	ldw	r5,224(sp)
 82075a0:	000d883a 	mov	r6,zero
 82075a4:	000f883a 	mov	r7,zero
 82075a8:	d8c03c15 	stw	r3,240(sp)
 82075ac:	da003d15 	stw	r8,244(sp)
 82075b0:	8212c480 	call	8212c48 <__eqdf2>
 82075b4:	d8c03c17 	ldw	r3,240(sp)
 82075b8:	da003d17 	ldw	r8,244(sp)
 82075bc:	1000f71e 	bne	r2,zero,820799c <___vfprintf_internal_r+0x1214>
 82075c0:	d8801f17 	ldw	r2,124(sp)
 82075c4:	01020974 	movhi	r4,2085
 82075c8:	2135e904 	addi	r4,r4,-10332
 82075cc:	18c00044 	addi	r3,r3,1
 82075d0:	10800044 	addi	r2,r2,1
 82075d4:	41000015 	stw	r4,0(r8)
 82075d8:	01000044 	movi	r4,1
 82075dc:	41000115 	stw	r4,4(r8)
 82075e0:	d8c02015 	stw	r3,128(sp)
 82075e4:	d8801f15 	stw	r2,124(sp)
 82075e8:	010001c4 	movi	r4,7
 82075ec:	2082b816 	blt	r4,r2,82080d0 <___vfprintf_internal_r+0x1948>
 82075f0:	42000204 	addi	r8,r8,8
 82075f4:	d8802617 	ldw	r2,152(sp)
 82075f8:	d9403317 	ldw	r5,204(sp)
 82075fc:	11400216 	blt	r2,r5,8207608 <___vfprintf_internal_r+0xe80>
 8207600:	9080004c 	andi	r2,r18,1
 8207604:	103ed526 	beq	r2,zero,820715c <___vfprintf_internal_r+0x9d4>
 8207608:	d8803717 	ldw	r2,220(sp)
 820760c:	d9003417 	ldw	r4,208(sp)
 8207610:	d9403717 	ldw	r5,220(sp)
 8207614:	1887883a 	add	r3,r3,r2
 8207618:	d8801f17 	ldw	r2,124(sp)
 820761c:	41000015 	stw	r4,0(r8)
 8207620:	41400115 	stw	r5,4(r8)
 8207624:	10800044 	addi	r2,r2,1
 8207628:	d8c02015 	stw	r3,128(sp)
 820762c:	d8801f15 	stw	r2,124(sp)
 8207630:	010001c4 	movi	r4,7
 8207634:	20832916 	blt	r4,r2,82082dc <___vfprintf_internal_r+0x1b54>
 8207638:	42000204 	addi	r8,r8,8
 820763c:	d8803317 	ldw	r2,204(sp)
 8207640:	143fffc4 	addi	r16,r2,-1
 8207644:	043ec50e 	bge	zero,r16,820715c <___vfprintf_internal_r+0x9d4>
 8207648:	04400404 	movi	r17,16
 820764c:	d8801f17 	ldw	r2,124(sp)
 8207650:	8c00880e 	bge	r17,r16,8207874 <___vfprintf_internal_r+0x10ec>
 8207654:	01420974 	movhi	r5,2085
 8207658:	2975f184 	addi	r5,r5,-10298
 820765c:	d9402b15 	stw	r5,172(sp)
 8207660:	058001c4 	movi	r22,7
 8207664:	dcc02c17 	ldw	r19,176(sp)
 8207668:	00000306 	br	8207678 <___vfprintf_internal_r+0xef0>
 820766c:	42000204 	addi	r8,r8,8
 8207670:	843ffc04 	addi	r16,r16,-16
 8207674:	8c00820e 	bge	r17,r16,8207880 <___vfprintf_internal_r+0x10f8>
 8207678:	18c00404 	addi	r3,r3,16
 820767c:	10800044 	addi	r2,r2,1
 8207680:	45000015 	stw	r20,0(r8)
 8207684:	44400115 	stw	r17,4(r8)
 8207688:	d8c02015 	stw	r3,128(sp)
 820768c:	d8801f15 	stw	r2,124(sp)
 8207690:	b0bff60e 	bge	r22,r2,820766c <___vfprintf_internal_r+0xee4>
 8207694:	d9801e04 	addi	r6,sp,120
 8207698:	b80b883a 	mov	r5,r23
 820769c:	9809883a 	mov	r4,r19
 82076a0:	820f2dc0 	call	820f2dc <__sprint_r>
 82076a4:	103d3a1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82076a8:	d8c02017 	ldw	r3,128(sp)
 82076ac:	d8801f17 	ldw	r2,124(sp)
 82076b0:	da000404 	addi	r8,sp,16
 82076b4:	003fee06 	br	8207670 <___vfprintf_internal_r+0xee8>
 82076b8:	d9403117 	ldw	r5,196(sp)
 82076bc:	d8802a17 	ldw	r2,168(sp)
 82076c0:	28adc83a 	sub	r22,r5,r2
 82076c4:	05be630e 	bge	zero,r22,8207054 <___vfprintf_internal_r+0x8cc>
 82076c8:	07000404 	movi	fp,16
 82076cc:	d8801f17 	ldw	r2,124(sp)
 82076d0:	e5838f0e 	bge	fp,r22,8208510 <___vfprintf_internal_r+0x1d88>
 82076d4:	01420974 	movhi	r5,2085
 82076d8:	2975f184 	addi	r5,r5,-10298
 82076dc:	dc403015 	stw	r17,192(sp)
 82076e0:	d9402b15 	stw	r5,172(sp)
 82076e4:	b023883a 	mov	r17,r22
 82076e8:	04c001c4 	movi	r19,7
 82076ec:	a82d883a 	mov	r22,r21
 82076f0:	902b883a 	mov	r21,r18
 82076f4:	8025883a 	mov	r18,r16
 82076f8:	dc002c17 	ldw	r16,176(sp)
 82076fc:	00000306 	br	820770c <___vfprintf_internal_r+0xf84>
 8207700:	8c7ffc04 	addi	r17,r17,-16
 8207704:	42000204 	addi	r8,r8,8
 8207708:	e440110e 	bge	fp,r17,8207750 <___vfprintf_internal_r+0xfc8>
 820770c:	18c00404 	addi	r3,r3,16
 8207710:	10800044 	addi	r2,r2,1
 8207714:	45000015 	stw	r20,0(r8)
 8207718:	47000115 	stw	fp,4(r8)
 820771c:	d8c02015 	stw	r3,128(sp)
 8207720:	d8801f15 	stw	r2,124(sp)
 8207724:	98bff60e 	bge	r19,r2,8207700 <___vfprintf_internal_r+0xf78>
 8207728:	d9801e04 	addi	r6,sp,120
 820772c:	b80b883a 	mov	r5,r23
 8207730:	8009883a 	mov	r4,r16
 8207734:	820f2dc0 	call	820f2dc <__sprint_r>
 8207738:	103d151e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 820773c:	8c7ffc04 	addi	r17,r17,-16
 8207740:	d8c02017 	ldw	r3,128(sp)
 8207744:	d8801f17 	ldw	r2,124(sp)
 8207748:	da000404 	addi	r8,sp,16
 820774c:	e47fef16 	blt	fp,r17,820770c <___vfprintf_internal_r+0xf84>
 8207750:	9021883a 	mov	r16,r18
 8207754:	a825883a 	mov	r18,r21
 8207758:	b02b883a 	mov	r21,r22
 820775c:	882d883a 	mov	r22,r17
 8207760:	dc403017 	ldw	r17,192(sp)
 8207764:	d9002b17 	ldw	r4,172(sp)
 8207768:	1d87883a 	add	r3,r3,r22
 820776c:	10800044 	addi	r2,r2,1
 8207770:	41000015 	stw	r4,0(r8)
 8207774:	45800115 	stw	r22,4(r8)
 8207778:	d8c02015 	stw	r3,128(sp)
 820777c:	d8801f15 	stw	r2,124(sp)
 8207780:	010001c4 	movi	r4,7
 8207784:	20818e16 	blt	r4,r2,8207dc0 <___vfprintf_internal_r+0x1638>
 8207788:	42000204 	addi	r8,r8,8
 820778c:	003e3106 	br	8207054 <___vfprintf_internal_r+0x8cc>
 8207790:	d9403317 	ldw	r5,204(sp)
 8207794:	00800044 	movi	r2,1
 8207798:	18c00044 	addi	r3,r3,1
 820779c:	1141530e 	bge	r2,r5,8207cec <___vfprintf_internal_r+0x1564>
 82077a0:	dc401f17 	ldw	r17,124(sp)
 82077a4:	00800044 	movi	r2,1
 82077a8:	40800115 	stw	r2,4(r8)
 82077ac:	8c400044 	addi	r17,r17,1
 82077b0:	44000015 	stw	r16,0(r8)
 82077b4:	d8c02015 	stw	r3,128(sp)
 82077b8:	dc401f15 	stw	r17,124(sp)
 82077bc:	008001c4 	movi	r2,7
 82077c0:	14416b16 	blt	r2,r17,8207d70 <___vfprintf_internal_r+0x15e8>
 82077c4:	42000204 	addi	r8,r8,8
 82077c8:	d8803717 	ldw	r2,220(sp)
 82077cc:	d9003417 	ldw	r4,208(sp)
 82077d0:	8c400044 	addi	r17,r17,1
 82077d4:	10c7883a 	add	r3,r2,r3
 82077d8:	40800115 	stw	r2,4(r8)
 82077dc:	41000015 	stw	r4,0(r8)
 82077e0:	d8c02015 	stw	r3,128(sp)
 82077e4:	dc401f15 	stw	r17,124(sp)
 82077e8:	008001c4 	movi	r2,7
 82077ec:	14416916 	blt	r2,r17,8207d94 <___vfprintf_internal_r+0x160c>
 82077f0:	45800204 	addi	r22,r8,8
 82077f4:	d9003617 	ldw	r4,216(sp)
 82077f8:	d9403817 	ldw	r5,224(sp)
 82077fc:	000d883a 	mov	r6,zero
 8207800:	000f883a 	mov	r7,zero
 8207804:	d8c03c15 	stw	r3,240(sp)
 8207808:	8212c480 	call	8212c48 <__eqdf2>
 820780c:	d8c03c17 	ldw	r3,240(sp)
 8207810:	1000bc26 	beq	r2,zero,8207b04 <___vfprintf_internal_r+0x137c>
 8207814:	d9403317 	ldw	r5,204(sp)
 8207818:	84000044 	addi	r16,r16,1
 820781c:	8c400044 	addi	r17,r17,1
 8207820:	28bfffc4 	addi	r2,r5,-1
 8207824:	1887883a 	add	r3,r3,r2
 8207828:	b0800115 	stw	r2,4(r22)
 820782c:	b4000015 	stw	r16,0(r22)
 8207830:	d8c02015 	stw	r3,128(sp)
 8207834:	dc401f15 	stw	r17,124(sp)
 8207838:	008001c4 	movi	r2,7
 820783c:	14414316 	blt	r2,r17,8207d4c <___vfprintf_internal_r+0x15c4>
 8207840:	b5800204 	addi	r22,r22,8
 8207844:	d9003a17 	ldw	r4,232(sp)
 8207848:	df0022c4 	addi	fp,sp,139
 820784c:	8c400044 	addi	r17,r17,1
 8207850:	20c7883a 	add	r3,r4,r3
 8207854:	b7000015 	stw	fp,0(r22)
 8207858:	b1000115 	stw	r4,4(r22)
 820785c:	d8c02015 	stw	r3,128(sp)
 8207860:	dc401f15 	stw	r17,124(sp)
 8207864:	008001c4 	movi	r2,7
 8207868:	14400e16 	blt	r2,r17,82078a4 <___vfprintf_internal_r+0x111c>
 820786c:	b2000204 	addi	r8,r22,8
 8207870:	003e3a06 	br	820715c <___vfprintf_internal_r+0x9d4>
 8207874:	01020974 	movhi	r4,2085
 8207878:	2135f184 	addi	r4,r4,-10298
 820787c:	d9002b15 	stw	r4,172(sp)
 8207880:	d9002b17 	ldw	r4,172(sp)
 8207884:	1c07883a 	add	r3,r3,r16
 8207888:	44000115 	stw	r16,4(r8)
 820788c:	41000015 	stw	r4,0(r8)
 8207890:	10800044 	addi	r2,r2,1
 8207894:	d8c02015 	stw	r3,128(sp)
 8207898:	d8801f15 	stw	r2,124(sp)
 820789c:	010001c4 	movi	r4,7
 82078a0:	20be2d0e 	bge	r4,r2,8207158 <___vfprintf_internal_r+0x9d0>
 82078a4:	d9002c17 	ldw	r4,176(sp)
 82078a8:	d9801e04 	addi	r6,sp,120
 82078ac:	b80b883a 	mov	r5,r23
 82078b0:	820f2dc0 	call	820f2dc <__sprint_r>
 82078b4:	103cb61e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82078b8:	d8c02017 	ldw	r3,128(sp)
 82078bc:	da000404 	addi	r8,sp,16
 82078c0:	003e2606 	br	820715c <___vfprintf_internal_r+0x9d4>
 82078c4:	d9002c17 	ldw	r4,176(sp)
 82078c8:	d9801e04 	addi	r6,sp,120
 82078cc:	b80b883a 	mov	r5,r23
 82078d0:	820f2dc0 	call	820f2dc <__sprint_r>
 82078d4:	103e5d26 	beq	r2,zero,820724c <___vfprintf_internal_r+0xac4>
 82078d8:	003cad06 	br	8206b90 <___vfprintf_internal_r+0x408>
 82078dc:	d9002c17 	ldw	r4,176(sp)
 82078e0:	d9801e04 	addi	r6,sp,120
 82078e4:	b80b883a 	mov	r5,r23
 82078e8:	820f2dc0 	call	820f2dc <__sprint_r>
 82078ec:	103ca81e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82078f0:	d8c02017 	ldw	r3,128(sp)
 82078f4:	da000404 	addi	r8,sp,16
 82078f8:	003e0b06 	br	8207128 <___vfprintf_internal_r+0x9a0>
 82078fc:	d9002c17 	ldw	r4,176(sp)
 8207900:	d9801e04 	addi	r6,sp,120
 8207904:	b80b883a 	mov	r5,r23
 8207908:	820f2dc0 	call	820f2dc <__sprint_r>
 820790c:	103ca01e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207910:	d8c02017 	ldw	r3,128(sp)
 8207914:	da000404 	addi	r8,sp,16
 8207918:	003dbd06 	br	8207010 <___vfprintf_internal_r+0x888>
 820791c:	d9002c17 	ldw	r4,176(sp)
 8207920:	d9801e04 	addi	r6,sp,120
 8207924:	b80b883a 	mov	r5,r23
 8207928:	820f2dc0 	call	820f2dc <__sprint_r>
 820792c:	103c981e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207930:	d8c02017 	ldw	r3,128(sp)
 8207934:	da000404 	addi	r8,sp,16
 8207938:	003dc306 	br	8207048 <___vfprintf_internal_r+0x8c0>
 820793c:	d8802917 	ldw	r2,164(sp)
 8207940:	d8002785 	stb	zero,158(sp)
 8207944:	103f0616 	blt	r2,zero,8207560 <___vfprintf_internal_r+0xdd8>
 8207948:	00ffdfc4 	movi	r3,-129
 820794c:	9d84b03a 	or	r2,r19,r22
 8207950:	90e4703a 	and	r18,r18,r3
 8207954:	103c6b26 	beq	r2,zero,8206b04 <___vfprintf_internal_r+0x37c>
 8207958:	0039883a 	mov	fp,zero
 820795c:	003e7406 	br	8207330 <___vfprintf_internal_r+0xba8>
 8207960:	9080040c 	andi	r2,r18,16
 8207964:	1001b326 	beq	r2,zero,8208034 <___vfprintf_internal_r+0x18ac>
 8207968:	d9002d17 	ldw	r4,180(sp)
 820796c:	d9402917 	ldw	r5,164(sp)
 8207970:	d8002785 	stb	zero,158(sp)
 8207974:	20800104 	addi	r2,r4,4
 8207978:	24c00017 	ldw	r19,0(r4)
 820797c:	002d883a 	mov	r22,zero
 8207980:	2801b516 	blt	r5,zero,8208058 <___vfprintf_internal_r+0x18d0>
 8207984:	00ffdfc4 	movi	r3,-129
 8207988:	d8802d15 	stw	r2,180(sp)
 820798c:	90e4703a 	and	r18,r18,r3
 8207990:	983d2726 	beq	r19,zero,8206e30 <___vfprintf_internal_r+0x6a8>
 8207994:	0039883a 	mov	fp,zero
 8207998:	003d2a06 	br	8206e44 <___vfprintf_internal_r+0x6bc>
 820799c:	dc402617 	ldw	r17,152(sp)
 82079a0:	0441d30e 	bge	zero,r17,82080f0 <___vfprintf_internal_r+0x1968>
 82079a4:	dc403217 	ldw	r17,200(sp)
 82079a8:	d8803317 	ldw	r2,204(sp)
 82079ac:	1440010e 	bge	r2,r17,82079b4 <___vfprintf_internal_r+0x122c>
 82079b0:	1023883a 	mov	r17,r2
 82079b4:	04400a0e 	bge	zero,r17,82079e0 <___vfprintf_internal_r+0x1258>
 82079b8:	d8801f17 	ldw	r2,124(sp)
 82079bc:	1c47883a 	add	r3,r3,r17
 82079c0:	44000015 	stw	r16,0(r8)
 82079c4:	10800044 	addi	r2,r2,1
 82079c8:	44400115 	stw	r17,4(r8)
 82079cc:	d8c02015 	stw	r3,128(sp)
 82079d0:	d8801f15 	stw	r2,124(sp)
 82079d4:	010001c4 	movi	r4,7
 82079d8:	20826516 	blt	r4,r2,8208370 <___vfprintf_internal_r+0x1be8>
 82079dc:	42000204 	addi	r8,r8,8
 82079e0:	88026116 	blt	r17,zero,8208368 <___vfprintf_internal_r+0x1be0>
 82079e4:	d9003217 	ldw	r4,200(sp)
 82079e8:	2463c83a 	sub	r17,r4,r17
 82079ec:	04407b0e 	bge	zero,r17,8207bdc <___vfprintf_internal_r+0x1454>
 82079f0:	05800404 	movi	r22,16
 82079f4:	d8801f17 	ldw	r2,124(sp)
 82079f8:	b4419d0e 	bge	r22,r17,8208070 <___vfprintf_internal_r+0x18e8>
 82079fc:	01020974 	movhi	r4,2085
 8207a00:	2135f184 	addi	r4,r4,-10298
 8207a04:	d9002b15 	stw	r4,172(sp)
 8207a08:	070001c4 	movi	fp,7
 8207a0c:	dcc02c17 	ldw	r19,176(sp)
 8207a10:	00000306 	br	8207a20 <___vfprintf_internal_r+0x1298>
 8207a14:	42000204 	addi	r8,r8,8
 8207a18:	8c7ffc04 	addi	r17,r17,-16
 8207a1c:	b441970e 	bge	r22,r17,820807c <___vfprintf_internal_r+0x18f4>
 8207a20:	18c00404 	addi	r3,r3,16
 8207a24:	10800044 	addi	r2,r2,1
 8207a28:	45000015 	stw	r20,0(r8)
 8207a2c:	45800115 	stw	r22,4(r8)
 8207a30:	d8c02015 	stw	r3,128(sp)
 8207a34:	d8801f15 	stw	r2,124(sp)
 8207a38:	e0bff60e 	bge	fp,r2,8207a14 <___vfprintf_internal_r+0x128c>
 8207a3c:	d9801e04 	addi	r6,sp,120
 8207a40:	b80b883a 	mov	r5,r23
 8207a44:	9809883a 	mov	r4,r19
 8207a48:	820f2dc0 	call	820f2dc <__sprint_r>
 8207a4c:	103c501e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207a50:	d8c02017 	ldw	r3,128(sp)
 8207a54:	d8801f17 	ldw	r2,124(sp)
 8207a58:	da000404 	addi	r8,sp,16
 8207a5c:	003fee06 	br	8207a18 <___vfprintf_internal_r+0x1290>
 8207a60:	d9002c17 	ldw	r4,176(sp)
 8207a64:	d9801e04 	addi	r6,sp,120
 8207a68:	b80b883a 	mov	r5,r23
 8207a6c:	820f2dc0 	call	820f2dc <__sprint_r>
 8207a70:	103c471e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207a74:	d8c02017 	ldw	r3,128(sp)
 8207a78:	df002787 	ldb	fp,158(sp)
 8207a7c:	da000404 	addi	r8,sp,16
 8207a80:	003d5606 	br	8206fdc <___vfprintf_internal_r+0x854>
 8207a84:	9080040c 	andi	r2,r18,16
 8207a88:	10016126 	beq	r2,zero,8208010 <___vfprintf_internal_r+0x1888>
 8207a8c:	d8802d17 	ldw	r2,180(sp)
 8207a90:	14c00017 	ldw	r19,0(r2)
 8207a94:	10800104 	addi	r2,r2,4
 8207a98:	d8802d15 	stw	r2,180(sp)
 8207a9c:	982dd7fa 	srai	r22,r19,31
 8207aa0:	b005883a 	mov	r2,r22
 8207aa4:	003c8206 	br	8206cb0 <___vfprintf_internal_r+0x528>
 8207aa8:	9080040c 	andi	r2,r18,16
 8207aac:	10003526 	beq	r2,zero,8207b84 <___vfprintf_internal_r+0x13fc>
 8207ab0:	d9402d17 	ldw	r5,180(sp)
 8207ab4:	d8c02917 	ldw	r3,164(sp)
 8207ab8:	d8002785 	stb	zero,158(sp)
 8207abc:	28800104 	addi	r2,r5,4
 8207ac0:	2cc00017 	ldw	r19,0(r5)
 8207ac4:	002d883a 	mov	r22,zero
 8207ac8:	18003716 	blt	r3,zero,8207ba8 <___vfprintf_internal_r+0x1420>
 8207acc:	00ffdfc4 	movi	r3,-129
 8207ad0:	d8802d15 	stw	r2,180(sp)
 8207ad4:	90e4703a 	and	r18,r18,r3
 8207ad8:	0039883a 	mov	fp,zero
 8207adc:	983df326 	beq	r19,zero,82072ac <___vfprintf_internal_r+0xb24>
 8207ae0:	00800244 	movi	r2,9
 8207ae4:	14fc7b36 	bltu	r2,r19,8206cd4 <___vfprintf_internal_r+0x54c>
 8207ae8:	d8c02817 	ldw	r3,160(sp)
 8207aec:	dc001dc4 	addi	r16,sp,119
 8207af0:	9cc00c04 	addi	r19,r19,48
 8207af4:	1c07c83a 	sub	r3,r3,r16
 8207af8:	dcc01dc5 	stb	r19,119(sp)
 8207afc:	d8c02e15 	stw	r3,184(sp)
 8207b00:	003ce806 	br	8206ea4 <___vfprintf_internal_r+0x71c>
 8207b04:	d8803317 	ldw	r2,204(sp)
 8207b08:	143fffc4 	addi	r16,r2,-1
 8207b0c:	043f4d0e 	bge	zero,r16,8207844 <___vfprintf_internal_r+0x10bc>
 8207b10:	07000404 	movi	fp,16
 8207b14:	e400810e 	bge	fp,r16,8207d1c <___vfprintf_internal_r+0x1594>
 8207b18:	01420974 	movhi	r5,2085
 8207b1c:	2975f184 	addi	r5,r5,-10298
 8207b20:	d9402b15 	stw	r5,172(sp)
 8207b24:	01c001c4 	movi	r7,7
 8207b28:	dcc02c17 	ldw	r19,176(sp)
 8207b2c:	00000306 	br	8207b3c <___vfprintf_internal_r+0x13b4>
 8207b30:	b5800204 	addi	r22,r22,8
 8207b34:	843ffc04 	addi	r16,r16,-16
 8207b38:	e4007b0e 	bge	fp,r16,8207d28 <___vfprintf_internal_r+0x15a0>
 8207b3c:	18c00404 	addi	r3,r3,16
 8207b40:	8c400044 	addi	r17,r17,1
 8207b44:	b5000015 	stw	r20,0(r22)
 8207b48:	b7000115 	stw	fp,4(r22)
 8207b4c:	d8c02015 	stw	r3,128(sp)
 8207b50:	dc401f15 	stw	r17,124(sp)
 8207b54:	3c7ff60e 	bge	r7,r17,8207b30 <___vfprintf_internal_r+0x13a8>
 8207b58:	d9801e04 	addi	r6,sp,120
 8207b5c:	b80b883a 	mov	r5,r23
 8207b60:	9809883a 	mov	r4,r19
 8207b64:	d9c03c15 	stw	r7,240(sp)
 8207b68:	820f2dc0 	call	820f2dc <__sprint_r>
 8207b6c:	d9c03c17 	ldw	r7,240(sp)
 8207b70:	103c071e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207b74:	d8c02017 	ldw	r3,128(sp)
 8207b78:	dc401f17 	ldw	r17,124(sp)
 8207b7c:	dd800404 	addi	r22,sp,16
 8207b80:	003fec06 	br	8207b34 <___vfprintf_internal_r+0x13ac>
 8207b84:	9080100c 	andi	r2,r18,64
 8207b88:	d8002785 	stb	zero,158(sp)
 8207b8c:	10010e26 	beq	r2,zero,8207fc8 <___vfprintf_internal_r+0x1840>
 8207b90:	d9002d17 	ldw	r4,180(sp)
 8207b94:	d9402917 	ldw	r5,164(sp)
 8207b98:	002d883a 	mov	r22,zero
 8207b9c:	20800104 	addi	r2,r4,4
 8207ba0:	24c0000b 	ldhu	r19,0(r4)
 8207ba4:	283fc90e 	bge	r5,zero,8207acc <___vfprintf_internal_r+0x1344>
 8207ba8:	d8802d15 	stw	r2,180(sp)
 8207bac:	0039883a 	mov	fp,zero
 8207bb0:	9d84b03a 	or	r2,r19,r22
 8207bb4:	103c461e 	bne	r2,zero,8206cd0 <___vfprintf_internal_r+0x548>
 8207bb8:	00800044 	movi	r2,1
 8207bbc:	003e6c06 	br	8207570 <___vfprintf_internal_r+0xde8>
 8207bc0:	d9002c17 	ldw	r4,176(sp)
 8207bc4:	d9801e04 	addi	r6,sp,120
 8207bc8:	b80b883a 	mov	r5,r23
 8207bcc:	820f2dc0 	call	820f2dc <__sprint_r>
 8207bd0:	103bef1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207bd4:	d8c02017 	ldw	r3,128(sp)
 8207bd8:	da000404 	addi	r8,sp,16
 8207bdc:	d9003217 	ldw	r4,200(sp)
 8207be0:	d8802617 	ldw	r2,152(sp)
 8207be4:	d9403317 	ldw	r5,204(sp)
 8207be8:	8123883a 	add	r17,r16,r4
 8207bec:	11400216 	blt	r2,r5,8207bf8 <___vfprintf_internal_r+0x1470>
 8207bf0:	9100004c 	andi	r4,r18,1
 8207bf4:	20000d26 	beq	r4,zero,8207c2c <___vfprintf_internal_r+0x14a4>
 8207bf8:	d9003717 	ldw	r4,220(sp)
 8207bfc:	d9403417 	ldw	r5,208(sp)
 8207c00:	1907883a 	add	r3,r3,r4
 8207c04:	d9001f17 	ldw	r4,124(sp)
 8207c08:	41400015 	stw	r5,0(r8)
 8207c0c:	d9403717 	ldw	r5,220(sp)
 8207c10:	21000044 	addi	r4,r4,1
 8207c14:	d8c02015 	stw	r3,128(sp)
 8207c18:	41400115 	stw	r5,4(r8)
 8207c1c:	d9001f15 	stw	r4,124(sp)
 8207c20:	014001c4 	movi	r5,7
 8207c24:	2901e816 	blt	r5,r4,82083c8 <___vfprintf_internal_r+0x1c40>
 8207c28:	42000204 	addi	r8,r8,8
 8207c2c:	d9003317 	ldw	r4,204(sp)
 8207c30:	8121883a 	add	r16,r16,r4
 8207c34:	2085c83a 	sub	r2,r4,r2
 8207c38:	8461c83a 	sub	r16,r16,r17
 8207c3c:	1400010e 	bge	r2,r16,8207c44 <___vfprintf_internal_r+0x14bc>
 8207c40:	1021883a 	mov	r16,r2
 8207c44:	04000a0e 	bge	zero,r16,8207c70 <___vfprintf_internal_r+0x14e8>
 8207c48:	d9001f17 	ldw	r4,124(sp)
 8207c4c:	1c07883a 	add	r3,r3,r16
 8207c50:	44400015 	stw	r17,0(r8)
 8207c54:	21000044 	addi	r4,r4,1
 8207c58:	44000115 	stw	r16,4(r8)
 8207c5c:	d8c02015 	stw	r3,128(sp)
 8207c60:	d9001f15 	stw	r4,124(sp)
 8207c64:	014001c4 	movi	r5,7
 8207c68:	2901fb16 	blt	r5,r4,8208458 <___vfprintf_internal_r+0x1cd0>
 8207c6c:	42000204 	addi	r8,r8,8
 8207c70:	8001f716 	blt	r16,zero,8208450 <___vfprintf_internal_r+0x1cc8>
 8207c74:	1421c83a 	sub	r16,r2,r16
 8207c78:	043d380e 	bge	zero,r16,820715c <___vfprintf_internal_r+0x9d4>
 8207c7c:	04400404 	movi	r17,16
 8207c80:	d8801f17 	ldw	r2,124(sp)
 8207c84:	8c3efb0e 	bge	r17,r16,8207874 <___vfprintf_internal_r+0x10ec>
 8207c88:	01420974 	movhi	r5,2085
 8207c8c:	2975f184 	addi	r5,r5,-10298
 8207c90:	d9402b15 	stw	r5,172(sp)
 8207c94:	058001c4 	movi	r22,7
 8207c98:	dcc02c17 	ldw	r19,176(sp)
 8207c9c:	00000306 	br	8207cac <___vfprintf_internal_r+0x1524>
 8207ca0:	42000204 	addi	r8,r8,8
 8207ca4:	843ffc04 	addi	r16,r16,-16
 8207ca8:	8c3ef50e 	bge	r17,r16,8207880 <___vfprintf_internal_r+0x10f8>
 8207cac:	18c00404 	addi	r3,r3,16
 8207cb0:	10800044 	addi	r2,r2,1
 8207cb4:	45000015 	stw	r20,0(r8)
 8207cb8:	44400115 	stw	r17,4(r8)
 8207cbc:	d8c02015 	stw	r3,128(sp)
 8207cc0:	d8801f15 	stw	r2,124(sp)
 8207cc4:	b0bff60e 	bge	r22,r2,8207ca0 <___vfprintf_internal_r+0x1518>
 8207cc8:	d9801e04 	addi	r6,sp,120
 8207ccc:	b80b883a 	mov	r5,r23
 8207cd0:	9809883a 	mov	r4,r19
 8207cd4:	820f2dc0 	call	820f2dc <__sprint_r>
 8207cd8:	103bad1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207cdc:	d8c02017 	ldw	r3,128(sp)
 8207ce0:	d8801f17 	ldw	r2,124(sp)
 8207ce4:	da000404 	addi	r8,sp,16
 8207ce8:	003fee06 	br	8207ca4 <___vfprintf_internal_r+0x151c>
 8207cec:	9088703a 	and	r4,r18,r2
 8207cf0:	203eab1e 	bne	r4,zero,82077a0 <___vfprintf_internal_r+0x1018>
 8207cf4:	dc401f17 	ldw	r17,124(sp)
 8207cf8:	40800115 	stw	r2,4(r8)
 8207cfc:	44000015 	stw	r16,0(r8)
 8207d00:	8c400044 	addi	r17,r17,1
 8207d04:	d8c02015 	stw	r3,128(sp)
 8207d08:	dc401f15 	stw	r17,124(sp)
 8207d0c:	008001c4 	movi	r2,7
 8207d10:	14400e16 	blt	r2,r17,8207d4c <___vfprintf_internal_r+0x15c4>
 8207d14:	45800204 	addi	r22,r8,8
 8207d18:	003eca06 	br	8207844 <___vfprintf_internal_r+0x10bc>
 8207d1c:	01020974 	movhi	r4,2085
 8207d20:	2135f184 	addi	r4,r4,-10298
 8207d24:	d9002b15 	stw	r4,172(sp)
 8207d28:	d8802b17 	ldw	r2,172(sp)
 8207d2c:	1c07883a 	add	r3,r3,r16
 8207d30:	8c400044 	addi	r17,r17,1
 8207d34:	b0800015 	stw	r2,0(r22)
 8207d38:	b4000115 	stw	r16,4(r22)
 8207d3c:	d8c02015 	stw	r3,128(sp)
 8207d40:	dc401f15 	stw	r17,124(sp)
 8207d44:	008001c4 	movi	r2,7
 8207d48:	147ebd0e 	bge	r2,r17,8207840 <___vfprintf_internal_r+0x10b8>
 8207d4c:	d9002c17 	ldw	r4,176(sp)
 8207d50:	d9801e04 	addi	r6,sp,120
 8207d54:	b80b883a 	mov	r5,r23
 8207d58:	820f2dc0 	call	820f2dc <__sprint_r>
 8207d5c:	103b8c1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207d60:	d8c02017 	ldw	r3,128(sp)
 8207d64:	dc401f17 	ldw	r17,124(sp)
 8207d68:	dd800404 	addi	r22,sp,16
 8207d6c:	003eb506 	br	8207844 <___vfprintf_internal_r+0x10bc>
 8207d70:	d9002c17 	ldw	r4,176(sp)
 8207d74:	d9801e04 	addi	r6,sp,120
 8207d78:	b80b883a 	mov	r5,r23
 8207d7c:	820f2dc0 	call	820f2dc <__sprint_r>
 8207d80:	103b831e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207d84:	d8c02017 	ldw	r3,128(sp)
 8207d88:	dc401f17 	ldw	r17,124(sp)
 8207d8c:	da000404 	addi	r8,sp,16
 8207d90:	003e8d06 	br	82077c8 <___vfprintf_internal_r+0x1040>
 8207d94:	d9002c17 	ldw	r4,176(sp)
 8207d98:	d9801e04 	addi	r6,sp,120
 8207d9c:	b80b883a 	mov	r5,r23
 8207da0:	820f2dc0 	call	820f2dc <__sprint_r>
 8207da4:	103b7a1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207da8:	d8c02017 	ldw	r3,128(sp)
 8207dac:	dc401f17 	ldw	r17,124(sp)
 8207db0:	dd800404 	addi	r22,sp,16
 8207db4:	003e8f06 	br	82077f4 <___vfprintf_internal_r+0x106c>
 8207db8:	0027883a 	mov	r19,zero
 8207dbc:	003f4a06 	br	8207ae8 <___vfprintf_internal_r+0x1360>
 8207dc0:	d9002c17 	ldw	r4,176(sp)
 8207dc4:	d9801e04 	addi	r6,sp,120
 8207dc8:	b80b883a 	mov	r5,r23
 8207dcc:	820f2dc0 	call	820f2dc <__sprint_r>
 8207dd0:	103b6f1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8207dd4:	d8c02017 	ldw	r3,128(sp)
 8207dd8:	da000404 	addi	r8,sp,16
 8207ddc:	003c9d06 	br	8207054 <___vfprintf_internal_r+0x8cc>
 8207de0:	04e7c83a 	sub	r19,zero,r19
 8207de4:	9804c03a 	cmpne	r2,r19,zero
 8207de8:	05adc83a 	sub	r22,zero,r22
 8207dec:	b0adc83a 	sub	r22,r22,r2
 8207df0:	d8802917 	ldw	r2,164(sp)
 8207df4:	07000b44 	movi	fp,45
 8207df8:	df002785 	stb	fp,158(sp)
 8207dfc:	10017b16 	blt	r2,zero,82083ec <___vfprintf_internal_r+0x1c64>
 8207e00:	00bfdfc4 	movi	r2,-129
 8207e04:	90a4703a 	and	r18,r18,r2
 8207e08:	003bb106 	br	8206cd0 <___vfprintf_internal_r+0x548>
 8207e0c:	d9003617 	ldw	r4,216(sp)
 8207e10:	d9403817 	ldw	r5,224(sp)
 8207e14:	da003d15 	stw	r8,244(sp)
 8207e18:	820daf40 	call	820daf4 <__fpclassifyd>
 8207e1c:	da003d17 	ldw	r8,244(sp)
 8207e20:	1000f026 	beq	r2,zero,82081e4 <___vfprintf_internal_r+0x1a5c>
 8207e24:	d9002917 	ldw	r4,164(sp)
 8207e28:	05bff7c4 	movi	r22,-33
 8207e2c:	00bfffc4 	movi	r2,-1
 8207e30:	8dac703a 	and	r22,r17,r22
 8207e34:	20820026 	beq	r4,r2,8208638 <___vfprintf_internal_r+0x1eb0>
 8207e38:	008011c4 	movi	r2,71
 8207e3c:	b081f726 	beq	r22,r2,820861c <___vfprintf_internal_r+0x1e94>
 8207e40:	d9003817 	ldw	r4,224(sp)
 8207e44:	90c04014 	ori	r3,r18,256
 8207e48:	d8c02b15 	stw	r3,172(sp)
 8207e4c:	20021516 	blt	r4,zero,82086a4 <___vfprintf_internal_r+0x1f1c>
 8207e50:	dcc03817 	ldw	r19,224(sp)
 8207e54:	d8002a05 	stb	zero,168(sp)
 8207e58:	00801984 	movi	r2,102
 8207e5c:	8881f926 	beq	r17,r2,8208644 <___vfprintf_internal_r+0x1ebc>
 8207e60:	00801184 	movi	r2,70
 8207e64:	88821c26 	beq	r17,r2,82086d8 <___vfprintf_internal_r+0x1f50>
 8207e68:	00801144 	movi	r2,69
 8207e6c:	b081ef26 	beq	r22,r2,820862c <___vfprintf_internal_r+0x1ea4>
 8207e70:	d8c02917 	ldw	r3,164(sp)
 8207e74:	d8802104 	addi	r2,sp,132
 8207e78:	d8800315 	stw	r2,12(sp)
 8207e7c:	d9403617 	ldw	r5,216(sp)
 8207e80:	d8802504 	addi	r2,sp,148
 8207e84:	d9002c17 	ldw	r4,176(sp)
 8207e88:	d8800215 	stw	r2,8(sp)
 8207e8c:	d8802604 	addi	r2,sp,152
 8207e90:	d8c00015 	stw	r3,0(sp)
 8207e94:	d8800115 	stw	r2,4(sp)
 8207e98:	01c00084 	movi	r7,2
 8207e9c:	980d883a 	mov	r6,r19
 8207ea0:	d8c03c15 	stw	r3,240(sp)
 8207ea4:	da003d15 	stw	r8,244(sp)
 8207ea8:	8208f040 	call	8208f04 <_dtoa_r>
 8207eac:	1021883a 	mov	r16,r2
 8207eb0:	008019c4 	movi	r2,103
 8207eb4:	d8c03c17 	ldw	r3,240(sp)
 8207eb8:	da003d17 	ldw	r8,244(sp)
 8207ebc:	88817126 	beq	r17,r2,8208484 <___vfprintf_internal_r+0x1cfc>
 8207ec0:	008011c4 	movi	r2,71
 8207ec4:	88829226 	beq	r17,r2,8208910 <___vfprintf_internal_r+0x2188>
 8207ec8:	80f9883a 	add	fp,r16,r3
 8207ecc:	d9003617 	ldw	r4,216(sp)
 8207ed0:	000d883a 	mov	r6,zero
 8207ed4:	000f883a 	mov	r7,zero
 8207ed8:	980b883a 	mov	r5,r19
 8207edc:	da003d15 	stw	r8,244(sp)
 8207ee0:	8212c480 	call	8212c48 <__eqdf2>
 8207ee4:	da003d17 	ldw	r8,244(sp)
 8207ee8:	10018d26 	beq	r2,zero,8208520 <___vfprintf_internal_r+0x1d98>
 8207eec:	d8802117 	ldw	r2,132(sp)
 8207ef0:	1700062e 	bgeu	r2,fp,8207f0c <___vfprintf_internal_r+0x1784>
 8207ef4:	01000c04 	movi	r4,48
 8207ef8:	10c00044 	addi	r3,r2,1
 8207efc:	d8c02115 	stw	r3,132(sp)
 8207f00:	11000005 	stb	r4,0(r2)
 8207f04:	d8802117 	ldw	r2,132(sp)
 8207f08:	173ffb36 	bltu	r2,fp,8207ef8 <___vfprintf_internal_r+0x1770>
 8207f0c:	1405c83a 	sub	r2,r2,r16
 8207f10:	d8803315 	stw	r2,204(sp)
 8207f14:	008011c4 	movi	r2,71
 8207f18:	b0817626 	beq	r22,r2,82084f4 <___vfprintf_internal_r+0x1d6c>
 8207f1c:	00801944 	movi	r2,101
 8207f20:	1442810e 	bge	r2,r17,8208928 <___vfprintf_internal_r+0x21a0>
 8207f24:	d8c02617 	ldw	r3,152(sp)
 8207f28:	00801984 	movi	r2,102
 8207f2c:	d8c03215 	stw	r3,200(sp)
 8207f30:	8881fe26 	beq	r17,r2,820872c <___vfprintf_internal_r+0x1fa4>
 8207f34:	d8c03217 	ldw	r3,200(sp)
 8207f38:	d9003317 	ldw	r4,204(sp)
 8207f3c:	1901dd16 	blt	r3,r4,82086b4 <___vfprintf_internal_r+0x1f2c>
 8207f40:	9480004c 	andi	r18,r18,1
 8207f44:	90022b1e 	bne	r18,zero,82087f4 <___vfprintf_internal_r+0x206c>
 8207f48:	1805883a 	mov	r2,r3
 8207f4c:	18028016 	blt	r3,zero,8208950 <___vfprintf_internal_r+0x21c8>
 8207f50:	d8c03217 	ldw	r3,200(sp)
 8207f54:	044019c4 	movi	r17,103
 8207f58:	d8c02e15 	stw	r3,184(sp)
 8207f5c:	df002a07 	ldb	fp,168(sp)
 8207f60:	e001531e 	bne	fp,zero,82084b0 <___vfprintf_internal_r+0x1d28>
 8207f64:	df002783 	ldbu	fp,158(sp)
 8207f68:	d8802a15 	stw	r2,168(sp)
 8207f6c:	dc802b17 	ldw	r18,172(sp)
 8207f70:	d8002915 	stw	zero,164(sp)
 8207f74:	003bd106 	br	8206ebc <___vfprintf_internal_r+0x734>
 8207f78:	d8802d17 	ldw	r2,180(sp)
 8207f7c:	d8c02d17 	ldw	r3,180(sp)
 8207f80:	d9002d17 	ldw	r4,180(sp)
 8207f84:	10800017 	ldw	r2,0(r2)
 8207f88:	18c00117 	ldw	r3,4(r3)
 8207f8c:	21000204 	addi	r4,r4,8
 8207f90:	d8803615 	stw	r2,216(sp)
 8207f94:	d8c03815 	stw	r3,224(sp)
 8207f98:	d9002d15 	stw	r4,180(sp)
 8207f9c:	003b7506 	br	8206d74 <___vfprintf_internal_r+0x5ec>
 8207fa0:	ac400007 	ldb	r17,0(r21)
 8207fa4:	003a5906 	br	820690c <___vfprintf_internal_r+0x184>
 8207fa8:	9080100c 	andi	r2,r18,64
 8207fac:	1000a826 	beq	r2,zero,8208250 <___vfprintf_internal_r+0x1ac8>
 8207fb0:	d9002d17 	ldw	r4,180(sp)
 8207fb4:	002d883a 	mov	r22,zero
 8207fb8:	24c0000b 	ldhu	r19,0(r4)
 8207fbc:	21000104 	addi	r4,r4,4
 8207fc0:	d9002d15 	stw	r4,180(sp)
 8207fc4:	003ccb06 	br	82072f4 <___vfprintf_internal_r+0xb6c>
 8207fc8:	d8c02d17 	ldw	r3,180(sp)
 8207fcc:	d9002917 	ldw	r4,164(sp)
 8207fd0:	002d883a 	mov	r22,zero
 8207fd4:	18800104 	addi	r2,r3,4
 8207fd8:	1cc00017 	ldw	r19,0(r3)
 8207fdc:	203ebb0e 	bge	r4,zero,8207acc <___vfprintf_internal_r+0x1344>
 8207fe0:	003ef106 	br	8207ba8 <___vfprintf_internal_r+0x1420>
 8207fe4:	9080040c 	andi	r2,r18,16
 8207fe8:	1000921e 	bne	r2,zero,8208234 <___vfprintf_internal_r+0x1aac>
 8207fec:	9480100c 	andi	r18,r18,64
 8207ff0:	90013926 	beq	r18,zero,82084d8 <___vfprintf_internal_r+0x1d50>
 8207ff4:	d9002d17 	ldw	r4,180(sp)
 8207ff8:	d9402f17 	ldw	r5,188(sp)
 8207ffc:	20800017 	ldw	r2,0(r4)
 8208000:	21000104 	addi	r4,r4,4
 8208004:	d9002d15 	stw	r4,180(sp)
 8208008:	1140000d 	sth	r5,0(r2)
 820800c:	003a1606 	br	8206868 <___vfprintf_internal_r+0xe0>
 8208010:	9080100c 	andi	r2,r18,64
 8208014:	10008026 	beq	r2,zero,8208218 <___vfprintf_internal_r+0x1a90>
 8208018:	d8c02d17 	ldw	r3,180(sp)
 820801c:	1cc0000f 	ldh	r19,0(r3)
 8208020:	18c00104 	addi	r3,r3,4
 8208024:	d8c02d15 	stw	r3,180(sp)
 8208028:	982dd7fa 	srai	r22,r19,31
 820802c:	b005883a 	mov	r2,r22
 8208030:	003b1f06 	br	8206cb0 <___vfprintf_internal_r+0x528>
 8208034:	9080100c 	andi	r2,r18,64
 8208038:	d8002785 	stb	zero,158(sp)
 820803c:	10008a1e 	bne	r2,zero,8208268 <___vfprintf_internal_r+0x1ae0>
 8208040:	d9402d17 	ldw	r5,180(sp)
 8208044:	d8c02917 	ldw	r3,164(sp)
 8208048:	002d883a 	mov	r22,zero
 820804c:	28800104 	addi	r2,r5,4
 8208050:	2cc00017 	ldw	r19,0(r5)
 8208054:	183e4b0e 	bge	r3,zero,8207984 <___vfprintf_internal_r+0x11fc>
 8208058:	9d86b03a 	or	r3,r19,r22
 820805c:	d8802d15 	stw	r2,180(sp)
 8208060:	183e4c1e 	bne	r3,zero,8207994 <___vfprintf_internal_r+0x120c>
 8208064:	0039883a 	mov	fp,zero
 8208068:	0005883a 	mov	r2,zero
 820806c:	003d4006 	br	8207570 <___vfprintf_internal_r+0xde8>
 8208070:	01420974 	movhi	r5,2085
 8208074:	2975f184 	addi	r5,r5,-10298
 8208078:	d9402b15 	stw	r5,172(sp)
 820807c:	d9402b17 	ldw	r5,172(sp)
 8208080:	1c47883a 	add	r3,r3,r17
 8208084:	10800044 	addi	r2,r2,1
 8208088:	41400015 	stw	r5,0(r8)
 820808c:	44400115 	stw	r17,4(r8)
 8208090:	d8c02015 	stw	r3,128(sp)
 8208094:	d8801f15 	stw	r2,124(sp)
 8208098:	010001c4 	movi	r4,7
 820809c:	20bec816 	blt	r4,r2,8207bc0 <___vfprintf_internal_r+0x1438>
 82080a0:	42000204 	addi	r8,r8,8
 82080a4:	003ecd06 	br	8207bdc <___vfprintf_internal_r+0x1454>
 82080a8:	d9002917 	ldw	r4,164(sp)
 82080ac:	d8002785 	stb	zero,158(sp)
 82080b0:	203d2d16 	blt	r4,zero,8207568 <___vfprintf_internal_r+0xde0>
 82080b4:	00bfdfc4 	movi	r2,-129
 82080b8:	90a4703a 	and	r18,r18,r2
 82080bc:	003a9106 	br	8206b04 <___vfprintf_internal_r+0x37c>
 82080c0:	01020974 	movhi	r4,2085
 82080c4:	2135f184 	addi	r4,r4,-10298
 82080c8:	d9002b15 	stw	r4,172(sp)
 82080cc:	003c0c06 	br	8207100 <___vfprintf_internal_r+0x978>
 82080d0:	d9002c17 	ldw	r4,176(sp)
 82080d4:	d9801e04 	addi	r6,sp,120
 82080d8:	b80b883a 	mov	r5,r23
 82080dc:	820f2dc0 	call	820f2dc <__sprint_r>
 82080e0:	103aab1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82080e4:	d8c02017 	ldw	r3,128(sp)
 82080e8:	da000404 	addi	r8,sp,16
 82080ec:	003d4106 	br	82075f4 <___vfprintf_internal_r+0xe6c>
 82080f0:	d8801f17 	ldw	r2,124(sp)
 82080f4:	01420974 	movhi	r5,2085
 82080f8:	01000044 	movi	r4,1
 82080fc:	18c00044 	addi	r3,r3,1
 8208100:	10800044 	addi	r2,r2,1
 8208104:	2975e904 	addi	r5,r5,-10332
 8208108:	41000115 	stw	r4,4(r8)
 820810c:	41400015 	stw	r5,0(r8)
 8208110:	d8c02015 	stw	r3,128(sp)
 8208114:	d8801f15 	stw	r2,124(sp)
 8208118:	010001c4 	movi	r4,7
 820811c:	20805c16 	blt	r4,r2,8208290 <___vfprintf_internal_r+0x1b08>
 8208120:	42000204 	addi	r8,r8,8
 8208124:	8800041e 	bne	r17,zero,8208138 <___vfprintf_internal_r+0x19b0>
 8208128:	d8803317 	ldw	r2,204(sp)
 820812c:	1000021e 	bne	r2,zero,8208138 <___vfprintf_internal_r+0x19b0>
 8208130:	9080004c 	andi	r2,r18,1
 8208134:	103c0926 	beq	r2,zero,820715c <___vfprintf_internal_r+0x9d4>
 8208138:	d9003717 	ldw	r4,220(sp)
 820813c:	d8801f17 	ldw	r2,124(sp)
 8208140:	d9403417 	ldw	r5,208(sp)
 8208144:	20c7883a 	add	r3,r4,r3
 8208148:	10800044 	addi	r2,r2,1
 820814c:	41000115 	stw	r4,4(r8)
 8208150:	41400015 	stw	r5,0(r8)
 8208154:	d8c02015 	stw	r3,128(sp)
 8208158:	d8801f15 	stw	r2,124(sp)
 820815c:	010001c4 	movi	r4,7
 8208160:	20812116 	blt	r4,r2,82085e8 <___vfprintf_internal_r+0x1e60>
 8208164:	42000204 	addi	r8,r8,8
 8208168:	0463c83a 	sub	r17,zero,r17
 820816c:	0440730e 	bge	zero,r17,820833c <___vfprintf_internal_r+0x1bb4>
 8208170:	05800404 	movi	r22,16
 8208174:	b440860e 	bge	r22,r17,8208390 <___vfprintf_internal_r+0x1c08>
 8208178:	01420974 	movhi	r5,2085
 820817c:	2975f184 	addi	r5,r5,-10298
 8208180:	d9402b15 	stw	r5,172(sp)
 8208184:	070001c4 	movi	fp,7
 8208188:	dcc02c17 	ldw	r19,176(sp)
 820818c:	00000306 	br	820819c <___vfprintf_internal_r+0x1a14>
 8208190:	42000204 	addi	r8,r8,8
 8208194:	8c7ffc04 	addi	r17,r17,-16
 8208198:	b440800e 	bge	r22,r17,820839c <___vfprintf_internal_r+0x1c14>
 820819c:	18c00404 	addi	r3,r3,16
 82081a0:	10800044 	addi	r2,r2,1
 82081a4:	45000015 	stw	r20,0(r8)
 82081a8:	45800115 	stw	r22,4(r8)
 82081ac:	d8c02015 	stw	r3,128(sp)
 82081b0:	d8801f15 	stw	r2,124(sp)
 82081b4:	e0bff60e 	bge	fp,r2,8208190 <___vfprintf_internal_r+0x1a08>
 82081b8:	d9801e04 	addi	r6,sp,120
 82081bc:	b80b883a 	mov	r5,r23
 82081c0:	9809883a 	mov	r4,r19
 82081c4:	820f2dc0 	call	820f2dc <__sprint_r>
 82081c8:	103a711e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82081cc:	d8c02017 	ldw	r3,128(sp)
 82081d0:	d8801f17 	ldw	r2,124(sp)
 82081d4:	da000404 	addi	r8,sp,16
 82081d8:	003fee06 	br	8208194 <___vfprintf_internal_r+0x1a0c>
 82081dc:	00bfffc4 	movi	r2,-1
 82081e0:	003a6f06 	br	8206ba0 <___vfprintf_internal_r+0x418>
 82081e4:	008011c4 	movi	r2,71
 82081e8:	1440b816 	blt	r2,r17,82084cc <___vfprintf_internal_r+0x1d44>
 82081ec:	04020974 	movhi	r16,2085
 82081f0:	8435db04 	addi	r16,r16,-10388
 82081f4:	00c000c4 	movi	r3,3
 82081f8:	00bfdfc4 	movi	r2,-129
 82081fc:	d8c02a15 	stw	r3,168(sp)
 8208200:	90a4703a 	and	r18,r18,r2
 8208204:	df002783 	ldbu	fp,158(sp)
 8208208:	d8c02e15 	stw	r3,184(sp)
 820820c:	d8002915 	stw	zero,164(sp)
 8208210:	d8003215 	stw	zero,200(sp)
 8208214:	003b2906 	br	8206ebc <___vfprintf_internal_r+0x734>
 8208218:	d9002d17 	ldw	r4,180(sp)
 820821c:	24c00017 	ldw	r19,0(r4)
 8208220:	21000104 	addi	r4,r4,4
 8208224:	d9002d15 	stw	r4,180(sp)
 8208228:	982dd7fa 	srai	r22,r19,31
 820822c:	b005883a 	mov	r2,r22
 8208230:	003a9f06 	br	8206cb0 <___vfprintf_internal_r+0x528>
 8208234:	d9402d17 	ldw	r5,180(sp)
 8208238:	d8c02f17 	ldw	r3,188(sp)
 820823c:	28800017 	ldw	r2,0(r5)
 8208240:	29400104 	addi	r5,r5,4
 8208244:	d9402d15 	stw	r5,180(sp)
 8208248:	10c00015 	stw	r3,0(r2)
 820824c:	00398606 	br	8206868 <___vfprintf_internal_r+0xe0>
 8208250:	d9402d17 	ldw	r5,180(sp)
 8208254:	002d883a 	mov	r22,zero
 8208258:	2cc00017 	ldw	r19,0(r5)
 820825c:	29400104 	addi	r5,r5,4
 8208260:	d9402d15 	stw	r5,180(sp)
 8208264:	003c2306 	br	82072f4 <___vfprintf_internal_r+0xb6c>
 8208268:	d8c02d17 	ldw	r3,180(sp)
 820826c:	d9002917 	ldw	r4,164(sp)
 8208270:	002d883a 	mov	r22,zero
 8208274:	18800104 	addi	r2,r3,4
 8208278:	1cc0000b 	ldhu	r19,0(r3)
 820827c:	203dc10e 	bge	r4,zero,8207984 <___vfprintf_internal_r+0x11fc>
 8208280:	003f7506 	br	8208058 <___vfprintf_internal_r+0x18d0>
 8208284:	04020974 	movhi	r16,2085
 8208288:	8435d904 	addi	r16,r16,-10396
 820828c:	003acc06 	br	8206dc0 <___vfprintf_internal_r+0x638>
 8208290:	d9002c17 	ldw	r4,176(sp)
 8208294:	d9801e04 	addi	r6,sp,120
 8208298:	b80b883a 	mov	r5,r23
 820829c:	820f2dc0 	call	820f2dc <__sprint_r>
 82082a0:	103a3b1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82082a4:	dc402617 	ldw	r17,152(sp)
 82082a8:	d8c02017 	ldw	r3,128(sp)
 82082ac:	da000404 	addi	r8,sp,16
 82082b0:	003f9c06 	br	8208124 <___vfprintf_internal_r+0x199c>
 82082b4:	ac400043 	ldbu	r17,1(r21)
 82082b8:	94800814 	ori	r18,r18,32
 82082bc:	ad400044 	addi	r21,r21,1
 82082c0:	8c403fcc 	andi	r17,r17,255
 82082c4:	8c40201c 	xori	r17,r17,128
 82082c8:	8c7fe004 	addi	r17,r17,-128
 82082cc:	00398f06 	br	820690c <___vfprintf_internal_r+0x184>
 82082d0:	d8c02d15 	stw	r3,180(sp)
 82082d4:	0039883a 	mov	fp,zero
 82082d8:	003e3506 	br	8207bb0 <___vfprintf_internal_r+0x1428>
 82082dc:	d9002c17 	ldw	r4,176(sp)
 82082e0:	d9801e04 	addi	r6,sp,120
 82082e4:	b80b883a 	mov	r5,r23
 82082e8:	820f2dc0 	call	820f2dc <__sprint_r>
 82082ec:	103a281e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82082f0:	d8c02017 	ldw	r3,128(sp)
 82082f4:	da000404 	addi	r8,sp,16
 82082f8:	003cd006 	br	820763c <___vfprintf_internal_r+0xeb4>
 82082fc:	8009883a 	mov	r4,r16
 8208300:	da003d15 	stw	r8,244(sp)
 8208304:	8203cac0 	call	8203cac <strlen>
 8208308:	d8802e15 	stw	r2,184(sp)
 820830c:	da003d17 	ldw	r8,244(sp)
 8208310:	103c340e 	bge	r2,zero,82073e4 <___vfprintf_internal_r+0xc5c>
 8208314:	0005883a 	mov	r2,zero
 8208318:	003c3206 	br	82073e4 <___vfprintf_internal_r+0xc5c>
 820831c:	d9002c17 	ldw	r4,176(sp)
 8208320:	d9801e04 	addi	r6,sp,120
 8208324:	b80b883a 	mov	r5,r23
 8208328:	820f2dc0 	call	820f2dc <__sprint_r>
 820832c:	103a181e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8208330:	d8c02017 	ldw	r3,128(sp)
 8208334:	d8801f17 	ldw	r2,124(sp)
 8208338:	da000404 	addi	r8,sp,16
 820833c:	d9403317 	ldw	r5,204(sp)
 8208340:	10800044 	addi	r2,r2,1
 8208344:	44000015 	stw	r16,0(r8)
 8208348:	28c7883a 	add	r3,r5,r3
 820834c:	003b7d06 	br	8207144 <___vfprintf_internal_r+0x9bc>
 8208350:	01020974 	movhi	r4,2085
 8208354:	2135f584 	addi	r4,r4,-10282
 8208358:	d9003515 	stw	r4,212(sp)
 820835c:	003b1406 	br	8206fb0 <___vfprintf_internal_r+0x828>
 8208360:	013fffc4 	movi	r4,-1
 8208364:	003a3506 	br	8206c3c <___vfprintf_internal_r+0x4b4>
 8208368:	0023883a 	mov	r17,zero
 820836c:	003d9d06 	br	82079e4 <___vfprintf_internal_r+0x125c>
 8208370:	d9002c17 	ldw	r4,176(sp)
 8208374:	d9801e04 	addi	r6,sp,120
 8208378:	b80b883a 	mov	r5,r23
 820837c:	820f2dc0 	call	820f2dc <__sprint_r>
 8208380:	103a031e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 8208384:	d8c02017 	ldw	r3,128(sp)
 8208388:	da000404 	addi	r8,sp,16
 820838c:	003d9406 	br	82079e0 <___vfprintf_internal_r+0x1258>
 8208390:	01020974 	movhi	r4,2085
 8208394:	2135f184 	addi	r4,r4,-10298
 8208398:	d9002b15 	stw	r4,172(sp)
 820839c:	d9002b17 	ldw	r4,172(sp)
 82083a0:	1c47883a 	add	r3,r3,r17
 82083a4:	10800044 	addi	r2,r2,1
 82083a8:	41000015 	stw	r4,0(r8)
 82083ac:	44400115 	stw	r17,4(r8)
 82083b0:	d8c02015 	stw	r3,128(sp)
 82083b4:	d8801f15 	stw	r2,124(sp)
 82083b8:	010001c4 	movi	r4,7
 82083bc:	20bfd716 	blt	r4,r2,820831c <___vfprintf_internal_r+0x1b94>
 82083c0:	42000204 	addi	r8,r8,8
 82083c4:	003fdd06 	br	820833c <___vfprintf_internal_r+0x1bb4>
 82083c8:	d9002c17 	ldw	r4,176(sp)
 82083cc:	d9801e04 	addi	r6,sp,120
 82083d0:	b80b883a 	mov	r5,r23
 82083d4:	820f2dc0 	call	820f2dc <__sprint_r>
 82083d8:	1039ed1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82083dc:	d8802617 	ldw	r2,152(sp)
 82083e0:	d8c02017 	ldw	r3,128(sp)
 82083e4:	da000404 	addi	r8,sp,16
 82083e8:	003e1006 	br	8207c2c <___vfprintf_internal_r+0x14a4>
 82083ec:	00800044 	movi	r2,1
 82083f0:	10803fcc 	andi	r2,r2,255
 82083f4:	00c00044 	movi	r3,1
 82083f8:	10fa3526 	beq	r2,r3,8206cd0 <___vfprintf_internal_r+0x548>
 82083fc:	00c00084 	movi	r3,2
 8208400:	10fbcb26 	beq	r2,r3,8207330 <___vfprintf_internal_r+0xba8>
 8208404:	003a8f06 	br	8206e44 <___vfprintf_internal_r+0x6bc>
 8208408:	01020974 	movhi	r4,2085
 820840c:	2135f584 	addi	r4,r4,-10282
 8208410:	d9003515 	stw	r4,212(sp)
 8208414:	003b7606 	br	82071f0 <___vfprintf_internal_r+0xa68>
 8208418:	d8802917 	ldw	r2,164(sp)
 820841c:	00c00184 	movi	r3,6
 8208420:	1880012e 	bgeu	r3,r2,8208428 <___vfprintf_internal_r+0x1ca0>
 8208424:	1805883a 	mov	r2,r3
 8208428:	d8802e15 	stw	r2,184(sp)
 820842c:	1000ef16 	blt	r2,zero,82087ec <___vfprintf_internal_r+0x2064>
 8208430:	04020974 	movhi	r16,2085
 8208434:	d8802a15 	stw	r2,168(sp)
 8208438:	dcc02d15 	stw	r19,180(sp)
 820843c:	d8002915 	stw	zero,164(sp)
 8208440:	d8003215 	stw	zero,200(sp)
 8208444:	8435e704 	addi	r16,r16,-10340
 8208448:	0039883a 	mov	fp,zero
 820844c:	003aa206 	br	8206ed8 <___vfprintf_internal_r+0x750>
 8208450:	0021883a 	mov	r16,zero
 8208454:	003e0706 	br	8207c74 <___vfprintf_internal_r+0x14ec>
 8208458:	d9002c17 	ldw	r4,176(sp)
 820845c:	d9801e04 	addi	r6,sp,120
 8208460:	b80b883a 	mov	r5,r23
 8208464:	820f2dc0 	call	820f2dc <__sprint_r>
 8208468:	1039c91e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 820846c:	d8802617 	ldw	r2,152(sp)
 8208470:	d9403317 	ldw	r5,204(sp)
 8208474:	d8c02017 	ldw	r3,128(sp)
 8208478:	da000404 	addi	r8,sp,16
 820847c:	2885c83a 	sub	r2,r5,r2
 8208480:	003dfb06 	br	8207c70 <___vfprintf_internal_r+0x14e8>
 8208484:	9080004c 	andi	r2,r18,1
 8208488:	103e8f1e 	bne	r2,zero,8207ec8 <___vfprintf_internal_r+0x1740>
 820848c:	d8802117 	ldw	r2,132(sp)
 8208490:	003e9e06 	br	8207f0c <___vfprintf_internal_r+0x1784>
 8208494:	1025883a 	mov	r18,r2
 8208498:	0039883a 	mov	fp,zero
 820849c:	00800084 	movi	r2,2
 82084a0:	003fd306 	br	82083f0 <___vfprintf_internal_r+0x1c68>
 82084a4:	07000b44 	movi	fp,45
 82084a8:	df002785 	stb	fp,158(sp)
 82084ac:	003a4006 	br	8206db0 <___vfprintf_internal_r+0x628>
 82084b0:	00c00b44 	movi	r3,45
 82084b4:	d8c02785 	stb	r3,158(sp)
 82084b8:	d8802a15 	stw	r2,168(sp)
 82084bc:	dc802b17 	ldw	r18,172(sp)
 82084c0:	d8002915 	stw	zero,164(sp)
 82084c4:	07000b44 	movi	fp,45
 82084c8:	003a8006 	br	8206ecc <___vfprintf_internal_r+0x744>
 82084cc:	04020974 	movhi	r16,2085
 82084d0:	8435dc04 	addi	r16,r16,-10384
 82084d4:	003f4706 	br	82081f4 <___vfprintf_internal_r+0x1a6c>
 82084d8:	d8c02d17 	ldw	r3,180(sp)
 82084dc:	d9002f17 	ldw	r4,188(sp)
 82084e0:	18800017 	ldw	r2,0(r3)
 82084e4:	18c00104 	addi	r3,r3,4
 82084e8:	d8c02d15 	stw	r3,180(sp)
 82084ec:	11000015 	stw	r4,0(r2)
 82084f0:	0038dd06 	br	8206868 <___vfprintf_internal_r+0xe0>
 82084f4:	dd802617 	ldw	r22,152(sp)
 82084f8:	00bfff44 	movi	r2,-3
 82084fc:	b0801c16 	blt	r22,r2,8208570 <___vfprintf_internal_r+0x1de8>
 8208500:	d9402917 	ldw	r5,164(sp)
 8208504:	2d801a16 	blt	r5,r22,8208570 <___vfprintf_internal_r+0x1de8>
 8208508:	dd803215 	stw	r22,200(sp)
 820850c:	003e8906 	br	8207f34 <___vfprintf_internal_r+0x17ac>
 8208510:	01020974 	movhi	r4,2085
 8208514:	2135f184 	addi	r4,r4,-10298
 8208518:	d9002b15 	stw	r4,172(sp)
 820851c:	003c9106 	br	8207764 <___vfprintf_internal_r+0xfdc>
 8208520:	e005883a 	mov	r2,fp
 8208524:	003e7906 	br	8207f0c <___vfprintf_internal_r+0x1784>
 8208528:	d9402917 	ldw	r5,164(sp)
 820852c:	df002783 	ldbu	fp,158(sp)
 8208530:	dcc02d15 	stw	r19,180(sp)
 8208534:	d9402a15 	stw	r5,168(sp)
 8208538:	d9402e15 	stw	r5,184(sp)
 820853c:	d8002915 	stw	zero,164(sp)
 8208540:	d8003215 	stw	zero,200(sp)
 8208544:	003a5d06 	br	8206ebc <___vfprintf_internal_r+0x734>
 8208548:	9080004c 	andi	r2,r18,1
 820854c:	0039883a 	mov	fp,zero
 8208550:	10000426 	beq	r2,zero,8208564 <___vfprintf_internal_r+0x1ddc>
 8208554:	00800c04 	movi	r2,48
 8208558:	dc001dc4 	addi	r16,sp,119
 820855c:	d8801dc5 	stb	r2,119(sp)
 8208560:	003b8006 	br	8207364 <___vfprintf_internal_r+0xbdc>
 8208564:	d8002e15 	stw	zero,184(sp)
 8208568:	dc001e04 	addi	r16,sp,120
 820856c:	003a4d06 	br	8206ea4 <___vfprintf_internal_r+0x71c>
 8208570:	8c7fff84 	addi	r17,r17,-2
 8208574:	b5bfffc4 	addi	r22,r22,-1
 8208578:	dd802615 	stw	r22,152(sp)
 820857c:	dc4022c5 	stb	r17,139(sp)
 8208580:	b000bf16 	blt	r22,zero,8208880 <___vfprintf_internal_r+0x20f8>
 8208584:	00800ac4 	movi	r2,43
 8208588:	d8802305 	stb	r2,140(sp)
 820858c:	00800244 	movi	r2,9
 8208590:	15807016 	blt	r2,r22,8208754 <___vfprintf_internal_r+0x1fcc>
 8208594:	00800c04 	movi	r2,48
 8208598:	b5800c04 	addi	r22,r22,48
 820859c:	d8802345 	stb	r2,141(sp)
 82085a0:	dd802385 	stb	r22,142(sp)
 82085a4:	d88023c4 	addi	r2,sp,143
 82085a8:	df0022c4 	addi	fp,sp,139
 82085ac:	d8c03317 	ldw	r3,204(sp)
 82085b0:	1739c83a 	sub	fp,r2,fp
 82085b4:	d9003317 	ldw	r4,204(sp)
 82085b8:	e0c7883a 	add	r3,fp,r3
 82085bc:	df003a15 	stw	fp,232(sp)
 82085c0:	d8c02e15 	stw	r3,184(sp)
 82085c4:	00800044 	movi	r2,1
 82085c8:	1100b30e 	bge	r2,r4,8208898 <___vfprintf_internal_r+0x2110>
 82085cc:	d8c02e17 	ldw	r3,184(sp)
 82085d0:	18c00044 	addi	r3,r3,1
 82085d4:	d8c02e15 	stw	r3,184(sp)
 82085d8:	1805883a 	mov	r2,r3
 82085dc:	1800ac16 	blt	r3,zero,8208890 <___vfprintf_internal_r+0x2108>
 82085e0:	d8003215 	stw	zero,200(sp)
 82085e4:	003e5d06 	br	8207f5c <___vfprintf_internal_r+0x17d4>
 82085e8:	d9002c17 	ldw	r4,176(sp)
 82085ec:	d9801e04 	addi	r6,sp,120
 82085f0:	b80b883a 	mov	r5,r23
 82085f4:	820f2dc0 	call	820f2dc <__sprint_r>
 82085f8:	1039651e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0x408>
 82085fc:	dc402617 	ldw	r17,152(sp)
 8208600:	d8c02017 	ldw	r3,128(sp)
 8208604:	d8801f17 	ldw	r2,124(sp)
 8208608:	da000404 	addi	r8,sp,16
 820860c:	003ed606 	br	8208168 <___vfprintf_internal_r+0x19e0>
 8208610:	582b883a 	mov	r21,r11
 8208614:	d8002915 	stw	zero,164(sp)
 8208618:	0038bd06 	br	8206910 <___vfprintf_internal_r+0x188>
 820861c:	d8802917 	ldw	r2,164(sp)
 8208620:	103e071e 	bne	r2,zero,8207e40 <___vfprintf_internal_r+0x16b8>
 8208624:	dc002915 	stw	r16,164(sp)
 8208628:	003e0506 	br	8207e40 <___vfprintf_internal_r+0x16b8>
 820862c:	d9002917 	ldw	r4,164(sp)
 8208630:	20c00044 	addi	r3,r4,1
 8208634:	003e0f06 	br	8207e74 <___vfprintf_internal_r+0x16ec>
 8208638:	01400184 	movi	r5,6
 820863c:	d9402915 	stw	r5,164(sp)
 8208640:	003dff06 	br	8207e40 <___vfprintf_internal_r+0x16b8>
 8208644:	d8802104 	addi	r2,sp,132
 8208648:	d8800315 	stw	r2,12(sp)
 820864c:	d8802504 	addi	r2,sp,148
 8208650:	d8800215 	stw	r2,8(sp)
 8208654:	d8802604 	addi	r2,sp,152
 8208658:	d8800115 	stw	r2,4(sp)
 820865c:	d8802917 	ldw	r2,164(sp)
 8208660:	d9403617 	ldw	r5,216(sp)
 8208664:	d9002c17 	ldw	r4,176(sp)
 8208668:	d8800015 	stw	r2,0(sp)
 820866c:	01c000c4 	movi	r7,3
 8208670:	980d883a 	mov	r6,r19
 8208674:	da003d15 	stw	r8,244(sp)
 8208678:	8208f040 	call	8208f04 <_dtoa_r>
 820867c:	d8c02917 	ldw	r3,164(sp)
 8208680:	da003d17 	ldw	r8,244(sp)
 8208684:	1021883a 	mov	r16,r2
 8208688:	10f9883a 	add	fp,r2,r3
 820868c:	81000007 	ldb	r4,0(r16)
 8208690:	00800c04 	movi	r2,48
 8208694:	20805e26 	beq	r4,r2,8208810 <___vfprintf_internal_r+0x2088>
 8208698:	d8c02617 	ldw	r3,152(sp)
 820869c:	e0f9883a 	add	fp,fp,r3
 82086a0:	003e0a06 	br	8207ecc <___vfprintf_internal_r+0x1744>
 82086a4:	00c00b44 	movi	r3,45
 82086a8:	24e0003c 	xorhi	r19,r4,32768
 82086ac:	d8c02a05 	stb	r3,168(sp)
 82086b0:	003de906 	br	8207e58 <___vfprintf_internal_r+0x16d0>
 82086b4:	d8c03217 	ldw	r3,200(sp)
 82086b8:	00c07a0e 	bge	zero,r3,82088a4 <___vfprintf_internal_r+0x211c>
 82086bc:	00800044 	movi	r2,1
 82086c0:	d9003317 	ldw	r4,204(sp)
 82086c4:	1105883a 	add	r2,r2,r4
 82086c8:	d8802e15 	stw	r2,184(sp)
 82086cc:	10004e16 	blt	r2,zero,8208808 <___vfprintf_internal_r+0x2080>
 82086d0:	044019c4 	movi	r17,103
 82086d4:	003e2106 	br	8207f5c <___vfprintf_internal_r+0x17d4>
 82086d8:	d9002917 	ldw	r4,164(sp)
 82086dc:	d8802104 	addi	r2,sp,132
 82086e0:	d8800315 	stw	r2,12(sp)
 82086e4:	d9000015 	stw	r4,0(sp)
 82086e8:	d8802504 	addi	r2,sp,148
 82086ec:	d9403617 	ldw	r5,216(sp)
 82086f0:	d9002c17 	ldw	r4,176(sp)
 82086f4:	d8800215 	stw	r2,8(sp)
 82086f8:	d8802604 	addi	r2,sp,152
 82086fc:	d8800115 	stw	r2,4(sp)
 8208700:	01c000c4 	movi	r7,3
 8208704:	980d883a 	mov	r6,r19
 8208708:	da003d15 	stw	r8,244(sp)
 820870c:	8208f040 	call	8208f04 <_dtoa_r>
 8208710:	d8c02917 	ldw	r3,164(sp)
 8208714:	da003d17 	ldw	r8,244(sp)
 8208718:	1021883a 	mov	r16,r2
 820871c:	00801184 	movi	r2,70
 8208720:	80f9883a 	add	fp,r16,r3
 8208724:	88bfd926 	beq	r17,r2,820868c <___vfprintf_internal_r+0x1f04>
 8208728:	003de806 	br	8207ecc <___vfprintf_internal_r+0x1744>
 820872c:	d9002917 	ldw	r4,164(sp)
 8208730:	00c04d0e 	bge	zero,r3,8208868 <___vfprintf_internal_r+0x20e0>
 8208734:	2000441e 	bne	r4,zero,8208848 <___vfprintf_internal_r+0x20c0>
 8208738:	9480004c 	andi	r18,r18,1
 820873c:	9000421e 	bne	r18,zero,8208848 <___vfprintf_internal_r+0x20c0>
 8208740:	1805883a 	mov	r2,r3
 8208744:	18007016 	blt	r3,zero,8208908 <___vfprintf_internal_r+0x2180>
 8208748:	d8c03217 	ldw	r3,200(sp)
 820874c:	d8c02e15 	stw	r3,184(sp)
 8208750:	003e0206 	br	8207f5c <___vfprintf_internal_r+0x17d4>
 8208754:	df0022c4 	addi	fp,sp,139
 8208758:	dc002915 	stw	r16,164(sp)
 820875c:	4027883a 	mov	r19,r8
 8208760:	e021883a 	mov	r16,fp
 8208764:	b009883a 	mov	r4,r22
 8208768:	01400284 	movi	r5,10
 820876c:	82028e80 	call	82028e8 <__modsi3>
 8208770:	10800c04 	addi	r2,r2,48
 8208774:	843fffc4 	addi	r16,r16,-1
 8208778:	b009883a 	mov	r4,r22
 820877c:	01400284 	movi	r5,10
 8208780:	80800005 	stb	r2,0(r16)
 8208784:	82028640 	call	8202864 <__divsi3>
 8208788:	102d883a 	mov	r22,r2
 820878c:	00800244 	movi	r2,9
 8208790:	15bff416 	blt	r2,r22,8208764 <___vfprintf_internal_r+0x1fdc>
 8208794:	9811883a 	mov	r8,r19
 8208798:	b0800c04 	addi	r2,r22,48
 820879c:	8027883a 	mov	r19,r16
 82087a0:	997fffc4 	addi	r5,r19,-1
 82087a4:	98bfffc5 	stb	r2,-1(r19)
 82087a8:	dc002917 	ldw	r16,164(sp)
 82087ac:	2f006a2e 	bgeu	r5,fp,8208958 <___vfprintf_internal_r+0x21d0>
 82087b0:	d9c02384 	addi	r7,sp,142
 82087b4:	3ccfc83a 	sub	r7,r7,r19
 82087b8:	d9002344 	addi	r4,sp,141
 82087bc:	e1cf883a 	add	r7,fp,r7
 82087c0:	00000106 	br	82087c8 <___vfprintf_internal_r+0x2040>
 82087c4:	28800003 	ldbu	r2,0(r5)
 82087c8:	20800005 	stb	r2,0(r4)
 82087cc:	21000044 	addi	r4,r4,1
 82087d0:	29400044 	addi	r5,r5,1
 82087d4:	393ffb1e 	bne	r7,r4,82087c4 <___vfprintf_internal_r+0x203c>
 82087d8:	d8802304 	addi	r2,sp,140
 82087dc:	14c5c83a 	sub	r2,r2,r19
 82087e0:	d8c02344 	addi	r3,sp,141
 82087e4:	1885883a 	add	r2,r3,r2
 82087e8:	003f7006 	br	82085ac <___vfprintf_internal_r+0x1e24>
 82087ec:	0005883a 	mov	r2,zero
 82087f0:	003f0f06 	br	8208430 <___vfprintf_internal_r+0x1ca8>
 82087f4:	d8c03217 	ldw	r3,200(sp)
 82087f8:	18c00044 	addi	r3,r3,1
 82087fc:	d8c02e15 	stw	r3,184(sp)
 8208800:	1805883a 	mov	r2,r3
 8208804:	183fb20e 	bge	r3,zero,82086d0 <___vfprintf_internal_r+0x1f48>
 8208808:	0005883a 	mov	r2,zero
 820880c:	003fb006 	br	82086d0 <___vfprintf_internal_r+0x1f48>
 8208810:	d9003617 	ldw	r4,216(sp)
 8208814:	000d883a 	mov	r6,zero
 8208818:	000f883a 	mov	r7,zero
 820881c:	980b883a 	mov	r5,r19
 8208820:	d8c03c15 	stw	r3,240(sp)
 8208824:	da003d15 	stw	r8,244(sp)
 8208828:	8212c480 	call	8212c48 <__eqdf2>
 820882c:	d8c03c17 	ldw	r3,240(sp)
 8208830:	da003d17 	ldw	r8,244(sp)
 8208834:	103f9826 	beq	r2,zero,8208698 <___vfprintf_internal_r+0x1f10>
 8208838:	00800044 	movi	r2,1
 820883c:	10c7c83a 	sub	r3,r2,r3
 8208840:	d8c02615 	stw	r3,152(sp)
 8208844:	003f9506 	br	820869c <___vfprintf_internal_r+0x1f14>
 8208848:	d9002917 	ldw	r4,164(sp)
 820884c:	d8c03217 	ldw	r3,200(sp)
 8208850:	20800044 	addi	r2,r4,1
 8208854:	1885883a 	add	r2,r3,r2
 8208858:	d8802e15 	stw	r2,184(sp)
 820885c:	103dbf0e 	bge	r2,zero,8207f5c <___vfprintf_internal_r+0x17d4>
 8208860:	0005883a 	mov	r2,zero
 8208864:	003dbd06 	br	8207f5c <___vfprintf_internal_r+0x17d4>
 8208868:	2000211e 	bne	r4,zero,82088f0 <___vfprintf_internal_r+0x2168>
 820886c:	9480004c 	andi	r18,r18,1
 8208870:	90001f1e 	bne	r18,zero,82088f0 <___vfprintf_internal_r+0x2168>
 8208874:	00800044 	movi	r2,1
 8208878:	d8802e15 	stw	r2,184(sp)
 820887c:	003db706 	br	8207f5c <___vfprintf_internal_r+0x17d4>
 8208880:	00800b44 	movi	r2,45
 8208884:	05adc83a 	sub	r22,zero,r22
 8208888:	d8802305 	stb	r2,140(sp)
 820888c:	003f3f06 	br	820858c <___vfprintf_internal_r+0x1e04>
 8208890:	0005883a 	mov	r2,zero
 8208894:	003f5206 	br	82085e0 <___vfprintf_internal_r+0x1e58>
 8208898:	90a4703a 	and	r18,r18,r2
 820889c:	903f4e26 	beq	r18,zero,82085d8 <___vfprintf_internal_r+0x1e50>
 82088a0:	003f4a06 	br	82085cc <___vfprintf_internal_r+0x1e44>
 82088a4:	00800084 	movi	r2,2
 82088a8:	10c5c83a 	sub	r2,r2,r3
 82088ac:	003f8406 	br	82086c0 <___vfprintf_internal_r+0x1f38>
 82088b0:	d8802d17 	ldw	r2,180(sp)
 82088b4:	d9002d17 	ldw	r4,180(sp)
 82088b8:	ac400043 	ldbu	r17,1(r21)
 82088bc:	10800017 	ldw	r2,0(r2)
 82088c0:	582b883a 	mov	r21,r11
 82088c4:	d8802915 	stw	r2,164(sp)
 82088c8:	20800104 	addi	r2,r4,4
 82088cc:	d9002917 	ldw	r4,164(sp)
 82088d0:	d8802d15 	stw	r2,180(sp)
 82088d4:	203e7a0e 	bge	r4,zero,82082c0 <___vfprintf_internal_r+0x1b38>
 82088d8:	8c403fcc 	andi	r17,r17,255
 82088dc:	00bfffc4 	movi	r2,-1
 82088e0:	8c40201c 	xori	r17,r17,128
 82088e4:	d8802915 	stw	r2,164(sp)
 82088e8:	8c7fe004 	addi	r17,r17,-128
 82088ec:	00380706 	br	820690c <___vfprintf_internal_r+0x184>
 82088f0:	d8c02917 	ldw	r3,164(sp)
 82088f4:	18c00084 	addi	r3,r3,2
 82088f8:	d8c02e15 	stw	r3,184(sp)
 82088fc:	1805883a 	mov	r2,r3
 8208900:	183d960e 	bge	r3,zero,8207f5c <___vfprintf_internal_r+0x17d4>
 8208904:	003fd606 	br	8208860 <___vfprintf_internal_r+0x20d8>
 8208908:	0005883a 	mov	r2,zero
 820890c:	003f8e06 	br	8208748 <___vfprintf_internal_r+0x1fc0>
 8208910:	9080004c 	andi	r2,r18,1
 8208914:	103f811e 	bne	r2,zero,820871c <___vfprintf_internal_r+0x1f94>
 8208918:	d8802117 	ldw	r2,132(sp)
 820891c:	1405c83a 	sub	r2,r2,r16
 8208920:	d8803315 	stw	r2,204(sp)
 8208924:	b47ef326 	beq	r22,r17,82084f4 <___vfprintf_internal_r+0x1d6c>
 8208928:	dd802617 	ldw	r22,152(sp)
 820892c:	003f1106 	br	8208574 <___vfprintf_internal_r+0x1dec>
 8208930:	d9c02785 	stb	r7,158(sp)
 8208934:	00390406 	br	8206d48 <___vfprintf_internal_r+0x5c0>
 8208938:	d9c02785 	stb	r7,158(sp)
 820893c:	0038d306 	br	8206c8c <___vfprintf_internal_r+0x504>
 8208940:	d9c02785 	stb	r7,158(sp)
 8208944:	003a6106 	br	82072cc <___vfprintf_internal_r+0xb44>
 8208948:	d9c02785 	stb	r7,158(sp)
 820894c:	003af806 	br	8207530 <___vfprintf_internal_r+0xda8>
 8208950:	0005883a 	mov	r2,zero
 8208954:	003d7e06 	br	8207f50 <___vfprintf_internal_r+0x17c8>
 8208958:	d8802344 	addi	r2,sp,141
 820895c:	003f1306 	br	82085ac <___vfprintf_internal_r+0x1e24>
 8208960:	d9c02785 	stb	r7,158(sp)
 8208964:	00392306 	br	8206df4 <___vfprintf_internal_r+0x66c>
 8208968:	d9c02785 	stb	r7,158(sp)
 820896c:	003aa906 	br	8207414 <___vfprintf_internal_r+0xc8c>
 8208970:	d9c02785 	stb	r7,158(sp)
 8208974:	003a3d06 	br	820726c <___vfprintf_internal_r+0xae4>
 8208978:	d9c02785 	stb	r7,158(sp)
 820897c:	003aca06 	br	82074a8 <___vfprintf_internal_r+0xd20>

08208980 <__vfprintf_internal>:
 8208980:	00820974 	movhi	r2,2085
 8208984:	108eb804 	addi	r2,r2,15072
 8208988:	300f883a 	mov	r7,r6
 820898c:	280d883a 	mov	r6,r5
 8208990:	200b883a 	mov	r5,r4
 8208994:	11000017 	ldw	r4,0(r2)
 8208998:	82067881 	jmpi	8206788 <___vfprintf_internal_r>

0820899c <__sbprintf>:
 820899c:	2880030b 	ldhu	r2,12(r5)
 82089a0:	2ac01917 	ldw	r11,100(r5)
 82089a4:	2a80038b 	ldhu	r10,14(r5)
 82089a8:	2a400717 	ldw	r9,28(r5)
 82089ac:	2a000917 	ldw	r8,36(r5)
 82089b0:	defee204 	addi	sp,sp,-1144
 82089b4:	00c10004 	movi	r3,1024
 82089b8:	dc011a15 	stw	r16,1128(sp)
 82089bc:	10bfff4c 	andi	r2,r2,65533
 82089c0:	2821883a 	mov	r16,r5
 82089c4:	d8cb883a 	add	r5,sp,r3
 82089c8:	dc811c15 	stw	r18,1136(sp)
 82089cc:	dc411b15 	stw	r17,1132(sp)
 82089d0:	dfc11d15 	stw	ra,1140(sp)
 82089d4:	2025883a 	mov	r18,r4
 82089d8:	d881030d 	sth	r2,1036(sp)
 82089dc:	dac11915 	stw	r11,1124(sp)
 82089e0:	da81038d 	sth	r10,1038(sp)
 82089e4:	da410715 	stw	r9,1052(sp)
 82089e8:	da010915 	stw	r8,1060(sp)
 82089ec:	dec10015 	stw	sp,1024(sp)
 82089f0:	dec10415 	stw	sp,1040(sp)
 82089f4:	d8c10215 	stw	r3,1032(sp)
 82089f8:	d8c10515 	stw	r3,1044(sp)
 82089fc:	d8010615 	stw	zero,1048(sp)
 8208a00:	82067880 	call	8206788 <___vfprintf_internal_r>
 8208a04:	1023883a 	mov	r17,r2
 8208a08:	10000416 	blt	r2,zero,8208a1c <__sbprintf+0x80>
 8208a0c:	d9410004 	addi	r5,sp,1024
 8208a10:	9009883a 	mov	r4,r18
 8208a14:	820a7a80 	call	820a7a8 <_fflush_r>
 8208a18:	10000d1e 	bne	r2,zero,8208a50 <__sbprintf+0xb4>
 8208a1c:	d881030b 	ldhu	r2,1036(sp)
 8208a20:	1080100c 	andi	r2,r2,64
 8208a24:	10000326 	beq	r2,zero,8208a34 <__sbprintf+0x98>
 8208a28:	8080030b 	ldhu	r2,12(r16)
 8208a2c:	10801014 	ori	r2,r2,64
 8208a30:	8080030d 	sth	r2,12(r16)
 8208a34:	8805883a 	mov	r2,r17
 8208a38:	dfc11d17 	ldw	ra,1140(sp)
 8208a3c:	dc811c17 	ldw	r18,1136(sp)
 8208a40:	dc411b17 	ldw	r17,1132(sp)
 8208a44:	dc011a17 	ldw	r16,1128(sp)
 8208a48:	dec11e04 	addi	sp,sp,1144
 8208a4c:	f800283a 	ret
 8208a50:	047fffc4 	movi	r17,-1
 8208a54:	003ff106 	br	8208a1c <__sbprintf+0x80>

08208a58 <__swbuf_r>:
 8208a58:	defffb04 	addi	sp,sp,-20
 8208a5c:	dcc00315 	stw	r19,12(sp)
 8208a60:	dc800215 	stw	r18,8(sp)
 8208a64:	dc000015 	stw	r16,0(sp)
 8208a68:	dfc00415 	stw	ra,16(sp)
 8208a6c:	dc400115 	stw	r17,4(sp)
 8208a70:	2025883a 	mov	r18,r4
 8208a74:	2827883a 	mov	r19,r5
 8208a78:	3021883a 	mov	r16,r6
 8208a7c:	20000226 	beq	r4,zero,8208a88 <__swbuf_r+0x30>
 8208a80:	20800e17 	ldw	r2,56(r4)
 8208a84:	10004226 	beq	r2,zero,8208b90 <__swbuf_r+0x138>
 8208a88:	80800617 	ldw	r2,24(r16)
 8208a8c:	8100030b 	ldhu	r4,12(r16)
 8208a90:	80800215 	stw	r2,8(r16)
 8208a94:	2080020c 	andi	r2,r4,8
 8208a98:	10003626 	beq	r2,zero,8208b74 <__swbuf_r+0x11c>
 8208a9c:	80c00417 	ldw	r3,16(r16)
 8208aa0:	18003426 	beq	r3,zero,8208b74 <__swbuf_r+0x11c>
 8208aa4:	2088000c 	andi	r2,r4,8192
 8208aa8:	9c403fcc 	andi	r17,r19,255
 8208aac:	10001a26 	beq	r2,zero,8208b18 <__swbuf_r+0xc0>
 8208ab0:	80800017 	ldw	r2,0(r16)
 8208ab4:	81000517 	ldw	r4,20(r16)
 8208ab8:	10c7c83a 	sub	r3,r2,r3
 8208abc:	1900200e 	bge	r3,r4,8208b40 <__swbuf_r+0xe8>
 8208ac0:	18c00044 	addi	r3,r3,1
 8208ac4:	81000217 	ldw	r4,8(r16)
 8208ac8:	11400044 	addi	r5,r2,1
 8208acc:	81400015 	stw	r5,0(r16)
 8208ad0:	213fffc4 	addi	r4,r4,-1
 8208ad4:	81000215 	stw	r4,8(r16)
 8208ad8:	14c00005 	stb	r19,0(r2)
 8208adc:	80800517 	ldw	r2,20(r16)
 8208ae0:	10c01e26 	beq	r2,r3,8208b5c <__swbuf_r+0x104>
 8208ae4:	8080030b 	ldhu	r2,12(r16)
 8208ae8:	1080004c 	andi	r2,r2,1
 8208aec:	10000226 	beq	r2,zero,8208af8 <__swbuf_r+0xa0>
 8208af0:	00800284 	movi	r2,10
 8208af4:	88801926 	beq	r17,r2,8208b5c <__swbuf_r+0x104>
 8208af8:	8805883a 	mov	r2,r17
 8208afc:	dfc00417 	ldw	ra,16(sp)
 8208b00:	dcc00317 	ldw	r19,12(sp)
 8208b04:	dc800217 	ldw	r18,8(sp)
 8208b08:	dc400117 	ldw	r17,4(sp)
 8208b0c:	dc000017 	ldw	r16,0(sp)
 8208b10:	dec00504 	addi	sp,sp,20
 8208b14:	f800283a 	ret
 8208b18:	81401917 	ldw	r5,100(r16)
 8208b1c:	00b7ffc4 	movi	r2,-8193
 8208b20:	21080014 	ori	r4,r4,8192
 8208b24:	2884703a 	and	r2,r5,r2
 8208b28:	80801915 	stw	r2,100(r16)
 8208b2c:	80800017 	ldw	r2,0(r16)
 8208b30:	8100030d 	sth	r4,12(r16)
 8208b34:	81000517 	ldw	r4,20(r16)
 8208b38:	10c7c83a 	sub	r3,r2,r3
 8208b3c:	193fe016 	blt	r3,r4,8208ac0 <__swbuf_r+0x68>
 8208b40:	800b883a 	mov	r5,r16
 8208b44:	9009883a 	mov	r4,r18
 8208b48:	820a7a80 	call	820a7a8 <_fflush_r>
 8208b4c:	1000071e 	bne	r2,zero,8208b6c <__swbuf_r+0x114>
 8208b50:	80800017 	ldw	r2,0(r16)
 8208b54:	00c00044 	movi	r3,1
 8208b58:	003fda06 	br	8208ac4 <__swbuf_r+0x6c>
 8208b5c:	800b883a 	mov	r5,r16
 8208b60:	9009883a 	mov	r4,r18
 8208b64:	820a7a80 	call	820a7a8 <_fflush_r>
 8208b68:	103fe326 	beq	r2,zero,8208af8 <__swbuf_r+0xa0>
 8208b6c:	00bfffc4 	movi	r2,-1
 8208b70:	003fe206 	br	8208afc <__swbuf_r+0xa4>
 8208b74:	800b883a 	mov	r5,r16
 8208b78:	9009883a 	mov	r4,r18
 8208b7c:	8208bb00 	call	8208bb0 <__swsetup_r>
 8208b80:	103ffa1e 	bne	r2,zero,8208b6c <__swbuf_r+0x114>
 8208b84:	8100030b 	ldhu	r4,12(r16)
 8208b88:	80c00417 	ldw	r3,16(r16)
 8208b8c:	003fc506 	br	8208aa4 <__swbuf_r+0x4c>
 8208b90:	820ab840 	call	820ab84 <__sinit>
 8208b94:	003fbc06 	br	8208a88 <__swbuf_r+0x30>

08208b98 <__swbuf>:
 8208b98:	00820974 	movhi	r2,2085
 8208b9c:	108eb804 	addi	r2,r2,15072
 8208ba0:	280d883a 	mov	r6,r5
 8208ba4:	200b883a 	mov	r5,r4
 8208ba8:	11000017 	ldw	r4,0(r2)
 8208bac:	8208a581 	jmpi	8208a58 <__swbuf_r>

08208bb0 <__swsetup_r>:
 8208bb0:	00820974 	movhi	r2,2085
 8208bb4:	defffd04 	addi	sp,sp,-12
 8208bb8:	108eb804 	addi	r2,r2,15072
 8208bbc:	dc400115 	stw	r17,4(sp)
 8208bc0:	2023883a 	mov	r17,r4
 8208bc4:	11000017 	ldw	r4,0(r2)
 8208bc8:	dc000015 	stw	r16,0(sp)
 8208bcc:	dfc00215 	stw	ra,8(sp)
 8208bd0:	2821883a 	mov	r16,r5
 8208bd4:	20000226 	beq	r4,zero,8208be0 <__swsetup_r+0x30>
 8208bd8:	20800e17 	ldw	r2,56(r4)
 8208bdc:	10003126 	beq	r2,zero,8208ca4 <__swsetup_r+0xf4>
 8208be0:	8080030b 	ldhu	r2,12(r16)
 8208be4:	10c0020c 	andi	r3,r2,8
 8208be8:	1009883a 	mov	r4,r2
 8208bec:	18000f26 	beq	r3,zero,8208c2c <__swsetup_r+0x7c>
 8208bf0:	80c00417 	ldw	r3,16(r16)
 8208bf4:	18001526 	beq	r3,zero,8208c4c <__swsetup_r+0x9c>
 8208bf8:	1100004c 	andi	r4,r2,1
 8208bfc:	20001c1e 	bne	r4,zero,8208c70 <__swsetup_r+0xc0>
 8208c00:	1080008c 	andi	r2,r2,2
 8208c04:	1000291e 	bne	r2,zero,8208cac <__swsetup_r+0xfc>
 8208c08:	80800517 	ldw	r2,20(r16)
 8208c0c:	80800215 	stw	r2,8(r16)
 8208c10:	18001c26 	beq	r3,zero,8208c84 <__swsetup_r+0xd4>
 8208c14:	0005883a 	mov	r2,zero
 8208c18:	dfc00217 	ldw	ra,8(sp)
 8208c1c:	dc400117 	ldw	r17,4(sp)
 8208c20:	dc000017 	ldw	r16,0(sp)
 8208c24:	dec00304 	addi	sp,sp,12
 8208c28:	f800283a 	ret
 8208c2c:	2080040c 	andi	r2,r4,16
 8208c30:	10002e26 	beq	r2,zero,8208cec <__swsetup_r+0x13c>
 8208c34:	2080010c 	andi	r2,r4,4
 8208c38:	10001e1e 	bne	r2,zero,8208cb4 <__swsetup_r+0x104>
 8208c3c:	80c00417 	ldw	r3,16(r16)
 8208c40:	20800214 	ori	r2,r4,8
 8208c44:	8080030d 	sth	r2,12(r16)
 8208c48:	183feb1e 	bne	r3,zero,8208bf8 <__swsetup_r+0x48>
 8208c4c:	1100a00c 	andi	r4,r2,640
 8208c50:	01408004 	movi	r5,512
 8208c54:	217fe826 	beq	r4,r5,8208bf8 <__swsetup_r+0x48>
 8208c58:	800b883a 	mov	r5,r16
 8208c5c:	8809883a 	mov	r4,r17
 8208c60:	820b87c0 	call	820b87c <__smakebuf_r>
 8208c64:	8080030b 	ldhu	r2,12(r16)
 8208c68:	80c00417 	ldw	r3,16(r16)
 8208c6c:	003fe206 	br	8208bf8 <__swsetup_r+0x48>
 8208c70:	80800517 	ldw	r2,20(r16)
 8208c74:	80000215 	stw	zero,8(r16)
 8208c78:	0085c83a 	sub	r2,zero,r2
 8208c7c:	80800615 	stw	r2,24(r16)
 8208c80:	183fe41e 	bne	r3,zero,8208c14 <__swsetup_r+0x64>
 8208c84:	80c0030b 	ldhu	r3,12(r16)
 8208c88:	0005883a 	mov	r2,zero
 8208c8c:	1900200c 	andi	r4,r3,128
 8208c90:	203fe126 	beq	r4,zero,8208c18 <__swsetup_r+0x68>
 8208c94:	18c01014 	ori	r3,r3,64
 8208c98:	80c0030d 	sth	r3,12(r16)
 8208c9c:	00bfffc4 	movi	r2,-1
 8208ca0:	003fdd06 	br	8208c18 <__swsetup_r+0x68>
 8208ca4:	820ab840 	call	820ab84 <__sinit>
 8208ca8:	003fcd06 	br	8208be0 <__swsetup_r+0x30>
 8208cac:	0005883a 	mov	r2,zero
 8208cb0:	003fd606 	br	8208c0c <__swsetup_r+0x5c>
 8208cb4:	81400c17 	ldw	r5,48(r16)
 8208cb8:	28000626 	beq	r5,zero,8208cd4 <__swsetup_r+0x124>
 8208cbc:	80801004 	addi	r2,r16,64
 8208cc0:	28800326 	beq	r5,r2,8208cd0 <__swsetup_r+0x120>
 8208cc4:	8809883a 	mov	r4,r17
 8208cc8:	820ae4c0 	call	820ae4c <_free_r>
 8208ccc:	8100030b 	ldhu	r4,12(r16)
 8208cd0:	80000c15 	stw	zero,48(r16)
 8208cd4:	80c00417 	ldw	r3,16(r16)
 8208cd8:	00bff6c4 	movi	r2,-37
 8208cdc:	1108703a 	and	r4,r2,r4
 8208ce0:	80000115 	stw	zero,4(r16)
 8208ce4:	80c00015 	stw	r3,0(r16)
 8208ce8:	003fd506 	br	8208c40 <__swsetup_r+0x90>
 8208cec:	00800244 	movi	r2,9
 8208cf0:	88800015 	stw	r2,0(r17)
 8208cf4:	20801014 	ori	r2,r4,64
 8208cf8:	8080030d 	sth	r2,12(r16)
 8208cfc:	00bfffc4 	movi	r2,-1
 8208d00:	003fc506 	br	8208c18 <__swsetup_r+0x68>

08208d04 <quorem>:
 8208d04:	defff704 	addi	sp,sp,-36
 8208d08:	dc800215 	stw	r18,8(sp)
 8208d0c:	20800417 	ldw	r2,16(r4)
 8208d10:	2c800417 	ldw	r18,16(r5)
 8208d14:	dfc00815 	stw	ra,32(sp)
 8208d18:	ddc00715 	stw	r23,28(sp)
 8208d1c:	dd800615 	stw	r22,24(sp)
 8208d20:	dd400515 	stw	r21,20(sp)
 8208d24:	dd000415 	stw	r20,16(sp)
 8208d28:	dcc00315 	stw	r19,12(sp)
 8208d2c:	dc400115 	stw	r17,4(sp)
 8208d30:	dc000015 	stw	r16,0(sp)
 8208d34:	14807116 	blt	r2,r18,8208efc <quorem+0x1f8>
 8208d38:	94bfffc4 	addi	r18,r18,-1
 8208d3c:	94ad883a 	add	r22,r18,r18
 8208d40:	b5ad883a 	add	r22,r22,r22
 8208d44:	2c400504 	addi	r17,r5,20
 8208d48:	8da9883a 	add	r20,r17,r22
 8208d4c:	25400504 	addi	r21,r4,20
 8208d50:	282f883a 	mov	r23,r5
 8208d54:	adad883a 	add	r22,r21,r22
 8208d58:	a1400017 	ldw	r5,0(r20)
 8208d5c:	2021883a 	mov	r16,r4
 8208d60:	b1000017 	ldw	r4,0(r22)
 8208d64:	29400044 	addi	r5,r5,1
 8208d68:	820295c0 	call	820295c <__udivsi3>
 8208d6c:	1027883a 	mov	r19,r2
 8208d70:	10002c26 	beq	r2,zero,8208e24 <quorem+0x120>
 8208d74:	a813883a 	mov	r9,r21
 8208d78:	880b883a 	mov	r5,r17
 8208d7c:	0009883a 	mov	r4,zero
 8208d80:	000d883a 	mov	r6,zero
 8208d84:	2a000017 	ldw	r8,0(r5)
 8208d88:	49c00017 	ldw	r7,0(r9)
 8208d8c:	29400104 	addi	r5,r5,4
 8208d90:	40bfffcc 	andi	r2,r8,65535
 8208d94:	14c5383a 	mul	r2,r2,r19
 8208d98:	4010d43a 	srli	r8,r8,16
 8208d9c:	38ffffcc 	andi	r3,r7,65535
 8208da0:	1105883a 	add	r2,r2,r4
 8208da4:	1008d43a 	srli	r4,r2,16
 8208da8:	44d1383a 	mul	r8,r8,r19
 8208dac:	198d883a 	add	r6,r3,r6
 8208db0:	10ffffcc 	andi	r3,r2,65535
 8208db4:	30c7c83a 	sub	r3,r6,r3
 8208db8:	380ed43a 	srli	r7,r7,16
 8208dbc:	4105883a 	add	r2,r8,r4
 8208dc0:	180dd43a 	srai	r6,r3,16
 8208dc4:	113fffcc 	andi	r4,r2,65535
 8208dc8:	390fc83a 	sub	r7,r7,r4
 8208dcc:	398d883a 	add	r6,r7,r6
 8208dd0:	300e943a 	slli	r7,r6,16
 8208dd4:	18ffffcc 	andi	r3,r3,65535
 8208dd8:	1008d43a 	srli	r4,r2,16
 8208ddc:	38ceb03a 	or	r7,r7,r3
 8208de0:	49c00015 	stw	r7,0(r9)
 8208de4:	300dd43a 	srai	r6,r6,16
 8208de8:	4a400104 	addi	r9,r9,4
 8208dec:	a17fe52e 	bgeu	r20,r5,8208d84 <quorem+0x80>
 8208df0:	b0800017 	ldw	r2,0(r22)
 8208df4:	10000b1e 	bne	r2,zero,8208e24 <quorem+0x120>
 8208df8:	b0bfff04 	addi	r2,r22,-4
 8208dfc:	a880082e 	bgeu	r21,r2,8208e20 <quorem+0x11c>
 8208e00:	b0ffff17 	ldw	r3,-4(r22)
 8208e04:	18000326 	beq	r3,zero,8208e14 <quorem+0x110>
 8208e08:	00000506 	br	8208e20 <quorem+0x11c>
 8208e0c:	10c00017 	ldw	r3,0(r2)
 8208e10:	1800031e 	bne	r3,zero,8208e20 <quorem+0x11c>
 8208e14:	10bfff04 	addi	r2,r2,-4
 8208e18:	94bfffc4 	addi	r18,r18,-1
 8208e1c:	a8bffb36 	bltu	r21,r2,8208e0c <quorem+0x108>
 8208e20:	84800415 	stw	r18,16(r16)
 8208e24:	b80b883a 	mov	r5,r23
 8208e28:	8009883a 	mov	r4,r16
 8208e2c:	820cc6c0 	call	820cc6c <__mcmp>
 8208e30:	10002616 	blt	r2,zero,8208ecc <quorem+0x1c8>
 8208e34:	9cc00044 	addi	r19,r19,1
 8208e38:	a805883a 	mov	r2,r21
 8208e3c:	000b883a 	mov	r5,zero
 8208e40:	11000017 	ldw	r4,0(r2)
 8208e44:	89800017 	ldw	r6,0(r17)
 8208e48:	10800104 	addi	r2,r2,4
 8208e4c:	20ffffcc 	andi	r3,r4,65535
 8208e50:	194b883a 	add	r5,r3,r5
 8208e54:	30ffffcc 	andi	r3,r6,65535
 8208e58:	28c7c83a 	sub	r3,r5,r3
 8208e5c:	300cd43a 	srli	r6,r6,16
 8208e60:	2008d43a 	srli	r4,r4,16
 8208e64:	180bd43a 	srai	r5,r3,16
 8208e68:	18ffffcc 	andi	r3,r3,65535
 8208e6c:	2189c83a 	sub	r4,r4,r6
 8208e70:	2149883a 	add	r4,r4,r5
 8208e74:	200c943a 	slli	r6,r4,16
 8208e78:	8c400104 	addi	r17,r17,4
 8208e7c:	200bd43a 	srai	r5,r4,16
 8208e80:	30c6b03a 	or	r3,r6,r3
 8208e84:	10ffff15 	stw	r3,-4(r2)
 8208e88:	a47fed2e 	bgeu	r20,r17,8208e40 <quorem+0x13c>
 8208e8c:	9485883a 	add	r2,r18,r18
 8208e90:	1085883a 	add	r2,r2,r2
 8208e94:	a887883a 	add	r3,r21,r2
 8208e98:	18800017 	ldw	r2,0(r3)
 8208e9c:	10000b1e 	bne	r2,zero,8208ecc <quorem+0x1c8>
 8208ea0:	18bfff04 	addi	r2,r3,-4
 8208ea4:	a880082e 	bgeu	r21,r2,8208ec8 <quorem+0x1c4>
 8208ea8:	18ffff17 	ldw	r3,-4(r3)
 8208eac:	18000326 	beq	r3,zero,8208ebc <quorem+0x1b8>
 8208eb0:	00000506 	br	8208ec8 <quorem+0x1c4>
 8208eb4:	10c00017 	ldw	r3,0(r2)
 8208eb8:	1800031e 	bne	r3,zero,8208ec8 <quorem+0x1c4>
 8208ebc:	10bfff04 	addi	r2,r2,-4
 8208ec0:	94bfffc4 	addi	r18,r18,-1
 8208ec4:	a8bffb36 	bltu	r21,r2,8208eb4 <quorem+0x1b0>
 8208ec8:	84800415 	stw	r18,16(r16)
 8208ecc:	9805883a 	mov	r2,r19
 8208ed0:	dfc00817 	ldw	ra,32(sp)
 8208ed4:	ddc00717 	ldw	r23,28(sp)
 8208ed8:	dd800617 	ldw	r22,24(sp)
 8208edc:	dd400517 	ldw	r21,20(sp)
 8208ee0:	dd000417 	ldw	r20,16(sp)
 8208ee4:	dcc00317 	ldw	r19,12(sp)
 8208ee8:	dc800217 	ldw	r18,8(sp)
 8208eec:	dc400117 	ldw	r17,4(sp)
 8208ef0:	dc000017 	ldw	r16,0(sp)
 8208ef4:	dec00904 	addi	sp,sp,36
 8208ef8:	f800283a 	ret
 8208efc:	0005883a 	mov	r2,zero
 8208f00:	003ff306 	br	8208ed0 <quorem+0x1cc>

08208f04 <_dtoa_r>:
 8208f04:	20801017 	ldw	r2,64(r4)
 8208f08:	deffde04 	addi	sp,sp,-136
 8208f0c:	df002015 	stw	fp,128(sp)
 8208f10:	dcc01b15 	stw	r19,108(sp)
 8208f14:	dc801a15 	stw	r18,104(sp)
 8208f18:	dc401915 	stw	r17,100(sp)
 8208f1c:	dc001815 	stw	r16,96(sp)
 8208f20:	dfc02115 	stw	ra,132(sp)
 8208f24:	ddc01f15 	stw	r23,124(sp)
 8208f28:	dd801e15 	stw	r22,120(sp)
 8208f2c:	dd401d15 	stw	r21,116(sp)
 8208f30:	dd001c15 	stw	r20,112(sp)
 8208f34:	d9c00315 	stw	r7,12(sp)
 8208f38:	2039883a 	mov	fp,r4
 8208f3c:	3023883a 	mov	r17,r6
 8208f40:	2825883a 	mov	r18,r5
 8208f44:	dc002417 	ldw	r16,144(sp)
 8208f48:	3027883a 	mov	r19,r6
 8208f4c:	10000826 	beq	r2,zero,8208f70 <_dtoa_r+0x6c>
 8208f50:	21801117 	ldw	r6,68(r4)
 8208f54:	00c00044 	movi	r3,1
 8208f58:	100b883a 	mov	r5,r2
 8208f5c:	1986983a 	sll	r3,r3,r6
 8208f60:	11800115 	stw	r6,4(r2)
 8208f64:	10c00215 	stw	r3,8(r2)
 8208f68:	820c44c0 	call	820c44c <_Bfree>
 8208f6c:	e0001015 	stw	zero,64(fp)
 8208f70:	88002e16 	blt	r17,zero,820902c <_dtoa_r+0x128>
 8208f74:	80000015 	stw	zero,0(r16)
 8208f78:	889ffc2c 	andhi	r2,r17,32752
 8208f7c:	00dffc34 	movhi	r3,32752
 8208f80:	10c01c26 	beq	r2,r3,8208ff4 <_dtoa_r+0xf0>
 8208f84:	000d883a 	mov	r6,zero
 8208f88:	000f883a 	mov	r7,zero
 8208f8c:	9009883a 	mov	r4,r18
 8208f90:	980b883a 	mov	r5,r19
 8208f94:	8212c480 	call	8212c48 <__eqdf2>
 8208f98:	10002b1e 	bne	r2,zero,8209048 <_dtoa_r+0x144>
 8208f9c:	d9c02317 	ldw	r7,140(sp)
 8208fa0:	00800044 	movi	r2,1
 8208fa4:	38800015 	stw	r2,0(r7)
 8208fa8:	d8802517 	ldw	r2,148(sp)
 8208fac:	10019e26 	beq	r2,zero,8209628 <_dtoa_r+0x724>
 8208fb0:	d8c02517 	ldw	r3,148(sp)
 8208fb4:	00820974 	movhi	r2,2085
 8208fb8:	10b5e944 	addi	r2,r2,-10331
 8208fbc:	18800015 	stw	r2,0(r3)
 8208fc0:	10bfffc4 	addi	r2,r2,-1
 8208fc4:	dfc02117 	ldw	ra,132(sp)
 8208fc8:	df002017 	ldw	fp,128(sp)
 8208fcc:	ddc01f17 	ldw	r23,124(sp)
 8208fd0:	dd801e17 	ldw	r22,120(sp)
 8208fd4:	dd401d17 	ldw	r21,116(sp)
 8208fd8:	dd001c17 	ldw	r20,112(sp)
 8208fdc:	dcc01b17 	ldw	r19,108(sp)
 8208fe0:	dc801a17 	ldw	r18,104(sp)
 8208fe4:	dc401917 	ldw	r17,100(sp)
 8208fe8:	dc001817 	ldw	r16,96(sp)
 8208fec:	dec02204 	addi	sp,sp,136
 8208ff0:	f800283a 	ret
 8208ff4:	d8c02317 	ldw	r3,140(sp)
 8208ff8:	0089c3c4 	movi	r2,9999
 8208ffc:	18800015 	stw	r2,0(r3)
 8209000:	90017726 	beq	r18,zero,82095e0 <_dtoa_r+0x6dc>
 8209004:	00820974 	movhi	r2,2085
 8209008:	10b5fd04 	addi	r2,r2,-10252
 820900c:	d9002517 	ldw	r4,148(sp)
 8209010:	203fec26 	beq	r4,zero,8208fc4 <_dtoa_r+0xc0>
 8209014:	10c000c7 	ldb	r3,3(r2)
 8209018:	1801781e 	bne	r3,zero,82095fc <_dtoa_r+0x6f8>
 820901c:	10c000c4 	addi	r3,r2,3
 8209020:	d9802517 	ldw	r6,148(sp)
 8209024:	30c00015 	stw	r3,0(r6)
 8209028:	003fe606 	br	8208fc4 <_dtoa_r+0xc0>
 820902c:	04e00034 	movhi	r19,32768
 8209030:	9cffffc4 	addi	r19,r19,-1
 8209034:	00800044 	movi	r2,1
 8209038:	8ce6703a 	and	r19,r17,r19
 820903c:	80800015 	stw	r2,0(r16)
 8209040:	9823883a 	mov	r17,r19
 8209044:	003fcc06 	br	8208f78 <_dtoa_r+0x74>
 8209048:	d8800204 	addi	r2,sp,8
 820904c:	d8800015 	stw	r2,0(sp)
 8209050:	d9c00104 	addi	r7,sp,4
 8209054:	900b883a 	mov	r5,r18
 8209058:	980d883a 	mov	r6,r19
 820905c:	e009883a 	mov	r4,fp
 8209060:	8820d53a 	srli	r16,r17,20
 8209064:	820d0380 	call	820d038 <__d2b>
 8209068:	d8800915 	stw	r2,36(sp)
 820906c:	8001651e 	bne	r16,zero,8209604 <_dtoa_r+0x700>
 8209070:	dd800217 	ldw	r22,8(sp)
 8209074:	dc000117 	ldw	r16,4(sp)
 8209078:	00800804 	movi	r2,32
 820907c:	b421883a 	add	r16,r22,r16
 8209080:	80c10c84 	addi	r3,r16,1074
 8209084:	10c2d10e 	bge	r2,r3,8209bcc <_dtoa_r+0xcc8>
 8209088:	00801004 	movi	r2,64
 820908c:	81010484 	addi	r4,r16,1042
 8209090:	10c7c83a 	sub	r3,r2,r3
 8209094:	9108d83a 	srl	r4,r18,r4
 8209098:	88e2983a 	sll	r17,r17,r3
 820909c:	2448b03a 	or	r4,r4,r17
 82090a0:	82140100 	call	8214010 <__floatunsidf>
 82090a4:	017f8434 	movhi	r5,65040
 82090a8:	01800044 	movi	r6,1
 82090ac:	1009883a 	mov	r4,r2
 82090b0:	194b883a 	add	r5,r3,r5
 82090b4:	843fffc4 	addi	r16,r16,-1
 82090b8:	d9801115 	stw	r6,68(sp)
 82090bc:	000d883a 	mov	r6,zero
 82090c0:	01cffe34 	movhi	r7,16376
 82090c4:	82135b80 	call	82135b8 <__subdf3>
 82090c8:	0198dbf4 	movhi	r6,25455
 82090cc:	01cff4f4 	movhi	r7,16339
 82090d0:	3190d844 	addi	r6,r6,17249
 82090d4:	39e1e9c4 	addi	r7,r7,-30809
 82090d8:	1009883a 	mov	r4,r2
 82090dc:	180b883a 	mov	r5,r3
 82090e0:	8212ea00 	call	8212ea0 <__muldf3>
 82090e4:	01a2d874 	movhi	r6,35681
 82090e8:	01cff1f4 	movhi	r7,16327
 82090ec:	31b22cc4 	addi	r6,r6,-14157
 82090f0:	39e28a04 	addi	r7,r7,-30168
 82090f4:	180b883a 	mov	r5,r3
 82090f8:	1009883a 	mov	r4,r2
 82090fc:	8211ab40 	call	8211ab4 <__adddf3>
 8209100:	8009883a 	mov	r4,r16
 8209104:	1029883a 	mov	r20,r2
 8209108:	1823883a 	mov	r17,r3
 820910c:	8213f340 	call	8213f34 <__floatsidf>
 8209110:	019427f4 	movhi	r6,20639
 8209114:	01cff4f4 	movhi	r7,16339
 8209118:	319e7ec4 	addi	r6,r6,31227
 820911c:	39d104c4 	addi	r7,r7,17427
 8209120:	1009883a 	mov	r4,r2
 8209124:	180b883a 	mov	r5,r3
 8209128:	8212ea00 	call	8212ea0 <__muldf3>
 820912c:	100d883a 	mov	r6,r2
 8209130:	180f883a 	mov	r7,r3
 8209134:	a009883a 	mov	r4,r20
 8209138:	880b883a 	mov	r5,r17
 820913c:	8211ab40 	call	8211ab4 <__adddf3>
 8209140:	1009883a 	mov	r4,r2
 8209144:	180b883a 	mov	r5,r3
 8209148:	1029883a 	mov	r20,r2
 820914c:	1823883a 	mov	r17,r3
 8209150:	8213eb40 	call	8213eb4 <__fixdfsi>
 8209154:	000d883a 	mov	r6,zero
 8209158:	000f883a 	mov	r7,zero
 820915c:	a009883a 	mov	r4,r20
 8209160:	880b883a 	mov	r5,r17
 8209164:	d8800515 	stw	r2,20(sp)
 8209168:	8212dac0 	call	8212dac <__ledf2>
 820916c:	10028716 	blt	r2,zero,8209b8c <_dtoa_r+0xc88>
 8209170:	d8c00517 	ldw	r3,20(sp)
 8209174:	00800584 	movi	r2,22
 8209178:	10c27536 	bltu	r2,r3,8209b50 <_dtoa_r+0xc4c>
 820917c:	180490fa 	slli	r2,r3,3
 8209180:	00c20974 	movhi	r3,2085
 8209184:	18f61804 	addi	r3,r3,-10144
 8209188:	1885883a 	add	r2,r3,r2
 820918c:	11000017 	ldw	r4,0(r2)
 8209190:	11400117 	ldw	r5,4(r2)
 8209194:	900d883a 	mov	r6,r18
 8209198:	980f883a 	mov	r7,r19
 820919c:	8212cd00 	call	8212cd0 <__gedf2>
 82091a0:	00828d0e 	bge	zero,r2,8209bd8 <_dtoa_r+0xcd4>
 82091a4:	d9000517 	ldw	r4,20(sp)
 82091a8:	d8000e15 	stw	zero,56(sp)
 82091ac:	213fffc4 	addi	r4,r4,-1
 82091b0:	d9000515 	stw	r4,20(sp)
 82091b4:	b42dc83a 	sub	r22,r22,r16
 82091b8:	b5bfffc4 	addi	r22,r22,-1
 82091bc:	b0026f16 	blt	r22,zero,8209b7c <_dtoa_r+0xc78>
 82091c0:	d8000815 	stw	zero,32(sp)
 82091c4:	d9c00517 	ldw	r7,20(sp)
 82091c8:	38026416 	blt	r7,zero,8209b5c <_dtoa_r+0xc58>
 82091cc:	b1ed883a 	add	r22,r22,r7
 82091d0:	d9c00d15 	stw	r7,52(sp)
 82091d4:	d8000a15 	stw	zero,40(sp)
 82091d8:	d9800317 	ldw	r6,12(sp)
 82091dc:	00800244 	movi	r2,9
 82091e0:	11811436 	bltu	r2,r6,8209634 <_dtoa_r+0x730>
 82091e4:	00800144 	movi	r2,5
 82091e8:	1184e10e 	bge	r2,r6,820a570 <_dtoa_r+0x166c>
 82091ec:	31bfff04 	addi	r6,r6,-4
 82091f0:	d9800315 	stw	r6,12(sp)
 82091f4:	0023883a 	mov	r17,zero
 82091f8:	d9800317 	ldw	r6,12(sp)
 82091fc:	008000c4 	movi	r2,3
 8209200:	30836726 	beq	r6,r2,8209fa0 <_dtoa_r+0x109c>
 8209204:	1183410e 	bge	r2,r6,8209f0c <_dtoa_r+0x1008>
 8209208:	d9c00317 	ldw	r7,12(sp)
 820920c:	00800104 	movi	r2,4
 8209210:	38827c26 	beq	r7,r2,8209c04 <_dtoa_r+0xd00>
 8209214:	00800144 	movi	r2,5
 8209218:	3884c41e 	bne	r7,r2,820a52c <_dtoa_r+0x1628>
 820921c:	00800044 	movi	r2,1
 8209220:	d8800b15 	stw	r2,44(sp)
 8209224:	d8c00517 	ldw	r3,20(sp)
 8209228:	d9002217 	ldw	r4,136(sp)
 820922c:	1907883a 	add	r3,r3,r4
 8209230:	19800044 	addi	r6,r3,1
 8209234:	d8c00c15 	stw	r3,48(sp)
 8209238:	d9800615 	stw	r6,24(sp)
 820923c:	0183a40e 	bge	zero,r6,820a0d0 <_dtoa_r+0x11cc>
 8209240:	d9800617 	ldw	r6,24(sp)
 8209244:	3021883a 	mov	r16,r6
 8209248:	e0001115 	stw	zero,68(fp)
 820924c:	008005c4 	movi	r2,23
 8209250:	1184c92e 	bgeu	r2,r6,820a578 <_dtoa_r+0x1674>
 8209254:	00c00044 	movi	r3,1
 8209258:	00800104 	movi	r2,4
 820925c:	1085883a 	add	r2,r2,r2
 8209260:	11000504 	addi	r4,r2,20
 8209264:	180b883a 	mov	r5,r3
 8209268:	18c00044 	addi	r3,r3,1
 820926c:	313ffb2e 	bgeu	r6,r4,820925c <_dtoa_r+0x358>
 8209270:	e1401115 	stw	r5,68(fp)
 8209274:	e009883a 	mov	r4,fp
 8209278:	820c3a40 	call	820c3a4 <_Balloc>
 820927c:	d8800715 	stw	r2,28(sp)
 8209280:	e0801015 	stw	r2,64(fp)
 8209284:	00800384 	movi	r2,14
 8209288:	1400f736 	bltu	r2,r16,8209668 <_dtoa_r+0x764>
 820928c:	8800f626 	beq	r17,zero,8209668 <_dtoa_r+0x764>
 8209290:	d9c00517 	ldw	r7,20(sp)
 8209294:	01c39a0e 	bge	zero,r7,820a100 <_dtoa_r+0x11fc>
 8209298:	388003cc 	andi	r2,r7,15
 820929c:	100490fa 	slli	r2,r2,3
 82092a0:	382bd13a 	srai	r21,r7,4
 82092a4:	00c20974 	movhi	r3,2085
 82092a8:	18f61804 	addi	r3,r3,-10144
 82092ac:	1885883a 	add	r2,r3,r2
 82092b0:	a8c0040c 	andi	r3,r21,16
 82092b4:	12400017 	ldw	r9,0(r2)
 82092b8:	12000117 	ldw	r8,4(r2)
 82092bc:	18037926 	beq	r3,zero,820a0a4 <_dtoa_r+0x11a0>
 82092c0:	00820974 	movhi	r2,2085
 82092c4:	10b60e04 	addi	r2,r2,-10184
 82092c8:	11800817 	ldw	r6,32(r2)
 82092cc:	11c00917 	ldw	r7,36(r2)
 82092d0:	9009883a 	mov	r4,r18
 82092d4:	980b883a 	mov	r5,r19
 82092d8:	da001715 	stw	r8,92(sp)
 82092dc:	da401615 	stw	r9,88(sp)
 82092e0:	82123600 	call	8212360 <__divdf3>
 82092e4:	da001717 	ldw	r8,92(sp)
 82092e8:	da401617 	ldw	r9,88(sp)
 82092ec:	ad4003cc 	andi	r21,r21,15
 82092f0:	040000c4 	movi	r16,3
 82092f4:	1023883a 	mov	r17,r2
 82092f8:	1829883a 	mov	r20,r3
 82092fc:	a8001126 	beq	r21,zero,8209344 <_dtoa_r+0x440>
 8209300:	05c20974 	movhi	r23,2085
 8209304:	bdf60e04 	addi	r23,r23,-10184
 8209308:	4805883a 	mov	r2,r9
 820930c:	4007883a 	mov	r3,r8
 8209310:	a980004c 	andi	r6,r21,1
 8209314:	1009883a 	mov	r4,r2
 8209318:	a82bd07a 	srai	r21,r21,1
 820931c:	180b883a 	mov	r5,r3
 8209320:	30000426 	beq	r6,zero,8209334 <_dtoa_r+0x430>
 8209324:	b9800017 	ldw	r6,0(r23)
 8209328:	b9c00117 	ldw	r7,4(r23)
 820932c:	84000044 	addi	r16,r16,1
 8209330:	8212ea00 	call	8212ea0 <__muldf3>
 8209334:	bdc00204 	addi	r23,r23,8
 8209338:	a83ff51e 	bne	r21,zero,8209310 <_dtoa_r+0x40c>
 820933c:	1013883a 	mov	r9,r2
 8209340:	1811883a 	mov	r8,r3
 8209344:	480d883a 	mov	r6,r9
 8209348:	400f883a 	mov	r7,r8
 820934c:	8809883a 	mov	r4,r17
 8209350:	a00b883a 	mov	r5,r20
 8209354:	82123600 	call	8212360 <__divdf3>
 8209358:	d8800f15 	stw	r2,60(sp)
 820935c:	d8c01015 	stw	r3,64(sp)
 8209360:	d8c00e17 	ldw	r3,56(sp)
 8209364:	18000626 	beq	r3,zero,8209380 <_dtoa_r+0x47c>
 8209368:	d9000f17 	ldw	r4,60(sp)
 820936c:	d9401017 	ldw	r5,64(sp)
 8209370:	000d883a 	mov	r6,zero
 8209374:	01cffc34 	movhi	r7,16368
 8209378:	8212dac0 	call	8212dac <__ledf2>
 820937c:	10040b16 	blt	r2,zero,820a3ac <_dtoa_r+0x14a8>
 8209380:	8009883a 	mov	r4,r16
 8209384:	8213f340 	call	8213f34 <__floatsidf>
 8209388:	d9800f17 	ldw	r6,60(sp)
 820938c:	d9c01017 	ldw	r7,64(sp)
 8209390:	1009883a 	mov	r4,r2
 8209394:	180b883a 	mov	r5,r3
 8209398:	8212ea00 	call	8212ea0 <__muldf3>
 820939c:	000d883a 	mov	r6,zero
 82093a0:	01d00734 	movhi	r7,16412
 82093a4:	1009883a 	mov	r4,r2
 82093a8:	180b883a 	mov	r5,r3
 82093ac:	8211ab40 	call	8211ab4 <__adddf3>
 82093b0:	1021883a 	mov	r16,r2
 82093b4:	d8800617 	ldw	r2,24(sp)
 82093b8:	047f3034 	movhi	r17,64704
 82093bc:	1c63883a 	add	r17,r3,r17
 82093c0:	10031826 	beq	r2,zero,820a024 <_dtoa_r+0x1120>
 82093c4:	d8c00517 	ldw	r3,20(sp)
 82093c8:	db000617 	ldw	r12,24(sp)
 82093cc:	d8c01315 	stw	r3,76(sp)
 82093d0:	d9000b17 	ldw	r4,44(sp)
 82093d4:	20038f26 	beq	r4,zero,820a214 <_dtoa_r+0x1310>
 82093d8:	60bfffc4 	addi	r2,r12,-1
 82093dc:	100490fa 	slli	r2,r2,3
 82093e0:	00c20974 	movhi	r3,2085
 82093e4:	18f61804 	addi	r3,r3,-10144
 82093e8:	1885883a 	add	r2,r3,r2
 82093ec:	11800017 	ldw	r6,0(r2)
 82093f0:	11c00117 	ldw	r7,4(r2)
 82093f4:	d8800717 	ldw	r2,28(sp)
 82093f8:	0009883a 	mov	r4,zero
 82093fc:	014ff834 	movhi	r5,16352
 8209400:	db001615 	stw	r12,88(sp)
 8209404:	15c00044 	addi	r23,r2,1
 8209408:	82123600 	call	8212360 <__divdf3>
 820940c:	800d883a 	mov	r6,r16
 8209410:	880f883a 	mov	r7,r17
 8209414:	1009883a 	mov	r4,r2
 8209418:	180b883a 	mov	r5,r3
 820941c:	82135b80 	call	82135b8 <__subdf3>
 8209420:	d9401017 	ldw	r5,64(sp)
 8209424:	d9000f17 	ldw	r4,60(sp)
 8209428:	102b883a 	mov	r21,r2
 820942c:	d8c01215 	stw	r3,72(sp)
 8209430:	8213eb40 	call	8213eb4 <__fixdfsi>
 8209434:	1009883a 	mov	r4,r2
 8209438:	1029883a 	mov	r20,r2
 820943c:	8213f340 	call	8213f34 <__floatsidf>
 8209440:	d9000f17 	ldw	r4,60(sp)
 8209444:	d9401017 	ldw	r5,64(sp)
 8209448:	100d883a 	mov	r6,r2
 820944c:	180f883a 	mov	r7,r3
 8209450:	82135b80 	call	82135b8 <__subdf3>
 8209454:	1823883a 	mov	r17,r3
 8209458:	d8c00717 	ldw	r3,28(sp)
 820945c:	d9401217 	ldw	r5,72(sp)
 8209460:	a2000c04 	addi	r8,r20,48
 8209464:	1021883a 	mov	r16,r2
 8209468:	1a000005 	stb	r8,0(r3)
 820946c:	800d883a 	mov	r6,r16
 8209470:	880f883a 	mov	r7,r17
 8209474:	a809883a 	mov	r4,r21
 8209478:	4029883a 	mov	r20,r8
 820947c:	8212cd00 	call	8212cd0 <__gedf2>
 8209480:	00841d16 	blt	zero,r2,820a4f8 <_dtoa_r+0x15f4>
 8209484:	800d883a 	mov	r6,r16
 8209488:	880f883a 	mov	r7,r17
 820948c:	0009883a 	mov	r4,zero
 8209490:	014ffc34 	movhi	r5,16368
 8209494:	82135b80 	call	82135b8 <__subdf3>
 8209498:	d9401217 	ldw	r5,72(sp)
 820949c:	100d883a 	mov	r6,r2
 82094a0:	180f883a 	mov	r7,r3
 82094a4:	a809883a 	mov	r4,r21
 82094a8:	8212cd00 	call	8212cd0 <__gedf2>
 82094ac:	db001617 	ldw	r12,88(sp)
 82094b0:	00840e16 	blt	zero,r2,820a4ec <_dtoa_r+0x15e8>
 82094b4:	00800044 	movi	r2,1
 82094b8:	13006b0e 	bge	r2,r12,8209668 <_dtoa_r+0x764>
 82094bc:	d9000717 	ldw	r4,28(sp)
 82094c0:	dd800f15 	stw	r22,60(sp)
 82094c4:	dcc01015 	stw	r19,64(sp)
 82094c8:	2319883a 	add	r12,r4,r12
 82094cc:	dcc01217 	ldw	r19,72(sp)
 82094d0:	602d883a 	mov	r22,r12
 82094d4:	dc801215 	stw	r18,72(sp)
 82094d8:	b825883a 	mov	r18,r23
 82094dc:	00000906 	br	8209504 <_dtoa_r+0x600>
 82094e0:	82135b80 	call	82135b8 <__subdf3>
 82094e4:	a80d883a 	mov	r6,r21
 82094e8:	980f883a 	mov	r7,r19
 82094ec:	1009883a 	mov	r4,r2
 82094f0:	180b883a 	mov	r5,r3
 82094f4:	8212dac0 	call	8212dac <__ledf2>
 82094f8:	1003e816 	blt	r2,zero,820a49c <_dtoa_r+0x1598>
 82094fc:	b825883a 	mov	r18,r23
 8209500:	bd83e926 	beq	r23,r22,820a4a8 <_dtoa_r+0x15a4>
 8209504:	a809883a 	mov	r4,r21
 8209508:	980b883a 	mov	r5,r19
 820950c:	000d883a 	mov	r6,zero
 8209510:	01d00934 	movhi	r7,16420
 8209514:	8212ea00 	call	8212ea0 <__muldf3>
 8209518:	000d883a 	mov	r6,zero
 820951c:	01d00934 	movhi	r7,16420
 8209520:	8009883a 	mov	r4,r16
 8209524:	880b883a 	mov	r5,r17
 8209528:	102b883a 	mov	r21,r2
 820952c:	1827883a 	mov	r19,r3
 8209530:	8212ea00 	call	8212ea0 <__muldf3>
 8209534:	180b883a 	mov	r5,r3
 8209538:	1009883a 	mov	r4,r2
 820953c:	1821883a 	mov	r16,r3
 8209540:	1023883a 	mov	r17,r2
 8209544:	8213eb40 	call	8213eb4 <__fixdfsi>
 8209548:	1009883a 	mov	r4,r2
 820954c:	1029883a 	mov	r20,r2
 8209550:	8213f340 	call	8213f34 <__floatsidf>
 8209554:	8809883a 	mov	r4,r17
 8209558:	800b883a 	mov	r5,r16
 820955c:	100d883a 	mov	r6,r2
 8209560:	180f883a 	mov	r7,r3
 8209564:	82135b80 	call	82135b8 <__subdf3>
 8209568:	a5000c04 	addi	r20,r20,48
 820956c:	a80d883a 	mov	r6,r21
 8209570:	980f883a 	mov	r7,r19
 8209574:	1009883a 	mov	r4,r2
 8209578:	180b883a 	mov	r5,r3
 820957c:	95000005 	stb	r20,0(r18)
 8209580:	1021883a 	mov	r16,r2
 8209584:	1823883a 	mov	r17,r3
 8209588:	8212dac0 	call	8212dac <__ledf2>
 820958c:	bdc00044 	addi	r23,r23,1
 8209590:	800d883a 	mov	r6,r16
 8209594:	880f883a 	mov	r7,r17
 8209598:	0009883a 	mov	r4,zero
 820959c:	014ffc34 	movhi	r5,16368
 82095a0:	103fcf0e 	bge	r2,zero,82094e0 <_dtoa_r+0x5dc>
 82095a4:	d8c01317 	ldw	r3,76(sp)
 82095a8:	d8c00515 	stw	r3,20(sp)
 82095ac:	d9400917 	ldw	r5,36(sp)
 82095b0:	e009883a 	mov	r4,fp
 82095b4:	820c44c0 	call	820c44c <_Bfree>
 82095b8:	d9000517 	ldw	r4,20(sp)
 82095bc:	d9802317 	ldw	r6,140(sp)
 82095c0:	d9c02517 	ldw	r7,148(sp)
 82095c4:	b8000005 	stb	zero,0(r23)
 82095c8:	20800044 	addi	r2,r4,1
 82095cc:	30800015 	stw	r2,0(r6)
 82095d0:	3802aa26 	beq	r7,zero,820a07c <_dtoa_r+0x1178>
 82095d4:	3dc00015 	stw	r23,0(r7)
 82095d8:	d8800717 	ldw	r2,28(sp)
 82095dc:	003e7906 	br	8208fc4 <_dtoa_r+0xc0>
 82095e0:	00800434 	movhi	r2,16
 82095e4:	10bfffc4 	addi	r2,r2,-1
 82095e8:	88a2703a 	and	r17,r17,r2
 82095ec:	883e851e 	bne	r17,zero,8209004 <_dtoa_r+0x100>
 82095f0:	00820974 	movhi	r2,2085
 82095f4:	10b5fa04 	addi	r2,r2,-10264
 82095f8:	003e8406 	br	820900c <_dtoa_r+0x108>
 82095fc:	10c00204 	addi	r3,r2,8
 8209600:	003e8706 	br	8209020 <_dtoa_r+0x11c>
 8209604:	01400434 	movhi	r5,16
 8209608:	297fffc4 	addi	r5,r5,-1
 820960c:	994a703a 	and	r5,r19,r5
 8209610:	9009883a 	mov	r4,r18
 8209614:	843f0044 	addi	r16,r16,-1023
 8209618:	294ffc34 	orhi	r5,r5,16368
 820961c:	dd800217 	ldw	r22,8(sp)
 8209620:	d8001115 	stw	zero,68(sp)
 8209624:	003ea506 	br	82090bc <_dtoa_r+0x1b8>
 8209628:	00820974 	movhi	r2,2085
 820962c:	10b5e904 	addi	r2,r2,-10332
 8209630:	003e6406 	br	8208fc4 <_dtoa_r+0xc0>
 8209634:	e0001115 	stw	zero,68(fp)
 8209638:	000b883a 	mov	r5,zero
 820963c:	e009883a 	mov	r4,fp
 8209640:	820c3a40 	call	820c3a4 <_Balloc>
 8209644:	01bfffc4 	movi	r6,-1
 8209648:	01c00044 	movi	r7,1
 820964c:	d8800715 	stw	r2,28(sp)
 8209650:	d9800c15 	stw	r6,48(sp)
 8209654:	e0801015 	stw	r2,64(fp)
 8209658:	d8000315 	stw	zero,12(sp)
 820965c:	d9c00b15 	stw	r7,44(sp)
 8209660:	d9800615 	stw	r6,24(sp)
 8209664:	d8002215 	stw	zero,136(sp)
 8209668:	d8800117 	ldw	r2,4(sp)
 820966c:	10008916 	blt	r2,zero,8209894 <_dtoa_r+0x990>
 8209670:	d9000517 	ldw	r4,20(sp)
 8209674:	00c00384 	movi	r3,14
 8209678:	19008616 	blt	r3,r4,8209894 <_dtoa_r+0x990>
 820967c:	200490fa 	slli	r2,r4,3
 8209680:	00c20974 	movhi	r3,2085
 8209684:	d9802217 	ldw	r6,136(sp)
 8209688:	18f61804 	addi	r3,r3,-10144
 820968c:	1885883a 	add	r2,r3,r2
 8209690:	14000017 	ldw	r16,0(r2)
 8209694:	14400117 	ldw	r17,4(r2)
 8209698:	30016316 	blt	r6,zero,8209c28 <_dtoa_r+0xd24>
 820969c:	800d883a 	mov	r6,r16
 82096a0:	880f883a 	mov	r7,r17
 82096a4:	9009883a 	mov	r4,r18
 82096a8:	980b883a 	mov	r5,r19
 82096ac:	82123600 	call	8212360 <__divdf3>
 82096b0:	180b883a 	mov	r5,r3
 82096b4:	1009883a 	mov	r4,r2
 82096b8:	8213eb40 	call	8213eb4 <__fixdfsi>
 82096bc:	1009883a 	mov	r4,r2
 82096c0:	102b883a 	mov	r21,r2
 82096c4:	8213f340 	call	8213f34 <__floatsidf>
 82096c8:	800d883a 	mov	r6,r16
 82096cc:	880f883a 	mov	r7,r17
 82096d0:	1009883a 	mov	r4,r2
 82096d4:	180b883a 	mov	r5,r3
 82096d8:	8212ea00 	call	8212ea0 <__muldf3>
 82096dc:	100d883a 	mov	r6,r2
 82096e0:	180f883a 	mov	r7,r3
 82096e4:	9009883a 	mov	r4,r18
 82096e8:	980b883a 	mov	r5,r19
 82096ec:	82135b80 	call	82135b8 <__subdf3>
 82096f0:	d9c00717 	ldw	r7,28(sp)
 82096f4:	1009883a 	mov	r4,r2
 82096f8:	a8800c04 	addi	r2,r21,48
 82096fc:	38800005 	stb	r2,0(r7)
 8209700:	3dc00044 	addi	r23,r7,1
 8209704:	d9c00617 	ldw	r7,24(sp)
 8209708:	01800044 	movi	r6,1
 820970c:	180b883a 	mov	r5,r3
 8209710:	2005883a 	mov	r2,r4
 8209714:	39803826 	beq	r7,r6,82097f8 <_dtoa_r+0x8f4>
 8209718:	000d883a 	mov	r6,zero
 820971c:	01d00934 	movhi	r7,16420
 8209720:	8212ea00 	call	8212ea0 <__muldf3>
 8209724:	000d883a 	mov	r6,zero
 8209728:	000f883a 	mov	r7,zero
 820972c:	1009883a 	mov	r4,r2
 8209730:	180b883a 	mov	r5,r3
 8209734:	1025883a 	mov	r18,r2
 8209738:	1827883a 	mov	r19,r3
 820973c:	8212c480 	call	8212c48 <__eqdf2>
 8209740:	103f9a26 	beq	r2,zero,82095ac <_dtoa_r+0x6a8>
 8209744:	d9c00617 	ldw	r7,24(sp)
 8209748:	d8c00717 	ldw	r3,28(sp)
 820974c:	b829883a 	mov	r20,r23
 8209750:	38bfffc4 	addi	r2,r7,-1
 8209754:	18ad883a 	add	r22,r3,r2
 8209758:	00000a06 	br	8209784 <_dtoa_r+0x880>
 820975c:	8212ea00 	call	8212ea0 <__muldf3>
 8209760:	000d883a 	mov	r6,zero
 8209764:	000f883a 	mov	r7,zero
 8209768:	1009883a 	mov	r4,r2
 820976c:	180b883a 	mov	r5,r3
 8209770:	1025883a 	mov	r18,r2
 8209774:	1827883a 	mov	r19,r3
 8209778:	b829883a 	mov	r20,r23
 820977c:	8212c480 	call	8212c48 <__eqdf2>
 8209780:	103f8a26 	beq	r2,zero,82095ac <_dtoa_r+0x6a8>
 8209784:	800d883a 	mov	r6,r16
 8209788:	880f883a 	mov	r7,r17
 820978c:	9009883a 	mov	r4,r18
 8209790:	980b883a 	mov	r5,r19
 8209794:	82123600 	call	8212360 <__divdf3>
 8209798:	180b883a 	mov	r5,r3
 820979c:	1009883a 	mov	r4,r2
 82097a0:	8213eb40 	call	8213eb4 <__fixdfsi>
 82097a4:	1009883a 	mov	r4,r2
 82097a8:	102b883a 	mov	r21,r2
 82097ac:	8213f340 	call	8213f34 <__floatsidf>
 82097b0:	800d883a 	mov	r6,r16
 82097b4:	880f883a 	mov	r7,r17
 82097b8:	1009883a 	mov	r4,r2
 82097bc:	180b883a 	mov	r5,r3
 82097c0:	8212ea00 	call	8212ea0 <__muldf3>
 82097c4:	100d883a 	mov	r6,r2
 82097c8:	180f883a 	mov	r7,r3
 82097cc:	9009883a 	mov	r4,r18
 82097d0:	980b883a 	mov	r5,r19
 82097d4:	82135b80 	call	82135b8 <__subdf3>
 82097d8:	aa000c04 	addi	r8,r21,48
 82097dc:	a2000005 	stb	r8,0(r20)
 82097e0:	000d883a 	mov	r6,zero
 82097e4:	01d00934 	movhi	r7,16420
 82097e8:	1009883a 	mov	r4,r2
 82097ec:	180b883a 	mov	r5,r3
 82097f0:	a5c00044 	addi	r23,r20,1
 82097f4:	b53fd91e 	bne	r22,r20,820975c <_dtoa_r+0x858>
 82097f8:	100d883a 	mov	r6,r2
 82097fc:	180f883a 	mov	r7,r3
 8209800:	1009883a 	mov	r4,r2
 8209804:	180b883a 	mov	r5,r3
 8209808:	8211ab40 	call	8211ab4 <__adddf3>
 820980c:	100d883a 	mov	r6,r2
 8209810:	180f883a 	mov	r7,r3
 8209814:	8009883a 	mov	r4,r16
 8209818:	880b883a 	mov	r5,r17
 820981c:	1027883a 	mov	r19,r2
 8209820:	1825883a 	mov	r18,r3
 8209824:	8212dac0 	call	8212dac <__ledf2>
 8209828:	10000816 	blt	r2,zero,820984c <_dtoa_r+0x948>
 820982c:	980d883a 	mov	r6,r19
 8209830:	900f883a 	mov	r7,r18
 8209834:	8009883a 	mov	r4,r16
 8209838:	880b883a 	mov	r5,r17
 820983c:	8212c480 	call	8212c48 <__eqdf2>
 8209840:	103f5a1e 	bne	r2,zero,82095ac <_dtoa_r+0x6a8>
 8209844:	ad40004c 	andi	r21,r21,1
 8209848:	a83f5826 	beq	r21,zero,82095ac <_dtoa_r+0x6a8>
 820984c:	bd3fffc3 	ldbu	r20,-1(r23)
 8209850:	b8bfffc4 	addi	r2,r23,-1
 8209854:	1007883a 	mov	r3,r2
 8209858:	01400e44 	movi	r5,57
 820985c:	d9800717 	ldw	r6,28(sp)
 8209860:	00000506 	br	8209878 <_dtoa_r+0x974>
 8209864:	18ffffc4 	addi	r3,r3,-1
 8209868:	11824726 	beq	r2,r6,820a188 <_dtoa_r+0x1284>
 820986c:	1d000003 	ldbu	r20,0(r3)
 8209870:	102f883a 	mov	r23,r2
 8209874:	10bfffc4 	addi	r2,r2,-1
 8209878:	a1003fcc 	andi	r4,r20,255
 820987c:	2100201c 	xori	r4,r4,128
 8209880:	213fe004 	addi	r4,r4,-128
 8209884:	217ff726 	beq	r4,r5,8209864 <_dtoa_r+0x960>
 8209888:	a2000044 	addi	r8,r20,1
 820988c:	12000005 	stb	r8,0(r2)
 8209890:	003f4606 	br	82095ac <_dtoa_r+0x6a8>
 8209894:	d9000b17 	ldw	r4,44(sp)
 8209898:	2000c826 	beq	r4,zero,8209bbc <_dtoa_r+0xcb8>
 820989c:	d9800317 	ldw	r6,12(sp)
 82098a0:	00c00044 	movi	r3,1
 82098a4:	1980f90e 	bge	r3,r6,8209c8c <_dtoa_r+0xd88>
 82098a8:	d8800617 	ldw	r2,24(sp)
 82098ac:	d8c00a17 	ldw	r3,40(sp)
 82098b0:	157fffc4 	addi	r21,r2,-1
 82098b4:	1d41f316 	blt	r3,r21,820a084 <_dtoa_r+0x1180>
 82098b8:	1d6bc83a 	sub	r21,r3,r21
 82098bc:	d9c00617 	ldw	r7,24(sp)
 82098c0:	3802aa16 	blt	r7,zero,820a36c <_dtoa_r+0x1468>
 82098c4:	dd000817 	ldw	r20,32(sp)
 82098c8:	d8800617 	ldw	r2,24(sp)
 82098cc:	d8c00817 	ldw	r3,32(sp)
 82098d0:	01400044 	movi	r5,1
 82098d4:	e009883a 	mov	r4,fp
 82098d8:	1887883a 	add	r3,r3,r2
 82098dc:	d8c00815 	stw	r3,32(sp)
 82098e0:	b0ad883a 	add	r22,r22,r2
 82098e4:	820c7b00 	call	820c7b0 <__i2b>
 82098e8:	1023883a 	mov	r17,r2
 82098ec:	a0000826 	beq	r20,zero,8209910 <_dtoa_r+0xa0c>
 82098f0:	0580070e 	bge	zero,r22,8209910 <_dtoa_r+0xa0c>
 82098f4:	a005883a 	mov	r2,r20
 82098f8:	b500b916 	blt	r22,r20,8209be0 <_dtoa_r+0xcdc>
 82098fc:	d9000817 	ldw	r4,32(sp)
 8209900:	a0a9c83a 	sub	r20,r20,r2
 8209904:	b0adc83a 	sub	r22,r22,r2
 8209908:	2089c83a 	sub	r4,r4,r2
 820990c:	d9000815 	stw	r4,32(sp)
 8209910:	d9800a17 	ldw	r6,40(sp)
 8209914:	0181810e 	bge	zero,r6,8209f1c <_dtoa_r+0x1018>
 8209918:	d9c00b17 	ldw	r7,44(sp)
 820991c:	3800b326 	beq	r7,zero,8209bec <_dtoa_r+0xce8>
 8209920:	a800b226 	beq	r21,zero,8209bec <_dtoa_r+0xce8>
 8209924:	880b883a 	mov	r5,r17
 8209928:	a80d883a 	mov	r6,r21
 820992c:	e009883a 	mov	r4,fp
 8209930:	820c9e40 	call	820c9e4 <__pow5mult>
 8209934:	d9800917 	ldw	r6,36(sp)
 8209938:	100b883a 	mov	r5,r2
 820993c:	e009883a 	mov	r4,fp
 8209940:	1023883a 	mov	r17,r2
 8209944:	820c7ec0 	call	820c7ec <__multiply>
 8209948:	1021883a 	mov	r16,r2
 820994c:	d8800a17 	ldw	r2,40(sp)
 8209950:	d9400917 	ldw	r5,36(sp)
 8209954:	e009883a 	mov	r4,fp
 8209958:	1545c83a 	sub	r2,r2,r21
 820995c:	d8800a15 	stw	r2,40(sp)
 8209960:	820c44c0 	call	820c44c <_Bfree>
 8209964:	d8c00a17 	ldw	r3,40(sp)
 8209968:	18009f1e 	bne	r3,zero,8209be8 <_dtoa_r+0xce4>
 820996c:	05c00044 	movi	r23,1
 8209970:	e009883a 	mov	r4,fp
 8209974:	b80b883a 	mov	r5,r23
 8209978:	820c7b00 	call	820c7b0 <__i2b>
 820997c:	d9000d17 	ldw	r4,52(sp)
 8209980:	102b883a 	mov	r21,r2
 8209984:	2000ce26 	beq	r4,zero,8209cc0 <_dtoa_r+0xdbc>
 8209988:	200d883a 	mov	r6,r4
 820998c:	100b883a 	mov	r5,r2
 8209990:	e009883a 	mov	r4,fp
 8209994:	820c9e40 	call	820c9e4 <__pow5mult>
 8209998:	d9800317 	ldw	r6,12(sp)
 820999c:	102b883a 	mov	r21,r2
 82099a0:	b981810e 	bge	r23,r6,8209fa8 <_dtoa_r+0x10a4>
 82099a4:	0027883a 	mov	r19,zero
 82099a8:	a8800417 	ldw	r2,16(r21)
 82099ac:	05c00804 	movi	r23,32
 82099b0:	10800104 	addi	r2,r2,4
 82099b4:	1085883a 	add	r2,r2,r2
 82099b8:	1085883a 	add	r2,r2,r2
 82099bc:	a885883a 	add	r2,r21,r2
 82099c0:	11000017 	ldw	r4,0(r2)
 82099c4:	820c6980 	call	820c698 <__hi0bits>
 82099c8:	b885c83a 	sub	r2,r23,r2
 82099cc:	1585883a 	add	r2,r2,r22
 82099d0:	108007cc 	andi	r2,r2,31
 82099d4:	1000b326 	beq	r2,zero,8209ca4 <_dtoa_r+0xda0>
 82099d8:	00c00804 	movi	r3,32
 82099dc:	1887c83a 	sub	r3,r3,r2
 82099e0:	01000104 	movi	r4,4
 82099e4:	20c2cd0e 	bge	r4,r3,820a51c <_dtoa_r+0x1618>
 82099e8:	00c00704 	movi	r3,28
 82099ec:	1885c83a 	sub	r2,r3,r2
 82099f0:	d8c00817 	ldw	r3,32(sp)
 82099f4:	a0a9883a 	add	r20,r20,r2
 82099f8:	b0ad883a 	add	r22,r22,r2
 82099fc:	1887883a 	add	r3,r3,r2
 8209a00:	d8c00815 	stw	r3,32(sp)
 8209a04:	d9800817 	ldw	r6,32(sp)
 8209a08:	0180040e 	bge	zero,r6,8209a1c <_dtoa_r+0xb18>
 8209a0c:	800b883a 	mov	r5,r16
 8209a10:	e009883a 	mov	r4,fp
 8209a14:	820cb240 	call	820cb24 <__lshift>
 8209a18:	1021883a 	mov	r16,r2
 8209a1c:	0580050e 	bge	zero,r22,8209a34 <_dtoa_r+0xb30>
 8209a20:	a80b883a 	mov	r5,r21
 8209a24:	b00d883a 	mov	r6,r22
 8209a28:	e009883a 	mov	r4,fp
 8209a2c:	820cb240 	call	820cb24 <__lshift>
 8209a30:	102b883a 	mov	r21,r2
 8209a34:	d9c00e17 	ldw	r7,56(sp)
 8209a38:	3801211e 	bne	r7,zero,8209ec0 <_dtoa_r+0xfbc>
 8209a3c:	d9800617 	ldw	r6,24(sp)
 8209a40:	0181380e 	bge	zero,r6,8209f24 <_dtoa_r+0x1020>
 8209a44:	d8c00b17 	ldw	r3,44(sp)
 8209a48:	1800ab1e 	bne	r3,zero,8209cf8 <_dtoa_r+0xdf4>
 8209a4c:	dc800717 	ldw	r18,28(sp)
 8209a50:	dcc00617 	ldw	r19,24(sp)
 8209a54:	9029883a 	mov	r20,r18
 8209a58:	00000206 	br	8209a64 <_dtoa_r+0xb60>
 8209a5c:	820c4740 	call	820c474 <__multadd>
 8209a60:	1021883a 	mov	r16,r2
 8209a64:	a80b883a 	mov	r5,r21
 8209a68:	8009883a 	mov	r4,r16
 8209a6c:	8208d040 	call	8208d04 <quorem>
 8209a70:	10800c04 	addi	r2,r2,48
 8209a74:	90800005 	stb	r2,0(r18)
 8209a78:	94800044 	addi	r18,r18,1
 8209a7c:	9507c83a 	sub	r3,r18,r20
 8209a80:	000f883a 	mov	r7,zero
 8209a84:	01800284 	movi	r6,10
 8209a88:	800b883a 	mov	r5,r16
 8209a8c:	e009883a 	mov	r4,fp
 8209a90:	1cfff216 	blt	r3,r19,8209a5c <_dtoa_r+0xb58>
 8209a94:	1011883a 	mov	r8,r2
 8209a98:	d8800617 	ldw	r2,24(sp)
 8209a9c:	0082370e 	bge	zero,r2,820a37c <_dtoa_r+0x1478>
 8209aa0:	d9000717 	ldw	r4,28(sp)
 8209aa4:	0025883a 	mov	r18,zero
 8209aa8:	20af883a 	add	r23,r4,r2
 8209aac:	01800044 	movi	r6,1
 8209ab0:	800b883a 	mov	r5,r16
 8209ab4:	e009883a 	mov	r4,fp
 8209ab8:	da001715 	stw	r8,92(sp)
 8209abc:	820cb240 	call	820cb24 <__lshift>
 8209ac0:	a80b883a 	mov	r5,r21
 8209ac4:	1009883a 	mov	r4,r2
 8209ac8:	d8800915 	stw	r2,36(sp)
 8209acc:	820cc6c0 	call	820cc6c <__mcmp>
 8209ad0:	da001717 	ldw	r8,92(sp)
 8209ad4:	0081800e 	bge	zero,r2,820a0d8 <_dtoa_r+0x11d4>
 8209ad8:	b93fffc3 	ldbu	r4,-1(r23)
 8209adc:	b8bfffc4 	addi	r2,r23,-1
 8209ae0:	1007883a 	mov	r3,r2
 8209ae4:	01800e44 	movi	r6,57
 8209ae8:	d9c00717 	ldw	r7,28(sp)
 8209aec:	00000506 	br	8209b04 <_dtoa_r+0xc00>
 8209af0:	18ffffc4 	addi	r3,r3,-1
 8209af4:	11c12326 	beq	r2,r7,8209f84 <_dtoa_r+0x1080>
 8209af8:	19000003 	ldbu	r4,0(r3)
 8209afc:	102f883a 	mov	r23,r2
 8209b00:	10bfffc4 	addi	r2,r2,-1
 8209b04:	21403fcc 	andi	r5,r4,255
 8209b08:	2940201c 	xori	r5,r5,128
 8209b0c:	297fe004 	addi	r5,r5,-128
 8209b10:	29bff726 	beq	r5,r6,8209af0 <_dtoa_r+0xbec>
 8209b14:	21000044 	addi	r4,r4,1
 8209b18:	11000005 	stb	r4,0(r2)
 8209b1c:	a80b883a 	mov	r5,r21
 8209b20:	e009883a 	mov	r4,fp
 8209b24:	820c44c0 	call	820c44c <_Bfree>
 8209b28:	883ea026 	beq	r17,zero,82095ac <_dtoa_r+0x6a8>
 8209b2c:	90000426 	beq	r18,zero,8209b40 <_dtoa_r+0xc3c>
 8209b30:	94400326 	beq	r18,r17,8209b40 <_dtoa_r+0xc3c>
 8209b34:	900b883a 	mov	r5,r18
 8209b38:	e009883a 	mov	r4,fp
 8209b3c:	820c44c0 	call	820c44c <_Bfree>
 8209b40:	880b883a 	mov	r5,r17
 8209b44:	e009883a 	mov	r4,fp
 8209b48:	820c44c0 	call	820c44c <_Bfree>
 8209b4c:	003e9706 	br	82095ac <_dtoa_r+0x6a8>
 8209b50:	01800044 	movi	r6,1
 8209b54:	d9800e15 	stw	r6,56(sp)
 8209b58:	003d9606 	br	82091b4 <_dtoa_r+0x2b0>
 8209b5c:	d8800817 	ldw	r2,32(sp)
 8209b60:	d8c00517 	ldw	r3,20(sp)
 8209b64:	d8000d15 	stw	zero,52(sp)
 8209b68:	10c5c83a 	sub	r2,r2,r3
 8209b6c:	00c9c83a 	sub	r4,zero,r3
 8209b70:	d8800815 	stw	r2,32(sp)
 8209b74:	d9000a15 	stw	r4,40(sp)
 8209b78:	003d9706 	br	82091d8 <_dtoa_r+0x2d4>
 8209b7c:	05adc83a 	sub	r22,zero,r22
 8209b80:	dd800815 	stw	r22,32(sp)
 8209b84:	002d883a 	mov	r22,zero
 8209b88:	003d8e06 	br	82091c4 <_dtoa_r+0x2c0>
 8209b8c:	d9000517 	ldw	r4,20(sp)
 8209b90:	8213f340 	call	8213f34 <__floatsidf>
 8209b94:	100d883a 	mov	r6,r2
 8209b98:	180f883a 	mov	r7,r3
 8209b9c:	a009883a 	mov	r4,r20
 8209ba0:	880b883a 	mov	r5,r17
 8209ba4:	8212c480 	call	8212c48 <__eqdf2>
 8209ba8:	103d7126 	beq	r2,zero,8209170 <_dtoa_r+0x26c>
 8209bac:	d9c00517 	ldw	r7,20(sp)
 8209bb0:	39ffffc4 	addi	r7,r7,-1
 8209bb4:	d9c00515 	stw	r7,20(sp)
 8209bb8:	003d6d06 	br	8209170 <_dtoa_r+0x26c>
 8209bbc:	dd400a17 	ldw	r21,40(sp)
 8209bc0:	dd000817 	ldw	r20,32(sp)
 8209bc4:	0023883a 	mov	r17,zero
 8209bc8:	003f4806 	br	82098ec <_dtoa_r+0x9e8>
 8209bcc:	10e3c83a 	sub	r17,r2,r3
 8209bd0:	9448983a 	sll	r4,r18,r17
 8209bd4:	003d3206 	br	82090a0 <_dtoa_r+0x19c>
 8209bd8:	d8000e15 	stw	zero,56(sp)
 8209bdc:	003d7506 	br	82091b4 <_dtoa_r+0x2b0>
 8209be0:	b005883a 	mov	r2,r22
 8209be4:	003f4506 	br	82098fc <_dtoa_r+0x9f8>
 8209be8:	dc000915 	stw	r16,36(sp)
 8209bec:	d9800a17 	ldw	r6,40(sp)
 8209bf0:	d9400917 	ldw	r5,36(sp)
 8209bf4:	e009883a 	mov	r4,fp
 8209bf8:	820c9e40 	call	820c9e4 <__pow5mult>
 8209bfc:	1021883a 	mov	r16,r2
 8209c00:	003f5a06 	br	820996c <_dtoa_r+0xa68>
 8209c04:	01c00044 	movi	r7,1
 8209c08:	d9c00b15 	stw	r7,44(sp)
 8209c0c:	d8802217 	ldw	r2,136(sp)
 8209c10:	0081280e 	bge	zero,r2,820a0b4 <_dtoa_r+0x11b0>
 8209c14:	100d883a 	mov	r6,r2
 8209c18:	1021883a 	mov	r16,r2
 8209c1c:	d8800c15 	stw	r2,48(sp)
 8209c20:	d8800615 	stw	r2,24(sp)
 8209c24:	003d8806 	br	8209248 <_dtoa_r+0x344>
 8209c28:	d8800617 	ldw	r2,24(sp)
 8209c2c:	00be9b16 	blt	zero,r2,820969c <_dtoa_r+0x798>
 8209c30:	10010f1e 	bne	r2,zero,820a070 <_dtoa_r+0x116c>
 8209c34:	880b883a 	mov	r5,r17
 8209c38:	000d883a 	mov	r6,zero
 8209c3c:	01d00534 	movhi	r7,16404
 8209c40:	8009883a 	mov	r4,r16
 8209c44:	8212ea00 	call	8212ea0 <__muldf3>
 8209c48:	900d883a 	mov	r6,r18
 8209c4c:	980f883a 	mov	r7,r19
 8209c50:	1009883a 	mov	r4,r2
 8209c54:	180b883a 	mov	r5,r3
 8209c58:	8212cd00 	call	8212cd0 <__gedf2>
 8209c5c:	002b883a 	mov	r21,zero
 8209c60:	0023883a 	mov	r17,zero
 8209c64:	1000bf16 	blt	r2,zero,8209f64 <_dtoa_r+0x1060>
 8209c68:	d9802217 	ldw	r6,136(sp)
 8209c6c:	ddc00717 	ldw	r23,28(sp)
 8209c70:	018c303a 	nor	r6,zero,r6
 8209c74:	d9800515 	stw	r6,20(sp)
 8209c78:	a80b883a 	mov	r5,r21
 8209c7c:	e009883a 	mov	r4,fp
 8209c80:	820c44c0 	call	820c44c <_Bfree>
 8209c84:	883e4926 	beq	r17,zero,82095ac <_dtoa_r+0x6a8>
 8209c88:	003fad06 	br	8209b40 <_dtoa_r+0xc3c>
 8209c8c:	d9c01117 	ldw	r7,68(sp)
 8209c90:	3801bc26 	beq	r7,zero,820a384 <_dtoa_r+0x1480>
 8209c94:	10810cc4 	addi	r2,r2,1075
 8209c98:	dd400a17 	ldw	r21,40(sp)
 8209c9c:	dd000817 	ldw	r20,32(sp)
 8209ca0:	003f0a06 	br	82098cc <_dtoa_r+0x9c8>
 8209ca4:	00800704 	movi	r2,28
 8209ca8:	d9000817 	ldw	r4,32(sp)
 8209cac:	a0a9883a 	add	r20,r20,r2
 8209cb0:	b0ad883a 	add	r22,r22,r2
 8209cb4:	2089883a 	add	r4,r4,r2
 8209cb8:	d9000815 	stw	r4,32(sp)
 8209cbc:	003f5106 	br	8209a04 <_dtoa_r+0xb00>
 8209cc0:	d8c00317 	ldw	r3,12(sp)
 8209cc4:	b8c1fc0e 	bge	r23,r3,820a4b8 <_dtoa_r+0x15b4>
 8209cc8:	0027883a 	mov	r19,zero
 8209ccc:	b805883a 	mov	r2,r23
 8209cd0:	003f3e06 	br	82099cc <_dtoa_r+0xac8>
 8209cd4:	880b883a 	mov	r5,r17
 8209cd8:	e009883a 	mov	r4,fp
 8209cdc:	000f883a 	mov	r7,zero
 8209ce0:	01800284 	movi	r6,10
 8209ce4:	820c4740 	call	820c474 <__multadd>
 8209ce8:	d9000c17 	ldw	r4,48(sp)
 8209cec:	1023883a 	mov	r17,r2
 8209cf0:	0102040e 	bge	zero,r4,820a504 <_dtoa_r+0x1600>
 8209cf4:	d9000615 	stw	r4,24(sp)
 8209cf8:	0500050e 	bge	zero,r20,8209d10 <_dtoa_r+0xe0c>
 8209cfc:	880b883a 	mov	r5,r17
 8209d00:	a00d883a 	mov	r6,r20
 8209d04:	e009883a 	mov	r4,fp
 8209d08:	820cb240 	call	820cb24 <__lshift>
 8209d0c:	1023883a 	mov	r17,r2
 8209d10:	9801241e 	bne	r19,zero,820a1a4 <_dtoa_r+0x12a0>
 8209d14:	8829883a 	mov	r20,r17
 8209d18:	d9000617 	ldw	r4,24(sp)
 8209d1c:	dcc00717 	ldw	r19,28(sp)
 8209d20:	9480004c 	andi	r18,r18,1
 8209d24:	20bfffc4 	addi	r2,r4,-1
 8209d28:	9885883a 	add	r2,r19,r2
 8209d2c:	d8800415 	stw	r2,16(sp)
 8209d30:	dc800615 	stw	r18,24(sp)
 8209d34:	a80b883a 	mov	r5,r21
 8209d38:	8009883a 	mov	r4,r16
 8209d3c:	8208d040 	call	8208d04 <quorem>
 8209d40:	880b883a 	mov	r5,r17
 8209d44:	8009883a 	mov	r4,r16
 8209d48:	102f883a 	mov	r23,r2
 8209d4c:	820cc6c0 	call	820cc6c <__mcmp>
 8209d50:	a80b883a 	mov	r5,r21
 8209d54:	a00d883a 	mov	r6,r20
 8209d58:	e009883a 	mov	r4,fp
 8209d5c:	102d883a 	mov	r22,r2
 8209d60:	820cccc0 	call	820cccc <__mdiff>
 8209d64:	1007883a 	mov	r3,r2
 8209d68:	10800317 	ldw	r2,12(r2)
 8209d6c:	bc800c04 	addi	r18,r23,48
 8209d70:	180b883a 	mov	r5,r3
 8209d74:	10004e1e 	bne	r2,zero,8209eb0 <_dtoa_r+0xfac>
 8209d78:	8009883a 	mov	r4,r16
 8209d7c:	d8c01615 	stw	r3,88(sp)
 8209d80:	820cc6c0 	call	820cc6c <__mcmp>
 8209d84:	d8c01617 	ldw	r3,88(sp)
 8209d88:	e009883a 	mov	r4,fp
 8209d8c:	d8801615 	stw	r2,88(sp)
 8209d90:	180b883a 	mov	r5,r3
 8209d94:	820c44c0 	call	820c44c <_Bfree>
 8209d98:	d8801617 	ldw	r2,88(sp)
 8209d9c:	1000041e 	bne	r2,zero,8209db0 <_dtoa_r+0xeac>
 8209da0:	d9800317 	ldw	r6,12(sp)
 8209da4:	3000021e 	bne	r6,zero,8209db0 <_dtoa_r+0xeac>
 8209da8:	d8c00617 	ldw	r3,24(sp)
 8209dac:	18003726 	beq	r3,zero,8209e8c <_dtoa_r+0xf88>
 8209db0:	b0002016 	blt	r22,zero,8209e34 <_dtoa_r+0xf30>
 8209db4:	b000041e 	bne	r22,zero,8209dc8 <_dtoa_r+0xec4>
 8209db8:	d9000317 	ldw	r4,12(sp)
 8209dbc:	2000021e 	bne	r4,zero,8209dc8 <_dtoa_r+0xec4>
 8209dc0:	d8c00617 	ldw	r3,24(sp)
 8209dc4:	18001b26 	beq	r3,zero,8209e34 <_dtoa_r+0xf30>
 8209dc8:	00810716 	blt	zero,r2,820a1e8 <_dtoa_r+0x12e4>
 8209dcc:	d8c00417 	ldw	r3,16(sp)
 8209dd0:	9d800044 	addi	r22,r19,1
 8209dd4:	9c800005 	stb	r18,0(r19)
 8209dd8:	b02f883a 	mov	r23,r22
 8209ddc:	98c10626 	beq	r19,r3,820a1f8 <_dtoa_r+0x12f4>
 8209de0:	800b883a 	mov	r5,r16
 8209de4:	000f883a 	mov	r7,zero
 8209de8:	01800284 	movi	r6,10
 8209dec:	e009883a 	mov	r4,fp
 8209df0:	820c4740 	call	820c474 <__multadd>
 8209df4:	1021883a 	mov	r16,r2
 8209df8:	000f883a 	mov	r7,zero
 8209dfc:	01800284 	movi	r6,10
 8209e00:	880b883a 	mov	r5,r17
 8209e04:	e009883a 	mov	r4,fp
 8209e08:	8d002526 	beq	r17,r20,8209ea0 <_dtoa_r+0xf9c>
 8209e0c:	820c4740 	call	820c474 <__multadd>
 8209e10:	a00b883a 	mov	r5,r20
 8209e14:	000f883a 	mov	r7,zero
 8209e18:	01800284 	movi	r6,10
 8209e1c:	e009883a 	mov	r4,fp
 8209e20:	1023883a 	mov	r17,r2
 8209e24:	820c4740 	call	820c474 <__multadd>
 8209e28:	1029883a 	mov	r20,r2
 8209e2c:	b027883a 	mov	r19,r22
 8209e30:	003fc006 	br	8209d34 <_dtoa_r+0xe30>
 8209e34:	9011883a 	mov	r8,r18
 8209e38:	00800e0e 	bge	zero,r2,8209e74 <_dtoa_r+0xf70>
 8209e3c:	800b883a 	mov	r5,r16
 8209e40:	01800044 	movi	r6,1
 8209e44:	e009883a 	mov	r4,fp
 8209e48:	da001715 	stw	r8,92(sp)
 8209e4c:	820cb240 	call	820cb24 <__lshift>
 8209e50:	a80b883a 	mov	r5,r21
 8209e54:	1009883a 	mov	r4,r2
 8209e58:	1021883a 	mov	r16,r2
 8209e5c:	820cc6c0 	call	820cc6c <__mcmp>
 8209e60:	da001717 	ldw	r8,92(sp)
 8209e64:	0081960e 	bge	zero,r2,820a4c0 <_dtoa_r+0x15bc>
 8209e68:	00800e44 	movi	r2,57
 8209e6c:	40817026 	beq	r8,r2,820a430 <_dtoa_r+0x152c>
 8209e70:	ba000c44 	addi	r8,r23,49
 8209e74:	8825883a 	mov	r18,r17
 8209e78:	9dc00044 	addi	r23,r19,1
 8209e7c:	9a000005 	stb	r8,0(r19)
 8209e80:	a023883a 	mov	r17,r20
 8209e84:	dc000915 	stw	r16,36(sp)
 8209e88:	003f2406 	br	8209b1c <_dtoa_r+0xc18>
 8209e8c:	00800e44 	movi	r2,57
 8209e90:	9011883a 	mov	r8,r18
 8209e94:	90816626 	beq	r18,r2,820a430 <_dtoa_r+0x152c>
 8209e98:	05bff516 	blt	zero,r22,8209e70 <_dtoa_r+0xf6c>
 8209e9c:	003ff506 	br	8209e74 <_dtoa_r+0xf70>
 8209ea0:	820c4740 	call	820c474 <__multadd>
 8209ea4:	1023883a 	mov	r17,r2
 8209ea8:	1029883a 	mov	r20,r2
 8209eac:	003fdf06 	br	8209e2c <_dtoa_r+0xf28>
 8209eb0:	e009883a 	mov	r4,fp
 8209eb4:	820c44c0 	call	820c44c <_Bfree>
 8209eb8:	00800044 	movi	r2,1
 8209ebc:	003fbc06 	br	8209db0 <_dtoa_r+0xeac>
 8209ec0:	a80b883a 	mov	r5,r21
 8209ec4:	8009883a 	mov	r4,r16
 8209ec8:	820cc6c0 	call	820cc6c <__mcmp>
 8209ecc:	103edb0e 	bge	r2,zero,8209a3c <_dtoa_r+0xb38>
 8209ed0:	800b883a 	mov	r5,r16
 8209ed4:	000f883a 	mov	r7,zero
 8209ed8:	01800284 	movi	r6,10
 8209edc:	e009883a 	mov	r4,fp
 8209ee0:	820c4740 	call	820c474 <__multadd>
 8209ee4:	1021883a 	mov	r16,r2
 8209ee8:	d8800517 	ldw	r2,20(sp)
 8209eec:	d8c00b17 	ldw	r3,44(sp)
 8209ef0:	10bfffc4 	addi	r2,r2,-1
 8209ef4:	d8800515 	stw	r2,20(sp)
 8209ef8:	183f761e 	bne	r3,zero,8209cd4 <_dtoa_r+0xdd0>
 8209efc:	d9000c17 	ldw	r4,48(sp)
 8209f00:	0101730e 	bge	zero,r4,820a4d0 <_dtoa_r+0x15cc>
 8209f04:	d9000615 	stw	r4,24(sp)
 8209f08:	003ed006 	br	8209a4c <_dtoa_r+0xb48>
 8209f0c:	00800084 	movi	r2,2
 8209f10:	3081861e 	bne	r6,r2,820a52c <_dtoa_r+0x1628>
 8209f14:	d8000b15 	stw	zero,44(sp)
 8209f18:	003f3c06 	br	8209c0c <_dtoa_r+0xd08>
 8209f1c:	dc000917 	ldw	r16,36(sp)
 8209f20:	003e9206 	br	820996c <_dtoa_r+0xa68>
 8209f24:	d9c00317 	ldw	r7,12(sp)
 8209f28:	00800084 	movi	r2,2
 8209f2c:	11fec50e 	bge	r2,r7,8209a44 <_dtoa_r+0xb40>
 8209f30:	d9000617 	ldw	r4,24(sp)
 8209f34:	20013c1e 	bne	r4,zero,820a428 <_dtoa_r+0x1524>
 8209f38:	a80b883a 	mov	r5,r21
 8209f3c:	000f883a 	mov	r7,zero
 8209f40:	01800144 	movi	r6,5
 8209f44:	e009883a 	mov	r4,fp
 8209f48:	820c4740 	call	820c474 <__multadd>
 8209f4c:	100b883a 	mov	r5,r2
 8209f50:	8009883a 	mov	r4,r16
 8209f54:	102b883a 	mov	r21,r2
 8209f58:	820cc6c0 	call	820cc6c <__mcmp>
 8209f5c:	dc000915 	stw	r16,36(sp)
 8209f60:	00bf410e 	bge	zero,r2,8209c68 <_dtoa_r+0xd64>
 8209f64:	d9c00717 	ldw	r7,28(sp)
 8209f68:	00800c44 	movi	r2,49
 8209f6c:	38800005 	stb	r2,0(r7)
 8209f70:	d8800517 	ldw	r2,20(sp)
 8209f74:	3dc00044 	addi	r23,r7,1
 8209f78:	10800044 	addi	r2,r2,1
 8209f7c:	d8800515 	stw	r2,20(sp)
 8209f80:	003f3d06 	br	8209c78 <_dtoa_r+0xd74>
 8209f84:	d9800517 	ldw	r6,20(sp)
 8209f88:	d9c00717 	ldw	r7,28(sp)
 8209f8c:	00800c44 	movi	r2,49
 8209f90:	31800044 	addi	r6,r6,1
 8209f94:	d9800515 	stw	r6,20(sp)
 8209f98:	38800005 	stb	r2,0(r7)
 8209f9c:	003edf06 	br	8209b1c <_dtoa_r+0xc18>
 8209fa0:	d8000b15 	stw	zero,44(sp)
 8209fa4:	003c9f06 	br	8209224 <_dtoa_r+0x320>
 8209fa8:	903e7e1e 	bne	r18,zero,82099a4 <_dtoa_r+0xaa0>
 8209fac:	00800434 	movhi	r2,16
 8209fb0:	10bfffc4 	addi	r2,r2,-1
 8209fb4:	9884703a 	and	r2,r19,r2
 8209fb8:	1000ea1e 	bne	r2,zero,820a364 <_dtoa_r+0x1460>
 8209fbc:	9cdffc2c 	andhi	r19,r19,32752
 8209fc0:	9800e826 	beq	r19,zero,820a364 <_dtoa_r+0x1460>
 8209fc4:	d9c00817 	ldw	r7,32(sp)
 8209fc8:	b5800044 	addi	r22,r22,1
 8209fcc:	04c00044 	movi	r19,1
 8209fd0:	39c00044 	addi	r7,r7,1
 8209fd4:	d9c00815 	stw	r7,32(sp)
 8209fd8:	d8800d17 	ldw	r2,52(sp)
 8209fdc:	103e721e 	bne	r2,zero,82099a8 <_dtoa_r+0xaa4>
 8209fe0:	00800044 	movi	r2,1
 8209fe4:	003e7906 	br	82099cc <_dtoa_r+0xac8>
 8209fe8:	8009883a 	mov	r4,r16
 8209fec:	8213f340 	call	8213f34 <__floatsidf>
 8209ff0:	d9800f17 	ldw	r6,60(sp)
 8209ff4:	d9c01017 	ldw	r7,64(sp)
 8209ff8:	1009883a 	mov	r4,r2
 8209ffc:	180b883a 	mov	r5,r3
 820a000:	8212ea00 	call	8212ea0 <__muldf3>
 820a004:	000d883a 	mov	r6,zero
 820a008:	01d00734 	movhi	r7,16412
 820a00c:	1009883a 	mov	r4,r2
 820a010:	180b883a 	mov	r5,r3
 820a014:	8211ab40 	call	8211ab4 <__adddf3>
 820a018:	047f3034 	movhi	r17,64704
 820a01c:	1021883a 	mov	r16,r2
 820a020:	1c63883a 	add	r17,r3,r17
 820a024:	d9000f17 	ldw	r4,60(sp)
 820a028:	d9401017 	ldw	r5,64(sp)
 820a02c:	000d883a 	mov	r6,zero
 820a030:	01d00534 	movhi	r7,16404
 820a034:	82135b80 	call	82135b8 <__subdf3>
 820a038:	800d883a 	mov	r6,r16
 820a03c:	880f883a 	mov	r7,r17
 820a040:	1009883a 	mov	r4,r2
 820a044:	180b883a 	mov	r5,r3
 820a048:	102b883a 	mov	r21,r2
 820a04c:	1829883a 	mov	r20,r3
 820a050:	8212cd00 	call	8212cd0 <__gedf2>
 820a054:	00806c16 	blt	zero,r2,820a208 <_dtoa_r+0x1304>
 820a058:	89e0003c 	xorhi	r7,r17,32768
 820a05c:	800d883a 	mov	r6,r16
 820a060:	a809883a 	mov	r4,r21
 820a064:	a00b883a 	mov	r5,r20
 820a068:	8212dac0 	call	8212dac <__ledf2>
 820a06c:	103d7e0e 	bge	r2,zero,8209668 <_dtoa_r+0x764>
 820a070:	002b883a 	mov	r21,zero
 820a074:	0023883a 	mov	r17,zero
 820a078:	003efb06 	br	8209c68 <_dtoa_r+0xd64>
 820a07c:	d8800717 	ldw	r2,28(sp)
 820a080:	003bd006 	br	8208fc4 <_dtoa_r+0xc0>
 820a084:	d9000a17 	ldw	r4,40(sp)
 820a088:	d9800d17 	ldw	r6,52(sp)
 820a08c:	dd400a15 	stw	r21,40(sp)
 820a090:	a905c83a 	sub	r2,r21,r4
 820a094:	308d883a 	add	r6,r6,r2
 820a098:	d9800d15 	stw	r6,52(sp)
 820a09c:	002b883a 	mov	r21,zero
 820a0a0:	003e0606 	br	82098bc <_dtoa_r+0x9b8>
 820a0a4:	9023883a 	mov	r17,r18
 820a0a8:	9829883a 	mov	r20,r19
 820a0ac:	04000084 	movi	r16,2
 820a0b0:	003c9206 	br	82092fc <_dtoa_r+0x3f8>
 820a0b4:	04000044 	movi	r16,1
 820a0b8:	dc000c15 	stw	r16,48(sp)
 820a0bc:	dc000615 	stw	r16,24(sp)
 820a0c0:	dc002215 	stw	r16,136(sp)
 820a0c4:	e0001115 	stw	zero,68(fp)
 820a0c8:	000b883a 	mov	r5,zero
 820a0cc:	003c6906 	br	8209274 <_dtoa_r+0x370>
 820a0d0:	3021883a 	mov	r16,r6
 820a0d4:	003ffb06 	br	820a0c4 <_dtoa_r+0x11c0>
 820a0d8:	1000021e 	bne	r2,zero,820a0e4 <_dtoa_r+0x11e0>
 820a0dc:	4200004c 	andi	r8,r8,1
 820a0e0:	403e7d1e 	bne	r8,zero,8209ad8 <_dtoa_r+0xbd4>
 820a0e4:	01000c04 	movi	r4,48
 820a0e8:	00000106 	br	820a0f0 <_dtoa_r+0x11ec>
 820a0ec:	102f883a 	mov	r23,r2
 820a0f0:	b8bfffc4 	addi	r2,r23,-1
 820a0f4:	10c00007 	ldb	r3,0(r2)
 820a0f8:	193ffc26 	beq	r3,r4,820a0ec <_dtoa_r+0x11e8>
 820a0fc:	003e8706 	br	8209b1c <_dtoa_r+0xc18>
 820a100:	d8800517 	ldw	r2,20(sp)
 820a104:	00a3c83a 	sub	r17,zero,r2
 820a108:	8800a426 	beq	r17,zero,820a39c <_dtoa_r+0x1498>
 820a10c:	888003cc 	andi	r2,r17,15
 820a110:	100490fa 	slli	r2,r2,3
 820a114:	00c20974 	movhi	r3,2085
 820a118:	18f61804 	addi	r3,r3,-10144
 820a11c:	1885883a 	add	r2,r3,r2
 820a120:	11800017 	ldw	r6,0(r2)
 820a124:	11c00117 	ldw	r7,4(r2)
 820a128:	9009883a 	mov	r4,r18
 820a12c:	980b883a 	mov	r5,r19
 820a130:	8823d13a 	srai	r17,r17,4
 820a134:	8212ea00 	call	8212ea0 <__muldf3>
 820a138:	d8800f15 	stw	r2,60(sp)
 820a13c:	d8c01015 	stw	r3,64(sp)
 820a140:	8800e826 	beq	r17,zero,820a4e4 <_dtoa_r+0x15e0>
 820a144:	05020974 	movhi	r20,2085
 820a148:	a5360e04 	addi	r20,r20,-10184
 820a14c:	04000084 	movi	r16,2
 820a150:	8980004c 	andi	r6,r17,1
 820a154:	1009883a 	mov	r4,r2
 820a158:	8823d07a 	srai	r17,r17,1
 820a15c:	180b883a 	mov	r5,r3
 820a160:	30000426 	beq	r6,zero,820a174 <_dtoa_r+0x1270>
 820a164:	a1800017 	ldw	r6,0(r20)
 820a168:	a1c00117 	ldw	r7,4(r20)
 820a16c:	84000044 	addi	r16,r16,1
 820a170:	8212ea00 	call	8212ea0 <__muldf3>
 820a174:	a5000204 	addi	r20,r20,8
 820a178:	883ff51e 	bne	r17,zero,820a150 <_dtoa_r+0x124c>
 820a17c:	d8800f15 	stw	r2,60(sp)
 820a180:	d8c01015 	stw	r3,64(sp)
 820a184:	003c7606 	br	8209360 <_dtoa_r+0x45c>
 820a188:	00c00c04 	movi	r3,48
 820a18c:	10c00005 	stb	r3,0(r2)
 820a190:	d8c00517 	ldw	r3,20(sp)
 820a194:	bd3fffc3 	ldbu	r20,-1(r23)
 820a198:	18c00044 	addi	r3,r3,1
 820a19c:	d8c00515 	stw	r3,20(sp)
 820a1a0:	003db906 	br	8209888 <_dtoa_r+0x984>
 820a1a4:	89400117 	ldw	r5,4(r17)
 820a1a8:	e009883a 	mov	r4,fp
 820a1ac:	820c3a40 	call	820c3a4 <_Balloc>
 820a1b0:	89800417 	ldw	r6,16(r17)
 820a1b4:	89400304 	addi	r5,r17,12
 820a1b8:	11000304 	addi	r4,r2,12
 820a1bc:	31800084 	addi	r6,r6,2
 820a1c0:	318d883a 	add	r6,r6,r6
 820a1c4:	318d883a 	add	r6,r6,r6
 820a1c8:	1027883a 	mov	r19,r2
 820a1cc:	8202c5c0 	call	8202c5c <memcpy>
 820a1d0:	01800044 	movi	r6,1
 820a1d4:	980b883a 	mov	r5,r19
 820a1d8:	e009883a 	mov	r4,fp
 820a1dc:	820cb240 	call	820cb24 <__lshift>
 820a1e0:	1029883a 	mov	r20,r2
 820a1e4:	003ecc06 	br	8209d18 <_dtoa_r+0xe14>
 820a1e8:	00800e44 	movi	r2,57
 820a1ec:	90809026 	beq	r18,r2,820a430 <_dtoa_r+0x152c>
 820a1f0:	92000044 	addi	r8,r18,1
 820a1f4:	003f1f06 	br	8209e74 <_dtoa_r+0xf70>
 820a1f8:	9011883a 	mov	r8,r18
 820a1fc:	8825883a 	mov	r18,r17
 820a200:	a023883a 	mov	r17,r20
 820a204:	003e2906 	br	8209aac <_dtoa_r+0xba8>
 820a208:	002b883a 	mov	r21,zero
 820a20c:	0023883a 	mov	r17,zero
 820a210:	003f5406 	br	8209f64 <_dtoa_r+0x1060>
 820a214:	61bfffc4 	addi	r6,r12,-1
 820a218:	300490fa 	slli	r2,r6,3
 820a21c:	00c20974 	movhi	r3,2085
 820a220:	18f61804 	addi	r3,r3,-10144
 820a224:	1885883a 	add	r2,r3,r2
 820a228:	11000017 	ldw	r4,0(r2)
 820a22c:	11400117 	ldw	r5,4(r2)
 820a230:	d8800717 	ldw	r2,28(sp)
 820a234:	880f883a 	mov	r7,r17
 820a238:	d9801215 	stw	r6,72(sp)
 820a23c:	800d883a 	mov	r6,r16
 820a240:	db001615 	stw	r12,88(sp)
 820a244:	15c00044 	addi	r23,r2,1
 820a248:	8212ea00 	call	8212ea0 <__muldf3>
 820a24c:	d9401017 	ldw	r5,64(sp)
 820a250:	d9000f17 	ldw	r4,60(sp)
 820a254:	d8c01515 	stw	r3,84(sp)
 820a258:	d8801415 	stw	r2,80(sp)
 820a25c:	8213eb40 	call	8213eb4 <__fixdfsi>
 820a260:	1009883a 	mov	r4,r2
 820a264:	1021883a 	mov	r16,r2
 820a268:	8213f340 	call	8213f34 <__floatsidf>
 820a26c:	d9000f17 	ldw	r4,60(sp)
 820a270:	d9401017 	ldw	r5,64(sp)
 820a274:	100d883a 	mov	r6,r2
 820a278:	180f883a 	mov	r7,r3
 820a27c:	82135b80 	call	82135b8 <__subdf3>
 820a280:	1829883a 	mov	r20,r3
 820a284:	d8c00717 	ldw	r3,28(sp)
 820a288:	84000c04 	addi	r16,r16,48
 820a28c:	1023883a 	mov	r17,r2
 820a290:	1c000005 	stb	r16,0(r3)
 820a294:	db001617 	ldw	r12,88(sp)
 820a298:	00800044 	movi	r2,1
 820a29c:	60802226 	beq	r12,r2,820a328 <_dtoa_r+0x1424>
 820a2a0:	d9c00717 	ldw	r7,28(sp)
 820a2a4:	8805883a 	mov	r2,r17
 820a2a8:	b82b883a 	mov	r21,r23
 820a2ac:	3b19883a 	add	r12,r7,r12
 820a2b0:	6023883a 	mov	r17,r12
 820a2b4:	a007883a 	mov	r3,r20
 820a2b8:	dc800f15 	stw	r18,60(sp)
 820a2bc:	000d883a 	mov	r6,zero
 820a2c0:	01d00934 	movhi	r7,16420
 820a2c4:	1009883a 	mov	r4,r2
 820a2c8:	180b883a 	mov	r5,r3
 820a2cc:	8212ea00 	call	8212ea0 <__muldf3>
 820a2d0:	180b883a 	mov	r5,r3
 820a2d4:	1009883a 	mov	r4,r2
 820a2d8:	1829883a 	mov	r20,r3
 820a2dc:	1025883a 	mov	r18,r2
 820a2e0:	8213eb40 	call	8213eb4 <__fixdfsi>
 820a2e4:	1009883a 	mov	r4,r2
 820a2e8:	1021883a 	mov	r16,r2
 820a2ec:	8213f340 	call	8213f34 <__floatsidf>
 820a2f0:	100d883a 	mov	r6,r2
 820a2f4:	180f883a 	mov	r7,r3
 820a2f8:	9009883a 	mov	r4,r18
 820a2fc:	a00b883a 	mov	r5,r20
 820a300:	84000c04 	addi	r16,r16,48
 820a304:	82135b80 	call	82135b8 <__subdf3>
 820a308:	ad400044 	addi	r21,r21,1
 820a30c:	ac3fffc5 	stb	r16,-1(r21)
 820a310:	ac7fea1e 	bne	r21,r17,820a2bc <_dtoa_r+0x13b8>
 820a314:	1023883a 	mov	r17,r2
 820a318:	d8801217 	ldw	r2,72(sp)
 820a31c:	dc800f17 	ldw	r18,60(sp)
 820a320:	1829883a 	mov	r20,r3
 820a324:	b8af883a 	add	r23,r23,r2
 820a328:	d9001417 	ldw	r4,80(sp)
 820a32c:	d9401517 	ldw	r5,84(sp)
 820a330:	000d883a 	mov	r6,zero
 820a334:	01cff834 	movhi	r7,16352
 820a338:	8211ab40 	call	8211ab4 <__adddf3>
 820a33c:	880d883a 	mov	r6,r17
 820a340:	a00f883a 	mov	r7,r20
 820a344:	1009883a 	mov	r4,r2
 820a348:	180b883a 	mov	r5,r3
 820a34c:	8212dac0 	call	8212dac <__ledf2>
 820a350:	10003e0e 	bge	r2,zero,820a44c <_dtoa_r+0x1548>
 820a354:	d9001317 	ldw	r4,76(sp)
 820a358:	bd3fffc3 	ldbu	r20,-1(r23)
 820a35c:	d9000515 	stw	r4,20(sp)
 820a360:	003d3b06 	br	8209850 <_dtoa_r+0x94c>
 820a364:	0027883a 	mov	r19,zero
 820a368:	003f1b06 	br	8209fd8 <_dtoa_r+0x10d4>
 820a36c:	d8800817 	ldw	r2,32(sp)
 820a370:	11e9c83a 	sub	r20,r2,r7
 820a374:	0005883a 	mov	r2,zero
 820a378:	003d5406 	br	82098cc <_dtoa_r+0x9c8>
 820a37c:	00800044 	movi	r2,1
 820a380:	003dc706 	br	8209aa0 <_dtoa_r+0xb9c>
 820a384:	d8c00217 	ldw	r3,8(sp)
 820a388:	00800d84 	movi	r2,54
 820a38c:	dd400a17 	ldw	r21,40(sp)
 820a390:	10c5c83a 	sub	r2,r2,r3
 820a394:	dd000817 	ldw	r20,32(sp)
 820a398:	003d4c06 	br	82098cc <_dtoa_r+0x9c8>
 820a39c:	dc800f15 	stw	r18,60(sp)
 820a3a0:	dcc01015 	stw	r19,64(sp)
 820a3a4:	04000084 	movi	r16,2
 820a3a8:	003bed06 	br	8209360 <_dtoa_r+0x45c>
 820a3ac:	d9000617 	ldw	r4,24(sp)
 820a3b0:	203f0d26 	beq	r4,zero,8209fe8 <_dtoa_r+0x10e4>
 820a3b4:	d9800c17 	ldw	r6,48(sp)
 820a3b8:	01bcab0e 	bge	zero,r6,8209668 <_dtoa_r+0x764>
 820a3bc:	d9401017 	ldw	r5,64(sp)
 820a3c0:	d9000f17 	ldw	r4,60(sp)
 820a3c4:	000d883a 	mov	r6,zero
 820a3c8:	01d00934 	movhi	r7,16420
 820a3cc:	8212ea00 	call	8212ea0 <__muldf3>
 820a3d0:	81000044 	addi	r4,r16,1
 820a3d4:	d8800f15 	stw	r2,60(sp)
 820a3d8:	d8c01015 	stw	r3,64(sp)
 820a3dc:	8213f340 	call	8213f34 <__floatsidf>
 820a3e0:	d9800f17 	ldw	r6,60(sp)
 820a3e4:	d9c01017 	ldw	r7,64(sp)
 820a3e8:	1009883a 	mov	r4,r2
 820a3ec:	180b883a 	mov	r5,r3
 820a3f0:	8212ea00 	call	8212ea0 <__muldf3>
 820a3f4:	01d00734 	movhi	r7,16412
 820a3f8:	000d883a 	mov	r6,zero
 820a3fc:	1009883a 	mov	r4,r2
 820a400:	180b883a 	mov	r5,r3
 820a404:	8211ab40 	call	8211ab4 <__adddf3>
 820a408:	d9c00517 	ldw	r7,20(sp)
 820a40c:	047f3034 	movhi	r17,64704
 820a410:	1021883a 	mov	r16,r2
 820a414:	39ffffc4 	addi	r7,r7,-1
 820a418:	d9c01315 	stw	r7,76(sp)
 820a41c:	1c63883a 	add	r17,r3,r17
 820a420:	db000c17 	ldw	r12,48(sp)
 820a424:	003bea06 	br	82093d0 <_dtoa_r+0x4cc>
 820a428:	dc000915 	stw	r16,36(sp)
 820a42c:	003e0e06 	br	8209c68 <_dtoa_r+0xd64>
 820a430:	01000e44 	movi	r4,57
 820a434:	8825883a 	mov	r18,r17
 820a438:	9dc00044 	addi	r23,r19,1
 820a43c:	99000005 	stb	r4,0(r19)
 820a440:	a023883a 	mov	r17,r20
 820a444:	dc000915 	stw	r16,36(sp)
 820a448:	003da406 	br	8209adc <_dtoa_r+0xbd8>
 820a44c:	d9801417 	ldw	r6,80(sp)
 820a450:	d9c01517 	ldw	r7,84(sp)
 820a454:	0009883a 	mov	r4,zero
 820a458:	014ff834 	movhi	r5,16352
 820a45c:	82135b80 	call	82135b8 <__subdf3>
 820a460:	880d883a 	mov	r6,r17
 820a464:	a00f883a 	mov	r7,r20
 820a468:	1009883a 	mov	r4,r2
 820a46c:	180b883a 	mov	r5,r3
 820a470:	8212cd00 	call	8212cd0 <__gedf2>
 820a474:	00bc7c0e 	bge	zero,r2,8209668 <_dtoa_r+0x764>
 820a478:	01000c04 	movi	r4,48
 820a47c:	00000106 	br	820a484 <_dtoa_r+0x1580>
 820a480:	102f883a 	mov	r23,r2
 820a484:	b8bfffc4 	addi	r2,r23,-1
 820a488:	10c00007 	ldb	r3,0(r2)
 820a48c:	193ffc26 	beq	r3,r4,820a480 <_dtoa_r+0x157c>
 820a490:	d9801317 	ldw	r6,76(sp)
 820a494:	d9800515 	stw	r6,20(sp)
 820a498:	003c4406 	br	82095ac <_dtoa_r+0x6a8>
 820a49c:	d9801317 	ldw	r6,76(sp)
 820a4a0:	d9800515 	stw	r6,20(sp)
 820a4a4:	003cea06 	br	8209850 <_dtoa_r+0x94c>
 820a4a8:	dd800f17 	ldw	r22,60(sp)
 820a4ac:	dcc01017 	ldw	r19,64(sp)
 820a4b0:	dc801217 	ldw	r18,72(sp)
 820a4b4:	003c6c06 	br	8209668 <_dtoa_r+0x764>
 820a4b8:	903e031e 	bne	r18,zero,8209cc8 <_dtoa_r+0xdc4>
 820a4bc:	003ebb06 	br	8209fac <_dtoa_r+0x10a8>
 820a4c0:	103e6c1e 	bne	r2,zero,8209e74 <_dtoa_r+0xf70>
 820a4c4:	4080004c 	andi	r2,r8,1
 820a4c8:	103e6a26 	beq	r2,zero,8209e74 <_dtoa_r+0xf70>
 820a4cc:	003e6606 	br	8209e68 <_dtoa_r+0xf64>
 820a4d0:	d8c00317 	ldw	r3,12(sp)
 820a4d4:	00800084 	movi	r2,2
 820a4d8:	10c02916 	blt	r2,r3,820a580 <_dtoa_r+0x167c>
 820a4dc:	d9000c17 	ldw	r4,48(sp)
 820a4e0:	003e8806 	br	8209f04 <_dtoa_r+0x1000>
 820a4e4:	04000084 	movi	r16,2
 820a4e8:	003b9d06 	br	8209360 <_dtoa_r+0x45c>
 820a4ec:	d9001317 	ldw	r4,76(sp)
 820a4f0:	d9000515 	stw	r4,20(sp)
 820a4f4:	003cd606 	br	8209850 <_dtoa_r+0x94c>
 820a4f8:	d8801317 	ldw	r2,76(sp)
 820a4fc:	d8800515 	stw	r2,20(sp)
 820a500:	003c2a06 	br	82095ac <_dtoa_r+0x6a8>
 820a504:	d9800317 	ldw	r6,12(sp)
 820a508:	00800084 	movi	r2,2
 820a50c:	11801516 	blt	r2,r6,820a564 <_dtoa_r+0x1660>
 820a510:	d9c00c17 	ldw	r7,48(sp)
 820a514:	d9c00615 	stw	r7,24(sp)
 820a518:	003df706 	br	8209cf8 <_dtoa_r+0xdf4>
 820a51c:	193d3926 	beq	r3,r4,8209a04 <_dtoa_r+0xb00>
 820a520:	00c00f04 	movi	r3,60
 820a524:	1885c83a 	sub	r2,r3,r2
 820a528:	003ddf06 	br	8209ca8 <_dtoa_r+0xda4>
 820a52c:	e009883a 	mov	r4,fp
 820a530:	e0001115 	stw	zero,68(fp)
 820a534:	000b883a 	mov	r5,zero
 820a538:	820c3a40 	call	820c3a4 <_Balloc>
 820a53c:	d8800715 	stw	r2,28(sp)
 820a540:	d8c00717 	ldw	r3,28(sp)
 820a544:	00bfffc4 	movi	r2,-1
 820a548:	01000044 	movi	r4,1
 820a54c:	d8800c15 	stw	r2,48(sp)
 820a550:	e0c01015 	stw	r3,64(fp)
 820a554:	d9000b15 	stw	r4,44(sp)
 820a558:	d8800615 	stw	r2,24(sp)
 820a55c:	d8002215 	stw	zero,136(sp)
 820a560:	003c4106 	br	8209668 <_dtoa_r+0x764>
 820a564:	d8c00c17 	ldw	r3,48(sp)
 820a568:	d8c00615 	stw	r3,24(sp)
 820a56c:	003e7006 	br	8209f30 <_dtoa_r+0x102c>
 820a570:	04400044 	movi	r17,1
 820a574:	003b2006 	br	82091f8 <_dtoa_r+0x2f4>
 820a578:	000b883a 	mov	r5,zero
 820a57c:	003b3d06 	br	8209274 <_dtoa_r+0x370>
 820a580:	d8800c17 	ldw	r2,48(sp)
 820a584:	d8800615 	stw	r2,24(sp)
 820a588:	003e6906 	br	8209f30 <_dtoa_r+0x102c>

0820a58c <__sflush_r>:
 820a58c:	2880030b 	ldhu	r2,12(r5)
 820a590:	defffb04 	addi	sp,sp,-20
 820a594:	dcc00315 	stw	r19,12(sp)
 820a598:	dc400115 	stw	r17,4(sp)
 820a59c:	dfc00415 	stw	ra,16(sp)
 820a5a0:	dc800215 	stw	r18,8(sp)
 820a5a4:	dc000015 	stw	r16,0(sp)
 820a5a8:	10c0020c 	andi	r3,r2,8
 820a5ac:	2823883a 	mov	r17,r5
 820a5b0:	2027883a 	mov	r19,r4
 820a5b4:	1800311e 	bne	r3,zero,820a67c <__sflush_r+0xf0>
 820a5b8:	28c00117 	ldw	r3,4(r5)
 820a5bc:	10820014 	ori	r2,r2,2048
 820a5c0:	2880030d 	sth	r2,12(r5)
 820a5c4:	00c04b0e 	bge	zero,r3,820a6f4 <__sflush_r+0x168>
 820a5c8:	8a000a17 	ldw	r8,40(r17)
 820a5cc:	40002326 	beq	r8,zero,820a65c <__sflush_r+0xd0>
 820a5d0:	9c000017 	ldw	r16,0(r19)
 820a5d4:	10c4000c 	andi	r3,r2,4096
 820a5d8:	98000015 	stw	zero,0(r19)
 820a5dc:	18004826 	beq	r3,zero,820a700 <__sflush_r+0x174>
 820a5e0:	89801417 	ldw	r6,80(r17)
 820a5e4:	10c0010c 	andi	r3,r2,4
 820a5e8:	18000626 	beq	r3,zero,820a604 <__sflush_r+0x78>
 820a5ec:	88c00117 	ldw	r3,4(r17)
 820a5f0:	88800c17 	ldw	r2,48(r17)
 820a5f4:	30cdc83a 	sub	r6,r6,r3
 820a5f8:	10000226 	beq	r2,zero,820a604 <__sflush_r+0x78>
 820a5fc:	88800f17 	ldw	r2,60(r17)
 820a600:	308dc83a 	sub	r6,r6,r2
 820a604:	89400717 	ldw	r5,28(r17)
 820a608:	000f883a 	mov	r7,zero
 820a60c:	9809883a 	mov	r4,r19
 820a610:	403ee83a 	callr	r8
 820a614:	00ffffc4 	movi	r3,-1
 820a618:	10c04426 	beq	r2,r3,820a72c <__sflush_r+0x1a0>
 820a61c:	88c0030b 	ldhu	r3,12(r17)
 820a620:	89000417 	ldw	r4,16(r17)
 820a624:	88000115 	stw	zero,4(r17)
 820a628:	197dffcc 	andi	r5,r3,63487
 820a62c:	8940030d 	sth	r5,12(r17)
 820a630:	89000015 	stw	r4,0(r17)
 820a634:	18c4000c 	andi	r3,r3,4096
 820a638:	18002c1e 	bne	r3,zero,820a6ec <__sflush_r+0x160>
 820a63c:	89400c17 	ldw	r5,48(r17)
 820a640:	9c000015 	stw	r16,0(r19)
 820a644:	28000526 	beq	r5,zero,820a65c <__sflush_r+0xd0>
 820a648:	88801004 	addi	r2,r17,64
 820a64c:	28800226 	beq	r5,r2,820a658 <__sflush_r+0xcc>
 820a650:	9809883a 	mov	r4,r19
 820a654:	820ae4c0 	call	820ae4c <_free_r>
 820a658:	88000c15 	stw	zero,48(r17)
 820a65c:	0005883a 	mov	r2,zero
 820a660:	dfc00417 	ldw	ra,16(sp)
 820a664:	dcc00317 	ldw	r19,12(sp)
 820a668:	dc800217 	ldw	r18,8(sp)
 820a66c:	dc400117 	ldw	r17,4(sp)
 820a670:	dc000017 	ldw	r16,0(sp)
 820a674:	dec00504 	addi	sp,sp,20
 820a678:	f800283a 	ret
 820a67c:	2c800417 	ldw	r18,16(r5)
 820a680:	903ff626 	beq	r18,zero,820a65c <__sflush_r+0xd0>
 820a684:	2c000017 	ldw	r16,0(r5)
 820a688:	108000cc 	andi	r2,r2,3
 820a68c:	2c800015 	stw	r18,0(r5)
 820a690:	84a1c83a 	sub	r16,r16,r18
 820a694:	1000131e 	bne	r2,zero,820a6e4 <__sflush_r+0x158>
 820a698:	28800517 	ldw	r2,20(r5)
 820a69c:	88800215 	stw	r2,8(r17)
 820a6a0:	04000316 	blt	zero,r16,820a6b0 <__sflush_r+0x124>
 820a6a4:	003fed06 	br	820a65c <__sflush_r+0xd0>
 820a6a8:	90a5883a 	add	r18,r18,r2
 820a6ac:	043feb0e 	bge	zero,r16,820a65c <__sflush_r+0xd0>
 820a6b0:	88800917 	ldw	r2,36(r17)
 820a6b4:	89400717 	ldw	r5,28(r17)
 820a6b8:	800f883a 	mov	r7,r16
 820a6bc:	900d883a 	mov	r6,r18
 820a6c0:	9809883a 	mov	r4,r19
 820a6c4:	103ee83a 	callr	r2
 820a6c8:	80a1c83a 	sub	r16,r16,r2
 820a6cc:	00bff616 	blt	zero,r2,820a6a8 <__sflush_r+0x11c>
 820a6d0:	88c0030b 	ldhu	r3,12(r17)
 820a6d4:	00bfffc4 	movi	r2,-1
 820a6d8:	18c01014 	ori	r3,r3,64
 820a6dc:	88c0030d 	sth	r3,12(r17)
 820a6e0:	003fdf06 	br	820a660 <__sflush_r+0xd4>
 820a6e4:	0005883a 	mov	r2,zero
 820a6e8:	003fec06 	br	820a69c <__sflush_r+0x110>
 820a6ec:	88801415 	stw	r2,80(r17)
 820a6f0:	003fd206 	br	820a63c <__sflush_r+0xb0>
 820a6f4:	28c00f17 	ldw	r3,60(r5)
 820a6f8:	00ffb316 	blt	zero,r3,820a5c8 <__sflush_r+0x3c>
 820a6fc:	003fd706 	br	820a65c <__sflush_r+0xd0>
 820a700:	89400717 	ldw	r5,28(r17)
 820a704:	000d883a 	mov	r6,zero
 820a708:	01c00044 	movi	r7,1
 820a70c:	9809883a 	mov	r4,r19
 820a710:	403ee83a 	callr	r8
 820a714:	100d883a 	mov	r6,r2
 820a718:	00bfffc4 	movi	r2,-1
 820a71c:	30801426 	beq	r6,r2,820a770 <__sflush_r+0x1e4>
 820a720:	8880030b 	ldhu	r2,12(r17)
 820a724:	8a000a17 	ldw	r8,40(r17)
 820a728:	003fae06 	br	820a5e4 <__sflush_r+0x58>
 820a72c:	98c00017 	ldw	r3,0(r19)
 820a730:	183fba26 	beq	r3,zero,820a61c <__sflush_r+0x90>
 820a734:	01000744 	movi	r4,29
 820a738:	19000626 	beq	r3,r4,820a754 <__sflush_r+0x1c8>
 820a73c:	01000584 	movi	r4,22
 820a740:	19000426 	beq	r3,r4,820a754 <__sflush_r+0x1c8>
 820a744:	88c0030b 	ldhu	r3,12(r17)
 820a748:	18c01014 	ori	r3,r3,64
 820a74c:	88c0030d 	sth	r3,12(r17)
 820a750:	003fc306 	br	820a660 <__sflush_r+0xd4>
 820a754:	8880030b 	ldhu	r2,12(r17)
 820a758:	88c00417 	ldw	r3,16(r17)
 820a75c:	88000115 	stw	zero,4(r17)
 820a760:	10bdffcc 	andi	r2,r2,63487
 820a764:	8880030d 	sth	r2,12(r17)
 820a768:	88c00015 	stw	r3,0(r17)
 820a76c:	003fb306 	br	820a63c <__sflush_r+0xb0>
 820a770:	98800017 	ldw	r2,0(r19)
 820a774:	103fea26 	beq	r2,zero,820a720 <__sflush_r+0x194>
 820a778:	00c00744 	movi	r3,29
 820a77c:	10c00226 	beq	r2,r3,820a788 <__sflush_r+0x1fc>
 820a780:	00c00584 	movi	r3,22
 820a784:	10c0031e 	bne	r2,r3,820a794 <__sflush_r+0x208>
 820a788:	9c000015 	stw	r16,0(r19)
 820a78c:	0005883a 	mov	r2,zero
 820a790:	003fb306 	br	820a660 <__sflush_r+0xd4>
 820a794:	88c0030b 	ldhu	r3,12(r17)
 820a798:	3005883a 	mov	r2,r6
 820a79c:	18c01014 	ori	r3,r3,64
 820a7a0:	88c0030d 	sth	r3,12(r17)
 820a7a4:	003fae06 	br	820a660 <__sflush_r+0xd4>

0820a7a8 <_fflush_r>:
 820a7a8:	defffd04 	addi	sp,sp,-12
 820a7ac:	dc000115 	stw	r16,4(sp)
 820a7b0:	dfc00215 	stw	ra,8(sp)
 820a7b4:	2021883a 	mov	r16,r4
 820a7b8:	20000226 	beq	r4,zero,820a7c4 <_fflush_r+0x1c>
 820a7bc:	20800e17 	ldw	r2,56(r4)
 820a7c0:	10000c26 	beq	r2,zero,820a7f4 <_fflush_r+0x4c>
 820a7c4:	2880030f 	ldh	r2,12(r5)
 820a7c8:	1000051e 	bne	r2,zero,820a7e0 <_fflush_r+0x38>
 820a7cc:	0005883a 	mov	r2,zero
 820a7d0:	dfc00217 	ldw	ra,8(sp)
 820a7d4:	dc000117 	ldw	r16,4(sp)
 820a7d8:	dec00304 	addi	sp,sp,12
 820a7dc:	f800283a 	ret
 820a7e0:	8009883a 	mov	r4,r16
 820a7e4:	dfc00217 	ldw	ra,8(sp)
 820a7e8:	dc000117 	ldw	r16,4(sp)
 820a7ec:	dec00304 	addi	sp,sp,12
 820a7f0:	820a58c1 	jmpi	820a58c <__sflush_r>
 820a7f4:	d9400015 	stw	r5,0(sp)
 820a7f8:	820ab840 	call	820ab84 <__sinit>
 820a7fc:	d9400017 	ldw	r5,0(sp)
 820a800:	003ff006 	br	820a7c4 <_fflush_r+0x1c>

0820a804 <fflush>:
 820a804:	20000526 	beq	r4,zero,820a81c <fflush+0x18>
 820a808:	00820974 	movhi	r2,2085
 820a80c:	108eb804 	addi	r2,r2,15072
 820a810:	200b883a 	mov	r5,r4
 820a814:	11000017 	ldw	r4,0(r2)
 820a818:	820a7a81 	jmpi	820a7a8 <_fflush_r>
 820a81c:	00820974 	movhi	r2,2085
 820a820:	108eb704 	addi	r2,r2,15068
 820a824:	11000017 	ldw	r4,0(r2)
 820a828:	01420874 	movhi	r5,2081
 820a82c:	2969ea04 	addi	r5,r5,-22616
 820a830:	820b6dc1 	jmpi	820b6dc <_fwalk_reent>

0820a834 <__fp_unlock>:
 820a834:	0005883a 	mov	r2,zero
 820a838:	f800283a 	ret

0820a83c <_cleanup_r>:
 820a83c:	01420874 	movhi	r5,2081
 820a840:	29426804 	addi	r5,r5,2464
 820a844:	820b6dc1 	jmpi	820b6dc <_fwalk_reent>

0820a848 <__sinit.part.1>:
 820a848:	defff704 	addi	sp,sp,-36
 820a84c:	00c20874 	movhi	r3,2081
 820a850:	dfc00815 	stw	ra,32(sp)
 820a854:	ddc00715 	stw	r23,28(sp)
 820a858:	dd800615 	stw	r22,24(sp)
 820a85c:	dd400515 	stw	r21,20(sp)
 820a860:	dd000415 	stw	r20,16(sp)
 820a864:	dcc00315 	stw	r19,12(sp)
 820a868:	dc800215 	stw	r18,8(sp)
 820a86c:	dc400115 	stw	r17,4(sp)
 820a870:	dc000015 	stw	r16,0(sp)
 820a874:	18ea0f04 	addi	r3,r3,-22468
 820a878:	24000117 	ldw	r16,4(r4)
 820a87c:	20c00f15 	stw	r3,60(r4)
 820a880:	2080bb04 	addi	r2,r4,748
 820a884:	00c000c4 	movi	r3,3
 820a888:	20c0b915 	stw	r3,740(r4)
 820a88c:	2080ba15 	stw	r2,744(r4)
 820a890:	2000b815 	stw	zero,736(r4)
 820a894:	05c00204 	movi	r23,8
 820a898:	00800104 	movi	r2,4
 820a89c:	2025883a 	mov	r18,r4
 820a8a0:	b80d883a 	mov	r6,r23
 820a8a4:	81001704 	addi	r4,r16,92
 820a8a8:	000b883a 	mov	r5,zero
 820a8ac:	80000015 	stw	zero,0(r16)
 820a8b0:	80000115 	stw	zero,4(r16)
 820a8b4:	80000215 	stw	zero,8(r16)
 820a8b8:	8080030d 	sth	r2,12(r16)
 820a8bc:	80001915 	stw	zero,100(r16)
 820a8c0:	8000038d 	sth	zero,14(r16)
 820a8c4:	80000415 	stw	zero,16(r16)
 820a8c8:	80000515 	stw	zero,20(r16)
 820a8cc:	80000615 	stw	zero,24(r16)
 820a8d0:	8202f000 	call	8202f00 <memset>
 820a8d4:	05820874 	movhi	r22,2081
 820a8d8:	94400217 	ldw	r17,8(r18)
 820a8dc:	05420874 	movhi	r21,2081
 820a8e0:	05020874 	movhi	r20,2081
 820a8e4:	04c20874 	movhi	r19,2081
 820a8e8:	b5b6ef04 	addi	r22,r22,-9284
 820a8ec:	ad770604 	addi	r21,r21,-9192
 820a8f0:	a5372504 	addi	r20,r20,-9068
 820a8f4:	9cf73c04 	addi	r19,r19,-8976
 820a8f8:	85800815 	stw	r22,32(r16)
 820a8fc:	85400915 	stw	r21,36(r16)
 820a900:	85000a15 	stw	r20,40(r16)
 820a904:	84c00b15 	stw	r19,44(r16)
 820a908:	84000715 	stw	r16,28(r16)
 820a90c:	00800284 	movi	r2,10
 820a910:	8880030d 	sth	r2,12(r17)
 820a914:	00800044 	movi	r2,1
 820a918:	b80d883a 	mov	r6,r23
 820a91c:	89001704 	addi	r4,r17,92
 820a920:	000b883a 	mov	r5,zero
 820a924:	88000015 	stw	zero,0(r17)
 820a928:	88000115 	stw	zero,4(r17)
 820a92c:	88000215 	stw	zero,8(r17)
 820a930:	88001915 	stw	zero,100(r17)
 820a934:	8880038d 	sth	r2,14(r17)
 820a938:	88000415 	stw	zero,16(r17)
 820a93c:	88000515 	stw	zero,20(r17)
 820a940:	88000615 	stw	zero,24(r17)
 820a944:	8202f000 	call	8202f00 <memset>
 820a948:	94000317 	ldw	r16,12(r18)
 820a94c:	00800484 	movi	r2,18
 820a950:	8c400715 	stw	r17,28(r17)
 820a954:	8d800815 	stw	r22,32(r17)
 820a958:	8d400915 	stw	r21,36(r17)
 820a95c:	8d000a15 	stw	r20,40(r17)
 820a960:	8cc00b15 	stw	r19,44(r17)
 820a964:	8080030d 	sth	r2,12(r16)
 820a968:	00800084 	movi	r2,2
 820a96c:	80000015 	stw	zero,0(r16)
 820a970:	80000115 	stw	zero,4(r16)
 820a974:	80000215 	stw	zero,8(r16)
 820a978:	80001915 	stw	zero,100(r16)
 820a97c:	8080038d 	sth	r2,14(r16)
 820a980:	80000415 	stw	zero,16(r16)
 820a984:	80000515 	stw	zero,20(r16)
 820a988:	80000615 	stw	zero,24(r16)
 820a98c:	b80d883a 	mov	r6,r23
 820a990:	000b883a 	mov	r5,zero
 820a994:	81001704 	addi	r4,r16,92
 820a998:	8202f000 	call	8202f00 <memset>
 820a99c:	00800044 	movi	r2,1
 820a9a0:	84000715 	stw	r16,28(r16)
 820a9a4:	85800815 	stw	r22,32(r16)
 820a9a8:	85400915 	stw	r21,36(r16)
 820a9ac:	85000a15 	stw	r20,40(r16)
 820a9b0:	84c00b15 	stw	r19,44(r16)
 820a9b4:	90800e15 	stw	r2,56(r18)
 820a9b8:	dfc00817 	ldw	ra,32(sp)
 820a9bc:	ddc00717 	ldw	r23,28(sp)
 820a9c0:	dd800617 	ldw	r22,24(sp)
 820a9c4:	dd400517 	ldw	r21,20(sp)
 820a9c8:	dd000417 	ldw	r20,16(sp)
 820a9cc:	dcc00317 	ldw	r19,12(sp)
 820a9d0:	dc800217 	ldw	r18,8(sp)
 820a9d4:	dc400117 	ldw	r17,4(sp)
 820a9d8:	dc000017 	ldw	r16,0(sp)
 820a9dc:	dec00904 	addi	sp,sp,36
 820a9e0:	f800283a 	ret

0820a9e4 <__fp_lock>:
 820a9e4:	0005883a 	mov	r2,zero
 820a9e8:	f800283a 	ret

0820a9ec <__sfmoreglue>:
 820a9ec:	defffc04 	addi	sp,sp,-16
 820a9f0:	dc400115 	stw	r17,4(sp)
 820a9f4:	2c7fffc4 	addi	r17,r5,-1
 820a9f8:	8c401a24 	muli	r17,r17,104
 820a9fc:	dc800215 	stw	r18,8(sp)
 820aa00:	2825883a 	mov	r18,r5
 820aa04:	89401d04 	addi	r5,r17,116
 820aa08:	dc000015 	stw	r16,0(sp)
 820aa0c:	dfc00315 	stw	ra,12(sp)
 820aa10:	820ba380 	call	820ba38 <_malloc_r>
 820aa14:	1021883a 	mov	r16,r2
 820aa18:	10000726 	beq	r2,zero,820aa38 <__sfmoreglue+0x4c>
 820aa1c:	11000304 	addi	r4,r2,12
 820aa20:	10000015 	stw	zero,0(r2)
 820aa24:	14800115 	stw	r18,4(r2)
 820aa28:	11000215 	stw	r4,8(r2)
 820aa2c:	89801a04 	addi	r6,r17,104
 820aa30:	000b883a 	mov	r5,zero
 820aa34:	8202f000 	call	8202f00 <memset>
 820aa38:	8005883a 	mov	r2,r16
 820aa3c:	dfc00317 	ldw	ra,12(sp)
 820aa40:	dc800217 	ldw	r18,8(sp)
 820aa44:	dc400117 	ldw	r17,4(sp)
 820aa48:	dc000017 	ldw	r16,0(sp)
 820aa4c:	dec00404 	addi	sp,sp,16
 820aa50:	f800283a 	ret

0820aa54 <__sfp>:
 820aa54:	defffb04 	addi	sp,sp,-20
 820aa58:	dc000015 	stw	r16,0(sp)
 820aa5c:	04020974 	movhi	r16,2085
 820aa60:	840eb704 	addi	r16,r16,15068
 820aa64:	dcc00315 	stw	r19,12(sp)
 820aa68:	2027883a 	mov	r19,r4
 820aa6c:	81000017 	ldw	r4,0(r16)
 820aa70:	dfc00415 	stw	ra,16(sp)
 820aa74:	dc800215 	stw	r18,8(sp)
 820aa78:	20800e17 	ldw	r2,56(r4)
 820aa7c:	dc400115 	stw	r17,4(sp)
 820aa80:	1000021e 	bne	r2,zero,820aa8c <__sfp+0x38>
 820aa84:	820a8480 	call	820a848 <__sinit.part.1>
 820aa88:	81000017 	ldw	r4,0(r16)
 820aa8c:	2480b804 	addi	r18,r4,736
 820aa90:	047fffc4 	movi	r17,-1
 820aa94:	91000117 	ldw	r4,4(r18)
 820aa98:	94000217 	ldw	r16,8(r18)
 820aa9c:	213fffc4 	addi	r4,r4,-1
 820aaa0:	20000a16 	blt	r4,zero,820aacc <__sfp+0x78>
 820aaa4:	8080030f 	ldh	r2,12(r16)
 820aaa8:	10000c26 	beq	r2,zero,820aadc <__sfp+0x88>
 820aaac:	80c01d04 	addi	r3,r16,116
 820aab0:	00000206 	br	820aabc <__sfp+0x68>
 820aab4:	18bfe60f 	ldh	r2,-104(r3)
 820aab8:	10000826 	beq	r2,zero,820aadc <__sfp+0x88>
 820aabc:	213fffc4 	addi	r4,r4,-1
 820aac0:	1c3ffd04 	addi	r16,r3,-12
 820aac4:	18c01a04 	addi	r3,r3,104
 820aac8:	247ffa1e 	bne	r4,r17,820aab4 <__sfp+0x60>
 820aacc:	90800017 	ldw	r2,0(r18)
 820aad0:	10001d26 	beq	r2,zero,820ab48 <__sfp+0xf4>
 820aad4:	1025883a 	mov	r18,r2
 820aad8:	003fee06 	br	820aa94 <__sfp+0x40>
 820aadc:	00bfffc4 	movi	r2,-1
 820aae0:	8080038d 	sth	r2,14(r16)
 820aae4:	00800044 	movi	r2,1
 820aae8:	8080030d 	sth	r2,12(r16)
 820aaec:	80001915 	stw	zero,100(r16)
 820aaf0:	80000015 	stw	zero,0(r16)
 820aaf4:	80000215 	stw	zero,8(r16)
 820aaf8:	80000115 	stw	zero,4(r16)
 820aafc:	80000415 	stw	zero,16(r16)
 820ab00:	80000515 	stw	zero,20(r16)
 820ab04:	80000615 	stw	zero,24(r16)
 820ab08:	01800204 	movi	r6,8
 820ab0c:	000b883a 	mov	r5,zero
 820ab10:	81001704 	addi	r4,r16,92
 820ab14:	8202f000 	call	8202f00 <memset>
 820ab18:	8005883a 	mov	r2,r16
 820ab1c:	80000c15 	stw	zero,48(r16)
 820ab20:	80000d15 	stw	zero,52(r16)
 820ab24:	80001115 	stw	zero,68(r16)
 820ab28:	80001215 	stw	zero,72(r16)
 820ab2c:	dfc00417 	ldw	ra,16(sp)
 820ab30:	dcc00317 	ldw	r19,12(sp)
 820ab34:	dc800217 	ldw	r18,8(sp)
 820ab38:	dc400117 	ldw	r17,4(sp)
 820ab3c:	dc000017 	ldw	r16,0(sp)
 820ab40:	dec00504 	addi	sp,sp,20
 820ab44:	f800283a 	ret
 820ab48:	01400104 	movi	r5,4
 820ab4c:	9809883a 	mov	r4,r19
 820ab50:	820a9ec0 	call	820a9ec <__sfmoreglue>
 820ab54:	90800015 	stw	r2,0(r18)
 820ab58:	103fde1e 	bne	r2,zero,820aad4 <__sfp+0x80>
 820ab5c:	00800304 	movi	r2,12
 820ab60:	98800015 	stw	r2,0(r19)
 820ab64:	0005883a 	mov	r2,zero
 820ab68:	003ff006 	br	820ab2c <__sfp+0xd8>

0820ab6c <_cleanup>:
 820ab6c:	00820974 	movhi	r2,2085
 820ab70:	108eb704 	addi	r2,r2,15068
 820ab74:	11000017 	ldw	r4,0(r2)
 820ab78:	01420874 	movhi	r5,2081
 820ab7c:	29426804 	addi	r5,r5,2464
 820ab80:	820b6dc1 	jmpi	820b6dc <_fwalk_reent>

0820ab84 <__sinit>:
 820ab84:	20800e17 	ldw	r2,56(r4)
 820ab88:	10000126 	beq	r2,zero,820ab90 <__sinit+0xc>
 820ab8c:	f800283a 	ret
 820ab90:	820a8481 	jmpi	820a848 <__sinit.part.1>

0820ab94 <__sfp_lock_acquire>:
 820ab94:	f800283a 	ret

0820ab98 <__sfp_lock_release>:
 820ab98:	f800283a 	ret

0820ab9c <__sinit_lock_acquire>:
 820ab9c:	f800283a 	ret

0820aba0 <__sinit_lock_release>:
 820aba0:	f800283a 	ret

0820aba4 <__fp_lock_all>:
 820aba4:	00820974 	movhi	r2,2085
 820aba8:	108eb804 	addi	r2,r2,15072
 820abac:	11000017 	ldw	r4,0(r2)
 820abb0:	01420874 	movhi	r5,2081
 820abb4:	296a7904 	addi	r5,r5,-22044
 820abb8:	820b6181 	jmpi	820b618 <_fwalk>

0820abbc <__fp_unlock_all>:
 820abbc:	00820974 	movhi	r2,2085
 820abc0:	108eb804 	addi	r2,r2,15072
 820abc4:	11000017 	ldw	r4,0(r2)
 820abc8:	01420874 	movhi	r5,2081
 820abcc:	296a0d04 	addi	r5,r5,-22476
 820abd0:	820b6181 	jmpi	820b618 <_fwalk>

0820abd4 <_fputc_r>:
 820abd4:	defffc04 	addi	sp,sp,-16
 820abd8:	dc000215 	stw	r16,8(sp)
 820abdc:	dfc00315 	stw	ra,12(sp)
 820abe0:	2021883a 	mov	r16,r4
 820abe4:	20000726 	beq	r4,zero,820ac04 <_fputc_r+0x30>
 820abe8:	20800e17 	ldw	r2,56(r4)
 820abec:	1000051e 	bne	r2,zero,820ac04 <_fputc_r+0x30>
 820abf0:	d9400015 	stw	r5,0(sp)
 820abf4:	d9800115 	stw	r6,4(sp)
 820abf8:	820ab840 	call	820ab84 <__sinit>
 820abfc:	d9800117 	ldw	r6,4(sp)
 820ac00:	d9400017 	ldw	r5,0(sp)
 820ac04:	8009883a 	mov	r4,r16
 820ac08:	dfc00317 	ldw	ra,12(sp)
 820ac0c:	dc000217 	ldw	r16,8(sp)
 820ac10:	dec00404 	addi	sp,sp,16
 820ac14:	82031281 	jmpi	8203128 <_putc_r>

0820ac18 <fputc>:
 820ac18:	00820974 	movhi	r2,2085
 820ac1c:	defffc04 	addi	sp,sp,-16
 820ac20:	108eb804 	addi	r2,r2,15072
 820ac24:	dc000115 	stw	r16,4(sp)
 820ac28:	14000017 	ldw	r16,0(r2)
 820ac2c:	dc400215 	stw	r17,8(sp)
 820ac30:	dfc00315 	stw	ra,12(sp)
 820ac34:	2023883a 	mov	r17,r4
 820ac38:	80000626 	beq	r16,zero,820ac54 <fputc+0x3c>
 820ac3c:	80800e17 	ldw	r2,56(r16)
 820ac40:	1000041e 	bne	r2,zero,820ac54 <fputc+0x3c>
 820ac44:	8009883a 	mov	r4,r16
 820ac48:	d9400015 	stw	r5,0(sp)
 820ac4c:	820ab840 	call	820ab84 <__sinit>
 820ac50:	d9400017 	ldw	r5,0(sp)
 820ac54:	280d883a 	mov	r6,r5
 820ac58:	8009883a 	mov	r4,r16
 820ac5c:	880b883a 	mov	r5,r17
 820ac60:	dfc00317 	ldw	ra,12(sp)
 820ac64:	dc400217 	ldw	r17,8(sp)
 820ac68:	dc000117 	ldw	r16,4(sp)
 820ac6c:	dec00404 	addi	sp,sp,16
 820ac70:	82031281 	jmpi	8203128 <_putc_r>

0820ac74 <_fputs_r>:
 820ac74:	defff804 	addi	sp,sp,-32
 820ac78:	dc400615 	stw	r17,24(sp)
 820ac7c:	2023883a 	mov	r17,r4
 820ac80:	2809883a 	mov	r4,r5
 820ac84:	dc000515 	stw	r16,20(sp)
 820ac88:	dfc00715 	stw	ra,28(sp)
 820ac8c:	3021883a 	mov	r16,r6
 820ac90:	d9400315 	stw	r5,12(sp)
 820ac94:	8203cac0 	call	8203cac <strlen>
 820ac98:	d8800215 	stw	r2,8(sp)
 820ac9c:	d8800415 	stw	r2,16(sp)
 820aca0:	d8800304 	addi	r2,sp,12
 820aca4:	d8800015 	stw	r2,0(sp)
 820aca8:	00800044 	movi	r2,1
 820acac:	d8800115 	stw	r2,4(sp)
 820acb0:	88000226 	beq	r17,zero,820acbc <_fputs_r+0x48>
 820acb4:	88800e17 	ldw	r2,56(r17)
 820acb8:	10001226 	beq	r2,zero,820ad04 <_fputs_r+0x90>
 820acbc:	8080030b 	ldhu	r2,12(r16)
 820acc0:	10c8000c 	andi	r3,r2,8192
 820acc4:	1800061e 	bne	r3,zero,820ace0 <_fputs_r+0x6c>
 820acc8:	81001917 	ldw	r4,100(r16)
 820accc:	00f7ffc4 	movi	r3,-8193
 820acd0:	10880014 	ori	r2,r2,8192
 820acd4:	20c6703a 	and	r3,r4,r3
 820acd8:	8080030d 	sth	r2,12(r16)
 820acdc:	80c01915 	stw	r3,100(r16)
 820ace0:	d80d883a 	mov	r6,sp
 820ace4:	800b883a 	mov	r5,r16
 820ace8:	8809883a 	mov	r4,r17
 820acec:	820b15c0 	call	820b15c <__sfvwrite_r>
 820acf0:	dfc00717 	ldw	ra,28(sp)
 820acf4:	dc400617 	ldw	r17,24(sp)
 820acf8:	dc000517 	ldw	r16,20(sp)
 820acfc:	dec00804 	addi	sp,sp,32
 820ad00:	f800283a 	ret
 820ad04:	8809883a 	mov	r4,r17
 820ad08:	820ab840 	call	820ab84 <__sinit>
 820ad0c:	003feb06 	br	820acbc <_fputs_r+0x48>

0820ad10 <fputs>:
 820ad10:	00820974 	movhi	r2,2085
 820ad14:	108eb804 	addi	r2,r2,15072
 820ad18:	280d883a 	mov	r6,r5
 820ad1c:	200b883a 	mov	r5,r4
 820ad20:	11000017 	ldw	r4,0(r2)
 820ad24:	820ac741 	jmpi	820ac74 <_fputs_r>

0820ad28 <_malloc_trim_r>:
 820ad28:	defffb04 	addi	sp,sp,-20
 820ad2c:	dcc00315 	stw	r19,12(sp)
 820ad30:	04c20974 	movhi	r19,2085
 820ad34:	dc800215 	stw	r18,8(sp)
 820ad38:	dc400115 	stw	r17,4(sp)
 820ad3c:	dc000015 	stw	r16,0(sp)
 820ad40:	dfc00415 	stw	ra,16(sp)
 820ad44:	2821883a 	mov	r16,r5
 820ad48:	9cc84604 	addi	r19,r19,8472
 820ad4c:	2025883a 	mov	r18,r4
 820ad50:	82147440 	call	8214744 <__malloc_lock>
 820ad54:	98800217 	ldw	r2,8(r19)
 820ad58:	14400117 	ldw	r17,4(r2)
 820ad5c:	00bfff04 	movi	r2,-4
 820ad60:	88a2703a 	and	r17,r17,r2
 820ad64:	8c21c83a 	sub	r16,r17,r16
 820ad68:	8403fbc4 	addi	r16,r16,4079
 820ad6c:	8020d33a 	srli	r16,r16,12
 820ad70:	0083ffc4 	movi	r2,4095
 820ad74:	843fffc4 	addi	r16,r16,-1
 820ad78:	8020933a 	slli	r16,r16,12
 820ad7c:	1400060e 	bge	r2,r16,820ad98 <_malloc_trim_r+0x70>
 820ad80:	000b883a 	mov	r5,zero
 820ad84:	9009883a 	mov	r4,r18
 820ad88:	820db680 	call	820db68 <_sbrk_r>
 820ad8c:	98c00217 	ldw	r3,8(r19)
 820ad90:	1c47883a 	add	r3,r3,r17
 820ad94:	10c00a26 	beq	r2,r3,820adc0 <_malloc_trim_r+0x98>
 820ad98:	9009883a 	mov	r4,r18
 820ad9c:	82148640 	call	8214864 <__malloc_unlock>
 820ada0:	0005883a 	mov	r2,zero
 820ada4:	dfc00417 	ldw	ra,16(sp)
 820ada8:	dcc00317 	ldw	r19,12(sp)
 820adac:	dc800217 	ldw	r18,8(sp)
 820adb0:	dc400117 	ldw	r17,4(sp)
 820adb4:	dc000017 	ldw	r16,0(sp)
 820adb8:	dec00504 	addi	sp,sp,20
 820adbc:	f800283a 	ret
 820adc0:	040bc83a 	sub	r5,zero,r16
 820adc4:	9009883a 	mov	r4,r18
 820adc8:	820db680 	call	820db68 <_sbrk_r>
 820adcc:	00ffffc4 	movi	r3,-1
 820add0:	10c00d26 	beq	r2,r3,820ae08 <_malloc_trim_r+0xe0>
 820add4:	00c20974 	movhi	r3,2085
 820add8:	18d10f04 	addi	r3,r3,17468
 820addc:	18800017 	ldw	r2,0(r3)
 820ade0:	99000217 	ldw	r4,8(r19)
 820ade4:	8c23c83a 	sub	r17,r17,r16
 820ade8:	8c400054 	ori	r17,r17,1
 820adec:	1421c83a 	sub	r16,r2,r16
 820adf0:	24400115 	stw	r17,4(r4)
 820adf4:	9009883a 	mov	r4,r18
 820adf8:	1c000015 	stw	r16,0(r3)
 820adfc:	82148640 	call	8214864 <__malloc_unlock>
 820ae00:	00800044 	movi	r2,1
 820ae04:	003fe706 	br	820ada4 <_malloc_trim_r+0x7c>
 820ae08:	000b883a 	mov	r5,zero
 820ae0c:	9009883a 	mov	r4,r18
 820ae10:	820db680 	call	820db68 <_sbrk_r>
 820ae14:	99000217 	ldw	r4,8(r19)
 820ae18:	014003c4 	movi	r5,15
 820ae1c:	1107c83a 	sub	r3,r2,r4
 820ae20:	28ffdd0e 	bge	r5,r3,820ad98 <_malloc_trim_r+0x70>
 820ae24:	01420974 	movhi	r5,2085
 820ae28:	294eba04 	addi	r5,r5,15080
 820ae2c:	29400017 	ldw	r5,0(r5)
 820ae30:	18c00054 	ori	r3,r3,1
 820ae34:	20c00115 	stw	r3,4(r4)
 820ae38:	00c20974 	movhi	r3,2085
 820ae3c:	1145c83a 	sub	r2,r2,r5
 820ae40:	18d10f04 	addi	r3,r3,17468
 820ae44:	18800015 	stw	r2,0(r3)
 820ae48:	003fd306 	br	820ad98 <_malloc_trim_r+0x70>

0820ae4c <_free_r>:
 820ae4c:	28004126 	beq	r5,zero,820af54 <_free_r+0x108>
 820ae50:	defffd04 	addi	sp,sp,-12
 820ae54:	dc400115 	stw	r17,4(sp)
 820ae58:	dc000015 	stw	r16,0(sp)
 820ae5c:	2023883a 	mov	r17,r4
 820ae60:	2821883a 	mov	r16,r5
 820ae64:	dfc00215 	stw	ra,8(sp)
 820ae68:	82147440 	call	8214744 <__malloc_lock>
 820ae6c:	81ffff17 	ldw	r7,-4(r16)
 820ae70:	00bfff84 	movi	r2,-2
 820ae74:	01020974 	movhi	r4,2085
 820ae78:	81bffe04 	addi	r6,r16,-8
 820ae7c:	3884703a 	and	r2,r7,r2
 820ae80:	21084604 	addi	r4,r4,8472
 820ae84:	308b883a 	add	r5,r6,r2
 820ae88:	2a400117 	ldw	r9,4(r5)
 820ae8c:	22000217 	ldw	r8,8(r4)
 820ae90:	00ffff04 	movi	r3,-4
 820ae94:	48c6703a 	and	r3,r9,r3
 820ae98:	2a005726 	beq	r5,r8,820aff8 <_free_r+0x1ac>
 820ae9c:	28c00115 	stw	r3,4(r5)
 820aea0:	39c0004c 	andi	r7,r7,1
 820aea4:	3800091e 	bne	r7,zero,820aecc <_free_r+0x80>
 820aea8:	823ffe17 	ldw	r8,-8(r16)
 820aeac:	22400204 	addi	r9,r4,8
 820aeb0:	320dc83a 	sub	r6,r6,r8
 820aeb4:	31c00217 	ldw	r7,8(r6)
 820aeb8:	1205883a 	add	r2,r2,r8
 820aebc:	3a406526 	beq	r7,r9,820b054 <_free_r+0x208>
 820aec0:	32000317 	ldw	r8,12(r6)
 820aec4:	3a000315 	stw	r8,12(r7)
 820aec8:	41c00215 	stw	r7,8(r8)
 820aecc:	28cf883a 	add	r7,r5,r3
 820aed0:	39c00117 	ldw	r7,4(r7)
 820aed4:	39c0004c 	andi	r7,r7,1
 820aed8:	38003a26 	beq	r7,zero,820afc4 <_free_r+0x178>
 820aedc:	10c00054 	ori	r3,r2,1
 820aee0:	30c00115 	stw	r3,4(r6)
 820aee4:	3087883a 	add	r3,r6,r2
 820aee8:	18800015 	stw	r2,0(r3)
 820aeec:	00c07fc4 	movi	r3,511
 820aef0:	18801936 	bltu	r3,r2,820af58 <_free_r+0x10c>
 820aef4:	1004d0fa 	srli	r2,r2,3
 820aef8:	01c00044 	movi	r7,1
 820aefc:	21400117 	ldw	r5,4(r4)
 820af00:	10c00044 	addi	r3,r2,1
 820af04:	18c7883a 	add	r3,r3,r3
 820af08:	1005d0ba 	srai	r2,r2,2
 820af0c:	18c7883a 	add	r3,r3,r3
 820af10:	18c7883a 	add	r3,r3,r3
 820af14:	1907883a 	add	r3,r3,r4
 820af18:	3884983a 	sll	r2,r7,r2
 820af1c:	19c00017 	ldw	r7,0(r3)
 820af20:	1a3ffe04 	addi	r8,r3,-8
 820af24:	1144b03a 	or	r2,r2,r5
 820af28:	32000315 	stw	r8,12(r6)
 820af2c:	31c00215 	stw	r7,8(r6)
 820af30:	20800115 	stw	r2,4(r4)
 820af34:	19800015 	stw	r6,0(r3)
 820af38:	39800315 	stw	r6,12(r7)
 820af3c:	8809883a 	mov	r4,r17
 820af40:	dfc00217 	ldw	ra,8(sp)
 820af44:	dc400117 	ldw	r17,4(sp)
 820af48:	dc000017 	ldw	r16,0(sp)
 820af4c:	dec00304 	addi	sp,sp,12
 820af50:	82148641 	jmpi	8214864 <__malloc_unlock>
 820af54:	f800283a 	ret
 820af58:	100ad27a 	srli	r5,r2,9
 820af5c:	00c00104 	movi	r3,4
 820af60:	19404a36 	bltu	r3,r5,820b08c <_free_r+0x240>
 820af64:	100ad1ba 	srli	r5,r2,6
 820af68:	28c00e44 	addi	r3,r5,57
 820af6c:	18c7883a 	add	r3,r3,r3
 820af70:	29400e04 	addi	r5,r5,56
 820af74:	18c7883a 	add	r3,r3,r3
 820af78:	18c7883a 	add	r3,r3,r3
 820af7c:	1909883a 	add	r4,r3,r4
 820af80:	20c00017 	ldw	r3,0(r4)
 820af84:	01c20974 	movhi	r7,2085
 820af88:	213ffe04 	addi	r4,r4,-8
 820af8c:	39c84604 	addi	r7,r7,8472
 820af90:	20c04426 	beq	r4,r3,820b0a4 <_free_r+0x258>
 820af94:	01ffff04 	movi	r7,-4
 820af98:	19400117 	ldw	r5,4(r3)
 820af9c:	29ca703a 	and	r5,r5,r7
 820afa0:	1140022e 	bgeu	r2,r5,820afac <_free_r+0x160>
 820afa4:	18c00217 	ldw	r3,8(r3)
 820afa8:	20fffb1e 	bne	r4,r3,820af98 <_free_r+0x14c>
 820afac:	19000317 	ldw	r4,12(r3)
 820afb0:	31000315 	stw	r4,12(r6)
 820afb4:	30c00215 	stw	r3,8(r6)
 820afb8:	21800215 	stw	r6,8(r4)
 820afbc:	19800315 	stw	r6,12(r3)
 820afc0:	003fde06 	br	820af3c <_free_r+0xf0>
 820afc4:	29c00217 	ldw	r7,8(r5)
 820afc8:	10c5883a 	add	r2,r2,r3
 820afcc:	00c20974 	movhi	r3,2085
 820afd0:	18c84804 	addi	r3,r3,8480
 820afd4:	38c03b26 	beq	r7,r3,820b0c4 <_free_r+0x278>
 820afd8:	2a000317 	ldw	r8,12(r5)
 820afdc:	11400054 	ori	r5,r2,1
 820afe0:	3087883a 	add	r3,r6,r2
 820afe4:	3a000315 	stw	r8,12(r7)
 820afe8:	41c00215 	stw	r7,8(r8)
 820afec:	31400115 	stw	r5,4(r6)
 820aff0:	18800015 	stw	r2,0(r3)
 820aff4:	003fbd06 	br	820aeec <_free_r+0xa0>
 820aff8:	39c0004c 	andi	r7,r7,1
 820affc:	10c5883a 	add	r2,r2,r3
 820b000:	3800071e 	bne	r7,zero,820b020 <_free_r+0x1d4>
 820b004:	81fffe17 	ldw	r7,-8(r16)
 820b008:	31cdc83a 	sub	r6,r6,r7
 820b00c:	30c00317 	ldw	r3,12(r6)
 820b010:	31400217 	ldw	r5,8(r6)
 820b014:	11c5883a 	add	r2,r2,r7
 820b018:	28c00315 	stw	r3,12(r5)
 820b01c:	19400215 	stw	r5,8(r3)
 820b020:	10c00054 	ori	r3,r2,1
 820b024:	30c00115 	stw	r3,4(r6)
 820b028:	00c20974 	movhi	r3,2085
 820b02c:	18cebb04 	addi	r3,r3,15084
 820b030:	18c00017 	ldw	r3,0(r3)
 820b034:	21800215 	stw	r6,8(r4)
 820b038:	10ffc036 	bltu	r2,r3,820af3c <_free_r+0xf0>
 820b03c:	00820974 	movhi	r2,2085
 820b040:	108f1804 	addi	r2,r2,15456
 820b044:	11400017 	ldw	r5,0(r2)
 820b048:	8809883a 	mov	r4,r17
 820b04c:	820ad280 	call	820ad28 <_malloc_trim_r>
 820b050:	003fba06 	br	820af3c <_free_r+0xf0>
 820b054:	28c9883a 	add	r4,r5,r3
 820b058:	21000117 	ldw	r4,4(r4)
 820b05c:	2100004c 	andi	r4,r4,1
 820b060:	2000391e 	bne	r4,zero,820b148 <_free_r+0x2fc>
 820b064:	29c00217 	ldw	r7,8(r5)
 820b068:	29000317 	ldw	r4,12(r5)
 820b06c:	1885883a 	add	r2,r3,r2
 820b070:	10c00054 	ori	r3,r2,1
 820b074:	39000315 	stw	r4,12(r7)
 820b078:	21c00215 	stw	r7,8(r4)
 820b07c:	30c00115 	stw	r3,4(r6)
 820b080:	308d883a 	add	r6,r6,r2
 820b084:	30800015 	stw	r2,0(r6)
 820b088:	003fac06 	br	820af3c <_free_r+0xf0>
 820b08c:	00c00504 	movi	r3,20
 820b090:	19401536 	bltu	r3,r5,820b0e8 <_free_r+0x29c>
 820b094:	28c01704 	addi	r3,r5,92
 820b098:	18c7883a 	add	r3,r3,r3
 820b09c:	294016c4 	addi	r5,r5,91
 820b0a0:	003fb406 	br	820af74 <_free_r+0x128>
 820b0a4:	280bd0ba 	srai	r5,r5,2
 820b0a8:	00c00044 	movi	r3,1
 820b0ac:	38800117 	ldw	r2,4(r7)
 820b0b0:	194a983a 	sll	r5,r3,r5
 820b0b4:	2007883a 	mov	r3,r4
 820b0b8:	2884b03a 	or	r2,r5,r2
 820b0bc:	38800115 	stw	r2,4(r7)
 820b0c0:	003fbb06 	br	820afb0 <_free_r+0x164>
 820b0c4:	21800515 	stw	r6,20(r4)
 820b0c8:	21800415 	stw	r6,16(r4)
 820b0cc:	10c00054 	ori	r3,r2,1
 820b0d0:	31c00315 	stw	r7,12(r6)
 820b0d4:	31c00215 	stw	r7,8(r6)
 820b0d8:	30c00115 	stw	r3,4(r6)
 820b0dc:	308d883a 	add	r6,r6,r2
 820b0e0:	30800015 	stw	r2,0(r6)
 820b0e4:	003f9506 	br	820af3c <_free_r+0xf0>
 820b0e8:	00c01504 	movi	r3,84
 820b0ec:	19400536 	bltu	r3,r5,820b104 <_free_r+0x2b8>
 820b0f0:	100ad33a 	srli	r5,r2,12
 820b0f4:	28c01bc4 	addi	r3,r5,111
 820b0f8:	18c7883a 	add	r3,r3,r3
 820b0fc:	29401b84 	addi	r5,r5,110
 820b100:	003f9c06 	br	820af74 <_free_r+0x128>
 820b104:	00c05504 	movi	r3,340
 820b108:	19400536 	bltu	r3,r5,820b120 <_free_r+0x2d4>
 820b10c:	100ad3fa 	srli	r5,r2,15
 820b110:	28c01e04 	addi	r3,r5,120
 820b114:	18c7883a 	add	r3,r3,r3
 820b118:	29401dc4 	addi	r5,r5,119
 820b11c:	003f9506 	br	820af74 <_free_r+0x128>
 820b120:	00c15504 	movi	r3,1364
 820b124:	19400536 	bltu	r3,r5,820b13c <_free_r+0x2f0>
 820b128:	100ad4ba 	srli	r5,r2,18
 820b12c:	28c01f44 	addi	r3,r5,125
 820b130:	18c7883a 	add	r3,r3,r3
 820b134:	29401f04 	addi	r5,r5,124
 820b138:	003f8e06 	br	820af74 <_free_r+0x128>
 820b13c:	00c03f84 	movi	r3,254
 820b140:	01401f84 	movi	r5,126
 820b144:	003f8b06 	br	820af74 <_free_r+0x128>
 820b148:	10c00054 	ori	r3,r2,1
 820b14c:	30c00115 	stw	r3,4(r6)
 820b150:	308d883a 	add	r6,r6,r2
 820b154:	30800015 	stw	r2,0(r6)
 820b158:	003f7806 	br	820af3c <_free_r+0xf0>

0820b15c <__sfvwrite_r>:
 820b15c:	30800217 	ldw	r2,8(r6)
 820b160:	10006726 	beq	r2,zero,820b300 <__sfvwrite_r+0x1a4>
 820b164:	28c0030b 	ldhu	r3,12(r5)
 820b168:	defff404 	addi	sp,sp,-48
 820b16c:	dd400715 	stw	r21,28(sp)
 820b170:	dd000615 	stw	r20,24(sp)
 820b174:	dc000215 	stw	r16,8(sp)
 820b178:	dfc00b15 	stw	ra,44(sp)
 820b17c:	df000a15 	stw	fp,40(sp)
 820b180:	ddc00915 	stw	r23,36(sp)
 820b184:	dd800815 	stw	r22,32(sp)
 820b188:	dcc00515 	stw	r19,20(sp)
 820b18c:	dc800415 	stw	r18,16(sp)
 820b190:	dc400315 	stw	r17,12(sp)
 820b194:	1880020c 	andi	r2,r3,8
 820b198:	2821883a 	mov	r16,r5
 820b19c:	202b883a 	mov	r21,r4
 820b1a0:	3029883a 	mov	r20,r6
 820b1a4:	10002726 	beq	r2,zero,820b244 <__sfvwrite_r+0xe8>
 820b1a8:	28800417 	ldw	r2,16(r5)
 820b1ac:	10002526 	beq	r2,zero,820b244 <__sfvwrite_r+0xe8>
 820b1b0:	1880008c 	andi	r2,r3,2
 820b1b4:	a4400017 	ldw	r17,0(r20)
 820b1b8:	10002a26 	beq	r2,zero,820b264 <__sfvwrite_r+0x108>
 820b1bc:	05a00034 	movhi	r22,32768
 820b1c0:	0027883a 	mov	r19,zero
 820b1c4:	0025883a 	mov	r18,zero
 820b1c8:	b5bf0004 	addi	r22,r22,-1024
 820b1cc:	980d883a 	mov	r6,r19
 820b1d0:	a809883a 	mov	r4,r21
 820b1d4:	90004626 	beq	r18,zero,820b2f0 <__sfvwrite_r+0x194>
 820b1d8:	900f883a 	mov	r7,r18
 820b1dc:	b480022e 	bgeu	r22,r18,820b1e8 <__sfvwrite_r+0x8c>
 820b1e0:	01e00034 	movhi	r7,32768
 820b1e4:	39ff0004 	addi	r7,r7,-1024
 820b1e8:	80800917 	ldw	r2,36(r16)
 820b1ec:	81400717 	ldw	r5,28(r16)
 820b1f0:	103ee83a 	callr	r2
 820b1f4:	0080570e 	bge	zero,r2,820b354 <__sfvwrite_r+0x1f8>
 820b1f8:	a0c00217 	ldw	r3,8(r20)
 820b1fc:	98a7883a 	add	r19,r19,r2
 820b200:	90a5c83a 	sub	r18,r18,r2
 820b204:	1885c83a 	sub	r2,r3,r2
 820b208:	a0800215 	stw	r2,8(r20)
 820b20c:	103fef1e 	bne	r2,zero,820b1cc <__sfvwrite_r+0x70>
 820b210:	0005883a 	mov	r2,zero
 820b214:	dfc00b17 	ldw	ra,44(sp)
 820b218:	df000a17 	ldw	fp,40(sp)
 820b21c:	ddc00917 	ldw	r23,36(sp)
 820b220:	dd800817 	ldw	r22,32(sp)
 820b224:	dd400717 	ldw	r21,28(sp)
 820b228:	dd000617 	ldw	r20,24(sp)
 820b22c:	dcc00517 	ldw	r19,20(sp)
 820b230:	dc800417 	ldw	r18,16(sp)
 820b234:	dc400317 	ldw	r17,12(sp)
 820b238:	dc000217 	ldw	r16,8(sp)
 820b23c:	dec00c04 	addi	sp,sp,48
 820b240:	f800283a 	ret
 820b244:	800b883a 	mov	r5,r16
 820b248:	a809883a 	mov	r4,r21
 820b24c:	8208bb00 	call	8208bb0 <__swsetup_r>
 820b250:	1000eb1e 	bne	r2,zero,820b600 <__sfvwrite_r+0x4a4>
 820b254:	80c0030b 	ldhu	r3,12(r16)
 820b258:	a4400017 	ldw	r17,0(r20)
 820b25c:	1880008c 	andi	r2,r3,2
 820b260:	103fd61e 	bne	r2,zero,820b1bc <__sfvwrite_r+0x60>
 820b264:	1880004c 	andi	r2,r3,1
 820b268:	10003f1e 	bne	r2,zero,820b368 <__sfvwrite_r+0x20c>
 820b26c:	0039883a 	mov	fp,zero
 820b270:	0025883a 	mov	r18,zero
 820b274:	90001a26 	beq	r18,zero,820b2e0 <__sfvwrite_r+0x184>
 820b278:	1880800c 	andi	r2,r3,512
 820b27c:	84c00217 	ldw	r19,8(r16)
 820b280:	10002126 	beq	r2,zero,820b308 <__sfvwrite_r+0x1ac>
 820b284:	982f883a 	mov	r23,r19
 820b288:	94c09336 	bltu	r18,r19,820b4d8 <__sfvwrite_r+0x37c>
 820b28c:	1881200c 	andi	r2,r3,1152
 820b290:	10009e1e 	bne	r2,zero,820b50c <__sfvwrite_r+0x3b0>
 820b294:	81000017 	ldw	r4,0(r16)
 820b298:	b80d883a 	mov	r6,r23
 820b29c:	e00b883a 	mov	r5,fp
 820b2a0:	8202da40 	call	8202da4 <memmove>
 820b2a4:	80c00217 	ldw	r3,8(r16)
 820b2a8:	81000017 	ldw	r4,0(r16)
 820b2ac:	9005883a 	mov	r2,r18
 820b2b0:	1ce7c83a 	sub	r19,r3,r19
 820b2b4:	25cf883a 	add	r7,r4,r23
 820b2b8:	84c00215 	stw	r19,8(r16)
 820b2bc:	81c00015 	stw	r7,0(r16)
 820b2c0:	a0c00217 	ldw	r3,8(r20)
 820b2c4:	e0b9883a 	add	fp,fp,r2
 820b2c8:	90a5c83a 	sub	r18,r18,r2
 820b2cc:	18a7c83a 	sub	r19,r3,r2
 820b2d0:	a4c00215 	stw	r19,8(r20)
 820b2d4:	983fce26 	beq	r19,zero,820b210 <__sfvwrite_r+0xb4>
 820b2d8:	80c0030b 	ldhu	r3,12(r16)
 820b2dc:	903fe61e 	bne	r18,zero,820b278 <__sfvwrite_r+0x11c>
 820b2e0:	8f000017 	ldw	fp,0(r17)
 820b2e4:	8c800117 	ldw	r18,4(r17)
 820b2e8:	8c400204 	addi	r17,r17,8
 820b2ec:	003fe106 	br	820b274 <__sfvwrite_r+0x118>
 820b2f0:	8cc00017 	ldw	r19,0(r17)
 820b2f4:	8c800117 	ldw	r18,4(r17)
 820b2f8:	8c400204 	addi	r17,r17,8
 820b2fc:	003fb306 	br	820b1cc <__sfvwrite_r+0x70>
 820b300:	0005883a 	mov	r2,zero
 820b304:	f800283a 	ret
 820b308:	81000017 	ldw	r4,0(r16)
 820b30c:	80800417 	ldw	r2,16(r16)
 820b310:	11005736 	bltu	r2,r4,820b470 <__sfvwrite_r+0x314>
 820b314:	85c00517 	ldw	r23,20(r16)
 820b318:	95c05536 	bltu	r18,r23,820b470 <__sfvwrite_r+0x314>
 820b31c:	00a00034 	movhi	r2,32768
 820b320:	10bfffc4 	addi	r2,r2,-1
 820b324:	9009883a 	mov	r4,r18
 820b328:	1480012e 	bgeu	r2,r18,820b330 <__sfvwrite_r+0x1d4>
 820b32c:	1009883a 	mov	r4,r2
 820b330:	b80b883a 	mov	r5,r23
 820b334:	82028640 	call	8202864 <__divsi3>
 820b338:	15cf383a 	mul	r7,r2,r23
 820b33c:	81400717 	ldw	r5,28(r16)
 820b340:	80800917 	ldw	r2,36(r16)
 820b344:	e00d883a 	mov	r6,fp
 820b348:	a809883a 	mov	r4,r21
 820b34c:	103ee83a 	callr	r2
 820b350:	00bfdb16 	blt	zero,r2,820b2c0 <__sfvwrite_r+0x164>
 820b354:	8080030b 	ldhu	r2,12(r16)
 820b358:	10801014 	ori	r2,r2,64
 820b35c:	8080030d 	sth	r2,12(r16)
 820b360:	00bfffc4 	movi	r2,-1
 820b364:	003fab06 	br	820b214 <__sfvwrite_r+0xb8>
 820b368:	0027883a 	mov	r19,zero
 820b36c:	0011883a 	mov	r8,zero
 820b370:	0039883a 	mov	fp,zero
 820b374:	0025883a 	mov	r18,zero
 820b378:	90001f26 	beq	r18,zero,820b3f8 <__sfvwrite_r+0x29c>
 820b37c:	40005a26 	beq	r8,zero,820b4e8 <__sfvwrite_r+0x38c>
 820b380:	982d883a 	mov	r22,r19
 820b384:	94c0012e 	bgeu	r18,r19,820b38c <__sfvwrite_r+0x230>
 820b388:	902d883a 	mov	r22,r18
 820b38c:	81000017 	ldw	r4,0(r16)
 820b390:	80800417 	ldw	r2,16(r16)
 820b394:	b02f883a 	mov	r23,r22
 820b398:	81c00517 	ldw	r7,20(r16)
 820b39c:	1100032e 	bgeu	r2,r4,820b3ac <__sfvwrite_r+0x250>
 820b3a0:	80c00217 	ldw	r3,8(r16)
 820b3a4:	38c7883a 	add	r3,r7,r3
 820b3a8:	1d801816 	blt	r3,r22,820b40c <__sfvwrite_r+0x2b0>
 820b3ac:	b1c03e16 	blt	r22,r7,820b4a8 <__sfvwrite_r+0x34c>
 820b3b0:	80800917 	ldw	r2,36(r16)
 820b3b4:	81400717 	ldw	r5,28(r16)
 820b3b8:	e00d883a 	mov	r6,fp
 820b3bc:	da000115 	stw	r8,4(sp)
 820b3c0:	a809883a 	mov	r4,r21
 820b3c4:	103ee83a 	callr	r2
 820b3c8:	102f883a 	mov	r23,r2
 820b3cc:	da000117 	ldw	r8,4(sp)
 820b3d0:	00bfe00e 	bge	zero,r2,820b354 <__sfvwrite_r+0x1f8>
 820b3d4:	9de7c83a 	sub	r19,r19,r23
 820b3d8:	98001f26 	beq	r19,zero,820b458 <__sfvwrite_r+0x2fc>
 820b3dc:	a0800217 	ldw	r2,8(r20)
 820b3e0:	e5f9883a 	add	fp,fp,r23
 820b3e4:	95e5c83a 	sub	r18,r18,r23
 820b3e8:	15efc83a 	sub	r23,r2,r23
 820b3ec:	a5c00215 	stw	r23,8(r20)
 820b3f0:	b83f8726 	beq	r23,zero,820b210 <__sfvwrite_r+0xb4>
 820b3f4:	903fe11e 	bne	r18,zero,820b37c <__sfvwrite_r+0x220>
 820b3f8:	8f000017 	ldw	fp,0(r17)
 820b3fc:	8c800117 	ldw	r18,4(r17)
 820b400:	0011883a 	mov	r8,zero
 820b404:	8c400204 	addi	r17,r17,8
 820b408:	003fdb06 	br	820b378 <__sfvwrite_r+0x21c>
 820b40c:	180d883a 	mov	r6,r3
 820b410:	e00b883a 	mov	r5,fp
 820b414:	da000115 	stw	r8,4(sp)
 820b418:	d8c00015 	stw	r3,0(sp)
 820b41c:	8202da40 	call	8202da4 <memmove>
 820b420:	d8c00017 	ldw	r3,0(sp)
 820b424:	80800017 	ldw	r2,0(r16)
 820b428:	800b883a 	mov	r5,r16
 820b42c:	a809883a 	mov	r4,r21
 820b430:	10c5883a 	add	r2,r2,r3
 820b434:	80800015 	stw	r2,0(r16)
 820b438:	d8c00015 	stw	r3,0(sp)
 820b43c:	820a7a80 	call	820a7a8 <_fflush_r>
 820b440:	d8c00017 	ldw	r3,0(sp)
 820b444:	da000117 	ldw	r8,4(sp)
 820b448:	103fc21e 	bne	r2,zero,820b354 <__sfvwrite_r+0x1f8>
 820b44c:	182f883a 	mov	r23,r3
 820b450:	9de7c83a 	sub	r19,r19,r23
 820b454:	983fe11e 	bne	r19,zero,820b3dc <__sfvwrite_r+0x280>
 820b458:	800b883a 	mov	r5,r16
 820b45c:	a809883a 	mov	r4,r21
 820b460:	820a7a80 	call	820a7a8 <_fflush_r>
 820b464:	103fbb1e 	bne	r2,zero,820b354 <__sfvwrite_r+0x1f8>
 820b468:	0011883a 	mov	r8,zero
 820b46c:	003fdb06 	br	820b3dc <__sfvwrite_r+0x280>
 820b470:	94c0012e 	bgeu	r18,r19,820b478 <__sfvwrite_r+0x31c>
 820b474:	9027883a 	mov	r19,r18
 820b478:	980d883a 	mov	r6,r19
 820b47c:	e00b883a 	mov	r5,fp
 820b480:	8202da40 	call	8202da4 <memmove>
 820b484:	80800217 	ldw	r2,8(r16)
 820b488:	80c00017 	ldw	r3,0(r16)
 820b48c:	14c5c83a 	sub	r2,r2,r19
 820b490:	1cc7883a 	add	r3,r3,r19
 820b494:	80800215 	stw	r2,8(r16)
 820b498:	80c00015 	stw	r3,0(r16)
 820b49c:	10004326 	beq	r2,zero,820b5ac <__sfvwrite_r+0x450>
 820b4a0:	9805883a 	mov	r2,r19
 820b4a4:	003f8606 	br	820b2c0 <__sfvwrite_r+0x164>
 820b4a8:	b00d883a 	mov	r6,r22
 820b4ac:	e00b883a 	mov	r5,fp
 820b4b0:	da000115 	stw	r8,4(sp)
 820b4b4:	8202da40 	call	8202da4 <memmove>
 820b4b8:	80800217 	ldw	r2,8(r16)
 820b4bc:	80c00017 	ldw	r3,0(r16)
 820b4c0:	da000117 	ldw	r8,4(sp)
 820b4c4:	1585c83a 	sub	r2,r2,r22
 820b4c8:	1dad883a 	add	r22,r3,r22
 820b4cc:	80800215 	stw	r2,8(r16)
 820b4d0:	85800015 	stw	r22,0(r16)
 820b4d4:	003fbf06 	br	820b3d4 <__sfvwrite_r+0x278>
 820b4d8:	81000017 	ldw	r4,0(r16)
 820b4dc:	9027883a 	mov	r19,r18
 820b4e0:	902f883a 	mov	r23,r18
 820b4e4:	003f6c06 	br	820b298 <__sfvwrite_r+0x13c>
 820b4e8:	900d883a 	mov	r6,r18
 820b4ec:	01400284 	movi	r5,10
 820b4f0:	e009883a 	mov	r4,fp
 820b4f4:	820c2440 	call	820c244 <memchr>
 820b4f8:	10003e26 	beq	r2,zero,820b5f4 <__sfvwrite_r+0x498>
 820b4fc:	10800044 	addi	r2,r2,1
 820b500:	1727c83a 	sub	r19,r2,fp
 820b504:	02000044 	movi	r8,1
 820b508:	003f9d06 	br	820b380 <__sfvwrite_r+0x224>
 820b50c:	80800517 	ldw	r2,20(r16)
 820b510:	81400417 	ldw	r5,16(r16)
 820b514:	81c00017 	ldw	r7,0(r16)
 820b518:	10a7883a 	add	r19,r2,r2
 820b51c:	9885883a 	add	r2,r19,r2
 820b520:	1026d7fa 	srli	r19,r2,31
 820b524:	396dc83a 	sub	r22,r7,r5
 820b528:	b1000044 	addi	r4,r22,1
 820b52c:	9885883a 	add	r2,r19,r2
 820b530:	1027d07a 	srai	r19,r2,1
 820b534:	2485883a 	add	r2,r4,r18
 820b538:	980d883a 	mov	r6,r19
 820b53c:	9880022e 	bgeu	r19,r2,820b548 <__sfvwrite_r+0x3ec>
 820b540:	1027883a 	mov	r19,r2
 820b544:	100d883a 	mov	r6,r2
 820b548:	18c1000c 	andi	r3,r3,1024
 820b54c:	18001c26 	beq	r3,zero,820b5c0 <__sfvwrite_r+0x464>
 820b550:	300b883a 	mov	r5,r6
 820b554:	a809883a 	mov	r4,r21
 820b558:	820ba380 	call	820ba38 <_malloc_r>
 820b55c:	102f883a 	mov	r23,r2
 820b560:	10002926 	beq	r2,zero,820b608 <__sfvwrite_r+0x4ac>
 820b564:	81400417 	ldw	r5,16(r16)
 820b568:	b00d883a 	mov	r6,r22
 820b56c:	1009883a 	mov	r4,r2
 820b570:	8202c5c0 	call	8202c5c <memcpy>
 820b574:	8080030b 	ldhu	r2,12(r16)
 820b578:	00fedfc4 	movi	r3,-1153
 820b57c:	10c4703a 	and	r2,r2,r3
 820b580:	10802014 	ori	r2,r2,128
 820b584:	8080030d 	sth	r2,12(r16)
 820b588:	bd89883a 	add	r4,r23,r22
 820b58c:	9d8fc83a 	sub	r7,r19,r22
 820b590:	85c00415 	stw	r23,16(r16)
 820b594:	84c00515 	stw	r19,20(r16)
 820b598:	81000015 	stw	r4,0(r16)
 820b59c:	9027883a 	mov	r19,r18
 820b5a0:	81c00215 	stw	r7,8(r16)
 820b5a4:	902f883a 	mov	r23,r18
 820b5a8:	003f3b06 	br	820b298 <__sfvwrite_r+0x13c>
 820b5ac:	800b883a 	mov	r5,r16
 820b5b0:	a809883a 	mov	r4,r21
 820b5b4:	820a7a80 	call	820a7a8 <_fflush_r>
 820b5b8:	103fb926 	beq	r2,zero,820b4a0 <__sfvwrite_r+0x344>
 820b5bc:	003f6506 	br	820b354 <__sfvwrite_r+0x1f8>
 820b5c0:	a809883a 	mov	r4,r21
 820b5c4:	820d3a00 	call	820d3a0 <_realloc_r>
 820b5c8:	102f883a 	mov	r23,r2
 820b5cc:	103fee1e 	bne	r2,zero,820b588 <__sfvwrite_r+0x42c>
 820b5d0:	81400417 	ldw	r5,16(r16)
 820b5d4:	a809883a 	mov	r4,r21
 820b5d8:	820ae4c0 	call	820ae4c <_free_r>
 820b5dc:	8080030b 	ldhu	r2,12(r16)
 820b5e0:	00ffdfc4 	movi	r3,-129
 820b5e4:	1884703a 	and	r2,r3,r2
 820b5e8:	00c00304 	movi	r3,12
 820b5ec:	a8c00015 	stw	r3,0(r21)
 820b5f0:	003f5906 	br	820b358 <__sfvwrite_r+0x1fc>
 820b5f4:	94c00044 	addi	r19,r18,1
 820b5f8:	02000044 	movi	r8,1
 820b5fc:	003f6006 	br	820b380 <__sfvwrite_r+0x224>
 820b600:	00bfffc4 	movi	r2,-1
 820b604:	003f0306 	br	820b214 <__sfvwrite_r+0xb8>
 820b608:	00800304 	movi	r2,12
 820b60c:	a8800015 	stw	r2,0(r21)
 820b610:	8080030b 	ldhu	r2,12(r16)
 820b614:	003f5006 	br	820b358 <__sfvwrite_r+0x1fc>

0820b618 <_fwalk>:
 820b618:	defff704 	addi	sp,sp,-36
 820b61c:	dd000415 	stw	r20,16(sp)
 820b620:	dfc00815 	stw	ra,32(sp)
 820b624:	ddc00715 	stw	r23,28(sp)
 820b628:	dd800615 	stw	r22,24(sp)
 820b62c:	dd400515 	stw	r21,20(sp)
 820b630:	dcc00315 	stw	r19,12(sp)
 820b634:	dc800215 	stw	r18,8(sp)
 820b638:	dc400115 	stw	r17,4(sp)
 820b63c:	dc000015 	stw	r16,0(sp)
 820b640:	2500b804 	addi	r20,r4,736
 820b644:	a0002326 	beq	r20,zero,820b6d4 <_fwalk+0xbc>
 820b648:	282b883a 	mov	r21,r5
 820b64c:	002f883a 	mov	r23,zero
 820b650:	05800044 	movi	r22,1
 820b654:	04ffffc4 	movi	r19,-1
 820b658:	a4400117 	ldw	r17,4(r20)
 820b65c:	a4800217 	ldw	r18,8(r20)
 820b660:	8c7fffc4 	addi	r17,r17,-1
 820b664:	88000d16 	blt	r17,zero,820b69c <_fwalk+0x84>
 820b668:	94000304 	addi	r16,r18,12
 820b66c:	94800384 	addi	r18,r18,14
 820b670:	8080000b 	ldhu	r2,0(r16)
 820b674:	8c7fffc4 	addi	r17,r17,-1
 820b678:	813ffd04 	addi	r4,r16,-12
 820b67c:	b080042e 	bgeu	r22,r2,820b690 <_fwalk+0x78>
 820b680:	9080000f 	ldh	r2,0(r18)
 820b684:	14c00226 	beq	r2,r19,820b690 <_fwalk+0x78>
 820b688:	a83ee83a 	callr	r21
 820b68c:	b8aeb03a 	or	r23,r23,r2
 820b690:	84001a04 	addi	r16,r16,104
 820b694:	94801a04 	addi	r18,r18,104
 820b698:	8cfff51e 	bne	r17,r19,820b670 <_fwalk+0x58>
 820b69c:	a5000017 	ldw	r20,0(r20)
 820b6a0:	a03fed1e 	bne	r20,zero,820b658 <_fwalk+0x40>
 820b6a4:	b805883a 	mov	r2,r23
 820b6a8:	dfc00817 	ldw	ra,32(sp)
 820b6ac:	ddc00717 	ldw	r23,28(sp)
 820b6b0:	dd800617 	ldw	r22,24(sp)
 820b6b4:	dd400517 	ldw	r21,20(sp)
 820b6b8:	dd000417 	ldw	r20,16(sp)
 820b6bc:	dcc00317 	ldw	r19,12(sp)
 820b6c0:	dc800217 	ldw	r18,8(sp)
 820b6c4:	dc400117 	ldw	r17,4(sp)
 820b6c8:	dc000017 	ldw	r16,0(sp)
 820b6cc:	dec00904 	addi	sp,sp,36
 820b6d0:	f800283a 	ret
 820b6d4:	002f883a 	mov	r23,zero
 820b6d8:	003ff206 	br	820b6a4 <_fwalk+0x8c>

0820b6dc <_fwalk_reent>:
 820b6dc:	defff704 	addi	sp,sp,-36
 820b6e0:	dd000415 	stw	r20,16(sp)
 820b6e4:	dfc00815 	stw	ra,32(sp)
 820b6e8:	ddc00715 	stw	r23,28(sp)
 820b6ec:	dd800615 	stw	r22,24(sp)
 820b6f0:	dd400515 	stw	r21,20(sp)
 820b6f4:	dcc00315 	stw	r19,12(sp)
 820b6f8:	dc800215 	stw	r18,8(sp)
 820b6fc:	dc400115 	stw	r17,4(sp)
 820b700:	dc000015 	stw	r16,0(sp)
 820b704:	2500b804 	addi	r20,r4,736
 820b708:	a0002326 	beq	r20,zero,820b798 <_fwalk_reent+0xbc>
 820b70c:	282b883a 	mov	r21,r5
 820b710:	2027883a 	mov	r19,r4
 820b714:	002f883a 	mov	r23,zero
 820b718:	05800044 	movi	r22,1
 820b71c:	04bfffc4 	movi	r18,-1
 820b720:	a4400117 	ldw	r17,4(r20)
 820b724:	a4000217 	ldw	r16,8(r20)
 820b728:	8c7fffc4 	addi	r17,r17,-1
 820b72c:	88000c16 	blt	r17,zero,820b760 <_fwalk_reent+0x84>
 820b730:	84000304 	addi	r16,r16,12
 820b734:	8080000b 	ldhu	r2,0(r16)
 820b738:	8c7fffc4 	addi	r17,r17,-1
 820b73c:	817ffd04 	addi	r5,r16,-12
 820b740:	b080052e 	bgeu	r22,r2,820b758 <_fwalk_reent+0x7c>
 820b744:	8080008f 	ldh	r2,2(r16)
 820b748:	9809883a 	mov	r4,r19
 820b74c:	14800226 	beq	r2,r18,820b758 <_fwalk_reent+0x7c>
 820b750:	a83ee83a 	callr	r21
 820b754:	b8aeb03a 	or	r23,r23,r2
 820b758:	84001a04 	addi	r16,r16,104
 820b75c:	8cbff51e 	bne	r17,r18,820b734 <_fwalk_reent+0x58>
 820b760:	a5000017 	ldw	r20,0(r20)
 820b764:	a03fee1e 	bne	r20,zero,820b720 <_fwalk_reent+0x44>
 820b768:	b805883a 	mov	r2,r23
 820b76c:	dfc00817 	ldw	ra,32(sp)
 820b770:	ddc00717 	ldw	r23,28(sp)
 820b774:	dd800617 	ldw	r22,24(sp)
 820b778:	dd400517 	ldw	r21,20(sp)
 820b77c:	dd000417 	ldw	r20,16(sp)
 820b780:	dcc00317 	ldw	r19,12(sp)
 820b784:	dc800217 	ldw	r18,8(sp)
 820b788:	dc400117 	ldw	r17,4(sp)
 820b78c:	dc000017 	ldw	r16,0(sp)
 820b790:	dec00904 	addi	sp,sp,36
 820b794:	f800283a 	ret
 820b798:	002f883a 	mov	r23,zero
 820b79c:	003ff206 	br	820b768 <_fwalk_reent+0x8c>

0820b7a0 <_setlocale_r>:
 820b7a0:	30001b26 	beq	r6,zero,820b810 <_setlocale_r+0x70>
 820b7a4:	01420974 	movhi	r5,2085
 820b7a8:	defffe04 	addi	sp,sp,-8
 820b7ac:	2975fe04 	addi	r5,r5,-10248
 820b7b0:	3009883a 	mov	r4,r6
 820b7b4:	dc000015 	stw	r16,0(sp)
 820b7b8:	dfc00115 	stw	ra,4(sp)
 820b7bc:	3021883a 	mov	r16,r6
 820b7c0:	820dcf80 	call	820dcf8 <strcmp>
 820b7c4:	1000061e 	bne	r2,zero,820b7e0 <_setlocale_r+0x40>
 820b7c8:	00820974 	movhi	r2,2085
 820b7cc:	10b41604 	addi	r2,r2,-12200
 820b7d0:	dfc00117 	ldw	ra,4(sp)
 820b7d4:	dc000017 	ldw	r16,0(sp)
 820b7d8:	dec00204 	addi	sp,sp,8
 820b7dc:	f800283a 	ret
 820b7e0:	01420974 	movhi	r5,2085
 820b7e4:	29741604 	addi	r5,r5,-12200
 820b7e8:	8009883a 	mov	r4,r16
 820b7ec:	820dcf80 	call	820dcf8 <strcmp>
 820b7f0:	103ff526 	beq	r2,zero,820b7c8 <_setlocale_r+0x28>
 820b7f4:	01420974 	movhi	r5,2085
 820b7f8:	2975e104 	addi	r5,r5,-10364
 820b7fc:	8009883a 	mov	r4,r16
 820b800:	820dcf80 	call	820dcf8 <strcmp>
 820b804:	103ff026 	beq	r2,zero,820b7c8 <_setlocale_r+0x28>
 820b808:	0005883a 	mov	r2,zero
 820b80c:	003ff006 	br	820b7d0 <_setlocale_r+0x30>
 820b810:	00820974 	movhi	r2,2085
 820b814:	10b41604 	addi	r2,r2,-12200
 820b818:	f800283a 	ret

0820b81c <__locale_charset>:
 820b81c:	00820974 	movhi	r2,2085
 820b820:	10883004 	addi	r2,r2,8384
 820b824:	f800283a 	ret

0820b828 <__locale_mb_cur_max>:
 820b828:	00820974 	movhi	r2,2085
 820b82c:	108eb904 	addi	r2,r2,15076
 820b830:	10800017 	ldw	r2,0(r2)
 820b834:	f800283a 	ret

0820b838 <__locale_msgcharset>:
 820b838:	00820974 	movhi	r2,2085
 820b83c:	10882804 	addi	r2,r2,8352
 820b840:	f800283a 	ret

0820b844 <__locale_cjk_lang>:
 820b844:	0005883a 	mov	r2,zero
 820b848:	f800283a 	ret

0820b84c <_localeconv_r>:
 820b84c:	00820974 	movhi	r2,2085
 820b850:	10883804 	addi	r2,r2,8416
 820b854:	f800283a 	ret

0820b858 <setlocale>:
 820b858:	00820974 	movhi	r2,2085
 820b85c:	108eb804 	addi	r2,r2,15072
 820b860:	280d883a 	mov	r6,r5
 820b864:	200b883a 	mov	r5,r4
 820b868:	11000017 	ldw	r4,0(r2)
 820b86c:	820b7a01 	jmpi	820b7a0 <_setlocale_r>

0820b870 <localeconv>:
 820b870:	00820974 	movhi	r2,2085
 820b874:	10883804 	addi	r2,r2,8416
 820b878:	f800283a 	ret

0820b87c <__smakebuf_r>:
 820b87c:	2880030b 	ldhu	r2,12(r5)
 820b880:	10c0008c 	andi	r3,r2,2
 820b884:	1800411e 	bne	r3,zero,820b98c <__smakebuf_r+0x110>
 820b888:	deffec04 	addi	sp,sp,-80
 820b88c:	dc000f15 	stw	r16,60(sp)
 820b890:	2821883a 	mov	r16,r5
 820b894:	2940038f 	ldh	r5,14(r5)
 820b898:	dc401015 	stw	r17,64(sp)
 820b89c:	dfc01315 	stw	ra,76(sp)
 820b8a0:	dcc01215 	stw	r19,72(sp)
 820b8a4:	dc801115 	stw	r18,68(sp)
 820b8a8:	2023883a 	mov	r17,r4
 820b8ac:	28001c16 	blt	r5,zero,820b920 <__smakebuf_r+0xa4>
 820b8b0:	d80d883a 	mov	r6,sp
 820b8b4:	8210cac0 	call	8210cac <_fstat_r>
 820b8b8:	10001816 	blt	r2,zero,820b91c <__smakebuf_r+0xa0>
 820b8bc:	d8800117 	ldw	r2,4(sp)
 820b8c0:	00e00014 	movui	r3,32768
 820b8c4:	10bc000c 	andi	r2,r2,61440
 820b8c8:	14c80020 	cmpeqi	r19,r2,8192
 820b8cc:	10c03726 	beq	r2,r3,820b9ac <__smakebuf_r+0x130>
 820b8d0:	80c0030b 	ldhu	r3,12(r16)
 820b8d4:	18c20014 	ori	r3,r3,2048
 820b8d8:	80c0030d 	sth	r3,12(r16)
 820b8dc:	00c80004 	movi	r3,8192
 820b8e0:	10c0521e 	bne	r2,r3,820ba2c <__smakebuf_r+0x1b0>
 820b8e4:	8140038f 	ldh	r5,14(r16)
 820b8e8:	8809883a 	mov	r4,r17
 820b8ec:	8210d080 	call	8210d08 <_isatty_r>
 820b8f0:	10004c26 	beq	r2,zero,820ba24 <__smakebuf_r+0x1a8>
 820b8f4:	8080030b 	ldhu	r2,12(r16)
 820b8f8:	80c010c4 	addi	r3,r16,67
 820b8fc:	80c00015 	stw	r3,0(r16)
 820b900:	10800054 	ori	r2,r2,1
 820b904:	8080030d 	sth	r2,12(r16)
 820b908:	00800044 	movi	r2,1
 820b90c:	80c00415 	stw	r3,16(r16)
 820b910:	80800515 	stw	r2,20(r16)
 820b914:	04810004 	movi	r18,1024
 820b918:	00000706 	br	820b938 <__smakebuf_r+0xbc>
 820b91c:	8080030b 	ldhu	r2,12(r16)
 820b920:	10c0200c 	andi	r3,r2,128
 820b924:	18001f1e 	bne	r3,zero,820b9a4 <__smakebuf_r+0x128>
 820b928:	04810004 	movi	r18,1024
 820b92c:	10820014 	ori	r2,r2,2048
 820b930:	8080030d 	sth	r2,12(r16)
 820b934:	0027883a 	mov	r19,zero
 820b938:	900b883a 	mov	r5,r18
 820b93c:	8809883a 	mov	r4,r17
 820b940:	820ba380 	call	820ba38 <_malloc_r>
 820b944:	10002c26 	beq	r2,zero,820b9f8 <__smakebuf_r+0x17c>
 820b948:	80c0030b 	ldhu	r3,12(r16)
 820b94c:	01020874 	movhi	r4,2081
 820b950:	212a0f04 	addi	r4,r4,-22468
 820b954:	89000f15 	stw	r4,60(r17)
 820b958:	18c02014 	ori	r3,r3,128
 820b95c:	80c0030d 	sth	r3,12(r16)
 820b960:	80800015 	stw	r2,0(r16)
 820b964:	80800415 	stw	r2,16(r16)
 820b968:	84800515 	stw	r18,20(r16)
 820b96c:	98001a1e 	bne	r19,zero,820b9d8 <__smakebuf_r+0x15c>
 820b970:	dfc01317 	ldw	ra,76(sp)
 820b974:	dcc01217 	ldw	r19,72(sp)
 820b978:	dc801117 	ldw	r18,68(sp)
 820b97c:	dc401017 	ldw	r17,64(sp)
 820b980:	dc000f17 	ldw	r16,60(sp)
 820b984:	dec01404 	addi	sp,sp,80
 820b988:	f800283a 	ret
 820b98c:	288010c4 	addi	r2,r5,67
 820b990:	28800015 	stw	r2,0(r5)
 820b994:	28800415 	stw	r2,16(r5)
 820b998:	00800044 	movi	r2,1
 820b99c:	28800515 	stw	r2,20(r5)
 820b9a0:	f800283a 	ret
 820b9a4:	04801004 	movi	r18,64
 820b9a8:	003fe006 	br	820b92c <__smakebuf_r+0xb0>
 820b9ac:	81000a17 	ldw	r4,40(r16)
 820b9b0:	00c20874 	movhi	r3,2081
 820b9b4:	18f72504 	addi	r3,r3,-9068
 820b9b8:	20ffc51e 	bne	r4,r3,820b8d0 <__smakebuf_r+0x54>
 820b9bc:	8080030b 	ldhu	r2,12(r16)
 820b9c0:	04810004 	movi	r18,1024
 820b9c4:	84801315 	stw	r18,76(r16)
 820b9c8:	1484b03a 	or	r2,r2,r18
 820b9cc:	8080030d 	sth	r2,12(r16)
 820b9d0:	0027883a 	mov	r19,zero
 820b9d4:	003fd806 	br	820b938 <__smakebuf_r+0xbc>
 820b9d8:	8140038f 	ldh	r5,14(r16)
 820b9dc:	8809883a 	mov	r4,r17
 820b9e0:	8210d080 	call	8210d08 <_isatty_r>
 820b9e4:	103fe226 	beq	r2,zero,820b970 <__smakebuf_r+0xf4>
 820b9e8:	8080030b 	ldhu	r2,12(r16)
 820b9ec:	10800054 	ori	r2,r2,1
 820b9f0:	8080030d 	sth	r2,12(r16)
 820b9f4:	003fde06 	br	820b970 <__smakebuf_r+0xf4>
 820b9f8:	8080030b 	ldhu	r2,12(r16)
 820b9fc:	10c0800c 	andi	r3,r2,512
 820ba00:	183fdb1e 	bne	r3,zero,820b970 <__smakebuf_r+0xf4>
 820ba04:	10800094 	ori	r2,r2,2
 820ba08:	80c010c4 	addi	r3,r16,67
 820ba0c:	8080030d 	sth	r2,12(r16)
 820ba10:	00800044 	movi	r2,1
 820ba14:	80c00015 	stw	r3,0(r16)
 820ba18:	80c00415 	stw	r3,16(r16)
 820ba1c:	80800515 	stw	r2,20(r16)
 820ba20:	003fd306 	br	820b970 <__smakebuf_r+0xf4>
 820ba24:	04810004 	movi	r18,1024
 820ba28:	003fc306 	br	820b938 <__smakebuf_r+0xbc>
 820ba2c:	0027883a 	mov	r19,zero
 820ba30:	04810004 	movi	r18,1024
 820ba34:	003fc006 	br	820b938 <__smakebuf_r+0xbc>

0820ba38 <_malloc_r>:
 820ba38:	defff504 	addi	sp,sp,-44
 820ba3c:	dc800315 	stw	r18,12(sp)
 820ba40:	dfc00a15 	stw	ra,40(sp)
 820ba44:	df000915 	stw	fp,36(sp)
 820ba48:	ddc00815 	stw	r23,32(sp)
 820ba4c:	dd800715 	stw	r22,28(sp)
 820ba50:	dd400615 	stw	r21,24(sp)
 820ba54:	dd000515 	stw	r20,20(sp)
 820ba58:	dcc00415 	stw	r19,16(sp)
 820ba5c:	dc400215 	stw	r17,8(sp)
 820ba60:	dc000115 	stw	r16,4(sp)
 820ba64:	288002c4 	addi	r2,r5,11
 820ba68:	00c00584 	movi	r3,22
 820ba6c:	2025883a 	mov	r18,r4
 820ba70:	18807f2e 	bgeu	r3,r2,820bc70 <_malloc_r+0x238>
 820ba74:	047ffe04 	movi	r17,-8
 820ba78:	1462703a 	and	r17,r2,r17
 820ba7c:	8800a316 	blt	r17,zero,820bd0c <_malloc_r+0x2d4>
 820ba80:	8940a236 	bltu	r17,r5,820bd0c <_malloc_r+0x2d4>
 820ba84:	82147440 	call	8214744 <__malloc_lock>
 820ba88:	00807dc4 	movi	r2,503
 820ba8c:	1441e92e 	bgeu	r2,r17,820c234 <_malloc_r+0x7fc>
 820ba90:	8804d27a 	srli	r2,r17,9
 820ba94:	1000a126 	beq	r2,zero,820bd1c <_malloc_r+0x2e4>
 820ba98:	00c00104 	movi	r3,4
 820ba9c:	18811e36 	bltu	r3,r2,820bf18 <_malloc_r+0x4e0>
 820baa0:	8804d1ba 	srli	r2,r17,6
 820baa4:	12000e44 	addi	r8,r2,57
 820baa8:	11c00e04 	addi	r7,r2,56
 820baac:	4209883a 	add	r4,r8,r8
 820bab0:	04c20974 	movhi	r19,2085
 820bab4:	2109883a 	add	r4,r4,r4
 820bab8:	9cc84604 	addi	r19,r19,8472
 820babc:	2109883a 	add	r4,r4,r4
 820bac0:	9909883a 	add	r4,r19,r4
 820bac4:	24000117 	ldw	r16,4(r4)
 820bac8:	213ffe04 	addi	r4,r4,-8
 820bacc:	24009726 	beq	r4,r16,820bd2c <_malloc_r+0x2f4>
 820bad0:	80800117 	ldw	r2,4(r16)
 820bad4:	01bfff04 	movi	r6,-4
 820bad8:	014003c4 	movi	r5,15
 820badc:	1184703a 	and	r2,r2,r6
 820bae0:	1447c83a 	sub	r3,r2,r17
 820bae4:	28c00716 	blt	r5,r3,820bb04 <_malloc_r+0xcc>
 820bae8:	1800920e 	bge	r3,zero,820bd34 <_malloc_r+0x2fc>
 820baec:	84000317 	ldw	r16,12(r16)
 820baf0:	24008e26 	beq	r4,r16,820bd2c <_malloc_r+0x2f4>
 820baf4:	80800117 	ldw	r2,4(r16)
 820baf8:	1184703a 	and	r2,r2,r6
 820bafc:	1447c83a 	sub	r3,r2,r17
 820bb00:	28fff90e 	bge	r5,r3,820bae8 <_malloc_r+0xb0>
 820bb04:	3809883a 	mov	r4,r7
 820bb08:	01820974 	movhi	r6,2085
 820bb0c:	9c000417 	ldw	r16,16(r19)
 820bb10:	31884604 	addi	r6,r6,8472
 820bb14:	32000204 	addi	r8,r6,8
 820bb18:	82013426 	beq	r16,r8,820bfec <_malloc_r+0x5b4>
 820bb1c:	80c00117 	ldw	r3,4(r16)
 820bb20:	00bfff04 	movi	r2,-4
 820bb24:	188e703a 	and	r7,r3,r2
 820bb28:	3c45c83a 	sub	r2,r7,r17
 820bb2c:	00c003c4 	movi	r3,15
 820bb30:	18811f16 	blt	r3,r2,820bfb0 <_malloc_r+0x578>
 820bb34:	32000515 	stw	r8,20(r6)
 820bb38:	32000415 	stw	r8,16(r6)
 820bb3c:	10007f0e 	bge	r2,zero,820bd3c <_malloc_r+0x304>
 820bb40:	00807fc4 	movi	r2,511
 820bb44:	11c0fd36 	bltu	r2,r7,820bf3c <_malloc_r+0x504>
 820bb48:	3806d0fa 	srli	r3,r7,3
 820bb4c:	01c00044 	movi	r7,1
 820bb50:	30800117 	ldw	r2,4(r6)
 820bb54:	19400044 	addi	r5,r3,1
 820bb58:	294b883a 	add	r5,r5,r5
 820bb5c:	1807d0ba 	srai	r3,r3,2
 820bb60:	294b883a 	add	r5,r5,r5
 820bb64:	294b883a 	add	r5,r5,r5
 820bb68:	298b883a 	add	r5,r5,r6
 820bb6c:	38c6983a 	sll	r3,r7,r3
 820bb70:	29c00017 	ldw	r7,0(r5)
 820bb74:	2a7ffe04 	addi	r9,r5,-8
 820bb78:	1886b03a 	or	r3,r3,r2
 820bb7c:	82400315 	stw	r9,12(r16)
 820bb80:	81c00215 	stw	r7,8(r16)
 820bb84:	30c00115 	stw	r3,4(r6)
 820bb88:	2c000015 	stw	r16,0(r5)
 820bb8c:	3c000315 	stw	r16,12(r7)
 820bb90:	2005d0ba 	srai	r2,r4,2
 820bb94:	01400044 	movi	r5,1
 820bb98:	288a983a 	sll	r5,r5,r2
 820bb9c:	19406f36 	bltu	r3,r5,820bd5c <_malloc_r+0x324>
 820bba0:	28c4703a 	and	r2,r5,r3
 820bba4:	10000a1e 	bne	r2,zero,820bbd0 <_malloc_r+0x198>
 820bba8:	00bfff04 	movi	r2,-4
 820bbac:	294b883a 	add	r5,r5,r5
 820bbb0:	2088703a 	and	r4,r4,r2
 820bbb4:	28c4703a 	and	r2,r5,r3
 820bbb8:	21000104 	addi	r4,r4,4
 820bbbc:	1000041e 	bne	r2,zero,820bbd0 <_malloc_r+0x198>
 820bbc0:	294b883a 	add	r5,r5,r5
 820bbc4:	28c4703a 	and	r2,r5,r3
 820bbc8:	21000104 	addi	r4,r4,4
 820bbcc:	103ffc26 	beq	r2,zero,820bbc0 <_malloc_r+0x188>
 820bbd0:	02bfff04 	movi	r10,-4
 820bbd4:	024003c4 	movi	r9,15
 820bbd8:	21800044 	addi	r6,r4,1
 820bbdc:	318d883a 	add	r6,r6,r6
 820bbe0:	318d883a 	add	r6,r6,r6
 820bbe4:	318d883a 	add	r6,r6,r6
 820bbe8:	998d883a 	add	r6,r19,r6
 820bbec:	333ffe04 	addi	r12,r6,-8
 820bbf0:	2017883a 	mov	r11,r4
 820bbf4:	31800104 	addi	r6,r6,4
 820bbf8:	34000017 	ldw	r16,0(r6)
 820bbfc:	31fffd04 	addi	r7,r6,-12
 820bc00:	81c0041e 	bne	r16,r7,820bc14 <_malloc_r+0x1dc>
 820bc04:	0000fb06 	br	820bff4 <_malloc_r+0x5bc>
 820bc08:	1801030e 	bge	r3,zero,820c018 <_malloc_r+0x5e0>
 820bc0c:	84000317 	ldw	r16,12(r16)
 820bc10:	81c0f826 	beq	r16,r7,820bff4 <_malloc_r+0x5bc>
 820bc14:	80800117 	ldw	r2,4(r16)
 820bc18:	1284703a 	and	r2,r2,r10
 820bc1c:	1447c83a 	sub	r3,r2,r17
 820bc20:	48fff90e 	bge	r9,r3,820bc08 <_malloc_r+0x1d0>
 820bc24:	80800317 	ldw	r2,12(r16)
 820bc28:	81000217 	ldw	r4,8(r16)
 820bc2c:	89400054 	ori	r5,r17,1
 820bc30:	81400115 	stw	r5,4(r16)
 820bc34:	20800315 	stw	r2,12(r4)
 820bc38:	11000215 	stw	r4,8(r2)
 820bc3c:	8463883a 	add	r17,r16,r17
 820bc40:	9c400515 	stw	r17,20(r19)
 820bc44:	9c400415 	stw	r17,16(r19)
 820bc48:	18800054 	ori	r2,r3,1
 820bc4c:	88800115 	stw	r2,4(r17)
 820bc50:	8a000315 	stw	r8,12(r17)
 820bc54:	8a000215 	stw	r8,8(r17)
 820bc58:	88e3883a 	add	r17,r17,r3
 820bc5c:	88c00015 	stw	r3,0(r17)
 820bc60:	9009883a 	mov	r4,r18
 820bc64:	82148640 	call	8214864 <__malloc_unlock>
 820bc68:	80800204 	addi	r2,r16,8
 820bc6c:	00001b06 	br	820bcdc <_malloc_r+0x2a4>
 820bc70:	04400404 	movi	r17,16
 820bc74:	89402536 	bltu	r17,r5,820bd0c <_malloc_r+0x2d4>
 820bc78:	82147440 	call	8214744 <__malloc_lock>
 820bc7c:	00800184 	movi	r2,6
 820bc80:	01000084 	movi	r4,2
 820bc84:	04c20974 	movhi	r19,2085
 820bc88:	1085883a 	add	r2,r2,r2
 820bc8c:	9cc84604 	addi	r19,r19,8472
 820bc90:	1085883a 	add	r2,r2,r2
 820bc94:	9885883a 	add	r2,r19,r2
 820bc98:	14000117 	ldw	r16,4(r2)
 820bc9c:	10fffe04 	addi	r3,r2,-8
 820bca0:	80c0d926 	beq	r16,r3,820c008 <_malloc_r+0x5d0>
 820bca4:	80c00117 	ldw	r3,4(r16)
 820bca8:	81000317 	ldw	r4,12(r16)
 820bcac:	00bfff04 	movi	r2,-4
 820bcb0:	1884703a 	and	r2,r3,r2
 820bcb4:	81400217 	ldw	r5,8(r16)
 820bcb8:	8085883a 	add	r2,r16,r2
 820bcbc:	10c00117 	ldw	r3,4(r2)
 820bcc0:	29000315 	stw	r4,12(r5)
 820bcc4:	21400215 	stw	r5,8(r4)
 820bcc8:	18c00054 	ori	r3,r3,1
 820bccc:	10c00115 	stw	r3,4(r2)
 820bcd0:	9009883a 	mov	r4,r18
 820bcd4:	82148640 	call	8214864 <__malloc_unlock>
 820bcd8:	80800204 	addi	r2,r16,8
 820bcdc:	dfc00a17 	ldw	ra,40(sp)
 820bce0:	df000917 	ldw	fp,36(sp)
 820bce4:	ddc00817 	ldw	r23,32(sp)
 820bce8:	dd800717 	ldw	r22,28(sp)
 820bcec:	dd400617 	ldw	r21,24(sp)
 820bcf0:	dd000517 	ldw	r20,20(sp)
 820bcf4:	dcc00417 	ldw	r19,16(sp)
 820bcf8:	dc800317 	ldw	r18,12(sp)
 820bcfc:	dc400217 	ldw	r17,8(sp)
 820bd00:	dc000117 	ldw	r16,4(sp)
 820bd04:	dec00b04 	addi	sp,sp,44
 820bd08:	f800283a 	ret
 820bd0c:	00800304 	movi	r2,12
 820bd10:	90800015 	stw	r2,0(r18)
 820bd14:	0005883a 	mov	r2,zero
 820bd18:	003ff006 	br	820bcdc <_malloc_r+0x2a4>
 820bd1c:	01002004 	movi	r4,128
 820bd20:	02001004 	movi	r8,64
 820bd24:	01c00fc4 	movi	r7,63
 820bd28:	003f6106 	br	820bab0 <_malloc_r+0x78>
 820bd2c:	4009883a 	mov	r4,r8
 820bd30:	003f7506 	br	820bb08 <_malloc_r+0xd0>
 820bd34:	81000317 	ldw	r4,12(r16)
 820bd38:	003fde06 	br	820bcb4 <_malloc_r+0x27c>
 820bd3c:	81c5883a 	add	r2,r16,r7
 820bd40:	11400117 	ldw	r5,4(r2)
 820bd44:	9009883a 	mov	r4,r18
 820bd48:	29400054 	ori	r5,r5,1
 820bd4c:	11400115 	stw	r5,4(r2)
 820bd50:	82148640 	call	8214864 <__malloc_unlock>
 820bd54:	80800204 	addi	r2,r16,8
 820bd58:	003fe006 	br	820bcdc <_malloc_r+0x2a4>
 820bd5c:	9c000217 	ldw	r16,8(r19)
 820bd60:	00bfff04 	movi	r2,-4
 820bd64:	85800117 	ldw	r22,4(r16)
 820bd68:	b0ac703a 	and	r22,r22,r2
 820bd6c:	b4400336 	bltu	r22,r17,820bd7c <_malloc_r+0x344>
 820bd70:	b445c83a 	sub	r2,r22,r17
 820bd74:	00c003c4 	movi	r3,15
 820bd78:	18805d16 	blt	r3,r2,820bef0 <_malloc_r+0x4b8>
 820bd7c:	05c20974 	movhi	r23,2085
 820bd80:	00820974 	movhi	r2,2085
 820bd84:	108f1804 	addi	r2,r2,15456
 820bd88:	bdceba04 	addi	r23,r23,15080
 820bd8c:	15400017 	ldw	r21,0(r2)
 820bd90:	b8c00017 	ldw	r3,0(r23)
 820bd94:	00bfffc4 	movi	r2,-1
 820bd98:	858d883a 	add	r6,r16,r22
 820bd9c:	8d6b883a 	add	r21,r17,r21
 820bda0:	1880ea26 	beq	r3,r2,820c14c <_malloc_r+0x714>
 820bda4:	ad4403c4 	addi	r21,r21,4111
 820bda8:	00bc0004 	movi	r2,-4096
 820bdac:	a8aa703a 	and	r21,r21,r2
 820bdb0:	a80b883a 	mov	r5,r21
 820bdb4:	9009883a 	mov	r4,r18
 820bdb8:	d9800015 	stw	r6,0(sp)
 820bdbc:	820db680 	call	820db68 <_sbrk_r>
 820bdc0:	1029883a 	mov	r20,r2
 820bdc4:	00bfffc4 	movi	r2,-1
 820bdc8:	d9800017 	ldw	r6,0(sp)
 820bdcc:	a080e826 	beq	r20,r2,820c170 <_malloc_r+0x738>
 820bdd0:	a180a636 	bltu	r20,r6,820c06c <_malloc_r+0x634>
 820bdd4:	07020974 	movhi	fp,2085
 820bdd8:	e7110f04 	addi	fp,fp,17468
 820bddc:	e0800017 	ldw	r2,0(fp)
 820bde0:	a887883a 	add	r3,r21,r2
 820bde4:	e0c00015 	stw	r3,0(fp)
 820bde8:	3500e626 	beq	r6,r20,820c184 <_malloc_r+0x74c>
 820bdec:	b9000017 	ldw	r4,0(r23)
 820bdf0:	00bfffc4 	movi	r2,-1
 820bdf4:	2080ee26 	beq	r4,r2,820c1b0 <_malloc_r+0x778>
 820bdf8:	a185c83a 	sub	r2,r20,r6
 820bdfc:	10c5883a 	add	r2,r2,r3
 820be00:	e0800015 	stw	r2,0(fp)
 820be04:	a0c001cc 	andi	r3,r20,7
 820be08:	1800bc26 	beq	r3,zero,820c0fc <_malloc_r+0x6c4>
 820be0c:	a0e9c83a 	sub	r20,r20,r3
 820be10:	00840204 	movi	r2,4104
 820be14:	a5000204 	addi	r20,r20,8
 820be18:	10c7c83a 	sub	r3,r2,r3
 820be1c:	a545883a 	add	r2,r20,r21
 820be20:	1083ffcc 	andi	r2,r2,4095
 820be24:	18abc83a 	sub	r21,r3,r2
 820be28:	a80b883a 	mov	r5,r21
 820be2c:	9009883a 	mov	r4,r18
 820be30:	820db680 	call	820db68 <_sbrk_r>
 820be34:	00ffffc4 	movi	r3,-1
 820be38:	10c0e126 	beq	r2,r3,820c1c0 <_malloc_r+0x788>
 820be3c:	1505c83a 	sub	r2,r2,r20
 820be40:	1545883a 	add	r2,r2,r21
 820be44:	10800054 	ori	r2,r2,1
 820be48:	e0c00017 	ldw	r3,0(fp)
 820be4c:	9d000215 	stw	r20,8(r19)
 820be50:	a0800115 	stw	r2,4(r20)
 820be54:	a8c7883a 	add	r3,r21,r3
 820be58:	e0c00015 	stw	r3,0(fp)
 820be5c:	84c00e26 	beq	r16,r19,820be98 <_malloc_r+0x460>
 820be60:	018003c4 	movi	r6,15
 820be64:	3580a72e 	bgeu	r6,r22,820c104 <_malloc_r+0x6cc>
 820be68:	81400117 	ldw	r5,4(r16)
 820be6c:	013ffe04 	movi	r4,-8
 820be70:	b0bffd04 	addi	r2,r22,-12
 820be74:	1104703a 	and	r2,r2,r4
 820be78:	2900004c 	andi	r4,r5,1
 820be7c:	2088b03a 	or	r4,r4,r2
 820be80:	81000115 	stw	r4,4(r16)
 820be84:	01400144 	movi	r5,5
 820be88:	8089883a 	add	r4,r16,r2
 820be8c:	21400115 	stw	r5,4(r4)
 820be90:	21400215 	stw	r5,8(r4)
 820be94:	3080cd36 	bltu	r6,r2,820c1cc <_malloc_r+0x794>
 820be98:	00820974 	movhi	r2,2085
 820be9c:	108f1704 	addi	r2,r2,15452
 820bea0:	11000017 	ldw	r4,0(r2)
 820bea4:	20c0012e 	bgeu	r4,r3,820beac <_malloc_r+0x474>
 820bea8:	10c00015 	stw	r3,0(r2)
 820beac:	00820974 	movhi	r2,2085
 820beb0:	108f1604 	addi	r2,r2,15448
 820beb4:	11000017 	ldw	r4,0(r2)
 820beb8:	9c000217 	ldw	r16,8(r19)
 820bebc:	20c0012e 	bgeu	r4,r3,820bec4 <_malloc_r+0x48c>
 820bec0:	10c00015 	stw	r3,0(r2)
 820bec4:	80c00117 	ldw	r3,4(r16)
 820bec8:	00bfff04 	movi	r2,-4
 820becc:	1886703a 	and	r3,r3,r2
 820bed0:	1c45c83a 	sub	r2,r3,r17
 820bed4:	1c400236 	bltu	r3,r17,820bee0 <_malloc_r+0x4a8>
 820bed8:	00c003c4 	movi	r3,15
 820bedc:	18800416 	blt	r3,r2,820bef0 <_malloc_r+0x4b8>
 820bee0:	9009883a 	mov	r4,r18
 820bee4:	82148640 	call	8214864 <__malloc_unlock>
 820bee8:	0005883a 	mov	r2,zero
 820beec:	003f7b06 	br	820bcdc <_malloc_r+0x2a4>
 820bef0:	88c00054 	ori	r3,r17,1
 820bef4:	80c00115 	stw	r3,4(r16)
 820bef8:	8463883a 	add	r17,r16,r17
 820befc:	10800054 	ori	r2,r2,1
 820bf00:	9c400215 	stw	r17,8(r19)
 820bf04:	88800115 	stw	r2,4(r17)
 820bf08:	9009883a 	mov	r4,r18
 820bf0c:	82148640 	call	8214864 <__malloc_unlock>
 820bf10:	80800204 	addi	r2,r16,8
 820bf14:	003f7106 	br	820bcdc <_malloc_r+0x2a4>
 820bf18:	00c00504 	movi	r3,20
 820bf1c:	18804a2e 	bgeu	r3,r2,820c048 <_malloc_r+0x610>
 820bf20:	00c01504 	movi	r3,84
 820bf24:	18806e36 	bltu	r3,r2,820c0e0 <_malloc_r+0x6a8>
 820bf28:	8804d33a 	srli	r2,r17,12
 820bf2c:	12001bc4 	addi	r8,r2,111
 820bf30:	11c01b84 	addi	r7,r2,110
 820bf34:	4209883a 	add	r4,r8,r8
 820bf38:	003edd06 	br	820bab0 <_malloc_r+0x78>
 820bf3c:	3804d27a 	srli	r2,r7,9
 820bf40:	00c00104 	movi	r3,4
 820bf44:	1880442e 	bgeu	r3,r2,820c058 <_malloc_r+0x620>
 820bf48:	00c00504 	movi	r3,20
 820bf4c:	18808136 	bltu	r3,r2,820c154 <_malloc_r+0x71c>
 820bf50:	11401704 	addi	r5,r2,92
 820bf54:	10c016c4 	addi	r3,r2,91
 820bf58:	294b883a 	add	r5,r5,r5
 820bf5c:	294b883a 	add	r5,r5,r5
 820bf60:	294b883a 	add	r5,r5,r5
 820bf64:	994b883a 	add	r5,r19,r5
 820bf68:	28800017 	ldw	r2,0(r5)
 820bf6c:	01820974 	movhi	r6,2085
 820bf70:	297ffe04 	addi	r5,r5,-8
 820bf74:	31884604 	addi	r6,r6,8472
 820bf78:	28806526 	beq	r5,r2,820c110 <_malloc_r+0x6d8>
 820bf7c:	01bfff04 	movi	r6,-4
 820bf80:	10c00117 	ldw	r3,4(r2)
 820bf84:	1986703a 	and	r3,r3,r6
 820bf88:	38c0022e 	bgeu	r7,r3,820bf94 <_malloc_r+0x55c>
 820bf8c:	10800217 	ldw	r2,8(r2)
 820bf90:	28bffb1e 	bne	r5,r2,820bf80 <_malloc_r+0x548>
 820bf94:	11400317 	ldw	r5,12(r2)
 820bf98:	98c00117 	ldw	r3,4(r19)
 820bf9c:	81400315 	stw	r5,12(r16)
 820bfa0:	80800215 	stw	r2,8(r16)
 820bfa4:	2c000215 	stw	r16,8(r5)
 820bfa8:	14000315 	stw	r16,12(r2)
 820bfac:	003ef806 	br	820bb90 <_malloc_r+0x158>
 820bfb0:	88c00054 	ori	r3,r17,1
 820bfb4:	80c00115 	stw	r3,4(r16)
 820bfb8:	8463883a 	add	r17,r16,r17
 820bfbc:	34400515 	stw	r17,20(r6)
 820bfc0:	34400415 	stw	r17,16(r6)
 820bfc4:	10c00054 	ori	r3,r2,1
 820bfc8:	8a000315 	stw	r8,12(r17)
 820bfcc:	8a000215 	stw	r8,8(r17)
 820bfd0:	88c00115 	stw	r3,4(r17)
 820bfd4:	88a3883a 	add	r17,r17,r2
 820bfd8:	88800015 	stw	r2,0(r17)
 820bfdc:	9009883a 	mov	r4,r18
 820bfe0:	82148640 	call	8214864 <__malloc_unlock>
 820bfe4:	80800204 	addi	r2,r16,8
 820bfe8:	003f3c06 	br	820bcdc <_malloc_r+0x2a4>
 820bfec:	30c00117 	ldw	r3,4(r6)
 820bff0:	003ee706 	br	820bb90 <_malloc_r+0x158>
 820bff4:	5ac00044 	addi	r11,r11,1
 820bff8:	588000cc 	andi	r2,r11,3
 820bffc:	31800204 	addi	r6,r6,8
 820c000:	103efd1e 	bne	r2,zero,820bbf8 <_malloc_r+0x1c0>
 820c004:	00002406 	br	820c098 <_malloc_r+0x660>
 820c008:	14000317 	ldw	r16,12(r2)
 820c00c:	143f251e 	bne	r2,r16,820bca4 <_malloc_r+0x26c>
 820c010:	21000084 	addi	r4,r4,2
 820c014:	003ebc06 	br	820bb08 <_malloc_r+0xd0>
 820c018:	8085883a 	add	r2,r16,r2
 820c01c:	10c00117 	ldw	r3,4(r2)
 820c020:	81000317 	ldw	r4,12(r16)
 820c024:	81400217 	ldw	r5,8(r16)
 820c028:	18c00054 	ori	r3,r3,1
 820c02c:	10c00115 	stw	r3,4(r2)
 820c030:	29000315 	stw	r4,12(r5)
 820c034:	21400215 	stw	r5,8(r4)
 820c038:	9009883a 	mov	r4,r18
 820c03c:	82148640 	call	8214864 <__malloc_unlock>
 820c040:	80800204 	addi	r2,r16,8
 820c044:	003f2506 	br	820bcdc <_malloc_r+0x2a4>
 820c048:	12001704 	addi	r8,r2,92
 820c04c:	11c016c4 	addi	r7,r2,91
 820c050:	4209883a 	add	r4,r8,r8
 820c054:	003e9606 	br	820bab0 <_malloc_r+0x78>
 820c058:	3804d1ba 	srli	r2,r7,6
 820c05c:	11400e44 	addi	r5,r2,57
 820c060:	10c00e04 	addi	r3,r2,56
 820c064:	294b883a 	add	r5,r5,r5
 820c068:	003fbc06 	br	820bf5c <_malloc_r+0x524>
 820c06c:	84ff5926 	beq	r16,r19,820bdd4 <_malloc_r+0x39c>
 820c070:	00820974 	movhi	r2,2085
 820c074:	10884604 	addi	r2,r2,8472
 820c078:	14000217 	ldw	r16,8(r2)
 820c07c:	00bfff04 	movi	r2,-4
 820c080:	80c00117 	ldw	r3,4(r16)
 820c084:	1886703a 	and	r3,r3,r2
 820c088:	003f9106 	br	820bed0 <_malloc_r+0x498>
 820c08c:	60800217 	ldw	r2,8(r12)
 820c090:	213fffc4 	addi	r4,r4,-1
 820c094:	1300651e 	bne	r2,r12,820c22c <_malloc_r+0x7f4>
 820c098:	208000cc 	andi	r2,r4,3
 820c09c:	633ffe04 	addi	r12,r12,-8
 820c0a0:	103ffa1e 	bne	r2,zero,820c08c <_malloc_r+0x654>
 820c0a4:	98800117 	ldw	r2,4(r19)
 820c0a8:	0146303a 	nor	r3,zero,r5
 820c0ac:	1884703a 	and	r2,r3,r2
 820c0b0:	98800115 	stw	r2,4(r19)
 820c0b4:	294b883a 	add	r5,r5,r5
 820c0b8:	117f2836 	bltu	r2,r5,820bd5c <_malloc_r+0x324>
 820c0bc:	283f2726 	beq	r5,zero,820bd5c <_malloc_r+0x324>
 820c0c0:	2886703a 	and	r3,r5,r2
 820c0c4:	5809883a 	mov	r4,r11
 820c0c8:	183ec31e 	bne	r3,zero,820bbd8 <_malloc_r+0x1a0>
 820c0cc:	294b883a 	add	r5,r5,r5
 820c0d0:	2886703a 	and	r3,r5,r2
 820c0d4:	21000104 	addi	r4,r4,4
 820c0d8:	183ffc26 	beq	r3,zero,820c0cc <_malloc_r+0x694>
 820c0dc:	003ebe06 	br	820bbd8 <_malloc_r+0x1a0>
 820c0e0:	00c05504 	movi	r3,340
 820c0e4:	18801236 	bltu	r3,r2,820c130 <_malloc_r+0x6f8>
 820c0e8:	8804d3fa 	srli	r2,r17,15
 820c0ec:	12001e04 	addi	r8,r2,120
 820c0f0:	11c01dc4 	addi	r7,r2,119
 820c0f4:	4209883a 	add	r4,r8,r8
 820c0f8:	003e6d06 	br	820bab0 <_malloc_r+0x78>
 820c0fc:	00c40004 	movi	r3,4096
 820c100:	003f4606 	br	820be1c <_malloc_r+0x3e4>
 820c104:	00800044 	movi	r2,1
 820c108:	a0800115 	stw	r2,4(r20)
 820c10c:	003f7406 	br	820bee0 <_malloc_r+0x4a8>
 820c110:	1805d0ba 	srai	r2,r3,2
 820c114:	01c00044 	movi	r7,1
 820c118:	30c00117 	ldw	r3,4(r6)
 820c11c:	388e983a 	sll	r7,r7,r2
 820c120:	2805883a 	mov	r2,r5
 820c124:	38c6b03a 	or	r3,r7,r3
 820c128:	30c00115 	stw	r3,4(r6)
 820c12c:	003f9b06 	br	820bf9c <_malloc_r+0x564>
 820c130:	00c15504 	movi	r3,1364
 820c134:	18801a36 	bltu	r3,r2,820c1a0 <_malloc_r+0x768>
 820c138:	8804d4ba 	srli	r2,r17,18
 820c13c:	12001f44 	addi	r8,r2,125
 820c140:	11c01f04 	addi	r7,r2,124
 820c144:	4209883a 	add	r4,r8,r8
 820c148:	003e5906 	br	820bab0 <_malloc_r+0x78>
 820c14c:	ad400404 	addi	r21,r21,16
 820c150:	003f1706 	br	820bdb0 <_malloc_r+0x378>
 820c154:	00c01504 	movi	r3,84
 820c158:	18802336 	bltu	r3,r2,820c1e8 <_malloc_r+0x7b0>
 820c15c:	3804d33a 	srli	r2,r7,12
 820c160:	11401bc4 	addi	r5,r2,111
 820c164:	10c01b84 	addi	r3,r2,110
 820c168:	294b883a 	add	r5,r5,r5
 820c16c:	003f7b06 	br	820bf5c <_malloc_r+0x524>
 820c170:	9c000217 	ldw	r16,8(r19)
 820c174:	00bfff04 	movi	r2,-4
 820c178:	80c00117 	ldw	r3,4(r16)
 820c17c:	1886703a 	and	r3,r3,r2
 820c180:	003f5306 	br	820bed0 <_malloc_r+0x498>
 820c184:	3083ffcc 	andi	r2,r6,4095
 820c188:	103f181e 	bne	r2,zero,820bdec <_malloc_r+0x3b4>
 820c18c:	99000217 	ldw	r4,8(r19)
 820c190:	b545883a 	add	r2,r22,r21
 820c194:	10800054 	ori	r2,r2,1
 820c198:	20800115 	stw	r2,4(r4)
 820c19c:	003f3e06 	br	820be98 <_malloc_r+0x460>
 820c1a0:	01003f84 	movi	r4,254
 820c1a4:	02001fc4 	movi	r8,127
 820c1a8:	01c01f84 	movi	r7,126
 820c1ac:	003e4006 	br	820bab0 <_malloc_r+0x78>
 820c1b0:	00820974 	movhi	r2,2085
 820c1b4:	108eba04 	addi	r2,r2,15080
 820c1b8:	15000015 	stw	r20,0(r2)
 820c1bc:	003f1106 	br	820be04 <_malloc_r+0x3cc>
 820c1c0:	00800044 	movi	r2,1
 820c1c4:	002b883a 	mov	r21,zero
 820c1c8:	003f1f06 	br	820be48 <_malloc_r+0x410>
 820c1cc:	81400204 	addi	r5,r16,8
 820c1d0:	9009883a 	mov	r4,r18
 820c1d4:	820ae4c0 	call	820ae4c <_free_r>
 820c1d8:	00820974 	movhi	r2,2085
 820c1dc:	10910f04 	addi	r2,r2,17468
 820c1e0:	10c00017 	ldw	r3,0(r2)
 820c1e4:	003f2c06 	br	820be98 <_malloc_r+0x460>
 820c1e8:	00c05504 	movi	r3,340
 820c1ec:	18800536 	bltu	r3,r2,820c204 <_malloc_r+0x7cc>
 820c1f0:	3804d3fa 	srli	r2,r7,15
 820c1f4:	11401e04 	addi	r5,r2,120
 820c1f8:	10c01dc4 	addi	r3,r2,119
 820c1fc:	294b883a 	add	r5,r5,r5
 820c200:	003f5606 	br	820bf5c <_malloc_r+0x524>
 820c204:	00c15504 	movi	r3,1364
 820c208:	18800536 	bltu	r3,r2,820c220 <_malloc_r+0x7e8>
 820c20c:	3804d4ba 	srli	r2,r7,18
 820c210:	11401f44 	addi	r5,r2,125
 820c214:	10c01f04 	addi	r3,r2,124
 820c218:	294b883a 	add	r5,r5,r5
 820c21c:	003f4f06 	br	820bf5c <_malloc_r+0x524>
 820c220:	01403f84 	movi	r5,254
 820c224:	00c01f84 	movi	r3,126
 820c228:	003f4c06 	br	820bf5c <_malloc_r+0x524>
 820c22c:	98800117 	ldw	r2,4(r19)
 820c230:	003fa006 	br	820c0b4 <_malloc_r+0x67c>
 820c234:	8808d0fa 	srli	r4,r17,3
 820c238:	20800044 	addi	r2,r4,1
 820c23c:	1085883a 	add	r2,r2,r2
 820c240:	003e9006 	br	820bc84 <_malloc_r+0x24c>

0820c244 <memchr>:
 820c244:	208000cc 	andi	r2,r4,3
 820c248:	280f883a 	mov	r7,r5
 820c24c:	10003426 	beq	r2,zero,820c320 <memchr+0xdc>
 820c250:	30bfffc4 	addi	r2,r6,-1
 820c254:	30001a26 	beq	r6,zero,820c2c0 <memchr+0x7c>
 820c258:	20c00003 	ldbu	r3,0(r4)
 820c25c:	29803fcc 	andi	r6,r5,255
 820c260:	30c0051e 	bne	r6,r3,820c278 <memchr+0x34>
 820c264:	00001806 	br	820c2c8 <memchr+0x84>
 820c268:	10001526 	beq	r2,zero,820c2c0 <memchr+0x7c>
 820c26c:	20c00003 	ldbu	r3,0(r4)
 820c270:	10bfffc4 	addi	r2,r2,-1
 820c274:	30c01426 	beq	r6,r3,820c2c8 <memchr+0x84>
 820c278:	21000044 	addi	r4,r4,1
 820c27c:	20c000cc 	andi	r3,r4,3
 820c280:	183ff91e 	bne	r3,zero,820c268 <memchr+0x24>
 820c284:	020000c4 	movi	r8,3
 820c288:	40801136 	bltu	r8,r2,820c2d0 <memchr+0x8c>
 820c28c:	10000c26 	beq	r2,zero,820c2c0 <memchr+0x7c>
 820c290:	20c00003 	ldbu	r3,0(r4)
 820c294:	29403fcc 	andi	r5,r5,255
 820c298:	28c00b26 	beq	r5,r3,820c2c8 <memchr+0x84>
 820c29c:	20c00044 	addi	r3,r4,1
 820c2a0:	39803fcc 	andi	r6,r7,255
 820c2a4:	2089883a 	add	r4,r4,r2
 820c2a8:	00000306 	br	820c2b8 <memchr+0x74>
 820c2ac:	18c00044 	addi	r3,r3,1
 820c2b0:	197fffc3 	ldbu	r5,-1(r3)
 820c2b4:	31400526 	beq	r6,r5,820c2cc <memchr+0x88>
 820c2b8:	1805883a 	mov	r2,r3
 820c2bc:	20fffb1e 	bne	r4,r3,820c2ac <memchr+0x68>
 820c2c0:	0005883a 	mov	r2,zero
 820c2c4:	f800283a 	ret
 820c2c8:	2005883a 	mov	r2,r4
 820c2cc:	f800283a 	ret
 820c2d0:	28c03fcc 	andi	r3,r5,255
 820c2d4:	1812923a 	slli	r9,r3,8
 820c2d8:	02ffbff4 	movhi	r11,65279
 820c2dc:	02a02074 	movhi	r10,32897
 820c2e0:	48d2b03a 	or	r9,r9,r3
 820c2e4:	4806943a 	slli	r3,r9,16
 820c2e8:	5affbfc4 	addi	r11,r11,-257
 820c2ec:	52a02004 	addi	r10,r10,-32640
 820c2f0:	48d2b03a 	or	r9,r9,r3
 820c2f4:	20c00017 	ldw	r3,0(r4)
 820c2f8:	48c6f03a 	xor	r3,r9,r3
 820c2fc:	1acd883a 	add	r6,r3,r11
 820c300:	00c6303a 	nor	r3,zero,r3
 820c304:	30c6703a 	and	r3,r6,r3
 820c308:	1a86703a 	and	r3,r3,r10
 820c30c:	183fe01e 	bne	r3,zero,820c290 <memchr+0x4c>
 820c310:	10bfff04 	addi	r2,r2,-4
 820c314:	21000104 	addi	r4,r4,4
 820c318:	40bff636 	bltu	r8,r2,820c2f4 <memchr+0xb0>
 820c31c:	003fdb06 	br	820c28c <memchr+0x48>
 820c320:	3005883a 	mov	r2,r6
 820c324:	003fd706 	br	820c284 <memchr+0x40>

0820c328 <memcmp>:
 820c328:	01c000c4 	movi	r7,3
 820c32c:	3980192e 	bgeu	r7,r6,820c394 <memcmp+0x6c>
 820c330:	2144b03a 	or	r2,r4,r5
 820c334:	11c4703a 	and	r2,r2,r7
 820c338:	10000f26 	beq	r2,zero,820c378 <memcmp+0x50>
 820c33c:	20800003 	ldbu	r2,0(r4)
 820c340:	28c00003 	ldbu	r3,0(r5)
 820c344:	10c0151e 	bne	r2,r3,820c39c <memcmp+0x74>
 820c348:	31bfff84 	addi	r6,r6,-2
 820c34c:	01ffffc4 	movi	r7,-1
 820c350:	00000406 	br	820c364 <memcmp+0x3c>
 820c354:	20800003 	ldbu	r2,0(r4)
 820c358:	28c00003 	ldbu	r3,0(r5)
 820c35c:	31bfffc4 	addi	r6,r6,-1
 820c360:	10c00e1e 	bne	r2,r3,820c39c <memcmp+0x74>
 820c364:	21000044 	addi	r4,r4,1
 820c368:	29400044 	addi	r5,r5,1
 820c36c:	31fff91e 	bne	r6,r7,820c354 <memcmp+0x2c>
 820c370:	0005883a 	mov	r2,zero
 820c374:	f800283a 	ret
 820c378:	20c00017 	ldw	r3,0(r4)
 820c37c:	28800017 	ldw	r2,0(r5)
 820c380:	18bfee1e 	bne	r3,r2,820c33c <memcmp+0x14>
 820c384:	31bfff04 	addi	r6,r6,-4
 820c388:	21000104 	addi	r4,r4,4
 820c38c:	29400104 	addi	r5,r5,4
 820c390:	39bff936 	bltu	r7,r6,820c378 <memcmp+0x50>
 820c394:	303fe91e 	bne	r6,zero,820c33c <memcmp+0x14>
 820c398:	003ff506 	br	820c370 <memcmp+0x48>
 820c39c:	10c5c83a 	sub	r2,r2,r3
 820c3a0:	f800283a 	ret

0820c3a4 <_Balloc>:
 820c3a4:	20801317 	ldw	r2,76(r4)
 820c3a8:	defffc04 	addi	sp,sp,-16
 820c3ac:	dc400115 	stw	r17,4(sp)
 820c3b0:	dc000015 	stw	r16,0(sp)
 820c3b4:	dfc00315 	stw	ra,12(sp)
 820c3b8:	dc800215 	stw	r18,8(sp)
 820c3bc:	2023883a 	mov	r17,r4
 820c3c0:	2821883a 	mov	r16,r5
 820c3c4:	10000f26 	beq	r2,zero,820c404 <_Balloc+0x60>
 820c3c8:	8407883a 	add	r3,r16,r16
 820c3cc:	18c7883a 	add	r3,r3,r3
 820c3d0:	10c7883a 	add	r3,r2,r3
 820c3d4:	18800017 	ldw	r2,0(r3)
 820c3d8:	10001126 	beq	r2,zero,820c420 <_Balloc+0x7c>
 820c3dc:	11000017 	ldw	r4,0(r2)
 820c3e0:	19000015 	stw	r4,0(r3)
 820c3e4:	10000415 	stw	zero,16(r2)
 820c3e8:	10000315 	stw	zero,12(r2)
 820c3ec:	dfc00317 	ldw	ra,12(sp)
 820c3f0:	dc800217 	ldw	r18,8(sp)
 820c3f4:	dc400117 	ldw	r17,4(sp)
 820c3f8:	dc000017 	ldw	r16,0(sp)
 820c3fc:	dec00404 	addi	sp,sp,16
 820c400:	f800283a 	ret
 820c404:	01800844 	movi	r6,33
 820c408:	01400104 	movi	r5,4
 820c40c:	82108dc0 	call	82108dc <_calloc_r>
 820c410:	88801315 	stw	r2,76(r17)
 820c414:	103fec1e 	bne	r2,zero,820c3c8 <_Balloc+0x24>
 820c418:	0005883a 	mov	r2,zero
 820c41c:	003ff306 	br	820c3ec <_Balloc+0x48>
 820c420:	01400044 	movi	r5,1
 820c424:	2c24983a 	sll	r18,r5,r16
 820c428:	8809883a 	mov	r4,r17
 820c42c:	91800144 	addi	r6,r18,5
 820c430:	318d883a 	add	r6,r6,r6
 820c434:	318d883a 	add	r6,r6,r6
 820c438:	82108dc0 	call	82108dc <_calloc_r>
 820c43c:	103ff626 	beq	r2,zero,820c418 <_Balloc+0x74>
 820c440:	14000115 	stw	r16,4(r2)
 820c444:	14800215 	stw	r18,8(r2)
 820c448:	003fe606 	br	820c3e4 <_Balloc+0x40>

0820c44c <_Bfree>:
 820c44c:	28000826 	beq	r5,zero,820c470 <_Bfree+0x24>
 820c450:	28c00117 	ldw	r3,4(r5)
 820c454:	20801317 	ldw	r2,76(r4)
 820c458:	18c7883a 	add	r3,r3,r3
 820c45c:	18c7883a 	add	r3,r3,r3
 820c460:	10c5883a 	add	r2,r2,r3
 820c464:	10c00017 	ldw	r3,0(r2)
 820c468:	28c00015 	stw	r3,0(r5)
 820c46c:	11400015 	stw	r5,0(r2)
 820c470:	f800283a 	ret

0820c474 <__multadd>:
 820c474:	defffa04 	addi	sp,sp,-24
 820c478:	dc800315 	stw	r18,12(sp)
 820c47c:	dc400215 	stw	r17,8(sp)
 820c480:	dc000115 	stw	r16,4(sp)
 820c484:	2823883a 	mov	r17,r5
 820c488:	2c000417 	ldw	r16,16(r5)
 820c48c:	dfc00515 	stw	ra,20(sp)
 820c490:	dcc00415 	stw	r19,16(sp)
 820c494:	2025883a 	mov	r18,r4
 820c498:	29400504 	addi	r5,r5,20
 820c49c:	0011883a 	mov	r8,zero
 820c4a0:	28c00017 	ldw	r3,0(r5)
 820c4a4:	29400104 	addi	r5,r5,4
 820c4a8:	42000044 	addi	r8,r8,1
 820c4ac:	18bfffcc 	andi	r2,r3,65535
 820c4b0:	1185383a 	mul	r2,r2,r6
 820c4b4:	1806d43a 	srli	r3,r3,16
 820c4b8:	11cf883a 	add	r7,r2,r7
 820c4bc:	3808d43a 	srli	r4,r7,16
 820c4c0:	1987383a 	mul	r3,r3,r6
 820c4c4:	38bfffcc 	andi	r2,r7,65535
 820c4c8:	1907883a 	add	r3,r3,r4
 820c4cc:	1808943a 	slli	r4,r3,16
 820c4d0:	180ed43a 	srli	r7,r3,16
 820c4d4:	2085883a 	add	r2,r4,r2
 820c4d8:	28bfff15 	stw	r2,-4(r5)
 820c4dc:	443ff016 	blt	r8,r16,820c4a0 <__multadd+0x2c>
 820c4e0:	38000926 	beq	r7,zero,820c508 <__multadd+0x94>
 820c4e4:	88800217 	ldw	r2,8(r17)
 820c4e8:	80800f0e 	bge	r16,r2,820c528 <__multadd+0xb4>
 820c4ec:	80800144 	addi	r2,r16,5
 820c4f0:	1085883a 	add	r2,r2,r2
 820c4f4:	1085883a 	add	r2,r2,r2
 820c4f8:	8885883a 	add	r2,r17,r2
 820c4fc:	11c00015 	stw	r7,0(r2)
 820c500:	84000044 	addi	r16,r16,1
 820c504:	8c000415 	stw	r16,16(r17)
 820c508:	8805883a 	mov	r2,r17
 820c50c:	dfc00517 	ldw	ra,20(sp)
 820c510:	dcc00417 	ldw	r19,16(sp)
 820c514:	dc800317 	ldw	r18,12(sp)
 820c518:	dc400217 	ldw	r17,8(sp)
 820c51c:	dc000117 	ldw	r16,4(sp)
 820c520:	dec00604 	addi	sp,sp,24
 820c524:	f800283a 	ret
 820c528:	89400117 	ldw	r5,4(r17)
 820c52c:	9009883a 	mov	r4,r18
 820c530:	d9c00015 	stw	r7,0(sp)
 820c534:	29400044 	addi	r5,r5,1
 820c538:	820c3a40 	call	820c3a4 <_Balloc>
 820c53c:	89800417 	ldw	r6,16(r17)
 820c540:	89400304 	addi	r5,r17,12
 820c544:	11000304 	addi	r4,r2,12
 820c548:	31800084 	addi	r6,r6,2
 820c54c:	318d883a 	add	r6,r6,r6
 820c550:	318d883a 	add	r6,r6,r6
 820c554:	1027883a 	mov	r19,r2
 820c558:	8202c5c0 	call	8202c5c <memcpy>
 820c55c:	d9c00017 	ldw	r7,0(sp)
 820c560:	88000a26 	beq	r17,zero,820c58c <__multadd+0x118>
 820c564:	88c00117 	ldw	r3,4(r17)
 820c568:	90801317 	ldw	r2,76(r18)
 820c56c:	18c7883a 	add	r3,r3,r3
 820c570:	18c7883a 	add	r3,r3,r3
 820c574:	10c5883a 	add	r2,r2,r3
 820c578:	10c00017 	ldw	r3,0(r2)
 820c57c:	88c00015 	stw	r3,0(r17)
 820c580:	14400015 	stw	r17,0(r2)
 820c584:	9823883a 	mov	r17,r19
 820c588:	003fd806 	br	820c4ec <__multadd+0x78>
 820c58c:	9823883a 	mov	r17,r19
 820c590:	003fd606 	br	820c4ec <__multadd+0x78>

0820c594 <__s2b>:
 820c594:	defff904 	addi	sp,sp,-28
 820c598:	dc400115 	stw	r17,4(sp)
 820c59c:	dc000015 	stw	r16,0(sp)
 820c5a0:	2023883a 	mov	r17,r4
 820c5a4:	2821883a 	mov	r16,r5
 820c5a8:	39000204 	addi	r4,r7,8
 820c5ac:	01400244 	movi	r5,9
 820c5b0:	dcc00315 	stw	r19,12(sp)
 820c5b4:	dc800215 	stw	r18,8(sp)
 820c5b8:	dfc00615 	stw	ra,24(sp)
 820c5bc:	dd400515 	stw	r21,20(sp)
 820c5c0:	dd000415 	stw	r20,16(sp)
 820c5c4:	3825883a 	mov	r18,r7
 820c5c8:	3027883a 	mov	r19,r6
 820c5cc:	82028640 	call	8202864 <__divsi3>
 820c5d0:	00c00044 	movi	r3,1
 820c5d4:	000b883a 	mov	r5,zero
 820c5d8:	1880030e 	bge	r3,r2,820c5e8 <__s2b+0x54>
 820c5dc:	18c7883a 	add	r3,r3,r3
 820c5e0:	29400044 	addi	r5,r5,1
 820c5e4:	18bffd16 	blt	r3,r2,820c5dc <__s2b+0x48>
 820c5e8:	8809883a 	mov	r4,r17
 820c5ec:	820c3a40 	call	820c3a4 <_Balloc>
 820c5f0:	d8c00717 	ldw	r3,28(sp)
 820c5f4:	10c00515 	stw	r3,20(r2)
 820c5f8:	00c00044 	movi	r3,1
 820c5fc:	10c00415 	stw	r3,16(r2)
 820c600:	00c00244 	movi	r3,9
 820c604:	1cc0210e 	bge	r3,r19,820c68c <__s2b+0xf8>
 820c608:	80eb883a 	add	r21,r16,r3
 820c60c:	a829883a 	mov	r20,r21
 820c610:	84e1883a 	add	r16,r16,r19
 820c614:	a1c00007 	ldb	r7,0(r20)
 820c618:	01800284 	movi	r6,10
 820c61c:	a5000044 	addi	r20,r20,1
 820c620:	100b883a 	mov	r5,r2
 820c624:	39fff404 	addi	r7,r7,-48
 820c628:	8809883a 	mov	r4,r17
 820c62c:	820c4740 	call	820c474 <__multadd>
 820c630:	a43ff81e 	bne	r20,r16,820c614 <__s2b+0x80>
 820c634:	ace1883a 	add	r16,r21,r19
 820c638:	843ffe04 	addi	r16,r16,-8
 820c63c:	9c800a0e 	bge	r19,r18,820c668 <__s2b+0xd4>
 820c640:	94e5c83a 	sub	r18,r18,r19
 820c644:	84a5883a 	add	r18,r16,r18
 820c648:	81c00007 	ldb	r7,0(r16)
 820c64c:	01800284 	movi	r6,10
 820c650:	84000044 	addi	r16,r16,1
 820c654:	100b883a 	mov	r5,r2
 820c658:	39fff404 	addi	r7,r7,-48
 820c65c:	8809883a 	mov	r4,r17
 820c660:	820c4740 	call	820c474 <__multadd>
 820c664:	84bff81e 	bne	r16,r18,820c648 <__s2b+0xb4>
 820c668:	dfc00617 	ldw	ra,24(sp)
 820c66c:	dd400517 	ldw	r21,20(sp)
 820c670:	dd000417 	ldw	r20,16(sp)
 820c674:	dcc00317 	ldw	r19,12(sp)
 820c678:	dc800217 	ldw	r18,8(sp)
 820c67c:	dc400117 	ldw	r17,4(sp)
 820c680:	dc000017 	ldw	r16,0(sp)
 820c684:	dec00704 	addi	sp,sp,28
 820c688:	f800283a 	ret
 820c68c:	84000284 	addi	r16,r16,10
 820c690:	1827883a 	mov	r19,r3
 820c694:	003fe906 	br	820c63c <__s2b+0xa8>

0820c698 <__hi0bits>:
 820c698:	20bfffec 	andhi	r2,r4,65535
 820c69c:	1000141e 	bne	r2,zero,820c6f0 <__hi0bits+0x58>
 820c6a0:	2008943a 	slli	r4,r4,16
 820c6a4:	00800404 	movi	r2,16
 820c6a8:	20ffc02c 	andhi	r3,r4,65280
 820c6ac:	1800021e 	bne	r3,zero,820c6b8 <__hi0bits+0x20>
 820c6b0:	2008923a 	slli	r4,r4,8
 820c6b4:	10800204 	addi	r2,r2,8
 820c6b8:	20fc002c 	andhi	r3,r4,61440
 820c6bc:	1800021e 	bne	r3,zero,820c6c8 <__hi0bits+0x30>
 820c6c0:	2008913a 	slli	r4,r4,4
 820c6c4:	10800104 	addi	r2,r2,4
 820c6c8:	20f0002c 	andhi	r3,r4,49152
 820c6cc:	1800031e 	bne	r3,zero,820c6dc <__hi0bits+0x44>
 820c6d0:	2109883a 	add	r4,r4,r4
 820c6d4:	10800084 	addi	r2,r2,2
 820c6d8:	2109883a 	add	r4,r4,r4
 820c6dc:	20000316 	blt	r4,zero,820c6ec <__hi0bits+0x54>
 820c6e0:	2110002c 	andhi	r4,r4,16384
 820c6e4:	2000041e 	bne	r4,zero,820c6f8 <__hi0bits+0x60>
 820c6e8:	00800804 	movi	r2,32
 820c6ec:	f800283a 	ret
 820c6f0:	0005883a 	mov	r2,zero
 820c6f4:	003fec06 	br	820c6a8 <__hi0bits+0x10>
 820c6f8:	10800044 	addi	r2,r2,1
 820c6fc:	f800283a 	ret

0820c700 <__lo0bits>:
 820c700:	20c00017 	ldw	r3,0(r4)
 820c704:	188001cc 	andi	r2,r3,7
 820c708:	10000826 	beq	r2,zero,820c72c <__lo0bits+0x2c>
 820c70c:	1880004c 	andi	r2,r3,1
 820c710:	1000211e 	bne	r2,zero,820c798 <__lo0bits+0x98>
 820c714:	1880008c 	andi	r2,r3,2
 820c718:	1000211e 	bne	r2,zero,820c7a0 <__lo0bits+0xa0>
 820c71c:	1806d0ba 	srli	r3,r3,2
 820c720:	00800084 	movi	r2,2
 820c724:	20c00015 	stw	r3,0(r4)
 820c728:	f800283a 	ret
 820c72c:	18bfffcc 	andi	r2,r3,65535
 820c730:	10001326 	beq	r2,zero,820c780 <__lo0bits+0x80>
 820c734:	0005883a 	mov	r2,zero
 820c738:	19403fcc 	andi	r5,r3,255
 820c73c:	2800021e 	bne	r5,zero,820c748 <__lo0bits+0x48>
 820c740:	1806d23a 	srli	r3,r3,8
 820c744:	10800204 	addi	r2,r2,8
 820c748:	194003cc 	andi	r5,r3,15
 820c74c:	2800021e 	bne	r5,zero,820c758 <__lo0bits+0x58>
 820c750:	1806d13a 	srli	r3,r3,4
 820c754:	10800104 	addi	r2,r2,4
 820c758:	194000cc 	andi	r5,r3,3
 820c75c:	2800021e 	bne	r5,zero,820c768 <__lo0bits+0x68>
 820c760:	1806d0ba 	srli	r3,r3,2
 820c764:	10800084 	addi	r2,r2,2
 820c768:	1940004c 	andi	r5,r3,1
 820c76c:	2800081e 	bne	r5,zero,820c790 <__lo0bits+0x90>
 820c770:	1806d07a 	srli	r3,r3,1
 820c774:	1800051e 	bne	r3,zero,820c78c <__lo0bits+0x8c>
 820c778:	00800804 	movi	r2,32
 820c77c:	f800283a 	ret
 820c780:	1806d43a 	srli	r3,r3,16
 820c784:	00800404 	movi	r2,16
 820c788:	003feb06 	br	820c738 <__lo0bits+0x38>
 820c78c:	10800044 	addi	r2,r2,1
 820c790:	20c00015 	stw	r3,0(r4)
 820c794:	f800283a 	ret
 820c798:	0005883a 	mov	r2,zero
 820c79c:	f800283a 	ret
 820c7a0:	1806d07a 	srli	r3,r3,1
 820c7a4:	00800044 	movi	r2,1
 820c7a8:	20c00015 	stw	r3,0(r4)
 820c7ac:	f800283a 	ret

0820c7b0 <__i2b>:
 820c7b0:	defffd04 	addi	sp,sp,-12
 820c7b4:	dc000015 	stw	r16,0(sp)
 820c7b8:	04000044 	movi	r16,1
 820c7bc:	dc400115 	stw	r17,4(sp)
 820c7c0:	2823883a 	mov	r17,r5
 820c7c4:	800b883a 	mov	r5,r16
 820c7c8:	dfc00215 	stw	ra,8(sp)
 820c7cc:	820c3a40 	call	820c3a4 <_Balloc>
 820c7d0:	14400515 	stw	r17,20(r2)
 820c7d4:	14000415 	stw	r16,16(r2)
 820c7d8:	dfc00217 	ldw	ra,8(sp)
 820c7dc:	dc400117 	ldw	r17,4(sp)
 820c7e0:	dc000017 	ldw	r16,0(sp)
 820c7e4:	dec00304 	addi	sp,sp,12
 820c7e8:	f800283a 	ret

0820c7ec <__multiply>:
 820c7ec:	defffa04 	addi	sp,sp,-24
 820c7f0:	dcc00315 	stw	r19,12(sp)
 820c7f4:	dc800215 	stw	r18,8(sp)
 820c7f8:	34c00417 	ldw	r19,16(r6)
 820c7fc:	2c800417 	ldw	r18,16(r5)
 820c800:	dd000415 	stw	r20,16(sp)
 820c804:	dc400115 	stw	r17,4(sp)
 820c808:	dfc00515 	stw	ra,20(sp)
 820c80c:	dc000015 	stw	r16,0(sp)
 820c810:	2829883a 	mov	r20,r5
 820c814:	3023883a 	mov	r17,r6
 820c818:	94c0050e 	bge	r18,r19,820c830 <__multiply+0x44>
 820c81c:	9007883a 	mov	r3,r18
 820c820:	3029883a 	mov	r20,r6
 820c824:	9825883a 	mov	r18,r19
 820c828:	2823883a 	mov	r17,r5
 820c82c:	1827883a 	mov	r19,r3
 820c830:	a0800217 	ldw	r2,8(r20)
 820c834:	94e1883a 	add	r16,r18,r19
 820c838:	a1400117 	ldw	r5,4(r20)
 820c83c:	1400010e 	bge	r2,r16,820c844 <__multiply+0x58>
 820c840:	29400044 	addi	r5,r5,1
 820c844:	820c3a40 	call	820c3a4 <_Balloc>
 820c848:	8415883a 	add	r10,r16,r16
 820c84c:	12c00504 	addi	r11,r2,20
 820c850:	5295883a 	add	r10,r10,r10
 820c854:	5a95883a 	add	r10,r11,r10
 820c858:	5807883a 	mov	r3,r11
 820c85c:	5a80032e 	bgeu	r11,r10,820c86c <__multiply+0x80>
 820c860:	18000015 	stw	zero,0(r3)
 820c864:	18c00104 	addi	r3,r3,4
 820c868:	1abffd36 	bltu	r3,r10,820c860 <__multiply+0x74>
 820c86c:	9ce7883a 	add	r19,r19,r19
 820c870:	94a5883a 	add	r18,r18,r18
 820c874:	89800504 	addi	r6,r17,20
 820c878:	9ce7883a 	add	r19,r19,r19
 820c87c:	a3400504 	addi	r13,r20,20
 820c880:	94a5883a 	add	r18,r18,r18
 820c884:	34d9883a 	add	r12,r6,r19
 820c888:	6c93883a 	add	r9,r13,r18
 820c88c:	3300422e 	bgeu	r6,r12,820c998 <__multiply+0x1ac>
 820c890:	37c00017 	ldw	ra,0(r6)
 820c894:	fbffffcc 	andi	r15,ra,65535
 820c898:	78001b26 	beq	r15,zero,820c908 <__multiply+0x11c>
 820c89c:	5811883a 	mov	r8,r11
 820c8a0:	681d883a 	mov	r14,r13
 820c8a4:	000f883a 	mov	r7,zero
 820c8a8:	71000017 	ldw	r4,0(r14)
 820c8ac:	40c00017 	ldw	r3,0(r8)
 820c8b0:	73800104 	addi	r14,r14,4
 820c8b4:	217fffcc 	andi	r5,r4,65535
 820c8b8:	2bcb383a 	mul	r5,r5,r15
 820c8bc:	2008d43a 	srli	r4,r4,16
 820c8c0:	1c7fffcc 	andi	r17,r3,65535
 820c8c4:	2c4b883a 	add	r5,r5,r17
 820c8c8:	29cb883a 	add	r5,r5,r7
 820c8cc:	23c9383a 	mul	r4,r4,r15
 820c8d0:	1806d43a 	srli	r3,r3,16
 820c8d4:	280ed43a 	srli	r7,r5,16
 820c8d8:	297fffcc 	andi	r5,r5,65535
 820c8dc:	20c7883a 	add	r3,r4,r3
 820c8e0:	19c7883a 	add	r3,r3,r7
 820c8e4:	1808943a 	slli	r4,r3,16
 820c8e8:	4023883a 	mov	r17,r8
 820c8ec:	180ed43a 	srli	r7,r3,16
 820c8f0:	214ab03a 	or	r5,r4,r5
 820c8f4:	41400015 	stw	r5,0(r8)
 820c8f8:	42000104 	addi	r8,r8,4
 820c8fc:	727fea36 	bltu	r14,r9,820c8a8 <__multiply+0xbc>
 820c900:	89c00115 	stw	r7,4(r17)
 820c904:	37c00017 	ldw	ra,0(r6)
 820c908:	f83ed43a 	srli	ra,ra,16
 820c90c:	f8001f26 	beq	ra,zero,820c98c <__multiply+0x1a0>
 820c910:	58c00017 	ldw	r3,0(r11)
 820c914:	681d883a 	mov	r14,r13
 820c918:	581f883a 	mov	r15,r11
 820c91c:	1811883a 	mov	r8,r3
 820c920:	5825883a 	mov	r18,r11
 820c924:	000f883a 	mov	r7,zero
 820c928:	00000106 	br	820c930 <__multiply+0x144>
 820c92c:	8825883a 	mov	r18,r17
 820c930:	7140000b 	ldhu	r5,0(r14)
 820c934:	4010d43a 	srli	r8,r8,16
 820c938:	193fffcc 	andi	r4,r3,65535
 820c93c:	2fcb383a 	mul	r5,r5,ra
 820c940:	7bc00104 	addi	r15,r15,4
 820c944:	73800104 	addi	r14,r14,4
 820c948:	2a0b883a 	add	r5,r5,r8
 820c94c:	29cb883a 	add	r5,r5,r7
 820c950:	2806943a 	slli	r3,r5,16
 820c954:	94400104 	addi	r17,r18,4
 820c958:	280ad43a 	srli	r5,r5,16
 820c95c:	1908b03a 	or	r4,r3,r4
 820c960:	793fff15 	stw	r4,-4(r15)
 820c964:	70ffff17 	ldw	r3,-4(r14)
 820c968:	8a000017 	ldw	r8,0(r17)
 820c96c:	1806d43a 	srli	r3,r3,16
 820c970:	413fffcc 	andi	r4,r8,65535
 820c974:	1fc7383a 	mul	r3,r3,ra
 820c978:	1907883a 	add	r3,r3,r4
 820c97c:	1947883a 	add	r3,r3,r5
 820c980:	180ed43a 	srli	r7,r3,16
 820c984:	727fe936 	bltu	r14,r9,820c92c <__multiply+0x140>
 820c988:	90c00115 	stw	r3,4(r18)
 820c98c:	31800104 	addi	r6,r6,4
 820c990:	5ac00104 	addi	r11,r11,4
 820c994:	333fbe36 	bltu	r6,r12,820c890 <__multiply+0xa4>
 820c998:	0400090e 	bge	zero,r16,820c9c0 <__multiply+0x1d4>
 820c99c:	50ffff17 	ldw	r3,-4(r10)
 820c9a0:	52bfff04 	addi	r10,r10,-4
 820c9a4:	18000326 	beq	r3,zero,820c9b4 <__multiply+0x1c8>
 820c9a8:	00000506 	br	820c9c0 <__multiply+0x1d4>
 820c9ac:	50c00017 	ldw	r3,0(r10)
 820c9b0:	1800031e 	bne	r3,zero,820c9c0 <__multiply+0x1d4>
 820c9b4:	843fffc4 	addi	r16,r16,-1
 820c9b8:	52bfff04 	addi	r10,r10,-4
 820c9bc:	803ffb1e 	bne	r16,zero,820c9ac <__multiply+0x1c0>
 820c9c0:	14000415 	stw	r16,16(r2)
 820c9c4:	dfc00517 	ldw	ra,20(sp)
 820c9c8:	dd000417 	ldw	r20,16(sp)
 820c9cc:	dcc00317 	ldw	r19,12(sp)
 820c9d0:	dc800217 	ldw	r18,8(sp)
 820c9d4:	dc400117 	ldw	r17,4(sp)
 820c9d8:	dc000017 	ldw	r16,0(sp)
 820c9dc:	dec00604 	addi	sp,sp,24
 820c9e0:	f800283a 	ret

0820c9e4 <__pow5mult>:
 820c9e4:	defffa04 	addi	sp,sp,-24
 820c9e8:	dcc00315 	stw	r19,12(sp)
 820c9ec:	dc000015 	stw	r16,0(sp)
 820c9f0:	dfc00515 	stw	ra,20(sp)
 820c9f4:	dd000415 	stw	r20,16(sp)
 820c9f8:	dc800215 	stw	r18,8(sp)
 820c9fc:	dc400115 	stw	r17,4(sp)
 820ca00:	308000cc 	andi	r2,r6,3
 820ca04:	3021883a 	mov	r16,r6
 820ca08:	2027883a 	mov	r19,r4
 820ca0c:	10002f1e 	bne	r2,zero,820cacc <__pow5mult+0xe8>
 820ca10:	2825883a 	mov	r18,r5
 820ca14:	8021d0ba 	srai	r16,r16,2
 820ca18:	80001a26 	beq	r16,zero,820ca84 <__pow5mult+0xa0>
 820ca1c:	9c401217 	ldw	r17,72(r19)
 820ca20:	8800061e 	bne	r17,zero,820ca3c <__pow5mult+0x58>
 820ca24:	00003406 	br	820caf8 <__pow5mult+0x114>
 820ca28:	8021d07a 	srai	r16,r16,1
 820ca2c:	80001526 	beq	r16,zero,820ca84 <__pow5mult+0xa0>
 820ca30:	88800017 	ldw	r2,0(r17)
 820ca34:	10001c26 	beq	r2,zero,820caa8 <__pow5mult+0xc4>
 820ca38:	1023883a 	mov	r17,r2
 820ca3c:	8080004c 	andi	r2,r16,1
 820ca40:	103ff926 	beq	r2,zero,820ca28 <__pow5mult+0x44>
 820ca44:	880d883a 	mov	r6,r17
 820ca48:	900b883a 	mov	r5,r18
 820ca4c:	9809883a 	mov	r4,r19
 820ca50:	820c7ec0 	call	820c7ec <__multiply>
 820ca54:	90001b26 	beq	r18,zero,820cac4 <__pow5mult+0xe0>
 820ca58:	91000117 	ldw	r4,4(r18)
 820ca5c:	98c01317 	ldw	r3,76(r19)
 820ca60:	8021d07a 	srai	r16,r16,1
 820ca64:	2109883a 	add	r4,r4,r4
 820ca68:	2109883a 	add	r4,r4,r4
 820ca6c:	1907883a 	add	r3,r3,r4
 820ca70:	19000017 	ldw	r4,0(r3)
 820ca74:	91000015 	stw	r4,0(r18)
 820ca78:	1c800015 	stw	r18,0(r3)
 820ca7c:	1025883a 	mov	r18,r2
 820ca80:	803feb1e 	bne	r16,zero,820ca30 <__pow5mult+0x4c>
 820ca84:	9005883a 	mov	r2,r18
 820ca88:	dfc00517 	ldw	ra,20(sp)
 820ca8c:	dd000417 	ldw	r20,16(sp)
 820ca90:	dcc00317 	ldw	r19,12(sp)
 820ca94:	dc800217 	ldw	r18,8(sp)
 820ca98:	dc400117 	ldw	r17,4(sp)
 820ca9c:	dc000017 	ldw	r16,0(sp)
 820caa0:	dec00604 	addi	sp,sp,24
 820caa4:	f800283a 	ret
 820caa8:	880d883a 	mov	r6,r17
 820caac:	880b883a 	mov	r5,r17
 820cab0:	9809883a 	mov	r4,r19
 820cab4:	820c7ec0 	call	820c7ec <__multiply>
 820cab8:	88800015 	stw	r2,0(r17)
 820cabc:	10000015 	stw	zero,0(r2)
 820cac0:	003fdd06 	br	820ca38 <__pow5mult+0x54>
 820cac4:	1025883a 	mov	r18,r2
 820cac8:	003fd706 	br	820ca28 <__pow5mult+0x44>
 820cacc:	10bfffc4 	addi	r2,r2,-1
 820cad0:	1085883a 	add	r2,r2,r2
 820cad4:	00c20974 	movhi	r3,2085
 820cad8:	18f60104 	addi	r3,r3,-10236
 820cadc:	1085883a 	add	r2,r2,r2
 820cae0:	1885883a 	add	r2,r3,r2
 820cae4:	11800017 	ldw	r6,0(r2)
 820cae8:	000f883a 	mov	r7,zero
 820caec:	820c4740 	call	820c474 <__multadd>
 820caf0:	1025883a 	mov	r18,r2
 820caf4:	003fc706 	br	820ca14 <__pow5mult+0x30>
 820caf8:	05000044 	movi	r20,1
 820cafc:	a00b883a 	mov	r5,r20
 820cb00:	9809883a 	mov	r4,r19
 820cb04:	820c3a40 	call	820c3a4 <_Balloc>
 820cb08:	1023883a 	mov	r17,r2
 820cb0c:	00809c44 	movi	r2,625
 820cb10:	88800515 	stw	r2,20(r17)
 820cb14:	8d000415 	stw	r20,16(r17)
 820cb18:	9c401215 	stw	r17,72(r19)
 820cb1c:	88000015 	stw	zero,0(r17)
 820cb20:	003fc606 	br	820ca3c <__pow5mult+0x58>

0820cb24 <__lshift>:
 820cb24:	defff904 	addi	sp,sp,-28
 820cb28:	dd400515 	stw	r21,20(sp)
 820cb2c:	dcc00315 	stw	r19,12(sp)
 820cb30:	302bd17a 	srai	r21,r6,5
 820cb34:	2cc00417 	ldw	r19,16(r5)
 820cb38:	28800217 	ldw	r2,8(r5)
 820cb3c:	dd000415 	stw	r20,16(sp)
 820cb40:	ace7883a 	add	r19,r21,r19
 820cb44:	dc800215 	stw	r18,8(sp)
 820cb48:	dc400115 	stw	r17,4(sp)
 820cb4c:	dc000015 	stw	r16,0(sp)
 820cb50:	dfc00615 	stw	ra,24(sp)
 820cb54:	9c000044 	addi	r16,r19,1
 820cb58:	2823883a 	mov	r17,r5
 820cb5c:	3029883a 	mov	r20,r6
 820cb60:	2025883a 	mov	r18,r4
 820cb64:	29400117 	ldw	r5,4(r5)
 820cb68:	1400030e 	bge	r2,r16,820cb78 <__lshift+0x54>
 820cb6c:	1085883a 	add	r2,r2,r2
 820cb70:	29400044 	addi	r5,r5,1
 820cb74:	143ffd16 	blt	r2,r16,820cb6c <__lshift+0x48>
 820cb78:	9009883a 	mov	r4,r18
 820cb7c:	820c3a40 	call	820c3a4 <_Balloc>
 820cb80:	10c00504 	addi	r3,r2,20
 820cb84:	0540070e 	bge	zero,r21,820cba4 <__lshift+0x80>
 820cb88:	ad6b883a 	add	r21,r21,r21
 820cb8c:	ad6b883a 	add	r21,r21,r21
 820cb90:	1809883a 	mov	r4,r3
 820cb94:	1d47883a 	add	r3,r3,r21
 820cb98:	20000015 	stw	zero,0(r4)
 820cb9c:	21000104 	addi	r4,r4,4
 820cba0:	193ffd1e 	bne	r3,r4,820cb98 <__lshift+0x74>
 820cba4:	8a000417 	ldw	r8,16(r17)
 820cba8:	89000504 	addi	r4,r17,20
 820cbac:	a18007cc 	andi	r6,r20,31
 820cbb0:	4211883a 	add	r8,r8,r8
 820cbb4:	4211883a 	add	r8,r8,r8
 820cbb8:	2211883a 	add	r8,r4,r8
 820cbbc:	30002326 	beq	r6,zero,820cc4c <__lshift+0x128>
 820cbc0:	02400804 	movi	r9,32
 820cbc4:	4993c83a 	sub	r9,r9,r6
 820cbc8:	000b883a 	mov	r5,zero
 820cbcc:	21c00017 	ldw	r7,0(r4)
 820cbd0:	1815883a 	mov	r10,r3
 820cbd4:	18c00104 	addi	r3,r3,4
 820cbd8:	398e983a 	sll	r7,r7,r6
 820cbdc:	21000104 	addi	r4,r4,4
 820cbe0:	394ab03a 	or	r5,r7,r5
 820cbe4:	197fff15 	stw	r5,-4(r3)
 820cbe8:	217fff17 	ldw	r5,-4(r4)
 820cbec:	2a4ad83a 	srl	r5,r5,r9
 820cbf0:	223ff636 	bltu	r4,r8,820cbcc <__lshift+0xa8>
 820cbf4:	51400115 	stw	r5,4(r10)
 820cbf8:	28001a1e 	bne	r5,zero,820cc64 <__lshift+0x140>
 820cbfc:	843fffc4 	addi	r16,r16,-1
 820cc00:	14000415 	stw	r16,16(r2)
 820cc04:	88000826 	beq	r17,zero,820cc28 <__lshift+0x104>
 820cc08:	89000117 	ldw	r4,4(r17)
 820cc0c:	90c01317 	ldw	r3,76(r18)
 820cc10:	2109883a 	add	r4,r4,r4
 820cc14:	2109883a 	add	r4,r4,r4
 820cc18:	1907883a 	add	r3,r3,r4
 820cc1c:	19000017 	ldw	r4,0(r3)
 820cc20:	89000015 	stw	r4,0(r17)
 820cc24:	1c400015 	stw	r17,0(r3)
 820cc28:	dfc00617 	ldw	ra,24(sp)
 820cc2c:	dd400517 	ldw	r21,20(sp)
 820cc30:	dd000417 	ldw	r20,16(sp)
 820cc34:	dcc00317 	ldw	r19,12(sp)
 820cc38:	dc800217 	ldw	r18,8(sp)
 820cc3c:	dc400117 	ldw	r17,4(sp)
 820cc40:	dc000017 	ldw	r16,0(sp)
 820cc44:	dec00704 	addi	sp,sp,28
 820cc48:	f800283a 	ret
 820cc4c:	21400017 	ldw	r5,0(r4)
 820cc50:	18c00104 	addi	r3,r3,4
 820cc54:	21000104 	addi	r4,r4,4
 820cc58:	197fff15 	stw	r5,-4(r3)
 820cc5c:	223ffb36 	bltu	r4,r8,820cc4c <__lshift+0x128>
 820cc60:	003fe606 	br	820cbfc <__lshift+0xd8>
 820cc64:	9c000084 	addi	r16,r19,2
 820cc68:	003fe406 	br	820cbfc <__lshift+0xd8>

0820cc6c <__mcmp>:
 820cc6c:	20800417 	ldw	r2,16(r4)
 820cc70:	28c00417 	ldw	r3,16(r5)
 820cc74:	10c5c83a 	sub	r2,r2,r3
 820cc78:	1000111e 	bne	r2,zero,820ccc0 <__mcmp+0x54>
 820cc7c:	18c7883a 	add	r3,r3,r3
 820cc80:	18c7883a 	add	r3,r3,r3
 820cc84:	21000504 	addi	r4,r4,20
 820cc88:	29400504 	addi	r5,r5,20
 820cc8c:	20c5883a 	add	r2,r4,r3
 820cc90:	28cb883a 	add	r5,r5,r3
 820cc94:	00000106 	br	820cc9c <__mcmp+0x30>
 820cc98:	20800a2e 	bgeu	r4,r2,820ccc4 <__mcmp+0x58>
 820cc9c:	10bfff04 	addi	r2,r2,-4
 820cca0:	297fff04 	addi	r5,r5,-4
 820cca4:	11800017 	ldw	r6,0(r2)
 820cca8:	28c00017 	ldw	r3,0(r5)
 820ccac:	30fffa26 	beq	r6,r3,820cc98 <__mcmp+0x2c>
 820ccb0:	30c00236 	bltu	r6,r3,820ccbc <__mcmp+0x50>
 820ccb4:	00800044 	movi	r2,1
 820ccb8:	f800283a 	ret
 820ccbc:	00bfffc4 	movi	r2,-1
 820ccc0:	f800283a 	ret
 820ccc4:	0005883a 	mov	r2,zero
 820ccc8:	f800283a 	ret

0820cccc <__mdiff>:
 820cccc:	28c00417 	ldw	r3,16(r5)
 820ccd0:	30800417 	ldw	r2,16(r6)
 820ccd4:	defffa04 	addi	sp,sp,-24
 820ccd8:	dcc00315 	stw	r19,12(sp)
 820ccdc:	dc800215 	stw	r18,8(sp)
 820cce0:	dfc00515 	stw	ra,20(sp)
 820cce4:	dd000415 	stw	r20,16(sp)
 820cce8:	dc400115 	stw	r17,4(sp)
 820ccec:	dc000015 	stw	r16,0(sp)
 820ccf0:	1887c83a 	sub	r3,r3,r2
 820ccf4:	2825883a 	mov	r18,r5
 820ccf8:	3027883a 	mov	r19,r6
 820ccfc:	1800141e 	bne	r3,zero,820cd50 <__mdiff+0x84>
 820cd00:	1085883a 	add	r2,r2,r2
 820cd04:	1085883a 	add	r2,r2,r2
 820cd08:	2a000504 	addi	r8,r5,20
 820cd0c:	34000504 	addi	r16,r6,20
 820cd10:	4087883a 	add	r3,r8,r2
 820cd14:	8085883a 	add	r2,r16,r2
 820cd18:	00000106 	br	820cd20 <__mdiff+0x54>
 820cd1c:	40c0592e 	bgeu	r8,r3,820ce84 <__mdiff+0x1b8>
 820cd20:	18ffff04 	addi	r3,r3,-4
 820cd24:	10bfff04 	addi	r2,r2,-4
 820cd28:	19c00017 	ldw	r7,0(r3)
 820cd2c:	11400017 	ldw	r5,0(r2)
 820cd30:	397ffa26 	beq	r7,r5,820cd1c <__mdiff+0x50>
 820cd34:	3940592e 	bgeu	r7,r5,820ce9c <__mdiff+0x1d0>
 820cd38:	9005883a 	mov	r2,r18
 820cd3c:	4023883a 	mov	r17,r8
 820cd40:	9825883a 	mov	r18,r19
 820cd44:	05000044 	movi	r20,1
 820cd48:	1027883a 	mov	r19,r2
 820cd4c:	00000406 	br	820cd60 <__mdiff+0x94>
 820cd50:	18005616 	blt	r3,zero,820ceac <__mdiff+0x1e0>
 820cd54:	34400504 	addi	r17,r6,20
 820cd58:	2c000504 	addi	r16,r5,20
 820cd5c:	0029883a 	mov	r20,zero
 820cd60:	91400117 	ldw	r5,4(r18)
 820cd64:	820c3a40 	call	820c3a4 <_Balloc>
 820cd68:	92400417 	ldw	r9,16(r18)
 820cd6c:	9b000417 	ldw	r12,16(r19)
 820cd70:	12c00504 	addi	r11,r2,20
 820cd74:	4a51883a 	add	r8,r9,r9
 820cd78:	6319883a 	add	r12,r12,r12
 820cd7c:	4211883a 	add	r8,r8,r8
 820cd80:	6319883a 	add	r12,r12,r12
 820cd84:	15000315 	stw	r20,12(r2)
 820cd88:	8211883a 	add	r8,r16,r8
 820cd8c:	8b19883a 	add	r12,r17,r12
 820cd90:	0007883a 	mov	r3,zero
 820cd94:	81400017 	ldw	r5,0(r16)
 820cd98:	89c00017 	ldw	r7,0(r17)
 820cd9c:	59800104 	addi	r6,r11,4
 820cda0:	293fffcc 	andi	r4,r5,65535
 820cda4:	20c7883a 	add	r3,r4,r3
 820cda8:	393fffcc 	andi	r4,r7,65535
 820cdac:	1909c83a 	sub	r4,r3,r4
 820cdb0:	280ad43a 	srli	r5,r5,16
 820cdb4:	380ed43a 	srli	r7,r7,16
 820cdb8:	2007d43a 	srai	r3,r4,16
 820cdbc:	213fffcc 	andi	r4,r4,65535
 820cdc0:	29cbc83a 	sub	r5,r5,r7
 820cdc4:	28c7883a 	add	r3,r5,r3
 820cdc8:	180a943a 	slli	r5,r3,16
 820cdcc:	8c400104 	addi	r17,r17,4
 820cdd0:	84000104 	addi	r16,r16,4
 820cdd4:	2908b03a 	or	r4,r5,r4
 820cdd8:	59000015 	stw	r4,0(r11)
 820cddc:	1807d43a 	srai	r3,r3,16
 820cde0:	3015883a 	mov	r10,r6
 820cde4:	3017883a 	mov	r11,r6
 820cde8:	8b3fea36 	bltu	r17,r12,820cd94 <__mdiff+0xc8>
 820cdec:	8200162e 	bgeu	r16,r8,820ce48 <__mdiff+0x17c>
 820cdf0:	8017883a 	mov	r11,r16
 820cdf4:	59400017 	ldw	r5,0(r11)
 820cdf8:	31800104 	addi	r6,r6,4
 820cdfc:	5ac00104 	addi	r11,r11,4
 820ce00:	293fffcc 	andi	r4,r5,65535
 820ce04:	20c7883a 	add	r3,r4,r3
 820ce08:	280ed43a 	srli	r7,r5,16
 820ce0c:	180bd43a 	srai	r5,r3,16
 820ce10:	193fffcc 	andi	r4,r3,65535
 820ce14:	3947883a 	add	r3,r7,r5
 820ce18:	180a943a 	slli	r5,r3,16
 820ce1c:	1807d43a 	srai	r3,r3,16
 820ce20:	2908b03a 	or	r4,r5,r4
 820ce24:	313fff15 	stw	r4,-4(r6)
 820ce28:	5a3ff236 	bltu	r11,r8,820cdf4 <__mdiff+0x128>
 820ce2c:	0406303a 	nor	r3,zero,r16
 820ce30:	1a07883a 	add	r3,r3,r8
 820ce34:	1806d0ba 	srli	r3,r3,2
 820ce38:	18c00044 	addi	r3,r3,1
 820ce3c:	18c7883a 	add	r3,r3,r3
 820ce40:	18c7883a 	add	r3,r3,r3
 820ce44:	50d5883a 	add	r10,r10,r3
 820ce48:	50ffff04 	addi	r3,r10,-4
 820ce4c:	2000041e 	bne	r4,zero,820ce60 <__mdiff+0x194>
 820ce50:	18ffff04 	addi	r3,r3,-4
 820ce54:	19000017 	ldw	r4,0(r3)
 820ce58:	4a7fffc4 	addi	r9,r9,-1
 820ce5c:	203ffc26 	beq	r4,zero,820ce50 <__mdiff+0x184>
 820ce60:	12400415 	stw	r9,16(r2)
 820ce64:	dfc00517 	ldw	ra,20(sp)
 820ce68:	dd000417 	ldw	r20,16(sp)
 820ce6c:	dcc00317 	ldw	r19,12(sp)
 820ce70:	dc800217 	ldw	r18,8(sp)
 820ce74:	dc400117 	ldw	r17,4(sp)
 820ce78:	dc000017 	ldw	r16,0(sp)
 820ce7c:	dec00604 	addi	sp,sp,24
 820ce80:	f800283a 	ret
 820ce84:	000b883a 	mov	r5,zero
 820ce88:	820c3a40 	call	820c3a4 <_Balloc>
 820ce8c:	00c00044 	movi	r3,1
 820ce90:	10c00415 	stw	r3,16(r2)
 820ce94:	10000515 	stw	zero,20(r2)
 820ce98:	003ff206 	br	820ce64 <__mdiff+0x198>
 820ce9c:	8023883a 	mov	r17,r16
 820cea0:	0029883a 	mov	r20,zero
 820cea4:	4021883a 	mov	r16,r8
 820cea8:	003fad06 	br	820cd60 <__mdiff+0x94>
 820ceac:	9005883a 	mov	r2,r18
 820ceb0:	94400504 	addi	r17,r18,20
 820ceb4:	9c000504 	addi	r16,r19,20
 820ceb8:	9825883a 	mov	r18,r19
 820cebc:	05000044 	movi	r20,1
 820cec0:	1027883a 	mov	r19,r2
 820cec4:	003fa606 	br	820cd60 <__mdiff+0x94>

0820cec8 <__ulp>:
 820cec8:	295ffc2c 	andhi	r5,r5,32752
 820cecc:	00bf3034 	movhi	r2,64704
 820ced0:	2887883a 	add	r3,r5,r2
 820ced4:	00c0020e 	bge	zero,r3,820cee0 <__ulp+0x18>
 820ced8:	0005883a 	mov	r2,zero
 820cedc:	f800283a 	ret
 820cee0:	00c7c83a 	sub	r3,zero,r3
 820cee4:	1807d53a 	srai	r3,r3,20
 820cee8:	008004c4 	movi	r2,19
 820ceec:	10c00b0e 	bge	r2,r3,820cf1c <__ulp+0x54>
 820cef0:	18bffb04 	addi	r2,r3,-20
 820cef4:	01000784 	movi	r4,30
 820cef8:	0007883a 	mov	r3,zero
 820cefc:	20800516 	blt	r4,r2,820cf14 <__ulp+0x4c>
 820cf00:	010007c4 	movi	r4,31
 820cf04:	2089c83a 	sub	r4,r4,r2
 820cf08:	00800044 	movi	r2,1
 820cf0c:	1104983a 	sll	r2,r2,r4
 820cf10:	f800283a 	ret
 820cf14:	00800044 	movi	r2,1
 820cf18:	f800283a 	ret
 820cf1c:	01400234 	movhi	r5,8
 820cf20:	28c7d83a 	sra	r3,r5,r3
 820cf24:	0005883a 	mov	r2,zero
 820cf28:	f800283a 	ret

0820cf2c <__b2d>:
 820cf2c:	defffa04 	addi	sp,sp,-24
 820cf30:	dc000015 	stw	r16,0(sp)
 820cf34:	24000417 	ldw	r16,16(r4)
 820cf38:	dc400115 	stw	r17,4(sp)
 820cf3c:	24400504 	addi	r17,r4,20
 820cf40:	8421883a 	add	r16,r16,r16
 820cf44:	8421883a 	add	r16,r16,r16
 820cf48:	8c21883a 	add	r16,r17,r16
 820cf4c:	dc800215 	stw	r18,8(sp)
 820cf50:	84bfff17 	ldw	r18,-4(r16)
 820cf54:	dd000415 	stw	r20,16(sp)
 820cf58:	dcc00315 	stw	r19,12(sp)
 820cf5c:	9009883a 	mov	r4,r18
 820cf60:	2829883a 	mov	r20,r5
 820cf64:	dfc00515 	stw	ra,20(sp)
 820cf68:	820c6980 	call	820c698 <__hi0bits>
 820cf6c:	00c00804 	movi	r3,32
 820cf70:	1889c83a 	sub	r4,r3,r2
 820cf74:	a1000015 	stw	r4,0(r20)
 820cf78:	01000284 	movi	r4,10
 820cf7c:	84ffff04 	addi	r19,r16,-4
 820cf80:	20801216 	blt	r4,r2,820cfcc <__b2d+0xa0>
 820cf84:	018002c4 	movi	r6,11
 820cf88:	308dc83a 	sub	r6,r6,r2
 820cf8c:	9186d83a 	srl	r3,r18,r6
 820cf90:	18cffc34 	orhi	r3,r3,16368
 820cf94:	8cc0212e 	bgeu	r17,r19,820d01c <__b2d+0xf0>
 820cf98:	813ffe17 	ldw	r4,-8(r16)
 820cf9c:	218cd83a 	srl	r6,r4,r6
 820cfa0:	10800544 	addi	r2,r2,21
 820cfa4:	9084983a 	sll	r2,r18,r2
 820cfa8:	1184b03a 	or	r2,r2,r6
 820cfac:	dfc00517 	ldw	ra,20(sp)
 820cfb0:	dd000417 	ldw	r20,16(sp)
 820cfb4:	dcc00317 	ldw	r19,12(sp)
 820cfb8:	dc800217 	ldw	r18,8(sp)
 820cfbc:	dc400117 	ldw	r17,4(sp)
 820cfc0:	dc000017 	ldw	r16,0(sp)
 820cfc4:	dec00604 	addi	sp,sp,24
 820cfc8:	f800283a 	ret
 820cfcc:	8cc00f2e 	bgeu	r17,r19,820d00c <__b2d+0xe0>
 820cfd0:	117ffd44 	addi	r5,r2,-11
 820cfd4:	80bffe17 	ldw	r2,-8(r16)
 820cfd8:	28000e26 	beq	r5,zero,820d014 <__b2d+0xe8>
 820cfdc:	1949c83a 	sub	r4,r3,r5
 820cfe0:	9164983a 	sll	r18,r18,r5
 820cfe4:	1106d83a 	srl	r3,r2,r4
 820cfe8:	81bffe04 	addi	r6,r16,-8
 820cfec:	948ffc34 	orhi	r18,r18,16368
 820cff0:	90c6b03a 	or	r3,r18,r3
 820cff4:	89800e2e 	bgeu	r17,r6,820d030 <__b2d+0x104>
 820cff8:	81bffd17 	ldw	r6,-12(r16)
 820cffc:	1144983a 	sll	r2,r2,r5
 820d000:	310ad83a 	srl	r5,r6,r4
 820d004:	2884b03a 	or	r2,r5,r2
 820d008:	003fe806 	br	820cfac <__b2d+0x80>
 820d00c:	10bffd44 	addi	r2,r2,-11
 820d010:	1000041e 	bne	r2,zero,820d024 <__b2d+0xf8>
 820d014:	90cffc34 	orhi	r3,r18,16368
 820d018:	003fe406 	br	820cfac <__b2d+0x80>
 820d01c:	000d883a 	mov	r6,zero
 820d020:	003fdf06 	br	820cfa0 <__b2d+0x74>
 820d024:	90a4983a 	sll	r18,r18,r2
 820d028:	0005883a 	mov	r2,zero
 820d02c:	003ff906 	br	820d014 <__b2d+0xe8>
 820d030:	1144983a 	sll	r2,r2,r5
 820d034:	003fdd06 	br	820cfac <__b2d+0x80>

0820d038 <__d2b>:
 820d038:	defff804 	addi	sp,sp,-32
 820d03c:	dc000215 	stw	r16,8(sp)
 820d040:	3021883a 	mov	r16,r6
 820d044:	dc400315 	stw	r17,12(sp)
 820d048:	8022907a 	slli	r17,r16,1
 820d04c:	dd000615 	stw	r20,24(sp)
 820d050:	2829883a 	mov	r20,r5
 820d054:	01400044 	movi	r5,1
 820d058:	dcc00515 	stw	r19,20(sp)
 820d05c:	dc800415 	stw	r18,16(sp)
 820d060:	dfc00715 	stw	ra,28(sp)
 820d064:	3825883a 	mov	r18,r7
 820d068:	8822d57a 	srli	r17,r17,21
 820d06c:	820c3a40 	call	820c3a4 <_Balloc>
 820d070:	1027883a 	mov	r19,r2
 820d074:	00800434 	movhi	r2,16
 820d078:	10bfffc4 	addi	r2,r2,-1
 820d07c:	808c703a 	and	r6,r16,r2
 820d080:	88000126 	beq	r17,zero,820d088 <__d2b+0x50>
 820d084:	31800434 	orhi	r6,r6,16
 820d088:	d9800015 	stw	r6,0(sp)
 820d08c:	a0002426 	beq	r20,zero,820d120 <__d2b+0xe8>
 820d090:	d9000104 	addi	r4,sp,4
 820d094:	dd000115 	stw	r20,4(sp)
 820d098:	820c7000 	call	820c700 <__lo0bits>
 820d09c:	d8c00017 	ldw	r3,0(sp)
 820d0a0:	10002f1e 	bne	r2,zero,820d160 <__d2b+0x128>
 820d0a4:	d9000117 	ldw	r4,4(sp)
 820d0a8:	99000515 	stw	r4,20(r19)
 820d0ac:	1821003a 	cmpeq	r16,r3,zero
 820d0b0:	01000084 	movi	r4,2
 820d0b4:	2421c83a 	sub	r16,r4,r16
 820d0b8:	98c00615 	stw	r3,24(r19)
 820d0bc:	9c000415 	stw	r16,16(r19)
 820d0c0:	88001f1e 	bne	r17,zero,820d140 <__d2b+0x108>
 820d0c4:	10bef384 	addi	r2,r2,-1074
 820d0c8:	90800015 	stw	r2,0(r18)
 820d0cc:	00900034 	movhi	r2,16384
 820d0d0:	10bfffc4 	addi	r2,r2,-1
 820d0d4:	8085883a 	add	r2,r16,r2
 820d0d8:	1085883a 	add	r2,r2,r2
 820d0dc:	1085883a 	add	r2,r2,r2
 820d0e0:	9885883a 	add	r2,r19,r2
 820d0e4:	11000517 	ldw	r4,20(r2)
 820d0e8:	8020917a 	slli	r16,r16,5
 820d0ec:	820c6980 	call	820c698 <__hi0bits>
 820d0f0:	d8c00817 	ldw	r3,32(sp)
 820d0f4:	8085c83a 	sub	r2,r16,r2
 820d0f8:	18800015 	stw	r2,0(r3)
 820d0fc:	9805883a 	mov	r2,r19
 820d100:	dfc00717 	ldw	ra,28(sp)
 820d104:	dd000617 	ldw	r20,24(sp)
 820d108:	dcc00517 	ldw	r19,20(sp)
 820d10c:	dc800417 	ldw	r18,16(sp)
 820d110:	dc400317 	ldw	r17,12(sp)
 820d114:	dc000217 	ldw	r16,8(sp)
 820d118:	dec00804 	addi	sp,sp,32
 820d11c:	f800283a 	ret
 820d120:	d809883a 	mov	r4,sp
 820d124:	820c7000 	call	820c700 <__lo0bits>
 820d128:	d8c00017 	ldw	r3,0(sp)
 820d12c:	04000044 	movi	r16,1
 820d130:	9c000415 	stw	r16,16(r19)
 820d134:	98c00515 	stw	r3,20(r19)
 820d138:	10800804 	addi	r2,r2,32
 820d13c:	883fe126 	beq	r17,zero,820d0c4 <__d2b+0x8c>
 820d140:	00c00d44 	movi	r3,53
 820d144:	8c7ef344 	addi	r17,r17,-1075
 820d148:	88a3883a 	add	r17,r17,r2
 820d14c:	1885c83a 	sub	r2,r3,r2
 820d150:	d8c00817 	ldw	r3,32(sp)
 820d154:	94400015 	stw	r17,0(r18)
 820d158:	18800015 	stw	r2,0(r3)
 820d15c:	003fe706 	br	820d0fc <__d2b+0xc4>
 820d160:	01000804 	movi	r4,32
 820d164:	2089c83a 	sub	r4,r4,r2
 820d168:	1908983a 	sll	r4,r3,r4
 820d16c:	d9400117 	ldw	r5,4(sp)
 820d170:	1886d83a 	srl	r3,r3,r2
 820d174:	2148b03a 	or	r4,r4,r5
 820d178:	99000515 	stw	r4,20(r19)
 820d17c:	d8c00015 	stw	r3,0(sp)
 820d180:	003fca06 	br	820d0ac <__d2b+0x74>

0820d184 <__ratio>:
 820d184:	defff904 	addi	sp,sp,-28
 820d188:	dc400315 	stw	r17,12(sp)
 820d18c:	2823883a 	mov	r17,r5
 820d190:	d9400104 	addi	r5,sp,4
 820d194:	dfc00615 	stw	ra,24(sp)
 820d198:	dcc00515 	stw	r19,20(sp)
 820d19c:	dc800415 	stw	r18,16(sp)
 820d1a0:	2027883a 	mov	r19,r4
 820d1a4:	dc000215 	stw	r16,8(sp)
 820d1a8:	820cf2c0 	call	820cf2c <__b2d>
 820d1ac:	d80b883a 	mov	r5,sp
 820d1b0:	8809883a 	mov	r4,r17
 820d1b4:	1025883a 	mov	r18,r2
 820d1b8:	1821883a 	mov	r16,r3
 820d1bc:	820cf2c0 	call	820cf2c <__b2d>
 820d1c0:	8a000417 	ldw	r8,16(r17)
 820d1c4:	99000417 	ldw	r4,16(r19)
 820d1c8:	d9400117 	ldw	r5,4(sp)
 820d1cc:	2209c83a 	sub	r4,r4,r8
 820d1d0:	2010917a 	slli	r8,r4,5
 820d1d4:	d9000017 	ldw	r4,0(sp)
 820d1d8:	2909c83a 	sub	r4,r5,r4
 820d1dc:	4109883a 	add	r4,r8,r4
 820d1e0:	01000e0e 	bge	zero,r4,820d21c <__ratio+0x98>
 820d1e4:	2008953a 	slli	r4,r4,20
 820d1e8:	2421883a 	add	r16,r4,r16
 820d1ec:	100d883a 	mov	r6,r2
 820d1f0:	180f883a 	mov	r7,r3
 820d1f4:	9009883a 	mov	r4,r18
 820d1f8:	800b883a 	mov	r5,r16
 820d1fc:	82123600 	call	8212360 <__divdf3>
 820d200:	dfc00617 	ldw	ra,24(sp)
 820d204:	dcc00517 	ldw	r19,20(sp)
 820d208:	dc800417 	ldw	r18,16(sp)
 820d20c:	dc400317 	ldw	r17,12(sp)
 820d210:	dc000217 	ldw	r16,8(sp)
 820d214:	dec00704 	addi	sp,sp,28
 820d218:	f800283a 	ret
 820d21c:	2008953a 	slli	r4,r4,20
 820d220:	1907c83a 	sub	r3,r3,r4
 820d224:	003ff106 	br	820d1ec <__ratio+0x68>

0820d228 <_mprec_log10>:
 820d228:	defffe04 	addi	sp,sp,-8
 820d22c:	dc000015 	stw	r16,0(sp)
 820d230:	dfc00115 	stw	ra,4(sp)
 820d234:	008005c4 	movi	r2,23
 820d238:	2021883a 	mov	r16,r4
 820d23c:	11000d0e 	bge	r2,r4,820d274 <_mprec_log10+0x4c>
 820d240:	0005883a 	mov	r2,zero
 820d244:	00cffc34 	movhi	r3,16368
 820d248:	843fffc4 	addi	r16,r16,-1
 820d24c:	000d883a 	mov	r6,zero
 820d250:	01d00934 	movhi	r7,16420
 820d254:	1009883a 	mov	r4,r2
 820d258:	180b883a 	mov	r5,r3
 820d25c:	8212ea00 	call	8212ea0 <__muldf3>
 820d260:	803ff91e 	bne	r16,zero,820d248 <_mprec_log10+0x20>
 820d264:	dfc00117 	ldw	ra,4(sp)
 820d268:	dc000017 	ldw	r16,0(sp)
 820d26c:	dec00204 	addi	sp,sp,8
 820d270:	f800283a 	ret
 820d274:	202090fa 	slli	r16,r4,3
 820d278:	00820974 	movhi	r2,2085
 820d27c:	10b61804 	addi	r2,r2,-10144
 820d280:	1421883a 	add	r16,r2,r16
 820d284:	80800017 	ldw	r2,0(r16)
 820d288:	80c00117 	ldw	r3,4(r16)
 820d28c:	dfc00117 	ldw	ra,4(sp)
 820d290:	dc000017 	ldw	r16,0(sp)
 820d294:	dec00204 	addi	sp,sp,8
 820d298:	f800283a 	ret

0820d29c <__copybits>:
 820d29c:	297fffc4 	addi	r5,r5,-1
 820d2a0:	280fd17a 	srai	r7,r5,5
 820d2a4:	30c00417 	ldw	r3,16(r6)
 820d2a8:	30800504 	addi	r2,r6,20
 820d2ac:	39c00044 	addi	r7,r7,1
 820d2b0:	18c7883a 	add	r3,r3,r3
 820d2b4:	39cf883a 	add	r7,r7,r7
 820d2b8:	18c7883a 	add	r3,r3,r3
 820d2bc:	39cf883a 	add	r7,r7,r7
 820d2c0:	10c7883a 	add	r3,r2,r3
 820d2c4:	21cf883a 	add	r7,r4,r7
 820d2c8:	10c00d2e 	bgeu	r2,r3,820d300 <__copybits+0x64>
 820d2cc:	200b883a 	mov	r5,r4
 820d2d0:	12000017 	ldw	r8,0(r2)
 820d2d4:	29400104 	addi	r5,r5,4
 820d2d8:	10800104 	addi	r2,r2,4
 820d2dc:	2a3fff15 	stw	r8,-4(r5)
 820d2e0:	10fffb36 	bltu	r2,r3,820d2d0 <__copybits+0x34>
 820d2e4:	1985c83a 	sub	r2,r3,r6
 820d2e8:	10bffac4 	addi	r2,r2,-21
 820d2ec:	1004d0ba 	srli	r2,r2,2
 820d2f0:	10800044 	addi	r2,r2,1
 820d2f4:	1085883a 	add	r2,r2,r2
 820d2f8:	1085883a 	add	r2,r2,r2
 820d2fc:	2089883a 	add	r4,r4,r2
 820d300:	21c0032e 	bgeu	r4,r7,820d310 <__copybits+0x74>
 820d304:	20000015 	stw	zero,0(r4)
 820d308:	21000104 	addi	r4,r4,4
 820d30c:	21fffd36 	bltu	r4,r7,820d304 <__copybits+0x68>
 820d310:	f800283a 	ret

0820d314 <__any_on>:
 820d314:	20c00417 	ldw	r3,16(r4)
 820d318:	2805d17a 	srai	r2,r5,5
 820d31c:	21000504 	addi	r4,r4,20
 820d320:	18800d0e 	bge	r3,r2,820d358 <__any_on+0x44>
 820d324:	18c7883a 	add	r3,r3,r3
 820d328:	18c7883a 	add	r3,r3,r3
 820d32c:	20c7883a 	add	r3,r4,r3
 820d330:	20c0192e 	bgeu	r4,r3,820d398 <__any_on+0x84>
 820d334:	18bfff17 	ldw	r2,-4(r3)
 820d338:	18ffff04 	addi	r3,r3,-4
 820d33c:	1000041e 	bne	r2,zero,820d350 <__any_on+0x3c>
 820d340:	20c0142e 	bgeu	r4,r3,820d394 <__any_on+0x80>
 820d344:	18ffff04 	addi	r3,r3,-4
 820d348:	19400017 	ldw	r5,0(r3)
 820d34c:	283ffc26 	beq	r5,zero,820d340 <__any_on+0x2c>
 820d350:	00800044 	movi	r2,1
 820d354:	f800283a 	ret
 820d358:	10c00a0e 	bge	r2,r3,820d384 <__any_on+0x70>
 820d35c:	1085883a 	add	r2,r2,r2
 820d360:	1085883a 	add	r2,r2,r2
 820d364:	294007cc 	andi	r5,r5,31
 820d368:	2087883a 	add	r3,r4,r2
 820d36c:	283ff026 	beq	r5,zero,820d330 <__any_on+0x1c>
 820d370:	19800017 	ldw	r6,0(r3)
 820d374:	3144d83a 	srl	r2,r6,r5
 820d378:	114a983a 	sll	r5,r2,r5
 820d37c:	317ff41e 	bne	r6,r5,820d350 <__any_on+0x3c>
 820d380:	003feb06 	br	820d330 <__any_on+0x1c>
 820d384:	1085883a 	add	r2,r2,r2
 820d388:	1085883a 	add	r2,r2,r2
 820d38c:	2087883a 	add	r3,r4,r2
 820d390:	003fe706 	br	820d330 <__any_on+0x1c>
 820d394:	f800283a 	ret
 820d398:	0005883a 	mov	r2,zero
 820d39c:	f800283a 	ret

0820d3a0 <_realloc_r>:
 820d3a0:	defff604 	addi	sp,sp,-40
 820d3a4:	dc800215 	stw	r18,8(sp)
 820d3a8:	dfc00915 	stw	ra,36(sp)
 820d3ac:	df000815 	stw	fp,32(sp)
 820d3b0:	ddc00715 	stw	r23,28(sp)
 820d3b4:	dd800615 	stw	r22,24(sp)
 820d3b8:	dd400515 	stw	r21,20(sp)
 820d3bc:	dd000415 	stw	r20,16(sp)
 820d3c0:	dcc00315 	stw	r19,12(sp)
 820d3c4:	dc400115 	stw	r17,4(sp)
 820d3c8:	dc000015 	stw	r16,0(sp)
 820d3cc:	3025883a 	mov	r18,r6
 820d3d0:	2800b726 	beq	r5,zero,820d6b0 <_realloc_r+0x310>
 820d3d4:	282b883a 	mov	r21,r5
 820d3d8:	2029883a 	mov	r20,r4
 820d3dc:	82147440 	call	8214744 <__malloc_lock>
 820d3e0:	a8bfff17 	ldw	r2,-4(r21)
 820d3e4:	043fff04 	movi	r16,-4
 820d3e8:	90c002c4 	addi	r3,r18,11
 820d3ec:	01000584 	movi	r4,22
 820d3f0:	acfffe04 	addi	r19,r21,-8
 820d3f4:	1420703a 	and	r16,r2,r16
 820d3f8:	20c0332e 	bgeu	r4,r3,820d4c8 <_realloc_r+0x128>
 820d3fc:	047ffe04 	movi	r17,-8
 820d400:	1c62703a 	and	r17,r3,r17
 820d404:	8807883a 	mov	r3,r17
 820d408:	88005816 	blt	r17,zero,820d56c <_realloc_r+0x1cc>
 820d40c:	8c805736 	bltu	r17,r18,820d56c <_realloc_r+0x1cc>
 820d410:	80c0300e 	bge	r16,r3,820d4d4 <_realloc_r+0x134>
 820d414:	07020974 	movhi	fp,2085
 820d418:	e7084604 	addi	fp,fp,8472
 820d41c:	e1c00217 	ldw	r7,8(fp)
 820d420:	9c09883a 	add	r4,r19,r16
 820d424:	22000117 	ldw	r8,4(r4)
 820d428:	21c06326 	beq	r4,r7,820d5b8 <_realloc_r+0x218>
 820d42c:	017fff84 	movi	r5,-2
 820d430:	414a703a 	and	r5,r8,r5
 820d434:	214b883a 	add	r5,r4,r5
 820d438:	29800117 	ldw	r6,4(r5)
 820d43c:	3180004c 	andi	r6,r6,1
 820d440:	30003f26 	beq	r6,zero,820d540 <_realloc_r+0x1a0>
 820d444:	1080004c 	andi	r2,r2,1
 820d448:	10008326 	beq	r2,zero,820d658 <_realloc_r+0x2b8>
 820d44c:	900b883a 	mov	r5,r18
 820d450:	a009883a 	mov	r4,r20
 820d454:	820ba380 	call	820ba38 <_malloc_r>
 820d458:	1025883a 	mov	r18,r2
 820d45c:	10011e26 	beq	r2,zero,820d8d8 <_realloc_r+0x538>
 820d460:	a93fff17 	ldw	r4,-4(r21)
 820d464:	10fffe04 	addi	r3,r2,-8
 820d468:	00bfff84 	movi	r2,-2
 820d46c:	2084703a 	and	r2,r4,r2
 820d470:	9885883a 	add	r2,r19,r2
 820d474:	1880ee26 	beq	r3,r2,820d830 <_realloc_r+0x490>
 820d478:	81bfff04 	addi	r6,r16,-4
 820d47c:	00800904 	movi	r2,36
 820d480:	1180b836 	bltu	r2,r6,820d764 <_realloc_r+0x3c4>
 820d484:	00c004c4 	movi	r3,19
 820d488:	19809636 	bltu	r3,r6,820d6e4 <_realloc_r+0x344>
 820d48c:	9005883a 	mov	r2,r18
 820d490:	a807883a 	mov	r3,r21
 820d494:	19000017 	ldw	r4,0(r3)
 820d498:	11000015 	stw	r4,0(r2)
 820d49c:	19000117 	ldw	r4,4(r3)
 820d4a0:	11000115 	stw	r4,4(r2)
 820d4a4:	18c00217 	ldw	r3,8(r3)
 820d4a8:	10c00215 	stw	r3,8(r2)
 820d4ac:	a80b883a 	mov	r5,r21
 820d4b0:	a009883a 	mov	r4,r20
 820d4b4:	820ae4c0 	call	820ae4c <_free_r>
 820d4b8:	a009883a 	mov	r4,r20
 820d4bc:	82148640 	call	8214864 <__malloc_unlock>
 820d4c0:	9005883a 	mov	r2,r18
 820d4c4:	00001206 	br	820d510 <_realloc_r+0x170>
 820d4c8:	00c00404 	movi	r3,16
 820d4cc:	1823883a 	mov	r17,r3
 820d4d0:	003fce06 	br	820d40c <_realloc_r+0x6c>
 820d4d4:	a825883a 	mov	r18,r21
 820d4d8:	8445c83a 	sub	r2,r16,r17
 820d4dc:	00c003c4 	movi	r3,15
 820d4e0:	18802636 	bltu	r3,r2,820d57c <_realloc_r+0x1dc>
 820d4e4:	99800117 	ldw	r6,4(r19)
 820d4e8:	9c07883a 	add	r3,r19,r16
 820d4ec:	3180004c 	andi	r6,r6,1
 820d4f0:	3420b03a 	or	r16,r6,r16
 820d4f4:	9c000115 	stw	r16,4(r19)
 820d4f8:	18800117 	ldw	r2,4(r3)
 820d4fc:	10800054 	ori	r2,r2,1
 820d500:	18800115 	stw	r2,4(r3)
 820d504:	a009883a 	mov	r4,r20
 820d508:	82148640 	call	8214864 <__malloc_unlock>
 820d50c:	9005883a 	mov	r2,r18
 820d510:	dfc00917 	ldw	ra,36(sp)
 820d514:	df000817 	ldw	fp,32(sp)
 820d518:	ddc00717 	ldw	r23,28(sp)
 820d51c:	dd800617 	ldw	r22,24(sp)
 820d520:	dd400517 	ldw	r21,20(sp)
 820d524:	dd000417 	ldw	r20,16(sp)
 820d528:	dcc00317 	ldw	r19,12(sp)
 820d52c:	dc800217 	ldw	r18,8(sp)
 820d530:	dc400117 	ldw	r17,4(sp)
 820d534:	dc000017 	ldw	r16,0(sp)
 820d538:	dec00a04 	addi	sp,sp,40
 820d53c:	f800283a 	ret
 820d540:	017fff04 	movi	r5,-4
 820d544:	414a703a 	and	r5,r8,r5
 820d548:	814d883a 	add	r6,r16,r5
 820d54c:	30c01f16 	blt	r6,r3,820d5cc <_realloc_r+0x22c>
 820d550:	20800317 	ldw	r2,12(r4)
 820d554:	20c00217 	ldw	r3,8(r4)
 820d558:	a825883a 	mov	r18,r21
 820d55c:	3021883a 	mov	r16,r6
 820d560:	18800315 	stw	r2,12(r3)
 820d564:	10c00215 	stw	r3,8(r2)
 820d568:	003fdb06 	br	820d4d8 <_realloc_r+0x138>
 820d56c:	00800304 	movi	r2,12
 820d570:	a0800015 	stw	r2,0(r20)
 820d574:	0005883a 	mov	r2,zero
 820d578:	003fe506 	br	820d510 <_realloc_r+0x170>
 820d57c:	98c00117 	ldw	r3,4(r19)
 820d580:	9c4b883a 	add	r5,r19,r17
 820d584:	11000054 	ori	r4,r2,1
 820d588:	18c0004c 	andi	r3,r3,1
 820d58c:	1c62b03a 	or	r17,r3,r17
 820d590:	9c400115 	stw	r17,4(r19)
 820d594:	29000115 	stw	r4,4(r5)
 820d598:	2885883a 	add	r2,r5,r2
 820d59c:	10c00117 	ldw	r3,4(r2)
 820d5a0:	29400204 	addi	r5,r5,8
 820d5a4:	a009883a 	mov	r4,r20
 820d5a8:	18c00054 	ori	r3,r3,1
 820d5ac:	10c00115 	stw	r3,4(r2)
 820d5b0:	820ae4c0 	call	820ae4c <_free_r>
 820d5b4:	003fd306 	br	820d504 <_realloc_r+0x164>
 820d5b8:	017fff04 	movi	r5,-4
 820d5bc:	414a703a 	and	r5,r8,r5
 820d5c0:	89800404 	addi	r6,r17,16
 820d5c4:	8151883a 	add	r8,r16,r5
 820d5c8:	4180590e 	bge	r8,r6,820d730 <_realloc_r+0x390>
 820d5cc:	1080004c 	andi	r2,r2,1
 820d5d0:	103f9e1e 	bne	r2,zero,820d44c <_realloc_r+0xac>
 820d5d4:	adbffe17 	ldw	r22,-8(r21)
 820d5d8:	00bfff04 	movi	r2,-4
 820d5dc:	9dadc83a 	sub	r22,r19,r22
 820d5e0:	b1800117 	ldw	r6,4(r22)
 820d5e4:	3084703a 	and	r2,r6,r2
 820d5e8:	20002026 	beq	r4,zero,820d66c <_realloc_r+0x2cc>
 820d5ec:	80af883a 	add	r23,r16,r2
 820d5f0:	b96f883a 	add	r23,r23,r5
 820d5f4:	21c05f26 	beq	r4,r7,820d774 <_realloc_r+0x3d4>
 820d5f8:	b8c01c16 	blt	r23,r3,820d66c <_realloc_r+0x2cc>
 820d5fc:	20800317 	ldw	r2,12(r4)
 820d600:	20c00217 	ldw	r3,8(r4)
 820d604:	81bfff04 	addi	r6,r16,-4
 820d608:	01000904 	movi	r4,36
 820d60c:	18800315 	stw	r2,12(r3)
 820d610:	10c00215 	stw	r3,8(r2)
 820d614:	b0c00217 	ldw	r3,8(r22)
 820d618:	b0800317 	ldw	r2,12(r22)
 820d61c:	b4800204 	addi	r18,r22,8
 820d620:	18800315 	stw	r2,12(r3)
 820d624:	10c00215 	stw	r3,8(r2)
 820d628:	21801b36 	bltu	r4,r6,820d698 <_realloc_r+0x2f8>
 820d62c:	008004c4 	movi	r2,19
 820d630:	1180352e 	bgeu	r2,r6,820d708 <_realloc_r+0x368>
 820d634:	a8800017 	ldw	r2,0(r21)
 820d638:	b0800215 	stw	r2,8(r22)
 820d63c:	a8800117 	ldw	r2,4(r21)
 820d640:	b0800315 	stw	r2,12(r22)
 820d644:	008006c4 	movi	r2,27
 820d648:	11807f36 	bltu	r2,r6,820d848 <_realloc_r+0x4a8>
 820d64c:	b0800404 	addi	r2,r22,16
 820d650:	ad400204 	addi	r21,r21,8
 820d654:	00002d06 	br	820d70c <_realloc_r+0x36c>
 820d658:	adbffe17 	ldw	r22,-8(r21)
 820d65c:	00bfff04 	movi	r2,-4
 820d660:	9dadc83a 	sub	r22,r19,r22
 820d664:	b1000117 	ldw	r4,4(r22)
 820d668:	2084703a 	and	r2,r4,r2
 820d66c:	b03f7726 	beq	r22,zero,820d44c <_realloc_r+0xac>
 820d670:	80af883a 	add	r23,r16,r2
 820d674:	b8ff7516 	blt	r23,r3,820d44c <_realloc_r+0xac>
 820d678:	b0800317 	ldw	r2,12(r22)
 820d67c:	b0c00217 	ldw	r3,8(r22)
 820d680:	81bfff04 	addi	r6,r16,-4
 820d684:	01000904 	movi	r4,36
 820d688:	18800315 	stw	r2,12(r3)
 820d68c:	10c00215 	stw	r3,8(r2)
 820d690:	b4800204 	addi	r18,r22,8
 820d694:	21bfe52e 	bgeu	r4,r6,820d62c <_realloc_r+0x28c>
 820d698:	a80b883a 	mov	r5,r21
 820d69c:	9009883a 	mov	r4,r18
 820d6a0:	8202da40 	call	8202da4 <memmove>
 820d6a4:	b821883a 	mov	r16,r23
 820d6a8:	b027883a 	mov	r19,r22
 820d6ac:	003f8a06 	br	820d4d8 <_realloc_r+0x138>
 820d6b0:	300b883a 	mov	r5,r6
 820d6b4:	dfc00917 	ldw	ra,36(sp)
 820d6b8:	df000817 	ldw	fp,32(sp)
 820d6bc:	ddc00717 	ldw	r23,28(sp)
 820d6c0:	dd800617 	ldw	r22,24(sp)
 820d6c4:	dd400517 	ldw	r21,20(sp)
 820d6c8:	dd000417 	ldw	r20,16(sp)
 820d6cc:	dcc00317 	ldw	r19,12(sp)
 820d6d0:	dc800217 	ldw	r18,8(sp)
 820d6d4:	dc400117 	ldw	r17,4(sp)
 820d6d8:	dc000017 	ldw	r16,0(sp)
 820d6dc:	dec00a04 	addi	sp,sp,40
 820d6e0:	820ba381 	jmpi	820ba38 <_malloc_r>
 820d6e4:	a8c00017 	ldw	r3,0(r21)
 820d6e8:	90c00015 	stw	r3,0(r18)
 820d6ec:	a8c00117 	ldw	r3,4(r21)
 820d6f0:	90c00115 	stw	r3,4(r18)
 820d6f4:	00c006c4 	movi	r3,27
 820d6f8:	19804536 	bltu	r3,r6,820d810 <_realloc_r+0x470>
 820d6fc:	90800204 	addi	r2,r18,8
 820d700:	a8c00204 	addi	r3,r21,8
 820d704:	003f6306 	br	820d494 <_realloc_r+0xf4>
 820d708:	9005883a 	mov	r2,r18
 820d70c:	a8c00017 	ldw	r3,0(r21)
 820d710:	b821883a 	mov	r16,r23
 820d714:	b027883a 	mov	r19,r22
 820d718:	10c00015 	stw	r3,0(r2)
 820d71c:	a8c00117 	ldw	r3,4(r21)
 820d720:	10c00115 	stw	r3,4(r2)
 820d724:	a8c00217 	ldw	r3,8(r21)
 820d728:	10c00215 	stw	r3,8(r2)
 820d72c:	003f6a06 	br	820d4d8 <_realloc_r+0x138>
 820d730:	9c67883a 	add	r19,r19,r17
 820d734:	4445c83a 	sub	r2,r8,r17
 820d738:	e4c00215 	stw	r19,8(fp)
 820d73c:	10800054 	ori	r2,r2,1
 820d740:	98800115 	stw	r2,4(r19)
 820d744:	a8bfff17 	ldw	r2,-4(r21)
 820d748:	a009883a 	mov	r4,r20
 820d74c:	1080004c 	andi	r2,r2,1
 820d750:	1462b03a 	or	r17,r2,r17
 820d754:	ac7fff15 	stw	r17,-4(r21)
 820d758:	82148640 	call	8214864 <__malloc_unlock>
 820d75c:	a805883a 	mov	r2,r21
 820d760:	003f6b06 	br	820d510 <_realloc_r+0x170>
 820d764:	a80b883a 	mov	r5,r21
 820d768:	9009883a 	mov	r4,r18
 820d76c:	8202da40 	call	8202da4 <memmove>
 820d770:	003f4e06 	br	820d4ac <_realloc_r+0x10c>
 820d774:	89000404 	addi	r4,r17,16
 820d778:	b93fbc16 	blt	r23,r4,820d66c <_realloc_r+0x2cc>
 820d77c:	b0800317 	ldw	r2,12(r22)
 820d780:	b0c00217 	ldw	r3,8(r22)
 820d784:	81bfff04 	addi	r6,r16,-4
 820d788:	01000904 	movi	r4,36
 820d78c:	18800315 	stw	r2,12(r3)
 820d790:	10c00215 	stw	r3,8(r2)
 820d794:	b4800204 	addi	r18,r22,8
 820d798:	21804336 	bltu	r4,r6,820d8a8 <_realloc_r+0x508>
 820d79c:	008004c4 	movi	r2,19
 820d7a0:	11803f2e 	bgeu	r2,r6,820d8a0 <_realloc_r+0x500>
 820d7a4:	a8800017 	ldw	r2,0(r21)
 820d7a8:	b0800215 	stw	r2,8(r22)
 820d7ac:	a8800117 	ldw	r2,4(r21)
 820d7b0:	b0800315 	stw	r2,12(r22)
 820d7b4:	008006c4 	movi	r2,27
 820d7b8:	11803f36 	bltu	r2,r6,820d8b8 <_realloc_r+0x518>
 820d7bc:	b0800404 	addi	r2,r22,16
 820d7c0:	ad400204 	addi	r21,r21,8
 820d7c4:	a8c00017 	ldw	r3,0(r21)
 820d7c8:	10c00015 	stw	r3,0(r2)
 820d7cc:	a8c00117 	ldw	r3,4(r21)
 820d7d0:	10c00115 	stw	r3,4(r2)
 820d7d4:	a8c00217 	ldw	r3,8(r21)
 820d7d8:	10c00215 	stw	r3,8(r2)
 820d7dc:	b447883a 	add	r3,r22,r17
 820d7e0:	bc45c83a 	sub	r2,r23,r17
 820d7e4:	e0c00215 	stw	r3,8(fp)
 820d7e8:	10800054 	ori	r2,r2,1
 820d7ec:	18800115 	stw	r2,4(r3)
 820d7f0:	b0800117 	ldw	r2,4(r22)
 820d7f4:	a009883a 	mov	r4,r20
 820d7f8:	1080004c 	andi	r2,r2,1
 820d7fc:	1462b03a 	or	r17,r2,r17
 820d800:	b4400115 	stw	r17,4(r22)
 820d804:	82148640 	call	8214864 <__malloc_unlock>
 820d808:	9005883a 	mov	r2,r18
 820d80c:	003f4006 	br	820d510 <_realloc_r+0x170>
 820d810:	a8c00217 	ldw	r3,8(r21)
 820d814:	90c00215 	stw	r3,8(r18)
 820d818:	a8c00317 	ldw	r3,12(r21)
 820d81c:	90c00315 	stw	r3,12(r18)
 820d820:	30801126 	beq	r6,r2,820d868 <_realloc_r+0x4c8>
 820d824:	90800404 	addi	r2,r18,16
 820d828:	a8c00404 	addi	r3,r21,16
 820d82c:	003f1906 	br	820d494 <_realloc_r+0xf4>
 820d830:	90ffff17 	ldw	r3,-4(r18)
 820d834:	00bfff04 	movi	r2,-4
 820d838:	a825883a 	mov	r18,r21
 820d83c:	1884703a 	and	r2,r3,r2
 820d840:	80a1883a 	add	r16,r16,r2
 820d844:	003f2406 	br	820d4d8 <_realloc_r+0x138>
 820d848:	a8800217 	ldw	r2,8(r21)
 820d84c:	b0800415 	stw	r2,16(r22)
 820d850:	a8800317 	ldw	r2,12(r21)
 820d854:	b0800515 	stw	r2,20(r22)
 820d858:	31000a26 	beq	r6,r4,820d884 <_realloc_r+0x4e4>
 820d85c:	b0800604 	addi	r2,r22,24
 820d860:	ad400404 	addi	r21,r21,16
 820d864:	003fa906 	br	820d70c <_realloc_r+0x36c>
 820d868:	a9000417 	ldw	r4,16(r21)
 820d86c:	90800604 	addi	r2,r18,24
 820d870:	a8c00604 	addi	r3,r21,24
 820d874:	91000415 	stw	r4,16(r18)
 820d878:	a9000517 	ldw	r4,20(r21)
 820d87c:	91000515 	stw	r4,20(r18)
 820d880:	003f0406 	br	820d494 <_realloc_r+0xf4>
 820d884:	a8c00417 	ldw	r3,16(r21)
 820d888:	ad400604 	addi	r21,r21,24
 820d88c:	b0800804 	addi	r2,r22,32
 820d890:	b0c00615 	stw	r3,24(r22)
 820d894:	a8ffff17 	ldw	r3,-4(r21)
 820d898:	b0c00715 	stw	r3,28(r22)
 820d89c:	003f9b06 	br	820d70c <_realloc_r+0x36c>
 820d8a0:	9005883a 	mov	r2,r18
 820d8a4:	003fc706 	br	820d7c4 <_realloc_r+0x424>
 820d8a8:	a80b883a 	mov	r5,r21
 820d8ac:	9009883a 	mov	r4,r18
 820d8b0:	8202da40 	call	8202da4 <memmove>
 820d8b4:	003fc906 	br	820d7dc <_realloc_r+0x43c>
 820d8b8:	a8800217 	ldw	r2,8(r21)
 820d8bc:	b0800415 	stw	r2,16(r22)
 820d8c0:	a8800317 	ldw	r2,12(r21)
 820d8c4:	b0800515 	stw	r2,20(r22)
 820d8c8:	31000726 	beq	r6,r4,820d8e8 <_realloc_r+0x548>
 820d8cc:	b0800604 	addi	r2,r22,24
 820d8d0:	ad400404 	addi	r21,r21,16
 820d8d4:	003fbb06 	br	820d7c4 <_realloc_r+0x424>
 820d8d8:	a009883a 	mov	r4,r20
 820d8dc:	82148640 	call	8214864 <__malloc_unlock>
 820d8e0:	0005883a 	mov	r2,zero
 820d8e4:	003f0a06 	br	820d510 <_realloc_r+0x170>
 820d8e8:	a8c00417 	ldw	r3,16(r21)
 820d8ec:	ad400604 	addi	r21,r21,24
 820d8f0:	b0800804 	addi	r2,r22,32
 820d8f4:	b0c00615 	stw	r3,24(r22)
 820d8f8:	a8ffff17 	ldw	r3,-4(r21)
 820d8fc:	b0c00715 	stw	r3,28(r22)
 820d900:	003fb006 	br	820d7c4 <_realloc_r+0x424>

0820d904 <lflush>:
 820d904:	2080030b 	ldhu	r2,12(r4)
 820d908:	00c00244 	movi	r3,9
 820d90c:	1080024c 	andi	r2,r2,9
 820d910:	10c00226 	beq	r2,r3,820d91c <lflush+0x18>
 820d914:	0005883a 	mov	r2,zero
 820d918:	f800283a 	ret
 820d91c:	820a8041 	jmpi	820a804 <fflush>

0820d920 <__srefill_r>:
 820d920:	defffc04 	addi	sp,sp,-16
 820d924:	dc400115 	stw	r17,4(sp)
 820d928:	dc000015 	stw	r16,0(sp)
 820d92c:	dfc00315 	stw	ra,12(sp)
 820d930:	dc800215 	stw	r18,8(sp)
 820d934:	2023883a 	mov	r17,r4
 820d938:	2821883a 	mov	r16,r5
 820d93c:	20000226 	beq	r4,zero,820d948 <__srefill_r+0x28>
 820d940:	20800e17 	ldw	r2,56(r4)
 820d944:	10003c26 	beq	r2,zero,820da38 <__srefill_r+0x118>
 820d948:	80c0030b 	ldhu	r3,12(r16)
 820d94c:	1908000c 	andi	r4,r3,8192
 820d950:	1805883a 	mov	r2,r3
 820d954:	2000071e 	bne	r4,zero,820d974 <__srefill_r+0x54>
 820d958:	81001917 	ldw	r4,100(r16)
 820d95c:	18880014 	ori	r2,r3,8192
 820d960:	00f7ffc4 	movi	r3,-8193
 820d964:	20c8703a 	and	r4,r4,r3
 820d968:	8080030d 	sth	r2,12(r16)
 820d96c:	1007883a 	mov	r3,r2
 820d970:	81001915 	stw	r4,100(r16)
 820d974:	80000115 	stw	zero,4(r16)
 820d978:	1100080c 	andi	r4,r2,32
 820d97c:	2000571e 	bne	r4,zero,820dadc <__srefill_r+0x1bc>
 820d980:	1100010c 	andi	r4,r2,4
 820d984:	20001f26 	beq	r4,zero,820da04 <__srefill_r+0xe4>
 820d988:	81400c17 	ldw	r5,48(r16)
 820d98c:	28000826 	beq	r5,zero,820d9b0 <__srefill_r+0x90>
 820d990:	80801004 	addi	r2,r16,64
 820d994:	28800226 	beq	r5,r2,820d9a0 <__srefill_r+0x80>
 820d998:	8809883a 	mov	r4,r17
 820d99c:	820ae4c0 	call	820ae4c <_free_r>
 820d9a0:	80800f17 	ldw	r2,60(r16)
 820d9a4:	80000c15 	stw	zero,48(r16)
 820d9a8:	80800115 	stw	r2,4(r16)
 820d9ac:	1000391e 	bne	r2,zero,820da94 <__srefill_r+0x174>
 820d9b0:	80800417 	ldw	r2,16(r16)
 820d9b4:	10004b26 	beq	r2,zero,820dae4 <__srefill_r+0x1c4>
 820d9b8:	8480030b 	ldhu	r18,12(r16)
 820d9bc:	908000cc 	andi	r2,r18,3
 820d9c0:	10001f1e 	bne	r2,zero,820da40 <__srefill_r+0x120>
 820d9c4:	81800417 	ldw	r6,16(r16)
 820d9c8:	80800817 	ldw	r2,32(r16)
 820d9cc:	81c00517 	ldw	r7,20(r16)
 820d9d0:	81400717 	ldw	r5,28(r16)
 820d9d4:	81800015 	stw	r6,0(r16)
 820d9d8:	8809883a 	mov	r4,r17
 820d9dc:	103ee83a 	callr	r2
 820d9e0:	80800115 	stw	r2,4(r16)
 820d9e4:	00800e0e 	bge	zero,r2,820da20 <__srefill_r+0x100>
 820d9e8:	0005883a 	mov	r2,zero
 820d9ec:	dfc00317 	ldw	ra,12(sp)
 820d9f0:	dc800217 	ldw	r18,8(sp)
 820d9f4:	dc400117 	ldw	r17,4(sp)
 820d9f8:	dc000017 	ldw	r16,0(sp)
 820d9fc:	dec00404 	addi	sp,sp,16
 820da00:	f800283a 	ret
 820da04:	1100040c 	andi	r4,r2,16
 820da08:	20003026 	beq	r4,zero,820dacc <__srefill_r+0x1ac>
 820da0c:	1080020c 	andi	r2,r2,8
 820da10:	1000241e 	bne	r2,zero,820daa4 <__srefill_r+0x184>
 820da14:	18c00114 	ori	r3,r3,4
 820da18:	80c0030d 	sth	r3,12(r16)
 820da1c:	003fe406 	br	820d9b0 <__srefill_r+0x90>
 820da20:	80c0030b 	ldhu	r3,12(r16)
 820da24:	1000161e 	bne	r2,zero,820da80 <__srefill_r+0x160>
 820da28:	18c00814 	ori	r3,r3,32
 820da2c:	00bfffc4 	movi	r2,-1
 820da30:	80c0030d 	sth	r3,12(r16)
 820da34:	003fed06 	br	820d9ec <__srefill_r+0xcc>
 820da38:	820ab840 	call	820ab84 <__sinit>
 820da3c:	003fc206 	br	820d948 <__srefill_r+0x28>
 820da40:	00820974 	movhi	r2,2085
 820da44:	108eb704 	addi	r2,r2,15068
 820da48:	11000017 	ldw	r4,0(r2)
 820da4c:	01420874 	movhi	r5,2081
 820da50:	00800044 	movi	r2,1
 820da54:	29764104 	addi	r5,r5,-9980
 820da58:	8080030d 	sth	r2,12(r16)
 820da5c:	820b6180 	call	820b618 <_fwalk>
 820da60:	00800244 	movi	r2,9
 820da64:	8480030d 	sth	r18,12(r16)
 820da68:	9480024c 	andi	r18,r18,9
 820da6c:	90bfd51e 	bne	r18,r2,820d9c4 <__srefill_r+0xa4>
 820da70:	800b883a 	mov	r5,r16
 820da74:	8809883a 	mov	r4,r17
 820da78:	820a58c0 	call	820a58c <__sflush_r>
 820da7c:	003fd106 	br	820d9c4 <__srefill_r+0xa4>
 820da80:	18c01014 	ori	r3,r3,64
 820da84:	80000115 	stw	zero,4(r16)
 820da88:	00bfffc4 	movi	r2,-1
 820da8c:	80c0030d 	sth	r3,12(r16)
 820da90:	003fd606 	br	820d9ec <__srefill_r+0xcc>
 820da94:	80c00e17 	ldw	r3,56(r16)
 820da98:	0005883a 	mov	r2,zero
 820da9c:	80c00015 	stw	r3,0(r16)
 820daa0:	003fd206 	br	820d9ec <__srefill_r+0xcc>
 820daa4:	800b883a 	mov	r5,r16
 820daa8:	8809883a 	mov	r4,r17
 820daac:	820a7a80 	call	820a7a8 <_fflush_r>
 820dab0:	10000a1e 	bne	r2,zero,820dadc <__srefill_r+0x1bc>
 820dab4:	8080030b 	ldhu	r2,12(r16)
 820dab8:	00fffdc4 	movi	r3,-9
 820dabc:	80000215 	stw	zero,8(r16)
 820dac0:	1886703a 	and	r3,r3,r2
 820dac4:	80000615 	stw	zero,24(r16)
 820dac8:	003fd206 	br	820da14 <__srefill_r+0xf4>
 820dacc:	00800244 	movi	r2,9
 820dad0:	88800015 	stw	r2,0(r17)
 820dad4:	18c01014 	ori	r3,r3,64
 820dad8:	80c0030d 	sth	r3,12(r16)
 820dadc:	00bfffc4 	movi	r2,-1
 820dae0:	003fc206 	br	820d9ec <__srefill_r+0xcc>
 820dae4:	800b883a 	mov	r5,r16
 820dae8:	8809883a 	mov	r4,r17
 820daec:	820b87c0 	call	820b87c <__smakebuf_r>
 820daf0:	003fb106 	br	820d9b8 <__srefill_r+0x98>

0820daf4 <__fpclassifyd>:
 820daf4:	00a00034 	movhi	r2,32768
 820daf8:	10bfffc4 	addi	r2,r2,-1
 820dafc:	2884703a 	and	r2,r5,r2
 820db00:	10000726 	beq	r2,zero,820db20 <__fpclassifyd+0x2c>
 820db04:	00fffc34 	movhi	r3,65520
 820db08:	019ff834 	movhi	r6,32736
 820db0c:	28c7883a 	add	r3,r5,r3
 820db10:	31bfffc4 	addi	r6,r6,-1
 820db14:	30c00536 	bltu	r6,r3,820db2c <__fpclassifyd+0x38>
 820db18:	00800104 	movi	r2,4
 820db1c:	f800283a 	ret
 820db20:	2000021e 	bne	r4,zero,820db2c <__fpclassifyd+0x38>
 820db24:	00800084 	movi	r2,2
 820db28:	f800283a 	ret
 820db2c:	00dffc34 	movhi	r3,32752
 820db30:	019ff834 	movhi	r6,32736
 820db34:	28cb883a 	add	r5,r5,r3
 820db38:	31bfffc4 	addi	r6,r6,-1
 820db3c:	317ff62e 	bgeu	r6,r5,820db18 <__fpclassifyd+0x24>
 820db40:	01400434 	movhi	r5,16
 820db44:	297fffc4 	addi	r5,r5,-1
 820db48:	28800236 	bltu	r5,r2,820db54 <__fpclassifyd+0x60>
 820db4c:	008000c4 	movi	r2,3
 820db50:	f800283a 	ret
 820db54:	10c00226 	beq	r2,r3,820db60 <__fpclassifyd+0x6c>
 820db58:	0005883a 	mov	r2,zero
 820db5c:	f800283a 	ret
 820db60:	2005003a 	cmpeq	r2,r4,zero
 820db64:	f800283a 	ret

0820db68 <_sbrk_r>:
 820db68:	defffd04 	addi	sp,sp,-12
 820db6c:	dc000015 	stw	r16,0(sp)
 820db70:	04020974 	movhi	r16,2085
 820db74:	dc400115 	stw	r17,4(sp)
 820db78:	840f1904 	addi	r16,r16,15460
 820db7c:	2023883a 	mov	r17,r4
 820db80:	2809883a 	mov	r4,r5
 820db84:	dfc00215 	stw	ra,8(sp)
 820db88:	80000015 	stw	zero,0(r16)
 820db8c:	82145700 	call	8214570 <sbrk>
 820db90:	00ffffc4 	movi	r3,-1
 820db94:	10c00526 	beq	r2,r3,820dbac <_sbrk_r+0x44>
 820db98:	dfc00217 	ldw	ra,8(sp)
 820db9c:	dc400117 	ldw	r17,4(sp)
 820dba0:	dc000017 	ldw	r16,0(sp)
 820dba4:	dec00304 	addi	sp,sp,12
 820dba8:	f800283a 	ret
 820dbac:	80c00017 	ldw	r3,0(r16)
 820dbb0:	183ff926 	beq	r3,zero,820db98 <_sbrk_r+0x30>
 820dbb4:	88c00015 	stw	r3,0(r17)
 820dbb8:	003ff706 	br	820db98 <_sbrk_r+0x30>

0820dbbc <__sread>:
 820dbbc:	defffe04 	addi	sp,sp,-8
 820dbc0:	dc000015 	stw	r16,0(sp)
 820dbc4:	2821883a 	mov	r16,r5
 820dbc8:	2940038f 	ldh	r5,14(r5)
 820dbcc:	dfc00115 	stw	ra,4(sp)
 820dbd0:	8210dbc0 	call	8210dbc <_read_r>
 820dbd4:	10000716 	blt	r2,zero,820dbf4 <__sread+0x38>
 820dbd8:	80c01417 	ldw	r3,80(r16)
 820dbdc:	1887883a 	add	r3,r3,r2
 820dbe0:	80c01415 	stw	r3,80(r16)
 820dbe4:	dfc00117 	ldw	ra,4(sp)
 820dbe8:	dc000017 	ldw	r16,0(sp)
 820dbec:	dec00204 	addi	sp,sp,8
 820dbf0:	f800283a 	ret
 820dbf4:	80c0030b 	ldhu	r3,12(r16)
 820dbf8:	18fbffcc 	andi	r3,r3,61439
 820dbfc:	80c0030d 	sth	r3,12(r16)
 820dc00:	dfc00117 	ldw	ra,4(sp)
 820dc04:	dc000017 	ldw	r16,0(sp)
 820dc08:	dec00204 	addi	sp,sp,8
 820dc0c:	f800283a 	ret

0820dc10 <__seofread>:
 820dc10:	0005883a 	mov	r2,zero
 820dc14:	f800283a 	ret

0820dc18 <__swrite>:
 820dc18:	2880030b 	ldhu	r2,12(r5)
 820dc1c:	defffb04 	addi	sp,sp,-20
 820dc20:	dcc00315 	stw	r19,12(sp)
 820dc24:	dc800215 	stw	r18,8(sp)
 820dc28:	dc400115 	stw	r17,4(sp)
 820dc2c:	dc000015 	stw	r16,0(sp)
 820dc30:	dfc00415 	stw	ra,16(sp)
 820dc34:	10c0400c 	andi	r3,r2,256
 820dc38:	2821883a 	mov	r16,r5
 820dc3c:	2023883a 	mov	r17,r4
 820dc40:	3025883a 	mov	r18,r6
 820dc44:	3827883a 	mov	r19,r7
 820dc48:	18000526 	beq	r3,zero,820dc60 <__swrite+0x48>
 820dc4c:	2940038f 	ldh	r5,14(r5)
 820dc50:	01c00084 	movi	r7,2
 820dc54:	000d883a 	mov	r6,zero
 820dc58:	8210d5c0 	call	8210d5c <_lseek_r>
 820dc5c:	8080030b 	ldhu	r2,12(r16)
 820dc60:	8140038f 	ldh	r5,14(r16)
 820dc64:	10bbffcc 	andi	r2,r2,61439
 820dc68:	980f883a 	mov	r7,r19
 820dc6c:	900d883a 	mov	r6,r18
 820dc70:	8809883a 	mov	r4,r17
 820dc74:	8080030d 	sth	r2,12(r16)
 820dc78:	dfc00417 	ldw	ra,16(sp)
 820dc7c:	dcc00317 	ldw	r19,12(sp)
 820dc80:	dc800217 	ldw	r18,8(sp)
 820dc84:	dc400117 	ldw	r17,4(sp)
 820dc88:	dc000017 	ldw	r16,0(sp)
 820dc8c:	dec00504 	addi	sp,sp,20
 820dc90:	82108281 	jmpi	8210828 <_write_r>

0820dc94 <__sseek>:
 820dc94:	defffe04 	addi	sp,sp,-8
 820dc98:	dc000015 	stw	r16,0(sp)
 820dc9c:	2821883a 	mov	r16,r5
 820dca0:	2940038f 	ldh	r5,14(r5)
 820dca4:	dfc00115 	stw	ra,4(sp)
 820dca8:	8210d5c0 	call	8210d5c <_lseek_r>
 820dcac:	00ffffc4 	movi	r3,-1
 820dcb0:	10c00826 	beq	r2,r3,820dcd4 <__sseek+0x40>
 820dcb4:	80c0030b 	ldhu	r3,12(r16)
 820dcb8:	80801415 	stw	r2,80(r16)
 820dcbc:	18c40014 	ori	r3,r3,4096
 820dcc0:	80c0030d 	sth	r3,12(r16)
 820dcc4:	dfc00117 	ldw	ra,4(sp)
 820dcc8:	dc000017 	ldw	r16,0(sp)
 820dccc:	dec00204 	addi	sp,sp,8
 820dcd0:	f800283a 	ret
 820dcd4:	80c0030b 	ldhu	r3,12(r16)
 820dcd8:	18fbffcc 	andi	r3,r3,61439
 820dcdc:	80c0030d 	sth	r3,12(r16)
 820dce0:	dfc00117 	ldw	ra,4(sp)
 820dce4:	dc000017 	ldw	r16,0(sp)
 820dce8:	dec00204 	addi	sp,sp,8
 820dcec:	f800283a 	ret

0820dcf0 <__sclose>:
 820dcf0:	2940038f 	ldh	r5,14(r5)
 820dcf4:	82108881 	jmpi	8210888 <_close_r>

0820dcf8 <strcmp>:
 820dcf8:	2144b03a 	or	r2,r4,r5
 820dcfc:	108000cc 	andi	r2,r2,3
 820dd00:	1000171e 	bne	r2,zero,820dd60 <strcmp+0x68>
 820dd04:	20800017 	ldw	r2,0(r4)
 820dd08:	28c00017 	ldw	r3,0(r5)
 820dd0c:	10c0141e 	bne	r2,r3,820dd60 <strcmp+0x68>
 820dd10:	027fbff4 	movhi	r9,65279
 820dd14:	4a7fbfc4 	addi	r9,r9,-257
 820dd18:	0086303a 	nor	r3,zero,r2
 820dd1c:	02202074 	movhi	r8,32897
 820dd20:	1245883a 	add	r2,r2,r9
 820dd24:	42202004 	addi	r8,r8,-32640
 820dd28:	10c4703a 	and	r2,r2,r3
 820dd2c:	1204703a 	and	r2,r2,r8
 820dd30:	10000226 	beq	r2,zero,820dd3c <strcmp+0x44>
 820dd34:	00002306 	br	820ddc4 <strcmp+0xcc>
 820dd38:	1000221e 	bne	r2,zero,820ddc4 <strcmp+0xcc>
 820dd3c:	21000104 	addi	r4,r4,4
 820dd40:	20c00017 	ldw	r3,0(r4)
 820dd44:	29400104 	addi	r5,r5,4
 820dd48:	29800017 	ldw	r6,0(r5)
 820dd4c:	1a4f883a 	add	r7,r3,r9
 820dd50:	00c4303a 	nor	r2,zero,r3
 820dd54:	3884703a 	and	r2,r7,r2
 820dd58:	1204703a 	and	r2,r2,r8
 820dd5c:	19bff626 	beq	r3,r6,820dd38 <strcmp+0x40>
 820dd60:	20800003 	ldbu	r2,0(r4)
 820dd64:	10c03fcc 	andi	r3,r2,255
 820dd68:	18c0201c 	xori	r3,r3,128
 820dd6c:	18ffe004 	addi	r3,r3,-128
 820dd70:	18000c26 	beq	r3,zero,820dda4 <strcmp+0xac>
 820dd74:	29800007 	ldb	r6,0(r5)
 820dd78:	19800326 	beq	r3,r6,820dd88 <strcmp+0x90>
 820dd7c:	00001306 	br	820ddcc <strcmp+0xd4>
 820dd80:	29800007 	ldb	r6,0(r5)
 820dd84:	11800b1e 	bne	r2,r6,820ddb4 <strcmp+0xbc>
 820dd88:	21000044 	addi	r4,r4,1
 820dd8c:	20c00003 	ldbu	r3,0(r4)
 820dd90:	29400044 	addi	r5,r5,1
 820dd94:	18803fcc 	andi	r2,r3,255
 820dd98:	1080201c 	xori	r2,r2,128
 820dd9c:	10bfe004 	addi	r2,r2,-128
 820dda0:	103ff71e 	bne	r2,zero,820dd80 <strcmp+0x88>
 820dda4:	0007883a 	mov	r3,zero
 820dda8:	28800003 	ldbu	r2,0(r5)
 820ddac:	1885c83a 	sub	r2,r3,r2
 820ddb0:	f800283a 	ret
 820ddb4:	28800003 	ldbu	r2,0(r5)
 820ddb8:	18c03fcc 	andi	r3,r3,255
 820ddbc:	1885c83a 	sub	r2,r3,r2
 820ddc0:	f800283a 	ret
 820ddc4:	0005883a 	mov	r2,zero
 820ddc8:	f800283a 	ret
 820ddcc:	10c03fcc 	andi	r3,r2,255
 820ddd0:	003ff506 	br	820dda8 <strcmp+0xb0>

0820ddd4 <__ssprint_r>:
 820ddd4:	30800217 	ldw	r2,8(r6)
 820ddd8:	defff604 	addi	sp,sp,-40
 820dddc:	dc800215 	stw	r18,8(sp)
 820dde0:	dfc00915 	stw	ra,36(sp)
 820dde4:	df000815 	stw	fp,32(sp)
 820dde8:	ddc00715 	stw	r23,28(sp)
 820ddec:	dd800615 	stw	r22,24(sp)
 820ddf0:	dd400515 	stw	r21,20(sp)
 820ddf4:	dd000415 	stw	r20,16(sp)
 820ddf8:	dcc00315 	stw	r19,12(sp)
 820ddfc:	dc400115 	stw	r17,4(sp)
 820de00:	dc000015 	stw	r16,0(sp)
 820de04:	3025883a 	mov	r18,r6
 820de08:	10005826 	beq	r2,zero,820df6c <__ssprint_r+0x198>
 820de0c:	2027883a 	mov	r19,r4
 820de10:	35c00017 	ldw	r23,0(r6)
 820de14:	29000017 	ldw	r4,0(r5)
 820de18:	28800217 	ldw	r2,8(r5)
 820de1c:	2823883a 	mov	r17,r5
 820de20:	0039883a 	mov	fp,zero
 820de24:	0021883a 	mov	r16,zero
 820de28:	80003926 	beq	r16,zero,820df10 <__ssprint_r+0x13c>
 820de2c:	102b883a 	mov	r21,r2
 820de30:	102d883a 	mov	r22,r2
 820de34:	80803a36 	bltu	r16,r2,820df20 <__ssprint_r+0x14c>
 820de38:	88c0030b 	ldhu	r3,12(r17)
 820de3c:	1881200c 	andi	r2,r3,1152
 820de40:	10002626 	beq	r2,zero,820dedc <__ssprint_r+0x108>
 820de44:	88800517 	ldw	r2,20(r17)
 820de48:	89400417 	ldw	r5,16(r17)
 820de4c:	81800044 	addi	r6,r16,1
 820de50:	108f883a 	add	r7,r2,r2
 820de54:	3885883a 	add	r2,r7,r2
 820de58:	100ed7fa 	srli	r7,r2,31
 820de5c:	216dc83a 	sub	r22,r4,r5
 820de60:	3589883a 	add	r4,r6,r22
 820de64:	3885883a 	add	r2,r7,r2
 820de68:	102bd07a 	srai	r21,r2,1
 820de6c:	a80d883a 	mov	r6,r21
 820de70:	a900022e 	bgeu	r21,r4,820de7c <__ssprint_r+0xa8>
 820de74:	202b883a 	mov	r21,r4
 820de78:	200d883a 	mov	r6,r4
 820de7c:	18c1000c 	andi	r3,r3,1024
 820de80:	18002a26 	beq	r3,zero,820df2c <__ssprint_r+0x158>
 820de84:	300b883a 	mov	r5,r6
 820de88:	9809883a 	mov	r4,r19
 820de8c:	820ba380 	call	820ba38 <_malloc_r>
 820de90:	1029883a 	mov	r20,r2
 820de94:	10002c26 	beq	r2,zero,820df48 <__ssprint_r+0x174>
 820de98:	89400417 	ldw	r5,16(r17)
 820de9c:	b00d883a 	mov	r6,r22
 820dea0:	1009883a 	mov	r4,r2
 820dea4:	8202c5c0 	call	8202c5c <memcpy>
 820dea8:	8880030b 	ldhu	r2,12(r17)
 820deac:	00fedfc4 	movi	r3,-1153
 820deb0:	10c4703a 	and	r2,r2,r3
 820deb4:	10802014 	ori	r2,r2,128
 820deb8:	8880030d 	sth	r2,12(r17)
 820debc:	a589883a 	add	r4,r20,r22
 820dec0:	adadc83a 	sub	r22,r21,r22
 820dec4:	8d400515 	stw	r21,20(r17)
 820dec8:	8d800215 	stw	r22,8(r17)
 820decc:	8d000415 	stw	r20,16(r17)
 820ded0:	89000015 	stw	r4,0(r17)
 820ded4:	802b883a 	mov	r21,r16
 820ded8:	802d883a 	mov	r22,r16
 820dedc:	b00d883a 	mov	r6,r22
 820dee0:	e00b883a 	mov	r5,fp
 820dee4:	8202da40 	call	8202da4 <memmove>
 820dee8:	88800217 	ldw	r2,8(r17)
 820deec:	89000017 	ldw	r4,0(r17)
 820def0:	90c00217 	ldw	r3,8(r18)
 820def4:	1545c83a 	sub	r2,r2,r21
 820def8:	2589883a 	add	r4,r4,r22
 820defc:	88800215 	stw	r2,8(r17)
 820df00:	89000015 	stw	r4,0(r17)
 820df04:	1c21c83a 	sub	r16,r3,r16
 820df08:	94000215 	stw	r16,8(r18)
 820df0c:	80001726 	beq	r16,zero,820df6c <__ssprint_r+0x198>
 820df10:	bf000017 	ldw	fp,0(r23)
 820df14:	bc000117 	ldw	r16,4(r23)
 820df18:	bdc00204 	addi	r23,r23,8
 820df1c:	003fc206 	br	820de28 <__ssprint_r+0x54>
 820df20:	802b883a 	mov	r21,r16
 820df24:	802d883a 	mov	r22,r16
 820df28:	003fec06 	br	820dedc <__ssprint_r+0x108>
 820df2c:	9809883a 	mov	r4,r19
 820df30:	820d3a00 	call	820d3a0 <_realloc_r>
 820df34:	1029883a 	mov	r20,r2
 820df38:	103fe01e 	bne	r2,zero,820debc <__ssprint_r+0xe8>
 820df3c:	89400417 	ldw	r5,16(r17)
 820df40:	9809883a 	mov	r4,r19
 820df44:	820ae4c0 	call	820ae4c <_free_r>
 820df48:	88c0030b 	ldhu	r3,12(r17)
 820df4c:	00800304 	movi	r2,12
 820df50:	98800015 	stw	r2,0(r19)
 820df54:	18c01014 	ori	r3,r3,64
 820df58:	88c0030d 	sth	r3,12(r17)
 820df5c:	00bfffc4 	movi	r2,-1
 820df60:	90000215 	stw	zero,8(r18)
 820df64:	90000115 	stw	zero,4(r18)
 820df68:	00000206 	br	820df74 <__ssprint_r+0x1a0>
 820df6c:	90000115 	stw	zero,4(r18)
 820df70:	0005883a 	mov	r2,zero
 820df74:	dfc00917 	ldw	ra,36(sp)
 820df78:	df000817 	ldw	fp,32(sp)
 820df7c:	ddc00717 	ldw	r23,28(sp)
 820df80:	dd800617 	ldw	r22,24(sp)
 820df84:	dd400517 	ldw	r21,20(sp)
 820df88:	dd000417 	ldw	r20,16(sp)
 820df8c:	dcc00317 	ldw	r19,12(sp)
 820df90:	dc800217 	ldw	r18,8(sp)
 820df94:	dc400117 	ldw	r17,4(sp)
 820df98:	dc000017 	ldw	r16,0(sp)
 820df9c:	dec00a04 	addi	sp,sp,40
 820dfa0:	f800283a 	ret

0820dfa4 <___svfiprintf_internal_r>:
 820dfa4:	2880030b 	ldhu	r2,12(r5)
 820dfa8:	deffc804 	addi	sp,sp,-224
 820dfac:	dcc03115 	stw	r19,196(sp)
 820dfb0:	dfc03715 	stw	ra,220(sp)
 820dfb4:	df003615 	stw	fp,216(sp)
 820dfb8:	ddc03515 	stw	r23,212(sp)
 820dfbc:	dd803415 	stw	r22,208(sp)
 820dfc0:	dd403315 	stw	r21,204(sp)
 820dfc4:	dd003215 	stw	r20,200(sp)
 820dfc8:	dc803015 	stw	r18,192(sp)
 820dfcc:	dc402f15 	stw	r17,188(sp)
 820dfd0:	dc002e15 	stw	r16,184(sp)
 820dfd4:	d9402715 	stw	r5,156(sp)
 820dfd8:	d9002a15 	stw	r4,168(sp)
 820dfdc:	1080200c 	andi	r2,r2,128
 820dfe0:	d9c02315 	stw	r7,140(sp)
 820dfe4:	3027883a 	mov	r19,r6
 820dfe8:	10000226 	beq	r2,zero,820dff4 <___svfiprintf_internal_r+0x50>
 820dfec:	28800417 	ldw	r2,16(r5)
 820dff0:	10041d26 	beq	r2,zero,820f068 <___svfiprintf_internal_r+0x10c4>
 820dff4:	dac01a04 	addi	r11,sp,104
 820dff8:	dac01e15 	stw	r11,120(sp)
 820dffc:	d8801e17 	ldw	r2,120(sp)
 820e000:	dac019c4 	addi	r11,sp,103
 820e004:	dd402a17 	ldw	r21,168(sp)
 820e008:	ddc02717 	ldw	r23,156(sp)
 820e00c:	05820974 	movhi	r22,2085
 820e010:	05020974 	movhi	r20,2085
 820e014:	dac01f15 	stw	r11,124(sp)
 820e018:	12d7c83a 	sub	r11,r2,r11
 820e01c:	b5b64e04 	addi	r22,r22,-9928
 820e020:	a5364a04 	addi	r20,r20,-9944
 820e024:	dec01a15 	stw	sp,104(sp)
 820e028:	d8001c15 	stw	zero,112(sp)
 820e02c:	d8001b15 	stw	zero,108(sp)
 820e030:	d811883a 	mov	r8,sp
 820e034:	d8002915 	stw	zero,164(sp)
 820e038:	d8002515 	stw	zero,148(sp)
 820e03c:	dac02b15 	stw	r11,172(sp)
 820e040:	98800007 	ldb	r2,0(r19)
 820e044:	1002dd26 	beq	r2,zero,820ebbc <___svfiprintf_internal_r+0xc18>
 820e048:	00c00944 	movi	r3,37
 820e04c:	9823883a 	mov	r17,r19
 820e050:	10c0021e 	bne	r2,r3,820e05c <___svfiprintf_internal_r+0xb8>
 820e054:	00001406 	br	820e0a8 <___svfiprintf_internal_r+0x104>
 820e058:	10c00326 	beq	r2,r3,820e068 <___svfiprintf_internal_r+0xc4>
 820e05c:	8c400044 	addi	r17,r17,1
 820e060:	88800007 	ldb	r2,0(r17)
 820e064:	103ffc1e 	bne	r2,zero,820e058 <___svfiprintf_internal_r+0xb4>
 820e068:	8ce1c83a 	sub	r16,r17,r19
 820e06c:	80000e26 	beq	r16,zero,820e0a8 <___svfiprintf_internal_r+0x104>
 820e070:	d8c01c17 	ldw	r3,112(sp)
 820e074:	d8801b17 	ldw	r2,108(sp)
 820e078:	44c00015 	stw	r19,0(r8)
 820e07c:	1c07883a 	add	r3,r3,r16
 820e080:	10800044 	addi	r2,r2,1
 820e084:	d8c01c15 	stw	r3,112(sp)
 820e088:	44000115 	stw	r16,4(r8)
 820e08c:	d8801b15 	stw	r2,108(sp)
 820e090:	00c001c4 	movi	r3,7
 820e094:	18831e16 	blt	r3,r2,820ed10 <___svfiprintf_internal_r+0xd6c>
 820e098:	42000204 	addi	r8,r8,8
 820e09c:	dac02517 	ldw	r11,148(sp)
 820e0a0:	5c17883a 	add	r11,r11,r16
 820e0a4:	dac02515 	stw	r11,148(sp)
 820e0a8:	88800007 	ldb	r2,0(r17)
 820e0ac:	1002c526 	beq	r2,zero,820ebc4 <___svfiprintf_internal_r+0xc20>
 820e0b0:	88c00047 	ldb	r3,1(r17)
 820e0b4:	8cc00044 	addi	r19,r17,1
 820e0b8:	d8001d85 	stb	zero,118(sp)
 820e0bc:	0009883a 	mov	r4,zero
 820e0c0:	000f883a 	mov	r7,zero
 820e0c4:	043fffc4 	movi	r16,-1
 820e0c8:	d8002415 	stw	zero,144(sp)
 820e0cc:	0025883a 	mov	r18,zero
 820e0d0:	01401604 	movi	r5,88
 820e0d4:	01800244 	movi	r6,9
 820e0d8:	02800a84 	movi	r10,42
 820e0dc:	02401b04 	movi	r9,108
 820e0e0:	9cc00044 	addi	r19,r19,1
 820e0e4:	18bff804 	addi	r2,r3,-32
 820e0e8:	2881dd36 	bltu	r5,r2,820e860 <___svfiprintf_internal_r+0x8bc>
 820e0ec:	100490ba 	slli	r2,r2,2
 820e0f0:	02c20874 	movhi	r11,2081
 820e0f4:	5af84104 	addi	r11,r11,-7932
 820e0f8:	12c5883a 	add	r2,r2,r11
 820e0fc:	10800017 	ldw	r2,0(r2)
 820e100:	1000683a 	jmp	r2
 820e104:	0820e300 	call	820e30 <OSCtxSw_SWITCH_PC+0x820df0>
 820e108:	0820e860 	cmpeqi	zero,at,-31839
 820e10c:	0820e860 	cmpeqi	zero,at,-31839
 820e110:	0820e2f4 	orhi	zero,at,33675
 820e114:	0820e860 	cmpeqi	zero,at,-31839
 820e118:	0820e860 	cmpeqi	zero,at,-31839
 820e11c:	0820e860 	cmpeqi	zero,at,-31839
 820e120:	0820e860 	cmpeqi	zero,at,-31839
 820e124:	0820e860 	cmpeqi	zero,at,-31839
 820e128:	0820e860 	cmpeqi	zero,at,-31839
 820e12c:	0820e268 	cmpgeui	zero,at,33673
 820e130:	0820e444 	addi	zero,at,-31855
 820e134:	0820e860 	cmpeqi	zero,at,-31839
 820e138:	0820e294 	ori	zero,at,33674
 820e13c:	0820e894 	ori	zero,at,33698
 820e140:	0820e860 	cmpeqi	zero,at,-31839
 820e144:	0820e888 	cmpgei	zero,at,-31838
 820e148:	0820e828 	cmpgeui	zero,at,33696
 820e14c:	0820e828 	cmpgeui	zero,at,33696
 820e150:	0820e828 	cmpgeui	zero,at,33696
 820e154:	0820e828 	cmpgeui	zero,at,33696
 820e158:	0820e828 	cmpgeui	zero,at,33696
 820e15c:	0820e828 	cmpgeui	zero,at,33696
 820e160:	0820e828 	cmpgeui	zero,at,33696
 820e164:	0820e828 	cmpgeui	zero,at,33696
 820e168:	0820e828 	cmpgeui	zero,at,33696
 820e16c:	0820e860 	cmpeqi	zero,at,-31839
 820e170:	0820e860 	cmpeqi	zero,at,-31839
 820e174:	0820e860 	cmpeqi	zero,at,-31839
 820e178:	0820e860 	cmpeqi	zero,at,-31839
 820e17c:	0820e860 	cmpeqi	zero,at,-31839
 820e180:	0820e860 	cmpeqi	zero,at,-31839
 820e184:	0820e860 	cmpeqi	zero,at,-31839
 820e188:	0820e860 	cmpeqi	zero,at,-31839
 820e18c:	0820e860 	cmpeqi	zero,at,-31839
 820e190:	0820e860 	cmpeqi	zero,at,-31839
 820e194:	0820e7c4 	addi	zero,at,-31841
 820e198:	0820e860 	cmpeqi	zero,at,-31839
 820e19c:	0820e860 	cmpeqi	zero,at,-31839
 820e1a0:	0820e860 	cmpeqi	zero,at,-31839
 820e1a4:	0820e860 	cmpeqi	zero,at,-31839
 820e1a8:	0820e860 	cmpeqi	zero,at,-31839
 820e1ac:	0820e860 	cmpeqi	zero,at,-31839
 820e1b0:	0820e860 	cmpeqi	zero,at,-31839
 820e1b4:	0820e860 	cmpeqi	zero,at,-31839
 820e1b8:	0820e860 	cmpeqi	zero,at,-31839
 820e1bc:	0820e860 	cmpeqi	zero,at,-31839
 820e1c0:	0820e93c 	xorhi	zero,at,33700
 820e1c4:	0820e860 	cmpeqi	zero,at,-31839
 820e1c8:	0820e860 	cmpeqi	zero,at,-31839
 820e1cc:	0820e860 	cmpeqi	zero,at,-31839
 820e1d0:	0820e860 	cmpeqi	zero,at,-31839
 820e1d4:	0820e860 	cmpeqi	zero,at,-31839
 820e1d8:	0820e8d4 	ori	zero,at,33699
 820e1dc:	0820e860 	cmpeqi	zero,at,-31839
 820e1e0:	0820e860 	cmpeqi	zero,at,-31839
 820e1e4:	0820e608 	cmpgei	zero,at,-31848
 820e1e8:	0820e860 	cmpeqi	zero,at,-31839
 820e1ec:	0820e860 	cmpeqi	zero,at,-31839
 820e1f0:	0820e860 	cmpeqi	zero,at,-31839
 820e1f4:	0820e860 	cmpeqi	zero,at,-31839
 820e1f8:	0820e860 	cmpeqi	zero,at,-31839
 820e1fc:	0820e860 	cmpeqi	zero,at,-31839
 820e200:	0820e860 	cmpeqi	zero,at,-31839
 820e204:	0820e860 	cmpeqi	zero,at,-31839
 820e208:	0820e860 	cmpeqi	zero,at,-31839
 820e20c:	0820e860 	cmpeqi	zero,at,-31839
 820e210:	0820e4f8 	rdprs	zero,at,-31853
 820e214:	0820e6a4 	muli	zero,at,-31846
 820e218:	0820e860 	cmpeqi	zero,at,-31839
 820e21c:	0820e860 	cmpeqi	zero,at,-31839
 820e220:	0820e860 	cmpeqi	zero,at,-31839
 820e224:	0820e698 	cmpnei	zero,at,-31846
 820e228:	0820e6a4 	muli	zero,at,-31846
 820e22c:	0820e860 	cmpeqi	zero,at,-31839
 820e230:	0820e860 	cmpeqi	zero,at,-31839
 820e234:	0820e688 	cmpgei	zero,at,-31846
 820e238:	0820e860 	cmpeqi	zero,at,-31839
 820e23c:	0820e64c 	andi	zero,at,33689
 820e240:	0820e454 	ori	zero,at,33681
 820e244:	0820e2a0 	cmpeqi	zero,at,-31862
 820e248:	0820e7b8 	rdprs	zero,at,-31842
 820e24c:	0820e860 	cmpeqi	zero,at,-31839
 820e250:	0820e76c 	andhi	zero,at,33693
 820e254:	0820e860 	cmpeqi	zero,at,-31839
 820e258:	0820e3c4 	addi	zero,at,-31857
 820e25c:	0820e860 	cmpeqi	zero,at,-31839
 820e260:	0820e860 	cmpeqi	zero,at,-31839
 820e264:	0820e320 	cmpeqi	zero,at,-31860
 820e268:	dac02317 	ldw	r11,140(sp)
 820e26c:	5ac00017 	ldw	r11,0(r11)
 820e270:	dac02415 	stw	r11,144(sp)
 820e274:	dac02317 	ldw	r11,140(sp)
 820e278:	58800104 	addi	r2,r11,4
 820e27c:	dac02417 	ldw	r11,144(sp)
 820e280:	5802e90e 	bge	r11,zero,820ee28 <___svfiprintf_internal_r+0xe84>
 820e284:	dac02417 	ldw	r11,144(sp)
 820e288:	d8802315 	stw	r2,140(sp)
 820e28c:	02d7c83a 	sub	r11,zero,r11
 820e290:	dac02415 	stw	r11,144(sp)
 820e294:	94800114 	ori	r18,r18,4
 820e298:	98c00007 	ldb	r3,0(r19)
 820e29c:	003f9006 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e2a0:	00800c04 	movi	r2,48
 820e2a4:	dac02317 	ldw	r11,140(sp)
 820e2a8:	d8801d05 	stb	r2,116(sp)
 820e2ac:	00801e04 	movi	r2,120
 820e2b0:	d8801d45 	stb	r2,117(sp)
 820e2b4:	d8001d85 	stb	zero,118(sp)
 820e2b8:	58c00104 	addi	r3,r11,4
 820e2bc:	5f000017 	ldw	fp,0(r11)
 820e2c0:	0013883a 	mov	r9,zero
 820e2c4:	90800094 	ori	r2,r18,2
 820e2c8:	80032b16 	blt	r16,zero,820ef78 <___svfiprintf_internal_r+0xfd4>
 820e2cc:	00bfdfc4 	movi	r2,-129
 820e2d0:	90a4703a 	and	r18,r18,r2
 820e2d4:	d8c02315 	stw	r3,140(sp)
 820e2d8:	94800094 	ori	r18,r18,2
 820e2dc:	e002dc26 	beq	fp,zero,820ee50 <___svfiprintf_internal_r+0xeac>
 820e2e0:	01020974 	movhi	r4,2085
 820e2e4:	2135e204 	addi	r4,r4,-10360
 820e2e8:	0015883a 	mov	r10,zero
 820e2ec:	d9002915 	stw	r4,164(sp)
 820e2f0:	00002306 	br	820e380 <___svfiprintf_internal_r+0x3dc>
 820e2f4:	94800054 	ori	r18,r18,1
 820e2f8:	98c00007 	ldb	r3,0(r19)
 820e2fc:	003f7806 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e300:	38803fcc 	andi	r2,r7,255
 820e304:	1080201c 	xori	r2,r2,128
 820e308:	10bfe004 	addi	r2,r2,-128
 820e30c:	1002f31e 	bne	r2,zero,820eedc <___svfiprintf_internal_r+0xf38>
 820e310:	01000044 	movi	r4,1
 820e314:	01c00804 	movi	r7,32
 820e318:	98c00007 	ldb	r3,0(r19)
 820e31c:	003f7006 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e320:	21003fcc 	andi	r4,r4,255
 820e324:	2003aa1e 	bne	r4,zero,820f1d0 <___svfiprintf_internal_r+0x122c>
 820e328:	00820974 	movhi	r2,2085
 820e32c:	10b5e204 	addi	r2,r2,-10360
 820e330:	d8802915 	stw	r2,164(sp)
 820e334:	9080080c 	andi	r2,r18,32
 820e338:	1000ba26 	beq	r2,zero,820e624 <___svfiprintf_internal_r+0x680>
 820e33c:	dac02317 	ldw	r11,140(sp)
 820e340:	5f000017 	ldw	fp,0(r11)
 820e344:	5a400117 	ldw	r9,4(r11)
 820e348:	5ac00204 	addi	r11,r11,8
 820e34c:	dac02315 	stw	r11,140(sp)
 820e350:	9080004c 	andi	r2,r18,1
 820e354:	10029026 	beq	r2,zero,820ed98 <___svfiprintf_internal_r+0xdf4>
 820e358:	e244b03a 	or	r2,fp,r9
 820e35c:	1002d41e 	bne	r2,zero,820eeb0 <___svfiprintf_internal_r+0xf0c>
 820e360:	d8001d85 	stb	zero,118(sp)
 820e364:	80030b16 	blt	r16,zero,820ef94 <___svfiprintf_internal_r+0xff0>
 820e368:	00bfdfc4 	movi	r2,-129
 820e36c:	90a4703a 	and	r18,r18,r2
 820e370:	0015883a 	mov	r10,zero
 820e374:	80002426 	beq	r16,zero,820e408 <___svfiprintf_internal_r+0x464>
 820e378:	0039883a 	mov	fp,zero
 820e37c:	0013883a 	mov	r9,zero
 820e380:	d9002917 	ldw	r4,164(sp)
 820e384:	dc401a04 	addi	r17,sp,104
 820e388:	e08003cc 	andi	r2,fp,15
 820e38c:	4806973a 	slli	r3,r9,28
 820e390:	2085883a 	add	r2,r4,r2
 820e394:	e038d13a 	srli	fp,fp,4
 820e398:	10800003 	ldbu	r2,0(r2)
 820e39c:	4812d13a 	srli	r9,r9,4
 820e3a0:	8c7fffc4 	addi	r17,r17,-1
 820e3a4:	1f38b03a 	or	fp,r3,fp
 820e3a8:	88800005 	stb	r2,0(r17)
 820e3ac:	e244b03a 	or	r2,fp,r9
 820e3b0:	103ff51e 	bne	r2,zero,820e388 <___svfiprintf_internal_r+0x3e4>
 820e3b4:	dac01e17 	ldw	r11,120(sp)
 820e3b8:	5c57c83a 	sub	r11,r11,r17
 820e3bc:	dac02115 	stw	r11,132(sp)
 820e3c0:	00001406 	br	820e414 <___svfiprintf_internal_r+0x470>
 820e3c4:	21003fcc 	andi	r4,r4,255
 820e3c8:	2003741e 	bne	r4,zero,820f19c <___svfiprintf_internal_r+0x11f8>
 820e3cc:	9080080c 	andi	r2,r18,32
 820e3d0:	10014526 	beq	r2,zero,820e8e8 <___svfiprintf_internal_r+0x944>
 820e3d4:	dac02317 	ldw	r11,140(sp)
 820e3d8:	d8001d85 	stb	zero,118(sp)
 820e3dc:	58c00204 	addi	r3,r11,8
 820e3e0:	5f000017 	ldw	fp,0(r11)
 820e3e4:	5a400117 	ldw	r9,4(r11)
 820e3e8:	8002d916 	blt	r16,zero,820ef50 <___svfiprintf_internal_r+0xfac>
 820e3ec:	013fdfc4 	movi	r4,-129
 820e3f0:	e244b03a 	or	r2,fp,r9
 820e3f4:	d8c02315 	stw	r3,140(sp)
 820e3f8:	9124703a 	and	r18,r18,r4
 820e3fc:	0015883a 	mov	r10,zero
 820e400:	1000b91e 	bne	r2,zero,820e6e8 <___svfiprintf_internal_r+0x744>
 820e404:	8002e61e 	bne	r16,zero,820efa0 <___svfiprintf_internal_r+0xffc>
 820e408:	0021883a 	mov	r16,zero
 820e40c:	d8002115 	stw	zero,132(sp)
 820e410:	dc401a04 	addi	r17,sp,104
 820e414:	d8c02117 	ldw	r3,132(sp)
 820e418:	dc002015 	stw	r16,128(sp)
 820e41c:	80c0010e 	bge	r16,r3,820e424 <___svfiprintf_internal_r+0x480>
 820e420:	d8c02015 	stw	r3,128(sp)
 820e424:	52803fcc 	andi	r10,r10,255
 820e428:	5280201c 	xori	r10,r10,128
 820e42c:	52bfe004 	addi	r10,r10,-128
 820e430:	50003c26 	beq	r10,zero,820e524 <___svfiprintf_internal_r+0x580>
 820e434:	dac02017 	ldw	r11,128(sp)
 820e438:	5ac00044 	addi	r11,r11,1
 820e43c:	dac02015 	stw	r11,128(sp)
 820e440:	00003806 	br	820e524 <___svfiprintf_internal_r+0x580>
 820e444:	01000044 	movi	r4,1
 820e448:	01c00ac4 	movi	r7,43
 820e44c:	98c00007 	ldb	r3,0(r19)
 820e450:	003f2306 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e454:	21003fcc 	andi	r4,r4,255
 820e458:	2003481e 	bne	r4,zero,820f17c <___svfiprintf_internal_r+0x11d8>
 820e45c:	9080080c 	andi	r2,r18,32
 820e460:	10013b26 	beq	r2,zero,820e950 <___svfiprintf_internal_r+0x9ac>
 820e464:	dac02317 	ldw	r11,140(sp)
 820e468:	d8001d85 	stb	zero,118(sp)
 820e46c:	58800204 	addi	r2,r11,8
 820e470:	5f000017 	ldw	fp,0(r11)
 820e474:	5a400117 	ldw	r9,4(r11)
 820e478:	8002a816 	blt	r16,zero,820ef1c <___svfiprintf_internal_r+0xf78>
 820e47c:	013fdfc4 	movi	r4,-129
 820e480:	e246b03a 	or	r3,fp,r9
 820e484:	d8802315 	stw	r2,140(sp)
 820e488:	9124703a 	and	r18,r18,r4
 820e48c:	18013c26 	beq	r3,zero,820e980 <___svfiprintf_internal_r+0x9dc>
 820e490:	0015883a 	mov	r10,zero
 820e494:	dc401a04 	addi	r17,sp,104
 820e498:	e006d0fa 	srli	r3,fp,3
 820e49c:	4808977a 	slli	r4,r9,29
 820e4a0:	4812d0fa 	srli	r9,r9,3
 820e4a4:	e70001cc 	andi	fp,fp,7
 820e4a8:	e0800c04 	addi	r2,fp,48
 820e4ac:	8c7fffc4 	addi	r17,r17,-1
 820e4b0:	20f8b03a 	or	fp,r4,r3
 820e4b4:	88800005 	stb	r2,0(r17)
 820e4b8:	e246b03a 	or	r3,fp,r9
 820e4bc:	183ff61e 	bne	r3,zero,820e498 <___svfiprintf_internal_r+0x4f4>
 820e4c0:	90c0004c 	andi	r3,r18,1
 820e4c4:	1800a526 	beq	r3,zero,820e75c <___svfiprintf_internal_r+0x7b8>
 820e4c8:	10803fcc 	andi	r2,r2,255
 820e4cc:	1080201c 	xori	r2,r2,128
 820e4d0:	10bfe004 	addi	r2,r2,-128
 820e4d4:	00c00c04 	movi	r3,48
 820e4d8:	10ffb626 	beq	r2,r3,820e3b4 <___svfiprintf_internal_r+0x410>
 820e4dc:	88ffffc5 	stb	r3,-1(r17)
 820e4e0:	d8c01e17 	ldw	r3,120(sp)
 820e4e4:	88bfffc4 	addi	r2,r17,-1
 820e4e8:	1023883a 	mov	r17,r2
 820e4ec:	1887c83a 	sub	r3,r3,r2
 820e4f0:	d8c02115 	stw	r3,132(sp)
 820e4f4:	003fc706 	br	820e414 <___svfiprintf_internal_r+0x470>
 820e4f8:	dac02317 	ldw	r11,140(sp)
 820e4fc:	00c00044 	movi	r3,1
 820e500:	d8c02015 	stw	r3,128(sp)
 820e504:	58800017 	ldw	r2,0(r11)
 820e508:	5ac00104 	addi	r11,r11,4
 820e50c:	d8001d85 	stb	zero,118(sp)
 820e510:	d8801005 	stb	r2,64(sp)
 820e514:	dac02315 	stw	r11,140(sp)
 820e518:	d8c02115 	stw	r3,132(sp)
 820e51c:	dc401004 	addi	r17,sp,64
 820e520:	0021883a 	mov	r16,zero
 820e524:	90c0008c 	andi	r3,r18,2
 820e528:	d8c02215 	stw	r3,136(sp)
 820e52c:	18000326 	beq	r3,zero,820e53c <___svfiprintf_internal_r+0x598>
 820e530:	dac02017 	ldw	r11,128(sp)
 820e534:	5ac00084 	addi	r11,r11,2
 820e538:	dac02015 	stw	r11,128(sp)
 820e53c:	90c0210c 	andi	r3,r18,132
 820e540:	d8c02615 	stw	r3,152(sp)
 820e544:	1801131e 	bne	r3,zero,820e994 <___svfiprintf_internal_r+0x9f0>
 820e548:	dac02417 	ldw	r11,144(sp)
 820e54c:	d8c02017 	ldw	r3,128(sp)
 820e550:	58f9c83a 	sub	fp,r11,r3
 820e554:	07010f0e 	bge	zero,fp,820e994 <___svfiprintf_internal_r+0x9f0>
 820e558:	02400404 	movi	r9,16
 820e55c:	d8c01c17 	ldw	r3,112(sp)
 820e560:	d8801b17 	ldw	r2,108(sp)
 820e564:	4f02d60e 	bge	r9,fp,820f0c0 <___svfiprintf_internal_r+0x111c>
 820e568:	01420974 	movhi	r5,2085
 820e56c:	29764e04 	addi	r5,r5,-9928
 820e570:	d9402815 	stw	r5,160(sp)
 820e574:	028001c4 	movi	r10,7
 820e578:	00000306 	br	820e588 <___svfiprintf_internal_r+0x5e4>
 820e57c:	e73ffc04 	addi	fp,fp,-16
 820e580:	42000204 	addi	r8,r8,8
 820e584:	4f00150e 	bge	r9,fp,820e5dc <___svfiprintf_internal_r+0x638>
 820e588:	18c00404 	addi	r3,r3,16
 820e58c:	10800044 	addi	r2,r2,1
 820e590:	45800015 	stw	r22,0(r8)
 820e594:	42400115 	stw	r9,4(r8)
 820e598:	d8c01c15 	stw	r3,112(sp)
 820e59c:	d8801b15 	stw	r2,108(sp)
 820e5a0:	50bff60e 	bge	r10,r2,820e57c <___svfiprintf_internal_r+0x5d8>
 820e5a4:	d9801a04 	addi	r6,sp,104
 820e5a8:	b80b883a 	mov	r5,r23
 820e5ac:	a809883a 	mov	r4,r21
 820e5b0:	da402c15 	stw	r9,176(sp)
 820e5b4:	da802d15 	stw	r10,180(sp)
 820e5b8:	820ddd40 	call	820ddd4 <__ssprint_r>
 820e5bc:	da402c17 	ldw	r9,176(sp)
 820e5c0:	da802d17 	ldw	r10,180(sp)
 820e5c4:	1001851e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820e5c8:	e73ffc04 	addi	fp,fp,-16
 820e5cc:	d8c01c17 	ldw	r3,112(sp)
 820e5d0:	d8801b17 	ldw	r2,108(sp)
 820e5d4:	d811883a 	mov	r8,sp
 820e5d8:	4f3feb16 	blt	r9,fp,820e588 <___svfiprintf_internal_r+0x5e4>
 820e5dc:	dac02817 	ldw	r11,160(sp)
 820e5e0:	e0c7883a 	add	r3,fp,r3
 820e5e4:	10800044 	addi	r2,r2,1
 820e5e8:	42c00015 	stw	r11,0(r8)
 820e5ec:	47000115 	stw	fp,4(r8)
 820e5f0:	d8c01c15 	stw	r3,112(sp)
 820e5f4:	d8801b15 	stw	r2,108(sp)
 820e5f8:	010001c4 	movi	r4,7
 820e5fc:	2081ee16 	blt	r4,r2,820edb8 <___svfiprintf_internal_r+0xe14>
 820e600:	42000204 	addi	r8,r8,8
 820e604:	0000e506 	br	820e99c <___svfiprintf_internal_r+0x9f8>
 820e608:	21003fcc 	andi	r4,r4,255
 820e60c:	2002dd1e 	bne	r4,zero,820f184 <___svfiprintf_internal_r+0x11e0>
 820e610:	00820974 	movhi	r2,2085
 820e614:	10b5dd04 	addi	r2,r2,-10380
 820e618:	d8802915 	stw	r2,164(sp)
 820e61c:	9080080c 	andi	r2,r18,32
 820e620:	103f461e 	bne	r2,zero,820e33c <___svfiprintf_internal_r+0x398>
 820e624:	9080040c 	andi	r2,r18,16
 820e628:	10022e1e 	bne	r2,zero,820eee4 <___svfiprintf_internal_r+0xf40>
 820e62c:	9080100c 	andi	r2,r18,64
 820e630:	dac02317 	ldw	r11,140(sp)
 820e634:	10027326 	beq	r2,zero,820f004 <___svfiprintf_internal_r+0x1060>
 820e638:	5f00000b 	ldhu	fp,0(r11)
 820e63c:	5ac00104 	addi	r11,r11,4
 820e640:	0013883a 	mov	r9,zero
 820e644:	dac02315 	stw	r11,140(sp)
 820e648:	003f4106 	br	820e350 <___svfiprintf_internal_r+0x3ac>
 820e64c:	21003fcc 	andi	r4,r4,255
 820e650:	2002e11e 	bne	r4,zero,820f1d8 <___svfiprintf_internal_r+0x1234>
 820e654:	9080080c 	andi	r2,r18,32
 820e658:	1002011e 	bne	r2,zero,820ee60 <___svfiprintf_internal_r+0xebc>
 820e65c:	9080040c 	andi	r2,r18,16
 820e660:	10023e1e 	bne	r2,zero,820ef5c <___svfiprintf_internal_r+0xfb8>
 820e664:	9480100c 	andi	r18,r18,64
 820e668:	90023c26 	beq	r18,zero,820ef5c <___svfiprintf_internal_r+0xfb8>
 820e66c:	dac02317 	ldw	r11,140(sp)
 820e670:	58800017 	ldw	r2,0(r11)
 820e674:	5ac00104 	addi	r11,r11,4
 820e678:	dac02315 	stw	r11,140(sp)
 820e67c:	dac02517 	ldw	r11,148(sp)
 820e680:	12c0000d 	sth	r11,0(r2)
 820e684:	003e6e06 	br	820e040 <___svfiprintf_internal_r+0x9c>
 820e688:	98c00007 	ldb	r3,0(r19)
 820e68c:	1a422926 	beq	r3,r9,820ef34 <___svfiprintf_internal_r+0xf90>
 820e690:	94800414 	ori	r18,r18,16
 820e694:	003e9206 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e698:	94801014 	ori	r18,r18,64
 820e69c:	98c00007 	ldb	r3,0(r19)
 820e6a0:	003e8f06 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e6a4:	21003fcc 	andi	r4,r4,255
 820e6a8:	2002c71e 	bne	r4,zero,820f1c8 <___svfiprintf_internal_r+0x1224>
 820e6ac:	9080080c 	andi	r2,r18,32
 820e6b0:	10004926 	beq	r2,zero,820e7d8 <___svfiprintf_internal_r+0x834>
 820e6b4:	dac02317 	ldw	r11,140(sp)
 820e6b8:	58800117 	ldw	r2,4(r11)
 820e6bc:	5f000017 	ldw	fp,0(r11)
 820e6c0:	5ac00204 	addi	r11,r11,8
 820e6c4:	dac02315 	stw	r11,140(sp)
 820e6c8:	1013883a 	mov	r9,r2
 820e6cc:	10004b16 	blt	r2,zero,820e7fc <___svfiprintf_internal_r+0x858>
 820e6d0:	da801d83 	ldbu	r10,118(sp)
 820e6d4:	8001cb16 	blt	r16,zero,820ee04 <___svfiprintf_internal_r+0xe60>
 820e6d8:	00ffdfc4 	movi	r3,-129
 820e6dc:	e244b03a 	or	r2,fp,r9
 820e6e0:	90e4703a 	and	r18,r18,r3
 820e6e4:	103f4726 	beq	r2,zero,820e404 <___svfiprintf_internal_r+0x460>
 820e6e8:	48008c26 	beq	r9,zero,820e91c <___svfiprintf_internal_r+0x978>
 820e6ec:	dc802015 	stw	r18,128(sp)
 820e6f0:	dc002115 	stw	r16,132(sp)
 820e6f4:	dc401a04 	addi	r17,sp,104
 820e6f8:	e021883a 	mov	r16,fp
 820e6fc:	da002215 	stw	r8,136(sp)
 820e700:	5039883a 	mov	fp,r10
 820e704:	4825883a 	mov	r18,r9
 820e708:	8009883a 	mov	r4,r16
 820e70c:	900b883a 	mov	r5,r18
 820e710:	01800284 	movi	r6,10
 820e714:	000f883a 	mov	r7,zero
 820e718:	821157c0 	call	821157c <__umoddi3>
 820e71c:	10800c04 	addi	r2,r2,48
 820e720:	8c7fffc4 	addi	r17,r17,-1
 820e724:	8009883a 	mov	r4,r16
 820e728:	900b883a 	mov	r5,r18
 820e72c:	88800005 	stb	r2,0(r17)
 820e730:	01800284 	movi	r6,10
 820e734:	000f883a 	mov	r7,zero
 820e738:	82110040 	call	8211004 <__udivdi3>
 820e73c:	1021883a 	mov	r16,r2
 820e740:	10c4b03a 	or	r2,r2,r3
 820e744:	1825883a 	mov	r18,r3
 820e748:	103fef1e 	bne	r2,zero,820e708 <___svfiprintf_internal_r+0x764>
 820e74c:	dc802017 	ldw	r18,128(sp)
 820e750:	dc002117 	ldw	r16,132(sp)
 820e754:	da002217 	ldw	r8,136(sp)
 820e758:	e015883a 	mov	r10,fp
 820e75c:	d8c01e17 	ldw	r3,120(sp)
 820e760:	1c47c83a 	sub	r3,r3,r17
 820e764:	d8c02115 	stw	r3,132(sp)
 820e768:	003f2a06 	br	820e414 <___svfiprintf_internal_r+0x470>
 820e76c:	dac02317 	ldw	r11,140(sp)
 820e770:	d8001d85 	stb	zero,118(sp)
 820e774:	5c400017 	ldw	r17,0(r11)
 820e778:	5f000104 	addi	fp,r11,4
 820e77c:	88022f26 	beq	r17,zero,820f03c <___svfiprintf_internal_r+0x1098>
 820e780:	80022516 	blt	r16,zero,820f018 <___svfiprintf_internal_r+0x1074>
 820e784:	800d883a 	mov	r6,r16
 820e788:	000b883a 	mov	r5,zero
 820e78c:	8809883a 	mov	r4,r17
 820e790:	da002c15 	stw	r8,176(sp)
 820e794:	820c2440 	call	820c244 <memchr>
 820e798:	da002c17 	ldw	r8,176(sp)
 820e79c:	10026426 	beq	r2,zero,820f130 <___svfiprintf_internal_r+0x118c>
 820e7a0:	1445c83a 	sub	r2,r2,r17
 820e7a4:	d8802115 	stw	r2,132(sp)
 820e7a8:	da801d83 	ldbu	r10,118(sp)
 820e7ac:	df002315 	stw	fp,140(sp)
 820e7b0:	0021883a 	mov	r16,zero
 820e7b4:	003f1706 	br	820e414 <___svfiprintf_internal_r+0x470>
 820e7b8:	94800814 	ori	r18,r18,32
 820e7bc:	98c00007 	ldb	r3,0(r19)
 820e7c0:	003e4706 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e7c4:	21003fcc 	andi	r4,r4,255
 820e7c8:	2002701e 	bne	r4,zero,820f18c <___svfiprintf_internal_r+0x11e8>
 820e7cc:	94800414 	ori	r18,r18,16
 820e7d0:	9080080c 	andi	r2,r18,32
 820e7d4:	103fb71e 	bne	r2,zero,820e6b4 <___svfiprintf_internal_r+0x710>
 820e7d8:	9080040c 	andi	r2,r18,16
 820e7dc:	1001ab26 	beq	r2,zero,820ee8c <___svfiprintf_internal_r+0xee8>
 820e7e0:	dac02317 	ldw	r11,140(sp)
 820e7e4:	5f000017 	ldw	fp,0(r11)
 820e7e8:	5ac00104 	addi	r11,r11,4
 820e7ec:	dac02315 	stw	r11,140(sp)
 820e7f0:	e013d7fa 	srai	r9,fp,31
 820e7f4:	4805883a 	mov	r2,r9
 820e7f8:	103fb50e 	bge	r2,zero,820e6d0 <___svfiprintf_internal_r+0x72c>
 820e7fc:	0739c83a 	sub	fp,zero,fp
 820e800:	02800b44 	movi	r10,45
 820e804:	e004c03a 	cmpne	r2,fp,zero
 820e808:	0253c83a 	sub	r9,zero,r9
 820e80c:	da801d85 	stb	r10,118(sp)
 820e810:	4893c83a 	sub	r9,r9,r2
 820e814:	80023016 	blt	r16,zero,820f0d8 <___svfiprintf_internal_r+0x1134>
 820e818:	00bfdfc4 	movi	r2,-129
 820e81c:	90a4703a 	and	r18,r18,r2
 820e820:	483fb21e 	bne	r9,zero,820e6ec <___svfiprintf_internal_r+0x748>
 820e824:	00003d06 	br	820e91c <___svfiprintf_internal_r+0x978>
 820e828:	9817883a 	mov	r11,r19
 820e82c:	d8002415 	stw	zero,144(sp)
 820e830:	18bff404 	addi	r2,r3,-48
 820e834:	0019883a 	mov	r12,zero
 820e838:	58c00007 	ldb	r3,0(r11)
 820e83c:	630002a4 	muli	r12,r12,10
 820e840:	9cc00044 	addi	r19,r19,1
 820e844:	9817883a 	mov	r11,r19
 820e848:	1319883a 	add	r12,r2,r12
 820e84c:	18bff404 	addi	r2,r3,-48
 820e850:	30bff92e 	bgeu	r6,r2,820e838 <___svfiprintf_internal_r+0x894>
 820e854:	db002415 	stw	r12,144(sp)
 820e858:	18bff804 	addi	r2,r3,-32
 820e85c:	28be232e 	bgeu	r5,r2,820e0ec <___svfiprintf_internal_r+0x148>
 820e860:	21003fcc 	andi	r4,r4,255
 820e864:	20024b1e 	bne	r4,zero,820f194 <___svfiprintf_internal_r+0x11f0>
 820e868:	1800d626 	beq	r3,zero,820ebc4 <___svfiprintf_internal_r+0xc20>
 820e86c:	02c00044 	movi	r11,1
 820e870:	dac02015 	stw	r11,128(sp)
 820e874:	d8c01005 	stb	r3,64(sp)
 820e878:	d8001d85 	stb	zero,118(sp)
 820e87c:	dac02115 	stw	r11,132(sp)
 820e880:	dc401004 	addi	r17,sp,64
 820e884:	003f2606 	br	820e520 <___svfiprintf_internal_r+0x57c>
 820e888:	94802014 	ori	r18,r18,128
 820e88c:	98c00007 	ldb	r3,0(r19)
 820e890:	003e1306 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820e894:	98c00007 	ldb	r3,0(r19)
 820e898:	9ac00044 	addi	r11,r19,1
 820e89c:	1a822b26 	beq	r3,r10,820f14c <___svfiprintf_internal_r+0x11a8>
 820e8a0:	18bff404 	addi	r2,r3,-48
 820e8a4:	0021883a 	mov	r16,zero
 820e8a8:	30821e36 	bltu	r6,r2,820f124 <___svfiprintf_internal_r+0x1180>
 820e8ac:	58c00007 	ldb	r3,0(r11)
 820e8b0:	840002a4 	muli	r16,r16,10
 820e8b4:	5cc00044 	addi	r19,r11,1
 820e8b8:	9817883a 	mov	r11,r19
 820e8bc:	80a1883a 	add	r16,r16,r2
 820e8c0:	18bff404 	addi	r2,r3,-48
 820e8c4:	30bff92e 	bgeu	r6,r2,820e8ac <___svfiprintf_internal_r+0x908>
 820e8c8:	803e060e 	bge	r16,zero,820e0e4 <___svfiprintf_internal_r+0x140>
 820e8cc:	043fffc4 	movi	r16,-1
 820e8d0:	003e0406 	br	820e0e4 <___svfiprintf_internal_r+0x140>
 820e8d4:	21003fcc 	andi	r4,r4,255
 820e8d8:	2002371e 	bne	r4,zero,820f1b8 <___svfiprintf_internal_r+0x1214>
 820e8dc:	94800414 	ori	r18,r18,16
 820e8e0:	9080080c 	andi	r2,r18,32
 820e8e4:	103ebb1e 	bne	r2,zero,820e3d4 <___svfiprintf_internal_r+0x430>
 820e8e8:	9080040c 	andi	r2,r18,16
 820e8ec:	10013b26 	beq	r2,zero,820eddc <___svfiprintf_internal_r+0xe38>
 820e8f0:	dac02317 	ldw	r11,140(sp)
 820e8f4:	d8001d85 	stb	zero,118(sp)
 820e8f8:	0013883a 	mov	r9,zero
 820e8fc:	58800104 	addi	r2,r11,4
 820e900:	5f000017 	ldw	fp,0(r11)
 820e904:	80013d16 	blt	r16,zero,820edfc <___svfiprintf_internal_r+0xe58>
 820e908:	00ffdfc4 	movi	r3,-129
 820e90c:	d8802315 	stw	r2,140(sp)
 820e910:	90e4703a 	and	r18,r18,r3
 820e914:	0015883a 	mov	r10,zero
 820e918:	e03eba26 	beq	fp,zero,820e404 <___svfiprintf_internal_r+0x460>
 820e91c:	00800244 	movi	r2,9
 820e920:	173f7236 	bltu	r2,fp,820e6ec <___svfiprintf_internal_r+0x748>
 820e924:	dac02b17 	ldw	r11,172(sp)
 820e928:	e7000c04 	addi	fp,fp,48
 820e92c:	df0019c5 	stb	fp,103(sp)
 820e930:	dac02115 	stw	r11,132(sp)
 820e934:	dc4019c4 	addi	r17,sp,103
 820e938:	003eb606 	br	820e414 <___svfiprintf_internal_r+0x470>
 820e93c:	21003fcc 	andi	r4,r4,255
 820e940:	20021f1e 	bne	r4,zero,820f1c0 <___svfiprintf_internal_r+0x121c>
 820e944:	94800414 	ori	r18,r18,16
 820e948:	9080080c 	andi	r2,r18,32
 820e94c:	103ec51e 	bne	r2,zero,820e464 <___svfiprintf_internal_r+0x4c0>
 820e950:	9080040c 	andi	r2,r18,16
 820e954:	10016926 	beq	r2,zero,820eefc <___svfiprintf_internal_r+0xf58>
 820e958:	dac02317 	ldw	r11,140(sp)
 820e95c:	d8001d85 	stb	zero,118(sp)
 820e960:	0013883a 	mov	r9,zero
 820e964:	58800104 	addi	r2,r11,4
 820e968:	5f000017 	ldw	fp,0(r11)
 820e96c:	80016b16 	blt	r16,zero,820ef1c <___svfiprintf_internal_r+0xf78>
 820e970:	00ffdfc4 	movi	r3,-129
 820e974:	d8802315 	stw	r2,140(sp)
 820e978:	90e4703a 	and	r18,r18,r3
 820e97c:	e03ec41e 	bne	fp,zero,820e490 <___svfiprintf_internal_r+0x4ec>
 820e980:	0015883a 	mov	r10,zero
 820e984:	8001c226 	beq	r16,zero,820f090 <___svfiprintf_internal_r+0x10ec>
 820e988:	0039883a 	mov	fp,zero
 820e98c:	0013883a 	mov	r9,zero
 820e990:	003ec006 	br	820e494 <___svfiprintf_internal_r+0x4f0>
 820e994:	d8c01c17 	ldw	r3,112(sp)
 820e998:	d8801b17 	ldw	r2,108(sp)
 820e99c:	d9001d87 	ldb	r4,118(sp)
 820e9a0:	20000b26 	beq	r4,zero,820e9d0 <___svfiprintf_internal_r+0xa2c>
 820e9a4:	d9001d84 	addi	r4,sp,118
 820e9a8:	18c00044 	addi	r3,r3,1
 820e9ac:	10800044 	addi	r2,r2,1
 820e9b0:	41000015 	stw	r4,0(r8)
 820e9b4:	01000044 	movi	r4,1
 820e9b8:	41000115 	stw	r4,4(r8)
 820e9bc:	d8c01c15 	stw	r3,112(sp)
 820e9c0:	d8801b15 	stw	r2,108(sp)
 820e9c4:	010001c4 	movi	r4,7
 820e9c8:	2080e116 	blt	r4,r2,820ed50 <___svfiprintf_internal_r+0xdac>
 820e9cc:	42000204 	addi	r8,r8,8
 820e9d0:	dac02217 	ldw	r11,136(sp)
 820e9d4:	58000b26 	beq	r11,zero,820ea04 <___svfiprintf_internal_r+0xa60>
 820e9d8:	d9001d04 	addi	r4,sp,116
 820e9dc:	18c00084 	addi	r3,r3,2
 820e9e0:	10800044 	addi	r2,r2,1
 820e9e4:	41000015 	stw	r4,0(r8)
 820e9e8:	01000084 	movi	r4,2
 820e9ec:	41000115 	stw	r4,4(r8)
 820e9f0:	d8c01c15 	stw	r3,112(sp)
 820e9f4:	d8801b15 	stw	r2,108(sp)
 820e9f8:	010001c4 	movi	r4,7
 820e9fc:	2080dd16 	blt	r4,r2,820ed74 <___svfiprintf_internal_r+0xdd0>
 820ea00:	42000204 	addi	r8,r8,8
 820ea04:	dac02617 	ldw	r11,152(sp)
 820ea08:	01002004 	movi	r4,128
 820ea0c:	59008426 	beq	r11,r4,820ec20 <___svfiprintf_internal_r+0xc7c>
 820ea10:	dac02117 	ldw	r11,132(sp)
 820ea14:	82e1c83a 	sub	r16,r16,r11
 820ea18:	0400270e 	bge	zero,r16,820eab8 <___svfiprintf_internal_r+0xb14>
 820ea1c:	01c00404 	movi	r7,16
 820ea20:	3c016a0e 	bge	r7,r16,820efcc <___svfiprintf_internal_r+0x1028>
 820ea24:	01420974 	movhi	r5,2085
 820ea28:	29764a04 	addi	r5,r5,-9944
 820ea2c:	d9402215 	stw	r5,136(sp)
 820ea30:	070001c4 	movi	fp,7
 820ea34:	00000306 	br	820ea44 <___svfiprintf_internal_r+0xaa0>
 820ea38:	843ffc04 	addi	r16,r16,-16
 820ea3c:	42000204 	addi	r8,r8,8
 820ea40:	3c00130e 	bge	r7,r16,820ea90 <___svfiprintf_internal_r+0xaec>
 820ea44:	18c00404 	addi	r3,r3,16
 820ea48:	10800044 	addi	r2,r2,1
 820ea4c:	45000015 	stw	r20,0(r8)
 820ea50:	41c00115 	stw	r7,4(r8)
 820ea54:	d8c01c15 	stw	r3,112(sp)
 820ea58:	d8801b15 	stw	r2,108(sp)
 820ea5c:	e0bff60e 	bge	fp,r2,820ea38 <___svfiprintf_internal_r+0xa94>
 820ea60:	d9801a04 	addi	r6,sp,104
 820ea64:	b80b883a 	mov	r5,r23
 820ea68:	a809883a 	mov	r4,r21
 820ea6c:	d9c02c15 	stw	r7,176(sp)
 820ea70:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ea74:	d9c02c17 	ldw	r7,176(sp)
 820ea78:	1000581e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ea7c:	843ffc04 	addi	r16,r16,-16
 820ea80:	d8c01c17 	ldw	r3,112(sp)
 820ea84:	d8801b17 	ldw	r2,108(sp)
 820ea88:	d811883a 	mov	r8,sp
 820ea8c:	3c3fed16 	blt	r7,r16,820ea44 <___svfiprintf_internal_r+0xaa0>
 820ea90:	dac02217 	ldw	r11,136(sp)
 820ea94:	1c07883a 	add	r3,r3,r16
 820ea98:	10800044 	addi	r2,r2,1
 820ea9c:	42c00015 	stw	r11,0(r8)
 820eaa0:	44000115 	stw	r16,4(r8)
 820eaa4:	d8c01c15 	stw	r3,112(sp)
 820eaa8:	d8801b15 	stw	r2,108(sp)
 820eaac:	010001c4 	movi	r4,7
 820eab0:	20809e16 	blt	r4,r2,820ed2c <___svfiprintf_internal_r+0xd88>
 820eab4:	42000204 	addi	r8,r8,8
 820eab8:	dac02117 	ldw	r11,132(sp)
 820eabc:	10800044 	addi	r2,r2,1
 820eac0:	44400015 	stw	r17,0(r8)
 820eac4:	58c7883a 	add	r3,r11,r3
 820eac8:	42c00115 	stw	r11,4(r8)
 820eacc:	d8c01c15 	stw	r3,112(sp)
 820ead0:	d8801b15 	stw	r2,108(sp)
 820ead4:	010001c4 	movi	r4,7
 820ead8:	20807f16 	blt	r4,r2,820ecd8 <___svfiprintf_internal_r+0xd34>
 820eadc:	42000204 	addi	r8,r8,8
 820eae0:	9480010c 	andi	r18,r18,4
 820eae4:	90002926 	beq	r18,zero,820eb8c <___svfiprintf_internal_r+0xbe8>
 820eae8:	dac02417 	ldw	r11,144(sp)
 820eaec:	d8802017 	ldw	r2,128(sp)
 820eaf0:	58a1c83a 	sub	r16,r11,r2
 820eaf4:	0400250e 	bge	zero,r16,820eb8c <___svfiprintf_internal_r+0xbe8>
 820eaf8:	04400404 	movi	r17,16
 820eafc:	d8801b17 	ldw	r2,108(sp)
 820eb00:	8c017c0e 	bge	r17,r16,820f0f4 <___svfiprintf_internal_r+0x1150>
 820eb04:	01420974 	movhi	r5,2085
 820eb08:	29764e04 	addi	r5,r5,-9928
 820eb0c:	d9402815 	stw	r5,160(sp)
 820eb10:	048001c4 	movi	r18,7
 820eb14:	00000306 	br	820eb24 <___svfiprintf_internal_r+0xb80>
 820eb18:	843ffc04 	addi	r16,r16,-16
 820eb1c:	42000204 	addi	r8,r8,8
 820eb20:	8c00110e 	bge	r17,r16,820eb68 <___svfiprintf_internal_r+0xbc4>
 820eb24:	18c00404 	addi	r3,r3,16
 820eb28:	10800044 	addi	r2,r2,1
 820eb2c:	45800015 	stw	r22,0(r8)
 820eb30:	44400115 	stw	r17,4(r8)
 820eb34:	d8c01c15 	stw	r3,112(sp)
 820eb38:	d8801b15 	stw	r2,108(sp)
 820eb3c:	90bff60e 	bge	r18,r2,820eb18 <___svfiprintf_internal_r+0xb74>
 820eb40:	d9801a04 	addi	r6,sp,104
 820eb44:	b80b883a 	mov	r5,r23
 820eb48:	a809883a 	mov	r4,r21
 820eb4c:	820ddd40 	call	820ddd4 <__ssprint_r>
 820eb50:	1000221e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820eb54:	843ffc04 	addi	r16,r16,-16
 820eb58:	d8c01c17 	ldw	r3,112(sp)
 820eb5c:	d8801b17 	ldw	r2,108(sp)
 820eb60:	d811883a 	mov	r8,sp
 820eb64:	8c3fef16 	blt	r17,r16,820eb24 <___svfiprintf_internal_r+0xb80>
 820eb68:	dac02817 	ldw	r11,160(sp)
 820eb6c:	1c07883a 	add	r3,r3,r16
 820eb70:	10800044 	addi	r2,r2,1
 820eb74:	42c00015 	stw	r11,0(r8)
 820eb78:	44000115 	stw	r16,4(r8)
 820eb7c:	d8c01c15 	stw	r3,112(sp)
 820eb80:	d8801b15 	stw	r2,108(sp)
 820eb84:	010001c4 	movi	r4,7
 820eb88:	2080aa16 	blt	r4,r2,820ee34 <___svfiprintf_internal_r+0xe90>
 820eb8c:	d8802417 	ldw	r2,144(sp)
 820eb90:	dac02017 	ldw	r11,128(sp)
 820eb94:	12c0010e 	bge	r2,r11,820eb9c <___svfiprintf_internal_r+0xbf8>
 820eb98:	5805883a 	mov	r2,r11
 820eb9c:	dac02517 	ldw	r11,148(sp)
 820eba0:	5897883a 	add	r11,r11,r2
 820eba4:	dac02515 	stw	r11,148(sp)
 820eba8:	1800531e 	bne	r3,zero,820ecf8 <___svfiprintf_internal_r+0xd54>
 820ebac:	98800007 	ldb	r2,0(r19)
 820ebb0:	d8001b15 	stw	zero,108(sp)
 820ebb4:	d811883a 	mov	r8,sp
 820ebb8:	103d231e 	bne	r2,zero,820e048 <___svfiprintf_internal_r+0xa4>
 820ebbc:	9823883a 	mov	r17,r19
 820ebc0:	003d3906 	br	820e0a8 <___svfiprintf_internal_r+0x104>
 820ebc4:	d8801c17 	ldw	r2,112(sp)
 820ebc8:	10000426 	beq	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ebcc:	d9402717 	ldw	r5,156(sp)
 820ebd0:	d9002a17 	ldw	r4,168(sp)
 820ebd4:	d9801a04 	addi	r6,sp,104
 820ebd8:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ebdc:	dac02717 	ldw	r11,156(sp)
 820ebe0:	d8802517 	ldw	r2,148(sp)
 820ebe4:	58c0030b 	ldhu	r3,12(r11)
 820ebe8:	18c0100c 	andi	r3,r3,64
 820ebec:	1801381e 	bne	r3,zero,820f0d0 <___svfiprintf_internal_r+0x112c>
 820ebf0:	dfc03717 	ldw	ra,220(sp)
 820ebf4:	df003617 	ldw	fp,216(sp)
 820ebf8:	ddc03517 	ldw	r23,212(sp)
 820ebfc:	dd803417 	ldw	r22,208(sp)
 820ec00:	dd403317 	ldw	r21,204(sp)
 820ec04:	dd003217 	ldw	r20,200(sp)
 820ec08:	dcc03117 	ldw	r19,196(sp)
 820ec0c:	dc803017 	ldw	r18,192(sp)
 820ec10:	dc402f17 	ldw	r17,188(sp)
 820ec14:	dc002e17 	ldw	r16,184(sp)
 820ec18:	dec03804 	addi	sp,sp,224
 820ec1c:	f800283a 	ret
 820ec20:	dac02417 	ldw	r11,144(sp)
 820ec24:	d9002017 	ldw	r4,128(sp)
 820ec28:	5939c83a 	sub	fp,r11,r4
 820ec2c:	073f780e 	bge	zero,fp,820ea10 <___svfiprintf_internal_r+0xa6c>
 820ec30:	02400404 	movi	r9,16
 820ec34:	4f01370e 	bge	r9,fp,820f114 <___svfiprintf_internal_r+0x1170>
 820ec38:	02c20974 	movhi	r11,2085
 820ec3c:	5af64a04 	addi	r11,r11,-9944
 820ec40:	dac02215 	stw	r11,136(sp)
 820ec44:	028001c4 	movi	r10,7
 820ec48:	00000306 	br	820ec58 <___svfiprintf_internal_r+0xcb4>
 820ec4c:	e73ffc04 	addi	fp,fp,-16
 820ec50:	42000204 	addi	r8,r8,8
 820ec54:	4f00150e 	bge	r9,fp,820ecac <___svfiprintf_internal_r+0xd08>
 820ec58:	18c00404 	addi	r3,r3,16
 820ec5c:	10800044 	addi	r2,r2,1
 820ec60:	45000015 	stw	r20,0(r8)
 820ec64:	42400115 	stw	r9,4(r8)
 820ec68:	d8c01c15 	stw	r3,112(sp)
 820ec6c:	d8801b15 	stw	r2,108(sp)
 820ec70:	50bff60e 	bge	r10,r2,820ec4c <___svfiprintf_internal_r+0xca8>
 820ec74:	d9801a04 	addi	r6,sp,104
 820ec78:	b80b883a 	mov	r5,r23
 820ec7c:	a809883a 	mov	r4,r21
 820ec80:	da402c15 	stw	r9,176(sp)
 820ec84:	da802d15 	stw	r10,180(sp)
 820ec88:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ec8c:	da402c17 	ldw	r9,176(sp)
 820ec90:	da802d17 	ldw	r10,180(sp)
 820ec94:	103fd11e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ec98:	e73ffc04 	addi	fp,fp,-16
 820ec9c:	d8c01c17 	ldw	r3,112(sp)
 820eca0:	d8801b17 	ldw	r2,108(sp)
 820eca4:	d811883a 	mov	r8,sp
 820eca8:	4f3feb16 	blt	r9,fp,820ec58 <___svfiprintf_internal_r+0xcb4>
 820ecac:	dac02217 	ldw	r11,136(sp)
 820ecb0:	1f07883a 	add	r3,r3,fp
 820ecb4:	10800044 	addi	r2,r2,1
 820ecb8:	42c00015 	stw	r11,0(r8)
 820ecbc:	47000115 	stw	fp,4(r8)
 820ecc0:	d8c01c15 	stw	r3,112(sp)
 820ecc4:	d8801b15 	stw	r2,108(sp)
 820ecc8:	010001c4 	movi	r4,7
 820eccc:	2080b616 	blt	r4,r2,820efa8 <___svfiprintf_internal_r+0x1004>
 820ecd0:	42000204 	addi	r8,r8,8
 820ecd4:	003f4e06 	br	820ea10 <___svfiprintf_internal_r+0xa6c>
 820ecd8:	d9801a04 	addi	r6,sp,104
 820ecdc:	b80b883a 	mov	r5,r23
 820ece0:	a809883a 	mov	r4,r21
 820ece4:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ece8:	103fbc1e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ecec:	d8c01c17 	ldw	r3,112(sp)
 820ecf0:	d811883a 	mov	r8,sp
 820ecf4:	003f7a06 	br	820eae0 <___svfiprintf_internal_r+0xb3c>
 820ecf8:	d9801a04 	addi	r6,sp,104
 820ecfc:	b80b883a 	mov	r5,r23
 820ed00:	a809883a 	mov	r4,r21
 820ed04:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ed08:	103fa826 	beq	r2,zero,820ebac <___svfiprintf_internal_r+0xc08>
 820ed0c:	003fb306 	br	820ebdc <___svfiprintf_internal_r+0xc38>
 820ed10:	d9801a04 	addi	r6,sp,104
 820ed14:	b80b883a 	mov	r5,r23
 820ed18:	a809883a 	mov	r4,r21
 820ed1c:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ed20:	103fae1e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ed24:	d811883a 	mov	r8,sp
 820ed28:	003cdc06 	br	820e09c <___svfiprintf_internal_r+0xf8>
 820ed2c:	d9801a04 	addi	r6,sp,104
 820ed30:	b80b883a 	mov	r5,r23
 820ed34:	a809883a 	mov	r4,r21
 820ed38:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ed3c:	103fa71e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ed40:	d8c01c17 	ldw	r3,112(sp)
 820ed44:	d8801b17 	ldw	r2,108(sp)
 820ed48:	d811883a 	mov	r8,sp
 820ed4c:	003f5a06 	br	820eab8 <___svfiprintf_internal_r+0xb14>
 820ed50:	d9801a04 	addi	r6,sp,104
 820ed54:	b80b883a 	mov	r5,r23
 820ed58:	a809883a 	mov	r4,r21
 820ed5c:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ed60:	103f9e1e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ed64:	d8c01c17 	ldw	r3,112(sp)
 820ed68:	d8801b17 	ldw	r2,108(sp)
 820ed6c:	d811883a 	mov	r8,sp
 820ed70:	003f1706 	br	820e9d0 <___svfiprintf_internal_r+0xa2c>
 820ed74:	d9801a04 	addi	r6,sp,104
 820ed78:	b80b883a 	mov	r5,r23
 820ed7c:	a809883a 	mov	r4,r21
 820ed80:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ed84:	103f951e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ed88:	d8c01c17 	ldw	r3,112(sp)
 820ed8c:	d8801b17 	ldw	r2,108(sp)
 820ed90:	d811883a 	mov	r8,sp
 820ed94:	003f1b06 	br	820ea04 <___svfiprintf_internal_r+0xa60>
 820ed98:	d8001d85 	stb	zero,118(sp)
 820ed9c:	80007b16 	blt	r16,zero,820ef8c <___svfiprintf_internal_r+0xfe8>
 820eda0:	00ffdfc4 	movi	r3,-129
 820eda4:	e244b03a 	or	r2,fp,r9
 820eda8:	90e4703a 	and	r18,r18,r3
 820edac:	103d7026 	beq	r2,zero,820e370 <___svfiprintf_internal_r+0x3cc>
 820edb0:	0015883a 	mov	r10,zero
 820edb4:	003d7206 	br	820e380 <___svfiprintf_internal_r+0x3dc>
 820edb8:	d9801a04 	addi	r6,sp,104
 820edbc:	b80b883a 	mov	r5,r23
 820edc0:	a809883a 	mov	r4,r21
 820edc4:	820ddd40 	call	820ddd4 <__ssprint_r>
 820edc8:	103f841e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820edcc:	d8c01c17 	ldw	r3,112(sp)
 820edd0:	d8801b17 	ldw	r2,108(sp)
 820edd4:	d811883a 	mov	r8,sp
 820edd8:	003ef006 	br	820e99c <___svfiprintf_internal_r+0x9f8>
 820eddc:	9080100c 	andi	r2,r18,64
 820ede0:	d8001d85 	stb	zero,118(sp)
 820ede4:	dac02317 	ldw	r11,140(sp)
 820ede8:	10008126 	beq	r2,zero,820eff0 <___svfiprintf_internal_r+0x104c>
 820edec:	58800104 	addi	r2,r11,4
 820edf0:	5f00000b 	ldhu	fp,0(r11)
 820edf4:	0013883a 	mov	r9,zero
 820edf8:	803ec30e 	bge	r16,zero,820e908 <___svfiprintf_internal_r+0x964>
 820edfc:	d8802315 	stw	r2,140(sp)
 820ee00:	0015883a 	mov	r10,zero
 820ee04:	e244b03a 	or	r2,fp,r9
 820ee08:	103e371e 	bne	r2,zero,820e6e8 <___svfiprintf_internal_r+0x744>
 820ee0c:	00800044 	movi	r2,1
 820ee10:	10803fcc 	andi	r2,r2,255
 820ee14:	00c00044 	movi	r3,1
 820ee18:	10c06126 	beq	r2,r3,820efa0 <___svfiprintf_internal_r+0xffc>
 820ee1c:	00c00084 	movi	r3,2
 820ee20:	10fd5526 	beq	r2,r3,820e378 <___svfiprintf_internal_r+0x3d4>
 820ee24:	003ed806 	br	820e988 <___svfiprintf_internal_r+0x9e4>
 820ee28:	d8802315 	stw	r2,140(sp)
 820ee2c:	98c00007 	ldb	r3,0(r19)
 820ee30:	003cab06 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820ee34:	d9801a04 	addi	r6,sp,104
 820ee38:	b80b883a 	mov	r5,r23
 820ee3c:	a809883a 	mov	r4,r21
 820ee40:	820ddd40 	call	820ddd4 <__ssprint_r>
 820ee44:	103f651e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820ee48:	d8c01c17 	ldw	r3,112(sp)
 820ee4c:	003f4f06 	br	820eb8c <___svfiprintf_internal_r+0xbe8>
 820ee50:	00820974 	movhi	r2,2085
 820ee54:	10b5e204 	addi	r2,r2,-10360
 820ee58:	d8802915 	stw	r2,164(sp)
 820ee5c:	003d4406 	br	820e370 <___svfiprintf_internal_r+0x3cc>
 820ee60:	dac02317 	ldw	r11,140(sp)
 820ee64:	58800017 	ldw	r2,0(r11)
 820ee68:	dac02517 	ldw	r11,148(sp)
 820ee6c:	5807d7fa 	srai	r3,r11,31
 820ee70:	dac02317 	ldw	r11,140(sp)
 820ee74:	10c00115 	stw	r3,4(r2)
 820ee78:	5ac00104 	addi	r11,r11,4
 820ee7c:	dac02315 	stw	r11,140(sp)
 820ee80:	dac02517 	ldw	r11,148(sp)
 820ee84:	12c00015 	stw	r11,0(r2)
 820ee88:	003c6d06 	br	820e040 <___svfiprintf_internal_r+0x9c>
 820ee8c:	9080100c 	andi	r2,r18,64
 820ee90:	dac02317 	ldw	r11,140(sp)
 820ee94:	103e5326 	beq	r2,zero,820e7e4 <___svfiprintf_internal_r+0x840>
 820ee98:	5f00000f 	ldh	fp,0(r11)
 820ee9c:	5ac00104 	addi	r11,r11,4
 820eea0:	dac02315 	stw	r11,140(sp)
 820eea4:	e013d7fa 	srai	r9,fp,31
 820eea8:	4805883a 	mov	r2,r9
 820eeac:	003e0706 	br	820e6cc <___svfiprintf_internal_r+0x728>
 820eeb0:	00800c04 	movi	r2,48
 820eeb4:	d8801d05 	stb	r2,116(sp)
 820eeb8:	d8c01d45 	stb	r3,117(sp)
 820eebc:	d8001d85 	stb	zero,118(sp)
 820eec0:	90800094 	ori	r2,r18,2
 820eec4:	80008f16 	blt	r16,zero,820f104 <___svfiprintf_internal_r+0x1160>
 820eec8:	00bfdfc4 	movi	r2,-129
 820eecc:	90a4703a 	and	r18,r18,r2
 820eed0:	94800094 	ori	r18,r18,2
 820eed4:	0015883a 	mov	r10,zero
 820eed8:	003d2906 	br	820e380 <___svfiprintf_internal_r+0x3dc>
 820eedc:	98c00007 	ldb	r3,0(r19)
 820eee0:	003c7f06 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820eee4:	dac02317 	ldw	r11,140(sp)
 820eee8:	0013883a 	mov	r9,zero
 820eeec:	5f000017 	ldw	fp,0(r11)
 820eef0:	5ac00104 	addi	r11,r11,4
 820eef4:	dac02315 	stw	r11,140(sp)
 820eef8:	003d1506 	br	820e350 <___svfiprintf_internal_r+0x3ac>
 820eefc:	9080100c 	andi	r2,r18,64
 820ef00:	d8001d85 	stb	zero,118(sp)
 820ef04:	dac02317 	ldw	r11,140(sp)
 820ef08:	10003426 	beq	r2,zero,820efdc <___svfiprintf_internal_r+0x1038>
 820ef0c:	58800104 	addi	r2,r11,4
 820ef10:	5f00000b 	ldhu	fp,0(r11)
 820ef14:	0013883a 	mov	r9,zero
 820ef18:	803e950e 	bge	r16,zero,820e970 <___svfiprintf_internal_r+0x9cc>
 820ef1c:	e246b03a 	or	r3,fp,r9
 820ef20:	d8802315 	stw	r2,140(sp)
 820ef24:	183d5a1e 	bne	r3,zero,820e490 <___svfiprintf_internal_r+0x4ec>
 820ef28:	0015883a 	mov	r10,zero
 820ef2c:	0005883a 	mov	r2,zero
 820ef30:	003fb706 	br	820ee10 <___svfiprintf_internal_r+0xe6c>
 820ef34:	98c00043 	ldbu	r3,1(r19)
 820ef38:	94800814 	ori	r18,r18,32
 820ef3c:	9cc00044 	addi	r19,r19,1
 820ef40:	18c03fcc 	andi	r3,r3,255
 820ef44:	18c0201c 	xori	r3,r3,128
 820ef48:	18ffe004 	addi	r3,r3,-128
 820ef4c:	003c6406 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820ef50:	d8c02315 	stw	r3,140(sp)
 820ef54:	0015883a 	mov	r10,zero
 820ef58:	003faa06 	br	820ee04 <___svfiprintf_internal_r+0xe60>
 820ef5c:	dac02317 	ldw	r11,140(sp)
 820ef60:	58800017 	ldw	r2,0(r11)
 820ef64:	5ac00104 	addi	r11,r11,4
 820ef68:	dac02315 	stw	r11,140(sp)
 820ef6c:	dac02517 	ldw	r11,148(sp)
 820ef70:	12c00015 	stw	r11,0(r2)
 820ef74:	003c3206 	br	820e040 <___svfiprintf_internal_r+0x9c>
 820ef78:	01020974 	movhi	r4,2085
 820ef7c:	2135e204 	addi	r4,r4,-10360
 820ef80:	d9002915 	stw	r4,164(sp)
 820ef84:	d8c02315 	stw	r3,140(sp)
 820ef88:	1025883a 	mov	r18,r2
 820ef8c:	e244b03a 	or	r2,fp,r9
 820ef90:	103f871e 	bne	r2,zero,820edb0 <___svfiprintf_internal_r+0xe0c>
 820ef94:	0015883a 	mov	r10,zero
 820ef98:	00800084 	movi	r2,2
 820ef9c:	003f9c06 	br	820ee10 <___svfiprintf_internal_r+0xe6c>
 820efa0:	0039883a 	mov	fp,zero
 820efa4:	003e5f06 	br	820e924 <___svfiprintf_internal_r+0x980>
 820efa8:	d9801a04 	addi	r6,sp,104
 820efac:	b80b883a 	mov	r5,r23
 820efb0:	a809883a 	mov	r4,r21
 820efb4:	820ddd40 	call	820ddd4 <__ssprint_r>
 820efb8:	103f081e 	bne	r2,zero,820ebdc <___svfiprintf_internal_r+0xc38>
 820efbc:	d8c01c17 	ldw	r3,112(sp)
 820efc0:	d8801b17 	ldw	r2,108(sp)
 820efc4:	d811883a 	mov	r8,sp
 820efc8:	003e9106 	br	820ea10 <___svfiprintf_internal_r+0xa6c>
 820efcc:	01020974 	movhi	r4,2085
 820efd0:	21364a04 	addi	r4,r4,-9944
 820efd4:	d9002215 	stw	r4,136(sp)
 820efd8:	003ead06 	br	820ea90 <___svfiprintf_internal_r+0xaec>
 820efdc:	58800104 	addi	r2,r11,4
 820efe0:	5f000017 	ldw	fp,0(r11)
 820efe4:	0013883a 	mov	r9,zero
 820efe8:	803e610e 	bge	r16,zero,820e970 <___svfiprintf_internal_r+0x9cc>
 820efec:	003fcb06 	br	820ef1c <___svfiprintf_internal_r+0xf78>
 820eff0:	58800104 	addi	r2,r11,4
 820eff4:	5f000017 	ldw	fp,0(r11)
 820eff8:	0013883a 	mov	r9,zero
 820effc:	803e420e 	bge	r16,zero,820e908 <___svfiprintf_internal_r+0x964>
 820f000:	003f7e06 	br	820edfc <___svfiprintf_internal_r+0xe58>
 820f004:	5f000017 	ldw	fp,0(r11)
 820f008:	5ac00104 	addi	r11,r11,4
 820f00c:	0013883a 	mov	r9,zero
 820f010:	dac02315 	stw	r11,140(sp)
 820f014:	003cce06 	br	820e350 <___svfiprintf_internal_r+0x3ac>
 820f018:	8809883a 	mov	r4,r17
 820f01c:	da002c15 	stw	r8,176(sp)
 820f020:	8203cac0 	call	8203cac <strlen>
 820f024:	d8802115 	stw	r2,132(sp)
 820f028:	da801d83 	ldbu	r10,118(sp)
 820f02c:	df002315 	stw	fp,140(sp)
 820f030:	0021883a 	mov	r16,zero
 820f034:	da002c17 	ldw	r8,176(sp)
 820f038:	003cf606 	br	820e414 <___svfiprintf_internal_r+0x470>
 820f03c:	00800184 	movi	r2,6
 820f040:	1400012e 	bgeu	r2,r16,820f048 <___svfiprintf_internal_r+0x10a4>
 820f044:	1021883a 	mov	r16,r2
 820f048:	dc002115 	stw	r16,132(sp)
 820f04c:	8005883a 	mov	r2,r16
 820f050:	80003c16 	blt	r16,zero,820f144 <___svfiprintf_internal_r+0x11a0>
 820f054:	04420974 	movhi	r17,2085
 820f058:	d8802015 	stw	r2,128(sp)
 820f05c:	df002315 	stw	fp,140(sp)
 820f060:	8c75e704 	addi	r17,r17,-10340
 820f064:	003d2e06 	br	820e520 <___svfiprintf_internal_r+0x57c>
 820f068:	04001004 	movi	r16,64
 820f06c:	800b883a 	mov	r5,r16
 820f070:	820ba380 	call	820ba38 <_malloc_r>
 820f074:	dac02717 	ldw	r11,156(sp)
 820f078:	58800015 	stw	r2,0(r11)
 820f07c:	58800415 	stw	r2,16(r11)
 820f080:	10004826 	beq	r2,zero,820f1a4 <___svfiprintf_internal_r+0x1200>
 820f084:	dac02717 	ldw	r11,156(sp)
 820f088:	5c000515 	stw	r16,20(r11)
 820f08c:	003bd906 	br	820dff4 <___svfiprintf_internal_r+0x50>
 820f090:	9080004c 	andi	r2,r18,1
 820f094:	0015883a 	mov	r10,zero
 820f098:	10000626 	beq	r2,zero,820f0b4 <___svfiprintf_internal_r+0x1110>
 820f09c:	dac02b17 	ldw	r11,172(sp)
 820f0a0:	00800c04 	movi	r2,48
 820f0a4:	d88019c5 	stb	r2,103(sp)
 820f0a8:	dac02115 	stw	r11,132(sp)
 820f0ac:	dc4019c4 	addi	r17,sp,103
 820f0b0:	003cd806 	br	820e414 <___svfiprintf_internal_r+0x470>
 820f0b4:	d8002115 	stw	zero,132(sp)
 820f0b8:	dc401a04 	addi	r17,sp,104
 820f0bc:	003cd506 	br	820e414 <___svfiprintf_internal_r+0x470>
 820f0c0:	01020974 	movhi	r4,2085
 820f0c4:	21364e04 	addi	r4,r4,-9928
 820f0c8:	d9002815 	stw	r4,160(sp)
 820f0cc:	003d4306 	br	820e5dc <___svfiprintf_internal_r+0x638>
 820f0d0:	00bfffc4 	movi	r2,-1
 820f0d4:	003ec606 	br	820ebf0 <___svfiprintf_internal_r+0xc4c>
 820f0d8:	00800044 	movi	r2,1
 820f0dc:	10803fcc 	andi	r2,r2,255
 820f0e0:	00c00044 	movi	r3,1
 820f0e4:	10fd8026 	beq	r2,r3,820e6e8 <___svfiprintf_internal_r+0x744>
 820f0e8:	00c00084 	movi	r3,2
 820f0ec:	10fca426 	beq	r2,r3,820e380 <___svfiprintf_internal_r+0x3dc>
 820f0f0:	003ce806 	br	820e494 <___svfiprintf_internal_r+0x4f0>
 820f0f4:	01020974 	movhi	r4,2085
 820f0f8:	21364e04 	addi	r4,r4,-9928
 820f0fc:	d9002815 	stw	r4,160(sp)
 820f100:	003e9906 	br	820eb68 <___svfiprintf_internal_r+0xbc4>
 820f104:	1025883a 	mov	r18,r2
 820f108:	0015883a 	mov	r10,zero
 820f10c:	00800084 	movi	r2,2
 820f110:	003ff206 	br	820f0dc <___svfiprintf_internal_r+0x1138>
 820f114:	01420974 	movhi	r5,2085
 820f118:	29764a04 	addi	r5,r5,-9944
 820f11c:	d9402215 	stw	r5,136(sp)
 820f120:	003ee206 	br	820ecac <___svfiprintf_internal_r+0xd08>
 820f124:	5827883a 	mov	r19,r11
 820f128:	0021883a 	mov	r16,zero
 820f12c:	003bed06 	br	820e0e4 <___svfiprintf_internal_r+0x140>
 820f130:	dc002115 	stw	r16,132(sp)
 820f134:	da801d83 	ldbu	r10,118(sp)
 820f138:	df002315 	stw	fp,140(sp)
 820f13c:	0021883a 	mov	r16,zero
 820f140:	003cb406 	br	820e414 <___svfiprintf_internal_r+0x470>
 820f144:	0005883a 	mov	r2,zero
 820f148:	003fc206 	br	820f054 <___svfiprintf_internal_r+0x10b0>
 820f14c:	d8802317 	ldw	r2,140(sp)
 820f150:	98c00043 	ldbu	r3,1(r19)
 820f154:	5827883a 	mov	r19,r11
 820f158:	14000017 	ldw	r16,0(r2)
 820f15c:	10800104 	addi	r2,r2,4
 820f160:	d8802315 	stw	r2,140(sp)
 820f164:	803f760e 	bge	r16,zero,820ef40 <___svfiprintf_internal_r+0xf9c>
 820f168:	18c03fcc 	andi	r3,r3,255
 820f16c:	18c0201c 	xori	r3,r3,128
 820f170:	043fffc4 	movi	r16,-1
 820f174:	18ffe004 	addi	r3,r3,-128
 820f178:	003bd906 	br	820e0e0 <___svfiprintf_internal_r+0x13c>
 820f17c:	d9c01d85 	stb	r7,118(sp)
 820f180:	003cb606 	br	820e45c <___svfiprintf_internal_r+0x4b8>
 820f184:	d9c01d85 	stb	r7,118(sp)
 820f188:	003d2106 	br	820e610 <___svfiprintf_internal_r+0x66c>
 820f18c:	d9c01d85 	stb	r7,118(sp)
 820f190:	003d8e06 	br	820e7cc <___svfiprintf_internal_r+0x828>
 820f194:	d9c01d85 	stb	r7,118(sp)
 820f198:	003db306 	br	820e868 <___svfiprintf_internal_r+0x8c4>
 820f19c:	d9c01d85 	stb	r7,118(sp)
 820f1a0:	003c8a06 	br	820e3cc <___svfiprintf_internal_r+0x428>
 820f1a4:	dac02a17 	ldw	r11,168(sp)
 820f1a8:	00800304 	movi	r2,12
 820f1ac:	58800015 	stw	r2,0(r11)
 820f1b0:	00bfffc4 	movi	r2,-1
 820f1b4:	003e8e06 	br	820ebf0 <___svfiprintf_internal_r+0xc4c>
 820f1b8:	d9c01d85 	stb	r7,118(sp)
 820f1bc:	003dc706 	br	820e8dc <___svfiprintf_internal_r+0x938>
 820f1c0:	d9c01d85 	stb	r7,118(sp)
 820f1c4:	003ddf06 	br	820e944 <___svfiprintf_internal_r+0x9a0>
 820f1c8:	d9c01d85 	stb	r7,118(sp)
 820f1cc:	003d3706 	br	820e6ac <___svfiprintf_internal_r+0x708>
 820f1d0:	d9c01d85 	stb	r7,118(sp)
 820f1d4:	003c5406 	br	820e328 <___svfiprintf_internal_r+0x384>
 820f1d8:	d9c01d85 	stb	r7,118(sp)
 820f1dc:	003d1d06 	br	820e654 <___svfiprintf_internal_r+0x6b0>

0820f1e0 <__sprint_r.part.0>:
 820f1e0:	28801917 	ldw	r2,100(r5)
 820f1e4:	defff604 	addi	sp,sp,-40
 820f1e8:	dd400515 	stw	r21,20(sp)
 820f1ec:	dfc00915 	stw	ra,36(sp)
 820f1f0:	df000815 	stw	fp,32(sp)
 820f1f4:	ddc00715 	stw	r23,28(sp)
 820f1f8:	dd800615 	stw	r22,24(sp)
 820f1fc:	dd000415 	stw	r20,16(sp)
 820f200:	dcc00315 	stw	r19,12(sp)
 820f204:	dc800215 	stw	r18,8(sp)
 820f208:	dc400115 	stw	r17,4(sp)
 820f20c:	dc000015 	stw	r16,0(sp)
 820f210:	1088000c 	andi	r2,r2,8192
 820f214:	302b883a 	mov	r21,r6
 820f218:	10002e26 	beq	r2,zero,820f2d4 <__sprint_r.part.0+0xf4>
 820f21c:	30800217 	ldw	r2,8(r6)
 820f220:	35800017 	ldw	r22,0(r6)
 820f224:	10002926 	beq	r2,zero,820f2cc <__sprint_r.part.0+0xec>
 820f228:	2827883a 	mov	r19,r5
 820f22c:	2029883a 	mov	r20,r4
 820f230:	b5c00104 	addi	r23,r22,4
 820f234:	04bfffc4 	movi	r18,-1
 820f238:	bc400017 	ldw	r17,0(r23)
 820f23c:	b4000017 	ldw	r16,0(r22)
 820f240:	0039883a 	mov	fp,zero
 820f244:	8822d0ba 	srli	r17,r17,2
 820f248:	8800031e 	bne	r17,zero,820f258 <__sprint_r.part.0+0x78>
 820f24c:	00001806 	br	820f2b0 <__sprint_r.part.0+0xd0>
 820f250:	84000104 	addi	r16,r16,4
 820f254:	8f001526 	beq	r17,fp,820f2ac <__sprint_r.part.0+0xcc>
 820f258:	81400017 	ldw	r5,0(r16)
 820f25c:	980d883a 	mov	r6,r19
 820f260:	a009883a 	mov	r4,r20
 820f264:	8210c080 	call	8210c08 <_fputwc_r>
 820f268:	e7000044 	addi	fp,fp,1
 820f26c:	14bff81e 	bne	r2,r18,820f250 <__sprint_r.part.0+0x70>
 820f270:	9005883a 	mov	r2,r18
 820f274:	a8000215 	stw	zero,8(r21)
 820f278:	a8000115 	stw	zero,4(r21)
 820f27c:	dfc00917 	ldw	ra,36(sp)
 820f280:	df000817 	ldw	fp,32(sp)
 820f284:	ddc00717 	ldw	r23,28(sp)
 820f288:	dd800617 	ldw	r22,24(sp)
 820f28c:	dd400517 	ldw	r21,20(sp)
 820f290:	dd000417 	ldw	r20,16(sp)
 820f294:	dcc00317 	ldw	r19,12(sp)
 820f298:	dc800217 	ldw	r18,8(sp)
 820f29c:	dc400117 	ldw	r17,4(sp)
 820f2a0:	dc000017 	ldw	r16,0(sp)
 820f2a4:	dec00a04 	addi	sp,sp,40
 820f2a8:	f800283a 	ret
 820f2ac:	a8800217 	ldw	r2,8(r21)
 820f2b0:	8c63883a 	add	r17,r17,r17
 820f2b4:	8c63883a 	add	r17,r17,r17
 820f2b8:	1445c83a 	sub	r2,r2,r17
 820f2bc:	a8800215 	stw	r2,8(r21)
 820f2c0:	b5800204 	addi	r22,r22,8
 820f2c4:	bdc00204 	addi	r23,r23,8
 820f2c8:	103fdb1e 	bne	r2,zero,820f238 <__sprint_r.part.0+0x58>
 820f2cc:	0005883a 	mov	r2,zero
 820f2d0:	003fe806 	br	820f274 <__sprint_r.part.0+0x94>
 820f2d4:	820b15c0 	call	820b15c <__sfvwrite_r>
 820f2d8:	003fe606 	br	820f274 <__sprint_r.part.0+0x94>

0820f2dc <__sprint_r>:
 820f2dc:	30c00217 	ldw	r3,8(r6)
 820f2e0:	18000126 	beq	r3,zero,820f2e8 <__sprint_r+0xc>
 820f2e4:	820f1e01 	jmpi	820f1e0 <__sprint_r.part.0>
 820f2e8:	30000115 	stw	zero,4(r6)
 820f2ec:	0005883a 	mov	r2,zero
 820f2f0:	f800283a 	ret

0820f2f4 <___vfiprintf_internal_r>:
 820f2f4:	deffc904 	addi	sp,sp,-220
 820f2f8:	df003515 	stw	fp,212(sp)
 820f2fc:	dd003115 	stw	r20,196(sp)
 820f300:	dfc03615 	stw	ra,216(sp)
 820f304:	ddc03415 	stw	r23,208(sp)
 820f308:	dd803315 	stw	r22,204(sp)
 820f30c:	dd403215 	stw	r21,200(sp)
 820f310:	dcc03015 	stw	r19,192(sp)
 820f314:	dc802f15 	stw	r18,188(sp)
 820f318:	dc402e15 	stw	r17,184(sp)
 820f31c:	dc002d15 	stw	r16,180(sp)
 820f320:	d9002015 	stw	r4,128(sp)
 820f324:	d9c02215 	stw	r7,136(sp)
 820f328:	2829883a 	mov	r20,r5
 820f32c:	3039883a 	mov	fp,r6
 820f330:	20000226 	beq	r4,zero,820f33c <___vfiprintf_internal_r+0x48>
 820f334:	20800e17 	ldw	r2,56(r4)
 820f338:	1000cf26 	beq	r2,zero,820f678 <___vfiprintf_internal_r+0x384>
 820f33c:	a080030b 	ldhu	r2,12(r20)
 820f340:	10c8000c 	andi	r3,r2,8192
 820f344:	1800061e 	bne	r3,zero,820f360 <___vfiprintf_internal_r+0x6c>
 820f348:	a1001917 	ldw	r4,100(r20)
 820f34c:	00f7ffc4 	movi	r3,-8193
 820f350:	10880014 	ori	r2,r2,8192
 820f354:	20c6703a 	and	r3,r4,r3
 820f358:	a080030d 	sth	r2,12(r20)
 820f35c:	a0c01915 	stw	r3,100(r20)
 820f360:	10c0020c 	andi	r3,r2,8
 820f364:	1800a926 	beq	r3,zero,820f60c <___vfiprintf_internal_r+0x318>
 820f368:	a0c00417 	ldw	r3,16(r20)
 820f36c:	1800a726 	beq	r3,zero,820f60c <___vfiprintf_internal_r+0x318>
 820f370:	1080068c 	andi	r2,r2,26
 820f374:	00c00284 	movi	r3,10
 820f378:	10c0ac26 	beq	r2,r3,820f62c <___vfiprintf_internal_r+0x338>
 820f37c:	da801a04 	addi	r10,sp,104
 820f380:	da801e15 	stw	r10,120(sp)
 820f384:	d8801e17 	ldw	r2,120(sp)
 820f388:	da8019c4 	addi	r10,sp,103
 820f38c:	05820974 	movhi	r22,2085
 820f390:	05c20974 	movhi	r23,2085
 820f394:	da801f15 	stw	r10,124(sp)
 820f398:	1295c83a 	sub	r10,r2,r10
 820f39c:	b5b65604 	addi	r22,r22,-9896
 820f3a0:	bdf65204 	addi	r23,r23,-9912
 820f3a4:	dec01a15 	stw	sp,104(sp)
 820f3a8:	d8001c15 	stw	zero,112(sp)
 820f3ac:	d8001b15 	stw	zero,108(sp)
 820f3b0:	d8002615 	stw	zero,152(sp)
 820f3b4:	d8002315 	stw	zero,140(sp)
 820f3b8:	da802715 	stw	r10,156(sp)
 820f3bc:	d811883a 	mov	r8,sp
 820f3c0:	dd002115 	stw	r20,132(sp)
 820f3c4:	e021883a 	mov	r16,fp
 820f3c8:	80800007 	ldb	r2,0(r16)
 820f3cc:	1003ea26 	beq	r2,zero,8210378 <___vfiprintf_internal_r+0x1084>
 820f3d0:	00c00944 	movi	r3,37
 820f3d4:	8025883a 	mov	r18,r16
 820f3d8:	10c0021e 	bne	r2,r3,820f3e4 <___vfiprintf_internal_r+0xf0>
 820f3dc:	00001606 	br	820f438 <___vfiprintf_internal_r+0x144>
 820f3e0:	10c00326 	beq	r2,r3,820f3f0 <___vfiprintf_internal_r+0xfc>
 820f3e4:	94800044 	addi	r18,r18,1
 820f3e8:	90800007 	ldb	r2,0(r18)
 820f3ec:	103ffc1e 	bne	r2,zero,820f3e0 <___vfiprintf_internal_r+0xec>
 820f3f0:	9423c83a 	sub	r17,r18,r16
 820f3f4:	88001026 	beq	r17,zero,820f438 <___vfiprintf_internal_r+0x144>
 820f3f8:	d8c01c17 	ldw	r3,112(sp)
 820f3fc:	d8801b17 	ldw	r2,108(sp)
 820f400:	44000015 	stw	r16,0(r8)
 820f404:	88c7883a 	add	r3,r17,r3
 820f408:	10800044 	addi	r2,r2,1
 820f40c:	44400115 	stw	r17,4(r8)
 820f410:	d8c01c15 	stw	r3,112(sp)
 820f414:	d8801b15 	stw	r2,108(sp)
 820f418:	010001c4 	movi	r4,7
 820f41c:	2080760e 	bge	r4,r2,820f5f8 <___vfiprintf_internal_r+0x304>
 820f420:	1803821e 	bne	r3,zero,821022c <___vfiprintf_internal_r+0xf38>
 820f424:	da802317 	ldw	r10,140(sp)
 820f428:	d8001b15 	stw	zero,108(sp)
 820f42c:	d811883a 	mov	r8,sp
 820f430:	5455883a 	add	r10,r10,r17
 820f434:	da802315 	stw	r10,140(sp)
 820f438:	90800007 	ldb	r2,0(r18)
 820f43c:	10044626 	beq	r2,zero,8210558 <___vfiprintf_internal_r+0x1264>
 820f440:	90c00047 	ldb	r3,1(r18)
 820f444:	94000044 	addi	r16,r18,1
 820f448:	d8001d85 	stb	zero,118(sp)
 820f44c:	0009883a 	mov	r4,zero
 820f450:	000f883a 	mov	r7,zero
 820f454:	027fffc4 	movi	r9,-1
 820f458:	0023883a 	mov	r17,zero
 820f45c:	0029883a 	mov	r20,zero
 820f460:	01401604 	movi	r5,88
 820f464:	01800244 	movi	r6,9
 820f468:	03400a84 	movi	r13,42
 820f46c:	03001b04 	movi	r12,108
 820f470:	84000044 	addi	r16,r16,1
 820f474:	18bff804 	addi	r2,r3,-32
 820f478:	28827336 	bltu	r5,r2,820fe48 <___vfiprintf_internal_r+0xb54>
 820f47c:	100490ba 	slli	r2,r2,2
 820f480:	02820874 	movhi	r10,2081
 820f484:	52bd2504 	addi	r10,r10,-2924
 820f488:	1285883a 	add	r2,r2,r10
 820f48c:	10800017 	ldw	r2,0(r2)
 820f490:	1000683a 	jmp	r2
 820f494:	0820fb7c 	xorhi	zero,at,33773
 820f498:	0820fe48 	cmpgei	zero,at,-31751
 820f49c:	0820fe48 	cmpgei	zero,at,-31751
 820f4a0:	0820fb9c 	xori	zero,at,33774
 820f4a4:	0820fe48 	cmpgei	zero,at,-31751
 820f4a8:	0820fe48 	cmpgei	zero,at,-31751
 820f4ac:	0820fe48 	cmpgei	zero,at,-31751
 820f4b0:	0820fe48 	cmpgei	zero,at,-31751
 820f4b4:	0820fe48 	cmpgei	zero,at,-31751
 820f4b8:	0820fe48 	cmpgei	zero,at,-31751
 820f4bc:	0820fd84 	addi	zero,at,-31754
 820f4c0:	0820fda0 	cmpeqi	zero,at,-31754
 820f4c4:	0820fe48 	cmpgei	zero,at,-31751
 820f4c8:	0820f688 	cmpgei	zero,at,-31782
 820f4cc:	0820fdb0 	cmpltui	zero,at,33782
 820f4d0:	0820fe48 	cmpgei	zero,at,-31751
 820f4d4:	0820fba8 	cmpgeui	zero,at,33774
 820f4d8:	0820fbb4 	orhi	zero,at,33774
 820f4dc:	0820fbb4 	orhi	zero,at,33774
 820f4e0:	0820fbb4 	orhi	zero,at,33774
 820f4e4:	0820fbb4 	orhi	zero,at,33774
 820f4e8:	0820fbb4 	orhi	zero,at,33774
 820f4ec:	0820fbb4 	orhi	zero,at,33774
 820f4f0:	0820fbb4 	orhi	zero,at,33774
 820f4f4:	0820fbb4 	orhi	zero,at,33774
 820f4f8:	0820fbb4 	orhi	zero,at,33774
 820f4fc:	0820fe48 	cmpgei	zero,at,-31751
 820f500:	0820fe48 	cmpgei	zero,at,-31751
 820f504:	0820fe48 	cmpgei	zero,at,-31751
 820f508:	0820fe48 	cmpgei	zero,at,-31751
 820f50c:	0820fe48 	cmpgei	zero,at,-31751
 820f510:	0820fe48 	cmpgei	zero,at,-31751
 820f514:	0820fe48 	cmpgei	zero,at,-31751
 820f518:	0820fe48 	cmpgei	zero,at,-31751
 820f51c:	0820fe48 	cmpgei	zero,at,-31751
 820f520:	0820fe48 	cmpgei	zero,at,-31751
 820f524:	0820fbe0 	cmpeqi	zero,at,-31761
 820f528:	0820fe48 	cmpgei	zero,at,-31751
 820f52c:	0820fe48 	cmpgei	zero,at,-31751
 820f530:	0820fe48 	cmpgei	zero,at,-31751
 820f534:	0820fe48 	cmpgei	zero,at,-31751
 820f538:	0820fe48 	cmpgei	zero,at,-31751
 820f53c:	0820fe48 	cmpgei	zero,at,-31751
 820f540:	0820fe48 	cmpgei	zero,at,-31751
 820f544:	0820fe48 	cmpgei	zero,at,-31751
 820f548:	0820fe48 	cmpgei	zero,at,-31751
 820f54c:	0820fe48 	cmpgei	zero,at,-31751
 820f550:	0820fc18 	cmpnei	zero,at,-31760
 820f554:	0820fe48 	cmpgei	zero,at,-31751
 820f558:	0820fe48 	cmpgei	zero,at,-31751
 820f55c:	0820fe48 	cmpgei	zero,at,-31751
 820f560:	0820fe48 	cmpgei	zero,at,-31751
 820f564:	0820fe48 	cmpgei	zero,at,-31751
 820f568:	0820fc70 	cmpltui	zero,at,33777
 820f56c:	0820fe48 	cmpgei	zero,at,-31751
 820f570:	0820fe48 	cmpgei	zero,at,-31751
 820f574:	0820fce0 	cmpeqi	zero,at,-31757
 820f578:	0820fe48 	cmpgei	zero,at,-31751
 820f57c:	0820fe48 	cmpgei	zero,at,-31751
 820f580:	0820fe48 	cmpgei	zero,at,-31751
 820f584:	0820fe48 	cmpgei	zero,at,-31751
 820f588:	0820fe48 	cmpgei	zero,at,-31751
 820f58c:	0820fe48 	cmpgei	zero,at,-31751
 820f590:	0820fe48 	cmpgei	zero,at,-31751
 820f594:	0820fe48 	cmpgei	zero,at,-31751
 820f598:	0820fe48 	cmpgei	zero,at,-31751
 820f59c:	0820fe48 	cmpgei	zero,at,-31751
 820f5a0:	0820fa8c 	andi	zero,at,33770
 820f5a4:	0820fab8 	rdprs	zero,at,-31766
 820f5a8:	0820fe48 	cmpgei	zero,at,-31751
 820f5ac:	0820fe48 	cmpgei	zero,at,-31751
 820f5b0:	0820fe48 	cmpgei	zero,at,-31751
 820f5b4:	0820fdf0 	cmpltui	zero,at,33783
 820f5b8:	0820fab8 	rdprs	zero,at,-31766
 820f5bc:	0820fe48 	cmpgei	zero,at,-31751
 820f5c0:	0820fe48 	cmpgei	zero,at,-31751
 820f5c4:	0820f94c 	andi	zero,at,33765
 820f5c8:	0820fe48 	cmpgei	zero,at,-31751
 820f5cc:	0820f95c 	xori	zero,at,33765
 820f5d0:	0820f998 	cmpnei	zero,at,-31770
 820f5d4:	0820f694 	ori	zero,at,33754
 820f5d8:	0820f940 	call	820f94 <OSCtxSw_SWITCH_PC+0x820f54>
 820f5dc:	0820fe48 	cmpgei	zero,at,-31751
 820f5e0:	0820fd1c 	xori	zero,at,33780
 820f5e4:	0820fe48 	cmpgei	zero,at,-31751
 820f5e8:	0820fd74 	orhi	zero,at,33781
 820f5ec:	0820fe48 	cmpgei	zero,at,-31751
 820f5f0:	0820fe48 	cmpgei	zero,at,-31751
 820f5f4:	0820fa38 	rdprs	zero,at,-31768
 820f5f8:	42000204 	addi	r8,r8,8
 820f5fc:	da802317 	ldw	r10,140(sp)
 820f600:	5455883a 	add	r10,r10,r17
 820f604:	da802315 	stw	r10,140(sp)
 820f608:	003f8b06 	br	820f438 <___vfiprintf_internal_r+0x144>
 820f60c:	d9002017 	ldw	r4,128(sp)
 820f610:	a00b883a 	mov	r5,r20
 820f614:	8208bb00 	call	8208bb0 <__swsetup_r>
 820f618:	1003b11e 	bne	r2,zero,82104e0 <___vfiprintf_internal_r+0x11ec>
 820f61c:	a080030b 	ldhu	r2,12(r20)
 820f620:	00c00284 	movi	r3,10
 820f624:	1080068c 	andi	r2,r2,26
 820f628:	10ff541e 	bne	r2,r3,820f37c <___vfiprintf_internal_r+0x88>
 820f62c:	a080038f 	ldh	r2,14(r20)
 820f630:	103f5216 	blt	r2,zero,820f37c <___vfiprintf_internal_r+0x88>
 820f634:	d9c02217 	ldw	r7,136(sp)
 820f638:	d9002017 	ldw	r4,128(sp)
 820f63c:	e00d883a 	mov	r6,fp
 820f640:	a00b883a 	mov	r5,r20
 820f644:	821076c0 	call	821076c <__sbprintf>
 820f648:	dfc03617 	ldw	ra,216(sp)
 820f64c:	df003517 	ldw	fp,212(sp)
 820f650:	ddc03417 	ldw	r23,208(sp)
 820f654:	dd803317 	ldw	r22,204(sp)
 820f658:	dd403217 	ldw	r21,200(sp)
 820f65c:	dd003117 	ldw	r20,196(sp)
 820f660:	dcc03017 	ldw	r19,192(sp)
 820f664:	dc802f17 	ldw	r18,188(sp)
 820f668:	dc402e17 	ldw	r17,184(sp)
 820f66c:	dc002d17 	ldw	r16,180(sp)
 820f670:	dec03704 	addi	sp,sp,220
 820f674:	f800283a 	ret
 820f678:	820ab840 	call	820ab84 <__sinit>
 820f67c:	003f2f06 	br	820f33c <___vfiprintf_internal_r+0x48>
 820f680:	0463c83a 	sub	r17,zero,r17
 820f684:	d8802215 	stw	r2,136(sp)
 820f688:	a5000114 	ori	r20,r20,4
 820f68c:	80c00007 	ldb	r3,0(r16)
 820f690:	003f7706 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820f694:	00800c04 	movi	r2,48
 820f698:	da802217 	ldw	r10,136(sp)
 820f69c:	d8801d05 	stb	r2,116(sp)
 820f6a0:	00801e04 	movi	r2,120
 820f6a4:	d8801d45 	stb	r2,117(sp)
 820f6a8:	d8001d85 	stb	zero,118(sp)
 820f6ac:	50c00104 	addi	r3,r10,4
 820f6b0:	54800017 	ldw	r18,0(r10)
 820f6b4:	0027883a 	mov	r19,zero
 820f6b8:	a0800094 	ori	r2,r20,2
 820f6bc:	48030b16 	blt	r9,zero,82102ec <___vfiprintf_internal_r+0xff8>
 820f6c0:	00bfdfc4 	movi	r2,-129
 820f6c4:	a096703a 	and	r11,r20,r2
 820f6c8:	d8c02215 	stw	r3,136(sp)
 820f6cc:	5d000094 	ori	r20,r11,2
 820f6d0:	90032b1e 	bne	r18,zero,8210380 <___vfiprintf_internal_r+0x108c>
 820f6d4:	00820974 	movhi	r2,2085
 820f6d8:	10b5e204 	addi	r2,r2,-10360
 820f6dc:	d8802615 	stw	r2,152(sp)
 820f6e0:	0039883a 	mov	fp,zero
 820f6e4:	48017b1e 	bne	r9,zero,820fcd4 <___vfiprintf_internal_r+0x9e0>
 820f6e8:	0013883a 	mov	r9,zero
 820f6ec:	0027883a 	mov	r19,zero
 820f6f0:	dd401a04 	addi	r21,sp,104
 820f6f4:	4825883a 	mov	r18,r9
 820f6f8:	4cc0010e 	bge	r9,r19,820f700 <___vfiprintf_internal_r+0x40c>
 820f6fc:	9825883a 	mov	r18,r19
 820f700:	e7003fcc 	andi	fp,fp,255
 820f704:	e700201c 	xori	fp,fp,128
 820f708:	e73fe004 	addi	fp,fp,-128
 820f70c:	e0000126 	beq	fp,zero,820f714 <___vfiprintf_internal_r+0x420>
 820f710:	94800044 	addi	r18,r18,1
 820f714:	a380008c 	andi	r14,r20,2
 820f718:	70000126 	beq	r14,zero,820f720 <___vfiprintf_internal_r+0x42c>
 820f71c:	94800084 	addi	r18,r18,2
 820f720:	a700210c 	andi	fp,r20,132
 820f724:	e001df1e 	bne	fp,zero,820fea4 <___vfiprintf_internal_r+0xbb0>
 820f728:	8c87c83a 	sub	r3,r17,r18
 820f72c:	00c1dd0e 	bge	zero,r3,820fea4 <___vfiprintf_internal_r+0xbb0>
 820f730:	01c00404 	movi	r7,16
 820f734:	d8801c17 	ldw	r2,112(sp)
 820f738:	38c3ad0e 	bge	r7,r3,82105f0 <___vfiprintf_internal_r+0x12fc>
 820f73c:	02820974 	movhi	r10,2085
 820f740:	52b65604 	addi	r10,r10,-9896
 820f744:	dc002915 	stw	r16,164(sp)
 820f748:	d9801b17 	ldw	r6,108(sp)
 820f74c:	da802415 	stw	r10,144(sp)
 820f750:	03c001c4 	movi	r15,7
 820f754:	da402515 	stw	r9,148(sp)
 820f758:	db802815 	stw	r14,160(sp)
 820f75c:	1821883a 	mov	r16,r3
 820f760:	00000506 	br	820f778 <___vfiprintf_internal_r+0x484>
 820f764:	31400084 	addi	r5,r6,2
 820f768:	42000204 	addi	r8,r8,8
 820f76c:	200d883a 	mov	r6,r4
 820f770:	843ffc04 	addi	r16,r16,-16
 820f774:	3c000d0e 	bge	r7,r16,820f7ac <___vfiprintf_internal_r+0x4b8>
 820f778:	10800404 	addi	r2,r2,16
 820f77c:	31000044 	addi	r4,r6,1
 820f780:	45800015 	stw	r22,0(r8)
 820f784:	41c00115 	stw	r7,4(r8)
 820f788:	d8801c15 	stw	r2,112(sp)
 820f78c:	d9001b15 	stw	r4,108(sp)
 820f790:	793ff40e 	bge	r15,r4,820f764 <___vfiprintf_internal_r+0x470>
 820f794:	1001b51e 	bne	r2,zero,820fe6c <___vfiprintf_internal_r+0xb78>
 820f798:	843ffc04 	addi	r16,r16,-16
 820f79c:	000d883a 	mov	r6,zero
 820f7a0:	01400044 	movi	r5,1
 820f7a4:	d811883a 	mov	r8,sp
 820f7a8:	3c3ff316 	blt	r7,r16,820f778 <___vfiprintf_internal_r+0x484>
 820f7ac:	8007883a 	mov	r3,r16
 820f7b0:	da402517 	ldw	r9,148(sp)
 820f7b4:	db802817 	ldw	r14,160(sp)
 820f7b8:	dc002917 	ldw	r16,164(sp)
 820f7bc:	da802417 	ldw	r10,144(sp)
 820f7c0:	1885883a 	add	r2,r3,r2
 820f7c4:	40c00115 	stw	r3,4(r8)
 820f7c8:	42800015 	stw	r10,0(r8)
 820f7cc:	d8801c15 	stw	r2,112(sp)
 820f7d0:	d9401b15 	stw	r5,108(sp)
 820f7d4:	00c001c4 	movi	r3,7
 820f7d8:	19426016 	blt	r3,r5,821015c <___vfiprintf_internal_r+0xe68>
 820f7dc:	d8c01d87 	ldb	r3,118(sp)
 820f7e0:	42000204 	addi	r8,r8,8
 820f7e4:	29000044 	addi	r4,r5,1
 820f7e8:	1801b31e 	bne	r3,zero,820feb8 <___vfiprintf_internal_r+0xbc4>
 820f7ec:	7001c026 	beq	r14,zero,820fef0 <___vfiprintf_internal_r+0xbfc>
 820f7f0:	d8c01d04 	addi	r3,sp,116
 820f7f4:	10800084 	addi	r2,r2,2
 820f7f8:	40c00015 	stw	r3,0(r8)
 820f7fc:	00c00084 	movi	r3,2
 820f800:	40c00115 	stw	r3,4(r8)
 820f804:	d8801c15 	stw	r2,112(sp)
 820f808:	d9001b15 	stw	r4,108(sp)
 820f80c:	00c001c4 	movi	r3,7
 820f810:	1902650e 	bge	r3,r4,82101a8 <___vfiprintf_internal_r+0xeb4>
 820f814:	10029a1e 	bne	r2,zero,8210280 <___vfiprintf_internal_r+0xf8c>
 820f818:	00c02004 	movi	r3,128
 820f81c:	01000044 	movi	r4,1
 820f820:	000b883a 	mov	r5,zero
 820f824:	d811883a 	mov	r8,sp
 820f828:	e0c1b31e 	bne	fp,r3,820fef8 <___vfiprintf_internal_r+0xc04>
 820f82c:	8cb9c83a 	sub	fp,r17,r18
 820f830:	0701b10e 	bge	zero,fp,820fef8 <___vfiprintf_internal_r+0xc04>
 820f834:	01c00404 	movi	r7,16
 820f838:	3f03890e 	bge	r7,fp,8210660 <___vfiprintf_internal_r+0x136c>
 820f83c:	00c20974 	movhi	r3,2085
 820f840:	18f65204 	addi	r3,r3,-9912
 820f844:	d8c02415 	stw	r3,144(sp)
 820f848:	8007883a 	mov	r3,r16
 820f84c:	034001c4 	movi	r13,7
 820f850:	e021883a 	mov	r16,fp
 820f854:	da402515 	stw	r9,148(sp)
 820f858:	1839883a 	mov	fp,r3
 820f85c:	00000506 	br	820f874 <___vfiprintf_internal_r+0x580>
 820f860:	29800084 	addi	r6,r5,2
 820f864:	42000204 	addi	r8,r8,8
 820f868:	180b883a 	mov	r5,r3
 820f86c:	843ffc04 	addi	r16,r16,-16
 820f870:	3c000d0e 	bge	r7,r16,820f8a8 <___vfiprintf_internal_r+0x5b4>
 820f874:	10800404 	addi	r2,r2,16
 820f878:	28c00044 	addi	r3,r5,1
 820f87c:	45c00015 	stw	r23,0(r8)
 820f880:	41c00115 	stw	r7,4(r8)
 820f884:	d8801c15 	stw	r2,112(sp)
 820f888:	d8c01b15 	stw	r3,108(sp)
 820f88c:	68fff40e 	bge	r13,r3,820f860 <___vfiprintf_internal_r+0x56c>
 820f890:	1002241e 	bne	r2,zero,8210124 <___vfiprintf_internal_r+0xe30>
 820f894:	843ffc04 	addi	r16,r16,-16
 820f898:	01800044 	movi	r6,1
 820f89c:	000b883a 	mov	r5,zero
 820f8a0:	d811883a 	mov	r8,sp
 820f8a4:	3c3ff316 	blt	r7,r16,820f874 <___vfiprintf_internal_r+0x580>
 820f8a8:	da402517 	ldw	r9,148(sp)
 820f8ac:	e007883a 	mov	r3,fp
 820f8b0:	8039883a 	mov	fp,r16
 820f8b4:	1821883a 	mov	r16,r3
 820f8b8:	d8c02417 	ldw	r3,144(sp)
 820f8bc:	1705883a 	add	r2,r2,fp
 820f8c0:	47000115 	stw	fp,4(r8)
 820f8c4:	40c00015 	stw	r3,0(r8)
 820f8c8:	d8801c15 	stw	r2,112(sp)
 820f8cc:	d9801b15 	stw	r6,108(sp)
 820f8d0:	00c001c4 	movi	r3,7
 820f8d4:	19827616 	blt	r3,r6,82102b0 <___vfiprintf_internal_r+0xfbc>
 820f8d8:	4cf9c83a 	sub	fp,r9,r19
 820f8dc:	42000204 	addi	r8,r8,8
 820f8e0:	31000044 	addi	r4,r6,1
 820f8e4:	300b883a 	mov	r5,r6
 820f8e8:	07018516 	blt	zero,fp,820ff00 <___vfiprintf_internal_r+0xc0c>
 820f8ec:	9885883a 	add	r2,r19,r2
 820f8f0:	45400015 	stw	r21,0(r8)
 820f8f4:	44c00115 	stw	r19,4(r8)
 820f8f8:	d8801c15 	stw	r2,112(sp)
 820f8fc:	d9001b15 	stw	r4,108(sp)
 820f900:	00c001c4 	movi	r3,7
 820f904:	1901dd0e 	bge	r3,r4,821007c <___vfiprintf_internal_r+0xd88>
 820f908:	1002401e 	bne	r2,zero,821020c <___vfiprintf_internal_r+0xf18>
 820f90c:	d8001b15 	stw	zero,108(sp)
 820f910:	a2c0010c 	andi	r11,r20,4
 820f914:	58000226 	beq	r11,zero,820f920 <___vfiprintf_internal_r+0x62c>
 820f918:	8ca7c83a 	sub	r19,r17,r18
 820f91c:	04c2f216 	blt	zero,r19,82104e8 <___vfiprintf_internal_r+0x11f4>
 820f920:	8c80010e 	bge	r17,r18,820f928 <___vfiprintf_internal_r+0x634>
 820f924:	9023883a 	mov	r17,r18
 820f928:	da802317 	ldw	r10,140(sp)
 820f92c:	5455883a 	add	r10,r10,r17
 820f930:	da802315 	stw	r10,140(sp)
 820f934:	d8001b15 	stw	zero,108(sp)
 820f938:	d811883a 	mov	r8,sp
 820f93c:	003ea206 	br	820f3c8 <___vfiprintf_internal_r+0xd4>
 820f940:	a5000814 	ori	r20,r20,32
 820f944:	80c00007 	ldb	r3,0(r16)
 820f948:	003ec906 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820f94c:	80c00007 	ldb	r3,0(r16)
 820f950:	1b030926 	beq	r3,r12,8210578 <___vfiprintf_internal_r+0x1284>
 820f954:	a5000414 	ori	r20,r20,16
 820f958:	003ec506 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820f95c:	21003fcc 	andi	r4,r4,255
 820f960:	20035e1e 	bne	r4,zero,82106dc <___vfiprintf_internal_r+0x13e8>
 820f964:	a080080c 	andi	r2,r20,32
 820f968:	1002a526 	beq	r2,zero,8210400 <___vfiprintf_internal_r+0x110c>
 820f96c:	da802217 	ldw	r10,136(sp)
 820f970:	50800017 	ldw	r2,0(r10)
 820f974:	da802317 	ldw	r10,140(sp)
 820f978:	5007d7fa 	srai	r3,r10,31
 820f97c:	da802217 	ldw	r10,136(sp)
 820f980:	10c00115 	stw	r3,4(r2)
 820f984:	52800104 	addi	r10,r10,4
 820f988:	da802215 	stw	r10,136(sp)
 820f98c:	da802317 	ldw	r10,140(sp)
 820f990:	12800015 	stw	r10,0(r2)
 820f994:	003e8c06 	br	820f3c8 <___vfiprintf_internal_r+0xd4>
 820f998:	21003fcc 	andi	r4,r4,255
 820f99c:	2003511e 	bne	r4,zero,82106e4 <___vfiprintf_internal_r+0x13f0>
 820f9a0:	a080080c 	andi	r2,r20,32
 820f9a4:	1000a126 	beq	r2,zero,820fc2c <___vfiprintf_internal_r+0x938>
 820f9a8:	da802217 	ldw	r10,136(sp)
 820f9ac:	d8001d85 	stb	zero,118(sp)
 820f9b0:	50800204 	addi	r2,r10,8
 820f9b4:	54800017 	ldw	r18,0(r10)
 820f9b8:	54c00117 	ldw	r19,4(r10)
 820f9bc:	4802b416 	blt	r9,zero,8210490 <___vfiprintf_internal_r+0x119c>
 820f9c0:	013fdfc4 	movi	r4,-129
 820f9c4:	94c6b03a 	or	r3,r18,r19
 820f9c8:	d8802215 	stw	r2,136(sp)
 820f9cc:	a128703a 	and	r20,r20,r4
 820f9d0:	1800a226 	beq	r3,zero,820fc5c <___vfiprintf_internal_r+0x968>
 820f9d4:	0039883a 	mov	fp,zero
 820f9d8:	dd401a04 	addi	r21,sp,104
 820f9dc:	9006d0fa 	srli	r3,r18,3
 820f9e0:	9808977a 	slli	r4,r19,29
 820f9e4:	9826d0fa 	srli	r19,r19,3
 820f9e8:	948001cc 	andi	r18,r18,7
 820f9ec:	90800c04 	addi	r2,r18,48
 820f9f0:	ad7fffc4 	addi	r21,r21,-1
 820f9f4:	20e4b03a 	or	r18,r4,r3
 820f9f8:	a8800005 	stb	r2,0(r21)
 820f9fc:	94c6b03a 	or	r3,r18,r19
 820fa00:	183ff61e 	bne	r3,zero,820f9dc <___vfiprintf_internal_r+0x6e8>
 820fa04:	a0c0004c 	andi	r3,r20,1
 820fa08:	18005926 	beq	r3,zero,820fb70 <___vfiprintf_internal_r+0x87c>
 820fa0c:	10803fcc 	andi	r2,r2,255
 820fa10:	1080201c 	xori	r2,r2,128
 820fa14:	10bfe004 	addi	r2,r2,-128
 820fa18:	00c00c04 	movi	r3,48
 820fa1c:	10c05426 	beq	r2,r3,820fb70 <___vfiprintf_internal_r+0x87c>
 820fa20:	da801e17 	ldw	r10,120(sp)
 820fa24:	a8bfffc4 	addi	r2,r21,-1
 820fa28:	a8ffffc5 	stb	r3,-1(r21)
 820fa2c:	50a7c83a 	sub	r19,r10,r2
 820fa30:	102b883a 	mov	r21,r2
 820fa34:	003f2f06 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 820fa38:	21003fcc 	andi	r4,r4,255
 820fa3c:	2003421e 	bne	r4,zero,8210748 <___vfiprintf_internal_r+0x1454>
 820fa40:	00820974 	movhi	r2,2085
 820fa44:	10b5e204 	addi	r2,r2,-10360
 820fa48:	d8802615 	stw	r2,152(sp)
 820fa4c:	a080080c 	andi	r2,r20,32
 820fa50:	1000aa26 	beq	r2,zero,820fcfc <___vfiprintf_internal_r+0xa08>
 820fa54:	da802217 	ldw	r10,136(sp)
 820fa58:	54800017 	ldw	r18,0(r10)
 820fa5c:	54c00117 	ldw	r19,4(r10)
 820fa60:	52800204 	addi	r10,r10,8
 820fa64:	da802215 	stw	r10,136(sp)
 820fa68:	a080004c 	andi	r2,r20,1
 820fa6c:	1001d226 	beq	r2,zero,82101b8 <___vfiprintf_internal_r+0xec4>
 820fa70:	94c4b03a 	or	r2,r18,r19
 820fa74:	1002351e 	bne	r2,zero,821034c <___vfiprintf_internal_r+0x1058>
 820fa78:	d8001d85 	stb	zero,118(sp)
 820fa7c:	48022216 	blt	r9,zero,8210308 <___vfiprintf_internal_r+0x1014>
 820fa80:	00bfdfc4 	movi	r2,-129
 820fa84:	a0a8703a 	and	r20,r20,r2
 820fa88:	003f1506 	br	820f6e0 <___vfiprintf_internal_r+0x3ec>
 820fa8c:	da802217 	ldw	r10,136(sp)
 820fa90:	04800044 	movi	r18,1
 820fa94:	d8001d85 	stb	zero,118(sp)
 820fa98:	50800017 	ldw	r2,0(r10)
 820fa9c:	52800104 	addi	r10,r10,4
 820faa0:	da802215 	stw	r10,136(sp)
 820faa4:	d8801005 	stb	r2,64(sp)
 820faa8:	9027883a 	mov	r19,r18
 820faac:	dd401004 	addi	r21,sp,64
 820fab0:	0013883a 	mov	r9,zero
 820fab4:	003f1706 	br	820f714 <___vfiprintf_internal_r+0x420>
 820fab8:	21003fcc 	andi	r4,r4,255
 820fabc:	2003201e 	bne	r4,zero,8210740 <___vfiprintf_internal_r+0x144c>
 820fac0:	a080080c 	andi	r2,r20,32
 820fac4:	10004b26 	beq	r2,zero,820fbf4 <___vfiprintf_internal_r+0x900>
 820fac8:	da802217 	ldw	r10,136(sp)
 820facc:	50800117 	ldw	r2,4(r10)
 820fad0:	54800017 	ldw	r18,0(r10)
 820fad4:	52800204 	addi	r10,r10,8
 820fad8:	da802215 	stw	r10,136(sp)
 820fadc:	1027883a 	mov	r19,r2
 820fae0:	10022c16 	blt	r2,zero,8210394 <___vfiprintf_internal_r+0x10a0>
 820fae4:	df001d83 	ldbu	fp,118(sp)
 820fae8:	48007216 	blt	r9,zero,820fcb4 <___vfiprintf_internal_r+0x9c0>
 820faec:	00ffdfc4 	movi	r3,-129
 820faf0:	94c4b03a 	or	r2,r18,r19
 820faf4:	a0e8703a 	and	r20,r20,r3
 820faf8:	1000cc26 	beq	r2,zero,820fe2c <___vfiprintf_internal_r+0xb38>
 820fafc:	98021026 	beq	r19,zero,8210340 <___vfiprintf_internal_r+0x104c>
 820fb00:	dc402415 	stw	r17,144(sp)
 820fb04:	dc002515 	stw	r16,148(sp)
 820fb08:	9823883a 	mov	r17,r19
 820fb0c:	9021883a 	mov	r16,r18
 820fb10:	dd401a04 	addi	r21,sp,104
 820fb14:	4825883a 	mov	r18,r9
 820fb18:	4027883a 	mov	r19,r8
 820fb1c:	8009883a 	mov	r4,r16
 820fb20:	880b883a 	mov	r5,r17
 820fb24:	01800284 	movi	r6,10
 820fb28:	000f883a 	mov	r7,zero
 820fb2c:	821157c0 	call	821157c <__umoddi3>
 820fb30:	10800c04 	addi	r2,r2,48
 820fb34:	ad7fffc4 	addi	r21,r21,-1
 820fb38:	8009883a 	mov	r4,r16
 820fb3c:	880b883a 	mov	r5,r17
 820fb40:	a8800005 	stb	r2,0(r21)
 820fb44:	01800284 	movi	r6,10
 820fb48:	000f883a 	mov	r7,zero
 820fb4c:	82110040 	call	8211004 <__udivdi3>
 820fb50:	1021883a 	mov	r16,r2
 820fb54:	10c4b03a 	or	r2,r2,r3
 820fb58:	1823883a 	mov	r17,r3
 820fb5c:	103fef1e 	bne	r2,zero,820fb1c <___vfiprintf_internal_r+0x828>
 820fb60:	dc402417 	ldw	r17,144(sp)
 820fb64:	dc002517 	ldw	r16,148(sp)
 820fb68:	9013883a 	mov	r9,r18
 820fb6c:	9811883a 	mov	r8,r19
 820fb70:	da801e17 	ldw	r10,120(sp)
 820fb74:	5567c83a 	sub	r19,r10,r21
 820fb78:	003ede06 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 820fb7c:	38803fcc 	andi	r2,r7,255
 820fb80:	1080201c 	xori	r2,r2,128
 820fb84:	10bfe004 	addi	r2,r2,-128
 820fb88:	1002371e 	bne	r2,zero,8210468 <___vfiprintf_internal_r+0x1174>
 820fb8c:	01000044 	movi	r4,1
 820fb90:	01c00804 	movi	r7,32
 820fb94:	80c00007 	ldb	r3,0(r16)
 820fb98:	003e3506 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820fb9c:	a5000054 	ori	r20,r20,1
 820fba0:	80c00007 	ldb	r3,0(r16)
 820fba4:	003e3206 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820fba8:	a5002014 	ori	r20,r20,128
 820fbac:	80c00007 	ldb	r3,0(r16)
 820fbb0:	003e2f06 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820fbb4:	8015883a 	mov	r10,r16
 820fbb8:	0023883a 	mov	r17,zero
 820fbbc:	18bff404 	addi	r2,r3,-48
 820fbc0:	50c00007 	ldb	r3,0(r10)
 820fbc4:	8c4002a4 	muli	r17,r17,10
 820fbc8:	84000044 	addi	r16,r16,1
 820fbcc:	8015883a 	mov	r10,r16
 820fbd0:	1463883a 	add	r17,r2,r17
 820fbd4:	18bff404 	addi	r2,r3,-48
 820fbd8:	30bff92e 	bgeu	r6,r2,820fbc0 <___vfiprintf_internal_r+0x8cc>
 820fbdc:	003e2506 	br	820f474 <___vfiprintf_internal_r+0x180>
 820fbe0:	21003fcc 	andi	r4,r4,255
 820fbe4:	2002d41e 	bne	r4,zero,8210738 <___vfiprintf_internal_r+0x1444>
 820fbe8:	a5000414 	ori	r20,r20,16
 820fbec:	a080080c 	andi	r2,r20,32
 820fbf0:	103fb51e 	bne	r2,zero,820fac8 <___vfiprintf_internal_r+0x7d4>
 820fbf4:	a080040c 	andi	r2,r20,16
 820fbf8:	1001f826 	beq	r2,zero,82103dc <___vfiprintf_internal_r+0x10e8>
 820fbfc:	da802217 	ldw	r10,136(sp)
 820fc00:	54800017 	ldw	r18,0(r10)
 820fc04:	52800104 	addi	r10,r10,4
 820fc08:	da802215 	stw	r10,136(sp)
 820fc0c:	9027d7fa 	srai	r19,r18,31
 820fc10:	9805883a 	mov	r2,r19
 820fc14:	003fb206 	br	820fae0 <___vfiprintf_internal_r+0x7ec>
 820fc18:	21003fcc 	andi	r4,r4,255
 820fc1c:	2002c41e 	bne	r4,zero,8210730 <___vfiprintf_internal_r+0x143c>
 820fc20:	a5000414 	ori	r20,r20,16
 820fc24:	a080080c 	andi	r2,r20,32
 820fc28:	103f5f1e 	bne	r2,zero,820f9a8 <___vfiprintf_internal_r+0x6b4>
 820fc2c:	a080040c 	andi	r2,r20,16
 820fc30:	10020f26 	beq	r2,zero,8210470 <___vfiprintf_internal_r+0x117c>
 820fc34:	da802217 	ldw	r10,136(sp)
 820fc38:	d8001d85 	stb	zero,118(sp)
 820fc3c:	0027883a 	mov	r19,zero
 820fc40:	50800104 	addi	r2,r10,4
 820fc44:	54800017 	ldw	r18,0(r10)
 820fc48:	48021116 	blt	r9,zero,8210490 <___vfiprintf_internal_r+0x119c>
 820fc4c:	00ffdfc4 	movi	r3,-129
 820fc50:	d8802215 	stw	r2,136(sp)
 820fc54:	a0e8703a 	and	r20,r20,r3
 820fc58:	903f5e1e 	bne	r18,zero,820f9d4 <___vfiprintf_internal_r+0x6e0>
 820fc5c:	0039883a 	mov	fp,zero
 820fc60:	4802a626 	beq	r9,zero,82106fc <___vfiprintf_internal_r+0x1408>
 820fc64:	0025883a 	mov	r18,zero
 820fc68:	0027883a 	mov	r19,zero
 820fc6c:	003f5a06 	br	820f9d8 <___vfiprintf_internal_r+0x6e4>
 820fc70:	21003fcc 	andi	r4,r4,255
 820fc74:	20029f1e 	bne	r4,zero,82106f4 <___vfiprintf_internal_r+0x1400>
 820fc78:	a5000414 	ori	r20,r20,16
 820fc7c:	a080080c 	andi	r2,r20,32
 820fc80:	10005e1e 	bne	r2,zero,820fdfc <___vfiprintf_internal_r+0xb08>
 820fc84:	a080040c 	andi	r2,r20,16
 820fc88:	1001a21e 	bne	r2,zero,8210314 <___vfiprintf_internal_r+0x1020>
 820fc8c:	a080100c 	andi	r2,r20,64
 820fc90:	d8001d85 	stb	zero,118(sp)
 820fc94:	da802217 	ldw	r10,136(sp)
 820fc98:	1002231e 	bne	r2,zero,8210528 <___vfiprintf_internal_r+0x1234>
 820fc9c:	50800104 	addi	r2,r10,4
 820fca0:	54800017 	ldw	r18,0(r10)
 820fca4:	0027883a 	mov	r19,zero
 820fca8:	4801a00e 	bge	r9,zero,821032c <___vfiprintf_internal_r+0x1038>
 820fcac:	d8802215 	stw	r2,136(sp)
 820fcb0:	0039883a 	mov	fp,zero
 820fcb4:	94c4b03a 	or	r2,r18,r19
 820fcb8:	103f901e 	bne	r2,zero,820fafc <___vfiprintf_internal_r+0x808>
 820fcbc:	00800044 	movi	r2,1
 820fcc0:	10803fcc 	andi	r2,r2,255
 820fcc4:	00c00044 	movi	r3,1
 820fcc8:	10c05926 	beq	r2,r3,820fe30 <___vfiprintf_internal_r+0xb3c>
 820fccc:	00c00084 	movi	r3,2
 820fcd0:	10ffe41e 	bne	r2,r3,820fc64 <___vfiprintf_internal_r+0x970>
 820fcd4:	0025883a 	mov	r18,zero
 820fcd8:	0027883a 	mov	r19,zero
 820fcdc:	00013d06 	br	82101d4 <___vfiprintf_internal_r+0xee0>
 820fce0:	21003fcc 	andi	r4,r4,255
 820fce4:	2002811e 	bne	r4,zero,82106ec <___vfiprintf_internal_r+0x13f8>
 820fce8:	00820974 	movhi	r2,2085
 820fcec:	10b5dd04 	addi	r2,r2,-10380
 820fcf0:	d8802615 	stw	r2,152(sp)
 820fcf4:	a080080c 	andi	r2,r20,32
 820fcf8:	103f561e 	bne	r2,zero,820fa54 <___vfiprintf_internal_r+0x760>
 820fcfc:	a080040c 	andi	r2,r20,16
 820fd00:	1001d126 	beq	r2,zero,8210448 <___vfiprintf_internal_r+0x1154>
 820fd04:	da802217 	ldw	r10,136(sp)
 820fd08:	0027883a 	mov	r19,zero
 820fd0c:	54800017 	ldw	r18,0(r10)
 820fd10:	52800104 	addi	r10,r10,4
 820fd14:	da802215 	stw	r10,136(sp)
 820fd18:	003f5306 	br	820fa68 <___vfiprintf_internal_r+0x774>
 820fd1c:	da802217 	ldw	r10,136(sp)
 820fd20:	d8001d85 	stb	zero,118(sp)
 820fd24:	55400017 	ldw	r21,0(r10)
 820fd28:	50c00104 	addi	r3,r10,4
 820fd2c:	a8024226 	beq	r21,zero,8210638 <___vfiprintf_internal_r+0x1344>
 820fd30:	48021816 	blt	r9,zero,8210594 <___vfiprintf_internal_r+0x12a0>
 820fd34:	480d883a 	mov	r6,r9
 820fd38:	000b883a 	mov	r5,zero
 820fd3c:	a809883a 	mov	r4,r21
 820fd40:	d8c02a15 	stw	r3,168(sp)
 820fd44:	da002b15 	stw	r8,172(sp)
 820fd48:	da402c15 	stw	r9,176(sp)
 820fd4c:	820c2440 	call	820c244 <memchr>
 820fd50:	d8c02a17 	ldw	r3,168(sp)
 820fd54:	da002b17 	ldw	r8,172(sp)
 820fd58:	da402c17 	ldw	r9,176(sp)
 820fd5c:	10024826 	beq	r2,zero,8210680 <___vfiprintf_internal_r+0x138c>
 820fd60:	1567c83a 	sub	r19,r2,r21
 820fd64:	df001d83 	ldbu	fp,118(sp)
 820fd68:	d8c02215 	stw	r3,136(sp)
 820fd6c:	0013883a 	mov	r9,zero
 820fd70:	003e6006 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 820fd74:	21003fcc 	andi	r4,r4,255
 820fd78:	203fc026 	beq	r4,zero,820fc7c <___vfiprintf_internal_r+0x988>
 820fd7c:	d9c01d85 	stb	r7,118(sp)
 820fd80:	003fbe06 	br	820fc7c <___vfiprintf_internal_r+0x988>
 820fd84:	da802217 	ldw	r10,136(sp)
 820fd88:	54400017 	ldw	r17,0(r10)
 820fd8c:	50800104 	addi	r2,r10,4
 820fd90:	883e3b16 	blt	r17,zero,820f680 <___vfiprintf_internal_r+0x38c>
 820fd94:	d8802215 	stw	r2,136(sp)
 820fd98:	80c00007 	ldb	r3,0(r16)
 820fd9c:	003db406 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820fda0:	01000044 	movi	r4,1
 820fda4:	01c00ac4 	movi	r7,43
 820fda8:	80c00007 	ldb	r3,0(r16)
 820fdac:	003db006 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820fdb0:	80c00007 	ldb	r3,0(r16)
 820fdb4:	82800044 	addi	r10,r16,1
 820fdb8:	1b423c26 	beq	r3,r13,82106ac <___vfiprintf_internal_r+0x13b8>
 820fdbc:	18bff404 	addi	r2,r3,-48
 820fdc0:	0013883a 	mov	r9,zero
 820fdc4:	30822b36 	bltu	r6,r2,8210674 <___vfiprintf_internal_r+0x1380>
 820fdc8:	50c00007 	ldb	r3,0(r10)
 820fdcc:	4a4002a4 	muli	r9,r9,10
 820fdd0:	54000044 	addi	r16,r10,1
 820fdd4:	8015883a 	mov	r10,r16
 820fdd8:	4893883a 	add	r9,r9,r2
 820fddc:	18bff404 	addi	r2,r3,-48
 820fde0:	30bff92e 	bgeu	r6,r2,820fdc8 <___vfiprintf_internal_r+0xad4>
 820fde4:	483da30e 	bge	r9,zero,820f474 <___vfiprintf_internal_r+0x180>
 820fde8:	027fffc4 	movi	r9,-1
 820fdec:	003da106 	br	820f474 <___vfiprintf_internal_r+0x180>
 820fdf0:	a5001014 	ori	r20,r20,64
 820fdf4:	80c00007 	ldb	r3,0(r16)
 820fdf8:	003d9d06 	br	820f470 <___vfiprintf_internal_r+0x17c>
 820fdfc:	da802217 	ldw	r10,136(sp)
 820fe00:	d8001d85 	stb	zero,118(sp)
 820fe04:	50c00204 	addi	r3,r10,8
 820fe08:	54800017 	ldw	r18,0(r10)
 820fe0c:	54c00117 	ldw	r19,4(r10)
 820fe10:	4801ca16 	blt	r9,zero,821053c <___vfiprintf_internal_r+0x1248>
 820fe14:	013fdfc4 	movi	r4,-129
 820fe18:	94c4b03a 	or	r2,r18,r19
 820fe1c:	d8c02215 	stw	r3,136(sp)
 820fe20:	a128703a 	and	r20,r20,r4
 820fe24:	0039883a 	mov	fp,zero
 820fe28:	103f341e 	bne	r2,zero,820fafc <___vfiprintf_internal_r+0x808>
 820fe2c:	483e2e26 	beq	r9,zero,820f6e8 <___vfiprintf_internal_r+0x3f4>
 820fe30:	0025883a 	mov	r18,zero
 820fe34:	94800c04 	addi	r18,r18,48
 820fe38:	dc8019c5 	stb	r18,103(sp)
 820fe3c:	dcc02717 	ldw	r19,156(sp)
 820fe40:	dd4019c4 	addi	r21,sp,103
 820fe44:	003e2b06 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 820fe48:	21003fcc 	andi	r4,r4,255
 820fe4c:	2002361e 	bne	r4,zero,8210728 <___vfiprintf_internal_r+0x1434>
 820fe50:	1801c126 	beq	r3,zero,8210558 <___vfiprintf_internal_r+0x1264>
 820fe54:	04800044 	movi	r18,1
 820fe58:	d8c01005 	stb	r3,64(sp)
 820fe5c:	d8001d85 	stb	zero,118(sp)
 820fe60:	9027883a 	mov	r19,r18
 820fe64:	dd401004 	addi	r21,sp,64
 820fe68:	003f1106 	br	820fab0 <___vfiprintf_internal_r+0x7bc>
 820fe6c:	d9402117 	ldw	r5,132(sp)
 820fe70:	d9002017 	ldw	r4,128(sp)
 820fe74:	d9801a04 	addi	r6,sp,104
 820fe78:	d9c02b15 	stw	r7,172(sp)
 820fe7c:	dbc02a15 	stw	r15,168(sp)
 820fe80:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 820fe84:	d9c02b17 	ldw	r7,172(sp)
 820fe88:	dbc02a17 	ldw	r15,168(sp)
 820fe8c:	10006d1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 820fe90:	d9801b17 	ldw	r6,108(sp)
 820fe94:	d8801c17 	ldw	r2,112(sp)
 820fe98:	d811883a 	mov	r8,sp
 820fe9c:	31400044 	addi	r5,r6,1
 820fea0:	003e3306 	br	820f770 <___vfiprintf_internal_r+0x47c>
 820fea4:	d9401b17 	ldw	r5,108(sp)
 820fea8:	d8801c17 	ldw	r2,112(sp)
 820feac:	29000044 	addi	r4,r5,1
 820feb0:	d8c01d87 	ldb	r3,118(sp)
 820feb4:	183e4d26 	beq	r3,zero,820f7ec <___vfiprintf_internal_r+0x4f8>
 820feb8:	00c00044 	movi	r3,1
 820febc:	d9401d84 	addi	r5,sp,118
 820fec0:	10c5883a 	add	r2,r2,r3
 820fec4:	41400015 	stw	r5,0(r8)
 820fec8:	40c00115 	stw	r3,4(r8)
 820fecc:	d8801c15 	stw	r2,112(sp)
 820fed0:	d9001b15 	stw	r4,108(sp)
 820fed4:	014001c4 	movi	r5,7
 820fed8:	2900a90e 	bge	r5,r4,8210180 <___vfiprintf_internal_r+0xe8c>
 820fedc:	1000da1e 	bne	r2,zero,8210248 <___vfiprintf_internal_r+0xf54>
 820fee0:	7000ab1e 	bne	r14,zero,8210190 <___vfiprintf_internal_r+0xe9c>
 820fee4:	000b883a 	mov	r5,zero
 820fee8:	1809883a 	mov	r4,r3
 820feec:	d811883a 	mov	r8,sp
 820fef0:	00c02004 	movi	r3,128
 820fef4:	e0fe4d26 	beq	fp,r3,820f82c <___vfiprintf_internal_r+0x538>
 820fef8:	4cf9c83a 	sub	fp,r9,r19
 820fefc:	073e7b0e 	bge	zero,fp,820f8ec <___vfiprintf_internal_r+0x5f8>
 820ff00:	01c00404 	movi	r7,16
 820ff04:	3f01900e 	bge	r7,fp,8210548 <___vfiprintf_internal_r+0x1254>
 820ff08:	00c20974 	movhi	r3,2085
 820ff0c:	18f65204 	addi	r3,r3,-9912
 820ff10:	d8c02415 	stw	r3,144(sp)
 820ff14:	034001c4 	movi	r13,7
 820ff18:	00000506 	br	820ff30 <___vfiprintf_internal_r+0xc3c>
 820ff1c:	29000084 	addi	r4,r5,2
 820ff20:	42000204 	addi	r8,r8,8
 820ff24:	180b883a 	mov	r5,r3
 820ff28:	e73ffc04 	addi	fp,fp,-16
 820ff2c:	3f000d0e 	bge	r7,fp,820ff64 <___vfiprintf_internal_r+0xc70>
 820ff30:	10800404 	addi	r2,r2,16
 820ff34:	28c00044 	addi	r3,r5,1
 820ff38:	45c00015 	stw	r23,0(r8)
 820ff3c:	41c00115 	stw	r7,4(r8)
 820ff40:	d8801c15 	stw	r2,112(sp)
 820ff44:	d8c01b15 	stw	r3,108(sp)
 820ff48:	68fff40e 	bge	r13,r3,820ff1c <___vfiprintf_internal_r+0xc28>
 820ff4c:	1000101e 	bne	r2,zero,820ff90 <___vfiprintf_internal_r+0xc9c>
 820ff50:	e73ffc04 	addi	fp,fp,-16
 820ff54:	01000044 	movi	r4,1
 820ff58:	000b883a 	mov	r5,zero
 820ff5c:	d811883a 	mov	r8,sp
 820ff60:	3f3ff316 	blt	r7,fp,820ff30 <___vfiprintf_internal_r+0xc3c>
 820ff64:	da802417 	ldw	r10,144(sp)
 820ff68:	1705883a 	add	r2,r2,fp
 820ff6c:	47000115 	stw	fp,4(r8)
 820ff70:	42800015 	stw	r10,0(r8)
 820ff74:	d8801c15 	stw	r2,112(sp)
 820ff78:	d9001b15 	stw	r4,108(sp)
 820ff7c:	00c001c4 	movi	r3,7
 820ff80:	19003616 	blt	r3,r4,821005c <___vfiprintf_internal_r+0xd68>
 820ff84:	42000204 	addi	r8,r8,8
 820ff88:	21000044 	addi	r4,r4,1
 820ff8c:	003e5706 	br	820f8ec <___vfiprintf_internal_r+0x5f8>
 820ff90:	d9402117 	ldw	r5,132(sp)
 820ff94:	d9002017 	ldw	r4,128(sp)
 820ff98:	d9801a04 	addi	r6,sp,104
 820ff9c:	d9c02b15 	stw	r7,172(sp)
 820ffa0:	db402a15 	stw	r13,168(sp)
 820ffa4:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 820ffa8:	d9c02b17 	ldw	r7,172(sp)
 820ffac:	db402a17 	ldw	r13,168(sp)
 820ffb0:	1000241e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 820ffb4:	d9401b17 	ldw	r5,108(sp)
 820ffb8:	d8801c17 	ldw	r2,112(sp)
 820ffbc:	d811883a 	mov	r8,sp
 820ffc0:	29000044 	addi	r4,r5,1
 820ffc4:	003fd806 	br	820ff28 <___vfiprintf_internal_r+0xc34>
 820ffc8:	d9401b17 	ldw	r5,108(sp)
 820ffcc:	00c20974 	movhi	r3,2085
 820ffd0:	18f65604 	addi	r3,r3,-9896
 820ffd4:	d8c02415 	stw	r3,144(sp)
 820ffd8:	29400044 	addi	r5,r5,1
 820ffdc:	d8c02417 	ldw	r3,144(sp)
 820ffe0:	14c5883a 	add	r2,r2,r19
 820ffe4:	44c00115 	stw	r19,4(r8)
 820ffe8:	40c00015 	stw	r3,0(r8)
 820ffec:	d8801c15 	stw	r2,112(sp)
 820fff0:	d9401b15 	stw	r5,108(sp)
 820fff4:	00c001c4 	movi	r3,7
 820fff8:	1940070e 	bge	r3,r5,8210018 <___vfiprintf_internal_r+0xd24>
 820fffc:	103e4826 	beq	r2,zero,820f920 <___vfiprintf_internal_r+0x62c>
 8210000:	d9402117 	ldw	r5,132(sp)
 8210004:	d9002017 	ldw	r4,128(sp)
 8210008:	d9801a04 	addi	r6,sp,104
 821000c:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 8210010:	10000c1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 8210014:	d8801c17 	ldw	r2,112(sp)
 8210018:	8c80010e 	bge	r17,r18,8210020 <___vfiprintf_internal_r+0xd2c>
 821001c:	9023883a 	mov	r17,r18
 8210020:	da802317 	ldw	r10,140(sp)
 8210024:	5455883a 	add	r10,r10,r17
 8210028:	da802315 	stw	r10,140(sp)
 821002c:	103e4126 	beq	r2,zero,820f934 <___vfiprintf_internal_r+0x640>
 8210030:	d9402117 	ldw	r5,132(sp)
 8210034:	d9002017 	ldw	r4,128(sp)
 8210038:	d9801a04 	addi	r6,sp,104
 821003c:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 8210040:	103e3c26 	beq	r2,zero,820f934 <___vfiprintf_internal_r+0x640>
 8210044:	dd002117 	ldw	r20,132(sp)
 8210048:	a080030b 	ldhu	r2,12(r20)
 821004c:	1080100c 	andi	r2,r2,64
 8210050:	1001231e 	bne	r2,zero,82104e0 <___vfiprintf_internal_r+0x11ec>
 8210054:	d8802317 	ldw	r2,140(sp)
 8210058:	003d7b06 	br	820f648 <___vfiprintf_internal_r+0x354>
 821005c:	1000991e 	bne	r2,zero,82102c4 <___vfiprintf_internal_r+0xfd0>
 8210060:	00c00044 	movi	r3,1
 8210064:	9805883a 	mov	r2,r19
 8210068:	dd400015 	stw	r21,0(sp)
 821006c:	dcc00115 	stw	r19,4(sp)
 8210070:	dcc01c15 	stw	r19,112(sp)
 8210074:	d8c01b15 	stw	r3,108(sp)
 8210078:	d811883a 	mov	r8,sp
 821007c:	42000204 	addi	r8,r8,8
 8210080:	a2c0010c 	andi	r11,r20,4
 8210084:	583fe426 	beq	r11,zero,8210018 <___vfiprintf_internal_r+0xd24>
 8210088:	8ca7c83a 	sub	r19,r17,r18
 821008c:	04ffe20e 	bge	zero,r19,8210018 <___vfiprintf_internal_r+0xd24>
 8210090:	01c00404 	movi	r7,16
 8210094:	3cffcc0e 	bge	r7,r19,820ffc8 <___vfiprintf_internal_r+0xcd4>
 8210098:	02820974 	movhi	r10,2085
 821009c:	52b65604 	addi	r10,r10,-9896
 82100a0:	d9001b17 	ldw	r4,108(sp)
 82100a4:	da802415 	stw	r10,144(sp)
 82100a8:	382b883a 	mov	r21,r7
 82100ac:	050001c4 	movi	r20,7
 82100b0:	df002017 	ldw	fp,128(sp)
 82100b4:	00000506 	br	82100cc <___vfiprintf_internal_r+0xdd8>
 82100b8:	21400084 	addi	r5,r4,2
 82100bc:	42000204 	addi	r8,r8,8
 82100c0:	1809883a 	mov	r4,r3
 82100c4:	9cfffc04 	addi	r19,r19,-16
 82100c8:	acffc40e 	bge	r21,r19,820ffdc <___vfiprintf_internal_r+0xce8>
 82100cc:	10800404 	addi	r2,r2,16
 82100d0:	20c00044 	addi	r3,r4,1
 82100d4:	45800015 	stw	r22,0(r8)
 82100d8:	45400115 	stw	r21,4(r8)
 82100dc:	d8801c15 	stw	r2,112(sp)
 82100e0:	d8c01b15 	stw	r3,108(sp)
 82100e4:	a0fff40e 	bge	r20,r3,82100b8 <___vfiprintf_internal_r+0xdc4>
 82100e8:	1000041e 	bne	r2,zero,82100fc <___vfiprintf_internal_r+0xe08>
 82100ec:	01400044 	movi	r5,1
 82100f0:	0009883a 	mov	r4,zero
 82100f4:	d811883a 	mov	r8,sp
 82100f8:	003ff206 	br	82100c4 <___vfiprintf_internal_r+0xdd0>
 82100fc:	d9402117 	ldw	r5,132(sp)
 8210100:	d9801a04 	addi	r6,sp,104
 8210104:	e009883a 	mov	r4,fp
 8210108:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 821010c:	103fcd1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 8210110:	d9001b17 	ldw	r4,108(sp)
 8210114:	d8801c17 	ldw	r2,112(sp)
 8210118:	d811883a 	mov	r8,sp
 821011c:	21400044 	addi	r5,r4,1
 8210120:	003fe806 	br	82100c4 <___vfiprintf_internal_r+0xdd0>
 8210124:	d9402117 	ldw	r5,132(sp)
 8210128:	d9002017 	ldw	r4,128(sp)
 821012c:	d9801a04 	addi	r6,sp,104
 8210130:	d9c02b15 	stw	r7,172(sp)
 8210134:	db402a15 	stw	r13,168(sp)
 8210138:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 821013c:	d9c02b17 	ldw	r7,172(sp)
 8210140:	db402a17 	ldw	r13,168(sp)
 8210144:	103fbf1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 8210148:	d9401b17 	ldw	r5,108(sp)
 821014c:	d8801c17 	ldw	r2,112(sp)
 8210150:	d811883a 	mov	r8,sp
 8210154:	29800044 	addi	r6,r5,1
 8210158:	003dc406 	br	820f86c <___vfiprintf_internal_r+0x578>
 821015c:	1000d21e 	bne	r2,zero,82104a8 <___vfiprintf_internal_r+0x11b4>
 8210160:	d8c01d87 	ldb	r3,118(sp)
 8210164:	18009526 	beq	r3,zero,82103bc <___vfiprintf_internal_r+0x10c8>
 8210168:	00800044 	movi	r2,1
 821016c:	d8c01d84 	addi	r3,sp,118
 8210170:	1009883a 	mov	r4,r2
 8210174:	d8c00015 	stw	r3,0(sp)
 8210178:	d8800115 	stw	r2,4(sp)
 821017c:	d811883a 	mov	r8,sp
 8210180:	200b883a 	mov	r5,r4
 8210184:	42000204 	addi	r8,r8,8
 8210188:	21000044 	addi	r4,r4,1
 821018c:	003d9706 	br	820f7ec <___vfiprintf_internal_r+0x4f8>
 8210190:	d9001d04 	addi	r4,sp,116
 8210194:	00800084 	movi	r2,2
 8210198:	d9000015 	stw	r4,0(sp)
 821019c:	d8800115 	stw	r2,4(sp)
 82101a0:	1809883a 	mov	r4,r3
 82101a4:	d811883a 	mov	r8,sp
 82101a8:	200b883a 	mov	r5,r4
 82101ac:	42000204 	addi	r8,r8,8
 82101b0:	21000044 	addi	r4,r4,1
 82101b4:	003f4e06 	br	820fef0 <___vfiprintf_internal_r+0xbfc>
 82101b8:	d8001d85 	stb	zero,118(sp)
 82101bc:	48005016 	blt	r9,zero,8210300 <___vfiprintf_internal_r+0x100c>
 82101c0:	00ffdfc4 	movi	r3,-129
 82101c4:	94c4b03a 	or	r2,r18,r19
 82101c8:	a0e8703a 	and	r20,r20,r3
 82101cc:	103d4426 	beq	r2,zero,820f6e0 <___vfiprintf_internal_r+0x3ec>
 82101d0:	0039883a 	mov	fp,zero
 82101d4:	d9002617 	ldw	r4,152(sp)
 82101d8:	dd401a04 	addi	r21,sp,104
 82101dc:	908003cc 	andi	r2,r18,15
 82101e0:	9806973a 	slli	r3,r19,28
 82101e4:	2085883a 	add	r2,r4,r2
 82101e8:	9024d13a 	srli	r18,r18,4
 82101ec:	10800003 	ldbu	r2,0(r2)
 82101f0:	9826d13a 	srli	r19,r19,4
 82101f4:	ad7fffc4 	addi	r21,r21,-1
 82101f8:	1ca4b03a 	or	r18,r3,r18
 82101fc:	a8800005 	stb	r2,0(r21)
 8210200:	94c4b03a 	or	r2,r18,r19
 8210204:	103ff51e 	bne	r2,zero,82101dc <___vfiprintf_internal_r+0xee8>
 8210208:	003e5906 	br	820fb70 <___vfiprintf_internal_r+0x87c>
 821020c:	d9402117 	ldw	r5,132(sp)
 8210210:	d9002017 	ldw	r4,128(sp)
 8210214:	d9801a04 	addi	r6,sp,104
 8210218:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 821021c:	103f891e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 8210220:	d8801c17 	ldw	r2,112(sp)
 8210224:	d811883a 	mov	r8,sp
 8210228:	003f9506 	br	8210080 <___vfiprintf_internal_r+0xd8c>
 821022c:	d9402117 	ldw	r5,132(sp)
 8210230:	d9002017 	ldw	r4,128(sp)
 8210234:	d9801a04 	addi	r6,sp,104
 8210238:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 821023c:	103f811e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 8210240:	d811883a 	mov	r8,sp
 8210244:	003ced06 	br	820f5fc <___vfiprintf_internal_r+0x308>
 8210248:	d9402117 	ldw	r5,132(sp)
 821024c:	d9002017 	ldw	r4,128(sp)
 8210250:	d9801a04 	addi	r6,sp,104
 8210254:	da402c15 	stw	r9,176(sp)
 8210258:	db802a15 	stw	r14,168(sp)
 821025c:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 8210260:	da402c17 	ldw	r9,176(sp)
 8210264:	db802a17 	ldw	r14,168(sp)
 8210268:	103f761e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 821026c:	d9401b17 	ldw	r5,108(sp)
 8210270:	d8801c17 	ldw	r2,112(sp)
 8210274:	d811883a 	mov	r8,sp
 8210278:	29000044 	addi	r4,r5,1
 821027c:	003d5b06 	br	820f7ec <___vfiprintf_internal_r+0x4f8>
 8210280:	d9402117 	ldw	r5,132(sp)
 8210284:	d9002017 	ldw	r4,128(sp)
 8210288:	d9801a04 	addi	r6,sp,104
 821028c:	da402c15 	stw	r9,176(sp)
 8210290:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 8210294:	da402c17 	ldw	r9,176(sp)
 8210298:	103f6a1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 821029c:	d9401b17 	ldw	r5,108(sp)
 82102a0:	d8801c17 	ldw	r2,112(sp)
 82102a4:	d811883a 	mov	r8,sp
 82102a8:	29000044 	addi	r4,r5,1
 82102ac:	003f1006 	br	820fef0 <___vfiprintf_internal_r+0xbfc>
 82102b0:	1000c31e 	bne	r2,zero,82105c0 <___vfiprintf_internal_r+0x12cc>
 82102b4:	01000044 	movi	r4,1
 82102b8:	000b883a 	mov	r5,zero
 82102bc:	d811883a 	mov	r8,sp
 82102c0:	003f0d06 	br	820fef8 <___vfiprintf_internal_r+0xc04>
 82102c4:	d9402117 	ldw	r5,132(sp)
 82102c8:	d9002017 	ldw	r4,128(sp)
 82102cc:	d9801a04 	addi	r6,sp,104
 82102d0:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 82102d4:	103f5b1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 82102d8:	d9001b17 	ldw	r4,108(sp)
 82102dc:	d8801c17 	ldw	r2,112(sp)
 82102e0:	d811883a 	mov	r8,sp
 82102e4:	21000044 	addi	r4,r4,1
 82102e8:	003d8006 	br	820f8ec <___vfiprintf_internal_r+0x5f8>
 82102ec:	01020974 	movhi	r4,2085
 82102f0:	2135e204 	addi	r4,r4,-10360
 82102f4:	d9002615 	stw	r4,152(sp)
 82102f8:	d8c02215 	stw	r3,136(sp)
 82102fc:	1029883a 	mov	r20,r2
 8210300:	94c4b03a 	or	r2,r18,r19
 8210304:	103fb21e 	bne	r2,zero,82101d0 <___vfiprintf_internal_r+0xedc>
 8210308:	0039883a 	mov	fp,zero
 821030c:	00800084 	movi	r2,2
 8210310:	003e6b06 	br	820fcc0 <___vfiprintf_internal_r+0x9cc>
 8210314:	da802217 	ldw	r10,136(sp)
 8210318:	d8001d85 	stb	zero,118(sp)
 821031c:	0027883a 	mov	r19,zero
 8210320:	50800104 	addi	r2,r10,4
 8210324:	54800017 	ldw	r18,0(r10)
 8210328:	483e6016 	blt	r9,zero,820fcac <___vfiprintf_internal_r+0x9b8>
 821032c:	00ffdfc4 	movi	r3,-129
 8210330:	d8802215 	stw	r2,136(sp)
 8210334:	a0e8703a 	and	r20,r20,r3
 8210338:	0039883a 	mov	fp,zero
 821033c:	903ebb26 	beq	r18,zero,820fe2c <___vfiprintf_internal_r+0xb38>
 8210340:	00800244 	movi	r2,9
 8210344:	14bdee36 	bltu	r2,r18,820fb00 <___vfiprintf_internal_r+0x80c>
 8210348:	003eba06 	br	820fe34 <___vfiprintf_internal_r+0xb40>
 821034c:	00800c04 	movi	r2,48
 8210350:	d8c01d45 	stb	r3,117(sp)
 8210354:	d8801d05 	stb	r2,116(sp)
 8210358:	d8001d85 	stb	zero,118(sp)
 821035c:	a0c00094 	ori	r3,r20,2
 8210360:	4800a916 	blt	r9,zero,8210608 <___vfiprintf_internal_r+0x1314>
 8210364:	00bfdfc4 	movi	r2,-129
 8210368:	a096703a 	and	r11,r20,r2
 821036c:	5d000094 	ori	r20,r11,2
 8210370:	0039883a 	mov	fp,zero
 8210374:	003f9706 	br	82101d4 <___vfiprintf_internal_r+0xee0>
 8210378:	8025883a 	mov	r18,r16
 821037c:	003c2e06 	br	820f438 <___vfiprintf_internal_r+0x144>
 8210380:	00820974 	movhi	r2,2085
 8210384:	10b5e204 	addi	r2,r2,-10360
 8210388:	0039883a 	mov	fp,zero
 821038c:	d8802615 	stw	r2,152(sp)
 8210390:	003f9006 	br	82101d4 <___vfiprintf_internal_r+0xee0>
 8210394:	04a5c83a 	sub	r18,zero,r18
 8210398:	07000b44 	movi	fp,45
 821039c:	9004c03a 	cmpne	r2,r18,zero
 82103a0:	04e7c83a 	sub	r19,zero,r19
 82103a4:	df001d85 	stb	fp,118(sp)
 82103a8:	98a7c83a 	sub	r19,r19,r2
 82103ac:	48009f16 	blt	r9,zero,821062c <___vfiprintf_internal_r+0x1338>
 82103b0:	00bfdfc4 	movi	r2,-129
 82103b4:	a0a8703a 	and	r20,r20,r2
 82103b8:	003dd006 	br	820fafc <___vfiprintf_internal_r+0x808>
 82103bc:	70004c26 	beq	r14,zero,82104f0 <___vfiprintf_internal_r+0x11fc>
 82103c0:	00800084 	movi	r2,2
 82103c4:	d8c01d04 	addi	r3,sp,116
 82103c8:	d8c00015 	stw	r3,0(sp)
 82103cc:	d8800115 	stw	r2,4(sp)
 82103d0:	01000044 	movi	r4,1
 82103d4:	d811883a 	mov	r8,sp
 82103d8:	003f7306 	br	82101a8 <___vfiprintf_internal_r+0xeb4>
 82103dc:	a080100c 	andi	r2,r20,64
 82103e0:	da802217 	ldw	r10,136(sp)
 82103e4:	103e0626 	beq	r2,zero,820fc00 <___vfiprintf_internal_r+0x90c>
 82103e8:	5480000f 	ldh	r18,0(r10)
 82103ec:	52800104 	addi	r10,r10,4
 82103f0:	da802215 	stw	r10,136(sp)
 82103f4:	9027d7fa 	srai	r19,r18,31
 82103f8:	9805883a 	mov	r2,r19
 82103fc:	003db806 	br	820fae0 <___vfiprintf_internal_r+0x7ec>
 8210400:	a080040c 	andi	r2,r20,16
 8210404:	1000091e 	bne	r2,zero,821042c <___vfiprintf_internal_r+0x1138>
 8210408:	a2c0100c 	andi	r11,r20,64
 821040c:	58000726 	beq	r11,zero,821042c <___vfiprintf_internal_r+0x1138>
 8210410:	da802217 	ldw	r10,136(sp)
 8210414:	50800017 	ldw	r2,0(r10)
 8210418:	52800104 	addi	r10,r10,4
 821041c:	da802215 	stw	r10,136(sp)
 8210420:	da802317 	ldw	r10,140(sp)
 8210424:	1280000d 	sth	r10,0(r2)
 8210428:	003be706 	br	820f3c8 <___vfiprintf_internal_r+0xd4>
 821042c:	da802217 	ldw	r10,136(sp)
 8210430:	50800017 	ldw	r2,0(r10)
 8210434:	52800104 	addi	r10,r10,4
 8210438:	da802215 	stw	r10,136(sp)
 821043c:	da802317 	ldw	r10,140(sp)
 8210440:	12800015 	stw	r10,0(r2)
 8210444:	003be006 	br	820f3c8 <___vfiprintf_internal_r+0xd4>
 8210448:	a080100c 	andi	r2,r20,64
 821044c:	da802217 	ldw	r10,136(sp)
 8210450:	10003026 	beq	r2,zero,8210514 <___vfiprintf_internal_r+0x1220>
 8210454:	5480000b 	ldhu	r18,0(r10)
 8210458:	52800104 	addi	r10,r10,4
 821045c:	0027883a 	mov	r19,zero
 8210460:	da802215 	stw	r10,136(sp)
 8210464:	003d8006 	br	820fa68 <___vfiprintf_internal_r+0x774>
 8210468:	80c00007 	ldb	r3,0(r16)
 821046c:	003c0006 	br	820f470 <___vfiprintf_internal_r+0x17c>
 8210470:	a080100c 	andi	r2,r20,64
 8210474:	d8001d85 	stb	zero,118(sp)
 8210478:	da802217 	ldw	r10,136(sp)
 821047c:	1000201e 	bne	r2,zero,8210500 <___vfiprintf_internal_r+0x120c>
 8210480:	50800104 	addi	r2,r10,4
 8210484:	54800017 	ldw	r18,0(r10)
 8210488:	0027883a 	mov	r19,zero
 821048c:	483def0e 	bge	r9,zero,820fc4c <___vfiprintf_internal_r+0x958>
 8210490:	94c6b03a 	or	r3,r18,r19
 8210494:	d8802215 	stw	r2,136(sp)
 8210498:	183d4e1e 	bne	r3,zero,820f9d4 <___vfiprintf_internal_r+0x6e0>
 821049c:	0039883a 	mov	fp,zero
 82104a0:	0005883a 	mov	r2,zero
 82104a4:	003e0606 	br	820fcc0 <___vfiprintf_internal_r+0x9cc>
 82104a8:	d9402117 	ldw	r5,132(sp)
 82104ac:	d9002017 	ldw	r4,128(sp)
 82104b0:	d9801a04 	addi	r6,sp,104
 82104b4:	da402c15 	stw	r9,176(sp)
 82104b8:	db802a15 	stw	r14,168(sp)
 82104bc:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 82104c0:	da402c17 	ldw	r9,176(sp)
 82104c4:	db802a17 	ldw	r14,168(sp)
 82104c8:	103ede1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 82104cc:	d9401b17 	ldw	r5,108(sp)
 82104d0:	d8801c17 	ldw	r2,112(sp)
 82104d4:	d811883a 	mov	r8,sp
 82104d8:	29000044 	addi	r4,r5,1
 82104dc:	003e7406 	br	820feb0 <___vfiprintf_internal_r+0xbbc>
 82104e0:	00bfffc4 	movi	r2,-1
 82104e4:	003c5806 	br	820f648 <___vfiprintf_internal_r+0x354>
 82104e8:	d811883a 	mov	r8,sp
 82104ec:	003ee806 	br	8210090 <___vfiprintf_internal_r+0xd9c>
 82104f0:	000b883a 	mov	r5,zero
 82104f4:	01000044 	movi	r4,1
 82104f8:	d811883a 	mov	r8,sp
 82104fc:	003e7c06 	br	820fef0 <___vfiprintf_internal_r+0xbfc>
 8210500:	50800104 	addi	r2,r10,4
 8210504:	5480000b 	ldhu	r18,0(r10)
 8210508:	0027883a 	mov	r19,zero
 821050c:	483dcf0e 	bge	r9,zero,820fc4c <___vfiprintf_internal_r+0x958>
 8210510:	003fdf06 	br	8210490 <___vfiprintf_internal_r+0x119c>
 8210514:	54800017 	ldw	r18,0(r10)
 8210518:	52800104 	addi	r10,r10,4
 821051c:	0027883a 	mov	r19,zero
 8210520:	da802215 	stw	r10,136(sp)
 8210524:	003d5006 	br	820fa68 <___vfiprintf_internal_r+0x774>
 8210528:	50800104 	addi	r2,r10,4
 821052c:	5480000b 	ldhu	r18,0(r10)
 8210530:	0027883a 	mov	r19,zero
 8210534:	483f7d0e 	bge	r9,zero,821032c <___vfiprintf_internal_r+0x1038>
 8210538:	003ddc06 	br	820fcac <___vfiprintf_internal_r+0x9b8>
 821053c:	d8c02215 	stw	r3,136(sp)
 8210540:	0039883a 	mov	fp,zero
 8210544:	003ddb06 	br	820fcb4 <___vfiprintf_internal_r+0x9c0>
 8210548:	02820974 	movhi	r10,2085
 821054c:	52b65204 	addi	r10,r10,-9912
 8210550:	da802415 	stw	r10,144(sp)
 8210554:	003e8306 	br	820ff64 <___vfiprintf_internal_r+0xc70>
 8210558:	d8801c17 	ldw	r2,112(sp)
 821055c:	dd002117 	ldw	r20,132(sp)
 8210560:	103eb926 	beq	r2,zero,8210048 <___vfiprintf_internal_r+0xd54>
 8210564:	d9002017 	ldw	r4,128(sp)
 8210568:	d9801a04 	addi	r6,sp,104
 821056c:	a00b883a 	mov	r5,r20
 8210570:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 8210574:	003eb406 	br	8210048 <___vfiprintf_internal_r+0xd54>
 8210578:	80c00043 	ldbu	r3,1(r16)
 821057c:	a5000814 	ori	r20,r20,32
 8210580:	84000044 	addi	r16,r16,1
 8210584:	18c03fcc 	andi	r3,r3,255
 8210588:	18c0201c 	xori	r3,r3,128
 821058c:	18ffe004 	addi	r3,r3,-128
 8210590:	003bb706 	br	820f470 <___vfiprintf_internal_r+0x17c>
 8210594:	a809883a 	mov	r4,r21
 8210598:	d8c02a15 	stw	r3,168(sp)
 821059c:	da002b15 	stw	r8,172(sp)
 82105a0:	8203cac0 	call	8203cac <strlen>
 82105a4:	d8c02a17 	ldw	r3,168(sp)
 82105a8:	1027883a 	mov	r19,r2
 82105ac:	df001d83 	ldbu	fp,118(sp)
 82105b0:	d8c02215 	stw	r3,136(sp)
 82105b4:	0013883a 	mov	r9,zero
 82105b8:	da002b17 	ldw	r8,172(sp)
 82105bc:	003c4d06 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 82105c0:	d9402117 	ldw	r5,132(sp)
 82105c4:	d9002017 	ldw	r4,128(sp)
 82105c8:	d9801a04 	addi	r6,sp,104
 82105cc:	da402c15 	stw	r9,176(sp)
 82105d0:	820f1e00 	call	820f1e0 <__sprint_r.part.0>
 82105d4:	da402c17 	ldw	r9,176(sp)
 82105d8:	103e9a1e 	bne	r2,zero,8210044 <___vfiprintf_internal_r+0xd50>
 82105dc:	d9401b17 	ldw	r5,108(sp)
 82105e0:	d8801c17 	ldw	r2,112(sp)
 82105e4:	d811883a 	mov	r8,sp
 82105e8:	29000044 	addi	r4,r5,1
 82105ec:	003e4206 	br	820fef8 <___vfiprintf_internal_r+0xc04>
 82105f0:	d9401b17 	ldw	r5,108(sp)
 82105f4:	01020974 	movhi	r4,2085
 82105f8:	21365604 	addi	r4,r4,-9896
 82105fc:	d9002415 	stw	r4,144(sp)
 8210600:	29400044 	addi	r5,r5,1
 8210604:	003c6d06 	br	820f7bc <___vfiprintf_internal_r+0x4c8>
 8210608:	0039883a 	mov	fp,zero
 821060c:	00800084 	movi	r2,2
 8210610:	10803fcc 	andi	r2,r2,255
 8210614:	01000044 	movi	r4,1
 8210618:	11001e26 	beq	r2,r4,8210694 <___vfiprintf_internal_r+0x13a0>
 821061c:	01000084 	movi	r4,2
 8210620:	11001e1e 	bne	r2,r4,821069c <___vfiprintf_internal_r+0x13a8>
 8210624:	1829883a 	mov	r20,r3
 8210628:	003eea06 	br	82101d4 <___vfiprintf_internal_r+0xee0>
 821062c:	a007883a 	mov	r3,r20
 8210630:	00800044 	movi	r2,1
 8210634:	003ff606 	br	8210610 <___vfiprintf_internal_r+0x131c>
 8210638:	00800184 	movi	r2,6
 821063c:	1240012e 	bgeu	r2,r9,8210644 <___vfiprintf_internal_r+0x1350>
 8210640:	1013883a 	mov	r9,r2
 8210644:	4827883a 	mov	r19,r9
 8210648:	4825883a 	mov	r18,r9
 821064c:	48001516 	blt	r9,zero,82106a4 <___vfiprintf_internal_r+0x13b0>
 8210650:	05420974 	movhi	r21,2085
 8210654:	d8c02215 	stw	r3,136(sp)
 8210658:	ad75e704 	addi	r21,r21,-10340
 821065c:	003d1406 	br	820fab0 <___vfiprintf_internal_r+0x7bc>
 8210660:	02820974 	movhi	r10,2085
 8210664:	52b65204 	addi	r10,r10,-9912
 8210668:	da802415 	stw	r10,144(sp)
 821066c:	200d883a 	mov	r6,r4
 8210670:	003c9106 	br	820f8b8 <___vfiprintf_internal_r+0x5c4>
 8210674:	5021883a 	mov	r16,r10
 8210678:	0013883a 	mov	r9,zero
 821067c:	003b7d06 	br	820f474 <___vfiprintf_internal_r+0x180>
 8210680:	4827883a 	mov	r19,r9
 8210684:	df001d83 	ldbu	fp,118(sp)
 8210688:	d8c02215 	stw	r3,136(sp)
 821068c:	0013883a 	mov	r9,zero
 8210690:	003c1806 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 8210694:	1829883a 	mov	r20,r3
 8210698:	003d1806 	br	820fafc <___vfiprintf_internal_r+0x808>
 821069c:	1829883a 	mov	r20,r3
 82106a0:	003ccd06 	br	820f9d8 <___vfiprintf_internal_r+0x6e4>
 82106a4:	0025883a 	mov	r18,zero
 82106a8:	003fe906 	br	8210650 <___vfiprintf_internal_r+0x135c>
 82106ac:	d8802217 	ldw	r2,136(sp)
 82106b0:	80c00043 	ldbu	r3,1(r16)
 82106b4:	5021883a 	mov	r16,r10
 82106b8:	12400017 	ldw	r9,0(r2)
 82106bc:	10800104 	addi	r2,r2,4
 82106c0:	d8802215 	stw	r2,136(sp)
 82106c4:	483faf0e 	bge	r9,zero,8210584 <___vfiprintf_internal_r+0x1290>
 82106c8:	18c03fcc 	andi	r3,r3,255
 82106cc:	18c0201c 	xori	r3,r3,128
 82106d0:	027fffc4 	movi	r9,-1
 82106d4:	18ffe004 	addi	r3,r3,-128
 82106d8:	003b6506 	br	820f470 <___vfiprintf_internal_r+0x17c>
 82106dc:	d9c01d85 	stb	r7,118(sp)
 82106e0:	003ca006 	br	820f964 <___vfiprintf_internal_r+0x670>
 82106e4:	d9c01d85 	stb	r7,118(sp)
 82106e8:	003cad06 	br	820f9a0 <___vfiprintf_internal_r+0x6ac>
 82106ec:	d9c01d85 	stb	r7,118(sp)
 82106f0:	003d7d06 	br	820fce8 <___vfiprintf_internal_r+0x9f4>
 82106f4:	d9c01d85 	stb	r7,118(sp)
 82106f8:	003d5f06 	br	820fc78 <___vfiprintf_internal_r+0x984>
 82106fc:	a080004c 	andi	r2,r20,1
 8210700:	0039883a 	mov	fp,zero
 8210704:	10000526 	beq	r2,zero,821071c <___vfiprintf_internal_r+0x1428>
 8210708:	00800c04 	movi	r2,48
 821070c:	d88019c5 	stb	r2,103(sp)
 8210710:	dcc02717 	ldw	r19,156(sp)
 8210714:	dd4019c4 	addi	r21,sp,103
 8210718:	003bf606 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 821071c:	0027883a 	mov	r19,zero
 8210720:	dd401a04 	addi	r21,sp,104
 8210724:	003bf306 	br	820f6f4 <___vfiprintf_internal_r+0x400>
 8210728:	d9c01d85 	stb	r7,118(sp)
 821072c:	003dc806 	br	820fe50 <___vfiprintf_internal_r+0xb5c>
 8210730:	d9c01d85 	stb	r7,118(sp)
 8210734:	003d3a06 	br	820fc20 <___vfiprintf_internal_r+0x92c>
 8210738:	d9c01d85 	stb	r7,118(sp)
 821073c:	003d2a06 	br	820fbe8 <___vfiprintf_internal_r+0x8f4>
 8210740:	d9c01d85 	stb	r7,118(sp)
 8210744:	003cde06 	br	820fac0 <___vfiprintf_internal_r+0x7cc>
 8210748:	d9c01d85 	stb	r7,118(sp)
 821074c:	003cbc06 	br	820fa40 <___vfiprintf_internal_r+0x74c>

08210750 <__vfiprintf_internal>:
 8210750:	00820974 	movhi	r2,2085
 8210754:	108eb804 	addi	r2,r2,15072
 8210758:	300f883a 	mov	r7,r6
 821075c:	280d883a 	mov	r6,r5
 8210760:	200b883a 	mov	r5,r4
 8210764:	11000017 	ldw	r4,0(r2)
 8210768:	820f2f41 	jmpi	820f2f4 <___vfiprintf_internal_r>

0821076c <__sbprintf>:
 821076c:	2880030b 	ldhu	r2,12(r5)
 8210770:	2ac01917 	ldw	r11,100(r5)
 8210774:	2a80038b 	ldhu	r10,14(r5)
 8210778:	2a400717 	ldw	r9,28(r5)
 821077c:	2a000917 	ldw	r8,36(r5)
 8210780:	defee204 	addi	sp,sp,-1144
 8210784:	00c10004 	movi	r3,1024
 8210788:	dc011a15 	stw	r16,1128(sp)
 821078c:	10bfff4c 	andi	r2,r2,65533
 8210790:	2821883a 	mov	r16,r5
 8210794:	d8cb883a 	add	r5,sp,r3
 8210798:	dc811c15 	stw	r18,1136(sp)
 821079c:	dc411b15 	stw	r17,1132(sp)
 82107a0:	dfc11d15 	stw	ra,1140(sp)
 82107a4:	2025883a 	mov	r18,r4
 82107a8:	d881030d 	sth	r2,1036(sp)
 82107ac:	dac11915 	stw	r11,1124(sp)
 82107b0:	da81038d 	sth	r10,1038(sp)
 82107b4:	da410715 	stw	r9,1052(sp)
 82107b8:	da010915 	stw	r8,1060(sp)
 82107bc:	dec10015 	stw	sp,1024(sp)
 82107c0:	dec10415 	stw	sp,1040(sp)
 82107c4:	d8c10215 	stw	r3,1032(sp)
 82107c8:	d8c10515 	stw	r3,1044(sp)
 82107cc:	d8010615 	stw	zero,1048(sp)
 82107d0:	820f2f40 	call	820f2f4 <___vfiprintf_internal_r>
 82107d4:	1023883a 	mov	r17,r2
 82107d8:	10000416 	blt	r2,zero,82107ec <__sbprintf+0x80>
 82107dc:	d9410004 	addi	r5,sp,1024
 82107e0:	9009883a 	mov	r4,r18
 82107e4:	820a7a80 	call	820a7a8 <_fflush_r>
 82107e8:	10000d1e 	bne	r2,zero,8210820 <__sbprintf+0xb4>
 82107ec:	d881030b 	ldhu	r2,1036(sp)
 82107f0:	1080100c 	andi	r2,r2,64
 82107f4:	10000326 	beq	r2,zero,8210804 <__sbprintf+0x98>
 82107f8:	8080030b 	ldhu	r2,12(r16)
 82107fc:	10801014 	ori	r2,r2,64
 8210800:	8080030d 	sth	r2,12(r16)
 8210804:	8805883a 	mov	r2,r17
 8210808:	dfc11d17 	ldw	ra,1140(sp)
 821080c:	dc811c17 	ldw	r18,1136(sp)
 8210810:	dc411b17 	ldw	r17,1132(sp)
 8210814:	dc011a17 	ldw	r16,1128(sp)
 8210818:	dec11e04 	addi	sp,sp,1144
 821081c:	f800283a 	ret
 8210820:	047fffc4 	movi	r17,-1
 8210824:	003ff106 	br	82107ec <__sbprintf+0x80>

08210828 <_write_r>:
 8210828:	defffd04 	addi	sp,sp,-12
 821082c:	2805883a 	mov	r2,r5
 8210830:	dc000015 	stw	r16,0(sp)
 8210834:	04020974 	movhi	r16,2085
 8210838:	dc400115 	stw	r17,4(sp)
 821083c:	300b883a 	mov	r5,r6
 8210840:	840f1904 	addi	r16,r16,15460
 8210844:	2023883a 	mov	r17,r4
 8210848:	380d883a 	mov	r6,r7
 821084c:	1009883a 	mov	r4,r2
 8210850:	dfc00215 	stw	ra,8(sp)
 8210854:	80000015 	stw	zero,0(r16)
 8210858:	82257840 	call	8225784 <write>
 821085c:	00ffffc4 	movi	r3,-1
 8210860:	10c00526 	beq	r2,r3,8210878 <_write_r+0x50>
 8210864:	dfc00217 	ldw	ra,8(sp)
 8210868:	dc400117 	ldw	r17,4(sp)
 821086c:	dc000017 	ldw	r16,0(sp)
 8210870:	dec00304 	addi	sp,sp,12
 8210874:	f800283a 	ret
 8210878:	80c00017 	ldw	r3,0(r16)
 821087c:	183ff926 	beq	r3,zero,8210864 <_write_r+0x3c>
 8210880:	88c00015 	stw	r3,0(r17)
 8210884:	003ff706 	br	8210864 <_write_r+0x3c>

08210888 <_close_r>:
 8210888:	defffd04 	addi	sp,sp,-12
 821088c:	dc000015 	stw	r16,0(sp)
 8210890:	04020974 	movhi	r16,2085
 8210894:	dc400115 	stw	r17,4(sp)
 8210898:	840f1904 	addi	r16,r16,15460
 821089c:	2023883a 	mov	r17,r4
 82108a0:	2809883a 	mov	r4,r5
 82108a4:	dfc00215 	stw	ra,8(sp)
 82108a8:	80000015 	stw	zero,0(r16)
 82108ac:	82255840 	call	8225584 <close>
 82108b0:	00ffffc4 	movi	r3,-1
 82108b4:	10c00526 	beq	r2,r3,82108cc <_close_r+0x44>
 82108b8:	dfc00217 	ldw	ra,8(sp)
 82108bc:	dc400117 	ldw	r17,4(sp)
 82108c0:	dc000017 	ldw	r16,0(sp)
 82108c4:	dec00304 	addi	sp,sp,12
 82108c8:	f800283a 	ret
 82108cc:	80c00017 	ldw	r3,0(r16)
 82108d0:	183ff926 	beq	r3,zero,82108b8 <_close_r+0x30>
 82108d4:	88c00015 	stw	r3,0(r17)
 82108d8:	003ff706 	br	82108b8 <_close_r+0x30>

082108dc <_calloc_r>:
 82108dc:	298b383a 	mul	r5,r5,r6
 82108e0:	defffe04 	addi	sp,sp,-8
 82108e4:	dfc00115 	stw	ra,4(sp)
 82108e8:	dc000015 	stw	r16,0(sp)
 82108ec:	820ba380 	call	820ba38 <_malloc_r>
 82108f0:	10002926 	beq	r2,zero,8210998 <_calloc_r+0xbc>
 82108f4:	11bfff17 	ldw	r6,-4(r2)
 82108f8:	1021883a 	mov	r16,r2
 82108fc:	00bfff04 	movi	r2,-4
 8210900:	308c703a 	and	r6,r6,r2
 8210904:	00c00904 	movi	r3,36
 8210908:	308d883a 	add	r6,r6,r2
 821090c:	19801636 	bltu	r3,r6,8210968 <_calloc_r+0x8c>
 8210910:	008004c4 	movi	r2,19
 8210914:	11800b2e 	bgeu	r2,r6,8210944 <_calloc_r+0x68>
 8210918:	80000015 	stw	zero,0(r16)
 821091c:	80000115 	stw	zero,4(r16)
 8210920:	008006c4 	movi	r2,27
 8210924:	11801a2e 	bgeu	r2,r6,8210990 <_calloc_r+0xb4>
 8210928:	80000215 	stw	zero,8(r16)
 821092c:	80000315 	stw	zero,12(r16)
 8210930:	30c0151e 	bne	r6,r3,8210988 <_calloc_r+0xac>
 8210934:	80000415 	stw	zero,16(r16)
 8210938:	80800604 	addi	r2,r16,24
 821093c:	80000515 	stw	zero,20(r16)
 8210940:	00000106 	br	8210948 <_calloc_r+0x6c>
 8210944:	8005883a 	mov	r2,r16
 8210948:	10000015 	stw	zero,0(r2)
 821094c:	10000115 	stw	zero,4(r2)
 8210950:	10000215 	stw	zero,8(r2)
 8210954:	8005883a 	mov	r2,r16
 8210958:	dfc00117 	ldw	ra,4(sp)
 821095c:	dc000017 	ldw	r16,0(sp)
 8210960:	dec00204 	addi	sp,sp,8
 8210964:	f800283a 	ret
 8210968:	000b883a 	mov	r5,zero
 821096c:	8009883a 	mov	r4,r16
 8210970:	8202f000 	call	8202f00 <memset>
 8210974:	8005883a 	mov	r2,r16
 8210978:	dfc00117 	ldw	ra,4(sp)
 821097c:	dc000017 	ldw	r16,0(sp)
 8210980:	dec00204 	addi	sp,sp,8
 8210984:	f800283a 	ret
 8210988:	80800404 	addi	r2,r16,16
 821098c:	003fee06 	br	8210948 <_calloc_r+0x6c>
 8210990:	80800204 	addi	r2,r16,8
 8210994:	003fec06 	br	8210948 <_calloc_r+0x6c>
 8210998:	0005883a 	mov	r2,zero
 821099c:	003fee06 	br	8210958 <_calloc_r+0x7c>

082109a0 <_fclose_r>:
 82109a0:	28003926 	beq	r5,zero,8210a88 <_fclose_r+0xe8>
 82109a4:	defffc04 	addi	sp,sp,-16
 82109a8:	dc400115 	stw	r17,4(sp)
 82109ac:	dc000015 	stw	r16,0(sp)
 82109b0:	dfc00315 	stw	ra,12(sp)
 82109b4:	dc800215 	stw	r18,8(sp)
 82109b8:	2023883a 	mov	r17,r4
 82109bc:	2821883a 	mov	r16,r5
 82109c0:	20000226 	beq	r4,zero,82109cc <_fclose_r+0x2c>
 82109c4:	20800e17 	ldw	r2,56(r4)
 82109c8:	10002726 	beq	r2,zero,8210a68 <_fclose_r+0xc8>
 82109cc:	8080030f 	ldh	r2,12(r16)
 82109d0:	1000071e 	bne	r2,zero,82109f0 <_fclose_r+0x50>
 82109d4:	0005883a 	mov	r2,zero
 82109d8:	dfc00317 	ldw	ra,12(sp)
 82109dc:	dc800217 	ldw	r18,8(sp)
 82109e0:	dc400117 	ldw	r17,4(sp)
 82109e4:	dc000017 	ldw	r16,0(sp)
 82109e8:	dec00404 	addi	sp,sp,16
 82109ec:	f800283a 	ret
 82109f0:	800b883a 	mov	r5,r16
 82109f4:	8809883a 	mov	r4,r17
 82109f8:	820a58c0 	call	820a58c <__sflush_r>
 82109fc:	1025883a 	mov	r18,r2
 8210a00:	80800b17 	ldw	r2,44(r16)
 8210a04:	10000426 	beq	r2,zero,8210a18 <_fclose_r+0x78>
 8210a08:	81400717 	ldw	r5,28(r16)
 8210a0c:	8809883a 	mov	r4,r17
 8210a10:	103ee83a 	callr	r2
 8210a14:	10001616 	blt	r2,zero,8210a70 <_fclose_r+0xd0>
 8210a18:	8080030b 	ldhu	r2,12(r16)
 8210a1c:	1080200c 	andi	r2,r2,128
 8210a20:	1000151e 	bne	r2,zero,8210a78 <_fclose_r+0xd8>
 8210a24:	81400c17 	ldw	r5,48(r16)
 8210a28:	28000526 	beq	r5,zero,8210a40 <_fclose_r+0xa0>
 8210a2c:	80801004 	addi	r2,r16,64
 8210a30:	28800226 	beq	r5,r2,8210a3c <_fclose_r+0x9c>
 8210a34:	8809883a 	mov	r4,r17
 8210a38:	820ae4c0 	call	820ae4c <_free_r>
 8210a3c:	80000c15 	stw	zero,48(r16)
 8210a40:	81401117 	ldw	r5,68(r16)
 8210a44:	28000326 	beq	r5,zero,8210a54 <_fclose_r+0xb4>
 8210a48:	8809883a 	mov	r4,r17
 8210a4c:	820ae4c0 	call	820ae4c <_free_r>
 8210a50:	80001115 	stw	zero,68(r16)
 8210a54:	820ab940 	call	820ab94 <__sfp_lock_acquire>
 8210a58:	8000030d 	sth	zero,12(r16)
 8210a5c:	820ab980 	call	820ab98 <__sfp_lock_release>
 8210a60:	9005883a 	mov	r2,r18
 8210a64:	003fdc06 	br	82109d8 <_fclose_r+0x38>
 8210a68:	820ab840 	call	820ab84 <__sinit>
 8210a6c:	003fd706 	br	82109cc <_fclose_r+0x2c>
 8210a70:	04bfffc4 	movi	r18,-1
 8210a74:	003fe806 	br	8210a18 <_fclose_r+0x78>
 8210a78:	81400417 	ldw	r5,16(r16)
 8210a7c:	8809883a 	mov	r4,r17
 8210a80:	820ae4c0 	call	820ae4c <_free_r>
 8210a84:	003fe706 	br	8210a24 <_fclose_r+0x84>
 8210a88:	0005883a 	mov	r2,zero
 8210a8c:	f800283a 	ret

08210a90 <fclose>:
 8210a90:	00820974 	movhi	r2,2085
 8210a94:	108eb804 	addi	r2,r2,15072
 8210a98:	200b883a 	mov	r5,r4
 8210a9c:	11000017 	ldw	r4,0(r2)
 8210aa0:	82109a01 	jmpi	82109a0 <_fclose_r>

08210aa4 <__fputwc>:
 8210aa4:	defff804 	addi	sp,sp,-32
 8210aa8:	dcc00415 	stw	r19,16(sp)
 8210aac:	dc800315 	stw	r18,12(sp)
 8210ab0:	dc000115 	stw	r16,4(sp)
 8210ab4:	dfc00715 	stw	ra,28(sp)
 8210ab8:	dd400615 	stw	r21,24(sp)
 8210abc:	dd000515 	stw	r20,20(sp)
 8210ac0:	dc400215 	stw	r17,8(sp)
 8210ac4:	2027883a 	mov	r19,r4
 8210ac8:	2825883a 	mov	r18,r5
 8210acc:	3021883a 	mov	r16,r6
 8210ad0:	820b8280 	call	820b828 <__locale_mb_cur_max>
 8210ad4:	00c00044 	movi	r3,1
 8210ad8:	10c03e26 	beq	r2,r3,8210bd4 <__fputwc+0x130>
 8210adc:	81c01704 	addi	r7,r16,92
 8210ae0:	900d883a 	mov	r6,r18
 8210ae4:	d80b883a 	mov	r5,sp
 8210ae8:	9809883a 	mov	r4,r19
 8210aec:	8210e1c0 	call	8210e1c <_wcrtomb_r>
 8210af0:	1029883a 	mov	r20,r2
 8210af4:	00bfffc4 	movi	r2,-1
 8210af8:	a0802026 	beq	r20,r2,8210b7c <__fputwc+0xd8>
 8210afc:	d9400003 	ldbu	r5,0(sp)
 8210b00:	a0001c26 	beq	r20,zero,8210b74 <__fputwc+0xd0>
 8210b04:	0023883a 	mov	r17,zero
 8210b08:	05400284 	movi	r21,10
 8210b0c:	00000906 	br	8210b34 <__fputwc+0x90>
 8210b10:	80800017 	ldw	r2,0(r16)
 8210b14:	11400005 	stb	r5,0(r2)
 8210b18:	80c00017 	ldw	r3,0(r16)
 8210b1c:	18c00044 	addi	r3,r3,1
 8210b20:	80c00015 	stw	r3,0(r16)
 8210b24:	8c400044 	addi	r17,r17,1
 8210b28:	dc45883a 	add	r2,sp,r17
 8210b2c:	8d00112e 	bgeu	r17,r20,8210b74 <__fputwc+0xd0>
 8210b30:	11400003 	ldbu	r5,0(r2)
 8210b34:	80c00217 	ldw	r3,8(r16)
 8210b38:	18ffffc4 	addi	r3,r3,-1
 8210b3c:	80c00215 	stw	r3,8(r16)
 8210b40:	183ff30e 	bge	r3,zero,8210b10 <__fputwc+0x6c>
 8210b44:	80800617 	ldw	r2,24(r16)
 8210b48:	18801916 	blt	r3,r2,8210bb0 <__fputwc+0x10c>
 8210b4c:	80800017 	ldw	r2,0(r16)
 8210b50:	11400005 	stb	r5,0(r2)
 8210b54:	80800017 	ldw	r2,0(r16)
 8210b58:	10c00003 	ldbu	r3,0(r2)
 8210b5c:	10800044 	addi	r2,r2,1
 8210b60:	1d402326 	beq	r3,r21,8210bf0 <__fputwc+0x14c>
 8210b64:	80800015 	stw	r2,0(r16)
 8210b68:	8c400044 	addi	r17,r17,1
 8210b6c:	dc45883a 	add	r2,sp,r17
 8210b70:	8d3fef36 	bltu	r17,r20,8210b30 <__fputwc+0x8c>
 8210b74:	9005883a 	mov	r2,r18
 8210b78:	00000406 	br	8210b8c <__fputwc+0xe8>
 8210b7c:	80c0030b 	ldhu	r3,12(r16)
 8210b80:	a005883a 	mov	r2,r20
 8210b84:	18c01014 	ori	r3,r3,64
 8210b88:	80c0030d 	sth	r3,12(r16)
 8210b8c:	dfc00717 	ldw	ra,28(sp)
 8210b90:	dd400617 	ldw	r21,24(sp)
 8210b94:	dd000517 	ldw	r20,20(sp)
 8210b98:	dcc00417 	ldw	r19,16(sp)
 8210b9c:	dc800317 	ldw	r18,12(sp)
 8210ba0:	dc400217 	ldw	r17,8(sp)
 8210ba4:	dc000117 	ldw	r16,4(sp)
 8210ba8:	dec00804 	addi	sp,sp,32
 8210bac:	f800283a 	ret
 8210bb0:	800d883a 	mov	r6,r16
 8210bb4:	29403fcc 	andi	r5,r5,255
 8210bb8:	9809883a 	mov	r4,r19
 8210bbc:	8208a580 	call	8208a58 <__swbuf_r>
 8210bc0:	10bfffe0 	cmpeqi	r2,r2,-1
 8210bc4:	10803fcc 	andi	r2,r2,255
 8210bc8:	103fd626 	beq	r2,zero,8210b24 <__fputwc+0x80>
 8210bcc:	00bfffc4 	movi	r2,-1
 8210bd0:	003fee06 	br	8210b8c <__fputwc+0xe8>
 8210bd4:	90ffffc4 	addi	r3,r18,-1
 8210bd8:	01003f84 	movi	r4,254
 8210bdc:	20ffbf36 	bltu	r4,r3,8210adc <__fputwc+0x38>
 8210be0:	900b883a 	mov	r5,r18
 8210be4:	dc800005 	stb	r18,0(sp)
 8210be8:	1029883a 	mov	r20,r2
 8210bec:	003fc506 	br	8210b04 <__fputwc+0x60>
 8210bf0:	800d883a 	mov	r6,r16
 8210bf4:	a80b883a 	mov	r5,r21
 8210bf8:	9809883a 	mov	r4,r19
 8210bfc:	8208a580 	call	8208a58 <__swbuf_r>
 8210c00:	10bfffe0 	cmpeqi	r2,r2,-1
 8210c04:	003fef06 	br	8210bc4 <__fputwc+0x120>

08210c08 <_fputwc_r>:
 8210c08:	3080030b 	ldhu	r2,12(r6)
 8210c0c:	10c8000c 	andi	r3,r2,8192
 8210c10:	1800051e 	bne	r3,zero,8210c28 <_fputwc_r+0x20>
 8210c14:	30c01917 	ldw	r3,100(r6)
 8210c18:	10880014 	ori	r2,r2,8192
 8210c1c:	3080030d 	sth	r2,12(r6)
 8210c20:	18880014 	ori	r2,r3,8192
 8210c24:	30801915 	stw	r2,100(r6)
 8210c28:	8210aa41 	jmpi	8210aa4 <__fputwc>

08210c2c <fputwc>:
 8210c2c:	00820974 	movhi	r2,2085
 8210c30:	defffc04 	addi	sp,sp,-16
 8210c34:	108eb804 	addi	r2,r2,15072
 8210c38:	dc000115 	stw	r16,4(sp)
 8210c3c:	14000017 	ldw	r16,0(r2)
 8210c40:	dc400215 	stw	r17,8(sp)
 8210c44:	dfc00315 	stw	ra,12(sp)
 8210c48:	2023883a 	mov	r17,r4
 8210c4c:	80000226 	beq	r16,zero,8210c58 <fputwc+0x2c>
 8210c50:	80800e17 	ldw	r2,56(r16)
 8210c54:	10001026 	beq	r2,zero,8210c98 <fputwc+0x6c>
 8210c58:	2880030b 	ldhu	r2,12(r5)
 8210c5c:	10c8000c 	andi	r3,r2,8192
 8210c60:	1800051e 	bne	r3,zero,8210c78 <fputwc+0x4c>
 8210c64:	28c01917 	ldw	r3,100(r5)
 8210c68:	10880014 	ori	r2,r2,8192
 8210c6c:	2880030d 	sth	r2,12(r5)
 8210c70:	18880014 	ori	r2,r3,8192
 8210c74:	28801915 	stw	r2,100(r5)
 8210c78:	280d883a 	mov	r6,r5
 8210c7c:	8009883a 	mov	r4,r16
 8210c80:	880b883a 	mov	r5,r17
 8210c84:	dfc00317 	ldw	ra,12(sp)
 8210c88:	dc400217 	ldw	r17,8(sp)
 8210c8c:	dc000117 	ldw	r16,4(sp)
 8210c90:	dec00404 	addi	sp,sp,16
 8210c94:	8210aa41 	jmpi	8210aa4 <__fputwc>
 8210c98:	8009883a 	mov	r4,r16
 8210c9c:	d9400015 	stw	r5,0(sp)
 8210ca0:	820ab840 	call	820ab84 <__sinit>
 8210ca4:	d9400017 	ldw	r5,0(sp)
 8210ca8:	003feb06 	br	8210c58 <fputwc+0x2c>

08210cac <_fstat_r>:
 8210cac:	defffd04 	addi	sp,sp,-12
 8210cb0:	2805883a 	mov	r2,r5
 8210cb4:	dc000015 	stw	r16,0(sp)
 8210cb8:	04020974 	movhi	r16,2085
 8210cbc:	dc400115 	stw	r17,4(sp)
 8210cc0:	840f1904 	addi	r16,r16,15460
 8210cc4:	2023883a 	mov	r17,r4
 8210cc8:	300b883a 	mov	r5,r6
 8210ccc:	1009883a 	mov	r4,r2
 8210cd0:	dfc00215 	stw	ra,8(sp)
 8210cd4:	80000015 	stw	zero,0(r16)
 8210cd8:	82142140 	call	8214214 <fstat>
 8210cdc:	00ffffc4 	movi	r3,-1
 8210ce0:	10c00526 	beq	r2,r3,8210cf8 <_fstat_r+0x4c>
 8210ce4:	dfc00217 	ldw	ra,8(sp)
 8210ce8:	dc400117 	ldw	r17,4(sp)
 8210cec:	dc000017 	ldw	r16,0(sp)
 8210cf0:	dec00304 	addi	sp,sp,12
 8210cf4:	f800283a 	ret
 8210cf8:	80c00017 	ldw	r3,0(r16)
 8210cfc:	183ff926 	beq	r3,zero,8210ce4 <_fstat_r+0x38>
 8210d00:	88c00015 	stw	r3,0(r17)
 8210d04:	003ff706 	br	8210ce4 <_fstat_r+0x38>

08210d08 <_isatty_r>:
 8210d08:	defffd04 	addi	sp,sp,-12
 8210d0c:	dc000015 	stw	r16,0(sp)
 8210d10:	04020974 	movhi	r16,2085
 8210d14:	dc400115 	stw	r17,4(sp)
 8210d18:	840f1904 	addi	r16,r16,15460
 8210d1c:	2023883a 	mov	r17,r4
 8210d20:	2809883a 	mov	r4,r5
 8210d24:	dfc00215 	stw	ra,8(sp)
 8210d28:	80000015 	stw	zero,0(r16)
 8210d2c:	82143000 	call	8214300 <isatty>
 8210d30:	00ffffc4 	movi	r3,-1
 8210d34:	10c00526 	beq	r2,r3,8210d4c <_isatty_r+0x44>
 8210d38:	dfc00217 	ldw	ra,8(sp)
 8210d3c:	dc400117 	ldw	r17,4(sp)
 8210d40:	dc000017 	ldw	r16,0(sp)
 8210d44:	dec00304 	addi	sp,sp,12
 8210d48:	f800283a 	ret
 8210d4c:	80c00017 	ldw	r3,0(r16)
 8210d50:	183ff926 	beq	r3,zero,8210d38 <_isatty_r+0x30>
 8210d54:	88c00015 	stw	r3,0(r17)
 8210d58:	003ff706 	br	8210d38 <_isatty_r+0x30>

08210d5c <_lseek_r>:
 8210d5c:	defffd04 	addi	sp,sp,-12
 8210d60:	2805883a 	mov	r2,r5
 8210d64:	dc000015 	stw	r16,0(sp)
 8210d68:	04020974 	movhi	r16,2085
 8210d6c:	dc400115 	stw	r17,4(sp)
 8210d70:	300b883a 	mov	r5,r6
 8210d74:	840f1904 	addi	r16,r16,15460
 8210d78:	2023883a 	mov	r17,r4
 8210d7c:	380d883a 	mov	r6,r7
 8210d80:	1009883a 	mov	r4,r2
 8210d84:	dfc00215 	stw	ra,8(sp)
 8210d88:	80000015 	stw	zero,0(r16)
 8210d8c:	82143e00 	call	82143e0 <lseek>
 8210d90:	00ffffc4 	movi	r3,-1
 8210d94:	10c00526 	beq	r2,r3,8210dac <_lseek_r+0x50>
 8210d98:	dfc00217 	ldw	ra,8(sp)
 8210d9c:	dc400117 	ldw	r17,4(sp)
 8210da0:	dc000017 	ldw	r16,0(sp)
 8210da4:	dec00304 	addi	sp,sp,12
 8210da8:	f800283a 	ret
 8210dac:	80c00017 	ldw	r3,0(r16)
 8210db0:	183ff926 	beq	r3,zero,8210d98 <_lseek_r+0x3c>
 8210db4:	88c00015 	stw	r3,0(r17)
 8210db8:	003ff706 	br	8210d98 <_lseek_r+0x3c>

08210dbc <_read_r>:
 8210dbc:	defffd04 	addi	sp,sp,-12
 8210dc0:	2805883a 	mov	r2,r5
 8210dc4:	dc000015 	stw	r16,0(sp)
 8210dc8:	04020974 	movhi	r16,2085
 8210dcc:	dc400115 	stw	r17,4(sp)
 8210dd0:	300b883a 	mov	r5,r6
 8210dd4:	840f1904 	addi	r16,r16,15460
 8210dd8:	2023883a 	mov	r17,r4
 8210ddc:	380d883a 	mov	r6,r7
 8210de0:	1009883a 	mov	r4,r2
 8210de4:	dfc00215 	stw	ra,8(sp)
 8210de8:	80000015 	stw	zero,0(r16)
 8210dec:	82257140 	call	8225714 <read>
 8210df0:	00ffffc4 	movi	r3,-1
 8210df4:	10c00526 	beq	r2,r3,8210e0c <_read_r+0x50>
 8210df8:	dfc00217 	ldw	ra,8(sp)
 8210dfc:	dc400117 	ldw	r17,4(sp)
 8210e00:	dc000017 	ldw	r16,0(sp)
 8210e04:	dec00304 	addi	sp,sp,12
 8210e08:	f800283a 	ret
 8210e0c:	80c00017 	ldw	r3,0(r16)
 8210e10:	183ff926 	beq	r3,zero,8210df8 <_read_r+0x3c>
 8210e14:	88c00015 	stw	r3,0(r17)
 8210e18:	003ff706 	br	8210df8 <_read_r+0x3c>

08210e1c <_wcrtomb_r>:
 8210e1c:	defff604 	addi	sp,sp,-40
 8210e20:	00820974 	movhi	r2,2085
 8210e24:	dc800815 	stw	r18,32(sp)
 8210e28:	dc400715 	stw	r17,28(sp)
 8210e2c:	dc000615 	stw	r16,24(sp)
 8210e30:	108ebc04 	addi	r2,r2,15088
 8210e34:	dfc00915 	stw	ra,36(sp)
 8210e38:	2021883a 	mov	r16,r4
 8210e3c:	3823883a 	mov	r17,r7
 8210e40:	14800017 	ldw	r18,0(r2)
 8210e44:	28001426 	beq	r5,zero,8210e98 <_wcrtomb_r+0x7c>
 8210e48:	d9400415 	stw	r5,16(sp)
 8210e4c:	d9800515 	stw	r6,20(sp)
 8210e50:	820b81c0 	call	820b81c <__locale_charset>
 8210e54:	d9800517 	ldw	r6,20(sp)
 8210e58:	d9400417 	ldw	r5,16(sp)
 8210e5c:	100f883a 	mov	r7,r2
 8210e60:	dc400015 	stw	r17,0(sp)
 8210e64:	8009883a 	mov	r4,r16
 8210e68:	903ee83a 	callr	r18
 8210e6c:	00ffffc4 	movi	r3,-1
 8210e70:	10c0031e 	bne	r2,r3,8210e80 <_wcrtomb_r+0x64>
 8210e74:	88000015 	stw	zero,0(r17)
 8210e78:	00c02284 	movi	r3,138
 8210e7c:	80c00015 	stw	r3,0(r16)
 8210e80:	dfc00917 	ldw	ra,36(sp)
 8210e84:	dc800817 	ldw	r18,32(sp)
 8210e88:	dc400717 	ldw	r17,28(sp)
 8210e8c:	dc000617 	ldw	r16,24(sp)
 8210e90:	dec00a04 	addi	sp,sp,40
 8210e94:	f800283a 	ret
 8210e98:	820b81c0 	call	820b81c <__locale_charset>
 8210e9c:	100f883a 	mov	r7,r2
 8210ea0:	dc400015 	stw	r17,0(sp)
 8210ea4:	000d883a 	mov	r6,zero
 8210ea8:	d9400104 	addi	r5,sp,4
 8210eac:	8009883a 	mov	r4,r16
 8210eb0:	903ee83a 	callr	r18
 8210eb4:	003fed06 	br	8210e6c <_wcrtomb_r+0x50>

08210eb8 <wcrtomb>:
 8210eb8:	defff604 	addi	sp,sp,-40
 8210ebc:	00820974 	movhi	r2,2085
 8210ec0:	dc800615 	stw	r18,24(sp)
 8210ec4:	dc400515 	stw	r17,20(sp)
 8210ec8:	108eb804 	addi	r2,r2,15072
 8210ecc:	dfc00915 	stw	ra,36(sp)
 8210ed0:	dd000815 	stw	r20,32(sp)
 8210ed4:	dcc00715 	stw	r19,28(sp)
 8210ed8:	dc000415 	stw	r16,16(sp)
 8210edc:	3025883a 	mov	r18,r6
 8210ee0:	14400017 	ldw	r17,0(r2)
 8210ee4:	20001926 	beq	r4,zero,8210f4c <wcrtomb+0x94>
 8210ee8:	00820974 	movhi	r2,2085
 8210eec:	108ebc04 	addi	r2,r2,15088
 8210ef0:	15000017 	ldw	r20,0(r2)
 8210ef4:	2021883a 	mov	r16,r4
 8210ef8:	2827883a 	mov	r19,r5
 8210efc:	820b81c0 	call	820b81c <__locale_charset>
 8210f00:	100f883a 	mov	r7,r2
 8210f04:	dc800015 	stw	r18,0(sp)
 8210f08:	980d883a 	mov	r6,r19
 8210f0c:	800b883a 	mov	r5,r16
 8210f10:	8809883a 	mov	r4,r17
 8210f14:	a03ee83a 	callr	r20
 8210f18:	00ffffc4 	movi	r3,-1
 8210f1c:	10c0031e 	bne	r2,r3,8210f2c <wcrtomb+0x74>
 8210f20:	90000015 	stw	zero,0(r18)
 8210f24:	00c02284 	movi	r3,138
 8210f28:	88c00015 	stw	r3,0(r17)
 8210f2c:	dfc00917 	ldw	ra,36(sp)
 8210f30:	dd000817 	ldw	r20,32(sp)
 8210f34:	dcc00717 	ldw	r19,28(sp)
 8210f38:	dc800617 	ldw	r18,24(sp)
 8210f3c:	dc400517 	ldw	r17,20(sp)
 8210f40:	dc000417 	ldw	r16,16(sp)
 8210f44:	dec00a04 	addi	sp,sp,40
 8210f48:	f800283a 	ret
 8210f4c:	00820974 	movhi	r2,2085
 8210f50:	108ebc04 	addi	r2,r2,15088
 8210f54:	14000017 	ldw	r16,0(r2)
 8210f58:	820b81c0 	call	820b81c <__locale_charset>
 8210f5c:	100f883a 	mov	r7,r2
 8210f60:	dc800015 	stw	r18,0(sp)
 8210f64:	000d883a 	mov	r6,zero
 8210f68:	d9400104 	addi	r5,sp,4
 8210f6c:	8809883a 	mov	r4,r17
 8210f70:	803ee83a 	callr	r16
 8210f74:	003fe806 	br	8210f18 <wcrtomb+0x60>

08210f78 <__ascii_wctomb>:
 8210f78:	28000526 	beq	r5,zero,8210f90 <__ascii_wctomb+0x18>
 8210f7c:	00803fc4 	movi	r2,255
 8210f80:	11800536 	bltu	r2,r6,8210f98 <__ascii_wctomb+0x20>
 8210f84:	29800005 	stb	r6,0(r5)
 8210f88:	00800044 	movi	r2,1
 8210f8c:	f800283a 	ret
 8210f90:	0005883a 	mov	r2,zero
 8210f94:	f800283a 	ret
 8210f98:	00802284 	movi	r2,138
 8210f9c:	20800015 	stw	r2,0(r4)
 8210fa0:	00bfffc4 	movi	r2,-1
 8210fa4:	f800283a 	ret

08210fa8 <_wctomb_r>:
 8210fa8:	00820974 	movhi	r2,2085
 8210fac:	defff904 	addi	sp,sp,-28
 8210fb0:	108ebc04 	addi	r2,r2,15088
 8210fb4:	dfc00615 	stw	ra,24(sp)
 8210fb8:	dc400515 	stw	r17,20(sp)
 8210fbc:	dc000415 	stw	r16,16(sp)
 8210fc0:	3823883a 	mov	r17,r7
 8210fc4:	14000017 	ldw	r16,0(r2)
 8210fc8:	d9000115 	stw	r4,4(sp)
 8210fcc:	d9400215 	stw	r5,8(sp)
 8210fd0:	d9800315 	stw	r6,12(sp)
 8210fd4:	820b81c0 	call	820b81c <__locale_charset>
 8210fd8:	d9800317 	ldw	r6,12(sp)
 8210fdc:	d9400217 	ldw	r5,8(sp)
 8210fe0:	d9000117 	ldw	r4,4(sp)
 8210fe4:	100f883a 	mov	r7,r2
 8210fe8:	dc400015 	stw	r17,0(sp)
 8210fec:	803ee83a 	callr	r16
 8210ff0:	dfc00617 	ldw	ra,24(sp)
 8210ff4:	dc400517 	ldw	r17,20(sp)
 8210ff8:	dc000417 	ldw	r16,16(sp)
 8210ffc:	dec00704 	addi	sp,sp,28
 8211000:	f800283a 	ret

08211004 <__udivdi3>:
 8211004:	defff504 	addi	sp,sp,-44
 8211008:	dcc00415 	stw	r19,16(sp)
 821100c:	dc000115 	stw	r16,4(sp)
 8211010:	dfc00a15 	stw	ra,40(sp)
 8211014:	df000915 	stw	fp,36(sp)
 8211018:	ddc00815 	stw	r23,32(sp)
 821101c:	dd800715 	stw	r22,28(sp)
 8211020:	dd400615 	stw	r21,24(sp)
 8211024:	dd000515 	stw	r20,20(sp)
 8211028:	dc800315 	stw	r18,12(sp)
 821102c:	dc400215 	stw	r17,8(sp)
 8211030:	2027883a 	mov	r19,r4
 8211034:	2821883a 	mov	r16,r5
 8211038:	3800411e 	bne	r7,zero,8211140 <__udivdi3+0x13c>
 821103c:	3023883a 	mov	r17,r6
 8211040:	2025883a 	mov	r18,r4
 8211044:	2980522e 	bgeu	r5,r6,8211190 <__udivdi3+0x18c>
 8211048:	00bfffd4 	movui	r2,65535
 821104c:	282d883a 	mov	r22,r5
 8211050:	1180a836 	bltu	r2,r6,82112f4 <__udivdi3+0x2f0>
 8211054:	00803fc4 	movi	r2,255
 8211058:	1185803a 	cmpltu	r2,r2,r6
 821105c:	100490fa 	slli	r2,r2,3
 8211060:	3086d83a 	srl	r3,r6,r2
 8211064:	01020974 	movhi	r4,2085
 8211068:	21365a04 	addi	r4,r4,-9880
 821106c:	20c7883a 	add	r3,r4,r3
 8211070:	18c00003 	ldbu	r3,0(r3)
 8211074:	1885883a 	add	r2,r3,r2
 8211078:	00c00804 	movi	r3,32
 821107c:	1887c83a 	sub	r3,r3,r2
 8211080:	18000526 	beq	r3,zero,8211098 <__udivdi3+0x94>
 8211084:	80e0983a 	sll	r16,r16,r3
 8211088:	9884d83a 	srl	r2,r19,r2
 821108c:	30e2983a 	sll	r17,r6,r3
 8211090:	98e4983a 	sll	r18,r19,r3
 8211094:	142cb03a 	or	r22,r2,r16
 8211098:	882ad43a 	srli	r21,r17,16
 821109c:	b009883a 	mov	r4,r22
 82110a0:	8d3fffcc 	andi	r20,r17,65535
 82110a4:	a80b883a 	mov	r5,r21
 82110a8:	82029c00 	call	82029c0 <__umodsi3>
 82110ac:	b009883a 	mov	r4,r22
 82110b0:	a80b883a 	mov	r5,r21
 82110b4:	1027883a 	mov	r19,r2
 82110b8:	820295c0 	call	820295c <__udivsi3>
 82110bc:	102d883a 	mov	r22,r2
 82110c0:	9826943a 	slli	r19,r19,16
 82110c4:	9004d43a 	srli	r2,r18,16
 82110c8:	a5a1383a 	mul	r16,r20,r22
 82110cc:	14c4b03a 	or	r2,r2,r19
 82110d0:	1400052e 	bgeu	r2,r16,82110e8 <__udivdi3+0xe4>
 82110d4:	1445883a 	add	r2,r2,r17
 82110d8:	b0ffffc4 	addi	r3,r22,-1
 82110dc:	14400136 	bltu	r2,r17,82110e4 <__udivdi3+0xe0>
 82110e0:	14012336 	bltu	r2,r16,8211570 <__udivdi3+0x56c>
 82110e4:	182d883a 	mov	r22,r3
 82110e8:	1421c83a 	sub	r16,r2,r16
 82110ec:	a80b883a 	mov	r5,r21
 82110f0:	8009883a 	mov	r4,r16
 82110f4:	82029c00 	call	82029c0 <__umodsi3>
 82110f8:	1027883a 	mov	r19,r2
 82110fc:	a80b883a 	mov	r5,r21
 8211100:	8009883a 	mov	r4,r16
 8211104:	820295c0 	call	820295c <__udivsi3>
 8211108:	9826943a 	slli	r19,r19,16
 821110c:	a0a9383a 	mul	r20,r20,r2
 8211110:	94bfffcc 	andi	r18,r18,65535
 8211114:	94e4b03a 	or	r18,r18,r19
 8211118:	9500052e 	bgeu	r18,r20,8211130 <__udivdi3+0x12c>
 821111c:	8ca5883a 	add	r18,r17,r18
 8211120:	10ffffc4 	addi	r3,r2,-1
 8211124:	9440f136 	bltu	r18,r17,82114ec <__udivdi3+0x4e8>
 8211128:	9500f02e 	bgeu	r18,r20,82114ec <__udivdi3+0x4e8>
 821112c:	10bfff84 	addi	r2,r2,-2
 8211130:	b00c943a 	slli	r6,r22,16
 8211134:	0007883a 	mov	r3,zero
 8211138:	3084b03a 	or	r2,r6,r2
 821113c:	00005906 	br	82112a4 <__udivdi3+0x2a0>
 8211140:	29c05636 	bltu	r5,r7,821129c <__udivdi3+0x298>
 8211144:	00bfffd4 	movui	r2,65535
 8211148:	11c0622e 	bgeu	r2,r7,82112d4 <__udivdi3+0x2d0>
 821114c:	00804034 	movhi	r2,256
 8211150:	10bfffc4 	addi	r2,r2,-1
 8211154:	11c0ee36 	bltu	r2,r7,8211510 <__udivdi3+0x50c>
 8211158:	00800404 	movi	r2,16
 821115c:	3886d83a 	srl	r3,r7,r2
 8211160:	01020974 	movhi	r4,2085
 8211164:	21365a04 	addi	r4,r4,-9880
 8211168:	20c7883a 	add	r3,r4,r3
 821116c:	18c00003 	ldbu	r3,0(r3)
 8211170:	05400804 	movi	r21,32
 8211174:	1885883a 	add	r2,r3,r2
 8211178:	a8abc83a 	sub	r21,r21,r2
 821117c:	a800621e 	bne	r21,zero,8211308 <__udivdi3+0x304>
 8211180:	3c00e936 	bltu	r7,r16,8211528 <__udivdi3+0x524>
 8211184:	9985403a 	cmpgeu	r2,r19,r6
 8211188:	0007883a 	mov	r3,zero
 821118c:	00004506 	br	82112a4 <__udivdi3+0x2a0>
 8211190:	3000041e 	bne	r6,zero,82111a4 <__udivdi3+0x1a0>
 8211194:	000b883a 	mov	r5,zero
 8211198:	01000044 	movi	r4,1
 821119c:	820295c0 	call	820295c <__udivsi3>
 82111a0:	1023883a 	mov	r17,r2
 82111a4:	00bfffd4 	movui	r2,65535
 82111a8:	14404e2e 	bgeu	r2,r17,82112e4 <__udivdi3+0x2e0>
 82111ac:	00804034 	movhi	r2,256
 82111b0:	10bfffc4 	addi	r2,r2,-1
 82111b4:	1440d836 	bltu	r2,r17,8211518 <__udivdi3+0x514>
 82111b8:	00800404 	movi	r2,16
 82111bc:	8886d83a 	srl	r3,r17,r2
 82111c0:	01020974 	movhi	r4,2085
 82111c4:	21365a04 	addi	r4,r4,-9880
 82111c8:	20c7883a 	add	r3,r4,r3
 82111cc:	18c00003 	ldbu	r3,0(r3)
 82111d0:	1885883a 	add	r2,r3,r2
 82111d4:	00c00804 	movi	r3,32
 82111d8:	1887c83a 	sub	r3,r3,r2
 82111dc:	18008f1e 	bne	r3,zero,821141c <__udivdi3+0x418>
 82111e0:	882ad43a 	srli	r21,r17,16
 82111e4:	8461c83a 	sub	r16,r16,r17
 82111e8:	8d3fffcc 	andi	r20,r17,65535
 82111ec:	00c00044 	movi	r3,1
 82111f0:	8009883a 	mov	r4,r16
 82111f4:	a80b883a 	mov	r5,r21
 82111f8:	d8c00015 	stw	r3,0(sp)
 82111fc:	82029c00 	call	82029c0 <__umodsi3>
 8211200:	8009883a 	mov	r4,r16
 8211204:	a80b883a 	mov	r5,r21
 8211208:	1027883a 	mov	r19,r2
 821120c:	820295c0 	call	820295c <__udivsi3>
 8211210:	9826943a 	slli	r19,r19,16
 8211214:	9008d43a 	srli	r4,r18,16
 8211218:	1521383a 	mul	r16,r2,r20
 821121c:	102d883a 	mov	r22,r2
 8211220:	24c8b03a 	or	r4,r4,r19
 8211224:	d8c00017 	ldw	r3,0(sp)
 8211228:	2400052e 	bgeu	r4,r16,8211240 <__udivdi3+0x23c>
 821122c:	2449883a 	add	r4,r4,r17
 8211230:	b0bfffc4 	addi	r2,r22,-1
 8211234:	24400136 	bltu	r4,r17,821123c <__udivdi3+0x238>
 8211238:	2400ca36 	bltu	r4,r16,8211564 <__udivdi3+0x560>
 821123c:	102d883a 	mov	r22,r2
 8211240:	2421c83a 	sub	r16,r4,r16
 8211244:	a80b883a 	mov	r5,r21
 8211248:	8009883a 	mov	r4,r16
 821124c:	d8c00015 	stw	r3,0(sp)
 8211250:	82029c00 	call	82029c0 <__umodsi3>
 8211254:	1027883a 	mov	r19,r2
 8211258:	a80b883a 	mov	r5,r21
 821125c:	8009883a 	mov	r4,r16
 8211260:	820295c0 	call	820295c <__udivsi3>
 8211264:	9826943a 	slli	r19,r19,16
 8211268:	1529383a 	mul	r20,r2,r20
 821126c:	94bfffcc 	andi	r18,r18,65535
 8211270:	94e4b03a 	or	r18,r18,r19
 8211274:	d8c00017 	ldw	r3,0(sp)
 8211278:	9500052e 	bgeu	r18,r20,8211290 <__udivdi3+0x28c>
 821127c:	8ca5883a 	add	r18,r17,r18
 8211280:	113fffc4 	addi	r4,r2,-1
 8211284:	94409736 	bltu	r18,r17,82114e4 <__udivdi3+0x4e0>
 8211288:	9500962e 	bgeu	r18,r20,82114e4 <__udivdi3+0x4e0>
 821128c:	10bfff84 	addi	r2,r2,-2
 8211290:	b00c943a 	slli	r6,r22,16
 8211294:	3084b03a 	or	r2,r6,r2
 8211298:	00000206 	br	82112a4 <__udivdi3+0x2a0>
 821129c:	0007883a 	mov	r3,zero
 82112a0:	0005883a 	mov	r2,zero
 82112a4:	dfc00a17 	ldw	ra,40(sp)
 82112a8:	df000917 	ldw	fp,36(sp)
 82112ac:	ddc00817 	ldw	r23,32(sp)
 82112b0:	dd800717 	ldw	r22,28(sp)
 82112b4:	dd400617 	ldw	r21,24(sp)
 82112b8:	dd000517 	ldw	r20,20(sp)
 82112bc:	dcc00417 	ldw	r19,16(sp)
 82112c0:	dc800317 	ldw	r18,12(sp)
 82112c4:	dc400217 	ldw	r17,8(sp)
 82112c8:	dc000117 	ldw	r16,4(sp)
 82112cc:	dec00b04 	addi	sp,sp,44
 82112d0:	f800283a 	ret
 82112d4:	00803fc4 	movi	r2,255
 82112d8:	11c5803a 	cmpltu	r2,r2,r7
 82112dc:	100490fa 	slli	r2,r2,3
 82112e0:	003f9e06 	br	821115c <__udivdi3+0x158>
 82112e4:	00803fc4 	movi	r2,255
 82112e8:	1445803a 	cmpltu	r2,r2,r17
 82112ec:	100490fa 	slli	r2,r2,3
 82112f0:	003fb206 	br	82111bc <__udivdi3+0x1b8>
 82112f4:	00804034 	movhi	r2,256
 82112f8:	10bfffc4 	addi	r2,r2,-1
 82112fc:	11808836 	bltu	r2,r6,8211520 <__udivdi3+0x51c>
 8211300:	00800404 	movi	r2,16
 8211304:	003f5606 	br	8211060 <__udivdi3+0x5c>
 8211308:	30aed83a 	srl	r23,r6,r2
 821130c:	3d4e983a 	sll	r7,r7,r21
 8211310:	80acd83a 	srl	r22,r16,r2
 8211314:	9884d83a 	srl	r2,r19,r2
 8211318:	3deeb03a 	or	r23,r7,r23
 821131c:	b824d43a 	srli	r18,r23,16
 8211320:	8560983a 	sll	r16,r16,r21
 8211324:	b009883a 	mov	r4,r22
 8211328:	900b883a 	mov	r5,r18
 821132c:	3568983a 	sll	r20,r6,r21
 8211330:	1420b03a 	or	r16,r2,r16
 8211334:	82029c00 	call	82029c0 <__umodsi3>
 8211338:	b009883a 	mov	r4,r22
 821133c:	900b883a 	mov	r5,r18
 8211340:	1023883a 	mov	r17,r2
 8211344:	820295c0 	call	820295c <__udivsi3>
 8211348:	8808943a 	slli	r4,r17,16
 821134c:	bf3fffcc 	andi	fp,r23,65535
 8211350:	8006d43a 	srli	r3,r16,16
 8211354:	e0a3383a 	mul	r17,fp,r2
 8211358:	100d883a 	mov	r6,r2
 821135c:	1906b03a 	or	r3,r3,r4
 8211360:	1c40042e 	bgeu	r3,r17,8211374 <__udivdi3+0x370>
 8211364:	1dc7883a 	add	r3,r3,r23
 8211368:	10bfffc4 	addi	r2,r2,-1
 821136c:	1dc0752e 	bgeu	r3,r23,8211544 <__udivdi3+0x540>
 8211370:	100d883a 	mov	r6,r2
 8211374:	1c63c83a 	sub	r17,r3,r17
 8211378:	900b883a 	mov	r5,r18
 821137c:	8809883a 	mov	r4,r17
 8211380:	d9800015 	stw	r6,0(sp)
 8211384:	82029c00 	call	82029c0 <__umodsi3>
 8211388:	102d883a 	mov	r22,r2
 821138c:	8809883a 	mov	r4,r17
 8211390:	900b883a 	mov	r5,r18
 8211394:	820295c0 	call	820295c <__udivsi3>
 8211398:	b02c943a 	slli	r22,r22,16
 821139c:	e089383a 	mul	r4,fp,r2
 82113a0:	843fffcc 	andi	r16,r16,65535
 82113a4:	85a0b03a 	or	r16,r16,r22
 82113a8:	d9800017 	ldw	r6,0(sp)
 82113ac:	8100042e 	bgeu	r16,r4,82113c0 <__udivdi3+0x3bc>
 82113b0:	85e1883a 	add	r16,r16,r23
 82113b4:	10ffffc4 	addi	r3,r2,-1
 82113b8:	85c05e2e 	bgeu	r16,r23,8211534 <__udivdi3+0x530>
 82113bc:	1805883a 	mov	r2,r3
 82113c0:	300c943a 	slli	r6,r6,16
 82113c4:	a17fffcc 	andi	r5,r20,65535
 82113c8:	a028d43a 	srli	r20,r20,16
 82113cc:	3084b03a 	or	r2,r6,r2
 82113d0:	10ffffcc 	andi	r3,r2,65535
 82113d4:	100cd43a 	srli	r6,r2,16
 82113d8:	194f383a 	mul	r7,r3,r5
 82113dc:	1d07383a 	mul	r3,r3,r20
 82113e0:	314b383a 	mul	r5,r6,r5
 82113e4:	3810d43a 	srli	r8,r7,16
 82113e8:	8121c83a 	sub	r16,r16,r4
 82113ec:	1947883a 	add	r3,r3,r5
 82113f0:	40c7883a 	add	r3,r8,r3
 82113f4:	350d383a 	mul	r6,r6,r20
 82113f8:	1940022e 	bgeu	r3,r5,8211404 <__udivdi3+0x400>
 82113fc:	01000074 	movhi	r4,1
 8211400:	310d883a 	add	r6,r6,r4
 8211404:	1828d43a 	srli	r20,r3,16
 8211408:	a18d883a 	add	r6,r20,r6
 821140c:	81803e36 	bltu	r16,r6,8211508 <__udivdi3+0x504>
 8211410:	81803826 	beq	r16,r6,82114f4 <__udivdi3+0x4f0>
 8211414:	0007883a 	mov	r3,zero
 8211418:	003fa206 	br	82112a4 <__udivdi3+0x2a0>
 821141c:	88e2983a 	sll	r17,r17,r3
 8211420:	80a8d83a 	srl	r20,r16,r2
 8211424:	80e0983a 	sll	r16,r16,r3
 8211428:	882ad43a 	srli	r21,r17,16
 821142c:	9884d83a 	srl	r2,r19,r2
 8211430:	a009883a 	mov	r4,r20
 8211434:	a80b883a 	mov	r5,r21
 8211438:	142eb03a 	or	r23,r2,r16
 821143c:	98e4983a 	sll	r18,r19,r3
 8211440:	82029c00 	call	82029c0 <__umodsi3>
 8211444:	a009883a 	mov	r4,r20
 8211448:	a80b883a 	mov	r5,r21
 821144c:	1021883a 	mov	r16,r2
 8211450:	820295c0 	call	820295c <__udivsi3>
 8211454:	1039883a 	mov	fp,r2
 8211458:	8d3fffcc 	andi	r20,r17,65535
 821145c:	8020943a 	slli	r16,r16,16
 8211460:	b804d43a 	srli	r2,r23,16
 8211464:	a72d383a 	mul	r22,r20,fp
 8211468:	1404b03a 	or	r2,r2,r16
 821146c:	1580062e 	bgeu	r2,r22,8211488 <__udivdi3+0x484>
 8211470:	1445883a 	add	r2,r2,r17
 8211474:	e0ffffc4 	addi	r3,fp,-1
 8211478:	14403836 	bltu	r2,r17,821155c <__udivdi3+0x558>
 821147c:	1580372e 	bgeu	r2,r22,821155c <__udivdi3+0x558>
 8211480:	e73fff84 	addi	fp,fp,-2
 8211484:	1445883a 	add	r2,r2,r17
 8211488:	15adc83a 	sub	r22,r2,r22
 821148c:	a80b883a 	mov	r5,r21
 8211490:	b009883a 	mov	r4,r22
 8211494:	82029c00 	call	82029c0 <__umodsi3>
 8211498:	1027883a 	mov	r19,r2
 821149c:	b009883a 	mov	r4,r22
 82114a0:	a80b883a 	mov	r5,r21
 82114a4:	820295c0 	call	820295c <__udivsi3>
 82114a8:	9826943a 	slli	r19,r19,16
 82114ac:	a0a1383a 	mul	r16,r20,r2
 82114b0:	b93fffcc 	andi	r4,r23,65535
 82114b4:	24c8b03a 	or	r4,r4,r19
 82114b8:	2400062e 	bgeu	r4,r16,82114d4 <__udivdi3+0x4d0>
 82114bc:	2449883a 	add	r4,r4,r17
 82114c0:	10ffffc4 	addi	r3,r2,-1
 82114c4:	24402336 	bltu	r4,r17,8211554 <__udivdi3+0x550>
 82114c8:	2400222e 	bgeu	r4,r16,8211554 <__udivdi3+0x550>
 82114cc:	10bfff84 	addi	r2,r2,-2
 82114d0:	2449883a 	add	r4,r4,r17
 82114d4:	e038943a 	slli	fp,fp,16
 82114d8:	2421c83a 	sub	r16,r4,r16
 82114dc:	e086b03a 	or	r3,fp,r2
 82114e0:	003f4306 	br	82111f0 <__udivdi3+0x1ec>
 82114e4:	2005883a 	mov	r2,r4
 82114e8:	003f6906 	br	8211290 <__udivdi3+0x28c>
 82114ec:	1805883a 	mov	r2,r3
 82114f0:	003f0f06 	br	8211130 <__udivdi3+0x12c>
 82114f4:	1806943a 	slli	r3,r3,16
 82114f8:	9d66983a 	sll	r19,r19,r21
 82114fc:	39ffffcc 	andi	r7,r7,65535
 8211500:	19c7883a 	add	r3,r3,r7
 8211504:	98ffc32e 	bgeu	r19,r3,8211414 <__udivdi3+0x410>
 8211508:	10bfffc4 	addi	r2,r2,-1
 821150c:	003fc106 	br	8211414 <__udivdi3+0x410>
 8211510:	00800604 	movi	r2,24
 8211514:	003f1106 	br	821115c <__udivdi3+0x158>
 8211518:	00800604 	movi	r2,24
 821151c:	003f2706 	br	82111bc <__udivdi3+0x1b8>
 8211520:	00800604 	movi	r2,24
 8211524:	003ece06 	br	8211060 <__udivdi3+0x5c>
 8211528:	0007883a 	mov	r3,zero
 821152c:	00800044 	movi	r2,1
 8211530:	003f5c06 	br	82112a4 <__udivdi3+0x2a0>
 8211534:	813fa12e 	bgeu	r16,r4,82113bc <__udivdi3+0x3b8>
 8211538:	10bfff84 	addi	r2,r2,-2
 821153c:	85e1883a 	add	r16,r16,r23
 8211540:	003f9f06 	br	82113c0 <__udivdi3+0x3bc>
 8211544:	1c7f8a2e 	bgeu	r3,r17,8211370 <__udivdi3+0x36c>
 8211548:	31bfff84 	addi	r6,r6,-2
 821154c:	1dc7883a 	add	r3,r3,r23
 8211550:	003f8806 	br	8211374 <__udivdi3+0x370>
 8211554:	1805883a 	mov	r2,r3
 8211558:	003fde06 	br	82114d4 <__udivdi3+0x4d0>
 821155c:	1839883a 	mov	fp,r3
 8211560:	003fc906 	br	8211488 <__udivdi3+0x484>
 8211564:	b5bfff84 	addi	r22,r22,-2
 8211568:	2449883a 	add	r4,r4,r17
 821156c:	003f3406 	br	8211240 <__udivdi3+0x23c>
 8211570:	b5bfff84 	addi	r22,r22,-2
 8211574:	1445883a 	add	r2,r2,r17
 8211578:	003edb06 	br	82110e8 <__udivdi3+0xe4>

0821157c <__umoddi3>:
 821157c:	defff404 	addi	sp,sp,-48
 8211580:	df000a15 	stw	fp,40(sp)
 8211584:	dc400315 	stw	r17,12(sp)
 8211588:	dc000215 	stw	r16,8(sp)
 821158c:	dfc00b15 	stw	ra,44(sp)
 8211590:	ddc00915 	stw	r23,36(sp)
 8211594:	dd800815 	stw	r22,32(sp)
 8211598:	dd400715 	stw	r21,28(sp)
 821159c:	dd000615 	stw	r20,24(sp)
 82115a0:	dcc00515 	stw	r19,20(sp)
 82115a4:	dc800415 	stw	r18,16(sp)
 82115a8:	2021883a 	mov	r16,r4
 82115ac:	2823883a 	mov	r17,r5
 82115b0:	2839883a 	mov	fp,r5
 82115b4:	38003c1e 	bne	r7,zero,82116a8 <__umoddi3+0x12c>
 82115b8:	3027883a 	mov	r19,r6
 82115bc:	2029883a 	mov	r20,r4
 82115c0:	2980512e 	bgeu	r5,r6,8211708 <__umoddi3+0x18c>
 82115c4:	00bfffd4 	movui	r2,65535
 82115c8:	11809a36 	bltu	r2,r6,8211834 <__umoddi3+0x2b8>
 82115cc:	01003fc4 	movi	r4,255
 82115d0:	2189803a 	cmpltu	r4,r4,r6
 82115d4:	200890fa 	slli	r4,r4,3
 82115d8:	3104d83a 	srl	r2,r6,r4
 82115dc:	00c20974 	movhi	r3,2085
 82115e0:	18f65a04 	addi	r3,r3,-9880
 82115e4:	1885883a 	add	r2,r3,r2
 82115e8:	10c00003 	ldbu	r3,0(r2)
 82115ec:	00800804 	movi	r2,32
 82115f0:	1909883a 	add	r4,r3,r4
 82115f4:	1125c83a 	sub	r18,r2,r4
 82115f8:	90000526 	beq	r18,zero,8211610 <__umoddi3+0x94>
 82115fc:	8ca2983a 	sll	r17,r17,r18
 8211600:	8108d83a 	srl	r4,r16,r4
 8211604:	34a6983a 	sll	r19,r6,r18
 8211608:	84a8983a 	sll	r20,r16,r18
 821160c:	2478b03a 	or	fp,r4,r17
 8211610:	982ed43a 	srli	r23,r19,16
 8211614:	e009883a 	mov	r4,fp
 8211618:	9dbfffcc 	andi	r22,r19,65535
 821161c:	b80b883a 	mov	r5,r23
 8211620:	82029c00 	call	82029c0 <__umodsi3>
 8211624:	e009883a 	mov	r4,fp
 8211628:	b80b883a 	mov	r5,r23
 821162c:	102b883a 	mov	r21,r2
 8211630:	820295c0 	call	820295c <__udivsi3>
 8211634:	a806943a 	slli	r3,r21,16
 8211638:	a008d43a 	srli	r4,r20,16
 821163c:	b085383a 	mul	r2,r22,r2
 8211640:	20c8b03a 	or	r4,r4,r3
 8211644:	2080032e 	bgeu	r4,r2,8211654 <__umoddi3+0xd8>
 8211648:	24c9883a 	add	r4,r4,r19
 821164c:	24c00136 	bltu	r4,r19,8211654 <__umoddi3+0xd8>
 8211650:	20811036 	bltu	r4,r2,8211a94 <__umoddi3+0x518>
 8211654:	20abc83a 	sub	r21,r4,r2
 8211658:	b80b883a 	mov	r5,r23
 821165c:	a809883a 	mov	r4,r21
 8211660:	82029c00 	call	82029c0 <__umodsi3>
 8211664:	1023883a 	mov	r17,r2
 8211668:	b80b883a 	mov	r5,r23
 821166c:	a809883a 	mov	r4,r21
 8211670:	820295c0 	call	820295c <__udivsi3>
 8211674:	8822943a 	slli	r17,r17,16
 8211678:	b085383a 	mul	r2,r22,r2
 821167c:	a0ffffcc 	andi	r3,r20,65535
 8211680:	1c46b03a 	or	r3,r3,r17
 8211684:	1880042e 	bgeu	r3,r2,8211698 <__umoddi3+0x11c>
 8211688:	1cc7883a 	add	r3,r3,r19
 821168c:	1cc00236 	bltu	r3,r19,8211698 <__umoddi3+0x11c>
 8211690:	1880012e 	bgeu	r3,r2,8211698 <__umoddi3+0x11c>
 8211694:	1cc7883a 	add	r3,r3,r19
 8211698:	1885c83a 	sub	r2,r3,r2
 821169c:	1484d83a 	srl	r2,r2,r18
 82116a0:	0007883a 	mov	r3,zero
 82116a4:	00004f06 	br	82117e4 <__umoddi3+0x268>
 82116a8:	29c04c36 	bltu	r5,r7,82117dc <__umoddi3+0x260>
 82116ac:	00bfffd4 	movui	r2,65535
 82116b0:	11c0582e 	bgeu	r2,r7,8211814 <__umoddi3+0x298>
 82116b4:	00804034 	movhi	r2,256
 82116b8:	10bfffc4 	addi	r2,r2,-1
 82116bc:	11c0e736 	bltu	r2,r7,8211a5c <__umoddi3+0x4e0>
 82116c0:	01000404 	movi	r4,16
 82116c4:	3904d83a 	srl	r2,r7,r4
 82116c8:	00c20974 	movhi	r3,2085
 82116cc:	18f65a04 	addi	r3,r3,-9880
 82116d0:	1885883a 	add	r2,r3,r2
 82116d4:	14c00003 	ldbu	r19,0(r2)
 82116d8:	00c00804 	movi	r3,32
 82116dc:	9927883a 	add	r19,r19,r4
 82116e0:	1ce9c83a 	sub	r20,r3,r19
 82116e4:	a000581e 	bne	r20,zero,8211848 <__umoddi3+0x2cc>
 82116e8:	3c400136 	bltu	r7,r17,82116f0 <__umoddi3+0x174>
 82116ec:	8180eb36 	bltu	r16,r6,8211a9c <__umoddi3+0x520>
 82116f0:	8185c83a 	sub	r2,r16,r6
 82116f4:	89e3c83a 	sub	r17,r17,r7
 82116f8:	8089803a 	cmpltu	r4,r16,r2
 82116fc:	8939c83a 	sub	fp,r17,r4
 8211700:	e007883a 	mov	r3,fp
 8211704:	00003706 	br	82117e4 <__umoddi3+0x268>
 8211708:	3000041e 	bne	r6,zero,821171c <__umoddi3+0x1a0>
 821170c:	000b883a 	mov	r5,zero
 8211710:	01000044 	movi	r4,1
 8211714:	820295c0 	call	820295c <__udivsi3>
 8211718:	1027883a 	mov	r19,r2
 821171c:	00bfffd4 	movui	r2,65535
 8211720:	14c0402e 	bgeu	r2,r19,8211824 <__umoddi3+0x2a8>
 8211724:	00804034 	movhi	r2,256
 8211728:	10bfffc4 	addi	r2,r2,-1
 821172c:	14c0cd36 	bltu	r2,r19,8211a64 <__umoddi3+0x4e8>
 8211730:	00800404 	movi	r2,16
 8211734:	9886d83a 	srl	r3,r19,r2
 8211738:	01020974 	movhi	r4,2085
 821173c:	21365a04 	addi	r4,r4,-9880
 8211740:	20c7883a 	add	r3,r4,r3
 8211744:	18c00003 	ldbu	r3,0(r3)
 8211748:	1887883a 	add	r3,r3,r2
 821174c:	00800804 	movi	r2,32
 8211750:	10e5c83a 	sub	r18,r2,r3
 8211754:	9000901e 	bne	r18,zero,8211998 <__umoddi3+0x41c>
 8211758:	982cd43a 	srli	r22,r19,16
 821175c:	8ce3c83a 	sub	r17,r17,r19
 8211760:	9d7fffcc 	andi	r21,r19,65535
 8211764:	b00b883a 	mov	r5,r22
 8211768:	8809883a 	mov	r4,r17
 821176c:	82029c00 	call	82029c0 <__umodsi3>
 8211770:	8809883a 	mov	r4,r17
 8211774:	b00b883a 	mov	r5,r22
 8211778:	1021883a 	mov	r16,r2
 821177c:	820295c0 	call	820295c <__udivsi3>
 8211780:	8006943a 	slli	r3,r16,16
 8211784:	a008d43a 	srli	r4,r20,16
 8211788:	1545383a 	mul	r2,r2,r21
 821178c:	20c8b03a 	or	r4,r4,r3
 8211790:	2080042e 	bgeu	r4,r2,82117a4 <__umoddi3+0x228>
 8211794:	24c9883a 	add	r4,r4,r19
 8211798:	24c00236 	bltu	r4,r19,82117a4 <__umoddi3+0x228>
 821179c:	2080012e 	bgeu	r4,r2,82117a4 <__umoddi3+0x228>
 82117a0:	24c9883a 	add	r4,r4,r19
 82117a4:	20a1c83a 	sub	r16,r4,r2
 82117a8:	b00b883a 	mov	r5,r22
 82117ac:	8009883a 	mov	r4,r16
 82117b0:	82029c00 	call	82029c0 <__umodsi3>
 82117b4:	1023883a 	mov	r17,r2
 82117b8:	b00b883a 	mov	r5,r22
 82117bc:	8009883a 	mov	r4,r16
 82117c0:	820295c0 	call	820295c <__udivsi3>
 82117c4:	8822943a 	slli	r17,r17,16
 82117c8:	1545383a 	mul	r2,r2,r21
 82117cc:	a53fffcc 	andi	r20,r20,65535
 82117d0:	a446b03a 	or	r3,r20,r17
 82117d4:	18bfb02e 	bgeu	r3,r2,8211698 <__umoddi3+0x11c>
 82117d8:	003fab06 	br	8211688 <__umoddi3+0x10c>
 82117dc:	2005883a 	mov	r2,r4
 82117e0:	2807883a 	mov	r3,r5
 82117e4:	dfc00b17 	ldw	ra,44(sp)
 82117e8:	df000a17 	ldw	fp,40(sp)
 82117ec:	ddc00917 	ldw	r23,36(sp)
 82117f0:	dd800817 	ldw	r22,32(sp)
 82117f4:	dd400717 	ldw	r21,28(sp)
 82117f8:	dd000617 	ldw	r20,24(sp)
 82117fc:	dcc00517 	ldw	r19,20(sp)
 8211800:	dc800417 	ldw	r18,16(sp)
 8211804:	dc400317 	ldw	r17,12(sp)
 8211808:	dc000217 	ldw	r16,8(sp)
 821180c:	dec00c04 	addi	sp,sp,48
 8211810:	f800283a 	ret
 8211814:	04c03fc4 	movi	r19,255
 8211818:	99c9803a 	cmpltu	r4,r19,r7
 821181c:	200890fa 	slli	r4,r4,3
 8211820:	003fa806 	br	82116c4 <__umoddi3+0x148>
 8211824:	00803fc4 	movi	r2,255
 8211828:	14c5803a 	cmpltu	r2,r2,r19
 821182c:	100490fa 	slli	r2,r2,3
 8211830:	003fc006 	br	8211734 <__umoddi3+0x1b8>
 8211834:	00804034 	movhi	r2,256
 8211838:	10bfffc4 	addi	r2,r2,-1
 821183c:	11808b36 	bltu	r2,r6,8211a6c <__umoddi3+0x4f0>
 8211840:	01000404 	movi	r4,16
 8211844:	003f6406 	br	82115d8 <__umoddi3+0x5c>
 8211848:	34c4d83a 	srl	r2,r6,r19
 821184c:	3d0e983a 	sll	r7,r7,r20
 8211850:	8cf8d83a 	srl	fp,r17,r19
 8211854:	8d10983a 	sll	r8,r17,r20
 8211858:	38aab03a 	or	r21,r7,r2
 821185c:	a82cd43a 	srli	r22,r21,16
 8211860:	84e2d83a 	srl	r17,r16,r19
 8211864:	e009883a 	mov	r4,fp
 8211868:	b00b883a 	mov	r5,r22
 821186c:	8a22b03a 	or	r17,r17,r8
 8211870:	3524983a 	sll	r18,r6,r20
 8211874:	82029c00 	call	82029c0 <__umodsi3>
 8211878:	e009883a 	mov	r4,fp
 821187c:	b00b883a 	mov	r5,r22
 8211880:	102f883a 	mov	r23,r2
 8211884:	820295c0 	call	820295c <__udivsi3>
 8211888:	100d883a 	mov	r6,r2
 821188c:	b808943a 	slli	r4,r23,16
 8211890:	aa3fffcc 	andi	r8,r21,65535
 8211894:	8804d43a 	srli	r2,r17,16
 8211898:	41af383a 	mul	r23,r8,r6
 821189c:	8520983a 	sll	r16,r16,r20
 82118a0:	1104b03a 	or	r2,r2,r4
 82118a4:	15c0042e 	bgeu	r2,r23,82118b8 <__umoddi3+0x33c>
 82118a8:	1545883a 	add	r2,r2,r21
 82118ac:	30ffffc4 	addi	r3,r6,-1
 82118b0:	1540742e 	bgeu	r2,r21,8211a84 <__umoddi3+0x508>
 82118b4:	180d883a 	mov	r6,r3
 82118b8:	15efc83a 	sub	r23,r2,r23
 82118bc:	b00b883a 	mov	r5,r22
 82118c0:	b809883a 	mov	r4,r23
 82118c4:	d9800115 	stw	r6,4(sp)
 82118c8:	da000015 	stw	r8,0(sp)
 82118cc:	82029c00 	call	82029c0 <__umodsi3>
 82118d0:	b00b883a 	mov	r5,r22
 82118d4:	b809883a 	mov	r4,r23
 82118d8:	1039883a 	mov	fp,r2
 82118dc:	820295c0 	call	820295c <__udivsi3>
 82118e0:	da000017 	ldw	r8,0(sp)
 82118e4:	e038943a 	slli	fp,fp,16
 82118e8:	100b883a 	mov	r5,r2
 82118ec:	4089383a 	mul	r4,r8,r2
 82118f0:	8a3fffcc 	andi	r8,r17,65535
 82118f4:	4710b03a 	or	r8,r8,fp
 82118f8:	d9800117 	ldw	r6,4(sp)
 82118fc:	4100042e 	bgeu	r8,r4,8211910 <__umoddi3+0x394>
 8211900:	4551883a 	add	r8,r8,r21
 8211904:	10bfffc4 	addi	r2,r2,-1
 8211908:	45405a2e 	bgeu	r8,r21,8211a74 <__umoddi3+0x4f8>
 821190c:	100b883a 	mov	r5,r2
 8211910:	300c943a 	slli	r6,r6,16
 8211914:	91ffffcc 	andi	r7,r18,65535
 8211918:	9004d43a 	srli	r2,r18,16
 821191c:	314cb03a 	or	r6,r6,r5
 8211920:	317fffcc 	andi	r5,r6,65535
 8211924:	300cd43a 	srli	r6,r6,16
 8211928:	29d3383a 	mul	r9,r5,r7
 821192c:	288b383a 	mul	r5,r5,r2
 8211930:	31cf383a 	mul	r7,r6,r7
 8211934:	4806d43a 	srli	r3,r9,16
 8211938:	4111c83a 	sub	r8,r8,r4
 821193c:	29cb883a 	add	r5,r5,r7
 8211940:	194b883a 	add	r5,r3,r5
 8211944:	3085383a 	mul	r2,r6,r2
 8211948:	29c0022e 	bgeu	r5,r7,8211954 <__umoddi3+0x3d8>
 821194c:	00c00074 	movhi	r3,1
 8211950:	10c5883a 	add	r2,r2,r3
 8211954:	2808d43a 	srli	r4,r5,16
 8211958:	280a943a 	slli	r5,r5,16
 821195c:	4a7fffcc 	andi	r9,r9,65535
 8211960:	2085883a 	add	r2,r4,r2
 8211964:	2a4b883a 	add	r5,r5,r9
 8211968:	40803636 	bltu	r8,r2,8211a44 <__umoddi3+0x4c8>
 821196c:	40804d26 	beq	r8,r2,8211aa4 <__umoddi3+0x528>
 8211970:	4089c83a 	sub	r4,r8,r2
 8211974:	280f883a 	mov	r7,r5
 8211978:	81cfc83a 	sub	r7,r16,r7
 821197c:	81c7803a 	cmpltu	r3,r16,r7
 8211980:	20c7c83a 	sub	r3,r4,r3
 8211984:	1cc4983a 	sll	r2,r3,r19
 8211988:	3d0ed83a 	srl	r7,r7,r20
 821198c:	1d06d83a 	srl	r3,r3,r20
 8211990:	11c4b03a 	or	r2,r2,r7
 8211994:	003f9306 	br	82117e4 <__umoddi3+0x268>
 8211998:	9ca6983a 	sll	r19,r19,r18
 821199c:	88e8d83a 	srl	r20,r17,r3
 82119a0:	80c4d83a 	srl	r2,r16,r3
 82119a4:	982cd43a 	srli	r22,r19,16
 82119a8:	8ca2983a 	sll	r17,r17,r18
 82119ac:	a009883a 	mov	r4,r20
 82119b0:	b00b883a 	mov	r5,r22
 82119b4:	1478b03a 	or	fp,r2,r17
 82119b8:	82029c00 	call	82029c0 <__umodsi3>
 82119bc:	a009883a 	mov	r4,r20
 82119c0:	b00b883a 	mov	r5,r22
 82119c4:	1023883a 	mov	r17,r2
 82119c8:	820295c0 	call	820295c <__udivsi3>
 82119cc:	9d7fffcc 	andi	r21,r19,65535
 82119d0:	880a943a 	slli	r5,r17,16
 82119d4:	e008d43a 	srli	r4,fp,16
 82119d8:	a885383a 	mul	r2,r21,r2
 82119dc:	84a8983a 	sll	r20,r16,r18
 82119e0:	2148b03a 	or	r4,r4,r5
 82119e4:	2080042e 	bgeu	r4,r2,82119f8 <__umoddi3+0x47c>
 82119e8:	24c9883a 	add	r4,r4,r19
 82119ec:	24c00236 	bltu	r4,r19,82119f8 <__umoddi3+0x47c>
 82119f0:	2080012e 	bgeu	r4,r2,82119f8 <__umoddi3+0x47c>
 82119f4:	24c9883a 	add	r4,r4,r19
 82119f8:	20a3c83a 	sub	r17,r4,r2
 82119fc:	b00b883a 	mov	r5,r22
 8211a00:	8809883a 	mov	r4,r17
 8211a04:	82029c00 	call	82029c0 <__umodsi3>
 8211a08:	102f883a 	mov	r23,r2
 8211a0c:	8809883a 	mov	r4,r17
 8211a10:	b00b883a 	mov	r5,r22
 8211a14:	820295c0 	call	820295c <__udivsi3>
 8211a18:	b82e943a 	slli	r23,r23,16
 8211a1c:	a885383a 	mul	r2,r21,r2
 8211a20:	e13fffcc 	andi	r4,fp,65535
 8211a24:	25c8b03a 	or	r4,r4,r23
 8211a28:	2080042e 	bgeu	r4,r2,8211a3c <__umoddi3+0x4c0>
 8211a2c:	24c9883a 	add	r4,r4,r19
 8211a30:	24c00236 	bltu	r4,r19,8211a3c <__umoddi3+0x4c0>
 8211a34:	2080012e 	bgeu	r4,r2,8211a3c <__umoddi3+0x4c0>
 8211a38:	24c9883a 	add	r4,r4,r19
 8211a3c:	20a3c83a 	sub	r17,r4,r2
 8211a40:	003f4806 	br	8211764 <__umoddi3+0x1e8>
 8211a44:	2c8fc83a 	sub	r7,r5,r18
 8211a48:	1545c83a 	sub	r2,r2,r21
 8211a4c:	29cb803a 	cmpltu	r5,r5,r7
 8211a50:	1145c83a 	sub	r2,r2,r5
 8211a54:	4089c83a 	sub	r4,r8,r2
 8211a58:	003fc706 	br	8211978 <__umoddi3+0x3fc>
 8211a5c:	01000604 	movi	r4,24
 8211a60:	003f1806 	br	82116c4 <__umoddi3+0x148>
 8211a64:	00800604 	movi	r2,24
 8211a68:	003f3206 	br	8211734 <__umoddi3+0x1b8>
 8211a6c:	01000604 	movi	r4,24
 8211a70:	003ed906 	br	82115d8 <__umoddi3+0x5c>
 8211a74:	413fa52e 	bgeu	r8,r4,821190c <__umoddi3+0x390>
 8211a78:	297fff84 	addi	r5,r5,-2
 8211a7c:	4551883a 	add	r8,r8,r21
 8211a80:	003fa306 	br	8211910 <__umoddi3+0x394>
 8211a84:	15ff8b2e 	bgeu	r2,r23,82118b4 <__umoddi3+0x338>
 8211a88:	31bfff84 	addi	r6,r6,-2
 8211a8c:	1545883a 	add	r2,r2,r21
 8211a90:	003f8906 	br	82118b8 <__umoddi3+0x33c>
 8211a94:	24c9883a 	add	r4,r4,r19
 8211a98:	003eee06 	br	8211654 <__umoddi3+0xd8>
 8211a9c:	8005883a 	mov	r2,r16
 8211aa0:	003f1706 	br	8211700 <__umoddi3+0x184>
 8211aa4:	817fe736 	bltu	r16,r5,8211a44 <__umoddi3+0x4c8>
 8211aa8:	280f883a 	mov	r7,r5
 8211aac:	0009883a 	mov	r4,zero
 8211ab0:	003fb106 	br	8211978 <__umoddi3+0x3fc>

08211ab4 <__adddf3>:
 8211ab4:	02c00434 	movhi	r11,16
 8211ab8:	5affffc4 	addi	r11,r11,-1
 8211abc:	2806d7fa 	srli	r3,r5,31
 8211ac0:	2ad4703a 	and	r10,r5,r11
 8211ac4:	3ad2703a 	and	r9,r7,r11
 8211ac8:	3804d53a 	srli	r2,r7,20
 8211acc:	3018d77a 	srli	r12,r6,29
 8211ad0:	280ad53a 	srli	r5,r5,20
 8211ad4:	501490fa 	slli	r10,r10,3
 8211ad8:	2010d77a 	srli	r8,r4,29
 8211adc:	481290fa 	slli	r9,r9,3
 8211ae0:	380ed7fa 	srli	r7,r7,31
 8211ae4:	defffb04 	addi	sp,sp,-20
 8211ae8:	dc800215 	stw	r18,8(sp)
 8211aec:	dc400115 	stw	r17,4(sp)
 8211af0:	dc000015 	stw	r16,0(sp)
 8211af4:	dfc00415 	stw	ra,16(sp)
 8211af8:	dcc00315 	stw	r19,12(sp)
 8211afc:	1c803fcc 	andi	r18,r3,255
 8211b00:	2c01ffcc 	andi	r16,r5,2047
 8211b04:	5210b03a 	or	r8,r10,r8
 8211b08:	202290fa 	slli	r17,r4,3
 8211b0c:	1081ffcc 	andi	r2,r2,2047
 8211b10:	4b12b03a 	or	r9,r9,r12
 8211b14:	300c90fa 	slli	r6,r6,3
 8211b18:	91c07526 	beq	r18,r7,8211cf0 <__adddf3+0x23c>
 8211b1c:	8087c83a 	sub	r3,r16,r2
 8211b20:	00c0ab0e 	bge	zero,r3,8211dd0 <__adddf3+0x31c>
 8211b24:	10002a1e 	bne	r2,zero,8211bd0 <__adddf3+0x11c>
 8211b28:	4984b03a 	or	r2,r9,r6
 8211b2c:	1000961e 	bne	r2,zero,8211d88 <__adddf3+0x2d4>
 8211b30:	888001cc 	andi	r2,r17,7
 8211b34:	10000726 	beq	r2,zero,8211b54 <__adddf3+0xa0>
 8211b38:	888003cc 	andi	r2,r17,15
 8211b3c:	00c00104 	movi	r3,4
 8211b40:	10c00426 	beq	r2,r3,8211b54 <__adddf3+0xa0>
 8211b44:	88c7883a 	add	r3,r17,r3
 8211b48:	1c63803a 	cmpltu	r17,r3,r17
 8211b4c:	4451883a 	add	r8,r8,r17
 8211b50:	1823883a 	mov	r17,r3
 8211b54:	4080202c 	andhi	r2,r8,128
 8211b58:	10005926 	beq	r2,zero,8211cc0 <__adddf3+0x20c>
 8211b5c:	84000044 	addi	r16,r16,1
 8211b60:	0081ffc4 	movi	r2,2047
 8211b64:	8080ba26 	beq	r16,r2,8211e50 <__adddf3+0x39c>
 8211b68:	00bfe034 	movhi	r2,65408
 8211b6c:	10bfffc4 	addi	r2,r2,-1
 8211b70:	4090703a 	and	r8,r8,r2
 8211b74:	4004977a 	slli	r2,r8,29
 8211b78:	4010927a 	slli	r8,r8,9
 8211b7c:	8822d0fa 	srli	r17,r17,3
 8211b80:	8401ffcc 	andi	r16,r16,2047
 8211b84:	4010d33a 	srli	r8,r8,12
 8211b88:	9007883a 	mov	r3,r18
 8211b8c:	1444b03a 	or	r2,r2,r17
 8211b90:	8401ffcc 	andi	r16,r16,2047
 8211b94:	8020953a 	slli	r16,r16,20
 8211b98:	18c03fcc 	andi	r3,r3,255
 8211b9c:	01000434 	movhi	r4,16
 8211ba0:	213fffc4 	addi	r4,r4,-1
 8211ba4:	180697fa 	slli	r3,r3,31
 8211ba8:	4110703a 	and	r8,r8,r4
 8211bac:	4410b03a 	or	r8,r8,r16
 8211bb0:	40c6b03a 	or	r3,r8,r3
 8211bb4:	dfc00417 	ldw	ra,16(sp)
 8211bb8:	dcc00317 	ldw	r19,12(sp)
 8211bbc:	dc800217 	ldw	r18,8(sp)
 8211bc0:	dc400117 	ldw	r17,4(sp)
 8211bc4:	dc000017 	ldw	r16,0(sp)
 8211bc8:	dec00504 	addi	sp,sp,20
 8211bcc:	f800283a 	ret
 8211bd0:	0081ffc4 	movi	r2,2047
 8211bd4:	80bfd626 	beq	r16,r2,8211b30 <__adddf3+0x7c>
 8211bd8:	4a402034 	orhi	r9,r9,128
 8211bdc:	00800e04 	movi	r2,56
 8211be0:	10c09f16 	blt	r2,r3,8211e60 <__adddf3+0x3ac>
 8211be4:	008007c4 	movi	r2,31
 8211be8:	10c0c216 	blt	r2,r3,8211ef4 <__adddf3+0x440>
 8211bec:	00800804 	movi	r2,32
 8211bf0:	10c5c83a 	sub	r2,r2,r3
 8211bf4:	488a983a 	sll	r5,r9,r2
 8211bf8:	30c8d83a 	srl	r4,r6,r3
 8211bfc:	3084983a 	sll	r2,r6,r2
 8211c00:	48c6d83a 	srl	r3,r9,r3
 8211c04:	290cb03a 	or	r6,r5,r4
 8211c08:	1004c03a 	cmpne	r2,r2,zero
 8211c0c:	308cb03a 	or	r6,r6,r2
 8211c10:	898dc83a 	sub	r6,r17,r6
 8211c14:	89a3803a 	cmpltu	r17,r17,r6
 8211c18:	40d1c83a 	sub	r8,r8,r3
 8211c1c:	4451c83a 	sub	r8,r8,r17
 8211c20:	3023883a 	mov	r17,r6
 8211c24:	4080202c 	andhi	r2,r8,128
 8211c28:	10002326 	beq	r2,zero,8211cb8 <__adddf3+0x204>
 8211c2c:	04c02034 	movhi	r19,128
 8211c30:	9cffffc4 	addi	r19,r19,-1
 8211c34:	44e6703a 	and	r19,r8,r19
 8211c38:	98007626 	beq	r19,zero,8211e14 <__adddf3+0x360>
 8211c3c:	9809883a 	mov	r4,r19
 8211c40:	82140b80 	call	82140b8 <__clzsi2>
 8211c44:	10fffe04 	addi	r3,r2,-8
 8211c48:	010007c4 	movi	r4,31
 8211c4c:	20c07716 	blt	r4,r3,8211e2c <__adddf3+0x378>
 8211c50:	00800804 	movi	r2,32
 8211c54:	10c5c83a 	sub	r2,r2,r3
 8211c58:	8884d83a 	srl	r2,r17,r2
 8211c5c:	98d0983a 	sll	r8,r19,r3
 8211c60:	88e2983a 	sll	r17,r17,r3
 8211c64:	1204b03a 	or	r2,r2,r8
 8211c68:	1c007416 	blt	r3,r16,8211e3c <__adddf3+0x388>
 8211c6c:	1c21c83a 	sub	r16,r3,r16
 8211c70:	82000044 	addi	r8,r16,1
 8211c74:	00c007c4 	movi	r3,31
 8211c78:	1a009116 	blt	r3,r8,8211ec0 <__adddf3+0x40c>
 8211c7c:	00c00804 	movi	r3,32
 8211c80:	1a07c83a 	sub	r3,r3,r8
 8211c84:	8a08d83a 	srl	r4,r17,r8
 8211c88:	88e2983a 	sll	r17,r17,r3
 8211c8c:	10c6983a 	sll	r3,r2,r3
 8211c90:	1210d83a 	srl	r8,r2,r8
 8211c94:	8804c03a 	cmpne	r2,r17,zero
 8211c98:	1906b03a 	or	r3,r3,r4
 8211c9c:	18a2b03a 	or	r17,r3,r2
 8211ca0:	0021883a 	mov	r16,zero
 8211ca4:	003fa206 	br	8211b30 <__adddf3+0x7c>
 8211ca8:	1890b03a 	or	r8,r3,r2
 8211cac:	40017d26 	beq	r8,zero,82122a4 <__adddf3+0x7f0>
 8211cb0:	1011883a 	mov	r8,r2
 8211cb4:	1823883a 	mov	r17,r3
 8211cb8:	888001cc 	andi	r2,r17,7
 8211cbc:	103f9e1e 	bne	r2,zero,8211b38 <__adddf3+0x84>
 8211cc0:	4004977a 	slli	r2,r8,29
 8211cc4:	8822d0fa 	srli	r17,r17,3
 8211cc8:	4010d0fa 	srli	r8,r8,3
 8211ccc:	9007883a 	mov	r3,r18
 8211cd0:	1444b03a 	or	r2,r2,r17
 8211cd4:	0101ffc4 	movi	r4,2047
 8211cd8:	81002426 	beq	r16,r4,8211d6c <__adddf3+0x2b8>
 8211cdc:	8120703a 	and	r16,r16,r4
 8211ce0:	01000434 	movhi	r4,16
 8211ce4:	213fffc4 	addi	r4,r4,-1
 8211ce8:	4110703a 	and	r8,r8,r4
 8211cec:	003fa806 	br	8211b90 <__adddf3+0xdc>
 8211cf0:	8089c83a 	sub	r4,r16,r2
 8211cf4:	01005e0e 	bge	zero,r4,8211e70 <__adddf3+0x3bc>
 8211cf8:	10002b26 	beq	r2,zero,8211da8 <__adddf3+0x2f4>
 8211cfc:	0081ffc4 	movi	r2,2047
 8211d00:	80bf8b26 	beq	r16,r2,8211b30 <__adddf3+0x7c>
 8211d04:	4a402034 	orhi	r9,r9,128
 8211d08:	00800e04 	movi	r2,56
 8211d0c:	1100a40e 	bge	r2,r4,8211fa0 <__adddf3+0x4ec>
 8211d10:	498cb03a 	or	r6,r9,r6
 8211d14:	300ac03a 	cmpne	r5,r6,zero
 8211d18:	0013883a 	mov	r9,zero
 8211d1c:	2c4b883a 	add	r5,r5,r17
 8211d20:	2c63803a 	cmpltu	r17,r5,r17
 8211d24:	4a11883a 	add	r8,r9,r8
 8211d28:	8a11883a 	add	r8,r17,r8
 8211d2c:	2823883a 	mov	r17,r5
 8211d30:	4080202c 	andhi	r2,r8,128
 8211d34:	103fe026 	beq	r2,zero,8211cb8 <__adddf3+0x204>
 8211d38:	84000044 	addi	r16,r16,1
 8211d3c:	0081ffc4 	movi	r2,2047
 8211d40:	8080d226 	beq	r16,r2,821208c <__adddf3+0x5d8>
 8211d44:	00bfe034 	movhi	r2,65408
 8211d48:	10bfffc4 	addi	r2,r2,-1
 8211d4c:	4090703a 	and	r8,r8,r2
 8211d50:	880ad07a 	srli	r5,r17,1
 8211d54:	400897fa 	slli	r4,r8,31
 8211d58:	88c0004c 	andi	r3,r17,1
 8211d5c:	28e2b03a 	or	r17,r5,r3
 8211d60:	4010d07a 	srli	r8,r8,1
 8211d64:	2462b03a 	or	r17,r4,r17
 8211d68:	003f7106 	br	8211b30 <__adddf3+0x7c>
 8211d6c:	4088b03a 	or	r4,r8,r2
 8211d70:	20014526 	beq	r4,zero,8212288 <__adddf3+0x7d4>
 8211d74:	01000434 	movhi	r4,16
 8211d78:	42000234 	orhi	r8,r8,8
 8211d7c:	213fffc4 	addi	r4,r4,-1
 8211d80:	4110703a 	and	r8,r8,r4
 8211d84:	003f8206 	br	8211b90 <__adddf3+0xdc>
 8211d88:	18ffffc4 	addi	r3,r3,-1
 8211d8c:	1800491e 	bne	r3,zero,8211eb4 <__adddf3+0x400>
 8211d90:	898bc83a 	sub	r5,r17,r6
 8211d94:	8963803a 	cmpltu	r17,r17,r5
 8211d98:	4251c83a 	sub	r8,r8,r9
 8211d9c:	4451c83a 	sub	r8,r8,r17
 8211da0:	2823883a 	mov	r17,r5
 8211da4:	003f9f06 	br	8211c24 <__adddf3+0x170>
 8211da8:	4984b03a 	or	r2,r9,r6
 8211dac:	103f6026 	beq	r2,zero,8211b30 <__adddf3+0x7c>
 8211db0:	213fffc4 	addi	r4,r4,-1
 8211db4:	2000931e 	bne	r4,zero,8212004 <__adddf3+0x550>
 8211db8:	898d883a 	add	r6,r17,r6
 8211dbc:	3463803a 	cmpltu	r17,r6,r17
 8211dc0:	4251883a 	add	r8,r8,r9
 8211dc4:	8a11883a 	add	r8,r17,r8
 8211dc8:	3023883a 	mov	r17,r6
 8211dcc:	003fd806 	br	8211d30 <__adddf3+0x27c>
 8211dd0:	1800541e 	bne	r3,zero,8211f24 <__adddf3+0x470>
 8211dd4:	80800044 	addi	r2,r16,1
 8211dd8:	1081ffcc 	andi	r2,r2,2047
 8211ddc:	00c00044 	movi	r3,1
 8211de0:	1880a00e 	bge	r3,r2,8212064 <__adddf3+0x5b0>
 8211de4:	8989c83a 	sub	r4,r17,r6
 8211de8:	8905803a 	cmpltu	r2,r17,r4
 8211dec:	4267c83a 	sub	r19,r8,r9
 8211df0:	98a7c83a 	sub	r19,r19,r2
 8211df4:	9880202c 	andhi	r2,r19,128
 8211df8:	10006326 	beq	r2,zero,8211f88 <__adddf3+0x4d4>
 8211dfc:	3463c83a 	sub	r17,r6,r17
 8211e00:	4a07c83a 	sub	r3,r9,r8
 8211e04:	344d803a 	cmpltu	r6,r6,r17
 8211e08:	19a7c83a 	sub	r19,r3,r6
 8211e0c:	3825883a 	mov	r18,r7
 8211e10:	983f8a1e 	bne	r19,zero,8211c3c <__adddf3+0x188>
 8211e14:	8809883a 	mov	r4,r17
 8211e18:	82140b80 	call	82140b8 <__clzsi2>
 8211e1c:	10800804 	addi	r2,r2,32
 8211e20:	10fffe04 	addi	r3,r2,-8
 8211e24:	010007c4 	movi	r4,31
 8211e28:	20ff890e 	bge	r4,r3,8211c50 <__adddf3+0x19c>
 8211e2c:	10bff604 	addi	r2,r2,-40
 8211e30:	8884983a 	sll	r2,r17,r2
 8211e34:	0023883a 	mov	r17,zero
 8211e38:	1c3f8c0e 	bge	r3,r16,8211c6c <__adddf3+0x1b8>
 8211e3c:	023fe034 	movhi	r8,65408
 8211e40:	423fffc4 	addi	r8,r8,-1
 8211e44:	80e1c83a 	sub	r16,r16,r3
 8211e48:	1210703a 	and	r8,r2,r8
 8211e4c:	003f3806 	br	8211b30 <__adddf3+0x7c>
 8211e50:	9007883a 	mov	r3,r18
 8211e54:	0011883a 	mov	r8,zero
 8211e58:	0005883a 	mov	r2,zero
 8211e5c:	003f4c06 	br	8211b90 <__adddf3+0xdc>
 8211e60:	498cb03a 	or	r6,r9,r6
 8211e64:	300cc03a 	cmpne	r6,r6,zero
 8211e68:	0007883a 	mov	r3,zero
 8211e6c:	003f6806 	br	8211c10 <__adddf3+0x15c>
 8211e70:	20009c1e 	bne	r4,zero,82120e4 <__adddf3+0x630>
 8211e74:	80800044 	addi	r2,r16,1
 8211e78:	1141ffcc 	andi	r5,r2,2047
 8211e7c:	01000044 	movi	r4,1
 8211e80:	2140670e 	bge	r4,r5,8212020 <__adddf3+0x56c>
 8211e84:	0101ffc4 	movi	r4,2047
 8211e88:	11007f26 	beq	r2,r4,8212088 <__adddf3+0x5d4>
 8211e8c:	898d883a 	add	r6,r17,r6
 8211e90:	4247883a 	add	r3,r8,r9
 8211e94:	3451803a 	cmpltu	r8,r6,r17
 8211e98:	40d1883a 	add	r8,r8,r3
 8211e9c:	402297fa 	slli	r17,r8,31
 8211ea0:	300cd07a 	srli	r6,r6,1
 8211ea4:	4010d07a 	srli	r8,r8,1
 8211ea8:	1021883a 	mov	r16,r2
 8211eac:	89a2b03a 	or	r17,r17,r6
 8211eb0:	003f1f06 	br	8211b30 <__adddf3+0x7c>
 8211eb4:	0081ffc4 	movi	r2,2047
 8211eb8:	80bf481e 	bne	r16,r2,8211bdc <__adddf3+0x128>
 8211ebc:	003f1c06 	br	8211b30 <__adddf3+0x7c>
 8211ec0:	843ff844 	addi	r16,r16,-31
 8211ec4:	01000804 	movi	r4,32
 8211ec8:	1406d83a 	srl	r3,r2,r16
 8211ecc:	41005026 	beq	r8,r4,8212010 <__adddf3+0x55c>
 8211ed0:	01001004 	movi	r4,64
 8211ed4:	2211c83a 	sub	r8,r4,r8
 8211ed8:	1204983a 	sll	r2,r2,r8
 8211edc:	88a2b03a 	or	r17,r17,r2
 8211ee0:	8822c03a 	cmpne	r17,r17,zero
 8211ee4:	1c62b03a 	or	r17,r3,r17
 8211ee8:	0011883a 	mov	r8,zero
 8211eec:	0021883a 	mov	r16,zero
 8211ef0:	003f7106 	br	8211cb8 <__adddf3+0x204>
 8211ef4:	193ff804 	addi	r4,r3,-32
 8211ef8:	00800804 	movi	r2,32
 8211efc:	4908d83a 	srl	r4,r9,r4
 8211f00:	18804526 	beq	r3,r2,8212018 <__adddf3+0x564>
 8211f04:	00801004 	movi	r2,64
 8211f08:	10c5c83a 	sub	r2,r2,r3
 8211f0c:	4886983a 	sll	r3,r9,r2
 8211f10:	198cb03a 	or	r6,r3,r6
 8211f14:	300cc03a 	cmpne	r6,r6,zero
 8211f18:	218cb03a 	or	r6,r4,r6
 8211f1c:	0007883a 	mov	r3,zero
 8211f20:	003f3b06 	br	8211c10 <__adddf3+0x15c>
 8211f24:	80002a26 	beq	r16,zero,8211fd0 <__adddf3+0x51c>
 8211f28:	0101ffc4 	movi	r4,2047
 8211f2c:	11006826 	beq	r2,r4,82120d0 <__adddf3+0x61c>
 8211f30:	00c7c83a 	sub	r3,zero,r3
 8211f34:	42002034 	orhi	r8,r8,128
 8211f38:	01000e04 	movi	r4,56
 8211f3c:	20c07c16 	blt	r4,r3,8212130 <__adddf3+0x67c>
 8211f40:	010007c4 	movi	r4,31
 8211f44:	20c0da16 	blt	r4,r3,82122b0 <__adddf3+0x7fc>
 8211f48:	01000804 	movi	r4,32
 8211f4c:	20c9c83a 	sub	r4,r4,r3
 8211f50:	4114983a 	sll	r10,r8,r4
 8211f54:	88cad83a 	srl	r5,r17,r3
 8211f58:	8908983a 	sll	r4,r17,r4
 8211f5c:	40c6d83a 	srl	r3,r8,r3
 8211f60:	5162b03a 	or	r17,r10,r5
 8211f64:	2008c03a 	cmpne	r4,r4,zero
 8211f68:	8922b03a 	or	r17,r17,r4
 8211f6c:	3463c83a 	sub	r17,r6,r17
 8211f70:	48c7c83a 	sub	r3,r9,r3
 8211f74:	344d803a 	cmpltu	r6,r6,r17
 8211f78:	1991c83a 	sub	r8,r3,r6
 8211f7c:	1021883a 	mov	r16,r2
 8211f80:	3825883a 	mov	r18,r7
 8211f84:	003f2706 	br	8211c24 <__adddf3+0x170>
 8211f88:	24d0b03a 	or	r8,r4,r19
 8211f8c:	40001b1e 	bne	r8,zero,8211ffc <__adddf3+0x548>
 8211f90:	0005883a 	mov	r2,zero
 8211f94:	0007883a 	mov	r3,zero
 8211f98:	0021883a 	mov	r16,zero
 8211f9c:	003f4d06 	br	8211cd4 <__adddf3+0x220>
 8211fa0:	008007c4 	movi	r2,31
 8211fa4:	11003c16 	blt	r2,r4,8212098 <__adddf3+0x5e4>
 8211fa8:	00800804 	movi	r2,32
 8211fac:	1105c83a 	sub	r2,r2,r4
 8211fb0:	488e983a 	sll	r7,r9,r2
 8211fb4:	310ad83a 	srl	r5,r6,r4
 8211fb8:	3084983a 	sll	r2,r6,r2
 8211fbc:	4912d83a 	srl	r9,r9,r4
 8211fc0:	394ab03a 	or	r5,r7,r5
 8211fc4:	1004c03a 	cmpne	r2,r2,zero
 8211fc8:	288ab03a 	or	r5,r5,r2
 8211fcc:	003f5306 	br	8211d1c <__adddf3+0x268>
 8211fd0:	4448b03a 	or	r4,r8,r17
 8211fd4:	20003e26 	beq	r4,zero,82120d0 <__adddf3+0x61c>
 8211fd8:	00c6303a 	nor	r3,zero,r3
 8211fdc:	18003a1e 	bne	r3,zero,82120c8 <__adddf3+0x614>
 8211fe0:	3463c83a 	sub	r17,r6,r17
 8211fe4:	4a07c83a 	sub	r3,r9,r8
 8211fe8:	344d803a 	cmpltu	r6,r6,r17
 8211fec:	1991c83a 	sub	r8,r3,r6
 8211ff0:	1021883a 	mov	r16,r2
 8211ff4:	3825883a 	mov	r18,r7
 8211ff8:	003f0a06 	br	8211c24 <__adddf3+0x170>
 8211ffc:	2023883a 	mov	r17,r4
 8212000:	003f0d06 	br	8211c38 <__adddf3+0x184>
 8212004:	0081ffc4 	movi	r2,2047
 8212008:	80bf3f1e 	bne	r16,r2,8211d08 <__adddf3+0x254>
 821200c:	003ec806 	br	8211b30 <__adddf3+0x7c>
 8212010:	0005883a 	mov	r2,zero
 8212014:	003fb106 	br	8211edc <__adddf3+0x428>
 8212018:	0007883a 	mov	r3,zero
 821201c:	003fbc06 	br	8211f10 <__adddf3+0x45c>
 8212020:	4444b03a 	or	r2,r8,r17
 8212024:	8000871e 	bne	r16,zero,8212244 <__adddf3+0x790>
 8212028:	1000ba26 	beq	r2,zero,8212314 <__adddf3+0x860>
 821202c:	4984b03a 	or	r2,r9,r6
 8212030:	103ebf26 	beq	r2,zero,8211b30 <__adddf3+0x7c>
 8212034:	8985883a 	add	r2,r17,r6
 8212038:	4247883a 	add	r3,r8,r9
 821203c:	1451803a 	cmpltu	r8,r2,r17
 8212040:	40d1883a 	add	r8,r8,r3
 8212044:	40c0202c 	andhi	r3,r8,128
 8212048:	1023883a 	mov	r17,r2
 821204c:	183f1a26 	beq	r3,zero,8211cb8 <__adddf3+0x204>
 8212050:	00bfe034 	movhi	r2,65408
 8212054:	10bfffc4 	addi	r2,r2,-1
 8212058:	2021883a 	mov	r16,r4
 821205c:	4090703a 	and	r8,r8,r2
 8212060:	003eb306 	br	8211b30 <__adddf3+0x7c>
 8212064:	4444b03a 	or	r2,r8,r17
 8212068:	8000291e 	bne	r16,zero,8212110 <__adddf3+0x65c>
 821206c:	10004b1e 	bne	r2,zero,821219c <__adddf3+0x6e8>
 8212070:	4990b03a 	or	r8,r9,r6
 8212074:	40008b26 	beq	r8,zero,82122a4 <__adddf3+0x7f0>
 8212078:	4811883a 	mov	r8,r9
 821207c:	3023883a 	mov	r17,r6
 8212080:	3825883a 	mov	r18,r7
 8212084:	003eaa06 	br	8211b30 <__adddf3+0x7c>
 8212088:	1021883a 	mov	r16,r2
 821208c:	0011883a 	mov	r8,zero
 8212090:	0005883a 	mov	r2,zero
 8212094:	003f0f06 	br	8211cd4 <__adddf3+0x220>
 8212098:	217ff804 	addi	r5,r4,-32
 821209c:	00800804 	movi	r2,32
 82120a0:	494ad83a 	srl	r5,r9,r5
 82120a4:	20807d26 	beq	r4,r2,821229c <__adddf3+0x7e8>
 82120a8:	00801004 	movi	r2,64
 82120ac:	1109c83a 	sub	r4,r2,r4
 82120b0:	4912983a 	sll	r9,r9,r4
 82120b4:	498cb03a 	or	r6,r9,r6
 82120b8:	300cc03a 	cmpne	r6,r6,zero
 82120bc:	298ab03a 	or	r5,r5,r6
 82120c0:	0013883a 	mov	r9,zero
 82120c4:	003f1506 	br	8211d1c <__adddf3+0x268>
 82120c8:	0101ffc4 	movi	r4,2047
 82120cc:	113f9a1e 	bne	r2,r4,8211f38 <__adddf3+0x484>
 82120d0:	4811883a 	mov	r8,r9
 82120d4:	3023883a 	mov	r17,r6
 82120d8:	1021883a 	mov	r16,r2
 82120dc:	3825883a 	mov	r18,r7
 82120e0:	003e9306 	br	8211b30 <__adddf3+0x7c>
 82120e4:	8000161e 	bne	r16,zero,8212140 <__adddf3+0x68c>
 82120e8:	444ab03a 	or	r5,r8,r17
 82120ec:	28005126 	beq	r5,zero,8212234 <__adddf3+0x780>
 82120f0:	0108303a 	nor	r4,zero,r4
 82120f4:	20004d1e 	bne	r4,zero,821222c <__adddf3+0x778>
 82120f8:	89a3883a 	add	r17,r17,r6
 82120fc:	4253883a 	add	r9,r8,r9
 8212100:	898d803a 	cmpltu	r6,r17,r6
 8212104:	3251883a 	add	r8,r6,r9
 8212108:	1021883a 	mov	r16,r2
 821210c:	003f0806 	br	8211d30 <__adddf3+0x27c>
 8212110:	1000301e 	bne	r2,zero,82121d4 <__adddf3+0x720>
 8212114:	4984b03a 	or	r2,r9,r6
 8212118:	10007126 	beq	r2,zero,82122e0 <__adddf3+0x82c>
 821211c:	4811883a 	mov	r8,r9
 8212120:	3023883a 	mov	r17,r6
 8212124:	3825883a 	mov	r18,r7
 8212128:	0401ffc4 	movi	r16,2047
 821212c:	003e8006 	br	8211b30 <__adddf3+0x7c>
 8212130:	4462b03a 	or	r17,r8,r17
 8212134:	8822c03a 	cmpne	r17,r17,zero
 8212138:	0007883a 	mov	r3,zero
 821213c:	003f8b06 	br	8211f6c <__adddf3+0x4b8>
 8212140:	0141ffc4 	movi	r5,2047
 8212144:	11403b26 	beq	r2,r5,8212234 <__adddf3+0x780>
 8212148:	0109c83a 	sub	r4,zero,r4
 821214c:	42002034 	orhi	r8,r8,128
 8212150:	01400e04 	movi	r5,56
 8212154:	29006716 	blt	r5,r4,82122f4 <__adddf3+0x840>
 8212158:	014007c4 	movi	r5,31
 821215c:	29007016 	blt	r5,r4,8212320 <__adddf3+0x86c>
 8212160:	01400804 	movi	r5,32
 8212164:	290bc83a 	sub	r5,r5,r4
 8212168:	4154983a 	sll	r10,r8,r5
 821216c:	890ed83a 	srl	r7,r17,r4
 8212170:	894a983a 	sll	r5,r17,r5
 8212174:	4108d83a 	srl	r4,r8,r4
 8212178:	51e2b03a 	or	r17,r10,r7
 821217c:	280ac03a 	cmpne	r5,r5,zero
 8212180:	8962b03a 	or	r17,r17,r5
 8212184:	89a3883a 	add	r17,r17,r6
 8212188:	2253883a 	add	r9,r4,r9
 821218c:	898d803a 	cmpltu	r6,r17,r6
 8212190:	3251883a 	add	r8,r6,r9
 8212194:	1021883a 	mov	r16,r2
 8212198:	003ee506 	br	8211d30 <__adddf3+0x27c>
 821219c:	4984b03a 	or	r2,r9,r6
 82121a0:	103e6326 	beq	r2,zero,8211b30 <__adddf3+0x7c>
 82121a4:	8987c83a 	sub	r3,r17,r6
 82121a8:	88c9803a 	cmpltu	r4,r17,r3
 82121ac:	4245c83a 	sub	r2,r8,r9
 82121b0:	1105c83a 	sub	r2,r2,r4
 82121b4:	1100202c 	andhi	r4,r2,128
 82121b8:	203ebb26 	beq	r4,zero,8211ca8 <__adddf3+0x1f4>
 82121bc:	3463c83a 	sub	r17,r6,r17
 82121c0:	4a07c83a 	sub	r3,r9,r8
 82121c4:	344d803a 	cmpltu	r6,r6,r17
 82121c8:	1991c83a 	sub	r8,r3,r6
 82121cc:	3825883a 	mov	r18,r7
 82121d0:	003e5706 	br	8211b30 <__adddf3+0x7c>
 82121d4:	4984b03a 	or	r2,r9,r6
 82121d8:	10002e26 	beq	r2,zero,8212294 <__adddf3+0x7e0>
 82121dc:	4004d0fa 	srli	r2,r8,3
 82121e0:	8822d0fa 	srli	r17,r17,3
 82121e4:	4010977a 	slli	r8,r8,29
 82121e8:	10c0022c 	andhi	r3,r2,8
 82121ec:	4462b03a 	or	r17,r8,r17
 82121f0:	18000826 	beq	r3,zero,8212214 <__adddf3+0x760>
 82121f4:	4808d0fa 	srli	r4,r9,3
 82121f8:	20c0022c 	andhi	r3,r4,8
 82121fc:	1800051e 	bne	r3,zero,8212214 <__adddf3+0x760>
 8212200:	300cd0fa 	srli	r6,r6,3
 8212204:	4806977a 	slli	r3,r9,29
 8212208:	2005883a 	mov	r2,r4
 821220c:	3825883a 	mov	r18,r7
 8212210:	19a2b03a 	or	r17,r3,r6
 8212214:	8810d77a 	srli	r8,r17,29
 8212218:	100490fa 	slli	r2,r2,3
 821221c:	882290fa 	slli	r17,r17,3
 8212220:	0401ffc4 	movi	r16,2047
 8212224:	4090b03a 	or	r8,r8,r2
 8212228:	003e4106 	br	8211b30 <__adddf3+0x7c>
 821222c:	0141ffc4 	movi	r5,2047
 8212230:	117fc71e 	bne	r2,r5,8212150 <__adddf3+0x69c>
 8212234:	4811883a 	mov	r8,r9
 8212238:	3023883a 	mov	r17,r6
 821223c:	1021883a 	mov	r16,r2
 8212240:	003e3b06 	br	8211b30 <__adddf3+0x7c>
 8212244:	10002f26 	beq	r2,zero,8212304 <__adddf3+0x850>
 8212248:	4984b03a 	or	r2,r9,r6
 821224c:	10001126 	beq	r2,zero,8212294 <__adddf3+0x7e0>
 8212250:	4004d0fa 	srli	r2,r8,3
 8212254:	8822d0fa 	srli	r17,r17,3
 8212258:	4010977a 	slli	r8,r8,29
 821225c:	10c0022c 	andhi	r3,r2,8
 8212260:	4462b03a 	or	r17,r8,r17
 8212264:	183feb26 	beq	r3,zero,8212214 <__adddf3+0x760>
 8212268:	4808d0fa 	srli	r4,r9,3
 821226c:	20c0022c 	andhi	r3,r4,8
 8212270:	183fe81e 	bne	r3,zero,8212214 <__adddf3+0x760>
 8212274:	300cd0fa 	srli	r6,r6,3
 8212278:	4806977a 	slli	r3,r9,29
 821227c:	2005883a 	mov	r2,r4
 8212280:	19a2b03a 	or	r17,r3,r6
 8212284:	003fe306 	br	8212214 <__adddf3+0x760>
 8212288:	0011883a 	mov	r8,zero
 821228c:	0005883a 	mov	r2,zero
 8212290:	003e3f06 	br	8211b90 <__adddf3+0xdc>
 8212294:	0401ffc4 	movi	r16,2047
 8212298:	003e2506 	br	8211b30 <__adddf3+0x7c>
 821229c:	0013883a 	mov	r9,zero
 82122a0:	003f8406 	br	82120b4 <__adddf3+0x600>
 82122a4:	0005883a 	mov	r2,zero
 82122a8:	0007883a 	mov	r3,zero
 82122ac:	003e8906 	br	8211cd4 <__adddf3+0x220>
 82122b0:	197ff804 	addi	r5,r3,-32
 82122b4:	01000804 	movi	r4,32
 82122b8:	414ad83a 	srl	r5,r8,r5
 82122bc:	19002426 	beq	r3,r4,8212350 <__adddf3+0x89c>
 82122c0:	01001004 	movi	r4,64
 82122c4:	20c7c83a 	sub	r3,r4,r3
 82122c8:	40c6983a 	sll	r3,r8,r3
 82122cc:	1c46b03a 	or	r3,r3,r17
 82122d0:	1806c03a 	cmpne	r3,r3,zero
 82122d4:	28e2b03a 	or	r17,r5,r3
 82122d8:	0007883a 	mov	r3,zero
 82122dc:	003f2306 	br	8211f6c <__adddf3+0x4b8>
 82122e0:	0007883a 	mov	r3,zero
 82122e4:	5811883a 	mov	r8,r11
 82122e8:	00bfffc4 	movi	r2,-1
 82122ec:	0401ffc4 	movi	r16,2047
 82122f0:	003e7806 	br	8211cd4 <__adddf3+0x220>
 82122f4:	4462b03a 	or	r17,r8,r17
 82122f8:	8822c03a 	cmpne	r17,r17,zero
 82122fc:	0009883a 	mov	r4,zero
 8212300:	003fa006 	br	8212184 <__adddf3+0x6d0>
 8212304:	4811883a 	mov	r8,r9
 8212308:	3023883a 	mov	r17,r6
 821230c:	0401ffc4 	movi	r16,2047
 8212310:	003e0706 	br	8211b30 <__adddf3+0x7c>
 8212314:	4811883a 	mov	r8,r9
 8212318:	3023883a 	mov	r17,r6
 821231c:	003e0406 	br	8211b30 <__adddf3+0x7c>
 8212320:	21fff804 	addi	r7,r4,-32
 8212324:	01400804 	movi	r5,32
 8212328:	41ced83a 	srl	r7,r8,r7
 821232c:	21400a26 	beq	r4,r5,8212358 <__adddf3+0x8a4>
 8212330:	01401004 	movi	r5,64
 8212334:	2909c83a 	sub	r4,r5,r4
 8212338:	4108983a 	sll	r4,r8,r4
 821233c:	2448b03a 	or	r4,r4,r17
 8212340:	2008c03a 	cmpne	r4,r4,zero
 8212344:	3922b03a 	or	r17,r7,r4
 8212348:	0009883a 	mov	r4,zero
 821234c:	003f8d06 	br	8212184 <__adddf3+0x6d0>
 8212350:	0007883a 	mov	r3,zero
 8212354:	003fdd06 	br	82122cc <__adddf3+0x818>
 8212358:	0009883a 	mov	r4,zero
 821235c:	003ff706 	br	821233c <__adddf3+0x888>

08212360 <__divdf3>:
 8212360:	defff204 	addi	sp,sp,-56
 8212364:	dd400915 	stw	r21,36(sp)
 8212368:	282ad53a 	srli	r21,r5,20
 821236c:	dd000815 	stw	r20,32(sp)
 8212370:	2828d7fa 	srli	r20,r5,31
 8212374:	dc000415 	stw	r16,16(sp)
 8212378:	04000434 	movhi	r16,16
 821237c:	df000c15 	stw	fp,48(sp)
 8212380:	843fffc4 	addi	r16,r16,-1
 8212384:	dfc00d15 	stw	ra,52(sp)
 8212388:	ddc00b15 	stw	r23,44(sp)
 821238c:	dd800a15 	stw	r22,40(sp)
 8212390:	dcc00715 	stw	r19,28(sp)
 8212394:	dc800615 	stw	r18,24(sp)
 8212398:	dc400515 	stw	r17,20(sp)
 821239c:	ad41ffcc 	andi	r21,r21,2047
 82123a0:	2c20703a 	and	r16,r5,r16
 82123a4:	a7003fcc 	andi	fp,r20,255
 82123a8:	a8006126 	beq	r21,zero,8212530 <__divdf3+0x1d0>
 82123ac:	0081ffc4 	movi	r2,2047
 82123b0:	2025883a 	mov	r18,r4
 82123b4:	a8803726 	beq	r21,r2,8212494 <__divdf3+0x134>
 82123b8:	80800434 	orhi	r2,r16,16
 82123bc:	100490fa 	slli	r2,r2,3
 82123c0:	2020d77a 	srli	r16,r4,29
 82123c4:	202490fa 	slli	r18,r4,3
 82123c8:	ad7f0044 	addi	r21,r21,-1023
 82123cc:	80a0b03a 	or	r16,r16,r2
 82123d0:	0027883a 	mov	r19,zero
 82123d4:	0013883a 	mov	r9,zero
 82123d8:	3804d53a 	srli	r2,r7,20
 82123dc:	382cd7fa 	srli	r22,r7,31
 82123e0:	04400434 	movhi	r17,16
 82123e4:	8c7fffc4 	addi	r17,r17,-1
 82123e8:	1081ffcc 	andi	r2,r2,2047
 82123ec:	3011883a 	mov	r8,r6
 82123f0:	3c62703a 	and	r17,r7,r17
 82123f4:	b5c03fcc 	andi	r23,r22,255
 82123f8:	10006c26 	beq	r2,zero,82125ac <__divdf3+0x24c>
 82123fc:	00c1ffc4 	movi	r3,2047
 8212400:	10c06426 	beq	r2,r3,8212594 <__divdf3+0x234>
 8212404:	88c00434 	orhi	r3,r17,16
 8212408:	180690fa 	slli	r3,r3,3
 821240c:	3022d77a 	srli	r17,r6,29
 8212410:	301090fa 	slli	r8,r6,3
 8212414:	10bf0044 	addi	r2,r2,-1023
 8212418:	88e2b03a 	or	r17,r17,r3
 821241c:	000f883a 	mov	r7,zero
 8212420:	a58cf03a 	xor	r6,r20,r22
 8212424:	3cc8b03a 	or	r4,r7,r19
 8212428:	a8abc83a 	sub	r21,r21,r2
 821242c:	008003c4 	movi	r2,15
 8212430:	3007883a 	mov	r3,r6
 8212434:	34c03fcc 	andi	r19,r6,255
 8212438:	11009036 	bltu	r2,r4,821267c <__divdf3+0x31c>
 821243c:	200890ba 	slli	r4,r4,2
 8212440:	00820874 	movhi	r2,2081
 8212444:	10891504 	addi	r2,r2,9300
 8212448:	2089883a 	add	r4,r4,r2
 821244c:	20800017 	ldw	r2,0(r4)
 8212450:	1000683a 	jmp	r2
 8212454:	0821267c 	xorhi	zero,at,33945
 8212458:	082124cc 	andi	zero,at,33939
 821245c:	0821266c 	andhi	zero,at,33945
 8212460:	082124c0 	call	82124c <OSCtxSw_SWITCH_PC+0x82120c>
 8212464:	0821266c 	andhi	zero,at,33945
 8212468:	08212640 	call	821264 <OSCtxSw_SWITCH_PC+0x821224>
 821246c:	0821266c 	andhi	zero,at,33945
 8212470:	082124c0 	call	82124c <OSCtxSw_SWITCH_PC+0x82120c>
 8212474:	082124cc 	andi	zero,at,33939
 8212478:	082124cc 	andi	zero,at,33939
 821247c:	08212640 	call	821264 <OSCtxSw_SWITCH_PC+0x821224>
 8212480:	082124c0 	call	82124c <OSCtxSw_SWITCH_PC+0x82120c>
 8212484:	082124b0 	cmpltui	zero,at,33938
 8212488:	082124b0 	cmpltui	zero,at,33938
 821248c:	082124b0 	cmpltui	zero,at,33938
 8212490:	08212960 	cmpeqi	zero,at,-31579
 8212494:	2404b03a 	or	r2,r4,r16
 8212498:	1000661e 	bne	r2,zero,8212634 <__divdf3+0x2d4>
 821249c:	04c00204 	movi	r19,8
 82124a0:	0021883a 	mov	r16,zero
 82124a4:	0025883a 	mov	r18,zero
 82124a8:	02400084 	movi	r9,2
 82124ac:	003fca06 	br	82123d8 <__divdf3+0x78>
 82124b0:	8023883a 	mov	r17,r16
 82124b4:	9011883a 	mov	r8,r18
 82124b8:	e02f883a 	mov	r23,fp
 82124bc:	480f883a 	mov	r7,r9
 82124c0:	00800084 	movi	r2,2
 82124c4:	3881311e 	bne	r7,r2,821298c <__divdf3+0x62c>
 82124c8:	b827883a 	mov	r19,r23
 82124cc:	98c0004c 	andi	r3,r19,1
 82124d0:	0081ffc4 	movi	r2,2047
 82124d4:	000b883a 	mov	r5,zero
 82124d8:	0025883a 	mov	r18,zero
 82124dc:	1004953a 	slli	r2,r2,20
 82124e0:	18c03fcc 	andi	r3,r3,255
 82124e4:	04400434 	movhi	r17,16
 82124e8:	8c7fffc4 	addi	r17,r17,-1
 82124ec:	180697fa 	slli	r3,r3,31
 82124f0:	2c4a703a 	and	r5,r5,r17
 82124f4:	288ab03a 	or	r5,r5,r2
 82124f8:	28c6b03a 	or	r3,r5,r3
 82124fc:	9005883a 	mov	r2,r18
 8212500:	dfc00d17 	ldw	ra,52(sp)
 8212504:	df000c17 	ldw	fp,48(sp)
 8212508:	ddc00b17 	ldw	r23,44(sp)
 821250c:	dd800a17 	ldw	r22,40(sp)
 8212510:	dd400917 	ldw	r21,36(sp)
 8212514:	dd000817 	ldw	r20,32(sp)
 8212518:	dcc00717 	ldw	r19,28(sp)
 821251c:	dc800617 	ldw	r18,24(sp)
 8212520:	dc400517 	ldw	r17,20(sp)
 8212524:	dc000417 	ldw	r16,16(sp)
 8212528:	dec00e04 	addi	sp,sp,56
 821252c:	f800283a 	ret
 8212530:	2404b03a 	or	r2,r4,r16
 8212534:	2027883a 	mov	r19,r4
 8212538:	10003926 	beq	r2,zero,8212620 <__divdf3+0x2c0>
 821253c:	80012e26 	beq	r16,zero,82129f8 <__divdf3+0x698>
 8212540:	8009883a 	mov	r4,r16
 8212544:	d9800315 	stw	r6,12(sp)
 8212548:	d9c00215 	stw	r7,8(sp)
 821254c:	82140b80 	call	82140b8 <__clzsi2>
 8212550:	d9800317 	ldw	r6,12(sp)
 8212554:	d9c00217 	ldw	r7,8(sp)
 8212558:	113ffd44 	addi	r4,r2,-11
 821255c:	00c00704 	movi	r3,28
 8212560:	19012116 	blt	r3,r4,82129e8 <__divdf3+0x688>
 8212564:	00c00744 	movi	r3,29
 8212568:	147ffe04 	addi	r17,r2,-8
 821256c:	1907c83a 	sub	r3,r3,r4
 8212570:	8460983a 	sll	r16,r16,r17
 8212574:	98c6d83a 	srl	r3,r19,r3
 8212578:	9c64983a 	sll	r18,r19,r17
 821257c:	1c20b03a 	or	r16,r3,r16
 8212580:	1080fcc4 	addi	r2,r2,1011
 8212584:	00abc83a 	sub	r21,zero,r2
 8212588:	0027883a 	mov	r19,zero
 821258c:	0013883a 	mov	r9,zero
 8212590:	003f9106 	br	82123d8 <__divdf3+0x78>
 8212594:	3446b03a 	or	r3,r6,r17
 8212598:	18001f1e 	bne	r3,zero,8212618 <__divdf3+0x2b8>
 821259c:	0023883a 	mov	r17,zero
 82125a0:	0011883a 	mov	r8,zero
 82125a4:	01c00084 	movi	r7,2
 82125a8:	003f9d06 	br	8212420 <__divdf3+0xc0>
 82125ac:	3446b03a 	or	r3,r6,r17
 82125b0:	18001526 	beq	r3,zero,8212608 <__divdf3+0x2a8>
 82125b4:	88011b26 	beq	r17,zero,8212a24 <__divdf3+0x6c4>
 82125b8:	8809883a 	mov	r4,r17
 82125bc:	d9800315 	stw	r6,12(sp)
 82125c0:	da400115 	stw	r9,4(sp)
 82125c4:	82140b80 	call	82140b8 <__clzsi2>
 82125c8:	d9800317 	ldw	r6,12(sp)
 82125cc:	da400117 	ldw	r9,4(sp)
 82125d0:	113ffd44 	addi	r4,r2,-11
 82125d4:	00c00704 	movi	r3,28
 82125d8:	19010e16 	blt	r3,r4,8212a14 <__divdf3+0x6b4>
 82125dc:	00c00744 	movi	r3,29
 82125e0:	123ffe04 	addi	r8,r2,-8
 82125e4:	1907c83a 	sub	r3,r3,r4
 82125e8:	8a22983a 	sll	r17,r17,r8
 82125ec:	30c6d83a 	srl	r3,r6,r3
 82125f0:	3210983a 	sll	r8,r6,r8
 82125f4:	1c62b03a 	or	r17,r3,r17
 82125f8:	1080fcc4 	addi	r2,r2,1011
 82125fc:	0085c83a 	sub	r2,zero,r2
 8212600:	000f883a 	mov	r7,zero
 8212604:	003f8606 	br	8212420 <__divdf3+0xc0>
 8212608:	0023883a 	mov	r17,zero
 821260c:	0011883a 	mov	r8,zero
 8212610:	01c00044 	movi	r7,1
 8212614:	003f8206 	br	8212420 <__divdf3+0xc0>
 8212618:	01c000c4 	movi	r7,3
 821261c:	003f8006 	br	8212420 <__divdf3+0xc0>
 8212620:	04c00104 	movi	r19,4
 8212624:	0021883a 	mov	r16,zero
 8212628:	0025883a 	mov	r18,zero
 821262c:	02400044 	movi	r9,1
 8212630:	003f6906 	br	82123d8 <__divdf3+0x78>
 8212634:	04c00304 	movi	r19,12
 8212638:	024000c4 	movi	r9,3
 821263c:	003f6606 	br	82123d8 <__divdf3+0x78>
 8212640:	01400434 	movhi	r5,16
 8212644:	0007883a 	mov	r3,zero
 8212648:	297fffc4 	addi	r5,r5,-1
 821264c:	04bfffc4 	movi	r18,-1
 8212650:	0081ffc4 	movi	r2,2047
 8212654:	003fa106 	br	82124dc <__divdf3+0x17c>
 8212658:	00c00044 	movi	r3,1
 821265c:	1887c83a 	sub	r3,r3,r2
 8212660:	01000e04 	movi	r4,56
 8212664:	20c1210e 	bge	r4,r3,8212aec <__divdf3+0x78c>
 8212668:	98c0004c 	andi	r3,r19,1
 821266c:	0005883a 	mov	r2,zero
 8212670:	000b883a 	mov	r5,zero
 8212674:	0025883a 	mov	r18,zero
 8212678:	003f9806 	br	82124dc <__divdf3+0x17c>
 821267c:	8c00fd36 	bltu	r17,r16,8212a74 <__divdf3+0x714>
 8212680:	8440fb26 	beq	r16,r17,8212a70 <__divdf3+0x710>
 8212684:	8007883a 	mov	r3,r16
 8212688:	ad7fffc4 	addi	r21,r21,-1
 821268c:	0021883a 	mov	r16,zero
 8212690:	4004d63a 	srli	r2,r8,24
 8212694:	8822923a 	slli	r17,r17,8
 8212698:	1809883a 	mov	r4,r3
 821269c:	402c923a 	slli	r22,r8,8
 82126a0:	88b8b03a 	or	fp,r17,r2
 82126a4:	e028d43a 	srli	r20,fp,16
 82126a8:	d8c00015 	stw	r3,0(sp)
 82126ac:	e5ffffcc 	andi	r23,fp,65535
 82126b0:	a00b883a 	mov	r5,r20
 82126b4:	820295c0 	call	820295c <__udivsi3>
 82126b8:	d8c00017 	ldw	r3,0(sp)
 82126bc:	a00b883a 	mov	r5,r20
 82126c0:	d8800315 	stw	r2,12(sp)
 82126c4:	1809883a 	mov	r4,r3
 82126c8:	82029c00 	call	82029c0 <__umodsi3>
 82126cc:	d9800317 	ldw	r6,12(sp)
 82126d0:	1006943a 	slli	r3,r2,16
 82126d4:	9004d43a 	srli	r2,r18,16
 82126d8:	b9a3383a 	mul	r17,r23,r6
 82126dc:	10c4b03a 	or	r2,r2,r3
 82126e0:	1440062e 	bgeu	r2,r17,82126fc <__divdf3+0x39c>
 82126e4:	1705883a 	add	r2,r2,fp
 82126e8:	30ffffc4 	addi	r3,r6,-1
 82126ec:	1700ee36 	bltu	r2,fp,8212aa8 <__divdf3+0x748>
 82126f0:	1440ed2e 	bgeu	r2,r17,8212aa8 <__divdf3+0x748>
 82126f4:	31bfff84 	addi	r6,r6,-2
 82126f8:	1705883a 	add	r2,r2,fp
 82126fc:	1463c83a 	sub	r17,r2,r17
 8212700:	a00b883a 	mov	r5,r20
 8212704:	8809883a 	mov	r4,r17
 8212708:	d9800315 	stw	r6,12(sp)
 821270c:	820295c0 	call	820295c <__udivsi3>
 8212710:	a00b883a 	mov	r5,r20
 8212714:	8809883a 	mov	r4,r17
 8212718:	d8800215 	stw	r2,8(sp)
 821271c:	82029c00 	call	82029c0 <__umodsi3>
 8212720:	d9c00217 	ldw	r7,8(sp)
 8212724:	1004943a 	slli	r2,r2,16
 8212728:	94bfffcc 	andi	r18,r18,65535
 821272c:	b9d1383a 	mul	r8,r23,r7
 8212730:	90a4b03a 	or	r18,r18,r2
 8212734:	d9800317 	ldw	r6,12(sp)
 8212738:	9200062e 	bgeu	r18,r8,8212754 <__divdf3+0x3f4>
 821273c:	9725883a 	add	r18,r18,fp
 8212740:	38bfffc4 	addi	r2,r7,-1
 8212744:	9700d636 	bltu	r18,fp,8212aa0 <__divdf3+0x740>
 8212748:	9200d52e 	bgeu	r18,r8,8212aa0 <__divdf3+0x740>
 821274c:	39ffff84 	addi	r7,r7,-2
 8212750:	9725883a 	add	r18,r18,fp
 8212754:	3004943a 	slli	r2,r6,16
 8212758:	b012d43a 	srli	r9,r22,16
 821275c:	b1bfffcc 	andi	r6,r22,65535
 8212760:	11e2b03a 	or	r17,r2,r7
 8212764:	8806d43a 	srli	r3,r17,16
 8212768:	893fffcc 	andi	r4,r17,65535
 821276c:	218b383a 	mul	r5,r4,r6
 8212770:	30c5383a 	mul	r2,r6,r3
 8212774:	2249383a 	mul	r4,r4,r9
 8212778:	280ed43a 	srli	r7,r5,16
 821277c:	9225c83a 	sub	r18,r18,r8
 8212780:	2089883a 	add	r4,r4,r2
 8212784:	3909883a 	add	r4,r7,r4
 8212788:	1a47383a 	mul	r3,r3,r9
 821278c:	2080022e 	bgeu	r4,r2,8212798 <__divdf3+0x438>
 8212790:	00800074 	movhi	r2,1
 8212794:	1887883a 	add	r3,r3,r2
 8212798:	2004d43a 	srli	r2,r4,16
 821279c:	2008943a 	slli	r4,r4,16
 82127a0:	297fffcc 	andi	r5,r5,65535
 82127a4:	10c7883a 	add	r3,r2,r3
 82127a8:	2149883a 	add	r4,r4,r5
 82127ac:	90c0a536 	bltu	r18,r3,8212a44 <__divdf3+0x6e4>
 82127b0:	90c0bf26 	beq	r18,r3,8212ab0 <__divdf3+0x750>
 82127b4:	90c7c83a 	sub	r3,r18,r3
 82127b8:	810fc83a 	sub	r7,r16,r4
 82127bc:	81e5803a 	cmpltu	r18,r16,r7
 82127c0:	1ca5c83a 	sub	r18,r3,r18
 82127c4:	e480c126 	beq	fp,r18,8212acc <__divdf3+0x76c>
 82127c8:	a00b883a 	mov	r5,r20
 82127cc:	9009883a 	mov	r4,r18
 82127d0:	d9800315 	stw	r6,12(sp)
 82127d4:	d9c00215 	stw	r7,8(sp)
 82127d8:	da400115 	stw	r9,4(sp)
 82127dc:	820295c0 	call	820295c <__udivsi3>
 82127e0:	a00b883a 	mov	r5,r20
 82127e4:	9009883a 	mov	r4,r18
 82127e8:	d8800015 	stw	r2,0(sp)
 82127ec:	82029c00 	call	82029c0 <__umodsi3>
 82127f0:	d9c00217 	ldw	r7,8(sp)
 82127f4:	da000017 	ldw	r8,0(sp)
 82127f8:	1006943a 	slli	r3,r2,16
 82127fc:	3804d43a 	srli	r2,r7,16
 8212800:	ba21383a 	mul	r16,r23,r8
 8212804:	d9800317 	ldw	r6,12(sp)
 8212808:	10c4b03a 	or	r2,r2,r3
 821280c:	da400117 	ldw	r9,4(sp)
 8212810:	1400062e 	bgeu	r2,r16,821282c <__divdf3+0x4cc>
 8212814:	1705883a 	add	r2,r2,fp
 8212818:	40ffffc4 	addi	r3,r8,-1
 821281c:	1700ad36 	bltu	r2,fp,8212ad4 <__divdf3+0x774>
 8212820:	1400ac2e 	bgeu	r2,r16,8212ad4 <__divdf3+0x774>
 8212824:	423fff84 	addi	r8,r8,-2
 8212828:	1705883a 	add	r2,r2,fp
 821282c:	1421c83a 	sub	r16,r2,r16
 8212830:	a00b883a 	mov	r5,r20
 8212834:	8009883a 	mov	r4,r16
 8212838:	d9800315 	stw	r6,12(sp)
 821283c:	d9c00215 	stw	r7,8(sp)
 8212840:	da000015 	stw	r8,0(sp)
 8212844:	da400115 	stw	r9,4(sp)
 8212848:	820295c0 	call	820295c <__udivsi3>
 821284c:	8009883a 	mov	r4,r16
 8212850:	a00b883a 	mov	r5,r20
 8212854:	1025883a 	mov	r18,r2
 8212858:	82029c00 	call	82029c0 <__umodsi3>
 821285c:	d9c00217 	ldw	r7,8(sp)
 8212860:	1004943a 	slli	r2,r2,16
 8212864:	bcaf383a 	mul	r23,r23,r18
 8212868:	393fffcc 	andi	r4,r7,65535
 821286c:	2088b03a 	or	r4,r4,r2
 8212870:	d9800317 	ldw	r6,12(sp)
 8212874:	da000017 	ldw	r8,0(sp)
 8212878:	da400117 	ldw	r9,4(sp)
 821287c:	25c0062e 	bgeu	r4,r23,8212898 <__divdf3+0x538>
 8212880:	2709883a 	add	r4,r4,fp
 8212884:	90bfffc4 	addi	r2,r18,-1
 8212888:	27009436 	bltu	r4,fp,8212adc <__divdf3+0x77c>
 821288c:	25c0932e 	bgeu	r4,r23,8212adc <__divdf3+0x77c>
 8212890:	94bfff84 	addi	r18,r18,-2
 8212894:	2709883a 	add	r4,r4,fp
 8212898:	4004943a 	slli	r2,r8,16
 821289c:	25efc83a 	sub	r23,r4,r23
 82128a0:	1490b03a 	or	r8,r2,r18
 82128a4:	4008d43a 	srli	r4,r8,16
 82128a8:	40ffffcc 	andi	r3,r8,65535
 82128ac:	30c5383a 	mul	r2,r6,r3
 82128b0:	1a47383a 	mul	r3,r3,r9
 82128b4:	310d383a 	mul	r6,r6,r4
 82128b8:	100ad43a 	srli	r5,r2,16
 82128bc:	4913383a 	mul	r9,r9,r4
 82128c0:	1987883a 	add	r3,r3,r6
 82128c4:	28c7883a 	add	r3,r5,r3
 82128c8:	1980022e 	bgeu	r3,r6,82128d4 <__divdf3+0x574>
 82128cc:	01000074 	movhi	r4,1
 82128d0:	4913883a 	add	r9,r9,r4
 82128d4:	1808d43a 	srli	r4,r3,16
 82128d8:	1806943a 	slli	r3,r3,16
 82128dc:	10bfffcc 	andi	r2,r2,65535
 82128e0:	2253883a 	add	r9,r4,r9
 82128e4:	1887883a 	add	r3,r3,r2
 82128e8:	ba403836 	bltu	r23,r9,82129cc <__divdf3+0x66c>
 82128ec:	ba403626 	beq	r23,r9,82129c8 <__divdf3+0x668>
 82128f0:	42000054 	ori	r8,r8,1
 82128f4:	a880ffc4 	addi	r2,r21,1023
 82128f8:	00bf570e 	bge	zero,r2,8212658 <__divdf3+0x2f8>
 82128fc:	40c001cc 	andi	r3,r8,7
 8212900:	18000726 	beq	r3,zero,8212920 <__divdf3+0x5c0>
 8212904:	40c003cc 	andi	r3,r8,15
 8212908:	01000104 	movi	r4,4
 821290c:	19000426 	beq	r3,r4,8212920 <__divdf3+0x5c0>
 8212910:	4107883a 	add	r3,r8,r4
 8212914:	1a11803a 	cmpltu	r8,r3,r8
 8212918:	8a23883a 	add	r17,r17,r8
 821291c:	1811883a 	mov	r8,r3
 8212920:	88c0402c 	andhi	r3,r17,256
 8212924:	18000426 	beq	r3,zero,8212938 <__divdf3+0x5d8>
 8212928:	00ffc034 	movhi	r3,65280
 821292c:	18ffffc4 	addi	r3,r3,-1
 8212930:	a8810004 	addi	r2,r21,1024
 8212934:	88e2703a 	and	r17,r17,r3
 8212938:	00c1ff84 	movi	r3,2046
 821293c:	18bee316 	blt	r3,r2,82124cc <__divdf3+0x16c>
 8212940:	8824977a 	slli	r18,r17,29
 8212944:	4010d0fa 	srli	r8,r8,3
 8212948:	8822927a 	slli	r17,r17,9
 821294c:	1081ffcc 	andi	r2,r2,2047
 8212950:	9224b03a 	or	r18,r18,r8
 8212954:	880ad33a 	srli	r5,r17,12
 8212958:	98c0004c 	andi	r3,r19,1
 821295c:	003edf06 	br	82124dc <__divdf3+0x17c>
 8212960:	8080022c 	andhi	r2,r16,8
 8212964:	10001226 	beq	r2,zero,82129b0 <__divdf3+0x650>
 8212968:	8880022c 	andhi	r2,r17,8
 821296c:	1000101e 	bne	r2,zero,82129b0 <__divdf3+0x650>
 8212970:	00800434 	movhi	r2,16
 8212974:	89400234 	orhi	r5,r17,8
 8212978:	10bfffc4 	addi	r2,r2,-1
 821297c:	b007883a 	mov	r3,r22
 8212980:	288a703a 	and	r5,r5,r2
 8212984:	4025883a 	mov	r18,r8
 8212988:	003f3106 	br	8212650 <__divdf3+0x2f0>
 821298c:	008000c4 	movi	r2,3
 8212990:	3880a626 	beq	r7,r2,8212c2c <__divdf3+0x8cc>
 8212994:	00800044 	movi	r2,1
 8212998:	3880521e 	bne	r7,r2,8212ae4 <__divdf3+0x784>
 821299c:	b807883a 	mov	r3,r23
 82129a0:	0005883a 	mov	r2,zero
 82129a4:	000b883a 	mov	r5,zero
 82129a8:	0025883a 	mov	r18,zero
 82129ac:	003ecb06 	br	82124dc <__divdf3+0x17c>
 82129b0:	00800434 	movhi	r2,16
 82129b4:	81400234 	orhi	r5,r16,8
 82129b8:	10bfffc4 	addi	r2,r2,-1
 82129bc:	a007883a 	mov	r3,r20
 82129c0:	288a703a 	and	r5,r5,r2
 82129c4:	003f2206 	br	8212650 <__divdf3+0x2f0>
 82129c8:	183fca26 	beq	r3,zero,82128f4 <__divdf3+0x594>
 82129cc:	e5ef883a 	add	r23,fp,r23
 82129d0:	40bfffc4 	addi	r2,r8,-1
 82129d4:	bf00392e 	bgeu	r23,fp,8212abc <__divdf3+0x75c>
 82129d8:	1011883a 	mov	r8,r2
 82129dc:	ba7fc41e 	bne	r23,r9,82128f0 <__divdf3+0x590>
 82129e0:	b0ffc31e 	bne	r22,r3,82128f0 <__divdf3+0x590>
 82129e4:	003fc306 	br	82128f4 <__divdf3+0x594>
 82129e8:	143ff604 	addi	r16,r2,-40
 82129ec:	9c20983a 	sll	r16,r19,r16
 82129f0:	0025883a 	mov	r18,zero
 82129f4:	003ee206 	br	8212580 <__divdf3+0x220>
 82129f8:	d9800315 	stw	r6,12(sp)
 82129fc:	d9c00215 	stw	r7,8(sp)
 8212a00:	82140b80 	call	82140b8 <__clzsi2>
 8212a04:	10800804 	addi	r2,r2,32
 8212a08:	d9c00217 	ldw	r7,8(sp)
 8212a0c:	d9800317 	ldw	r6,12(sp)
 8212a10:	003ed106 	br	8212558 <__divdf3+0x1f8>
 8212a14:	147ff604 	addi	r17,r2,-40
 8212a18:	3462983a 	sll	r17,r6,r17
 8212a1c:	0011883a 	mov	r8,zero
 8212a20:	003ef506 	br	82125f8 <__divdf3+0x298>
 8212a24:	3009883a 	mov	r4,r6
 8212a28:	d9800315 	stw	r6,12(sp)
 8212a2c:	da400115 	stw	r9,4(sp)
 8212a30:	82140b80 	call	82140b8 <__clzsi2>
 8212a34:	10800804 	addi	r2,r2,32
 8212a38:	da400117 	ldw	r9,4(sp)
 8212a3c:	d9800317 	ldw	r6,12(sp)
 8212a40:	003ee306 	br	82125d0 <__divdf3+0x270>
 8212a44:	85a1883a 	add	r16,r16,r22
 8212a48:	8585803a 	cmpltu	r2,r16,r22
 8212a4c:	1705883a 	add	r2,r2,fp
 8212a50:	14a5883a 	add	r18,r2,r18
 8212a54:	88bfffc4 	addi	r2,r17,-1
 8212a58:	e4800c2e 	bgeu	fp,r18,8212a8c <__divdf3+0x72c>
 8212a5c:	90c03e36 	bltu	r18,r3,8212b58 <__divdf3+0x7f8>
 8212a60:	1c806926 	beq	r3,r18,8212c08 <__divdf3+0x8a8>
 8212a64:	90c7c83a 	sub	r3,r18,r3
 8212a68:	1023883a 	mov	r17,r2
 8212a6c:	003f5206 	br	82127b8 <__divdf3+0x458>
 8212a70:	923f0436 	bltu	r18,r8,8212684 <__divdf3+0x324>
 8212a74:	800897fa 	slli	r4,r16,31
 8212a78:	9004d07a 	srli	r2,r18,1
 8212a7c:	8006d07a 	srli	r3,r16,1
 8212a80:	902097fa 	slli	r16,r18,31
 8212a84:	20a4b03a 	or	r18,r4,r2
 8212a88:	003f0106 	br	8212690 <__divdf3+0x330>
 8212a8c:	e4bff51e 	bne	fp,r18,8212a64 <__divdf3+0x704>
 8212a90:	85bff22e 	bgeu	r16,r22,8212a5c <__divdf3+0x6fc>
 8212a94:	e0c7c83a 	sub	r3,fp,r3
 8212a98:	1023883a 	mov	r17,r2
 8212a9c:	003f4606 	br	82127b8 <__divdf3+0x458>
 8212aa0:	100f883a 	mov	r7,r2
 8212aa4:	003f2b06 	br	8212754 <__divdf3+0x3f4>
 8212aa8:	180d883a 	mov	r6,r3
 8212aac:	003f1306 	br	82126fc <__divdf3+0x39c>
 8212ab0:	813fe436 	bltu	r16,r4,8212a44 <__divdf3+0x6e4>
 8212ab4:	0007883a 	mov	r3,zero
 8212ab8:	003f3f06 	br	82127b8 <__divdf3+0x458>
 8212abc:	ba402c36 	bltu	r23,r9,8212b70 <__divdf3+0x810>
 8212ac0:	4dc05426 	beq	r9,r23,8212c14 <__divdf3+0x8b4>
 8212ac4:	1011883a 	mov	r8,r2
 8212ac8:	003f8906 	br	82128f0 <__divdf3+0x590>
 8212acc:	023fffc4 	movi	r8,-1
 8212ad0:	003f8806 	br	82128f4 <__divdf3+0x594>
 8212ad4:	1811883a 	mov	r8,r3
 8212ad8:	003f5406 	br	821282c <__divdf3+0x4cc>
 8212adc:	1025883a 	mov	r18,r2
 8212ae0:	003f6d06 	br	8212898 <__divdf3+0x538>
 8212ae4:	b827883a 	mov	r19,r23
 8212ae8:	003f8206 	br	82128f4 <__divdf3+0x594>
 8212aec:	010007c4 	movi	r4,31
 8212af0:	20c02616 	blt	r4,r3,8212b8c <__divdf3+0x82c>
 8212af4:	00800804 	movi	r2,32
 8212af8:	10c5c83a 	sub	r2,r2,r3
 8212afc:	888a983a 	sll	r5,r17,r2
 8212b00:	40c8d83a 	srl	r4,r8,r3
 8212b04:	4084983a 	sll	r2,r8,r2
 8212b08:	88e2d83a 	srl	r17,r17,r3
 8212b0c:	2906b03a 	or	r3,r5,r4
 8212b10:	1004c03a 	cmpne	r2,r2,zero
 8212b14:	1886b03a 	or	r3,r3,r2
 8212b18:	188001cc 	andi	r2,r3,7
 8212b1c:	10000726 	beq	r2,zero,8212b3c <__divdf3+0x7dc>
 8212b20:	188003cc 	andi	r2,r3,15
 8212b24:	01000104 	movi	r4,4
 8212b28:	11000426 	beq	r2,r4,8212b3c <__divdf3+0x7dc>
 8212b2c:	1805883a 	mov	r2,r3
 8212b30:	10c00104 	addi	r3,r2,4
 8212b34:	1885803a 	cmpltu	r2,r3,r2
 8212b38:	88a3883a 	add	r17,r17,r2
 8212b3c:	8880202c 	andhi	r2,r17,128
 8212b40:	10002726 	beq	r2,zero,8212be0 <__divdf3+0x880>
 8212b44:	98c0004c 	andi	r3,r19,1
 8212b48:	00800044 	movi	r2,1
 8212b4c:	000b883a 	mov	r5,zero
 8212b50:	0025883a 	mov	r18,zero
 8212b54:	003e6106 	br	82124dc <__divdf3+0x17c>
 8212b58:	85a1883a 	add	r16,r16,r22
 8212b5c:	8585803a 	cmpltu	r2,r16,r22
 8212b60:	1705883a 	add	r2,r2,fp
 8212b64:	14a5883a 	add	r18,r2,r18
 8212b68:	8c7fff84 	addi	r17,r17,-2
 8212b6c:	003f1106 	br	82127b4 <__divdf3+0x454>
 8212b70:	b589883a 	add	r4,r22,r22
 8212b74:	25ad803a 	cmpltu	r22,r4,r22
 8212b78:	b739883a 	add	fp,r22,fp
 8212b7c:	40bfff84 	addi	r2,r8,-2
 8212b80:	bf2f883a 	add	r23,r23,fp
 8212b84:	202d883a 	mov	r22,r4
 8212b88:	003f9306 	br	82129d8 <__divdf3+0x678>
 8212b8c:	013ff844 	movi	r4,-31
 8212b90:	2085c83a 	sub	r2,r4,r2
 8212b94:	8888d83a 	srl	r4,r17,r2
 8212b98:	00800804 	movi	r2,32
 8212b9c:	18802126 	beq	r3,r2,8212c24 <__divdf3+0x8c4>
 8212ba0:	00801004 	movi	r2,64
 8212ba4:	10c5c83a 	sub	r2,r2,r3
 8212ba8:	8884983a 	sll	r2,r17,r2
 8212bac:	1204b03a 	or	r2,r2,r8
 8212bb0:	1004c03a 	cmpne	r2,r2,zero
 8212bb4:	2084b03a 	or	r2,r4,r2
 8212bb8:	144001cc 	andi	r17,r2,7
 8212bbc:	88000d1e 	bne	r17,zero,8212bf4 <__divdf3+0x894>
 8212bc0:	000b883a 	mov	r5,zero
 8212bc4:	1024d0fa 	srli	r18,r2,3
 8212bc8:	98c0004c 	andi	r3,r19,1
 8212bcc:	0005883a 	mov	r2,zero
 8212bd0:	9464b03a 	or	r18,r18,r17
 8212bd4:	003e4106 	br	82124dc <__divdf3+0x17c>
 8212bd8:	1007883a 	mov	r3,r2
 8212bdc:	0023883a 	mov	r17,zero
 8212be0:	880a927a 	slli	r5,r17,9
 8212be4:	1805883a 	mov	r2,r3
 8212be8:	8822977a 	slli	r17,r17,29
 8212bec:	280ad33a 	srli	r5,r5,12
 8212bf0:	003ff406 	br	8212bc4 <__divdf3+0x864>
 8212bf4:	10c003cc 	andi	r3,r2,15
 8212bf8:	01000104 	movi	r4,4
 8212bfc:	193ff626 	beq	r3,r4,8212bd8 <__divdf3+0x878>
 8212c00:	0023883a 	mov	r17,zero
 8212c04:	003fca06 	br	8212b30 <__divdf3+0x7d0>
 8212c08:	813fd336 	bltu	r16,r4,8212b58 <__divdf3+0x7f8>
 8212c0c:	1023883a 	mov	r17,r2
 8212c10:	003fa806 	br	8212ab4 <__divdf3+0x754>
 8212c14:	b0ffd636 	bltu	r22,r3,8212b70 <__divdf3+0x810>
 8212c18:	1011883a 	mov	r8,r2
 8212c1c:	b0ff341e 	bne	r22,r3,82128f0 <__divdf3+0x590>
 8212c20:	003f3406 	br	82128f4 <__divdf3+0x594>
 8212c24:	0005883a 	mov	r2,zero
 8212c28:	003fe006 	br	8212bac <__divdf3+0x84c>
 8212c2c:	00800434 	movhi	r2,16
 8212c30:	89400234 	orhi	r5,r17,8
 8212c34:	10bfffc4 	addi	r2,r2,-1
 8212c38:	b807883a 	mov	r3,r23
 8212c3c:	288a703a 	and	r5,r5,r2
 8212c40:	4025883a 	mov	r18,r8
 8212c44:	003e8206 	br	8212650 <__divdf3+0x2f0>

08212c48 <__eqdf2>:
 8212c48:	2804d53a 	srli	r2,r5,20
 8212c4c:	3806d53a 	srli	r3,r7,20
 8212c50:	02000434 	movhi	r8,16
 8212c54:	423fffc4 	addi	r8,r8,-1
 8212c58:	1081ffcc 	andi	r2,r2,2047
 8212c5c:	0281ffc4 	movi	r10,2047
 8212c60:	2a12703a 	and	r9,r5,r8
 8212c64:	18c1ffcc 	andi	r3,r3,2047
 8212c68:	3a10703a 	and	r8,r7,r8
 8212c6c:	280ad7fa 	srli	r5,r5,31
 8212c70:	380ed7fa 	srli	r7,r7,31
 8212c74:	12801026 	beq	r2,r10,8212cb8 <__eqdf2+0x70>
 8212c78:	0281ffc4 	movi	r10,2047
 8212c7c:	1a800a26 	beq	r3,r10,8212ca8 <__eqdf2+0x60>
 8212c80:	10c00226 	beq	r2,r3,8212c8c <__eqdf2+0x44>
 8212c84:	00800044 	movi	r2,1
 8212c88:	f800283a 	ret
 8212c8c:	4a3ffd1e 	bne	r9,r8,8212c84 <__eqdf2+0x3c>
 8212c90:	21bffc1e 	bne	r4,r6,8212c84 <__eqdf2+0x3c>
 8212c94:	29c00c26 	beq	r5,r7,8212cc8 <__eqdf2+0x80>
 8212c98:	103ffa1e 	bne	r2,zero,8212c84 <__eqdf2+0x3c>
 8212c9c:	2244b03a 	or	r2,r4,r9
 8212ca0:	1004c03a 	cmpne	r2,r2,zero
 8212ca4:	f800283a 	ret
 8212ca8:	3214b03a 	or	r10,r6,r8
 8212cac:	503ff426 	beq	r10,zero,8212c80 <__eqdf2+0x38>
 8212cb0:	00800044 	movi	r2,1
 8212cb4:	f800283a 	ret
 8212cb8:	2254b03a 	or	r10,r4,r9
 8212cbc:	503fee26 	beq	r10,zero,8212c78 <__eqdf2+0x30>
 8212cc0:	00800044 	movi	r2,1
 8212cc4:	f800283a 	ret
 8212cc8:	0005883a 	mov	r2,zero
 8212ccc:	f800283a 	ret

08212cd0 <__gedf2>:
 8212cd0:	2804d53a 	srli	r2,r5,20
 8212cd4:	3806d53a 	srli	r3,r7,20
 8212cd8:	02000434 	movhi	r8,16
 8212cdc:	423fffc4 	addi	r8,r8,-1
 8212ce0:	1081ffcc 	andi	r2,r2,2047
 8212ce4:	0241ffc4 	movi	r9,2047
 8212ce8:	2a14703a 	and	r10,r5,r8
 8212cec:	18c1ffcc 	andi	r3,r3,2047
 8212cf0:	3a10703a 	and	r8,r7,r8
 8212cf4:	280ad7fa 	srli	r5,r5,31
 8212cf8:	380ed7fa 	srli	r7,r7,31
 8212cfc:	12401d26 	beq	r2,r9,8212d74 <__gedf2+0xa4>
 8212d00:	0241ffc4 	movi	r9,2047
 8212d04:	1a401226 	beq	r3,r9,8212d50 <__gedf2+0x80>
 8212d08:	1000081e 	bne	r2,zero,8212d2c <__gedf2+0x5c>
 8212d0c:	2296b03a 	or	r11,r4,r10
 8212d10:	5813003a 	cmpeq	r9,r11,zero
 8212d14:	1800091e 	bne	r3,zero,8212d3c <__gedf2+0x6c>
 8212d18:	3218b03a 	or	r12,r6,r8
 8212d1c:	6000071e 	bne	r12,zero,8212d3c <__gedf2+0x6c>
 8212d20:	0005883a 	mov	r2,zero
 8212d24:	5800101e 	bne	r11,zero,8212d68 <__gedf2+0x98>
 8212d28:	f800283a 	ret
 8212d2c:	18000c1e 	bne	r3,zero,8212d60 <__gedf2+0x90>
 8212d30:	3212b03a 	or	r9,r6,r8
 8212d34:	48000c26 	beq	r9,zero,8212d68 <__gedf2+0x98>
 8212d38:	0013883a 	mov	r9,zero
 8212d3c:	39c03fcc 	andi	r7,r7,255
 8212d40:	48000826 	beq	r9,zero,8212d64 <__gedf2+0x94>
 8212d44:	38000926 	beq	r7,zero,8212d6c <__gedf2+0x9c>
 8212d48:	00800044 	movi	r2,1
 8212d4c:	f800283a 	ret
 8212d50:	3212b03a 	or	r9,r6,r8
 8212d54:	483fec26 	beq	r9,zero,8212d08 <__gedf2+0x38>
 8212d58:	00bfff84 	movi	r2,-2
 8212d5c:	f800283a 	ret
 8212d60:	39c03fcc 	andi	r7,r7,255
 8212d64:	29c00626 	beq	r5,r7,8212d80 <__gedf2+0xb0>
 8212d68:	283ff726 	beq	r5,zero,8212d48 <__gedf2+0x78>
 8212d6c:	00bfffc4 	movi	r2,-1
 8212d70:	f800283a 	ret
 8212d74:	2292b03a 	or	r9,r4,r10
 8212d78:	483fe126 	beq	r9,zero,8212d00 <__gedf2+0x30>
 8212d7c:	003ff606 	br	8212d58 <__gedf2+0x88>
 8212d80:	18bff916 	blt	r3,r2,8212d68 <__gedf2+0x98>
 8212d84:	10c00316 	blt	r2,r3,8212d94 <__gedf2+0xc4>
 8212d88:	42bff736 	bltu	r8,r10,8212d68 <__gedf2+0x98>
 8212d8c:	52000326 	beq	r10,r8,8212d9c <__gedf2+0xcc>
 8212d90:	5200042e 	bgeu	r10,r8,8212da4 <__gedf2+0xd4>
 8212d94:	283fec1e 	bne	r5,zero,8212d48 <__gedf2+0x78>
 8212d98:	003ff406 	br	8212d6c <__gedf2+0x9c>
 8212d9c:	313ff236 	bltu	r6,r4,8212d68 <__gedf2+0x98>
 8212da0:	21bffc36 	bltu	r4,r6,8212d94 <__gedf2+0xc4>
 8212da4:	0005883a 	mov	r2,zero
 8212da8:	f800283a 	ret

08212dac <__ledf2>:
 8212dac:	2804d53a 	srli	r2,r5,20
 8212db0:	3810d53a 	srli	r8,r7,20
 8212db4:	00c00434 	movhi	r3,16
 8212db8:	18ffffc4 	addi	r3,r3,-1
 8212dbc:	1081ffcc 	andi	r2,r2,2047
 8212dc0:	0241ffc4 	movi	r9,2047
 8212dc4:	28d4703a 	and	r10,r5,r3
 8212dc8:	4201ffcc 	andi	r8,r8,2047
 8212dcc:	38c6703a 	and	r3,r7,r3
 8212dd0:	280ad7fa 	srli	r5,r5,31
 8212dd4:	380ed7fa 	srli	r7,r7,31
 8212dd8:	12401f26 	beq	r2,r9,8212e58 <__ledf2+0xac>
 8212ddc:	0241ffc4 	movi	r9,2047
 8212de0:	42401426 	beq	r8,r9,8212e34 <__ledf2+0x88>
 8212de4:	1000091e 	bne	r2,zero,8212e0c <__ledf2+0x60>
 8212de8:	2296b03a 	or	r11,r4,r10
 8212dec:	5813003a 	cmpeq	r9,r11,zero
 8212df0:	29403fcc 	andi	r5,r5,255
 8212df4:	40000a1e 	bne	r8,zero,8212e20 <__ledf2+0x74>
 8212df8:	30d8b03a 	or	r12,r6,r3
 8212dfc:	6000081e 	bne	r12,zero,8212e20 <__ledf2+0x74>
 8212e00:	0005883a 	mov	r2,zero
 8212e04:	5800111e 	bne	r11,zero,8212e4c <__ledf2+0xa0>
 8212e08:	f800283a 	ret
 8212e0c:	29403fcc 	andi	r5,r5,255
 8212e10:	40000c1e 	bne	r8,zero,8212e44 <__ledf2+0x98>
 8212e14:	30d2b03a 	or	r9,r6,r3
 8212e18:	48000c26 	beq	r9,zero,8212e4c <__ledf2+0xa0>
 8212e1c:	0013883a 	mov	r9,zero
 8212e20:	39c03fcc 	andi	r7,r7,255
 8212e24:	48000826 	beq	r9,zero,8212e48 <__ledf2+0x9c>
 8212e28:	38001126 	beq	r7,zero,8212e70 <__ledf2+0xc4>
 8212e2c:	00800044 	movi	r2,1
 8212e30:	f800283a 	ret
 8212e34:	30d2b03a 	or	r9,r6,r3
 8212e38:	483fea26 	beq	r9,zero,8212de4 <__ledf2+0x38>
 8212e3c:	00800084 	movi	r2,2
 8212e40:	f800283a 	ret
 8212e44:	39c03fcc 	andi	r7,r7,255
 8212e48:	39400726 	beq	r7,r5,8212e68 <__ledf2+0xbc>
 8212e4c:	2800081e 	bne	r5,zero,8212e70 <__ledf2+0xc4>
 8212e50:	00800044 	movi	r2,1
 8212e54:	f800283a 	ret
 8212e58:	2292b03a 	or	r9,r4,r10
 8212e5c:	483fdf26 	beq	r9,zero,8212ddc <__ledf2+0x30>
 8212e60:	00800084 	movi	r2,2
 8212e64:	f800283a 	ret
 8212e68:	4080030e 	bge	r8,r2,8212e78 <__ledf2+0xcc>
 8212e6c:	383fef26 	beq	r7,zero,8212e2c <__ledf2+0x80>
 8212e70:	00bfffc4 	movi	r2,-1
 8212e74:	f800283a 	ret
 8212e78:	123feb16 	blt	r2,r8,8212e28 <__ledf2+0x7c>
 8212e7c:	1abff336 	bltu	r3,r10,8212e4c <__ledf2+0xa0>
 8212e80:	50c00326 	beq	r10,r3,8212e90 <__ledf2+0xe4>
 8212e84:	50c0042e 	bgeu	r10,r3,8212e98 <__ledf2+0xec>
 8212e88:	283fe81e 	bne	r5,zero,8212e2c <__ledf2+0x80>
 8212e8c:	003ff806 	br	8212e70 <__ledf2+0xc4>
 8212e90:	313fee36 	bltu	r6,r4,8212e4c <__ledf2+0xa0>
 8212e94:	21bffc36 	bltu	r4,r6,8212e88 <__ledf2+0xdc>
 8212e98:	0005883a 	mov	r2,zero
 8212e9c:	f800283a 	ret

08212ea0 <__muldf3>:
 8212ea0:	defff304 	addi	sp,sp,-52
 8212ea4:	2804d53a 	srli	r2,r5,20
 8212ea8:	dd800915 	stw	r22,36(sp)
 8212eac:	282cd7fa 	srli	r22,r5,31
 8212eb0:	dc000315 	stw	r16,12(sp)
 8212eb4:	04000434 	movhi	r16,16
 8212eb8:	dd400815 	stw	r21,32(sp)
 8212ebc:	dc800515 	stw	r18,20(sp)
 8212ec0:	843fffc4 	addi	r16,r16,-1
 8212ec4:	dfc00c15 	stw	ra,48(sp)
 8212ec8:	df000b15 	stw	fp,44(sp)
 8212ecc:	ddc00a15 	stw	r23,40(sp)
 8212ed0:	dd000715 	stw	r20,28(sp)
 8212ed4:	dcc00615 	stw	r19,24(sp)
 8212ed8:	dc400415 	stw	r17,16(sp)
 8212edc:	1481ffcc 	andi	r18,r2,2047
 8212ee0:	2c20703a 	and	r16,r5,r16
 8212ee4:	b02b883a 	mov	r21,r22
 8212ee8:	b2403fcc 	andi	r9,r22,255
 8212eec:	90006026 	beq	r18,zero,8213070 <__muldf3+0x1d0>
 8212ef0:	0081ffc4 	movi	r2,2047
 8212ef4:	2029883a 	mov	r20,r4
 8212ef8:	90803626 	beq	r18,r2,8212fd4 <__muldf3+0x134>
 8212efc:	80800434 	orhi	r2,r16,16
 8212f00:	100490fa 	slli	r2,r2,3
 8212f04:	2020d77a 	srli	r16,r4,29
 8212f08:	202890fa 	slli	r20,r4,3
 8212f0c:	94bf0044 	addi	r18,r18,-1023
 8212f10:	80a0b03a 	or	r16,r16,r2
 8212f14:	0027883a 	mov	r19,zero
 8212f18:	0039883a 	mov	fp,zero
 8212f1c:	3804d53a 	srli	r2,r7,20
 8212f20:	382ed7fa 	srli	r23,r7,31
 8212f24:	04400434 	movhi	r17,16
 8212f28:	8c7fffc4 	addi	r17,r17,-1
 8212f2c:	1081ffcc 	andi	r2,r2,2047
 8212f30:	3011883a 	mov	r8,r6
 8212f34:	3c62703a 	and	r17,r7,r17
 8212f38:	ba803fcc 	andi	r10,r23,255
 8212f3c:	10006d26 	beq	r2,zero,82130f4 <__muldf3+0x254>
 8212f40:	00c1ffc4 	movi	r3,2047
 8212f44:	10c06526 	beq	r2,r3,82130dc <__muldf3+0x23c>
 8212f48:	88c00434 	orhi	r3,r17,16
 8212f4c:	180690fa 	slli	r3,r3,3
 8212f50:	3022d77a 	srli	r17,r6,29
 8212f54:	301090fa 	slli	r8,r6,3
 8212f58:	10bf0044 	addi	r2,r2,-1023
 8212f5c:	88e2b03a 	or	r17,r17,r3
 8212f60:	000b883a 	mov	r5,zero
 8212f64:	9085883a 	add	r2,r18,r2
 8212f68:	2cc8b03a 	or	r4,r5,r19
 8212f6c:	00c003c4 	movi	r3,15
 8212f70:	bdacf03a 	xor	r22,r23,r22
 8212f74:	12c00044 	addi	r11,r2,1
 8212f78:	19009936 	bltu	r3,r4,82131e0 <__muldf3+0x340>
 8212f7c:	200890ba 	slli	r4,r4,2
 8212f80:	00c20874 	movhi	r3,2081
 8212f84:	18cbe504 	addi	r3,r3,12180
 8212f88:	20c9883a 	add	r4,r4,r3
 8212f8c:	20c00017 	ldw	r3,0(r4)
 8212f90:	1800683a 	jmp	r3
 8212f94:	082131e0 	cmpeqi	zero,at,-31545
 8212f98:	08212ff4 	orhi	zero,at,33983
 8212f9c:	08212ff4 	orhi	zero,at,33983
 8212fa0:	08212ff0 	cmpltui	zero,at,33983
 8212fa4:	082131bc 	xorhi	zero,at,33990
 8212fa8:	082131bc 	xorhi	zero,at,33990
 8212fac:	082131a4 	muli	zero,at,-31546
 8212fb0:	08212ff0 	cmpltui	zero,at,33983
 8212fb4:	082131bc 	xorhi	zero,at,33990
 8212fb8:	082131a4 	muli	zero,at,-31546
 8212fbc:	082131bc 	xorhi	zero,at,33990
 8212fc0:	08212ff0 	cmpltui	zero,at,33983
 8212fc4:	082131cc 	andi	zero,at,33991
 8212fc8:	082131cc 	andi	zero,at,33991
 8212fcc:	082131cc 	andi	zero,at,33991
 8212fd0:	082133e8 	cmpgeui	zero,at,33999
 8212fd4:	2404b03a 	or	r2,r4,r16
 8212fd8:	10006f1e 	bne	r2,zero,8213198 <__muldf3+0x2f8>
 8212fdc:	04c00204 	movi	r19,8
 8212fe0:	0021883a 	mov	r16,zero
 8212fe4:	0029883a 	mov	r20,zero
 8212fe8:	07000084 	movi	fp,2
 8212fec:	003fcb06 	br	8212f1c <__muldf3+0x7c>
 8212ff0:	502d883a 	mov	r22,r10
 8212ff4:	00800084 	movi	r2,2
 8212ff8:	28805726 	beq	r5,r2,8213158 <__muldf3+0x2b8>
 8212ffc:	008000c4 	movi	r2,3
 8213000:	28816626 	beq	r5,r2,821359c <__muldf3+0x6fc>
 8213004:	00800044 	movi	r2,1
 8213008:	2881411e 	bne	r5,r2,8213510 <__muldf3+0x670>
 821300c:	b02b883a 	mov	r21,r22
 8213010:	0005883a 	mov	r2,zero
 8213014:	000b883a 	mov	r5,zero
 8213018:	0029883a 	mov	r20,zero
 821301c:	1004953a 	slli	r2,r2,20
 8213020:	a8c03fcc 	andi	r3,r21,255
 8213024:	04400434 	movhi	r17,16
 8213028:	8c7fffc4 	addi	r17,r17,-1
 821302c:	180697fa 	slli	r3,r3,31
 8213030:	2c4a703a 	and	r5,r5,r17
 8213034:	288ab03a 	or	r5,r5,r2
 8213038:	28c6b03a 	or	r3,r5,r3
 821303c:	a005883a 	mov	r2,r20
 8213040:	dfc00c17 	ldw	ra,48(sp)
 8213044:	df000b17 	ldw	fp,44(sp)
 8213048:	ddc00a17 	ldw	r23,40(sp)
 821304c:	dd800917 	ldw	r22,36(sp)
 8213050:	dd400817 	ldw	r21,32(sp)
 8213054:	dd000717 	ldw	r20,28(sp)
 8213058:	dcc00617 	ldw	r19,24(sp)
 821305c:	dc800517 	ldw	r18,20(sp)
 8213060:	dc400417 	ldw	r17,16(sp)
 8213064:	dc000317 	ldw	r16,12(sp)
 8213068:	dec00d04 	addi	sp,sp,52
 821306c:	f800283a 	ret
 8213070:	2404b03a 	or	r2,r4,r16
 8213074:	2027883a 	mov	r19,r4
 8213078:	10004226 	beq	r2,zero,8213184 <__muldf3+0x2e4>
 821307c:	8000fc26 	beq	r16,zero,8213470 <__muldf3+0x5d0>
 8213080:	8009883a 	mov	r4,r16
 8213084:	d9800215 	stw	r6,8(sp)
 8213088:	d9c00015 	stw	r7,0(sp)
 821308c:	da400115 	stw	r9,4(sp)
 8213090:	82140b80 	call	82140b8 <__clzsi2>
 8213094:	d9800217 	ldw	r6,8(sp)
 8213098:	d9c00017 	ldw	r7,0(sp)
 821309c:	da400117 	ldw	r9,4(sp)
 82130a0:	113ffd44 	addi	r4,r2,-11
 82130a4:	00c00704 	movi	r3,28
 82130a8:	1900ed16 	blt	r3,r4,8213460 <__muldf3+0x5c0>
 82130ac:	00c00744 	movi	r3,29
 82130b0:	147ffe04 	addi	r17,r2,-8
 82130b4:	1907c83a 	sub	r3,r3,r4
 82130b8:	8460983a 	sll	r16,r16,r17
 82130bc:	98c6d83a 	srl	r3,r19,r3
 82130c0:	9c68983a 	sll	r20,r19,r17
 82130c4:	1c20b03a 	or	r16,r3,r16
 82130c8:	1080fcc4 	addi	r2,r2,1011
 82130cc:	00a5c83a 	sub	r18,zero,r2
 82130d0:	0027883a 	mov	r19,zero
 82130d4:	0039883a 	mov	fp,zero
 82130d8:	003f9006 	br	8212f1c <__muldf3+0x7c>
 82130dc:	3446b03a 	or	r3,r6,r17
 82130e0:	1800261e 	bne	r3,zero,821317c <__muldf3+0x2dc>
 82130e4:	0023883a 	mov	r17,zero
 82130e8:	0011883a 	mov	r8,zero
 82130ec:	01400084 	movi	r5,2
 82130f0:	003f9c06 	br	8212f64 <__muldf3+0xc4>
 82130f4:	3446b03a 	or	r3,r6,r17
 82130f8:	18001c26 	beq	r3,zero,821316c <__muldf3+0x2cc>
 82130fc:	8800ce26 	beq	r17,zero,8213438 <__muldf3+0x598>
 8213100:	8809883a 	mov	r4,r17
 8213104:	d9800215 	stw	r6,8(sp)
 8213108:	da400115 	stw	r9,4(sp)
 821310c:	da800015 	stw	r10,0(sp)
 8213110:	82140b80 	call	82140b8 <__clzsi2>
 8213114:	d9800217 	ldw	r6,8(sp)
 8213118:	da400117 	ldw	r9,4(sp)
 821311c:	da800017 	ldw	r10,0(sp)
 8213120:	113ffd44 	addi	r4,r2,-11
 8213124:	00c00704 	movi	r3,28
 8213128:	1900bf16 	blt	r3,r4,8213428 <__muldf3+0x588>
 821312c:	00c00744 	movi	r3,29
 8213130:	123ffe04 	addi	r8,r2,-8
 8213134:	1907c83a 	sub	r3,r3,r4
 8213138:	8a22983a 	sll	r17,r17,r8
 821313c:	30c6d83a 	srl	r3,r6,r3
 8213140:	3210983a 	sll	r8,r6,r8
 8213144:	1c62b03a 	or	r17,r3,r17
 8213148:	1080fcc4 	addi	r2,r2,1011
 821314c:	0085c83a 	sub	r2,zero,r2
 8213150:	000b883a 	mov	r5,zero
 8213154:	003f8306 	br	8212f64 <__muldf3+0xc4>
 8213158:	b02b883a 	mov	r21,r22
 821315c:	0081ffc4 	movi	r2,2047
 8213160:	000b883a 	mov	r5,zero
 8213164:	0029883a 	mov	r20,zero
 8213168:	003fac06 	br	821301c <__muldf3+0x17c>
 821316c:	0023883a 	mov	r17,zero
 8213170:	0011883a 	mov	r8,zero
 8213174:	01400044 	movi	r5,1
 8213178:	003f7a06 	br	8212f64 <__muldf3+0xc4>
 821317c:	014000c4 	movi	r5,3
 8213180:	003f7806 	br	8212f64 <__muldf3+0xc4>
 8213184:	04c00104 	movi	r19,4
 8213188:	0021883a 	mov	r16,zero
 821318c:	0029883a 	mov	r20,zero
 8213190:	07000044 	movi	fp,1
 8213194:	003f6106 	br	8212f1c <__muldf3+0x7c>
 8213198:	04c00304 	movi	r19,12
 821319c:	070000c4 	movi	fp,3
 82131a0:	003f5e06 	br	8212f1c <__muldf3+0x7c>
 82131a4:	01400434 	movhi	r5,16
 82131a8:	002b883a 	mov	r21,zero
 82131ac:	297fffc4 	addi	r5,r5,-1
 82131b0:	053fffc4 	movi	r20,-1
 82131b4:	0081ffc4 	movi	r2,2047
 82131b8:	003f9806 	br	821301c <__muldf3+0x17c>
 82131bc:	8023883a 	mov	r17,r16
 82131c0:	a011883a 	mov	r8,r20
 82131c4:	e00b883a 	mov	r5,fp
 82131c8:	003f8a06 	br	8212ff4 <__muldf3+0x154>
 82131cc:	8023883a 	mov	r17,r16
 82131d0:	a011883a 	mov	r8,r20
 82131d4:	482d883a 	mov	r22,r9
 82131d8:	e00b883a 	mov	r5,fp
 82131dc:	003f8506 	br	8212ff4 <__muldf3+0x154>
 82131e0:	a00ad43a 	srli	r5,r20,16
 82131e4:	401ad43a 	srli	r13,r8,16
 82131e8:	a53fffcc 	andi	r20,r20,65535
 82131ec:	423fffcc 	andi	r8,r8,65535
 82131f0:	4519383a 	mul	r12,r8,r20
 82131f4:	4147383a 	mul	r3,r8,r5
 82131f8:	6d09383a 	mul	r4,r13,r20
 82131fc:	600cd43a 	srli	r6,r12,16
 8213200:	2b5d383a 	mul	r14,r5,r13
 8213204:	20c9883a 	add	r4,r4,r3
 8213208:	310d883a 	add	r6,r6,r4
 821320c:	30c0022e 	bgeu	r6,r3,8213218 <__muldf3+0x378>
 8213210:	00c00074 	movhi	r3,1
 8213214:	70dd883a 	add	r14,r14,r3
 8213218:	8826d43a 	srli	r19,r17,16
 821321c:	8bffffcc 	andi	r15,r17,65535
 8213220:	7d23383a 	mul	r17,r15,r20
 8213224:	7949383a 	mul	r4,r15,r5
 8213228:	9d29383a 	mul	r20,r19,r20
 821322c:	8814d43a 	srli	r10,r17,16
 8213230:	3012943a 	slli	r9,r6,16
 8213234:	a129883a 	add	r20,r20,r4
 8213238:	633fffcc 	andi	r12,r12,65535
 821323c:	5515883a 	add	r10,r10,r20
 8213240:	3006d43a 	srli	r3,r6,16
 8213244:	4b13883a 	add	r9,r9,r12
 8213248:	2ccb383a 	mul	r5,r5,r19
 821324c:	5100022e 	bgeu	r10,r4,8213258 <__muldf3+0x3b8>
 8213250:	01000074 	movhi	r4,1
 8213254:	290b883a 	add	r5,r5,r4
 8213258:	802ad43a 	srli	r21,r16,16
 821325c:	843fffcc 	andi	r16,r16,65535
 8213260:	440d383a 	mul	r6,r8,r16
 8213264:	4565383a 	mul	r18,r8,r21
 8213268:	8349383a 	mul	r4,r16,r13
 821326c:	500e943a 	slli	r7,r10,16
 8213270:	3010d43a 	srli	r8,r6,16
 8213274:	5028d43a 	srli	r20,r10,16
 8213278:	2489883a 	add	r4,r4,r18
 821327c:	8abfffcc 	andi	r10,r17,65535
 8213280:	3a95883a 	add	r10,r7,r10
 8213284:	4119883a 	add	r12,r8,r4
 8213288:	a169883a 	add	r20,r20,r5
 821328c:	1a87883a 	add	r3,r3,r10
 8213290:	6d5b383a 	mul	r13,r13,r21
 8213294:	6480022e 	bgeu	r12,r18,82132a0 <__muldf3+0x400>
 8213298:	01000074 	movhi	r4,1
 821329c:	691b883a 	add	r13,r13,r4
 82132a0:	7c25383a 	mul	r18,r15,r16
 82132a4:	7d4b383a 	mul	r5,r15,r21
 82132a8:	84cf383a 	mul	r7,r16,r19
 82132ac:	901ed43a 	srli	r15,r18,16
 82132b0:	6008d43a 	srli	r4,r12,16
 82132b4:	6010943a 	slli	r8,r12,16
 82132b8:	394f883a 	add	r7,r7,r5
 82132bc:	333fffcc 	andi	r12,r6,65535
 82132c0:	79df883a 	add	r15,r15,r7
 82132c4:	235b883a 	add	r13,r4,r13
 82132c8:	9d63383a 	mul	r17,r19,r21
 82132cc:	4309883a 	add	r4,r8,r12
 82132d0:	7940022e 	bgeu	r15,r5,82132dc <__muldf3+0x43c>
 82132d4:	01400074 	movhi	r5,1
 82132d8:	8963883a 	add	r17,r17,r5
 82132dc:	780a943a 	slli	r5,r15,16
 82132e0:	91bfffcc 	andi	r6,r18,65535
 82132e4:	70c7883a 	add	r3,r14,r3
 82132e8:	298d883a 	add	r6,r5,r6
 82132ec:	1a8f803a 	cmpltu	r7,r3,r10
 82132f0:	350b883a 	add	r5,r6,r20
 82132f4:	20c7883a 	add	r3,r4,r3
 82132f8:	3955883a 	add	r10,r7,r5
 82132fc:	1909803a 	cmpltu	r4,r3,r4
 8213300:	6a91883a 	add	r8,r13,r10
 8213304:	780cd43a 	srli	r6,r15,16
 8213308:	2219883a 	add	r12,r4,r8
 821330c:	2d0b803a 	cmpltu	r5,r5,r20
 8213310:	51cf803a 	cmpltu	r7,r10,r7
 8213314:	29ceb03a 	or	r7,r5,r7
 8213318:	4351803a 	cmpltu	r8,r8,r13
 821331c:	610b803a 	cmpltu	r5,r12,r4
 8213320:	4148b03a 	or	r4,r8,r5
 8213324:	398f883a 	add	r7,r7,r6
 8213328:	3909883a 	add	r4,r7,r4
 821332c:	1810927a 	slli	r8,r3,9
 8213330:	2449883a 	add	r4,r4,r17
 8213334:	2008927a 	slli	r4,r4,9
 8213338:	6022d5fa 	srli	r17,r12,23
 821333c:	1806d5fa 	srli	r3,r3,23
 8213340:	4252b03a 	or	r9,r8,r9
 8213344:	600a927a 	slli	r5,r12,9
 8213348:	4810c03a 	cmpne	r8,r9,zero
 821334c:	2462b03a 	or	r17,r4,r17
 8213350:	40c6b03a 	or	r3,r8,r3
 8213354:	8900402c 	andhi	r4,r17,256
 8213358:	1950b03a 	or	r8,r3,r5
 821335c:	20000726 	beq	r4,zero,821337c <__muldf3+0x4dc>
 8213360:	4006d07a 	srli	r3,r8,1
 8213364:	880497fa 	slli	r2,r17,31
 8213368:	4200004c 	andi	r8,r8,1
 821336c:	8822d07a 	srli	r17,r17,1
 8213370:	1a10b03a 	or	r8,r3,r8
 8213374:	1210b03a 	or	r8,r2,r8
 8213378:	5805883a 	mov	r2,r11
 821337c:	1140ffc4 	addi	r5,r2,1023
 8213380:	0140440e 	bge	zero,r5,8213494 <__muldf3+0x5f4>
 8213384:	40c001cc 	andi	r3,r8,7
 8213388:	18000726 	beq	r3,zero,82133a8 <__muldf3+0x508>
 821338c:	40c003cc 	andi	r3,r8,15
 8213390:	01000104 	movi	r4,4
 8213394:	19000426 	beq	r3,r4,82133a8 <__muldf3+0x508>
 8213398:	4107883a 	add	r3,r8,r4
 821339c:	1a11803a 	cmpltu	r8,r3,r8
 82133a0:	8a23883a 	add	r17,r17,r8
 82133a4:	1811883a 	mov	r8,r3
 82133a8:	88c0402c 	andhi	r3,r17,256
 82133ac:	18000426 	beq	r3,zero,82133c0 <__muldf3+0x520>
 82133b0:	11410004 	addi	r5,r2,1024
 82133b4:	00bfc034 	movhi	r2,65280
 82133b8:	10bfffc4 	addi	r2,r2,-1
 82133bc:	88a2703a 	and	r17,r17,r2
 82133c0:	0081ff84 	movi	r2,2046
 82133c4:	117f6416 	blt	r2,r5,8213158 <__muldf3+0x2b8>
 82133c8:	8828977a 	slli	r20,r17,29
 82133cc:	4010d0fa 	srli	r8,r8,3
 82133d0:	8822927a 	slli	r17,r17,9
 82133d4:	2881ffcc 	andi	r2,r5,2047
 82133d8:	a228b03a 	or	r20,r20,r8
 82133dc:	880ad33a 	srli	r5,r17,12
 82133e0:	b02b883a 	mov	r21,r22
 82133e4:	003f0d06 	br	821301c <__muldf3+0x17c>
 82133e8:	8080022c 	andhi	r2,r16,8
 82133ec:	10000926 	beq	r2,zero,8213414 <__muldf3+0x574>
 82133f0:	8880022c 	andhi	r2,r17,8
 82133f4:	1000071e 	bne	r2,zero,8213414 <__muldf3+0x574>
 82133f8:	00800434 	movhi	r2,16
 82133fc:	89400234 	orhi	r5,r17,8
 8213400:	10bfffc4 	addi	r2,r2,-1
 8213404:	b82b883a 	mov	r21,r23
 8213408:	288a703a 	and	r5,r5,r2
 821340c:	4029883a 	mov	r20,r8
 8213410:	003f6806 	br	82131b4 <__muldf3+0x314>
 8213414:	00800434 	movhi	r2,16
 8213418:	81400234 	orhi	r5,r16,8
 821341c:	10bfffc4 	addi	r2,r2,-1
 8213420:	288a703a 	and	r5,r5,r2
 8213424:	003f6306 	br	82131b4 <__muldf3+0x314>
 8213428:	147ff604 	addi	r17,r2,-40
 821342c:	3462983a 	sll	r17,r6,r17
 8213430:	0011883a 	mov	r8,zero
 8213434:	003f4406 	br	8213148 <__muldf3+0x2a8>
 8213438:	3009883a 	mov	r4,r6
 821343c:	d9800215 	stw	r6,8(sp)
 8213440:	da400115 	stw	r9,4(sp)
 8213444:	da800015 	stw	r10,0(sp)
 8213448:	82140b80 	call	82140b8 <__clzsi2>
 821344c:	10800804 	addi	r2,r2,32
 8213450:	da800017 	ldw	r10,0(sp)
 8213454:	da400117 	ldw	r9,4(sp)
 8213458:	d9800217 	ldw	r6,8(sp)
 821345c:	003f3006 	br	8213120 <__muldf3+0x280>
 8213460:	143ff604 	addi	r16,r2,-40
 8213464:	9c20983a 	sll	r16,r19,r16
 8213468:	0029883a 	mov	r20,zero
 821346c:	003f1606 	br	82130c8 <__muldf3+0x228>
 8213470:	d9800215 	stw	r6,8(sp)
 8213474:	d9c00015 	stw	r7,0(sp)
 8213478:	da400115 	stw	r9,4(sp)
 821347c:	82140b80 	call	82140b8 <__clzsi2>
 8213480:	10800804 	addi	r2,r2,32
 8213484:	da400117 	ldw	r9,4(sp)
 8213488:	d9c00017 	ldw	r7,0(sp)
 821348c:	d9800217 	ldw	r6,8(sp)
 8213490:	003f0306 	br	82130a0 <__muldf3+0x200>
 8213494:	00c00044 	movi	r3,1
 8213498:	1947c83a 	sub	r3,r3,r5
 821349c:	00800e04 	movi	r2,56
 82134a0:	10feda16 	blt	r2,r3,821300c <__muldf3+0x16c>
 82134a4:	008007c4 	movi	r2,31
 82134a8:	10c01b16 	blt	r2,r3,8213518 <__muldf3+0x678>
 82134ac:	00800804 	movi	r2,32
 82134b0:	10c5c83a 	sub	r2,r2,r3
 82134b4:	888a983a 	sll	r5,r17,r2
 82134b8:	40c8d83a 	srl	r4,r8,r3
 82134bc:	4084983a 	sll	r2,r8,r2
 82134c0:	88e2d83a 	srl	r17,r17,r3
 82134c4:	2906b03a 	or	r3,r5,r4
 82134c8:	1004c03a 	cmpne	r2,r2,zero
 82134cc:	1886b03a 	or	r3,r3,r2
 82134d0:	188001cc 	andi	r2,r3,7
 82134d4:	10000726 	beq	r2,zero,82134f4 <__muldf3+0x654>
 82134d8:	188003cc 	andi	r2,r3,15
 82134dc:	01000104 	movi	r4,4
 82134e0:	11000426 	beq	r2,r4,82134f4 <__muldf3+0x654>
 82134e4:	1805883a 	mov	r2,r3
 82134e8:	10c00104 	addi	r3,r2,4
 82134ec:	1885803a 	cmpltu	r2,r3,r2
 82134f0:	88a3883a 	add	r17,r17,r2
 82134f4:	8880202c 	andhi	r2,r17,128
 82134f8:	10001c26 	beq	r2,zero,821356c <__muldf3+0x6cc>
 82134fc:	b02b883a 	mov	r21,r22
 8213500:	00800044 	movi	r2,1
 8213504:	000b883a 	mov	r5,zero
 8213508:	0029883a 	mov	r20,zero
 821350c:	003ec306 	br	821301c <__muldf3+0x17c>
 8213510:	5805883a 	mov	r2,r11
 8213514:	003f9906 	br	821337c <__muldf3+0x4dc>
 8213518:	00bff844 	movi	r2,-31
 821351c:	1145c83a 	sub	r2,r2,r5
 8213520:	8888d83a 	srl	r4,r17,r2
 8213524:	00800804 	movi	r2,32
 8213528:	18801a26 	beq	r3,r2,8213594 <__muldf3+0x6f4>
 821352c:	00801004 	movi	r2,64
 8213530:	10c5c83a 	sub	r2,r2,r3
 8213534:	8884983a 	sll	r2,r17,r2
 8213538:	1204b03a 	or	r2,r2,r8
 821353c:	1004c03a 	cmpne	r2,r2,zero
 8213540:	2084b03a 	or	r2,r4,r2
 8213544:	144001cc 	andi	r17,r2,7
 8213548:	88000d1e 	bne	r17,zero,8213580 <__muldf3+0x6e0>
 821354c:	000b883a 	mov	r5,zero
 8213550:	1028d0fa 	srli	r20,r2,3
 8213554:	b02b883a 	mov	r21,r22
 8213558:	0005883a 	mov	r2,zero
 821355c:	a468b03a 	or	r20,r20,r17
 8213560:	003eae06 	br	821301c <__muldf3+0x17c>
 8213564:	1007883a 	mov	r3,r2
 8213568:	0023883a 	mov	r17,zero
 821356c:	880a927a 	slli	r5,r17,9
 8213570:	1805883a 	mov	r2,r3
 8213574:	8822977a 	slli	r17,r17,29
 8213578:	280ad33a 	srli	r5,r5,12
 821357c:	003ff406 	br	8213550 <__muldf3+0x6b0>
 8213580:	10c003cc 	andi	r3,r2,15
 8213584:	01000104 	movi	r4,4
 8213588:	193ff626 	beq	r3,r4,8213564 <__muldf3+0x6c4>
 821358c:	0023883a 	mov	r17,zero
 8213590:	003fd506 	br	82134e8 <__muldf3+0x648>
 8213594:	0005883a 	mov	r2,zero
 8213598:	003fe706 	br	8213538 <__muldf3+0x698>
 821359c:	00800434 	movhi	r2,16
 82135a0:	89400234 	orhi	r5,r17,8
 82135a4:	10bfffc4 	addi	r2,r2,-1
 82135a8:	b02b883a 	mov	r21,r22
 82135ac:	288a703a 	and	r5,r5,r2
 82135b0:	4029883a 	mov	r20,r8
 82135b4:	003eff06 	br	82131b4 <__muldf3+0x314>

082135b8 <__subdf3>:
 82135b8:	02000434 	movhi	r8,16
 82135bc:	423fffc4 	addi	r8,r8,-1
 82135c0:	defffb04 	addi	sp,sp,-20
 82135c4:	2a14703a 	and	r10,r5,r8
 82135c8:	3812d53a 	srli	r9,r7,20
 82135cc:	3a10703a 	and	r8,r7,r8
 82135d0:	2006d77a 	srli	r3,r4,29
 82135d4:	3004d77a 	srli	r2,r6,29
 82135d8:	dc000015 	stw	r16,0(sp)
 82135dc:	501490fa 	slli	r10,r10,3
 82135e0:	2820d53a 	srli	r16,r5,20
 82135e4:	401090fa 	slli	r8,r8,3
 82135e8:	dc800215 	stw	r18,8(sp)
 82135ec:	dc400115 	stw	r17,4(sp)
 82135f0:	dfc00415 	stw	ra,16(sp)
 82135f4:	202290fa 	slli	r17,r4,3
 82135f8:	dcc00315 	stw	r19,12(sp)
 82135fc:	4a41ffcc 	andi	r9,r9,2047
 8213600:	0101ffc4 	movi	r4,2047
 8213604:	2824d7fa 	srli	r18,r5,31
 8213608:	8401ffcc 	andi	r16,r16,2047
 821360c:	50c6b03a 	or	r3,r10,r3
 8213610:	380ed7fa 	srli	r7,r7,31
 8213614:	408ab03a 	or	r5,r8,r2
 8213618:	300c90fa 	slli	r6,r6,3
 821361c:	49009626 	beq	r9,r4,8213878 <__subdf3+0x2c0>
 8213620:	39c0005c 	xori	r7,r7,1
 8213624:	8245c83a 	sub	r2,r16,r9
 8213628:	3c807426 	beq	r7,r18,82137fc <__subdf3+0x244>
 821362c:	0080af0e 	bge	zero,r2,82138ec <__subdf3+0x334>
 8213630:	48002a1e 	bne	r9,zero,82136dc <__subdf3+0x124>
 8213634:	2988b03a 	or	r4,r5,r6
 8213638:	20009a1e 	bne	r4,zero,82138a4 <__subdf3+0x2ec>
 821363c:	888001cc 	andi	r2,r17,7
 8213640:	10000726 	beq	r2,zero,8213660 <__subdf3+0xa8>
 8213644:	888003cc 	andi	r2,r17,15
 8213648:	01000104 	movi	r4,4
 821364c:	11000426 	beq	r2,r4,8213660 <__subdf3+0xa8>
 8213650:	890b883a 	add	r5,r17,r4
 8213654:	2c63803a 	cmpltu	r17,r5,r17
 8213658:	1c47883a 	add	r3,r3,r17
 821365c:	2823883a 	mov	r17,r5
 8213660:	1880202c 	andhi	r2,r3,128
 8213664:	10005926 	beq	r2,zero,82137cc <__subdf3+0x214>
 8213668:	84000044 	addi	r16,r16,1
 821366c:	0081ffc4 	movi	r2,2047
 8213670:	8080be26 	beq	r16,r2,821396c <__subdf3+0x3b4>
 8213674:	017fe034 	movhi	r5,65408
 8213678:	297fffc4 	addi	r5,r5,-1
 821367c:	1946703a 	and	r3,r3,r5
 8213680:	1804977a 	slli	r2,r3,29
 8213684:	1806927a 	slli	r3,r3,9
 8213688:	8822d0fa 	srli	r17,r17,3
 821368c:	8401ffcc 	andi	r16,r16,2047
 8213690:	180ad33a 	srli	r5,r3,12
 8213694:	9100004c 	andi	r4,r18,1
 8213698:	1444b03a 	or	r2,r2,r17
 821369c:	80c1ffcc 	andi	r3,r16,2047
 82136a0:	1820953a 	slli	r16,r3,20
 82136a4:	20c03fcc 	andi	r3,r4,255
 82136a8:	180897fa 	slli	r4,r3,31
 82136ac:	00c00434 	movhi	r3,16
 82136b0:	18ffffc4 	addi	r3,r3,-1
 82136b4:	28c6703a 	and	r3,r5,r3
 82136b8:	1c06b03a 	or	r3,r3,r16
 82136bc:	1906b03a 	or	r3,r3,r4
 82136c0:	dfc00417 	ldw	ra,16(sp)
 82136c4:	dcc00317 	ldw	r19,12(sp)
 82136c8:	dc800217 	ldw	r18,8(sp)
 82136cc:	dc400117 	ldw	r17,4(sp)
 82136d0:	dc000017 	ldw	r16,0(sp)
 82136d4:	dec00504 	addi	sp,sp,20
 82136d8:	f800283a 	ret
 82136dc:	0101ffc4 	movi	r4,2047
 82136e0:	813fd626 	beq	r16,r4,821363c <__subdf3+0x84>
 82136e4:	29402034 	orhi	r5,r5,128
 82136e8:	01000e04 	movi	r4,56
 82136ec:	2080a316 	blt	r4,r2,821397c <__subdf3+0x3c4>
 82136f0:	010007c4 	movi	r4,31
 82136f4:	2080c616 	blt	r4,r2,8213a10 <__subdf3+0x458>
 82136f8:	01000804 	movi	r4,32
 82136fc:	2089c83a 	sub	r4,r4,r2
 8213700:	2910983a 	sll	r8,r5,r4
 8213704:	308ed83a 	srl	r7,r6,r2
 8213708:	3108983a 	sll	r4,r6,r4
 821370c:	2884d83a 	srl	r2,r5,r2
 8213710:	41ccb03a 	or	r6,r8,r7
 8213714:	2008c03a 	cmpne	r4,r4,zero
 8213718:	310cb03a 	or	r6,r6,r4
 821371c:	898dc83a 	sub	r6,r17,r6
 8213720:	89a3803a 	cmpltu	r17,r17,r6
 8213724:	1887c83a 	sub	r3,r3,r2
 8213728:	1c47c83a 	sub	r3,r3,r17
 821372c:	3023883a 	mov	r17,r6
 8213730:	1880202c 	andhi	r2,r3,128
 8213734:	10002326 	beq	r2,zero,82137c4 <__subdf3+0x20c>
 8213738:	04c02034 	movhi	r19,128
 821373c:	9cffffc4 	addi	r19,r19,-1
 8213740:	1ce6703a 	and	r19,r3,r19
 8213744:	98007a26 	beq	r19,zero,8213930 <__subdf3+0x378>
 8213748:	9809883a 	mov	r4,r19
 821374c:	82140b80 	call	82140b8 <__clzsi2>
 8213750:	113ffe04 	addi	r4,r2,-8
 8213754:	00c007c4 	movi	r3,31
 8213758:	19007b16 	blt	r3,r4,8213948 <__subdf3+0x390>
 821375c:	00800804 	movi	r2,32
 8213760:	1105c83a 	sub	r2,r2,r4
 8213764:	8884d83a 	srl	r2,r17,r2
 8213768:	9906983a 	sll	r3,r19,r4
 821376c:	8922983a 	sll	r17,r17,r4
 8213770:	10c4b03a 	or	r2,r2,r3
 8213774:	24007816 	blt	r4,r16,8213958 <__subdf3+0x3a0>
 8213778:	2421c83a 	sub	r16,r4,r16
 821377c:	80c00044 	addi	r3,r16,1
 8213780:	010007c4 	movi	r4,31
 8213784:	20c09516 	blt	r4,r3,82139dc <__subdf3+0x424>
 8213788:	01400804 	movi	r5,32
 821378c:	28cbc83a 	sub	r5,r5,r3
 8213790:	88c8d83a 	srl	r4,r17,r3
 8213794:	8962983a 	sll	r17,r17,r5
 8213798:	114a983a 	sll	r5,r2,r5
 821379c:	10c6d83a 	srl	r3,r2,r3
 82137a0:	8804c03a 	cmpne	r2,r17,zero
 82137a4:	290ab03a 	or	r5,r5,r4
 82137a8:	28a2b03a 	or	r17,r5,r2
 82137ac:	0021883a 	mov	r16,zero
 82137b0:	003fa206 	br	821363c <__subdf3+0x84>
 82137b4:	2090b03a 	or	r8,r4,r2
 82137b8:	40018e26 	beq	r8,zero,8213df4 <__subdf3+0x83c>
 82137bc:	1007883a 	mov	r3,r2
 82137c0:	2023883a 	mov	r17,r4
 82137c4:	888001cc 	andi	r2,r17,7
 82137c8:	103f9e1e 	bne	r2,zero,8213644 <__subdf3+0x8c>
 82137cc:	1804977a 	slli	r2,r3,29
 82137d0:	8822d0fa 	srli	r17,r17,3
 82137d4:	1810d0fa 	srli	r8,r3,3
 82137d8:	9100004c 	andi	r4,r18,1
 82137dc:	1444b03a 	or	r2,r2,r17
 82137e0:	00c1ffc4 	movi	r3,2047
 82137e4:	80c02826 	beq	r16,r3,8213888 <__subdf3+0x2d0>
 82137e8:	01400434 	movhi	r5,16
 82137ec:	297fffc4 	addi	r5,r5,-1
 82137f0:	80e0703a 	and	r16,r16,r3
 82137f4:	414a703a 	and	r5,r8,r5
 82137f8:	003fa806 	br	821369c <__subdf3+0xe4>
 82137fc:	0080630e 	bge	zero,r2,821398c <__subdf3+0x3d4>
 8213800:	48003026 	beq	r9,zero,82138c4 <__subdf3+0x30c>
 8213804:	0101ffc4 	movi	r4,2047
 8213808:	813f8c26 	beq	r16,r4,821363c <__subdf3+0x84>
 821380c:	29402034 	orhi	r5,r5,128
 8213810:	01000e04 	movi	r4,56
 8213814:	2080a90e 	bge	r4,r2,8213abc <__subdf3+0x504>
 8213818:	298cb03a 	or	r6,r5,r6
 821381c:	3012c03a 	cmpne	r9,r6,zero
 8213820:	0005883a 	mov	r2,zero
 8213824:	4c53883a 	add	r9,r9,r17
 8213828:	4c63803a 	cmpltu	r17,r9,r17
 821382c:	10c7883a 	add	r3,r2,r3
 8213830:	88c7883a 	add	r3,r17,r3
 8213834:	4823883a 	mov	r17,r9
 8213838:	1880202c 	andhi	r2,r3,128
 821383c:	1000d026 	beq	r2,zero,8213b80 <__subdf3+0x5c8>
 8213840:	84000044 	addi	r16,r16,1
 8213844:	0081ffc4 	movi	r2,2047
 8213848:	8080fe26 	beq	r16,r2,8213c44 <__subdf3+0x68c>
 821384c:	00bfe034 	movhi	r2,65408
 8213850:	10bfffc4 	addi	r2,r2,-1
 8213854:	1886703a 	and	r3,r3,r2
 8213858:	880ad07a 	srli	r5,r17,1
 821385c:	180497fa 	slli	r2,r3,31
 8213860:	8900004c 	andi	r4,r17,1
 8213864:	2922b03a 	or	r17,r5,r4
 8213868:	1806d07a 	srli	r3,r3,1
 821386c:	1462b03a 	or	r17,r2,r17
 8213870:	3825883a 	mov	r18,r7
 8213874:	003f7106 	br	821363c <__subdf3+0x84>
 8213878:	2984b03a 	or	r2,r5,r6
 821387c:	103f6826 	beq	r2,zero,8213620 <__subdf3+0x68>
 8213880:	39c03fcc 	andi	r7,r7,255
 8213884:	003f6706 	br	8213624 <__subdf3+0x6c>
 8213888:	4086b03a 	or	r3,r8,r2
 821388c:	18015226 	beq	r3,zero,8213dd8 <__subdf3+0x820>
 8213890:	00c00434 	movhi	r3,16
 8213894:	41400234 	orhi	r5,r8,8
 8213898:	18ffffc4 	addi	r3,r3,-1
 821389c:	28ca703a 	and	r5,r5,r3
 82138a0:	003f7e06 	br	821369c <__subdf3+0xe4>
 82138a4:	10bfffc4 	addi	r2,r2,-1
 82138a8:	1000491e 	bne	r2,zero,82139d0 <__subdf3+0x418>
 82138ac:	898fc83a 	sub	r7,r17,r6
 82138b0:	89e3803a 	cmpltu	r17,r17,r7
 82138b4:	1947c83a 	sub	r3,r3,r5
 82138b8:	1c47c83a 	sub	r3,r3,r17
 82138bc:	3823883a 	mov	r17,r7
 82138c0:	003f9b06 	br	8213730 <__subdf3+0x178>
 82138c4:	2988b03a 	or	r4,r5,r6
 82138c8:	203f5c26 	beq	r4,zero,821363c <__subdf3+0x84>
 82138cc:	10bfffc4 	addi	r2,r2,-1
 82138d0:	1000931e 	bne	r2,zero,8213b20 <__subdf3+0x568>
 82138d4:	898d883a 	add	r6,r17,r6
 82138d8:	3463803a 	cmpltu	r17,r6,r17
 82138dc:	1947883a 	add	r3,r3,r5
 82138e0:	88c7883a 	add	r3,r17,r3
 82138e4:	3023883a 	mov	r17,r6
 82138e8:	003fd306 	br	8213838 <__subdf3+0x280>
 82138ec:	1000541e 	bne	r2,zero,8213a40 <__subdf3+0x488>
 82138f0:	80800044 	addi	r2,r16,1
 82138f4:	1081ffcc 	andi	r2,r2,2047
 82138f8:	01000044 	movi	r4,1
 82138fc:	2080a20e 	bge	r4,r2,8213b88 <__subdf3+0x5d0>
 8213900:	8989c83a 	sub	r4,r17,r6
 8213904:	8905803a 	cmpltu	r2,r17,r4
 8213908:	1967c83a 	sub	r19,r3,r5
 821390c:	98a7c83a 	sub	r19,r19,r2
 8213910:	9880202c 	andhi	r2,r19,128
 8213914:	10006326 	beq	r2,zero,8213aa4 <__subdf3+0x4ec>
 8213918:	3463c83a 	sub	r17,r6,r17
 821391c:	28c7c83a 	sub	r3,r5,r3
 8213920:	344d803a 	cmpltu	r6,r6,r17
 8213924:	19a7c83a 	sub	r19,r3,r6
 8213928:	3825883a 	mov	r18,r7
 821392c:	983f861e 	bne	r19,zero,8213748 <__subdf3+0x190>
 8213930:	8809883a 	mov	r4,r17
 8213934:	82140b80 	call	82140b8 <__clzsi2>
 8213938:	10800804 	addi	r2,r2,32
 821393c:	113ffe04 	addi	r4,r2,-8
 8213940:	00c007c4 	movi	r3,31
 8213944:	193f850e 	bge	r3,r4,821375c <__subdf3+0x1a4>
 8213948:	10bff604 	addi	r2,r2,-40
 821394c:	8884983a 	sll	r2,r17,r2
 8213950:	0023883a 	mov	r17,zero
 8213954:	243f880e 	bge	r4,r16,8213778 <__subdf3+0x1c0>
 8213958:	00ffe034 	movhi	r3,65408
 821395c:	18ffffc4 	addi	r3,r3,-1
 8213960:	8121c83a 	sub	r16,r16,r4
 8213964:	10c6703a 	and	r3,r2,r3
 8213968:	003f3406 	br	821363c <__subdf3+0x84>
 821396c:	9100004c 	andi	r4,r18,1
 8213970:	000b883a 	mov	r5,zero
 8213974:	0005883a 	mov	r2,zero
 8213978:	003f4806 	br	821369c <__subdf3+0xe4>
 821397c:	298cb03a 	or	r6,r5,r6
 8213980:	300cc03a 	cmpne	r6,r6,zero
 8213984:	0005883a 	mov	r2,zero
 8213988:	003f6406 	br	821371c <__subdf3+0x164>
 821398c:	10009a1e 	bne	r2,zero,8213bf8 <__subdf3+0x640>
 8213990:	82400044 	addi	r9,r16,1
 8213994:	4881ffcc 	andi	r2,r9,2047
 8213998:	02800044 	movi	r10,1
 821399c:	5080670e 	bge	r10,r2,8213b3c <__subdf3+0x584>
 82139a0:	0081ffc4 	movi	r2,2047
 82139a4:	4880af26 	beq	r9,r2,8213c64 <__subdf3+0x6ac>
 82139a8:	898d883a 	add	r6,r17,r6
 82139ac:	1945883a 	add	r2,r3,r5
 82139b0:	3447803a 	cmpltu	r3,r6,r17
 82139b4:	1887883a 	add	r3,r3,r2
 82139b8:	182297fa 	slli	r17,r3,31
 82139bc:	300cd07a 	srli	r6,r6,1
 82139c0:	1806d07a 	srli	r3,r3,1
 82139c4:	4821883a 	mov	r16,r9
 82139c8:	89a2b03a 	or	r17,r17,r6
 82139cc:	003f1b06 	br	821363c <__subdf3+0x84>
 82139d0:	0101ffc4 	movi	r4,2047
 82139d4:	813f441e 	bne	r16,r4,82136e8 <__subdf3+0x130>
 82139d8:	003f1806 	br	821363c <__subdf3+0x84>
 82139dc:	843ff844 	addi	r16,r16,-31
 82139e0:	01400804 	movi	r5,32
 82139e4:	1408d83a 	srl	r4,r2,r16
 82139e8:	19405026 	beq	r3,r5,8213b2c <__subdf3+0x574>
 82139ec:	01401004 	movi	r5,64
 82139f0:	28c7c83a 	sub	r3,r5,r3
 82139f4:	10c4983a 	sll	r2,r2,r3
 82139f8:	88a2b03a 	or	r17,r17,r2
 82139fc:	8822c03a 	cmpne	r17,r17,zero
 8213a00:	2462b03a 	or	r17,r4,r17
 8213a04:	0007883a 	mov	r3,zero
 8213a08:	0021883a 	mov	r16,zero
 8213a0c:	003f6d06 	br	82137c4 <__subdf3+0x20c>
 8213a10:	11fff804 	addi	r7,r2,-32
 8213a14:	01000804 	movi	r4,32
 8213a18:	29ced83a 	srl	r7,r5,r7
 8213a1c:	11004526 	beq	r2,r4,8213b34 <__subdf3+0x57c>
 8213a20:	01001004 	movi	r4,64
 8213a24:	2089c83a 	sub	r4,r4,r2
 8213a28:	2904983a 	sll	r2,r5,r4
 8213a2c:	118cb03a 	or	r6,r2,r6
 8213a30:	300cc03a 	cmpne	r6,r6,zero
 8213a34:	398cb03a 	or	r6,r7,r6
 8213a38:	0005883a 	mov	r2,zero
 8213a3c:	003f3706 	br	821371c <__subdf3+0x164>
 8213a40:	80002a26 	beq	r16,zero,8213aec <__subdf3+0x534>
 8213a44:	0101ffc4 	movi	r4,2047
 8213a48:	49006626 	beq	r9,r4,8213be4 <__subdf3+0x62c>
 8213a4c:	0085c83a 	sub	r2,zero,r2
 8213a50:	18c02034 	orhi	r3,r3,128
 8213a54:	01000e04 	movi	r4,56
 8213a58:	20807e16 	blt	r4,r2,8213c54 <__subdf3+0x69c>
 8213a5c:	010007c4 	movi	r4,31
 8213a60:	2080e716 	blt	r4,r2,8213e00 <__subdf3+0x848>
 8213a64:	01000804 	movi	r4,32
 8213a68:	2089c83a 	sub	r4,r4,r2
 8213a6c:	1914983a 	sll	r10,r3,r4
 8213a70:	8890d83a 	srl	r8,r17,r2
 8213a74:	8908983a 	sll	r4,r17,r4
 8213a78:	1884d83a 	srl	r2,r3,r2
 8213a7c:	5222b03a 	or	r17,r10,r8
 8213a80:	2006c03a 	cmpne	r3,r4,zero
 8213a84:	88e2b03a 	or	r17,r17,r3
 8213a88:	3463c83a 	sub	r17,r6,r17
 8213a8c:	2885c83a 	sub	r2,r5,r2
 8213a90:	344d803a 	cmpltu	r6,r6,r17
 8213a94:	1187c83a 	sub	r3,r2,r6
 8213a98:	4821883a 	mov	r16,r9
 8213a9c:	3825883a 	mov	r18,r7
 8213aa0:	003f2306 	br	8213730 <__subdf3+0x178>
 8213aa4:	24d0b03a 	or	r8,r4,r19
 8213aa8:	40001b1e 	bne	r8,zero,8213b18 <__subdf3+0x560>
 8213aac:	0005883a 	mov	r2,zero
 8213ab0:	0009883a 	mov	r4,zero
 8213ab4:	0021883a 	mov	r16,zero
 8213ab8:	003f4906 	br	82137e0 <__subdf3+0x228>
 8213abc:	010007c4 	movi	r4,31
 8213ac0:	20803a16 	blt	r4,r2,8213bac <__subdf3+0x5f4>
 8213ac4:	01000804 	movi	r4,32
 8213ac8:	2089c83a 	sub	r4,r4,r2
 8213acc:	2912983a 	sll	r9,r5,r4
 8213ad0:	3090d83a 	srl	r8,r6,r2
 8213ad4:	3108983a 	sll	r4,r6,r4
 8213ad8:	2884d83a 	srl	r2,r5,r2
 8213adc:	4a12b03a 	or	r9,r9,r8
 8213ae0:	2008c03a 	cmpne	r4,r4,zero
 8213ae4:	4912b03a 	or	r9,r9,r4
 8213ae8:	003f4e06 	br	8213824 <__subdf3+0x26c>
 8213aec:	1c48b03a 	or	r4,r3,r17
 8213af0:	20003c26 	beq	r4,zero,8213be4 <__subdf3+0x62c>
 8213af4:	0084303a 	nor	r2,zero,r2
 8213af8:	1000381e 	bne	r2,zero,8213bdc <__subdf3+0x624>
 8213afc:	3463c83a 	sub	r17,r6,r17
 8213b00:	28c5c83a 	sub	r2,r5,r3
 8213b04:	344d803a 	cmpltu	r6,r6,r17
 8213b08:	1187c83a 	sub	r3,r2,r6
 8213b0c:	4821883a 	mov	r16,r9
 8213b10:	3825883a 	mov	r18,r7
 8213b14:	003f0606 	br	8213730 <__subdf3+0x178>
 8213b18:	2023883a 	mov	r17,r4
 8213b1c:	003f0906 	br	8213744 <__subdf3+0x18c>
 8213b20:	0101ffc4 	movi	r4,2047
 8213b24:	813f3a1e 	bne	r16,r4,8213810 <__subdf3+0x258>
 8213b28:	003ec406 	br	821363c <__subdf3+0x84>
 8213b2c:	0005883a 	mov	r2,zero
 8213b30:	003fb106 	br	82139f8 <__subdf3+0x440>
 8213b34:	0005883a 	mov	r2,zero
 8213b38:	003fbc06 	br	8213a2c <__subdf3+0x474>
 8213b3c:	1c44b03a 	or	r2,r3,r17
 8213b40:	80008e1e 	bne	r16,zero,8213d7c <__subdf3+0x7c4>
 8213b44:	1000c826 	beq	r2,zero,8213e68 <__subdf3+0x8b0>
 8213b48:	2984b03a 	or	r2,r5,r6
 8213b4c:	103ebb26 	beq	r2,zero,821363c <__subdf3+0x84>
 8213b50:	8989883a 	add	r4,r17,r6
 8213b54:	1945883a 	add	r2,r3,r5
 8213b58:	2447803a 	cmpltu	r3,r4,r17
 8213b5c:	1887883a 	add	r3,r3,r2
 8213b60:	1880202c 	andhi	r2,r3,128
 8213b64:	2023883a 	mov	r17,r4
 8213b68:	103f1626 	beq	r2,zero,82137c4 <__subdf3+0x20c>
 8213b6c:	00bfe034 	movhi	r2,65408
 8213b70:	10bfffc4 	addi	r2,r2,-1
 8213b74:	5021883a 	mov	r16,r10
 8213b78:	1886703a 	and	r3,r3,r2
 8213b7c:	003eaf06 	br	821363c <__subdf3+0x84>
 8213b80:	3825883a 	mov	r18,r7
 8213b84:	003f0f06 	br	82137c4 <__subdf3+0x20c>
 8213b88:	1c44b03a 	or	r2,r3,r17
 8213b8c:	8000251e 	bne	r16,zero,8213c24 <__subdf3+0x66c>
 8213b90:	1000661e 	bne	r2,zero,8213d2c <__subdf3+0x774>
 8213b94:	2990b03a 	or	r8,r5,r6
 8213b98:	40009626 	beq	r8,zero,8213df4 <__subdf3+0x83c>
 8213b9c:	2807883a 	mov	r3,r5
 8213ba0:	3023883a 	mov	r17,r6
 8213ba4:	3825883a 	mov	r18,r7
 8213ba8:	003ea406 	br	821363c <__subdf3+0x84>
 8213bac:	127ff804 	addi	r9,r2,-32
 8213bb0:	01000804 	movi	r4,32
 8213bb4:	2a52d83a 	srl	r9,r5,r9
 8213bb8:	11008c26 	beq	r2,r4,8213dec <__subdf3+0x834>
 8213bbc:	01001004 	movi	r4,64
 8213bc0:	2085c83a 	sub	r2,r4,r2
 8213bc4:	2884983a 	sll	r2,r5,r2
 8213bc8:	118cb03a 	or	r6,r2,r6
 8213bcc:	300cc03a 	cmpne	r6,r6,zero
 8213bd0:	4992b03a 	or	r9,r9,r6
 8213bd4:	0005883a 	mov	r2,zero
 8213bd8:	003f1206 	br	8213824 <__subdf3+0x26c>
 8213bdc:	0101ffc4 	movi	r4,2047
 8213be0:	493f9c1e 	bne	r9,r4,8213a54 <__subdf3+0x49c>
 8213be4:	2807883a 	mov	r3,r5
 8213be8:	3023883a 	mov	r17,r6
 8213bec:	4821883a 	mov	r16,r9
 8213bf0:	3825883a 	mov	r18,r7
 8213bf4:	003e9106 	br	821363c <__subdf3+0x84>
 8213bf8:	80001f1e 	bne	r16,zero,8213c78 <__subdf3+0x6c0>
 8213bfc:	1c48b03a 	or	r4,r3,r17
 8213c00:	20005a26 	beq	r4,zero,8213d6c <__subdf3+0x7b4>
 8213c04:	0084303a 	nor	r2,zero,r2
 8213c08:	1000561e 	bne	r2,zero,8213d64 <__subdf3+0x7ac>
 8213c0c:	89a3883a 	add	r17,r17,r6
 8213c10:	1945883a 	add	r2,r3,r5
 8213c14:	898d803a 	cmpltu	r6,r17,r6
 8213c18:	3087883a 	add	r3,r6,r2
 8213c1c:	4821883a 	mov	r16,r9
 8213c20:	003f0506 	br	8213838 <__subdf3+0x280>
 8213c24:	10002b1e 	bne	r2,zero,8213cd4 <__subdf3+0x71c>
 8213c28:	2984b03a 	or	r2,r5,r6
 8213c2c:	10008026 	beq	r2,zero,8213e30 <__subdf3+0x878>
 8213c30:	2807883a 	mov	r3,r5
 8213c34:	3023883a 	mov	r17,r6
 8213c38:	3825883a 	mov	r18,r7
 8213c3c:	0401ffc4 	movi	r16,2047
 8213c40:	003e7e06 	br	821363c <__subdf3+0x84>
 8213c44:	3809883a 	mov	r4,r7
 8213c48:	0011883a 	mov	r8,zero
 8213c4c:	0005883a 	mov	r2,zero
 8213c50:	003ee306 	br	82137e0 <__subdf3+0x228>
 8213c54:	1c62b03a 	or	r17,r3,r17
 8213c58:	8822c03a 	cmpne	r17,r17,zero
 8213c5c:	0005883a 	mov	r2,zero
 8213c60:	003f8906 	br	8213a88 <__subdf3+0x4d0>
 8213c64:	3809883a 	mov	r4,r7
 8213c68:	4821883a 	mov	r16,r9
 8213c6c:	0011883a 	mov	r8,zero
 8213c70:	0005883a 	mov	r2,zero
 8213c74:	003eda06 	br	82137e0 <__subdf3+0x228>
 8213c78:	0101ffc4 	movi	r4,2047
 8213c7c:	49003b26 	beq	r9,r4,8213d6c <__subdf3+0x7b4>
 8213c80:	0085c83a 	sub	r2,zero,r2
 8213c84:	18c02034 	orhi	r3,r3,128
 8213c88:	01000e04 	movi	r4,56
 8213c8c:	20806e16 	blt	r4,r2,8213e48 <__subdf3+0x890>
 8213c90:	010007c4 	movi	r4,31
 8213c94:	20807716 	blt	r4,r2,8213e74 <__subdf3+0x8bc>
 8213c98:	01000804 	movi	r4,32
 8213c9c:	2089c83a 	sub	r4,r4,r2
 8213ca0:	1914983a 	sll	r10,r3,r4
 8213ca4:	8890d83a 	srl	r8,r17,r2
 8213ca8:	8908983a 	sll	r4,r17,r4
 8213cac:	1884d83a 	srl	r2,r3,r2
 8213cb0:	5222b03a 	or	r17,r10,r8
 8213cb4:	2006c03a 	cmpne	r3,r4,zero
 8213cb8:	88e2b03a 	or	r17,r17,r3
 8213cbc:	89a3883a 	add	r17,r17,r6
 8213cc0:	1145883a 	add	r2,r2,r5
 8213cc4:	898d803a 	cmpltu	r6,r17,r6
 8213cc8:	3087883a 	add	r3,r6,r2
 8213ccc:	4821883a 	mov	r16,r9
 8213cd0:	003ed906 	br	8213838 <__subdf3+0x280>
 8213cd4:	2984b03a 	or	r2,r5,r6
 8213cd8:	10004226 	beq	r2,zero,8213de4 <__subdf3+0x82c>
 8213cdc:	1808d0fa 	srli	r4,r3,3
 8213ce0:	8822d0fa 	srli	r17,r17,3
 8213ce4:	1806977a 	slli	r3,r3,29
 8213ce8:	2080022c 	andhi	r2,r4,8
 8213cec:	1c62b03a 	or	r17,r3,r17
 8213cf0:	10000826 	beq	r2,zero,8213d14 <__subdf3+0x75c>
 8213cf4:	2812d0fa 	srli	r9,r5,3
 8213cf8:	4880022c 	andhi	r2,r9,8
 8213cfc:	1000051e 	bne	r2,zero,8213d14 <__subdf3+0x75c>
 8213d00:	300cd0fa 	srli	r6,r6,3
 8213d04:	2804977a 	slli	r2,r5,29
 8213d08:	4809883a 	mov	r4,r9
 8213d0c:	3825883a 	mov	r18,r7
 8213d10:	11a2b03a 	or	r17,r2,r6
 8213d14:	8806d77a 	srli	r3,r17,29
 8213d18:	200890fa 	slli	r4,r4,3
 8213d1c:	882290fa 	slli	r17,r17,3
 8213d20:	0401ffc4 	movi	r16,2047
 8213d24:	1906b03a 	or	r3,r3,r4
 8213d28:	003e4406 	br	821363c <__subdf3+0x84>
 8213d2c:	2984b03a 	or	r2,r5,r6
 8213d30:	103e4226 	beq	r2,zero,821363c <__subdf3+0x84>
 8213d34:	8989c83a 	sub	r4,r17,r6
 8213d38:	8911803a 	cmpltu	r8,r17,r4
 8213d3c:	1945c83a 	sub	r2,r3,r5
 8213d40:	1205c83a 	sub	r2,r2,r8
 8213d44:	1200202c 	andhi	r8,r2,128
 8213d48:	403e9a26 	beq	r8,zero,82137b4 <__subdf3+0x1fc>
 8213d4c:	3463c83a 	sub	r17,r6,r17
 8213d50:	28c5c83a 	sub	r2,r5,r3
 8213d54:	344d803a 	cmpltu	r6,r6,r17
 8213d58:	1187c83a 	sub	r3,r2,r6
 8213d5c:	3825883a 	mov	r18,r7
 8213d60:	003e3606 	br	821363c <__subdf3+0x84>
 8213d64:	0101ffc4 	movi	r4,2047
 8213d68:	493fc71e 	bne	r9,r4,8213c88 <__subdf3+0x6d0>
 8213d6c:	2807883a 	mov	r3,r5
 8213d70:	3023883a 	mov	r17,r6
 8213d74:	4821883a 	mov	r16,r9
 8213d78:	003e3006 	br	821363c <__subdf3+0x84>
 8213d7c:	10003626 	beq	r2,zero,8213e58 <__subdf3+0x8a0>
 8213d80:	2984b03a 	or	r2,r5,r6
 8213d84:	10001726 	beq	r2,zero,8213de4 <__subdf3+0x82c>
 8213d88:	1808d0fa 	srli	r4,r3,3
 8213d8c:	8822d0fa 	srli	r17,r17,3
 8213d90:	1806977a 	slli	r3,r3,29
 8213d94:	2080022c 	andhi	r2,r4,8
 8213d98:	1c62b03a 	or	r17,r3,r17
 8213d9c:	10000726 	beq	r2,zero,8213dbc <__subdf3+0x804>
 8213da0:	2812d0fa 	srli	r9,r5,3
 8213da4:	4880022c 	andhi	r2,r9,8
 8213da8:	1000041e 	bne	r2,zero,8213dbc <__subdf3+0x804>
 8213dac:	300cd0fa 	srli	r6,r6,3
 8213db0:	2804977a 	slli	r2,r5,29
 8213db4:	4809883a 	mov	r4,r9
 8213db8:	11a2b03a 	or	r17,r2,r6
 8213dbc:	8806d77a 	srli	r3,r17,29
 8213dc0:	200890fa 	slli	r4,r4,3
 8213dc4:	882290fa 	slli	r17,r17,3
 8213dc8:	3825883a 	mov	r18,r7
 8213dcc:	1906b03a 	or	r3,r3,r4
 8213dd0:	0401ffc4 	movi	r16,2047
 8213dd4:	003e1906 	br	821363c <__subdf3+0x84>
 8213dd8:	000b883a 	mov	r5,zero
 8213ddc:	0005883a 	mov	r2,zero
 8213de0:	003e2e06 	br	821369c <__subdf3+0xe4>
 8213de4:	0401ffc4 	movi	r16,2047
 8213de8:	003e1406 	br	821363c <__subdf3+0x84>
 8213dec:	0005883a 	mov	r2,zero
 8213df0:	003f7506 	br	8213bc8 <__subdf3+0x610>
 8213df4:	0005883a 	mov	r2,zero
 8213df8:	0009883a 	mov	r4,zero
 8213dfc:	003e7806 	br	82137e0 <__subdf3+0x228>
 8213e00:	123ff804 	addi	r8,r2,-32
 8213e04:	01000804 	movi	r4,32
 8213e08:	1a10d83a 	srl	r8,r3,r8
 8213e0c:	11002526 	beq	r2,r4,8213ea4 <__subdf3+0x8ec>
 8213e10:	01001004 	movi	r4,64
 8213e14:	2085c83a 	sub	r2,r4,r2
 8213e18:	1884983a 	sll	r2,r3,r2
 8213e1c:	1444b03a 	or	r2,r2,r17
 8213e20:	1004c03a 	cmpne	r2,r2,zero
 8213e24:	40a2b03a 	or	r17,r8,r2
 8213e28:	0005883a 	mov	r2,zero
 8213e2c:	003f1606 	br	8213a88 <__subdf3+0x4d0>
 8213e30:	02000434 	movhi	r8,16
 8213e34:	0009883a 	mov	r4,zero
 8213e38:	423fffc4 	addi	r8,r8,-1
 8213e3c:	00bfffc4 	movi	r2,-1
 8213e40:	0401ffc4 	movi	r16,2047
 8213e44:	003e6606 	br	82137e0 <__subdf3+0x228>
 8213e48:	1c62b03a 	or	r17,r3,r17
 8213e4c:	8822c03a 	cmpne	r17,r17,zero
 8213e50:	0005883a 	mov	r2,zero
 8213e54:	003f9906 	br	8213cbc <__subdf3+0x704>
 8213e58:	2807883a 	mov	r3,r5
 8213e5c:	3023883a 	mov	r17,r6
 8213e60:	0401ffc4 	movi	r16,2047
 8213e64:	003df506 	br	821363c <__subdf3+0x84>
 8213e68:	2807883a 	mov	r3,r5
 8213e6c:	3023883a 	mov	r17,r6
 8213e70:	003df206 	br	821363c <__subdf3+0x84>
 8213e74:	123ff804 	addi	r8,r2,-32
 8213e78:	01000804 	movi	r4,32
 8213e7c:	1a10d83a 	srl	r8,r3,r8
 8213e80:	11000a26 	beq	r2,r4,8213eac <__subdf3+0x8f4>
 8213e84:	01001004 	movi	r4,64
 8213e88:	2085c83a 	sub	r2,r4,r2
 8213e8c:	1884983a 	sll	r2,r3,r2
 8213e90:	1444b03a 	or	r2,r2,r17
 8213e94:	1004c03a 	cmpne	r2,r2,zero
 8213e98:	40a2b03a 	or	r17,r8,r2
 8213e9c:	0005883a 	mov	r2,zero
 8213ea0:	003f8606 	br	8213cbc <__subdf3+0x704>
 8213ea4:	0005883a 	mov	r2,zero
 8213ea8:	003fdc06 	br	8213e1c <__subdf3+0x864>
 8213eac:	0005883a 	mov	r2,zero
 8213eb0:	003ff706 	br	8213e90 <__subdf3+0x8d8>

08213eb4 <__fixdfsi>:
 8213eb4:	280cd53a 	srli	r6,r5,20
 8213eb8:	00c00434 	movhi	r3,16
 8213ebc:	18ffffc4 	addi	r3,r3,-1
 8213ec0:	3181ffcc 	andi	r6,r6,2047
 8213ec4:	01c0ff84 	movi	r7,1022
 8213ec8:	28c6703a 	and	r3,r5,r3
 8213ecc:	280ad7fa 	srli	r5,r5,31
 8213ed0:	3980120e 	bge	r7,r6,8213f1c <__fixdfsi+0x68>
 8213ed4:	00810744 	movi	r2,1053
 8213ed8:	11800c16 	blt	r2,r6,8213f0c <__fixdfsi+0x58>
 8213edc:	00810cc4 	movi	r2,1075
 8213ee0:	1185c83a 	sub	r2,r2,r6
 8213ee4:	01c007c4 	movi	r7,31
 8213ee8:	18c00434 	orhi	r3,r3,16
 8213eec:	38800d16 	blt	r7,r2,8213f24 <__fixdfsi+0x70>
 8213ef0:	31befb44 	addi	r6,r6,-1043
 8213ef4:	2084d83a 	srl	r2,r4,r2
 8213ef8:	1986983a 	sll	r3,r3,r6
 8213efc:	1884b03a 	or	r2,r3,r2
 8213f00:	28000726 	beq	r5,zero,8213f20 <__fixdfsi+0x6c>
 8213f04:	0085c83a 	sub	r2,zero,r2
 8213f08:	f800283a 	ret
 8213f0c:	00a00034 	movhi	r2,32768
 8213f10:	10bfffc4 	addi	r2,r2,-1
 8213f14:	2885883a 	add	r2,r5,r2
 8213f18:	f800283a 	ret
 8213f1c:	0005883a 	mov	r2,zero
 8213f20:	f800283a 	ret
 8213f24:	008104c4 	movi	r2,1043
 8213f28:	1185c83a 	sub	r2,r2,r6
 8213f2c:	1884d83a 	srl	r2,r3,r2
 8213f30:	003ff306 	br	8213f00 <__fixdfsi+0x4c>

08213f34 <__floatsidf>:
 8213f34:	defffd04 	addi	sp,sp,-12
 8213f38:	dfc00215 	stw	ra,8(sp)
 8213f3c:	dc400115 	stw	r17,4(sp)
 8213f40:	dc000015 	stw	r16,0(sp)
 8213f44:	20002b26 	beq	r4,zero,8213ff4 <__floatsidf+0xc0>
 8213f48:	2023883a 	mov	r17,r4
 8213f4c:	2020d7fa 	srli	r16,r4,31
 8213f50:	20002d16 	blt	r4,zero,8214008 <__floatsidf+0xd4>
 8213f54:	8809883a 	mov	r4,r17
 8213f58:	82140b80 	call	82140b8 <__clzsi2>
 8213f5c:	01410784 	movi	r5,1054
 8213f60:	288bc83a 	sub	r5,r5,r2
 8213f64:	01010cc4 	movi	r4,1075
 8213f68:	2149c83a 	sub	r4,r4,r5
 8213f6c:	00c007c4 	movi	r3,31
 8213f70:	1900160e 	bge	r3,r4,8213fcc <__floatsidf+0x98>
 8213f74:	00c104c4 	movi	r3,1043
 8213f78:	1947c83a 	sub	r3,r3,r5
 8213f7c:	88c6983a 	sll	r3,r17,r3
 8213f80:	00800434 	movhi	r2,16
 8213f84:	10bfffc4 	addi	r2,r2,-1
 8213f88:	1886703a 	and	r3,r3,r2
 8213f8c:	2941ffcc 	andi	r5,r5,2047
 8213f90:	800d883a 	mov	r6,r16
 8213f94:	0005883a 	mov	r2,zero
 8213f98:	280a953a 	slli	r5,r5,20
 8213f9c:	31803fcc 	andi	r6,r6,255
 8213fa0:	01000434 	movhi	r4,16
 8213fa4:	300c97fa 	slli	r6,r6,31
 8213fa8:	213fffc4 	addi	r4,r4,-1
 8213fac:	1906703a 	and	r3,r3,r4
 8213fb0:	1946b03a 	or	r3,r3,r5
 8213fb4:	1986b03a 	or	r3,r3,r6
 8213fb8:	dfc00217 	ldw	ra,8(sp)
 8213fbc:	dc400117 	ldw	r17,4(sp)
 8213fc0:	dc000017 	ldw	r16,0(sp)
 8213fc4:	dec00304 	addi	sp,sp,12
 8213fc8:	f800283a 	ret
 8213fcc:	00c002c4 	movi	r3,11
 8213fd0:	1887c83a 	sub	r3,r3,r2
 8213fd4:	88c6d83a 	srl	r3,r17,r3
 8213fd8:	8904983a 	sll	r2,r17,r4
 8213fdc:	01000434 	movhi	r4,16
 8213fe0:	213fffc4 	addi	r4,r4,-1
 8213fe4:	2941ffcc 	andi	r5,r5,2047
 8213fe8:	1906703a 	and	r3,r3,r4
 8213fec:	800d883a 	mov	r6,r16
 8213ff0:	003fe906 	br	8213f98 <__floatsidf+0x64>
 8213ff4:	000d883a 	mov	r6,zero
 8213ff8:	000b883a 	mov	r5,zero
 8213ffc:	0007883a 	mov	r3,zero
 8214000:	0005883a 	mov	r2,zero
 8214004:	003fe406 	br	8213f98 <__floatsidf+0x64>
 8214008:	0123c83a 	sub	r17,zero,r4
 821400c:	003fd106 	br	8213f54 <__floatsidf+0x20>

08214010 <__floatunsidf>:
 8214010:	defffe04 	addi	sp,sp,-8
 8214014:	dc000015 	stw	r16,0(sp)
 8214018:	dfc00115 	stw	ra,4(sp)
 821401c:	2021883a 	mov	r16,r4
 8214020:	20002226 	beq	r4,zero,82140ac <__floatunsidf+0x9c>
 8214024:	82140b80 	call	82140b8 <__clzsi2>
 8214028:	01010784 	movi	r4,1054
 821402c:	2089c83a 	sub	r4,r4,r2
 8214030:	01810cc4 	movi	r6,1075
 8214034:	310dc83a 	sub	r6,r6,r4
 8214038:	00c007c4 	movi	r3,31
 821403c:	1980120e 	bge	r3,r6,8214088 <__floatunsidf+0x78>
 8214040:	00c104c4 	movi	r3,1043
 8214044:	1907c83a 	sub	r3,r3,r4
 8214048:	80ca983a 	sll	r5,r16,r3
 821404c:	00800434 	movhi	r2,16
 8214050:	10bfffc4 	addi	r2,r2,-1
 8214054:	2101ffcc 	andi	r4,r4,2047
 8214058:	0021883a 	mov	r16,zero
 821405c:	288a703a 	and	r5,r5,r2
 8214060:	2008953a 	slli	r4,r4,20
 8214064:	00c00434 	movhi	r3,16
 8214068:	18ffffc4 	addi	r3,r3,-1
 821406c:	28c6703a 	and	r3,r5,r3
 8214070:	8005883a 	mov	r2,r16
 8214074:	1906b03a 	or	r3,r3,r4
 8214078:	dfc00117 	ldw	ra,4(sp)
 821407c:	dc000017 	ldw	r16,0(sp)
 8214080:	dec00204 	addi	sp,sp,8
 8214084:	f800283a 	ret
 8214088:	00c002c4 	movi	r3,11
 821408c:	188bc83a 	sub	r5,r3,r2
 8214090:	814ad83a 	srl	r5,r16,r5
 8214094:	00c00434 	movhi	r3,16
 8214098:	18ffffc4 	addi	r3,r3,-1
 821409c:	81a0983a 	sll	r16,r16,r6
 82140a0:	2101ffcc 	andi	r4,r4,2047
 82140a4:	28ca703a 	and	r5,r5,r3
 82140a8:	003fed06 	br	8214060 <__floatunsidf+0x50>
 82140ac:	0009883a 	mov	r4,zero
 82140b0:	000b883a 	mov	r5,zero
 82140b4:	003fea06 	br	8214060 <__floatunsidf+0x50>

082140b8 <__clzsi2>:
 82140b8:	00bfffd4 	movui	r2,65535
 82140bc:	11000536 	bltu	r2,r4,82140d4 <__clzsi2+0x1c>
 82140c0:	00803fc4 	movi	r2,255
 82140c4:	11000f36 	bltu	r2,r4,8214104 <__clzsi2+0x4c>
 82140c8:	00800804 	movi	r2,32
 82140cc:	0007883a 	mov	r3,zero
 82140d0:	00000506 	br	82140e8 <__clzsi2+0x30>
 82140d4:	00804034 	movhi	r2,256
 82140d8:	10bfffc4 	addi	r2,r2,-1
 82140dc:	11000c2e 	bgeu	r2,r4,8214110 <__clzsi2+0x58>
 82140e0:	00800204 	movi	r2,8
 82140e4:	00c00604 	movi	r3,24
 82140e8:	20c8d83a 	srl	r4,r4,r3
 82140ec:	00c20974 	movhi	r3,2085
 82140f0:	18f65a04 	addi	r3,r3,-9880
 82140f4:	1909883a 	add	r4,r3,r4
 82140f8:	20c00003 	ldbu	r3,0(r4)
 82140fc:	10c5c83a 	sub	r2,r2,r3
 8214100:	f800283a 	ret
 8214104:	00800604 	movi	r2,24
 8214108:	00c00204 	movi	r3,8
 821410c:	003ff606 	br	82140e8 <__clzsi2+0x30>
 8214110:	00800404 	movi	r2,16
 8214114:	1007883a 	mov	r3,r2
 8214118:	003ff306 	br	82140e8 <__clzsi2+0x30>

0821411c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 821411c:	defffc04 	addi	sp,sp,-16
 8214120:	dfc00315 	stw	ra,12(sp)
 8214124:	df000215 	stw	fp,8(sp)
 8214128:	df000204 	addi	fp,sp,8
 821412c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 8214130:	d1600704 	addi	r5,gp,-32740
 8214134:	e13fff17 	ldw	r4,-4(fp)
 8214138:	823bc9c0 	call	823bc9c <alt_find_dev>
 821413c:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 8214140:	e0bffe17 	ldw	r2,-8(fp)
 8214144:	10000926 	beq	r2,zero,821416c <alt_flash_open_dev+0x50>
 8214148:	e0bffe17 	ldw	r2,-8(fp)
 821414c:	10800317 	ldw	r2,12(r2)
 8214150:	10000626 	beq	r2,zero,821416c <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 8214154:	e0bffe17 	ldw	r2,-8(fp)
 8214158:	10800317 	ldw	r2,12(r2)
 821415c:	e17fff17 	ldw	r5,-4(fp)
 8214160:	e13ffe17 	ldw	r4,-8(fp)
 8214164:	103ee83a 	callr	r2
 8214168:	00000106 	br	8214170 <alt_flash_open_dev+0x54>
  }

  return dev;
 821416c:	e0bffe17 	ldw	r2,-8(fp)
}
 8214170:	e037883a 	mov	sp,fp
 8214174:	dfc00117 	ldw	ra,4(sp)
 8214178:	df000017 	ldw	fp,0(sp)
 821417c:	dec00204 	addi	sp,sp,8
 8214180:	f800283a 	ret

08214184 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 8214184:	defffd04 	addi	sp,sp,-12
 8214188:	dfc00215 	stw	ra,8(sp)
 821418c:	df000115 	stw	fp,4(sp)
 8214190:	df000104 	addi	fp,sp,4
 8214194:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 8214198:	e0bfff17 	ldw	r2,-4(fp)
 821419c:	10000826 	beq	r2,zero,82141c0 <alt_flash_close_dev+0x3c>
 82141a0:	e0bfff17 	ldw	r2,-4(fp)
 82141a4:	10800417 	ldw	r2,16(r2)
 82141a8:	10000526 	beq	r2,zero,82141c0 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 82141ac:	e0bfff17 	ldw	r2,-4(fp)
 82141b0:	10800417 	ldw	r2,16(r2)
 82141b4:	e13fff17 	ldw	r4,-4(fp)
 82141b8:	103ee83a 	callr	r2
  }
  return;
 82141bc:	0001883a 	nop
 82141c0:	0001883a 	nop
}
 82141c4:	e037883a 	mov	sp,fp
 82141c8:	dfc00117 	ldw	ra,4(sp)
 82141cc:	df000017 	ldw	fp,0(sp)
 82141d0:	dec00204 	addi	sp,sp,8
 82141d4:	f800283a 	ret

082141d8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82141d8:	defffe04 	addi	sp,sp,-8
 82141dc:	dfc00115 	stw	ra,4(sp)
 82141e0:	df000015 	stw	fp,0(sp)
 82141e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82141e8:	d0a04717 	ldw	r2,-32484(gp)
 82141ec:	10000326 	beq	r2,zero,82141fc <alt_get_errno+0x24>
 82141f0:	d0a04717 	ldw	r2,-32484(gp)
 82141f4:	103ee83a 	callr	r2
 82141f8:	00000106 	br	8214200 <alt_get_errno+0x28>
 82141fc:	d0a06304 	addi	r2,gp,-32372
}
 8214200:	e037883a 	mov	sp,fp
 8214204:	dfc00117 	ldw	ra,4(sp)
 8214208:	df000017 	ldw	fp,0(sp)
 821420c:	dec00204 	addi	sp,sp,8
 8214210:	f800283a 	ret

08214214 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 8214214:	defffb04 	addi	sp,sp,-20
 8214218:	dfc00415 	stw	ra,16(sp)
 821421c:	df000315 	stw	fp,12(sp)
 8214220:	df000304 	addi	fp,sp,12
 8214224:	e13ffe15 	stw	r4,-8(fp)
 8214228:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 821422c:	e0bffe17 	ldw	r2,-8(fp)
 8214230:	10000616 	blt	r2,zero,821424c <fstat+0x38>
 8214234:	e0bffe17 	ldw	r2,-8(fp)
 8214238:	10c00324 	muli	r3,r2,12
 821423c:	00820974 	movhi	r2,2085
 8214240:	108df204 	addi	r2,r2,14280
 8214244:	1885883a 	add	r2,r3,r2
 8214248:	00000106 	br	8214250 <fstat+0x3c>
 821424c:	0005883a 	mov	r2,zero
 8214250:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8214254:	e0bffd17 	ldw	r2,-12(fp)
 8214258:	10001026 	beq	r2,zero,821429c <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 821425c:	e0bffd17 	ldw	r2,-12(fp)
 8214260:	10800017 	ldw	r2,0(r2)
 8214264:	10800817 	ldw	r2,32(r2)
 8214268:	10000726 	beq	r2,zero,8214288 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 821426c:	e0bffd17 	ldw	r2,-12(fp)
 8214270:	10800017 	ldw	r2,0(r2)
 8214274:	10800817 	ldw	r2,32(r2)
 8214278:	e17fff17 	ldw	r5,-4(fp)
 821427c:	e13ffd17 	ldw	r4,-12(fp)
 8214280:	103ee83a 	callr	r2
 8214284:	00000a06 	br	82142b0 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 8214288:	e0bfff17 	ldw	r2,-4(fp)
 821428c:	00c80004 	movi	r3,8192
 8214290:	10c00115 	stw	r3,4(r2)
      return 0;
 8214294:	0005883a 	mov	r2,zero
 8214298:	00000506 	br	82142b0 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 821429c:	82141d80 	call	82141d8 <alt_get_errno>
 82142a0:	1007883a 	mov	r3,r2
 82142a4:	00801444 	movi	r2,81
 82142a8:	18800015 	stw	r2,0(r3)
    return -1;
 82142ac:	00bfffc4 	movi	r2,-1
  }
}
 82142b0:	e037883a 	mov	sp,fp
 82142b4:	dfc00117 	ldw	ra,4(sp)
 82142b8:	df000017 	ldw	fp,0(sp)
 82142bc:	dec00204 	addi	sp,sp,8
 82142c0:	f800283a 	ret

082142c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82142c4:	defffe04 	addi	sp,sp,-8
 82142c8:	dfc00115 	stw	ra,4(sp)
 82142cc:	df000015 	stw	fp,0(sp)
 82142d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82142d4:	d0a04717 	ldw	r2,-32484(gp)
 82142d8:	10000326 	beq	r2,zero,82142e8 <alt_get_errno+0x24>
 82142dc:	d0a04717 	ldw	r2,-32484(gp)
 82142e0:	103ee83a 	callr	r2
 82142e4:	00000106 	br	82142ec <alt_get_errno+0x28>
 82142e8:	d0a06304 	addi	r2,gp,-32372
}
 82142ec:	e037883a 	mov	sp,fp
 82142f0:	dfc00117 	ldw	ra,4(sp)
 82142f4:	df000017 	ldw	fp,0(sp)
 82142f8:	dec00204 	addi	sp,sp,8
 82142fc:	f800283a 	ret

08214300 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 8214300:	deffed04 	addi	sp,sp,-76
 8214304:	dfc01215 	stw	ra,72(sp)
 8214308:	df001115 	stw	fp,68(sp)
 821430c:	df001104 	addi	fp,sp,68
 8214310:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8214314:	e0bfff17 	ldw	r2,-4(fp)
 8214318:	10000616 	blt	r2,zero,8214334 <isatty+0x34>
 821431c:	e0bfff17 	ldw	r2,-4(fp)
 8214320:	10c00324 	muli	r3,r2,12
 8214324:	00820974 	movhi	r2,2085
 8214328:	108df204 	addi	r2,r2,14280
 821432c:	1885883a 	add	r2,r3,r2
 8214330:	00000106 	br	8214338 <isatty+0x38>
 8214334:	0005883a 	mov	r2,zero
 8214338:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 821433c:	e0bfef17 	ldw	r2,-68(fp)
 8214340:	10000e26 	beq	r2,zero,821437c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 8214344:	e0bfef17 	ldw	r2,-68(fp)
 8214348:	10800017 	ldw	r2,0(r2)
 821434c:	10800817 	ldw	r2,32(r2)
 8214350:	1000021e 	bne	r2,zero,821435c <isatty+0x5c>
    {
      return 1;
 8214354:	00800044 	movi	r2,1
 8214358:	00000d06 	br	8214390 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 821435c:	e0bff004 	addi	r2,fp,-64
 8214360:	100b883a 	mov	r5,r2
 8214364:	e13fff17 	ldw	r4,-4(fp)
 8214368:	82142140 	call	8214214 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 821436c:	e0bff117 	ldw	r2,-60(fp)
 8214370:	10880020 	cmpeqi	r2,r2,8192
 8214374:	10803fcc 	andi	r2,r2,255
 8214378:	00000506 	br	8214390 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 821437c:	82142c40 	call	82142c4 <alt_get_errno>
 8214380:	1007883a 	mov	r3,r2
 8214384:	00801444 	movi	r2,81
 8214388:	18800015 	stw	r2,0(r3)
    return 0;
 821438c:	0005883a 	mov	r2,zero
  }
}
 8214390:	e037883a 	mov	sp,fp
 8214394:	dfc00117 	ldw	ra,4(sp)
 8214398:	df000017 	ldw	fp,0(sp)
 821439c:	dec00204 	addi	sp,sp,8
 82143a0:	f800283a 	ret

082143a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82143a4:	defffe04 	addi	sp,sp,-8
 82143a8:	dfc00115 	stw	ra,4(sp)
 82143ac:	df000015 	stw	fp,0(sp)
 82143b0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82143b4:	d0a04717 	ldw	r2,-32484(gp)
 82143b8:	10000326 	beq	r2,zero,82143c8 <alt_get_errno+0x24>
 82143bc:	d0a04717 	ldw	r2,-32484(gp)
 82143c0:	103ee83a 	callr	r2
 82143c4:	00000106 	br	82143cc <alt_get_errno+0x28>
 82143c8:	d0a06304 	addi	r2,gp,-32372
}
 82143cc:	e037883a 	mov	sp,fp
 82143d0:	dfc00117 	ldw	ra,4(sp)
 82143d4:	df000017 	ldw	fp,0(sp)
 82143d8:	dec00204 	addi	sp,sp,8
 82143dc:	f800283a 	ret

082143e0 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 82143e0:	defff904 	addi	sp,sp,-28
 82143e4:	dfc00615 	stw	ra,24(sp)
 82143e8:	df000515 	stw	fp,20(sp)
 82143ec:	df000504 	addi	fp,sp,20
 82143f0:	e13ffd15 	stw	r4,-12(fp)
 82143f4:	e17ffe15 	stw	r5,-8(fp)
 82143f8:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 82143fc:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8214400:	e0bffd17 	ldw	r2,-12(fp)
 8214404:	10000616 	blt	r2,zero,8214420 <lseek+0x40>
 8214408:	e0bffd17 	ldw	r2,-12(fp)
 821440c:	10c00324 	muli	r3,r2,12
 8214410:	00820974 	movhi	r2,2085
 8214414:	108df204 	addi	r2,r2,14280
 8214418:	1885883a 	add	r2,r3,r2
 821441c:	00000106 	br	8214424 <lseek+0x44>
 8214420:	0005883a 	mov	r2,zero
 8214424:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 8214428:	e0bffc17 	ldw	r2,-16(fp)
 821442c:	10001026 	beq	r2,zero,8214470 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 8214430:	e0bffc17 	ldw	r2,-16(fp)
 8214434:	10800017 	ldw	r2,0(r2)
 8214438:	10800717 	ldw	r2,28(r2)
 821443c:	10000926 	beq	r2,zero,8214464 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 8214440:	e0bffc17 	ldw	r2,-16(fp)
 8214444:	10800017 	ldw	r2,0(r2)
 8214448:	10800717 	ldw	r2,28(r2)
 821444c:	e1bfff17 	ldw	r6,-4(fp)
 8214450:	e17ffe17 	ldw	r5,-8(fp)
 8214454:	e13ffc17 	ldw	r4,-16(fp)
 8214458:	103ee83a 	callr	r2
 821445c:	e0bffb15 	stw	r2,-20(fp)
 8214460:	00000506 	br	8214478 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 8214464:	00bfde84 	movi	r2,-134
 8214468:	e0bffb15 	stw	r2,-20(fp)
 821446c:	00000206 	br	8214478 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 8214470:	00bfebc4 	movi	r2,-81
 8214474:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 8214478:	e0bffb17 	ldw	r2,-20(fp)
 821447c:	1000070e 	bge	r2,zero,821449c <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 8214480:	82143a40 	call	82143a4 <alt_get_errno>
 8214484:	1007883a 	mov	r3,r2
 8214488:	e0bffb17 	ldw	r2,-20(fp)
 821448c:	0085c83a 	sub	r2,zero,r2
 8214490:	18800015 	stw	r2,0(r3)
    rc = -1;
 8214494:	00bfffc4 	movi	r2,-1
 8214498:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 821449c:	e0bffb17 	ldw	r2,-20(fp)
}
 82144a0:	e037883a 	mov	sp,fp
 82144a4:	dfc00117 	ldw	ra,4(sp)
 82144a8:	df000017 	ldw	fp,0(sp)
 82144ac:	dec00204 	addi	sp,sp,8
 82144b0:	f800283a 	ret

082144b4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 82144b4:	defff904 	addi	sp,sp,-28
 82144b8:	dfc00615 	stw	ra,24(sp)
 82144bc:	df000515 	stw	fp,20(sp)
 82144c0:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 82144c4:	0009883a 	mov	r4,zero
 82144c8:	821c14c0 	call	821c14c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 82144cc:	82151a00 	call	82151a0 <OSInit>
 82144d0:	01000044 	movi	r4,1
 82144d4:	8219b080 	call	8219b08 <OSSemCreate>
 82144d8:	d0a06815 	stw	r2,-32352(gp)
 82144dc:	01000044 	movi	r4,1
 82144e0:	8219b080 	call	8219b08 <OSSemCreate>
 82144e4:	d0a06a15 	stw	r2,-32344(gp)
 82144e8:	d0a0b604 	addi	r2,gp,-32040
 82144ec:	e0bffc15 	stw	r2,-16(fp)
 82144f0:	00800044 	movi	r2,1
 82144f4:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 82144f8:	e0bffd0b 	ldhu	r2,-12(fp)
 82144fc:	1009883a 	mov	r4,r2
 8214500:	8219b080 	call	8219b08 <OSSemCreate>
 8214504:	1007883a 	mov	r3,r2
 8214508:	e0bffc17 	ldw	r2,-16(fp)
 821450c:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 8214510:	821c1840 	call	821c184 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 8214514:	01820974 	movhi	r6,2085
 8214518:	31b69a04 	addi	r6,r6,-9624
 821451c:	01420974 	movhi	r5,2085
 8214520:	29769a04 	addi	r5,r5,-9624
 8214524:	01020974 	movhi	r4,2085
 8214528:	21369a04 	addi	r4,r4,-9624
 821452c:	823c0900 	call	823c090 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 8214530:	823bbdc0 	call	823bbdc <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 8214534:	01020934 	movhi	r4,2084
 8214538:	212f0f04 	addi	r4,r4,-17348
 821453c:	824b3780 	call	824b378 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8214540:	d0a06417 	ldw	r2,-32368(gp)
 8214544:	d0e06517 	ldw	r3,-32364(gp)
 8214548:	d1206617 	ldw	r4,-32360(gp)
 821454c:	200d883a 	mov	r6,r4
 8214550:	180b883a 	mov	r5,r3
 8214554:	1009883a 	mov	r4,r2
 8214558:	8200d180 	call	8200d18 <main>
 821455c:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 8214560:	01000044 	movi	r4,1
 8214564:	82255840 	call	8225584 <close>
  exit (result);
 8214568:	e13ffb17 	ldw	r4,-20(fp)
 821456c:	824b3a40 	call	824b3a4 <exit>

08214570 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 8214570:	defff904 	addi	sp,sp,-28
 8214574:	df000615 	stw	fp,24(sp)
 8214578:	df000604 	addi	fp,sp,24
 821457c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214580:	0005303a 	rdctl	r2,status
 8214584:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214588:	e0fffe17 	ldw	r3,-8(fp)
 821458c:	00bfff84 	movi	r2,-2
 8214590:	1884703a 	and	r2,r3,r2
 8214594:	1001703a 	wrctl	status,r2
  
  return context;
 8214598:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 821459c:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 82145a0:	d0a00917 	ldw	r2,-32732(gp)
 82145a4:	10c000c4 	addi	r3,r2,3
 82145a8:	00bfff04 	movi	r2,-4
 82145ac:	1884703a 	and	r2,r3,r2
 82145b0:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 82145b4:	d0e00917 	ldw	r3,-32732(gp)
 82145b8:	e0bfff17 	ldw	r2,-4(fp)
 82145bc:	1887883a 	add	r3,r3,r2
 82145c0:	00820e34 	movhi	r2,2104
 82145c4:	10800004 	addi	r2,r2,0
 82145c8:	10c0062e 	bgeu	r2,r3,82145e4 <sbrk+0x74>
 82145cc:	e0bffb17 	ldw	r2,-20(fp)
 82145d0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82145d4:	e0bffa17 	ldw	r2,-24(fp)
 82145d8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 82145dc:	00bfffc4 	movi	r2,-1
 82145e0:	00000b06 	br	8214610 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 82145e4:	d0a00917 	ldw	r2,-32732(gp)
 82145e8:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 82145ec:	d0e00917 	ldw	r3,-32732(gp)
 82145f0:	e0bfff17 	ldw	r2,-4(fp)
 82145f4:	1885883a 	add	r2,r3,r2
 82145f8:	d0a00915 	stw	r2,-32732(gp)
 82145fc:	e0bffb17 	ldw	r2,-20(fp)
 8214600:	e0bffc15 	stw	r2,-16(fp)
 8214604:	e0bffc17 	ldw	r2,-16(fp)
 8214608:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 821460c:	e0bffd17 	ldw	r2,-12(fp)
} 
 8214610:	e037883a 	mov	sp,fp
 8214614:	df000017 	ldw	fp,0(sp)
 8214618:	dec00104 	addi	sp,sp,4
 821461c:	f800283a 	ret

08214620 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 8214620:	deffdf04 	addi	sp,sp,-132
 8214624:	dfc02015 	stw	ra,128(sp)
 8214628:	df001f15 	stw	fp,124(sp)
 821462c:	df001f04 	addi	fp,sp,124
 8214630:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 8214634:	e0bfe204 	addi	r2,fp,-120
 8214638:	100b883a 	mov	r5,r2
 821463c:	01003fc4 	movi	r4,255
 8214640:	821ba900 	call	821ba90 <OSTaskQuery>
 8214644:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214648:	e0bffe83 	ldbu	r2,-6(fp)
 821464c:	10803fcc 	andi	r2,r2,255
 8214650:	10001e1e 	bne	r2,zero,82146cc <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
 8214654:	e0bfee83 	ldbu	r2,-70(fp)
 8214658:	10803fcc 	andi	r2,r2,255
 821465c:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 8214660:	d0a06817 	ldw	r2,-32352(gp)
 8214664:	e0fffd04 	addi	r3,fp,-12
 8214668:	180b883a 	mov	r5,r3
 821466c:	1009883a 	mov	r4,r2
 8214670:	821a2a80 	call	821a2a8 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 8214674:	e0bffe43 	ldbu	r2,-7(fp)
 8214678:	10803fcc 	andi	r2,r2,255
 821467c:	10000726 	beq	r2,zero,821469c <__env_lock+0x7c>
 8214680:	d0a00a17 	ldw	r2,-32728(gp)
 8214684:	e0ffe117 	ldw	r3,-124(fp)
 8214688:	1880041e 	bne	r3,r2,821469c <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 821468c:	d0a06717 	ldw	r2,-32356(gp)
 8214690:	10800044 	addi	r2,r2,1
 8214694:	d0a06715 	stw	r2,-32356(gp)
 8214698:	00000a06 	br	82146c4 <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 821469c:	d0a06817 	ldw	r2,-32352(gp)
 82146a0:	e0fffe84 	addi	r3,fp,-6
 82146a4:	180d883a 	mov	r6,r3
 82146a8:	000b883a 	mov	r5,zero
 82146ac:	1009883a 	mov	r4,r2
 82146b0:	8219e200 	call	8219e20 <OSSemPend>
    locks  = 1;
 82146b4:	00800044 	movi	r2,1
 82146b8:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 82146bc:	e0bfe117 	ldw	r2,-124(fp)
 82146c0:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 82146c4:	0001883a 	nop
 82146c8:	00000106 	br	82146d0 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 82146cc:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 82146d0:	e037883a 	mov	sp,fp
 82146d4:	dfc00117 	ldw	ra,4(sp)
 82146d8:	df000017 	ldw	fp,0(sp)
 82146dc:	dec00204 	addi	sp,sp,8
 82146e0:	f800283a 	ret

082146e4 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 82146e4:	defffd04 	addi	sp,sp,-12
 82146e8:	dfc00215 	stw	ra,8(sp)
 82146ec:	df000115 	stw	fp,4(sp)
 82146f0:	df000104 	addi	fp,sp,4
 82146f4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 82146f8:	d0a06717 	ldw	r2,-32356(gp)
 82146fc:	10000b26 	beq	r2,zero,821472c <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 8214700:	d0a06717 	ldw	r2,-32356(gp)
 8214704:	10bfffc4 	addi	r2,r2,-1
 8214708:	d0a06715 	stw	r2,-32356(gp)
 821470c:	d0a06717 	ldw	r2,-32356(gp)
 8214710:	1000071e 	bne	r2,zero,8214730 <__env_unlock+0x4c>
  {
    lockid = -1;
 8214714:	00bfffc4 	movi	r2,-1
 8214718:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 821471c:	d0a06817 	ldw	r2,-32352(gp)
 8214720:	1009883a 	mov	r4,r2
 8214724:	821a1980 	call	821a198 <OSSemPost>
 8214728:	00000106 	br	8214730 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 821472c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214730:	e037883a 	mov	sp,fp
 8214734:	dfc00117 	ldw	ra,4(sp)
 8214738:	df000017 	ldw	fp,0(sp)
 821473c:	dec00204 	addi	sp,sp,8
 8214740:	f800283a 	ret

08214744 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 8214744:	deffdb04 	addi	sp,sp,-148
 8214748:	dfc02415 	stw	ra,144(sp)
 821474c:	df002315 	stw	fp,140(sp)
 8214750:	df002304 	addi	fp,sp,140
 8214754:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214758:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 821475c:	d0a06b43 	ldbu	r2,-32339(gp)
 8214760:	10803fcc 	andi	r2,r2,255
 8214764:	10800060 	cmpeqi	r2,r2,1
 8214768:	10003626 	beq	r2,zero,8214844 <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 821476c:	e0bfe204 	addi	r2,fp,-120
 8214770:	100b883a 	mov	r5,r2
 8214774:	01003fc4 	movi	r4,255
 8214778:	821ba900 	call	821ba90 <OSTaskQuery>
 821477c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214780:	e0bffe83 	ldbu	r2,-6(fp)
 8214784:	10803fcc 	andi	r2,r2,255
 8214788:	1000301e 	bne	r2,zero,821484c <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
 821478c:	e0bfee83 	ldbu	r2,-70(fp)
 8214790:	10803fcc 	andi	r2,r2,255
 8214794:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 8214798:	d0a06a17 	ldw	r2,-32344(gp)
 821479c:	e0fffd04 	addi	r3,fp,-12
 82147a0:	180b883a 	mov	r5,r3
 82147a4:	1009883a 	mov	r4,r2
 82147a8:	821a2a80 	call	821a2a8 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82147ac:	0005303a 	rdctl	r2,status
 82147b0:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82147b4:	e0ffe117 	ldw	r3,-124(fp)
 82147b8:	00bfff84 	movi	r2,-2
 82147bc:	1884703a 	and	r2,r3,r2
 82147c0:	1001703a 	wrctl	status,r2
  
  return context;
 82147c4:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
 82147c8:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 82147cc:	e0bffd0b 	ldhu	r2,-12(fp)
 82147d0:	10bfffcc 	andi	r2,r2,65535
 82147d4:	10000b1e 	bne	r2,zero,8214804 <__malloc_lock+0xc0>
 82147d8:	d0a00b17 	ldw	r2,-32724(gp)
 82147dc:	e0ffde17 	ldw	r3,-136(fp)
 82147e0:	1880081e 	bne	r3,r2,8214804 <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
 82147e4:	d0a06917 	ldw	r2,-32348(gp)
 82147e8:	10800044 	addi	r2,r2,1
 82147ec:	d0a06915 	stw	r2,-32348(gp)
 82147f0:	e0bfdd17 	ldw	r2,-140(fp)
 82147f4:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82147f8:	e0bfdf17 	ldw	r2,-132(fp)
 82147fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 8214800:	00000e06 	br	821483c <__malloc_lock+0xf8>
 8214804:	e0bfdd17 	ldw	r2,-140(fp)
 8214808:	e0bfe015 	stw	r2,-128(fp)
 821480c:	e0bfe017 	ldw	r2,-128(fp)
 8214810:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 8214814:	d0a06a17 	ldw	r2,-32344(gp)
 8214818:	e0fffe84 	addi	r3,fp,-6
 821481c:	180d883a 	mov	r6,r3
 8214820:	000b883a 	mov	r5,zero
 8214824:	1009883a 	mov	r4,r2
 8214828:	8219e200 	call	8219e20 <OSSemPend>
    locks  = 1;
 821482c:	00800044 	movi	r2,1
 8214830:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 8214834:	e0bfde17 	ldw	r2,-136(fp)
 8214838:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 821483c:	0001883a 	nop
 8214840:	00000306 	br	8214850 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
 8214844:	0001883a 	nop
 8214848:	00000106 	br	8214850 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 821484c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214850:	e037883a 	mov	sp,fp
 8214854:	dfc00117 	ldw	ra,4(sp)
 8214858:	df000017 	ldw	fp,0(sp)
 821485c:	dec00204 	addi	sp,sp,8
 8214860:	f800283a 	ret

08214864 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 8214864:	defff804 	addi	sp,sp,-32
 8214868:	dfc00715 	stw	ra,28(sp)
 821486c:	df000615 	stw	fp,24(sp)
 8214870:	df000604 	addi	fp,sp,24
 8214874:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214878:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 821487c:	d0a06b43 	ldbu	r2,-32339(gp)
 8214880:	10803fcc 	andi	r2,r2,255
 8214884:	10800060 	cmpeqi	r2,r2,1
 8214888:	10002326 	beq	r2,zero,8214918 <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821488c:	0005303a 	rdctl	r2,status
 8214890:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214894:	e0fffe17 	ldw	r3,-8(fp)
 8214898:	00bfff84 	movi	r2,-2
 821489c:	1884703a 	and	r2,r3,r2
 82148a0:	1001703a 	wrctl	status,r2
  
  return context;
 82148a4:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
 82148a8:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 82148ac:	d0a06917 	ldw	r2,-32348(gp)
 82148b0:	1000051e 	bne	r2,zero,82148c8 <__malloc_unlock+0x64>
 82148b4:	e0bffa17 	ldw	r2,-24(fp)
 82148b8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82148bc:	e0bffb17 	ldw	r2,-20(fp)
 82148c0:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 82148c4:	00001506 	br	821491c <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 82148c8:	d0a06917 	ldw	r2,-32348(gp)
 82148cc:	10bfffc4 	addi	r2,r2,-1
 82148d0:	d0a06915 	stw	r2,-32348(gp)
 82148d4:	d0a06917 	ldw	r2,-32348(gp)
 82148d8:	10000a1e 	bne	r2,zero,8214904 <__malloc_unlock+0xa0>
  {
    lockid = -1;
 82148dc:	00bfffc4 	movi	r2,-1
 82148e0:	d0a00b15 	stw	r2,-32724(gp)
 82148e4:	e0bffa17 	ldw	r2,-24(fp)
 82148e8:	e0bffc15 	stw	r2,-16(fp)
 82148ec:	e0bffc17 	ldw	r2,-16(fp)
 82148f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 82148f4:	d0a06a17 	ldw	r2,-32344(gp)
 82148f8:	1009883a 	mov	r4,r2
 82148fc:	821a1980 	call	821a198 <OSSemPost>
 8214900:	00000606 	br	821491c <__malloc_unlock+0xb8>
 8214904:	e0bffa17 	ldw	r2,-24(fp)
 8214908:	e0bffd15 	stw	r2,-12(fp)
 821490c:	e0bffd17 	ldw	r2,-12(fp)
 8214910:	1001703a 	wrctl	status,r2
 8214914:	00000106 	br	821491c <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 8214918:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 821491c:	e037883a 	mov	sp,fp
 8214920:	dfc00117 	ldw	ra,4(sp)
 8214924:	df000017 	ldw	fp,0(sp)
 8214928:	dec00204 	addi	sp,sp,8
 821492c:	f800283a 	ret

08214930 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214930:	defff704 	addi	sp,sp,-36
 8214934:	dfc00815 	stw	ra,32(sp)
 8214938:	df000715 	stw	fp,28(sp)
 821493c:	df000704 	addi	fp,sp,28
 8214940:	e13ffd15 	stw	r4,-12(fp)
 8214944:	e17ffe15 	stw	r5,-8(fp)
 8214948:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821494c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214950:	e0bfff17 	ldw	r2,-4(fp)
 8214954:	1000021e 	bne	r2,zero,8214960 <OSEventNameGet+0x30>
        return (0);
 8214958:	0005883a 	mov	r2,zero
 821495c:	00003706 	br	8214a3c <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214960:	e0bffd17 	ldw	r2,-12(fp)
 8214964:	1000051e 	bne	r2,zero,821497c <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 8214968:	e0bfff17 	ldw	r2,-4(fp)
 821496c:	00c00104 	movi	r3,4
 8214970:	10c00005 	stb	r3,0(r2)
        return (0);
 8214974:	0005883a 	mov	r2,zero
 8214978:	00003006 	br	8214a3c <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 821497c:	e0bffe17 	ldw	r2,-8(fp)
 8214980:	1000051e 	bne	r2,zero,8214998 <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8214984:	e0bfff17 	ldw	r2,-4(fp)
 8214988:	00c00304 	movi	r3,12
 821498c:	10c00005 	stb	r3,0(r2)
        return (0);
 8214990:	0005883a 	mov	r2,zero
 8214994:	00002906 	br	8214a3c <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214998:	d0a07903 	ldbu	r2,-32284(gp)
 821499c:	10803fcc 	andi	r2,r2,255
 82149a0:	10000526 	beq	r2,zero,82149b8 <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 82149a4:	e0bfff17 	ldw	r2,-4(fp)
 82149a8:	00c00444 	movi	r3,17
 82149ac:	10c00005 	stb	r3,0(r2)
        return (0);
 82149b0:	0005883a 	mov	r2,zero
 82149b4:	00002106 	br	8214a3c <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 82149b8:	e0bffd17 	ldw	r2,-12(fp)
 82149bc:	10800003 	ldbu	r2,0(r2)
 82149c0:	10803fcc 	andi	r2,r2,255
 82149c4:	10bfffc4 	addi	r2,r2,-1
 82149c8:	10800128 	cmpgeui	r2,r2,4
 82149cc:	10000526 	beq	r2,zero,82149e4 <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 82149d0:	e0bfff17 	ldw	r2,-4(fp)
 82149d4:	00c00044 	movi	r3,1
 82149d8:	10c00005 	stb	r3,0(r2)
             return (0);
 82149dc:	0005883a 	mov	r2,zero
 82149e0:	00001606 	br	8214a3c <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 82149e4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82149e8:	0005303a 	rdctl	r2,status
 82149ec:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82149f0:	e0fffb17 	ldw	r3,-20(fp)
 82149f4:	00bfff84 	movi	r2,-2
 82149f8:	1884703a 	and	r2,r3,r2
 82149fc:	1001703a 	wrctl	status,r2
  
  return context;
 8214a00:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 8214a04:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 8214a08:	e0bffd17 	ldw	r2,-12(fp)
 8214a0c:	10800384 	addi	r2,r2,14
 8214a10:	100b883a 	mov	r5,r2
 8214a14:	e13ffe17 	ldw	r4,-8(fp)
 8214a18:	82163b40 	call	82163b4 <OS_StrCopy>
 8214a1c:	e0bffa05 	stb	r2,-24(fp)
 8214a20:	e0bff917 	ldw	r2,-28(fp)
 8214a24:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214a28:	e0bffc17 	ldw	r2,-16(fp)
 8214a2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214a30:	e0bfff17 	ldw	r2,-4(fp)
 8214a34:	10000005 	stb	zero,0(r2)
    return (len);
 8214a38:	e0bffa03 	ldbu	r2,-24(fp)
}
 8214a3c:	e037883a 	mov	sp,fp
 8214a40:	dfc00117 	ldw	ra,4(sp)
 8214a44:	df000017 	ldw	fp,0(sp)
 8214a48:	dec00204 	addi	sp,sp,8
 8214a4c:	f800283a 	ret

08214a50 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214a50:	defff604 	addi	sp,sp,-40
 8214a54:	dfc00915 	stw	ra,36(sp)
 8214a58:	df000815 	stw	fp,32(sp)
 8214a5c:	df000804 	addi	fp,sp,32
 8214a60:	e13ffd15 	stw	r4,-12(fp)
 8214a64:	e17ffe15 	stw	r5,-8(fp)
 8214a68:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214a6c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214a70:	e0bfff17 	ldw	r2,-4(fp)
 8214a74:	10004026 	beq	r2,zero,8214b78 <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214a78:	e0bffd17 	ldw	r2,-12(fp)
 8214a7c:	1000041e 	bne	r2,zero,8214a90 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 8214a80:	e0bfff17 	ldw	r2,-4(fp)
 8214a84:	00c00104 	movi	r3,4
 8214a88:	10c00005 	stb	r3,0(r2)
        return;
 8214a8c:	00003b06 	br	8214b7c <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214a90:	e0bffe17 	ldw	r2,-8(fp)
 8214a94:	1000041e 	bne	r2,zero,8214aa8 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8214a98:	e0bfff17 	ldw	r2,-4(fp)
 8214a9c:	00c00304 	movi	r3,12
 8214aa0:	10c00005 	stb	r3,0(r2)
        return;
 8214aa4:	00003506 	br	8214b7c <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214aa8:	d0a07903 	ldbu	r2,-32284(gp)
 8214aac:	10803fcc 	andi	r2,r2,255
 8214ab0:	10000426 	beq	r2,zero,8214ac4 <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8214ab4:	e0bfff17 	ldw	r2,-4(fp)
 8214ab8:	00c00484 	movi	r3,18
 8214abc:	10c00005 	stb	r3,0(r2)
        return;
 8214ac0:	00002e06 	br	8214b7c <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
 8214ac4:	e0bffd17 	ldw	r2,-12(fp)
 8214ac8:	10800003 	ldbu	r2,0(r2)
 8214acc:	10803fcc 	andi	r2,r2,255
 8214ad0:	10bfffc4 	addi	r2,r2,-1
 8214ad4:	10800128 	cmpgeui	r2,r2,4
 8214ad8:	10000426 	beq	r2,zero,8214aec <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214adc:	e0bfff17 	ldw	r2,-4(fp)
 8214ae0:	00c00044 	movi	r3,1
 8214ae4:	10c00005 	stb	r3,0(r2)
             return;
 8214ae8:	00002406 	br	8214b7c <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214aec:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214af0:	0005303a 	rdctl	r2,status
 8214af4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214af8:	e0fffc17 	ldw	r3,-16(fp)
 8214afc:	00bfff84 	movi	r2,-2
 8214b00:	1884703a 	and	r2,r3,r2
 8214b04:	1001703a 	wrctl	status,r2
  
  return context;
 8214b08:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 8214b0c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 8214b10:	e13ffe17 	ldw	r4,-8(fp)
 8214b14:	82164280 	call	8216428 <OS_StrLen>
 8214b18:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 8214b1c:	e0bffa03 	ldbu	r2,-24(fp)
 8214b20:	10800830 	cmpltui	r2,r2,32
 8214b24:	1000081e 	bne	r2,zero,8214b48 <OSEventNameSet+0xf8>
 8214b28:	e0bff817 	ldw	r2,-32(fp)
 8214b2c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214b30:	e0bff917 	ldw	r2,-28(fp)
 8214b34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 8214b38:	e0bfff17 	ldw	r2,-4(fp)
 8214b3c:	00c002c4 	movi	r3,11
 8214b40:	10c00005 	stb	r3,0(r2)
        return;
 8214b44:	00000d06 	br	8214b7c <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 8214b48:	e0bffd17 	ldw	r2,-12(fp)
 8214b4c:	10800384 	addi	r2,r2,14
 8214b50:	e17ffe17 	ldw	r5,-8(fp)
 8214b54:	1009883a 	mov	r4,r2
 8214b58:	82163b40 	call	82163b4 <OS_StrCopy>
 8214b5c:	e0bff817 	ldw	r2,-32(fp)
 8214b60:	e0bffb15 	stw	r2,-20(fp)
 8214b64:	e0bffb17 	ldw	r2,-20(fp)
 8214b68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214b6c:	e0bfff17 	ldw	r2,-4(fp)
 8214b70:	10000005 	stb	zero,0(r2)
 8214b74:	00000106 	br	8214b7c <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8214b78:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 8214b7c:	e037883a 	mov	sp,fp
 8214b80:	dfc00117 	ldw	ra,4(sp)
 8214b84:	df000017 	ldw	fp,0(sp)
 8214b88:	dec00204 	addi	sp,sp,8
 8214b8c:	f800283a 	ret

08214b90 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 8214b90:	deffed04 	addi	sp,sp,-76
 8214b94:	dfc01215 	stw	ra,72(sp)
 8214b98:	df001115 	stw	fp,68(sp)
 8214b9c:	df001104 	addi	fp,sp,68
 8214ba0:	e13ffc15 	stw	r4,-16(fp)
 8214ba4:	e17ffd15 	stw	r5,-12(fp)
 8214ba8:	e1bffe15 	stw	r6,-8(fp)
 8214bac:	3805883a 	mov	r2,r7
 8214bb0:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 8214bb4:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 8214bb8:	e0800217 	ldw	r2,8(fp)
 8214bbc:	1000021e 	bne	r2,zero,8214bc8 <OSEventPendMulti+0x38>
        return (0);
 8214bc0:	0005883a 	mov	r2,zero
 8214bc4:	00017106 	br	821518c <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 8214bc8:	e0bffc17 	ldw	r2,-16(fp)
 8214bcc:	1000051e 	bne	r2,zero,8214be4 <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 8214bd0:	e0800217 	ldw	r2,8(fp)
 8214bd4:	00c00104 	movi	r3,4
 8214bd8:	10c00005 	stb	r3,0(r2)
        return (0);
 8214bdc:	0005883a 	mov	r2,zero
 8214be0:	00016a06 	br	821518c <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 8214be4:	e0bffd17 	ldw	r2,-12(fp)
 8214be8:	1000051e 	bne	r2,zero,8214c00 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 8214bec:	e0800217 	ldw	r2,8(fp)
 8214bf0:	00c00104 	movi	r3,4
 8214bf4:	10c00005 	stb	r3,0(r2)
        return (0);
 8214bf8:	0005883a 	mov	r2,zero
 8214bfc:	00016306 	br	821518c <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 8214c00:	e0bffe17 	ldw	r2,-8(fp)
 8214c04:	1000051e 	bne	r2,zero,8214c1c <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 8214c08:	e0800217 	ldw	r2,8(fp)
 8214c0c:	00c00104 	movi	r3,4
 8214c10:	10c00005 	stb	r3,0(r2)
        return (0);
 8214c14:	0005883a 	mov	r2,zero
 8214c18:	00015c06 	br	821518c <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 8214c1c:	e0bffd17 	ldw	r2,-12(fp)
 8214c20:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 8214c24:	e0bffc17 	ldw	r2,-16(fp)
 8214c28:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 8214c2c:	e0bfef17 	ldw	r2,-68(fp)
 8214c30:	10800017 	ldw	r2,0(r2)
 8214c34:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 8214c38:	00001906 	br	8214ca0 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 8214c3c:	e0bff017 	ldw	r2,-64(fp)
 8214c40:	10800003 	ldbu	r2,0(r2)
 8214c44:	10803fcc 	andi	r2,r2,255
 8214c48:	10c000a0 	cmpeqi	r3,r2,2
 8214c4c:	1800091e 	bne	r3,zero,8214c74 <OSEventPendMulti+0xe4>
 8214c50:	10c000e0 	cmpeqi	r3,r2,3
 8214c54:	1800091e 	bne	r3,zero,8214c7c <OSEventPendMulti+0xec>
 8214c58:	10800060 	cmpeqi	r2,r2,1
 8214c5c:	1000091e 	bne	r2,zero,8214c84 <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 8214c60:	e0800217 	ldw	r2,8(fp)
 8214c64:	00c00044 	movi	r3,1
 8214c68:	10c00005 	stb	r3,0(r2)
                 return (0);
 8214c6c:	0005883a 	mov	r2,zero
 8214c70:	00014606 	br	821518c <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 8214c74:	0001883a 	nop
 8214c78:	00000306 	br	8214c88 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 8214c7c:	0001883a 	nop
 8214c80:	00000106 	br	8214c88 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 8214c84:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 8214c88:	e0bfef17 	ldw	r2,-68(fp)
 8214c8c:	10800104 	addi	r2,r2,4
 8214c90:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214c94:	e0bfef17 	ldw	r2,-68(fp)
 8214c98:	10800017 	ldw	r2,0(r2)
 8214c9c:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 8214ca0:	e0bff017 	ldw	r2,-64(fp)
 8214ca4:	103fe51e 	bne	r2,zero,8214c3c <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 8214ca8:	d0a07903 	ldbu	r2,-32284(gp)
 8214cac:	10803fcc 	andi	r2,r2,255
 8214cb0:	10000526 	beq	r2,zero,8214cc8 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 8214cb4:	e0800217 	ldw	r2,8(fp)
 8214cb8:	00c00084 	movi	r3,2
 8214cbc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214cc0:	0005883a 	mov	r2,zero
 8214cc4:	00013106 	br	821518c <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 8214cc8:	d0a06b03 	ldbu	r2,-32340(gp)
 8214ccc:	10803fcc 	andi	r2,r2,255
 8214cd0:	10000526 	beq	r2,zero,8214ce8 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 8214cd4:	e0800217 	ldw	r2,8(fp)
 8214cd8:	00c00344 	movi	r3,13
 8214cdc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ce0:	0005883a 	mov	r2,zero
 8214ce4:	00012906 	br	821518c <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214ce8:	0005303a 	rdctl	r2,status
 8214cec:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214cf0:	e0fffb17 	ldw	r3,-20(fp)
 8214cf4:	00bfff84 	movi	r2,-2
 8214cf8:	1884703a 	and	r2,r3,r2
 8214cfc:	1001703a 	wrctl	status,r2
  
  return context;
 8214d00:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 8214d04:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 8214d08:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 8214d0c:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 8214d10:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 8214d14:	e0bffc17 	ldw	r2,-16(fp)
 8214d18:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 8214d1c:	e0bfef17 	ldw	r2,-68(fp)
 8214d20:	10800017 	ldw	r2,0(r2)
 8214d24:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8214d28:	00008106 	br	8214f30 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
 8214d2c:	e0bff017 	ldw	r2,-64(fp)
 8214d30:	10800003 	ldbu	r2,0(r2)
 8214d34:	10803fcc 	andi	r2,r2,255
 8214d38:	10c000a0 	cmpeqi	r3,r2,2
 8214d3c:	18003c1e 	bne	r3,zero,8214e30 <OSEventPendMulti+0x2a0>
 8214d40:	10c000e0 	cmpeqi	r3,r2,3
 8214d44:	1800031e 	bne	r3,zero,8214d54 <OSEventPendMulti+0x1c4>
 8214d48:	10800060 	cmpeqi	r2,r2,1
 8214d4c:	10001e1e 	bne	r2,zero,8214dc8 <OSEventPendMulti+0x238>
 8214d50:	00006606 	br	8214eec <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 8214d54:	e0bff017 	ldw	r2,-64(fp)
 8214d58:	1080020b 	ldhu	r2,8(r2)
 8214d5c:	10bfffcc 	andi	r2,r2,65535
 8214d60:	10001526 	beq	r2,zero,8214db8 <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 8214d64:	e0bff017 	ldw	r2,-64(fp)
 8214d68:	1080020b 	ldhu	r2,8(r2)
 8214d6c:	10bfffc4 	addi	r2,r2,-1
 8214d70:	1007883a 	mov	r3,r2
 8214d74:	e0bff017 	ldw	r2,-64(fp)
 8214d78:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 8214d7c:	e0bffd17 	ldw	r2,-12(fp)
 8214d80:	10c00104 	addi	r3,r2,4
 8214d84:	e0fffd15 	stw	r3,-12(fp)
 8214d88:	e0fff017 	ldw	r3,-64(fp)
 8214d8c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
 8214d90:	00800044 	movi	r2,1
 8214d94:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 8214d98:	e0bffe17 	ldw	r2,-8(fp)
 8214d9c:	10c00104 	addi	r3,r2,4
 8214da0:	e0fffe15 	stw	r3,-8(fp)
 8214da4:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
 8214da8:	e0bff18b 	ldhu	r2,-58(fp)
 8214dac:	10800044 	addi	r2,r2,1
 8214db0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 8214db4:	00005806 	br	8214f18 <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 8214db8:	e0bff203 	ldbu	r2,-56(fp)
 8214dbc:	10800054 	ori	r2,r2,1
 8214dc0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214dc4:	00005406 	br	8214f18 <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 8214dc8:	e0bff017 	ldw	r2,-64(fp)
 8214dcc:	10800117 	ldw	r2,4(r2)
 8214dd0:	10001326 	beq	r2,zero,8214e20 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 8214dd4:	e0bffe17 	ldw	r2,-8(fp)
 8214dd8:	10c00104 	addi	r3,r2,4
 8214ddc:	e0fffe15 	stw	r3,-8(fp)
 8214de0:	e0fff017 	ldw	r3,-64(fp)
 8214de4:	18c00117 	ldw	r3,4(r3)
 8214de8:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
 8214dec:	e0bff017 	ldw	r2,-64(fp)
 8214df0:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 8214df4:	e0bffd17 	ldw	r2,-12(fp)
 8214df8:	10c00104 	addi	r3,r2,4
 8214dfc:	e0fffd15 	stw	r3,-12(fp)
 8214e00:	e0fff017 	ldw	r3,-64(fp)
 8214e04:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
 8214e08:	00800044 	movi	r2,1
 8214e0c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8214e10:	e0bff18b 	ldhu	r2,-58(fp)
 8214e14:	10800044 	addi	r2,r2,1
 8214e18:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 8214e1c:	00003e06 	br	8214f18 <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 8214e20:	e0bff203 	ldbu	r2,-56(fp)
 8214e24:	10800094 	ori	r2,r2,2
 8214e28:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214e2c:	00003a06 	br	8214f18 <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 8214e30:	e0bff017 	ldw	r2,-64(fp)
 8214e34:	10800117 	ldw	r2,4(r2)
 8214e38:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 8214e3c:	e0bff517 	ldw	r2,-44(fp)
 8214e40:	1080058b 	ldhu	r2,22(r2)
 8214e44:	10bfffcc 	andi	r2,r2,65535
 8214e48:	10002426 	beq	r2,zero,8214edc <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 8214e4c:	e0bffe17 	ldw	r2,-8(fp)
 8214e50:	10c00104 	addi	r3,r2,4
 8214e54:	e0fffe15 	stw	r3,-8(fp)
 8214e58:	e0fff517 	ldw	r3,-44(fp)
 8214e5c:	18c00417 	ldw	r3,16(r3)
 8214e60:	19400104 	addi	r5,r3,4
 8214e64:	e13ff517 	ldw	r4,-44(fp)
 8214e68:	21400415 	stw	r5,16(r4)
 8214e6c:	18c00017 	ldw	r3,0(r3)
 8214e70:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 8214e74:	e0bff517 	ldw	r2,-44(fp)
 8214e78:	10c00417 	ldw	r3,16(r2)
 8214e7c:	e0bff517 	ldw	r2,-44(fp)
 8214e80:	10800217 	ldw	r2,8(r2)
 8214e84:	1880041e 	bne	r3,r2,8214e98 <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 8214e88:	e0bff517 	ldw	r2,-44(fp)
 8214e8c:	10c00117 	ldw	r3,4(r2)
 8214e90:	e0bff517 	ldw	r2,-44(fp)
 8214e94:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 8214e98:	e0bff517 	ldw	r2,-44(fp)
 8214e9c:	1080058b 	ldhu	r2,22(r2)
 8214ea0:	10bfffc4 	addi	r2,r2,-1
 8214ea4:	1007883a 	mov	r3,r2
 8214ea8:	e0bff517 	ldw	r2,-44(fp)
 8214eac:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 8214eb0:	e0bffd17 	ldw	r2,-12(fp)
 8214eb4:	10c00104 	addi	r3,r2,4
 8214eb8:	e0fffd15 	stw	r3,-12(fp)
 8214ebc:	e0fff017 	ldw	r3,-64(fp)
 8214ec0:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
 8214ec4:	00800044 	movi	r2,1
 8214ec8:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8214ecc:	e0bff18b 	ldhu	r2,-58(fp)
 8214ed0:	10800044 	addi	r2,r2,1
 8214ed4:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 8214ed8:	00000f06 	br	8214f18 <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 8214edc:	e0bff203 	ldbu	r2,-56(fp)
 8214ee0:	10800114 	ori	r2,r2,4
 8214ee4:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214ee8:	00000b06 	br	8214f18 <OSEventPendMulti+0x388>
 8214eec:	e0bff317 	ldw	r2,-52(fp)
 8214ef0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214ef4:	e0bff417 	ldw	r2,-48(fp)
 8214ef8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 8214efc:	e0bffd17 	ldw	r2,-12(fp)
 8214f00:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 8214f04:	e0800217 	ldw	r2,8(fp)
 8214f08:	00c00044 	movi	r3,1
 8214f0c:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 8214f10:	e0bff18b 	ldhu	r2,-58(fp)
 8214f14:	00009d06 	br	821518c <OSEventPendMulti+0x5fc>
        }
        pevents++;
 8214f18:	e0bfef17 	ldw	r2,-68(fp)
 8214f1c:	10800104 	addi	r2,r2,4
 8214f20:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214f24:	e0bfef17 	ldw	r2,-68(fp)
 8214f28:	10800017 	ldw	r2,0(r2)
 8214f2c:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8214f30:	e0bff017 	ldw	r2,-64(fp)
 8214f34:	103f7d1e 	bne	r2,zero,8214d2c <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 8214f38:	e0bff103 	ldbu	r2,-60(fp)
 8214f3c:	10800058 	cmpnei	r2,r2,1
 8214f40:	10000a1e 	bne	r2,zero,8214f6c <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 8214f44:	e0bffd17 	ldw	r2,-12(fp)
 8214f48:	10000015 	stw	zero,0(r2)
 8214f4c:	e0bff317 	ldw	r2,-52(fp)
 8214f50:	e0bff615 	stw	r2,-40(fp)
 8214f54:	e0bff617 	ldw	r2,-40(fp)
 8214f58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 8214f5c:	e0800217 	ldw	r2,8(fp)
 8214f60:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 8214f64:	e0bff18b 	ldhu	r2,-58(fp)
 8214f68:	00008806 	br	821518c <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 8214f6c:	d0a07a17 	ldw	r2,-32280(gp)
 8214f70:	d0e07a17 	ldw	r3,-32280(gp)
 8214f74:	19000c03 	ldbu	r4,48(r3)
 8214f78:	e0fff203 	ldbu	r3,-56(fp)
 8214f7c:	20c6b03a 	or	r3,r4,r3
 8214f80:	1809883a 	mov	r4,r3
 8214f84:	00ffe004 	movi	r3,-128
 8214f88:	20c6b03a 	or	r3,r4,r3
 8214f8c:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8214f90:	d0a07a17 	ldw	r2,-32280(gp)
 8214f94:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 8214f98:	d0a07a17 	ldw	r2,-32280(gp)
 8214f9c:	e0ffff0b 	ldhu	r3,-4(fp)
 8214fa0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 8214fa4:	e13ffc17 	ldw	r4,-16(fp)
 8214fa8:	8215acc0 	call	8215acc <OS_EventTaskWaitMulti>
 8214fac:	e0bff317 	ldw	r2,-52(fp)
 8214fb0:	e0bff915 	stw	r2,-28(fp)
 8214fb4:	e0bff917 	ldw	r2,-28(fp)
 8214fb8:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 8214fbc:	82162700 	call	8216270 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214fc0:	0005303a 	rdctl	r2,status
 8214fc4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214fc8:	e0fff717 	ldw	r3,-36(fp)
 8214fcc:	00bfff84 	movi	r2,-2
 8214fd0:	1884703a 	and	r2,r3,r2
 8214fd4:	1001703a 	wrctl	status,r2
  
  return context;
 8214fd8:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 8214fdc:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 8214fe0:	d0a07a17 	ldw	r2,-32280(gp)
 8214fe4:	10800c43 	ldbu	r2,49(r2)
 8214fe8:	10803fcc 	andi	r2,r2,255
 8214fec:	10000226 	beq	r2,zero,8214ff8 <OSEventPendMulti+0x468>
 8214ff0:	108000a0 	cmpeqi	r2,r2,2
 8214ff4:	10001826 	beq	r2,zero,8215058 <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 8214ff8:	d0a07a17 	ldw	r2,-32280(gp)
 8214ffc:	10800717 	ldw	r2,28(r2)
 8215000:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 8215004:	e0bff017 	ldw	r2,-64(fp)
 8215008:	10000b26 	beq	r2,zero,8215038 <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 821500c:	e0bffd17 	ldw	r2,-12(fp)
 8215010:	10c00104 	addi	r3,r2,4
 8215014:	e0fffd15 	stw	r3,-12(fp)
 8215018:	e0fff017 	ldw	r3,-64(fp)
 821501c:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 8215020:	e0bffd17 	ldw	r2,-12(fp)
 8215024:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 8215028:	e0bff18b 	ldhu	r2,-58(fp)
 821502c:	10800044 	addi	r2,r2,1
 8215030:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 8215034:	00000d06 	br	821506c <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 8215038:	d0a07a17 	ldw	r2,-32280(gp)
 821503c:	00c00044 	movi	r3,1
 8215040:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8215044:	d0a07a17 	ldw	r2,-32280(gp)
 8215048:	e17ffc17 	ldw	r5,-16(fp)
 821504c:	1009883a 	mov	r4,r2
 8215050:	8215cd40 	call	8215cd4 <OS_EventTaskRemoveMulti>
             }
			 break;
 8215054:	00000506 	br	821506c <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8215058:	d0a07a17 	ldw	r2,-32280(gp)
 821505c:	e17ffc17 	ldw	r5,-16(fp)
 8215060:	1009883a 	mov	r4,r2
 8215064:	8215cd40 	call	8215cd4 <OS_EventTaskRemoveMulti>
             break;
 8215068:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 821506c:	d0a07a17 	ldw	r2,-32280(gp)
 8215070:	10800c43 	ldbu	r2,49(r2)
 8215074:	10803fcc 	andi	r2,r2,255
 8215078:	10000326 	beq	r2,zero,8215088 <OSEventPendMulti+0x4f8>
 821507c:	108000a0 	cmpeqi	r2,r2,2
 8215080:	1000231e 	bne	r2,zero,8215110 <OSEventPendMulti+0x580>
 8215084:	00002a06 	br	8215130 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 8215088:	e0bff017 	ldw	r2,-64(fp)
 821508c:	10800003 	ldbu	r2,0(r2)
 8215090:	10803fcc 	andi	r2,r2,255
 8215094:	0080100e 	bge	zero,r2,82150d8 <OSEventPendMulti+0x548>
 8215098:	10c000d0 	cmplti	r3,r2,3
 821509c:	1800071e 	bne	r3,zero,82150bc <OSEventPendMulti+0x52c>
 82150a0:	108000e0 	cmpeqi	r2,r2,3
 82150a4:	10000c26 	beq	r2,zero,82150d8 <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 82150a8:	e0bffe17 	ldw	r2,-8(fp)
 82150ac:	10c00104 	addi	r3,r2,4
 82150b0:	e0fffe15 	stw	r3,-8(fp)
 82150b4:	10000015 	stw	zero,0(r2)
                      break;
 82150b8:	00001206 	br	8215104 <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 82150bc:	e0bffe17 	ldw	r2,-8(fp)
 82150c0:	10c00104 	addi	r3,r2,4
 82150c4:	e0fffe15 	stw	r3,-8(fp)
 82150c8:	d0e07a17 	ldw	r3,-32280(gp)
 82150cc:	18c00917 	ldw	r3,36(r3)
 82150d0:	10c00015 	stw	r3,0(r2)
                      break;
 82150d4:	00000b06 	br	8215104 <OSEventPendMulti+0x574>
 82150d8:	e0bff317 	ldw	r2,-52(fp)
 82150dc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82150e0:	e0bff817 	ldw	r2,-32(fp)
 82150e4:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 82150e8:	e0bffd17 	ldw	r2,-12(fp)
 82150ec:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 82150f0:	e0800217 	ldw	r2,8(fp)
 82150f4:	00c00044 	movi	r3,1
 82150f8:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 82150fc:	e0bff18b 	ldhu	r2,-58(fp)
 8215100:	00002206 	br	821518c <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
 8215104:	e0800217 	ldw	r2,8(fp)
 8215108:	10000005 	stb	zero,0(r2)
             break;
 821510c:	00001006 	br	8215150 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 8215110:	e0bffe17 	ldw	r2,-8(fp)
 8215114:	10c00104 	addi	r3,r2,4
 8215118:	e0fffe15 	stw	r3,-8(fp)
 821511c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 8215120:	e0800217 	ldw	r2,8(fp)
 8215124:	00c00384 	movi	r3,14
 8215128:	10c00005 	stb	r3,0(r2)
             break;
 821512c:	00000806 	br	8215150 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 8215130:	e0bffe17 	ldw	r2,-8(fp)
 8215134:	10c00104 	addi	r3,r2,4
 8215138:	e0fffe15 	stw	r3,-8(fp)
 821513c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 8215140:	e0800217 	ldw	r2,8(fp)
 8215144:	00c00284 	movi	r3,10
 8215148:	10c00005 	stb	r3,0(r2)
             break;
 821514c:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 8215150:	d0a07a17 	ldw	r2,-32280(gp)
 8215154:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 8215158:	d0a07a17 	ldw	r2,-32280(gp)
 821515c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 8215160:	d0a07a17 	ldw	r2,-32280(gp)
 8215164:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8215168:	d0a07a17 	ldw	r2,-32280(gp)
 821516c:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 8215170:	d0a07a17 	ldw	r2,-32280(gp)
 8215174:	10000915 	stw	zero,36(r2)
 8215178:	e0bff317 	ldw	r2,-52(fp)
 821517c:	e0bffa15 	stw	r2,-24(fp)
 8215180:	e0bffa17 	ldw	r2,-24(fp)
 8215184:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 8215188:	e0bff18b 	ldhu	r2,-58(fp)
}
 821518c:	e037883a 	mov	sp,fp
 8215190:	dfc00117 	ldw	ra,4(sp)
 8215194:	df000017 	ldw	fp,0(sp)
 8215198:	dec00204 	addi	sp,sp,8
 821519c:	f800283a 	ret

082151a0 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 82151a0:	defffe04 	addi	sp,sp,-8
 82151a4:	dfc00115 	stw	ra,4(sp)
 82151a8:	df000015 	stw	fp,0(sp)
 82151ac:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 82151b0:	823cce00 	call	823cce0 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 82151b4:	8215f1c0 	call	8215f1c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 82151b8:	8215f640 	call	8215f64 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 82151bc:	82160d00 	call	82160d0 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 82151c0:	8215e3c0 	call	8215e3c <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 82151c4:	8217f880 	call	8217f88 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 82151c8:	82188880 	call	8218888 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 82151cc:	82199b00 	call	82199b0 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 82151d0:	8215fd00 	call	8215fd0 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 82151d4:	82160500 	call	8216050 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 82151d8:	823cd000 	call	823cd00 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 82151dc:	821695c0 	call	821695c <OSDebugInit>
#endif
}
 82151e0:	0001883a 	nop
 82151e4:	e037883a 	mov	sp,fp
 82151e8:	dfc00117 	ldw	ra,4(sp)
 82151ec:	df000017 	ldw	fp,0(sp)
 82151f0:	dec00204 	addi	sp,sp,8
 82151f4:	f800283a 	ret

082151f8 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 82151f8:	deffff04 	addi	sp,sp,-4
 82151fc:	df000015 	stw	fp,0(sp)
 8215200:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
 8215204:	d0a06b43 	ldbu	r2,-32339(gp)
 8215208:	10803fcc 	andi	r2,r2,255
 821520c:	10800058 	cmpnei	r2,r2,1
 8215210:	1000071e 	bne	r2,zero,8215230 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
 8215214:	d0a07903 	ldbu	r2,-32284(gp)
 8215218:	10803fcc 	andi	r2,r2,255
 821521c:	10803fe0 	cmpeqi	r2,r2,255
 8215220:	1000031e 	bne	r2,zero,8215230 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 8215224:	d0a07903 	ldbu	r2,-32284(gp)
 8215228:	10800044 	addi	r2,r2,1
 821522c:	d0a07905 	stb	r2,-32284(gp)
        }
    }
}
 8215230:	0001883a 	nop
 8215234:	e037883a 	mov	sp,fp
 8215238:	df000017 	ldw	fp,0(sp)
 821523c:	dec00104 	addi	sp,sp,4
 8215240:	f800283a 	ret

08215244 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 8215244:	defffb04 	addi	sp,sp,-20
 8215248:	dfc00415 	stw	ra,16(sp)
 821524c:	df000315 	stw	fp,12(sp)
 8215250:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8215254:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 8215258:	d0a06b43 	ldbu	r2,-32339(gp)
 821525c:	10803fcc 	andi	r2,r2,255
 8215260:	10800058 	cmpnei	r2,r2,1
 8215264:	10002f1e 	bne	r2,zero,8215324 <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215268:	0005303a 	rdctl	r2,status
 821526c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215270:	e0ffff17 	ldw	r3,-4(fp)
 8215274:	00bfff84 	movi	r2,-2
 8215278:	1884703a 	and	r2,r3,r2
 821527c:	1001703a 	wrctl	status,r2
  
  return context;
 8215280:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215284:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 8215288:	d0a07903 	ldbu	r2,-32284(gp)
 821528c:	10803fcc 	andi	r2,r2,255
 8215290:	10000326 	beq	r2,zero,82152a0 <OSIntExit+0x5c>
            OSIntNesting--;
 8215294:	d0a07903 	ldbu	r2,-32284(gp)
 8215298:	10bfffc4 	addi	r2,r2,-1
 821529c:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 82152a0:	d0a07903 	ldbu	r2,-32284(gp)
 82152a4:	10803fcc 	andi	r2,r2,255
 82152a8:	10001a1e 	bne	r2,zero,8215314 <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 82152ac:	d0a06b03 	ldbu	r2,-32340(gp)
 82152b0:	10803fcc 	andi	r2,r2,255
 82152b4:	1000171e 	bne	r2,zero,8215314 <OSIntExit+0xd0>
                OS_SchedNew();
 82152b8:	82163400 	call	8216340 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 82152bc:	d0e06d03 	ldbu	r3,-32332(gp)
 82152c0:	d0a06d43 	ldbu	r2,-32331(gp)
 82152c4:	18c03fcc 	andi	r3,r3,255
 82152c8:	10803fcc 	andi	r2,r2,255
 82152cc:	18801126 	beq	r3,r2,8215314 <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 82152d0:	d0a06d03 	ldbu	r2,-32332(gp)
 82152d4:	10c03fcc 	andi	r3,r2,255
 82152d8:	008209b4 	movhi	r2,2086
 82152dc:	10b5c804 	addi	r2,r2,-10464
 82152e0:	18c7883a 	add	r3,r3,r3
 82152e4:	18c7883a 	add	r3,r3,r3
 82152e8:	10c5883a 	add	r2,r2,r3
 82152ec:	10800017 	ldw	r2,0(r2)
 82152f0:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 82152f4:	d0a07517 	ldw	r2,-32300(gp)
 82152f8:	10c00e17 	ldw	r3,56(r2)
 82152fc:	18c00044 	addi	r3,r3,1
 8215300:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 8215304:	d0a07017 	ldw	r2,-32320(gp)
 8215308:	10800044 	addi	r2,r2,1
 821530c:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 8215310:	823ca000 	call	823ca00 <OSCtxSw>
 8215314:	e0bffd17 	ldw	r2,-12(fp)
 8215318:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821531c:	e0bffe17 	ldw	r2,-8(fp)
 8215320:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 8215324:	0001883a 	nop
 8215328:	e037883a 	mov	sp,fp
 821532c:	dfc00117 	ldw	ra,4(sp)
 8215330:	df000017 	ldw	fp,0(sp)
 8215334:	dec00204 	addi	sp,sp,8
 8215338:	f800283a 	ret

0821533c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 821533c:	defffc04 	addi	sp,sp,-16
 8215340:	df000315 	stw	fp,12(sp)
 8215344:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215348:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 821534c:	d0a06b43 	ldbu	r2,-32339(gp)
 8215350:	10803fcc 	andi	r2,r2,255
 8215354:	10800058 	cmpnei	r2,r2,1
 8215358:	1000161e 	bne	r2,zero,82153b4 <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821535c:	0005303a 	rdctl	r2,status
 8215360:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215364:	e0ffff17 	ldw	r3,-4(fp)
 8215368:	00bfff84 	movi	r2,-2
 821536c:	1884703a 	and	r2,r3,r2
 8215370:	1001703a 	wrctl	status,r2
  
  return context;
 8215374:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215378:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 821537c:	d0a07903 	ldbu	r2,-32284(gp)
 8215380:	10803fcc 	andi	r2,r2,255
 8215384:	1000071e 	bne	r2,zero,82153a4 <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 8215388:	d0a06b03 	ldbu	r2,-32340(gp)
 821538c:	10803fcc 	andi	r2,r2,255
 8215390:	10803fe0 	cmpeqi	r2,r2,255
 8215394:	1000031e 	bne	r2,zero,82153a4 <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 8215398:	d0a06b03 	ldbu	r2,-32340(gp)
 821539c:	10800044 	addi	r2,r2,1
 82153a0:	d0a06b05 	stb	r2,-32340(gp)
 82153a4:	e0bffd17 	ldw	r2,-12(fp)
 82153a8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82153ac:	e0bffe17 	ldw	r2,-8(fp)
 82153b0:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 82153b4:	0001883a 	nop
 82153b8:	e037883a 	mov	sp,fp
 82153bc:	df000017 	ldw	fp,0(sp)
 82153c0:	dec00104 	addi	sp,sp,4
 82153c4:	f800283a 	ret

082153c8 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 82153c8:	defff804 	addi	sp,sp,-32
 82153cc:	dfc00715 	stw	ra,28(sp)
 82153d0:	df000615 	stw	fp,24(sp)
 82153d4:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82153d8:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 82153dc:	d0a06b43 	ldbu	r2,-32339(gp)
 82153e0:	10803fcc 	andi	r2,r2,255
 82153e4:	10800058 	cmpnei	r2,r2,1
 82153e8:	1000281e 	bne	r2,zero,821548c <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82153ec:	0005303a 	rdctl	r2,status
 82153f0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82153f4:	e0ffff17 	ldw	r3,-4(fp)
 82153f8:	00bfff84 	movi	r2,-2
 82153fc:	1884703a 	and	r2,r3,r2
 8215400:	1001703a 	wrctl	status,r2
  
  return context;
 8215404:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215408:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 821540c:	d0a06b03 	ldbu	r2,-32340(gp)
 8215410:	10803fcc 	andi	r2,r2,255
 8215414:	10001926 	beq	r2,zero,821547c <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 8215418:	d0a06b03 	ldbu	r2,-32340(gp)
 821541c:	10bfffc4 	addi	r2,r2,-1
 8215420:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 8215424:	d0a06b03 	ldbu	r2,-32340(gp)
 8215428:	10803fcc 	andi	r2,r2,255
 821542c:	10000e1e 	bne	r2,zero,8215468 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 8215430:	d0a07903 	ldbu	r2,-32284(gp)
 8215434:	10803fcc 	andi	r2,r2,255
 8215438:	1000061e 	bne	r2,zero,8215454 <OSSchedUnlock+0x8c>
 821543c:	e0bffa17 	ldw	r2,-24(fp)
 8215440:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215444:	e0bffb17 	ldw	r2,-20(fp)
 8215448:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 821544c:	82162700 	call	8216270 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 8215450:	00000e06 	br	821548c <OSSchedUnlock+0xc4>
 8215454:	e0bffa17 	ldw	r2,-24(fp)
 8215458:	e0bffc15 	stw	r2,-16(fp)
 821545c:	e0bffc17 	ldw	r2,-16(fp)
 8215460:	1001703a 	wrctl	status,r2
 8215464:	00000906 	br	821548c <OSSchedUnlock+0xc4>
 8215468:	e0bffa17 	ldw	r2,-24(fp)
 821546c:	e0bffd15 	stw	r2,-12(fp)
 8215470:	e0bffd17 	ldw	r2,-12(fp)
 8215474:	1001703a 	wrctl	status,r2
 8215478:	00000406 	br	821548c <OSSchedUnlock+0xc4>
 821547c:	e0bffa17 	ldw	r2,-24(fp)
 8215480:	e0bffe15 	stw	r2,-8(fp)
 8215484:	e0bffe17 	ldw	r2,-8(fp)
 8215488:	1001703a 	wrctl	status,r2
 821548c:	0001883a 	nop
 8215490:	e037883a 	mov	sp,fp
 8215494:	dfc00117 	ldw	ra,4(sp)
 8215498:	df000017 	ldw	fp,0(sp)
 821549c:	dec00204 	addi	sp,sp,8
 82154a0:	f800283a 	ret

082154a4 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 82154a4:	defffe04 	addi	sp,sp,-8
 82154a8:	dfc00115 	stw	ra,4(sp)
 82154ac:	df000015 	stw	fp,0(sp)
 82154b0:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 82154b4:	d0a06b43 	ldbu	r2,-32339(gp)
 82154b8:	10803fcc 	andi	r2,r2,255
 82154bc:	10000f1e 	bne	r2,zero,82154fc <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 82154c0:	82163400 	call	8216340 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 82154c4:	d0a06d03 	ldbu	r2,-32332(gp)
 82154c8:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 82154cc:	d0a06d03 	ldbu	r2,-32332(gp)
 82154d0:	10c03fcc 	andi	r3,r2,255
 82154d4:	008209b4 	movhi	r2,2086
 82154d8:	10b5c804 	addi	r2,r2,-10464
 82154dc:	18c7883a 	add	r3,r3,r3
 82154e0:	18c7883a 	add	r3,r3,r3
 82154e4:	10c5883a 	add	r2,r2,r3
 82154e8:	10800017 	ldw	r2,0(r2)
 82154ec:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 82154f0:	d0a07517 	ldw	r2,-32300(gp)
 82154f4:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 82154f8:	823ca8c0 	call	823ca8c <OSStartHighRdy>
    }
}
 82154fc:	0001883a 	nop
 8215500:	e037883a 	mov	sp,fp
 8215504:	dfc00117 	ldw	ra,4(sp)
 8215508:	df000017 	ldw	fp,0(sp)
 821550c:	dec00204 	addi	sp,sp,8
 8215510:	f800283a 	ret

08215514 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 8215514:	defff904 	addi	sp,sp,-28
 8215518:	dfc00615 	stw	ra,24(sp)
 821551c:	df000515 	stw	fp,20(sp)
 8215520:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215524:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 8215528:	01000084 	movi	r4,2
 821552c:	821bc240 	call	821bc24 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215530:	0005303a 	rdctl	r2,status
 8215534:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215538:	e0fffc17 	ldw	r3,-16(fp)
 821553c:	00bfff84 	movi	r2,-2
 8215540:	1884703a 	and	r2,r3,r2
 8215544:	1001703a 	wrctl	status,r2
  
  return context;
 8215548:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 821554c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 8215550:	d0206c15 	stw	zero,-32336(gp)
 8215554:	e0bffb17 	ldw	r2,-20(fp)
 8215558:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821555c:	e0bffd17 	ldw	r2,-12(fp)
 8215560:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 8215564:	01000284 	movi	r4,10
 8215568:	821bc240 	call	821bc24 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821556c:	0005303a 	rdctl	r2,status
 8215570:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215574:	e0fffe17 	ldw	r3,-8(fp)
 8215578:	00bfff84 	movi	r2,-2
 821557c:	1884703a 	and	r2,r3,r2
 8215580:	1001703a 	wrctl	status,r2
  
  return context;
 8215584:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 8215588:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 821558c:	d0a06c17 	ldw	r2,-32336(gp)
 8215590:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 8215594:	00800044 	movi	r2,1
 8215598:	d0a07d05 	stb	r2,-32268(gp)
 821559c:	e0bffb17 	ldw	r2,-20(fp)
 82155a0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82155a4:	e0bfff17 	ldw	r2,-4(fp)
 82155a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 82155ac:	0001883a 	nop
 82155b0:	e037883a 	mov	sp,fp
 82155b4:	dfc00117 	ldw	ra,4(sp)
 82155b8:	df000017 	ldw	fp,0(sp)
 82155bc:	dec00204 	addi	sp,sp,8
 82155c0:	f800283a 	ret

082155c4 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 82155c4:	defff704 	addi	sp,sp,-36
 82155c8:	dfc00815 	stw	ra,32(sp)
 82155cc:	df000715 	stw	fp,28(sp)
 82155d0:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 82155d4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 82155d8:	823ccb40 	call	823ccb4 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82155dc:	0005303a 	rdctl	r2,status
 82155e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82155e4:	e0fffd17 	ldw	r3,-12(fp)
 82155e8:	00bfff84 	movi	r2,-2
 82155ec:	1884703a 	and	r2,r3,r2
 82155f0:	1001703a 	wrctl	status,r2
  
  return context;
 82155f4:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 82155f8:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 82155fc:	d0a07b17 	ldw	r2,-32276(gp)
 8215600:	10800044 	addi	r2,r2,1
 8215604:	d0a07b15 	stw	r2,-32276(gp)
 8215608:	e0bffb17 	ldw	r2,-20(fp)
 821560c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215610:	e0bfff17 	ldw	r2,-4(fp)
 8215614:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 8215618:	d0a06b43 	ldbu	r2,-32339(gp)
 821561c:	10803fcc 	andi	r2,r2,255
 8215620:	10800058 	cmpnei	r2,r2,1
 8215624:	10006a1e 	bne	r2,zero,82157d0 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 8215628:	d0a06f03 	ldbu	r2,-32324(gp)
 821562c:	10803fcc 	andi	r2,r2,255
 8215630:	10c00060 	cmpeqi	r3,r2,1
 8215634:	1800061e 	bne	r3,zero,8215650 <OSTimeTick+0x8c>
 8215638:	10c000a0 	cmpeqi	r3,r2,2
 821563c:	1800061e 	bne	r3,zero,8215658 <OSTimeTick+0x94>
 8215640:	10000a1e 	bne	r2,zero,821566c <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 8215644:	00800044 	movi	r2,1
 8215648:	e0bffa05 	stb	r2,-24(fp)
                 break;
 821564c:	00000b06 	br	821567c <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 8215650:	e03ffa05 	stb	zero,-24(fp)
                 break;
 8215654:	00000906 	br	821567c <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 8215658:	00800044 	movi	r2,1
 821565c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 8215660:	00800044 	movi	r2,1
 8215664:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 8215668:	00000406 	br	821567c <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 821566c:	00800044 	movi	r2,1
 8215670:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 8215674:	d0206f05 	stb	zero,-32324(gp)
                 break;
 8215678:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 821567c:	e0bffa03 	ldbu	r2,-24(fp)
 8215680:	10005226 	beq	r2,zero,82157cc <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 8215684:	d0a06e17 	ldw	r2,-32328(gp)
 8215688:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 821568c:	00004906 	br	82157b4 <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215690:	0005303a 	rdctl	r2,status
 8215694:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215698:	e0fffc17 	ldw	r3,-16(fp)
 821569c:	00bfff84 	movi	r2,-2
 82156a0:	1884703a 	and	r2,r3,r2
 82156a4:	1001703a 	wrctl	status,r2
  
  return context;
 82156a8:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
 82156ac:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 82156b0:	e0bff917 	ldw	r2,-28(fp)
 82156b4:	10800b8b 	ldhu	r2,46(r2)
 82156b8:	10bfffcc 	andi	r2,r2,65535
 82156bc:	10003626 	beq	r2,zero,8215798 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 82156c0:	e0bff917 	ldw	r2,-28(fp)
 82156c4:	10800b8b 	ldhu	r2,46(r2)
 82156c8:	10bfffc4 	addi	r2,r2,-1
 82156cc:	1007883a 	mov	r3,r2
 82156d0:	e0bff917 	ldw	r2,-28(fp)
 82156d4:	10c00b8d 	sth	r3,46(r2)
 82156d8:	e0bff917 	ldw	r2,-28(fp)
 82156dc:	10800b8b 	ldhu	r2,46(r2)
 82156e0:	10bfffcc 	andi	r2,r2,65535
 82156e4:	10002c1e 	bne	r2,zero,8215798 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 82156e8:	e0bff917 	ldw	r2,-28(fp)
 82156ec:	10800c03 	ldbu	r2,48(r2)
 82156f0:	10803fcc 	andi	r2,r2,255
 82156f4:	10800dcc 	andi	r2,r2,55
 82156f8:	10000b26 	beq	r2,zero,8215728 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 82156fc:	e0bff917 	ldw	r2,-28(fp)
 8215700:	10c00c03 	ldbu	r3,48(r2)
 8215704:	00bff204 	movi	r2,-56
 8215708:	1884703a 	and	r2,r3,r2
 821570c:	1007883a 	mov	r3,r2
 8215710:	e0bff917 	ldw	r2,-28(fp)
 8215714:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 8215718:	e0bff917 	ldw	r2,-28(fp)
 821571c:	00c00044 	movi	r3,1
 8215720:	10c00c45 	stb	r3,49(r2)
 8215724:	00000206 	br	8215730 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 8215728:	e0bff917 	ldw	r2,-28(fp)
 821572c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 8215730:	e0bff917 	ldw	r2,-28(fp)
 8215734:	10800c03 	ldbu	r2,48(r2)
 8215738:	10803fcc 	andi	r2,r2,255
 821573c:	1080020c 	andi	r2,r2,8
 8215740:	1000151e 	bne	r2,zero,8215798 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 8215744:	e0bff917 	ldw	r2,-28(fp)
 8215748:	10c00d83 	ldbu	r3,54(r2)
 821574c:	d0a07703 	ldbu	r2,-32292(gp)
 8215750:	1884b03a 	or	r2,r3,r2
 8215754:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8215758:	e0bff917 	ldw	r2,-28(fp)
 821575c:	10800d03 	ldbu	r2,52(r2)
 8215760:	10c03fcc 	andi	r3,r2,255
 8215764:	e0bff917 	ldw	r2,-28(fp)
 8215768:	10800d03 	ldbu	r2,52(r2)
 821576c:	11003fcc 	andi	r4,r2,255
 8215770:	d0a07744 	addi	r2,gp,-32291
 8215774:	2085883a 	add	r2,r4,r2
 8215778:	11000003 	ldbu	r4,0(r2)
 821577c:	e0bff917 	ldw	r2,-28(fp)
 8215780:	10800d43 	ldbu	r2,53(r2)
 8215784:	2084b03a 	or	r2,r4,r2
 8215788:	1009883a 	mov	r4,r2
 821578c:	d0a07744 	addi	r2,gp,-32291
 8215790:	1885883a 	add	r2,r3,r2
 8215794:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 8215798:	e0bff917 	ldw	r2,-28(fp)
 821579c:	10800517 	ldw	r2,20(r2)
 82157a0:	e0bff915 	stw	r2,-28(fp)
 82157a4:	e0bffb17 	ldw	r2,-20(fp)
 82157a8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82157ac:	e0bffe17 	ldw	r2,-8(fp)
 82157b0:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 82157b4:	e0bff917 	ldw	r2,-28(fp)
 82157b8:	10800c83 	ldbu	r2,50(r2)
 82157bc:	10803fcc 	andi	r2,r2,255
 82157c0:	10800518 	cmpnei	r2,r2,20
 82157c4:	103fb21e 	bne	r2,zero,8215690 <OSTimeTick+0xcc>
 82157c8:	00000106 	br	82157d0 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 82157cc:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 82157d0:	e037883a 	mov	sp,fp
 82157d4:	dfc00117 	ldw	ra,4(sp)
 82157d8:	df000017 	ldw	fp,0(sp)
 82157dc:	dec00204 	addi	sp,sp,8
 82157e0:	f800283a 	ret

082157e4 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 82157e4:	deffff04 	addi	sp,sp,-4
 82157e8:	df000015 	stw	fp,0(sp)
 82157ec:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 82157f0:	00804784 	movi	r2,286
}
 82157f4:	e037883a 	mov	sp,fp
 82157f8:	df000017 	ldw	fp,0(sp)
 82157fc:	dec00104 	addi	sp,sp,4
 8215800:	f800283a 	ret

08215804 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 8215804:	deffff04 	addi	sp,sp,-4
 8215808:	df000015 	stw	fp,0(sp)
 821580c:	d839883a 	mov	fp,sp
}
 8215810:	0001883a 	nop
 8215814:	e037883a 	mov	sp,fp
 8215818:	df000017 	ldw	fp,0(sp)
 821581c:	dec00104 	addi	sp,sp,4
 8215820:	f800283a 	ret

08215824 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 8215824:	defff804 	addi	sp,sp,-32
 8215828:	dfc00715 	stw	ra,28(sp)
 821582c:	df000615 	stw	fp,24(sp)
 8215830:	df000604 	addi	fp,sp,24
 8215834:	e13ffc15 	stw	r4,-16(fp)
 8215838:	e17ffd15 	stw	r5,-12(fp)
 821583c:	3007883a 	mov	r3,r6
 8215840:	3805883a 	mov	r2,r7
 8215844:	e0fffe05 	stb	r3,-8(fp)
 8215848:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 821584c:	e0bffc17 	ldw	r2,-16(fp)
 8215850:	10800283 	ldbu	r2,10(r2)
 8215854:	10c03fcc 	andi	r3,r2,255
 8215858:	00820974 	movhi	r2,2085
 821585c:	10b69f04 	addi	r2,r2,-9604
 8215860:	10c5883a 	add	r2,r2,r3
 8215864:	10800003 	ldbu	r2,0(r2)
 8215868:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 821586c:	e0bffa03 	ldbu	r2,-24(fp)
 8215870:	e0fffc17 	ldw	r3,-16(fp)
 8215874:	1885883a 	add	r2,r3,r2
 8215878:	108002c4 	addi	r2,r2,11
 821587c:	10800003 	ldbu	r2,0(r2)
 8215880:	10c03fcc 	andi	r3,r2,255
 8215884:	00820974 	movhi	r2,2085
 8215888:	10b69f04 	addi	r2,r2,-9604
 821588c:	10c5883a 	add	r2,r2,r3
 8215890:	10800003 	ldbu	r2,0(r2)
 8215894:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 8215898:	e0bffa03 	ldbu	r2,-24(fp)
 821589c:	100490fa 	slli	r2,r2,3
 82158a0:	1007883a 	mov	r3,r2
 82158a4:	e0bffa43 	ldbu	r2,-23(fp)
 82158a8:	1885883a 	add	r2,r3,r2
 82158ac:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 82158b0:	e0fffa83 	ldbu	r3,-22(fp)
 82158b4:	008209b4 	movhi	r2,2086
 82158b8:	10b5c804 	addi	r2,r2,-10464
 82158bc:	18c7883a 	add	r3,r3,r3
 82158c0:	18c7883a 	add	r3,r3,r3
 82158c4:	10c5883a 	add	r2,r2,r3
 82158c8:	10800017 	ldw	r2,0(r2)
 82158cc:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 82158d0:	e0bffb17 	ldw	r2,-20(fp)
 82158d4:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 82158d8:	e0bffb17 	ldw	r2,-20(fp)
 82158dc:	e0fffd17 	ldw	r3,-12(fp)
 82158e0:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 82158e4:	e0bffb17 	ldw	r2,-20(fp)
 82158e8:	10800c03 	ldbu	r2,48(r2)
 82158ec:	1007883a 	mov	r3,r2
 82158f0:	e0bffe03 	ldbu	r2,-8(fp)
 82158f4:	0084303a 	nor	r2,zero,r2
 82158f8:	1884703a 	and	r2,r3,r2
 82158fc:	1007883a 	mov	r3,r2
 8215900:	e0bffb17 	ldw	r2,-20(fp)
 8215904:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 8215908:	e0bffb17 	ldw	r2,-20(fp)
 821590c:	e0ffff03 	ldbu	r3,-4(fp)
 8215910:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 8215914:	e0bffb17 	ldw	r2,-20(fp)
 8215918:	10800c03 	ldbu	r2,48(r2)
 821591c:	10803fcc 	andi	r2,r2,255
 8215920:	1080020c 	andi	r2,r2,8
 8215924:	1000111e 	bne	r2,zero,821596c <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 8215928:	e0bffb17 	ldw	r2,-20(fp)
 821592c:	10c00d83 	ldbu	r3,54(r2)
 8215930:	d0a07703 	ldbu	r2,-32292(gp)
 8215934:	1884b03a 	or	r2,r3,r2
 8215938:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 821593c:	e0fffa03 	ldbu	r3,-24(fp)
 8215940:	e13ffa03 	ldbu	r4,-24(fp)
 8215944:	d0a07744 	addi	r2,gp,-32291
 8215948:	2085883a 	add	r2,r4,r2
 821594c:	11000003 	ldbu	r4,0(r2)
 8215950:	e0bffb17 	ldw	r2,-20(fp)
 8215954:	10800d43 	ldbu	r2,53(r2)
 8215958:	2084b03a 	or	r2,r4,r2
 821595c:	1009883a 	mov	r4,r2
 8215960:	d0a07744 	addi	r2,gp,-32291
 8215964:	1885883a 	add	r2,r3,r2
 8215968:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 821596c:	e17ffc17 	ldw	r5,-16(fp)
 8215970:	e13ffb17 	ldw	r4,-20(fp)
 8215974:	8215c1c0 	call	8215c1c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 8215978:	e0bffb17 	ldw	r2,-20(fp)
 821597c:	10800817 	ldw	r2,32(r2)
 8215980:	10000826 	beq	r2,zero,82159a4 <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 8215984:	e0bffb17 	ldw	r2,-20(fp)
 8215988:	10800817 	ldw	r2,32(r2)
 821598c:	100b883a 	mov	r5,r2
 8215990:	e13ffb17 	ldw	r4,-20(fp)
 8215994:	8215cd40 	call	8215cd4 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 8215998:	e0bffb17 	ldw	r2,-20(fp)
 821599c:	e0fffc17 	ldw	r3,-16(fp)
 82159a0:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 82159a4:	e0bffa83 	ldbu	r2,-22(fp)
}
 82159a8:	e037883a 	mov	sp,fp
 82159ac:	dfc00117 	ldw	ra,4(sp)
 82159b0:	df000017 	ldw	fp,0(sp)
 82159b4:	dec00204 	addi	sp,sp,8
 82159b8:	f800283a 	ret

082159bc <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 82159bc:	defffd04 	addi	sp,sp,-12
 82159c0:	df000215 	stw	fp,8(sp)
 82159c4:	df000204 	addi	fp,sp,8
 82159c8:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 82159cc:	d0a07a17 	ldw	r2,-32280(gp)
 82159d0:	e0ffff17 	ldw	r3,-4(fp)
 82159d4:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 82159d8:	d0a07a17 	ldw	r2,-32280(gp)
 82159dc:	10800d03 	ldbu	r2,52(r2)
 82159e0:	10803fcc 	andi	r2,r2,255
 82159e4:	d0e07a17 	ldw	r3,-32280(gp)
 82159e8:	18c00d03 	ldbu	r3,52(r3)
 82159ec:	18c03fcc 	andi	r3,r3,255
 82159f0:	e13fff17 	ldw	r4,-4(fp)
 82159f4:	20c7883a 	add	r3,r4,r3
 82159f8:	18c002c4 	addi	r3,r3,11
 82159fc:	19000003 	ldbu	r4,0(r3)
 8215a00:	d0e07a17 	ldw	r3,-32280(gp)
 8215a04:	18c00d43 	ldbu	r3,53(r3)
 8215a08:	20c6b03a 	or	r3,r4,r3
 8215a0c:	1809883a 	mov	r4,r3
 8215a10:	e0ffff17 	ldw	r3,-4(fp)
 8215a14:	1885883a 	add	r2,r3,r2
 8215a18:	108002c4 	addi	r2,r2,11
 8215a1c:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215a20:	e0bfff17 	ldw	r2,-4(fp)
 8215a24:	10c00283 	ldbu	r3,10(r2)
 8215a28:	d0a07a17 	ldw	r2,-32280(gp)
 8215a2c:	10800d83 	ldbu	r2,54(r2)
 8215a30:	1884b03a 	or	r2,r3,r2
 8215a34:	1007883a 	mov	r3,r2
 8215a38:	e0bfff17 	ldw	r2,-4(fp)
 8215a3c:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215a40:	d0a07a17 	ldw	r2,-32280(gp)
 8215a44:	10800d03 	ldbu	r2,52(r2)
 8215a48:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215a4c:	e0fffe03 	ldbu	r3,-8(fp)
 8215a50:	e13ffe03 	ldbu	r4,-8(fp)
 8215a54:	d0a07744 	addi	r2,gp,-32291
 8215a58:	2085883a 	add	r2,r4,r2
 8215a5c:	10800003 	ldbu	r2,0(r2)
 8215a60:	1009883a 	mov	r4,r2
 8215a64:	d0a07a17 	ldw	r2,-32280(gp)
 8215a68:	10800d43 	ldbu	r2,53(r2)
 8215a6c:	0084303a 	nor	r2,zero,r2
 8215a70:	2084703a 	and	r2,r4,r2
 8215a74:	1009883a 	mov	r4,r2
 8215a78:	d0a07744 	addi	r2,gp,-32291
 8215a7c:	1885883a 	add	r2,r3,r2
 8215a80:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215a84:	e0fffe03 	ldbu	r3,-8(fp)
 8215a88:	d0a07744 	addi	r2,gp,-32291
 8215a8c:	1885883a 	add	r2,r3,r2
 8215a90:	10800003 	ldbu	r2,0(r2)
 8215a94:	10803fcc 	andi	r2,r2,255
 8215a98:	1000071e 	bne	r2,zero,8215ab8 <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215a9c:	d0a07a17 	ldw	r2,-32280(gp)
 8215aa0:	10800d83 	ldbu	r2,54(r2)
 8215aa4:	0084303a 	nor	r2,zero,r2
 8215aa8:	1007883a 	mov	r3,r2
 8215aac:	d0a07703 	ldbu	r2,-32292(gp)
 8215ab0:	1884703a 	and	r2,r3,r2
 8215ab4:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215ab8:	0001883a 	nop
 8215abc:	e037883a 	mov	sp,fp
 8215ac0:	df000017 	ldw	fp,0(sp)
 8215ac4:	dec00104 	addi	sp,sp,4
 8215ac8:	f800283a 	ret

08215acc <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 8215acc:	defffb04 	addi	sp,sp,-20
 8215ad0:	df000415 	stw	fp,16(sp)
 8215ad4:	df000404 	addi	fp,sp,16
 8215ad8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 8215adc:	d0a07a17 	ldw	r2,-32280(gp)
 8215ae0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 8215ae4:	d0a07a17 	ldw	r2,-32280(gp)
 8215ae8:	e0ffff17 	ldw	r3,-4(fp)
 8215aec:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 8215af0:	e0bfff17 	ldw	r2,-4(fp)
 8215af4:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 8215af8:	e0bffc17 	ldw	r2,-16(fp)
 8215afc:	10800017 	ldw	r2,0(r2)
 8215b00:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215b04:	00002006 	br	8215b88 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 8215b08:	d0a07a17 	ldw	r2,-32280(gp)
 8215b0c:	10800d03 	ldbu	r2,52(r2)
 8215b10:	10803fcc 	andi	r2,r2,255
 8215b14:	d0e07a17 	ldw	r3,-32280(gp)
 8215b18:	18c00d03 	ldbu	r3,52(r3)
 8215b1c:	18c03fcc 	andi	r3,r3,255
 8215b20:	e13ffd17 	ldw	r4,-12(fp)
 8215b24:	20c7883a 	add	r3,r4,r3
 8215b28:	18c002c4 	addi	r3,r3,11
 8215b2c:	19000003 	ldbu	r4,0(r3)
 8215b30:	d0e07a17 	ldw	r3,-32280(gp)
 8215b34:	18c00d43 	ldbu	r3,53(r3)
 8215b38:	20c6b03a 	or	r3,r4,r3
 8215b3c:	1809883a 	mov	r4,r3
 8215b40:	e0fffd17 	ldw	r3,-12(fp)
 8215b44:	1885883a 	add	r2,r3,r2
 8215b48:	108002c4 	addi	r2,r2,11
 8215b4c:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215b50:	e0bffd17 	ldw	r2,-12(fp)
 8215b54:	10c00283 	ldbu	r3,10(r2)
 8215b58:	d0a07a17 	ldw	r2,-32280(gp)
 8215b5c:	10800d83 	ldbu	r2,54(r2)
 8215b60:	1884b03a 	or	r2,r3,r2
 8215b64:	1007883a 	mov	r3,r2
 8215b68:	e0bffd17 	ldw	r2,-12(fp)
 8215b6c:	10c00285 	stb	r3,10(r2)
        pevents++;
 8215b70:	e0bffc17 	ldw	r2,-16(fp)
 8215b74:	10800104 	addi	r2,r2,4
 8215b78:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 8215b7c:	e0bffc17 	ldw	r2,-16(fp)
 8215b80:	10800017 	ldw	r2,0(r2)
 8215b84:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215b88:	e0bffd17 	ldw	r2,-12(fp)
 8215b8c:	103fde1e 	bne	r2,zero,8215b08 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215b90:	d0a07a17 	ldw	r2,-32280(gp)
 8215b94:	10800d03 	ldbu	r2,52(r2)
 8215b98:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215b9c:	e0fffe03 	ldbu	r3,-8(fp)
 8215ba0:	e13ffe03 	ldbu	r4,-8(fp)
 8215ba4:	d0a07744 	addi	r2,gp,-32291
 8215ba8:	2085883a 	add	r2,r4,r2
 8215bac:	10800003 	ldbu	r2,0(r2)
 8215bb0:	1009883a 	mov	r4,r2
 8215bb4:	d0a07a17 	ldw	r2,-32280(gp)
 8215bb8:	10800d43 	ldbu	r2,53(r2)
 8215bbc:	0084303a 	nor	r2,zero,r2
 8215bc0:	2084703a 	and	r2,r4,r2
 8215bc4:	1009883a 	mov	r4,r2
 8215bc8:	d0a07744 	addi	r2,gp,-32291
 8215bcc:	1885883a 	add	r2,r3,r2
 8215bd0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215bd4:	e0fffe03 	ldbu	r3,-8(fp)
 8215bd8:	d0a07744 	addi	r2,gp,-32291
 8215bdc:	1885883a 	add	r2,r3,r2
 8215be0:	10800003 	ldbu	r2,0(r2)
 8215be4:	10803fcc 	andi	r2,r2,255
 8215be8:	1000071e 	bne	r2,zero,8215c08 <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215bec:	d0a07a17 	ldw	r2,-32280(gp)
 8215bf0:	10800d83 	ldbu	r2,54(r2)
 8215bf4:	0084303a 	nor	r2,zero,r2
 8215bf8:	1007883a 	mov	r3,r2
 8215bfc:	d0a07703 	ldbu	r2,-32292(gp)
 8215c00:	1884703a 	and	r2,r3,r2
 8215c04:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215c08:	0001883a 	nop
 8215c0c:	e037883a 	mov	sp,fp
 8215c10:	df000017 	ldw	fp,0(sp)
 8215c14:	dec00104 	addi	sp,sp,4
 8215c18:	f800283a 	ret

08215c1c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 8215c1c:	defffc04 	addi	sp,sp,-16
 8215c20:	df000315 	stw	fp,12(sp)
 8215c24:	df000304 	addi	fp,sp,12
 8215c28:	e13ffe15 	stw	r4,-8(fp)
 8215c2c:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 8215c30:	e0bffe17 	ldw	r2,-8(fp)
 8215c34:	10800d03 	ldbu	r2,52(r2)
 8215c38:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 8215c3c:	e0bffd03 	ldbu	r2,-12(fp)
 8215c40:	e0fffd03 	ldbu	r3,-12(fp)
 8215c44:	e13fff17 	ldw	r4,-4(fp)
 8215c48:	20c7883a 	add	r3,r4,r3
 8215c4c:	18c002c4 	addi	r3,r3,11
 8215c50:	18c00003 	ldbu	r3,0(r3)
 8215c54:	1809883a 	mov	r4,r3
 8215c58:	e0fffe17 	ldw	r3,-8(fp)
 8215c5c:	18c00d43 	ldbu	r3,53(r3)
 8215c60:	00c6303a 	nor	r3,zero,r3
 8215c64:	20c6703a 	and	r3,r4,r3
 8215c68:	1809883a 	mov	r4,r3
 8215c6c:	e0ffff17 	ldw	r3,-4(fp)
 8215c70:	1885883a 	add	r2,r3,r2
 8215c74:	108002c4 	addi	r2,r2,11
 8215c78:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
 8215c7c:	e0bffd03 	ldbu	r2,-12(fp)
 8215c80:	e0ffff17 	ldw	r3,-4(fp)
 8215c84:	1885883a 	add	r2,r3,r2
 8215c88:	108002c4 	addi	r2,r2,11
 8215c8c:	10800003 	ldbu	r2,0(r2)
 8215c90:	10803fcc 	andi	r2,r2,255
 8215c94:	10000a1e 	bne	r2,zero,8215cc0 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 8215c98:	e0bfff17 	ldw	r2,-4(fp)
 8215c9c:	10800283 	ldbu	r2,10(r2)
 8215ca0:	1007883a 	mov	r3,r2
 8215ca4:	e0bffe17 	ldw	r2,-8(fp)
 8215ca8:	10800d83 	ldbu	r2,54(r2)
 8215cac:	0084303a 	nor	r2,zero,r2
 8215cb0:	1884703a 	and	r2,r3,r2
 8215cb4:	1007883a 	mov	r3,r2
 8215cb8:	e0bfff17 	ldw	r2,-4(fp)
 8215cbc:	10c00285 	stb	r3,10(r2)
    }
}
 8215cc0:	0001883a 	nop
 8215cc4:	e037883a 	mov	sp,fp
 8215cc8:	df000017 	ldw	fp,0(sp)
 8215ccc:	dec00104 	addi	sp,sp,4
 8215cd0:	f800283a 	ret

08215cd4 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 8215cd4:	defffa04 	addi	sp,sp,-24
 8215cd8:	df000515 	stw	fp,20(sp)
 8215cdc:	df000504 	addi	fp,sp,20
 8215ce0:	e13ffe15 	stw	r4,-8(fp)
 8215ce4:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 8215ce8:	e0bffe17 	ldw	r2,-8(fp)
 8215cec:	10800d03 	ldbu	r2,52(r2)
 8215cf0:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 8215cf4:	e0bffe17 	ldw	r2,-8(fp)
 8215cf8:	10800d83 	ldbu	r2,54(r2)
 8215cfc:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 8215d00:	e0bffe17 	ldw	r2,-8(fp)
 8215d04:	10800d43 	ldbu	r2,53(r2)
 8215d08:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 8215d0c:	e0bfff17 	ldw	r2,-4(fp)
 8215d10:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 8215d14:	e0bffb17 	ldw	r2,-20(fp)
 8215d18:	10800017 	ldw	r2,0(r2)
 8215d1c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215d20:	00002506 	br	8215db8 <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
 8215d24:	e0bffd03 	ldbu	r2,-12(fp)
 8215d28:	e0fffd03 	ldbu	r3,-12(fp)
 8215d2c:	e13ffc17 	ldw	r4,-16(fp)
 8215d30:	20c7883a 	add	r3,r4,r3
 8215d34:	18c002c4 	addi	r3,r3,11
 8215d38:	18c00003 	ldbu	r3,0(r3)
 8215d3c:	1809883a 	mov	r4,r3
 8215d40:	e0fffd83 	ldbu	r3,-10(fp)
 8215d44:	00c6303a 	nor	r3,zero,r3
 8215d48:	20c6703a 	and	r3,r4,r3
 8215d4c:	1809883a 	mov	r4,r3
 8215d50:	e0fffc17 	ldw	r3,-16(fp)
 8215d54:	1885883a 	add	r2,r3,r2
 8215d58:	108002c4 	addi	r2,r2,11
 8215d5c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
 8215d60:	e0bffd03 	ldbu	r2,-12(fp)
 8215d64:	e0fffc17 	ldw	r3,-16(fp)
 8215d68:	1885883a 	add	r2,r3,r2
 8215d6c:	108002c4 	addi	r2,r2,11
 8215d70:	10800003 	ldbu	r2,0(r2)
 8215d74:	10803fcc 	andi	r2,r2,255
 8215d78:	1000091e 	bne	r2,zero,8215da0 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
 8215d7c:	e0bffc17 	ldw	r2,-16(fp)
 8215d80:	10800283 	ldbu	r2,10(r2)
 8215d84:	1007883a 	mov	r3,r2
 8215d88:	e0bffd43 	ldbu	r2,-11(fp)
 8215d8c:	0084303a 	nor	r2,zero,r2
 8215d90:	1884703a 	and	r2,r3,r2
 8215d94:	1007883a 	mov	r3,r2
 8215d98:	e0bffc17 	ldw	r2,-16(fp)
 8215d9c:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 8215da0:	e0bffb17 	ldw	r2,-20(fp)
 8215da4:	10800104 	addi	r2,r2,4
 8215da8:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 8215dac:	e0bffb17 	ldw	r2,-20(fp)
 8215db0:	10800017 	ldw	r2,0(r2)
 8215db4:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215db8:	e0bffc17 	ldw	r2,-16(fp)
 8215dbc:	103fd91e 	bne	r2,zero,8215d24 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 8215dc0:	0001883a 	nop
 8215dc4:	e037883a 	mov	sp,fp
 8215dc8:	df000017 	ldw	fp,0(sp)
 8215dcc:	dec00104 	addi	sp,sp,4
 8215dd0:	f800283a 	ret

08215dd4 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 8215dd4:	defffc04 	addi	sp,sp,-16
 8215dd8:	df000315 	stw	fp,12(sp)
 8215ddc:	df000304 	addi	fp,sp,12
 8215de0:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 8215de4:	e0bfff17 	ldw	r2,-4(fp)
 8215de8:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 8215dec:	e0bfff17 	ldw	r2,-4(fp)
 8215df0:	108002c4 	addi	r2,r2,11
 8215df4:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8215df8:	e03ffe05 	stb	zero,-8(fp)
 8215dfc:	00000706 	br	8215e1c <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
 8215e00:	e0bffd17 	ldw	r2,-12(fp)
 8215e04:	10c00044 	addi	r3,r2,1
 8215e08:	e0fffd15 	stw	r3,-12(fp)
 8215e0c:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8215e10:	e0bffe03 	ldbu	r2,-8(fp)
 8215e14:	10800044 	addi	r2,r2,1
 8215e18:	e0bffe05 	stb	r2,-8(fp)
 8215e1c:	e0bffe03 	ldbu	r2,-8(fp)
 8215e20:	108000f0 	cmpltui	r2,r2,3
 8215e24:	103ff61e 	bne	r2,zero,8215e00 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 8215e28:	0001883a 	nop
 8215e2c:	e037883a 	mov	sp,fp
 8215e30:	df000017 	ldw	fp,0(sp)
 8215e34:	dec00104 	addi	sp,sp,4
 8215e38:	f800283a 	ret

08215e3c <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 8215e3c:	defffb04 	addi	sp,sp,-20
 8215e40:	dfc00415 	stw	ra,16(sp)
 8215e44:	df000315 	stw	fp,12(sp)
 8215e48:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 8215e4c:	0142d004 	movi	r5,2880
 8215e50:	010209b4 	movhi	r4,2086
 8215e54:	2131b404 	addi	r4,r4,-14640
 8215e58:	82161b40 	call	82161b4 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 8215e5c:	008209b4 	movhi	r2,2086
 8215e60:	10b1b404 	addi	r2,r2,-14640
 8215e64:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 8215e68:	008209b4 	movhi	r2,2086
 8215e6c:	10b1c004 	addi	r2,r2,-14592
 8215e70:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8215e74:	e03ffd0d 	sth	zero,-12(fp)
 8215e78:	00001306 	br	8215ec8 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8215e7c:	e0bffe17 	ldw	r2,-8(fp)
 8215e80:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 8215e84:	e0bffe17 	ldw	r2,-8(fp)
 8215e88:	e0ffff17 	ldw	r3,-4(fp)
 8215e8c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 8215e90:	e0bffe17 	ldw	r2,-8(fp)
 8215e94:	00c00fc4 	movi	r3,63
 8215e98:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 8215e9c:	e0bffe17 	ldw	r2,-8(fp)
 8215ea0:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 8215ea4:	e0bffe17 	ldw	r2,-8(fp)
 8215ea8:	10800c04 	addi	r2,r2,48
 8215eac:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 8215eb0:	e0bfff17 	ldw	r2,-4(fp)
 8215eb4:	10800c04 	addi	r2,r2,48
 8215eb8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8215ebc:	e0bffd0b 	ldhu	r2,-12(fp)
 8215ec0:	10800044 	addi	r2,r2,1
 8215ec4:	e0bffd0d 	sth	r2,-12(fp)
 8215ec8:	e0bffd0b 	ldhu	r2,-12(fp)
 8215ecc:	10800ef0 	cmpltui	r2,r2,59
 8215ed0:	103fea1e 	bne	r2,zero,8215e7c <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 8215ed4:	e0bffe17 	ldw	r2,-8(fp)
 8215ed8:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 8215edc:	e0bffe17 	ldw	r2,-8(fp)
 8215ee0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 8215ee4:	e0bffe17 	ldw	r2,-8(fp)
 8215ee8:	00c00fc4 	movi	r3,63
 8215eec:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 8215ef0:	e0bffe17 	ldw	r2,-8(fp)
 8215ef4:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 8215ef8:	008209b4 	movhi	r2,2086
 8215efc:	10b1b404 	addi	r2,r2,-14640
 8215f00:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 8215f04:	0001883a 	nop
 8215f08:	e037883a 	mov	sp,fp
 8215f0c:	dfc00117 	ldw	ra,4(sp)
 8215f10:	df000017 	ldw	fp,0(sp)
 8215f14:	dec00204 	addi	sp,sp,8
 8215f18:	f800283a 	ret

08215f1c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 8215f1c:	deffff04 	addi	sp,sp,-4
 8215f20:	df000015 	stw	fp,0(sp)
 8215f24:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 8215f28:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 8215f2c:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 8215f30:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 8215f34:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 8215f38:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 8215f3c:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 8215f40:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 8215f44:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 8215f48:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 8215f4c:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 8215f50:	0001883a 	nop
 8215f54:	e037883a 	mov	sp,fp
 8215f58:	df000017 	ldw	fp,0(sp)
 8215f5c:	dec00104 	addi	sp,sp,4
 8215f60:	f800283a 	ret

08215f64 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 8215f64:	defffd04 	addi	sp,sp,-12
 8215f68:	df000215 	stw	fp,8(sp)
 8215f6c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 8215f70:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 8215f74:	d0a07744 	addi	r2,gp,-32291
 8215f78:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 8215f7c:	e03ffe05 	stb	zero,-8(fp)
 8215f80:	00000706 	br	8215fa0 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
 8215f84:	e0bfff17 	ldw	r2,-4(fp)
 8215f88:	10c00044 	addi	r3,r2,1
 8215f8c:	e0ffff15 	stw	r3,-4(fp)
 8215f90:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 8215f94:	e0bffe03 	ldbu	r2,-8(fp)
 8215f98:	10800044 	addi	r2,r2,1
 8215f9c:	e0bffe05 	stb	r2,-8(fp)
 8215fa0:	e0bffe03 	ldbu	r2,-8(fp)
 8215fa4:	108000f0 	cmpltui	r2,r2,3
 8215fa8:	103ff61e 	bne	r2,zero,8215f84 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 8215fac:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 8215fb0:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 8215fb4:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 8215fb8:	d0207a15 	stw	zero,-32280(gp)
}
 8215fbc:	0001883a 	nop
 8215fc0:	e037883a 	mov	sp,fp
 8215fc4:	df000017 	ldw	fp,0(sp)
 8215fc8:	dec00104 	addi	sp,sp,4
 8215fcc:	f800283a 	ret

08215fd0 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 8215fd0:	defff804 	addi	sp,sp,-32
 8215fd4:	dfc00715 	stw	ra,28(sp)
 8215fd8:	df000615 	stw	fp,24(sp)
 8215fdc:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 8215fe0:	008000c4 	movi	r2,3
 8215fe4:	d8800415 	stw	r2,16(sp)
 8215fe8:	d8000315 	stw	zero,12(sp)
 8215fec:	00808004 	movi	r2,512
 8215ff0:	d8800215 	stw	r2,8(sp)
 8215ff4:	008209b4 	movhi	r2,2086
 8215ff8:	10afb404 	addi	r2,r2,-16688
 8215ffc:	d8800115 	stw	r2,4(sp)
 8216000:	00bfffd4 	movui	r2,65535
 8216004:	d8800015 	stw	r2,0(sp)
 8216008:	01c00504 	movi	r7,20
 821600c:	018209b4 	movhi	r6,2086
 8216010:	31b1b304 	addi	r6,r6,-14644
 8216014:	000b883a 	mov	r5,zero
 8216018:	01020874 	movhi	r4,2081
 821601c:	21191f04 	addi	r4,r4,25724
 8216020:	821ab540 	call	821ab54 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 8216024:	e1bfff04 	addi	r6,fp,-4
 8216028:	01420974 	movhi	r5,2085
 821602c:	2976df04 	addi	r5,r5,-9348
 8216030:	01000504 	movi	r4,20
 8216034:	821b3640 	call	821b364 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 8216038:	0001883a 	nop
 821603c:	e037883a 	mov	sp,fp
 8216040:	dfc00117 	ldw	ra,4(sp)
 8216044:	df000017 	ldw	fp,0(sp)
 8216048:	dec00204 	addi	sp,sp,8
 821604c:	f800283a 	ret

08216050 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 8216050:	defff804 	addi	sp,sp,-32
 8216054:	dfc00715 	stw	ra,28(sp)
 8216058:	df000615 	stw	fp,24(sp)
 821605c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 8216060:	008000c4 	movi	r2,3
 8216064:	d8800415 	stw	r2,16(sp)
 8216068:	d8000315 	stw	zero,12(sp)
 821606c:	00808004 	movi	r2,512
 8216070:	d8800215 	stw	r2,8(sp)
 8216074:	008209b4 	movhi	r2,2086
 8216078:	10ad3c04 	addi	r2,r2,-19216
 821607c:	d8800115 	stw	r2,4(sp)
 8216080:	00bfff94 	movui	r2,65534
 8216084:	d8800015 	stw	r2,0(sp)
 8216088:	01c004c4 	movi	r7,19
 821608c:	018209b4 	movhi	r6,2086
 8216090:	31af3b04 	addi	r6,r6,-17172
 8216094:	000b883a 	mov	r5,zero
 8216098:	01020874 	movhi	r4,2081
 821609c:	21193604 	addi	r4,r4,25816
 82160a0:	821ab540 	call	821ab54 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 82160a4:	e1bfff04 	addi	r6,fp,-4
 82160a8:	01420974 	movhi	r5,2085
 82160ac:	2976e304 	addi	r5,r5,-9332
 82160b0:	010004c4 	movi	r4,19
 82160b4:	821b3640 	call	821b364 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 82160b8:	0001883a 	nop
 82160bc:	e037883a 	mov	sp,fp
 82160c0:	dfc00117 	ldw	ra,4(sp)
 82160c4:	df000017 	ldw	fp,0(sp)
 82160c8:	dec00204 	addi	sp,sp,8
 82160cc:	f800283a 	ret

082160d0 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 82160d0:	defffb04 	addi	sp,sp,-20
 82160d4:	dfc00415 	stw	ra,16(sp)
 82160d8:	df000315 	stw	fp,12(sp)
 82160dc:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 82160e0:	01414404 	movi	r5,1296
 82160e4:	010209b4 	movhi	r4,2086
 82160e8:	21348404 	addi	r4,r4,-11760
 82160ec:	82161b40 	call	82161b4 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 82160f0:	01401504 	movi	r5,84
 82160f4:	010209b4 	movhi	r4,2086
 82160f8:	2135c804 	addi	r4,r4,-10464
 82160fc:	82161b40 	call	82161b4 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 8216100:	008209b4 	movhi	r2,2086
 8216104:	10b48404 	addi	r2,r2,-11760
 8216108:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 821610c:	008209b4 	movhi	r2,2086
 8216110:	10b49f04 	addi	r2,r2,-11652
 8216114:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216118:	e03ffd05 	stb	zero,-12(fp)
 821611c:	00001106 	br	8216164 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 8216120:	e0bffe17 	ldw	r2,-8(fp)
 8216124:	e0ffff17 	ldw	r3,-4(fp)
 8216128:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 821612c:	e0bffe17 	ldw	r2,-8(fp)
 8216130:	00c00fc4 	movi	r3,63
 8216134:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216138:	e0bffe17 	ldw	r2,-8(fp)
 821613c:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 8216140:	e0bffe17 	ldw	r2,-8(fp)
 8216144:	10801b04 	addi	r2,r2,108
 8216148:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 821614c:	e0bfff17 	ldw	r2,-4(fp)
 8216150:	10801b04 	addi	r2,r2,108
 8216154:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216158:	e0bffd03 	ldbu	r2,-12(fp)
 821615c:	10800044 	addi	r2,r2,1
 8216160:	e0bffd05 	stb	r2,-12(fp)
 8216164:	e0bffd03 	ldbu	r2,-12(fp)
 8216168:	108002f0 	cmpltui	r2,r2,11
 821616c:	103fec1e 	bne	r2,zero,8216120 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 8216170:	e0bffe17 	ldw	r2,-8(fp)
 8216174:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 8216178:	e0bffe17 	ldw	r2,-8(fp)
 821617c:	00c00fc4 	movi	r3,63
 8216180:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216184:	e0bffe17 	ldw	r2,-8(fp)
 8216188:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 821618c:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 8216190:	008209b4 	movhi	r2,2086
 8216194:	10b48404 	addi	r2,r2,-11760
 8216198:	d0a07215 	stw	r2,-32312(gp)
}
 821619c:	0001883a 	nop
 82161a0:	e037883a 	mov	sp,fp
 82161a4:	dfc00117 	ldw	ra,4(sp)
 82161a8:	df000017 	ldw	fp,0(sp)
 82161ac:	dec00204 	addi	sp,sp,8
 82161b0:	f800283a 	ret

082161b4 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 82161b4:	defffd04 	addi	sp,sp,-12
 82161b8:	df000215 	stw	fp,8(sp)
 82161bc:	df000204 	addi	fp,sp,8
 82161c0:	e13ffe15 	stw	r4,-8(fp)
 82161c4:	2805883a 	mov	r2,r5
 82161c8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 82161cc:	00000706 	br	82161ec <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 82161d0:	e0bffe17 	ldw	r2,-8(fp)
 82161d4:	10c00044 	addi	r3,r2,1
 82161d8:	e0fffe15 	stw	r3,-8(fp)
 82161dc:	10000005 	stb	zero,0(r2)
        size--;
 82161e0:	e0bfff0b 	ldhu	r2,-4(fp)
 82161e4:	10bfffc4 	addi	r2,r2,-1
 82161e8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 82161ec:	e0bfff0b 	ldhu	r2,-4(fp)
 82161f0:	103ff71e 	bne	r2,zero,82161d0 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 82161f4:	0001883a 	nop
 82161f8:	e037883a 	mov	sp,fp
 82161fc:	df000017 	ldw	fp,0(sp)
 8216200:	dec00104 	addi	sp,sp,4
 8216204:	f800283a 	ret

08216208 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 8216208:	defffc04 	addi	sp,sp,-16
 821620c:	df000315 	stw	fp,12(sp)
 8216210:	df000304 	addi	fp,sp,12
 8216214:	e13ffd15 	stw	r4,-12(fp)
 8216218:	e17ffe15 	stw	r5,-8(fp)
 821621c:	3005883a 	mov	r2,r6
 8216220:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 8216224:	00000b06 	br	8216254 <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
 8216228:	e0bffd17 	ldw	r2,-12(fp)
 821622c:	10c00044 	addi	r3,r2,1
 8216230:	e0fffd15 	stw	r3,-12(fp)
 8216234:	e0fffe17 	ldw	r3,-8(fp)
 8216238:	19000044 	addi	r4,r3,1
 821623c:	e13ffe15 	stw	r4,-8(fp)
 8216240:	18c00003 	ldbu	r3,0(r3)
 8216244:	10c00005 	stb	r3,0(r2)
        size--;
 8216248:	e0bfff0b 	ldhu	r2,-4(fp)
 821624c:	10bfffc4 	addi	r2,r2,-1
 8216250:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 8216254:	e0bfff0b 	ldhu	r2,-4(fp)
 8216258:	103ff31e 	bne	r2,zero,8216228 <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 821625c:	0001883a 	nop
 8216260:	e037883a 	mov	sp,fp
 8216264:	df000017 	ldw	fp,0(sp)
 8216268:	dec00104 	addi	sp,sp,4
 821626c:	f800283a 	ret

08216270 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 8216270:	defffb04 	addi	sp,sp,-20
 8216274:	dfc00415 	stw	ra,16(sp)
 8216278:	df000315 	stw	fp,12(sp)
 821627c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8216280:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216284:	0005303a 	rdctl	r2,status
 8216288:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821628c:	e0ffff17 	ldw	r3,-4(fp)
 8216290:	00bfff84 	movi	r2,-2
 8216294:	1884703a 	and	r2,r3,r2
 8216298:	1001703a 	wrctl	status,r2
  
  return context;
 821629c:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
 82162a0:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 82162a4:	d0a07903 	ldbu	r2,-32284(gp)
 82162a8:	10803fcc 	andi	r2,r2,255
 82162ac:	10001a1e 	bne	r2,zero,8216318 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 82162b0:	d0a06b03 	ldbu	r2,-32340(gp)
 82162b4:	10803fcc 	andi	r2,r2,255
 82162b8:	1000171e 	bne	r2,zero,8216318 <OS_Sched+0xa8>
            OS_SchedNew();
 82162bc:	82163400 	call	8216340 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 82162c0:	d0e06d03 	ldbu	r3,-32332(gp)
 82162c4:	d0a06d43 	ldbu	r2,-32331(gp)
 82162c8:	18c03fcc 	andi	r3,r3,255
 82162cc:	10803fcc 	andi	r2,r2,255
 82162d0:	18801126 	beq	r3,r2,8216318 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 82162d4:	d0a06d03 	ldbu	r2,-32332(gp)
 82162d8:	10c03fcc 	andi	r3,r2,255
 82162dc:	008209b4 	movhi	r2,2086
 82162e0:	10b5c804 	addi	r2,r2,-10464
 82162e4:	18c7883a 	add	r3,r3,r3
 82162e8:	18c7883a 	add	r3,r3,r3
 82162ec:	10c5883a 	add	r2,r2,r3
 82162f0:	10800017 	ldw	r2,0(r2)
 82162f4:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 82162f8:	d0a07517 	ldw	r2,-32300(gp)
 82162fc:	10c00e17 	ldw	r3,56(r2)
 8216300:	18c00044 	addi	r3,r3,1
 8216304:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 8216308:	d0a07017 	ldw	r2,-32320(gp)
 821630c:	10800044 	addi	r2,r2,1
 8216310:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 8216314:	823ca000 	call	823ca00 <OSCtxSw>
 8216318:	e0bffd17 	ldw	r2,-12(fp)
 821631c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216320:	e0bffe17 	ldw	r2,-8(fp)
 8216324:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 8216328:	0001883a 	nop
 821632c:	e037883a 	mov	sp,fp
 8216330:	dfc00117 	ldw	ra,4(sp)
 8216334:	df000017 	ldw	fp,0(sp)
 8216338:	dec00204 	addi	sp,sp,8
 821633c:	f800283a 	ret

08216340 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 8216340:	defffe04 	addi	sp,sp,-8
 8216344:	df000115 	stw	fp,4(sp)
 8216348:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 821634c:	d0a07703 	ldbu	r2,-32292(gp)
 8216350:	10c03fcc 	andi	r3,r2,255
 8216354:	00820974 	movhi	r2,2085
 8216358:	10b69f04 	addi	r2,r2,-9604
 821635c:	10c5883a 	add	r2,r2,r3
 8216360:	10800003 	ldbu	r2,0(r2)
 8216364:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 8216368:	e0bfff03 	ldbu	r2,-4(fp)
 821636c:	100490fa 	slli	r2,r2,3
 8216370:	1009883a 	mov	r4,r2
 8216374:	e0ffff03 	ldbu	r3,-4(fp)
 8216378:	d0a07744 	addi	r2,gp,-32291
 821637c:	1885883a 	add	r2,r3,r2
 8216380:	10800003 	ldbu	r2,0(r2)
 8216384:	10c03fcc 	andi	r3,r2,255
 8216388:	00820974 	movhi	r2,2085
 821638c:	10b69f04 	addi	r2,r2,-9604
 8216390:	10c5883a 	add	r2,r2,r3
 8216394:	10800003 	ldbu	r2,0(r2)
 8216398:	2085883a 	add	r2,r4,r2
 821639c:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 82163a0:	0001883a 	nop
 82163a4:	e037883a 	mov	sp,fp
 82163a8:	df000017 	ldw	fp,0(sp)
 82163ac:	dec00104 	addi	sp,sp,4
 82163b0:	f800283a 	ret

082163b4 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 82163b4:	defffc04 	addi	sp,sp,-16
 82163b8:	df000315 	stw	fp,12(sp)
 82163bc:	df000304 	addi	fp,sp,12
 82163c0:	e13ffe15 	stw	r4,-8(fp)
 82163c4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 82163c8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 82163cc:	00000b06 	br	82163fc <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
 82163d0:	e0bffe17 	ldw	r2,-8(fp)
 82163d4:	10c00044 	addi	r3,r2,1
 82163d8:	e0fffe15 	stw	r3,-8(fp)
 82163dc:	e0ffff17 	ldw	r3,-4(fp)
 82163e0:	19000044 	addi	r4,r3,1
 82163e4:	e13fff15 	stw	r4,-4(fp)
 82163e8:	18c00003 	ldbu	r3,0(r3)
 82163ec:	10c00005 	stb	r3,0(r2)
        len++;
 82163f0:	e0bffd03 	ldbu	r2,-12(fp)
 82163f4:	10800044 	addi	r2,r2,1
 82163f8:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 82163fc:	e0bfff17 	ldw	r2,-4(fp)
 8216400:	10800003 	ldbu	r2,0(r2)
 8216404:	10803fcc 	andi	r2,r2,255
 8216408:	103ff11e 	bne	r2,zero,82163d0 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 821640c:	e0bffe17 	ldw	r2,-8(fp)
 8216410:	10000005 	stb	zero,0(r2)
    return (len);
 8216414:	e0bffd03 	ldbu	r2,-12(fp)
}
 8216418:	e037883a 	mov	sp,fp
 821641c:	df000017 	ldw	fp,0(sp)
 8216420:	dec00104 	addi	sp,sp,4
 8216424:	f800283a 	ret

08216428 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 8216428:	defffd04 	addi	sp,sp,-12
 821642c:	df000215 	stw	fp,8(sp)
 8216430:	df000204 	addi	fp,sp,8
 8216434:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 8216438:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 821643c:	00000606 	br	8216458 <OS_StrLen+0x30>
        psrc++;
 8216440:	e0bfff17 	ldw	r2,-4(fp)
 8216444:	10800044 	addi	r2,r2,1
 8216448:	e0bfff15 	stw	r2,-4(fp)
        len++;
 821644c:	e0bffe03 	ldbu	r2,-8(fp)
 8216450:	10800044 	addi	r2,r2,1
 8216454:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 8216458:	e0bfff17 	ldw	r2,-4(fp)
 821645c:	10800003 	ldbu	r2,0(r2)
 8216460:	10803fcc 	andi	r2,r2,255
 8216464:	103ff61e 	bne	r2,zero,8216440 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 8216468:	e0bffe03 	ldbu	r2,-8(fp)
}
 821646c:	e037883a 	mov	sp,fp
 8216470:	df000017 	ldw	fp,0(sp)
 8216474:	dec00104 	addi	sp,sp,4
 8216478:	f800283a 	ret

0821647c <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 821647c:	defffa04 	addi	sp,sp,-24
 8216480:	dfc00515 	stw	ra,20(sp)
 8216484:	df000415 	stw	fp,16(sp)
 8216488:	df000404 	addi	fp,sp,16
 821648c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8216490:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216494:	0005303a 	rdctl	r2,status
 8216498:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821649c:	e0fffd17 	ldw	r3,-12(fp)
 82164a0:	00bfff84 	movi	r2,-2
 82164a4:	1884703a 	and	r2,r3,r2
 82164a8:	1001703a 	wrctl	status,r2
  
  return context;
 82164ac:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 82164b0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 82164b4:	d0a06c17 	ldw	r2,-32336(gp)
 82164b8:	10800044 	addi	r2,r2,1
 82164bc:	d0a06c15 	stw	r2,-32336(gp)
 82164c0:	e0bffc17 	ldw	r2,-16(fp)
 82164c4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82164c8:	e0bffe17 	ldw	r2,-8(fp)
 82164cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 82164d0:	823cd200 	call	823cd20 <OSTaskIdleHook>
    }
 82164d4:	003fef06 	br	8216494 <OS_TaskIdle+0x18>

082164d8 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 82164d8:	defff804 	addi	sp,sp,-32
 82164dc:	dfc00715 	stw	ra,28(sp)
 82164e0:	df000615 	stw	fp,24(sp)
 82164e4:	dc400515 	stw	r17,20(sp)
 82164e8:	dc000415 	stw	r16,16(sp)
 82164ec:	df000604 	addi	fp,sp,24
 82164f0:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82164f4:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 82164f8:	00000206 	br	8216504 <OS_TaskStat+0x2c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 82164fc:	01000504 	movi	r4,20
 8216500:	821bc240 	call	821bc24 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 8216504:	d0a07d03 	ldbu	r2,-32268(gp)
 8216508:	10803fcc 	andi	r2,r2,255
 821650c:	103ffb26 	beq	r2,zero,82164fc <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 8216510:	d0e07117 	ldw	r3,-32316(gp)
 8216514:	00947b34 	movhi	r2,20972
 8216518:	10a147c4 	addi	r2,r2,-31457
 821651c:	1888383a 	mulxuu	r4,r3,r2
 8216520:	1885383a 	mul	r2,r3,r2
 8216524:	1021883a 	mov	r16,r2
 8216528:	2023883a 	mov	r17,r4
 821652c:	8804d17a 	srli	r2,r17,5
 8216530:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 8216534:	d0a07117 	ldw	r2,-32316(gp)
 8216538:	1000031e 	bne	r2,zero,8216548 <OS_TaskStat+0x70>
        OSCPUUsage = 0;
 821653c:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 8216540:	01003fc4 	movi	r4,255
 8216544:	821b8ac0 	call	821b8ac <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216548:	0005303a 	rdctl	r2,status
 821654c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216550:	e0fffb17 	ldw	r3,-20(fp)
 8216554:	00bfff84 	movi	r2,-2
 8216558:	1884703a 	and	r2,r3,r2
 821655c:	1001703a 	wrctl	status,r2
  
  return context;
 8216560:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 8216564:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 8216568:	d0a06c17 	ldw	r2,-32336(gp)
 821656c:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 8216570:	d0206c15 	stw	zero,-32336(gp)
 8216574:	e0bffa17 	ldw	r2,-24(fp)
 8216578:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821657c:	e0bffc17 	ldw	r2,-16(fp)
 8216580:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 8216584:	d0a07e17 	ldw	r2,-32264(gp)
 8216588:	d0e07117 	ldw	r3,-32316(gp)
 821658c:	180b883a 	mov	r5,r3
 8216590:	1009883a 	mov	r4,r2
 8216594:	820295c0 	call	820295c <__udivsi3>
 8216598:	1007883a 	mov	r3,r2
 821659c:	00801904 	movi	r2,100
 82165a0:	10c5c83a 	sub	r2,r2,r3
 82165a4:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 82165a8:	823cc940 	call	823cc94 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 82165ac:	82165bc0 	call	82165bc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 82165b0:	01000284 	movi	r4,10
 82165b4:	821bc240 	call	821bc24 <OSTimeDly>
    }
 82165b8:	003fe306 	br	8216548 <OS_TaskStat+0x70>

082165bc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 82165bc:	defffa04 	addi	sp,sp,-24
 82165c0:	dfc00515 	stw	ra,20(sp)
 82165c4:	df000415 	stw	fp,16(sp)
 82165c8:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 82165cc:	e03ffc05 	stb	zero,-16(fp)
 82165d0:	00002406 	br	8216664 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 82165d4:	e0bffc03 	ldbu	r2,-16(fp)
 82165d8:	e0fffe04 	addi	r3,fp,-8
 82165dc:	180b883a 	mov	r5,r3
 82165e0:	1009883a 	mov	r4,r2
 82165e4:	821b6ec0 	call	821b6ec <OSTaskStkChk>
 82165e8:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 82165ec:	e0bffc43 	ldbu	r2,-15(fp)
 82165f0:	1000191e 	bne	r2,zero,8216658 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 82165f4:	e0fffc03 	ldbu	r3,-16(fp)
 82165f8:	008209b4 	movhi	r2,2086
 82165fc:	10b5c804 	addi	r2,r2,-10464
 8216600:	18c7883a 	add	r3,r3,r3
 8216604:	18c7883a 	add	r3,r3,r3
 8216608:	10c5883a 	add	r2,r2,r3
 821660c:	10800017 	ldw	r2,0(r2)
 8216610:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 8216614:	e0bffd17 	ldw	r2,-12(fp)
 8216618:	10000f26 	beq	r2,zero,8216658 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 821661c:	e0bffd17 	ldw	r2,-12(fp)
 8216620:	10800060 	cmpeqi	r2,r2,1
 8216624:	10000c1e 	bne	r2,zero,8216658 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 8216628:	e0bffd17 	ldw	r2,-12(fp)
 821662c:	10c00217 	ldw	r3,8(r2)
 8216630:	e0bffd17 	ldw	r2,-12(fp)
 8216634:	10800317 	ldw	r2,12(r2)
 8216638:	1085883a 	add	r2,r2,r2
 821663c:	1085883a 	add	r2,r2,r2
 8216640:	1887883a 	add	r3,r3,r2
 8216644:	e0bffd17 	ldw	r2,-12(fp)
 8216648:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 821664c:	e0ffff17 	ldw	r3,-4(fp)
 8216650:	e0bffd17 	ldw	r2,-12(fp)
 8216654:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 8216658:	e0bffc03 	ldbu	r2,-16(fp)
 821665c:	10800044 	addi	r2,r2,1
 8216660:	e0bffc05 	stb	r2,-16(fp)
 8216664:	e0bffc03 	ldbu	r2,-16(fp)
 8216668:	10800570 	cmpltui	r2,r2,21
 821666c:	103fd91e 	bne	r2,zero,82165d4 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 8216670:	0001883a 	nop
 8216674:	e037883a 	mov	sp,fp
 8216678:	dfc00117 	ldw	ra,4(sp)
 821667c:	df000017 	ldw	fp,0(sp)
 8216680:	dec00204 	addi	sp,sp,8
 8216684:	f800283a 	ret

08216688 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 8216688:	defff204 	addi	sp,sp,-56
 821668c:	dfc00d15 	stw	ra,52(sp)
 8216690:	df000c15 	stw	fp,48(sp)
 8216694:	df000c04 	addi	fp,sp,48
 8216698:	e17ffc15 	stw	r5,-16(fp)
 821669c:	e1bffd15 	stw	r6,-12(fp)
 82166a0:	3807883a 	mov	r3,r7
 82166a4:	e0800417 	ldw	r2,16(fp)
 82166a8:	e13ffb05 	stb	r4,-20(fp)
 82166ac:	e0fffe0d 	sth	r3,-8(fp)
 82166b0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82166b4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82166b8:	0005303a 	rdctl	r2,status
 82166bc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82166c0:	e0fffa17 	ldw	r3,-24(fp)
 82166c4:	00bfff84 	movi	r2,-2
 82166c8:	1884703a 	and	r2,r3,r2
 82166cc:	1001703a 	wrctl	status,r2
  
  return context;
 82166d0:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
 82166d4:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 82166d8:	d0a07217 	ldw	r2,-32312(gp)
 82166dc:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
 82166e0:	e0bff617 	ldw	r2,-40(fp)
 82166e4:	10009326 	beq	r2,zero,8216934 <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 82166e8:	e0bff617 	ldw	r2,-40(fp)
 82166ec:	10800517 	ldw	r2,20(r2)
 82166f0:	d0a07215 	stw	r2,-32312(gp)
 82166f4:	e0bff417 	ldw	r2,-48(fp)
 82166f8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82166fc:	e0bff817 	ldw	r2,-32(fp)
 8216700:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 8216704:	e0bff617 	ldw	r2,-40(fp)
 8216708:	e0fffc17 	ldw	r3,-16(fp)
 821670c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 8216710:	e0bff617 	ldw	r2,-40(fp)
 8216714:	e0fffb03 	ldbu	r3,-20(fp)
 8216718:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 821671c:	e0bff617 	ldw	r2,-40(fp)
 8216720:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 8216724:	e0bff617 	ldw	r2,-40(fp)
 8216728:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 821672c:	e0bff617 	ldw	r2,-40(fp)
 8216730:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 8216734:	e0bff617 	ldw	r2,-40(fp)
 8216738:	e0c00317 	ldw	r3,12(fp)
 821673c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 8216740:	e0bff617 	ldw	r2,-40(fp)
 8216744:	e0c00217 	ldw	r3,8(fp)
 8216748:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 821674c:	e0bff617 	ldw	r2,-40(fp)
 8216750:	e0fffd17 	ldw	r3,-12(fp)
 8216754:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 8216758:	e0bff617 	ldw	r2,-40(fp)
 821675c:	e0ffff0b 	ldhu	r3,-4(fp)
 8216760:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 8216764:	e0bff617 	ldw	r2,-40(fp)
 8216768:	e0fffe0b 	ldhu	r3,-8(fp)
 821676c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 8216770:	e0bff617 	ldw	r2,-40(fp)
 8216774:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 8216778:	e0bffb03 	ldbu	r2,-20(fp)
 821677c:	1004d0fa 	srli	r2,r2,3
 8216780:	1007883a 	mov	r3,r2
 8216784:	e0bff617 	ldw	r2,-40(fp)
 8216788:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 821678c:	e0bffb03 	ldbu	r2,-20(fp)
 8216790:	108001cc 	andi	r2,r2,7
 8216794:	1007883a 	mov	r3,r2
 8216798:	e0bff617 	ldw	r2,-40(fp)
 821679c:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 82167a0:	e0bff617 	ldw	r2,-40(fp)
 82167a4:	10800d03 	ldbu	r2,52(r2)
 82167a8:	10803fcc 	andi	r2,r2,255
 82167ac:	00c00044 	movi	r3,1
 82167b0:	1884983a 	sll	r2,r3,r2
 82167b4:	1007883a 	mov	r3,r2
 82167b8:	e0bff617 	ldw	r2,-40(fp)
 82167bc:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 82167c0:	e0bff617 	ldw	r2,-40(fp)
 82167c4:	10800cc3 	ldbu	r2,51(r2)
 82167c8:	10803fcc 	andi	r2,r2,255
 82167cc:	00c00044 	movi	r3,1
 82167d0:	1884983a 	sll	r2,r3,r2
 82167d4:	1007883a 	mov	r3,r2
 82167d8:	e0bff617 	ldw	r2,-40(fp)
 82167dc:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 82167e0:	e0bff617 	ldw	r2,-40(fp)
 82167e4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 82167e8:	e0bff617 	ldw	r2,-40(fp)
 82167ec:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 82167f0:	e0bff617 	ldw	r2,-40(fp)
 82167f4:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 82167f8:	e0bff617 	ldw	r2,-40(fp)
 82167fc:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 8216800:	e0bff617 	ldw	r2,-40(fp)
 8216804:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 8216808:	e0bff617 	ldw	r2,-40(fp)
 821680c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 8216810:	e0bff617 	ldw	r2,-40(fp)
 8216814:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 8216818:	e0bff617 	ldw	r2,-40(fp)
 821681c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 8216820:	e0bff617 	ldw	r2,-40(fp)
 8216824:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 8216828:	e0bff617 	ldw	r2,-40(fp)
 821682c:	00c00fc4 	movi	r3,63
 8216830:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216834:	e0bff617 	ldw	r2,-40(fp)
 8216838:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 821683c:	e13ff617 	ldw	r4,-40(fp)
 8216840:	823cd400 	call	823cd40 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 8216844:	e13ff617 	ldw	r4,-40(fp)
 8216848:	823cc2c0 	call	823cc2c <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821684c:	0005303a 	rdctl	r2,status
 8216850:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216854:	e0fff517 	ldw	r3,-44(fp)
 8216858:	00bfff84 	movi	r2,-2
 821685c:	1884703a 	and	r2,r3,r2
 8216860:	1001703a 	wrctl	status,r2
  
  return context;
 8216864:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 8216868:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 821686c:	e0fffb03 	ldbu	r3,-20(fp)
 8216870:	008209b4 	movhi	r2,2086
 8216874:	10b5c804 	addi	r2,r2,-10464
 8216878:	18c7883a 	add	r3,r3,r3
 821687c:	18c7883a 	add	r3,r3,r3
 8216880:	10c5883a 	add	r2,r2,r3
 8216884:	e0fff617 	ldw	r3,-40(fp)
 8216888:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 821688c:	d0e06e17 	ldw	r3,-32328(gp)
 8216890:	e0bff617 	ldw	r2,-40(fp)
 8216894:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 8216898:	e0bff617 	ldw	r2,-40(fp)
 821689c:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 82168a0:	d0a06e17 	ldw	r2,-32328(gp)
 82168a4:	10000326 	beq	r2,zero,82168b4 <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
 82168a8:	d0a06e17 	ldw	r2,-32328(gp)
 82168ac:	e0fff617 	ldw	r3,-40(fp)
 82168b0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 82168b4:	e0bff617 	ldw	r2,-40(fp)
 82168b8:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 82168bc:	e0bff617 	ldw	r2,-40(fp)
 82168c0:	10c00d83 	ldbu	r3,54(r2)
 82168c4:	d0a07703 	ldbu	r2,-32292(gp)
 82168c8:	1884b03a 	or	r2,r3,r2
 82168cc:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 82168d0:	e0bff617 	ldw	r2,-40(fp)
 82168d4:	10800d03 	ldbu	r2,52(r2)
 82168d8:	10c03fcc 	andi	r3,r2,255
 82168dc:	e0bff617 	ldw	r2,-40(fp)
 82168e0:	10800d03 	ldbu	r2,52(r2)
 82168e4:	11003fcc 	andi	r4,r2,255
 82168e8:	d0a07744 	addi	r2,gp,-32291
 82168ec:	2085883a 	add	r2,r4,r2
 82168f0:	11000003 	ldbu	r4,0(r2)
 82168f4:	e0bff617 	ldw	r2,-40(fp)
 82168f8:	10800d43 	ldbu	r2,53(r2)
 82168fc:	2084b03a 	or	r2,r4,r2
 8216900:	1009883a 	mov	r4,r2
 8216904:	d0a07744 	addi	r2,gp,-32291
 8216908:	1885883a 	add	r2,r3,r2
 821690c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 8216910:	d0a07343 	ldbu	r2,-32307(gp)
 8216914:	10800044 	addi	r2,r2,1
 8216918:	d0a07345 	stb	r2,-32307(gp)
 821691c:	e0bff417 	ldw	r2,-48(fp)
 8216920:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216924:	e0bff717 	ldw	r2,-36(fp)
 8216928:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 821692c:	0005883a 	mov	r2,zero
 8216930:	00000506 	br	8216948 <OS_TCBInit+0x2c0>
 8216934:	e0bff417 	ldw	r2,-48(fp)
 8216938:	e0bff915 	stw	r2,-28(fp)
 821693c:	e0bff917 	ldw	r2,-28(fp)
 8216940:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 8216944:	00801084 	movi	r2,66
}
 8216948:	e037883a 	mov	sp,fp
 821694c:	dfc00117 	ldw	ra,4(sp)
 8216950:	df000017 	ldw	fp,0(sp)
 8216954:	dec00204 	addi	sp,sp,8
 8216958:	f800283a 	ret

0821695c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 821695c:	defffe04 	addi	sp,sp,-8
 8216960:	df000115 	stw	fp,4(sp)
 8216964:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 8216968:	d0a00c04 	addi	r2,gp,-32720
 821696c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 8216970:	d0a00d04 	addi	r2,gp,-32716
 8216974:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 8216978:	d0a00e84 	addi	r2,gp,-32710
 821697c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 8216980:	d0a00f04 	addi	r2,gp,-32708
 8216984:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 8216988:	d0a00e04 	addi	r2,gp,-32712
 821698c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 8216990:	d0a00f84 	addi	r2,gp,-32706
 8216994:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 8216998:	d0a01004 	addi	r2,gp,-32704
 821699c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 82169a0:	d0a01084 	addi	r2,gp,-32702
 82169a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 82169a8:	d0a01104 	addi	r2,gp,-32700
 82169ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 82169b0:	d0a01184 	addi	r2,gp,-32698
 82169b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 82169b8:	d0a01204 	addi	r2,gp,-32696
 82169bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 82169c0:	d0a01284 	addi	r2,gp,-32694
 82169c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 82169c8:	d0a01304 	addi	r2,gp,-32692
 82169cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 82169d0:	d0a01384 	addi	r2,gp,-32690
 82169d4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 82169d8:	d0a01404 	addi	r2,gp,-32688
 82169dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 82169e0:	d0a01484 	addi	r2,gp,-32686
 82169e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 82169e8:	d0a01504 	addi	r2,gp,-32684
 82169ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 82169f0:	d0a01584 	addi	r2,gp,-32682
 82169f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 82169f8:	d0a01604 	addi	r2,gp,-32680
 82169fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 8216a00:	d0a01684 	addi	r2,gp,-32678
 8216a04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 8216a08:	d0a01704 	addi	r2,gp,-32676
 8216a0c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 8216a10:	d0a01784 	addi	r2,gp,-32674
 8216a14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 8216a18:	d0a01804 	addi	r2,gp,-32672
 8216a1c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 8216a20:	d0a01884 	addi	r2,gp,-32670
 8216a24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 8216a28:	d0a01904 	addi	r2,gp,-32668
 8216a2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 8216a30:	d0a01984 	addi	r2,gp,-32666
 8216a34:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 8216a38:	d0a01a04 	addi	r2,gp,-32664
 8216a3c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 8216a40:	d0a01a84 	addi	r2,gp,-32662
 8216a44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 8216a48:	d0a01b04 	addi	r2,gp,-32660
 8216a4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 8216a50:	d0a01b84 	addi	r2,gp,-32658
 8216a54:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 8216a58:	d0a01c04 	addi	r2,gp,-32656
 8216a5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 8216a60:	d0a01c84 	addi	r2,gp,-32654
 8216a64:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 8216a68:	d0a01d04 	addi	r2,gp,-32652
 8216a6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 8216a70:	d0a01d84 	addi	r2,gp,-32650
 8216a74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 8216a78:	d0a01e04 	addi	r2,gp,-32648
 8216a7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 8216a80:	d0a01e84 	addi	r2,gp,-32646
 8216a84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 8216a88:	d0a01f04 	addi	r2,gp,-32644
 8216a8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 8216a90:	d0a01f84 	addi	r2,gp,-32642
 8216a94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 8216a98:	d0a02004 	addi	r2,gp,-32640
 8216a9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 8216aa0:	d0a02084 	addi	r2,gp,-32638
 8216aa4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 8216aa8:	d0a02104 	addi	r2,gp,-32636
 8216aac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 8216ab0:	d0a02184 	addi	r2,gp,-32634
 8216ab4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 8216ab8:	d0a02204 	addi	r2,gp,-32632
 8216abc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 8216ac0:	d0a02284 	addi	r2,gp,-32630
 8216ac4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 8216ac8:	d0a02304 	addi	r2,gp,-32628
 8216acc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 8216ad0:	d0a02804 	addi	r2,gp,-32608
 8216ad4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 8216ad8:	0001883a 	nop
 8216adc:	e037883a 	mov	sp,fp
 8216ae0:	df000017 	ldw	fp,0(sp)
 8216ae4:	dec00104 	addi	sp,sp,4
 8216ae8:	f800283a 	ret

08216aec <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 8216aec:	defff204 	addi	sp,sp,-56
 8216af0:	df000d15 	stw	fp,52(sp)
 8216af4:	df000d04 	addi	fp,sp,52
 8216af8:	e13ffc15 	stw	r4,-16(fp)
 8216afc:	2807883a 	mov	r3,r5
 8216b00:	3005883a 	mov	r2,r6
 8216b04:	e1ffff15 	stw	r7,-4(fp)
 8216b08:	e0fffd0d 	sth	r3,-12(fp)
 8216b0c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8216b10:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8216b14:	e0bfff17 	ldw	r2,-4(fp)
 8216b18:	1000021e 	bne	r2,zero,8216b24 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 8216b1c:	0005883a 	mov	r2,zero
 8216b20:	0000b006 	br	8216de4 <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216b24:	e0bffc17 	ldw	r2,-16(fp)
 8216b28:	1000051e 	bne	r2,zero,8216b40 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216b2c:	e0bfff17 	ldw	r2,-4(fp)
 8216b30:	00c01b84 	movi	r3,110
 8216b34:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216b38:	0005883a 	mov	r2,zero
 8216b3c:	0000a906 	br	8216de4 <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8216b40:	e0bffc17 	ldw	r2,-16(fp)
 8216b44:	10800003 	ldbu	r2,0(r2)
 8216b48:	10803fcc 	andi	r2,r2,255
 8216b4c:	10800160 	cmpeqi	r2,r2,5
 8216b50:	1000051e 	bne	r2,zero,8216b68 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 8216b54:	e0bfff17 	ldw	r2,-4(fp)
 8216b58:	00c00044 	movi	r3,1
 8216b5c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216b60:	0005883a 	mov	r2,zero
 8216b64:	00009f06 	br	8216de4 <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8216b68:	e0fffe03 	ldbu	r3,-8(fp)
 8216b6c:	00bfe004 	movi	r2,-128
 8216b70:	1884703a 	and	r2,r3,r2
 8216b74:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 8216b78:	e0bff503 	ldbu	r2,-44(fp)
 8216b7c:	10000626 	beq	r2,zero,8216b98 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 8216b80:	e0bffe03 	ldbu	r2,-8(fp)
 8216b84:	10801fcc 	andi	r2,r2,127
 8216b88:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8216b8c:	00800044 	movi	r2,1
 8216b90:	e0bff385 	stb	r2,-50(fp)
 8216b94:	00000106 	br	8216b9c <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 8216b98:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 8216b9c:	e0bfff17 	ldw	r2,-4(fp)
 8216ba0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216ba4:	0005303a 	rdctl	r2,status
 8216ba8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216bac:	e0fffb17 	ldw	r3,-20(fp)
 8216bb0:	00bfff84 	movi	r2,-2
 8216bb4:	1884703a 	and	r2,r3,r2
 8216bb8:	1001703a 	wrctl	status,r2
  
  return context;
 8216bbc:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 8216bc0:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 8216bc4:	e0bffe03 	ldbu	r2,-8(fp)
 8216bc8:	10c00060 	cmpeqi	r3,r2,1
 8216bcc:	18005f1e 	bne	r3,zero,8216d4c <OSFlagAccept+0x260>
 8216bd0:	10c00088 	cmpgei	r3,r2,2
 8216bd4:	1800021e 	bne	r3,zero,8216be0 <OSFlagAccept+0xf4>
 8216bd8:	10003f26 	beq	r2,zero,8216cd8 <OSFlagAccept+0x1ec>
 8216bdc:	00007706 	br	8216dbc <OSFlagAccept+0x2d0>
 8216be0:	10c000a0 	cmpeqi	r3,r2,2
 8216be4:	1800031e 	bne	r3,zero,8216bf4 <OSFlagAccept+0x108>
 8216be8:	108000e0 	cmpeqi	r2,r2,3
 8216bec:	10001e1e 	bne	r2,zero,8216c68 <OSFlagAccept+0x17c>
 8216bf0:	00007206 	br	8216dbc <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216bf4:	e0bffc17 	ldw	r2,-16(fp)
 8216bf8:	10c0020b 	ldhu	r3,8(r2)
 8216bfc:	e0bffd0b 	ldhu	r2,-12(fp)
 8216c00:	1884703a 	and	r2,r3,r2
 8216c04:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216c08:	e0fff30b 	ldhu	r3,-52(fp)
 8216c0c:	e0bffd0b 	ldhu	r2,-12(fp)
 8216c10:	18800d1e 	bne	r3,r2,8216c48 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216c14:	e0bff383 	ldbu	r2,-50(fp)
 8216c18:	10800058 	cmpnei	r2,r2,1
 8216c1c:	10000d1e 	bne	r2,zero,8216c54 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8216c20:	e0bffc17 	ldw	r2,-16(fp)
 8216c24:	1080020b 	ldhu	r2,8(r2)
 8216c28:	1007883a 	mov	r3,r2
 8216c2c:	e0bff30b 	ldhu	r2,-52(fp)
 8216c30:	0084303a 	nor	r2,zero,r2
 8216c34:	1884703a 	and	r2,r3,r2
 8216c38:	1007883a 	mov	r3,r2
 8216c3c:	e0bffc17 	ldw	r2,-16(fp)
 8216c40:	10c0020d 	sth	r3,8(r2)
 8216c44:	00000306 	br	8216c54 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216c48:	e0bfff17 	ldw	r2,-4(fp)
 8216c4c:	00c01c04 	movi	r3,112
 8216c50:	10c00005 	stb	r3,0(r2)
 8216c54:	e0bff417 	ldw	r2,-48(fp)
 8216c58:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216c5c:	e0bff617 	ldw	r2,-40(fp)
 8216c60:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216c64:	00005e06 	br	8216de0 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216c68:	e0bffc17 	ldw	r2,-16(fp)
 8216c6c:	10c0020b 	ldhu	r3,8(r2)
 8216c70:	e0bffd0b 	ldhu	r2,-12(fp)
 8216c74:	1884703a 	and	r2,r3,r2
 8216c78:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 8216c7c:	e0bff30b 	ldhu	r2,-52(fp)
 8216c80:	10000d26 	beq	r2,zero,8216cb8 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216c84:	e0bff383 	ldbu	r2,-50(fp)
 8216c88:	10800058 	cmpnei	r2,r2,1
 8216c8c:	10000d1e 	bne	r2,zero,8216cc4 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 8216c90:	e0bffc17 	ldw	r2,-16(fp)
 8216c94:	1080020b 	ldhu	r2,8(r2)
 8216c98:	1007883a 	mov	r3,r2
 8216c9c:	e0bff30b 	ldhu	r2,-52(fp)
 8216ca0:	0084303a 	nor	r2,zero,r2
 8216ca4:	1884703a 	and	r2,r3,r2
 8216ca8:	1007883a 	mov	r3,r2
 8216cac:	e0bffc17 	ldw	r2,-16(fp)
 8216cb0:	10c0020d 	sth	r3,8(r2)
 8216cb4:	00000306 	br	8216cc4 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216cb8:	e0bfff17 	ldw	r2,-4(fp)
 8216cbc:	00c01c04 	movi	r3,112
 8216cc0:	10c00005 	stb	r3,0(r2)
 8216cc4:	e0bff417 	ldw	r2,-48(fp)
 8216cc8:	e0bff715 	stw	r2,-36(fp)
 8216ccc:	e0bff717 	ldw	r2,-36(fp)
 8216cd0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216cd4:	00004206 	br	8216de0 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8216cd8:	e0bffc17 	ldw	r2,-16(fp)
 8216cdc:	1080020b 	ldhu	r2,8(r2)
 8216ce0:	0084303a 	nor	r2,zero,r2
 8216ce4:	1007883a 	mov	r3,r2
 8216ce8:	e0bffd0b 	ldhu	r2,-12(fp)
 8216cec:	1884703a 	and	r2,r3,r2
 8216cf0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216cf4:	e0fff30b 	ldhu	r3,-52(fp)
 8216cf8:	e0bffd0b 	ldhu	r2,-12(fp)
 8216cfc:	18800b1e 	bne	r3,r2,8216d2c <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216d00:	e0bff383 	ldbu	r2,-50(fp)
 8216d04:	10800058 	cmpnei	r2,r2,1
 8216d08:	10000b1e 	bne	r2,zero,8216d38 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 8216d0c:	e0bffc17 	ldw	r2,-16(fp)
 8216d10:	10c0020b 	ldhu	r3,8(r2)
 8216d14:	e0bff30b 	ldhu	r2,-52(fp)
 8216d18:	1884b03a 	or	r2,r3,r2
 8216d1c:	1007883a 	mov	r3,r2
 8216d20:	e0bffc17 	ldw	r2,-16(fp)
 8216d24:	10c0020d 	sth	r3,8(r2)
 8216d28:	00000306 	br	8216d38 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216d2c:	e0bfff17 	ldw	r2,-4(fp)
 8216d30:	00c01c04 	movi	r3,112
 8216d34:	10c00005 	stb	r3,0(r2)
 8216d38:	e0bff417 	ldw	r2,-48(fp)
 8216d3c:	e0bff815 	stw	r2,-32(fp)
 8216d40:	e0bff817 	ldw	r2,-32(fp)
 8216d44:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216d48:	00002506 	br	8216de0 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 8216d4c:	e0bffc17 	ldw	r2,-16(fp)
 8216d50:	1080020b 	ldhu	r2,8(r2)
 8216d54:	0084303a 	nor	r2,zero,r2
 8216d58:	1007883a 	mov	r3,r2
 8216d5c:	e0bffd0b 	ldhu	r2,-12(fp)
 8216d60:	1884703a 	and	r2,r3,r2
 8216d64:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8216d68:	e0bff30b 	ldhu	r2,-52(fp)
 8216d6c:	10000b26 	beq	r2,zero,8216d9c <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216d70:	e0bff383 	ldbu	r2,-50(fp)
 8216d74:	10800058 	cmpnei	r2,r2,1
 8216d78:	10000b1e 	bne	r2,zero,8216da8 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8216d7c:	e0bffc17 	ldw	r2,-16(fp)
 8216d80:	10c0020b 	ldhu	r3,8(r2)
 8216d84:	e0bff30b 	ldhu	r2,-52(fp)
 8216d88:	1884b03a 	or	r2,r3,r2
 8216d8c:	1007883a 	mov	r3,r2
 8216d90:	e0bffc17 	ldw	r2,-16(fp)
 8216d94:	10c0020d 	sth	r3,8(r2)
 8216d98:	00000306 	br	8216da8 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216d9c:	e0bfff17 	ldw	r2,-4(fp)
 8216da0:	00c01c04 	movi	r3,112
 8216da4:	10c00005 	stb	r3,0(r2)
 8216da8:	e0bff417 	ldw	r2,-48(fp)
 8216dac:	e0bff915 	stw	r2,-28(fp)
 8216db0:	e0bff917 	ldw	r2,-28(fp)
 8216db4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216db8:	00000906 	br	8216de0 <OSFlagAccept+0x2f4>
 8216dbc:	e0bff417 	ldw	r2,-48(fp)
 8216dc0:	e0bffa15 	stw	r2,-24(fp)
 8216dc4:	e0bffa17 	ldw	r2,-24(fp)
 8216dc8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8216dcc:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 8216dd0:	e0bfff17 	ldw	r2,-4(fp)
 8216dd4:	00c01bc4 	movi	r3,111
 8216dd8:	10c00005 	stb	r3,0(r2)
             break;
 8216ddc:	0001883a 	nop
    }
    return (flags_rdy);
 8216de0:	e0bff30b 	ldhu	r2,-52(fp)
}
 8216de4:	e037883a 	mov	sp,fp
 8216de8:	df000017 	ldw	fp,0(sp)
 8216dec:	dec00104 	addi	sp,sp,4
 8216df0:	f800283a 	ret

08216df4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 8216df4:	defff804 	addi	sp,sp,-32
 8216df8:	df000715 	stw	fp,28(sp)
 8216dfc:	df000704 	addi	fp,sp,28
 8216e00:	2005883a 	mov	r2,r4
 8216e04:	e17fff15 	stw	r5,-4(fp)
 8216e08:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 8216e0c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 8216e10:	e0bfff17 	ldw	r2,-4(fp)
 8216e14:	1000021e 	bne	r2,zero,8216e20 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 8216e18:	0005883a 	mov	r2,zero
 8216e1c:	00003306 	br	8216eec <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 8216e20:	d0a07903 	ldbu	r2,-32284(gp)
 8216e24:	10803fcc 	andi	r2,r2,255
 8216e28:	10000526 	beq	r2,zero,8216e40 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 8216e2c:	e0bfff17 	ldw	r2,-4(fp)
 8216e30:	00c00404 	movi	r3,16
 8216e34:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 8216e38:	0005883a 	mov	r2,zero
 8216e3c:	00002b06 	br	8216eec <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216e40:	0005303a 	rdctl	r2,status
 8216e44:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216e48:	e0fffd17 	ldw	r3,-12(fp)
 8216e4c:	00bfff84 	movi	r2,-2
 8216e50:	1884703a 	and	r2,r3,r2
 8216e54:	1001703a 	wrctl	status,r2
  
  return context;
 8216e58:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8216e5c:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 8216e60:	d0a07c17 	ldw	r2,-32272(gp)
 8216e64:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 8216e68:	e0bffb17 	ldw	r2,-20(fp)
 8216e6c:	10001726 	beq	r2,zero,8216ecc <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 8216e70:	d0a07c17 	ldw	r2,-32272(gp)
 8216e74:	10800117 	ldw	r2,4(r2)
 8216e78:	d0a07c15 	stw	r2,-32272(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 8216e7c:	e0bffb17 	ldw	r2,-20(fp)
 8216e80:	00c00144 	movi	r3,5
 8216e84:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 8216e88:	e0bffb17 	ldw	r2,-20(fp)
 8216e8c:	e0fffe0b 	ldhu	r3,-8(fp)
 8216e90:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 8216e94:	e0bffb17 	ldw	r2,-20(fp)
 8216e98:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 8216e9c:	e0bffb17 	ldw	r2,-20(fp)
 8216ea0:	00c00fc4 	movi	r3,63
 8216ea4:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8216ea8:	e0bffb17 	ldw	r2,-20(fp)
 8216eac:	100002c5 	stb	zero,11(r2)
 8216eb0:	e0bff917 	ldw	r2,-28(fp)
 8216eb4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216eb8:	e0bffa17 	ldw	r2,-24(fp)
 8216ebc:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 8216ec0:	e0bfff17 	ldw	r2,-4(fp)
 8216ec4:	10000005 	stb	zero,0(r2)
 8216ec8:	00000706 	br	8216ee8 <OSFlagCreate+0xf4>
 8216ecc:	e0bff917 	ldw	r2,-28(fp)
 8216ed0:	e0bffc15 	stw	r2,-16(fp)
 8216ed4:	e0bffc17 	ldw	r2,-16(fp)
 8216ed8:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 8216edc:	e0bfff17 	ldw	r2,-4(fp)
 8216ee0:	00c01c84 	movi	r3,114
 8216ee4:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 8216ee8:	e0bffb17 	ldw	r2,-20(fp)
}
 8216eec:	e037883a 	mov	sp,fp
 8216ef0:	df000017 	ldw	fp,0(sp)
 8216ef4:	dec00104 	addi	sp,sp,4
 8216ef8:	f800283a 	ret

08216efc <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 8216efc:	defff204 	addi	sp,sp,-56
 8216f00:	dfc00d15 	stw	ra,52(sp)
 8216f04:	df000c15 	stw	fp,48(sp)
 8216f08:	df000c04 	addi	fp,sp,48
 8216f0c:	e13ffd15 	stw	r4,-12(fp)
 8216f10:	2805883a 	mov	r2,r5
 8216f14:	e1bfff15 	stw	r6,-4(fp)
 8216f18:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8216f1c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8216f20:	e0bfff17 	ldw	r2,-4(fp)
 8216f24:	1000021e 	bne	r2,zero,8216f30 <OSFlagDel+0x34>
        return (pgrp);
 8216f28:	e0bffd17 	ldw	r2,-12(fp)
 8216f2c:	00008006 	br	8217130 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216f30:	e0bffd17 	ldw	r2,-12(fp)
 8216f34:	1000051e 	bne	r2,zero,8216f4c <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216f38:	e0bfff17 	ldw	r2,-4(fp)
 8216f3c:	00c01b84 	movi	r3,110
 8216f40:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8216f44:	e0bffd17 	ldw	r2,-12(fp)
 8216f48:	00007906 	br	8217130 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8216f4c:	d0a07903 	ldbu	r2,-32284(gp)
 8216f50:	10803fcc 	andi	r2,r2,255
 8216f54:	10000526 	beq	r2,zero,8216f6c <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8216f58:	e0bfff17 	ldw	r2,-4(fp)
 8216f5c:	00c003c4 	movi	r3,15
 8216f60:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8216f64:	e0bffd17 	ldw	r2,-12(fp)
 8216f68:	00007106 	br	8217130 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 8216f6c:	e0bffd17 	ldw	r2,-12(fp)
 8216f70:	10800003 	ldbu	r2,0(r2)
 8216f74:	10803fcc 	andi	r2,r2,255
 8216f78:	10800160 	cmpeqi	r2,r2,5
 8216f7c:	1000051e 	bne	r2,zero,8216f94 <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
 8216f80:	e0bfff17 	ldw	r2,-4(fp)
 8216f84:	00c00044 	movi	r3,1
 8216f88:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8216f8c:	e0bffd17 	ldw	r2,-12(fp)
 8216f90:	00006706 	br	8217130 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216f94:	0005303a 	rdctl	r2,status
 8216f98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216f9c:	e0fffc17 	ldw	r3,-16(fp)
 8216fa0:	00bfff84 	movi	r2,-2
 8216fa4:	1884703a 	and	r2,r3,r2
 8216fa8:	1001703a 	wrctl	status,r2
  
  return context;
 8216fac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8216fb0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 8216fb4:	e0bffd17 	ldw	r2,-12(fp)
 8216fb8:	10800117 	ldw	r2,4(r2)
 8216fbc:	10000326 	beq	r2,zero,8216fcc <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8216fc0:	00800044 	movi	r2,1
 8216fc4:	e0bff405 	stb	r2,-48(fp)
 8216fc8:	00000106 	br	8216fd0 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8216fcc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8216fd0:	e0bffe03 	ldbu	r2,-8(fp)
 8216fd4:	10000326 	beq	r2,zero,8216fe4 <OSFlagDel+0xe8>
 8216fd8:	10800060 	cmpeqi	r2,r2,1
 8216fdc:	1000231e 	bne	r2,zero,821706c <OSFlagDel+0x170>
 8216fe0:	00004806 	br	8217104 <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 8216fe4:	e0bff403 	ldbu	r2,-48(fp)
 8216fe8:	1000161e 	bne	r2,zero,8217044 <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 8216fec:	e0bffd17 	ldw	r2,-12(fp)
 8216ff0:	00c00fc4 	movi	r3,63
 8216ff4:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8216ff8:	e0bffd17 	ldw	r2,-12(fp)
 8216ffc:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217000:	e0bffd17 	ldw	r2,-12(fp)
 8217004:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 8217008:	d0e07c17 	ldw	r3,-32272(gp)
 821700c:	e0bffd17 	ldw	r2,-12(fp)
 8217010:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 8217014:	e0bffd17 	ldw	r2,-12(fp)
 8217018:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 821701c:	e0bffd17 	ldw	r2,-12(fp)
 8217020:	d0a07c15 	stw	r2,-32272(gp)
 8217024:	e0bff717 	ldw	r2,-36(fp)
 8217028:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821702c:	e0bff817 	ldw	r2,-32(fp)
 8217030:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 8217034:	e0bfff17 	ldw	r2,-4(fp)
 8217038:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 821703c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 8217040:	00003a06 	br	821712c <OSFlagDel+0x230>
 8217044:	e0bff717 	ldw	r2,-36(fp)
 8217048:	e0bff915 	stw	r2,-28(fp)
 821704c:	e0bff917 	ldw	r2,-28(fp)
 8217050:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 8217054:	e0bfff17 	ldw	r2,-4(fp)
 8217058:	00c01244 	movi	r3,73
 821705c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 8217060:	e0bffd17 	ldw	r2,-12(fp)
 8217064:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8217068:	00003006 	br	821712c <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 821706c:	e0bffd17 	ldw	r2,-12(fp)
 8217070:	10800117 	ldw	r2,4(r2)
 8217074:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8217078:	00000606 	br	8217094 <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 821707c:	000b883a 	mov	r5,zero
 8217080:	e13ff517 	ldw	r4,-44(fp)
 8217084:	82180680 	call	8218068 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8217088:	e0bff517 	ldw	r2,-44(fp)
 821708c:	10800017 	ldw	r2,0(r2)
 8217090:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8217094:	e0bff517 	ldw	r2,-44(fp)
 8217098:	103ff81e 	bne	r2,zero,821707c <OSFlagDel+0x180>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 821709c:	e0bffd17 	ldw	r2,-12(fp)
 82170a0:	00c00fc4 	movi	r3,63
 82170a4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 82170a8:	e0bffd17 	ldw	r2,-12(fp)
 82170ac:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82170b0:	e0bffd17 	ldw	r2,-12(fp)
 82170b4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 82170b8:	d0e07c17 	ldw	r3,-32272(gp)
 82170bc:	e0bffd17 	ldw	r2,-12(fp)
 82170c0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 82170c4:	e0bffd17 	ldw	r2,-12(fp)
 82170c8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 82170cc:	e0bffd17 	ldw	r2,-12(fp)
 82170d0:	d0a07c15 	stw	r2,-32272(gp)
 82170d4:	e0bff717 	ldw	r2,-36(fp)
 82170d8:	e0bffa15 	stw	r2,-24(fp)
 82170dc:	e0bffa17 	ldw	r2,-24(fp)
 82170e0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 82170e4:	e0bff403 	ldbu	r2,-48(fp)
 82170e8:	10800058 	cmpnei	r2,r2,1
 82170ec:	1000011e 	bne	r2,zero,82170f4 <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 82170f0:	82162700 	call	8216270 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 82170f4:	e0bfff17 	ldw	r2,-4(fp)
 82170f8:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 82170fc:	e03ff615 	stw	zero,-40(fp)
             break;
 8217100:	00000a06 	br	821712c <OSFlagDel+0x230>
 8217104:	e0bff717 	ldw	r2,-36(fp)
 8217108:	e0bffb15 	stw	r2,-20(fp)
 821710c:	e0bffb17 	ldw	r2,-20(fp)
 8217110:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 8217114:	e0bfff17 	ldw	r2,-4(fp)
 8217118:	00c001c4 	movi	r3,7
 821711c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 8217120:	e0bffd17 	ldw	r2,-12(fp)
 8217124:	e0bff615 	stw	r2,-40(fp)
             break;
 8217128:	0001883a 	nop
    }
    return (pgrp_return);
 821712c:	e0bff617 	ldw	r2,-40(fp)
}
 8217130:	e037883a 	mov	sp,fp
 8217134:	dfc00117 	ldw	ra,4(sp)
 8217138:	df000017 	ldw	fp,0(sp)
 821713c:	dec00204 	addi	sp,sp,8
 8217140:	f800283a 	ret

08217144 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 8217144:	defff604 	addi	sp,sp,-40
 8217148:	dfc00915 	stw	ra,36(sp)
 821714c:	df000815 	stw	fp,32(sp)
 8217150:	df000804 	addi	fp,sp,32
 8217154:	e13ffd15 	stw	r4,-12(fp)
 8217158:	e17ffe15 	stw	r5,-8(fp)
 821715c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217160:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8217164:	e0bfff17 	ldw	r2,-4(fp)
 8217168:	1000021e 	bne	r2,zero,8217174 <OSFlagNameGet+0x30>
        return (0);
 821716c:	0005883a 	mov	r2,zero
 8217170:	00003906 	br	8217258 <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 8217174:	e0bffd17 	ldw	r2,-12(fp)
 8217178:	1000051e 	bne	r2,zero,8217190 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 821717c:	e0bfff17 	ldw	r2,-4(fp)
 8217180:	00c01b84 	movi	r3,110
 8217184:	10c00005 	stb	r3,0(r2)
        return (0);
 8217188:	0005883a 	mov	r2,zero
 821718c:	00003206 	br	8217258 <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8217190:	e0bffe17 	ldw	r2,-8(fp)
 8217194:	1000051e 	bne	r2,zero,82171ac <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8217198:	e0bfff17 	ldw	r2,-4(fp)
 821719c:	00c00304 	movi	r3,12
 82171a0:	10c00005 	stb	r3,0(r2)
        return (0);
 82171a4:	0005883a 	mov	r2,zero
 82171a8:	00002b06 	br	8217258 <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82171ac:	d0a07903 	ldbu	r2,-32284(gp)
 82171b0:	10803fcc 	andi	r2,r2,255
 82171b4:	10000526 	beq	r2,zero,82171cc <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 82171b8:	e0bfff17 	ldw	r2,-4(fp)
 82171bc:	00c00444 	movi	r3,17
 82171c0:	10c00005 	stb	r3,0(r2)
        return (0);
 82171c4:	0005883a 	mov	r2,zero
 82171c8:	00002306 	br	8217258 <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82171cc:	0005303a 	rdctl	r2,status
 82171d0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82171d4:	e0fffc17 	ldw	r3,-16(fp)
 82171d8:	00bfff84 	movi	r2,-2
 82171dc:	1884703a 	and	r2,r3,r2
 82171e0:	1001703a 	wrctl	status,r2
  
  return context;
 82171e4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82171e8:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 82171ec:	e0bffd17 	ldw	r2,-12(fp)
 82171f0:	10800003 	ldbu	r2,0(r2)
 82171f4:	10803fcc 	andi	r2,r2,255
 82171f8:	10800160 	cmpeqi	r2,r2,5
 82171fc:	1000091e 	bne	r2,zero,8217224 <OSFlagNameGet+0xe0>
 8217200:	e0bff817 	ldw	r2,-32(fp)
 8217204:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217208:	e0bff917 	ldw	r2,-28(fp)
 821720c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 8217210:	e0bfff17 	ldw	r2,-4(fp)
 8217214:	00c00044 	movi	r3,1
 8217218:	10c00005 	stb	r3,0(r2)
        return (0);
 821721c:	0005883a 	mov	r2,zero
 8217220:	00000d06 	br	8217258 <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 8217224:	e0bffd17 	ldw	r2,-12(fp)
 8217228:	10800284 	addi	r2,r2,10
 821722c:	100b883a 	mov	r5,r2
 8217230:	e13ffe17 	ldw	r4,-8(fp)
 8217234:	82163b40 	call	82163b4 <OS_StrCopy>
 8217238:	e0bffb05 	stb	r2,-20(fp)
 821723c:	e0bff817 	ldw	r2,-32(fp)
 8217240:	e0bffa15 	stw	r2,-24(fp)
 8217244:	e0bffa17 	ldw	r2,-24(fp)
 8217248:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821724c:	e0bfff17 	ldw	r2,-4(fp)
 8217250:	10000005 	stb	zero,0(r2)
    return (len);
 8217254:	e0bffb03 	ldbu	r2,-20(fp)
}
 8217258:	e037883a 	mov	sp,fp
 821725c:	dfc00117 	ldw	ra,4(sp)
 8217260:	df000017 	ldw	fp,0(sp)
 8217264:	dec00204 	addi	sp,sp,8
 8217268:	f800283a 	ret

0821726c <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 821726c:	defff504 	addi	sp,sp,-44
 8217270:	dfc00a15 	stw	ra,40(sp)
 8217274:	df000915 	stw	fp,36(sp)
 8217278:	df000904 	addi	fp,sp,36
 821727c:	e13ffd15 	stw	r4,-12(fp)
 8217280:	e17ffe15 	stw	r5,-8(fp)
 8217284:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217288:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 821728c:	e0bfff17 	ldw	r2,-4(fp)
 8217290:	10004326 	beq	r2,zero,82173a0 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 8217294:	e0bffd17 	ldw	r2,-12(fp)
 8217298:	1000041e 	bne	r2,zero,82172ac <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 821729c:	e0bfff17 	ldw	r2,-4(fp)
 82172a0:	00c01b84 	movi	r3,110
 82172a4:	10c00005 	stb	r3,0(r2)
        return;
 82172a8:	00003e06 	br	82173a4 <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82172ac:	e0bffe17 	ldw	r2,-8(fp)
 82172b0:	1000041e 	bne	r2,zero,82172c4 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 82172b4:	e0bfff17 	ldw	r2,-4(fp)
 82172b8:	00c00304 	movi	r3,12
 82172bc:	10c00005 	stb	r3,0(r2)
        return;
 82172c0:	00003806 	br	82173a4 <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82172c4:	d0a07903 	ldbu	r2,-32284(gp)
 82172c8:	10803fcc 	andi	r2,r2,255
 82172cc:	10000426 	beq	r2,zero,82172e0 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 82172d0:	e0bfff17 	ldw	r2,-4(fp)
 82172d4:	00c00484 	movi	r3,18
 82172d8:	10c00005 	stb	r3,0(r2)
        return;
 82172dc:	00003106 	br	82173a4 <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82172e0:	0005303a 	rdctl	r2,status
 82172e4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82172e8:	e0fffc17 	ldw	r3,-16(fp)
 82172ec:	00bfff84 	movi	r2,-2
 82172f0:	1884703a 	and	r2,r3,r2
 82172f4:	1001703a 	wrctl	status,r2
  
  return context;
 82172f8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82172fc:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 8217300:	e0bffd17 	ldw	r2,-12(fp)
 8217304:	10800003 	ldbu	r2,0(r2)
 8217308:	10803fcc 	andi	r2,r2,255
 821730c:	10800160 	cmpeqi	r2,r2,5
 8217310:	1000081e 	bne	r2,zero,8217334 <OSFlagNameSet+0xc8>
 8217314:	e0bff717 	ldw	r2,-36(fp)
 8217318:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821731c:	e0bff817 	ldw	r2,-32(fp)
 8217320:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 8217324:	e0bfff17 	ldw	r2,-4(fp)
 8217328:	00c00044 	movi	r3,1
 821732c:	10c00005 	stb	r3,0(r2)
        return;
 8217330:	00001c06 	br	82173a4 <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 8217334:	e13ffe17 	ldw	r4,-8(fp)
 8217338:	82164280 	call	8216428 <OS_StrLen>
 821733c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 8217340:	e0bffa03 	ldbu	r2,-24(fp)
 8217344:	10800830 	cmpltui	r2,r2,32
 8217348:	1000081e 	bne	r2,zero,821736c <OSFlagNameSet+0x100>
 821734c:	e0bff717 	ldw	r2,-36(fp)
 8217350:	e0bff915 	stw	r2,-28(fp)
 8217354:	e0bff917 	ldw	r2,-28(fp)
 8217358:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 821735c:	e0bfff17 	ldw	r2,-4(fp)
 8217360:	00c01cc4 	movi	r3,115
 8217364:	10c00005 	stb	r3,0(r2)
        return;
 8217368:	00000e06 	br	82173a4 <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 821736c:	e0bffd17 	ldw	r2,-12(fp)
 8217370:	10800284 	addi	r2,r2,10
 8217374:	e17ffe17 	ldw	r5,-8(fp)
 8217378:	1009883a 	mov	r4,r2
 821737c:	82163b40 	call	82163b4 <OS_StrCopy>
 8217380:	e0bff717 	ldw	r2,-36(fp)
 8217384:	e0bffb15 	stw	r2,-20(fp)
 8217388:	e0bffb17 	ldw	r2,-20(fp)
 821738c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217390:	e0bfff17 	ldw	r2,-4(fp)
 8217394:	10000005 	stb	zero,0(r2)
    return;
 8217398:	0001883a 	nop
 821739c:	00000106 	br	82173a4 <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 82173a0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 82173a4:	e037883a 	mov	sp,fp
 82173a8:	dfc00117 	ldw	ra,4(sp)
 82173ac:	df000017 	ldw	fp,0(sp)
 82173b0:	dec00204 	addi	sp,sp,8
 82173b4:	f800283a 	ret

082173b8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 82173b8:	deffe104 	addi	sp,sp,-124
 82173bc:	dfc01e15 	stw	ra,120(sp)
 82173c0:	df001d15 	stw	fp,116(sp)
 82173c4:	df001d04 	addi	fp,sp,116
 82173c8:	e13ffc15 	stw	r4,-16(fp)
 82173cc:	2809883a 	mov	r4,r5
 82173d0:	3007883a 	mov	r3,r6
 82173d4:	3805883a 	mov	r2,r7
 82173d8:	e13ffd0d 	sth	r4,-12(fp)
 82173dc:	e0fffe05 	stb	r3,-8(fp)
 82173e0:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 82173e4:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 82173e8:	e0800217 	ldw	r2,8(fp)
 82173ec:	1000021e 	bne	r2,zero,82173f8 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 82173f0:	0005883a 	mov	r2,zero
 82173f4:	00015906 	br	821795c <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 82173f8:	e0bffc17 	ldw	r2,-16(fp)
 82173fc:	1000051e 	bne	r2,zero,8217414 <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217400:	e0800217 	ldw	r2,8(fp)
 8217404:	00c01b84 	movi	r3,110
 8217408:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821740c:	0005883a 	mov	r2,zero
 8217410:	00015206 	br	821795c <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8217414:	d0a07903 	ldbu	r2,-32284(gp)
 8217418:	10803fcc 	andi	r2,r2,255
 821741c:	10000526 	beq	r2,zero,8217434 <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 8217420:	e0800217 	ldw	r2,8(fp)
 8217424:	00c00084 	movi	r3,2
 8217428:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821742c:	0005883a 	mov	r2,zero
 8217430:	00014a06 	br	821795c <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 8217434:	d0a06b03 	ldbu	r2,-32340(gp)
 8217438:	10803fcc 	andi	r2,r2,255
 821743c:	10000526 	beq	r2,zero,8217454 <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 8217440:	e0800217 	ldw	r2,8(fp)
 8217444:	00c00344 	movi	r3,13
 8217448:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821744c:	0005883a 	mov	r2,zero
 8217450:	00014206 	br	821795c <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8217454:	e0bffc17 	ldw	r2,-16(fp)
 8217458:	10800003 	ldbu	r2,0(r2)
 821745c:	10803fcc 	andi	r2,r2,255
 8217460:	10800160 	cmpeqi	r2,r2,5
 8217464:	1000051e 	bne	r2,zero,821747c <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
 8217468:	e0800217 	ldw	r2,8(fp)
 821746c:	00c00044 	movi	r3,1
 8217470:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217474:	0005883a 	mov	r2,zero
 8217478:	00013806 	br	821795c <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 821747c:	e0fffe03 	ldbu	r3,-8(fp)
 8217480:	00bfe004 	movi	r2,-128
 8217484:	1884703a 	and	r2,r3,r2
 8217488:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 821748c:	e0bfe603 	ldbu	r2,-104(fp)
 8217490:	10000626 	beq	r2,zero,82174ac <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 8217494:	e0bffe03 	ldbu	r2,-8(fp)
 8217498:	10801fcc 	andi	r2,r2,127
 821749c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 82174a0:	00800044 	movi	r2,1
 82174a4:	e0bfe405 	stb	r2,-112(fp)
 82174a8:	00000106 	br	82174b0 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
 82174ac:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82174b0:	0005303a 	rdctl	r2,status
 82174b4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82174b8:	e0fff617 	ldw	r3,-40(fp)
 82174bc:	00bfff84 	movi	r2,-2
 82174c0:	1884703a 	and	r2,r3,r2
 82174c4:	1001703a 	wrctl	status,r2
  
  return context;
 82174c8:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 82174cc:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
 82174d0:	e0bffe03 	ldbu	r2,-8(fp)
 82174d4:	10c00060 	cmpeqi	r3,r2,1
 82174d8:	1800921e 	bne	r3,zero,8217724 <OSFlagPend+0x36c>
 82174dc:	10c00088 	cmpgei	r3,r2,2
 82174e0:	1800021e 	bne	r3,zero,82174ec <OSFlagPend+0x134>
 82174e4:	10006126 	beq	r2,zero,821766c <OSFlagPend+0x2b4>
 82174e8:	0000bb06 	br	82177d8 <OSFlagPend+0x420>
 82174ec:	10c000a0 	cmpeqi	r3,r2,2
 82174f0:	1800031e 	bne	r3,zero,8217500 <OSFlagPend+0x148>
 82174f4:	108000e0 	cmpeqi	r2,r2,3
 82174f8:	10002f1e 	bne	r2,zero,82175b8 <OSFlagPend+0x200>
 82174fc:	0000b606 	br	82177d8 <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 8217500:	e0bffc17 	ldw	r2,-16(fp)
 8217504:	10c0020b 	ldhu	r3,8(r2)
 8217508:	e0bffd0b 	ldhu	r2,-12(fp)
 821750c:	1884703a 	and	r2,r3,r2
 8217510:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8217514:	e0ffe80b 	ldhu	r3,-96(fp)
 8217518:	e0bffd0b 	ldhu	r2,-12(fp)
 821751c:	1880171e 	bne	r3,r2,821757c <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217520:	e0bfe403 	ldbu	r2,-112(fp)
 8217524:	10800058 	cmpnei	r2,r2,1
 8217528:	1000091e 	bne	r2,zero,8217550 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 821752c:	e0bffc17 	ldw	r2,-16(fp)
 8217530:	1080020b 	ldhu	r2,8(r2)
 8217534:	1007883a 	mov	r3,r2
 8217538:	e0bfe80b 	ldhu	r2,-96(fp)
 821753c:	0084303a 	nor	r2,zero,r2
 8217540:	1884703a 	and	r2,r3,r2
 8217544:	1007883a 	mov	r3,r2
 8217548:	e0bffc17 	ldw	r2,-16(fp)
 821754c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217550:	d0a07a17 	ldw	r2,-32280(gp)
 8217554:	e0ffe80b 	ldhu	r3,-96(fp)
 8217558:	10c00b0d 	sth	r3,44(r2)
 821755c:	e0bfe517 	ldw	r2,-108(fp)
 8217560:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217564:	e0bfe717 	ldw	r2,-100(fp)
 8217568:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 821756c:	e0800217 	ldw	r2,8(fp)
 8217570:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217574:	e0bfe80b 	ldhu	r2,-96(fp)
 8217578:	0000f806 	br	821795c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 821757c:	e13ffd0b 	ldhu	r4,-12(fp)
 8217580:	e17ffe03 	ldbu	r5,-8(fp)
 8217584:	e0bfff0b 	ldhu	r2,-4(fp)
 8217588:	e0fff704 	addi	r3,fp,-36
 821758c:	d8800015 	stw	r2,0(sp)
 8217590:	280f883a 	mov	r7,r5
 8217594:	200d883a 	mov	r6,r4
 8217598:	180b883a 	mov	r5,r3
 821759c:	e13ffc17 	ldw	r4,-16(fp)
 82175a0:	8217e280 	call	8217e28 <OS_FlagBlock>
 82175a4:	e0bfe517 	ldw	r2,-108(fp)
 82175a8:	e0bfe915 	stw	r2,-92(fp)
 82175ac:	e0bfe917 	ldw	r2,-92(fp)
 82175b0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82175b4:	00009206 	br	8217800 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 82175b8:	e0bffc17 	ldw	r2,-16(fp)
 82175bc:	10c0020b 	ldhu	r3,8(r2)
 82175c0:	e0bffd0b 	ldhu	r2,-12(fp)
 82175c4:	1884703a 	and	r2,r3,r2
 82175c8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 82175cc:	e0bfe80b 	ldhu	r2,-96(fp)
 82175d0:	10001726 	beq	r2,zero,8217630 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82175d4:	e0bfe403 	ldbu	r2,-112(fp)
 82175d8:	10800058 	cmpnei	r2,r2,1
 82175dc:	1000091e 	bne	r2,zero,8217604 <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 82175e0:	e0bffc17 	ldw	r2,-16(fp)
 82175e4:	1080020b 	ldhu	r2,8(r2)
 82175e8:	1007883a 	mov	r3,r2
 82175ec:	e0bfe80b 	ldhu	r2,-96(fp)
 82175f0:	0084303a 	nor	r2,zero,r2
 82175f4:	1884703a 	and	r2,r3,r2
 82175f8:	1007883a 	mov	r3,r2
 82175fc:	e0bffc17 	ldw	r2,-16(fp)
 8217600:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217604:	d0a07a17 	ldw	r2,-32280(gp)
 8217608:	e0ffe80b 	ldhu	r3,-96(fp)
 821760c:	10c00b0d 	sth	r3,44(r2)
 8217610:	e0bfe517 	ldw	r2,-108(fp)
 8217614:	e0bfea15 	stw	r2,-88(fp)
 8217618:	e0bfea17 	ldw	r2,-88(fp)
 821761c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217620:	e0800217 	ldw	r2,8(fp)
 8217624:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217628:	e0bfe80b 	ldhu	r2,-96(fp)
 821762c:	0000cb06 	br	821795c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217630:	e13ffd0b 	ldhu	r4,-12(fp)
 8217634:	e17ffe03 	ldbu	r5,-8(fp)
 8217638:	e0bfff0b 	ldhu	r2,-4(fp)
 821763c:	e0fff704 	addi	r3,fp,-36
 8217640:	d8800015 	stw	r2,0(sp)
 8217644:	280f883a 	mov	r7,r5
 8217648:	200d883a 	mov	r6,r4
 821764c:	180b883a 	mov	r5,r3
 8217650:	e13ffc17 	ldw	r4,-16(fp)
 8217654:	8217e280 	call	8217e28 <OS_FlagBlock>
 8217658:	e0bfe517 	ldw	r2,-108(fp)
 821765c:	e0bfeb15 	stw	r2,-84(fp)
 8217660:	e0bfeb17 	ldw	r2,-84(fp)
 8217664:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217668:	00006506 	br	8217800 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 821766c:	e0bffc17 	ldw	r2,-16(fp)
 8217670:	1080020b 	ldhu	r2,8(r2)
 8217674:	0084303a 	nor	r2,zero,r2
 8217678:	1007883a 	mov	r3,r2
 821767c:	e0bffd0b 	ldhu	r2,-12(fp)
 8217680:	1884703a 	and	r2,r3,r2
 8217684:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8217688:	e0ffe80b 	ldhu	r3,-96(fp)
 821768c:	e0bffd0b 	ldhu	r2,-12(fp)
 8217690:	1880151e 	bne	r3,r2,82176e8 <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217694:	e0bfe403 	ldbu	r2,-112(fp)
 8217698:	10800058 	cmpnei	r2,r2,1
 821769c:	1000071e 	bne	r2,zero,82176bc <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 82176a0:	e0bffc17 	ldw	r2,-16(fp)
 82176a4:	10c0020b 	ldhu	r3,8(r2)
 82176a8:	e0bfe80b 	ldhu	r2,-96(fp)
 82176ac:	1884b03a 	or	r2,r3,r2
 82176b0:	1007883a 	mov	r3,r2
 82176b4:	e0bffc17 	ldw	r2,-16(fp)
 82176b8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 82176bc:	d0a07a17 	ldw	r2,-32280(gp)
 82176c0:	e0ffe80b 	ldhu	r3,-96(fp)
 82176c4:	10c00b0d 	sth	r3,44(r2)
 82176c8:	e0bfe517 	ldw	r2,-108(fp)
 82176cc:	e0bfec15 	stw	r2,-80(fp)
 82176d0:	e0bfec17 	ldw	r2,-80(fp)
 82176d4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 82176d8:	e0800217 	ldw	r2,8(fp)
 82176dc:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 82176e0:	e0bfe80b 	ldhu	r2,-96(fp)
 82176e4:	00009d06 	br	821795c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 82176e8:	e13ffd0b 	ldhu	r4,-12(fp)
 82176ec:	e17ffe03 	ldbu	r5,-8(fp)
 82176f0:	e0bfff0b 	ldhu	r2,-4(fp)
 82176f4:	e0fff704 	addi	r3,fp,-36
 82176f8:	d8800015 	stw	r2,0(sp)
 82176fc:	280f883a 	mov	r7,r5
 8217700:	200d883a 	mov	r6,r4
 8217704:	180b883a 	mov	r5,r3
 8217708:	e13ffc17 	ldw	r4,-16(fp)
 821770c:	8217e280 	call	8217e28 <OS_FlagBlock>
 8217710:	e0bfe517 	ldw	r2,-108(fp)
 8217714:	e0bfed15 	stw	r2,-76(fp)
 8217718:	e0bfed17 	ldw	r2,-76(fp)
 821771c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217720:	00003706 	br	8217800 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 8217724:	e0bffc17 	ldw	r2,-16(fp)
 8217728:	1080020b 	ldhu	r2,8(r2)
 821772c:	0084303a 	nor	r2,zero,r2
 8217730:	1007883a 	mov	r3,r2
 8217734:	e0bffd0b 	ldhu	r2,-12(fp)
 8217738:	1884703a 	and	r2,r3,r2
 821773c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8217740:	e0bfe80b 	ldhu	r2,-96(fp)
 8217744:	10001526 	beq	r2,zero,821779c <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217748:	e0bfe403 	ldbu	r2,-112(fp)
 821774c:	10800058 	cmpnei	r2,r2,1
 8217750:	1000071e 	bne	r2,zero,8217770 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8217754:	e0bffc17 	ldw	r2,-16(fp)
 8217758:	10c0020b 	ldhu	r3,8(r2)
 821775c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217760:	1884b03a 	or	r2,r3,r2
 8217764:	1007883a 	mov	r3,r2
 8217768:	e0bffc17 	ldw	r2,-16(fp)
 821776c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217770:	d0a07a17 	ldw	r2,-32280(gp)
 8217774:	e0ffe80b 	ldhu	r3,-96(fp)
 8217778:	10c00b0d 	sth	r3,44(r2)
 821777c:	e0bfe517 	ldw	r2,-108(fp)
 8217780:	e0bfee15 	stw	r2,-72(fp)
 8217784:	e0bfee17 	ldw	r2,-72(fp)
 8217788:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 821778c:	e0800217 	ldw	r2,8(fp)
 8217790:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217794:	e0bfe80b 	ldhu	r2,-96(fp)
 8217798:	00007006 	br	821795c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 821779c:	e13ffd0b 	ldhu	r4,-12(fp)
 82177a0:	e17ffe03 	ldbu	r5,-8(fp)
 82177a4:	e0bfff0b 	ldhu	r2,-4(fp)
 82177a8:	e0fff704 	addi	r3,fp,-36
 82177ac:	d8800015 	stw	r2,0(sp)
 82177b0:	280f883a 	mov	r7,r5
 82177b4:	200d883a 	mov	r6,r4
 82177b8:	180b883a 	mov	r5,r3
 82177bc:	e13ffc17 	ldw	r4,-16(fp)
 82177c0:	8217e280 	call	8217e28 <OS_FlagBlock>
 82177c4:	e0bfe517 	ldw	r2,-108(fp)
 82177c8:	e0bfef15 	stw	r2,-68(fp)
 82177cc:	e0bfef17 	ldw	r2,-68(fp)
 82177d0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82177d4:	00000a06 	br	8217800 <OSFlagPend+0x448>
 82177d8:	e0bfe517 	ldw	r2,-108(fp)
 82177dc:	e0bff015 	stw	r2,-64(fp)
 82177e0:	e0bff017 	ldw	r2,-64(fp)
 82177e4:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 82177e8:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 82177ec:	e0800217 	ldw	r2,8(fp)
 82177f0:	00c01bc4 	movi	r3,111
 82177f4:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 82177f8:	e0bfe80b 	ldhu	r2,-96(fp)
 82177fc:	00005706 	br	821795c <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 8217800:	82162700 	call	8216270 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217804:	0005303a 	rdctl	r2,status
 8217808:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821780c:	e0fff117 	ldw	r3,-60(fp)
 8217810:	00bfff84 	movi	r2,-2
 8217814:	1884703a 	and	r2,r3,r2
 8217818:	1001703a 	wrctl	status,r2
  
  return context;
 821781c:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
 8217820:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 8217824:	d0a07a17 	ldw	r2,-32280(gp)
 8217828:	10800c43 	ldbu	r2,49(r2)
 821782c:	10803fcc 	andi	r2,r2,255
 8217830:	10001c26 	beq	r2,zero,82178a4 <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 8217834:	d0a07a17 	ldw	r2,-32280(gp)
 8217838:	10800c43 	ldbu	r2,49(r2)
 821783c:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8217840:	d0a07a17 	ldw	r2,-32280(gp)
 8217844:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 8217848:	e0bff704 	addi	r2,fp,-36
 821784c:	1009883a 	mov	r4,r2
 8217850:	821815c0 	call	821815c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 8217854:	d0a07a17 	ldw	r2,-32280(gp)
 8217858:	10000c05 	stb	zero,48(r2)
 821785c:	e0bfe517 	ldw	r2,-108(fp)
 8217860:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217864:	e0bff217 	ldw	r2,-56(fp)
 8217868:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 821786c:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
 8217870:	e0bff303 	ldbu	r2,-52(fp)
 8217874:	108000a0 	cmpeqi	r2,r2,2
 8217878:	10000426 	beq	r2,zero,821788c <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 821787c:	e0800217 	ldw	r2,8(fp)
 8217880:	00c00384 	movi	r3,14
 8217884:	10c00005 	stb	r3,0(r2)
                 break;
 8217888:	00000406 	br	821789c <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 821788c:	e0800217 	ldw	r2,8(fp)
 8217890:	00c00284 	movi	r3,10
 8217894:	10c00005 	stb	r3,0(r2)
                 break;
 8217898:	0001883a 	nop
        }
        return (flags_rdy);
 821789c:	e0bfe80b 	ldhu	r2,-96(fp)
 82178a0:	00002e06 	br	821795c <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 82178a4:	d0a07a17 	ldw	r2,-32280(gp)
 82178a8:	10800b0b 	ldhu	r2,44(r2)
 82178ac:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 82178b0:	e0bfe403 	ldbu	r2,-112(fp)
 82178b4:	10800058 	cmpnei	r2,r2,1
 82178b8:	1000211e 	bne	r2,zero,8217940 <OSFlagPend+0x588>
        switch (wait_type) {
 82178bc:	e0bffe03 	ldbu	r2,-8(fp)
 82178c0:	10001616 	blt	r2,zero,821791c <OSFlagPend+0x564>
 82178c4:	10c00090 	cmplti	r3,r2,2
 82178c8:	18000c1e 	bne	r3,zero,82178fc <OSFlagPend+0x544>
 82178cc:	10800108 	cmpgei	r2,r2,4
 82178d0:	1000121e 	bne	r2,zero,821791c <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 82178d4:	e0bffc17 	ldw	r2,-16(fp)
 82178d8:	1080020b 	ldhu	r2,8(r2)
 82178dc:	1007883a 	mov	r3,r2
 82178e0:	e0bfe80b 	ldhu	r2,-96(fp)
 82178e4:	0084303a 	nor	r2,zero,r2
 82178e8:	1884703a 	and	r2,r3,r2
 82178ec:	1007883a 	mov	r3,r2
 82178f0:	e0bffc17 	ldw	r2,-16(fp)
 82178f4:	10c0020d 	sth	r3,8(r2)
                 break;
 82178f8:	00001106 	br	8217940 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 82178fc:	e0bffc17 	ldw	r2,-16(fp)
 8217900:	10c0020b 	ldhu	r3,8(r2)
 8217904:	e0bfe80b 	ldhu	r2,-96(fp)
 8217908:	1884b03a 	or	r2,r3,r2
 821790c:	1007883a 	mov	r3,r2
 8217910:	e0bffc17 	ldw	r2,-16(fp)
 8217914:	10c0020d 	sth	r3,8(r2)
                 break;
 8217918:	00000906 	br	8217940 <OSFlagPend+0x588>
 821791c:	e0bfe517 	ldw	r2,-108(fp)
 8217920:	e0bff415 	stw	r2,-48(fp)
 8217924:	e0bff417 	ldw	r2,-48(fp)
 8217928:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 821792c:	e0800217 	ldw	r2,8(fp)
 8217930:	00c01bc4 	movi	r3,111
 8217934:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217938:	0005883a 	mov	r2,zero
 821793c:	00000706 	br	821795c <OSFlagPend+0x5a4>
 8217940:	e0bfe517 	ldw	r2,-108(fp)
 8217944:	e0bff515 	stw	r2,-44(fp)
 8217948:	e0bff517 	ldw	r2,-44(fp)
 821794c:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 8217950:	e0800217 	ldw	r2,8(fp)
 8217954:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 8217958:	e0bfe80b 	ldhu	r2,-96(fp)
}
 821795c:	e037883a 	mov	sp,fp
 8217960:	dfc00117 	ldw	ra,4(sp)
 8217964:	df000017 	ldw	fp,0(sp)
 8217968:	dec00204 	addi	sp,sp,8
 821796c:	f800283a 	ret

08217970 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 8217970:	defffb04 	addi	sp,sp,-20
 8217974:	df000415 	stw	fp,16(sp)
 8217978:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 821797c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217980:	0005303a 	rdctl	r2,status
 8217984:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217988:	e0fffe17 	ldw	r3,-8(fp)
 821798c:	00bfff84 	movi	r2,-2
 8217990:	1884703a 	and	r2,r3,r2
 8217994:	1001703a 	wrctl	status,r2
  
  return context;
 8217998:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 821799c:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 82179a0:	d0a07a17 	ldw	r2,-32280(gp)
 82179a4:	10800b0b 	ldhu	r2,44(r2)
 82179a8:	e0bffd0d 	sth	r2,-12(fp)
 82179ac:	e0bffc17 	ldw	r2,-16(fp)
 82179b0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82179b4:	e0bfff17 	ldw	r2,-4(fp)
 82179b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 82179bc:	e0bffd0b 	ldhu	r2,-12(fp)
}
 82179c0:	e037883a 	mov	sp,fp
 82179c4:	df000017 	ldw	fp,0(sp)
 82179c8:	dec00104 	addi	sp,sp,4
 82179cc:	f800283a 	ret

082179d0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 82179d0:	deffef04 	addi	sp,sp,-68
 82179d4:	dfc01015 	stw	ra,64(sp)
 82179d8:	df000f15 	stw	fp,60(sp)
 82179dc:	df000f04 	addi	fp,sp,60
 82179e0:	e13ffc15 	stw	r4,-16(fp)
 82179e4:	2807883a 	mov	r3,r5
 82179e8:	3005883a 	mov	r2,r6
 82179ec:	e1ffff15 	stw	r7,-4(fp)
 82179f0:	e0fffd0d 	sth	r3,-12(fp)
 82179f4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 82179f8:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 82179fc:	e0bfff17 	ldw	r2,-4(fp)
 8217a00:	1000021e 	bne	r2,zero,8217a0c <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 8217a04:	0005883a 	mov	r2,zero
 8217a08:	0000d106 	br	8217d50 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 8217a0c:	e0bffc17 	ldw	r2,-16(fp)
 8217a10:	1000051e 	bne	r2,zero,8217a28 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217a14:	e0bfff17 	ldw	r2,-4(fp)
 8217a18:	00c01b84 	movi	r3,110
 8217a1c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217a20:	0005883a 	mov	r2,zero
 8217a24:	0000ca06 	br	8217d50 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 8217a28:	e0bffc17 	ldw	r2,-16(fp)
 8217a2c:	10800003 	ldbu	r2,0(r2)
 8217a30:	10803fcc 	andi	r2,r2,255
 8217a34:	10800160 	cmpeqi	r2,r2,5
 8217a38:	1000051e 	bne	r2,zero,8217a50 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 8217a3c:	e0bfff17 	ldw	r2,-4(fp)
 8217a40:	00c00044 	movi	r3,1
 8217a44:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217a48:	0005883a 	mov	r2,zero
 8217a4c:	0000c006 	br	8217d50 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217a50:	0005303a 	rdctl	r2,status
 8217a54:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217a58:	e0fffb17 	ldw	r3,-20(fp)
 8217a5c:	00bfff84 	movi	r2,-2
 8217a60:	1884703a 	and	r2,r3,r2
 8217a64:	1001703a 	wrctl	status,r2
  
  return context;
 8217a68:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 8217a6c:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 8217a70:	e0bffe03 	ldbu	r2,-8(fp)
 8217a74:	10000326 	beq	r2,zero,8217a84 <OSFlagPost+0xb4>
 8217a78:	10800060 	cmpeqi	r2,r2,1
 8217a7c:	10000b1e 	bne	r2,zero,8217aac <OSFlagPost+0xdc>
 8217a80:	00001206 	br	8217acc <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 8217a84:	e0bffc17 	ldw	r2,-16(fp)
 8217a88:	1080020b 	ldhu	r2,8(r2)
 8217a8c:	1007883a 	mov	r3,r2
 8217a90:	e0bffd0b 	ldhu	r2,-12(fp)
 8217a94:	0084303a 	nor	r2,zero,r2
 8217a98:	1884703a 	and	r2,r3,r2
 8217a9c:	1007883a 	mov	r3,r2
 8217aa0:	e0bffc17 	ldw	r2,-16(fp)
 8217aa4:	10c0020d 	sth	r3,8(r2)
             break;
 8217aa8:	00001106 	br	8217af0 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 8217aac:	e0bffc17 	ldw	r2,-16(fp)
 8217ab0:	10c0020b 	ldhu	r3,8(r2)
 8217ab4:	e0bffd0b 	ldhu	r2,-12(fp)
 8217ab8:	1884b03a 	or	r2,r3,r2
 8217abc:	1007883a 	mov	r3,r2
 8217ac0:	e0bffc17 	ldw	r2,-16(fp)
 8217ac4:	10c0020d 	sth	r3,8(r2)
             break;
 8217ac8:	00000906 	br	8217af0 <OSFlagPost+0x120>
 8217acc:	e0bff317 	ldw	r2,-52(fp)
 8217ad0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217ad4:	e0bff417 	ldw	r2,-48(fp)
 8217ad8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 8217adc:	e0bfff17 	ldw	r2,-4(fp)
 8217ae0:	00c01c44 	movi	r3,113
 8217ae4:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 8217ae8:	0005883a 	mov	r2,zero
 8217aec:	00009806 	br	8217d50 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 8217af0:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217af4:	e0bffc17 	ldw	r2,-16(fp)
 8217af8:	10800117 	ldw	r2,4(r2)
 8217afc:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217b00:	00007706 	br	8217ce0 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 8217b04:	e0bff117 	ldw	r2,-60(fp)
 8217b08:	10800483 	ldbu	r2,18(r2)
 8217b0c:	10803fcc 	andi	r2,r2,255
 8217b10:	10c00060 	cmpeqi	r3,r2,1
 8217b14:	18004a1e 	bne	r3,zero,8217c40 <OSFlagPost+0x270>
 8217b18:	10c00088 	cmpgei	r3,r2,2
 8217b1c:	1800021e 	bne	r3,zero,8217b28 <OSFlagPost+0x158>
 8217b20:	10002f26 	beq	r2,zero,8217be0 <OSFlagPost+0x210>
 8217b24:	00005b06 	br	8217c94 <OSFlagPost+0x2c4>
 8217b28:	10c000a0 	cmpeqi	r3,r2,2
 8217b2c:	1800031e 	bne	r3,zero,8217b3c <OSFlagPost+0x16c>
 8217b30:	108000e0 	cmpeqi	r2,r2,3
 8217b34:	1000171e 	bne	r2,zero,8217b94 <OSFlagPost+0x1c4>
 8217b38:	00005606 	br	8217c94 <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217b3c:	e0bffc17 	ldw	r2,-16(fp)
 8217b40:	10c0020b 	ldhu	r3,8(r2)
 8217b44:	e0bff117 	ldw	r2,-60(fp)
 8217b48:	1080040b 	ldhu	r2,16(r2)
 8217b4c:	1884703a 	and	r2,r3,r2
 8217b50:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217b54:	e0bff117 	ldw	r2,-60(fp)
 8217b58:	1080040b 	ldhu	r2,16(r2)
 8217b5c:	10ffffcc 	andi	r3,r2,65535
 8217b60:	e0bff60b 	ldhu	r2,-40(fp)
 8217b64:	1880541e 	bne	r3,r2,8217cb8 <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217b68:	e0bff60b 	ldhu	r2,-40(fp)
 8217b6c:	100b883a 	mov	r5,r2
 8217b70:	e13ff117 	ldw	r4,-60(fp)
 8217b74:	82180680 	call	8218068 <OS_FlagTaskRdy>
 8217b78:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217b7c:	e0bff683 	ldbu	r2,-38(fp)
 8217b80:	10800058 	cmpnei	r2,r2,1
 8217b84:	10004c1e 	bne	r2,zero,8217cb8 <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217b88:	00800044 	movi	r2,1
 8217b8c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217b90:	00004906 	br	8217cb8 <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217b94:	e0bffc17 	ldw	r2,-16(fp)
 8217b98:	10c0020b 	ldhu	r3,8(r2)
 8217b9c:	e0bff117 	ldw	r2,-60(fp)
 8217ba0:	1080040b 	ldhu	r2,16(r2)
 8217ba4:	1884703a 	and	r2,r3,r2
 8217ba8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217bac:	e0bff60b 	ldhu	r2,-40(fp)
 8217bb0:	10004326 	beq	r2,zero,8217cc0 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217bb4:	e0bff60b 	ldhu	r2,-40(fp)
 8217bb8:	100b883a 	mov	r5,r2
 8217bbc:	e13ff117 	ldw	r4,-60(fp)
 8217bc0:	82180680 	call	8218068 <OS_FlagTaskRdy>
 8217bc4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217bc8:	e0bff683 	ldbu	r2,-38(fp)
 8217bcc:	10800058 	cmpnei	r2,r2,1
 8217bd0:	10003b1e 	bne	r2,zero,8217cc0 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217bd4:	00800044 	movi	r2,1
 8217bd8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217bdc:	00003806 	br	8217cc0 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217be0:	e0bffc17 	ldw	r2,-16(fp)
 8217be4:	1080020b 	ldhu	r2,8(r2)
 8217be8:	0084303a 	nor	r2,zero,r2
 8217bec:	1007883a 	mov	r3,r2
 8217bf0:	e0bff117 	ldw	r2,-60(fp)
 8217bf4:	1080040b 	ldhu	r2,16(r2)
 8217bf8:	1884703a 	and	r2,r3,r2
 8217bfc:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217c00:	e0bff117 	ldw	r2,-60(fp)
 8217c04:	1080040b 	ldhu	r2,16(r2)
 8217c08:	10ffffcc 	andi	r3,r2,65535
 8217c0c:	e0bff60b 	ldhu	r2,-40(fp)
 8217c10:	18802d1e 	bne	r3,r2,8217cc8 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217c14:	e0bff60b 	ldhu	r2,-40(fp)
 8217c18:	100b883a 	mov	r5,r2
 8217c1c:	e13ff117 	ldw	r4,-60(fp)
 8217c20:	82180680 	call	8218068 <OS_FlagTaskRdy>
 8217c24:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217c28:	e0bff683 	ldbu	r2,-38(fp)
 8217c2c:	10800058 	cmpnei	r2,r2,1
 8217c30:	1000251e 	bne	r2,zero,8217cc8 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217c34:	00800044 	movi	r2,1
 8217c38:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217c3c:	00002206 	br	8217cc8 <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217c40:	e0bffc17 	ldw	r2,-16(fp)
 8217c44:	1080020b 	ldhu	r2,8(r2)
 8217c48:	0084303a 	nor	r2,zero,r2
 8217c4c:	1007883a 	mov	r3,r2
 8217c50:	e0bff117 	ldw	r2,-60(fp)
 8217c54:	1080040b 	ldhu	r2,16(r2)
 8217c58:	1884703a 	and	r2,r3,r2
 8217c5c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217c60:	e0bff60b 	ldhu	r2,-40(fp)
 8217c64:	10001a26 	beq	r2,zero,8217cd0 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217c68:	e0bff60b 	ldhu	r2,-40(fp)
 8217c6c:	100b883a 	mov	r5,r2
 8217c70:	e13ff117 	ldw	r4,-60(fp)
 8217c74:	82180680 	call	8218068 <OS_FlagTaskRdy>
 8217c78:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217c7c:	e0bff683 	ldbu	r2,-38(fp)
 8217c80:	10800058 	cmpnei	r2,r2,1
 8217c84:	1000121e 	bne	r2,zero,8217cd0 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217c88:	00800044 	movi	r2,1
 8217c8c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217c90:	00000f06 	br	8217cd0 <OSFlagPost+0x300>
 8217c94:	e0bff317 	ldw	r2,-52(fp)
 8217c98:	e0bff515 	stw	r2,-44(fp)
 8217c9c:	e0bff517 	ldw	r2,-44(fp)
 8217ca0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217ca4:	e0bfff17 	ldw	r2,-4(fp)
 8217ca8:	00c01bc4 	movi	r3,111
 8217cac:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217cb0:	0005883a 	mov	r2,zero
 8217cb4:	00002606 	br	8217d50 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217cb8:	0001883a 	nop
 8217cbc:	00000506 	br	8217cd4 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217cc0:	0001883a 	nop
 8217cc4:	00000306 	br	8217cd4 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217cc8:	0001883a 	nop
 8217ccc:	00000106 	br	8217cd4 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217cd0:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 8217cd4:	e0bff117 	ldw	r2,-60(fp)
 8217cd8:	10800017 	ldw	r2,0(r2)
 8217cdc:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217ce0:	e0bff117 	ldw	r2,-60(fp)
 8217ce4:	103f871e 	bne	r2,zero,8217b04 <OSFlagPost+0x134>
 8217ce8:	e0bff317 	ldw	r2,-52(fp)
 8217cec:	e0bff715 	stw	r2,-36(fp)
 8217cf0:	e0bff717 	ldw	r2,-36(fp)
 8217cf4:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 8217cf8:	e0bff203 	ldbu	r2,-56(fp)
 8217cfc:	10800058 	cmpnei	r2,r2,1
 8217d00:	1000011e 	bne	r2,zero,8217d08 <OSFlagPost+0x338>
        OS_Sched();
 8217d04:	82162700 	call	8216270 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217d08:	0005303a 	rdctl	r2,status
 8217d0c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217d10:	e0fffa17 	ldw	r3,-24(fp)
 8217d14:	00bfff84 	movi	r2,-2
 8217d18:	1884703a 	and	r2,r3,r2
 8217d1c:	1001703a 	wrctl	status,r2
  
  return context;
 8217d20:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 8217d24:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 8217d28:	e0bffc17 	ldw	r2,-16(fp)
 8217d2c:	1080020b 	ldhu	r2,8(r2)
 8217d30:	e0bff90d 	sth	r2,-28(fp)
 8217d34:	e0bff317 	ldw	r2,-52(fp)
 8217d38:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217d3c:	e0bff817 	ldw	r2,-32(fp)
 8217d40:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 8217d44:	e0bfff17 	ldw	r2,-4(fp)
 8217d48:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 8217d4c:	e0bff90b 	ldhu	r2,-28(fp)
}
 8217d50:	e037883a 	mov	sp,fp
 8217d54:	dfc00117 	ldw	ra,4(sp)
 8217d58:	df000017 	ldw	fp,0(sp)
 8217d5c:	dec00204 	addi	sp,sp,8
 8217d60:	f800283a 	ret

08217d64 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 8217d64:	defff904 	addi	sp,sp,-28
 8217d68:	df000615 	stw	fp,24(sp)
 8217d6c:	df000604 	addi	fp,sp,24
 8217d70:	e13ffe15 	stw	r4,-8(fp)
 8217d74:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 8217d78:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 8217d7c:	e0bfff17 	ldw	r2,-4(fp)
 8217d80:	1000021e 	bne	r2,zero,8217d8c <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 8217d84:	0005883a 	mov	r2,zero
 8217d88:	00002306 	br	8217e18 <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 8217d8c:	e0bffe17 	ldw	r2,-8(fp)
 8217d90:	1000051e 	bne	r2,zero,8217da8 <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217d94:	e0bfff17 	ldw	r2,-4(fp)
 8217d98:	00c01b84 	movi	r3,110
 8217d9c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217da0:	0005883a 	mov	r2,zero
 8217da4:	00001c06 	br	8217e18 <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 8217da8:	e0bffe17 	ldw	r2,-8(fp)
 8217dac:	10800003 	ldbu	r2,0(r2)
 8217db0:	10803fcc 	andi	r2,r2,255
 8217db4:	10800160 	cmpeqi	r2,r2,5
 8217db8:	1000051e 	bne	r2,zero,8217dd0 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8217dbc:	e0bfff17 	ldw	r2,-4(fp)
 8217dc0:	00c00044 	movi	r3,1
 8217dc4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217dc8:	0005883a 	mov	r2,zero
 8217dcc:	00001206 	br	8217e18 <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217dd0:	0005303a 	rdctl	r2,status
 8217dd4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217dd8:	e0fffc17 	ldw	r3,-16(fp)
 8217ddc:	00bfff84 	movi	r2,-2
 8217de0:	1884703a 	and	r2,r3,r2
 8217de4:	1001703a 	wrctl	status,r2
  
  return context;
 8217de8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8217dec:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 8217df0:	e0bffe17 	ldw	r2,-8(fp)
 8217df4:	1080020b 	ldhu	r2,8(r2)
 8217df8:	e0bffb0d 	sth	r2,-20(fp)
 8217dfc:	e0bffa17 	ldw	r2,-24(fp)
 8217e00:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217e04:	e0bffd17 	ldw	r2,-12(fp)
 8217e08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217e0c:	e0bfff17 	ldw	r2,-4(fp)
 8217e10:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 8217e14:	e0bffb0b 	ldhu	r2,-20(fp)
}
 8217e18:	e037883a 	mov	sp,fp
 8217e1c:	df000017 	ldw	fp,0(sp)
 8217e20:	dec00104 	addi	sp,sp,4
 8217e24:	f800283a 	ret

08217e28 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 8217e28:	defff804 	addi	sp,sp,-32
 8217e2c:	df000715 	stw	fp,28(sp)
 8217e30:	df000704 	addi	fp,sp,28
 8217e34:	e13ffb15 	stw	r4,-20(fp)
 8217e38:	e17ffc15 	stw	r5,-16(fp)
 8217e3c:	3009883a 	mov	r4,r6
 8217e40:	3807883a 	mov	r3,r7
 8217e44:	e0800117 	ldw	r2,4(fp)
 8217e48:	e13ffd0d 	sth	r4,-12(fp)
 8217e4c:	e0fffe05 	stb	r3,-8(fp)
 8217e50:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 8217e54:	d0a07a17 	ldw	r2,-32280(gp)
 8217e58:	d0e07a17 	ldw	r3,-32280(gp)
 8217e5c:	18c00c03 	ldbu	r3,48(r3)
 8217e60:	18c00814 	ori	r3,r3,32
 8217e64:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 8217e68:	d0a07a17 	ldw	r2,-32280(gp)
 8217e6c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 8217e70:	d0a07a17 	ldw	r2,-32280(gp)
 8217e74:	e0ffff0b 	ldhu	r3,-4(fp)
 8217e78:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 8217e7c:	d0a07a17 	ldw	r2,-32280(gp)
 8217e80:	e0fffc17 	ldw	r3,-16(fp)
 8217e84:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 8217e88:	e0bffc17 	ldw	r2,-16(fp)
 8217e8c:	e0fffd0b 	ldhu	r3,-12(fp)
 8217e90:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 8217e94:	e0bffc17 	ldw	r2,-16(fp)
 8217e98:	e0fffe03 	ldbu	r3,-8(fp)
 8217e9c:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 8217ea0:	d0e07a17 	ldw	r3,-32280(gp)
 8217ea4:	e0bffc17 	ldw	r2,-16(fp)
 8217ea8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 8217eac:	e0bffb17 	ldw	r2,-20(fp)
 8217eb0:	10c00117 	ldw	r3,4(r2)
 8217eb4:	e0bffc17 	ldw	r2,-16(fp)
 8217eb8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 8217ebc:	e0bffc17 	ldw	r2,-16(fp)
 8217ec0:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 8217ec4:	e0bffc17 	ldw	r2,-16(fp)
 8217ec8:	e0fffb17 	ldw	r3,-20(fp)
 8217ecc:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217ed0:	e0bffb17 	ldw	r2,-20(fp)
 8217ed4:	10800117 	ldw	r2,4(r2)
 8217ed8:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 8217edc:	e0bff917 	ldw	r2,-28(fp)
 8217ee0:	10000326 	beq	r2,zero,8217ef0 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 8217ee4:	e0bff917 	ldw	r2,-28(fp)
 8217ee8:	e0fffc17 	ldw	r3,-16(fp)
 8217eec:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 8217ef0:	e0bffb17 	ldw	r2,-20(fp)
 8217ef4:	e0fffc17 	ldw	r3,-16(fp)
 8217ef8:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 8217efc:	d0a07a17 	ldw	r2,-32280(gp)
 8217f00:	10800d03 	ldbu	r2,52(r2)
 8217f04:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 8217f08:	e0fffa03 	ldbu	r3,-24(fp)
 8217f0c:	e13ffa03 	ldbu	r4,-24(fp)
 8217f10:	d0a07744 	addi	r2,gp,-32291
 8217f14:	2085883a 	add	r2,r4,r2
 8217f18:	10800003 	ldbu	r2,0(r2)
 8217f1c:	1009883a 	mov	r4,r2
 8217f20:	d0a07a17 	ldw	r2,-32280(gp)
 8217f24:	10800d43 	ldbu	r2,53(r2)
 8217f28:	0084303a 	nor	r2,zero,r2
 8217f2c:	2084703a 	and	r2,r4,r2
 8217f30:	1009883a 	mov	r4,r2
 8217f34:	d0a07744 	addi	r2,gp,-32291
 8217f38:	1885883a 	add	r2,r3,r2
 8217f3c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 8217f40:	e0fffa03 	ldbu	r3,-24(fp)
 8217f44:	d0a07744 	addi	r2,gp,-32291
 8217f48:	1885883a 	add	r2,r3,r2
 8217f4c:	10800003 	ldbu	r2,0(r2)
 8217f50:	10803fcc 	andi	r2,r2,255
 8217f54:	1000071e 	bne	r2,zero,8217f74 <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 8217f58:	d0a07a17 	ldw	r2,-32280(gp)
 8217f5c:	10800d83 	ldbu	r2,54(r2)
 8217f60:	0084303a 	nor	r2,zero,r2
 8217f64:	1007883a 	mov	r3,r2
 8217f68:	d0a07703 	ldbu	r2,-32292(gp)
 8217f6c:	1884703a 	and	r2,r3,r2
 8217f70:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8217f74:	0001883a 	nop
 8217f78:	e037883a 	mov	sp,fp
 8217f7c:	df000017 	ldw	fp,0(sp)
 8217f80:	dec00104 	addi	sp,sp,4
 8217f84:	f800283a 	ret

08217f88 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 8217f88:	defffb04 	addi	sp,sp,-20
 8217f8c:	dfc00415 	stw	ra,16(sp)
 8217f90:	df000315 	stw	fp,12(sp)
 8217f94:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 8217f98:	0140dc04 	movi	r5,880
 8217f9c:	010209b4 	movhi	r4,2086
 8217fa0:	21295404 	addi	r4,r4,-23216
 8217fa4:	82161b40 	call	82161b4 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 8217fa8:	008209b4 	movhi	r2,2086
 8217fac:	10a95404 	addi	r2,r2,-23216
 8217fb0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 8217fb4:	008209b4 	movhi	r2,2086
 8217fb8:	10a95f04 	addi	r2,r2,-23172
 8217fbc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8217fc0:	e03ffd0d 	sth	zero,-12(fp)
 8217fc4:	00001306 	br	8218014 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217fc8:	e0bffe17 	ldw	r2,-8(fp)
 8217fcc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 8217fd0:	e0bffe17 	ldw	r2,-8(fp)
 8217fd4:	e0ffff17 	ldw	r3,-4(fp)
 8217fd8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 8217fdc:	e0bffe17 	ldw	r2,-8(fp)
 8217fe0:	00c00fc4 	movi	r3,63
 8217fe4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 8217fe8:	e0bffe17 	ldw	r2,-8(fp)
 8217fec:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 8217ff0:	e0bffe17 	ldw	r2,-8(fp)
 8217ff4:	10800b04 	addi	r2,r2,44
 8217ff8:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 8217ffc:	e0bfff17 	ldw	r2,-4(fp)
 8218000:	10800b04 	addi	r2,r2,44
 8218004:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8218008:	e0bffd0b 	ldhu	r2,-12(fp)
 821800c:	10800044 	addi	r2,r2,1
 8218010:	e0bffd0d 	sth	r2,-12(fp)
 8218014:	e0bffd0b 	ldhu	r2,-12(fp)
 8218018:	108004f0 	cmpltui	r2,r2,19
 821801c:	103fea1e 	bne	r2,zero,8217fc8 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8218020:	e0bffe17 	ldw	r2,-8(fp)
 8218024:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 8218028:	e0bffe17 	ldw	r2,-8(fp)
 821802c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 8218030:	e0bffe17 	ldw	r2,-8(fp)
 8218034:	00c00fc4 	movi	r3,63
 8218038:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 821803c:	e0bffe17 	ldw	r2,-8(fp)
 8218040:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 8218044:	008209b4 	movhi	r2,2086
 8218048:	10a95404 	addi	r2,r2,-23216
 821804c:	d0a07c15 	stw	r2,-32272(gp)
#endif
}
 8218050:	0001883a 	nop
 8218054:	e037883a 	mov	sp,fp
 8218058:	dfc00117 	ldw	ra,4(sp)
 821805c:	df000017 	ldw	fp,0(sp)
 8218060:	dec00204 	addi	sp,sp,8
 8218064:	f800283a 	ret

08218068 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 8218068:	defffa04 	addi	sp,sp,-24
 821806c:	dfc00515 	stw	ra,20(sp)
 8218070:	df000415 	stw	fp,16(sp)
 8218074:	df000404 	addi	fp,sp,16
 8218078:	e13ffe15 	stw	r4,-8(fp)
 821807c:	2805883a 	mov	r2,r5
 8218080:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 8218084:	e0bffe17 	ldw	r2,-8(fp)
 8218088:	10800217 	ldw	r2,8(r2)
 821808c:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 8218090:	e0bffd17 	ldw	r2,-12(fp)
 8218094:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 8218098:	e0bffd17 	ldw	r2,-12(fp)
 821809c:	e0ffff0b 	ldhu	r3,-4(fp)
 82180a0:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 82180a4:	e0bffd17 	ldw	r2,-12(fp)
 82180a8:	10c00c03 	ldbu	r3,48(r2)
 82180ac:	00bff7c4 	movi	r2,-33
 82180b0:	1884703a 	and	r2,r3,r2
 82180b4:	1007883a 	mov	r3,r2
 82180b8:	e0bffd17 	ldw	r2,-12(fp)
 82180bc:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 82180c0:	e0bffd17 	ldw	r2,-12(fp)
 82180c4:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 82180c8:	e0bffd17 	ldw	r2,-12(fp)
 82180cc:	10800c03 	ldbu	r2,48(r2)
 82180d0:	10803fcc 	andi	r2,r2,255
 82180d4:	1000181e 	bne	r2,zero,8218138 <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 82180d8:	e0bffd17 	ldw	r2,-12(fp)
 82180dc:	10c00d83 	ldbu	r3,54(r2)
 82180e0:	d0a07703 	ldbu	r2,-32292(gp)
 82180e4:	1884b03a 	or	r2,r3,r2
 82180e8:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 82180ec:	e0bffd17 	ldw	r2,-12(fp)
 82180f0:	10800d03 	ldbu	r2,52(r2)
 82180f4:	10c03fcc 	andi	r3,r2,255
 82180f8:	e0bffd17 	ldw	r2,-12(fp)
 82180fc:	10800d03 	ldbu	r2,52(r2)
 8218100:	11003fcc 	andi	r4,r2,255
 8218104:	d0a07744 	addi	r2,gp,-32291
 8218108:	2085883a 	add	r2,r4,r2
 821810c:	11000003 	ldbu	r4,0(r2)
 8218110:	e0bffd17 	ldw	r2,-12(fp)
 8218114:	10800d43 	ldbu	r2,53(r2)
 8218118:	2084b03a 	or	r2,r4,r2
 821811c:	1009883a 	mov	r4,r2
 8218120:	d0a07744 	addi	r2,gp,-32291
 8218124:	1885883a 	add	r2,r3,r2
 8218128:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
 821812c:	00800044 	movi	r2,1
 8218130:	e0bffc05 	stb	r2,-16(fp)
 8218134:	00000106 	br	821813c <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
 8218138:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 821813c:	e13ffe17 	ldw	r4,-8(fp)
 8218140:	821815c0 	call	821815c <OS_FlagUnlink>
    return (sched);
 8218144:	e0bffc03 	ldbu	r2,-16(fp)
}
 8218148:	e037883a 	mov	sp,fp
 821814c:	dfc00117 	ldw	ra,4(sp)
 8218150:	df000017 	ldw	fp,0(sp)
 8218154:	dec00204 	addi	sp,sp,8
 8218158:	f800283a 	ret

0821815c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 821815c:	defffa04 	addi	sp,sp,-24
 8218160:	df000515 	stw	fp,20(sp)
 8218164:	df000504 	addi	fp,sp,20
 8218168:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 821816c:	e0bfff17 	ldw	r2,-4(fp)
 8218170:	10800117 	ldw	r2,4(r2)
 8218174:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8218178:	e0bfff17 	ldw	r2,-4(fp)
 821817c:	10800017 	ldw	r2,0(r2)
 8218180:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 8218184:	e0bffb17 	ldw	r2,-20(fp)
 8218188:	10000b1e 	bne	r2,zero,82181b8 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 821818c:	e0bfff17 	ldw	r2,-4(fp)
 8218190:	10800317 	ldw	r2,12(r2)
 8218194:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 8218198:	e0bffd17 	ldw	r2,-12(fp)
 821819c:	e0fffc17 	ldw	r3,-16(fp)
 82181a0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 82181a4:	e0bffc17 	ldw	r2,-16(fp)
 82181a8:	10000b26 	beq	r2,zero,82181d8 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 82181ac:	e0bffc17 	ldw	r2,-16(fp)
 82181b0:	10000115 	stw	zero,4(r2)
 82181b4:	00000806 	br	82181d8 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 82181b8:	e0bffb17 	ldw	r2,-20(fp)
 82181bc:	e0fffc17 	ldw	r3,-16(fp)
 82181c0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 82181c4:	e0bffc17 	ldw	r2,-16(fp)
 82181c8:	10000326 	beq	r2,zero,82181d8 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 82181cc:	e0bffc17 	ldw	r2,-16(fp)
 82181d0:	e0fffb17 	ldw	r3,-20(fp)
 82181d4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 82181d8:	e0bfff17 	ldw	r2,-4(fp)
 82181dc:	10800217 	ldw	r2,8(r2)
 82181e0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 82181e4:	e0bffe17 	ldw	r2,-8(fp)
 82181e8:	10000a15 	stw	zero,40(r2)
#endif
}
 82181ec:	0001883a 	nop
 82181f0:	e037883a 	mov	sp,fp
 82181f4:	df000017 	ldw	fp,0(sp)
 82181f8:	dec00104 	addi	sp,sp,4
 82181fc:	f800283a 	ret

08218200 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 8218200:	defff404 	addi	sp,sp,-48
 8218204:	df000b15 	stw	fp,44(sp)
 8218208:	df000b04 	addi	fp,sp,44
 821820c:	e13ffc15 	stw	r4,-16(fp)
 8218210:	e17ffd15 	stw	r5,-12(fp)
 8218214:	e1bffe15 	stw	r6,-8(fp)
 8218218:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821821c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8218220:	e0bfff17 	ldw	r2,-4(fp)
 8218224:	1000021e 	bne	r2,zero,8218230 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 8218228:	0005883a 	mov	r2,zero
 821822c:	00006506 	br	82183c4 <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 8218230:	e0bffc17 	ldw	r2,-16(fp)
 8218234:	1000051e 	bne	r2,zero,821824c <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218238:	e0bfff17 	ldw	r2,-4(fp)
 821823c:	00c01884 	movi	r3,98
 8218240:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218244:	0005883a 	mov	r2,zero
 8218248:	00005e06 	br	82183c4 <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 821824c:	e0bffc17 	ldw	r2,-16(fp)
 8218250:	108000cc 	andi	r2,r2,3
 8218254:	10000526 	beq	r2,zero,821826c <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218258:	e0bfff17 	ldw	r2,-4(fp)
 821825c:	00c01884 	movi	r3,98
 8218260:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218264:	0005883a 	mov	r2,zero
 8218268:	00005606 	br	82183c4 <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 821826c:	e0bffd17 	ldw	r2,-12(fp)
 8218270:	108000a8 	cmpgeui	r2,r2,2
 8218274:	1000051e 	bne	r2,zero,821828c <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 8218278:	e0bfff17 	ldw	r2,-4(fp)
 821827c:	00c016c4 	movi	r3,91
 8218280:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218284:	0005883a 	mov	r2,zero
 8218288:	00004e06 	br	82183c4 <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 821828c:	e0bffe17 	ldw	r2,-8(fp)
 8218290:	10800128 	cmpgeui	r2,r2,4
 8218294:	1000051e 	bne	r2,zero,82182ac <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 8218298:	e0bfff17 	ldw	r2,-4(fp)
 821829c:	00c01704 	movi	r3,92
 82182a0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 82182a4:	0005883a 	mov	r2,zero
 82182a8:	00004606 	br	82183c4 <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82182ac:	0005303a 	rdctl	r2,status
 82182b0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82182b4:	e0fffb17 	ldw	r3,-20(fp)
 82182b8:	00bfff84 	movi	r2,-2
 82182bc:	1884703a 	and	r2,r3,r2
 82182c0:	1001703a 	wrctl	status,r2
  
  return context;
 82182c4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82182c8:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 82182cc:	d0a07417 	ldw	r2,-32304(gp)
 82182d0:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 82182d4:	d0a07417 	ldw	r2,-32304(gp)
 82182d8:	10000326 	beq	r2,zero,82182e8 <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 82182dc:	d0a07417 	ldw	r2,-32304(gp)
 82182e0:	10800117 	ldw	r2,4(r2)
 82182e4:	d0a07415 	stw	r2,-32304(gp)
 82182e8:	e0bff817 	ldw	r2,-32(fp)
 82182ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82182f0:	e0bff917 	ldw	r2,-28(fp)
 82182f4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 82182f8:	e0bffa17 	ldw	r2,-24(fp)
 82182fc:	1000051e 	bne	r2,zero,8218314 <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
 8218300:	e0bfff17 	ldw	r2,-4(fp)
 8218304:	00c01684 	movi	r3,90
 8218308:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821830c:	0005883a 	mov	r2,zero
 8218310:	00002c06 	br	82183c4 <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 8218314:	e0bffc17 	ldw	r2,-16(fp)
 8218318:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 821831c:	e0fffc17 	ldw	r3,-16(fp)
 8218320:	e0bffe17 	ldw	r2,-8(fp)
 8218324:	1885883a 	add	r2,r3,r2
 8218328:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 821832c:	e03ff715 	stw	zero,-36(fp)
 8218330:	00000c06 	br	8218364 <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 8218334:	e0bff617 	ldw	r2,-40(fp)
 8218338:	e0fff517 	ldw	r3,-44(fp)
 821833c:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 8218340:	e0bff517 	ldw	r2,-44(fp)
 8218344:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 8218348:	e0fff517 	ldw	r3,-44(fp)
 821834c:	e0bffe17 	ldw	r2,-8(fp)
 8218350:	1885883a 	add	r2,r3,r2
 8218354:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 8218358:	e0bff717 	ldw	r2,-36(fp)
 821835c:	10800044 	addi	r2,r2,1
 8218360:	e0bff715 	stw	r2,-36(fp)
 8218364:	e0bffd17 	ldw	r2,-12(fp)
 8218368:	10bfffc4 	addi	r2,r2,-1
 821836c:	e0fff717 	ldw	r3,-36(fp)
 8218370:	18bff036 	bltu	r3,r2,8218334 <OSMemCreate+0x134>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 8218374:	e0bff617 	ldw	r2,-40(fp)
 8218378:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 821837c:	e0bffa17 	ldw	r2,-24(fp)
 8218380:	e0fffc17 	ldw	r3,-16(fp)
 8218384:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 8218388:	e0bffa17 	ldw	r2,-24(fp)
 821838c:	e0fffc17 	ldw	r3,-16(fp)
 8218390:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 8218394:	e0bffa17 	ldw	r2,-24(fp)
 8218398:	e0fffd17 	ldw	r3,-12(fp)
 821839c:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 82183a0:	e0bffa17 	ldw	r2,-24(fp)
 82183a4:	e0fffd17 	ldw	r3,-12(fp)
 82183a8:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 82183ac:	e0bffa17 	ldw	r2,-24(fp)
 82183b0:	e0fffe17 	ldw	r3,-8(fp)
 82183b4:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 82183b8:	e0bfff17 	ldw	r2,-4(fp)
 82183bc:	10000005 	stb	zero,0(r2)
    return (pmem);
 82183c0:	e0bffa17 	ldw	r2,-24(fp)
}
 82183c4:	e037883a 	mov	sp,fp
 82183c8:	df000017 	ldw	fp,0(sp)
 82183cc:	dec00104 	addi	sp,sp,4
 82183d0:	f800283a 	ret

082183d4 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 82183d4:	defff804 	addi	sp,sp,-32
 82183d8:	df000715 	stw	fp,28(sp)
 82183dc:	df000704 	addi	fp,sp,28
 82183e0:	e13ffe15 	stw	r4,-8(fp)
 82183e4:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82183e8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 82183ec:	e0bfff17 	ldw	r2,-4(fp)
 82183f0:	1000021e 	bne	r2,zero,82183fc <OSMemGet+0x28>
        return ((void *)0);
 82183f4:	0005883a 	mov	r2,zero
 82183f8:	00002e06 	br	82184b4 <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 82183fc:	e0bffe17 	ldw	r2,-8(fp)
 8218400:	1000051e 	bne	r2,zero,8218418 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 8218404:	e0bfff17 	ldw	r2,-4(fp)
 8218408:	00c01804 	movi	r3,96
 821840c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218410:	0005883a 	mov	r2,zero
 8218414:	00002706 	br	82184b4 <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218418:	0005303a 	rdctl	r2,status
 821841c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218420:	e0fffd17 	ldw	r3,-12(fp)
 8218424:	00bfff84 	movi	r2,-2
 8218428:	1884703a 	and	r2,r3,r2
 821842c:	1001703a 	wrctl	status,r2
  
  return context;
 8218430:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218434:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 8218438:	e0bffe17 	ldw	r2,-8(fp)
 821843c:	10800417 	ldw	r2,16(r2)
 8218440:	10001426 	beq	r2,zero,8218494 <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 8218444:	e0bffe17 	ldw	r2,-8(fp)
 8218448:	10800117 	ldw	r2,4(r2)
 821844c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 8218450:	e0bffb17 	ldw	r2,-20(fp)
 8218454:	10c00017 	ldw	r3,0(r2)
 8218458:	e0bffe17 	ldw	r2,-8(fp)
 821845c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 8218460:	e0bffe17 	ldw	r2,-8(fp)
 8218464:	10800417 	ldw	r2,16(r2)
 8218468:	10ffffc4 	addi	r3,r2,-1
 821846c:	e0bffe17 	ldw	r2,-8(fp)
 8218470:	10c00415 	stw	r3,16(r2)
 8218474:	e0bff917 	ldw	r2,-28(fp)
 8218478:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821847c:	e0bffa17 	ldw	r2,-24(fp)
 8218480:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 8218484:	e0bfff17 	ldw	r2,-4(fp)
 8218488:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 821848c:	e0bffb17 	ldw	r2,-20(fp)
 8218490:	00000806 	br	82184b4 <OSMemGet+0xe0>
 8218494:	e0bff917 	ldw	r2,-28(fp)
 8218498:	e0bffc15 	stw	r2,-16(fp)
 821849c:	e0bffc17 	ldw	r2,-16(fp)
 82184a0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 82184a4:	e0bfff17 	ldw	r2,-4(fp)
 82184a8:	00c01744 	movi	r3,93
 82184ac:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 82184b0:	0005883a 	mov	r2,zero
}
 82184b4:	e037883a 	mov	sp,fp
 82184b8:	df000017 	ldw	fp,0(sp)
 82184bc:	dec00104 	addi	sp,sp,4
 82184c0:	f800283a 	ret

082184c4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82184c4:	defff704 	addi	sp,sp,-36
 82184c8:	dfc00815 	stw	ra,32(sp)
 82184cc:	df000715 	stw	fp,28(sp)
 82184d0:	df000704 	addi	fp,sp,28
 82184d4:	e13ffd15 	stw	r4,-12(fp)
 82184d8:	e17ffe15 	stw	r5,-8(fp)
 82184dc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82184e0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82184e4:	e0bfff17 	ldw	r2,-4(fp)
 82184e8:	1000021e 	bne	r2,zero,82184f4 <OSMemNameGet+0x30>
        return (0);
 82184ec:	0005883a 	mov	r2,zero
 82184f0:	00002b06 	br	82185a0 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82184f4:	e0bffd17 	ldw	r2,-12(fp)
 82184f8:	1000051e 	bne	r2,zero,8218510 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82184fc:	e0bfff17 	ldw	r2,-4(fp)
 8218500:	00c01804 	movi	r3,96
 8218504:	10c00005 	stb	r3,0(r2)
        return (0);
 8218508:	0005883a 	mov	r2,zero
 821850c:	00002406 	br	82185a0 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8218510:	e0bffe17 	ldw	r2,-8(fp)
 8218514:	1000051e 	bne	r2,zero,821852c <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8218518:	e0bfff17 	ldw	r2,-4(fp)
 821851c:	00c00304 	movi	r3,12
 8218520:	10c00005 	stb	r3,0(r2)
        return (0);
 8218524:	0005883a 	mov	r2,zero
 8218528:	00001d06 	br	82185a0 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821852c:	d0a07903 	ldbu	r2,-32284(gp)
 8218530:	10803fcc 	andi	r2,r2,255
 8218534:	10000526 	beq	r2,zero,821854c <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 8218538:	e0bfff17 	ldw	r2,-4(fp)
 821853c:	00c00444 	movi	r3,17
 8218540:	10c00005 	stb	r3,0(r2)
        return (0);
 8218544:	0005883a 	mov	r2,zero
 8218548:	00001506 	br	82185a0 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821854c:	0005303a 	rdctl	r2,status
 8218550:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218554:	e0fffb17 	ldw	r3,-20(fp)
 8218558:	00bfff84 	movi	r2,-2
 821855c:	1884703a 	and	r2,r3,r2
 8218560:	1001703a 	wrctl	status,r2
  
  return context;
 8218564:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 8218568:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 821856c:	e0bffd17 	ldw	r2,-12(fp)
 8218570:	10800504 	addi	r2,r2,20
 8218574:	100b883a 	mov	r5,r2
 8218578:	e13ffe17 	ldw	r4,-8(fp)
 821857c:	82163b40 	call	82163b4 <OS_StrCopy>
 8218580:	e0bffa05 	stb	r2,-24(fp)
 8218584:	e0bff917 	ldw	r2,-28(fp)
 8218588:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821858c:	e0bffc17 	ldw	r2,-16(fp)
 8218590:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8218594:	e0bfff17 	ldw	r2,-4(fp)
 8218598:	10000005 	stb	zero,0(r2)
    return (len);
 821859c:	e0bffa03 	ldbu	r2,-24(fp)
}
 82185a0:	e037883a 	mov	sp,fp
 82185a4:	dfc00117 	ldw	ra,4(sp)
 82185a8:	df000017 	ldw	fp,0(sp)
 82185ac:	dec00204 	addi	sp,sp,8
 82185b0:	f800283a 	ret

082185b4 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82185b4:	defff604 	addi	sp,sp,-40
 82185b8:	dfc00915 	stw	ra,36(sp)
 82185bc:	df000815 	stw	fp,32(sp)
 82185c0:	df000804 	addi	fp,sp,32
 82185c4:	e13ffd15 	stw	r4,-12(fp)
 82185c8:	e17ffe15 	stw	r5,-8(fp)
 82185cc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82185d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82185d4:	e0bfff17 	ldw	r2,-4(fp)
 82185d8:	10003526 	beq	r2,zero,82186b0 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82185dc:	e0bffd17 	ldw	r2,-12(fp)
 82185e0:	1000041e 	bne	r2,zero,82185f4 <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82185e4:	e0bfff17 	ldw	r2,-4(fp)
 82185e8:	00c01804 	movi	r3,96
 82185ec:	10c00005 	stb	r3,0(r2)
        return;
 82185f0:	00003006 	br	82186b4 <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82185f4:	e0bffe17 	ldw	r2,-8(fp)
 82185f8:	1000041e 	bne	r2,zero,821860c <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 82185fc:	e0bfff17 	ldw	r2,-4(fp)
 8218600:	00c00304 	movi	r3,12
 8218604:	10c00005 	stb	r3,0(r2)
        return;
 8218608:	00002a06 	br	82186b4 <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821860c:	d0a07903 	ldbu	r2,-32284(gp)
 8218610:	10803fcc 	andi	r2,r2,255
 8218614:	10000426 	beq	r2,zero,8218628 <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8218618:	e0bfff17 	ldw	r2,-4(fp)
 821861c:	00c00484 	movi	r3,18
 8218620:	10c00005 	stb	r3,0(r2)
        return;
 8218624:	00002306 	br	82186b4 <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218628:	0005303a 	rdctl	r2,status
 821862c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218630:	e0fffc17 	ldw	r3,-16(fp)
 8218634:	00bfff84 	movi	r2,-2
 8218638:	1884703a 	and	r2,r3,r2
 821863c:	1001703a 	wrctl	status,r2
  
  return context;
 8218640:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218644:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 8218648:	e13ffe17 	ldw	r4,-8(fp)
 821864c:	82164280 	call	8216428 <OS_StrLen>
 8218650:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 8218654:	e0bffa03 	ldbu	r2,-24(fp)
 8218658:	10800830 	cmpltui	r2,r2,32
 821865c:	1000081e 	bne	r2,zero,8218680 <OSMemNameSet+0xcc>
 8218660:	e0bff817 	ldw	r2,-32(fp)
 8218664:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218668:	e0bff917 	ldw	r2,-28(fp)
 821866c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 8218670:	e0bfff17 	ldw	r2,-4(fp)
 8218674:	00c018c4 	movi	r3,99
 8218678:	10c00005 	stb	r3,0(r2)
        return;
 821867c:	00000d06 	br	82186b4 <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 8218680:	e0bffd17 	ldw	r2,-12(fp)
 8218684:	10800504 	addi	r2,r2,20
 8218688:	e17ffe17 	ldw	r5,-8(fp)
 821868c:	1009883a 	mov	r4,r2
 8218690:	82163b40 	call	82163b4 <OS_StrCopy>
 8218694:	e0bff817 	ldw	r2,-32(fp)
 8218698:	e0bffb15 	stw	r2,-20(fp)
 821869c:	e0bffb17 	ldw	r2,-20(fp)
 82186a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82186a4:	e0bfff17 	ldw	r2,-4(fp)
 82186a8:	10000005 	stb	zero,0(r2)
 82186ac:	00000106 	br	82186b4 <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 82186b0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 82186b4:	e037883a 	mov	sp,fp
 82186b8:	dfc00117 	ldw	ra,4(sp)
 82186bc:	df000017 	ldw	fp,0(sp)
 82186c0:	dec00204 	addi	sp,sp,8
 82186c4:	f800283a 	ret

082186c8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 82186c8:	defff904 	addi	sp,sp,-28
 82186cc:	df000615 	stw	fp,24(sp)
 82186d0:	df000604 	addi	fp,sp,24
 82186d4:	e13ffe15 	stw	r4,-8(fp)
 82186d8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82186dc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82186e0:	e0bffe17 	ldw	r2,-8(fp)
 82186e4:	1000021e 	bne	r2,zero,82186f0 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 82186e8:	00801804 	movi	r2,96
 82186ec:	00002806 	br	8218790 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 82186f0:	e0bfff17 	ldw	r2,-4(fp)
 82186f4:	1000021e 	bne	r2,zero,8218700 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 82186f8:	008017c4 	movi	r2,95
 82186fc:	00002406 	br	8218790 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218700:	0005303a 	rdctl	r2,status
 8218704:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218708:	e0fffd17 	ldw	r3,-12(fp)
 821870c:	00bfff84 	movi	r2,-2
 8218710:	1884703a 	and	r2,r3,r2
 8218714:	1001703a 	wrctl	status,r2
  
  return context;
 8218718:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821871c:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 8218720:	e0bffe17 	ldw	r2,-8(fp)
 8218724:	10c00417 	ldw	r3,16(r2)
 8218728:	e0bffe17 	ldw	r2,-8(fp)
 821872c:	10800317 	ldw	r2,12(r2)
 8218730:	18800636 	bltu	r3,r2,821874c <OSMemPut+0x84>
 8218734:	e0bffa17 	ldw	r2,-24(fp)
 8218738:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821873c:	e0bffb17 	ldw	r2,-20(fp)
 8218740:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 8218744:	00801784 	movi	r2,94
 8218748:	00001106 	br	8218790 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 821874c:	e0bffe17 	ldw	r2,-8(fp)
 8218750:	10c00117 	ldw	r3,4(r2)
 8218754:	e0bfff17 	ldw	r2,-4(fp)
 8218758:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 821875c:	e0bffe17 	ldw	r2,-8(fp)
 8218760:	e0ffff17 	ldw	r3,-4(fp)
 8218764:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 8218768:	e0bffe17 	ldw	r2,-8(fp)
 821876c:	10800417 	ldw	r2,16(r2)
 8218770:	10c00044 	addi	r3,r2,1
 8218774:	e0bffe17 	ldw	r2,-8(fp)
 8218778:	10c00415 	stw	r3,16(r2)
 821877c:	e0bffa17 	ldw	r2,-24(fp)
 8218780:	e0bffc15 	stw	r2,-16(fp)
 8218784:	e0bffc17 	ldw	r2,-16(fp)
 8218788:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 821878c:	0005883a 	mov	r2,zero
}
 8218790:	e037883a 	mov	sp,fp
 8218794:	df000017 	ldw	fp,0(sp)
 8218798:	dec00104 	addi	sp,sp,4
 821879c:	f800283a 	ret

082187a0 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 82187a0:	defffa04 	addi	sp,sp,-24
 82187a4:	df000515 	stw	fp,20(sp)
 82187a8:	df000504 	addi	fp,sp,20
 82187ac:	e13ffe15 	stw	r4,-8(fp)
 82187b0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82187b4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82187b8:	e0bffe17 	ldw	r2,-8(fp)
 82187bc:	1000021e 	bne	r2,zero,82187c8 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 82187c0:	00801804 	movi	r2,96
 82187c4:	00002c06 	br	8218878 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 82187c8:	e0bfff17 	ldw	r2,-4(fp)
 82187cc:	1000021e 	bne	r2,zero,82187d8 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 82187d0:	00801844 	movi	r2,97
 82187d4:	00002806 	br	8218878 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82187d8:	0005303a 	rdctl	r2,status
 82187dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82187e0:	e0fffc17 	ldw	r3,-16(fp)
 82187e4:	00bfff84 	movi	r2,-2
 82187e8:	1884703a 	and	r2,r3,r2
 82187ec:	1001703a 	wrctl	status,r2
  
  return context;
 82187f0:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82187f4:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 82187f8:	e0bffe17 	ldw	r2,-8(fp)
 82187fc:	10c00017 	ldw	r3,0(r2)
 8218800:	e0bfff17 	ldw	r2,-4(fp)
 8218804:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 8218808:	e0bffe17 	ldw	r2,-8(fp)
 821880c:	10c00117 	ldw	r3,4(r2)
 8218810:	e0bfff17 	ldw	r2,-4(fp)
 8218814:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 8218818:	e0bffe17 	ldw	r2,-8(fp)
 821881c:	10c00217 	ldw	r3,8(r2)
 8218820:	e0bfff17 	ldw	r2,-4(fp)
 8218824:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 8218828:	e0bffe17 	ldw	r2,-8(fp)
 821882c:	10c00317 	ldw	r3,12(r2)
 8218830:	e0bfff17 	ldw	r2,-4(fp)
 8218834:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 8218838:	e0bffe17 	ldw	r2,-8(fp)
 821883c:	10c00417 	ldw	r3,16(r2)
 8218840:	e0bfff17 	ldw	r2,-4(fp)
 8218844:	10c00415 	stw	r3,16(r2)
 8218848:	e0bffb17 	ldw	r2,-20(fp)
 821884c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218850:	e0bffd17 	ldw	r2,-12(fp)
 8218854:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 8218858:	e0bfff17 	ldw	r2,-4(fp)
 821885c:	10c00317 	ldw	r3,12(r2)
 8218860:	e0bfff17 	ldw	r2,-4(fp)
 8218864:	10800417 	ldw	r2,16(r2)
 8218868:	1887c83a 	sub	r3,r3,r2
 821886c:	e0bfff17 	ldw	r2,-4(fp)
 8218870:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 8218874:	0005883a 	mov	r2,zero
}
 8218878:	e037883a 	mov	sp,fp
 821887c:	df000017 	ldw	fp,0(sp)
 8218880:	dec00104 	addi	sp,sp,4
 8218884:	f800283a 	ret

08218888 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 8218888:	defffc04 	addi	sp,sp,-16
 821888c:	dfc00315 	stw	ra,12(sp)
 8218890:	df000215 	stw	fp,8(sp)
 8218894:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 8218898:	01430c04 	movi	r5,3120
 821889c:	010209b4 	movhi	r4,2086
 82188a0:	212a3004 	addi	r4,r4,-22336
 82188a4:	82161b40 	call	82161b4 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 82188a8:	008209b4 	movhi	r2,2086
 82188ac:	10aa3004 	addi	r2,r2,-22336
 82188b0:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 82188b4:	e03fff0d 	sth	zero,-4(fp)
 82188b8:	00001306 	br	8218908 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 82188bc:	e0bfff0b 	ldhu	r2,-4(fp)
 82188c0:	10800044 	addi	r2,r2,1
 82188c4:	10c00d24 	muli	r3,r2,52
 82188c8:	008209b4 	movhi	r2,2086
 82188cc:	10aa3004 	addi	r2,r2,-22336
 82188d0:	1887883a 	add	r3,r3,r2
 82188d4:	e0bffe17 	ldw	r2,-8(fp)
 82188d8:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 82188dc:	e0bffe17 	ldw	r2,-8(fp)
 82188e0:	00c00fc4 	movi	r3,63
 82188e4:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 82188e8:	e0bffe17 	ldw	r2,-8(fp)
 82188ec:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 82188f0:	e0bffe17 	ldw	r2,-8(fp)
 82188f4:	10800d04 	addi	r2,r2,52
 82188f8:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 82188fc:	e0bfff0b 	ldhu	r2,-4(fp)
 8218900:	10800044 	addi	r2,r2,1
 8218904:	e0bfff0d 	sth	r2,-4(fp)
 8218908:	e0bfff0b 	ldhu	r2,-4(fp)
 821890c:	10800ef0 	cmpltui	r2,r2,59
 8218910:	103fea1e 	bne	r2,zero,82188bc <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 8218914:	e0bffe17 	ldw	r2,-8(fp)
 8218918:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 821891c:	e0bffe17 	ldw	r2,-8(fp)
 8218920:	00c00fc4 	movi	r3,63
 8218924:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218928:	e0bffe17 	ldw	r2,-8(fp)
 821892c:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 8218930:	008209b4 	movhi	r2,2086
 8218934:	10aa3004 	addi	r2,r2,-22336
 8218938:	d0a07415 	stw	r2,-32304(gp)
#endif
}
 821893c:	0001883a 	nop
 8218940:	e037883a 	mov	sp,fp
 8218944:	dfc00117 	ldw	ra,4(sp)
 8218948:	df000017 	ldw	fp,0(sp)
 821894c:	dec00204 	addi	sp,sp,8
 8218950:	f800283a 	ret

08218954 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 8218954:	defff804 	addi	sp,sp,-32
 8218958:	df000715 	stw	fp,28(sp)
 821895c:	df000704 	addi	fp,sp,28
 8218960:	e13ffe15 	stw	r4,-8(fp)
 8218964:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218968:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 821896c:	e0bfff17 	ldw	r2,-4(fp)
 8218970:	1000021e 	bne	r2,zero,821897c <OSQAccept+0x28>
        return ((void *)0);
 8218974:	0005883a 	mov	r2,zero
 8218978:	00004206 	br	8218a84 <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 821897c:	e0bffe17 	ldw	r2,-8(fp)
 8218980:	1000051e 	bne	r2,zero,8218998 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 8218984:	e0bfff17 	ldw	r2,-4(fp)
 8218988:	00c00104 	movi	r3,4
 821898c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218990:	0005883a 	mov	r2,zero
 8218994:	00003b06 	br	8218a84 <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218998:	e0bffe17 	ldw	r2,-8(fp)
 821899c:	10800003 	ldbu	r2,0(r2)
 82189a0:	10803fcc 	andi	r2,r2,255
 82189a4:	108000a0 	cmpeqi	r2,r2,2
 82189a8:	1000051e 	bne	r2,zero,82189c0 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 82189ac:	e0bfff17 	ldw	r2,-4(fp)
 82189b0:	00c00044 	movi	r3,1
 82189b4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82189b8:	0005883a 	mov	r2,zero
 82189bc:	00003106 	br	8218a84 <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82189c0:	0005303a 	rdctl	r2,status
 82189c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82189c8:	e0fffd17 	ldw	r3,-12(fp)
 82189cc:	00bfff84 	movi	r2,-2
 82189d0:	1884703a 	and	r2,r3,r2
 82189d4:	1001703a 	wrctl	status,r2
  
  return context;
 82189d8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82189dc:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 82189e0:	e0bffe17 	ldw	r2,-8(fp)
 82189e4:	10800117 	ldw	r2,4(r2)
 82189e8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 82189ec:	e0bffc17 	ldw	r2,-16(fp)
 82189f0:	1080058b 	ldhu	r2,22(r2)
 82189f4:	10bfffcc 	andi	r2,r2,65535
 82189f8:	10001926 	beq	r2,zero,8218a60 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 82189fc:	e0bffc17 	ldw	r2,-16(fp)
 8218a00:	10800417 	ldw	r2,16(r2)
 8218a04:	11000104 	addi	r4,r2,4
 8218a08:	e0fffc17 	ldw	r3,-16(fp)
 8218a0c:	19000415 	stw	r4,16(r3)
 8218a10:	10800017 	ldw	r2,0(r2)
 8218a14:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8218a18:	e0bffc17 	ldw	r2,-16(fp)
 8218a1c:	1080058b 	ldhu	r2,22(r2)
 8218a20:	10bfffc4 	addi	r2,r2,-1
 8218a24:	1007883a 	mov	r3,r2
 8218a28:	e0bffc17 	ldw	r2,-16(fp)
 8218a2c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8218a30:	e0bffc17 	ldw	r2,-16(fp)
 8218a34:	10c00417 	ldw	r3,16(r2)
 8218a38:	e0bffc17 	ldw	r2,-16(fp)
 8218a3c:	10800217 	ldw	r2,8(r2)
 8218a40:	1880041e 	bne	r3,r2,8218a54 <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 8218a44:	e0bffc17 	ldw	r2,-16(fp)
 8218a48:	10c00117 	ldw	r3,4(r2)
 8218a4c:	e0bffc17 	ldw	r2,-16(fp)
 8218a50:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 8218a54:	e0bfff17 	ldw	r2,-4(fp)
 8218a58:	10000005 	stb	zero,0(r2)
 8218a5c:	00000406 	br	8218a70 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 8218a60:	e0bfff17 	ldw	r2,-4(fp)
 8218a64:	00c007c4 	movi	r3,31
 8218a68:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 8218a6c:	e03ff915 	stw	zero,-28(fp)
 8218a70:	e0bffa17 	ldw	r2,-24(fp)
 8218a74:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218a78:	e0bffb17 	ldw	r2,-20(fp)
 8218a7c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 8218a80:	e0bff917 	ldw	r2,-28(fp)
}
 8218a84:	e037883a 	mov	sp,fp
 8218a88:	df000017 	ldw	fp,0(sp)
 8218a8c:	dec00104 	addi	sp,sp,4
 8218a90:	f800283a 	ret

08218a94 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 8218a94:	defff404 	addi	sp,sp,-48
 8218a98:	dfc00b15 	stw	ra,44(sp)
 8218a9c:	df000a15 	stw	fp,40(sp)
 8218aa0:	df000a04 	addi	fp,sp,40
 8218aa4:	e13ffe15 	stw	r4,-8(fp)
 8218aa8:	2805883a 	mov	r2,r5
 8218aac:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218ab0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8218ab4:	d0a07903 	ldbu	r2,-32284(gp)
 8218ab8:	10803fcc 	andi	r2,r2,255
 8218abc:	10000226 	beq	r2,zero,8218ac8 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 8218ac0:	0005883a 	mov	r2,zero
 8218ac4:	00005906 	br	8218c2c <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218ac8:	0005303a 	rdctl	r2,status
 8218acc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218ad0:	e0fffd17 	ldw	r3,-12(fp)
 8218ad4:	00bfff84 	movi	r2,-2
 8218ad8:	1884703a 	and	r2,r3,r2
 8218adc:	1001703a 	wrctl	status,r2
  
  return context;
 8218ae0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218ae4:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 8218ae8:	d0a07817 	ldw	r2,-32288(gp)
 8218aec:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 8218af0:	d0a07817 	ldw	r2,-32288(gp)
 8218af4:	10000326 	beq	r2,zero,8218b04 <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8218af8:	d0a07817 	ldw	r2,-32288(gp)
 8218afc:	10800117 	ldw	r2,4(r2)
 8218b00:	d0a07815 	stw	r2,-32288(gp)
 8218b04:	e0bff717 	ldw	r2,-36(fp)
 8218b08:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218b0c:	e0bff817 	ldw	r2,-32(fp)
 8218b10:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 8218b14:	e0bff617 	ldw	r2,-40(fp)
 8218b18:	10004326 	beq	r2,zero,8218c28 <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218b1c:	0005303a 	rdctl	r2,status
 8218b20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218b24:	e0fff917 	ldw	r3,-28(fp)
 8218b28:	00bfff84 	movi	r2,-2
 8218b2c:	1884703a 	and	r2,r3,r2
 8218b30:	1001703a 	wrctl	status,r2
  
  return context;
 8218b34:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
 8218b38:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 8218b3c:	d0a07617 	ldw	r2,-32296(gp)
 8218b40:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 8218b44:	e0bffb17 	ldw	r2,-20(fp)
 8218b48:	10002d26 	beq	r2,zero,8218c00 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 8218b4c:	d0a07617 	ldw	r2,-32296(gp)
 8218b50:	10800017 	ldw	r2,0(r2)
 8218b54:	d0a07615 	stw	r2,-32296(gp)
 8218b58:	e0bff717 	ldw	r2,-36(fp)
 8218b5c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218b60:	e0bffa17 	ldw	r2,-24(fp)
 8218b64:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 8218b68:	e0bffb17 	ldw	r2,-20(fp)
 8218b6c:	e0fffe17 	ldw	r3,-8(fp)
 8218b70:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 8218b74:	e0bfff0b 	ldhu	r2,-4(fp)
 8218b78:	1085883a 	add	r2,r2,r2
 8218b7c:	1085883a 	add	r2,r2,r2
 8218b80:	1007883a 	mov	r3,r2
 8218b84:	e0bffe17 	ldw	r2,-8(fp)
 8218b88:	10c7883a 	add	r3,r2,r3
 8218b8c:	e0bffb17 	ldw	r2,-20(fp)
 8218b90:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 8218b94:	e0bffb17 	ldw	r2,-20(fp)
 8218b98:	e0fffe17 	ldw	r3,-8(fp)
 8218b9c:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 8218ba0:	e0bffb17 	ldw	r2,-20(fp)
 8218ba4:	e0fffe17 	ldw	r3,-8(fp)
 8218ba8:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 8218bac:	e0bffb17 	ldw	r2,-20(fp)
 8218bb0:	e0ffff0b 	ldhu	r3,-4(fp)
 8218bb4:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 8218bb8:	e0bffb17 	ldw	r2,-20(fp)
 8218bbc:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 8218bc0:	e0bff617 	ldw	r2,-40(fp)
 8218bc4:	00c00084 	movi	r3,2
 8218bc8:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 8218bcc:	e0bff617 	ldw	r2,-40(fp)
 8218bd0:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 8218bd4:	e0bff617 	ldw	r2,-40(fp)
 8218bd8:	e0fffb17 	ldw	r3,-20(fp)
 8218bdc:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 8218be0:	e0bff617 	ldw	r2,-40(fp)
 8218be4:	00c00fc4 	movi	r3,63
 8218be8:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 8218bec:	e0bff617 	ldw	r2,-40(fp)
 8218bf0:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 8218bf4:	e13ff617 	ldw	r4,-40(fp)
 8218bf8:	8215dd40 	call	8215dd4 <OS_EventWaitListInit>
 8218bfc:	00000a06 	br	8218c28 <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 8218c00:	d0e07817 	ldw	r3,-32288(gp)
 8218c04:	e0bff617 	ldw	r2,-40(fp)
 8218c08:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 8218c0c:	e0bff617 	ldw	r2,-40(fp)
 8218c10:	d0a07815 	stw	r2,-32288(gp)
 8218c14:	e0bff717 	ldw	r2,-36(fp)
 8218c18:	e0bffc15 	stw	r2,-16(fp)
 8218c1c:	e0bffc17 	ldw	r2,-16(fp)
 8218c20:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 8218c24:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 8218c28:	e0bff617 	ldw	r2,-40(fp)
}
 8218c2c:	e037883a 	mov	sp,fp
 8218c30:	dfc00117 	ldw	ra,4(sp)
 8218c34:	df000017 	ldw	fp,0(sp)
 8218c38:	dec00204 	addi	sp,sp,8
 8218c3c:	f800283a 	ret

08218c40 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8218c40:	defff204 	addi	sp,sp,-56
 8218c44:	dfc00d15 	stw	ra,52(sp)
 8218c48:	df000c15 	stw	fp,48(sp)
 8218c4c:	df000c04 	addi	fp,sp,48
 8218c50:	e13ffd15 	stw	r4,-12(fp)
 8218c54:	2805883a 	mov	r2,r5
 8218c58:	e1bfff15 	stw	r6,-4(fp)
 8218c5c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8218c60:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8218c64:	e0bfff17 	ldw	r2,-4(fp)
 8218c68:	1000021e 	bne	r2,zero,8218c74 <OSQDel+0x34>
        return (pevent);
 8218c6c:	e0bffd17 	ldw	r2,-12(fp)
 8218c70:	00008e06 	br	8218eac <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8218c74:	e0bffd17 	ldw	r2,-12(fp)
 8218c78:	1000051e 	bne	r2,zero,8218c90 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218c7c:	e0bfff17 	ldw	r2,-4(fp)
 8218c80:	00c00104 	movi	r3,4
 8218c84:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218c88:	e0bffd17 	ldw	r2,-12(fp)
 8218c8c:	00008706 	br	8218eac <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8218c90:	e0bffd17 	ldw	r2,-12(fp)
 8218c94:	10800003 	ldbu	r2,0(r2)
 8218c98:	10803fcc 	andi	r2,r2,255
 8218c9c:	108000a0 	cmpeqi	r2,r2,2
 8218ca0:	1000051e 	bne	r2,zero,8218cb8 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218ca4:	e0bfff17 	ldw	r2,-4(fp)
 8218ca8:	00c00044 	movi	r3,1
 8218cac:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218cb0:	e0bffd17 	ldw	r2,-12(fp)
 8218cb4:	00007d06 	br	8218eac <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8218cb8:	d0a07903 	ldbu	r2,-32284(gp)
 8218cbc:	10803fcc 	andi	r2,r2,255
 8218cc0:	10000526 	beq	r2,zero,8218cd8 <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8218cc4:	e0bfff17 	ldw	r2,-4(fp)
 8218cc8:	00c003c4 	movi	r3,15
 8218ccc:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218cd0:	e0bffd17 	ldw	r2,-12(fp)
 8218cd4:	00007506 	br	8218eac <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218cd8:	0005303a 	rdctl	r2,status
 8218cdc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218ce0:	e0fffc17 	ldw	r3,-16(fp)
 8218ce4:	00bfff84 	movi	r2,-2
 8218ce8:	1884703a 	and	r2,r3,r2
 8218cec:	1001703a 	wrctl	status,r2
  
  return context;
 8218cf0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218cf4:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 8218cf8:	e0bffd17 	ldw	r2,-12(fp)
 8218cfc:	10800283 	ldbu	r2,10(r2)
 8218d00:	10803fcc 	andi	r2,r2,255
 8218d04:	10000326 	beq	r2,zero,8218d14 <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8218d08:	00800044 	movi	r2,1
 8218d0c:	e0bff405 	stb	r2,-48(fp)
 8218d10:	00000106 	br	8218d18 <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8218d14:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8218d18:	e0bffe03 	ldbu	r2,-8(fp)
 8218d1c:	10000326 	beq	r2,zero,8218d2c <OSQDel+0xec>
 8218d20:	10800060 	cmpeqi	r2,r2,1
 8218d24:	1000301e 	bne	r2,zero,8218de8 <OSQDel+0x1a8>
 8218d28:	00005506 	br	8218e80 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 8218d2c:	e0bff403 	ldbu	r2,-48(fp)
 8218d30:	10001e1e 	bne	r2,zero,8218dac <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8218d34:	e0bffd17 	ldw	r2,-12(fp)
 8218d38:	00c00fc4 	movi	r3,63
 8218d3c:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8218d40:	e0bffd17 	ldw	r2,-12(fp)
 8218d44:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 8218d48:	e0bffd17 	ldw	r2,-12(fp)
 8218d4c:	10800117 	ldw	r2,4(r2)
 8218d50:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 8218d54:	d0e07617 	ldw	r3,-32296(gp)
 8218d58:	e0bff817 	ldw	r2,-32(fp)
 8218d5c:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 8218d60:	e0bff817 	ldw	r2,-32(fp)
 8218d64:	d0a07615 	stw	r2,-32296(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8218d68:	e0bffd17 	ldw	r2,-12(fp)
 8218d6c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8218d70:	d0e07817 	ldw	r3,-32288(gp)
 8218d74:	e0bffd17 	ldw	r2,-12(fp)
 8218d78:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8218d7c:	e0bffd17 	ldw	r2,-12(fp)
 8218d80:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8218d84:	e0bffd17 	ldw	r2,-12(fp)
 8218d88:	d0a07815 	stw	r2,-32288(gp)
 8218d8c:	e0bff617 	ldw	r2,-40(fp)
 8218d90:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218d94:	e0bff717 	ldw	r2,-36(fp)
 8218d98:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8218d9c:	e0bfff17 	ldw	r2,-4(fp)
 8218da0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 8218da4:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8218da8:	00003f06 	br	8218ea8 <OSQDel+0x268>
 8218dac:	e0bff617 	ldw	r2,-40(fp)
 8218db0:	e0bff915 	stw	r2,-28(fp)
 8218db4:	e0bff917 	ldw	r2,-28(fp)
 8218db8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8218dbc:	e0bfff17 	ldw	r2,-4(fp)
 8218dc0:	00c01244 	movi	r3,73
 8218dc4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8218dc8:	e0bffd17 	ldw	r2,-12(fp)
 8218dcc:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 8218dd0:	00003506 	br	8218ea8 <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 8218dd4:	000f883a 	mov	r7,zero
 8218dd8:	01800104 	movi	r6,4
 8218ddc:	000b883a 	mov	r5,zero
 8218de0:	e13ffd17 	ldw	r4,-12(fp)
 8218de4:	82158240 	call	8215824 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 8218de8:	e0bffd17 	ldw	r2,-12(fp)
 8218dec:	10800283 	ldbu	r2,10(r2)
 8218df0:	10803fcc 	andi	r2,r2,255
 8218df4:	103ff71e 	bne	r2,zero,8218dd4 <OSQDel+0x194>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8218df8:	e0bffd17 	ldw	r2,-12(fp)
 8218dfc:	00c00fc4 	movi	r3,63
 8218e00:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 8218e04:	e0bffd17 	ldw	r2,-12(fp)
 8218e08:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 8218e0c:	e0bffd17 	ldw	r2,-12(fp)
 8218e10:	10800117 	ldw	r2,4(r2)
 8218e14:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 8218e18:	d0e07617 	ldw	r3,-32296(gp)
 8218e1c:	e0bff817 	ldw	r2,-32(fp)
 8218e20:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 8218e24:	e0bff817 	ldw	r2,-32(fp)
 8218e28:	d0a07615 	stw	r2,-32296(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8218e2c:	e0bffd17 	ldw	r2,-12(fp)
 8218e30:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 8218e34:	d0e07817 	ldw	r3,-32288(gp)
 8218e38:	e0bffd17 	ldw	r2,-12(fp)
 8218e3c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8218e40:	e0bffd17 	ldw	r2,-12(fp)
 8218e44:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8218e48:	e0bffd17 	ldw	r2,-12(fp)
 8218e4c:	d0a07815 	stw	r2,-32288(gp)
 8218e50:	e0bff617 	ldw	r2,-40(fp)
 8218e54:	e0bffa15 	stw	r2,-24(fp)
 8218e58:	e0bffa17 	ldw	r2,-24(fp)
 8218e5c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8218e60:	e0bff403 	ldbu	r2,-48(fp)
 8218e64:	10800058 	cmpnei	r2,r2,1
 8218e68:	1000011e 	bne	r2,zero,8218e70 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8218e6c:	82162700 	call	8216270 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8218e70:	e0bfff17 	ldw	r2,-4(fp)
 8218e74:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 8218e78:	e03ff515 	stw	zero,-44(fp)
             break;
 8218e7c:	00000a06 	br	8218ea8 <OSQDel+0x268>
 8218e80:	e0bff617 	ldw	r2,-40(fp)
 8218e84:	e0bffb15 	stw	r2,-20(fp)
 8218e88:	e0bffb17 	ldw	r2,-20(fp)
 8218e8c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 8218e90:	e0bfff17 	ldw	r2,-4(fp)
 8218e94:	00c001c4 	movi	r3,7
 8218e98:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 8218e9c:	e0bffd17 	ldw	r2,-12(fp)
 8218ea0:	e0bff515 	stw	r2,-44(fp)
             break;
 8218ea4:	0001883a 	nop
    }
    return (pevent_return);
 8218ea8:	e0bff517 	ldw	r2,-44(fp)
}
 8218eac:	e037883a 	mov	sp,fp
 8218eb0:	dfc00117 	ldw	ra,4(sp)
 8218eb4:	df000017 	ldw	fp,0(sp)
 8218eb8:	dec00204 	addi	sp,sp,8
 8218ebc:	f800283a 	ret

08218ec0 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 8218ec0:	defffa04 	addi	sp,sp,-24
 8218ec4:	df000515 	stw	fp,20(sp)
 8218ec8:	df000504 	addi	fp,sp,20
 8218ecc:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8218ed0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8218ed4:	e0bfff17 	ldw	r2,-4(fp)
 8218ed8:	1000021e 	bne	r2,zero,8218ee4 <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 8218edc:	00800104 	movi	r2,4
 8218ee0:	00002106 	br	8218f68 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8218ee4:	e0bfff17 	ldw	r2,-4(fp)
 8218ee8:	10800003 	ldbu	r2,0(r2)
 8218eec:	10803fcc 	andi	r2,r2,255
 8218ef0:	108000a0 	cmpeqi	r2,r2,2
 8218ef4:	1000021e 	bne	r2,zero,8218f00 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 8218ef8:	00800044 	movi	r2,1
 8218efc:	00001a06 	br	8218f68 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218f00:	0005303a 	rdctl	r2,status
 8218f04:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218f08:	e0fffd17 	ldw	r3,-12(fp)
 8218f0c:	00bfff84 	movi	r2,-2
 8218f10:	1884703a 	and	r2,r3,r2
 8218f14:	1001703a 	wrctl	status,r2
  
  return context;
 8218f18:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218f1c:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 8218f20:	e0bfff17 	ldw	r2,-4(fp)
 8218f24:	10800117 	ldw	r2,4(r2)
 8218f28:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 8218f2c:	e0bffc17 	ldw	r2,-16(fp)
 8218f30:	10c00117 	ldw	r3,4(r2)
 8218f34:	e0bffc17 	ldw	r2,-16(fp)
 8218f38:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 8218f3c:	e0bffc17 	ldw	r2,-16(fp)
 8218f40:	10c00117 	ldw	r3,4(r2)
 8218f44:	e0bffc17 	ldw	r2,-16(fp)
 8218f48:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 8218f4c:	e0bffc17 	ldw	r2,-16(fp)
 8218f50:	1000058d 	sth	zero,22(r2)
 8218f54:	e0bffb17 	ldw	r2,-20(fp)
 8218f58:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218f5c:	e0bffe17 	ldw	r2,-8(fp)
 8218f60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8218f64:	0005883a 	mov	r2,zero
}
 8218f68:	e037883a 	mov	sp,fp
 8218f6c:	df000017 	ldw	fp,0(sp)
 8218f70:	dec00104 	addi	sp,sp,4
 8218f74:	f800283a 	ret

08218f78 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 8218f78:	defff304 	addi	sp,sp,-52
 8218f7c:	dfc00c15 	stw	ra,48(sp)
 8218f80:	df000b15 	stw	fp,44(sp)
 8218f84:	df000b04 	addi	fp,sp,44
 8218f88:	e13ffd15 	stw	r4,-12(fp)
 8218f8c:	2805883a 	mov	r2,r5
 8218f90:	e1bfff15 	stw	r6,-4(fp)
 8218f94:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218f98:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218f9c:	e0bfff17 	ldw	r2,-4(fp)
 8218fa0:	1000021e 	bne	r2,zero,8218fac <OSQPend+0x34>
        return ((void *)0);
 8218fa4:	0005883a 	mov	r2,zero
 8218fa8:	00009106 	br	82191f0 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8218fac:	e0bffd17 	ldw	r2,-12(fp)
 8218fb0:	1000051e 	bne	r2,zero,8218fc8 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218fb4:	e0bfff17 	ldw	r2,-4(fp)
 8218fb8:	00c00104 	movi	r3,4
 8218fbc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218fc0:	0005883a 	mov	r2,zero
 8218fc4:	00008a06 	br	82191f0 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218fc8:	e0bffd17 	ldw	r2,-12(fp)
 8218fcc:	10800003 	ldbu	r2,0(r2)
 8218fd0:	10803fcc 	andi	r2,r2,255
 8218fd4:	108000a0 	cmpeqi	r2,r2,2
 8218fd8:	1000051e 	bne	r2,zero,8218ff0 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218fdc:	e0bfff17 	ldw	r2,-4(fp)
 8218fe0:	00c00044 	movi	r3,1
 8218fe4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218fe8:	0005883a 	mov	r2,zero
 8218fec:	00008006 	br	82191f0 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8218ff0:	d0a07903 	ldbu	r2,-32284(gp)
 8218ff4:	10803fcc 	andi	r2,r2,255
 8218ff8:	10000526 	beq	r2,zero,8219010 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 8218ffc:	e0bfff17 	ldw	r2,-4(fp)
 8219000:	00c00084 	movi	r3,2
 8219004:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219008:	0005883a 	mov	r2,zero
 821900c:	00007806 	br	82191f0 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 8219010:	d0a06b03 	ldbu	r2,-32340(gp)
 8219014:	10803fcc 	andi	r2,r2,255
 8219018:	10000526 	beq	r2,zero,8219030 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 821901c:	e0bfff17 	ldw	r2,-4(fp)
 8219020:	00c00344 	movi	r3,13
 8219024:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219028:	0005883a 	mov	r2,zero
 821902c:	00007006 	br	82191f0 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219030:	0005303a 	rdctl	r2,status
 8219034:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219038:	e0fffc17 	ldw	r3,-16(fp)
 821903c:	00bfff84 	movi	r2,-2
 8219040:	1884703a 	and	r2,r3,r2
 8219044:	1001703a 	wrctl	status,r2
  
  return context;
 8219048:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821904c:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8219050:	e0bffd17 	ldw	r2,-12(fp)
 8219054:	10800117 	ldw	r2,4(r2)
 8219058:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 821905c:	e0bff817 	ldw	r2,-32(fp)
 8219060:	1080058b 	ldhu	r2,22(r2)
 8219064:	10bfffcc 	andi	r2,r2,65535
 8219068:	10001e26 	beq	r2,zero,82190e4 <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 821906c:	e0bff817 	ldw	r2,-32(fp)
 8219070:	10800417 	ldw	r2,16(r2)
 8219074:	11000104 	addi	r4,r2,4
 8219078:	e0fff817 	ldw	r3,-32(fp)
 821907c:	19000415 	stw	r4,16(r3)
 8219080:	10800017 	ldw	r2,0(r2)
 8219084:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8219088:	e0bff817 	ldw	r2,-32(fp)
 821908c:	1080058b 	ldhu	r2,22(r2)
 8219090:	10bfffc4 	addi	r2,r2,-1
 8219094:	1007883a 	mov	r3,r2
 8219098:	e0bff817 	ldw	r2,-32(fp)
 821909c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 82190a0:	e0bff817 	ldw	r2,-32(fp)
 82190a4:	10c00417 	ldw	r3,16(r2)
 82190a8:	e0bff817 	ldw	r2,-32(fp)
 82190ac:	10800217 	ldw	r2,8(r2)
 82190b0:	1880041e 	bne	r3,r2,82190c4 <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
 82190b4:	e0bff817 	ldw	r2,-32(fp)
 82190b8:	10c00117 	ldw	r3,4(r2)
 82190bc:	e0bff817 	ldw	r2,-32(fp)
 82190c0:	10c00415 	stw	r3,16(r2)
 82190c4:	e0bff617 	ldw	r2,-40(fp)
 82190c8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82190cc:	e0bff717 	ldw	r2,-36(fp)
 82190d0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 82190d4:	e0bfff17 	ldw	r2,-4(fp)
 82190d8:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 82190dc:	e0bff517 	ldw	r2,-44(fp)
 82190e0:	00004306 	br	82191f0 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 82190e4:	d0a07a17 	ldw	r2,-32280(gp)
 82190e8:	d0e07a17 	ldw	r3,-32280(gp)
 82190ec:	18c00c03 	ldbu	r3,48(r3)
 82190f0:	18c00114 	ori	r3,r3,4
 82190f4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 82190f8:	d0a07a17 	ldw	r2,-32280(gp)
 82190fc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 8219100:	d0a07a17 	ldw	r2,-32280(gp)
 8219104:	e0fffe0b 	ldhu	r3,-8(fp)
 8219108:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 821910c:	e13ffd17 	ldw	r4,-12(fp)
 8219110:	82159bc0 	call	82159bc <OS_EventTaskWait>
 8219114:	e0bff617 	ldw	r2,-40(fp)
 8219118:	e0bffb15 	stw	r2,-20(fp)
 821911c:	e0bffb17 	ldw	r2,-20(fp)
 8219120:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 8219124:	82162700 	call	8216270 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219128:	0005303a 	rdctl	r2,status
 821912c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219130:	e0fff917 	ldw	r3,-28(fp)
 8219134:	00bfff84 	movi	r2,-2
 8219138:	1884703a 	and	r2,r3,r2
 821913c:	1001703a 	wrctl	status,r2
  
  return context;
 8219140:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 8219144:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 8219148:	d0a07a17 	ldw	r2,-32280(gp)
 821914c:	10800c43 	ldbu	r2,49(r2)
 8219150:	10803fcc 	andi	r2,r2,255
 8219154:	10000326 	beq	r2,zero,8219164 <OSQPend+0x1ec>
 8219158:	108000a0 	cmpeqi	r2,r2,2
 821915c:	1000071e 	bne	r2,zero,821917c <OSQPend+0x204>
 8219160:	00000b06 	br	8219190 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 8219164:	d0a07a17 	ldw	r2,-32280(gp)
 8219168:	10800917 	ldw	r2,36(r2)
 821916c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 8219170:	e0bfff17 	ldw	r2,-4(fp)
 8219174:	10000005 	stb	zero,0(r2)
             break;
 8219178:	00000e06 	br	82191b4 <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 821917c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219180:	e0bfff17 	ldw	r2,-4(fp)
 8219184:	00c00384 	movi	r3,14
 8219188:	10c00005 	stb	r3,0(r2)
             break;
 821918c:	00000906 	br	82191b4 <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 8219190:	d0a07a17 	ldw	r2,-32280(gp)
 8219194:	e17ffd17 	ldw	r5,-12(fp)
 8219198:	1009883a 	mov	r4,r2
 821919c:	8215c1c0 	call	8215c1c <OS_EventTaskRemove>
             pmsg = (void *)0;
 82191a0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 82191a4:	e0bfff17 	ldw	r2,-4(fp)
 82191a8:	00c00284 	movi	r3,10
 82191ac:	10c00005 	stb	r3,0(r2)
             break;
 82191b0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 82191b4:	d0a07a17 	ldw	r2,-32280(gp)
 82191b8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 82191bc:	d0a07a17 	ldw	r2,-32280(gp)
 82191c0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 82191c4:	d0a07a17 	ldw	r2,-32280(gp)
 82191c8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 82191cc:	d0a07a17 	ldw	r2,-32280(gp)
 82191d0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 82191d4:	d0a07a17 	ldw	r2,-32280(gp)
 82191d8:	10000915 	stw	zero,36(r2)
 82191dc:	e0bff617 	ldw	r2,-40(fp)
 82191e0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82191e4:	e0bffa17 	ldw	r2,-24(fp)
 82191e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 82191ec:	e0bff517 	ldw	r2,-44(fp)
}
 82191f0:	e037883a 	mov	sp,fp
 82191f4:	dfc00117 	ldw	ra,4(sp)
 82191f8:	df000017 	ldw	fp,0(sp)
 82191fc:	dec00204 	addi	sp,sp,8
 8219200:	f800283a 	ret

08219204 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219204:	defff604 	addi	sp,sp,-40
 8219208:	dfc00915 	stw	ra,36(sp)
 821920c:	df000815 	stw	fp,32(sp)
 8219210:	df000804 	addi	fp,sp,32
 8219214:	e13ffd15 	stw	r4,-12(fp)
 8219218:	2805883a 	mov	r2,r5
 821921c:	e1bfff15 	stw	r6,-4(fp)
 8219220:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219224:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219228:	e0bfff17 	ldw	r2,-4(fp)
 821922c:	1000021e 	bne	r2,zero,8219238 <OSQPendAbort+0x34>
        return (0);
 8219230:	0005883a 	mov	r2,zero
 8219234:	00004906 	br	821935c <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219238:	e0bffd17 	ldw	r2,-12(fp)
 821923c:	1000051e 	bne	r2,zero,8219254 <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219240:	e0bfff17 	ldw	r2,-4(fp)
 8219244:	00c00104 	movi	r3,4
 8219248:	10c00005 	stb	r3,0(r2)
        return (0);
 821924c:	0005883a 	mov	r2,zero
 8219250:	00004206 	br	821935c <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8219254:	e0bffd17 	ldw	r2,-12(fp)
 8219258:	10800003 	ldbu	r2,0(r2)
 821925c:	10803fcc 	andi	r2,r2,255
 8219260:	108000a0 	cmpeqi	r2,r2,2
 8219264:	1000051e 	bne	r2,zero,821927c <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219268:	e0bfff17 	ldw	r2,-4(fp)
 821926c:	00c00044 	movi	r3,1
 8219270:	10c00005 	stb	r3,0(r2)
        return (0);
 8219274:	0005883a 	mov	r2,zero
 8219278:	00003806 	br	821935c <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821927c:	0005303a 	rdctl	r2,status
 8219280:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219284:	e0fffc17 	ldw	r3,-16(fp)
 8219288:	00bfff84 	movi	r2,-2
 821928c:	1884703a 	and	r2,r3,r2
 8219290:	1001703a 	wrctl	status,r2
  
  return context;
 8219294:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219298:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 821929c:	e0bffd17 	ldw	r2,-12(fp)
 82192a0:	10800283 	ldbu	r2,10(r2)
 82192a4:	10803fcc 	andi	r2,r2,255
 82192a8:	10002526 	beq	r2,zero,8219340 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
 82192ac:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 82192b0:	e0bffe03 	ldbu	r2,-8(fp)
 82192b4:	10800060 	cmpeqi	r2,r2,1
 82192b8:	10000e26 	beq	r2,zero,82192f4 <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82192bc:	00000806 	br	82192e0 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82192c0:	01c00084 	movi	r7,2
 82192c4:	01800104 	movi	r6,4
 82192c8:	000b883a 	mov	r5,zero
 82192cc:	e13ffd17 	ldw	r4,-12(fp)
 82192d0:	82158240 	call	8215824 <OS_EventTaskRdy>
                     nbr_tasks++;
 82192d4:	e0bff803 	ldbu	r2,-32(fp)
 82192d8:	10800044 	addi	r2,r2,1
 82192dc:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82192e0:	e0bffd17 	ldw	r2,-12(fp)
 82192e4:	10800283 	ldbu	r2,10(r2)
 82192e8:	10803fcc 	andi	r2,r2,255
 82192ec:	103ff41e 	bne	r2,zero,82192c0 <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 82192f0:	00000906 	br	8219318 <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82192f4:	01c00084 	movi	r7,2
 82192f8:	01800104 	movi	r6,4
 82192fc:	000b883a 	mov	r5,zero
 8219300:	e13ffd17 	ldw	r4,-12(fp)
 8219304:	82158240 	call	8215824 <OS_EventTaskRdy>
                 nbr_tasks++;
 8219308:	e0bff803 	ldbu	r2,-32(fp)
 821930c:	10800044 	addi	r2,r2,1
 8219310:	e0bff805 	stb	r2,-32(fp)
                 break;
 8219314:	0001883a 	nop
 8219318:	e0bff917 	ldw	r2,-28(fp)
 821931c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219320:	e0bffa17 	ldw	r2,-24(fp)
 8219324:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 8219328:	82162700 	call	8216270 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821932c:	e0bfff17 	ldw	r2,-4(fp)
 8219330:	00c00384 	movi	r3,14
 8219334:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 8219338:	e0bff803 	ldbu	r2,-32(fp)
 821933c:	00000706 	br	821935c <OSQPendAbort+0x158>
 8219340:	e0bff917 	ldw	r2,-28(fp)
 8219344:	e0bffb15 	stw	r2,-20(fp)
 8219348:	e0bffb17 	ldw	r2,-20(fp)
 821934c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8219350:	e0bfff17 	ldw	r2,-4(fp)
 8219354:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 8219358:	0005883a 	mov	r2,zero
}
 821935c:	e037883a 	mov	sp,fp
 8219360:	dfc00117 	ldw	ra,4(sp)
 8219364:	df000017 	ldw	fp,0(sp)
 8219368:	dec00204 	addi	sp,sp,8
 821936c:	f800283a 	ret

08219370 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 8219370:	defff604 	addi	sp,sp,-40
 8219374:	dfc00915 	stw	ra,36(sp)
 8219378:	df000815 	stw	fp,32(sp)
 821937c:	df000804 	addi	fp,sp,32
 8219380:	e13ffe15 	stw	r4,-8(fp)
 8219384:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219388:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 821938c:	e0bffe17 	ldw	r2,-8(fp)
 8219390:	1000021e 	bne	r2,zero,821939c <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 8219394:	00800104 	movi	r2,4
 8219398:	00004a06 	br	82194c4 <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 821939c:	e0bffe17 	ldw	r2,-8(fp)
 82193a0:	10800003 	ldbu	r2,0(r2)
 82193a4:	10803fcc 	andi	r2,r2,255
 82193a8:	108000a0 	cmpeqi	r2,r2,2
 82193ac:	1000021e 	bne	r2,zero,82193b8 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 82193b0:	00800044 	movi	r2,1
 82193b4:	00004306 	br	82194c4 <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82193b8:	0005303a 	rdctl	r2,status
 82193bc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82193c0:	e0fffd17 	ldw	r3,-12(fp)
 82193c4:	00bfff84 	movi	r2,-2
 82193c8:	1884703a 	and	r2,r3,r2
 82193cc:	1001703a 	wrctl	status,r2
  
  return context;
 82193d0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82193d4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 82193d8:	e0bffe17 	ldw	r2,-8(fp)
 82193dc:	10800283 	ldbu	r2,10(r2)
 82193e0:	10803fcc 	andi	r2,r2,255
 82193e4:	10000c26 	beq	r2,zero,8219418 <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82193e8:	000f883a 	mov	r7,zero
 82193ec:	01800104 	movi	r6,4
 82193f0:	e17fff17 	ldw	r5,-4(fp)
 82193f4:	e13ffe17 	ldw	r4,-8(fp)
 82193f8:	82158240 	call	8215824 <OS_EventTaskRdy>
 82193fc:	e0bff817 	ldw	r2,-32(fp)
 8219400:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219404:	e0bff917 	ldw	r2,-28(fp)
 8219408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 821940c:	82162700 	call	8216270 <OS_Sched>
        return (OS_ERR_NONE);
 8219410:	0005883a 	mov	r2,zero
 8219414:	00002b06 	br	82194c4 <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 8219418:	e0bffe17 	ldw	r2,-8(fp)
 821941c:	10800117 	ldw	r2,4(r2)
 8219420:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 8219424:	e0bffb17 	ldw	r2,-20(fp)
 8219428:	10c0058b 	ldhu	r3,22(r2)
 821942c:	e0bffb17 	ldw	r2,-20(fp)
 8219430:	1080050b 	ldhu	r2,20(r2)
 8219434:	18ffffcc 	andi	r3,r3,65535
 8219438:	10bfffcc 	andi	r2,r2,65535
 821943c:	18800636 	bltu	r3,r2,8219458 <OSQPost+0xe8>
 8219440:	e0bff817 	ldw	r2,-32(fp)
 8219444:	e0bffa15 	stw	r2,-24(fp)
 8219448:	e0bffa17 	ldw	r2,-24(fp)
 821944c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219450:	00800784 	movi	r2,30
 8219454:	00001b06 	br	82194c4 <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 8219458:	e0bffb17 	ldw	r2,-20(fp)
 821945c:	10800317 	ldw	r2,12(r2)
 8219460:	11000104 	addi	r4,r2,4
 8219464:	e0fffb17 	ldw	r3,-20(fp)
 8219468:	19000315 	stw	r4,12(r3)
 821946c:	e0ffff17 	ldw	r3,-4(fp)
 8219470:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 8219474:	e0bffb17 	ldw	r2,-20(fp)
 8219478:	1080058b 	ldhu	r2,22(r2)
 821947c:	10800044 	addi	r2,r2,1
 8219480:	1007883a 	mov	r3,r2
 8219484:	e0bffb17 	ldw	r2,-20(fp)
 8219488:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 821948c:	e0bffb17 	ldw	r2,-20(fp)
 8219490:	10c00317 	ldw	r3,12(r2)
 8219494:	e0bffb17 	ldw	r2,-20(fp)
 8219498:	10800217 	ldw	r2,8(r2)
 821949c:	1880041e 	bne	r3,r2,82194b0 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 82194a0:	e0bffb17 	ldw	r2,-20(fp)
 82194a4:	10c00117 	ldw	r3,4(r2)
 82194a8:	e0bffb17 	ldw	r2,-20(fp)
 82194ac:	10c00315 	stw	r3,12(r2)
 82194b0:	e0bff817 	ldw	r2,-32(fp)
 82194b4:	e0bffc15 	stw	r2,-16(fp)
 82194b8:	e0bffc17 	ldw	r2,-16(fp)
 82194bc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 82194c0:	0005883a 	mov	r2,zero
}
 82194c4:	e037883a 	mov	sp,fp
 82194c8:	dfc00117 	ldw	ra,4(sp)
 82194cc:	df000017 	ldw	fp,0(sp)
 82194d0:	dec00204 	addi	sp,sp,8
 82194d4:	f800283a 	ret

082194d8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 82194d8:	defff604 	addi	sp,sp,-40
 82194dc:	dfc00915 	stw	ra,36(sp)
 82194e0:	df000815 	stw	fp,32(sp)
 82194e4:	df000804 	addi	fp,sp,32
 82194e8:	e13ffe15 	stw	r4,-8(fp)
 82194ec:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82194f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 82194f4:	e0bffe17 	ldw	r2,-8(fp)
 82194f8:	1000021e 	bne	r2,zero,8219504 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 82194fc:	00800104 	movi	r2,4
 8219500:	00004c06 	br	8219634 <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8219504:	e0bffe17 	ldw	r2,-8(fp)
 8219508:	10800003 	ldbu	r2,0(r2)
 821950c:	10803fcc 	andi	r2,r2,255
 8219510:	108000a0 	cmpeqi	r2,r2,2
 8219514:	1000021e 	bne	r2,zero,8219520 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 8219518:	00800044 	movi	r2,1
 821951c:	00004506 	br	8219634 <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219520:	0005303a 	rdctl	r2,status
 8219524:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219528:	e0fffd17 	ldw	r3,-12(fp)
 821952c:	00bfff84 	movi	r2,-2
 8219530:	1884703a 	and	r2,r3,r2
 8219534:	1001703a 	wrctl	status,r2
  
  return context;
 8219538:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821953c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 8219540:	e0bffe17 	ldw	r2,-8(fp)
 8219544:	10800283 	ldbu	r2,10(r2)
 8219548:	10803fcc 	andi	r2,r2,255
 821954c:	10000c26 	beq	r2,zero,8219580 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219550:	000f883a 	mov	r7,zero
 8219554:	01800104 	movi	r6,4
 8219558:	e17fff17 	ldw	r5,-4(fp)
 821955c:	e13ffe17 	ldw	r4,-8(fp)
 8219560:	82158240 	call	8215824 <OS_EventTaskRdy>
 8219564:	e0bff817 	ldw	r2,-32(fp)
 8219568:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821956c:	e0bff917 	ldw	r2,-28(fp)
 8219570:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 8219574:	82162700 	call	8216270 <OS_Sched>
        return (OS_ERR_NONE);
 8219578:	0005883a 	mov	r2,zero
 821957c:	00002d06 	br	8219634 <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219580:	e0bffe17 	ldw	r2,-8(fp)
 8219584:	10800117 	ldw	r2,4(r2)
 8219588:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 821958c:	e0bffb17 	ldw	r2,-20(fp)
 8219590:	10c0058b 	ldhu	r3,22(r2)
 8219594:	e0bffb17 	ldw	r2,-20(fp)
 8219598:	1080050b 	ldhu	r2,20(r2)
 821959c:	18ffffcc 	andi	r3,r3,65535
 82195a0:	10bfffcc 	andi	r2,r2,65535
 82195a4:	18800636 	bltu	r3,r2,82195c0 <OSQPostFront+0xe8>
 82195a8:	e0bff817 	ldw	r2,-32(fp)
 82195ac:	e0bffa15 	stw	r2,-24(fp)
 82195b0:	e0bffa17 	ldw	r2,-24(fp)
 82195b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 82195b8:	00800784 	movi	r2,30
 82195bc:	00001d06 	br	8219634 <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 82195c0:	e0bffb17 	ldw	r2,-20(fp)
 82195c4:	10c00417 	ldw	r3,16(r2)
 82195c8:	e0bffb17 	ldw	r2,-20(fp)
 82195cc:	10800117 	ldw	r2,4(r2)
 82195d0:	1880041e 	bne	r3,r2,82195e4 <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 82195d4:	e0bffb17 	ldw	r2,-20(fp)
 82195d8:	10c00217 	ldw	r3,8(r2)
 82195dc:	e0bffb17 	ldw	r2,-20(fp)
 82195e0:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 82195e4:	e0bffb17 	ldw	r2,-20(fp)
 82195e8:	10800417 	ldw	r2,16(r2)
 82195ec:	10ffff04 	addi	r3,r2,-4
 82195f0:	e0bffb17 	ldw	r2,-20(fp)
 82195f4:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 82195f8:	e0bffb17 	ldw	r2,-20(fp)
 82195fc:	10800417 	ldw	r2,16(r2)
 8219600:	e0ffff17 	ldw	r3,-4(fp)
 8219604:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219608:	e0bffb17 	ldw	r2,-20(fp)
 821960c:	1080058b 	ldhu	r2,22(r2)
 8219610:	10800044 	addi	r2,r2,1
 8219614:	1007883a 	mov	r3,r2
 8219618:	e0bffb17 	ldw	r2,-20(fp)
 821961c:	10c0058d 	sth	r3,22(r2)
 8219620:	e0bff817 	ldw	r2,-32(fp)
 8219624:	e0bffc15 	stw	r2,-16(fp)
 8219628:	e0bffc17 	ldw	r2,-16(fp)
 821962c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219630:	0005883a 	mov	r2,zero
}
 8219634:	e037883a 	mov	sp,fp
 8219638:	dfc00117 	ldw	ra,4(sp)
 821963c:	df000017 	ldw	fp,0(sp)
 8219640:	dec00204 	addi	sp,sp,8
 8219644:	f800283a 	ret

08219648 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 8219648:	defff504 	addi	sp,sp,-44
 821964c:	dfc00a15 	stw	ra,40(sp)
 8219650:	df000915 	stw	fp,36(sp)
 8219654:	df000904 	addi	fp,sp,36
 8219658:	e13ffd15 	stw	r4,-12(fp)
 821965c:	e17ffe15 	stw	r5,-8(fp)
 8219660:	3005883a 	mov	r2,r6
 8219664:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219668:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821966c:	e0bffd17 	ldw	r2,-12(fp)
 8219670:	1000021e 	bne	r2,zero,821967c <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 8219674:	00800104 	movi	r2,4
 8219678:	00007106 	br	8219840 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 821967c:	e0bffd17 	ldw	r2,-12(fp)
 8219680:	10800003 	ldbu	r2,0(r2)
 8219684:	10803fcc 	andi	r2,r2,255
 8219688:	108000a0 	cmpeqi	r2,r2,2
 821968c:	1000021e 	bne	r2,zero,8219698 <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 8219690:	00800044 	movi	r2,1
 8219694:	00006a06 	br	8219840 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219698:	0005303a 	rdctl	r2,status
 821969c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82196a0:	e0fffc17 	ldw	r3,-16(fp)
 82196a4:	00bfff84 	movi	r2,-2
 82196a8:	1884703a 	and	r2,r3,r2
 82196ac:	1001703a 	wrctl	status,r2
  
  return context;
 82196b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82196b4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 82196b8:	e0bffd17 	ldw	r2,-12(fp)
 82196bc:	10800283 	ldbu	r2,10(r2)
 82196c0:	10803fcc 	andi	r2,r2,255
 82196c4:	10001d26 	beq	r2,zero,821973c <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 82196c8:	e0bfff03 	ldbu	r2,-4(fp)
 82196cc:	1080004c 	andi	r2,r2,1
 82196d0:	10000b26 	beq	r2,zero,8219700 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82196d4:	00000506 	br	82196ec <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82196d8:	000f883a 	mov	r7,zero
 82196dc:	01800104 	movi	r6,4
 82196e0:	e17ffe17 	ldw	r5,-8(fp)
 82196e4:	e13ffd17 	ldw	r4,-12(fp)
 82196e8:	82158240 	call	8215824 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82196ec:	e0bffd17 	ldw	r2,-12(fp)
 82196f0:	10800283 	ldbu	r2,10(r2)
 82196f4:	10803fcc 	andi	r2,r2,255
 82196f8:	103ff71e 	bne	r2,zero,82196d8 <OSQPostOpt+0x90>
 82196fc:	00000506 	br	8219714 <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219700:	000f883a 	mov	r7,zero
 8219704:	01800104 	movi	r6,4
 8219708:	e17ffe17 	ldw	r5,-8(fp)
 821970c:	e13ffd17 	ldw	r4,-12(fp)
 8219710:	82158240 	call	8215824 <OS_EventTaskRdy>
 8219714:	e0bff717 	ldw	r2,-36(fp)
 8219718:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821971c:	e0bff817 	ldw	r2,-32(fp)
 8219720:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 8219724:	e0bfff03 	ldbu	r2,-4(fp)
 8219728:	1080010c 	andi	r2,r2,4
 821972c:	1000011e 	bne	r2,zero,8219734 <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 8219730:	82162700 	call	8216270 <OS_Sched>
        }
        return (OS_ERR_NONE);
 8219734:	0005883a 	mov	r2,zero
 8219738:	00004106 	br	8219840 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 821973c:	e0bffd17 	ldw	r2,-12(fp)
 8219740:	10800117 	ldw	r2,4(r2)
 8219744:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 8219748:	e0bffa17 	ldw	r2,-24(fp)
 821974c:	10c0058b 	ldhu	r3,22(r2)
 8219750:	e0bffa17 	ldw	r2,-24(fp)
 8219754:	1080050b 	ldhu	r2,20(r2)
 8219758:	18ffffcc 	andi	r3,r3,65535
 821975c:	10bfffcc 	andi	r2,r2,65535
 8219760:	18800636 	bltu	r3,r2,821977c <OSQPostOpt+0x134>
 8219764:	e0bff717 	ldw	r2,-36(fp)
 8219768:	e0bff915 	stw	r2,-28(fp)
 821976c:	e0bff917 	ldw	r2,-28(fp)
 8219770:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219774:	00800784 	movi	r2,30
 8219778:	00003106 	br	8219840 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 821977c:	e0bfff03 	ldbu	r2,-4(fp)
 8219780:	1080008c 	andi	r2,r2,2
 8219784:	10001326 	beq	r2,zero,82197d4 <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 8219788:	e0bffa17 	ldw	r2,-24(fp)
 821978c:	10c00417 	ldw	r3,16(r2)
 8219790:	e0bffa17 	ldw	r2,-24(fp)
 8219794:	10800117 	ldw	r2,4(r2)
 8219798:	1880041e 	bne	r3,r2,82197ac <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 821979c:	e0bffa17 	ldw	r2,-24(fp)
 82197a0:	10c00217 	ldw	r3,8(r2)
 82197a4:	e0bffa17 	ldw	r2,-24(fp)
 82197a8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 82197ac:	e0bffa17 	ldw	r2,-24(fp)
 82197b0:	10800417 	ldw	r2,16(r2)
 82197b4:	10ffff04 	addi	r3,r2,-4
 82197b8:	e0bffa17 	ldw	r2,-24(fp)
 82197bc:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 82197c0:	e0bffa17 	ldw	r2,-24(fp)
 82197c4:	10800417 	ldw	r2,16(r2)
 82197c8:	e0fffe17 	ldw	r3,-8(fp)
 82197cc:	10c00015 	stw	r3,0(r2)
 82197d0:	00001006 	br	8219814 <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 82197d4:	e0bffa17 	ldw	r2,-24(fp)
 82197d8:	10800317 	ldw	r2,12(r2)
 82197dc:	11000104 	addi	r4,r2,4
 82197e0:	e0fffa17 	ldw	r3,-24(fp)
 82197e4:	19000315 	stw	r4,12(r3)
 82197e8:	e0fffe17 	ldw	r3,-8(fp)
 82197ec:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 82197f0:	e0bffa17 	ldw	r2,-24(fp)
 82197f4:	10c00317 	ldw	r3,12(r2)
 82197f8:	e0bffa17 	ldw	r2,-24(fp)
 82197fc:	10800217 	ldw	r2,8(r2)
 8219800:	1880041e 	bne	r3,r2,8219814 <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 8219804:	e0bffa17 	ldw	r2,-24(fp)
 8219808:	10c00117 	ldw	r3,4(r2)
 821980c:	e0bffa17 	ldw	r2,-24(fp)
 8219810:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219814:	e0bffa17 	ldw	r2,-24(fp)
 8219818:	1080058b 	ldhu	r2,22(r2)
 821981c:	10800044 	addi	r2,r2,1
 8219820:	1007883a 	mov	r3,r2
 8219824:	e0bffa17 	ldw	r2,-24(fp)
 8219828:	10c0058d 	sth	r3,22(r2)
 821982c:	e0bff717 	ldw	r2,-36(fp)
 8219830:	e0bffb15 	stw	r2,-20(fp)
 8219834:	e0bffb17 	ldw	r2,-20(fp)
 8219838:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821983c:	0005883a 	mov	r2,zero
}
 8219840:	e037883a 	mov	sp,fp
 8219844:	dfc00117 	ldw	ra,4(sp)
 8219848:	df000017 	ldw	fp,0(sp)
 821984c:	dec00204 	addi	sp,sp,8
 8219850:	f800283a 	ret

08219854 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 8219854:	defff604 	addi	sp,sp,-40
 8219858:	df000915 	stw	fp,36(sp)
 821985c:	df000904 	addi	fp,sp,36
 8219860:	e13ffe15 	stw	r4,-8(fp)
 8219864:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219868:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 821986c:	e0bffe17 	ldw	r2,-8(fp)
 8219870:	1000021e 	bne	r2,zero,821987c <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 8219874:	00800104 	movi	r2,4
 8219878:	00004906 	br	82199a0 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 821987c:	e0bfff17 	ldw	r2,-4(fp)
 8219880:	1000021e 	bne	r2,zero,821988c <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 8219884:	00800244 	movi	r2,9
 8219888:	00004506 	br	82199a0 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 821988c:	e0bffe17 	ldw	r2,-8(fp)
 8219890:	10800003 	ldbu	r2,0(r2)
 8219894:	10803fcc 	andi	r2,r2,255
 8219898:	108000a0 	cmpeqi	r2,r2,2
 821989c:	1000021e 	bne	r2,zero,82198a8 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 82198a0:	00800044 	movi	r2,1
 82198a4:	00003e06 	br	82199a0 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82198a8:	0005303a 	rdctl	r2,status
 82198ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82198b0:	e0fffd17 	ldw	r3,-12(fp)
 82198b4:	00bfff84 	movi	r2,-2
 82198b8:	1884703a 	and	r2,r3,r2
 82198bc:	1001703a 	wrctl	status,r2
  
  return context;
 82198c0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82198c4:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 82198c8:	e0bffe17 	ldw	r2,-8(fp)
 82198cc:	10c00283 	ldbu	r3,10(r2)
 82198d0:	e0bfff17 	ldw	r2,-4(fp)
 82198d4:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 82198d8:	e0bffe17 	ldw	r2,-8(fp)
 82198dc:	108002c4 	addi	r2,r2,11
 82198e0:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 82198e4:	e0bfff17 	ldw	r2,-4(fp)
 82198e8:	10800204 	addi	r2,r2,8
 82198ec:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 82198f0:	e03ff705 	stb	zero,-36(fp)
 82198f4:	00000b06 	br	8219924 <OSQQuery+0xd0>
        *pdest++ = *psrc++;
 82198f8:	e0bff917 	ldw	r2,-28(fp)
 82198fc:	10c00044 	addi	r3,r2,1
 8219900:	e0fff915 	stw	r3,-28(fp)
 8219904:	e0fff817 	ldw	r3,-32(fp)
 8219908:	19000044 	addi	r4,r3,1
 821990c:	e13ff815 	stw	r4,-32(fp)
 8219910:	18c00003 	ldbu	r3,0(r3)
 8219914:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219918:	e0bff703 	ldbu	r2,-36(fp)
 821991c:	10800044 	addi	r2,r2,1
 8219920:	e0bff705 	stb	r2,-36(fp)
 8219924:	e0bff703 	ldbu	r2,-36(fp)
 8219928:	108000f0 	cmpltui	r2,r2,3
 821992c:	103ff21e 	bne	r2,zero,82198f8 <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 8219930:	e0bffe17 	ldw	r2,-8(fp)
 8219934:	10800117 	ldw	r2,4(r2)
 8219938:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 821993c:	e0bffc17 	ldw	r2,-16(fp)
 8219940:	1080058b 	ldhu	r2,22(r2)
 8219944:	10bfffcc 	andi	r2,r2,65535
 8219948:	10000626 	beq	r2,zero,8219964 <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 821994c:	e0bffc17 	ldw	r2,-16(fp)
 8219950:	10800417 	ldw	r2,16(r2)
 8219954:	10c00017 	ldw	r3,0(r2)
 8219958:	e0bfff17 	ldw	r2,-4(fp)
 821995c:	10c00015 	stw	r3,0(r2)
 8219960:	00000206 	br	821996c <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
 8219964:	e0bfff17 	ldw	r2,-4(fp)
 8219968:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 821996c:	e0bffc17 	ldw	r2,-16(fp)
 8219970:	10c0058b 	ldhu	r3,22(r2)
 8219974:	e0bfff17 	ldw	r2,-4(fp)
 8219978:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 821997c:	e0bffc17 	ldw	r2,-16(fp)
 8219980:	10c0050b 	ldhu	r3,20(r2)
 8219984:	e0bfff17 	ldw	r2,-4(fp)
 8219988:	10c0018d 	sth	r3,6(r2)
 821998c:	e0bffa17 	ldw	r2,-24(fp)
 8219990:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219994:	e0bffb17 	ldw	r2,-20(fp)
 8219998:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821999c:	0005883a 	mov	r2,zero
}
 82199a0:	e037883a 	mov	sp,fp
 82199a4:	df000017 	ldw	fp,0(sp)
 82199a8:	dec00104 	addi	sp,sp,4
 82199ac:	f800283a 	ret

082199b0 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 82199b0:	defffb04 	addi	sp,sp,-20
 82199b4:	dfc00415 	stw	ra,16(sp)
 82199b8:	df000315 	stw	fp,12(sp)
 82199bc:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 82199c0:	01407804 	movi	r5,480
 82199c4:	010209b4 	movhi	r4,2086
 82199c8:	212f3c04 	addi	r4,r4,-17168
 82199cc:	82161b40 	call	82161b4 <OS_MemClr>
    pq1 = &OSQTbl[0];
 82199d0:	008209b4 	movhi	r2,2086
 82199d4:	10af3c04 	addi	r2,r2,-17168
 82199d8:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 82199dc:	008209b4 	movhi	r2,2086
 82199e0:	10af4204 	addi	r2,r2,-17144
 82199e4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 82199e8:	e03ffd0d 	sth	zero,-12(fp)
 82199ec:	00000c06 	br	8219a20 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 82199f0:	e0bffe17 	ldw	r2,-8(fp)
 82199f4:	e0ffff17 	ldw	r3,-4(fp)
 82199f8:	10c00015 	stw	r3,0(r2)
        pq1++;
 82199fc:	e0bffe17 	ldw	r2,-8(fp)
 8219a00:	10800604 	addi	r2,r2,24
 8219a04:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 8219a08:	e0bfff17 	ldw	r2,-4(fp)
 8219a0c:	10800604 	addi	r2,r2,24
 8219a10:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219a14:	e0bffd0b 	ldhu	r2,-12(fp)
 8219a18:	10800044 	addi	r2,r2,1
 8219a1c:	e0bffd0d 	sth	r2,-12(fp)
 8219a20:	e0bffd0b 	ldhu	r2,-12(fp)
 8219a24:	108004f0 	cmpltui	r2,r2,19
 8219a28:	103ff11e 	bne	r2,zero,82199f0 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 8219a2c:	e0bffe17 	ldw	r2,-8(fp)
 8219a30:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 8219a34:	008209b4 	movhi	r2,2086
 8219a38:	10af3c04 	addi	r2,r2,-17168
 8219a3c:	d0a07615 	stw	r2,-32296(gp)
#endif
}
 8219a40:	0001883a 	nop
 8219a44:	e037883a 	mov	sp,fp
 8219a48:	dfc00117 	ldw	ra,4(sp)
 8219a4c:	df000017 	ldw	fp,0(sp)
 8219a50:	dec00204 	addi	sp,sp,8
 8219a54:	f800283a 	ret

08219a58 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 8219a58:	defffa04 	addi	sp,sp,-24
 8219a5c:	df000515 	stw	fp,20(sp)
 8219a60:	df000504 	addi	fp,sp,20
 8219a64:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219a68:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219a6c:	e0bfff17 	ldw	r2,-4(fp)
 8219a70:	1000021e 	bne	r2,zero,8219a7c <OSSemAccept+0x24>
        return (0);
 8219a74:	0005883a 	mov	r2,zero
 8219a78:	00001f06 	br	8219af8 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219a7c:	e0bfff17 	ldw	r2,-4(fp)
 8219a80:	10800003 	ldbu	r2,0(r2)
 8219a84:	10803fcc 	andi	r2,r2,255
 8219a88:	108000e0 	cmpeqi	r2,r2,3
 8219a8c:	1000021e 	bne	r2,zero,8219a98 <OSSemAccept+0x40>
        return (0);
 8219a90:	0005883a 	mov	r2,zero
 8219a94:	00001806 	br	8219af8 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219a98:	0005303a 	rdctl	r2,status
 8219a9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219aa0:	e0fffe17 	ldw	r3,-8(fp)
 8219aa4:	00bfff84 	movi	r2,-2
 8219aa8:	1884703a 	and	r2,r3,r2
 8219aac:	1001703a 	wrctl	status,r2
  
  return context;
 8219ab0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219ab4:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 8219ab8:	e0bfff17 	ldw	r2,-4(fp)
 8219abc:	1080020b 	ldhu	r2,8(r2)
 8219ac0:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 8219ac4:	e0bffd0b 	ldhu	r2,-12(fp)
 8219ac8:	10000626 	beq	r2,zero,8219ae4 <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 8219acc:	e0bfff17 	ldw	r2,-4(fp)
 8219ad0:	1080020b 	ldhu	r2,8(r2)
 8219ad4:	10bfffc4 	addi	r2,r2,-1
 8219ad8:	1007883a 	mov	r3,r2
 8219adc:	e0bfff17 	ldw	r2,-4(fp)
 8219ae0:	10c0020d 	sth	r3,8(r2)
 8219ae4:	e0bffb17 	ldw	r2,-20(fp)
 8219ae8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219aec:	e0bffc17 	ldw	r2,-16(fp)
 8219af0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 8219af4:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8219af8:	e037883a 	mov	sp,fp
 8219afc:	df000017 	ldw	fp,0(sp)
 8219b00:	dec00104 	addi	sp,sp,4
 8219b04:	f800283a 	ret

08219b08 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 8219b08:	defff904 	addi	sp,sp,-28
 8219b0c:	dfc00615 	stw	ra,24(sp)
 8219b10:	df000515 	stw	fp,20(sp)
 8219b14:	df000504 	addi	fp,sp,20
 8219b18:	2005883a 	mov	r2,r4
 8219b1c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219b20:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219b24:	d0a07903 	ldbu	r2,-32284(gp)
 8219b28:	10803fcc 	andi	r2,r2,255
 8219b2c:	10000226 	beq	r2,zero,8219b38 <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 8219b30:	0005883a 	mov	r2,zero
 8219b34:	00002506 	br	8219bcc <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219b38:	0005303a 	rdctl	r2,status
 8219b3c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219b40:	e0fffe17 	ldw	r3,-8(fp)
 8219b44:	00bfff84 	movi	r2,-2
 8219b48:	1884703a 	and	r2,r3,r2
 8219b4c:	1001703a 	wrctl	status,r2
  
  return context;
 8219b50:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219b54:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 8219b58:	d0a07817 	ldw	r2,-32288(gp)
 8219b5c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 8219b60:	d0a07817 	ldw	r2,-32288(gp)
 8219b64:	10000326 	beq	r2,zero,8219b74 <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8219b68:	d0a07817 	ldw	r2,-32288(gp)
 8219b6c:	10800117 	ldw	r2,4(r2)
 8219b70:	d0a07815 	stw	r2,-32288(gp)
 8219b74:	e0bffb17 	ldw	r2,-20(fp)
 8219b78:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219b7c:	e0bffc17 	ldw	r2,-16(fp)
 8219b80:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 8219b84:	e0bffd17 	ldw	r2,-12(fp)
 8219b88:	10000f26 	beq	r2,zero,8219bc8 <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 8219b8c:	e0bffd17 	ldw	r2,-12(fp)
 8219b90:	00c000c4 	movi	r3,3
 8219b94:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 8219b98:	e0bffd17 	ldw	r2,-12(fp)
 8219b9c:	e0ffff0b 	ldhu	r3,-4(fp)
 8219ba0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 8219ba4:	e0bffd17 	ldw	r2,-12(fp)
 8219ba8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 8219bac:	e0bffd17 	ldw	r2,-12(fp)
 8219bb0:	00c00fc4 	movi	r3,63
 8219bb4:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 8219bb8:	e0bffd17 	ldw	r2,-12(fp)
 8219bbc:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 8219bc0:	e13ffd17 	ldw	r4,-12(fp)
 8219bc4:	8215dd40 	call	8215dd4 <OS_EventWaitListInit>
    }
    return (pevent);
 8219bc8:	e0bffd17 	ldw	r2,-12(fp)
}
 8219bcc:	e037883a 	mov	sp,fp
 8219bd0:	dfc00117 	ldw	ra,4(sp)
 8219bd4:	df000017 	ldw	fp,0(sp)
 8219bd8:	dec00204 	addi	sp,sp,8
 8219bdc:	f800283a 	ret

08219be0 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219be0:	defff304 	addi	sp,sp,-52
 8219be4:	dfc00c15 	stw	ra,48(sp)
 8219be8:	df000b15 	stw	fp,44(sp)
 8219bec:	df000b04 	addi	fp,sp,44
 8219bf0:	e13ffd15 	stw	r4,-12(fp)
 8219bf4:	2805883a 	mov	r2,r5
 8219bf8:	e1bfff15 	stw	r6,-4(fp)
 8219bfc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219c00:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219c04:	e0bfff17 	ldw	r2,-4(fp)
 8219c08:	1000021e 	bne	r2,zero,8219c14 <OSSemDel+0x34>
        return (pevent);
 8219c0c:	e0bffd17 	ldw	r2,-12(fp)
 8219c10:	00007e06 	br	8219e0c <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219c14:	e0bffd17 	ldw	r2,-12(fp)
 8219c18:	1000051e 	bne	r2,zero,8219c30 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219c1c:	e0bfff17 	ldw	r2,-4(fp)
 8219c20:	00c00104 	movi	r3,4
 8219c24:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219c28:	e0bffd17 	ldw	r2,-12(fp)
 8219c2c:	00007706 	br	8219e0c <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 8219c30:	e0bffd17 	ldw	r2,-12(fp)
 8219c34:	10800003 	ldbu	r2,0(r2)
 8219c38:	10803fcc 	andi	r2,r2,255
 8219c3c:	108000e0 	cmpeqi	r2,r2,3
 8219c40:	1000051e 	bne	r2,zero,8219c58 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219c44:	e0bfff17 	ldw	r2,-4(fp)
 8219c48:	00c00044 	movi	r3,1
 8219c4c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219c50:	e0bffd17 	ldw	r2,-12(fp)
 8219c54:	00006d06 	br	8219e0c <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219c58:	d0a07903 	ldbu	r2,-32284(gp)
 8219c5c:	10803fcc 	andi	r2,r2,255
 8219c60:	10000526 	beq	r2,zero,8219c78 <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 8219c64:	e0bfff17 	ldw	r2,-4(fp)
 8219c68:	00c003c4 	movi	r3,15
 8219c6c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219c70:	e0bffd17 	ldw	r2,-12(fp)
 8219c74:	00006506 	br	8219e0c <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219c78:	0005303a 	rdctl	r2,status
 8219c7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219c80:	e0fffc17 	ldw	r3,-16(fp)
 8219c84:	00bfff84 	movi	r2,-2
 8219c88:	1884703a 	and	r2,r3,r2
 8219c8c:	1001703a 	wrctl	status,r2
  
  return context;
 8219c90:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219c94:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 8219c98:	e0bffd17 	ldw	r2,-12(fp)
 8219c9c:	10800283 	ldbu	r2,10(r2)
 8219ca0:	10803fcc 	andi	r2,r2,255
 8219ca4:	10000326 	beq	r2,zero,8219cb4 <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8219ca8:	00800044 	movi	r2,1
 8219cac:	e0bff505 	stb	r2,-44(fp)
 8219cb0:	00000106 	br	8219cb8 <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8219cb4:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 8219cb8:	e0bffe03 	ldbu	r2,-8(fp)
 8219cbc:	10000326 	beq	r2,zero,8219ccc <OSSemDel+0xec>
 8219cc0:	10800060 	cmpeqi	r2,r2,1
 8219cc4:	1000281e 	bne	r2,zero,8219d68 <OSSemDel+0x188>
 8219cc8:	00004506 	br	8219de0 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 8219ccc:	e0bff503 	ldbu	r2,-44(fp)
 8219cd0:	1000161e 	bne	r2,zero,8219d2c <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8219cd4:	e0bffd17 	ldw	r2,-12(fp)
 8219cd8:	00c00fc4 	movi	r3,63
 8219cdc:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8219ce0:	e0bffd17 	ldw	r2,-12(fp)
 8219ce4:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219ce8:	e0bffd17 	ldw	r2,-12(fp)
 8219cec:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8219cf0:	d0e07817 	ldw	r3,-32288(gp)
 8219cf4:	e0bffd17 	ldw	r2,-12(fp)
 8219cf8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8219cfc:	e0bffd17 	ldw	r2,-12(fp)
 8219d00:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8219d04:	e0bffd17 	ldw	r2,-12(fp)
 8219d08:	d0a07815 	stw	r2,-32288(gp)
 8219d0c:	e0bff717 	ldw	r2,-36(fp)
 8219d10:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219d14:	e0bff817 	ldw	r2,-32(fp)
 8219d18:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8219d1c:	e0bfff17 	ldw	r2,-4(fp)
 8219d20:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 8219d24:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8219d28:	00003706 	br	8219e08 <OSSemDel+0x228>
 8219d2c:	e0bff717 	ldw	r2,-36(fp)
 8219d30:	e0bff915 	stw	r2,-28(fp)
 8219d34:	e0bff917 	ldw	r2,-28(fp)
 8219d38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8219d3c:	e0bfff17 	ldw	r2,-4(fp)
 8219d40:	00c01244 	movi	r3,73
 8219d44:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8219d48:	e0bffd17 	ldw	r2,-12(fp)
 8219d4c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8219d50:	00002d06 	br	8219e08 <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 8219d54:	000f883a 	mov	r7,zero
 8219d58:	01800044 	movi	r6,1
 8219d5c:	000b883a 	mov	r5,zero
 8219d60:	e13ffd17 	ldw	r4,-12(fp)
 8219d64:	82158240 	call	8215824 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 8219d68:	e0bffd17 	ldw	r2,-12(fp)
 8219d6c:	10800283 	ldbu	r2,10(r2)
 8219d70:	10803fcc 	andi	r2,r2,255
 8219d74:	103ff71e 	bne	r2,zero,8219d54 <OSSemDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8219d78:	e0bffd17 	ldw	r2,-12(fp)
 8219d7c:	00c00fc4 	movi	r3,63
 8219d80:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 8219d84:	e0bffd17 	ldw	r2,-12(fp)
 8219d88:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219d8c:	e0bffd17 	ldw	r2,-12(fp)
 8219d90:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 8219d94:	d0e07817 	ldw	r3,-32288(gp)
 8219d98:	e0bffd17 	ldw	r2,-12(fp)
 8219d9c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8219da0:	e0bffd17 	ldw	r2,-12(fp)
 8219da4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8219da8:	e0bffd17 	ldw	r2,-12(fp)
 8219dac:	d0a07815 	stw	r2,-32288(gp)
 8219db0:	e0bff717 	ldw	r2,-36(fp)
 8219db4:	e0bffa15 	stw	r2,-24(fp)
 8219db8:	e0bffa17 	ldw	r2,-24(fp)
 8219dbc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8219dc0:	e0bff503 	ldbu	r2,-44(fp)
 8219dc4:	10800058 	cmpnei	r2,r2,1
 8219dc8:	1000011e 	bne	r2,zero,8219dd0 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8219dcc:	82162700 	call	8216270 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8219dd0:	e0bfff17 	ldw	r2,-4(fp)
 8219dd4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 8219dd8:	e03ff615 	stw	zero,-40(fp)
             break;
 8219ddc:	00000a06 	br	8219e08 <OSSemDel+0x228>
 8219de0:	e0bff717 	ldw	r2,-36(fp)
 8219de4:	e0bffb15 	stw	r2,-20(fp)
 8219de8:	e0bffb17 	ldw	r2,-20(fp)
 8219dec:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 8219df0:	e0bfff17 	ldw	r2,-4(fp)
 8219df4:	00c001c4 	movi	r3,7
 8219df8:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 8219dfc:	e0bffd17 	ldw	r2,-12(fp)
 8219e00:	e0bff615 	stw	r2,-40(fp)
             break;
 8219e04:	0001883a 	nop
    }
    return (pevent_return);
 8219e08:	e0bff617 	ldw	r2,-40(fp)
}
 8219e0c:	e037883a 	mov	sp,fp
 8219e10:	dfc00117 	ldw	ra,4(sp)
 8219e14:	df000017 	ldw	fp,0(sp)
 8219e18:	dec00204 	addi	sp,sp,8
 8219e1c:	f800283a 	ret

08219e20 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 8219e20:	defff504 	addi	sp,sp,-44
 8219e24:	dfc00a15 	stw	ra,40(sp)
 8219e28:	df000915 	stw	fp,36(sp)
 8219e2c:	df000904 	addi	fp,sp,36
 8219e30:	e13ffd15 	stw	r4,-12(fp)
 8219e34:	2805883a 	mov	r2,r5
 8219e38:	e1bfff15 	stw	r6,-4(fp)
 8219e3c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219e40:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8219e44:	e0bfff17 	ldw	r2,-4(fp)
 8219e48:	10007226 	beq	r2,zero,821a014 <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219e4c:	e0bffd17 	ldw	r2,-12(fp)
 8219e50:	1000041e 	bne	r2,zero,8219e64 <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 8219e54:	e0bfff17 	ldw	r2,-4(fp)
 8219e58:	00c00104 	movi	r3,4
 8219e5c:	10c00005 	stb	r3,0(r2)
        return;
 8219e60:	00006d06 	br	821a018 <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219e64:	e0bffd17 	ldw	r2,-12(fp)
 8219e68:	10800003 	ldbu	r2,0(r2)
 8219e6c:	10803fcc 	andi	r2,r2,255
 8219e70:	108000e0 	cmpeqi	r2,r2,3
 8219e74:	1000041e 	bne	r2,zero,8219e88 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 8219e78:	e0bfff17 	ldw	r2,-4(fp)
 8219e7c:	00c00044 	movi	r3,1
 8219e80:	10c00005 	stb	r3,0(r2)
        return;
 8219e84:	00006406 	br	821a018 <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 8219e88:	d0a07903 	ldbu	r2,-32284(gp)
 8219e8c:	10803fcc 	andi	r2,r2,255
 8219e90:	10000426 	beq	r2,zero,8219ea4 <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 8219e94:	e0bfff17 	ldw	r2,-4(fp)
 8219e98:	00c00084 	movi	r3,2
 8219e9c:	10c00005 	stb	r3,0(r2)
        return;
 8219ea0:	00005d06 	br	821a018 <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 8219ea4:	d0a06b03 	ldbu	r2,-32340(gp)
 8219ea8:	10803fcc 	andi	r2,r2,255
 8219eac:	10000426 	beq	r2,zero,8219ec0 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 8219eb0:	e0bfff17 	ldw	r2,-4(fp)
 8219eb4:	00c00344 	movi	r3,13
 8219eb8:	10c00005 	stb	r3,0(r2)
        return;
 8219ebc:	00005606 	br	821a018 <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219ec0:	0005303a 	rdctl	r2,status
 8219ec4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219ec8:	e0fffc17 	ldw	r3,-16(fp)
 8219ecc:	00bfff84 	movi	r2,-2
 8219ed0:	1884703a 	and	r2,r3,r2
 8219ed4:	1001703a 	wrctl	status,r2
  
  return context;
 8219ed8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219edc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 8219ee0:	e0bffd17 	ldw	r2,-12(fp)
 8219ee4:	1080020b 	ldhu	r2,8(r2)
 8219ee8:	10bfffcc 	andi	r2,r2,65535
 8219eec:	10000d26 	beq	r2,zero,8219f24 <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 8219ef0:	e0bffd17 	ldw	r2,-12(fp)
 8219ef4:	1080020b 	ldhu	r2,8(r2)
 8219ef8:	10bfffc4 	addi	r2,r2,-1
 8219efc:	1007883a 	mov	r3,r2
 8219f00:	e0bffd17 	ldw	r2,-12(fp)
 8219f04:	10c0020d 	sth	r3,8(r2)
 8219f08:	e0bff717 	ldw	r2,-36(fp)
 8219f0c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219f10:	e0bff817 	ldw	r2,-32(fp)
 8219f14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 8219f18:	e0bfff17 	ldw	r2,-4(fp)
 8219f1c:	10000005 	stb	zero,0(r2)
        return;
 8219f20:	00003d06 	br	821a018 <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 8219f24:	d0a07a17 	ldw	r2,-32280(gp)
 8219f28:	d0e07a17 	ldw	r3,-32280(gp)
 8219f2c:	18c00c03 	ldbu	r3,48(r3)
 8219f30:	18c00054 	ori	r3,r3,1
 8219f34:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8219f38:	d0a07a17 	ldw	r2,-32280(gp)
 8219f3c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 8219f40:	d0a07a17 	ldw	r2,-32280(gp)
 8219f44:	e0fffe0b 	ldhu	r3,-8(fp)
 8219f48:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 8219f4c:	e13ffd17 	ldw	r4,-12(fp)
 8219f50:	82159bc0 	call	82159bc <OS_EventTaskWait>
 8219f54:	e0bff717 	ldw	r2,-36(fp)
 8219f58:	e0bffb15 	stw	r2,-20(fp)
 8219f5c:	e0bffb17 	ldw	r2,-20(fp)
 8219f60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 8219f64:	82162700 	call	8216270 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219f68:	0005303a 	rdctl	r2,status
 8219f6c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219f70:	e0fff917 	ldw	r3,-28(fp)
 8219f74:	00bfff84 	movi	r2,-2
 8219f78:	1884703a 	and	r2,r3,r2
 8219f7c:	1001703a 	wrctl	status,r2
  
  return context;
 8219f80:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 8219f84:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 8219f88:	d0a07a17 	ldw	r2,-32280(gp)
 8219f8c:	10800c43 	ldbu	r2,49(r2)
 8219f90:	10803fcc 	andi	r2,r2,255
 8219f94:	10000326 	beq	r2,zero,8219fa4 <OSSemPend+0x184>
 8219f98:	108000a0 	cmpeqi	r2,r2,2
 8219f9c:	1000041e 	bne	r2,zero,8219fb0 <OSSemPend+0x190>
 8219fa0:	00000706 	br	8219fc0 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 8219fa4:	e0bfff17 	ldw	r2,-4(fp)
 8219fa8:	10000005 	stb	zero,0(r2)
             break;
 8219fac:	00000c06 	br	8219fe0 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219fb0:	e0bfff17 	ldw	r2,-4(fp)
 8219fb4:	00c00384 	movi	r3,14
 8219fb8:	10c00005 	stb	r3,0(r2)
             break;
 8219fbc:	00000806 	br	8219fe0 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 8219fc0:	d0a07a17 	ldw	r2,-32280(gp)
 8219fc4:	e17ffd17 	ldw	r5,-12(fp)
 8219fc8:	1009883a 	mov	r4,r2
 8219fcc:	8215c1c0 	call	8215c1c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 8219fd0:	e0bfff17 	ldw	r2,-4(fp)
 8219fd4:	00c00284 	movi	r3,10
 8219fd8:	10c00005 	stb	r3,0(r2)
             break;
 8219fdc:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 8219fe0:	d0a07a17 	ldw	r2,-32280(gp)
 8219fe4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 8219fe8:	d0a07a17 	ldw	r2,-32280(gp)
 8219fec:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 8219ff0:	d0a07a17 	ldw	r2,-32280(gp)
 8219ff4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8219ff8:	d0a07a17 	ldw	r2,-32280(gp)
 8219ffc:	10000815 	stw	zero,32(r2)
 821a000:	e0bff717 	ldw	r2,-36(fp)
 821a004:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a008:	e0bffa17 	ldw	r2,-24(fp)
 821a00c:	1001703a 	wrctl	status,r2
 821a010:	00000106 	br	821a018 <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a014:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 821a018:	e037883a 	mov	sp,fp
 821a01c:	dfc00117 	ldw	ra,4(sp)
 821a020:	df000017 	ldw	fp,0(sp)
 821a024:	dec00204 	addi	sp,sp,8
 821a028:	f800283a 	ret

0821a02c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 821a02c:	defff604 	addi	sp,sp,-40
 821a030:	dfc00915 	stw	ra,36(sp)
 821a034:	df000815 	stw	fp,32(sp)
 821a038:	df000804 	addi	fp,sp,32
 821a03c:	e13ffd15 	stw	r4,-12(fp)
 821a040:	2805883a 	mov	r2,r5
 821a044:	e1bfff15 	stw	r6,-4(fp)
 821a048:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a04c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a050:	e0bfff17 	ldw	r2,-4(fp)
 821a054:	1000021e 	bne	r2,zero,821a060 <OSSemPendAbort+0x34>
        return (0);
 821a058:	0005883a 	mov	r2,zero
 821a05c:	00004906 	br	821a184 <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a060:	e0bffd17 	ldw	r2,-12(fp)
 821a064:	1000051e 	bne	r2,zero,821a07c <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 821a068:	e0bfff17 	ldw	r2,-4(fp)
 821a06c:	00c00104 	movi	r3,4
 821a070:	10c00005 	stb	r3,0(r2)
        return (0);
 821a074:	0005883a 	mov	r2,zero
 821a078:	00004206 	br	821a184 <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a07c:	e0bffd17 	ldw	r2,-12(fp)
 821a080:	10800003 	ldbu	r2,0(r2)
 821a084:	10803fcc 	andi	r2,r2,255
 821a088:	108000e0 	cmpeqi	r2,r2,3
 821a08c:	1000051e 	bne	r2,zero,821a0a4 <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 821a090:	e0bfff17 	ldw	r2,-4(fp)
 821a094:	00c00044 	movi	r3,1
 821a098:	10c00005 	stb	r3,0(r2)
        return (0);
 821a09c:	0005883a 	mov	r2,zero
 821a0a0:	00003806 	br	821a184 <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a0a4:	0005303a 	rdctl	r2,status
 821a0a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a0ac:	e0fffc17 	ldw	r3,-16(fp)
 821a0b0:	00bfff84 	movi	r2,-2
 821a0b4:	1884703a 	and	r2,r3,r2
 821a0b8:	1001703a 	wrctl	status,r2
  
  return context;
 821a0bc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a0c0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 821a0c4:	e0bffd17 	ldw	r2,-12(fp)
 821a0c8:	10800283 	ldbu	r2,10(r2)
 821a0cc:	10803fcc 	andi	r2,r2,255
 821a0d0:	10002526 	beq	r2,zero,821a168 <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
 821a0d4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 821a0d8:	e0bffe03 	ldbu	r2,-8(fp)
 821a0dc:	10800060 	cmpeqi	r2,r2,1
 821a0e0:	10000e26 	beq	r2,zero,821a11c <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a0e4:	00000806 	br	821a108 <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a0e8:	01c00084 	movi	r7,2
 821a0ec:	01800044 	movi	r6,1
 821a0f0:	000b883a 	mov	r5,zero
 821a0f4:	e13ffd17 	ldw	r4,-12(fp)
 821a0f8:	82158240 	call	8215824 <OS_EventTaskRdy>
                     nbr_tasks++;
 821a0fc:	e0bff803 	ldbu	r2,-32(fp)
 821a100:	10800044 	addi	r2,r2,1
 821a104:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a108:	e0bffd17 	ldw	r2,-12(fp)
 821a10c:	10800283 	ldbu	r2,10(r2)
 821a110:	10803fcc 	andi	r2,r2,255
 821a114:	103ff41e 	bne	r2,zero,821a0e8 <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 821a118:	00000906 	br	821a140 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a11c:	01c00084 	movi	r7,2
 821a120:	01800044 	movi	r6,1
 821a124:	000b883a 	mov	r5,zero
 821a128:	e13ffd17 	ldw	r4,-12(fp)
 821a12c:	82158240 	call	8215824 <OS_EventTaskRdy>
                 nbr_tasks++;
 821a130:	e0bff803 	ldbu	r2,-32(fp)
 821a134:	10800044 	addi	r2,r2,1
 821a138:	e0bff805 	stb	r2,-32(fp)
                 break;
 821a13c:	0001883a 	nop
 821a140:	e0bff917 	ldw	r2,-28(fp)
 821a144:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a148:	e0bffa17 	ldw	r2,-24(fp)
 821a14c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a150:	82162700 	call	8216270 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821a154:	e0bfff17 	ldw	r2,-4(fp)
 821a158:	00c00384 	movi	r3,14
 821a15c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 821a160:	e0bff803 	ldbu	r2,-32(fp)
 821a164:	00000706 	br	821a184 <OSSemPendAbort+0x158>
 821a168:	e0bff917 	ldw	r2,-28(fp)
 821a16c:	e0bffb15 	stw	r2,-20(fp)
 821a170:	e0bffb17 	ldw	r2,-20(fp)
 821a174:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821a178:	e0bfff17 	ldw	r2,-4(fp)
 821a17c:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 821a180:	0005883a 	mov	r2,zero
}
 821a184:	e037883a 	mov	sp,fp
 821a188:	dfc00117 	ldw	ra,4(sp)
 821a18c:	df000017 	ldw	fp,0(sp)
 821a190:	dec00204 	addi	sp,sp,8
 821a194:	f800283a 	ret

0821a198 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 821a198:	defff804 	addi	sp,sp,-32
 821a19c:	dfc00715 	stw	ra,28(sp)
 821a1a0:	df000615 	stw	fp,24(sp)
 821a1a4:	df000604 	addi	fp,sp,24
 821a1a8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a1ac:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a1b0:	e0bfff17 	ldw	r2,-4(fp)
 821a1b4:	1000021e 	bne	r2,zero,821a1c0 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a1b8:	00800104 	movi	r2,4
 821a1bc:	00003506 	br	821a294 <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a1c0:	e0bfff17 	ldw	r2,-4(fp)
 821a1c4:	10800003 	ldbu	r2,0(r2)
 821a1c8:	10803fcc 	andi	r2,r2,255
 821a1cc:	108000e0 	cmpeqi	r2,r2,3
 821a1d0:	1000021e 	bne	r2,zero,821a1dc <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 821a1d4:	00800044 	movi	r2,1
 821a1d8:	00002e06 	br	821a294 <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a1dc:	0005303a 	rdctl	r2,status
 821a1e0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a1e4:	e0fffe17 	ldw	r3,-8(fp)
 821a1e8:	00bfff84 	movi	r2,-2
 821a1ec:	1884703a 	and	r2,r3,r2
 821a1f0:	1001703a 	wrctl	status,r2
  
  return context;
 821a1f4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821a1f8:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 821a1fc:	e0bfff17 	ldw	r2,-4(fp)
 821a200:	10800283 	ldbu	r2,10(r2)
 821a204:	10803fcc 	andi	r2,r2,255
 821a208:	10000c26 	beq	r2,zero,821a23c <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a20c:	000f883a 	mov	r7,zero
 821a210:	01800044 	movi	r6,1
 821a214:	000b883a 	mov	r5,zero
 821a218:	e13fff17 	ldw	r4,-4(fp)
 821a21c:	82158240 	call	8215824 <OS_EventTaskRdy>
 821a220:	e0bffa17 	ldw	r2,-24(fp)
 821a224:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a228:	e0bffb17 	ldw	r2,-20(fp)
 821a22c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a230:	82162700 	call	8216270 <OS_Sched>
        return (OS_ERR_NONE);
 821a234:	0005883a 	mov	r2,zero
 821a238:	00001606 	br	821a294 <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 821a23c:	e0bfff17 	ldw	r2,-4(fp)
 821a240:	1080020b 	ldhu	r2,8(r2)
 821a244:	10ffffcc 	andi	r3,r2,65535
 821a248:	00bfffd4 	movui	r2,65535
 821a24c:	18800c26 	beq	r3,r2,821a280 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 821a250:	e0bfff17 	ldw	r2,-4(fp)
 821a254:	1080020b 	ldhu	r2,8(r2)
 821a258:	10800044 	addi	r2,r2,1
 821a25c:	1007883a 	mov	r3,r2
 821a260:	e0bfff17 	ldw	r2,-4(fp)
 821a264:	10c0020d 	sth	r3,8(r2)
 821a268:	e0bffa17 	ldw	r2,-24(fp)
 821a26c:	e0bffc15 	stw	r2,-16(fp)
 821a270:	e0bffc17 	ldw	r2,-16(fp)
 821a274:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 821a278:	0005883a 	mov	r2,zero
 821a27c:	00000506 	br	821a294 <OSSemPost+0xfc>
 821a280:	e0bffa17 	ldw	r2,-24(fp)
 821a284:	e0bffd15 	stw	r2,-12(fp)
 821a288:	e0bffd17 	ldw	r2,-12(fp)
 821a28c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 821a290:	00800c84 	movi	r2,50
}
 821a294:	e037883a 	mov	sp,fp
 821a298:	dfc00117 	ldw	ra,4(sp)
 821a29c:	df000017 	ldw	fp,0(sp)
 821a2a0:	dec00204 	addi	sp,sp,8
 821a2a4:	f800283a 	ret

0821a2a8 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 821a2a8:	defff704 	addi	sp,sp,-36
 821a2ac:	df000815 	stw	fp,32(sp)
 821a2b0:	df000804 	addi	fp,sp,32
 821a2b4:	e13ffe15 	stw	r4,-8(fp)
 821a2b8:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821a2bc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 821a2c0:	e0bffe17 	ldw	r2,-8(fp)
 821a2c4:	1000021e 	bne	r2,zero,821a2d0 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a2c8:	00800104 	movi	r2,4
 821a2cc:	00003606 	br	821a3a8 <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 821a2d0:	e0bfff17 	ldw	r2,-4(fp)
 821a2d4:	1000021e 	bne	r2,zero,821a2e0 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 821a2d8:	00800244 	movi	r2,9
 821a2dc:	00003206 	br	821a3a8 <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 821a2e0:	e0bffe17 	ldw	r2,-8(fp)
 821a2e4:	10800003 	ldbu	r2,0(r2)
 821a2e8:	10803fcc 	andi	r2,r2,255
 821a2ec:	108000e0 	cmpeqi	r2,r2,3
 821a2f0:	1000021e 	bne	r2,zero,821a2fc <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 821a2f4:	00800044 	movi	r2,1
 821a2f8:	00002b06 	br	821a3a8 <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a2fc:	0005303a 	rdctl	r2,status
 821a300:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a304:	e0fffd17 	ldw	r3,-12(fp)
 821a308:	00bfff84 	movi	r2,-2
 821a30c:	1884703a 	and	r2,r3,r2
 821a310:	1001703a 	wrctl	status,r2
  
  return context;
 821a314:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821a318:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 821a31c:	e0bffe17 	ldw	r2,-8(fp)
 821a320:	10c00283 	ldbu	r3,10(r2)
 821a324:	e0bfff17 	ldw	r2,-4(fp)
 821a328:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 821a32c:	e0bffe17 	ldw	r2,-8(fp)
 821a330:	108002c4 	addi	r2,r2,11
 821a334:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 821a338:	e0bfff17 	ldw	r2,-4(fp)
 821a33c:	10800084 	addi	r2,r2,2
 821a340:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a344:	e03ffa05 	stb	zero,-24(fp)
 821a348:	00000b06 	br	821a378 <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
 821a34c:	e0bff917 	ldw	r2,-28(fp)
 821a350:	10c00044 	addi	r3,r2,1
 821a354:	e0fff915 	stw	r3,-28(fp)
 821a358:	e0fff817 	ldw	r3,-32(fp)
 821a35c:	19000044 	addi	r4,r3,1
 821a360:	e13ff815 	stw	r4,-32(fp)
 821a364:	18c00003 	ldbu	r3,0(r3)
 821a368:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a36c:	e0bffa03 	ldbu	r2,-24(fp)
 821a370:	10800044 	addi	r2,r2,1
 821a374:	e0bffa05 	stb	r2,-24(fp)
 821a378:	e0bffa03 	ldbu	r2,-24(fp)
 821a37c:	108000f0 	cmpltui	r2,r2,3
 821a380:	103ff21e 	bne	r2,zero,821a34c <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 821a384:	e0bffe17 	ldw	r2,-8(fp)
 821a388:	10c0020b 	ldhu	r3,8(r2)
 821a38c:	e0bfff17 	ldw	r2,-4(fp)
 821a390:	10c0000d 	sth	r3,0(r2)
 821a394:	e0bffb17 	ldw	r2,-20(fp)
 821a398:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a39c:	e0bffc17 	ldw	r2,-16(fp)
 821a3a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821a3a4:	0005883a 	mov	r2,zero
}
 821a3a8:	e037883a 	mov	sp,fp
 821a3ac:	df000017 	ldw	fp,0(sp)
 821a3b0:	dec00104 	addi	sp,sp,4
 821a3b4:	f800283a 	ret

0821a3b8 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 821a3b8:	defff904 	addi	sp,sp,-28
 821a3bc:	df000615 	stw	fp,24(sp)
 821a3c0:	df000604 	addi	fp,sp,24
 821a3c4:	e13ffd15 	stw	r4,-12(fp)
 821a3c8:	2805883a 	mov	r2,r5
 821a3cc:	e1bfff15 	stw	r6,-4(fp)
 821a3d0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a3d4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a3d8:	e0bfff17 	ldw	r2,-4(fp)
 821a3dc:	10003126 	beq	r2,zero,821a4a4 <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a3e0:	e0bffd17 	ldw	r2,-12(fp)
 821a3e4:	1000041e 	bne	r2,zero,821a3f8 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 821a3e8:	e0bfff17 	ldw	r2,-4(fp)
 821a3ec:	00c00104 	movi	r3,4
 821a3f0:	10c00005 	stb	r3,0(r2)
        return;
 821a3f4:	00002c06 	br	821a4a8 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a3f8:	e0bffd17 	ldw	r2,-12(fp)
 821a3fc:	10800003 	ldbu	r2,0(r2)
 821a400:	10803fcc 	andi	r2,r2,255
 821a404:	108000e0 	cmpeqi	r2,r2,3
 821a408:	1000041e 	bne	r2,zero,821a41c <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 821a40c:	e0bfff17 	ldw	r2,-4(fp)
 821a410:	00c00044 	movi	r3,1
 821a414:	10c00005 	stb	r3,0(r2)
        return;
 821a418:	00002306 	br	821a4a8 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a41c:	0005303a 	rdctl	r2,status
 821a420:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a424:	e0fffc17 	ldw	r3,-16(fp)
 821a428:	00bfff84 	movi	r2,-2
 821a42c:	1884703a 	and	r2,r3,r2
 821a430:	1001703a 	wrctl	status,r2
  
  return context;
 821a434:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a438:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 821a43c:	e0bfff17 	ldw	r2,-4(fp)
 821a440:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 821a444:	e0bffd17 	ldw	r2,-12(fp)
 821a448:	1080020b 	ldhu	r2,8(r2)
 821a44c:	10bfffcc 	andi	r2,r2,65535
 821a450:	10000426 	beq	r2,zero,821a464 <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 821a454:	e0bffd17 	ldw	r2,-12(fp)
 821a458:	e0fffe0b 	ldhu	r3,-8(fp)
 821a45c:	10c0020d 	sth	r3,8(r2)
 821a460:	00000b06 	br	821a490 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 821a464:	e0bffd17 	ldw	r2,-12(fp)
 821a468:	10800283 	ldbu	r2,10(r2)
 821a46c:	10803fcc 	andi	r2,r2,255
 821a470:	1000041e 	bne	r2,zero,821a484 <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 821a474:	e0bffd17 	ldw	r2,-12(fp)
 821a478:	e0fffe0b 	ldhu	r3,-8(fp)
 821a47c:	10c0020d 	sth	r3,8(r2)
 821a480:	00000306 	br	821a490 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 821a484:	e0bfff17 	ldw	r2,-4(fp)
 821a488:	00c01244 	movi	r3,73
 821a48c:	10c00005 	stb	r3,0(r2)
 821a490:	e0bffa17 	ldw	r2,-24(fp)
 821a494:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a498:	e0bffb17 	ldw	r2,-20(fp)
 821a49c:	1001703a 	wrctl	status,r2
 821a4a0:	00000106 	br	821a4a8 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a4a4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 821a4a8:	e037883a 	mov	sp,fp
 821a4ac:	df000017 	ldw	fp,0(sp)
 821a4b0:	dec00104 	addi	sp,sp,4
 821a4b4:	f800283a 	ret

0821a4b8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 821a4b8:	defff104 	addi	sp,sp,-60
 821a4bc:	dfc00e15 	stw	ra,56(sp)
 821a4c0:	df000d15 	stw	fp,52(sp)
 821a4c4:	df000d04 	addi	fp,sp,52
 821a4c8:	2007883a 	mov	r3,r4
 821a4cc:	2805883a 	mov	r2,r5
 821a4d0:	e0fffe05 	stb	r3,-8(fp)
 821a4d4:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 821a4d8:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 821a4dc:	e0bffe03 	ldbu	r2,-8(fp)
 821a4e0:	10800530 	cmpltui	r2,r2,20
 821a4e4:	1000051e 	bne	r2,zero,821a4fc <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 821a4e8:	e0bffe03 	ldbu	r2,-8(fp)
 821a4ec:	10803fe0 	cmpeqi	r2,r2,255
 821a4f0:	1000021e 	bne	r2,zero,821a4fc <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 821a4f4:	00800a84 	movi	r2,42
 821a4f8:	00012606 	br	821a994 <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 821a4fc:	e0bfff03 	ldbu	r2,-4(fp)
 821a500:	10800530 	cmpltui	r2,r2,20
 821a504:	1000021e 	bne	r2,zero,821a510 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 821a508:	00800a84 	movi	r2,42
 821a50c:	00012106 	br	821a994 <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a510:	0005303a 	rdctl	r2,status
 821a514:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a518:	e0fffd17 	ldw	r3,-12(fp)
 821a51c:	00bfff84 	movi	r2,-2
 821a520:	1884703a 	and	r2,r3,r2
 821a524:	1001703a 	wrctl	status,r2
  
  return context;
 821a528:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821a52c:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 821a530:	e0ffff03 	ldbu	r3,-4(fp)
 821a534:	008209b4 	movhi	r2,2086
 821a538:	10b5c804 	addi	r2,r2,-10464
 821a53c:	18c7883a 	add	r3,r3,r3
 821a540:	18c7883a 	add	r3,r3,r3
 821a544:	10c5883a 	add	r2,r2,r3
 821a548:	10800017 	ldw	r2,0(r2)
 821a54c:	10000626 	beq	r2,zero,821a568 <OSTaskChangePrio+0xb0>
 821a550:	e0bff517 	ldw	r2,-44(fp)
 821a554:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a558:	e0bff617 	ldw	r2,-40(fp)
 821a55c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 821a560:	00800a04 	movi	r2,40
 821a564:	00010b06 	br	821a994 <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 821a568:	e0bffe03 	ldbu	r2,-8(fp)
 821a56c:	10803fd8 	cmpnei	r2,r2,255
 821a570:	1000031e 	bne	r2,zero,821a580 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 821a574:	d0a07a17 	ldw	r2,-32280(gp)
 821a578:	10800c83 	ldbu	r2,50(r2)
 821a57c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 821a580:	e0fffe03 	ldbu	r3,-8(fp)
 821a584:	008209b4 	movhi	r2,2086
 821a588:	10b5c804 	addi	r2,r2,-10464
 821a58c:	18c7883a 	add	r3,r3,r3
 821a590:	18c7883a 	add	r3,r3,r3
 821a594:	10c5883a 	add	r2,r2,r3
 821a598:	10800017 	ldw	r2,0(r2)
 821a59c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 821a5a0:	e0bff817 	ldw	r2,-32(fp)
 821a5a4:	1000061e 	bne	r2,zero,821a5c0 <OSTaskChangePrio+0x108>
 821a5a8:	e0bff517 	ldw	r2,-44(fp)
 821a5ac:	e0bff715 	stw	r2,-36(fp)
 821a5b0:	e0bff717 	ldw	r2,-36(fp)
 821a5b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 821a5b8:	00800a44 	movi	r2,41
 821a5bc:	0000f506 	br	821a994 <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 821a5c0:	e0bff817 	ldw	r2,-32(fp)
 821a5c4:	10800058 	cmpnei	r2,r2,1
 821a5c8:	1000061e 	bne	r2,zero,821a5e4 <OSTaskChangePrio+0x12c>
 821a5cc:	e0bff517 	ldw	r2,-44(fp)
 821a5d0:	e0bff915 	stw	r2,-28(fp)
 821a5d4:	e0bff917 	ldw	r2,-28(fp)
 821a5d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 821a5dc:	008010c4 	movi	r2,67
 821a5e0:	0000ec06 	br	821a994 <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 821a5e4:	e0bfff03 	ldbu	r2,-4(fp)
 821a5e8:	1004d0fa 	srli	r2,r2,3
 821a5ec:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 821a5f0:	e0bfff03 	ldbu	r2,-4(fp)
 821a5f4:	108001cc 	andi	r2,r2,7
 821a5f8:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
 821a5fc:	e0bffb03 	ldbu	r2,-20(fp)
 821a600:	00c00044 	movi	r3,1
 821a604:	1884983a 	sll	r2,r3,r2
 821a608:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
 821a60c:	e0bffb43 	ldbu	r2,-19(fp)
 821a610:	00c00044 	movi	r3,1
 821a614:	1884983a 	sll	r2,r3,r2
 821a618:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 821a61c:	e0fffe03 	ldbu	r3,-8(fp)
 821a620:	008209b4 	movhi	r2,2086
 821a624:	10b5c804 	addi	r2,r2,-10464
 821a628:	18c7883a 	add	r3,r3,r3
 821a62c:	18c7883a 	add	r3,r3,r3
 821a630:	10c5883a 	add	r2,r2,r3
 821a634:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 821a638:	e0ffff03 	ldbu	r3,-4(fp)
 821a63c:	008209b4 	movhi	r2,2086
 821a640:	10b5c804 	addi	r2,r2,-10464
 821a644:	18c7883a 	add	r3,r3,r3
 821a648:	18c7883a 	add	r3,r3,r3
 821a64c:	10c5883a 	add	r2,r2,r3
 821a650:	e0fff817 	ldw	r3,-32(fp)
 821a654:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 821a658:	e0bff817 	ldw	r2,-32(fp)
 821a65c:	10800d03 	ldbu	r2,52(r2)
 821a660:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
 821a664:	e0bff817 	ldw	r2,-32(fp)
 821a668:	10800d83 	ldbu	r2,54(r2)
 821a66c:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 821a670:	e0bff817 	ldw	r2,-32(fp)
 821a674:	10800d43 	ldbu	r2,53(r2)
 821a678:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 821a67c:	e0fffc03 	ldbu	r3,-16(fp)
 821a680:	d0a07744 	addi	r2,gp,-32291
 821a684:	1885883a 	add	r2,r3,r2
 821a688:	10c00003 	ldbu	r3,0(r2)
 821a68c:	e0bffc83 	ldbu	r2,-14(fp)
 821a690:	1884703a 	and	r2,r3,r2
 821a694:	10803fcc 	andi	r2,r2,255
 821a698:	10002826 	beq	r2,zero,821a73c <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
 821a69c:	e0fffc03 	ldbu	r3,-16(fp)
 821a6a0:	e13ffc03 	ldbu	r4,-16(fp)
 821a6a4:	d0a07744 	addi	r2,gp,-32291
 821a6a8:	2085883a 	add	r2,r4,r2
 821a6ac:	10800003 	ldbu	r2,0(r2)
 821a6b0:	1009883a 	mov	r4,r2
 821a6b4:	e0bffc83 	ldbu	r2,-14(fp)
 821a6b8:	0084303a 	nor	r2,zero,r2
 821a6bc:	2084703a 	and	r2,r4,r2
 821a6c0:	1009883a 	mov	r4,r2
 821a6c4:	d0a07744 	addi	r2,gp,-32291
 821a6c8:	1885883a 	add	r2,r3,r2
 821a6cc:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 821a6d0:	e0fffc03 	ldbu	r3,-16(fp)
 821a6d4:	d0a07744 	addi	r2,gp,-32291
 821a6d8:	1885883a 	add	r2,r3,r2
 821a6dc:	10800003 	ldbu	r2,0(r2)
 821a6e0:	10803fcc 	andi	r2,r2,255
 821a6e4:	1000061e 	bne	r2,zero,821a700 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
 821a6e8:	e0bffc43 	ldbu	r2,-15(fp)
 821a6ec:	0084303a 	nor	r2,zero,r2
 821a6f0:	1007883a 	mov	r3,r2
 821a6f4:	d0a07703 	ldbu	r2,-32292(gp)
 821a6f8:	1884703a 	and	r2,r3,r2
 821a6fc:	d0a07705 	stb	r2,-32292(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 821a700:	d0e07703 	ldbu	r3,-32292(gp)
 821a704:	e0bffb83 	ldbu	r2,-18(fp)
 821a708:	1884b03a 	or	r2,r3,r2
 821a70c:	d0a07705 	stb	r2,-32292(gp)
         OSRdyTbl[y_new] |= bitx_new;
 821a710:	e0fffb03 	ldbu	r3,-20(fp)
 821a714:	e13ffb03 	ldbu	r4,-20(fp)
 821a718:	d0a07744 	addi	r2,gp,-32291
 821a71c:	2085883a 	add	r2,r4,r2
 821a720:	11000003 	ldbu	r4,0(r2)
 821a724:	e0bffbc3 	ldbu	r2,-17(fp)
 821a728:	2084b03a 	or	r2,r4,r2
 821a72c:	1009883a 	mov	r4,r2
 821a730:	d0a07744 	addi	r2,gp,-32291
 821a734:	1885883a 	add	r2,r3,r2
 821a738:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 821a73c:	e0bff817 	ldw	r2,-32(fp)
 821a740:	10800717 	ldw	r2,28(r2)
 821a744:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 821a748:	e0bff317 	ldw	r2,-52(fp)
 821a74c:	10003326 	beq	r2,zero,821a81c <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 821a750:	e0bffc03 	ldbu	r2,-16(fp)
 821a754:	e0fffc03 	ldbu	r3,-16(fp)
 821a758:	e13ff317 	ldw	r4,-52(fp)
 821a75c:	20c7883a 	add	r3,r4,r3
 821a760:	18c002c4 	addi	r3,r3,11
 821a764:	18c00003 	ldbu	r3,0(r3)
 821a768:	1809883a 	mov	r4,r3
 821a76c:	e0fffc83 	ldbu	r3,-14(fp)
 821a770:	00c6303a 	nor	r3,zero,r3
 821a774:	20c6703a 	and	r3,r4,r3
 821a778:	1809883a 	mov	r4,r3
 821a77c:	e0fff317 	ldw	r3,-52(fp)
 821a780:	1885883a 	add	r2,r3,r2
 821a784:	108002c4 	addi	r2,r2,11
 821a788:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 821a78c:	e0bffc03 	ldbu	r2,-16(fp)
 821a790:	e0fff317 	ldw	r3,-52(fp)
 821a794:	1885883a 	add	r2,r3,r2
 821a798:	108002c4 	addi	r2,r2,11
 821a79c:	10800003 	ldbu	r2,0(r2)
 821a7a0:	10803fcc 	andi	r2,r2,255
 821a7a4:	1000091e 	bne	r2,zero,821a7cc <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
 821a7a8:	e0bff317 	ldw	r2,-52(fp)
 821a7ac:	10800283 	ldbu	r2,10(r2)
 821a7b0:	1007883a 	mov	r3,r2
 821a7b4:	e0bffc43 	ldbu	r2,-15(fp)
 821a7b8:	0084303a 	nor	r2,zero,r2
 821a7bc:	1884703a 	and	r2,r3,r2
 821a7c0:	1007883a 	mov	r3,r2
 821a7c4:	e0bff317 	ldw	r2,-52(fp)
 821a7c8:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 821a7cc:	e0bff317 	ldw	r2,-52(fp)
 821a7d0:	10c00283 	ldbu	r3,10(r2)
 821a7d4:	e0bffb83 	ldbu	r2,-18(fp)
 821a7d8:	1884b03a 	or	r2,r3,r2
 821a7dc:	1007883a 	mov	r3,r2
 821a7e0:	e0bff317 	ldw	r2,-52(fp)
 821a7e4:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 821a7e8:	e0bffb03 	ldbu	r2,-20(fp)
 821a7ec:	e0fffb03 	ldbu	r3,-20(fp)
 821a7f0:	e13ff317 	ldw	r4,-52(fp)
 821a7f4:	20c7883a 	add	r3,r4,r3
 821a7f8:	18c002c4 	addi	r3,r3,11
 821a7fc:	19000003 	ldbu	r4,0(r3)
 821a800:	e0fffbc3 	ldbu	r3,-17(fp)
 821a804:	20c6b03a 	or	r3,r4,r3
 821a808:	1809883a 	mov	r4,r3
 821a80c:	e0fff317 	ldw	r3,-52(fp)
 821a810:	1885883a 	add	r2,r3,r2
 821a814:	108002c4 	addi	r2,r2,11
 821a818:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 821a81c:	e0bff817 	ldw	r2,-32(fp)
 821a820:	10800817 	ldw	r2,32(r2)
 821a824:	10004226 	beq	r2,zero,821a930 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
 821a828:	e0bff817 	ldw	r2,-32(fp)
 821a82c:	10800817 	ldw	r2,32(r2)
 821a830:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 821a834:	e0bff417 	ldw	r2,-48(fp)
 821a838:	10800017 	ldw	r2,0(r2)
 821a83c:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 821a840:	00003906 	br	821a928 <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 821a844:	e0bffc03 	ldbu	r2,-16(fp)
 821a848:	e0fffc03 	ldbu	r3,-16(fp)
 821a84c:	e13ff317 	ldw	r4,-52(fp)
 821a850:	20c7883a 	add	r3,r4,r3
 821a854:	18c002c4 	addi	r3,r3,11
 821a858:	18c00003 	ldbu	r3,0(r3)
 821a85c:	1809883a 	mov	r4,r3
 821a860:	e0fffc83 	ldbu	r3,-14(fp)
 821a864:	00c6303a 	nor	r3,zero,r3
 821a868:	20c6703a 	and	r3,r4,r3
 821a86c:	1809883a 	mov	r4,r3
 821a870:	e0fff317 	ldw	r3,-52(fp)
 821a874:	1885883a 	add	r2,r3,r2
 821a878:	108002c4 	addi	r2,r2,11
 821a87c:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 821a880:	e0bffc03 	ldbu	r2,-16(fp)
 821a884:	e0fff317 	ldw	r3,-52(fp)
 821a888:	1885883a 	add	r2,r3,r2
 821a88c:	108002c4 	addi	r2,r2,11
 821a890:	10800003 	ldbu	r2,0(r2)
 821a894:	10803fcc 	andi	r2,r2,255
 821a898:	1000091e 	bne	r2,zero,821a8c0 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
 821a89c:	e0bff317 	ldw	r2,-52(fp)
 821a8a0:	10800283 	ldbu	r2,10(r2)
 821a8a4:	1007883a 	mov	r3,r2
 821a8a8:	e0bffc43 	ldbu	r2,-15(fp)
 821a8ac:	0084303a 	nor	r2,zero,r2
 821a8b0:	1884703a 	and	r2,r3,r2
 821a8b4:	1007883a 	mov	r3,r2
 821a8b8:	e0bff317 	ldw	r2,-52(fp)
 821a8bc:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 821a8c0:	e0bff317 	ldw	r2,-52(fp)
 821a8c4:	10c00283 	ldbu	r3,10(r2)
 821a8c8:	e0bffb83 	ldbu	r2,-18(fp)
 821a8cc:	1884b03a 	or	r2,r3,r2
 821a8d0:	1007883a 	mov	r3,r2
 821a8d4:	e0bff317 	ldw	r2,-52(fp)
 821a8d8:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 821a8dc:	e0bffb03 	ldbu	r2,-20(fp)
 821a8e0:	e0fffb03 	ldbu	r3,-20(fp)
 821a8e4:	e13ff317 	ldw	r4,-52(fp)
 821a8e8:	20c7883a 	add	r3,r4,r3
 821a8ec:	18c002c4 	addi	r3,r3,11
 821a8f0:	19000003 	ldbu	r4,0(r3)
 821a8f4:	e0fffbc3 	ldbu	r3,-17(fp)
 821a8f8:	20c6b03a 	or	r3,r4,r3
 821a8fc:	1809883a 	mov	r4,r3
 821a900:	e0fff317 	ldw	r3,-52(fp)
 821a904:	1885883a 	add	r2,r3,r2
 821a908:	108002c4 	addi	r2,r2,11
 821a90c:	11000005 	stb	r4,0(r2)
            pevents++;
 821a910:	e0bff417 	ldw	r2,-48(fp)
 821a914:	10800104 	addi	r2,r2,4
 821a918:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 821a91c:	e0bff417 	ldw	r2,-48(fp)
 821a920:	10800017 	ldw	r2,0(r2)
 821a924:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 821a928:	e0bff317 	ldw	r2,-52(fp)
 821a92c:	103fc51e 	bne	r2,zero,821a844 <OSTaskChangePrio+0x38c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 821a930:	e0bff817 	ldw	r2,-32(fp)
 821a934:	e0ffff03 	ldbu	r3,-4(fp)
 821a938:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 821a93c:	e0bff817 	ldw	r2,-32(fp)
 821a940:	e0fffb03 	ldbu	r3,-20(fp)
 821a944:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 821a948:	e0bff817 	ldw	r2,-32(fp)
 821a94c:	e0fffb43 	ldbu	r3,-19(fp)
 821a950:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 821a954:	e0bff817 	ldw	r2,-32(fp)
 821a958:	e0fffb83 	ldbu	r3,-18(fp)
 821a95c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 821a960:	e0bff817 	ldw	r2,-32(fp)
 821a964:	e0fffbc3 	ldbu	r3,-17(fp)
 821a968:	10c00d45 	stb	r3,53(r2)
 821a96c:	e0bff517 	ldw	r2,-44(fp)
 821a970:	e0bffa15 	stw	r2,-24(fp)
 821a974:	e0bffa17 	ldw	r2,-24(fp)
 821a978:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821a97c:	d0a06b43 	ldbu	r2,-32339(gp)
 821a980:	10803fcc 	andi	r2,r2,255
 821a984:	10800058 	cmpnei	r2,r2,1
 821a988:	1000011e 	bne	r2,zero,821a990 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
 821a98c:	82162700 	call	8216270 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821a990:	0005883a 	mov	r2,zero
}
 821a994:	e037883a 	mov	sp,fp
 821a998:	dfc00117 	ldw	ra,4(sp)
 821a99c:	df000017 	ldw	fp,0(sp)
 821a9a0:	dec00204 	addi	sp,sp,8
 821a9a4:	f800283a 	ret

0821a9a8 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 821a9a8:	deffee04 	addi	sp,sp,-72
 821a9ac:	dfc01115 	stw	ra,68(sp)
 821a9b0:	df001015 	stw	fp,64(sp)
 821a9b4:	df001004 	addi	fp,sp,64
 821a9b8:	e13ffc15 	stw	r4,-16(fp)
 821a9bc:	e17ffd15 	stw	r5,-12(fp)
 821a9c0:	e1bffe15 	stw	r6,-8(fp)
 821a9c4:	3805883a 	mov	r2,r7
 821a9c8:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821a9cc:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821a9d0:	e0bfff03 	ldbu	r2,-4(fp)
 821a9d4:	10800570 	cmpltui	r2,r2,21
 821a9d8:	1000021e 	bne	r2,zero,821a9e4 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 821a9dc:	00800a84 	movi	r2,42
 821a9e0:	00005706 	br	821ab40 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a9e4:	0005303a 	rdctl	r2,status
 821a9e8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a9ec:	e0fffb17 	ldw	r3,-20(fp)
 821a9f0:	00bfff84 	movi	r2,-2
 821a9f4:	1884703a 	and	r2,r3,r2
 821a9f8:	1001703a 	wrctl	status,r2
  
  return context;
 821a9fc:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821aa00:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821aa04:	d0a07903 	ldbu	r2,-32284(gp)
 821aa08:	10803fcc 	andi	r2,r2,255
 821aa0c:	10000626 	beq	r2,zero,821aa28 <OSTaskCreate+0x80>
 821aa10:	e0bff317 	ldw	r2,-52(fp)
 821aa14:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821aa18:	e0bff417 	ldw	r2,-48(fp)
 821aa1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821aa20:	00800f04 	movi	r2,60
 821aa24:	00004606 	br	821ab40 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821aa28:	e0ffff03 	ldbu	r3,-4(fp)
 821aa2c:	008209b4 	movhi	r2,2086
 821aa30:	10b5c804 	addi	r2,r2,-10464
 821aa34:	18c7883a 	add	r3,r3,r3
 821aa38:	18c7883a 	add	r3,r3,r3
 821aa3c:	10c5883a 	add	r2,r2,r3
 821aa40:	10800017 	ldw	r2,0(r2)
 821aa44:	1000391e 	bne	r2,zero,821ab2c <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821aa48:	e0ffff03 	ldbu	r3,-4(fp)
 821aa4c:	008209b4 	movhi	r2,2086
 821aa50:	10b5c804 	addi	r2,r2,-10464
 821aa54:	18c7883a 	add	r3,r3,r3
 821aa58:	18c7883a 	add	r3,r3,r3
 821aa5c:	10c5883a 	add	r2,r2,r3
 821aa60:	00c00044 	movi	r3,1
 821aa64:	10c00015 	stw	r3,0(r2)
 821aa68:	e0bff317 	ldw	r2,-52(fp)
 821aa6c:	e0bff515 	stw	r2,-44(fp)
 821aa70:	e0bff517 	ldw	r2,-44(fp)
 821aa74:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 821aa78:	000f883a 	mov	r7,zero
 821aa7c:	e1bffe17 	ldw	r6,-8(fp)
 821aa80:	e17ffd17 	ldw	r5,-12(fp)
 821aa84:	e13ffc17 	ldw	r4,-16(fp)
 821aa88:	823cad00 	call	823cad0 <OSTaskStkInit>
 821aa8c:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 821aa90:	e0bfff03 	ldbu	r2,-4(fp)
 821aa94:	d8000215 	stw	zero,8(sp)
 821aa98:	d8000115 	stw	zero,4(sp)
 821aa9c:	d8000015 	stw	zero,0(sp)
 821aaa0:	000f883a 	mov	r7,zero
 821aaa4:	000d883a 	mov	r6,zero
 821aaa8:	e17ff717 	ldw	r5,-36(fp)
 821aaac:	1009883a 	mov	r4,r2
 821aab0:	82166880 	call	8216688 <OS_TCBInit>
 821aab4:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
 821aab8:	e0bff803 	ldbu	r2,-32(fp)
 821aabc:	1000061e 	bne	r2,zero,821aad8 <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 821aac0:	d0a06b43 	ldbu	r2,-32339(gp)
 821aac4:	10803fcc 	andi	r2,r2,255
 821aac8:	10800058 	cmpnei	r2,r2,1
 821aacc:	1000151e 	bne	r2,zero,821ab24 <OSTaskCreate+0x17c>
                OS_Sched();
 821aad0:	82162700 	call	8216270 <OS_Sched>
 821aad4:	00001306 	br	821ab24 <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821aad8:	0005303a 	rdctl	r2,status
 821aadc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821aae0:	e0fffa17 	ldw	r3,-24(fp)
 821aae4:	00bfff84 	movi	r2,-2
 821aae8:	1884703a 	and	r2,r3,r2
 821aaec:	1001703a 	wrctl	status,r2
  
  return context;
 821aaf0:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821aaf4:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 821aaf8:	e0ffff03 	ldbu	r3,-4(fp)
 821aafc:	008209b4 	movhi	r2,2086
 821ab00:	10b5c804 	addi	r2,r2,-10464
 821ab04:	18c7883a 	add	r3,r3,r3
 821ab08:	18c7883a 	add	r3,r3,r3
 821ab0c:	10c5883a 	add	r2,r2,r3
 821ab10:	10000015 	stw	zero,0(r2)
 821ab14:	e0bff317 	ldw	r2,-52(fp)
 821ab18:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ab1c:	e0bff617 	ldw	r2,-40(fp)
 821ab20:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821ab24:	e0bff803 	ldbu	r2,-32(fp)
 821ab28:	00000506 	br	821ab40 <OSTaskCreate+0x198>
 821ab2c:	e0bff317 	ldw	r2,-52(fp)
 821ab30:	e0bff915 	stw	r2,-28(fp)
 821ab34:	e0bff917 	ldw	r2,-28(fp)
 821ab38:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821ab3c:	00800a04 	movi	r2,40
}
 821ab40:	e037883a 	mov	sp,fp
 821ab44:	dfc00117 	ldw	ra,4(sp)
 821ab48:	df000017 	ldw	fp,0(sp)
 821ab4c:	dec00204 	addi	sp,sp,8
 821ab50:	f800283a 	ret

0821ab54 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 821ab54:	deffec04 	addi	sp,sp,-80
 821ab58:	dfc01315 	stw	ra,76(sp)
 821ab5c:	df001215 	stw	fp,72(sp)
 821ab60:	df001204 	addi	fp,sp,72
 821ab64:	e13ffa15 	stw	r4,-24(fp)
 821ab68:	e17ffb15 	stw	r5,-20(fp)
 821ab6c:	e1bffc15 	stw	r6,-16(fp)
 821ab70:	3809883a 	mov	r4,r7
 821ab74:	e0c00217 	ldw	r3,8(fp)
 821ab78:	e0800617 	ldw	r2,24(fp)
 821ab7c:	e13ffd05 	stb	r4,-12(fp)
 821ab80:	e0fffe0d 	sth	r3,-8(fp)
 821ab84:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821ab88:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821ab8c:	e0bffd03 	ldbu	r2,-12(fp)
 821ab90:	10800570 	cmpltui	r2,r2,21
 821ab94:	1000021e 	bne	r2,zero,821aba0 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 821ab98:	00800a84 	movi	r2,42
 821ab9c:	00006106 	br	821ad24 <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821aba0:	0005303a 	rdctl	r2,status
 821aba4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821aba8:	e0fff917 	ldw	r3,-28(fp)
 821abac:	00bfff84 	movi	r2,-2
 821abb0:	1884703a 	and	r2,r3,r2
 821abb4:	1001703a 	wrctl	status,r2
  
  return context;
 821abb8:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821abbc:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821abc0:	d0a07903 	ldbu	r2,-32284(gp)
 821abc4:	10803fcc 	andi	r2,r2,255
 821abc8:	10000626 	beq	r2,zero,821abe4 <OSTaskCreateExt+0x90>
 821abcc:	e0bff117 	ldw	r2,-60(fp)
 821abd0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821abd4:	e0bff217 	ldw	r2,-56(fp)
 821abd8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821abdc:	00800f04 	movi	r2,60
 821abe0:	00005006 	br	821ad24 <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821abe4:	e0fffd03 	ldbu	r3,-12(fp)
 821abe8:	008209b4 	movhi	r2,2086
 821abec:	10b5c804 	addi	r2,r2,-10464
 821abf0:	18c7883a 	add	r3,r3,r3
 821abf4:	18c7883a 	add	r3,r3,r3
 821abf8:	10c5883a 	add	r2,r2,r3
 821abfc:	10800017 	ldw	r2,0(r2)
 821ac00:	1000431e 	bne	r2,zero,821ad10 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821ac04:	e0fffd03 	ldbu	r3,-12(fp)
 821ac08:	008209b4 	movhi	r2,2086
 821ac0c:	10b5c804 	addi	r2,r2,-10464
 821ac10:	18c7883a 	add	r3,r3,r3
 821ac14:	18c7883a 	add	r3,r3,r3
 821ac18:	10c5883a 	add	r2,r2,r3
 821ac1c:	00c00044 	movi	r3,1
 821ac20:	10c00015 	stw	r3,0(r2)
 821ac24:	e0bff117 	ldw	r2,-60(fp)
 821ac28:	e0bff315 	stw	r2,-52(fp)
 821ac2c:	e0bff317 	ldw	r2,-52(fp)
 821ac30:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 821ac34:	e0bfff0b 	ldhu	r2,-4(fp)
 821ac38:	100d883a 	mov	r6,r2
 821ac3c:	e1400417 	ldw	r5,16(fp)
 821ac40:	e1000317 	ldw	r4,12(fp)
 821ac44:	821bbb40 	call	821bbb4 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 821ac48:	e0bfff0b 	ldhu	r2,-4(fp)
 821ac4c:	100f883a 	mov	r7,r2
 821ac50:	e1bffc17 	ldw	r6,-16(fp)
 821ac54:	e17ffb17 	ldw	r5,-20(fp)
 821ac58:	e13ffa17 	ldw	r4,-24(fp)
 821ac5c:	823cad00 	call	823cad0 <OSTaskStkInit>
 821ac60:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 821ac64:	e0fffd03 	ldbu	r3,-12(fp)
 821ac68:	e13ffe0b 	ldhu	r4,-8(fp)
 821ac6c:	e0bfff0b 	ldhu	r2,-4(fp)
 821ac70:	d8800215 	stw	r2,8(sp)
 821ac74:	e0800517 	ldw	r2,20(fp)
 821ac78:	d8800115 	stw	r2,4(sp)
 821ac7c:	e0800417 	ldw	r2,16(fp)
 821ac80:	d8800015 	stw	r2,0(sp)
 821ac84:	200f883a 	mov	r7,r4
 821ac88:	e1800317 	ldw	r6,12(fp)
 821ac8c:	e17ff517 	ldw	r5,-44(fp)
 821ac90:	1809883a 	mov	r4,r3
 821ac94:	82166880 	call	8216688 <OS_TCBInit>
 821ac98:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
 821ac9c:	e0bff603 	ldbu	r2,-40(fp)
 821aca0:	1000061e 	bne	r2,zero,821acbc <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 821aca4:	d0a06b43 	ldbu	r2,-32339(gp)
 821aca8:	10803fcc 	andi	r2,r2,255
 821acac:	10800058 	cmpnei	r2,r2,1
 821acb0:	1000151e 	bne	r2,zero,821ad08 <OSTaskCreateExt+0x1b4>
                OS_Sched();
 821acb4:	82162700 	call	8216270 <OS_Sched>
 821acb8:	00001306 	br	821ad08 <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821acbc:	0005303a 	rdctl	r2,status
 821acc0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821acc4:	e0fff817 	ldw	r3,-32(fp)
 821acc8:	00bfff84 	movi	r2,-2
 821accc:	1884703a 	and	r2,r3,r2
 821acd0:	1001703a 	wrctl	status,r2
  
  return context;
 821acd4:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821acd8:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 821acdc:	e0fffd03 	ldbu	r3,-12(fp)
 821ace0:	008209b4 	movhi	r2,2086
 821ace4:	10b5c804 	addi	r2,r2,-10464
 821ace8:	18c7883a 	add	r3,r3,r3
 821acec:	18c7883a 	add	r3,r3,r3
 821acf0:	10c5883a 	add	r2,r2,r3
 821acf4:	10000015 	stw	zero,0(r2)
 821acf8:	e0bff117 	ldw	r2,-60(fp)
 821acfc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ad00:	e0bff417 	ldw	r2,-48(fp)
 821ad04:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821ad08:	e0bff603 	ldbu	r2,-40(fp)
 821ad0c:	00000506 	br	821ad24 <OSTaskCreateExt+0x1d0>
 821ad10:	e0bff117 	ldw	r2,-60(fp)
 821ad14:	e0bff715 	stw	r2,-36(fp)
 821ad18:	e0bff717 	ldw	r2,-36(fp)
 821ad1c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821ad20:	00800a04 	movi	r2,40
}
 821ad24:	e037883a 	mov	sp,fp
 821ad28:	dfc00117 	ldw	ra,4(sp)
 821ad2c:	df000017 	ldw	fp,0(sp)
 821ad30:	dec00204 	addi	sp,sp,8
 821ad34:	f800283a 	ret

0821ad38 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 821ad38:	defff404 	addi	sp,sp,-48
 821ad3c:	dfc00b15 	stw	ra,44(sp)
 821ad40:	df000a15 	stw	fp,40(sp)
 821ad44:	df000a04 	addi	fp,sp,40
 821ad48:	2005883a 	mov	r2,r4
 821ad4c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 821ad50:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 821ad54:	d0a07903 	ldbu	r2,-32284(gp)
 821ad58:	10803fcc 	andi	r2,r2,255
 821ad5c:	10000226 	beq	r2,zero,821ad68 <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
 821ad60:	00801004 	movi	r2,64
 821ad64:	0000c006 	br	821b068 <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 821ad68:	e0bfff03 	ldbu	r2,-4(fp)
 821ad6c:	10800518 	cmpnei	r2,r2,20
 821ad70:	1000021e 	bne	r2,zero,821ad7c <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
 821ad74:	00800f84 	movi	r2,62
 821ad78:	0000bb06 	br	821b068 <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 821ad7c:	e0bfff03 	ldbu	r2,-4(fp)
 821ad80:	10800530 	cmpltui	r2,r2,20
 821ad84:	1000051e 	bne	r2,zero,821ad9c <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
 821ad88:	e0bfff03 	ldbu	r2,-4(fp)
 821ad8c:	10803fe0 	cmpeqi	r2,r2,255
 821ad90:	1000021e 	bne	r2,zero,821ad9c <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
 821ad94:	00800a84 	movi	r2,42
 821ad98:	0000b306 	br	821b068 <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ad9c:	0005303a 	rdctl	r2,status
 821ada0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ada4:	e0fffe17 	ldw	r3,-8(fp)
 821ada8:	00bfff84 	movi	r2,-2
 821adac:	1884703a 	and	r2,r3,r2
 821adb0:	1001703a 	wrctl	status,r2
  
  return context;
 821adb4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 821adb8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 821adbc:	e0bfff03 	ldbu	r2,-4(fp)
 821adc0:	10803fd8 	cmpnei	r2,r2,255
 821adc4:	1000031e 	bne	r2,zero,821add4 <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 821adc8:	d0a07a17 	ldw	r2,-32280(gp)
 821adcc:	10800c83 	ldbu	r2,50(r2)
 821add0:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821add4:	e0ffff03 	ldbu	r3,-4(fp)
 821add8:	008209b4 	movhi	r2,2086
 821addc:	10b5c804 	addi	r2,r2,-10464
 821ade0:	18c7883a 	add	r3,r3,r3
 821ade4:	18c7883a 	add	r3,r3,r3
 821ade8:	10c5883a 	add	r2,r2,r3
 821adec:	10800017 	ldw	r2,0(r2)
 821adf0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 821adf4:	e0bff817 	ldw	r2,-32(fp)
 821adf8:	1000061e 	bne	r2,zero,821ae14 <OSTaskDel+0xdc>
 821adfc:	e0bff617 	ldw	r2,-40(fp)
 821ae00:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ae04:	e0bff717 	ldw	r2,-36(fp)
 821ae08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821ae0c:	008010c4 	movi	r2,67
 821ae10:	00009506 	br	821b068 <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 821ae14:	e0bff817 	ldw	r2,-32(fp)
 821ae18:	10800058 	cmpnei	r2,r2,1
 821ae1c:	1000061e 	bne	r2,zero,821ae38 <OSTaskDel+0x100>
 821ae20:	e0bff617 	ldw	r2,-40(fp)
 821ae24:	e0bff915 	stw	r2,-28(fp)
 821ae28:	e0bff917 	ldw	r2,-28(fp)
 821ae2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821ae30:	00800f44 	movi	r2,61
 821ae34:	00008c06 	br	821b068 <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 821ae38:	e0bff817 	ldw	r2,-32(fp)
 821ae3c:	10800d03 	ldbu	r2,52(r2)
 821ae40:	10c03fcc 	andi	r3,r2,255
 821ae44:	e0bff817 	ldw	r2,-32(fp)
 821ae48:	10800d03 	ldbu	r2,52(r2)
 821ae4c:	11003fcc 	andi	r4,r2,255
 821ae50:	d0a07744 	addi	r2,gp,-32291
 821ae54:	2085883a 	add	r2,r4,r2
 821ae58:	10800003 	ldbu	r2,0(r2)
 821ae5c:	1009883a 	mov	r4,r2
 821ae60:	e0bff817 	ldw	r2,-32(fp)
 821ae64:	10800d43 	ldbu	r2,53(r2)
 821ae68:	0084303a 	nor	r2,zero,r2
 821ae6c:	2084703a 	and	r2,r4,r2
 821ae70:	1009883a 	mov	r4,r2
 821ae74:	d0a07744 	addi	r2,gp,-32291
 821ae78:	1885883a 	add	r2,r3,r2
 821ae7c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 821ae80:	e0bff817 	ldw	r2,-32(fp)
 821ae84:	10800d03 	ldbu	r2,52(r2)
 821ae88:	10c03fcc 	andi	r3,r2,255
 821ae8c:	d0a07744 	addi	r2,gp,-32291
 821ae90:	1885883a 	add	r2,r3,r2
 821ae94:	10800003 	ldbu	r2,0(r2)
 821ae98:	10803fcc 	andi	r2,r2,255
 821ae9c:	1000071e 	bne	r2,zero,821aebc <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 821aea0:	e0bff817 	ldw	r2,-32(fp)
 821aea4:	10800d83 	ldbu	r2,54(r2)
 821aea8:	0084303a 	nor	r2,zero,r2
 821aeac:	1007883a 	mov	r3,r2
 821aeb0:	d0a07703 	ldbu	r2,-32292(gp)
 821aeb4:	1884703a 	and	r2,r3,r2
 821aeb8:	d0a07705 	stb	r2,-32292(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 821aebc:	e0bff817 	ldw	r2,-32(fp)
 821aec0:	10800717 	ldw	r2,28(r2)
 821aec4:	10000526 	beq	r2,zero,821aedc <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 821aec8:	e0bff817 	ldw	r2,-32(fp)
 821aecc:	10800717 	ldw	r2,28(r2)
 821aed0:	100b883a 	mov	r5,r2
 821aed4:	e13ff817 	ldw	r4,-32(fp)
 821aed8:	8215c1c0 	call	8215c1c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 821aedc:	e0bff817 	ldw	r2,-32(fp)
 821aee0:	10800817 	ldw	r2,32(r2)
 821aee4:	10000526 	beq	r2,zero,821aefc <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 821aee8:	e0bff817 	ldw	r2,-32(fp)
 821aeec:	10800817 	ldw	r2,32(r2)
 821aef0:	100b883a 	mov	r5,r2
 821aef4:	e13ff817 	ldw	r4,-32(fp)
 821aef8:	8215cd40 	call	8215cd4 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 821aefc:	e0bff817 	ldw	r2,-32(fp)
 821af00:	10800a17 	ldw	r2,40(r2)
 821af04:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 821af08:	e0bffb17 	ldw	r2,-20(fp)
 821af0c:	10000226 	beq	r2,zero,821af18 <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 821af10:	e13ffb17 	ldw	r4,-20(fp)
 821af14:	821815c0 	call	821815c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 821af18:	e0bff817 	ldw	r2,-32(fp)
 821af1c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 821af20:	e0bff817 	ldw	r2,-32(fp)
 821af24:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 821af28:	e0bff817 	ldw	r2,-32(fp)
 821af2c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 821af30:	d0a06b03 	ldbu	r2,-32340(gp)
 821af34:	10803fcc 	andi	r2,r2,255
 821af38:	10803fe0 	cmpeqi	r2,r2,255
 821af3c:	1000031e 	bne	r2,zero,821af4c <OSTaskDel+0x214>
        OSLockNesting++;
 821af40:	d0a06b03 	ldbu	r2,-32340(gp)
 821af44:	10800044 	addi	r2,r2,1
 821af48:	d0a06b05 	stb	r2,-32340(gp)
 821af4c:	e0bff617 	ldw	r2,-40(fp)
 821af50:	e0bffd15 	stw	r2,-12(fp)
 821af54:	e0bffd17 	ldw	r2,-12(fp)
 821af58:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 821af5c:	82158040 	call	8215804 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821af60:	0005303a 	rdctl	r2,status
 821af64:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821af68:	e0fffa17 	ldw	r3,-24(fp)
 821af6c:	00bfff84 	movi	r2,-2
 821af70:	1884703a 	and	r2,r3,r2
 821af74:	1001703a 	wrctl	status,r2
  
  return context;
 821af78:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 821af7c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 821af80:	d0a06b03 	ldbu	r2,-32340(gp)
 821af84:	10803fcc 	andi	r2,r2,255
 821af88:	10000326 	beq	r2,zero,821af98 <OSTaskDel+0x260>
        OSLockNesting--;
 821af8c:	d0a06b03 	ldbu	r2,-32340(gp)
 821af90:	10bfffc4 	addi	r2,r2,-1
 821af94:	d0a06b05 	stb	r2,-32340(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 821af98:	e13ff817 	ldw	r4,-32(fp)
 821af9c:	823cc500 	call	823cc50 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 821afa0:	d0a07343 	ldbu	r2,-32307(gp)
 821afa4:	10bfffc4 	addi	r2,r2,-1
 821afa8:	d0a07345 	stb	r2,-32307(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 821afac:	e0ffff03 	ldbu	r3,-4(fp)
 821afb0:	008209b4 	movhi	r2,2086
 821afb4:	10b5c804 	addi	r2,r2,-10464
 821afb8:	18c7883a 	add	r3,r3,r3
 821afbc:	18c7883a 	add	r3,r3,r3
 821afc0:	10c5883a 	add	r2,r2,r3
 821afc4:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 821afc8:	e0bff817 	ldw	r2,-32(fp)
 821afcc:	10800617 	ldw	r2,24(r2)
 821afd0:	1000071e 	bne	r2,zero,821aff0 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 821afd4:	e0bff817 	ldw	r2,-32(fp)
 821afd8:	10800517 	ldw	r2,20(r2)
 821afdc:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 821afe0:	e0bff817 	ldw	r2,-32(fp)
 821afe4:	10800517 	ldw	r2,20(r2)
 821afe8:	d0a06e15 	stw	r2,-32328(gp)
 821afec:	00000a06 	br	821b018 <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 821aff0:	e0bff817 	ldw	r2,-32(fp)
 821aff4:	10800617 	ldw	r2,24(r2)
 821aff8:	e0fff817 	ldw	r3,-32(fp)
 821affc:	18c00517 	ldw	r3,20(r3)
 821b000:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 821b004:	e0bff817 	ldw	r2,-32(fp)
 821b008:	10800517 	ldw	r2,20(r2)
 821b00c:	e0fff817 	ldw	r3,-32(fp)
 821b010:	18c00617 	ldw	r3,24(r3)
 821b014:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 821b018:	d0e07217 	ldw	r3,-32312(gp)
 821b01c:	e0bff817 	ldw	r2,-32(fp)
 821b020:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 821b024:	e0bff817 	ldw	r2,-32(fp)
 821b028:	d0a07215 	stw	r2,-32312(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 821b02c:	e0bff817 	ldw	r2,-32(fp)
 821b030:	00c00fc4 	movi	r3,63
 821b034:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 821b038:	e0bff817 	ldw	r2,-32(fp)
 821b03c:	10001345 	stb	zero,77(r2)
 821b040:	e0bff617 	ldw	r2,-40(fp)
 821b044:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b048:	e0bffc17 	ldw	r2,-16(fp)
 821b04c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821b050:	d0a06b43 	ldbu	r2,-32339(gp)
 821b054:	10803fcc 	andi	r2,r2,255
 821b058:	10800058 	cmpnei	r2,r2,1
 821b05c:	1000011e 	bne	r2,zero,821b064 <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
 821b060:	82162700 	call	8216270 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821b064:	0005883a 	mov	r2,zero
}
 821b068:	e037883a 	mov	sp,fp
 821b06c:	dfc00117 	ldw	ra,4(sp)
 821b070:	df000017 	ldw	fp,0(sp)
 821b074:	dec00204 	addi	sp,sp,8
 821b078:	f800283a 	ret

0821b07c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 821b07c:	defff504 	addi	sp,sp,-44
 821b080:	df000a15 	stw	fp,40(sp)
 821b084:	df000a04 	addi	fp,sp,40
 821b088:	2005883a 	mov	r2,r4
 821b08c:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b090:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 821b094:	e0bfff03 	ldbu	r2,-4(fp)
 821b098:	10800518 	cmpnei	r2,r2,20
 821b09c:	1000021e 	bne	r2,zero,821b0a8 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 821b0a0:	00800f84 	movi	r2,62
 821b0a4:	00004506 	br	821b1bc <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821b0a8:	e0bfff03 	ldbu	r2,-4(fp)
 821b0ac:	10800530 	cmpltui	r2,r2,20
 821b0b0:	1000051e 	bne	r2,zero,821b0c8 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 821b0b4:	e0bfff03 	ldbu	r2,-4(fp)
 821b0b8:	10803fe0 	cmpeqi	r2,r2,255
 821b0bc:	1000021e 	bne	r2,zero,821b0c8 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 821b0c0:	00800a84 	movi	r2,42
 821b0c4:	00003d06 	br	821b1bc <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 821b0c8:	e0bfff03 	ldbu	r2,-4(fp)
 821b0cc:	10803fd8 	cmpnei	r2,r2,255
 821b0d0:	1000111e 	bne	r2,zero,821b118 <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b0d4:	0005303a 	rdctl	r2,status
 821b0d8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b0dc:	e0fff917 	ldw	r3,-28(fp)
 821b0e0:	00bfff84 	movi	r2,-2
 821b0e4:	1884703a 	and	r2,r3,r2
 821b0e8:	1001703a 	wrctl	status,r2
  
  return context;
 821b0ec:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 821b0f0:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 821b0f4:	d0a07a17 	ldw	r2,-32280(gp)
 821b0f8:	10800dc3 	ldbu	r2,55(r2)
 821b0fc:	e0bff805 	stb	r2,-32(fp)
 821b100:	e0bff617 	ldw	r2,-40(fp)
 821b104:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b108:	e0bffe17 	ldw	r2,-8(fp)
 821b10c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 821b110:	e0bff803 	ldbu	r2,-32(fp)
 821b114:	00002906 	br	821b1bc <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b118:	0005303a 	rdctl	r2,status
 821b11c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b120:	e0fff717 	ldw	r3,-36(fp)
 821b124:	00bfff84 	movi	r2,-2
 821b128:	1884703a 	and	r2,r3,r2
 821b12c:	1001703a 	wrctl	status,r2
  
  return context;
 821b130:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 821b134:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b138:	e0ffff03 	ldbu	r3,-4(fp)
 821b13c:	008209b4 	movhi	r2,2086
 821b140:	10b5c804 	addi	r2,r2,-10464
 821b144:	18c7883a 	add	r3,r3,r3
 821b148:	18c7883a 	add	r3,r3,r3
 821b14c:	10c5883a 	add	r2,r2,r3
 821b150:	10800017 	ldw	r2,0(r2)
 821b154:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 821b158:	e0bffb17 	ldw	r2,-20(fp)
 821b15c:	1000061e 	bne	r2,zero,821b178 <OSTaskDelReq+0xfc>
 821b160:	e0bff617 	ldw	r2,-40(fp)
 821b164:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b168:	e0bffa17 	ldw	r2,-24(fp)
 821b16c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 821b170:	008010c4 	movi	r2,67
 821b174:	00001106 	br	821b1bc <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 821b178:	e0bffb17 	ldw	r2,-20(fp)
 821b17c:	10800058 	cmpnei	r2,r2,1
 821b180:	1000061e 	bne	r2,zero,821b19c <OSTaskDelReq+0x120>
 821b184:	e0bff617 	ldw	r2,-40(fp)
 821b188:	e0bffc15 	stw	r2,-16(fp)
 821b18c:	e0bffc17 	ldw	r2,-16(fp)
 821b190:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b194:	00800f44 	movi	r2,61
 821b198:	00000806 	br	821b1bc <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 821b19c:	e0bffb17 	ldw	r2,-20(fp)
 821b1a0:	00c00fc4 	movi	r3,63
 821b1a4:	10c00dc5 	stb	r3,55(r2)
 821b1a8:	e0bff617 	ldw	r2,-40(fp)
 821b1ac:	e0bffd15 	stw	r2,-12(fp)
 821b1b0:	e0bffd17 	ldw	r2,-12(fp)
 821b1b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821b1b8:	0005883a 	mov	r2,zero
}
 821b1bc:	e037883a 	mov	sp,fp
 821b1c0:	df000017 	ldw	fp,0(sp)
 821b1c4:	dec00104 	addi	sp,sp,4
 821b1c8:	f800283a 	ret

0821b1cc <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b1cc:	defff404 	addi	sp,sp,-48
 821b1d0:	dfc00b15 	stw	ra,44(sp)
 821b1d4:	df000a15 	stw	fp,40(sp)
 821b1d8:	df000a04 	addi	fp,sp,40
 821b1dc:	2005883a 	mov	r2,r4
 821b1e0:	e17ffe15 	stw	r5,-8(fp)
 821b1e4:	e1bfff15 	stw	r6,-4(fp)
 821b1e8:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 821b1ec:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 821b1f0:	e0bfff17 	ldw	r2,-4(fp)
 821b1f4:	1000021e 	bne	r2,zero,821b200 <OSTaskNameGet+0x34>
        return (0);
 821b1f8:	0005883a 	mov	r2,zero
 821b1fc:	00005406 	br	821b350 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 821b200:	e0bffd03 	ldbu	r2,-12(fp)
 821b204:	10800570 	cmpltui	r2,r2,21
 821b208:	1000081e 	bne	r2,zero,821b22c <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 821b20c:	e0bffd03 	ldbu	r2,-12(fp)
 821b210:	10803fe0 	cmpeqi	r2,r2,255
 821b214:	1000051e 	bne	r2,zero,821b22c <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 821b218:	e0bfff17 	ldw	r2,-4(fp)
 821b21c:	00c00a84 	movi	r3,42
 821b220:	10c00005 	stb	r3,0(r2)
            return (0);
 821b224:	0005883a 	mov	r2,zero
 821b228:	00004906 	br	821b350 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 821b22c:	e0bffe17 	ldw	r2,-8(fp)
 821b230:	1000051e 	bne	r2,zero,821b248 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 821b234:	e0bfff17 	ldw	r2,-4(fp)
 821b238:	00c00304 	movi	r3,12
 821b23c:	10c00005 	stb	r3,0(r2)
        return (0);
 821b240:	0005883a 	mov	r2,zero
 821b244:	00004206 	br	821b350 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 821b248:	d0a07903 	ldbu	r2,-32284(gp)
 821b24c:	10803fcc 	andi	r2,r2,255
 821b250:	10000526 	beq	r2,zero,821b268 <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
 821b254:	e0bfff17 	ldw	r2,-4(fp)
 821b258:	00c00444 	movi	r3,17
 821b25c:	10c00005 	stb	r3,0(r2)
        return (0);
 821b260:	0005883a 	mov	r2,zero
 821b264:	00003a06 	br	821b350 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b268:	0005303a 	rdctl	r2,status
 821b26c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b270:	e0fffc17 	ldw	r3,-16(fp)
 821b274:	00bfff84 	movi	r2,-2
 821b278:	1884703a 	and	r2,r3,r2
 821b27c:	1001703a 	wrctl	status,r2
  
  return context;
 821b280:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b284:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 821b288:	e0bffd03 	ldbu	r2,-12(fp)
 821b28c:	10803fd8 	cmpnei	r2,r2,255
 821b290:	1000031e 	bne	r2,zero,821b2a0 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
 821b294:	d0a07a17 	ldw	r2,-32280(gp)
 821b298:	10800c83 	ldbu	r2,50(r2)
 821b29c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b2a0:	e0fffd03 	ldbu	r3,-12(fp)
 821b2a4:	008209b4 	movhi	r2,2086
 821b2a8:	10b5c804 	addi	r2,r2,-10464
 821b2ac:	18c7883a 	add	r3,r3,r3
 821b2b0:	18c7883a 	add	r3,r3,r3
 821b2b4:	10c5883a 	add	r2,r2,r3
 821b2b8:	10800017 	ldw	r2,0(r2)
 821b2bc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 821b2c0:	e0bff817 	ldw	r2,-32(fp)
 821b2c4:	1000091e 	bne	r2,zero,821b2ec <OSTaskNameGet+0x120>
 821b2c8:	e0bff617 	ldw	r2,-40(fp)
 821b2cc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b2d0:	e0bff717 	ldw	r2,-36(fp)
 821b2d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b2d8:	e0bfff17 	ldw	r2,-4(fp)
 821b2dc:	00c010c4 	movi	r3,67
 821b2e0:	10c00005 	stb	r3,0(r2)
        return (0);
 821b2e4:	0005883a 	mov	r2,zero
 821b2e8:	00001906 	br	821b350 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 821b2ec:	e0bff817 	ldw	r2,-32(fp)
 821b2f0:	10800058 	cmpnei	r2,r2,1
 821b2f4:	1000091e 	bne	r2,zero,821b31c <OSTaskNameGet+0x150>
 821b2f8:	e0bff617 	ldw	r2,-40(fp)
 821b2fc:	e0bff915 	stw	r2,-28(fp)
 821b300:	e0bff917 	ldw	r2,-28(fp)
 821b304:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b308:	e0bfff17 	ldw	r2,-4(fp)
 821b30c:	00c010c4 	movi	r3,67
 821b310:	10c00005 	stb	r3,0(r2)
        return (0);
 821b314:	0005883a 	mov	r2,zero
 821b318:	00000d06 	br	821b350 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 821b31c:	e0bff817 	ldw	r2,-32(fp)
 821b320:	10801304 	addi	r2,r2,76
 821b324:	100b883a 	mov	r5,r2
 821b328:	e13ffe17 	ldw	r4,-8(fp)
 821b32c:	82163b40 	call	82163b4 <OS_StrCopy>
 821b330:	e0bffb05 	stb	r2,-20(fp)
 821b334:	e0bff617 	ldw	r2,-40(fp)
 821b338:	e0bffa15 	stw	r2,-24(fp)
 821b33c:	e0bffa17 	ldw	r2,-24(fp)
 821b340:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b344:	e0bfff17 	ldw	r2,-4(fp)
 821b348:	10000005 	stb	zero,0(r2)
    return (len);
 821b34c:	e0bffb03 	ldbu	r2,-20(fp)
}
 821b350:	e037883a 	mov	sp,fp
 821b354:	dfc00117 	ldw	ra,4(sp)
 821b358:	df000017 	ldw	fp,0(sp)
 821b35c:	dec00204 	addi	sp,sp,8
 821b360:	f800283a 	ret

0821b364 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b364:	defff304 	addi	sp,sp,-52
 821b368:	dfc00c15 	stw	ra,48(sp)
 821b36c:	df000b15 	stw	fp,44(sp)
 821b370:	df000b04 	addi	fp,sp,44
 821b374:	2005883a 	mov	r2,r4
 821b378:	e17ffe15 	stw	r5,-8(fp)
 821b37c:	e1bfff15 	stw	r6,-4(fp)
 821b380:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b384:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 821b388:	e0bfff17 	ldw	r2,-4(fp)
 821b38c:	10005c26 	beq	r2,zero,821b500 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 821b390:	e0bffd03 	ldbu	r2,-12(fp)
 821b394:	10800570 	cmpltui	r2,r2,21
 821b398:	1000071e 	bne	r2,zero,821b3b8 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 821b39c:	e0bffd03 	ldbu	r2,-12(fp)
 821b3a0:	10803fe0 	cmpeqi	r2,r2,255
 821b3a4:	1000041e 	bne	r2,zero,821b3b8 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 821b3a8:	e0bfff17 	ldw	r2,-4(fp)
 821b3ac:	00c00a84 	movi	r3,42
 821b3b0:	10c00005 	stb	r3,0(r2)
            return;
 821b3b4:	00005306 	br	821b504 <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 821b3b8:	e0bffe17 	ldw	r2,-8(fp)
 821b3bc:	1000041e 	bne	r2,zero,821b3d0 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 821b3c0:	e0bfff17 	ldw	r2,-4(fp)
 821b3c4:	00c00304 	movi	r3,12
 821b3c8:	10c00005 	stb	r3,0(r2)
        return;
 821b3cc:	00004d06 	br	821b504 <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 821b3d0:	d0a07903 	ldbu	r2,-32284(gp)
 821b3d4:	10803fcc 	andi	r2,r2,255
 821b3d8:	10000426 	beq	r2,zero,821b3ec <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
 821b3dc:	e0bfff17 	ldw	r2,-4(fp)
 821b3e0:	00c00484 	movi	r3,18
 821b3e4:	10c00005 	stb	r3,0(r2)
        return;
 821b3e8:	00004606 	br	821b504 <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b3ec:	0005303a 	rdctl	r2,status
 821b3f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b3f4:	e0fffc17 	ldw	r3,-16(fp)
 821b3f8:	00bfff84 	movi	r2,-2
 821b3fc:	1884703a 	and	r2,r3,r2
 821b400:	1001703a 	wrctl	status,r2
  
  return context;
 821b404:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b408:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 821b40c:	e0bffd03 	ldbu	r2,-12(fp)
 821b410:	10803fd8 	cmpnei	r2,r2,255
 821b414:	1000031e 	bne	r2,zero,821b424 <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
 821b418:	d0a07a17 	ldw	r2,-32280(gp)
 821b41c:	10800c83 	ldbu	r2,50(r2)
 821b420:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b424:	e0fffd03 	ldbu	r3,-12(fp)
 821b428:	008209b4 	movhi	r2,2086
 821b42c:	10b5c804 	addi	r2,r2,-10464
 821b430:	18c7883a 	add	r3,r3,r3
 821b434:	18c7883a 	add	r3,r3,r3
 821b438:	10c5883a 	add	r2,r2,r3
 821b43c:	10800017 	ldw	r2,0(r2)
 821b440:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 821b444:	e0bff717 	ldw	r2,-36(fp)
 821b448:	1000081e 	bne	r2,zero,821b46c <OSTaskNameSet+0x108>
 821b44c:	e0bff517 	ldw	r2,-44(fp)
 821b450:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b454:	e0bff617 	ldw	r2,-40(fp)
 821b458:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b45c:	e0bfff17 	ldw	r2,-4(fp)
 821b460:	00c010c4 	movi	r3,67
 821b464:	10c00005 	stb	r3,0(r2)
        return;
 821b468:	00002606 	br	821b504 <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 821b46c:	e0bff717 	ldw	r2,-36(fp)
 821b470:	10800058 	cmpnei	r2,r2,1
 821b474:	1000081e 	bne	r2,zero,821b498 <OSTaskNameSet+0x134>
 821b478:	e0bff517 	ldw	r2,-44(fp)
 821b47c:	e0bff815 	stw	r2,-32(fp)
 821b480:	e0bff817 	ldw	r2,-32(fp)
 821b484:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b488:	e0bfff17 	ldw	r2,-4(fp)
 821b48c:	00c010c4 	movi	r3,67
 821b490:	10c00005 	stb	r3,0(r2)
        return;
 821b494:	00001b06 	br	821b504 <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 821b498:	e13ffe17 	ldw	r4,-8(fp)
 821b49c:	82164280 	call	8216428 <OS_StrLen>
 821b4a0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 821b4a4:	e0bffa03 	ldbu	r2,-24(fp)
 821b4a8:	10800830 	cmpltui	r2,r2,32
 821b4ac:	1000081e 	bne	r2,zero,821b4d0 <OSTaskNameSet+0x16c>
 821b4b0:	e0bff517 	ldw	r2,-44(fp)
 821b4b4:	e0bff915 	stw	r2,-28(fp)
 821b4b8:	e0bff917 	ldw	r2,-28(fp)
 821b4bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 821b4c0:	e0bfff17 	ldw	r2,-4(fp)
 821b4c4:	00c01044 	movi	r3,65
 821b4c8:	10c00005 	stb	r3,0(r2)
        return;
 821b4cc:	00000d06 	br	821b504 <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 821b4d0:	e0bff717 	ldw	r2,-36(fp)
 821b4d4:	10801304 	addi	r2,r2,76
 821b4d8:	e17ffe17 	ldw	r5,-8(fp)
 821b4dc:	1009883a 	mov	r4,r2
 821b4e0:	82163b40 	call	82163b4 <OS_StrCopy>
 821b4e4:	e0bff517 	ldw	r2,-44(fp)
 821b4e8:	e0bffb15 	stw	r2,-20(fp)
 821b4ec:	e0bffb17 	ldw	r2,-20(fp)
 821b4f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b4f4:	e0bfff17 	ldw	r2,-4(fp)
 821b4f8:	10000005 	stb	zero,0(r2)
 821b4fc:	00000106 	br	821b504 <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 821b500:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 821b504:	e037883a 	mov	sp,fp
 821b508:	dfc00117 	ldw	ra,4(sp)
 821b50c:	df000017 	ldw	fp,0(sp)
 821b510:	dec00204 	addi	sp,sp,8
 821b514:	f800283a 	ret

0821b518 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 821b518:	defff404 	addi	sp,sp,-48
 821b51c:	dfc00b15 	stw	ra,44(sp)
 821b520:	df000a15 	stw	fp,40(sp)
 821b524:	df000a04 	addi	fp,sp,40
 821b528:	2005883a 	mov	r2,r4
 821b52c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b530:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 821b534:	e0bfff03 	ldbu	r2,-4(fp)
 821b538:	10800530 	cmpltui	r2,r2,20
 821b53c:	1000021e 	bne	r2,zero,821b548 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821b540:	00800a84 	movi	r2,42
 821b544:	00006406 	br	821b6d8 <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b548:	0005303a 	rdctl	r2,status
 821b54c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b550:	e0fffe17 	ldw	r3,-8(fp)
 821b554:	00bfff84 	movi	r2,-2
 821b558:	1884703a 	and	r2,r3,r2
 821b55c:	1001703a 	wrctl	status,r2
  
  return context;
 821b560:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821b564:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b568:	e0ffff03 	ldbu	r3,-4(fp)
 821b56c:	008209b4 	movhi	r2,2086
 821b570:	10b5c804 	addi	r2,r2,-10464
 821b574:	18c7883a 	add	r3,r3,r3
 821b578:	18c7883a 	add	r3,r3,r3
 821b57c:	10c5883a 	add	r2,r2,r3
 821b580:	10800017 	ldw	r2,0(r2)
 821b584:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 821b588:	e0bff817 	ldw	r2,-32(fp)
 821b58c:	1000061e 	bne	r2,zero,821b5a8 <OSTaskResume+0x90>
 821b590:	e0bff617 	ldw	r2,-40(fp)
 821b594:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b598:	e0bff717 	ldw	r2,-36(fp)
 821b59c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 821b5a0:	00801184 	movi	r2,70
 821b5a4:	00004c06 	br	821b6d8 <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 821b5a8:	e0bff817 	ldw	r2,-32(fp)
 821b5ac:	10800058 	cmpnei	r2,r2,1
 821b5b0:	1000061e 	bne	r2,zero,821b5cc <OSTaskResume+0xb4>
 821b5b4:	e0bff617 	ldw	r2,-40(fp)
 821b5b8:	e0bff915 	stw	r2,-28(fp)
 821b5bc:	e0bff917 	ldw	r2,-28(fp)
 821b5c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b5c4:	008010c4 	movi	r2,67
 821b5c8:	00004306 	br	821b6d8 <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 821b5cc:	e0bff817 	ldw	r2,-32(fp)
 821b5d0:	10800c03 	ldbu	r2,48(r2)
 821b5d4:	10803fcc 	andi	r2,r2,255
 821b5d8:	1080020c 	andi	r2,r2,8
 821b5dc:	10003926 	beq	r2,zero,821b6c4 <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 821b5e0:	e0bff817 	ldw	r2,-32(fp)
 821b5e4:	10c00c03 	ldbu	r3,48(r2)
 821b5e8:	00bffdc4 	movi	r2,-9
 821b5ec:	1884703a 	and	r2,r3,r2
 821b5f0:	1007883a 	mov	r3,r2
 821b5f4:	e0bff817 	ldw	r2,-32(fp)
 821b5f8:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 821b5fc:	e0bff817 	ldw	r2,-32(fp)
 821b600:	10800c03 	ldbu	r2,48(r2)
 821b604:	10803fcc 	andi	r2,r2,255
 821b608:	1000281e 	bne	r2,zero,821b6ac <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
 821b60c:	e0bff817 	ldw	r2,-32(fp)
 821b610:	10800b8b 	ldhu	r2,46(r2)
 821b614:	10bfffcc 	andi	r2,r2,65535
 821b618:	10001f1e 	bne	r2,zero,821b698 <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 821b61c:	e0bff817 	ldw	r2,-32(fp)
 821b620:	10c00d83 	ldbu	r3,54(r2)
 821b624:	d0a07703 	ldbu	r2,-32292(gp)
 821b628:	1884b03a 	or	r2,r3,r2
 821b62c:	d0a07705 	stb	r2,-32292(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821b630:	e0bff817 	ldw	r2,-32(fp)
 821b634:	10800d03 	ldbu	r2,52(r2)
 821b638:	10c03fcc 	andi	r3,r2,255
 821b63c:	e0bff817 	ldw	r2,-32(fp)
 821b640:	10800d03 	ldbu	r2,52(r2)
 821b644:	11003fcc 	andi	r4,r2,255
 821b648:	d0a07744 	addi	r2,gp,-32291
 821b64c:	2085883a 	add	r2,r4,r2
 821b650:	11000003 	ldbu	r4,0(r2)
 821b654:	e0bff817 	ldw	r2,-32(fp)
 821b658:	10800d43 	ldbu	r2,53(r2)
 821b65c:	2084b03a 	or	r2,r4,r2
 821b660:	1009883a 	mov	r4,r2
 821b664:	d0a07744 	addi	r2,gp,-32291
 821b668:	1885883a 	add	r2,r3,r2
 821b66c:	11000005 	stb	r4,0(r2)
 821b670:	e0bff617 	ldw	r2,-40(fp)
 821b674:	e0bffa15 	stw	r2,-24(fp)
 821b678:	e0bffa17 	ldw	r2,-24(fp)
 821b67c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 821b680:	d0a06b43 	ldbu	r2,-32339(gp)
 821b684:	10803fcc 	andi	r2,r2,255
 821b688:	10800058 	cmpnei	r2,r2,1
 821b68c:	10000b1e 	bne	r2,zero,821b6bc <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
 821b690:	82162700 	call	8216270 <OS_Sched>
 821b694:	00000906 	br	821b6bc <OSTaskResume+0x1a4>
 821b698:	e0bff617 	ldw	r2,-40(fp)
 821b69c:	e0bffb15 	stw	r2,-20(fp)
 821b6a0:	e0bffb17 	ldw	r2,-20(fp)
 821b6a4:	1001703a 	wrctl	status,r2
 821b6a8:	00000406 	br	821b6bc <OSTaskResume+0x1a4>
 821b6ac:	e0bff617 	ldw	r2,-40(fp)
 821b6b0:	e0bffc15 	stw	r2,-16(fp)
 821b6b4:	e0bffc17 	ldw	r2,-16(fp)
 821b6b8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 821b6bc:	0005883a 	mov	r2,zero
 821b6c0:	00000506 	br	821b6d8 <OSTaskResume+0x1c0>
 821b6c4:	e0bff617 	ldw	r2,-40(fp)
 821b6c8:	e0bffd15 	stw	r2,-12(fp)
 821b6cc:	e0bffd17 	ldw	r2,-12(fp)
 821b6d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 821b6d4:	00801104 	movi	r2,68
}
 821b6d8:	e037883a 	mov	sp,fp
 821b6dc:	dfc00117 	ldw	ra,4(sp)
 821b6e0:	df000017 	ldw	fp,0(sp)
 821b6e4:	dec00204 	addi	sp,sp,8
 821b6e8:	f800283a 	ret

0821b6ec <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 821b6ec:	defff304 	addi	sp,sp,-52
 821b6f0:	df000c15 	stw	fp,48(sp)
 821b6f4:	df000c04 	addi	fp,sp,48
 821b6f8:	2005883a 	mov	r2,r4
 821b6fc:	e17fff15 	stw	r5,-4(fp)
 821b700:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 821b704:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 821b708:	e0bffe03 	ldbu	r2,-8(fp)
 821b70c:	10800570 	cmpltui	r2,r2,21
 821b710:	1000051e 	bne	r2,zero,821b728 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 821b714:	e0bffe03 	ldbu	r2,-8(fp)
 821b718:	10803fe0 	cmpeqi	r2,r2,255
 821b71c:	1000021e 	bne	r2,zero,821b728 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 821b720:	00800a84 	movi	r2,42
 821b724:	00005d06 	br	821b89c <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 821b728:	e0bfff17 	ldw	r2,-4(fp)
 821b72c:	1000021e 	bne	r2,zero,821b738 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 821b730:	00800244 	movi	r2,9
 821b734:	00005906 	br	821b89c <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 821b738:	e0bfff17 	ldw	r2,-4(fp)
 821b73c:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 821b740:	e0bfff17 	ldw	r2,-4(fp)
 821b744:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b748:	0005303a 	rdctl	r2,status
 821b74c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b750:	e0fffd17 	ldw	r3,-12(fp)
 821b754:	00bfff84 	movi	r2,-2
 821b758:	1884703a 	and	r2,r3,r2
 821b75c:	1001703a 	wrctl	status,r2
  
  return context;
 821b760:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
 821b764:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 821b768:	e0bffe03 	ldbu	r2,-8(fp)
 821b76c:	10803fd8 	cmpnei	r2,r2,255
 821b770:	1000031e 	bne	r2,zero,821b780 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821b774:	d0a07a17 	ldw	r2,-32280(gp)
 821b778:	10800c83 	ldbu	r2,50(r2)
 821b77c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b780:	e0fffe03 	ldbu	r3,-8(fp)
 821b784:	008209b4 	movhi	r2,2086
 821b788:	10b5c804 	addi	r2,r2,-10464
 821b78c:	18c7883a 	add	r3,r3,r3
 821b790:	18c7883a 	add	r3,r3,r3
 821b794:	10c5883a 	add	r2,r2,r3
 821b798:	10800017 	ldw	r2,0(r2)
 821b79c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 821b7a0:	e0bff817 	ldw	r2,-32(fp)
 821b7a4:	1000061e 	bne	r2,zero,821b7c0 <OSTaskStkChk+0xd4>
 821b7a8:	e0bff617 	ldw	r2,-40(fp)
 821b7ac:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b7b0:	e0bff717 	ldw	r2,-36(fp)
 821b7b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b7b8:	008010c4 	movi	r2,67
 821b7bc:	00003706 	br	821b89c <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821b7c0:	e0bff817 	ldw	r2,-32(fp)
 821b7c4:	10800058 	cmpnei	r2,r2,1
 821b7c8:	1000061e 	bne	r2,zero,821b7e4 <OSTaskStkChk+0xf8>
 821b7cc:	e0bff617 	ldw	r2,-40(fp)
 821b7d0:	e0bff915 	stw	r2,-28(fp)
 821b7d4:	e0bff917 	ldw	r2,-28(fp)
 821b7d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b7dc:	008010c4 	movi	r2,67
 821b7e0:	00002e06 	br	821b89c <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 821b7e4:	e0bff817 	ldw	r2,-32(fp)
 821b7e8:	1080040b 	ldhu	r2,16(r2)
 821b7ec:	10bfffcc 	andi	r2,r2,65535
 821b7f0:	1080004c 	andi	r2,r2,1
 821b7f4:	1000061e 	bne	r2,zero,821b810 <OSTaskStkChk+0x124>
 821b7f8:	e0bff617 	ldw	r2,-40(fp)
 821b7fc:	e0bffa15 	stw	r2,-24(fp)
 821b800:	e0bffa17 	ldw	r2,-24(fp)
 821b804:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 821b808:	00801144 	movi	r2,69
 821b80c:	00002306 	br	821b89c <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
 821b810:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 821b814:	e0bff817 	ldw	r2,-32(fp)
 821b818:	10800317 	ldw	r2,12(r2)
 821b81c:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
 821b820:	e0bff817 	ldw	r2,-32(fp)
 821b824:	10800217 	ldw	r2,8(r2)
 821b828:	e0bff415 	stw	r2,-48(fp)
 821b82c:	e0bff617 	ldw	r2,-40(fp)
 821b830:	e0bffb15 	stw	r2,-20(fp)
 821b834:	e0bffb17 	ldw	r2,-20(fp)
 821b838:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821b83c:	00000306 	br	821b84c <OSTaskStkChk+0x160>
        nfree++;
 821b840:	e0bff517 	ldw	r2,-44(fp)
 821b844:	10800044 	addi	r2,r2,1
 821b848:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821b84c:	e0bff417 	ldw	r2,-48(fp)
 821b850:	10c00104 	addi	r3,r2,4
 821b854:	e0fff415 	stw	r3,-48(fp)
 821b858:	10800017 	ldw	r2,0(r2)
 821b85c:	103ff826 	beq	r2,zero,821b840 <OSTaskStkChk+0x154>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 821b860:	e0bff517 	ldw	r2,-44(fp)
 821b864:	1085883a 	add	r2,r2,r2
 821b868:	1085883a 	add	r2,r2,r2
 821b86c:	1007883a 	mov	r3,r2
 821b870:	e0bfff17 	ldw	r2,-4(fp)
 821b874:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 821b878:	e0fffc17 	ldw	r3,-16(fp)
 821b87c:	e0bff517 	ldw	r2,-44(fp)
 821b880:	1885c83a 	sub	r2,r3,r2
 821b884:	1085883a 	add	r2,r2,r2
 821b888:	1085883a 	add	r2,r2,r2
 821b88c:	1007883a 	mov	r3,r2
 821b890:	e0bfff17 	ldw	r2,-4(fp)
 821b894:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 821b898:	0005883a 	mov	r2,zero
}
 821b89c:	e037883a 	mov	sp,fp
 821b8a0:	df000017 	ldw	fp,0(sp)
 821b8a4:	dec00104 	addi	sp,sp,4
 821b8a8:	f800283a 	ret

0821b8ac <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 821b8ac:	defff504 	addi	sp,sp,-44
 821b8b0:	dfc00a15 	stw	ra,40(sp)
 821b8b4:	df000915 	stw	fp,36(sp)
 821b8b8:	df000904 	addi	fp,sp,36
 821b8bc:	2005883a 	mov	r2,r4
 821b8c0:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b8c4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 821b8c8:	e0bfff03 	ldbu	r2,-4(fp)
 821b8cc:	10800518 	cmpnei	r2,r2,20
 821b8d0:	1000021e 	bne	r2,zero,821b8dc <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 821b8d4:	008011c4 	movi	r2,71
 821b8d8:	00006806 	br	821ba7c <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821b8dc:	e0bfff03 	ldbu	r2,-4(fp)
 821b8e0:	10800530 	cmpltui	r2,r2,20
 821b8e4:	1000051e 	bne	r2,zero,821b8fc <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 821b8e8:	e0bfff03 	ldbu	r2,-4(fp)
 821b8ec:	10803fe0 	cmpeqi	r2,r2,255
 821b8f0:	1000021e 	bne	r2,zero,821b8fc <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 821b8f4:	00800a84 	movi	r2,42
 821b8f8:	00006006 	br	821ba7c <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b8fc:	0005303a 	rdctl	r2,status
 821b900:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b904:	e0fffe17 	ldw	r3,-8(fp)
 821b908:	00bfff84 	movi	r2,-2
 821b90c:	1884703a 	and	r2,r3,r2
 821b910:	1001703a 	wrctl	status,r2
  
  return context;
 821b914:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 821b918:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 821b91c:	e0bfff03 	ldbu	r2,-4(fp)
 821b920:	10803fd8 	cmpnei	r2,r2,255
 821b924:	1000061e 	bne	r2,zero,821b940 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821b928:	d0a07a17 	ldw	r2,-32280(gp)
 821b92c:	10800c83 	ldbu	r2,50(r2)
 821b930:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 821b934:	00800044 	movi	r2,1
 821b938:	e0bff705 	stb	r2,-36(fp)
 821b93c:	00000906 	br	821b964 <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 821b940:	d0a07a17 	ldw	r2,-32280(gp)
 821b944:	10800c83 	ldbu	r2,50(r2)
 821b948:	10c03fcc 	andi	r3,r2,255
 821b94c:	e0bfff03 	ldbu	r2,-4(fp)
 821b950:	1880031e 	bne	r3,r2,821b960 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
 821b954:	00800044 	movi	r2,1
 821b958:	e0bff705 	stb	r2,-36(fp)
 821b95c:	00000106 	br	821b964 <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 821b960:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b964:	e0ffff03 	ldbu	r3,-4(fp)
 821b968:	008209b4 	movhi	r2,2086
 821b96c:	10b5c804 	addi	r2,r2,-10464
 821b970:	18c7883a 	add	r3,r3,r3
 821b974:	18c7883a 	add	r3,r3,r3
 821b978:	10c5883a 	add	r2,r2,r3
 821b97c:	10800017 	ldw	r2,0(r2)
 821b980:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 821b984:	e0bffa17 	ldw	r2,-24(fp)
 821b988:	1000061e 	bne	r2,zero,821b9a4 <OSTaskSuspend+0xf8>
 821b98c:	e0bff817 	ldw	r2,-32(fp)
 821b990:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b994:	e0bff917 	ldw	r2,-28(fp)
 821b998:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 821b99c:	00801204 	movi	r2,72
 821b9a0:	00003606 	br	821ba7c <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 821b9a4:	e0bffa17 	ldw	r2,-24(fp)
 821b9a8:	10800058 	cmpnei	r2,r2,1
 821b9ac:	1000061e 	bne	r2,zero,821b9c8 <OSTaskSuspend+0x11c>
 821b9b0:	e0bff817 	ldw	r2,-32(fp)
 821b9b4:	e0bffb15 	stw	r2,-20(fp)
 821b9b8:	e0bffb17 	ldw	r2,-20(fp)
 821b9bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b9c0:	008010c4 	movi	r2,67
 821b9c4:	00002d06 	br	821ba7c <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
 821b9c8:	e0bffa17 	ldw	r2,-24(fp)
 821b9cc:	10800d03 	ldbu	r2,52(r2)
 821b9d0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 821b9d4:	e0fffd03 	ldbu	r3,-12(fp)
 821b9d8:	e13ffd03 	ldbu	r4,-12(fp)
 821b9dc:	d0a07744 	addi	r2,gp,-32291
 821b9e0:	2085883a 	add	r2,r4,r2
 821b9e4:	10800003 	ldbu	r2,0(r2)
 821b9e8:	1009883a 	mov	r4,r2
 821b9ec:	e0bffa17 	ldw	r2,-24(fp)
 821b9f0:	10800d43 	ldbu	r2,53(r2)
 821b9f4:	0084303a 	nor	r2,zero,r2
 821b9f8:	2084703a 	and	r2,r4,r2
 821b9fc:	1009883a 	mov	r4,r2
 821ba00:	d0a07744 	addi	r2,gp,-32291
 821ba04:	1885883a 	add	r2,r3,r2
 821ba08:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 821ba0c:	e0fffd03 	ldbu	r3,-12(fp)
 821ba10:	d0a07744 	addi	r2,gp,-32291
 821ba14:	1885883a 	add	r2,r3,r2
 821ba18:	10800003 	ldbu	r2,0(r2)
 821ba1c:	10803fcc 	andi	r2,r2,255
 821ba20:	1000071e 	bne	r2,zero,821ba40 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 821ba24:	e0bffa17 	ldw	r2,-24(fp)
 821ba28:	10800d83 	ldbu	r2,54(r2)
 821ba2c:	0084303a 	nor	r2,zero,r2
 821ba30:	1007883a 	mov	r3,r2
 821ba34:	d0a07703 	ldbu	r2,-32292(gp)
 821ba38:	1884703a 	and	r2,r3,r2
 821ba3c:	d0a07705 	stb	r2,-32292(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 821ba40:	e0bffa17 	ldw	r2,-24(fp)
 821ba44:	10800c03 	ldbu	r2,48(r2)
 821ba48:	10800214 	ori	r2,r2,8
 821ba4c:	1007883a 	mov	r3,r2
 821ba50:	e0bffa17 	ldw	r2,-24(fp)
 821ba54:	10c00c05 	stb	r3,48(r2)
 821ba58:	e0bff817 	ldw	r2,-32(fp)
 821ba5c:	e0bffc15 	stw	r2,-16(fp)
 821ba60:	e0bffc17 	ldw	r2,-16(fp)
 821ba64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 821ba68:	e0bff703 	ldbu	r2,-36(fp)
 821ba6c:	10800058 	cmpnei	r2,r2,1
 821ba70:	1000011e 	bne	r2,zero,821ba78 <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
 821ba74:	82162700 	call	8216270 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821ba78:	0005883a 	mov	r2,zero
}
 821ba7c:	e037883a 	mov	sp,fp
 821ba80:	dfc00117 	ldw	ra,4(sp)
 821ba84:	df000017 	ldw	fp,0(sp)
 821ba88:	dec00204 	addi	sp,sp,8
 821ba8c:	f800283a 	ret

0821ba90 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 821ba90:	defff604 	addi	sp,sp,-40
 821ba94:	dfc00915 	stw	ra,36(sp)
 821ba98:	df000815 	stw	fp,32(sp)
 821ba9c:	df000804 	addi	fp,sp,32
 821baa0:	2005883a 	mov	r2,r4
 821baa4:	e17fff15 	stw	r5,-4(fp)
 821baa8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821baac:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 821bab0:	e0bffe03 	ldbu	r2,-8(fp)
 821bab4:	10800570 	cmpltui	r2,r2,21
 821bab8:	1000051e 	bne	r2,zero,821bad0 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 821babc:	e0bffe03 	ldbu	r2,-8(fp)
 821bac0:	10803fe0 	cmpeqi	r2,r2,255
 821bac4:	1000021e 	bne	r2,zero,821bad0 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 821bac8:	00800a84 	movi	r2,42
 821bacc:	00003406 	br	821bba0 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 821bad0:	e0bfff17 	ldw	r2,-4(fp)
 821bad4:	1000021e 	bne	r2,zero,821bae0 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 821bad8:	00800244 	movi	r2,9
 821badc:	00003006 	br	821bba0 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bae0:	0005303a 	rdctl	r2,status
 821bae4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bae8:	e0fffd17 	ldw	r3,-12(fp)
 821baec:	00bfff84 	movi	r2,-2
 821baf0:	1884703a 	and	r2,r3,r2
 821baf4:	1001703a 	wrctl	status,r2
  
  return context;
 821baf8:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821bafc:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 821bb00:	e0bffe03 	ldbu	r2,-8(fp)
 821bb04:	10803fd8 	cmpnei	r2,r2,255
 821bb08:	1000031e 	bne	r2,zero,821bb18 <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
 821bb0c:	d0a07a17 	ldw	r2,-32280(gp)
 821bb10:	10800c83 	ldbu	r2,50(r2)
 821bb14:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821bb18:	e0fffe03 	ldbu	r3,-8(fp)
 821bb1c:	008209b4 	movhi	r2,2086
 821bb20:	10b5c804 	addi	r2,r2,-10464
 821bb24:	18c7883a 	add	r3,r3,r3
 821bb28:	18c7883a 	add	r3,r3,r3
 821bb2c:	10c5883a 	add	r2,r2,r3
 821bb30:	10800017 	ldw	r2,0(r2)
 821bb34:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 821bb38:	e0bffa17 	ldw	r2,-24(fp)
 821bb3c:	1000061e 	bne	r2,zero,821bb58 <OSTaskQuery+0xc8>
 821bb40:	e0bff817 	ldw	r2,-32(fp)
 821bb44:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bb48:	e0bff917 	ldw	r2,-28(fp)
 821bb4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 821bb50:	00800a44 	movi	r2,41
 821bb54:	00001206 	br	821bba0 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 821bb58:	e0bffa17 	ldw	r2,-24(fp)
 821bb5c:	10800058 	cmpnei	r2,r2,1
 821bb60:	1000061e 	bne	r2,zero,821bb7c <OSTaskQuery+0xec>
 821bb64:	e0bff817 	ldw	r2,-32(fp)
 821bb68:	e0bffb15 	stw	r2,-20(fp)
 821bb6c:	e0bffb17 	ldw	r2,-20(fp)
 821bb70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821bb74:	008010c4 	movi	r2,67
 821bb78:	00000906 	br	821bba0 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 821bb7c:	01801b04 	movi	r6,108
 821bb80:	e17ffa17 	ldw	r5,-24(fp)
 821bb84:	e13fff17 	ldw	r4,-4(fp)
 821bb88:	82162080 	call	8216208 <OS_MemCopy>
 821bb8c:	e0bff817 	ldw	r2,-32(fp)
 821bb90:	e0bffc15 	stw	r2,-16(fp)
 821bb94:	e0bffc17 	ldw	r2,-16(fp)
 821bb98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821bb9c:	0005883a 	mov	r2,zero
}
 821bba0:	e037883a 	mov	sp,fp
 821bba4:	dfc00117 	ldw	ra,4(sp)
 821bba8:	df000017 	ldw	fp,0(sp)
 821bbac:	dec00204 	addi	sp,sp,8
 821bbb0:	f800283a 	ret

0821bbb4 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 821bbb4:	defffc04 	addi	sp,sp,-16
 821bbb8:	df000315 	stw	fp,12(sp)
 821bbbc:	df000304 	addi	fp,sp,12
 821bbc0:	e13ffd15 	stw	r4,-12(fp)
 821bbc4:	e17ffe15 	stw	r5,-8(fp)
 821bbc8:	3005883a 	mov	r2,r6
 821bbcc:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 821bbd0:	e0bfff0b 	ldhu	r2,-4(fp)
 821bbd4:	1080004c 	andi	r2,r2,1
 821bbd8:	10000d26 	beq	r2,zero,821bc10 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 821bbdc:	e0bfff0b 	ldhu	r2,-4(fp)
 821bbe0:	1080008c 	andi	r2,r2,2
 821bbe4:	10000a26 	beq	r2,zero,821bc10 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821bbe8:	00000706 	br	821bc08 <OS_TaskStkClr+0x54>
                size--;
 821bbec:	e0bffe17 	ldw	r2,-8(fp)
 821bbf0:	10bfffc4 	addi	r2,r2,-1
 821bbf4:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 821bbf8:	e0bffd17 	ldw	r2,-12(fp)
 821bbfc:	10c00104 	addi	r3,r2,4
 821bc00:	e0fffd15 	stw	r3,-12(fp)
 821bc04:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821bc08:	e0bffe17 	ldw	r2,-8(fp)
 821bc0c:	103ff71e 	bne	r2,zero,821bbec <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 821bc10:	0001883a 	nop
 821bc14:	e037883a 	mov	sp,fp
 821bc18:	df000017 	ldw	fp,0(sp)
 821bc1c:	dec00104 	addi	sp,sp,4
 821bc20:	f800283a 	ret

0821bc24 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 821bc24:	defff904 	addi	sp,sp,-28
 821bc28:	dfc00615 	stw	ra,24(sp)
 821bc2c:	df000515 	stw	fp,20(sp)
 821bc30:	df000504 	addi	fp,sp,20
 821bc34:	2005883a 	mov	r2,r4
 821bc38:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bc3c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bc40:	d0a07903 	ldbu	r2,-32284(gp)
 821bc44:	10803fcc 	andi	r2,r2,255
 821bc48:	1000311e 	bne	r2,zero,821bd10 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 821bc4c:	e0bfff0b 	ldhu	r2,-4(fp)
 821bc50:	10003026 	beq	r2,zero,821bd14 <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bc54:	0005303a 	rdctl	r2,status
 821bc58:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bc5c:	e0fffe17 	ldw	r3,-8(fp)
 821bc60:	00bfff84 	movi	r2,-2
 821bc64:	1884703a 	and	r2,r3,r2
 821bc68:	1001703a 	wrctl	status,r2
  
  return context;
 821bc6c:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 821bc70:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 821bc74:	d0a07a17 	ldw	r2,-32280(gp)
 821bc78:	10800d03 	ldbu	r2,52(r2)
 821bc7c:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 821bc80:	e0fffd03 	ldbu	r3,-12(fp)
 821bc84:	e13ffd03 	ldbu	r4,-12(fp)
 821bc88:	d0a07744 	addi	r2,gp,-32291
 821bc8c:	2085883a 	add	r2,r4,r2
 821bc90:	10800003 	ldbu	r2,0(r2)
 821bc94:	1009883a 	mov	r4,r2
 821bc98:	d0a07a17 	ldw	r2,-32280(gp)
 821bc9c:	10800d43 	ldbu	r2,53(r2)
 821bca0:	0084303a 	nor	r2,zero,r2
 821bca4:	2084703a 	and	r2,r4,r2
 821bca8:	1009883a 	mov	r4,r2
 821bcac:	d0a07744 	addi	r2,gp,-32291
 821bcb0:	1885883a 	add	r2,r3,r2
 821bcb4:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
 821bcb8:	e0fffd03 	ldbu	r3,-12(fp)
 821bcbc:	d0a07744 	addi	r2,gp,-32291
 821bcc0:	1885883a 	add	r2,r3,r2
 821bcc4:	10800003 	ldbu	r2,0(r2)
 821bcc8:	10803fcc 	andi	r2,r2,255
 821bccc:	1000071e 	bne	r2,zero,821bcec <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 821bcd0:	d0a07a17 	ldw	r2,-32280(gp)
 821bcd4:	10800d83 	ldbu	r2,54(r2)
 821bcd8:	0084303a 	nor	r2,zero,r2
 821bcdc:	1007883a 	mov	r3,r2
 821bce0:	d0a07703 	ldbu	r2,-32292(gp)
 821bce4:	1884703a 	and	r2,r3,r2
 821bce8:	d0a07705 	stb	r2,-32292(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 821bcec:	d0a07a17 	ldw	r2,-32280(gp)
 821bcf0:	e0ffff0b 	ldhu	r3,-4(fp)
 821bcf4:	10c00b8d 	sth	r3,46(r2)
 821bcf8:	e0bffb17 	ldw	r2,-20(fp)
 821bcfc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bd00:	e0bffc17 	ldw	r2,-16(fp)
 821bd04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 821bd08:	82162700 	call	8216270 <OS_Sched>
 821bd0c:	00000106 	br	821bd14 <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 821bd10:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 821bd14:	e037883a 	mov	sp,fp
 821bd18:	dfc00117 	ldw	ra,4(sp)
 821bd1c:	df000017 	ldw	fp,0(sp)
 821bd20:	dec00204 	addi	sp,sp,8
 821bd24:	f800283a 	ret

0821bd28 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 821bd28:	defff804 	addi	sp,sp,-32
 821bd2c:	dfc00715 	stw	ra,28(sp)
 821bd30:	df000615 	stw	fp,24(sp)
 821bd34:	df000604 	addi	fp,sp,24
 821bd38:	2015883a 	mov	r10,r4
 821bd3c:	2809883a 	mov	r4,r5
 821bd40:	3007883a 	mov	r3,r6
 821bd44:	3805883a 	mov	r2,r7
 821bd48:	e2bffc05 	stb	r10,-16(fp)
 821bd4c:	e13ffd05 	stb	r4,-12(fp)
 821bd50:	e0fffe05 	stb	r3,-8(fp)
 821bd54:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bd58:	d0a07903 	ldbu	r2,-32284(gp)
 821bd5c:	10803fcc 	andi	r2,r2,255
 821bd60:	10000226 	beq	r2,zero,821bd6c <OSTimeDlyHMSM+0x44>
        return (OS_ERR_TIME_DLY_ISR);
 821bd64:	00801544 	movi	r2,85
 821bd68:	00004206 	br	821be74 <OSTimeDlyHMSM+0x14c>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 821bd6c:	e0bffc03 	ldbu	r2,-16(fp)
 821bd70:	1000081e 	bne	r2,zero,821bd94 <OSTimeDlyHMSM+0x6c>
        if (minutes == 0) {
 821bd74:	e0bffd03 	ldbu	r2,-12(fp)
 821bd78:	1000061e 	bne	r2,zero,821bd94 <OSTimeDlyHMSM+0x6c>
            if (seconds == 0) {
 821bd7c:	e0bffe03 	ldbu	r2,-8(fp)
 821bd80:	1000041e 	bne	r2,zero,821bd94 <OSTimeDlyHMSM+0x6c>
                if (ms == 0) {
 821bd84:	e0bfff0b 	ldhu	r2,-4(fp)
 821bd88:	1000021e 	bne	r2,zero,821bd94 <OSTimeDlyHMSM+0x6c>
                    return (OS_ERR_TIME_ZERO_DLY);
 821bd8c:	00801504 	movi	r2,84
 821bd90:	00003806 	br	821be74 <OSTimeDlyHMSM+0x14c>
                }
            }
        }
    }
    if (minutes > 59) {
 821bd94:	e0bffd03 	ldbu	r2,-12(fp)
 821bd98:	10800f30 	cmpltui	r2,r2,60
 821bd9c:	1000021e 	bne	r2,zero,821bda8 <OSTimeDlyHMSM+0x80>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 821bda0:	00801444 	movi	r2,81
 821bda4:	00003306 	br	821be74 <OSTimeDlyHMSM+0x14c>
    }
    if (seconds > 59) {
 821bda8:	e0bffe03 	ldbu	r2,-8(fp)
 821bdac:	10800f30 	cmpltui	r2,r2,60
 821bdb0:	1000021e 	bne	r2,zero,821bdbc <OSTimeDlyHMSM+0x94>
        return (OS_ERR_TIME_INVALID_SECONDS);
 821bdb4:	00801484 	movi	r2,82
 821bdb8:	00002e06 	br	821be74 <OSTimeDlyHMSM+0x14c>
    }
    if (ms > 999) {
 821bdbc:	e0bfff0b 	ldhu	r2,-4(fp)
 821bdc0:	1080fa30 	cmpltui	r2,r2,1000
 821bdc4:	1000021e 	bne	r2,zero,821bdd0 <OSTimeDlyHMSM+0xa8>
        return (OS_ERR_TIME_INVALID_MS);
 821bdc8:	008014c4 	movi	r2,83
 821bdcc:	00002906 	br	821be74 <OSTimeDlyHMSM+0x14c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821bdd0:	e0bffc03 	ldbu	r2,-16(fp)
 821bdd4:	10c38424 	muli	r3,r2,3600
 821bdd8:	e0bffd03 	ldbu	r2,-12(fp)
 821bddc:	10800f24 	muli	r2,r2,60
 821bde0:	1887883a 	add	r3,r3,r2
 821bde4:	e0bffe03 	ldbu	r2,-8(fp)
 821bde8:	1885883a 	add	r2,r3,r2
 821bdec:	11001924 	muli	r4,r2,100
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 821bdf0:	e0bfff0b 	ldhu	r2,-4(fp)
 821bdf4:	10801924 	muli	r2,r2,100
 821bdf8:	10c07d04 	addi	r3,r2,500
 821bdfc:	008418b4 	movhi	r2,4194
 821be00:	109374c4 	addi	r2,r2,19923
 821be04:	188a383a 	mulxuu	r5,r3,r2
 821be08:	1885383a 	mul	r2,r3,r2
 821be0c:	1011883a 	mov	r8,r2
 821be10:	2813883a 	mov	r9,r5
 821be14:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821be18:	2085883a 	add	r2,r4,r2
 821be1c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 821be20:	e0bffb17 	ldw	r2,-20(fp)
 821be24:	1004d43a 	srli	r2,r2,16
 821be28:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 821be2c:	e0bffb17 	ldw	r2,-20(fp)
 821be30:	10bfffcc 	andi	r2,r2,65535
 821be34:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
 821be38:	e0bffb17 	ldw	r2,-20(fp)
 821be3c:	10bfffcc 	andi	r2,r2,65535
 821be40:	1009883a 	mov	r4,r2
 821be44:	821bc240 	call	821bc24 <OSTimeDly>
    while (loops > 0) {
 821be48:	00000706 	br	821be68 <OSTimeDlyHMSM+0x140>
        OSTimeDly((INT16U)32768u);
 821be4c:	01200014 	movui	r4,32768
 821be50:	821bc240 	call	821bc24 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 821be54:	01200014 	movui	r4,32768
 821be58:	821bc240 	call	821bc24 <OSTimeDly>
        loops--;
 821be5c:	e0bffa0b 	ldhu	r2,-24(fp)
 821be60:	10bfffc4 	addi	r2,r2,-1
 821be64:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 821be68:	e0bffa0b 	ldhu	r2,-24(fp)
 821be6c:	103ff71e 	bne	r2,zero,821be4c <OSTimeDlyHMSM+0x124>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 821be70:	0005883a 	mov	r2,zero
}
 821be74:	e037883a 	mov	sp,fp
 821be78:	dfc00117 	ldw	ra,4(sp)
 821be7c:	df000017 	ldw	fp,0(sp)
 821be80:	dec00204 	addi	sp,sp,8
 821be84:	f800283a 	ret

0821be88 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 821be88:	defff504 	addi	sp,sp,-44
 821be8c:	dfc00a15 	stw	ra,40(sp)
 821be90:	df000915 	stw	fp,36(sp)
 821be94:	df000904 	addi	fp,sp,36
 821be98:	2005883a 	mov	r2,r4
 821be9c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821bea0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 821bea4:	e0bfff03 	ldbu	r2,-4(fp)
 821bea8:	10800530 	cmpltui	r2,r2,20
 821beac:	1000021e 	bne	r2,zero,821beb8 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821beb0:	00800a84 	movi	r2,42
 821beb4:	00006406 	br	821c048 <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821beb8:	0005303a 	rdctl	r2,status
 821bebc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bec0:	e0fffe17 	ldw	r3,-8(fp)
 821bec4:	00bfff84 	movi	r2,-2
 821bec8:	1884703a 	and	r2,r3,r2
 821becc:	1001703a 	wrctl	status,r2
  
  return context;
 821bed0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821bed4:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 821bed8:	e0ffff03 	ldbu	r3,-4(fp)
 821bedc:	008209b4 	movhi	r2,2086
 821bee0:	10b5c804 	addi	r2,r2,-10464
 821bee4:	18c7883a 	add	r3,r3,r3
 821bee8:	18c7883a 	add	r3,r3,r3
 821beec:	10c5883a 	add	r2,r2,r3
 821bef0:	10800017 	ldw	r2,0(r2)
 821bef4:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
 821bef8:	e0bff917 	ldw	r2,-28(fp)
 821befc:	1000061e 	bne	r2,zero,821bf18 <OSTimeDlyResume+0x90>
 821bf00:	e0bff717 	ldw	r2,-36(fp)
 821bf04:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bf08:	e0bff817 	ldw	r2,-32(fp)
 821bf0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821bf10:	008010c4 	movi	r2,67
 821bf14:	00004c06 	br	821c048 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821bf18:	e0bff917 	ldw	r2,-28(fp)
 821bf1c:	10800058 	cmpnei	r2,r2,1
 821bf20:	1000061e 	bne	r2,zero,821bf3c <OSTimeDlyResume+0xb4>
 821bf24:	e0bff717 	ldw	r2,-36(fp)
 821bf28:	e0bffa15 	stw	r2,-24(fp)
 821bf2c:	e0bffa17 	ldw	r2,-24(fp)
 821bf30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821bf34:	008010c4 	movi	r2,67
 821bf38:	00004306 	br	821c048 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 821bf3c:	e0bff917 	ldw	r2,-28(fp)
 821bf40:	10800b8b 	ldhu	r2,46(r2)
 821bf44:	10bfffcc 	andi	r2,r2,65535
 821bf48:	1000061e 	bne	r2,zero,821bf64 <OSTimeDlyResume+0xdc>
 821bf4c:	e0bff717 	ldw	r2,-36(fp)
 821bf50:	e0bffb15 	stw	r2,-20(fp)
 821bf54:	e0bffb17 	ldw	r2,-20(fp)
 821bf58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 821bf5c:	00801404 	movi	r2,80
 821bf60:	00003906 	br	821c048 <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 821bf64:	e0bff917 	ldw	r2,-28(fp)
 821bf68:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 821bf6c:	e0bff917 	ldw	r2,-28(fp)
 821bf70:	10800c03 	ldbu	r2,48(r2)
 821bf74:	10803fcc 	andi	r2,r2,255
 821bf78:	10800dcc 	andi	r2,r2,55
 821bf7c:	10000b26 	beq	r2,zero,821bfac <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 821bf80:	e0bff917 	ldw	r2,-28(fp)
 821bf84:	10c00c03 	ldbu	r3,48(r2)
 821bf88:	00bff204 	movi	r2,-56
 821bf8c:	1884703a 	and	r2,r3,r2
 821bf90:	1007883a 	mov	r3,r2
 821bf94:	e0bff917 	ldw	r2,-28(fp)
 821bf98:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 821bf9c:	e0bff917 	ldw	r2,-28(fp)
 821bfa0:	00c00044 	movi	r3,1
 821bfa4:	10c00c45 	stb	r3,49(r2)
 821bfa8:	00000206 	br	821bfb4 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 821bfac:	e0bff917 	ldw	r2,-28(fp)
 821bfb0:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 821bfb4:	e0bff917 	ldw	r2,-28(fp)
 821bfb8:	10800c03 	ldbu	r2,48(r2)
 821bfbc:	10803fcc 	andi	r2,r2,255
 821bfc0:	1080020c 	andi	r2,r2,8
 821bfc4:	10001b1e 	bne	r2,zero,821c034 <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 821bfc8:	e0bff917 	ldw	r2,-28(fp)
 821bfcc:	10c00d83 	ldbu	r3,54(r2)
 821bfd0:	d0a07703 	ldbu	r2,-32292(gp)
 821bfd4:	1884b03a 	or	r2,r3,r2
 821bfd8:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821bfdc:	e0bff917 	ldw	r2,-28(fp)
 821bfe0:	10800d03 	ldbu	r2,52(r2)
 821bfe4:	10c03fcc 	andi	r3,r2,255
 821bfe8:	e0bff917 	ldw	r2,-28(fp)
 821bfec:	10800d03 	ldbu	r2,52(r2)
 821bff0:	11003fcc 	andi	r4,r2,255
 821bff4:	d0a07744 	addi	r2,gp,-32291
 821bff8:	2085883a 	add	r2,r4,r2
 821bffc:	11000003 	ldbu	r4,0(r2)
 821c000:	e0bff917 	ldw	r2,-28(fp)
 821c004:	10800d43 	ldbu	r2,53(r2)
 821c008:	2084b03a 	or	r2,r4,r2
 821c00c:	1009883a 	mov	r4,r2
 821c010:	d0a07744 	addi	r2,gp,-32291
 821c014:	1885883a 	add	r2,r3,r2
 821c018:	11000005 	stb	r4,0(r2)
 821c01c:	e0bff717 	ldw	r2,-36(fp)
 821c020:	e0bffc15 	stw	r2,-16(fp)
 821c024:	e0bffc17 	ldw	r2,-16(fp)
 821c028:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 821c02c:	82162700 	call	8216270 <OS_Sched>
 821c030:	00000406 	br	821c044 <OSTimeDlyResume+0x1bc>
 821c034:	e0bff717 	ldw	r2,-36(fp)
 821c038:	e0bffd15 	stw	r2,-12(fp)
 821c03c:	e0bffd17 	ldw	r2,-12(fp)
 821c040:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 821c044:	0005883a 	mov	r2,zero
}
 821c048:	e037883a 	mov	sp,fp
 821c04c:	dfc00117 	ldw	ra,4(sp)
 821c050:	df000017 	ldw	fp,0(sp)
 821c054:	dec00204 	addi	sp,sp,8
 821c058:	f800283a 	ret

0821c05c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 821c05c:	defffb04 	addi	sp,sp,-20
 821c060:	df000415 	stw	fp,16(sp)
 821c064:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c068:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c06c:	0005303a 	rdctl	r2,status
 821c070:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c074:	e0fffe17 	ldw	r3,-8(fp)
 821c078:	00bfff84 	movi	r2,-2
 821c07c:	1884703a 	and	r2,r3,r2
 821c080:	1001703a 	wrctl	status,r2
  
  return context;
 821c084:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 821c088:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 821c08c:	d0a07b17 	ldw	r2,-32276(gp)
 821c090:	e0bffd15 	stw	r2,-12(fp)
 821c094:	e0bffc17 	ldw	r2,-16(fp)
 821c098:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c09c:	e0bfff17 	ldw	r2,-4(fp)
 821c0a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 821c0a4:	e0bffd17 	ldw	r2,-12(fp)
}
 821c0a8:	e037883a 	mov	sp,fp
 821c0ac:	df000017 	ldw	fp,0(sp)
 821c0b0:	dec00104 	addi	sp,sp,4
 821c0b4:	f800283a 	ret

0821c0b8 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 821c0b8:	defffb04 	addi	sp,sp,-20
 821c0bc:	df000415 	stw	fp,16(sp)
 821c0c0:	df000404 	addi	fp,sp,16
 821c0c4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c0c8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c0cc:	0005303a 	rdctl	r2,status
 821c0d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c0d4:	e0fffd17 	ldw	r3,-12(fp)
 821c0d8:	00bfff84 	movi	r2,-2
 821c0dc:	1884703a 	and	r2,r3,r2
 821c0e0:	1001703a 	wrctl	status,r2
  
  return context;
 821c0e4:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 821c0e8:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 821c0ec:	e0bfff17 	ldw	r2,-4(fp)
 821c0f0:	d0a07b15 	stw	r2,-32276(gp)
 821c0f4:	e0bffc17 	ldw	r2,-16(fp)
 821c0f8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c0fc:	e0bffe17 	ldw	r2,-8(fp)
 821c100:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 821c104:	0001883a 	nop
 821c108:	e037883a 	mov	sp,fp
 821c10c:	df000017 	ldw	fp,0(sp)
 821c110:	dec00104 	addi	sp,sp,4
 821c114:	f800283a 	ret

0821c118 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 821c118:	defffd04 	addi	sp,sp,-12
 821c11c:	dfc00215 	stw	ra,8(sp)
 821c120:	df000115 	stw	fp,4(sp)
 821c124:	df000104 	addi	fp,sp,4
 821c128:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 821c12c:	d1604404 	addi	r5,gp,-32496
 821c130:	e13fff17 	ldw	r4,-4(fp)
 821c134:	823bb380 	call	823bb38 <alt_dev_llist_insert>
}
 821c138:	e037883a 	mov	sp,fp
 821c13c:	dfc00117 	ldw	ra,4(sp)
 821c140:	df000017 	ldw	fp,0(sp)
 821c144:	dec00204 	addi	sp,sp,8
 821c148:	f800283a 	ret

0821c14c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 821c14c:	defffd04 	addi	sp,sp,-12
 821c150:	dfc00215 	stw	ra,8(sp)
 821c154:	df000115 	stw	fp,4(sp)
 821c158:	df000104 	addi	fp,sp,4
 821c15c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 821c160:	823c9dc0 	call	823c9dc <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 821c164:	00800044 	movi	r2,1
 821c168:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 821c16c:	0001883a 	nop
 821c170:	e037883a 	mov	sp,fp
 821c174:	dfc00117 	ldw	ra,4(sp)
 821c178:	df000017 	ldw	fp,0(sp)
 821c17c:	dec00204 	addi	sp,sp,8
 821c180:	f800283a 	ret

0821c184 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 821c184:	defffa04 	addi	sp,sp,-24
 821c188:	dfc00515 	stw	ra,20(sp)
 821c18c:	df000415 	stw	fp,16(sp)
 821c190:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 821c194:	01c01904 	movi	r7,100
 821c198:	000d883a 	mov	r6,zero
 821c19c:	000b883a 	mov	r5,zero
 821c1a0:	01024034 	movhi	r4,2304
 821c1a4:	821ee540 	call	821ee54 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 821c1a8:	01800044 	movi	r6,1
 821c1ac:	000b883a 	mov	r5,zero
 821c1b0:	01020974 	movhi	r4,2085
 821c1b4:	21095204 	addi	r4,r4,9544
 821c1b8:	821c5200 	call	821c520 <altera_avalon_jtag_uart_init>
 821c1bc:	01020974 	movhi	r4,2085
 821c1c0:	21094804 	addi	r4,r4,9504
 821c1c4:	821c1180 	call	821c118 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 821c1c8:	01020974 	movhi	r4,2085
 821c1cc:	210d6d04 	addi	r4,r4,13748
 821c1d0:	821de680 	call	821de68 <altera_avalon_lcd_16207_init>
 821c1d4:	01020974 	movhi	r4,2085
 821c1d8:	210d6304 	addi	r4,r4,13708
 821c1dc:	821c1180 	call	821c118 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 821c1e0:	01800084 	movi	r6,2
 821c1e4:	000b883a 	mov	r5,zero
 821c1e8:	01020974 	movhi	r4,2085
 821c1ec:	210dac04 	addi	r4,r4,14000
 821c1f0:	821ed340 	call	821ed34 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 821c1f4:	018000c4 	movi	r6,3
 821c1f8:	000b883a 	mov	r5,zero
 821c1fc:	01020974 	movhi	r4,2085
 821c200:	210db804 	addi	r4,r4,14048
 821c204:	821ed340 	call	821ed34 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 821c208:	0001883a 	nop
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 821c20c:	e03ffc15 	stw	zero,-16(fp)
 821c210:	00800044 	movi	r2,1
 821c214:	e0bffd15 	stw	r2,-12(fp)
 821c218:	e0bffd17 	ldw	r2,-12(fp)
 821c21c:	00800216 	blt	zero,r2,821c228 <alt_sys_init+0xa4>
 821c220:	00800044 	movi	r2,1
 821c224:	e0bffd15 	stw	r2,-12(fp)
 821c228:	e03ffc15 	stw	zero,-16(fp)
 821c22c:	00005a06 	br	821c398 <alt_sys_init+0x214>
 821c230:	008209b4 	movhi	r2,2086
 821c234:	10b5dd04 	addi	r2,r2,-10380
 821c238:	e0fffc17 	ldw	r3,-16(fp)
 821c23c:	18c00724 	muli	r3,r3,28
 821c240:	10c5883a 	add	r2,r2,r3
 821c244:	10000015 	stw	zero,0(r2)
 821c248:	008209b4 	movhi	r2,2086
 821c24c:	10b5dd04 	addi	r2,r2,-10380
 821c250:	e0fffc17 	ldw	r3,-16(fp)
 821c254:	18c00724 	muli	r3,r3,28
 821c258:	10c5883a 	add	r2,r2,r3
 821c25c:	10800104 	addi	r2,r2,4
 821c260:	10000015 	stw	zero,0(r2)
 821c264:	d0e02917 	ldw	r3,-32604(gp)
 821c268:	008209b4 	movhi	r2,2086
 821c26c:	10b5dd04 	addi	r2,r2,-10380
 821c270:	e13ffc17 	ldw	r4,-16(fp)
 821c274:	21000724 	muli	r4,r4,28
 821c278:	1105883a 	add	r2,r2,r4
 821c27c:	10800204 	addi	r2,r2,8
 821c280:	10c00015 	stw	r3,0(r2)
 821c284:	008209b4 	movhi	r2,2086
 821c288:	10b5dd04 	addi	r2,r2,-10380
 821c28c:	e0fffc17 	ldw	r3,-16(fp)
 821c290:	18c00724 	muli	r3,r3,28
 821c294:	10c5883a 	add	r2,r2,r3
 821c298:	10c00304 	addi	r3,r2,12
 821c29c:	008208b4 	movhi	r2,2082
 821c2a0:	108fb004 	addi	r2,r2,16064
 821c2a4:	18800015 	stw	r2,0(r3)
 821c2a8:	e0bffc17 	ldw	r2,-16(fp)
 821c2ac:	10c00724 	muli	r3,r2,28
 821c2b0:	008209b4 	movhi	r2,2086
 821c2b4:	10b5dd04 	addi	r2,r2,-10380
 821c2b8:	1885883a 	add	r2,r3,r2
 821c2bc:	d0e02e04 	addi	r3,gp,-32584
 821c2c0:	e0fffe15 	stw	r3,-8(fp)
 821c2c4:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 821c2c8:	e0bfff17 	ldw	r2,-4(fp)
 821c2cc:	e0fffe17 	ldw	r3,-8(fp)
 821c2d0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 821c2d4:	e0bffe17 	ldw	r2,-8(fp)
 821c2d8:	10c00017 	ldw	r3,0(r2)
 821c2dc:	e0bfff17 	ldw	r2,-4(fp)
 821c2e0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 821c2e4:	e0bffe17 	ldw	r2,-8(fp)
 821c2e8:	10800017 	ldw	r2,0(r2)
 821c2ec:	e0ffff17 	ldw	r3,-4(fp)
 821c2f0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 821c2f4:	e0bffe17 	ldw	r2,-8(fp)
 821c2f8:	e0ffff17 	ldw	r3,-4(fp)
 821c2fc:	10c00015 	stw	r3,0(r2)
 821c300:	d0a08003 	ldbu	r2,-32256(gp)
 821c304:	11003fcc 	andi	r4,r2,255
 821c308:	e0bffc17 	ldw	r2,-16(fp)
 821c30c:	10c00724 	muli	r3,r2,28
 821c310:	008209b4 	movhi	r2,2086
 821c314:	10b5dd04 	addi	r2,r2,-10380
 821c318:	1887883a 	add	r3,r3,r2
 821c31c:	008209b4 	movhi	r2,2086
 821c320:	10b61d04 	addi	r2,r2,-10124
 821c324:	21000324 	muli	r4,r4,12
 821c328:	1105883a 	add	r2,r2,r4
 821c32c:	10c00015 	stw	r3,0(r2)
 821c330:	d0a08003 	ldbu	r2,-32256(gp)
 821c334:	10c03fcc 	andi	r3,r2,255
 821c338:	008209b4 	movhi	r2,2086
 821c33c:	10b61d04 	addi	r2,r2,-10124
 821c340:	18c00324 	muli	r3,r3,12
 821c344:	10c5883a 	add	r2,r2,r3
 821c348:	10c00104 	addi	r3,r2,4
 821c34c:	00820034 	movhi	r2,2048
 821c350:	108c0004 	addi	r2,r2,12288
 821c354:	18800015 	stw	r2,0(r3)
 821c358:	d0a08003 	ldbu	r2,-32256(gp)
 821c35c:	10c03fcc 	andi	r3,r2,255
 821c360:	e0bffc17 	ldw	r2,-16(fp)
 821c364:	1009883a 	mov	r4,r2
 821c368:	008209b4 	movhi	r2,2086
 821c36c:	10b61d04 	addi	r2,r2,-10124
 821c370:	18c00324 	muli	r3,r3,12
 821c374:	10c5883a 	add	r2,r2,r3
 821c378:	10800204 	addi	r2,r2,8
 821c37c:	11000005 	stb	r4,0(r2)
 821c380:	d0a08003 	ldbu	r2,-32256(gp)
 821c384:	10800044 	addi	r2,r2,1
 821c388:	d0a08005 	stb	r2,-32256(gp)
 821c38c:	e0bffc17 	ldw	r2,-16(fp)
 821c390:	10800044 	addi	r2,r2,1
 821c394:	e0bffc15 	stw	r2,-16(fp)
 821c398:	e0fffc17 	ldw	r3,-16(fp)
 821c39c:	e0bffd17 	ldw	r2,-12(fp)
 821c3a0:	18bfa316 	blt	r3,r2,821c230 <alt_sys_init+0xac>
}
 821c3a4:	0001883a 	nop
 821c3a8:	e037883a 	mov	sp,fp
 821c3ac:	dfc00117 	ldw	ra,4(sp)
 821c3b0:	df000017 	ldw	fp,0(sp)
 821c3b4:	dec00204 	addi	sp,sp,8
 821c3b8:	f800283a 	ret

0821c3bc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 821c3bc:	defffa04 	addi	sp,sp,-24
 821c3c0:	dfc00515 	stw	ra,20(sp)
 821c3c4:	df000415 	stw	fp,16(sp)
 821c3c8:	df000404 	addi	fp,sp,16
 821c3cc:	e13ffd15 	stw	r4,-12(fp)
 821c3d0:	e17ffe15 	stw	r5,-8(fp)
 821c3d4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c3d8:	e0bffd17 	ldw	r2,-12(fp)
 821c3dc:	10800017 	ldw	r2,0(r2)
 821c3e0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 821c3e4:	e0bffc17 	ldw	r2,-16(fp)
 821c3e8:	10c00a04 	addi	r3,r2,40
 821c3ec:	e0bffd17 	ldw	r2,-12(fp)
 821c3f0:	10800217 	ldw	r2,8(r2)
 821c3f4:	100f883a 	mov	r7,r2
 821c3f8:	e1bfff17 	ldw	r6,-4(fp)
 821c3fc:	e17ffe17 	ldw	r5,-8(fp)
 821c400:	1809883a 	mov	r4,r3
 821c404:	821cb680 	call	821cb68 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 821c408:	e037883a 	mov	sp,fp
 821c40c:	dfc00117 	ldw	ra,4(sp)
 821c410:	df000017 	ldw	fp,0(sp)
 821c414:	dec00204 	addi	sp,sp,8
 821c418:	f800283a 	ret

0821c41c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821c41c:	defffa04 	addi	sp,sp,-24
 821c420:	dfc00515 	stw	ra,20(sp)
 821c424:	df000415 	stw	fp,16(sp)
 821c428:	df000404 	addi	fp,sp,16
 821c42c:	e13ffd15 	stw	r4,-12(fp)
 821c430:	e17ffe15 	stw	r5,-8(fp)
 821c434:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c438:	e0bffd17 	ldw	r2,-12(fp)
 821c43c:	10800017 	ldw	r2,0(r2)
 821c440:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 821c444:	e0bffc17 	ldw	r2,-16(fp)
 821c448:	10c00a04 	addi	r3,r2,40
 821c44c:	e0bffd17 	ldw	r2,-12(fp)
 821c450:	10800217 	ldw	r2,8(r2)
 821c454:	100f883a 	mov	r7,r2
 821c458:	e1bfff17 	ldw	r6,-4(fp)
 821c45c:	e17ffe17 	ldw	r5,-8(fp)
 821c460:	1809883a 	mov	r4,r3
 821c464:	821ce240 	call	821ce24 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 821c468:	e037883a 	mov	sp,fp
 821c46c:	dfc00117 	ldw	ra,4(sp)
 821c470:	df000017 	ldw	fp,0(sp)
 821c474:	dec00204 	addi	sp,sp,8
 821c478:	f800283a 	ret

0821c47c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 821c47c:	defffc04 	addi	sp,sp,-16
 821c480:	dfc00315 	stw	ra,12(sp)
 821c484:	df000215 	stw	fp,8(sp)
 821c488:	df000204 	addi	fp,sp,8
 821c48c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c490:	e0bfff17 	ldw	r2,-4(fp)
 821c494:	10800017 	ldw	r2,0(r2)
 821c498:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 821c49c:	e0bffe17 	ldw	r2,-8(fp)
 821c4a0:	10c00a04 	addi	r3,r2,40
 821c4a4:	e0bfff17 	ldw	r2,-4(fp)
 821c4a8:	10800217 	ldw	r2,8(r2)
 821c4ac:	100b883a 	mov	r5,r2
 821c4b0:	1809883a 	mov	r4,r3
 821c4b4:	821ca100 	call	821ca10 <altera_avalon_jtag_uart_close>
}
 821c4b8:	e037883a 	mov	sp,fp
 821c4bc:	dfc00117 	ldw	ra,4(sp)
 821c4c0:	df000017 	ldw	fp,0(sp)
 821c4c4:	dec00204 	addi	sp,sp,8
 821c4c8:	f800283a 	ret

0821c4cc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 821c4cc:	defffa04 	addi	sp,sp,-24
 821c4d0:	dfc00515 	stw	ra,20(sp)
 821c4d4:	df000415 	stw	fp,16(sp)
 821c4d8:	df000404 	addi	fp,sp,16
 821c4dc:	e13ffd15 	stw	r4,-12(fp)
 821c4e0:	e17ffe15 	stw	r5,-8(fp)
 821c4e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 821c4e8:	e0bffd17 	ldw	r2,-12(fp)
 821c4ec:	10800017 	ldw	r2,0(r2)
 821c4f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 821c4f4:	e0bffc17 	ldw	r2,-16(fp)
 821c4f8:	10800a04 	addi	r2,r2,40
 821c4fc:	e1bfff17 	ldw	r6,-4(fp)
 821c500:	e17ffe17 	ldw	r5,-8(fp)
 821c504:	1009883a 	mov	r4,r2
 821c508:	821ca780 	call	821ca78 <altera_avalon_jtag_uart_ioctl>
}
 821c50c:	e037883a 	mov	sp,fp
 821c510:	dfc00117 	ldw	ra,4(sp)
 821c514:	df000017 	ldw	fp,0(sp)
 821c518:	dec00204 	addi	sp,sp,8
 821c51c:	f800283a 	ret

0821c520 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 821c520:	defff104 	addi	sp,sp,-60
 821c524:	dfc00e15 	stw	ra,56(sp)
 821c528:	df000d15 	stw	fp,52(sp)
 821c52c:	df000d04 	addi	fp,sp,52
 821c530:	e13ff915 	stw	r4,-28(fp)
 821c534:	e17ffa15 	stw	r5,-24(fp)
 821c538:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 821c53c:	e0bff917 	ldw	r2,-28(fp)
 821c540:	10800c04 	addi	r2,r2,48
 821c544:	e0bff415 	stw	r2,-48(fp)
 821c548:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 821c54c:	e0bff80b 	ldhu	r2,-32(fp)
 821c550:	e0fff884 	addi	r3,fp,-30
 821c554:	180b883a 	mov	r5,r3
 821c558:	1009883a 	mov	r4,r2
 821c55c:	8216df40 	call	8216df4 <OSFlagCreate>
 821c560:	1007883a 	mov	r3,r2
 821c564:	e0bff417 	ldw	r2,-48(fp)
 821c568:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 821c56c:	e0bff917 	ldw	r2,-28(fp)
 821c570:	10800a04 	addi	r2,r2,40
 821c574:	e0bff515 	stw	r2,-44(fp)
 821c578:	00800044 	movi	r2,1
 821c57c:	e0bff78d 	sth	r2,-34(fp)
 821c580:	e0bff78b 	ldhu	r2,-34(fp)
 821c584:	1009883a 	mov	r4,r2
 821c588:	8219b080 	call	8219b08 <OSSemCreate>
 821c58c:	1007883a 	mov	r3,r2
 821c590:	e0bff517 	ldw	r2,-44(fp)
 821c594:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 821c598:	e0bff917 	ldw	r2,-28(fp)
 821c59c:	10800b04 	addi	r2,r2,44
 821c5a0:	e0bff615 	stw	r2,-40(fp)
 821c5a4:	00800044 	movi	r2,1
 821c5a8:	e0bff70d 	sth	r2,-36(fp)
 821c5ac:	e0bff70b 	ldhu	r2,-36(fp)
 821c5b0:	1009883a 	mov	r4,r2
 821c5b4:	8219b080 	call	8219b08 <OSSemCreate>
 821c5b8:	1007883a 	mov	r3,r2
 821c5bc:	e0bff617 	ldw	r2,-40(fp)
 821c5c0:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c5c4:	e0bff917 	ldw	r2,-28(fp)
 821c5c8:	00c00044 	movi	r3,1
 821c5cc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 821c5d0:	e0bff917 	ldw	r2,-28(fp)
 821c5d4:	10800017 	ldw	r2,0(r2)
 821c5d8:	10800104 	addi	r2,r2,4
 821c5dc:	1007883a 	mov	r3,r2
 821c5e0:	e0bff917 	ldw	r2,-28(fp)
 821c5e4:	10800817 	ldw	r2,32(r2)
 821c5e8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 821c5ec:	e0bffa17 	ldw	r2,-24(fp)
 821c5f0:	e0fffb17 	ldw	r3,-20(fp)
 821c5f4:	d8000015 	stw	zero,0(sp)
 821c5f8:	e1fff917 	ldw	r7,-28(fp)
 821c5fc:	018208b4 	movhi	r6,2082
 821c600:	31b19a04 	addi	r6,r6,-14744
 821c604:	180b883a 	mov	r5,r3
 821c608:	1009883a 	mov	r4,r2
 821c60c:	823bd2c0 	call	823bd2c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 821c610:	e0bff917 	ldw	r2,-28(fp)
 821c614:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 821c618:	e0bff917 	ldw	r2,-28(fp)
 821c61c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 821c620:	d0e0b817 	ldw	r3,-32032(gp)
 821c624:	e1fff917 	ldw	r7,-28(fp)
 821c628:	018208b4 	movhi	r6,2082
 821c62c:	31b24304 	addi	r6,r6,-14068
 821c630:	180b883a 	mov	r5,r3
 821c634:	1009883a 	mov	r4,r2
 821c638:	823b8200 	call	823b820 <alt_alarm_start>
 821c63c:	1000040e 	bge	r2,zero,821c650 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 821c640:	e0fff917 	ldw	r3,-28(fp)
 821c644:	00a00034 	movhi	r2,32768
 821c648:	10bfffc4 	addi	r2,r2,-1
 821c64c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 821c650:	0001883a 	nop
 821c654:	e037883a 	mov	sp,fp
 821c658:	dfc00117 	ldw	ra,4(sp)
 821c65c:	df000017 	ldw	fp,0(sp)
 821c660:	dec00204 	addi	sp,sp,8
 821c664:	f800283a 	ret

0821c668 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 821c668:	defff204 	addi	sp,sp,-56
 821c66c:	dfc00d15 	stw	ra,52(sp)
 821c670:	df000c15 	stw	fp,48(sp)
 821c674:	df000c04 	addi	fp,sp,48
 821c678:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 821c67c:	e0bfff17 	ldw	r2,-4(fp)
 821c680:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
 821c684:	e0bff617 	ldw	r2,-40(fp)
 821c688:	10800017 	ldw	r2,0(r2)
 821c68c:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c690:	e0bff717 	ldw	r2,-36(fp)
 821c694:	10800104 	addi	r2,r2,4
 821c698:	10800037 	ldwio	r2,0(r2)
 821c69c:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 821c6a0:	e0bff817 	ldw	r2,-32(fp)
 821c6a4:	1080c00c 	andi	r2,r2,768
 821c6a8:	10009126 	beq	r2,zero,821c8f0 <altera_avalon_jtag_uart_irq+0x288>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 821c6ac:	e0bff817 	ldw	r2,-32(fp)
 821c6b0:	1080400c 	andi	r2,r2,256
 821c6b4:	10004726 	beq	r2,zero,821c7d4 <altera_avalon_jtag_uart_irq+0x16c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 821c6b8:	00800074 	movhi	r2,1
 821c6bc:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c6c0:	e0bff617 	ldw	r2,-40(fp)
 821c6c4:	10800d17 	ldw	r2,52(r2)
 821c6c8:	10800044 	addi	r2,r2,1
 821c6cc:	1081ffcc 	andi	r2,r2,2047
 821c6d0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 821c6d4:	e0bff617 	ldw	r2,-40(fp)
 821c6d8:	10c00e17 	ldw	r3,56(r2)
 821c6dc:	e0bff917 	ldw	r2,-28(fp)
 821c6e0:	18802726 	beq	r3,r2,821c780 <altera_avalon_jtag_uart_irq+0x118>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 821c6e4:	e0bff717 	ldw	r2,-36(fp)
 821c6e8:	10800037 	ldwio	r2,0(r2)
 821c6ec:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 821c6f0:	e0bff417 	ldw	r2,-48(fp)
 821c6f4:	10a0000c 	andi	r2,r2,32768
 821c6f8:	10002326 	beq	r2,zero,821c788 <altera_avalon_jtag_uart_irq+0x120>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 821c6fc:	e0bff617 	ldw	r2,-40(fp)
 821c700:	10800d17 	ldw	r2,52(r2)
 821c704:	e0fff417 	ldw	r3,-48(fp)
 821c708:	1809883a 	mov	r4,r3
 821c70c:	e0fff617 	ldw	r3,-40(fp)
 821c710:	1885883a 	add	r2,r3,r2
 821c714:	10801104 	addi	r2,r2,68
 821c718:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c71c:	e0bff617 	ldw	r2,-40(fp)
 821c720:	10800d17 	ldw	r2,52(r2)
 821c724:	10800044 	addi	r2,r2,1
 821c728:	10c1ffcc 	andi	r3,r2,2047
 821c72c:	e0bff617 	ldw	r2,-40(fp)
 821c730:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 821c734:	e0bff617 	ldw	r2,-40(fp)
 821c738:	10800c17 	ldw	r2,48(r2)
 821c73c:	e0bffb15 	stw	r2,-20(fp)
 821c740:	00800044 	movi	r2,1
 821c744:	e0bffc0d 	sth	r2,-16(fp)
 821c748:	00800044 	movi	r2,1
 821c74c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c750:	d0a06b43 	ldbu	r2,-32339(gp)
 821c754:	10803fcc 	andi	r2,r2,255
 821c758:	103fd926 	beq	r2,zero,821c6c0 <altera_avalon_jtag_uart_irq+0x58>
  {
    OSFlagPost (group, flags, opt, &err);
 821c75c:	e0bffc0b 	ldhu	r2,-16(fp)
 821c760:	e0fffc83 	ldbu	r3,-14(fp)
 821c764:	e13ffdc4 	addi	r4,fp,-9
 821c768:	200f883a 	mov	r7,r4
 821c76c:	180d883a 	mov	r6,r3
 821c770:	100b883a 	mov	r5,r2
 821c774:	e13ffb17 	ldw	r4,-20(fp)
 821c778:	82179d00 	call	82179d0 <OSFlagPost>
      }
 821c77c:	003fd006 	br	821c6c0 <altera_avalon_jtag_uart_irq+0x58>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 821c780:	0001883a 	nop
 821c784:	00000106 	br	821c78c <altera_avalon_jtag_uart_irq+0x124>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 821c788:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 821c78c:	e0bff417 	ldw	r2,-48(fp)
 821c790:	10bfffec 	andhi	r2,r2,65535
 821c794:	10000f26 	beq	r2,zero,821c7d4 <altera_avalon_jtag_uart_irq+0x16c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c798:	e0bff617 	ldw	r2,-40(fp)
 821c79c:	10c00817 	ldw	r3,32(r2)
 821c7a0:	00bfff84 	movi	r2,-2
 821c7a4:	1886703a 	and	r3,r3,r2
 821c7a8:	e0bff617 	ldw	r2,-40(fp)
 821c7ac:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 821c7b0:	e0bff717 	ldw	r2,-36(fp)
 821c7b4:	10800104 	addi	r2,r2,4
 821c7b8:	1007883a 	mov	r3,r2
 821c7bc:	e0bff617 	ldw	r2,-40(fp)
 821c7c0:	10800817 	ldw	r2,32(r2)
 821c7c4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c7c8:	e0bff717 	ldw	r2,-36(fp)
 821c7cc:	10800104 	addi	r2,r2,4
 821c7d0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 821c7d4:	e0bff817 	ldw	r2,-32(fp)
 821c7d8:	1080800c 	andi	r2,r2,512
 821c7dc:	103fac26 	beq	r2,zero,821c690 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 821c7e0:	e0bff817 	ldw	r2,-32(fp)
 821c7e4:	1004d43a 	srli	r2,r2,16
 821c7e8:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 821c7ec:	00002606 	br	821c888 <altera_avalon_jtag_uart_irq+0x220>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 821c7f0:	e0bff717 	ldw	r2,-36(fp)
 821c7f4:	e0fff617 	ldw	r3,-40(fp)
 821c7f8:	18c01017 	ldw	r3,64(r3)
 821c7fc:	e13ff617 	ldw	r4,-40(fp)
 821c800:	20c7883a 	add	r3,r4,r3
 821c804:	18c21104 	addi	r3,r3,2116
 821c808:	18c00003 	ldbu	r3,0(r3)
 821c80c:	18c03fcc 	andi	r3,r3,255
 821c810:	18c0201c 	xori	r3,r3,128
 821c814:	18ffe004 	addi	r3,r3,-128
 821c818:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c81c:	e0bff617 	ldw	r2,-40(fp)
 821c820:	10801017 	ldw	r2,64(r2)
 821c824:	10800044 	addi	r2,r2,1
 821c828:	10c1ffcc 	andi	r3,r2,2047
 821c82c:	e0bff617 	ldw	r2,-40(fp)
 821c830:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 821c834:	e0bff617 	ldw	r2,-40(fp)
 821c838:	10800c17 	ldw	r2,48(r2)
 821c83c:	e0bffa15 	stw	r2,-24(fp)
 821c840:	00800084 	movi	r2,2
 821c844:	e0bffd0d 	sth	r2,-12(fp)
 821c848:	00800044 	movi	r2,1
 821c84c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c850:	d0a06b43 	ldbu	r2,-32339(gp)
 821c854:	10803fcc 	andi	r2,r2,255
 821c858:	10000826 	beq	r2,zero,821c87c <altera_avalon_jtag_uart_irq+0x214>
  {
    OSFlagPost (group, flags, opt, &err);
 821c85c:	e0bffd0b 	ldhu	r2,-12(fp)
 821c860:	e0fffd83 	ldbu	r3,-10(fp)
 821c864:	e13ffe04 	addi	r4,fp,-8
 821c868:	200f883a 	mov	r7,r4
 821c86c:	180d883a 	mov	r6,r3
 821c870:	100b883a 	mov	r5,r2
 821c874:	e13ffa17 	ldw	r4,-24(fp)
 821c878:	82179d00 	call	82179d0 <OSFlagPost>

        space--;
 821c87c:	e0bff517 	ldw	r2,-44(fp)
 821c880:	10bfffc4 	addi	r2,r2,-1
 821c884:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 821c888:	e0bff517 	ldw	r2,-44(fp)
 821c88c:	10000526 	beq	r2,zero,821c8a4 <altera_avalon_jtag_uart_irq+0x23c>
 821c890:	e0bff617 	ldw	r2,-40(fp)
 821c894:	10c01017 	ldw	r3,64(r2)
 821c898:	e0bff617 	ldw	r2,-40(fp)
 821c89c:	10800f17 	ldw	r2,60(r2)
 821c8a0:	18bfd31e 	bne	r3,r2,821c7f0 <altera_avalon_jtag_uart_irq+0x188>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 821c8a4:	e0bff517 	ldw	r2,-44(fp)
 821c8a8:	103f7926 	beq	r2,zero,821c690 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821c8ac:	e0bff617 	ldw	r2,-40(fp)
 821c8b0:	10c00817 	ldw	r3,32(r2)
 821c8b4:	00bfff44 	movi	r2,-3
 821c8b8:	1886703a 	and	r3,r3,r2
 821c8bc:	e0bff617 	ldw	r2,-40(fp)
 821c8c0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821c8c4:	e0bff617 	ldw	r2,-40(fp)
 821c8c8:	10800017 	ldw	r2,0(r2)
 821c8cc:	10800104 	addi	r2,r2,4
 821c8d0:	1007883a 	mov	r3,r2
 821c8d4:	e0bff617 	ldw	r2,-40(fp)
 821c8d8:	10800817 	ldw	r2,32(r2)
 821c8dc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c8e0:	e0bff717 	ldw	r2,-36(fp)
 821c8e4:	10800104 	addi	r2,r2,4
 821c8e8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 821c8ec:	003f6806 	br	821c690 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 821c8f0:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 821c8f4:	0001883a 	nop
 821c8f8:	e037883a 	mov	sp,fp
 821c8fc:	dfc00117 	ldw	ra,4(sp)
 821c900:	df000017 	ldw	fp,0(sp)
 821c904:	dec00204 	addi	sp,sp,8
 821c908:	f800283a 	ret

0821c90c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 821c90c:	defff904 	addi	sp,sp,-28
 821c910:	dfc00615 	stw	ra,24(sp)
 821c914:	df000515 	stw	fp,20(sp)
 821c918:	df000504 	addi	fp,sp,20
 821c91c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 821c920:	e0bfff17 	ldw	r2,-4(fp)
 821c924:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 821c928:	e0bffb17 	ldw	r2,-20(fp)
 821c92c:	10800017 	ldw	r2,0(r2)
 821c930:	10800104 	addi	r2,r2,4
 821c934:	10800037 	ldwio	r2,0(r2)
 821c938:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 821c93c:	e0bffc17 	ldw	r2,-16(fp)
 821c940:	1081000c 	andi	r2,r2,1024
 821c944:	10000b26 	beq	r2,zero,821c974 <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 821c948:	e0bffb17 	ldw	r2,-20(fp)
 821c94c:	10800017 	ldw	r2,0(r2)
 821c950:	10800104 	addi	r2,r2,4
 821c954:	1007883a 	mov	r3,r2
 821c958:	e0bffb17 	ldw	r2,-20(fp)
 821c95c:	10800817 	ldw	r2,32(r2)
 821c960:	10810014 	ori	r2,r2,1024
 821c964:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 821c968:	e0bffb17 	ldw	r2,-20(fp)
 821c96c:	10000915 	stw	zero,36(r2)
 821c970:	00002106 	br	821c9f8 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 821c974:	e0bffb17 	ldw	r2,-20(fp)
 821c978:	10c00917 	ldw	r3,36(r2)
 821c97c:	00a00034 	movhi	r2,32768
 821c980:	10bfff04 	addi	r2,r2,-4
 821c984:	10c01c36 	bltu	r2,r3,821c9f8 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 821c988:	e0bffb17 	ldw	r2,-20(fp)
 821c98c:	10800917 	ldw	r2,36(r2)
 821c990:	10c00044 	addi	r3,r2,1
 821c994:	e0bffb17 	ldw	r2,-20(fp)
 821c998:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 821c99c:	e0bffb17 	ldw	r2,-20(fp)
 821c9a0:	10c00917 	ldw	r3,36(r2)
 821c9a4:	e0bffb17 	ldw	r2,-20(fp)
 821c9a8:	10800117 	ldw	r2,4(r2)
 821c9ac:	18801236 	bltu	r3,r2,821c9f8 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 821c9b0:	e0bffb17 	ldw	r2,-20(fp)
 821c9b4:	10800c17 	ldw	r2,48(r2)
 821c9b8:	e0bffd15 	stw	r2,-12(fp)
 821c9bc:	00800104 	movi	r2,4
 821c9c0:	e0bffe0d 	sth	r2,-8(fp)
 821c9c4:	00800044 	movi	r2,1
 821c9c8:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c9cc:	d0a06b43 	ldbu	r2,-32339(gp)
 821c9d0:	10803fcc 	andi	r2,r2,255
 821c9d4:	10000826 	beq	r2,zero,821c9f8 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 821c9d8:	e0bffe0b 	ldhu	r2,-8(fp)
 821c9dc:	e0fffe83 	ldbu	r3,-6(fp)
 821c9e0:	e13ffec4 	addi	r4,fp,-5
 821c9e4:	200f883a 	mov	r7,r4
 821c9e8:	180d883a 	mov	r6,r3
 821c9ec:	100b883a 	mov	r5,r2
 821c9f0:	e13ffd17 	ldw	r4,-12(fp)
 821c9f4:	82179d00 	call	82179d0 <OSFlagPost>
 821c9f8:	d0a0b817 	ldw	r2,-32032(gp)
    }
  }

  return alt_ticks_per_second();
}
 821c9fc:	e037883a 	mov	sp,fp
 821ca00:	dfc00117 	ldw	ra,4(sp)
 821ca04:	df000017 	ldw	fp,0(sp)
 821ca08:	dec00204 	addi	sp,sp,8
 821ca0c:	f800283a 	ret

0821ca10 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 821ca10:	defffd04 	addi	sp,sp,-12
 821ca14:	df000215 	stw	fp,8(sp)
 821ca18:	df000204 	addi	fp,sp,8
 821ca1c:	e13ffe15 	stw	r4,-8(fp)
 821ca20:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821ca24:	00000506 	br	821ca3c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 821ca28:	e0bfff17 	ldw	r2,-4(fp)
 821ca2c:	1090000c 	andi	r2,r2,16384
 821ca30:	10000226 	beq	r2,zero,821ca3c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 821ca34:	00bffd44 	movi	r2,-11
 821ca38:	00000b06 	br	821ca68 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821ca3c:	e0bffe17 	ldw	r2,-8(fp)
 821ca40:	10c01017 	ldw	r3,64(r2)
 821ca44:	e0bffe17 	ldw	r2,-8(fp)
 821ca48:	10800f17 	ldw	r2,60(r2)
 821ca4c:	18800526 	beq	r3,r2,821ca64 <altera_avalon_jtag_uart_close+0x54>
 821ca50:	e0bffe17 	ldw	r2,-8(fp)
 821ca54:	10c00917 	ldw	r3,36(r2)
 821ca58:	e0bffe17 	ldw	r2,-8(fp)
 821ca5c:	10800117 	ldw	r2,4(r2)
 821ca60:	18bff136 	bltu	r3,r2,821ca28 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 821ca64:	0005883a 	mov	r2,zero
}
 821ca68:	e037883a 	mov	sp,fp
 821ca6c:	df000017 	ldw	fp,0(sp)
 821ca70:	dec00104 	addi	sp,sp,4
 821ca74:	f800283a 	ret

0821ca78 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 821ca78:	defffa04 	addi	sp,sp,-24
 821ca7c:	df000515 	stw	fp,20(sp)
 821ca80:	df000504 	addi	fp,sp,20
 821ca84:	e13ffd15 	stw	r4,-12(fp)
 821ca88:	e17ffe15 	stw	r5,-8(fp)
 821ca8c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 821ca90:	00bff9c4 	movi	r2,-25
 821ca94:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 821ca98:	e0bffe17 	ldw	r2,-8(fp)
 821ca9c:	10da8060 	cmpeqi	r3,r2,27137
 821caa0:	1800031e 	bne	r3,zero,821cab0 <altera_avalon_jtag_uart_ioctl+0x38>
 821caa4:	109a80a0 	cmpeqi	r2,r2,27138
 821caa8:	1000181e 	bne	r2,zero,821cb0c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 821caac:	00002906 	br	821cb54 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 821cab0:	e0bffd17 	ldw	r2,-12(fp)
 821cab4:	10c00117 	ldw	r3,4(r2)
 821cab8:	00a00034 	movhi	r2,32768
 821cabc:	10bfffc4 	addi	r2,r2,-1
 821cac0:	18802126 	beq	r3,r2,821cb48 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 821cac4:	e0bfff17 	ldw	r2,-4(fp)
 821cac8:	10800017 	ldw	r2,0(r2)
 821cacc:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 821cad0:	e0bffc17 	ldw	r2,-16(fp)
 821cad4:	10800090 	cmplti	r2,r2,2
 821cad8:	1000061e 	bne	r2,zero,821caf4 <altera_avalon_jtag_uart_ioctl+0x7c>
 821cadc:	e0fffc17 	ldw	r3,-16(fp)
 821cae0:	00a00034 	movhi	r2,32768
 821cae4:	10bfffc4 	addi	r2,r2,-1
 821cae8:	18800226 	beq	r3,r2,821caf4 <altera_avalon_jtag_uart_ioctl+0x7c>
 821caec:	e0bffc17 	ldw	r2,-16(fp)
 821caf0:	00000206 	br	821cafc <altera_avalon_jtag_uart_ioctl+0x84>
 821caf4:	00a00034 	movhi	r2,32768
 821caf8:	10bfff84 	addi	r2,r2,-2
 821cafc:	e0fffd17 	ldw	r3,-12(fp)
 821cb00:	18800115 	stw	r2,4(r3)
      rc = 0;
 821cb04:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821cb08:	00000f06 	br	821cb48 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 821cb0c:	e0bffd17 	ldw	r2,-12(fp)
 821cb10:	10c00117 	ldw	r3,4(r2)
 821cb14:	00a00034 	movhi	r2,32768
 821cb18:	10bfffc4 	addi	r2,r2,-1
 821cb1c:	18800c26 	beq	r3,r2,821cb50 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 821cb20:	e0bffd17 	ldw	r2,-12(fp)
 821cb24:	10c00917 	ldw	r3,36(r2)
 821cb28:	e0bffd17 	ldw	r2,-12(fp)
 821cb2c:	10800117 	ldw	r2,4(r2)
 821cb30:	1885803a 	cmpltu	r2,r3,r2
 821cb34:	10c03fcc 	andi	r3,r2,255
 821cb38:	e0bfff17 	ldw	r2,-4(fp)
 821cb3c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 821cb40:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821cb44:	00000206 	br	821cb50 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 821cb48:	0001883a 	nop
 821cb4c:	00000106 	br	821cb54 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 821cb50:	0001883a 	nop

  default:
    break;
  }

  return rc;
 821cb54:	e0bffb17 	ldw	r2,-20(fp)
}
 821cb58:	e037883a 	mov	sp,fp
 821cb5c:	df000017 	ldw	fp,0(sp)
 821cb60:	dec00104 	addi	sp,sp,4
 821cb64:	f800283a 	ret

0821cb68 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 821cb68:	deffed04 	addi	sp,sp,-76
 821cb6c:	dfc01215 	stw	ra,72(sp)
 821cb70:	df001115 	stw	fp,68(sp)
 821cb74:	df001104 	addi	fp,sp,68
 821cb78:	e13ffc15 	stw	r4,-16(fp)
 821cb7c:	e17ffd15 	stw	r5,-12(fp)
 821cb80:	e1bffe15 	stw	r6,-8(fp)
 821cb84:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 821cb88:	e0bffd17 	ldw	r2,-12(fp)
 821cb8c:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 821cb90:	e0bffc17 	ldw	r2,-16(fp)
 821cb94:	10800a17 	ldw	r2,40(r2)
 821cb98:	e0bff815 	stw	r2,-32(fp)
 821cb9c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 821cba0:	e0bff90b 	ldhu	r2,-28(fp)
 821cba4:	e0fffb04 	addi	r3,fp,-20
 821cba8:	180d883a 	mov	r6,r3
 821cbac:	100b883a 	mov	r5,r2
 821cbb0:	e13ff817 	ldw	r4,-32(fp)
 821cbb4:	8219e200 	call	8219e20 <OSSemPend>

  while (space > 0)
 821cbb8:	00006106 	br	821cd40 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 821cbbc:	e0bffc17 	ldw	r2,-16(fp)
 821cbc0:	10800d17 	ldw	r2,52(r2)
 821cbc4:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
 821cbc8:	e0bffc17 	ldw	r2,-16(fp)
 821cbcc:	10800e17 	ldw	r2,56(r2)
 821cbd0:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
 821cbd4:	e0fff317 	ldw	r3,-52(fp)
 821cbd8:	e0bff417 	ldw	r2,-48(fp)
 821cbdc:	18800536 	bltu	r3,r2,821cbf4 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 821cbe0:	e0fff317 	ldw	r3,-52(fp)
 821cbe4:	e0bff417 	ldw	r2,-48(fp)
 821cbe8:	1885c83a 	sub	r2,r3,r2
 821cbec:	e0bff115 	stw	r2,-60(fp)
 821cbf0:	00000406 	br	821cc04 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 821cbf4:	00c20004 	movi	r3,2048
 821cbf8:	e0bff417 	ldw	r2,-48(fp)
 821cbfc:	1885c83a 	sub	r2,r3,r2
 821cc00:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821cc04:	e0bff117 	ldw	r2,-60(fp)
 821cc08:	10001e26 	beq	r2,zero,821cc84 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 821cc0c:	e0fffe17 	ldw	r3,-8(fp)
 821cc10:	e0bff117 	ldw	r2,-60(fp)
 821cc14:	1880022e 	bgeu	r3,r2,821cc20 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 821cc18:	e0bffe17 	ldw	r2,-8(fp)
 821cc1c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 821cc20:	e0bffc17 	ldw	r2,-16(fp)
 821cc24:	10c01104 	addi	r3,r2,68
 821cc28:	e0bff417 	ldw	r2,-48(fp)
 821cc2c:	1885883a 	add	r2,r3,r2
 821cc30:	e1bff117 	ldw	r6,-60(fp)
 821cc34:	100b883a 	mov	r5,r2
 821cc38:	e13ff017 	ldw	r4,-64(fp)
 821cc3c:	8202c5c0 	call	8202c5c <memcpy>
      ptr   += n;
 821cc40:	e0fff017 	ldw	r3,-64(fp)
 821cc44:	e0bff117 	ldw	r2,-60(fp)
 821cc48:	1885883a 	add	r2,r3,r2
 821cc4c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
 821cc50:	e0fffe17 	ldw	r3,-8(fp)
 821cc54:	e0bff117 	ldw	r2,-60(fp)
 821cc58:	1885c83a 	sub	r2,r3,r2
 821cc5c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cc60:	e0fff417 	ldw	r3,-48(fp)
 821cc64:	e0bff117 	ldw	r2,-60(fp)
 821cc68:	1885883a 	add	r2,r3,r2
 821cc6c:	10c1ffcc 	andi	r3,r2,2047
 821cc70:	e0bffc17 	ldw	r2,-16(fp)
 821cc74:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 821cc78:	e0bffe17 	ldw	r2,-8(fp)
 821cc7c:	00bfcf16 	blt	zero,r2,821cbbc <altera_avalon_jtag_uart_read+0x54>
 821cc80:	00000106 	br	821cc88 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 821cc84:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 821cc88:	e0fff017 	ldw	r3,-64(fp)
 821cc8c:	e0bffd17 	ldw	r2,-12(fp)
 821cc90:	18802e1e 	bne	r3,r2,821cd4c <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 821cc94:	e0bfff17 	ldw	r2,-4(fp)
 821cc98:	1090000c 	andi	r2,r2,16384
 821cc9c:	10002d1e 	bne	r2,zero,821cd54 <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 821cca0:	d0a06b43 	ldbu	r2,-32339(gp)
 821cca4:	10803fcc 	andi	r2,r2,255
 821cca8:	10800058 	cmpnei	r2,r2,1
 821ccac:	1000161e 	bne	r2,zero,821cd08 <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 821ccb0:	e0bffc17 	ldw	r2,-16(fp)
 821ccb4:	10800c17 	ldw	r2,48(r2)
 821ccb8:	e0bff215 	stw	r2,-56(fp)
 821ccbc:	00800144 	movi	r2,5
 821ccc0:	e0bff98d 	sth	r2,-26(fp)
 821ccc4:	00bfe0c4 	movi	r2,-125
 821ccc8:	e0bffa05 	stb	r2,-24(fp)
 821cccc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821ccd0:	d0a06b43 	ldbu	r2,-32339(gp)
 821ccd4:	10803fcc 	andi	r2,r2,255
 821ccd8:	10001526 	beq	r2,zero,821cd30 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821ccdc:	e0fff98b 	ldhu	r3,-26(fp)
 821cce0:	e13ffa03 	ldbu	r4,-24(fp)
 821cce4:	e17ffa8b 	ldhu	r5,-22(fp)
 821cce8:	e0bffb44 	addi	r2,fp,-19
 821ccec:	d8800015 	stw	r2,0(sp)
 821ccf0:	280f883a 	mov	r7,r5
 821ccf4:	200d883a 	mov	r6,r4
 821ccf8:	180b883a 	mov	r5,r3
 821ccfc:	e13ff217 	ldw	r4,-56(fp)
 821cd00:	82173b80 	call	82173b8 <OSFlagPend>
 821cd04:	00000a06 	br	821cd30 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 821cd08:	0001883a 	nop
 821cd0c:	e0bffc17 	ldw	r2,-16(fp)
 821cd10:	10c00d17 	ldw	r3,52(r2)
 821cd14:	e0bff317 	ldw	r2,-52(fp)
 821cd18:	1880051e 	bne	r3,r2,821cd30 <altera_avalon_jtag_uart_read+0x1c8>
 821cd1c:	e0bffc17 	ldw	r2,-16(fp)
 821cd20:	10c00917 	ldw	r3,36(r2)
 821cd24:	e0bffc17 	ldw	r2,-16(fp)
 821cd28:	10800117 	ldw	r2,4(r2)
 821cd2c:	18bff736 	bltu	r3,r2,821cd0c <altera_avalon_jtag_uart_read+0x1a4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 821cd30:	e0bffc17 	ldw	r2,-16(fp)
 821cd34:	10c00d17 	ldw	r3,52(r2)
 821cd38:	e0bff317 	ldw	r2,-52(fp)
 821cd3c:	18800726 	beq	r3,r2,821cd5c <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 821cd40:	e0bffe17 	ldw	r2,-8(fp)
 821cd44:	00bf9d16 	blt	zero,r2,821cbbc <altera_avalon_jtag_uart_read+0x54>
 821cd48:	00000506 	br	821cd60 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 821cd4c:	0001883a 	nop
 821cd50:	00000306 	br	821cd60 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 821cd54:	0001883a 	nop
 821cd58:	00000106 	br	821cd60 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 821cd5c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 821cd60:	e0bffc17 	ldw	r2,-16(fp)
 821cd64:	10800a17 	ldw	r2,40(r2)
 821cd68:	1009883a 	mov	r4,r2
 821cd6c:	821a1980 	call	821a198 <OSSemPost>

  if (ptr != buffer)
 821cd70:	e0fff017 	ldw	r3,-64(fp)
 821cd74:	e0bffd17 	ldw	r2,-12(fp)
 821cd78:	18801826 	beq	r3,r2,821cddc <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821cd7c:	0005303a 	rdctl	r2,status
 821cd80:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821cd84:	e0fff717 	ldw	r3,-36(fp)
 821cd88:	00bfff84 	movi	r2,-2
 821cd8c:	1884703a 	and	r2,r3,r2
 821cd90:	1001703a 	wrctl	status,r2
  
  return context;
 821cd94:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 821cd98:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821cd9c:	e0bffc17 	ldw	r2,-16(fp)
 821cda0:	10800817 	ldw	r2,32(r2)
 821cda4:	10c00054 	ori	r3,r2,1
 821cda8:	e0bffc17 	ldw	r2,-16(fp)
 821cdac:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cdb0:	e0bffc17 	ldw	r2,-16(fp)
 821cdb4:	10800017 	ldw	r2,0(r2)
 821cdb8:	10800104 	addi	r2,r2,4
 821cdbc:	1007883a 	mov	r3,r2
 821cdc0:	e0bffc17 	ldw	r2,-16(fp)
 821cdc4:	10800817 	ldw	r2,32(r2)
 821cdc8:	18800035 	stwio	r2,0(r3)
 821cdcc:	e0bff617 	ldw	r2,-40(fp)
 821cdd0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821cdd4:	e0bff517 	ldw	r2,-44(fp)
 821cdd8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 821cddc:	e0fff017 	ldw	r3,-64(fp)
 821cde0:	e0bffd17 	ldw	r2,-12(fp)
 821cde4:	18800426 	beq	r3,r2,821cdf8 <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
 821cde8:	e0fff017 	ldw	r3,-64(fp)
 821cdec:	e0bffd17 	ldw	r2,-12(fp)
 821cdf0:	1885c83a 	sub	r2,r3,r2
 821cdf4:	00000606 	br	821ce10 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 821cdf8:	e0bfff17 	ldw	r2,-4(fp)
 821cdfc:	1090000c 	andi	r2,r2,16384
 821ce00:	10000226 	beq	r2,zero,821ce0c <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
 821ce04:	00bffd44 	movi	r2,-11
 821ce08:	00000106 	br	821ce10 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 821ce0c:	00bffec4 	movi	r2,-5
}
 821ce10:	e037883a 	mov	sp,fp
 821ce14:	dfc00117 	ldw	ra,4(sp)
 821ce18:	df000017 	ldw	fp,0(sp)
 821ce1c:	dec00204 	addi	sp,sp,8
 821ce20:	f800283a 	ret

0821ce24 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 821ce24:	deffed04 	addi	sp,sp,-76
 821ce28:	dfc01215 	stw	ra,72(sp)
 821ce2c:	df001115 	stw	fp,68(sp)
 821ce30:	df001104 	addi	fp,sp,68
 821ce34:	e13ffc15 	stw	r4,-16(fp)
 821ce38:	e17ffd15 	stw	r5,-12(fp)
 821ce3c:	e1bffe15 	stw	r6,-8(fp)
 821ce40:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 821ce44:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 821ce48:	e0bffd17 	ldw	r2,-12(fp)
 821ce4c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 821ce50:	e0bffc17 	ldw	r2,-16(fp)
 821ce54:	10800b17 	ldw	r2,44(r2)
 821ce58:	e0bff815 	stw	r2,-32(fp)
 821ce5c:	e03ff90d 	sth	zero,-28(fp)
 821ce60:	e0bff90b 	ldhu	r2,-28(fp)
 821ce64:	e0fffb44 	addi	r3,fp,-19
 821ce68:	180d883a 	mov	r6,r3
 821ce6c:	100b883a 	mov	r5,r2
 821ce70:	e13ff817 	ldw	r4,-32(fp)
 821ce74:	8219e200 	call	8219e20 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821ce78:	00003706 	br	821cf58 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 821ce7c:	e0bffc17 	ldw	r2,-16(fp)
 821ce80:	10800f17 	ldw	r2,60(r2)
 821ce84:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
 821ce88:	e0bffc17 	ldw	r2,-16(fp)
 821ce8c:	10801017 	ldw	r2,64(r2)
 821ce90:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 821ce94:	e0fff417 	ldw	r3,-48(fp)
 821ce98:	e0bff017 	ldw	r2,-64(fp)
 821ce9c:	1880062e 	bgeu	r3,r2,821ceb8 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 821cea0:	e0fff017 	ldw	r3,-64(fp)
 821cea4:	e0bff417 	ldw	r2,-48(fp)
 821cea8:	1885c83a 	sub	r2,r3,r2
 821ceac:	10bfffc4 	addi	r2,r2,-1
 821ceb0:	e0bff115 	stw	r2,-60(fp)
 821ceb4:	00000b06 	br	821cee4 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 821ceb8:	e0bff017 	ldw	r2,-64(fp)
 821cebc:	10000526 	beq	r2,zero,821ced4 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 821cec0:	00c20004 	movi	r3,2048
 821cec4:	e0bff417 	ldw	r2,-48(fp)
 821cec8:	1885c83a 	sub	r2,r3,r2
 821cecc:	e0bff115 	stw	r2,-60(fp)
 821ced0:	00000406 	br	821cee4 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 821ced4:	00c1ffc4 	movi	r3,2047
 821ced8:	e0bff417 	ldw	r2,-48(fp)
 821cedc:	1885c83a 	sub	r2,r3,r2
 821cee0:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821cee4:	e0bff117 	ldw	r2,-60(fp)
 821cee8:	10001e26 	beq	r2,zero,821cf64 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 821ceec:	e0fffe17 	ldw	r3,-8(fp)
 821cef0:	e0bff117 	ldw	r2,-60(fp)
 821cef4:	1880022e 	bgeu	r3,r2,821cf00 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 821cef8:	e0bffe17 	ldw	r2,-8(fp)
 821cefc:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 821cf00:	e0bffc17 	ldw	r2,-16(fp)
 821cf04:	10c21104 	addi	r3,r2,2116
 821cf08:	e0bff417 	ldw	r2,-48(fp)
 821cf0c:	1885883a 	add	r2,r3,r2
 821cf10:	e1bff117 	ldw	r6,-60(fp)
 821cf14:	e17ffd17 	ldw	r5,-12(fp)
 821cf18:	1009883a 	mov	r4,r2
 821cf1c:	8202c5c0 	call	8202c5c <memcpy>
      ptr   += n;
 821cf20:	e0fffd17 	ldw	r3,-12(fp)
 821cf24:	e0bff117 	ldw	r2,-60(fp)
 821cf28:	1885883a 	add	r2,r3,r2
 821cf2c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 821cf30:	e0fffe17 	ldw	r3,-8(fp)
 821cf34:	e0bff117 	ldw	r2,-60(fp)
 821cf38:	1885c83a 	sub	r2,r3,r2
 821cf3c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cf40:	e0fff417 	ldw	r3,-48(fp)
 821cf44:	e0bff117 	ldw	r2,-60(fp)
 821cf48:	1885883a 	add	r2,r3,r2
 821cf4c:	10c1ffcc 	andi	r3,r2,2047
 821cf50:	e0bffc17 	ldw	r2,-16(fp)
 821cf54:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821cf58:	e0bffe17 	ldw	r2,-8(fp)
 821cf5c:	00bfc716 	blt	zero,r2,821ce7c <altera_avalon_jtag_uart_write+0x58>
 821cf60:	00000106 	br	821cf68 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 821cf64:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821cf68:	0005303a 	rdctl	r2,status
 821cf6c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821cf70:	e0fff717 	ldw	r3,-36(fp)
 821cf74:	00bfff84 	movi	r2,-2
 821cf78:	1884703a 	and	r2,r3,r2
 821cf7c:	1001703a 	wrctl	status,r2
  
  return context;
 821cf80:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 821cf84:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821cf88:	e0bffc17 	ldw	r2,-16(fp)
 821cf8c:	10800817 	ldw	r2,32(r2)
 821cf90:	10c00094 	ori	r3,r2,2
 821cf94:	e0bffc17 	ldw	r2,-16(fp)
 821cf98:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cf9c:	e0bffc17 	ldw	r2,-16(fp)
 821cfa0:	10800017 	ldw	r2,0(r2)
 821cfa4:	10800104 	addi	r2,r2,4
 821cfa8:	1007883a 	mov	r3,r2
 821cfac:	e0bffc17 	ldw	r2,-16(fp)
 821cfb0:	10800817 	ldw	r2,32(r2)
 821cfb4:	18800035 	stwio	r2,0(r3)
 821cfb8:	e0bff617 	ldw	r2,-40(fp)
 821cfbc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821cfc0:	e0bff317 	ldw	r2,-52(fp)
 821cfc4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 821cfc8:	e0bffe17 	ldw	r2,-8(fp)
 821cfcc:	00802a0e 	bge	zero,r2,821d078 <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
 821cfd0:	e0bfff17 	ldw	r2,-4(fp)
 821cfd4:	1090000c 	andi	r2,r2,16384
 821cfd8:	10002a1e 	bne	r2,zero,821d084 <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 821cfdc:	d0a06b43 	ldbu	r2,-32339(gp)
 821cfe0:	10803fcc 	andi	r2,r2,255
 821cfe4:	10800058 	cmpnei	r2,r2,1
 821cfe8:	1000161e 	bne	r2,zero,821d044 <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 821cfec:	e0bffc17 	ldw	r2,-16(fp)
 821cff0:	10800c17 	ldw	r2,48(r2)
 821cff4:	e0bff515 	stw	r2,-44(fp)
 821cff8:	00800184 	movi	r2,6
 821cffc:	e0bff98d 	sth	r2,-26(fp)
 821d000:	00bfe0c4 	movi	r2,-125
 821d004:	e0bffa05 	stb	r2,-24(fp)
 821d008:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821d00c:	d0a06b43 	ldbu	r2,-32339(gp)
 821d010:	10803fcc 	andi	r2,r2,255
 821d014:	10001526 	beq	r2,zero,821d06c <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821d018:	e0fff98b 	ldhu	r3,-26(fp)
 821d01c:	e13ffa03 	ldbu	r4,-24(fp)
 821d020:	e17ffa8b 	ldhu	r5,-22(fp)
 821d024:	e0bffb04 	addi	r2,fp,-20
 821d028:	d8800015 	stw	r2,0(sp)
 821d02c:	280f883a 	mov	r7,r5
 821d030:	200d883a 	mov	r6,r4
 821d034:	180b883a 	mov	r5,r3
 821d038:	e13ff517 	ldw	r4,-44(fp)
 821d03c:	82173b80 	call	82173b8 <OSFlagPend>
 821d040:	00000a06 	br	821d06c <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 821d044:	0001883a 	nop
 821d048:	e0bffc17 	ldw	r2,-16(fp)
 821d04c:	10c01017 	ldw	r3,64(r2)
 821d050:	e0bff017 	ldw	r2,-64(fp)
 821d054:	1880051e 	bne	r3,r2,821d06c <altera_avalon_jtag_uart_write+0x248>
 821d058:	e0bffc17 	ldw	r2,-16(fp)
 821d05c:	10c00917 	ldw	r3,36(r2)
 821d060:	e0bffc17 	ldw	r2,-16(fp)
 821d064:	10800117 	ldw	r2,4(r2)
 821d068:	18bff736 	bltu	r3,r2,821d048 <altera_avalon_jtag_uart_write+0x224>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 821d06c:	e0bffc17 	ldw	r2,-16(fp)
 821d070:	10800917 	ldw	r2,36(r2)
 821d074:	1000051e 	bne	r2,zero,821d08c <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
 821d078:	e0bffe17 	ldw	r2,-8(fp)
 821d07c:	00bfb616 	blt	zero,r2,821cf58 <altera_avalon_jtag_uart_write+0x134>
 821d080:	00000306 	br	821d090 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 821d084:	0001883a 	nop
 821d088:	00000106 	br	821d090 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 821d08c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 821d090:	e0bffc17 	ldw	r2,-16(fp)
 821d094:	10800b17 	ldw	r2,44(r2)
 821d098:	1009883a 	mov	r4,r2
 821d09c:	821a1980 	call	821a198 <OSSemPost>

  if (ptr != start)
 821d0a0:	e0fffd17 	ldw	r3,-12(fp)
 821d0a4:	e0bff217 	ldw	r2,-56(fp)
 821d0a8:	18800426 	beq	r3,r2,821d0bc <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
 821d0ac:	e0fffd17 	ldw	r3,-12(fp)
 821d0b0:	e0bff217 	ldw	r2,-56(fp)
 821d0b4:	1885c83a 	sub	r2,r3,r2
 821d0b8:	00000606 	br	821d0d4 <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
 821d0bc:	e0bfff17 	ldw	r2,-4(fp)
 821d0c0:	1090000c 	andi	r2,r2,16384
 821d0c4:	10000226 	beq	r2,zero,821d0d0 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
 821d0c8:	00bffd44 	movi	r2,-11
 821d0cc:	00000106 	br	821d0d4 <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 821d0d0:	00bffec4 	movi	r2,-5
}
 821d0d4:	e037883a 	mov	sp,fp
 821d0d8:	dfc00117 	ldw	ra,4(sp)
 821d0dc:	df000017 	ldw	fp,0(sp)
 821d0e0:	dec00204 	addi	sp,sp,8
 821d0e4:	f800283a 	ret

0821d0e8 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 821d0e8:	defffa04 	addi	sp,sp,-24
 821d0ec:	dfc00515 	stw	ra,20(sp)
 821d0f0:	df000415 	stw	fp,16(sp)
 821d0f4:	df000404 	addi	fp,sp,16
 821d0f8:	e13ffe15 	stw	r4,-8(fp)
 821d0fc:	2805883a 	mov	r2,r5
 821d100:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d104:	e0bffe17 	ldw	r2,-8(fp)
 821d108:	10800017 	ldw	r2,0(r2)
 821d10c:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d110:	008003f4 	movhi	r2,15
 821d114:	10909004 	addi	r2,r2,16960
 821d118:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d11c:	e0bffe17 	ldw	r2,-8(fp)
 821d120:	10800803 	ldbu	r2,32(r2)
 821d124:	10803fcc 	andi	r2,r2,255
 821d128:	1080201c 	xori	r2,r2,128
 821d12c:	10bfe004 	addi	r2,r2,-128
 821d130:	1000151e 	bne	r2,zero,821d188 <lcd_write_command+0xa0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d134:	00000906 	br	821d15c <lcd_write_command+0x74>
    if (--i == 0)
 821d138:	e0bffc17 	ldw	r2,-16(fp)
 821d13c:	10bfffc4 	addi	r2,r2,-1
 821d140:	e0bffc15 	stw	r2,-16(fp)
 821d144:	e0bffc17 	ldw	r2,-16(fp)
 821d148:	1000041e 	bne	r2,zero,821d15c <lcd_write_command+0x74>
    {
      sp->broken = 1;
 821d14c:	e0bffe17 	ldw	r2,-8(fp)
 821d150:	00c00044 	movi	r3,1
 821d154:	10c00805 	stb	r3,32(r2)
      return;
 821d158:	00000c06 	br	821d18c <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d15c:	e0bffd17 	ldw	r2,-12(fp)
 821d160:	10800104 	addi	r2,r2,4
 821d164:	10800037 	ldwio	r2,0(r2)
 821d168:	1080200c 	andi	r2,r2,128
 821d16c:	103ff21e 	bne	r2,zero,821d138 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d170:	01001904 	movi	r4,100
 821d174:	823c7700 	call	823c770 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 821d178:	e0bffd17 	ldw	r2,-12(fp)
 821d17c:	e0ffff03 	ldbu	r3,-4(fp)
 821d180:	10c00035 	stwio	r3,0(r2)
 821d184:	00000106 	br	821d18c <lcd_write_command+0xa4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d188:	0001883a 	nop
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
}
 821d18c:	e037883a 	mov	sp,fp
 821d190:	dfc00117 	ldw	ra,4(sp)
 821d194:	df000017 	ldw	fp,0(sp)
 821d198:	dec00204 	addi	sp,sp,8
 821d19c:	f800283a 	ret

0821d1a0 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 821d1a0:	defffa04 	addi	sp,sp,-24
 821d1a4:	dfc00515 	stw	ra,20(sp)
 821d1a8:	df000415 	stw	fp,16(sp)
 821d1ac:	df000404 	addi	fp,sp,16
 821d1b0:	e13ffe15 	stw	r4,-8(fp)
 821d1b4:	2805883a 	mov	r2,r5
 821d1b8:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d1bc:	e0bffe17 	ldw	r2,-8(fp)
 821d1c0:	10800017 	ldw	r2,0(r2)
 821d1c4:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d1c8:	008003f4 	movhi	r2,15
 821d1cc:	10909004 	addi	r2,r2,16960
 821d1d0:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d1d4:	e0bffe17 	ldw	r2,-8(fp)
 821d1d8:	10800803 	ldbu	r2,32(r2)
 821d1dc:	10803fcc 	andi	r2,r2,255
 821d1e0:	1080201c 	xori	r2,r2,128
 821d1e4:	10bfe004 	addi	r2,r2,-128
 821d1e8:	10001d1e 	bne	r2,zero,821d260 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d1ec:	00000906 	br	821d214 <lcd_write_data+0x74>
    if (--i == 0)
 821d1f0:	e0bffc17 	ldw	r2,-16(fp)
 821d1f4:	10bfffc4 	addi	r2,r2,-1
 821d1f8:	e0bffc15 	stw	r2,-16(fp)
 821d1fc:	e0bffc17 	ldw	r2,-16(fp)
 821d200:	1000041e 	bne	r2,zero,821d214 <lcd_write_data+0x74>
    {
      sp->broken = 1;
 821d204:	e0bffe17 	ldw	r2,-8(fp)
 821d208:	00c00044 	movi	r3,1
 821d20c:	10c00805 	stb	r3,32(r2)
      return;
 821d210:	00001406 	br	821d264 <lcd_write_data+0xc4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d214:	e0bffd17 	ldw	r2,-12(fp)
 821d218:	10800104 	addi	r2,r2,4
 821d21c:	10800037 	ldwio	r2,0(r2)
 821d220:	1080200c 	andi	r2,r2,128
 821d224:	103ff21e 	bne	r2,zero,821d1f0 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d228:	01001904 	movi	r4,100
 821d22c:	823c7700 	call	823c770 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 821d230:	e0bffd17 	ldw	r2,-12(fp)
 821d234:	10800204 	addi	r2,r2,8
 821d238:	1007883a 	mov	r3,r2
 821d23c:	e0bfff03 	ldbu	r2,-4(fp)
 821d240:	18800035 	stwio	r2,0(r3)

  sp->address++;
 821d244:	e0bffe17 	ldw	r2,-8(fp)
 821d248:	108008c3 	ldbu	r2,35(r2)
 821d24c:	10800044 	addi	r2,r2,1
 821d250:	1007883a 	mov	r3,r2
 821d254:	e0bffe17 	ldw	r2,-8(fp)
 821d258:	10c008c5 	stb	r3,35(r2)
 821d25c:	00000106 	br	821d264 <lcd_write_data+0xc4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d260:	0001883a 	nop
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);

  sp->address++;
}
 821d264:	e037883a 	mov	sp,fp
 821d268:	dfc00117 	ldw	ra,4(sp)
 821d26c:	df000017 	ldw	fp,0(sp)
 821d270:	dec00204 	addi	sp,sp,8
 821d274:	f800283a 	ret

0821d278 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 821d278:	defffc04 	addi	sp,sp,-16
 821d27c:	dfc00315 	stw	ra,12(sp)
 821d280:	df000215 	stw	fp,8(sp)
 821d284:	df000204 	addi	fp,sp,8
 821d288:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 821d28c:	01400044 	movi	r5,1
 821d290:	e13fff17 	ldw	r4,-4(fp)
 821d294:	821d0e80 	call	821d0e8 <lcd_write_command>

  sp->x = 0;
 821d298:	e0bfff17 	ldw	r2,-4(fp)
 821d29c:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 821d2a0:	e0bfff17 	ldw	r2,-4(fp)
 821d2a4:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 821d2a8:	e0bfff17 	ldw	r2,-4(fp)
 821d2ac:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d2b0:	e03ffe15 	stw	zero,-8(fp)
 821d2b4:	00001b06 	br	821d324 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 821d2b8:	e0bffe17 	ldw	r2,-8(fp)
 821d2bc:	108018e4 	muli	r2,r2,99
 821d2c0:	10801004 	addi	r2,r2,64
 821d2c4:	e0ffff17 	ldw	r3,-4(fp)
 821d2c8:	1885883a 	add	r2,r3,r2
 821d2cc:	01801444 	movi	r6,81
 821d2d0:	01400804 	movi	r5,32
 821d2d4:	1009883a 	mov	r4,r2
 821d2d8:	8202f000 	call	8202f00 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 821d2dc:	e0bffe17 	ldw	r2,-8(fp)
 821d2e0:	108018e4 	muli	r2,r2,99
 821d2e4:	10800c04 	addi	r2,r2,48
 821d2e8:	e0ffff17 	ldw	r3,-4(fp)
 821d2ec:	1885883a 	add	r2,r3,r2
 821d2f0:	01800404 	movi	r6,16
 821d2f4:	01400804 	movi	r5,32
 821d2f8:	1009883a 	mov	r4,r2
 821d2fc:	8202f000 	call	8202f00 <memset>
    sp->line[y].width = 0;
 821d300:	e0ffff17 	ldw	r3,-4(fp)
 821d304:	e0bffe17 	ldw	r2,-8(fp)
 821d308:	108018e4 	muli	r2,r2,99
 821d30c:	1885883a 	add	r2,r3,r2
 821d310:	10802444 	addi	r2,r2,145
 821d314:	10000005 	stb	zero,0(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d318:	e0bffe17 	ldw	r2,-8(fp)
 821d31c:	10800044 	addi	r2,r2,1
 821d320:	e0bffe15 	stw	r2,-8(fp)
 821d324:	e0bffe17 	ldw	r2,-8(fp)
 821d328:	10800090 	cmplti	r2,r2,2
 821d32c:	103fe21e 	bne	r2,zero,821d2b8 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 821d330:	0001883a 	nop
 821d334:	e037883a 	mov	sp,fp
 821d338:	dfc00117 	ldw	ra,4(sp)
 821d33c:	df000017 	ldw	fp,0(sp)
 821d340:	dec00204 	addi	sp,sp,8
 821d344:	f800283a 	ret

0821d348 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 821d348:	defff704 	addi	sp,sp,-36
 821d34c:	dfc00815 	stw	ra,32(sp)
 821d350:	df000715 	stw	fp,28(sp)
 821d354:	df000704 	addi	fp,sp,28
 821d358:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 821d35c:	e0bfff17 	ldw	r2,-4(fp)
 821d360:	10800943 	ldbu	r2,37(r2)
 821d364:	10803fcc 	andi	r2,r2,255
 821d368:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d36c:	e03ff915 	stw	zero,-28(fp)
 821d370:	00006706 	br	821d510 <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 821d374:	e0ffff17 	ldw	r3,-4(fp)
 821d378:	e0bff917 	ldw	r2,-28(fp)
 821d37c:	108018e4 	muli	r2,r2,99
 821d380:	1885883a 	add	r2,r3,r2
 821d384:	10802444 	addi	r2,r2,145
 821d388:	10800003 	ldbu	r2,0(r2)
 821d38c:	10803fcc 	andi	r2,r2,255
 821d390:	1080201c 	xori	r2,r2,128
 821d394:	10bfe004 	addi	r2,r2,-128
 821d398:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 821d39c:	e0ffff17 	ldw	r3,-4(fp)
 821d3a0:	e0bff917 	ldw	r2,-28(fp)
 821d3a4:	108018e4 	muli	r2,r2,99
 821d3a8:	1885883a 	add	r2,r3,r2
 821d3ac:	10802484 	addi	r2,r2,146
 821d3b0:	10800003 	ldbu	r2,0(r2)
 821d3b4:	10c03fcc 	andi	r3,r2,255
 821d3b8:	e0bffc17 	ldw	r2,-16(fp)
 821d3bc:	1885383a 	mul	r2,r3,r2
 821d3c0:	1005d23a 	srai	r2,r2,8
 821d3c4:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
 821d3c8:	e0fffb17 	ldw	r3,-20(fp)
 821d3cc:	e0bffd17 	ldw	r2,-12(fp)
 821d3d0:	18800116 	blt	r3,r2,821d3d8 <lcd_repaint_screen+0x90>
      offset = 0;
 821d3d4:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d3d8:	e03ffa15 	stw	zero,-24(fp)
 821d3dc:	00004606 	br	821d4f8 <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 821d3e0:	e0fffa17 	ldw	r3,-24(fp)
 821d3e4:	e0bffb17 	ldw	r2,-20(fp)
 821d3e8:	1885883a 	add	r2,r3,r2
 821d3ec:	e17ffd17 	ldw	r5,-12(fp)
 821d3f0:	1009883a 	mov	r4,r2
 821d3f4:	82028e80 	call	82028e8 <__modsi3>
 821d3f8:	1009883a 	mov	r4,r2
 821d3fc:	e0ffff17 	ldw	r3,-4(fp)
 821d400:	e0bff917 	ldw	r2,-28(fp)
 821d404:	108018e4 	muli	r2,r2,99
 821d408:	1885883a 	add	r2,r3,r2
 821d40c:	1105883a 	add	r2,r2,r4
 821d410:	10801004 	addi	r2,r2,64
 821d414:	10800003 	ldbu	r2,0(r2)
 821d418:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 821d41c:	e0ffff17 	ldw	r3,-4(fp)
 821d420:	e0bff917 	ldw	r2,-28(fp)
 821d424:	108018e4 	muli	r2,r2,99
 821d428:	1887883a 	add	r3,r3,r2
 821d42c:	e0bffa17 	ldw	r2,-24(fp)
 821d430:	1885883a 	add	r2,r3,r2
 821d434:	10800c04 	addi	r2,r2,48
 821d438:	10800003 	ldbu	r2,0(r2)
 821d43c:	10c03fcc 	andi	r3,r2,255
 821d440:	18c0201c 	xori	r3,r3,128
 821d444:	18ffe004 	addi	r3,r3,-128
 821d448:	e0bffe07 	ldb	r2,-8(fp)
 821d44c:	18802726 	beq	r3,r2,821d4ec <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 821d450:	e0fff917 	ldw	r3,-28(fp)
 821d454:	d0a02a04 	addi	r2,gp,-32600
 821d458:	1885883a 	add	r2,r3,r2
 821d45c:	10800003 	ldbu	r2,0(r2)
 821d460:	1007883a 	mov	r3,r2
 821d464:	e0bffa17 	ldw	r2,-24(fp)
 821d468:	1885883a 	add	r2,r3,r2
 821d46c:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
 821d470:	e0fffe43 	ldbu	r3,-7(fp)
 821d474:	e0bfff17 	ldw	r2,-4(fp)
 821d478:	108008c3 	ldbu	r2,35(r2)
 821d47c:	10803fcc 	andi	r2,r2,255
 821d480:	1080201c 	xori	r2,r2,128
 821d484:	10bfe004 	addi	r2,r2,-128
 821d488:	18800a26 	beq	r3,r2,821d4b4 <lcd_repaint_screen+0x16c>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 821d48c:	e0fffe43 	ldbu	r3,-7(fp)
 821d490:	00bfe004 	movi	r2,-128
 821d494:	1884b03a 	or	r2,r3,r2
 821d498:	10803fcc 	andi	r2,r2,255
 821d49c:	100b883a 	mov	r5,r2
 821d4a0:	e13fff17 	ldw	r4,-4(fp)
 821d4a4:	821d0e80 	call	821d0e8 <lcd_write_command>
          sp->address = address;
 821d4a8:	e0fffe43 	ldbu	r3,-7(fp)
 821d4ac:	e0bfff17 	ldw	r2,-4(fp)
 821d4b0:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 821d4b4:	e0bffe03 	ldbu	r2,-8(fp)
 821d4b8:	10803fcc 	andi	r2,r2,255
 821d4bc:	100b883a 	mov	r5,r2
 821d4c0:	e13fff17 	ldw	r4,-4(fp)
 821d4c4:	821d1a00 	call	821d1a0 <lcd_write_data>
        sp->line[y].visible[x] = c;
 821d4c8:	e0ffff17 	ldw	r3,-4(fp)
 821d4cc:	e0bff917 	ldw	r2,-28(fp)
 821d4d0:	108018e4 	muli	r2,r2,99
 821d4d4:	1887883a 	add	r3,r3,r2
 821d4d8:	e0bffa17 	ldw	r2,-24(fp)
 821d4dc:	1885883a 	add	r2,r3,r2
 821d4e0:	10800c04 	addi	r2,r2,48
 821d4e4:	e0fffe03 	ldbu	r3,-8(fp)
 821d4e8:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d4ec:	e0bffa17 	ldw	r2,-24(fp)
 821d4f0:	10800044 	addi	r2,r2,1
 821d4f4:	e0bffa15 	stw	r2,-24(fp)
 821d4f8:	e0bffa17 	ldw	r2,-24(fp)
 821d4fc:	10800410 	cmplti	r2,r2,16
 821d500:	103fb71e 	bne	r2,zero,821d3e0 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d504:	e0bff917 	ldw	r2,-28(fp)
 821d508:	10800044 	addi	r2,r2,1
 821d50c:	e0bff915 	stw	r2,-28(fp)
 821d510:	e0bff917 	ldw	r2,-28(fp)
 821d514:	10800090 	cmplti	r2,r2,2
 821d518:	103f961e 	bne	r2,zero,821d374 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 821d51c:	0001883a 	nop
 821d520:	e037883a 	mov	sp,fp
 821d524:	dfc00117 	ldw	ra,4(sp)
 821d528:	df000017 	ldw	fp,0(sp)
 821d52c:	dec00204 	addi	sp,sp,8
 821d530:	f800283a 	ret

0821d534 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 821d534:	defffc04 	addi	sp,sp,-16
 821d538:	dfc00315 	stw	ra,12(sp)
 821d53c:	df000215 	stw	fp,8(sp)
 821d540:	df000204 	addi	fp,sp,8
 821d544:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d548:	e03ffe15 	stw	zero,-8(fp)
 821d54c:	00001d06 	br	821d5c4 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 821d550:	e0bffe17 	ldw	r2,-8(fp)
 821d554:	00800f16 	blt	zero,r2,821d594 <lcd_scroll_up+0x60>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 821d558:	e0bffe17 	ldw	r2,-8(fp)
 821d55c:	108018e4 	muli	r2,r2,99
 821d560:	10801004 	addi	r2,r2,64
 821d564:	e0ffff17 	ldw	r3,-4(fp)
 821d568:	1889883a 	add	r4,r3,r2
 821d56c:	e0bffe17 	ldw	r2,-8(fp)
 821d570:	10800044 	addi	r2,r2,1
 821d574:	108018e4 	muli	r2,r2,99
 821d578:	10801004 	addi	r2,r2,64
 821d57c:	e0ffff17 	ldw	r3,-4(fp)
 821d580:	1885883a 	add	r2,r3,r2
 821d584:	01801404 	movi	r6,80
 821d588:	100b883a 	mov	r5,r2
 821d58c:	8202c5c0 	call	8202c5c <memcpy>
 821d590:	00000906 	br	821d5b8 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 821d594:	e0bffe17 	ldw	r2,-8(fp)
 821d598:	108018e4 	muli	r2,r2,99
 821d59c:	10801004 	addi	r2,r2,64
 821d5a0:	e0ffff17 	ldw	r3,-4(fp)
 821d5a4:	1885883a 	add	r2,r3,r2
 821d5a8:	01801404 	movi	r6,80
 821d5ac:	01400804 	movi	r5,32
 821d5b0:	1009883a 	mov	r4,r2
 821d5b4:	8202f000 	call	8202f00 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d5b8:	e0bffe17 	ldw	r2,-8(fp)
 821d5bc:	10800044 	addi	r2,r2,1
 821d5c0:	e0bffe15 	stw	r2,-8(fp)
 821d5c4:	e0bffe17 	ldw	r2,-8(fp)
 821d5c8:	10800090 	cmplti	r2,r2,2
 821d5cc:	103fe01e 	bne	r2,zero,821d550 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 821d5d0:	e0bfff17 	ldw	r2,-4(fp)
 821d5d4:	10800883 	ldbu	r2,34(r2)
 821d5d8:	10bfffc4 	addi	r2,r2,-1
 821d5dc:	1007883a 	mov	r3,r2
 821d5e0:	e0bfff17 	ldw	r2,-4(fp)
 821d5e4:	10c00885 	stb	r3,34(r2)
}
 821d5e8:	0001883a 	nop
 821d5ec:	e037883a 	mov	sp,fp
 821d5f0:	dfc00117 	ldw	ra,4(sp)
 821d5f4:	df000017 	ldw	fp,0(sp)
 821d5f8:	dec00204 	addi	sp,sp,8
 821d5fc:	f800283a 	ret

0821d600 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 821d600:	defff904 	addi	sp,sp,-28
 821d604:	dfc00615 	stw	ra,24(sp)
 821d608:	df000515 	stw	fp,20(sp)
 821d60c:	df000504 	addi	fp,sp,20
 821d610:	e13ffe15 	stw	r4,-8(fp)
 821d614:	2805883a 	mov	r2,r5
 821d618:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
 821d61c:	e03ffb15 	stw	zero,-20(fp)
 821d620:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
 821d624:	e0bffe17 	ldw	r2,-8(fp)
 821d628:	10800a03 	ldbu	r2,40(r2)
 821d62c:	10803fcc 	andi	r2,r2,255
 821d630:	1080201c 	xori	r2,r2,128
 821d634:	10bfe004 	addi	r2,r2,-128
 821d638:	108016d8 	cmpnei	r2,r2,91
 821d63c:	1000411e 	bne	r2,zero,821d744 <lcd_handle_escape+0x144>
  {
    char * ptr = sp->escape+1;
 821d640:	e0bffe17 	ldw	r2,-8(fp)
 821d644:	10800a04 	addi	r2,r2,40
 821d648:	10800044 	addi	r2,r2,1
 821d64c:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
 821d650:	00000c06 	br	821d684 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 821d654:	e0bffb17 	ldw	r2,-20(fp)
 821d658:	10c002a4 	muli	r3,r2,10
 821d65c:	e0bffd17 	ldw	r2,-12(fp)
 821d660:	11000044 	addi	r4,r2,1
 821d664:	e13ffd15 	stw	r4,-12(fp)
 821d668:	10800003 	ldbu	r2,0(r2)
 821d66c:	10803fcc 	andi	r2,r2,255
 821d670:	1080201c 	xori	r2,r2,128
 821d674:	10bfe004 	addi	r2,r2,-128
 821d678:	10bff404 	addi	r2,r2,-48
 821d67c:	1885883a 	add	r2,r3,r2
 821d680:	e0bffb15 	stw	r2,-20(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 821d684:	d0e00017 	ldw	r3,-32768(gp)
 821d688:	e0bffd17 	ldw	r2,-12(fp)
 821d68c:	10800003 	ldbu	r2,0(r2)
 821d690:	10803fcc 	andi	r2,r2,255
 821d694:	1080201c 	xori	r2,r2,128
 821d698:	10bfe004 	addi	r2,r2,-128
 821d69c:	10800044 	addi	r2,r2,1
 821d6a0:	1885883a 	add	r2,r3,r2
 821d6a4:	10800003 	ldbu	r2,0(r2)
 821d6a8:	10803fcc 	andi	r2,r2,255
 821d6ac:	1080010c 	andi	r2,r2,4
 821d6b0:	103fe81e 	bne	r2,zero,821d654 <lcd_handle_escape+0x54>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 821d6b4:	e0bffd17 	ldw	r2,-12(fp)
 821d6b8:	10800003 	ldbu	r2,0(r2)
 821d6bc:	10803fcc 	andi	r2,r2,255
 821d6c0:	1080201c 	xori	r2,r2,128
 821d6c4:	10bfe004 	addi	r2,r2,-128
 821d6c8:	10800ed8 	cmpnei	r2,r2,59
 821d6cc:	10001f1e 	bne	r2,zero,821d74c <lcd_handle_escape+0x14c>
    {
      ptr++;
 821d6d0:	e0bffd17 	ldw	r2,-12(fp)
 821d6d4:	10800044 	addi	r2,r2,1
 821d6d8:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
 821d6dc:	00000c06 	br	821d710 <lcd_handle_escape+0x110>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 821d6e0:	e0bffc17 	ldw	r2,-16(fp)
 821d6e4:	10c002a4 	muli	r3,r2,10
 821d6e8:	e0bffd17 	ldw	r2,-12(fp)
 821d6ec:	11000044 	addi	r4,r2,1
 821d6f0:	e13ffd15 	stw	r4,-12(fp)
 821d6f4:	10800003 	ldbu	r2,0(r2)
 821d6f8:	10803fcc 	andi	r2,r2,255
 821d6fc:	1080201c 	xori	r2,r2,128
 821d700:	10bfe004 	addi	r2,r2,-128
 821d704:	10bff404 	addi	r2,r2,-48
 821d708:	1885883a 	add	r2,r3,r2
 821d70c:	e0bffc15 	stw	r2,-16(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 821d710:	d0e00017 	ldw	r3,-32768(gp)
 821d714:	e0bffd17 	ldw	r2,-12(fp)
 821d718:	10800003 	ldbu	r2,0(r2)
 821d71c:	10803fcc 	andi	r2,r2,255
 821d720:	1080201c 	xori	r2,r2,128
 821d724:	10bfe004 	addi	r2,r2,-128
 821d728:	10800044 	addi	r2,r2,1
 821d72c:	1885883a 	add	r2,r3,r2
 821d730:	10800003 	ldbu	r2,0(r2)
 821d734:	10803fcc 	andi	r2,r2,255
 821d738:	1080010c 	andi	r2,r2,4
 821d73c:	103fe81e 	bne	r2,zero,821d6e0 <lcd_handle_escape+0xe0>
 821d740:	00000206 	br	821d74c <lcd_handle_escape+0x14c>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 821d744:	00bfffc4 	movi	r2,-1
 821d748:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
 821d74c:	e0bfff07 	ldb	r2,-4(fp)
 821d750:	10c012a0 	cmpeqi	r3,r2,74
 821d754:	1800291e 	bne	r3,zero,821d7fc <lcd_handle_escape+0x1fc>
 821d758:	10c012c8 	cmpgei	r3,r2,75
 821d75c:	1800031e 	bne	r3,zero,821d76c <lcd_handle_escape+0x16c>
 821d760:	10801220 	cmpeqi	r2,r2,72
 821d764:	1000061e 	bne	r2,zero,821d780 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821d768:	00004a06 	br	821d894 <lcd_handle_escape+0x294>
    }
  }
  else
    parm1 = -1;

  switch (c)
 821d76c:	10c012e0 	cmpeqi	r3,r2,75
 821d770:	1800281e 	bne	r3,zero,821d814 <lcd_handle_escape+0x214>
 821d774:	108019a0 	cmpeqi	r2,r2,102
 821d778:	1000011e 	bne	r2,zero,821d780 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821d77c:	00004506 	br	821d894 <lcd_handle_escape+0x294>

  switch (c)
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 821d780:	e0bffc17 	ldw	r2,-16(fp)
 821d784:	0080050e 	bge	zero,r2,821d79c <lcd_handle_escape+0x19c>
      sp->x = parm2 - 1;
 821d788:	e0bffc17 	ldw	r2,-16(fp)
 821d78c:	10bfffc4 	addi	r2,r2,-1
 821d790:	1007883a 	mov	r3,r2
 821d794:	e0bffe17 	ldw	r2,-8(fp)
 821d798:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 821d79c:	e0bffb17 	ldw	r2,-20(fp)
 821d7a0:	0080370e 	bge	zero,r2,821d880 <lcd_handle_escape+0x280>
    {
      sp->y = parm1 - 1;
 821d7a4:	e0bffb17 	ldw	r2,-20(fp)
 821d7a8:	10bfffc4 	addi	r2,r2,-1
 821d7ac:	1007883a 	mov	r3,r2
 821d7b0:	e0bffe17 	ldw	r2,-8(fp)
 821d7b4:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 821d7b8:	e0bffe17 	ldw	r2,-8(fp)
 821d7bc:	10800883 	ldbu	r2,34(r2)
 821d7c0:	10803fcc 	andi	r2,r2,255
 821d7c4:	10800170 	cmpltui	r2,r2,5
 821d7c8:	1000061e 	bne	r2,zero,821d7e4 <lcd_handle_escape+0x1e4>
        sp->y = ALT_LCD_HEIGHT * 2;
 821d7cc:	e0bffe17 	ldw	r2,-8(fp)
 821d7d0:	00c00104 	movi	r3,4
 821d7d4:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
 821d7d8:	00000206 	br	821d7e4 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
 821d7dc:	e13ffe17 	ldw	r4,-8(fp)
 821d7e0:	821d5340 	call	821d534 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 821d7e4:	e0bffe17 	ldw	r2,-8(fp)
 821d7e8:	10800883 	ldbu	r2,34(r2)
 821d7ec:	10803fcc 	andi	r2,r2,255
 821d7f0:	108000e8 	cmpgeui	r2,r2,3
 821d7f4:	103ff91e 	bne	r2,zero,821d7dc <lcd_handle_escape+0x1dc>
        lcd_scroll_up(sp);
    }
    break;
 821d7f8:	00002106 	br	821d880 <lcd_handle_escape+0x280>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 821d7fc:	e0bffb17 	ldw	r2,-20(fp)
 821d800:	10800098 	cmpnei	r2,r2,2
 821d804:	1000201e 	bne	r2,zero,821d888 <lcd_handle_escape+0x288>
      lcd_clear_screen(sp);
 821d808:	e13ffe17 	ldw	r4,-8(fp)
 821d80c:	821d2780 	call	821d278 <lcd_clear_screen>
    break;
 821d810:	00001d06 	br	821d888 <lcd_handle_escape+0x288>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 821d814:	e0bffb17 	ldw	r2,-20(fp)
 821d818:	00801d16 	blt	zero,r2,821d890 <lcd_handle_escape+0x290>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821d81c:	e0bffe17 	ldw	r2,-8(fp)
 821d820:	10800843 	ldbu	r2,33(r2)
 821d824:	10803fcc 	andi	r2,r2,255
 821d828:	10801428 	cmpgeui	r2,r2,80
 821d82c:	1000181e 	bne	r2,zero,821d890 <lcd_handle_escape+0x290>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 821d830:	e0bffe17 	ldw	r2,-8(fp)
 821d834:	10800883 	ldbu	r2,34(r2)
 821d838:	10803fcc 	andi	r2,r2,255
 821d83c:	108018e4 	muli	r2,r2,99
 821d840:	10801004 	addi	r2,r2,64
 821d844:	e0fffe17 	ldw	r3,-8(fp)
 821d848:	1887883a 	add	r3,r3,r2
 821d84c:	e0bffe17 	ldw	r2,-8(fp)
 821d850:	10800843 	ldbu	r2,33(r2)
 821d854:	10803fcc 	andi	r2,r2,255
 821d858:	1889883a 	add	r4,r3,r2
 821d85c:	e0bffe17 	ldw	r2,-8(fp)
 821d860:	10800843 	ldbu	r2,33(r2)
 821d864:	10803fcc 	andi	r2,r2,255
 821d868:	00c01404 	movi	r3,80
 821d86c:	1885c83a 	sub	r2,r3,r2
 821d870:	100d883a 	mov	r6,r2
 821d874:	01400804 	movi	r5,32
 821d878:	8202f000 	call	8202f00 <memset>
    }
    break;
 821d87c:	00000406 	br	821d890 <lcd_handle_escape+0x290>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
 821d880:	0001883a 	nop
 821d884:	00000306 	br	821d894 <lcd_handle_escape+0x294>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
 821d888:	0001883a 	nop
 821d88c:	00000106 	br	821d894 <lcd_handle_escape+0x294>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
 821d890:	0001883a 	nop
  }
}
 821d894:	0001883a 	nop
 821d898:	e037883a 	mov	sp,fp
 821d89c:	dfc00117 	ldw	ra,4(sp)
 821d8a0:	df000017 	ldw	fp,0(sp)
 821d8a4:	dec00204 	addi	sp,sp,8
 821d8a8:	f800283a 	ret

0821d8ac <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 821d8ac:	defff104 	addi	sp,sp,-60
 821d8b0:	dfc00e15 	stw	ra,56(sp)
 821d8b4:	df000d15 	stw	fp,52(sp)
 821d8b8:	df000d04 	addi	fp,sp,52
 821d8bc:	e13ffc15 	stw	r4,-16(fp)
 821d8c0:	e17ffd15 	stw	r5,-12(fp)
 821d8c4:	e1bffe15 	stw	r6,-8(fp)
 821d8c8:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 821d8cc:	e0bffe17 	ldw	r2,-8(fp)
 821d8d0:	e0fffd17 	ldw	r3,-12(fp)
 821d8d4:	1885883a 	add	r2,r3,r2
 821d8d8:	e0bff615 	stw	r2,-40(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 821d8dc:	e0bffc17 	ldw	r2,-16(fp)
 821d8e0:	10803e17 	ldw	r2,248(r2)
 821d8e4:	e0bffa15 	stw	r2,-24(fp)
 821d8e8:	e03ffb0d 	sth	zero,-20(fp)
 821d8ec:	e0bffb0b 	ldhu	r2,-20(fp)
 821d8f0:	e0fffb84 	addi	r3,fp,-18
 821d8f4:	180d883a 	mov	r6,r3
 821d8f8:	100b883a 	mov	r5,r2
 821d8fc:	e13ffa17 	ldw	r4,-24(fp)
 821d900:	8219e200 	call	8219e20 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 821d904:	e0bffc17 	ldw	r2,-16(fp)
 821d908:	00c00044 	movi	r3,1
 821d90c:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
 821d910:	00009906 	br	821db78 <altera_avalon_lcd_16207_write+0x2cc>
  {
    char c = *ptr;
 821d914:	e0bffd17 	ldw	r2,-12(fp)
 821d918:	10800003 	ldbu	r2,0(r2)
 821d91c:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 821d920:	e0bffc17 	ldw	r2,-16(fp)
 821d924:	10800903 	ldbu	r2,36(r2)
 821d928:	10803fcc 	andi	r2,r2,255
 821d92c:	1080201c 	xori	r2,r2,128
 821d930:	10bfe004 	addi	r2,r2,-128
 821d934:	10003716 	blt	r2,zero,821da14 <altera_avalon_lcd_16207_write+0x168>
    {
      unsigned int esccount = sp->esccount;
 821d938:	e0bffc17 	ldw	r2,-16(fp)
 821d93c:	10800903 	ldbu	r2,36(r2)
 821d940:	10803fcc 	andi	r2,r2,255
 821d944:	1080201c 	xori	r2,r2,128
 821d948:	10bfe004 	addi	r2,r2,-128
 821d94c:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 821d950:	e0bff817 	ldw	r2,-32(fp)
 821d954:	1000031e 	bne	r2,zero,821d964 <altera_avalon_lcd_16207_write+0xb8>
 821d958:	e0bff707 	ldb	r2,-36(fp)
 821d95c:	108016d8 	cmpnei	r2,r2,91
 821d960:	10000d1e 	bne	r2,zero,821d998 <altera_avalon_lcd_16207_write+0xec>
 821d964:	e0bff817 	ldw	r2,-32(fp)
 821d968:	10001826 	beq	r2,zero,821d9cc <altera_avalon_lcd_16207_write+0x120>
          (esccount > 0 && !isdigit(c) && c != ';'))
 821d96c:	d0e00017 	ldw	r3,-32768(gp)
 821d970:	e0bff707 	ldb	r2,-36(fp)
 821d974:	10800044 	addi	r2,r2,1
 821d978:	1885883a 	add	r2,r3,r2
 821d97c:	10800003 	ldbu	r2,0(r2)
 821d980:	10803fcc 	andi	r2,r2,255
 821d984:	1080010c 	andi	r2,r2,4
 821d988:	1000101e 	bne	r2,zero,821d9cc <altera_avalon_lcd_16207_write+0x120>
 821d98c:	e0bff707 	ldb	r2,-36(fp)
 821d990:	10800ee0 	cmpeqi	r2,r2,59
 821d994:	10000d1e 	bne	r2,zero,821d9cc <altera_avalon_lcd_16207_write+0x120>
      {
        sp->escape[esccount] = 0;
 821d998:	e0fffc17 	ldw	r3,-16(fp)
 821d99c:	e0bff817 	ldw	r2,-32(fp)
 821d9a0:	1885883a 	add	r2,r3,r2
 821d9a4:	10800a04 	addi	r2,r2,40
 821d9a8:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 821d9ac:	e0bff707 	ldb	r2,-36(fp)
 821d9b0:	100b883a 	mov	r5,r2
 821d9b4:	e13ffc17 	ldw	r4,-16(fp)
 821d9b8:	821d6000 	call	821d600 <lcd_handle_escape>

        sp->esccount = -1;
 821d9bc:	e0bffc17 	ldw	r2,-16(fp)
 821d9c0:	00ffffc4 	movi	r3,-1
 821d9c4:	10c00905 	stb	r3,36(r2)
 821d9c8:	00006806 	br	821db6c <altera_avalon_lcd_16207_write+0x2c0>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 821d9cc:	e0bffc17 	ldw	r2,-16(fp)
 821d9d0:	10800903 	ldbu	r2,36(r2)
 821d9d4:	10803fcc 	andi	r2,r2,255
 821d9d8:	108001e8 	cmpgeui	r2,r2,7
 821d9dc:	1000631e 	bne	r2,zero,821db6c <altera_avalon_lcd_16207_write+0x2c0>
      {
        sp->escape[esccount] = c;
 821d9e0:	e0fffc17 	ldw	r3,-16(fp)
 821d9e4:	e0bff817 	ldw	r2,-32(fp)
 821d9e8:	1885883a 	add	r2,r3,r2
 821d9ec:	10800a04 	addi	r2,r2,40
 821d9f0:	e0fff703 	ldbu	r3,-36(fp)
 821d9f4:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
 821d9f8:	e0bffc17 	ldw	r2,-16(fp)
 821d9fc:	10800903 	ldbu	r2,36(r2)
 821da00:	10800044 	addi	r2,r2,1
 821da04:	1007883a 	mov	r3,r2
 821da08:	e0bffc17 	ldw	r2,-16(fp)
 821da0c:	10c00905 	stb	r3,36(r2)
 821da10:	00005606 	br	821db6c <altera_avalon_lcd_16207_write+0x2c0>
      }
    }
    else if (c == 27) /* ESC */
 821da14:	e0bff707 	ldb	r2,-36(fp)
 821da18:	108006d8 	cmpnei	r2,r2,27
 821da1c:	1000031e 	bne	r2,zero,821da2c <altera_avalon_lcd_16207_write+0x180>
    {
      sp->esccount = 0;
 821da20:	e0bffc17 	ldw	r2,-16(fp)
 821da24:	10000905 	stb	zero,36(r2)
 821da28:	00005006 	br	821db6c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\r')
 821da2c:	e0bff707 	ldb	r2,-36(fp)
 821da30:	10800358 	cmpnei	r2,r2,13
 821da34:	1000031e 	bne	r2,zero,821da44 <altera_avalon_lcd_16207_write+0x198>
    {
      sp->x = 0;
 821da38:	e0bffc17 	ldw	r2,-16(fp)
 821da3c:	10000845 	stb	zero,33(r2)
 821da40:	00004a06 	br	821db6c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\n')
 821da44:	e0bff707 	ldb	r2,-36(fp)
 821da48:	10800298 	cmpnei	r2,r2,10
 821da4c:	1000101e 	bne	r2,zero,821da90 <altera_avalon_lcd_16207_write+0x1e4>
    {
      sp->x = 0;
 821da50:	e0bffc17 	ldw	r2,-16(fp)
 821da54:	10000845 	stb	zero,33(r2)
      sp->y++;
 821da58:	e0bffc17 	ldw	r2,-16(fp)
 821da5c:	10800883 	ldbu	r2,34(r2)
 821da60:	10800044 	addi	r2,r2,1
 821da64:	1007883a 	mov	r3,r2
 821da68:	e0bffc17 	ldw	r2,-16(fp)
 821da6c:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 821da70:	e0bffc17 	ldw	r2,-16(fp)
 821da74:	10800883 	ldbu	r2,34(r2)
 821da78:	10803fcc 	andi	r2,r2,255
 821da7c:	108000f0 	cmpltui	r2,r2,3
 821da80:	10003a1e 	bne	r2,zero,821db6c <altera_avalon_lcd_16207_write+0x2c0>
        lcd_scroll_up(sp);
 821da84:	e13ffc17 	ldw	r4,-16(fp)
 821da88:	821d5340 	call	821d534 <lcd_scroll_up>
 821da8c:	00003706 	br	821db6c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\b')
 821da90:	e0bff707 	ldb	r2,-36(fp)
 821da94:	10800218 	cmpnei	r2,r2,8
 821da98:	10000b1e 	bne	r2,zero,821dac8 <altera_avalon_lcd_16207_write+0x21c>
    {
      if (sp->x > 0)
 821da9c:	e0bffc17 	ldw	r2,-16(fp)
 821daa0:	10800843 	ldbu	r2,33(r2)
 821daa4:	10803fcc 	andi	r2,r2,255
 821daa8:	10003026 	beq	r2,zero,821db6c <altera_avalon_lcd_16207_write+0x2c0>
        sp->x--;
 821daac:	e0bffc17 	ldw	r2,-16(fp)
 821dab0:	10800843 	ldbu	r2,33(r2)
 821dab4:	10bfffc4 	addi	r2,r2,-1
 821dab8:	1007883a 	mov	r3,r2
 821dabc:	e0bffc17 	ldw	r2,-16(fp)
 821dac0:	10c00845 	stb	r3,33(r2)
 821dac4:	00002906 	br	821db6c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (isprint(c))
 821dac8:	d0e00017 	ldw	r3,-32768(gp)
 821dacc:	e0bff707 	ldb	r2,-36(fp)
 821dad0:	10800044 	addi	r2,r2,1
 821dad4:	1885883a 	add	r2,r3,r2
 821dad8:	10800003 	ldbu	r2,0(r2)
 821dadc:	10803fcc 	andi	r2,r2,255
 821dae0:	1080201c 	xori	r2,r2,128
 821dae4:	10bfe004 	addi	r2,r2,-128
 821dae8:	108025cc 	andi	r2,r2,151
 821daec:	10001f26 	beq	r2,zero,821db6c <altera_avalon_lcd_16207_write+0x2c0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 821daf0:	e0bffc17 	ldw	r2,-16(fp)
 821daf4:	10800883 	ldbu	r2,34(r2)
 821daf8:	10803fcc 	andi	r2,r2,255
 821dafc:	108000b0 	cmpltui	r2,r2,2
 821db00:	1000021e 	bne	r2,zero,821db0c <altera_avalon_lcd_16207_write+0x260>
        lcd_scroll_up(sp);
 821db04:	e13ffc17 	ldw	r4,-16(fp)
 821db08:	821d5340 	call	821d534 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821db0c:	e0bffc17 	ldw	r2,-16(fp)
 821db10:	10800843 	ldbu	r2,33(r2)
 821db14:	10803fcc 	andi	r2,r2,255
 821db18:	10801428 	cmpgeui	r2,r2,80
 821db1c:	10000d1e 	bne	r2,zero,821db54 <altera_avalon_lcd_16207_write+0x2a8>
        sp->line[sp->y].data[sp->x] = c;
 821db20:	e0bffc17 	ldw	r2,-16(fp)
 821db24:	10800883 	ldbu	r2,34(r2)
 821db28:	10c03fcc 	andi	r3,r2,255
 821db2c:	e0bffc17 	ldw	r2,-16(fp)
 821db30:	10800843 	ldbu	r2,33(r2)
 821db34:	10803fcc 	andi	r2,r2,255
 821db38:	e13ffc17 	ldw	r4,-16(fp)
 821db3c:	18c018e4 	muli	r3,r3,99
 821db40:	20c7883a 	add	r3,r4,r3
 821db44:	1885883a 	add	r2,r3,r2
 821db48:	10801004 	addi	r2,r2,64
 821db4c:	e0fff703 	ldbu	r3,-36(fp)
 821db50:	10c00005 	stb	r3,0(r2)

      sp->x++;
 821db54:	e0bffc17 	ldw	r2,-16(fp)
 821db58:	10800843 	ldbu	r2,33(r2)
 821db5c:	10800044 	addi	r2,r2,1
 821db60:	1007883a 	mov	r3,r2
 821db64:	e0bffc17 	ldw	r2,-16(fp)
 821db68:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 821db6c:	e0bffd17 	ldw	r2,-12(fp)
 821db70:	10800044 	addi	r2,r2,1
 821db74:	e0bffd15 	stw	r2,-12(fp)
 821db78:	e0fffd17 	ldw	r3,-12(fp)
 821db7c:	e0bff617 	ldw	r2,-40(fp)
 821db80:	18bf6436 	bltu	r3,r2,821d914 <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 821db84:	00800404 	movi	r2,16
 821db88:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821db8c:	e03ff315 	stw	zero,-52(fp)
 821db90:	00003706 	br	821dc70 <altera_avalon_lcd_16207_write+0x3c4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821db94:	00801404 	movi	r2,80
 821db98:	e0bff515 	stw	r2,-44(fp)
 821db9c:	00001106 	br	821dbe4 <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
 821dba0:	e0bff517 	ldw	r2,-44(fp)
 821dba4:	10bfffc4 	addi	r2,r2,-1
 821dba8:	e13ffc17 	ldw	r4,-16(fp)
 821dbac:	e0fff317 	ldw	r3,-52(fp)
 821dbb0:	18c018e4 	muli	r3,r3,99
 821dbb4:	20c7883a 	add	r3,r4,r3
 821dbb8:	1885883a 	add	r2,r3,r2
 821dbbc:	10801004 	addi	r2,r2,64
 821dbc0:	10800003 	ldbu	r2,0(r2)
 821dbc4:	10803fcc 	andi	r2,r2,255
 821dbc8:	1080201c 	xori	r2,r2,128
 821dbcc:	10bfe004 	addi	r2,r2,-128
 821dbd0:	10800820 	cmpeqi	r2,r2,32
 821dbd4:	10000626 	beq	r2,zero,821dbf0 <altera_avalon_lcd_16207_write+0x344>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821dbd8:	e0bff517 	ldw	r2,-44(fp)
 821dbdc:	10bfffc4 	addi	r2,r2,-1
 821dbe0:	e0bff515 	stw	r2,-44(fp)
 821dbe4:	e0bff517 	ldw	r2,-44(fp)
 821dbe8:	00bfed16 	blt	zero,r2,821dba0 <altera_avalon_lcd_16207_write+0x2f4>
 821dbec:	00000106 	br	821dbf4 <altera_avalon_lcd_16207_write+0x348>
      if (sp->line[y].data[width-1] != ' ')
        break;
 821dbf0:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 821dbf4:	e0bff517 	ldw	r2,-44(fp)
 821dbf8:	10800448 	cmpgei	r2,r2,17
 821dbfc:	1000031e 	bne	r2,zero,821dc0c <altera_avalon_lcd_16207_write+0x360>
      width = ALT_LCD_WIDTH;
 821dc00:	00800404 	movi	r2,16
 821dc04:	e0bff515 	stw	r2,-44(fp)
 821dc08:	00000306 	br	821dc18 <altera_avalon_lcd_16207_write+0x36c>
    else
      width++;
 821dc0c:	e0bff517 	ldw	r2,-44(fp)
 821dc10:	10800044 	addi	r2,r2,1
 821dc14:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 821dc18:	e0bff517 	ldw	r2,-44(fp)
 821dc1c:	1009883a 	mov	r4,r2
 821dc20:	e0fffc17 	ldw	r3,-16(fp)
 821dc24:	e0bff317 	ldw	r2,-52(fp)
 821dc28:	108018e4 	muli	r2,r2,99
 821dc2c:	1885883a 	add	r2,r3,r2
 821dc30:	10802444 	addi	r2,r2,145
 821dc34:	11000005 	stb	r4,0(r2)
    if (widthmax < width)
 821dc38:	e0fff417 	ldw	r3,-48(fp)
 821dc3c:	e0bff517 	ldw	r2,-44(fp)
 821dc40:	1880020e 	bge	r3,r2,821dc4c <altera_avalon_lcd_16207_write+0x3a0>
      widthmax = width;
 821dc44:	e0bff517 	ldw	r2,-44(fp)
 821dc48:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 821dc4c:	e0fffc17 	ldw	r3,-16(fp)
 821dc50:	e0bff317 	ldw	r2,-52(fp)
 821dc54:	108018e4 	muli	r2,r2,99
 821dc58:	1885883a 	add	r2,r3,r2
 821dc5c:	10802484 	addi	r2,r2,146
 821dc60:	10000005 	stb	zero,0(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dc64:	e0bff317 	ldw	r2,-52(fp)
 821dc68:	10800044 	addi	r2,r2,1
 821dc6c:	e0bff315 	stw	r2,-52(fp)
 821dc70:	e0bff317 	ldw	r2,-52(fp)
 821dc74:	10800090 	cmplti	r2,r2,2
 821dc78:	103fc61e 	bne	r2,zero,821db94 <altera_avalon_lcd_16207_write+0x2e8>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 821dc7c:	e0bff417 	ldw	r2,-48(fp)
 821dc80:	10800448 	cmpgei	r2,r2,17
 821dc84:	1000031e 	bne	r2,zero,821dc94 <altera_avalon_lcd_16207_write+0x3e8>
    sp->scrollmax = 0;
 821dc88:	e0bffc17 	ldw	r2,-16(fp)
 821dc8c:	10000985 	stb	zero,38(r2)
 821dc90:	00002e06 	br	821dd4c <altera_avalon_lcd_16207_write+0x4a0>
  else
  {
    widthmax *= 2;
 821dc94:	e0bff417 	ldw	r2,-48(fp)
 821dc98:	1085883a 	add	r2,r2,r2
 821dc9c:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
 821dca0:	e0bff417 	ldw	r2,-48(fp)
 821dca4:	1007883a 	mov	r3,r2
 821dca8:	e0bffc17 	ldw	r2,-16(fp)
 821dcac:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dcb0:	e03ff315 	stw	zero,-52(fp)
 821dcb4:	00002206 	br	821dd40 <altera_avalon_lcd_16207_write+0x494>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 821dcb8:	e0fffc17 	ldw	r3,-16(fp)
 821dcbc:	e0bff317 	ldw	r2,-52(fp)
 821dcc0:	108018e4 	muli	r2,r2,99
 821dcc4:	1885883a 	add	r2,r3,r2
 821dcc8:	10802444 	addi	r2,r2,145
 821dccc:	10800003 	ldbu	r2,0(r2)
 821dcd0:	10803fcc 	andi	r2,r2,255
 821dcd4:	1080201c 	xori	r2,r2,128
 821dcd8:	10bfe004 	addi	r2,r2,-128
 821dcdc:	10800450 	cmplti	r2,r2,17
 821dce0:	1000141e 	bne	r2,zero,821dd34 <altera_avalon_lcd_16207_write+0x488>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 821dce4:	e0fffc17 	ldw	r3,-16(fp)
 821dce8:	e0bff317 	ldw	r2,-52(fp)
 821dcec:	108018e4 	muli	r2,r2,99
 821dcf0:	1885883a 	add	r2,r3,r2
 821dcf4:	10802444 	addi	r2,r2,145
 821dcf8:	10800003 	ldbu	r2,0(r2)
 821dcfc:	10803fcc 	andi	r2,r2,255
 821dd00:	1080201c 	xori	r2,r2,128
 821dd04:	10bfe004 	addi	r2,r2,-128
 821dd08:	1004923a 	slli	r2,r2,8
 821dd0c:	e17ff417 	ldw	r5,-48(fp)
 821dd10:	1009883a 	mov	r4,r2
 821dd14:	82028640 	call	8202864 <__divsi3>
 821dd18:	1009883a 	mov	r4,r2
 821dd1c:	e0fffc17 	ldw	r3,-16(fp)
 821dd20:	e0bff317 	ldw	r2,-52(fp)
 821dd24:	108018e4 	muli	r2,r2,99
 821dd28:	1885883a 	add	r2,r3,r2
 821dd2c:	10802484 	addi	r2,r2,146
 821dd30:	11000005 	stb	r4,0(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dd34:	e0bff317 	ldw	r2,-52(fp)
 821dd38:	10800044 	addi	r2,r2,1
 821dd3c:	e0bff315 	stw	r2,-52(fp)
 821dd40:	e0bff317 	ldw	r2,-52(fp)
 821dd44:	10800090 	cmplti	r2,r2,2
 821dd48:	103fdb1e 	bne	r2,zero,821dcb8 <altera_avalon_lcd_16207_write+0x40c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 821dd4c:	e0bffc17 	ldw	r2,-16(fp)
 821dd50:	10800943 	ldbu	r2,37(r2)
 821dd54:	10803fcc 	andi	r2,r2,255
 821dd58:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
 821dd5c:	e13ffc17 	ldw	r4,-16(fp)
 821dd60:	821d3480 	call	821d348 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 821dd64:	e0bffc17 	ldw	r2,-16(fp)
 821dd68:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 821dd6c:	e0bffc17 	ldw	r2,-16(fp)
 821dd70:	10800943 	ldbu	r2,37(r2)
 821dd74:	10c03fcc 	andi	r3,r2,255
 821dd78:	e0bff917 	ldw	r2,-28(fp)
 821dd7c:	18800426 	beq	r3,r2,821dd90 <altera_avalon_lcd_16207_write+0x4e4>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 821dd80:	e0bffc17 	ldw	r2,-16(fp)
 821dd84:	00c00044 	movi	r3,1
 821dd88:	10c009c5 	stb	r3,39(r2)
  }
 821dd8c:	003fef06 	br	821dd4c <altera_avalon_lcd_16207_write+0x4a0>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
 821dd90:	0001883a 	nop

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 821dd94:	e0bffc17 	ldw	r2,-16(fp)
 821dd98:	10803e17 	ldw	r2,248(r2)
 821dd9c:	1009883a 	mov	r4,r2
 821dda0:	821a1980 	call	821a198 <OSSemPost>

  return len;
 821dda4:	e0bffe17 	ldw	r2,-8(fp)
}
 821dda8:	e037883a 	mov	sp,fp
 821ddac:	dfc00117 	ldw	ra,4(sp)
 821ddb0:	df000017 	ldw	fp,0(sp)
 821ddb4:	dec00204 	addi	sp,sp,8
 821ddb8:	f800283a 	ret

0821ddbc <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 821ddbc:	defffc04 	addi	sp,sp,-16
 821ddc0:	dfc00315 	stw	ra,12(sp)
 821ddc4:	df000215 	stw	fp,8(sp)
 821ddc8:	df000204 	addi	fp,sp,8
 821ddcc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 821ddd0:	e0bfff17 	ldw	r2,-4(fp)
 821ddd4:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 821ddd8:	e0bffe17 	ldw	r2,-8(fp)
 821dddc:	10800943 	ldbu	r2,37(r2)
 821dde0:	10803fcc 	andi	r2,r2,255
 821dde4:	10c00044 	addi	r3,r2,1
 821dde8:	e0bffe17 	ldw	r2,-8(fp)
 821ddec:	10800983 	ldbu	r2,38(r2)
 821ddf0:	10803fcc 	andi	r2,r2,255
 821ddf4:	18800316 	blt	r3,r2,821de04 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
 821ddf8:	e0bffe17 	ldw	r2,-8(fp)
 821ddfc:	10000945 	stb	zero,37(r2)
 821de00:	00000606 	br	821de1c <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
 821de04:	e0bffe17 	ldw	r2,-8(fp)
 821de08:	10800943 	ldbu	r2,37(r2)
 821de0c:	10800044 	addi	r2,r2,1
 821de10:	1007883a 	mov	r3,r2
 821de14:	e0bffe17 	ldw	r2,-8(fp)
 821de18:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 821de1c:	e0bffe17 	ldw	r2,-8(fp)
 821de20:	10800983 	ldbu	r2,38(r2)
 821de24:	10803fcc 	andi	r2,r2,255
 821de28:	10000826 	beq	r2,zero,821de4c <alt_lcd_16207_timeout+0x90>
 821de2c:	e0bffe17 	ldw	r2,-8(fp)
 821de30:	108009c3 	ldbu	r2,39(r2)
 821de34:	10803fcc 	andi	r2,r2,255
 821de38:	1080201c 	xori	r2,r2,128
 821de3c:	10bfe004 	addi	r2,r2,-128
 821de40:	1000021e 	bne	r2,zero,821de4c <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
 821de44:	e13ffe17 	ldw	r4,-8(fp)
 821de48:	821d3480 	call	821d348 <lcd_repaint_screen>

  return sp->period;
 821de4c:	e0bffe17 	ldw	r2,-8(fp)
 821de50:	10800717 	ldw	r2,28(r2)
}
 821de54:	e037883a 	mov	sp,fp
 821de58:	dfc00117 	ldw	ra,4(sp)
 821de5c:	df000017 	ldw	fp,0(sp)
 821de60:	dec00204 	addi	sp,sp,8
 821de64:	f800283a 	ret

0821de68 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 821de68:	defff604 	addi	sp,sp,-40
 821de6c:	dfc00915 	stw	ra,36(sp)
 821de70:	df000815 	stw	fp,32(sp)
 821de74:	dc400715 	stw	r17,28(sp)
 821de78:	dc000615 	stw	r16,24(sp)
 821de7c:	df000804 	addi	fp,sp,32
 821de80:	e13ffb15 	stw	r4,-20(fp)
  unsigned int base = sp->base;
 821de84:	e0bffb17 	ldw	r2,-20(fp)
 821de88:	10800017 	ldw	r2,0(r2)
 821de8c:	e0bff815 	stw	r2,-32(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 821de90:	e0bffb17 	ldw	r2,-20(fp)
 821de94:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 821de98:	e0bffb17 	ldw	r2,-20(fp)
 821de9c:	10803e04 	addi	r2,r2,248
 821dea0:	e0bff915 	stw	r2,-28(fp)
 821dea4:	00800044 	movi	r2,1
 821dea8:	e0bffa0d 	sth	r2,-24(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 821deac:	e0bffa0b 	ldhu	r2,-24(fp)
 821deb0:	1009883a 	mov	r4,r2
 821deb4:	8219b080 	call	8219b08 <OSSemCreate>
 821deb8:	1007883a 	mov	r3,r2
 821debc:	e0bff917 	ldw	r2,-28(fp)
 821dec0:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 821dec4:	010ea604 	movi	r4,15000
 821dec8:	823c7700 	call	823c770 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821decc:	e0bff817 	ldw	r2,-32(fp)
 821ded0:	00c00c04 	movi	r3,48
 821ded4:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 821ded8:	01040104 	movi	r4,4100
 821dedc:	823c7700 	call	823c770 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821dee0:	e0bff817 	ldw	r2,-32(fp)
 821dee4:	00c00c04 	movi	r3,48
 821dee8:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 821deec:	0100fa04 	movi	r4,1000
 821def0:	823c7700 	call	823c770 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821def4:	e0bff817 	ldw	r2,-32(fp)
 821def8:	00c00c04 	movi	r3,48
 821defc:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 821df00:	01400e04 	movi	r5,56
 821df04:	e13ffb17 	ldw	r4,-20(fp)
 821df08:	821d0e80 	call	821d0e8 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 821df0c:	01400204 	movi	r5,8
 821df10:	e13ffb17 	ldw	r4,-20(fp)
 821df14:	821d0e80 	call	821d0e8 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 821df18:	e13ffb17 	ldw	r4,-20(fp)
 821df1c:	821d2780 	call	821d278 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 821df20:	01400184 	movi	r5,6
 821df24:	e13ffb17 	ldw	r4,-20(fp)
 821df28:	821d0e80 	call	821d0e8 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 821df2c:	01400304 	movi	r5,12
 821df30:	e13ffb17 	ldw	r4,-20(fp)
 821df34:	821d0e80 	call	821d0e8 <lcd_write_command>

  sp->esccount = -1;
 821df38:	e0bffb17 	ldw	r2,-20(fp)
 821df3c:	00ffffc4 	movi	r3,-1
 821df40:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
 821df44:	e0bffb17 	ldw	r2,-20(fp)
 821df48:	10800a04 	addi	r2,r2,40
 821df4c:	01800204 	movi	r6,8
 821df50:	000b883a 	mov	r5,zero
 821df54:	1009883a 	mov	r4,r2
 821df58:	8202f000 	call	8202f00 <memset>

  sp->scrollpos = 0;
 821df5c:	e0bffb17 	ldw	r2,-20(fp)
 821df60:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 821df64:	e0bffb17 	ldw	r2,-20(fp)
 821df68:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 821df6c:	e0bffb17 	ldw	r2,-20(fp)
 821df70:	100009c5 	stb	zero,39(r2)
 821df74:	d0e0b817 	ldw	r3,-32032(gp)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 821df78:	00b33374 	movhi	r2,52429
 821df7c:	10b33344 	addi	r2,r2,-13107
 821df80:	1888383a 	mulxuu	r4,r3,r2
 821df84:	1885383a 	mul	r2,r3,r2
 821df88:	1021883a 	mov	r16,r2
 821df8c:	2023883a 	mov	r17,r4
 821df90:	8804d0fa 	srli	r2,r17,3
 821df94:	1007883a 	mov	r3,r2
 821df98:	e0bffb17 	ldw	r2,-20(fp)
 821df9c:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 821dfa0:	e0bffb17 	ldw	r2,-20(fp)
 821dfa4:	10c00104 	addi	r3,r2,4
 821dfa8:	e0bffb17 	ldw	r2,-20(fp)
 821dfac:	10800717 	ldw	r2,28(r2)
 821dfb0:	e1fffb17 	ldw	r7,-20(fp)
 821dfb4:	018208b4 	movhi	r6,2082
 821dfb8:	31b76f04 	addi	r6,r6,-8772
 821dfbc:	100b883a 	mov	r5,r2
 821dfc0:	1809883a 	mov	r4,r3
 821dfc4:	823b8200 	call	823b820 <alt_alarm_start>
}
 821dfc8:	0001883a 	nop
 821dfcc:	e6fffe04 	addi	sp,fp,-8
 821dfd0:	dfc00317 	ldw	ra,12(sp)
 821dfd4:	df000217 	ldw	fp,8(sp)
 821dfd8:	dc400117 	ldw	r17,4(sp)
 821dfdc:	dc000017 	ldw	r16,0(sp)
 821dfe0:	dec00404 	addi	sp,sp,16
 821dfe4:	f800283a 	ret

0821dfe8 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821dfe8:	defffa04 	addi	sp,sp,-24
 821dfec:	dfc00515 	stw	ra,20(sp)
 821dff0:	df000415 	stw	fp,16(sp)
 821dff4:	df000404 	addi	fp,sp,16
 821dff8:	e13ffd15 	stw	r4,-12(fp)
 821dffc:	e17ffe15 	stw	r5,-8(fp)
 821e000:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 821e004:	e0bffd17 	ldw	r2,-12(fp)
 821e008:	10800017 	ldw	r2,0(r2)
 821e00c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 821e010:	e0bffc17 	ldw	r2,-16(fp)
 821e014:	10c00a04 	addi	r3,r2,40
 821e018:	e0bffd17 	ldw	r2,-12(fp)
 821e01c:	10800217 	ldw	r2,8(r2)
 821e020:	100f883a 	mov	r7,r2
 821e024:	e1bfff17 	ldw	r6,-4(fp)
 821e028:	e17ffe17 	ldw	r5,-8(fp)
 821e02c:	1809883a 	mov	r4,r3
 821e030:	821d8ac0 	call	821d8ac <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 821e034:	e037883a 	mov	sp,fp
 821e038:	dfc00117 	ldw	ra,4(sp)
 821e03c:	df000017 	ldw	fp,0(sp)
 821e040:	dec00204 	addi	sp,sp,8
 821e044:	f800283a 	ret

0821e048 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 821e048:	defffe04 	addi	sp,sp,-8
 821e04c:	dfc00115 	stw	ra,4(sp)
 821e050:	df000015 	stw	fp,0(sp)
 821e054:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 821e058:	d0a04717 	ldw	r2,-32484(gp)
 821e05c:	10000326 	beq	r2,zero,821e06c <alt_get_errno+0x24>
 821e060:	d0a04717 	ldw	r2,-32484(gp)
 821e064:	103ee83a 	callr	r2
 821e068:	00000106 	br	821e070 <alt_get_errno+0x28>
 821e06c:	d0a06304 	addi	r2,gp,-32372
}
 821e070:	e037883a 	mov	sp,fp
 821e074:	dfc00117 	ldw	ra,4(sp)
 821e078:	df000017 	ldw	fp,0(sp)
 821e07c:	dec00204 	addi	sp,sp,8
 821e080:	f800283a 	ret

0821e084 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e084:	defffc04 	addi	sp,sp,-16
 821e088:	df000315 	stw	fp,12(sp)
 821e08c:	df000304 	addi	fp,sp,12
 821e090:	e13ffe15 	stw	r4,-8(fp)
 821e094:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e098:	e0bffe17 	ldw	r2,-8(fp)
 821e09c:	10800317 	ldw	r2,12(r2)
 821e0a0:	10800037 	ldwio	r2,0(r2)
 821e0a4:	1080040c 	andi	r2,r2,16
 821e0a8:	10000226 	beq	r2,zero,821e0b4 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 821e0ac:	00bffc04 	movi	r2,-16
 821e0b0:	00003906 	br	821e198 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e0b4:	e0bffe17 	ldw	r2,-8(fp)
 821e0b8:	10800317 	ldw	r2,12(r2)
 821e0bc:	10800404 	addi	r2,r2,16
 821e0c0:	e0fffe17 	ldw	r3,-8(fp)
 821e0c4:	18c00317 	ldw	r3,12(r3)
 821e0c8:	18c00404 	addi	r3,r3,16
 821e0cc:	19000037 	ldwio	r4,0(r3)
 821e0d0:	00fff7c4 	movi	r3,-33
 821e0d4:	20c6703a 	and	r3,r4,r3
 821e0d8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e0dc:	e0bffe17 	ldw	r2,-8(fp)
 821e0e0:	10800317 	ldw	r2,12(r2)
 821e0e4:	00c03fc4 	movi	r3,255
 821e0e8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e0ec:	e0bffe17 	ldw	r2,-8(fp)
 821e0f0:	10800317 	ldw	r2,12(r2)
 821e0f4:	10800804 	addi	r2,r2,32
 821e0f8:	e0ffff17 	ldw	r3,-4(fp)
 821e0fc:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 821e100:	e0bffe17 	ldw	r2,-8(fp)
 821e104:	10800917 	ldw	r2,36(r2)
 821e108:	10001126 	beq	r2,zero,821e150 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e10c:	e0bffe17 	ldw	r2,-8(fp)
 821e110:	10800317 	ldw	r2,12(r2)
 821e114:	10800404 	addi	r2,r2,16
 821e118:	10800037 	ldwio	r2,0(r2)
 821e11c:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 821e120:	e0bffe17 	ldw	r2,-8(fp)
 821e124:	10c00b17 	ldw	r3,44(r2)
 821e128:	e0bffd17 	ldw	r2,-12(fp)
 821e12c:	1884b03a 	or	r2,r3,r2
 821e130:	10801814 	ori	r2,r2,96
 821e134:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e138:	e0bffe17 	ldw	r2,-8(fp)
 821e13c:	10800317 	ldw	r2,12(r2)
 821e140:	10800404 	addi	r2,r2,16
 821e144:	e0fffd17 	ldw	r3,-12(fp)
 821e148:	10c00035 	stwio	r3,0(r2)
 821e14c:	00001106 	br	821e194 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e150:	e0bffe17 	ldw	r2,-8(fp)
 821e154:	10800317 	ldw	r2,12(r2)
 821e158:	10800404 	addi	r2,r2,16
 821e15c:	10800037 	ldwio	r2,0(r2)
 821e160:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 821e164:	e0bffd17 	ldw	r2,-12(fp)
 821e168:	10801814 	ori	r2,r2,96
 821e16c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 821e170:	e0fffd17 	ldw	r3,-12(fp)
 821e174:	00bffbc4 	movi	r2,-17
 821e178:	1884703a 	and	r2,r3,r2
 821e17c:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e180:	e0bffe17 	ldw	r2,-8(fp)
 821e184:	10800317 	ldw	r2,12(r2)
 821e188:	10800404 	addi	r2,r2,16
 821e18c:	e0fffd17 	ldw	r3,-12(fp)
 821e190:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 821e194:	0005883a 	mov	r2,zero
}
 821e198:	e037883a 	mov	sp,fp
 821e19c:	df000017 	ldw	fp,0(sp)
 821e1a0:	dec00104 	addi	sp,sp,4
 821e1a4:	f800283a 	ret

0821e1a8 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e1a8:	defffc04 	addi	sp,sp,-16
 821e1ac:	df000315 	stw	fp,12(sp)
 821e1b0:	df000304 	addi	fp,sp,12
 821e1b4:	e13ffe15 	stw	r4,-8(fp)
 821e1b8:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e1bc:	0001883a 	nop
 821e1c0:	e0bffe17 	ldw	r2,-8(fp)
 821e1c4:	10800317 	ldw	r2,12(r2)
 821e1c8:	10800037 	ldwio	r2,0(r2)
 821e1cc:	1080040c 	andi	r2,r2,16
 821e1d0:	103ffb1e 	bne	r2,zero,821e1c0 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e1d4:	e0bffe17 	ldw	r2,-8(fp)
 821e1d8:	10800317 	ldw	r2,12(r2)
 821e1dc:	10800404 	addi	r2,r2,16
 821e1e0:	e0fffe17 	ldw	r3,-8(fp)
 821e1e4:	18c00317 	ldw	r3,12(r3)
 821e1e8:	18c00404 	addi	r3,r3,16
 821e1ec:	19000037 	ldwio	r4,0(r3)
 821e1f0:	00fff7c4 	movi	r3,-33
 821e1f4:	20c6703a 	and	r3,r4,r3
 821e1f8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e1fc:	e0bffe17 	ldw	r2,-8(fp)
 821e200:	10800317 	ldw	r2,12(r2)
 821e204:	00c03fc4 	movi	r3,255
 821e208:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e20c:	e0bffe17 	ldw	r2,-8(fp)
 821e210:	10800317 	ldw	r2,12(r2)
 821e214:	10800804 	addi	r2,r2,32
 821e218:	e0ffff17 	ldw	r3,-4(fp)
 821e21c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e220:	e0bffe17 	ldw	r2,-8(fp)
 821e224:	10800317 	ldw	r2,12(r2)
 821e228:	10800404 	addi	r2,r2,16
 821e22c:	e0fffe17 	ldw	r3,-8(fp)
 821e230:	18c00317 	ldw	r3,12(r3)
 821e234:	18c00404 	addi	r3,r3,16
 821e238:	18c00037 	ldwio	r3,0(r3)
 821e23c:	18c01814 	ori	r3,r3,96
 821e240:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e244:	0001883a 	nop
 821e248:	e0bffe17 	ldw	r2,-8(fp)
 821e24c:	10800317 	ldw	r2,12(r2)
 821e250:	10800037 	ldwio	r2,0(r2)
 821e254:	1080040c 	andi	r2,r2,16
 821e258:	103ffb1e 	bne	r2,zero,821e248 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821e25c:	e0bffe17 	ldw	r2,-8(fp)
 821e260:	10800317 	ldw	r2,12(r2)
 821e264:	10800404 	addi	r2,r2,16
 821e268:	e0fffe17 	ldw	r3,-8(fp)
 821e26c:	18c00317 	ldw	r3,12(r3)
 821e270:	18c00404 	addi	r3,r3,16
 821e274:	19000037 	ldwio	r4,0(r3)
 821e278:	00fff7c4 	movi	r3,-33
 821e27c:	20c6703a 	and	r3,r4,r3
 821e280:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 821e284:	e0bffe17 	ldw	r2,-8(fp)
 821e288:	10800317 	ldw	r2,12(r2)
 821e28c:	10800037 	ldwio	r2,0(r2)
 821e290:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e294:	e0bffe17 	ldw	r2,-8(fp)
 821e298:	10800317 	ldw	r2,12(r2)
 821e29c:	00c03fc4 	movi	r3,255
 821e2a0:	10c00035 	stwio	r3,0(r2)

  return status;
 821e2a4:	e0bffd03 	ldbu	r2,-12(fp)
}
 821e2a8:	e037883a 	mov	sp,fp
 821e2ac:	df000017 	ldw	fp,0(sp)
 821e2b0:	dec00104 	addi	sp,sp,4
 821e2b4:	f800283a 	ret

0821e2b8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 821e2b8:	defff404 	addi	sp,sp,-48
 821e2bc:	dfc00b15 	stw	ra,44(sp)
 821e2c0:	df000a15 	stw	fp,40(sp)
 821e2c4:	df000a04 	addi	fp,sp,40
 821e2c8:	e13ffb15 	stw	r4,-20(fp)
 821e2cc:	e17ffc15 	stw	r5,-16(fp)
 821e2d0:	e1bffd15 	stw	r6,-12(fp)
 821e2d4:	e1fffe15 	stw	r7,-8(fp)
 821e2d8:	e0800217 	ldw	r2,8(fp)
 821e2dc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 821e2e0:	e0bfff0b 	ldhu	r2,-4(fp)
 821e2e4:	d8000415 	stw	zero,16(sp)
 821e2e8:	d8000315 	stw	zero,12(sp)
 821e2ec:	e0c00417 	ldw	r3,16(fp)
 821e2f0:	d8c00215 	stw	r3,8(sp)
 821e2f4:	e0c00317 	ldw	r3,12(fp)
 821e2f8:	d8c00115 	stw	r3,4(sp)
 821e2fc:	d8800015 	stw	r2,0(sp)
 821e300:	e1fffe17 	ldw	r7,-8(fp)
 821e304:	e1bffd17 	ldw	r6,-12(fp)
 821e308:	e17ffc17 	ldw	r5,-16(fp)
 821e30c:	e13ffb17 	ldw	r4,-20(fp)
 821e310:	821e32c0 	call	821e32c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 821e314:	0001883a 	nop
 821e318:	e037883a 	mov	sp,fp
 821e31c:	dfc00117 	ldw	ra,4(sp)
 821e320:	df000017 	ldw	fp,0(sp)
 821e324:	dec00204 	addi	sp,sp,8
 821e328:	f800283a 	ret

0821e32c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 821e32c:	defff204 	addi	sp,sp,-56
 821e330:	dfc00d15 	stw	ra,52(sp)
 821e334:	df000c15 	stw	fp,48(sp)
 821e338:	df000c04 	addi	fp,sp,48
 821e33c:	e13ffb15 	stw	r4,-20(fp)
 821e340:	e17ffc15 	stw	r5,-16(fp)
 821e344:	e1bffd15 	stw	r6,-12(fp)
 821e348:	e1fffe15 	stw	r7,-8(fp)
 821e34c:	e0800217 	ldw	r2,8(fp)
 821e350:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e354:	e0bfff0b 	ldhu	r2,-4(fp)
 821e358:	d8000615 	stw	zero,24(sp)
 821e35c:	e0c00617 	ldw	r3,24(fp)
 821e360:	d8c00515 	stw	r3,20(sp)
 821e364:	e0c00517 	ldw	r3,20(fp)
 821e368:	d8c00415 	stw	r3,16(sp)
 821e36c:	e0c00417 	ldw	r3,16(fp)
 821e370:	d8c00315 	stw	r3,12(sp)
 821e374:	e0c00317 	ldw	r3,12(fp)
 821e378:	d8c00215 	stw	r3,8(sp)
 821e37c:	d8000115 	stw	zero,4(sp)
 821e380:	d8800015 	stw	r2,0(sp)
 821e384:	e1fffe17 	ldw	r7,-8(fp)
 821e388:	e1bffd17 	ldw	r6,-12(fp)
 821e38c:	e17ffc17 	ldw	r5,-16(fp)
 821e390:	e13ffb17 	ldw	r4,-20(fp)
 821e394:	821e8c00 	call	821e8c0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 821e398:	0001883a 	nop
 821e39c:	e037883a 	mov	sp,fp
 821e3a0:	dfc00117 	ldw	ra,4(sp)
 821e3a4:	df000017 	ldw	fp,0(sp)
 821e3a8:	dec00204 	addi	sp,sp,8
 821e3ac:	f800283a 	ret

0821e3b0 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 821e3b0:	defff804 	addi	sp,sp,-32
 821e3b4:	dfc00715 	stw	ra,28(sp)
 821e3b8:	df000615 	stw	fp,24(sp)
 821e3bc:	df000604 	addi	fp,sp,24
 821e3c0:	e13ffc15 	stw	r4,-16(fp)
 821e3c4:	e17ffd15 	stw	r5,-12(fp)
 821e3c8:	e1bffe15 	stw	r6,-8(fp)
 821e3cc:	3805883a 	mov	r2,r7
 821e3d0:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 821e3d4:	e0ffff0b 	ldhu	r3,-4(fp)
 821e3d8:	d8000115 	stw	zero,4(sp)
 821e3dc:	e0800217 	ldw	r2,8(fp)
 821e3e0:	d8800015 	stw	r2,0(sp)
 821e3e4:	180f883a 	mov	r7,r3
 821e3e8:	e1bffe17 	ldw	r6,-8(fp)
 821e3ec:	e17ffd17 	ldw	r5,-12(fp)
 821e3f0:	e13ffc17 	ldw	r4,-16(fp)
 821e3f4:	821e4100 	call	821e410 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 821e3f8:	0001883a 	nop
 821e3fc:	e037883a 	mov	sp,fp
 821e400:	dfc00117 	ldw	ra,4(sp)
 821e404:	df000017 	ldw	fp,0(sp)
 821e408:	dec00204 	addi	sp,sp,8
 821e40c:	f800283a 	ret

0821e410 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 821e410:	defff304 	addi	sp,sp,-52
 821e414:	dfc00c15 	stw	ra,48(sp)
 821e418:	df000b15 	stw	fp,44(sp)
 821e41c:	df000b04 	addi	fp,sp,44
 821e420:	e13ffc15 	stw	r4,-16(fp)
 821e424:	e17ffd15 	stw	r5,-12(fp)
 821e428:	e1bffe15 	stw	r6,-8(fp)
 821e42c:	3805883a 	mov	r2,r7
 821e430:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e434:	e0bfff0b 	ldhu	r2,-4(fp)
 821e438:	d8000615 	stw	zero,24(sp)
 821e43c:	e0c00317 	ldw	r3,12(fp)
 821e440:	d8c00515 	stw	r3,20(sp)
 821e444:	d8000415 	stw	zero,16(sp)
 821e448:	e0c00217 	ldw	r3,8(fp)
 821e44c:	d8c00315 	stw	r3,12(sp)
 821e450:	d8000215 	stw	zero,8(sp)
 821e454:	d8000115 	stw	zero,4(sp)
 821e458:	d8800015 	stw	r2,0(sp)
 821e45c:	e1fffe17 	ldw	r7,-8(fp)
 821e460:	000d883a 	mov	r6,zero
 821e464:	e17ffd17 	ldw	r5,-12(fp)
 821e468:	e13ffc17 	ldw	r4,-16(fp)
 821e46c:	821e8c00 	call	821e8c0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 821e470:	0001883a 	nop
 821e474:	e037883a 	mov	sp,fp
 821e478:	dfc00117 	ldw	ra,4(sp)
 821e47c:	df000017 	ldw	fp,0(sp)
 821e480:	dec00204 	addi	sp,sp,8
 821e484:	f800283a 	ret

0821e488 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 821e488:	defff404 	addi	sp,sp,-48
 821e48c:	dfc00b15 	stw	ra,44(sp)
 821e490:	df000a15 	stw	fp,40(sp)
 821e494:	df000a04 	addi	fp,sp,40
 821e498:	e13ffb15 	stw	r4,-20(fp)
 821e49c:	e17ffc15 	stw	r5,-16(fp)
 821e4a0:	e1bffd15 	stw	r6,-12(fp)
 821e4a4:	3807883a 	mov	r3,r7
 821e4a8:	e0800517 	ldw	r2,20(fp)
 821e4ac:	e0fffe0d 	sth	r3,-8(fp)
 821e4b0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 821e4b4:	e0fffe0b 	ldhu	r3,-8(fp)
 821e4b8:	e0bfff03 	ldbu	r2,-4(fp)
 821e4bc:	d8800415 	stw	r2,16(sp)
 821e4c0:	d8000315 	stw	zero,12(sp)
 821e4c4:	e0800417 	ldw	r2,16(fp)
 821e4c8:	d8800215 	stw	r2,8(sp)
 821e4cc:	e0800317 	ldw	r2,12(fp)
 821e4d0:	d8800115 	stw	r2,4(sp)
 821e4d4:	e0800217 	ldw	r2,8(fp)
 821e4d8:	d8800015 	stw	r2,0(sp)
 821e4dc:	180f883a 	mov	r7,r3
 821e4e0:	e1bffd17 	ldw	r6,-12(fp)
 821e4e4:	e17ffc17 	ldw	r5,-16(fp)
 821e4e8:	e13ffb17 	ldw	r4,-20(fp)
 821e4ec:	821e5080 	call	821e508 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 821e4f0:	0001883a 	nop
 821e4f4:	e037883a 	mov	sp,fp
 821e4f8:	dfc00117 	ldw	ra,4(sp)
 821e4fc:	df000017 	ldw	fp,0(sp)
 821e500:	dec00204 	addi	sp,sp,8
 821e504:	f800283a 	ret

0821e508 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 821e508:	defff204 	addi	sp,sp,-56
 821e50c:	dfc00d15 	stw	ra,52(sp)
 821e510:	df000c15 	stw	fp,48(sp)
 821e514:	df000c04 	addi	fp,sp,48
 821e518:	e13ffb15 	stw	r4,-20(fp)
 821e51c:	e17ffc15 	stw	r5,-16(fp)
 821e520:	e1bffd15 	stw	r6,-12(fp)
 821e524:	3807883a 	mov	r3,r7
 821e528:	e0800617 	ldw	r2,24(fp)
 821e52c:	e0fffe0d 	sth	r3,-8(fp)
 821e530:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e534:	e0bffe0b 	ldhu	r2,-8(fp)
 821e538:	e0ffff03 	ldbu	r3,-4(fp)
 821e53c:	d8c00615 	stw	r3,24(sp)
 821e540:	d8000515 	stw	zero,20(sp)
 821e544:	e0c00517 	ldw	r3,20(fp)
 821e548:	d8c00415 	stw	r3,16(sp)
 821e54c:	e0c00317 	ldw	r3,12(fp)
 821e550:	d8c00315 	stw	r3,12(sp)
 821e554:	e0c00217 	ldw	r3,8(fp)
 821e558:	d8c00215 	stw	r3,8(sp)
 821e55c:	e0c00417 	ldw	r3,16(fp)
 821e560:	d8c00115 	stw	r3,4(sp)
 821e564:	d8800015 	stw	r2,0(sp)
 821e568:	000f883a 	mov	r7,zero
 821e56c:	e1bffd17 	ldw	r6,-12(fp)
 821e570:	e17ffc17 	ldw	r5,-16(fp)
 821e574:	e13ffb17 	ldw	r4,-20(fp)
 821e578:	821e8c00 	call	821e8c0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 821e57c:	0001883a 	nop
 821e580:	e037883a 	mov	sp,fp
 821e584:	dfc00117 	ldw	ra,4(sp)
 821e588:	df000017 	ldw	fp,0(sp)
 821e58c:	dec00204 	addi	sp,sp,8
 821e590:	f800283a 	ret

0821e594 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 821e594:	defffb04 	addi	sp,sp,-20
 821e598:	df000415 	stw	fp,16(sp)
 821e59c:	df000404 	addi	fp,sp,16
 821e5a0:	e13ffc15 	stw	r4,-16(fp)
 821e5a4:	e17ffd15 	stw	r5,-12(fp)
 821e5a8:	e1bffe15 	stw	r6,-8(fp)
 821e5ac:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 821e5b0:	e0bffc17 	ldw	r2,-16(fp)
 821e5b4:	e0fffd17 	ldw	r3,-12(fp)
 821e5b8:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 821e5bc:	e0bffc17 	ldw	r2,-16(fp)
 821e5c0:	e0ffff17 	ldw	r3,-4(fp)
 821e5c4:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 821e5c8:	e0bffc17 	ldw	r2,-16(fp)
 821e5cc:	e0fffe17 	ldw	r3,-8(fp)
 821e5d0:	10c00b15 	stw	r3,44(r2)
}
 821e5d4:	0001883a 	nop
 821e5d8:	e037883a 	mov	sp,fp
 821e5dc:	df000017 	ldw	fp,0(sp)
 821e5e0:	dec00104 	addi	sp,sp,4
 821e5e4:	f800283a 	ret

0821e5e8 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 821e5e8:	defffd04 	addi	sp,sp,-12
 821e5ec:	df000215 	stw	fp,8(sp)
 821e5f0:	df000204 	addi	fp,sp,8
 821e5f4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e5f8:	e0bfff17 	ldw	r2,-4(fp)
 821e5fc:	10800317 	ldw	r2,12(r2)
 821e600:	10800404 	addi	r2,r2,16
 821e604:	10800037 	ldwio	r2,0(r2)
 821e608:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e60c:	e0bffe17 	ldw	r2,-8(fp)
 821e610:	10800814 	ori	r2,r2,32
 821e614:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e618:	e0bfff17 	ldw	r2,-4(fp)
 821e61c:	10800317 	ldw	r2,12(r2)
 821e620:	10800404 	addi	r2,r2,16
 821e624:	e0fffe17 	ldw	r3,-8(fp)
 821e628:	10c00035 	stwio	r3,0(r2)
}
 821e62c:	0001883a 	nop
 821e630:	e037883a 	mov	sp,fp
 821e634:	df000017 	ldw	fp,0(sp)
 821e638:	dec00104 	addi	sp,sp,4
 821e63c:	f800283a 	ret

0821e640 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 821e640:	defffd04 	addi	sp,sp,-12
 821e644:	df000215 	stw	fp,8(sp)
 821e648:	df000204 	addi	fp,sp,8
 821e64c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e650:	e0bfff17 	ldw	r2,-4(fp)
 821e654:	10800317 	ldw	r2,12(r2)
 821e658:	10800404 	addi	r2,r2,16
 821e65c:	10800037 	ldwio	r2,0(r2)
 821e660:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e664:	e0fffe17 	ldw	r3,-8(fp)
 821e668:	00bff7c4 	movi	r2,-33
 821e66c:	1884703a 	and	r2,r3,r2
 821e670:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e674:	e0bfff17 	ldw	r2,-4(fp)
 821e678:	10800317 	ldw	r2,12(r2)
 821e67c:	10800404 	addi	r2,r2,16
 821e680:	e0fffe17 	ldw	r3,-8(fp)
 821e684:	10c00035 	stwio	r3,0(r2)
}
 821e688:	0001883a 	nop
 821e68c:	e037883a 	mov	sp,fp
 821e690:	df000017 	ldw	fp,0(sp)
 821e694:	dec00104 	addi	sp,sp,4
 821e698:	f800283a 	ret

0821e69c <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 821e69c:	defffe04 	addi	sp,sp,-8
 821e6a0:	df000115 	stw	fp,4(sp)
 821e6a4:	df000104 	addi	fp,sp,4
 821e6a8:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 821e6ac:	e0bfff17 	ldw	r2,-4(fp)
 821e6b0:	10800784 	addi	r2,r2,30
 821e6b4:	10800023 	ldbuio	r2,0(r2)
 821e6b8:	10803fcc 	andi	r2,r2,255
 821e6bc:	10801fcc 	andi	r2,r2,127
 821e6c0:	10000226 	beq	r2,zero,821e6cc <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 821e6c4:	00bffec4 	movi	r2,-5
 821e6c8:	00000906 	br	821e6f0 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 821e6cc:	e0bfff17 	ldw	r2,-4(fp)
 821e6d0:	108007c4 	addi	r2,r2,31
 821e6d4:	10800023 	ldbuio	r2,0(r2)
 821e6d8:	10803fcc 	andi	r2,r2,255
 821e6dc:	1080200c 	andi	r2,r2,128
 821e6e0:	10000226 	beq	r2,zero,821e6ec <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 821e6e4:	00bfe244 	movi	r2,-119
 821e6e8:	00000106 	br	821e6f0 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 821e6ec:	0005883a 	mov	r2,zero
}
 821e6f0:	e037883a 	mov	sp,fp
 821e6f4:	df000017 	ldw	fp,0(sp)
 821e6f8:	dec00104 	addi	sp,sp,4
 821e6fc:	f800283a 	ret

0821e700 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 821e700:	defffc04 	addi	sp,sp,-16
 821e704:	dfc00315 	stw	ra,12(sp)
 821e708:	df000215 	stw	fp,8(sp)
 821e70c:	df000204 	addi	fp,sp,8
 821e710:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 821e714:	d1602b04 	addi	r5,gp,-32596
 821e718:	e13fff17 	ldw	r4,-4(fp)
 821e71c:	823bc9c0 	call	823bc9c <alt_find_dev>
 821e720:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 821e724:	e0bffe17 	ldw	r2,-8(fp)
 821e728:	1000041e 	bne	r2,zero,821e73c <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 821e72c:	821e0480 	call	821e048 <alt_get_errno>
 821e730:	1007883a 	mov	r3,r2
 821e734:	008004c4 	movi	r2,19
 821e738:	18800015 	stw	r2,0(r3)
  }

  return dev;
 821e73c:	e0bffe17 	ldw	r2,-8(fp)
}
 821e740:	e037883a 	mov	sp,fp
 821e744:	dfc00117 	ldw	ra,4(sp)
 821e748:	df000017 	ldw	fp,0(sp)
 821e74c:	dec00204 	addi	sp,sp,8
 821e750:	f800283a 	ret

0821e754 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 821e754:	defff104 	addi	sp,sp,-60
 821e758:	dfc00e15 	stw	ra,56(sp)
 821e75c:	df000d15 	stw	fp,52(sp)
 821e760:	df000d04 	addi	fp,sp,52
 821e764:	e13ffa15 	stw	r4,-24(fp)
 821e768:	e17ffb15 	stw	r5,-20(fp)
 821e76c:	e1bffc15 	stw	r6,-16(fp)
 821e770:	e1fffd15 	stw	r7,-12(fp)
 821e774:	e0c00217 	ldw	r3,8(fp)
 821e778:	e0800617 	ldw	r2,24(fp)
 821e77c:	e0fffe0d 	sth	r3,-8(fp)
 821e780:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 821e784:	e0bffe0b 	ldhu	r2,-8(fp)
 821e788:	e0ffff03 	ldbu	r3,-4(fp)
 821e78c:	d8c00615 	stw	r3,24(sp)
 821e790:	d8000515 	stw	zero,20(sp)
 821e794:	d8000415 	stw	zero,16(sp)
 821e798:	e0c00517 	ldw	r3,20(fp)
 821e79c:	d8c00315 	stw	r3,12(sp)
 821e7a0:	e0c00417 	ldw	r3,16(fp)
 821e7a4:	d8c00215 	stw	r3,8(sp)
 821e7a8:	e0c00317 	ldw	r3,12(fp)
 821e7ac:	d8c00115 	stw	r3,4(sp)
 821e7b0:	d8800015 	stw	r2,0(sp)
 821e7b4:	e1fffd17 	ldw	r7,-12(fp)
 821e7b8:	e1bffc17 	ldw	r6,-16(fp)
 821e7bc:	e17ffb17 	ldw	r5,-20(fp)
 821e7c0:	e13ffa17 	ldw	r4,-24(fp)
 821e7c4:	821e8c00 	call	821e8c0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 821e7c8:	0001883a 	nop
 821e7cc:	e037883a 	mov	sp,fp
 821e7d0:	dfc00117 	ldw	ra,4(sp)
 821e7d4:	df000017 	ldw	fp,0(sp)
 821e7d8:	dec00204 	addi	sp,sp,8
 821e7dc:	f800283a 	ret

0821e7e0 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 821e7e0:	defffc04 	addi	sp,sp,-16
 821e7e4:	df000315 	stw	fp,12(sp)
 821e7e8:	df000304 	addi	fp,sp,12
 821e7ec:	e13ffe15 	stw	r4,-8(fp)
 821e7f0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e7f4:	e0bffe17 	ldw	r2,-8(fp)
 821e7f8:	10800317 	ldw	r2,12(r2)
 821e7fc:	10800404 	addi	r2,r2,16
 821e800:	10800037 	ldwio	r2,0(r2)
 821e804:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 821e808:	e0fffd17 	ldw	r3,-12(fp)
 821e80c:	00a00434 	movhi	r2,32784
 821e810:	10bfffc4 	addi	r2,r2,-1
 821e814:	1884703a 	and	r2,r3,r2
 821e818:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 821e81c:	e0bfff17 	ldw	r2,-4(fp)
 821e820:	1004953a 	slli	r2,r2,20
 821e824:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 821e828:	e0bffd17 	ldw	r2,-12(fp)
 821e82c:	1884b03a 	or	r2,r3,r2
 821e830:	10800134 	orhi	r2,r2,4
 821e834:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e838:	e0bffe17 	ldw	r2,-8(fp)
 821e83c:	10800317 	ldw	r2,12(r2)
 821e840:	10800404 	addi	r2,r2,16
 821e844:	e0fffd17 	ldw	r3,-12(fp)
 821e848:	10c00035 	stwio	r3,0(r2)
  
  return;
 821e84c:	0001883a 	nop
}
 821e850:	e037883a 	mov	sp,fp
 821e854:	df000017 	ldw	fp,0(sp)
 821e858:	dec00104 	addi	sp,sp,4
 821e85c:	f800283a 	ret

0821e860 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 821e860:	defffd04 	addi	sp,sp,-12
 821e864:	df000215 	stw	fp,8(sp)
 821e868:	df000204 	addi	fp,sp,8
 821e86c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e870:	e0bfff17 	ldw	r2,-4(fp)
 821e874:	10800317 	ldw	r2,12(r2)
 821e878:	10800404 	addi	r2,r2,16
 821e87c:	10800037 	ldwio	r2,0(r2)
 821e880:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 821e884:	e0fffe17 	ldw	r3,-8(fp)
 821e888:	00bfff34 	movhi	r2,65532
 821e88c:	10bfffc4 	addi	r2,r2,-1
 821e890:	1884703a 	and	r2,r3,r2
 821e894:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e898:	e0bfff17 	ldw	r2,-4(fp)
 821e89c:	10800317 	ldw	r2,12(r2)
 821e8a0:	10800404 	addi	r2,r2,16
 821e8a4:	e0fffe17 	ldw	r3,-8(fp)
 821e8a8:	10c00035 	stwio	r3,0(r2)
  
  return;
 821e8ac:	0001883a 	nop
}
 821e8b0:	e037883a 	mov	sp,fp
 821e8b4:	df000017 	ldw	fp,0(sp)
 821e8b8:	dec00104 	addi	sp,sp,4
 821e8bc:	f800283a 	ret

0821e8c0 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 821e8c0:	defff804 	addi	sp,sp,-32
 821e8c4:	dfc00715 	stw	ra,28(sp)
 821e8c8:	df000615 	stw	fp,24(sp)
 821e8cc:	df000604 	addi	fp,sp,24
 821e8d0:	e13ffa15 	stw	r4,-24(fp)
 821e8d4:	e17ffb15 	stw	r5,-20(fp)
 821e8d8:	e1bffc15 	stw	r6,-16(fp)
 821e8dc:	e1fffd15 	stw	r7,-12(fp)
 821e8e0:	e0c00217 	ldw	r3,8(fp)
 821e8e4:	e0800817 	ldw	r2,32(fp)
 821e8e8:	e0fffe0d 	sth	r3,-8(fp)
 821e8ec:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 821e8f0:	e0bffb17 	ldw	r2,-20(fp)
 821e8f4:	108007c4 	addi	r2,r2,31
 821e8f8:	e0fffb17 	ldw	r3,-20(fp)
 821e8fc:	18c007c3 	ldbu	r3,31(r3)
 821e900:	19003fcc 	andi	r4,r3,255
 821e904:	00ffdfc4 	movi	r3,-129
 821e908:	20c6703a 	and	r3,r4,r3
 821e90c:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 821e910:	e0bffa17 	ldw	r2,-24(fp)
 821e914:	e0fffc17 	ldw	r3,-16(fp)
 821e918:	19403fcc 	andi	r5,r3,255
 821e91c:	10c00003 	ldbu	r3,0(r2)
 821e920:	1806703a 	and	r3,r3,zero
 821e924:	1809883a 	mov	r4,r3
 821e928:	2807883a 	mov	r3,r5
 821e92c:	20c6b03a 	or	r3,r4,r3
 821e930:	10c00005 	stb	r3,0(r2)
 821e934:	e0fffc17 	ldw	r3,-16(fp)
 821e938:	1806d23a 	srli	r3,r3,8
 821e93c:	19403fcc 	andi	r5,r3,255
 821e940:	10c00043 	ldbu	r3,1(r2)
 821e944:	1806703a 	and	r3,r3,zero
 821e948:	1809883a 	mov	r4,r3
 821e94c:	2807883a 	mov	r3,r5
 821e950:	20c6b03a 	or	r3,r4,r3
 821e954:	10c00045 	stb	r3,1(r2)
 821e958:	e0fffc17 	ldw	r3,-16(fp)
 821e95c:	1806d43a 	srli	r3,r3,16
 821e960:	19403fcc 	andi	r5,r3,255
 821e964:	10c00083 	ldbu	r3,2(r2)
 821e968:	1806703a 	and	r3,r3,zero
 821e96c:	1809883a 	mov	r4,r3
 821e970:	2807883a 	mov	r3,r5
 821e974:	20c6b03a 	or	r3,r4,r3
 821e978:	10c00085 	stb	r3,2(r2)
 821e97c:	e0fffc17 	ldw	r3,-16(fp)
 821e980:	180ad63a 	srli	r5,r3,24
 821e984:	10c000c3 	ldbu	r3,3(r2)
 821e988:	1806703a 	and	r3,r3,zero
 821e98c:	1809883a 	mov	r4,r3
 821e990:	2807883a 	mov	r3,r5
 821e994:	20c6b03a 	or	r3,r4,r3
 821e998:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 821e99c:	e0bffa17 	ldw	r2,-24(fp)
 821e9a0:	e0fffd17 	ldw	r3,-12(fp)
 821e9a4:	19403fcc 	andi	r5,r3,255
 821e9a8:	10c00203 	ldbu	r3,8(r2)
 821e9ac:	1806703a 	and	r3,r3,zero
 821e9b0:	1809883a 	mov	r4,r3
 821e9b4:	2807883a 	mov	r3,r5
 821e9b8:	20c6b03a 	or	r3,r4,r3
 821e9bc:	10c00205 	stb	r3,8(r2)
 821e9c0:	e0fffd17 	ldw	r3,-12(fp)
 821e9c4:	1806d23a 	srli	r3,r3,8
 821e9c8:	19403fcc 	andi	r5,r3,255
 821e9cc:	10c00243 	ldbu	r3,9(r2)
 821e9d0:	1806703a 	and	r3,r3,zero
 821e9d4:	1809883a 	mov	r4,r3
 821e9d8:	2807883a 	mov	r3,r5
 821e9dc:	20c6b03a 	or	r3,r4,r3
 821e9e0:	10c00245 	stb	r3,9(r2)
 821e9e4:	e0fffd17 	ldw	r3,-12(fp)
 821e9e8:	1806d43a 	srli	r3,r3,16
 821e9ec:	19403fcc 	andi	r5,r3,255
 821e9f0:	10c00283 	ldbu	r3,10(r2)
 821e9f4:	1806703a 	and	r3,r3,zero
 821e9f8:	1809883a 	mov	r4,r3
 821e9fc:	2807883a 	mov	r3,r5
 821ea00:	20c6b03a 	or	r3,r4,r3
 821ea04:	10c00285 	stb	r3,10(r2)
 821ea08:	e0fffd17 	ldw	r3,-12(fp)
 821ea0c:	180ad63a 	srli	r5,r3,24
 821ea10:	10c002c3 	ldbu	r3,11(r2)
 821ea14:	1806703a 	and	r3,r3,zero
 821ea18:	1809883a 	mov	r4,r3
 821ea1c:	2807883a 	mov	r3,r5
 821ea20:	20c6b03a 	or	r3,r4,r3
 821ea24:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 821ea28:	e0bffa17 	ldw	r2,-24(fp)
 821ea2c:	e0fffb17 	ldw	r3,-20(fp)
 821ea30:	19403fcc 	andi	r5,r3,255
 821ea34:	10c00403 	ldbu	r3,16(r2)
 821ea38:	1806703a 	and	r3,r3,zero
 821ea3c:	1809883a 	mov	r4,r3
 821ea40:	2807883a 	mov	r3,r5
 821ea44:	20c6b03a 	or	r3,r4,r3
 821ea48:	10c00405 	stb	r3,16(r2)
 821ea4c:	e0fffb17 	ldw	r3,-20(fp)
 821ea50:	1806d23a 	srli	r3,r3,8
 821ea54:	19403fcc 	andi	r5,r3,255
 821ea58:	10c00443 	ldbu	r3,17(r2)
 821ea5c:	1806703a 	and	r3,r3,zero
 821ea60:	1809883a 	mov	r4,r3
 821ea64:	2807883a 	mov	r3,r5
 821ea68:	20c6b03a 	or	r3,r4,r3
 821ea6c:	10c00445 	stb	r3,17(r2)
 821ea70:	e0fffb17 	ldw	r3,-20(fp)
 821ea74:	1806d43a 	srli	r3,r3,16
 821ea78:	19403fcc 	andi	r5,r3,255
 821ea7c:	10c00483 	ldbu	r3,18(r2)
 821ea80:	1806703a 	and	r3,r3,zero
 821ea84:	1809883a 	mov	r4,r3
 821ea88:	2807883a 	mov	r3,r5
 821ea8c:	20c6b03a 	or	r3,r4,r3
 821ea90:	10c00485 	stb	r3,18(r2)
 821ea94:	e0fffb17 	ldw	r3,-20(fp)
 821ea98:	180ad63a 	srli	r5,r3,24
 821ea9c:	10c004c3 	ldbu	r3,19(r2)
 821eaa0:	1806703a 	and	r3,r3,zero
 821eaa4:	1809883a 	mov	r4,r3
 821eaa8:	2807883a 	mov	r3,r5
 821eaac:	20c6b03a 	or	r3,r4,r3
 821eab0:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 821eab4:	e0bffa17 	ldw	r2,-24(fp)
 821eab8:	10c00103 	ldbu	r3,4(r2)
 821eabc:	1806703a 	and	r3,r3,zero
 821eac0:	10c00105 	stb	r3,4(r2)
 821eac4:	10c00143 	ldbu	r3,5(r2)
 821eac8:	1806703a 	and	r3,r3,zero
 821eacc:	10c00145 	stb	r3,5(r2)
 821ead0:	10c00183 	ldbu	r3,6(r2)
 821ead4:	1806703a 	and	r3,r3,zero
 821ead8:	10c00185 	stb	r3,6(r2)
 821eadc:	10c001c3 	ldbu	r3,7(r2)
 821eae0:	1806703a 	and	r3,r3,zero
 821eae4:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 821eae8:	e0bffa17 	ldw	r2,-24(fp)
 821eaec:	10c00303 	ldbu	r3,12(r2)
 821eaf0:	1806703a 	and	r3,r3,zero
 821eaf4:	10c00305 	stb	r3,12(r2)
 821eaf8:	10c00343 	ldbu	r3,13(r2)
 821eafc:	1806703a 	and	r3,r3,zero
 821eb00:	10c00345 	stb	r3,13(r2)
 821eb04:	10c00383 	ldbu	r3,14(r2)
 821eb08:	1806703a 	and	r3,r3,zero
 821eb0c:	10c00385 	stb	r3,14(r2)
 821eb10:	10c003c3 	ldbu	r3,15(r2)
 821eb14:	1806703a 	and	r3,r3,zero
 821eb18:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 821eb1c:	e0bffa17 	ldw	r2,-24(fp)
 821eb20:	10c00503 	ldbu	r3,20(r2)
 821eb24:	1806703a 	and	r3,r3,zero
 821eb28:	10c00505 	stb	r3,20(r2)
 821eb2c:	10c00543 	ldbu	r3,21(r2)
 821eb30:	1806703a 	and	r3,r3,zero
 821eb34:	10c00545 	stb	r3,21(r2)
 821eb38:	10c00583 	ldbu	r3,22(r2)
 821eb3c:	1806703a 	and	r3,r3,zero
 821eb40:	10c00585 	stb	r3,22(r2)
 821eb44:	10c005c3 	ldbu	r3,23(r2)
 821eb48:	1806703a 	and	r3,r3,zero
 821eb4c:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 821eb50:	e0bffa17 	ldw	r2,-24(fp)
 821eb54:	e0fffe17 	ldw	r3,-8(fp)
 821eb58:	19403fcc 	andi	r5,r3,255
 821eb5c:	10c00603 	ldbu	r3,24(r2)
 821eb60:	1806703a 	and	r3,r3,zero
 821eb64:	1809883a 	mov	r4,r3
 821eb68:	2807883a 	mov	r3,r5
 821eb6c:	20c6b03a 	or	r3,r4,r3
 821eb70:	10c00605 	stb	r3,24(r2)
 821eb74:	e0fffe17 	ldw	r3,-8(fp)
 821eb78:	1806d23a 	srli	r3,r3,8
 821eb7c:	19403fcc 	andi	r5,r3,255
 821eb80:	10c00643 	ldbu	r3,25(r2)
 821eb84:	1806703a 	and	r3,r3,zero
 821eb88:	1809883a 	mov	r4,r3
 821eb8c:	2807883a 	mov	r3,r5
 821eb90:	20c6b03a 	or	r3,r4,r3
 821eb94:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 821eb98:	e0bffa17 	ldw	r2,-24(fp)
 821eb9c:	10c00703 	ldbu	r3,28(r2)
 821eba0:	1806703a 	and	r3,r3,zero
 821eba4:	10c00705 	stb	r3,28(r2)
 821eba8:	10c00743 	ldbu	r3,29(r2)
 821ebac:	1806703a 	and	r3,r3,zero
 821ebb0:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 821ebb4:	e0bffa17 	ldw	r2,-24(fp)
 821ebb8:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 821ebbc:	e0800617 	ldw	r2,24(fp)
 821ebc0:	1007883a 	mov	r3,r2
 821ebc4:	e0bffa17 	ldw	r2,-24(fp)
 821ebc8:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 821ebcc:	e0800717 	ldw	r2,28(fp)
 821ebd0:	1007883a 	mov	r3,r2
 821ebd4:	e0bffa17 	ldw	r2,-24(fp)
 821ebd8:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821ebdc:	e0800317 	ldw	r2,12(fp)
 821ebe0:	10000226 	beq	r2,zero,821ebec <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 821ebe4:	00bfe044 	movi	r2,-127
 821ebe8:	00000106 	br	821ebf0 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 821ebec:	00bfe004 	movi	r2,-128
 821ebf0:	e0c00417 	ldw	r3,16(fp)
 821ebf4:	18000226 	beq	r3,zero,821ec00 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 821ebf8:	00c00084 	movi	r3,2
 821ebfc:	00000106 	br	821ec04 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 821ec00:	0007883a 	mov	r3,zero
 821ec04:	10c4b03a 	or	r2,r2,r3
 821ec08:	1007883a 	mov	r3,r2
 821ec0c:	e0800517 	ldw	r2,20(fp)
 821ec10:	10000226 	beq	r2,zero,821ec1c <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 821ec14:	00800104 	movi	r2,4
 821ec18:	00000106 	br	821ec20 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 821ec1c:	0005883a 	mov	r2,zero
 821ec20:	1884b03a 	or	r2,r3,r2
 821ec24:	1007883a 	mov	r3,r2
 821ec28:	e0bfff03 	ldbu	r2,-4(fp)
 821ec2c:	10000426 	beq	r2,zero,821ec40 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 821ec30:	e0bfff03 	ldbu	r2,-4(fp)
 821ec34:	108003cc 	andi	r2,r2,15
 821ec38:	100490fa 	slli	r2,r2,3
 821ec3c:	00000106 	br	821ec44 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821ec40:	0005883a 	mov	r2,zero
 821ec44:	1884b03a 	or	r2,r3,r2
 821ec48:	1007883a 	mov	r3,r2
 821ec4c:	e0bffa17 	ldw	r2,-24(fp)
 821ec50:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 821ec54:	01400804 	movi	r5,32
 821ec58:	e13ffa17 	ldw	r4,-24(fp)
 821ec5c:	823ba580 	call	823ba58 <alt_dcache_flush>
}
 821ec60:	0001883a 	nop
 821ec64:	e037883a 	mov	sp,fp
 821ec68:	dfc00117 	ldw	ra,4(sp)
 821ec6c:	df000017 	ldw	fp,0(sp)
 821ec70:	dec00204 	addi	sp,sp,8
 821ec74:	f800283a 	ret

0821ec78 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 821ec78:	defff904 	addi	sp,sp,-28
 821ec7c:	dfc00615 	stw	ra,24(sp)
 821ec80:	df000515 	stw	fp,20(sp)
 821ec84:	df000504 	addi	fp,sp,20
 821ec88:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 821ec8c:	e0bfff17 	ldw	r2,-4(fp)
 821ec90:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821ec94:	e0bffb17 	ldw	r2,-20(fp)
 821ec98:	10800317 	ldw	r2,12(r2)
 821ec9c:	10800404 	addi	r2,r2,16
 821eca0:	e0fffb17 	ldw	r3,-20(fp)
 821eca4:	18c00317 	ldw	r3,12(r3)
 821eca8:	18c00404 	addi	r3,r3,16
 821ecac:	18c00037 	ldwio	r3,0(r3)
 821ecb0:	18e00034 	orhi	r3,r3,32768
 821ecb4:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821ecb8:	e0bffb17 	ldw	r2,-20(fp)
 821ecbc:	10800317 	ldw	r2,12(r2)
 821ecc0:	10800404 	addi	r2,r2,16
 821ecc4:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 821ecc8:	e0bffb17 	ldw	r2,-20(fp)
 821eccc:	10800917 	ldw	r2,36(r2)
 821ecd0:	10001226 	beq	r2,zero,821ed1c <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ecd4:	0005303a 	rdctl	r2,status
 821ecd8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ecdc:	e0fffd17 	ldw	r3,-12(fp)
 821ece0:	00bfff84 	movi	r2,-2
 821ece4:	1884703a 	and	r2,r3,r2
 821ece8:	1001703a 	wrctl	status,r2
  
  return context;
 821ecec:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 821ecf0:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 821ecf4:	e0bffb17 	ldw	r2,-20(fp)
 821ecf8:	10800917 	ldw	r2,36(r2)
 821ecfc:	e0fffb17 	ldw	r3,-20(fp)
 821ed00:	18c00a17 	ldw	r3,40(r3)
 821ed04:	1809883a 	mov	r4,r3
 821ed08:	103ee83a 	callr	r2
 821ed0c:	e0bffc17 	ldw	r2,-16(fp)
 821ed10:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ed14:	e0bffe17 	ldw	r2,-8(fp)
 821ed18:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 821ed1c:	0001883a 	nop
 821ed20:	e037883a 	mov	sp,fp
 821ed24:	dfc00117 	ldw	ra,4(sp)
 821ed28:	df000017 	ldw	fp,0(sp)
 821ed2c:	dec00204 	addi	sp,sp,8
 821ed30:	f800283a 	ret

0821ed34 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 821ed34:	defffa04 	addi	sp,sp,-24
 821ed38:	dfc00515 	stw	ra,20(sp)
 821ed3c:	df000415 	stw	fp,16(sp)
 821ed40:	df000404 	addi	fp,sp,16
 821ed44:	e13ffd15 	stw	r4,-12(fp)
 821ed48:	e17ffe15 	stw	r5,-8(fp)
 821ed4c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821ed50:	e0bffd17 	ldw	r2,-12(fp)
 821ed54:	10800317 	ldw	r2,12(r2)
 821ed58:	10800404 	addi	r2,r2,16
 821ed5c:	00c00074 	movhi	r3,1
 821ed60:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821ed64:	e0bffd17 	ldw	r2,-12(fp)
 821ed68:	10800317 	ldw	r2,12(r2)
 821ed6c:	10800404 	addi	r2,r2,16
 821ed70:	00c00074 	movhi	r3,1
 821ed74:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 821ed78:	e0bffd17 	ldw	r2,-12(fp)
 821ed7c:	10800317 	ldw	r2,12(r2)
 821ed80:	10800404 	addi	r2,r2,16
 821ed84:	0007883a 	mov	r3,zero
 821ed88:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821ed8c:	e0bffd17 	ldw	r2,-12(fp)
 821ed90:	10800317 	ldw	r2,12(r2)
 821ed94:	00c03fc4 	movi	r3,255
 821ed98:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 821ed9c:	d1602b04 	addi	r5,gp,-32596
 821eda0:	e13ffd17 	ldw	r4,-12(fp)
 821eda4:	823bb380 	call	823bb38 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 821eda8:	d8000015 	stw	zero,0(sp)
 821edac:	e1fffd17 	ldw	r7,-12(fp)
 821edb0:	018208b4 	movhi	r6,2082
 821edb4:	31bb1e04 	addi	r6,r6,-5000
 821edb8:	e17fff17 	ldw	r5,-4(fp)
 821edbc:	e13ffe17 	ldw	r4,-8(fp)
 821edc0:	823bd2c0 	call	823bd2c <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 821edc4:	0001883a 	nop
 821edc8:	e037883a 	mov	sp,fp
 821edcc:	dfc00117 	ldw	ra,4(sp)
 821edd0:	df000017 	ldw	fp,0(sp)
 821edd4:	dec00204 	addi	sp,sp,8
 821edd8:	f800283a 	ret

0821eddc <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 821eddc:	defffa04 	addi	sp,sp,-24
 821ede0:	dfc00515 	stw	ra,20(sp)
 821ede4:	df000415 	stw	fp,16(sp)
 821ede8:	df000404 	addi	fp,sp,16
 821edec:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 821edf0:	0007883a 	mov	r3,zero
 821edf4:	e0bfff17 	ldw	r2,-4(fp)
 821edf8:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 821edfc:	e0bfff17 	ldw	r2,-4(fp)
 821ee00:	10800104 	addi	r2,r2,4
 821ee04:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ee08:	0005303a 	rdctl	r2,status
 821ee0c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ee10:	e0fffd17 	ldw	r3,-12(fp)
 821ee14:	00bfff84 	movi	r2,-2
 821ee18:	1884703a 	and	r2,r3,r2
 821ee1c:	1001703a 	wrctl	status,r2
  
  return context;
 821ee20:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 821ee24:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 821ee28:	823c5cc0 	call	823c5cc <alt_tick>
 821ee2c:	e0bffc17 	ldw	r2,-16(fp)
 821ee30:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ee34:	e0bffe17 	ldw	r2,-8(fp)
 821ee38:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 821ee3c:	0001883a 	nop
 821ee40:	e037883a 	mov	sp,fp
 821ee44:	dfc00117 	ldw	ra,4(sp)
 821ee48:	df000017 	ldw	fp,0(sp)
 821ee4c:	dec00204 	addi	sp,sp,8
 821ee50:	f800283a 	ret

0821ee54 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 821ee54:	defff804 	addi	sp,sp,-32
 821ee58:	dfc00715 	stw	ra,28(sp)
 821ee5c:	df000615 	stw	fp,24(sp)
 821ee60:	df000604 	addi	fp,sp,24
 821ee64:	e13ffc15 	stw	r4,-16(fp)
 821ee68:	e17ffd15 	stw	r5,-12(fp)
 821ee6c:	e1bffe15 	stw	r6,-8(fp)
 821ee70:	e1ffff15 	stw	r7,-4(fp)
 821ee74:	e0bfff17 	ldw	r2,-4(fp)
 821ee78:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 821ee7c:	d0a0b817 	ldw	r2,-32032(gp)
 821ee80:	1000021e 	bne	r2,zero,821ee8c <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 821ee84:	e0bffb17 	ldw	r2,-20(fp)
 821ee88:	d0a0b815 	stw	r2,-32032(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 821ee8c:	e0bffc17 	ldw	r2,-16(fp)
 821ee90:	10800104 	addi	r2,r2,4
 821ee94:	00c001c4 	movi	r3,7
 821ee98:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 821ee9c:	d8000015 	stw	zero,0(sp)
 821eea0:	e1fffc17 	ldw	r7,-16(fp)
 821eea4:	018208b4 	movhi	r6,2082
 821eea8:	31bb7704 	addi	r6,r6,-4644
 821eeac:	e17ffe17 	ldw	r5,-8(fp)
 821eeb0:	e13ffd17 	ldw	r4,-12(fp)
 821eeb4:	823bd2c0 	call	823bd2c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 821eeb8:	0001883a 	nop
 821eebc:	e037883a 	mov	sp,fp
 821eec0:	dfc00117 	ldw	ra,4(sp)
 821eec4:	df000017 	ldw	fp,0(sp)
 821eec8:	dec00204 	addi	sp,sp,8
 821eecc:	f800283a 	ret

0821eed0 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 821eed0:	defffb04 	addi	sp,sp,-20
 821eed4:	df000115 	stw	fp,4(sp)
 821eed8:	df000104 	addi	fp,sp,4
 821eedc:	e13fff15 	stw	r4,-4(fp)
 821eee0:	e1400115 	stw	r5,4(fp)
 821eee4:	e1800215 	stw	r6,8(fp)
 821eee8:	e1c00315 	stw	r7,12(fp)
 821eeec:	0001883a 	nop
 821eef0:	e037883a 	mov	sp,fp
 821eef4:	df000017 	ldw	fp,0(sp)
 821eef8:	dec00404 	addi	sp,sp,16
 821eefc:	f800283a 	ret

0821ef00 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 821ef00:	defffb04 	addi	sp,sp,-20
 821ef04:	df000415 	stw	fp,16(sp)
 821ef08:	df000404 	addi	fp,sp,16
 821ef0c:	e13ffc15 	stw	r4,-16(fp)
 821ef10:	e17ffd15 	stw	r5,-12(fp)
 821ef14:	e1bffe15 	stw	r6,-8(fp)
 821ef18:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 821ef1c:	e0fffd17 	ldw	r3,-12(fp)
 821ef20:	e0bffc17 	ldw	r2,-16(fp)
 821ef24:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 821ef28:	e0fffe17 	ldw	r3,-8(fp)
 821ef2c:	e0bffc17 	ldw	r2,-16(fp)
 821ef30:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 821ef34:	e0ffff17 	ldw	r3,-4(fp)
 821ef38:	e0bffc17 	ldw	r2,-16(fp)
 821ef3c:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 821ef40:	e0c00117 	ldw	r3,4(fp)
 821ef44:	e0bffc17 	ldw	r2,-16(fp)
 821ef48:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 821ef4c:	0005883a 	mov	r2,zero
}
 821ef50:	e037883a 	mov	sp,fp
 821ef54:	df000017 	ldw	fp,0(sp)
 821ef58:	dec00104 	addi	sp,sp,4
 821ef5c:	f800283a 	ret

0821ef60 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 821ef60:	defffa04 	addi	sp,sp,-24
 821ef64:	dfc00515 	stw	ra,20(sp)
 821ef68:	df000415 	stw	fp,16(sp)
 821ef6c:	df000404 	addi	fp,sp,16
 821ef70:	e13ffe15 	stw	r4,-8(fp)
 821ef74:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 821ef78:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 821ef7c:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821ef80:	00000b06 	br	821efb0 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821ef84:	e0fffc17 	ldw	r3,-16(fp)
 821ef88:	18800044 	addi	r2,r3,1
 821ef8c:	e0bffc15 	stw	r2,-16(fp)
 821ef90:	008003f4 	movhi	r2,15
 821ef94:	10909004 	addi	r2,r2,16960
 821ef98:	1880051e 	bne	r3,r2,821efb0 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 821ef9c:	01020974 	movhi	r4,2085
 821efa0:	2136fb04 	addi	r4,r4,-9236
 821efa4:	82033700 	call	8203370 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 821efa8:	00bffa84 	movi	r2,-22
 821efac:	00002006 	br	821f030 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821efb0:	e0bffe17 	ldw	r2,-8(fp)
 821efb4:	10800117 	ldw	r2,4(r2)
 821efb8:	10800317 	ldw	r2,12(r2)
 821efbc:	10800037 	ldwio	r2,0(r2)
 821efc0:	1080040c 	andi	r2,r2,16
 821efc4:	103fef1e 	bne	r2,zero,821ef84 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 821efc8:	e0bffe17 	ldw	r2,-8(fp)
 821efcc:	10800117 	ldw	r2,4(r2)
 821efd0:	10800317 	ldw	r2,12(r2)
 821efd4:	10800404 	addi	r2,r2,16
 821efd8:	0007883a 	mov	r3,zero
 821efdc:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 821efe0:	e0bffe17 	ldw	r2,-8(fp)
 821efe4:	10800117 	ldw	r2,4(r2)
 821efe8:	10800317 	ldw	r2,12(r2)
 821efec:	00c03fc4 	movi	r3,255
 821eff0:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 821eff4:	e0bffe17 	ldw	r2,-8(fp)
 821eff8:	10800117 	ldw	r2,4(r2)
 821effc:	e17fff17 	ldw	r5,-4(fp)
 821f000:	1009883a 	mov	r4,r2
 821f004:	821e1a80 	call	821e1a8 <alt_avalon_sgdma_do_sync_transfer>
 821f008:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 821f00c:	e0bffd03 	ldbu	r2,-12(fp)
 821f010:	10000226 	beq	r2,zero,821f01c <tse_mac_sTxWrite+0xbc>
    return -1;
 821f014:	00bfffc4 	movi	r2,-1
 821f018:	00000506 	br	821f030 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 821f01c:	e0bfff17 	ldw	r2,-4(fp)
 821f020:	10800704 	addi	r2,r2,28
 821f024:	10800037 	ldwio	r2,0(r2)
 821f028:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 821f02c:	e0bffd8b 	ldhu	r2,-10(fp)
}
 821f030:	e037883a 	mov	sp,fp
 821f034:	dfc00117 	ldw	ra,4(sp)
 821f038:	df000017 	ldw	fp,0(sp)
 821f03c:	dec00204 	addi	sp,sp,8
 821f040:	f800283a 	ret

0821f044 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 821f044:	defffa04 	addi	sp,sp,-24
 821f048:	dfc00515 	stw	ra,20(sp)
 821f04c:	df000415 	stw	fp,16(sp)
 821f050:	df000404 	addi	fp,sp,16
 821f054:	e13ffe15 	stw	r4,-8(fp)
 821f058:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 821f05c:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 821f060:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f064:	00000b06 	br	821f094 <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f068:	e0fffc17 	ldw	r3,-16(fp)
 821f06c:	18800044 	addi	r2,r3,1
 821f070:	e0bffc15 	stw	r2,-16(fp)
 821f074:	008003f4 	movhi	r2,15
 821f078:	10909004 	addi	r2,r2,16960
 821f07c:	1880051e 	bne	r3,r2,821f094 <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 821f080:	01020974 	movhi	r4,2085
 821f084:	21370204 	addi	r4,r4,-9208
 821f088:	82033700 	call	8203370 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 821f08c:	00bffa84 	movi	r2,-22
 821f090:	00001106 	br	821f0d8 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f094:	e0bffe17 	ldw	r2,-8(fp)
 821f098:	10800217 	ldw	r2,8(r2)
 821f09c:	10800317 	ldw	r2,12(r2)
 821f0a0:	10800037 	ldwio	r2,0(r2)
 821f0a4:	1080040c 	andi	r2,r2,16
 821f0a8:	103fef1e 	bne	r2,zero,821f068 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 821f0ac:	e0bffe17 	ldw	r2,-8(fp)
 821f0b0:	10800217 	ldw	r2,8(r2)
 821f0b4:	e17fff17 	ldw	r5,-4(fp)
 821f0b8:	1009883a 	mov	r4,r2
 821f0bc:	821e0840 	call	821e084 <alt_avalon_sgdma_do_async_transfer>
 821f0c0:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 821f0c4:	e0bffd03 	ldbu	r2,-12(fp)
 821f0c8:	10000226 	beq	r2,zero,821f0d4 <tse_mac_aRxRead+0x90>
    return -1;
 821f0cc:	00bfffc4 	movi	r2,-1
 821f0d0:	00000106 	br	821f0d8 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 821f0d4:	0005883a 	mov	r2,zero
}
 821f0d8:	e037883a 	mov	sp,fp
 821f0dc:	dfc00117 	ldw	ra,4(sp)
 821f0e0:	df000017 	ldw	fp,0(sp)
 821f0e4:	dec00204 	addi	sp,sp,8
 821f0e8:	f800283a 	ret

0821f0ec <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 821f0ec:	defffc04 	addi	sp,sp,-16
 821f0f0:	df000315 	stw	fp,12(sp)
 821f0f4:	df000304 	addi	fp,sp,12
 821f0f8:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f0fc:	e0bfff17 	ldw	r2,-4(fp)
 821f100:	10800204 	addi	r2,r2,8
 821f104:	10800037 	ldwio	r2,0(r2)
 821f108:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 821f10c:	e0bfff17 	ldw	r2,-4(fp)
 821f110:	10800204 	addi	r2,r2,8
 821f114:	00c80204 	movi	r3,8200
 821f118:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 821f11c:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 821f120:	00000306 	br	821f130 <tse_mac_SwReset+0x44>
 821f124:	e0bffd17 	ldw	r2,-12(fp)
 821f128:	10800044 	addi	r2,r2,1
 821f12c:	e0bffd15 	stw	r2,-12(fp)
 821f130:	e0bfff17 	ldw	r2,-4(fp)
 821f134:	10800204 	addi	r2,r2,8
 821f138:	10800037 	ldwio	r2,0(r2)
 821f13c:	1088000c 	andi	r2,r2,8192
 821f140:	10000326 	beq	r2,zero,821f150 <tse_mac_SwReset+0x64>
 821f144:	e0bffd17 	ldw	r2,-12(fp)
 821f148:	1089c410 	cmplti	r2,r2,10000
 821f14c:	103ff51e 	bne	r2,zero,821f124 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 821f150:	e0bfff17 	ldw	r2,-4(fp)
 821f154:	10800204 	addi	r2,r2,8
 821f158:	e0fffe17 	ldw	r3,-8(fp)
 821f15c:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 821f160:	0005883a 	mov	r2,zero
}
 821f164:	e037883a 	mov	sp,fp
 821f168:	df000017 	ldw	fp,0(sp)
 821f16c:	dec00104 	addi	sp,sp,4
 821f170:	f800283a 	ret

0821f174 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 821f174:	defffd04 	addi	sp,sp,-12
 821f178:	df000215 	stw	fp,8(sp)
 821f17c:	df000204 	addi	fp,sp,8
 821f180:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f184:	e0bfff17 	ldw	r2,-4(fp)
 821f188:	10800204 	addi	r2,r2,8
 821f18c:	10800037 	ldwio	r2,0(r2)
 821f190:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 821f194:	e0fffe17 	ldw	r3,-8(fp)
 821f198:	00bffdc4 	movi	r2,-9
 821f19c:	1884703a 	and	r2,r3,r2
 821f1a0:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f1a4:	e0bfff17 	ldw	r2,-4(fp)
 821f1a8:	10800204 	addi	r2,r2,8
 821f1ac:	e0fffe17 	ldw	r3,-8(fp)
 821f1b0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f1b4:	0005883a 	mov	r2,zero
}
 821f1b8:	e037883a 	mov	sp,fp
 821f1bc:	df000017 	ldw	fp,0(sp)
 821f1c0:	dec00104 	addi	sp,sp,4
 821f1c4:	f800283a 	ret

0821f1c8 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 821f1c8:	defffd04 	addi	sp,sp,-12
 821f1cc:	df000215 	stw	fp,8(sp)
 821f1d0:	df000204 	addi	fp,sp,8
 821f1d4:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f1d8:	e0bfff17 	ldw	r2,-4(fp)
 821f1dc:	10800204 	addi	r2,r2,8
 821f1e0:	10800037 	ldwio	r2,0(r2)
 821f1e4:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 821f1e8:	e0bffe17 	ldw	r2,-8(fp)
 821f1ec:	10800214 	ori	r2,r2,8
 821f1f0:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f1f4:	e0bfff17 	ldw	r2,-4(fp)
 821f1f8:	10800204 	addi	r2,r2,8
 821f1fc:	e0fffe17 	ldw	r3,-8(fp)
 821f200:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f204:	0005883a 	mov	r2,zero
}
 821f208:	e037883a 	mov	sp,fp
 821f20c:	df000017 	ldw	fp,0(sp)
 821f210:	dec00104 	addi	sp,sp,4
 821f214:	f800283a 	ret

0821f218 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 821f218:	defffb04 	addi	sp,sp,-20
 821f21c:	dfc00415 	stw	ra,16(sp)
 821f220:	df000315 	stw	fp,12(sp)
 821f224:	dc000215 	stw	r16,8(sp)
 821f228:	df000304 	addi	fp,sp,12
 821f22c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f230:	e03ffd15 	stw	zero,-12(fp)
 821f234:	00002906 	br	821f2dc <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 821f238:	008209b4 	movhi	r2,2086
 821f23c:	10b61904 	addi	r2,r2,-10140
 821f240:	e0fffd17 	ldw	r3,-12(fp)
 821f244:	18c7883a 	add	r3,r3,r3
 821f248:	18c7883a 	add	r3,r3,r3
 821f24c:	10c5883a 	add	r2,r2,r3
 821f250:	10800017 	ldw	r2,0(r2)
 821f254:	10c01417 	ldw	r3,80(r2)
 821f258:	e0bffe17 	ldw	r2,-8(fp)
 821f25c:	10801417 	ldw	r2,80(r2)
 821f260:	18801b1e 	bne	r3,r2,821f2d0 <alt_tse_phy_add_profile+0xb8>
 821f264:	008209b4 	movhi	r2,2086
 821f268:	10b61904 	addi	r2,r2,-10140
 821f26c:	e0fffd17 	ldw	r3,-12(fp)
 821f270:	18c7883a 	add	r3,r3,r3
 821f274:	18c7883a 	add	r3,r3,r3
 821f278:	10c5883a 	add	r2,r2,r3
 821f27c:	10800017 	ldw	r2,0(r2)
 821f280:	10c01503 	ldbu	r3,84(r2)
 821f284:	e0bffe17 	ldw	r2,-8(fp)
 821f288:	10801503 	ldbu	r2,84(r2)
 821f28c:	18c03fcc 	andi	r3,r3,255
 821f290:	10803fcc 	andi	r2,r2,255
 821f294:	18800e1e 	bne	r3,r2,821f2d0 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 821f298:	e0bffe17 	ldw	r2,-8(fp)
 821f29c:	10801417 	ldw	r2,80(r2)
 821f2a0:	1007883a 	mov	r3,r2
 821f2a4:	e0bffe17 	ldw	r2,-8(fp)
 821f2a8:	10801503 	ldbu	r2,84(r2)
 821f2ac:	10803fcc 	andi	r2,r2,255
 821f2b0:	100d883a 	mov	r6,r2
 821f2b4:	180b883a 	mov	r5,r3
 821f2b8:	01020974 	movhi	r4,2085
 821f2bc:	21370904 	addi	r4,r4,-9180
 821f2c0:	82030ec0 	call	82030ec <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 821f2c4:	01020974 	movhi	r4,2085
 821f2c8:	21371d04 	addi	r4,r4,-9100
 821f2cc:	82033700 	call	8203370 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f2d0:	e0bffd17 	ldw	r2,-12(fp)
 821f2d4:	10800044 	addi	r2,r2,1
 821f2d8:	e0bffd15 	stw	r2,-12(fp)
 821f2dc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f2e0:	10803fcc 	andi	r2,r2,255
 821f2e4:	e0fffd17 	ldw	r3,-12(fp)
 821f2e8:	18bfd316 	blt	r3,r2,821f238 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 821f2ec:	d0a07f03 	ldbu	r2,-32260(gp)
 821f2f0:	14003fcc 	andi	r16,r2,255
 821f2f4:	01001904 	movi	r4,100
 821f2f8:	824b3dc0 	call	824b3dc <malloc>
 821f2fc:	1009883a 	mov	r4,r2
 821f300:	008209b4 	movhi	r2,2086
 821f304:	10b61904 	addi	r2,r2,-10140
 821f308:	8407883a 	add	r3,r16,r16
 821f30c:	18c7883a 	add	r3,r3,r3
 821f310:	10c5883a 	add	r2,r2,r3
 821f314:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 821f318:	d0a07f03 	ldbu	r2,-32260(gp)
 821f31c:	10c03fcc 	andi	r3,r2,255
 821f320:	008209b4 	movhi	r2,2086
 821f324:	10b61904 	addi	r2,r2,-10140
 821f328:	18c7883a 	add	r3,r3,r3
 821f32c:	18c7883a 	add	r3,r3,r3
 821f330:	10c5883a 	add	r2,r2,r3
 821f334:	10800017 	ldw	r2,0(r2)
 821f338:	1000081e 	bne	r2,zero,821f35c <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 821f33c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f340:	10803fcc 	andi	r2,r2,255
 821f344:	100b883a 	mov	r5,r2
 821f348:	01020974 	movhi	r4,2085
 821f34c:	21373504 	addi	r4,r4,-9004
 821f350:	82030ec0 	call	82030ec <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 821f354:	00bfffc4 	movi	r2,-1
 821f358:	00002206 	br	821f3e4 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 821f35c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f360:	10c03fcc 	andi	r3,r2,255
 821f364:	008209b4 	movhi	r2,2086
 821f368:	10b61904 	addi	r2,r2,-10140
 821f36c:	18c7883a 	add	r3,r3,r3
 821f370:	18c7883a 	add	r3,r3,r3
 821f374:	10c5883a 	add	r2,r2,r3
 821f378:	10c00017 	ldw	r3,0(r2)
 821f37c:	e0bffe17 	ldw	r2,-8(fp)
 821f380:	1009883a 	mov	r4,r2
 821f384:	00801904 	movi	r2,100
 821f388:	100d883a 	mov	r6,r2
 821f38c:	200b883a 	mov	r5,r4
 821f390:	1809883a 	mov	r4,r3
 821f394:	8202c5c0 	call	8202c5c <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 821f398:	d0a07f03 	ldbu	r2,-32260(gp)
 821f39c:	10c03fcc 	andi	r3,r2,255
 821f3a0:	008209b4 	movhi	r2,2086
 821f3a4:	10b61904 	addi	r2,r2,-10140
 821f3a8:	18c7883a 	add	r3,r3,r3
 821f3ac:	18c7883a 	add	r3,r3,r3
 821f3b0:	10c5883a 	add	r2,r2,r3
 821f3b4:	10800017 	ldw	r2,0(r2)
 821f3b8:	1007883a 	mov	r3,r2
 821f3bc:	e0bffe17 	ldw	r2,-8(fp)
 821f3c0:	100b883a 	mov	r5,r2
 821f3c4:	1809883a 	mov	r4,r3
 821f3c8:	824b4040 	call	824b404 <strcpy>
    
    phy_profile_count++;
 821f3cc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f3d0:	10800044 	addi	r2,r2,1
 821f3d4:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 821f3d8:	d0a07f03 	ldbu	r2,-32260(gp)
 821f3dc:	10803fcc 	andi	r2,r2,255
 821f3e0:	10bfffc4 	addi	r2,r2,-1
}
 821f3e4:	e6ffff04 	addi	sp,fp,-4
 821f3e8:	dfc00217 	ldw	ra,8(sp)
 821f3ec:	df000117 	ldw	fp,4(sp)
 821f3f0:	dc000017 	ldw	r16,0(sp)
 821f3f4:	dec00304 	addi	sp,sp,12
 821f3f8:	f800283a 	ret

0821f3fc <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 821f3fc:	defff204 	addi	sp,sp,-56
 821f400:	dfc00d15 	stw	ra,52(sp)
 821f404:	df000c15 	stw	fp,48(sp)
 821f408:	dc000b15 	stw	r16,44(sp)
 821f40c:	df000c04 	addi	fp,sp,48
 821f410:	e13ffb15 	stw	r4,-20(fp)
 821f414:	e17ffc15 	stw	r5,-16(fp)
 821f418:	e1bffd15 	stw	r6,-12(fp)
 821f41c:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 821f420:	e0bffb17 	ldw	r2,-20(fp)
 821f424:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 821f428:	e0bffc17 	ldw	r2,-16(fp)
 821f42c:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 821f430:	e0bffd17 	ldw	r2,-12(fp)
 821f434:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 821f438:	e0bffe17 	ldw	r2,-8(fp)
 821f43c:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 821f440:	e0800217 	ldw	r2,8(fp)
 821f444:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 821f448:	e0bffa17 	ldw	r2,-24(fp)
 821f44c:	10800303 	ldbu	r2,12(r2)
 821f450:	10803fcc 	andi	r2,r2,255
 821f454:	1000031e 	bne	r2,zero,821f464 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 821f458:	00800044 	movi	r2,1
 821f45c:	e0bff515 	stw	r2,-44(fp)
 821f460:	00000e06 	br	821f49c <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 821f464:	e0bffa17 	ldw	r2,-24(fp)
 821f468:	10800303 	ldbu	r2,12(r2)
 821f46c:	10803fcc 	andi	r2,r2,255
 821f470:	10000526 	beq	r2,zero,821f488 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 821f474:	e0bffa17 	ldw	r2,-24(fp)
 821f478:	10800303 	ldbu	r2,12(r2)
 821f47c:	10803fcc 	andi	r2,r2,255
 821f480:	e0bff515 	stw	r2,-44(fp)
 821f484:	00000506 	br	821f49c <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 821f488:	01020974 	movhi	r4,2085
 821f48c:	21374404 	addi	r4,r4,-8944
 821f490:	82033700 	call	8203370 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f494:	00bfffc4 	movi	r2,-1
 821f498:	00025106 	br	821fde0 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 821f49c:	e03ff415 	stw	zero,-48(fp)
 821f4a0:	00024b06 	br	821fdd0 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 821f4a4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f4a8:	10803fcc 	andi	r2,r2,255
 821f4ac:	1080201c 	xori	r2,r2,128
 821f4b0:	10bfe004 	addi	r2,r2,-128
 821f4b4:	10800110 	cmplti	r2,r2,4
 821f4b8:	10000c1e 	bne	r2,zero,821f4ec <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 821f4bc:	01020974 	movhi	r4,2085
 821f4c0:	21375004 	addi	r4,r4,-8896
 821f4c4:	82033700 	call	8203370 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 821f4c8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f4cc:	10803fcc 	andi	r2,r2,255
 821f4d0:	1080201c 	xori	r2,r2,128
 821f4d4:	10bfe004 	addi	r2,r2,-128
 821f4d8:	100d883a 	mov	r6,r2
 821f4dc:	01400104 	movi	r5,4
 821f4e0:	01020974 	movhi	r4,2085
 821f4e4:	21376004 	addi	r4,r4,-8832
 821f4e8:	82030ec0 	call	82030ec <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 821f4ec:	e0bffa17 	ldw	r2,-24(fp)
 821f4f0:	1000081e 	bne	r2,zero,821f514 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821f4f4:	01020974 	movhi	r4,2085
 821f4f8:	21376f04 	addi	r4,r4,-8772
 821f4fc:	82033700 	call	8203370 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 821f500:	01020974 	movhi	r4,2085
 821f504:	21377904 	addi	r4,r4,-8732
 821f508:	82033700 	call	8203370 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f50c:	00bfffc4 	movi	r2,-1
 821f510:	00023306 	br	821fde0 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 821f514:	d0a07f83 	ldbu	r2,-32258(gp)
 821f518:	11003fcc 	andi	r4,r2,255
 821f51c:	2100201c 	xori	r4,r4,128
 821f520:	213fe004 	addi	r4,r4,-128
 821f524:	e0bffa17 	ldw	r2,-24(fp)
 821f528:	10800017 	ldw	r2,0(r2)
 821f52c:	e0fff417 	ldw	r3,-48(fp)
 821f530:	180692ba 	slli	r3,r3,10
 821f534:	10c7883a 	add	r3,r2,r3
 821f538:	00820974 	movhi	r2,2085
 821f53c:	1086d704 	addi	r2,r2,7004
 821f540:	21001224 	muli	r4,r4,72
 821f544:	1105883a 	add	r2,r2,r4
 821f548:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 821f54c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f550:	11003fcc 	andi	r4,r2,255
 821f554:	2100201c 	xori	r4,r4,128
 821f558:	213fe004 	addi	r4,r4,-128
 821f55c:	e0bffa17 	ldw	r2,-24(fp)
 821f560:	10c0010b 	ldhu	r3,4(r2)
 821f564:	00820974 	movhi	r2,2085
 821f568:	1086d704 	addi	r2,r2,7004
 821f56c:	21001224 	muli	r4,r4,72
 821f570:	1105883a 	add	r2,r2,r4
 821f574:	10800104 	addi	r2,r2,4
 821f578:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 821f57c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f580:	11003fcc 	andi	r4,r2,255
 821f584:	2100201c 	xori	r4,r4,128
 821f588:	213fe004 	addi	r4,r4,-128
 821f58c:	e0bffa17 	ldw	r2,-24(fp)
 821f590:	10c0018b 	ldhu	r3,6(r2)
 821f594:	00820974 	movhi	r2,2085
 821f598:	1086d704 	addi	r2,r2,7004
 821f59c:	21001224 	muli	r4,r4,72
 821f5a0:	1105883a 	add	r2,r2,r4
 821f5a4:	10800184 	addi	r2,r2,6
 821f5a8:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 821f5ac:	d0a07f83 	ldbu	r2,-32258(gp)
 821f5b0:	11003fcc 	andi	r4,r2,255
 821f5b4:	2100201c 	xori	r4,r4,128
 821f5b8:	213fe004 	addi	r4,r4,-128
 821f5bc:	e0bffa17 	ldw	r2,-24(fp)
 821f5c0:	10c00203 	ldbu	r3,8(r2)
 821f5c4:	00820974 	movhi	r2,2085
 821f5c8:	1086d704 	addi	r2,r2,7004
 821f5cc:	21001224 	muli	r4,r4,72
 821f5d0:	1105883a 	add	r2,r2,r4
 821f5d4:	10800204 	addi	r2,r2,8
 821f5d8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 821f5dc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f5e0:	11003fcc 	andi	r4,r2,255
 821f5e4:	2100201c 	xori	r4,r4,128
 821f5e8:	213fe004 	addi	r4,r4,-128
 821f5ec:	e0bffa17 	ldw	r2,-24(fp)
 821f5f0:	10c00243 	ldbu	r3,9(r2)
 821f5f4:	00820974 	movhi	r2,2085
 821f5f8:	1086d704 	addi	r2,r2,7004
 821f5fc:	21001224 	muli	r4,r4,72
 821f600:	1105883a 	add	r2,r2,r4
 821f604:	10800244 	addi	r2,r2,9
 821f608:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 821f60c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f610:	11003fcc 	andi	r4,r2,255
 821f614:	2100201c 	xori	r4,r4,128
 821f618:	213fe004 	addi	r4,r4,-128
 821f61c:	e0bffa17 	ldw	r2,-24(fp)
 821f620:	10c00283 	ldbu	r3,10(r2)
 821f624:	00820974 	movhi	r2,2085
 821f628:	1086d704 	addi	r2,r2,7004
 821f62c:	21001224 	muli	r4,r4,72
 821f630:	1105883a 	add	r2,r2,r4
 821f634:	10800284 	addi	r2,r2,10
 821f638:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 821f63c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f640:	11003fcc 	andi	r4,r2,255
 821f644:	2100201c 	xori	r4,r4,128
 821f648:	213fe004 	addi	r4,r4,-128
 821f64c:	e0bffa17 	ldw	r2,-24(fp)
 821f650:	10c002c3 	ldbu	r3,11(r2)
 821f654:	00820974 	movhi	r2,2085
 821f658:	1086d704 	addi	r2,r2,7004
 821f65c:	21001224 	muli	r4,r4,72
 821f660:	1105883a 	add	r2,r2,r4
 821f664:	108002c4 	addi	r2,r2,11
 821f668:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 821f66c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f670:	11003fcc 	andi	r4,r2,255
 821f674:	2100201c 	xori	r4,r4,128
 821f678:	213fe004 	addi	r4,r4,-128
 821f67c:	e0bffa17 	ldw	r2,-24(fp)
 821f680:	10c00303 	ldbu	r3,12(r2)
 821f684:	00820974 	movhi	r2,2085
 821f688:	1086d704 	addi	r2,r2,7004
 821f68c:	21001224 	muli	r4,r4,72
 821f690:	1105883a 	add	r2,r2,r4
 821f694:	10800304 	addi	r2,r2,12
 821f698:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 821f69c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f6a0:	11003fcc 	andi	r4,r2,255
 821f6a4:	2100201c 	xori	r4,r4,128
 821f6a8:	213fe004 	addi	r4,r4,-128
 821f6ac:	e0bffa17 	ldw	r2,-24(fp)
 821f6b0:	10c00343 	ldbu	r3,13(r2)
 821f6b4:	00820974 	movhi	r2,2085
 821f6b8:	1086d704 	addi	r2,r2,7004
 821f6bc:	21001224 	muli	r4,r4,72
 821f6c0:	1105883a 	add	r2,r2,r4
 821f6c4:	10800344 	addi	r2,r2,13
 821f6c8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 821f6cc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f6d0:	11003fcc 	andi	r4,r2,255
 821f6d4:	2100201c 	xori	r4,r4,128
 821f6d8:	213fe004 	addi	r4,r4,-128
 821f6dc:	e0bffa17 	ldw	r2,-24(fp)
 821f6e0:	10c00383 	ldbu	r3,14(r2)
 821f6e4:	00820974 	movhi	r2,2085
 821f6e8:	1086d704 	addi	r2,r2,7004
 821f6ec:	21001224 	muli	r4,r4,72
 821f6f0:	1105883a 	add	r2,r2,r4
 821f6f4:	10800384 	addi	r2,r2,14
 821f6f8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 821f6fc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f700:	11003fcc 	andi	r4,r2,255
 821f704:	2100201c 	xori	r4,r4,128
 821f708:	213fe004 	addi	r4,r4,-128
 821f70c:	e0bffa17 	ldw	r2,-24(fp)
 821f710:	10c003c3 	ldbu	r3,15(r2)
 821f714:	00820974 	movhi	r2,2085
 821f718:	1086d704 	addi	r2,r2,7004
 821f71c:	21001224 	muli	r4,r4,72
 821f720:	1105883a 	add	r2,r2,r4
 821f724:	108003c4 	addi	r2,r2,15
 821f728:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 821f72c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f730:	11003fcc 	andi	r4,r2,255
 821f734:	2100201c 	xori	r4,r4,128
 821f738:	213fe004 	addi	r4,r4,-128
 821f73c:	e0bffa17 	ldw	r2,-24(fp)
 821f740:	10c00403 	ldbu	r3,16(r2)
 821f744:	00820974 	movhi	r2,2085
 821f748:	1086d704 	addi	r2,r2,7004
 821f74c:	21001224 	muli	r4,r4,72
 821f750:	1105883a 	add	r2,r2,r4
 821f754:	10800404 	addi	r2,r2,16
 821f758:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 821f75c:	e0bff617 	ldw	r2,-40(fp)
 821f760:	10000d1e 	bne	r2,zero,821f798 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 821f764:	01020974 	movhi	r4,2085
 821f768:	21378b04 	addi	r4,r4,-8660
 821f76c:	82033700 	call	8203370 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 821f770:	d0a07f83 	ldbu	r2,-32258(gp)
 821f774:	10803fcc 	andi	r2,r2,255
 821f778:	1080201c 	xori	r2,r2,128
 821f77c:	10bfe004 	addi	r2,r2,-128
 821f780:	100b883a 	mov	r5,r2
 821f784:	01020974 	movhi	r4,2085
 821f788:	21379604 	addi	r4,r4,-8616
 821f78c:	82030ec0 	call	82030ec <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f790:	00bfffc4 	movi	r2,-1
 821f794:	00019206 	br	821fde0 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 821f798:	d0a07f83 	ldbu	r2,-32258(gp)
 821f79c:	14003fcc 	andi	r16,r2,255
 821f7a0:	8400201c 	xori	r16,r16,128
 821f7a4:	843fe004 	addi	r16,r16,-128
 821f7a8:	e0bff617 	ldw	r2,-40(fp)
 821f7ac:	10800017 	ldw	r2,0(r2)
 821f7b0:	1009883a 	mov	r4,r2
 821f7b4:	8203cac0 	call	8203cac <strlen>
 821f7b8:	10800044 	addi	r2,r2,1
 821f7bc:	1009883a 	mov	r4,r2
 821f7c0:	824b3dc0 	call	824b3dc <malloc>
 821f7c4:	1009883a 	mov	r4,r2
 821f7c8:	00820974 	movhi	r2,2085
 821f7cc:	1086d704 	addi	r2,r2,7004
 821f7d0:	80c01224 	muli	r3,r16,72
 821f7d4:	10c5883a 	add	r2,r2,r3
 821f7d8:	10800504 	addi	r2,r2,20
 821f7dc:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 821f7e0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7e4:	10c03fcc 	andi	r3,r2,255
 821f7e8:	18c0201c 	xori	r3,r3,128
 821f7ec:	18ffe004 	addi	r3,r3,-128
 821f7f0:	00820974 	movhi	r2,2085
 821f7f4:	1086d704 	addi	r2,r2,7004
 821f7f8:	18c01224 	muli	r3,r3,72
 821f7fc:	10c5883a 	add	r2,r2,r3
 821f800:	10800504 	addi	r2,r2,20
 821f804:	10800017 	ldw	r2,0(r2)
 821f808:	10000a1e 	bne	r2,zero,821f834 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 821f80c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f810:	10803fcc 	andi	r2,r2,255
 821f814:	1080201c 	xori	r2,r2,128
 821f818:	10bfe004 	addi	r2,r2,-128
 821f81c:	100b883a 	mov	r5,r2
 821f820:	01020974 	movhi	r4,2085
 821f824:	2137ae04 	addi	r4,r4,-8520
 821f828:	82030ec0 	call	82030ec <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821f82c:	00bfffc4 	movi	r2,-1
 821f830:	00016b06 	br	821fde0 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 821f834:	d0a07f83 	ldbu	r2,-32258(gp)
 821f838:	10c03fcc 	andi	r3,r2,255
 821f83c:	18c0201c 	xori	r3,r3,128
 821f840:	18ffe004 	addi	r3,r3,-128
 821f844:	00820974 	movhi	r2,2085
 821f848:	1086d704 	addi	r2,r2,7004
 821f84c:	18c01224 	muli	r3,r3,72
 821f850:	10c5883a 	add	r2,r2,r3
 821f854:	10800504 	addi	r2,r2,20
 821f858:	10c00017 	ldw	r3,0(r2)
 821f85c:	e0bff617 	ldw	r2,-40(fp)
 821f860:	10800017 	ldw	r2,0(r2)
 821f864:	100b883a 	mov	r5,r2
 821f868:	1809883a 	mov	r4,r3
 821f86c:	824b4040 	call	824b404 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 821f870:	d0a07f83 	ldbu	r2,-32258(gp)
 821f874:	14003fcc 	andi	r16,r2,255
 821f878:	8400201c 	xori	r16,r16,128
 821f87c:	843fe004 	addi	r16,r16,-128
 821f880:	e0bff617 	ldw	r2,-40(fp)
 821f884:	10800117 	ldw	r2,4(r2)
 821f888:	1009883a 	mov	r4,r2
 821f88c:	8203cac0 	call	8203cac <strlen>
 821f890:	10800044 	addi	r2,r2,1
 821f894:	1009883a 	mov	r4,r2
 821f898:	824b3dc0 	call	824b3dc <malloc>
 821f89c:	1009883a 	mov	r4,r2
 821f8a0:	00820974 	movhi	r2,2085
 821f8a4:	1086d704 	addi	r2,r2,7004
 821f8a8:	80c01224 	muli	r3,r16,72
 821f8ac:	10c5883a 	add	r2,r2,r3
 821f8b0:	10800604 	addi	r2,r2,24
 821f8b4:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 821f8b8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8bc:	10c03fcc 	andi	r3,r2,255
 821f8c0:	18c0201c 	xori	r3,r3,128
 821f8c4:	18ffe004 	addi	r3,r3,-128
 821f8c8:	00820974 	movhi	r2,2085
 821f8cc:	1086d704 	addi	r2,r2,7004
 821f8d0:	18c01224 	muli	r3,r3,72
 821f8d4:	10c5883a 	add	r2,r2,r3
 821f8d8:	10800604 	addi	r2,r2,24
 821f8dc:	10800017 	ldw	r2,0(r2)
 821f8e0:	10000a1e 	bne	r2,zero,821f90c <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 821f8e4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8e8:	10803fcc 	andi	r2,r2,255
 821f8ec:	1080201c 	xori	r2,r2,128
 821f8f0:	10bfe004 	addi	r2,r2,-128
 821f8f4:	100b883a 	mov	r5,r2
 821f8f8:	01020974 	movhi	r4,2085
 821f8fc:	2137c104 	addi	r4,r4,-8444
 821f900:	82030ec0 	call	82030ec <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821f904:	00bfffc4 	movi	r2,-1
 821f908:	00013506 	br	821fde0 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 821f90c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f910:	10c03fcc 	andi	r3,r2,255
 821f914:	18c0201c 	xori	r3,r3,128
 821f918:	18ffe004 	addi	r3,r3,-128
 821f91c:	00820974 	movhi	r2,2085
 821f920:	1086d704 	addi	r2,r2,7004
 821f924:	18c01224 	muli	r3,r3,72
 821f928:	10c5883a 	add	r2,r2,r3
 821f92c:	10800604 	addi	r2,r2,24
 821f930:	10c00017 	ldw	r3,0(r2)
 821f934:	e0bff617 	ldw	r2,-40(fp)
 821f938:	10800117 	ldw	r2,4(r2)
 821f93c:	100b883a 	mov	r5,r2
 821f940:	1809883a 	mov	r4,r3
 821f944:	824b4040 	call	824b404 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 821f948:	d0a07f83 	ldbu	r2,-32258(gp)
 821f94c:	11003fcc 	andi	r4,r2,255
 821f950:	2100201c 	xori	r4,r4,128
 821f954:	213fe004 	addi	r4,r4,-128
 821f958:	e0bff617 	ldw	r2,-40(fp)
 821f95c:	10c0020b 	ldhu	r3,8(r2)
 821f960:	00820974 	movhi	r2,2085
 821f964:	1086d704 	addi	r2,r2,7004
 821f968:	21001224 	muli	r4,r4,72
 821f96c:	1105883a 	add	r2,r2,r4
 821f970:	10800704 	addi	r2,r2,28
 821f974:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 821f978:	e0bff717 	ldw	r2,-36(fp)
 821f97c:	1000151e 	bne	r2,zero,821f9d4 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 821f980:	d0a07f83 	ldbu	r2,-32258(gp)
 821f984:	10c03fcc 	andi	r3,r2,255
 821f988:	18c0201c 	xori	r3,r3,128
 821f98c:	18ffe004 	addi	r3,r3,-128
 821f990:	00820974 	movhi	r2,2085
 821f994:	1086d704 	addi	r2,r2,7004
 821f998:	18c01224 	muli	r3,r3,72
 821f99c:	10c5883a 	add	r2,r2,r3
 821f9a0:	10800784 	addi	r2,r2,30
 821f9a4:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 821f9a8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9ac:	10c03fcc 	andi	r3,r2,255
 821f9b0:	18c0201c 	xori	r3,r3,128
 821f9b4:	18ffe004 	addi	r3,r3,-128
 821f9b8:	00820974 	movhi	r2,2085
 821f9bc:	1086d704 	addi	r2,r2,7004
 821f9c0:	18c01224 	muli	r3,r3,72
 821f9c4:	10c5883a 	add	r2,r2,r3
 821f9c8:	10800804 	addi	r2,r2,32
 821f9cc:	10000015 	stw	zero,0(r2)
 821f9d0:	00001806 	br	821fa34 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 821f9d4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9d8:	11003fcc 	andi	r4,r2,255
 821f9dc:	2100201c 	xori	r4,r4,128
 821f9e0:	213fe004 	addi	r4,r4,-128
 821f9e4:	e0bff717 	ldw	r2,-36(fp)
 821f9e8:	10c00003 	ldbu	r3,0(r2)
 821f9ec:	00820974 	movhi	r2,2085
 821f9f0:	1086d704 	addi	r2,r2,7004
 821f9f4:	21001224 	muli	r4,r4,72
 821f9f8:	1105883a 	add	r2,r2,r4
 821f9fc:	10800784 	addi	r2,r2,30
 821fa00:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 821fa04:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa08:	11003fcc 	andi	r4,r2,255
 821fa0c:	2100201c 	xori	r4,r4,128
 821fa10:	213fe004 	addi	r4,r4,-128
 821fa14:	e0bff717 	ldw	r2,-36(fp)
 821fa18:	10c00117 	ldw	r3,4(r2)
 821fa1c:	00820974 	movhi	r2,2085
 821fa20:	1086d704 	addi	r2,r2,7004
 821fa24:	21001224 	muli	r4,r4,72
 821fa28:	1105883a 	add	r2,r2,r4
 821fa2c:	10800804 	addi	r2,r2,32
 821fa30:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 821fa34:	e0bff817 	ldw	r2,-32(fp)
 821fa38:	1000471e 	bne	r2,zero,821fb58 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 821fa3c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa40:	10c03fcc 	andi	r3,r2,255
 821fa44:	18c0201c 	xori	r3,r3,128
 821fa48:	18ffe004 	addi	r3,r3,-128
 821fa4c:	00820974 	movhi	r2,2085
 821fa50:	1086d704 	addi	r2,r2,7004
 821fa54:	18c01224 	muli	r3,r3,72
 821fa58:	10c5883a 	add	r2,r2,r3
 821fa5c:	10800904 	addi	r2,r2,36
 821fa60:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fa64:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa68:	10c03fcc 	andi	r3,r2,255
 821fa6c:	18c0201c 	xori	r3,r3,128
 821fa70:	18ffe004 	addi	r3,r3,-128
 821fa74:	00820974 	movhi	r2,2085
 821fa78:	1086d704 	addi	r2,r2,7004
 821fa7c:	18c01224 	muli	r3,r3,72
 821fa80:	10c5883a 	add	r2,r2,r3
 821fa84:	10800a04 	addi	r2,r2,40
 821fa88:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 821fa8c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa90:	10c03fcc 	andi	r3,r2,255
 821fa94:	18c0201c 	xori	r3,r3,128
 821fa98:	18ffe004 	addi	r3,r3,-128
 821fa9c:	00820974 	movhi	r2,2085
 821faa0:	1086d704 	addi	r2,r2,7004
 821faa4:	18c01224 	muli	r3,r3,72
 821faa8:	10c5883a 	add	r2,r2,r3
 821faac:	10800b04 	addi	r2,r2,44
 821fab0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 821fab4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fab8:	10c03fcc 	andi	r3,r2,255
 821fabc:	18c0201c 	xori	r3,r3,128
 821fac0:	18ffe004 	addi	r3,r3,-128
 821fac4:	00820974 	movhi	r2,2085
 821fac8:	1086d704 	addi	r2,r2,7004
 821facc:	18c01224 	muli	r3,r3,72
 821fad0:	10c5883a 	add	r2,r2,r3
 821fad4:	10800c04 	addi	r2,r2,48
 821fad8:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fadc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fae0:	10c03fcc 	andi	r3,r2,255
 821fae4:	18c0201c 	xori	r3,r3,128
 821fae8:	18ffe004 	addi	r3,r3,-128
 821faec:	00820974 	movhi	r2,2085
 821faf0:	1086d704 	addi	r2,r2,7004
 821faf4:	18c01224 	muli	r3,r3,72
 821faf8:	10c5883a 	add	r2,r2,r3
 821fafc:	10800d04 	addi	r2,r2,52
 821fb00:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 821fb04:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb08:	10c03fcc 	andi	r3,r2,255
 821fb0c:	18c0201c 	xori	r3,r3,128
 821fb10:	18ffe004 	addi	r3,r3,-128
 821fb14:	00820974 	movhi	r2,2085
 821fb18:	1086d704 	addi	r2,r2,7004
 821fb1c:	18c01224 	muli	r3,r3,72
 821fb20:	10c5883a 	add	r2,r2,r3
 821fb24:	10800e04 	addi	r2,r2,56
 821fb28:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 821fb2c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb30:	10c03fcc 	andi	r3,r2,255
 821fb34:	18c0201c 	xori	r3,r3,128
 821fb38:	18ffe004 	addi	r3,r3,-128
 821fb3c:	00820974 	movhi	r2,2085
 821fb40:	1086d704 	addi	r2,r2,7004
 821fb44:	18c01224 	muli	r3,r3,72
 821fb48:	10c5883a 	add	r2,r2,r3
 821fb4c:	10800f04 	addi	r2,r2,60
 821fb50:	10000015 	stw	zero,0(r2)
 821fb54:	00005406 	br	821fca8 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 821fb58:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb5c:	11003fcc 	andi	r4,r2,255
 821fb60:	2100201c 	xori	r4,r4,128
 821fb64:	213fe004 	addi	r4,r4,-128
 821fb68:	e0bff817 	ldw	r2,-32(fp)
 821fb6c:	10c00003 	ldbu	r3,0(r2)
 821fb70:	00820974 	movhi	r2,2085
 821fb74:	1086d704 	addi	r2,r2,7004
 821fb78:	21001224 	muli	r4,r4,72
 821fb7c:	1105883a 	add	r2,r2,r4
 821fb80:	10800904 	addi	r2,r2,36
 821fb84:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 821fb88:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb8c:	11003fcc 	andi	r4,r2,255
 821fb90:	2100201c 	xori	r4,r4,128
 821fb94:	213fe004 	addi	r4,r4,-128
 821fb98:	e0bff817 	ldw	r2,-32(fp)
 821fb9c:	10c00117 	ldw	r3,4(r2)
 821fba0:	00820974 	movhi	r2,2085
 821fba4:	1086d704 	addi	r2,r2,7004
 821fba8:	21001224 	muli	r4,r4,72
 821fbac:	1105883a 	add	r2,r2,r4
 821fbb0:	10800a04 	addi	r2,r2,40
 821fbb4:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 821fbb8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbbc:	11003fcc 	andi	r4,r2,255
 821fbc0:	2100201c 	xori	r4,r4,128
 821fbc4:	213fe004 	addi	r4,r4,-128
 821fbc8:	e0bff817 	ldw	r2,-32(fp)
 821fbcc:	10c00217 	ldw	r3,8(r2)
 821fbd0:	00820974 	movhi	r2,2085
 821fbd4:	1086d704 	addi	r2,r2,7004
 821fbd8:	21001224 	muli	r4,r4,72
 821fbdc:	1105883a 	add	r2,r2,r4
 821fbe0:	10800b04 	addi	r2,r2,44
 821fbe4:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 821fbe8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbec:	11003fcc 	andi	r4,r2,255
 821fbf0:	2100201c 	xori	r4,r4,128
 821fbf4:	213fe004 	addi	r4,r4,-128
 821fbf8:	e0bff817 	ldw	r2,-32(fp)
 821fbfc:	10c00317 	ldw	r3,12(r2)
 821fc00:	00820974 	movhi	r2,2085
 821fc04:	1086d704 	addi	r2,r2,7004
 821fc08:	21001224 	muli	r4,r4,72
 821fc0c:	1105883a 	add	r2,r2,r4
 821fc10:	10800c04 	addi	r2,r2,48
 821fc14:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 821fc18:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc1c:	11003fcc 	andi	r4,r2,255
 821fc20:	2100201c 	xori	r4,r4,128
 821fc24:	213fe004 	addi	r4,r4,-128
 821fc28:	e0bff817 	ldw	r2,-32(fp)
 821fc2c:	10c00417 	ldw	r3,16(r2)
 821fc30:	00820974 	movhi	r2,2085
 821fc34:	1086d704 	addi	r2,r2,7004
 821fc38:	21001224 	muli	r4,r4,72
 821fc3c:	1105883a 	add	r2,r2,r4
 821fc40:	10800d04 	addi	r2,r2,52
 821fc44:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 821fc48:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc4c:	11003fcc 	andi	r4,r2,255
 821fc50:	2100201c 	xori	r4,r4,128
 821fc54:	213fe004 	addi	r4,r4,-128
 821fc58:	e0bff817 	ldw	r2,-32(fp)
 821fc5c:	10c00517 	ldw	r3,20(r2)
 821fc60:	00820974 	movhi	r2,2085
 821fc64:	1086d704 	addi	r2,r2,7004
 821fc68:	21001224 	muli	r4,r4,72
 821fc6c:	1105883a 	add	r2,r2,r4
 821fc70:	10800e04 	addi	r2,r2,56
 821fc74:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 821fc78:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc7c:	11003fcc 	andi	r4,r2,255
 821fc80:	2100201c 	xori	r4,r4,128
 821fc84:	213fe004 	addi	r4,r4,-128
 821fc88:	e0bff817 	ldw	r2,-32(fp)
 821fc8c:	10c00617 	ldw	r3,24(r2)
 821fc90:	00820974 	movhi	r2,2085
 821fc94:	1086d704 	addi	r2,r2,7004
 821fc98:	21001224 	muli	r4,r4,72
 821fc9c:	1105883a 	add	r2,r2,r4
 821fca0:	10800f04 	addi	r2,r2,60
 821fca4:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 821fca8:	e0bff917 	ldw	r2,-28(fp)
 821fcac:	1000161e 	bne	r2,zero,821fd08 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 821fcb0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fcb4:	10c03fcc 	andi	r3,r2,255
 821fcb8:	18c0201c 	xori	r3,r3,128
 821fcbc:	18ffe004 	addi	r3,r3,-128
 821fcc0:	00820974 	movhi	r2,2085
 821fcc4:	1086d704 	addi	r2,r2,7004
 821fcc8:	18c01224 	muli	r3,r3,72
 821fccc:	10c5883a 	add	r2,r2,r3
 821fcd0:	10801004 	addi	r2,r2,64
 821fcd4:	00ffffc4 	movi	r3,-1
 821fcd8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 821fcdc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fce0:	10c03fcc 	andi	r3,r2,255
 821fce4:	18c0201c 	xori	r3,r3,128
 821fce8:	18ffe004 	addi	r3,r3,-128
 821fcec:	00820974 	movhi	r2,2085
 821fcf0:	1086d704 	addi	r2,r2,7004
 821fcf4:	18c01224 	muli	r3,r3,72
 821fcf8:	10c5883a 	add	r2,r2,r3
 821fcfc:	10801104 	addi	r2,r2,68
 821fd00:	10000015 	stw	zero,0(r2)
 821fd04:	00001806 	br	821fd68 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 821fd08:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd0c:	11003fcc 	andi	r4,r2,255
 821fd10:	2100201c 	xori	r4,r4,128
 821fd14:	213fe004 	addi	r4,r4,-128
 821fd18:	e0bff917 	ldw	r2,-28(fp)
 821fd1c:	10c00017 	ldw	r3,0(r2)
 821fd20:	00820974 	movhi	r2,2085
 821fd24:	1086d704 	addi	r2,r2,7004
 821fd28:	21001224 	muli	r4,r4,72
 821fd2c:	1105883a 	add	r2,r2,r4
 821fd30:	10801004 	addi	r2,r2,64
 821fd34:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 821fd38:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd3c:	11003fcc 	andi	r4,r2,255
 821fd40:	2100201c 	xori	r4,r4,128
 821fd44:	213fe004 	addi	r4,r4,-128
 821fd48:	e0bff917 	ldw	r2,-28(fp)
 821fd4c:	10c00117 	ldw	r3,4(r2)
 821fd50:	00820974 	movhi	r2,2085
 821fd54:	1086d704 	addi	r2,r2,7004
 821fd58:	21001224 	muli	r4,r4,72
 821fd5c:	1105883a 	add	r2,r2,r4
 821fd60:	10801104 	addi	r2,r2,68
 821fd64:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 821fd68:	e0bff617 	ldw	r2,-40(fp)
 821fd6c:	10800304 	addi	r2,r2,12
 821fd70:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 821fd74:	e0bff717 	ldw	r2,-36(fp)
 821fd78:	10000326 	beq	r2,zero,821fd88 <alt_tse_system_add_sys+0x98c>
 821fd7c:	e0bff717 	ldw	r2,-36(fp)
 821fd80:	10800204 	addi	r2,r2,8
 821fd84:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 821fd88:	e0bff817 	ldw	r2,-32(fp)
 821fd8c:	10000326 	beq	r2,zero,821fd9c <alt_tse_system_add_sys+0x9a0>
 821fd90:	e0bff817 	ldw	r2,-32(fp)
 821fd94:	10800704 	addi	r2,r2,28
 821fd98:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 821fd9c:	e0bff917 	ldw	r2,-28(fp)
 821fda0:	10000326 	beq	r2,zero,821fdb0 <alt_tse_system_add_sys+0x9b4>
 821fda4:	e0bff917 	ldw	r2,-28(fp)
 821fda8:	10800204 	addi	r2,r2,8
 821fdac:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 821fdb0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fdb4:	10800044 	addi	r2,r2,1
 821fdb8:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 821fdbc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fdc0:	d0a02d05 	stb	r2,-32588(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 821fdc4:	e0bff417 	ldw	r2,-48(fp)
 821fdc8:	10800044 	addi	r2,r2,1
 821fdcc:	e0bff415 	stw	r2,-48(fp)
 821fdd0:	e0fff417 	ldw	r3,-48(fp)
 821fdd4:	e0bff517 	ldw	r2,-44(fp)
 821fdd8:	18bdb216 	blt	r3,r2,821f4a4 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 821fddc:	0005883a 	mov	r2,zero
	
}
 821fde0:	e6ffff04 	addi	sp,fp,-4
 821fde4:	dfc00217 	ldw	ra,8(sp)
 821fde8:	df000117 	ldw	fp,4(sp)
 821fdec:	dc000017 	ldw	r16,0(sp)
 821fdf0:	dec00304 	addi	sp,sp,12
 821fdf4:	f800283a 	ret

0821fdf8 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 821fdf8:	defff904 	addi	sp,sp,-28
 821fdfc:	dfc00615 	stw	ra,24(sp)
 821fe00:	df000515 	stw	fp,20(sp)
 821fe04:	df000504 	addi	fp,sp,20
 821fe08:	e13ffe15 	stw	r4,-8(fp)
 821fe0c:	2805883a 	mov	r2,r5
 821fe10:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 821fe14:	e03ffb15 	stw	zero,-20(fp)
 821fe18:	00004806 	br	821ff3c <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 821fe1c:	e0bffb17 	ldw	r2,-20(fp)
 821fe20:	1085883a 	add	r2,r2,r2
 821fe24:	1085883a 	add	r2,r2,r2
 821fe28:	1007883a 	mov	r3,r2
 821fe2c:	e0bffe17 	ldw	r2,-8(fp)
 821fe30:	10c5883a 	add	r2,r2,r3
 821fe34:	10800017 	ldw	r2,0(r2)
 821fe38:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 821fe3c:	e0bffd17 	ldw	r2,-12(fp)
 821fe40:	1000081e 	bne	r2,zero,821fe64 <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821fe44:	01020974 	movhi	r4,2085
 821fe48:	21376f04 	addi	r4,r4,-8772
 821fe4c:	82033700 	call	8203370 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 821fe50:	01020974 	movhi	r4,2085
 821fe54:	2137d404 	addi	r4,r4,-8368
 821fe58:	82033700 	call	8203370 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821fe5c:	00bfffc4 	movi	r2,-1
 821fe60:	00003a06 	br	821ff4c <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 821fe64:	e03ffc15 	stw	zero,-16(fp)
 821fe68:	00002d06 	br	821ff20 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 821fe6c:	e0bffd17 	ldw	r2,-12(fp)
 821fe70:	10c00017 	ldw	r3,0(r2)
 821fe74:	00820974 	movhi	r2,2085
 821fe78:	1086d704 	addi	r2,r2,7004
 821fe7c:	e13ffc17 	ldw	r4,-16(fp)
 821fe80:	21001224 	muli	r4,r4,72
 821fe84:	1105883a 	add	r2,r2,r4
 821fe88:	10800017 	ldw	r2,0(r2)
 821fe8c:	1880211e 	bne	r3,r2,821ff14 <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 821fe90:	00820974 	movhi	r2,2085
 821fe94:	1086d704 	addi	r2,r2,7004
 821fe98:	e0fffc17 	ldw	r3,-16(fp)
 821fe9c:	18c01224 	muli	r3,r3,72
 821fea0:	10c5883a 	add	r2,r2,r3
 821fea4:	108002c4 	addi	r2,r2,11
 821fea8:	10800003 	ldbu	r2,0(r2)
 821feac:	10803fcc 	andi	r2,r2,255
 821feb0:	10000826 	beq	r2,zero,821fed4 <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 821feb4:	01020974 	movhi	r4,2085
 821feb8:	2137e804 	addi	r4,r4,-8288
 821febc:	82033700 	call	8203370 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 821fec0:	01020974 	movhi	r4,2085
 821fec4:	2137f904 	addi	r4,r4,-8220
 821fec8:	82033700 	call	8203370 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821fecc:	00bfffc4 	movi	r2,-1
 821fed0:	00001e06 	br	821ff4c <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 821fed4:	00820974 	movhi	r2,2085
 821fed8:	1086d704 	addi	r2,r2,7004
 821fedc:	e0fffc17 	ldw	r3,-16(fp)
 821fee0:	18c01224 	muli	r3,r3,72
 821fee4:	10c5883a 	add	r2,r2,r3
 821fee8:	10800344 	addi	r2,r2,13
 821feec:	00c00044 	movi	r3,1
 821fef0:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 821fef4:	00820974 	movhi	r2,2085
 821fef8:	1086d704 	addi	r2,r2,7004
 821fefc:	e0fffc17 	ldw	r3,-16(fp)
 821ff00:	18c01224 	muli	r3,r3,72
 821ff04:	10c5883a 	add	r2,r2,r3
 821ff08:	10800384 	addi	r2,r2,14
 821ff0c:	e0ffff03 	ldbu	r3,-4(fp)
 821ff10:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 821ff14:	e0bffc17 	ldw	r2,-16(fp)
 821ff18:	10800044 	addi	r2,r2,1
 821ff1c:	e0bffc15 	stw	r2,-16(fp)
 821ff20:	d0a02d03 	ldbu	r2,-32588(gp)
 821ff24:	10803fcc 	andi	r2,r2,255
 821ff28:	e0fffc17 	ldw	r3,-16(fp)
 821ff2c:	18bfcf16 	blt	r3,r2,821fe6c <alt_tse_sys_enable_mdio_sharing+0x74>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 821ff30:	e0bffb17 	ldw	r2,-20(fp)
 821ff34:	10800044 	addi	r2,r2,1
 821ff38:	e0bffb15 	stw	r2,-20(fp)
 821ff3c:	e0bfff03 	ldbu	r2,-4(fp)
 821ff40:	e0fffb17 	ldw	r3,-20(fp)
 821ff44:	18bfb516 	blt	r3,r2,821fe1c <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 821ff48:	0005883a 	mov	r2,zero
}
 821ff4c:	e037883a 	mov	sp,fp
 821ff50:	dfc00117 	ldw	ra,4(sp)
 821ff54:	df000017 	ldw	fp,0(sp)
 821ff58:	dec00204 	addi	sp,sp,8
 821ff5c:	f800283a 	ret

0821ff60 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 821ff60:	defffc04 	addi	sp,sp,-16
 821ff64:	dfc00315 	stw	ra,12(sp)
 821ff68:	df000215 	stw	fp,8(sp)
 821ff6c:	df000204 	addi	fp,sp,8
 821ff70:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 821ff74:	e13fff17 	ldw	r4,-4(fp)
 821ff78:	82201480 	call	8220148 <alt_tse_get_mac_info>
 821ff7c:	10800317 	ldw	r2,12(r2)
 821ff80:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 821ff84:	e13ffe17 	ldw	r4,-8(fp)
 821ff88:	82233180 	call	8223318 <alt_tse_phy_get_common_speed>
}
 821ff8c:	e037883a 	mov	sp,fp
 821ff90:	dfc00117 	ldw	ra,4(sp)
 821ff94:	df000017 	ldw	fp,0(sp)
 821ff98:	dec00204 	addi	sp,sp,8
 821ff9c:	f800283a 	ret

0821ffa0 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 821ffa0:	defffb04 	addi	sp,sp,-20
 821ffa4:	dfc00415 	stw	ra,16(sp)
 821ffa8:	df000315 	stw	fp,12(sp)
 821ffac:	df000304 	addi	fp,sp,12
 821ffb0:	e13ffe15 	stw	r4,-8(fp)
 821ffb4:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 821ffb8:	e13ffe17 	ldw	r4,-8(fp)
 821ffbc:	82201480 	call	8220148 <alt_tse_get_mac_info>
 821ffc0:	10800317 	ldw	r2,12(r2)
 821ffc4:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 821ffc8:	e17fff17 	ldw	r5,-4(fp)
 821ffcc:	e13ffd17 	ldw	r4,-12(fp)
 821ffd0:	82236400 	call	8223640 <alt_tse_phy_set_common_speed>
}
 821ffd4:	e037883a 	mov	sp,fp
 821ffd8:	dfc00117 	ldw	ra,4(sp)
 821ffdc:	df000017 	ldw	fp,0(sp)
 821ffe0:	dec00204 	addi	sp,sp,8
 821ffe4:	f800283a 	ret

0821ffe8 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 821ffe8:	defffd04 	addi	sp,sp,-12
 821ffec:	df000215 	stw	fp,8(sp)
 821fff0:	df000204 	addi	fp,sp,8
 821fff4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 821fff8:	e03ffe15 	stw	zero,-8(fp)
 821fffc:	00000c06 	br	8220030 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 8220000:	e0bffe17 	ldw	r2,-8(fp)
 8220004:	10c01224 	muli	r3,r2,72
 8220008:	00820974 	movhi	r2,2085
 822000c:	1086d704 	addi	r2,r2,7004
 8220010:	1887883a 	add	r3,r3,r2
 8220014:	e0bfff17 	ldw	r2,-4(fp)
 8220018:	1880021e 	bne	r3,r2,8220024 <alt_tse_get_system_index+0x3c>
            return i;
 822001c:	e0bffe17 	ldw	r2,-8(fp)
 8220020:	00000806 	br	8220044 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 8220024:	e0bffe17 	ldw	r2,-8(fp)
 8220028:	10800044 	addi	r2,r2,1
 822002c:	e0bffe15 	stw	r2,-8(fp)
 8220030:	d0a02d03 	ldbu	r2,-32588(gp)
 8220034:	10803fcc 	andi	r2,r2,255
 8220038:	e0fffe17 	ldw	r3,-8(fp)
 822003c:	18bff016 	blt	r3,r2,8220000 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220040:	00bfffc4 	movi	r2,-1
}
 8220044:	e037883a 	mov	sp,fp
 8220048:	df000017 	ldw	fp,0(sp)
 822004c:	dec00104 	addi	sp,sp,4
 8220050:	f800283a 	ret

08220054 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 8220054:	defffd04 	addi	sp,sp,-12
 8220058:	df000215 	stw	fp,8(sp)
 822005c:	df000204 	addi	fp,sp,8
 8220060:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 8220064:	e03ffe15 	stw	zero,-8(fp)
 8220068:	00000e06 	br	82200a4 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 822006c:	008209b4 	movhi	r2,2086
 8220070:	10b61504 	addi	r2,r2,-10156
 8220074:	e0fffe17 	ldw	r3,-8(fp)
 8220078:	18c7883a 	add	r3,r3,r3
 822007c:	18c7883a 	add	r3,r3,r3
 8220080:	10c5883a 	add	r2,r2,r3
 8220084:	10c00017 	ldw	r3,0(r2)
 8220088:	e0bfff17 	ldw	r2,-4(fp)
 822008c:	1880021e 	bne	r3,r2,8220098 <alt_tse_get_mac_group_index+0x44>
            return i;
 8220090:	e0bffe17 	ldw	r2,-8(fp)
 8220094:	00000806 	br	82200b8 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 8220098:	e0bffe17 	ldw	r2,-8(fp)
 822009c:	10800044 	addi	r2,r2,1
 82200a0:	e0bffe15 	stw	r2,-8(fp)
 82200a4:	d0a07f43 	ldbu	r2,-32259(gp)
 82200a8:	10803fcc 	andi	r2,r2,255
 82200ac:	e0fffe17 	ldw	r3,-8(fp)
 82200b0:	18bfee16 	blt	r3,r2,822006c <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 82200b4:	00bfffc4 	movi	r2,-1
}
 82200b8:	e037883a 	mov	sp,fp
 82200bc:	df000017 	ldw	fp,0(sp)
 82200c0:	dec00104 	addi	sp,sp,4
 82200c4:	f800283a 	ret

082200c8 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 82200c8:	defffd04 	addi	sp,sp,-12
 82200cc:	df000215 	stw	fp,8(sp)
 82200d0:	df000204 	addi	fp,sp,8
 82200d4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 82200d8:	e03ffe15 	stw	zero,-8(fp)
 82200dc:	00000f06 	br	822011c <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 82200e0:	e0bfff17 	ldw	r2,-4(fp)
 82200e4:	10c00317 	ldw	r3,12(r2)
 82200e8:	e0bffe17 	ldw	r2,-8(fp)
 82200ec:	10800044 	addi	r2,r2,1
 82200f0:	1085883a 	add	r2,r2,r2
 82200f4:	1085883a 	add	r2,r2,r2
 82200f8:	1885883a 	add	r2,r3,r2
 82200fc:	10c00017 	ldw	r3,0(r2)
 8220100:	e0bfff17 	ldw	r2,-4(fp)
 8220104:	1880021e 	bne	r3,r2,8220110 <alt_tse_get_mac_info_index+0x48>
            return i;
 8220108:	e0bffe17 	ldw	r2,-8(fp)
 822010c:	00000a06 	br	8220138 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 8220110:	e0bffe17 	ldw	r2,-8(fp)
 8220114:	10800044 	addi	r2,r2,1
 8220118:	e0bffe15 	stw	r2,-8(fp)
 822011c:	e0bfff17 	ldw	r2,-4(fp)
 8220120:	10800317 	ldw	r2,12(r2)
 8220124:	10800003 	ldbu	r2,0(r2)
 8220128:	10803fcc 	andi	r2,r2,255
 822012c:	e0fffe17 	ldw	r3,-8(fp)
 8220130:	18bfeb16 	blt	r3,r2,82200e0 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220134:	00bfffc4 	movi	r2,-1
}
 8220138:	e037883a 	mov	sp,fp
 822013c:	df000017 	ldw	fp,0(sp)
 8220140:	dec00104 	addi	sp,sp,4
 8220144:	f800283a 	ret

08220148 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 8220148:	defffa04 	addi	sp,sp,-24
 822014c:	df000515 	stw	fp,20(sp)
 8220150:	df000504 	addi	fp,sp,20
 8220154:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 8220158:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 822015c:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 8220160:	e03ffb15 	stw	zero,-20(fp)
 8220164:	00002506 	br	82201fc <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 8220168:	008209b4 	movhi	r2,2086
 822016c:	10b61504 	addi	r2,r2,-10156
 8220170:	e0fffb17 	ldw	r3,-20(fp)
 8220174:	18c7883a 	add	r3,r3,r3
 8220178:	18c7883a 	add	r3,r3,r3
 822017c:	10c5883a 	add	r2,r2,r3
 8220180:	10800017 	ldw	r2,0(r2)
 8220184:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 8220188:	e03ffc15 	stw	zero,-16(fp)
 822018c:	00001306 	br	82201dc <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 8220190:	e0fffd17 	ldw	r3,-12(fp)
 8220194:	e0bffc17 	ldw	r2,-16(fp)
 8220198:	10800044 	addi	r2,r2,1
 822019c:	1085883a 	add	r2,r2,r2
 82201a0:	1085883a 	add	r2,r2,r2
 82201a4:	1885883a 	add	r2,r3,r2
 82201a8:	10800017 	ldw	r2,0(r2)
 82201ac:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 82201b0:	e0bffe17 	ldw	r2,-8(fp)
 82201b4:	10800217 	ldw	r2,8(r2)
 82201b8:	10800017 	ldw	r2,0(r2)
 82201bc:	1007883a 	mov	r3,r2
 82201c0:	e0bfff17 	ldw	r2,-4(fp)
 82201c4:	1880021e 	bne	r3,r2,82201d0 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 82201c8:	e0bffe17 	ldw	r2,-8(fp)
 82201cc:	00001006 	br	8220210 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 82201d0:	e0bffc17 	ldw	r2,-16(fp)
 82201d4:	10800044 	addi	r2,r2,1
 82201d8:	e0bffc15 	stw	r2,-16(fp)
 82201dc:	e0bffd17 	ldw	r2,-12(fp)
 82201e0:	10800003 	ldbu	r2,0(r2)
 82201e4:	10803fcc 	andi	r2,r2,255
 82201e8:	e0fffc17 	ldw	r3,-16(fp)
 82201ec:	18bfe816 	blt	r3,r2,8220190 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 82201f0:	e0bffb17 	ldw	r2,-20(fp)
 82201f4:	10800044 	addi	r2,r2,1
 82201f8:	e0bffb15 	stw	r2,-20(fp)
 82201fc:	d0a07f43 	ldbu	r2,-32259(gp)
 8220200:	10803fcc 	andi	r2,r2,255
 8220204:	e0fffb17 	ldw	r3,-20(fp)
 8220208:	18bfd716 	blt	r3,r2,8220168 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 822020c:	0005883a 	mov	r2,zero
}
 8220210:	e037883a 	mov	sp,fp
 8220214:	df000017 	ldw	fp,0(sp)
 8220218:	dec00104 	addi	sp,sp,4
 822021c:	f800283a 	ret

08220220 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 8220220:	defffc04 	addi	sp,sp,-16
 8220224:	df000315 	stw	fp,12(sp)
 8220228:	df000304 	addi	fp,sp,12
 822022c:	e13ffe15 	stw	r4,-8(fp)
 8220230:	2805883a 	mov	r2,r5
 8220234:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220238:	e0bffe17 	ldw	r2,-8(fp)
 822023c:	10800204 	addi	r2,r2,8
 8220240:	10800037 	ldwio	r2,0(r2)
 8220244:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 8220248:	e0bfff03 	ldbu	r2,-4(fp)
 822024c:	10800098 	cmpnei	r2,r2,2
 8220250:	1000091e 	bne	r2,zero,8220278 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220254:	e0bffd17 	ldw	r2,-12(fp)
 8220258:	10800214 	ori	r2,r2,8
 822025c:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220260:	e0fffd17 	ldw	r3,-12(fp)
 8220264:	00bf8034 	movhi	r2,65024
 8220268:	10bfffc4 	addi	r2,r2,-1
 822026c:	1884703a 	and	r2,r3,r2
 8220270:	e0bffd15 	stw	r2,-12(fp)
 8220274:	00001906 	br	82202dc <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 8220278:	e0bfff03 	ldbu	r2,-4(fp)
 822027c:	10800058 	cmpnei	r2,r2,1
 8220280:	10000a1e 	bne	r2,zero,82202ac <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220284:	e0fffd17 	ldw	r3,-12(fp)
 8220288:	00bffdc4 	movi	r2,-9
 822028c:	1884703a 	and	r2,r3,r2
 8220290:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220294:	e0fffd17 	ldw	r3,-12(fp)
 8220298:	00bf8034 	movhi	r2,65024
 822029c:	10bfffc4 	addi	r2,r2,-1
 82202a0:	1884703a 	and	r2,r3,r2
 82202a4:	e0bffd15 	stw	r2,-12(fp)
 82202a8:	00000c06 	br	82202dc <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 82202ac:	e0bfff03 	ldbu	r2,-4(fp)
 82202b0:	1000081e 	bne	r2,zero,82202d4 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82202b4:	e0fffd17 	ldw	r3,-12(fp)
 82202b8:	00bffdc4 	movi	r2,-9
 82202bc:	1884703a 	and	r2,r3,r2
 82202c0:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82202c4:	e0bffd17 	ldw	r2,-12(fp)
 82202c8:	10808034 	orhi	r2,r2,512
 82202cc:	e0bffd15 	stw	r2,-12(fp)
 82202d0:	00000206 	br	82202dc <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 82202d4:	00bffd84 	movi	r2,-10
 82202d8:	00000506 	br	82202f0 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 82202dc:	e0bffe17 	ldw	r2,-8(fp)
 82202e0:	10800204 	addi	r2,r2,8
 82202e4:	e0fffd17 	ldw	r3,-12(fp)
 82202e8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 82202ec:	0005883a 	mov	r2,zero
}
 82202f0:	e037883a 	mov	sp,fp
 82202f4:	df000017 	ldw	fp,0(sp)
 82202f8:	dec00104 	addi	sp,sp,4
 82202fc:	f800283a 	ret

08220300 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 8220300:	defffc04 	addi	sp,sp,-16
 8220304:	df000315 	stw	fp,12(sp)
 8220308:	df000304 	addi	fp,sp,12
 822030c:	e13ffe15 	stw	r4,-8(fp)
 8220310:	2805883a 	mov	r2,r5
 8220314:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220318:	e0bffe17 	ldw	r2,-8(fp)
 822031c:	10800204 	addi	r2,r2,8
 8220320:	10800037 	ldwio	r2,0(r2)
 8220324:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8220328:	e0bfff03 	ldbu	r2,-4(fp)
 822032c:	1000041e 	bne	r2,zero,8220340 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8220330:	e0bffd17 	ldw	r2,-12(fp)
 8220334:	10810014 	ori	r2,r2,1024
 8220338:	e0bffd15 	stw	r2,-12(fp)
 822033c:	00000a06 	br	8220368 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 8220340:	e0bfff03 	ldbu	r2,-4(fp)
 8220344:	10800058 	cmpnei	r2,r2,1
 8220348:	1000051e 	bne	r2,zero,8220360 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 822034c:	e0fffd17 	ldw	r3,-12(fp)
 8220350:	00beffc4 	movi	r2,-1025
 8220354:	1884703a 	and	r2,r3,r2
 8220358:	e0bffd15 	stw	r2,-12(fp)
 822035c:	00000206 	br	8220368 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 8220360:	00bffd84 	movi	r2,-10
 8220364:	00000506 	br	822037c <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 8220368:	e0bffe17 	ldw	r2,-8(fp)
 822036c:	10800204 	addi	r2,r2,8
 8220370:	e0fffd17 	ldw	r3,-12(fp)
 8220374:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 8220378:	0005883a 	mov	r2,zero

}
 822037c:	e037883a 	mov	sp,fp
 8220380:	df000017 	ldw	fp,0(sp)
 8220384:	dec00104 	addi	sp,sp,4
 8220388:	f800283a 	ret

0822038c <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 822038c:	defff404 	addi	sp,sp,-48
 8220390:	dfc00b15 	stw	ra,44(sp)
 8220394:	df000a15 	stw	fp,40(sp)
 8220398:	df000a04 	addi	fp,sp,40
 822039c:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82203a0:	00800044 	movi	r2,1
 82203a4:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 82203a8:	00800044 	movi	r2,1
 82203ac:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 82203b0:	e0bff743 	ldbu	r2,-35(fp)
 82203b4:	10c0004c 	andi	r3,r2,1
 82203b8:	e0bff703 	ldbu	r2,-36(fp)
 82203bc:	10800098 	cmpnei	r2,r2,2
 82203c0:	1000021e 	bne	r2,zero,82203cc <getPHYSpeed+0x40>
 82203c4:	00800084 	movi	r2,2
 82203c8:	00000106 	br	82203d0 <getPHYSpeed+0x44>
 82203cc:	0005883a 	mov	r2,zero
 82203d0:	1886b03a 	or	r3,r3,r2
 82203d4:	e0bff703 	ldbu	r2,-36(fp)
 82203d8:	10800058 	cmpnei	r2,r2,1
 82203dc:	1000021e 	bne	r2,zero,82203e8 <getPHYSpeed+0x5c>
 82203e0:	00800104 	movi	r2,4
 82203e4:	00000106 	br	82203ec <getPHYSpeed+0x60>
 82203e8:	0005883a 	mov	r2,zero
 82203ec:	1886b03a 	or	r3,r3,r2
 82203f0:	e0bff703 	ldbu	r2,-36(fp)
 82203f4:	1000021e 	bne	r2,zero,8220400 <getPHYSpeed+0x74>
 82203f8:	00800204 	movi	r2,8
 82203fc:	00000106 	br	8220404 <getPHYSpeed+0x78>
 8220400:	0005883a 	mov	r2,zero
 8220404:	1886b03a 	or	r3,r3,r2
 8220408:	e0bff703 	ldbu	r2,-36(fp)
 822040c:	108000d8 	cmpnei	r2,r2,3
 8220410:	1000021e 	bne	r2,zero,822041c <getPHYSpeed+0x90>
 8220414:	00800074 	movhi	r2,1
 8220418:	00000106 	br	8220420 <getPHYSpeed+0x94>
 822041c:	0005883a 	mov	r2,zero
 8220420:	1884b03a 	or	r2,r3,r2
 8220424:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 8220428:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 822042c:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 8220430:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 8220434:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8220438:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 822043c:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 8220440:	d0a07fc3 	ldbu	r2,-32257(gp)
 8220444:	10803fcc 	andi	r2,r2,255
 8220448:	1000031e 	bne	r2,zero,8220458 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 822044c:	822238c0 	call	822238c <alt_tse_phy_init>
        is_init = 1;
 8220450:	00800044 	movi	r2,1
 8220454:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 8220458:	e13fff17 	ldw	r4,-4(fp)
 822045c:	82201480 	call	8220148 <alt_tse_get_mac_info>
 8220460:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 8220464:	e0bffa17 	ldw	r2,-24(fp)
 8220468:	1000481e 	bne	r2,zero,822058c <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 822046c:	00800044 	movi	r2,1
 8220470:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220474:	00800044 	movi	r2,1
 8220478:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 822047c:	e0bff743 	ldbu	r2,-35(fp)
 8220480:	10c0004c 	andi	r3,r2,1
 8220484:	e0bff703 	ldbu	r2,-36(fp)
 8220488:	10800098 	cmpnei	r2,r2,2
 822048c:	1000021e 	bne	r2,zero,8220498 <getPHYSpeed+0x10c>
 8220490:	00800084 	movi	r2,2
 8220494:	00000106 	br	822049c <getPHYSpeed+0x110>
 8220498:	0005883a 	mov	r2,zero
 822049c:	1886b03a 	or	r3,r3,r2
 82204a0:	e0bff703 	ldbu	r2,-36(fp)
 82204a4:	10800058 	cmpnei	r2,r2,1
 82204a8:	1000021e 	bne	r2,zero,82204b4 <getPHYSpeed+0x128>
 82204ac:	00800104 	movi	r2,4
 82204b0:	00000106 	br	82204b8 <getPHYSpeed+0x12c>
 82204b4:	0005883a 	mov	r2,zero
 82204b8:	1886b03a 	or	r3,r3,r2
 82204bc:	e0bff703 	ldbu	r2,-36(fp)
 82204c0:	1000021e 	bne	r2,zero,82204cc <getPHYSpeed+0x140>
 82204c4:	00800204 	movi	r2,8
 82204c8:	00000106 	br	82204d0 <getPHYSpeed+0x144>
 82204cc:	0005883a 	mov	r2,zero
 82204d0:	1886b03a 	or	r3,r3,r2
 82204d4:	e0bff703 	ldbu	r2,-36(fp)
 82204d8:	108000d8 	cmpnei	r2,r2,3
 82204dc:	1000021e 	bne	r2,zero,82204e8 <getPHYSpeed+0x15c>
 82204e0:	00800074 	movhi	r2,1
 82204e4:	00000106 	br	82204ec <getPHYSpeed+0x160>
 82204e8:	0005883a 	mov	r2,zero
 82204ec:	1884b03a 	or	r2,r3,r2
 82204f0:	10802034 	orhi	r2,r2,128
 82204f4:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 82204f8:	e0bff703 	ldbu	r2,-36(fp)
 82204fc:	108000a0 	cmpeqi	r2,r2,2
 8220500:	10000e1e 	bne	r2,zero,822053c <getPHYSpeed+0x1b0>
 8220504:	e0bff703 	ldbu	r2,-36(fp)
 8220508:	10800060 	cmpeqi	r2,r2,1
 822050c:	1000081e 	bne	r2,zero,8220530 <getPHYSpeed+0x1a4>
 8220510:	e0bff703 	ldbu	r2,-36(fp)
 8220514:	1000031e 	bne	r2,zero,8220524 <getPHYSpeed+0x198>
 8220518:	00820974 	movhi	r2,2085
 822051c:	10b80804 	addi	r2,r2,-8160
 8220520:	00000806 	br	8220544 <getPHYSpeed+0x1b8>
 8220524:	00820974 	movhi	r2,2085
 8220528:	10b80904 	addi	r2,r2,-8156
 822052c:	00000506 	br	8220544 <getPHYSpeed+0x1b8>
 8220530:	00820974 	movhi	r2,2085
 8220534:	10b80b04 	addi	r2,r2,-8148
 8220538:	00000206 	br	8220544 <getPHYSpeed+0x1b8>
 822053c:	00820974 	movhi	r2,2085
 8220540:	10b80c04 	addi	r2,r2,-8144
 8220544:	e0fff743 	ldbu	r3,-35(fp)
 8220548:	18c00058 	cmpnei	r3,r3,1
 822054c:	1800031e 	bne	r3,zero,822055c <getPHYSpeed+0x1d0>
 8220550:	00c20974 	movhi	r3,2085
 8220554:	18f80e04 	addi	r3,r3,-8136
 8220558:	00000206 	br	8220564 <getPHYSpeed+0x1d8>
 822055c:	00c20974 	movhi	r3,2085
 8220560:	18f81004 	addi	r3,r3,-8128
 8220564:	180d883a 	mov	r6,r3
 8220568:	100b883a 	mov	r5,r2
 822056c:	01020974 	movhi	r4,2085
 8220570:	21381204 	addi	r4,r4,-8120
 8220574:	82030ec0 	call	82030ec <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 8220578:	01020974 	movhi	r4,2085
 822057c:	21382a04 	addi	r4,r4,-8024
 8220580:	82033700 	call	8203370 <puts>
        return result;
 8220584:	e0bff817 	ldw	r2,-32(fp)
 8220588:	00021d06 	br	8220e00 <getPHYSpeed+0xa74>
    }
    
    pphy = pmac_info->pphy_info;
 822058c:	e0bffa17 	ldw	r2,-24(fp)
 8220590:	10800117 	ldw	r2,4(r2)
 8220594:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 8220598:	e0bffa17 	ldw	r2,-24(fp)
 822059c:	10800317 	ldw	r2,12(r2)
 82205a0:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 82205a4:	e0bffa17 	ldw	r2,-24(fp)
 82205a8:	10800217 	ldw	r2,8(r2)
 82205ac:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82205b0:	e13ffa17 	ldw	r4,-24(fp)
 82205b4:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 82205b8:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82205bc:	e13ffb17 	ldw	r4,-20(fp)
 82205c0:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 82205c4:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 82205c8:	e0bffb17 	ldw	r2,-20(fp)
 82205cc:	10800117 	ldw	r2,4(r2)
 82205d0:	10800217 	ldw	r2,8(r2)
 82205d4:	10800203 	ldbu	r2,8(r2)
 82205d8:	10803fcc 	andi	r2,r2,255
 82205dc:	10005a1e 	bne	r2,zero,8220748 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82205e0:	00800044 	movi	r2,1
 82205e4:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 82205e8:	00800044 	movi	r2,1
 82205ec:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 82205f0:	e0bff743 	ldbu	r2,-35(fp)
 82205f4:	10c0004c 	andi	r3,r2,1
 82205f8:	e0bff703 	ldbu	r2,-36(fp)
 82205fc:	10800098 	cmpnei	r2,r2,2
 8220600:	1000021e 	bne	r2,zero,822060c <getPHYSpeed+0x280>
 8220604:	00800084 	movi	r2,2
 8220608:	00000106 	br	8220610 <getPHYSpeed+0x284>
 822060c:	0005883a 	mov	r2,zero
 8220610:	1886b03a 	or	r3,r3,r2
 8220614:	e0bff703 	ldbu	r2,-36(fp)
 8220618:	10800058 	cmpnei	r2,r2,1
 822061c:	1000021e 	bne	r2,zero,8220628 <getPHYSpeed+0x29c>
 8220620:	00800104 	movi	r2,4
 8220624:	00000106 	br	822062c <getPHYSpeed+0x2a0>
 8220628:	0005883a 	mov	r2,zero
 822062c:	1886b03a 	or	r3,r3,r2
 8220630:	e0bff703 	ldbu	r2,-36(fp)
 8220634:	1000021e 	bne	r2,zero,8220640 <getPHYSpeed+0x2b4>
 8220638:	00800204 	movi	r2,8
 822063c:	00000106 	br	8220644 <getPHYSpeed+0x2b8>
 8220640:	0005883a 	mov	r2,zero
 8220644:	1886b03a 	or	r3,r3,r2
 8220648:	e0bff703 	ldbu	r2,-36(fp)
 822064c:	108000d8 	cmpnei	r2,r2,3
 8220650:	1000021e 	bne	r2,zero,822065c <getPHYSpeed+0x2d0>
 8220654:	00800074 	movhi	r2,1
 8220658:	00000106 	br	8220660 <getPHYSpeed+0x2d4>
 822065c:	0005883a 	mov	r2,zero
 8220660:	1884b03a 	or	r2,r3,r2
 8220664:	10801034 	orhi	r2,r2,64
 8220668:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 822066c:	010003f4 	movhi	r4,15
 8220670:	21109004 	addi	r4,r4,16960
 8220674:	823c7700 	call	823c770 <usleep>
        if(psys->tse_phy_cfg) {
 8220678:	e0bffc17 	ldw	r2,-16(fp)
 822067c:	10801117 	ldw	r2,68(r2)
 8220680:	10000d26 	beq	r2,zero,82206b8 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 8220684:	e0bffd47 	ldb	r2,-11(fp)
 8220688:	e0fffd07 	ldb	r3,-12(fp)
 822068c:	180d883a 	mov	r6,r3
 8220690:	100b883a 	mov	r5,r2
 8220694:	01020974 	movhi	r4,2085
 8220698:	21383b04 	addi	r4,r4,-7956
 822069c:	82030ec0 	call	82030ec <printf>
        	result = psys->tse_phy_cfg(pmac);
 82206a0:	e0bffc17 	ldw	r2,-16(fp)
 82206a4:	10801117 	ldw	r2,68(r2)
 82206a8:	e13fff17 	ldw	r4,-4(fp)
 82206ac:	103ee83a 	callr	r2
 82206b0:	e0bff815 	stw	r2,-32(fp)
 82206b4:	00002206 	br	8220740 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82206b8:	e13ffd47 	ldb	r4,-11(fp)
 82206bc:	e0bff703 	ldbu	r2,-36(fp)
 82206c0:	108000a0 	cmpeqi	r2,r2,2
 82206c4:	10000e1e 	bne	r2,zero,8220700 <getPHYSpeed+0x374>
 82206c8:	e0bff703 	ldbu	r2,-36(fp)
 82206cc:	10800060 	cmpeqi	r2,r2,1
 82206d0:	1000081e 	bne	r2,zero,82206f4 <getPHYSpeed+0x368>
 82206d4:	e0bff703 	ldbu	r2,-36(fp)
 82206d8:	1000031e 	bne	r2,zero,82206e8 <getPHYSpeed+0x35c>
 82206dc:	00820974 	movhi	r2,2085
 82206e0:	10b80804 	addi	r2,r2,-8160
 82206e4:	00000806 	br	8220708 <getPHYSpeed+0x37c>
 82206e8:	00820974 	movhi	r2,2085
 82206ec:	10b80904 	addi	r2,r2,-8156
 82206f0:	00000506 	br	8220708 <getPHYSpeed+0x37c>
 82206f4:	00820974 	movhi	r2,2085
 82206f8:	10b80b04 	addi	r2,r2,-8148
 82206fc:	00000206 	br	8220708 <getPHYSpeed+0x37c>
 8220700:	00820974 	movhi	r2,2085
 8220704:	10b80c04 	addi	r2,r2,-8144
 8220708:	e0fff743 	ldbu	r3,-35(fp)
 822070c:	18c00058 	cmpnei	r3,r3,1
 8220710:	1800031e 	bne	r3,zero,8220720 <getPHYSpeed+0x394>
 8220714:	00c20974 	movhi	r3,2085
 8220718:	18f80e04 	addi	r3,r3,-8136
 822071c:	00000206 	br	8220728 <getPHYSpeed+0x39c>
 8220720:	00c20974 	movhi	r3,2085
 8220724:	18f81004 	addi	r3,r3,-8128
 8220728:	180f883a 	mov	r7,r3
 822072c:	100d883a 	mov	r6,r2
 8220730:	200b883a 	mov	r5,r4
 8220734:	01020974 	movhi	r4,2085
 8220738:	21384d04 	addi	r4,r4,-7884
 822073c:	82030ec0 	call	82030ec <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 8220740:	e0bff817 	ldw	r2,-32(fp)
 8220744:	0001ae06 	br	8220e00 <getPHYSpeed+0xa74>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220748:	e0bffb17 	ldw	r2,-20(fp)
 822074c:	10800117 	ldw	r2,4(r2)
 8220750:	10800217 	ldw	r2,8(r2)
 8220754:	10800017 	ldw	r2,0(r2)
 8220758:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 822075c:	e0bff917 	ldw	r2,-28(fp)
 8220760:	1000491e 	bne	r2,zero,8220888 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220764:	00800044 	movi	r2,1
 8220768:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 822076c:	00800044 	movi	r2,1
 8220770:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 8220774:	e0bff743 	ldbu	r2,-35(fp)
 8220778:	10c0004c 	andi	r3,r2,1
 822077c:	e0bff703 	ldbu	r2,-36(fp)
 8220780:	10800098 	cmpnei	r2,r2,2
 8220784:	1000021e 	bne	r2,zero,8220790 <getPHYSpeed+0x404>
 8220788:	00800084 	movi	r2,2
 822078c:	00000106 	br	8220794 <getPHYSpeed+0x408>
 8220790:	0005883a 	mov	r2,zero
 8220794:	1886b03a 	or	r3,r3,r2
 8220798:	e0bff703 	ldbu	r2,-36(fp)
 822079c:	10800058 	cmpnei	r2,r2,1
 82207a0:	1000021e 	bne	r2,zero,82207ac <getPHYSpeed+0x420>
 82207a4:	00800104 	movi	r2,4
 82207a8:	00000106 	br	82207b0 <getPHYSpeed+0x424>
 82207ac:	0005883a 	mov	r2,zero
 82207b0:	1886b03a 	or	r3,r3,r2
 82207b4:	e0bff703 	ldbu	r2,-36(fp)
 82207b8:	1000021e 	bne	r2,zero,82207c4 <getPHYSpeed+0x438>
 82207bc:	00800204 	movi	r2,8
 82207c0:	00000106 	br	82207c8 <getPHYSpeed+0x43c>
 82207c4:	0005883a 	mov	r2,zero
 82207c8:	1886b03a 	or	r3,r3,r2
 82207cc:	e0bff703 	ldbu	r2,-36(fp)
 82207d0:	108000d8 	cmpnei	r2,r2,3
 82207d4:	1000021e 	bne	r2,zero,82207e0 <getPHYSpeed+0x454>
 82207d8:	00800074 	movhi	r2,1
 82207dc:	00000106 	br	82207e4 <getPHYSpeed+0x458>
 82207e0:	0005883a 	mov	r2,zero
 82207e4:	1884b03a 	or	r2,r3,r2
 82207e8:	10800834 	orhi	r2,r2,32
 82207ec:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82207f0:	e13ffd47 	ldb	r4,-11(fp)
 82207f4:	e17ffd07 	ldb	r5,-12(fp)
 82207f8:	e0bff703 	ldbu	r2,-36(fp)
 82207fc:	108000a0 	cmpeqi	r2,r2,2
 8220800:	10000e1e 	bne	r2,zero,822083c <getPHYSpeed+0x4b0>
 8220804:	e0bff703 	ldbu	r2,-36(fp)
 8220808:	10800060 	cmpeqi	r2,r2,1
 822080c:	1000081e 	bne	r2,zero,8220830 <getPHYSpeed+0x4a4>
 8220810:	e0bff703 	ldbu	r2,-36(fp)
 8220814:	1000031e 	bne	r2,zero,8220824 <getPHYSpeed+0x498>
 8220818:	00820974 	movhi	r2,2085
 822081c:	10b80804 	addi	r2,r2,-8160
 8220820:	00000806 	br	8220844 <getPHYSpeed+0x4b8>
 8220824:	00820974 	movhi	r2,2085
 8220828:	10b80904 	addi	r2,r2,-8156
 822082c:	00000506 	br	8220844 <getPHYSpeed+0x4b8>
 8220830:	00820974 	movhi	r2,2085
 8220834:	10b80b04 	addi	r2,r2,-8148
 8220838:	00000206 	br	8220844 <getPHYSpeed+0x4b8>
 822083c:	00820974 	movhi	r2,2085
 8220840:	10b80c04 	addi	r2,r2,-8144
 8220844:	e0fff743 	ldbu	r3,-35(fp)
 8220848:	18c00058 	cmpnei	r3,r3,1
 822084c:	1800031e 	bne	r3,zero,822085c <getPHYSpeed+0x4d0>
 8220850:	00c20974 	movhi	r3,2085
 8220854:	18f80e04 	addi	r3,r3,-8136
 8220858:	00000206 	br	8220864 <getPHYSpeed+0x4d8>
 822085c:	00c20974 	movhi	r3,2085
 8220860:	18f81004 	addi	r3,r3,-8128
 8220864:	d8c00015 	stw	r3,0(sp)
 8220868:	100f883a 	mov	r7,r2
 822086c:	280d883a 	mov	r6,r5
 8220870:	200b883a 	mov	r5,r4
 8220874:	01020974 	movhi	r4,2085
 8220878:	21385f04 	addi	r4,r4,-7812
 822087c:	82030ec0 	call	82030ec <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 8220880:	e0bff817 	ldw	r2,-32(fp)
 8220884:	00015e06 	br	8220e00 <getPHYSpeed+0xa74>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8220888:	e0bffa17 	ldw	r2,-24(fp)
 822088c:	10800003 	ldbu	r2,0(r2)
 8220890:	10803fcc 	andi	r2,r2,255
 8220894:	10800058 	cmpnei	r2,r2,1
 8220898:	1000081e 	bne	r2,zero,82208bc <getPHYSpeed+0x530>
			alt_tse_phy_set_adv_1000(pphy, 0);
 822089c:	000b883a 	mov	r5,zero
 82208a0:	e13ff917 	ldw	r4,-28(fp)
 82208a4:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 82208a8:	01400134 	movhi	r5,4
 82208ac:	29742404 	addi	r5,r5,-12144
 82208b0:	e13ff917 	ldw	r4,-28(fp)
 82208b4:	82224a40 	call	82224a4 <alt_tse_phy_restart_an>
 82208b8:	00000f06 	br	82208f8 <getPHYSpeed+0x56c>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 82208bc:	e0bffa17 	ldw	r2,-24(fp)
 82208c0:	10800003 	ldbu	r2,0(r2)
 82208c4:	10803fcc 	andi	r2,r2,255
 82208c8:	10800098 	cmpnei	r2,r2,2
 82208cc:	10000a1e 	bne	r2,zero,82208f8 <getPHYSpeed+0x56c>
			alt_tse_phy_set_adv_100(pphy, 0);
 82208d0:	000b883a 	mov	r5,zero
 82208d4:	e13ff917 	ldw	r4,-28(fp)
 82208d8:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 82208dc:	000b883a 	mov	r5,zero
 82208e0:	e13ff917 	ldw	r4,-28(fp)
 82208e4:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 82208e8:	01400134 	movhi	r5,4
 82208ec:	29742404 	addi	r5,r5,-12144
 82208f0:	e13ff917 	ldw	r4,-28(fp)
 82208f4:	82224a40 	call	82224a4 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 82208f8:	01400134 	movhi	r5,4
 82208fc:	29742404 	addi	r5,r5,-12144
 8220900:	e13ff917 	ldw	r4,-28(fp)
 8220904:	82226600 	call	8222660 <alt_tse_phy_check_link>
 8220908:	10bfffd8 	cmpnei	r2,r2,-1
 822090c:	1000491e 	bne	r2,zero,8220a34 <getPHYSpeed+0x6a8>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220910:	00800044 	movi	r2,1
 8220914:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220918:	00800044 	movi	r2,1
 822091c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 8220920:	e0bff743 	ldbu	r2,-35(fp)
 8220924:	10c0004c 	andi	r3,r2,1
 8220928:	e0bff703 	ldbu	r2,-36(fp)
 822092c:	10800098 	cmpnei	r2,r2,2
 8220930:	1000021e 	bne	r2,zero,822093c <getPHYSpeed+0x5b0>
 8220934:	00800084 	movi	r2,2
 8220938:	00000106 	br	8220940 <getPHYSpeed+0x5b4>
 822093c:	0005883a 	mov	r2,zero
 8220940:	1886b03a 	or	r3,r3,r2
 8220944:	e0bff703 	ldbu	r2,-36(fp)
 8220948:	10800058 	cmpnei	r2,r2,1
 822094c:	1000021e 	bne	r2,zero,8220958 <getPHYSpeed+0x5cc>
 8220950:	00800104 	movi	r2,4
 8220954:	00000106 	br	822095c <getPHYSpeed+0x5d0>
 8220958:	0005883a 	mov	r2,zero
 822095c:	1886b03a 	or	r3,r3,r2
 8220960:	e0bff703 	ldbu	r2,-36(fp)
 8220964:	1000021e 	bne	r2,zero,8220970 <getPHYSpeed+0x5e4>
 8220968:	00800204 	movi	r2,8
 822096c:	00000106 	br	8220974 <getPHYSpeed+0x5e8>
 8220970:	0005883a 	mov	r2,zero
 8220974:	1886b03a 	or	r3,r3,r2
 8220978:	e0bff703 	ldbu	r2,-36(fp)
 822097c:	108000d8 	cmpnei	r2,r2,3
 8220980:	1000021e 	bne	r2,zero,822098c <getPHYSpeed+0x600>
 8220984:	00800074 	movhi	r2,1
 8220988:	00000106 	br	8220990 <getPHYSpeed+0x604>
 822098c:	0005883a 	mov	r2,zero
 8220990:	1884b03a 	or	r2,r3,r2
 8220994:	10800234 	orhi	r2,r2,8
 8220998:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 822099c:	e13ffd47 	ldb	r4,-11(fp)
 82209a0:	e17ffd07 	ldb	r5,-12(fp)
 82209a4:	e0bff703 	ldbu	r2,-36(fp)
 82209a8:	108000a0 	cmpeqi	r2,r2,2
 82209ac:	10000e1e 	bne	r2,zero,82209e8 <getPHYSpeed+0x65c>
 82209b0:	e0bff703 	ldbu	r2,-36(fp)
 82209b4:	10800060 	cmpeqi	r2,r2,1
 82209b8:	1000081e 	bne	r2,zero,82209dc <getPHYSpeed+0x650>
 82209bc:	e0bff703 	ldbu	r2,-36(fp)
 82209c0:	1000031e 	bne	r2,zero,82209d0 <getPHYSpeed+0x644>
 82209c4:	00820974 	movhi	r2,2085
 82209c8:	10b80804 	addi	r2,r2,-8160
 82209cc:	00000806 	br	82209f0 <getPHYSpeed+0x664>
 82209d0:	00820974 	movhi	r2,2085
 82209d4:	10b80904 	addi	r2,r2,-8156
 82209d8:	00000506 	br	82209f0 <getPHYSpeed+0x664>
 82209dc:	00820974 	movhi	r2,2085
 82209e0:	10b80b04 	addi	r2,r2,-8148
 82209e4:	00000206 	br	82209f0 <getPHYSpeed+0x664>
 82209e8:	00820974 	movhi	r2,2085
 82209ec:	10b80c04 	addi	r2,r2,-8144
 82209f0:	e0fff743 	ldbu	r3,-35(fp)
 82209f4:	18c00058 	cmpnei	r3,r3,1
 82209f8:	1800031e 	bne	r3,zero,8220a08 <getPHYSpeed+0x67c>
 82209fc:	00c20974 	movhi	r3,2085
 8220a00:	18f80e04 	addi	r3,r3,-8136
 8220a04:	00000206 	br	8220a10 <getPHYSpeed+0x684>
 8220a08:	00c20974 	movhi	r3,2085
 8220a0c:	18f81004 	addi	r3,r3,-8128
 8220a10:	d8c00015 	stw	r3,0(sp)
 8220a14:	100f883a 	mov	r7,r2
 8220a18:	280d883a 	mov	r6,r5
 8220a1c:	200b883a 	mov	r5,r4
 8220a20:	01020974 	movhi	r4,2085
 8220a24:	21387004 	addi	r4,r4,-7744
 8220a28:	82030ec0 	call	82030ec <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 8220a2c:	e0bff817 	ldw	r2,-32(fp)
 8220a30:	0000f306 	br	8220e00 <getPHYSpeed+0xa74>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 8220a34:	e0bffe17 	ldw	r2,-8(fp)
 8220a38:	10801004 	addi	r2,r2,64
 8220a3c:	e0fff917 	ldw	r3,-28(fp)
 8220a40:	18c00003 	ldbu	r3,0(r3)
 8220a44:	18c03fcc 	andi	r3,r3,255
 8220a48:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8220a4c:	d8000015 	stw	zero,0(sp)
 8220a50:	01c00044 	movi	r7,1
 8220a54:	01800384 	movi	r6,14
 8220a58:	000b883a 	mov	r5,zero
 8220a5c:	e13ff917 	ldw	r4,-28(fp)
 8220a60:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 8220a64:	e0bff917 	ldw	r2,-28(fp)
 8220a68:	10800517 	ldw	r2,20(r2)
 8220a6c:	10002b1e 	bne	r2,zero,8220b1c <getPHYSpeed+0x790>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 8220a70:	e0bffd47 	ldb	r2,-11(fp)
 8220a74:	e0fffd07 	ldb	r3,-12(fp)
 8220a78:	180d883a 	mov	r6,r3
 8220a7c:	100b883a 	mov	r5,r2
 8220a80:	01020974 	movhi	r4,2085
 8220a84:	21388404 	addi	r4,r4,-7664
 8220a88:	82030ec0 	call	82030ec <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220a8c:	00800044 	movi	r2,1
 8220a90:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220a94:	00800044 	movi	r2,1
 8220a98:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 8220a9c:	e0bff743 	ldbu	r2,-35(fp)
 8220aa0:	10c0004c 	andi	r3,r2,1
 8220aa4:	e0bff703 	ldbu	r2,-36(fp)
 8220aa8:	10800098 	cmpnei	r2,r2,2
 8220aac:	1000021e 	bne	r2,zero,8220ab8 <getPHYSpeed+0x72c>
 8220ab0:	00800084 	movi	r2,2
 8220ab4:	00000106 	br	8220abc <getPHYSpeed+0x730>
 8220ab8:	0005883a 	mov	r2,zero
 8220abc:	1886b03a 	or	r3,r3,r2
 8220ac0:	e0bff703 	ldbu	r2,-36(fp)
 8220ac4:	10800058 	cmpnei	r2,r2,1
 8220ac8:	1000021e 	bne	r2,zero,8220ad4 <getPHYSpeed+0x748>
 8220acc:	00800104 	movi	r2,4
 8220ad0:	00000106 	br	8220ad8 <getPHYSpeed+0x74c>
 8220ad4:	0005883a 	mov	r2,zero
 8220ad8:	1886b03a 	or	r3,r3,r2
 8220adc:	e0bff703 	ldbu	r2,-36(fp)
 8220ae0:	1000021e 	bne	r2,zero,8220aec <getPHYSpeed+0x760>
 8220ae4:	00800204 	movi	r2,8
 8220ae8:	00000106 	br	8220af0 <getPHYSpeed+0x764>
 8220aec:	0005883a 	mov	r2,zero
 8220af0:	1886b03a 	or	r3,r3,r2
 8220af4:	e0bff703 	ldbu	r2,-36(fp)
 8220af8:	108000d8 	cmpnei	r2,r2,3
 8220afc:	1000021e 	bne	r2,zero,8220b08 <getPHYSpeed+0x77c>
 8220b00:	00800074 	movhi	r2,1
 8220b04:	00000106 	br	8220b0c <getPHYSpeed+0x780>
 8220b08:	0005883a 	mov	r2,zero
 8220b0c:	1884b03a 	or	r2,r3,r2
 8220b10:	10800134 	orhi	r2,r2,4
 8220b14:	e0bff815 	stw	r2,-32(fp)
 8220b18:	00009406 	br	8220d6c <getPHYSpeed+0x9e0>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 8220b1c:	e0bff917 	ldw	r2,-28(fp)
 8220b20:	10800517 	ldw	r2,20(r2)
 8220b24:	10801817 	ldw	r2,96(r2)
 8220b28:	10002626 	beq	r2,zero,8220bc4 <getPHYSpeed+0x838>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 8220b2c:	e0bff917 	ldw	r2,-28(fp)
 8220b30:	10800517 	ldw	r2,20(r2)
 8220b34:	10801817 	ldw	r2,96(r2)
 8220b38:	e13ffe17 	ldw	r4,-8(fp)
 8220b3c:	103ee83a 	callr	r2
 8220b40:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220b44:	e0bff817 	ldw	r2,-32(fp)
 8220b48:	1080008c 	andi	r2,r2,2
 8220b4c:	10000c1e 	bne	r2,zero,8220b80 <getPHYSpeed+0x7f4>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 8220b50:	e0bff817 	ldw	r2,-32(fp)
 8220b54:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220b58:	1000071e 	bne	r2,zero,8220b78 <getPHYSpeed+0x7ec>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 8220b5c:	e0bff817 	ldw	r2,-32(fp)
 8220b60:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220b64:	10000226 	beq	r2,zero,8220b70 <getPHYSpeed+0x7e4>
 8220b68:	0005883a 	mov	r2,zero
 8220b6c:	00000506 	br	8220b84 <getPHYSpeed+0x7f8>
 8220b70:	008000c4 	movi	r2,3
 8220b74:	00000306 	br	8220b84 <getPHYSpeed+0x7f8>
 8220b78:	00800044 	movi	r2,1
 8220b7c:	00000106 	br	8220b84 <getPHYSpeed+0x7f8>
 8220b80:	00800084 	movi	r2,2
 8220b84:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 8220b88:	e0bff817 	ldw	r2,-32(fp)
 8220b8c:	1080004c 	andi	r2,r2,1
 8220b90:	1004c03a 	cmpne	r2,r2,zero
 8220b94:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 8220b98:	e0bff817 	ldw	r2,-32(fp)
 8220b9c:	1080006c 	andhi	r2,r2,1
 8220ba0:	10007226 	beq	r2,zero,8220d6c <getPHYSpeed+0x9e0>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 8220ba4:	e0bffd47 	ldb	r2,-11(fp)
 8220ba8:	e0fffd07 	ldb	r3,-12(fp)
 8220bac:	180d883a 	mov	r6,r3
 8220bb0:	100b883a 	mov	r5,r2
 8220bb4:	01020974 	movhi	r4,2085
 8220bb8:	21389204 	addi	r4,r4,-7608
 8220bbc:	82030ec0 	call	82030ec <printf>
 8220bc0:	00006a06 	br	8220d6c <getPHYSpeed+0x9e0>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 8220bc4:	e0bff917 	ldw	r2,-28(fp)
 8220bc8:	10800517 	ldw	r2,20(r2)
 8220bcc:	10801583 	ldbu	r2,86(r2)
 8220bd0:	10803fcc 	andi	r2,r2,255
 8220bd4:	10002b1e 	bne	r2,zero,8220c84 <getPHYSpeed+0x8f8>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 8220bd8:	e0bffd47 	ldb	r2,-11(fp)
 8220bdc:	e0fffd07 	ldb	r3,-12(fp)
 8220be0:	180d883a 	mov	r6,r3
 8220be4:	100b883a 	mov	r5,r2
 8220be8:	01020974 	movhi	r4,2085
 8220bec:	21389f04 	addi	r4,r4,-7556
 8220bf0:	82030ec0 	call	82030ec <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220bf4:	00800044 	movi	r2,1
 8220bf8:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220bfc:	00800044 	movi	r2,1
 8220c00:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 8220c04:	e0bff743 	ldbu	r2,-35(fp)
 8220c08:	10c0004c 	andi	r3,r2,1
 8220c0c:	e0bff703 	ldbu	r2,-36(fp)
 8220c10:	10800098 	cmpnei	r2,r2,2
 8220c14:	1000021e 	bne	r2,zero,8220c20 <getPHYSpeed+0x894>
 8220c18:	00800084 	movi	r2,2
 8220c1c:	00000106 	br	8220c24 <getPHYSpeed+0x898>
 8220c20:	0005883a 	mov	r2,zero
 8220c24:	1886b03a 	or	r3,r3,r2
 8220c28:	e0bff703 	ldbu	r2,-36(fp)
 8220c2c:	10800058 	cmpnei	r2,r2,1
 8220c30:	1000021e 	bne	r2,zero,8220c3c <getPHYSpeed+0x8b0>
 8220c34:	00800104 	movi	r2,4
 8220c38:	00000106 	br	8220c40 <getPHYSpeed+0x8b4>
 8220c3c:	0005883a 	mov	r2,zero
 8220c40:	1886b03a 	or	r3,r3,r2
 8220c44:	e0bff703 	ldbu	r2,-36(fp)
 8220c48:	1000021e 	bne	r2,zero,8220c54 <getPHYSpeed+0x8c8>
 8220c4c:	00800204 	movi	r2,8
 8220c50:	00000106 	br	8220c58 <getPHYSpeed+0x8cc>
 8220c54:	0005883a 	mov	r2,zero
 8220c58:	1886b03a 	or	r3,r3,r2
 8220c5c:	e0bff703 	ldbu	r2,-36(fp)
 8220c60:	108000d8 	cmpnei	r2,r2,3
 8220c64:	1000021e 	bne	r2,zero,8220c70 <getPHYSpeed+0x8e4>
 8220c68:	00800074 	movhi	r2,1
 8220c6c:	00000106 	br	8220c74 <getPHYSpeed+0x8e8>
 8220c70:	0005883a 	mov	r2,zero
 8220c74:	1884b03a 	or	r2,r3,r2
 8220c78:	108000b4 	orhi	r2,r2,2
 8220c7c:	e0bff815 	stw	r2,-32(fp)
 8220c80:	00003a06 	br	8220d6c <getPHYSpeed+0x9e0>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8220c84:	e0bff917 	ldw	r2,-28(fp)
 8220c88:	10800517 	ldw	r2,20(r2)
 8220c8c:	10801583 	ldbu	r2,86(r2)
 8220c90:	10c03fcc 	andi	r3,r2,255
 8220c94:	e0bff917 	ldw	r2,-28(fp)
 8220c98:	10800517 	ldw	r2,20(r2)
 8220c9c:	108015c3 	ldbu	r2,87(r2)
 8220ca0:	10803fcc 	andi	r2,r2,255
 8220ca4:	01c00084 	movi	r7,2
 8220ca8:	100d883a 	mov	r6,r2
 8220cac:	180b883a 	mov	r5,r3
 8220cb0:	e13ff917 	ldw	r4,-28(fp)
 8220cb4:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8220cb8:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8220cbc:	e0bff917 	ldw	r2,-28(fp)
 8220cc0:	10800517 	ldw	r2,20(r2)
 8220cc4:	10801583 	ldbu	r2,86(r2)
 8220cc8:	10c03fcc 	andi	r3,r2,255
 8220ccc:	e0bff917 	ldw	r2,-28(fp)
 8220cd0:	10800517 	ldw	r2,20(r2)
 8220cd4:	10801603 	ldbu	r2,88(r2)
 8220cd8:	10803fcc 	andi	r2,r2,255
 8220cdc:	01c00044 	movi	r7,1
 8220ce0:	100d883a 	mov	r6,r2
 8220ce4:	180b883a 	mov	r5,r3
 8220ce8:	e13ff917 	ldw	r4,-28(fp)
 8220cec:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8220cf0:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8220cf4:	e0bff743 	ldbu	r2,-35(fp)
 8220cf8:	10c0004c 	andi	r3,r2,1
 8220cfc:	e0bff703 	ldbu	r2,-36(fp)
 8220d00:	10800098 	cmpnei	r2,r2,2
 8220d04:	1000021e 	bne	r2,zero,8220d10 <getPHYSpeed+0x984>
 8220d08:	00800084 	movi	r2,2
 8220d0c:	00000106 	br	8220d14 <getPHYSpeed+0x988>
 8220d10:	0005883a 	mov	r2,zero
 8220d14:	1886b03a 	or	r3,r3,r2
 8220d18:	e0bff703 	ldbu	r2,-36(fp)
 8220d1c:	10800058 	cmpnei	r2,r2,1
 8220d20:	1000021e 	bne	r2,zero,8220d2c <getPHYSpeed+0x9a0>
 8220d24:	00800104 	movi	r2,4
 8220d28:	00000106 	br	8220d30 <getPHYSpeed+0x9a4>
 8220d2c:	0005883a 	mov	r2,zero
 8220d30:	1886b03a 	or	r3,r3,r2
 8220d34:	e0bff703 	ldbu	r2,-36(fp)
 8220d38:	1000021e 	bne	r2,zero,8220d44 <getPHYSpeed+0x9b8>
 8220d3c:	00800204 	movi	r2,8
 8220d40:	00000106 	br	8220d48 <getPHYSpeed+0x9bc>
 8220d44:	0005883a 	mov	r2,zero
 8220d48:	1886b03a 	or	r3,r3,r2
 8220d4c:	e0bff703 	ldbu	r2,-36(fp)
 8220d50:	108000d8 	cmpnei	r2,r2,3
 8220d54:	1000021e 	bne	r2,zero,8220d60 <getPHYSpeed+0x9d4>
 8220d58:	00800074 	movhi	r2,1
 8220d5c:	00000106 	br	8220d64 <getPHYSpeed+0x9d8>
 8220d60:	0005883a 	mov	r2,zero
 8220d64:	1884b03a 	or	r2,r3,r2
 8220d68:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220d6c:	e13ffd47 	ldb	r4,-11(fp)
 8220d70:	e17ffd07 	ldb	r5,-12(fp)
 8220d74:	e0bff703 	ldbu	r2,-36(fp)
 8220d78:	108000a0 	cmpeqi	r2,r2,2
 8220d7c:	10000e1e 	bne	r2,zero,8220db8 <getPHYSpeed+0xa2c>
 8220d80:	e0bff703 	ldbu	r2,-36(fp)
 8220d84:	10800060 	cmpeqi	r2,r2,1
 8220d88:	1000081e 	bne	r2,zero,8220dac <getPHYSpeed+0xa20>
 8220d8c:	e0bff703 	ldbu	r2,-36(fp)
 8220d90:	1000031e 	bne	r2,zero,8220da0 <getPHYSpeed+0xa14>
 8220d94:	00820974 	movhi	r2,2085
 8220d98:	10b80804 	addi	r2,r2,-8160
 8220d9c:	00000806 	br	8220dc0 <getPHYSpeed+0xa34>
 8220da0:	00820974 	movhi	r2,2085
 8220da4:	10b80904 	addi	r2,r2,-8156
 8220da8:	00000506 	br	8220dc0 <getPHYSpeed+0xa34>
 8220dac:	00820974 	movhi	r2,2085
 8220db0:	10b80b04 	addi	r2,r2,-8148
 8220db4:	00000206 	br	8220dc0 <getPHYSpeed+0xa34>
 8220db8:	00820974 	movhi	r2,2085
 8220dbc:	10b80c04 	addi	r2,r2,-8144
 8220dc0:	e0fff743 	ldbu	r3,-35(fp)
 8220dc4:	18c00058 	cmpnei	r3,r3,1
 8220dc8:	1800031e 	bne	r3,zero,8220dd8 <getPHYSpeed+0xa4c>
 8220dcc:	00c20974 	movhi	r3,2085
 8220dd0:	18f80e04 	addi	r3,r3,-8136
 8220dd4:	00000206 	br	8220de0 <getPHYSpeed+0xa54>
 8220dd8:	00c20974 	movhi	r3,2085
 8220ddc:	18f81004 	addi	r3,r3,-8128
 8220de0:	d8c00015 	stw	r3,0(sp)
 8220de4:	100f883a 	mov	r7,r2
 8220de8:	280d883a 	mov	r6,r5
 8220dec:	200b883a 	mov	r5,r4
 8220df0:	01020974 	movhi	r4,2085
 8220df4:	2138b604 	addi	r4,r4,-7464
 8220df8:	82030ec0 	call	82030ec <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 8220dfc:	e0bff817 	ldw	r2,-32(fp)
}
 8220e00:	e037883a 	mov	sp,fp
 8220e04:	dfc00117 	ldw	ra,4(sp)
 8220e08:	df000017 	ldw	fp,0(sp)
 8220e0c:	dec00204 	addi	sp,sp,8
 8220e10:	f800283a 	ret

08220e14 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 8220e14:	defffd04 	addi	sp,sp,-12
 8220e18:	df000215 	stw	fp,8(sp)
 8220e1c:	df000204 	addi	fp,sp,8
 8220e20:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220e24:	e0bfff17 	ldw	r2,-4(fp)
 8220e28:	10800617 	ldw	r2,24(r2)
 8220e2c:	10800317 	ldw	r2,12(r2)
 8220e30:	10800117 	ldw	r2,4(r2)
 8220e34:	10800217 	ldw	r2,8(r2)
 8220e38:	10800017 	ldw	r2,0(r2)
 8220e3c:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8220e40:	e0bffe17 	ldw	r2,-8(fp)
 8220e44:	10801004 	addi	r2,r2,64
 8220e48:	10800037 	ldwio	r2,0(r2)
}
 8220e4c:	e037883a 	mov	sp,fp
 8220e50:	df000017 	ldw	fp,0(sp)
 8220e54:	dec00104 	addi	sp,sp,4
 8220e58:	f800283a 	ret

08220e5c <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 8220e5c:	defffc04 	addi	sp,sp,-16
 8220e60:	df000315 	stw	fp,12(sp)
 8220e64:	df000304 	addi	fp,sp,12
 8220e68:	e13ffe15 	stw	r4,-8(fp)
 8220e6c:	2805883a 	mov	r2,r5
 8220e70:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220e74:	e0bffe17 	ldw	r2,-8(fp)
 8220e78:	10800617 	ldw	r2,24(r2)
 8220e7c:	10800317 	ldw	r2,12(r2)
 8220e80:	10800117 	ldw	r2,4(r2)
 8220e84:	10800217 	ldw	r2,8(r2)
 8220e88:	10800017 	ldw	r2,0(r2)
 8220e8c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 8220e90:	e0bffd17 	ldw	r2,-12(fp)
 8220e94:	10801004 	addi	r2,r2,64
 8220e98:	e0ffff03 	ldbu	r3,-4(fp)
 8220e9c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 8220ea0:	0005883a 	mov	r2,zero
}
 8220ea4:	e037883a 	mov	sp,fp
 8220ea8:	df000017 	ldw	fp,0(sp)
 8220eac:	dec00104 	addi	sp,sp,4
 8220eb0:	f800283a 	ret

08220eb4 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 8220eb4:	defff604 	addi	sp,sp,-40
 8220eb8:	df000915 	stw	fp,36(sp)
 8220ebc:	df000904 	addi	fp,sp,36
 8220ec0:	e13ffb15 	stw	r4,-20(fp)
 8220ec4:	3009883a 	mov	r4,r6
 8220ec8:	3807883a 	mov	r3,r7
 8220ecc:	e0800117 	ldw	r2,4(fp)
 8220ed0:	e17ffc05 	stb	r5,-16(fp)
 8220ed4:	e13ffd05 	stb	r4,-12(fp)
 8220ed8:	e0fffe05 	stb	r3,-8(fp)
 8220edc:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220ee0:	e0bffb17 	ldw	r2,-20(fp)
 8220ee4:	10800617 	ldw	r2,24(r2)
 8220ee8:	10800317 	ldw	r2,12(r2)
 8220eec:	10800117 	ldw	r2,4(r2)
 8220ef0:	10800217 	ldw	r2,8(r2)
 8220ef4:	10800017 	ldw	r2,0(r2)
 8220ef8:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 8220efc:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8220f00:	e03ff815 	stw	zero,-32(fp)
 8220f04:	00000906 	br	8220f2c <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 8220f08:	e0bff70b 	ldhu	r2,-36(fp)
 8220f0c:	1085883a 	add	r2,r2,r2
 8220f10:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 8220f14:	e0bff70b 	ldhu	r2,-36(fp)
 8220f18:	10800054 	ori	r2,r2,1
 8220f1c:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8220f20:	e0bff817 	ldw	r2,-32(fp)
 8220f24:	10800044 	addi	r2,r2,1
 8220f28:	e0bff815 	stw	r2,-32(fp)
 8220f2c:	e0bffe03 	ldbu	r2,-8(fp)
 8220f30:	e0fff817 	ldw	r3,-32(fp)
 8220f34:	18bff416 	blt	r3,r2,8220f08 <alt_tse_phy_wr_mdio_reg+0x54>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 8220f38:	e0fff70b 	ldhu	r3,-36(fp)
 8220f3c:	e0bffd03 	ldbu	r2,-12(fp)
 8220f40:	1884983a 	sll	r2,r3,r2
 8220f44:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 8220f48:	e0bff917 	ldw	r2,-28(fp)
 8220f4c:	10c0a004 	addi	r3,r2,640
 8220f50:	e0bffc03 	ldbu	r2,-16(fp)
 8220f54:	1085883a 	add	r2,r2,r2
 8220f58:	1085883a 	add	r2,r2,r2
 8220f5c:	1885883a 	add	r2,r3,r2
 8220f60:	10800037 	ldwio	r2,0(r2)
 8220f64:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 8220f68:	e0bff70b 	ldhu	r2,-36(fp)
 8220f6c:	0084303a 	nor	r2,zero,r2
 8220f70:	1007883a 	mov	r3,r2
 8220f74:	e0bffa0b 	ldhu	r2,-24(fp)
 8220f78:	1884703a 	and	r2,r3,r2
 8220f7c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 8220f80:	e0ffff0b 	ldhu	r3,-4(fp)
 8220f84:	e0bffd03 	ldbu	r2,-12(fp)
 8220f88:	1884983a 	sll	r2,r3,r2
 8220f8c:	1007883a 	mov	r3,r2
 8220f90:	e0bff70b 	ldhu	r2,-36(fp)
 8220f94:	1884703a 	and	r2,r3,r2
 8220f98:	1007883a 	mov	r3,r2
 8220f9c:	e0bffa0b 	ldhu	r2,-24(fp)
 8220fa0:	1884b03a 	or	r2,r3,r2
 8220fa4:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 8220fa8:	e0bff917 	ldw	r2,-28(fp)
 8220fac:	10c0a004 	addi	r3,r2,640
 8220fb0:	e0bffc03 	ldbu	r2,-16(fp)
 8220fb4:	1085883a 	add	r2,r2,r2
 8220fb8:	1085883a 	add	r2,r2,r2
 8220fbc:	1885883a 	add	r2,r3,r2
 8220fc0:	e0fffa0b 	ldhu	r3,-24(fp)
 8220fc4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 8220fc8:	0005883a 	mov	r2,zero
    
}
 8220fcc:	e037883a 	mov	sp,fp
 8220fd0:	df000017 	ldw	fp,0(sp)
 8220fd4:	dec00104 	addi	sp,sp,4
 8220fd8:	f800283a 	ret

08220fdc <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 8220fdc:	defff704 	addi	sp,sp,-36
 8220fe0:	df000815 	stw	fp,32(sp)
 8220fe4:	df000804 	addi	fp,sp,32
 8220fe8:	e13ffc15 	stw	r4,-16(fp)
 8220fec:	2809883a 	mov	r4,r5
 8220ff0:	3007883a 	mov	r3,r6
 8220ff4:	3805883a 	mov	r2,r7
 8220ff8:	e13ffd05 	stb	r4,-12(fp)
 8220ffc:	e0fffe05 	stb	r3,-8(fp)
 8221000:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221004:	e0bffc17 	ldw	r2,-16(fp)
 8221008:	10800617 	ldw	r2,24(r2)
 822100c:	10800317 	ldw	r2,12(r2)
 8221010:	10800117 	ldw	r2,4(r2)
 8221014:	10800217 	ldw	r2,8(r2)
 8221018:	10800017 	ldw	r2,0(r2)
 822101c:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 8221020:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221024:	e03ff915 	stw	zero,-28(fp)
 8221028:	00000906 	br	8221050 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 822102c:	e0bff817 	ldw	r2,-32(fp)
 8221030:	1085883a 	add	r2,r2,r2
 8221034:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 8221038:	e0bff817 	ldw	r2,-32(fp)
 822103c:	10800054 	ori	r2,r2,1
 8221040:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221044:	e0bff917 	ldw	r2,-28(fp)
 8221048:	10800044 	addi	r2,r2,1
 822104c:	e0bff915 	stw	r2,-28(fp)
 8221050:	e0bfff03 	ldbu	r2,-4(fp)
 8221054:	e0fff917 	ldw	r3,-28(fp)
 8221058:	18bff416 	blt	r3,r2,822102c <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 822105c:	e0bffa17 	ldw	r2,-24(fp)
 8221060:	10c0a004 	addi	r3,r2,640
 8221064:	e0bffd03 	ldbu	r2,-12(fp)
 8221068:	1085883a 	add	r2,r2,r2
 822106c:	1085883a 	add	r2,r2,r2
 8221070:	1885883a 	add	r2,r3,r2
 8221074:	10800037 	ldwio	r2,0(r2)
 8221078:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 822107c:	e0fffb0b 	ldhu	r3,-20(fp)
 8221080:	e0bffe03 	ldbu	r2,-8(fp)
 8221084:	1885d83a 	sra	r2,r3,r2
 8221088:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 822108c:	e0fffb0b 	ldhu	r3,-20(fp)
 8221090:	e0bff817 	ldw	r2,-32(fp)
 8221094:	1884703a 	and	r2,r3,r2
}
 8221098:	e037883a 	mov	sp,fp
 822109c:	df000017 	ldw	fp,0(sp)
 82210a0:	dec00104 	addi	sp,sp,4
 82210a4:	f800283a 	ret

082210a8 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 82210a8:	deff9a04 	addi	sp,sp,-408
 82210ac:	dfc06515 	stw	ra,404(sp)
 82210b0:	df006415 	stw	fp,400(sp)
 82210b4:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 82210b8:	e0ff9c04 	addi	r3,fp,-400
 82210bc:	00801904 	movi	r2,100
 82210c0:	100d883a 	mov	r6,r2
 82210c4:	000b883a 	mov	r5,zero
 82210c8:	1809883a 	mov	r4,r3
 82210cc:	8202f000 	call	8202f00 <memset>
 82210d0:	009d9cb4 	movhi	r2,30322
 82210d4:	10985344 	addi	r2,r2,24909
 82210d8:	e0bf9c15 	stw	r2,-400(fp)
 82210dc:	00881b34 	movhi	r2,8300
 82210e0:	109b1944 	addi	r2,r2,27749
 82210e4:	e0bf9d15 	stw	r2,-396(fp)
 82210e8:	008c5174 	movhi	r2,12613
 82210ec:	108e0e04 	addi	r2,r2,14392
 82210f0:	e0bf9e15 	stw	r2,-392(fp)
 82210f4:	00800c74 	movhi	r2,49
 82210f8:	108c4c44 	addi	r2,r2,12593
 82210fc:	e0bf9f15 	stw	r2,-388(fp)
 8221100:	e0bfa004 	addi	r2,fp,-384
 8221104:	00c01004 	movi	r3,64
 8221108:	180d883a 	mov	r6,r3
 822110c:	000b883a 	mov	r5,zero
 8221110:	1009883a 	mov	r4,r2
 8221114:	8202f000 	call	8202f00 <memset>
 8221118:	009410c4 	movi	r2,20547
 822111c:	e0bfb015 	stw	r2,-320(fp)
 8221120:	00800304 	movi	r2,12
 8221124:	e0bfb105 	stb	r2,-316(fp)
 8221128:	00800084 	movi	r2,2
 822112c:	e0bfb145 	stb	r2,-315(fp)
 8221130:	00800444 	movi	r2,17
 8221134:	e0bfb185 	stb	r2,-314(fp)
 8221138:	00800384 	movi	r2,14
 822113c:	e0bfb1c5 	stb	r2,-313(fp)
 8221140:	00800344 	movi	r2,13
 8221144:	e0bfb205 	stb	r2,-312(fp)
 8221148:	00800284 	movi	r2,10
 822114c:	e0bfb245 	stb	r2,-311(fp)
 8221150:	008208b4 	movhi	r2,2082
 8221154:	108ebe04 	addi	r2,r2,15096
 8221158:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 822115c:	e0bfb504 	addi	r2,fp,-300
 8221160:	00c01904 	movi	r3,100
 8221164:	180d883a 	mov	r6,r3
 8221168:	000b883a 	mov	r5,zero
 822116c:	1009883a 	mov	r4,r2
 8221170:	8202f000 	call	8202f00 <memset>
 8221174:	009d9cb4 	movhi	r2,30322
 8221178:	10985344 	addi	r2,r2,24909
 822117c:	e0bfb515 	stw	r2,-300(fp)
 8221180:	00881b34 	movhi	r2,8300
 8221184:	109b1944 	addi	r2,r2,27749
 8221188:	e0bfb615 	stw	r2,-296(fp)
 822118c:	00991874 	movhi	r2,25697
 8221190:	109d5444 	addi	r2,r2,30033
 8221194:	e0bfb715 	stw	r2,-292(fp)
 8221198:	00965234 	movhi	r2,22856
 822119c:	10940804 	addi	r2,r2,20512
 82211a0:	e0bfb815 	stw	r2,-288(fp)
 82211a4:	00914e34 	movhi	r2,17720
 82211a8:	108e0804 	addi	r2,r2,14368
 82211ac:	e0bfb915 	stw	r2,-284(fp)
 82211b0:	008d4d34 	movhi	r2,13620
 82211b4:	108c4c44 	addi	r2,r2,12593
 82211b8:	e0bfba15 	stw	r2,-280(fp)
 82211bc:	e03fbb15 	stw	zero,-276(fp)
 82211c0:	e03fbc15 	stw	zero,-272(fp)
 82211c4:	e03fbd15 	stw	zero,-268(fp)
 82211c8:	e03fbe15 	stw	zero,-264(fp)
 82211cc:	e03fbf15 	stw	zero,-260(fp)
 82211d0:	e03fc015 	stw	zero,-256(fp)
 82211d4:	e03fc115 	stw	zero,-252(fp)
 82211d8:	e03fc215 	stw	zero,-248(fp)
 82211dc:	e03fc315 	stw	zero,-244(fp)
 82211e0:	e03fc415 	stw	zero,-240(fp)
 82211e4:	e03fc515 	stw	zero,-236(fp)
 82211e8:	e03fc615 	stw	zero,-232(fp)
 82211ec:	e03fc715 	stw	zero,-228(fp)
 82211f0:	e03fc815 	stw	zero,-224(fp)
 82211f4:	009410c4 	movi	r2,20547
 82211f8:	e0bfc915 	stw	r2,-220(fp)
 82211fc:	00800344 	movi	r2,13
 8221200:	e0bfca05 	stb	r2,-216(fp)
 8221204:	00800084 	movi	r2,2
 8221208:	e0bfca45 	stb	r2,-215(fp)
 822120c:	00800444 	movi	r2,17
 8221210:	e0bfca85 	stb	r2,-214(fp)
 8221214:	00800384 	movi	r2,14
 8221218:	e0bfcac5 	stb	r2,-213(fp)
 822121c:	00800344 	movi	r2,13
 8221220:	e0bfcb05 	stb	r2,-212(fp)
 8221224:	00800284 	movi	r2,10
 8221228:	e0bfcb45 	stb	r2,-211(fp)
 822122c:	008208b4 	movhi	r2,2082
 8221230:	108ebe04 	addi	r2,r2,15096
 8221234:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 8221238:	e0bfce04 	addi	r2,fp,-200
 822123c:	00c01904 	movi	r3,100
 8221240:	180d883a 	mov	r6,r3
 8221244:	000b883a 	mov	r5,zero
 8221248:	1009883a 	mov	r4,r2
 822124c:	8202f000 	call	8202f00 <memset>
 8221250:	009a5d34 	movhi	r2,26996
 8221254:	10985384 	addi	r2,r2,24910
 8221258:	e0bfce15 	stw	r2,-200(fp)
 822125c:	009b1874 	movhi	r2,27745
 8221260:	109b9bc4 	addi	r2,r2,28271
 8221264:	e0bfcf15 	stw	r2,-196(fp)
 8221268:	008e1434 	movhi	r2,14416
 822126c:	10910804 	addi	r2,r2,17440
 8221270:	e0bfd015 	stw	r2,-192(fp)
 8221274:	008d4db4 	movhi	r2,13622
 8221278:	108e0cc4 	addi	r2,r2,14387
 822127c:	e0bfd115 	stw	r2,-188(fp)
 8221280:	e03fd215 	stw	zero,-184(fp)
 8221284:	e0bfd304 	addi	r2,fp,-180
 8221288:	00c00f04 	movi	r3,60
 822128c:	180d883a 	mov	r6,r3
 8221290:	000b883a 	mov	r5,zero
 8221294:	1009883a 	mov	r4,r2
 8221298:	8202f000 	call	8202f00 <memset>
 822129c:	00800234 	movhi	r2,8
 82212a0:	108005c4 	addi	r2,r2,23
 82212a4:	e0bfe215 	stw	r2,-120(fp)
 82212a8:	008001c4 	movi	r2,7
 82212ac:	e0bfe305 	stb	r2,-116(fp)
 82212b0:	00800284 	movi	r2,10
 82212b4:	e0bfe345 	stb	r2,-115(fp)
 82212b8:	00800444 	movi	r2,17
 82212bc:	e0bfe385 	stb	r2,-114(fp)
 82212c0:	008000c4 	movi	r2,3
 82212c4:	e0bfe3c5 	stb	r2,-113(fp)
 82212c8:	00800044 	movi	r2,1
 82212cc:	e0bfe405 	stb	r2,-112(fp)
 82212d0:	00800084 	movi	r2,2
 82212d4:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 82212d8:	00820974 	movhi	r2,2085
 82212dc:	10b8c204 	addi	r2,r2,-7416
 82212e0:	e0ffe704 	addi	r3,fp,-100
 82212e4:	1009883a 	mov	r4,r2
 82212e8:	00801904 	movi	r2,100
 82212ec:	100d883a 	mov	r6,r2
 82212f0:	200b883a 	mov	r5,r4
 82212f4:	1809883a 	mov	r4,r3
 82212f8:	8202c5c0 	call	8202c5c <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 82212fc:	e13f9c04 	addi	r4,fp,-400
 8221300:	821f2180 	call	821f218 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 8221304:	e0bfb504 	addi	r2,fp,-300
 8221308:	1009883a 	mov	r4,r2
 822130c:	821f2180 	call	821f218 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 8221310:	e0bfce04 	addi	r2,fp,-200
 8221314:	1009883a 	mov	r4,r2
 8221318:	821f2180 	call	821f218 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 822131c:	e0bfe704 	addi	r2,fp,-100
 8221320:	1009883a 	mov	r4,r2
 8221324:	821f2180 	call	821f218 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 8221328:	d0a07f03 	ldbu	r2,-32260(gp)
 822132c:	10803fcc 	andi	r2,r2,255
}
 8221330:	e037883a 	mov	sp,fp
 8221334:	dfc00117 	ldw	ra,4(sp)
 8221338:	df000017 	ldw	fp,0(sp)
 822133c:	dec00204 	addi	sp,sp,8
 8221340:	f800283a 	ret

08221344 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 8221344:	defffd04 	addi	sp,sp,-12
 8221348:	dfc00215 	stw	ra,8(sp)
 822134c:	df000115 	stw	fp,4(sp)
 8221350:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 8221354:	d0a07f03 	ldbu	r2,-32260(gp)
 8221358:	10803fcc 	andi	r2,r2,255
 822135c:	100b883a 	mov	r5,r2
 8221360:	01020974 	movhi	r4,2085
 8221364:	2138db04 	addi	r4,r4,-7316
 8221368:	821eed00 	call	821eed0 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 822136c:	e03fff05 	stb	zero,-4(fp)
 8221370:	00006d06 	br	8221528 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 8221374:	e0bfff07 	ldb	r2,-4(fp)
 8221378:	100b883a 	mov	r5,r2
 822137c:	01020974 	movhi	r4,2085
 8221380:	2138ea04 	addi	r4,r4,-7256
 8221384:	821eed00 	call	821eed0 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 8221388:	e0ffff07 	ldb	r3,-4(fp)
 822138c:	008209b4 	movhi	r2,2086
 8221390:	10b61904 	addi	r2,r2,-10140
 8221394:	18c7883a 	add	r3,r3,r3
 8221398:	18c7883a 	add	r3,r3,r3
 822139c:	10c5883a 	add	r2,r2,r3
 82213a0:	10800017 	ldw	r2,0(r2)
 82213a4:	100b883a 	mov	r5,r2
 82213a8:	01020974 	movhi	r4,2085
 82213ac:	2138ef04 	addi	r4,r4,-7236
 82213b0:	821eed00 	call	821eed0 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 82213b4:	e0ffff07 	ldb	r3,-4(fp)
 82213b8:	008209b4 	movhi	r2,2086
 82213bc:	10b61904 	addi	r2,r2,-10140
 82213c0:	18c7883a 	add	r3,r3,r3
 82213c4:	18c7883a 	add	r3,r3,r3
 82213c8:	10c5883a 	add	r2,r2,r3
 82213cc:	10800017 	ldw	r2,0(r2)
 82213d0:	10801417 	ldw	r2,80(r2)
 82213d4:	100b883a 	mov	r5,r2
 82213d8:	01020974 	movhi	r4,2085
 82213dc:	2138f504 	addi	r4,r4,-7212
 82213e0:	821eed00 	call	821eed0 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 82213e4:	e0ffff07 	ldb	r3,-4(fp)
 82213e8:	008209b4 	movhi	r2,2086
 82213ec:	10b61904 	addi	r2,r2,-10140
 82213f0:	18c7883a 	add	r3,r3,r3
 82213f4:	18c7883a 	add	r3,r3,r3
 82213f8:	10c5883a 	add	r2,r2,r3
 82213fc:	10800017 	ldw	r2,0(r2)
 8221400:	10801503 	ldbu	r2,84(r2)
 8221404:	10803fcc 	andi	r2,r2,255
 8221408:	100b883a 	mov	r5,r2
 822140c:	01020974 	movhi	r4,2085
 8221410:	2138fc04 	addi	r4,r4,-7184
 8221414:	821eed00 	call	821eed0 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 8221418:	e0ffff07 	ldb	r3,-4(fp)
 822141c:	008209b4 	movhi	r2,2086
 8221420:	10b61904 	addi	r2,r2,-10140
 8221424:	18c7883a 	add	r3,r3,r3
 8221428:	18c7883a 	add	r3,r3,r3
 822142c:	10c5883a 	add	r2,r2,r3
 8221430:	10800017 	ldw	r2,0(r2)
 8221434:	10801543 	ldbu	r2,85(r2)
 8221438:	10803fcc 	andi	r2,r2,255
 822143c:	100b883a 	mov	r5,r2
 8221440:	01020974 	movhi	r4,2085
 8221444:	21390304 	addi	r4,r4,-7156
 8221448:	821eed00 	call	821eed0 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 822144c:	e0ffff07 	ldb	r3,-4(fp)
 8221450:	008209b4 	movhi	r2,2086
 8221454:	10b61904 	addi	r2,r2,-10140
 8221458:	18c7883a 	add	r3,r3,r3
 822145c:	18c7883a 	add	r3,r3,r3
 8221460:	10c5883a 	add	r2,r2,r3
 8221464:	10800017 	ldw	r2,0(r2)
 8221468:	10801583 	ldbu	r2,86(r2)
 822146c:	10803fcc 	andi	r2,r2,255
 8221470:	100b883a 	mov	r5,r2
 8221474:	01020974 	movhi	r4,2085
 8221478:	21390a04 	addi	r4,r4,-7128
 822147c:	821eed00 	call	821eed0 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 8221480:	e0ffff07 	ldb	r3,-4(fp)
 8221484:	008209b4 	movhi	r2,2086
 8221488:	10b61904 	addi	r2,r2,-10140
 822148c:	18c7883a 	add	r3,r3,r3
 8221490:	18c7883a 	add	r3,r3,r3
 8221494:	10c5883a 	add	r2,r2,r3
 8221498:	10800017 	ldw	r2,0(r2)
 822149c:	108015c3 	ldbu	r2,87(r2)
 82214a0:	10803fcc 	andi	r2,r2,255
 82214a4:	100b883a 	mov	r5,r2
 82214a8:	01020974 	movhi	r4,2085
 82214ac:	21391104 	addi	r4,r4,-7100
 82214b0:	821eed00 	call	821eed0 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 82214b4:	e0ffff07 	ldb	r3,-4(fp)
 82214b8:	008209b4 	movhi	r2,2086
 82214bc:	10b61904 	addi	r2,r2,-10140
 82214c0:	18c7883a 	add	r3,r3,r3
 82214c4:	18c7883a 	add	r3,r3,r3
 82214c8:	10c5883a 	add	r2,r2,r3
 82214cc:	10800017 	ldw	r2,0(r2)
 82214d0:	10801603 	ldbu	r2,88(r2)
 82214d4:	10803fcc 	andi	r2,r2,255
 82214d8:	100b883a 	mov	r5,r2
 82214dc:	01020974 	movhi	r4,2085
 82214e0:	21391704 	addi	r4,r4,-7076
 82214e4:	821eed00 	call	821eed0 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 82214e8:	e0ffff07 	ldb	r3,-4(fp)
 82214ec:	008209b4 	movhi	r2,2086
 82214f0:	10b61904 	addi	r2,r2,-10140
 82214f4:	18c7883a 	add	r3,r3,r3
 82214f8:	18c7883a 	add	r3,r3,r3
 82214fc:	10c5883a 	add	r2,r2,r3
 8221500:	10800017 	ldw	r2,0(r2)
 8221504:	10801643 	ldbu	r2,89(r2)
 8221508:	10803fcc 	andi	r2,r2,255
 822150c:	100b883a 	mov	r5,r2
 8221510:	01020974 	movhi	r4,2085
 8221514:	21391d04 	addi	r4,r4,-7052
 8221518:	821eed00 	call	821eed0 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 822151c:	e0bfff03 	ldbu	r2,-4(fp)
 8221520:	10800044 	addi	r2,r2,1
 8221524:	e0bfff05 	stb	r2,-4(fp)
 8221528:	e0ffff07 	ldb	r3,-4(fp)
 822152c:	d0a07f03 	ldbu	r2,-32260(gp)
 8221530:	10803fcc 	andi	r2,r2,255
 8221534:	18bf8f16 	blt	r3,r2,8221374 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 8221538:	d0a07f03 	ldbu	r2,-32260(gp)
 822153c:	10803fcc 	andi	r2,r2,255
}
 8221540:	e037883a 	mov	sp,fp
 8221544:	dfc00117 	ldw	ra,4(sp)
 8221548:	df000017 	ldw	fp,0(sp)
 822154c:	dec00204 	addi	sp,sp,8
 8221550:	f800283a 	ret

08221554 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 8221554:	defffa04 	addi	sp,sp,-24
 8221558:	dfc00515 	stw	ra,20(sp)
 822155c:	df000415 	stw	fp,16(sp)
 8221560:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 8221564:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221568:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 822156c:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 8221570:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221574:	e03ffc05 	stb	zero,-16(fp)
 8221578:	00019506 	br	8221bd0 <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 822157c:	e0bffc07 	ldb	r2,-16(fp)
 8221580:	10c01224 	muli	r3,r2,72
 8221584:	00820974 	movhi	r2,2085
 8221588:	1086d704 	addi	r2,r2,7004
 822158c:	1885883a 	add	r2,r3,r2
 8221590:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 8221594:	e0bfff17 	ldw	r2,-4(fp)
 8221598:	10800517 	ldw	r2,20(r2)
 822159c:	10018926 	beq	r2,zero,8221bc4 <alt_tse_mac_group_init+0x670>
 82215a0:	e0bfff17 	ldw	r2,-4(fp)
 82215a4:	10800617 	ldw	r2,24(r2)
 82215a8:	10018626 	beq	r2,zero,8221bc4 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 82215ac:	d0a07f43 	ldbu	r2,-32259(gp)
 82215b0:	10c03fcc 	andi	r3,r2,255
 82215b4:	e0bfff17 	ldw	r2,-4(fp)
 82215b8:	10800017 	ldw	r2,0(r2)
 82215bc:	100d883a 	mov	r6,r2
 82215c0:	180b883a 	mov	r5,r3
 82215c4:	01020974 	movhi	r4,2085
 82215c8:	21392304 	addi	r4,r4,-7028
 82215cc:	82030ec0 	call	82030ec <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 82215d0:	01000504 	movi	r4,20
 82215d4:	824b3dc0 	call	824b3dc <malloc>
 82215d8:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 82215dc:	e0bffd17 	ldw	r2,-12(fp)
 82215e0:	1000081e 	bne	r2,zero,8221604 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 82215e4:	d0a07f43 	ldbu	r2,-32259(gp)
 82215e8:	10803fcc 	andi	r2,r2,255
 82215ec:	100b883a 	mov	r5,r2
 82215f0:	01020974 	movhi	r4,2085
 82215f4:	21392f04 	addi	r4,r4,-6980
 82215f8:	82030ec0 	call	82030ec <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 82215fc:	00bfffc4 	movi	r2,-1
 8221600:	00017806 	br	8221be4 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 8221604:	e0bfff17 	ldw	r2,-4(fp)
 8221608:	108002c3 	ldbu	r2,11(r2)
 822160c:	10803fcc 	andi	r2,r2,255
 8221610:	10001226 	beq	r2,zero,822165c <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 8221614:	e0bfff17 	ldw	r2,-4(fp)
 8221618:	10c00303 	ldbu	r3,12(r2)
 822161c:	e0bffd17 	ldw	r2,-12(fp)
 8221620:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 8221624:	01020974 	movhi	r4,2085
 8221628:	21393d04 	addi	r4,r4,-6924
 822162c:	821eed00 	call	821eed0 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 8221630:	e0bffd17 	ldw	r2,-12(fp)
 8221634:	10800003 	ldbu	r2,0(r2)
 8221638:	10803fcc 	andi	r2,r2,255
 822163c:	100b883a 	mov	r5,r2
 8221640:	01020974 	movhi	r4,2085
 8221644:	21394804 	addi	r4,r4,-6880
 8221648:	821eed00 	call	821eed0 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 822164c:	01020974 	movhi	r4,2085
 8221650:	21395304 	addi	r4,r4,-6836
 8221654:	821eed00 	call	821eed0 <no_printf>
 8221658:	00001f06 	br	82216d8 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 822165c:	e0bfff17 	ldw	r2,-4(fp)
 8221660:	10800343 	ldbu	r2,13(r2)
 8221664:	10803fcc 	andi	r2,r2,255
 8221668:	10001226 	beq	r2,zero,82216b4 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 822166c:	e0bfff17 	ldw	r2,-4(fp)
 8221670:	10c00383 	ldbu	r3,14(r2)
 8221674:	e0bffd17 	ldw	r2,-12(fp)
 8221678:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 822167c:	01020974 	movhi	r4,2085
 8221680:	21395e04 	addi	r4,r4,-6792
 8221684:	821eed00 	call	821eed0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 8221688:	01020974 	movhi	r4,2085
 822168c:	21395304 	addi	r4,r4,-6836
 8221690:	821eed00 	call	821eed0 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 8221694:	e0bffd17 	ldw	r2,-12(fp)
 8221698:	10800003 	ldbu	r2,0(r2)
 822169c:	10803fcc 	andi	r2,r2,255
 82216a0:	100b883a 	mov	r5,r2
 82216a4:	01020974 	movhi	r4,2085
 82216a8:	21396904 	addi	r4,r4,-6748
 82216ac:	821eed00 	call	821eed0 <no_printf>
 82216b0:	00000906 	br	82216d8 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 82216b4:	e0bffd17 	ldw	r2,-12(fp)
 82216b8:	00c00044 	movi	r3,1
 82216bc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 82216c0:	01020974 	movhi	r4,2085
 82216c4:	21395e04 	addi	r4,r4,-6792
 82216c8:	821eed00 	call	821eed0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 82216cc:	01020974 	movhi	r4,2085
 82216d0:	21397404 	addi	r4,r4,-6704
 82216d4:	821eed00 	call	821eed0 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 82216d8:	e03ffc45 	stb	zero,-15(fp)
 82216dc:	00012206 	br	8221b68 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 82216e0:	01000404 	movi	r4,16
 82216e4:	824b3dc0 	call	824b3dc <malloc>
 82216e8:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 82216ec:	e0bffe17 	ldw	r2,-8(fp)
 82216f0:	10000a1e 	bne	r2,zero,822171c <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 82216f4:	d0a07f43 	ldbu	r2,-32259(gp)
 82216f8:	10803fcc 	andi	r2,r2,255
 82216fc:	e0fffc47 	ldb	r3,-15(fp)
 8221700:	180d883a 	mov	r6,r3
 8221704:	100b883a 	mov	r5,r2
 8221708:	01020974 	movhi	r4,2085
 822170c:	21397f04 	addi	r4,r4,-6660
 8221710:	82030ec0 	call	82030ec <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 8221714:	00bfffc4 	movi	r2,-1
 8221718:	00013206 	br	8221be4 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 822171c:	e0bffe17 	ldw	r2,-8(fp)
 8221720:	e0fffd17 	ldw	r3,-12(fp)
 8221724:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 8221728:	e0bffe17 	ldw	r2,-8(fp)
 822172c:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 8221730:	e0fffc07 	ldb	r3,-16(fp)
 8221734:	e0bffc47 	ldb	r2,-15(fp)
 8221738:	1885883a 	add	r2,r3,r2
 822173c:	10c01224 	muli	r3,r2,72
 8221740:	00820974 	movhi	r2,2085
 8221744:	1086d704 	addi	r2,r2,7004
 8221748:	1887883a 	add	r3,r3,r2
 822174c:	e0bffe17 	ldw	r2,-8(fp)
 8221750:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 8221754:	e0bffe17 	ldw	r2,-8(fp)
 8221758:	10800217 	ldw	r2,8(r2)
 822175c:	10800517 	ldw	r2,20(r2)
 8221760:	10000426 	beq	r2,zero,8221774 <alt_tse_mac_group_init+0x220>
 8221764:	e0bffe17 	ldw	r2,-8(fp)
 8221768:	10800217 	ldw	r2,8(r2)
 822176c:	10800617 	ldw	r2,24(r2)
 8221770:	1000091e 	bne	r2,zero,8221798 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 8221774:	e0fffc07 	ldb	r3,-16(fp)
 8221778:	e0bffc47 	ldb	r2,-15(fp)
 822177c:	1885883a 	add	r2,r3,r2
 8221780:	100b883a 	mov	r5,r2
 8221784:	01020974 	movhi	r4,2085
 8221788:	21399104 	addi	r4,r4,-6588
 822178c:	82030ec0 	call	82030ec <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8221790:	00bfffc4 	movi	r2,-1
 8221794:	00011306 	br	8221be4 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 8221798:	e0bffe17 	ldw	r2,-8(fp)
 822179c:	10800217 	ldw	r2,8(r2)
 82217a0:	10800243 	ldbu	r2,9(r2)
 82217a4:	10803fcc 	andi	r2,r2,255
 82217a8:	10000d26 	beq	r2,zero,82217e0 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 82217ac:	e0bffe17 	ldw	r2,-8(fp)
 82217b0:	10800217 	ldw	r2,8(r2)
 82217b4:	10800283 	ldbu	r2,10(r2)
 82217b8:	10803fcc 	andi	r2,r2,255
 82217bc:	10000426 	beq	r2,zero,82217d0 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 82217c0:	e0bffe17 	ldw	r2,-8(fp)
 82217c4:	00c00084 	movi	r3,2
 82217c8:	10c00005 	stb	r3,0(r2)
 82217cc:	00000606 	br	82217e8 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 82217d0:	e0bffe17 	ldw	r2,-8(fp)
 82217d4:	00c00044 	movi	r3,1
 82217d8:	10c00005 	stb	r3,0(r2)
 82217dc:	00000206 	br	82217e8 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 82217e0:	e0bffe17 	ldw	r2,-8(fp)
 82217e4:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 82217e8:	e0bffe17 	ldw	r2,-8(fp)
 82217ec:	10800217 	ldw	r2,8(r2)
 82217f0:	10800343 	ldbu	r2,13(r2)
 82217f4:	10803fcc 	andi	r2,r2,255
 82217f8:	10006626 	beq	r2,zero,8221994 <alt_tse_mac_group_init+0x440>
 82217fc:	e0bffe17 	ldw	r2,-8(fp)
 8221800:	10800217 	ldw	r2,8(r2)
 8221804:	108002c3 	ldbu	r2,11(r2)
 8221808:	10803fcc 	andi	r2,r2,255
 822180c:	1000611e 	bne	r2,zero,8221994 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221810:	e0fffc47 	ldb	r3,-15(fp)
 8221814:	e0bffe17 	ldw	r2,-8(fp)
 8221818:	10800217 	ldw	r2,8(r2)
 822181c:	10800017 	ldw	r2,0(r2)
 8221820:	100d883a 	mov	r6,r2
 8221824:	180b883a 	mov	r5,r3
 8221828:	01020974 	movhi	r4,2085
 822182c:	2139a004 	addi	r4,r4,-6528
 8221830:	821eed00 	call	821eed0 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 8221834:	e13ffc47 	ldb	r4,-15(fp)
 8221838:	e0fffc07 	ldb	r3,-16(fp)
 822183c:	e0bffc47 	ldb	r2,-15(fp)
 8221840:	1885883a 	add	r2,r3,r2
 8221844:	100d883a 	mov	r6,r2
 8221848:	200b883a 	mov	r5,r4
 822184c:	01020974 	movhi	r4,2085
 8221850:	2139ac04 	addi	r4,r4,-6480
 8221854:	821eed00 	call	821eed0 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 8221858:	e0bffe17 	ldw	r2,-8(fp)
 822185c:	10800003 	ldbu	r2,0(r2)
 8221860:	10803fcc 	andi	r2,r2,255
 8221864:	10c00060 	cmpeqi	r3,r2,1
 8221868:	18000c1e 	bne	r3,zero,822189c <alt_tse_mac_group_init+0x348>
 822186c:	10c000a0 	cmpeqi	r3,r2,2
 8221870:	1800021e 	bne	r3,zero,822187c <alt_tse_mac_group_init+0x328>
 8221874:	10001126 	beq	r2,zero,82218bc <alt_tse_mac_group_init+0x368>
 8221878:	00001806 	br	82218dc <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 822187c:	e0bffc47 	ldb	r2,-15(fp)
 8221880:	01820974 	movhi	r6,2085
 8221884:	31b9bb04 	addi	r6,r6,-6420
 8221888:	100b883a 	mov	r5,r2
 822188c:	01020974 	movhi	r4,2085
 8221890:	2139c004 	addi	r4,r4,-6400
 8221894:	821eed00 	call	821eed0 <no_printf>
                            break;
 8221898:	00001806 	br	82218fc <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 822189c:	e0bffc47 	ldb	r2,-15(fp)
 82218a0:	01820974 	movhi	r6,2085
 82218a4:	31b9cb04 	addi	r6,r6,-6356
 82218a8:	100b883a 	mov	r5,r2
 82218ac:	01020974 	movhi	r4,2085
 82218b0:	2139c004 	addi	r4,r4,-6400
 82218b4:	821eed00 	call	821eed0 <no_printf>
                            break;
 82218b8:	00001006 	br	82218fc <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 82218bc:	e0bffc47 	ldb	r2,-15(fp)
 82218c0:	01820974 	movhi	r6,2085
 82218c4:	31b9d104 	addi	r6,r6,-6332
 82218c8:	100b883a 	mov	r5,r2
 82218cc:	01020974 	movhi	r4,2085
 82218d0:	2139c004 	addi	r4,r4,-6400
 82218d4:	821eed00 	call	821eed0 <no_printf>
                            break;
 82218d8:	00000806 	br	82218fc <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 82218dc:	e0bffc47 	ldb	r2,-15(fp)
 82218e0:	01820974 	movhi	r6,2085
 82218e4:	31b80904 	addi	r6,r6,-8156
 82218e8:	100b883a 	mov	r5,r2
 82218ec:	01020974 	movhi	r4,2085
 82218f0:	2139c004 	addi	r4,r4,-6400
 82218f4:	821eed00 	call	821eed0 <no_printf>
                            break;
 82218f8:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 82218fc:	e0bffe17 	ldw	r2,-8(fp)
 8221900:	10800217 	ldw	r2,8(r2)
 8221904:	108003c3 	ldbu	r2,15(r2)
 8221908:	10803fcc 	andi	r2,r2,255
 822190c:	10008b26 	beq	r2,zero,8221b3c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221910:	e0fffc47 	ldb	r3,-15(fp)
 8221914:	e0bffe17 	ldw	r2,-8(fp)
 8221918:	10800217 	ldw	r2,8(r2)
 822191c:	108003c3 	ldbu	r2,15(r2)
 8221920:	10803fcc 	andi	r2,r2,255
 8221924:	10000326 	beq	r2,zero,8221934 <alt_tse_mac_group_init+0x3e0>
 8221928:	00820974 	movhi	r2,2085
 822192c:	10b9d804 	addi	r2,r2,-6304
 8221930:	00000206 	br	822193c <alt_tse_mac_group_init+0x3e8>
 8221934:	00820974 	movhi	r2,2085
 8221938:	10b9d904 	addi	r2,r2,-6300
 822193c:	100d883a 	mov	r6,r2
 8221940:	180b883a 	mov	r5,r3
 8221944:	01020974 	movhi	r4,2085
 8221948:	2139da04 	addi	r4,r4,-6296
 822194c:	821eed00 	call	821eed0 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 8221950:	e0fffc47 	ldb	r3,-15(fp)
 8221954:	e0bffe17 	ldw	r2,-8(fp)
 8221958:	10800217 	ldw	r2,8(r2)
 822195c:	10800403 	ldbu	r2,16(r2)
 8221960:	10803fcc 	andi	r2,r2,255
 8221964:	10000326 	beq	r2,zero,8221974 <alt_tse_mac_group_init+0x420>
 8221968:	00820974 	movhi	r2,2085
 822196c:	10b9d804 	addi	r2,r2,-6304
 8221970:	00000206 	br	822197c <alt_tse_mac_group_init+0x428>
 8221974:	00820974 	movhi	r2,2085
 8221978:	10b9d904 	addi	r2,r2,-6300
 822197c:	100d883a 	mov	r6,r2
 8221980:	180b883a 	mov	r5,r3
 8221984:	01020974 	movhi	r4,2085
 8221988:	2139e504 	addi	r4,r4,-6252
 822198c:	821eed00 	call	821eed0 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221990:	00006a06 	br	8221b3c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 8221994:	e0bffc47 	ldb	r2,-15(fp)
 8221998:	1000421e 	bne	r2,zero,8221aa4 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 822199c:	e0bffe17 	ldw	r2,-8(fp)
 82219a0:	10800003 	ldbu	r2,0(r2)
 82219a4:	10803fcc 	andi	r2,r2,255
 82219a8:	10c00060 	cmpeqi	r3,r2,1
 82219ac:	18000a1e 	bne	r3,zero,82219d8 <alt_tse_mac_group_init+0x484>
 82219b0:	10c000a0 	cmpeqi	r3,r2,2
 82219b4:	1800021e 	bne	r3,zero,82219c0 <alt_tse_mac_group_init+0x46c>
 82219b8:	10000d26 	beq	r2,zero,82219f0 <alt_tse_mac_group_init+0x49c>
 82219bc:	00001206 	br	8221a08 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 82219c0:	01420974 	movhi	r5,2085
 82219c4:	2979bb04 	addi	r5,r5,-6420
 82219c8:	01020974 	movhi	r4,2085
 82219cc:	2139f004 	addi	r4,r4,-6208
 82219d0:	821eed00 	call	821eed0 <no_printf>
	                            break;
 82219d4:	00001206 	br	8221a20 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 82219d8:	01420974 	movhi	r5,2085
 82219dc:	2979cb04 	addi	r5,r5,-6356
 82219e0:	01020974 	movhi	r4,2085
 82219e4:	2139f004 	addi	r4,r4,-6208
 82219e8:	821eed00 	call	821eed0 <no_printf>
	                            break;
 82219ec:	00000c06 	br	8221a20 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 82219f0:	01420974 	movhi	r5,2085
 82219f4:	2979d104 	addi	r5,r5,-6332
 82219f8:	01020974 	movhi	r4,2085
 82219fc:	2139f004 	addi	r4,r4,-6208
 8221a00:	821eed00 	call	821eed0 <no_printf>
	                            break;
 8221a04:	00000606 	br	8221a20 <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 8221a08:	01420974 	movhi	r5,2085
 8221a0c:	29780904 	addi	r5,r5,-8156
 8221a10:	01020974 	movhi	r4,2085
 8221a14:	2139f004 	addi	r4,r4,-6208
 8221a18:	821eed00 	call	821eed0 <no_printf>
                                    break;
 8221a1c:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221a20:	e0bffe17 	ldw	r2,-8(fp)
 8221a24:	10800217 	ldw	r2,8(r2)
 8221a28:	108003c3 	ldbu	r2,15(r2)
 8221a2c:	10803fcc 	andi	r2,r2,255
 8221a30:	10001c26 	beq	r2,zero,8221aa4 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221a34:	e0bffe17 	ldw	r2,-8(fp)
 8221a38:	10800217 	ldw	r2,8(r2)
 8221a3c:	108003c3 	ldbu	r2,15(r2)
 8221a40:	10803fcc 	andi	r2,r2,255
 8221a44:	10000326 	beq	r2,zero,8221a54 <alt_tse_mac_group_init+0x500>
 8221a48:	00820974 	movhi	r2,2085
 8221a4c:	10b9d804 	addi	r2,r2,-6304
 8221a50:	00000206 	br	8221a5c <alt_tse_mac_group_init+0x508>
 8221a54:	00820974 	movhi	r2,2085
 8221a58:	10b9d904 	addi	r2,r2,-6300
 8221a5c:	100b883a 	mov	r5,r2
 8221a60:	01020974 	movhi	r4,2085
 8221a64:	2139fb04 	addi	r4,r4,-6164
 8221a68:	821eed00 	call	821eed0 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 8221a6c:	e0bffe17 	ldw	r2,-8(fp)
 8221a70:	10800217 	ldw	r2,8(r2)
 8221a74:	10800403 	ldbu	r2,16(r2)
 8221a78:	10803fcc 	andi	r2,r2,255
 8221a7c:	10000326 	beq	r2,zero,8221a8c <alt_tse_mac_group_init+0x538>
 8221a80:	00820974 	movhi	r2,2085
 8221a84:	10b9d804 	addi	r2,r2,-6304
 8221a88:	00000206 	br	8221a94 <alt_tse_mac_group_init+0x540>
 8221a8c:	00820974 	movhi	r2,2085
 8221a90:	10b9d904 	addi	r2,r2,-6300
 8221a94:	100b883a 	mov	r5,r2
 8221a98:	01020974 	movhi	r4,2085
 8221a9c:	213a0604 	addi	r4,r4,-6120
 8221aa0:	821eed00 	call	821eed0 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 8221aa4:	e0bffe17 	ldw	r2,-8(fp)
 8221aa8:	10800217 	ldw	r2,8(r2)
 8221aac:	108002c3 	ldbu	r2,11(r2)
 8221ab0:	10803fcc 	andi	r2,r2,255
 8221ab4:	10001326 	beq	r2,zero,8221b04 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221ab8:	e0fffc47 	ldb	r3,-15(fp)
 8221abc:	e0bffe17 	ldw	r2,-8(fp)
 8221ac0:	10800217 	ldw	r2,8(r2)
 8221ac4:	10800017 	ldw	r2,0(r2)
 8221ac8:	100d883a 	mov	r6,r2
 8221acc:	180b883a 	mov	r5,r3
 8221ad0:	01020974 	movhi	r4,2085
 8221ad4:	213a1104 	addi	r4,r4,-6076
 8221ad8:	821eed00 	call	821eed0 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 8221adc:	e13ffc47 	ldb	r4,-15(fp)
 8221ae0:	e0fffc07 	ldb	r3,-16(fp)
 8221ae4:	e0bffc47 	ldb	r2,-15(fp)
 8221ae8:	1885883a 	add	r2,r3,r2
 8221aec:	100d883a 	mov	r6,r2
 8221af0:	200b883a 	mov	r5,r4
 8221af4:	01020974 	movhi	r4,2085
 8221af8:	213a1d04 	addi	r4,r4,-6028
 8221afc:	821eed00 	call	821eed0 <no_printf>
 8221b00:	00000e06 	br	8221b3c <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 8221b04:	e0bffe17 	ldw	r2,-8(fp)
 8221b08:	10800217 	ldw	r2,8(r2)
 8221b0c:	10800017 	ldw	r2,0(r2)
 8221b10:	100b883a 	mov	r5,r2
 8221b14:	01020974 	movhi	r4,2085
 8221b18:	213a2c04 	addi	r4,r4,-5968
 8221b1c:	821eed00 	call	821eed0 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 8221b20:	e0fffc07 	ldb	r3,-16(fp)
 8221b24:	e0bffc47 	ldb	r2,-15(fp)
 8221b28:	1885883a 	add	r2,r3,r2
 8221b2c:	100b883a 	mov	r5,r2
 8221b30:	01020974 	movhi	r4,2085
 8221b34:	213a3804 	addi	r4,r4,-5920
 8221b38:	821eed00 	call	821eed0 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 8221b3c:	e0bffc47 	ldb	r2,-15(fp)
 8221b40:	e0fffd17 	ldw	r3,-12(fp)
 8221b44:	10800044 	addi	r2,r2,1
 8221b48:	1085883a 	add	r2,r2,r2
 8221b4c:	1085883a 	add	r2,r2,r2
 8221b50:	1885883a 	add	r2,r3,r2
 8221b54:	e0fffe17 	ldw	r3,-8(fp)
 8221b58:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 8221b5c:	e0bffc43 	ldbu	r2,-15(fp)
 8221b60:	10800044 	addi	r2,r2,1
 8221b64:	e0bffc45 	stb	r2,-15(fp)
 8221b68:	e0fffc47 	ldb	r3,-15(fp)
 8221b6c:	e0bffd17 	ldw	r2,-12(fp)
 8221b70:	10800003 	ldbu	r2,0(r2)
 8221b74:	10803fcc 	andi	r2,r2,255
 8221b78:	18bed916 	blt	r3,r2,82216e0 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 8221b7c:	d0a07f43 	ldbu	r2,-32259(gp)
 8221b80:	10c03fcc 	andi	r3,r2,255
 8221b84:	008209b4 	movhi	r2,2086
 8221b88:	10b61504 	addi	r2,r2,-10156
 8221b8c:	18c7883a 	add	r3,r3,r3
 8221b90:	18c7883a 	add	r3,r3,r3
 8221b94:	10c5883a 	add	r2,r2,r3
 8221b98:	e0fffd17 	ldw	r3,-12(fp)
 8221b9c:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 8221ba0:	d0a07f43 	ldbu	r2,-32259(gp)
 8221ba4:	10800044 	addi	r2,r2,1
 8221ba8:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 8221bac:	e0bffd17 	ldw	r2,-12(fp)
 8221bb0:	10c00003 	ldbu	r3,0(r2)
 8221bb4:	e0bffc03 	ldbu	r2,-16(fp)
 8221bb8:	1885883a 	add	r2,r3,r2
 8221bbc:	10bfffc4 	addi	r2,r2,-1
 8221bc0:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221bc4:	e0bffc03 	ldbu	r2,-16(fp)
 8221bc8:	10800044 	addi	r2,r2,1
 8221bcc:	e0bffc05 	stb	r2,-16(fp)
 8221bd0:	e0fffc07 	ldb	r3,-16(fp)
 8221bd4:	d0a02d03 	ldbu	r2,-32588(gp)
 8221bd8:	10803fcc 	andi	r2,r2,255
 8221bdc:	18be6716 	blt	r3,r2,822157c <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 8221be0:	0005883a 	mov	r2,zero
}
 8221be4:	e037883a 	mov	sp,fp
 8221be8:	dfc00117 	ldw	ra,4(sp)
 8221bec:	df000017 	ldw	fp,0(sp)
 8221bf0:	dec00204 	addi	sp,sp,8
 8221bf4:	f800283a 	ret

08221bf8 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 8221bf8:	deffed04 	addi	sp,sp,-76
 8221bfc:	dfc01215 	stw	ra,72(sp)
 8221c00:	df001115 	stw	fp,68(sp)
 8221c04:	df001104 	addi	fp,sp,68
 8221c08:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 8221c0c:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 8221c10:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 8221c14:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 8221c18:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221c1c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 8221c20:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221c24:	e0bfff17 	ldw	r2,-4(fp)
 8221c28:	10800117 	ldw	r2,4(r2)
 8221c2c:	10800217 	ldw	r2,8(r2)
 8221c30:	10800017 	ldw	r2,0(r2)
 8221c34:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221c38:	e0bff917 	ldw	r2,-28(fp)
 8221c3c:	10801004 	addi	r2,r2,64
 8221c40:	10800037 	ldwio	r2,0(r2)
 8221c44:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8221c48:	e13fff17 	ldw	r4,-4(fp)
 8221c4c:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 8221c50:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221c54:	e03ff005 	stb	zero,-64(fp)
 8221c58:	0000cb06 	br	8221f88 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 8221c5c:	e0bff917 	ldw	r2,-28(fp)
 8221c60:	10801004 	addi	r2,r2,64
 8221c64:	e0fff003 	ldbu	r3,-64(fp)
 8221c68:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 8221c6c:	e0bff917 	ldw	r2,-28(fp)
 8221c70:	1080a204 	addi	r2,r2,648
 8221c74:	10800037 	ldwio	r2,0(r2)
 8221c78:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 8221c7c:	e0bff917 	ldw	r2,-28(fp)
 8221c80:	1080a304 	addi	r2,r2,652
 8221c84:	10800037 	ldwio	r2,0(r2)
 8221c88:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 8221c8c:	e0fffc17 	ldw	r3,-16(fp)
 8221c90:	e0bff517 	ldw	r2,-44(fp)
 8221c94:	1880b926 	beq	r3,r2,8221f7c <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 8221c98:	01000704 	movi	r4,28
 8221c9c:	824b3dc0 	call	824b3dc <malloc>
 8221ca0:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 8221ca4:	e0bff617 	ldw	r2,-40(fp)
 8221ca8:	1000091e 	bne	r2,zero,8221cd0 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 8221cac:	e0bffb07 	ldb	r2,-20(fp)
 8221cb0:	e0fff407 	ldb	r3,-48(fp)
 8221cb4:	180d883a 	mov	r6,r3
 8221cb8:	100b883a 	mov	r5,r2
 8221cbc:	01020974 	movhi	r4,2085
 8221cc0:	213a4704 	addi	r4,r4,-5860
 8221cc4:	82030ec0 	call	82030ec <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 8221cc8:	00bfffc4 	movi	r2,-1
 8221ccc:	0000ce06 	br	8222008 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 8221cd0:	e0bff617 	ldw	r2,-40(fp)
 8221cd4:	e0fff003 	ldbu	r3,-64(fp)
 8221cd8:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 8221cdc:	e0bffc17 	ldw	r2,-16(fp)
 8221ce0:	100691ba 	slli	r3,r2,6
 8221ce4:	e0bff517 	ldw	r2,-44(fp)
 8221ce8:	1005d2ba 	srai	r2,r2,10
 8221cec:	10800fcc 	andi	r2,r2,63
 8221cf0:	1884b03a 	or	r2,r3,r2
 8221cf4:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 8221cf8:	e0bff517 	ldw	r2,-44(fp)
 8221cfc:	1005d13a 	srai	r2,r2,4
 8221d00:	10800fcc 	andi	r2,r2,63
 8221d04:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 8221d08:	e0bff517 	ldw	r2,-44(fp)
 8221d0c:	108003cc 	andi	r2,r2,15
 8221d10:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 8221d14:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 8221d18:	e03ff115 	stw	zero,-60(fp)
 8221d1c:	00003406 	br	8221df0 <alt_tse_mac_get_phy+0x1f8>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 8221d20:	008209b4 	movhi	r2,2086
 8221d24:	10b61904 	addi	r2,r2,-10140
 8221d28:	e0fff117 	ldw	r3,-60(fp)
 8221d2c:	18c7883a 	add	r3,r3,r3
 8221d30:	18c7883a 	add	r3,r3,r3
 8221d34:	10c5883a 	add	r2,r2,r3
 8221d38:	10800017 	ldw	r2,0(r2)
 8221d3c:	10c01417 	ldw	r3,80(r2)
 8221d40:	e0bffd17 	ldw	r2,-12(fp)
 8221d44:	1880271e 	bne	r3,r2,8221de4 <alt_tse_mac_get_phy+0x1ec>
 8221d48:	008209b4 	movhi	r2,2086
 8221d4c:	10b61904 	addi	r2,r2,-10140
 8221d50:	e0fff117 	ldw	r3,-60(fp)
 8221d54:	18c7883a 	add	r3,r3,r3
 8221d58:	18c7883a 	add	r3,r3,r3
 8221d5c:	10c5883a 	add	r2,r2,r3
 8221d60:	10800017 	ldw	r2,0(r2)
 8221d64:	10801503 	ldbu	r2,84(r2)
 8221d68:	10c03fcc 	andi	r3,r2,255
 8221d6c:	e0bffe03 	ldbu	r2,-8(fp)
 8221d70:	18801c1e 	bne	r3,r2,8221de4 <alt_tse_mac_get_phy+0x1ec>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 8221d74:	008209b4 	movhi	r2,2086
 8221d78:	10b61904 	addi	r2,r2,-10140
 8221d7c:	e0fff117 	ldw	r3,-60(fp)
 8221d80:	18c7883a 	add	r3,r3,r3
 8221d84:	18c7883a 	add	r3,r3,r3
 8221d88:	10c5883a 	add	r2,r2,r3
 8221d8c:	10c00017 	ldw	r3,0(r2)
 8221d90:	e0bff617 	ldw	r2,-40(fp)
 8221d94:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 8221d98:	008209b4 	movhi	r2,2086
 8221d9c:	10b61904 	addi	r2,r2,-10140
 8221da0:	e0fff117 	ldw	r3,-60(fp)
 8221da4:	18c7883a 	add	r3,r3,r3
 8221da8:	18c7883a 	add	r3,r3,r3
 8221dac:	10c5883a 	add	r2,r2,r3
 8221db0:	10800017 	ldw	r2,0(r2)
 8221db4:	1009883a 	mov	r4,r2
 8221db8:	e0bff003 	ldbu	r2,-64(fp)
 8221dbc:	e0fffb07 	ldb	r3,-20(fp)
 8221dc0:	180f883a 	mov	r7,r3
 8221dc4:	100d883a 	mov	r6,r2
 8221dc8:	200b883a 	mov	r5,r4
 8221dcc:	01020974 	movhi	r4,2085
 8221dd0:	213a5604 	addi	r4,r4,-5800
 8221dd4:	82030ec0 	call	82030ec <printf>
                    is_phy_in_profile = 1;
 8221dd8:	00800044 	movi	r2,1
 8221ddc:	e0bff205 	stb	r2,-56(fp)
                    break;
 8221de0:	00000706 	br	8221e00 <alt_tse_mac_get_phy+0x208>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 8221de4:	e0bff117 	ldw	r2,-60(fp)
 8221de8:	10800044 	addi	r2,r2,1
 8221dec:	e0bff115 	stw	r2,-60(fp)
 8221df0:	d0a07f03 	ldbu	r2,-32260(gp)
 8221df4:	10803fcc 	andi	r2,r2,255
 8221df8:	e0fff117 	ldw	r3,-60(fp)
 8221dfc:	18bfc816 	blt	r3,r2,8221d20 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 8221e00:	e0bff203 	ldbu	r2,-56(fp)
 8221e04:	10000f1e 	bne	r2,zero,8221e44 <alt_tse_mac_get_phy+0x24c>
                pphy->pphy_profile = 0;
 8221e08:	e0bff617 	ldw	r2,-40(fp)
 8221e0c:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 8221e10:	e0bff003 	ldbu	r2,-64(fp)
 8221e14:	e0fffb07 	ldb	r3,-20(fp)
 8221e18:	180d883a 	mov	r6,r3
 8221e1c:	100b883a 	mov	r5,r2
 8221e20:	01020974 	movhi	r4,2085
 8221e24:	213a6604 	addi	r4,r4,-5736
 8221e28:	82030ec0 	call	82030ec <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 8221e2c:	01020974 	movhi	r4,2085
 8221e30:	213a7704 	addi	r4,r4,-5668
 8221e34:	82033700 	call	8203370 <puts>
                return_value++;
 8221e38:	e0bff317 	ldw	r2,-52(fp)
 8221e3c:	10800044 	addi	r2,r2,1
 8221e40:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 8221e44:	e0bffd17 	ldw	r2,-12(fp)
 8221e48:	100b883a 	mov	r5,r2
 8221e4c:	01020974 	movhi	r4,2085
 8221e50:	213a8404 	addi	r4,r4,-5616
 8221e54:	821eed00 	call	821eed0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 8221e58:	e0bffe03 	ldbu	r2,-8(fp)
 8221e5c:	100b883a 	mov	r5,r2
 8221e60:	01020974 	movhi	r4,2085
 8221e64:	213a8f04 	addi	r4,r4,-5572
 8221e68:	821eed00 	call	821eed0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 8221e6c:	e0bffe43 	ldbu	r2,-7(fp)
 8221e70:	100b883a 	mov	r5,r2
 8221e74:	01020974 	movhi	r4,2085
 8221e78:	213a9a04 	addi	r4,r4,-5528
 8221e7c:	821eed00 	call	821eed0 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 8221e80:	e17ff617 	ldw	r5,-40(fp)
 8221e84:	e13fff17 	ldw	r4,-4(fp)
 8221e88:	822201c0 	call	822201c <alt_tse_mac_associate_phy>
 8221e8c:	1000351e 	bne	r2,zero,8221f64 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 8221e90:	e0bff617 	ldw	r2,-40(fp)
 8221e94:	10800617 	ldw	r2,24(r2)
 8221e98:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 8221e9c:	e0bff717 	ldw	r2,-36(fp)
 8221ea0:	10800217 	ldw	r2,8(r2)
 8221ea4:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8221ea8:	d8000015 	stw	zero,0(sp)
 8221eac:	01c00044 	movi	r7,1
 8221eb0:	01800384 	movi	r6,14
 8221eb4:	000b883a 	mov	r5,zero
 8221eb8:	e13ff617 	ldw	r4,-40(fp)
 8221ebc:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 8221ec0:	01400044 	movi	r5,1
 8221ec4:	e13ff617 	ldw	r4,-40(fp)
 8221ec8:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 8221ecc:	01400044 	movi	r5,1
 8221ed0:	e13ff617 	ldw	r4,-40(fp)
 8221ed4:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 8221ed8:	01400044 	movi	r5,1
 8221edc:	e13ff617 	ldw	r4,-40(fp)
 8221ee0:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 8221ee4:	014003f4 	movhi	r5,15
 8221ee8:	29509004 	addi	r5,r5,16960
 8221eec:	e13ff617 	ldw	r4,-40(fp)
 8221ef0:	82224a40 	call	82224a4 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 8221ef4:	e0bff617 	ldw	r2,-40(fp)
 8221ef8:	10800517 	ldw	r2,20(r2)
 8221efc:	10000f26 	beq	r2,zero,8221f3c <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 8221f00:	e0bff617 	ldw	r2,-40(fp)
 8221f04:	10800517 	ldw	r2,20(r2)
 8221f08:	10801717 	ldw	r2,92(r2)
 8221f0c:	10000b26 	beq	r2,zero,8221f3c <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 8221f10:	e0bff617 	ldw	r2,-40(fp)
 8221f14:	10800517 	ldw	r2,20(r2)
 8221f18:	100b883a 	mov	r5,r2
 8221f1c:	01020974 	movhi	r4,2085
 8221f20:	213aa504 	addi	r4,r4,-5484
 8221f24:	821eed00 	call	821eed0 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 8221f28:	e0bff617 	ldw	r2,-40(fp)
 8221f2c:	10800517 	ldw	r2,20(r2)
 8221f30:	10801717 	ldw	r2,92(r2)
 8221f34:	e13ff917 	ldw	r4,-28(fp)
 8221f38:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 8221f3c:	e0bff817 	ldw	r2,-32(fp)
 8221f40:	10801117 	ldw	r2,68(r2)
 8221f44:	10000726 	beq	r2,zero,8221f64 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 8221f48:	01020974 	movhi	r4,2085
 8221f4c:	213ab304 	addi	r4,r4,-5428
 8221f50:	821eed00 	call	821eed0 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 8221f54:	e0bff817 	ldw	r2,-32(fp)
 8221f58:	10801117 	ldw	r2,68(r2)
 8221f5c:	e13ff917 	ldw	r4,-28(fp)
 8221f60:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 8221f64:	01020974 	movhi	r4,2085
 8221f68:	213ac104 	addi	r4,r4,-5372
 8221f6c:	821eed00 	call	821eed0 <no_printf>
	            
            phy_info_count++;
 8221f70:	e0bff403 	ldbu	r2,-48(fp)
 8221f74:	10800044 	addi	r2,r2,1
 8221f78:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221f7c:	e0bff003 	ldbu	r2,-64(fp)
 8221f80:	10800044 	addi	r2,r2,1
 8221f84:	e0bff005 	stb	r2,-64(fp)
 8221f88:	e0bff003 	ldbu	r2,-64(fp)
 8221f8c:	10800830 	cmpltui	r2,r2,32
 8221f90:	103f321e 	bne	r2,zero,8221c5c <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 8221f94:	e0bfff17 	ldw	r2,-4(fp)
 8221f98:	10800003 	ldbu	r2,0(r2)
 8221f9c:	10c03fcc 	andi	r3,r2,255
 8221fa0:	e0bff407 	ldb	r2,-48(fp)
 8221fa4:	18801326 	beq	r3,r2,8221ff4 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 8221fa8:	e0bff407 	ldb	r2,-48(fp)
 8221fac:	1000061e 	bne	r2,zero,8221fc8 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 8221fb0:	e0bffb07 	ldb	r2,-20(fp)
 8221fb4:	100b883a 	mov	r5,r2
 8221fb8:	01020974 	movhi	r4,2085
 8221fbc:	213ac204 	addi	r4,r4,-5368
 8221fc0:	82030ec0 	call	82030ec <printf>
 8221fc4:	00000b06 	br	8221ff4 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 8221fc8:	e0fffb07 	ldb	r3,-20(fp)
 8221fcc:	e13ff407 	ldb	r4,-48(fp)
 8221fd0:	e0bfff17 	ldw	r2,-4(fp)
 8221fd4:	10800003 	ldbu	r2,0(r2)
 8221fd8:	10803fcc 	andi	r2,r2,255
 8221fdc:	100f883a 	mov	r7,r2
 8221fe0:	200d883a 	mov	r6,r4
 8221fe4:	180b883a 	mov	r5,r3
 8221fe8:	01020974 	movhi	r4,2085
 8221fec:	213ace04 	addi	r4,r4,-5320
 8221ff0:	82030ec0 	call	82030ec <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8221ff4:	e0bff917 	ldw	r2,-28(fp)
 8221ff8:	10801004 	addi	r2,r2,64
 8221ffc:	e0fffa17 	ldw	r3,-24(fp)
 8222000:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 8222004:	e0bff317 	ldw	r2,-52(fp)
}
 8222008:	e037883a 	mov	sp,fp
 822200c:	dfc00117 	ldw	ra,4(sp)
 8222010:	df000017 	ldw	fp,0(sp)
 8222014:	dec00204 	addi	sp,sp,8
 8222018:	f800283a 	ret

0822201c <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 822201c:	defff604 	addi	sp,sp,-40
 8222020:	dfc00915 	stw	ra,36(sp)
 8222024:	df000815 	stw	fp,32(sp)
 8222028:	df000804 	addi	fp,sp,32
 822202c:	e13ffe15 	stw	r4,-8(fp)
 8222030:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 8222034:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 8222038:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 822203c:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8222040:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222044:	e13ffe17 	ldw	r4,-8(fp)
 8222048:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 822204c:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 8222050:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 8222054:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 8222058:	e03ff815 	stw	zero,-32(fp)
 822205c:	00002c06 	br	8222110 <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 8222060:	e0fffe17 	ldw	r3,-8(fp)
 8222064:	e0bff817 	ldw	r2,-32(fp)
 8222068:	10800044 	addi	r2,r2,1
 822206c:	1085883a 	add	r2,r2,r2
 8222070:	1085883a 	add	r2,r2,r2
 8222074:	1885883a 	add	r2,r3,r2
 8222078:	10800017 	ldw	r2,0(r2)
 822207c:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 8222080:	e0bffc17 	ldw	r2,-16(fp)
 8222084:	10800217 	ldw	r2,8(r2)
 8222088:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 822208c:	e0bffb17 	ldw	r2,-20(fp)
 8222090:	10c01017 	ldw	r3,64(r2)
 8222094:	e0bfff17 	ldw	r2,-4(fp)
 8222098:	10800003 	ldbu	r2,0(r2)
 822209c:	10803fcc 	andi	r2,r2,255
 82220a0:	1880181e 	bne	r3,r2,8222104 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82220a4:	e13ffc17 	ldw	r4,-16(fp)
 82220a8:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 82220ac:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 82220b0:	e13ffb17 	ldw	r4,-20(fp)
 82220b4:	821ffe80 	call	821ffe8 <alt_tse_get_system_index>
 82220b8:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 82220bc:	e0bffc17 	ldw	r2,-16(fp)
 82220c0:	e0ffff17 	ldw	r3,-4(fp)
 82220c4:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 82220c8:	e0bfff17 	ldw	r2,-4(fp)
 82220cc:	e0fffc17 	ldw	r3,-16(fp)
 82220d0:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82220d4:	e0bffd47 	ldb	r2,-11(fp)
 82220d8:	e0fffd07 	ldb	r3,-12(fp)
 82220dc:	e13ffd87 	ldb	r4,-10(fp)
 82220e0:	200f883a 	mov	r7,r4
 82220e4:	180d883a 	mov	r6,r3
 82220e8:	100b883a 	mov	r5,r2
 82220ec:	01020974 	movhi	r4,2085
 82220f0:	213aed04 	addi	r4,r4,-5196
 82220f4:	82030ec0 	call	82030ec <printf>
            is_mapped = 1;
 82220f8:	00800044 	movi	r2,1
 82220fc:	e0bffa05 	stb	r2,-24(fp)
            break;
 8222100:	00000806 	br	8222124 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 8222104:	e0bff817 	ldw	r2,-32(fp)
 8222108:	10800044 	addi	r2,r2,1
 822210c:	e0bff815 	stw	r2,-32(fp)
 8222110:	e0bffe17 	ldw	r2,-8(fp)
 8222114:	10800003 	ldbu	r2,0(r2)
 8222118:	10803fcc 	andi	r2,r2,255
 822211c:	e0fff817 	ldw	r3,-32(fp)
 8222120:	18bfcf16 	blt	r3,r2,8222060 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 8222124:	e0bffa03 	ldbu	r2,-24(fp)
 8222128:	10003d1e 	bne	r2,zero,8222220 <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 822212c:	e03ff815 	stw	zero,-32(fp)
 8222130:	00003606 	br	822220c <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 8222134:	e0fffe17 	ldw	r3,-8(fp)
 8222138:	e0bff817 	ldw	r2,-32(fp)
 822213c:	10800044 	addi	r2,r2,1
 8222140:	1085883a 	add	r2,r2,r2
 8222144:	1085883a 	add	r2,r2,r2
 8222148:	1885883a 	add	r2,r3,r2
 822214c:	10800017 	ldw	r2,0(r2)
 8222150:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 8222154:	e0bffc17 	ldw	r2,-16(fp)
 8222158:	10800217 	ldw	r2,8(r2)
 822215c:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 8222160:	e0bffb17 	ldw	r2,-20(fp)
 8222164:	10800517 	ldw	r2,20(r2)
 8222168:	10002426 	beq	r2,zero,82221fc <alt_tse_mac_associate_phy+0x1e0>
 822216c:	e0bffb17 	ldw	r2,-20(fp)
 8222170:	10800617 	ldw	r2,24(r2)
 8222174:	10002126 	beq	r2,zero,82221fc <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 8222178:	e0bffb17 	ldw	r2,-20(fp)
 822217c:	10801017 	ldw	r2,64(r2)
 8222180:	10bfffd8 	cmpnei	r2,r2,-1
 8222184:	10001e1e 	bne	r2,zero,8222200 <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222188:	e13ffc17 	ldw	r4,-16(fp)
 822218c:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 8222190:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 8222194:	e13ffb17 	ldw	r4,-20(fp)
 8222198:	821ffe80 	call	821ffe8 <alt_tse_get_system_index>
 822219c:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 82221a0:	e0bffc17 	ldw	r2,-16(fp)
 82221a4:	e0ffff17 	ldw	r3,-4(fp)
 82221a8:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 82221ac:	e0bfff17 	ldw	r2,-4(fp)
 82221b0:	e0fffc17 	ldw	r3,-16(fp)
 82221b4:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 82221b8:	e0bfff17 	ldw	r2,-4(fp)
 82221bc:	10800003 	ldbu	r2,0(r2)
 82221c0:	10c03fcc 	andi	r3,r2,255
 82221c4:	e0bffb17 	ldw	r2,-20(fp)
 82221c8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82221cc:	e0bffd47 	ldb	r2,-11(fp)
 82221d0:	e0fffd07 	ldb	r3,-12(fp)
 82221d4:	e13ffd87 	ldb	r4,-10(fp)
 82221d8:	200f883a 	mov	r7,r4
 82221dc:	180d883a 	mov	r6,r3
 82221e0:	100b883a 	mov	r5,r2
 82221e4:	01020974 	movhi	r4,2085
 82221e8:	213afd04 	addi	r4,r4,-5132
 82221ec:	82030ec0 	call	82030ec <printf>
                is_mapped = 1;
 82221f0:	00800044 	movi	r2,1
 82221f4:	e0bffa05 	stb	r2,-24(fp)
                break;
 82221f8:	00000906 	br	8222220 <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 82221fc:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 8222200:	e0bff817 	ldw	r2,-32(fp)
 8222204:	10800044 	addi	r2,r2,1
 8222208:	e0bff815 	stw	r2,-32(fp)
 822220c:	e0bffe17 	ldw	r2,-8(fp)
 8222210:	10800003 	ldbu	r2,0(r2)
 8222214:	10803fcc 	andi	r2,r2,255
 8222218:	e0fff817 	ldw	r3,-32(fp)
 822221c:	18bfc516 	blt	r3,r2,8222134 <alt_tse_mac_associate_phy+0x118>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 8222220:	e0bffa03 	ldbu	r2,-24(fp)
 8222224:	1000091e 	bne	r2,zero,822224c <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 8222228:	e0bfff17 	ldw	r2,-4(fp)
 822222c:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 8222230:	e0bffd47 	ldb	r2,-11(fp)
 8222234:	100b883a 	mov	r5,r2
 8222238:	01020974 	movhi	r4,2085
 822223c:	213b0e04 	addi	r4,r4,-5064
 8222240:	82030ec0 	call	82030ec <printf>
        return_value = TSE_PHY_MAP_ERROR;
 8222244:	00bfffc4 	movi	r2,-1
 8222248:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 822224c:	e0bff917 	ldw	r2,-28(fp)
}
 8222250:	e037883a 	mov	sp,fp
 8222254:	dfc00117 	ldw	ra,4(sp)
 8222258:	df000017 	ldw	fp,0(sp)
 822225c:	dec00204 	addi	sp,sp,8
 8222260:	f800283a 	ret

08222264 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 8222264:	defff804 	addi	sp,sp,-32
 8222268:	dfc00715 	stw	ra,28(sp)
 822226c:	df000615 	stw	fp,24(sp)
 8222270:	df000604 	addi	fp,sp,24
 8222274:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 8222278:	e0bfff17 	ldw	r2,-4(fp)
 822227c:	10800217 	ldw	r2,8(r2)
 8222280:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 8222284:	e0bffa17 	ldw	r2,-24(fp)
 8222288:	10800017 	ldw	r2,0(r2)
 822228c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222290:	e0bfff17 	ldw	r2,-4(fp)
 8222294:	10800317 	ldw	r2,12(r2)
 8222298:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 822229c:	e13fff17 	ldw	r4,-4(fp)
 82222a0:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 82222a4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82222a8:	e13ffc17 	ldw	r4,-16(fp)
 82222ac:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 82222b0:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 82222b4:	e0bffa17 	ldw	r2,-24(fp)
 82222b8:	108003c3 	ldbu	r2,15(r2)
 82222bc:	10803fcc 	andi	r2,r2,255
 82222c0:	10002c26 	beq	r2,zero,8222374 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 82222c4:	e0bffd47 	ldb	r2,-11(fp)
 82222c8:	e0fffd07 	ldb	r3,-12(fp)
 82222cc:	180d883a 	mov	r6,r3
 82222d0:	100b883a 	mov	r5,r2
 82222d4:	01020974 	movhi	r4,2085
 82222d8:	213b3f04 	addi	r4,r4,-4868
 82222dc:	82030ec0 	call	82030ec <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 82222e0:	e0bffb17 	ldw	r2,-20(fp)
 82222e4:	10808004 	addi	r2,r2,512
 82222e8:	10801404 	addi	r2,r2,80
 82222ec:	10800037 	ldwio	r2,0(r2)
 82222f0:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 82222f4:	e0bffa17 	ldw	r2,-24(fp)
 82222f8:	10800403 	ldbu	r2,16(r2)
 82222fc:	10803fcc 	andi	r2,r2,255
 8222300:	10000e26 	beq	r2,zero,822233c <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 8222304:	e0bffd47 	ldb	r2,-11(fp)
 8222308:	e0fffd07 	ldb	r3,-12(fp)
 822230c:	180d883a 	mov	r6,r3
 8222310:	100b883a 	mov	r5,r2
 8222314:	01020974 	movhi	r4,2085
 8222318:	213b4d04 	addi	r4,r4,-4812
 822231c:	82030ec0 	call	82030ec <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 8222320:	e0bffb17 	ldw	r2,-20(fp)
 8222324:	10808004 	addi	r2,r2,512
 8222328:	10801404 	addi	r2,r2,80
 822232c:	e0fffe17 	ldw	r3,-8(fp)
 8222330:	18c000d4 	ori	r3,r3,3
 8222334:	10c00035 	stwio	r3,0(r2)
 8222338:	00000e06 	br	8222374 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 822233c:	e0bffd47 	ldb	r2,-11(fp)
 8222340:	e0fffd07 	ldb	r3,-12(fp)
 8222344:	180d883a 	mov	r6,r3
 8222348:	100b883a 	mov	r5,r2
 822234c:	01020974 	movhi	r4,2085
 8222350:	213b5904 	addi	r4,r4,-4764
 8222354:	82030ec0 	call	82030ec <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 8222358:	e0bffb17 	ldw	r2,-20(fp)
 822235c:	10808004 	addi	r2,r2,512
 8222360:	10801404 	addi	r2,r2,80
 8222364:	e13ffe17 	ldw	r4,-8(fp)
 8222368:	00ffff04 	movi	r3,-4
 822236c:	20c6703a 	and	r3,r4,r3
 8222370:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 8222374:	0005883a 	mov	r2,zero
}
 8222378:	e037883a 	mov	sp,fp
 822237c:	dfc00117 	ldw	ra,4(sp)
 8222380:	df000017 	ldw	fp,0(sp)
 8222384:	dec00204 	addi	sp,sp,8
 8222388:	f800283a 	ret

0822238c <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 822238c:	defffb04 	addi	sp,sp,-20
 8222390:	dfc00415 	stw	ra,16(sp)
 8222394:	df000315 	stw	fp,12(sp)
 8222398:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 822239c:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 82223a0:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 82223a4:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 82223a8:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 82223ac:	82210a80 	call	82210a8 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 82223b0:	82213440 	call	8221344 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 82223b4:	82215540 	call	8221554 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 82223b8:	e03ffd05 	stb	zero,-12(fp)
 82223bc:	00002f06 	br	822247c <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 82223c0:	e0fffd07 	ldb	r3,-12(fp)
 82223c4:	008209b4 	movhi	r2,2086
 82223c8:	10b61504 	addi	r2,r2,-10156
 82223cc:	18c7883a 	add	r3,r3,r3
 82223d0:	18c7883a 	add	r3,r3,r3
 82223d4:	10c5883a 	add	r2,r2,r3
 82223d8:	10800017 	ldw	r2,0(r2)
 82223dc:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 82223e0:	e0bffe17 	ldw	r2,-8(fp)
 82223e4:	10800117 	ldw	r2,4(r2)
 82223e8:	10800217 	ldw	r2,8(r2)
 82223ec:	10800203 	ldbu	r2,8(r2)
 82223f0:	10803fcc 	andi	r2,r2,255
 82223f4:	10000326 	beq	r2,zero,8222404 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 82223f8:	e13ffe17 	ldw	r4,-8(fp)
 82223fc:	8221bf80 	call	8221bf8 <alt_tse_mac_get_phy>
 8222400:	00000706 	br	8222420 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 8222404:	e0bffd07 	ldb	r2,-12(fp)
 8222408:	e0fffd47 	ldb	r3,-11(fp)
 822240c:	180d883a 	mov	r6,r3
 8222410:	100b883a 	mov	r5,r2
 8222414:	01020974 	movhi	r4,2085
 8222418:	213b6504 	addi	r4,r4,-4716
 822241c:	82030ec0 	call	82030ec <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222420:	e03ffd45 	stb	zero,-11(fp)
 8222424:	00000d06 	br	822245c <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 8222428:	e0bffd47 	ldb	r2,-11(fp)
 822242c:	e0fffe17 	ldw	r3,-8(fp)
 8222430:	10800044 	addi	r2,r2,1
 8222434:	1085883a 	add	r2,r2,r2
 8222438:	1085883a 	add	r2,r2,r2
 822243c:	1885883a 	add	r2,r3,r2
 8222440:	10800017 	ldw	r2,0(r2)
 8222444:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 8222448:	e13fff17 	ldw	r4,-4(fp)
 822244c:	82222640 	call	8222264 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222450:	e0bffd43 	ldbu	r2,-11(fp)
 8222454:	10800044 	addi	r2,r2,1
 8222458:	e0bffd45 	stb	r2,-11(fp)
 822245c:	e0fffd47 	ldb	r3,-11(fp)
 8222460:	e0bffe17 	ldw	r2,-8(fp)
 8222464:	10800003 	ldbu	r2,0(r2)
 8222468:	10803fcc 	andi	r2,r2,255
 822246c:	18bfee16 	blt	r3,r2,8222428 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 8222470:	e0bffd03 	ldbu	r2,-12(fp)
 8222474:	10800044 	addi	r2,r2,1
 8222478:	e0bffd05 	stb	r2,-12(fp)
 822247c:	e0fffd07 	ldb	r3,-12(fp)
 8222480:	d0a07f43 	ldbu	r2,-32259(gp)
 8222484:	10803fcc 	andi	r2,r2,255
 8222488:	18bfcd16 	blt	r3,r2,82223c0 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 822248c:	0005883a 	mov	r2,zero
}
 8222490:	e037883a 	mov	sp,fp
 8222494:	dfc00117 	ldw	ra,4(sp)
 8222498:	df000017 	ldw	fp,0(sp)
 822249c:	dec00204 	addi	sp,sp,8
 82224a0:	f800283a 	ret

082224a4 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 82224a4:	defff704 	addi	sp,sp,-36
 82224a8:	dfc00815 	stw	ra,32(sp)
 82224ac:	df000715 	stw	fp,28(sp)
 82224b0:	df000704 	addi	fp,sp,28
 82224b4:	e13ffe15 	stw	r4,-8(fp)
 82224b8:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82224bc:	e0bffe17 	ldw	r2,-8(fp)
 82224c0:	10800617 	ldw	r2,24(r2)
 82224c4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82224c8:	e0bffb17 	ldw	r2,-20(fp)
 82224cc:	10800317 	ldw	r2,12(r2)
 82224d0:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82224d4:	e13ffb17 	ldw	r4,-20(fp)
 82224d8:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 82224dc:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82224e0:	e13ffc17 	ldw	r4,-16(fp)
 82224e4:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 82224e8:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82224ec:	e13ffe17 	ldw	r4,-8(fp)
 82224f0:	8220e140 	call	8220e14 <alt_tse_phy_rd_mdio_addr>
 82224f4:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82224f8:	e0bffe17 	ldw	r2,-8(fp)
 82224fc:	10800003 	ldbu	r2,0(r2)
 8222500:	10803fcc 	andi	r2,r2,255
 8222504:	100b883a 	mov	r5,r2
 8222508:	e13ffe17 	ldw	r4,-8(fp)
 822250c:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222510:	01c00044 	movi	r7,1
 8222514:	018000c4 	movi	r6,3
 8222518:	01400044 	movi	r5,1
 822251c:	e13ffe17 	ldw	r4,-8(fp)
 8222520:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222524:	10000d1e 	bne	r2,zero,822255c <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222528:	e0bffd47 	ldb	r2,-11(fp)
 822252c:	e0fffd07 	ldb	r3,-12(fp)
 8222530:	180d883a 	mov	r6,r3
 8222534:	100b883a 	mov	r5,r2
 8222538:	01020974 	movhi	r4,2085
 822253c:	213b7b04 	addi	r4,r4,-4628
 8222540:	82030ec0 	call	82030ec <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222544:	e0bffd83 	ldbu	r2,-10(fp)
 8222548:	100b883a 	mov	r5,r2
 822254c:	e13ffe17 	ldw	r4,-8(fp)
 8222550:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 8222554:	00bfff84 	movi	r2,-2
 8222558:	00003c06 	br	822264c <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 822255c:	00800044 	movi	r2,1
 8222560:	d8800015 	stw	r2,0(sp)
 8222564:	01c00044 	movi	r7,1
 8222568:	01800304 	movi	r6,12
 822256c:	000b883a 	mov	r5,zero
 8222570:	e13ffe17 	ldw	r4,-8(fp)
 8222574:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 8222578:	00800044 	movi	r2,1
 822257c:	d8800015 	stw	r2,0(sp)
 8222580:	01c00044 	movi	r7,1
 8222584:	01800244 	movi	r6,9
 8222588:	000b883a 	mov	r5,zero
 822258c:	e13ffe17 	ldw	r4,-8(fp)
 8222590:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 8222594:	e0bffd47 	ldb	r2,-11(fp)
 8222598:	e0fffd07 	ldb	r3,-12(fp)
 822259c:	180d883a 	mov	r6,r3
 82225a0:	100b883a 	mov	r5,r2
 82225a4:	01020974 	movhi	r4,2085
 82225a8:	213b8b04 	addi	r4,r4,-4564
 82225ac:	82030ec0 	call	82030ec <printf>
    
    alt_32 timeout = 0;
 82225b0:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 82225b4:	00001306 	br	8222604 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 82225b8:	e0bffa17 	ldw	r2,-24(fp)
 82225bc:	10c00044 	addi	r3,r2,1
 82225c0:	e0fffa15 	stw	r3,-24(fp)
 82225c4:	1007883a 	mov	r3,r2
 82225c8:	e0bfff17 	ldw	r2,-4(fp)
 82225cc:	10c00d2e 	bgeu	r2,r3,8222604 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 82225d0:	e0bffd47 	ldb	r2,-11(fp)
 82225d4:	e0fffd07 	ldb	r3,-12(fp)
 82225d8:	180d883a 	mov	r6,r3
 82225dc:	100b883a 	mov	r5,r2
 82225e0:	01020974 	movhi	r4,2085
 82225e4:	213b9d04 	addi	r4,r4,-4492
 82225e8:	82030ec0 	call	82030ec <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82225ec:	e0bffd83 	ldbu	r2,-10(fp)
 82225f0:	100b883a 	mov	r5,r2
 82225f4:	e13ffe17 	ldw	r4,-8(fp)
 82225f8:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 82225fc:	00bfffc4 	movi	r2,-1
 8222600:	00001206 	br	822264c <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 8222604:	01c00044 	movi	r7,1
 8222608:	01800144 	movi	r6,5
 822260c:	01400044 	movi	r5,1
 8222610:	e13ffe17 	ldw	r4,-8(fp)
 8222614:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222618:	103fe726 	beq	r2,zero,82225b8 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 822261c:	e0bffd47 	ldb	r2,-11(fp)
 8222620:	e0fffd07 	ldb	r3,-12(fp)
 8222624:	180d883a 	mov	r6,r3
 8222628:	100b883a 	mov	r5,r2
 822262c:	01020974 	movhi	r4,2085
 8222630:	213ba904 	addi	r4,r4,-4444
 8222634:	82030ec0 	call	82030ec <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222638:	e0bffd83 	ldbu	r2,-10(fp)
 822263c:	100b883a 	mov	r5,r2
 8222640:	e13ffe17 	ldw	r4,-8(fp)
 8222644:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 8222648:	0005883a 	mov	r2,zero
}
 822264c:	e037883a 	mov	sp,fp
 8222650:	dfc00117 	ldw	ra,4(sp)
 8222654:	df000017 	ldw	fp,0(sp)
 8222658:	dec00204 	addi	sp,sp,8
 822265c:	f800283a 	ret

08222660 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222660:	defff904 	addi	sp,sp,-28
 8222664:	dfc00615 	stw	ra,24(sp)
 8222668:	df000515 	stw	fp,20(sp)
 822266c:	df000504 	addi	fp,sp,20
 8222670:	e13ffe15 	stw	r4,-8(fp)
 8222674:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222678:	e0bffe17 	ldw	r2,-8(fp)
 822267c:	10800617 	ldw	r2,24(r2)
 8222680:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222684:	e0bffb17 	ldw	r2,-20(fp)
 8222688:	10800317 	ldw	r2,12(r2)
 822268c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222690:	e13ffb17 	ldw	r4,-20(fp)
 8222694:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 8222698:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 822269c:	e13ffc17 	ldw	r4,-16(fp)
 82226a0:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 82226a4:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82226a8:	e13ffe17 	ldw	r4,-8(fp)
 82226ac:	8220e140 	call	8220e14 <alt_tse_phy_rd_mdio_addr>
 82226b0:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82226b4:	e0bffe17 	ldw	r2,-8(fp)
 82226b8:	10800003 	ldbu	r2,0(r2)
 82226bc:	10803fcc 	andi	r2,r2,255
 82226c0:	100b883a 	mov	r5,r2
 82226c4:	e13ffe17 	ldw	r4,-8(fp)
 82226c8:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 82226cc:	e0bffd47 	ldb	r2,-11(fp)
 82226d0:	e0fffd07 	ldb	r3,-12(fp)
 82226d4:	180d883a 	mov	r6,r3
 82226d8:	100b883a 	mov	r5,r2
 82226dc:	01020974 	movhi	r4,2085
 82226e0:	213bb504 	addi	r4,r4,-4396
 82226e4:	82030ec0 	call	82030ec <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 82226e8:	01c00044 	movi	r7,1
 82226ec:	01800384 	movi	r6,14
 82226f0:	000b883a 	mov	r5,zero
 82226f4:	e13ffe17 	ldw	r4,-8(fp)
 82226f8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82226fc:	1000061e 	bne	r2,zero,8222718 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 8222700:	01c00044 	movi	r7,1
 8222704:	01800144 	movi	r6,5
 8222708:	01400044 	movi	r5,1
 822270c:	e13ffe17 	ldw	r4,-8(fp)
 8222710:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 8222714:	1000191e 	bne	r2,zero,822277c <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 8222718:	e0bffd47 	ldb	r2,-11(fp)
 822271c:	e0fffd07 	ldb	r3,-12(fp)
 8222720:	180d883a 	mov	r6,r3
 8222724:	100b883a 	mov	r5,r2
 8222728:	01020974 	movhi	r4,2085
 822272c:	213bc004 	addi	r4,r4,-4352
 8222730:	82030ec0 	call	82030ec <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 8222734:	e17fff17 	ldw	r5,-4(fp)
 8222738:	e13ffe17 	ldw	r4,-8(fp)
 822273c:	82224a40 	call	82224a4 <alt_tse_phy_restart_an>
 8222740:	10bfffd8 	cmpnei	r2,r2,-1
 8222744:	10000d1e 	bne	r2,zero,822277c <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 8222748:	e0bffd47 	ldb	r2,-11(fp)
 822274c:	e0fffd07 	ldb	r3,-12(fp)
 8222750:	180d883a 	mov	r6,r3
 8222754:	100b883a 	mov	r5,r2
 8222758:	01020974 	movhi	r4,2085
 822275c:	213bd404 	addi	r4,r4,-4272
 8222760:	82030ec0 	call	82030ec <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222764:	e0bffd83 	ldbu	r2,-10(fp)
 8222768:	100b883a 	mov	r5,r2
 822276c:	e13ffe17 	ldw	r4,-8(fp)
 8222770:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 8222774:	00bfffc4 	movi	r2,-1
 8222778:	00000c06 	br	82227ac <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 822277c:	e0bffd47 	ldb	r2,-11(fp)
 8222780:	e0fffd07 	ldb	r3,-12(fp)
 8222784:	180d883a 	mov	r6,r3
 8222788:	100b883a 	mov	r5,r2
 822278c:	01020974 	movhi	r4,2085
 8222790:	213be104 	addi	r4,r4,-4220
 8222794:	82030ec0 	call	82030ec <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222798:	e0bffd83 	ldbu	r2,-10(fp)
 822279c:	100b883a 	mov	r5,r2
 82227a0:	e13ffe17 	ldw	r4,-8(fp)
 82227a4:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 82227a8:	0005883a 	mov	r2,zero
}
 82227ac:	e037883a 	mov	sp,fp
 82227b0:	dfc00117 	ldw	ra,4(sp)
 82227b4:	df000017 	ldw	fp,0(sp)
 82227b8:	dec00204 	addi	sp,sp,8
 82227bc:	f800283a 	ret

082227c0 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 82227c0:	defff904 	addi	sp,sp,-28
 82227c4:	dfc00615 	stw	ra,24(sp)
 82227c8:	df000515 	stw	fp,20(sp)
 82227cc:	df000504 	addi	fp,sp,20
 82227d0:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 82227d4:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82227d8:	e0bfff17 	ldw	r2,-4(fp)
 82227dc:	10800617 	ldw	r2,24(r2)
 82227e0:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82227e4:	e0bffc17 	ldw	r2,-16(fp)
 82227e8:	10800317 	ldw	r2,12(r2)
 82227ec:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82227f0:	e13ffc17 	ldw	r4,-16(fp)
 82227f4:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 82227f8:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 82227fc:	e13ffd17 	ldw	r4,-12(fp)
 8222800:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 8222804:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222808:	e13fff17 	ldw	r4,-4(fp)
 822280c:	8220e140 	call	8220e14 <alt_tse_phy_rd_mdio_addr>
 8222810:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222814:	e0bfff17 	ldw	r2,-4(fp)
 8222818:	10800003 	ldbu	r2,0(r2)
 822281c:	10803fcc 	andi	r2,r2,255
 8222820:	100b883a 	mov	r5,r2
 8222824:	e13fff17 	ldw	r4,-4(fp)
 8222828:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 822282c:	01c00044 	movi	r7,1
 8222830:	018000c4 	movi	r6,3
 8222834:	01400044 	movi	r5,1
 8222838:	e13fff17 	ldw	r4,-4(fp)
 822283c:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222840:	10000d1e 	bne	r2,zero,8222878 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222844:	e0bffe47 	ldb	r2,-7(fp)
 8222848:	e0fffe07 	ldb	r3,-8(fp)
 822284c:	180d883a 	mov	r6,r3
 8222850:	100b883a 	mov	r5,r2
 8222854:	01020974 	movhi	r4,2085
 8222858:	213b7b04 	addi	r4,r4,-4628
 822285c:	82030ec0 	call	82030ec <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222860:	e0bffe83 	ldbu	r2,-6(fp)
 8222864:	100b883a 	mov	r5,r2
 8222868:	e13fff17 	ldw	r4,-4(fp)
 822286c:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 8222870:	00bfff84 	movi	r2,-2
 8222874:	00013306 	br	8222d44 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8222878:	01400134 	movhi	r5,4
 822287c:	29742404 	addi	r5,r5,-12144
 8222880:	e13fff17 	ldw	r4,-4(fp)
 8222884:	82224a40 	call	82224a4 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 8222888:	01c00044 	movi	r7,1
 822288c:	01800144 	movi	r6,5
 8222890:	01400044 	movi	r5,1
 8222894:	e13fff17 	ldw	r4,-4(fp)
 8222898:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822289c:	1000021e 	bne	r2,zero,82228a8 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 82228a0:	00bfffc4 	movi	r2,-1
 82228a4:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 82228a8:	01c00044 	movi	r7,1
 82228ac:	018003c4 	movi	r6,15
 82228b0:	014003c4 	movi	r5,15
 82228b4:	e13fff17 	ldw	r4,-4(fp)
 82228b8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82228bc:	1007883a 	mov	r3,r2
 82228c0:	e0bfff17 	ldw	r2,-4(fp)
 82228c4:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 82228c8:	01c00044 	movi	r7,1
 82228cc:	01800384 	movi	r6,14
 82228d0:	014003c4 	movi	r5,15
 82228d4:	e13fff17 	ldw	r4,-4(fp)
 82228d8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82228dc:	1007883a 	mov	r3,r2
 82228e0:	e0bfff17 	ldw	r2,-4(fp)
 82228e4:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 82228e8:	01c00044 	movi	r7,1
 82228ec:	01800344 	movi	r6,13
 82228f0:	014003c4 	movi	r5,15
 82228f4:	e13fff17 	ldw	r4,-4(fp)
 82228f8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82228fc:	1007883a 	mov	r3,r2
 8222900:	e0bfff17 	ldw	r2,-4(fp)
 8222904:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8222908:	01c00044 	movi	r7,1
 822290c:	01800304 	movi	r6,12
 8222910:	014003c4 	movi	r5,15
 8222914:	e13fff17 	ldw	r4,-4(fp)
 8222918:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822291c:	1007883a 	mov	r3,r2
 8222920:	e0bfff17 	ldw	r2,-4(fp)
 8222924:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222928:	01c00044 	movi	r7,1
 822292c:	018003c4 	movi	r6,15
 8222930:	01400044 	movi	r5,1
 8222934:	e13fff17 	ldw	r4,-4(fp)
 8222938:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822293c:	1007883a 	mov	r3,r2
 8222940:	e0bfff17 	ldw	r2,-4(fp)
 8222944:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222948:	01c00044 	movi	r7,1
 822294c:	01800384 	movi	r6,14
 8222950:	01400044 	movi	r5,1
 8222954:	e13fff17 	ldw	r4,-4(fp)
 8222958:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822295c:	1007883a 	mov	r3,r2
 8222960:	e0bfff17 	ldw	r2,-4(fp)
 8222964:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8222968:	01c00044 	movi	r7,1
 822296c:	01800344 	movi	r6,13
 8222970:	01400044 	movi	r5,1
 8222974:	e13fff17 	ldw	r4,-4(fp)
 8222978:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822297c:	1007883a 	mov	r3,r2
 8222980:	e0bfff17 	ldw	r2,-4(fp)
 8222984:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 8222988:	01c00044 	movi	r7,1
 822298c:	01800284 	movi	r6,10
 8222990:	01400044 	movi	r5,1
 8222994:	e13fff17 	ldw	r4,-4(fp)
 8222998:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822299c:	1007883a 	mov	r3,r2
 82229a0:	e0bfff17 	ldw	r2,-4(fp)
 82229a4:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 82229a8:	01c00044 	movi	r7,1
 82229ac:	01800244 	movi	r6,9
 82229b0:	01400044 	movi	r5,1
 82229b4:	e13fff17 	ldw	r4,-4(fp)
 82229b8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82229bc:	1007883a 	mov	r3,r2
 82229c0:	e0bfff17 	ldw	r2,-4(fp)
 82229c4:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 82229c8:	01c00044 	movi	r7,1
 82229cc:	01800304 	movi	r6,12
 82229d0:	01400044 	movi	r5,1
 82229d4:	e13fff17 	ldw	r4,-4(fp)
 82229d8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82229dc:	1007883a 	mov	r3,r2
 82229e0:	e0bfff17 	ldw	r2,-4(fp)
 82229e4:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 82229e8:	01c00044 	movi	r7,1
 82229ec:	018002c4 	movi	r6,11
 82229f0:	01400044 	movi	r5,1
 82229f4:	e13fff17 	ldw	r4,-4(fp)
 82229f8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82229fc:	1007883a 	mov	r3,r2
 8222a00:	e0bfff17 	ldw	r2,-4(fp)
 8222a04:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 8222a08:	01c00044 	movi	r7,1
 8222a0c:	018002c4 	movi	r6,11
 8222a10:	01400284 	movi	r5,10
 8222a14:	e13fff17 	ldw	r4,-4(fp)
 8222a18:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222a1c:	1007883a 	mov	r3,r2
 8222a20:	e0bfff17 	ldw	r2,-4(fp)
 8222a24:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 8222a28:	01c00044 	movi	r7,1
 8222a2c:	01800284 	movi	r6,10
 8222a30:	01400284 	movi	r5,10
 8222a34:	e13fff17 	ldw	r4,-4(fp)
 8222a38:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222a3c:	1007883a 	mov	r3,r2
 8222a40:	e0bfff17 	ldw	r2,-4(fp)
 8222a44:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 8222a48:	01c00044 	movi	r7,1
 8222a4c:	01800244 	movi	r6,9
 8222a50:	01400144 	movi	r5,5
 8222a54:	e13fff17 	ldw	r4,-4(fp)
 8222a58:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222a5c:	1007883a 	mov	r3,r2
 8222a60:	e0bfff17 	ldw	r2,-4(fp)
 8222a64:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 8222a68:	01c00044 	movi	r7,1
 8222a6c:	01800204 	movi	r6,8
 8222a70:	01400144 	movi	r5,5
 8222a74:	e13fff17 	ldw	r4,-4(fp)
 8222a78:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222a7c:	1007883a 	mov	r3,r2
 8222a80:	e0bfff17 	ldw	r2,-4(fp)
 8222a84:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 8222a88:	01c00044 	movi	r7,1
 8222a8c:	018001c4 	movi	r6,7
 8222a90:	01400144 	movi	r5,5
 8222a94:	e13fff17 	ldw	r4,-4(fp)
 8222a98:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222a9c:	1007883a 	mov	r3,r2
 8222aa0:	e0bfff17 	ldw	r2,-4(fp)
 8222aa4:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 8222aa8:	01c00044 	movi	r7,1
 8222aac:	01800184 	movi	r6,6
 8222ab0:	01400144 	movi	r5,5
 8222ab4:	e13fff17 	ldw	r4,-4(fp)
 8222ab8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222abc:	1007883a 	mov	r3,r2
 8222ac0:	e0bfff17 	ldw	r2,-4(fp)
 8222ac4:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 8222ac8:	01c00044 	movi	r7,1
 8222acc:	01800144 	movi	r6,5
 8222ad0:	01400144 	movi	r5,5
 8222ad4:	e13fff17 	ldw	r4,-4(fp)
 8222ad8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222adc:	1007883a 	mov	r3,r2
 8222ae0:	e0bfff17 	ldw	r2,-4(fp)
 8222ae4:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 8222ae8:	e0bffe47 	ldb	r2,-7(fp)
 8222aec:	e0fffe07 	ldb	r3,-8(fp)
 8222af0:	180d883a 	mov	r6,r3
 8222af4:	100b883a 	mov	r5,r2
 8222af8:	01020974 	movhi	r4,2085
 8222afc:	213bec04 	addi	r4,r4,-4176
 8222b00:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 8222b04:	e0bfff17 	ldw	r2,-4(fp)
 8222b08:	10800043 	ldbu	r2,1(r2)
 8222b0c:	10803fcc 	andi	r2,r2,255
 8222b10:	100b883a 	mov	r5,r2
 8222b14:	01020974 	movhi	r4,2085
 8222b18:	213bf704 	addi	r4,r4,-4132
 8222b1c:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 8222b20:	e0bfff17 	ldw	r2,-4(fp)
 8222b24:	10800083 	ldbu	r2,2(r2)
 8222b28:	10803fcc 	andi	r2,r2,255
 8222b2c:	100b883a 	mov	r5,r2
 8222b30:	01020974 	movhi	r4,2085
 8222b34:	213c0104 	addi	r4,r4,-4092
 8222b38:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 8222b3c:	e0bfff17 	ldw	r2,-4(fp)
 8222b40:	108000c3 	ldbu	r2,3(r2)
 8222b44:	10803fcc 	andi	r2,r2,255
 8222b48:	100b883a 	mov	r5,r2
 8222b4c:	01020974 	movhi	r4,2085
 8222b50:	213c0b04 	addi	r4,r4,-4052
 8222b54:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 8222b58:	e0bfff17 	ldw	r2,-4(fp)
 8222b5c:	10800103 	ldbu	r2,4(r2)
 8222b60:	10803fcc 	andi	r2,r2,255
 8222b64:	100b883a 	mov	r5,r2
 8222b68:	01020974 	movhi	r4,2085
 8222b6c:	213c1504 	addi	r4,r4,-4012
 8222b70:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 8222b74:	e0bfff17 	ldw	r2,-4(fp)
 8222b78:	10800143 	ldbu	r2,5(r2)
 8222b7c:	10803fcc 	andi	r2,r2,255
 8222b80:	100b883a 	mov	r5,r2
 8222b84:	01020974 	movhi	r4,2085
 8222b88:	213c1f04 	addi	r4,r4,-3972
 8222b8c:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 8222b90:	e0bfff17 	ldw	r2,-4(fp)
 8222b94:	10800183 	ldbu	r2,6(r2)
 8222b98:	10803fcc 	andi	r2,r2,255
 8222b9c:	100b883a 	mov	r5,r2
 8222ba0:	01020974 	movhi	r4,2085
 8222ba4:	213c2904 	addi	r4,r4,-3932
 8222ba8:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 8222bac:	e0bfff17 	ldw	r2,-4(fp)
 8222bb0:	108001c3 	ldbu	r2,7(r2)
 8222bb4:	10803fcc 	andi	r2,r2,255
 8222bb8:	100b883a 	mov	r5,r2
 8222bbc:	01020974 	movhi	r4,2085
 8222bc0:	213c3304 	addi	r4,r4,-3892
 8222bc4:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 8222bc8:	e0bfff17 	ldw	r2,-4(fp)
 8222bcc:	10800203 	ldbu	r2,8(r2)
 8222bd0:	10803fcc 	andi	r2,r2,255
 8222bd4:	100b883a 	mov	r5,r2
 8222bd8:	01020974 	movhi	r4,2085
 8222bdc:	213c3d04 	addi	r4,r4,-3852
 8222be0:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 8222be4:	e0bfff17 	ldw	r2,-4(fp)
 8222be8:	10800243 	ldbu	r2,9(r2)
 8222bec:	10803fcc 	andi	r2,r2,255
 8222bf0:	100b883a 	mov	r5,r2
 8222bf4:	01020974 	movhi	r4,2085
 8222bf8:	213c4704 	addi	r4,r4,-3812
 8222bfc:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 8222c00:	e0bfff17 	ldw	r2,-4(fp)
 8222c04:	10800283 	ldbu	r2,10(r2)
 8222c08:	10803fcc 	andi	r2,r2,255
 8222c0c:	100b883a 	mov	r5,r2
 8222c10:	01020974 	movhi	r4,2085
 8222c14:	213c5104 	addi	r4,r4,-3772
 8222c18:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 8222c1c:	e0bfff17 	ldw	r2,-4(fp)
 8222c20:	108002c3 	ldbu	r2,11(r2)
 8222c24:	10803fcc 	andi	r2,r2,255
 8222c28:	100b883a 	mov	r5,r2
 8222c2c:	01020974 	movhi	r4,2085
 8222c30:	213c5b04 	addi	r4,r4,-3732
 8222c34:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "\n");
 8222c38:	01020974 	movhi	r4,2085
 8222c3c:	213ac104 	addi	r4,r4,-5372
 8222c40:	821eed00 	call	821eed0 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 8222c44:	e0bffe47 	ldb	r2,-7(fp)
 8222c48:	e0fffe07 	ldb	r3,-8(fp)
 8222c4c:	180d883a 	mov	r6,r3
 8222c50:	100b883a 	mov	r5,r2
 8222c54:	01020974 	movhi	r4,2085
 8222c58:	213c6504 	addi	r4,r4,-3692
 8222c5c:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 8222c60:	e0bfff17 	ldw	r2,-4(fp)
 8222c64:	10800303 	ldbu	r2,12(r2)
 8222c68:	10803fcc 	andi	r2,r2,255
 8222c6c:	100b883a 	mov	r5,r2
 8222c70:	01020974 	movhi	r4,2085
 8222c74:	213c0b04 	addi	r4,r4,-4052
 8222c78:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 8222c7c:	e0bfff17 	ldw	r2,-4(fp)
 8222c80:	10800343 	ldbu	r2,13(r2)
 8222c84:	10803fcc 	andi	r2,r2,255
 8222c88:	100b883a 	mov	r5,r2
 8222c8c:	01020974 	movhi	r4,2085
 8222c90:	213c1504 	addi	r4,r4,-4012
 8222c94:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 8222c98:	e0bfff17 	ldw	r2,-4(fp)
 8222c9c:	10800383 	ldbu	r2,14(r2)
 8222ca0:	10803fcc 	andi	r2,r2,255
 8222ca4:	100b883a 	mov	r5,r2
 8222ca8:	01020974 	movhi	r4,2085
 8222cac:	213c1f04 	addi	r4,r4,-3972
 8222cb0:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 8222cb4:	e0bfff17 	ldw	r2,-4(fp)
 8222cb8:	108003c3 	ldbu	r2,15(r2)
 8222cbc:	10803fcc 	andi	r2,r2,255
 8222cc0:	100b883a 	mov	r5,r2
 8222cc4:	01020974 	movhi	r4,2085
 8222cc8:	213c7204 	addi	r4,r4,-3640
 8222ccc:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 8222cd0:	e0bfff17 	ldw	r2,-4(fp)
 8222cd4:	10800403 	ldbu	r2,16(r2)
 8222cd8:	10803fcc 	andi	r2,r2,255
 8222cdc:	100b883a 	mov	r5,r2
 8222ce0:	01020974 	movhi	r4,2085
 8222ce4:	213c7c04 	addi	r4,r4,-3600
 8222ce8:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 8222cec:	e0bfff17 	ldw	r2,-4(fp)
 8222cf0:	10800443 	ldbu	r2,17(r2)
 8222cf4:	10803fcc 	andi	r2,r2,255
 8222cf8:	100b883a 	mov	r5,r2
 8222cfc:	01020974 	movhi	r4,2085
 8222d00:	213c8604 	addi	r4,r4,-3560
 8222d04:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 8222d08:	e0bfff17 	ldw	r2,-4(fp)
 8222d0c:	10800483 	ldbu	r2,18(r2)
 8222d10:	10803fcc 	andi	r2,r2,255
 8222d14:	100b883a 	mov	r5,r2
 8222d18:	01020974 	movhi	r4,2085
 8222d1c:	213c9004 	addi	r4,r4,-3520
 8222d20:	821eed00 	call	821eed0 <no_printf>
    tse_dprintf(6, "\n");
 8222d24:	01020974 	movhi	r4,2085
 8222d28:	213ac104 	addi	r4,r4,-5372
 8222d2c:	821eed00 	call	821eed0 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222d30:	e0bffe83 	ldbu	r2,-6(fp)
 8222d34:	100b883a 	mov	r5,r2
 8222d38:	e13fff17 	ldw	r4,-4(fp)
 8222d3c:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 8222d40:	e0bffb17 	ldw	r2,-20(fp)
    
}
 8222d44:	e037883a 	mov	sp,fp
 8222d48:	dfc00117 	ldw	ra,4(sp)
 8222d4c:	df000017 	ldw	fp,0(sp)
 8222d50:	dec00204 	addi	sp,sp,8
 8222d54:	f800283a 	ret

08222d58 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 8222d58:	defff804 	addi	sp,sp,-32
 8222d5c:	dfc00715 	stw	ra,28(sp)
 8222d60:	df000615 	stw	fp,24(sp)
 8222d64:	df000604 	addi	fp,sp,24
 8222d68:	e13ffe15 	stw	r4,-8(fp)
 8222d6c:	2805883a 	mov	r2,r5
 8222d70:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222d74:	e0bffe17 	ldw	r2,-8(fp)
 8222d78:	10800617 	ldw	r2,24(r2)
 8222d7c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222d80:	e0bffb17 	ldw	r2,-20(fp)
 8222d84:	10800317 	ldw	r2,12(r2)
 8222d88:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222d8c:	e13ffb17 	ldw	r4,-20(fp)
 8222d90:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 8222d94:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222d98:	e13ffc17 	ldw	r4,-16(fp)
 8222d9c:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 8222da0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222da4:	e13ffe17 	ldw	r4,-8(fp)
 8222da8:	8220e140 	call	8220e14 <alt_tse_phy_rd_mdio_addr>
 8222dac:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222db0:	e0bffe17 	ldw	r2,-8(fp)
 8222db4:	10800003 	ldbu	r2,0(r2)
 8222db8:	10803fcc 	andi	r2,r2,255
 8222dbc:	100b883a 	mov	r5,r2
 8222dc0:	e13ffe17 	ldw	r4,-8(fp)
 8222dc4:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8222dc8:	e0bfff03 	ldbu	r2,-4(fp)
 8222dcc:	10002d26 	beq	r2,zero,8222e84 <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 8222dd0:	01c00044 	movi	r7,1
 8222dd4:	01800344 	movi	r6,13
 8222dd8:	014003c4 	movi	r5,15
 8222ddc:	e13ffe17 	ldw	r4,-8(fp)
 8222de0:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222de4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 8222de8:	e0bffdc3 	ldbu	r2,-9(fp)
 8222dec:	d8800015 	stw	r2,0(sp)
 8222df0:	01c00044 	movi	r7,1
 8222df4:	01800244 	movi	r6,9
 8222df8:	01400244 	movi	r5,9
 8222dfc:	e13ffe17 	ldw	r4,-8(fp)
 8222e00:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222e04:	e0bffd47 	ldb	r2,-11(fp)
 8222e08:	e0fffd07 	ldb	r3,-12(fp)
 8222e0c:	e13ffdc3 	ldbu	r4,-9(fp)
 8222e10:	200f883a 	mov	r7,r4
 8222e14:	180d883a 	mov	r6,r3
 8222e18:	100b883a 	mov	r5,r2
 8222e1c:	01020974 	movhi	r4,2085
 8222e20:	213c9a04 	addi	r4,r4,-3480
 8222e24:	821eed00 	call	821eed0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8222e28:	01c00044 	movi	r7,1
 8222e2c:	01800304 	movi	r6,12
 8222e30:	014003c4 	movi	r5,15
 8222e34:	e13ffe17 	ldw	r4,-8(fp)
 8222e38:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222e3c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 8222e40:	e0bffdc3 	ldbu	r2,-9(fp)
 8222e44:	d8800015 	stw	r2,0(sp)
 8222e48:	01c00044 	movi	r7,1
 8222e4c:	01800204 	movi	r6,8
 8222e50:	01400244 	movi	r5,9
 8222e54:	e13ffe17 	ldw	r4,-8(fp)
 8222e58:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222e5c:	e0bffd47 	ldb	r2,-11(fp)
 8222e60:	e0fffd07 	ldb	r3,-12(fp)
 8222e64:	e13ffdc3 	ldbu	r4,-9(fp)
 8222e68:	200f883a 	mov	r7,r4
 8222e6c:	180d883a 	mov	r6,r3
 8222e70:	100b883a 	mov	r5,r2
 8222e74:	01020974 	movhi	r4,2085
 8222e78:	213cad04 	addi	r4,r4,-3404
 8222e7c:	821eed00 	call	821eed0 <no_printf>
 8222e80:	00001c06 	br	8222ef4 <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 8222e84:	d8000015 	stw	zero,0(sp)
 8222e88:	01c00044 	movi	r7,1
 8222e8c:	01800244 	movi	r6,9
 8222e90:	01400244 	movi	r5,9
 8222e94:	e13ffe17 	ldw	r4,-8(fp)
 8222e98:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8222e9c:	e0bffd47 	ldb	r2,-11(fp)
 8222ea0:	e0fffd07 	ldb	r3,-12(fp)
 8222ea4:	000f883a 	mov	r7,zero
 8222ea8:	180d883a 	mov	r6,r3
 8222eac:	100b883a 	mov	r5,r2
 8222eb0:	01020974 	movhi	r4,2085
 8222eb4:	213c9a04 	addi	r4,r4,-3480
 8222eb8:	821eed00 	call	821eed0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 8222ebc:	d8000015 	stw	zero,0(sp)
 8222ec0:	01c00044 	movi	r7,1
 8222ec4:	01800204 	movi	r6,8
 8222ec8:	01400244 	movi	r5,9
 8222ecc:	e13ffe17 	ldw	r4,-8(fp)
 8222ed0:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8222ed4:	e0bffd47 	ldb	r2,-11(fp)
 8222ed8:	e0fffd07 	ldb	r3,-12(fp)
 8222edc:	000f883a 	mov	r7,zero
 8222ee0:	180d883a 	mov	r6,r3
 8222ee4:	100b883a 	mov	r5,r2
 8222ee8:	01020974 	movhi	r4,2085
 8222eec:	213cc004 	addi	r4,r4,-3328
 8222ef0:	821eed00 	call	821eed0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 8222ef4:	e0bffd83 	ldbu	r2,-10(fp)
 8222ef8:	100b883a 	mov	r5,r2
 8222efc:	e13ffe17 	ldw	r4,-8(fp)
 8222f00:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 8222f04:	0005883a 	mov	r2,zero
}
 8222f08:	e037883a 	mov	sp,fp
 8222f0c:	dfc00117 	ldw	ra,4(sp)
 8222f10:	df000017 	ldw	fp,0(sp)
 8222f14:	dec00204 	addi	sp,sp,8
 8222f18:	f800283a 	ret

08222f1c <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 8222f1c:	defff804 	addi	sp,sp,-32
 8222f20:	dfc00715 	stw	ra,28(sp)
 8222f24:	df000615 	stw	fp,24(sp)
 8222f28:	df000604 	addi	fp,sp,24
 8222f2c:	e13ffe15 	stw	r4,-8(fp)
 8222f30:	2805883a 	mov	r2,r5
 8222f34:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222f38:	e0bffe17 	ldw	r2,-8(fp)
 8222f3c:	10800617 	ldw	r2,24(r2)
 8222f40:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222f44:	e0bffb17 	ldw	r2,-20(fp)
 8222f48:	10800317 	ldw	r2,12(r2)
 8222f4c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222f50:	e13ffb17 	ldw	r4,-20(fp)
 8222f54:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 8222f58:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222f5c:	e13ffc17 	ldw	r4,-16(fp)
 8222f60:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 8222f64:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222f68:	e13ffe17 	ldw	r4,-8(fp)
 8222f6c:	8220e140 	call	8220e14 <alt_tse_phy_rd_mdio_addr>
 8222f70:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222f74:	e0bffe17 	ldw	r2,-8(fp)
 8222f78:	10800003 	ldbu	r2,0(r2)
 8222f7c:	10803fcc 	andi	r2,r2,255
 8222f80:	100b883a 	mov	r5,r2
 8222f84:	e13ffe17 	ldw	r4,-8(fp)
 8222f88:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8222f8c:	e0bfff03 	ldbu	r2,-4(fp)
 8222f90:	10004326 	beq	r2,zero,82230a0 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222f94:	01c00044 	movi	r7,1
 8222f98:	018003c4 	movi	r6,15
 8222f9c:	01400044 	movi	r5,1
 8222fa0:	e13ffe17 	ldw	r4,-8(fp)
 8222fa4:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8222fa8:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 8222fac:	e0bffdc3 	ldbu	r2,-9(fp)
 8222fb0:	d8800015 	stw	r2,0(sp)
 8222fb4:	01c00044 	movi	r7,1
 8222fb8:	01800244 	movi	r6,9
 8222fbc:	01400104 	movi	r5,4
 8222fc0:	e13ffe17 	ldw	r4,-8(fp)
 8222fc4:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 8222fc8:	e0bffd47 	ldb	r2,-11(fp)
 8222fcc:	e0fffd07 	ldb	r3,-12(fp)
 8222fd0:	e13ffdc3 	ldbu	r4,-9(fp)
 8222fd4:	200f883a 	mov	r7,r4
 8222fd8:	180d883a 	mov	r6,r3
 8222fdc:	100b883a 	mov	r5,r2
 8222fe0:	01020974 	movhi	r4,2085
 8222fe4:	213cd204 	addi	r4,r4,-3256
 8222fe8:	821eed00 	call	821eed0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222fec:	01c00044 	movi	r7,1
 8222ff0:	01800384 	movi	r6,14
 8222ff4:	01400044 	movi	r5,1
 8222ff8:	e13ffe17 	ldw	r4,-8(fp)
 8222ffc:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8223000:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 8223004:	e0bffdc3 	ldbu	r2,-9(fp)
 8223008:	d8800015 	stw	r2,0(sp)
 822300c:	01c00044 	movi	r7,1
 8223010:	01800204 	movi	r6,8
 8223014:	01400104 	movi	r5,4
 8223018:	e13ffe17 	ldw	r4,-8(fp)
 822301c:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223020:	e0bffd47 	ldb	r2,-11(fp)
 8223024:	e0fffd07 	ldb	r3,-12(fp)
 8223028:	e13ffdc3 	ldbu	r4,-9(fp)
 822302c:	200f883a 	mov	r7,r4
 8223030:	180d883a 	mov	r6,r3
 8223034:	100b883a 	mov	r5,r2
 8223038:	01020974 	movhi	r4,2085
 822303c:	213ce204 	addi	r4,r4,-3192
 8223040:	821eed00 	call	821eed0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8223044:	01c00044 	movi	r7,1
 8223048:	01800344 	movi	r6,13
 822304c:	01400044 	movi	r5,1
 8223050:	e13ffe17 	ldw	r4,-8(fp)
 8223054:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8223058:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 822305c:	e0bffdc3 	ldbu	r2,-9(fp)
 8223060:	d8800015 	stw	r2,0(sp)
 8223064:	01c00044 	movi	r7,1
 8223068:	018001c4 	movi	r6,7
 822306c:	01400104 	movi	r5,4
 8223070:	e13ffe17 	ldw	r4,-8(fp)
 8223074:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223078:	e0bffd47 	ldb	r2,-11(fp)
 822307c:	e0fffd07 	ldb	r3,-12(fp)
 8223080:	e13ffdc3 	ldbu	r4,-9(fp)
 8223084:	200f883a 	mov	r7,r4
 8223088:	180d883a 	mov	r6,r3
 822308c:	100b883a 	mov	r5,r2
 8223090:	01020974 	movhi	r4,2085
 8223094:	213cf504 	addi	r4,r4,-3116
 8223098:	821eed00 	call	821eed0 <no_printf>
 822309c:	00002a06 	br	8223148 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 82230a0:	d8000015 	stw	zero,0(sp)
 82230a4:	01c00044 	movi	r7,1
 82230a8:	01800244 	movi	r6,9
 82230ac:	01400104 	movi	r5,4
 82230b0:	e13ffe17 	ldw	r4,-8(fp)
 82230b4:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 82230b8:	e0bffd47 	ldb	r2,-11(fp)
 82230bc:	e0fffd07 	ldb	r3,-12(fp)
 82230c0:	000f883a 	mov	r7,zero
 82230c4:	180d883a 	mov	r6,r3
 82230c8:	100b883a 	mov	r5,r2
 82230cc:	01020974 	movhi	r4,2085
 82230d0:	213cd204 	addi	r4,r4,-3256
 82230d4:	821eed00 	call	821eed0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 82230d8:	d8000015 	stw	zero,0(sp)
 82230dc:	01c00044 	movi	r7,1
 82230e0:	01800204 	movi	r6,8
 82230e4:	01400104 	movi	r5,4
 82230e8:	e13ffe17 	ldw	r4,-8(fp)
 82230ec:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82230f0:	e0bffd47 	ldb	r2,-11(fp)
 82230f4:	e0fffd07 	ldb	r3,-12(fp)
 82230f8:	000f883a 	mov	r7,zero
 82230fc:	180d883a 	mov	r6,r3
 8223100:	100b883a 	mov	r5,r2
 8223104:	01020974 	movhi	r4,2085
 8223108:	213ce204 	addi	r4,r4,-3192
 822310c:	821eed00 	call	821eed0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 8223110:	d8000015 	stw	zero,0(sp)
 8223114:	01c00044 	movi	r7,1
 8223118:	018001c4 	movi	r6,7
 822311c:	01400104 	movi	r5,4
 8223120:	e13ffe17 	ldw	r4,-8(fp)
 8223124:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223128:	e0bffd47 	ldb	r2,-11(fp)
 822312c:	e0fffd07 	ldb	r3,-12(fp)
 8223130:	000f883a 	mov	r7,zero
 8223134:	180d883a 	mov	r6,r3
 8223138:	100b883a 	mov	r5,r2
 822313c:	01020974 	movhi	r4,2085
 8223140:	213cf504 	addi	r4,r4,-3116
 8223144:	821eed00 	call	821eed0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 8223148:	e0bffd83 	ldbu	r2,-10(fp)
 822314c:	100b883a 	mov	r5,r2
 8223150:	e13ffe17 	ldw	r4,-8(fp)
 8223154:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 8223158:	0005883a 	mov	r2,zero
}
 822315c:	e037883a 	mov	sp,fp
 8223160:	dfc00117 	ldw	ra,4(sp)
 8223164:	df000017 	ldw	fp,0(sp)
 8223168:	dec00204 	addi	sp,sp,8
 822316c:	f800283a 	ret

08223170 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 8223170:	defff504 	addi	sp,sp,-44
 8223174:	dfc00a15 	stw	ra,40(sp)
 8223178:	df000915 	stw	fp,36(sp)
 822317c:	df000904 	addi	fp,sp,36
 8223180:	e13ffe15 	stw	r4,-8(fp)
 8223184:	2805883a 	mov	r2,r5
 8223188:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 822318c:	e0bffe17 	ldw	r2,-8(fp)
 8223190:	10800617 	ldw	r2,24(r2)
 8223194:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223198:	e0bff817 	ldw	r2,-32(fp)
 822319c:	10800317 	ldw	r2,12(r2)
 82231a0:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82231a4:	e13ff817 	ldw	r4,-32(fp)
 82231a8:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 82231ac:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82231b0:	e13ff917 	ldw	r4,-28(fp)
 82231b4:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 82231b8:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82231bc:	e13ffe17 	ldw	r4,-8(fp)
 82231c0:	8220e140 	call	8220e14 <alt_tse_phy_rd_mdio_addr>
 82231c4:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82231c8:	e0bffe17 	ldw	r2,-8(fp)
 82231cc:	10800003 	ldbu	r2,0(r2)
 82231d0:	10803fcc 	andi	r2,r2,255
 82231d4:	100b883a 	mov	r5,r2
 82231d8:	e13ffe17 	ldw	r4,-8(fp)
 82231dc:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 82231e0:	e0bfff03 	ldbu	r2,-4(fp)
 82231e4:	10002926 	beq	r2,zero,822328c <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 82231e8:	01c00044 	movi	r7,1
 82231ec:	01800304 	movi	r6,12
 82231f0:	01400044 	movi	r5,1
 82231f4:	e13ffe17 	ldw	r4,-8(fp)
 82231f8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82231fc:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 8223200:	e0bffd03 	ldbu	r2,-12(fp)
 8223204:	d8800015 	stw	r2,0(sp)
 8223208:	01c00044 	movi	r7,1
 822320c:	01800184 	movi	r6,6
 8223210:	01400104 	movi	r5,4
 8223214:	e13ffe17 	ldw	r4,-8(fp)
 8223218:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822321c:	e0bffd03 	ldbu	r2,-12(fp)
 8223220:	100f883a 	mov	r7,r2
 8223224:	e1bffa17 	ldw	r6,-24(fp)
 8223228:	e17ffb17 	ldw	r5,-20(fp)
 822322c:	01020974 	movhi	r4,2085
 8223230:	213d0804 	addi	r4,r4,-3040
 8223234:	821eed00 	call	821eed0 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8223238:	01c00044 	movi	r7,1
 822323c:	018002c4 	movi	r6,11
 8223240:	01400044 	movi	r5,1
 8223244:	e13ffe17 	ldw	r4,-8(fp)
 8223248:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 822324c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 8223250:	e0bffd03 	ldbu	r2,-12(fp)
 8223254:	d8800015 	stw	r2,0(sp)
 8223258:	01c00044 	movi	r7,1
 822325c:	01800144 	movi	r6,5
 8223260:	01400104 	movi	r5,4
 8223264:	e13ffe17 	ldw	r4,-8(fp)
 8223268:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822326c:	e0bffd03 	ldbu	r2,-12(fp)
 8223270:	100f883a 	mov	r7,r2
 8223274:	e1bffa17 	ldw	r6,-24(fp)
 8223278:	e17ffb17 	ldw	r5,-20(fp)
 822327c:	01020974 	movhi	r4,2085
 8223280:	213d1b04 	addi	r4,r4,-2964
 8223284:	821eed00 	call	821eed0 <no_printf>
 8223288:	00001806 	br	82232ec <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 822328c:	d8000015 	stw	zero,0(sp)
 8223290:	01c00044 	movi	r7,1
 8223294:	01800184 	movi	r6,6
 8223298:	01400104 	movi	r5,4
 822329c:	e13ffe17 	ldw	r4,-8(fp)
 82232a0:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82232a4:	000f883a 	mov	r7,zero
 82232a8:	e1bffa17 	ldw	r6,-24(fp)
 82232ac:	e17ffb17 	ldw	r5,-20(fp)
 82232b0:	01020974 	movhi	r4,2085
 82232b4:	213d0804 	addi	r4,r4,-3040
 82232b8:	821eed00 	call	821eed0 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 82232bc:	d8000015 	stw	zero,0(sp)
 82232c0:	01c00044 	movi	r7,1
 82232c4:	01800144 	movi	r6,5
 82232c8:	01400104 	movi	r5,4
 82232cc:	e13ffe17 	ldw	r4,-8(fp)
 82232d0:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82232d4:	000f883a 	mov	r7,zero
 82232d8:	e1bffa17 	ldw	r6,-24(fp)
 82232dc:	e17ffb17 	ldw	r5,-20(fp)
 82232e0:	01020974 	movhi	r4,2085
 82232e4:	213d1b04 	addi	r4,r4,-2964
 82232e8:	821eed00 	call	821eed0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82232ec:	e0bffc17 	ldw	r2,-16(fp)
 82232f0:	10803fcc 	andi	r2,r2,255
 82232f4:	100b883a 	mov	r5,r2
 82232f8:	e13ffe17 	ldw	r4,-8(fp)
 82232fc:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 8223300:	0005883a 	mov	r2,zero
}
 8223304:	e037883a 	mov	sp,fp
 8223308:	dfc00117 	ldw	ra,4(sp)
 822330c:	df000017 	ldw	fp,0(sp)
 8223310:	dec00204 	addi	sp,sp,8
 8223314:	f800283a 	ret

08223318 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 8223318:	defff604 	addi	sp,sp,-40
 822331c:	dfc00915 	stw	ra,36(sp)
 8223320:	df000815 	stw	fp,32(sp)
 8223324:	df000804 	addi	fp,sp,32
 8223328:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 822332c:	00800044 	movi	r2,1
 8223330:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 8223334:	00800044 	movi	r2,1
 8223338:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 822333c:	00800044 	movi	r2,1
 8223340:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 8223344:	00800044 	movi	r2,1
 8223348:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 822334c:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 8223350:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223354:	e13fff17 	ldw	r4,-4(fp)
 8223358:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 822335c:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 8223360:	e03ff815 	stw	zero,-32(fp)
 8223364:	00001c06 	br	82233d8 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 8223368:	e0ffff17 	ldw	r3,-4(fp)
 822336c:	e0bff817 	ldw	r2,-32(fp)
 8223370:	10800044 	addi	r2,r2,1
 8223374:	1085883a 	add	r2,r2,r2
 8223378:	1085883a 	add	r2,r2,r2
 822337c:	1885883a 	add	r2,r3,r2
 8223380:	10800017 	ldw	r2,0(r2)
 8223384:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223388:	e0bffc17 	ldw	r2,-16(fp)
 822338c:	10800117 	ldw	r2,4(r2)
 8223390:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 8223394:	e0bffd17 	ldw	r2,-12(fp)
 8223398:	10000926 	beq	r2,zero,82233c0 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 822339c:	01400044 	movi	r5,1
 82233a0:	e13ffd17 	ldw	r4,-12(fp)
 82233a4:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 82233a8:	01400044 	movi	r5,1
 82233ac:	e13ffd17 	ldw	r4,-12(fp)
 82233b0:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 82233b4:	01400044 	movi	r5,1
 82233b8:	e13ffd17 	ldw	r4,-12(fp)
 82233bc:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 82233c0:	01020974 	movhi	r4,2085
 82233c4:	213ac104 	addi	r4,r4,-5372
 82233c8:	821eed00 	call	821eed0 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 82233cc:	e0bff817 	ldw	r2,-32(fp)
 82233d0:	10800044 	addi	r2,r2,1
 82233d4:	e0bff815 	stw	r2,-32(fp)
 82233d8:	e0bfff17 	ldw	r2,-4(fp)
 82233dc:	10800003 	ldbu	r2,0(r2)
 82233e0:	10803fcc 	andi	r2,r2,255
 82233e4:	e0fff817 	ldw	r3,-32(fp)
 82233e8:	18bfdf16 	blt	r3,r2,8223368 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82233ec:	e03ff815 	stw	zero,-32(fp)
 82233f0:	00005606 	br	822354c <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 82233f4:	e0ffff17 	ldw	r3,-4(fp)
 82233f8:	e0bff817 	ldw	r2,-32(fp)
 82233fc:	10800044 	addi	r2,r2,1
 8223400:	1085883a 	add	r2,r2,r2
 8223404:	1085883a 	add	r2,r2,r2
 8223408:	1885883a 	add	r2,r3,r2
 822340c:	10800017 	ldw	r2,0(r2)
 8223410:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223414:	e0bffc17 	ldw	r2,-16(fp)
 8223418:	10800117 	ldw	r2,4(r2)
 822341c:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223420:	e0bffd17 	ldw	r2,-12(fp)
 8223424:	10004326 	beq	r2,zero,8223534 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 8223428:	e13ffd17 	ldw	r4,-12(fp)
 822342c:	82227c00 	call	82227c0 <alt_tse_phy_get_cap>
 8223430:	1000421e 	bne	r2,zero,822353c <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 8223434:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8223438:	e0bffc17 	ldw	r2,-16(fp)
 822343c:	10800003 	ldbu	r2,0(r2)
 8223440:	10803fcc 	andi	r2,r2,255
 8223444:	10800058 	cmpnei	r2,r2,1
 8223448:	1000021e 	bne	r2,zero,8223454 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 822344c:	e03ff905 	stb	zero,-28(fp)
 8223450:	00000706 	br	8223470 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8223454:	e0bffc17 	ldw	r2,-16(fp)
 8223458:	10800003 	ldbu	r2,0(r2)
 822345c:	10803fcc 	andi	r2,r2,255
 8223460:	10800098 	cmpnei	r2,r2,2
 8223464:	1000021e 	bne	r2,zero,8223470 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 8223468:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 822346c:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 8223470:	e0bffd17 	ldw	r2,-12(fp)
 8223474:	10c000c3 	ldbu	r3,3(r2)
 8223478:	e0bffd17 	ldw	r2,-12(fp)
 822347c:	10800303 	ldbu	r2,12(r2)
 8223480:	1884703a 	and	r2,r3,r2
 8223484:	1007883a 	mov	r3,r2
 8223488:	e0bff903 	ldbu	r2,-28(fp)
 822348c:	1884703a 	and	r2,r3,r2
 8223490:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 8223494:	e0bffd17 	ldw	r2,-12(fp)
 8223498:	10c00183 	ldbu	r3,6(r2)
 822349c:	e0bffd17 	ldw	r2,-12(fp)
 82234a0:	108003c3 	ldbu	r2,15(r2)
 82234a4:	1884703a 	and	r2,r3,r2
 82234a8:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 82234ac:	e0bffd17 	ldw	r2,-12(fp)
 82234b0:	10c001c3 	ldbu	r3,7(r2)
 82234b4:	e0bffd17 	ldw	r2,-12(fp)
 82234b8:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82234bc:	1884703a 	and	r2,r3,r2
 82234c0:	2084b03a 	or	r2,r4,r2
 82234c4:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 82234c8:	e0bffd17 	ldw	r2,-12(fp)
 82234cc:	10c00143 	ldbu	r3,5(r2)
 82234d0:	e0bffd17 	ldw	r2,-12(fp)
 82234d4:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82234d8:	1884703a 	and	r2,r3,r2
 82234dc:	2084b03a 	or	r2,r4,r2
 82234e0:	1007883a 	mov	r3,r2
 82234e4:	e0bff943 	ldbu	r2,-27(fp)
 82234e8:	1884703a 	and	r2,r3,r2
 82234ec:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 82234f0:	e0bffd17 	ldw	r2,-12(fp)
 82234f4:	10c00283 	ldbu	r3,10(r2)
 82234f8:	e0bffd17 	ldw	r2,-12(fp)
 82234fc:	10800443 	ldbu	r2,17(r2)
 8223500:	1884703a 	and	r2,r3,r2
 8223504:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 8223508:	e0bffd17 	ldw	r2,-12(fp)
 822350c:	10c002c3 	ldbu	r3,11(r2)
 8223510:	e0bffd17 	ldw	r2,-12(fp)
 8223514:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 8223518:	1884703a 	and	r2,r3,r2
 822351c:	2084b03a 	or	r2,r4,r2
 8223520:	1007883a 	mov	r3,r2
 8223524:	e0bff983 	ldbu	r2,-26(fp)
 8223528:	1884703a 	and	r2,r3,r2
 822352c:	e0bff985 	stb	r2,-26(fp)
 8223530:	00000306 	br	8223540 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223534:	0001883a 	nop
 8223538:	00000106 	br	8223540 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 822353c:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223540:	e0bff817 	ldw	r2,-32(fp)
 8223544:	10800044 	addi	r2,r2,1
 8223548:	e0bff815 	stw	r2,-32(fp)
 822354c:	e0bfff17 	ldw	r2,-4(fp)
 8223550:	10800003 	ldbu	r2,0(r2)
 8223554:	10803fcc 	andi	r2,r2,255
 8223558:	e0fff817 	ldw	r3,-32(fp)
 822355c:	18bfa516 	blt	r3,r2,82233f4 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 8223560:	e0bffb03 	ldbu	r2,-20(fp)
 8223564:	10800058 	cmpnei	r2,r2,1
 8223568:	1000081e 	bne	r2,zero,822358c <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 822356c:	00bfffc4 	movi	r2,-1
 8223570:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 8223574:	e0bffe07 	ldb	r2,-8(fp)
 8223578:	100b883a 	mov	r5,r2
 822357c:	01020974 	movhi	r4,2085
 8223580:	213d2e04 	addi	r4,r4,-2888
 8223584:	82030ec0 	call	82030ec <printf>
 8223588:	00002706 	br	8223628 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 822358c:	e0bff903 	ldbu	r2,-28(fp)
 8223590:	10000926 	beq	r2,zero,82235b8 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 8223594:	00800084 	movi	r2,2
 8223598:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 822359c:	e0bffe07 	ldb	r2,-8(fp)
 82235a0:	0180fa04 	movi	r6,1000
 82235a4:	100b883a 	mov	r5,r2
 82235a8:	01020974 	movhi	r4,2085
 82235ac:	213d4004 	addi	r4,r4,-2816
 82235b0:	82030ec0 	call	82030ec <printf>
 82235b4:	00001c06 	br	8223628 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 82235b8:	e0bff943 	ldbu	r2,-27(fp)
 82235bc:	10000926 	beq	r2,zero,82235e4 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 82235c0:	00800044 	movi	r2,1
 82235c4:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 82235c8:	e0bffe07 	ldb	r2,-8(fp)
 82235cc:	01801904 	movi	r6,100
 82235d0:	100b883a 	mov	r5,r2
 82235d4:	01020974 	movhi	r4,2085
 82235d8:	213d4004 	addi	r4,r4,-2816
 82235dc:	82030ec0 	call	82030ec <printf>
 82235e0:	00001106 	br	8223628 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 82235e4:	e0bff983 	ldbu	r2,-26(fp)
 82235e8:	10000826 	beq	r2,zero,822360c <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 82235ec:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 82235f0:	e0bffe07 	ldb	r2,-8(fp)
 82235f4:	01800284 	movi	r6,10
 82235f8:	100b883a 	mov	r5,r2
 82235fc:	01020974 	movhi	r4,2085
 8223600:	213d4004 	addi	r4,r4,-2816
 8223604:	82030ec0 	call	82030ec <printf>
 8223608:	00000706 	br	8223628 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 822360c:	00bfffc4 	movi	r2,-1
 8223610:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 8223614:	e0bffe07 	ldb	r2,-8(fp)
 8223618:	100b883a 	mov	r5,r2
 822361c:	01020974 	movhi	r4,2085
 8223620:	213d4d04 	addi	r4,r4,-2764
 8223624:	82030ec0 	call	82030ec <printf>

    return common_speed;
 8223628:	e0bffa17 	ldw	r2,-24(fp)
}
 822362c:	e037883a 	mov	sp,fp
 8223630:	dfc00117 	ldw	ra,4(sp)
 8223634:	df000017 	ldw	fp,0(sp)
 8223638:	dec00204 	addi	sp,sp,8
 822363c:	f800283a 	ret

08223640 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 8223640:	defff004 	addi	sp,sp,-64
 8223644:	dfc00f15 	stw	ra,60(sp)
 8223648:	df000e15 	stw	fp,56(sp)
 822364c:	dc400d15 	stw	r17,52(sp)
 8223650:	dc000c15 	stw	r16,48(sp)
 8223654:	df000e04 	addi	fp,sp,56
 8223658:	e13ffc15 	stw	r4,-16(fp)
 822365c:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 8223660:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 8223664:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 8223668:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 822366c:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223670:	e13ffc17 	ldw	r4,-16(fp)
 8223674:	82200540 	call	8220054 <alt_tse_get_mac_group_index>
 8223678:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 822367c:	e0bffc17 	ldw	r2,-16(fp)
 8223680:	10800117 	ldw	r2,4(r2)
 8223684:	10800217 	ldw	r2,8(r2)
 8223688:	10800017 	ldw	r2,0(r2)
 822368c:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8223690:	e0bff917 	ldw	r2,-28(fp)
 8223694:	10801004 	addi	r2,r2,64
 8223698:	10800037 	ldwio	r2,0(r2)
 822369c:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 82236a0:	e0bffd17 	ldw	r2,-12(fp)
 82236a4:	10000316 	blt	r2,zero,82236b4 <alt_tse_phy_set_common_speed+0x74>
 82236a8:	e0bffd17 	ldw	r2,-12(fp)
 82236ac:	108000d0 	cmplti	r2,r2,3
 82236b0:	10000c1e 	bne	r2,zero,82236e4 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 82236b4:	e0bff847 	ldb	r2,-31(fp)
 82236b8:	e1bffd17 	ldw	r6,-12(fp)
 82236bc:	100b883a 	mov	r5,r2
 82236c0:	01020974 	movhi	r4,2085
 82236c4:	213d5a04 	addi	r4,r4,-2712
 82236c8:	82030ec0 	call	82030ec <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82236cc:	e0bff917 	ldw	r2,-28(fp)
 82236d0:	10801004 	addi	r2,r2,64
 82236d4:	e0fffa17 	ldw	r3,-24(fp)
 82236d8:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 82236dc:	00bfffc4 	movi	r2,-1
 82236e0:	0000fe06 	br	8223adc <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82236e4:	e03ff315 	stw	zero,-52(fp)
 82236e8:	0000dc06 	br	8223a5c <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
 82236ec:	e0fffc17 	ldw	r3,-16(fp)
 82236f0:	e0bff317 	ldw	r2,-52(fp)
 82236f4:	10800044 	addi	r2,r2,1
 82236f8:	1085883a 	add	r2,r2,r2
 82236fc:	1085883a 	add	r2,r2,r2
 8223700:	1885883a 	add	r2,r3,r2
 8223704:	10800017 	ldw	r2,0(r2)
 8223708:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 822370c:	e13ff617 	ldw	r4,-40(fp)
 8223710:	82200c80 	call	82200c8 <alt_tse_get_mac_info_index>
 8223714:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 8223718:	e0bff617 	ldw	r2,-40(fp)
 822371c:	10800117 	ldw	r2,4(r2)
 8223720:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223724:	e0bff517 	ldw	r2,-44(fp)
 8223728:	1000c826 	beq	r2,zero,8223a4c <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 822372c:	e0bff617 	ldw	r2,-40(fp)
 8223730:	10800217 	ldw	r2,8(r2)
 8223734:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223738:	e0bff517 	ldw	r2,-44(fp)
 822373c:	10800003 	ldbu	r2,0(r2)
 8223740:	10803fcc 	andi	r2,r2,255
 8223744:	100b883a 	mov	r5,r2
 8223748:	e13ff517 	ldw	r4,-44(fp)
 822374c:	8220e5c0 	call	8220e5c <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223750:	e0bff517 	ldw	r2,-44(fp)
 8223754:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223758:	10803fcc 	andi	r2,r2,255
 822375c:	10000c1e 	bne	r2,zero,8223790 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223760:	e0bff517 	ldw	r2,-44(fp)
 8223764:	10800103 	ldbu	r2,4(r2)
 8223768:	10803fcc 	andi	r2,r2,255
 822376c:	1000081e 	bne	r2,zero,8223790 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223770:	e0bff517 	ldw	r2,-44(fp)
 8223774:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223778:	10803fcc 	andi	r2,r2,255
 822377c:	1000041e 	bne	r2,zero,8223790 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223780:	e0bff517 	ldw	r2,-44(fp)
 8223784:	10800083 	ldbu	r2,2(r2)
 8223788:	10803fcc 	andi	r2,r2,255
 822378c:	10000226 	beq	r2,zero,8223798 <alt_tse_phy_set_common_speed+0x158>
 8223790:	00800044 	movi	r2,1
 8223794:	00000106 	br	822379c <alt_tse_phy_set_common_speed+0x15c>
 8223798:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 822379c:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 82237a0:	e0bffb03 	ldbu	r2,-20(fp)
 82237a4:	1000101e 	bne	r2,zero,82237e8 <alt_tse_phy_set_common_speed+0x1a8>
 82237a8:	e0bffd17 	ldw	r2,-12(fp)
 82237ac:	10800098 	cmpnei	r2,r2,2
 82237b0:	10000d1e 	bne	r2,zero,82237e8 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 82237b4:	e0bff847 	ldb	r2,-31(fp)
 82237b8:	e0fff807 	ldb	r3,-32(fp)
 82237bc:	180d883a 	mov	r6,r3
 82237c0:	100b883a 	mov	r5,r2
 82237c4:	01020974 	movhi	r4,2085
 82237c8:	213d6e04 	addi	r4,r4,-2632
 82237cc:	82030ec0 	call	82030ec <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82237d0:	e0bff917 	ldw	r2,-28(fp)
 82237d4:	10801004 	addi	r2,r2,64
 82237d8:	e0fffa17 	ldw	r3,-24(fp)
 82237dc:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 82237e0:	00bfffc4 	movi	r2,-1
 82237e4:	0000bd06 	br	8223adc <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 82237e8:	01c00044 	movi	r7,1
 82237ec:	018000c4 	movi	r6,3
 82237f0:	01400044 	movi	r5,1
 82237f4:	e13ff517 	ldw	r4,-44(fp)
 82237f8:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82237fc:	1000141e 	bne	r2,zero,8223850 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 8223800:	e0bffb03 	ldbu	r2,-20(fp)
 8223804:	10000926 	beq	r2,zero,822382c <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 8223808:	e0bffd17 	ldw	r2,-12(fp)
 822380c:	1005d07a 	srai	r2,r2,1
 8223810:	10bfffcc 	andi	r2,r2,65535
 8223814:	d8800015 	stw	r2,0(sp)
 8223818:	01c00044 	movi	r7,1
 822381c:	01800184 	movi	r6,6
 8223820:	000b883a 	mov	r5,zero
 8223824:	e13ff517 	ldw	r4,-44(fp)
 8223828:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 822382c:	e0bffd17 	ldw	r2,-12(fp)
 8223830:	10bfffcc 	andi	r2,r2,65535
 8223834:	d8800015 	stw	r2,0(sp)
 8223838:	01c00044 	movi	r7,1
 822383c:	01800344 	movi	r6,13
 8223840:	000b883a 	mov	r5,zero
 8223844:	e13ff517 	ldw	r4,-44(fp)
 8223848:	8220eb40 	call	8220eb4 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 822384c:	00008006 	br	8223a50 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 8223850:	e0bffd17 	ldw	r2,-12(fp)
 8223854:	10800098 	cmpnei	r2,r2,2
 8223858:	10000a1e 	bne	r2,zero,8223884 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 822385c:	01400044 	movi	r5,1
 8223860:	e13ff517 	ldw	r4,-44(fp)
 8223864:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223868:	01400044 	movi	r5,1
 822386c:	e13ff517 	ldw	r4,-44(fp)
 8223870:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223874:	01400044 	movi	r5,1
 8223878:	e13ff517 	ldw	r4,-44(fp)
 822387c:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
 8223880:	00002206 	br	822390c <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 8223884:	e0bffd17 	ldw	r2,-12(fp)
 8223888:	10800058 	cmpnei	r2,r2,1
 822388c:	10000a1e 	bne	r2,zero,82238b8 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223890:	000b883a 	mov	r5,zero
 8223894:	e13ff517 	ldw	r4,-44(fp)
 8223898:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 822389c:	01400044 	movi	r5,1
 82238a0:	e13ff517 	ldw	r4,-44(fp)
 82238a4:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 82238a8:	01400044 	movi	r5,1
 82238ac:	e13ff517 	ldw	r4,-44(fp)
 82238b0:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
 82238b4:	00001506 	br	822390c <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 82238b8:	e0bffd17 	ldw	r2,-12(fp)
 82238bc:	10000a1e 	bne	r2,zero,82238e8 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 82238c0:	000b883a 	mov	r5,zero
 82238c4:	e13ff517 	ldw	r4,-44(fp)
 82238c8:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 82238cc:	000b883a 	mov	r5,zero
 82238d0:	e13ff517 	ldw	r4,-44(fp)
 82238d4:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 82238d8:	01400044 	movi	r5,1
 82238dc:	e13ff517 	ldw	r4,-44(fp)
 82238e0:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
 82238e4:	00000906 	br	822390c <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 82238e8:	000b883a 	mov	r5,zero
 82238ec:	e13ff517 	ldw	r4,-44(fp)
 82238f0:	8222d580 	call	8222d58 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 82238f4:	000b883a 	mov	r5,zero
 82238f8:	e13ff517 	ldw	r4,-44(fp)
 82238fc:	8222f1c0 	call	8222f1c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 8223900:	000b883a 	mov	r5,zero
 8223904:	e13ff517 	ldw	r4,-44(fp)
 8223908:	82231700 	call	8223170 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 822390c:	01c00044 	movi	r7,1
 8223910:	01800144 	movi	r6,5
 8223914:	01400044 	movi	r5,1
 8223918:	e13ff517 	ldw	r4,-44(fp)
 822391c:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8223920:	10800058 	cmpnei	r2,r2,1
 8223924:	10003b1e 	bne	r2,zero,8223a14 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 8223928:	e0bffb03 	ldbu	r2,-20(fp)
 822392c:	10000f26 	beq	r2,zero,822396c <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8223930:	e0bff517 	ldw	r2,-44(fp)
 8223934:	10800517 	ldw	r2,20(r2)
 8223938:	10801583 	ldbu	r2,86(r2)
 822393c:	10c03fcc 	andi	r3,r2,255
 8223940:	e0bff517 	ldw	r2,-44(fp)
 8223944:	10800517 	ldw	r2,20(r2)
 8223948:	108015c3 	ldbu	r2,87(r2)
 822394c:	10803fcc 	andi	r2,r2,255
 8223950:	01c00084 	movi	r7,2
 8223954:	100d883a 	mov	r6,r2
 8223958:	180b883a 	mov	r5,r3
 822395c:	e13ff517 	ldw	r4,-44(fp)
 8223960:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8223964:	e0bff405 	stb	r2,-48(fp)
 8223968:	00000e06 	br	82239a4 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 822396c:	e0bff517 	ldw	r2,-44(fp)
 8223970:	10800517 	ldw	r2,20(r2)
 8223974:	10801583 	ldbu	r2,86(r2)
 8223978:	10c03fcc 	andi	r3,r2,255
 822397c:	e0bff517 	ldw	r2,-44(fp)
 8223980:	10800517 	ldw	r2,20(r2)
 8223984:	108015c3 	ldbu	r2,87(r2)
 8223988:	10803fcc 	andi	r2,r2,255
 822398c:	01c00044 	movi	r7,1
 8223990:	100d883a 	mov	r6,r2
 8223994:	180b883a 	mov	r5,r3
 8223998:	e13ff517 	ldw	r4,-44(fp)
 822399c:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82239a0:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 82239a4:	e0fff403 	ldbu	r3,-48(fp)
 82239a8:	e0bffd17 	ldw	r2,-12(fp)
 82239ac:	18800426 	beq	r3,r2,82239c0 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 82239b0:	01400134 	movhi	r5,4
 82239b4:	29742404 	addi	r5,r5,-12144
 82239b8:	e13ff517 	ldw	r4,-44(fp)
 82239bc:	82224a40 	call	82224a4 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 82239c0:	e0bff517 	ldw	r2,-44(fp)
 82239c4:	10800517 	ldw	r2,20(r2)
 82239c8:	10801583 	ldbu	r2,86(r2)
 82239cc:	10c03fcc 	andi	r3,r2,255
 82239d0:	e0bff517 	ldw	r2,-44(fp)
 82239d4:	10800517 	ldw	r2,20(r2)
 82239d8:	10801603 	ldbu	r2,88(r2)
 82239dc:	10803fcc 	andi	r2,r2,255
 82239e0:	01c00044 	movi	r7,1
 82239e4:	100d883a 	mov	r6,r2
 82239e8:	180b883a 	mov	r5,r3
 82239ec:	e13ff517 	ldw	r4,-44(fp)
 82239f0:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 82239f4:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 82239f8:	e0bff717 	ldw	r2,-36(fp)
 82239fc:	10800017 	ldw	r2,0(r2)
 8223a00:	1007883a 	mov	r3,r2
 8223a04:	e0bffb43 	ldbu	r2,-19(fp)
 8223a08:	100b883a 	mov	r5,r2
 8223a0c:	1809883a 	mov	r4,r3
 8223a10:	82203000 	call	8220300 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 8223a14:	e43ff847 	ldb	r16,-31(fp)
 8223a18:	e47ff807 	ldb	r17,-32(fp)
 8223a1c:	01c00404 	movi	r7,16
 8223a20:	000d883a 	mov	r6,zero
 8223a24:	01400044 	movi	r5,1
 8223a28:	e13ff517 	ldw	r4,-44(fp)
 8223a2c:	8220fdc0 	call	8220fdc <alt_tse_phy_rd_mdio_reg>
 8223a30:	100f883a 	mov	r7,r2
 8223a34:	880d883a 	mov	r6,r17
 8223a38:	800b883a 	mov	r5,r16
 8223a3c:	01020974 	movhi	r4,2085
 8223a40:	213d8504 	addi	r4,r4,-2540
 8223a44:	82030ec0 	call	82030ec <printf>
 8223a48:	00000106 	br	8223a50 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223a4c:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223a50:	e0bff317 	ldw	r2,-52(fp)
 8223a54:	10800044 	addi	r2,r2,1
 8223a58:	e0bff315 	stw	r2,-52(fp)
 8223a5c:	e0bffc17 	ldw	r2,-16(fp)
 8223a60:	10800003 	ldbu	r2,0(r2)
 8223a64:	10803fcc 	andi	r2,r2,255
 8223a68:	e0fff317 	ldw	r3,-52(fp)
 8223a6c:	18bf1f16 	blt	r3,r2,82236ec <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 8223a70:	e0fff847 	ldb	r3,-31(fp)
 8223a74:	e0bffd17 	ldw	r2,-12(fp)
 8223a78:	108000a0 	cmpeqi	r2,r2,2
 8223a7c:	1000071e 	bne	r2,zero,8223a9c <alt_tse_phy_set_common_speed+0x45c>
 8223a80:	e0bffd17 	ldw	r2,-12(fp)
 8223a84:	10800058 	cmpnei	r2,r2,1
 8223a88:	1000021e 	bne	r2,zero,8223a94 <alt_tse_phy_set_common_speed+0x454>
 8223a8c:	00801904 	movi	r2,100
 8223a90:	00000306 	br	8223aa0 <alt_tse_phy_set_common_speed+0x460>
 8223a94:	00800284 	movi	r2,10
 8223a98:	00000106 	br	8223aa0 <alt_tse_phy_set_common_speed+0x460>
 8223a9c:	0080fa04 	movi	r2,1000
 8223aa0:	100d883a 	mov	r6,r2
 8223aa4:	180b883a 	mov	r5,r3
 8223aa8:	01020974 	movhi	r4,2085
 8223aac:	213d9104 	addi	r4,r4,-2492
 8223ab0:	82030ec0 	call	82030ec <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 8223ab4:	e0bffd17 	ldw	r2,-12(fp)
 8223ab8:	10803fcc 	andi	r2,r2,255
 8223abc:	100b883a 	mov	r5,r2
 8223ac0:	e13ff917 	ldw	r4,-28(fp)
 8223ac4:	82202200 	call	8220220 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223ac8:	e0bff917 	ldw	r2,-28(fp)
 8223acc:	10801004 	addi	r2,r2,64
 8223ad0:	e0fffa17 	ldw	r3,-24(fp)
 8223ad4:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 8223ad8:	e0bffd17 	ldw	r2,-12(fp)
}
 8223adc:	e6fffe04 	addi	sp,fp,-8
 8223ae0:	dfc00317 	ldw	ra,12(sp)
 8223ae4:	df000217 	ldw	fp,8(sp)
 8223ae8:	dc400117 	ldw	r17,4(sp)
 8223aec:	dc000017 	ldw	r16,0(sp)
 8223af0:	dec00404 	addi	sp,sp,16
 8223af4:	f800283a 	ret

08223af8 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 8223af8:	defffc04 	addi	sp,sp,-16
 8223afc:	dfc00315 	stw	ra,12(sp)
 8223b00:	df000215 	stw	fp,8(sp)
 8223b04:	df000204 	addi	fp,sp,8
 8223b08:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 8223b0c:	e0bfff17 	ldw	r2,-4(fp)
 8223b10:	1080a104 	addi	r2,r2,644
 8223b14:	10800037 	ldwio	r2,0(r2)
 8223b18:	1080080c 	andi	r2,r2,32
 8223b1c:	1000161e 	bne	r2,zero,8223b78 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 8223b20:	01020974 	movhi	r4,2085
 8223b24:	213da204 	addi	r4,r4,-2424
 8223b28:	82033700 	call	8203370 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 8223b2c:	e0bfff17 	ldw	r2,-4(fp)
 8223b30:	1080a004 	addi	r2,r2,640
 8223b34:	10801004 	addi	r2,r2,64
 8223b38:	00c01e04 	movi	r3,120
 8223b3c:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 8223b40:	01020974 	movhi	r4,2085
 8223b44:	213dab04 	addi	r4,r4,-2388
 8223b48:	82033700 	call	8203370 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223b4c:	e0bfff17 	ldw	r2,-4(fp)
 8223b50:	1080a004 	addi	r2,r2,640
 8223b54:	10800037 	ldwio	r2,0(r2)
 8223b58:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 8223b5c:	e0bfff17 	ldw	r2,-4(fp)
 8223b60:	1080a004 	addi	r2,r2,640
 8223b64:	e13ffe0b 	ldhu	r4,-8(fp)
 8223b68:	00e00004 	movi	r3,-32768
 8223b6c:	20c6b03a 	or	r3,r4,r3
 8223b70:	18ffffcc 	andi	r3,r3,65535
 8223b74:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 8223b78:	0005883a 	mov	r2,zero
}
 8223b7c:	e037883a 	mov	sp,fp
 8223b80:	dfc00117 	ldw	ra,4(sp)
 8223b84:	df000017 	ldw	fp,0(sp)
 8223b88:	dec00204 	addi	sp,sp,8
 8223b8c:	f800283a 	ret

08223b90 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 8223b90:	defffc04 	addi	sp,sp,-16
 8223b94:	dfc00315 	stw	ra,12(sp)
 8223b98:	df000215 	stw	fp,8(sp)
 8223b9c:	df000204 	addi	fp,sp,8
 8223ba0:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223ba4:	e0bfff17 	ldw	r2,-4(fp)
 8223ba8:	1080bb04 	addi	r2,r2,748
 8223bac:	10800037 	ldwio	r2,0(r2)
 8223bb0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223bb4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223bb8:	00bffc04 	movi	r2,-16
 8223bbc:	1884703a 	and	r2,r3,r2
 8223bc0:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 8223bc4:	01020974 	movhi	r4,2085
 8223bc8:	213db004 	addi	r4,r4,-2368
 8223bcc:	82033700 	call	8203370 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 8223bd0:	e0bfff17 	ldw	r2,-4(fp)
 8223bd4:	1080bb04 	addi	r2,r2,748
 8223bd8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223bdc:	18c003d4 	ori	r3,r3,15
 8223be0:	18ffffcc 	andi	r3,r3,65535
 8223be4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223be8:	01020974 	movhi	r4,2085
 8223bec:	213dbc04 	addi	r4,r4,-2320
 8223bf0:	82033700 	call	8203370 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223bf4:	e0bfff17 	ldw	r2,-4(fp)
 8223bf8:	1080b404 	addi	r2,r2,720
 8223bfc:	10800037 	ldwio	r2,0(r2)
 8223c00:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223c04:	e0fffe0b 	ldhu	r3,-8(fp)
 8223c08:	00bfdf44 	movi	r2,-131
 8223c0c:	1884703a 	and	r2,r3,r2
 8223c10:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223c14:	e0bfff17 	ldw	r2,-4(fp)
 8223c18:	1080b404 	addi	r2,r2,720
 8223c1c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223c20:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223c24:	01020974 	movhi	r4,2085
 8223c28:	213dab04 	addi	r4,r4,-2388
 8223c2c:	82033700 	call	8203370 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223c30:	e0bfff17 	ldw	r2,-4(fp)
 8223c34:	1080a004 	addi	r2,r2,640
 8223c38:	10800037 	ldwio	r2,0(r2)
 8223c3c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223c40:	e0bfff17 	ldw	r2,-4(fp)
 8223c44:	1080a004 	addi	r2,r2,640
 8223c48:	e13ffe0b 	ldhu	r4,-8(fp)
 8223c4c:	00e00004 	movi	r3,-32768
 8223c50:	20c6b03a 	or	r3,r4,r3
 8223c54:	18ffffcc 	andi	r3,r3,65535
 8223c58:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223c5c:	00800044 	movi	r2,1
}
 8223c60:	e037883a 	mov	sp,fp
 8223c64:	dfc00117 	ldw	ra,4(sp)
 8223c68:	df000017 	ldw	fp,0(sp)
 8223c6c:	dec00204 	addi	sp,sp,8
 8223c70:	f800283a 	ret

08223c74 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 8223c74:	defffc04 	addi	sp,sp,-16
 8223c78:	dfc00315 	stw	ra,12(sp)
 8223c7c:	df000215 	stw	fp,8(sp)
 8223c80:	df000204 	addi	fp,sp,8
 8223c84:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223c88:	e0bfff17 	ldw	r2,-4(fp)
 8223c8c:	1080bb04 	addi	r2,r2,748
 8223c90:	10800037 	ldwio	r2,0(r2)
 8223c94:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223c98:	e0fffe0b 	ldhu	r3,-8(fp)
 8223c9c:	00bffc04 	movi	r2,-16
 8223ca0:	1884703a 	and	r2,r3,r2
 8223ca4:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 8223ca8:	01020974 	movhi	r4,2085
 8223cac:	213dc604 	addi	r4,r4,-2280
 8223cb0:	82033700 	call	8203370 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 8223cb4:	e0bfff17 	ldw	r2,-4(fp)
 8223cb8:	1080bb04 	addi	r2,r2,748
 8223cbc:	e0fffe0b 	ldhu	r3,-8(fp)
 8223cc0:	18c00114 	ori	r3,r3,4
 8223cc4:	18ffffcc 	andi	r3,r3,65535
 8223cc8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223ccc:	01020974 	movhi	r4,2085
 8223cd0:	213dbc04 	addi	r4,r4,-2320
 8223cd4:	82033700 	call	8203370 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223cd8:	e0bfff17 	ldw	r2,-4(fp)
 8223cdc:	1080b404 	addi	r2,r2,720
 8223ce0:	10800037 	ldwio	r2,0(r2)
 8223ce4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223ce8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223cec:	00bfdf44 	movi	r2,-131
 8223cf0:	1884703a 	and	r2,r3,r2
 8223cf4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223cf8:	e0bfff17 	ldw	r2,-4(fp)
 8223cfc:	1080b404 	addi	r2,r2,720
 8223d00:	e0fffe0b 	ldhu	r3,-8(fp)
 8223d04:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223d08:	01020974 	movhi	r4,2085
 8223d0c:	213dab04 	addi	r4,r4,-2388
 8223d10:	82033700 	call	8203370 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223d14:	e0bfff17 	ldw	r2,-4(fp)
 8223d18:	1080a004 	addi	r2,r2,640
 8223d1c:	10800037 	ldwio	r2,0(r2)
 8223d20:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223d24:	e0bfff17 	ldw	r2,-4(fp)
 8223d28:	1080a004 	addi	r2,r2,640
 8223d2c:	e13ffe0b 	ldhu	r4,-8(fp)
 8223d30:	00e00004 	movi	r3,-32768
 8223d34:	20c6b03a 	or	r3,r4,r3
 8223d38:	18ffffcc 	andi	r3,r3,65535
 8223d3c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223d40:	00800044 	movi	r2,1
}
 8223d44:	e037883a 	mov	sp,fp
 8223d48:	dfc00117 	ldw	ra,4(sp)
 8223d4c:	df000017 	ldw	fp,0(sp)
 8223d50:	dec00204 	addi	sp,sp,8
 8223d54:	f800283a 	ret

08223d58 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 8223d58:	defffc04 	addi	sp,sp,-16
 8223d5c:	dfc00315 	stw	ra,12(sp)
 8223d60:	df000215 	stw	fp,8(sp)
 8223d64:	df000204 	addi	fp,sp,8
 8223d68:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223d6c:	e0bfff17 	ldw	r2,-4(fp)
 8223d70:	1080bb04 	addi	r2,r2,748
 8223d74:	10800037 	ldwio	r2,0(r2)
 8223d78:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223d7c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223d80:	00bffc04 	movi	r2,-16
 8223d84:	1884703a 	and	r2,r3,r2
 8223d88:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 8223d8c:	01020974 	movhi	r4,2085
 8223d90:	213ddb04 	addi	r4,r4,-2196
 8223d94:	82033700 	call	8203370 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 8223d98:	e0bfff17 	ldw	r2,-4(fp)
 8223d9c:	1080bb04 	addi	r2,r2,748
 8223da0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223da4:	18c002d4 	ori	r3,r3,11
 8223da8:	18ffffcc 	andi	r3,r3,65535
 8223dac:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 8223db0:	01020974 	movhi	r4,2085
 8223db4:	213dea04 	addi	r4,r4,-2136
 8223db8:	82033700 	call	8203370 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 8223dbc:	e0bfff17 	ldw	r2,-4(fp)
 8223dc0:	1080b404 	addi	r2,r2,720
 8223dc4:	10800037 	ldwio	r2,0(r2)
 8223dc8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223dcc:	e0fffe0b 	ldhu	r3,-8(fp)
 8223dd0:	00bfdf44 	movi	r2,-131
 8223dd4:	1884703a 	and	r2,r3,r2
 8223dd8:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 8223ddc:	e0bffe0b 	ldhu	r2,-8(fp)
 8223de0:	10802094 	ori	r2,r2,130
 8223de4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 8223de8:	e0bfff17 	ldw	r2,-4(fp)
 8223dec:	1080b404 	addi	r2,r2,720
 8223df0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223df4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223df8:	01020974 	movhi	r4,2085
 8223dfc:	213dab04 	addi	r4,r4,-2388
 8223e00:	82033700 	call	8203370 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223e04:	e0bfff17 	ldw	r2,-4(fp)
 8223e08:	1080a004 	addi	r2,r2,640
 8223e0c:	10800037 	ldwio	r2,0(r2)
 8223e10:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223e14:	e0bfff17 	ldw	r2,-4(fp)
 8223e18:	1080a004 	addi	r2,r2,640
 8223e1c:	e13ffe0b 	ldhu	r4,-8(fp)
 8223e20:	00e00004 	movi	r3,-32768
 8223e24:	20c6b03a 	or	r3,r4,r3
 8223e28:	18ffffcc 	andi	r3,r3,65535
 8223e2c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223e30:	00800044 	movi	r2,1
    
}
 8223e34:	e037883a 	mov	sp,fp
 8223e38:	dfc00117 	ldw	ra,4(sp)
 8223e3c:	df000017 	ldw	fp,0(sp)
 8223e40:	dec00204 	addi	sp,sp,8
 8223e44:	f800283a 	ret

08223e48 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 8223e48:	defffc04 	addi	sp,sp,-16
 8223e4c:	df000315 	stw	fp,12(sp)
 8223e50:	df000304 	addi	fp,sp,12
 8223e54:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 8223e58:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 8223e5c:	e0bfff17 	ldw	r2,-4(fp)
 8223e60:	1080b004 	addi	r2,r2,704
 8223e64:	10800037 	ldwio	r2,0(r2)
 8223e68:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 8223e6c:	e0bffe17 	ldw	r2,-8(fp)
 8223e70:	1080008c 	andi	r2,r2,2
 8223e74:	10000426 	beq	r2,zero,8223e88 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 8223e78:	e0bffd17 	ldw	r2,-12(fp)
 8223e7c:	10800214 	ori	r2,r2,8
 8223e80:	e0bffd15 	stw	r2,-12(fp)
 8223e84:	00000306 	br	8223e94 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 8223e88:	e0bffd17 	ldw	r2,-12(fp)
 8223e8c:	10800114 	ori	r2,r2,4
 8223e90:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 8223e94:	e0bffe17 	ldw	r2,-8(fp)
 8223e98:	1080010c 	andi	r2,r2,4
 8223e9c:	10000326 	beq	r2,zero,8223eac <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 8223ea0:	e0bffd17 	ldw	r2,-12(fp)
 8223ea4:	10800054 	ori	r2,r2,1
 8223ea8:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 8223eac:	e0bffd17 	ldw	r2,-12(fp)
}
 8223eb0:	e037883a 	mov	sp,fp
 8223eb4:	df000017 	ldw	fp,0(sp)
 8223eb8:	dec00104 	addi	sp,sp,4
 8223ebc:	f800283a 	ret

08223ec0 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 8223ec0:	defffa04 	addi	sp,sp,-24
 8223ec4:	dfc00515 	stw	ra,20(sp)
 8223ec8:	df000415 	stw	fp,16(sp)
 8223ecc:	df000404 	addi	fp,sp,16
 8223ed0:	e13fff15 	stw	r4,-4(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 8223ed4:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_system_info *psys_info = 0;
 8223ed8:	e03ffe15 	stw	zero,-8(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 8223edc:	e03ffc15 	stw	zero,-16(fp)
 8223ee0:	00001106 	br	8223f28 <altera_eth_tse_init+0x68>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 8223ee4:	008209b4 	movhi	r2,2086
 8223ee8:	10b61d04 	addi	r2,r2,-10124
 8223eec:	e0fffc17 	ldw	r3,-16(fp)
 8223ef0:	18c00324 	muli	r3,r3,12
 8223ef4:	10c5883a 	add	r2,r2,r3
 8223ef8:	10c00017 	ldw	r3,0(r2)
 8223efc:	e0bfff17 	ldw	r2,-4(fp)
 8223f00:	1880061e 	bne	r3,r2,8223f1c <altera_eth_tse_init+0x5c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 8223f04:	e0bffc17 	ldw	r2,-16(fp)
 8223f08:	10c00324 	muli	r3,r2,12
 8223f0c:	008209b4 	movhi	r2,2086
 8223f10:	10b61d04 	addi	r2,r2,-10124
 8223f14:	1885883a 	add	r2,r3,r2
 8223f18:	e0bffd15 	stw	r2,-12(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 8223f1c:	e0bffc17 	ldw	r2,-16(fp)
 8223f20:	10800044 	addi	r2,r2,1
 8223f24:	e0bffc15 	stw	r2,-16(fp)
 8223f28:	d0a08003 	ldbu	r2,-32256(gp)
 8223f2c:	10803fcc 	andi	r2,r2,255
 8223f30:	e0fffc17 	ldw	r3,-16(fp)
 8223f34:	18bfeb16 	blt	r3,r2,8223ee4 <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 8223f38:	e0bffd17 	ldw	r2,-12(fp)
 8223f3c:	1000021e 	bne	r2,zero,8223f48 <altera_eth_tse_init+0x88>
        return ENP_HARDWARE;
 8223f40:	00bff744 	movi	r2,-35
 8223f44:	00002706 	br	8223fe4 <altera_eth_tse_init+0x124>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8223f48:	e03ffc15 	stw	zero,-16(fp)
 8223f4c:	00001206 	br	8223f98 <altera_eth_tse_init+0xd8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 8223f50:	00820974 	movhi	r2,2085
 8223f54:	1086d704 	addi	r2,r2,7004
 8223f58:	e0fffc17 	ldw	r3,-16(fp)
 8223f5c:	18c01224 	muli	r3,r3,72
 8223f60:	10c5883a 	add	r2,r2,r3
 8223f64:	10c00017 	ldw	r3,0(r2)
 8223f68:	e0bffd17 	ldw	r2,-12(fp)
 8223f6c:	10800117 	ldw	r2,4(r2)
 8223f70:	1880061e 	bne	r3,r2,8223f8c <altera_eth_tse_init+0xcc>
            psys_info = &tse_mac_device[i];
 8223f74:	e0bffc17 	ldw	r2,-16(fp)
 8223f78:	10c01224 	muli	r3,r2,72
 8223f7c:	00820974 	movhi	r2,2085
 8223f80:	1086d704 	addi	r2,r2,7004
 8223f84:	1885883a 	add	r2,r3,r2
 8223f88:	e0bffe15 	stw	r2,-8(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8223f8c:	e0bffc17 	ldw	r2,-16(fp)
 8223f90:	10800044 	addi	r2,r2,1
 8223f94:	e0bffc15 	stw	r2,-16(fp)
 8223f98:	d0a02d03 	ldbu	r2,-32588(gp)
 8223f9c:	10803fcc 	andi	r2,r2,255
 8223fa0:	e0fffc17 	ldw	r3,-16(fp)
 8223fa4:	18bfea16 	blt	r3,r2,8223f50 <altera_eth_tse_init+0x90>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 8223fa8:	e0bffe17 	ldw	r2,-8(fp)
 8223fac:	1000021e 	bne	r2,zero,8223fb8 <altera_eth_tse_init+0xf8>
        return ENP_HARDWARE;
 8223fb0:	00bff744 	movi	r2,-35
 8223fb4:	00000b06 	br	8223fe4 <altera_eth_tse_init+0x124>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 8223fb8:	e0bfff17 	ldw	r2,-4(fp)
 8223fbc:	11000517 	ldw	r4,20(r2)
 8223fc0:	e0bffd17 	ldw	r2,-12(fp)
 8223fc4:	10800203 	ldbu	r2,8(r2)
 8223fc8:	10803fcc 	andi	r2,r2,255
 8223fcc:	10801224 	muli	r2,r2,72
 8223fd0:	e0fffe17 	ldw	r3,-8(fp)
 8223fd4:	1885883a 	add	r2,r3,r2
 8223fd8:	100b883a 	mov	r5,r2
 8223fdc:	8223ff80 	call	8223ff8 <prep_tse_mac>
    
    return SUCCESS;
 8223fe0:	0005883a 	mov	r2,zero
}
 8223fe4:	e037883a 	mov	sp,fp
 8223fe8:	dfc00117 	ldw	ra,4(sp)
 8223fec:	df000017 	ldw	fp,0(sp)
 8223ff0:	dec00204 	addi	sp,sp,8
 8223ff4:	f800283a 	ret

08223ff8 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 8223ff8:	defffb04 	addi	sp,sp,-20
 8223ffc:	dfc00415 	stw	ra,16(sp)
 8224000:	df000315 	stw	fp,12(sp)
 8224004:	df000304 	addi	fp,sp,12
 8224008:	e13ffe15 	stw	r4,-8(fp)
 822400c:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 8224010:	e17ffe17 	ldw	r5,-8(fp)
 8224014:	01020974 	movhi	r4,2085
 8224018:	213df404 	addi	r4,r4,-2096
 822401c:	82030ec0 	call	82030ec <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 8224020:	008209b4 	movhi	r2,2086
 8224024:	10b62904 	addi	r2,r2,-10076
 8224028:	e0fffe17 	ldw	r3,-8(fp)
 822402c:	18c01324 	muli	r3,r3,76
 8224030:	10c5883a 	add	r2,r2,r3
 8224034:	10800c04 	addi	r2,r2,48
 8224038:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 822403c:	008209b4 	movhi	r2,2086
 8224040:	10b62904 	addi	r2,r2,-10076
 8224044:	e0fffe17 	ldw	r3,-8(fp)
 8224048:	18c01324 	muli	r3,r3,76
 822404c:	10c5883a 	add	r2,r2,r3
 8224050:	10801204 	addi	r2,r2,72
 8224054:	e0ffff17 	ldw	r3,-4(fp)
 8224058:	10c00015 	stw	r3,0(r2)

        ifp = nets[index];
 822405c:	008209b4 	movhi	r2,2086
 8224060:	10b73a04 	addi	r2,r2,-8984
 8224064:	e0fffe17 	ldw	r3,-8(fp)
 8224068:	18c7883a 	add	r3,r3,r3
 822406c:	18c7883a 	add	r3,r3,r3
 8224070:	10c5883a 	add	r2,r2,r3
 8224074:	10800017 	ldw	r2,0(r2)
 8224078:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 822407c:	e0bffd17 	ldw	r2,-12(fp)
 8224080:	10802717 	ldw	r2,156(r2)
 8224084:	00c00084 	movi	r3,2
 8224088:	10c00615 	stw	r3,24(r2)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 822408c:	e0bffd17 	ldw	r2,-12(fp)
 8224090:	10802717 	ldw	r2,156(r2)
 8224094:	00c00084 	movi	r3,2
 8224098:	10c00715 	stw	r3,28(r2)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 822409c:	e0bffd17 	ldw	r2,-12(fp)
 82240a0:	10802717 	ldw	r2,156(r2)
 82240a4:	d0e0a817 	ldw	r3,-32096(gp)
 82240a8:	10c00815 	stw	r3,32(r2)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 82240ac:	e0bffd17 	ldw	r2,-12(fp)
 82240b0:	10c02717 	ldw	r3,156(r2)
 82240b4:	e0bffe17 	ldw	r2,-8(fp)
 82240b8:	10801324 	muli	r2,r2,76
 82240bc:	11000604 	addi	r4,r2,24
 82240c0:	008209b4 	movhi	r2,2086
 82240c4:	10b62904 	addi	r2,r2,-10076
 82240c8:	2085883a 	add	r2,r4,r2
 82240cc:	18800515 	stw	r2,20(r3)
        ifp->n_mib->ifDescr =       "Altera TSE MAC ethernet";
 82240d0:	e0bffd17 	ldw	r2,-12(fp)
 82240d4:	10c02717 	ldw	r3,156(r2)
 82240d8:	00820974 	movhi	r2,2085
 82240dc:	10bdf904 	addi	r2,r2,-2076
 82240e0:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 82240e4:	e0bffd17 	ldw	r2,-12(fp)
 82240e8:	00c00404 	movi	r3,16
 82240ec:	10c00815 	stw	r3,32(r2)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 82240f0:	e0bffd17 	ldw	r2,-12(fp)
 82240f4:	00c00184 	movi	r3,6
 82240f8:	10c01115 	stw	r3,68(r2)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 82240fc:	e0bffd17 	ldw	r2,-12(fp)
 8224100:	10802717 	ldw	r2,156(r2)
 8224104:	00c00184 	movi	r3,6
 8224108:	10c00215 	stw	r3,8(r2)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 822410c:	e0bffd17 	ldw	r2,-12(fp)
 8224110:	00c17a84 	movi	r3,1514
 8224114:	10c00915 	stw	r3,36(r2)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 8224118:	e0fffd17 	ldw	r3,-12(fp)
 822411c:	008208b4 	movhi	r2,2082
 8224120:	10909404 	addi	r2,r2,16976
 8224124:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 8224128:	e0bffd17 	ldw	r2,-12(fp)
 822412c:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 8224130:	e0fffd17 	ldw	r3,-12(fp)
 8224134:	008208b4 	movhi	r2,2082
 8224138:	10932c04 	addi	r2,r2,19632
 822413c:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 8224140:	e0fffd17 	ldw	r3,-12(fp)
 8224144:	008208b4 	movhi	r2,2082
 8224148:	10952004 	addi	r2,r2,21632
 822414c:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 8224150:	e0fffd17 	ldw	r3,-12(fp)
 8224154:	008208b4 	movhi	r2,2082
 8224158:	10951004 	addi	r2,r2,21568
 822415c:	18800715 	stw	r2,28(r3)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 8224160:	e0bffd17 	ldw	r2,-12(fp)
 8224164:	10802a17 	ldw	r2,168(r2)
 8224168:	10c00214 	ori	r3,r2,8
 822416c:	e0bffd17 	ldw	r2,-12(fp)
 8224170:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 8224174:	008209b4 	movhi	r2,2086
 8224178:	10b73a04 	addi	r2,r2,-8984
 822417c:	e0fffe17 	ldw	r3,-8(fp)
 8224180:	18c7883a 	add	r3,r3,r3
 8224184:	18c7883a 	add	r3,r3,r3
 8224188:	10c5883a 	add	r2,r2,r3
 822418c:	10800017 	ldw	r2,0(r2)
 8224190:	10c02717 	ldw	r3,156(r2)
 8224194:	e0bffe17 	ldw	r2,-8(fp)
 8224198:	10801324 	muli	r2,r2,76
 822419c:	11000604 	addi	r4,r2,24
 82241a0:	008209b4 	movhi	r2,2086
 82241a4:	10b62904 	addi	r2,r2,-10076
 82241a8:	2085883a 	add	r2,r4,r2
 82241ac:	18800515 	stw	r2,20(r3)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 82241b0:	e0bffe17 	ldw	r2,-8(fp)
 82241b4:	10801324 	muli	r2,r2,76
 82241b8:	10c00604 	addi	r3,r2,24
 82241bc:	008209b4 	movhi	r2,2086
 82241c0:	10b62904 	addi	r2,r2,-10076
 82241c4:	1885883a 	add	r2,r3,r2
 82241c8:	100b883a 	mov	r5,r2
 82241cc:	e13ffd17 	ldw	r4,-12(fp)
 82241d0:	82010c40 	call	82010c4 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 82241d4:	008209b4 	movhi	r2,2086
 82241d8:	10b62904 	addi	r2,r2,-10076
 82241dc:	e0fffe17 	ldw	r3,-8(fp)
 82241e0:	18c01324 	muli	r3,r3,76
 82241e4:	10c5883a 	add	r2,r2,r3
 82241e8:	e0fffe17 	ldw	r3,-8(fp)
 82241ec:	10c00015 	stw	r3,0(r2)
        tse[index].netp = ifp;
 82241f0:	008209b4 	movhi	r2,2086
 82241f4:	10b62904 	addi	r2,r2,-10076
 82241f8:	e0fffe17 	ldw	r3,-8(fp)
 82241fc:	18c01324 	muli	r3,r3,76
 8224200:	10c5883a 	add	r2,r2,r3
 8224204:	10800804 	addi	r2,r2,32
 8224208:	e0fffd17 	ldw	r3,-12(fp)
 822420c:	10c00015 	stw	r3,0(r2)
        ifp->n_local = (void*)(&tse[index]);
 8224210:	e0bffe17 	ldw	r2,-8(fp)
 8224214:	10c01324 	muli	r3,r2,76
 8224218:	008209b4 	movhi	r2,2086
 822421c:	10b62904 	addi	r2,r2,-10076
 8224220:	1887883a 	add	r3,r3,r2
 8224224:	e0bffd17 	ldw	r2,-12(fp)
 8224228:	10c02815 	stw	r3,160(r2)
    
        index++;
 822422c:	e0bffe17 	ldw	r2,-8(fp)
 8224230:	10800044 	addi	r2,r2,1
 8224234:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 8224238:	e0bffe17 	ldw	r2,-8(fp)
}
 822423c:	e037883a 	mov	sp,fp
 8224240:	dfc00117 	ldw	ra,4(sp)
 8224244:	df000017 	ldw	fp,0(sp)
 8224248:	dec00204 	addi	sp,sp,8
 822424c:	f800283a 	ret

08224250 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 8224250:	defff004 	addi	sp,sp,-64
 8224254:	dfc00f15 	stw	ra,60(sp)
 8224258:	df000e15 	stw	fp,56(sp)
 822425c:	df000e04 	addi	fp,sp,56
 8224260:	e13fff15 	stw	r4,-4(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 8224264:	e03ff815 	stw	zero,-32(fp)
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 8224268:	008209b4 	movhi	r2,2086
 822426c:	10b62904 	addi	r2,r2,-10076
 8224270:	e0ffff17 	ldw	r3,-4(fp)
 8224274:	18c01324 	muli	r3,r3,76
 8224278:	10c5883a 	add	r2,r2,r3
 822427c:	10801204 	addi	r2,r2,72
 8224280:	10800017 	ldw	r2,0(r2)
 8224284:	e0bff915 	stw	r2,-28(fp)
   
   dprintf("[tse_mac_init]\n");
 8224288:	01020974 	movhi	r4,2085
 822428c:	213dff04 	addi	r4,r4,-2052
 8224290:	82033700 	call	8203370 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 8224294:	e0bff917 	ldw	r2,-28(fp)
 8224298:	10800783 	ldbu	r2,30(r2)
 822429c:	10803fcc 	andi	r2,r2,255
 82242a0:	10800058 	cmpnei	r2,r2,1
 82242a4:	10000b1e 	bne	r2,zero,82242d4 <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 82242a8:	e0bff917 	ldw	r2,-28(fp)
 82242ac:	10800817 	ldw	r2,32(r2)
 82242b0:	1009883a 	mov	r4,r2
 82242b4:	008209b4 	movhi	r2,2086
 82242b8:	10b62904 	addi	r2,r2,-10076
 82242bc:	e0ffff17 	ldw	r3,-4(fp)
 82242c0:	18c01324 	muli	r3,r3,76
 82242c4:	10c5883a 	add	r2,r2,r3
 82242c8:	10800f04 	addi	r2,r2,60
 82242cc:	11000015 	stw	r4,0(r2)
 82242d0:	00001206 	br	822431c <tse_mac_init+0xcc>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 82242d4:	01002804 	movi	r4,160
 82242d8:	823c7180 	call	823c718 <alt_uncached_malloc>
 82242dc:	e0bff515 	stw	r2,-44(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82242e0:	00000306 	br	82242f0 <tse_mac_init+0xa0>
        {
            temp_desc++;
 82242e4:	e0bff517 	ldw	r2,-44(fp)
 82242e8:	10800044 	addi	r2,r2,1
 82242ec:	e0bff515 	stw	r2,-44(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82242f0:	e0bff517 	ldw	r2,-44(fp)
 82242f4:	108007cc 	andi	r2,r2,31
 82242f8:	103ffa1e 	bne	r2,zero,82242e4 <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 82242fc:	008209b4 	movhi	r2,2086
 8224300:	10b62904 	addi	r2,r2,-10076
 8224304:	e0ffff17 	ldw	r3,-4(fp)
 8224308:	18c01324 	muli	r3,r3,76
 822430c:	10c5883a 	add	r2,r2,r3
 8224310:	10800f04 	addi	r2,r2,60
 8224314:	e0fff517 	ldw	r3,-44(fp)
 8224318:	10c00015 	stw	r3,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 822431c:	e0bff917 	ldw	r2,-28(fp)
 8224320:	10800517 	ldw	r2,20(r2)
 8224324:	1009883a 	mov	r4,r2
 8224328:	821e7000 	call	821e700 <alt_avalon_sgdma_open>
 822432c:	e0bffa15 	stw	r2,-24(fp)
   
   if(!sgdma_tx_dev) {
 8224330:	e0bffa17 	ldw	r2,-24(fp)
 8224334:	1000051e 	bne	r2,zero,822434c <tse_mac_init+0xfc>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 8224338:	01020974 	movhi	r4,2085
 822433c:	213e0304 	addi	r4,r4,-2036
 8224340:	82033700 	call	8203370 <puts>
      return ENP_RESOURCE;
 8224344:	00bffa84 	movi	r2,-22
 8224348:	00025406 	br	8224c9c <tse_mac_init+0xa4c>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 822434c:	e0bff917 	ldw	r2,-28(fp)
 8224350:	10800617 	ldw	r2,24(r2)
 8224354:	1009883a 	mov	r4,r2
 8224358:	821e7000 	call	821e700 <alt_avalon_sgdma_open>
 822435c:	e0bffb15 	stw	r2,-20(fp)
   if(!sgdma_rx_dev) {
 8224360:	e0bffb17 	ldw	r2,-20(fp)
 8224364:	1000051e 	bne	r2,zero,822437c <tse_mac_init+0x12c>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 8224368:	01020974 	movhi	r4,2085
 822436c:	213e0f04 	addi	r4,r4,-1988
 8224370:	82033700 	call	8203370 <puts>
      return ENP_RESOURCE;
 8224374:	00bffa84 	movi	r2,-22
 8224378:	00024806 	br	8224c9c <tse_mac_init+0xa4c>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 822437c:	e0bfff17 	ldw	r2,-4(fp)
 8224380:	10801324 	muli	r2,r2,76
 8224384:	10c00104 	addi	r3,r2,4
 8224388:	008209b4 	movhi	r2,2086
 822438c:	10b62904 	addi	r2,r2,-10076
 8224390:	1887883a 	add	r3,r3,r2
 8224394:	e0bff917 	ldw	r2,-28(fp)
 8224398:	10800017 	ldw	r2,0(r2)
 822439c:	e13ffa17 	ldw	r4,-24(fp)
 82243a0:	e17ffb17 	ldw	r5,-20(fp)
 82243a4:	d8000015 	stw	zero,0(sp)
 82243a8:	280f883a 	mov	r7,r5
 82243ac:	200d883a 	mov	r6,r4
 82243b0:	100b883a 	mov	r5,r2
 82243b4:	1809883a 	mov	r4,r3
 82243b8:	821ef000 	call	821ef00 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 82243bc:	008209b4 	movhi	r2,2086
 82243c0:	10b62904 	addi	r2,r2,-10076
 82243c4:	e0ffff17 	ldw	r3,-4(fp)
 82243c8:	18c01324 	muli	r3,r3,76
 82243cc:	10c5883a 	add	r2,r2,r3
 82243d0:	10800304 	addi	r2,r2,12
 82243d4:	10800017 	ldw	r2,0(r2)
 82243d8:	10800317 	ldw	r2,12(r2)
 82243dc:	10800404 	addi	r2,r2,16
 82243e0:	00c00074 	movhi	r3,1
 82243e4:	10c00035 	stwio	r3,0(r2)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 82243e8:	008209b4 	movhi	r2,2086
 82243ec:	10b62904 	addi	r2,r2,-10076
 82243f0:	e0ffff17 	ldw	r3,-4(fp)
 82243f4:	18c01324 	muli	r3,r3,76
 82243f8:	10c5883a 	add	r2,r2,r3
 82243fc:	10800304 	addi	r2,r2,12
 8224400:	10800017 	ldw	r2,0(r2)
 8224404:	10800317 	ldw	r2,12(r2)
 8224408:	10800404 	addi	r2,r2,16
 822440c:	0007883a 	mov	r3,zero
 8224410:	10c00035 	stwio	r3,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 8224414:	e0bff917 	ldw	r2,-28(fp)
 8224418:	1080070b 	ldhu	r2,28(r2)
 822441c:	10ffffcc 	andi	r3,r2,65535
 8224420:	008209b4 	movhi	r2,2086
 8224424:	10b62904 	addi	r2,r2,-10076
 8224428:	e13fff17 	ldw	r4,-4(fp)
 822442c:	21001324 	muli	r4,r4,76
 8224430:	1105883a 	add	r2,r2,r4
 8224434:	10800904 	addi	r2,r2,36
 8224438:	10c00015 	stw	r3,0(r2)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 822443c:	008209b4 	movhi	r2,2086
 8224440:	10b62904 	addi	r2,r2,-10076
 8224444:	e0ffff17 	ldw	r3,-4(fp)
 8224448:	18c01324 	muli	r3,r3,76
 822444c:	10c5883a 	add	r2,r2,r3
 8224450:	10800104 	addi	r2,r2,4
 8224454:	10800017 	ldw	r2,0(r2)
 8224458:	1009883a 	mov	r4,r2
 822445c:	822038c0 	call	822038c <getPHYSpeed>
 8224460:	e0bffc15 	stw	r2,-16(fp)
   speed = (result >> 1) & 0x07;
 8224464:	e0bffc17 	ldw	r2,-16(fp)
 8224468:	1005d07a 	srai	r2,r2,1
 822446c:	108001cc 	andi	r2,r2,7
 8224470:	e0bffd15 	stw	r2,-12(fp)
   duplex = result & 0x01;
 8224474:	e0bffc17 	ldw	r2,-16(fp)
 8224478:	1080004c 	andi	r2,r2,1
 822447c:	e0bffe15 	stw	r2,-8(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 8224480:	008209b4 	movhi	r2,2086
 8224484:	10b62904 	addi	r2,r2,-10076
 8224488:	e0ffff17 	ldw	r3,-4(fp)
 822448c:	18c01324 	muli	r3,r3,76
 8224490:	10c5883a 	add	r2,r2,r3
 8224494:	10800104 	addi	r2,r2,4
 8224498:	10800017 	ldw	r2,0(r2)
 822449c:	10800204 	addi	r2,r2,8
 82244a0:	00c800c4 	movi	r3,8195
 82244a4:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 82244a8:	e03ff415 	stw	zero,-48(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 82244ac:	00000506 	br	82244c4 <tse_mac_init+0x274>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 82244b0:	e0bff417 	ldw	r2,-48(fp)
 82244b4:	10c00044 	addi	r3,r2,1
 82244b8:	e0fff415 	stw	r3,-48(fp)
 82244bc:	1089c450 	cmplti	r2,r2,10001
 82244c0:	10000c26 	beq	r2,zero,82244f4 <tse_mac_init+0x2a4>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 82244c4:	008209b4 	movhi	r2,2086
 82244c8:	10b62904 	addi	r2,r2,-10076
 82244cc:	e0ffff17 	ldw	r3,-4(fp)
 82244d0:	18c01324 	muli	r3,r3,76
 82244d4:	10c5883a 	add	r2,r2,r3
 82244d8:	10800104 	addi	r2,r2,4
 82244dc:	10800017 	ldw	r2,0(r2)
 82244e0:	10800204 	addi	r2,r2,8
 82244e4:	10800037 	ldwio	r2,0(r2)
 82244e8:	1088000c 	andi	r2,r2,8192
 82244ec:	103ff01e 	bne	r2,zero,82244b0 <tse_mac_init+0x260>
 82244f0:	00000106 	br	82244f8 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
 82244f4:	0001883a 	nop
     }
   }
   if(x >= 10000) {
 82244f8:	e0bff417 	ldw	r2,-48(fp)
 82244fc:	1089c410 	cmplti	r2,r2,10000
 8224500:	1000031e 	bne	r2,zero,8224510 <tse_mac_init+0x2c0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 8224504:	01020974 	movhi	r4,2085
 8224508:	213e1b04 	addi	r4,r4,-1940
 822450c:	82033700 	call	8203370 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 8224510:	008209b4 	movhi	r2,2086
 8224514:	10b62904 	addi	r2,r2,-10076
 8224518:	e0ffff17 	ldw	r3,-4(fp)
 822451c:	18c01324 	muli	r3,r3,76
 8224520:	10c5883a 	add	r2,r2,r3
 8224524:	10800104 	addi	r2,r2,4
 8224528:	10800017 	ldw	r2,0(r2)
 822452c:	10800204 	addi	r2,r2,8
 8224530:	10800037 	ldwio	r2,0(r2)
 8224534:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) {
 8224538:	e0bff317 	ldw	r2,-52(fp)
 822453c:	108000cc 	andi	r2,r2,3
 8224540:	10000526 	beq	r2,zero,8224558 <tse_mac_init+0x308>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 8224544:	e17ff317 	ldw	r5,-52(fp)
 8224548:	01020974 	movhi	r4,2085
 822454c:	213e2404 	addi	r4,r4,-1904
 8224550:	82030ec0 	call	82030ec <printf>
 8224554:	00000506 	br	822456c <tse_mac_init+0x31c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 8224558:	e1bff317 	ldw	r6,-52(fp)
 822455c:	e17ff417 	ldw	r5,-48(fp)
 8224560:	01020974 	movhi	r4,2085
 8224564:	213e3804 	addi	r4,r4,-1824
 8224568:	82030ec0 	call	82030ec <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 822456c:	e0bff917 	ldw	r2,-28(fp)
 8224570:	10800903 	ldbu	r2,36(r2)
 8224574:	10803fcc 	andi	r2,r2,255
 8224578:	10800058 	cmpnei	r2,r2,1
 822457c:	1000331e 	bne	r2,zero,822464c <tse_mac_init+0x3fc>
      int channel_loop = 0;
 8224580:	e03ff615 	stw	zero,-40(fp)
      int mac_loop = 0;
 8224584:	e03ff715 	stw	zero,-36(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224588:	e03ff615 	stw	zero,-40(fp)
 822458c:	00002b06 	br	822463c <tse_mac_init+0x3ec>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 8224590:	e03ff715 	stw	zero,-36(fp)
 8224594:	00001b06 	br	8224604 <tse_mac_init+0x3b4>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 8224598:	008209b4 	movhi	r2,2086
 822459c:	10b61504 	addi	r2,r2,-10156
 82245a0:	e0fff617 	ldw	r3,-40(fp)
 82245a4:	18c7883a 	add	r3,r3,r3
 82245a8:	18c7883a 	add	r3,r3,r3
 82245ac:	10c5883a 	add	r2,r2,r3
 82245b0:	10c00017 	ldw	r3,0(r2)
 82245b4:	e0bff717 	ldw	r2,-36(fp)
 82245b8:	10800044 	addi	r2,r2,1
 82245bc:	1085883a 	add	r2,r2,r2
 82245c0:	1085883a 	add	r2,r2,r2
 82245c4:	1885883a 	add	r2,r3,r2
 82245c8:	10800017 	ldw	r2,0(r2)
 82245cc:	10c00217 	ldw	r3,8(r2)
 82245d0:	e0bff917 	ldw	r2,-28(fp)
 82245d4:	1880081e 	bne	r3,r2,82245f8 <tse_mac_init+0x3a8>
            tse[iface].channel = mac_loop;
 82245d8:	008209b4 	movhi	r2,2086
 82245dc:	10b62904 	addi	r2,r2,-10076
 82245e0:	e0ffff17 	ldw	r3,-4(fp)
 82245e4:	18c01324 	muli	r3,r3,76
 82245e8:	10c5883a 	add	r2,r2,r3
 82245ec:	10800d04 	addi	r2,r2,52
 82245f0:	e0fff717 	ldw	r3,-36(fp)
 82245f4:	10c00015 	stw	r3,0(r2)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 82245f8:	e0bff717 	ldw	r2,-36(fp)
 82245fc:	10800044 	addi	r2,r2,1
 8224600:	e0bff715 	stw	r2,-36(fp)
 8224604:	008209b4 	movhi	r2,2086
 8224608:	10b61504 	addi	r2,r2,-10156
 822460c:	e0fff617 	ldw	r3,-40(fp)
 8224610:	18c7883a 	add	r3,r3,r3
 8224614:	18c7883a 	add	r3,r3,r3
 8224618:	10c5883a 	add	r2,r2,r3
 822461c:	10800017 	ldw	r2,0(r2)
 8224620:	10800003 	ldbu	r2,0(r2)
 8224624:	10803fcc 	andi	r2,r2,255
 8224628:	e0fff717 	ldw	r3,-36(fp)
 822462c:	18bfda16 	blt	r3,r2,8224598 <tse_mac_init+0x348>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224630:	e0bff617 	ldw	r2,-40(fp)
 8224634:	10800044 	addi	r2,r2,1
 8224638:	e0bff615 	stw	r2,-40(fp)
 822463c:	d0a07f43 	ldbu	r2,-32259(gp)
 8224640:	10803fcc 	andi	r2,r2,255
 8224644:	e0fff617 	ldw	r3,-40(fp)
 8224648:	18bfd116 	blt	r3,r2,8224590 <tse_mac_init+0x340>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 822464c:	e0bff917 	ldw	r2,-28(fp)
 8224650:	10800903 	ldbu	r2,36(r2)
 8224654:	10803fcc 	andi	r2,r2,255
 8224658:	10800058 	cmpnei	r2,r2,1
 822465c:	10000f1e 	bne	r2,zero,822469c <tse_mac_init+0x44c>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 8224660:	e0bff917 	ldw	r2,-28(fp)
 8224664:	10800d17 	ldw	r2,52(r2)
 8224668:	1007883a 	mov	r3,r2
 822466c:	e0bff917 	ldw	r2,-28(fp)
 8224670:	10800f17 	ldw	r2,60(r2)
 8224674:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 8224678:	e0bff917 	ldw	r2,-28(fp)
 822467c:	10800d17 	ldw	r2,52(r2)
 8224680:	10800204 	addi	r2,r2,8
 8224684:	1007883a 	mov	r3,r2
 8224688:	e0bff917 	ldw	r2,-28(fp)
 822468c:	10800f17 	ldw	r2,60(r2)
 8224690:	10bfdd04 	addi	r2,r2,-140
 8224694:	18800035 	stwio	r2,0(r3)
 8224698:	00006006 	br	822481c <tse_mac_init+0x5cc>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 822469c:	008209b4 	movhi	r2,2086
 82246a0:	10b62904 	addi	r2,r2,-10076
 82246a4:	e0ffff17 	ldw	r3,-4(fp)
 82246a8:	18c01324 	muli	r3,r3,76
 82246ac:	10c5883a 	add	r2,r2,r3
 82246b0:	10800104 	addi	r2,r2,4
 82246b4:	10800017 	ldw	r2,0(r2)
 82246b8:	10800504 	addi	r2,r2,20
 82246bc:	00c17b84 	movi	r3,1518
 82246c0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 82246c4:	008209b4 	movhi	r2,2086
 82246c8:	10b62904 	addi	r2,r2,-10076
 82246cc:	e0ffff17 	ldw	r3,-4(fp)
 82246d0:	18c01324 	muli	r3,r3,76
 82246d4:	10c5883a 	add	r2,r2,r3
 82246d8:	10800104 	addi	r2,r2,4
 82246dc:	10800017 	ldw	r2,0(r2)
 82246e0:	10800b04 	addi	r2,r2,44
 82246e4:	00c00204 	movi	r3,8
 82246e8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 82246ec:	008209b4 	movhi	r2,2086
 82246f0:	10b62904 	addi	r2,r2,-10076
 82246f4:	e0ffff17 	ldw	r3,-4(fp)
 82246f8:	18c01324 	muli	r3,r3,76
 82246fc:	10c5883a 	add	r2,r2,r3
 8224700:	10800104 	addi	r2,r2,4
 8224704:	10800017 	ldw	r2,0(r2)
 8224708:	10800c04 	addi	r2,r2,48
 822470c:	00c00204 	movi	r3,8
 8224710:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 8224714:	008209b4 	movhi	r2,2086
 8224718:	10b62904 	addi	r2,r2,-10076
 822471c:	e0ffff17 	ldw	r3,-4(fp)
 8224720:	18c01324 	muli	r3,r3,76
 8224724:	10c5883a 	add	r2,r2,r3
 8224728:	10800104 	addi	r2,r2,4
 822472c:	10800017 	ldw	r2,0(r2)
 8224730:	10800d04 	addi	r2,r2,52
 8224734:	00c00204 	movi	r3,8
 8224738:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 822473c:	008209b4 	movhi	r2,2086
 8224740:	10b62904 	addi	r2,r2,-10076
 8224744:	e0ffff17 	ldw	r3,-4(fp)
 8224748:	18c01324 	muli	r3,r3,76
 822474c:	10c5883a 	add	r2,r2,r3
 8224750:	10800104 	addi	r2,r2,4
 8224754:	10800017 	ldw	r2,0(r2)
 8224758:	10800e04 	addi	r2,r2,56
 822475c:	00c000c4 	movi	r3,3
 8224760:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 8224764:	008209b4 	movhi	r2,2086
 8224768:	10b62904 	addi	r2,r2,-10076
 822476c:	e0ffff17 	ldw	r3,-4(fp)
 8224770:	18c01324 	muli	r3,r3,76
 8224774:	10c5883a 	add	r2,r2,r3
 8224778:	10800104 	addi	r2,r2,4
 822477c:	10800017 	ldw	r2,0(r2)
 8224780:	10800904 	addi	r2,r2,36
 8224784:	e0fff917 	ldw	r3,-28(fp)
 8224788:	18c0010b 	ldhu	r3,4(r3)
 822478c:	18ffffcc 	andi	r3,r3,65535
 8224790:	18fffc04 	addi	r3,r3,-16
 8224794:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 8224798:	008209b4 	movhi	r2,2086
 822479c:	10b62904 	addi	r2,r2,-10076
 82247a0:	e0ffff17 	ldw	r3,-4(fp)
 82247a4:	18c01324 	muli	r3,r3,76
 82247a8:	10c5883a 	add	r2,r2,r3
 82247ac:	10800104 	addi	r2,r2,4
 82247b0:	10800017 	ldw	r2,0(r2)
 82247b4:	10800a04 	addi	r2,r2,40
 82247b8:	0007883a 	mov	r3,zero
 82247bc:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 82247c0:	008209b4 	movhi	r2,2086
 82247c4:	10b62904 	addi	r2,r2,-10076
 82247c8:	e0ffff17 	ldw	r3,-4(fp)
 82247cc:	18c01324 	muli	r3,r3,76
 82247d0:	10c5883a 	add	r2,r2,r3
 82247d4:	10800104 	addi	r2,r2,4
 82247d8:	10800017 	ldw	r2,0(r2)
 82247dc:	10800704 	addi	r2,r2,28
 82247e0:	e0fff917 	ldw	r3,-28(fp)
 82247e4:	18c0018b 	ldhu	r3,6(r3)
 82247e8:	18ffffcc 	andi	r3,r3,65535
 82247ec:	18fffc04 	addi	r3,r3,-16
 82247f0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 82247f4:	008209b4 	movhi	r2,2086
 82247f8:	10b62904 	addi	r2,r2,-10076
 82247fc:	e0ffff17 	ldw	r3,-4(fp)
 8224800:	18c01324 	muli	r3,r3,76
 8224804:	10c5883a 	add	r2,r2,r3
 8224808:	10800104 	addi	r2,r2,4
 822480c:	10800017 	ldw	r2,0(r2)
 8224810:	10800804 	addi	r2,r2,32
 8224814:	0007883a 	mov	r3,zero
 8224818:	10c00035 	stwio	r3,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 822481c:	008209b4 	movhi	r2,2086
 8224820:	10b62904 	addi	r2,r2,-10076
 8224824:	e0ffff17 	ldw	r3,-4(fp)
 8224828:	18c01324 	muli	r3,r3,76
 822482c:	10c5883a 	add	r2,r2,r3
 8224830:	10800104 	addi	r2,r2,4
 8224834:	10800017 	ldw	r2,0(r2)
 8224838:	10803a04 	addi	r2,r2,232
 822483c:	00c00134 	movhi	r3,4
 8224840:	10c00035 	stwio	r3,0(r2)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 8224844:	008209b4 	movhi	r2,2086
 8224848:	10b62904 	addi	r2,r2,-10076
 822484c:	e0ffff17 	ldw	r3,-4(fp)
 8224850:	18c01324 	muli	r3,r3,76
 8224854:	10c5883a 	add	r2,r2,r3
 8224858:	10800104 	addi	r2,r2,4
 822485c:	10800017 	ldw	r2,0(r2)
 8224860:	10803a04 	addi	r2,r2,232
 8224864:	10800037 	ldwio	r2,0(r2)
 8224868:	1080012c 	andhi	r2,r2,4
 822486c:	10001e26 	beq	r2,zero,82248e8 <tse_mac_init+0x698>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 8224870:	008209b4 	movhi	r2,2086
 8224874:	10b62904 	addi	r2,r2,-10076
 8224878:	e0ffff17 	ldw	r3,-4(fp)
 822487c:	18c01324 	muli	r3,r3,76
 8224880:	10c5883a 	add	r2,r2,r3
 8224884:	10800a04 	addi	r2,r2,40
 8224888:	00c00044 	movi	r3,1
 822488c:	10c00015 	stw	r3,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 8224890:	008209b4 	movhi	r2,2086
 8224894:	10b62904 	addi	r2,r2,-10076
 8224898:	e0ffff17 	ldw	r3,-4(fp)
 822489c:	18c01324 	muli	r3,r3,76
 82248a0:	10c5883a 	add	r2,r2,r3
 82248a4:	10800104 	addi	r2,r2,4
 82248a8:	10800017 	ldw	r2,0(r2)
 82248ac:	10803b04 	addi	r2,r2,236
 82248b0:	00c08034 	movhi	r3,512
 82248b4:	10c00035 	stwio	r3,0(r2)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 82248b8:	008209b4 	movhi	r2,2086
 82248bc:	10b62904 	addi	r2,r2,-10076
 82248c0:	e0ffff17 	ldw	r3,-4(fp)
 82248c4:	18c01324 	muli	r3,r3,76
 82248c8:	10c5883a 	add	r2,r2,r3
 82248cc:	10800104 	addi	r2,r2,4
 82248d0:	10800017 	ldw	r2,0(r2)
 82248d4:	10803b04 	addi	r2,r2,236
 82248d8:	10800037 	ldwio	r2,0(r2)
 82248dc:	1080802c 	andhi	r2,r2,512
 82248e0:	10001d26 	beq	r2,zero,8224958 <tse_mac_init+0x708>
 82248e4:	00000d06 	br	822491c <tse_mac_init+0x6cc>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 82248e8:	008209b4 	movhi	r2,2086
 82248ec:	10b62904 	addi	r2,r2,-10076
 82248f0:	e0ffff17 	ldw	r3,-4(fp)
 82248f4:	18c01324 	muli	r3,r3,76
 82248f8:	10c5883a 	add	r2,r2,r3
 82248fc:	10800a04 	addi	r2,r2,40
 8224900:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 8224904:	01400084 	movi	r5,2
 8224908:	01020974 	movhi	r4,2085
 822490c:	213e4004 	addi	r4,r4,-1792
 8224910:	82030ec0 	call	82030ec <printf>
      return ENP_LOGIC;
 8224914:	00bffd44 	movi	r2,-11
 8224918:	0000e006 	br	8224c9c <tse_mac_init+0xa4c>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 822491c:	008209b4 	movhi	r2,2086
 8224920:	10b62904 	addi	r2,r2,-10076
 8224924:	e0ffff17 	ldw	r3,-4(fp)
 8224928:	18c01324 	muli	r3,r3,76
 822492c:	10c5883a 	add	r2,r2,r3
 8224930:	10800b04 	addi	r2,r2,44
 8224934:	00c00044 	movi	r3,1
 8224938:	10c00015 	stw	r3,0(r2)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 822493c:	00810034 	movhi	r2,1024
 8224940:	108080c4 	addi	r2,r2,515
 8224944:	e0bff315 	stw	r2,-52(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 8224948:	e0bffd17 	ldw	r2,-12(fp)
 822494c:	10800058 	cmpnei	r2,r2,1
 8224950:	1000171e 	bne	r2,zero,82249b0 <tse_mac_init+0x760>
 8224954:	00000d06 	br	822498c <tse_mac_init+0x73c>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 8224958:	008209b4 	movhi	r2,2086
 822495c:	10b62904 	addi	r2,r2,-10076
 8224960:	e0ffff17 	ldw	r3,-4(fp)
 8224964:	18c01324 	muli	r3,r3,76
 8224968:	10c5883a 	add	r2,r2,r3
 822496c:	10800b04 	addi	r2,r2,44
 8224970:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 8224974:	01400084 	movi	r5,2
 8224978:	01020974 	movhi	r4,2085
 822497c:	213e5804 	addi	r4,r4,-1696
 8224980:	82030ec0 	call	82030ec <printf>
      return ENP_LOGIC;
 8224984:	00bffd44 	movi	r2,-11
 8224988:	0000c406 	br	8224c9c <tse_mac_init+0xa4c>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 822498c:	e0bff317 	ldw	r2,-52(fp)
 8224990:	10800214 	ori	r2,r2,8
 8224994:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224998:	e0fff317 	ldw	r3,-52(fp)
 822499c:	00bf8034 	movhi	r2,65024
 82249a0:	10bfffc4 	addi	r2,r2,-1
 82249a4:	1884703a 	and	r2,r3,r2
 82249a8:	e0bff315 	stw	r2,-52(fp)
 82249ac:	00002106 	br	8224a34 <tse_mac_init+0x7e4>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 82249b0:	e0bffd17 	ldw	r2,-12(fp)
 82249b4:	10800098 	cmpnei	r2,r2,2
 82249b8:	10000a1e 	bne	r2,zero,82249e4 <tse_mac_init+0x794>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82249bc:	e0fff317 	ldw	r3,-52(fp)
 82249c0:	00bffdc4 	movi	r2,-9
 82249c4:	1884703a 	and	r2,r3,r2
 82249c8:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82249cc:	e0fff317 	ldw	r3,-52(fp)
 82249d0:	00bf8034 	movhi	r2,65024
 82249d4:	10bfffc4 	addi	r2,r2,-1
 82249d8:	1884703a 	and	r2,r3,r2
 82249dc:	e0bff315 	stw	r2,-52(fp)
 82249e0:	00001406 	br	8224a34 <tse_mac_init+0x7e4>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 82249e4:	e0bffd17 	ldw	r2,-12(fp)
 82249e8:	10800118 	cmpnei	r2,r2,4
 82249ec:	1000081e 	bne	r2,zero,8224a10 <tse_mac_init+0x7c0>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82249f0:	e0fff317 	ldw	r3,-52(fp)
 82249f4:	00bffdc4 	movi	r2,-9
 82249f8:	1884703a 	and	r2,r3,r2
 82249fc:	e0bff315 	stw	r2,-52(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224a00:	e0bff317 	ldw	r2,-52(fp)
 8224a04:	10808034 	orhi	r2,r2,512
 8224a08:	e0bff315 	stw	r2,-52(fp)
 8224a0c:	00000906 	br	8224a34 <tse_mac_init+0x7e4>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224a10:	e0fff317 	ldw	r3,-52(fp)
 8224a14:	00bffdc4 	movi	r2,-9
 8224a18:	1884703a 	and	r2,r3,r2
 8224a1c:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224a20:	e0fff317 	ldw	r3,-52(fp)
 8224a24:	00bf8034 	movhi	r2,65024
 8224a28:	10bfffc4 	addi	r2,r2,-1
 8224a2c:	1884703a 	and	r2,r3,r2
 8224a30:	e0bff315 	stw	r2,-52(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8224a34:	e0bffe17 	ldw	r2,-8(fp)
 8224a38:	1000041e 	bne	r2,zero,8224a4c <tse_mac_init+0x7fc>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224a3c:	e0bff317 	ldw	r2,-52(fp)
 8224a40:	10810014 	ori	r2,r2,1024
 8224a44:	e0bff315 	stw	r2,-52(fp)
 8224a48:	00000406 	br	8224a5c <tse_mac_init+0x80c>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224a4c:	e0fff317 	ldw	r3,-52(fp)
 8224a50:	00beffc4 	movi	r2,-1025
 8224a54:	1884703a 	and	r2,r3,r2
 8224a58:	e0bff315 	stw	r2,-52(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 8224a5c:	008209b4 	movhi	r2,2086
 8224a60:	10b62904 	addi	r2,r2,-10076
 8224a64:	e0ffff17 	ldw	r3,-4(fp)
 8224a68:	18c01324 	muli	r3,r3,76
 8224a6c:	10c5883a 	add	r2,r2,r3
 8224a70:	10800104 	addi	r2,r2,4
 8224a74:	10800017 	ldw	r2,0(r2)
 8224a78:	10800204 	addi	r2,r2,8
 8224a7c:	e0fff317 	ldw	r3,-52(fp)
 8224a80:	10c00035 	stwio	r3,0(r2)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
 8224a84:	008209b4 	movhi	r2,2086
 8224a88:	10b62904 	addi	r2,r2,-10076
 8224a8c:	e0ffff17 	ldw	r3,-4(fp)
 8224a90:	18c01324 	muli	r3,r3,76
 8224a94:	10c5883a 	add	r2,r2,r3
 8224a98:	10800104 	addi	r2,r2,4
 8224a9c:	10800017 	ldw	r2,0(r2)
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 8224aa0:	10800204 	addi	r2,r2,8
 8224aa4:	10800037 	ldwio	r2,0(r2)
 8224aa8:	100b883a 	mov	r5,r2
 8224aac:	01020974 	movhi	r4,2085
 8224ab0:	213e7004 	addi	r4,r4,-1600
 8224ab4:	82030ec0 	call	82030ec <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 8224ab8:	008209b4 	movhi	r2,2086
 8224abc:	10b62904 	addi	r2,r2,-10076
 8224ac0:	e0ffff17 	ldw	r3,-4(fp)
 8224ac4:	18c01324 	muli	r3,r3,76
 8224ac8:	10c5883a 	add	r2,r2,r3
 8224acc:	10800104 	addi	r2,r2,4
 8224ad0:	10800017 	ldw	r2,0(r2)
 8224ad4:	10c00304 	addi	r3,r2,12
 8224ad8:	008209b4 	movhi	r2,2086
 8224adc:	10b62904 	addi	r2,r2,-10076
 8224ae0:	e13fff17 	ldw	r4,-4(fp)
 8224ae4:	21001324 	muli	r4,r4,76
 8224ae8:	1105883a 	add	r2,r2,r4
 8224aec:	10800604 	addi	r2,r2,24
 8224af0:	10800003 	ldbu	r2,0(r2)
 8224af4:	11003fcc 	andi	r4,r2,255
 8224af8:	008209b4 	movhi	r2,2086
 8224afc:	10b62904 	addi	r2,r2,-10076
 8224b00:	e17fff17 	ldw	r5,-4(fp)
 8224b04:	29401324 	muli	r5,r5,76
 8224b08:	1145883a 	add	r2,r2,r5
 8224b0c:	10800644 	addi	r2,r2,25
 8224b10:	10800003 	ldbu	r2,0(r2)
 8224b14:	10803fcc 	andi	r2,r2,255
 8224b18:	1004923a 	slli	r2,r2,8
 8224b1c:	2088b03a 	or	r4,r4,r2
 8224b20:	008209b4 	movhi	r2,2086
 8224b24:	10b62904 	addi	r2,r2,-10076
 8224b28:	e17fff17 	ldw	r5,-4(fp)
 8224b2c:	29401324 	muli	r5,r5,76
 8224b30:	1145883a 	add	r2,r2,r5
 8224b34:	10800684 	addi	r2,r2,26
 8224b38:	10800003 	ldbu	r2,0(r2)
 8224b3c:	10803fcc 	andi	r2,r2,255
 8224b40:	1004943a 	slli	r2,r2,16
 8224b44:	2088b03a 	or	r4,r4,r2
 8224b48:	008209b4 	movhi	r2,2086
 8224b4c:	10b62904 	addi	r2,r2,-10076
 8224b50:	e17fff17 	ldw	r5,-4(fp)
 8224b54:	29401324 	muli	r5,r5,76
 8224b58:	1145883a 	add	r2,r2,r5
 8224b5c:	108006c4 	addi	r2,r2,27
 8224b60:	10800003 	ldbu	r2,0(r2)
 8224b64:	10803fcc 	andi	r2,r2,255
 8224b68:	1004963a 	slli	r2,r2,24
 8224b6c:	2084b03a 	or	r2,r4,r2
 8224b70:	18800035 	stwio	r2,0(r3)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 8224b74:	008209b4 	movhi	r2,2086
 8224b78:	10b62904 	addi	r2,r2,-10076
 8224b7c:	e0ffff17 	ldw	r3,-4(fp)
 8224b80:	18c01324 	muli	r3,r3,76
 8224b84:	10c5883a 	add	r2,r2,r3
 8224b88:	10800104 	addi	r2,r2,4
 8224b8c:	10800017 	ldw	r2,0(r2)
 8224b90:	10c00404 	addi	r3,r2,16
 8224b94:	008209b4 	movhi	r2,2086
 8224b98:	10b62904 	addi	r2,r2,-10076
 8224b9c:	e13fff17 	ldw	r4,-4(fp)
 8224ba0:	21001324 	muli	r4,r4,76
 8224ba4:	1105883a 	add	r2,r2,r4
 8224ba8:	10800704 	addi	r2,r2,28
 8224bac:	10800003 	ldbu	r2,0(r2)
 8224bb0:	11003fcc 	andi	r4,r2,255
 8224bb4:	008209b4 	movhi	r2,2086
 8224bb8:	10b62904 	addi	r2,r2,-10076
 8224bbc:	e17fff17 	ldw	r5,-4(fp)
 8224bc0:	29401324 	muli	r5,r5,76
 8224bc4:	1145883a 	add	r2,r2,r5
 8224bc8:	10800744 	addi	r2,r2,29
 8224bcc:	10800003 	ldbu	r2,0(r2)
 8224bd0:	10803fcc 	andi	r2,r2,255
 8224bd4:	1004923a 	slli	r2,r2,8
 8224bd8:	2084b03a 	or	r2,r4,r2
 8224bdc:	10bfffcc 	andi	r2,r2,65535
 8224be0:	18800035 	stwio	r2,0(r3)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 8224be4:	008209b4 	movhi	r2,2086
 8224be8:	10b73a04 	addi	r2,r2,-8984
 8224bec:	e0ffff17 	ldw	r3,-4(fp)
 8224bf0:	18c7883a 	add	r3,r3,r3
 8224bf4:	18c7883a 	add	r3,r3,r3
 8224bf8:	10c5883a 	add	r2,r2,r3
 8224bfc:	10800017 	ldw	r2,0(r2)
 8224c00:	10802717 	ldw	r2,156(r2)
 8224c04:	00c00044 	movi	r3,1
 8224c08:	10c00615 	stw	r3,24(r2)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 8224c0c:	008209b4 	movhi	r2,2086
 8224c10:	10b73a04 	addi	r2,r2,-8984
 8224c14:	e0ffff17 	ldw	r3,-4(fp)
 8224c18:	18c7883a 	add	r3,r3,r3
 8224c1c:	18c7883a 	add	r3,r3,r3
 8224c20:	10c5883a 	add	r2,r2,r3
 8224c24:	10800017 	ldw	r2,0(r2)
 8224c28:	10802717 	ldw	r2,156(r2)
 8224c2c:	00c00044 	movi	r3,1
 8224c30:	10c00715 	stw	r3,28(r2)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224c34:	008209b4 	movhi	r2,2086
 8224c38:	10b62904 	addi	r2,r2,-10076
 8224c3c:	e0ffff17 	ldw	r3,-4(fp)
 8224c40:	18c01324 	muli	r3,r3,76
 8224c44:	10c5883a 	add	r2,r2,r3
 8224c48:	10800304 	addi	r2,r2,12
 8224c4c:	11000017 	ldw	r4,0(r2)
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
 8224c50:	e0bfff17 	ldw	r2,-4(fp)
 8224c54:	10c01324 	muli	r3,r2,76
 8224c58:	008209b4 	movhi	r2,2086
 8224c5c:	10b62904 	addi	r2,r2,-10076
 8224c60:	1885883a 	add	r2,r3,r2
   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224c64:	100f883a 	mov	r7,r2
 8224c68:	01800604 	movi	r6,24
 8224c6c:	014208b4 	movhi	r5,2082
 8224c70:	2953ea04 	addi	r5,r5,20392
 8224c74:	821e5940 	call	821e594 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 8224c78:	e0bfff17 	ldw	r2,-4(fp)
 8224c7c:	10c01324 	muli	r3,r2,76
 8224c80:	008209b4 	movhi	r2,2086
 8224c84:	10b62904 	addi	r2,r2,-10076
 8224c88:	1885883a 	add	r2,r3,r2
 8224c8c:	1009883a 	mov	r4,r2
 8224c90:	82250540 	call	8225054 <tse_sgdma_read_init>
 8224c94:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 8224c98:	e0bff817 	ldw	r2,-32(fp)
}
 8224c9c:	e037883a 	mov	sp,fp
 8224ca0:	dfc00117 	ldw	ra,4(sp)
 8224ca4:	df000017 	ldw	fp,0(sp)
 8224ca8:	dec00204 	addi	sp,sp,8
 8224cac:	f800283a 	ret

08224cb0 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 8224cb0:	defe6504 	addi	sp,sp,-1644
 8224cb4:	dfc19a15 	stw	ra,1640(sp)
 8224cb8:	df019915 	stw	fp,1636(sp)
 8224cbc:	df019904 	addi	fp,sp,1636
 8224cc0:	e13ffd15 	stw	r4,-12(fp)
 8224cc4:	e17ffe15 	stw	r5,-8(fp)
 8224cc8:	e1bfff15 	stw	r6,-4(fp)
   int result,i;
   unsigned len = data_bytes;
 8224ccc:	e0bfff17 	ldw	r2,-4(fp)
 8224cd0:	e0be6e15 	stw	r2,-1608(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 8224cd4:	e0bffd17 	ldw	r2,-12(fp)
 8224cd8:	10802817 	ldw	r2,160(r2)
 8224cdc:	e0be6f15 	stw	r2,-1604(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 8224ce0:	e0be6f17 	ldw	r2,-1604(fp)
 8224ce4:	10801217 	ldw	r2,72(r2)
 8224ce8:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8224cec:	0005303a 	rdctl	r2,status
 8224cf0:	e0be7615 	stw	r2,-1576(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8224cf4:	e0fe7617 	ldw	r3,-1576(fp)
 8224cf8:	00bfff84 	movi	r2,-2
 8224cfc:	1884703a 	and	r2,r3,r2
 8224d00:	1001703a 	wrctl	status,r2
  
  return context;
 8224d04:	e0be7617 	ldw	r2,-1576(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 8224d08:	e0be7215 	stw	r2,-1592(fp)
   mi = &tse_ptr->mi;
 8224d0c:	e0be6f17 	ldw	r2,-1604(fp)
 8224d10:	10800104 	addi	r2,r2,4
 8224d14:	e0be7315 	stw	r2,-1588(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 8224d18:	e0be6f17 	ldw	r2,-1604(fp)
 8224d1c:	10800c17 	ldw	r2,48(r2)
 8224d20:	10000926 	beq	r2,zero,8224d48 <tse_mac_raw_send+0x98>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 8224d24:	01020974 	movhi	r4,2085
 8224d28:	213e7c04 	addi	r4,r4,-1552
 8224d2c:	82033700 	call	8203370 <puts>
 8224d30:	e0be7217 	ldw	r2,-1592(fp)
 8224d34:	e0be7115 	stw	r2,-1596(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8224d38:	e0be7117 	ldw	r2,-1596(fp)
 8224d3c:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 8224d40:	00bffa84 	movi	r2,-22
 8224d44:	00009306 	br	8224f94 <tse_mac_raw_send+0x2e4>
   }
 
   tse_ptr->sem = 1;  
 8224d48:	e0be6f17 	ldw	r2,-1604(fp)
 8224d4c:	00c00044 	movi	r3,1
 8224d50:	10c00c15 	stw	r3,48(r2)

   if(((unsigned long)data & 0x03) == 0) 
 8224d54:	e0bffe17 	ldw	r2,-8(fp)
 8224d58:	108000cc 	andi	r2,r2,3
 8224d5c:	1000031e 	bne	r2,zero,8224d6c <tse_mac_raw_send+0xbc>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 8224d60:	e0bffe17 	ldw	r2,-8(fp)
 8224d64:	e0be6d15 	stw	r2,-1612(fp)
 8224d68:	00001406 	br	8224dbc <tse_mac_raw_send+0x10c>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8224d6c:	e03e6c15 	stw	zero,-1616(fp)
 8224d70:	00000d06 	br	8224da8 <tse_mac_raw_send+0xf8>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 8224d74:	e0be6c17 	ldw	r2,-1616(fp)
 8224d78:	e0fffe17 	ldw	r3,-8(fp)
 8224d7c:	1885883a 	add	r2,r3,r2
 8224d80:	10800023 	ldbuio	r2,0(r2)
 8224d84:	10803fcc 	andi	r2,r2,255
 8224d88:	1009883a 	mov	r4,r2
 8224d8c:	e0fe7704 	addi	r3,fp,-1572
 8224d90:	e0be6c17 	ldw	r2,-1616(fp)
 8224d94:	1885883a 	add	r2,r3,r2
 8224d98:	11000005 	stb	r4,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8224d9c:	e0be6c17 	ldw	r2,-1616(fp)
 8224da0:	10800044 	addi	r2,r2,1
 8224da4:	e0be6c15 	stw	r2,-1616(fp)
 8224da8:	e0fe6c17 	ldw	r3,-1616(fp)
 8224dac:	e0be6e17 	ldw	r2,-1608(fp)
 8224db0:	18bff036 	bltu	r3,r2,8224d74 <tse_mac_raw_send+0xc4>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 8224db4:	e0be7704 	addi	r2,fp,-1572
 8224db8:	e0be6d15 	stw	r2,-1612(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 8224dbc:	01400104 	movi	r5,4
 8224dc0:	e13e6d17 	ldw	r4,-1612(fp)
 8224dc4:	823c4fc0 	call	823c4fc <alt_remap_cached>
 8224dc8:	e0be6d15 	stw	r2,-1612(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 8224dcc:	e0be7017 	ldw	r2,-1600(fp)
 8224dd0:	10800903 	ldbu	r2,36(r2)
 8224dd4:	10803fcc 	andi	r2,r2,255
 8224dd8:	10800058 	cmpnei	r2,r2,1
 8224ddc:	1000271e 	bne	r2,zero,8224e7c <tse_mac_raw_send+0x1cc>
 8224de0:	e0be6e17 	ldw	r2,-1608(fp)
 8224de4:	108003f0 	cmpltui	r2,r2,15
 8224de8:	1000241e 	bne	r2,zero,8224e7c <tse_mac_raw_send+0x1cc>
 8224dec:	e0be6f17 	ldw	r2,-1604(fp)
 8224df0:	10800d17 	ldw	r2,52(r2)
 8224df4:	1085883a 	add	r2,r2,r2
 8224df8:	1085883a 	add	r2,r2,r2
 8224dfc:	1007883a 	mov	r3,r2
 8224e00:	e0be7017 	ldw	r2,-1600(fp)
 8224e04:	10800b17 	ldw	r2,44(r2)
 8224e08:	1885883a 	add	r2,r3,r2
 8224e0c:	10800037 	ldwio	r2,0(r2)
 8224e10:	10800388 	cmpgei	r2,r2,14
 8224e14:	1000191e 	bne	r2,zero,8224e7c <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224e18:	e0be6f17 	ldw	r2,-1604(fp)
 8224e1c:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8224e20:	e0be6f17 	ldw	r2,-1604(fp)
 8224e24:	10800f17 	ldw	r2,60(r2)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224e28:	11000804 	addi	r4,r2,32
 8224e2c:	e0be6e17 	ldw	r2,-1608(fp)
 8224e30:	117fffcc 	andi	r5,r2,65535
 8224e34:	d8000315 	stw	zero,12(sp)
 8224e38:	00800044 	movi	r2,1
 8224e3c:	d8800215 	stw	r2,8(sp)
 8224e40:	00800044 	movi	r2,1
 8224e44:	d8800115 	stw	r2,4(sp)
 8224e48:	d8000015 	stw	zero,0(sp)
 8224e4c:	280f883a 	mov	r7,r5
 8224e50:	e1be6d17 	ldw	r6,-1612(fp)
 8224e54:	200b883a 	mov	r5,r4
 8224e58:	1809883a 	mov	r4,r3
 8224e5c:	821e4880 	call	821e488 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tse_mac_sTxWrite(mi,tse_ptr->desc);
 8224e60:	e0be6f17 	ldw	r2,-1604(fp)
 8224e64:	10800f17 	ldw	r2,60(r2)
 8224e68:	100b883a 	mov	r5,r2
 8224e6c:	e13e7317 	ldw	r4,-1588(fp)
 8224e70:	821ef600 	call	821ef60 <tse_mac_sTxWrite>
        result = 0;
 8224e74:	e03e6b15 	stw	zero,-1620(fp)
 8224e78:	00001e06 	br	8224ef4 <tse_mac_raw_send+0x244>
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 8224e7c:	e0be6e17 	ldw	r2,-1608(fp)
 8224e80:	108003f0 	cmpltui	r2,r2,15
 8224e84:	1000191e 	bne	r2,zero,8224eec <tse_mac_raw_send+0x23c>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224e88:	e0be6f17 	ldw	r2,-1604(fp)
 8224e8c:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8224e90:	e0be6f17 	ldw	r2,-1604(fp)
 8224e94:	10800f17 	ldw	r2,60(r2)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8224e98:	11000804 	addi	r4,r2,32
 8224e9c:	e0be6e17 	ldw	r2,-1608(fp)
 8224ea0:	117fffcc 	andi	r5,r2,65535
 8224ea4:	d8000315 	stw	zero,12(sp)
 8224ea8:	00800044 	movi	r2,1
 8224eac:	d8800215 	stw	r2,8(sp)
 8224eb0:	00800044 	movi	r2,1
 8224eb4:	d8800115 	stw	r2,4(sp)
 8224eb8:	d8000015 	stw	zero,0(sp)
 8224ebc:	280f883a 	mov	r7,r5
 8224ec0:	e1be6d17 	ldw	r6,-1612(fp)
 8224ec4:	200b883a 	mov	r5,r4
 8224ec8:	1809883a 	mov	r4,r3
 8224ecc:	821e4880 	call	821e488 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tse_mac_sTxWrite(mi,tse_ptr->desc);
 8224ed0:	e0be6f17 	ldw	r2,-1604(fp)
 8224ed4:	10800f17 	ldw	r2,60(r2)
 8224ed8:	100b883a 	mov	r5,r2
 8224edc:	e13e7317 	ldw	r4,-1588(fp)
 8224ee0:	821ef600 	call	821ef60 <tse_mac_sTxWrite>
       result = 0;
 8224ee4:	e03e6b15 	stw	zero,-1620(fp)
 8224ee8:	00000206 	br	8224ef4 <tse_mac_raw_send+0x244>

   } else {
       result = -3;
 8224eec:	00bfff44 	movi	r2,-3
 8224ef0:	e0be6b15 	stw	r2,-1620(fp)
   }

   if(result < 0)   /* SGDMA not available */
 8224ef4:	e0be6b17 	ldw	r2,-1620(fp)
 8224ef8:	1000120e 	bge	r2,zero,8224f44 <tse_mac_raw_send+0x294>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 8224efc:	e1be6e17 	ldw	r6,-1608(fp)
 8224f00:	e17e6b17 	ldw	r5,-1620(fp)
 8224f04:	01020974 	movhi	r4,2085
 8224f08:	213e8304 	addi	r4,r4,-1524
 8224f0c:	82030ec0 	call	82030ec <printf>
      net->n_mib->ifOutDiscards++;
 8224f10:	e0bffd17 	ldw	r2,-12(fp)
 8224f14:	10802717 	ldw	r2,156(r2)
 8224f18:	10c01217 	ldw	r3,72(r2)
 8224f1c:	18c00044 	addi	r3,r3,1
 8224f20:	10c01215 	stw	r3,72(r2)
      tse_ptr->sem = 0;
 8224f24:	e0be6f17 	ldw	r2,-1604(fp)
 8224f28:	10000c15 	stw	zero,48(r2)
 8224f2c:	e0be7217 	ldw	r2,-1592(fp)
 8224f30:	e0be7415 	stw	r2,-1584(fp)
 8224f34:	e0be7417 	ldw	r2,-1584(fp)
 8224f38:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 8224f3c:	00bffa84 	movi	r2,-22
 8224f40:	00001406 	br	8224f94 <tse_mac_raw_send+0x2e4>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 8224f44:	e0bffd17 	ldw	r2,-12(fp)
 8224f48:	10802717 	ldw	r2,156(r2)
 8224f4c:	e0fffd17 	ldw	r3,-12(fp)
 8224f50:	18c02717 	ldw	r3,156(r3)
 8224f54:	19000f17 	ldw	r4,60(r3)
 8224f58:	e0ffff17 	ldw	r3,-4(fp)
 8224f5c:	20c7883a 	add	r3,r4,r3
 8224f60:	10c00f15 	stw	r3,60(r2)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 8224f64:	e0bffd17 	ldw	r2,-12(fp)
 8224f68:	10802717 	ldw	r2,156(r2)
 8224f6c:	10c01017 	ldw	r3,64(r2)
 8224f70:	18c00044 	addi	r3,r3,1
 8224f74:	10c01015 	stw	r3,64(r2)
      tse_ptr->sem = 0;
 8224f78:	e0be6f17 	ldw	r2,-1604(fp)
 8224f7c:	10000c15 	stw	zero,48(r2)
 8224f80:	e0be7217 	ldw	r2,-1592(fp)
 8224f84:	e0be7515 	stw	r2,-1580(fp)
 8224f88:	e0be7517 	ldw	r2,-1580(fp)
 8224f8c:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 8224f90:	0005883a 	mov	r2,zero
   }
}
 8224f94:	e037883a 	mov	sp,fp
 8224f98:	dfc00117 	ldw	ra,4(sp)
 8224f9c:	df000017 	ldw	fp,0(sp)
 8224fa0:	dec00204 	addi	sp,sp,8
 8224fa4:	f800283a 	ret

08224fa8 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 8224fa8:	defffa04 	addi	sp,sp,-24
 8224fac:	dfc00515 	stw	ra,20(sp)
 8224fb0:	df000415 	stw	fp,16(sp)
 8224fb4:	df000404 	addi	fp,sp,16
 8224fb8:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 8224fbc:	e0bfff17 	ldw	r2,-4(fp)
 8224fc0:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 8224fc4:	008209b4 	movhi	r2,2086
 8224fc8:	10b67504 	addi	r2,r2,-9772
 8224fcc:	10800217 	ldw	r2,8(r2)
 8224fd0:	e0bffd15 	stw	r2,-12(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 8224fd4:	e0bffc17 	ldw	r2,-16(fp)
 8224fd8:	10800317 	ldw	r2,12(r2)
 8224fdc:	10800317 	ldw	r2,12(r2)
 8224fe0:	10800037 	ldwio	r2,0(r2)
 8224fe4:	e0bffe05 	stb	r2,-8(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 8224fe8:	e0bffe03 	ldbu	r2,-8(fp)
 8224fec:	1080030c 	andi	r2,r2,12
 8224ff0:	10001226 	beq	r2,zero,822503c <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 8224ff4:	e13ffc17 	ldw	r4,-16(fp)
 8224ff8:	82252000 	call	8225200 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 8224ffc:	e0bffc17 	ldw	r2,-16(fp)
 8225000:	10c00317 	ldw	r3,12(r2)
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 8225004:	e0bffc17 	ldw	r2,-16(fp)
 8225008:	10800f17 	ldw	r2,60(r2)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 822500c:	10801004 	addi	r2,r2,64
 8225010:	100b883a 	mov	r5,r2
 8225014:	1809883a 	mov	r4,r3
 8225018:	821e0840 	call	821e084 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 822501c:	008209b4 	movhi	r2,2086
 8225020:	10b67504 	addi	r2,r2,-9772
 8225024:	10800217 	ldw	r2,8(r2)
 8225028:	e0fffd17 	ldw	r3,-12(fp)
 822502c:	1880030e 	bge	r3,r2,822503c <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 8225030:	d0a0ab17 	ldw	r2,-32084(gp)
 8225034:	1009883a 	mov	r4,r2
 8225038:	821a1980 	call	821a198 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 822503c:	0001883a 	nop
 8225040:	e037883a 	mov	sp,fp
 8225044:	dfc00117 	ldw	ra,4(sp)
 8225048:	df000017 	ldw	fp,0(sp)
 822504c:	dec00204 	addi	sp,sp,8
 8225050:	f800283a 	ret

08225054 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 8225054:	defffa04 	addi	sp,sp,-24
 8225058:	dfc00515 	stw	ra,20(sp)
 822505c:	df000415 	stw	fp,16(sp)
 8225060:	dc000315 	stw	r16,12(sp)
 8225064:	df000404 	addi	fp,sp,16
 8225068:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 822506c:	e0bffe17 	ldw	r2,-8(fp)
 8225070:	10000e15 	stw	zero,56(r2)
 8225074:	00004406 	br	8225188 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 8225078:	e0bffe17 	ldw	r2,-8(fp)
 822507c:	14000e17 	ldw	r16,56(r2)
 8225080:	01017f04 	movi	r4,1532
 8225084:	822c7380 	call	822c738 <pk_alloc>
 8225088:	1009883a 	mov	r4,r2
 822508c:	e0fffe17 	ldw	r3,-8(fp)
 8225090:	80800444 	addi	r2,r16,17
 8225094:	1085883a 	add	r2,r2,r2
 8225098:	1085883a 	add	r2,r2,r2
 822509c:	1885883a 	add	r2,r3,r2
 82250a0:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 82250a4:	e0bffe17 	ldw	r2,-8(fp)
 82250a8:	10800e17 	ldw	r2,56(r2)
 82250ac:	e0fffe17 	ldw	r3,-8(fp)
 82250b0:	10800444 	addi	r2,r2,17
 82250b4:	1085883a 	add	r2,r2,r2
 82250b8:	1085883a 	add	r2,r2,r2
 82250bc:	1885883a 	add	r2,r3,r2
 82250c0:	10800017 	ldw	r2,0(r2)
 82250c4:	10000b1e 	bne	r2,zero,82250f4 <tse_sgdma_read_init+0xa0>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 82250c8:	01020974 	movhi	r4,2085
 82250cc:	213e8f04 	addi	r4,r4,-1476
 82250d0:	82033700 	call	8203370 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 82250d4:	e0bffe17 	ldw	r2,-8(fp)
 82250d8:	10800817 	ldw	r2,32(r2)
 82250dc:	10802717 	ldw	r2,156(r2)
 82250e0:	10c00c17 	ldw	r3,48(r2)
 82250e4:	18c00044 	addi	r3,r3,1
 82250e8:	10c00c15 	stw	r3,48(r2)
      
      return ENP_NOBUFFER;
 82250ec:	00bffac4 	movi	r2,-21
 82250f0:	00003d06 	br	82251e8 <tse_sgdma_read_init+0x194>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82250f4:	e0bffe17 	ldw	r2,-8(fp)
 82250f8:	10800e17 	ldw	r2,56(r2)
 82250fc:	e0fffe17 	ldw	r3,-8(fp)
 8225100:	10800444 	addi	r2,r2,17
 8225104:	1085883a 	add	r2,r2,r2
 8225108:	1085883a 	add	r2,r2,r2
 822510c:	1885883a 	add	r2,r3,r2
 8225110:	10800017 	ldw	r2,0(r2)
 8225114:	10800117 	ldw	r2,4(r2)
 8225118:	01400104 	movi	r5,4
 822511c:	1009883a 	mov	r4,r2
 8225120:	823c4fc0 	call	823c4fc <alt_remap_cached>
 8225124:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 8225128:	e0bffe17 	ldw	r2,-8(fp)
 822512c:	10c00f17 	ldw	r3,60(r2)
 8225130:	e0bffe17 	ldw	r2,-8(fp)
 8225134:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225138:	10800084 	addi	r2,r2,2
 822513c:	1004917a 	slli	r2,r2,5
 8225140:	1889883a 	add	r4,r3,r2
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST], // pointer to "next"
 8225144:	e0bffe17 	ldw	r2,-8(fp)
 8225148:	10c00f17 	ldw	r3,60(r2)
 822514c:	e0bffe17 	ldw	r2,-8(fp)
 8225150:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225154:	108000c4 	addi	r2,r2,3
 8225158:	1004917a 	slli	r2,r2,5
 822515c:	1885883a 	add	r2,r3,r2
 8225160:	d8000015 	stw	zero,0(sp)
 8225164:	000f883a 	mov	r7,zero
 8225168:	e1bffd17 	ldw	r6,-12(fp)
 822516c:	100b883a 	mov	r5,r2
 8225170:	821e3b00 	call	821e3b0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 8225174:	e0bffe17 	ldw	r2,-8(fp)
 8225178:	10800e17 	ldw	r2,56(r2)
 822517c:	10c00044 	addi	r3,r2,1
 8225180:	e0bffe17 	ldw	r2,-8(fp)
 8225184:	10c00e15 	stw	r3,56(r2)
 8225188:	e0bffe17 	ldw	r2,-8(fp)
 822518c:	10800e17 	ldw	r2,56(r2)
 8225190:	00bfb90e 	bge	zero,r2,8225078 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 8225194:	e0bffe17 	ldw	r2,-8(fp)
 8225198:	10800e17 	ldw	r2,56(r2)
 822519c:	100b883a 	mov	r5,r2
 82251a0:	01020974 	movhi	r4,2085
 82251a4:	213ea004 	addi	r4,r4,-1408
 82251a8:	82030ec0 	call	82030ec <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 82251ac:	e0bffe17 	ldw	r2,-8(fp)
 82251b0:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 82251b4:	e0bffe17 	ldw	r2,-8(fp)
 82251b8:	10800f17 	ldw	r2,60(r2)
 82251bc:	10c01004 	addi	r3,r2,64
 82251c0:	e0bffe17 	ldw	r2,-8(fp)
 82251c4:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 82251c8:	e0bffe17 	ldw	r2,-8(fp)
 82251cc:	10c00104 	addi	r3,r2,4
 82251d0:	e0bffe17 	ldw	r2,-8(fp)
 82251d4:	10801017 	ldw	r2,64(r2)
 82251d8:	100b883a 	mov	r5,r2
 82251dc:	1809883a 	mov	r4,r3
 82251e0:	821f0440 	call	821f044 <tse_mac_aRxRead>
  
  return SUCCESS;
 82251e4:	0005883a 	mov	r2,zero
}
 82251e8:	e6ffff04 	addi	sp,fp,-4
 82251ec:	dfc00217 	ldw	ra,8(sp)
 82251f0:	df000117 	ldw	fp,4(sp)
 82251f4:	dc000017 	ldw	r16,0(sp)
 82251f8:	dec00304 	addi	sp,sp,12
 82251fc:	f800283a 	ret

08225200 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 8225200:	defff704 	addi	sp,sp,-36
 8225204:	dfc00815 	stw	ra,32(sp)
 8225208:	df000715 	stw	fp,28(sp)
 822520c:	df000704 	addi	fp,sp,28
 8225210:	e13fff15 	stw	r4,-4(fp)
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 8225214:	e0bfff17 	ldw	r2,-4(fp)
 8225218:	10c00f17 	ldw	r3,60(r2)
 822521c:	e0bfff17 	ldw	r2,-4(fp)
 8225220:	10800e17 	ldw	r2,56(r2)
 8225224:	10800084 	addi	r2,r2,2
 8225228:	1004917a 	slli	r2,r2,5
 822522c:	1887883a 	add	r3,r3,r2
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 8225230:	e0bfff17 	ldw	r2,-4(fp)
 8225234:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 8225238:	e0bfff17 	ldw	r2,-4(fp)
 822523c:	10801017 	ldw	r2,64(r2)
 8225240:	10800704 	addi	r2,r2,28
 8225244:	10800037 	ldwio	r2,0(r2)
 8225248:	1005d43a 	srai	r2,r2,16
 822524c:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 8225250:	e0bfff17 	ldw	r2,-4(fp)
 8225254:	10801017 	ldw	r2,64(r2)
 8225258:	10800704 	addi	r2,r2,28
 822525c:	1080002b 	ldhuio	r2,0(r2)
 8225260:	10bfffcc 	andi	r2,r2,65535
 8225264:	10bfff84 	addi	r2,r2,-2
 8225268:	e0bffa15 	stw	r2,-24(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 822526c:	e0bfff17 	ldw	r2,-4(fp)
 8225270:	10800817 	ldw	r2,32(r2)
 8225274:	10802717 	ldw	r2,156(r2)
 8225278:	e0ffff17 	ldw	r3,-4(fp)
 822527c:	18c00817 	ldw	r3,32(r3)
 8225280:	18c02717 	ldw	r3,156(r3)
 8225284:	19000917 	ldw	r4,36(r3)
 8225288:	e0fffa17 	ldw	r3,-24(fp)
 822528c:	20c7883a 	add	r3,r4,r3
 8225290:	10c00915 	stw	r3,36(r2)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 8225294:	e0bfff17 	ldw	r2,-4(fp)
 8225298:	10800e17 	ldw	r2,56(r2)
 822529c:	e0ffff17 	ldw	r3,-4(fp)
 82252a0:	10800444 	addi	r2,r2,17
 82252a4:	1085883a 	add	r2,r2,r2
 82252a8:	1085883a 	add	r2,r2,r2
 82252ac:	1885883a 	add	r2,r3,r2
 82252b0:	10800017 	ldw	r2,0(r2)
 82252b4:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 82252b8:	e0bffb17 	ldw	r2,-20(fp)
 82252bc:	10800117 	ldw	r2,4(r2)
 82252c0:	10c00404 	addi	r3,r2,16
 82252c4:	e0bffb17 	ldw	r2,-20(fp)
 82252c8:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 82252cc:	e0bffa17 	ldw	r2,-24(fp)
 82252d0:	10bffc84 	addi	r2,r2,-14
 82252d4:	1007883a 	mov	r3,r2
 82252d8:	e0bffb17 	ldw	r2,-20(fp)
 82252dc:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 82252e0:	d0a0a817 	ldw	r2,-32096(gp)
 82252e4:	1007883a 	mov	r3,r2
 82252e8:	e0bffb17 	ldw	r2,-20(fp)
 82252ec:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 82252f0:	e0bfff17 	ldw	r2,-4(fp)
 82252f4:	10c00817 	ldw	r3,32(r2)
 82252f8:	e0bffb17 	ldw	r2,-20(fp)
 82252fc:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 8225300:	e0bffb17 	ldw	r2,-20(fp)
 8225304:	10800117 	ldw	r2,4(r2)
 8225308:	10800084 	addi	r2,r2,2
 822530c:	e0bffc15 	stw	r2,-16(fp)
    rx_packet->type = eth->e_type;
 8225310:	e0bffc17 	ldw	r2,-16(fp)
 8225314:	10c0030b 	ldhu	r3,12(r2)
 8225318:	e0bffb17 	ldw	r2,-20(fp)
 822531c:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 8225320:	e0bff903 	ldbu	r2,-28(fp)
 8225324:	10801fcc 	andi	r2,r2,127
 8225328:	1000251e 	bne	r2,zero,82253c0 <tse_mac_rcv+0x1c0>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 822532c:	01017f04 	movi	r4,1532
 8225330:	822c7380 	call	822c738 <pk_alloc>
 8225334:	e0bffd15 	stw	r2,-12(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 8225338:	e0bffd17 	ldw	r2,-12(fp)
 822533c:	10000a1e 	bne	r2,zero,8225368 <tse_mac_rcv+0x168>
        dprintf("No free buffers for rx\n");
 8225340:	01020974 	movhi	r4,2085
 8225344:	213eb104 	addi	r4,r4,-1340
 8225348:	82033700 	call	8203370 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 822534c:	e0bfff17 	ldw	r2,-4(fp)
 8225350:	10800817 	ldw	r2,32(r2)
 8225354:	10802717 	ldw	r2,156(r2)
 8225358:	10c00c17 	ldw	r3,48(r2)
 822535c:	18c00044 	addi	r3,r3,1
 8225360:	10c00c15 	stw	r3,48(r2)
 8225364:	00001906 	br	82253cc <tse_mac_rcv+0x1cc>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 8225368:	e0bfff17 	ldw	r2,-4(fp)
 822536c:	10800e17 	ldw	r2,56(r2)
 8225370:	e0ffff17 	ldw	r3,-4(fp)
 8225374:	10800444 	addi	r2,r2,17
 8225378:	1085883a 	add	r2,r2,r2
 822537c:	1085883a 	add	r2,r2,r2
 8225380:	1885883a 	add	r2,r3,r2
 8225384:	10800017 	ldw	r2,0(r2)
 8225388:	100b883a 	mov	r5,r2
 822538c:	010209b4 	movhi	r4,2086
 8225390:	21367504 	addi	r4,r4,-9772
 8225394:	822ccc80 	call	822ccc8 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 8225398:	e0bfff17 	ldw	r2,-4(fp)
 822539c:	10800e17 	ldw	r2,56(r2)
 82253a0:	e0ffff17 	ldw	r3,-4(fp)
 82253a4:	10800444 	addi	r2,r2,17
 82253a8:	1085883a 	add	r2,r2,r2
 82253ac:	1085883a 	add	r2,r2,r2
 82253b0:	1885883a 	add	r2,r3,r2
 82253b4:	e0fffd17 	ldw	r3,-12(fp)
 82253b8:	10c00015 	stw	r3,0(r2)
 82253bc:	00000306 	br	82253cc <tse_mac_rcv+0x1cc>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 82253c0:	01020974 	movhi	r4,2085
 82253c4:	213eb704 	addi	r4,r4,-1316
 82253c8:	82033700 	call	8203370 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82253cc:	e0bfff17 	ldw	r2,-4(fp)
 82253d0:	10800e17 	ldw	r2,56(r2)
 82253d4:	e0ffff17 	ldw	r3,-4(fp)
 82253d8:	10800444 	addi	r2,r2,17
 82253dc:	1085883a 	add	r2,r2,r2
 82253e0:	1085883a 	add	r2,r2,r2
 82253e4:	1885883a 	add	r2,r3,r2
 82253e8:	10800017 	ldw	r2,0(r2)
 82253ec:	10800117 	ldw	r2,4(r2)
 82253f0:	01400104 	movi	r5,4
 82253f4:	1009883a 	mov	r4,r2
 82253f8:	823c4fc0 	call	823c4fc <alt_remap_cached>
 82253fc:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 8225400:	e0bfff17 	ldw	r2,-4(fp)
 8225404:	10801017 	ldw	r2,64(r2)
 8225408:	10800204 	addi	r2,r2,8
 822540c:	e0fffe17 	ldw	r3,-8(fp)
 8225410:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 8225414:	e0bfff17 	ldw	r2,-4(fp)
 8225418:	10801017 	ldw	r2,64(r2)
 822541c:	10800704 	addi	r2,r2,28
 8225420:	00e04034 	movhi	r3,33024
 8225424:	10c00035 	stwio	r3,0(r2)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 8225428:	0001883a 	nop
 822542c:	e037883a 	mov	sp,fp
 8225430:	dfc00117 	ldw	ra,4(sp)
 8225434:	df000017 	ldw	fp,0(sp)
 8225438:	dec00204 	addi	sp,sp,8
 822543c:	f800283a 	ret

08225440 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 8225440:	defffc04 	addi	sp,sp,-16
 8225444:	dfc00315 	stw	ra,12(sp)
 8225448:	df000215 	stw	fp,8(sp)
 822544c:	df000204 	addi	fp,sp,8
 8225450:	e13ffe15 	stw	r4,-8(fp)
 8225454:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 8225458:	01420974 	movhi	r5,2085
 822545c:	297ec304 	addi	r5,r5,-1268
 8225460:	e13ffe17 	ldw	r4,-8(fp)
 8225464:	8228bac0 	call	8228bac <ns_printf>
   return SUCCESS;
 8225468:	0005883a 	mov	r2,zero
}
 822546c:	e037883a 	mov	sp,fp
 8225470:	dfc00117 	ldw	ra,4(sp)
 8225474:	df000017 	ldw	fp,0(sp)
 8225478:	dec00204 	addi	sp,sp,8
 822547c:	f800283a 	ret

08225480 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 8225480:	defffc04 	addi	sp,sp,-16
 8225484:	dfc00315 	stw	ra,12(sp)
 8225488:	df000215 	stw	fp,8(sp)
 822548c:	df000204 	addi	fp,sp,8
 8225490:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 8225494:	008209b4 	movhi	r2,2086
 8225498:	10b73a04 	addi	r2,r2,-8984
 822549c:	e0ffff17 	ldw	r3,-4(fp)
 82254a0:	18c7883a 	add	r3,r3,r3
 82254a4:	18c7883a 	add	r3,r3,r3
 82254a8:	10c5883a 	add	r2,r2,r3
 82254ac:	10800017 	ldw	r2,0(r2)
 82254b0:	10802717 	ldw	r2,156(r2)
 82254b4:	00c00084 	movi	r3,2
 82254b8:	10c00615 	stw	r3,24(r2)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 82254bc:	008209b4 	movhi	r2,2086
 82254c0:	10b62904 	addi	r2,r2,-10076
 82254c4:	e0ffff17 	ldw	r3,-4(fp)
 82254c8:	18c01324 	muli	r3,r3,76
 82254cc:	10c5883a 	add	r2,r2,r3
 82254d0:	10800304 	addi	r2,r2,12
 82254d4:	10800017 	ldw	r2,0(r2)
 82254d8:	000f883a 	mov	r7,zero
 82254dc:	000d883a 	mov	r6,zero
 82254e0:	000b883a 	mov	r5,zero
 82254e4:	1009883a 	mov	r4,r2
 82254e8:	821e5940 	call	821e594 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82254ec:	008209b4 	movhi	r2,2086
 82254f0:	10b62904 	addi	r2,r2,-10076
 82254f4:	e0ffff17 	ldw	r3,-4(fp)
 82254f8:	18c01324 	muli	r3,r3,76
 82254fc:	10c5883a 	add	r2,r2,r3
 8225500:	10800104 	addi	r2,r2,4
 8225504:	10800017 	ldw	r2,0(r2)
 8225508:	10800204 	addi	r2,r2,8
 822550c:	10800037 	ldwio	r2,0(r2)
 8225510:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 8225514:	008209b4 	movhi	r2,2086
 8225518:	10b62904 	addi	r2,r2,-10076
 822551c:	e0ffff17 	ldw	r3,-4(fp)
 8225520:	18c01324 	muli	r3,r3,76
 8225524:	10c5883a 	add	r2,r2,r3
 8225528:	10800104 	addi	r2,r2,4
 822552c:	10800017 	ldw	r2,0(r2)
 8225530:	10800204 	addi	r2,r2,8
 8225534:	e13ffe17 	ldw	r4,-8(fp)
 8225538:	00ffff44 	movi	r3,-3
 822553c:	20c6703a 	and	r3,r4,r3
 8225540:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 8225544:	008209b4 	movhi	r2,2086
 8225548:	10b73a04 	addi	r2,r2,-8984
 822554c:	e0ffff17 	ldw	r3,-4(fp)
 8225550:	18c7883a 	add	r3,r3,r3
 8225554:	18c7883a 	add	r3,r3,r3
 8225558:	10c5883a 	add	r2,r2,r3
 822555c:	10800017 	ldw	r2,0(r2)
 8225560:	10802717 	ldw	r2,156(r2)
 8225564:	00c00084 	movi	r3,2
 8225568:	10c00715 	stw	r3,28(r2)

  return SUCCESS;
 822556c:	0005883a 	mov	r2,zero
}
 8225570:	e037883a 	mov	sp,fp
 8225574:	dfc00117 	ldw	ra,4(sp)
 8225578:	df000017 	ldw	fp,0(sp)
 822557c:	dec00204 	addi	sp,sp,8
 8225580:	f800283a 	ret

08225584 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 8225584:	defffd04 	addi	sp,sp,-12
 8225588:	dfc00215 	stw	ra,8(sp)
 822558c:	df000115 	stw	fp,4(sp)
 8225590:	df000104 	addi	fp,sp,4
 8225594:	e13fff15 	stw	r4,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 8225598:	e0bfff17 	ldw	r2,-4(fp)
 822559c:	10800808 	cmpgei	r2,r2,32
 82255a0:	1000031e 	bne	r2,zero,82255b0 <close+0x2c>
 82255a4:	e13fff17 	ldw	r4,-4(fp)
 82255a8:	823b9880 	call	823b988 <alt_close>
 82255ac:	00000206 	br	82255b8 <close+0x34>
 82255b0:	e13fff17 	ldw	r4,-4(fp)
 82255b4:	82315980 	call	8231598 <t_socketclose>
}
 82255b8:	e037883a 	mov	sp,fp
 82255bc:	dfc00117 	ldw	ra,4(sp)
 82255c0:	df000017 	ldw	fp,0(sp)
 82255c4:	dec00204 	addi	sp,sp,8
 82255c8:	f800283a 	ret

082255cc <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 82255cc:	defff504 	addi	sp,sp,-44
 82255d0:	dfc00a15 	stw	ra,40(sp)
 82255d4:	df000915 	stw	fp,36(sp)
 82255d8:	df000904 	addi	fp,sp,36
 82255dc:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 82255e0:	d0a02e17 	ldw	r2,-32584(gp)
 82255e4:	e0bff815 	stw	r2,-32(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 82255e8:	d0a02e04 	addi	r2,gp,-32584
 82255ec:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82255f0:	00003f06 	br	82256f0 <iniche_devices_init+0x124>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 82255f4:	e0bff817 	ldw	r2,-32(fp)
 82255f8:	e0fff817 	ldw	r3,-32(fp)
 82255fc:	10c00415 	stw	r3,16(r2)
        p_dev->if_num = if_count;
 8225600:	e0bff817 	ldw	r2,-32(fp)
 8225604:	e0ffff17 	ldw	r3,-4(fp)
 8225608:	10c00515 	stw	r3,20(r2)
        p_dev->p_net = nets[p_dev->if_num];
 822560c:	e0bff817 	ldw	r2,-32(fp)
 8225610:	10c00517 	ldw	r3,20(r2)
 8225614:	008209b4 	movhi	r2,2086
 8225618:	10b73a04 	addi	r2,r2,-8984
 822561c:	18c7883a 	add	r3,r3,r3
 8225620:	18c7883a 	add	r3,r3,r3
 8225624:	10c5883a 	add	r2,r2,r3
 8225628:	10c00017 	ldw	r3,0(r2)
 822562c:	e0bff817 	ldw	r2,-32(fp)
 8225630:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 8225634:	e0bff817 	ldw	r2,-32(fp)
 8225638:	10800317 	ldw	r2,12(r2)
 822563c:	e13ff817 	ldw	r4,-32(fp)
 8225640:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 8225644:	e0bff817 	ldw	r2,-32(fp)
 8225648:	10800617 	ldw	r2,24(r2)
 822564c:	e0bffa15 	stw	r2,-24(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 8225650:	e17ffd04 	addi	r5,fp,-12
 8225654:	e13ffc04 	addi	r4,fp,-16
 8225658:	e0fffb04 	addi	r3,fp,-20
 822565c:	e0bffe04 	addi	r2,fp,-8
 8225660:	d8800015 	stw	r2,0(sp)
 8225664:	280f883a 	mov	r7,r5
 8225668:	200d883a 	mov	r6,r4
 822566c:	180b883a 	mov	r5,r3
 8225670:	e13ff817 	ldw	r4,-32(fp)
 8225674:	82011180 	call	8201118 <get_ip_addr>
 8225678:	10001726 	beq	r2,zero,82256d8 <iniche_devices_init+0x10c>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 822567c:	e0bffe17 	ldw	r2,-8(fp)
 8225680:	10000526 	beq	r2,zero,8225698 <iniche_devices_init+0xcc>
                p_net->n_flags |= NF_DHCPC;
 8225684:	e0bffa17 	ldw	r2,-24(fp)
 8225688:	10802a17 	ldw	r2,168(r2)
 822568c:	10c04014 	ori	r3,r2,256
 8225690:	e0bffa17 	ldw	r2,-24(fp)
 8225694:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 8225698:	e0fffb17 	ldw	r3,-20(fp)
 822569c:	e0bffa17 	ldw	r2,-24(fp)
 82256a0:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 82256a4:	e0fffc17 	ldw	r3,-16(fp)
 82256a8:	e0bffa17 	ldw	r2,-24(fp)
 82256ac:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 82256b0:	e0fffd17 	ldw	r3,-12(fp)
 82256b4:	e0bffa17 	ldw	r2,-24(fp)
 82256b8:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 82256bc:	e0fffa17 	ldw	r3,-24(fp)
 82256c0:	00820934 	movhi	r2,2084
 82256c4:	10b43804 	addi	r2,r2,-12064
 82256c8:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 82256cc:	e0bffa17 	ldw	r2,-24(fp)
 82256d0:	00c00084 	movi	r3,2
 82256d4:	10c02f05 	stb	r3,188(r2)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 82256d8:	e0bfff17 	ldw	r2,-4(fp)
 82256dc:	10800044 	addi	r2,r2,1
 82256e0:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 82256e4:	e0bff817 	ldw	r2,-32(fp)
 82256e8:	10800017 	ldw	r2,0(r2)
 82256ec:	e0bff815 	stw	r2,-32(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82256f0:	e0fff817 	ldw	r3,-32(fp)
 82256f4:	e0bff917 	ldw	r2,-28(fp)
 82256f8:	18bfbe1e 	bne	r3,r2,82255f4 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 82256fc:	e0bfff17 	ldw	r2,-4(fp)
}
 8225700:	e037883a 	mov	sp,fp
 8225704:	dfc00117 	ldw	ra,4(sp)
 8225708:	df000017 	ldw	fp,0(sp)
 822570c:	dec00204 	addi	sp,sp,8
 8225710:	f800283a 	ret

08225714 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 8225714:	defff904 	addi	sp,sp,-28
 8225718:	dfc00615 	stw	ra,24(sp)
 822571c:	df000515 	stw	fp,20(sp)
 8225720:	df000504 	addi	fp,sp,20
 8225724:	e13ffd15 	stw	r4,-12(fp)
 8225728:	e17ffe15 	stw	r5,-8(fp)
 822572c:	e1bfff15 	stw	r6,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225730:	e0bffd17 	ldw	r2,-12(fp)
 8225734:	10800808 	cmpgei	r2,r2,32
 8225738:	1000051e 	bne	r2,zero,8225750 <read+0x3c>
 822573c:	e1bfff17 	ldw	r6,-4(fp)
 8225740:	e17ffe17 	ldw	r5,-8(fp)
 8225744:	e13ffd17 	ldw	r4,-12(fp)
 8225748:	823c39c0 	call	823c39c <alt_read>
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 822574c:	00000806 	br	8225770 <read+0x5c>
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225750:	e0bfff17 	ldw	r2,-4(fp)
 8225754:	d8000115 	stw	zero,4(sp)
 8225758:	d8000015 	stw	zero,0(sp)
 822575c:	000f883a 	mov	r7,zero
 8225760:	100d883a 	mov	r6,r2
 8225764:	e17ffe17 	ldw	r5,-8(fp)
 8225768:	e13ffd17 	ldw	r4,-12(fp)
 822576c:	82280b00 	call	82280b0 <bsd_recvfrom>
}
 8225770:	e037883a 	mov	sp,fp
 8225774:	dfc00117 	ldw	ra,4(sp)
 8225778:	df000017 	ldw	fp,0(sp)
 822577c:	dec00204 	addi	sp,sp,8
 8225780:	f800283a 	ret

08225784 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 8225784:	defffb04 	addi	sp,sp,-20
 8225788:	dfc00415 	stw	ra,16(sp)
 822578c:	df000315 	stw	fp,12(sp)
 8225790:	df000304 	addi	fp,sp,12
 8225794:	e13ffd15 	stw	r4,-12(fp)
 8225798:	e17ffe15 	stw	r5,-8(fp)
 822579c:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 82257a0:	e0bffd17 	ldw	r2,-12(fp)
 82257a4:	10800808 	cmpgei	r2,r2,32
 82257a8:	1000051e 	bne	r2,zero,82257c0 <write+0x3c>
  {
    return alt_write (fd, ptr, len);
 82257ac:	e1bfff17 	ldw	r6,-4(fp)
 82257b0:	e17ffe17 	ldw	r5,-8(fp)
 82257b4:	e13ffd17 	ldw	r4,-12(fp)
 82257b8:	823c8e40 	call	823c8e4 <alt_write>
 82257bc:	00000606 	br	82257d8 <write+0x54>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 82257c0:	e0bfff17 	ldw	r2,-4(fp)
 82257c4:	000f883a 	mov	r7,zero
 82257c8:	100d883a 	mov	r6,r2
 82257cc:	e17ffe17 	ldw	r5,-8(fp)
 82257d0:	e13ffd17 	ldw	r4,-12(fp)
 82257d4:	82312bc0 	call	82312bc <t_send>
  }  
}
 82257d8:	e037883a 	mov	sp,fp
 82257dc:	dfc00117 	ldw	ra,4(sp)
 82257e0:	df000017 	ldw	fp,0(sp)
 82257e4:	dec00204 	addi	sp,sp,8
 82257e8:	f800283a 	ret

082257ec <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 82257ec:	defffc04 	addi	sp,sp,-16
 82257f0:	dfc00315 	stw	ra,12(sp)
 82257f4:	df000215 	stw	fp,8(sp)
 82257f8:	df000204 	addi	fp,sp,8
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 82257fc:	e03ffe15 	stw	zero,-8(fp)
 8225800:	00004a06 	br	822592c <Netinit+0x140>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 8225804:	008209b4 	movhi	r2,2086
 8225808:	10b73a04 	addi	r2,r2,-8984
 822580c:	e0fffe17 	ldw	r3,-8(fp)
 8225810:	18c7883a 	add	r3,r3,r3
 8225814:	18c7883a 	add	r3,r3,r3
 8225818:	10c5883a 	add	r2,r2,r3
 822581c:	10800017 	ldw	r2,0(r2)
 8225820:	10802717 	ldw	r2,156(r2)
 8225824:	10800217 	ldw	r2,8(r2)
 8225828:	10800198 	cmpnei	r2,r2,6
 822582c:	1000241e 	bne	r2,zero,82258c0 <Netinit+0xd4>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 8225830:	008209b4 	movhi	r2,2086
 8225834:	10b73a04 	addi	r2,r2,-8984
 8225838:	e0fffe17 	ldw	r3,-8(fp)
 822583c:	18c7883a 	add	r3,r3,r3
 8225840:	18c7883a 	add	r3,r3,r3
 8225844:	10c5883a 	add	r2,r2,r3
 8225848:	10800017 	ldw	r2,0(r2)
 822584c:	10800917 	ldw	r2,36(r2)
 8225850:	1000091e 	bne	r2,zero,8225878 <Netinit+0x8c>
            nets[i]->n_mtu = 1514;
 8225854:	008209b4 	movhi	r2,2086
 8225858:	10b73a04 	addi	r2,r2,-8984
 822585c:	e0fffe17 	ldw	r3,-8(fp)
 8225860:	18c7883a 	add	r3,r3,r3
 8225864:	18c7883a 	add	r3,r3,r3
 8225868:	10c5883a 	add	r2,r2,r3
 822586c:	10800017 	ldw	r2,0(r2)
 8225870:	00c17a84 	movi	r3,1514
 8225874:	10c00915 	stw	r3,36(r2)

         if (nets[i]->n_lnh == 0)
 8225878:	008209b4 	movhi	r2,2086
 822587c:	10b73a04 	addi	r2,r2,-8984
 8225880:	e0fffe17 	ldw	r3,-8(fp)
 8225884:	18c7883a 	add	r3,r3,r3
 8225888:	18c7883a 	add	r3,r3,r3
 822588c:	10c5883a 	add	r2,r2,r3
 8225890:	10800017 	ldw	r2,0(r2)
 8225894:	10800817 	ldw	r2,32(r2)
 8225898:	1000091e 	bne	r2,zero,82258c0 <Netinit+0xd4>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 822589c:	008209b4 	movhi	r2,2086
 82258a0:	10b73a04 	addi	r2,r2,-8984
 82258a4:	e0fffe17 	ldw	r3,-8(fp)
 82258a8:	18c7883a 	add	r3,r3,r3
 82258ac:	18c7883a 	add	r3,r3,r3
 82258b0:	10c5883a 	add	r2,r2,r3
 82258b4:	10800017 	ldw	r2,0(r2)
 82258b8:	00c00404 	movi	r3,16
 82258bc:	10c00815 	stw	r3,32(r2)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 82258c0:	008209b4 	movhi	r2,2086
 82258c4:	10b73a04 	addi	r2,r2,-8984
 82258c8:	e0fffe17 	ldw	r3,-8(fp)
 82258cc:	18c7883a 	add	r3,r3,r3
 82258d0:	18c7883a 	add	r3,r3,r3
 82258d4:	10c5883a 	add	r2,r2,r3
 82258d8:	10800017 	ldw	r2,0(r2)
 82258dc:	10800817 	ldw	r2,32(r2)
 82258e0:	d0e08117 	ldw	r3,-32252(gp)
 82258e4:	10c0010e 	bge	r2,r3,82258ec <Netinit+0x100>
 82258e8:	1805883a 	mov	r2,r3
 82258ec:	d0a08115 	stw	r2,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 82258f0:	008209b4 	movhi	r2,2086
 82258f4:	10b73a04 	addi	r2,r2,-8984
 82258f8:	e0fffe17 	ldw	r3,-8(fp)
 82258fc:	18c7883a 	add	r3,r3,r3
 8225900:	18c7883a 	add	r3,r3,r3
 8225904:	10c5883a 	add	r2,r2,r3
 8225908:	10800017 	ldw	r2,0(r2)
 822590c:	10800917 	ldw	r2,36(r2)
 8225910:	d0e08217 	ldw	r3,-32248(gp)
 8225914:	10c0010e 	bge	r2,r3,822591c <Netinit+0x130>
 8225918:	1805883a 	mov	r2,r3
 822591c:	d0a08215 	stw	r2,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225920:	e0bffe17 	ldw	r2,-8(fp)
 8225924:	10800044 	addi	r2,r2,1
 8225928:	e0bffe15 	stw	r2,-8(fp)
 822592c:	d0a08417 	ldw	r2,-32240(gp)
 8225930:	1007883a 	mov	r3,r2
 8225934:	e0bffe17 	ldw	r2,-8(fp)
 8225938:	10ffb216 	blt	r2,r3,8225804 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 822593c:	008209b4 	movhi	r2,2086
 8225940:	10b67504 	addi	r2,r2,-9772
 8225944:	10000115 	stw	zero,4(r2)
 8225948:	008209b4 	movhi	r2,2086
 822594c:	10b67504 	addi	r2,r2,-9772
 8225950:	10c00117 	ldw	r3,4(r2)
 8225954:	008209b4 	movhi	r2,2086
 8225958:	10b67504 	addi	r2,r2,-9772
 822595c:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 8225960:	008209b4 	movhi	r2,2086
 8225964:	10b67504 	addi	r2,r2,-9772
 8225968:	10000215 	stw	zero,8(r2)
 822596c:	008209b4 	movhi	r2,2086
 8225970:	10b67504 	addi	r2,r2,-9772
 8225974:	10c00217 	ldw	r3,8(r2)
 8225978:	008209b4 	movhi	r2,2086
 822597c:	10b67504 	addi	r2,r2,-9772
 8225980:	10c00415 	stw	r3,16(r2)
 8225984:	008209b4 	movhi	r2,2086
 8225988:	10b67504 	addi	r2,r2,-9772
 822598c:	10c00417 	ldw	r3,16(r2)
 8225990:	008209b4 	movhi	r2,2086
 8225994:	10b67504 	addi	r2,r2,-9772
 8225998:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 822599c:	01000084 	movi	r4,2
 82259a0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   e = pk_init();
 82259a4:	822c49c0 	call	822c49c <pk_init>
 82259a8:	e0bfff15 	stw	r2,-4(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82259ac:	01000084 	movi	r4,2
 82259b0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 82259b4:	e0bfff17 	ldw	r2,-4(fp)
 82259b8:	10000226 	beq	r2,zero,82259c4 <Netinit+0x1d8>
      return e;
 82259bc:	e0bfff17 	ldw	r2,-4(fp)
 82259c0:	0000ff06 	br	8225dc0 <Netinit+0x5d4>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 82259c4:	010208b4 	movhi	r4,2082
 82259c8:	2117cb04 	addi	r4,r4,24364
 82259cc:	82268740 	call	8226874 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 82259d0:	e03ffe15 	stw	zero,-8(fp)
 82259d4:	0000f506 	br	8225dac <Netinit+0x5c0>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 82259d8:	008209b4 	movhi	r2,2086
 82259dc:	10b73a04 	addi	r2,r2,-8984
 82259e0:	e0fffe17 	ldw	r3,-8(fp)
 82259e4:	18c7883a 	add	r3,r3,r3
 82259e8:	18c7883a 	add	r3,r3,r3
 82259ec:	10c5883a 	add	r2,r2,r3
 82259f0:	10800017 	ldw	r2,0(r2)
 82259f4:	10800217 	ldw	r2,8(r2)
 82259f8:	10009126 	beq	r2,zero,8225c40 <Netinit+0x454>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 82259fc:	008209b4 	movhi	r2,2086
 8225a00:	10b73a04 	addi	r2,r2,-8984
 8225a04:	e0fffe17 	ldw	r3,-8(fp)
 8225a08:	18c7883a 	add	r3,r3,r3
 8225a0c:	18c7883a 	add	r3,r3,r3
 8225a10:	10c5883a 	add	r2,r2,r3
 8225a14:	10800017 	ldw	r2,0(r2)
 8225a18:	10800217 	ldw	r2,8(r2)
 8225a1c:	e13ffe17 	ldw	r4,-8(fp)
 8225a20:	103ee83a 	callr	r2
 8225a24:	e0bfff15 	stw	r2,-4(fp)
 8225a28:	e0bfff17 	ldw	r2,-4(fp)
 8225a2c:	10001026 	beq	r2,zero,8225a70 <Netinit+0x284>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 8225a30:	e1bffe17 	ldw	r6,-8(fp)
 8225a34:	e17fff17 	ldw	r5,-4(fp)
 8225a38:	01020974 	movhi	r4,2085
 8225a3c:	213ecf04 	addi	r4,r4,-1220
 8225a40:	82030ec0 	call	82030ec <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 8225a44:	008209b4 	movhi	r2,2086
 8225a48:	10b73a04 	addi	r2,r2,-8984
 8225a4c:	e0fffe17 	ldw	r3,-8(fp)
 8225a50:	18c7883a 	add	r3,r3,r3
 8225a54:	18c7883a 	add	r3,r3,r3
 8225a58:	10c5883a 	add	r2,r2,r3
 8225a5c:	10800017 	ldw	r2,0(r2)
 8225a60:	10802717 	ldw	r2,156(r2)
 8225a64:	00c00084 	movi	r3,2
 8225a68:	10c00715 	stw	r3,28(r2)
            continue;   /* ignore ifaces which fail */
 8225a6c:	0000cc06 	br	8225da0 <Netinit+0x5b4>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 8225a70:	008209b4 	movhi	r2,2086
 8225a74:	10b73a04 	addi	r2,r2,-8984
 8225a78:	e0fffe17 	ldw	r3,-8(fp)
 8225a7c:	18c7883a 	add	r3,r3,r3
 8225a80:	18c7883a 	add	r3,r3,r3
 8225a84:	10c5883a 	add	r2,r2,r3
 8225a88:	10800017 	ldw	r2,0(r2)
 8225a8c:	10802717 	ldw	r2,156(r2)
 8225a90:	10800217 	ldw	r2,8(r2)
 8225a94:	10800198 	cmpnei	r2,r2,6
 8225a98:	1000111e 	bne	r2,zero,8225ae0 <Netinit+0x2f4>
            nets[i]->n_flags |= NF_BCAST;
 8225a9c:	008209b4 	movhi	r2,2086
 8225aa0:	10b73a04 	addi	r2,r2,-8984
 8225aa4:	e0fffe17 	ldw	r3,-8(fp)
 8225aa8:	18c7883a 	add	r3,r3,r3
 8225aac:	18c7883a 	add	r3,r3,r3
 8225ab0:	10c5883a 	add	r2,r2,r3
 8225ab4:	11000017 	ldw	r4,0(r2)
 8225ab8:	008209b4 	movhi	r2,2086
 8225abc:	10b73a04 	addi	r2,r2,-8984
 8225ac0:	e0fffe17 	ldw	r3,-8(fp)
 8225ac4:	18c7883a 	add	r3,r3,r3
 8225ac8:	18c7883a 	add	r3,r3,r3
 8225acc:	10c5883a 	add	r2,r2,r3
 8225ad0:	10800017 	ldw	r2,0(r2)
 8225ad4:	10802a17 	ldw	r2,168(r2)
 8225ad8:	10800054 	ori	r2,r2,1
 8225adc:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 8225ae0:	008209b4 	movhi	r2,2086
 8225ae4:	10b73a04 	addi	r2,r2,-8984
 8225ae8:	e0fffe17 	ldw	r3,-8(fp)
 8225aec:	18c7883a 	add	r3,r3,r3
 8225af0:	18c7883a 	add	r3,r3,r3
 8225af4:	10c5883a 	add	r2,r2,r3
 8225af8:	10800017 	ldw	r2,0(r2)
 8225afc:	10802717 	ldw	r2,156(r2)
 8225b00:	00c00044 	movi	r3,1
 8225b04:	10c00615 	stw	r3,24(r2)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 8225b08:	008209b4 	movhi	r2,2086
 8225b0c:	10b73a04 	addi	r2,r2,-8984
 8225b10:	e0fffe17 	ldw	r3,-8(fp)
 8225b14:	18c7883a 	add	r3,r3,r3
 8225b18:	18c7883a 	add	r3,r3,r3
 8225b1c:	10c5883a 	add	r2,r2,r3
 8225b20:	10800017 	ldw	r2,0(r2)
 8225b24:	10800103 	ldbu	r2,4(r2)
 8225b28:	10803fcc 	andi	r2,r2,255
 8225b2c:	1080201c 	xori	r2,r2,128
 8225b30:	10bfe004 	addi	r2,r2,-128
 8225b34:	1000421e 	bne	r2,zero,8225c40 <Netinit+0x454>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 8225b38:	008209b4 	movhi	r2,2086
 8225b3c:	10b73a04 	addi	r2,r2,-8984
 8225b40:	e0fffe17 	ldw	r3,-8(fp)
 8225b44:	18c7883a 	add	r3,r3,r3
 8225b48:	18c7883a 	add	r3,r3,r3
 8225b4c:	10c5883a 	add	r2,r2,r3
 8225b50:	10800017 	ldw	r2,0(r2)
 8225b54:	10802717 	ldw	r2,156(r2)
 8225b58:	10800217 	ldw	r2,8(r2)
 8225b5c:	10800198 	cmpnei	r2,r2,6
 8225b60:	1000131e 	bne	r2,zero,8225bb0 <Netinit+0x3c4>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 8225b64:	008209b4 	movhi	r2,2086
 8225b68:	10b73a04 	addi	r2,r2,-8984
 8225b6c:	e0fffe17 	ldw	r3,-8(fp)
 8225b70:	18c7883a 	add	r3,r3,r3
 8225b74:	18c7883a 	add	r3,r3,r3
 8225b78:	10c5883a 	add	r2,r2,r3
 8225b7c:	10800017 	ldw	r2,0(r2)
 8225b80:	00c01944 	movi	r3,101
 8225b84:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 't';
 8225b88:	008209b4 	movhi	r2,2086
 8225b8c:	10b73a04 	addi	r2,r2,-8984
 8225b90:	e0fffe17 	ldw	r3,-8(fp)
 8225b94:	18c7883a 	add	r3,r3,r3
 8225b98:	18c7883a 	add	r3,r3,r3
 8225b9c:	10c5883a 	add	r2,r2,r3
 8225ba0:	10800017 	ldw	r2,0(r2)
 8225ba4:	00c01d04 	movi	r3,116
 8225ba8:	10c00145 	stb	r3,5(r2)
 8225bac:	00001206 	br	8225bf8 <Netinit+0x40c>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 8225bb0:	008209b4 	movhi	r2,2086
 8225bb4:	10b73a04 	addi	r2,r2,-8984
 8225bb8:	e0fffe17 	ldw	r3,-8(fp)
 8225bbc:	18c7883a 	add	r3,r3,r3
 8225bc0:	18c7883a 	add	r3,r3,r3
 8225bc4:	10c5883a 	add	r2,r2,r3
 8225bc8:	10800017 	ldw	r2,0(r2)
 8225bcc:	00c01a44 	movi	r3,105
 8225bd0:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 'f';
 8225bd4:	008209b4 	movhi	r2,2086
 8225bd8:	10b73a04 	addi	r2,r2,-8984
 8225bdc:	e0fffe17 	ldw	r3,-8(fp)
 8225be0:	18c7883a 	add	r3,r3,r3
 8225be4:	18c7883a 	add	r3,r3,r3
 8225be8:	10c5883a 	add	r2,r2,r3
 8225bec:	10800017 	ldw	r2,0(r2)
 8225bf0:	00c01984 	movi	r3,102
 8225bf4:	10c00145 	stb	r3,5(r2)
            }
            nets[i]->name[2] = (char)(i + '1');
 8225bf8:	008209b4 	movhi	r2,2086
 8225bfc:	10b73a04 	addi	r2,r2,-8984
 8225c00:	e0fffe17 	ldw	r3,-8(fp)
 8225c04:	18c7883a 	add	r3,r3,r3
 8225c08:	18c7883a 	add	r3,r3,r3
 8225c0c:	10c5883a 	add	r2,r2,r3
 8225c10:	10800017 	ldw	r2,0(r2)
 8225c14:	e0fffe17 	ldw	r3,-8(fp)
 8225c18:	18c00c44 	addi	r3,r3,49
 8225c1c:	10c00185 	stb	r3,6(r2)
            nets[i]->name[3] = '\0';
 8225c20:	008209b4 	movhi	r2,2086
 8225c24:	10b73a04 	addi	r2,r2,-8984
 8225c28:	e0fffe17 	ldw	r3,-8(fp)
 8225c2c:	18c7883a 	add	r3,r3,r3
 8225c30:	18c7883a 	add	r3,r3,r3
 8225c34:	10c5883a 	add	r2,r2,r3
 8225c38:	10800017 	ldw	r2,0(r2)
 8225c3c:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 8225c40:	e13ffe17 	ldw	r4,-8(fp)
 8225c44:	8225dd40 	call	8225dd4 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 8225c48:	008209b4 	movhi	r2,2086
 8225c4c:	10b73a04 	addi	r2,r2,-8984
 8225c50:	e0fffe17 	ldw	r3,-8(fp)
 8225c54:	18c7883a 	add	r3,r3,r3
 8225c58:	18c7883a 	add	r3,r3,r3
 8225c5c:	10c5883a 	add	r2,r2,r3
 8225c60:	10800017 	ldw	r2,0(r2)
 8225c64:	10800a17 	ldw	r2,40(r2)
 8225c68:	10004d26 	beq	r2,zero,8225da0 <Netinit+0x5b4>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225c6c:	008209b4 	movhi	r2,2086
 8225c70:	10b73a04 	addi	r2,r2,-8984
 8225c74:	e0fffe17 	ldw	r3,-8(fp)
 8225c78:	18c7883a 	add	r3,r3,r3
 8225c7c:	18c7883a 	add	r3,r3,r3
 8225c80:	10c5883a 	add	r2,r2,r3
 8225c84:	11000017 	ldw	r4,0(r2)
 8225c88:	008209b4 	movhi	r2,2086
 8225c8c:	10b73a04 	addi	r2,r2,-8984
 8225c90:	e0fffe17 	ldw	r3,-8(fp)
 8225c94:	18c7883a 	add	r3,r3,r3
 8225c98:	18c7883a 	add	r3,r3,r3
 8225c9c:	10c5883a 	add	r2,r2,r3
 8225ca0:	10800017 	ldw	r2,0(r2)
 8225ca4:	11400a17 	ldw	r5,40(r2)
 8225ca8:	008209b4 	movhi	r2,2086
 8225cac:	10b73a04 	addi	r2,r2,-8984
 8225cb0:	e0fffe17 	ldw	r3,-8(fp)
 8225cb4:	18c7883a 	add	r3,r3,r3
 8225cb8:	18c7883a 	add	r3,r3,r3
 8225cbc:	10c5883a 	add	r2,r2,r3
 8225cc0:	10800017 	ldw	r2,0(r2)
 8225cc4:	10800c17 	ldw	r2,48(r2)
 8225cc8:	0084303a 	nor	r2,zero,r2
 8225ccc:	2884b03a 	or	r2,r5,r2
 8225cd0:	20800e15 	stw	r2,56(r4)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 8225cd4:	008209b4 	movhi	r2,2086
 8225cd8:	10b73a04 	addi	r2,r2,-8984
 8225cdc:	e0fffe17 	ldw	r3,-8(fp)
 8225ce0:	18c7883a 	add	r3,r3,r3
 8225ce4:	18c7883a 	add	r3,r3,r3
 8225ce8:	10c5883a 	add	r2,r2,r3
 8225cec:	11000017 	ldw	r4,0(r2)
 8225cf0:	008209b4 	movhi	r2,2086
 8225cf4:	10b73a04 	addi	r2,r2,-8984
 8225cf8:	e0fffe17 	ldw	r3,-8(fp)
 8225cfc:	18c7883a 	add	r3,r3,r3
 8225d00:	18c7883a 	add	r3,r3,r3
 8225d04:	10c5883a 	add	r2,r2,r3
 8225d08:	10800017 	ldw	r2,0(r2)
 8225d0c:	11400a17 	ldw	r5,40(r2)
 8225d10:	008209b4 	movhi	r2,2086
 8225d14:	10b73a04 	addi	r2,r2,-8984
 8225d18:	e0fffe17 	ldw	r3,-8(fp)
 8225d1c:	18c7883a 	add	r3,r3,r3
 8225d20:	18c7883a 	add	r3,r3,r3
 8225d24:	10c5883a 	add	r2,r2,r3
 8225d28:	10800017 	ldw	r2,0(r2)
 8225d2c:	10800c17 	ldw	r2,48(r2)
 8225d30:	2884703a 	and	r2,r5,r2
 8225d34:	20800f15 	stw	r2,60(r4)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225d38:	008209b4 	movhi	r2,2086
 8225d3c:	10b73a04 	addi	r2,r2,-8984
 8225d40:	e0fffe17 	ldw	r3,-8(fp)
 8225d44:	18c7883a 	add	r3,r3,r3
 8225d48:	18c7883a 	add	r3,r3,r3
 8225d4c:	10c5883a 	add	r2,r2,r3
 8225d50:	11000017 	ldw	r4,0(r2)
 8225d54:	008209b4 	movhi	r2,2086
 8225d58:	10b73a04 	addi	r2,r2,-8984
 8225d5c:	e0fffe17 	ldw	r3,-8(fp)
 8225d60:	18c7883a 	add	r3,r3,r3
 8225d64:	18c7883a 	add	r3,r3,r3
 8225d68:	10c5883a 	add	r2,r2,r3
 8225d6c:	10800017 	ldw	r2,0(r2)
 8225d70:	11400a17 	ldw	r5,40(r2)
 8225d74:	008209b4 	movhi	r2,2086
 8225d78:	10b73a04 	addi	r2,r2,-8984
 8225d7c:	e0fffe17 	ldw	r3,-8(fp)
 8225d80:	18c7883a 	add	r3,r3,r3
 8225d84:	18c7883a 	add	r3,r3,r3
 8225d88:	10c5883a 	add	r2,r2,r3
 8225d8c:	10800017 	ldw	r2,0(r2)
 8225d90:	10800c17 	ldw	r2,48(r2)
 8225d94:	0084303a 	nor	r2,zero,r2
 8225d98:	2884b03a 	or	r2,r5,r2
 8225d9c:	20801015 	stw	r2,64(r4)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8225da0:	e0bffe17 	ldw	r2,-8(fp)
 8225da4:	10800044 	addi	r2,r2,1
 8225da8:	e0bffe15 	stw	r2,-8(fp)
 8225dac:	d0a08417 	ldw	r2,-32240(gp)
 8225db0:	1007883a 	mov	r3,r2
 8225db4:	e0bffe17 	ldw	r2,-8(fp)
 8225db8:	10ff0716 	blt	r2,r3,82259d8 <Netinit+0x1ec>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 8225dbc:	0005883a 	mov	r2,zero
}
 8225dc0:	e037883a 	mov	sp,fp
 8225dc4:	dfc00117 	ldw	ra,4(sp)
 8225dc8:	df000017 	ldw	fp,0(sp)
 8225dcc:	dec00204 	addi	sp,sp,8
 8225dd0:	f800283a 	ret

08225dd4 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 8225dd4:	defffc04 	addi	sp,sp,-16
 8225dd8:	dfc00315 	stw	ra,12(sp)
 8225ddc:	df000215 	stw	fp,8(sp)
 8225de0:	df000204 	addi	fp,sp,8
 8225de4:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 8225de8:	008209b4 	movhi	r2,2086
 8225dec:	10b73a04 	addi	r2,r2,-8984
 8225df0:	e0ffff17 	ldw	r3,-4(fp)
 8225df4:	18c7883a 	add	r3,r3,r3
 8225df8:	18c7883a 	add	r3,r3,r3
 8225dfc:	10c5883a 	add	r2,r2,r3
 8225e00:	10800017 	ldw	r2,0(r2)
 8225e04:	10800c17 	ldw	r2,48(r2)
 8225e08:	1000421e 	bne	r2,zero,8225f14 <fixup_subnet_mask+0x140>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 8225e0c:	008209b4 	movhi	r2,2086
 8225e10:	10b73a04 	addi	r2,r2,-8984
 8225e14:	e0ffff17 	ldw	r3,-4(fp)
 8225e18:	18c7883a 	add	r3,r3,r3
 8225e1c:	18c7883a 	add	r3,r3,r3
 8225e20:	10c5883a 	add	r2,r2,r3
 8225e24:	10800017 	ldw	r2,0(r2)
 8225e28:	10800a17 	ldw	r2,40(r2)
 8225e2c:	1080200c 	andi	r2,r2,128
 8225e30:	1000031e 	bne	r2,zero,8225e40 <fixup_subnet_mask+0x6c>
      smask = 0xFF000000L;
 8225e34:	00bfc034 	movhi	r2,65280
 8225e38:	e0bffe15 	stw	r2,-8(fp)
 8225e3c:	00001f06 	br	8225ebc <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 8225e40:	008209b4 	movhi	r2,2086
 8225e44:	10b73a04 	addi	r2,r2,-8984
 8225e48:	e0ffff17 	ldw	r3,-4(fp)
 8225e4c:	18c7883a 	add	r3,r3,r3
 8225e50:	18c7883a 	add	r3,r3,r3
 8225e54:	10c5883a 	add	r2,r2,r3
 8225e58:	10800017 	ldw	r2,0(r2)
 8225e5c:	10800a17 	ldw	r2,40(r2)
 8225e60:	1080300c 	andi	r2,r2,192
 8225e64:	10802018 	cmpnei	r2,r2,128
 8225e68:	1000031e 	bne	r2,zero,8225e78 <fixup_subnet_mask+0xa4>
      smask = 0xFFFF0000L;
 8225e6c:	00bffff4 	movhi	r2,65535
 8225e70:	e0bffe15 	stw	r2,-8(fp)
 8225e74:	00001106 	br	8225ebc <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 8225e78:	008209b4 	movhi	r2,2086
 8225e7c:	10b73a04 	addi	r2,r2,-8984
 8225e80:	e0ffff17 	ldw	r3,-4(fp)
 8225e84:	18c7883a 	add	r3,r3,r3
 8225e88:	18c7883a 	add	r3,r3,r3
 8225e8c:	10c5883a 	add	r2,r2,r3
 8225e90:	10800017 	ldw	r2,0(r2)
 8225e94:	10800a17 	ldw	r2,40(r2)
 8225e98:	1080380c 	andi	r2,r2,224
 8225e9c:	10803018 	cmpnei	r2,r2,192
 8225ea0:	1000031e 	bne	r2,zero,8225eb0 <fixup_subnet_mask+0xdc>
      smask = 0xFFFFFF00L;
 8225ea4:	00bfc004 	movi	r2,-256
 8225ea8:	e0bffe15 	stw	r2,-8(fp)
 8225eac:	00000306 	br	8225ebc <fixup_subnet_mask+0xe8>
   else
   {
      dtrap();    /* bad logic or setup values */
 8225eb0:	822d2e00 	call	822d2e0 <dtrap>
      smask = 0xFFFFFF00L;
 8225eb4:	00bfc004 	movi	r2,-256
 8225eb8:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 8225ebc:	008209b4 	movhi	r2,2086
 8225ec0:	10b73a04 	addi	r2,r2,-8984
 8225ec4:	e0ffff17 	ldw	r3,-4(fp)
 8225ec8:	18c7883a 	add	r3,r3,r3
 8225ecc:	18c7883a 	add	r3,r3,r3
 8225ed0:	10c5883a 	add	r2,r2,r3
 8225ed4:	10800017 	ldw	r2,0(r2)
 8225ed8:	e0fffe17 	ldw	r3,-8(fp)
 8225edc:	1808d63a 	srli	r4,r3,24
 8225ee0:	e0fffe17 	ldw	r3,-8(fp)
 8225ee4:	1806d23a 	srli	r3,r3,8
 8225ee8:	18ffc00c 	andi	r3,r3,65280
 8225eec:	20c8b03a 	or	r4,r4,r3
 8225ef0:	e0fffe17 	ldw	r3,-8(fp)
 8225ef4:	18ffc00c 	andi	r3,r3,65280
 8225ef8:	1806923a 	slli	r3,r3,8
 8225efc:	20c8b03a 	or	r4,r4,r3
 8225f00:	e0fffe17 	ldw	r3,-8(fp)
 8225f04:	1806963a 	slli	r3,r3,24
 8225f08:	20c6b03a 	or	r3,r4,r3
 8225f0c:	10c00c15 	stw	r3,48(r2)
 8225f10:	00000106 	br	8225f18 <fixup_subnet_mask+0x144>
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
      return;
 8225f14:	0001883a 	nop
   {
      dtrap();    /* bad logic or setup values */
      smask = 0xFFFFFF00L;
   }
   nets[netnum]->snmask = htonl(smask);
}
 8225f18:	e037883a 	mov	sp,fp
 8225f1c:	dfc00117 	ldw	ra,4(sp)
 8225f20:	df000017 	ldw	fp,0(sp)
 8225f24:	dec00204 	addi	sp,sp,8
 8225f28:	f800283a 	ret

08225f2c <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 8225f2c:	defffc04 	addi	sp,sp,-16
 8225f30:	dfc00315 	stw	ra,12(sp)
 8225f34:	df000215 	stw	fp,8(sp)
 8225f38:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 8225f3c:	e03fff15 	stw	zero,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 8225f40:	d0a08317 	ldw	r2,-32244(gp)
 8225f44:	1080010c 	andi	r2,r2,4
 8225f48:	10000326 	beq	r2,zero,8225f58 <netclose+0x2c>
 8225f4c:	01020974 	movhi	r4,2085
 8225f50:	213ed604 	addi	r4,r4,-1192
 8225f54:	82033700 	call	8203370 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8225f58:	008209b4 	movhi	r2,2086
 8225f5c:	10b97b04 	addi	r2,r2,-6676
 8225f60:	10800017 	ldw	r2,0(r2)
 8225f64:	e0bffe15 	stw	r2,-8(fp)
 8225f68:	00002106 	br	8225ff0 <netclose+0xc4>
   {
      if (ifp->n_close)
 8225f6c:	e0bffe17 	ldw	r2,-8(fp)
 8225f70:	10800517 	ldw	r2,20(r2)
 8225f74:	10000f26 	beq	r2,zero,8225fb4 <netclose+0x88>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 8225f78:	e0bffe17 	ldw	r2,-8(fp)
 8225f7c:	10802717 	ldw	r2,156(r2)
 8225f80:	10800117 	ldw	r2,4(r2)
 8225f84:	100b883a 	mov	r5,r2
 8225f88:	01020974 	movhi	r4,2085
 8225f8c:	213edb04 	addi	r4,r4,-1172
 8225f90:	82030ec0 	call	82030ec <printf>
         (*(ifp->n_close))(index++);
 8225f94:	e0bffe17 	ldw	r2,-8(fp)
 8225f98:	10c00517 	ldw	r3,20(r2)
 8225f9c:	e0bfff17 	ldw	r2,-4(fp)
 8225fa0:	11000044 	addi	r4,r2,1
 8225fa4:	e13fff15 	stw	r4,-4(fp)
 8225fa8:	1009883a 	mov	r4,r2
 8225fac:	183ee83a 	callr	r3
 8225fb0:	00000c06 	br	8225fe4 <netclose+0xb8>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 8225fb4:	d0a08317 	ldw	r2,-32244(gp)
 8225fb8:	1080010c 	andi	r2,r2,4
 8225fbc:	10000626 	beq	r2,zero,8225fd8 <netclose+0xac>
 8225fc0:	e0bffe17 	ldw	r2,-8(fp)
 8225fc4:	10800104 	addi	r2,r2,4
 8225fc8:	100b883a 	mov	r5,r2
 8225fcc:	01020974 	movhi	r4,2085
 8225fd0:	213ee204 	addi	r4,r4,-1144
 8225fd4:	82030ec0 	call	82030ec <printf>
#endif
         index++;
 8225fd8:	e0bfff17 	ldw	r2,-4(fp)
 8225fdc:	10800044 	addi	r2,r2,1
 8225fe0:	e0bfff15 	stw	r2,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8225fe4:	e0bffe17 	ldw	r2,-8(fp)
 8225fe8:	10800017 	ldw	r2,0(r2)
 8225fec:	e0bffe15 	stw	r2,-8(fp)
 8225ff0:	e0bffe17 	ldw	r2,-8(fp)
 8225ff4:	103fdd1e 	bne	r2,zero,8225f6c <netclose+0x40>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 8225ff8:	0001883a 	nop
 8225ffc:	e037883a 	mov	sp,fp
 8226000:	dfc00117 	ldw	ra,4(sp)
 8226004:	df000017 	ldw	fp,0(sp)
 8226008:	dec00204 	addi	sp,sp,8
 822600c:	f800283a 	ret

08226010 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 8226010:	defff904 	addi	sp,sp,-28
 8226014:	dfc00615 	stw	ra,24(sp)
 8226018:	df000515 	stw	fp,20(sp)
 822601c:	df000504 	addi	fp,sp,20
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 8226020:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 8226024:	0000d906 	br	822638c <pktdemux+0x37c>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 8226028:	e0fffb17 	ldw	r3,-20(fp)
 822602c:	18800044 	addi	r2,r3,1
 8226030:	e0bffb15 	stw	r2,-20(fp)
 8226034:	008209b4 	movhi	r2,2086
 8226038:	10b7e104 	addi	r2,r2,-8316
 822603c:	10800217 	ldw	r2,8(r2)
 8226040:	10c0020e 	bge	r2,r3,822604c <pktdemux+0x3c>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 8226044:	82295580 	call	8229558 <tk_yield>
         pkts = 0;   /* reset counter */
 8226048:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 822604c:	01000044 	movi	r4,1
 8226050:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 8226054:	010209b4 	movhi	r4,2086
 8226058:	21367504 	addi	r4,r4,-9772
 822605c:	822cc100 	call	822cc10 <getq>
 8226060:	e0bffc15 	stw	r2,-16(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 8226064:	01000044 	movi	r4,1
 8226068:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 822606c:	e0bffc17 	ldw	r2,-16(fp)
 8226070:	1000031e 	bne	r2,zero,8226080 <pktdemux+0x70>
 8226074:	01020974 	movhi	r4,2085
 8226078:	213ee904 	addi	r4,r4,-1116
 822607c:	82289940 	call	8228994 <panic>
      ifc = pkt->net;
 8226080:	e0bffc17 	ldw	r2,-16(fp)
 8226084:	10800617 	ldw	r2,24(r2)
 8226088:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 822608c:	e0bffd17 	ldw	r2,-12(fp)
 8226090:	10802717 	ldw	r2,156(r2)
 8226094:	e0bffe15 	stw	r2,-8(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 8226098:	e0bffc17 	ldw	r2,-16(fp)
 822609c:	10800117 	ldw	r2,4(r2)
 82260a0:	10800084 	addi	r2,r2,2
 82260a4:	100b883a 	mov	r5,r2
 82260a8:	e13ffd17 	ldw	r4,-12(fp)
 82260ac:	823eb040 	call	823eb04 <isbcast>
 82260b0:	10000626 	beq	r2,zero,82260cc <pktdemux+0xbc>
         mib->ifInNUcastPkts++;
 82260b4:	e0bffe17 	ldw	r2,-8(fp)
 82260b8:	10800b17 	ldw	r2,44(r2)
 82260bc:	10c00044 	addi	r3,r2,1
 82260c0:	e0bffe17 	ldw	r2,-8(fp)
 82260c4:	10c00b15 	stw	r3,44(r2)
 82260c8:	00000506 	br	82260e0 <pktdemux+0xd0>
      else
         mib->ifInUcastPkts++;
 82260cc:	e0bffe17 	ldw	r2,-8(fp)
 82260d0:	10800a17 	ldw	r2,40(r2)
 82260d4:	10c00044 	addi	r3,r2,1
 82260d8:	e0bffe17 	ldw	r2,-8(fp)
 82260dc:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 82260e0:	e0bffe17 	ldw	r2,-8(fp)
 82260e4:	10800617 	ldw	r2,24(r2)
 82260e8:	10800098 	cmpnei	r2,r2,2
 82260ec:	10000c1e 	bne	r2,zero,8226120 <pktdemux+0x110>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82260f0:	01000084 	movi	r4,2
 82260f4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 82260f8:	e13ffc17 	ldw	r4,-16(fp)
 82260fc:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226100:	01000084 	movi	r4,2
 8226104:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 8226108:	e0bffe17 	ldw	r2,-8(fp)
 822610c:	10800c17 	ldw	r2,48(r2)
 8226110:	10c00044 	addi	r3,r2,1
 8226114:	e0bffe17 	ldw	r2,-8(fp)
 8226118:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 822611c:	00009b06 	br	822638c <pktdemux+0x37c>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 8226120:	e0bffc17 	ldw	r2,-16(fp)
 8226124:	10800117 	ldw	r2,4(r2)
 8226128:	10bfff04 	addi	r2,r2,-4
 822612c:	10800003 	ldbu	r2,0(r2)
 8226130:	10803fcc 	andi	r2,r2,255
 8226134:	1080201c 	xori	r2,r2,128
 8226138:	10bfe004 	addi	r2,r2,-128
 822613c:	10801358 	cmpnei	r2,r2,77
 8226140:	10000b1e 	bne	r2,zero,8226170 <pktdemux+0x160>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
 8226144:	e0bffc17 	ldw	r2,-16(fp)
 8226148:	10c00117 	ldw	r3,4(r2)
 822614c:	e0bffc17 	ldw	r2,-16(fp)
 8226150:	10800217 	ldw	r2,8(r2)
 8226154:	1885883a 	add	r2,r3,r2
 8226158:	10800003 	ldbu	r2,0(r2)
         mib->ifInDiscards++;
         continue;      /* next packet */
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 822615c:	10803fcc 	andi	r2,r2,255
 8226160:	1080201c 	xori	r2,r2,128
 8226164:	10bfe004 	addi	r2,r2,-128
 8226168:	10801360 	cmpeqi	r2,r2,77
 822616c:	1000041e 	bne	r2,zero,8226180 <pktdemux+0x170>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 8226170:	822d2e00 	call	822d2e0 <dtrap>
         panic("pktdemux: corrupt pkt");
 8226174:	01020974 	movhi	r4,2085
 8226178:	213eef04 	addi	r4,r4,-1092
 822617c:	82289940 	call	8228994 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 8226180:	e0bffd17 	ldw	r2,-12(fp)
 8226184:	10802a17 	ldw	r2,168(r2)
 8226188:	1080020c 	andi	r2,r2,8
 822618c:	1000491e 	bne	r2,zero,82262b4 <pktdemux+0x2a4>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 8226190:	e0bffd17 	ldw	r2,-12(fp)
 8226194:	10802717 	ldw	r2,156(r2)
 8226198:	10800217 	ldw	r2,8(r2)
 822619c:	108001a0 	cmpeqi	r2,r2,6
 82261a0:	10003626 	beq	r2,zero,822627c <pktdemux+0x26c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 82261a4:	e0bffc17 	ldw	r2,-16(fp)
 82261a8:	10800117 	ldw	r2,4(r2)
 82261ac:	10800084 	addi	r2,r2,2
 82261b0:	e0bfff15 	stw	r2,-4(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 82261b4:	e0bfff17 	ldw	r2,-4(fp)
 82261b8:	10800304 	addi	r2,r2,12
 82261bc:	10800003 	ldbu	r2,0(r2)
 82261c0:	10803fcc 	andi	r2,r2,255
 82261c4:	1080201c 	xori	r2,r2,128
 82261c8:	10bfe004 	addi	r2,r2,-128
 82261cc:	1004923a 	slli	r2,r2,8
 82261d0:	1007883a 	mov	r3,r2
 82261d4:	e0bfff17 	ldw	r2,-4(fp)
 82261d8:	10800344 	addi	r2,r2,13
 82261dc:	10800003 	ldbu	r2,0(r2)
 82261e0:	10803fcc 	andi	r2,r2,255
 82261e4:	1080201c 	xori	r2,r2,128
 82261e8:	10bfe004 	addi	r2,r2,-128
 82261ec:	10803fcc 	andi	r2,r2,255
 82261f0:	1885883a 	add	r2,r3,r2
 82261f4:	10bfffcc 	andi	r2,r2,65535
 82261f8:	1004d23a 	srli	r2,r2,8
 82261fc:	1007883a 	mov	r3,r2
 8226200:	e0bfff17 	ldw	r2,-4(fp)
 8226204:	10800304 	addi	r2,r2,12
 8226208:	10800003 	ldbu	r2,0(r2)
 822620c:	10803fcc 	andi	r2,r2,255
 8226210:	1080201c 	xori	r2,r2,128
 8226214:	10bfe004 	addi	r2,r2,-128
 8226218:	1004923a 	slli	r2,r2,8
 822621c:	1009883a 	mov	r4,r2
 8226220:	e0bfff17 	ldw	r2,-4(fp)
 8226224:	10800344 	addi	r2,r2,13
 8226228:	10800003 	ldbu	r2,0(r2)
 822622c:	10803fcc 	andi	r2,r2,255
 8226230:	1080201c 	xori	r2,r2,128
 8226234:	10bfe004 	addi	r2,r2,-128
 8226238:	10803fcc 	andi	r2,r2,255
 822623c:	2085883a 	add	r2,r4,r2
 8226240:	10bfffcc 	andi	r2,r2,65535
 8226244:	1004923a 	slli	r2,r2,8
 8226248:	1884b03a 	or	r2,r3,r2
 822624c:	1007883a 	mov	r3,r2
 8226250:	e0bffc17 	ldw	r2,-16(fp)
 8226254:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 8226258:	e0bffc17 	ldw	r2,-16(fp)
 822625c:	10800117 	ldw	r2,4(r2)
 8226260:	e0fffc17 	ldw	r3,-16(fp)
 8226264:	18c00617 	ldw	r3,24(r3)
 8226268:	18c00817 	ldw	r3,32(r3)
 822626c:	10c7883a 	add	r3,r2,r3
 8226270:	e0bffc17 	ldw	r2,-16(fp)
 8226274:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 8226278:	00000e06 	br	82262b4 <pktdemux+0x2a4>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 822627c:	e0bffd17 	ldw	r2,-12(fp)
 8226280:	10802717 	ldw	r2,156(r2)
 8226284:	10800217 	ldw	r2,8(r2)
 8226288:	100b883a 	mov	r5,r2
 822628c:	01020974 	movhi	r4,2085
 8226290:	213ef504 	addi	r4,r4,-1068
 8226294:	82030ec0 	call	82030ec <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8226298:	01000084 	movi	r4,2
 822629c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(pkt);
 82262a0:	e13ffc17 	ldw	r4,-16(fp)
 82262a4:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82262a8:	01000084 	movi	r4,2
 82262ac:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            continue;
 82262b0:	00003606 	br	822638c <pktdemux+0x37c>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 82262b4:	e0bffc17 	ldw	r2,-16(fp)
 82262b8:	1080080b 	ldhu	r2,32(r2)
 82262bc:	10bfffcc 	andi	r2,r2,65535
 82262c0:	10c00220 	cmpeqi	r3,r2,8
 82262c4:	1800031e 	bne	r3,zero,82262d4 <pktdemux+0x2c4>
 82262c8:	10818220 	cmpeqi	r2,r2,1544
 82262cc:	1000081e 	bne	r2,zero,82262f0 <pktdemux+0x2e0>
 82262d0:	00000e06 	br	822630c <pktdemux+0x2fc>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82262d4:	0009883a 	mov	r4,zero
 82262d8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 82262dc:	e13ffc17 	ldw	r4,-16(fp)
 82262e0:	824297c0 	call	824297c <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 82262e4:	0009883a 	mov	r4,zero
 82262e8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         break;
 82262ec:	00002606 	br	8226388 <pktdemux+0x378>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82262f0:	0009883a 	mov	r4,zero
 82262f4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         arprcv(pkt);
 82262f8:	e13ffc17 	ldw	r4,-16(fp)
 82262fc:	823e2ec0 	call	823e2ec <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8226300:	0009883a 	mov	r4,zero
 8226304:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         break;
 8226308:	00001f06 	br	8226388 <pktdemux+0x378>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 822630c:	d0a08317 	ldw	r2,-32244(gp)
 8226310:	1081000c 	andi	r2,r2,1024
 8226314:	10001026 	beq	r2,zero,8226358 <pktdemux+0x348>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 8226318:	e0bffc17 	ldw	r2,-16(fp)
 822631c:	1080080b 	ldhu	r2,32(r2)
 8226320:	10bfffcc 	andi	r2,r2,65535
 8226324:	1004d23a 	srli	r2,r2,8
 8226328:	10bfffcc 	andi	r2,r2,65535
 822632c:	10c03fcc 	andi	r3,r2,255
 8226330:	e0bffc17 	ldw	r2,-16(fp)
 8226334:	1080080b 	ldhu	r2,32(r2)
 8226338:	10bfffcc 	andi	r2,r2,65535
 822633c:	1004923a 	slli	r2,r2,8
 8226340:	10bfffcc 	andi	r2,r2,65535
 8226344:	1884b03a 	or	r2,r3,r2
 8226348:	100b883a 	mov	r5,r2
 822634c:	01020974 	movhi	r4,2085
 8226350:	213efd04 	addi	r4,r4,-1036
 8226354:	82030ec0 	call	82030ec <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 8226358:	e0bffd17 	ldw	r2,-12(fp)
 822635c:	10802717 	ldw	r2,156(r2)
 8226360:	10c00e17 	ldw	r3,56(r2)
 8226364:	18c00044 	addi	r3,r3,1
 8226368:	10c00e15 	stw	r3,56(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822636c:	01000084 	movi	r4,2
 8226370:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 8226374:	e13ffc17 	ldw	r4,-16(fp)
 8226378:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822637c:	01000084 	movi	r4,2
 8226380:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         break;
 8226384:	0001883a 	nop
      }
      continue;
 8226388:	0001883a 	nop
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 822638c:	008209b4 	movhi	r2,2086
 8226390:	10b67504 	addi	r2,r2,-9772
 8226394:	10800217 	ldw	r2,8(r2)
 8226398:	103f231e 	bne	r2,zero,8226028 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 822639c:	0001883a 	nop
 82263a0:	e037883a 	mov	sp,fp
 82263a4:	dfc00117 	ldw	ra,4(sp)
 82263a8:	df000017 	ldw	fp,0(sp)
 82263ac:	dec00204 	addi	sp,sp,8
 82263b0:	f800283a 	ret

082263b4 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 82263b4:	defffd04 	addi	sp,sp,-12
 82263b8:	df000215 	stw	fp,8(sp)
 82263bc:	df000204 	addi	fp,sp,8
 82263c0:	e13ffe15 	stw	r4,-8(fp)
 82263c4:	e17fff15 	stw	r5,-4(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82263c8:	d0a0a817 	ldw	r2,-32096(gp)
 82263cc:	10000c0e 	bge	r2,zero,8226400 <c_older+0x4c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82263d0:	d0e0a817 	ldw	r3,-32096(gp)

u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82263d4:	e0bffe17 	ldw	r2,-8(fp)
 82263d8:	18800336 	bltu	r3,r2,82263e8 <c_older+0x34>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82263dc:	d0e0a817 	ldw	r3,-32096(gp)
 82263e0:	e0bfff17 	ldw	r2,-4(fp)
 82263e4:	1880062e 	bgeu	r3,r2,8226400 <c_older+0x4c>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82263e8:	d0a0a817 	ldw	r2,-32096(gp)
u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82263ec:	e0fffe17 	ldw	r3,-8(fp)
 82263f0:	18800a36 	bltu	r3,r2,822641c <c_older+0x68>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82263f4:	d0a0a817 	ldw	r2,-32096(gp)
 82263f8:	e0ffff17 	ldw	r3,-4(fp)
 82263fc:	18800736 	bltu	r3,r2,822641c <c_older+0x68>
   {
      if (ct1 < ct2)
 8226400:	e0fffe17 	ldw	r3,-8(fp)
 8226404:	e0bfff17 	ldw	r2,-4(fp)
 8226408:	1880022e 	bgeu	r3,r2,8226414 <c_older+0x60>
         return(ct1);      /* then smaller is oldest */
 822640c:	e0bffe17 	ldw	r2,-8(fp)
 8226410:	00000806 	br	8226434 <c_older+0x80>
      else 
         return(ct2);
 8226414:	e0bfff17 	ldw	r2,-4(fp)
 8226418:	00000606 	br	8226434 <c_older+0x80>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 822641c:	e0fffe17 	ldw	r3,-8(fp)
 8226420:	e0bfff17 	ldw	r2,-4(fp)
 8226424:	18800236 	bltu	r3,r2,8226430 <c_older+0x7c>
      return(ct1);
 8226428:	e0bffe17 	ldw	r2,-8(fp)
 822642c:	00000106 	br	8226434 <c_older+0x80>
   else
      return(ct2);
 8226430:	e0bfff17 	ldw	r2,-4(fp)
}
 8226434:	e037883a 	mov	sp,fp
 8226438:	df000017 	ldw	fp,0(sp)
 822643c:	dec00104 	addi	sp,sp,4
 8226440:	f800283a 	ret

08226444 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 8226444:	defffb04 	addi	sp,sp,-20
 8226448:	dfc00415 	stw	ra,16(sp)
 822644c:	df000315 	stw	fp,12(sp)
 8226450:	df000304 	addi	fp,sp,12
 8226454:	e13ffe15 	stw	r4,-8(fp)
 8226458:	e17fff15 	stw	r5,-4(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 822645c:	e0bffe17 	ldw	r2,-8(fp)
 8226460:	10800617 	ldw	r2,24(r2)
 8226464:	10802717 	ldw	r2,156(r2)
 8226468:	e0bffd15 	stw	r2,-12(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 822646c:	e0bffd17 	ldw	r2,-12(fp)
 8226470:	10800617 	ldw	r2,24(r2)
 8226474:	10800098 	cmpnei	r2,r2,2
 8226478:	1000081e 	bne	r2,zero,822649c <ip2mac+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822647c:	01000084 	movi	r4,2
 8226480:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 8226484:	e13ffe17 	ldw	r4,-8(fp)
 8226488:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822648c:	01000084 	movi	r4,2
 8226490:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 8226494:	00bff7c4 	movi	r2,-33
 8226498:	00004806 	br	82265bc <ip2mac+0x178>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 822649c:	e0bffe17 	ldw	r2,-8(fp)
 82264a0:	10800617 	ldw	r2,24(r2)
 82264a4:	10800817 	ldw	r2,32(r2)
 82264a8:	10000826 	beq	r2,zero,82264cc <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 82264ac:	e0bffd17 	ldw	r2,-12(fp)
 82264b0:	10800217 	ldw	r2,8(r2)
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 82264b4:	108005e0 	cmpeqi	r2,r2,23
 82264b8:	1000041e 	bne	r2,zero,82264cc <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
 82264bc:	e0bffd17 	ldw	r2,-12(fp)
 82264c0:	10800217 	ldw	r2,8(r2)
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 82264c4:	10800718 	cmpnei	r2,r2,28
 82264c8:	1000291e 	bne	r2,zero,8226570 <ip2mac+0x12c>
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 82264cc:	e0bffd17 	ldw	r2,-12(fp)
 82264d0:	10801017 	ldw	r2,64(r2)
 82264d4:	10c00044 	addi	r3,r2,1
 82264d8:	e0bffd17 	ldw	r2,-12(fp)
 82264dc:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 82264e0:	e0bffd17 	ldw	r2,-12(fp)
 82264e4:	10c00f17 	ldw	r3,60(r2)
 82264e8:	e0bffe17 	ldw	r2,-8(fp)
 82264ec:	10800417 	ldw	r2,16(r2)
 82264f0:	1887883a 	add	r3,r3,r2
 82264f4:	e0bffd17 	ldw	r2,-12(fp)
 82264f8:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 82264fc:	e0bffe17 	ldw	r2,-8(fp)
 8226500:	10800617 	ldw	r2,24(r2)
 8226504:	10800417 	ldw	r2,16(r2)
 8226508:	10000626 	beq	r2,zero,8226524 <ip2mac+0xe0>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 822650c:	e0bffe17 	ldw	r2,-8(fp)
 8226510:	10800617 	ldw	r2,24(r2)
 8226514:	10800417 	ldw	r2,16(r2)
 8226518:	e13ffe17 	ldw	r4,-8(fp)
 822651c:	103ee83a 	callr	r2
 8226520:	00001106 	br	8226568 <ip2mac+0x124>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 8226524:	e0bffe17 	ldw	r2,-8(fp)
 8226528:	10800617 	ldw	r2,24(r2)
 822652c:	10800317 	ldw	r2,12(r2)
 8226530:	e0fffe17 	ldw	r3,-8(fp)
 8226534:	19000617 	ldw	r4,24(r3)
 8226538:	e0fffe17 	ldw	r3,-8(fp)
 822653c:	19400317 	ldw	r5,12(r3)
 8226540:	e0fffe17 	ldw	r3,-8(fp)
 8226544:	18c00417 	ldw	r3,16(r3)
 8226548:	180d883a 	mov	r6,r3
 822654c:	103ee83a 	callr	r2
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226550:	01000084 	movi	r4,2
 8226554:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226558:	e13ffe17 	ldw	r4,-8(fp)
 822655c:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226560:	01000084 	movi	r4,2
 8226564:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 8226568:	0005883a 	mov	r2,zero
 822656c:	00001306 	br	82265bc <ip2mac+0x178>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 8226570:	e0bffe17 	ldw	r2,-8(fp)
 8226574:	10800617 	ldw	r2,24(r2)
 8226578:	10800a17 	ldw	r2,40(r2)
 822657c:	10000c1e 	bne	r2,zero,82265b0 <ip2mac+0x16c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 8226580:	e0bffe17 	ldw	r2,-8(fp)
 8226584:	10800717 	ldw	r2,28(r2)
 8226588:	10bfffe0 	cmpeqi	r2,r2,-1
 822658c:	1000081e 	bne	r2,zero,82265b0 <ip2mac+0x16c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226590:	01000084 	movi	r4,2
 8226594:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226598:	e13ffe17 	ldw	r4,-8(fp)
 822659c:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82265a0:	01000084 	movi	r4,2
 82265a4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 82265a8:	00bff884 	movi	r2,-30
 82265ac:	00000306 	br	82265bc <ip2mac+0x178>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 82265b0:	e17fff17 	ldw	r5,-4(fp)
 82265b4:	e13ffe17 	ldw	r4,-8(fp)
 82265b8:	823e5500 	call	823e550 <send_via_arp>
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 82265bc:	e037883a 	mov	sp,fp
 82265c0:	dfc00117 	ldw	ra,4(sp)
 82265c4:	df000017 	ldw	fp,0(sp)
 82265c8:	dec00204 	addi	sp,sp,8
 82265cc:	f800283a 	ret

082265d0 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 82265d0:	defffc04 	addi	sp,sp,-16
 82265d4:	dfc00315 	stw	ra,12(sp)
 82265d8:	df000215 	stw	fp,8(sp)
 82265dc:	df000204 	addi	fp,sp,8
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 82265e0:	e03ffe15 	stw	zero,-8(fp)
 82265e4:	00002a06 	br	8226690 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 82265e8:	e0bffe17 	ldw	r2,-8(fp)
 82265ec:	10c03024 	muli	r3,r2,192
 82265f0:	008209b4 	movhi	r2,2086
 82265f4:	10b67a04 	addi	r2,r2,-9752
 82265f8:	1889883a 	add	r4,r3,r2
 82265fc:	008209b4 	movhi	r2,2086
 8226600:	10b73a04 	addi	r2,r2,-8984
 8226604:	e0fffe17 	ldw	r3,-8(fp)
 8226608:	18c7883a 	add	r3,r3,r3
 822660c:	18c7883a 	add	r3,r3,r3
 8226610:	10c5883a 	add	r2,r2,r3
 8226614:	11000015 	stw	r4,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 8226618:	008209b4 	movhi	r2,2086
 822661c:	10b73a04 	addi	r2,r2,-8984
 8226620:	e0fffe17 	ldw	r3,-8(fp)
 8226624:	18c7883a 	add	r3,r3,r3
 8226628:	18c7883a 	add	r3,r3,r3
 822662c:	10c5883a 	add	r2,r2,r3
 8226630:	11000017 	ldw	r4,0(r2)
 8226634:	008209b4 	movhi	r2,2086
 8226638:	10b73a04 	addi	r2,r2,-8984
 822663c:	e0fffe17 	ldw	r3,-8(fp)
 8226640:	18c7883a 	add	r3,r3,r3
 8226644:	18c7883a 	add	r3,r3,r3
 8226648:	10c5883a 	add	r2,r2,r3
 822664c:	10800017 	ldw	r2,0(r2)
 8226650:	10801204 	addi	r2,r2,72
 8226654:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 8226658:	008209b4 	movhi	r2,2086
 822665c:	10b73a04 	addi	r2,r2,-8984
 8226660:	e0fffe17 	ldw	r3,-8(fp)
 8226664:	18c7883a 	add	r3,r3,r3
 8226668:	18c7883a 	add	r3,r3,r3
 822666c:	10c5883a 	add	r2,r2,r3
 8226670:	10800017 	ldw	r2,0(r2)
 8226674:	100b883a 	mov	r5,r2
 8226678:	010209b4 	movhi	r4,2086
 822667c:	21397b04 	addi	r4,r4,-6676
 8226680:	822ccc80 	call	822ccc8 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 8226684:	e0bffe17 	ldw	r2,-8(fp)
 8226688:	10800044 	addi	r2,r2,1
 822668c:	e0bffe15 	stw	r2,-8(fp)
 8226690:	e0bffe17 	ldw	r2,-8(fp)
 8226694:	10800110 	cmplti	r2,r2,4
 8226698:	103fd31e 	bne	r2,zero,82265e8 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 822669c:	d0a08417 	ldw	r2,-32240(gp)
 82266a0:	1009883a 	mov	r4,r2
 82266a4:	82439580 	call	8243958 <prep_ifaces>
 82266a8:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 82266ac:	d0a08417 	ldw	r2,-32240(gp)
 82266b0:	1000031e 	bne	r2,zero,82266c0 <ip_startup+0xf0>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 82266b4:	00820974 	movhi	r2,2085
 82266b8:	10bf0e04 	addi	r2,r2,-968
 82266bc:	00006806 	br	8226860 <ip_startup+0x290>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 82266c0:	d0a08417 	ldw	r2,-32240(gp)
 82266c4:	e0bffe15 	stw	r2,-8(fp)
 82266c8:	00001506 	br	8226720 <ip_startup+0x150>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 82266cc:	008209b4 	movhi	r2,2086
 82266d0:	10b73a04 	addi	r2,r2,-8984
 82266d4:	e0fffe17 	ldw	r3,-8(fp)
 82266d8:	18c7883a 	add	r3,r3,r3
 82266dc:	18c7883a 	add	r3,r3,r3
 82266e0:	10c5883a 	add	r2,r2,r3
 82266e4:	10800017 	ldw	r2,0(r2)
 82266e8:	100b883a 	mov	r5,r2
 82266ec:	010209b4 	movhi	r4,2086
 82266f0:	21397b04 	addi	r4,r4,-6676
 82266f4:	822cd780 	call	822cd78 <qdel>
      nets[i] = NULL;               /* remove from array */
 82266f8:	008209b4 	movhi	r2,2086
 82266fc:	10b73a04 	addi	r2,r2,-8984
 8226700:	e0fffe17 	ldw	r3,-8(fp)
 8226704:	18c7883a 	add	r3,r3,r3
 8226708:	18c7883a 	add	r3,r3,r3
 822670c:	10c5883a 	add	r2,r2,r3
 8226710:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 8226714:	e0bffe17 	ldw	r2,-8(fp)
 8226718:	10800044 	addi	r2,r2,1
 822671c:	e0bffe15 	stw	r2,-8(fp)
 8226720:	e0bffe17 	ldw	r2,-8(fp)
 8226724:	10800110 	cmplti	r2,r2,4
 8226728:	103fe81e 	bne	r2,zero,82266cc <ip_startup+0xfc>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 822672c:	822d4040 	call	822d404 <clock_init>
   exit_hook(clock_c);
 8226730:	010208f4 	movhi	r4,2083
 8226734:	21350f04 	addi	r4,r4,-11204
 8226738:	82268740 	call	8226874 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 822673c:	82257ec0 	call	82257ec <Netinit>
 8226740:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226744:	e0bfff17 	ldw	r2,-4(fp)
 8226748:	10000326 	beq	r2,zero,8226758 <ip_startup+0x188>
   {
      return("unable to initialize net");
 822674c:	00820974 	movhi	r2,2085
 8226750:	10bf1804 	addi	r2,r2,-928
 8226754:	00004206 	br	8226860 <ip_startup+0x290>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 8226758:	823d6ac0 	call	823d6ac <etainit>
 822675c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226760:	e0bfff17 	ldw	r2,-4(fp)
 8226764:	10000426 	beq	r2,zero,8226778 <ip_startup+0x1a8>
   {
      ip_exit();
 8226768:	82268e40 	call	82268e4 <ip_exit>
      return("unable to initialize arp");
 822676c:	00820974 	movhi	r2,2085
 8226770:	10bf1f04 	addi	r2,r2,-900
 8226774:	00003a06 	br	8226860 <ip_startup+0x290>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 8226778:	823ecfc0 	call	823ecfc <ip_init>
 822677c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226780:	e0bfff17 	ldw	r2,-4(fp)
 8226784:	10000426 	beq	r2,zero,8226798 <ip_startup+0x1c8>
   {
      ip_exit();
 8226788:	82268e40 	call	82268e4 <ip_exit>
      return("unable to initialize IP");
 822678c:	00820974 	movhi	r2,2085
 8226790:	10bf2604 	addi	r2,r2,-872
 8226794:	00003206 	br	8226860 <ip_startup+0x290>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 8226798:	8226a380 	call	8226a38 <igmp_init>
 822679c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 82267a0:	e0bfff17 	ldw	r2,-4(fp)
 82267a4:	10000326 	beq	r2,zero,82267b4 <ip_startup+0x1e4>
   {
      ip_exit();
 82267a8:	82268e40 	call	82268e4 <ip_exit>
      return(ipmcfail_str);
 82267ac:	d0a03017 	ldw	r2,-32576(gp)
 82267b0:	00002b06 	br	8226860 <ip_startup+0x290>
   }

   for (i = 0; i < (int)ifNumber; i++)
 82267b4:	e03ffe15 	stw	zero,-8(fp)
 82267b8:	00001b06 	br	8226828 <ip_startup+0x258>
   {
      if (nets[i]->n_mcastlist != NULL)
 82267bc:	008209b4 	movhi	r2,2086
 82267c0:	10b73a04 	addi	r2,r2,-8984
 82267c4:	e0fffe17 	ldw	r3,-8(fp)
 82267c8:	18c7883a 	add	r3,r3,r3
 82267cc:	18c7883a 	add	r3,r3,r3
 82267d0:	10c5883a 	add	r2,r2,r3
 82267d4:	10800017 	ldw	r2,0(r2)
 82267d8:	10802b17 	ldw	r2,172(r2)
 82267dc:	10000f26 	beq	r2,zero,822681c <ip_startup+0x24c>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 82267e0:	008209b4 	movhi	r2,2086
 82267e4:	10b73a04 	addi	r2,r2,-8984
 82267e8:	e0fffe17 	ldw	r3,-8(fp)
 82267ec:	18c7883a 	add	r3,r3,r3
 82267f0:	18c7883a 	add	r3,r3,r3
 82267f4:	10c5883a 	add	r2,r2,r3
 82267f8:	10800017 	ldw	r2,0(r2)
 82267fc:	01800104 	movi	r6,4
 8226800:	100b883a 	mov	r5,r2
 8226804:	d1208804 	addi	r4,gp,-32224
 8226808:	824369c0 	call	824369c <in_addmulti>
 822680c:	1000031e 	bne	r2,zero,822681c <ip_startup+0x24c>
      {
         ip_exit();
 8226810:	82268e40 	call	82268e4 <ip_exit>
         return(ipmcfail_str);
 8226814:	d0a03017 	ldw	r2,-32576(gp)
 8226818:	00001106 	br	8226860 <ip_startup+0x290>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 822681c:	e0bffe17 	ldw	r2,-8(fp)
 8226820:	10800044 	addi	r2,r2,1
 8226824:	e0bffe15 	stw	r2,-8(fp)
 8226828:	d0a08417 	ldw	r2,-32240(gp)
 822682c:	1007883a 	mov	r3,r2
 8226830:	e0bffe17 	ldw	r2,-8(fp)
 8226834:	10ffe116 	blt	r2,r3,82267bc <ip_startup+0x1ec>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 8226838:	823ac2c0 	call	823ac2c <tcpinit>
 822683c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226840:	e0bfff17 	ldw	r2,-4(fp)
 8226844:	10000426 	beq	r2,zero,8226858 <ip_startup+0x288>
   {
      ip_exit();
 8226848:	82268e40 	call	82268e4 <ip_exit>
      return("unable to initialize TCP");
 822684c:	00820974 	movhi	r2,2085
 8226850:	10bf2c04 	addi	r2,r2,-848
 8226854:	00000206 	br	8226860 <ip_startup+0x290>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 8226858:	8243a000 	call	8243a00 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 822685c:	0005883a 	mov	r2,zero
}
 8226860:	e037883a 	mov	sp,fp
 8226864:	dfc00117 	ldw	ra,4(sp)
 8226868:	df000017 	ldw	fp,0(sp)
 822686c:	dec00204 	addi	sp,sp,8
 8226870:	f800283a 	ret

08226874 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 8226874:	defffd04 	addi	sp,sp,-12
 8226878:	dfc00215 	stw	ra,8(sp)
 822687c:	df000115 	stw	fp,4(sp)
 8226880:	df000104 	addi	fp,sp,4
 8226884:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 8226888:	d0a08517 	ldw	r2,-32236(gp)
 822688c:	10800390 	cmplti	r2,r2,14
 8226890:	1000031e 	bne	r2,zero,82268a0 <exit_hook+0x2c>
      panic("exit_hook");
 8226894:	01020974 	movhi	r4,2085
 8226898:	213f3304 	addi	r4,r4,-820
 822689c:	82289940 	call	8228994 <panic>

   closers[++nclosers] = func;
 82268a0:	d0a08517 	ldw	r2,-32236(gp)
 82268a4:	10800044 	addi	r2,r2,1
 82268a8:	d0a08515 	stw	r2,-32236(gp)
 82268ac:	d0e08517 	ldw	r3,-32236(gp)
 82268b0:	00820974 	movhi	r2,2085
 82268b4:	10911904 	addi	r2,r2,17508
 82268b8:	18c7883a 	add	r3,r3,r3
 82268bc:	18c7883a 	add	r3,r3,r3
 82268c0:	10c5883a 	add	r2,r2,r3
 82268c4:	e0ffff17 	ldw	r3,-4(fp)
 82268c8:	10c00015 	stw	r3,0(r2)
}
 82268cc:	0001883a 	nop
 82268d0:	e037883a 	mov	sp,fp
 82268d4:	dfc00117 	ldw	ra,4(sp)
 82268d8:	df000017 	ldw	fp,0(sp)
 82268dc:	dec00204 	addi	sp,sp,8
 82268e0:	f800283a 	ret

082268e4 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 82268e4:	defffd04 	addi	sp,sp,-12
 82268e8:	dfc00215 	stw	ra,8(sp)
 82268ec:	df000115 	stw	fp,4(sp)
 82268f0:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 82268f4:	d0a08517 	ldw	r2,-32236(gp)
 82268f8:	e0bfff15 	stw	r2,-4(fp)
 82268fc:	00002506 	br	8226994 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 8226900:	00820974 	movhi	r2,2085
 8226904:	10911904 	addi	r2,r2,17508
 8226908:	e0ffff17 	ldw	r3,-4(fp)
 822690c:	18c7883a 	add	r3,r3,r3
 8226910:	18c7883a 	add	r3,r3,r3
 8226914:	10c5883a 	add	r2,r2,r3
 8226918:	10800017 	ldw	r2,0(r2)
 822691c:	100b883a 	mov	r5,r2
 8226920:	01020974 	movhi	r4,2085
 8226924:	213f3604 	addi	r4,r4,-808
 8226928:	82030ec0 	call	82030ec <printf>
#endif
      if(closers[n])
 822692c:	00820974 	movhi	r2,2085
 8226930:	10911904 	addi	r2,r2,17508
 8226934:	e0ffff17 	ldw	r3,-4(fp)
 8226938:	18c7883a 	add	r3,r3,r3
 822693c:	18c7883a 	add	r3,r3,r3
 8226940:	10c5883a 	add	r2,r2,r3
 8226944:	10800017 	ldw	r2,0(r2)
 8226948:	10000f26 	beq	r2,zero,8226988 <ip_exit+0xa4>
      {
         (*closers[n])();
 822694c:	00820974 	movhi	r2,2085
 8226950:	10911904 	addi	r2,r2,17508
 8226954:	e0ffff17 	ldw	r3,-4(fp)
 8226958:	18c7883a 	add	r3,r3,r3
 822695c:	18c7883a 	add	r3,r3,r3
 8226960:	10c5883a 	add	r2,r2,r3
 8226964:	10800017 	ldw	r2,0(r2)
 8226968:	103ee83a 	callr	r2
         closers[n] = NULL;
 822696c:	00820974 	movhi	r2,2085
 8226970:	10911904 	addi	r2,r2,17508
 8226974:	e0ffff17 	ldw	r3,-4(fp)
 8226978:	18c7883a 	add	r3,r3,r3
 822697c:	18c7883a 	add	r3,r3,r3
 8226980:	10c5883a 	add	r2,r2,r3
 8226984:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 8226988:	e0bfff17 	ldw	r2,-4(fp)
 822698c:	10bfffc4 	addi	r2,r2,-1
 8226990:	e0bfff15 	stw	r2,-4(fp)
 8226994:	e0bfff17 	ldw	r2,-4(fp)
 8226998:	103fd91e 	bne	r2,zero,8226900 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 822699c:	0001883a 	nop
 82269a0:	e037883a 	mov	sp,fp
 82269a4:	dfc00117 	ldw	ra,4(sp)
 82269a8:	df000017 	ldw	fp,0(sp)
 82269ac:	dec00204 	addi	sp,sp,8
 82269b0:	f800283a 	ret

082269b4 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 82269b4:	defffb04 	addi	sp,sp,-20
 82269b8:	dfc00415 	stw	ra,16(sp)
 82269bc:	df000315 	stw	fp,12(sp)
 82269c0:	df000304 	addi	fp,sp,12
 82269c4:	e13fff15 	stw	r4,-4(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 82269c8:	008209b4 	movhi	r2,2086
 82269cc:	10b97b04 	addi	r2,r2,-6676
 82269d0:	10800017 	ldw	r2,0(r2)
 82269d4:	e0bffe15 	stw	r2,-8(fp)
 82269d8:	e03ffd15 	stw	zero,-12(fp)
 82269dc:	00000b06 	br	8226a0c <if_netnumber+0x58>
   {
      if(ifp == nptr)
 82269e0:	e0fffe17 	ldw	r3,-8(fp)
 82269e4:	e0bfff17 	ldw	r2,-4(fp)
 82269e8:	1880021e 	bne	r3,r2,82269f4 <if_netnumber+0x40>
        return (int)i;
 82269ec:	e0bffd17 	ldw	r2,-12(fp)
 82269f0:	00000c06 	br	8226a24 <if_netnumber+0x70>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 82269f4:	e0bffe17 	ldw	r2,-8(fp)
 82269f8:	10800017 	ldw	r2,0(r2)
 82269fc:	e0bffe15 	stw	r2,-8(fp)
 8226a00:	e0bffd17 	ldw	r2,-12(fp)
 8226a04:	10800044 	addi	r2,r2,1
 8226a08:	e0bffd15 	stw	r2,-12(fp)
 8226a0c:	e0bffe17 	ldw	r2,-8(fp)
 8226a10:	103ff31e 	bne	r2,zero,82269e0 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 8226a14:	01020974 	movhi	r4,2085
 8226a18:	213f3d04 	addi	r4,r4,-780
 8226a1c:	82289940 	call	8228994 <panic>
   return 0;
 8226a20:	0005883a 	mov	r2,zero
}
 8226a24:	e037883a 	mov	sp,fp
 8226a28:	dfc00117 	ldw	ra,4(sp)
 8226a2c:	df000017 	ldw	fp,0(sp)
 8226a30:	dec00204 	addi	sp,sp,8
 8226a34:	f800283a 	ret

08226a38 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 8226a38:	defffe04 	addi	sp,sp,-8
 8226a3c:	df000115 	stw	fp,4(sp)
 8226a40:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 8226a44:	00804034 	movhi	r2,256
 8226a48:	10803804 	addi	r2,r2,224
 8226a4c:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 8226a50:	00808034 	movhi	r2,512
 8226a54:	10803804 	addi	r2,r2,224
 8226a58:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226a5c:	008209b4 	movhi	r2,2086
 8226a60:	10b97b04 	addi	r2,r2,-6676
 8226a64:	10800017 	ldw	r2,0(r2)
 8226a68:	e0bfff15 	stw	r2,-4(fp)
 8226a6c:	00001006 	br	8226ab0 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 8226a70:	e0bfff17 	ldw	r2,-4(fp)
 8226a74:	10802f03 	ldbu	r2,188(r2)
 8226a78:	10803fcc 	andi	r2,r2,255
 8226a7c:	10800058 	cmpnei	r2,r2,1
 8226a80:	1000041e 	bne	r2,zero,8226a94 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 8226a84:	e0bfff17 	ldw	r2,-4(fp)
 8226a88:	00c00044 	movi	r3,1
 8226a8c:	10c02d05 	stb	r3,180(r2)
 8226a90:	00000406 	br	8226aa4 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 8226a94:	e0bfff17 	ldw	r2,-4(fp)
 8226a98:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 8226a9c:	e0bfff17 	ldw	r2,-4(fp)
 8226aa0:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226aa4:	e0bfff17 	ldw	r2,-4(fp)
 8226aa8:	10800017 	ldw	r2,0(r2)
 8226aac:	e0bfff15 	stw	r2,-4(fp)
 8226ab0:	e0bfff17 	ldw	r2,-4(fp)
 8226ab4:	103fee1e 	bne	r2,zero,8226a70 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226ab8:	d0a0a817 	ldw	r2,-32096(gp)
 8226abc:	10800504 	addi	r2,r2,20
 8226ac0:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 8226ac4:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 8226ac8:	0005883a 	mov	r2,zero
}
 8226acc:	e037883a 	mov	sp,fp
 8226ad0:	df000017 	ldw	fp,0(sp)
 8226ad4:	dec00104 	addi	sp,sp,4
 8226ad8:	f800283a 	ret

08226adc <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 8226adc:	defffb04 	addi	sp,sp,-20
 8226ae0:	dfc00415 	stw	ra,16(sp)
 8226ae4:	df000315 	stw	fp,12(sp)
 8226ae8:	df000304 	addi	fp,sp,12
 8226aec:	e13fff15 	stw	r4,-4(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 8226af0:	008209b4 	movhi	r2,2086
 8226af4:	10b73e04 	addi	r2,r2,-8968
 8226af8:	10800017 	ldw	r2,0(r2)
 8226afc:	10c00044 	addi	r3,r2,1
 8226b00:	008209b4 	movhi	r2,2086
 8226b04:	10b73e04 	addi	r2,r2,-8968
 8226b08:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226b0c:	e13fff17 	ldw	r4,-4(fp)
 8226b10:	82272a00 	call	82272a0 <igmp_validate>
 8226b14:	e0bffd15 	stw	r2,-12(fp)
 8226b18:	e0bffd17 	ldw	r2,-12(fp)
 8226b1c:	10001a1e 	bne	r2,zero,8226b88 <igmp_input+0xac>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 8226b20:	e0bfff17 	ldw	r2,-4(fp)
 8226b24:	10800617 	ldw	r2,24(r2)
 8226b28:	10802f03 	ldbu	r2,188(r2)
 8226b2c:	e0bffe05 	stb	r2,-8(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 8226b30:	e0bffe03 	ldbu	r2,-8(fp)
 8226b34:	10c00060 	cmpeqi	r3,r2,1
 8226b38:	1800031e 	bne	r3,zero,8226b48 <igmp_input+0x6c>
 8226b3c:	108000a0 	cmpeqi	r2,r2,2
 8226b40:	1000041e 	bne	r2,zero,8226b54 <igmp_input+0x78>
 8226b44:	00000606 	br	8226b60 <igmp_input+0x84>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 8226b48:	e13fff17 	ldw	r4,-4(fp)
 8226b4c:	82452580 	call	8245258 <igmpv1_input>
 8226b50:	00001506 	br	8226ba8 <igmp_input+0xcc>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 8226b54:	e13fff17 	ldw	r4,-4(fp)
 8226b58:	82454fc0 	call	82454fc <igmpv2_input>
 8226b5c:	00001206 	br	8226ba8 <igmp_input+0xcc>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 8226b60:	008209b4 	movhi	r2,2086
 8226b64:	10b73e04 	addi	r2,r2,-8968
 8226b68:	10800d17 	ldw	r2,52(r2)
 8226b6c:	10c00044 	addi	r3,r2,1
 8226b70:	008209b4 	movhi	r2,2086
 8226b74:	10b73e04 	addi	r2,r2,-8968
 8226b78:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 8226b7c:	00bfffc4 	movi	r2,-1
 8226b80:	e0bffd15 	stw	r2,-12(fp)
         break;
 8226b84:	00000106 	br	8226b8c <igmp_input+0xb0>
     
   ++igmpstats.igmp_total_rcvd;
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226b88:	0001883a 	nop
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8226b8c:	01000084 	movi	r4,2
 8226b90:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 8226b94:	e13fff17 	ldw	r4,-4(fp)
 8226b98:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226b9c:	01000084 	movi	r4,2
 8226ba0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      
   return rc;
 8226ba4:	e0bffd17 	ldw	r2,-12(fp)
}
 8226ba8:	e037883a 	mov	sp,fp
 8226bac:	dfc00117 	ldw	ra,4(sp)
 8226bb0:	df000017 	ldw	fp,0(sp)
 8226bb4:	dec00204 	addi	sp,sp,8
 8226bb8:	f800283a 	ret

08226bbc <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 8226bbc:	defffc04 	addi	sp,sp,-16
 8226bc0:	dfc00315 	stw	ra,12(sp)
 8226bc4:	df000215 	stw	fp,8(sp)
 8226bc8:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 8226bcc:	0009883a 	mov	r4,zero
 8226bd0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 8226bd4:	d0a08617 	ldw	r2,-32232(gp)
 8226bd8:	1000031e 	bne	r2,zero,8226be8 <igmp_fasttimo+0x2c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 8226bdc:	0009883a 	mov	r4,zero
 8226be0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return;
 8226be4:	00004d06 	br	8226d1c <igmp_fasttimo+0x160>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226be8:	008209b4 	movhi	r2,2086
 8226bec:	10b97b04 	addi	r2,r2,-6676
 8226bf0:	10800017 	ldw	r2,0(r2)
 8226bf4:	e0bfff15 	stw	r2,-4(fp)
 8226bf8:	00004006 	br	8226cfc <igmp_fasttimo+0x140>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226bfc:	e0bfff17 	ldw	r2,-4(fp)
 8226c00:	10802c17 	ldw	r2,176(r2)
 8226c04:	e0bffe15 	stw	r2,-8(fp)
 8226c08:	00003706 	br	8226ce8 <igmp_fasttimo+0x12c>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 8226c0c:	e0bffe17 	ldw	r2,-8(fp)
 8226c10:	10800017 	ldw	r2,0(r2)
 8226c14:	10003026 	beq	r2,zero,8226cd8 <igmp_fasttimo+0x11c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 8226c18:	e0bffe17 	ldw	r2,-8(fp)
 8226c1c:	10800317 	ldw	r2,12(r2)
 8226c20:	10002e26 	beq	r2,zero,8226cdc <igmp_fasttimo+0x120>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 8226c24:	e0bffe17 	ldw	r2,-8(fp)
 8226c28:	10800317 	ldw	r2,12(r2)
 8226c2c:	10ffffc4 	addi	r3,r2,-1
 8226c30:	e0bffe17 	ldw	r2,-8(fp)
 8226c34:	10c00315 	stw	r3,12(r2)
 8226c38:	e0bffe17 	ldw	r2,-8(fp)
 8226c3c:	10800317 	ldw	r2,12(r2)
 8226c40:	1000261e 	bne	r2,zero,8226cdc <igmp_fasttimo+0x120>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 8226c44:	e0bfff17 	ldw	r2,-4(fp)
 8226c48:	10802d03 	ldbu	r2,180(r2)
 8226c4c:	10803fcc 	andi	r2,r2,255
 8226c50:	10000426 	beq	r2,zero,8226c64 <igmp_fasttimo+0xa8>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8226c54:	e17ffe17 	ldw	r5,-8(fp)
 8226c58:	01000484 	movi	r4,18
 8226c5c:	8226d300 	call	8226d30 <igmp_send>
 8226c60:	00000306 	br	8226c70 <igmp_fasttimo+0xb4>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 8226c64:	e17ffe17 	ldw	r5,-8(fp)
 8226c68:	01000584 	movi	r4,22
 8226c6c:	8226d300 	call	8226d30 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8226c70:	e0bfff17 	ldw	r2,-4(fp)
 8226c74:	10802f03 	ldbu	r2,188(r2)
 8226c78:	10803fcc 	andi	r2,r2,255
 8226c7c:	10800098 	cmpnei	r2,r2,2
 8226c80:	1000111e 	bne	r2,zero,8226cc8 <igmp_fasttimo+0x10c>
            {
               inm->last2send_report = IGMP_TRUE;
 8226c84:	e0bffe17 	ldw	r2,-8(fp)
 8226c88:	00c00044 	movi	r3,1
 8226c8c:	10c00405 	stb	r3,16(r2)
               
               if (ifp->igmpv1_rtr_present)
 8226c90:	e0bfff17 	ldw	r2,-4(fp)
 8226c94:	10802d03 	ldbu	r2,180(r2)
 8226c98:	10803fcc 	andi	r2,r2,255
 8226c9c:	10000a26 	beq	r2,zero,8226cc8 <igmp_fasttimo+0x10c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 8226ca0:	e0bfff17 	ldw	r2,-4(fp)
 8226ca4:	10c02e17 	ldw	r3,184(r2)
 8226ca8:	00a71014 	movui	r2,40000
 8226cac:	1887883a 	add	r3,r3,r2
 8226cb0:	d0a0a817 	ldw	r2,-32096(gp)
 8226cb4:	1880042e 	bgeu	r3,r2,8226cc8 <igmp_fasttimo+0x10c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 8226cb8:	e0bfff17 	ldw	r2,-4(fp)
 8226cbc:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 8226cc0:	e0bfff17 	ldw	r2,-4(fp)
 8226cc4:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 8226cc8:	d0a08617 	ldw	r2,-32232(gp)
 8226ccc:	10bfffc4 	addi	r2,r2,-1
 8226cd0:	d0a08615 	stw	r2,-32232(gp)
 8226cd4:	00000106 	br	8226cdc <igmp_fasttimo+0x120>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
               continue;
 8226cd8:	0001883a 	nop
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226cdc:	e0bffe17 	ldw	r2,-8(fp)
 8226ce0:	10800517 	ldw	r2,20(r2)
 8226ce4:	e0bffe15 	stw	r2,-8(fp)
 8226ce8:	e0bffe17 	ldw	r2,-8(fp)
 8226cec:	103fc71e 	bne	r2,zero,8226c0c <igmp_fasttimo+0x50>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226cf0:	e0bfff17 	ldw	r2,-4(fp)
 8226cf4:	10800017 	ldw	r2,0(r2)
 8226cf8:	e0bfff15 	stw	r2,-4(fp)
 8226cfc:	e0bfff17 	ldw	r2,-4(fp)
 8226d00:	103fbe1e 	bne	r2,zero,8226bfc <igmp_fasttimo+0x40>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226d04:	d0a0a817 	ldw	r2,-32096(gp)
 8226d08:	10800504 	addi	r2,r2,20
 8226d0c:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8226d10:	0009883a 	mov	r4,zero
 8226d14:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   
   return;
 8226d18:	0001883a 	nop
}
 8226d1c:	e037883a 	mov	sp,fp
 8226d20:	dfc00117 	ldw	ra,4(sp)
 8226d24:	df000017 	ldw	fp,0(sp)
 8226d28:	dec00204 	addi	sp,sp,8
 8226d2c:	f800283a 	ret

08226d30 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 8226d30:	deffde04 	addi	sp,sp,-136
 8226d34:	dfc02115 	stw	ra,132(sp)
 8226d38:	df002015 	stw	fp,128(sp)
 8226d3c:	df002004 	addi	fp,sp,128
 8226d40:	2005883a 	mov	r2,r4
 8226d44:	e17fff15 	stw	r5,-4(fp)
 8226d48:	e0bffe05 	stb	r2,-8(fp)
   struct igmp * igmp;
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 8226d4c:	00800504 	movi	r2,20
 8226d50:	e0bffd05 	stb	r2,-12(fp)
 8226d54:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 8226d58:	d0a08117 	ldw	r2,-32252(gp)
 8226d5c:	10800704 	addi	r2,r2,28
 8226d60:	e0bfe205 	stb	r2,-120(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8226d64:	e0bffe03 	ldbu	r2,-8(fp)
 8226d68:	108005e0 	cmpeqi	r2,r2,23
 8226d6c:	1000031e 	bne	r2,zero,8226d7c <igmp_send+0x4c>
 8226d70:	e0bffe03 	ldbu	r2,-8(fp)
 8226d74:	10800598 	cmpnei	r2,r2,22
 8226d78:	1000031e 	bne	r2,zero,8226d88 <igmp_send+0x58>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 8226d7c:	e0bfe203 	ldbu	r2,-120(fp)
 8226d80:	10800104 	addi	r2,r2,4
 8226d84:	e0bfe205 	stb	r2,-120(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8226d88:	01000084 	movi	r4,2
 8226d8c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 8226d90:	e0bfe203 	ldbu	r2,-120(fp)
 8226d94:	1009883a 	mov	r4,r2
 8226d98:	822c7380 	call	822c738 <pk_alloc>
 8226d9c:	e0bfe315 	stw	r2,-116(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8226da0:	01000084 	movi	r4,2
 8226da4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 8226da8:	e0bfe317 	ldw	r2,-116(fp)
 8226dac:	1000081e 	bne	r2,zero,8226dd0 <igmp_send+0xa0>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 8226db0:	008209b4 	movhi	r2,2086
 8226db4:	10b73e04 	addi	r2,r2,-8968
 8226db8:	10800c17 	ldw	r2,48(r2)
 8226dbc:	10c00044 	addi	r3,r2,1
 8226dc0:	008209b4 	movhi	r2,2086
 8226dc4:	10b73e04 	addi	r2,r2,-8968
 8226dc8:	10c00c15 	stw	r3,48(r2)
 8226dcc:	00007a06 	br	8226fb8 <igmp_send+0x288>
      return;
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 8226dd0:	e0bfe317 	ldw	r2,-116(fp)
 8226dd4:	10800317 	ldw	r2,12(r2)
 8226dd8:	e0bfe415 	stw	r2,-112(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 8226ddc:	e0bfff17 	ldw	r2,-4(fp)
 8226de0:	10800117 	ldw	r2,4(r2)
 8226de4:	10c00a17 	ldw	r3,40(r2)
 8226de8:	e0bfe417 	ldw	r2,-112(fp)
 8226dec:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 8226df0:	e0bffe03 	ldbu	r2,-8(fp)
 8226df4:	108005d8 	cmpnei	r2,r2,23
 8226df8:	1000041e 	bne	r2,zero,8226e0c <igmp_send+0xdc>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 8226dfc:	d0e08917 	ldw	r3,-32220(gp)
 8226e00:	e0bfe417 	ldw	r2,-112(fp)
 8226e04:	10c00415 	stw	r3,16(r2)
 8226e08:	00000406 	br	8226e1c <igmp_send+0xec>
   }
   else
      pip->ip_dest = inm->inm_addr;
 8226e0c:	e0bfff17 	ldw	r2,-4(fp)
 8226e10:	10c00017 	ldw	r3,0(r2)
 8226e14:	e0bfe417 	ldw	r2,-112(fp)
 8226e18:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 8226e1c:	e0bfe417 	ldw	r2,-112(fp)
 8226e20:	10c00417 	ldw	r3,16(r2)
 8226e24:	e0bfe317 	ldw	r2,-116(fp)
 8226e28:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 8226e2c:	e0bfe317 	ldw	r2,-116(fp)
 8226e30:	10800317 	ldw	r2,12(r2)
 8226e34:	10800504 	addi	r2,r2,20
 8226e38:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8226e3c:	e0bffe03 	ldbu	r2,-8(fp)
 8226e40:	108005e0 	cmpeqi	r2,r2,23
 8226e44:	1000031e 	bne	r2,zero,8226e54 <igmp_send+0x124>
 8226e48:	e0bffe03 	ldbu	r2,-8(fp)
 8226e4c:	10800598 	cmpnei	r2,r2,22
 8226e50:	1000061e 	bne	r2,zero,8226e6c <igmp_send+0x13c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 8226e54:	e0bfe017 	ldw	r2,-128(fp)
 8226e58:	10800104 	addi	r2,r2,4
 8226e5c:	e0bfe015 	stw	r2,-128(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 8226e60:	e0bffd04 	addi	r2,fp,-12
 8226e64:	e0bfe115 	stw	r2,-124(fp)
 8226e68:	00000306 	br	8226e78 <igmp_send+0x148>
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 8226e6c:	e0bffd04 	addi	r2,fp,-12
 8226e70:	10800044 	addi	r2,r2,1
 8226e74:	e0bfe115 	stw	r2,-124(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 8226e78:	e0bfe017 	ldw	r2,-128(fp)
 8226e7c:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 8226e80:	e0bfe517 	ldw	r2,-108(fp)
 8226e84:	e0fffe03 	ldbu	r3,-8(fp)
 8226e88:	10c00005 	stb	r3,0(r2)
   igmp->igmp_code = 0;
 8226e8c:	e0bfe517 	ldw	r2,-108(fp)
 8226e90:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 8226e94:	e0bfff17 	ldw	r2,-4(fp)
 8226e98:	10c00017 	ldw	r3,0(r2)
 8226e9c:	e0bfe517 	ldw	r2,-108(fp)
 8226ea0:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 8226ea4:	e0bfe517 	ldw	r2,-108(fp)
 8226ea8:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 8226eac:	01400104 	movi	r5,4
 8226eb0:	e13fe517 	ldw	r4,-108(fp)
 8226eb4:	82285000 	call	8228500 <cksum>
 8226eb8:	0084303a 	nor	r2,zero,r2
 8226ebc:	1007883a 	mov	r3,r2
 8226ec0:	e0bfe517 	ldw	r2,-108(fp)
 8226ec4:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 8226ec8:	e0bfe704 	addi	r2,fp,-100
 8226ecc:	e0bfe615 	stw	r2,-104(fp)
   MEMSET(imop, 0, sizeof(simo));
 8226ed0:	01801604 	movi	r6,88
 8226ed4:	000b883a 	mov	r5,zero
 8226ed8:	e13fe617 	ldw	r4,-104(fp)
 8226edc:	8202f000 	call	8202f00 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 8226ee0:	e0bfff17 	ldw	r2,-4(fp)
 8226ee4:	10c00117 	ldw	r3,4(r2)
 8226ee8:	e0bfe617 	ldw	r2,-104(fp)
 8226eec:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 8226ef0:	e0bfe617 	ldw	r2,-104(fp)
 8226ef4:	00c00044 	movi	r3,1
 8226ef8:	10c00105 	stb	r3,4(r2)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 8226efc:	e0bfe617 	ldw	r2,-104(fp)
 8226f00:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 8226f04:	e0bfe317 	ldw	r2,-116(fp)
 8226f08:	e0ffe017 	ldw	r3,-128(fp)
 8226f0c:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 8226f10:	e0bfe317 	ldw	r2,-116(fp)
 8226f14:	00c00204 	movi	r3,8
 8226f18:	10c00415 	stw	r3,16(r2)
   p->imo = imop;
 8226f1c:	e0bfe317 	ldw	r2,-116(fp)
 8226f20:	e0ffe617 	ldw	r3,-104(fp)
 8226f24:	10c00b15 	stw	r3,44(r2)
   
   ip_write2 (IGMP_PROT, p, optp);
 8226f28:	e1bfe117 	ldw	r6,-124(fp)
 8226f2c:	e17fe317 	ldw	r5,-116(fp)
 8226f30:	01000084 	movi	r4,2
 8226f34:	823f8b80 	call	823f8b8 <ip_write2>

   if (type == IGMPv2_LEAVE_GROUP)
 8226f38:	e0bffe03 	ldbu	r2,-8(fp)
 8226f3c:	108005d8 	cmpnei	r2,r2,23
 8226f40:	1000081e 	bne	r2,zero,8226f64 <igmp_send+0x234>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 8226f44:	008209b4 	movhi	r2,2086
 8226f48:	10b73e04 	addi	r2,r2,-8968
 8226f4c:	10801717 	ldw	r2,92(r2)
 8226f50:	10c00044 	addi	r3,r2,1
 8226f54:	008209b4 	movhi	r2,2086
 8226f58:	10b73e04 	addi	r2,r2,-8968
 8226f5c:	10c01715 	stw	r3,92(r2)
 8226f60:	00001506 	br	8226fb8 <igmp_send+0x288>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 8226f64:	e0bffe03 	ldbu	r2,-8(fp)
 8226f68:	10800598 	cmpnei	r2,r2,22
 8226f6c:	1000081e 	bne	r2,zero,8226f90 <igmp_send+0x260>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 8226f70:	008209b4 	movhi	r2,2086
 8226f74:	10b73e04 	addi	r2,r2,-8968
 8226f78:	10801817 	ldw	r2,96(r2)
 8226f7c:	10c00044 	addi	r3,r2,1
 8226f80:	008209b4 	movhi	r2,2086
 8226f84:	10b73e04 	addi	r2,r2,-8968
 8226f88:	10c01815 	stw	r3,96(r2)
 8226f8c:	00000a06 	br	8226fb8 <igmp_send+0x288>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 8226f90:	e0bffe03 	ldbu	r2,-8(fp)
 8226f94:	10800498 	cmpnei	r2,r2,18
 8226f98:	1000071e 	bne	r2,zero,8226fb8 <igmp_send+0x288>
      ++igmpstats.igmp_v1_reports_sent;
 8226f9c:	008209b4 	movhi	r2,2086
 8226fa0:	10b73e04 	addi	r2,r2,-8968
 8226fa4:	10801617 	ldw	r2,88(r2)
 8226fa8:	10c00044 	addi	r3,r2,1
 8226fac:	008209b4 	movhi	r2,2086
 8226fb0:	10b73e04 	addi	r2,r2,-8968
 8226fb4:	10c01615 	stw	r3,88(r2)
}
 8226fb8:	e037883a 	mov	sp,fp
 8226fbc:	dfc00117 	ldw	ra,4(sp)
 8226fc0:	df000017 	ldw	fp,0(sp)
 8226fc4:	dec00204 	addi	sp,sp,8
 8226fc8:	f800283a 	ret

08226fcc <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 8226fcc:	defffc04 	addi	sp,sp,-16
 8226fd0:	dfc00315 	stw	ra,12(sp)
 8226fd4:	df000215 	stw	fp,8(sp)
 8226fd8:	df000204 	addi	fp,sp,8
 8226fdc:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 8226fe0:	e0bfff17 	ldw	r2,-4(fp)
 8226fe4:	10800117 	ldw	r2,4(r2)
 8226fe8:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 8226fec:	e0bfff17 	ldw	r2,-4(fp)
 8226ff0:	10c00017 	ldw	r3,0(r2)
 8226ff4:	d0a08817 	ldw	r2,-32224(gp)
 8226ff8:	1880031e 	bne	r3,r2,8227008 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 8226ffc:	e0bfff17 	ldw	r2,-4(fp)
 8227000:	10000315 	stw	zero,12(r2)
      }

      ++igmp_timers_are_running;
   }
   
   return;
 8227004:	00008106 	br	822720c <igmp_joingroup+0x240>
      inm->inm_timer = 0;
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 8227008:	e0bffe17 	ldw	r2,-8(fp)
 822700c:	10802d03 	ldbu	r2,180(r2)
 8227010:	10803fcc 	andi	r2,r2,255
 8227014:	10003926 	beq	r2,zero,82270fc <igmp_joingroup+0x130>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8227018:	e17fff17 	ldw	r5,-4(fp)
 822701c:	01000484 	movi	r4,18
 8227020:	8226d300 	call	8226d30 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8227024:	008209b4 	movhi	r2,2086
 8227028:	10b98004 	addi	r2,r2,-6656
 822702c:	10c00217 	ldw	r3,8(r2)
 8227030:	008209b4 	movhi	r2,2086
 8227034:	10b73a04 	addi	r2,r2,-8984
 8227038:	10800017 	ldw	r2,0(r2)
 822703c:	10800a17 	ldw	r2,40(r2)
 8227040:	1008d63a 	srli	r4,r2,24
 8227044:	008209b4 	movhi	r2,2086
 8227048:	10b73a04 	addi	r2,r2,-8984
 822704c:	10800017 	ldw	r2,0(r2)
 8227050:	10800a17 	ldw	r2,40(r2)
 8227054:	1004d23a 	srli	r2,r2,8
 8227058:	10bfc00c 	andi	r2,r2,65280
 822705c:	2088b03a 	or	r4,r4,r2
 8227060:	008209b4 	movhi	r2,2086
 8227064:	10b73a04 	addi	r2,r2,-8984
 8227068:	10800017 	ldw	r2,0(r2)
 822706c:	10800a17 	ldw	r2,40(r2)
 8227070:	10bfc00c 	andi	r2,r2,65280
 8227074:	1004923a 	slli	r2,r2,8
 8227078:	2088b03a 	or	r4,r4,r2
 822707c:	008209b4 	movhi	r2,2086
 8227080:	10b73a04 	addi	r2,r2,-8984
 8227084:	10800017 	ldw	r2,0(r2)
 8227088:	10800a17 	ldw	r2,40(r2)
 822708c:	1004963a 	slli	r2,r2,24
 8227090:	2084b03a 	or	r2,r4,r2
 8227094:	1887883a 	add	r3,r3,r2
 8227098:	e0bfff17 	ldw	r2,-4(fp)
 822709c:	10800017 	ldw	r2,0(r2)
 82270a0:	1008d63a 	srli	r4,r2,24
 82270a4:	e0bfff17 	ldw	r2,-4(fp)
 82270a8:	10800017 	ldw	r2,0(r2)
 82270ac:	1004d23a 	srli	r2,r2,8
 82270b0:	10bfc00c 	andi	r2,r2,65280
 82270b4:	2088b03a 	or	r4,r4,r2
 82270b8:	e0bfff17 	ldw	r2,-4(fp)
 82270bc:	10800017 	ldw	r2,0(r2)
 82270c0:	10bfc00c 	andi	r2,r2,65280
 82270c4:	1004923a 	slli	r2,r2,8
 82270c8:	2088b03a 	or	r4,r4,r2
 82270cc:	e0bfff17 	ldw	r2,-4(fp)
 82270d0:	10800017 	ldw	r2,0(r2)
 82270d4:	1004963a 	slli	r2,r2,24
 82270d8:	2084b03a 	or	r2,r4,r2
 82270dc:	1885883a 	add	r2,r3,r2
 82270e0:	01400c84 	movi	r5,50
 82270e4:	1009883a 	mov	r4,r2
 82270e8:	82029c00 	call	82029c0 <__umodsi3>
 82270ec:	10c00044 	addi	r3,r2,1
 82270f0:	e0bfff17 	ldw	r2,-4(fp)
 82270f4:	10c00315 	stw	r3,12(r2)
 82270f8:	00003806 	br	82271dc <igmp_joingroup+0x210>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 82270fc:	e17fff17 	ldw	r5,-4(fp)
 8227100:	01000584 	movi	r4,22
 8227104:	8226d300 	call	8226d30 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 8227108:	008209b4 	movhi	r2,2086
 822710c:	10b98004 	addi	r2,r2,-6656
 8227110:	10c00217 	ldw	r3,8(r2)
 8227114:	008209b4 	movhi	r2,2086
 8227118:	10b73a04 	addi	r2,r2,-8984
 822711c:	10800017 	ldw	r2,0(r2)
 8227120:	10800a17 	ldw	r2,40(r2)
 8227124:	1008d63a 	srli	r4,r2,24
 8227128:	008209b4 	movhi	r2,2086
 822712c:	10b73a04 	addi	r2,r2,-8984
 8227130:	10800017 	ldw	r2,0(r2)
 8227134:	10800a17 	ldw	r2,40(r2)
 8227138:	1004d23a 	srli	r2,r2,8
 822713c:	10bfc00c 	andi	r2,r2,65280
 8227140:	2088b03a 	or	r4,r4,r2
 8227144:	008209b4 	movhi	r2,2086
 8227148:	10b73a04 	addi	r2,r2,-8984
 822714c:	10800017 	ldw	r2,0(r2)
 8227150:	10800a17 	ldw	r2,40(r2)
 8227154:	10bfc00c 	andi	r2,r2,65280
 8227158:	1004923a 	slli	r2,r2,8
 822715c:	2088b03a 	or	r4,r4,r2
 8227160:	008209b4 	movhi	r2,2086
 8227164:	10b73a04 	addi	r2,r2,-8984
 8227168:	10800017 	ldw	r2,0(r2)
 822716c:	10800a17 	ldw	r2,40(r2)
 8227170:	1004963a 	slli	r2,r2,24
 8227174:	2084b03a 	or	r2,r4,r2
 8227178:	1887883a 	add	r3,r3,r2
 822717c:	e0bfff17 	ldw	r2,-4(fp)
 8227180:	10800017 	ldw	r2,0(r2)
 8227184:	1008d63a 	srli	r4,r2,24
 8227188:	e0bfff17 	ldw	r2,-4(fp)
 822718c:	10800017 	ldw	r2,0(r2)
 8227190:	1004d23a 	srli	r2,r2,8
 8227194:	10bfc00c 	andi	r2,r2,65280
 8227198:	2088b03a 	or	r4,r4,r2
 822719c:	e0bfff17 	ldw	r2,-4(fp)
 82271a0:	10800017 	ldw	r2,0(r2)
 82271a4:	10bfc00c 	andi	r2,r2,65280
 82271a8:	1004923a 	slli	r2,r2,8
 82271ac:	2088b03a 	or	r4,r4,r2
 82271b0:	e0bfff17 	ldw	r2,-4(fp)
 82271b4:	10800017 	ldw	r2,0(r2)
 82271b8:	1004963a 	slli	r2,r2,24
 82271bc:	2084b03a 	or	r2,r4,r2
 82271c0:	1885883a 	add	r2,r3,r2
 82271c4:	01400c84 	movi	r5,50
 82271c8:	1009883a 	mov	r4,r2
 82271cc:	82029c00 	call	82029c0 <__umodsi3>
 82271d0:	10c00044 	addi	r3,r2,1
 82271d4:	e0bfff17 	ldw	r2,-4(fp)
 82271d8:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 82271dc:	e0bffe17 	ldw	r2,-8(fp)
 82271e0:	10802f03 	ldbu	r2,188(r2)
 82271e4:	10803fcc 	andi	r2,r2,255
 82271e8:	10800098 	cmpnei	r2,r2,2
 82271ec:	1000031e 	bne	r2,zero,82271fc <igmp_joingroup+0x230>
      {
         inm->last2send_report = IGMP_TRUE;
 82271f0:	e0bfff17 	ldw	r2,-4(fp)
 82271f4:	00c00044 	movi	r3,1
 82271f8:	10c00405 	stb	r3,16(r2)
      }

      ++igmp_timers_are_running;
 82271fc:	d0a08617 	ldw	r2,-32232(gp)
 8227200:	10800044 	addi	r2,r2,1
 8227204:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
 8227208:	0001883a 	nop
}     
 822720c:	e037883a 	mov	sp,fp
 8227210:	dfc00117 	ldw	ra,4(sp)
 8227214:	df000017 	ldw	fp,0(sp)
 8227218:	dec00204 	addi	sp,sp,8
 822721c:	f800283a 	ret

08227220 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 8227220:	defffc04 	addi	sp,sp,-16
 8227224:	dfc00315 	stw	ra,12(sp)
 8227228:	df000215 	stw	fp,8(sp)
 822722c:	df000204 	addi	fp,sp,8
 8227230:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 8227234:	e0bfff17 	ldw	r2,-4(fp)
 8227238:	10800117 	ldw	r2,4(r2)
 822723c:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 8227240:	e0bffe17 	ldw	r2,-8(fp)
 8227244:	10802f03 	ldbu	r2,188(r2)
 8227248:	10803fcc 	andi	r2,r2,255
 822724c:	10800098 	cmpnei	r2,r2,2
 8227250:	10000d1e 	bne	r2,zero,8227288 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
 8227254:	e0bffe17 	ldw	r2,-8(fp)
 8227258:	10802d03 	ldbu	r2,180(r2)
{
   NET ifp;

   ifp = inm->inm_netp;

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 822725c:	10803fcc 	andi	r2,r2,255
 8227260:	1000091e 	bne	r2,zero,8227288 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 8227264:	e0bfff17 	ldw	r2,-4(fp)
 8227268:	10800403 	ldbu	r2,16(r2)
 822726c:	10803fcc 	andi	r2,r2,255
 8227270:	10800058 	cmpnei	r2,r2,1
 8227274:	1000041e 	bne	r2,zero,8227288 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 8227278:	e17fff17 	ldw	r5,-4(fp)
 822727c:	010005c4 	movi	r4,23
 8227280:	8226d300 	call	8226d30 <igmp_send>
   }
   
   return;
 8227284:	0001883a 	nop
 8227288:	0001883a 	nop
}
 822728c:	e037883a 	mov	sp,fp
 8227290:	dfc00117 	ldw	ra,4(sp)
 8227294:	df000017 	ldw	fp,0(sp)
 8227298:	dec00204 	addi	sp,sp,8
 822729c:	f800283a 	ret

082272a0 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 82272a0:	defff604 	addi	sp,sp,-40
 82272a4:	dfc00915 	stw	ra,36(sp)
 82272a8:	df000815 	stw	fp,32(sp)
 82272ac:	df000804 	addi	fp,sp,32
 82272b0:	e13fff15 	stw	r4,-4(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 82272b4:	e0bfff17 	ldw	r2,-4(fp)
 82272b8:	10800317 	ldw	r2,12(r2)
 82272bc:	e0bff815 	stw	r2,-32(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 82272c0:	e0bfff17 	ldw	r2,-4(fp)
 82272c4:	10c00417 	ldw	r3,16(r2)
 82272c8:	e0bff817 	ldw	r2,-32(fp)
 82272cc:	10800003 	ldbu	r2,0(r2)
 82272d0:	10803fcc 	andi	r2,r2,255
 82272d4:	108003cc 	andi	r2,r2,15
 82272d8:	1085883a 	add	r2,r2,r2
 82272dc:	1085883a 	add	r2,r2,r2
 82272e0:	1885c83a 	sub	r2,r3,r2
 82272e4:	e0bff915 	stw	r2,-28(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 82272e8:	e0bff917 	ldw	r2,-28(fp)
 82272ec:	10800220 	cmpeqi	r2,r2,8
 82272f0:	1000091e 	bne	r2,zero,8227318 <igmp_validate+0x78>
   {
      ++igmpstats.igmp_badlen_rcvd;
 82272f4:	008209b4 	movhi	r2,2086
 82272f8:	10b73e04 	addi	r2,r2,-8968
 82272fc:	10800a17 	ldw	r2,40(r2)
 8227300:	10c00044 	addi	r3,r2,1
 8227304:	008209b4 	movhi	r2,2086
 8227308:	10b73e04 	addi	r2,r2,-8968
 822730c:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 8227310:	00bff804 	movi	r2,-32
 8227314:	0000a306 	br	82275a4 <igmp_validate+0x304>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 8227318:	e0bff817 	ldw	r2,-32(fp)
 822731c:	10800003 	ldbu	r2,0(r2)
 8227320:	10803fcc 	andi	r2,r2,255
 8227324:	108003cc 	andi	r2,r2,15
 8227328:	1085883a 	add	r2,r2,r2
 822732c:	1085883a 	add	r2,r2,r2
 8227330:	1007883a 	mov	r3,r2
 8227334:	e0bff817 	ldw	r2,-32(fp)
 8227338:	10c5883a 	add	r2,r2,r3
 822733c:	e0bffa15 	stw	r2,-24(fp)
   osum = igmp->igmp_cksum;
 8227340:	e0bffa17 	ldw	r2,-24(fp)
 8227344:	1080008b 	ldhu	r2,2(r2)
 8227348:	e0bffb0d 	sth	r2,-20(fp)
   igmp->igmp_cksum = 0;
 822734c:	e0bffa17 	ldw	r2,-24(fp)
 8227350:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 8227354:	e0bff917 	ldw	r2,-28(fp)
 8227358:	1005d07a 	srai	r2,r2,1
 822735c:	100b883a 	mov	r5,r2
 8227360:	e13ffa17 	ldw	r4,-24(fp)
 8227364:	82285000 	call	8228500 <cksum>
 8227368:	0084303a 	nor	r2,zero,r2
 822736c:	e0bffb8d 	sth	r2,-18(fp)
   if (xsum != osum)
 8227370:	e0fffb8b 	ldhu	r3,-18(fp)
 8227374:	e0bffb0b 	ldhu	r2,-20(fp)
 8227378:	18800c26 	beq	r3,r2,82273ac <igmp_validate+0x10c>
   {
      igmp->igmp_cksum = osum;
 822737c:	e0bffa17 	ldw	r2,-24(fp)
 8227380:	e0fffb0b 	ldhu	r3,-20(fp)
 8227384:	10c0008d 	sth	r3,2(r2)
      ++igmpstats.igmp_badsum_rcvd;
 8227388:	008209b4 	movhi	r2,2086
 822738c:	10b73e04 	addi	r2,r2,-8968
 8227390:	10800b17 	ldw	r2,44(r2)
 8227394:	10c00044 	addi	r3,r2,1
 8227398:	008209b4 	movhi	r2,2086
 822739c:	10b73e04 	addi	r2,r2,-8968
 82273a0:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 82273a4:	00bff804 	movi	r2,-32
 82273a8:	00007e06 	br	82275a4 <igmp_validate+0x304>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 82273ac:	e0bffa17 	ldw	r2,-24(fp)
 82273b0:	10800003 	ldbu	r2,0(r2)
 82273b4:	e0bffc05 	stb	r2,-16(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 82273b8:	e0bffa17 	ldw	r2,-24(fp)
 82273bc:	10800117 	ldw	r2,4(r2)
 82273c0:	1006d63a 	srli	r3,r2,24
 82273c4:	e0bffa17 	ldw	r2,-24(fp)
 82273c8:	10800117 	ldw	r2,4(r2)
 82273cc:	1004d23a 	srli	r2,r2,8
 82273d0:	10bfc00c 	andi	r2,r2,65280
 82273d4:	1886b03a 	or	r3,r3,r2
 82273d8:	e0bffa17 	ldw	r2,-24(fp)
 82273dc:	10800117 	ldw	r2,4(r2)
 82273e0:	10bfc00c 	andi	r2,r2,65280
 82273e4:	1004923a 	slli	r2,r2,8
 82273e8:	1886b03a 	or	r3,r3,r2
 82273ec:	e0bffa17 	ldw	r2,-24(fp)
 82273f0:	10800117 	ldw	r2,4(r2)
 82273f4:	1004963a 	slli	r2,r2,24
 82273f8:	1884b03a 	or	r2,r3,r2
 82273fc:	e0bffd15 	stw	r2,-12(fp)
   resp_time = igmp->igmp_code;
 8227400:	e0bffa17 	ldw	r2,-24(fp)
 8227404:	10800043 	ldbu	r2,1(r2)
 8227408:	e0bffe05 	stb	r2,-8(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 822740c:	e0bffc03 	ldbu	r2,-16(fp)
 8227410:	10800458 	cmpnei	r2,r2,17
 8227414:	1000301e 	bne	r2,zero,82274d8 <igmp_validate+0x238>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 8227418:	e0bffe03 	ldbu	r2,-8(fp)
 822741c:	10000426 	beq	r2,zero,8227430 <igmp_validate+0x190>
 8227420:	e0bffe03 	ldbu	r2,-8(fp)
 8227424:	10000f26 	beq	r2,zero,8227464 <igmp_validate+0x1c4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
 8227428:	e0bffd17 	ldw	r2,-12(fp)
 822742c:	10000d1e 	bne	r2,zero,8227464 <igmp_validate+0x1c4>
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 8227430:	e0bff817 	ldw	r2,-32(fp)
 8227434:	10c00417 	ldw	r3,16(r2)
 8227438:	d0a08817 	ldw	r2,-32224(gp)
 822743c:	18800926 	beq	r3,r2,8227464 <igmp_validate+0x1c4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 8227440:	008209b4 	movhi	r2,2086
 8227444:	10b73e04 	addi	r2,r2,-8968
 8227448:	10800e17 	ldw	r2,56(r2)
 822744c:	10c00044 	addi	r3,r2,1
 8227450:	008209b4 	movhi	r2,2086
 8227454:	10b73e04 	addi	r2,r2,-8968
 8227458:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 822745c:	00bff804 	movi	r2,-32
 8227460:	00005006 	br	82275a4 <igmp_validate+0x304>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 8227464:	e0bffe03 	ldbu	r2,-8(fp)
 8227468:	10001b26 	beq	r2,zero,82274d8 <igmp_validate+0x238>
 822746c:	e0bffd17 	ldw	r2,-12(fp)
 8227470:	10001926 	beq	r2,zero,82274d8 <igmp_validate+0x238>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 8227474:	e0bfff17 	ldw	r2,-4(fp)
 8227478:	10800617 	ldw	r2,24(r2)
 822747c:	10802f03 	ldbu	r2,188(r2)
 8227480:	10803fcc 	andi	r2,r2,255
 8227484:	10800058 	cmpnei	r2,r2,1
 8227488:	1000021e 	bne	r2,zero,8227494 <igmp_validate+0x1f4>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 822748c:	00bff804 	movi	r2,-32
 8227490:	00004406 	br	82275a4 <igmp_validate+0x304>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 8227494:	e0bffd17 	ldw	r2,-12(fp)
 8227498:	10fc002c 	andhi	r3,r2,61440
 822749c:	00b80034 	movhi	r2,57344
 82274a0:	1880041e 	bne	r3,r2,82274b4 <igmp_validate+0x214>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
 82274a4:	e0bffa17 	ldw	r2,-24(fp)
 82274a8:	10c00117 	ldw	r3,4(r2)
 82274ac:	d0a08817 	ldw	r2,-32224(gp)
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 82274b0:	1880091e 	bne	r3,r2,82274d8 <igmp_validate+0x238>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 82274b4:	008209b4 	movhi	r2,2086
 82274b8:	10b73e04 	addi	r2,r2,-8968
 82274bc:	10801117 	ldw	r2,68(r2)
 82274c0:	10c00044 	addi	r3,r2,1
 82274c4:	008209b4 	movhi	r2,2086
 82274c8:	10b73e04 	addi	r2,r2,-8968
 82274cc:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 82274d0:	00bff804 	movi	r2,-32
 82274d4:	00003306 	br	82275a4 <igmp_validate+0x304>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 82274d8:	e0bffc03 	ldbu	r2,-16(fp)
 82274dc:	108004a0 	cmpeqi	r2,r2,18
 82274e0:	1000031e 	bne	r2,zero,82274f0 <igmp_validate+0x250>
 82274e4:	e0bffc03 	ldbu	r2,-16(fp)
 82274e8:	10800598 	cmpnei	r2,r2,22
 82274ec:	1000121e 	bne	r2,zero,8227538 <igmp_validate+0x298>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82274f0:	e0bffa17 	ldw	r2,-24(fp)
 82274f4:	10c00117 	ldw	r3,4(r2)
 82274f8:	e0bff817 	ldw	r2,-32(fp)
 82274fc:	10800417 	ldw	r2,16(r2)
 8227500:	1880041e 	bne	r3,r2,8227514 <igmp_validate+0x274>
          (!IN_MULTICAST(mcgrp_addr)))
 8227504:	e0bffd17 	ldw	r2,-12(fp)
 8227508:	10fc002c 	andhi	r3,r2,61440
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 822750c:	00b80034 	movhi	r2,57344
 8227510:	18800926 	beq	r3,r2,8227538 <igmp_validate+0x298>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 8227514:	008209b4 	movhi	r2,2086
 8227518:	10b73e04 	addi	r2,r2,-8968
 822751c:	10800f17 	ldw	r2,60(r2)
 8227520:	10c00044 	addi	r3,r2,1
 8227524:	008209b4 	movhi	r2,2086
 8227528:	10b73e04 	addi	r2,r2,-8968
 822752c:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 8227530:	00bff804 	movi	r2,-32
 8227534:	00001b06 	br	82275a4 <igmp_validate+0x304>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8227538:	e0bffc03 	ldbu	r2,-16(fp)
 822753c:	108005e0 	cmpeqi	r2,r2,23
 8227540:	10000a1e 	bne	r2,zero,822756c <igmp_validate+0x2cc>
 8227544:	e0bffc03 	ldbu	r2,-16(fp)
 8227548:	108005a0 	cmpeqi	r2,r2,22
 822754c:	1000071e 	bne	r2,zero,822756c <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
 8227550:	e0bffc03 	ldbu	r2,-16(fp)
 8227554:	10800458 	cmpnei	r2,r2,17
 8227558:	1000111e 	bne	r2,zero,82275a0 <igmp_validate+0x300>
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
 822755c:	e0bffa17 	ldw	r2,-24(fp)
 8227560:	10800043 	ldbu	r2,1(r2)
 8227564:	10803fcc 	andi	r2,r2,255
 8227568:	10000d26 	beq	r2,zero,82275a0 <igmp_validate+0x300>
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 822756c:	e13ff817 	ldw	r4,-32(fp)
 8227570:	8245a840 	call	8245a84 <igmpv2_chk4_rtr_alert_opt>
 8227574:	10803fcc 	andi	r2,r2,255
 8227578:	1000091e 	bne	r2,zero,82275a0 <igmp_validate+0x300>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 822757c:	008209b4 	movhi	r2,2086
 8227580:	10b73e04 	addi	r2,r2,-8968
 8227584:	10801417 	ldw	r2,80(r2)
 8227588:	10c00044 	addi	r3,r2,1
 822758c:	008209b4 	movhi	r2,2086
 8227590:	10b73e04 	addi	r2,r2,-8968
 8227594:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 8227598:	00bff804 	movi	r2,-32
 822759c:	00000106 	br	82275a4 <igmp_validate+0x304>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 82275a0:	0005883a 	mov	r2,zero
}
 82275a4:	e037883a 	mov	sp,fp
 82275a8:	dfc00117 	ldw	ra,4(sp)
 82275ac:	df000017 	ldw	fp,0(sp)
 82275b0:	dec00204 	addi	sp,sp,8
 82275b4:	f800283a 	ret

082275b8 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 82275b8:	defffa04 	addi	sp,sp,-24
 82275bc:	dfc00515 	stw	ra,20(sp)
 82275c0:	df000415 	stw	fp,16(sp)
 82275c4:	df000404 	addi	fp,sp,16
 82275c8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82275cc:	008209b4 	movhi	r2,2086
 82275d0:	10b97b04 	addi	r2,r2,-6676
 82275d4:	10800017 	ldw	r2,0(r2)
 82275d8:	e0bffe15 	stw	r2,-8(fp)
 82275dc:	00003b06 	br	82276cc <igmp_print_stats+0x114>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
                 ifp->name, 
 82275e0:	e0bffe17 	ldw	r2,-8(fp)
 82275e4:	10c00104 	addi	r3,r2,4
                 ifp->igmp_oper_mode, 
 82275e8:	e0bffe17 	ldw	r2,-8(fp)
 82275ec:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82275f0:	11003fcc 	andi	r4,r2,255
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
 82275f4:	e0bffe17 	ldw	r2,-8(fp)
 82275f8:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82275fc:	10803fcc 	andi	r2,r2,255
 8227600:	10800058 	cmpnei	r2,r2,1
 8227604:	1000031e 	bne	r2,zero,8227614 <igmp_print_stats+0x5c>
 8227608:	00820974 	movhi	r2,2085
 822760c:	10bf4004 	addi	r2,r2,-768
 8227610:	00000206 	br	822761c <igmp_print_stats+0x64>
 8227614:	00820974 	movhi	r2,2085
 8227618:	10bf4104 	addi	r2,r2,-764
 822761c:	d8800015 	stw	r2,0(sp)
 8227620:	200f883a 	mov	r7,r4
 8227624:	180d883a 	mov	r6,r3
 8227628:	01420974 	movhi	r5,2085
 822762c:	297f4204 	addi	r5,r5,-760
 8227630:	e13fff17 	ldw	r4,-4(fp)
 8227634:	8228bac0 	call	8228bac <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8227638:	e0bffe17 	ldw	r2,-8(fp)
 822763c:	10802f03 	ldbu	r2,188(r2)
 8227640:	10803fcc 	andi	r2,r2,255
 8227644:	10800098 	cmpnei	r2,r2,2
 8227648:	1000191e 	bne	r2,zero,82276b0 <igmp_print_stats+0xf8>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
                    ifp->igmpv1_rtr_present,
 822764c:	e0bffe17 	ldw	r2,-8(fp)
 8227650:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227654:	11403fcc 	andi	r5,r2,255
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
 8227658:	e0bffe17 	ldw	r2,-8(fp)
 822765c:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227660:	10803fcc 	andi	r2,r2,255
 8227664:	10800058 	cmpnei	r2,r2,1
 8227668:	1000031e 	bne	r2,zero,8227678 <igmp_print_stats+0xc0>
 822766c:	00820974 	movhi	r2,2085
 8227670:	10bf4704 	addi	r2,r2,-740
 8227674:	00000206 	br	8227680 <igmp_print_stats+0xc8>
 8227678:	00820974 	movhi	r2,2085
 822767c:	10bf4904 	addi	r2,r2,-732
 8227680:	e0fffe17 	ldw	r3,-8(fp)
 8227684:	18c02e17 	ldw	r3,184(r3)
 8227688:	d120a817 	ldw	r4,-32096(gp)
 822768c:	d9000115 	stw	r4,4(sp)
 8227690:	d8c00015 	stw	r3,0(sp)
 8227694:	100f883a 	mov	r7,r2
 8227698:	280d883a 	mov	r6,r5
 822769c:	01420974 	movhi	r5,2085
 82276a0:	297f4b04 	addi	r5,r5,-724
 82276a4:	e13fff17 	ldw	r4,-4(fp)
 82276a8:	8228bac0 	call	8228bac <ns_printf>
 82276ac:	00000406 	br	82276c0 <igmp_print_stats+0x108>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 82276b0:	01420974 	movhi	r5,2085
 82276b4:	297f5604 	addi	r5,r5,-680
 82276b8:	e13fff17 	ldw	r4,-4(fp)
 82276bc:	8228bac0 	call	8228bac <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82276c0:	e0bffe17 	ldw	r2,-8(fp)
 82276c4:	10800017 	ldw	r2,0(r2)
 82276c8:	e0bffe15 	stw	r2,-8(fp)
 82276cc:	e0bffe17 	ldw	r2,-8(fp)
 82276d0:	103fc31e 	bne	r2,zero,82275e0 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 82276d4:	008209b4 	movhi	r2,2086
 82276d8:	10b73e04 	addi	r2,r2,-8968
 82276dc:	10800017 	ldw	r2,0(r2)
 82276e0:	d0e08617 	ldw	r3,-32232(gp)
 82276e4:	180f883a 	mov	r7,r3
 82276e8:	100d883a 	mov	r6,r2
 82276ec:	01420974 	movhi	r5,2085
 82276f0:	297f5704 	addi	r5,r5,-676
 82276f4:	e13fff17 	ldw	r4,-4(fp)
 82276f8:	8228bac0 	call	8228bac <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 82276fc:	008209b4 	movhi	r2,2086
 8227700:	10b73e04 	addi	r2,r2,-8968
 8227704:	10800117 	ldw	r2,4(r2)
 8227708:	100d883a 	mov	r6,r2
 822770c:	01420974 	movhi	r5,2085
 8227710:	297f6404 	addi	r5,r5,-624
 8227714:	e13fff17 	ldw	r4,-4(fp)
 8227718:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 822771c:	008209b4 	movhi	r2,2086
 8227720:	10b73e04 	addi	r2,r2,-8968
 8227724:	10800217 	ldw	r2,8(r2)
 8227728:	100d883a 	mov	r6,r2
 822772c:	01420974 	movhi	r5,2085
 8227730:	297f7504 	addi	r5,r5,-556
 8227734:	e13fff17 	ldw	r4,-4(fp)
 8227738:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 822773c:	008209b4 	movhi	r2,2086
 8227740:	10b73e04 	addi	r2,r2,-8968
 8227744:	10800317 	ldw	r2,12(r2)
 8227748:	100d883a 	mov	r6,r2
 822774c:	01420974 	movhi	r5,2085
 8227750:	297f8104 	addi	r5,r5,-508
 8227754:	e13fff17 	ldw	r4,-4(fp)
 8227758:	8228bac0 	call	8228bac <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 822775c:	008209b4 	movhi	r2,2086
 8227760:	10b73e04 	addi	r2,r2,-8968
 8227764:	10800417 	ldw	r2,16(r2)
 8227768:	100d883a 	mov	r6,r2
 822776c:	01420974 	movhi	r5,2085
 8227770:	297f9404 	addi	r5,r5,-432
 8227774:	e13fff17 	ldw	r4,-4(fp)
 8227778:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 822777c:	008209b4 	movhi	r2,2086
 8227780:	10b73e04 	addi	r2,r2,-8968
 8227784:	10c00517 	ldw	r3,20(r2)
 8227788:	008209b4 	movhi	r2,2086
 822778c:	10b73e04 	addi	r2,r2,-8968
 8227790:	10800617 	ldw	r2,24(r2)
 8227794:	100f883a 	mov	r7,r2
 8227798:	180d883a 	mov	r6,r3
 822779c:	01420974 	movhi	r5,2085
 82277a0:	297fa504 	addi	r5,r5,-364
 82277a4:	e13fff17 	ldw	r4,-4(fp)
 82277a8:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 82277ac:	008209b4 	movhi	r2,2086
 82277b0:	10b73e04 	addi	r2,r2,-8968
 82277b4:	10800717 	ldw	r2,28(r2)
 82277b8:	100d883a 	mov	r6,r2
 82277bc:	01420974 	movhi	r5,2085
 82277c0:	297f8104 	addi	r5,r5,-508
 82277c4:	e13fff17 	ldw	r4,-4(fp)
 82277c8:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 82277cc:	008209b4 	movhi	r2,2086
 82277d0:	10b73e04 	addi	r2,r2,-8968
 82277d4:	10800817 	ldw	r2,32(r2)
 82277d8:	100d883a 	mov	r6,r2
 82277dc:	01420974 	movhi	r5,2085
 82277e0:	297fb804 	addi	r5,r5,-288
 82277e4:	e13fff17 	ldw	r4,-4(fp)
 82277e8:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 82277ec:	008209b4 	movhi	r2,2086
 82277f0:	10b73e04 	addi	r2,r2,-8968
 82277f4:	10800917 	ldw	r2,36(r2)
 82277f8:	100d883a 	mov	r6,r2
 82277fc:	01420974 	movhi	r5,2085
 8227800:	297fc904 	addi	r5,r5,-220
 8227804:	e13fff17 	ldw	r4,-4(fp)
 8227808:	8228bac0 	call	8228bac <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 822780c:	008209b4 	movhi	r2,2086
 8227810:	10b73e04 	addi	r2,r2,-8968
 8227814:	10c01717 	ldw	r3,92(r2)
 8227818:	008209b4 	movhi	r2,2086
 822781c:	10b73e04 	addi	r2,r2,-8968
 8227820:	10801817 	ldw	r2,96(r2)
 8227824:	100f883a 	mov	r7,r2
 8227828:	180d883a 	mov	r6,r3
 822782c:	01420974 	movhi	r5,2085
 8227830:	297fd504 	addi	r5,r5,-172
 8227834:	e13fff17 	ldw	r4,-4(fp)
 8227838:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 822783c:	008209b4 	movhi	r2,2086
 8227840:	10b73e04 	addi	r2,r2,-8968
 8227844:	10801617 	ldw	r2,88(r2)
 8227848:	100d883a 	mov	r6,r2
 822784c:	01420974 	movhi	r5,2085
 8227850:	297fe804 	addi	r5,r5,-96
 8227854:	e13fff17 	ldw	r4,-4(fp)
 8227858:	8228bac0 	call	8228bac <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 822785c:	008209b4 	movhi	r2,2086
 8227860:	10b73e04 	addi	r2,r2,-8968
 8227864:	10800a17 	ldw	r2,40(r2)
 8227868:	100d883a 	mov	r6,r2
 822786c:	01420974 	movhi	r5,2085
 8227870:	297ff404 	addi	r5,r5,-48
 8227874:	e13fff17 	ldw	r4,-4(fp)
 8227878:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 822787c:	008209b4 	movhi	r2,2086
 8227880:	10b73e04 	addi	r2,r2,-8968
 8227884:	10800b17 	ldw	r2,44(r2)
 8227888:	100d883a 	mov	r6,r2
 822788c:	01420974 	movhi	r5,2085
 8227890:	29400004 	addi	r5,r5,0
 8227894:	e13fff17 	ldw	r4,-4(fp)
 8227898:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 822789c:	008209b4 	movhi	r2,2086
 82278a0:	10b73e04 	addi	r2,r2,-8968
 82278a4:	10c00c17 	ldw	r3,48(r2)
 82278a8:	008209b4 	movhi	r2,2086
 82278ac:	10b73e04 	addi	r2,r2,-8968
 82278b0:	10800d17 	ldw	r2,52(r2)
 82278b4:	100f883a 	mov	r7,r2
 82278b8:	180d883a 	mov	r6,r3
 82278bc:	01420974 	movhi	r5,2085
 82278c0:	29400c04 	addi	r5,r5,48
 82278c4:	e13fff17 	ldw	r4,-4(fp)
 82278c8:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 82278cc:	008209b4 	movhi	r2,2086
 82278d0:	10b73e04 	addi	r2,r2,-8968
 82278d4:	10c00e17 	ldw	r3,56(r2)
 82278d8:	008209b4 	movhi	r2,2086
 82278dc:	10b73e04 	addi	r2,r2,-8968
 82278e0:	10800f17 	ldw	r2,60(r2)
 82278e4:	100f883a 	mov	r7,r2
 82278e8:	180d883a 	mov	r6,r3
 82278ec:	01420974 	movhi	r5,2085
 82278f0:	29402004 	addi	r5,r5,128
 82278f4:	e13fff17 	ldw	r4,-4(fp)
 82278f8:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 82278fc:	008209b4 	movhi	r2,2086
 8227900:	10b73e04 	addi	r2,r2,-8968
 8227904:	10801117 	ldw	r2,68(r2)
 8227908:	100d883a 	mov	r6,r2
 822790c:	01420974 	movhi	r5,2085
 8227910:	29403004 	addi	r5,r5,192
 8227914:	e13fff17 	ldw	r4,-4(fp)
 8227918:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 822791c:	008209b4 	movhi	r2,2086
 8227920:	10b73e04 	addi	r2,r2,-8968
 8227924:	10801217 	ldw	r2,72(r2)
 8227928:	100d883a 	mov	r6,r2
 822792c:	01420974 	movhi	r5,2085
 8227930:	29403d04 	addi	r5,r5,244
 8227934:	e13fff17 	ldw	r4,-4(fp)
 8227938:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 822793c:	008209b4 	movhi	r2,2086
 8227940:	10b73e04 	addi	r2,r2,-8968
 8227944:	10801317 	ldw	r2,76(r2)
 8227948:	100d883a 	mov	r6,r2
 822794c:	01420974 	movhi	r5,2085
 8227950:	29405004 	addi	r5,r5,320
 8227954:	e13fff17 	ldw	r4,-4(fp)
 8227958:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 822795c:	008209b4 	movhi	r2,2086
 8227960:	10b73e04 	addi	r2,r2,-8968
 8227964:	10801417 	ldw	r2,80(r2)
 8227968:	100d883a 	mov	r6,r2
 822796c:	01420974 	movhi	r5,2085
 8227970:	29406104 	addi	r5,r5,388
 8227974:	e13fff17 	ldw	r4,-4(fp)
 8227978:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 822797c:	008209b4 	movhi	r2,2086
 8227980:	10b73e04 	addi	r2,r2,-8968
 8227984:	10801017 	ldw	r2,64(r2)
 8227988:	100d883a 	mov	r6,r2
 822798c:	01420974 	movhi	r5,2085
 8227990:	29407304 	addi	r5,r5,460
 8227994:	e13fff17 	ldw	r4,-4(fp)
 8227998:	8228bac0 	call	8228bac <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 822799c:	008209b4 	movhi	r2,2086
 82279a0:	10b73e04 	addi	r2,r2,-8968
 82279a4:	10801517 	ldw	r2,84(r2)
 82279a8:	100d883a 	mov	r6,r2
 82279ac:	01420974 	movhi	r5,2085
 82279b0:	29408304 	addi	r5,r5,524
 82279b4:	e13fff17 	ldw	r4,-4(fp)
 82279b8:	8228bac0 	call	8228bac <ns_printf>
   
   return IGMP_OK;
 82279bc:	0005883a 	mov	r2,zero
}
 82279c0:	e037883a 	mov	sp,fp
 82279c4:	dfc00117 	ldw	ra,4(sp)
 82279c8:	df000017 	ldw	fp,0(sp)
 82279cc:	dec00204 	addi	sp,sp,8
 82279d0:	f800283a 	ret

082279d4 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 82279d4:	defff404 	addi	sp,sp,-48
 82279d8:	dfc00b15 	stw	ra,44(sp)
 82279dc:	df000a15 	stw	fp,40(sp)
 82279e0:	df000a04 	addi	fp,sp,40
 82279e4:	e13ffd15 	stw	r4,-12(fp)
 82279e8:	e17ffe15 	stw	r5,-8(fp)
 82279ec:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 82279f0:	e0bffd17 	ldw	r2,-12(fp)
 82279f4:	10bff804 	addi	r2,r2,-32
 82279f8:	1085883a 	add	r2,r2,r2
 82279fc:	1085883a 	add	r2,r2,r2
 8227a00:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 8227a04:	008209b4 	movhi	r2,2086
 8227a08:	10b87704 	addi	r2,r2,-7716
 8227a0c:	e0bff615 	stw	r2,-40(fp)
 8227a10:	00000606 	br	8227a2c <bsd_accept+0x58>
 8227a14:	e0fff617 	ldw	r3,-40(fp)
 8227a18:	e0bff717 	ldw	r2,-36(fp)
 8227a1c:	18800626 	beq	r3,r2,8227a38 <bsd_accept+0x64>
 8227a20:	e0bff617 	ldw	r2,-40(fp)
 8227a24:	10800017 	ldw	r2,0(r2)
 8227a28:	e0bff615 	stw	r2,-40(fp)
 8227a2c:	e0bff617 	ldw	r2,-40(fp)
 8227a30:	103ff81e 	bne	r2,zero,8227a14 <bsd_accept+0x40>
 8227a34:	00000106 	br	8227a3c <bsd_accept+0x68>
 8227a38:	0001883a 	nop
 8227a3c:	e0fff617 	ldw	r3,-40(fp)
 8227a40:	e0bff717 	ldw	r2,-36(fp)
 8227a44:	18800326 	beq	r3,r2,8227a54 <bsd_accept+0x80>
 8227a48:	822d2e00 	call	822d2e0 <dtrap>
 8227a4c:	00bfffc4 	movi	r2,-1
 8227a50:	00002406 	br	8227ae4 <bsd_accept+0x110>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 8227a54:	e0bffe17 	ldw	r2,-8(fp)
 8227a58:	10000726 	beq	r2,zero,8227a78 <bsd_accept+0xa4>
   {
      if (addrlen == 0)
 8227a5c:	e0bfff17 	ldw	r2,-4(fp)
 8227a60:	1000051e 	bne	r2,zero,8227a78 <bsd_accept+0xa4>
      {
         so->so_error = EFAULT;
 8227a64:	e0bff717 	ldw	r2,-36(fp)
 8227a68:	00c00384 	movi	r3,14
 8227a6c:	10c00615 	stw	r3,24(r2)
         return -1;
 8227a70:	00bfffc4 	movi	r2,-1
 8227a74:	00001b06 	br	8227ae4 <bsd_accept+0x110>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 8227a78:	e0bff904 	addi	r2,fp,-28
 8227a7c:	e1bfff17 	ldw	r6,-4(fp)
 8227a80:	100b883a 	mov	r5,r2
 8227a84:	e13ffd17 	ldw	r4,-12(fp)
 8227a88:	82304380 	call	8230438 <t_accept>
 8227a8c:	e0bff815 	stw	r2,-32(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 8227a90:	e0bff817 	ldw	r2,-32(fp)
 8227a94:	10bfffe0 	cmpeqi	r2,r2,-1
 8227a98:	1000111e 	bne	r2,zero,8227ae0 <bsd_accept+0x10c>
 8227a9c:	e0bffe17 	ldw	r2,-8(fp)
 8227aa0:	10000f26 	beq	r2,zero,8227ae0 <bsd_accept+0x10c>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 8227aa4:	e0bfff17 	ldw	r2,-4(fp)
 8227aa8:	10800017 	ldw	r2,0(r2)
 8227aac:	10800470 	cmpltui	r2,r2,17
 8227ab0:	1000031e 	bne	r2,zero,8227ac0 <bsd_accept+0xec>
         *addrlen = sizeof(struct sockaddr_in);
 8227ab4:	e0bfff17 	ldw	r2,-4(fp)
 8227ab8:	00c00404 	movi	r3,16
 8227abc:	10c00015 	stw	r3,0(r2)
      MEMCPY(addr, &laddr, *addrlen);
 8227ac0:	e0bfff17 	ldw	r2,-4(fp)
 8227ac4:	10800017 	ldw	r2,0(r2)
 8227ac8:	1007883a 	mov	r3,r2
 8227acc:	e0bff904 	addi	r2,fp,-28
 8227ad0:	180d883a 	mov	r6,r3
 8227ad4:	100b883a 	mov	r5,r2
 8227ad8:	e13ffe17 	ldw	r4,-8(fp)
 8227adc:	8202c5c0 	call	8202c5c <memcpy>
   }

   return lret;
 8227ae0:	e0bff817 	ldw	r2,-32(fp)
}
 8227ae4:	e037883a 	mov	sp,fp
 8227ae8:	dfc00117 	ldw	ra,4(sp)
 8227aec:	df000017 	ldw	fp,0(sp)
 8227af0:	dec00204 	addi	sp,sp,8
 8227af4:	f800283a 	ret

08227af8 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227af8:	defff304 	addi	sp,sp,-52
 8227afc:	dfc00c15 	stw	ra,48(sp)
 8227b00:	df000b15 	stw	fp,44(sp)
 8227b04:	df000b04 	addi	fp,sp,44
 8227b08:	e13ffd15 	stw	r4,-12(fp)
 8227b0c:	e17ffe15 	stw	r5,-8(fp)
 8227b10:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227b14:	e0bffd17 	ldw	r2,-12(fp)
 8227b18:	10bff804 	addi	r2,r2,-32
 8227b1c:	1085883a 	add	r2,r2,r2
 8227b20:	1085883a 	add	r2,r2,r2
 8227b24:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227b28:	008209b4 	movhi	r2,2086
 8227b2c:	10b87704 	addi	r2,r2,-7716
 8227b30:	e0bff515 	stw	r2,-44(fp)
 8227b34:	00000606 	br	8227b50 <bsd_getpeername+0x58>
 8227b38:	e0fff517 	ldw	r3,-44(fp)
 8227b3c:	e0bff617 	ldw	r2,-40(fp)
 8227b40:	18800626 	beq	r3,r2,8227b5c <bsd_getpeername+0x64>
 8227b44:	e0bff517 	ldw	r2,-44(fp)
 8227b48:	10800017 	ldw	r2,0(r2)
 8227b4c:	e0bff515 	stw	r2,-44(fp)
 8227b50:	e0bff517 	ldw	r2,-44(fp)
 8227b54:	103ff81e 	bne	r2,zero,8227b38 <bsd_getpeername+0x40>
 8227b58:	00000106 	br	8227b60 <bsd_getpeername+0x68>
 8227b5c:	0001883a 	nop
 8227b60:	e0fff517 	ldw	r3,-44(fp)
 8227b64:	e0bff617 	ldw	r2,-40(fp)
 8227b68:	18800326 	beq	r3,r2,8227b78 <bsd_getpeername+0x80>
 8227b6c:	822d2e00 	call	822d2e0 <dtrap>
 8227b70:	00bfffc4 	movi	r2,-1
 8227b74:	00002406 	br	8227c08 <bsd_getpeername+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227b78:	e0bfff17 	ldw	r2,-4(fp)
 8227b7c:	1000051e 	bne	r2,zero,8227b94 <bsd_getpeername+0x9c>
   {
      so->so_error = EFAULT;
 8227b80:	e0bff617 	ldw	r2,-40(fp)
 8227b84:	00c00384 	movi	r3,14
 8227b88:	10c00615 	stw	r3,24(r2)
      return -1;
 8227b8c:	00bfffc4 	movi	r2,-1
 8227b90:	00001d06 	br	8227c08 <bsd_getpeername+0x110>
   }
   lnamelen = *namelen;
 8227b94:	e0bfff17 	ldw	r2,-4(fp)
 8227b98:	10800017 	ldw	r2,0(r2)
 8227b9c:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 8227ba0:	e0fffc04 	addi	r3,fp,-16
 8227ba4:	e0bff804 	addi	r2,fp,-32
 8227ba8:	180d883a 	mov	r6,r3
 8227bac:	100b883a 	mov	r5,r2
 8227bb0:	e13ffd17 	ldw	r4,-12(fp)
 8227bb4:	82308f80 	call	82308f8 <t_getpeername>
 8227bb8:	e0bff715 	stw	r2,-36(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 8227bbc:	e0bff717 	ldw	r2,-36(fp)
 8227bc0:	10bfffe0 	cmpeqi	r2,r2,-1
 8227bc4:	10000f1e 	bne	r2,zero,8227c04 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227bc8:	e0bffc17 	ldw	r2,-16(fp)
 8227bcc:	10800470 	cmpltui	r2,r2,17
 8227bd0:	1000021e 	bne	r2,zero,8227bdc <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227bd4:	00800404 	movi	r2,16
 8227bd8:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 8227bdc:	e0bffc17 	ldw	r2,-16(fp)
 8227be0:	1007883a 	mov	r3,r2
 8227be4:	e0bff804 	addi	r2,fp,-32
 8227be8:	180d883a 	mov	r6,r3
 8227bec:	100b883a 	mov	r5,r2
 8227bf0:	e13ffe17 	ldw	r4,-8(fp)
 8227bf4:	8202c5c0 	call	8202c5c <memcpy>
      *namelen = lnamelen;
 8227bf8:	e0fffc17 	ldw	r3,-16(fp)
 8227bfc:	e0bfff17 	ldw	r2,-4(fp)
 8227c00:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227c04:	e0bff717 	ldw	r2,-36(fp)
}
 8227c08:	e037883a 	mov	sp,fp
 8227c0c:	dfc00117 	ldw	ra,4(sp)
 8227c10:	df000017 	ldw	fp,0(sp)
 8227c14:	dec00204 	addi	sp,sp,8
 8227c18:	f800283a 	ret

08227c1c <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227c1c:	defff304 	addi	sp,sp,-52
 8227c20:	dfc00c15 	stw	ra,48(sp)
 8227c24:	df000b15 	stw	fp,44(sp)
 8227c28:	df000b04 	addi	fp,sp,44
 8227c2c:	e13ffd15 	stw	r4,-12(fp)
 8227c30:	e17ffe15 	stw	r5,-8(fp)
 8227c34:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227c38:	e0bffd17 	ldw	r2,-12(fp)
 8227c3c:	10bff804 	addi	r2,r2,-32
 8227c40:	1085883a 	add	r2,r2,r2
 8227c44:	1085883a 	add	r2,r2,r2
 8227c48:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227c4c:	008209b4 	movhi	r2,2086
 8227c50:	10b87704 	addi	r2,r2,-7716
 8227c54:	e0bff515 	stw	r2,-44(fp)
 8227c58:	00000606 	br	8227c74 <bsd_getsockname+0x58>
 8227c5c:	e0fff517 	ldw	r3,-44(fp)
 8227c60:	e0bff617 	ldw	r2,-40(fp)
 8227c64:	18800626 	beq	r3,r2,8227c80 <bsd_getsockname+0x64>
 8227c68:	e0bff517 	ldw	r2,-44(fp)
 8227c6c:	10800017 	ldw	r2,0(r2)
 8227c70:	e0bff515 	stw	r2,-44(fp)
 8227c74:	e0bff517 	ldw	r2,-44(fp)
 8227c78:	103ff81e 	bne	r2,zero,8227c5c <bsd_getsockname+0x40>
 8227c7c:	00000106 	br	8227c84 <bsd_getsockname+0x68>
 8227c80:	0001883a 	nop
 8227c84:	e0fff517 	ldw	r3,-44(fp)
 8227c88:	e0bff617 	ldw	r2,-40(fp)
 8227c8c:	18800326 	beq	r3,r2,8227c9c <bsd_getsockname+0x80>
 8227c90:	822d2e00 	call	822d2e0 <dtrap>
 8227c94:	00bfffc4 	movi	r2,-1
 8227c98:	00002406 	br	8227d2c <bsd_getsockname+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227c9c:	e0bfff17 	ldw	r2,-4(fp)
 8227ca0:	1000051e 	bne	r2,zero,8227cb8 <bsd_getsockname+0x9c>
   {
      so->so_error = EFAULT;
 8227ca4:	e0bff617 	ldw	r2,-40(fp)
 8227ca8:	00c00384 	movi	r3,14
 8227cac:	10c00615 	stw	r3,24(r2)
      return -1;
 8227cb0:	00bfffc4 	movi	r2,-1
 8227cb4:	00001d06 	br	8227d2c <bsd_getsockname+0x110>
   }
   lnamelen = *namelen;
 8227cb8:	e0bfff17 	ldw	r2,-4(fp)
 8227cbc:	10800017 	ldw	r2,0(r2)
 8227cc0:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 8227cc4:	e0fffc04 	addi	r3,fp,-16
 8227cc8:	e0bff804 	addi	r2,fp,-32
 8227ccc:	180d883a 	mov	r6,r3
 8227cd0:	100b883a 	mov	r5,r2
 8227cd4:	e13ffd17 	ldw	r4,-12(fp)
 8227cd8:	823093c0 	call	823093c <t_getsockname>
 8227cdc:	e0bff715 	stw	r2,-36(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 8227ce0:	e0bff717 	ldw	r2,-36(fp)
 8227ce4:	10bfffe0 	cmpeqi	r2,r2,-1
 8227ce8:	10000f1e 	bne	r2,zero,8227d28 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227cec:	e0bffc17 	ldw	r2,-16(fp)
 8227cf0:	10800470 	cmpltui	r2,r2,17
 8227cf4:	1000021e 	bne	r2,zero,8227d00 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227cf8:	00800404 	movi	r2,16
 8227cfc:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 8227d00:	e0bffc17 	ldw	r2,-16(fp)
 8227d04:	1007883a 	mov	r3,r2
 8227d08:	e0bff804 	addi	r2,fp,-32
 8227d0c:	180d883a 	mov	r6,r3
 8227d10:	100b883a 	mov	r5,r2
 8227d14:	e13ffe17 	ldw	r4,-8(fp)
 8227d18:	8202c5c0 	call	8202c5c <memcpy>
      *namelen = lnamelen;
 8227d1c:	e0fffc17 	ldw	r3,-16(fp)
 8227d20:	e0bfff17 	ldw	r2,-4(fp)
 8227d24:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227d28:	e0bff717 	ldw	r2,-36(fp)
}
 8227d2c:	e037883a 	mov	sp,fp
 8227d30:	dfc00117 	ldw	ra,4(sp)
 8227d34:	df000017 	ldw	fp,0(sp)
 8227d38:	dec00204 	addi	sp,sp,8
 8227d3c:	f800283a 	ret

08227d40 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 8227d40:	defffd04 	addi	sp,sp,-12
 8227d44:	df000215 	stw	fp,8(sp)
 8227d48:	df000204 	addi	fp,sp,8
 8227d4c:	e13ffe15 	stw	r4,-8(fp)
 8227d50:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(level);

   switch (name)
 8227d54:	e0bfff17 	ldw	r2,-4(fp)
 8227d58:	10c02020 	cmpeqi	r3,r2,128
 8227d5c:	1800341e 	bne	r3,zero,8227e30 <bsd_i_sockoptlen+0xf0>
 8227d60:	10c02048 	cmpgei	r3,r2,129
 8227d64:	18001a1e 	bne	r3,zero,8227dd0 <bsd_i_sockoptlen+0x90>
 8227d68:	10c00308 	cmpgei	r3,r2,12
 8227d6c:	18000e1e 	bne	r3,zero,8227da8 <bsd_i_sockoptlen+0x68>
 8227d70:	10c00288 	cmpgei	r3,r2,10
 8227d74:	1800361e 	bne	r3,zero,8227e50 <bsd_i_sockoptlen+0x110>
 8227d78:	10c00120 	cmpeqi	r3,r2,4
 8227d7c:	1800301e 	bne	r3,zero,8227e40 <bsd_i_sockoptlen+0x100>
 8227d80:	10c00148 	cmpgei	r3,r2,5
 8227d84:	1800031e 	bne	r3,zero,8227d94 <bsd_i_sockoptlen+0x54>
 8227d88:	108000e0 	cmpeqi	r2,r2,3
 8227d8c:	1000341e 	bne	r2,zero,8227e60 <bsd_i_sockoptlen+0x120>
 8227d90:	00003506 	br	8227e68 <bsd_i_sockoptlen+0x128>
 8227d94:	10c00220 	cmpeqi	r3,r2,8
 8227d98:	1800291e 	bne	r3,zero,8227e40 <bsd_i_sockoptlen+0x100>
 8227d9c:	10800260 	cmpeqi	r2,r2,9
 8227da0:	1000291e 	bne	r2,zero,8227e48 <bsd_i_sockoptlen+0x108>
 8227da4:	00003006 	br	8227e68 <bsd_i_sockoptlen+0x128>
 8227da8:	10c00420 	cmpeqi	r3,r2,16
 8227dac:	1800241e 	bne	r3,zero,8227e40 <bsd_i_sockoptlen+0x100>
 8227db0:	10c00448 	cmpgei	r3,r2,17
 8227db4:	1800031e 	bne	r3,zero,8227dc4 <bsd_i_sockoptlen+0x84>
 8227db8:	10800388 	cmpgei	r2,r2,14
 8227dbc:	10002a1e 	bne	r2,zero,8227e68 <bsd_i_sockoptlen+0x128>
 8227dc0:	00002506 	br	8227e58 <bsd_i_sockoptlen+0x118>
 8227dc4:	10800820 	cmpeqi	r2,r2,32
 8227dc8:	10001d1e 	bne	r2,zero,8227e40 <bsd_i_sockoptlen+0x100>
 8227dcc:	00002606 	br	8227e68 <bsd_i_sockoptlen+0x128>
 8227dd0:	10c401c8 	cmpgei	r3,r2,4103
 8227dd4:	18000a1e 	bne	r3,zero,8227e00 <bsd_i_sockoptlen+0xc0>
 8227dd8:	10c40148 	cmpgei	r3,r2,4101
 8227ddc:	1800161e 	bne	r3,zero,8227e38 <bsd_i_sockoptlen+0xf8>
 8227de0:	10c04020 	cmpeqi	r3,r2,256
 8227de4:	1800161e 	bne	r3,zero,8227e40 <bsd_i_sockoptlen+0x100>
 8227de8:	10c04010 	cmplti	r3,r2,256
 8227dec:	18001e1e 	bne	r3,zero,8227e68 <bsd_i_sockoptlen+0x128>
 8227df0:	10bbffc4 	addi	r2,r2,-4097
 8227df4:	108000a8 	cmpgeui	r2,r2,2
 8227df8:	10001b1e 	bne	r2,zero,8227e68 <bsd_i_sockoptlen+0x128>
 8227dfc:	00001006 	br	8227e40 <bsd_i_sockoptlen+0x100>
 8227e00:	10c40588 	cmpgei	r3,r2,4118
 8227e04:	1800051e 	bne	r3,zero,8227e1c <bsd_i_sockoptlen+0xdc>
 8227e08:	10c40508 	cmpgei	r3,r2,4116
 8227e0c:	1800061e 	bne	r3,zero,8227e28 <bsd_i_sockoptlen+0xe8>
 8227e10:	10840248 	cmpgei	r2,r2,4105
 8227e14:	1000141e 	bne	r2,zero,8227e68 <bsd_i_sockoptlen+0x128>
 8227e18:	00000906 	br	8227e40 <bsd_i_sockoptlen+0x100>
 8227e1c:	108405a0 	cmpeqi	r2,r2,4118
 8227e20:	1000071e 	bne	r2,zero,8227e40 <bsd_i_sockoptlen+0x100>
 8227e24:	00001006 	br	8227e68 <bsd_i_sockoptlen+0x128>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 8227e28:	0005883a 	mov	r2,zero
 8227e2c:	00000f06 	br	8227e6c <bsd_i_sockoptlen+0x12c>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 8227e30:	00800204 	movi	r2,8
 8227e34:	00000d06 	br	8227e6c <bsd_i_sockoptlen+0x12c>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 8227e38:	00800084 	movi	r2,2
 8227e3c:	00000b06 	br	8227e6c <bsd_i_sockoptlen+0x12c>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 8227e40:	00800104 	movi	r2,4
 8227e44:	00000906 	br	8227e6c <bsd_i_sockoptlen+0x12c>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 8227e48:	00800104 	movi	r2,4
 8227e4c:	00000706 	br	8227e6c <bsd_i_sockoptlen+0x12c>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 8227e50:	00800044 	movi	r2,1
 8227e54:	00000506 	br	8227e6c <bsd_i_sockoptlen+0x12c>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 8227e58:	00800204 	movi	r2,8
 8227e5c:	00000306 	br	8227e6c <bsd_i_sockoptlen+0x12c>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 8227e60:	00800104 	movi	r2,4
 8227e64:	00000106 	br	8227e6c <bsd_i_sockoptlen+0x12c>
   default:
      /* we don't know what type these options are */
      return 0;
 8227e68:	0005883a 	mov	r2,zero
   }
   
}
 8227e6c:	e037883a 	mov	sp,fp
 8227e70:	df000017 	ldw	fp,0(sp)
 8227e74:	dec00104 	addi	sp,sp,4
 8227e78:	f800283a 	ret

08227e7c <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 8227e7c:	defff504 	addi	sp,sp,-44
 8227e80:	dfc00a15 	stw	ra,40(sp)
 8227e84:	df000915 	stw	fp,36(sp)
 8227e88:	df000904 	addi	fp,sp,36
 8227e8c:	e13ffc15 	stw	r4,-16(fp)
 8227e90:	e17ffd15 	stw	r5,-12(fp)
 8227e94:	e1bffe15 	stw	r6,-8(fp)
 8227e98:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 8227e9c:	e0bffc17 	ldw	r2,-16(fp)
 8227ea0:	10bff804 	addi	r2,r2,-32
 8227ea4:	1085883a 	add	r2,r2,r2
 8227ea8:	1085883a 	add	r2,r2,r2
 8227eac:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8227eb0:	008209b4 	movhi	r2,2086
 8227eb4:	10b87704 	addi	r2,r2,-7716
 8227eb8:	e0bff815 	stw	r2,-32(fp)
 8227ebc:	00000606 	br	8227ed8 <bsd_getsockopt+0x5c>
 8227ec0:	e0fff817 	ldw	r3,-32(fp)
 8227ec4:	e0bff917 	ldw	r2,-28(fp)
 8227ec8:	18800626 	beq	r3,r2,8227ee4 <bsd_getsockopt+0x68>
 8227ecc:	e0bff817 	ldw	r2,-32(fp)
 8227ed0:	10800017 	ldw	r2,0(r2)
 8227ed4:	e0bff815 	stw	r2,-32(fp)
 8227ed8:	e0bff817 	ldw	r2,-32(fp)
 8227edc:	103ff81e 	bne	r2,zero,8227ec0 <bsd_getsockopt+0x44>
 8227ee0:	00000106 	br	8227ee8 <bsd_getsockopt+0x6c>
 8227ee4:	0001883a 	nop
 8227ee8:	e0fff817 	ldw	r3,-32(fp)
 8227eec:	e0bff917 	ldw	r2,-28(fp)
 8227ef0:	18800326 	beq	r3,r2,8227f00 <bsd_getsockopt+0x84>
 8227ef4:	822d2e00 	call	822d2e0 <dtrap>
 8227ef8:	00bfffc4 	movi	r2,-1
 8227efc:	00001d06 	br	8227f74 <bsd_getsockopt+0xf8>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 8227f00:	e17ffe17 	ldw	r5,-8(fp)
 8227f04:	e13ffd17 	ldw	r4,-12(fp)
 8227f08:	8227d400 	call	8227d40 <bsd_i_sockoptlen>
 8227f0c:	e0bffa15 	stw	r2,-24(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 8227f10:	e0800217 	ldw	r2,8(fp)
 8227f14:	10000426 	beq	r2,zero,8227f28 <bsd_getsockopt+0xac>
 8227f18:	e0800217 	ldw	r2,8(fp)
 8227f1c:	10c00017 	ldw	r3,0(r2)
 8227f20:	e0bffa17 	ldw	r2,-24(fp)
 8227f24:	1880050e 	bge	r3,r2,8227f3c <bsd_getsockopt+0xc0>
   {
      so->so_error = EFAULT;
 8227f28:	e0bff917 	ldw	r2,-28(fp)
 8227f2c:	00c00384 	movi	r3,14
 8227f30:	10c00615 	stw	r3,24(r2)
      return -1;
 8227f34:	00bfffc4 	movi	r2,-1
 8227f38:	00000e06 	br	8227f74 <bsd_getsockopt+0xf8>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 8227f3c:	e0bffa17 	ldw	r2,-24(fp)
 8227f40:	d8800015 	stw	r2,0(sp)
 8227f44:	e1ffff17 	ldw	r7,-4(fp)
 8227f48:	e1bffe17 	ldw	r6,-8(fp)
 8227f4c:	e17ffd17 	ldw	r5,-12(fp)
 8227f50:	e13ffc17 	ldw	r4,-16(fp)
 8227f54:	8230d1c0 	call	8230d1c <t_getsockopt>
 8227f58:	e0bffb15 	stw	r2,-20(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 8227f5c:	e0bffb17 	ldw	r2,-20(fp)
 8227f60:	1000031e 	bne	r2,zero,8227f70 <bsd_getsockopt+0xf4>
   {
      *optlen = loptlen;
 8227f64:	e0800217 	ldw	r2,8(fp)
 8227f68:	e0fffa17 	ldw	r3,-24(fp)
 8227f6c:	10c00015 	stw	r3,0(r2)
   }

   return e;
 8227f70:	e0bffb17 	ldw	r2,-20(fp)
   
}
 8227f74:	e037883a 	mov	sp,fp
 8227f78:	dfc00117 	ldw	ra,4(sp)
 8227f7c:	df000017 	ldw	fp,0(sp)
 8227f80:	dec00204 	addi	sp,sp,8
 8227f84:	f800283a 	ret

08227f88 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 8227f88:	defff504 	addi	sp,sp,-44
 8227f8c:	dfc00815 	stw	ra,32(sp)
 8227f90:	df000715 	stw	fp,28(sp)
 8227f94:	df000704 	addi	fp,sp,28
 8227f98:	e13ffe15 	stw	r4,-8(fp)
 8227f9c:	e17fff15 	stw	r5,-4(fp)
 8227fa0:	e1800215 	stw	r6,8(fp)
 8227fa4:	e1c00315 	stw	r7,12(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 8227fa8:	e0bffe17 	ldw	r2,-8(fp)
 8227fac:	10bff804 	addi	r2,r2,-32
 8227fb0:	1085883a 	add	r2,r2,r2
 8227fb4:	1085883a 	add	r2,r2,r2
 8227fb8:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 8227fbc:	008209b4 	movhi	r2,2086
 8227fc0:	10b87704 	addi	r2,r2,-7716
 8227fc4:	e0bffa15 	stw	r2,-24(fp)
 8227fc8:	00000606 	br	8227fe4 <bsd_ioctl+0x5c>
 8227fcc:	e0fffa17 	ldw	r3,-24(fp)
 8227fd0:	e0bffb17 	ldw	r2,-20(fp)
 8227fd4:	18800626 	beq	r3,r2,8227ff0 <bsd_ioctl+0x68>
 8227fd8:	e0bffa17 	ldw	r2,-24(fp)
 8227fdc:	10800017 	ldw	r2,0(r2)
 8227fe0:	e0bffa15 	stw	r2,-24(fp)
 8227fe4:	e0bffa17 	ldw	r2,-24(fp)
 8227fe8:	103ff81e 	bne	r2,zero,8227fcc <bsd_ioctl+0x44>
 8227fec:	00000106 	br	8227ff4 <bsd_ioctl+0x6c>
 8227ff0:	0001883a 	nop
 8227ff4:	e0fffa17 	ldw	r3,-24(fp)
 8227ff8:	e0bffb17 	ldw	r2,-20(fp)
 8227ffc:	18800326 	beq	r3,r2,822800c <bsd_ioctl+0x84>
 8228000:	822d2e00 	call	822d2e0 <dtrap>
 8228004:	00bfffc4 	movi	r2,-1
 8228008:	00001706 	br	8228068 <bsd_ioctl+0xe0>

   va_start(argptr, request);
 822800c:	e0800204 	addi	r2,fp,8
 8228010:	e0bffc15 	stw	r2,-16(fp)

   switch (request)
 8228014:	e0bfff17 	ldw	r2,-4(fp)
 8228018:	108405a0 	cmpeqi	r2,r2,4118
 822801c:	10000e26 	beq	r2,zero,8228058 <bsd_ioctl+0xd0>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 8228020:	e0bffc17 	ldw	r2,-16(fp)
 8228024:	10c00104 	addi	r3,r2,4
 8228028:	e0fffc15 	stw	r3,-16(fp)
 822802c:	10800017 	ldw	r2,0(r2)
 8228030:	e0bffd15 	stw	r2,-12(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 8228034:	e0fffd04 	addi	r3,fp,-12
 8228038:	00800104 	movi	r2,4
 822803c:	d8800015 	stw	r2,0(sp)
 8228040:	180f883a 	mov	r7,r3
 8228044:	01840584 	movi	r6,4118
 8228048:	017fffc4 	movi	r5,-1
 822804c:	e13ffe17 	ldw	r4,-8(fp)
 8228050:	8230b5c0 	call	8230b5c <t_setsockopt>
 8228054:	00000406 	br	8228068 <bsd_ioctl+0xe0>
   default:
      so->so_error = EINVAL;
 8228058:	e0bffb17 	ldw	r2,-20(fp)
 822805c:	00c00584 	movi	r3,22
 8228060:	10c00615 	stw	r3,24(r2)
      return -1;
 8228064:	00bfffc4 	movi	r2,-1
   }
}
 8228068:	e037883a 	mov	sp,fp
 822806c:	dfc00117 	ldw	ra,4(sp)
 8228070:	df000017 	ldw	fp,0(sp)
 8228074:	dec00404 	addi	sp,sp,16
 8228078:	f800283a 	ret

0822807c <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 822807c:	defffd04 	addi	sp,sp,-12
 8228080:	dfc00215 	stw	ra,8(sp)
 8228084:	df000115 	stw	fp,4(sp)
 8228088:	df000104 	addi	fp,sp,4
 822808c:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 8228090:	e0bfff17 	ldw	r2,-4(fp)
 8228094:	1009883a 	mov	r4,r2
 8228098:	82287400 	call	8228740 <print_ipad>
}
 822809c:	e037883a 	mov	sp,fp
 82280a0:	dfc00117 	ldw	ra,4(sp)
 82280a4:	df000017 	ldw	fp,0(sp)
 82280a8:	dec00204 	addi	sp,sp,8
 82280ac:	f800283a 	ret

082280b0 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 82280b0:	defff004 	addi	sp,sp,-64
 82280b4:	dfc00f15 	stw	ra,60(sp)
 82280b8:	df000e15 	stw	fp,56(sp)
 82280bc:	df000e04 	addi	fp,sp,56
 82280c0:	e13ffc15 	stw	r4,-16(fp)
 82280c4:	e17ffd15 	stw	r5,-12(fp)
 82280c8:	e1bffe15 	stw	r6,-8(fp)
 82280cc:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 82280d0:	e03ffb15 	stw	zero,-20(fp)
   int lret;

   so = LONG2SO(s);
 82280d4:	e0bffc17 	ldw	r2,-16(fp)
 82280d8:	10bff804 	addi	r2,r2,-32
 82280dc:	1085883a 	add	r2,r2,r2
 82280e0:	1085883a 	add	r2,r2,r2
 82280e4:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 82280e8:	008209b4 	movhi	r2,2086
 82280ec:	10b87704 	addi	r2,r2,-7716
 82280f0:	e0bff415 	stw	r2,-48(fp)
 82280f4:	00000606 	br	8228110 <bsd_recvfrom+0x60>
 82280f8:	e0fff417 	ldw	r3,-48(fp)
 82280fc:	e0bff517 	ldw	r2,-44(fp)
 8228100:	18800626 	beq	r3,r2,822811c <bsd_recvfrom+0x6c>
 8228104:	e0bff417 	ldw	r2,-48(fp)
 8228108:	10800017 	ldw	r2,0(r2)
 822810c:	e0bff415 	stw	r2,-48(fp)
 8228110:	e0bff417 	ldw	r2,-48(fp)
 8228114:	103ff81e 	bne	r2,zero,82280f8 <bsd_recvfrom+0x48>
 8228118:	00000106 	br	8228120 <bsd_recvfrom+0x70>
 822811c:	0001883a 	nop
 8228120:	e0fff417 	ldw	r3,-48(fp)
 8228124:	e0bff517 	ldw	r2,-44(fp)
 8228128:	18800326 	beq	r3,r2,8228138 <bsd_recvfrom+0x88>
 822812c:	822d2e00 	call	822d2e0 <dtrap>
 8228130:	00bfffc4 	movi	r2,-1
 8228134:	00002b06 	br	82281e4 <bsd_recvfrom+0x134>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 8228138:	e0800217 	ldw	r2,8(fp)
 822813c:	10000a26 	beq	r2,zero,8228168 <bsd_recvfrom+0xb8>
   {
      if (fromlen == NULL)
 8228140:	e0800317 	ldw	r2,12(fp)
 8228144:	1000051e 	bne	r2,zero,822815c <bsd_recvfrom+0xac>
      {
         so->so_error = EFAULT;
 8228148:	e0bff517 	ldw	r2,-44(fp)
 822814c:	00c00384 	movi	r3,14
 8228150:	10c00615 	stw	r3,24(r2)
         return -1;
 8228154:	00bfffc4 	movi	r2,-1
 8228158:	00002206 	br	82281e4 <bsd_recvfrom+0x134>
      }
      lfromlen = *fromlen;
 822815c:	e0800317 	ldw	r2,12(fp)
 8228160:	10800017 	ldw	r2,0(r2)
 8228164:	e0bffb15 	stw	r2,-20(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 8228168:	e0bffb04 	addi	r2,fp,-20
 822816c:	d8800115 	stw	r2,4(sp)
 8228170:	e0bff704 	addi	r2,fp,-36
 8228174:	d8800015 	stw	r2,0(sp)
 8228178:	e1ffff17 	ldw	r7,-4(fp)
 822817c:	e1bffe17 	ldw	r6,-8(fp)
 8228180:	e17ffd17 	ldw	r5,-12(fp)
 8228184:	e13ffc17 	ldw	r4,-16(fp)
 8228188:	8230f880 	call	8230f88 <t_recvfrom>
 822818c:	e0bff615 	stw	r2,-40(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 8228190:	e0bff617 	ldw	r2,-40(fp)
 8228194:	10bfffe0 	cmpeqi	r2,r2,-1
 8228198:	1000111e 	bne	r2,zero,82281e0 <bsd_recvfrom+0x130>
 822819c:	e0800217 	ldw	r2,8(fp)
 82281a0:	10000f26 	beq	r2,zero,82281e0 <bsd_recvfrom+0x130>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 82281a4:	e0bffb17 	ldw	r2,-20(fp)
 82281a8:	10800470 	cmpltui	r2,r2,17
 82281ac:	1000021e 	bne	r2,zero,82281b8 <bsd_recvfrom+0x108>
         lfromlen = sizeof(struct sockaddr_in);
 82281b0:	00800404 	movi	r2,16
 82281b4:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 82281b8:	e0bffb17 	ldw	r2,-20(fp)
 82281bc:	1007883a 	mov	r3,r2
 82281c0:	e0bff704 	addi	r2,fp,-36
 82281c4:	180d883a 	mov	r6,r3
 82281c8:	100b883a 	mov	r5,r2
 82281cc:	e1000217 	ldw	r4,8(fp)
 82281d0:	8202c5c0 	call	8202c5c <memcpy>
      *fromlen = lfromlen;
 82281d4:	e0fffb17 	ldw	r3,-20(fp)
 82281d8:	e0800317 	ldw	r2,12(fp)
 82281dc:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 82281e0:	e0bff617 	ldw	r2,-40(fp)
}
 82281e4:	e037883a 	mov	sp,fp
 82281e8:	dfc00117 	ldw	ra,4(sp)
 82281ec:	df000017 	ldw	fp,0(sp)
 82281f0:	dec00204 	addi	sp,sp,8
 82281f4:	f800283a 	ret

082281f8 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 82281f8:	defff804 	addi	sp,sp,-32
 82281fc:	dfc00715 	stw	ra,28(sp)
 8228200:	df000615 	stw	fp,24(sp)
 8228204:	df000604 	addi	fp,sp,24
 8228208:	e13ffc15 	stw	r4,-16(fp)
 822820c:	e17ffd15 	stw	r5,-12(fp)
 8228210:	e1bffe15 	stw	r6,-8(fp)
 8228214:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 8228218:	e0800217 	ldw	r2,8(fp)
 822821c:	10004b26 	beq	r2,zero,822834c <bsd_select+0x154>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 8228220:	00801904 	movi	r2,100
 8228224:	e0bffb15 	stw	r2,-20(fp)
      if (tps >= 1000)
 8228228:	e0bffb17 	ldw	r2,-20(fp)
 822822c:	1080fa10 	cmplti	r2,r2,1000
 8228230:	10000e1e 	bne	r2,zero,822826c <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 8228234:	e0800217 	ldw	r2,8(fp)
 8228238:	10800117 	ldw	r2,4(r2)
 822823c:	10800c84 	addi	r2,r2,50
 8228240:	01401904 	movi	r5,100
 8228244:	1009883a 	mov	r4,r2
 8228248:	82028640 	call	8202864 <__divsi3>
 822824c:	1007883a 	mov	r3,r2
 8228250:	e0bffb17 	ldw	r2,-20(fp)
 8228254:	1885383a 	mul	r2,r3,r2
 8228258:	0149c404 	movi	r5,10000
 822825c:	1009883a 	mov	r4,r2
 8228260:	82028640 	call	8202864 <__divsi3>
 8228264:	e0bffa15 	stw	r2,-24(fp)
 8228268:	00003106 	br	8228330 <bsd_select+0x138>
      }
      else if (tps >= 100)
 822826c:	e0bffb17 	ldw	r2,-20(fp)
 8228270:	10801910 	cmplti	r2,r2,100
 8228274:	10000e1e 	bne	r2,zero,82282b0 <bsd_select+0xb8>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 8228278:	e0800217 	ldw	r2,8(fp)
 822827c:	10800117 	ldw	r2,4(r2)
 8228280:	10807d04 	addi	r2,r2,500
 8228284:	0140fa04 	movi	r5,1000
 8228288:	1009883a 	mov	r4,r2
 822828c:	82028640 	call	8202864 <__divsi3>
 8228290:	1007883a 	mov	r3,r2
 8228294:	e0bffb17 	ldw	r2,-20(fp)
 8228298:	1885383a 	mul	r2,r3,r2
 822829c:	0140fa04 	movi	r5,1000
 82282a0:	1009883a 	mov	r4,r2
 82282a4:	82028640 	call	8202864 <__divsi3>
 82282a8:	e0bffa15 	stw	r2,-24(fp)
 82282ac:	00002006 	br	8228330 <bsd_select+0x138>
      }
      else if (tps >= 10)
 82282b0:	e0bffb17 	ldw	r2,-20(fp)
 82282b4:	10800290 	cmplti	r2,r2,10
 82282b8:	10000e1e 	bne	r2,zero,82282f4 <bsd_select+0xfc>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 82282bc:	e0800217 	ldw	r2,8(fp)
 82282c0:	10800117 	ldw	r2,4(r2)
 82282c4:	1084e204 	addi	r2,r2,5000
 82282c8:	0149c404 	movi	r5,10000
 82282cc:	1009883a 	mov	r4,r2
 82282d0:	82028640 	call	8202864 <__divsi3>
 82282d4:	1007883a 	mov	r3,r2
 82282d8:	e0bffb17 	ldw	r2,-20(fp)
 82282dc:	1885383a 	mul	r2,r3,r2
 82282e0:	01401904 	movi	r5,100
 82282e4:	1009883a 	mov	r4,r2
 82282e8:	82028640 	call	8202864 <__divsi3>
 82282ec:	e0bffa15 	stw	r2,-24(fp)
 82282f0:	00000f06 	br	8228330 <bsd_select+0x138>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 82282f4:	e0800217 	ldw	r2,8(fp)
 82282f8:	10c00117 	ldw	r3,4(r2)
 82282fc:	00b0d414 	movui	r2,50000
 8228300:	1885883a 	add	r2,r3,r2
 8228304:	014000b4 	movhi	r5,2
 8228308:	2961a804 	addi	r5,r5,-31072
 822830c:	1009883a 	mov	r4,r2
 8228310:	82028640 	call	8202864 <__divsi3>
 8228314:	1007883a 	mov	r3,r2
 8228318:	e0bffb17 	ldw	r2,-20(fp)
 822831c:	1885383a 	mul	r2,r3,r2
 8228320:	01400284 	movi	r5,10
 8228324:	1009883a 	mov	r4,r2
 8228328:	82028640 	call	8202864 <__divsi3>
 822832c:	e0bffa15 	stw	r2,-24(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 8228330:	e0800217 	ldw	r2,8(fp)
 8228334:	10800017 	ldw	r2,0(r2)
 8228338:	10801924 	muli	r2,r2,100
 822833c:	e0fffa17 	ldw	r3,-24(fp)
 8228340:	1885883a 	add	r2,r3,r2
 8228344:	e0bffa15 	stw	r2,-24(fp)
 8228348:	00000206 	br	8228354 <bsd_select+0x15c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 822834c:	00bfffc4 	movi	r2,-1
 8228350:	e0bffa15 	stw	r2,-24(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 8228354:	e1fffa17 	ldw	r7,-24(fp)
 8228358:	e1bfff17 	ldw	r6,-4(fp)
 822835c:	e17ffe17 	ldw	r5,-8(fp)
 8228360:	e13ffd17 	ldw	r4,-12(fp)
 8228364:	8234a400 	call	8234a40 <t_select>
}
 8228368:	e037883a 	mov	sp,fp
 822836c:	dfc00117 	ldw	ra,4(sp)
 8228370:	df000017 	ldw	fp,0(sp)
 8228374:	dec00204 	addi	sp,sp,8
 8228378:	f800283a 	ret

0822837c <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 822837c:	defff704 	addi	sp,sp,-36
 8228380:	dfc00815 	stw	ra,32(sp)
 8228384:	df000715 	stw	fp,28(sp)
 8228388:	df000704 	addi	fp,sp,28
 822838c:	e13ffc15 	stw	r4,-16(fp)
 8228390:	e17ffd15 	stw	r5,-12(fp)
 8228394:	e1bffe15 	stw	r6,-8(fp)
 8228398:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;

   so = LONG2SO(s);
 822839c:	e0bffc17 	ldw	r2,-16(fp)
 82283a0:	10bff804 	addi	r2,r2,-32
 82283a4:	1085883a 	add	r2,r2,r2
 82283a8:	1085883a 	add	r2,r2,r2
 82283ac:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82283b0:	008209b4 	movhi	r2,2086
 82283b4:	10b87704 	addi	r2,r2,-7716
 82283b8:	e0bffa15 	stw	r2,-24(fp)
 82283bc:	00000606 	br	82283d8 <bsd_setsockopt+0x5c>
 82283c0:	e0fffa17 	ldw	r3,-24(fp)
 82283c4:	e0bffb17 	ldw	r2,-20(fp)
 82283c8:	18800626 	beq	r3,r2,82283e4 <bsd_setsockopt+0x68>
 82283cc:	e0bffa17 	ldw	r2,-24(fp)
 82283d0:	10800017 	ldw	r2,0(r2)
 82283d4:	e0bffa15 	stw	r2,-24(fp)
 82283d8:	e0bffa17 	ldw	r2,-24(fp)
 82283dc:	103ff81e 	bne	r2,zero,82283c0 <bsd_setsockopt+0x44>
 82283e0:	00000106 	br	82283e8 <bsd_setsockopt+0x6c>
 82283e4:	0001883a 	nop
 82283e8:	e0fffa17 	ldw	r3,-24(fp)
 82283ec:	e0bffb17 	ldw	r2,-20(fp)
 82283f0:	18800326 	beq	r3,r2,8228400 <bsd_setsockopt+0x84>
 82283f4:	822d2e00 	call	822d2e0 <dtrap>
 82283f8:	00bfffc4 	movi	r2,-1
 82283fc:	00001206 	br	8228448 <bsd_setsockopt+0xcc>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 8228400:	e17ffe17 	ldw	r5,-8(fp)
 8228404:	e13ffd17 	ldw	r4,-12(fp)
 8228408:	8227d400 	call	8227d40 <bsd_i_sockoptlen>
 822840c:	1007883a 	mov	r3,r2
 8228410:	e0800217 	ldw	r2,8(fp)
 8228414:	10c0050e 	bge	r2,r3,822842c <bsd_setsockopt+0xb0>
   {
      so->so_error = EFAULT;
 8228418:	e0bffb17 	ldw	r2,-20(fp)
 822841c:	00c00384 	movi	r3,14
 8228420:	10c00615 	stw	r3,24(r2)
      return -1;
 8228424:	00bfffc4 	movi	r2,-1
 8228428:	00000706 	br	8228448 <bsd_setsockopt+0xcc>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 822842c:	e0800217 	ldw	r2,8(fp)
 8228430:	d8800015 	stw	r2,0(sp)
 8228434:	e1ffff17 	ldw	r7,-4(fp)
 8228438:	e1bffe17 	ldw	r6,-8(fp)
 822843c:	e17ffd17 	ldw	r5,-12(fp)
 8228440:	e13ffc17 	ldw	r4,-16(fp)
 8228444:	8230b5c0 	call	8230b5c <t_setsockopt>
}
 8228448:	e037883a 	mov	sp,fp
 822844c:	dfc00117 	ldw	ra,4(sp)
 8228450:	df000017 	ldw	fp,0(sp)
 8228454:	dec00204 	addi	sp,sp,8
 8228458:	f800283a 	ret

0822845c <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 822845c:	defffa04 	addi	sp,sp,-24
 8228460:	df000515 	stw	fp,20(sp)
 8228464:	df000504 	addi	fp,sp,20
 8228468:	e13ffe15 	stw	r4,-8(fp)
 822846c:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 8228470:	e0bffe17 	ldw	r2,-8(fp)
 8228474:	e0bffb15 	stw	r2,-20(fp)
   unsigned long sum = 0;
 8228478:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 822847c:	e0bfff17 	ldw	r2,-4(fp)
 8228480:	e0bffd15 	stw	r2,-12(fp)

   while (--count >= 0)
 8228484:	00000806 	br	82284a8 <ccksum+0x4c>
   {
      /*  This is the inner loop */
      sum += *addr++;
 8228488:	e0bffb17 	ldw	r2,-20(fp)
 822848c:	10c00084 	addi	r3,r2,2
 8228490:	e0fffb15 	stw	r3,-20(fp)
 8228494:	1080000b 	ldhu	r2,0(r2)
 8228498:	10bfffcc 	andi	r2,r2,65535
 822849c:	e0fffc17 	ldw	r3,-16(fp)
 82284a0:	1885883a 	add	r2,r3,r2
 82284a4:	e0bffc15 	stw	r2,-16(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 82284a8:	e0bffd17 	ldw	r2,-12(fp)
 82284ac:	10bfffc4 	addi	r2,r2,-1
 82284b0:	e0bffd15 	stw	r2,-12(fp)
 82284b4:	e0bffd17 	ldw	r2,-12(fp)
 82284b8:	103ff30e 	bge	r2,zero,8228488 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 82284bc:	e0bffc17 	ldw	r2,-16(fp)
 82284c0:	10ffffcc 	andi	r3,r2,65535
 82284c4:	e0bffc17 	ldw	r2,-16(fp)
 82284c8:	1004d43a 	srli	r2,r2,16
 82284cc:	1885883a 	add	r2,r3,r2
 82284d0:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 82284d4:	e0bffc17 	ldw	r2,-16(fp)
 82284d8:	10ffffcc 	andi	r3,r2,65535
 82284dc:	e0bffc17 	ldw	r2,-16(fp)
 82284e0:	1004d43a 	srli	r2,r2,16
 82284e4:	1885883a 	add	r2,r3,r2
 82284e8:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 82284ec:	e0bffc17 	ldw	r2,-16(fp)
}
 82284f0:	e037883a 	mov	sp,fp
 82284f4:	df000017 	ldw	fp,0(sp)
 82284f8:	dec00104 	addi	sp,sp,4
 82284fc:	f800283a 	ret

08228500 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 8228500:	defffc04 	addi	sp,sp,-16
 8228504:	dfc00315 	stw	ra,12(sp)
 8228508:	df000215 	stw	fp,8(sp)
 822850c:	df000204 	addi	fp,sp,8
 8228510:	e13ffe15 	stw	r4,-8(fp)
 8228514:	e17fff15 	stw	r5,-4(fp)
   switch (cksum_select)
 8228518:	d0a03117 	ldw	r2,-32572(gp)
 822851c:	108000a0 	cmpeqi	r2,r2,2
 8228520:	1000041e 	bne	r2,zero,8228534 <cksum+0x34>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 8228524:	e17fff17 	ldw	r5,-4(fp)
 8228528:	e13ffe17 	ldw	r4,-8(fp)
 822852c:	822845c0 	call	822845c <ccksum>
 8228530:	00000306 	br	8228540 <cksum+0x40>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 8228534:	e17fff17 	ldw	r5,-4(fp)
 8228538:	e13ffe17 	ldw	r4,-8(fp)
 822853c:	822d14c0 	call	822d14c <asm_cksum>
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 8228540:	e037883a 	mov	sp,fp
 8228544:	dfc00117 	ldw	ra,4(sp)
 8228548:	df000017 	ldw	fp,0(sp)
 822854c:	dec00204 	addi	sp,sp,8
 8228550:	f800283a 	ret

08228554 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 8228554:	defffe04 	addi	sp,sp,-8
 8228558:	dfc00115 	stw	ra,4(sp)
 822855c:	df000015 	stw	fp,0(sp)
 8228560:	d839883a 	mov	fp,sp
   dtrap();
 8228564:	822d2e00 	call	822d2e0 <dtrap>
   return 0;
 8228568:	0005883a 	mov	r2,zero
}
 822856c:	e037883a 	mov	sp,fp
 8228570:	dfc00117 	ldw	ra,4(sp)
 8228574:	df000017 	ldw	fp,0(sp)
 8228578:	dec00204 	addi	sp,sp,8
 822857c:	f800283a 	ret

08228580 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 8228580:	defffe04 	addi	sp,sp,-8
 8228584:	df000115 	stw	fp,4(sp)
 8228588:	df000104 	addi	fp,sp,4
 822858c:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 8228590:	00000306 	br	82285a0 <nextarg+0x20>
 8228594:	e0bfff17 	ldw	r2,-4(fp)
 8228598:	10800044 	addi	r2,r2,1
 822859c:	e0bfff15 	stw	r2,-4(fp)
 82285a0:	e0bfff17 	ldw	r2,-4(fp)
 82285a4:	10800003 	ldbu	r2,0(r2)
 82285a8:	10803fcc 	andi	r2,r2,255
 82285ac:	1080201c 	xori	r2,r2,128
 82285b0:	10bfe004 	addi	r2,r2,-128
 82285b4:	10800848 	cmpgei	r2,r2,33
 82285b8:	103ff61e 	bne	r2,zero,8228594 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 82285bc:	00000306 	br	82285cc <nextarg+0x4c>
 82285c0:	e0bfff17 	ldw	r2,-4(fp)
 82285c4:	10800044 	addi	r2,r2,1
 82285c8:	e0bfff15 	stw	r2,-4(fp)
 82285cc:	e0bfff17 	ldw	r2,-4(fp)
 82285d0:	10800003 	ldbu	r2,0(r2)
 82285d4:	10803fcc 	andi	r2,r2,255
 82285d8:	1080201c 	xori	r2,r2,128
 82285dc:	10bfe004 	addi	r2,r2,-128
 82285e0:	10800820 	cmpeqi	r2,r2,32
 82285e4:	103ff61e 	bne	r2,zero,82285c0 <nextarg+0x40>
      return (argp);
 82285e8:	e0bfff17 	ldw	r2,-4(fp)
}
 82285ec:	e037883a 	mov	sp,fp
 82285f0:	df000017 	ldw	fp,0(sp)
 82285f4:	dec00104 	addi	sp,sp,4
 82285f8:	f800283a 	ret

082285fc <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 82285fc:	defff804 	addi	sp,sp,-32
 8228600:	dfc00715 	stw	ra,28(sp)
 8228604:	df000615 	stw	fp,24(sp)
 8228608:	df000604 	addi	fp,sp,24
 822860c:	e13ffd15 	stw	r4,-12(fp)
 8228610:	e17ffe15 	stw	r5,-8(fp)
 8228614:	e1bfff15 	stw	r6,-4(fp)
   u_char * data  =  (u_char *)buffer;
 8228618:	e0bffe17 	ldw	r2,-8(fp)
 822861c:	e0bffa15 	stw	r2,-24(fp)
   unsigned int count;
   char  c;

   while (len)
 8228620:	00003f06 	br	8228720 <hexdump+0x124>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228624:	e03ffb15 	stw	zero,-20(fp)
 8228628:	00000d06 	br	8228660 <hexdump+0x64>
         ns_printf(pio, "%02x ", *(data + count));
 822862c:	e0fffa17 	ldw	r3,-24(fp)
 8228630:	e0bffb17 	ldw	r2,-20(fp)
 8228634:	1885883a 	add	r2,r3,r2
 8228638:	10800003 	ldbu	r2,0(r2)
 822863c:	10803fcc 	andi	r2,r2,255
 8228640:	100d883a 	mov	r6,r2
 8228644:	01420974 	movhi	r5,2085
 8228648:	29409304 	addi	r5,r5,588
 822864c:	e13ffd17 	ldw	r4,-12(fp)
 8228650:	8228bac0 	call	8228bac <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228654:	e0bffb17 	ldw	r2,-20(fp)
 8228658:	10800044 	addi	r2,r2,1
 822865c:	e0bffb15 	stw	r2,-20(fp)
 8228660:	e0bffb17 	ldw	r2,-20(fp)
 8228664:	10800428 	cmpgeui	r2,r2,16
 8228668:	1000031e 	bne	r2,zero,8228678 <hexdump+0x7c>
 822866c:	e0fffb17 	ldw	r3,-20(fp)
 8228670:	e0bfff17 	ldw	r2,-4(fp)
 8228674:	18bfed36 	bltu	r3,r2,822862c <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228678:	e03ffb15 	stw	zero,-20(fp)
 822867c:	00001606 	br	82286d8 <hexdump+0xdc>
      {
         c = *(data + count);
 8228680:	e0fffa17 	ldw	r3,-24(fp)
 8228684:	e0bffb17 	ldw	r2,-20(fp)
 8228688:	1885883a 	add	r2,r3,r2
 822868c:	10800003 	ldbu	r2,0(r2)
 8228690:	e0bffc05 	stb	r2,-16(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 8228694:	e0bffc07 	ldb	r2,-16(fp)
 8228698:	10800810 	cmplti	r2,r2,32
 822869c:	1000051e 	bne	r2,zero,82286b4 <hexdump+0xb8>
 82286a0:	e0bffc07 	ldb	r2,-16(fp)
 82286a4:	10801fe0 	cmpeqi	r2,r2,127
 82286a8:	1000021e 	bne	r2,zero,82286b4 <hexdump+0xb8>
 82286ac:	e0bffc07 	ldb	r2,-16(fp)
 82286b0:	00000106 	br	82286b8 <hexdump+0xbc>
 82286b4:	00800b84 	movi	r2,46
 82286b8:	100d883a 	mov	r6,r2
 82286bc:	01420974 	movhi	r5,2085
 82286c0:	29409504 	addi	r5,r5,596
 82286c4:	e13ffd17 	ldw	r4,-12(fp)
 82286c8:	8228bac0 	call	8228bac <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 82286cc:	e0bffb17 	ldw	r2,-20(fp)
 82286d0:	10800044 	addi	r2,r2,1
 82286d4:	e0bffb15 	stw	r2,-20(fp)
 82286d8:	e0bffb17 	ldw	r2,-20(fp)
 82286dc:	10800428 	cmpgeui	r2,r2,16
 82286e0:	1000031e 	bne	r2,zero,82286f0 <hexdump+0xf4>
 82286e4:	e0fffb17 	ldw	r3,-20(fp)
 82286e8:	e0bfff17 	ldw	r2,-4(fp)
 82286ec:	18bfe436 	bltu	r3,r2,8228680 <hexdump+0x84>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 82286f0:	01420974 	movhi	r5,2085
 82286f4:	29409604 	addi	r5,r5,600
 82286f8:	e13ffd17 	ldw	r4,-12(fp)
 82286fc:	8228bac0 	call	8228bac <ns_printf>
      len -= count;
 8228700:	e0ffff17 	ldw	r3,-4(fp)
 8228704:	e0bffb17 	ldw	r2,-20(fp)
 8228708:	1885c83a 	sub	r2,r3,r2
 822870c:	e0bfff15 	stw	r2,-4(fp)
      data += count;
 8228710:	e0fffa17 	ldw	r3,-24(fp)
 8228714:	e0bffb17 	ldw	r2,-20(fp)
 8228718:	1885883a 	add	r2,r3,r2
 822871c:	e0bffa15 	stw	r2,-24(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 8228720:	e0bfff17 	ldw	r2,-4(fp)
 8228724:	103fbf1e 	bne	r2,zero,8228624 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 8228728:	0001883a 	nop
 822872c:	e037883a 	mov	sp,fp
 8228730:	dfc00117 	ldw	ra,4(sp)
 8228734:	df000017 	ldw	fp,0(sp)
 8228738:	dec00204 	addi	sp,sp,8
 822873c:	f800283a 	ret

08228740 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 8228740:	defffa04 	addi	sp,sp,-24
 8228744:	dfc00515 	stw	ra,20(sp)
 8228748:	df000415 	stw	fp,16(sp)
 822874c:	df000404 	addi	fp,sp,16
 8228750:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 8228754:	e0bfff17 	ldw	r2,-4(fp)
 8228758:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
    ip.ip.ipchar[0],
 822875c:	e0bffe03 	ldbu	r2,-8(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228760:	11003fcc 	andi	r4,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
 8228764:	e0bffe43 	ldbu	r2,-7(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228768:	11403fcc 	andi	r5,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
 822876c:	e0bffe83 	ldbu	r2,-6(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228770:	10803fcc 	andi	r2,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);
 8228774:	e0fffec3 	ldbu	r3,-5(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228778:	18c03fcc 	andi	r3,r3,255
 822877c:	d8c00115 	stw	r3,4(sp)
 8228780:	d8800015 	stw	r2,0(sp)
 8228784:	280f883a 	mov	r7,r5
 8228788:	200d883a 	mov	r6,r4
 822878c:	01420974 	movhi	r5,2085
 8228790:	29409704 	addi	r5,r5,604
 8228794:	010209b4 	movhi	r4,2086
 8228798:	21375b84 	addi	r4,r4,-8850
 822879c:	82034640 	call	8203464 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 82287a0:	008209b4 	movhi	r2,2086
 82287a4:	10b75b84 	addi	r2,r2,-8850
}
 82287a8:	e037883a 	mov	sp,fp
 82287ac:	dfc00117 	ldw	ra,4(sp)
 82287b0:	df000017 	ldw	fp,0(sp)
 82287b4:	dec00204 	addi	sp,sp,8
 82287b8:	f800283a 	ret

082287bc <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 82287bc:	defff004 	addi	sp,sp,-64
 82287c0:	dfc00f15 	stw	ra,60(sp)
 82287c4:	df000e15 	stw	fp,56(sp)
 82287c8:	ddc00d15 	stw	r23,52(sp)
 82287cc:	dd800c15 	stw	r22,48(sp)
 82287d0:	dd400b15 	stw	r21,44(sp)
 82287d4:	dd000a15 	stw	r20,40(sp)
 82287d8:	dcc00915 	stw	r19,36(sp)
 82287dc:	dc800815 	stw	r18,32(sp)
 82287e0:	dc400715 	stw	r17,28(sp)
 82287e4:	dc000615 	stw	r16,24(sp)
 82287e8:	df000e04 	addi	fp,sp,56
 82287ec:	e13ff715 	stw	r4,-36(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 82287f0:	e0fff717 	ldw	r3,-36(fp)
 82287f4:	00947b34 	movhi	r2,20972
 82287f8:	10a147c4 	addi	r2,r2,-31457
 82287fc:	1888383a 	mulxuu	r4,r3,r2
 8228800:	1885383a 	mul	r2,r3,r2
 8228804:	100b883a 	mov	r5,r2
 8228808:	200d883a 	mov	r6,r4
 822880c:	3004d17a 	srli	r2,r6,5
 8228810:	e0bff715 	stw	r2,-36(fp)
   seconds = (unsigned)(timetick%60);
 8228814:	e0bff717 	ldw	r2,-36(fp)
 8228818:	01400f04 	movi	r5,60
 822881c:	1009883a 	mov	r4,r2
 8228820:	82029c00 	call	82029c0 <__umodsi3>
 8228824:	e0bff415 	stw	r2,-48(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 8228828:	e0fff717 	ldw	r3,-36(fp)
 822882c:	00a22274 	movhi	r2,34953
 8228830:	10a22244 	addi	r2,r2,-30583
 8228834:	1888383a 	mulxuu	r4,r3,r2
 8228838:	1885383a 	mul	r2,r3,r2
 822883c:	102d883a 	mov	r22,r2
 8228840:	202f883a 	mov	r23,r4
 8228844:	b804d17a 	srli	r2,r23,5
 8228848:	e0bff715 	stw	r2,-36(fp)
   minutes = (unsigned)(timetick%60);
 822884c:	e0fff717 	ldw	r3,-36(fp)
 8228850:	00a22274 	movhi	r2,34953
 8228854:	10a22244 	addi	r2,r2,-30583
 8228858:	1888383a 	mulxuu	r4,r3,r2
 822885c:	1885383a 	mul	r2,r3,r2
 8228860:	1029883a 	mov	r20,r2
 8228864:	202b883a 	mov	r21,r4
 8228868:	a804d17a 	srli	r2,r21,5
 822886c:	10800f24 	muli	r2,r2,60
 8228870:	1885c83a 	sub	r2,r3,r2
 8228874:	e0bff515 	stw	r2,-44(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 8228878:	e0fff717 	ldw	r3,-36(fp)
 822887c:	00a22274 	movhi	r2,34953
 8228880:	10a22244 	addi	r2,r2,-30583
 8228884:	1888383a 	mulxuu	r4,r3,r2
 8228888:	1885383a 	mul	r2,r3,r2
 822888c:	1025883a 	mov	r18,r2
 8228890:	2027883a 	mov	r19,r4
 8228894:	9804d17a 	srli	r2,r19,5
 8228898:	e0bff715 	stw	r2,-36(fp)
   hours = (unsigned)(timetick%24);
 822889c:	e0bff717 	ldw	r2,-36(fp)
 82288a0:	01400604 	movi	r5,24
 82288a4:	1009883a 	mov	r4,r2
 82288a8:	82029c00 	call	82029c0 <__umodsi3>
 82288ac:	e0bff615 	stw	r2,-40(fp)
   timetick = timetick/24;    /* turn timetick into days */
 82288b0:	e0fff717 	ldw	r3,-36(fp)
 82288b4:	00aaaaf4 	movhi	r2,43691
 82288b8:	10aaaac4 	addi	r2,r2,-21845
 82288bc:	1888383a 	mulxuu	r4,r3,r2
 82288c0:	1885383a 	mul	r2,r3,r2
 82288c4:	1021883a 	mov	r16,r2
 82288c8:	2023883a 	mov	r17,r4
 82288cc:	8804d13a 	srli	r2,r17,4
 82288d0:	e0bff715 	stw	r2,-36(fp)

   if (timetick)  /* Is there a whole number of days? */
 82288d4:	e0bff717 	ldw	r2,-36(fp)
 82288d8:	10000c26 	beq	r2,zero,822890c <print_uptime+0x150>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 82288dc:	e0bff417 	ldw	r2,-48(fp)
 82288e0:	d8800115 	stw	r2,4(sp)
 82288e4:	e0bff517 	ldw	r2,-44(fp)
 82288e8:	d8800015 	stw	r2,0(sp)
 82288ec:	e1fff617 	ldw	r7,-40(fp)
 82288f0:	e1bff717 	ldw	r6,-36(fp)
 82288f4:	01420974 	movhi	r5,2085
 82288f8:	29409a04 	addi	r5,r5,616
 82288fc:	01020974 	movhi	r4,2085
 8228900:	21112804 	addi	r4,r4,17568
 8228904:	82034640 	call	8203464 <sprintf>
 8228908:	00001306 	br	8228958 <print_uptime+0x19c>
    timetick, hours, minutes, seconds);
   else if (hours)
 822890c:	e0bff617 	ldw	r2,-40(fp)
 8228910:	10000a26 	beq	r2,zero,822893c <print_uptime+0x180>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 8228914:	e0bff417 	ldw	r2,-48(fp)
 8228918:	d8800015 	stw	r2,0(sp)
 822891c:	e1fff517 	ldw	r7,-44(fp)
 8228920:	e1bff617 	ldw	r6,-40(fp)
 8228924:	01420974 	movhi	r5,2085
 8228928:	2940a004 	addi	r5,r5,640
 822892c:	01020974 	movhi	r4,2085
 8228930:	21112804 	addi	r4,r4,17568
 8228934:	82034640 	call	8203464 <sprintf>
 8228938:	00000706 	br	8228958 <print_uptime+0x19c>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 822893c:	e1fff417 	ldw	r7,-48(fp)
 8228940:	e1bff517 	ldw	r6,-44(fp)
 8228944:	01420974 	movhi	r5,2085
 8228948:	2940a504 	addi	r5,r5,660
 822894c:	01020974 	movhi	r4,2085
 8228950:	21112804 	addi	r4,r4,17568
 8228954:	82034640 	call	8203464 <sprintf>
   return tistring;
 8228958:	00820974 	movhi	r2,2085
 822895c:	10912804 	addi	r2,r2,17568
}
 8228960:	e6fff804 	addi	sp,fp,-32
 8228964:	dfc00917 	ldw	ra,36(sp)
 8228968:	df000817 	ldw	fp,32(sp)
 822896c:	ddc00717 	ldw	r23,28(sp)
 8228970:	dd800617 	ldw	r22,24(sp)
 8228974:	dd400517 	ldw	r21,20(sp)
 8228978:	dd000417 	ldw	r20,16(sp)
 822897c:	dcc00317 	ldw	r19,12(sp)
 8228980:	dc800217 	ldw	r18,8(sp)
 8228984:	dc400117 	ldw	r17,4(sp)
 8228988:	dc000017 	ldw	r16,0(sp)
 822898c:	dec00a04 	addi	sp,sp,40
 8228990:	f800283a 	ret

08228994 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 8228994:	defffd04 	addi	sp,sp,-12
 8228998:	dfc00215 	stw	ra,8(sp)
 822899c:	df000115 	stw	fp,4(sp)
 82289a0:	df000104 	addi	fp,sp,4
 82289a4:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 82289a8:	e17fff17 	ldw	r5,-4(fp)
 82289ac:	01020974 	movhi	r4,2085
 82289b0:	2100aa04 	addi	r4,r4,680
 82289b4:	82030ec0 	call	82030ec <printf>
   dtrap();                   /* try to hook debugger */
 82289b8:	822d2e00 	call	822d2e0 <dtrap>
   netexit(1);                /* try to clean up */
 82289bc:	01000044 	movi	r4,1
 82289c0:	82439d80 	call	82439d8 <netexit>
}
 82289c4:	0001883a 	nop
 82289c8:	e037883a 	mov	sp,fp
 82289cc:	dfc00117 	ldw	ra,4(sp)
 82289d0:	df000017 	ldw	fp,0(sp)
 82289d4:	dec00204 	addi	sp,sp,8
 82289d8:	f800283a 	ret

082289dc <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 82289dc:	defffb04 	addi	sp,sp,-20
 82289e0:	df000415 	stw	fp,16(sp)
 82289e4:	df000404 	addi	fp,sp,16
 82289e8:	e13ffe15 	stw	r4,-8(fp)
 82289ec:	2805883a 	mov	r2,r5
 82289f0:	e0bfff05 	stb	r2,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 82289f4:	008209b4 	movhi	r2,2086
 82289f8:	10b75704 	addi	r2,r2,-8868
 82289fc:	e0bffd15 	stw	r2,-12(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228a00:	e03ffc15 	stw	zero,-16(fp)
 8228a04:	00003f06 	br	8228b04 <print_eth+0x128>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 8228a08:	e0bffe17 	ldw	r2,-8(fp)
 8228a0c:	10800003 	ldbu	r2,0(r2)
 8228a10:	10803fcc 	andi	r2,r2,255
 8228a14:	1004d13a 	srli	r2,r2,4
 8228a18:	10800c04 	addi	r2,r2,48
 8228a1c:	1007883a 	mov	r3,r2
 8228a20:	e0bffd17 	ldw	r2,-12(fp)
 8228a24:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228a28:	e0bffd17 	ldw	r2,-12(fp)
 8228a2c:	10800003 	ldbu	r2,0(r2)
 8228a30:	10803fcc 	andi	r2,r2,255
 8228a34:	1080201c 	xori	r2,r2,128
 8228a38:	10bfe004 	addi	r2,r2,-128
 8228a3c:	10800e90 	cmplti	r2,r2,58
 8228a40:	1000061e 	bne	r2,zero,8228a5c <print_eth+0x80>
         (*out) += 7;
 8228a44:	e0bffd17 	ldw	r2,-12(fp)
 8228a48:	10800003 	ldbu	r2,0(r2)
 8228a4c:	108001c4 	addi	r2,r2,7
 8228a50:	1007883a 	mov	r3,r2
 8228a54:	e0bffd17 	ldw	r2,-12(fp)
 8228a58:	10c00005 	stb	r3,0(r2)
      out++;
 8228a5c:	e0bffd17 	ldw	r2,-12(fp)
 8228a60:	10800044 	addi	r2,r2,1
 8228a64:	e0bffd15 	stw	r2,-12(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 8228a68:	e0bffe17 	ldw	r2,-8(fp)
 8228a6c:	10800003 	ldbu	r2,0(r2)
 8228a70:	108003cc 	andi	r2,r2,15
 8228a74:	10800c04 	addi	r2,r2,48
 8228a78:	1007883a 	mov	r3,r2
 8228a7c:	e0bffd17 	ldw	r2,-12(fp)
 8228a80:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228a84:	e0bffd17 	ldw	r2,-12(fp)
 8228a88:	10800003 	ldbu	r2,0(r2)
 8228a8c:	10803fcc 	andi	r2,r2,255
 8228a90:	1080201c 	xori	r2,r2,128
 8228a94:	10bfe004 	addi	r2,r2,-128
 8228a98:	10800e90 	cmplti	r2,r2,58
 8228a9c:	1000061e 	bne	r2,zero,8228ab8 <print_eth+0xdc>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 8228aa0:	e0bffd17 	ldw	r2,-12(fp)
 8228aa4:	10800003 	ldbu	r2,0(r2)
 8228aa8:	108001c4 	addi	r2,r2,7
 8228aac:	1007883a 	mov	r3,r2
 8228ab0:	e0bffd17 	ldw	r2,-12(fp)
 8228ab4:	10c00005 	stb	r3,0(r2)
      out++;
 8228ab8:	e0bffd17 	ldw	r2,-12(fp)
 8228abc:	10800044 	addi	r2,r2,1
 8228ac0:	e0bffd15 	stw	r2,-12(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 8228ac4:	e0bfff07 	ldb	r2,-4(fp)
 8228ac8:	10000826 	beq	r2,zero,8228aec <print_eth+0x110>
 8228acc:	e0bffc17 	ldw	r2,-16(fp)
 8228ad0:	10800148 	cmpgei	r2,r2,5
 8228ad4:	1000051e 	bne	r2,zero,8228aec <print_eth+0x110>
         *out++ = spacer;
 8228ad8:	e0bffd17 	ldw	r2,-12(fp)
 8228adc:	10c00044 	addi	r3,r2,1
 8228ae0:	e0fffd15 	stw	r3,-12(fp)
 8228ae4:	e0ffff03 	ldbu	r3,-4(fp)
 8228ae8:	10c00005 	stb	r3,0(r2)
      addr++;
 8228aec:	e0bffe17 	ldw	r2,-8(fp)
 8228af0:	10800044 	addi	r2,r2,1
 8228af4:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228af8:	e0bffc17 	ldw	r2,-16(fp)
 8228afc:	10800044 	addi	r2,r2,1
 8228b00:	e0bffc15 	stw	r2,-16(fp)
 8228b04:	e0bffc17 	ldw	r2,-16(fp)
 8228b08:	10800190 	cmplti	r2,r2,6
 8228b0c:	103fbe1e 	bne	r2,zero,8228a08 <print_eth+0x2c>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 8228b10:	e0bffd17 	ldw	r2,-12(fp)
 8228b14:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 8228b18:	008209b4 	movhi	r2,2086
 8228b1c:	10b75704 	addi	r2,r2,-8868
}
 8228b20:	e037883a 	mov	sp,fp
 8228b24:	df000017 	ldw	fp,0(sp)
 8228b28:	dec00104 	addi	sp,sp,4
 8228b2c:	f800283a 	ret

08228b30 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 8228b30:	defffd04 	addi	sp,sp,-12
 8228b34:	df000215 	stw	fp,8(sp)
 8228b38:	df000204 	addi	fp,sp,8
 8228b3c:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 8228b40:	e0bfff17 	ldw	r2,-4(fp)
 8228b44:	e0bffe15 	stw	r2,-8(fp)
 8228b48:	00000d06 	br	8228b80 <uslash+0x50>
      if (*cp == '\\')
 8228b4c:	e0bffe17 	ldw	r2,-8(fp)
 8228b50:	10800003 	ldbu	r2,0(r2)
 8228b54:	10803fcc 	andi	r2,r2,255
 8228b58:	1080201c 	xori	r2,r2,128
 8228b5c:	10bfe004 	addi	r2,r2,-128
 8228b60:	10801718 	cmpnei	r2,r2,92
 8228b64:	1000031e 	bne	r2,zero,8228b74 <uslash+0x44>
      *cp = '/';
 8228b68:	e0bffe17 	ldw	r2,-8(fp)
 8228b6c:	00c00bc4 	movi	r3,47
 8228b70:	10c00005 	stb	r3,0(r2)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 8228b74:	e0bffe17 	ldw	r2,-8(fp)
 8228b78:	10800044 	addi	r2,r2,1
 8228b7c:	e0bffe15 	stw	r2,-8(fp)
 8228b80:	e0bffe17 	ldw	r2,-8(fp)
 8228b84:	10800003 	ldbu	r2,0(r2)
 8228b88:	10803fcc 	andi	r2,r2,255
 8228b8c:	1080201c 	xori	r2,r2,128
 8228b90:	10bfe004 	addi	r2,r2,-128
 8228b94:	103fed1e 	bne	r2,zero,8228b4c <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 8228b98:	e0bfff17 	ldw	r2,-4(fp)
}
 8228b9c:	e037883a 	mov	sp,fp
 8228ba0:	df000017 	ldw	fp,0(sp)
 8228ba4:	dec00104 	addi	sp,sp,4
 8228ba8:	f800283a 	ret

08228bac <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 8228bac:	defff304 	addi	sp,sp,-52
 8228bb0:	dfc00a15 	stw	ra,40(sp)
 8228bb4:	df000915 	stw	fp,36(sp)
 8228bb8:	dc400815 	stw	r17,32(sp)
 8228bbc:	dc000715 	stw	r16,28(sp)
 8228bc0:	df000904 	addi	fp,sp,36
 8228bc4:	e13ffc15 	stw	r4,-16(fp)
 8228bc8:	e17ffd15 	stw	r5,-12(fp)
 8228bcc:	e1800215 	stw	r6,8(fp)
 8228bd0:	e1c00315 	stw	r7,12(fp)
   char *   outbuf=NULL;
 8228bd4:	e03ff815 	stw	zero,-32(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 8228bd8:	00802704 	movi	r2,156
 8228bdc:	e0bff715 	stw	r2,-36(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228be0:	e0bffc17 	ldw	r2,-16(fp)
 8228be4:	e0bff915 	stw	r2,-28(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 8228be8:	e0bff917 	ldw	r2,-28(fp)
 8228bec:	1000091e 	bne	r2,zero,8228c14 <ns_printf+0x68>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 8228bf0:	e0800204 	addi	r2,fp,8
 8228bf4:	e0bffb15 	stw	r2,-20(fp)
      ret_value = vprintf(format,argList);
 8228bf8:	e0bffb17 	ldw	r2,-20(fp)
 8228bfc:	100b883a 	mov	r5,r2
 8228c00:	e13ffd17 	ldw	r4,-12(fp)
 8228c04:	824b8a40 	call	824b8a4 <vprintf>
 8228c08:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 8228c0c:	e0bffa17 	ldw	r2,-24(fp)
 8228c10:	00003b06 	br	8228d00 <ns_printf+0x154>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 8228c14:	e0bff917 	ldw	r2,-28(fp)
 8228c18:	10800117 	ldw	r2,4(r2)
 8228c1c:	1000021e 	bne	r2,zero,8228c28 <ns_printf+0x7c>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 8228c20:	00bfffc4 	movi	r2,-1
 8228c24:	00003606 	br	8228d00 <ns_printf+0x154>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 8228c28:	e13ffd17 	ldw	r4,-12(fp)
 8228c2c:	8203cac0 	call	8203cac <strlen>
 8228c30:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 8228c34:	e0bffa17 	ldw	r2,-24(fp)
 8228c38:	10802710 	cmplti	r2,r2,156
 8228c3c:	1000041e 	bne	r2,zero,8228c50 <ns_printf+0xa4>
   {
      buf_size += ret_value ;
 8228c40:	e0fff717 	ldw	r3,-36(fp)
 8228c44:	e0bffa17 	ldw	r2,-24(fp)
 8228c48:	1885883a 	add	r2,r3,r2
 8228c4c:	e0bff715 	stw	r2,-36(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 8228c50:	e0bff717 	ldw	r2,-36(fp)
 8228c54:	1009883a 	mov	r4,r2
 8228c58:	822deb80 	call	822deb8 <npalloc>
 8228c5c:	e0bff815 	stw	r2,-32(fp)

   if (outbuf == NULL)
 8228c60:	e0bff817 	ldw	r2,-32(fp)
 8228c64:	1000021e 	bne	r2,zero,8228c70 <ns_printf+0xc4>
   {
      return -2;
 8228c68:	00bfff84 	movi	r2,-2
 8228c6c:	00002406 	br	8228d00 <ns_printf+0x154>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 8228c70:	e0800204 	addi	r2,fp,8
 8228c74:	e0bffb15 	stw	r2,-20(fp)
   ret_value = vsprintf(outbuf,format,argList);
 8228c78:	e0bffb17 	ldw	r2,-20(fp)
 8228c7c:	100d883a 	mov	r6,r2
 8228c80:	e17ffd17 	ldw	r5,-12(fp)
 8228c84:	e13ff817 	ldw	r4,-32(fp)
 8228c88:	824b9200 	call	824b920 <vsprintf>
 8228c8c:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 8228c90:	e13ff817 	ldw	r4,-32(fp)
 8228c94:	8203cac0 	call	8203cac <strlen>
 8228c98:	1007883a 	mov	r3,r2
 8228c9c:	e0bff717 	ldw	r2,-36(fp)
 8228ca0:	10c0080e 	bge	r2,r3,8228cc4 <ns_printf+0x118>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 8228ca4:	01020974 	movhi	r4,2085
 8228ca8:	2100ad04 	addi	r4,r4,692
 8228cac:	82289940 	call	8228994 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 8228cb0:	e0bff717 	ldw	r2,-36(fp)
 8228cb4:	10bfffc4 	addi	r2,r2,-1
 8228cb8:	e0fff817 	ldw	r3,-32(fp)
 8228cbc:	1885883a 	add	r2,r3,r2
 8228cc0:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 8228cc4:	e0bff917 	ldw	r2,-28(fp)
 8228cc8:	14000117 	ldw	r16,4(r2)
 8228ccc:	e0bff917 	ldw	r2,-28(fp)
 8228cd0:	14400217 	ldw	r17,8(r2)
 8228cd4:	e13ff817 	ldw	r4,-32(fp)
 8228cd8:	8203cac0 	call	8203cac <strlen>
 8228cdc:	100d883a 	mov	r6,r2
 8228ce0:	e17ff817 	ldw	r5,-32(fp)
 8228ce4:	8809883a 	mov	r4,r17
 8228ce8:	803ee83a 	callr	r16
 8228cec:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 8228cf0:	e13ff817 	ldw	r4,-32(fp)
 8228cf4:	822deec0 	call	822deec <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 8228cf8:	82295580 	call	8229558 <tk_yield>

   return ret_value ;
 8228cfc:	e0bffa17 	ldw	r2,-24(fp)
}
 8228d00:	e6fffe04 	addi	sp,fp,-8
 8228d04:	dfc00317 	ldw	ra,12(sp)
 8228d08:	df000217 	ldw	fp,8(sp)
 8228d0c:	dc400117 	ldw	r17,4(sp)
 8228d10:	dc000017 	ldw	r16,0(sp)
 8228d14:	dec00604 	addi	sp,sp,24
 8228d18:	f800283a 	ret

08228d1c <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 8228d1c:	defffb04 	addi	sp,sp,-20
 8228d20:	dfc00415 	stw	ra,16(sp)
 8228d24:	df000315 	stw	fp,12(sp)
 8228d28:	df000304 	addi	fp,sp,12
 8228d2c:	e13ffd15 	stw	r4,-12(fp)
 8228d30:	e17ffe15 	stw	r5,-8(fp)
 8228d34:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 8228d38:	e17ffe17 	ldw	r5,-8(fp)
 8228d3c:	01020974 	movhi	r4,2085
 8228d40:	2100b404 	addi	r4,r4,720
 8228d44:	82030ec0 	call	82030ec <printf>
   USE_ARG(s);
   return len;
 8228d48:	e0bfff17 	ldw	r2,-4(fp)
}
 8228d4c:	e037883a 	mov	sp,fp
 8228d50:	dfc00117 	ldw	ra,4(sp)
 8228d54:	df000017 	ldw	fp,0(sp)
 8228d58:	dec00204 	addi	sp,sp,8
 8228d5c:	f800283a 	ret

08228d60 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 8228d60:	defffa04 	addi	sp,sp,-24
 8228d64:	dfc00515 	stw	ra,20(sp)
 8228d68:	df000415 	stw	fp,16(sp)
 8228d6c:	df000404 	addi	fp,sp,16
 8228d70:	e13ffe15 	stw	r4,-8(fp)
 8228d74:	e17fff15 	stw	r5,-4(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228d78:	e0bffe17 	ldw	r2,-8(fp)
 8228d7c:	e0bffc15 	stw	r2,-16(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 8228d80:	e0bfff17 	ldw	r2,-4(fp)
 8228d84:	01400504 	movi	r5,20
 8228d88:	1009883a 	mov	r4,r2
 8228d8c:	82028e80 	call	82028e8 <__modsi3>
 8228d90:	1000231e 	bne	r2,zero,8228e20 <con_page+0xc0>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 8228d94:	e0bffc17 	ldw	r2,-16(fp)
 8228d98:	10002126 	beq	r2,zero,8228e20 <con_page+0xc0>
 8228d9c:	e0bffc17 	ldw	r2,-16(fp)
 8228da0:	10800317 	ldw	r2,12(r2)
 8228da4:	10001e26 	beq	r2,zero,8228e20 <con_page+0xc0>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 8228da8:	01420974 	movhi	r5,2085
 8228dac:	2940b504 	addi	r5,r5,724
 8228db0:	e13ffc17 	ldw	r4,-16(fp)
 8228db4:	8228bac0 	call	8228bac <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 8228db8:	e0bffc17 	ldw	r2,-16(fp)
 8228dbc:	10800317 	ldw	r2,12(r2)
 8228dc0:	e0fffc17 	ldw	r3,-16(fp)
 8228dc4:	18c00217 	ldw	r3,8(r3)
 8228dc8:	1809883a 	mov	r4,r3
 8228dcc:	103ee83a 	callr	r2
 8228dd0:	e0bffd15 	stw	r2,-12(fp)
            if (ch == 0)
 8228dd4:	e0bffd17 	ldw	r2,-12(fp)
 8228dd8:	1000011e 	bne	r2,zero,8228de0 <con_page+0x80>
               tk_yield();    /* Give timeslice to other processes */
 8228ddc:	82295580 	call	8229558 <tk_yield>
         } while (ch == 0) ;
 8228de0:	e0bffd17 	ldw	r2,-12(fp)
 8228de4:	103ff426 	beq	r2,zero,8228db8 <con_page+0x58>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 8228de8:	e0bffd17 	ldw	r2,-12(fp)
 8228dec:	10bfffd8 	cmpnei	r2,r2,-1
 8228df0:	1000021e 	bne	r2,zero,8228dfc <con_page+0x9c>
            return 1 ;
 8228df4:	00800044 	movi	r2,1
 8228df8:	00000a06 	br	8228e24 <con_page+0xc4>

         ns_printf(pio,"\n");
 8228dfc:	01420974 	movhi	r5,2085
 8228e00:	29409604 	addi	r5,r5,600
 8228e04:	e13ffc17 	ldw	r4,-16(fp)
 8228e08:	8228bac0 	call	8228bac <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 8228e0c:	e0bffd17 	ldw	r2,-12(fp)
 8228e10:	108006d8 	cmpnei	r2,r2,27
 8228e14:	1000021e 	bne	r2,zero,8228e20 <con_page+0xc0>
            return 1 ;
 8228e18:	00800044 	movi	r2,1
 8228e1c:	00000106 	br	8228e24 <con_page+0xc4>
      }
   }
   return  0;
 8228e20:	0005883a 	mov	r2,zero
}
 8228e24:	e037883a 	mov	sp,fp
 8228e28:	dfc00117 	ldw	ra,4(sp)
 8228e2c:	df000017 	ldw	fp,0(sp)
 8228e30:	dec00204 	addi	sp,sp,8
 8228e34:	f800283a 	ret

08228e38 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 8228e38:	defff704 	addi	sp,sp,-36
 8228e3c:	dfc00815 	stw	ra,32(sp)
 8228e40:	df000715 	stw	fp,28(sp)
 8228e44:	df000704 	addi	fp,sp,28
 8228e48:	e13ffd15 	stw	r4,-12(fp)
 8228e4c:	e17ffe15 	stw	r5,-8(fp)
 8228e50:	e1bfff15 	stw	r6,-4(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 8228e54:	e0bffd17 	ldw	r2,-12(fp)
 8228e58:	e0bffa15 	stw	r2,-24(fp)
   char **pargv = NULL;
 8228e5c:	e03ffb15 	stw	zero,-20(fp)
   *pargc_index = 0;
 8228e60:	e0bfff17 	ldw	r2,-4(fp)
 8228e64:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 8228e68:	e0bffd17 	ldw	r2,-12(fp)
 8228e6c:	1000021e 	bne	r2,zero,8228e78 <parse_args+0x40>
   {
      return (NULL);
 8228e70:	0005883a 	mov	r2,zero
 8228e74:	00006c06 	br	8229028 <parse_args+0x1f0>
   }
   len = strlen(buf);
 8228e78:	e13ffd17 	ldw	r4,-12(fp)
 8228e7c:	8203cac0 	call	8203cac <strlen>
 8228e80:	e0bffc15 	stw	r2,-16(fp)
   if (len <= 0)
 8228e84:	e0bffc17 	ldw	r2,-16(fp)
 8228e88:	00800216 	blt	zero,r2,8228e94 <parse_args+0x5c>
   {
      return (NULL);
 8228e8c:	0005883a 	mov	r2,zero
 8228e90:	00006506 	br	8229028 <parse_args+0x1f0>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 8228e94:	e0bffe17 	ldw	r2,-8(fp)
 8228e98:	1085883a 	add	r2,r2,r2
 8228e9c:	1085883a 	add	r2,r2,r2
 8228ea0:	1009883a 	mov	r4,r2
 8228ea4:	822deb80 	call	822deb8 <npalloc>
 8228ea8:	e0bffb15 	stw	r2,-20(fp)
   if (pargv == NULL)
 8228eac:	e0bffb17 	ldw	r2,-20(fp)
 8228eb0:	1000051e 	bne	r2,zero,8228ec8 <parse_args+0x90>
   {
      return (NULL);
 8228eb4:	0005883a 	mov	r2,zero
 8228eb8:	00005b06 	br	8229028 <parse_args+0x1f0>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 8228ebc:	e0bffa17 	ldw	r2,-24(fp)
 8228ec0:	10800044 	addi	r2,r2,1
 8228ec4:	e0bffa15 	stw	r2,-24(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 8228ec8:	e0bffa17 	ldw	r2,-24(fp)
 8228ecc:	10800003 	ldbu	r2,0(r2)
 8228ed0:	10803fcc 	andi	r2,r2,255
 8228ed4:	1080201c 	xori	r2,r2,128
 8228ed8:	10bfe004 	addi	r2,r2,-128
 8228edc:	10800820 	cmpeqi	r2,r2,32
 8228ee0:	103ff61e 	bne	r2,zero,8228ebc <parse_args+0x84>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 8228ee4:	00003006 	br	8228fa8 <parse_args+0x170>
   {
      pargv[(*pargc_index)] = bp;
 8228ee8:	e0bfff17 	ldw	r2,-4(fp)
 8228eec:	10800017 	ldw	r2,0(r2)
 8228ef0:	1085883a 	add	r2,r2,r2
 8228ef4:	1085883a 	add	r2,r2,r2
 8228ef8:	1007883a 	mov	r3,r2
 8228efc:	e0bffb17 	ldw	r2,-20(fp)
 8228f00:	10c5883a 	add	r2,r2,r3
 8228f04:	e0fffa17 	ldw	r3,-24(fp)
 8228f08:	10c00015 	stw	r3,0(r2)
      (*pargc_index)++;
 8228f0c:	e0bfff17 	ldw	r2,-4(fp)
 8228f10:	10800017 	ldw	r2,0(r2)
 8228f14:	10c00044 	addi	r3,r2,1
 8228f18:	e0bfff17 	ldw	r2,-4(fp)
 8228f1c:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 8228f20:	00000306 	br	8228f30 <parse_args+0xf8>
      {
         bp++; 
 8228f24:	e0bffa17 	ldw	r2,-24(fp)
 8228f28:	10800044 	addi	r2,r2,1
 8228f2c:	e0bffa15 	stw	r2,-24(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 8228f30:	e0bffa17 	ldw	r2,-24(fp)
 8228f34:	10800003 	ldbu	r2,0(r2)
 8228f38:	10803fcc 	andi	r2,r2,255
 8228f3c:	1080201c 	xori	r2,r2,128
 8228f40:	10bfe004 	addi	r2,r2,-128
 8228f44:	10800820 	cmpeqi	r2,r2,32
 8228f48:	10000a1e 	bne	r2,zero,8228f74 <parse_args+0x13c>
 8228f4c:	e0bffa17 	ldw	r2,-24(fp)
 8228f50:	10800003 	ldbu	r2,0(r2)
 8228f54:	10803fcc 	andi	r2,r2,255
 8228f58:	1080201c 	xori	r2,r2,128
 8228f5c:	10bfe004 	addi	r2,r2,-128
 8228f60:	103ff01e 	bne	r2,zero,8228f24 <parse_args+0xec>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8228f64:	00000306 	br	8228f74 <parse_args+0x13c>
      {
         bp++; 
 8228f68:	e0bffa17 	ldw	r2,-24(fp)
 8228f6c:	10800044 	addi	r2,r2,1
 8228f70:	e0bffa15 	stw	r2,-24(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8228f74:	e0bffa17 	ldw	r2,-24(fp)
 8228f78:	10800003 	ldbu	r2,0(r2)
 8228f7c:	10803fcc 	andi	r2,r2,255
 8228f80:	1080201c 	xori	r2,r2,128
 8228f84:	10bfe004 	addi	r2,r2,-128
 8228f88:	10800818 	cmpnei	r2,r2,32
 8228f8c:	1000061e 	bne	r2,zero,8228fa8 <parse_args+0x170>
 8228f90:	e0bffa17 	ldw	r2,-24(fp)
 8228f94:	10800003 	ldbu	r2,0(r2)
 8228f98:	10803fcc 	andi	r2,r2,255
 8228f9c:	1080201c 	xori	r2,r2,128
 8228fa0:	10bfe004 	addi	r2,r2,-128
 8228fa4:	103ff01e 	bne	r2,zero,8228f68 <parse_args+0x130>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 8228fa8:	e0bffa17 	ldw	r2,-24(fp)
 8228fac:	10800003 	ldbu	r2,0(r2)
 8228fb0:	10803fcc 	andi	r2,r2,255
 8228fb4:	1080201c 	xori	r2,r2,128
 8228fb8:	10bfe004 	addi	r2,r2,-128
 8228fbc:	10000426 	beq	r2,zero,8228fd0 <parse_args+0x198>
 8228fc0:	e0bfff17 	ldw	r2,-4(fp)
 8228fc4:	10c00017 	ldw	r3,0(r2)
 8228fc8:	e0bffe17 	ldw	r2,-8(fp)
 8228fcc:	18bfc616 	blt	r3,r2,8228ee8 <parse_args+0xb0>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 8228fd0:	e03ff915 	stw	zero,-28(fp)
 8228fd4:	00001006 	br	8229018 <parse_args+0x1e0>
   {
      if (buf[i] == ' ')
 8228fd8:	e0bff917 	ldw	r2,-28(fp)
 8228fdc:	e0fffd17 	ldw	r3,-12(fp)
 8228fe0:	1885883a 	add	r2,r3,r2
 8228fe4:	10800003 	ldbu	r2,0(r2)
 8228fe8:	10803fcc 	andi	r2,r2,255
 8228fec:	1080201c 	xori	r2,r2,128
 8228ff0:	10bfe004 	addi	r2,r2,-128
 8228ff4:	10800818 	cmpnei	r2,r2,32
 8228ff8:	1000041e 	bne	r2,zero,822900c <parse_args+0x1d4>
         buf[i] = '\0';
 8228ffc:	e0bff917 	ldw	r2,-28(fp)
 8229000:	e0fffd17 	ldw	r3,-12(fp)
 8229004:	1885883a 	add	r2,r3,r2
 8229008:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 822900c:	e0bff917 	ldw	r2,-28(fp)
 8229010:	10800044 	addi	r2,r2,1
 8229014:	e0bff915 	stw	r2,-28(fp)
 8229018:	e0fff917 	ldw	r3,-28(fp)
 822901c:	e0bffc17 	ldw	r2,-16(fp)
 8229020:	18bfed16 	blt	r3,r2,8228fd8 <parse_args+0x1a0>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 8229024:	e0bffb17 	ldw	r2,-20(fp)
}
 8229028:	e037883a 	mov	sp,fp
 822902c:	dfc00117 	ldw	ra,4(sp)
 8229030:	df000017 	ldw	fp,0(sp)
 8229034:	dec00204 	addi	sp,sp,8
 8229038:	f800283a 	ret

0822903c <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 822903c:	defffc04 	addi	sp,sp,-16
 8229040:	dfc00315 	stw	ra,12(sp)
 8229044:	df000215 	stw	fp,8(sp)
 8229048:	df000204 	addi	fp,sp,8
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 822904c:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 8229050:	823d1040 	call	823d104 <prep_modules>
 8229054:	e0bfff15 	stw	r2,-4(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 8229058:	e03ffe15 	stw	zero,-8(fp)
 822905c:	00001a06 	br	82290c8 <netmain+0x8c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 8229060:	e0bffe17 	ldw	r2,-8(fp)
 8229064:	10c00624 	muli	r3,r2,24
 8229068:	00820974 	movhi	r2,2085
 822906c:	108dc404 	addi	r2,r2,14096
 8229070:	1885883a 	add	r2,r3,r2
 8229074:	1009883a 	mov	r4,r2
 8229078:	822d6a80 	call	822d6a8 <TK_NEWTASK>
 822907c:	e0bfff15 	stw	r2,-4(fp)
      if (e != 0)
 8229080:	e0bfff17 	ldw	r2,-4(fp)
 8229084:	10000d26 	beq	r2,zero,82290bc <netmain+0x80>
      {
         dprintf("task create error\n");
 8229088:	01020974 	movhi	r4,2085
 822908c:	2100c704 	addi	r4,r4,796
 8229090:	82033700 	call	8203370 <puts>
         panic((char *)&nettasks[i].name);
 8229094:	e0bffe17 	ldw	r2,-8(fp)
 8229098:	10800624 	muli	r2,r2,24
 822909c:	10c00104 	addi	r3,r2,4
 82290a0:	00820974 	movhi	r2,2085
 82290a4:	108dc404 	addi	r2,r2,14096
 82290a8:	1885883a 	add	r2,r3,r2
 82290ac:	1009883a 	mov	r4,r2
 82290b0:	82289940 	call	8228994 <panic>
         return -1;  /* compiler warnings */
 82290b4:	00bfffc4 	movi	r2,-1
 82290b8:	00001306 	br	8229108 <netmain+0xcc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 82290bc:	e0bffe17 	ldw	r2,-8(fp)
 82290c0:	10800044 	addi	r2,r2,1
 82290c4:	e0bffe15 	stw	r2,-8(fp)
 82290c8:	d0a03217 	ldw	r2,-32568(gp)
 82290cc:	e0fffe17 	ldw	r3,-8(fp)
 82290d0:	18bfe316 	blt	r3,r2,8229060 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 82290d4:	823d56c0 	call	823d56c <create_apptasks>
 82290d8:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0) 
 82290dc:	e0bfff17 	ldw	r2,-4(fp)
 82290e0:	10000826 	beq	r2,zero,8229104 <netmain+0xc8>
   {
      dprintf("task create error\n");
 82290e4:	01020974 	movhi	r4,2085
 82290e8:	2100c704 	addi	r4,r4,796
 82290ec:	82033700 	call	8203370 <puts>
      panic("netmain");
 82290f0:	01020974 	movhi	r4,2085
 82290f4:	2100cc04 	addi	r4,r4,816
 82290f8:	82289940 	call	8228994 <panic>
      return -1;  /* compiler warnings */
 82290fc:	00bfffc4 	movi	r2,-1
 8229100:	00000106 	br	8229108 <netmain+0xcc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 8229104:	0005883a 	mov	r2,zero
#endif
#endif   /* NO_INET_STACK */
}
 8229108:	e037883a 	mov	sp,fp
 822910c:	dfc00117 	ldw	ra,4(sp)
 8229110:	df000017 	ldw	fp,0(sp)
 8229114:	dec00204 	addi	sp,sp,8
 8229118:	f800283a 	ret

0822911c <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 822911c:	defffc04 	addi	sp,sp,-16
 8229120:	dfc00315 	stw	ra,12(sp)
 8229124:	df000215 	stw	fp,8(sp)
 8229128:	df000204 	addi	fp,sp,8
 822912c:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 8229130:	823cd640 	call	823cd64 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 8229134:	00800044 	movi	r2,1
 8229138:	d0a08c15 	stw	r2,-32208(gp)

   for (;;)
   {
      TK_NETRX_BLOCK();
 822913c:	d0a0ab17 	ldw	r2,-32084(gp)
 8229140:	e1bffe04 	addi	r6,fp,-8
 8229144:	01401904 	movi	r5,100
 8229148:	1009883a 	mov	r4,r2
 822914c:	8219e200 	call	8219e20 <OSSemPend>
 8229150:	e0bffe03 	ldbu	r2,-8(fp)
 8229154:	10803fcc 	andi	r2,r2,255
 8229158:	10000526 	beq	r2,zero,8229170 <tk_netmain+0x54>
 822915c:	e0bffe03 	ldbu	r2,-8(fp)
 8229160:	10803fcc 	andi	r2,r2,255
 8229164:	108002a0 	cmpeqi	r2,r2,10
 8229168:	1000011e 	bne	r2,zero,8229170 <tk_netmain+0x54>
 822916c:	822d2e00 	call	822d2e0 <dtrap>
      netmain_wakes++;  /* count wakeups */
 8229170:	d0a08a17 	ldw	r2,-32216(gp)
 8229174:	10800044 	addi	r2,r2,1
 8229178:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 822917c:	008209b4 	movhi	r2,2086
 8229180:	10b67504 	addi	r2,r2,-9772
 8229184:	10800217 	ldw	r2,8(r2)
 8229188:	103fec26 	beq	r2,zero,822913c <tk_netmain+0x20>
         pktdemux();
 822918c:	82260100 	call	8226010 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 8229190:	003fea06 	br	822913c <tk_netmain+0x20>

08229194 <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 8229194:	defffd04 	addi	sp,sp,-12
 8229198:	dfc00215 	stw	ra,8(sp)
 822919c:	df000115 	stw	fp,4(sp)
 82291a0:	df000104 	addi	fp,sp,4
 82291a4:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 82291a8:	00000306 	br	82291b8 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 82291ac:	822ba5c0 	call	822ba5c <dhc_second>
#endif
      TK_SLEEP(1);
 82291b0:	01000084 	movi	r4,2
 82291b4:	821bc240 	call	821bc24 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 82291b8:	d0a08c17 	ldw	r2,-32208(gp)
 82291bc:	103ffb26 	beq	r2,zero,82291ac <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 82291c0:	01000084 	movi	r4,2
 82291c4:	821bc240 	call	821bc24 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 82291c8:	d0a08b17 	ldw	r2,-32212(gp)
 82291cc:	10800044 	addi	r2,r2,1
 82291d0:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 82291d4:	823d1580 	call	823d158 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 82291d8:	003ff906 	br	82291c0 <tk_nettick+0x2c>

082291dc <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 82291dc:	defffe04 	addi	sp,sp,-8
 82291e0:	dfc00115 	stw	ra,4(sp)
 82291e4:	df000015 	stw	fp,0(sp)
 82291e8:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 82291ec:	01000084 	movi	r4,2
 82291f0:	821bc240 	call	821bc24 <OSTimeDly>
}
 82291f4:	0001883a 	nop
 82291f8:	e037883a 	mov	sp,fp
 82291fc:	dfc00117 	ldw	ra,4(sp)
 8229200:	df000017 	ldw	fp,0(sp)
 8229204:	dec00204 	addi	sp,sp,8
 8229208:	f800283a 	ret

0822920c <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 822920c:	defffc04 	addi	sp,sp,-16
 8229210:	dfc00315 	stw	ra,12(sp)
 8229214:	df000215 	stw	fp,8(sp)
 8229218:	df000204 	addi	fp,sp,8
 822921c:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 8229220:	e0bfff17 	ldw	r2,-4(fp)
 8229224:	10800003 	ldbu	r2,0(r2)
 8229228:	10803fcc 	andi	r2,r2,255
 822922c:	1009883a 	mov	r4,r2
 8229230:	821b5180 	call	821b518 <OSTaskResume>
 8229234:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 8229238:	e0bffe03 	ldbu	r2,-8(fp)
 822923c:	10000a26 	beq	r2,zero,8229268 <TK_OSTaskResume+0x5c>
 8229240:	e0bffe03 	ldbu	r2,-8(fp)
 8229244:	10801120 	cmpeqi	r2,r2,68
 8229248:	1000071e 	bne	r2,zero,8229268 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 822924c:	01020974 	movhi	r4,2085
 8229250:	2100ce04 	addi	r4,r4,824
 8229254:	82033700 	call	8203370 <puts>
      dtrap();
 8229258:	822d2e00 	call	822d2e0 <dtrap>
      panic("TK_OSTaskResume");      
 822925c:	01020974 	movhi	r4,2085
 8229260:	2100db04 	addi	r4,r4,876
 8229264:	82289940 	call	8228994 <panic>
   }
#endif
}
 8229268:	0001883a 	nop
 822926c:	e037883a 	mov	sp,fp
 8229270:	dfc00117 	ldw	ra,4(sp)
 8229274:	df000017 	ldw	fp,0(sp)
 8229278:	dec00204 	addi	sp,sp,8
 822927c:	f800283a 	ret

08229280 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 8229280:	defffb04 	addi	sp,sp,-20
 8229284:	dfc00415 	stw	ra,16(sp)
 8229288:	df000315 	stw	fp,12(sp)
 822928c:	df000304 	addi	fp,sp,12
 8229290:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229294:	e03ffd15 	stw	zero,-12(fp)
 8229298:	00004706 	br	82293b8 <tcp_sleep+0x138>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 822929c:	008209b4 	movhi	r2,2086
 82292a0:	10b82504 	addi	r2,r2,-8044
 82292a4:	e0fffd17 	ldw	r3,-12(fp)
 82292a8:	18c00324 	muli	r3,r3,12
 82292ac:	10c5883a 	add	r2,r2,r3
 82292b0:	10800104 	addi	r2,r2,4
 82292b4:	10800017 	ldw	r2,0(r2)
 82292b8:	10003c1e 	bne	r2,zero,82293ac <tcp_sleep+0x12c>
      {
         global_TCPwakeup_set[i].soc_event = event;
 82292bc:	008209b4 	movhi	r2,2086
 82292c0:	10b82504 	addi	r2,r2,-8044
 82292c4:	e0fffd17 	ldw	r3,-12(fp)
 82292c8:	18c00324 	muli	r3,r3,12
 82292cc:	10c5883a 	add	r2,r2,r3
 82292d0:	10800104 	addi	r2,r2,4
 82292d4:	e0ffff17 	ldw	r3,-4(fp)
 82292d8:	10c00015 	stw	r3,0(r2)
         global_TCPwakeup_set[i].ctick = cticks;
 82292dc:	d0e0a817 	ldw	r3,-32096(gp)
 82292e0:	008209b4 	movhi	r2,2086
 82292e4:	10b82504 	addi	r2,r2,-8044
 82292e8:	e13ffd17 	ldw	r4,-12(fp)
 82292ec:	21000324 	muli	r4,r4,12
 82292f0:	1105883a 	add	r2,r2,r4
 82292f4:	10c00015 	stw	r3,0(r2)
         if (i > global_TCPwakeup_setIndx)
 82292f8:	d0e0a717 	ldw	r3,-32100(gp)
 82292fc:	e0bffd17 	ldw	r2,-12(fp)
 8229300:	1880020e 	bge	r3,r2,822930c <tcp_sleep+0x8c>
            global_TCPwakeup_setIndx = i;
 8229304:	e0bffd17 	ldw	r2,-12(fp)
 8229308:	d0a0a715 	stw	r2,-32100(gp)

         tcp_sleep_count++;
 822930c:	d0a0a317 	ldw	r2,-32116(gp)
 8229310:	10800044 	addi	r2,r2,1
 8229314:	d0a0a315 	stw	r2,-32116(gp)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 8229318:	0009883a 	mov	r4,zero
 822931c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 8229320:	008209b4 	movhi	r2,2086
 8229324:	10b82504 	addi	r2,r2,-8044
 8229328:	e0fffd17 	ldw	r3,-12(fp)
 822932c:	18c00324 	muli	r3,r3,12
 8229330:	10c5883a 	add	r2,r2,r3
 8229334:	10800204 	addi	r2,r2,8
 8229338:	10800017 	ldw	r2,0(r2)
 822933c:	e0fffe04 	addi	r3,fp,-8
 8229340:	180d883a 	mov	r6,r3
 8229344:	01401904 	movi	r5,100
 8229348:	1009883a 	mov	r4,r2
 822934c:	8219e200 	call	8219e20 <OSSemPend>
         if (err == 10)
 8229350:	e0bffe03 	ldbu	r2,-8(fp)
 8229354:	10803fcc 	andi	r2,r2,255
 8229358:	10800298 	cmpnei	r2,r2,10
 822935c:	1000101e 	bne	r2,zero,82293a0 <tcp_sleep+0x120>
         {
            ++tcp_sleep_timeout;
 8229360:	d0a08e17 	ldw	r2,-32200(gp)
 8229364:	10800044 	addi	r2,r2,1
 8229368:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 822936c:	008209b4 	movhi	r2,2086
 8229370:	10b82504 	addi	r2,r2,-8044
 8229374:	e0fffd17 	ldw	r3,-12(fp)
 8229378:	18c00324 	muli	r3,r3,12
 822937c:	10c5883a 	add	r2,r2,r3
 8229380:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 8229384:	008209b4 	movhi	r2,2086
 8229388:	10b82504 	addi	r2,r2,-8044
 822938c:	e0fffd17 	ldw	r3,-12(fp)
 8229390:	18c00324 	muli	r3,r3,12
 8229394:	10c5883a 	add	r2,r2,r3
 8229398:	10800104 	addi	r2,r2,4
 822939c:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 82293a0:	0009883a 	mov	r4,zero
 82293a4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
 82293a8:	00000d06 	br	82293e0 <tcp_sleep+0x160>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82293ac:	e0bffd17 	ldw	r2,-12(fp)
 82293b0:	10800044 	addi	r2,r2,1
 82293b4:	e0bffd15 	stw	r2,-12(fp)
 82293b8:	e0bffd17 	ldw	r2,-12(fp)
 82293bc:	10800510 	cmplti	r2,r2,20
 82293c0:	103fb61e 	bne	r2,zero,822929c <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 82293c4:	e0bffd17 	ldw	r2,-12(fp)
 82293c8:	d0a0a715 	stw	r2,-32100(gp)

   UNLOCK_NET_RESOURCE(NET_RESID);
 82293cc:	0009883a 	mov	r4,zero
 82293d0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 82293d4:	82295580 	call	8229558 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 82293d8:	0009883a 	mov	r4,zero
 82293dc:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
}
 82293e0:	e037883a 	mov	sp,fp
 82293e4:	dfc00117 	ldw	ra,4(sp)
 82293e8:	df000017 	ldw	fp,0(sp)
 82293ec:	dec00204 	addi	sp,sp,8
 82293f0:	f800283a 	ret

082293f4 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 82293f4:	defffc04 	addi	sp,sp,-16
 82293f8:	dfc00315 	stw	ra,12(sp)
 82293fc:	df000215 	stw	fp,8(sp)
 8229400:	df000204 	addi	fp,sp,8
 8229404:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 8229408:	821533c0 	call	821533c <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 822940c:	e03ffe15 	stw	zero,-8(fp)
 8229410:	00002c06 	br	82294c4 <tcp_wakeup+0xd0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 8229414:	008209b4 	movhi	r2,2086
 8229418:	10b82504 	addi	r2,r2,-8044
 822941c:	e0fffe17 	ldw	r3,-8(fp)
 8229420:	18c00324 	muli	r3,r3,12
 8229424:	10c5883a 	add	r2,r2,r3
 8229428:	10800017 	ldw	r2,0(r2)
 822942c:	10002226 	beq	r2,zero,82294b8 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
 8229430:	008209b4 	movhi	r2,2086
 8229434:	10b82504 	addi	r2,r2,-8044
 8229438:	e0fffe17 	ldw	r3,-8(fp)
 822943c:	18c00324 	muli	r3,r3,12
 8229440:	10c5883a 	add	r2,r2,r3
 8229444:	10800104 	addi	r2,r2,4
 8229448:	10c00017 	ldw	r3,0(r2)

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 822944c:	e0bfff17 	ldw	r2,-4(fp)
 8229450:	1880191e 	bne	r3,r2,82294b8 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 8229454:	008209b4 	movhi	r2,2086
 8229458:	10b82504 	addi	r2,r2,-8044
 822945c:	e0fffe17 	ldw	r3,-8(fp)
 8229460:	18c00324 	muli	r3,r3,12
 8229464:	10c5883a 	add	r2,r2,r3
 8229468:	10800204 	addi	r2,r2,8
 822946c:	10800017 	ldw	r2,0(r2)
 8229470:	1009883a 	mov	r4,r2
 8229474:	821a1980 	call	821a198 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 8229478:	008209b4 	movhi	r2,2086
 822947c:	10b82504 	addi	r2,r2,-8044
 8229480:	e0fffe17 	ldw	r3,-8(fp)
 8229484:	18c00324 	muli	r3,r3,12
 8229488:	10c5883a 	add	r2,r2,r3
 822948c:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 8229490:	008209b4 	movhi	r2,2086
 8229494:	10b82504 	addi	r2,r2,-8044
 8229498:	e0fffe17 	ldw	r3,-8(fp)
 822949c:	18c00324 	muli	r3,r3,12
 82294a0:	10c5883a 	add	r2,r2,r3
 82294a4:	10800104 	addi	r2,r2,4
 82294a8:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 82294ac:	d0a0a417 	ldw	r2,-32112(gp)
 82294b0:	10800044 	addi	r2,r2,1
 82294b4:	d0a0a415 	stw	r2,-32112(gp)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82294b8:	e0bffe17 	ldw	r2,-8(fp)
 82294bc:	10800044 	addi	r2,r2,1
 82294c0:	e0bffe15 	stw	r2,-8(fp)
 82294c4:	e0bffe17 	ldw	r2,-8(fp)
 82294c8:	10800510 	cmplti	r2,r2,20
 82294cc:	103fd11e 	bne	r2,zero,8229414 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 82294d0:	82153c80 	call	82153c8 <OSSchedUnlock>
}
 82294d4:	0001883a 	nop
 82294d8:	e037883a 	mov	sp,fp
 82294dc:	dfc00117 	ldw	ra,4(sp)
 82294e0:	df000017 	ldw	fp,0(sp)
 82294e4:	dec00204 	addi	sp,sp,8
 82294e8:	f800283a 	ret

082294ec <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 82294ec:	deffe204 	addi	sp,sp,-120
 82294f0:	dfc01d15 	stw	ra,116(sp)
 82294f4:	df001c15 	stw	fp,112(sp)
 82294f8:	df001c04 	addi	fp,sp,112
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 82294fc:	e0bfe504 	addi	r2,fp,-108
 8229500:	100b883a 	mov	r5,r2
 8229504:	01003fc4 	movi	r4,255
 8229508:	821ba900 	call	821ba90 <OSTaskQuery>
 822950c:	e0bfe405 	stb	r2,-112(fp)

   if (err == OS_NO_ERR)
 8229510:	e0bfe403 	ldbu	r2,-112(fp)
 8229514:	1000041e 	bne	r2,zero,8229528 <TK_OSTaskQuery+0x3c>
   {
      task_prio = task_data.OSTCBPrio;
 8229518:	e0bff183 	ldbu	r2,-58(fp)
 822951c:	e0bfe445 	stb	r2,-111(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 8229520:	e0bfe443 	ldbu	r2,-111(fp)
 8229524:	00000706 	br	8229544 <TK_OSTaskQuery+0x58>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 8229528:	01020974 	movhi	r4,2085
 822952c:	2100df04 	addi	r4,r4,892
 8229530:	82030ec0 	call	82030ec <printf>
      panic("TK_OSTaskQuery");
 8229534:	01020974 	movhi	r4,2085
 8229538:	2100ec04 	addi	r4,r4,944
 822953c:	82289940 	call	8228994 <panic>
      return 0;
 8229540:	0005883a 	mov	r2,zero
   }
   
   return task_prio;
}
 8229544:	e037883a 	mov	sp,fp
 8229548:	dfc00117 	ldw	ra,4(sp)
 822954c:	df000017 	ldw	fp,0(sp)
 8229550:	dec00204 	addi	sp,sp,8
 8229554:	f800283a 	ret

08229558 <tk_yield>:



void
tk_yield(void)
{
 8229558:	defffe04 	addi	sp,sp,-8
 822955c:	dfc00115 	stw	ra,4(sp)
 8229560:	df000015 	stw	fp,0(sp)
 8229564:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 8229568:	01000044 	movi	r4,1
 822956c:	821bc240 	call	821bc24 <OSTimeDly>
}
 8229570:	0001883a 	nop
 8229574:	e037883a 	mov	sp,fp
 8229578:	dfc00117 	ldw	ra,4(sp)
 822957c:	df000017 	ldw	fp,0(sp)
 8229580:	dec00204 	addi	sp,sp,8
 8229584:	f800283a 	ret

08229588 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 8229588:	deffef04 	addi	sp,sp,-68
 822958c:	dfc01015 	stw	ra,64(sp)
 8229590:	df000f15 	stw	fp,60(sp)
 8229594:	df000f04 	addi	fp,sp,60
 8229598:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 822959c:	01420974 	movhi	r5,2085
 82295a0:	2940f004 	addi	r5,r5,960
 82295a4:	e13fff17 	ldw	r4,-4(fp)
 82295a8:	8228bac0 	call	8228bac <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 82295ac:	d0a07017 	ldw	r2,-32320(gp)
 82295b0:	100d883a 	mov	r6,r2
 82295b4:	01420974 	movhi	r5,2085
 82295b8:	2940f604 	addi	r5,r5,984
 82295bc:	e13fff17 	ldw	r4,-4(fp)
 82295c0:	8228bac0 	call	8228bac <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 82295c4:	01420974 	movhi	r5,2085
 82295c8:	2940fe04 	addi	r5,r5,1016
 82295cc:	e13fff17 	ldw	r4,-4(fp)
 82295d0:	8228bac0 	call	8228bac <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 82295d4:	e03ff215 	stw	zero,-56(fp)
 82295d8:	00005406 	br	822972c <tk_stats+0x1a4>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 82295dc:	008209b4 	movhi	r2,2086
 82295e0:	10b5c804 	addi	r2,r2,-10464
 82295e4:	e0fff217 	ldw	r3,-56(fp)
 82295e8:	18c7883a 	add	r3,r3,r3
 82295ec:	18c7883a 	add	r3,r3,r3
 82295f0:	10c5883a 	add	r2,r2,r3
 82295f4:	10800017 	ldw	r2,0(r2)
 82295f8:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 82295fc:	e0bff417 	ldw	r2,-48(fp)
 8229600:	10004626 	beq	r2,zero,822971c <tk_stats+0x194>
 8229604:	e0bff417 	ldw	r2,-48(fp)
 8229608:	10800058 	cmpnei	r2,r2,1
 822960c:	10004326 	beq	r2,zero,822971c <tk_stats+0x194>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 8229610:	e0bff417 	ldw	r2,-48(fp)
 8229614:	10800c83 	ldbu	r2,50(r2)
 8229618:	10803fcc 	andi	r2,r2,255
 822961c:	e13ffe44 	addi	r4,fp,-7
 8229620:	e0fff604 	addi	r3,fp,-40
 8229624:	200d883a 	mov	r6,r4
 8229628:	180b883a 	mov	r5,r3
 822962c:	1009883a 	mov	r4,r2
 8229630:	821b1cc0 	call	821b1cc <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 8229634:	e0bff417 	ldw	r2,-48(fp)
 8229638:	10800c83 	ldbu	r2,50(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 822963c:	11003fcc 	andi	r4,r2,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 8229640:	e0bff417 	ldw	r2,-48(fp)
 8229644:	10800c03 	ldbu	r2,48(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 8229648:	10803fcc 	andi	r2,r2,255
 822964c:	e0fff604 	addi	r3,fp,-40
 8229650:	d8800015 	stw	r2,0(sp)
 8229654:	200f883a 	mov	r7,r4
 8229658:	180d883a 	mov	r6,r3
 822965c:	01420974 	movhi	r5,2085
 8229660:	29410e04 	addi	r5,r5,1080
 8229664:	e13fff17 	ldw	r4,-4(fp)
 8229668:	8228bac0 	call	8228bac <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 822966c:	e0bff417 	ldw	r2,-48(fp)
 8229670:	10800217 	ldw	r2,8(r2)
 8229674:	10002426 	beq	r2,zero,8229708 <tk_stats+0x180>
 8229678:	e0bff417 	ldw	r2,-48(fp)
 822967c:	10800317 	ldw	r2,12(r2)
 8229680:	10002126 	beq	r2,zero,8229708 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 8229684:	e0bff417 	ldw	r2,-48(fp)
 8229688:	10800217 	ldw	r2,8(r2)
 822968c:	10800104 	addi	r2,r2,4
 8229690:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 8229694:	00000306 	br	82296a4 <tk_stats+0x11c>
            sp++;
 8229698:	e0bff317 	ldw	r2,-52(fp)
 822969c:	10800104 	addi	r2,r2,4
 82296a0:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 82296a4:	e0bff317 	ldw	r2,-52(fp)
 82296a8:	10800017 	ldw	r2,0(r2)
 82296ac:	103ffa26 	beq	r2,zero,8229698 <tk_stats+0x110>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 82296b0:	e0bff417 	ldw	r2,-48(fp)
 82296b4:	10800317 	ldw	r2,12(r2)
 82296b8:	e0fff317 	ldw	r3,-52(fp)
 82296bc:	e13ff417 	ldw	r4,-48(fp)
 82296c0:	21000217 	ldw	r4,8(r4)
 82296c4:	1907c83a 	sub	r3,r3,r4
 82296c8:	1807d0ba 	srai	r3,r3,2
 82296cc:	10c5c83a 	sub	r2,r2,r3
 82296d0:	1085883a 	add	r2,r2,r2
 82296d4:	1085883a 	add	r2,r2,r2
 82296d8:	e0bff515 	stw	r2,-44(fp)
         ns_printf(pio, "%6d,      %6d\n",
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
 82296dc:	e0bff417 	ldw	r2,-48(fp)
 82296e0:	10800317 	ldw	r2,12(r2)
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
         ns_printf(pio, "%6d,      %6d\n",
 82296e4:	1085883a 	add	r2,r2,r2
 82296e8:	1085883a 	add	r2,r2,r2
 82296ec:	e1fff517 	ldw	r7,-44(fp)
 82296f0:	100d883a 	mov	r6,r2
 82296f4:	01420974 	movhi	r5,2085
 82296f8:	29411604 	addi	r5,r5,1112
 82296fc:	e13fff17 	ldw	r4,-4(fp)
 8229700:	8228bac0 	call	8228bac <ns_printf>
 8229704:	00000606 	br	8229720 <tk_stats+0x198>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 8229708:	01420974 	movhi	r5,2085
 822970c:	29411a04 	addi	r5,r5,1128
 8229710:	e13fff17 	ldw	r4,-4(fp)
 8229714:	8228bac0 	call	8228bac <ns_printf>
 8229718:	00000106 	br	8229720 <tk_stats+0x198>
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
         continue;
 822971c:	0001883a 	nop
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 8229720:	e0bff217 	ldw	r2,-56(fp)
 8229724:	10800044 	addi	r2,r2,1
 8229728:	e0bff215 	stw	r2,-56(fp)
 822972c:	e0bff217 	ldw	r2,-56(fp)
 8229730:	10800550 	cmplti	r2,r2,21
 8229734:	103fa91e 	bne	r2,zero,82295dc <tk_stats+0x54>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 8229738:	d0a0a317 	ldw	r2,-32116(gp)
 822973c:	d0e0a417 	ldw	r3,-32112(gp)
 8229740:	180f883a 	mov	r7,r3
 8229744:	100d883a 	mov	r6,r2
 8229748:	01420974 	movhi	r5,2085
 822974c:	29411e04 	addi	r5,r5,1144
 8229750:	e13fff17 	ldw	r4,-4(fp)
 8229754:	8228bac0 	call	8228bac <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 8229758:	d0a0a717 	ldw	r2,-32100(gp)
 822975c:	d0e08e17 	ldw	r3,-32200(gp)
 8229760:	180f883a 	mov	r7,r3
 8229764:	100d883a 	mov	r6,r2
 8229768:	01420974 	movhi	r5,2085
 822976c:	29412a04 	addi	r5,r5,1192
 8229770:	e13fff17 	ldw	r4,-4(fp)
 8229774:	8228bac0 	call	8228bac <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 8229778:	0005883a 	mov	r2,zero
}
 822977c:	e037883a 	mov	sp,fp
 8229780:	dfc00117 	ldw	ra,4(sp)
 8229784:	df000017 	ldw	fp,0(sp)
 8229788:	dec00204 	addi	sp,sp,8
 822978c:	f800283a 	ret

08229790 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 8229790:	defffa04 	addi	sp,sp,-24
 8229794:	dfc00515 	stw	ra,20(sp)
 8229798:	df000415 	stw	fp,16(sp)
 822979c:	df000404 	addi	fp,sp,16
 82297a0:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 82297a4:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 82297a8:	e17fff17 	ldw	r5,-4(fp)
 82297ac:	01000d84 	movi	r4,54
 82297b0:	822c3dc0 	call	822c3dc <find_opt>
 82297b4:	e0bffd15 	stw	r2,-12(fp)
 82297b8:	e0bffd17 	ldw	r2,-12(fp)
 82297bc:	10001026 	beq	r2,zero,8229800 <dhc_get_srv_ipaddr+0x70>
   {
      opts++;
 82297c0:	e0bffd17 	ldw	r2,-12(fp)
 82297c4:	10800044 	addi	r2,r2,1
 82297c8:	e0bffd15 	stw	r2,-12(fp)
      optlen = *opts;
 82297cc:	e0bffd17 	ldw	r2,-12(fp)
 82297d0:	10800003 	ldbu	r2,0(r2)
 82297d4:	e0bffe05 	stb	r2,-8(fp)
      opts++;
 82297d8:	e0bffd17 	ldw	r2,-12(fp)
 82297dc:	10800044 	addi	r2,r2,1
 82297e0:	e0bffd15 	stw	r2,-12(fp)
      srv_ipaddr = dh_getlong(opts);
 82297e4:	e13ffd17 	ldw	r4,-12(fp)
 82297e8:	822b7400 	call	822b740 <dh_getlong>
 82297ec:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 82297f0:	e0bffe03 	ldbu	r2,-8(fp)
 82297f4:	e0fffd17 	ldw	r3,-12(fp)
 82297f8:	1885883a 	add	r2,r3,r2
 82297fc:	e0bffd15 	stw	r2,-12(fp)
   }

   return (srv_ipaddr);
 8229800:	e0bffc17 	ldw	r2,-16(fp)
} 
 8229804:	e037883a 	mov	sp,fp
 8229808:	dfc00117 	ldw	ra,4(sp)
 822980c:	df000017 	ldw	fp,0(sp)
 8229810:	dec00204 	addi	sp,sp,8
 8229814:	f800283a 	ret

08229818 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 8229818:	defffc04 	addi	sp,sp,-16
 822981c:	dfc00315 	stw	ra,12(sp)
 8229820:	df000215 	stw	fp,8(sp)
 8229824:	df000204 	addi	fp,sp,8
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 8229828:	00bfff44 	movi	r2,-3
 822982c:	d8800015 	stw	r2,0(sp)
 8229830:	01c208f4 	movhi	r7,2083
 8229834:	39e64404 	addi	r7,r7,-26352
 8229838:	01801104 	movi	r6,68
 822983c:	014010c4 	movi	r5,67
 8229840:	0009883a 	mov	r4,zero
 8229844:	822ce780 	call	822ce78 <udp_open>
 8229848:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 822984c:	d0a08f17 	ldw	r2,-32196(gp)
 8229850:	1000021e 	bne	r2,zero,822985c <dhc_init+0x44>
      return ENP_RESOURCE;
 8229854:	00bffa84 	movi	r2,-22
 8229858:	00001606 	br	82298b4 <dhc_init+0x9c>

   for (i = 0; i < MAXNETS; i++)
 822985c:	e03fff15 	stw	zero,-4(fp)
 8229860:	00001006 	br	82298a4 <dhc_init+0x8c>
   {
      dhc_states[i].state = DHCS_UNUSED;
 8229864:	008209b4 	movhi	r2,2086
 8229868:	10b76004 	addi	r2,r2,-8832
 822986c:	e0ffff17 	ldw	r3,-4(fp)
 8229870:	18c00f24 	muli	r3,r3,60
 8229874:	10c5883a 	add	r2,r2,r3
 8229878:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 822987c:	008209b4 	movhi	r2,2086
 8229880:	10b76004 	addi	r2,r2,-8832
 8229884:	e0ffff17 	ldw	r3,-4(fp)
 8229888:	18c00f24 	muli	r3,r3,60
 822988c:	10c5883a 	add	r2,r2,r3
 8229890:	10800104 	addi	r2,r2,4
 8229894:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 8229898:	e0bfff17 	ldw	r2,-4(fp)
 822989c:	10800044 	addi	r2,r2,1
 82298a0:	e0bfff15 	stw	r2,-4(fp)
 82298a4:	e0bfff17 	ldw	r2,-4(fp)
 82298a8:	10800110 	cmplti	r2,r2,4
 82298ac:	103fed1e 	bne	r2,zero,8229864 <dhc_init+0x4c>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 82298b0:	0005883a 	mov	r2,zero
}
 82298b4:	e037883a 	mov	sp,fp
 82298b8:	dfc00117 	ldw	ra,4(sp)
 82298bc:	df000017 	ldw	fp,0(sp)
 82298c0:	dec00204 	addi	sp,sp,8
 82298c4:	f800283a 	ret

082298c8 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 82298c8:	defffd04 	addi	sp,sp,-12
 82298cc:	df000215 	stw	fp,8(sp)
 82298d0:	df000204 	addi	fp,sp,8
 82298d4:	e13ffe15 	stw	r4,-8(fp)
 82298d8:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 82298dc:	008209b4 	movhi	r2,2086
 82298e0:	10b76004 	addi	r2,r2,-8832
 82298e4:	e0fffe17 	ldw	r3,-8(fp)
 82298e8:	18c00f24 	muli	r3,r3,60
 82298ec:	10c5883a 	add	r2,r2,r3
 82298f0:	10800e04 	addi	r2,r2,56
 82298f4:	e0ffff17 	ldw	r3,-4(fp)
 82298f8:	10c00015 	stw	r3,0(r2)
}
 82298fc:	0001883a 	nop
 8229900:	e037883a 	mov	sp,fp
 8229904:	df000017 	ldw	fp,0(sp)
 8229908:	dec00104 	addi	sp,sp,4
 822990c:	f800283a 	ret

08229910 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 8229910:	defff504 	addi	sp,sp,-44
 8229914:	dfc00a15 	stw	ra,40(sp)
 8229918:	df000915 	stw	fp,36(sp)
 822991c:	dc000815 	stw	r16,32(sp)
 8229920:	df000904 	addi	fp,sp,36
 8229924:	e13ffd15 	stw	r4,-12(fp)
 8229928:	e17ffe15 	stw	r5,-8(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 822992c:	e0bffd17 	ldw	r2,-12(fp)
 8229930:	10800417 	ldw	r2,16(r2)
 8229934:	e0bff815 	stw	r2,-32(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 8229938:	e03ff715 	stw	zero,-36(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 822993c:	e0bffe17 	ldw	r2,-8(fp)
 8229940:	10bfff60 	cmpeqi	r2,r2,-3
 8229944:	1000031e 	bne	r2,zero,8229954 <dhc_upcall+0x44>
   {
      dtrap();
 8229948:	822d2e00 	call	822d2e0 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 822994c:	00bffd44 	movi	r2,-11
 8229950:	0001d506 	br	822a0a8 <dhc_upcall+0x798>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 8229954:	e0bffd17 	ldw	r2,-12(fp)
 8229958:	10800617 	ldw	r2,24(r2)
 822995c:	1009883a 	mov	r4,r2
 8229960:	82269b40 	call	82269b4 <if_netnumber>
 8229964:	e0bff915 	stw	r2,-28(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 8229968:	008209b4 	movhi	r2,2086
 822996c:	10b76004 	addi	r2,r2,-8832
 8229970:	e0fff917 	ldw	r3,-28(fp)
 8229974:	18c00f24 	muli	r3,r3,60
 8229978:	10c5883a 	add	r2,r2,r3
 822997c:	10800017 	ldw	r2,0(r2)
 8229980:	1000021e 	bne	r2,zero,822998c <dhc_upcall+0x7c>
      return ENP_NOT_MINE;
 8229984:	00800084 	movi	r2,2
 8229988:	0001c706 	br	822a0a8 <dhc_upcall+0x798>

   bp = (struct bootp *)pkt->nb_prot;
 822998c:	e0bffd17 	ldw	r2,-12(fp)
 8229990:	10800317 	ldw	r2,12(r2)
 8229994:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229998:	e0bff817 	ldw	r2,-32(fp)
 822999c:	10803b30 	cmpltui	r2,r2,236
 82299a0:	10000b1e 	bne	r2,zero,82299d0 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
 82299a4:	e0bffa17 	ldw	r2,-24(fp)
 82299a8:	10800003 	ldbu	r2,0(r2)
      return ENP_NOT_MINE;

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 82299ac:	10803fcc 	andi	r2,r2,255
 82299b0:	10800098 	cmpnei	r2,r2,2
 82299b4:	1000061e 	bne	r2,zero,82299d0 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
 82299b8:	e0bffa17 	ldw	r2,-24(fp)
 82299bc:	10803b04 	addi	r2,r2,236
 82299c0:	10c00017 	ldw	r3,0(r2)

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
       (bp->op != BOOTREPLY) ||
 82299c4:	0098d534 	movhi	r2,25428
 82299c8:	10a098c4 	addi	r2,r2,-32157
 82299cc:	18800626 	beq	r3,r2,82299e8 <dhc_upcall+0xd8>
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 82299d0:	822d2e00 	call	822d2e0 <dtrap>
      dsc_errors++;
 82299d4:	d0a09017 	ldw	r2,-32192(gp)
 82299d8:	10800044 	addi	r2,r2,1
 82299dc:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 82299e0:	00800084 	movi	r2,2
 82299e4:	0001b006 	br	822a0a8 <dhc_upcall+0x798>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 82299e8:	e0bffa17 	ldw	r2,-24(fp)
 82299ec:	10c00704 	addi	r3,r2,28
 82299f0:	e0bffd17 	ldw	r2,-12(fp)
 82299f4:	10800617 	ldw	r2,24(r2)
 82299f8:	11001717 	ldw	r4,92(r2)
 82299fc:	e0bffd17 	ldw	r2,-12(fp)
 8229a00:	10800617 	ldw	r2,24(r2)
 8229a04:	10801117 	ldw	r2,68(r2)
 8229a08:	100d883a 	mov	r6,r2
 8229a0c:	200b883a 	mov	r5,r4
 8229a10:	1809883a 	mov	r4,r3
 8229a14:	820c3280 	call	820c328 <memcmp>
 8229a18:	10000226 	beq	r2,zero,8229a24 <dhc_upcall+0x114>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 8229a1c:	00800084 	movi	r2,2
 8229a20:	0001a106 	br	822a0a8 <dhc_upcall+0x798>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 8229a24:	e0bffa17 	ldw	r2,-24(fp)
 8229a28:	10803c04 	addi	r2,r2,240
 8229a2c:	100b883a 	mov	r5,r2
 8229a30:	01000d44 	movi	r4,53
 8229a34:	822c3dc0 	call	822c3dc <find_opt>
 8229a38:	e0bffb15 	stw	r2,-20(fp)
   if (opts && *opts == DHOP_TYPE)
 8229a3c:	e0bffb17 	ldw	r2,-20(fp)
 8229a40:	10001026 	beq	r2,zero,8229a84 <dhc_upcall+0x174>
 8229a44:	e0bffb17 	ldw	r2,-20(fp)
 8229a48:	10800003 	ldbu	r2,0(r2)
 8229a4c:	10803fcc 	andi	r2,r2,255
 8229a50:	10800d58 	cmpnei	r2,r2,53
 8229a54:	10000b1e 	bne	r2,zero,8229a84 <dhc_upcall+0x174>
   {
      dhcptype = *(opts+2);
 8229a58:	e0bffb17 	ldw	r2,-20(fp)
 8229a5c:	10800084 	addi	r2,r2,2
 8229a60:	10800003 	ldbu	r2,0(r2)
 8229a64:	10803fcc 	andi	r2,r2,255
 8229a68:	e0bff715 	stw	r2,-36(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 8229a6c:	e0bffa17 	ldw	r2,-24(fp)
 8229a70:	10800003 	ldbu	r2,0(r2)
 8229a74:	10800114 	ori	r2,r2,4
 8229a78:	1007883a 	mov	r3,r2
 8229a7c:	e0bffa17 	ldw	r2,-24(fp)
 8229a80:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 8229a84:	e0bffa17 	ldw	r2,-24(fp)
 8229a88:	10800003 	ldbu	r2,0(r2)
 8229a8c:	10803fcc 	andi	r2,r2,255
 8229a90:	1080010c 	andi	r2,r2,4
 8229a94:	10016326 	beq	r2,zero,822a024 <dhc_upcall+0x714>
   {
      switch (dhcptype)
 8229a98:	e0bff717 	ldw	r2,-36(fp)
 8229a9c:	10c00148 	cmpgei	r3,r2,5
 8229aa0:	1800051e 	bne	r3,zero,8229ab8 <dhc_upcall+0x1a8>
 8229aa4:	10c000c8 	cmpgei	r3,r2,3
 8229aa8:	1800051e 	bne	r3,zero,8229ac0 <dhc_upcall+0x1b0>
 8229aac:	10800060 	cmpeqi	r2,r2,1
 8229ab0:	1000031e 	bne	r2,zero,8229ac0 <dhc_upcall+0x1b0>
 8229ab4:	00000706 	br	8229ad4 <dhc_upcall+0x1c4>
 8229ab8:	108001e0 	cmpeqi	r2,r2,7
 8229abc:	10000526 	beq	r2,zero,8229ad4 <dhc_upcall+0x1c4>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 8229ac0:	d0a09017 	ldw	r2,-32192(gp)
 8229ac4:	10800044 	addi	r2,r2,1
 8229ac8:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229acc:	00800084 	movi	r2,2
 8229ad0:	00017506 	br	822a0a8 <dhc_upcall+0x798>
      }

      switch (dhc_states[iface].state)
 8229ad4:	008209b4 	movhi	r2,2086
 8229ad8:	10b76004 	addi	r2,r2,-8832
 8229adc:	e0fff917 	ldw	r3,-28(fp)
 8229ae0:	18c00f24 	muli	r3,r3,60
 8229ae4:	10c5883a 	add	r2,r2,r3
 8229ae8:	10800017 	ldw	r2,0(r2)
 8229aec:	10c00268 	cmpgeui	r3,r2,9
 8229af0:	1801431e 	bne	r3,zero,822a000 <dhc_upcall+0x6f0>
 8229af4:	100690ba 	slli	r3,r2,2
 8229af8:	008208f4 	movhi	r2,2083
 8229afc:	10a6c304 	addi	r2,r2,-25844
 8229b00:	1885883a 	add	r2,r3,r2
 8229b04:	10800017 	ldw	r2,0(r2)
 8229b08:	1000683a 	jmp	r2
 8229b0c:	0822a000 	call	822a00 <OSCtxSw_SWITCH_PC+0x8229c0>
 8229b10:	08229b30 	cmpltui	zero,at,35436
 8229b14:	08229b30 	cmpltui	zero,at,35436
 8229b18:	08229d64 	muli	zero,at,-30091
 8229b1c:	08229b44 	addi	zero,at,-30099
 8229b20:	08229cb8 	rdprs	zero,at,-30094
 8229b24:	08229b30 	cmpltui	zero,at,35436
 8229b28:	08229cb8 	rdprs	zero,at,-30094
 8229b2c:	08229cb8 	rdprs	zero,at,-30094
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 8229b30:	d0a09017 	ldw	r2,-32192(gp)
 8229b34:	10800044 	addi	r2,r2,1
 8229b38:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229b3c:	00800084 	movi	r2,2
 8229b40:	00015906 	br	822a0a8 <dhc_upcall+0x798>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 8229b44:	e0bff717 	ldw	r2,-36(fp)
 8229b48:	10800098 	cmpnei	r2,r2,2
 8229b4c:	10004f1e 	bne	r2,zero,8229c8c <dhc_upcall+0x37c>
         {
            dsc_offers++;
 8229b50:	d0a09217 	ldw	r2,-32184(gp)
 8229b54:	10800044 	addi	r2,r2,1
 8229b58:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 8229b5c:	e0bffa17 	ldw	r2,-24(fp)
 8229b60:	10803c04 	addi	r2,r2,240
 8229b64:	1009883a 	mov	r4,r2
 8229b68:	82297900 	call	8229790 <dhc_get_srv_ipaddr>
 8229b6c:	1009883a 	mov	r4,r2
 8229b70:	008209b4 	movhi	r2,2086
 8229b74:	10b76004 	addi	r2,r2,-8832
 8229b78:	e0fff917 	ldw	r3,-28(fp)
 8229b7c:	18c00f24 	muli	r3,r3,60
 8229b80:	10c5883a 	add	r2,r2,r3
 8229b84:	10800d04 	addi	r2,r2,52
 8229b88:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229b8c:	008209b4 	movhi	r2,2086
 8229b90:	10b76004 	addi	r2,r2,-8832
 8229b94:	e0fff917 	ldw	r3,-28(fp)
 8229b98:	18c00f24 	muli	r3,r3,60
 8229b9c:	10c5883a 	add	r2,r2,r3
 8229ba0:	10800d04 	addi	r2,r2,52
 8229ba4:	10800017 	ldw	r2,0(r2)
 8229ba8:	10000d1e 	bne	r2,zero,8229be0 <dhc_upcall+0x2d0>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229bac:	822d2e00 	call	822d2e0 <dtrap>
               dsc_errors++;
 8229bb0:	d0a09017 	ldw	r2,-32192(gp)
 8229bb4:	10800044 	addi	r2,r2,1
 8229bb8:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229bbc:	e0bffd17 	ldw	r2,-12(fp)
 8229bc0:	10c00717 	ldw	r3,28(r2)
 8229bc4:	008209b4 	movhi	r2,2086
 8229bc8:	10b76004 	addi	r2,r2,-8832
 8229bcc:	e13ff917 	ldw	r4,-28(fp)
 8229bd0:	21000f24 	muli	r4,r4,60
 8229bd4:	1105883a 	add	r2,r2,r4
 8229bd8:	10800d04 	addi	r2,r2,52
 8229bdc:	10c00015 	stw	r3,0(r2)
            }

            if (bp->hops)
 8229be0:	e0bffa17 	ldw	r2,-24(fp)
 8229be4:	108000c3 	ldbu	r2,3(r2)
 8229be8:	10803fcc 	andi	r2,r2,255
 8229bec:	10000a26 	beq	r2,zero,8229c18 <dhc_upcall+0x308>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229bf0:	e0bffd17 	ldw	r2,-12(fp)
 8229bf4:	10c00717 	ldw	r3,28(r2)
 8229bf8:	008209b4 	movhi	r2,2086
 8229bfc:	10b76004 	addi	r2,r2,-8832
 8229c00:	e13ff917 	ldw	r4,-28(fp)
 8229c04:	21000f24 	muli	r4,r4,60
 8229c08:	1105883a 	add	r2,r2,r4
 8229c0c:	10800c04 	addi	r2,r2,48
 8229c10:	10c00015 	stw	r3,0(r2)
 8229c14:	00000706 	br	8229c34 <dhc_upcall+0x324>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229c18:	008209b4 	movhi	r2,2086
 8229c1c:	10b76004 	addi	r2,r2,-8832
 8229c20:	e0fff917 	ldw	r3,-28(fp)
 8229c24:	18c00f24 	muli	r3,r3,60
 8229c28:	10c5883a 	add	r2,r2,r3
 8229c2c:	10800c04 	addi	r2,r2,48
 8229c30:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 8229c34:	e0bffd17 	ldw	r2,-12(fp)
 8229c38:	10800417 	ldw	r2,16(r2)
 8229c3c:	100d883a 	mov	r6,r2
 8229c40:	e17ffa17 	ldw	r5,-24(fp)
 8229c44:	e13ff917 	ldw	r4,-28(fp)
 8229c48:	822a7700 	call	822a770 <dhc_rx_offer>
 8229c4c:	e0bffc15 	stw	r2,-16(fp)
            if (e)
 8229c50:	e0bffc17 	ldw	r2,-16(fp)
 8229c54:	10000926 	beq	r2,zero,8229c7c <dhc_upcall+0x36c>
            {
               dsc_errors++;
 8229c58:	d0a09017 	ldw	r2,-32192(gp)
 8229c5c:	10800044 	addi	r2,r2,1
 8229c60:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 8229c64:	01400044 	movi	r5,1
 8229c68:	e13ff917 	ldw	r4,-28(fp)
 8229c6c:	822c32c0 	call	822c32c <dhc_set_state>
               dtrap();
 8229c70:	822d2e00 	call	822d2e0 <dtrap>
               return ENP_NOT_MINE;
 8229c74:	00800084 	movi	r2,2
 8229c78:	00010b06 	br	822a0a8 <dhc_upcall+0x798>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 8229c7c:	01400144 	movi	r5,5
 8229c80:	e13ff917 	ldw	r4,-28(fp)
 8229c84:	822c32c0 	call	822c32c <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 8229c88:	00010406 	br	822a09c <dhc_upcall+0x78c>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 8229c8c:	d0a09017 	ldw	r2,-32192(gp)
 8229c90:	10800044 	addi	r2,r2,1
 8229c94:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 8229c98:	e0bff717 	ldw	r2,-36(fp)
 8229c9c:	10800198 	cmpnei	r2,r2,6
 8229ca0:	1000031e 	bne	r2,zero,8229cb0 <dhc_upcall+0x3a0>
               dsc_naks++;
 8229ca4:	d0a09817 	ldw	r2,-32160(gp)
 8229ca8:	10800044 	addi	r2,r2,1
 8229cac:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 8229cb0:	00800084 	movi	r2,2
 8229cb4:	0000fc06 	br	822a0a8 <dhc_upcall+0x798>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229cb8:	008209b4 	movhi	r2,2086
 8229cbc:	10b76004 	addi	r2,r2,-8832
 8229cc0:	e0fff917 	ldw	r3,-28(fp)
 8229cc4:	18c00f24 	muli	r3,r3,60
 8229cc8:	10c5883a 	add	r2,r2,r3
 8229ccc:	10800d04 	addi	r2,r2,52
 8229cd0:	14000017 	ldw	r16,0(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
 8229cd4:	e0bffa17 	ldw	r2,-24(fp)
 8229cd8:	10803c04 	addi	r2,r2,240
 8229cdc:	1009883a 	mov	r4,r2
 8229ce0:	82297900 	call	8229790 <dhc_get_srv_ipaddr>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229ce4:	80800526 	beq	r16,r2,8229cfc <dhc_upcall+0x3ec>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 8229ce8:	d0a09017 	ldw	r2,-32192(gp)
 8229cec:	10800044 	addi	r2,r2,1
 8229cf0:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229cf4:	00800084 	movi	r2,2
 8229cf8:	0000eb06 	br	822a0a8 <dhc_upcall+0x798>
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229cfc:	008209b4 	movhi	r2,2086
 8229d00:	10b76004 	addi	r2,r2,-8832
 8229d04:	e0fff917 	ldw	r3,-28(fp)
 8229d08:	18c00f24 	muli	r3,r3,60
 8229d0c:	10c5883a 	add	r2,r2,r3
 8229d10:	10800c04 	addi	r2,r2,48
 8229d14:	10800017 	ldw	r2,0(r2)
 8229d18:	10001226 	beq	r2,zero,8229d64 <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
 8229d1c:	008209b4 	movhi	r2,2086
 8229d20:	10b76004 	addi	r2,r2,-8832
 8229d24:	e0fff917 	ldw	r3,-28(fp)
 8229d28:	18c00f24 	muli	r3,r3,60
 8229d2c:	10c5883a 	add	r2,r2,r3
 8229d30:	10800c04 	addi	r2,r2,48
 8229d34:	10c00017 	ldw	r3,0(r2)
 8229d38:	e0bffd17 	ldw	r2,-12(fp)
 8229d3c:	10800717 	ldw	r2,28(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229d40:	18800826 	beq	r3,r2,8229d64 <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 8229d44:	d0a09b17 	ldw	r2,-32148(gp)
 8229d48:	10800044 	addi	r2,r2,1
 8229d4c:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 8229d50:	d0a09017 	ldw	r2,-32192(gp)
 8229d54:	10800044 	addi	r2,r2,1
 8229d58:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229d5c:	00800084 	movi	r2,2
 8229d60:	0000d106 	br	822a0a8 <dhc_upcall+0x798>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 8229d64:	e0bff717 	ldw	r2,-36(fp)
 8229d68:	10800158 	cmpnei	r2,r2,5
 8229d6c:	1000851e 	bne	r2,zero,8229f84 <dhc_upcall+0x674>
         {
            dsc_acks++;
 8229d70:	d0a09417 	ldw	r2,-32176(gp)
 8229d74:	10800044 	addi	r2,r2,1
 8229d78:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 8229d7c:	e0bffa17 	ldw	r2,-24(fp)
 8229d80:	10803c04 	addi	r2,r2,240
 8229d84:	100b883a 	mov	r5,r2
 8229d88:	e13ff917 	ldw	r4,-28(fp)
 8229d8c:	822b7ec0 	call	822b7ec <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 8229d90:	008209b4 	movhi	r2,2086
 8229d94:	10b76004 	addi	r2,r2,-8832
 8229d98:	e0fff917 	ldw	r3,-28(fp)
 8229d9c:	18c00f24 	muli	r3,r3,60
 8229da0:	10c5883a 	add	r2,r2,r3
 8229da4:	10800504 	addi	r2,r2,20
 8229da8:	10800017 	ldw	r2,0(r2)
 8229dac:	10bfffd8 	cmpnei	r2,r2,-1
 8229db0:	1000111e 	bne	r2,zero,8229df8 <dhc_upcall+0x4e8>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 8229db4:	008209b4 	movhi	r2,2086
 8229db8:	10b76004 	addi	r2,r2,-8832
 8229dbc:	e0fff917 	ldw	r3,-28(fp)
 8229dc0:	18c00f24 	muli	r3,r3,60
 8229dc4:	10c5883a 	add	r2,r2,r3
 8229dc8:	10800604 	addi	r2,r2,24
 8229dcc:	00ffffc4 	movi	r3,-1
 8229dd0:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = DHC_INFINITY ;
 8229dd4:	008209b4 	movhi	r2,2086
 8229dd8:	10b76004 	addi	r2,r2,-8832
 8229ddc:	e0fff917 	ldw	r3,-28(fp)
 8229de0:	18c00f24 	muli	r3,r3,60
 8229de4:	10c5883a 	add	r2,r2,r3
 8229de8:	10800704 	addi	r2,r2,28
 8229dec:	00ffffc4 	movi	r3,-1
 8229df0:	10c00015 	stw	r3,0(r2)
 8229df4:	00001f06 	br	8229e74 <dhc_upcall+0x564>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 8229df8:	008209b4 	movhi	r2,2086
 8229dfc:	10b76004 	addi	r2,r2,-8832
 8229e00:	e0fff917 	ldw	r3,-28(fp)
 8229e04:	18c00f24 	muli	r3,r3,60
 8229e08:	10c5883a 	add	r2,r2,r3
 8229e0c:	10800504 	addi	r2,r2,20
 8229e10:	10800017 	ldw	r2,0(r2)
 8229e14:	1006d07a 	srli	r3,r2,1
 8229e18:	008209b4 	movhi	r2,2086
 8229e1c:	10b76004 	addi	r2,r2,-8832
 8229e20:	e13ff917 	ldw	r4,-28(fp)
 8229e24:	21000f24 	muli	r4,r4,60
 8229e28:	1105883a 	add	r2,r2,r4
 8229e2c:	10800604 	addi	r2,r2,24
 8229e30:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 8229e34:	008209b4 	movhi	r2,2086
 8229e38:	10b76004 	addi	r2,r2,-8832
 8229e3c:	e0fff917 	ldw	r3,-28(fp)
 8229e40:	18c00f24 	muli	r3,r3,60
 8229e44:	10c5883a 	add	r2,r2,r3
 8229e48:	10800504 	addi	r2,r2,20
 8229e4c:	10800017 	ldw	r2,0(r2)
 8229e50:	1004d0fa 	srli	r2,r2,3
 8229e54:	10c001e4 	muli	r3,r2,7
 8229e58:	008209b4 	movhi	r2,2086
 8229e5c:	10b76004 	addi	r2,r2,-8832
 8229e60:	e13ff917 	ldw	r4,-28(fp)
 8229e64:	21000f24 	muli	r4,r4,60
 8229e68:	1105883a 	add	r2,r2,r4
 8229e6c:	10800704 	addi	r2,r2,28
 8229e70:	10c00015 	stw	r3,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 8229e74:	d0e0a817 	ldw	r3,-32096(gp)
 8229e78:	008209b4 	movhi	r2,2086
 8229e7c:	10b76004 	addi	r2,r2,-8832
 8229e80:	e13ff917 	ldw	r4,-28(fp)
 8229e84:	21000f24 	muli	r4,r4,60
 8229e88:	1105883a 	add	r2,r2,r4
 8229e8c:	10800804 	addi	r2,r2,32
 8229e90:	10c00015 	stw	r3,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 8229e94:	e0bffa17 	ldw	r2,-24(fp)
 8229e98:	10803c04 	addi	r2,r2,240
 8229e9c:	1009883a 	mov	r4,r2
 8229ea0:	82297900 	call	8229790 <dhc_get_srv_ipaddr>
 8229ea4:	1009883a 	mov	r4,r2
 8229ea8:	008209b4 	movhi	r2,2086
 8229eac:	10b76004 	addi	r2,r2,-8832
 8229eb0:	e0fff917 	ldw	r3,-28(fp)
 8229eb4:	18c00f24 	muli	r3,r3,60
 8229eb8:	10c5883a 	add	r2,r2,r3
 8229ebc:	10800d04 	addi	r2,r2,52
 8229ec0:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229ec4:	008209b4 	movhi	r2,2086
 8229ec8:	10b76004 	addi	r2,r2,-8832
 8229ecc:	e0fff917 	ldw	r3,-28(fp)
 8229ed0:	18c00f24 	muli	r3,r3,60
 8229ed4:	10c5883a 	add	r2,r2,r3
 8229ed8:	10800d04 	addi	r2,r2,52
 8229edc:	10800017 	ldw	r2,0(r2)
 8229ee0:	10000d1e 	bne	r2,zero,8229f18 <dhc_upcall+0x608>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229ee4:	822d2e00 	call	822d2e0 <dtrap>
               dsc_errors++;
 8229ee8:	d0a09017 	ldw	r2,-32192(gp)
 8229eec:	10800044 	addi	r2,r2,1
 8229ef0:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229ef4:	e0bffd17 	ldw	r2,-12(fp)
 8229ef8:	10c00717 	ldw	r3,28(r2)
 8229efc:	008209b4 	movhi	r2,2086
 8229f00:	10b76004 	addi	r2,r2,-8832
 8229f04:	e13ff917 	ldw	r4,-28(fp)
 8229f08:	21000f24 	muli	r4,r4,60
 8229f0c:	1105883a 	add	r2,r2,r4
 8229f10:	10800d04 	addi	r2,r2,52
 8229f14:	10c00015 	stw	r3,0(r2)
            }
            if (bp->hops)
 8229f18:	e0bffa17 	ldw	r2,-24(fp)
 8229f1c:	108000c3 	ldbu	r2,3(r2)
 8229f20:	10803fcc 	andi	r2,r2,255
 8229f24:	10000a26 	beq	r2,zero,8229f50 <dhc_upcall+0x640>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229f28:	e0bffd17 	ldw	r2,-12(fp)
 8229f2c:	10c00717 	ldw	r3,28(r2)
 8229f30:	008209b4 	movhi	r2,2086
 8229f34:	10b76004 	addi	r2,r2,-8832
 8229f38:	e13ff917 	ldw	r4,-28(fp)
 8229f3c:	21000f24 	muli	r4,r4,60
 8229f40:	1105883a 	add	r2,r2,r4
 8229f44:	10800c04 	addi	r2,r2,48
 8229f48:	10c00015 	stw	r3,0(r2)
 8229f4c:	00000706 	br	8229f6c <dhc_upcall+0x65c>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229f50:	008209b4 	movhi	r2,2086
 8229f54:	10b76004 	addi	r2,r2,-8832
 8229f58:	e0fff917 	ldw	r3,-28(fp)
 8229f5c:	18c00f24 	muli	r3,r3,60
 8229f60:	10c5883a 	add	r2,r2,r3
 8229f64:	10800c04 	addi	r2,r2,48
 8229f68:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 8229f6c:	e13ff917 	ldw	r4,-28(fp)
 8229f70:	822b2d80 	call	822b2d8 <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 8229f74:	01400184 	movi	r5,6
 8229f78:	e13ff917 	ldw	r4,-28(fp)
 8229f7c:	822c32c0 	call	822c32c <dhc_set_state>
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 8229f80:	00004606 	br	822a09c <dhc_upcall+0x78c>
               dhc_states[iface].rly_ipaddr = 0;

            dhc_setip(iface);
            dhc_set_state(iface,DHCS_BOUND);
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 8229f84:	e0bff717 	ldw	r2,-36(fp)
 8229f88:	10800198 	cmpnei	r2,r2,6
 8229f8c:	1000071e 	bne	r2,zero,8229fac <dhc_upcall+0x69c>
         {
            dhc_set_state(iface,DHCS_INIT);
 8229f90:	01400044 	movi	r5,1
 8229f94:	e13ff917 	ldw	r4,-28(fp)
 8229f98:	822c32c0 	call	822c32c <dhc_set_state>
            dsc_naks++;
 8229f9c:	d0a09817 	ldw	r2,-32160(gp)
 8229fa0:	10800044 	addi	r2,r2,1
 8229fa4:	d0a09815 	stw	r2,-32160(gp)
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 8229fa8:	00003c06 	br	822a09c <dhc_upcall+0x78c>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 8229fac:	008209b4 	movhi	r2,2086
 8229fb0:	10b76004 	addi	r2,r2,-8832
 8229fb4:	e0fff917 	ldw	r3,-28(fp)
 8229fb8:	18c00f24 	muli	r3,r3,60
 8229fbc:	10c5883a 	add	r2,r2,r3
 8229fc0:	10800017 	ldw	r2,0(r2)
 8229fc4:	10800158 	cmpnei	r2,r2,5
 8229fc8:	1000081e 	bne	r2,zero,8229fec <dhc_upcall+0x6dc>
 8229fcc:	e0bff717 	ldw	r2,-36(fp)
 8229fd0:	10800098 	cmpnei	r2,r2,2
 8229fd4:	1000051e 	bne	r2,zero,8229fec <dhc_upcall+0x6dc>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 8229fd8:	d0a09217 	ldw	r2,-32184(gp)
 8229fdc:	10800044 	addi	r2,r2,1
 8229fe0:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 8229fe4:	00800084 	movi	r2,2
 8229fe8:	00002f06 	br	822a0a8 <dhc_upcall+0x798>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 8229fec:	d0a09017 	ldw	r2,-32192(gp)
 8229ff0:	10800044 	addi	r2,r2,1
 8229ff4:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229ff8:	00800084 	movi	r2,2
 8229ffc:	00002a06 	br	822a0a8 <dhc_upcall+0x798>
         }
         break;
      default:    /* bad state */
         dtrap();
 822a000:	822d2e00 	call	822d2e0 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 822a004:	01400044 	movi	r5,1
 822a008:	e13ff917 	ldw	r4,-28(fp)
 822a00c:	822c32c0 	call	822c32c <dhc_set_state>
         dsc_errors++;
 822a010:	d0a09017 	ldw	r2,-32192(gp)
 822a014:	10800044 	addi	r2,r2,1
 822a018:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 822a01c:	00bfffc4 	movi	r2,-1
 822a020:	00002106 	br	822a0a8 <dhc_upcall+0x798>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 822a024:	d0a09517 	ldw	r2,-32172(gp)
 822a028:	10800044 	addi	r2,r2,1
 822a02c:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 822a030:	e0bffa17 	ldw	r2,-24(fp)
 822a034:	10803c04 	addi	r2,r2,240
 822a038:	100b883a 	mov	r5,r2
 822a03c:	e13ff917 	ldw	r4,-28(fp)
 822a040:	822b7ec0 	call	822b7ec <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 822a044:	e0bffa17 	ldw	r2,-24(fp)
 822a048:	10c00417 	ldw	r3,16(r2)
 822a04c:	008209b4 	movhi	r2,2086
 822a050:	10b76004 	addi	r2,r2,-8832
 822a054:	e13ff917 	ldw	r4,-28(fp)
 822a058:	21000f24 	muli	r4,r4,60
 822a05c:	1105883a 	add	r2,r2,r4
 822a060:	10800904 	addi	r2,r2,36
 822a064:	10c00015 	stw	r3,0(r2)
      dhc_setip(iface);
 822a068:	e13ff917 	ldw	r4,-28(fp)
 822a06c:	822b2d80 	call	822b2d8 <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 822a070:	01400184 	movi	r5,6
 822a074:	e13ff917 	ldw	r4,-28(fp)
 822a078:	822c32c0 	call	822c32c <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 822a07c:	008209b4 	movhi	r2,2086
 822a080:	10b76004 	addi	r2,r2,-8832
 822a084:	e0fff917 	ldw	r3,-28(fp)
 822a088:	18c00f24 	muli	r3,r3,60
 822a08c:	10c5883a 	add	r2,r2,r3
 822a090:	10800604 	addi	r2,r2,24
 822a094:	00ffffc4 	movi	r3,-1
 822a098:	10c00015 	stw	r3,0(r2)
   }

   udp_free(pkt);
 822a09c:	e13ffd17 	ldw	r4,-12(fp)
 822a0a0:	82452140 	call	8245214 <udp_free>
   return 0;
 822a0a4:	0005883a 	mov	r2,zero
}
 822a0a8:	e6ffff04 	addi	sp,fp,-4
 822a0ac:	dfc00217 	ldw	ra,8(sp)
 822a0b0:	df000117 	ldw	fp,4(sp)
 822a0b4:	dc000017 	ldw	r16,0(sp)
 822a0b8:	dec00304 	addi	sp,sp,12
 822a0bc:	f800283a 	ret

0822a0c0 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 822a0c0:	defffb04 	addi	sp,sp,-20
 822a0c4:	dfc00415 	stw	ra,16(sp)
 822a0c8:	df000315 	stw	fp,12(sp)
 822a0cc:	df000304 	addi	fp,sp,12
 822a0d0:	e13ffe15 	stw	r4,-8(fp)
 822a0d4:	e17fff15 	stw	r5,-4(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 822a0d8:	01804b04 	movi	r6,300
 822a0dc:	000b883a 	mov	r5,zero
 822a0e0:	e13fff17 	ldw	r4,-4(fp)
 822a0e4:	8202f000 	call	8202f00 <memset>
   outbp->op = BOOTREQUEST;
 822a0e8:	e0bfff17 	ldw	r2,-4(fp)
 822a0ec:	00c00044 	movi	r3,1
 822a0f0:	10c00005 	stb	r3,0(r2)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 822a0f4:	008209b4 	movhi	r2,2086
 822a0f8:	10b73a04 	addi	r2,r2,-8984
 822a0fc:	e0fffe17 	ldw	r3,-8(fp)
 822a100:	18c7883a 	add	r3,r3,r3
 822a104:	18c7883a 	add	r3,r3,r3
 822a108:	10c5883a 	add	r2,r2,r3
 822a10c:	10800017 	ldw	r2,0(r2)
 822a110:	10802717 	ldw	r2,156(r2)
 822a114:	10800217 	ldw	r2,8(r2)
 822a118:	10c005e0 	cmpeqi	r3,r2,23
 822a11c:	1800081e 	bne	r3,zero,822a140 <dhc_buildheader+0x80>
 822a120:	10c00720 	cmpeqi	r3,r2,28
 822a124:	1800061e 	bne	r3,zero,822a140 <dhc_buildheader+0x80>
 822a128:	108001a0 	cmpeqi	r2,r2,6
 822a12c:	10000826 	beq	r2,zero,822a150 <dhc_buildheader+0x90>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 822a130:	e0bfff17 	ldw	r2,-4(fp)
 822a134:	00c00044 	movi	r3,1
 822a138:	10c00045 	stb	r3,1(r2)
   break;
 822a13c:	00000706 	br	822a15c <dhc_buildheader+0x9c>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 822a140:	e0bfff17 	ldw	r2,-4(fp)
 822a144:	00c00504 	movi	r3,20
 822a148:	10c00045 	stb	r3,1(r2)
   break;
 822a14c:	00000306 	br	822a15c <dhc_buildheader+0x9c>
      default:
      dtrap();
 822a150:	822d2e00 	call	822d2e0 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 822a154:	00bffd44 	movi	r2,-11
 822a158:	00004d06 	br	822a290 <dhc_buildheader+0x1d0>
   }

   addrlen = min(16, nets[iface]->n_hal);
 822a15c:	008209b4 	movhi	r2,2086
 822a160:	10b73a04 	addi	r2,r2,-8984
 822a164:	e0fffe17 	ldw	r3,-8(fp)
 822a168:	18c7883a 	add	r3,r3,r3
 822a16c:	18c7883a 	add	r3,r3,r3
 822a170:	10c5883a 	add	r2,r2,r3
 822a174:	10800017 	ldw	r2,0(r2)
 822a178:	10801117 	ldw	r2,68(r2)
 822a17c:	10c00470 	cmpltui	r3,r2,17
 822a180:	1800011e 	bne	r3,zero,822a188 <dhc_buildheader+0xc8>
 822a184:	00800404 	movi	r2,16
 822a188:	e0bffd15 	stw	r2,-12(fp)
   outbp->hlen = (u_char)addrlen;
 822a18c:	e0bffd17 	ldw	r2,-12(fp)
 822a190:	1007883a 	mov	r3,r2
 822a194:	e0bfff17 	ldw	r2,-4(fp)
 822a198:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 822a19c:	e0bfff17 	ldw	r2,-4(fp)
 822a1a0:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 822a1a4:	008209b4 	movhi	r2,2086
 822a1a8:	10b76004 	addi	r2,r2,-8832
 822a1ac:	e0fffe17 	ldw	r3,-8(fp)
 822a1b0:	18c00f24 	muli	r3,r3,60
 822a1b4:	10c5883a 	add	r2,r2,r3
 822a1b8:	10800017 	ldw	r2,0(r2)
 822a1bc:	108001d8 	cmpnei	r2,r2,7
 822a1c0:	1000031e 	bne	r2,zero,822a1d0 <dhc_buildheader+0x110>
      outbp->flags = 0; /* Renewing needs unicast */
 822a1c4:	e0bfff17 	ldw	r2,-4(fp)
 822a1c8:	1000028d 	sth	zero,10(r2)
 822a1cc:	00000306 	br	822a1dc <dhc_buildheader+0x11c>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 822a1d0:	e0bfff17 	ldw	r2,-4(fp)
 822a1d4:	00c02004 	movi	r3,128
 822a1d8:	10c0028d 	sth	r3,10(r2)
   outbp->xid = dhc_states[iface].xid;
 822a1dc:	008209b4 	movhi	r2,2086
 822a1e0:	10b76004 	addi	r2,r2,-8832
 822a1e4:	e0fffe17 	ldw	r3,-8(fp)
 822a1e8:	18c00f24 	muli	r3,r3,60
 822a1ec:	10c5883a 	add	r2,r2,r3
 822a1f0:	10800204 	addi	r2,r2,8
 822a1f4:	10c00017 	ldw	r3,0(r2)
 822a1f8:	e0bfff17 	ldw	r2,-4(fp)
 822a1fc:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 822a200:	008209b4 	movhi	r2,2086
 822a204:	10b76004 	addi	r2,r2,-8832
 822a208:	e0fffe17 	ldw	r3,-8(fp)
 822a20c:	18c00f24 	muli	r3,r3,60
 822a210:	10c5883a 	add	r2,r2,r3
 822a214:	10800304 	addi	r2,r2,12
 822a218:	10c0000b 	ldhu	r3,0(r2)
 822a21c:	e0bfff17 	ldw	r2,-4(fp)
 822a220:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 822a224:	008209b4 	movhi	r2,2086
 822a228:	10b73a04 	addi	r2,r2,-8984
 822a22c:	e0fffe17 	ldw	r3,-8(fp)
 822a230:	18c7883a 	add	r3,r3,r3
 822a234:	18c7883a 	add	r3,r3,r3
 822a238:	10c5883a 	add	r2,r2,r3
 822a23c:	10800017 	ldw	r2,0(r2)
 822a240:	10801717 	ldw	r2,92(r2)
 822a244:	1000031e 	bne	r2,zero,822a254 <dhc_buildheader+0x194>
   {
      dtrap();
 822a248:	822d2e00 	call	822d2e0 <dtrap>
      return ENP_LOGIC;
 822a24c:	00bffd44 	movi	r2,-11
 822a250:	00000f06 	br	822a290 <dhc_buildheader+0x1d0>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 822a254:	e0bfff17 	ldw	r2,-4(fp)
 822a258:	11000704 	addi	r4,r2,28
 822a25c:	008209b4 	movhi	r2,2086
 822a260:	10b73a04 	addi	r2,r2,-8984
 822a264:	e0fffe17 	ldw	r3,-8(fp)
 822a268:	18c7883a 	add	r3,r3,r3
 822a26c:	18c7883a 	add	r3,r3,r3
 822a270:	10c5883a 	add	r2,r2,r3
 822a274:	10800017 	ldw	r2,0(r2)
 822a278:	10801717 	ldw	r2,92(r2)
 822a27c:	e0fffd17 	ldw	r3,-12(fp)
 822a280:	180d883a 	mov	r6,r3
 822a284:	100b883a 	mov	r5,r2
 822a288:	8202c5c0 	call	8202c5c <memcpy>

   /* return success */
   return 0;
 822a28c:	0005883a 	mov	r2,zero
}
 822a290:	e037883a 	mov	sp,fp
 822a294:	dfc00117 	ldw	ra,4(sp)
 822a298:	df000017 	ldw	fp,0(sp)
 822a29c:	dec00204 	addi	sp,sp,8
 822a2a0:	f800283a 	ret

0822a2a4 <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 822a2a4:	defff404 	addi	sp,sp,-48
 822a2a8:	dfc00b15 	stw	ra,44(sp)
 822a2ac:	df000a15 	stw	fp,40(sp)
 822a2b0:	dc400915 	stw	r17,36(sp)
 822a2b4:	dc000815 	stw	r16,32(sp)
 822a2b8:	df000a04 	addi	fp,sp,40
 822a2bc:	e13ffd15 	stw	r4,-12(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 822a2c0:	000b883a 	mov	r5,zero
 822a2c4:	01004b04 	movi	r4,300
 822a2c8:	82451340 	call	8245134 <udp_alloc>
 822a2cc:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a2d0:	e0bff817 	ldw	r2,-32(fp)
 822a2d4:	1000021e 	bne	r2,zero,822a2e0 <dhc_discover+0x3c>
      return ENP_NOMEM;
 822a2d8:	00bffb04 	movi	r2,-20
 822a2dc:	00011d06 	br	822a754 <dhc_discover+0x4b0>
   pkt->nb_plen = sizeof(struct bootp);
 822a2e0:	e0bff817 	ldw	r2,-32(fp)
 822a2e4:	00c04b04 	movi	r3,300
 822a2e8:	10c00415 	stw	r3,16(r2)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 822a2ec:	d0a03317 	ldw	r2,-32564(gp)
 822a2f0:	10c00044 	addi	r3,r2,1
 822a2f4:	d0e03315 	stw	r3,-32564(gp)
 822a2f8:	1009883a 	mov	r4,r2
 822a2fc:	008209b4 	movhi	r2,2086
 822a300:	10b76004 	addi	r2,r2,-8832
 822a304:	e0fffd17 	ldw	r3,-12(fp)
 822a308:	18c00f24 	muli	r3,r3,60
 822a30c:	10c5883a 	add	r2,r2,r3
 822a310:	10800204 	addi	r2,r2,8
 822a314:	11000015 	stw	r4,0(r2)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 822a318:	823d0500 	call	823d050 <sysuptime>
 822a31c:	1007883a 	mov	r3,r2
 822a320:	00947b34 	movhi	r2,20972
 822a324:	10a147c4 	addi	r2,r2,-31457
 822a328:	1888383a 	mulxuu	r4,r3,r2
 822a32c:	1885383a 	mul	r2,r3,r2
 822a330:	1021883a 	mov	r16,r2
 822a334:	2023883a 	mov	r17,r4
 822a338:	8804d17a 	srli	r2,r17,5
 822a33c:	1009883a 	mov	r4,r2
 822a340:	008209b4 	movhi	r2,2086
 822a344:	10b76004 	addi	r2,r2,-8832
 822a348:	e0fffd17 	ldw	r3,-12(fp)
 822a34c:	18c00f24 	muli	r3,r3,60
 822a350:	10c5883a 	add	r2,r2,r3
 822a354:	10800304 	addi	r2,r2,12
 822a358:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 822a35c:	e0bff817 	ldw	r2,-32(fp)
 822a360:	10800317 	ldw	r2,12(r2)
 822a364:	e0bff915 	stw	r2,-28(fp)
   e = dhc_buildheader(iface,outbp);
 822a368:	e17ff917 	ldw	r5,-28(fp)
 822a36c:	e13ffd17 	ldw	r4,-12(fp)
 822a370:	822a0c00 	call	822a0c0 <dhc_buildheader>
 822a374:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822a378:	e0bffa17 	ldw	r2,-24(fp)
 822a37c:	10000226 	beq	r2,zero,822a388 <dhc_discover+0xe4>
      return e;
 822a380:	e0bffa17 	ldw	r2,-24(fp)
 822a384:	0000f306 	br	822a754 <dhc_discover+0x4b0>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a388:	e0bff917 	ldw	r2,-28(fp)
 822a38c:	10c03b04 	addi	r3,r2,236
 822a390:	0098d534 	movhi	r2,25428
 822a394:	10a098c4 	addi	r2,r2,-32157
 822a398:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 822a39c:	e0bff917 	ldw	r2,-28(fp)
 822a3a0:	10803c04 	addi	r2,r2,240
 822a3a4:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822a3a8:	e0bff617 	ldw	r2,-40(fp)
 822a3ac:	10c00044 	addi	r3,r2,1
 822a3b0:	e0fff615 	stw	r3,-40(fp)
 822a3b4:	00c00d44 	movi	r3,53
 822a3b8:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a3bc:	e0bff617 	ldw	r2,-40(fp)
 822a3c0:	10c00044 	addi	r3,r2,1
 822a3c4:	e0fff615 	stw	r3,-40(fp)
 822a3c8:	00c00044 	movi	r3,1
 822a3cc:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_DISCOVER;
 822a3d0:	e0bff617 	ldw	r2,-40(fp)
 822a3d4:	10c00044 	addi	r3,r2,1
 822a3d8:	e0fff615 	stw	r3,-40(fp)
 822a3dc:	00c00044 	movi	r3,1
 822a3e0:	10c00005 	stb	r3,0(r2)
   leasetime = -1L ;    /* ask for infinite lease */
 822a3e4:	00bfffc4 	movi	r2,-1
 822a3e8:	e0bffb15 	stw	r2,-20(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 822a3ec:	e0bff617 	ldw	r2,-40(fp)
 822a3f0:	10c00044 	addi	r3,r2,1
 822a3f4:	e0fff615 	stw	r3,-40(fp)
 822a3f8:	00c00cc4 	movi	r3,51
 822a3fc:	10c00005 	stb	r3,0(r2)
 822a400:	e0bff617 	ldw	r2,-40(fp)
 822a404:	10c00044 	addi	r3,r2,1
 822a408:	e0fff615 	stw	r3,-40(fp)
 822a40c:	00c00104 	movi	r3,4
 822a410:	10c00005 	stb	r3,0(r2)
 822a414:	e0bff617 	ldw	r2,-40(fp)
 822a418:	108000c4 	addi	r2,r2,3
 822a41c:	e0fffb04 	addi	r3,fp,-20
 822a420:	18c00003 	ldbu	r3,0(r3)
 822a424:	10c00005 	stb	r3,0(r2)
 822a428:	e0bff617 	ldw	r2,-40(fp)
 822a42c:	10c00084 	addi	r3,r2,2
 822a430:	e0bffb04 	addi	r2,fp,-20
 822a434:	10800044 	addi	r2,r2,1
 822a438:	10800003 	ldbu	r2,0(r2)
 822a43c:	18800005 	stb	r2,0(r3)
 822a440:	e0bff617 	ldw	r2,-40(fp)
 822a444:	10c00044 	addi	r3,r2,1
 822a448:	e0bffb04 	addi	r2,fp,-20
 822a44c:	10800084 	addi	r2,r2,2
 822a450:	10800003 	ldbu	r2,0(r2)
 822a454:	18800005 	stb	r2,0(r3)
 822a458:	e0bffb04 	addi	r2,fp,-20
 822a45c:	108000c4 	addi	r2,r2,3
 822a460:	10800003 	ldbu	r2,0(r2)
 822a464:	1007883a 	mov	r3,r2
 822a468:	e0bff617 	ldw	r2,-40(fp)
 822a46c:	10c00005 	stb	r3,0(r2)
 822a470:	e0bff617 	ldw	r2,-40(fp)
 822a474:	10800104 	addi	r2,r2,4
 822a478:	e0bff615 	stw	r2,-40(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 822a47c:	008209b4 	movhi	r2,2086
 822a480:	10b73a04 	addi	r2,r2,-8984
 822a484:	e0fffd17 	ldw	r3,-12(fp)
 822a488:	18c7883a 	add	r3,r3,r3
 822a48c:	18c7883a 	add	r3,r3,r3
 822a490:	10c5883a 	add	r2,r2,r3
 822a494:	10800017 	ldw	r2,0(r2)
 822a498:	10800a17 	ldw	r2,40(r2)
 822a49c:	10004e26 	beq	r2,zero,822a5d8 <dhc_discover+0x334>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 822a4a0:	008209b4 	movhi	r2,2086
 822a4a4:	10b73a04 	addi	r2,r2,-8984
 822a4a8:	e0fffd17 	ldw	r3,-12(fp)
 822a4ac:	18c7883a 	add	r3,r3,r3
 822a4b0:	18c7883a 	add	r3,r3,r3
 822a4b4:	10c5883a 	add	r2,r2,r3
 822a4b8:	10800017 	ldw	r2,0(r2)
 822a4bc:	10800a17 	ldw	r2,40(r2)
 822a4c0:	1008d63a 	srli	r4,r2,24
 822a4c4:	008209b4 	movhi	r2,2086
 822a4c8:	10b73a04 	addi	r2,r2,-8984
 822a4cc:	e0fffd17 	ldw	r3,-12(fp)
 822a4d0:	18c7883a 	add	r3,r3,r3
 822a4d4:	18c7883a 	add	r3,r3,r3
 822a4d8:	10c5883a 	add	r2,r2,r3
 822a4dc:	10800017 	ldw	r2,0(r2)
 822a4e0:	10800a17 	ldw	r2,40(r2)
 822a4e4:	1004d23a 	srli	r2,r2,8
 822a4e8:	10bfc00c 	andi	r2,r2,65280
 822a4ec:	2088b03a 	or	r4,r4,r2
 822a4f0:	008209b4 	movhi	r2,2086
 822a4f4:	10b73a04 	addi	r2,r2,-8984
 822a4f8:	e0fffd17 	ldw	r3,-12(fp)
 822a4fc:	18c7883a 	add	r3,r3,r3
 822a500:	18c7883a 	add	r3,r3,r3
 822a504:	10c5883a 	add	r2,r2,r3
 822a508:	10800017 	ldw	r2,0(r2)
 822a50c:	10800a17 	ldw	r2,40(r2)
 822a510:	10bfc00c 	andi	r2,r2,65280
 822a514:	1004923a 	slli	r2,r2,8
 822a518:	2088b03a 	or	r4,r4,r2
 822a51c:	008209b4 	movhi	r2,2086
 822a520:	10b73a04 	addi	r2,r2,-8984
 822a524:	e0fffd17 	ldw	r3,-12(fp)
 822a528:	18c7883a 	add	r3,r3,r3
 822a52c:	18c7883a 	add	r3,r3,r3
 822a530:	10c5883a 	add	r2,r2,r3
 822a534:	10800017 	ldw	r2,0(r2)
 822a538:	10800a17 	ldw	r2,40(r2)
 822a53c:	1004963a 	slli	r2,r2,24
 822a540:	2084b03a 	or	r2,r4,r2
 822a544:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 822a548:	e0bff617 	ldw	r2,-40(fp)
 822a54c:	10c00044 	addi	r3,r2,1
 822a550:	e0fff615 	stw	r3,-40(fp)
 822a554:	00c00c84 	movi	r3,50
 822a558:	10c00005 	stb	r3,0(r2)
 822a55c:	e0bff617 	ldw	r2,-40(fp)
 822a560:	10c00044 	addi	r3,r2,1
 822a564:	e0fff615 	stw	r3,-40(fp)
 822a568:	00c00104 	movi	r3,4
 822a56c:	10c00005 	stb	r3,0(r2)
 822a570:	e0bff617 	ldw	r2,-40(fp)
 822a574:	108000c4 	addi	r2,r2,3
 822a578:	e0fffc04 	addi	r3,fp,-16
 822a57c:	18c00003 	ldbu	r3,0(r3)
 822a580:	10c00005 	stb	r3,0(r2)
 822a584:	e0bff617 	ldw	r2,-40(fp)
 822a588:	10c00084 	addi	r3,r2,2
 822a58c:	e0bffc04 	addi	r2,fp,-16
 822a590:	10800044 	addi	r2,r2,1
 822a594:	10800003 	ldbu	r2,0(r2)
 822a598:	18800005 	stb	r2,0(r3)
 822a59c:	e0bff617 	ldw	r2,-40(fp)
 822a5a0:	10c00044 	addi	r3,r2,1
 822a5a4:	e0bffc04 	addi	r2,fp,-16
 822a5a8:	10800084 	addi	r2,r2,2
 822a5ac:	10800003 	ldbu	r2,0(r2)
 822a5b0:	18800005 	stb	r2,0(r3)
 822a5b4:	e0bffc04 	addi	r2,fp,-16
 822a5b8:	108000c4 	addi	r2,r2,3
 822a5bc:	10800003 	ldbu	r2,0(r2)
 822a5c0:	1007883a 	mov	r3,r2
 822a5c4:	e0bff617 	ldw	r2,-40(fp)
 822a5c8:	10c00005 	stb	r3,0(r2)
 822a5cc:	e0bff617 	ldw	r2,-40(fp)
 822a5d0:	10800104 	addi	r2,r2,4
 822a5d4:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822a5d8:	d0a03517 	ldw	r2,-32556(gp)
 822a5dc:	00801a0e 	bge	zero,r2,822a648 <dhc_discover+0x3a4>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822a5e0:	e0bff617 	ldw	r2,-40(fp)
 822a5e4:	10c00044 	addi	r3,r2,1
 822a5e8:	e0fff615 	stw	r3,-40(fp)
 822a5ec:	00c00dc4 	movi	r3,55
 822a5f0:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822a5f4:	e0bff617 	ldw	r2,-40(fp)
 822a5f8:	10c00044 	addi	r3,r2,1
 822a5fc:	e0fff615 	stw	r3,-40(fp)
 822a600:	d0e03517 	ldw	r3,-32556(gp)
 822a604:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822a608:	e03ff715 	stw	zero,-36(fp)
 822a60c:	00000b06 	br	822a63c <dhc_discover+0x398>
         *opts++ = reqlist[i];
 822a610:	e0bff617 	ldw	r2,-40(fp)
 822a614:	10c00044 	addi	r3,r2,1
 822a618:	e0fff615 	stw	r3,-40(fp)
 822a61c:	e13ff717 	ldw	r4,-36(fp)
 822a620:	d0e03404 	addi	r3,gp,-32560
 822a624:	20c7883a 	add	r3,r4,r3
 822a628:	18c00003 	ldbu	r3,0(r3)
 822a62c:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822a630:	e0bff717 	ldw	r2,-36(fp)
 822a634:	10800044 	addi	r2,r2,1
 822a638:	e0bff715 	stw	r2,-36(fp)
 822a63c:	d0a03517 	ldw	r2,-32556(gp)
 822a640:	e0fff717 	ldw	r3,-36(fp)
 822a644:	18bff216 	blt	r3,r2,822a610 <dhc_discover+0x36c>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 822a648:	e0bff617 	ldw	r2,-40(fp)
 822a64c:	10c00044 	addi	r3,r2,1
 822a650:	e0fff615 	stw	r3,-40(fp)
 822a654:	00ffffc4 	movi	r3,-1
 822a658:	10c00005 	stb	r3,0(r2)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 822a65c:	d0e0a817 	ldw	r3,-32096(gp)
 822a660:	008209b4 	movhi	r2,2086
 822a664:	10b76004 	addi	r2,r2,-8832
 822a668:	e13ffd17 	ldw	r4,-12(fp)
 822a66c:	21000f24 	muli	r4,r4,60
 822a670:	1105883a 	add	r2,r2,r4
 822a674:	10800404 	addi	r2,r2,16
 822a678:	10c00015 	stw	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 822a67c:	e0bff817 	ldw	r2,-32(fp)
 822a680:	00ffffc4 	movi	r3,-1
 822a684:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822a688:	008209b4 	movhi	r2,2086
 822a68c:	10b73a04 	addi	r2,r2,-8984
 822a690:	e0fffd17 	ldw	r3,-12(fp)
 822a694:	18c7883a 	add	r3,r3,r3
 822a698:	18c7883a 	add	r3,r3,r3
 822a69c:	10c5883a 	add	r2,r2,r3
 822a6a0:	10c00017 	ldw	r3,0(r2)
 822a6a4:	e0bff817 	ldw	r2,-32(fp)
 822a6a8:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 822a6ac:	008209b4 	movhi	r2,2086
 822a6b0:	10b76004 	addi	r2,r2,-8832
 822a6b4:	e0fffd17 	ldw	r3,-12(fp)
 822a6b8:	18c00f24 	muli	r3,r3,60
 822a6bc:	10c5883a 	add	r2,r2,r3
 822a6c0:	10800017 	ldw	r2,0(r2)
 822a6c4:	10800120 	cmpeqi	r2,r2,4
 822a6c8:	1000031e 	bne	r2,zero,822a6d8 <dhc_discover+0x434>
      dhc_set_state(iface, DHCS_SELECTING);
 822a6cc:	01400104 	movi	r5,4
 822a6d0:	e13ffd17 	ldw	r4,-12(fp)
 822a6d4:	822c32c0 	call	822c32c <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822a6d8:	e1bff817 	ldw	r6,-32(fp)
 822a6dc:	01401104 	movi	r5,68
 822a6e0:	010010c4 	movi	r4,67
 822a6e4:	8244cf80 	call	8244cf8 <udp_send>
   dsc_discovers++;
 822a6e8:	d0a09117 	ldw	r2,-32188(gp)
 822a6ec:	10800044 	addi	r2,r2,1
 822a6f0:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 822a6f4:	d0e0a817 	ldw	r3,-32096(gp)
 822a6f8:	008209b4 	movhi	r2,2086
 822a6fc:	10b76004 	addi	r2,r2,-8832
 822a700:	e13ffd17 	ldw	r4,-12(fp)
 822a704:	21000f24 	muli	r4,r4,60
 822a708:	1105883a 	add	r2,r2,r4
 822a70c:	10800404 	addi	r2,r2,16
 822a710:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822a714:	008209b4 	movhi	r2,2086
 822a718:	10b76004 	addi	r2,r2,-8832
 822a71c:	e0fffd17 	ldw	r3,-12(fp)
 822a720:	18c00f24 	muli	r3,r3,60
 822a724:	10c5883a 	add	r2,r2,r3
 822a728:	10800104 	addi	r2,r2,4
 822a72c:	10800017 	ldw	r2,0(r2)
 822a730:	10c00044 	addi	r3,r2,1
 822a734:	008209b4 	movhi	r2,2086
 822a738:	10b76004 	addi	r2,r2,-8832
 822a73c:	e13ffd17 	ldw	r4,-12(fp)
 822a740:	21000f24 	muli	r4,r4,60
 822a744:	1105883a 	add	r2,r2,r4
 822a748:	10800104 	addi	r2,r2,4
 822a74c:	10c00015 	stw	r3,0(r2)

   return 0;
 822a750:	0005883a 	mov	r2,zero
}
 822a754:	e6fffe04 	addi	sp,fp,-8
 822a758:	dfc00317 	ldw	ra,12(sp)
 822a75c:	df000217 	ldw	fp,8(sp)
 822a760:	dc400117 	ldw	r17,4(sp)
 822a764:	dc000017 	ldw	r16,0(sp)
 822a768:	dec00404 	addi	sp,sp,16
 822a76c:	f800283a 	ret

0822a770 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 822a770:	defff904 	addi	sp,sp,-28
 822a774:	dfc00615 	stw	ra,24(sp)
 822a778:	df000515 	stw	fp,20(sp)
 822a77c:	df000504 	addi	fp,sp,20
 822a780:	e13ffd15 	stw	r4,-12(fp)
 822a784:	e17ffe15 	stw	r5,-8(fp)
 822a788:	e1bfff15 	stw	r6,-4(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 822a78c:	008209b4 	movhi	r2,2086
 822a790:	10b76004 	addi	r2,r2,-8832
 822a794:	e0fffd17 	ldw	r3,-12(fp)
 822a798:	18c00f24 	muli	r3,r3,60
 822a79c:	10c5883a 	add	r2,r2,r3
 822a7a0:	10800204 	addi	r2,r2,8
 822a7a4:	10c00017 	ldw	r3,0(r2)
 822a7a8:	e0bffe17 	ldw	r2,-8(fp)
 822a7ac:	10800117 	ldw	r2,4(r2)
 822a7b0:	18800226 	beq	r3,r2,822a7bc <dhc_rx_offer+0x4c>
      return ENP_NOT_MINE;
 822a7b4:	00800084 	movi	r2,2
 822a7b8:	00002106 	br	822a840 <dhc_rx_offer+0xd0>

   opts = &bp->options[4];    /* examine options after cookie */
 822a7bc:	e0bffe17 	ldw	r2,-8(fp)
 822a7c0:	10803c04 	addi	r2,r2,240
 822a7c4:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 822a7c8:	e17ffb17 	ldw	r5,-20(fp)
 822a7cc:	e13ffd17 	ldw	r4,-12(fp)
 822a7d0:	822b7ec0 	call	822b7ec <dhc_extract_opts>
 822a7d4:	e0bffc15 	stw	r2,-16(fp)
   if (e)   /* parse error? */
 822a7d8:	e0bffc17 	ldw	r2,-16(fp)
 822a7dc:	10000326 	beq	r2,zero,822a7ec <dhc_rx_offer+0x7c>
   {
      dtrap();
 822a7e0:	822d2e00 	call	822d2e0 <dtrap>
      return e;
 822a7e4:	e0bffc17 	ldw	r2,-16(fp)
 822a7e8:	00001506 	br	822a840 <dhc_rx_offer+0xd0>
   }
   if (!bp->yiaddr)  /* require an IP address */
 822a7ec:	e0bffe17 	ldw	r2,-8(fp)
 822a7f0:	10800417 	ldw	r2,16(r2)
 822a7f4:	1000061e 	bne	r2,zero,822a810 <dhc_rx_offer+0xa0>
   {
      dhc_decline(iface,bp, bplen);
 822a7f8:	e1bfff17 	ldw	r6,-4(fp)
 822a7fc:	e17ffe17 	ldw	r5,-8(fp)
 822a800:	e13ffd17 	ldw	r4,-12(fp)
 822a804:	822b6380 	call	822b638 <dhc_decline>
      return ENP_NOT_MINE;
 822a808:	00800084 	movi	r2,2
 822a80c:	00000c06 	br	822a840 <dhc_rx_offer+0xd0>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 822a810:	e0bffe17 	ldw	r2,-8(fp)
 822a814:	10c00417 	ldw	r3,16(r2)
 822a818:	008209b4 	movhi	r2,2086
 822a81c:	10b76004 	addi	r2,r2,-8832
 822a820:	e13ffd17 	ldw	r4,-12(fp)
 822a824:	21000f24 	muli	r4,r4,60
 822a828:	1105883a 	add	r2,r2,r4
 822a82c:	10800904 	addi	r2,r2,36
 822a830:	10c00015 	stw	r3,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 822a834:	000b883a 	mov	r5,zero
 822a838:	e13ffd17 	ldw	r4,-12(fp)
 822a83c:	822a8540 	call	822a854 <dhc_request>
}
 822a840:	e037883a 	mov	sp,fp
 822a844:	dfc00117 	ldw	ra,4(sp)
 822a848:	df000017 	ldw	fp,0(sp)
 822a84c:	dec00204 	addi	sp,sp,8
 822a850:	f800283a 	ret

0822a854 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 822a854:	defff404 	addi	sp,sp,-48
 822a858:	dfc00b15 	stw	ra,44(sp)
 822a85c:	df000a15 	stw	fp,40(sp)
 822a860:	df000a04 	addi	fp,sp,40
 822a864:	e13ffe15 	stw	r4,-8(fp)
 822a868:	e17fff15 	stw	r5,-4(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 822a86c:	000b883a 	mov	r5,zero
 822a870:	01008904 	movi	r4,548
 822a874:	82451340 	call	8245134 <udp_alloc>
 822a878:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a87c:	e0bff817 	ldw	r2,-32(fp)
 822a880:	1000021e 	bne	r2,zero,822a88c <dhc_request+0x38>
      return ENP_NOMEM;
 822a884:	00bffb04 	movi	r2,-20
 822a888:	00028e06 	br	822b2c4 <dhc_request+0xa70>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 822a88c:	e0bff817 	ldw	r2,-32(fp)
 822a890:	00c03b04 	movi	r3,236
 822a894:	10c00415 	stw	r3,16(r2)

   if ( xid_flag == TRUE )
 822a898:	e0bfff17 	ldw	r2,-4(fp)
 822a89c:	10800058 	cmpnei	r2,r2,1
 822a8a0:	1000121e 	bne	r2,zero,822a8ec <dhc_request+0x98>
   {
      dhc_states[iface].xid  = xids++;
 822a8a4:	d0a03317 	ldw	r2,-32564(gp)
 822a8a8:	10c00044 	addi	r3,r2,1
 822a8ac:	d0e03315 	stw	r3,-32564(gp)
 822a8b0:	1009883a 	mov	r4,r2
 822a8b4:	008209b4 	movhi	r2,2086
 822a8b8:	10b76004 	addi	r2,r2,-8832
 822a8bc:	e0fffe17 	ldw	r3,-8(fp)
 822a8c0:	18c00f24 	muli	r3,r3,60
 822a8c4:	10c5883a 	add	r2,r2,r3
 822a8c8:	10800204 	addi	r2,r2,8
 822a8cc:	11000015 	stw	r4,0(r2)
      dhc_states[iface].secs = 0;
 822a8d0:	008209b4 	movhi	r2,2086
 822a8d4:	10b76004 	addi	r2,r2,-8832
 822a8d8:	e0fffe17 	ldw	r3,-8(fp)
 822a8dc:	18c00f24 	muli	r3,r3,60
 822a8e0:	10c5883a 	add	r2,r2,r3
 822a8e4:	10800304 	addi	r2,r2,12
 822a8e8:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 822a8ec:	e0bff817 	ldw	r2,-32(fp)
 822a8f0:	10800317 	ldw	r2,12(r2)
 822a8f4:	e0bff915 	stw	r2,-28(fp)
   e     = dhc_buildheader(iface,outbp);
 822a8f8:	e17ff917 	ldw	r5,-28(fp)
 822a8fc:	e13ffe17 	ldw	r4,-8(fp)
 822a900:	822a0c00 	call	822a0c0 <dhc_buildheader>
 822a904:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822a908:	e0bffa17 	ldw	r2,-24(fp)
 822a90c:	10000226 	beq	r2,zero,822a918 <dhc_request+0xc4>
      return e;
 822a910:	e0bffa17 	ldw	r2,-24(fp)
 822a914:	00026b06 	br	822b2c4 <dhc_request+0xa70>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a918:	e0bff917 	ldw	r2,-28(fp)
 822a91c:	10c03b04 	addi	r3,r2,236
 822a920:	0098d534 	movhi	r2,25428
 822a924:	10a098c4 	addi	r2,r2,-32157
 822a928:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 822a92c:	e0bff917 	ldw	r2,-28(fp)
 822a930:	10803c04 	addi	r2,r2,240
 822a934:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822a938:	e0bff617 	ldw	r2,-40(fp)
 822a93c:	10c00044 	addi	r3,r2,1
 822a940:	e0fff615 	stw	r3,-40(fp)
 822a944:	00c00d44 	movi	r3,53
 822a948:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a94c:	e0bff617 	ldw	r2,-40(fp)
 822a950:	10c00044 	addi	r3,r2,1
 822a954:	e0fff615 	stw	r3,-40(fp)
 822a958:	00c00044 	movi	r3,1
 822a95c:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_REQUEST;
 822a960:	e0bff617 	ldw	r2,-40(fp)
 822a964:	10c00044 	addi	r3,r2,1
 822a968:	e0fff615 	stw	r3,-40(fp)
 822a96c:	00c000c4 	movi	r3,3
 822a970:	10c00005 	stb	r3,0(r2)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822a974:	008209b4 	movhi	r2,2086
 822a978:	10b76004 	addi	r2,r2,-8832
 822a97c:	e0fffe17 	ldw	r3,-8(fp)
 822a980:	18c00f24 	muli	r3,r3,60
 822a984:	10c5883a 	add	r2,r2,r3
 822a988:	10800017 	ldw	r2,0(r2)
 822a98c:	10800120 	cmpeqi	r2,r2,4
 822a990:	1000181e 	bne	r2,zero,822a9f4 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822a994:	008209b4 	movhi	r2,2086
 822a998:	10b76004 	addi	r2,r2,-8832
 822a99c:	e0fffe17 	ldw	r3,-8(fp)
 822a9a0:	18c00f24 	muli	r3,r3,60
 822a9a4:	10c5883a 	add	r2,r2,r3
 822a9a8:	10800017 	ldw	r2,0(r2)
   *opts++ = DHOP_TYPE;
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822a9ac:	10800160 	cmpeqi	r2,r2,5
 822a9b0:	1000101e 	bne	r2,zero,822a9f4 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822a9b4:	008209b4 	movhi	r2,2086
 822a9b8:	10b76004 	addi	r2,r2,-8832
 822a9bc:	e0fffe17 	ldw	r3,-8(fp)
 822a9c0:	18c00f24 	muli	r3,r3,60
 822a9c4:	10c5883a 	add	r2,r2,r3
 822a9c8:	10800017 	ldw	r2,0(r2)
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822a9cc:	108000e0 	cmpeqi	r2,r2,3
 822a9d0:	1000081e 	bne	r2,zero,822a9f4 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
 822a9d4:	008209b4 	movhi	r2,2086
 822a9d8:	10b76004 	addi	r2,r2,-8832
 822a9dc:	e0fffe17 	ldw	r3,-8(fp)
 822a9e0:	18c00f24 	muli	r3,r3,60
 822a9e4:	10c5883a 	add	r2,r2,r3
 822a9e8:	10800017 	ldw	r2,0(r2)
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822a9ec:	10800098 	cmpnei	r2,r2,2
 822a9f0:	10004a1e 	bne	r2,zero,822ab1c <dhc_request+0x2c8>
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 822a9f4:	008209b4 	movhi	r2,2086
 822a9f8:	10b76004 	addi	r2,r2,-8832
 822a9fc:	e0fffe17 	ldw	r3,-8(fp)
 822aa00:	18c00f24 	muli	r3,r3,60
 822aa04:	10c5883a 	add	r2,r2,r3
 822aa08:	10800904 	addi	r2,r2,36
 822aa0c:	10800017 	ldw	r2,0(r2)
 822aa10:	1006d63a 	srli	r3,r2,24
 822aa14:	008209b4 	movhi	r2,2086
 822aa18:	10b76004 	addi	r2,r2,-8832
 822aa1c:	e13ffe17 	ldw	r4,-8(fp)
 822aa20:	21000f24 	muli	r4,r4,60
 822aa24:	1105883a 	add	r2,r2,r4
 822aa28:	10800904 	addi	r2,r2,36
 822aa2c:	10800017 	ldw	r2,0(r2)
 822aa30:	1004d23a 	srli	r2,r2,8
 822aa34:	10bfc00c 	andi	r2,r2,65280
 822aa38:	1886b03a 	or	r3,r3,r2
 822aa3c:	008209b4 	movhi	r2,2086
 822aa40:	10b76004 	addi	r2,r2,-8832
 822aa44:	e13ffe17 	ldw	r4,-8(fp)
 822aa48:	21000f24 	muli	r4,r4,60
 822aa4c:	1105883a 	add	r2,r2,r4
 822aa50:	10800904 	addi	r2,r2,36
 822aa54:	10800017 	ldw	r2,0(r2)
 822aa58:	10bfc00c 	andi	r2,r2,65280
 822aa5c:	1004923a 	slli	r2,r2,8
 822aa60:	1886b03a 	or	r3,r3,r2
 822aa64:	008209b4 	movhi	r2,2086
 822aa68:	10b76004 	addi	r2,r2,-8832
 822aa6c:	e13ffe17 	ldw	r4,-8(fp)
 822aa70:	21000f24 	muli	r4,r4,60
 822aa74:	1105883a 	add	r2,r2,r4
 822aa78:	10800904 	addi	r2,r2,36
 822aa7c:	10800017 	ldw	r2,0(r2)
 822aa80:	1004963a 	slli	r2,r2,24
 822aa84:	1884b03a 	or	r2,r3,r2
 822aa88:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 822aa8c:	e0bff617 	ldw	r2,-40(fp)
 822aa90:	10c00044 	addi	r3,r2,1
 822aa94:	e0fff615 	stw	r3,-40(fp)
 822aa98:	00c00c84 	movi	r3,50
 822aa9c:	10c00005 	stb	r3,0(r2)
 822aaa0:	e0bff617 	ldw	r2,-40(fp)
 822aaa4:	10c00044 	addi	r3,r2,1
 822aaa8:	e0fff615 	stw	r3,-40(fp)
 822aaac:	00c00104 	movi	r3,4
 822aab0:	10c00005 	stb	r3,0(r2)
 822aab4:	e0bff617 	ldw	r2,-40(fp)
 822aab8:	108000c4 	addi	r2,r2,3
 822aabc:	e0fffd04 	addi	r3,fp,-12
 822aac0:	18c00003 	ldbu	r3,0(r3)
 822aac4:	10c00005 	stb	r3,0(r2)
 822aac8:	e0bff617 	ldw	r2,-40(fp)
 822aacc:	10c00084 	addi	r3,r2,2
 822aad0:	e0bffd04 	addi	r2,fp,-12
 822aad4:	10800044 	addi	r2,r2,1
 822aad8:	10800003 	ldbu	r2,0(r2)
 822aadc:	18800005 	stb	r2,0(r3)
 822aae0:	e0bff617 	ldw	r2,-40(fp)
 822aae4:	10c00044 	addi	r3,r2,1
 822aae8:	e0bffd04 	addi	r2,fp,-12
 822aaec:	10800084 	addi	r2,r2,2
 822aaf0:	10800003 	ldbu	r2,0(r2)
 822aaf4:	18800005 	stb	r2,0(r3)
 822aaf8:	e0bffd04 	addi	r2,fp,-12
 822aafc:	108000c4 	addi	r2,r2,3
 822ab00:	10800003 	ldbu	r2,0(r2)
 822ab04:	1007883a 	mov	r3,r2
 822ab08:	e0bff617 	ldw	r2,-40(fp)
 822ab0c:	10c00005 	stb	r3,0(r2)
 822ab10:	e0bff617 	ldw	r2,-40(fp)
 822ab14:	10800104 	addi	r2,r2,4
 822ab18:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].snmask)
 822ab1c:	008209b4 	movhi	r2,2086
 822ab20:	10b76004 	addi	r2,r2,-8832
 822ab24:	e0fffe17 	ldw	r3,-8(fp)
 822ab28:	18c00f24 	muli	r3,r3,60
 822ab2c:	10c5883a 	add	r2,r2,r3
 822ab30:	10800a04 	addi	r2,r2,40
 822ab34:	10800017 	ldw	r2,0(r2)
 822ab38:	10004a26 	beq	r2,zero,822ac64 <dhc_request+0x410>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 822ab3c:	008209b4 	movhi	r2,2086
 822ab40:	10b76004 	addi	r2,r2,-8832
 822ab44:	e0fffe17 	ldw	r3,-8(fp)
 822ab48:	18c00f24 	muli	r3,r3,60
 822ab4c:	10c5883a 	add	r2,r2,r3
 822ab50:	10800a04 	addi	r2,r2,40
 822ab54:	10800017 	ldw	r2,0(r2)
 822ab58:	1006d63a 	srli	r3,r2,24
 822ab5c:	008209b4 	movhi	r2,2086
 822ab60:	10b76004 	addi	r2,r2,-8832
 822ab64:	e13ffe17 	ldw	r4,-8(fp)
 822ab68:	21000f24 	muli	r4,r4,60
 822ab6c:	1105883a 	add	r2,r2,r4
 822ab70:	10800a04 	addi	r2,r2,40
 822ab74:	10800017 	ldw	r2,0(r2)
 822ab78:	1004d23a 	srli	r2,r2,8
 822ab7c:	10bfc00c 	andi	r2,r2,65280
 822ab80:	1886b03a 	or	r3,r3,r2
 822ab84:	008209b4 	movhi	r2,2086
 822ab88:	10b76004 	addi	r2,r2,-8832
 822ab8c:	e13ffe17 	ldw	r4,-8(fp)
 822ab90:	21000f24 	muli	r4,r4,60
 822ab94:	1105883a 	add	r2,r2,r4
 822ab98:	10800a04 	addi	r2,r2,40
 822ab9c:	10800017 	ldw	r2,0(r2)
 822aba0:	10bfc00c 	andi	r2,r2,65280
 822aba4:	1004923a 	slli	r2,r2,8
 822aba8:	1886b03a 	or	r3,r3,r2
 822abac:	008209b4 	movhi	r2,2086
 822abb0:	10b76004 	addi	r2,r2,-8832
 822abb4:	e13ffe17 	ldw	r4,-8(fp)
 822abb8:	21000f24 	muli	r4,r4,60
 822abbc:	1105883a 	add	r2,r2,r4
 822abc0:	10800a04 	addi	r2,r2,40
 822abc4:	10800017 	ldw	r2,0(r2)
 822abc8:	1004963a 	slli	r2,r2,24
 822abcc:	1884b03a 	or	r2,r3,r2
 822abd0:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 822abd4:	e0bff617 	ldw	r2,-40(fp)
 822abd8:	10c00044 	addi	r3,r2,1
 822abdc:	e0fff615 	stw	r3,-40(fp)
 822abe0:	00c00044 	movi	r3,1
 822abe4:	10c00005 	stb	r3,0(r2)
 822abe8:	e0bff617 	ldw	r2,-40(fp)
 822abec:	10c00044 	addi	r3,r2,1
 822abf0:	e0fff615 	stw	r3,-40(fp)
 822abf4:	00c00104 	movi	r3,4
 822abf8:	10c00005 	stb	r3,0(r2)
 822abfc:	e0bff617 	ldw	r2,-40(fp)
 822ac00:	108000c4 	addi	r2,r2,3
 822ac04:	e0fffd04 	addi	r3,fp,-12
 822ac08:	18c00003 	ldbu	r3,0(r3)
 822ac0c:	10c00005 	stb	r3,0(r2)
 822ac10:	e0bff617 	ldw	r2,-40(fp)
 822ac14:	10c00084 	addi	r3,r2,2
 822ac18:	e0bffd04 	addi	r2,fp,-12
 822ac1c:	10800044 	addi	r2,r2,1
 822ac20:	10800003 	ldbu	r2,0(r2)
 822ac24:	18800005 	stb	r2,0(r3)
 822ac28:	e0bff617 	ldw	r2,-40(fp)
 822ac2c:	10c00044 	addi	r3,r2,1
 822ac30:	e0bffd04 	addi	r2,fp,-12
 822ac34:	10800084 	addi	r2,r2,2
 822ac38:	10800003 	ldbu	r2,0(r2)
 822ac3c:	18800005 	stb	r2,0(r3)
 822ac40:	e0bffd04 	addi	r2,fp,-12
 822ac44:	108000c4 	addi	r2,r2,3
 822ac48:	10800003 	ldbu	r2,0(r2)
 822ac4c:	1007883a 	mov	r3,r2
 822ac50:	e0bff617 	ldw	r2,-40(fp)
 822ac54:	10c00005 	stb	r3,0(r2)
 822ac58:	e0bff617 	ldw	r2,-40(fp)
 822ac5c:	10800104 	addi	r2,r2,4
 822ac60:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].defgw)
 822ac64:	008209b4 	movhi	r2,2086
 822ac68:	10b76004 	addi	r2,r2,-8832
 822ac6c:	e0fffe17 	ldw	r3,-8(fp)
 822ac70:	18c00f24 	muli	r3,r3,60
 822ac74:	10c5883a 	add	r2,r2,r3
 822ac78:	10800b04 	addi	r2,r2,44
 822ac7c:	10800017 	ldw	r2,0(r2)
 822ac80:	10004a26 	beq	r2,zero,822adac <dhc_request+0x558>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 822ac84:	008209b4 	movhi	r2,2086
 822ac88:	10b76004 	addi	r2,r2,-8832
 822ac8c:	e0fffe17 	ldw	r3,-8(fp)
 822ac90:	18c00f24 	muli	r3,r3,60
 822ac94:	10c5883a 	add	r2,r2,r3
 822ac98:	10800b04 	addi	r2,r2,44
 822ac9c:	10800017 	ldw	r2,0(r2)
 822aca0:	1006d63a 	srli	r3,r2,24
 822aca4:	008209b4 	movhi	r2,2086
 822aca8:	10b76004 	addi	r2,r2,-8832
 822acac:	e13ffe17 	ldw	r4,-8(fp)
 822acb0:	21000f24 	muli	r4,r4,60
 822acb4:	1105883a 	add	r2,r2,r4
 822acb8:	10800b04 	addi	r2,r2,44
 822acbc:	10800017 	ldw	r2,0(r2)
 822acc0:	1004d23a 	srli	r2,r2,8
 822acc4:	10bfc00c 	andi	r2,r2,65280
 822acc8:	1886b03a 	or	r3,r3,r2
 822accc:	008209b4 	movhi	r2,2086
 822acd0:	10b76004 	addi	r2,r2,-8832
 822acd4:	e13ffe17 	ldw	r4,-8(fp)
 822acd8:	21000f24 	muli	r4,r4,60
 822acdc:	1105883a 	add	r2,r2,r4
 822ace0:	10800b04 	addi	r2,r2,44
 822ace4:	10800017 	ldw	r2,0(r2)
 822ace8:	10bfc00c 	andi	r2,r2,65280
 822acec:	1004923a 	slli	r2,r2,8
 822acf0:	1886b03a 	or	r3,r3,r2
 822acf4:	008209b4 	movhi	r2,2086
 822acf8:	10b76004 	addi	r2,r2,-8832
 822acfc:	e13ffe17 	ldw	r4,-8(fp)
 822ad00:	21000f24 	muli	r4,r4,60
 822ad04:	1105883a 	add	r2,r2,r4
 822ad08:	10800b04 	addi	r2,r2,44
 822ad0c:	10800017 	ldw	r2,0(r2)
 822ad10:	1004963a 	slli	r2,r2,24
 822ad14:	1884b03a 	or	r2,r3,r2
 822ad18:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 822ad1c:	e0bff617 	ldw	r2,-40(fp)
 822ad20:	10c00044 	addi	r3,r2,1
 822ad24:	e0fff615 	stw	r3,-40(fp)
 822ad28:	00c000c4 	movi	r3,3
 822ad2c:	10c00005 	stb	r3,0(r2)
 822ad30:	e0bff617 	ldw	r2,-40(fp)
 822ad34:	10c00044 	addi	r3,r2,1
 822ad38:	e0fff615 	stw	r3,-40(fp)
 822ad3c:	00c00104 	movi	r3,4
 822ad40:	10c00005 	stb	r3,0(r2)
 822ad44:	e0bff617 	ldw	r2,-40(fp)
 822ad48:	108000c4 	addi	r2,r2,3
 822ad4c:	e0fffd04 	addi	r3,fp,-12
 822ad50:	18c00003 	ldbu	r3,0(r3)
 822ad54:	10c00005 	stb	r3,0(r2)
 822ad58:	e0bff617 	ldw	r2,-40(fp)
 822ad5c:	10c00084 	addi	r3,r2,2
 822ad60:	e0bffd04 	addi	r2,fp,-12
 822ad64:	10800044 	addi	r2,r2,1
 822ad68:	10800003 	ldbu	r2,0(r2)
 822ad6c:	18800005 	stb	r2,0(r3)
 822ad70:	e0bff617 	ldw	r2,-40(fp)
 822ad74:	10c00044 	addi	r3,r2,1
 822ad78:	e0bffd04 	addi	r2,fp,-12
 822ad7c:	10800084 	addi	r2,r2,2
 822ad80:	10800003 	ldbu	r2,0(r2)
 822ad84:	18800005 	stb	r2,0(r3)
 822ad88:	e0bffd04 	addi	r2,fp,-12
 822ad8c:	108000c4 	addi	r2,r2,3
 822ad90:	10800003 	ldbu	r2,0(r2)
 822ad94:	1007883a 	mov	r3,r2
 822ad98:	e0bff617 	ldw	r2,-40(fp)
 822ad9c:	10c00005 	stb	r3,0(r2)
 822ada0:	e0bff617 	ldw	r2,-40(fp)
 822ada4:	10800104 	addi	r2,r2,4
 822ada8:	e0bff615 	stw	r2,-40(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 822adac:	008209b4 	movhi	r2,2086
 822adb0:	10b76004 	addi	r2,r2,-8832
 822adb4:	e0fffe17 	ldw	r3,-8(fp)
 822adb8:	18c00f24 	muli	r3,r3,60
 822adbc:	10c5883a 	add	r2,r2,r3
 822adc0:	10800504 	addi	r2,r2,20
 822adc4:	10800017 	ldw	r2,0(r2)
 822adc8:	10003826 	beq	r2,zero,822aeac <dhc_request+0x658>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 822adcc:	e0bff617 	ldw	r2,-40(fp)
 822add0:	10c00044 	addi	r3,r2,1
 822add4:	e0fff615 	stw	r3,-40(fp)
 822add8:	00c00cc4 	movi	r3,51
 822addc:	10c00005 	stb	r3,0(r2)
 822ade0:	e0bff617 	ldw	r2,-40(fp)
 822ade4:	10c00044 	addi	r3,r2,1
 822ade8:	e0fff615 	stw	r3,-40(fp)
 822adec:	00c00104 	movi	r3,4
 822adf0:	10c00005 	stb	r3,0(r2)
 822adf4:	e0bff617 	ldw	r2,-40(fp)
 822adf8:	10c000c4 	addi	r3,r2,3
 822adfc:	e0bffe17 	ldw	r2,-8(fp)
 822ae00:	10800f24 	muli	r2,r2,60
 822ae04:	11000504 	addi	r4,r2,20
 822ae08:	008209b4 	movhi	r2,2086
 822ae0c:	10b76004 	addi	r2,r2,-8832
 822ae10:	2085883a 	add	r2,r4,r2
 822ae14:	10800003 	ldbu	r2,0(r2)
 822ae18:	18800005 	stb	r2,0(r3)
 822ae1c:	e0bff617 	ldw	r2,-40(fp)
 822ae20:	10c00084 	addi	r3,r2,2
 822ae24:	e0bffe17 	ldw	r2,-8(fp)
 822ae28:	10800f24 	muli	r2,r2,60
 822ae2c:	11000504 	addi	r4,r2,20
 822ae30:	008209b4 	movhi	r2,2086
 822ae34:	10b76004 	addi	r2,r2,-8832
 822ae38:	2085883a 	add	r2,r4,r2
 822ae3c:	10800044 	addi	r2,r2,1
 822ae40:	10800003 	ldbu	r2,0(r2)
 822ae44:	18800005 	stb	r2,0(r3)
 822ae48:	e0bff617 	ldw	r2,-40(fp)
 822ae4c:	10c00044 	addi	r3,r2,1
 822ae50:	e0bffe17 	ldw	r2,-8(fp)
 822ae54:	10800f24 	muli	r2,r2,60
 822ae58:	11000504 	addi	r4,r2,20
 822ae5c:	008209b4 	movhi	r2,2086
 822ae60:	10b76004 	addi	r2,r2,-8832
 822ae64:	2085883a 	add	r2,r4,r2
 822ae68:	10800084 	addi	r2,r2,2
 822ae6c:	10800003 	ldbu	r2,0(r2)
 822ae70:	18800005 	stb	r2,0(r3)
 822ae74:	e0bffe17 	ldw	r2,-8(fp)
 822ae78:	10800f24 	muli	r2,r2,60
 822ae7c:	10c00504 	addi	r3,r2,20
 822ae80:	008209b4 	movhi	r2,2086
 822ae84:	10b76004 	addi	r2,r2,-8832
 822ae88:	1885883a 	add	r2,r3,r2
 822ae8c:	108000c4 	addi	r2,r2,3
 822ae90:	10800003 	ldbu	r2,0(r2)
 822ae94:	1007883a 	mov	r3,r2
 822ae98:	e0bff617 	ldw	r2,-40(fp)
 822ae9c:	10c00005 	stb	r3,0(r2)
 822aea0:	e0bff617 	ldw	r2,-40(fp)
 822aea4:	10800104 	addi	r2,r2,4
 822aea8:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822aeac:	d0a03517 	ldw	r2,-32556(gp)
 822aeb0:	00801a0e 	bge	zero,r2,822af1c <dhc_request+0x6c8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822aeb4:	e0bff617 	ldw	r2,-40(fp)
 822aeb8:	10c00044 	addi	r3,r2,1
 822aebc:	e0fff615 	stw	r3,-40(fp)
 822aec0:	00c00dc4 	movi	r3,55
 822aec4:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822aec8:	e0bff617 	ldw	r2,-40(fp)
 822aecc:	10c00044 	addi	r3,r2,1
 822aed0:	e0fff615 	stw	r3,-40(fp)
 822aed4:	d0e03517 	ldw	r3,-32556(gp)
 822aed8:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822aedc:	e03ff715 	stw	zero,-36(fp)
 822aee0:	00000b06 	br	822af10 <dhc_request+0x6bc>
         *opts++ = reqlist[i];
 822aee4:	e0bff617 	ldw	r2,-40(fp)
 822aee8:	10c00044 	addi	r3,r2,1
 822aeec:	e0fff615 	stw	r3,-40(fp)
 822aef0:	e13ff717 	ldw	r4,-36(fp)
 822aef4:	d0e03404 	addi	r3,gp,-32560
 822aef8:	20c7883a 	add	r3,r4,r3
 822aefc:	18c00003 	ldbu	r3,0(r3)
 822af00:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822af04:	e0bff717 	ldw	r2,-36(fp)
 822af08:	10800044 	addi	r2,r2,1
 822af0c:	e0bff715 	stw	r2,-36(fp)
 822af10:	d0a03517 	ldw	r2,-32556(gp)
 822af14:	e0fff717 	ldw	r3,-36(fp)
 822af18:	18bff216 	blt	r3,r2,822aee4 <dhc_request+0x690>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 822af1c:	008209b4 	movhi	r2,2086
 822af20:	10b76004 	addi	r2,r2,-8832
 822af24:	e0fffe17 	ldw	r3,-8(fp)
 822af28:	18c00f24 	muli	r3,r3,60
 822af2c:	10c5883a 	add	r2,r2,r3
 822af30:	10800017 	ldw	r2,0(r2)
 822af34:	108001e0 	cmpeqi	r2,r2,7
 822af38:	1000081e 	bne	r2,zero,822af5c <dhc_request+0x708>
       || (dhc_states[iface].state == DHCS_REBINDING))
 822af3c:	008209b4 	movhi	r2,2086
 822af40:	10b76004 	addi	r2,r2,-8832
 822af44:	e0fffe17 	ldw	r3,-8(fp)
 822af48:	18c00f24 	muli	r3,r3,60
 822af4c:	10c5883a 	add	r2,r2,r3
 822af50:	10800017 	ldw	r2,0(r2)
 822af54:	10800218 	cmpnei	r2,r2,8
 822af58:	10000a1e 	bne	r2,zero,822af84 <dhc_request+0x730>
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 822af5c:	008209b4 	movhi	r2,2086
 822af60:	10b73a04 	addi	r2,r2,-8984
 822af64:	e0fffe17 	ldw	r3,-8(fp)
 822af68:	18c7883a 	add	r3,r3,r3
 822af6c:	18c7883a 	add	r3,r3,r3
 822af70:	10c5883a 	add	r2,r2,r3
 822af74:	10800017 	ldw	r2,0(r2)
 822af78:	10c00a17 	ldw	r3,40(r2)
 822af7c:	e0bff917 	ldw	r2,-28(fp)
 822af80:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822af84:	008209b4 	movhi	r2,2086
 822af88:	10b76004 	addi	r2,r2,-8832
 822af8c:	e0fffe17 	ldw	r3,-8(fp)
 822af90:	18c00f24 	muli	r3,r3,60
 822af94:	10c5883a 	add	r2,r2,r3
 822af98:	10800017 	ldw	r2,0(r2)
 822af9c:	10800120 	cmpeqi	r2,r2,4
 822afa0:	1000081e 	bne	r2,zero,822afc4 <dhc_request+0x770>
       (dhc_states[iface].state == DHCS_REQUESTING))
 822afa4:	008209b4 	movhi	r2,2086
 822afa8:	10b76004 	addi	r2,r2,-8832
 822afac:	e0fffe17 	ldw	r3,-8(fp)
 822afb0:	18c00f24 	muli	r3,r3,60
 822afb4:	10c5883a 	add	r2,r2,r3
 822afb8:	10800017 	ldw	r2,0(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822afbc:	10800158 	cmpnei	r2,r2,5
 822afc0:	10004a1e 	bne	r2,zero,822b0ec <dhc_request+0x898>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 822afc4:	008209b4 	movhi	r2,2086
 822afc8:	10b76004 	addi	r2,r2,-8832
 822afcc:	e0fffe17 	ldw	r3,-8(fp)
 822afd0:	18c00f24 	muli	r3,r3,60
 822afd4:	10c5883a 	add	r2,r2,r3
 822afd8:	10800d04 	addi	r2,r2,52
 822afdc:	10800017 	ldw	r2,0(r2)
 822afe0:	1006d63a 	srli	r3,r2,24
 822afe4:	008209b4 	movhi	r2,2086
 822afe8:	10b76004 	addi	r2,r2,-8832
 822afec:	e13ffe17 	ldw	r4,-8(fp)
 822aff0:	21000f24 	muli	r4,r4,60
 822aff4:	1105883a 	add	r2,r2,r4
 822aff8:	10800d04 	addi	r2,r2,52
 822affc:	10800017 	ldw	r2,0(r2)
 822b000:	1004d23a 	srli	r2,r2,8
 822b004:	10bfc00c 	andi	r2,r2,65280
 822b008:	1886b03a 	or	r3,r3,r2
 822b00c:	008209b4 	movhi	r2,2086
 822b010:	10b76004 	addi	r2,r2,-8832
 822b014:	e13ffe17 	ldw	r4,-8(fp)
 822b018:	21000f24 	muli	r4,r4,60
 822b01c:	1105883a 	add	r2,r2,r4
 822b020:	10800d04 	addi	r2,r2,52
 822b024:	10800017 	ldw	r2,0(r2)
 822b028:	10bfc00c 	andi	r2,r2,65280
 822b02c:	1004923a 	slli	r2,r2,8
 822b030:	1886b03a 	or	r3,r3,r2
 822b034:	008209b4 	movhi	r2,2086
 822b038:	10b76004 	addi	r2,r2,-8832
 822b03c:	e13ffe17 	ldw	r4,-8(fp)
 822b040:	21000f24 	muli	r4,r4,60
 822b044:	1105883a 	add	r2,r2,r4
 822b048:	10800d04 	addi	r2,r2,52
 822b04c:	10800017 	ldw	r2,0(r2)
 822b050:	1004963a 	slli	r2,r2,24
 822b054:	1884b03a 	or	r2,r3,r2
 822b058:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 822b05c:	e0bff617 	ldw	r2,-40(fp)
 822b060:	10c00044 	addi	r3,r2,1
 822b064:	e0fff615 	stw	r3,-40(fp)
 822b068:	00c00d84 	movi	r3,54
 822b06c:	10c00005 	stb	r3,0(r2)
 822b070:	e0bff617 	ldw	r2,-40(fp)
 822b074:	10c00044 	addi	r3,r2,1
 822b078:	e0fff615 	stw	r3,-40(fp)
 822b07c:	00c00104 	movi	r3,4
 822b080:	10c00005 	stb	r3,0(r2)
 822b084:	e0bff617 	ldw	r2,-40(fp)
 822b088:	108000c4 	addi	r2,r2,3
 822b08c:	e0fffd04 	addi	r3,fp,-12
 822b090:	18c00003 	ldbu	r3,0(r3)
 822b094:	10c00005 	stb	r3,0(r2)
 822b098:	e0bff617 	ldw	r2,-40(fp)
 822b09c:	10c00084 	addi	r3,r2,2
 822b0a0:	e0bffd04 	addi	r2,fp,-12
 822b0a4:	10800044 	addi	r2,r2,1
 822b0a8:	10800003 	ldbu	r2,0(r2)
 822b0ac:	18800005 	stb	r2,0(r3)
 822b0b0:	e0bff617 	ldw	r2,-40(fp)
 822b0b4:	10c00044 	addi	r3,r2,1
 822b0b8:	e0bffd04 	addi	r2,fp,-12
 822b0bc:	10800084 	addi	r2,r2,2
 822b0c0:	10800003 	ldbu	r2,0(r2)
 822b0c4:	18800005 	stb	r2,0(r3)
 822b0c8:	e0bffd04 	addi	r2,fp,-12
 822b0cc:	108000c4 	addi	r2,r2,3
 822b0d0:	10800003 	ldbu	r2,0(r2)
 822b0d4:	1007883a 	mov	r3,r2
 822b0d8:	e0bff617 	ldw	r2,-40(fp)
 822b0dc:	10c00005 	stb	r3,0(r2)
 822b0e0:	e0bff617 	ldw	r2,-40(fp)
 822b0e4:	10800104 	addi	r2,r2,4
 822b0e8:	e0bff615 	stw	r2,-40(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 822b0ec:	e0bff617 	ldw	r2,-40(fp)
 822b0f0:	10c00044 	addi	r3,r2,1
 822b0f4:	e0fff615 	stw	r3,-40(fp)
 822b0f8:	00c01444 	movi	r3,81
 822b0fc:	10c00005 	stb	r3,0(r2)
 822b100:	00800184 	movi	r2,6
 822b104:	e0bffb15 	stw	r2,-20(fp)
 822b108:	e0bff617 	ldw	r2,-40(fp)
 822b10c:	10c00044 	addi	r3,r2,1
 822b110:	e0fff615 	stw	r3,-40(fp)
 822b114:	e0fffb17 	ldw	r3,-20(fp)
 822b118:	10c00005 	stb	r3,0(r2)
 822b11c:	e0bffb17 	ldw	r2,-20(fp)
 822b120:	100d883a 	mov	r6,r2
 822b124:	01420974 	movhi	r5,2085
 822b128:	29413804 	addi	r5,r5,1248
 822b12c:	e13ff617 	ldw	r4,-40(fp)
 822b130:	824b5640 	call	824b564 <strncpy>
 822b134:	e0bffb17 	ldw	r2,-20(fp)
 822b138:	e0fff617 	ldw	r3,-40(fp)
 822b13c:	1885883a 	add	r2,r3,r2
 822b140:	e0bff615 	stw	r2,-40(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 822b144:	e0bff617 	ldw	r2,-40(fp)
 822b148:	10c00044 	addi	r3,r2,1
 822b14c:	e0fff615 	stw	r3,-40(fp)
 822b150:	00c00f04 	movi	r3,60
 822b154:	10c00005 	stb	r3,0(r2)
 822b158:	d0a04b17 	ldw	r2,-32468(gp)
 822b15c:	1009883a 	mov	r4,r2
 822b160:	8203cac0 	call	8203cac <strlen>
 822b164:	e0bffc15 	stw	r2,-16(fp)
 822b168:	e0bff617 	ldw	r2,-40(fp)
 822b16c:	10c00044 	addi	r3,r2,1
 822b170:	e0fff615 	stw	r3,-40(fp)
 822b174:	e0fffc17 	ldw	r3,-16(fp)
 822b178:	10c00005 	stb	r3,0(r2)
 822b17c:	d0a04b17 	ldw	r2,-32468(gp)
 822b180:	e0fffc17 	ldw	r3,-16(fp)
 822b184:	180d883a 	mov	r6,r3
 822b188:	100b883a 	mov	r5,r2
 822b18c:	e13ff617 	ldw	r4,-40(fp)
 822b190:	824b5640 	call	824b564 <strncpy>
 822b194:	e0bffc17 	ldw	r2,-16(fp)
 822b198:	e0fff617 	ldw	r3,-40(fp)
 822b19c:	1885883a 	add	r2,r3,r2
 822b1a0:	e0bff615 	stw	r2,-40(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 822b1a4:	e0bff617 	ldw	r2,-40(fp)
 822b1a8:	10c00044 	addi	r3,r2,1
 822b1ac:	e0fff615 	stw	r3,-40(fp)
 822b1b0:	00ffffc4 	movi	r3,-1
 822b1b4:	10c00005 	stb	r3,0(r2)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 822b1b8:	008209b4 	movhi	r2,2086
 822b1bc:	10b76004 	addi	r2,r2,-8832
 822b1c0:	e0fffe17 	ldw	r3,-8(fp)
 822b1c4:	18c00f24 	muli	r3,r3,60
 822b1c8:	10c5883a 	add	r2,r2,r3
 822b1cc:	10800017 	ldw	r2,0(r2)
 822b1d0:	108001d8 	cmpnei	r2,r2,7
 822b1d4:	10000a1e 	bne	r2,zero,822b200 <dhc_request+0x9ac>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 822b1d8:	008209b4 	movhi	r2,2086
 822b1dc:	10b76004 	addi	r2,r2,-8832
 822b1e0:	e0fffe17 	ldw	r3,-8(fp)
 822b1e4:	18c00f24 	muli	r3,r3,60
 822b1e8:	10c5883a 	add	r2,r2,r3
 822b1ec:	10800d04 	addi	r2,r2,52
 822b1f0:	10c00017 	ldw	r3,0(r2)
 822b1f4:	e0bff817 	ldw	r2,-32(fp)
 822b1f8:	10c00715 	stw	r3,28(r2)
 822b1fc:	00000306 	br	822b20c <dhc_request+0x9b8>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 822b200:	e0bff817 	ldw	r2,-32(fp)
 822b204:	00ffffc4 	movi	r3,-1
 822b208:	10c00715 	stw	r3,28(r2)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822b20c:	008209b4 	movhi	r2,2086
 822b210:	10b73a04 	addi	r2,r2,-8984
 822b214:	e0fffe17 	ldw	r3,-8(fp)
 822b218:	18c7883a 	add	r3,r3,r3
 822b21c:	18c7883a 	add	r3,r3,r3
 822b220:	10c5883a 	add	r2,r2,r3
 822b224:	10c00017 	ldw	r3,0(r2)
 822b228:	e0bff817 	ldw	r2,-32(fp)
 822b22c:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 822b230:	e0fff617 	ldw	r3,-40(fp)
 822b234:	e0bff917 	ldw	r2,-28(fp)
 822b238:	1885c83a 	sub	r2,r3,r2
 822b23c:	1007883a 	mov	r3,r2
 822b240:	e0bff817 	ldw	r2,-32(fp)
 822b244:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b248:	e1bff817 	ldw	r6,-32(fp)
 822b24c:	01401104 	movi	r5,68
 822b250:	010010c4 	movi	r4,67
 822b254:	8244cf80 	call	8244cf8 <udp_send>
   dsc_requests++;
 822b258:	d0a09317 	ldw	r2,-32180(gp)
 822b25c:	10800044 	addi	r2,r2,1
 822b260:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 822b264:	d0e0a817 	ldw	r3,-32096(gp)
 822b268:	008209b4 	movhi	r2,2086
 822b26c:	10b76004 	addi	r2,r2,-8832
 822b270:	e13ffe17 	ldw	r4,-8(fp)
 822b274:	21000f24 	muli	r4,r4,60
 822b278:	1105883a 	add	r2,r2,r4
 822b27c:	10800404 	addi	r2,r2,16
 822b280:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822b284:	008209b4 	movhi	r2,2086
 822b288:	10b76004 	addi	r2,r2,-8832
 822b28c:	e0fffe17 	ldw	r3,-8(fp)
 822b290:	18c00f24 	muli	r3,r3,60
 822b294:	10c5883a 	add	r2,r2,r3
 822b298:	10800104 	addi	r2,r2,4
 822b29c:	10800017 	ldw	r2,0(r2)
 822b2a0:	10c00044 	addi	r3,r2,1
 822b2a4:	008209b4 	movhi	r2,2086
 822b2a8:	10b76004 	addi	r2,r2,-8832
 822b2ac:	e13ffe17 	ldw	r4,-8(fp)
 822b2b0:	21000f24 	muli	r4,r4,60
 822b2b4:	1105883a 	add	r2,r2,r4
 822b2b8:	10800104 	addi	r2,r2,4
 822b2bc:	10c00015 	stw	r3,0(r2)

   return 0;   /* return OK code */
 822b2c0:	0005883a 	mov	r2,zero
}
 822b2c4:	e037883a 	mov	sp,fp
 822b2c8:	dfc00117 	ldw	ra,4(sp)
 822b2cc:	df000017 	ldw	fp,0(sp)
 822b2d0:	dec00204 	addi	sp,sp,8
 822b2d4:	f800283a 	ret

0822b2d8 <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 822b2d8:	defffd04 	addi	sp,sp,-12
 822b2dc:	dfc00215 	stw	ra,8(sp)
 822b2e0:	df000115 	stw	fp,4(sp)
 822b2e4:	df000104 	addi	fp,sp,4
 822b2e8:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 822b2ec:	008209b4 	movhi	r2,2086
 822b2f0:	10b73a04 	addi	r2,r2,-8984
 822b2f4:	e0ffff17 	ldw	r3,-4(fp)
 822b2f8:	18c7883a 	add	r3,r3,r3
 822b2fc:	18c7883a 	add	r3,r3,r3
 822b300:	10c5883a 	add	r2,r2,r3
 822b304:	10c00017 	ldw	r3,0(r2)
 822b308:	008209b4 	movhi	r2,2086
 822b30c:	10b76004 	addi	r2,r2,-8832
 822b310:	e13fff17 	ldw	r4,-4(fp)
 822b314:	21000f24 	muli	r4,r4,60
 822b318:	1105883a 	add	r2,r2,r4
 822b31c:	10800904 	addi	r2,r2,36
 822b320:	10800017 	ldw	r2,0(r2)
 822b324:	18800a15 	stw	r2,40(r3)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 822b328:	008209b4 	movhi	r2,2086
 822b32c:	10b73a04 	addi	r2,r2,-8984
 822b330:	e0ffff17 	ldw	r3,-4(fp)
 822b334:	18c7883a 	add	r3,r3,r3
 822b338:	18c7883a 	add	r3,r3,r3
 822b33c:	10c5883a 	add	r2,r2,r3
 822b340:	10c00017 	ldw	r3,0(r2)
 822b344:	008209b4 	movhi	r2,2086
 822b348:	10b76004 	addi	r2,r2,-8832
 822b34c:	e13fff17 	ldw	r4,-4(fp)
 822b350:	21000f24 	muli	r4,r4,60
 822b354:	1105883a 	add	r2,r2,r4
 822b358:	10800a04 	addi	r2,r2,40
 822b35c:	10800017 	ldw	r2,0(r2)
 822b360:	18800c15 	stw	r2,48(r3)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 822b364:	008209b4 	movhi	r2,2086
 822b368:	10b73a04 	addi	r2,r2,-8984
 822b36c:	e0ffff17 	ldw	r3,-4(fp)
 822b370:	18c7883a 	add	r3,r3,r3
 822b374:	18c7883a 	add	r3,r3,r3
 822b378:	10c5883a 	add	r2,r2,r3
 822b37c:	10c00017 	ldw	r3,0(r2)
 822b380:	008209b4 	movhi	r2,2086
 822b384:	10b76004 	addi	r2,r2,-8832
 822b388:	e13fff17 	ldw	r4,-4(fp)
 822b38c:	21000f24 	muli	r4,r4,60
 822b390:	1105883a 	add	r2,r2,r4
 822b394:	10800b04 	addi	r2,r2,44
 822b398:	10800017 	ldw	r2,0(r2)
 822b39c:	18800d15 	stw	r2,52(r3)

   if ( nets[iface]->snmask == 0 )
 822b3a0:	008209b4 	movhi	r2,2086
 822b3a4:	10b73a04 	addi	r2,r2,-8984
 822b3a8:	e0ffff17 	ldw	r3,-4(fp)
 822b3ac:	18c7883a 	add	r3,r3,r3
 822b3b0:	18c7883a 	add	r3,r3,r3
 822b3b4:	10c5883a 	add	r2,r2,r3
 822b3b8:	10800017 	ldw	r2,0(r2)
 822b3bc:	10800c17 	ldw	r2,48(r2)
 822b3c0:	1000111e 	bne	r2,zero,822b408 <dhc_setip+0x130>
   {
      fixup_subnet_mask(iface);
 822b3c4:	e13fff17 	ldw	r4,-4(fp)
 822b3c8:	8225dd40 	call	8225dd4 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 822b3cc:	008209b4 	movhi	r2,2086
 822b3d0:	10b73a04 	addi	r2,r2,-8984
 822b3d4:	e0ffff17 	ldw	r3,-4(fp)
 822b3d8:	18c7883a 	add	r3,r3,r3
 822b3dc:	18c7883a 	add	r3,r3,r3
 822b3e0:	10c5883a 	add	r2,r2,r3
 822b3e4:	10800017 	ldw	r2,0(r2)
 822b3e8:	10c00c17 	ldw	r3,48(r2)
 822b3ec:	008209b4 	movhi	r2,2086
 822b3f0:	10b76004 	addi	r2,r2,-8832
 822b3f4:	e13fff17 	ldw	r4,-4(fp)
 822b3f8:	21000f24 	muli	r4,r4,60
 822b3fc:	1105883a 	add	r2,r2,r4
 822b400:	10800a04 	addi	r2,r2,40
 822b404:	10c00015 	stw	r3,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b408:	008209b4 	movhi	r2,2086
 822b40c:	10b73a04 	addi	r2,r2,-8984
 822b410:	e0ffff17 	ldw	r3,-4(fp)
 822b414:	18c7883a 	add	r3,r3,r3
 822b418:	18c7883a 	add	r3,r3,r3
 822b41c:	10c5883a 	add	r2,r2,r3
 822b420:	11000017 	ldw	r4,0(r2)
 822b424:	008209b4 	movhi	r2,2086
 822b428:	10b73a04 	addi	r2,r2,-8984
 822b42c:	e0ffff17 	ldw	r3,-4(fp)
 822b430:	18c7883a 	add	r3,r3,r3
 822b434:	18c7883a 	add	r3,r3,r3
 822b438:	10c5883a 	add	r2,r2,r3
 822b43c:	10800017 	ldw	r2,0(r2)
 822b440:	11400a17 	ldw	r5,40(r2)
 822b444:	008209b4 	movhi	r2,2086
 822b448:	10b73a04 	addi	r2,r2,-8984
 822b44c:	e0ffff17 	ldw	r3,-4(fp)
 822b450:	18c7883a 	add	r3,r3,r3
 822b454:	18c7883a 	add	r3,r3,r3
 822b458:	10c5883a 	add	r2,r2,r3
 822b45c:	10800017 	ldw	r2,0(r2)
 822b460:	10800c17 	ldw	r2,48(r2)
 822b464:	0084303a 	nor	r2,zero,r2
 822b468:	2884b03a 	or	r2,r5,r2
 822b46c:	20800e15 	stw	r2,56(r4)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 822b470:	008209b4 	movhi	r2,2086
 822b474:	10b73a04 	addi	r2,r2,-8984
 822b478:	e0ffff17 	ldw	r3,-4(fp)
 822b47c:	18c7883a 	add	r3,r3,r3
 822b480:	18c7883a 	add	r3,r3,r3
 822b484:	10c5883a 	add	r2,r2,r3
 822b488:	11000017 	ldw	r4,0(r2)
 822b48c:	008209b4 	movhi	r2,2086
 822b490:	10b73a04 	addi	r2,r2,-8984
 822b494:	e0ffff17 	ldw	r3,-4(fp)
 822b498:	18c7883a 	add	r3,r3,r3
 822b49c:	18c7883a 	add	r3,r3,r3
 822b4a0:	10c5883a 	add	r2,r2,r3
 822b4a4:	10800017 	ldw	r2,0(r2)
 822b4a8:	11400a17 	ldw	r5,40(r2)
 822b4ac:	008209b4 	movhi	r2,2086
 822b4b0:	10b73a04 	addi	r2,r2,-8984
 822b4b4:	e0ffff17 	ldw	r3,-4(fp)
 822b4b8:	18c7883a 	add	r3,r3,r3
 822b4bc:	18c7883a 	add	r3,r3,r3
 822b4c0:	10c5883a 	add	r2,r2,r3
 822b4c4:	10800017 	ldw	r2,0(r2)
 822b4c8:	10800c17 	ldw	r2,48(r2)
 822b4cc:	2884703a 	and	r2,r5,r2
 822b4d0:	20800f15 	stw	r2,60(r4)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b4d4:	008209b4 	movhi	r2,2086
 822b4d8:	10b73a04 	addi	r2,r2,-8984
 822b4dc:	e0ffff17 	ldw	r3,-4(fp)
 822b4e0:	18c7883a 	add	r3,r3,r3
 822b4e4:	18c7883a 	add	r3,r3,r3
 822b4e8:	10c5883a 	add	r2,r2,r3
 822b4ec:	11000017 	ldw	r4,0(r2)
 822b4f0:	008209b4 	movhi	r2,2086
 822b4f4:	10b73a04 	addi	r2,r2,-8984
 822b4f8:	e0ffff17 	ldw	r3,-4(fp)
 822b4fc:	18c7883a 	add	r3,r3,r3
 822b500:	18c7883a 	add	r3,r3,r3
 822b504:	10c5883a 	add	r2,r2,r3
 822b508:	10800017 	ldw	r2,0(r2)
 822b50c:	11400a17 	ldw	r5,40(r2)
 822b510:	008209b4 	movhi	r2,2086
 822b514:	10b73a04 	addi	r2,r2,-8984
 822b518:	e0ffff17 	ldw	r3,-4(fp)
 822b51c:	18c7883a 	add	r3,r3,r3
 822b520:	18c7883a 	add	r3,r3,r3
 822b524:	10c5883a 	add	r2,r2,r3
 822b528:	10800017 	ldw	r2,0(r2)
 822b52c:	10800c17 	ldw	r2,48(r2)
 822b530:	0084303a 	nor	r2,zero,r2
 822b534:	2884b03a 	or	r2,r5,r2
 822b538:	20801015 	stw	r2,64(r4)

   return 0;   /* return OK code */
 822b53c:	0005883a 	mov	r2,zero
}
 822b540:	e037883a 	mov	sp,fp
 822b544:	dfc00117 	ldw	ra,4(sp)
 822b548:	df000017 	ldw	fp,0(sp)
 822b54c:	dec00204 	addi	sp,sp,8
 822b550:	f800283a 	ret

0822b554 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 822b554:	defffe04 	addi	sp,sp,-8
 822b558:	df000115 	stw	fp,4(sp)
 822b55c:	df000104 	addi	fp,sp,4
 822b560:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 822b564:	008209b4 	movhi	r2,2086
 822b568:	10b73a04 	addi	r2,r2,-8984
 822b56c:	e0ffff17 	ldw	r3,-4(fp)
 822b570:	18c7883a 	add	r3,r3,r3
 822b574:	18c7883a 	add	r3,r3,r3
 822b578:	10c5883a 	add	r2,r2,r3
 822b57c:	10800017 	ldw	r2,0(r2)
 822b580:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 822b584:	008209b4 	movhi	r2,2086
 822b588:	10b73a04 	addi	r2,r2,-8984
 822b58c:	e0ffff17 	ldw	r3,-4(fp)
 822b590:	18c7883a 	add	r3,r3,r3
 822b594:	18c7883a 	add	r3,r3,r3
 822b598:	10c5883a 	add	r2,r2,r3
 822b59c:	10800017 	ldw	r2,0(r2)
 822b5a0:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 822b5a4:	008209b4 	movhi	r2,2086
 822b5a8:	10b73a04 	addi	r2,r2,-8984
 822b5ac:	e0ffff17 	ldw	r3,-4(fp)
 822b5b0:	18c7883a 	add	r3,r3,r3
 822b5b4:	18c7883a 	add	r3,r3,r3
 822b5b8:	10c5883a 	add	r2,r2,r3
 822b5bc:	10800017 	ldw	r2,0(r2)
 822b5c0:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 822b5c4:	008209b4 	movhi	r2,2086
 822b5c8:	10b73a04 	addi	r2,r2,-8984
 822b5cc:	e0ffff17 	ldw	r3,-4(fp)
 822b5d0:	18c7883a 	add	r3,r3,r3
 822b5d4:	18c7883a 	add	r3,r3,r3
 822b5d8:	10c5883a 	add	r2,r2,r3
 822b5dc:	10800017 	ldw	r2,0(r2)
 822b5e0:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 822b5e4:	008209b4 	movhi	r2,2086
 822b5e8:	10b73a04 	addi	r2,r2,-8984
 822b5ec:	e0ffff17 	ldw	r3,-4(fp)
 822b5f0:	18c7883a 	add	r3,r3,r3
 822b5f4:	18c7883a 	add	r3,r3,r3
 822b5f8:	10c5883a 	add	r2,r2,r3
 822b5fc:	10800017 	ldw	r2,0(r2)
 822b600:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 822b604:	008209b4 	movhi	r2,2086
 822b608:	10b73a04 	addi	r2,r2,-8984
 822b60c:	e0ffff17 	ldw	r3,-4(fp)
 822b610:	18c7883a 	add	r3,r3,r3
 822b614:	18c7883a 	add	r3,r3,r3
 822b618:	10c5883a 	add	r2,r2,r3
 822b61c:	10800017 	ldw	r2,0(r2)
 822b620:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 822b624:	0005883a 	mov	r2,zero
}
 822b628:	e037883a 	mov	sp,fp
 822b62c:	df000017 	ldw	fp,0(sp)
 822b630:	dec00104 	addi	sp,sp,4
 822b634:	f800283a 	ret

0822b638 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 822b638:	defff804 	addi	sp,sp,-32
 822b63c:	dfc00715 	stw	ra,28(sp)
 822b640:	df000615 	stw	fp,24(sp)
 822b644:	df000604 	addi	fp,sp,24
 822b648:	e13ffd15 	stw	r4,-12(fp)
 822b64c:	e17ffe15 	stw	r5,-8(fp)
 822b650:	e1bfff15 	stw	r6,-4(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 822b654:	e0bfff17 	ldw	r2,-4(fp)
 822b658:	000b883a 	mov	r5,zero
 822b65c:	1009883a 	mov	r4,r2
 822b660:	82451340 	call	8245134 <udp_alloc>
 822b664:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 822b668:	e0bffa17 	ldw	r2,-24(fp)
 822b66c:	1000021e 	bne	r2,zero,822b678 <dhc_decline+0x40>
      return ENP_NOMEM;
 822b670:	00bffb04 	movi	r2,-20
 822b674:	00002d06 	br	822b72c <dhc_decline+0xf4>
   pkt->nb_plen = bplen;
 822b678:	e0bffa17 	ldw	r2,-24(fp)
 822b67c:	e0ffff17 	ldw	r3,-4(fp)
 822b680:	10c00415 	stw	r3,16(r2)

   outbp = (struct bootp *)pkt->nb_prot;
 822b684:	e0bffa17 	ldw	r2,-24(fp)
 822b688:	10800317 	ldw	r2,12(r2)
 822b68c:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 822b690:	e1bfff17 	ldw	r6,-4(fp)
 822b694:	e17ffe17 	ldw	r5,-8(fp)
 822b698:	e13ffb17 	ldw	r4,-20(fp)
 822b69c:	8202c5c0 	call	8202c5c <memcpy>
   outbp->op = BOOTREQUEST;
 822b6a0:	e0bffb17 	ldw	r2,-20(fp)
 822b6a4:	00c00044 	movi	r3,1
 822b6a8:	10c00005 	stb	r3,0(r2)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 822b6ac:	e0bffb17 	ldw	r2,-20(fp)
 822b6b0:	10803c04 	addi	r2,r2,240
 822b6b4:	100b883a 	mov	r5,r2
 822b6b8:	01000d44 	movi	r4,53
 822b6bc:	822c3dc0 	call	822c3dc <find_opt>
 822b6c0:	e0bffc15 	stw	r2,-16(fp)
   opts += 2;     /* point to actual op code */
 822b6c4:	e0bffc17 	ldw	r2,-16(fp)
 822b6c8:	10800084 	addi	r2,r2,2
 822b6cc:	e0bffc15 	stw	r2,-16(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 822b6d0:	e0bffc17 	ldw	r2,-16(fp)
 822b6d4:	00c00104 	movi	r3,4
 822b6d8:	10c00005 	stb	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 822b6dc:	e0bffa17 	ldw	r2,-24(fp)
 822b6e0:	00ffffc4 	movi	r3,-1
 822b6e4:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller speced net */
 822b6e8:	008209b4 	movhi	r2,2086
 822b6ec:	10b73a04 	addi	r2,r2,-8984
 822b6f0:	e0fffd17 	ldw	r3,-12(fp)
 822b6f4:	18c7883a 	add	r3,r3,r3
 822b6f8:	18c7883a 	add	r3,r3,r3
 822b6fc:	10c5883a 	add	r2,r2,r3
 822b700:	10c00017 	ldw	r3,0(r2)
 822b704:	e0bffa17 	ldw	r2,-24(fp)
 822b708:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b70c:	e1bffa17 	ldw	r6,-24(fp)
 822b710:	01401104 	movi	r5,68
 822b714:	010010c4 	movi	r4,67
 822b718:	8244cf80 	call	8244cf8 <udp_send>
   dsc_declines++;   /* count declines sent */
 822b71c:	d0a09617 	ldw	r2,-32168(gp)
 822b720:	10800044 	addi	r2,r2,1
 822b724:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 822b728:	0005883a 	mov	r2,zero
}
 822b72c:	e037883a 	mov	sp,fp
 822b730:	dfc00117 	ldw	ra,4(sp)
 822b734:	df000017 	ldw	fp,0(sp)
 822b738:	dec00204 	addi	sp,sp,8
 822b73c:	f800283a 	ret

0822b740 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 822b740:	defffc04 	addi	sp,sp,-16
 822b744:	df000315 	stw	fp,12(sp)
 822b748:	df000304 	addi	fp,sp,12
 822b74c:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 822b750:	e0bffe04 	addi	r2,fp,-8
 822b754:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 822b758:	e0bffd17 	ldw	r2,-12(fp)
 822b75c:	10c00044 	addi	r3,r2,1
 822b760:	e0fffd15 	stw	r3,-12(fp)
 822b764:	e0ffff17 	ldw	r3,-4(fp)
 822b768:	19000044 	addi	r4,r3,1
 822b76c:	e13fff15 	stw	r4,-4(fp)
 822b770:	18c00003 	ldbu	r3,0(r3)
 822b774:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b778:	e0bffd17 	ldw	r2,-12(fp)
 822b77c:	10c00044 	addi	r3,r2,1
 822b780:	e0fffd15 	stw	r3,-12(fp)
 822b784:	e0ffff17 	ldw	r3,-4(fp)
 822b788:	19000044 	addi	r4,r3,1
 822b78c:	e13fff15 	stw	r4,-4(fp)
 822b790:	18c00003 	ldbu	r3,0(r3)
 822b794:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b798:	e0bffd17 	ldw	r2,-12(fp)
 822b79c:	10c00044 	addi	r3,r2,1
 822b7a0:	e0fffd15 	stw	r3,-12(fp)
 822b7a4:	e0ffff17 	ldw	r3,-4(fp)
 822b7a8:	19000044 	addi	r4,r3,1
 822b7ac:	e13fff15 	stw	r4,-4(fp)
 822b7b0:	18c00003 	ldbu	r3,0(r3)
 822b7b4:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b7b8:	e0bffd17 	ldw	r2,-12(fp)
 822b7bc:	10c00044 	addi	r3,r2,1
 822b7c0:	e0fffd15 	stw	r3,-12(fp)
 822b7c4:	e0ffff17 	ldw	r3,-4(fp)
 822b7c8:	19000044 	addi	r4,r3,1
 822b7cc:	e13fff15 	stw	r4,-4(fp)
 822b7d0:	18c00003 	ldbu	r3,0(r3)
 822b7d4:	10c00005 	stb	r3,0(r2)

   return v;
 822b7d8:	e0bffe17 	ldw	r2,-8(fp)
}
 822b7dc:	e037883a 	mov	sp,fp
 822b7e0:	df000017 	ldw	fp,0(sp)
 822b7e4:	dec00104 	addi	sp,sp,4
 822b7e8:	f800283a 	ret

0822b7ec <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 822b7ec:	defff904 	addi	sp,sp,-28
 822b7f0:	dfc00615 	stw	ra,24(sp)
 822b7f4:	df000515 	stw	fp,20(sp)
 822b7f8:	dc000415 	stw	r16,16(sp)
 822b7fc:	df000504 	addi	fp,sp,20
 822b800:	e13ffd15 	stw	r4,-12(fp)
 822b804:	e17ffe15 	stw	r5,-8(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 822b808:	e0bffe17 	ldw	r2,-8(fp)
 822b80c:	10804e04 	addi	r2,r2,312
 822b810:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 822b814:	008209b4 	movhi	r2,2086
 822b818:	10b76004 	addi	r2,r2,-8832
 822b81c:	e0fffd17 	ldw	r3,-12(fp)
 822b820:	18c00f24 	muli	r3,r3,60
 822b824:	10c5883a 	add	r2,r2,r3
 822b828:	10800a04 	addi	r2,r2,40
 822b82c:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 822b830:	008209b4 	movhi	r2,2086
 822b834:	10b76004 	addi	r2,r2,-8832
 822b838:	e0fffd17 	ldw	r3,-12(fp)
 822b83c:	18c00f24 	muli	r3,r3,60
 822b840:	10c5883a 	add	r2,r2,r3
 822b844:	10800b04 	addi	r2,r2,44
 822b848:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 822b84c:	008209b4 	movhi	r2,2086
 822b850:	10b76004 	addi	r2,r2,-8832
 822b854:	e0fffd17 	ldw	r3,-12(fp)
 822b858:	18c00f24 	muli	r3,r3,60
 822b85c:	10c5883a 	add	r2,r2,r3
 822b860:	10800504 	addi	r2,r2,20
 822b864:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822b868:	00007106 	br	822ba30 <dhc_extract_opts+0x244>
   {
      switch (*opts++)
 822b86c:	e0bffe17 	ldw	r2,-8(fp)
 822b870:	10c00044 	addi	r3,r2,1
 822b874:	e0fffe15 	stw	r3,-8(fp)
 822b878:	10800003 	ldbu	r2,0(r2)
 822b87c:	10803fcc 	andi	r2,r2,255
 822b880:	10c000e0 	cmpeqi	r3,r2,3
 822b884:	1800201e 	bne	r3,zero,822b908 <dhc_extract_opts+0x11c>
 822b888:	10c00108 	cmpgei	r3,r2,4
 822b88c:	1800041e 	bne	r3,zero,822b8a0 <dhc_extract_opts+0xb4>
 822b890:	10006726 	beq	r2,zero,822ba30 <dhc_extract_opts+0x244>
 822b894:	10800060 	cmpeqi	r2,r2,1
 822b898:	10000a1e 	bne	r2,zero,822b8c4 <dhc_extract_opts+0xd8>
 822b89c:	00005c06 	br	822ba10 <dhc_extract_opts+0x224>
 822b8a0:	10c00ce0 	cmpeqi	r3,r2,51
 822b8a4:	18002f1e 	bne	r3,zero,822b964 <dhc_extract_opts+0x178>
 822b8a8:	10c03fe0 	cmpeqi	r3,r2,255
 822b8ac:	1800031e 	bne	r3,zero,822b8bc <dhc_extract_opts+0xd0>
 822b8b0:	108001a0 	cmpeqi	r2,r2,6
 822b8b4:	10004c1e 	bne	r2,zero,822b9e8 <dhc_extract_opts+0x1fc>
 822b8b8:	00005506 	br	822ba10 <dhc_extract_opts+0x224>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 822b8bc:	0005883a 	mov	r2,zero
 822b8c0:	00006006 	br	822ba44 <dhc_extract_opts+0x258>
      case DHOP_SNMASK:
         opts++;
 822b8c4:	e0bffe17 	ldw	r2,-8(fp)
 822b8c8:	10800044 	addi	r2,r2,1
 822b8cc:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 822b8d0:	e13ffe17 	ldw	r4,-8(fp)
 822b8d4:	822b7400 	call	822b740 <dh_getlong>
 822b8d8:	1009883a 	mov	r4,r2
 822b8dc:	008209b4 	movhi	r2,2086
 822b8e0:	10b76004 	addi	r2,r2,-8832
 822b8e4:	e0fffd17 	ldw	r3,-12(fp)
 822b8e8:	18c00f24 	muli	r3,r3,60
 822b8ec:	10c5883a 	add	r2,r2,r3
 822b8f0:	10800a04 	addi	r2,r2,40
 822b8f4:	11000015 	stw	r4,0(r2)
         opts += 4;
 822b8f8:	e0bffe17 	ldw	r2,-8(fp)
 822b8fc:	10800104 	addi	r2,r2,4
 822b900:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b904:	00004a06 	br	822ba30 <dhc_extract_opts+0x244>
      case DHOP_ROUTER:
         optlen = *opts++;
 822b908:	e0bffe17 	ldw	r2,-8(fp)
 822b90c:	10c00044 	addi	r3,r2,1
 822b910:	e0fffe15 	stw	r3,-8(fp)
 822b914:	10800003 	ldbu	r2,0(r2)
 822b918:	e0bffc05 	stb	r2,-16(fp)
         if (optlen >= 4)
 822b91c:	e0bffc03 	ldbu	r2,-16(fp)
 822b920:	10800130 	cmpltui	r2,r2,4
 822b924:	10000a1e 	bne	r2,zero,822b950 <dhc_extract_opts+0x164>
            dhc_states[iface].defgw = dh_getlong(opts);
 822b928:	e13ffe17 	ldw	r4,-8(fp)
 822b92c:	822b7400 	call	822b740 <dh_getlong>
 822b930:	1009883a 	mov	r4,r2
 822b934:	008209b4 	movhi	r2,2086
 822b938:	10b76004 	addi	r2,r2,-8832
 822b93c:	e0fffd17 	ldw	r3,-12(fp)
 822b940:	18c00f24 	muli	r3,r3,60
 822b944:	10c5883a 	add	r2,r2,r3
 822b948:	10800b04 	addi	r2,r2,44
 822b94c:	11000015 	stw	r4,0(r2)
         opts += optlen;
 822b950:	e0bffc03 	ldbu	r2,-16(fp)
 822b954:	e0fffe17 	ldw	r3,-8(fp)
 822b958:	1885883a 	add	r2,r3,r2
 822b95c:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b960:	00003306 	br	822ba30 <dhc_extract_opts+0x244>
      case DHOP_LEASE:
         opts++;
 822b964:	e0bffe17 	ldw	r2,-8(fp)
 822b968:	10800044 	addi	r2,r2,1
 822b96c:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 822b970:	e13ffe17 	ldw	r4,-8(fp)
 822b974:	822b7400 	call	822b740 <dh_getlong>
 822b978:	1004d63a 	srli	r2,r2,24
 822b97c:	1021883a 	mov	r16,r2
 822b980:	e13ffe17 	ldw	r4,-8(fp)
 822b984:	822b7400 	call	822b740 <dh_getlong>
 822b988:	1005d23a 	srai	r2,r2,8
 822b98c:	10bfc00c 	andi	r2,r2,65280
 822b990:	80a0b03a 	or	r16,r16,r2
 822b994:	e13ffe17 	ldw	r4,-8(fp)
 822b998:	822b7400 	call	822b740 <dh_getlong>
 822b99c:	10bfc00c 	andi	r2,r2,65280
 822b9a0:	1004923a 	slli	r2,r2,8
 822b9a4:	80a0b03a 	or	r16,r16,r2
 822b9a8:	e13ffe17 	ldw	r4,-8(fp)
 822b9ac:	822b7400 	call	822b740 <dh_getlong>
 822b9b0:	1004963a 	slli	r2,r2,24
 822b9b4:	8084b03a 	or	r2,r16,r2
 822b9b8:	1009883a 	mov	r4,r2
 822b9bc:	008209b4 	movhi	r2,2086
 822b9c0:	10b76004 	addi	r2,r2,-8832
 822b9c4:	e0fffd17 	ldw	r3,-12(fp)
 822b9c8:	18c00f24 	muli	r3,r3,60
 822b9cc:	10c5883a 	add	r2,r2,r3
 822b9d0:	10800504 	addi	r2,r2,20
 822b9d4:	11000015 	stw	r4,0(r2)
         opts += 4;
 822b9d8:	e0bffe17 	ldw	r2,-8(fp)
 822b9dc:	10800104 	addi	r2,r2,4
 822b9e0:	e0bffe15 	stw	r2,-8(fp)
         break;
 822b9e4:	00001206 	br	822ba30 <dhc_extract_opts+0x244>
      case DHOP_DNSRV:
         optlen = *opts++;
 822b9e8:	e0bffe17 	ldw	r2,-8(fp)
 822b9ec:	10c00044 	addi	r3,r2,1
 822b9f0:	e0fffe15 	stw	r3,-8(fp)
 822b9f4:	10800003 	ldbu	r2,0(r2)
 822b9f8:	e0bffc05 	stb	r2,-16(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 822b9fc:	e0bffc03 	ldbu	r2,-16(fp)
 822ba00:	e0fffe17 	ldw	r3,-8(fp)
 822ba04:	1885883a 	add	r2,r3,r2
 822ba08:	e0bffe15 	stw	r2,-8(fp)
         break;
 822ba0c:	00000806 	br	822ba30 <dhc_extract_opts+0x244>
      default:
         opts += ((*opts) + 1);
 822ba10:	e0bffe17 	ldw	r2,-8(fp)
 822ba14:	10800003 	ldbu	r2,0(r2)
 822ba18:	10803fcc 	andi	r2,r2,255
 822ba1c:	10800044 	addi	r2,r2,1
 822ba20:	e0fffe17 	ldw	r3,-8(fp)
 822ba24:	1885883a 	add	r2,r3,r2
 822ba28:	e0bffe15 	stw	r2,-8(fp)
         break;
 822ba2c:	0001883a 	nop
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822ba30:	e0bffe17 	ldw	r2,-8(fp)
 822ba34:	e0fffb17 	ldw	r3,-20(fp)
 822ba38:	18bf8c2e 	bgeu	r3,r2,822b86c <dhc_extract_opts+0x80>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 822ba3c:	822d2e00 	call	822d2e0 <dtrap>
   return -1;
 822ba40:	00bfffc4 	movi	r2,-1
}
 822ba44:	e6ffff04 	addi	sp,fp,-4
 822ba48:	dfc00217 	ldw	ra,8(sp)
 822ba4c:	df000117 	ldw	fp,4(sp)
 822ba50:	dc000017 	ldw	r16,0(sp)
 822ba54:	dec00304 	addi	sp,sp,12
 822ba58:	f800283a 	ret

0822ba5c <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 822ba5c:	defffa04 	addi	sp,sp,-24
 822ba60:	dfc00515 	stw	ra,20(sp)
 822ba64:	df000415 	stw	fp,16(sp)
 822ba68:	df000404 	addi	fp,sp,16
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822ba6c:	e03ffc15 	stw	zero,-16(fp)
 822ba70:	00014506 	br	822bf88 <dhc_second+0x52c>
   {
      switch (dhc_states[iface].state)
 822ba74:	008209b4 	movhi	r2,2086
 822ba78:	10b76004 	addi	r2,r2,-8832
 822ba7c:	e0fffc17 	ldw	r3,-16(fp)
 822ba80:	18c00f24 	muli	r3,r3,60
 822ba84:	10c5883a 	add	r2,r2,r3
 822ba88:	10800017 	ldw	r2,0(r2)
 822ba8c:	10c00268 	cmpgeui	r3,r2,9
 822ba90:	1801311e 	bne	r3,zero,822bf58 <dhc_second+0x4fc>
 822ba94:	100690ba 	slli	r3,r2,2
 822ba98:	008208f4 	movhi	r2,2083
 822ba9c:	10aeab04 	addi	r2,r2,-17748
 822baa0:	1885883a 	add	r2,r3,r2
 822baa4:	10800017 	ldw	r2,0(r2)
 822baa8:	1000683a 	jmp	r2
 822baac:	0822bf58 	cmpnei	zero,at,-29955
 822bab0:	0822bad0 	cmplti	zero,at,-29973
 822bab4:	0822bb00 	call	822bb0 <OSCtxSw_SWITCH_PC+0x822b70>
 822bab8:	0822bb30 	cmpltui	zero,at,35564
 822babc:	0822bb30 	cmpltui	zero,at,35564
 822bac0:	0822bb30 	cmpltui	zero,at,35564
 822bac4:	0822bd70 	cmpltui	zero,at,35573
 822bac8:	0822be18 	cmpnei	zero,at,-29960
 822bacc:	0822bc4c 	andi	zero,at,35569
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 822bad0:	e13ffc17 	ldw	r4,-16(fp)
 822bad4:	822a2a40 	call	822a2a4 <dhc_discover>
 822bad8:	e0bfff15 	stw	r2,-4(fp)
         /* Error while sending a discover packet */
         if (e)
 822badc:	e0bfff17 	ldw	r2,-4(fp)
 822bae0:	10000326 	beq	r2,zero,822baf0 <dhc_second+0x94>
         {
            dtrap();
 822bae4:	822d2e00 	call	822d2e0 <dtrap>
            return e;
 822bae8:	e0bfff17 	ldw	r2,-4(fp)
 822baec:	00012a06 	br	822bf98 <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 822baf0:	01400104 	movi	r5,4
 822baf4:	e13ffc17 	ldw	r4,-16(fp)
 822baf8:	822c32c0 	call	822c32c <dhc_set_state>
         break;
 822bafc:	00011f06 	br	822bf7c <dhc_second+0x520>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 822bb00:	e13ffc17 	ldw	r4,-16(fp)
 822bb04:	822c02c0 	call	822c02c <dhc_reclaim>
 822bb08:	e0bfff15 	stw	r2,-4(fp)
         if (e)
 822bb0c:	e0bfff17 	ldw	r2,-4(fp)
 822bb10:	10000326 	beq	r2,zero,822bb20 <dhc_second+0xc4>
         {
            dtrap();
 822bb14:	822d2e00 	call	822d2e0 <dtrap>
            return e;
 822bb18:	e0bfff17 	ldw	r2,-4(fp)
 822bb1c:	00011e06 	br	822bf98 <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 822bb20:	014000c4 	movi	r5,3
 822bb24:	e13ffc17 	ldw	r4,-16(fp)
 822bb28:	822c32c0 	call	822c32c <dhc_set_state>
         break;
 822bb2c:	00011306 	br	822bf7c <dhc_second+0x520>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 822bb30:	008209b4 	movhi	r2,2086
 822bb34:	10b76004 	addi	r2,r2,-8832
 822bb38:	e0fffc17 	ldw	r3,-16(fp)
 822bb3c:	18c00f24 	muli	r3,r3,60
 822bb40:	10c5883a 	add	r2,r2,r3
 822bb44:	10800104 	addi	r2,r2,4
 822bb48:	10800017 	ldw	r2,0(r2)
 822bb4c:	e0bffd15 	stw	r2,-12(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 822bb50:	e0bffd17 	ldw	r2,-12(fp)
 822bb54:	10800110 	cmplti	r2,r2,4
 822bb58:	1000021e 	bne	r2,zero,822bb64 <dhc_second+0x108>
            tries= DHC_MAX_TRIES;
 822bb5c:	00800104 	movi	r2,4
 822bb60:	e0bffd15 	stw	r2,-12(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 822bb64:	008209b4 	movhi	r2,2086
 822bb68:	10b76004 	addi	r2,r2,-8832
 822bb6c:	e0fffc17 	ldw	r3,-16(fp)
 822bb70:	18c00f24 	muli	r3,r3,60
 822bb74:	10c5883a 	add	r2,r2,r3
 822bb78:	10800404 	addi	r2,r2,16
 822bb7c:	10c00017 	ldw	r3,0(r2)
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
 822bb80:	01006404 	movi	r4,400
 822bb84:	e0bffd17 	ldw	r2,-12(fp)
 822bb88:	2084983a 	sll	r2,r4,r2
         tries = dhc_states[iface].tries ;

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
            tries= DHC_MAX_TRIES;
         if ( cticks > (dhc_states[iface].last_tick + 
 822bb8c:	1887883a 	add	r3,r3,r2
 822bb90:	d0a0a817 	ldw	r2,-32096(gp)
 822bb94:	1880192e 	bgeu	r3,r2,822bbfc <dhc_second+0x1a0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 822bb98:	008209b4 	movhi	r2,2086
 822bb9c:	10b76004 	addi	r2,r2,-8832
 822bba0:	e0fffc17 	ldw	r3,-16(fp)
 822bba4:	18c00f24 	muli	r3,r3,60
 822bba8:	10c5883a 	add	r2,r2,r3
 822bbac:	10800017 	ldw	r2,0(r2)
 822bbb0:	10c00120 	cmpeqi	r3,r2,4
 822bbb4:	1800051e 	bne	r3,zero,822bbcc <dhc_second+0x170>
 822bbb8:	10c00160 	cmpeqi	r3,r2,5
 822bbbc:	1800061e 	bne	r3,zero,822bbd8 <dhc_second+0x17c>
 822bbc0:	108000e0 	cmpeqi	r2,r2,3
 822bbc4:	1000081e 	bne	r2,zero,822bbe8 <dhc_second+0x18c>
 822bbc8:	00000a06 	br	822bbf4 <dhc_second+0x198>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 822bbcc:	e13ffc17 	ldw	r4,-16(fp)
 822bbd0:	822a2a40 	call	822a2a4 <dhc_discover>
               break;
 822bbd4:	00000906 	br	822bbfc <dhc_second+0x1a0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 822bbd8:	000b883a 	mov	r5,zero
 822bbdc:	e13ffc17 	ldw	r4,-16(fp)
 822bbe0:	822a8540 	call	822a854 <dhc_request>
               break;
 822bbe4:	00000506 	br	822bbfc <dhc_second+0x1a0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 822bbe8:	e13ffc17 	ldw	r4,-16(fp)
 822bbec:	822c02c0 	call	822c02c <dhc_reclaim>
               break;
 822bbf0:	00000206 	br	822bbfc <dhc_second+0x1a0>
            default:
               dtrap(); /* bogus state */
 822bbf4:	822d2e00 	call	822d2e0 <dtrap>
               break;
 822bbf8:	0001883a 	nop
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bbfc:	e0bffd17 	ldw	r2,-12(fp)
 822bc00:	10800118 	cmpnei	r2,r2,4
 822bc04:	1000d61e 	bne	r2,zero,822bf60 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
 822bc08:	008209b4 	movhi	r2,2086
 822bc0c:	10b76004 	addi	r2,r2,-8832
 822bc10:	e0fffc17 	ldw	r3,-16(fp)
 822bc14:	18c00f24 	muli	r3,r3,60
 822bc18:	10c5883a 	add	r2,r2,r3
 822bc1c:	10800017 	ldw	r2,0(r2)
            default:
               dtrap(); /* bogus state */
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bc20:	10800120 	cmpeqi	r2,r2,4
 822bc24:	1000ce1e 	bne	r2,zero,822bf60 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 822bc28:	01400244 	movi	r5,9
 822bc2c:	e13ffc17 	ldw	r4,-16(fp)
 822bc30:	822c32c0 	call	822c32c <dhc_set_state>
            dhc_resetip(iface);
 822bc34:	e13ffc17 	ldw	r4,-16(fp)
 822bc38:	822b5540 	call	822b554 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bc3c:	01400044 	movi	r5,1
 822bc40:	e13ffc17 	ldw	r4,-16(fp)
 822bc44:	822c32c0 	call	822c32c <dhc_set_state>
         }
         break;
 822bc48:	0000c506 	br	822bf60 <dhc_second+0x504>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 822bc4c:	008209b4 	movhi	r2,2086
 822bc50:	10b76004 	addi	r2,r2,-8832
 822bc54:	e0fffc17 	ldw	r3,-16(fp)
 822bc58:	18c00f24 	muli	r3,r3,60
 822bc5c:	10c5883a 	add	r2,r2,r3
 822bc60:	10800504 	addi	r2,r2,20
 822bc64:	10800017 	ldw	r2,0(r2)
 822bc68:	10c01924 	muli	r3,r2,100
 822bc6c:	008209b4 	movhi	r2,2086
 822bc70:	10b76004 	addi	r2,r2,-8832
 822bc74:	e13ffc17 	ldw	r4,-16(fp)
 822bc78:	21000f24 	muli	r4,r4,60
 822bc7c:	1105883a 	add	r2,r2,r4
 822bc80:	10800804 	addi	r2,r2,32
 822bc84:	10800017 	ldw	r2,0(r2)
 822bc88:	1885883a 	add	r2,r3,r2
 822bc8c:	d0e0a817 	ldw	r3,-32096(gp)
 822bc90:	18802e2e 	bgeu	r3,r2,822bd4c <dhc_second+0x2f0>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bc94:	008209b4 	movhi	r2,2086
 822bc98:	10b76004 	addi	r2,r2,-8832
 822bc9c:	e0fffc17 	ldw	r3,-16(fp)
 822bca0:	18c00f24 	muli	r3,r3,60
 822bca4:	10c5883a 	add	r2,r2,r3
 822bca8:	10800804 	addi	r2,r2,32
 822bcac:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].lease*TPS - 
 822bcb0:	008209b4 	movhi	r2,2086
 822bcb4:	10b76004 	addi	r2,r2,-8832
 822bcb8:	e13ffc17 	ldw	r4,-16(fp)
 822bcbc:	21000f24 	muli	r4,r4,60
 822bcc0:	1105883a 	add	r2,r2,r4
 822bcc4:	10800504 	addi	r2,r2,20
 822bcc8:	10800017 	ldw	r2,0(r2)
 822bccc:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bcd0:	1887883a 	add	r3,r3,r2
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;
 822bcd4:	008209b4 	movhi	r2,2086
 822bcd8:	10b76004 	addi	r2,r2,-8832
 822bcdc:	e13ffc17 	ldw	r4,-16(fp)
 822bce0:	21000f24 	muli	r4,r4,60
 822bce4:	1105883a 	add	r2,r2,r4
 822bce8:	10800404 	addi	r2,r2,16
 822bcec:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
             dhc_states[iface].lease*TPS - 
 822bcf0:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bcf4:	1004d07a 	srli	r2,r2,1
 822bcf8:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822bcfc:	e0bffe17 	ldw	r2,-8(fp)
 822bd00:	1085dc28 	cmpgeui	r2,r2,6000
 822bd04:	1000021e 	bne	r2,zero,822bd10 <dhc_second+0x2b4>
               half_time = 60*TPS;
 822bd08:	0085dc04 	movi	r2,6000
 822bd0c:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822bd10:	008209b4 	movhi	r2,2086
 822bd14:	10b76004 	addi	r2,r2,-8832
 822bd18:	e0fffc17 	ldw	r3,-16(fp)
 822bd1c:	18c00f24 	muli	r3,r3,60
 822bd20:	10c5883a 	add	r2,r2,r3
 822bd24:	10800404 	addi	r2,r2,16
 822bd28:	10c00017 	ldw	r3,0(r2)
 822bd2c:	e0bffe17 	ldw	r2,-8(fp)
 822bd30:	1887883a 	add	r3,r3,r2
 822bd34:	d0a0a817 	ldw	r2,-32096(gp)
 822bd38:	18808b2e 	bgeu	r3,r2,822bf68 <dhc_second+0x50c>
            {
               dhc_request(iface,FALSE);
 822bd3c:	000b883a 	mov	r5,zero
 822bd40:	e13ffc17 	ldw	r4,-16(fp)
 822bd44:	822a8540 	call	822a854 <dhc_request>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822bd48:	00008706 	br	822bf68 <dhc_second+0x50c>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 822bd4c:	01400244 	movi	r5,9
 822bd50:	e13ffc17 	ldw	r4,-16(fp)
 822bd54:	822c32c0 	call	822c32c <dhc_set_state>
            dhc_resetip(iface);
 822bd58:	e13ffc17 	ldw	r4,-16(fp)
 822bd5c:	822b5540 	call	822b554 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bd60:	01400044 	movi	r5,1
 822bd64:	e13ffc17 	ldw	r4,-16(fp)
 822bd68:	822c32c0 	call	822c32c <dhc_set_state>
         }
         break;
 822bd6c:	00007e06 	br	822bf68 <dhc_second+0x50c>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822bd70:	008209b4 	movhi	r2,2086
 822bd74:	10b76004 	addi	r2,r2,-8832
 822bd78:	e0fffc17 	ldw	r3,-16(fp)
 822bd7c:	18c00f24 	muli	r3,r3,60
 822bd80:	10c5883a 	add	r2,r2,r3
 822bd84:	10800604 	addi	r2,r2,24
 822bd88:	10800017 	ldw	r2,0(r2)
 822bd8c:	10bfffe0 	cmpeqi	r2,r2,-1
 822bd90:	1000771e 	bne	r2,zero,822bf70 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
 822bd94:	008209b4 	movhi	r2,2086
 822bd98:	10b76004 	addi	r2,r2,-8832
 822bd9c:	e0fffc17 	ldw	r3,-16(fp)
 822bda0:	18c00f24 	muli	r3,r3,60
 822bda4:	10c5883a 	add	r2,r2,r3
 822bda8:	10800604 	addi	r2,r2,24
 822bdac:	10800017 	ldw	r2,0(r2)
 822bdb0:	10c01924 	muli	r3,r2,100
 822bdb4:	008209b4 	movhi	r2,2086
 822bdb8:	10b76004 	addi	r2,r2,-8832
 822bdbc:	e13ffc17 	ldw	r4,-16(fp)
 822bdc0:	21000f24 	muli	r4,r4,60
 822bdc4:	1105883a 	add	r2,r2,r4
 822bdc8:	10800804 	addi	r2,r2,32
 822bdcc:	10800017 	ldw	r2,0(r2)
 822bdd0:	1887883a 	add	r3,r3,r2
 822bdd4:	d0a0a817 	ldw	r2,-32096(gp)
         }
         break;

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822bdd8:	1880652e 	bgeu	r3,r2,822bf70 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 822bddc:	014001c4 	movi	r5,7
 822bde0:	e13ffc17 	ldw	r4,-16(fp)
 822bde4:	822c32c0 	call	822c32c <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 822bde8:	e13ffc17 	ldw	r4,-16(fp)
 822bdec:	822c02c0 	call	822c02c <dhc_reclaim>
 822bdf0:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822bdf4:	e0bfff17 	ldw	r2,-4(fp)
 822bdf8:	10000326 	beq	r2,zero,822be08 <dhc_second+0x3ac>
            {
               dtrap();
 822bdfc:	822d2e00 	call	822d2e0 <dtrap>
               return e;
 822be00:	e0bfff17 	ldw	r2,-4(fp)
 822be04:	00006406 	br	822bf98 <dhc_second+0x53c>
            }
            dsc_renew++;
 822be08:	d0a09917 	ldw	r2,-32156(gp)
 822be0c:	10800044 	addi	r2,r2,1
 822be10:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 822be14:	00005606 	br	822bf70 <dhc_second+0x514>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 822be18:	008209b4 	movhi	r2,2086
 822be1c:	10b76004 	addi	r2,r2,-8832
 822be20:	e0fffc17 	ldw	r3,-16(fp)
 822be24:	18c00f24 	muli	r3,r3,60
 822be28:	10c5883a 	add	r2,r2,r3
 822be2c:	10800704 	addi	r2,r2,28
 822be30:	10800017 	ldw	r2,0(r2)
 822be34:	10c01924 	muli	r3,r2,100
 822be38:	008209b4 	movhi	r2,2086
 822be3c:	10b76004 	addi	r2,r2,-8832
 822be40:	e13ffc17 	ldw	r4,-16(fp)
 822be44:	21000f24 	muli	r4,r4,60
 822be48:	1105883a 	add	r2,r2,r4
 822be4c:	10800804 	addi	r2,r2,32
 822be50:	10800017 	ldw	r2,0(r2)
 822be54:	1885883a 	add	r2,r3,r2
 822be58:	d0e0a817 	ldw	r3,-32096(gp)
 822be5c:	18802e2e 	bgeu	r3,r2,822bf18 <dhc_second+0x4bc>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822be60:	008209b4 	movhi	r2,2086
 822be64:	10b76004 	addi	r2,r2,-8832
 822be68:	e0fffc17 	ldw	r3,-16(fp)
 822be6c:	18c00f24 	muli	r3,r3,60
 822be70:	10c5883a 	add	r2,r2,r3
 822be74:	10800804 	addi	r2,r2,32
 822be78:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].t2*TPS - 
 822be7c:	008209b4 	movhi	r2,2086
 822be80:	10b76004 	addi	r2,r2,-8832
 822be84:	e13ffc17 	ldw	r4,-16(fp)
 822be88:	21000f24 	muli	r4,r4,60
 822be8c:	1105883a 	add	r2,r2,r4
 822be90:	10800704 	addi	r2,r2,28
 822be94:	10800017 	ldw	r2,0(r2)
 822be98:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822be9c:	1887883a 	add	r3,r3,r2
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;
 822bea0:	008209b4 	movhi	r2,2086
 822bea4:	10b76004 	addi	r2,r2,-8832
 822bea8:	e13ffc17 	ldw	r4,-16(fp)
 822beac:	21000f24 	muli	r4,r4,60
 822beb0:	1105883a 	add	r2,r2,r4
 822beb4:	10800404 	addi	r2,r2,16
 822beb8:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
             dhc_states[iface].t2*TPS - 
 822bebc:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bec0:	1004d07a 	srli	r2,r2,1
 822bec4:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822bec8:	e0bffe17 	ldw	r2,-8(fp)
 822becc:	1085dc28 	cmpgeui	r2,r2,6000
 822bed0:	1000021e 	bne	r2,zero,822bedc <dhc_second+0x480>
               half_time = 60*TPS;
 822bed4:	0085dc04 	movi	r2,6000
 822bed8:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822bedc:	008209b4 	movhi	r2,2086
 822bee0:	10b76004 	addi	r2,r2,-8832
 822bee4:	e0fffc17 	ldw	r3,-16(fp)
 822bee8:	18c00f24 	muli	r3,r3,60
 822beec:	10c5883a 	add	r2,r2,r3
 822bef0:	10800404 	addi	r2,r2,16
 822bef4:	10c00017 	ldw	r3,0(r2)
 822bef8:	e0bffe17 	ldw	r2,-8(fp)
 822befc:	1887883a 	add	r3,r3,r2
 822bf00:	d0a0a817 	ldw	r2,-32096(gp)
 822bf04:	18801c2e 	bgeu	r3,r2,822bf78 <dhc_second+0x51c>
            {
               dhc_request(iface,FALSE);
 822bf08:	000b883a 	mov	r5,zero
 822bf0c:	e13ffc17 	ldw	r4,-16(fp)
 822bf10:	822a8540 	call	822a854 <dhc_request>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822bf14:	00001806 	br	822bf78 <dhc_second+0x51c>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 822bf18:	01400204 	movi	r5,8
 822bf1c:	e13ffc17 	ldw	r4,-16(fp)
 822bf20:	822c32c0 	call	822c32c <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 822bf24:	01400044 	movi	r5,1
 822bf28:	e13ffc17 	ldw	r4,-16(fp)
 822bf2c:	822a8540 	call	822a854 <dhc_request>
 822bf30:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822bf34:	e0bfff17 	ldw	r2,-4(fp)
 822bf38:	10000326 	beq	r2,zero,822bf48 <dhc_second+0x4ec>
            {
               dtrap();
 822bf3c:	822d2e00 	call	822d2e0 <dtrap>
               return e;
 822bf40:	e0bfff17 	ldw	r2,-4(fp)
 822bf44:	00001406 	br	822bf98 <dhc_second+0x53c>
            }
            dsc_rebind++;
 822bf48:	d0a09a17 	ldw	r2,-32152(gp)
 822bf4c:	10800044 	addi	r2,r2,1
 822bf50:	d0a09a15 	stw	r2,-32152(gp)
         }
         break;
 822bf54:	00000806 	br	822bf78 <dhc_second+0x51c>
      case DHCS_UNUSED:
      default:
         continue;
 822bf58:	0001883a 	nop
 822bf5c:	00000706 	br	822bf7c <dhc_second+0x520>
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822bf60:	0001883a 	nop
 822bf64:	00000506 	br	822bf7c <dhc_second+0x520>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822bf68:	0001883a 	nop
 822bf6c:	00000306 	br	822bf7c <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_renew++;
         }
         break;
 822bf70:	0001883a 	nop
 822bf74:	00000106 	br	822bf7c <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822bf78:	0001883a 	nop
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822bf7c:	e0bffc17 	ldw	r2,-16(fp)
 822bf80:	10800044 	addi	r2,r2,1
 822bf84:	e0bffc15 	stw	r2,-16(fp)
 822bf88:	e0bffc17 	ldw	r2,-16(fp)
 822bf8c:	10800110 	cmplti	r2,r2,4
 822bf90:	103eb81e 	bne	r2,zero,822ba74 <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 822bf94:	0005883a 	mov	r2,zero
}
 822bf98:	e037883a 	mov	sp,fp
 822bf9c:	dfc00117 	ldw	ra,4(sp)
 822bfa0:	df000017 	ldw	fp,0(sp)
 822bfa4:	dec00204 	addi	sp,sp,8
 822bfa8:	f800283a 	ret

0822bfac <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 822bfac:	defffd04 	addi	sp,sp,-12
 822bfb0:	dfc00215 	stw	ra,8(sp)
 822bfb4:	df000115 	stw	fp,4(sp)
 822bfb8:	df000104 	addi	fp,sp,4
 822bfbc:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 822bfc0:	e0bfff17 	ldw	r2,-4(fp)
 822bfc4:	10000316 	blt	r2,zero,822bfd4 <dhc_halt+0x28>
 822bfc8:	e0bfff17 	ldw	r2,-4(fp)
 822bfcc:	10800150 	cmplti	r2,r2,5
 822bfd0:	1000021e 	bne	r2,zero,822bfdc <dhc_halt+0x30>
   {
      dtrap();
 822bfd4:	822d2e00 	call	822d2e0 <dtrap>
      return;
 822bfd8:	00000f06 	br	822c018 <dhc_halt+0x6c>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 822bfdc:	e0bfff17 	ldw	r2,-4(fp)
 822bfe0:	10c00f24 	muli	r3,r2,60
 822bfe4:	008209b4 	movhi	r2,2086
 822bfe8:	10b76004 	addi	r2,r2,-8832
 822bfec:	1885883a 	add	r2,r3,r2
 822bff0:	01800f04 	movi	r6,60
 822bff4:	000b883a 	mov	r5,zero
 822bff8:	1009883a 	mov	r4,r2
 822bffc:	8202f000 	call	8202f00 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 822c000:	008209b4 	movhi	r2,2086
 822c004:	10b76004 	addi	r2,r2,-8832
 822c008:	e0ffff17 	ldw	r3,-4(fp)
 822c00c:	18c00f24 	muli	r3,r3,60
 822c010:	10c5883a 	add	r2,r2,r3
 822c014:	10000015 	stw	zero,0(r2)
}
 822c018:	e037883a 	mov	sp,fp
 822c01c:	dfc00117 	ldw	ra,4(sp)
 822c020:	df000017 	ldw	fp,0(sp)
 822c024:	dec00204 	addi	sp,sp,8
 822c028:	f800283a 	ret

0822c02c <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 822c02c:	defffc04 	addi	sp,sp,-16
 822c030:	dfc00315 	stw	ra,12(sp)
 822c034:	df000215 	stw	fp,8(sp)
 822c038:	df000204 	addi	fp,sp,8
 822c03c:	e13fff15 	stw	r4,-4(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 822c040:	008209b4 	movhi	r2,2086
 822c044:	10b73a04 	addi	r2,r2,-8984
 822c048:	e0ffff17 	ldw	r3,-4(fp)
 822c04c:	18c7883a 	add	r3,r3,r3
 822c050:	18c7883a 	add	r3,r3,r3
 822c054:	10c5883a 	add	r2,r2,r3
 822c058:	10800017 	ldw	r2,0(r2)
 822c05c:	10800a17 	ldw	r2,40(r2)
 822c060:	1000031e 	bne	r2,zero,822c070 <dhc_reclaim+0x44>
   {
      dtrap();    /* programming bug? */
 822c064:	822d2e00 	call	822d2e0 <dtrap>
      return ENP_LOGIC;
 822c068:	00bffd44 	movi	r2,-11
 822c06c:	00005806 	br	822c1d0 <dhc_reclaim+0x1a4>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 822c070:	008209b4 	movhi	r2,2086
 822c074:	10b73a04 	addi	r2,r2,-8984
 822c078:	e0ffff17 	ldw	r3,-4(fp)
 822c07c:	18c7883a 	add	r3,r3,r3
 822c080:	18c7883a 	add	r3,r3,r3
 822c084:	10c5883a 	add	r2,r2,r3
 822c088:	10800017 	ldw	r2,0(r2)
 822c08c:	10c00a17 	ldw	r3,40(r2)
 822c090:	008209b4 	movhi	r2,2086
 822c094:	10b76004 	addi	r2,r2,-8832
 822c098:	e13fff17 	ldw	r4,-4(fp)
 822c09c:	21000f24 	muli	r4,r4,60
 822c0a0:	1105883a 	add	r2,r2,r4
 822c0a4:	10800904 	addi	r2,r2,36
 822c0a8:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 822c0ac:	008209b4 	movhi	r2,2086
 822c0b0:	10b73a04 	addi	r2,r2,-8984
 822c0b4:	e0ffff17 	ldw	r3,-4(fp)
 822c0b8:	18c7883a 	add	r3,r3,r3
 822c0bc:	18c7883a 	add	r3,r3,r3
 822c0c0:	10c5883a 	add	r2,r2,r3
 822c0c4:	10800017 	ldw	r2,0(r2)
 822c0c8:	10c00c17 	ldw	r3,48(r2)
 822c0cc:	008209b4 	movhi	r2,2086
 822c0d0:	10b76004 	addi	r2,r2,-8832
 822c0d4:	e13fff17 	ldw	r4,-4(fp)
 822c0d8:	21000f24 	muli	r4,r4,60
 822c0dc:	1105883a 	add	r2,r2,r4
 822c0e0:	10800a04 	addi	r2,r2,40
 822c0e4:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 822c0e8:	008209b4 	movhi	r2,2086
 822c0ec:	10b73a04 	addi	r2,r2,-8984
 822c0f0:	e0ffff17 	ldw	r3,-4(fp)
 822c0f4:	18c7883a 	add	r3,r3,r3
 822c0f8:	18c7883a 	add	r3,r3,r3
 822c0fc:	10c5883a 	add	r2,r2,r3
 822c100:	10800017 	ldw	r2,0(r2)
 822c104:	10c00d17 	ldw	r3,52(r2)
 822c108:	008209b4 	movhi	r2,2086
 822c10c:	10b76004 	addi	r2,r2,-8832
 822c110:	e13fff17 	ldw	r4,-4(fp)
 822c114:	21000f24 	muli	r4,r4,60
 822c118:	1105883a 	add	r2,r2,r4
 822c11c:	10800b04 	addi	r2,r2,44
 822c120:	10c00015 	stw	r3,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 822c124:	008209b4 	movhi	r2,2086
 822c128:	10b76004 	addi	r2,r2,-8832
 822c12c:	e0ffff17 	ldw	r3,-4(fp)
 822c130:	18c00f24 	muli	r3,r3,60
 822c134:	10c5883a 	add	r2,r2,r3
 822c138:	10800c04 	addi	r2,r2,48
 822c13c:	10800017 	ldw	r2,0(r2)
 822c140:	10002026 	beq	r2,zero,822c1c4 <dhc_reclaim+0x198>
   {
      if (dhc_states[iface].srv_ipaddr)
 822c144:	008209b4 	movhi	r2,2086
 822c148:	10b76004 	addi	r2,r2,-8832
 822c14c:	e0ffff17 	ldw	r3,-4(fp)
 822c150:	18c00f24 	muli	r3,r3,60
 822c154:	10c5883a 	add	r2,r2,r3
 822c158:	10800d04 	addi	r2,r2,52
 822c15c:	10800017 	ldw	r2,0(r2)
 822c160:	10001726 	beq	r2,zero,822c1c0 <dhc_reclaim+0x194>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 822c164:	008209b4 	movhi	r2,2086
 822c168:	10b76004 	addi	r2,r2,-8832
 822c16c:	e0ffff17 	ldw	r3,-4(fp)
 822c170:	18c00f24 	muli	r3,r3,60
 822c174:	10c5883a 	add	r2,r2,r3
 822c178:	10800d04 	addi	r2,r2,52
 822c17c:	11000017 	ldw	r4,0(r2)
 822c180:	008209b4 	movhi	r2,2086
 822c184:	10b76004 	addi	r2,r2,-8832
 822c188:	e0ffff17 	ldw	r3,-4(fp)
 822c18c:	18c00f24 	muli	r3,r3,60
 822c190:	10c5883a 	add	r2,r2,r3
 822c194:	10800c04 	addi	r2,r2,48
 822c198:	10c00017 	ldw	r3,0(r2)
 822c19c:	00800084 	movi	r2,2
 822c1a0:	d8800015 	stw	r2,0(sp)
 822c1a4:	e1ffff17 	ldw	r7,-4(fp)
 822c1a8:	180d883a 	mov	r6,r3
 822c1ac:	017fffc4 	movi	r5,-1
 822c1b0:	824407c0 	call	824407c <add_route>
 822c1b4:	1000031e 	bne	r2,zero,822c1c4 <dhc_reclaim+0x198>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 822c1b8:	822d2e00 	call	822d2e0 <dtrap>
 822c1bc:	00000106 	br	822c1c4 <dhc_reclaim+0x198>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 822c1c0:	822d2e00 	call	822d2e0 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 822c1c4:	01400044 	movi	r5,1
 822c1c8:	e13fff17 	ldw	r4,-4(fp)
 822c1cc:	822a8540 	call	822a854 <dhc_request>
}
 822c1d0:	e037883a 	mov	sp,fp
 822c1d4:	dfc00117 	ldw	ra,4(sp)
 822c1d8:	df000017 	ldw	fp,0(sp)
 822c1dc:	dec00204 	addi	sp,sp,8
 822c1e0:	f800283a 	ret

0822c1e4 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 822c1e4:	defffb04 	addi	sp,sp,-20
 822c1e8:	dfc00415 	stw	ra,16(sp)
 822c1ec:	df000315 	stw	fp,12(sp)
 822c1f0:	df000304 	addi	fp,sp,12
 822c1f4:	e13ffe15 	stw	r4,-8(fp)
 822c1f8:	e17fff15 	stw	r5,-4(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 822c1fc:	e0bfff17 	ldw	r2,-4(fp)
 822c200:	10800058 	cmpnei	r2,r2,1
 822c204:	1000021e 	bne	r2,zero,822c210 <dhc_state_init+0x2c>
 822c208:	00800044 	movi	r2,1
 822c20c:	00000106 	br	822c214 <dhc_state_init+0x30>
 822c210:	00800084 	movi	r2,2
 822c214:	e0bffd15 	stw	r2,-12(fp)
   
   dhc_set_state(iface, state);
 822c218:	e17ffd17 	ldw	r5,-12(fp)
 822c21c:	e13ffe17 	ldw	r4,-8(fp)
 822c220:	822c32c0 	call	822c32c <dhc_set_state>
}
 822c224:	0001883a 	nop
 822c228:	e037883a 	mov	sp,fp
 822c22c:	dfc00117 	ldw	ra,4(sp)
 822c230:	df000017 	ldw	fp,0(sp)
 822c234:	dec00204 	addi	sp,sp,8
 822c238:	f800283a 	ret

0822c23c <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 822c23c:	defffe04 	addi	sp,sp,-8
 822c240:	df000115 	stw	fp,4(sp)
 822c244:	df000104 	addi	fp,sp,4
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c248:	e03fff15 	stw	zero,-4(fp)
 822c24c:	00001506 	br	822c2a4 <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c250:	008209b4 	movhi	r2,2086
 822c254:	10b76004 	addi	r2,r2,-8832
 822c258:	e0ffff17 	ldw	r3,-4(fp)
 822c25c:	18c00f24 	muli	r3,r3,60
 822c260:	10c5883a 	add	r2,r2,r3
 822c264:	10800017 	ldw	r2,0(r2)
 822c268:	10000826 	beq	r2,zero,822c28c <dhc_alldone+0x50>
          ( dhc_states[i].state == DHCS_BOUND  )  )
 822c26c:	008209b4 	movhi	r2,2086
 822c270:	10b76004 	addi	r2,r2,-8832
 822c274:	e0ffff17 	ldw	r3,-4(fp)
 822c278:	18c00f24 	muli	r3,r3,60
 822c27c:	10c5883a 	add	r2,r2,r3
 822c280:	10800017 	ldw	r2,0(r2)
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c284:	10800198 	cmpnei	r2,r2,6
 822c288:	1000041e 	bne	r2,zero,822c29c <dhc_alldone+0x60>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c28c:	e0bfff17 	ldw	r2,-4(fp)
 822c290:	10800044 	addi	r2,r2,1
 822c294:	e0bfff15 	stw	r2,-4(fp)
 822c298:	00000206 	br	822c2a4 <dhc_alldone+0x68>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 822c29c:	0005883a 	mov	r2,zero
 822c2a0:	00000406 	br	822c2b4 <dhc_alldone+0x78>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c2a4:	e0bfff17 	ldw	r2,-4(fp)
 822c2a8:	10800110 	cmplti	r2,r2,4
 822c2ac:	103fe81e 	bne	r2,zero,822c250 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 822c2b0:	00800044 	movi	r2,1
}
 822c2b4:	e037883a 	mov	sp,fp
 822c2b8:	df000017 	ldw	fp,0(sp)
 822c2bc:	dec00104 	addi	sp,sp,4
 822c2c0:	f800283a 	ret

0822c2c4 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 822c2c4:	defffe04 	addi	sp,sp,-8
 822c2c8:	df000115 	stw	fp,4(sp)
 822c2cc:	df000104 	addi	fp,sp,4
 822c2d0:	e13fff15 	stw	r4,-4(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c2d4:	008209b4 	movhi	r2,2086
 822c2d8:	10b76004 	addi	r2,r2,-8832
 822c2dc:	e0ffff17 	ldw	r3,-4(fp)
 822c2e0:	18c00f24 	muli	r3,r3,60
 822c2e4:	10c5883a 	add	r2,r2,r3
 822c2e8:	10800017 	ldw	r2,0(r2)
 822c2ec:	10000826 	beq	r2,zero,822c310 <dhc_ifacedone+0x4c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
 822c2f0:	008209b4 	movhi	r2,2086
 822c2f4:	10b76004 	addi	r2,r2,-8832
 822c2f8:	e0ffff17 	ldw	r3,-4(fp)
 822c2fc:	18c00f24 	muli	r3,r3,60
 822c300:	10c5883a 	add	r2,r2,r3
 822c304:	10800017 	ldw	r2,0(r2)
 */

int 
dhc_ifacedone(int iface)
{
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c308:	10800198 	cmpnei	r2,r2,6
 822c30c:	1000021e 	bne	r2,zero,822c318 <dhc_ifacedone+0x54>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 822c310:	00800044 	movi	r2,1
 822c314:	00000106 	br	822c31c <dhc_ifacedone+0x58>
   }
   else
   {
      return FALSE ;
 822c318:	0005883a 	mov	r2,zero
   }
}
 822c31c:	e037883a 	mov	sp,fp
 822c320:	df000017 	ldw	fp,0(sp)
 822c324:	dec00104 	addi	sp,sp,4
 822c328:	f800283a 	ret

0822c32c <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 822c32c:	defffc04 	addi	sp,sp,-16
 822c330:	dfc00315 	stw	ra,12(sp)
 822c334:	df000215 	stw	fp,8(sp)
 822c338:	df000204 	addi	fp,sp,8
 822c33c:	e13ffe15 	stw	r4,-8(fp)
 822c340:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 822c344:	e0ffff17 	ldw	r3,-4(fp)
 822c348:	008209b4 	movhi	r2,2086
 822c34c:	10b76004 	addi	r2,r2,-8832
 822c350:	e13ffe17 	ldw	r4,-8(fp)
 822c354:	21000f24 	muli	r4,r4,60
 822c358:	1105883a 	add	r2,r2,r4
 822c35c:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 822c360:	008209b4 	movhi	r2,2086
 822c364:	10b76004 	addi	r2,r2,-8832
 822c368:	e0fffe17 	ldw	r3,-8(fp)
 822c36c:	18c00f24 	muli	r3,r3,60
 822c370:	10c5883a 	add	r2,r2,r3
 822c374:	10800104 	addi	r2,r2,4
 822c378:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 822c37c:	008209b4 	movhi	r2,2086
 822c380:	10b76004 	addi	r2,r2,-8832
 822c384:	e0fffe17 	ldw	r3,-8(fp)
 822c388:	18c00f24 	muli	r3,r3,60
 822c38c:	10c5883a 	add	r2,r2,r3
 822c390:	10800e04 	addi	r2,r2,56
 822c394:	10800017 	ldw	r2,0(r2)
 822c398:	10000a26 	beq	r2,zero,822c3c4 <dhc_set_state+0x98>
      dhc_states[iface].callback(iface,state);
 822c39c:	008209b4 	movhi	r2,2086
 822c3a0:	10b76004 	addi	r2,r2,-8832
 822c3a4:	e0fffe17 	ldw	r3,-8(fp)
 822c3a8:	18c00f24 	muli	r3,r3,60
 822c3ac:	10c5883a 	add	r2,r2,r3
 822c3b0:	10800e04 	addi	r2,r2,56
 822c3b4:	10800017 	ldw	r2,0(r2)
 822c3b8:	e17fff17 	ldw	r5,-4(fp)
 822c3bc:	e13ffe17 	ldw	r4,-8(fp)
 822c3c0:	103ee83a 	callr	r2
}
 822c3c4:	0001883a 	nop
 822c3c8:	e037883a 	mov	sp,fp
 822c3cc:	dfc00117 	ldw	ra,4(sp)
 822c3d0:	df000017 	ldw	fp,0(sp)
 822c3d4:	dec00204 	addi	sp,sp,8
 822c3d8:	f800283a 	ret

0822c3dc <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 822c3dc:	defffc04 	addi	sp,sp,-16
 822c3e0:	df000315 	stw	fp,12(sp)
 822c3e4:	df000304 	addi	fp,sp,12
 822c3e8:	2005883a 	mov	r2,r4
 822c3ec:	e17fff15 	stw	r5,-4(fp)
 822c3f0:	e0bffe05 	stb	r2,-8(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 822c3f4:	e0bfff17 	ldw	r2,-4(fp)
 822c3f8:	10804e04 	addi	r2,r2,312
 822c3fc:	e0bffd15 	stw	r2,-12(fp)

   while (opts < end)
 822c400:	00001e06 	br	822c47c <find_opt+0xa0>
   {
      if (*opts == opcode) /* found it */
 822c404:	e0bfff17 	ldw	r2,-4(fp)
 822c408:	10800003 	ldbu	r2,0(r2)
 822c40c:	10c03fcc 	andi	r3,r2,255
 822c410:	e0bffe03 	ldbu	r2,-8(fp)
 822c414:	1880021e 	bne	r3,r2,822c420 <find_opt+0x44>
         return opts;
 822c418:	e0bfff17 	ldw	r2,-4(fp)
 822c41c:	00001b06 	br	822c48c <find_opt+0xb0>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 822c420:	e0bfff17 	ldw	r2,-4(fp)
 822c424:	10800003 	ldbu	r2,0(r2)
 822c428:	10803fcc 	andi	r2,r2,255
 822c42c:	10803fd8 	cmpnei	r2,r2,255
 822c430:	1000021e 	bne	r2,zero,822c43c <find_opt+0x60>
         return NULL;
 822c434:	0005883a 	mov	r2,zero
 822c438:	00001406 	br	822c48c <find_opt+0xb0>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 822c43c:	e0bfff17 	ldw	r2,-4(fp)
 822c440:	10800003 	ldbu	r2,0(r2)
 822c444:	10803fcc 	andi	r2,r2,255
 822c448:	1000041e 	bne	r2,zero,822c45c <find_opt+0x80>
         opts++;
 822c44c:	e0bfff17 	ldw	r2,-4(fp)
 822c450:	10800044 	addi	r2,r2,1
 822c454:	e0bfff15 	stw	r2,-4(fp)
 822c458:	00000806 	br	822c47c <find_opt+0xa0>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 822c45c:	e0bfff17 	ldw	r2,-4(fp)
 822c460:	10800044 	addi	r2,r2,1
 822c464:	10800003 	ldbu	r2,0(r2)
 822c468:	10803fcc 	andi	r2,r2,255
 822c46c:	10800084 	addi	r2,r2,2
 822c470:	e0ffff17 	ldw	r3,-4(fp)
 822c474:	1885883a 	add	r2,r3,r2
 822c478:	e0bfff15 	stw	r2,-4(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 822c47c:	e0ffff17 	ldw	r3,-4(fp)
 822c480:	e0bffd17 	ldw	r2,-12(fp)
 822c484:	18bfdf36 	bltu	r3,r2,822c404 <find_opt+0x28>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 822c488:	0005883a 	mov	r2,zero
}
 822c48c:	e037883a 	mov	sp,fp
 822c490:	df000017 	ldw	fp,0(sp)
 822c494:	dec00104 	addi	sp,sp,4
 822c498:	f800283a 	ret

0822c49c <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 822c49c:	defff804 	addi	sp,sp,-32
 822c4a0:	dfc00715 	stw	ra,28(sp)
 822c4a4:	df000615 	stw	fp,24(sp)
 822c4a8:	df000604 	addi	fp,sp,24
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 822c4ac:	d0e03817 	ldw	r3,-32544(gp)
 822c4b0:	d0a03617 	ldw	r2,-32552(gp)
 822c4b4:	1885883a 	add	r2,r3,r2
 822c4b8:	e0bffd15 	stw	r2,-12(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 822c4bc:	e03ffe05 	stb	zero,-8(fp)
#endif

   for (i = 0; i < numpkts; i++)
 822c4c0:	e03ffa15 	stw	zero,-24(fp)
 822c4c4:	00007a06 	br	822c6b0 <pk_init+0x214>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 822c4c8:	01000d04 	movi	r4,52
 822c4cc:	822deb80 	call	822deb8 <npalloc>
 822c4d0:	e0bfff15 	stw	r2,-4(fp)
      if (packet == NULL)
 822c4d4:	e0bfff17 	ldw	r2,-4(fp)
 822c4d8:	10008426 	beq	r2,zero,822c6ec <pk_init+0x250>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 822c4dc:	e0bffa17 	ldw	r2,-24(fp)
 822c4e0:	10800f30 	cmpltui	r2,r2,60
 822c4e4:	1000051e 	bne	r2,zero,822c4fc <pk_init+0x60>
      {
         dprintf("pk_init: bad define\n");
 822c4e8:	01020974 	movhi	r4,2085
 822c4ec:	21013a04 	addi	r4,r4,1256
 822c4f0:	82033700 	call	8203370 <puts>
         return -1;
 822c4f4:	00bfffc4 	movi	r2,-1
 822c4f8:	00008a06 	br	822c724 <pk_init+0x288>
      }
      pktlog[i] = packet;     /* save for debugging */
 822c4fc:	008209b4 	movhi	r2,2086
 822c500:	10b7a504 	addi	r2,r2,-8556
 822c504:	e0fffa17 	ldw	r3,-24(fp)
 822c508:	18c7883a 	add	r3,r3,r3
 822c50c:	18c7883a 	add	r3,r3,r3
 822c510:	10c5883a 	add	r2,r2,r3
 822c514:	e0ffff17 	ldw	r3,-4(fp)
 822c518:	10c00015 	stw	r3,0(r2)
#endif

      packet->nb_tstamp = 0L;
 822c51c:	e0bfff17 	ldw	r2,-4(fp)
 822c520:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 822c524:	d0a03817 	ldw	r2,-32544(gp)
 822c528:	e0fffa17 	ldw	r3,-24(fp)
 822c52c:	18802f2e 	bgeu	r3,r2,822c5ec <pk_init+0x150>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 822c530:	d0a03917 	ldw	r2,-32540(gp)
 822c534:	10800144 	addi	r2,r2,5
 822c538:	1009883a 	mov	r4,r2
 822c53c:	822df2c0 	call	822df2c <ncpalloc>
 822c540:	1007883a 	mov	r3,r2
 822c544:	e0bfff17 	ldw	r2,-4(fp)
 822c548:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c54c:	e0bfff17 	ldw	r2,-4(fp)
 822c550:	10800117 	ldw	r2,4(r2)
 822c554:	10006726 	beq	r2,zero,822c6f4 <pk_init+0x258>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c558:	e03ffb15 	stw	zero,-20(fp)
 822c55c:	00000906 	br	822c584 <pk_init+0xe8>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c560:	e0bfff17 	ldw	r2,-4(fp)
 822c564:	10c00117 	ldw	r3,4(r2)
 822c568:	e0bffb17 	ldw	r2,-20(fp)
 822c56c:	1885883a 	add	r2,r3,r2
 822c570:	00c01344 	movi	r3,77
 822c574:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c578:	e0bffb17 	ldw	r2,-20(fp)
 822c57c:	10800044 	addi	r2,r2,1
 822c580:	e0bffb15 	stw	r2,-20(fp)
 822c584:	e0bffb17 	ldw	r2,-20(fp)
 822c588:	10800110 	cmplti	r2,r2,4
 822c58c:	103ff41e 	bne	r2,zero,822c560 <pk_init+0xc4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 822c590:	e0bfff17 	ldw	r2,-4(fp)
 822c594:	10c00117 	ldw	r3,4(r2)
 822c598:	d0a03917 	ldw	r2,-32540(gp)
 822c59c:	10800104 	addi	r2,r2,4
 822c5a0:	1885883a 	add	r2,r3,r2
 822c5a4:	00c01344 	movi	r3,77
 822c5a8:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 822c5ac:	e0bfff17 	ldw	r2,-4(fp)
 822c5b0:	10800117 	ldw	r2,4(r2)
 822c5b4:	10c00104 	addi	r3,r2,4
 822c5b8:	e0bfff17 	ldw	r2,-4(fp)
 822c5bc:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c5c0:	e0bfff17 	ldw	r2,-4(fp)
 822c5c4:	10800117 	ldw	r2,4(r2)
 822c5c8:	10004c26 	beq	r2,zero,822c6fc <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 822c5cc:	d0e03917 	ldw	r3,-32540(gp)
 822c5d0:	e0bfff17 	ldw	r2,-4(fp)
 822c5d4:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 822c5d8:	e17fff17 	ldw	r5,-4(fp)
 822c5dc:	010209b4 	movhi	r4,2086
 822c5e0:	2137e104 	addi	r4,r4,-8316
 822c5e4:	822ccc80 	call	822ccc8 <putq>
 822c5e8:	00002e06 	br	822c6a4 <pk_init+0x208>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 822c5ec:	d0a03717 	ldw	r2,-32548(gp)
 822c5f0:	10800144 	addi	r2,r2,5
 822c5f4:	1009883a 	mov	r4,r2
 822c5f8:	822df2c0 	call	822df2c <ncpalloc>
 822c5fc:	1007883a 	mov	r3,r2
 822c600:	e0bfff17 	ldw	r2,-4(fp)
 822c604:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c608:	e0bfff17 	ldw	r2,-4(fp)
 822c60c:	10800117 	ldw	r2,4(r2)
 822c610:	10003c26 	beq	r2,zero,822c704 <pk_init+0x268>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c614:	e03ffc15 	stw	zero,-16(fp)
 822c618:	00000906 	br	822c640 <pk_init+0x1a4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c61c:	e0bfff17 	ldw	r2,-4(fp)
 822c620:	10c00117 	ldw	r3,4(r2)
 822c624:	e0bffc17 	ldw	r2,-16(fp)
 822c628:	1885883a 	add	r2,r3,r2
 822c62c:	00c01344 	movi	r3,77
 822c630:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c634:	e0bffc17 	ldw	r2,-16(fp)
 822c638:	10800044 	addi	r2,r2,1
 822c63c:	e0bffc15 	stw	r2,-16(fp)
 822c640:	e0bffc17 	ldw	r2,-16(fp)
 822c644:	10800110 	cmplti	r2,r2,4
 822c648:	103ff41e 	bne	r2,zero,822c61c <pk_init+0x180>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 822c64c:	e0bfff17 	ldw	r2,-4(fp)
 822c650:	10c00117 	ldw	r3,4(r2)
 822c654:	d0a03717 	ldw	r2,-32548(gp)
 822c658:	10800104 	addi	r2,r2,4
 822c65c:	1885883a 	add	r2,r3,r2
 822c660:	00c01344 	movi	r3,77
 822c664:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;
 822c668:	e0bfff17 	ldw	r2,-4(fp)
 822c66c:	10800117 	ldw	r2,4(r2)
 822c670:	10c00104 	addi	r3,r2,4
 822c674:	e0bfff17 	ldw	r2,-4(fp)
 822c678:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c67c:	e0bfff17 	ldw	r2,-4(fp)
 822c680:	10800117 	ldw	r2,4(r2)
 822c684:	10002126 	beq	r2,zero,822c70c <pk_init+0x270>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 822c688:	d0e03717 	ldw	r3,-32548(gp)
 822c68c:	e0bfff17 	ldw	r2,-4(fp)
 822c690:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 822c694:	e17fff17 	ldw	r5,-4(fp)
 822c698:	010209b4 	movhi	r4,2086
 822c69c:	21379c04 	addi	r4,r4,-8592
 822c6a0:	822ccc80 	call	822ccc8 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 822c6a4:	e0bffa17 	ldw	r2,-24(fp)
 822c6a8:	10800044 	addi	r2,r2,1
 822c6ac:	e0bffa15 	stw	r2,-24(fp)
 822c6b0:	e0fffa17 	ldw	r3,-24(fp)
 822c6b4:	e0bffd17 	ldw	r2,-12(fp)
 822c6b8:	18bf8336 	bltu	r3,r2,822c4c8 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 822c6bc:	d0a03817 	ldw	r2,-32544(gp)
 822c6c0:	1007883a 	mov	r3,r2
 822c6c4:	008209b4 	movhi	r2,2086
 822c6c8:	10b7e104 	addi	r2,r2,-8316
 822c6cc:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 822c6d0:	d0a03617 	ldw	r2,-32552(gp)
 822c6d4:	1007883a 	mov	r3,r2
 822c6d8:	008209b4 	movhi	r2,2086
 822c6dc:	10b79c04 	addi	r2,r2,-8592
 822c6e0:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 822c6e4:	0005883a 	mov	r2,zero
 822c6e8:	00000e06 	br	822c724 <pk_init+0x288>

   for (i = 0; i < numpkts; i++)
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
      if (packet == NULL)
         goto no_pkt_buf;
 822c6ec:	0001883a 	nop
 822c6f0:	00000706 	br	822c710 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c6f4:	0001883a 	nop
 822c6f8:	00000506 	br	822c710 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c6fc:	0001883a 	nop
 822c700:	00000306 	br	822c710 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c704:	0001883a 	nop
 822c708:	00000106 	br	822c710 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c70c:	0001883a 	nop

   return 0;

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 822c710:	e17ffa17 	ldw	r5,-24(fp)
 822c714:	01020974 	movhi	r4,2085
 822c718:	21013f04 	addi	r4,r4,1276
 822c71c:	82030ec0 	call	82030ec <printf>
#endif
   return(-1);
 822c720:	00bfffc4 	movi	r2,-1
}
 822c724:	e037883a 	mov	sp,fp
 822c728:	dfc00117 	ldw	ra,4(sp)
 822c72c:	df000017 	ldw	fp,0(sp)
 822c730:	dec00204 	addi	sp,sp,8
 822c734:	f800283a 	ret

0822c738 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 822c738:	defffc04 	addi	sp,sp,-16
 822c73c:	dfc00315 	stw	ra,12(sp)
 822c740:	df000215 	stw	fp,8(sp)
 822c744:	df000204 	addi	fp,sp,8
 822c748:	e13fff15 	stw	r4,-4(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 822c74c:	d0e03917 	ldw	r3,-32540(gp)
 822c750:	e0bfff17 	ldw	r2,-4(fp)
 822c754:	1880022e 	bgeu	r3,r2,822c760 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 822c758:	0005883a 	mov	r2,zero
 822c75c:	00002206 	br	822c7e8 <pk_alloc+0xb0>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 822c760:	d0e03717 	ldw	r3,-32548(gp)
 822c764:	e0bfff17 	ldw	r2,-4(fp)
 822c768:	18800436 	bltu	r3,r2,822c77c <pk_alloc+0x44>
 822c76c:	008209b4 	movhi	r2,2086
 822c770:	10b79c04 	addi	r2,r2,-8592
 822c774:	10800217 	ldw	r2,8(r2)
 822c778:	1000051e 	bne	r2,zero,822c790 <pk_alloc+0x58>
         p = (PACKET)getq(&bigfreeq);
 822c77c:	010209b4 	movhi	r4,2086
 822c780:	2137e104 	addi	r4,r4,-8316
 822c784:	822cc100 	call	822cc10 <getq>
 822c788:	e0bffe15 	stw	r2,-8(fp)
 822c78c:	00000406 	br	822c7a0 <pk_alloc+0x68>
      else
         p = (PACKET)getq(&lilfreeq);
 822c790:	010209b4 	movhi	r4,2086
 822c794:	21379c04 	addi	r4,r4,-8592
 822c798:	822cc100 	call	822cc10 <getq>
 822c79c:	e0bffe15 	stw	r2,-8(fp)

      if (!p)
 822c7a0:	e0bffe17 	ldw	r2,-8(fp)
 822c7a4:	1000021e 	bne	r2,zero,822c7b0 <pk_alloc+0x78>
         return NULL;
 822c7a8:	0005883a 	mov	r2,zero
 822c7ac:	00000e06 	br	822c7e8 <pk_alloc+0xb0>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 822c7b0:	e0bffe17 	ldw	r2,-8(fp)
 822c7b4:	10800117 	ldw	r2,4(r2)
 822c7b8:	d0e08117 	ldw	r3,-32252(gp)
 822c7bc:	10c7883a 	add	r3,r2,r3
 822c7c0:	e0bffe17 	ldw	r2,-8(fp)
 822c7c4:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 822c7c8:	e0bffe17 	ldw	r2,-8(fp)
 822c7cc:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 822c7d0:	e0bffe17 	ldw	r2,-8(fp)
 822c7d4:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 822c7d8:	e0bffe17 	ldw	r2,-8(fp)
 822c7dc:	00c00044 	movi	r3,1
 822c7e0:	10c00915 	stw	r3,36(r2)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 822c7e4:	e0bffe17 	ldw	r2,-8(fp)
}
 822c7e8:	e037883a 	mov	sp,fp
 822c7ec:	dfc00117 	ldw	ra,4(sp)
 822c7f0:	df000017 	ldw	fp,0(sp)
 822c7f4:	dec00204 	addi	sp,sp,8
 822c7f8:	f800283a 	ret

0822c7fc <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 822c7fc:	defffb04 	addi	sp,sp,-20
 822c800:	dfc00415 	stw	ra,16(sp)
 822c804:	df000315 	stw	fp,12(sp)
 822c808:	df000304 	addi	fp,sp,12
 822c80c:	e13fff15 	stw	r4,-4(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 822c810:	e0bfff17 	ldw	r2,-4(fp)
 822c814:	10800017 	ldw	r2,0(r2)
 822c818:	10000e26 	beq	r2,zero,822c854 <pk_validate+0x58>
 822c81c:	e0bfff17 	ldw	r2,-4(fp)
 822c820:	10800917 	ldw	r2,36(r2)
 822c824:	10000b26 	beq	r2,zero,822c854 <pk_validate+0x58>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 822c828:	822d4b80 	call	822d4b8 <irq_Mask>
 822c82c:	008209b4 	movhi	r2,2086
 822c830:	10b7a104 	addi	r2,r2,-8572
 822c834:	10800317 	ldw	r2,12(r2)
 822c838:	10c00044 	addi	r3,r2,1
 822c83c:	008209b4 	movhi	r2,2086
 822c840:	10b7a104 	addi	r2,r2,-8572
 822c844:	10c00315 	stw	r3,12(r2)
 822c848:	822d5180 	call	822d518 <irq_Unmask>
      return -1;
 822c84c:	00bfffc4 	movi	r2,-1
 822c850:	00008806 	br	822ca74 <pk_validate+0x278>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 822c854:	e0bfff17 	ldw	r2,-4(fp)
 822c858:	10c00217 	ldw	r3,8(r2)
 822c85c:	d0a03917 	ldw	r2,-32540(gp)
 822c860:	1880201e 	bne	r3,r2,822c8e4 <pk_validate+0xe8>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 822c864:	822d4b80 	call	822d4b8 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822c868:	008209b4 	movhi	r2,2086
 822c86c:	10b7e104 	addi	r2,r2,-8316
 822c870:	10800017 	ldw	r2,0(r2)
 822c874:	e0bffd15 	stw	r2,-12(fp)
 822c878:	00001606 	br	822c8d4 <pk_validate+0xd8>
            if (p == pkt)
 822c87c:	e0fffd17 	ldw	r3,-12(fp)
 822c880:	e0bfff17 	ldw	r2,-4(fp)
 822c884:	1880101e 	bne	r3,r2,822c8c8 <pk_validate+0xcc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 822c888:	e17fff17 	ldw	r5,-4(fp)
 822c88c:	01020974 	movhi	r4,2085
 822c890:	21014a04 	addi	r4,r4,1320
 822c894:	82030ec0 	call	82030ec <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 822c898:	822d5180 	call	822d518 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822c89c:	822d4b80 	call	822d4b8 <irq_Mask>
 822c8a0:	008209b4 	movhi	r2,2086
 822c8a4:	10b7a104 	addi	r2,r2,-8572
 822c8a8:	10800217 	ldw	r2,8(r2)
 822c8ac:	10c00044 	addi	r3,r2,1
 822c8b0:	008209b4 	movhi	r2,2086
 822c8b4:	10b7a104 	addi	r2,r2,-8572
 822c8b8:	10c00215 	stw	r3,8(r2)
 822c8bc:	822d5180 	call	822d518 <irq_Unmask>
               return -1;
 822c8c0:	00bfffc4 	movi	r2,-1
 822c8c4:	00006b06 	br	822ca74 <pk_validate+0x278>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822c8c8:	e0bffd17 	ldw	r2,-12(fp)
 822c8cc:	10800017 	ldw	r2,0(r2)
 822c8d0:	e0bffd15 	stw	r2,-12(fp)
 822c8d4:	e0bffd17 	ldw	r2,-12(fp)
 822c8d8:	103fe81e 	bne	r2,zero,822c87c <pk_validate+0x80>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 822c8dc:	822d5180 	call	822d518 <irq_Unmask>
 822c8e0:	00002f06 	br	822c9a0 <pk_validate+0x1a4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 822c8e4:	e0bfff17 	ldw	r2,-4(fp)
 822c8e8:	10c00217 	ldw	r3,8(r2)
 822c8ec:	d0a03717 	ldw	r2,-32548(gp)
 822c8f0:	1880201e 	bne	r3,r2,822c974 <pk_validate+0x178>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 822c8f4:	822d4b80 	call	822d4b8 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822c8f8:	008209b4 	movhi	r2,2086
 822c8fc:	10b79c04 	addi	r2,r2,-8592
 822c900:	10800017 	ldw	r2,0(r2)
 822c904:	e0bffd15 	stw	r2,-12(fp)
 822c908:	00001606 	br	822c964 <pk_validate+0x168>
            if (p == pkt)
 822c90c:	e0fffd17 	ldw	r3,-12(fp)
 822c910:	e0bfff17 	ldw	r2,-4(fp)
 822c914:	1880101e 	bne	r3,r2,822c958 <pk_validate+0x15c>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 822c918:	e17fff17 	ldw	r5,-4(fp)
 822c91c:	01020974 	movhi	r4,2085
 822c920:	21015404 	addi	r4,r4,1360
 822c924:	82030ec0 	call	82030ec <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 822c928:	822d5180 	call	822d518 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822c92c:	822d4b80 	call	822d4b8 <irq_Mask>
 822c930:	008209b4 	movhi	r2,2086
 822c934:	10b7a104 	addi	r2,r2,-8572
 822c938:	10800217 	ldw	r2,8(r2)
 822c93c:	10c00044 	addi	r3,r2,1
 822c940:	008209b4 	movhi	r2,2086
 822c944:	10b7a104 	addi	r2,r2,-8572
 822c948:	10c00215 	stw	r3,8(r2)
 822c94c:	822d5180 	call	822d518 <irq_Unmask>
            return -1;
 822c950:	00bfffc4 	movi	r2,-1
 822c954:	00004706 	br	822ca74 <pk_validate+0x278>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822c958:	e0bffd17 	ldw	r2,-12(fp)
 822c95c:	10800017 	ldw	r2,0(r2)
 822c960:	e0bffd15 	stw	r2,-12(fp)
 822c964:	e0bffd17 	ldw	r2,-12(fp)
 822c968:	103fe81e 	bne	r2,zero,822c90c <pk_validate+0x110>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 822c96c:	822d5180 	call	822d518 <irq_Unmask>
 822c970:	00000b06 	br	822c9a0 <pk_validate+0x1a4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 822c974:	822d4b80 	call	822d4b8 <irq_Mask>
 822c978:	008209b4 	movhi	r2,2086
 822c97c:	10b7a104 	addi	r2,r2,-8572
 822c980:	10800017 	ldw	r2,0(r2)
 822c984:	10c00044 	addi	r3,r2,1
 822c988:	008209b4 	movhi	r2,2086
 822c98c:	10b7a104 	addi	r2,r2,-8572
 822c990:	10c00015 	stw	r3,0(r2)
 822c994:	822d5180 	call	822d518 <irq_Unmask>
         return -1;
 822c998:	00bfffc4 	movi	r2,-1
 822c99c:	00003506 	br	822ca74 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822c9a0:	00800104 	movi	r2,4
 822c9a4:	e0bffe15 	stw	r2,-8(fp)
 822c9a8:	00001906 	br	822ca10 <pk_validate+0x214>
   {
      if (*(pkt->nb_buff - j) != 'M')
 822c9ac:	e0bfff17 	ldw	r2,-4(fp)
 822c9b0:	10c00117 	ldw	r3,4(r2)
 822c9b4:	e0bffe17 	ldw	r2,-8(fp)
 822c9b8:	0085c83a 	sub	r2,zero,r2
 822c9bc:	1885883a 	add	r2,r3,r2
 822c9c0:	10800003 	ldbu	r2,0(r2)
 822c9c4:	10803fcc 	andi	r2,r2,255
 822c9c8:	1080201c 	xori	r2,r2,128
 822c9cc:	10bfe004 	addi	r2,r2,-128
 822c9d0:	10801360 	cmpeqi	r2,r2,77
 822c9d4:	10000b1e 	bne	r2,zero,822ca04 <pk_validate+0x208>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822c9d8:	822d4b80 	call	822d4b8 <irq_Mask>
 822c9dc:	008209b4 	movhi	r2,2086
 822c9e0:	10b7a104 	addi	r2,r2,-8572
 822c9e4:	10800117 	ldw	r2,4(r2)
 822c9e8:	10c00044 	addi	r3,r2,1
 822c9ec:	008209b4 	movhi	r2,2086
 822c9f0:	10b7a104 	addi	r2,r2,-8572
 822c9f4:	10c00115 	stw	r3,4(r2)
 822c9f8:	822d5180 	call	822d518 <irq_Unmask>
         return -1;
 822c9fc:	00bfffc4 	movi	r2,-1
 822ca00:	00001c06 	br	822ca74 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822ca04:	e0bffe17 	ldw	r2,-8(fp)
 822ca08:	10bfffc4 	addi	r2,r2,-1
 822ca0c:	e0bffe15 	stw	r2,-8(fp)
 822ca10:	e0bffe17 	ldw	r2,-8(fp)
 822ca14:	00bfe516 	blt	zero,r2,822c9ac <pk_validate+0x1b0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 822ca18:	e0bfff17 	ldw	r2,-4(fp)
 822ca1c:	10c00117 	ldw	r3,4(r2)
 822ca20:	e0bfff17 	ldw	r2,-4(fp)
 822ca24:	10800217 	ldw	r2,8(r2)
 822ca28:	1885883a 	add	r2,r3,r2
 822ca2c:	10800003 	ldbu	r2,0(r2)
 822ca30:	10803fcc 	andi	r2,r2,255
 822ca34:	1080201c 	xori	r2,r2,128
 822ca38:	10bfe004 	addi	r2,r2,-128
 822ca3c:	10801360 	cmpeqi	r2,r2,77
 822ca40:	10000b1e 	bne	r2,zero,822ca70 <pk_validate+0x274>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822ca44:	822d4b80 	call	822d4b8 <irq_Mask>
 822ca48:	008209b4 	movhi	r2,2086
 822ca4c:	10b7a104 	addi	r2,r2,-8572
 822ca50:	10800117 	ldw	r2,4(r2)
 822ca54:	10c00044 	addi	r3,r2,1
 822ca58:	008209b4 	movhi	r2,2086
 822ca5c:	10b7a104 	addi	r2,r2,-8572
 822ca60:	10c00115 	stw	r3,4(r2)
 822ca64:	822d5180 	call	822d518 <irq_Unmask>
      return -1;
 822ca68:	00bfffc4 	movi	r2,-1
 822ca6c:	00000106 	br	822ca74 <pk_validate+0x278>
   }
#endif /* NPDEBUG */

   return 0;
 822ca70:	0005883a 	mov	r2,zero
}
 822ca74:	e037883a 	mov	sp,fp
 822ca78:	dfc00117 	ldw	ra,4(sp)
 822ca7c:	df000017 	ldw	fp,0(sp)
 822ca80:	dec00204 	addi	sp,sp,8
 822ca84:	f800283a 	ret

0822ca88 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 822ca88:	defffc04 	addi	sp,sp,-16
 822ca8c:	dfc00315 	stw	ra,12(sp)
 822ca90:	df000215 	stw	fp,8(sp)
 822ca94:	df000204 	addi	fp,sp,8
 822ca98:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 822ca9c:	e13fff17 	ldw	r4,-4(fp)
 822caa0:	822c7fc0 	call	822c7fc <pk_validate>
 822caa4:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 822caa8:	e0bffe17 	ldw	r2,-8(fp)
 822caac:	1000191e 	bne	r2,zero,822cb14 <pk_free+0x8c>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 822cab0:	e0bfff17 	ldw	r2,-4(fp)
 822cab4:	10800917 	ldw	r2,36(r2)
 822cab8:	113fffc4 	addi	r4,r2,-1
 822cabc:	e0ffff17 	ldw	r3,-4(fp)
 822cac0:	19000915 	stw	r4,36(r3)
 822cac4:	108000b0 	cmpltui	r2,r2,2
 822cac8:	10001426 	beq	r2,zero,822cb1c <pk_free+0x94>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 822cacc:	e0bfff17 	ldw	r2,-4(fp)
 822cad0:	10c00217 	ldw	r3,8(r2)
 822cad4:	d0a03917 	ldw	r2,-32540(gp)
 822cad8:	1880051e 	bne	r3,r2,822caf0 <pk_free+0x68>
            q_add(&bigfreeq, (qp)pkt);
 822cadc:	e17fff17 	ldw	r5,-4(fp)
 822cae0:	010209b4 	movhi	r4,2086
 822cae4:	2137e104 	addi	r4,r4,-8316
 822cae8:	822ccc80 	call	822ccc8 <putq>
 822caec:	00000c06 	br	822cb20 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 822caf0:	e0bfff17 	ldw	r2,-4(fp)
 822caf4:	10c00217 	ldw	r3,8(r2)
 822caf8:	d0a03717 	ldw	r2,-32548(gp)
 822cafc:	1880081e 	bne	r3,r2,822cb20 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 822cb00:	e17fff17 	ldw	r5,-4(fp)
 822cb04:	010209b4 	movhi	r4,2086
 822cb08:	21379c04 	addi	r4,r4,-8592
 822cb0c:	822ccc80 	call	822ccc8 <putq>
 822cb10:	00000306 	br	822cb20 <pk_free+0x98>
         {
            pkt = pknext;
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
 822cb14:	0001883a 	nop
 822cb18:	00000106 	br	822cb20 <pk_free+0x98>
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
         return;  /* packet was cloned, don't delete yet */
 822cb1c:	0001883a 	nop
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 822cb20:	e037883a 	mov	sp,fp
 822cb24:	dfc00117 	ldw	ra,4(sp)
 822cb28:	df000017 	ldw	fp,0(sp)
 822cb2c:	dec00204 	addi	sp,sp,8
 822cb30:	f800283a 	ret

0822cb34 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 822cb34:	deffff04 	addi	sp,sp,-4
 822cb38:	df000015 	stw	fp,0(sp)
 822cb3c:	d839883a 	mov	fp,sp
   return bigbufsiz;
 822cb40:	d0a03917 	ldw	r2,-32540(gp)
}
 822cb44:	e037883a 	mov	sp,fp
 822cb48:	df000017 	ldw	fp,0(sp)
 822cb4c:	dec00104 	addi	sp,sp,4
 822cb50:	f800283a 	ret

0822cb54 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 822cb54:	defff904 	addi	sp,sp,-28
 822cb58:	dfc00615 	stw	ra,24(sp)
 822cb5c:	df000515 	stw	fp,20(sp)
 822cb60:	df000504 	addi	fp,sp,20
 822cb64:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 822cb68:	01000084 	movi	r4,2
 822cb6c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 822cb70:	822d4b80 	call	822d4b8 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 822cb74:	008209b4 	movhi	r2,2086
 822cb78:	10b7a104 	addi	r2,r2,-8572
 822cb7c:	10c00017 	ldw	r3,0(r2)
 822cb80:	e0fffb15 	stw	r3,-20(fp)
 822cb84:	10c00117 	ldw	r3,4(r2)
 822cb88:	e0fffc15 	stw	r3,-16(fp)
 822cb8c:	10c00217 	ldw	r3,8(r2)
 822cb90:	e0fffd15 	stw	r3,-12(fp)
 822cb94:	10800317 	ldw	r2,12(r2)
 822cb98:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 822cb9c:	822d5180 	call	822d518 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822cba0:	01000084 	movi	r4,2
 822cba4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 822cba8:	01420974 	movhi	r5,2085
 822cbac:	29415e04 	addi	r5,r5,1400
 822cbb0:	e13fff17 	ldw	r4,-4(fp)
 822cbb4:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 822cbb8:	e0bffb17 	ldw	r2,-20(fp)
 822cbbc:	e0fffc17 	ldw	r3,-16(fp)
 822cbc0:	180f883a 	mov	r7,r3
 822cbc4:	100d883a 	mov	r6,r2
 822cbc8:	01420974 	movhi	r5,2085
 822cbcc:	29416704 	addi	r5,r5,1436
 822cbd0:	e13fff17 	ldw	r4,-4(fp)
 822cbd4:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 822cbd8:	e0bffd17 	ldw	r2,-12(fp)
 822cbdc:	e0fffe17 	ldw	r3,-8(fp)
 822cbe0:	180f883a 	mov	r7,r3
 822cbe4:	100d883a 	mov	r6,r2
 822cbe8:	01420974 	movhi	r5,2085
 822cbec:	29417404 	addi	r5,r5,1488
 822cbf0:	e13fff17 	ldw	r4,-4(fp)
 822cbf4:	8228bac0 	call	8228bac <ns_printf>

   return 0;
 822cbf8:	0005883a 	mov	r2,zero
}
 822cbfc:	e037883a 	mov	sp,fp
 822cc00:	dfc00117 	ldw	ra,4(sp)
 822cc04:	df000017 	ldw	fp,0(sp)
 822cc08:	dec00204 	addi	sp,sp,8
 822cc0c:	f800283a 	ret

0822cc10 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 822cc10:	defffc04 	addi	sp,sp,-16
 822cc14:	dfc00315 	stw	ra,12(sp)
 822cc18:	df000215 	stw	fp,8(sp)
 822cc1c:	df000204 	addi	fp,sp,8
 822cc20:	e13fff15 	stw	r4,-4(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 822cc24:	822d4b80 	call	822d4b8 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 822cc28:	e0bfff17 	ldw	r2,-4(fp)
 822cc2c:	10800017 	ldw	r2,0(r2)
 822cc30:	e0bffe15 	stw	r2,-8(fp)
 822cc34:	e0bffe17 	ldw	r2,-8(fp)
 822cc38:	1000031e 	bne	r2,zero,822cc48 <getq+0x38>
   {
      EXIT_CRIT_SECTION(q);
 822cc3c:	822d5180 	call	822d518 <irq_Unmask>
      return (0);             /* yes, show none */
 822cc40:	0005883a 	mov	r2,zero
 822cc44:	00001b06 	br	822ccb4 <getq+0xa4>
   }

   q->q_head = temp->qe_next; /* else unlink */
 822cc48:	e0bffe17 	ldw	r2,-8(fp)
 822cc4c:	10c00017 	ldw	r3,0(r2)
 822cc50:	e0bfff17 	ldw	r2,-4(fp)
 822cc54:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 822cc58:	e0bffe17 	ldw	r2,-8(fp)
 822cc5c:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 822cc60:	e0bfff17 	ldw	r2,-4(fp)
 822cc64:	10800017 	ldw	r2,0(r2)
 822cc68:	1000021e 	bne	r2,zero,822cc74 <getq+0x64>
      q->q_tail = 0;          /* yes, update tail pointer too */
 822cc6c:	e0bfff17 	ldw	r2,-4(fp)
 822cc70:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 822cc74:	e0bfff17 	ldw	r2,-4(fp)
 822cc78:	10800217 	ldw	r2,8(r2)
 822cc7c:	10ffffc4 	addi	r3,r2,-1
 822cc80:	e0bfff17 	ldw	r2,-4(fp)
 822cc84:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 822cc88:	e0bfff17 	ldw	r2,-4(fp)
 822cc8c:	10c00217 	ldw	r3,8(r2)
 822cc90:	e0bfff17 	ldw	r2,-4(fp)
 822cc94:	10800417 	ldw	r2,16(r2)
 822cc98:	1880040e 	bge	r3,r2,822ccac <getq+0x9c>
      q->q_min = q->q_len;
 822cc9c:	e0bfff17 	ldw	r2,-4(fp)
 822cca0:	10c00217 	ldw	r3,8(r2)
 822cca4:	e0bfff17 	ldw	r2,-4(fp)
 822cca8:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 822ccac:	822d5180 	call	822d518 <irq_Unmask>

   return ((void*)temp);
 822ccb0:	e0bffe17 	ldw	r2,-8(fp)
}
 822ccb4:	e037883a 	mov	sp,fp
 822ccb8:	dfc00117 	ldw	ra,4(sp)
 822ccbc:	df000017 	ldw	fp,0(sp)
 822ccc0:	dec00204 	addi	sp,sp,8
 822ccc4:	f800283a 	ret

0822ccc8 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 822ccc8:	defffc04 	addi	sp,sp,-16
 822cccc:	dfc00315 	stw	ra,12(sp)
 822ccd0:	df000215 	stw	fp,8(sp)
 822ccd4:	df000204 	addi	fp,sp,8
 822ccd8:	e13ffe15 	stw	r4,-8(fp)
 822ccdc:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 822cce0:	822d4b80 	call	822d4b8 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 822cce4:	e0bfff17 	ldw	r2,-4(fp)
 822cce8:	10000015 	stw	zero,0(r2)
 822ccec:	e0bffe17 	ldw	r2,-8(fp)
 822ccf0:	10800017 	ldw	r2,0(r2)
 822ccf4:	1000041e 	bne	r2,zero,822cd08 <putq+0x40>
 822ccf8:	e0bffe17 	ldw	r2,-8(fp)
 822ccfc:	e0ffff17 	ldw	r3,-4(fp)
 822cd00:	10c00015 	stw	r3,0(r2)
 822cd04:	00000406 	br	822cd18 <putq+0x50>
 822cd08:	e0bffe17 	ldw	r2,-8(fp)
 822cd0c:	10800117 	ldw	r2,4(r2)
 822cd10:	e0ffff17 	ldw	r3,-4(fp)
 822cd14:	10c00015 	stw	r3,0(r2)
 822cd18:	e0bffe17 	ldw	r2,-8(fp)
 822cd1c:	e0ffff17 	ldw	r3,-4(fp)
 822cd20:	10c00115 	stw	r3,4(r2)
 822cd24:	e0bffe17 	ldw	r2,-8(fp)
 822cd28:	10800217 	ldw	r2,8(r2)
 822cd2c:	10c00044 	addi	r3,r2,1
 822cd30:	e0bffe17 	ldw	r2,-8(fp)
 822cd34:	10c00215 	stw	r3,8(r2)
 822cd38:	e0bffe17 	ldw	r2,-8(fp)
 822cd3c:	10800217 	ldw	r2,8(r2)
 822cd40:	e0fffe17 	ldw	r3,-8(fp)
 822cd44:	18c00317 	ldw	r3,12(r3)
 822cd48:	1880040e 	bge	r3,r2,822cd5c <putq+0x94>
 822cd4c:	e0bffe17 	ldw	r2,-8(fp)
 822cd50:	10c00217 	ldw	r3,8(r2)
 822cd54:	e0bffe17 	ldw	r2,-8(fp)
 822cd58:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822cd5c:	822d5180 	call	822d518 <irq_Unmask>
}
 822cd60:	0001883a 	nop
 822cd64:	e037883a 	mov	sp,fp
 822cd68:	dfc00117 	ldw	ra,4(sp)
 822cd6c:	df000017 	ldw	fp,0(sp)
 822cd70:	dec00204 	addi	sp,sp,8
 822cd74:	f800283a 	ret

0822cd78 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 822cd78:	defffa04 	addi	sp,sp,-24
 822cd7c:	dfc00515 	stw	ra,20(sp)
 822cd80:	df000415 	stw	fp,16(sp)
 822cd84:	df000404 	addi	fp,sp,16
 822cd88:	e13ffe15 	stw	r4,-8(fp)
 822cd8c:	e17fff15 	stw	r5,-4(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 822cd90:	822d4b80 	call	822d4b8 <irq_Mask>
   qptr = q->q_head;
 822cd94:	e0bffe17 	ldw	r2,-8(fp)
 822cd98:	10800017 	ldw	r2,0(r2)
 822cd9c:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 822cda0:	e03ffd15 	stw	zero,-12(fp)
   while (qptr)
 822cda4:	00002b06 	br	822ce54 <qdel+0xdc>
   {
      if (qptr == (qp)elt)
 822cda8:	e0fffc17 	ldw	r3,-16(fp)
 822cdac:	e0bfff17 	ldw	r2,-4(fp)
 822cdb0:	1880231e 	bne	r3,r2,822ce40 <qdel+0xc8>
      {
         /* found our item; dequeue it */
         if (qlast)
 822cdb4:	e0bffd17 	ldw	r2,-12(fp)
 822cdb8:	10000526 	beq	r2,zero,822cdd0 <qdel+0x58>
            qlast->qe_next = qptr->qe_next;
 822cdbc:	e0bffc17 	ldw	r2,-16(fp)
 822cdc0:	10c00017 	ldw	r3,0(r2)
 822cdc4:	e0bffd17 	ldw	r2,-12(fp)
 822cdc8:	10c00015 	stw	r3,0(r2)
 822cdcc:	00000406 	br	822cde0 <qdel+0x68>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 822cdd0:	e0bffc17 	ldw	r2,-16(fp)
 822cdd4:	10c00017 	ldw	r3,0(r2)
 822cdd8:	e0bffe17 	ldw	r2,-8(fp)
 822cddc:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 822cde0:	e0bffe17 	ldw	r2,-8(fp)
 822cde4:	10c00117 	ldw	r3,4(r2)
 822cde8:	e0bfff17 	ldw	r2,-4(fp)
 822cdec:	1880031e 	bne	r3,r2,822cdfc <qdel+0x84>
            q->q_tail = qlast;
 822cdf0:	e0bffe17 	ldw	r2,-8(fp)
 822cdf4:	e0fffd17 	ldw	r3,-12(fp)
 822cdf8:	10c00115 	stw	r3,4(r2)

         /* fix queue counters */
         q->q_len--;
 822cdfc:	e0bffe17 	ldw	r2,-8(fp)
 822ce00:	10800217 	ldw	r2,8(r2)
 822ce04:	10ffffc4 	addi	r3,r2,-1
 822ce08:	e0bffe17 	ldw	r2,-8(fp)
 822ce0c:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 822ce10:	e0bffe17 	ldw	r2,-8(fp)
 822ce14:	10c00217 	ldw	r3,8(r2)
 822ce18:	e0bffe17 	ldw	r2,-8(fp)
 822ce1c:	10800417 	ldw	r2,16(r2)
 822ce20:	1880040e 	bge	r3,r2,822ce34 <qdel+0xbc>
            q->q_min = q->q_len;
 822ce24:	e0bffe17 	ldw	r2,-8(fp)
 822ce28:	10c00217 	ldw	r3,8(r2)
 822ce2c:	e0bffe17 	ldw	r2,-8(fp)
 822ce30:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 822ce34:	822d5180 	call	822d518 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 822ce38:	e0bfff17 	ldw	r2,-4(fp)
 822ce3c:	00000906 	br	822ce64 <qdel+0xec>
      }
      qlast = qptr;
 822ce40:	e0bffc17 	ldw	r2,-16(fp)
 822ce44:	e0bffd15 	stw	r2,-12(fp)
      qptr = qptr->qe_next;
 822ce48:	e0bffc17 	ldw	r2,-16(fp)
 822ce4c:	10800017 	ldw	r2,0(r2)
 822ce50:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 822ce54:	e0bffc17 	ldw	r2,-16(fp)
 822ce58:	103fd31e 	bne	r2,zero,822cda8 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822ce5c:	822d5180 	call	822d518 <irq_Unmask>
   return NULL;   /* item not found in queue */
 822ce60:	0005883a 	mov	r2,zero
}
 822ce64:	e037883a 	mov	sp,fp
 822ce68:	dfc00117 	ldw	ra,4(sp)
 822ce6c:	df000017 	ldw	fp,0(sp)
 822ce70:	dec00204 	addi	sp,sp,8
 822ce74:	f800283a 	ret

0822ce78 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 822ce78:	defff404 	addi	sp,sp,-48
 822ce7c:	dfc00b15 	stw	ra,44(sp)
 822ce80:	df000a15 	stw	fp,40(sp)
 822ce84:	df000a04 	addi	fp,sp,40
 822ce88:	e13ffc15 	stw	r4,-16(fp)
 822ce8c:	2807883a 	mov	r3,r5
 822ce90:	3005883a 	mov	r2,r6
 822ce94:	e1ffff15 	stw	r7,-4(fp)
 822ce98:	e0fffd0d 	sth	r3,-12(fp)
 822ce9c:	e0bffe0d 	sth	r2,-8(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 822cea0:	d0a08317 	ldw	r2,-32244(gp)
 822cea4:	1080010c 	andi	r2,r2,4
 822cea8:	10001526 	beq	r2,zero,822cf00 <udp_open+0x88>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822ceac:	e0bffc17 	ldw	r2,-16(fp)
 822ceb0:	12003fcc 	andi	r8,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822ceb4:	e0bffc17 	ldw	r2,-16(fp)
 822ceb8:	1004d23a 	srli	r2,r2,8
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cebc:	11803fcc 	andi	r6,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cec0:	e0bffc17 	ldw	r2,-16(fp)
 822cec4:	1004d43a 	srli	r2,r2,16
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cec8:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cecc:	e0bffc17 	ldw	r2,-16(fp)
 822ced0:	1004d63a 	srli	r2,r2,24
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822ced4:	e0fffe0b 	ldhu	r3,-8(fp)
 822ced8:	e13ffd0b 	ldhu	r4,-12(fp)
 822cedc:	e1400217 	ldw	r5,8(fp)
 822cee0:	d9400315 	stw	r5,12(sp)
 822cee4:	d9000215 	stw	r4,8(sp)
 822cee8:	d8c00115 	stw	r3,4(sp)
 822ceec:	d8800015 	stw	r2,0(sp)
 822cef0:	400b883a 	mov	r5,r8
 822cef4:	01020974 	movhi	r4,2085
 822cef8:	21018004 	addi	r4,r4,1536
 822cefc:	82030ec0 	call	82030ec <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 822cf00:	0009883a 	mov	r4,zero
 822cf04:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   ocon = NULL;
 822cf08:	e03ffb15 	stw	zero,-20(fp)
   for (con = firstudp; con; con = con->u_next)
 822cf0c:	d0a09c17 	ldw	r2,-32144(gp)
 822cf10:	e0bffa15 	stw	r2,-24(fp)
 822cf14:	00002006 	br	822cf98 <udp_open+0x120>
   {
      ocon = con;       /* remember last con in list */
 822cf18:	e0bffa17 	ldw	r2,-24(fp)
 822cf1c:	e0bffb15 	stw	r2,-20(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822cf20:	e0bffa17 	ldw	r2,-24(fp)
 822cf24:	1080018b 	ldhu	r2,6(r2)
 822cf28:	10ffffcc 	andi	r3,r2,65535
 822cf2c:	e0bffe0b 	ldhu	r2,-8(fp)
 822cf30:	1880161e 	bne	r3,r2,822cf8c <udp_open+0x114>
 822cf34:	e0bffa17 	ldw	r2,-24(fp)
 822cf38:	1080020b 	ldhu	r2,8(r2)
 822cf3c:	10ffffcc 	andi	r3,r2,65535
 822cf40:	e0bffd0b 	ldhu	r2,-12(fp)
 822cf44:	1880111e 	bne	r3,r2,822cf8c <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822cf48:	e0bffa17 	ldw	r2,-24(fp)
 822cf4c:	10800317 	ldw	r2,12(r2)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822cf50:	10000e1e 	bne	r2,zero,822cf8c <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822cf54:	e0bffa17 	ldw	r2,-24(fp)
 822cf58:	10c00417 	ldw	r3,16(r2)
 822cf5c:	e0bffc17 	ldw	r2,-16(fp)
 822cf60:	18800a1e 	bne	r3,r2,822cf8c <udp_open+0x114>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 822cf64:	d0a08317 	ldw	r2,-32244(gp)
 822cf68:	1080050c 	andi	r2,r2,20
 822cf6c:	10000326 	beq	r2,zero,822cf7c <udp_open+0x104>
            dprintf("UDP: Connection already exists.\n");
 822cf70:	01020974 	movhi	r4,2085
 822cf74:	21018f04 	addi	r4,r4,1596
 822cf78:	82033700 	call	8203370 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 822cf7c:	0009883a 	mov	r4,zero
 822cf80:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return(NULL);
 822cf84:	0005883a 	mov	r2,zero
 822cf88:	00003506 	br	822d060 <udp_open+0x1e8>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 822cf8c:	e0bffa17 	ldw	r2,-24(fp)
 822cf90:	10800017 	ldw	r2,0(r2)
 822cf94:	e0bffa15 	stw	r2,-24(fp)
 822cf98:	e0bffa17 	ldw	r2,-24(fp)
 822cf9c:	103fde1e 	bne	r2,zero,822cf18 <udp_open+0xa0>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 822cfa0:	01000804 	movi	r4,32
 822cfa4:	822deb80 	call	822deb8 <npalloc>
 822cfa8:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 822cfac:	e0bffa17 	ldw	r2,-24(fp)
 822cfb0:	10000a1e 	bne	r2,zero,822cfdc <udp_open+0x164>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 822cfb4:	d0a08317 	ldw	r2,-32244(gp)
 822cfb8:	1080010c 	andi	r2,r2,4
 822cfbc:	10000326 	beq	r2,zero,822cfcc <udp_open+0x154>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 822cfc0:	01020974 	movhi	r4,2085
 822cfc4:	21019704 	addi	r4,r4,1628
 822cfc8:	82033700 	call	8203370 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 822cfcc:	0009883a 	mov	r4,zero
 822cfd0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return(NULL);
 822cfd4:	0005883a 	mov	r2,zero
 822cfd8:	00002106 	br	822d060 <udp_open+0x1e8>
   }

   if (ocon)   /* ocon is end of list */
 822cfdc:	e0bffb17 	ldw	r2,-20(fp)
 822cfe0:	10000426 	beq	r2,zero,822cff4 <udp_open+0x17c>
      ocon->u_next = con;  /* add new connection to end */
 822cfe4:	e0bffb17 	ldw	r2,-20(fp)
 822cfe8:	e0fffa17 	ldw	r3,-24(fp)
 822cfec:	10c00015 	stw	r3,0(r2)
 822cff0:	00000206 	br	822cffc <udp_open+0x184>
   else  /* no list, start one */
      firstudp = con;
 822cff4:	e0bffa17 	ldw	r2,-24(fp)
 822cff8:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 822cffc:	e0bffa17 	ldw	r2,-24(fp)
 822d000:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 822d004:	e0bffa17 	ldw	r2,-24(fp)
 822d008:	e0fffe0b 	ldhu	r3,-8(fp)
 822d00c:	10c0018d 	sth	r3,6(r2)
   con->u_fport = fsock;
 822d010:	e0bffa17 	ldw	r2,-24(fp)
 822d014:	e0fffd0b 	ldhu	r3,-12(fp)
 822d018:	10c0020d 	sth	r3,8(r2)
   con->u_lhost = 0;
 822d01c:	e0bffa17 	ldw	r2,-24(fp)
 822d020:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 822d024:	e0bffa17 	ldw	r2,-24(fp)
 822d028:	e0fffc17 	ldw	r3,-16(fp)
 822d02c:	10c00415 	stw	r3,16(r2)
   con->u_rcv   = handler;
 822d030:	e0bffa17 	ldw	r2,-24(fp)
 822d034:	e0ffff17 	ldw	r3,-4(fp)
 822d038:	10c00515 	stw	r3,20(r2)
   con->u_data  = data;
 822d03c:	e0bffa17 	ldw	r2,-24(fp)
 822d040:	e0c00217 	ldw	r3,8(fp)
 822d044:	10c00615 	stw	r3,24(r2)
   con->u_flags = UDPCF_V4;
 822d048:	e0bffa17 	ldw	r2,-24(fp)
 822d04c:	00c00044 	movi	r3,1
 822d050:	10c0010d 	sth	r3,4(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 822d054:	0009883a 	mov	r4,zero
 822d058:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return(con);
 822d05c:	e0bffa17 	ldw	r2,-24(fp)
}
 822d060:	e037883a 	mov	sp,fp
 822d064:	dfc00117 	ldw	ra,4(sp)
 822d068:	df000017 	ldw	fp,0(sp)
 822d06c:	dec00204 	addi	sp,sp,8
 822d070:	f800283a 	ret

0822d074 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 822d074:	defffb04 	addi	sp,sp,-20
 822d078:	dfc00415 	stw	ra,16(sp)
 822d07c:	df000315 	stw	fp,12(sp)
 822d080:	df000304 	addi	fp,sp,12
 822d084:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 822d088:	e0bfff17 	ldw	r2,-4(fp)
 822d08c:	10000226 	beq	r2,zero,822d098 <udp_close+0x24>
 822d090:	d0a09c17 	ldw	r2,-32144(gp)
 822d094:	1000021e 	bne	r2,zero,822d0a0 <udp_close+0x2c>
   {
      dtrap(); /* bad programming! */
 822d098:	822d2e00 	call	822d2e0 <dtrap>
      return;
 822d09c:	00002606 	br	822d138 <udp_close+0xc4>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 822d0a0:	0009883a 	mov	r4,zero
 822d0a4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 822d0a8:	e03ffe15 	stw	zero,-8(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d0ac:	d0a09c17 	ldw	r2,-32144(gp)
 822d0b0:	e0bffd15 	stw	r2,-12(fp)
 822d0b4:	00000806 	br	822d0d8 <udp_close+0x64>
   {
      if (pcon == con)  /* found connection to delete */
 822d0b8:	e0fffd17 	ldw	r3,-12(fp)
 822d0bc:	e0bfff17 	ldw	r2,-4(fp)
 822d0c0:	18800826 	beq	r3,r2,822d0e4 <udp_close+0x70>
      break;
      lcon = pcon;   /* remember last connection */
 822d0c4:	e0bffd17 	ldw	r2,-12(fp)
 822d0c8:	e0bffe15 	stw	r2,-8(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d0cc:	e0bffd17 	ldw	r2,-12(fp)
 822d0d0:	10800017 	ldw	r2,0(r2)
 822d0d4:	e0bffd15 	stw	r2,-12(fp)
 822d0d8:	e0bffd17 	ldw	r2,-12(fp)
 822d0dc:	103ff61e 	bne	r2,zero,822d0b8 <udp_close+0x44>
 822d0e0:	00000106 	br	822d0e8 <udp_close+0x74>
   {
      if (pcon == con)  /* found connection to delete */
      break;
 822d0e4:	0001883a 	nop
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 822d0e8:	e0bffd17 	ldw	r2,-12(fp)
 822d0ec:	1000041e 	bne	r2,zero,822d100 <udp_close+0x8c>
   {
      dtrap(); /* prog error - connenction not in list */
 822d0f0:	822d2e00 	call	822d2e0 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d0f4:	0009883a 	mov	r4,zero
 822d0f8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return;
 822d0fc:	00000e06 	br	822d138 <udp_close+0xc4>
   }

   if (lcon)   /* in con is not head of list */
 822d100:	e0bffe17 	ldw	r2,-8(fp)
 822d104:	10000526 	beq	r2,zero,822d11c <udp_close+0xa8>
      lcon->u_next = con->u_next;   /* unlink */
 822d108:	e0bfff17 	ldw	r2,-4(fp)
 822d10c:	10c00017 	ldw	r3,0(r2)
 822d110:	e0bffe17 	ldw	r2,-8(fp)
 822d114:	10c00015 	stw	r3,0(r2)
 822d118:	00000306 	br	822d128 <udp_close+0xb4>
   else
      firstudp = con->u_next; /* remove from head */
 822d11c:	e0bfff17 	ldw	r2,-4(fp)
 822d120:	10800017 	ldw	r2,0(r2)
 822d124:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 822d128:	e13fff17 	ldw	r4,-4(fp)
 822d12c:	822deec0 	call	822deec <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 822d130:	0009883a 	mov	r4,zero
 822d134:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
}
 822d138:	e037883a 	mov	sp,fp
 822d13c:	dfc00117 	ldw	ra,4(sp)
 822d140:	df000017 	ldw	fp,0(sp)
 822d144:	dec00204 	addi	sp,sp,8
 822d148:	f800283a 	ret

0822d14c <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 822d14c:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 822d150:	0140620e 	bge	zero,r5,822d2dc <done>

      mov   r6, zero		       /* carry accumulator */
 822d154:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 822d158:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 822d15c:	18000326 	beq	r3,zero,822d16c <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 822d160:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 822d164:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 822d168:	297fffc4 	addi	r5,r5,-1

0822d16c <asm1>:
 822d16c:	02c208f4 	movhi	r11,2083
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 822d170:	5af4a604 	addi	r11,r11,-11624
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 822d174:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 822d178:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 822d17c:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 822d180:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 822d184:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 822d188:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 822d18c:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 822d190:	5800683a 	jmp	r11

0822d194 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 822d194:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 822d198:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 822d19c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d1a0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d1a4:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 822d1a8:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 822d1ac:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d1b0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d1b4:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 822d1b8:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 822d1bc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d1c0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d1c4:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 822d1c8:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 822d1cc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d1d0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d1d4:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 822d1d8:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 822d1dc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d1e0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d1e4:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 822d1e8:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 822d1ec:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d1f0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d1f4:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 822d1f8:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 822d1fc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d200:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d204:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 822d208:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 822d20c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d210:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d214:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 822d218:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 822d21c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d220:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d224:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 822d228:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 822d22c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d230:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d234:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 822d238:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 822d23c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d240:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d244:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 822d248:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 822d24c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d250:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d254:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 822d258:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 822d25c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d260:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d264:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 822d268:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 822d26c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d270:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d274:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 822d278:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 822d27c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d280:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d284:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 822d288:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 822d28c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d290:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d294:	418d883a 	add	r6,r8,r6

0822d298 <loop0>:
loop0:
      subi  r5, r5, 16
 822d298:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 822d29c:	283fbd0e 	bge	r5,zero,822d194 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 822d2a0:	48000426 	beq	r9,zero,822d2b4 <fold>
      ldhu  r7, 0(r4)
 822d2a4:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 822d2a8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d2ac:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d2b0:	418d883a 	add	r6,r8,r6

0822d2b4 <fold>:
      
fold:
      srli  r7, r2, 16
 822d2b4:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d2b8:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 822d2bc:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 822d2c0:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 822d2c4:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d2c8:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 822d2cc:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 822d2d0:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d2d4:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 822d2d8:	3885883a 	add	r2,r7,r2

0822d2dc <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 822d2dc:	f800283a 	ret

0822d2e0 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 822d2e0:	defffe04 	addi	sp,sp,-8
 822d2e4:	dfc00115 	stw	ra,4(sp)
 822d2e8:	df000015 	stw	fp,0(sp)
 822d2ec:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 822d2f0:	01020974 	movhi	r4,2085
 822d2f4:	2101a104 	addi	r4,r4,1668
 822d2f8:	82033700 	call	8203370 <puts>
}
 822d2fc:	0001883a 	nop
 822d300:	e037883a 	mov	sp,fp
 822d304:	dfc00117 	ldw	ra,4(sp)
 822d308:	df000017 	ldw	fp,0(sp)
 822d30c:	dec00204 	addi	sp,sp,8
 822d310:	f800283a 	ret

0822d314 <kbhit>:

int
kbhit()
{
 822d314:	defffd04 	addi	sp,sp,-12
 822d318:	dfc00215 	stw	ra,8(sp)
 822d31c:	df000115 	stw	fp,4(sp)
 822d320:	df000104 	addi	fp,sp,4
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 822d324:	d0a0a017 	ldw	r2,-32128(gp)
 822d328:	10000b1e 	bne	r2,zero,822d358 <kbhit+0x44>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 822d32c:	01900004 	movi	r6,16384
 822d330:	01400104 	movi	r5,4
 822d334:	0009883a 	mov	r4,zero
 822d338:	823d60c0 	call	823d60c <fcntl>
 822d33c:	10000426 	beq	r2,zero,822d350 <kbhit+0x3c>
      {
         printf("F_SETFL failed.\n");
 822d340:	01020974 	movhi	r4,2085
 822d344:	2101a804 	addi	r4,r4,1696
 822d348:	82033700 	call	8203370 <puts>
         dtrap();
 822d34c:	822d2e00 	call	822d2e0 <dtrap>
      }
      kbd_init = 1; 
 822d350:	00800044 	movi	r2,1
 822d354:	d0a0a015 	stw	r2,-32128(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 822d358:	d0a03a17 	ldw	r2,-32536(gp)
 822d35c:	10bfffd8 	cmpnei	r2,r2,-1
 822d360:	10000b1e 	bne	r2,zero,822d390 <kbhit+0x7c>
   {
      kb = getchar();
 822d364:	d0a00217 	ldw	r2,-32760(gp)
 822d368:	10800117 	ldw	r2,4(r2)
 822d36c:	1009883a 	mov	r4,r2
 822d370:	8202bd40 	call	8202bd4 <getc>
 822d374:	e0bfff15 	stw	r2,-4(fp)
      if (kb < 0)       /* any error means no character present */
 822d378:	e0bfff17 	ldw	r2,-4(fp)
 822d37c:	1000020e 	bge	r2,zero,822d388 <kbhit+0x74>
         return (FALSE);
 822d380:	0005883a 	mov	r2,zero
 822d384:	00000306 	br	822d394 <kbhit+0x80>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 822d388:	e0bfff17 	ldw	r2,-4(fp)
 822d38c:	d0a03a15 	stw	r2,-32536(gp)
   }

   return (TRUE);
 822d390:	00800044 	movi	r2,1
}
 822d394:	e037883a 	mov	sp,fp
 822d398:	dfc00117 	ldw	ra,4(sp)
 822d39c:	df000017 	ldw	fp,0(sp)
 822d3a0:	dec00204 	addi	sp,sp,8
 822d3a4:	f800283a 	ret

0822d3a8 <getch>:

int 
getch()
{
 822d3a8:	defffd04 	addi	sp,sp,-12
 822d3ac:	dfc00215 	stw	ra,8(sp)
 822d3b0:	df000115 	stw	fp,4(sp)
 822d3b4:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 822d3b8:	d0a03a17 	ldw	r2,-32536(gp)
 822d3bc:	10bfffe0 	cmpeqi	r2,r2,-1
 822d3c0:	1000051e 	bne	r2,zero,822d3d8 <getch+0x30>
   {
      chr = kb_last;
 822d3c4:	d0a03a17 	ldw	r2,-32536(gp)
 822d3c8:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 822d3cc:	00bfffc4 	movi	r2,-1
 822d3d0:	d0a03a15 	stw	r2,-32536(gp)
 822d3d4:	00000506 	br	822d3ec <getch+0x44>
   }
   else
      chr = getchar();
 822d3d8:	d0a00217 	ldw	r2,-32760(gp)
 822d3dc:	10800117 	ldw	r2,4(r2)
 822d3e0:	1009883a 	mov	r4,r2
 822d3e4:	8202bd40 	call	8202bd4 <getc>
 822d3e8:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 822d3ec:	e0bfff17 	ldw	r2,-4(fp)
}
 822d3f0:	e037883a 	mov	sp,fp
 822d3f4:	dfc00117 	ldw	ra,4(sp)
 822d3f8:	df000017 	ldw	fp,0(sp)
 822d3fc:	dec00204 	addi	sp,sp,8
 822d400:	f800283a 	ret

0822d404 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 822d404:	deffff04 	addi	sp,sp,-4
 822d408:	df000015 	stw	fp,0(sp)
 822d40c:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 822d410:	00801904 	movi	r2,100
 822d414:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 822d418:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 822d41c:	d020a815 	stw	zero,-32096(gp)
   cticks_initialized = 1;
 822d420:	00800044 	movi	r2,1
 822d424:	d0a09d15 	stw	r2,-32140(gp)
}
 822d428:	0001883a 	nop
 822d42c:	e037883a 	mov	sp,fp
 822d430:	df000017 	ldw	fp,0(sp)
 822d434:	dec00104 	addi	sp,sp,4
 822d438:	f800283a 	ret

0822d43c <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 822d43c:	deffff04 	addi	sp,sp,-4
 822d440:	df000015 	stw	fp,0(sp)
 822d444:	d839883a 	mov	fp,sp
   /* null */ ;
}
 822d448:	0001883a 	nop
 822d44c:	e037883a 	mov	sp,fp
 822d450:	df000017 	ldw	fp,0(sp)
 822d454:	dec00104 	addi	sp,sp,4
 822d458:	f800283a 	ret

0822d45c <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 822d45c:	deffff04 	addi	sp,sp,-4
 822d460:	df000015 	stw	fp,0(sp)
 822d464:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 822d468:	d0a09d17 	ldw	r2,-32140(gp)
 822d46c:	10000d26 	beq	r2,zero,822d4a4 <cticks_hook+0x48>
   {
      cticks_factor += TPS;
 822d470:	d0a0a117 	ldw	r2,-32124(gp)
 822d474:	10801904 	addi	r2,r2,100
 822d478:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 822d47c:	d0e0a117 	ldw	r3,-32124(gp)
 822d480:	d0a0a217 	ldw	r2,-32120(gp)
 822d484:	18800716 	blt	r3,r2,822d4a4 <cticks_hook+0x48>
      {
         cticks++;
 822d488:	d0a0a817 	ldw	r2,-32096(gp)
 822d48c:	10800044 	addi	r2,r2,1
 822d490:	d0a0a815 	stw	r2,-32096(gp)
         cticks_factor -= OS_TPS;
 822d494:	d0e0a117 	ldw	r3,-32124(gp)
 822d498:	d0a0a217 	ldw	r2,-32120(gp)
 822d49c:	1885c83a 	sub	r2,r3,r2
 822d4a0:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 822d4a4:	0001883a 	nop
 822d4a8:	e037883a 	mov	sp,fp
 822d4ac:	df000017 	ldw	fp,0(sp)
 822d4b0:	dec00104 	addi	sp,sp,4
 822d4b4:	f800283a 	ret

0822d4b8 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 822d4b8:	defffd04 	addi	sp,sp,-12
 822d4bc:	df000215 	stw	fp,8(sp)
 822d4c0:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 822d4c4:	0005303a 	rdctl	r2,status
 822d4c8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 822d4cc:	e0ffff17 	ldw	r3,-4(fp)
 822d4d0:	00bfff84 	movi	r2,-2
 822d4d4:	1884703a 	and	r2,r3,r2
 822d4d8:	1001703a 	wrctl	status,r2
  
  return context;
 822d4dc:	e0bfff17 	ldw	r2,-4(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 822d4e0:	e0bffe15 	stw	r2,-8(fp)
	
   if (++irq_level == 1)
 822d4e4:	d0a09e17 	ldw	r2,-32136(gp)
 822d4e8:	10800044 	addi	r2,r2,1
 822d4ec:	d0a09e15 	stw	r2,-32136(gp)
 822d4f0:	d0a09e17 	ldw	r2,-32136(gp)
 822d4f4:	10800058 	cmpnei	r2,r2,1
 822d4f8:	1000021e 	bne	r2,zero,822d504 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 822d4fc:	e0bffe17 	ldw	r2,-8(fp)
 822d500:	d0a09f15 	stw	r2,-32132(gp)
   }
}
 822d504:	0001883a 	nop
 822d508:	e037883a 	mov	sp,fp
 822d50c:	df000017 	ldw	fp,0(sp)
 822d510:	dec00104 	addi	sp,sp,4
 822d514:	f800283a 	ret

0822d518 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 822d518:	defffe04 	addi	sp,sp,-8
 822d51c:	df000115 	stw	fp,4(sp)
 822d520:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 822d524:	d0a09e17 	ldw	r2,-32136(gp)
 822d528:	10bfffc4 	addi	r2,r2,-1
 822d52c:	d0a09e15 	stw	r2,-32136(gp)
 822d530:	d0a09e17 	ldw	r2,-32136(gp)
 822d534:	1000041e 	bne	r2,zero,822d548 <irq_Unmask+0x30>
   {
      alt_irq_enable_all(cpu_statusreg);
 822d538:	d0a09f17 	ldw	r2,-32132(gp)
 822d53c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 822d540:	e0bfff17 	ldw	r2,-4(fp)
 822d544:	1001703a 	wrctl	status,r2
   }
}
 822d548:	0001883a 	nop
 822d54c:	e037883a 	mov	sp,fp
 822d550:	df000017 	ldw	fp,0(sp)
 822d554:	dec00104 	addi	sp,sp,4
 822d558:	f800283a 	ret

0822d55c <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 822d55c:	defffb04 	addi	sp,sp,-20
 822d560:	dfc00415 	stw	ra,16(sp)
 822d564:	df000315 	stw	fp,12(sp)
 822d568:	df000304 	addi	fp,sp,12
 822d56c:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d570:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d574:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d578:	e0bfff17 	ldw	r2,-4(fp)
 822d57c:	10002216 	blt	r2,zero,822d608 <LOCK_NET_RESOURCE+0xac>
 822d580:	e0bfff17 	ldw	r2,-4(fp)
 822d584:	10800408 	cmpgei	r2,r2,16
 822d588:	10001f1e 	bne	r2,zero,822d608 <LOCK_NET_RESOURCE+0xac>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 822d58c:	008209b4 	movhi	r2,2086
 822d590:	10b86104 	addi	r2,r2,-7804
 822d594:	e0ffff17 	ldw	r3,-4(fp)
 822d598:	18c7883a 	add	r3,r3,r3
 822d59c:	18c7883a 	add	r3,r3,r3
 822d5a0:	10c5883a 	add	r2,r2,r3
 822d5a4:	10800017 	ldw	r2,0(r2)
 822d5a8:	e0fffe04 	addi	r3,fp,-8
 822d5ac:	180d883a 	mov	r6,r3
 822d5b0:	000b883a 	mov	r5,zero
 822d5b4:	1009883a 	mov	r4,r2
 822d5b8:	8219e200 	call	8219e20 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d5bc:	e0bffe03 	ldbu	r2,-8(fp)
 822d5c0:	10803fcc 	andi	r2,r2,255
 822d5c4:	10800298 	cmpnei	r2,r2,10
 822d5c8:	10000a1e 	bne	r2,zero,822d5f4 <LOCK_NET_RESOURCE+0x98>
 822d5cc:	e0bffd17 	ldw	r2,-12(fp)
 822d5d0:	10800044 	addi	r2,r2,1
 822d5d4:	e0bffd15 	stw	r2,-12(fp)
 822d5d8:	e0bffd17 	ldw	r2,-12(fp)
 822d5dc:	1080fa50 	cmplti	r2,r2,1001
 822d5e0:	1000041e 	bne	r2,zero,822d5f4 <LOCK_NET_RESOURCE+0x98>
         {
            panic("lock NET");   /* fatal */
 822d5e4:	01020974 	movhi	r4,2085
 822d5e8:	2101ac04 	addi	r4,r4,1712
 822d5ec:	82289940 	call	8228994 <panic>
 822d5f0:	00000606 	br	822d60c <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
 822d5f4:	e0bffe03 	ldbu	r2,-8(fp)
 822d5f8:	10803fcc 	andi	r2,r2,255
 822d5fc:	108002a0 	cmpeqi	r2,r2,10
 822d600:	103fe21e 	bne	r2,zero,822d58c <LOCK_NET_RESOURCE+0x30>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d604:	00000106 	br	822d60c <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 822d608:	822d2e00 	call	822d2e0 <dtrap>
}
 822d60c:	e037883a 	mov	sp,fp
 822d610:	dfc00117 	ldw	ra,4(sp)
 822d614:	df000017 	ldw	fp,0(sp)
 822d618:	dec00204 	addi	sp,sp,8
 822d61c:	f800283a 	ret

0822d620 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 822d620:	defffc04 	addi	sp,sp,-16
 822d624:	dfc00315 	stw	ra,12(sp)
 822d628:	df000215 	stw	fp,8(sp)
 822d62c:	df000204 	addi	fp,sp,8
 822d630:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d634:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d638:	e0bfff17 	ldw	r2,-4(fp)
 822d63c:	10001316 	blt	r2,zero,822d68c <UNLOCK_NET_RESOURCE+0x6c>
 822d640:	e0bfff17 	ldw	r2,-4(fp)
 822d644:	10800408 	cmpgei	r2,r2,16
 822d648:	1000101e 	bne	r2,zero,822d68c <UNLOCK_NET_RESOURCE+0x6c>
   {
      error = OSSemPost(resid_semaphore[resid]);
 822d64c:	008209b4 	movhi	r2,2086
 822d650:	10b86104 	addi	r2,r2,-7804
 822d654:	e0ffff17 	ldw	r3,-4(fp)
 822d658:	18c7883a 	add	r3,r3,r3
 822d65c:	18c7883a 	add	r3,r3,r3
 822d660:	10c5883a 	add	r2,r2,r3
 822d664:	10800017 	ldw	r2,0(r2)
 822d668:	1009883a 	mov	r4,r2
 822d66c:	821a1980 	call	821a198 <OSSemPost>
 822d670:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d674:	e0bffe03 	ldbu	r2,-8(fp)
 822d678:	10000526 	beq	r2,zero,822d690 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
 822d67c:	01020974 	movhi	r4,2085
 822d680:	2101af04 	addi	r4,r4,1724
 822d684:	82289940 	call	8228994 <panic>
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
   {
      error = OSSemPost(resid_semaphore[resid]);
      if (error != OS_NO_ERR)
 822d688:	00000106 	br	822d690 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822d68c:	822d2e00 	call	822d2e0 <dtrap>
}
 822d690:	0001883a 	nop
 822d694:	e037883a 	mov	sp,fp
 822d698:	dfc00117 	ldw	ra,4(sp)
 822d69c:	df000017 	ldw	fp,0(sp)
 822d6a0:	dec00204 	addi	sp,sp,8
 822d6a4:	f800283a 	ret

0822d6a8 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 822d6a8:	deffee04 	addi	sp,sp,-72
 822d6ac:	dfc01115 	stw	ra,68(sp)
 822d6b0:	df001015 	stw	fp,64(sp)
 822d6b4:	df001004 	addi	fp,sp,64
 822d6b8:	e13fff15 	stw	r4,-4(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 822d6bc:	e0bfff17 	ldw	r2,-4(fp)
 822d6c0:	10800417 	ldw	r2,16(r2)
 822d6c4:	1009883a 	mov	r4,r2
 822d6c8:	822deb80 	call	822deb8 <npalloc>
 822d6cc:	e0bff515 	stw	r2,-44(fp)
   if(!stack)
 822d6d0:	e0bff517 	ldw	r2,-44(fp)
 822d6d4:	1000031e 	bne	r2,zero,822d6e4 <TK_NEWTASK+0x3c>
      panic("stack alloc");
 822d6d8:	01020974 	movhi	r4,2085
 822d6dc:	2101b204 	addi	r4,r4,1736
 822d6e0:	82289940 	call	8228994 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d6e4:	e0bfff17 	ldw	r2,-4(fp)
 822d6e8:	12000217 	ldw	r8,8(r2)
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
 822d6ec:	e0bfff17 	ldw	r2,-4(fp)
 822d6f0:	10800417 	ldw	r2,16(r2)
 822d6f4:	1006d0ba 	srli	r3,r2,2
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d6f8:	00900034 	movhi	r2,16384
 822d6fc:	10bfffc4 	addi	r2,r2,-1
 822d700:	1885883a 	add	r2,r3,r2
 822d704:	1085883a 	add	r2,r2,r2
 822d708:	1085883a 	add	r2,r2,r2
 822d70c:	1007883a 	mov	r3,r2
 822d710:	e0bff517 	ldw	r2,-44(fp)
 822d714:	10cb883a 	add	r5,r2,r3
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
 822d718:	e0bfff17 	ldw	r2,-4(fp)
 822d71c:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d720:	11803fcc 	andi	r6,r2,255
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
 822d724:	e0bfff17 	ldw	r2,-4(fp)
 822d728:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d72c:	10bfffcc 	andi	r2,r2,65535
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
      stack, 
      (INT32U)nettask->stacksize / sizeof(OS_STK),
 822d730:	e0ffff17 	ldw	r3,-4(fp)
 822d734:	18c00417 	ldw	r3,16(r3)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d738:	1806d0ba 	srli	r3,r3,2
 822d73c:	010000c4 	movi	r4,3
 822d740:	d9000415 	stw	r4,16(sp)
 822d744:	d8000315 	stw	zero,12(sp)
 822d748:	d8c00215 	stw	r3,8(sp)
 822d74c:	e0fff517 	ldw	r3,-44(fp)
 822d750:	d8c00115 	stw	r3,4(sp)
 822d754:	d8800015 	stw	r2,0(sp)
 822d758:	300f883a 	mov	r7,r6
 822d75c:	280d883a 	mov	r6,r5
 822d760:	000b883a 	mov	r5,zero
 822d764:	4009883a 	mov	r4,r8
 822d768:	821ab540 	call	821ab54 <OSTaskCreateExt>
 822d76c:	e0bff605 	stb	r2,-40(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 822d770:	e0bff603 	ldbu	r2,-40(fp)
 822d774:	10803fcc 	andi	r2,r2,255
 822d778:	10800a18 	cmpnei	r2,r2,40
 822d77c:	10001c1e 	bne	r2,zero,822d7f0 <TK_NEWTASK+0x148>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, (INT8U*)curr_task, &err);
 822d780:	e0bfff17 	ldw	r2,-4(fp)
 822d784:	10800317 	ldw	r2,12(r2)
 822d788:	10803fcc 	andi	r2,r2,255
 822d78c:	e13ff644 	addi	r4,fp,-39
 822d790:	e0fff684 	addi	r3,fp,-38
 822d794:	200d883a 	mov	r6,r4
 822d798:	180b883a 	mov	r5,r3
 822d79c:	1009883a 	mov	r4,r2
 822d7a0:	821b1cc0 	call	821b1cc <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 822d7a4:	e03ffe45 	stb	zero,-7(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 822d7a8:	e0bfff17 	ldw	r2,-4(fp)
 822d7ac:	10c00117 	ldw	r3,4(r2)
 822d7b0:	e0bfff17 	ldw	r2,-4(fp)
 822d7b4:	11000317 	ldw	r4,12(r2)
 822d7b8:	e0bfff17 	ldw	r2,-4(fp)
 822d7bc:	10800317 	ldw	r2,12(r2)
 822d7c0:	e17ff684 	addi	r5,fp,-38
 822d7c4:	d8800015 	stw	r2,0(sp)
 822d7c8:	280f883a 	mov	r7,r5
 822d7cc:	200d883a 	mov	r6,r4
 822d7d0:	180b883a 	mov	r5,r3
 822d7d4:	01020974 	movhi	r4,2085
 822d7d8:	2101b504 	addi	r4,r4,1748
 822d7dc:	82030ec0 	call	82030ec <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 822d7e0:	01020974 	movhi	r4,2085
 822d7e4:	2101cd04 	addi	r4,r4,1844
 822d7e8:	82033700 	call	8203370 <puts>
 822d7ec:	00002006 	br	822d870 <TK_NEWTASK+0x1c8>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 822d7f0:	e0bff603 	ldbu	r2,-40(fp)
 822d7f4:	10803fcc 	andi	r2,r2,255
 822d7f8:	10800a98 	cmpnei	r2,r2,42
 822d7fc:	10000e1e 	bne	r2,zero,822d838 <TK_NEWTASK+0x190>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 822d800:	e0bfff17 	ldw	r2,-4(fp)
 822d804:	10c00117 	ldw	r3,4(r2)
 822d808:	e0bfff17 	ldw	r2,-4(fp)
 822d80c:	10800317 	ldw	r2,12(r2)
 822d810:	01c00504 	movi	r7,20
 822d814:	100d883a 	mov	r6,r2
 822d818:	180b883a 	mov	r5,r3
 822d81c:	01020974 	movhi	r4,2085
 822d820:	2101f504 	addi	r4,r4,2004
 822d824:	82030ec0 	call	82030ec <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 822d828:	01020974 	movhi	r4,2085
 822d82c:	21021204 	addi	r4,r4,2120
 822d830:	82033700 	call	8203370 <puts>
 822d834:	00000e06 	br	822d870 <TK_NEWTASK+0x1c8>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 822d838:	e0bff603 	ldbu	r2,-40(fp)
 822d83c:	10803fcc 	andi	r2,r2,255
 822d840:	10000b26 	beq	r2,zero,822d870 <TK_NEWTASK+0x1c8>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 822d844:	e0bff603 	ldbu	r2,-40(fp)
 822d848:	10c03fcc 	andi	r3,r2,255
 822d84c:	e0bfff17 	ldw	r2,-4(fp)
 822d850:	10800117 	ldw	r2,4(r2)
 822d854:	100d883a 	mov	r6,r2
 822d858:	180b883a 	mov	r5,r3
 822d85c:	01020974 	movhi	r4,2085
 822d860:	21023104 	addi	r4,r4,2244
 822d864:	82030ec0 	call	82030ec <printf>
             error, nettask->name);
      return (-1);
 822d868:	00bfffc4 	movi	r2,-1
 822d86c:	00001c06 	br	822d8e0 <TK_NEWTASK+0x238>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, (INT8U*)&nettask->name[0], &error);
 822d870:	e0bfff17 	ldw	r2,-4(fp)
 822d874:	10800317 	ldw	r2,12(r2)
 822d878:	10c03fcc 	andi	r3,r2,255
 822d87c:	e0bfff17 	ldw	r2,-4(fp)
 822d880:	10800117 	ldw	r2,4(r2)
 822d884:	e13ff604 	addi	r4,fp,-40
 822d888:	200d883a 	mov	r6,r4
 822d88c:	100b883a 	mov	r5,r2
 822d890:	1809883a 	mov	r4,r3
 822d894:	821b3640 	call	821b364 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 822d898:	e0bfff17 	ldw	r2,-4(fp)
 822d89c:	e0fff517 	ldw	r3,-44(fp)
 822d8a0:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 822d8a4:	e0bfff17 	ldw	r2,-4(fp)
 822d8a8:	10800017 	ldw	r2,0(r2)
 822d8ac:	e0ffff17 	ldw	r3,-4(fp)
 822d8b0:	18c00317 	ldw	r3,12(r3)
 822d8b4:	10c00005 	stb	r3,0(r2)

   printf("Created \"%s\" task (Prio: %d)\n",
 822d8b8:	e0bfff17 	ldw	r2,-4(fp)
 822d8bc:	10c00117 	ldw	r3,4(r2)
 822d8c0:	e0bfff17 	ldw	r2,-4(fp)
 822d8c4:	10800317 	ldw	r2,12(r2)
 822d8c8:	100d883a 	mov	r6,r2
 822d8cc:	180b883a 	mov	r5,r3
 822d8d0:	01020974 	movhi	r4,2085
 822d8d4:	21023f04 	addi	r4,r4,2300
 822d8d8:	82030ec0 	call	82030ec <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 822d8dc:	0005883a 	mov	r2,zero
}
 822d8e0:	e037883a 	mov	sp,fp
 822d8e4:	dfc00117 	ldw	ra,4(sp)
 822d8e8:	df000017 	ldw	fp,0(sp)
 822d8ec:	dec00204 	addi	sp,sp,8
 822d8f0:	f800283a 	ret

0822d8f4 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 822d8f4:	defffb04 	addi	sp,sp,-20
 822d8f8:	dfc00415 	stw	ra,16(sp)
 822d8fc:	df000315 	stw	fp,12(sp)
 822d900:	df000304 	addi	fp,sp,12
 822d904:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d908:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d90c:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822d910:	e0bfff17 	ldw	r2,-4(fp)
 822d914:	108001a8 	cmpgeui	r2,r2,6
 822d918:	10001f1e 	bne	r2,zero,822d998 <wait_app_sem+0xa4>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 822d91c:	008209b4 	movhi	r2,2086
 822d920:	10b87104 	addi	r2,r2,-7740
 822d924:	e0ffff17 	ldw	r3,-4(fp)
 822d928:	18c7883a 	add	r3,r3,r3
 822d92c:	18c7883a 	add	r3,r3,r3
 822d930:	10c5883a 	add	r2,r2,r3
 822d934:	10800017 	ldw	r2,0(r2)
 822d938:	e0fffe04 	addi	r3,fp,-8
 822d93c:	180d883a 	mov	r6,r3
 822d940:	000b883a 	mov	r5,zero
 822d944:	1009883a 	mov	r4,r2
 822d948:	8219e200 	call	8219e20 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d94c:	e0bffe03 	ldbu	r2,-8(fp)
 822d950:	10803fcc 	andi	r2,r2,255
 822d954:	10800298 	cmpnei	r2,r2,10
 822d958:	10000a1e 	bne	r2,zero,822d984 <wait_app_sem+0x90>
 822d95c:	e0bffd17 	ldw	r2,-12(fp)
 822d960:	10800044 	addi	r2,r2,1
 822d964:	e0bffd15 	stw	r2,-12(fp)
 822d968:	e0bffd17 	ldw	r2,-12(fp)
 822d96c:	1080fa50 	cmplti	r2,r2,1001
 822d970:	1000041e 	bne	r2,zero,822d984 <wait_app_sem+0x90>
         {
            panic("lock NET");   /* fatal */
 822d974:	01020974 	movhi	r4,2085
 822d978:	2101ac04 	addi	r4,r4,1712
 822d97c:	82289940 	call	8228994 <panic>
 822d980:	00000606 	br	822d99c <wait_app_sem+0xa8>
            return;
         }
      } while (error == 10);
 822d984:	e0bffe03 	ldbu	r2,-8(fp)
 822d988:	10803fcc 	andi	r2,r2,255
 822d98c:	108002a0 	cmpeqi	r2,r2,10
 822d990:	103fe21e 	bne	r2,zero,822d91c <wait_app_sem+0x28>
 822d994:	00000106 	br	822d99c <wait_app_sem+0xa8>
   }
   else
      dtrap();
 822d998:	822d2e00 	call	822d2e0 <dtrap>
}
 822d99c:	e037883a 	mov	sp,fp
 822d9a0:	dfc00117 	ldw	ra,4(sp)
 822d9a4:	df000017 	ldw	fp,0(sp)
 822d9a8:	dec00204 	addi	sp,sp,8
 822d9ac:	f800283a 	ret

0822d9b0 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 822d9b0:	defffc04 	addi	sp,sp,-16
 822d9b4:	dfc00315 	stw	ra,12(sp)
 822d9b8:	df000215 	stw	fp,8(sp)
 822d9bc:	df000204 	addi	fp,sp,8
 822d9c0:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822d9c4:	e0bfff17 	ldw	r2,-4(fp)
 822d9c8:	108001a8 	cmpgeui	r2,r2,6
 822d9cc:	1000101e 	bne	r2,zero,822da10 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 822d9d0:	008209b4 	movhi	r2,2086
 822d9d4:	10b87104 	addi	r2,r2,-7740
 822d9d8:	e0ffff17 	ldw	r3,-4(fp)
 822d9dc:	18c7883a 	add	r3,r3,r3
 822d9e0:	18c7883a 	add	r3,r3,r3
 822d9e4:	10c5883a 	add	r2,r2,r3
 822d9e8:	10800017 	ldw	r2,0(r2)
 822d9ec:	1009883a 	mov	r4,r2
 822d9f0:	821a1980 	call	821a198 <OSSemPost>
 822d9f4:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d9f8:	e0bffe03 	ldbu	r2,-8(fp)
 822d9fc:	10000526 	beq	r2,zero,822da14 <post_app_sem+0x64>
      {
         panic("unlock NET");
 822da00:	01020974 	movhi	r4,2085
 822da04:	2101af04 	addi	r4,r4,1724
 822da08:	82289940 	call	8228994 <panic>
      }
   }
   else
      dtrap();
}
 822da0c:	00000106 	br	822da14 <post_app_sem+0x64>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822da10:	822d2e00 	call	822d2e0 <dtrap>
}
 822da14:	0001883a 	nop
 822da18:	e037883a 	mov	sp,fp
 822da1c:	dfc00117 	ldw	ra,4(sp)
 822da20:	df000017 	ldw	fp,0(sp)
 822da24:	dec00204 	addi	sp,sp,8
 822da28:	f800283a 	ret

0822da2c <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 822da2c:	defffd04 	addi	sp,sp,-12
 822da30:	dfc00215 	stw	ra,8(sp)
 822da34:	df000115 	stw	fp,4(sp)
 822da38:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 822da3c:	01000044 	movi	r4,1
 822da40:	8219b080 	call	8219b08 <OSSemCreate>
 822da44:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 822da48:	d0a0aa17 	ldw	r2,-32088(gp)
 822da4c:	1000031e 	bne	r2,zero,822da5c <alt_iniche_init+0x30>
      panic("mheap_sem_ptr create err"); 
 822da50:	01020974 	movhi	r4,2085
 822da54:	21024704 	addi	r4,r4,2332
 822da58:	82289940 	call	8228994 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 822da5c:	0009883a 	mov	r4,zero
 822da60:	8219b080 	call	8219b08 <OSSemCreate>
 822da64:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 822da68:	d0a0ab17 	ldw	r2,-32084(gp)
 822da6c:	1000031e 	bne	r2,zero,822da7c <alt_iniche_init+0x50>
      panic("rcvdq_sem_ptr create err"); 
 822da70:	01020974 	movhi	r4,2085
 822da74:	21024e04 	addi	r4,r4,2360
 822da78:	82289940 	call	8228994 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822da7c:	e03fff15 	stw	zero,-4(fp)
 822da80:	00001806 	br	822dae4 <alt_iniche_init+0xb8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 822da84:	01000044 	movi	r4,1
 822da88:	8219b080 	call	8219b08 <OSSemCreate>
 822da8c:	1009883a 	mov	r4,r2
 822da90:	008209b4 	movhi	r2,2086
 822da94:	10b86104 	addi	r2,r2,-7804
 822da98:	e0ffff17 	ldw	r3,-4(fp)
 822da9c:	18c7883a 	add	r3,r3,r3
 822daa0:	18c7883a 	add	r3,r3,r3
 822daa4:	10c5883a 	add	r2,r2,r3
 822daa8:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 822daac:	008209b4 	movhi	r2,2086
 822dab0:	10b86104 	addi	r2,r2,-7804
 822dab4:	e0ffff17 	ldw	r3,-4(fp)
 822dab8:	18c7883a 	add	r3,r3,r3
 822dabc:	18c7883a 	add	r3,r3,r3
 822dac0:	10c5883a 	add	r2,r2,r3
 822dac4:	10800017 	ldw	r2,0(r2)
 822dac8:	1000031e 	bne	r2,zero,822dad8 <alt_iniche_init+0xac>
         panic("resid_semaphore create err");  
 822dacc:	01020974 	movhi	r4,2085
 822dad0:	21025504 	addi	r4,r4,2388
 822dad4:	82289940 	call	8228994 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dad8:	e0bfff17 	ldw	r2,-4(fp)
 822dadc:	10800044 	addi	r2,r2,1
 822dae0:	e0bfff15 	stw	r2,-4(fp)
 822dae4:	e0bfff17 	ldw	r2,-4(fp)
 822dae8:	10800410 	cmplti	r2,r2,16
 822daec:	103fe51e 	bne	r2,zero,822da84 <alt_iniche_init+0x58>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822daf0:	e03fff15 	stw	zero,-4(fp)
 822daf4:	00001806 	br	822db58 <alt_iniche_init+0x12c>
   {
      app_semaphore[i] = OSSemCreate(1);
 822daf8:	01000044 	movi	r4,1
 822dafc:	8219b080 	call	8219b08 <OSSemCreate>
 822db00:	1009883a 	mov	r4,r2
 822db04:	008209b4 	movhi	r2,2086
 822db08:	10b87104 	addi	r2,r2,-7740
 822db0c:	e0ffff17 	ldw	r3,-4(fp)
 822db10:	18c7883a 	add	r3,r3,r3
 822db14:	18c7883a 	add	r3,r3,r3
 822db18:	10c5883a 	add	r2,r2,r3
 822db1c:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 822db20:	008209b4 	movhi	r2,2086
 822db24:	10b87104 	addi	r2,r2,-7740
 822db28:	e0ffff17 	ldw	r3,-4(fp)
 822db2c:	18c7883a 	add	r3,r3,r3
 822db30:	18c7883a 	add	r3,r3,r3
 822db34:	10c5883a 	add	r2,r2,r3
 822db38:	10800017 	ldw	r2,0(r2)
 822db3c:	1000031e 	bne	r2,zero,822db4c <alt_iniche_init+0x120>
         panic("app_semaphore create err");  
 822db40:	01020974 	movhi	r4,2085
 822db44:	21025c04 	addi	r4,r4,2416
 822db48:	82289940 	call	8228994 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822db4c:	e0bfff17 	ldw	r2,-4(fp)
 822db50:	10800044 	addi	r2,r2,1
 822db54:	e0bfff15 	stw	r2,-4(fp)
 822db58:	e0bfff17 	ldw	r2,-4(fp)
 822db5c:	10800190 	cmplti	r2,r2,6
 822db60:	103fe51e 	bne	r2,zero,822daf8 <alt_iniche_init+0xcc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822db64:	e03fff15 	stw	zero,-4(fp)
 822db68:	00002506 	br	822dc00 <alt_iniche_init+0x1d4>
   {
      global_TCPwakeup_set[i].ctick = 0;
 822db6c:	008209b4 	movhi	r2,2086
 822db70:	10b82504 	addi	r2,r2,-8044
 822db74:	e0ffff17 	ldw	r3,-4(fp)
 822db78:	18c00324 	muli	r3,r3,12
 822db7c:	10c5883a 	add	r2,r2,r3
 822db80:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 822db84:	008209b4 	movhi	r2,2086
 822db88:	10b82504 	addi	r2,r2,-8044
 822db8c:	e0ffff17 	ldw	r3,-4(fp)
 822db90:	18c00324 	muli	r3,r3,12
 822db94:	10c5883a 	add	r2,r2,r3
 822db98:	10800104 	addi	r2,r2,4
 822db9c:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 822dba0:	0009883a 	mov	r4,zero
 822dba4:	8219b080 	call	8219b08 <OSSemCreate>
 822dba8:	1009883a 	mov	r4,r2
 822dbac:	008209b4 	movhi	r2,2086
 822dbb0:	10b82504 	addi	r2,r2,-8044
 822dbb4:	e0ffff17 	ldw	r3,-4(fp)
 822dbb8:	18c00324 	muli	r3,r3,12
 822dbbc:	10c5883a 	add	r2,r2,r3
 822dbc0:	10800204 	addi	r2,r2,8
 822dbc4:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 822dbc8:	008209b4 	movhi	r2,2086
 822dbcc:	10b82504 	addi	r2,r2,-8044
 822dbd0:	e0ffff17 	ldw	r3,-4(fp)
 822dbd4:	18c00324 	muli	r3,r3,12
 822dbd8:	10c5883a 	add	r2,r2,r3
 822dbdc:	10800204 	addi	r2,r2,8
 822dbe0:	10800017 	ldw	r2,0(r2)
 822dbe4:	1000031e 	bne	r2,zero,822dbf4 <alt_iniche_init+0x1c8>
         panic("globwake_semaphore create err");  
 822dbe8:	01020974 	movhi	r4,2085
 822dbec:	21026304 	addi	r4,r4,2444
 822dbf0:	82289940 	call	8228994 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822dbf4:	e0bfff17 	ldw	r2,-4(fp)
 822dbf8:	10800044 	addi	r2,r2,1
 822dbfc:	e0bfff15 	stw	r2,-4(fp)
 822dc00:	e0bfff17 	ldw	r2,-4(fp)
 822dc04:	10800510 	cmplti	r2,r2,20
 822dc08:	103fd81e 	bne	r2,zero,822db6c <alt_iniche_init+0x140>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 822dc0c:	d020a715 	stw	zero,-32100(gp)
#endif  /* TCPWAKE_RTOS */
}
 822dc10:	0001883a 	nop
 822dc14:	e037883a 	mov	sp,fp
 822dc18:	dfc00117 	ldw	ra,4(sp)
 822dc1c:	df000017 	ldw	fp,0(sp)
 822dc20:	dec00204 	addi	sp,sp,8
 822dc24:	f800283a 	ret

0822dc28 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 822dc28:	deffff04 	addi	sp,sp,-4
 822dc2c:	df000015 	stw	fp,0(sp)
 822dc30:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 822dc34:	00800784 	movi	r2,30
 822dc38:	d0a03815 	stw	r2,-32544(gp)
   lilbufs = MAXLILPKTS;
 822dc3c:	00800784 	movi	r2,30
 822dc40:	d0a03615 	stw	r2,-32552(gp)
   bigbufsiz = BIGBUFSIZE;
 822dc44:	00818004 	movi	r2,1536
 822dc48:	d0a03915 	stw	r2,-32540(gp)
   lilbufsiz = LILBUFSIZE;
 822dc4c:	00802004 	movi	r2,128
 822dc50:	d0a03715 	stw	r2,-32548(gp)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 822dc54:	008208f4 	movhi	r2,2083
 822dc58:	10b72504 	addi	r2,r2,-9068
 822dc5c:	d0a0ca15 	stw	r2,-31960(gp)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 822dc60:	0005883a 	mov	r2,zero
}
 822dc64:	e037883a 	mov	sp,fp
 822dc68:	df000017 	ldw	fp,0(sp)
 822dc6c:	dec00104 	addi	sp,sp,4
 822dc70:	f800283a 	ret

0822dc74 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 822dc74:	deffff04 	addi	sp,sp,-4
 822dc78:	df000015 	stw	fp,0(sp)
 822dc7c:	d839883a 	mov	fp,sp
   return NULL;
 822dc80:	0005883a 	mov	r2,zero
}
 822dc84:	e037883a 	mov	sp,fp
 822dc88:	df000017 	ldw	fp,0(sp)
 822dc8c:	dec00104 	addi	sp,sp,4
 822dc90:	f800283a 	ret

0822dc94 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 822dc94:	defffd04 	addi	sp,sp,-12
 822dc98:	dfc00215 	stw	ra,8(sp)
 822dc9c:	df000115 	stw	fp,4(sp)
 822dca0:	df000104 	addi	fp,sp,4
 822dca4:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 822dca8:	e13fff17 	ldw	r4,-4(fp)
 822dcac:	82255cc0 	call	82255cc <iniche_devices_init>
 822dcb0:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 822dcb4:	e0bfff17 	ldw	r2,-4(fp)
}
 822dcb8:	e037883a 	mov	sp,fp
 822dcbc:	dfc00117 	ldw	ra,4(sp)
 822dcc0:	df000017 	ldw	fp,0(sp)
 822dcc4:	dec00204 	addi	sp,sp,8
 822dcc8:	f800283a 	ret

0822dccc <npalloc_base>:
#endif


char *
npalloc_base(unsigned size, int cacheable)
{
 822dccc:	defff804 	addi	sp,sp,-32
 822dcd0:	dfc00715 	stw	ra,28(sp)
 822dcd4:	df000615 	stw	fp,24(sp)
 822dcd8:	df000604 	addi	fp,sp,24
 822dcdc:	e13ffe15 	stw	r4,-8(fp)
 822dce0:	e17fff15 	stw	r5,-4(fp)
char * ptr;
void *(*alloc_rtn)(size_t size) = cacheable ? malloc : alt_uncached_malloc;
 822dce4:	e0bfff17 	ldw	r2,-4(fp)
 822dce8:	10000326 	beq	r2,zero,822dcf8 <npalloc_base+0x2c>
 822dcec:	00820974 	movhi	r2,2085
 822dcf0:	10acf704 	addi	r2,r2,-19492
 822dcf4:	00000206 	br	822dd00 <npalloc_base+0x34>
 822dcf8:	00820934 	movhi	r2,2084
 822dcfc:	10b1c604 	addi	r2,r2,-14568
 822dd00:	e0bffb15 	stw	r2,-20(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 822dd04:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd08:	e0fffd04 	addi	r3,fp,-12
 822dd0c:	180d883a 	mov	r6,r3
 822dd10:	000b883a 	mov	r5,zero
 822dd14:	1009883a 	mov	r4,r2
 822dd18:	8219e200 	call	8219e20 <OSSemPend>
   if(err)
 822dd1c:	e0bffd03 	ldbu	r2,-12(fp)
 822dd20:	10803fcc 	andi	r2,r2,255
 822dd24:	10001626 	beq	r2,zero,822dd80 <npalloc_base+0xb4>
   {
      int errct = 0;
 822dd28:	e03ffa15 	stw	zero,-24(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822dd2c:	00001006 	br	822dd70 <npalloc_base+0xa4>
      {
         if(errct++ > 1000)
 822dd30:	e0bffa17 	ldw	r2,-24(fp)
 822dd34:	10c00044 	addi	r3,r2,1
 822dd38:	e0fffa15 	stw	r3,-24(fp)
 822dd3c:	1080fa50 	cmplti	r2,r2,1001
 822dd40:	1000051e 	bne	r2,zero,822dd58 <npalloc_base+0x8c>
         {
            panic("npalloc");    /* fatal? */
 822dd44:	01020974 	movhi	r4,2085
 822dd48:	21026b04 	addi	r4,r4,2476
 822dd4c:	82289940 	call	8228994 <panic>
            return NULL;
 822dd50:	0005883a 	mov	r2,zero
 822dd54:	00001b06 	br	822ddc4 <npalloc_base+0xf8>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822dd58:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd5c:	e0fffd04 	addi	r3,fp,-12
 822dd60:	180d883a 	mov	r6,r3
 822dd64:	000b883a 	mov	r5,zero
 822dd68:	1009883a 	mov	r4,r2
 822dd6c:	8219e200 	call	8219e20 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822dd70:	e0bffd03 	ldbu	r2,-12(fp)
 822dd74:	10803fcc 	andi	r2,r2,255
 822dd78:	108002a0 	cmpeqi	r2,r2,10
 822dd7c:	103fec1e 	bne	r2,zero,822dd30 <npalloc_base+0x64>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, alloc_rtn);
#else
   ptr = (*alloc_rtn)(size);
 822dd80:	e0bffb17 	ldw	r2,-20(fp)
 822dd84:	e13ffe17 	ldw	r4,-8(fp)
 822dd88:	103ee83a 	callr	r2
 822dd8c:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 822dd90:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd94:	1009883a 	mov	r4,r2
 822dd98:	821a1980 	call	821a198 <OSSemPost>
 822dd9c:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 822dda0:	e0bffc17 	ldw	r2,-16(fp)
 822dda4:	1000021e 	bne	r2,zero,822ddb0 <npalloc_base+0xe4>
      return NULL;
 822dda8:	0005883a 	mov	r2,zero
 822ddac:	00000506 	br	822ddc4 <npalloc_base+0xf8>

   MEMSET(ptr, 0, size);
 822ddb0:	e1bffe17 	ldw	r6,-8(fp)
 822ddb4:	000b883a 	mov	r5,zero
 822ddb8:	e13ffc17 	ldw	r4,-16(fp)
 822ddbc:	8202f000 	call	8202f00 <memset>
   return ptr;      
 822ddc0:	e0bffc17 	ldw	r2,-16(fp)
}
 822ddc4:	e037883a 	mov	sp,fp
 822ddc8:	dfc00117 	ldw	ra,4(sp)
 822ddcc:	df000017 	ldw	fp,0(sp)
 822ddd0:	dec00204 	addi	sp,sp,8
 822ddd4:	f800283a 	ret

0822ddd8 <npfree_base>:

void
npfree_base(void *ptr, int cacheable)
{
 822ddd8:	defff904 	addi	sp,sp,-28
 822dddc:	dfc00615 	stw	ra,24(sp)
 822dde0:	df000515 	stw	fp,20(sp)
 822dde4:	df000504 	addi	fp,sp,20
 822dde8:	e13ffe15 	stw	r4,-8(fp)
 822ddec:	e17fff15 	stw	r5,-4(fp)
   void (*free_rtn)(void *ptr) = cacheable ? free : alt_uncached_free;
 822ddf0:	e0bfff17 	ldw	r2,-4(fp)
 822ddf4:	10000326 	beq	r2,zero,822de04 <npfree_base+0x2c>
 822ddf8:	00820974 	movhi	r2,2085
 822ddfc:	10acfc04 	addi	r2,r2,-19472
 822de00:	00000206 	br	822de0c <npfree_base+0x34>
 822de04:	00820934 	movhi	r2,2084
 822de08:	10b1b504 	addi	r2,r2,-14636
 822de0c:	e0bffc15 	stw	r2,-16(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 822de10:	d0a0aa17 	ldw	r2,-32088(gp)
 822de14:	e0fffd04 	addi	r3,fp,-12
 822de18:	180d883a 	mov	r6,r3
 822de1c:	000b883a 	mov	r5,zero
 822de20:	1009883a 	mov	r4,r2
 822de24:	8219e200 	call	8219e20 <OSSemPend>
   if (err)
 822de28:	e0bffd03 	ldbu	r2,-12(fp)
 822de2c:	10803fcc 	andi	r2,r2,255
 822de30:	10001526 	beq	r2,zero,822de88 <npfree_base+0xb0>
   {
      int errct = 0;
 822de34:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822de38:	00000f06 	br	822de78 <npfree_base+0xa0>
      {
         if (errct++ > 1000)
 822de3c:	e0bffb17 	ldw	r2,-20(fp)
 822de40:	10c00044 	addi	r3,r2,1
 822de44:	e0fffb15 	stw	r3,-20(fp)
 822de48:	1080fa50 	cmplti	r2,r2,1001
 822de4c:	1000041e 	bne	r2,zero,822de60 <npfree_base+0x88>
         {
            panic("npfree");    /* fatal? */
 822de50:	01020974 	movhi	r4,2085
 822de54:	21026d04 	addi	r4,r4,2484
 822de58:	82289940 	call	8228994 <panic>
            return;
 822de5c:	00001106 	br	822dea4 <npfree_base+0xcc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822de60:	d0a0aa17 	ldw	r2,-32088(gp)
 822de64:	e0fffd04 	addi	r3,fp,-12
 822de68:	180d883a 	mov	r6,r3
 822de6c:	000b883a 	mov	r5,zero
 822de70:	1009883a 	mov	r4,r2
 822de74:	8219e200 	call	8219e20 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822de78:	e0bffd03 	ldbu	r2,-12(fp)
 822de7c:	10803fcc 	andi	r2,r2,255
 822de80:	108002a0 	cmpeqi	r2,r2,10
 822de84:	103fed1e 	bne	r2,zero,822de3c <npfree_base+0x64>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free_rtn);
#else
   (*free_rtn)(ptr);
 822de88:	e0bffc17 	ldw	r2,-16(fp)
 822de8c:	e13ffe17 	ldw	r4,-8(fp)
 822de90:	103ee83a 	callr	r2
#endif

   err = OSSemPost(mheap_sem_ptr);
 822de94:	d0a0aa17 	ldw	r2,-32088(gp)
 822de98:	1009883a 	mov	r4,r2
 822de9c:	821a1980 	call	821a198 <OSSemPost>
 822dea0:	e0bffd05 	stb	r2,-12(fp)
#else
   (*free_rtn)(ptr);
#endif
#endif

}
 822dea4:	e037883a 	mov	sp,fp
 822dea8:	dfc00117 	ldw	ra,4(sp)
 822deac:	df000017 	ldw	fp,0(sp)
 822deb0:	dec00204 	addi	sp,sp,8
 822deb4:	f800283a 	ret

0822deb8 <npalloc>:

char *
npalloc(unsigned size)
{
 822deb8:	defffd04 	addi	sp,sp,-12
 822debc:	dfc00215 	stw	ra,8(sp)
 822dec0:	df000115 	stw	fp,4(sp)
 822dec4:	df000104 	addi	fp,sp,4
 822dec8:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 1);
 822decc:	01400044 	movi	r5,1
 822ded0:	e13fff17 	ldw	r4,-4(fp)
 822ded4:	822dccc0 	call	822dccc <npalloc_base>
}
 822ded8:	e037883a 	mov	sp,fp
 822dedc:	dfc00117 	ldw	ra,4(sp)
 822dee0:	df000017 	ldw	fp,0(sp)
 822dee4:	dec00204 	addi	sp,sp,8
 822dee8:	f800283a 	ret

0822deec <npfree>:

void
npfree(void *ptr)
{
 822deec:	defffd04 	addi	sp,sp,-12
 822def0:	dfc00215 	stw	ra,8(sp)
 822def4:	df000115 	stw	fp,4(sp)
 822def8:	df000104 	addi	fp,sp,4
 822defc:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822df00:	e0bfff17 	ldw	r2,-4(fp)
 822df04:	10000326 	beq	r2,zero,822df14 <npfree+0x28>
      npfree_base(ptr, 1);
 822df08:	01400044 	movi	r5,1
 822df0c:	e13fff17 	ldw	r4,-4(fp)
 822df10:	822ddd80 	call	822ddd8 <npfree_base>
   }
}
 822df14:	0001883a 	nop
 822df18:	e037883a 	mov	sp,fp
 822df1c:	dfc00117 	ldw	ra,4(sp)
 822df20:	df000017 	ldw	fp,0(sp)
 822df24:	dec00204 	addi	sp,sp,8
 822df28:	f800283a 	ret

0822df2c <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 822df2c:	defffd04 	addi	sp,sp,-12
 822df30:	dfc00215 	stw	ra,8(sp)
 822df34:	df000115 	stw	fp,4(sp)
 822df38:	df000104 	addi	fp,sp,4
 822df3c:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 0);
 822df40:	000b883a 	mov	r5,zero
 822df44:	e13fff17 	ldw	r4,-4(fp)
 822df48:	822dccc0 	call	822dccc <npalloc_base>
}
 822df4c:	e037883a 	mov	sp,fp
 822df50:	dfc00117 	ldw	ra,4(sp)
 822df54:	df000017 	ldw	fp,0(sp)
 822df58:	dec00204 	addi	sp,sp,8
 822df5c:	f800283a 	ret

0822df60 <ncpfree>:

void ncpfree(void *ptr)
{
 822df60:	defffd04 	addi	sp,sp,-12
 822df64:	dfc00215 	stw	ra,8(sp)
 822df68:	df000115 	stw	fp,4(sp)
 822df6c:	df000104 	addi	fp,sp,4
 822df70:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822df74:	e0bfff17 	ldw	r2,-4(fp)
 822df78:	10000326 	beq	r2,zero,822df88 <ncpfree+0x28>
      npfree_base(ptr, 0);
 822df7c:	000b883a 	mov	r5,zero
 822df80:	e13fff17 	ldw	r4,-4(fp)
 822df84:	822ddd80 	call	822ddd8 <npfree_base>
   }
}
 822df88:	0001883a 	nop
 822df8c:	e037883a 	mov	sp,fp
 822df90:	dfc00117 	ldw	ra,4(sp)
 822df94:	df000017 	ldw	fp,0(sp)
 822df98:	dec00204 	addi	sp,sp,8
 822df9c:	f800283a 	ret

0822dfa0 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 822dfa0:	defffc04 	addi	sp,sp,-16
 822dfa4:	dfc00315 	stw	ra,12(sp)
 822dfa8:	df000215 	stw	fp,8(sp)
 822dfac:	df000204 	addi	fp,sp,8
 822dfb0:	e13ffe15 	stw	r4,-8(fp)
 822dfb4:	e17fff15 	stw	r5,-4(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 822dfb8:	e0bffe17 	ldw	r2,-8(fp)
 822dfbc:	108000a0 	cmpeqi	r2,r2,2
 822dfc0:	1000031e 	bne	r2,zero,822dfd0 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 822dfc4:	822d2e00 	call	822d2e0 <dtrap>
         return NULL;
 822dfc8:	0005883a 	mov	r2,zero
 822dfcc:	00001306 	br	822e01c <pffindtype+0x7c>
      }
   }

   if (type == SOCK_STREAM)
 822dfd0:	e0bfff17 	ldw	r2,-4(fp)
 822dfd4:	10800058 	cmpnei	r2,r2,1
 822dfd8:	1000031e 	bne	r2,zero,822dfe8 <pffindtype+0x48>
      return &tcp_protosw;
 822dfdc:	00820974 	movhi	r2,2085
 822dfe0:	108dd004 	addi	r2,r2,14144
 822dfe4:	00000d06 	br	822e01c <pffindtype+0x7c>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 822dfe8:	e0bfff17 	ldw	r2,-4(fp)
 822dfec:	10800098 	cmpnei	r2,r2,2
 822dff0:	1000031e 	bne	r2,zero,822e000 <pffindtype+0x60>
      return &udp_protosw;
 822dff4:	00820974 	movhi	r2,2085
 822dff8:	108dd604 	addi	r2,r2,14168
 822dffc:	00000706 	br	822e01c <pffindtype+0x7c>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 822e000:	e0bfff17 	ldw	r2,-4(fp)
 822e004:	108000d8 	cmpnei	r2,r2,3
 822e008:	1000031e 	bne	r2,zero,822e018 <pffindtype+0x78>
      return &rawip_protosw;
 822e00c:	00820974 	movhi	r2,2085
 822e010:	108ddc04 	addi	r2,r2,14192
 822e014:	00000106 	br	822e01c <pffindtype+0x7c>
#endif  /* IP_RAW */
   else
      return NULL;
 822e018:	0005883a 	mov	r2,zero
}
 822e01c:	e037883a 	mov	sp,fp
 822e020:	dfc00117 	ldw	ra,4(sp)
 822e024:	df000017 	ldw	fp,0(sp)
 822e028:	dec00204 	addi	sp,sp,8
 822e02c:	f800283a 	ret

0822e030 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 822e030:	defffb04 	addi	sp,sp,-20
 822e034:	dfc00415 	stw	ra,16(sp)
 822e038:	df000315 	stw	fp,12(sp)
 822e03c:	df000304 	addi	fp,sp,12
 822e040:	e13ffd15 	stw	r4,-12(fp)
 822e044:	e17ffe15 	stw	r5,-8(fp)
 822e048:	e1bfff15 	stw	r6,-4(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 822e04c:	e0bfff17 	ldw	r2,-4(fp)
 822e050:	108000d8 	cmpnei	r2,r2,3
 822e054:	1000041e 	bne	r2,zero,822e068 <pffindproto+0x38>
      return(pffindtype(domain, type));
 822e058:	e17fff17 	ldw	r5,-4(fp)
 822e05c:	e13ffd17 	ldw	r4,-12(fp)
 822e060:	822dfa00 	call	822dfa0 <pffindtype>
 822e064:	00001e06 	br	822e0e0 <pffindproto+0xb0>
#endif

   switch (protocol)
 822e068:	e0bffe17 	ldw	r2,-8(fp)
 822e06c:	10c001a0 	cmpeqi	r3,r2,6
 822e070:	1800041e 	bne	r3,zero,822e084 <pffindproto+0x54>
 822e074:	10c00460 	cmpeqi	r3,r2,17
 822e078:	1800081e 	bne	r3,zero,822e09c <pffindproto+0x6c>
 822e07c:	10001026 	beq	r2,zero,822e0c0 <pffindproto+0x90>
 822e080:	00000c06 	br	822e0b4 <pffindproto+0x84>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 822e084:	e0bfff17 	ldw	r2,-4(fp)
 822e088:	10800058 	cmpnei	r2,r2,1
 822e08c:	10000e26 	beq	r2,zero,822e0c8 <pffindproto+0x98>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 822e090:	822d2e00 	call	822d2e0 <dtrap>
      return NULL;
 822e094:	0005883a 	mov	r2,zero
 822e098:	00001106 	br	822e0e0 <pffindproto+0xb0>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 822e09c:	e0bfff17 	ldw	r2,-4(fp)
 822e0a0:	10800098 	cmpnei	r2,r2,2
 822e0a4:	10000a26 	beq	r2,zero,822e0d0 <pffindproto+0xa0>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 822e0a8:	822d2e00 	call	822d2e0 <dtrap>
      return NULL;
 822e0ac:	0005883a 	mov	r2,zero
 822e0b0:	00000b06 	br	822e0e0 <pffindproto+0xb0>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 822e0b4:	822d2e00 	call	822d2e0 <dtrap>
      return NULL;
 822e0b8:	0005883a 	mov	r2,zero
 822e0bc:	00000806 	br	822e0e0 <pffindproto+0xb0>
      dtrap();
      return NULL;
#endif /* BSD_SOCKETS */
   case 0:
      /* let protocol default based on socket type */
      break;
 822e0c0:	0001883a 	nop
 822e0c4:	00000306 	br	822e0d4 <pffindproto+0xa4>
   switch (protocol)
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
         break;
 822e0c8:	0001883a 	nop
 822e0cc:	00000106 	br	822e0d4 <pffindproto+0xa4>
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
      return NULL;
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
         break;
 822e0d0:	0001883a 	nop
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
      return NULL;
   }
   return(pffindtype(domain, type));   /* map to findtype */
 822e0d4:	e17fff17 	ldw	r5,-4(fp)
 822e0d8:	e13ffd17 	ldw	r4,-12(fp)
 822e0dc:	822dfa00 	call	822dfa0 <pffindtype>
}
 822e0e0:	e037883a 	mov	sp,fp
 822e0e4:	dfc00117 	ldw	ra,4(sp)
 822e0e8:	df000017 	ldw	fp,0(sp)
 822e0ec:	dec00204 	addi	sp,sp,8
 822e0f0:	f800283a 	ret

0822e0f4 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 822e0f4:	defffa04 	addi	sp,sp,-24
 822e0f8:	dfc00515 	stw	ra,20(sp)
 822e0fc:	df000415 	stw	fp,16(sp)
 822e100:	df000404 	addi	fp,sp,16
 822e104:	e13ffe15 	stw	r4,-8(fp)
 822e108:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 822e10c:	e03ffc15 	stw	zero,-16(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 822e110:	e0bffe17 	ldw	r2,-8(fp)
 822e114:	0080030e 	bge	zero,r2,822e124 <m_getnbuf+0x30>
 822e118:	e0bffe17 	ldw	r2,-8(fp)
 822e11c:	10800390 	cmplti	r2,r2,14
 822e120:	1000011e 	bne	r2,zero,822e128 <m_getnbuf+0x34>
   {
      dtrap(); /* is this OK? */
 822e124:	822d2e00 	call	822d2e0 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 822e128:	e0bfff17 	ldw	r2,-4(fp)
 822e12c:	10000d26 	beq	r2,zero,822e164 <m_getnbuf+0x70>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e130:	01000084 	movi	r4,2
 822e134:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 822e138:	e0bfff17 	ldw	r2,-4(fp)
 822e13c:	10800e04 	addi	r2,r2,56
 822e140:	1009883a 	mov	r4,r2
 822e144:	822c7380 	call	822c738 <pk_alloc>
 822e148:	e0bffc15 	stw	r2,-16(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e14c:	01000084 	movi	r4,2
 822e150:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 822e154:	e0bffc17 	ldw	r2,-16(fp)
 822e158:	1000021e 	bne	r2,zero,822e164 <m_getnbuf+0x70>
         return NULL;
 822e15c:	0005883a 	mov	r2,zero
 822e160:	00004106 	br	822e268 <m_getnbuf+0x174>
   }

   m = (struct mbuf *)getq(&mfreeq);
 822e164:	010209b4 	movhi	r4,2086
 822e168:	21389004 	addi	r4,r4,-7616
 822e16c:	822cc100 	call	822cc10 <getq>
 822e170:	e0bffd15 	stw	r2,-12(fp)
   if (!m)
 822e174:	e0bffd17 	ldw	r2,-12(fp)
 822e178:	10000a1e 	bne	r2,zero,822e1a4 <m_getnbuf+0xb0>
   {
      if (pkt) 
 822e17c:	e0bffc17 	ldw	r2,-16(fp)
 822e180:	10000626 	beq	r2,zero,822e19c <m_getnbuf+0xa8>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822e184:	01000084 	movi	r4,2
 822e188:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822e18c:	e13ffc17 	ldw	r4,-16(fp)
 822e190:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e194:	01000084 	movi	r4,2
 822e198:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 822e19c:	0005883a 	mov	r2,zero
 822e1a0:	00003106 	br	822e268 <m_getnbuf+0x174>
   }
   m->m_type = type;
 822e1a4:	e0bffd17 	ldw	r2,-12(fp)
 822e1a8:	e0fffe17 	ldw	r3,-8(fp)
 822e1ac:	10c00815 	stw	r3,32(r2)
   if (len == 0)
 822e1b0:	e0bfff17 	ldw	r2,-4(fp)
 822e1b4:	1000071e 	bne	r2,zero,822e1d4 <m_getnbuf+0xe0>
   {
      m->pkt = NULL;
 822e1b8:	e0bffd17 	ldw	r2,-12(fp)
 822e1bc:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 822e1c0:	e0bffd17 	ldw	r2,-12(fp)
 822e1c4:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 822e1c8:	e0bffd17 	ldw	r2,-12(fp)
 822e1cc:	10000515 	stw	zero,20(r2)
 822e1d0:	00001506 	br	822e228 <m_getnbuf+0x134>
   }
   else
   {
      m->pkt = pkt;
 822e1d4:	e0bffd17 	ldw	r2,-12(fp)
 822e1d8:	e0fffc17 	ldw	r3,-16(fp)
 822e1dc:	10c00115 	stw	r3,4(r2)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 822e1e0:	e0bffc17 	ldw	r2,-16(fp)
 822e1e4:	10800117 	ldw	r2,4(r2)
 822e1e8:	10c00e04 	addi	r3,r2,56
 822e1ec:	e0bffc17 	ldw	r2,-16(fp)
 822e1f0:	10c00315 	stw	r3,12(r2)
 822e1f4:	e0bffc17 	ldw	r2,-16(fp)
 822e1f8:	10c00317 	ldw	r3,12(r2)
 822e1fc:	e0bffd17 	ldw	r2,-12(fp)
 822e200:	10c00315 	stw	r3,12(r2)
 822e204:	e0bffd17 	ldw	r2,-12(fp)
 822e208:	10c00317 	ldw	r3,12(r2)
 822e20c:	e0bffd17 	ldw	r2,-12(fp)
 822e210:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 822e214:	e0bffc17 	ldw	r2,-16(fp)
 822e218:	10800217 	ldw	r2,8(r2)
 822e21c:	10fff204 	addi	r3,r2,-56
 822e220:	e0bffd17 	ldw	r2,-12(fp)
 822e224:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 822e228:	e0bffd17 	ldw	r2,-12(fp)
 822e22c:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 822e230:	e0bffd17 	ldw	r2,-12(fp)
 822e234:	10000715 	stw	zero,28(r2)
 822e238:	e0bffd17 	ldw	r2,-12(fp)
 822e23c:	10c00717 	ldw	r3,28(r2)
 822e240:	e0bffd17 	ldw	r2,-12(fp)
 822e244:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 822e248:	d0a0ae17 	ldw	r2,-32072(gp)
 822e24c:	10800044 	addi	r2,r2,1
 822e250:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 822e254:	e17ffd17 	ldw	r5,-12(fp)
 822e258:	010209b4 	movhi	r4,2086
 822e25c:	21388b04 	addi	r4,r4,-7636
 822e260:	822ccc80 	call	822ccc8 <putq>
   return m;
 822e264:	e0bffd17 	ldw	r2,-12(fp)
}
 822e268:	e037883a 	mov	sp,fp
 822e26c:	dfc00117 	ldw	ra,4(sp)
 822e270:	df000017 	ldw	fp,0(sp)
 822e274:	dec00204 	addi	sp,sp,8
 822e278:	f800283a 	ret

0822e27c <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 822e27c:	defffc04 	addi	sp,sp,-16
 822e280:	dfc00315 	stw	ra,12(sp)
 822e284:	df000215 	stw	fp,8(sp)
 822e288:	df000204 	addi	fp,sp,8
 822e28c:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 822e290:	008209b4 	movhi	r2,2086
 822e294:	10b88b04 	addi	r2,r2,-7636
 822e298:	10800217 	ldw	r2,8(r2)
 822e29c:	00800316 	blt	zero,r2,822e2ac <m_free+0x30>
      panic("mfree: q_len");
 822e2a0:	01020974 	movhi	r4,2085
 822e2a4:	21026f04 	addi	r4,r4,2492
 822e2a8:	82289940 	call	8228994 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 822e2ac:	e0bfff17 	ldw	r2,-4(fp)
 822e2b0:	10800817 	ldw	r2,32(r2)
 822e2b4:	0080040e 	bge	zero,r2,822e2c8 <m_free+0x4c>
 822e2b8:	e0bfff17 	ldw	r2,-4(fp)
 822e2bc:	10800817 	ldw	r2,32(r2)
 822e2c0:	10800390 	cmplti	r2,r2,14
 822e2c4:	10000a1e 	bne	r2,zero,822e2f0 <m_free+0x74>
   {
      if (m->m_type == MT_FREE)
 822e2c8:	e0bfff17 	ldw	r2,-4(fp)
 822e2cc:	10800817 	ldw	r2,32(r2)
 822e2d0:	1000041e 	bne	r2,zero,822e2e4 <m_free+0x68>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 822e2d4:	822d2e00 	call	822d2e0 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 822e2d8:	e0bfff17 	ldw	r2,-4(fp)
 822e2dc:	10800617 	ldw	r2,24(r2)
 822e2e0:	00002306 	br	822e370 <m_free+0xf4>
      }
      else
         panic("m_free: type");
 822e2e4:	01020974 	movhi	r4,2085
 822e2e8:	21027304 	addi	r4,r4,2508
 822e2ec:	82289940 	call	8228994 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 822e2f0:	e0bfff17 	ldw	r2,-4(fp)
 822e2f4:	10800617 	ldw	r2,24(r2)
 822e2f8:	e0bffe15 	stw	r2,-8(fp)

   if (qdel(&mbufq, m) == NULL)
 822e2fc:	e17fff17 	ldw	r5,-4(fp)
 822e300:	010209b4 	movhi	r4,2086
 822e304:	21388b04 	addi	r4,r4,-7636
 822e308:	822cd780 	call	822cd78 <qdel>
 822e30c:	1000031e 	bne	r2,zero,822e31c <m_free+0xa0>
      panic("m_free: missing");
 822e310:	01020974 	movhi	r4,2085
 822e314:	21027704 	addi	r4,r4,2524
 822e318:	82289940 	call	8228994 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 822e31c:	e0bfff17 	ldw	r2,-4(fp)
 822e320:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 822e324:	e0bfff17 	ldw	r2,-4(fp)
 822e328:	10800117 	ldw	r2,4(r2)
 822e32c:	10000826 	beq	r2,zero,822e350 <m_free+0xd4>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e330:	01000084 	movi	r4,2
 822e334:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 822e338:	e0bfff17 	ldw	r2,-4(fp)
 822e33c:	10800117 	ldw	r2,4(r2)
 822e340:	1009883a 	mov	r4,r2
 822e344:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e348:	01000084 	movi	r4,2
 822e34c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 822e350:	d0a0af17 	ldw	r2,-32068(gp)
 822e354:	10800044 	addi	r2,r2,1
 822e358:	d0a0af15 	stw	r2,-32068(gp)
   putq(&mfreeq, (qp)m);
 822e35c:	e17fff17 	ldw	r5,-4(fp)
 822e360:	010209b4 	movhi	r4,2086
 822e364:	21389004 	addi	r4,r4,-7616
 822e368:	822ccc80 	call	822ccc8 <putq>
   return nextptr;
 822e36c:	e0bffe17 	ldw	r2,-8(fp)
}
 822e370:	e037883a 	mov	sp,fp
 822e374:	dfc00117 	ldw	ra,4(sp)
 822e378:	df000017 	ldw	fp,0(sp)
 822e37c:	dec00204 	addi	sp,sp,8
 822e380:	f800283a 	ret

0822e384 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 822e384:	defffd04 	addi	sp,sp,-12
 822e388:	dfc00215 	stw	ra,8(sp)
 822e38c:	df000115 	stw	fp,4(sp)
 822e390:	df000104 	addi	fp,sp,4
 822e394:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 822e398:	00000306 	br	822e3a8 <m_freem+0x24>
      m = m_free(m);
 822e39c:	e13fff17 	ldw	r4,-4(fp)
 822e3a0:	822e27c0 	call	822e27c <m_free>
 822e3a4:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 822e3a8:	e0bfff17 	ldw	r2,-4(fp)
 822e3ac:	103ffb1e 	bne	r2,zero,822e39c <m_freem+0x18>
      m = m_free(m);
}
 822e3b0:	0001883a 	nop
 822e3b4:	e037883a 	mov	sp,fp
 822e3b8:	dfc00117 	ldw	ra,4(sp)
 822e3bc:	df000017 	ldw	fp,0(sp)
 822e3c0:	dec00204 	addi	sp,sp,8
 822e3c4:	f800283a 	ret

0822e3c8 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 822e3c8:	defff704 	addi	sp,sp,-36
 822e3cc:	dfc00815 	stw	ra,32(sp)
 822e3d0:	df000715 	stw	fp,28(sp)
 822e3d4:	df000704 	addi	fp,sp,28
 822e3d8:	e13ffd15 	stw	r4,-12(fp)
 822e3dc:	e17ffe15 	stw	r5,-8(fp)
 822e3e0:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 822e3e4:	e0bfff17 	ldw	r2,-4(fp)
 822e3e8:	1000021e 	bne	r2,zero,822e3f4 <m_copy+0x2c>
      return NULL;
 822e3ec:	0005883a 	mov	r2,zero
 822e3f0:	0000ad06 	br	822e6a8 <m_copy+0x2e0>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 822e3f4:	e0bffe17 	ldw	r2,-8(fp)
 822e3f8:	10000516 	blt	r2,zero,822e410 <m_copy+0x48>
 822e3fc:	e0bfff17 	ldw	r2,-4(fp)
 822e400:	1000180e 	bge	r2,zero,822e464 <m_copy+0x9c>
 822e404:	e0bfff17 	ldw	r2,-4(fp)
 822e408:	10bfffe0 	cmpeqi	r2,r2,-1
 822e40c:	1000151e 	bne	r2,zero,822e464 <m_copy+0x9c>
   {
      dtrap();
 822e410:	822d2e00 	call	822d2e0 <dtrap>
      return NULL;
 822e414:	0005883a 	mov	r2,zero
 822e418:	0000a306 	br	822e6a8 <m_copy+0x2e0>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 822e41c:	e0bffd17 	ldw	r2,-12(fp)
 822e420:	1000031e 	bne	r2,zero,822e430 <m_copy+0x68>
      {
         dtrap();
 822e424:	822d2e00 	call	822d2e0 <dtrap>
         return NULL;
 822e428:	0005883a 	mov	r2,zero
 822e42c:	00009e06 	br	822e6a8 <m_copy+0x2e0>
      }
      if (off < (int)m->m_len)
 822e430:	e0bffd17 	ldw	r2,-12(fp)
 822e434:	10800217 	ldw	r2,8(r2)
 822e438:	1007883a 	mov	r3,r2
 822e43c:	e0bffe17 	ldw	r2,-8(fp)
 822e440:	10c00b16 	blt	r2,r3,822e470 <m_copy+0xa8>
         break;
      off -= m->m_len;
 822e444:	e0fffe17 	ldw	r3,-8(fp)
 822e448:	e0bffd17 	ldw	r2,-12(fp)
 822e44c:	10800217 	ldw	r2,8(r2)
 822e450:	1885c83a 	sub	r2,r3,r2
 822e454:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e458:	e0bffd17 	ldw	r2,-12(fp)
 822e45c:	10800617 	ldw	r2,24(r2)
 822e460:	e0bffd15 	stw	r2,-12(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 822e464:	e0bffe17 	ldw	r2,-8(fp)
 822e468:	00bfec16 	blt	zero,r2,822e41c <m_copy+0x54>
 822e46c:	00000106 	br	822e474 <m_copy+0xac>
      {
         dtrap();
         return NULL;
      }
      if (off < (int)m->m_len)
         break;
 822e470:	0001883a 	nop
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 822e474:	e03ffb15 	stw	zero,-20(fp)
 822e478:	e0bffb17 	ldw	r2,-20(fp)
 822e47c:	e0bffa15 	stw	r2,-24(fp)

   while (len > 0)
 822e480:	00007f06 	br	822e680 <m_copy+0x2b8>
   {
      if (m == NULL) /* at end of queue? */
 822e484:	e0bffd17 	ldw	r2,-12(fp)
 822e488:	1000051e 	bne	r2,zero,822e4a0 <m_copy+0xd8>
      {
         panic("m_copy: bad len");
 822e48c:	01020974 	movhi	r4,2085
 822e490:	21027b04 	addi	r4,r4,2540
 822e494:	82289940 	call	8228994 <panic>
         return NULL;
 822e498:	0005883a 	mov	r2,zero
 822e49c:	00008206 	br	822e6a8 <m_copy+0x2e0>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 822e4a0:	e0bffd17 	ldw	r2,-12(fp)
 822e4a4:	10c00217 	ldw	r3,8(r2)
 822e4a8:	e0bffe17 	ldw	r2,-8(fp)
 822e4ac:	1885c83a 	sub	r2,r3,r2
 822e4b0:	e0ffff17 	ldw	r3,-4(fp)
 822e4b4:	1880010e 	bge	r3,r2,822e4bc <m_copy+0xf4>
 822e4b8:	1805883a 	mov	r2,r3
 822e4bc:	e0bffc15 	stw	r2,-16(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e4c0:	e0bffe17 	ldw	r2,-8(fp)
 822e4c4:	108000cc 	andi	r2,r2,3
 822e4c8:	1000051e 	bne	r2,zero,822e4e0 <m_copy+0x118>
          (m->pkt->inuse != 1))
 822e4cc:	e0bffd17 	ldw	r2,-12(fp)
 822e4d0:	10800117 	ldw	r2,4(r2)
 822e4d4:	10800917 	ldw	r2,36(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e4d8:	10800060 	cmpeqi	r2,r2,1
 822e4dc:	1000251e 	bne	r2,zero,822e574 <m_copy+0x1ac>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 822e4e0:	e0bffd17 	ldw	r2,-12(fp)
 822e4e4:	10800817 	ldw	r2,32(r2)
 822e4e8:	e17ffc17 	ldw	r5,-16(fp)
 822e4ec:	1009883a 	mov	r4,r2
 822e4f0:	822e0f40 	call	822e0f4 <m_getnbuf>
 822e4f4:	e0bff915 	stw	r2,-28(fp)
 822e4f8:	e0bff917 	ldw	r2,-28(fp)
 822e4fc:	10006426 	beq	r2,zero,822e690 <m_copy+0x2c8>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 822e500:	e0bff917 	ldw	r2,-28(fp)
 822e504:	11000317 	ldw	r4,12(r2)
 822e508:	e0bffd17 	ldw	r2,-12(fp)
 822e50c:	10c00317 	ldw	r3,12(r2)
 822e510:	e0bffe17 	ldw	r2,-8(fp)
 822e514:	1885883a 	add	r2,r3,r2
 822e518:	e0fffc17 	ldw	r3,-16(fp)
 822e51c:	180d883a 	mov	r6,r3
 822e520:	100b883a 	mov	r5,r2
 822e524:	8202c5c0 	call	8202c5c <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 822e528:	e0fffc17 	ldw	r3,-16(fp)
 822e52c:	e0bff917 	ldw	r2,-28(fp)
 822e530:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 822e534:	008209b4 	movhi	r2,2086
 822e538:	10b8aa04 	addi	r2,r2,-7512
 822e53c:	10802e17 	ldw	r2,184(r2)
 822e540:	10c00044 	addi	r3,r2,1
 822e544:	008209b4 	movhi	r2,2086
 822e548:	10b8aa04 	addi	r2,r2,-7512
 822e54c:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 822e550:	008209b4 	movhi	r2,2086
 822e554:	10b8aa04 	addi	r2,r2,-7512
 822e558:	10c03017 	ldw	r3,192(r2)
 822e55c:	e0bffc17 	ldw	r2,-16(fp)
 822e560:	1887883a 	add	r3,r3,r2
 822e564:	008209b4 	movhi	r2,2086
 822e568:	10b8aa04 	addi	r2,r2,-7512
 822e56c:	10c03015 	stw	r3,192(r2)
 822e570:	00003106 	br	822e638 <m_copy+0x270>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 822e574:	e0bffd17 	ldw	r2,-12(fp)
 822e578:	10800817 	ldw	r2,32(r2)
 822e57c:	000b883a 	mov	r5,zero
 822e580:	1009883a 	mov	r4,r2
 822e584:	822e0f40 	call	822e0f4 <m_getnbuf>
 822e588:	e0bff915 	stw	r2,-28(fp)
 822e58c:	e0bff917 	ldw	r2,-28(fp)
 822e590:	10004126 	beq	r2,zero,822e698 <m_copy+0x2d0>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 822e594:	e0bffd17 	ldw	r2,-12(fp)
 822e598:	10800117 	ldw	r2,4(r2)
 822e59c:	10c00917 	ldw	r3,36(r2)
 822e5a0:	18c00044 	addi	r3,r3,1
 822e5a4:	10c00915 	stw	r3,36(r2)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 822e5a8:	e0bffd17 	ldw	r2,-12(fp)
 822e5ac:	10c00117 	ldw	r3,4(r2)
 822e5b0:	e0bff917 	ldw	r2,-28(fp)
 822e5b4:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 822e5b8:	e0bffd17 	ldw	r2,-12(fp)
 822e5bc:	10c00417 	ldw	r3,16(r2)
 822e5c0:	e0bff917 	ldw	r2,-28(fp)
 822e5c4:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 822e5c8:	e0bffd17 	ldw	r2,-12(fp)
 822e5cc:	10c00517 	ldw	r3,20(r2)
 822e5d0:	e0bff917 	ldw	r2,-28(fp)
 822e5d4:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 822e5d8:	e0bffd17 	ldw	r2,-12(fp)
 822e5dc:	10c00317 	ldw	r3,12(r2)
 822e5e0:	e0bffe17 	ldw	r2,-8(fp)
 822e5e4:	1887883a 	add	r3,r3,r2
 822e5e8:	e0bff917 	ldw	r2,-28(fp)
 822e5ec:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 822e5f0:	e0fffc17 	ldw	r3,-16(fp)
 822e5f4:	e0bff917 	ldw	r2,-28(fp)
 822e5f8:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 822e5fc:	008209b4 	movhi	r2,2086
 822e600:	10b8aa04 	addi	r2,r2,-7512
 822e604:	10802f17 	ldw	r2,188(r2)
 822e608:	10c00044 	addi	r3,r2,1
 822e60c:	008209b4 	movhi	r2,2086
 822e610:	10b8aa04 	addi	r2,r2,-7512
 822e614:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 822e618:	008209b4 	movhi	r2,2086
 822e61c:	10b8aa04 	addi	r2,r2,-7512
 822e620:	10c03117 	ldw	r3,196(r2)
 822e624:	e0bffc17 	ldw	r2,-16(fp)
 822e628:	1887883a 	add	r3,r3,r2
 822e62c:	008209b4 	movhi	r2,2086
 822e630:	10b8aa04 	addi	r2,r2,-7512
 822e634:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 822e638:	e0ffff17 	ldw	r3,-4(fp)
 822e63c:	e0bffc17 	ldw	r2,-16(fp)
 822e640:	1885c83a 	sub	r2,r3,r2
 822e644:	e0bfff15 	stw	r2,-4(fp)
      off = 0;
 822e648:	e03ffe15 	stw	zero,-8(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 822e64c:	e0bffb17 	ldw	r2,-20(fp)
 822e650:	10000426 	beq	r2,zero,822e664 <m_copy+0x29c>
         tail->m_next = nb;
 822e654:	e0bffb17 	ldw	r2,-20(fp)
 822e658:	e0fff917 	ldw	r3,-28(fp)
 822e65c:	10c00615 	stw	r3,24(r2)
 822e660:	00000206 	br	822e66c <m_copy+0x2a4>
      else
         head = nb;
 822e664:	e0bff917 	ldw	r2,-28(fp)
 822e668:	e0bffa15 	stw	r2,-24(fp)
      tail = nb;     /* always make new mbuf the tail */
 822e66c:	e0bff917 	ldw	r2,-28(fp)
 822e670:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 822e674:	e0bffd17 	ldw	r2,-12(fp)
 822e678:	10800617 	ldw	r2,24(r2)
 822e67c:	e0bffd15 	stw	r2,-12(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 822e680:	e0bfff17 	ldw	r2,-4(fp)
 822e684:	00bf7f16 	blt	zero,r2,822e484 <m_copy+0xbc>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 822e688:	e0bffa17 	ldw	r2,-24(fp)
 822e68c:	00000606 	br	822e6a8 <m_copy+0x2e0>
       */
      if ((off & (ALIGN_TYPE - 1)) ||
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
            goto nospace;
 822e690:	0001883a 	nop
 822e694:	00000106 	br	822e69c <m_copy+0x2d4>
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
            goto nospace;
 822e698:	0001883a 	nop
   }

   return head;

nospace:
   m_freem (head);
 822e69c:	e13ffa17 	ldw	r4,-24(fp)
 822e6a0:	822e3840 	call	822e384 <m_freem>
   return NULL;
 822e6a4:	0005883a 	mov	r2,zero
}
 822e6a8:	e037883a 	mov	sp,fp
 822e6ac:	dfc00117 	ldw	ra,4(sp)
 822e6b0:	df000017 	ldw	fp,0(sp)
 822e6b4:	dec00204 	addi	sp,sp,8
 822e6b8:	f800283a 	ret

0822e6bc <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 822e6bc:	defffb04 	addi	sp,sp,-20
 822e6c0:	df000415 	stw	fp,16(sp)
 822e6c4:	df000404 	addi	fp,sp,16
 822e6c8:	e13ffe15 	stw	r4,-8(fp)
 822e6cc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 822e6d0:	e0bffe17 	ldw	r2,-8(fp)
 822e6d4:	e0bffc15 	stw	r2,-16(fp)
 822e6d8:	e0bffc17 	ldw	r2,-16(fp)
 822e6dc:	10006226 	beq	r2,zero,822e868 <m_adj+0x1ac>
      return;

   if (len >= 0) 
 822e6e0:	e0bfff17 	ldw	r2,-4(fp)
 822e6e4:	10002216 	blt	r2,zero,822e770 <m_adj+0xb4>
   {
      while (m != NULL && len > 0) 
 822e6e8:	00001c06 	br	822e75c <m_adj+0xa0>
      {
         if (m->m_len <= (unsigned)len)
 822e6ec:	e0bffc17 	ldw	r2,-16(fp)
 822e6f0:	10800217 	ldw	r2,8(r2)
 822e6f4:	e0ffff17 	ldw	r3,-4(fp)
 822e6f8:	18800b36 	bltu	r3,r2,822e728 <m_adj+0x6c>
         {
            len -= m->m_len;
 822e6fc:	e0ffff17 	ldw	r3,-4(fp)
 822e700:	e0bffc17 	ldw	r2,-16(fp)
 822e704:	10800217 	ldw	r2,8(r2)
 822e708:	1885c83a 	sub	r2,r3,r2
 822e70c:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 822e710:	e0bffc17 	ldw	r2,-16(fp)
 822e714:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 822e718:	e0bffc17 	ldw	r2,-16(fp)
 822e71c:	10800617 	ldw	r2,24(r2)
 822e720:	e0bffc15 	stw	r2,-16(fp)
 822e724:	00000d06 	br	822e75c <m_adj+0xa0>
         }
         else
         {
            m->m_len -= len;
 822e728:	e0bffc17 	ldw	r2,-16(fp)
 822e72c:	10c00217 	ldw	r3,8(r2)
 822e730:	e0bfff17 	ldw	r2,-4(fp)
 822e734:	1887c83a 	sub	r3,r3,r2
 822e738:	e0bffc17 	ldw	r2,-16(fp)
 822e73c:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 822e740:	e0bffc17 	ldw	r2,-16(fp)
 822e744:	10c00317 	ldw	r3,12(r2)
 822e748:	e0bfff17 	ldw	r2,-4(fp)
 822e74c:	1887883a 	add	r3,r3,r2
 822e750:	e0bffc17 	ldw	r2,-16(fp)
 822e754:	10c00315 	stw	r3,12(r2)
            break;
 822e758:	00004406 	br	822e86c <m_adj+0x1b0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 822e75c:	e0bffc17 	ldw	r2,-16(fp)
 822e760:	10004226 	beq	r2,zero,822e86c <m_adj+0x1b0>
 822e764:	e0bfff17 	ldw	r2,-4(fp)
 822e768:	00bfe016 	blt	zero,r2,822e6ec <m_adj+0x30>
 822e76c:	00003f06 	br	822e86c <m_adj+0x1b0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 822e770:	e0bfff17 	ldw	r2,-4(fp)
 822e774:	0085c83a 	sub	r2,zero,r2
 822e778:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 822e77c:	e03ffd15 	stw	zero,-12(fp)
      for (;;) 
      {
         count += m->m_len;
 822e780:	e0bffc17 	ldw	r2,-16(fp)
 822e784:	10c00217 	ldw	r3,8(r2)
 822e788:	e0bffd17 	ldw	r2,-12(fp)
 822e78c:	1885883a 	add	r2,r3,r2
 822e790:	e0bffd15 	stw	r2,-12(fp)
         if (m->m_next == (struct mbuf *)0)
 822e794:	e0bffc17 	ldw	r2,-16(fp)
 822e798:	10800617 	ldw	r2,24(r2)
 822e79c:	10000426 	beq	r2,zero,822e7b0 <m_adj+0xf4>
            break;
         m = m->m_next;
 822e7a0:	e0bffc17 	ldw	r2,-16(fp)
 822e7a4:	10800617 	ldw	r2,24(r2)
 822e7a8:	e0bffc15 	stw	r2,-16(fp)
      }
 822e7ac:	003ff406 	br	822e780 <m_adj+0xc4>
      count = 0;
      for (;;) 
      {
         count += m->m_len;
         if (m->m_next == (struct mbuf *)0)
            break;
 822e7b0:	0001883a 	nop
         m = m->m_next;
      }
      if (m->m_len >= (unsigned)len)
 822e7b4:	e0bffc17 	ldw	r2,-16(fp)
 822e7b8:	10c00217 	ldw	r3,8(r2)
 822e7bc:	e0bfff17 	ldw	r2,-4(fp)
 822e7c0:	18800736 	bltu	r3,r2,822e7e0 <m_adj+0x124>
      {
         m->m_len -= len;
 822e7c4:	e0bffc17 	ldw	r2,-16(fp)
 822e7c8:	10c00217 	ldw	r3,8(r2)
 822e7cc:	e0bfff17 	ldw	r2,-4(fp)
 822e7d0:	1887c83a 	sub	r3,r3,r2
 822e7d4:	e0bffc17 	ldw	r2,-16(fp)
 822e7d8:	10c00215 	stw	r3,8(r2)
         return;
 822e7dc:	00002306 	br	822e86c <m_adj+0x1b0>
      }
      count -= len;
 822e7e0:	e0fffd17 	ldw	r3,-12(fp)
 822e7e4:	e0bfff17 	ldw	r2,-4(fp)
 822e7e8:	1885c83a 	sub	r2,r3,r2
 822e7ec:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822e7f0:	e0bffe17 	ldw	r2,-8(fp)
 822e7f4:	e0bffc15 	stw	r2,-16(fp)
 822e7f8:	00001006 	br	822e83c <m_adj+0x180>
      {
         if (m->m_len >= (unsigned)count)
 822e7fc:	e0bffc17 	ldw	r2,-16(fp)
 822e800:	10c00217 	ldw	r3,8(r2)
 822e804:	e0bffd17 	ldw	r2,-12(fp)
 822e808:	18800436 	bltu	r3,r2,822e81c <m_adj+0x160>
         {
            m->m_len = count;
 822e80c:	e0fffd17 	ldw	r3,-12(fp)
 822e810:	e0bffc17 	ldw	r2,-16(fp)
 822e814:	10c00215 	stw	r3,8(r2)
            break;
 822e818:	00000a06 	br	822e844 <m_adj+0x188>
         }
         count -= m->m_len;
 822e81c:	e0fffd17 	ldw	r3,-12(fp)
 822e820:	e0bffc17 	ldw	r2,-16(fp)
 822e824:	10800217 	ldw	r2,8(r2)
 822e828:	1885c83a 	sub	r2,r3,r2
 822e82c:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822e830:	e0bffc17 	ldw	r2,-16(fp)
 822e834:	10800617 	ldw	r2,24(r2)
 822e838:	e0bffc15 	stw	r2,-16(fp)
 822e83c:	e0bffc17 	ldw	r2,-16(fp)
 822e840:	103fee1e 	bne	r2,zero,822e7fc <m_adj+0x140>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822e844:	00000206 	br	822e850 <m_adj+0x194>
         m->m_len = 0;
 822e848:	e0bffc17 	ldw	r2,-16(fp)
 822e84c:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822e850:	e0bffc17 	ldw	r2,-16(fp)
 822e854:	10800617 	ldw	r2,24(r2)
 822e858:	e0bffc15 	stw	r2,-16(fp)
 822e85c:	e0bffc17 	ldw	r2,-16(fp)
 822e860:	103ff91e 	bne	r2,zero,822e848 <m_adj+0x18c>
 822e864:	00000106 	br	822e86c <m_adj+0x1b0>
{
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
      return;
 822e868:	0001883a 	nop
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
         m->m_len = 0;
   }
}
 822e86c:	e037883a 	mov	sp,fp
 822e870:	df000017 	ldw	fp,0(sp)
 822e874:	dec00104 	addi	sp,sp,4
 822e878:	f800283a 	ret

0822e87c <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 822e87c:	defffd04 	addi	sp,sp,-12
 822e880:	df000215 	stw	fp,8(sp)
 822e884:	df000204 	addi	fp,sp,8
 822e888:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 822e88c:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 822e890:	00000806 	br	822e8b4 <mbuf_len+0x38>
   {
      len += m->m_len;
 822e894:	e0bfff17 	ldw	r2,-4(fp)
 822e898:	10c00217 	ldw	r3,8(r2)
 822e89c:	e0bffe17 	ldw	r2,-8(fp)
 822e8a0:	1885883a 	add	r2,r3,r2
 822e8a4:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e8a8:	e0bfff17 	ldw	r2,-4(fp)
 822e8ac:	10800617 	ldw	r2,24(r2)
 822e8b0:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 822e8b4:	e0bfff17 	ldw	r2,-4(fp)
 822e8b8:	103ff61e 	bne	r2,zero,822e894 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 822e8bc:	e0bffe17 	ldw	r2,-8(fp)
}
 822e8c0:	e037883a 	mov	sp,fp
 822e8c4:	df000017 	ldw	fp,0(sp)
 822e8c8:	dec00104 	addi	sp,sp,4
 822e8cc:	f800283a 	ret

0822e8d0 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 822e8d0:	defffb04 	addi	sp,sp,-20
 822e8d4:	dfc00415 	stw	ra,16(sp)
 822e8d8:	df000315 	stw	fp,12(sp)
 822e8dc:	df000304 	addi	fp,sp,12
 822e8e0:	e13fff15 	stw	r4,-4(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822e8e4:	008209b4 	movhi	r2,2086
 822e8e8:	10b88b04 	addi	r2,r2,-7636
 822e8ec:	10800017 	ldw	r2,0(r2)
 822e8f0:	e0bffd15 	stw	r2,-12(fp)
 822e8f4:	00001206 	br	822e940 <dtom+0x70>
   {
      m = (struct mbuf *)qptr;
 822e8f8:	e0bffd17 	ldw	r2,-12(fp)
 822e8fc:	e0bffe15 	stw	r2,-8(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 822e900:	e0bffe17 	ldw	r2,-8(fp)
 822e904:	10800417 	ldw	r2,16(r2)
 822e908:	e0ffff17 	ldw	r3,-4(fp)
 822e90c:	18800936 	bltu	r3,r2,822e934 <dtom+0x64>
 822e910:	e0bffe17 	ldw	r2,-8(fp)
 822e914:	10c00417 	ldw	r3,16(r2)
 822e918:	e0bffe17 	ldw	r2,-8(fp)
 822e91c:	10800517 	ldw	r2,20(r2)
 822e920:	1885883a 	add	r2,r3,r2
 822e924:	e0ffff17 	ldw	r3,-4(fp)
 822e928:	1880022e 	bgeu	r3,r2,822e934 <dtom+0x64>
         return (struct mbuf *)qptr;
 822e92c:	e0bffd17 	ldw	r2,-12(fp)
 822e930:	00000906 	br	822e958 <dtom+0x88>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822e934:	e0bffd17 	ldw	r2,-12(fp)
 822e938:	10800017 	ldw	r2,0(r2)
 822e93c:	e0bffd15 	stw	r2,-12(fp)
 822e940:	e0bffd17 	ldw	r2,-12(fp)
 822e944:	103fec1e 	bne	r2,zero,822e8f8 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 822e948:	01020974 	movhi	r4,2085
 822e94c:	21027f04 	addi	r4,r4,2556
 822e950:	82289940 	call	8228994 <panic>
   return NULL;
 822e954:	0005883a 	mov	r2,zero
}
 822e958:	e037883a 	mov	sp,fp
 822e95c:	dfc00117 	ldw	ra,4(sp)
 822e960:	df000017 	ldw	fp,0(sp)
 822e964:	dec00204 	addi	sp,sp,8
 822e968:	f800283a 	ret

0822e96c <remque>:
};


void
remque (void * arg)
{
 822e96c:	defffd04 	addi	sp,sp,-12
 822e970:	df000215 	stw	fp,8(sp)
 822e974:	df000204 	addi	fp,sp,8
 822e978:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 822e97c:	e0bfff17 	ldw	r2,-4(fp)
 822e980:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 822e984:	e0bffe17 	ldw	r2,-8(fp)
 822e988:	10800117 	ldw	r2,4(r2)
 822e98c:	10000e26 	beq	r2,zero,822e9c8 <remque+0x5c>
      old->prev->next = old->next;
 822e990:	e0bffe17 	ldw	r2,-8(fp)
 822e994:	10800117 	ldw	r2,4(r2)
 822e998:	e0fffe17 	ldw	r3,-8(fp)
 822e99c:	18c00017 	ldw	r3,0(r3)
 822e9a0:	10c00015 	stw	r3,0(r2)
   if (old->next)
 822e9a4:	e0bffe17 	ldw	r2,-8(fp)
 822e9a8:	10800017 	ldw	r2,0(r2)
 822e9ac:	10000726 	beq	r2,zero,822e9cc <remque+0x60>
      old->next->prev = old->prev;
 822e9b0:	e0bffe17 	ldw	r2,-8(fp)
 822e9b4:	10800017 	ldw	r2,0(r2)
 822e9b8:	e0fffe17 	ldw	r3,-8(fp)
 822e9bc:	18c00117 	ldw	r3,4(r3)
 822e9c0:	10c00115 	stw	r3,4(r2)
 822e9c4:	00000106 	br	822e9cc <remque+0x60>
remque (void * arg)
{
   struct bsdq *  old;

   old = (struct bsdq *)arg;
   if (!old->prev) return;
 822e9c8:	0001883a 	nop
      old->prev->next = old->next;
   if (old->next)
      old->next->prev = old->prev;
}
 822e9cc:	e037883a 	mov	sp,fp
 822e9d0:	df000017 	ldw	fp,0(sp)
 822e9d4:	dec00104 	addi	sp,sp,4
 822e9d8:	f800283a 	ret

0822e9dc <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 822e9dc:	defffb04 	addi	sp,sp,-20
 822e9e0:	df000415 	stw	fp,16(sp)
 822e9e4:	df000404 	addi	fp,sp,16
 822e9e8:	e13ffe15 	stw	r4,-8(fp)
 822e9ec:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 822e9f0:	e0bffe17 	ldw	r2,-8(fp)
 822e9f4:	e0bffc15 	stw	r2,-16(fp)
   prev = (struct bsdq *)p;
 822e9f8:	e0bfff17 	ldw	r2,-4(fp)
 822e9fc:	e0bffd15 	stw	r2,-12(fp)
   newe->next = prev->next;
 822ea00:	e0bffd17 	ldw	r2,-12(fp)
 822ea04:	10c00017 	ldw	r3,0(r2)
 822ea08:	e0bffc17 	ldw	r2,-16(fp)
 822ea0c:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 822ea10:	e0bffc17 	ldw	r2,-16(fp)
 822ea14:	e0fffd17 	ldw	r3,-12(fp)
 822ea18:	10c00115 	stw	r3,4(r2)
   prev->next = newe;
 822ea1c:	e0bffd17 	ldw	r2,-12(fp)
 822ea20:	e0fffc17 	ldw	r3,-16(fp)
 822ea24:	10c00015 	stw	r3,0(r2)
   if (newe->next)
 822ea28:	e0bffc17 	ldw	r2,-16(fp)
 822ea2c:	10800017 	ldw	r2,0(r2)
 822ea30:	10000426 	beq	r2,zero,822ea44 <insque+0x68>
      newe->next->prev = newe;
 822ea34:	e0bffc17 	ldw	r2,-16(fp)
 822ea38:	10800017 	ldw	r2,0(r2)
 822ea3c:	e0fffc17 	ldw	r3,-16(fp)
 822ea40:	10c00115 	stw	r3,4(r2)
}
 822ea44:	0001883a 	nop
 822ea48:	e037883a 	mov	sp,fp
 822ea4c:	df000017 	ldw	fp,0(sp)
 822ea50:	dec00104 	addi	sp,sp,4
 822ea54:	f800283a 	ret

0822ea58 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 822ea58:	defffb04 	addi	sp,sp,-20
 822ea5c:	dfc00415 	stw	ra,16(sp)
 822ea60:	df000315 	stw	fp,12(sp)
 822ea64:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 822ea68:	d0e03617 	ldw	r3,-32552(gp)
 822ea6c:	d0a03817 	ldw	r2,-32544(gp)
 822ea70:	1885883a 	add	r2,r3,r2
 822ea74:	1085883a 	add	r2,r2,r2
 822ea78:	108000c4 	addi	r2,r2,3
 822ea7c:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 822ea80:	01800504 	movi	r6,20
 822ea84:	000b883a 	mov	r5,zero
 822ea88:	010209b4 	movhi	r4,2086
 822ea8c:	21387704 	addi	r4,r4,-7716
 822ea90:	8202f000 	call	8202f00 <memset>
   MEMSET(&mbufq, 0, sizeof(mbufq));
 822ea94:	01800504 	movi	r6,20
 822ea98:	000b883a 	mov	r5,zero
 822ea9c:	010209b4 	movhi	r4,2086
 822eaa0:	21388b04 	addi	r4,r4,-7636
 822eaa4:	8202f000 	call	8202f00 <memset>
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 822eaa8:	01800504 	movi	r6,20
 822eaac:	000b883a 	mov	r5,zero
 822eab0:	010209b4 	movhi	r4,2086
 822eab4:	21389004 	addi	r4,r4,-7616
 822eab8:	8202f000 	call	8202f00 <memset>
   for (i = 0; i < (int)bufcount; i++)
 822eabc:	e03ffd15 	stw	zero,-12(fp)
 822eac0:	00001506 	br	822eb18 <nptcp_init+0xc0>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 822eac4:	01000904 	movi	r4,36
 822eac8:	822deb80 	call	822deb8 <npalloc>
 822eacc:	e0bfff15 	stw	r2,-4(fp)
      if (!m)  /* malloc error, bail out */
 822ead0:	e0bfff17 	ldw	r2,-4(fp)
 822ead4:	1000031e 	bne	r2,zero,822eae4 <nptcp_init+0x8c>
         panic("tcpinit");
 822ead8:	01020974 	movhi	r4,2085
 822eadc:	21028104 	addi	r4,r4,2564
 822eae0:	82289940 	call	8228994 <panic>
      m->m_type = MT_FREE;
 822eae4:	e0bfff17 	ldw	r2,-4(fp)
 822eae8:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 822eaec:	e0bfff17 	ldw	r2,-4(fp)
 822eaf0:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 822eaf4:	e0bfff17 	ldw	r2,-4(fp)
 822eaf8:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 822eafc:	e17fff17 	ldw	r5,-4(fp)
 822eb00:	010209b4 	movhi	r4,2086
 822eb04:	21389004 	addi	r4,r4,-7616
 822eb08:	822ccc80 	call	822ccc8 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 822eb0c:	e0bffd17 	ldw	r2,-12(fp)
 822eb10:	10800044 	addi	r2,r2,1
 822eb14:	e0bffd15 	stw	r2,-12(fp)
 822eb18:	e0bffe17 	ldw	r2,-8(fp)
 822eb1c:	e0fffd17 	ldw	r3,-12(fp)
 822eb20:	18bfe816 	blt	r3,r2,822eac4 <nptcp_init+0x6c>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 822eb24:	e0fffe17 	ldw	r3,-8(fp)
 822eb28:	008209b4 	movhi	r2,2086
 822eb2c:	10b89004 	addi	r2,r2,-7616
 822eb30:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 822eb34:	82392180 	call	8239218 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 822eb38:	0005883a 	mov	r2,zero
}
 822eb3c:	e037883a 	mov	sp,fp
 822eb40:	dfc00117 	ldw	ra,4(sp)
 822eb44:	df000017 	ldw	fp,0(sp)
 822eb48:	dec00204 	addi	sp,sp,8
 822eb4c:	f800283a 	ret

0822eb50 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 822eb50:	defff904 	addi	sp,sp,-28
 822eb54:	dfc00615 	stw	ra,24(sp)
 822eb58:	df000515 	stw	fp,20(sp)
 822eb5c:	df000504 	addi	fp,sp,20
 822eb60:	e13fff15 	stw	r4,-4(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 822eb64:	e0bfff17 	ldw	r2,-4(fp)
 822eb68:	10800317 	ldw	r2,12(r2)
 822eb6c:	e0bffb15 	stw	r2,-20(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 822eb70:	e0bffb17 	ldw	r2,-20(fp)
 822eb74:	1080008b 	ldhu	r2,2(r2)
 822eb78:	10bfffcc 	andi	r2,r2,65535
 822eb7c:	1004d23a 	srli	r2,r2,8
 822eb80:	1007883a 	mov	r3,r2
 822eb84:	e0bffb17 	ldw	r2,-20(fp)
 822eb88:	1080008b 	ldhu	r2,2(r2)
 822eb8c:	10bfffcc 	andi	r2,r2,65535
 822eb90:	1004923a 	slli	r2,r2,8
 822eb94:	1884b03a 	or	r2,r3,r2
 822eb98:	e0bffc0d 	sth	r2,-16(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 822eb9c:	e0bffb17 	ldw	r2,-20(fp)
 822eba0:	10800003 	ldbu	r2,0(r2)
 822eba4:	10803fcc 	andi	r2,r2,255
 822eba8:	108003cc 	andi	r2,r2,15
 822ebac:	1085883a 	add	r2,r2,r2
 822ebb0:	1085883a 	add	r2,r2,r2
 822ebb4:	1007883a 	mov	r3,r2
 822ebb8:	e0bffb17 	ldw	r2,-20(fp)
 822ebbc:	10c5883a 	add	r2,r2,r3
 822ebc0:	e0bffd15 	stw	r2,-12(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 822ebc4:	e13ffb17 	ldw	r4,-20(fp)
 822ebc8:	82479e40 	call	82479e4 <tcp_cksum>
 822ebcc:	1007883a 	mov	r3,r2
 822ebd0:	e0bffd17 	ldw	r2,-12(fp)
 822ebd4:	1080040b 	ldhu	r2,16(r2)
 822ebd8:	18ffffcc 	andi	r3,r3,65535
 822ebdc:	10bfffcc 	andi	r2,r2,65535
 822ebe0:	18801626 	beq	r3,r2,822ec3c <tcp_rcv+0xec>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 822ebe4:	008209b4 	movhi	r2,2086
 822ebe8:	10b87c04 	addi	r2,r2,-7696
 822ebec:	10800d17 	ldw	r2,52(r2)
 822ebf0:	10c00044 	addi	r3,r2,1
 822ebf4:	008209b4 	movhi	r2,2086
 822ebf8:	10b87c04 	addi	r2,r2,-7696
 822ebfc:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 822ec00:	008209b4 	movhi	r2,2086
 822ec04:	10b8aa04 	addi	r2,r2,-7512
 822ec08:	10801c17 	ldw	r2,112(r2)
 822ec0c:	10c00044 	addi	r3,r2,1
 822ec10:	008209b4 	movhi	r2,2086
 822ec14:	10b8aa04 	addi	r2,r2,-7512
 822ec18:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ec1c:	01000084 	movi	r4,2
 822ec20:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 822ec24:	e13fff17 	ldw	r4,-4(fp)
 822ec28:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ec2c:	01000084 	movi	r4,2
 822ec30:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 822ec34:	00bff804 	movi	r2,-32
 822ec38:	00003406 	br	822ed0c <tcp_rcv+0x1bc>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 822ec3c:	000b883a 	mov	r5,zero
 822ec40:	01000044 	movi	r4,1
 822ec44:	822e0f40 	call	822e0f4 <m_getnbuf>
 822ec48:	e0bffe15 	stw	r2,-8(fp)
   if (!m_in){
 822ec4c:	e0bffe17 	ldw	r2,-8(fp)
 822ec50:	1000081e 	bne	r2,zero,822ec74 <tcp_rcv+0x124>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ec54:	01000084 	movi	r4,2
 822ec58:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 822ec5c:	e13fff17 	ldw	r4,-4(fp)
 822ec60:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ec64:	01000084 	movi	r4,2
 822ec68:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 822ec6c:	00bffa84 	movi	r2,-22
 822ec70:	00002606 	br	822ed0c <tcp_rcv+0x1bc>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 822ec74:	e0bffb17 	ldw	r2,-20(fp)
 822ec78:	10800003 	ldbu	r2,0(r2)
 822ec7c:	10803fcc 	andi	r2,r2,255
 822ec80:	108003cc 	andi	r2,r2,15
 822ec84:	1085883a 	add	r2,r2,r2
 822ec88:	1085883a 	add	r2,r2,r2
 822ec8c:	1007883a 	mov	r3,r2
 822ec90:	e0bffc0b 	ldhu	r2,-16(fp)
 822ec94:	10c5c83a 	sub	r2,r2,r3
 822ec98:	e0bffc0d 	sth	r2,-16(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 822ec9c:	e0bffb17 	ldw	r2,-20(fp)
 822eca0:	e0fffc0b 	ldhu	r3,-16(fp)
 822eca4:	10c0008d 	sth	r3,2(r2)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 822eca8:	e0bffe17 	ldw	r2,-8(fp)
 822ecac:	e0ffff17 	ldw	r3,-4(fp)
 822ecb0:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 822ecb4:	e0bfff17 	ldw	r2,-4(fp)
 822ecb8:	10c00317 	ldw	r3,12(r2)
 822ecbc:	e0bffe17 	ldw	r2,-8(fp)
 822ecc0:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822ecc4:	e0bfff17 	ldw	r2,-4(fp)
 822ecc8:	10c00417 	ldw	r3,16(r2)
 822eccc:	e0bffe17 	ldw	r2,-8(fp)
 822ecd0:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 822ecd4:	e0bfff17 	ldw	r2,-4(fp)
 822ecd8:	10c00117 	ldw	r3,4(r2)
 822ecdc:	e0bffe17 	ldw	r2,-8(fp)
 822ece0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 822ece4:	e0bfff17 	ldw	r2,-4(fp)
 822ece8:	10c00217 	ldw	r3,8(r2)
 822ecec:	e0bffe17 	ldw	r2,-8(fp)
 822ecf0:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 822ecf4:	e0bfff17 	ldw	r2,-4(fp)
 822ecf8:	10800617 	ldw	r2,24(r2)
 822ecfc:	100b883a 	mov	r5,r2
 822ed00:	e13ffe17 	ldw	r4,-8(fp)
 822ed04:	82356cc0 	call	82356cc <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 822ed08:	0005883a 	mov	r2,zero
}
 822ed0c:	e037883a 	mov	sp,fp
 822ed10:	dfc00117 	ldw	ra,4(sp)
 822ed14:	df000017 	ldw	fp,0(sp)
 822ed18:	dec00204 	addi	sp,sp,8
 822ed1c:	f800283a 	ret

0822ed20 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 822ed20:	defff404 	addi	sp,sp,-48
 822ed24:	dfc00b15 	stw	ra,44(sp)
 822ed28:	df000a15 	stw	fp,40(sp)
 822ed2c:	df000a04 	addi	fp,sp,40
 822ed30:	e13ffe15 	stw	r4,-8(fp)
 822ed34:	e17fff15 	stw	r5,-4(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 822ed38:	e0bffe17 	ldw	r2,-8(fp)
 822ed3c:	10800617 	ldw	r2,24(r2)
 822ed40:	10010a26 	beq	r2,zero,822f16c <ip_output+0x44c>
   {
      m1 = data;
 822ed44:	e0bffe17 	ldw	r2,-8(fp)
 822ed48:	e0bff615 	stw	r2,-40(fp)
      m2 = data->m_next;
 822ed4c:	e0bffe17 	ldw	r2,-8(fp)
 822ed50:	10800617 	ldw	r2,24(r2)
 822ed54:	e0bff715 	stw	r2,-36(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822ed58:	00003506 	br	822ee30 <ip_output+0x110>
      {
         pkt = m1->pkt;
 822ed5c:	e0bff617 	ldw	r2,-40(fp)
 822ed60:	10800117 	ldw	r2,4(r2)
 822ed64:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822ed68:	e0bffa17 	ldw	r2,-24(fp)
 822ed6c:	10c00117 	ldw	r3,4(r2)
 822ed70:	e0bffa17 	ldw	r2,-24(fp)
 822ed74:	10800217 	ldw	r2,8(r2)
 822ed78:	1885883a 	add	r2,r3,r2
             (m1->m_data + m1->m_len + m2->m_len))
 822ed7c:	e0fff617 	ldw	r3,-40(fp)
 822ed80:	19000317 	ldw	r4,12(r3)
 822ed84:	e0fff617 	ldw	r3,-40(fp)
 822ed88:	19400217 	ldw	r5,8(r3)
 822ed8c:	e0fff717 	ldw	r3,-36(fp)
 822ed90:	18c00217 	ldw	r3,8(r3)
 822ed94:	28c7883a 	add	r3,r5,r3
 822ed98:	20c7883a 	add	r3,r4,r3

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
      {
         pkt = m1->pkt;
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822ed9c:	18802b2e 	bgeu	r3,r2,822ee4c <ip_output+0x12c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 822eda0:	e0bff617 	ldw	r2,-40(fp)
 822eda4:	10c00317 	ldw	r3,12(r2)
 822eda8:	e0bff617 	ldw	r2,-40(fp)
 822edac:	10800217 	ldw	r2,8(r2)
 822edb0:	1887883a 	add	r3,r3,r2
 822edb4:	e0bff717 	ldw	r2,-36(fp)
 822edb8:	11000317 	ldw	r4,12(r2)
 822edbc:	e0bff717 	ldw	r2,-36(fp)
 822edc0:	10800217 	ldw	r2,8(r2)
 822edc4:	100d883a 	mov	r6,r2
 822edc8:	200b883a 	mov	r5,r4
 822edcc:	1809883a 	mov	r4,r3
 822edd0:	8202c5c0 	call	8202c5c <memcpy>
            m1->m_len += m2->m_len;
 822edd4:	e0bff617 	ldw	r2,-40(fp)
 822edd8:	10c00217 	ldw	r3,8(r2)
 822eddc:	e0bff717 	ldw	r2,-36(fp)
 822ede0:	10800217 	ldw	r2,8(r2)
 822ede4:	1887883a 	add	r3,r3,r2
 822ede8:	e0bff617 	ldw	r2,-40(fp)
 822edec:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 822edf0:	e0bff717 	ldw	r2,-36(fp)
 822edf4:	10c00617 	ldw	r3,24(r2)
 822edf8:	e0bff617 	ldw	r2,-40(fp)
 822edfc:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 822ee00:	e13ff717 	ldw	r4,-36(fp)
 822ee04:	822e27c0 	call	822e27c <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 822ee08:	e0bff617 	ldw	r2,-40(fp)
 822ee0c:	10800617 	ldw	r2,24(r2)
 822ee10:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oappends++;
 822ee14:	008209b4 	movhi	r2,2086
 822ee18:	10b8aa04 	addi	r2,r2,-7512
 822ee1c:	10803317 	ldw	r2,204(r2)
 822ee20:	10c00044 	addi	r3,r2,1
 822ee24:	008209b4 	movhi	r2,2086
 822ee28:	10b8aa04 	addi	r2,r2,-7512
 822ee2c:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822ee30:	e0bff717 	ldw	r2,-36(fp)
 822ee34:	10005b26 	beq	r2,zero,822efa4 <ip_output+0x284>
 822ee38:	e0bff717 	ldw	r2,-36(fp)
 822ee3c:	10800217 	ldw	r2,8(r2)
 822ee40:	108002b0 	cmpltui	r2,r2,10
 822ee44:	103fc51e 	bne	r2,zero,822ed5c <ip_output+0x3c>
 822ee48:	00005606 	br	822efa4 <ip_output+0x284>
            m_free(m2);    /* free this m2.... */
            m2 = m1->m_next;  /* ...and thread the next one */
            tcpstat.tcps_oappends++;
         }
         else     /* if won't fit, fall to next copy */
            break;
 822ee4c:	0001883a 	nop
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822ee50:	00005406 	br	822efa4 <ip_output+0x284>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 822ee54:	e0bff717 	ldw	r2,-36(fp)
 822ee58:	10800317 	ldw	r2,12(r2)
 822ee5c:	1007883a 	mov	r3,r2
 822ee60:	e0bff717 	ldw	r2,-36(fp)
 822ee64:	10800117 	ldw	r2,4(r2)
 822ee68:	10800117 	ldw	r2,4(r2)
 822ee6c:	1885c83a 	sub	r2,r3,r2
 822ee70:	e0bffb15 	stw	r2,-20(fp)
         if (e < MaxLnh)
 822ee74:	d0a08117 	ldw	r2,-32252(gp)
 822ee78:	e0fffb17 	ldw	r3,-20(fp)
 822ee7c:	1880090e 	bge	r3,r2,822eea4 <ip_output+0x184>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 822ee80:	d0a08117 	ldw	r2,-32252(gp)
 822ee84:	e1bffb17 	ldw	r6,-20(fp)
 822ee88:	100b883a 	mov	r5,r2
 822ee8c:	01020974 	movhi	r4,2085
 822ee90:	21028304 	addi	r4,r4,2572
 822ee94:	82030ec0 	call	82030ec <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 822ee98:	01020974 	movhi	r4,2085
 822ee9c:	21028904 	addi	r4,r4,2596
 822eea0:	82289940 	call	8228994 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 822eea4:	e0bff617 	ldw	r2,-40(fp)
 822eea8:	10800217 	ldw	r2,8(r2)
 822eeac:	d0e08117 	ldw	r3,-32252(gp)
 822eeb0:	e13ffb17 	ldw	r4,-20(fp)
 822eeb4:	20c7c83a 	sub	r3,r4,r3
 822eeb8:	10c03c2e 	bgeu	r2,r3,822efac <ip_output+0x28c>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
 822eebc:	e0bff617 	ldw	r2,-40(fp)
 822eec0:	10800217 	ldw	r2,8(r2)
 822eec4:	108000cc 	andi	r2,r2,3
 822eec8:	1000381e 	bne	r2,zero,822efac <ip_output+0x28c>
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
 822eecc:	e0bff717 	ldw	r2,-36(fp)
 822eed0:	10800317 	ldw	r2,12(r2)
 822eed4:	1007883a 	mov	r3,r2
 822eed8:	e0bff717 	ldw	r2,-36(fp)
 822eedc:	10800117 	ldw	r2,4(r2)
 822eee0:	10800117 	ldw	r2,4(r2)
 822eee4:	1885c83a 	sub	r2,r3,r2
 822eee8:	10800e18 	cmpnei	r2,r2,56
 822eeec:	10002f1e 	bne	r2,zero,822efac <ip_output+0x28c>
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 822eef0:	e0bff717 	ldw	r2,-36(fp)
 822eef4:	10c00317 	ldw	r3,12(r2)
 822eef8:	e0bff617 	ldw	r2,-40(fp)
 822eefc:	10800217 	ldw	r2,8(r2)
 822ef00:	0085c83a 	sub	r2,zero,r2
 822ef04:	1887883a 	add	r3,r3,r2
 822ef08:	e0bff617 	ldw	r2,-40(fp)
 822ef0c:	11000317 	ldw	r4,12(r2)
 822ef10:	e0bff617 	ldw	r2,-40(fp)
 822ef14:	10800217 	ldw	r2,8(r2)
 822ef18:	100d883a 	mov	r6,r2
 822ef1c:	200b883a 	mov	r5,r4
 822ef20:	1809883a 	mov	r4,r3
 822ef24:	8202c5c0 	call	8202c5c <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 822ef28:	e0bff717 	ldw	r2,-36(fp)
 822ef2c:	10c00317 	ldw	r3,12(r2)
 822ef30:	e0bff617 	ldw	r2,-40(fp)
 822ef34:	10800217 	ldw	r2,8(r2)
 822ef38:	0085c83a 	sub	r2,zero,r2
 822ef3c:	1887883a 	add	r3,r3,r2
 822ef40:	e0bff717 	ldw	r2,-36(fp)
 822ef44:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 822ef48:	e0bff717 	ldw	r2,-36(fp)
 822ef4c:	10c00217 	ldw	r3,8(r2)
 822ef50:	e0bff617 	ldw	r2,-40(fp)
 822ef54:	10800217 	ldw	r2,8(r2)
 822ef58:	1887883a 	add	r3,r3,r2
 822ef5c:	e0bff717 	ldw	r2,-36(fp)
 822ef60:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 822ef64:	e13ff617 	ldw	r4,-40(fp)
 822ef68:	822e27c0 	call	822e27c <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 822ef6c:	e0bff717 	ldw	r2,-36(fp)
 822ef70:	e0bff615 	stw	r2,-40(fp)
 822ef74:	e0bff617 	ldw	r2,-40(fp)
 822ef78:	e0bffe15 	stw	r2,-8(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 822ef7c:	e0bff717 	ldw	r2,-36(fp)
 822ef80:	10800617 	ldw	r2,24(r2)
 822ef84:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oprepends++;
 822ef88:	008209b4 	movhi	r2,2086
 822ef8c:	10b8aa04 	addi	r2,r2,-7512
 822ef90:	10803217 	ldw	r2,200(r2)
 822ef94:	10c00044 	addi	r3,r2,1
 822ef98:	008209b4 	movhi	r2,2086
 822ef9c:	10b8aa04 	addi	r2,r2,-7512
 822efa0:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822efa4:	e0bff717 	ldw	r2,-36(fp)
 822efa8:	103faa1e 	bne	r2,zero,822ee54 <ip_output+0x134>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 822efac:	e0bff717 	ldw	r2,-36(fp)
 822efb0:	10006e26 	beq	r2,zero,822f16c <ip_output+0x44c>
      {
         total = 0;
 822efb4:	e03ff915 	stw	zero,-28(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822efb8:	e0bff617 	ldw	r2,-40(fp)
 822efbc:	e0bff815 	stw	r2,-32(fp)
 822efc0:	00000806 	br	822efe4 <ip_output+0x2c4>
            total += mtmp->m_len;
 822efc4:	e0bff817 	ldw	r2,-32(fp)
 822efc8:	10c00217 	ldw	r3,8(r2)
 822efcc:	e0bff917 	ldw	r2,-28(fp)
 822efd0:	1885883a 	add	r2,r3,r2
 822efd4:	e0bff915 	stw	r2,-28(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822efd8:	e0bff817 	ldw	r2,-32(fp)
 822efdc:	10800617 	ldw	r2,24(r2)
 822efe0:	e0bff815 	stw	r2,-32(fp)
 822efe4:	e0bff817 	ldw	r2,-32(fp)
 822efe8:	103ff61e 	bne	r2,zero,822efc4 <ip_output+0x2a4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822efec:	01000084 	movi	r4,2
 822eff0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 822eff4:	e0bff917 	ldw	r2,-28(fp)
 822eff8:	10800e04 	addi	r2,r2,56
 822effc:	1009883a 	mov	r4,r2
 822f000:	822c7380 	call	822c738 <pk_alloc>
 822f004:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f008:	01000084 	movi	r4,2
 822f00c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 822f010:	e0bffa17 	ldw	r2,-24(fp)
 822f014:	1000021e 	bne	r2,zero,822f020 <ip_output+0x300>
            return ENOBUFS;
 822f018:	00801a44 	movi	r2,105
 822f01c:	0000a706 	br	822f2bc <ip_output+0x59c>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 822f020:	e0bffa17 	ldw	r2,-24(fp)
 822f024:	10800117 	ldw	r2,4(r2)
 822f028:	d0e08117 	ldw	r3,-32252(gp)
 822f02c:	10c7883a 	add	r3,r2,r3
 822f030:	e0bffa17 	ldw	r2,-24(fp)
 822f034:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 822f038:	e0bff617 	ldw	r2,-40(fp)
 822f03c:	e0bff815 	stw	r2,-32(fp)
         while (mtmp)
 822f040:	00002906 	br	822f0e8 <ip_output+0x3c8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 822f044:	e0bffa17 	ldw	r2,-24(fp)
 822f048:	10c00317 	ldw	r3,12(r2)
 822f04c:	e0bff817 	ldw	r2,-32(fp)
 822f050:	11000317 	ldw	r4,12(r2)
 822f054:	e0bff817 	ldw	r2,-32(fp)
 822f058:	10800217 	ldw	r2,8(r2)
 822f05c:	100d883a 	mov	r6,r2
 822f060:	200b883a 	mov	r5,r4
 822f064:	1809883a 	mov	r4,r3
 822f068:	8202c5c0 	call	8202c5c <memcpy>
            pkt->nb_prot += mtmp->m_len;
 822f06c:	e0bffa17 	ldw	r2,-24(fp)
 822f070:	10c00317 	ldw	r3,12(r2)
 822f074:	e0bff817 	ldw	r2,-32(fp)
 822f078:	10800217 	ldw	r2,8(r2)
 822f07c:	1887883a 	add	r3,r3,r2
 822f080:	e0bffa17 	ldw	r2,-24(fp)
 822f084:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 822f088:	e0bffa17 	ldw	r2,-24(fp)
 822f08c:	10c00417 	ldw	r3,16(r2)
 822f090:	e0bff817 	ldw	r2,-32(fp)
 822f094:	10800217 	ldw	r2,8(r2)
 822f098:	1887883a 	add	r3,r3,r2
 822f09c:	e0bffa17 	ldw	r2,-24(fp)
 822f0a0:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 822f0a4:	e0bff817 	ldw	r2,-32(fp)
 822f0a8:	e0bff715 	stw	r2,-36(fp)
            mtmp = mtmp->m_next;
 822f0ac:	e0bff817 	ldw	r2,-32(fp)
 822f0b0:	10800617 	ldw	r2,24(r2)
 822f0b4:	e0bff815 	stw	r2,-32(fp)
            if (m2 != data)   /* save original head */
 822f0b8:	e0fff717 	ldw	r3,-36(fp)
 822f0bc:	e0bffe17 	ldw	r2,-8(fp)
 822f0c0:	18800226 	beq	r3,r2,822f0cc <ip_output+0x3ac>
               m_free(m2);
 822f0c4:	e13ff717 	ldw	r4,-36(fp)
 822f0c8:	822e27c0 	call	822e27c <m_free>
            tcpstat.tcps_ocopies++;
 822f0cc:	008209b4 	movhi	r2,2086
 822f0d0:	10b8aa04 	addi	r2,r2,-7512
 822f0d4:	10803417 	ldw	r2,208(r2)
 822f0d8:	10c00044 	addi	r3,r2,1
 822f0dc:	008209b4 	movhi	r2,2086
 822f0e0:	10b8aa04 	addi	r2,r2,-7512
 822f0e4:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 822f0e8:	e0bff817 	ldw	r2,-32(fp)
 822f0ec:	103fd51e 	bne	r2,zero,822f044 <ip_output+0x324>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 822f0f0:	e0bffa17 	ldw	r2,-24(fp)
 822f0f4:	10c00317 	ldw	r3,12(r2)
 822f0f8:	e0bff917 	ldw	r2,-28(fp)
 822f0fc:	0085c83a 	sub	r2,zero,r2
 822f100:	1887883a 	add	r3,r3,r2
 822f104:	e0bffa17 	ldw	r2,-24(fp)
 822f108:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f10c:	01000084 	movi	r4,2
 822f110:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 822f114:	e0bffe17 	ldw	r2,-8(fp)
 822f118:	10800117 	ldw	r2,4(r2)
 822f11c:	1009883a 	mov	r4,r2
 822f120:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f124:	01000084 	movi	r4,2
 822f128:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 822f12c:	e0bffe17 	ldw	r2,-8(fp)
 822f130:	e0fffa17 	ldw	r3,-24(fp)
 822f134:	10c00115 	stw	r3,4(r2)
         data->m_len = pkt->nb_plen;
 822f138:	e0bffa17 	ldw	r2,-24(fp)
 822f13c:	10c00417 	ldw	r3,16(r2)
 822f140:	e0bffe17 	ldw	r2,-8(fp)
 822f144:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 822f148:	e0bffe17 	ldw	r2,-8(fp)
 822f14c:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 822f150:	e0bffa17 	ldw	r2,-24(fp)
 822f154:	10c00317 	ldw	r3,12(r2)
 822f158:	e0bffe17 	ldw	r2,-8(fp)
 822f15c:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 822f160:	e0fff917 	ldw	r3,-28(fp)
 822f164:	e0bffe17 	ldw	r2,-8(fp)
 822f168:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 822f16c:	e0bffe17 	ldw	r2,-8(fp)
 822f170:	10c00317 	ldw	r3,12(r2)
 822f174:	e0bffe17 	ldw	r2,-8(fp)
 822f178:	10800117 	ldw	r2,4(r2)
 822f17c:	10800117 	ldw	r2,4(r2)
 822f180:	d1208117 	ldw	r4,-32252(gp)
 822f184:	1105883a 	add	r2,r2,r4
 822f188:	1880032e 	bgeu	r3,r2,822f198 <ip_output+0x478>
      panic("ip_output: overflow");
 822f18c:	01020974 	movhi	r4,2085
 822f190:	21028e04 	addi	r4,r4,2616
 822f194:	82289940 	call	8228994 <panic>

   pkt = data->pkt;
 822f198:	e0bffe17 	ldw	r2,-8(fp)
 822f19c:	10800117 	ldw	r2,4(r2)
 822f1a0:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 822f1a4:	e0bfff17 	ldw	r2,-4(fp)
 822f1a8:	10000326 	beq	r2,zero,822f1b8 <ip_output+0x498>
	   pkt->soxopts = so_optsPack;   /* yup */
 822f1ac:	e0bffa17 	ldw	r2,-24(fp)
 822f1b0:	e0ffff17 	ldw	r3,-4(fp)
 822f1b4:	10c00c15 	stw	r3,48(r2)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 822f1b8:	e0bffe17 	ldw	r2,-8(fp)
 822f1bc:	10800317 	ldw	r2,12(r2)
 822f1c0:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 822f1c4:	e0bffc17 	ldw	r2,-16(fp)
 822f1c8:	10c00417 	ldw	r3,16(r2)
 822f1cc:	e0bffa17 	ldw	r2,-24(fp)
 822f1d0:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 822f1d4:	e0bffc17 	ldw	r2,-16(fp)
 822f1d8:	00c01144 	movi	r3,69
 822f1dc:	10c00005 	stb	r3,0(r2)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 822f1e0:	e0bffc17 	ldw	r2,-16(fp)
 822f1e4:	1080008b 	ldhu	r2,2(r2)
 822f1e8:	10bfffcc 	andi	r2,r2,65535
 822f1ec:	1004d23a 	srli	r2,r2,8
 822f1f0:	1007883a 	mov	r3,r2
 822f1f4:	e0bffc17 	ldw	r2,-16(fp)
 822f1f8:	1080008b 	ldhu	r2,2(r2)
 822f1fc:	10bfffcc 	andi	r2,r2,65535
 822f200:	1004923a 	slli	r2,r2,8
 822f204:	1884b03a 	or	r2,r3,r2
 822f208:	1007883a 	mov	r3,r2
 822f20c:	e0bffc17 	ldw	r2,-16(fp)
 822f210:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 822f214:	e0bffc17 	ldw	r2,-16(fp)
 822f218:	10800003 	ldbu	r2,0(r2)
 822f21c:	10803fcc 	andi	r2,r2,255
 822f220:	108003cc 	andi	r2,r2,15
 822f224:	1085883a 	add	r2,r2,r2
 822f228:	1085883a 	add	r2,r2,r2
 822f22c:	1007883a 	mov	r3,r2
 822f230:	e0bffc17 	ldw	r2,-16(fp)
 822f234:	10c5883a 	add	r2,r2,r3
 822f238:	e0bffd15 	stw	r2,-12(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 822f23c:	e13ffc17 	ldw	r4,-16(fp)
 822f240:	82479e40 	call	82479e4 <tcp_cksum>
 822f244:	1007883a 	mov	r3,r2
 822f248:	e0bffd17 	ldw	r2,-12(fp)
 822f24c:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 822f250:	e0bffc17 	ldw	r2,-16(fp)
 822f254:	10c00504 	addi	r3,r2,20
 822f258:	e0bffa17 	ldw	r2,-24(fp)
 822f25c:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 822f260:	e0bffe17 	ldw	r2,-8(fp)
 822f264:	10800217 	ldw	r2,8(r2)
 822f268:	10fffb04 	addi	r3,r2,-20
 822f26c:	e0bffa17 	ldw	r2,-24(fp)
 822f270:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 822f274:	e17ffa17 	ldw	r5,-24(fp)
 822f278:	01000184 	movi	r4,6
 822f27c:	823f6980 	call	823f698 <ip_write>
 822f280:	e0bffb15 	stw	r2,-20(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 822f284:	e0bffe17 	ldw	r2,-8(fp)
 822f288:	10000115 	stw	zero,4(r2)
   m_freem(data);
 822f28c:	e13ffe17 	ldw	r4,-8(fp)
 822f290:	822e3840 	call	822e384 <m_freem>

   if (e < 0)
 822f294:	e0bffb17 	ldw	r2,-20(fp)
 822f298:	1000070e 	bge	r2,zero,822f2b8 <ip_output+0x598>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 822f29c:	e0bffb17 	ldw	r2,-20(fp)
 822f2a0:	10bffa98 	cmpnei	r2,r2,-22
 822f2a4:	1000021e 	bne	r2,zero,822f2b0 <ip_output+0x590>
         return 0;
 822f2a8:	0005883a 	mov	r2,zero
 822f2ac:	00000306 	br	822f2bc <ip_output+0x59c>
      return e;
 822f2b0:	e0bffb17 	ldw	r2,-20(fp)
 822f2b4:	00000106 	br	822f2bc <ip_output+0x59c>
   }
   else
      return 0;
 822f2b8:	0005883a 	mov	r2,zero
}
 822f2bc:	e037883a 	mov	sp,fp
 822f2c0:	dfc00117 	ldw	ra,4(sp)
 822f2c4:	df000017 	ldw	fp,0(sp)
 822f2c8:	dec00204 	addi	sp,sp,8
 822f2cc:	f800283a 	ret

0822f2d0 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 822f2d0:	defffe04 	addi	sp,sp,-8
 822f2d4:	df000115 	stw	fp,4(sp)
 822f2d8:	df000104 	addi	fp,sp,4
 822f2dc:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr == 0xffffffff)
 822f2e0:	e0bfff17 	ldw	r2,-4(fp)
 822f2e4:	10bfffd8 	cmpnei	r2,r2,-1
 822f2e8:	1000021e 	bne	r2,zero,822f2f4 <in_broadcast+0x24>
      return TRUE;
 822f2ec:	00800044 	movi	r2,1
 822f2f0:	00000106 	br	822f2f8 <in_broadcast+0x28>

   return FALSE;
 822f2f4:	0005883a 	mov	r2,zero
}
 822f2f8:	e037883a 	mov	sp,fp
 822f2fc:	df000017 	ldw	fp,0(sp)
 822f300:	dec00104 	addi	sp,sp,4
 822f304:	f800283a 	ret

0822f308 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 822f308:	defffb04 	addi	sp,sp,-20
 822f30c:	dfc00415 	stw	ra,16(sp)
 822f310:	df000315 	stw	fp,12(sp)
 822f314:	df000304 	addi	fp,sp,12
 822f318:	e13ffe15 	stw	r4,-8(fp)
 822f31c:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 822f320:	e0bffe17 	ldw	r2,-8(fp)
 822f324:	10800003 	ldbu	r2,0(r2)
 822f328:	10803fcc 	andi	r2,r2,255
 822f32c:	108003cc 	andi	r2,r2,15
 822f330:	1085883a 	add	r2,r2,r2
 822f334:	1085883a 	add	r2,r2,r2
 822f338:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 822f33c:	e0bffd17 	ldw	r2,-12(fp)
 822f340:	10800548 	cmpgei	r2,r2,21
 822f344:	10002726 	beq	r2,zero,822f3e4 <np_stripoptions+0xdc>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 822f348:	e0bffd17 	ldw	r2,-12(fp)
 822f34c:	10bffb04 	addi	r2,r2,-20
 822f350:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 822f354:	e0bffe17 	ldw	r2,-8(fp)
 822f358:	1080008b 	ldhu	r2,2(r2)
 822f35c:	e0fffd17 	ldw	r3,-12(fp)
 822f360:	10c5c83a 	sub	r2,r2,r3
 822f364:	1007883a 	mov	r3,r2
 822f368:	e0bffe17 	ldw	r2,-8(fp)
 822f36c:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 822f370:	e0bffe17 	ldw	r2,-8(fp)
 822f374:	10800003 	ldbu	r2,0(r2)
 822f378:	1007883a 	mov	r3,r2
 822f37c:	00bffc04 	movi	r2,-16
 822f380:	1884703a 	and	r2,r3,r2
 822f384:	10800154 	ori	r2,r2,5
 822f388:	1007883a 	mov	r3,r2
 822f38c:	e0bffe17 	ldw	r2,-8(fp)
 822f390:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 822f394:	e0bffd17 	ldw	r2,-12(fp)
 822f398:	e0fffe17 	ldw	r3,-8(fp)
 822f39c:	1885883a 	add	r2,r3,r2
 822f3a0:	01800504 	movi	r6,20
 822f3a4:	e17ffe17 	ldw	r5,-8(fp)
 822f3a8:	1009883a 	mov	r4,r2
 822f3ac:	8202da40 	call	8202da4 <memmove>
   m->m_len -= ihlen;
 822f3b0:	e0bfff17 	ldw	r2,-4(fp)
 822f3b4:	10c00217 	ldw	r3,8(r2)
 822f3b8:	e0bffd17 	ldw	r2,-12(fp)
 822f3bc:	1887c83a 	sub	r3,r3,r2
 822f3c0:	e0bfff17 	ldw	r2,-4(fp)
 822f3c4:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 822f3c8:	e0bfff17 	ldw	r2,-4(fp)
 822f3cc:	10c00317 	ldw	r3,12(r2)
 822f3d0:	e0bffd17 	ldw	r2,-12(fp)
 822f3d4:	1887883a 	add	r3,r3,r2
 822f3d8:	e0bfff17 	ldw	r2,-4(fp)
 822f3dc:	10c00315 	stw	r3,12(r2)
 822f3e0:	00000106 	br	822f3e8 <np_stripoptions+0xe0>
   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
      return;
 822f3e4:	0001883a 	nop

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
   m->m_len -= ihlen;
   m->m_data += ihlen;
}
 822f3e8:	e037883a 	mov	sp,fp
 822f3ec:	dfc00117 	ldw	ra,4(sp)
 822f3f0:	df000017 	ldw	fp,0(sp)
 822f3f4:	dec00204 	addi	sp,sp,8
 822f3f8:	f800283a 	ret

0822f3fc <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 822f3fc:	defff304 	addi	sp,sp,-52
 822f400:	dfc00c15 	stw	ra,48(sp)
 822f404:	df000b15 	stw	fp,44(sp)
 822f408:	df000b04 	addi	fp,sp,44
 822f40c:	e13ffe15 	stw	r4,-8(fp)
 822f410:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 822f414:	e0bfff17 	ldw	r2,-4(fp)
 822f418:	10800617 	ldw	r2,24(r2)
 822f41c:	1006d63a 	srli	r3,r2,24
 822f420:	e0bfff17 	ldw	r2,-4(fp)
 822f424:	10800617 	ldw	r2,24(r2)
 822f428:	1004d23a 	srli	r2,r2,8
 822f42c:	10bfc00c 	andi	r2,r2,65280
 822f430:	1886b03a 	or	r3,r3,r2
 822f434:	e0bfff17 	ldw	r2,-4(fp)
 822f438:	10800617 	ldw	r2,24(r2)
 822f43c:	10bfc00c 	andi	r2,r2,65280
 822f440:	1004923a 	slli	r2,r2,8
 822f444:	1886b03a 	or	r3,r3,r2
 822f448:	e0bfff17 	ldw	r2,-4(fp)
 822f44c:	10800617 	ldw	r2,24(r2)
 822f450:	1004963a 	slli	r2,r2,24
 822f454:	1884b03a 	or	r2,r3,r2
 822f458:	e0bff815 	stw	r2,-32(fp)
   lhost = htonl(pdp->dip.ip_src);
 822f45c:	e0bfff17 	ldw	r2,-4(fp)
 822f460:	10800517 	ldw	r2,20(r2)
 822f464:	1006d63a 	srli	r3,r2,24
 822f468:	e0bfff17 	ldw	r2,-4(fp)
 822f46c:	10800517 	ldw	r2,20(r2)
 822f470:	1004d23a 	srli	r2,r2,8
 822f474:	10bfc00c 	andi	r2,r2,65280
 822f478:	1886b03a 	or	r3,r3,r2
 822f47c:	e0bfff17 	ldw	r2,-4(fp)
 822f480:	10800517 	ldw	r2,20(r2)
 822f484:	10bfc00c 	andi	r2,r2,65280
 822f488:	1004923a 	slli	r2,r2,8
 822f48c:	1886b03a 	or	r3,r3,r2
 822f490:	e0bfff17 	ldw	r2,-4(fp)
 822f494:	10800517 	ldw	r2,20(r2)
 822f498:	1004963a 	slli	r2,r2,24
 822f49c:	1884b03a 	or	r2,r3,r2
 822f4a0:	e0bff915 	stw	r2,-28(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 822f4a4:	e0bfff17 	ldw	r2,-4(fp)
 822f4a8:	10800704 	addi	r2,r2,28
 822f4ac:	1080000b 	ldhu	r2,0(r2)
 822f4b0:	10bfffcc 	andi	r2,r2,65535
 822f4b4:	1004d23a 	srli	r2,r2,8
 822f4b8:	1007883a 	mov	r3,r2
 822f4bc:	e0bfff17 	ldw	r2,-4(fp)
 822f4c0:	10800704 	addi	r2,r2,28
 822f4c4:	1080000b 	ldhu	r2,0(r2)
 822f4c8:	10bfffcc 	andi	r2,r2,65535
 822f4cc:	1004923a 	slli	r2,r2,8
 822f4d0:	1884b03a 	or	r2,r3,r2
 822f4d4:	e0bffa0d 	sth	r2,-24(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 822f4d8:	e0bfff17 	ldw	r2,-4(fp)
 822f4dc:	10800784 	addi	r2,r2,30
 822f4e0:	1080000b 	ldhu	r2,0(r2)
 822f4e4:	10bfffcc 	andi	r2,r2,65535
 822f4e8:	1004d23a 	srli	r2,r2,8
 822f4ec:	1007883a 	mov	r3,r2
 822f4f0:	e0bfff17 	ldw	r2,-4(fp)
 822f4f4:	10800784 	addi	r2,r2,30
 822f4f8:	1080000b 	ldhu	r2,0(r2)
 822f4fc:	10bfffcc 	andi	r2,r2,65535
 822f500:	1004923a 	slli	r2,r2,8
 822f504:	1884b03a 	or	r2,r3,r2
 822f508:	e0bffa8d 	sth	r2,-22(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 822f50c:	e0bfff17 	ldw	r2,-4(fp)
 822f510:	10800043 	ldbu	r2,1(r2)
 822f514:	10803fcc 	andi	r2,r2,255
 822f518:	1080201c 	xori	r2,r2,128
 822f51c:	10bfe004 	addi	r2,r2,-128
 822f520:	10800118 	cmpnei	r2,r2,4
 822f524:	10006e26 	beq	r2,zero,822f6e0 <so_icmpdu+0x2e4>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 822f528:	e0bfff17 	ldw	r2,-4(fp)
 822f52c:	10800443 	ldbu	r2,17(r2)
 822f530:	10803fcc 	andi	r2,r2,255
 822f534:	10800198 	cmpnei	r2,r2,6
 822f538:	1000221e 	bne	r2,zero,822f5c4 <so_icmpdu+0x1c8>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 822f53c:	e13ffa8b 	ldhu	r4,-22(fp)
 822f540:	e0bffa0b 	ldhu	r2,-24(fp)
 822f544:	00c00044 	movi	r3,1
 822f548:	d8c00115 	stw	r3,4(sp)
 822f54c:	d8800015 	stw	r2,0(sp)
 822f550:	e1fff917 	ldw	r7,-28(fp)
 822f554:	200d883a 	mov	r6,r4
 822f558:	e17ff817 	ldw	r5,-32(fp)
 822f55c:	010209b4 	movhi	r4,2086
 822f560:	21389f04 	addi	r4,r4,-7556
 822f564:	82481b80 	call	82481b8 <in_pcblookup>
 822f568:	e0bffb15 	stw	r2,-20(fp)
      if (inp == 0)
 822f56c:	e0bffb17 	ldw	r2,-20(fp)
 822f570:	10005d26 	beq	r2,zero,822f6e8 <so_icmpdu+0x2ec>
         goto done;
      so = inp->inp_socket;
 822f574:	e0bffb17 	ldw	r2,-20(fp)
 822f578:	10800817 	ldw	r2,32(r2)
 822f57c:	e0bffc15 	stw	r2,-16(fp)
      if (so == 0)
 822f580:	e0bffc17 	ldw	r2,-16(fp)
 822f584:	10005a26 	beq	r2,zero,822f6f0 <so_icmpdu+0x2f4>
         goto done;
      tp = intotcpcb(inp);
 822f588:	e0bffb17 	ldw	r2,-20(fp)
 822f58c:	10800917 	ldw	r2,36(r2)
 822f590:	e0bffd15 	stw	r2,-12(fp)
      if (tp)
 822f594:	e0bffd17 	ldw	r2,-12(fp)
 822f598:	10000626 	beq	r2,zero,822f5b4 <so_icmpdu+0x1b8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 822f59c:	e0bffd17 	ldw	r2,-12(fp)
 822f5a0:	10800217 	ldw	r2,8(r2)
 822f5a4:	10800088 	cmpgei	r2,r2,2
 822f5a8:	10005326 	beq	r2,zero,822f6f8 <so_icmpdu+0x2fc>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 822f5ac:	e13ffd17 	ldw	r4,-12(fp)
 822f5b0:	823992c0 	call	823992c <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f5b4:	e0bffc17 	ldw	r2,-16(fp)
 822f5b8:	00c01bc4 	movi	r3,111
 822f5bc:	10c00615 	stw	r3,24(r2)
 822f5c0:	00005406 	br	822f714 <so_icmpdu+0x318>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 822f5c4:	e0bfff17 	ldw	r2,-4(fp)
 822f5c8:	10800443 	ldbu	r2,17(r2)
 822f5cc:	10803fcc 	andi	r2,r2,255
 822f5d0:	10800458 	cmpnei	r2,r2,17
 822f5d4:	10004a1e 	bne	r2,zero,822f700 <so_icmpdu+0x304>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f5d8:	d0a09c17 	ldw	r2,-32144(gp)
 822f5dc:	e0bff715 	stw	r2,-36(fp)
 822f5e0:	00002106 	br	822f668 <so_icmpdu+0x26c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f5e4:	e0bff717 	ldw	r2,-36(fp)
 822f5e8:	1080020b 	ldhu	r2,8(r2)
 822f5ec:	10ffffcc 	andi	r3,r2,65535
 822f5f0:	e0bffa8b 	ldhu	r2,-22(fp)
 822f5f4:	18800426 	beq	r3,r2,822f608 <so_icmpdu+0x20c>
 822f5f8:	e0bff717 	ldw	r2,-36(fp)
 822f5fc:	1080020b 	ldhu	r2,8(r2)
 822f600:	10bfffcc 	andi	r2,r2,65535
 822f604:	1000151e 	bne	r2,zero,822f65c <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
 822f608:	e0bff717 	ldw	r2,-36(fp)
 822f60c:	10c00417 	ldw	r3,16(r2)
 822f610:	e0bff817 	ldw	r2,-32(fp)
 822f614:	1008d63a 	srli	r4,r2,24
 822f618:	e0bff817 	ldw	r2,-32(fp)
 822f61c:	1004d23a 	srli	r2,r2,8
 822f620:	10bfc00c 	andi	r2,r2,65280
 822f624:	2088b03a 	or	r4,r4,r2
 822f628:	e0bff817 	ldw	r2,-32(fp)
 822f62c:	10bfc00c 	andi	r2,r2,65280
 822f630:	1004923a 	slli	r2,r2,8
 822f634:	2088b03a 	or	r4,r4,r2
 822f638:	e0bff817 	ldw	r2,-32(fp)
 822f63c:	1004963a 	slli	r2,r2,24
 822f640:	2084b03a 	or	r2,r4,r2
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f644:	1880051e 	bne	r3,r2,822f65c <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
 822f648:	e0bff717 	ldw	r2,-36(fp)
 822f64c:	1080018b 	ldhu	r2,6(r2)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
 822f650:	10ffffcc 	andi	r3,r2,65535
 822f654:	e0bffa0b 	ldhu	r2,-24(fp)
 822f658:	18800626 	beq	r3,r2,822f674 <so_icmpdu+0x278>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f65c:	e0bff717 	ldw	r2,-36(fp)
 822f660:	10800017 	ldw	r2,0(r2)
 822f664:	e0bff715 	stw	r2,-36(fp)
 822f668:	e0bff717 	ldw	r2,-36(fp)
 822f66c:	103fdd1e 	bne	r2,zero,822f5e4 <so_icmpdu+0x1e8>
 822f670:	00000106 	br	822f678 <so_icmpdu+0x27c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
 822f674:	0001883a 	nop
         }
      if (!tmp) 
 822f678:	e0bff717 	ldw	r2,-36(fp)
 822f67c:	10002226 	beq	r2,zero,822f708 <so_icmpdu+0x30c>
         goto done;
      so = (struct socket *)tmp->u_data;
 822f680:	e0bff717 	ldw	r2,-36(fp)
 822f684:	10800617 	ldw	r2,24(r2)
 822f688:	e0bffc15 	stw	r2,-16(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 822f68c:	e0bffc17 	ldw	r2,-16(fp)
 822f690:	10800983 	ldbu	r2,38(r2)
 822f694:	10803fcc 	andi	r2,r2,255
 822f698:	1080201c 	xori	r2,r2,128
 822f69c:	10bfe004 	addi	r2,r2,-128
 822f6a0:	108000a0 	cmpeqi	r2,r2,2
 822f6a4:	10001a26 	beq	r2,zero,822f710 <so_icmpdu+0x314>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f6a8:	e0bffc17 	ldw	r2,-16(fp)
 822f6ac:	00c01bc4 	movi	r3,111
 822f6b0:	10c00615 	stw	r3,24(r2)
      /* do a select() notify on socket here */
      sorwakeup(so);
 822f6b4:	e0bffc17 	ldw	r2,-16(fp)
 822f6b8:	10800a04 	addi	r2,r2,40
 822f6bc:	100b883a 	mov	r5,r2
 822f6c0:	e13ffc17 	ldw	r4,-16(fp)
 822f6c4:	8233f900 	call	8233f90 <sbwakeup>
      sowwakeup(so);
 822f6c8:	e0bffc17 	ldw	r2,-16(fp)
 822f6cc:	10801204 	addi	r2,r2,72
 822f6d0:	100b883a 	mov	r5,r2
 822f6d4:	e13ffc17 	ldw	r4,-16(fp)
 822f6d8:	8233f900 	call	8233f90 <sbwakeup>
 822f6dc:	00000d06 	br	822f714 <so_icmpdu+0x318>
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
    {
       goto done;
 822f6e0:	0001883a 	nop
 822f6e4:	00000b06 	br	822f714 <so_icmpdu+0x318>
   if (pdp->dip.ip_prot == TCPTP)
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
      if (inp == 0)
         goto done;
 822f6e8:	0001883a 	nop
 822f6ec:	00000906 	br	822f714 <so_icmpdu+0x318>
      so = inp->inp_socket;
      if (so == 0)
         goto done;
 822f6f0:	0001883a 	nop
 822f6f4:	00000706 	br	822f714 <so_icmpdu+0x318>
      tp = intotcpcb(inp);
      if (tp)
      {
         if (tp->t_state <= TCPS_LISTEN)
         {
            goto done;
 822f6f8:	0001883a 	nop
 822f6fc:	00000506 	br	822f714 <so_icmpdu+0x318>
      sorwakeup(so);
      sowwakeup(so);
   }
#endif   /* UDP_SOCKETS */
   else
      goto done;
 822f700:	0001883a 	nop
 822f704:	00000306 	br	822f714 <so_icmpdu+0x318>
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
         goto done;
 822f708:	0001883a 	nop
 822f70c:	00000106 	br	822f714 <so_icmpdu+0x318>
      so = (struct socket *)tmp->u_data;
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
         goto done;
 822f710:	0001883a 	nop
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 822f714:	01000084 	movi	r4,2
 822f718:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 822f71c:	e13ffe17 	ldw	r4,-8(fp)
 822f720:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f724:	01000084 	movi	r4,2
 822f728:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return;
 822f72c:	0001883a 	nop
}
 822f730:	e037883a 	mov	sp,fp
 822f734:	dfc00117 	ldw	ra,4(sp)
 822f738:	df000017 	ldw	fp,0(sp)
 822f73c:	dec00204 	addi	sp,sp,8
 822f740:	f800283a 	ret

0822f744 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 822f744:	defffe04 	addi	sp,sp,-8
 822f748:	dfc00115 	stw	ra,4(sp)
 822f74c:	df000015 	stw	fp,0(sp)
 822f750:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 822f754:	d0a0ad17 	ldw	r2,-32076(gp)
 822f758:	1000121e 	bne	r2,zero,822f7a4 <tcp_tick+0x60>
      return;
   in_tcptick++;
 822f75c:	d0a0ad17 	ldw	r2,-32076(gp)
 822f760:	10800044 	addi	r2,r2,1
 822f764:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 822f768:	0009883a 	mov	r4,zero
 822f76c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 822f770:	d0e0a817 	ldw	r3,-32096(gp)
 822f774:	d0a0ac17 	ldw	r2,-32080(gp)
 822f778:	18800436 	bltu	r3,r2,822f78c <tcp_tick+0x48>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 822f77c:	8239b540 	call	8239b54 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 822f780:	d0a0a817 	ldw	r2,-32096(gp)
 822f784:	10800c84 	addi	r2,r2,50
 822f788:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 822f78c:	0009883a 	mov	r4,zero
 822f790:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 822f794:	d0a0ad17 	ldw	r2,-32076(gp)
 822f798:	10bfffc4 	addi	r2,r2,-1
 822f79c:	d0a0ad15 	stw	r2,-32076(gp)
 822f7a0:	00000106 	br	822f7a8 <tcp_tick+0x64>
void
tcp_tick()
{
   /* guard against re-entry */
   if (in_tcptick)
      return;
 822f7a4:	0001883a 	nop
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);

   in_tcptick--;
}
 822f7a8:	e037883a 	mov	sp,fp
 822f7ac:	dfc00117 	ldw	ra,4(sp)
 822f7b0:	df000017 	ldw	fp,0(sp)
 822f7b4:	dec00204 	addi	sp,sp,8
 822f7b8:	f800283a 	ret

0822f7bc <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 822f7bc:	defffd04 	addi	sp,sp,-12
 822f7c0:	df000215 	stw	fp,8(sp)
 822f7c4:	df000204 	addi	fp,sp,8
 822f7c8:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822f7cc:	d0a0cf17 	ldw	r2,-31940(gp)
 822f7d0:	e0bffe15 	stw	r2,-8(fp)
 822f7d4:	00000906 	br	822f7fc <rawip_lookup+0x40>
      if (tmp->ipr_data == (void*)so)
 822f7d8:	e0bffe17 	ldw	r2,-8(fp)
 822f7dc:	10c00417 	ldw	r3,16(r2)
 822f7e0:	e0bfff17 	ldw	r2,-4(fp)
 822f7e4:	1880021e 	bne	r3,r2,822f7f0 <rawip_lookup+0x34>
      return (tmp);
 822f7e8:	e0bffe17 	ldw	r2,-8(fp)
 822f7ec:	00000606 	br	822f808 <rawip_lookup+0x4c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822f7f0:	e0bffe17 	ldw	r2,-8(fp)
 822f7f4:	10800017 	ldw	r2,0(r2)
 822f7f8:	e0bffe15 	stw	r2,-8(fp)
 822f7fc:	e0bffe17 	ldw	r2,-8(fp)
 822f800:	103ff51e 	bne	r2,zero,822f7d8 <rawip_lookup+0x1c>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 822f804:	0005883a 	mov	r2,zero
}
 822f808:	e037883a 	mov	sp,fp
 822f80c:	df000017 	ldw	fp,0(sp)
 822f810:	dec00104 	addi	sp,sp,4
 822f814:	f800283a 	ret

0822f818 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 822f818:	defff504 	addi	sp,sp,-44
 822f81c:	dfc00a15 	stw	ra,40(sp)
 822f820:	df000915 	stw	fp,36(sp)
 822f824:	df000904 	addi	fp,sp,36
 822f828:	e13ffe15 	stw	r4,-8(fp)
 822f82c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 822f830:	e0bfff17 	ldw	r2,-4(fp)
 822f834:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 822f838:	0009883a 	mov	r4,zero
 822f83c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 822f840:	e0bff717 	ldw	r2,-36(fp)
 822f844:	10c00a17 	ldw	r3,40(r2)
 822f848:	e0bffe17 	ldw	r2,-8(fp)
 822f84c:	10800417 	ldw	r2,16(r2)
 822f850:	1887883a 	add	r3,r3,r2
 822f854:	e0bff717 	ldw	r2,-36(fp)
 822f858:	10800b17 	ldw	r2,44(r2)
 822f85c:	18800436 	bltu	r3,r2,822f870 <rawip_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f860:	0009883a 	mov	r4,zero
 822f864:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f868:	00801a44 	movi	r2,105
 822f86c:	00005706 	br	822f9cc <rawip_soinput+0x1b4>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 822f870:	000b883a 	mov	r5,zero
 822f874:	01000044 	movi	r4,1
 822f878:	822e0f40 	call	822e0f4 <m_getnbuf>
 822f87c:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 822f880:	e0bff817 	ldw	r2,-32(fp)
 822f884:	1000041e 	bne	r2,zero,822f898 <rawip_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f888:	0009883a 	mov	r4,zero
 822f88c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f890:	00801a44 	movi	r2,105
 822f894:	00004d06 	br	822f9cc <rawip_soinput+0x1b4>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 822f898:	e0bff817 	ldw	r2,-32(fp)
 822f89c:	e0fffe17 	ldw	r3,-8(fp)
 822f8a0:	10c00115 	stw	r3,4(r2)
   m_in->m_base = pkt->nb_buff;
 822f8a4:	e0bffe17 	ldw	r2,-8(fp)
 822f8a8:	10c00117 	ldw	r3,4(r2)
 822f8ac:	e0bff817 	ldw	r2,-32(fp)
 822f8b0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 822f8b4:	e0bffe17 	ldw	r2,-8(fp)
 822f8b8:	10c00217 	ldw	r3,8(r2)
 822f8bc:	e0bff817 	ldw	r2,-32(fp)
 822f8c0:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 822f8c4:	e0bffe17 	ldw	r2,-8(fp)
 822f8c8:	10c00317 	ldw	r3,12(r2)
 822f8cc:	e0bff817 	ldw	r2,-32(fp)
 822f8d0:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822f8d4:	e0bffe17 	ldw	r2,-8(fp)
 822f8d8:	10c00417 	ldw	r3,16(r2)
 822f8dc:	e0bff817 	ldw	r2,-32(fp)
 822f8e0:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 822f8e4:	e0bff717 	ldw	r2,-36(fp)
 822f8e8:	10800417 	ldw	r2,16(r2)
 822f8ec:	1088000c 	andi	r2,r2,8192
 822f8f0:	1000141e 	bne	r2,zero,822f944 <rawip_soinput+0x12c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 822f8f4:	e0bffe17 	ldw	r2,-8(fp)
 822f8f8:	10800317 	ldw	r2,12(r2)
 822f8fc:	10800003 	ldbu	r2,0(r2)
 822f900:	10803fcc 	andi	r2,r2,255
 822f904:	108003cc 	andi	r2,r2,15
 822f908:	1085883a 	add	r2,r2,r2
 822f90c:	1085883a 	add	r2,r2,r2
   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
   {
      unsigned int ihl = 
 822f910:	e0bff915 	stw	r2,-28(fp)
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
      m_in->m_data += ihl;
 822f914:	e0bff817 	ldw	r2,-32(fp)
 822f918:	10c00317 	ldw	r3,12(r2)
 822f91c:	e0bff917 	ldw	r2,-28(fp)
 822f920:	1887883a 	add	r3,r3,r2
 822f924:	e0bff817 	ldw	r2,-32(fp)
 822f928:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 822f92c:	e0bff817 	ldw	r2,-32(fp)
 822f930:	10c00217 	ldw	r3,8(r2)
 822f934:	e0bff917 	ldw	r2,-28(fp)
 822f938:	1887c83a 	sub	r3,r3,r2
 822f93c:	e0bff817 	ldw	r2,-32(fp)
 822f940:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 822f944:	e0bffe17 	ldw	r2,-8(fp)
 822f948:	10800717 	ldw	r2,28(r2)
 822f94c:	e0bffb15 	stw	r2,-20(fp)
   sin.sin_port = 0;
 822f950:	e03ffa8d 	sth	zero,-22(fp)
   sin.sin_family = AF_INET;
 822f954:	00800084 	movi	r2,2
 822f958:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 822f95c:	e0bff717 	ldw	r2,-36(fp)
 822f960:	10800a04 	addi	r2,r2,40
 822f964:	e0fffa04 	addi	r3,fp,-24
 822f968:	e1bff817 	ldw	r6,-32(fp)
 822f96c:	180b883a 	mov	r5,r3
 822f970:	1009883a 	mov	r4,r2
 822f974:	82342b80 	call	82342b8 <sbappendaddr>
 822f978:	1000081e 	bne	r2,zero,822f99c <rawip_soinput+0x184>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 822f97c:	e0bff817 	ldw	r2,-32(fp)
 822f980:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 822f984:	e13ff817 	ldw	r4,-32(fp)
 822f988:	822e27c0 	call	822e27c <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f98c:	0009883a 	mov	r4,zero
 822f990:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f994:	00801a44 	movi	r2,105
 822f998:	00000c06 	br	822f9cc <rawip_soinput+0x1b4>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 822f99c:	e0bff717 	ldw	r2,-36(fp)
 822f9a0:	10800a04 	addi	r2,r2,40
 822f9a4:	1009883a 	mov	r4,r2
 822f9a8:	82293f40 	call	82293f4 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 822f9ac:	e0bff717 	ldw	r2,-36(fp)
 822f9b0:	10800a04 	addi	r2,r2,40
 822f9b4:	100b883a 	mov	r5,r2
 822f9b8:	e13ff717 	ldw	r4,-36(fp)
 822f9bc:	8233f900 	call	8233f90 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 822f9c0:	0009883a 	mov	r4,zero
 822f9c4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return 0;
 822f9c8:	0005883a 	mov	r2,zero
}
 822f9cc:	e037883a 	mov	sp,fp
 822f9d0:	dfc00117 	ldw	ra,4(sp)
 822f9d4:	df000017 	ldw	fp,0(sp)
 822f9d8:	dec00204 	addi	sp,sp,8
 822f9dc:	f800283a 	ret

0822f9e0 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 822f9e0:	deffef04 	addi	sp,sp,-68
 822f9e4:	dfc01015 	stw	ra,64(sp)
 822f9e8:	df000f15 	stw	fp,60(sp)
 822f9ec:	dc000e15 	stw	r16,56(sp)
 822f9f0:	df000f04 	addi	fp,sp,60
 822f9f4:	e13ffc15 	stw	r4,-16(fp)
 822f9f8:	e17ffd15 	stw	r5,-12(fp)
 822f9fc:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 822fa00:	e0bffc17 	ldw	r2,-16(fp)
 822fa04:	10800717 	ldw	r2,28(r2)
 822fa08:	e0bff615 	stw	r2,-40(fp)

   switch (req) 
 822fa0c:	e0bff617 	ldw	r2,-40(fp)
 822fa10:	10800468 	cmpgeui	r2,r2,17
 822fa14:	1001be1e 	bne	r2,zero,8230110 <rawip_usrreq+0x730>
 822fa18:	e0bff617 	ldw	r2,-40(fp)
 822fa1c:	100690ba 	slli	r3,r2,2
 822fa20:	008208f4 	movhi	r2,2083
 822fa24:	10be8d04 	addi	r2,r2,-1484
 822fa28:	1885883a 	add	r2,r3,r2
 822fa2c:	10800017 	ldw	r2,0(r2)
 822fa30:	1000683a 	jmp	r2
 822fa34:	0822fa78 	rdprs	zero,at,-29719
 822fa38:	0822fb00 	call	822fb0 <OSCtxSw_SWITCH_PC+0x822f70>
 822fa3c:	0822fb3c 	xorhi	zero,at,35820
 822fa40:	08230110 	cmplti	zero,at,-29692
 822fa44:	0822fb3c 	xorhi	zero,at,35820
 822fa48:	08230110 	cmplti	zero,at,-29692
 822fa4c:	08230104 	addi	zero,at,-29692
 822fa50:	08230110 	cmplti	zero,at,-29692
 822fa54:	08230104 	addi	zero,at,-29692
 822fa58:	0822fcc8 	cmpgei	zero,at,-29709
 822fa5c:	08230110 	cmplti	zero,at,-29692
 822fa60:	08230110 	cmplti	zero,at,-29692
 822fa64:	08230110 	cmplti	zero,at,-29692
 822fa68:	08230110 	cmplti	zero,at,-29692
 822fa6c:	08230110 	cmplti	zero,at,-29692
 822fa70:	08230070 	cmpltui	zero,at,35841
 822fa74:	08230070 	cmpltui	zero,at,35841
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 822fa78:	e0bffc17 	ldw	r2,-16(fp)
 822fa7c:	10800417 	ldw	r2,16(r2)
 822fa80:	1088000c 	andi	r2,r2,8192
 822fa84:	1009883a 	mov	r4,r2
 822fa88:	8243ee00 	call	8243ee0 <ip_raw_maxalloc>

   switch (req) 
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 822fa8c:	1007883a 	mov	r3,r2
 822fa90:	e0bffc17 	ldw	r2,-16(fp)
 822fa94:	10c01315 	stw	r3,76(r2)
 822fa98:	e0bffc17 	ldw	r2,-16(fp)
 822fa9c:	10c01317 	ldw	r3,76(r2)
 822faa0:	e0bffc17 	ldw	r2,-16(fp)
 822faa4:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 822faa8:	e0bffe17 	ldw	r2,-8(fp)
 822faac:	e0bff705 	stb	r2,-36(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fab0:	0009883a 	mov	r4,zero
 822fab4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 822fab8:	e0fff703 	ldbu	r3,-36(fp)
 822fabc:	e0bffc17 	ldw	r2,-16(fp)
 822fac0:	d8800015 	stw	r2,0(sp)
 822fac4:	01c208f4 	movhi	r7,2083
 822fac8:	39fe0604 	addi	r7,r7,-2024
 822facc:	000d883a 	mov	r6,zero
 822fad0:	000b883a 	mov	r5,zero
 822fad4:	1809883a 	mov	r4,r3
 822fad8:	8243a2c0 	call	8243a2c <ip_raw_open>
 822fadc:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 822fae0:	0009883a 	mov	r4,zero
 822fae4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      if (!ep)
 822fae8:	e0bff817 	ldw	r2,-32(fp)
 822faec:	1000021e 	bne	r2,zero,822faf8 <rawip_usrreq+0x118>
         return(EINVAL);
 822faf0:	00800584 	movi	r2,22
 822faf4:	00018706 	br	8230114 <rawip_usrreq+0x734>
      return 0;
 822faf8:	0005883a 	mov	r2,zero
 822fafc:	00018506 	br	8230114 <rawip_usrreq+0x734>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 822fb00:	e13ffc17 	ldw	r4,-16(fp)
 822fb04:	822f7bc0 	call	822f7bc <rawip_lookup>
 822fb08:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fb0c:	e0bff817 	ldw	r2,-32(fp)
 822fb10:	1000021e 	bne	r2,zero,822fb1c <rawip_usrreq+0x13c>
         return(EINVAL);
 822fb14:	00800584 	movi	r2,22
 822fb18:	00017e06 	br	8230114 <rawip_usrreq+0x734>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fb1c:	0009883a 	mov	r4,zero
 822fb20:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 822fb24:	e13ff817 	ldw	r4,-32(fp)
 822fb28:	8243b040 	call	8243b04 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 822fb2c:	0009883a 	mov	r4,zero
 822fb30:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      return 0;
 822fb34:	0005883a 	mov	r2,zero
 822fb38:	00017606 	br	8230114 <rawip_usrreq+0x734>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 822fb3c:	e0bffe17 	ldw	r2,-8(fp)
 822fb40:	1000021e 	bne	r2,zero,822fb4c <rawip_usrreq+0x16c>
         return(EINVAL);
 822fb44:	00800584 	movi	r2,22
 822fb48:	00017206 	br	8230114 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 822fb4c:	e0bffe17 	ldw	r2,-8(fp)
 822fb50:	10800317 	ldw	r2,12(r2)
 822fb54:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 822fb58:	e0bff917 	ldw	r2,-28(fp)
 822fb5c:	1000021e 	bne	r2,zero,822fb68 <rawip_usrreq+0x188>
         return(EINVAL);
 822fb60:	00800584 	movi	r2,22
 822fb64:	00016b06 	br	8230114 <rawip_usrreq+0x734>
      if (nam->m_len != sizeof (*sin))
 822fb68:	e0bffe17 	ldw	r2,-8(fp)
 822fb6c:	10800217 	ldw	r2,8(r2)
 822fb70:	10800420 	cmpeqi	r2,r2,16
 822fb74:	1000021e 	bne	r2,zero,822fb80 <rawip_usrreq+0x1a0>
         return(EINVAL);
 822fb78:	00800584 	movi	r2,22
 822fb7c:	00016506 	br	8230114 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 822fb80:	e13ffc17 	ldw	r4,-16(fp)
 822fb84:	822f7bc0 	call	822f7bc <rawip_lookup>
 822fb88:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fb8c:	e0bff817 	ldw	r2,-32(fp)
 822fb90:	1000021e 	bne	r2,zero,822fb9c <rawip_usrreq+0x1bc>
         return(EINVAL);
 822fb94:	00800584 	movi	r2,22
 822fb98:	00015e06 	br	8230114 <rawip_usrreq+0x734>
      if (req == PRU_BIND)
 822fb9c:	e0bff617 	ldw	r2,-40(fp)
 822fba0:	10800098 	cmpnei	r2,r2,2
 822fba4:	1000201e 	bne	r2,zero,822fc28 <rawip_usrreq+0x248>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fba8:	e0bff917 	ldw	r2,-28(fp)
 822fbac:	10800117 	ldw	r2,4(r2)
 822fbb0:	1000021e 	bne	r2,zero,822fbbc <rawip_usrreq+0x1dc>
         {
            lhost = 0L;
 822fbb4:	e03ff415 	stw	zero,-48(fp)
 822fbb8:	00001706 	br	822fc18 <rawip_usrreq+0x238>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 822fbbc:	e0bff917 	ldw	r2,-28(fp)
 822fbc0:	10800117 	ldw	r2,4(r2)
 822fbc4:	e0bff415 	stw	r2,-48(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fbc8:	008209b4 	movhi	r2,2086
 822fbcc:	10b97b04 	addi	r2,r2,-6676
 822fbd0:	10800017 	ldw	r2,0(r2)
 822fbd4:	e0bff515 	stw	r2,-44(fp)
 822fbd8:	00000706 	br	822fbf8 <rawip_usrreq+0x218>
               if (ifp->n_ipaddr == lhost)
 822fbdc:	e0bff517 	ldw	r2,-44(fp)
 822fbe0:	10c00a17 	ldw	r3,40(r2)
 822fbe4:	e0bff417 	ldw	r2,-48(fp)
 822fbe8:	18800626 	beq	r3,r2,822fc04 <rawip_usrreq+0x224>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fbec:	e0bff517 	ldw	r2,-44(fp)
 822fbf0:	10800017 	ldw	r2,0(r2)
 822fbf4:	e0bff515 	stw	r2,-44(fp)
 822fbf8:	e0bff517 	ldw	r2,-44(fp)
 822fbfc:	103ff71e 	bne	r2,zero,822fbdc <rawip_usrreq+0x1fc>
 822fc00:	00000106 	br	822fc08 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
 822fc04:	0001883a 	nop
            if (ifp == NULL)
 822fc08:	e0bff517 	ldw	r2,-44(fp)
 822fc0c:	1000021e 	bne	r2,zero,822fc18 <rawip_usrreq+0x238>
               return(EADDRNOTAVAIL);
 822fc10:	00801f44 	movi	r2,125
 822fc14:	00013f06 	br	8230114 <rawip_usrreq+0x734>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 822fc18:	e0bff817 	ldw	r2,-32(fp)
 822fc1c:	e0fff417 	ldw	r3,-48(fp)
 822fc20:	10c00115 	stw	r3,4(r2)
 822fc24:	00002606 	br	822fcc0 <rawip_usrreq+0x2e0>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fc28:	e0bff917 	ldw	r2,-28(fp)
 822fc2c:	10800117 	ldw	r2,4(r2)
 822fc30:	1000021e 	bne	r2,zero,822fc3c <rawip_usrreq+0x25c>
            fhost = 0L;
 822fc34:	e03ff315 	stw	zero,-52(fp)
 822fc38:	00000306 	br	822fc48 <rawip_usrreq+0x268>
         else
            fhost = sin->sin_addr.s_addr;
 822fc3c:	e0bff917 	ldw	r2,-28(fp)
 822fc40:	10800117 	ldw	r2,4(r2)
 822fc44:	e0bff315 	stw	r2,-52(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 822fc48:	e0bff817 	ldw	r2,-32(fp)
 822fc4c:	e0fff317 	ldw	r3,-52(fp)
 822fc50:	10c00215 	stw	r3,8(r2)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 822fc54:	e0bff317 	ldw	r2,-52(fp)
 822fc58:	10000e26 	beq	r2,zero,822fc94 <rawip_usrreq+0x2b4>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 822fc5c:	e0bffc17 	ldw	r2,-16(fp)
 822fc60:	10c0088b 	ldhu	r3,34(r2)
 822fc64:	00bffcc4 	movi	r2,-13
 822fc68:	1884703a 	and	r2,r3,r2
 822fc6c:	1007883a 	mov	r3,r2
 822fc70:	e0bffc17 	ldw	r2,-16(fp)
 822fc74:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 822fc78:	e0bffc17 	ldw	r2,-16(fp)
 822fc7c:	1080088b 	ldhu	r2,34(r2)
 822fc80:	10800094 	ori	r2,r2,2
 822fc84:	1007883a 	mov	r3,r2
 822fc88:	e0bffc17 	ldw	r2,-16(fp)
 822fc8c:	10c0088d 	sth	r3,34(r2)
 822fc90:	00000706 	br	822fcb0 <rawip_usrreq+0x2d0>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 822fc94:	e0bffc17 	ldw	r2,-16(fp)
 822fc98:	10c0088b 	ldhu	r3,34(r2)
 822fc9c:	00bfff44 	movi	r2,-3
 822fca0:	1884703a 	and	r2,r3,r2
 822fca4:	1007883a 	mov	r3,r2
 822fca8:	e0bffc17 	ldw	r2,-16(fp)
 822fcac:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 822fcb0:	e0bffc17 	ldw	r2,-16(fp)
 822fcb4:	10800a04 	addi	r2,r2,40
 822fcb8:	1009883a 	mov	r4,r2
 822fcbc:	82346740 	call	8234674 <sbflush>
      }
      return 0;
 822fcc0:	0005883a 	mov	r2,zero
 822fcc4:	00011306 	br	8230114 <rawip_usrreq+0x734>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 822fcc8:	e0bffd17 	ldw	r2,-12(fp)
 822fccc:	1000021e 	bne	r2,zero,822fcd8 <rawip_usrreq+0x2f8>
         return(EINVAL);
 822fcd0:	00800584 	movi	r2,22
 822fcd4:	00010f06 	br	8230114 <rawip_usrreq+0x734>

      ep = rawip_lookup(so);
 822fcd8:	e13ffc17 	ldw	r4,-16(fp)
 822fcdc:	822f7bc0 	call	822f7bc <rawip_lookup>
 822fce0:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fce4:	e0bff817 	ldw	r2,-32(fp)
 822fce8:	1000041e 	bne	r2,zero,822fcfc <rawip_usrreq+0x31c>
      {
         m_free(m);
 822fcec:	e13ffd17 	ldw	r4,-12(fp)
 822fcf0:	822e27c0 	call	822e27c <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 822fcf4:	00801bc4 	movi	r2,111
 822fcf8:	00010606 	br	8230114 <rawip_usrreq+0x734>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 822fcfc:	e0bffe17 	ldw	r2,-8(fp)
 822fd00:	10000b1e 	bne	r2,zero,822fd30 <rawip_usrreq+0x350>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 822fd04:	e0bffc17 	ldw	r2,-16(fp)
 822fd08:	1080088b 	ldhu	r2,34(r2)
 822fd0c:	10bfffcc 	andi	r2,r2,65535
 822fd10:	1080008c 	andi	r2,r2,2
 822fd14:	1000021e 	bne	r2,zero,822fd20 <rawip_usrreq+0x340>
            return (ENOTCONN);
 822fd18:	00802004 	movi	r2,128
 822fd1c:	0000fd06 	br	8230114 <rawip_usrreq+0x734>
         fhost = ep->ipr_faddr;
 822fd20:	e0bff817 	ldw	r2,-32(fp)
 822fd24:	10800217 	ldw	r2,8(r2)
 822fd28:	e0bff315 	stw	r2,-52(fp)
 822fd2c:	00001406 	br	822fd80 <rawip_usrreq+0x3a0>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 822fd30:	e0bffc17 	ldw	r2,-16(fp)
 822fd34:	1080088b 	ldhu	r2,34(r2)
 822fd38:	10bfffcc 	andi	r2,r2,65535
 822fd3c:	1080008c 	andi	r2,r2,2
 822fd40:	10000226 	beq	r2,zero,822fd4c <rawip_usrreq+0x36c>
            return (EISCONN);
 822fd44:	00801fc4 	movi	r2,127
 822fd48:	0000f206 	br	8230114 <rawip_usrreq+0x734>
         if (nam->m_len != sizeof (*sin))
 822fd4c:	e0bffe17 	ldw	r2,-8(fp)
 822fd50:	10800217 	ldw	r2,8(r2)
 822fd54:	10800420 	cmpeqi	r2,r2,16
 822fd58:	1000031e 	bne	r2,zero,822fd68 <rawip_usrreq+0x388>
         {
            dtrap();
 822fd5c:	822d2e00 	call	822d2e0 <dtrap>
            return (EINVAL);
 822fd60:	00800584 	movi	r2,22
 822fd64:	0000eb06 	br	8230114 <rawip_usrreq+0x734>
         }
         sin = mtod(nam, struct sockaddr_in *);
 822fd68:	e0bffe17 	ldw	r2,-8(fp)
 822fd6c:	10800317 	ldw	r2,12(r2)
 822fd70:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 822fd74:	e0bff917 	ldw	r2,-28(fp)
 822fd78:	10800117 	ldw	r2,4(r2)
 822fd7c:	e0bff315 	stw	r2,-52(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 822fd80:	e0bffd17 	ldw	r2,-12(fp)
 822fd84:	14000217 	ldw	r16,8(r2)
 822fd88:	e0bffc17 	ldw	r2,-16(fp)
 822fd8c:	10800417 	ldw	r2,16(r2)
 822fd90:	1088000c 	andi	r2,r2,8192
 822fd94:	1009883a 	mov	r4,r2
 822fd98:	8243ee00 	call	8243ee0 <ip_raw_maxalloc>
 822fd9c:	1400032e 	bgeu	r2,r16,822fdac <rawip_usrreq+0x3cc>
      {
         dtrap(); /* should never happen */
 822fda0:	822d2e00 	call	822d2e0 <dtrap>
         return EMSGSIZE;  /* try to recover */
 822fda4:	00801e84 	movi	r2,122
 822fda8:	0000da06 	br	8230114 <rawip_usrreq+0x734>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 822fdac:	e0bffd17 	ldw	r2,-12(fp)
 822fdb0:	10800217 	ldw	r2,8(r2)
 822fdb4:	1007883a 	mov	r3,r2
 822fdb8:	e0bffc17 	ldw	r2,-16(fp)
 822fdbc:	10800417 	ldw	r2,16(r2)
 822fdc0:	1088000c 	andi	r2,r2,8192
 822fdc4:	100b883a 	mov	r5,r2
 822fdc8:	1809883a 	mov	r4,r3
 822fdcc:	8243de40 	call	8243de4 <ip_raw_alloc>
 822fdd0:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 822fdd4:	e0bffa17 	ldw	r2,-24(fp)
 822fdd8:	1000041e 	bne	r2,zero,822fdec <rawip_usrreq+0x40c>
      {
         m_free(m);
 822fddc:	e13ffd17 	ldw	r4,-12(fp)
 822fde0:	822e27c0 	call	822e27c <m_free>
         return ENOBUFS;   /* report buffer shortages */
 822fde4:	00801a44 	movi	r2,105
 822fde8:	0000ca06 	br	8230114 <rawip_usrreq+0x734>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 822fdec:	e0bffa17 	ldw	r2,-24(fp)
 822fdf0:	10c00317 	ldw	r3,12(r2)
 822fdf4:	e0bffd17 	ldw	r2,-12(fp)
 822fdf8:	11000317 	ldw	r4,12(r2)
 822fdfc:	e0bffd17 	ldw	r2,-12(fp)
 822fe00:	10800217 	ldw	r2,8(r2)
 822fe04:	100d883a 	mov	r6,r2
 822fe08:	200b883a 	mov	r5,r4
 822fe0c:	1809883a 	mov	r4,r3
 822fe10:	8202c5c0 	call	8202c5c <memcpy>
      pkt->nb_plen = m->m_len;
 822fe14:	e0bffd17 	ldw	r2,-12(fp)
 822fe18:	10c00217 	ldw	r3,8(r2)
 822fe1c:	e0bffa17 	ldw	r2,-24(fp)
 822fe20:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 822fe24:	e13ffd17 	ldw	r4,-12(fp)
 822fe28:	822e27c0 	call	822e27c <m_free>
      pkt->fhost = fhost;
 822fe2c:	e0bffa17 	ldw	r2,-24(fp)
 822fe30:	e0fff317 	ldw	r3,-52(fp)
 822fe34:	10c00715 	stw	r3,28(r2)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 822fe38:	e0bff317 	ldw	r2,-52(fp)
 822fe3c:	10bfffd8 	cmpnei	r2,r2,-1
 822fe40:	10004a1e 	bne	r2,zero,822ff6c <rawip_usrreq+0x58c>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 822fe44:	e0bff817 	ldw	r2,-32(fp)
 822fe48:	10800117 	ldw	r2,4(r2)
 822fe4c:	10001026 	beq	r2,zero,822fe90 <rawip_usrreq+0x4b0>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fe50:	008209b4 	movhi	r2,2086
 822fe54:	10b97b04 	addi	r2,r2,-6676
 822fe58:	10800017 	ldw	r2,0(r2)
 822fe5c:	e0bff515 	stw	r2,-44(fp)
 822fe60:	00000806 	br	822fe84 <rawip_usrreq+0x4a4>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 822fe64:	e0bff517 	ldw	r2,-44(fp)
 822fe68:	10c00a17 	ldw	r3,40(r2)
 822fe6c:	e0bff817 	ldw	r2,-32(fp)
 822fe70:	10800117 	ldw	r2,4(r2)
 822fe74:	18801d26 	beq	r3,r2,822feec <rawip_usrreq+0x50c>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fe78:	e0bff517 	ldw	r2,-44(fp)
 822fe7c:	10800017 	ldw	r2,0(r2)
 822fe80:	e0bff515 	stw	r2,-44(fp)
 822fe84:	e0bff517 	ldw	r2,-44(fp)
 822fe88:	103ff61e 	bne	r2,zero,822fe64 <rawip_usrreq+0x484>
 822fe8c:	00001a06 	br	822fef8 <rawip_usrreq+0x518>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fe90:	008209b4 	movhi	r2,2086
 822fe94:	10b97b04 	addi	r2,r2,-6676
 822fe98:	10800017 	ldw	r2,0(r2)
 822fe9c:	e0bff515 	stw	r2,-44(fp)
 822fea0:	00000f06 	br	822fee0 <rawip_usrreq+0x500>
               if ((ifp->n_flags & NF_BCAST) &&
 822fea4:	e0bff517 	ldw	r2,-44(fp)
 822fea8:	10802a17 	ldw	r2,168(r2)
 822feac:	1080004c 	andi	r2,r2,1
 822feb0:	10000826 	beq	r2,zero,822fed4 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822feb4:	e0bff517 	ldw	r2,-44(fp)
 822feb8:	10802717 	ldw	r2,156(r2)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
 822febc:	10000526 	beq	r2,zero,822fed4 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822fec0:	e0bff517 	ldw	r2,-44(fp)
 822fec4:	10802717 	ldw	r2,156(r2)
 822fec8:	10800617 	ldw	r2,24(r2)
 822fecc:	10800058 	cmpnei	r2,r2,1
 822fed0:	10000826 	beq	r2,zero,822fef4 <rawip_usrreq+0x514>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fed4:	e0bff517 	ldw	r2,-44(fp)
 822fed8:	10800017 	ldw	r2,0(r2)
 822fedc:	e0bff515 	stw	r2,-44(fp)
 822fee0:	e0bff517 	ldw	r2,-44(fp)
 822fee4:	103fef1e 	bne	r2,zero,822fea4 <rawip_usrreq+0x4c4>
 822fee8:	00000306 	br	822fef8 <rawip_usrreq+0x518>
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
 822feec:	0001883a 	nop
 822fef0:	00000106 	br	822fef8 <rawip_usrreq+0x518>
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 822fef4:	0001883a 	nop
         }
         if (ifp == NULL)
 822fef8:	e0bff517 	ldw	r2,-44(fp)
 822fefc:	1000181e 	bne	r2,zero,822ff60 <rawip_usrreq+0x580>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822ff00:	008209b4 	movhi	r2,2086
 822ff04:	10b97b04 	addi	r2,r2,-6676
 822ff08:	10800017 	ldw	r2,0(r2)
 822ff0c:	e0bff515 	stw	r2,-44(fp)
 822ff10:	00000b06 	br	822ff40 <rawip_usrreq+0x560>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822ff14:	e0bff517 	ldw	r2,-44(fp)
 822ff18:	10802717 	ldw	r2,156(r2)
 822ff1c:	10000526 	beq	r2,zero,822ff34 <rawip_usrreq+0x554>
 822ff20:	e0bff517 	ldw	r2,-44(fp)
 822ff24:	10802717 	ldw	r2,156(r2)
 822ff28:	10800617 	ldw	r2,24(r2)
 822ff2c:	10800058 	cmpnei	r2,r2,1
 822ff30:	10000626 	beq	r2,zero,822ff4c <rawip_usrreq+0x56c>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822ff34:	e0bff517 	ldw	r2,-44(fp)
 822ff38:	10800017 	ldw	r2,0(r2)
 822ff3c:	e0bff515 	stw	r2,-44(fp)
 822ff40:	e0bff517 	ldw	r2,-44(fp)
 822ff44:	103ff31e 	bne	r2,zero,822ff14 <rawip_usrreq+0x534>
 822ff48:	00000106 	br	822ff50 <rawip_usrreq+0x570>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 822ff4c:	0001883a 	nop
            if (ifp == NULL)
 822ff50:	e0bff517 	ldw	r2,-44(fp)
 822ff54:	1000021e 	bne	r2,zero,822ff60 <rawip_usrreq+0x580>
               return(EADDRNOTAVAIL);
 822ff58:	00801f44 	movi	r2,125
 822ff5c:	00006d06 	br	8230114 <rawip_usrreq+0x734>
         }
         pkt->net = ifp;
 822ff60:	e0bffa17 	ldw	r2,-24(fp)
 822ff64:	e0fff517 	ldw	r3,-44(fp)
 822ff68:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 822ff6c:	e0bffc17 	ldw	r2,-16(fp)
 822ff70:	10800317 	ldw	r2,12(r2)
 822ff74:	10000426 	beq	r2,zero,822ff88 <rawip_usrreq+0x5a8>
         pkt->imo = so->inp_moptions;
 822ff78:	e0bffc17 	ldw	r2,-16(fp)
 822ff7c:	10c00317 	ldw	r3,12(r2)
 822ff80:	e0bffa17 	ldw	r2,-24(fp)
 822ff84:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 822ff88:	e0bffc17 	ldw	r2,-16(fp)
 822ff8c:	10800417 	ldw	r2,16(r2)
 822ff90:	1088000c 	andi	r2,r2,8192
 822ff94:	10000826 	beq	r2,zero,822ffb8 <rawip_usrreq+0x5d8>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 822ff98:	0009883a 	mov	r4,zero
 822ff9c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 822ffa0:	e13ffa17 	ldw	r4,-24(fp)
 822ffa4:	823fc3c0 	call	823fc3c <ip_raw_write>
 822ffa8:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 822ffac:	0009883a 	mov	r4,zero
 822ffb0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
 822ffb4:	00002806 	br	8230058 <rawip_usrreq+0x678>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 822ffb8:	e0bffa17 	ldw	r2,-24(fp)
 822ffbc:	10800317 	ldw	r2,12(r2)
 822ffc0:	10bffb04 	addi	r2,r2,-20
 822ffc4:	e0bffb15 	stw	r2,-20(fp)
         if (ep->ipr_laddr)
 822ffc8:	e0bff817 	ldw	r2,-32(fp)
 822ffcc:	10800117 	ldw	r2,4(r2)
 822ffd0:	10000526 	beq	r2,zero,822ffe8 <rawip_usrreq+0x608>
            pip->ip_src = ep->ipr_laddr;
 822ffd4:	e0bff817 	ldw	r2,-32(fp)
 822ffd8:	10c00117 	ldw	r3,4(r2)
 822ffdc:	e0bffb17 	ldw	r2,-20(fp)
 822ffe0:	10c00315 	stw	r3,12(r2)
 822ffe4:	00000e06 	br	8230020 <rawip_usrreq+0x640>
         else
         {
            if (fhost == 0xffffffff)
 822ffe8:	e0bff317 	ldw	r2,-52(fp)
 822ffec:	10bfffd8 	cmpnei	r2,r2,-1
 822fff0:	1000061e 	bne	r2,zero,823000c <rawip_usrreq+0x62c>
               pip->ip_src = pkt->net->n_ipaddr;
 822fff4:	e0bffa17 	ldw	r2,-24(fp)
 822fff8:	10800617 	ldw	r2,24(r2)
 822fffc:	10c00a17 	ldw	r3,40(r2)
 8230000:	e0bffb17 	ldw	r2,-20(fp)
 8230004:	10c00315 	stw	r3,12(r2)
 8230008:	00000506 	br	8230020 <rawip_usrreq+0x640>
            else
               pip->ip_src = ip_mymach(fhost);
 823000c:	e13ff317 	ldw	r4,-52(fp)
 8230010:	82406e80 	call	82406e8 <ip_mymach>
 8230014:	1007883a 	mov	r3,r2
 8230018:	e0bffb17 	ldw	r2,-20(fp)
 823001c:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 8230020:	e0bffb17 	ldw	r2,-20(fp)
 8230024:	e0fff317 	ldw	r3,-52(fp)
 8230028:	10c00415 	stw	r3,16(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 823002c:	0009883a 	mov	r4,zero
 8230030:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 8230034:	e0bff817 	ldw	r2,-32(fp)
 8230038:	10800503 	ldbu	r2,20(r2)
 823003c:	10803fcc 	andi	r2,r2,255
 8230040:	e17ffa17 	ldw	r5,-24(fp)
 8230044:	1009883a 	mov	r4,r2
 8230048:	823f6980 	call	823f698 <ip_write>
 823004c:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8230050:	0009883a 	mov	r4,zero
 8230054:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 8230058:	e0bff217 	ldw	r2,-56(fp)
 823005c:	1000020e 	bge	r2,zero,8230068 <rawip_usrreq+0x688>
         return(e);
 8230060:	e0bff217 	ldw	r2,-56(fp)
 8230064:	00002b06 	br	8230114 <rawip_usrreq+0x734>
      return 0;
 8230068:	0005883a 	mov	r2,zero
 823006c:	00002906 	br	8230114 <rawip_usrreq+0x734>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 8230070:	e0bffe17 	ldw	r2,-8(fp)
 8230074:	1000021e 	bne	r2,zero,8230080 <rawip_usrreq+0x6a0>
         return(EINVAL);
 8230078:	00800584 	movi	r2,22
 823007c:	00002506 	br	8230114 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 8230080:	e0bffe17 	ldw	r2,-8(fp)
 8230084:	10800317 	ldw	r2,12(r2)
 8230088:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 823008c:	e0bff917 	ldw	r2,-28(fp)
 8230090:	1000021e 	bne	r2,zero,823009c <rawip_usrreq+0x6bc>
         return(EINVAL);
 8230094:	00800584 	movi	r2,22
 8230098:	00001e06 	br	8230114 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 823009c:	e13ffc17 	ldw	r4,-16(fp)
 82300a0:	822f7bc0 	call	822f7bc <rawip_lookup>
 82300a4:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 82300a8:	e0bff817 	ldw	r2,-32(fp)
 82300ac:	1000021e 	bne	r2,zero,82300b8 <rawip_usrreq+0x6d8>
         return(EINVAL);
 82300b0:	00800584 	movi	r2,22
 82300b4:	00001706 	br	8230114 <rawip_usrreq+0x734>
      sin->sin_port = 0;
 82300b8:	e0bff917 	ldw	r2,-28(fp)
 82300bc:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 82300c0:	e0bffe17 	ldw	r2,-8(fp)
 82300c4:	00c00404 	movi	r3,16
 82300c8:	10c00215 	stw	r3,8(r2)
      if (req == PRU_SOCKADDR)
 82300cc:	e0bff617 	ldw	r2,-40(fp)
 82300d0:	108003d8 	cmpnei	r2,r2,15
 82300d4:	1000051e 	bne	r2,zero,82300ec <rawip_usrreq+0x70c>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 82300d8:	e0bff817 	ldw	r2,-32(fp)
 82300dc:	10c00117 	ldw	r3,4(r2)
 82300e0:	e0bff917 	ldw	r2,-28(fp)
 82300e4:	10c00115 	stw	r3,4(r2)
 82300e8:	00000406 	br	82300fc <rawip_usrreq+0x71c>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 82300ec:	e0bff817 	ldw	r2,-32(fp)
 82300f0:	10c00217 	ldw	r3,8(r2)
 82300f4:	e0bff917 	ldw	r2,-28(fp)
 82300f8:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 82300fc:	0005883a 	mov	r2,zero
 8230100:	00000406 	br	8230114 <rawip_usrreq+0x734>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 8230104:	822d2e00 	call	822d2e0 <dtrap>
      return 0;
 8230108:	0005883a 	mov	r2,zero
 823010c:	00000106 	br	8230114 <rawip_usrreq+0x734>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 8230110:	008017c4 	movi	r2,95
   }
}
 8230114:	e6ffff04 	addi	sp,fp,-4
 8230118:	dfc00217 	ldw	ra,8(sp)
 823011c:	df000117 	ldw	fp,4(sp)
 8230120:	dc000017 	ldw	r16,0(sp)
 8230124:	dec00304 	addi	sp,sp,12
 8230128:	f800283a 	ret

0823012c <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 823012c:	defffc04 	addi	sp,sp,-16
 8230130:	dfc00315 	stw	ra,12(sp)
 8230134:	df000215 	stw	fp,8(sp)
 8230138:	df000204 	addi	fp,sp,8
 823013c:	e13ffe15 	stw	r4,-8(fp)
 8230140:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 8230144:	e0bffe17 	ldw	r2,-8(fp)
 8230148:	10800517 	ldw	r2,20(r2)
 823014c:	10800098 	cmpnei	r2,r2,2
 8230150:	1000041e 	bne	r2,zero,8230164 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
 8230154:	e0bfff17 	ldw	r2,-4(fp)
#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 8230158:	10800428 	cmpgeui	r2,r2,16
 823015c:	1000011e 	bne	r2,zero,8230164 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 8230160:	822d2e00 	call	822d2e0 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 8230164:	0001883a 	nop
 8230168:	e037883a 	mov	sp,fp
 823016c:	dfc00117 	ldw	ra,4(sp)
 8230170:	df000017 	ldw	fp,0(sp)
 8230174:	dec00204 	addi	sp,sp,8
 8230178:	f800283a 	ret

0823017c <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 823017c:	defffa04 	addi	sp,sp,-24
 8230180:	dfc00515 	stw	ra,20(sp)
 8230184:	df000415 	stw	fp,16(sp)
 8230188:	df000404 	addi	fp,sp,16
 823018c:	e13ffd15 	stw	r4,-12(fp)
 8230190:	e17ffe15 	stw	r5,-8(fp)
 8230194:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 8230198:	0009883a 	mov	r4,zero
 823019c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 82301a0:	e1bfff17 	ldw	r6,-4(fp)
 82301a4:	e17ffe17 	ldw	r5,-8(fp)
 82301a8:	e13ffd17 	ldw	r4,-12(fp)
 82301ac:	82317800 	call	8231780 <socreate>
 82301b0:	e0bffc15 	stw	r2,-16(fp)
 82301b4:	e0bffc17 	ldw	r2,-16(fp)
 82301b8:	1000041e 	bne	r2,zero,82301cc <t_socket+0x50>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 82301bc:	0009883a 	mov	r4,zero
 82301c0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82301c4:	00bfffc4 	movi	r2,-1
 82301c8:	00000706 	br	82301e8 <t_socket+0x6c>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 82301cc:	e0bffc17 	ldw	r2,-16(fp)
 82301d0:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82301d4:	0009883a 	mov	r4,zero
 82301d8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 82301dc:	e0bffc17 	ldw	r2,-16(fp)
 82301e0:	1004d0ba 	srli	r2,r2,2
 82301e4:	10800804 	addi	r2,r2,32
}
 82301e8:	e037883a 	mov	sp,fp
 82301ec:	dfc00117 	ldw	ra,4(sp)
 82301f0:	df000017 	ldw	fp,0(sp)
 82301f4:	dec00204 	addi	sp,sp,8
 82301f8:	f800283a 	ret

082301fc <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 82301fc:	defff204 	addi	sp,sp,-56
 8230200:	dfc00d15 	stw	ra,52(sp)
 8230204:	df000c15 	stw	fp,48(sp)
 8230208:	df000c04 	addi	fp,sp,48
 823020c:	e13ffd15 	stw	r4,-12(fp)
 8230210:	e17ffe15 	stw	r5,-8(fp)
 8230214:	e1bfff15 	stw	r6,-4(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 8230218:	e0bffd17 	ldw	r2,-12(fp)
 823021c:	10bff804 	addi	r2,r2,-32
 8230220:	1085883a 	add	r2,r2,r2
 8230224:	1085883a 	add	r2,r2,r2
 8230228:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 823022c:	008209b4 	movhi	r2,2086
 8230230:	10b87704 	addi	r2,r2,-7716
 8230234:	e0bff515 	stw	r2,-44(fp)
 8230238:	00000606 	br	8230254 <t_bind+0x58>
 823023c:	e0fff517 	ldw	r3,-44(fp)
 8230240:	e0bff617 	ldw	r2,-40(fp)
 8230244:	18800626 	beq	r3,r2,8230260 <t_bind+0x64>
 8230248:	e0bff517 	ldw	r2,-44(fp)
 823024c:	10800017 	ldw	r2,0(r2)
 8230250:	e0bff515 	stw	r2,-44(fp)
 8230254:	e0bff517 	ldw	r2,-44(fp)
 8230258:	103ff81e 	bne	r2,zero,823023c <t_bind+0x40>
 823025c:	00000106 	br	8230264 <t_bind+0x68>
 8230260:	0001883a 	nop
 8230264:	e0fff517 	ldw	r3,-44(fp)
 8230268:	e0bff617 	ldw	r2,-40(fp)
 823026c:	18800326 	beq	r3,r2,823027c <t_bind+0x80>
 8230270:	822d2e00 	call	822d2e0 <dtrap>
 8230274:	00bfffc4 	movi	r2,-1
 8230278:	00003406 	br	823034c <t_bind+0x150>
   DOMAIN_CHECK(so, addrlen);
 823027c:	e17fff17 	ldw	r5,-4(fp)
 8230280:	e13ff617 	ldw	r4,-40(fp)
 8230284:	823012c0 	call	823012c <DOMAIN_CHECK>

   so->so_error = 0;
 8230288:	e0bff617 	ldw	r2,-40(fp)
 823028c:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 8230290:	e0bffe17 	ldw	r2,-8(fp)
 8230294:	10000d1e 	bne	r2,zero,82302cc <t_bind+0xd0>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 8230298:	e0bff904 	addi	r2,fp,-28
 823029c:	01800404 	movi	r6,16
 82302a0:	000b883a 	mov	r5,zero
 82302a4:	1009883a 	mov	r4,r2
 82302a8:	8202f000 	call	8202f00 <memset>
      addrlen = sizeof(sa);
 82302ac:	00800404 	movi	r2,16
 82302b0:	e0bfff15 	stw	r2,-4(fp)
      sa.sa_family = so->so_domain;
 82302b4:	e0bff617 	ldw	r2,-40(fp)
 82302b8:	10800517 	ldw	r2,20(r2)
 82302bc:	e0bff90d 	sth	r2,-28(fp)
      sap = &sa;
 82302c0:	e0bff904 	addi	r2,fp,-28
 82302c4:	e0bff415 	stw	r2,-48(fp)
 82302c8:	00000206 	br	82302d4 <t_bind+0xd8>
   } else
      sap = addr;
 82302cc:	e0bffe17 	ldw	r2,-8(fp)
 82302d0:	e0bff415 	stw	r2,-48(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 82302d4:	01800244 	movi	r6,9
 82302d8:	e17fff17 	ldw	r5,-4(fp)
 82302dc:	e13ff417 	ldw	r4,-48(fp)
 82302e0:	823165c0 	call	823165c <sockargs>
 82302e4:	e0bff715 	stw	r2,-36(fp)
 82302e8:	e0bff717 	ldw	r2,-36(fp)
 82302ec:	1000051e 	bne	r2,zero,8230304 <t_bind+0x108>
   {
      so->so_error = ENOMEM;
 82302f0:	e0bff617 	ldw	r2,-40(fp)
 82302f4:	00c00304 	movi	r3,12
 82302f8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82302fc:	00bfffc4 	movi	r2,-1
 8230300:	00001206 	br	823034c <t_bind+0x150>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230304:	0009883a 	mov	r4,zero
 8230308:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 823030c:	e17ff717 	ldw	r5,-36(fp)
 8230310:	e13ff617 	ldw	r4,-40(fp)
 8230314:	82319280 	call	8231928 <sobind>
 8230318:	e0bff815 	stw	r2,-32(fp)
   m_freem(nam);
 823031c:	e13ff717 	ldw	r4,-36(fp)
 8230320:	822e3840 	call	822e384 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230324:	0009883a 	mov	r4,zero
 8230328:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (err) 
 823032c:	e0bff817 	ldw	r2,-32(fp)
 8230330:	10000526 	beq	r2,zero,8230348 <t_bind+0x14c>
   {
      so->so_error = err;
 8230334:	e0bff617 	ldw	r2,-40(fp)
 8230338:	e0fff817 	ldw	r3,-32(fp)
 823033c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230340:	00bfffc4 	movi	r2,-1
 8230344:	00000106 	br	823034c <t_bind+0x150>
   }
   return 0;
 8230348:	0005883a 	mov	r2,zero
}
 823034c:	e037883a 	mov	sp,fp
 8230350:	dfc00117 	ldw	ra,4(sp)
 8230354:	df000017 	ldw	fp,0(sp)
 8230358:	dec00204 	addi	sp,sp,8
 823035c:	f800283a 	ret

08230360 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 8230360:	defff904 	addi	sp,sp,-28
 8230364:	dfc00615 	stw	ra,24(sp)
 8230368:	df000515 	stw	fp,20(sp)
 823036c:	df000504 	addi	fp,sp,20
 8230370:	e13ffe15 	stw	r4,-8(fp)
 8230374:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 8230378:	e0bffe17 	ldw	r2,-8(fp)
 823037c:	10bff804 	addi	r2,r2,-32
 8230380:	1085883a 	add	r2,r2,r2
 8230384:	1085883a 	add	r2,r2,r2
 8230388:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 823038c:	008209b4 	movhi	r2,2086
 8230390:	10b87704 	addi	r2,r2,-7716
 8230394:	e0bffb15 	stw	r2,-20(fp)
 8230398:	00000606 	br	82303b4 <t_listen+0x54>
 823039c:	e0fffb17 	ldw	r3,-20(fp)
 82303a0:	e0bffc17 	ldw	r2,-16(fp)
 82303a4:	18800626 	beq	r3,r2,82303c0 <t_listen+0x60>
 82303a8:	e0bffb17 	ldw	r2,-20(fp)
 82303ac:	10800017 	ldw	r2,0(r2)
 82303b0:	e0bffb15 	stw	r2,-20(fp)
 82303b4:	e0bffb17 	ldw	r2,-20(fp)
 82303b8:	103ff81e 	bne	r2,zero,823039c <t_listen+0x3c>
 82303bc:	00000106 	br	82303c4 <t_listen+0x64>
 82303c0:	0001883a 	nop
 82303c4:	e0fffb17 	ldw	r3,-20(fp)
 82303c8:	e0bffc17 	ldw	r2,-16(fp)
 82303cc:	18800326 	beq	r3,r2,82303dc <t_listen+0x7c>
 82303d0:	822d2e00 	call	822d2e0 <dtrap>
 82303d4:	00bfffc4 	movi	r2,-1
 82303d8:	00001206 	br	8230424 <t_listen+0xc4>
   so->so_error = 0;
 82303dc:	e0bffc17 	ldw	r2,-16(fp)
 82303e0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 82303e4:	0009883a 	mov	r4,zero
 82303e8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 82303ec:	e17fff17 	ldw	r5,-4(fp)
 82303f0:	e13ffc17 	ldw	r4,-16(fp)
 82303f4:	82319840 	call	8231984 <solisten>
 82303f8:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82303fc:	0009883a 	mov	r4,zero
 8230400:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 8230404:	e0bffd17 	ldw	r2,-12(fp)
 8230408:	10000526 	beq	r2,zero,8230420 <t_listen+0xc0>
   {
      so->so_error = err;
 823040c:	e0bffc17 	ldw	r2,-16(fp)
 8230410:	e0fffd17 	ldw	r3,-12(fp)
 8230414:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230418:	00bfffc4 	movi	r2,-1
 823041c:	00000106 	br	8230424 <t_listen+0xc4>
   }
   return 0;
 8230420:	0005883a 	mov	r2,zero
}
 8230424:	e037883a 	mov	sp,fp
 8230428:	dfc00117 	ldw	ra,4(sp)
 823042c:	df000017 	ldw	fp,0(sp)
 8230430:	dec00204 	addi	sp,sp,8
 8230434:	f800283a 	ret

08230438 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 8230438:	defff704 	addi	sp,sp,-36
 823043c:	dfc00815 	stw	ra,32(sp)
 8230440:	df000715 	stw	fp,28(sp)
 8230444:	df000704 	addi	fp,sp,28
 8230448:	e13ffd15 	stw	r4,-12(fp)
 823044c:	e17ffe15 	stw	r5,-8(fp)
 8230450:	e1bfff15 	stw	r6,-4(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 8230454:	e0bffd17 	ldw	r2,-12(fp)
 8230458:	10bff804 	addi	r2,r2,-32
 823045c:	1085883a 	add	r2,r2,r2
 8230460:	1085883a 	add	r2,r2,r2
 8230464:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230468:	008209b4 	movhi	r2,2086
 823046c:	10b87704 	addi	r2,r2,-7716
 8230470:	e0bff915 	stw	r2,-28(fp)
 8230474:	00000606 	br	8230490 <t_accept+0x58>
 8230478:	e0fff917 	ldw	r3,-28(fp)
 823047c:	e0bffa17 	ldw	r2,-24(fp)
 8230480:	18800626 	beq	r3,r2,823049c <t_accept+0x64>
 8230484:	e0bff917 	ldw	r2,-28(fp)
 8230488:	10800017 	ldw	r2,0(r2)
 823048c:	e0bff915 	stw	r2,-28(fp)
 8230490:	e0bff917 	ldw	r2,-28(fp)
 8230494:	103ff81e 	bne	r2,zero,8230478 <t_accept+0x40>
 8230498:	00000106 	br	82304a0 <t_accept+0x68>
 823049c:	0001883a 	nop
 82304a0:	e0fff917 	ldw	r3,-28(fp)
 82304a4:	e0bffa17 	ldw	r2,-24(fp)
 82304a8:	18800326 	beq	r3,r2,82304b8 <t_accept+0x80>
 82304ac:	822d2e00 	call	822d2e0 <dtrap>
 82304b0:	00bfffc4 	movi	r2,-1
 82304b4:	00007006 	br	8230678 <t_accept+0x240>
   DOMAIN_CHECK(so, *addrlen);
 82304b8:	e0bfff17 	ldw	r2,-4(fp)
 82304bc:	10800017 	ldw	r2,0(r2)
 82304c0:	100b883a 	mov	r5,r2
 82304c4:	e13ffa17 	ldw	r4,-24(fp)
 82304c8:	823012c0 	call	823012c <DOMAIN_CHECK>

   so->so_error = 0;
 82304cc:	e0bffa17 	ldw	r2,-24(fp)
 82304d0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 82304d4:	e0bffa17 	ldw	r2,-24(fp)
 82304d8:	10800417 	ldw	r2,16(r2)
 82304dc:	1080008c 	andi	r2,r2,2
 82304e0:	1000051e 	bne	r2,zero,82304f8 <t_accept+0xc0>
   {
      so->so_error = EINVAL;
 82304e4:	e0bffa17 	ldw	r2,-24(fp)
 82304e8:	00c00584 	movi	r3,22
 82304ec:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82304f0:	00bfffc4 	movi	r2,-1
 82304f4:	00006006 	br	8230678 <t_accept+0x240>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 82304f8:	e0bffa17 	ldw	r2,-24(fp)
 82304fc:	1080088b 	ldhu	r2,34(r2)
 8230500:	10bfffcc 	andi	r2,r2,65535
 8230504:	1080400c 	andi	r2,r2,256
 8230508:	10000b26 	beq	r2,zero,8230538 <t_accept+0x100>
 823050c:	e0bffa17 	ldw	r2,-24(fp)
 8230510:	10801e43 	ldbu	r2,121(r2)
 8230514:	10803fcc 	andi	r2,r2,255
 8230518:	1080201c 	xori	r2,r2,128
 823051c:	10bfe004 	addi	r2,r2,-128
 8230520:	1000051e 	bne	r2,zero,8230538 <t_accept+0x100>
   {
      so->so_error = EWOULDBLOCK;
 8230524:	e0bffa17 	ldw	r2,-24(fp)
 8230528:	00c002c4 	movi	r3,11
 823052c:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230530:	00bfffc4 	movi	r2,-1
 8230534:	00005006 	br	8230678 <t_accept+0x240>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230538:	0009883a 	mov	r4,zero
 823053c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 8230540:	00001006 	br	8230584 <t_accept+0x14c>
   {
      if (so->so_state & SS_CANTRCVMORE)
 8230544:	e0bffa17 	ldw	r2,-24(fp)
 8230548:	1080088b 	ldhu	r2,34(r2)
 823054c:	10bfffcc 	andi	r2,r2,65535
 8230550:	1080080c 	andi	r2,r2,32
 8230554:	10000726 	beq	r2,zero,8230574 <t_accept+0x13c>
      {
         so->so_error = ECONNABORTED;
 8230558:	e0bffa17 	ldw	r2,-24(fp)
 823055c:	00c01c44 	movi	r3,113
 8230560:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230564:	0009883a 	mov	r4,zero
 8230568:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 823056c:	00bfffc4 	movi	r2,-1
 8230570:	00004106 	br	8230678 <t_accept+0x240>
      }
      tcp_sleep ((char *)&so->so_timeo);
 8230574:	e0bffa17 	ldw	r2,-24(fp)
 8230578:	10800904 	addi	r2,r2,36
 823057c:	1009883a 	mov	r4,r2
 8230580:	82292800 	call	8229280 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 8230584:	e0bffa17 	ldw	r2,-24(fp)
 8230588:	10801e43 	ldbu	r2,121(r2)
 823058c:	10803fcc 	andi	r2,r2,255
 8230590:	1080201c 	xori	r2,r2,128
 8230594:	10bfe004 	addi	r2,r2,-128
 8230598:	1000031e 	bne	r2,zero,82305a8 <t_accept+0x170>
 823059c:	e0bffa17 	ldw	r2,-24(fp)
 82305a0:	10800617 	ldw	r2,24(r2)
 82305a4:	103fe726 	beq	r2,zero,8230544 <t_accept+0x10c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 82305a8:	e0bffa17 	ldw	r2,-24(fp)
 82305ac:	10800617 	ldw	r2,24(r2)
 82305b0:	10000426 	beq	r2,zero,82305c4 <t_accept+0x18c>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 82305b4:	0009883a 	mov	r4,zero
 82305b8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82305bc:	00bfffc4 	movi	r2,-1
 82305c0:	00002d06 	br	8230678 <t_accept+0x240>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 82305c4:	01400404 	movi	r5,16
 82305c8:	01000244 	movi	r4,9
 82305cc:	822e0f40 	call	822e0f4 <m_getnbuf>
 82305d0:	e0bffb15 	stw	r2,-20(fp)
   if (nam == NULL) 
 82305d4:	e0bffb17 	ldw	r2,-20(fp)
 82305d8:	1000071e 	bne	r2,zero,82305f8 <t_accept+0x1c0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 82305dc:	0009883a 	mov	r4,zero
 82305e0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 82305e4:	e0bffa17 	ldw	r2,-24(fp)
 82305e8:	00c00304 	movi	r3,12
 82305ec:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82305f0:	00bfffc4 	movi	r2,-1
 82305f4:	00002006 	br	8230678 <t_accept+0x240>
   }
   { 
      struct socket *aso = so->so_q;
 82305f8:	e0bffa17 	ldw	r2,-24(fp)
 82305fc:	10801d17 	ldw	r2,116(r2)
 8230600:	e0bffc15 	stw	r2,-16(fp)
      if (soqremque (aso, 1) == 0)
 8230604:	01400044 	movi	r5,1
 8230608:	e13ffc17 	ldw	r4,-16(fp)
 823060c:	8233d300 	call	8233d30 <soqremque>
 8230610:	1000031e 	bne	r2,zero,8230620 <t_accept+0x1e8>
         panic("accept");
 8230614:	01020974 	movhi	r4,2085
 8230618:	21029304 	addi	r4,r4,2636
 823061c:	82289940 	call	8228994 <panic>
      so = aso;
 8230620:	e0bffc17 	ldw	r2,-16(fp)
 8230624:	e0bffa15 	stw	r2,-24(fp)
   }
   (void)soaccept (so, nam);
 8230628:	e17ffb17 	ldw	r5,-20(fp)
 823062c:	e13ffa17 	ldw	r4,-24(fp)
 8230630:	8231e700 	call	8231e70 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 8230634:	e0bffe17 	ldw	r2,-8(fp)
 8230638:	10000826 	beq	r2,zero,823065c <t_accept+0x224>
      MEMCPY(addr, nam->m_data, *addrlen);
 823063c:	e0bffb17 	ldw	r2,-20(fp)
 8230640:	10c00317 	ldw	r3,12(r2)
 8230644:	e0bfff17 	ldw	r2,-4(fp)
 8230648:	10800017 	ldw	r2,0(r2)
 823064c:	100d883a 	mov	r6,r2
 8230650:	180b883a 	mov	r5,r3
 8230654:	e13ffe17 	ldw	r4,-8(fp)
 8230658:	8202c5c0 	call	8202c5c <memcpy>
   m_freem (nam);
 823065c:	e13ffb17 	ldw	r4,-20(fp)
 8230660:	822e3840 	call	822e384 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230664:	0009883a 	mov	r4,zero
 8230668:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 823066c:	e0bffa17 	ldw	r2,-24(fp)
 8230670:	1004d0ba 	srli	r2,r2,2
 8230674:	10800804 	addi	r2,r2,32
}
 8230678:	e037883a 	mov	sp,fp
 823067c:	dfc00117 	ldw	ra,4(sp)
 8230680:	df000017 	ldw	fp,0(sp)
 8230684:	dec00204 	addi	sp,sp,8
 8230688:	f800283a 	ret

0823068c <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 823068c:	defff804 	addi	sp,sp,-32
 8230690:	dfc00715 	stw	ra,28(sp)
 8230694:	df000615 	stw	fp,24(sp)
 8230698:	df000604 	addi	fp,sp,24
 823069c:	e13ffd15 	stw	r4,-12(fp)
 82306a0:	e17ffe15 	stw	r5,-8(fp)
 82306a4:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 82306a8:	e0bffd17 	ldw	r2,-12(fp)
 82306ac:	10bff804 	addi	r2,r2,-32
 82306b0:	1085883a 	add	r2,r2,r2
 82306b4:	1085883a 	add	r2,r2,r2
 82306b8:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82306bc:	008209b4 	movhi	r2,2086
 82306c0:	10b87704 	addi	r2,r2,-7716
 82306c4:	e0bffa15 	stw	r2,-24(fp)
 82306c8:	00000606 	br	82306e4 <t_connect+0x58>
 82306cc:	e0fffa17 	ldw	r3,-24(fp)
 82306d0:	e0bffb17 	ldw	r2,-20(fp)
 82306d4:	18800626 	beq	r3,r2,82306f0 <t_connect+0x64>
 82306d8:	e0bffa17 	ldw	r2,-24(fp)
 82306dc:	10800017 	ldw	r2,0(r2)
 82306e0:	e0bffa15 	stw	r2,-24(fp)
 82306e4:	e0bffa17 	ldw	r2,-24(fp)
 82306e8:	103ff81e 	bne	r2,zero,82306cc <t_connect+0x40>
 82306ec:	00000106 	br	82306f4 <t_connect+0x68>
 82306f0:	0001883a 	nop
 82306f4:	e0fffa17 	ldw	r3,-24(fp)
 82306f8:	e0bffb17 	ldw	r2,-20(fp)
 82306fc:	18800326 	beq	r3,r2,823070c <t_connect+0x80>
 8230700:	822d2e00 	call	822d2e0 <dtrap>
 8230704:	00bfffc4 	movi	r2,-1
 8230708:	00007606 	br	82308e4 <t_connect+0x258>
   DOMAIN_CHECK(so, addrlen);
 823070c:	e17fff17 	ldw	r5,-4(fp)
 8230710:	e13ffb17 	ldw	r4,-20(fp)
 8230714:	823012c0 	call	823012c <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 8230718:	e0bffb17 	ldw	r2,-20(fp)
 823071c:	1080088b 	ldhu	r2,34(r2)
 8230720:	10bfffcc 	andi	r2,r2,65535
 8230724:	1080400c 	andi	r2,r2,256
 8230728:	10002426 	beq	r2,zero,82307bc <t_connect+0x130>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 823072c:	e0bffb17 	ldw	r2,-20(fp)
 8230730:	1080088b 	ldhu	r2,34(r2)
 8230734:	10bfffcc 	andi	r2,r2,65535
 8230738:	1080010c 	andi	r2,r2,4
 823073c:	10000526 	beq	r2,zero,8230754 <t_connect+0xc8>
      {
         so->so_error = EINPROGRESS;
 8230740:	e0bffb17 	ldw	r2,-20(fp)
 8230744:	00c01dc4 	movi	r3,119
 8230748:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 823074c:	00bfffc4 	movi	r2,-1
 8230750:	00006406 	br	82308e4 <t_connect+0x258>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 8230754:	e0bffb17 	ldw	r2,-20(fp)
 8230758:	1080088b 	ldhu	r2,34(r2)
 823075c:	10bfffcc 	andi	r2,r2,65535
 8230760:	1080008c 	andi	r2,r2,2
 8230764:	10000426 	beq	r2,zero,8230778 <t_connect+0xec>
      {
         so->so_error = 0;
 8230768:	e0bffb17 	ldw	r2,-20(fp)
 823076c:	10000615 	stw	zero,24(r2)
         return 0;
 8230770:	0005883a 	mov	r2,zero
 8230774:	00005b06 	br	82308e4 <t_connect+0x258>
      }
      if (so->so_state & SS_WASCONNECTING)
 8230778:	e0bffb17 	ldw	r2,-20(fp)
 823077c:	1080088b 	ldhu	r2,34(r2)
 8230780:	10bfffcc 	andi	r2,r2,65535
 8230784:	1088000c 	andi	r2,r2,8192
 8230788:	10000c26 	beq	r2,zero,82307bc <t_connect+0x130>
      {
         so->so_state &= ~SS_WASCONNECTING;
 823078c:	e0bffb17 	ldw	r2,-20(fp)
 8230790:	10c0088b 	ldhu	r3,34(r2)
 8230794:	00b7ffc4 	movi	r2,-8193
 8230798:	1884703a 	and	r2,r3,r2
 823079c:	1007883a 	mov	r3,r2
 82307a0:	e0bffb17 	ldw	r2,-20(fp)
 82307a4:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 82307a8:	e0bffb17 	ldw	r2,-20(fp)
 82307ac:	10800617 	ldw	r2,24(r2)
 82307b0:	10000226 	beq	r2,zero,82307bc <t_connect+0x130>
            return SOCKET_ERROR;
 82307b4:	00bfffc4 	movi	r2,-1
 82307b8:	00004a06 	br	82308e4 <t_connect+0x258>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 82307bc:	e0bffb17 	ldw	r2,-20(fp)
 82307c0:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 82307c4:	01800244 	movi	r6,9
 82307c8:	e17fff17 	ldw	r5,-4(fp)
 82307cc:	e13ffe17 	ldw	r4,-8(fp)
 82307d0:	823165c0 	call	823165c <sockargs>
 82307d4:	e0bffc15 	stw	r2,-16(fp)
 82307d8:	e0bffc17 	ldw	r2,-16(fp)
 82307dc:	1000051e 	bne	r2,zero,82307f4 <t_connect+0x168>
       == NULL)
   {
      so->so_error = ENOMEM;
 82307e0:	e0bffb17 	ldw	r2,-20(fp)
 82307e4:	00c00304 	movi	r3,12
 82307e8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82307ec:	00bfffc4 	movi	r2,-1
 82307f0:	00003c06 	br	82308e4 <t_connect+0x258>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 82307f4:	0009883a 	mov	r4,zero
 82307f8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 82307fc:	e17ffc17 	ldw	r5,-16(fp)
 8230800:	e13ffb17 	ldw	r4,-20(fp)
 8230804:	8231f080 	call	8231f08 <soconnect>
 8230808:	1007883a 	mov	r3,r2
 823080c:	e0bffb17 	ldw	r2,-20(fp)
 8230810:	10c00615 	stw	r3,24(r2)
 8230814:	e0bffb17 	ldw	r2,-20(fp)
 8230818:	10800617 	ldw	r2,24(r2)
 823081c:	10001b1e 	bne	r2,zero,823088c <t_connect+0x200>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 8230820:	e0bffb17 	ldw	r2,-20(fp)
 8230824:	1080088b 	ldhu	r2,34(r2)
 8230828:	10bfffcc 	andi	r2,r2,65535
 823082c:	1080400c 	andi	r2,r2,256
 8230830:	10000d26 	beq	r2,zero,8230868 <t_connect+0x1dc>
 8230834:	e0bffb17 	ldw	r2,-20(fp)
 8230838:	1080088b 	ldhu	r2,34(r2)
 823083c:	10bfffcc 	andi	r2,r2,65535
 8230840:	1080010c 	andi	r2,r2,4
 8230844:	10000826 	beq	r2,zero,8230868 <t_connect+0x1dc>
   {
      so->so_error = EINPROGRESS;
 8230848:	e0bffb17 	ldw	r2,-20(fp)
 823084c:	00c01dc4 	movi	r3,119
 8230850:	10c00615 	stw	r3,24(r2)
      goto bad;
 8230854:	00000e06 	br	8230890 <t_connect+0x204>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 8230858:	e0bffb17 	ldw	r2,-20(fp)
 823085c:	10800904 	addi	r2,r2,36
 8230860:	1009883a 	mov	r4,r2
 8230864:	82292800 	call	8229280 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 8230868:	e0bffb17 	ldw	r2,-20(fp)
 823086c:	1080088b 	ldhu	r2,34(r2)
 8230870:	10bfffcc 	andi	r2,r2,65535
 8230874:	1080010c 	andi	r2,r2,4
 8230878:	10000526 	beq	r2,zero,8230890 <t_connect+0x204>
 823087c:	e0bffb17 	ldw	r2,-20(fp)
 8230880:	10800617 	ldw	r2,24(r2)
 8230884:	103ff426 	beq	r2,zero,8230858 <t_connect+0x1cc>
 8230888:	00000106 	br	8230890 <t_connect+0x204>
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   if ((so->so_error = soconnect (so, nam)) != 0)
      goto bad;
 823088c:	0001883a 	nop
   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 8230890:	e0bffb17 	ldw	r2,-20(fp)
 8230894:	10800617 	ldw	r2,24(r2)
 8230898:	10801de0 	cmpeqi	r2,r2,119
 823089c:	1000071e 	bne	r2,zero,82308bc <t_connect+0x230>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 82308a0:	e0bffb17 	ldw	r2,-20(fp)
 82308a4:	10c0088b 	ldhu	r3,34(r2)
 82308a8:	00b7fec4 	movi	r2,-8197
 82308ac:	1884703a 	and	r2,r3,r2
 82308b0:	1007883a 	mov	r3,r2
 82308b4:	e0bffb17 	ldw	r2,-20(fp)
 82308b8:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 82308bc:	e13ffc17 	ldw	r4,-16(fp)
 82308c0:	822e3840 	call	822e384 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 82308c4:	0009883a 	mov	r4,zero
 82308c8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 82308cc:	e0bffb17 	ldw	r2,-20(fp)
 82308d0:	10800617 	ldw	r2,24(r2)
 82308d4:	10000226 	beq	r2,zero,82308e0 <t_connect+0x254>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 82308d8:	00bfffc4 	movi	r2,-1
 82308dc:	00000106 	br	82308e4 <t_connect+0x258>

   }
      return 0;
 82308e0:	0005883a 	mov	r2,zero
}
 82308e4:	e037883a 	mov	sp,fp
 82308e8:	dfc00117 	ldw	ra,4(sp)
 82308ec:	df000017 	ldw	fp,0(sp)
 82308f0:	dec00204 	addi	sp,sp,8
 82308f4:	f800283a 	ret

082308f8 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 82308f8:	defffb04 	addi	sp,sp,-20
 82308fc:	dfc00415 	stw	ra,16(sp)
 8230900:	df000315 	stw	fp,12(sp)
 8230904:	df000304 	addi	fp,sp,12
 8230908:	e13ffd15 	stw	r4,-12(fp)
 823090c:	e17ffe15 	stw	r5,-8(fp)
 8230910:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 8230914:	01c00404 	movi	r7,16
 8230918:	e1bfff17 	ldw	r6,-4(fp)
 823091c:	e17ffe17 	ldw	r5,-8(fp)
 8230920:	e13ffd17 	ldw	r4,-12(fp)
 8230924:	82309800 	call	8230980 <t_getname>
}
 8230928:	e037883a 	mov	sp,fp
 823092c:	dfc00117 	ldw	ra,4(sp)
 8230930:	df000017 	ldw	fp,0(sp)
 8230934:	dec00204 	addi	sp,sp,8
 8230938:	f800283a 	ret

0823093c <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 823093c:	defffb04 	addi	sp,sp,-20
 8230940:	dfc00415 	stw	ra,16(sp)
 8230944:	df000315 	stw	fp,12(sp)
 8230948:	df000304 	addi	fp,sp,12
 823094c:	e13ffd15 	stw	r4,-12(fp)
 8230950:	e17ffe15 	stw	r5,-8(fp)
 8230954:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 8230958:	01c003c4 	movi	r7,15
 823095c:	e1bfff17 	ldw	r6,-4(fp)
 8230960:	e17ffe17 	ldw	r5,-8(fp)
 8230964:	e13ffd17 	ldw	r4,-12(fp)
 8230968:	82309800 	call	8230980 <t_getname>
}
 823096c:	e037883a 	mov	sp,fp
 8230970:	dfc00117 	ldw	ra,4(sp)
 8230974:	df000017 	ldw	fp,0(sp)
 8230978:	dec00204 	addi	sp,sp,8
 823097c:	f800283a 	ret

08230980 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 8230980:	defff604 	addi	sp,sp,-40
 8230984:	dfc00915 	stw	ra,36(sp)
 8230988:	df000815 	stw	fp,32(sp)
 823098c:	df000804 	addi	fp,sp,32
 8230990:	e13ffc15 	stw	r4,-16(fp)
 8230994:	e17ffd15 	stw	r5,-12(fp)
 8230998:	e1bffe15 	stw	r6,-8(fp)
 823099c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 82309a0:	e0bffc17 	ldw	r2,-16(fp)
 82309a4:	10bff804 	addi	r2,r2,-32
 82309a8:	1085883a 	add	r2,r2,r2
 82309ac:	1085883a 	add	r2,r2,r2
 82309b0:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82309b4:	008209b4 	movhi	r2,2086
 82309b8:	10b87704 	addi	r2,r2,-7716
 82309bc:	e0bff815 	stw	r2,-32(fp)
 82309c0:	00000606 	br	82309dc <t_getname+0x5c>
 82309c4:	e0fff817 	ldw	r3,-32(fp)
 82309c8:	e0bff917 	ldw	r2,-28(fp)
 82309cc:	18800626 	beq	r3,r2,82309e8 <t_getname+0x68>
 82309d0:	e0bff817 	ldw	r2,-32(fp)
 82309d4:	10800017 	ldw	r2,0(r2)
 82309d8:	e0bff815 	stw	r2,-32(fp)
 82309dc:	e0bff817 	ldw	r2,-32(fp)
 82309e0:	103ff81e 	bne	r2,zero,82309c4 <t_getname+0x44>
 82309e4:	00000106 	br	82309ec <t_getname+0x6c>
 82309e8:	0001883a 	nop
 82309ec:	e0fff817 	ldw	r3,-32(fp)
 82309f0:	e0bff917 	ldw	r2,-28(fp)
 82309f4:	18800326 	beq	r3,r2,8230a04 <t_getname+0x84>
 82309f8:	822d2e00 	call	822d2e0 <dtrap>
 82309fc:	00bfffc4 	movi	r2,-1
 8230a00:	00005106 	br	8230b48 <t_getname+0x1c8>

   so->so_error = 0;
 8230a04:	e0bff917 	ldw	r2,-28(fp)
 8230a08:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 8230a0c:	e0bfff17 	ldw	r2,-4(fp)
 8230a10:	10800418 	cmpnei	r2,r2,16
 8230a14:	10000a1e 	bne	r2,zero,8230a40 <t_getname+0xc0>
 8230a18:	e0bff917 	ldw	r2,-28(fp)
 8230a1c:	1080088b 	ldhu	r2,34(r2)
 8230a20:	10bfffcc 	andi	r2,r2,65535
 8230a24:	1080008c 	andi	r2,r2,2
 8230a28:	1000051e 	bne	r2,zero,8230a40 <t_getname+0xc0>
   {
      so->so_error = ENOTCONN;
 8230a2c:	e0bff917 	ldw	r2,-28(fp)
 8230a30:	00c02004 	movi	r3,128
 8230a34:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230a38:	00bfffc4 	movi	r2,-1
 8230a3c:	00004206 	br	8230b48 <t_getname+0x1c8>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230a40:	0009883a 	mov	r4,zero
 8230a44:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8230a48:	01400404 	movi	r5,16
 8230a4c:	01000244 	movi	r4,9
 8230a50:	822e0f40 	call	822e0f4 <m_getnbuf>
 8230a54:	e0bffa15 	stw	r2,-24(fp)
   if (m == NULL) 
 8230a58:	e0bffa17 	ldw	r2,-24(fp)
 8230a5c:	1000071e 	bne	r2,zero,8230a7c <t_getname+0xfc>
   {
      so->so_error = ENOMEM;
 8230a60:	e0bff917 	ldw	r2,-28(fp)
 8230a64:	00c00304 	movi	r3,12
 8230a68:	10c00615 	stw	r3,24(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230a6c:	0009883a 	mov	r4,zero
 8230a70:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 8230a74:	00bfffc4 	movi	r2,-1
 8230a78:	00003306 	br	8230b48 <t_getname+0x1c8>
   }
   so->so_req = opcode;
 8230a7c:	e0bff917 	ldw	r2,-28(fp)
 8230a80:	e0ffff17 	ldw	r3,-4(fp)
 8230a84:	10c00715 	stw	r3,28(r2)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 8230a88:	e0bff917 	ldw	r2,-28(fp)
 8230a8c:	10800217 	ldw	r2,8(r2)
 8230a90:	10800317 	ldw	r2,12(r2)
 8230a94:	e1bffa17 	ldw	r6,-24(fp)
 8230a98:	000b883a 	mov	r5,zero
 8230a9c:	e13ff917 	ldw	r4,-28(fp)
 8230aa0:	103ee83a 	callr	r2
 8230aa4:	e0bffb15 	stw	r2,-20(fp)
 8230aa8:	e0bffb17 	ldw	r2,-20(fp)
 8230aac:	1000191e 	bne	r2,zero,8230b14 <t_getname+0x194>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 8230ab0:	e0bff917 	ldw	r2,-28(fp)
 8230ab4:	10800517 	ldw	r2,20(r2)
 8230ab8:	10800098 	cmpnei	r2,r2,2
 8230abc:	1000161e 	bne	r2,zero,8230b18 <t_getname+0x198>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 8230ac0:	e0bffe17 	ldw	r2,-8(fp)
 8230ac4:	10800017 	ldw	r2,0(r2)
 8230ac8:	10800428 	cmpgeui	r2,r2,16
 8230acc:	1000071e 	bne	r2,zero,8230aec <t_getname+0x16c>
      {
         dtrap();    /* programming error */
 8230ad0:	822d2e00 	call	822d2e0 <dtrap>
         m_freem(m);
 8230ad4:	e13ffa17 	ldw	r4,-24(fp)
 8230ad8:	822e3840 	call	822e384 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230adc:	0009883a 	mov	r4,zero
 8230ae0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 8230ae4:	00800584 	movi	r2,22
 8230ae8:	00001706 	br	8230b48 <t_getname+0x1c8>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 8230aec:	e0bffa17 	ldw	r2,-24(fp)
 8230af0:	10800317 	ldw	r2,12(r2)
 8230af4:	01800404 	movi	r6,16
 8230af8:	100b883a 	mov	r5,r2
 8230afc:	e13ffd17 	ldw	r4,-12(fp)
 8230b00:	8202c5c0 	call	8202c5c <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 8230b04:	e0bffe17 	ldw	r2,-8(fp)
 8230b08:	00c00404 	movi	r3,16
 8230b0c:	10c00015 	stw	r3,0(r2)
 8230b10:	00000106 	br	8230b18 <t_getname+0x198>
      UNLOCK_NET_RESOURCE(NET_RESID);
      return SOCKET_ERROR;
   }
   so->so_req = opcode;
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
      goto bad;
 8230b14:	0001883a 	nop
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 8230b18:	e13ffa17 	ldw	r4,-24(fp)
 8230b1c:	822e3840 	call	822e384 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230b20:	0009883a 	mov	r4,zero
 8230b24:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230b28:	e0bffb17 	ldw	r2,-20(fp)
 8230b2c:	10000526 	beq	r2,zero,8230b44 <t_getname+0x1c4>
   {
      so->so_error = err;
 8230b30:	e0bff917 	ldw	r2,-28(fp)
 8230b34:	e0fffb17 	ldw	r3,-20(fp)
 8230b38:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230b3c:	00bfffc4 	movi	r2,-1
 8230b40:	00000106 	br	8230b48 <t_getname+0x1c8>
   }
   return 0;
 8230b44:	0005883a 	mov	r2,zero
}
 8230b48:	e037883a 	mov	sp,fp
 8230b4c:	dfc00117 	ldw	ra,4(sp)
 8230b50:	df000017 	ldw	fp,0(sp)
 8230b54:	dec00204 	addi	sp,sp,8
 8230b58:	f800283a 	ret

08230b5c <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 8230b5c:	defff704 	addi	sp,sp,-36
 8230b60:	dfc00815 	stw	ra,32(sp)
 8230b64:	df000715 	stw	fp,28(sp)
 8230b68:	df000704 	addi	fp,sp,28
 8230b6c:	e13ffc15 	stw	r4,-16(fp)
 8230b70:	e17ffd15 	stw	r5,-12(fp)
 8230b74:	e1bffe15 	stw	r6,-8(fp)
 8230b78:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230b7c:	e0bffc17 	ldw	r2,-16(fp)
 8230b80:	10bff804 	addi	r2,r2,-32
 8230b84:	1085883a 	add	r2,r2,r2
 8230b88:	1085883a 	add	r2,r2,r2
 8230b8c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230b90:	008209b4 	movhi	r2,2086
 8230b94:	10b87704 	addi	r2,r2,-7716
 8230b98:	e0bff915 	stw	r2,-28(fp)
 8230b9c:	00000606 	br	8230bb8 <t_setsockopt+0x5c>
 8230ba0:	e0fff917 	ldw	r3,-28(fp)
 8230ba4:	e0bffa17 	ldw	r2,-24(fp)
 8230ba8:	18800626 	beq	r3,r2,8230bc4 <t_setsockopt+0x68>
 8230bac:	e0bff917 	ldw	r2,-28(fp)
 8230bb0:	10800017 	ldw	r2,0(r2)
 8230bb4:	e0bff915 	stw	r2,-28(fp)
 8230bb8:	e0bff917 	ldw	r2,-28(fp)
 8230bbc:	103ff81e 	bne	r2,zero,8230ba0 <t_setsockopt+0x44>
 8230bc0:	00000106 	br	8230bc8 <t_setsockopt+0x6c>
 8230bc4:	0001883a 	nop
 8230bc8:	e0fff917 	ldw	r3,-28(fp)
 8230bcc:	e0bffa17 	ldw	r2,-24(fp)
 8230bd0:	18800326 	beq	r3,r2,8230be0 <t_setsockopt+0x84>
 8230bd4:	822d2e00 	call	822d2e0 <dtrap>
 8230bd8:	00bfffc4 	movi	r2,-1
 8230bdc:	00004a06 	br	8230d08 <t_setsockopt+0x1ac>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230be0:	0009883a 	mov	r4,zero
 8230be4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   so->so_error = 0;
 8230be8:	e0bffa17 	ldw	r2,-24(fp)
 8230bec:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230bf0:	e0bffd17 	ldw	r2,-12(fp)
 8230bf4:	10800060 	cmpeqi	r2,r2,1
 8230bf8:	10000e1e 	bne	r2,zero,8230c34 <t_setsockopt+0xd8>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 8230bfc:	e1bfff17 	ldw	r6,-4(fp)
 8230c00:	e17ffe17 	ldw	r5,-8(fp)
 8230c04:	e13ffa17 	ldw	r4,-24(fp)
 8230c08:	8232e900 	call	8232e90 <sosetopt>
 8230c0c:	e0bffb15 	stw	r2,-20(fp)
 8230c10:	e0bffb17 	ldw	r2,-20(fp)
 8230c14:	10003926 	beq	r2,zero,8230cfc <t_setsockopt+0x1a0>
      {
         so->so_error = err;
 8230c18:	e0bffa17 	ldw	r2,-24(fp)
 8230c1c:	e0fffb17 	ldw	r3,-20(fp)
 8230c20:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230c24:	0009883a 	mov	r4,zero
 8230c28:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230c2c:	00bfffc4 	movi	r2,-1
 8230c30:	00003506 	br	8230d08 <t_setsockopt+0x1ac>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 8230c34:	e0bffa17 	ldw	r2,-24(fp)
 8230c38:	10801f17 	ldw	r2,124(r2)
 8230c3c:	10000f1e 	bne	r2,zero,8230c7c <t_setsockopt+0x120>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 8230c40:	01000104 	movi	r4,4
 8230c44:	822deb80 	call	822deb8 <npalloc>
 8230c48:	1007883a 	mov	r3,r2
 8230c4c:	e0bffa17 	ldw	r2,-24(fp)
 8230c50:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 8230c54:	e0bffa17 	ldw	r2,-24(fp)
 8230c58:	10801f17 	ldw	r2,124(r2)
 8230c5c:	1000071e 	bne	r2,zero,8230c7c <t_setsockopt+0x120>
         {
            so->so_error = ENOMEM;
 8230c60:	e0bffa17 	ldw	r2,-24(fp)
 8230c64:	00c00304 	movi	r3,12
 8230c68:	10c00615 	stw	r3,24(r2)
            UNLOCK_NET_RESOURCE (NET_RESID);
 8230c6c:	0009883a 	mov	r4,zero
 8230c70:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 8230c74:	00bfffc4 	movi	r2,-1
 8230c78:	00002306 	br	8230d08 <t_setsockopt+0x1ac>
         }
      }
      
      if (name == IP_TTL_OPT)
 8230c7c:	e0bffe17 	ldw	r2,-8(fp)
 8230c80:	10800118 	cmpnei	r2,r2,4
 8230c84:	1000061e 	bne	r2,zero,8230ca0 <t_setsockopt+0x144>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 8230c88:	e0bffa17 	ldw	r2,-24(fp)
 8230c8c:	10801f17 	ldw	r2,124(r2)
 8230c90:	e0ffff17 	ldw	r3,-4(fp)
 8230c94:	18c00017 	ldw	r3,0(r3)
 8230c98:	10c00045 	stb	r3,1(r2)
 8230c9c:	00001706 	br	8230cfc <t_setsockopt+0x1a0>
      else
      if (name == IP_TOS)
 8230ca0:	e0bffe17 	ldw	r2,-8(fp)
 8230ca4:	108000d8 	cmpnei	r2,r2,3
 8230ca8:	1000061e 	bne	r2,zero,8230cc4 <t_setsockopt+0x168>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 8230cac:	e0bffa17 	ldw	r2,-24(fp)
 8230cb0:	10801f17 	ldw	r2,124(r2)
 8230cb4:	e0ffff17 	ldw	r3,-4(fp)
 8230cb8:	18c00017 	ldw	r3,0(r3)
 8230cbc:	10c00005 	stb	r3,0(r2)
 8230cc0:	00000e06 	br	8230cfc <t_setsockopt+0x1a0>
	   else
	   if (name == IP_SCOPEID)
 8230cc4:	e0bffe17 	ldw	r2,-8(fp)
 8230cc8:	10800398 	cmpnei	r2,r2,14
 8230ccc:	1000071e 	bne	r2,zero,8230cec <t_setsockopt+0x190>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 8230cd0:	e0bffa17 	ldw	r2,-24(fp)
 8230cd4:	10801f17 	ldw	r2,124(r2)
 8230cd8:	e0ffff17 	ldw	r3,-4(fp)
 8230cdc:	18c00017 	ldw	r3,0(r3)
 8230ce0:	18c03fcc 	andi	r3,r3,255
 8230ce4:	10c00115 	stw	r3,4(r2)
 8230ce8:	00000406 	br	8230cfc <t_setsockopt+0x1a0>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230cec:	0009883a 	mov	r4,zero
 8230cf0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230cf4:	00bfffc4 	movi	r2,-1
 8230cf8:	00000306 	br	8230d08 <t_setsockopt+0x1ac>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230cfc:	0009883a 	mov	r4,zero
 8230d00:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return 0;
 8230d04:	0005883a 	mov	r2,zero
}
 8230d08:	e037883a 	mov	sp,fp
 8230d0c:	dfc00117 	ldw	ra,4(sp)
 8230d10:	df000017 	ldw	fp,0(sp)
 8230d14:	dec00204 	addi	sp,sp,8
 8230d18:	f800283a 	ret

08230d1c <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 8230d1c:	defff704 	addi	sp,sp,-36
 8230d20:	dfc00815 	stw	ra,32(sp)
 8230d24:	df000715 	stw	fp,28(sp)
 8230d28:	df000704 	addi	fp,sp,28
 8230d2c:	e13ffc15 	stw	r4,-16(fp)
 8230d30:	e17ffd15 	stw	r5,-12(fp)
 8230d34:	e1bffe15 	stw	r6,-8(fp)
 8230d38:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230d3c:	e0bffc17 	ldw	r2,-16(fp)
 8230d40:	10bff804 	addi	r2,r2,-32
 8230d44:	1085883a 	add	r2,r2,r2
 8230d48:	1085883a 	add	r2,r2,r2
 8230d4c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230d50:	008209b4 	movhi	r2,2086
 8230d54:	10b87704 	addi	r2,r2,-7716
 8230d58:	e0bff915 	stw	r2,-28(fp)
 8230d5c:	00000606 	br	8230d78 <t_getsockopt+0x5c>
 8230d60:	e0fff917 	ldw	r3,-28(fp)
 8230d64:	e0bffa17 	ldw	r2,-24(fp)
 8230d68:	18800626 	beq	r3,r2,8230d84 <t_getsockopt+0x68>
 8230d6c:	e0bff917 	ldw	r2,-28(fp)
 8230d70:	10800017 	ldw	r2,0(r2)
 8230d74:	e0bff915 	stw	r2,-28(fp)
 8230d78:	e0bff917 	ldw	r2,-28(fp)
 8230d7c:	103ff81e 	bne	r2,zero,8230d60 <t_getsockopt+0x44>
 8230d80:	00000106 	br	8230d88 <t_getsockopt+0x6c>
 8230d84:	0001883a 	nop
 8230d88:	e0fff917 	ldw	r3,-28(fp)
 8230d8c:	e0bffa17 	ldw	r2,-24(fp)
 8230d90:	18800326 	beq	r3,r2,8230da0 <t_getsockopt+0x84>
 8230d94:	822d2e00 	call	822d2e0 <dtrap>
 8230d98:	00bfffc4 	movi	r2,-1
 8230d9c:	00003d06 	br	8230e94 <t_getsockopt+0x178>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230da0:	0009883a 	mov	r4,zero
 8230da4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230da8:	e0bffd17 	ldw	r2,-12(fp)
 8230dac:	10800060 	cmpeqi	r2,r2,1
 8230db0:	10000e1e 	bne	r2,zero,8230dec <t_getsockopt+0xd0>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 8230db4:	e1bfff17 	ldw	r6,-4(fp)
 8230db8:	e17ffe17 	ldw	r5,-8(fp)
 8230dbc:	e13ffa17 	ldw	r4,-24(fp)
 8230dc0:	82332c00 	call	82332c0 <sogetopt>
 8230dc4:	e0bffb15 	stw	r2,-20(fp)
 8230dc8:	e0bffb17 	ldw	r2,-20(fp)
 8230dcc:	10002c26 	beq	r2,zero,8230e80 <t_getsockopt+0x164>
      {
         so->so_error = err;
 8230dd0:	e0bffa17 	ldw	r2,-24(fp)
 8230dd4:	e0fffb17 	ldw	r3,-20(fp)
 8230dd8:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230ddc:	0009883a 	mov	r4,zero
 8230de0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230de4:	00bfffc4 	movi	r2,-1
 8230de8:	00002a06 	br	8230e94 <t_getsockopt+0x178>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 8230dec:	e0bffe17 	ldw	r2,-8(fp)
 8230df0:	10800118 	cmpnei	r2,r2,4
 8230df4:	10000e1e 	bne	r2,zero,8230e30 <t_getsockopt+0x114>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 8230df8:	e0bffa17 	ldw	r2,-24(fp)
 8230dfc:	10801f17 	ldw	r2,124(r2)
 8230e00:	1000041e 	bne	r2,zero,8230e14 <t_getsockopt+0xf8>
 8230e04:	e0bfff17 	ldw	r2,-4(fp)
 8230e08:	00c01004 	movi	r3,64
 8230e0c:	10c00015 	stw	r3,0(r2)
 8230e10:	00001b06 	br	8230e80 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 8230e14:	e0bffa17 	ldw	r2,-24(fp)
 8230e18:	10801f17 	ldw	r2,124(r2)
 8230e1c:	10800043 	ldbu	r2,1(r2)
 8230e20:	10c03fcc 	andi	r3,r2,255
 8230e24:	e0bfff17 	ldw	r2,-4(fp)
 8230e28:	10c00015 	stw	r3,0(r2)
 8230e2c:	00001406 	br	8230e80 <t_getsockopt+0x164>
      }
      else if (name == IP_TOS)
 8230e30:	e0bffe17 	ldw	r2,-8(fp)
 8230e34:	108000d8 	cmpnei	r2,r2,3
 8230e38:	10000d1e 	bne	r2,zero,8230e70 <t_getsockopt+0x154>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 8230e3c:	e0bffa17 	ldw	r2,-24(fp)
 8230e40:	10801f17 	ldw	r2,124(r2)
 8230e44:	1000031e 	bne	r2,zero,8230e54 <t_getsockopt+0x138>
 8230e48:	e0bfff17 	ldw	r2,-4(fp)
 8230e4c:	10000015 	stw	zero,0(r2)
 8230e50:	00000b06 	br	8230e80 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 8230e54:	e0bffa17 	ldw	r2,-24(fp)
 8230e58:	10801f17 	ldw	r2,124(r2)
 8230e5c:	10800003 	ldbu	r2,0(r2)
 8230e60:	10c03fcc 	andi	r3,r2,255
 8230e64:	e0bfff17 	ldw	r2,-4(fp)
 8230e68:	10c00015 	stw	r3,0(r2)
 8230e6c:	00000406 	br	8230e80 <t_getsockopt+0x164>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230e70:	0009883a 	mov	r4,zero
 8230e74:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230e78:	00bfffc4 	movi	r2,-1
 8230e7c:	00000506 	br	8230e94 <t_getsockopt+0x178>
      }
   }   
   so->so_error = 0;
 8230e80:	e0bffa17 	ldw	r2,-24(fp)
 8230e84:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230e88:	0009883a 	mov	r4,zero
 8230e8c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return 0;
 8230e90:	0005883a 	mov	r2,zero
}
 8230e94:	e037883a 	mov	sp,fp
 8230e98:	dfc00117 	ldw	ra,4(sp)
 8230e9c:	df000017 	ldw	fp,0(sp)
 8230ea0:	dec00204 	addi	sp,sp,8
 8230ea4:	f800283a 	ret

08230ea8 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 8230ea8:	defff604 	addi	sp,sp,-40
 8230eac:	dfc00915 	stw	ra,36(sp)
 8230eb0:	df000815 	stw	fp,32(sp)
 8230eb4:	df000804 	addi	fp,sp,32
 8230eb8:	e13ffc15 	stw	r4,-16(fp)
 8230ebc:	e17ffd15 	stw	r5,-12(fp)
 8230ec0:	e1bffe15 	stw	r6,-8(fp)
 8230ec4:	e1ffff15 	stw	r7,-4(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 8230ec8:	e0bffe17 	ldw	r2,-8(fp)
 8230ecc:	e0bff915 	stw	r2,-28(fp)

   so = LONG2SO(s);
 8230ed0:	e0bffc17 	ldw	r2,-16(fp)
 8230ed4:	10bff804 	addi	r2,r2,-32
 8230ed8:	1085883a 	add	r2,r2,r2
 8230edc:	1085883a 	add	r2,r2,r2
 8230ee0:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 8230ee4:	e0bffa17 	ldw	r2,-24(fp)
 8230ee8:	1080088b 	ldhu	r2,34(r2)
 8230eec:	10bfffcc 	andi	r2,r2,65535
 8230ef0:	1080038c 	andi	r2,r2,14
 8230ef4:	108000a0 	cmpeqi	r2,r2,2
 8230ef8:	1000051e 	bne	r2,zero,8230f10 <t_recv+0x68>
   {
      so->so_error = EPIPE;
 8230efc:	e0bffa17 	ldw	r2,-24(fp)
 8230f00:	00c00804 	movi	r3,32
 8230f04:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230f08:	00bfffc4 	movi	r2,-1
 8230f0c:	00001906 	br	8230f74 <t_recv+0xcc>
   }
   so->so_error = 0;
 8230f10:	e0bffa17 	ldw	r2,-24(fp)
 8230f14:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8230f18:	0009883a 	mov	r4,zero
 8230f1c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 8230f20:	e0fffe04 	addi	r3,fp,-8
 8230f24:	e0bfff17 	ldw	r2,-4(fp)
 8230f28:	d8800015 	stw	r2,0(sp)
 8230f2c:	180f883a 	mov	r7,r3
 8230f30:	e1bffd17 	ldw	r6,-12(fp)
 8230f34:	000b883a 	mov	r5,zero
 8230f38:	e13ffa17 	ldw	r4,-24(fp)
 8230f3c:	82325b00 	call	82325b0 <soreceive>
 8230f40:	e0bffb15 	stw	r2,-20(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230f44:	0009883a 	mov	r4,zero
 8230f48:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if(err)
 8230f4c:	e0bffb17 	ldw	r2,-20(fp)
 8230f50:	10000526 	beq	r2,zero,8230f68 <t_recv+0xc0>
   {
      so->so_error = err;
 8230f54:	e0bffa17 	ldw	r2,-24(fp)
 8230f58:	e0fffb17 	ldw	r3,-20(fp)
 8230f5c:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230f60:	00bfffc4 	movi	r2,-1
 8230f64:	00000306 	br	8230f74 <t_recv+0xcc>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 8230f68:	e0bffe17 	ldw	r2,-8(fp)
 8230f6c:	e0fff917 	ldw	r3,-28(fp)
 8230f70:	1885c83a 	sub	r2,r3,r2
}
 8230f74:	e037883a 	mov	sp,fp
 8230f78:	dfc00117 	ldw	ra,4(sp)
 8230f7c:	df000017 	ldw	fp,0(sp)
 8230f80:	dec00204 	addi	sp,sp,8
 8230f84:	f800283a 	ret

08230f88 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 8230f88:	defff404 	addi	sp,sp,-48
 8230f8c:	dfc00b15 	stw	ra,44(sp)
 8230f90:	df000a15 	stw	fp,40(sp)
 8230f94:	df000a04 	addi	fp,sp,40
 8230f98:	e13ffc15 	stw	r4,-16(fp)
 8230f9c:	e17ffd15 	stw	r5,-12(fp)
 8230fa0:	e1bffe15 	stw	r6,-8(fp)
 8230fa4:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 8230fa8:	e03ffb15 	stw	zero,-20(fp)
   int   err;
   int   sendlen = len;
 8230fac:	e0bffe17 	ldw	r2,-8(fp)
 8230fb0:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 8230fb4:	e0bffc17 	ldw	r2,-16(fp)
 8230fb8:	10bff804 	addi	r2,r2,-32
 8230fbc:	1085883a 	add	r2,r2,r2
 8230fc0:	1085883a 	add	r2,r2,r2
 8230fc4:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8230fc8:	008209b4 	movhi	r2,2086
 8230fcc:	10b87704 	addi	r2,r2,-7716
 8230fd0:	e0bff715 	stw	r2,-36(fp)
 8230fd4:	00000606 	br	8230ff0 <t_recvfrom+0x68>
 8230fd8:	e0fff717 	ldw	r3,-36(fp)
 8230fdc:	e0bff917 	ldw	r2,-28(fp)
 8230fe0:	18800626 	beq	r3,r2,8230ffc <t_recvfrom+0x74>
 8230fe4:	e0bff717 	ldw	r2,-36(fp)
 8230fe8:	10800017 	ldw	r2,0(r2)
 8230fec:	e0bff715 	stw	r2,-36(fp)
 8230ff0:	e0bff717 	ldw	r2,-36(fp)
 8230ff4:	103ff81e 	bne	r2,zero,8230fd8 <t_recvfrom+0x50>
 8230ff8:	00000106 	br	8231000 <t_recvfrom+0x78>
 8230ffc:	0001883a 	nop
 8231000:	e0fff717 	ldw	r3,-36(fp)
 8231004:	e0bff917 	ldw	r2,-28(fp)
 8231008:	18800326 	beq	r3,r2,8231018 <t_recvfrom+0x90>
 823100c:	822d2e00 	call	822d2e0 <dtrap>
 8231010:	00bfffc4 	movi	r2,-1
 8231014:	00002706 	br	82310b4 <t_recvfrom+0x12c>
   so->so_error = 0;
 8231018:	e0bff917 	ldw	r2,-28(fp)
 823101c:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8231020:	0009883a 	mov	r4,zero
 8231024:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 8231028:	e13ffe04 	addi	r4,fp,-8
 823102c:	e0fffb04 	addi	r3,fp,-20
 8231030:	e0bfff17 	ldw	r2,-4(fp)
 8231034:	d8800015 	stw	r2,0(sp)
 8231038:	200f883a 	mov	r7,r4
 823103c:	e1bffd17 	ldw	r6,-12(fp)
 8231040:	180b883a 	mov	r5,r3
 8231044:	e13ff917 	ldw	r4,-28(fp)
 8231048:	82325b00 	call	82325b0 <soreceive>
 823104c:	e0bffa15 	stw	r2,-24(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 8231050:	e0bffb17 	ldw	r2,-20(fp)
 8231054:	10000b26 	beq	r2,zero,8231084 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 8231058:	e0bffb17 	ldw	r2,-20(fp)
 823105c:	10c00317 	ldw	r3,12(r2)
 8231060:	e0800317 	ldw	r2,12(fp)
 8231064:	10800017 	ldw	r2,0(r2)
 8231068:	100d883a 	mov	r6,r2
 823106c:	180b883a 	mov	r5,r3
 8231070:	e1000217 	ldw	r4,8(fp)
 8231074:	8202c5c0 	call	8202c5c <memcpy>
      m_freem (sender);
 8231078:	e0bffb17 	ldw	r2,-20(fp)
 823107c:	1009883a 	mov	r4,r2
 8231080:	822e3840 	call	822e384 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231084:	0009883a 	mov	r4,zero
 8231088:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if(err)
 823108c:	e0bffa17 	ldw	r2,-24(fp)
 8231090:	10000526 	beq	r2,zero,82310a8 <t_recvfrom+0x120>
   {
      so->so_error = err;
 8231094:	e0bff917 	ldw	r2,-28(fp)
 8231098:	e0fffa17 	ldw	r3,-24(fp)
 823109c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82310a0:	00bfffc4 	movi	r2,-1
 82310a4:	00000306 	br	82310b4 <t_recvfrom+0x12c>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 82310a8:	e0bffe17 	ldw	r2,-8(fp)
 82310ac:	e0fff817 	ldw	r3,-32(fp)
 82310b0:	1885c83a 	sub	r2,r3,r2
}
 82310b4:	e037883a 	mov	sp,fp
 82310b8:	dfc00117 	ldw	ra,4(sp)
 82310bc:	df000017 	ldw	fp,0(sp)
 82310c0:	dec00204 	addi	sp,sp,8
 82310c4:	f800283a 	ret

082310c8 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 82310c8:	defff404 	addi	sp,sp,-48
 82310cc:	dfc00b15 	stw	ra,44(sp)
 82310d0:	df000a15 	stw	fp,40(sp)
 82310d4:	df000a04 	addi	fp,sp,40
 82310d8:	e13ffc15 	stw	r4,-16(fp)
 82310dc:	e17ffd15 	stw	r5,-12(fp)
 82310e0:	e1bffe15 	stw	r6,-8(fp)
 82310e4:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 82310e8:	e0bffc17 	ldw	r2,-16(fp)
 82310ec:	10bff804 	addi	r2,r2,-32
 82310f0:	1085883a 	add	r2,r2,r2
 82310f4:	1085883a 	add	r2,r2,r2
 82310f8:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82310fc:	008209b4 	movhi	r2,2086
 8231100:	10b87704 	addi	r2,r2,-7716
 8231104:	e0bff815 	stw	r2,-32(fp)
 8231108:	00000606 	br	8231124 <t_sendto+0x5c>
 823110c:	e0fff817 	ldw	r3,-32(fp)
 8231110:	e0bff917 	ldw	r2,-28(fp)
 8231114:	18800626 	beq	r3,r2,8231130 <t_sendto+0x68>
 8231118:	e0bff817 	ldw	r2,-32(fp)
 823111c:	10800017 	ldw	r2,0(r2)
 8231120:	e0bff815 	stw	r2,-32(fp)
 8231124:	e0bff817 	ldw	r2,-32(fp)
 8231128:	103ff81e 	bne	r2,zero,823110c <t_sendto+0x44>
 823112c:	00000106 	br	8231134 <t_sendto+0x6c>
 8231130:	0001883a 	nop
 8231134:	e0fff817 	ldw	r3,-32(fp)
 8231138:	e0bff917 	ldw	r2,-28(fp)
 823113c:	18800326 	beq	r3,r2,823114c <t_sendto+0x84>
 8231140:	822d2e00 	call	822d2e0 <dtrap>
 8231144:	00bfffc4 	movi	r2,-1
 8231148:	00005706 	br	82312a8 <t_sendto+0x1e0>
   so->so_error = 0;
 823114c:	e0bff917 	ldw	r2,-28(fp)
 8231150:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 8231154:	e0bff917 	ldw	r2,-28(fp)
 8231158:	10800983 	ldbu	r2,38(r2)
 823115c:	10803fcc 	andi	r2,r2,255
 8231160:	1080201c 	xori	r2,r2,128
 8231164:	10bfe004 	addi	r2,r2,-128
 8231168:	10c000a0 	cmpeqi	r3,r2,2
 823116c:	18000a1e 	bne	r3,zero,8231198 <t_sendto+0xd0>
 8231170:	10c000e0 	cmpeqi	r3,r2,3
 8231174:	18000b1e 	bne	r3,zero,82311a4 <t_sendto+0xdc>
 8231178:	10800060 	cmpeqi	r2,r2,1
 823117c:	10001026 	beq	r2,zero,82311c0 <t_sendto+0xf8>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 8231180:	e1ffff17 	ldw	r7,-4(fp)
 8231184:	e1bffe17 	ldw	r6,-8(fp)
 8231188:	e17ffd17 	ldw	r5,-12(fp)
 823118c:	e13ffc17 	ldw	r4,-16(fp)
 8231190:	82312bc0 	call	82312bc <t_send>
 8231194:	00004406 	br	82312a8 <t_sendto+0x1e0>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 8231198:	82451f00 	call	82451f0 <udp_maxalloc>
 823119c:	e0bffb15 	stw	r2,-20(fp)
      break;
 82311a0:	00000d06 	br	82311d8 <t_sendto+0x110>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 82311a4:	e0bff917 	ldw	r2,-28(fp)
 82311a8:	10800417 	ldw	r2,16(r2)
 82311ac:	1088000c 	andi	r2,r2,8192
 82311b0:	1009883a 	mov	r4,r2
 82311b4:	8243ee00 	call	8243ee0 <ip_raw_maxalloc>
 82311b8:	e0bffb15 	stw	r2,-20(fp)
      break;
 82311bc:	00000606 	br	82311d8 <t_sendto+0x110>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 82311c0:	822d2e00 	call	822d2e0 <dtrap>
      so->so_error = EFAULT;
 82311c4:	e0bff917 	ldw	r2,-28(fp)
 82311c8:	00c00384 	movi	r3,14
 82311cc:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82311d0:	00bfffc4 	movi	r2,-1
 82311d4:	00003406 	br	82312a8 <t_sendto+0x1e0>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 82311d8:	e0fffb17 	ldw	r3,-20(fp)
 82311dc:	e0bffe17 	ldw	r2,-8(fp)
 82311e0:	1880050e 	bge	r3,r2,82311f8 <t_sendto+0x130>
   {
      so->so_error = EMSGSIZE;
 82311e4:	e0bff917 	ldw	r2,-28(fp)
 82311e8:	00c01e84 	movi	r3,122
 82311ec:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82311f0:	00bfffc4 	movi	r2,-1
 82311f4:	00002c06 	br	82312a8 <t_sendto+0x1e0>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 82311f8:	e0800217 	ldw	r2,8(fp)
 82311fc:	10000c26 	beq	r2,zero,8231230 <t_sendto+0x168>
   {
      name = sockargs(to, tolen, MT_SONAME);
 8231200:	01800244 	movi	r6,9
 8231204:	e1400317 	ldw	r5,12(fp)
 8231208:	e1000217 	ldw	r4,8(fp)
 823120c:	823165c0 	call	823165c <sockargs>
 8231210:	e0bff715 	stw	r2,-36(fp)
      if(name == NULL)
 8231214:	e0bff717 	ldw	r2,-36(fp)
 8231218:	1000061e 	bne	r2,zero,8231234 <t_sendto+0x16c>
      {
         so->so_error = ENOMEM;
 823121c:	e0bff917 	ldw	r2,-28(fp)
 8231220:	00c00304 	movi	r3,12
 8231224:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8231228:	00bfffc4 	movi	r2,-1
 823122c:	00001e06 	br	82312a8 <t_sendto+0x1e0>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 8231230:	e03ff715 	stw	zero,-36(fp)
   
   sendlen = len;
 8231234:	e0bffe17 	ldw	r2,-8(fp)
 8231238:	e0bffb15 	stw	r2,-20(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 823123c:	0009883a 	mov	r4,zero
 8231240:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 8231244:	e0fffb04 	addi	r3,fp,-20
 8231248:	e0bfff17 	ldw	r2,-4(fp)
 823124c:	d8800015 	stw	r2,0(sp)
 8231250:	180f883a 	mov	r7,r3
 8231254:	e1bffd17 	ldw	r6,-12(fp)
 8231258:	e17ff717 	ldw	r5,-36(fp)
 823125c:	e13ff917 	ldw	r4,-28(fp)
 8231260:	82320580 	call	8232058 <sosend>
 8231264:	e0bffa15 	stw	r2,-24(fp)

   if (name)
 8231268:	e0bff717 	ldw	r2,-36(fp)
 823126c:	10000226 	beq	r2,zero,8231278 <t_sendto+0x1b0>
      m_freem(name);
 8231270:	e13ff717 	ldw	r4,-36(fp)
 8231274:	822e3840 	call	822e384 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231278:	0009883a 	mov	r4,zero
 823127c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231280:	e0bffa17 	ldw	r2,-24(fp)
 8231284:	10000526 	beq	r2,zero,823129c <t_sendto+0x1d4>
   {
      so->so_error = err;
 8231288:	e0bff917 	ldw	r2,-28(fp)
 823128c:	e0fffa17 	ldw	r3,-24(fp)
 8231290:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231294:	00bfffc4 	movi	r2,-1
 8231298:	00000306 	br	82312a8 <t_sendto+0x1e0>
   }

   return (len - sendlen);
 823129c:	e0bffb17 	ldw	r2,-20(fp)
 82312a0:	e0fffe17 	ldw	r3,-8(fp)
 82312a4:	1885c83a 	sub	r2,r3,r2
}
 82312a8:	e037883a 	mov	sp,fp
 82312ac:	dfc00117 	ldw	ra,4(sp)
 82312b0:	df000017 	ldw	fp,0(sp)
 82312b4:	dec00204 	addi	sp,sp,8
 82312b8:	f800283a 	ret

082312bc <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 82312bc:	defff104 	addi	sp,sp,-60
 82312c0:	dfc00e15 	stw	ra,56(sp)
 82312c4:	df000d15 	stw	fp,52(sp)
 82312c8:	df000d04 	addi	fp,sp,52
 82312cc:	e13ffc15 	stw	r4,-16(fp)
 82312d0:	e17ffd15 	stw	r5,-12(fp)
 82312d4:	e1bffe15 	stw	r6,-8(fp)
 82312d8:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 82312dc:	e03ff515 	stw	zero,-44(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 82312e0:	e0bffc17 	ldw	r2,-16(fp)
 82312e4:	10bff804 	addi	r2,r2,-32
 82312e8:	1085883a 	add	r2,r2,r2
 82312ec:	1085883a 	add	r2,r2,r2
 82312f0:	e0bff715 	stw	r2,-36(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 82312f4:	e0bff717 	ldw	r2,-36(fp)
 82312f8:	1080088b 	ldhu	r2,34(r2)
 82312fc:	10bfffcc 	andi	r2,r2,65535
 8231300:	1080038c 	andi	r2,r2,14
 8231304:	108000a0 	cmpeqi	r2,r2,2
 8231308:	1000051e 	bne	r2,zero,8231320 <t_send+0x64>
   {
      so->so_error = EPIPE;
 823130c:	e0bff717 	ldw	r2,-36(fp)
 8231310:	00c00804 	movi	r3,32
 8231314:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231318:	00bfffc4 	movi	r2,-1
 823131c:	00006306 	br	82314ac <t_send+0x1f0>
   }
   so->so_error = 0;
 8231320:	e0bff717 	ldw	r2,-36(fp)
 8231324:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 8231328:	e0bff717 	ldw	r2,-36(fp)
 823132c:	10800983 	ldbu	r2,38(r2)
 8231330:	10803fcc 	andi	r2,r2,255
 8231334:	1080201c 	xori	r2,r2,128
 8231338:	10bfe004 	addi	r2,r2,-128
 823133c:	10800060 	cmpeqi	r2,r2,1
 8231340:	1000081e 	bne	r2,zero,8231364 <t_send+0xa8>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 8231344:	d8000115 	stw	zero,4(sp)
 8231348:	d8000015 	stw	zero,0(sp)
 823134c:	e1ffff17 	ldw	r7,-4(fp)
 8231350:	e1bffe17 	ldw	r6,-8(fp)
 8231354:	e17ffd17 	ldw	r5,-12(fp)
 8231358:	e13ffc17 	ldw	r4,-16(fp)
 823135c:	82310c80 	call	82310c8 <t_sendto>
 8231360:	00005206 	br	82314ac <t_send+0x1f0>

   maxpkt = TCP_MSS;
 8231364:	00816d04 	movi	r2,1460
 8231368:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 823136c:	e0bff717 	ldw	r2,-36(fp)
 8231370:	10800117 	ldw	r2,4(r2)
 8231374:	10004826 	beq	r2,zero,8231498 <t_send+0x1dc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 8231378:	e0bff717 	ldw	r2,-36(fp)
 823137c:	10800117 	ldw	r2,4(r2)
 8231380:	10800917 	ldw	r2,36(r2)
 8231384:	e0bff815 	stw	r2,-32(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 8231388:	e0bff817 	ldw	r2,-32(fp)
 823138c:	10800a0b 	ldhu	r2,40(r2)
 8231390:	10bfffcc 	andi	r2,r2,65535
 8231394:	10004026 	beq	r2,zero,8231498 <t_send+0x1dc>
         maxpkt = tp->t_maxseg;
 8231398:	e0bff817 	ldw	r2,-32(fp)
 823139c:	10800a0b 	ldhu	r2,40(r2)
 82313a0:	10bfffcc 	andi	r2,r2,65535
 82313a4:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 82313a8:	00003b06 	br	8231498 <t_send+0x1dc>
   {
      if (len > maxpkt)
 82313ac:	e0bffe17 	ldw	r2,-8(fp)
 82313b0:	e0fff617 	ldw	r3,-40(fp)
 82313b4:	1880030e 	bge	r3,r2,82313c4 <t_send+0x108>
         sendlen = maxpkt;  /* take biggest block we can */
 82313b8:	e0bff617 	ldw	r2,-40(fp)
 82313bc:	e0bffb15 	stw	r2,-20(fp)
 82313c0:	00000206 	br	82313cc <t_send+0x110>
      else
         sendlen = len;
 82313c4:	e0bffe17 	ldw	r2,-8(fp)
 82313c8:	e0bffb15 	stw	r2,-20(fp)
      sent = sendlen;
 82313cc:	e0bffb17 	ldw	r2,-20(fp)
 82313d0:	e0bff915 	stw	r2,-28(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 82313d4:	0009883a 	mov	r4,zero
 82313d8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 82313dc:	e0fffb04 	addi	r3,fp,-20
 82313e0:	e0bfff17 	ldw	r2,-4(fp)
 82313e4:	d8800015 	stw	r2,0(sp)
 82313e8:	180f883a 	mov	r7,r3
 82313ec:	e1bffd17 	ldw	r6,-12(fp)
 82313f0:	000b883a 	mov	r5,zero
 82313f4:	e13ff717 	ldw	r4,-36(fp)
 82313f8:	82320580 	call	8232058 <sosend>
 82313fc:	e0bffa15 	stw	r2,-24(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8231400:	0009883a 	mov	r4,zero
 8231404:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 8231408:	e0bffa17 	ldw	r2,-24(fp)
 823140c:	10001026 	beq	r2,zero,8231450 <t_send+0x194>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 8231410:	e0bffa17 	ldw	r2,-24(fp)
 8231414:	10801a60 	cmpeqi	r2,r2,105
 8231418:	1000031e 	bne	r2,zero,8231428 <t_send+0x16c>
 823141c:	e0bffa17 	ldw	r2,-24(fp)
 8231420:	108002d8 	cmpnei	r2,r2,11
 8231424:	1000051e 	bne	r2,zero,823143c <t_send+0x180>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 8231428:	e0bff517 	ldw	r2,-44(fp)
 823142c:	10000326 	beq	r2,zero,823143c <t_send+0x180>
            {
               so->so_error = 0;
 8231430:	e0bff717 	ldw	r2,-36(fp)
 8231434:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 8231438:	00001b06 	br	82314a8 <t_send+0x1ec>
            }
         }
         so->so_error = e;
 823143c:	e0bff717 	ldw	r2,-36(fp)
 8231440:	e0fffa17 	ldw	r3,-24(fp)
 8231444:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8231448:	00bfffc4 	movi	r2,-1
 823144c:	00001706 	br	82314ac <t_send+0x1f0>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 8231450:	e0bffb17 	ldw	r2,-20(fp)
 8231454:	1000131e 	bne	r2,zero,82314a4 <t_send+0x1e8>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 8231458:	e0bffb17 	ldw	r2,-20(fp)
 823145c:	e0fff917 	ldw	r3,-28(fp)
 8231460:	1885c83a 	sub	r2,r3,r2
 8231464:	e0bff915 	stw	r2,-28(fp)
      buf += sent;
 8231468:	e0bff917 	ldw	r2,-28(fp)
 823146c:	e0fffd17 	ldw	r3,-12(fp)
 8231470:	1885883a 	add	r2,r3,r2
 8231474:	e0bffd15 	stw	r2,-12(fp)
      len -= sent;
 8231478:	e0fffe17 	ldw	r3,-8(fp)
 823147c:	e0bff917 	ldw	r2,-28(fp)
 8231480:	1885c83a 	sub	r2,r3,r2
 8231484:	e0bffe15 	stw	r2,-8(fp)
      total_sent += sent;
 8231488:	e0fff517 	ldw	r3,-44(fp)
 823148c:	e0bff917 	ldw	r2,-28(fp)
 8231490:	1885883a 	add	r2,r3,r2
 8231494:	e0bff515 	stw	r2,-44(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 8231498:	e0bffe17 	ldw	r2,-8(fp)
 823149c:	103fc31e 	bne	r2,zero,82313ac <t_send+0xf0>
 82314a0:	00000106 	br	82314a8 <t_send+0x1ec>
         so->so_error = e;
         return SOCKET_ERROR;
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
         break;         /* break out of while(len) loop */
 82314a4:	0001883a 	nop
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 82314a8:	e0bff517 	ldw	r2,-44(fp)
}
 82314ac:	e037883a 	mov	sp,fp
 82314b0:	dfc00117 	ldw	ra,4(sp)
 82314b4:	df000017 	ldw	fp,0(sp)
 82314b8:	dec00204 	addi	sp,sp,8
 82314bc:	f800283a 	ret

082314c0 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 82314c0:	defff904 	addi	sp,sp,-28
 82314c4:	dfc00615 	stw	ra,24(sp)
 82314c8:	df000515 	stw	fp,20(sp)
 82314cc:	df000504 	addi	fp,sp,20
 82314d0:	e13ffe15 	stw	r4,-8(fp)
 82314d4:	e17fff15 	stw	r5,-4(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 82314d8:	e0bffe17 	ldw	r2,-8(fp)
 82314dc:	10bff804 	addi	r2,r2,-32
 82314e0:	1085883a 	add	r2,r2,r2
 82314e4:	1085883a 	add	r2,r2,r2
 82314e8:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 82314ec:	008209b4 	movhi	r2,2086
 82314f0:	10b87704 	addi	r2,r2,-7716
 82314f4:	e0bffb15 	stw	r2,-20(fp)
 82314f8:	00000606 	br	8231514 <t_shutdown+0x54>
 82314fc:	e0fffb17 	ldw	r3,-20(fp)
 8231500:	e0bffc17 	ldw	r2,-16(fp)
 8231504:	18800626 	beq	r3,r2,8231520 <t_shutdown+0x60>
 8231508:	e0bffb17 	ldw	r2,-20(fp)
 823150c:	10800017 	ldw	r2,0(r2)
 8231510:	e0bffb15 	stw	r2,-20(fp)
 8231514:	e0bffb17 	ldw	r2,-20(fp)
 8231518:	103ff81e 	bne	r2,zero,82314fc <t_shutdown+0x3c>
 823151c:	00000106 	br	8231524 <t_shutdown+0x64>
 8231520:	0001883a 	nop
 8231524:	e0fffb17 	ldw	r3,-20(fp)
 8231528:	e0bffc17 	ldw	r2,-16(fp)
 823152c:	18800326 	beq	r3,r2,823153c <t_shutdown+0x7c>
 8231530:	822d2e00 	call	822d2e0 <dtrap>
 8231534:	00bfffc4 	movi	r2,-1
 8231538:	00001206 	br	8231584 <t_shutdown+0xc4>
   so->so_error = 0;
 823153c:	e0bffc17 	ldw	r2,-16(fp)
 8231540:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 8231544:	0009883a 	mov	r4,zero
 8231548:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 823154c:	e17fff17 	ldw	r5,-4(fp)
 8231550:	e13ffc17 	ldw	r4,-16(fp)
 8231554:	8232cfc0 	call	8232cfc <soshutdown>
 8231558:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 823155c:	0009883a 	mov	r4,zero
 8231560:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231564:	e0bffd17 	ldw	r2,-12(fp)
 8231568:	10000526 	beq	r2,zero,8231580 <t_shutdown+0xc0>
   {
      so->so_error = err;
 823156c:	e0bffc17 	ldw	r2,-16(fp)
 8231570:	e0fffd17 	ldw	r3,-12(fp)
 8231574:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231578:	00bfffc4 	movi	r2,-1
 823157c:	00000106 	br	8231584 <t_shutdown+0xc4>
   }
   return 0;
 8231580:	0005883a 	mov	r2,zero
}
 8231584:	e037883a 	mov	sp,fp
 8231588:	dfc00117 	ldw	ra,4(sp)
 823158c:	df000017 	ldw	fp,0(sp)
 8231590:	dec00204 	addi	sp,sp,8
 8231594:	f800283a 	ret

08231598 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 8231598:	defffa04 	addi	sp,sp,-24
 823159c:	dfc00515 	stw	ra,20(sp)
 82315a0:	df000415 	stw	fp,16(sp)
 82315a4:	df000404 	addi	fp,sp,16
 82315a8:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 82315ac:	e0bfff17 	ldw	r2,-4(fp)
 82315b0:	10bff804 	addi	r2,r2,-32
 82315b4:	1085883a 	add	r2,r2,r2
 82315b8:	1085883a 	add	r2,r2,r2
 82315bc:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 82315c0:	008209b4 	movhi	r2,2086
 82315c4:	10b87704 	addi	r2,r2,-7716
 82315c8:	e0bffc15 	stw	r2,-16(fp)
 82315cc:	00000606 	br	82315e8 <t_socketclose+0x50>
 82315d0:	e0fffc17 	ldw	r3,-16(fp)
 82315d4:	e0bffd17 	ldw	r2,-12(fp)
 82315d8:	18800626 	beq	r3,r2,82315f4 <t_socketclose+0x5c>
 82315dc:	e0bffc17 	ldw	r2,-16(fp)
 82315e0:	10800017 	ldw	r2,0(r2)
 82315e4:	e0bffc15 	stw	r2,-16(fp)
 82315e8:	e0bffc17 	ldw	r2,-16(fp)
 82315ec:	103ff81e 	bne	r2,zero,82315d0 <t_socketclose+0x38>
 82315f0:	00000106 	br	82315f8 <t_socketclose+0x60>
 82315f4:	0001883a 	nop
 82315f8:	e0fffc17 	ldw	r3,-16(fp)
 82315fc:	e0bffd17 	ldw	r2,-12(fp)
 8231600:	18800326 	beq	r3,r2,8231610 <t_socketclose+0x78>
 8231604:	822d2e00 	call	822d2e0 <dtrap>
 8231608:	00bfffc4 	movi	r2,-1
 823160c:	00000e06 	br	8231648 <t_socketclose+0xb0>
   so->so_error = 0;
 8231610:	e0bffd17 	ldw	r2,-12(fp)
 8231614:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 8231618:	0009883a 	mov	r4,zero
 823161c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   err = soclose(so);
 8231620:	e13ffd17 	ldw	r4,-12(fp)
 8231624:	8231b640 	call	8231b64 <soclose>
 8231628:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 823162c:	0009883a 	mov	r4,zero
 8231630:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 8231634:	e0bffe17 	ldw	r2,-8(fp)
 8231638:	10000226 	beq	r2,zero,8231644 <t_socketclose+0xac>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 823163c:	00bfffc4 	movi	r2,-1
 8231640:	00000106 	br	8231648 <t_socketclose+0xb0>
   }
   return 0;
 8231644:	0005883a 	mov	r2,zero
}
 8231648:	e037883a 	mov	sp,fp
 823164c:	dfc00117 	ldw	ra,4(sp)
 8231650:	df000017 	ldw	fp,0(sp)
 8231654:	dec00204 	addi	sp,sp,8
 8231658:	f800283a 	ret

0823165c <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 823165c:	defffa04 	addi	sp,sp,-24
 8231660:	dfc00515 	stw	ra,20(sp)
 8231664:	df000415 	stw	fp,16(sp)
 8231668:	df000404 	addi	fp,sp,16
 823166c:	e13ffd15 	stw	r4,-12(fp)
 8231670:	e17ffe15 	stw	r5,-8(fp)
 8231674:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 8231678:	0009883a 	mov	r4,zero
 823167c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 8231680:	e17ffe17 	ldw	r5,-8(fp)
 8231684:	e13fff17 	ldw	r4,-4(fp)
 8231688:	822e0f40 	call	822e0f4 <m_getnbuf>
 823168c:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231690:	0009883a 	mov	r4,zero
 8231694:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 8231698:	e0bffc17 	ldw	r2,-16(fp)
 823169c:	1000021e 	bne	r2,zero,82316a8 <sockargs+0x4c>
      return NULL;
 82316a0:	0005883a 	mov	r2,zero
 82316a4:	00000b06 	br	82316d4 <sockargs+0x78>
   m->m_len = arglen;
 82316a8:	e0fffe17 	ldw	r3,-8(fp)
 82316ac:	e0bffc17 	ldw	r2,-16(fp)
 82316b0:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 82316b4:	e0bffc17 	ldw	r2,-16(fp)
 82316b8:	10800317 	ldw	r2,12(r2)
 82316bc:	e0fffe17 	ldw	r3,-8(fp)
 82316c0:	180d883a 	mov	r6,r3
 82316c4:	e17ffd17 	ldw	r5,-12(fp)
 82316c8:	1009883a 	mov	r4,r2
 82316cc:	8202c5c0 	call	8202c5c <memcpy>
   return m;
 82316d0:	e0bffc17 	ldw	r2,-16(fp)
}
 82316d4:	e037883a 	mov	sp,fp
 82316d8:	dfc00117 	ldw	ra,4(sp)
 82316dc:	df000017 	ldw	fp,0(sp)
 82316e0:	dec00204 	addi	sp,sp,8
 82316e4:	f800283a 	ret

082316e8 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 82316e8:	defffa04 	addi	sp,sp,-24
 82316ec:	dfc00515 	stw	ra,20(sp)
 82316f0:	df000415 	stw	fp,16(sp)
 82316f4:	df000404 	addi	fp,sp,16
 82316f8:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 82316fc:	e0bfff17 	ldw	r2,-4(fp)
 8231700:	10bff804 	addi	r2,r2,-32
 8231704:	1085883a 	add	r2,r2,r2
 8231708:	1085883a 	add	r2,r2,r2
 823170c:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 8231710:	00801b04 	movi	r2,108
 8231714:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 8231718:	0009883a 	mov	r4,zero
 823171c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231720:	008209b4 	movhi	r2,2086
 8231724:	10b87704 	addi	r2,r2,-7716
 8231728:	e0bffc15 	stw	r2,-16(fp)
 823172c:	00000a06 	br	8231758 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 8231730:	e0fffc17 	ldw	r3,-16(fp)
 8231734:	e0bffe17 	ldw	r2,-8(fp)
 8231738:	1880041e 	bne	r3,r2,823174c <t_errno+0x64>
      {
         errcode = so->so_error;
 823173c:	e0bffe17 	ldw	r2,-8(fp)
 8231740:	10800617 	ldw	r2,24(r2)
 8231744:	e0bffd15 	stw	r2,-12(fp)
         break;
 8231748:	00000506 	br	8231760 <t_errno+0x78>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 823174c:	e0bffc17 	ldw	r2,-16(fp)
 8231750:	10800017 	ldw	r2,0(r2)
 8231754:	e0bffc15 	stw	r2,-16(fp)
 8231758:	e0bffc17 	ldw	r2,-16(fp)
 823175c:	103ff41e 	bne	r2,zero,8231730 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231760:	0009883a 	mov	r4,zero
 8231764:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   return errcode;
 8231768:	e0bffd17 	ldw	r2,-12(fp)
}
 823176c:	e037883a 	mov	sp,fp
 8231770:	dfc00117 	ldw	ra,4(sp)
 8231774:	df000017 	ldw	fp,0(sp)
 8231778:	dec00204 	addi	sp,sp,8
 823177c:	f800283a 	ret

08231780 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 8231780:	defff704 	addi	sp,sp,-36
 8231784:	dfc00815 	stw	ra,32(sp)
 8231788:	df000715 	stw	fp,28(sp)
 823178c:	df000704 	addi	fp,sp,28
 8231790:	e13ffd15 	stw	r4,-12(fp)
 8231794:	e17ffe15 	stw	r5,-8(fp)
 8231798:	e1bfff15 	stw	r6,-4(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 823179c:	e0bfff17 	ldw	r2,-4(fp)
 82317a0:	10000626 	beq	r2,zero,82317bc <socreate+0x3c>
      prp = pffindproto(dom, proto, type);
 82317a4:	e1bffe17 	ldw	r6,-8(fp)
 82317a8:	e17fff17 	ldw	r5,-4(fp)
 82317ac:	e13ffd17 	ldw	r4,-12(fp)
 82317b0:	822e0300 	call	822e030 <pffindproto>
 82317b4:	e0bff915 	stw	r2,-28(fp)
 82317b8:	00000406 	br	82317cc <socreate+0x4c>
   else
      prp = pffindtype(dom, type);
 82317bc:	e17ffe17 	ldw	r5,-8(fp)
 82317c0:	e13ffd17 	ldw	r4,-12(fp)
 82317c4:	822dfa00 	call	822dfa0 <pffindtype>
 82317c8:	e0bff915 	stw	r2,-28(fp)
   if (prp == 0)
 82317cc:	e0bff917 	ldw	r2,-28(fp)
 82317d0:	1000021e 	bne	r2,zero,82317dc <socreate+0x5c>
      return NULL;
 82317d4:	0005883a 	mov	r2,zero
 82317d8:	00004e06 	br	8231914 <socreate+0x194>
   if (prp->pr_type != type)
 82317dc:	e0bff917 	ldw	r2,-28(fp)
 82317e0:	1080000b 	ldhu	r2,0(r2)
 82317e4:	10ffffcc 	andi	r3,r2,65535
 82317e8:	18e0001c 	xori	r3,r3,32768
 82317ec:	18e00004 	addi	r3,r3,-32768
 82317f0:	e0bffe17 	ldw	r2,-8(fp)
 82317f4:	18800226 	beq	r3,r2,8231800 <socreate+0x80>
      return NULL;
 82317f8:	0005883a 	mov	r2,zero
 82317fc:	00004506 	br	8231914 <socreate+0x194>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8231800:	01002104 	movi	r4,132
 8231804:	822deb80 	call	822deb8 <npalloc>
 8231808:	e0bffa15 	stw	r2,-24(fp)
 823180c:	e0bffa17 	ldw	r2,-24(fp)
 8231810:	1000021e 	bne	r2,zero,823181c <socreate+0x9c>
      return NULL;
 8231814:	0005883a 	mov	r2,zero
 8231818:	00003e06 	br	8231914 <socreate+0x194>
   so->next = NULL;
 823181c:	e0bffa17 	ldw	r2,-24(fp)
 8231820:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 8231824:	e17ffa17 	ldw	r5,-24(fp)
 8231828:	010209b4 	movhi	r4,2086
 823182c:	21387704 	addi	r4,r4,-7716
 8231830:	822ccc80 	call	822ccc8 <putq>

   so->so_options = socket_defaults;
 8231834:	d0a03c0b 	ldhu	r2,-32528(gp)
 8231838:	10ffffcc 	andi	r3,r2,65535
 823183c:	e0bffa17 	ldw	r2,-24(fp)
 8231840:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 8231844:	e0bffa17 	ldw	r2,-24(fp)
 8231848:	e0fffd17 	ldw	r3,-12(fp)
 823184c:	10c00515 	stw	r3,20(r2)
   so->so_state = 0;
 8231850:	e0bffa17 	ldw	r2,-24(fp)
 8231854:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 8231858:	e0bffe17 	ldw	r2,-8(fp)
 823185c:	1007883a 	mov	r3,r2
 8231860:	e0bffa17 	ldw	r2,-24(fp)
 8231864:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 8231868:	e0bffa17 	ldw	r2,-24(fp)
 823186c:	e0fff917 	ldw	r3,-28(fp)
 8231870:	10c00215 	stw	r3,8(r2)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 8231874:	e0bffa17 	ldw	r2,-24(fp)
 8231878:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 823187c:	e0bffa17 	ldw	r2,-24(fp)
 8231880:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 8231884:	e0bff917 	ldw	r2,-28(fp)
 8231888:	10800317 	ldw	r2,12(r2)
 823188c:	e0ffff17 	ldw	r3,-4(fp)
 8231890:	180d883a 	mov	r6,r3
 8231894:	000b883a 	mov	r5,zero
 8231898:	e13ffa17 	ldw	r4,-24(fp)
 823189c:	103ee83a 	callr	r2
 82318a0:	e0bffb15 	stw	r2,-20(fp)
   if (error) goto bad;
 82318a4:	e0bffb17 	ldw	r2,-20(fp)
 82318a8:	10000a1e 	bne	r2,zero,82318d4 <socreate+0x154>

   if (so_evtmap)
 82318ac:	d0a0ce03 	ldbu	r2,-31944(gp)
 82318b0:	10803fcc 	andi	r2,r2,255
 82318b4:	10001626 	beq	r2,zero,8231910 <socreate+0x190>
   {                       
      rc = (*so_evtmap_create) (so);
 82318b8:	d0a0cc17 	ldw	r2,-31952(gp)
 82318bc:	e13ffa17 	ldw	r4,-24(fp)
 82318c0:	103ee83a 	callr	r2
 82318c4:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0)
 82318c8:	e0bffc17 	ldw	r2,-16(fp)
 82318cc:	10000c26 	beq	r2,zero,8231900 <socreate+0x180>
 82318d0:	00000106 	br	82318d8 <socreate+0x158>
   so->inp_moptions = NULL;
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
   if (error) goto bad;
 82318d4:	0001883a 	nop
   {                       
      rc = (*so_evtmap_create) (so);
      if (rc != 0)
      {
bad:   
         so->so_state |= SS_NOFDREF;
 82318d8:	e0bffa17 	ldw	r2,-24(fp)
 82318dc:	1080088b 	ldhu	r2,34(r2)
 82318e0:	10800054 	ori	r2,r2,1
 82318e4:	1007883a 	mov	r3,r2
 82318e8:	e0bffa17 	ldw	r2,-24(fp)
 82318ec:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 82318f0:	e13ffa17 	ldw	r4,-24(fp)
 82318f4:	8231a540 	call	8231a54 <sofree>
         return NULL;   
 82318f8:	0005883a 	mov	r2,zero
 82318fc:	00000506 	br	8231914 <socreate+0x194>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 8231900:	82294ec0 	call	82294ec <TK_OSTaskQuery>
 8231904:	1007883a 	mov	r3,r2
 8231908:	e0bffa17 	ldw	r2,-24(fp)
 823190c:	10c02005 	stb	r3,128(r2)
   }

   return so;
 8231910:	e0bffa17 	ldw	r2,-24(fp)
}
 8231914:	e037883a 	mov	sp,fp
 8231918:	dfc00117 	ldw	ra,4(sp)
 823191c:	df000017 	ldw	fp,0(sp)
 8231920:	dec00204 	addi	sp,sp,8
 8231924:	f800283a 	ret

08231928 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 8231928:	defffb04 	addi	sp,sp,-20
 823192c:	dfc00415 	stw	ra,16(sp)
 8231930:	df000315 	stw	fp,12(sp)
 8231934:	df000304 	addi	fp,sp,12
 8231938:	e13ffe15 	stw	r4,-8(fp)
 823193c:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 8231940:	e0bffe17 	ldw	r2,-8(fp)
 8231944:	00c00084 	movi	r3,2
 8231948:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 823194c:	e0bffe17 	ldw	r2,-8(fp)
 8231950:	10800217 	ldw	r2,8(r2)
 8231954:	10800317 	ldw	r2,12(r2)
 8231958:	e1bfff17 	ldw	r6,-4(fp)
 823195c:	000b883a 	mov	r5,zero
 8231960:	e13ffe17 	ldw	r4,-8(fp)
 8231964:	103ee83a 	callr	r2
 8231968:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 823196c:	e0bffd17 	ldw	r2,-12(fp)
}
 8231970:	e037883a 	mov	sp,fp
 8231974:	dfc00117 	ldw	ra,4(sp)
 8231978:	df000017 	ldw	fp,0(sp)
 823197c:	dec00204 	addi	sp,sp,8
 8231980:	f800283a 	ret

08231984 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 8231984:	defffb04 	addi	sp,sp,-20
 8231988:	dfc00415 	stw	ra,16(sp)
 823198c:	df000315 	stw	fp,12(sp)
 8231990:	df000304 	addi	fp,sp,12
 8231994:	e13ffe15 	stw	r4,-8(fp)
 8231998:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 823199c:	e0bffe17 	ldw	r2,-8(fp)
 82319a0:	00c000c4 	movi	r3,3
 82319a4:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so,
 82319a8:	e0bffe17 	ldw	r2,-8(fp)
 82319ac:	10800217 	ldw	r2,8(r2)
 82319b0:	10800317 	ldw	r2,12(r2)
 82319b4:	000d883a 	mov	r6,zero
 82319b8:	000b883a 	mov	r5,zero
 82319bc:	e13ffe17 	ldw	r4,-8(fp)
 82319c0:	103ee83a 	callr	r2
 82319c4:	e0bffd15 	stw	r2,-12(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 82319c8:	e0bffd17 	ldw	r2,-12(fp)
 82319cc:	10000226 	beq	r2,zero,82319d8 <solisten+0x54>
   {
      return (error);
 82319d0:	e0bffd17 	ldw	r2,-12(fp)
 82319d4:	00001a06 	br	8231a40 <solisten+0xbc>
   }
   if (so->so_q == 0) 
 82319d8:	e0bffe17 	ldw	r2,-8(fp)
 82319dc:	10801d17 	ldw	r2,116(r2)
 82319e0:	10000b1e 	bne	r2,zero,8231a10 <solisten+0x8c>
   {
      so->so_q = so;
 82319e4:	e0bffe17 	ldw	r2,-8(fp)
 82319e8:	e0fffe17 	ldw	r3,-8(fp)
 82319ec:	10c01d15 	stw	r3,116(r2)
      so->so_q0 = so;
 82319f0:	e0bffe17 	ldw	r2,-8(fp)
 82319f4:	e0fffe17 	ldw	r3,-8(fp)
 82319f8:	10c01c15 	stw	r3,112(r2)
      so->so_options |= SO_ACCEPTCONN;
 82319fc:	e0bffe17 	ldw	r2,-8(fp)
 8231a00:	10800417 	ldw	r2,16(r2)
 8231a04:	10c00094 	ori	r3,r2,2
 8231a08:	e0bffe17 	ldw	r2,-8(fp)
 8231a0c:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 8231a10:	e0bfff17 	ldw	r2,-4(fp)
 8231a14:	1000010e 	bge	r2,zero,8231a1c <solisten+0x98>
      backlog = 0;
 8231a18:	e03fff15 	stw	zero,-4(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 8231a1c:	e0bfff17 	ldw	r2,-4(fp)
 8231a20:	10800188 	cmpgei	r2,r2,6
 8231a24:	1000021e 	bne	r2,zero,8231a30 <solisten+0xac>
 8231a28:	e0bfff17 	ldw	r2,-4(fp)
 8231a2c:	00000106 	br	8231a34 <solisten+0xb0>
 8231a30:	00800144 	movi	r2,5
 8231a34:	e0fffe17 	ldw	r3,-8(fp)
 8231a38:	18801e85 	stb	r2,122(r3)
   return 0;
 8231a3c:	0005883a 	mov	r2,zero
}
 8231a40:	e037883a 	mov	sp,fp
 8231a44:	dfc00117 	ldw	ra,4(sp)
 8231a48:	df000017 	ldw	fp,0(sp)
 8231a4c:	dec00204 	addi	sp,sp,8
 8231a50:	f800283a 	ret

08231a54 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 8231a54:	defffd04 	addi	sp,sp,-12
 8231a58:	dfc00215 	stw	ra,8(sp)
 8231a5c:	df000115 	stw	fp,4(sp)
 8231a60:	df000104 	addi	fp,sp,4
 8231a64:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 8231a68:	e0bfff17 	ldw	r2,-4(fp)
 8231a6c:	10800117 	ldw	r2,4(r2)
 8231a70:	1000361e 	bne	r2,zero,8231b4c <sofree+0xf8>
 8231a74:	e0bfff17 	ldw	r2,-4(fp)
 8231a78:	1080088b 	ldhu	r2,34(r2)
 8231a7c:	10bfffcc 	andi	r2,r2,65535
 8231a80:	1080004c 	andi	r2,r2,1
 8231a84:	10003126 	beq	r2,zero,8231b4c <sofree+0xf8>
      return;
   if (so->so_head) 
 8231a88:	e0bfff17 	ldw	r2,-4(fp)
 8231a8c:	10801b17 	ldw	r2,108(r2)
 8231a90:	10000d26 	beq	r2,zero,8231ac8 <sofree+0x74>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 8231a94:	000b883a 	mov	r5,zero
 8231a98:	e13fff17 	ldw	r4,-4(fp)
 8231a9c:	8233d300 	call	8233d30 <soqremque>
 8231aa0:	1000071e 	bne	r2,zero,8231ac0 <sofree+0x6c>
 8231aa4:	01400044 	movi	r5,1
 8231aa8:	e13fff17 	ldw	r4,-4(fp)
 8231aac:	8233d300 	call	8233d30 <soqremque>
 8231ab0:	1000031e 	bne	r2,zero,8231ac0 <sofree+0x6c>
         panic("sofree");
 8231ab4:	01020974 	movhi	r4,2085
 8231ab8:	21029504 	addi	r4,r4,2644
 8231abc:	82289940 	call	8228994 <panic>
      so->so_head = 0;
 8231ac0:	e0bfff17 	ldw	r2,-4(fp)
 8231ac4:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 8231ac8:	e0bfff17 	ldw	r2,-4(fp)
 8231acc:	10801204 	addi	r2,r2,72
 8231ad0:	1009883a 	mov	r4,r2
 8231ad4:	82340f40 	call	82340f4 <sbrelease>
   sorflush(so);
 8231ad8:	e13fff17 	ldw	r4,-4(fp)
 8231adc:	8232d940 	call	8232d94 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 8231ae0:	e0bfff17 	ldw	r2,-4(fp)
 8231ae4:	10800317 	ldw	r2,12(r2)
 8231ae8:	10000426 	beq	r2,zero,8231afc <sofree+0xa8>
	   ip_freemoptions(so->inp_moptions);
 8231aec:	e0bfff17 	ldw	r2,-4(fp)
 8231af0:	10800317 	ldw	r2,12(r2)
 8231af4:	1009883a 	mov	r4,r2
 8231af8:	82463c80 	call	82463c8 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 8231afc:	e0bfff17 	ldw	r2,-4(fp)
 8231b00:	10801f17 	ldw	r2,124(r2)
 8231b04:	10000426 	beq	r2,zero,8231b18 <sofree+0xc4>
      SOCOPT_FREE(so->so_optsPack);
 8231b08:	e0bfff17 	ldw	r2,-4(fp)
 8231b0c:	10801f17 	ldw	r2,124(r2)
 8231b10:	1009883a 	mov	r4,r2
 8231b14:	822deec0 	call	822deec <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8231b18:	e17fff17 	ldw	r5,-4(fp)
 8231b1c:	010209b4 	movhi	r4,2086
 8231b20:	21387704 	addi	r4,r4,-7716
 8231b24:	822cd780 	call	822cd78 <qdel>
   
   if (so_evtmap)  
 8231b28:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231b2c:	10803fcc 	andi	r2,r2,255
 8231b30:	10000326 	beq	r2,zero,8231b40 <sofree+0xec>
      (*so_evtmap_delete) (so);
 8231b34:	d0a0cd17 	ldw	r2,-31948(gp)
 8231b38:	e13fff17 	ldw	r4,-4(fp)
 8231b3c:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 8231b40:	e13fff17 	ldw	r4,-4(fp)
 8231b44:	822deec0 	call	822deec <npfree>
 8231b48:	00000106 	br	8231b50 <sofree+0xfc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
      return;
 8231b4c:	0001883a 	nop
   
   if (so_evtmap)  
      (*so_evtmap_delete) (so);
   
   SOC_FREE(so);
}
 8231b50:	e037883a 	mov	sp,fp
 8231b54:	dfc00117 	ldw	ra,4(sp)
 8231b58:	df000017 	ldw	fp,0(sp)
 8231b5c:	dec00204 	addi	sp,sp,8
 8231b60:	f800283a 	ret

08231b64 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 8231b64:	defff904 	addi	sp,sp,-28
 8231b68:	dfc00615 	stw	ra,24(sp)
 8231b6c:	df000515 	stw	fp,20(sp)
 8231b70:	df000504 	addi	fp,sp,20
 8231b74:	e13fff15 	stw	r4,-4(fp)
   int   error =  0;
 8231b78:	e03ffb15 	stw	zero,-20(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231b7c:	008209b4 	movhi	r2,2086
 8231b80:	10b87704 	addi	r2,r2,-7716
 8231b84:	10800017 	ldw	r2,0(r2)
 8231b88:	e0bffc15 	stw	r2,-16(fp)
 8231b8c:	00000606 	br	8231ba8 <soclose+0x44>
   {
      if (so == tmpso)
 8231b90:	e0ffff17 	ldw	r3,-4(fp)
 8231b94:	e0bffc17 	ldw	r2,-16(fp)
 8231b98:	18800626 	beq	r3,r2,8231bb4 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231b9c:	e0bffc17 	ldw	r2,-16(fp)
 8231ba0:	10800017 	ldw	r2,0(r2)
 8231ba4:	e0bffc15 	stw	r2,-16(fp)
 8231ba8:	e0bffc17 	ldw	r2,-16(fp)
 8231bac:	103ff81e 	bne	r2,zero,8231b90 <soclose+0x2c>
 8231bb0:	00000106 	br	8231bb8 <soclose+0x54>
   {
      if (so == tmpso)
         break;
 8231bb4:	0001883a 	nop
   }
   if ( tmpso == NULL)
 8231bb8:	e0bffc17 	ldw	r2,-16(fp)
 8231bbc:	1000021e 	bne	r2,zero,8231bc8 <soclose+0x64>
      return EINVAL;
 8231bc0:	00800584 	movi	r2,22
 8231bc4:	00009106 	br	8231e0c <soclose+0x2a8>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 8231bc8:	e0bfff17 	ldw	r2,-4(fp)
 8231bcc:	10800417 	ldw	r2,16(r2)
 8231bd0:	1080008c 	andi	r2,r2,2
 8231bd4:	10001226 	beq	r2,zero,8231c20 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 8231bd8:	00000406 	br	8231bec <soclose+0x88>
         (void) soabort(so->so_q0);
 8231bdc:	e0bfff17 	ldw	r2,-4(fp)
 8231be0:	10801c17 	ldw	r2,112(r2)
 8231be4:	1009883a 	mov	r4,r2
 8231be8:	8231e200 	call	8231e20 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 8231bec:	e0bfff17 	ldw	r2,-4(fp)
 8231bf0:	10c01c17 	ldw	r3,112(r2)
 8231bf4:	e0bfff17 	ldw	r2,-4(fp)
 8231bf8:	18bff81e 	bne	r3,r2,8231bdc <soclose+0x78>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231bfc:	00000406 	br	8231c10 <soclose+0xac>
         (void) soabort(so->so_q);
 8231c00:	e0bfff17 	ldw	r2,-4(fp)
 8231c04:	10801d17 	ldw	r2,116(r2)
 8231c08:	1009883a 	mov	r4,r2
 8231c0c:	8231e200 	call	8231e20 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231c10:	e0bfff17 	ldw	r2,-4(fp)
 8231c14:	10c01d17 	ldw	r3,116(r2)
 8231c18:	e0bfff17 	ldw	r2,-4(fp)
 8231c1c:	18bff81e 	bne	r3,r2,8231c00 <soclose+0x9c>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 8231c20:	e0bfff17 	ldw	r2,-4(fp)
 8231c24:	10800983 	ldbu	r2,38(r2)
 8231c28:	10803fcc 	andi	r2,r2,255
 8231c2c:	1080201c 	xori	r2,r2,128
 8231c30:	10bfe004 	addi	r2,r2,-128
 8231c34:	10800060 	cmpeqi	r2,r2,1
 8231c38:	10000c1e 	bne	r2,zero,8231c6c <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 8231c3c:	e0bfff17 	ldw	r2,-4(fp)
 8231c40:	00c00044 	movi	r3,1
 8231c44:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so,
 8231c48:	e0bfff17 	ldw	r2,-4(fp)
 8231c4c:	10800217 	ldw	r2,8(r2)
 8231c50:	10800317 	ldw	r2,12(r2)
 8231c54:	000d883a 	mov	r6,zero
 8231c58:	000b883a 	mov	r5,zero
 8231c5c:	e13fff17 	ldw	r4,-4(fp)
 8231c60:	103ee83a 	callr	r2
 8231c64:	e0bffb15 	stw	r2,-20(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 8231c68:	00005906 	br	8231dd0 <soclose+0x26c>
   }

   if (so->so_pcb == 0)
 8231c6c:	e0bfff17 	ldw	r2,-4(fp)
 8231c70:	10800117 	ldw	r2,4(r2)
 8231c74:	10005526 	beq	r2,zero,8231dcc <soclose+0x268>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 8231c78:	e0bfff17 	ldw	r2,-4(fp)
 8231c7c:	1080088b 	ldhu	r2,34(r2)
 8231c80:	10bfffcc 	andi	r2,r2,65535
 8231c84:	1080008c 	andi	r2,r2,2
 8231c88:	10003d26 	beq	r2,zero,8231d80 <soclose+0x21c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 8231c8c:	e0bfff17 	ldw	r2,-4(fp)
 8231c90:	1080088b 	ldhu	r2,34(r2)
 8231c94:	10bfffcc 	andi	r2,r2,65535
 8231c98:	1080020c 	andi	r2,r2,8
 8231c9c:	1000051e 	bne	r2,zero,8231cb4 <soclose+0x150>
      {
         error = sodisconnect(so);
 8231ca0:	e13fff17 	ldw	r4,-4(fp)
 8231ca4:	8231fc00 	call	8231fc0 <sodisconnect>
 8231ca8:	e0bffb15 	stw	r2,-20(fp)
         if (error)
 8231cac:	e0bffb17 	ldw	r2,-20(fp)
 8231cb0:	1000301e 	bne	r2,zero,8231d74 <soclose+0x210>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 8231cb4:	e0bfff17 	ldw	r2,-4(fp)
 8231cb8:	10800417 	ldw	r2,16(r2)
 8231cbc:	1080200c 	andi	r2,r2,128
 8231cc0:	10002126 	beq	r2,zero,8231d48 <soclose+0x1e4>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231cc4:	e0bfff17 	ldw	r2,-4(fp)
 8231cc8:	1080088b 	ldhu	r2,34(r2)
 8231ccc:	10bfffcc 	andi	r2,r2,65535
 8231cd0:	1080020c 	andi	r2,r2,8
 8231cd4:	10000526 	beq	r2,zero,8231cec <soclose+0x188>
             (so->so_state & SS_NBIO))
 8231cd8:	e0bfff17 	ldw	r2,-4(fp)
 8231cdc:	1080088b 	ldhu	r2,34(r2)
 8231ce0:	10bfffcc 	andi	r2,r2,65535
 8231ce4:	1080400c 	andi	r2,r2,256
         if (error)
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231ce8:	1000241e 	bne	r2,zero,8231d7c <soclose+0x218>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 8231cec:	e0bfff17 	ldw	r2,-4(fp)
 8231cf0:	1080080b 	ldhu	r2,32(r2)
 8231cf4:	10bfffcc 	andi	r2,r2,65535
 8231cf8:	10a0001c 	xori	r2,r2,32768
 8231cfc:	10a00004 	addi	r2,r2,-32768
 8231d00:	10c01924 	muli	r3,r2,100
 8231d04:	d0a0a817 	ldw	r2,-32096(gp)
 8231d08:	1885883a 	add	r2,r3,r2
 8231d0c:	e0bffd15 	stw	r2,-12(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231d10:	00000406 	br	8231d24 <soclose+0x1c0>
         {
            tcp_sleep((char *)&so->so_timeo);
 8231d14:	e0bfff17 	ldw	r2,-4(fp)
 8231d18:	10800904 	addi	r2,r2,36
 8231d1c:	1009883a 	mov	r4,r2
 8231d20:	82292800 	call	8229280 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231d24:	e0bfff17 	ldw	r2,-4(fp)
 8231d28:	1080088b 	ldhu	r2,34(r2)
 8231d2c:	10bfffcc 	andi	r2,r2,65535
 8231d30:	1080008c 	andi	r2,r2,2
 8231d34:	10001226 	beq	r2,zero,8231d80 <soclose+0x21c>
 8231d38:	d0e0a817 	ldw	r3,-32096(gp)
 8231d3c:	e0bffd17 	ldw	r2,-12(fp)
 8231d40:	18bff436 	bltu	r3,r2,8231d14 <soclose+0x1b0>
 8231d44:	00000e06 	br	8231d80 <soclose+0x21c>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 8231d48:	e0bfff17 	ldw	r2,-4(fp)
 8231d4c:	10801217 	ldw	r2,72(r2)
 8231d50:	10000b26 	beq	r2,zero,8231d80 <soclose+0x21c>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 8231d54:	e0bfff17 	ldw	r2,-4(fp)
 8231d58:	1080088b 	ldhu	r2,34(r2)
 8231d5c:	10800054 	ori	r2,r2,1
 8231d60:	1007883a 	mov	r3,r2
 8231d64:	e0bfff17 	ldw	r2,-4(fp)
 8231d68:	10c0088d 	sth	r3,34(r2)
            return 0;
 8231d6c:	0005883a 	mov	r2,zero
 8231d70:	00002606 	br	8231e0c <soclose+0x2a8>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
      {
         error = sodisconnect(so);
         if (error)
            goto drop;
 8231d74:	0001883a 	nop
 8231d78:	00000106 	br	8231d80 <soclose+0x21c>
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
             (so->so_state & SS_NBIO))
         {
            goto drop;
 8231d7c:	0001883a 	nop
            return 0;
         }
      }
   }
drop:
   if (so->so_pcb) 
 8231d80:	e0bfff17 	ldw	r2,-4(fp)
 8231d84:	10800117 	ldw	r2,4(r2)
 8231d88:	10001126 	beq	r2,zero,8231dd0 <soclose+0x26c>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 8231d8c:	e0bfff17 	ldw	r2,-4(fp)
 8231d90:	00c00044 	movi	r3,1
 8231d94:	10c00715 	stw	r3,28(r2)
      error2 = (*so->so_proto->pr_usrreq)(so,
 8231d98:	e0bfff17 	ldw	r2,-4(fp)
 8231d9c:	10800217 	ldw	r2,8(r2)
 8231da0:	10800317 	ldw	r2,12(r2)
 8231da4:	000d883a 	mov	r6,zero
 8231da8:	000b883a 	mov	r5,zero
 8231dac:	e13fff17 	ldw	r4,-4(fp)
 8231db0:	103ee83a 	callr	r2
 8231db4:	e0bffe15 	stw	r2,-8(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 8231db8:	e0bffb17 	ldw	r2,-20(fp)
 8231dbc:	1000041e 	bne	r2,zero,8231dd0 <soclose+0x26c>
         error = error2;
 8231dc0:	e0bffe17 	ldw	r2,-8(fp)
 8231dc4:	e0bffb15 	stw	r2,-20(fp)
 8231dc8:	00000106 	br	8231dd0 <soclose+0x26c>
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
   }

   if (so->so_pcb == 0)
      goto discard;
 8231dcc:	0001883a 	nop
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
         error = error2;
   }
discard:
   if (so->so_state & SS_NOFDREF)
 8231dd0:	e0bfff17 	ldw	r2,-4(fp)
 8231dd4:	1080088b 	ldhu	r2,34(r2)
 8231dd8:	10bfffcc 	andi	r2,r2,65535
 8231ddc:	1080004c 	andi	r2,r2,1
 8231de0:	10000126 	beq	r2,zero,8231de8 <soclose+0x284>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 8231de4:	822d2e00 	call	822d2e0 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 8231de8:	e0bfff17 	ldw	r2,-4(fp)
 8231dec:	1080088b 	ldhu	r2,34(r2)
 8231df0:	10800054 	ori	r2,r2,1
 8231df4:	1007883a 	mov	r3,r2
 8231df8:	e0bfff17 	ldw	r2,-4(fp)
 8231dfc:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 8231e00:	e13fff17 	ldw	r4,-4(fp)
 8231e04:	8231a540 	call	8231a54 <sofree>
   return (error);
 8231e08:	e0bffb17 	ldw	r2,-20(fp)
}
 8231e0c:	e037883a 	mov	sp,fp
 8231e10:	dfc00117 	ldw	ra,4(sp)
 8231e14:	df000017 	ldw	fp,0(sp)
 8231e18:	dec00204 	addi	sp,sp,8
 8231e1c:	f800283a 	ret

08231e20 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 8231e20:	defffd04 	addi	sp,sp,-12
 8231e24:	dfc00215 	stw	ra,8(sp)
 8231e28:	df000115 	stw	fp,4(sp)
 8231e2c:	df000104 	addi	fp,sp,4
 8231e30:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 8231e34:	e0bfff17 	ldw	r2,-4(fp)
 8231e38:	00c00284 	movi	r3,10
 8231e3c:	10c00715 	stw	r3,28(r2)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8231e40:	e0bfff17 	ldw	r2,-4(fp)
 8231e44:	10800217 	ldw	r2,8(r2)
 8231e48:	10800317 	ldw	r2,12(r2)
 8231e4c:	000d883a 	mov	r6,zero
 8231e50:	000b883a 	mov	r5,zero
 8231e54:	e13fff17 	ldw	r4,-4(fp)
 8231e58:	103ee83a 	callr	r2
}
 8231e5c:	e037883a 	mov	sp,fp
 8231e60:	dfc00117 	ldw	ra,4(sp)
 8231e64:	df000017 	ldw	fp,0(sp)
 8231e68:	dec00204 	addi	sp,sp,8
 8231e6c:	f800283a 	ret

08231e70 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 8231e70:	defffb04 	addi	sp,sp,-20
 8231e74:	dfc00415 	stw	ra,16(sp)
 8231e78:	df000315 	stw	fp,12(sp)
 8231e7c:	df000304 	addi	fp,sp,12
 8231e80:	e13ffe15 	stw	r4,-8(fp)
 8231e84:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 8231e88:	e0bffe17 	ldw	r2,-8(fp)
 8231e8c:	1080088b 	ldhu	r2,34(r2)
 8231e90:	10bfffcc 	andi	r2,r2,65535
 8231e94:	1080004c 	andi	r2,r2,1
 8231e98:	1000031e 	bne	r2,zero,8231ea8 <soaccept+0x38>
      panic("soaccept");
 8231e9c:	01020974 	movhi	r4,2085
 8231ea0:	21029704 	addi	r4,r4,2652
 8231ea4:	82289940 	call	8228994 <panic>
   so->so_state &= ~SS_NOFDREF;
 8231ea8:	e0bffe17 	ldw	r2,-8(fp)
 8231eac:	10c0088b 	ldhu	r3,34(r2)
 8231eb0:	00bfff84 	movi	r2,-2
 8231eb4:	1884703a 	and	r2,r3,r2
 8231eb8:	1007883a 	mov	r3,r2
 8231ebc:	e0bffe17 	ldw	r2,-8(fp)
 8231ec0:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 8231ec4:	e0bffe17 	ldw	r2,-8(fp)
 8231ec8:	00c00144 	movi	r3,5
 8231ecc:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231ed0:	e0bffe17 	ldw	r2,-8(fp)
 8231ed4:	10800217 	ldw	r2,8(r2)
 8231ed8:	10800317 	ldw	r2,12(r2)
 8231edc:	e1bfff17 	ldw	r6,-4(fp)
 8231ee0:	000b883a 	mov	r5,zero
 8231ee4:	e13ffe17 	ldw	r4,-8(fp)
 8231ee8:	103ee83a 	callr	r2
 8231eec:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 8231ef0:	e0bffd17 	ldw	r2,-12(fp)
}
 8231ef4:	e037883a 	mov	sp,fp
 8231ef8:	dfc00117 	ldw	ra,4(sp)
 8231efc:	df000017 	ldw	fp,0(sp)
 8231f00:	dec00204 	addi	sp,sp,8
 8231f04:	f800283a 	ret

08231f08 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 8231f08:	defffb04 	addi	sp,sp,-20
 8231f0c:	dfc00415 	stw	ra,16(sp)
 8231f10:	df000315 	stw	fp,12(sp)
 8231f14:	df000304 	addi	fp,sp,12
 8231f18:	e13ffe15 	stw	r4,-8(fp)
 8231f1c:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 8231f20:	e0bffe17 	ldw	r2,-8(fp)
 8231f24:	10800417 	ldw	r2,16(r2)
 8231f28:	1080008c 	andi	r2,r2,2
 8231f2c:	10000226 	beq	r2,zero,8231f38 <soconnect+0x30>
      return (EOPNOTSUPP);
 8231f30:	008017c4 	movi	r2,95
 8231f34:	00001d06 	br	8231fac <soconnect+0xa4>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8231f38:	e0bffe17 	ldw	r2,-8(fp)
 8231f3c:	1080088b 	ldhu	r2,34(r2)
 8231f40:	10bfffcc 	andi	r2,r2,65535
 8231f44:	1080018c 	andi	r2,r2,6
 8231f48:	10000c26 	beq	r2,zero,8231f7c <soconnect+0x74>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8231f4c:	e0bffe17 	ldw	r2,-8(fp)
 8231f50:	10800217 	ldw	r2,8(r2)
 8231f54:	1080010b 	ldhu	r2,4(r2)
 8231f58:	10bfffcc 	andi	r2,r2,65535
 8231f5c:	1080010c 	andi	r2,r2,4
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8231f60:	1000031e 	bne	r2,zero,8231f70 <soconnect+0x68>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
 8231f64:	e13ffe17 	ldw	r4,-8(fp)
 8231f68:	8231fc00 	call	8231fc0 <sodisconnect>
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8231f6c:	10000326 	beq	r2,zero,8231f7c <soconnect+0x74>
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 8231f70:	00801fc4 	movi	r2,127
 8231f74:	e0bffd15 	stw	r2,-12(fp)
 8231f78:	00000b06 	br	8231fa8 <soconnect+0xa0>
   }
   else
   {
      so->so_req = PRU_CONNECT;
 8231f7c:	e0bffe17 	ldw	r2,-8(fp)
 8231f80:	00c00104 	movi	r3,4
 8231f84:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231f88:	e0bffe17 	ldw	r2,-8(fp)
 8231f8c:	10800217 	ldw	r2,8(r2)
 8231f90:	10800317 	ldw	r2,12(r2)
 8231f94:	e1bfff17 	ldw	r6,-4(fp)
 8231f98:	000b883a 	mov	r5,zero
 8231f9c:	e13ffe17 	ldw	r4,-8(fp)
 8231fa0:	103ee83a 	callr	r2
 8231fa4:	e0bffd15 	stw	r2,-12(fp)
   }
   return error;
 8231fa8:	e0bffd17 	ldw	r2,-12(fp)
}
 8231fac:	e037883a 	mov	sp,fp
 8231fb0:	dfc00117 	ldw	ra,4(sp)
 8231fb4:	df000017 	ldw	fp,0(sp)
 8231fb8:	dec00204 	addi	sp,sp,8
 8231fbc:	f800283a 	ret

08231fc0 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 8231fc0:	defffc04 	addi	sp,sp,-16
 8231fc4:	dfc00315 	stw	ra,12(sp)
 8231fc8:	df000215 	stw	fp,8(sp)
 8231fcc:	df000204 	addi	fp,sp,8
 8231fd0:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 8231fd4:	e0bfff17 	ldw	r2,-4(fp)
 8231fd8:	1080088b 	ldhu	r2,34(r2)
 8231fdc:	10bfffcc 	andi	r2,r2,65535
 8231fe0:	1080008c 	andi	r2,r2,2
 8231fe4:	1000031e 	bne	r2,zero,8231ff4 <sodisconnect+0x34>
   {
      error = ENOTCONN;
 8231fe8:	00802004 	movi	r2,128
 8231fec:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8231ff0:	00001306 	br	8232040 <sodisconnect+0x80>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 8231ff4:	e0bfff17 	ldw	r2,-4(fp)
 8231ff8:	1080088b 	ldhu	r2,34(r2)
 8231ffc:	10bfffcc 	andi	r2,r2,65535
 8232000:	1080020c 	andi	r2,r2,8
 8232004:	10000326 	beq	r2,zero,8232014 <sodisconnect+0x54>
   {
      error = EALREADY;
 8232008:	00801e04 	movi	r2,120
 823200c:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8232010:	00000b06 	br	8232040 <sodisconnect+0x80>
   }
   so->so_req = PRU_DISCONNECT;
 8232014:	e0bfff17 	ldw	r2,-4(fp)
 8232018:	00c00184 	movi	r3,6
 823201c:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8232020:	e0bfff17 	ldw	r2,-4(fp)
 8232024:	10800217 	ldw	r2,8(r2)
 8232028:	10800317 	ldw	r2,12(r2)
 823202c:	000d883a 	mov	r6,zero
 8232030:	000b883a 	mov	r5,zero
 8232034:	e13fff17 	ldw	r4,-4(fp)
 8232038:	103ee83a 	callr	r2
 823203c:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 8232040:	e0bffe17 	ldw	r2,-8(fp)
}
 8232044:	e037883a 	mov	sp,fp
 8232048:	dfc00117 	ldw	ra,4(sp)
 823204c:	df000017 	ldw	fp,0(sp)
 8232050:	dec00204 	addi	sp,sp,8
 8232054:	f800283a 	ret

08232058 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 8232058:	defff204 	addi	sp,sp,-56
 823205c:	dfc00d15 	stw	ra,52(sp)
 8232060:	df000c15 	stw	fp,48(sp)
 8232064:	df000c04 	addi	fp,sp,48
 8232068:	e13ffc15 	stw	r4,-16(fp)
 823206c:	e17ffd15 	stw	r5,-12(fp)
 8232070:	e1bffe15 	stw	r6,-8(fp)
 8232074:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 8232078:	e03ff415 	stw	zero,-48(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 823207c:	e03ff815 	stw	zero,-32(fp)
   int   dontroute;
   int   first = 1;
 8232080:	00800044 	movi	r2,1
 8232084:	e0bff915 	stw	r2,-28(fp)

   resid = *data_length;
 8232088:	e0bfff17 	ldw	r2,-4(fp)
 823208c:	10800017 	ldw	r2,0(r2)
 8232090:	e0bff715 	stw	r2,-36(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 8232094:	e0bff717 	ldw	r2,-36(fp)
 8232098:	1000020e 	bge	r2,zero,82320a4 <sosend+0x4c>
      return (EINVAL);
 823209c:	00800584 	movi	r2,22
 82320a0:	00013e06 	br	823259c <sosend+0x544>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 82320a4:	e0bffc17 	ldw	r2,-16(fp)
 82320a8:	10800217 	ldw	r2,8(r2)
 82320ac:	1080010b 	ldhu	r2,4(r2)
 82320b0:	10bfffcc 	andi	r2,r2,65535
 82320b4:	1080004c 	andi	r2,r2,1
 82320b8:	10000726 	beq	r2,zero,82320d8 <sosend+0x80>
 82320bc:	e0bffc17 	ldw	r2,-16(fp)
 82320c0:	10801317 	ldw	r2,76(r2)
 82320c4:	1007883a 	mov	r3,r2
 82320c8:	e0bff717 	ldw	r2,-36(fp)
 82320cc:	1880020e 	bge	r3,r2,82320d8 <sosend+0x80>
      return (EMSGSIZE);
 82320d0:	00801e84 	movi	r2,122
 82320d4:	00013106 	br	823259c <sosend+0x544>

   dontroute = (flags & MSG_DONTROUTE) &&
 82320d8:	e0800217 	ldw	r2,8(fp)
 82320dc:	1080010c 	andi	r2,r2,4
               ((so->so_options & SO_DONTROUTE) == 0) &&
 82320e0:	10000c26 	beq	r2,zero,8232114 <sosend+0xbc>
 82320e4:	e0bffc17 	ldw	r2,-16(fp)
 82320e8:	10800417 	ldw	r2,16(r2)
 82320ec:	1080040c 	andi	r2,r2,16
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 82320f0:	1000081e 	bne	r2,zero,8232114 <sosend+0xbc>
               ((so->so_options & SO_DONTROUTE) == 0) &&
               (so->so_proto->pr_flags & PR_ATOMIC);
 82320f4:	e0bffc17 	ldw	r2,-16(fp)
 82320f8:	10800217 	ldw	r2,8(r2)
 82320fc:	1080010b 	ldhu	r2,4(r2)
 8232100:	10bfffcc 	andi	r2,r2,65535
 8232104:	1080004c 	andi	r2,r2,1

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
               ((so->so_options & SO_DONTROUTE) == 0) &&
 8232108:	10000226 	beq	r2,zero,8232114 <sosend+0xbc>
 823210c:	00800044 	movi	r2,1
 8232110:	00000106 	br	8232118 <sosend+0xc0>
 8232114:	0005883a 	mov	r2,zero
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 8232118:	e0bffa15 	stw	r2,-24(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 823211c:	00000406 	br	8232130 <sosend+0xd8>
 8232120:	e0bffc17 	ldw	r2,-16(fp)
 8232124:	10801904 	addi	r2,r2,100
 8232128:	1009883a 	mov	r4,r2
 823212c:	82292800 	call	8229280 <tcp_sleep>
 8232130:	e0bffc17 	ldw	r2,-16(fp)
 8232134:	1080190b 	ldhu	r2,100(r2)
 8232138:	10bfffcc 	andi	r2,r2,65535
 823213c:	1080004c 	andi	r2,r2,1
 8232140:	103ff71e 	bne	r2,zero,8232120 <sosend+0xc8>
 8232144:	e0bffc17 	ldw	r2,-16(fp)
 8232148:	1080190b 	ldhu	r2,100(r2)
 823214c:	10800054 	ori	r2,r2,1
 8232150:	1007883a 	mov	r3,r2
 8232154:	e0bffc17 	ldw	r2,-16(fp)
 8232158:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 823215c:	e0bffc17 	ldw	r2,-16(fp)
 8232160:	10800617 	ldw	r2,24(r2)
 8232164:	10000626 	beq	r2,zero,8232180 <sosend+0x128>
      {
         error = so->so_error;
 8232168:	e0bffc17 	ldw	r2,-16(fp)
 823216c:	10800617 	ldw	r2,24(r2)
 8232170:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;          /* ??? */
 8232174:	e0bffc17 	ldw	r2,-16(fp)
 8232178:	10000615 	stw	zero,24(r2)
         goto release;
 823217c:	0000f706 	br	823255c <sosend+0x504>
      }
      if (so->so_state & SS_CANTSENDMORE)
 8232180:	e0bffc17 	ldw	r2,-16(fp)
 8232184:	1080088b 	ldhu	r2,34(r2)
 8232188:	10bfffcc 	andi	r2,r2,65535
 823218c:	1080040c 	andi	r2,r2,16
 8232190:	10000326 	beq	r2,zero,82321a0 <sosend+0x148>
         snderr(EPIPE);
 8232194:	00800804 	movi	r2,32
 8232198:	e0bff815 	stw	r2,-32(fp)
 823219c:	0000ef06 	br	823255c <sosend+0x504>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 82321a0:	e0bffc17 	ldw	r2,-16(fp)
 82321a4:	1080088b 	ldhu	r2,34(r2)
 82321a8:	10bfffcc 	andi	r2,r2,65535
 82321ac:	1080008c 	andi	r2,r2,2
 82321b0:	10000e1e 	bne	r2,zero,82321ec <sosend+0x194>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 82321b4:	e0bffc17 	ldw	r2,-16(fp)
 82321b8:	10800217 	ldw	r2,8(r2)
 82321bc:	1080010b 	ldhu	r2,4(r2)
 82321c0:	10bfffcc 	andi	r2,r2,65535
 82321c4:	1080010c 	andi	r2,r2,4
 82321c8:	10000326 	beq	r2,zero,82321d8 <sosend+0x180>
            snderr(ENOTCONN);
 82321cc:	00802004 	movi	r2,128
 82321d0:	e0bff815 	stw	r2,-32(fp)
 82321d4:	0000e106 	br	823255c <sosend+0x504>
         if (nam == 0)
 82321d8:	e0bffd17 	ldw	r2,-12(fp)
 82321dc:	1000031e 	bne	r2,zero,82321ec <sosend+0x194>
            snderr(EDESTADDRREQ);
 82321e0:	00801e44 	movi	r2,121
 82321e4:	e0bff815 	stw	r2,-32(fp)
 82321e8:	0000dc06 	br	823255c <sosend+0x504>
      }
      if (flags & MSG_OOB)
 82321ec:	e0800217 	ldw	r2,8(fp)
 82321f0:	1080004c 	andi	r2,r2,1
 82321f4:	10000326 	beq	r2,zero,8232204 <sosend+0x1ac>
         space = 1024;
 82321f8:	00810004 	movi	r2,1024
 82321fc:	e0bff615 	stw	r2,-40(fp)
 8232200:	00004706 	br	8232320 <sosend+0x2c8>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 8232204:	e0bffc17 	ldw	r2,-16(fp)
 8232208:	10801317 	ldw	r2,76(r2)
 823220c:	1007883a 	mov	r3,r2
 8232210:	e0bffc17 	ldw	r2,-16(fp)
 8232214:	10801217 	ldw	r2,72(r2)
 8232218:	1885c83a 	sub	r2,r3,r2
 823221c:	10000616 	blt	r2,zero,8232238 <sosend+0x1e0>
 8232220:	e0bffc17 	ldw	r2,-16(fp)
 8232224:	10c01317 	ldw	r3,76(r2)
 8232228:	e0bffc17 	ldw	r2,-16(fp)
 823222c:	10801217 	ldw	r2,72(r2)
 8232230:	1885c83a 	sub	r2,r3,r2
 8232234:	00000106 	br	823223c <sosend+0x1e4>
 8232238:	0005883a 	mov	r2,zero
 823223c:	e0bff615 	stw	r2,-40(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 8232240:	e0bffc17 	ldw	r2,-16(fp)
 8232244:	10800217 	ldw	r2,8(r2)
 8232248:	1080010b 	ldhu	r2,4(r2)
 823224c:	10bfffcc 	andi	r2,r2,65535
 8232250:	1080004c 	andi	r2,r2,1
 8232254:	10000326 	beq	r2,zero,8232264 <sosend+0x20c>
 8232258:	e0fff617 	ldw	r3,-40(fp)
 823225c:	e0bff717 	ldw	r2,-36(fp)
 8232260:	18801216 	blt	r3,r2,82322ac <sosend+0x254>
 8232264:	e0bff717 	ldw	r2,-36(fp)
 8232268:	10815e10 	cmplti	r2,r2,1400
 823226c:	10002c1e 	bne	r2,zero,8232320 <sosend+0x2c8>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232270:	e0bff617 	ldw	r2,-40(fp)
 8232274:	10815e08 	cmpgei	r2,r2,1400
 8232278:	1000291e 	bne	r2,zero,8232320 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
 823227c:	e0bffc17 	ldw	r2,-16(fp)
 8232280:	10801217 	ldw	r2,72(r2)
         space = 1024;
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232284:	10815e30 	cmpltui	r2,r2,1400
 8232288:	1000251e 	bne	r2,zero,8232320 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 823228c:	e0bffc17 	ldw	r2,-16(fp)
 8232290:	1080088b 	ldhu	r2,34(r2)
 8232294:	10bfffcc 	andi	r2,r2,65535
 8232298:	1080400c 	andi	r2,r2,256
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
 823229c:	1000201e 	bne	r2,zero,8232320 <sosend+0x2c8>
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
 82322a0:	e0800217 	ldw	r2,8(fp)
 82322a4:	1080080c 	andi	r2,r2,32
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 82322a8:	10001d1e 	bne	r2,zero,8232320 <sosend+0x2c8>
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 82322ac:	e0bffc17 	ldw	r2,-16(fp)
 82322b0:	1080088b 	ldhu	r2,34(r2)
 82322b4:	10bfffcc 	andi	r2,r2,65535
 82322b8:	1080400c 	andi	r2,r2,256
 82322bc:	1000031e 	bne	r2,zero,82322cc <sosend+0x274>
 82322c0:	e0800217 	ldw	r2,8(fp)
 82322c4:	1080080c 	andi	r2,r2,32
 82322c8:	10000526 	beq	r2,zero,82322e0 <sosend+0x288>
            {
               if (first)
 82322cc:	e0bff917 	ldw	r2,-28(fp)
 82322d0:	10009d26 	beq	r2,zero,8232548 <sosend+0x4f0>
                  error = EWOULDBLOCK;
 82322d4:	008002c4 	movi	r2,11
 82322d8:	e0bff815 	stw	r2,-32(fp)
               goto release;
 82322dc:	00009a06 	br	8232548 <sosend+0x4f0>
            }
            sbunlock(&so->so_snd);
 82322e0:	e0bffc17 	ldw	r2,-16(fp)
 82322e4:	10c0190b 	ldhu	r3,100(r2)
 82322e8:	00bfff84 	movi	r2,-2
 82322ec:	1884703a 	and	r2,r3,r2
 82322f0:	1007883a 	mov	r3,r2
 82322f4:	e0bffc17 	ldw	r2,-16(fp)
 82322f8:	10c0190d 	sth	r3,100(r2)
 82322fc:	e0bffc17 	ldw	r2,-16(fp)
 8232300:	10801904 	addi	r2,r2,100
 8232304:	1009883a 	mov	r4,r2
 8232308:	82293f40 	call	82293f4 <tcp_wakeup>
            sbwait(&so->so_snd);
 823230c:	e0bffc17 	ldw	r2,-16(fp)
 8232310:	10801204 	addi	r2,r2,72
 8232314:	1009883a 	mov	r4,r2
 8232318:	8233f240 	call	8233f24 <sbwait>
            goto restart;
 823231c:	003f7f06 	br	823211c <sosend+0xc4>
         }
      }
      if ( space <= 0 ) 
 8232320:	e0bff617 	ldw	r2,-40(fp)
 8232324:	00805e16 	blt	zero,r2,82324a0 <sosend+0x448>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 8232328:	e0bffc17 	ldw	r2,-16(fp)
 823232c:	1080088b 	ldhu	r2,34(r2)
 8232330:	10bfffcc 	andi	r2,r2,65535
 8232334:	1080400c 	andi	r2,r2,256
 8232338:	1000031e 	bne	r2,zero,8232348 <sosend+0x2f0>
 823233c:	e0800217 	ldw	r2,8(fp)
 8232340:	1080080c 	andi	r2,r2,32
 8232344:	10000526 	beq	r2,zero,823235c <sosend+0x304>
         {
            if (first)     /* report first error */
 8232348:	e0bff917 	ldw	r2,-28(fp)
 823234c:	10008026 	beq	r2,zero,8232550 <sosend+0x4f8>
               error = EWOULDBLOCK;
 8232350:	008002c4 	movi	r2,11
 8232354:	e0bff815 	stw	r2,-32(fp)
            goto release;
 8232358:	00007d06 	br	8232550 <sosend+0x4f8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 823235c:	e0bffc17 	ldw	r2,-16(fp)
 8232360:	10c0190b 	ldhu	r3,100(r2)
 8232364:	00bfff84 	movi	r2,-2
 8232368:	1884703a 	and	r2,r3,r2
 823236c:	1007883a 	mov	r3,r2
 8232370:	e0bffc17 	ldw	r2,-16(fp)
 8232374:	10c0190d 	sth	r3,100(r2)
 8232378:	e0bffc17 	ldw	r2,-16(fp)
 823237c:	10801904 	addi	r2,r2,100
 8232380:	1009883a 	mov	r4,r2
 8232384:	82293f40 	call	82293f4 <tcp_wakeup>
         sbwait(&so->so_snd);
 8232388:	e0bffc17 	ldw	r2,-16(fp)
 823238c:	10801204 	addi	r2,r2,72
 8232390:	1009883a 	mov	r4,r2
 8232394:	8233f240 	call	8233f24 <sbwait>
         goto restart;
 8232398:	003f6006 	br	823211c <sosend+0xc4>
      }

      while (space > 0) 
      {
         len = resid;
 823239c:	e0bff717 	ldw	r2,-36(fp)
 82323a0:	e0bffb15 	stw	r2,-20(fp)
         if ( so->so_type == SOCK_STREAM )
 82323a4:	e0bffc17 	ldw	r2,-16(fp)
 82323a8:	10800983 	ldbu	r2,38(r2)
 82323ac:	10803fcc 	andi	r2,r2,255
 82323b0:	1080201c 	xori	r2,r2,128
 82323b4:	10bfe004 	addi	r2,r2,-128
 82323b8:	10800058 	cmpnei	r2,r2,1
 82323bc:	1000171e 	bne	r2,zero,823241c <sosend+0x3c4>
         {
            m = m_getwithdata(MT_TXDATA, len);
 82323c0:	e17ffb17 	ldw	r5,-20(fp)
 82323c4:	01000084 	movi	r4,2
 82323c8:	822e0f40 	call	822e0f4 <m_getnbuf>
 82323cc:	e0bff515 	stw	r2,-44(fp)
            if (!m)   
 82323d0:	e0bff517 	ldw	r2,-44(fp)
 82323d4:	1000031e 	bne	r2,zero,82323e4 <sosend+0x38c>
               snderr(ENOBUFS);
 82323d8:	00801a44 	movi	r2,105
 82323dc:	e0bff815 	stw	r2,-32(fp)
 82323e0:	00005e06 	br	823255c <sosend+0x504>
            MEMCPY(m->m_data, data, len);
 82323e4:	e0bff517 	ldw	r2,-44(fp)
 82323e8:	10800317 	ldw	r2,12(r2)
 82323ec:	e0fffb17 	ldw	r3,-20(fp)
 82323f0:	180d883a 	mov	r6,r3
 82323f4:	e17ffe17 	ldw	r5,-8(fp)
 82323f8:	1009883a 	mov	r4,r2
 82323fc:	8202c5c0 	call	8202c5c <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 8232400:	e0bffc17 	ldw	r2,-16(fp)
 8232404:	1080190b 	ldhu	r2,100(r2)
 8232408:	10802014 	ori	r2,r2,128
 823240c:	1007883a 	mov	r3,r2
 8232410:	e0bffc17 	ldw	r2,-16(fp)
 8232414:	10c0190d 	sth	r3,100(r2)
 8232418:	00000706 	br	8232438 <sosend+0x3e0>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 823241c:	000b883a 	mov	r5,zero
 8232420:	01000084 	movi	r4,2
 8232424:	822e0f40 	call	822e0f4 <m_getnbuf>
 8232428:	e0bff515 	stw	r2,-44(fp)
            m->m_data = data;
 823242c:	e0bff517 	ldw	r2,-44(fp)
 8232430:	e0fffe17 	ldw	r3,-8(fp)
 8232434:	10c00315 	stw	r3,12(r2)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 8232438:	e0bfff17 	ldw	r2,-4(fp)
 823243c:	10c00017 	ldw	r3,0(r2)
 8232440:	e0bffb17 	ldw	r2,-20(fp)
 8232444:	1887c83a 	sub	r3,r3,r2
 8232448:	e0bfff17 	ldw	r2,-4(fp)
 823244c:	10c00015 	stw	r3,0(r2)
         resid -= len;
 8232450:	e0fff717 	ldw	r3,-36(fp)
 8232454:	e0bffb17 	ldw	r2,-20(fp)
 8232458:	1885c83a 	sub	r2,r3,r2
 823245c:	e0bff715 	stw	r2,-36(fp)
         data += len;
 8232460:	e0bffb17 	ldw	r2,-20(fp)
 8232464:	e0fffe17 	ldw	r3,-8(fp)
 8232468:	1885883a 	add	r2,r3,r2
 823246c:	e0bffe15 	stw	r2,-8(fp)
         m->m_len = len;
 8232470:	e0fffb17 	ldw	r3,-20(fp)
 8232474:	e0bff517 	ldw	r2,-44(fp)
 8232478:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 823247c:	e0bff417 	ldw	r2,-48(fp)
 8232480:	1000021e 	bne	r2,zero,823248c <sosend+0x434>
            head = m;
 8232484:	e0bff517 	ldw	r2,-44(fp)
 8232488:	e0bff415 	stw	r2,-48(fp)
         if (error)
 823248c:	e0bff817 	ldw	r2,-32(fp)
 8232490:	1000311e 	bne	r2,zero,8232558 <sosend+0x500>
            goto release;
         if (*data_length <= 0)
 8232494:	e0bfff17 	ldw	r2,-4(fp)
 8232498:	10800017 	ldw	r2,0(r2)
 823249c:	0080030e 	bge	zero,r2,82324ac <sosend+0x454>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 82324a0:	e0bff617 	ldw	r2,-40(fp)
 82324a4:	00bfbd16 	blt	zero,r2,823239c <sosend+0x344>
 82324a8:	00000106 	br	82324b0 <sosend+0x458>
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
         if (*data_length <= 0)
            break;
 82324ac:	0001883a 	nop
      }

      if (dontroute)
 82324b0:	e0bffa17 	ldw	r2,-24(fp)
 82324b4:	10000526 	beq	r2,zero,82324cc <sosend+0x474>
         so->so_options |= SO_DONTROUTE;
 82324b8:	e0bffc17 	ldw	r2,-16(fp)
 82324bc:	10800417 	ldw	r2,16(r2)
 82324c0:	10c00414 	ori	r3,r2,16
 82324c4:	e0bffc17 	ldw	r2,-16(fp)
 82324c8:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 82324cc:	e0800217 	ldw	r2,8(fp)
 82324d0:	1080004c 	andi	r2,r2,1
 82324d4:	10000226 	beq	r2,zero,82324e0 <sosend+0x488>
 82324d8:	00800384 	movi	r2,14
 82324dc:	00000106 	br	82324e4 <sosend+0x48c>
 82324e0:	00800244 	movi	r2,9
 82324e4:	e0fffc17 	ldw	r3,-16(fp)
 82324e8:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 82324ec:	e0bffc17 	ldw	r2,-16(fp)
 82324f0:	10800217 	ldw	r2,8(r2)
 82324f4:	10800317 	ldw	r2,12(r2)
 82324f8:	e1bffd17 	ldw	r6,-12(fp)
 82324fc:	e17ff417 	ldw	r5,-48(fp)
 8232500:	e13ffc17 	ldw	r4,-16(fp)
 8232504:	103ee83a 	callr	r2
 8232508:	e0bff815 	stw	r2,-32(fp)

      if (dontroute)
 823250c:	e0bffa17 	ldw	r2,-24(fp)
 8232510:	10000626 	beq	r2,zero,823252c <sosend+0x4d4>
         so->so_options &= ~SO_DONTROUTE;
 8232514:	e0bffc17 	ldw	r2,-16(fp)
 8232518:	10c00417 	ldw	r3,16(r2)
 823251c:	00bffbc4 	movi	r2,-17
 8232520:	1886703a 	and	r3,r3,r2
 8232524:	e0bffc17 	ldw	r2,-16(fp)
 8232528:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 823252c:	e03ff415 	stw	zero,-48(fp)
      first = 0;
 8232530:	e03ff915 	stw	zero,-28(fp)
   } while ((resid != 0) && (error == 0));
 8232534:	e0bff717 	ldw	r2,-36(fp)
 8232538:	10000826 	beq	r2,zero,823255c <sosend+0x504>
 823253c:	e0bff817 	ldw	r2,-32(fp)
 8232540:	103f0626 	beq	r2,zero,823215c <sosend+0x104>
 8232544:	00000506 	br	823255c <sosend+0x504>
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
            {
               if (first)
                  error = EWOULDBLOCK;
               goto release;
 8232548:	0001883a 	nop
 823254c:	00000306 	br	823255c <sosend+0x504>
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
         {
            if (first)     /* report first error */
               error = EWOULDBLOCK;
            goto release;
 8232550:	0001883a 	nop
 8232554:	00000106 	br	823255c <sosend+0x504>
         data += len;
         m->m_len = len;
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
 8232558:	0001883a 	nop
      head = (struct mbuf *)NULL;
      first = 0;
   } while ((resid != 0) && (error == 0));

release:
   sbunlock(&so->so_snd);  
 823255c:	e0bffc17 	ldw	r2,-16(fp)
 8232560:	10c0190b 	ldhu	r3,100(r2)
 8232564:	00bfff84 	movi	r2,-2
 8232568:	1884703a 	and	r2,r3,r2
 823256c:	1007883a 	mov	r3,r2
 8232570:	e0bffc17 	ldw	r2,-16(fp)
 8232574:	10c0190d 	sth	r3,100(r2)
 8232578:	e0bffc17 	ldw	r2,-16(fp)
 823257c:	10801904 	addi	r2,r2,100
 8232580:	1009883a 	mov	r4,r2
 8232584:	82293f40 	call	82293f4 <tcp_wakeup>
   if (head)
 8232588:	e0bff417 	ldw	r2,-48(fp)
 823258c:	10000226 	beq	r2,zero,8232598 <sosend+0x540>
      m_freem(head);
 8232590:	e13ff417 	ldw	r4,-48(fp)
 8232594:	822e3840 	call	822e384 <m_freem>
   return error;
 8232598:	e0bff817 	ldw	r2,-32(fp)
}
 823259c:	e037883a 	mov	sp,fp
 82325a0:	dfc00117 	ldw	ra,4(sp)
 82325a4:	df000017 	ldw	fp,0(sp)
 82325a8:	dec00204 	addi	sp,sp,8
 82325ac:	f800283a 	ret

082325b0 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 82325b0:	defff204 	addi	sp,sp,-56
 82325b4:	dfc00d15 	stw	ra,52(sp)
 82325b8:	df000c15 	stw	fp,48(sp)
 82325bc:	df000c04 	addi	fp,sp,48
 82325c0:	e13ffc15 	stw	r4,-16(fp)
 82325c4:	e17ffd15 	stw	r5,-12(fp)
 82325c8:	e1bffe15 	stw	r6,-8(fp)
 82325cc:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 82325d0:	e03ff615 	stw	zero,-40(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 82325d4:	e0bffc17 	ldw	r2,-16(fp)
 82325d8:	10800217 	ldw	r2,8(r2)
 82325dc:	e0bffa15 	stw	r2,-24(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 82325e0:	e0bffd17 	ldw	r2,-12(fp)
 82325e4:	10000226 	beq	r2,zero,82325f0 <soreceive+0x40>
      *aname = 0;
 82325e8:	e0bffd17 	ldw	r2,-12(fp)
 82325ec:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 82325f0:	e0800217 	ldw	r2,8(fp)
 82325f4:	1080004c 	andi	r2,r2,1
 82325f8:	10004626 	beq	r2,zero,8232714 <soreceive+0x164>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 82325fc:	000b883a 	mov	r5,zero
 8232600:	01000044 	movi	r4,1
 8232604:	822e0f40 	call	822e0f4 <m_getnbuf>
 8232608:	e0bff415 	stw	r2,-48(fp)
      if (m == NULL)
 823260c:	e0bff417 	ldw	r2,-48(fp)
 8232610:	1000021e 	bne	r2,zero,823261c <soreceive+0x6c>
         return ENOBUFS;
 8232614:	00801a44 	movi	r2,105
 8232618:	0001b306 	br	8232ce8 <soreceive+0x738>
      lflags = flags & MSG_PEEK;
 823261c:	e0800217 	ldw	r2,8(fp)
 8232620:	1080008c 	andi	r2,r2,2
 8232624:	e0bffb15 	stw	r2,-20(fp)

      so->so_req = PRU_RCVOOB;
 8232628:	e0bffc17 	ldw	r2,-16(fp)
 823262c:	00c00344 	movi	r3,13
 8232630:	10c00715 	stw	r3,28(r2)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 8232634:	e0bffa17 	ldw	r2,-24(fp)
 8232638:	10800317 	ldw	r2,12(r2)
 823263c:	e0fffb17 	ldw	r3,-20(fp)
 8232640:	180d883a 	mov	r6,r3
 8232644:	e17ff417 	ldw	r5,-48(fp)
 8232648:	e13ffc17 	ldw	r4,-16(fp)
 823264c:	103ee83a 	callr	r2
 8232650:	e0bff615 	stw	r2,-40(fp)
      if (error == 0)
 8232654:	e0bff617 	ldw	r2,-40(fp)
 8232658:	1000231e 	bne	r2,zero,82326e8 <soreceive+0x138>
      {
         do 
         {
            len = *datalen;
 823265c:	e0bfff17 	ldw	r2,-4(fp)
 8232660:	10800017 	ldw	r2,0(r2)
 8232664:	e0bff515 	stw	r2,-44(fp)
            if (len > (int)m->m_len)
 8232668:	e0bff417 	ldw	r2,-48(fp)
 823266c:	10800217 	ldw	r2,8(r2)
 8232670:	1007883a 	mov	r3,r2
 8232674:	e0bff517 	ldw	r2,-44(fp)
 8232678:	1880030e 	bge	r3,r2,8232688 <soreceive+0xd8>
               len = m->m_len;
 823267c:	e0bff417 	ldw	r2,-48(fp)
 8232680:	10800217 	ldw	r2,8(r2)
 8232684:	e0bff515 	stw	r2,-44(fp)

            MEMCPY(data, mtod(m, char*), len);
 8232688:	e0bff417 	ldw	r2,-48(fp)
 823268c:	10800317 	ldw	r2,12(r2)
 8232690:	e0fff517 	ldw	r3,-44(fp)
 8232694:	180d883a 	mov	r6,r3
 8232698:	100b883a 	mov	r5,r2
 823269c:	e13ffe17 	ldw	r4,-8(fp)
 82326a0:	8202c5c0 	call	8202c5c <memcpy>
            data += len;
 82326a4:	e0bff517 	ldw	r2,-44(fp)
 82326a8:	e0fffe17 	ldw	r3,-8(fp)
 82326ac:	1885883a 	add	r2,r3,r2
 82326b0:	e0bffe15 	stw	r2,-8(fp)
            *datalen = len;
 82326b4:	e0bfff17 	ldw	r2,-4(fp)
 82326b8:	e0fff517 	ldw	r3,-44(fp)
 82326bc:	10c00015 	stw	r3,0(r2)
            m = m_free(m);
 82326c0:	e13ff417 	ldw	r4,-48(fp)
 82326c4:	822e27c0 	call	822e27c <m_free>
 82326c8:	e0bff415 	stw	r2,-48(fp)
         } while (*datalen && (error == 0) && m);
 82326cc:	e0bfff17 	ldw	r2,-4(fp)
 82326d0:	10800017 	ldw	r2,0(r2)
 82326d4:	10000426 	beq	r2,zero,82326e8 <soreceive+0x138>
 82326d8:	e0bff617 	ldw	r2,-40(fp)
 82326dc:	1000021e 	bne	r2,zero,82326e8 <soreceive+0x138>
 82326e0:	e0bff417 	ldw	r2,-48(fp)
 82326e4:	103fdd1e 	bne	r2,zero,823265c <soreceive+0xac>
      }

      if (m)
 82326e8:	e0bff417 	ldw	r2,-48(fp)
 82326ec:	10000226 	beq	r2,zero,82326f8 <soreceive+0x148>
         m_freem(m);
 82326f0:	e13ff417 	ldw	r4,-48(fp)
 82326f4:	822e3840 	call	822e384 <m_freem>
      return (error);
 82326f8:	e0bff617 	ldw	r2,-40(fp)
 82326fc:	00017a06 	br	8232ce8 <soreceive+0x738>
   }

restart:
   sblock (&so->so_rcv);
 8232700:	00000406 	br	8232714 <soreceive+0x164>
 8232704:	e0bffc17 	ldw	r2,-16(fp)
 8232708:	10801104 	addi	r2,r2,68
 823270c:	1009883a 	mov	r4,r2
 8232710:	82292800 	call	8229280 <tcp_sleep>
 8232714:	e0bffc17 	ldw	r2,-16(fp)
 8232718:	1080110b 	ldhu	r2,68(r2)
 823271c:	10bfffcc 	andi	r2,r2,65535
 8232720:	1080004c 	andi	r2,r2,1
 8232724:	103ff71e 	bne	r2,zero,8232704 <soreceive+0x154>
 8232728:	e0bffc17 	ldw	r2,-16(fp)
 823272c:	1080110b 	ldhu	r2,68(r2)
 8232730:	10800054 	ori	r2,r2,1
 8232734:	1007883a 	mov	r3,r2
 8232738:	e0bffc17 	ldw	r2,-16(fp)
 823273c:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 8232740:	e0bffc17 	ldw	r2,-16(fp)
 8232744:	10800a17 	ldw	r2,40(r2)
 8232748:	10003a1e 	bne	r2,zero,8232834 <soreceive+0x284>
   {
      if (so->so_error) 
 823274c:	e0bffc17 	ldw	r2,-16(fp)
 8232750:	10800617 	ldw	r2,24(r2)
 8232754:	10000626 	beq	r2,zero,8232770 <soreceive+0x1c0>
      {
         error = so->so_error;
 8232758:	e0bffc17 	ldw	r2,-16(fp)
 823275c:	10800617 	ldw	r2,24(r2)
 8232760:	e0bff615 	stw	r2,-40(fp)
         so->so_error = 0;
 8232764:	e0bffc17 	ldw	r2,-16(fp)
 8232768:	10000615 	stw	zero,24(r2)
         goto release;
 823276c:	00015206 	br	8232cb8 <soreceive+0x708>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8232770:	e0bffc17 	ldw	r2,-16(fp)
 8232774:	1080088b 	ldhu	r2,34(r2)
 8232778:	10bfffcc 	andi	r2,r2,65535
 823277c:	1080080c 	andi	r2,r2,32
 8232780:	10014a1e 	bne	r2,zero,8232cac <soreceive+0x6fc>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 8232784:	e0bffc17 	ldw	r2,-16(fp)
 8232788:	1080088b 	ldhu	r2,34(r2)
 823278c:	10bfffcc 	andi	r2,r2,65535
 8232790:	1080008c 	andi	r2,r2,2
 8232794:	1000091e 	bne	r2,zero,82327bc <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
 8232798:	e0bffc17 	ldw	r2,-16(fp)
 823279c:	10800217 	ldw	r2,8(r2)
 82327a0:	1080010b 	ldhu	r2,4(r2)
 82327a4:	10bfffcc 	andi	r2,r2,65535
 82327a8:	1080010c 	andi	r2,r2,4
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 82327ac:	10000326 	beq	r2,zero,82327bc <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 82327b0:	00802004 	movi	r2,128
 82327b4:	e0bff615 	stw	r2,-40(fp)
         goto release;
 82327b8:	00013f06 	br	8232cb8 <soreceive+0x708>
      }
      if (*datalen == 0)
 82327bc:	e0bfff17 	ldw	r2,-4(fp)
 82327c0:	10800017 	ldw	r2,0(r2)
 82327c4:	10013b26 	beq	r2,zero,8232cb4 <soreceive+0x704>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 82327c8:	e0bffc17 	ldw	r2,-16(fp)
 82327cc:	1080088b 	ldhu	r2,34(r2)
 82327d0:	10bfffcc 	andi	r2,r2,65535
 82327d4:	1080400c 	andi	r2,r2,256
 82327d8:	1000031e 	bne	r2,zero,82327e8 <soreceive+0x238>
 82327dc:	e0800217 	ldw	r2,8(fp)
 82327e0:	1080080c 	andi	r2,r2,32
 82327e4:	10000326 	beq	r2,zero,82327f4 <soreceive+0x244>
      {
         error = EWOULDBLOCK;
 82327e8:	008002c4 	movi	r2,11
 82327ec:	e0bff615 	stw	r2,-40(fp)
         goto release;
 82327f0:	00013106 	br	8232cb8 <soreceive+0x708>
      }
      sbunlock(&so->so_rcv);
 82327f4:	e0bffc17 	ldw	r2,-16(fp)
 82327f8:	10c0110b 	ldhu	r3,68(r2)
 82327fc:	00bfff84 	movi	r2,-2
 8232800:	1884703a 	and	r2,r3,r2
 8232804:	1007883a 	mov	r3,r2
 8232808:	e0bffc17 	ldw	r2,-16(fp)
 823280c:	10c0110d 	sth	r3,68(r2)
 8232810:	e0bffc17 	ldw	r2,-16(fp)
 8232814:	10801104 	addi	r2,r2,68
 8232818:	1009883a 	mov	r4,r2
 823281c:	82293f40 	call	82293f4 <tcp_wakeup>
      sbwait(&so->so_rcv);
 8232820:	e0bffc17 	ldw	r2,-16(fp)
 8232824:	10800a04 	addi	r2,r2,40
 8232828:	1009883a 	mov	r4,r2
 823282c:	8233f240 	call	8233f24 <sbwait>
      goto restart;
 8232830:	003fb306 	br	8232700 <soreceive+0x150>
   }
   m = so->so_rcv.sb_mb;
 8232834:	e0bffc17 	ldw	r2,-16(fp)
 8232838:	10801017 	ldw	r2,64(r2)
 823283c:	e0bff415 	stw	r2,-48(fp)
   if (m == 0)
 8232840:	e0bff417 	ldw	r2,-48(fp)
 8232844:	1000031e 	bne	r2,zero,8232854 <soreceive+0x2a4>
      panic("sorecv 1");
 8232848:	01020974 	movhi	r4,2085
 823284c:	21029a04 	addi	r4,r4,2664
 8232850:	82289940 	call	8228994 <panic>
   nextrecord = m->m_act;
 8232854:	e0bff417 	ldw	r2,-48(fp)
 8232858:	10800717 	ldw	r2,28(r2)
 823285c:	e0bff815 	stw	r2,-32(fp)
   if (pr->pr_flags & PR_ADDR) 
 8232860:	e0bffa17 	ldw	r2,-24(fp)
 8232864:	1080010b 	ldhu	r2,4(r2)
 8232868:	10bfffcc 	andi	r2,r2,65535
 823286c:	1080008c 	andi	r2,r2,2
 8232870:	10004226 	beq	r2,zero,823297c <soreceive+0x3cc>
   {
      if (m->m_type != MT_SONAME) 
 8232874:	e0bff417 	ldw	r2,-48(fp)
 8232878:	10800817 	ldw	r2,32(r2)
 823287c:	10800260 	cmpeqi	r2,r2,9
 8232880:	1000091e 	bne	r2,zero,82328a8 <soreceive+0x2f8>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 8232884:	e0bff417 	ldw	r2,-48(fp)
 8232888:	10800817 	ldw	r2,32(r2)
 823288c:	100b883a 	mov	r5,r2
 8232890:	01020974 	movhi	r4,2085
 8232894:	21029d04 	addi	r4,r4,2676
 8232898:	82030ec0 	call	82030ec <printf>
         panic("sorecv 2");
 823289c:	01020974 	movhi	r4,2085
 82328a0:	2102a304 	addi	r4,r4,2700
 82328a4:	82289940 	call	8228994 <panic>
      }
      if (flags & MSG_PEEK) 
 82328a8:	e0800217 	ldw	r2,8(fp)
 82328ac:	1080008c 	andi	r2,r2,2
 82328b0:	10000f26 	beq	r2,zero,82328f0 <soreceive+0x340>
      {
         if (aname)
 82328b4:	e0bffd17 	ldw	r2,-12(fp)
 82328b8:	10000926 	beq	r2,zero,82328e0 <soreceive+0x330>
            *aname = m_copy (m, 0, m->m_len);
 82328bc:	e0bff417 	ldw	r2,-48(fp)
 82328c0:	10800217 	ldw	r2,8(r2)
 82328c4:	100d883a 	mov	r6,r2
 82328c8:	000b883a 	mov	r5,zero
 82328cc:	e13ff417 	ldw	r4,-48(fp)
 82328d0:	822e3c80 	call	822e3c8 <m_copy>
 82328d4:	1007883a 	mov	r3,r2
 82328d8:	e0bffd17 	ldw	r2,-12(fp)
 82328dc:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 82328e0:	e0bff417 	ldw	r2,-48(fp)
 82328e4:	10800617 	ldw	r2,24(r2)
 82328e8:	e0bff415 	stw	r2,-48(fp)
 82328ec:	00002306 	br	823297c <soreceive+0x3cc>
      } else 
      {
         sbfree (&so->so_rcv, m);
 82328f0:	e0bffc17 	ldw	r2,-16(fp)
 82328f4:	10c00a17 	ldw	r3,40(r2)
 82328f8:	e0bff417 	ldw	r2,-48(fp)
 82328fc:	10800217 	ldw	r2,8(r2)
 8232900:	1887c83a 	sub	r3,r3,r2
 8232904:	e0bffc17 	ldw	r2,-16(fp)
 8232908:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 823290c:	e0bffd17 	ldw	r2,-12(fp)
 8232910:	10000d26 	beq	r2,zero,8232948 <soreceive+0x398>
         {
            *aname = m;
 8232914:	e0bffd17 	ldw	r2,-12(fp)
 8232918:	e0fff417 	ldw	r3,-48(fp)
 823291c:	10c00015 	stw	r3,0(r2)
            m = m->m_next;
 8232920:	e0bff417 	ldw	r2,-48(fp)
 8232924:	10800617 	ldw	r2,24(r2)
 8232928:	e0bff415 	stw	r2,-48(fp)
            (*aname)->m_next = 0;
 823292c:	e0bffd17 	ldw	r2,-12(fp)
 8232930:	10800017 	ldw	r2,0(r2)
 8232934:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 8232938:	e0bffc17 	ldw	r2,-16(fp)
 823293c:	e0fff417 	ldw	r3,-48(fp)
 8232940:	10c01015 	stw	r3,64(r2)
 8232944:	00000806 	br	8232968 <soreceive+0x3b8>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 8232948:	e13ff417 	ldw	r4,-48(fp)
 823294c:	822e27c0 	call	822e27c <m_free>
 8232950:	1007883a 	mov	r3,r2
 8232954:	e0bffc17 	ldw	r2,-16(fp)
 8232958:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 823295c:	e0bffc17 	ldw	r2,-16(fp)
 8232960:	10801017 	ldw	r2,64(r2)
 8232964:	e0bff415 	stw	r2,-48(fp)
         }
         if (m)
 8232968:	e0bff417 	ldw	r2,-48(fp)
 823296c:	10000326 	beq	r2,zero,823297c <soreceive+0x3cc>
            m->m_act = nextrecord;
 8232970:	e0bff417 	ldw	r2,-48(fp)
 8232974:	e0fff817 	ldw	r3,-32(fp)
 8232978:	10c00715 	stw	r3,28(r2)
      }
   }
   moff = 0;
 823297c:	e03ff915 	stw	zero,-28(fp)
   offset = 0;
 8232980:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 8232984:	00009e06 	br	8232c00 <soreceive+0x650>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 8232988:	e0bff417 	ldw	r2,-48(fp)
 823298c:	10800817 	ldw	r2,32(r2)
 8232990:	10800060 	cmpeqi	r2,r2,1
 8232994:	1000071e 	bne	r2,zero,82329b4 <soreceive+0x404>
 8232998:	e0bff417 	ldw	r2,-48(fp)
 823299c:	10800817 	ldw	r2,32(r2)
 82329a0:	108000e0 	cmpeqi	r2,r2,3
 82329a4:	1000031e 	bne	r2,zero,82329b4 <soreceive+0x404>
         panic("sorecv 3");
 82329a8:	01020974 	movhi	r4,2085
 82329ac:	2102a604 	addi	r4,r4,2712
 82329b0:	82289940 	call	8228994 <panic>
      len = *datalen;
 82329b4:	e0bfff17 	ldw	r2,-4(fp)
 82329b8:	10800017 	ldw	r2,0(r2)
 82329bc:	e0bff515 	stw	r2,-44(fp)
      so->so_state &= ~SS_RCVATMARK;
 82329c0:	e0bffc17 	ldw	r2,-16(fp)
 82329c4:	10c0088b 	ldhu	r3,34(r2)
 82329c8:	00bfefc4 	movi	r2,-65
 82329cc:	1884703a 	and	r2,r3,r2
 82329d0:	1007883a 	mov	r3,r2
 82329d4:	e0bffc17 	ldw	r2,-16(fp)
 82329d8:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 82329dc:	e0bffc17 	ldw	r2,-16(fp)
 82329e0:	10801a17 	ldw	r2,104(r2)
 82329e4:	10000c26 	beq	r2,zero,8232a18 <soreceive+0x468>
 82329e8:	e0bffc17 	ldw	r2,-16(fp)
 82329ec:	10c01a17 	ldw	r3,104(r2)
 82329f0:	e0bff717 	ldw	r2,-36(fp)
 82329f4:	1885c83a 	sub	r2,r3,r2
 82329f8:	1007883a 	mov	r3,r2
 82329fc:	e0bff517 	ldw	r2,-44(fp)
 8232a00:	1880050e 	bge	r3,r2,8232a18 <soreceive+0x468>
         len = (int)(so->so_oobmark - offset);
 8232a04:	e0bffc17 	ldw	r2,-16(fp)
 8232a08:	10c01a17 	ldw	r3,104(r2)
 8232a0c:	e0bff717 	ldw	r2,-36(fp)
 8232a10:	1885c83a 	sub	r2,r3,r2
 8232a14:	e0bff515 	stw	r2,-44(fp)
      if (len > (int)(m->m_len - moff))
 8232a18:	e0bff417 	ldw	r2,-48(fp)
 8232a1c:	10c00217 	ldw	r3,8(r2)
 8232a20:	e0bff917 	ldw	r2,-28(fp)
 8232a24:	1885c83a 	sub	r2,r3,r2
 8232a28:	1007883a 	mov	r3,r2
 8232a2c:	e0bff517 	ldw	r2,-44(fp)
 8232a30:	1880050e 	bge	r3,r2,8232a48 <soreceive+0x498>
         len = m->m_len - moff;
 8232a34:	e0bff417 	ldw	r2,-48(fp)
 8232a38:	10c00217 	ldw	r3,8(r2)
 8232a3c:	e0bff917 	ldw	r2,-28(fp)
 8232a40:	1885c83a 	sub	r2,r3,r2
 8232a44:	e0bff515 	stw	r2,-44(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 8232a48:	e0bff417 	ldw	r2,-48(fp)
 8232a4c:	10c00317 	ldw	r3,12(r2)
 8232a50:	e0bff917 	ldw	r2,-28(fp)
 8232a54:	1885883a 	add	r2,r3,r2
 8232a58:	e0fff517 	ldw	r3,-44(fp)
 8232a5c:	180d883a 	mov	r6,r3
 8232a60:	100b883a 	mov	r5,r2
 8232a64:	e13ffe17 	ldw	r4,-8(fp)
 8232a68:	8202c5c0 	call	8202c5c <memcpy>
      data += len;
 8232a6c:	e0bff517 	ldw	r2,-44(fp)
 8232a70:	e0fffe17 	ldw	r3,-8(fp)
 8232a74:	1885883a 	add	r2,r3,r2
 8232a78:	e0bffe15 	stw	r2,-8(fp)
      *datalen -= len;
 8232a7c:	e0bfff17 	ldw	r2,-4(fp)
 8232a80:	10c00017 	ldw	r3,0(r2)
 8232a84:	e0bff517 	ldw	r2,-44(fp)
 8232a88:	1887c83a 	sub	r3,r3,r2
 8232a8c:	e0bfff17 	ldw	r2,-4(fp)
 8232a90:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 8232a94:	e0bff417 	ldw	r2,-48(fp)
 8232a98:	10c00217 	ldw	r3,8(r2)
 8232a9c:	e0bff917 	ldw	r2,-28(fp)
 8232aa0:	1885c83a 	sub	r2,r3,r2
 8232aa4:	1007883a 	mov	r3,r2
 8232aa8:	e0bff517 	ldw	r2,-44(fp)
 8232aac:	1880201e 	bne	r3,r2,8232b30 <soreceive+0x580>
      {
         if (flags & MSG_PEEK) 
 8232ab0:	e0800217 	ldw	r2,8(fp)
 8232ab4:	1080008c 	andi	r2,r2,2
 8232ab8:	10000526 	beq	r2,zero,8232ad0 <soreceive+0x520>
         {
            m = m->m_next;
 8232abc:	e0bff417 	ldw	r2,-48(fp)
 8232ac0:	10800617 	ldw	r2,24(r2)
 8232ac4:	e0bff415 	stw	r2,-48(fp)
            moff = 0;
 8232ac8:	e03ff915 	stw	zero,-28(fp)
 8232acc:	00003206 	br	8232b98 <soreceive+0x5e8>
         } else 
         {
            nextrecord = m->m_act;
 8232ad0:	e0bff417 	ldw	r2,-48(fp)
 8232ad4:	10800717 	ldw	r2,28(r2)
 8232ad8:	e0bff815 	stw	r2,-32(fp)
            sbfree(&so->so_rcv, m);
 8232adc:	e0bffc17 	ldw	r2,-16(fp)
 8232ae0:	10c00a17 	ldw	r3,40(r2)
 8232ae4:	e0bff417 	ldw	r2,-48(fp)
 8232ae8:	10800217 	ldw	r2,8(r2)
 8232aec:	1887c83a 	sub	r3,r3,r2
 8232af0:	e0bffc17 	ldw	r2,-16(fp)
 8232af4:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 8232af8:	e13ff417 	ldw	r4,-48(fp)
 8232afc:	822e27c0 	call	822e27c <m_free>
 8232b00:	1007883a 	mov	r3,r2
 8232b04:	e0bffc17 	ldw	r2,-16(fp)
 8232b08:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 8232b0c:	e0bffc17 	ldw	r2,-16(fp)
 8232b10:	10801017 	ldw	r2,64(r2)
 8232b14:	e0bff415 	stw	r2,-48(fp)
            }
            if (m)
 8232b18:	e0bff417 	ldw	r2,-48(fp)
 8232b1c:	10001e26 	beq	r2,zero,8232b98 <soreceive+0x5e8>
               m->m_act = nextrecord;
 8232b20:	e0bff417 	ldw	r2,-48(fp)
 8232b24:	e0fff817 	ldw	r3,-32(fp)
 8232b28:	10c00715 	stw	r3,28(r2)
 8232b2c:	00001a06 	br	8232b98 <soreceive+0x5e8>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 8232b30:	e0800217 	ldw	r2,8(fp)
 8232b34:	1080008c 	andi	r2,r2,2
 8232b38:	10000526 	beq	r2,zero,8232b50 <soreceive+0x5a0>
            moff += len;
 8232b3c:	e0fff917 	ldw	r3,-28(fp)
 8232b40:	e0bff517 	ldw	r2,-44(fp)
 8232b44:	1885883a 	add	r2,r3,r2
 8232b48:	e0bff915 	stw	r2,-28(fp)
 8232b4c:	00001206 	br	8232b98 <soreceive+0x5e8>
         else 
         {
            m->m_data += len;
 8232b50:	e0bff417 	ldw	r2,-48(fp)
 8232b54:	10c00317 	ldw	r3,12(r2)
 8232b58:	e0bff517 	ldw	r2,-44(fp)
 8232b5c:	1887883a 	add	r3,r3,r2
 8232b60:	e0bff417 	ldw	r2,-48(fp)
 8232b64:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 8232b68:	e0bff417 	ldw	r2,-48(fp)
 8232b6c:	10c00217 	ldw	r3,8(r2)
 8232b70:	e0bff517 	ldw	r2,-44(fp)
 8232b74:	1887c83a 	sub	r3,r3,r2
 8232b78:	e0bff417 	ldw	r2,-48(fp)
 8232b7c:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 8232b80:	e0bffc17 	ldw	r2,-16(fp)
 8232b84:	10c00a17 	ldw	r3,40(r2)
 8232b88:	e0bff517 	ldw	r2,-44(fp)
 8232b8c:	1887c83a 	sub	r3,r3,r2
 8232b90:	e0bffc17 	ldw	r2,-16(fp)
 8232b94:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 8232b98:	e0bffc17 	ldw	r2,-16(fp)
 8232b9c:	10801a17 	ldw	r2,104(r2)
 8232ba0:	10001726 	beq	r2,zero,8232c00 <soreceive+0x650>
      {
         if ((flags & MSG_PEEK) == 0) 
 8232ba4:	e0800217 	ldw	r2,8(fp)
 8232ba8:	1080008c 	andi	r2,r2,2
 8232bac:	1000101e 	bne	r2,zero,8232bf0 <soreceive+0x640>
         {
            so->so_oobmark -= len;
 8232bb0:	e0bffc17 	ldw	r2,-16(fp)
 8232bb4:	10c01a17 	ldw	r3,104(r2)
 8232bb8:	e0bff517 	ldw	r2,-44(fp)
 8232bbc:	1887c83a 	sub	r3,r3,r2
 8232bc0:	e0bffc17 	ldw	r2,-16(fp)
 8232bc4:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 8232bc8:	e0bffc17 	ldw	r2,-16(fp)
 8232bcc:	10801a17 	ldw	r2,104(r2)
 8232bd0:	10000b1e 	bne	r2,zero,8232c00 <soreceive+0x650>
            {
               so->so_state |= SS_RCVATMARK;
 8232bd4:	e0bffc17 	ldw	r2,-16(fp)
 8232bd8:	1080088b 	ldhu	r2,34(r2)
 8232bdc:	10801014 	ori	r2,r2,64
 8232be0:	1007883a 	mov	r3,r2
 8232be4:	e0bffc17 	ldw	r2,-16(fp)
 8232be8:	10c0088d 	sth	r3,34(r2)
               break;
 8232bec:	00000b06 	br	8232c1c <soreceive+0x66c>
            }
         } else
            offset += len;
 8232bf0:	e0fff717 	ldw	r3,-36(fp)
 8232bf4:	e0bff517 	ldw	r2,-44(fp)
 8232bf8:	1885883a 	add	r2,r3,r2
 8232bfc:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 8232c00:	e0bff417 	ldw	r2,-48(fp)
 8232c04:	10000526 	beq	r2,zero,8232c1c <soreceive+0x66c>
 8232c08:	e0bfff17 	ldw	r2,-4(fp)
 8232c0c:	10800017 	ldw	r2,0(r2)
 8232c10:	0080020e 	bge	zero,r2,8232c1c <soreceive+0x66c>
 8232c14:	e0bff617 	ldw	r2,-40(fp)
 8232c18:	103f5b26 	beq	r2,zero,8232988 <soreceive+0x3d8>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 8232c1c:	e0800217 	ldw	r2,8(fp)
 8232c20:	1080008c 	andi	r2,r2,2
 8232c24:	1000241e 	bne	r2,zero,8232cb8 <soreceive+0x708>
   {
      if (m == 0)
 8232c28:	e0bff417 	ldw	r2,-48(fp)
 8232c2c:	1000041e 	bne	r2,zero,8232c40 <soreceive+0x690>
         so->so_rcv.sb_mb = nextrecord;
 8232c30:	e0bffc17 	ldw	r2,-16(fp)
 8232c34:	e0fff817 	ldw	r3,-32(fp)
 8232c38:	10c01015 	stw	r3,64(r2)
 8232c3c:	00000906 	br	8232c64 <soreceive+0x6b4>
      else if (pr->pr_flags & PR_ATOMIC)
 8232c40:	e0bffa17 	ldw	r2,-24(fp)
 8232c44:	1080010b 	ldhu	r2,4(r2)
 8232c48:	10bfffcc 	andi	r2,r2,65535
 8232c4c:	1080004c 	andi	r2,r2,1
 8232c50:	10000426 	beq	r2,zero,8232c64 <soreceive+0x6b4>
         (void) sbdroprecord(&so->so_rcv);
 8232c54:	e0bffc17 	ldw	r2,-16(fp)
 8232c58:	10800a04 	addi	r2,r2,40
 8232c5c:	1009883a 	mov	r4,r2
 8232c60:	82349b00 	call	82349b0 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 8232c64:	e0bffa17 	ldw	r2,-24(fp)
 8232c68:	1080010b 	ldhu	r2,4(r2)
 8232c6c:	10bfffcc 	andi	r2,r2,65535
 8232c70:	1080020c 	andi	r2,r2,8
 8232c74:	10001026 	beq	r2,zero,8232cb8 <soreceive+0x708>
 8232c78:	e0bffc17 	ldw	r2,-16(fp)
 8232c7c:	10800117 	ldw	r2,4(r2)
 8232c80:	10000d26 	beq	r2,zero,8232cb8 <soreceive+0x708>
      {
         so->so_req = PRU_RCVD;
 8232c84:	e0bffc17 	ldw	r2,-16(fp)
 8232c88:	00c00204 	movi	r3,8
 8232c8c:	10c00715 	stw	r3,28(r2)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 8232c90:	e0bffa17 	ldw	r2,-24(fp)
 8232c94:	10800317 	ldw	r2,12(r2)
 8232c98:	000d883a 	mov	r6,zero
 8232c9c:	000b883a 	mov	r5,zero
 8232ca0:	e13ffc17 	ldw	r4,-16(fp)
 8232ca4:	103ee83a 	callr	r2
 8232ca8:	00000306 	br	8232cb8 <soreceive+0x708>
         error = so->so_error;
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
 8232cac:	0001883a 	nop
 8232cb0:	00000106 	br	8232cb8 <soreceive+0x708>
      {
         error = ENOTCONN;
         goto release;
      }
      if (*datalen == 0)
         goto release;
 8232cb4:	0001883a 	nop
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 8232cb8:	e0bffc17 	ldw	r2,-16(fp)
 8232cbc:	10c0110b 	ldhu	r3,68(r2)
 8232cc0:	00bfff84 	movi	r2,-2
 8232cc4:	1884703a 	and	r2,r3,r2
 8232cc8:	1007883a 	mov	r3,r2
 8232ccc:	e0bffc17 	ldw	r2,-16(fp)
 8232cd0:	10c0110d 	sth	r3,68(r2)
 8232cd4:	e0bffc17 	ldw	r2,-16(fp)
 8232cd8:	10801104 	addi	r2,r2,68
 8232cdc:	1009883a 	mov	r4,r2
 8232ce0:	82293f40 	call	82293f4 <tcp_wakeup>
   return (error);
 8232ce4:	e0bff617 	ldw	r2,-40(fp)
}
 8232ce8:	e037883a 	mov	sp,fp
 8232cec:	dfc00117 	ldw	ra,4(sp)
 8232cf0:	df000017 	ldw	fp,0(sp)
 8232cf4:	dec00204 	addi	sp,sp,8
 8232cf8:	f800283a 	ret

08232cfc <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 8232cfc:	defffc04 	addi	sp,sp,-16
 8232d00:	dfc00315 	stw	ra,12(sp)
 8232d04:	df000215 	stw	fp,8(sp)
 8232d08:	df000204 	addi	fp,sp,8
 8232d0c:	e13ffe15 	stw	r4,-8(fp)
 8232d10:	e17fff15 	stw	r5,-4(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 8232d14:	e0bfff17 	ldw	r2,-4(fp)
 8232d18:	10800044 	addi	r2,r2,1
 8232d1c:	e0bfff15 	stw	r2,-4(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 8232d20:	e0bfff17 	ldw	r2,-4(fp)
 8232d24:	1080004c 	andi	r2,r2,1
 8232d28:	10000226 	beq	r2,zero,8232d34 <soshutdown+0x38>
      sorflush(so);
 8232d2c:	e13ffe17 	ldw	r4,-8(fp)
 8232d30:	8232d940 	call	8232d94 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 8232d34:	e0bfff17 	ldw	r2,-4(fp)
 8232d38:	1080008c 	andi	r2,r2,2
 8232d3c:	10000f26 	beq	r2,zero,8232d7c <soshutdown+0x80>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 8232d40:	e0bffe17 	ldw	r2,-8(fp)
 8232d44:	10801204 	addi	r2,r2,72
 8232d48:	1009883a 	mov	r4,r2
 8232d4c:	82346740 	call	8234674 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 8232d50:	e0bffe17 	ldw	r2,-8(fp)
 8232d54:	00c001c4 	movi	r3,7
 8232d58:	10c00715 	stw	r3,28(r2)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 8232d5c:	e0bffe17 	ldw	r2,-8(fp)
 8232d60:	10800217 	ldw	r2,8(r2)
 8232d64:	10800317 	ldw	r2,12(r2)
 8232d68:	000d883a 	mov	r6,zero
 8232d6c:	000b883a 	mov	r5,zero
 8232d70:	e13ffe17 	ldw	r4,-8(fp)
 8232d74:	103ee83a 	callr	r2
 8232d78:	00000106 	br	8232d80 <soshutdown+0x84>
   }

   return 0;
 8232d7c:	0005883a 	mov	r2,zero
}
 8232d80:	e037883a 	mov	sp,fp
 8232d84:	dfc00117 	ldw	ra,4(sp)
 8232d88:	df000017 	ldw	fp,0(sp)
 8232d8c:	dec00204 	addi	sp,sp,8
 8232d90:	f800283a 	ret

08232d94 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 8232d94:	defffb04 	addi	sp,sp,-20
 8232d98:	dfc00415 	stw	ra,16(sp)
 8232d9c:	df000315 	stw	fp,12(sp)
 8232da0:	df000304 	addi	fp,sp,12
 8232da4:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 8232da8:	e0bfff17 	ldw	r2,-4(fp)
 8232dac:	10800a04 	addi	r2,r2,40
 8232db0:	e0bffd15 	stw	r2,-12(fp)
   int   s;

   sblock(sb);
 8232db4:	00000406 	br	8232dc8 <sorflush+0x34>
 8232db8:	e0bffd17 	ldw	r2,-12(fp)
 8232dbc:	10800704 	addi	r2,r2,28
 8232dc0:	1009883a 	mov	r4,r2
 8232dc4:	82292800 	call	8229280 <tcp_sleep>
 8232dc8:	e0bffd17 	ldw	r2,-12(fp)
 8232dcc:	1080070b 	ldhu	r2,28(r2)
 8232dd0:	10bfffcc 	andi	r2,r2,65535
 8232dd4:	1080004c 	andi	r2,r2,1
 8232dd8:	103ff71e 	bne	r2,zero,8232db8 <sorflush+0x24>
 8232ddc:	e0bffd17 	ldw	r2,-12(fp)
 8232de0:	1080070b 	ldhu	r2,28(r2)
 8232de4:	10800054 	ori	r2,r2,1
 8232de8:	1007883a 	mov	r3,r2
 8232dec:	e0bffd17 	ldw	r2,-12(fp)
 8232df0:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 8232df4:	e13fff17 	ldw	r4,-4(fp)
 8232df8:	8233e900 	call	8233e90 <socantrcvmore>
   sbunlock(sb);
 8232dfc:	e0bffd17 	ldw	r2,-12(fp)
 8232e00:	10c0070b 	ldhu	r3,28(r2)
 8232e04:	00bfff84 	movi	r2,-2
 8232e08:	1884703a 	and	r2,r3,r2
 8232e0c:	1007883a 	mov	r3,r2
 8232e10:	e0bffd17 	ldw	r2,-12(fp)
 8232e14:	10c0070d 	sth	r3,28(r2)
 8232e18:	e0bffd17 	ldw	r2,-12(fp)
 8232e1c:	10800704 	addi	r2,r2,28
 8232e20:	1009883a 	mov	r4,r2
 8232e24:	82293f40 	call	82293f4 <tcp_wakeup>
   sbrelease(sb);
 8232e28:	e13ffd17 	ldw	r4,-12(fp)
 8232e2c:	82340f40 	call	82340f4 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 8232e30:	01800804 	movi	r6,32
 8232e34:	000b883a 	mov	r5,zero
 8232e38:	e13ffd17 	ldw	r4,-12(fp)
 8232e3c:	8202f000 	call	8202f00 <memset>
   s = so->so_error;
 8232e40:	e0bfff17 	ldw	r2,-4(fp)
 8232e44:	10800617 	ldw	r2,24(r2)
 8232e48:	e0bffe15 	stw	r2,-8(fp)
   so->so_error = ESHUTDOWN;
 8232e4c:	e0bfff17 	ldw	r2,-4(fp)
 8232e50:	00c01b84 	movi	r3,110
 8232e54:	10c00615 	stw	r3,24(r2)
   sorwakeup(so);
 8232e58:	e0bfff17 	ldw	r2,-4(fp)
 8232e5c:	10800a04 	addi	r2,r2,40
 8232e60:	100b883a 	mov	r5,r2
 8232e64:	e13fff17 	ldw	r4,-4(fp)
 8232e68:	8233f900 	call	8233f90 <sbwakeup>
   so->so_error = s;
 8232e6c:	e0bfff17 	ldw	r2,-4(fp)
 8232e70:	e0fffe17 	ldw	r3,-8(fp)
 8232e74:	10c00615 	stw	r3,24(r2)
}
 8232e78:	0001883a 	nop
 8232e7c:	e037883a 	mov	sp,fp
 8232e80:	dfc00117 	ldw	ra,4(sp)
 8232e84:	df000017 	ldw	fp,0(sp)
 8232e88:	dec00204 	addi	sp,sp,8
 8232e8c:	f800283a 	ret

08232e90 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 8232e90:	defff604 	addi	sp,sp,-40
 8232e94:	dfc00915 	stw	ra,36(sp)
 8232e98:	df000815 	stw	fp,32(sp)
 8232e9c:	df000804 	addi	fp,sp,32
 8232ea0:	e13ffd15 	stw	r4,-12(fp)
 8232ea4:	e17ffe15 	stw	r5,-8(fp)
 8232ea8:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 8232eac:	e03ff815 	stw	zero,-32(fp)

   switch (optname) 
 8232eb0:	e0bffe17 	ldw	r2,-8(fp)
 8232eb4:	10c08020 	cmpeqi	r3,r2,512
 8232eb8:	18003b1e 	bne	r3,zero,8232fa8 <sosetopt+0x118>
 8232ebc:	10c08048 	cmpgei	r3,r2,513
 8232ec0:	1800171e 	bne	r3,zero,8232f20 <sosetopt+0x90>
 8232ec4:	10c00388 	cmpgei	r3,r2,14
 8232ec8:	1800091e 	bne	r3,zero,8232ef0 <sosetopt+0x60>
 8232ecc:	10c00248 	cmpgei	r3,r2,9
 8232ed0:	1800831e 	bne	r3,zero,82330e0 <sosetopt+0x250>
 8232ed4:	10c00120 	cmpeqi	r3,r2,4
 8232ed8:	1800331e 	bne	r3,zero,8232fa8 <sosetopt+0x118>
 8232edc:	10c00220 	cmpeqi	r3,r2,8
 8232ee0:	1800311e 	bne	r3,zero,8232fa8 <sosetopt+0x118>
 8232ee4:	108000a0 	cmpeqi	r2,r2,2
 8232ee8:	1000831e 	bne	r2,zero,82330f8 <sosetopt+0x268>
 8232eec:	0000ea06 	br	8233298 <sosetopt+0x408>
 8232ef0:	10c00820 	cmpeqi	r3,r2,32
 8232ef4:	18002c1e 	bne	r3,zero,8232fa8 <sosetopt+0x118>
 8232ef8:	10c00848 	cmpgei	r3,r2,33
 8232efc:	1800031e 	bne	r3,zero,8232f0c <sosetopt+0x7c>
 8232f00:	10800420 	cmpeqi	r2,r2,16
 8232f04:	1000281e 	bne	r2,zero,8232fa8 <sosetopt+0x118>
 8232f08:	0000e306 	br	8233298 <sosetopt+0x408>
 8232f0c:	10c02020 	cmpeqi	r3,r2,128
 8232f10:	1800201e 	bne	r3,zero,8232f94 <sosetopt+0x104>
 8232f14:	10804020 	cmpeqi	r2,r2,256
 8232f18:	1000231e 	bne	r2,zero,8232fa8 <sosetopt+0x118>
 8232f1c:	0000de06 	br	8233298 <sosetopt+0x408>
 8232f20:	10c40520 	cmpeqi	r3,r2,4116
 8232f24:	1800481e 	bne	r3,zero,8233048 <sosetopt+0x1b8>
 8232f28:	10c40548 	cmpgei	r3,r2,4117
 8232f2c:	18000b1e 	bne	r3,zero,8232f5c <sosetopt+0xcc>
 8232f30:	10c401a0 	cmpeqi	r3,r2,4102
 8232f34:	18003f1e 	bne	r3,zero,8233034 <sosetopt+0x1a4>
 8232f38:	10c401c8 	cmpgei	r3,r2,4103
 8232f3c:	1800041e 	bne	r3,zero,8232f50 <sosetopt+0xc0>
 8232f40:	10bbffc4 	addi	r2,r2,-4097
 8232f44:	108000a8 	cmpgeui	r2,r2,2
 8232f48:	1000d31e 	bne	r2,zero,8233298 <sosetopt+0x408>
 8232f4c:	00002806 	br	8232ff0 <sosetopt+0x160>
 8232f50:	10840420 	cmpeqi	r2,r2,4112
 8232f54:	1000a91e 	bne	r2,zero,82331fc <sosetopt+0x36c>
 8232f58:	0000cf06 	br	8233298 <sosetopt+0x408>
 8232f5c:	10c800e0 	cmpeqi	r3,r2,8195
 8232f60:	1800a61e 	bne	r3,zero,82331fc <sosetopt+0x36c>
 8232f64:	10c80108 	cmpgei	r3,r2,8196
 8232f68:	1800051e 	bne	r3,zero,8232f80 <sosetopt+0xf0>
 8232f6c:	10c40560 	cmpeqi	r3,r2,4117
 8232f70:	18003c1e 	bne	r3,zero,8233064 <sosetopt+0x1d4>
 8232f74:	108405a0 	cmpeqi	r2,r2,4118
 8232f78:	1000421e 	bne	r2,zero,8233084 <sosetopt+0x1f4>
 8232f7c:	0000c606 	br	8233298 <sosetopt+0x408>
 8232f80:	10c80120 	cmpeqi	r3,r2,8196
 8232f84:	1800711e 	bne	r3,zero,823314c <sosetopt+0x2bc>
 8232f88:	10900020 	cmpeqi	r2,r2,16384
 8232f8c:	1000061e 	bne	r2,zero,8232fa8 <sosetopt+0x118>
 8232f90:	0000c106 	br	8233298 <sosetopt+0x408>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 8232f94:	e0bfff17 	ldw	r2,-4(fp)
 8232f98:	10800117 	ldw	r2,4(r2)
 8232f9c:	1007883a 	mov	r3,r2
 8232fa0:	e0bffd17 	ldw	r2,-12(fp)
 8232fa4:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 8232fa8:	e0bfff17 	ldw	r2,-4(fp)
 8232fac:	10800017 	ldw	r2,0(r2)
 8232fb0:	10000726 	beq	r2,zero,8232fd0 <sosetopt+0x140>
         so->so_options |= optname;
 8232fb4:	e0bffd17 	ldw	r2,-12(fp)
 8232fb8:	10c00417 	ldw	r3,16(r2)
 8232fbc:	e0bffe17 	ldw	r2,-8(fp)
 8232fc0:	1886b03a 	or	r3,r3,r2
 8232fc4:	e0bffd17 	ldw	r2,-12(fp)
 8232fc8:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~optname;
      break;
 8232fcc:	0000b606 	br	82332a8 <sosetopt+0x418>
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
         so->so_options |= optname;
      else
         so->so_options &= ~optname;
 8232fd0:	e0bffd17 	ldw	r2,-12(fp)
 8232fd4:	10800417 	ldw	r2,16(r2)
 8232fd8:	e0fffe17 	ldw	r3,-8(fp)
 8232fdc:	00c6303a 	nor	r3,zero,r3
 8232fe0:	10c6703a 	and	r3,r2,r3
 8232fe4:	e0bffd17 	ldw	r2,-12(fp)
 8232fe8:	10c00415 	stw	r3,16(r2)
      break;
 8232fec:	0000ae06 	br	82332a8 <sosetopt+0x418>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8232ff0:	e0bffe17 	ldw	r2,-8(fp)
 8232ff4:	10840058 	cmpnei	r2,r2,4097
 8232ff8:	1000031e 	bne	r2,zero,8233008 <sosetopt+0x178>
 8232ffc:	e0bffd17 	ldw	r2,-12(fp)
 8233000:	10801204 	addi	r2,r2,72
 8233004:	00000206 	br	8233010 <sosetopt+0x180>
 8233008:	e0bffd17 	ldw	r2,-12(fp)
 823300c:	10800a04 	addi	r2,r2,40
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
 8233010:	e0ffff17 	ldw	r3,-4(fp)
 8233014:	18c00017 	ldw	r3,0(r3)
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8233018:	180b883a 	mov	r5,r3
 823301c:	1009883a 	mov	r4,r2
 8233020:	82340a40 	call	82340a4 <sbreserve>
 8233024:	10009f1e 	bne	r2,zero,82332a4 <sosetopt+0x414>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 8233028:	00801a44 	movi	r2,105
 823302c:	e0bff815 	stw	r2,-32(fp)
         goto bad;
 8233030:	00009d06 	br	82332a8 <sosetopt+0x418>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 8233034:	e0bfff17 	ldw	r2,-4(fp)
 8233038:	10c0000b 	ldhu	r3,0(r2)
 823303c:	e0bffd17 	ldw	r2,-12(fp)
 8233040:	10c0118d 	sth	r3,70(r2)
      break;
 8233044:	00009806 	br	82332a8 <sosetopt+0x418>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 8233048:	e0bffd17 	ldw	r2,-12(fp)
 823304c:	1080088b 	ldhu	r2,34(r2)
 8233050:	10804014 	ori	r2,r2,256
 8233054:	1007883a 	mov	r3,r2
 8233058:	e0bffd17 	ldw	r2,-12(fp)
 823305c:	10c0088d 	sth	r3,34(r2)
      break;
 8233060:	00009106 	br	82332a8 <sosetopt+0x418>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 8233064:	e0bffd17 	ldw	r2,-12(fp)
 8233068:	10c0088b 	ldhu	r3,34(r2)
 823306c:	00bfbfc4 	movi	r2,-257
 8233070:	1884703a 	and	r2,r3,r2
 8233074:	1007883a 	mov	r3,r2
 8233078:	e0bffd17 	ldw	r2,-12(fp)
 823307c:	10c0088d 	sth	r3,34(r2)
      break;
 8233080:	00008906 	br	82332a8 <sosetopt+0x418>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 8233084:	e0bfff17 	ldw	r2,-4(fp)
 8233088:	1000031e 	bne	r2,zero,8233098 <sosetopt+0x208>
      {
         error = ENP_PARAM;
 823308c:	00bffd84 	movi	r2,-10
 8233090:	e0bff815 	stw	r2,-32(fp)
         break;
 8233094:	00008406 	br	82332a8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 8233098:	e0bfff17 	ldw	r2,-4(fp)
 823309c:	10800017 	ldw	r2,0(r2)
 82330a0:	10000726 	beq	r2,zero,82330c0 <sosetopt+0x230>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 82330a4:	e0bffd17 	ldw	r2,-12(fp)
 82330a8:	1080088b 	ldhu	r2,34(r2)
 82330ac:	10804014 	ori	r2,r2,256
 82330b0:	1007883a 	mov	r3,r2
 82330b4:	e0bffd17 	ldw	r2,-12(fp)
 82330b8:	10c0088d 	sth	r3,34(r2)
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
      break;
 82330bc:	00007a06 	br	82332a8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 82330c0:	e0bffd17 	ldw	r2,-12(fp)
 82330c4:	10c0088b 	ldhu	r3,34(r2)
 82330c8:	00bfbfc4 	movi	r2,-257
 82330cc:	1884703a 	and	r2,r3,r2
 82330d0:	1007883a 	mov	r3,r2
 82330d4:	e0bffd17 	ldw	r2,-12(fp)
 82330d8:	10c0088d 	sth	r3,34(r2)
      break;
 82330dc:	00007206 	br	82332a8 <sosetopt+0x418>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 82330e0:	e1bfff17 	ldw	r6,-4(fp)
 82330e4:	e17ffd17 	ldw	r5,-12(fp)
 82330e8:	e13ffe17 	ldw	r4,-8(fp)
 82330ec:	8245cf80 	call	8245cf8 <ip_setmoptions>
 82330f0:	e0bff815 	stw	r2,-32(fp)
      break;
 82330f4:	00006c06 	br	82332a8 <sosetopt+0x418>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 82330f8:	e0bfff17 	ldw	r2,-4(fp)
 82330fc:	1000031e 	bne	r2,zero,823310c <sosetopt+0x27c>
      {
         error = ENP_PARAM;
 8233100:	00bffd84 	movi	r2,-10
 8233104:	e0bff815 	stw	r2,-32(fp)
         break;
 8233108:	00006706 	br	82332a8 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 823310c:	e0bfff17 	ldw	r2,-4(fp)
 8233110:	10800017 	ldw	r2,0(r2)
 8233114:	10000626 	beq	r2,zero,8233130 <sosetopt+0x2a0>
         so->so_options |= SO_HDRINCL;
 8233118:	e0bffd17 	ldw	r2,-12(fp)
 823311c:	10800417 	ldw	r2,16(r2)
 8233120:	10c80014 	ori	r3,r2,8192
 8233124:	e0bffd17 	ldw	r2,-12(fp)
 8233128:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~SO_HDRINCL;
      break;
 823312c:	00005e06 	br	82332a8 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
         so->so_options |= SO_HDRINCL;
      else
         so->so_options &= ~SO_HDRINCL;
 8233130:	e0bffd17 	ldw	r2,-12(fp)
 8233134:	10c00417 	ldw	r3,16(r2)
 8233138:	00b7ffc4 	movi	r2,-8193
 823313c:	1886703a 	and	r3,r3,r2
 8233140:	e0bffd17 	ldw	r2,-12(fp)
 8233144:	10c00415 	stw	r3,16(r2)
      break;
 8233148:	00005706 	br	82332a8 <sosetopt+0x418>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 823314c:	e0bffd17 	ldw	r2,-12(fp)
 8233150:	10800983 	ldbu	r2,38(r2)
 8233154:	10803fcc 	andi	r2,r2,255
 8233158:	1080201c 	xori	r2,r2,128
 823315c:	10bfe004 	addi	r2,r2,-128
 8233160:	10800060 	cmpeqi	r2,r2,1
 8233164:	1000031e 	bne	r2,zero,8233174 <sosetopt+0x2e4>
      {
         error = EINVAL;
 8233168:	00800584 	movi	r2,22
 823316c:	e0bff815 	stw	r2,-32(fp)
         break;
 8233170:	00004d06 	br	82332a8 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233174:	e0bffd17 	ldw	r2,-12(fp)
 8233178:	10800117 	ldw	r2,4(r2)
 823317c:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 8233180:	e0bff917 	ldw	r2,-28(fp)
 8233184:	10800917 	ldw	r2,36(r2)
 8233188:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 823318c:	e0bffa17 	ldw	r2,-24(fp)
 8233190:	1000031e 	bne	r2,zero,82331a0 <sosetopt+0x310>
      {
         error = ENOTCONN;
 8233194:	00802004 	movi	r2,128
 8233198:	e0bff815 	stw	r2,-32(fp)
         break;
 823319c:	00004206 	br	82332a8 <sosetopt+0x418>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 82331a0:	e0bfff17 	ldw	r2,-4(fp)
 82331a4:	1000031e 	bne	r2,zero,82331b4 <sosetopt+0x324>
      {
         error = ENP_PARAM;
 82331a8:	00bffd84 	movi	r2,-10
 82331ac:	e0bff815 	stw	r2,-32(fp)
         break;
 82331b0:	00003d06 	br	82332a8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 82331b4:	e0bfff17 	ldw	r2,-4(fp)
 82331b8:	10800017 	ldw	r2,0(r2)
 82331bc:	10000726 	beq	r2,zero,82331dc <sosetopt+0x34c>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 82331c0:	e0bffa17 	ldw	r2,-24(fp)
 82331c4:	10800b0b 	ldhu	r2,44(r2)
 82331c8:	10800114 	ori	r2,r2,4
 82331cc:	1007883a 	mov	r3,r2
 82331d0:	e0bffa17 	ldw	r2,-24(fp)
 82331d4:	10c00b0d 	sth	r3,44(r2)
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */

      break;
 82331d8:	00003306 	br	82332a8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 82331dc:	e0bffa17 	ldw	r2,-24(fp)
 82331e0:	10c00b0b 	ldhu	r3,44(r2)
 82331e4:	00bffec4 	movi	r2,-5
 82331e8:	1884703a 	and	r2,r3,r2
 82331ec:	1007883a 	mov	r3,r2
 82331f0:	e0bffa17 	ldw	r2,-24(fp)
 82331f4:	10c00b0d 	sth	r3,44(r2)

      break;
 82331f8:	00002b06 	br	82332a8 <sosetopt+0x418>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82331fc:	e0bffd17 	ldw	r2,-12(fp)
 8233200:	10800983 	ldbu	r2,38(r2)
 8233204:	10803fcc 	andi	r2,r2,255
 8233208:	1080201c 	xori	r2,r2,128
 823320c:	10bfe004 	addi	r2,r2,-128
 8233210:	10800060 	cmpeqi	r2,r2,1
 8233214:	1000031e 	bne	r2,zero,8233224 <sosetopt+0x394>
      {
         error = EINVAL;
 8233218:	00800584 	movi	r2,22
 823321c:	e0bff815 	stw	r2,-32(fp)
         break;
 8233220:	00002106 	br	82332a8 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233224:	e0bffd17 	ldw	r2,-12(fp)
 8233228:	10800117 	ldw	r2,4(r2)
 823322c:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 8233230:	e0bffb17 	ldw	r2,-20(fp)
 8233234:	10800917 	ldw	r2,36(r2)
 8233238:	e0bffc15 	stw	r2,-16(fp)
      if(!tp)
 823323c:	e0bffc17 	ldw	r2,-16(fp)
 8233240:	1000031e 	bne	r2,zero,8233250 <sosetopt+0x3c0>
      {
         error = ENOTCONN;
 8233244:	00802004 	movi	r2,128
 8233248:	e0bff815 	stw	r2,-32(fp)
         break;
 823324c:	00001606 	br	82332a8 <sosetopt+0x418>
      }
      if (tp->t_state != TCPS_CLOSED)
 8233250:	e0bffc17 	ldw	r2,-16(fp)
 8233254:	10800217 	ldw	r2,8(r2)
 8233258:	10000326 	beq	r2,zero,8233268 <sosetopt+0x3d8>
      {
         error = EINVAL;
 823325c:	00800584 	movi	r2,22
 8233260:	e0bff815 	stw	r2,-32(fp)
         break;
 8233264:	00001006 	br	82332a8 <sosetopt+0x418>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 8233268:	e0bfff17 	ldw	r2,-4(fp)
 823326c:	10800017 	ldw	r2,0(r2)
 8233270:	1007883a 	mov	r3,r2
 8233274:	e0bffc17 	ldw	r2,-16(fp)
 8233278:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 823327c:	e0bffc17 	ldw	r2,-16(fp)
 8233280:	10800b0b 	ldhu	r2,44(r2)
 8233284:	10810014 	ori	r2,r2,1024
 8233288:	1007883a 	mov	r3,r2
 823328c:	e0bffc17 	ldw	r2,-16(fp)
 8233290:	10c00b0d 	sth	r3,44(r2)
      break;
 8233294:	00000406 	br	82332a8 <sosetopt+0x418>
   }
   default:
      error = ENOPROTOOPT;
 8233298:	00801b44 	movi	r2,109
 823329c:	e0bff815 	stw	r2,-32(fp)
      break;
 82332a0:	00000106 	br	82332a8 <sosetopt+0x418>
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
         goto bad;
      }
      break;
 82332a4:	0001883a 	nop
   default:
      error = ENOPROTOOPT;
      break;
   }
bad:
   return (error);
 82332a8:	e0bff817 	ldw	r2,-32(fp)
}
 82332ac:	e037883a 	mov	sp,fp
 82332b0:	dfc00117 	ldw	ra,4(sp)
 82332b4:	df000017 	ldw	fp,0(sp)
 82332b8:	dec00204 	addi	sp,sp,8
 82332bc:	f800283a 	ret

082332c0 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 82332c0:	defff504 	addi	sp,sp,-44
 82332c4:	dfc00a15 	stw	ra,40(sp)
 82332c8:	df000915 	stw	fp,36(sp)
 82332cc:	df000904 	addi	fp,sp,36
 82332d0:	e13ffd15 	stw	r4,-12(fp)
 82332d4:	e17ffe15 	stw	r5,-8(fp)
 82332d8:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 82332dc:	e03ff715 	stw	zero,-36(fp)

   /* sanity check the val parameter */
   if (!val)
 82332e0:	e0bfff17 	ldw	r2,-4(fp)
 82332e4:	1000021e 	bne	r2,zero,82332f0 <sogetopt+0x30>
   {
      return ENP_PARAM;
 82332e8:	00bffd84 	movi	r2,-10
 82332ec:	00011906 	br	8233754 <sogetopt+0x494>
   }

   switch (optname) 
 82332f0:	e0bffe17 	ldw	r2,-8(fp)
 82332f4:	10c400e0 	cmpeqi	r3,r2,4099
 82332f8:	1800701e 	bne	r3,zero,82334bc <sogetopt+0x1fc>
 82332fc:	10c40108 	cmpgei	r3,r2,4100
 8233300:	1800201e 	bne	r3,zero,8233384 <sogetopt+0xc4>
 8233304:	10c00420 	cmpeqi	r3,r2,16
 8233308:	1800641e 	bne	r3,zero,823349c <sogetopt+0x1dc>
 823330c:	10c00448 	cmpgei	r3,r2,17
 8233310:	18000c1e 	bne	r3,zero,8233344 <sogetopt+0x84>
 8233314:	10c00220 	cmpeqi	r3,r2,8
 8233318:	1800601e 	bne	r3,zero,823349c <sogetopt+0x1dc>
 823331c:	10c00248 	cmpgei	r3,r2,9
 8233320:	1800051e 	bne	r3,zero,8233338 <sogetopt+0x78>
 8233324:	10c000a0 	cmpeqi	r3,r2,2
 8233328:	1800d61e 	bne	r3,zero,8233684 <sogetopt+0x3c4>
 823332c:	10800120 	cmpeqi	r2,r2,4
 8233330:	10005a1e 	bne	r2,zero,823349c <sogetopt+0x1dc>
 8233334:	00010406 	br	8233748 <sogetopt+0x488>
 8233338:	10800308 	cmpgei	r2,r2,12
 823333c:	1001021e 	bne	r2,zero,8233748 <sogetopt+0x488>
 8233340:	0000ca06 	br	823366c <sogetopt+0x3ac>
 8233344:	10c04020 	cmpeqi	r3,r2,256
 8233348:	1800541e 	bne	r3,zero,823349c <sogetopt+0x1dc>
 823334c:	10c04048 	cmpgei	r3,r2,257
 8233350:	1800051e 	bne	r3,zero,8233368 <sogetopt+0xa8>
 8233354:	10c00820 	cmpeqi	r3,r2,32
 8233358:	1800501e 	bne	r3,zero,823349c <sogetopt+0x1dc>
 823335c:	10802020 	cmpeqi	r2,r2,128
 8233360:	10003f1e 	bne	r2,zero,8233460 <sogetopt+0x1a0>
 8233364:	0000f806 	br	8233748 <sogetopt+0x488>
 8233368:	10c40060 	cmpeqi	r3,r2,4097
 823336c:	18005f1e 	bne	r3,zero,82334ec <sogetopt+0x22c>
 8233370:	10c40088 	cmpgei	r3,r2,4098
 8233374:	1800631e 	bne	r3,zero,8233504 <sogetopt+0x244>
 8233378:	10808020 	cmpeqi	r2,r2,512
 823337c:	1000471e 	bne	r2,zero,823349c <sogetopt+0x1dc>
 8233380:	0000f106 	br	8233748 <sogetopt+0x488>
 8233384:	10c40420 	cmpeqi	r3,r2,4112
 8233388:	18007f1e 	bne	r3,zero,8233588 <sogetopt+0x2c8>
 823338c:	10c40448 	cmpgei	r3,r2,4113
 8233390:	1800101e 	bne	r3,zero,82333d4 <sogetopt+0x114>
 8233394:	10c401a0 	cmpeqi	r3,r2,4102
 8233398:	18009b1e 	bne	r3,zero,8233608 <sogetopt+0x348>
 823339c:	10c401c8 	cmpgei	r3,r2,4103
 82333a0:	1800051e 	bne	r3,zero,82333b8 <sogetopt+0xf8>
 82333a4:	10c40120 	cmpeqi	r3,r2,4100
 82333a8:	18004a1e 	bne	r3,zero,82334d4 <sogetopt+0x214>
 82333ac:	10840160 	cmpeqi	r2,r2,4101
 82333b0:	1000901e 	bne	r2,zero,82335f4 <sogetopt+0x334>
 82333b4:	0000e406 	br	8233748 <sogetopt+0x488>
 82333b8:	10c40220 	cmpeqi	r3,r2,4104
 82333bc:	1800631e 	bne	r3,zero,823354c <sogetopt+0x28c>
 82333c0:	10c40210 	cmplti	r3,r2,4104
 82333c4:	1800691e 	bne	r3,zero,823356c <sogetopt+0x2ac>
 82333c8:	10840260 	cmpeqi	r2,r2,4105
 82333cc:	1000931e 	bne	r2,zero,823361c <sogetopt+0x35c>
 82333d0:	0000dd06 	br	8233748 <sogetopt+0x488>
 82333d4:	10c404e0 	cmpeqi	r3,r2,4115
 82333d8:	18000e1e 	bne	r3,zero,8233414 <sogetopt+0x154>
 82333dc:	10c40508 	cmpgei	r3,r2,4116
 82333e0:	1800051e 	bne	r3,zero,82333f8 <sogetopt+0x138>
 82333e4:	10c40460 	cmpeqi	r3,r2,4113
 82333e8:	18004c1e 	bne	r3,zero,823351c <sogetopt+0x25c>
 82333ec:	108404a0 	cmpeqi	r2,r2,4114
 82333f0:	1000501e 	bne	r2,zero,8233534 <sogetopt+0x274>
 82333f4:	0000d406 	br	8233748 <sogetopt+0x488>
 82333f8:	10c800e0 	cmpeqi	r3,r2,8195
 82333fc:	1800621e 	bne	r3,zero,8233588 <sogetopt+0x2c8>
 8233400:	10c80120 	cmpeqi	r3,r2,8196
 8233404:	1800aa1e 	bne	r3,zero,82336b0 <sogetopt+0x3f0>
 8233408:	108405a0 	cmpeqi	r2,r2,4118
 823340c:	10008b1e 	bne	r2,zero,823363c <sogetopt+0x37c>
 8233410:	0000cd06 	br	8233748 <sogetopt+0x488>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 8233414:	e0bffd17 	ldw	r2,-12(fp)
 8233418:	1080088b 	ldhu	r2,34(r2)
 823341c:	10bfffcc 	andi	r2,r2,65535
 8233420:	1080008c 	andi	r2,r2,2
 8233424:	10000726 	beq	r2,zero,8233444 <sogetopt+0x184>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 8233428:	e0bffd17 	ldw	r2,-12(fp)
 823342c:	10800117 	ldw	r2,4(r2)
 8233430:	10800a17 	ldw	r2,40(r2)
 8233434:	10c00a17 	ldw	r3,40(r2)
 8233438:	e0bfff17 	ldw	r2,-4(fp)
 823343c:	10c00015 	stw	r3,0(r2)
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
      break;
 8233440:	0000c306 	br	8233750 <sogetopt+0x490>
      if (so->so_state & SS_ISCONNECTED)
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 8233444:	008209b4 	movhi	r2,2086
 8233448:	10b73a04 	addi	r2,r2,-8984
 823344c:	10800017 	ldw	r2,0(r2)
 8233450:	10c00a17 	ldw	r3,40(r2)
 8233454:	e0bfff17 	ldw	r2,-4(fp)
 8233458:	10c00015 	stw	r3,0(r2)
      break;
 823345c:	0000bc06 	br	8233750 <sogetopt+0x490>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 8233460:	e0bfff17 	ldw	r2,-4(fp)
 8233464:	e0bff815 	stw	r2,-32(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 8233468:	e0bffd17 	ldw	r2,-12(fp)
 823346c:	10800417 	ldw	r2,16(r2)
 8233470:	10c0200c 	andi	r3,r2,128
 8233474:	e0bff817 	ldw	r2,-32(fp)
 8233478:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 823347c:	e0bffd17 	ldw	r2,-12(fp)
 8233480:	1080080b 	ldhu	r2,32(r2)
 8233484:	10ffffcc 	andi	r3,r2,65535
 8233488:	18e0001c 	xori	r3,r3,32768
 823348c:	18e00004 	addi	r3,r3,-32768
 8233490:	e0bff817 	ldw	r2,-32(fp)
 8233494:	10c00115 	stw	r3,4(r2)
      }
      break;
 8233498:	0000ad06 	br	8233750 <sogetopt+0x490>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 823349c:	e0bffd17 	ldw	r2,-12(fp)
 82334a0:	10c00417 	ldw	r3,16(r2)
 82334a4:	e0bffe17 	ldw	r2,-8(fp)
 82334a8:	1884703a 	and	r2,r3,r2
 82334ac:	1007883a 	mov	r3,r2
 82334b0:	e0bfff17 	ldw	r2,-4(fp)
 82334b4:	10c00015 	stw	r3,0(r2)
      break;
 82334b8:	0000a506 	br	8233750 <sogetopt+0x490>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 82334bc:	e0bffd17 	ldw	r2,-12(fp)
 82334c0:	10801617 	ldw	r2,88(r2)
 82334c4:	1007883a 	mov	r3,r2
 82334c8:	e0bfff17 	ldw	r2,-4(fp)
 82334cc:	10c00015 	stw	r3,0(r2)
      break;
 82334d0:	00009f06 	br	8233750 <sogetopt+0x490>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 82334d4:	e0bffd17 	ldw	r2,-12(fp)
 82334d8:	10800e17 	ldw	r2,56(r2)
 82334dc:	1007883a 	mov	r3,r2
 82334e0:	e0bfff17 	ldw	r2,-4(fp)
 82334e4:	10c00015 	stw	r3,0(r2)
      break;
 82334e8:	00009906 	br	8233750 <sogetopt+0x490>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 82334ec:	e0bffd17 	ldw	r2,-12(fp)
 82334f0:	10801317 	ldw	r2,76(r2)
 82334f4:	1007883a 	mov	r3,r2
 82334f8:	e0bfff17 	ldw	r2,-4(fp)
 82334fc:	10c00015 	stw	r3,0(r2)
      break;
 8233500:	00009306 	br	8233750 <sogetopt+0x490>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 8233504:	e0bffd17 	ldw	r2,-12(fp)
 8233508:	10800b17 	ldw	r2,44(r2)
 823350c:	1007883a 	mov	r3,r2
 8233510:	e0bfff17 	ldw	r2,-4(fp)
 8233514:	10c00015 	stw	r3,0(r2)
      break;
 8233518:	00008d06 	br	8233750 <sogetopt+0x490>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 823351c:	e0bffd17 	ldw	r2,-12(fp)
 8233520:	10800a17 	ldw	r2,40(r2)
 8233524:	1007883a 	mov	r3,r2
 8233528:	e0bfff17 	ldw	r2,-4(fp)
 823352c:	10c00015 	stw	r3,0(r2)
      break;
 8233530:	00008706 	br	8233750 <sogetopt+0x490>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 8233534:	e0bffd17 	ldw	r2,-12(fp)
 8233538:	10801217 	ldw	r2,72(r2)
 823353c:	1007883a 	mov	r3,r2
 8233540:	e0bfff17 	ldw	r2,-4(fp)
 8233544:	10c00015 	stw	r3,0(r2)
      break;
 8233548:	00008106 	br	8233750 <sogetopt+0x490>

   case SO_TYPE:
      *(int *)val = so->so_type;
 823354c:	e0bffd17 	ldw	r2,-12(fp)
 8233550:	10800983 	ldbu	r2,38(r2)
 8233554:	10c03fcc 	andi	r3,r2,255
 8233558:	18c0201c 	xori	r3,r3,128
 823355c:	18ffe004 	addi	r3,r3,-128
 8233560:	e0bfff17 	ldw	r2,-4(fp)
 8233564:	10c00015 	stw	r3,0(r2)
      break;
 8233568:	00007906 	br	8233750 <sogetopt+0x490>

   case SO_ERROR:
      *(int *)val = so->so_error;
 823356c:	e0bffd17 	ldw	r2,-12(fp)
 8233570:	10c00617 	ldw	r3,24(r2)
 8233574:	e0bfff17 	ldw	r2,-4(fp)
 8233578:	10c00015 	stw	r3,0(r2)
      so->so_error = 0;
 823357c:	e0bffd17 	ldw	r2,-12(fp)
 8233580:	10000615 	stw	zero,24(r2)
      break;
 8233584:	00007206 	br	8233750 <sogetopt+0x490>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233588:	e0bffd17 	ldw	r2,-12(fp)
 823358c:	10800983 	ldbu	r2,38(r2)
 8233590:	10803fcc 	andi	r2,r2,255
 8233594:	1080201c 	xori	r2,r2,128
 8233598:	10bfe004 	addi	r2,r2,-128
 823359c:	10800060 	cmpeqi	r2,r2,1
 82335a0:	1000031e 	bne	r2,zero,82335b0 <sogetopt+0x2f0>
      {
         error = EINVAL;
 82335a4:	00800584 	movi	r2,22
 82335a8:	e0bff715 	stw	r2,-36(fp)
         break;
 82335ac:	00006806 	br	8233750 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82335b0:	e0bffd17 	ldw	r2,-12(fp)
 82335b4:	10800117 	ldw	r2,4(r2)
 82335b8:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 82335bc:	e0bff917 	ldw	r2,-28(fp)
 82335c0:	10800917 	ldw	r2,36(r2)
 82335c4:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 82335c8:	e0bffa17 	ldw	r2,-24(fp)
 82335cc:	1000031e 	bne	r2,zero,82335dc <sogetopt+0x31c>
      {
         error = ENOTCONN;
 82335d0:	00802004 	movi	r2,128
 82335d4:	e0bff715 	stw	r2,-36(fp)
         break;
 82335d8:	00005d06 	br	8233750 <sogetopt+0x490>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 82335dc:	e0bffa17 	ldw	r2,-24(fp)
 82335e0:	10800a0b 	ldhu	r2,40(r2)
 82335e4:	10ffffcc 	andi	r3,r2,65535
 82335e8:	e0bfff17 	ldw	r2,-4(fp)
 82335ec:	10c00015 	stw	r3,0(r2)
      break;
 82335f0:	00005706 	br	8233750 <sogetopt+0x490>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 82335f4:	e0bffd17 	ldw	r2,-12(fp)
 82335f8:	10c0198b 	ldhu	r3,102(r2)
 82335fc:	e0bfff17 	ldw	r2,-4(fp)
 8233600:	10c0000d 	sth	r3,0(r2)
      break;
 8233604:	00005206 	br	8233750 <sogetopt+0x490>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 8233608:	e0bffd17 	ldw	r2,-12(fp)
 823360c:	10c0118b 	ldhu	r3,70(r2)
 8233610:	e0bfff17 	ldw	r2,-4(fp)
 8233614:	10c0000d 	sth	r3,0(r2)
      break;
 8233618:	00004d06 	br	8233750 <sogetopt+0x490>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 823361c:	e0bffd17 	ldw	r2,-12(fp)
 8233620:	108009c3 	ldbu	r2,39(r2)
 8233624:	10c03fcc 	andi	r3,r2,255
 8233628:	18c0201c 	xori	r3,r3,128
 823362c:	18ffe004 	addi	r3,r3,-128
 8233630:	e0bfff17 	ldw	r2,-4(fp)
 8233634:	10c00015 	stw	r3,0(r2)
      break;
 8233638:	00004506 	br	8233750 <sogetopt+0x490>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 823363c:	e0bffd17 	ldw	r2,-12(fp)
 8233640:	1080088b 	ldhu	r2,34(r2)
 8233644:	10bfffcc 	andi	r2,r2,65535
 8233648:	1080400c 	andi	r2,r2,256
 823364c:	10000426 	beq	r2,zero,8233660 <sogetopt+0x3a0>
         *(int *)val = 1;   /* return 1 in val */
 8233650:	e0bfff17 	ldw	r2,-4(fp)
 8233654:	00c00044 	movi	r3,1
 8233658:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;     /* return 0 in val */
      break;
 823365c:	00003c06 	br	8233750 <sogetopt+0x490>
   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
         *(int *)val = 1;   /* return 1 in val */
      else
         *(int *)val = 0;     /* return 0 in val */
 8233660:	e0bfff17 	ldw	r2,-4(fp)
 8233664:	10000015 	stw	zero,0(r2)
      break;
 8233668:	00003906 	br	8233750 <sogetopt+0x490>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 823366c:	e1bfff17 	ldw	r6,-4(fp)
 8233670:	e17ffd17 	ldw	r5,-12(fp)
 8233674:	e13ffe17 	ldw	r4,-8(fp)
 8233678:	82462c00 	call	82462c0 <ip_getmoptions>
 823367c:	e0bff715 	stw	r2,-36(fp)
      break;
 8233680:	00003306 	br	8233750 <sogetopt+0x490>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 8233684:	e0bffd17 	ldw	r2,-12(fp)
 8233688:	10800417 	ldw	r2,16(r2)
 823368c:	1088000c 	andi	r2,r2,8192
 8233690:	10000426 	beq	r2,zero,82336a4 <sogetopt+0x3e4>
         *(int *)val = 1;
 8233694:	e0bfff17 	ldw	r2,-4(fp)
 8233698:	00c00044 	movi	r3,1
 823369c:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;
      break;
 82336a0:	00002b06 	br	8233750 <sogetopt+0x490>
   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
         *(int *)val = 1;
      else
         *(int *)val = 0;
 82336a4:	e0bfff17 	ldw	r2,-4(fp)
 82336a8:	10000015 	stw	zero,0(r2)
      break;
 82336ac:	00002806 	br	8233750 <sogetopt+0x490>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82336b0:	e0bffd17 	ldw	r2,-12(fp)
 82336b4:	10800983 	ldbu	r2,38(r2)
 82336b8:	10803fcc 	andi	r2,r2,255
 82336bc:	1080201c 	xori	r2,r2,128
 82336c0:	10bfe004 	addi	r2,r2,-128
 82336c4:	10800060 	cmpeqi	r2,r2,1
 82336c8:	1000031e 	bne	r2,zero,82336d8 <sogetopt+0x418>
      {
         error = EINVAL;
 82336cc:	00800584 	movi	r2,22
 82336d0:	e0bff715 	stw	r2,-36(fp)
         break;
 82336d4:	00001e06 	br	8233750 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82336d8:	e0bffd17 	ldw	r2,-12(fp)
 82336dc:	10800117 	ldw	r2,4(r2)
 82336e0:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 82336e4:	e0bffb17 	ldw	r2,-20(fp)
 82336e8:	10800917 	ldw	r2,36(r2)
 82336ec:	e0bffc15 	stw	r2,-16(fp)
      if (!tp)
 82336f0:	e0bffc17 	ldw	r2,-16(fp)
 82336f4:	1000031e 	bne	r2,zero,8233704 <sogetopt+0x444>
      {
         error = ENOTCONN;
 82336f8:	00802004 	movi	r2,128
 82336fc:	e0bff715 	stw	r2,-36(fp)
         break;
 8233700:	00001306 	br	8233750 <sogetopt+0x490>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 8233704:	e0bfff17 	ldw	r2,-4(fp)
 8233708:	1000031e 	bne	r2,zero,8233718 <sogetopt+0x458>
      {
         error = ENP_PARAM;
 823370c:	00bffd84 	movi	r2,-10
 8233710:	e0bff715 	stw	r2,-36(fp)
         break;
 8233714:	00000e06 	br	8233750 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 8233718:	e0bffc17 	ldw	r2,-16(fp)
 823371c:	10800b0b 	ldhu	r2,44(r2)
 8233720:	10bfffcc 	andi	r2,r2,65535
 8233724:	1080010c 	andi	r2,r2,4
 8233728:	10000426 	beq	r2,zero,823373c <sogetopt+0x47c>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 823372c:	e0bfff17 	ldw	r2,-4(fp)
 8233730:	00c00044 	movi	r3,1
 8233734:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */

      break;
 8233738:	00000506 	br	8233750 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 823373c:	e0bfff17 	ldw	r2,-4(fp)
 8233740:	10000015 	stw	zero,0(r2)

      break;
 8233744:	00000206 	br	8233750 <sogetopt+0x490>
   }

   default:
      return ENOPROTOOPT;
 8233748:	00801b44 	movi	r2,109
 823374c:	00000106 	br	8233754 <sogetopt+0x494>
   }
   return error;     /* no error */
 8233750:	e0bff717 	ldw	r2,-36(fp)
}
 8233754:	e037883a 	mov	sp,fp
 8233758:	dfc00117 	ldw	ra,4(sp)
 823375c:	df000017 	ldw	fp,0(sp)
 8233760:	dec00204 	addi	sp,sp,8
 8233764:	f800283a 	ret

08233768 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 8233768:	defffd04 	addi	sp,sp,-12
 823376c:	dfc00215 	stw	ra,8(sp)
 8233770:	df000115 	stw	fp,4(sp)
 8233774:	df000104 	addi	fp,sp,4
 8233778:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 823377c:	e0bfff17 	ldw	r2,-4(fp)
 8233780:	00c03644 	movi	r3,217
 8233784:	10c00615 	stw	r3,24(r2)
   sorwakeup (so);
 8233788:	e0bfff17 	ldw	r2,-4(fp)
 823378c:	10800a04 	addi	r2,r2,40
 8233790:	100b883a 	mov	r5,r2
 8233794:	e13fff17 	ldw	r4,-4(fp)
 8233798:	8233f900 	call	8233f90 <sbwakeup>
}
 823379c:	0001883a 	nop
 82337a0:	e037883a 	mov	sp,fp
 82337a4:	dfc00117 	ldw	ra,4(sp)
 82337a8:	df000017 	ldw	fp,0(sp)
 82337ac:	dec00204 	addi	sp,sp,8
 82337b0:	f800283a 	ret

082337b4 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 82337b4:	defffd04 	addi	sp,sp,-12
 82337b8:	dfc00215 	stw	ra,8(sp)
 82337bc:	df000115 	stw	fp,4(sp)
 82337c0:	df000104 	addi	fp,sp,4
 82337c4:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 82337c8:	e0bfff17 	ldw	r2,-4(fp)
 82337cc:	10c0088b 	ldhu	r3,34(r2)
 82337d0:	00bffd44 	movi	r2,-11
 82337d4:	1884703a 	and	r2,r3,r2
 82337d8:	1007883a 	mov	r3,r2
 82337dc:	e0bfff17 	ldw	r2,-4(fp)
 82337e0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 82337e4:	e0bfff17 	ldw	r2,-4(fp)
 82337e8:	1080088b 	ldhu	r2,34(r2)
 82337ec:	10800114 	ori	r2,r2,4
 82337f0:	1007883a 	mov	r3,r2
 82337f4:	e0bfff17 	ldw	r2,-4(fp)
 82337f8:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 82337fc:	e0bfff17 	ldw	r2,-4(fp)
 8233800:	10800904 	addi	r2,r2,36
 8233804:	1009883a 	mov	r4,r2
 8233808:	82293f40 	call	82293f4 <tcp_wakeup>
}
 823380c:	0001883a 	nop
 8233810:	e037883a 	mov	sp,fp
 8233814:	dfc00117 	ldw	ra,4(sp)
 8233818:	df000017 	ldw	fp,0(sp)
 823381c:	dec00204 	addi	sp,sp,8
 8233820:	f800283a 	ret

08233824 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 8233824:	defffc04 	addi	sp,sp,-16
 8233828:	dfc00315 	stw	ra,12(sp)
 823382c:	df000215 	stw	fp,8(sp)
 8233830:	df000204 	addi	fp,sp,8
 8233834:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 8233838:	e0bfff17 	ldw	r2,-4(fp)
 823383c:	10801b17 	ldw	r2,108(r2)
 8233840:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 8233844:	e0bffe17 	ldw	r2,-8(fp)
 8233848:	10001426 	beq	r2,zero,823389c <soisconnected+0x78>
   {
      if (soqremque(so, 0) == 0)
 823384c:	000b883a 	mov	r5,zero
 8233850:	e13fff17 	ldw	r4,-4(fp)
 8233854:	8233d300 	call	8233d30 <soqremque>
 8233858:	1000031e 	bne	r2,zero,8233868 <soisconnected+0x44>
         panic("soisconnected");
 823385c:	01020974 	movhi	r4,2085
 8233860:	2102a904 	addi	r4,r4,2724
 8233864:	82289940 	call	8228994 <panic>
      soqinsque(head, so, 1);
 8233868:	01800044 	movi	r6,1
 823386c:	e17fff17 	ldw	r5,-4(fp)
 8233870:	e13ffe17 	ldw	r4,-8(fp)
 8233874:	8233c840 	call	8233c84 <soqinsque>
      sorwakeup(head);
 8233878:	e0bffe17 	ldw	r2,-8(fp)
 823387c:	10800a04 	addi	r2,r2,40
 8233880:	100b883a 	mov	r5,r2
 8233884:	e13ffe17 	ldw	r4,-8(fp)
 8233888:	8233f900 	call	8233f90 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 823388c:	e0bffe17 	ldw	r2,-8(fp)
 8233890:	10800904 	addi	r2,r2,36
 8233894:	1009883a 	mov	r4,r2
 8233898:	82293f40 	call	82293f4 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 823389c:	e0bfff17 	ldw	r2,-4(fp)
 82338a0:	10c0088b 	ldhu	r3,34(r2)
 82338a4:	00bffcc4 	movi	r2,-13
 82338a8:	1884703a 	and	r2,r3,r2
 82338ac:	1007883a 	mov	r3,r2
 82338b0:	e0bfff17 	ldw	r2,-4(fp)
 82338b4:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 82338b8:	e0bfff17 	ldw	r2,-4(fp)
 82338bc:	1080088b 	ldhu	r2,34(r2)
 82338c0:	10800094 	ori	r2,r2,2
 82338c4:	1007883a 	mov	r3,r2
 82338c8:	e0bfff17 	ldw	r2,-4(fp)
 82338cc:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 82338d0:	e0bfff17 	ldw	r2,-4(fp)
 82338d4:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 82338d8:	e0bfff17 	ldw	r2,-4(fp)
 82338dc:	10800904 	addi	r2,r2,36
 82338e0:	1009883a 	mov	r4,r2
 82338e4:	82293f40 	call	82293f4 <tcp_wakeup>
   sorwakeup (so);
 82338e8:	e0bfff17 	ldw	r2,-4(fp)
 82338ec:	10800a04 	addi	r2,r2,40
 82338f0:	100b883a 	mov	r5,r2
 82338f4:	e13fff17 	ldw	r4,-4(fp)
 82338f8:	8233f900 	call	8233f90 <sbwakeup>
   sowwakeup (so);
 82338fc:	e0bfff17 	ldw	r2,-4(fp)
 8233900:	10801204 	addi	r2,r2,72
 8233904:	100b883a 	mov	r5,r2
 8233908:	e13fff17 	ldw	r4,-4(fp)
 823390c:	8233f900 	call	8233f90 <sbwakeup>
}
 8233910:	0001883a 	nop
 8233914:	e037883a 	mov	sp,fp
 8233918:	dfc00117 	ldw	ra,4(sp)
 823391c:	df000017 	ldw	fp,0(sp)
 8233920:	dec00204 	addi	sp,sp,8
 8233924:	f800283a 	ret

08233928 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 8233928:	defffd04 	addi	sp,sp,-12
 823392c:	dfc00215 	stw	ra,8(sp)
 8233930:	df000115 	stw	fp,4(sp)
 8233934:	df000104 	addi	fp,sp,4
 8233938:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 823393c:	e0bfff17 	ldw	r2,-4(fp)
 8233940:	10c0088b 	ldhu	r3,34(r2)
 8233944:	00bffec4 	movi	r2,-5
 8233948:	1884703a 	and	r2,r3,r2
 823394c:	1007883a 	mov	r3,r2
 8233950:	e0bfff17 	ldw	r2,-4(fp)
 8233954:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233958:	e0bfff17 	ldw	r2,-4(fp)
 823395c:	1080088b 	ldhu	r2,34(r2)
 8233960:	10800e14 	ori	r2,r2,56
 8233964:	1007883a 	mov	r3,r2
 8233968:	e0bfff17 	ldw	r2,-4(fp)
 823396c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 8233970:	e0bfff17 	ldw	r2,-4(fp)
 8233974:	10800904 	addi	r2,r2,36
 8233978:	1009883a 	mov	r4,r2
 823397c:	82293f40 	call	82293f4 <tcp_wakeup>
   sowwakeup (so);
 8233980:	e0bfff17 	ldw	r2,-4(fp)
 8233984:	10801204 	addi	r2,r2,72
 8233988:	100b883a 	mov	r5,r2
 823398c:	e13fff17 	ldw	r4,-4(fp)
 8233990:	8233f900 	call	8233f90 <sbwakeup>
   sorwakeup (so);
 8233994:	e0bfff17 	ldw	r2,-4(fp)
 8233998:	10800a04 	addi	r2,r2,40
 823399c:	100b883a 	mov	r5,r2
 82339a0:	e13fff17 	ldw	r4,-4(fp)
 82339a4:	8233f900 	call	8233f90 <sbwakeup>
}
 82339a8:	0001883a 	nop
 82339ac:	e037883a 	mov	sp,fp
 82339b0:	dfc00117 	ldw	ra,4(sp)
 82339b4:	df000017 	ldw	fp,0(sp)
 82339b8:	dec00204 	addi	sp,sp,8
 82339bc:	f800283a 	ret

082339c0 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 82339c0:	defffd04 	addi	sp,sp,-12
 82339c4:	dfc00215 	stw	ra,8(sp)
 82339c8:	df000115 	stw	fp,4(sp)
 82339cc:	df000104 	addi	fp,sp,4
 82339d0:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 82339d4:	e0bfff17 	ldw	r2,-4(fp)
 82339d8:	1080088b 	ldhu	r2,34(r2)
 82339dc:	10bfffcc 	andi	r2,r2,65535
 82339e0:	1080010c 	andi	r2,r2,4
 82339e4:	10000626 	beq	r2,zero,8233a00 <soisdisconnected+0x40>
      so->so_state |= SS_WASCONNECTING;
 82339e8:	e0bfff17 	ldw	r2,-4(fp)
 82339ec:	1080088b 	ldhu	r2,34(r2)
 82339f0:	10880014 	ori	r2,r2,8192
 82339f4:	1007883a 	mov	r3,r2
 82339f8:	e0bfff17 	ldw	r2,-4(fp)
 82339fc:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 8233a00:	e0bfff17 	ldw	r2,-4(fp)
 8233a04:	10c0088b 	ldhu	r3,34(r2)
 8233a08:	00bffc44 	movi	r2,-15
 8233a0c:	1884703a 	and	r2,r3,r2
 8233a10:	1007883a 	mov	r3,r2
 8233a14:	e0bfff17 	ldw	r2,-4(fp)
 8233a18:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233a1c:	e0bfff17 	ldw	r2,-4(fp)
 8233a20:	1080088b 	ldhu	r2,34(r2)
 8233a24:	10800c14 	ori	r2,r2,48
 8233a28:	1007883a 	mov	r3,r2
 8233a2c:	e0bfff17 	ldw	r2,-4(fp)
 8233a30:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233a34:	e0bfff17 	ldw	r2,-4(fp)
 8233a38:	10800904 	addi	r2,r2,36
 8233a3c:	1009883a 	mov	r4,r2
 8233a40:	82293f40 	call	82293f4 <tcp_wakeup>
   sowwakeup (so);
 8233a44:	e0bfff17 	ldw	r2,-4(fp)
 8233a48:	10801204 	addi	r2,r2,72
 8233a4c:	100b883a 	mov	r5,r2
 8233a50:	e13fff17 	ldw	r4,-4(fp)
 8233a54:	8233f900 	call	8233f90 <sbwakeup>
   sorwakeup (so);
 8233a58:	e0bfff17 	ldw	r2,-4(fp)
 8233a5c:	10800a04 	addi	r2,r2,40
 8233a60:	100b883a 	mov	r5,r2
 8233a64:	e13fff17 	ldw	r4,-4(fp)
 8233a68:	8233f900 	call	8233f90 <sbwakeup>
}
 8233a6c:	0001883a 	nop
 8233a70:	e037883a 	mov	sp,fp
 8233a74:	dfc00117 	ldw	ra,4(sp)
 8233a78:	df000017 	ldw	fp,0(sp)
 8233a7c:	dec00204 	addi	sp,sp,8
 8233a80:	f800283a 	ret

08233a84 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 8233a84:	defffb04 	addi	sp,sp,-20
 8233a88:	dfc00415 	stw	ra,16(sp)
 8233a8c:	df000315 	stw	fp,12(sp)
 8233a90:	df000304 	addi	fp,sp,12
 8233a94:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 8233a98:	e0bfff17 	ldw	r2,-4(fp)
 8233a9c:	10801e43 	ldbu	r2,121(r2)
 8233aa0:	10c03fcc 	andi	r3,r2,255
 8233aa4:	18c0201c 	xori	r3,r3,128
 8233aa8:	18ffe004 	addi	r3,r3,-128
 8233aac:	e0bfff17 	ldw	r2,-4(fp)
 8233ab0:	10801e03 	ldbu	r2,120(r2)
 8233ab4:	10803fcc 	andi	r2,r2,255
 8233ab8:	1080201c 	xori	r2,r2,128
 8233abc:	10bfe004 	addi	r2,r2,-128
 8233ac0:	1889883a 	add	r4,r3,r2
 8233ac4:	e0bfff17 	ldw	r2,-4(fp)
 8233ac8:	10801e83 	ldbu	r2,122(r2)
 8233acc:	10c03fcc 	andi	r3,r2,255
 8233ad0:	18c0201c 	xori	r3,r3,128
 8233ad4:	18ffe004 	addi	r3,r3,-128
 8233ad8:	1805883a 	mov	r2,r3
 8233adc:	1085883a 	add	r2,r2,r2
 8233ae0:	10c5883a 	add	r2,r2,r3
 8233ae4:	1006d7fa 	srli	r3,r2,31
 8233ae8:	1885883a 	add	r2,r3,r2
 8233aec:	1005d07a 	srai	r2,r2,1
 8233af0:	11005b16 	blt	r2,r4,8233c60 <sonewconn+0x1dc>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8233af4:	01002104 	movi	r4,132
 8233af8:	822deb80 	call	822deb8 <npalloc>
 8233afc:	e0bffd15 	stw	r2,-12(fp)
 8233b00:	e0bffd17 	ldw	r2,-12(fp)
 8233b04:	10005826 	beq	r2,zero,8233c68 <sonewconn+0x1e4>
      goto bad;
   so->next = NULL;
 8233b08:	e0bffd17 	ldw	r2,-12(fp)
 8233b0c:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 8233b10:	e17ffd17 	ldw	r5,-12(fp)
 8233b14:	010209b4 	movhi	r4,2086
 8233b18:	21387704 	addi	r4,r4,-7716
 8233b1c:	822ccc80 	call	822ccc8 <putq>
   so->so_type = head->so_type;
 8233b20:	e0bfff17 	ldw	r2,-4(fp)
 8233b24:	10c00983 	ldbu	r3,38(r2)
 8233b28:	e0bffd17 	ldw	r2,-12(fp)
 8233b2c:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 8233b30:	e0bfff17 	ldw	r2,-4(fp)
 8233b34:	10c00417 	ldw	r3,16(r2)
 8233b38:	00bfff44 	movi	r2,-3
 8233b3c:	1886703a 	and	r3,r3,r2
 8233b40:	e0bffd17 	ldw	r2,-12(fp)
 8233b44:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 8233b48:	e0bfff17 	ldw	r2,-4(fp)
 8233b4c:	10c0080b 	ldhu	r3,32(r2)
 8233b50:	e0bffd17 	ldw	r2,-12(fp)
 8233b54:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 8233b58:	e0bfff17 	ldw	r2,-4(fp)
 8233b5c:	1080088b 	ldhu	r2,34(r2)
 8233b60:	10800054 	ori	r2,r2,1
 8233b64:	1007883a 	mov	r3,r2
 8233b68:	e0bffd17 	ldw	r2,-12(fp)
 8233b6c:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 8233b70:	e0bfff17 	ldw	r2,-4(fp)
 8233b74:	10c00217 	ldw	r3,8(r2)
 8233b78:	e0bffd17 	ldw	r2,-12(fp)
 8233b7c:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 8233b80:	e0bfff17 	ldw	r2,-4(fp)
 8233b84:	10c0090b 	ldhu	r3,36(r2)
 8233b88:	e0bffd17 	ldw	r2,-12(fp)
 8233b8c:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 8233b90:	d0e04117 	ldw	r3,-32508(gp)
 8233b94:	e0bffd17 	ldw	r2,-12(fp)
 8233b98:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 8233b9c:	d0e04017 	ldw	r3,-32512(gp)
 8233ba0:	e0bffd17 	ldw	r2,-12(fp)
 8233ba4:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 8233ba8:	000d883a 	mov	r6,zero
 8233bac:	e17ffd17 	ldw	r5,-12(fp)
 8233bb0:	e13fff17 	ldw	r4,-4(fp)
 8233bb4:	8233c840 	call	8233c84 <soqinsque>
   so->so_req = PRU_ATTACH;
 8233bb8:	e0bffd17 	ldw	r2,-12(fp)
 8233bbc:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 8233bc0:	e0bfff17 	ldw	r2,-4(fp)
 8233bc4:	10c00517 	ldw	r3,20(r2)
 8233bc8:	e0bffd17 	ldw	r2,-12(fp)
 8233bcc:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 8233bd0:	e0bffd17 	ldw	r2,-12(fp)
 8233bd4:	10800217 	ldw	r2,8(r2)
 8233bd8:	10800317 	ldw	r2,12(r2)
 8233bdc:	000d883a 	mov	r6,zero
 8233be0:	000b883a 	mov	r5,zero
 8233be4:	e13ffd17 	ldw	r4,-12(fp)
 8233be8:	103ee83a 	callr	r2
 8233bec:	10000f1e 	bne	r2,zero,8233c2c <sonewconn+0x1a8>
      goto bad2;
   if (so_evtmap)
 8233bf0:	d0a0ce03 	ldbu	r2,-31944(gp)
 8233bf4:	10803fcc 	andi	r2,r2,255
 8233bf8:	10000a26 	beq	r2,zero,8233c24 <sonewconn+0x1a0>
   {
      rc = (*so_evtmap_create) (so);                       
 8233bfc:	d0a0cc17 	ldw	r2,-31952(gp)
 8233c00:	e13ffd17 	ldw	r4,-12(fp)
 8233c04:	103ee83a 	callr	r2
 8233c08:	e0bffe15 	stw	r2,-8(fp)
      if (rc != 0) goto bad2;
 8233c0c:	e0bffe17 	ldw	r2,-8(fp)
 8233c10:	1000081e 	bne	r2,zero,8233c34 <sonewconn+0x1b0>
      so->owner = head->owner;
 8233c14:	e0bfff17 	ldw	r2,-4(fp)
 8233c18:	10c02003 	ldbu	r3,128(r2)
 8233c1c:	e0bffd17 	ldw	r2,-12(fp)
 8233c20:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 8233c24:	e0bffd17 	ldw	r2,-12(fp)
 8233c28:	00001106 	br	8233c70 <sonewconn+0x1ec>
   soqinsque (head, so, 0);
   so->so_req = PRU_ATTACH;
   so->so_domain = head->so_domain;

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
      goto bad2;
 8233c2c:	0001883a 	nop
 8233c30:	00000106 	br	8233c38 <sonewconn+0x1b4>
   if (so_evtmap)
   {
      rc = (*so_evtmap_create) (so);                       
      if (rc != 0) goto bad2;
 8233c34:	0001883a 	nop
      so->owner = head->owner;
   }
   return (so);
   
bad2:
   (void) soqremque (so, 0);
 8233c38:	000b883a 	mov	r5,zero
 8233c3c:	e13ffd17 	ldw	r4,-12(fp)
 8233c40:	8233d300 	call	8233d30 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8233c44:	e17ffd17 	ldw	r5,-12(fp)
 8233c48:	010209b4 	movhi	r4,2086
 8233c4c:	21387704 	addi	r4,r4,-7716
 8233c50:	822cd780 	call	822cd78 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 8233c54:	e13ffd17 	ldw	r4,-12(fp)
 8233c58:	822deec0 	call	822deec <npfree>
 8233c5c:	00000306 	br	8233c6c <sonewconn+0x1e8>
{
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
      goto bad;
 8233c60:	0001883a 	nop
 8233c64:	00000106 	br	8233c6c <sonewconn+0x1e8>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
      goto bad;
 8233c68:	0001883a 	nop
bad2:
   (void) soqremque (so, 0);
   qdel(&soq, so);   /* Delete the socket entry from the queue */
   SOC_FREE(so);  /* Free the socket structure */
bad:
   return ((struct socket *)0);
 8233c6c:	0005883a 	mov	r2,zero
}
 8233c70:	e037883a 	mov	sp,fp
 8233c74:	dfc00117 	ldw	ra,4(sp)
 8233c78:	df000017 	ldw	fp,0(sp)
 8233c7c:	dec00204 	addi	sp,sp,8
 8233c80:	f800283a 	ret

08233c84 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 8233c84:	defffc04 	addi	sp,sp,-16
 8233c88:	df000315 	stw	fp,12(sp)
 8233c8c:	df000304 	addi	fp,sp,12
 8233c90:	e13ffd15 	stw	r4,-12(fp)
 8233c94:	e17ffe15 	stw	r5,-8(fp)
 8233c98:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 8233c9c:	e0bffe17 	ldw	r2,-8(fp)
 8233ca0:	e0fffd17 	ldw	r3,-12(fp)
 8233ca4:	10c01b15 	stw	r3,108(r2)
   if (q == 0) 
 8233ca8:	e0bfff17 	ldw	r2,-4(fp)
 8233cac:	10000e1e 	bne	r2,zero,8233ce8 <soqinsque+0x64>
   {
      head->so_q0len++;
 8233cb0:	e0bffd17 	ldw	r2,-12(fp)
 8233cb4:	10801e03 	ldbu	r2,120(r2)
 8233cb8:	10800044 	addi	r2,r2,1
 8233cbc:	1007883a 	mov	r3,r2
 8233cc0:	e0bffd17 	ldw	r2,-12(fp)
 8233cc4:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 8233cc8:	e0bffd17 	ldw	r2,-12(fp)
 8233ccc:	10c01c17 	ldw	r3,112(r2)
 8233cd0:	e0bffe17 	ldw	r2,-8(fp)
 8233cd4:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 8233cd8:	e0bffd17 	ldw	r2,-12(fp)
 8233cdc:	e0fffe17 	ldw	r3,-8(fp)
 8233ce0:	10c01c15 	stw	r3,112(r2)
   {
      head->so_qlen++;
      so->so_q = head->so_q;
      head->so_q = so;
   }
}
 8233ce4:	00000d06 	br	8233d1c <soqinsque+0x98>
      head->so_q0len++;
      so->so_q0 = head->so_q0;
      head->so_q0 = so;
   } else 
   {
      head->so_qlen++;
 8233ce8:	e0bffd17 	ldw	r2,-12(fp)
 8233cec:	10801e43 	ldbu	r2,121(r2)
 8233cf0:	10800044 	addi	r2,r2,1
 8233cf4:	1007883a 	mov	r3,r2
 8233cf8:	e0bffd17 	ldw	r2,-12(fp)
 8233cfc:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 8233d00:	e0bffd17 	ldw	r2,-12(fp)
 8233d04:	10c01d17 	ldw	r3,116(r2)
 8233d08:	e0bffe17 	ldw	r2,-8(fp)
 8233d0c:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 8233d10:	e0bffd17 	ldw	r2,-12(fp)
 8233d14:	e0fffe17 	ldw	r3,-8(fp)
 8233d18:	10c01d15 	stw	r3,116(r2)
   }
}
 8233d1c:	0001883a 	nop
 8233d20:	e037883a 	mov	sp,fp
 8233d24:	df000017 	ldw	fp,0(sp)
 8233d28:	dec00104 	addi	sp,sp,4
 8233d2c:	f800283a 	ret

08233d30 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 8233d30:	defffa04 	addi	sp,sp,-24
 8233d34:	df000515 	stw	fp,20(sp)
 8233d38:	df000504 	addi	fp,sp,20
 8233d3c:	e13ffe15 	stw	r4,-8(fp)
 8233d40:	e17fff15 	stw	r5,-4(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 8233d44:	e0bffe17 	ldw	r2,-8(fp)
 8233d48:	10801b17 	ldw	r2,108(r2)
 8233d4c:	e0bffc15 	stw	r2,-16(fp)
   prev = head;
 8233d50:	e0bffc17 	ldw	r2,-16(fp)
 8233d54:	e0bffb15 	stw	r2,-20(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 8233d58:	e0bfff17 	ldw	r2,-4(fp)
 8233d5c:	10000326 	beq	r2,zero,8233d6c <soqremque+0x3c>
 8233d60:	e0bffb17 	ldw	r2,-20(fp)
 8233d64:	10801d17 	ldw	r2,116(r2)
 8233d68:	00000206 	br	8233d74 <soqremque+0x44>
 8233d6c:	e0bffb17 	ldw	r2,-20(fp)
 8233d70:	10801c17 	ldw	r2,112(r2)
 8233d74:	e0bffd15 	stw	r2,-12(fp)
      if (next == so)
 8233d78:	e0fffd17 	ldw	r3,-12(fp)
 8233d7c:	e0bffe17 	ldw	r2,-8(fp)
 8233d80:	18800826 	beq	r3,r2,8233da4 <soqremque+0x74>
         break;
      if (next == head)
 8233d84:	e0fffd17 	ldw	r3,-12(fp)
 8233d88:	e0bffc17 	ldw	r2,-16(fp)
 8233d8c:	1880021e 	bne	r3,r2,8233d98 <soqremque+0x68>
         return (0);
 8233d90:	0005883a 	mov	r2,zero
 8233d94:	00002406 	br	8233e28 <soqremque+0xf8>
      prev = next;
 8233d98:	e0bffd17 	ldw	r2,-12(fp)
 8233d9c:	e0bffb15 	stw	r2,-20(fp)
   }
 8233da0:	003fed06 	br	8233d58 <soqremque+0x28>
   prev = head;
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
      if (next == so)
         break;
 8233da4:	0001883a 	nop
      if (next == head)
         return (0);
      prev = next;
   }
   if (q == 0) 
 8233da8:	e0bfff17 	ldw	r2,-4(fp)
 8233dac:	10000b1e 	bne	r2,zero,8233ddc <soqremque+0xac>
   {
      prev->so_q0 = next->so_q0;
 8233db0:	e0bffd17 	ldw	r2,-12(fp)
 8233db4:	10c01c17 	ldw	r3,112(r2)
 8233db8:	e0bffb17 	ldw	r2,-20(fp)
 8233dbc:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 8233dc0:	e0bffc17 	ldw	r2,-16(fp)
 8233dc4:	10801e03 	ldbu	r2,120(r2)
 8233dc8:	10bfffc4 	addi	r2,r2,-1
 8233dcc:	1007883a 	mov	r3,r2
 8233dd0:	e0bffc17 	ldw	r2,-16(fp)
 8233dd4:	10c01e05 	stb	r3,120(r2)
 8233dd8:	00000a06 	br	8233e04 <soqremque+0xd4>
   } else 
   {
      prev->so_q = next->so_q;
 8233ddc:	e0bffd17 	ldw	r2,-12(fp)
 8233de0:	10c01d17 	ldw	r3,116(r2)
 8233de4:	e0bffb17 	ldw	r2,-20(fp)
 8233de8:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 8233dec:	e0bffc17 	ldw	r2,-16(fp)
 8233df0:	10801e43 	ldbu	r2,121(r2)
 8233df4:	10bfffc4 	addi	r2,r2,-1
 8233df8:	1007883a 	mov	r3,r2
 8233dfc:	e0bffc17 	ldw	r2,-16(fp)
 8233e00:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 8233e04:	e0bffd17 	ldw	r2,-12(fp)
 8233e08:	10001d15 	stw	zero,116(r2)
 8233e0c:	e0bffd17 	ldw	r2,-12(fp)
 8233e10:	10c01d17 	ldw	r3,116(r2)
 8233e14:	e0bffd17 	ldw	r2,-12(fp)
 8233e18:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 8233e1c:	e0bffd17 	ldw	r2,-12(fp)
 8233e20:	10001b15 	stw	zero,108(r2)
   return 1;
 8233e24:	00800044 	movi	r2,1
}
 8233e28:	e037883a 	mov	sp,fp
 8233e2c:	df000017 	ldw	fp,0(sp)
 8233e30:	dec00104 	addi	sp,sp,4
 8233e34:	f800283a 	ret

08233e38 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 8233e38:	defffd04 	addi	sp,sp,-12
 8233e3c:	dfc00215 	stw	ra,8(sp)
 8233e40:	df000115 	stw	fp,4(sp)
 8233e44:	df000104 	addi	fp,sp,4
 8233e48:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 8233e4c:	e0bfff17 	ldw	r2,-4(fp)
 8233e50:	1080088b 	ldhu	r2,34(r2)
 8233e54:	10800414 	ori	r2,r2,16
 8233e58:	1007883a 	mov	r3,r2
 8233e5c:	e0bfff17 	ldw	r2,-4(fp)
 8233e60:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 8233e64:	e0bfff17 	ldw	r2,-4(fp)
 8233e68:	10801204 	addi	r2,r2,72
 8233e6c:	100b883a 	mov	r5,r2
 8233e70:	e13fff17 	ldw	r4,-4(fp)
 8233e74:	8233f900 	call	8233f90 <sbwakeup>
}
 8233e78:	0001883a 	nop
 8233e7c:	e037883a 	mov	sp,fp
 8233e80:	dfc00117 	ldw	ra,4(sp)
 8233e84:	df000017 	ldw	fp,0(sp)
 8233e88:	dec00204 	addi	sp,sp,8
 8233e8c:	f800283a 	ret

08233e90 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 8233e90:	defffd04 	addi	sp,sp,-12
 8233e94:	dfc00215 	stw	ra,8(sp)
 8233e98:	df000115 	stw	fp,4(sp)
 8233e9c:	df000104 	addi	fp,sp,4
 8233ea0:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 8233ea4:	e0bfff17 	ldw	r2,-4(fp)
 8233ea8:	1080088b 	ldhu	r2,34(r2)
 8233eac:	10800814 	ori	r2,r2,32
 8233eb0:	1007883a 	mov	r3,r2
 8233eb4:	e0bfff17 	ldw	r2,-4(fp)
 8233eb8:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 8233ebc:	e0bfff17 	ldw	r2,-4(fp)
 8233ec0:	10800a04 	addi	r2,r2,40
 8233ec4:	100b883a 	mov	r5,r2
 8233ec8:	e13fff17 	ldw	r4,-4(fp)
 8233ecc:	8233f900 	call	8233f90 <sbwakeup>
}
 8233ed0:	0001883a 	nop
 8233ed4:	e037883a 	mov	sp,fp
 8233ed8:	dfc00117 	ldw	ra,4(sp)
 8233edc:	df000017 	ldw	fp,0(sp)
 8233ee0:	dec00204 	addi	sp,sp,8
 8233ee4:	f800283a 	ret

08233ee8 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 8233ee8:	defffe04 	addi	sp,sp,-8
 8233eec:	df000115 	stw	fp,4(sp)
 8233ef0:	df000104 	addi	fp,sp,4
 8233ef4:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 8233ef8:	e0bfff17 	ldw	r2,-4(fp)
 8233efc:	1080070b 	ldhu	r2,28(r2)
 8233f00:	10800214 	ori	r2,r2,8
 8233f04:	1007883a 	mov	r3,r2
 8233f08:	e0bfff17 	ldw	r2,-4(fp)
 8233f0c:	10c0070d 	sth	r3,28(r2)
}
 8233f10:	0001883a 	nop
 8233f14:	e037883a 	mov	sp,fp
 8233f18:	df000017 	ldw	fp,0(sp)
 8233f1c:	dec00104 	addi	sp,sp,4
 8233f20:	f800283a 	ret

08233f24 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 8233f24:	defffd04 	addi	sp,sp,-12
 8233f28:	dfc00215 	stw	ra,8(sp)
 8233f2c:	df000115 	stw	fp,4(sp)
 8233f30:	df000104 	addi	fp,sp,4
 8233f34:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 8233f38:	e0bfff17 	ldw	r2,-4(fp)
 8233f3c:	1080070b 	ldhu	r2,28(r2)
 8233f40:	10800114 	ori	r2,r2,4
 8233f44:	1007883a 	mov	r3,r2
 8233f48:	e0bfff17 	ldw	r2,-4(fp)
 8233f4c:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 8233f50:	e0bfff17 	ldw	r2,-4(fp)
 8233f54:	1009883a 	mov	r4,r2
 8233f58:	82292800 	call	8229280 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 8233f5c:	e0bfff17 	ldw	r2,-4(fp)
 8233f60:	10c0070b 	ldhu	r3,28(r2)
 8233f64:	00bffec4 	movi	r2,-5
 8233f68:	1884703a 	and	r2,r3,r2
 8233f6c:	1007883a 	mov	r3,r2
 8233f70:	e0bfff17 	ldw	r2,-4(fp)
 8233f74:	10c0070d 	sth	r3,28(r2)
}
 8233f78:	0001883a 	nop
 8233f7c:	e037883a 	mov	sp,fp
 8233f80:	dfc00117 	ldw	ra,4(sp)
 8233f84:	df000017 	ldw	fp,0(sp)
 8233f88:	dec00204 	addi	sp,sp,8
 8233f8c:	f800283a 	ret

08233f90 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 8233f90:	defffc04 	addi	sp,sp,-16
 8233f94:	dfc00315 	stw	ra,12(sp)
 8233f98:	df000215 	stw	fp,8(sp)
 8233f9c:	df000204 	addi	fp,sp,8
 8233fa0:	e13ffe15 	stw	r4,-8(fp)
 8233fa4:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 8233fa8:	e0bfff17 	ldw	r2,-4(fp)
 8233fac:	1080070b 	ldhu	r2,28(r2)
 8233fb0:	10bfffcc 	andi	r2,r2,65535
 8233fb4:	1080020c 	andi	r2,r2,8
 8233fb8:	10000a26 	beq	r2,zero,8233fe4 <sbwakeup+0x54>
   {
      select_wait = 0;
 8233fbc:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 8233fc0:	d120b004 	addi	r4,gp,-32064
 8233fc4:	82293f40 	call	82293f4 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 8233fc8:	e0bfff17 	ldw	r2,-4(fp)
 8233fcc:	10c0070b 	ldhu	r3,28(r2)
 8233fd0:	00bffdc4 	movi	r2,-9
 8233fd4:	1884703a 	and	r2,r3,r2
 8233fd8:	1007883a 	mov	r3,r2
 8233fdc:	e0bfff17 	ldw	r2,-4(fp)
 8233fe0:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 8233fe4:	e0bfff17 	ldw	r2,-4(fp)
 8233fe8:	1080070b 	ldhu	r2,28(r2)
 8233fec:	10bfffcc 	andi	r2,r2,65535
 8233ff0:	1080010c 	andi	r2,r2,4
 8233ff4:	10000326 	beq	r2,zero,8234004 <sbwakeup+0x74>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 8233ff8:	e0bfff17 	ldw	r2,-4(fp)
 8233ffc:	1009883a 	mov	r4,r2
 8234000:	82293f40 	call	82293f4 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 8234004:	0001883a 	nop
 8234008:	e037883a 	mov	sp,fp
 823400c:	dfc00117 	ldw	ra,4(sp)
 8234010:	df000017 	ldw	fp,0(sp)
 8234014:	dec00204 	addi	sp,sp,8
 8234018:	f800283a 	ret

0823401c <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 823401c:	defffb04 	addi	sp,sp,-20
 8234020:	dfc00415 	stw	ra,16(sp)
 8234024:	df000315 	stw	fp,12(sp)
 8234028:	df000304 	addi	fp,sp,12
 823402c:	e13ffd15 	stw	r4,-12(fp)
 8234030:	e17ffe15 	stw	r5,-8(fp)
 8234034:	e1bfff15 	stw	r6,-4(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 8234038:	e0bffd17 	ldw	r2,-12(fp)
 823403c:	10801204 	addi	r2,r2,72
 8234040:	e17ffe17 	ldw	r5,-8(fp)
 8234044:	1009883a 	mov	r4,r2
 8234048:	82340a40 	call	82340a4 <sbreserve>
 823404c:	10000e26 	beq	r2,zero,8234088 <soreserve+0x6c>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 8234050:	e0bffd17 	ldw	r2,-12(fp)
 8234054:	10800a04 	addi	r2,r2,40
 8234058:	e17fff17 	ldw	r5,-4(fp)
 823405c:	1009883a 	mov	r4,r2
 8234060:	82340a40 	call	82340a4 <sbreserve>
 8234064:	10000226 	beq	r2,zero,8234070 <soreserve+0x54>
      goto bad2;
   return (0);
 8234068:	0005883a 	mov	r2,zero
 823406c:	00000806 	br	8234090 <soreserve+0x74>
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
      goto bad2;
 8234070:	0001883a 	nop
   return (0);
bad2:
   sbrelease(&so->so_snd);
 8234074:	e0bffd17 	ldw	r2,-12(fp)
 8234078:	10801204 	addi	r2,r2,72
 823407c:	1009883a 	mov	r4,r2
 8234080:	82340f40 	call	82340f4 <sbrelease>
 8234084:	00000106 	br	823408c <soreserve+0x70>
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
 8234088:	0001883a 	nop
      goto bad2;
   return (0);
bad2:
   sbrelease(&so->so_snd);
bad:
   return (ENOBUFS);
 823408c:	00801a44 	movi	r2,105
}
 8234090:	e037883a 	mov	sp,fp
 8234094:	dfc00117 	ldw	ra,4(sp)
 8234098:	df000017 	ldw	fp,0(sp)
 823409c:	dec00204 	addi	sp,sp,8
 82340a0:	f800283a 	ret

082340a4 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 82340a4:	defffd04 	addi	sp,sp,-12
 82340a8:	df000215 	stw	fp,8(sp)
 82340ac:	df000204 	addi	fp,sp,8
 82340b0:	e13ffe15 	stw	r4,-8(fp)
 82340b4:	e17fff15 	stw	r5,-4(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 82340b8:	e0bffe17 	ldw	r2,-8(fp)
 82340bc:	e0ffff17 	ldw	r3,-4(fp)
 82340c0:	10c00115 	stw	r3,4(r2)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 82340c4:	e0bfff17 	ldw	r2,-4(fp)
 82340c8:	1085883a 	add	r2,r2,r2
 82340cc:	10d00070 	cmpltui	r3,r2,16385
 82340d0:	1800011e 	bne	r3,zero,82340d8 <sbreserve+0x34>
 82340d4:	00900004 	movi	r2,16384
 82340d8:	e0fffe17 	ldw	r3,-8(fp)
 82340dc:	18800315 	stw	r2,12(r3)
   return (1);
 82340e0:	00800044 	movi	r2,1
}
 82340e4:	e037883a 	mov	sp,fp
 82340e8:	df000017 	ldw	fp,0(sp)
 82340ec:	dec00104 	addi	sp,sp,4
 82340f0:	f800283a 	ret

082340f4 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 82340f4:	defffd04 	addi	sp,sp,-12
 82340f8:	dfc00215 	stw	ra,8(sp)
 82340fc:	df000115 	stw	fp,4(sp)
 8234100:	df000104 	addi	fp,sp,4
 8234104:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 8234108:	e13fff17 	ldw	r4,-4(fp)
 823410c:	82346740 	call	8234674 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 8234110:	e0bfff17 	ldw	r2,-4(fp)
 8234114:	10000315 	stw	zero,12(r2)
 8234118:	e0bfff17 	ldw	r2,-4(fp)
 823411c:	10c00317 	ldw	r3,12(r2)
 8234120:	e0bfff17 	ldw	r2,-4(fp)
 8234124:	10c00115 	stw	r3,4(r2)
}
 8234128:	0001883a 	nop
 823412c:	e037883a 	mov	sp,fp
 8234130:	dfc00117 	ldw	ra,4(sp)
 8234134:	df000017 	ldw	fp,0(sp)
 8234138:	dec00204 	addi	sp,sp,8
 823413c:	f800283a 	ret

08234140 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 8234140:	defffb04 	addi	sp,sp,-20
 8234144:	dfc00415 	stw	ra,16(sp)
 8234148:	df000315 	stw	fp,12(sp)
 823414c:	df000304 	addi	fp,sp,12
 8234150:	e13ffe15 	stw	r4,-8(fp)
 8234154:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 8234158:	e0bfff17 	ldw	r2,-4(fp)
 823415c:	10001a26 	beq	r2,zero,82341c8 <sbappend+0x88>
      return;
   ENTER_CRIT_SECTION(sb);
 8234160:	822d4b80 	call	822d4b8 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 8234164:	e0bffe17 	ldw	r2,-8(fp)
 8234168:	10800617 	ldw	r2,24(r2)
 823416c:	e0bffd15 	stw	r2,-12(fp)
 8234170:	e0bffd17 	ldw	r2,-12(fp)
 8234174:	10000e26 	beq	r2,zero,82341b0 <sbappend+0x70>
   {
      while (n->m_act)
 8234178:	00000306 	br	8234188 <sbappend+0x48>
         n = n->m_act;
 823417c:	e0bffd17 	ldw	r2,-12(fp)
 8234180:	10800717 	ldw	r2,28(r2)
 8234184:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234188:	e0bffd17 	ldw	r2,-12(fp)
 823418c:	10800717 	ldw	r2,28(r2)
 8234190:	103ffa1e 	bne	r2,zero,823417c <sbappend+0x3c>
         n = n->m_act;
      while (n->m_next)
 8234194:	00000306 	br	82341a4 <sbappend+0x64>
         n = n->m_next;
 8234198:	e0bffd17 	ldw	r2,-12(fp)
 823419c:	10800617 	ldw	r2,24(r2)
 82341a0:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 82341a4:	e0bffd17 	ldw	r2,-12(fp)
 82341a8:	10800617 	ldw	r2,24(r2)
 82341ac:	103ffa1e 	bne	r2,zero,8234198 <sbappend+0x58>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 82341b0:	e1bffd17 	ldw	r6,-12(fp)
 82341b4:	e17fff17 	ldw	r5,-4(fp)
 82341b8:	e13ffe17 	ldw	r4,-8(fp)
 82341bc:	82344940 	call	8234494 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 82341c0:	822d5180 	call	822d518 <irq_Unmask>
 82341c4:	00000106 	br	82341cc <sbappend+0x8c>
sbappend(struct sockbuf * sb, struct mbuf * m)
{
   struct mbuf *  n;

   if (m == 0)
      return;
 82341c8:	0001883a 	nop
      while (n->m_next)
         n = n->m_next;
   }
   sbcompress(sb, m, n);
   EXIT_CRIT_SECTION(sb);
}
 82341cc:	e037883a 	mov	sp,fp
 82341d0:	dfc00117 	ldw	ra,4(sp)
 82341d4:	df000017 	ldw	fp,0(sp)
 82341d8:	dec00204 	addi	sp,sp,8
 82341dc:	f800283a 	ret

082341e0 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 82341e0:	defffb04 	addi	sp,sp,-20
 82341e4:	dfc00415 	stw	ra,16(sp)
 82341e8:	df000315 	stw	fp,12(sp)
 82341ec:	df000304 	addi	fp,sp,12
 82341f0:	e13ffe15 	stw	r4,-8(fp)
 82341f4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 82341f8:	e0bfff17 	ldw	r2,-4(fp)
 82341fc:	10002826 	beq	r2,zero,82342a0 <sbappendrecord+0xc0>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 8234200:	822d4b80 	call	822d4b8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 8234204:	e0bffe17 	ldw	r2,-8(fp)
 8234208:	10800617 	ldw	r2,24(r2)
 823420c:	e0bffd15 	stw	r2,-12(fp)
 8234210:	e0bffd17 	ldw	r2,-12(fp)
 8234214:	10000726 	beq	r2,zero,8234234 <sbappendrecord+0x54>
      while (m->m_act)
 8234218:	00000306 	br	8234228 <sbappendrecord+0x48>
      m = m->m_act;
 823421c:	e0bffd17 	ldw	r2,-12(fp)
 8234220:	10800717 	ldw	r2,28(r2)
 8234224:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 8234228:	e0bffd17 	ldw	r2,-12(fp)
 823422c:	10800717 	ldw	r2,28(r2)
 8234230:	103ffa1e 	bne	r2,zero,823421c <sbappendrecord+0x3c>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 8234234:	e0bffe17 	ldw	r2,-8(fp)
 8234238:	10c00017 	ldw	r3,0(r2)
 823423c:	e0bfff17 	ldw	r2,-4(fp)
 8234240:	10800217 	ldw	r2,8(r2)
 8234244:	1887883a 	add	r3,r3,r2
 8234248:	e0bffe17 	ldw	r2,-8(fp)
 823424c:	10c00015 	stw	r3,0(r2)
   if (m)
 8234250:	e0bffd17 	ldw	r2,-12(fp)
 8234254:	10000426 	beq	r2,zero,8234268 <sbappendrecord+0x88>
      m->m_act = m0;
 8234258:	e0bffd17 	ldw	r2,-12(fp)
 823425c:	e0ffff17 	ldw	r3,-4(fp)
 8234260:	10c00715 	stw	r3,28(r2)
 8234264:	00000306 	br	8234274 <sbappendrecord+0x94>
   else
      sb->sb_mb = m0;
 8234268:	e0bffe17 	ldw	r2,-8(fp)
 823426c:	e0ffff17 	ldw	r3,-4(fp)
 8234270:	10c00615 	stw	r3,24(r2)
   m = m0->m_next;
 8234274:	e0bfff17 	ldw	r2,-4(fp)
 8234278:	10800617 	ldw	r2,24(r2)
 823427c:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 8234280:	e0bfff17 	ldw	r2,-4(fp)
 8234284:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 8234288:	e1bfff17 	ldw	r6,-4(fp)
 823428c:	e17ffd17 	ldw	r5,-12(fp)
 8234290:	e13ffe17 	ldw	r4,-8(fp)
 8234294:	82344940 	call	8234494 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 8234298:	822d5180 	call	822d518 <irq_Unmask>
 823429c:	00000106 	br	82342a4 <sbappendrecord+0xc4>
   struct mbuf *  m0)
{
   struct mbuf *  m;

   if (m0 == 0)
      return;
 82342a0:	0001883a 	nop
      sb->sb_mb = m0;
   m = m0->m_next;
   m0->m_next = 0;
   sbcompress(sb, m, m0);
   EXIT_CRIT_SECTION(sb);
}
 82342a4:	e037883a 	mov	sp,fp
 82342a8:	dfc00117 	ldw	ra,4(sp)
 82342ac:	df000017 	ldw	fp,0(sp)
 82342b0:	dec00204 	addi	sp,sp,8
 82342b4:	f800283a 	ret

082342b8 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 82342b8:	defff804 	addi	sp,sp,-32
 82342bc:	dfc00715 	stw	ra,28(sp)
 82342c0:	df000615 	stw	fp,24(sp)
 82342c4:	df000604 	addi	fp,sp,24
 82342c8:	e13ffd15 	stw	r4,-12(fp)
 82342cc:	e17ffe15 	stw	r5,-8(fp)
 82342d0:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 82342d4:	00800404 	movi	r2,16
 82342d8:	e0bffc15 	stw	r2,-16(fp)

   ENTER_CRIT_SECTION(sb);
 82342dc:	822d4b80 	call	822d4b8 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 82342e0:	e0bfff17 	ldw	r2,-4(fp)
 82342e4:	e0bffa15 	stw	r2,-24(fp)
 82342e8:	00000806 	br	823430c <sbappendaddr+0x54>
      space += m->m_len;
 82342ec:	e0bffa17 	ldw	r2,-24(fp)
 82342f0:	10c00217 	ldw	r3,8(r2)
 82342f4:	e0bffc17 	ldw	r2,-16(fp)
 82342f8:	1885883a 	add	r2,r3,r2
 82342fc:	e0bffc15 	stw	r2,-16(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 8234300:	e0bffa17 	ldw	r2,-24(fp)
 8234304:	10800617 	ldw	r2,24(r2)
 8234308:	e0bffa15 	stw	r2,-24(fp)
 823430c:	e0bffa17 	ldw	r2,-24(fp)
 8234310:	103ff61e 	bne	r2,zero,82342ec <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 8234314:	e0bffd17 	ldw	r2,-12(fp)
 8234318:	10800117 	ldw	r2,4(r2)
 823431c:	1007883a 	mov	r3,r2
 8234320:	e0bffd17 	ldw	r2,-12(fp)
 8234324:	10800017 	ldw	r2,0(r2)
 8234328:	1885c83a 	sub	r2,r3,r2
 823432c:	10000716 	blt	r2,zero,823434c <sbappendaddr+0x94>
 8234330:	e0bffd17 	ldw	r2,-12(fp)
 8234334:	10c00117 	ldw	r3,4(r2)
 8234338:	e0bffd17 	ldw	r2,-12(fp)
 823433c:	10800017 	ldw	r2,0(r2)
 8234340:	1885c83a 	sub	r2,r3,r2
 8234344:	1007883a 	mov	r3,r2
 8234348:	00000106 	br	8234350 <sbappendaddr+0x98>
 823434c:	0007883a 	mov	r3,zero
 8234350:	e0bffc17 	ldw	r2,-16(fp)
 8234354:	1880030e 	bge	r3,r2,8234364 <sbappendaddr+0xac>
   {
      EXIT_CRIT_SECTION(sb);
 8234358:	822d5180 	call	822d518 <irq_Unmask>
      return (0);
 823435c:	0005883a 	mov	r2,zero
 8234360:	00004706 	br	8234480 <sbappendaddr+0x1c8>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 8234364:	01400404 	movi	r5,16
 8234368:	01000244 	movi	r4,9
 823436c:	822e0f40 	call	822e0f4 <m_getnbuf>
 8234370:	e0bffa15 	stw	r2,-24(fp)
 8234374:	e0bffa17 	ldw	r2,-24(fp)
 8234378:	1000031e 	bne	r2,zero,8234388 <sbappendaddr+0xd0>
   {
      EXIT_CRIT_SECTION(sb);
 823437c:	822d5180 	call	822d518 <irq_Unmask>
      return 0;
 8234380:	0005883a 	mov	r2,zero
 8234384:	00003e06 	br	8234480 <sbappendaddr+0x1c8>
   }
   *mtod(m, struct sockaddr *) = *asa;
 8234388:	e0bffa17 	ldw	r2,-24(fp)
 823438c:	10800317 	ldw	r2,12(r2)
 8234390:	e0fffe17 	ldw	r3,-8(fp)
 8234394:	1900000b 	ldhu	r4,0(r3)
 8234398:	1100000d 	sth	r4,0(r2)
 823439c:	1900008b 	ldhu	r4,2(r3)
 82343a0:	1100008d 	sth	r4,2(r2)
 82343a4:	1900010b 	ldhu	r4,4(r3)
 82343a8:	1100010d 	sth	r4,4(r2)
 82343ac:	1900018b 	ldhu	r4,6(r3)
 82343b0:	1100018d 	sth	r4,6(r2)
 82343b4:	1900020b 	ldhu	r4,8(r3)
 82343b8:	1100020d 	sth	r4,8(r2)
 82343bc:	1900028b 	ldhu	r4,10(r3)
 82343c0:	1100028d 	sth	r4,10(r2)
 82343c4:	1900030b 	ldhu	r4,12(r3)
 82343c8:	1100030d 	sth	r4,12(r2)
 82343cc:	18c0038b 	ldhu	r3,14(r3)
 82343d0:	10c0038d 	sth	r3,14(r2)
   m->m_len = sizeof (*asa);
 82343d4:	e0bffa17 	ldw	r2,-24(fp)
 82343d8:	00c00404 	movi	r3,16
 82343dc:	10c00215 	stw	r3,8(r2)
   sballoc (sb, m);
 82343e0:	e0bffd17 	ldw	r2,-12(fp)
 82343e4:	10c00017 	ldw	r3,0(r2)
 82343e8:	e0bffa17 	ldw	r2,-24(fp)
 82343ec:	10800217 	ldw	r2,8(r2)
 82343f0:	1887883a 	add	r3,r3,r2
 82343f4:	e0bffd17 	ldw	r2,-12(fp)
 82343f8:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 82343fc:	e0bffd17 	ldw	r2,-12(fp)
 8234400:	10800617 	ldw	r2,24(r2)
 8234404:	e0bffb15 	stw	r2,-20(fp)
 8234408:	e0bffb17 	ldw	r2,-20(fp)
 823440c:	10000b26 	beq	r2,zero,823443c <sbappendaddr+0x184>
   {
      while (n->m_act)
 8234410:	00000306 	br	8234420 <sbappendaddr+0x168>
         n = n->m_act;
 8234414:	e0bffb17 	ldw	r2,-20(fp)
 8234418:	10800717 	ldw	r2,28(r2)
 823441c:	e0bffb15 	stw	r2,-20(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234420:	e0bffb17 	ldw	r2,-20(fp)
 8234424:	10800717 	ldw	r2,28(r2)
 8234428:	103ffa1e 	bne	r2,zero,8234414 <sbappendaddr+0x15c>
         n = n->m_act;
      n->m_act = m;
 823442c:	e0bffb17 	ldw	r2,-20(fp)
 8234430:	e0fffa17 	ldw	r3,-24(fp)
 8234434:	10c00715 	stw	r3,28(r2)
 8234438:	00000306 	br	8234448 <sbappendaddr+0x190>
   } else
      sb->sb_mb = m;
 823443c:	e0bffd17 	ldw	r2,-12(fp)
 8234440:	e0fffa17 	ldw	r3,-24(fp)
 8234444:	10c00615 	stw	r3,24(r2)
   if (m->m_next)
 8234448:	e0bffa17 	ldw	r2,-24(fp)
 823444c:	10800617 	ldw	r2,24(r2)
 8234450:	10000326 	beq	r2,zero,8234460 <sbappendaddr+0x1a8>
      m = m->m_next;
 8234454:	e0bffa17 	ldw	r2,-24(fp)
 8234458:	10800617 	ldw	r2,24(r2)
 823445c:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 8234460:	e0bfff17 	ldw	r2,-4(fp)
 8234464:	10000426 	beq	r2,zero,8234478 <sbappendaddr+0x1c0>
      sbcompress(sb, m0, m);
 8234468:	e1bffa17 	ldw	r6,-24(fp)
 823446c:	e17fff17 	ldw	r5,-4(fp)
 8234470:	e13ffd17 	ldw	r4,-12(fp)
 8234474:	82344940 	call	8234494 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 8234478:	822d5180 	call	822d518 <irq_Unmask>
   return (1);
 823447c:	00800044 	movi	r2,1
}
 8234480:	e037883a 	mov	sp,fp
 8234484:	dfc00117 	ldw	ra,4(sp)
 8234488:	df000017 	ldw	fp,0(sp)
 823448c:	dec00204 	addi	sp,sp,8
 8234490:	f800283a 	ret

08234494 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 8234494:	defffb04 	addi	sp,sp,-20
 8234498:	dfc00415 	stw	ra,16(sp)
 823449c:	df000315 	stw	fp,12(sp)
 82344a0:	df000304 	addi	fp,sp,12
 82344a4:	e13ffd15 	stw	r4,-12(fp)
 82344a8:	e17ffe15 	stw	r5,-8(fp)
 82344ac:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 82344b0:	00006806 	br	8234654 <sbcompress+0x1c0>
   {
      if (m->m_len == 0) 
 82344b4:	e0bffe17 	ldw	r2,-8(fp)
 82344b8:	10800217 	ldw	r2,8(r2)
 82344bc:	1000041e 	bne	r2,zero,82344d0 <sbcompress+0x3c>
      {
         m = m_free(m);
 82344c0:	e13ffe17 	ldw	r4,-8(fp)
 82344c4:	822e27c0 	call	822e27c <m_free>
 82344c8:	e0bffe15 	stw	r2,-8(fp)
         continue;
 82344cc:	00006106 	br	8234654 <sbcompress+0x1c0>
      }
      if (m->m_type != MT_RXDATA && 
 82344d0:	e0bffe17 	ldw	r2,-8(fp)
 82344d4:	10800817 	ldw	r2,32(r2)
 82344d8:	10800060 	cmpeqi	r2,r2,1
 82344dc:	1000111e 	bne	r2,zero,8234524 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
 82344e0:	e0bffe17 	ldw	r2,-8(fp)
 82344e4:	10800817 	ldw	r2,32(r2)
      if (m->m_len == 0) 
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
 82344e8:	108000a0 	cmpeqi	r2,r2,2
 82344ec:	10000d1e 	bne	r2,zero,8234524 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
 82344f0:	e0bffe17 	ldw	r2,-8(fp)
 82344f4:	10800817 	ldw	r2,32(r2)
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
          m->m_type != MT_TXDATA && 
 82344f8:	10800260 	cmpeqi	r2,r2,9
 82344fc:	1000091e 	bne	r2,zero,8234524 <sbcompress+0x90>
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 8234500:	e0bffe17 	ldw	r2,-8(fp)
 8234504:	10800817 	ldw	r2,32(r2)
 8234508:	100b883a 	mov	r5,r2
 823450c:	01020974 	movhi	r4,2085
 8234510:	2102ad04 	addi	r4,r4,2740
 8234514:	82030ec0 	call	82030ec <printf>
         panic ("sbcomp:bad");
 8234518:	01020974 	movhi	r4,2085
 823451c:	2102b204 	addi	r4,r4,2760
 8234520:	82289940 	call	8228994 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 8234524:	e0bfff17 	ldw	r2,-4(fp)
 8234528:	10003326 	beq	r2,zero,82345f8 <sbcompress+0x164>
 823452c:	e0bffd17 	ldw	r2,-12(fp)
 8234530:	1080070b 	ldhu	r2,28(r2)
 8234534:	10bfffcc 	andi	r2,r2,65535
 8234538:	1080200c 	andi	r2,r2,128
 823453c:	10002e26 	beq	r2,zero,82345f8 <sbcompress+0x164>
          ((n->m_len + m->m_len) <
 8234540:	e0bfff17 	ldw	r2,-4(fp)
 8234544:	10c00217 	ldw	r3,8(r2)
 8234548:	e0bffe17 	ldw	r2,-8(fp)
 823454c:	10800217 	ldw	r2,8(r2)
 8234550:	1887883a 	add	r3,r3,r2
          n->m_memsz - (n->m_data - n->m_base) ) ) 
 8234554:	e0bfff17 	ldw	r2,-4(fp)
 8234558:	10800517 	ldw	r2,20(r2)
 823455c:	e13fff17 	ldw	r4,-4(fp)
 8234560:	21000317 	ldw	r4,12(r4)
 8234564:	200b883a 	mov	r5,r4
 8234568:	e13fff17 	ldw	r4,-4(fp)
 823456c:	21000417 	ldw	r4,16(r4)
 8234570:	2909c83a 	sub	r4,r5,r4
 8234574:	1105c83a 	sub	r2,r2,r4
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 8234578:	18801f2e 	bgeu	r3,r2,82345f8 <sbcompress+0x164>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 823457c:	e0bfff17 	ldw	r2,-4(fp)
 8234580:	10c00317 	ldw	r3,12(r2)
 8234584:	e0bfff17 	ldw	r2,-4(fp)
 8234588:	10800217 	ldw	r2,8(r2)
 823458c:	1887883a 	add	r3,r3,r2
 8234590:	e0bffe17 	ldw	r2,-8(fp)
 8234594:	11000317 	ldw	r4,12(r2)
 8234598:	e0bffe17 	ldw	r2,-8(fp)
 823459c:	10800217 	ldw	r2,8(r2)
 82345a0:	100d883a 	mov	r6,r2
 82345a4:	200b883a 	mov	r5,r4
 82345a8:	1809883a 	mov	r4,r3
 82345ac:	8202c5c0 	call	8202c5c <memcpy>
         sballoc(sb, m);
 82345b0:	e0bffd17 	ldw	r2,-12(fp)
 82345b4:	10c00017 	ldw	r3,0(r2)
 82345b8:	e0bffe17 	ldw	r2,-8(fp)
 82345bc:	10800217 	ldw	r2,8(r2)
 82345c0:	1887883a 	add	r3,r3,r2
 82345c4:	e0bffd17 	ldw	r2,-12(fp)
 82345c8:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 82345cc:	e0bfff17 	ldw	r2,-4(fp)
 82345d0:	10c00217 	ldw	r3,8(r2)
 82345d4:	e0bffe17 	ldw	r2,-8(fp)
 82345d8:	10800217 	ldw	r2,8(r2)
 82345dc:	1887883a 	add	r3,r3,r2
 82345e0:	e0bfff17 	ldw	r2,-4(fp)
 82345e4:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 82345e8:	e13ffe17 	ldw	r4,-8(fp)
 82345ec:	822e27c0 	call	822e27c <m_free>
 82345f0:	e0bffe15 	stw	r2,-8(fp)
         continue;
 82345f4:	00001706 	br	8234654 <sbcompress+0x1c0>
      }
      sballoc(sb, m);
 82345f8:	e0bffd17 	ldw	r2,-12(fp)
 82345fc:	10c00017 	ldw	r3,0(r2)
 8234600:	e0bffe17 	ldw	r2,-8(fp)
 8234604:	10800217 	ldw	r2,8(r2)
 8234608:	1887883a 	add	r3,r3,r2
 823460c:	e0bffd17 	ldw	r2,-12(fp)
 8234610:	10c00015 	stw	r3,0(r2)
      if (n)
 8234614:	e0bfff17 	ldw	r2,-4(fp)
 8234618:	10000426 	beq	r2,zero,823462c <sbcompress+0x198>
         n->m_next = m;
 823461c:	e0bfff17 	ldw	r2,-4(fp)
 8234620:	e0fffe17 	ldw	r3,-8(fp)
 8234624:	10c00615 	stw	r3,24(r2)
 8234628:	00000306 	br	8234638 <sbcompress+0x1a4>
      else
         sb->sb_mb = m;
 823462c:	e0bffd17 	ldw	r2,-12(fp)
 8234630:	e0fffe17 	ldw	r3,-8(fp)
 8234634:	10c00615 	stw	r3,24(r2)
      n = m;
 8234638:	e0bffe17 	ldw	r2,-8(fp)
 823463c:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 8234640:	e0bffe17 	ldw	r2,-8(fp)
 8234644:	10800617 	ldw	r2,24(r2)
 8234648:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 823464c:	e0bfff17 	ldw	r2,-4(fp)
 8234650:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 8234654:	e0bffe17 	ldw	r2,-8(fp)
 8234658:	103f961e 	bne	r2,zero,82344b4 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 823465c:	0001883a 	nop
 8234660:	e037883a 	mov	sp,fp
 8234664:	dfc00117 	ldw	ra,4(sp)
 8234668:	df000017 	ldw	fp,0(sp)
 823466c:	dec00204 	addi	sp,sp,8
 8234670:	f800283a 	ret

08234674 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 8234674:	defffd04 	addi	sp,sp,-12
 8234678:	dfc00215 	stw	ra,8(sp)
 823467c:	df000115 	stw	fp,4(sp)
 8234680:	df000104 	addi	fp,sp,4
 8234684:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 8234688:	822d4b80 	call	822d4b8 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 823468c:	e0bfff17 	ldw	r2,-4(fp)
 8234690:	1080070b 	ldhu	r2,28(r2)
 8234694:	10bfffcc 	andi	r2,r2,65535
 8234698:	1080004c 	andi	r2,r2,1
 823469c:	10000926 	beq	r2,zero,82346c4 <sbflush+0x50>
      panic("sbflush");
 82346a0:	01020974 	movhi	r4,2085
 82346a4:	2102b504 	addi	r4,r4,2772
 82346a8:	82289940 	call	8228994 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82346ac:	00000506 	br	82346c4 <sbflush+0x50>
      sbdrop (sb, (int)sb->sb_cc);
 82346b0:	e0bfff17 	ldw	r2,-4(fp)
 82346b4:	10800017 	ldw	r2,0(r2)
 82346b8:	100b883a 	mov	r5,r2
 82346bc:	e13fff17 	ldw	r4,-4(fp)
 82346c0:	82346f80 	call	82346f8 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82346c4:	e0bfff17 	ldw	r2,-4(fp)
 82346c8:	10800217 	ldw	r2,8(r2)
 82346cc:	103ff81e 	bne	r2,zero,82346b0 <sbflush+0x3c>
 82346d0:	e0bfff17 	ldw	r2,-4(fp)
 82346d4:	10800017 	ldw	r2,0(r2)
 82346d8:	103ff51e 	bne	r2,zero,82346b0 <sbflush+0x3c>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 82346dc:	822d5180 	call	822d518 <irq_Unmask>
}
 82346e0:	0001883a 	nop
 82346e4:	e037883a 	mov	sp,fp
 82346e8:	dfc00117 	ldw	ra,4(sp)
 82346ec:	df000017 	ldw	fp,0(sp)
 82346f0:	dec00204 	addi	sp,sp,8
 82346f4:	f800283a 	ret

082346f8 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 82346f8:	defff904 	addi	sp,sp,-28
 82346fc:	dfc00615 	stw	ra,24(sp)
 8234700:	df000515 	stw	fp,20(sp)
 8234704:	df000504 	addi	fp,sp,20
 8234708:	e13ffe15 	stw	r4,-8(fp)
 823470c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 8234710:	822d4b80 	call	822d4b8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 8234714:	e0bffe17 	ldw	r2,-8(fp)
 8234718:	10800617 	ldw	r2,24(r2)
 823471c:	e0bffb15 	stw	r2,-20(fp)
 8234720:	e0bffb17 	ldw	r2,-20(fp)
 8234724:	10000426 	beq	r2,zero,8234738 <sbdrop+0x40>
      next = m->m_act;
 8234728:	e0bffb17 	ldw	r2,-20(fp)
 823472c:	10800717 	ldw	r2,28(r2)
 8234730:	e0bffc15 	stw	r2,-16(fp)
 8234734:	00003706 	br	8234814 <sbdrop+0x11c>
   else
      next = NULL;
 8234738:	e03ffc15 	stw	zero,-16(fp)
   while (len > 0) 
 823473c:	00003506 	br	8234814 <sbdrop+0x11c>
   {
      if (m == 0) 
 8234740:	e0bffb17 	ldw	r2,-20(fp)
 8234744:	10000b1e 	bne	r2,zero,8234774 <sbdrop+0x7c>
      {
         if (next == 0)
 8234748:	e0bffc17 	ldw	r2,-16(fp)
 823474c:	1000031e 	bne	r2,zero,823475c <sbdrop+0x64>
            panic("sbdrop");
 8234750:	01020974 	movhi	r4,2085
 8234754:	2102b704 	addi	r4,r4,2780
 8234758:	82289940 	call	8228994 <panic>
         m = next;
 823475c:	e0bffc17 	ldw	r2,-16(fp)
 8234760:	e0bffb15 	stw	r2,-20(fp)
         next = m->m_act;
 8234764:	e0bffb17 	ldw	r2,-20(fp)
 8234768:	10800717 	ldw	r2,28(r2)
 823476c:	e0bffc15 	stw	r2,-16(fp)
         continue;
 8234770:	00002806 	br	8234814 <sbdrop+0x11c>
      }
      if (m->m_len > (unsigned)len) 
 8234774:	e0bffb17 	ldw	r2,-20(fp)
 8234778:	10800217 	ldw	r2,8(r2)
 823477c:	e0ffff17 	ldw	r3,-4(fp)
 8234780:	1880132e 	bgeu	r3,r2,82347d0 <sbdrop+0xd8>
      {
         m->m_len -= len;
 8234784:	e0bffb17 	ldw	r2,-20(fp)
 8234788:	10c00217 	ldw	r3,8(r2)
 823478c:	e0bfff17 	ldw	r2,-4(fp)
 8234790:	1887c83a 	sub	r3,r3,r2
 8234794:	e0bffb17 	ldw	r2,-20(fp)
 8234798:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 823479c:	e0bffb17 	ldw	r2,-20(fp)
 82347a0:	10c00317 	ldw	r3,12(r2)
 82347a4:	e0bfff17 	ldw	r2,-4(fp)
 82347a8:	1887883a 	add	r3,r3,r2
 82347ac:	e0bffb17 	ldw	r2,-20(fp)
 82347b0:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 82347b4:	e0bffe17 	ldw	r2,-8(fp)
 82347b8:	10c00017 	ldw	r3,0(r2)
 82347bc:	e0bfff17 	ldw	r2,-4(fp)
 82347c0:	1887c83a 	sub	r3,r3,r2
 82347c4:	e0bffe17 	ldw	r2,-8(fp)
 82347c8:	10c00015 	stw	r3,0(r2)
         break;
 82347cc:	00001306 	br	823481c <sbdrop+0x124>
      }
      len -= m->m_len;
 82347d0:	e0ffff17 	ldw	r3,-4(fp)
 82347d4:	e0bffb17 	ldw	r2,-20(fp)
 82347d8:	10800217 	ldw	r2,8(r2)
 82347dc:	1885c83a 	sub	r2,r3,r2
 82347e0:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 82347e4:	e0bffe17 	ldw	r2,-8(fp)
 82347e8:	10c00017 	ldw	r3,0(r2)
 82347ec:	e0bffb17 	ldw	r2,-20(fp)
 82347f0:	10800217 	ldw	r2,8(r2)
 82347f4:	1887c83a 	sub	r3,r3,r2
 82347f8:	e0bffe17 	ldw	r2,-8(fp)
 82347fc:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234800:	e13ffb17 	ldw	r4,-20(fp)
 8234804:	822e27c0 	call	822e27c <m_free>
 8234808:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 823480c:	e0bffd17 	ldw	r2,-12(fp)
 8234810:	e0bffb15 	stw	r2,-20(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 8234814:	e0bfff17 	ldw	r2,-4(fp)
 8234818:	00bfc916 	blt	zero,r2,8234740 <sbdrop+0x48>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 823481c:	00000c06 	br	8234850 <sbdrop+0x158>
   {
      sbfree(sb, m);
 8234820:	e0bffe17 	ldw	r2,-8(fp)
 8234824:	10c00017 	ldw	r3,0(r2)
 8234828:	e0bffb17 	ldw	r2,-20(fp)
 823482c:	10800217 	ldw	r2,8(r2)
 8234830:	1887c83a 	sub	r3,r3,r2
 8234834:	e0bffe17 	ldw	r2,-8(fp)
 8234838:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 823483c:	e13ffb17 	ldw	r4,-20(fp)
 8234840:	822e27c0 	call	822e27c <m_free>
 8234844:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234848:	e0bffd17 	ldw	r2,-12(fp)
 823484c:	e0bffb15 	stw	r2,-20(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234850:	e0bffb17 	ldw	r2,-20(fp)
 8234854:	10000326 	beq	r2,zero,8234864 <sbdrop+0x16c>
 8234858:	e0bffb17 	ldw	r2,-20(fp)
 823485c:	10800217 	ldw	r2,8(r2)
 8234860:	103fef26 	beq	r2,zero,8234820 <sbdrop+0x128>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 8234864:	e0bffb17 	ldw	r2,-20(fp)
 8234868:	10000726 	beq	r2,zero,8234888 <sbdrop+0x190>
   {
      sb->sb_mb = m;
 823486c:	e0bffe17 	ldw	r2,-8(fp)
 8234870:	e0fffb17 	ldw	r3,-20(fp)
 8234874:	10c00615 	stw	r3,24(r2)
      m->m_act = next;
 8234878:	e0bffb17 	ldw	r2,-20(fp)
 823487c:	e0fffc17 	ldw	r3,-16(fp)
 8234880:	10c00715 	stw	r3,28(r2)
 8234884:	00000306 	br	8234894 <sbdrop+0x19c>
   } else
      sb->sb_mb = next;
 8234888:	e0bffe17 	ldw	r2,-8(fp)
 823488c:	e0fffc17 	ldw	r3,-16(fp)
 8234890:	10c00615 	stw	r3,24(r2)
   EXIT_CRIT_SECTION(sb);
 8234894:	822d5180 	call	822d518 <irq_Unmask>
}
 8234898:	0001883a 	nop
 823489c:	e037883a 	mov	sp,fp
 82348a0:	dfc00117 	ldw	ra,4(sp)
 82348a4:	df000017 	ldw	fp,0(sp)
 82348a8:	dec00204 	addi	sp,sp,8
 82348ac:	f800283a 	ret

082348b0 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 82348b0:	defff904 	addi	sp,sp,-28
 82348b4:	dfc00615 	stw	ra,24(sp)
 82348b8:	df000515 	stw	fp,20(sp)
 82348bc:	df000504 	addi	fp,sp,20
 82348c0:	e13ffe15 	stw	r4,-8(fp)
 82348c4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 82348c8:	822d4b80 	call	822d4b8 <irq_Mask>
   len = mbuf_len(m);
 82348cc:	e13fff17 	ldw	r4,-4(fp)
 82348d0:	822e87c0 	call	822e87c <mbuf_len>
 82348d4:	e0bffd15 	stw	r2,-12(fp)
   if (len > 0)
 82348d8:	e0bffd17 	ldw	r2,-12(fp)
 82348dc:	0080070e 	bge	zero,r2,82348fc <sbdropend+0x4c>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 82348e0:	e0bffe17 	ldw	r2,-8(fp)
 82348e4:	10c00617 	ldw	r3,24(r2)
 82348e8:	e0bffd17 	ldw	r2,-12(fp)
 82348ec:	0085c83a 	sub	r2,zero,r2
 82348f0:	100b883a 	mov	r5,r2
 82348f4:	1809883a 	mov	r4,r3
 82348f8:	822e6bc0 	call	822e6bc <m_adj>
   nmb = sb->sb_mb;
 82348fc:	e0bffe17 	ldw	r2,-8(fp)
 8234900:	10800617 	ldw	r2,24(r2)
 8234904:	e0bffb15 	stw	r2,-20(fp)
   pmb = NULL;
 8234908:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 823490c:	e0bffe17 	ldw	r2,-8(fp)
 8234910:	10800617 	ldw	r2,24(r2)
 8234914:	10800217 	ldw	r2,8(r2)
 8234918:	1000081e 	bne	r2,zero,823493c <sbdropend+0x8c>
      sb->sb_mb = NULL;
 823491c:	e0bffe17 	ldw	r2,-8(fp)
 8234920:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234924:	00000506 	br	823493c <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 8234928:	e0bffb17 	ldw	r2,-20(fp)
 823492c:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 8234930:	e0bffb17 	ldw	r2,-20(fp)
 8234934:	10800617 	ldw	r2,24(r2)
 8234938:	e0bffb15 	stw	r2,-20(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 823493c:	e0bffb17 	ldw	r2,-20(fp)
 8234940:	10000326 	beq	r2,zero,8234950 <sbdropend+0xa0>
 8234944:	e0bffb17 	ldw	r2,-20(fp)
 8234948:	10800217 	ldw	r2,8(r2)
 823494c:	103ff61e 	bne	r2,zero,8234928 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 8234950:	e0bffb17 	ldw	r2,-20(fp)
 8234954:	10000926 	beq	r2,zero,823497c <sbdropend+0xcc>
 8234958:	e0bffb17 	ldw	r2,-20(fp)
 823495c:	10800217 	ldw	r2,8(r2)
 8234960:	1000061e 	bne	r2,zero,823497c <sbdropend+0xcc>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 8234964:	e0bffc17 	ldw	r2,-16(fp)
 8234968:	10000226 	beq	r2,zero,8234974 <sbdropend+0xc4>
         pmb->m_next = NULL;
 823496c:	e0bffc17 	ldw	r2,-16(fp)
 8234970:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 8234974:	e13ffb17 	ldw	r4,-20(fp)
 8234978:	822e3840 	call	822e384 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 823497c:	e0bffe17 	ldw	r2,-8(fp)
 8234980:	10c00017 	ldw	r3,0(r2)
 8234984:	e0bffd17 	ldw	r2,-12(fp)
 8234988:	1887c83a 	sub	r3,r3,r2
 823498c:	e0bffe17 	ldw	r2,-8(fp)
 8234990:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 8234994:	822d5180 	call	822d518 <irq_Unmask>
}
 8234998:	0001883a 	nop
 823499c:	e037883a 	mov	sp,fp
 82349a0:	dfc00117 	ldw	ra,4(sp)
 82349a4:	df000017 	ldw	fp,0(sp)
 82349a8:	dec00204 	addi	sp,sp,8
 82349ac:	f800283a 	ret

082349b0 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 82349b0:	defffb04 	addi	sp,sp,-20
 82349b4:	dfc00415 	stw	ra,16(sp)
 82349b8:	df000315 	stw	fp,12(sp)
 82349bc:	df000304 	addi	fp,sp,12
 82349c0:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 82349c4:	822d4b80 	call	822d4b8 <irq_Mask>
   m = sb->sb_mb;
 82349c8:	e0bfff17 	ldw	r2,-4(fp)
 82349cc:	10800617 	ldw	r2,24(r2)
 82349d0:	e0bffd15 	stw	r2,-12(fp)
   if (m)
 82349d4:	e0bffd17 	ldw	r2,-12(fp)
 82349d8:	10001226 	beq	r2,zero,8234a24 <sbdroprecord+0x74>
   {  sb->sb_mb = m->m_act;
 82349dc:	e0bffd17 	ldw	r2,-12(fp)
 82349e0:	10c00717 	ldw	r3,28(r2)
 82349e4:	e0bfff17 	ldw	r2,-4(fp)
 82349e8:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 82349ec:	e0bfff17 	ldw	r2,-4(fp)
 82349f0:	10c00017 	ldw	r3,0(r2)
 82349f4:	e0bffd17 	ldw	r2,-12(fp)
 82349f8:	10800217 	ldw	r2,8(r2)
 82349fc:	1887c83a 	sub	r3,r3,r2
 8234a00:	e0bfff17 	ldw	r2,-4(fp)
 8234a04:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 8234a08:	e13ffd17 	ldw	r4,-12(fp)
 8234a0c:	822e27c0 	call	822e27c <m_free>
 8234a10:	e0bffe15 	stw	r2,-8(fp)
      } while ((m = mn) != NULL);
 8234a14:	e0bffe17 	ldw	r2,-8(fp)
 8234a18:	e0bffd15 	stw	r2,-12(fp)
 8234a1c:	e0bffd17 	ldw	r2,-12(fp)
 8234a20:	103ff21e 	bne	r2,zero,82349ec <sbdroprecord+0x3c>
         }
   EXIT_CRIT_SECTION(sb);
 8234a24:	822d5180 	call	822d518 <irq_Unmask>
}
 8234a28:	0001883a 	nop
 8234a2c:	e037883a 	mov	sp,fp
 8234a30:	dfc00117 	ldw	ra,4(sp)
 8234a34:	df000017 	ldw	fp,0(sp)
 8234a38:	dec00204 	addi	sp,sp,8
 8234a3c:	f800283a 	ret

08234a40 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 8234a40:	defe7204 	addi	sp,sp,-1592
 8234a44:	dfc18d15 	stw	ra,1588(sp)
 8234a48:	df018c15 	stw	fp,1584(sp)
 8234a4c:	df018c04 	addi	fp,sp,1584
 8234a50:	e13ffc15 	stw	r4,-16(fp)
 8234a54:	e17ffd15 	stw	r5,-12(fp)
 8234a58:	e1bffe15 	stw	r6,-8(fp)
 8234a5c:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 8234a60:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 8234a64:	e0be7604 	addi	r2,fp,-1576
 8234a68:	0180c304 	movi	r6,780
 8234a6c:	000b883a 	mov	r5,zero
 8234a70:	1009883a 	mov	r4,r2
 8234a74:	8202f000 	call	8202f00 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 8234a78:	e0bf3904 	addi	r2,fp,-796
 8234a7c:	0180c304 	movi	r6,780
 8234a80:	000b883a 	mov	r5,zero
 8234a84:	1009883a 	mov	r4,r2
 8234a88:	8202f000 	call	8202f00 <memset>

   if (in)
 8234a8c:	e0bffc17 	ldw	r2,-16(fp)
 8234a90:	10000526 	beq	r2,zero,8234aa8 <t_select+0x68>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 8234a94:	e0bf3904 	addi	r2,fp,-796
 8234a98:	01804104 	movi	r6,260
 8234a9c:	e17ffc17 	ldw	r5,-16(fp)
 8234aa0:	1009883a 	mov	r4,r2
 8234aa4:	8202c5c0 	call	8202c5c <memcpy>
   if (out)
 8234aa8:	e0bffd17 	ldw	r2,-12(fp)
 8234aac:	10000626 	beq	r2,zero,8234ac8 <t_select+0x88>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 8234ab0:	e0bf3904 	addi	r2,fp,-796
 8234ab4:	10804104 	addi	r2,r2,260
 8234ab8:	01804104 	movi	r6,260
 8234abc:	e17ffd17 	ldw	r5,-12(fp)
 8234ac0:	1009883a 	mov	r4,r2
 8234ac4:	8202c5c0 	call	8202c5c <memcpy>
   if (ex)
 8234ac8:	e0bffe17 	ldw	r2,-8(fp)
 8234acc:	10000626 	beq	r2,zero,8234ae8 <t_select+0xa8>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 8234ad0:	e0bf3904 	addi	r2,fp,-796
 8234ad4:	10808204 	addi	r2,r2,520
 8234ad8:	01804104 	movi	r6,260
 8234adc:	e17ffe17 	ldw	r5,-8(fp)
 8234ae0:	1009883a 	mov	r4,r2
 8234ae4:	8202c5c0 	call	8202c5c <memcpy>
   tmo = cticks + tv;
 8234ae8:	d0e0a817 	ldw	r3,-32096(gp)
 8234aec:	e0bfff17 	ldw	r2,-4(fp)
 8234af0:	1885883a 	add	r2,r3,r2
 8234af4:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234af8:	e0bf3917 	ldw	r2,-796(fp)
 8234afc:	10000c1e 	bne	r2,zero,8234b30 <t_select+0xf0>
 8234b00:	e0bf7a17 	ldw	r2,-536(fp)
 8234b04:	10000a1e 	bne	r2,zero,8234b30 <t_select+0xf0>
       (ibits[2].fd_count == 0))
 8234b08:	e0bfbb17 	ldw	r2,-276(fp)
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234b0c:	1000081e 	bne	r2,zero,8234b30 <t_select+0xf0>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234b10:	e0bfff17 	ldw	r2,-4(fp)
 8234b14:	00801f0e 	bge	zero,r2,8234b94 <t_select+0x154>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 8234b18:	e0bfff17 	ldw	r2,-4(fp)
 8234b1c:	10800044 	addi	r2,r2,1
 8234b20:	10bfffcc 	andi	r2,r2,65535
 8234b24:	1009883a 	mov	r4,r2
 8234b28:	821bc240 	call	821bc24 <OSTimeDly>

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234b2c:	00001906 	br	8234b94 <t_select+0x154>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 8234b30:	0009883a 	mov	r4,zero
 8234b34:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234b38:	00000a06 	br	8234b64 <t_select+0x124>
      {
         if (tv != -1L) 
 8234b3c:	e0bfff17 	ldw	r2,-4(fp)
 8234b40:	10bfffe0 	cmpeqi	r2,r2,-1
 8234b44:	1000031e 	bne	r2,zero,8234b54 <t_select+0x114>
         {
            if (tmo <= cticks)
 8234b48:	d0e0a817 	ldw	r3,-32096(gp)
 8234b4c:	e0be7517 	ldw	r2,-1580(fp)
 8234b50:	18800d2e 	bgeu	r3,r2,8234b88 <t_select+0x148>
               break;
         }
         select_wait = 1;
 8234b54:	00800044 	movi	r2,1
 8234b58:	d0a0b00d 	sth	r2,-32064(gp)
         tcp_sleep (&select_wait);
 8234b5c:	d120b004 	addi	r4,gp,-32064
 8234b60:	82292800 	call	8229280 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234b64:	e0fe7604 	addi	r3,fp,-1576
 8234b68:	e0bf3904 	addi	r2,fp,-796
 8234b6c:	180b883a 	mov	r5,r3
 8234b70:	1009883a 	mov	r4,r2
 8234b74:	8234c100 	call	8234c10 <sock_selscan>
 8234b78:	e0be7415 	stw	r2,-1584(fp)
 8234b7c:	e0be7417 	ldw	r2,-1584(fp)
 8234b80:	103fee26 	beq	r2,zero,8234b3c <t_select+0xfc>
 8234b84:	00000106 	br	8234b8c <t_select+0x14c>
      {
         if (tv != -1L) 
         {
            if (tmo <= cticks)
               break;
 8234b88:	0001883a 	nop
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 8234b8c:	0009883a 	mov	r4,zero
 8234b90:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 8234b94:	e0be7417 	ldw	r2,-1584(fp)
 8234b98:	10001716 	blt	r2,zero,8234bf8 <t_select+0x1b8>
   {
      if (in)
 8234b9c:	e0bffc17 	ldw	r2,-16(fp)
 8234ba0:	10000526 	beq	r2,zero,8234bb8 <t_select+0x178>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 8234ba4:	e0be7604 	addi	r2,fp,-1576
 8234ba8:	01804104 	movi	r6,260
 8234bac:	100b883a 	mov	r5,r2
 8234bb0:	e13ffc17 	ldw	r4,-16(fp)
 8234bb4:	8202c5c0 	call	8202c5c <memcpy>
      if (out)
 8234bb8:	e0bffd17 	ldw	r2,-12(fp)
 8234bbc:	10000626 	beq	r2,zero,8234bd8 <t_select+0x198>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 8234bc0:	e0be7604 	addi	r2,fp,-1576
 8234bc4:	10804104 	addi	r2,r2,260
 8234bc8:	01804104 	movi	r6,260
 8234bcc:	100b883a 	mov	r5,r2
 8234bd0:	e13ffd17 	ldw	r4,-12(fp)
 8234bd4:	8202c5c0 	call	8202c5c <memcpy>
      if (ex)
 8234bd8:	e0bffe17 	ldw	r2,-8(fp)
 8234bdc:	10000626 	beq	r2,zero,8234bf8 <t_select+0x1b8>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 8234be0:	e0be7604 	addi	r2,fp,-1576
 8234be4:	10808204 	addi	r2,r2,520
 8234be8:	01804104 	movi	r6,260
 8234bec:	100b883a 	mov	r5,r2
 8234bf0:	e13ffe17 	ldw	r4,-8(fp)
 8234bf4:	8202c5c0 	call	8202c5c <memcpy>
   }
   return retval;
 8234bf8:	e0be7417 	ldw	r2,-1584(fp)
}
 8234bfc:	e037883a 	mov	sp,fp
 8234c00:	dfc00117 	ldw	ra,4(sp)
 8234c04:	df000017 	ldw	fp,0(sp)
 8234c08:	dec00204 	addi	sp,sp,8
 8234c0c:	f800283a 	ret

08234c10 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 8234c10:	defff604 	addi	sp,sp,-40
 8234c14:	dfc00915 	stw	ra,36(sp)
 8234c18:	df000815 	stw	fp,32(sp)
 8234c1c:	df000804 	addi	fp,sp,32
 8234c20:	e13ffe15 	stw	r4,-8(fp)
 8234c24:	e17fff15 	stw	r5,-4(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 8234c28:	e03ffa15 	stw	zero,-24(fp)
   int   num_sel  =  0;
 8234c2c:	e03ffb15 	stw	zero,-20(fp)

   for (which = 0; which < 3; which++)
 8234c30:	e03ff815 	stw	zero,-32(fp)
 8234c34:	00003d06 	br	8234d2c <sock_selscan+0x11c>
   {
      switch (which)
 8234c38:	e0bff817 	ldw	r2,-32(fp)
 8234c3c:	10c00060 	cmpeqi	r3,r2,1
 8234c40:	1800061e 	bne	r3,zero,8234c5c <sock_selscan+0x4c>
 8234c44:	10c000a0 	cmpeqi	r3,r2,2
 8234c48:	1800071e 	bne	r3,zero,8234c68 <sock_selscan+0x58>
 8234c4c:	1000081e 	bne	r2,zero,8234c70 <sock_selscan+0x60>
      {
      case 0:
         flag = SOREAD; break;
 8234c50:	00800044 	movi	r2,1
 8234c54:	e0bffa15 	stw	r2,-24(fp)
 8234c58:	00000506 	br	8234c70 <sock_selscan+0x60>

      case 1:
         flag = SOWRITE; break;
 8234c5c:	00800084 	movi	r2,2
 8234c60:	e0bffa15 	stw	r2,-24(fp)
 8234c64:	00000206 	br	8234c70 <sock_selscan+0x60>

      case 2:
         flag = 0; break;
 8234c68:	e03ffa15 	stw	zero,-24(fp)
 8234c6c:	0001883a 	nop
      }
      in = &ibits [which];
 8234c70:	e0bff817 	ldw	r2,-32(fp)
 8234c74:	10804124 	muli	r2,r2,260
 8234c78:	e0fffe17 	ldw	r3,-8(fp)
 8234c7c:	1885883a 	add	r2,r3,r2
 8234c80:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 8234c84:	e0bff817 	ldw	r2,-32(fp)
 8234c88:	10804124 	muli	r2,r2,260
 8234c8c:	e0ffff17 	ldw	r3,-4(fp)
 8234c90:	1885883a 	add	r2,r3,r2
 8234c94:	e0bffd15 	stw	r2,-12(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234c98:	e03ff915 	stw	zero,-28(fp)
 8234c9c:	00001b06 	br	8234d0c <sock_selscan+0xfc>
      {
         if (sock_select (in->fd_array[sock], flag))
 8234ca0:	e0fffc17 	ldw	r3,-16(fp)
 8234ca4:	e0bff917 	ldw	r2,-28(fp)
 8234ca8:	10800044 	addi	r2,r2,1
 8234cac:	1085883a 	add	r2,r2,r2
 8234cb0:	1085883a 	add	r2,r2,r2
 8234cb4:	1885883a 	add	r2,r3,r2
 8234cb8:	10800017 	ldw	r2,0(r2)
 8234cbc:	e17ffa17 	ldw	r5,-24(fp)
 8234cc0:	1009883a 	mov	r4,r2
 8234cc4:	8234d500 	call	8234d50 <sock_select>
 8234cc8:	10000d26 	beq	r2,zero,8234d00 <sock_selscan+0xf0>
         {
            FD_SET(in->fd_array[sock], out);
 8234ccc:	e0fffc17 	ldw	r3,-16(fp)
 8234cd0:	e0bff917 	ldw	r2,-28(fp)
 8234cd4:	10800044 	addi	r2,r2,1
 8234cd8:	1085883a 	add	r2,r2,r2
 8234cdc:	1085883a 	add	r2,r2,r2
 8234ce0:	1885883a 	add	r2,r3,r2
 8234ce4:	10800017 	ldw	r2,0(r2)
 8234ce8:	e17ffd17 	ldw	r5,-12(fp)
 8234cec:	1009883a 	mov	r4,r2
 8234cf0:	82351680 	call	8235168 <ifd_set>
            num_sel++;
 8234cf4:	e0bffb17 	ldw	r2,-20(fp)
 8234cf8:	10800044 	addi	r2,r2,1
 8234cfc:	e0bffb15 	stw	r2,-20(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234d00:	e0bff917 	ldw	r2,-28(fp)
 8234d04:	10800044 	addi	r2,r2,1
 8234d08:	e0bff915 	stw	r2,-28(fp)
 8234d0c:	e0bffc17 	ldw	r2,-16(fp)
 8234d10:	10800017 	ldw	r2,0(r2)
 8234d14:	1007883a 	mov	r3,r2
 8234d18:	e0bff917 	ldw	r2,-28(fp)
 8234d1c:	10ffe016 	blt	r2,r3,8234ca0 <sock_selscan+0x90>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 8234d20:	e0bff817 	ldw	r2,-32(fp)
 8234d24:	10800044 	addi	r2,r2,1
 8234d28:	e0bff815 	stw	r2,-32(fp)
 8234d2c:	e0bff817 	ldw	r2,-32(fp)
 8234d30:	108000d0 	cmplti	r2,r2,3
 8234d34:	103fc01e 	bne	r2,zero,8234c38 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 8234d38:	e0bffb17 	ldw	r2,-20(fp)
}
 8234d3c:	e037883a 	mov	sp,fp
 8234d40:	dfc00117 	ldw	ra,4(sp)
 8234d44:	df000017 	ldw	fp,0(sp)
 8234d48:	dec00204 	addi	sp,sp,8
 8234d4c:	f800283a 	ret

08234d50 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 8234d50:	defffa04 	addi	sp,sp,-24
 8234d54:	dfc00515 	stw	ra,20(sp)
 8234d58:	df000415 	stw	fp,16(sp)
 8234d5c:	df000404 	addi	fp,sp,16
 8234d60:	e13ffe15 	stw	r4,-8(fp)
 8234d64:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   ready =  0;
 8234d68:	e03ffc15 	stw	zero,-16(fp)

   so = LONG2SO(sock);
 8234d6c:	e0bffe17 	ldw	r2,-8(fp)
 8234d70:	10bff804 	addi	r2,r2,-32
 8234d74:	1085883a 	add	r2,r2,r2
 8234d78:	1085883a 	add	r2,r2,r2
 8234d7c:	e0bffd15 	stw	r2,-12(fp)

   switch (flag) 
 8234d80:	e0bfff17 	ldw	r2,-4(fp)
 8234d84:	10c00060 	cmpeqi	r3,r2,1
 8234d88:	1800041e 	bne	r3,zero,8234d9c <sock_select+0x4c>
 8234d8c:	10c000a0 	cmpeqi	r3,r2,2
 8234d90:	1800201e 	bne	r3,zero,8234e14 <sock_select+0xc4>
 8234d94:	10004326 	beq	r2,zero,8234ea4 <sock_select+0x154>
 8234d98:	00006006 	br	8234f1c <sock_select+0x1cc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 8234d9c:	e0bffd17 	ldw	r2,-12(fp)
 8234da0:	10800a17 	ldw	r2,40(r2)
 8234da4:	10000326 	beq	r2,zero,8234db4 <sock_select+0x64>
      {
         ready = 1;
 8234da8:	00800044 	movi	r2,1
 8234dac:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234db0:	00005a06 	br	8234f1c <sock_select+0x1cc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8234db4:	e0bffd17 	ldw	r2,-12(fp)
 8234db8:	1080088b 	ldhu	r2,34(r2)
 8234dbc:	10bfffcc 	andi	r2,r2,65535
 8234dc0:	1080080c 	andi	r2,r2,32
 8234dc4:	10000326 	beq	r2,zero,8234dd4 <sock_select+0x84>
      {  ready = 1;
 8234dc8:	00800044 	movi	r2,1
 8234dcc:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234dd0:	00005206 	br	8234f1c <sock_select+0x1cc>
      }
      if (so->so_qlen)  /* attach is ready */
 8234dd4:	e0bffd17 	ldw	r2,-12(fp)
 8234dd8:	10801e43 	ldbu	r2,121(r2)
 8234ddc:	10803fcc 	andi	r2,r2,255
 8234de0:	1080201c 	xori	r2,r2,128
 8234de4:	10bfe004 	addi	r2,r2,-128
 8234de8:	10000326 	beq	r2,zero,8234df8 <sock_select+0xa8>
      {
         ready = 1;
 8234dec:	00800044 	movi	r2,1
 8234df0:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234df4:	00004906 	br	8234f1c <sock_select+0x1cc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 8234df8:	e0bffd17 	ldw	r2,-12(fp)
 8234dfc:	1080110b 	ldhu	r2,68(r2)
 8234e00:	10800214 	ori	r2,r2,8
 8234e04:	1007883a 	mov	r3,r2
 8234e08:	e0bffd17 	ldw	r2,-12(fp)
 8234e0c:	10c0110d 	sth	r3,68(r2)
      break;
 8234e10:	00004206 	br	8234f1c <sock_select+0x1cc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8234e14:	e0bffd17 	ldw	r2,-12(fp)
 8234e18:	10801317 	ldw	r2,76(r2)
 8234e1c:	1007883a 	mov	r3,r2
 8234e20:	e0bffd17 	ldw	r2,-12(fp)
 8234e24:	10801217 	ldw	r2,72(r2)
 8234e28:	1885c83a 	sub	r2,r3,r2
 8234e2c:	10001816 	blt	r2,zero,8234e90 <sock_select+0x140>
 8234e30:	e0bffd17 	ldw	r2,-12(fp)
 8234e34:	10c01317 	ldw	r3,76(r2)
 8234e38:	e0bffd17 	ldw	r2,-12(fp)
 8234e3c:	10801217 	ldw	r2,72(r2)
 8234e40:	18801326 	beq	r3,r2,8234e90 <sock_select+0x140>
          ((((so)->so_state&SS_ISCONNECTED) || 
 8234e44:	e0bffd17 	ldw	r2,-12(fp)
 8234e48:	1080088b 	ldhu	r2,34(r2)
 8234e4c:	10bfffcc 	andi	r2,r2,65535
 8234e50:	1080008c 	andi	r2,r2,2
      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8234e54:	10000b1e 	bne	r2,zero,8234e84 <sock_select+0x134>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8234e58:	e0bffd17 	ldw	r2,-12(fp)
 8234e5c:	10800217 	ldw	r2,8(r2)
 8234e60:	1080010b 	ldhu	r2,4(r2)
 8234e64:	10bfffcc 	andi	r2,r2,65535
 8234e68:	1080010c 	andi	r2,r2,4
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
 8234e6c:	10000526 	beq	r2,zero,8234e84 <sock_select+0x134>
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
 8234e70:	e0bffd17 	ldw	r2,-12(fp)
 8234e74:	1080088b 	ldhu	r2,34(r2)
 8234e78:	10bfffcc 	andi	r2,r2,65535
 8234e7c:	1080040c 	andi	r2,r2,16
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8234e80:	10000326 	beq	r2,zero,8234e90 <sock_select+0x140>
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 8234e84:	00800044 	movi	r2,1
 8234e88:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234e8c:	00002306 	br	8234f1c <sock_select+0x1cc>
      }
      sbselqueue (&so->so_snd);
 8234e90:	e0bffd17 	ldw	r2,-12(fp)
 8234e94:	10801204 	addi	r2,r2,72
 8234e98:	1009883a 	mov	r4,r2
 8234e9c:	8233ee80 	call	8233ee8 <sbselqueue>
      break;
 8234ea0:	00001e06 	br	8234f1c <sock_select+0x1cc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 8234ea4:	e0bffd17 	ldw	r2,-12(fp)
 8234ea8:	10801a17 	ldw	r2,104(r2)
 8234eac:	1000051e 	bne	r2,zero,8234ec4 <sock_select+0x174>
 8234eb0:	e0bffd17 	ldw	r2,-12(fp)
 8234eb4:	1080088b 	ldhu	r2,34(r2)
 8234eb8:	10bfffcc 	andi	r2,r2,65535
 8234ebc:	1080100c 	andi	r2,r2,64
 8234ec0:	10000326 	beq	r2,zero,8234ed0 <sock_select+0x180>
      {
         ready = 1;
 8234ec4:	00800044 	movi	r2,1
 8234ec8:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234ecc:	00001306 	br	8234f1c <sock_select+0x1cc>
      }
      if (so->so_error &&
 8234ed0:	e0bffd17 	ldw	r2,-12(fp)
 8234ed4:	10800617 	ldw	r2,24(r2)
 8234ed8:	10000b26 	beq	r2,zero,8234f08 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
 8234edc:	e0bffd17 	ldw	r2,-12(fp)
 8234ee0:	10800617 	ldw	r2,24(r2)
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
 8234ee4:	10801de0 	cmpeqi	r2,r2,119
 8234ee8:	1000071e 	bne	r2,zero,8234f08 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
 8234eec:	e0bffd17 	ldw	r2,-12(fp)
 8234ef0:	10800617 	ldw	r2,24(r2)
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
          (so->so_error != EINPROGRESS) &&
 8234ef4:	108002e0 	cmpeqi	r2,r2,11
 8234ef8:	1000031e 	bne	r2,zero,8234f08 <sock_select+0x1b8>
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 8234efc:	00800044 	movi	r2,1
 8234f00:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234f04:	00000506 	br	8234f1c <sock_select+0x1cc>
      }
      sbselqueue(&so->so_rcv);
 8234f08:	e0bffd17 	ldw	r2,-12(fp)
 8234f0c:	10800a04 	addi	r2,r2,40
 8234f10:	1009883a 	mov	r4,r2
 8234f14:	8233ee80 	call	8233ee8 <sbselqueue>
      break;
 8234f18:	0001883a 	nop
   }

   return ready;
 8234f1c:	e0bffc17 	ldw	r2,-16(fp)
}
 8234f20:	e037883a 	mov	sp,fp
 8234f24:	dfc00117 	ldw	ra,4(sp)
 8234f28:	df000017 	ldw	fp,0(sp)
 8234f2c:	dec00204 	addi	sp,sp,8
 8234f30:	f800283a 	ret

08234f34 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 8234f34:	defff804 	addi	sp,sp,-32
 8234f38:	dfc00715 	stw	ra,28(sp)
 8234f3c:	df000615 	stw	fp,24(sp)
 8234f40:	df000604 	addi	fp,sp,24
 8234f44:	e13ffc15 	stw	r4,-16(fp)
 8234f48:	e17ffd15 	stw	r5,-12(fp)
 8234f4c:	e1bffe15 	stw	r6,-8(fp)
 8234f50:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8234f54:	e0bffc17 	ldw	r2,-16(fp)
 8234f58:	10800017 	ldw	r2,0(r2)
 8234f5c:	e0bffa15 	stw	r2,-24(fp)
 8234f60:	00001c06 	br	8234fd4 <in_pcbnotify+0xa0>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8234f64:	e0bffa17 	ldw	r2,-24(fp)
 8234f68:	10c00317 	ldw	r3,12(r2)
 8234f6c:	e0bffd17 	ldw	r2,-12(fp)
 8234f70:	10800017 	ldw	r2,0(r2)
 8234f74:	1880031e 	bne	r3,r2,8234f84 <in_pcbnotify+0x50>
          inp->inp_socket == 0) 
 8234f78:	e0bffa17 	ldw	r2,-24(fp)
 8234f7c:	10800817 	ldw	r2,32(r2)
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8234f80:	1000041e 	bne	r2,zero,8234f94 <in_pcbnotify+0x60>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 8234f84:	e0bffa17 	ldw	r2,-24(fp)
 8234f88:	10800017 	ldw	r2,0(r2)
 8234f8c:	e0bffa15 	stw	r2,-24(fp)
         continue;
 8234f90:	00001006 	br	8234fd4 <in_pcbnotify+0xa0>
      }
      if (errnum) 
 8234f94:	e0bffe17 	ldw	r2,-8(fp)
 8234f98:	10000426 	beq	r2,zero,8234fac <in_pcbnotify+0x78>
         inp->inp_socket->so_error = errnum;
 8234f9c:	e0bffa17 	ldw	r2,-24(fp)
 8234fa0:	10800817 	ldw	r2,32(r2)
 8234fa4:	e0fffe17 	ldw	r3,-8(fp)
 8234fa8:	10c00615 	stw	r3,24(r2)
      oinp = inp;
 8234fac:	e0bffa17 	ldw	r2,-24(fp)
 8234fb0:	e0bffb15 	stw	r2,-20(fp)
      inp = inp->inp_next;
 8234fb4:	e0bffa17 	ldw	r2,-24(fp)
 8234fb8:	10800017 	ldw	r2,0(r2)
 8234fbc:	e0bffa15 	stw	r2,-24(fp)
      if (notify)
 8234fc0:	e0bfff17 	ldw	r2,-4(fp)
 8234fc4:	10000326 	beq	r2,zero,8234fd4 <in_pcbnotify+0xa0>
         (*notify)(oinp);
 8234fc8:	e0bfff17 	ldw	r2,-4(fp)
 8234fcc:	e13ffb17 	ldw	r4,-20(fp)
 8234fd0:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8234fd4:	e0fffa17 	ldw	r3,-24(fp)
 8234fd8:	e0bffc17 	ldw	r2,-16(fp)
 8234fdc:	18bfe11e 	bne	r3,r2,8234f64 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 8234fe0:	0001883a 	nop
 8234fe4:	e037883a 	mov	sp,fp
 8234fe8:	dfc00117 	ldw	ra,4(sp)
 8234fec:	df000017 	ldw	fp,0(sp)
 8234ff0:	dec00204 	addi	sp,sp,8
 8234ff4:	f800283a 	ret

08234ff8 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 8234ff8:	defffd04 	addi	sp,sp,-12
 8234ffc:	dfc00215 	stw	ra,8(sp)
 8235000:	df000115 	stw	fp,4(sp)
 8235004:	df000104 	addi	fp,sp,4
 8235008:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 823500c:	e0bfff17 	ldw	r2,-4(fp)
 8235010:	10800817 	ldw	r2,32(r2)
 8235014:	10800904 	addi	r2,r2,36
 8235018:	1009883a 	mov	r4,r2
 823501c:	82293f40 	call	82293f4 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 8235020:	e0bfff17 	ldw	r2,-4(fp)
 8235024:	10c00817 	ldw	r3,32(r2)
 8235028:	e0bfff17 	ldw	r2,-4(fp)
 823502c:	10800817 	ldw	r2,32(r2)
 8235030:	10800a04 	addi	r2,r2,40
 8235034:	100b883a 	mov	r5,r2
 8235038:	1809883a 	mov	r4,r3
 823503c:	8233f900 	call	8233f90 <sbwakeup>
   sowwakeup(inp->inp_socket);
 8235040:	e0bfff17 	ldw	r2,-4(fp)
 8235044:	10c00817 	ldw	r3,32(r2)
 8235048:	e0bfff17 	ldw	r2,-4(fp)
 823504c:	10800817 	ldw	r2,32(r2)
 8235050:	10801204 	addi	r2,r2,72
 8235054:	100b883a 	mov	r5,r2
 8235058:	1809883a 	mov	r4,r3
 823505c:	8233f900 	call	8233f90 <sbwakeup>
}
 8235060:	0001883a 	nop
 8235064:	e037883a 	mov	sp,fp
 8235068:	dfc00117 	ldw	ra,4(sp)
 823506c:	df000017 	ldw	fp,0(sp)
 8235070:	dec00204 	addi	sp,sp,8
 8235074:	f800283a 	ret

08235078 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 8235078:	defffb04 	addi	sp,sp,-20
 823507c:	dfc00415 	stw	ra,16(sp)
 8235080:	df000315 	stw	fp,12(sp)
 8235084:	df000304 	addi	fp,sp,12
 8235088:	e13ffe15 	stw	r4,-8(fp)
 823508c:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 8235090:	e03ffd15 	stw	zero,-12(fp)
 8235094:	00002a06 	br	8235140 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 8235098:	e0ffff17 	ldw	r3,-4(fp)
 823509c:	e0bffd17 	ldw	r2,-12(fp)
 82350a0:	10800044 	addi	r2,r2,1
 82350a4:	1085883a 	add	r2,r2,r2
 82350a8:	1085883a 	add	r2,r2,r2
 82350ac:	1885883a 	add	r2,r3,r2
 82350b0:	10c00017 	ldw	r3,0(r2)
 82350b4:	e0bffe17 	ldw	r2,-8(fp)
 82350b8:	18801e1e 	bne	r3,r2,8235134 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 82350bc:	00001206 	br	8235108 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 82350c0:	e0bffd17 	ldw	r2,-12(fp)
 82350c4:	10800044 	addi	r2,r2,1
 82350c8:	e0ffff17 	ldw	r3,-4(fp)
 82350cc:	10800044 	addi	r2,r2,1
 82350d0:	1085883a 	add	r2,r2,r2
 82350d4:	1085883a 	add	r2,r2,r2
 82350d8:	1885883a 	add	r2,r3,r2
 82350dc:	10c00017 	ldw	r3,0(r2)
 82350e0:	e13fff17 	ldw	r4,-4(fp)
 82350e4:	e0bffd17 	ldw	r2,-12(fp)
 82350e8:	10800044 	addi	r2,r2,1
 82350ec:	1085883a 	add	r2,r2,r2
 82350f0:	1085883a 	add	r2,r2,r2
 82350f4:	2085883a 	add	r2,r4,r2
 82350f8:	10c00015 	stw	r3,0(r2)
            i++;
 82350fc:	e0bffd17 	ldw	r2,-12(fp)
 8235100:	10800044 	addi	r2,r2,1
 8235104:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 8235108:	e0bffd17 	ldw	r2,-12(fp)
 823510c:	10c00044 	addi	r3,r2,1
 8235110:	e0bfff17 	ldw	r2,-4(fp)
 8235114:	10800017 	ldw	r2,0(r2)
 8235118:	18bfe936 	bltu	r3,r2,82350c0 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 823511c:	e0bfff17 	ldw	r2,-4(fp)
 8235120:	10800017 	ldw	r2,0(r2)
 8235124:	10ffffc4 	addi	r3,r2,-1
 8235128:	e0bfff17 	ldw	r2,-4(fp)
 823512c:	10c00015 	stw	r3,0(r2)
         return;
 8235130:	00000806 	br	8235154 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 8235134:	e0bffd17 	ldw	r2,-12(fp)
 8235138:	10800044 	addi	r2,r2,1
 823513c:	e0bffd15 	stw	r2,-12(fp)
 8235140:	e0bfff17 	ldw	r2,-4(fp)
 8235144:	10800017 	ldw	r2,0(r2)
 8235148:	e0fffd17 	ldw	r3,-12(fp)
 823514c:	18bfd236 	bltu	r3,r2,8235098 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 8235150:	822d2e00 	call	822d2e0 <dtrap>
#endif
}
 8235154:	e037883a 	mov	sp,fp
 8235158:	dfc00117 	ldw	ra,4(sp)
 823515c:	df000017 	ldw	fp,0(sp)
 8235160:	dec00204 	addi	sp,sp,8
 8235164:	f800283a 	ret

08235168 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 8235168:	defffc04 	addi	sp,sp,-16
 823516c:	dfc00315 	stw	ra,12(sp)
 8235170:	df000215 	stw	fp,8(sp)
 8235174:	df000204 	addi	fp,sp,8
 8235178:	e13ffe15 	stw	r4,-8(fp)
 823517c:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 8235180:	e0bfff17 	ldw	r2,-4(fp)
 8235184:	10800017 	ldw	r2,0(r2)
 8235188:	10801028 	cmpgeui	r2,r2,64
 823518c:	10000d1e 	bne	r2,zero,82351c4 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 8235190:	e0bfff17 	ldw	r2,-4(fp)
 8235194:	10800017 	ldw	r2,0(r2)
 8235198:	11000044 	addi	r4,r2,1
 823519c:	e0ffff17 	ldw	r3,-4(fp)
 82351a0:	19000015 	stw	r4,0(r3)
 82351a4:	e0ffff17 	ldw	r3,-4(fp)
 82351a8:	10800044 	addi	r2,r2,1
 82351ac:	1085883a 	add	r2,r2,r2
 82351b0:	1085883a 	add	r2,r2,r2
 82351b4:	1885883a 	add	r2,r3,r2
 82351b8:	e0fffe17 	ldw	r3,-8(fp)
 82351bc:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
   else
      dtrap();
#endif
}
 82351c0:	00000106 	br	82351c8 <ifd_set+0x60>
{
   if (set->fd_count < FD_SETSIZE)
      set->fd_array[set->fd_count++] = sock;
#ifdef NPDEBUG
   else
      dtrap();
 82351c4:	822d2e00 	call	822d2e0 <dtrap>
#endif
}
 82351c8:	0001883a 	nop
 82351cc:	e037883a 	mov	sp,fp
 82351d0:	dfc00117 	ldw	ra,4(sp)
 82351d4:	df000017 	ldw	fp,0(sp)
 82351d8:	dec00204 	addi	sp,sp,8
 82351dc:	f800283a 	ret

082351e0 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 82351e0:	defffc04 	addi	sp,sp,-16
 82351e4:	df000315 	stw	fp,12(sp)
 82351e8:	df000304 	addi	fp,sp,12
 82351ec:	e13ffe15 	stw	r4,-8(fp)
 82351f0:	e17fff15 	stw	r5,-4(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 82351f4:	e03ffd15 	stw	zero,-12(fp)
 82351f8:	00000e06 	br	8235234 <ifd_isset+0x54>
   {
      if (set->fd_array[i] == sock)
 82351fc:	e0ffff17 	ldw	r3,-4(fp)
 8235200:	e0bffd17 	ldw	r2,-12(fp)
 8235204:	10800044 	addi	r2,r2,1
 8235208:	1085883a 	add	r2,r2,r2
 823520c:	1085883a 	add	r2,r2,r2
 8235210:	1885883a 	add	r2,r3,r2
 8235214:	10c00017 	ldw	r3,0(r2)
 8235218:	e0bffe17 	ldw	r2,-8(fp)
 823521c:	1880021e 	bne	r3,r2,8235228 <ifd_isset+0x48>
         return TRUE;
 8235220:	00800044 	movi	r2,1
 8235224:	00000806 	br	8235248 <ifd_isset+0x68>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 8235228:	e0bffd17 	ldw	r2,-12(fp)
 823522c:	10800044 	addi	r2,r2,1
 8235230:	e0bffd15 	stw	r2,-12(fp)
 8235234:	e0bfff17 	ldw	r2,-4(fp)
 8235238:	10800017 	ldw	r2,0(r2)
 823523c:	e0fffd17 	ldw	r3,-12(fp)
 8235240:	18bfee36 	bltu	r3,r2,82351fc <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 8235244:	0005883a 	mov	r2,zero
}
 8235248:	e037883a 	mov	sp,fp
 823524c:	df000017 	ldw	fp,0(sp)
 8235250:	dec00104 	addi	sp,sp,4
 8235254:	f800283a 	ret

08235258 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 8235258:	defffc04 	addi	sp,sp,-16
 823525c:	dfc00315 	stw	ra,12(sp)
 8235260:	df000215 	stw	fp,8(sp)
 8235264:	df000204 	addi	fp,sp,8
 8235268:	e13ffe15 	stw	r4,-8(fp)
 823526c:	e17fff15 	stw	r5,-4(fp)
   if (i < set->fd_count)
 8235270:	e0bfff17 	ldw	r2,-4(fp)
 8235274:	10800017 	ldw	r2,0(r2)
 8235278:	e0fffe17 	ldw	r3,-8(fp)
 823527c:	1880082e 	bgeu	r3,r2,82352a0 <ifd_get+0x48>
      return set->fd_array[i];
 8235280:	e0ffff17 	ldw	r3,-4(fp)
 8235284:	e0bffe17 	ldw	r2,-8(fp)
 8235288:	10800044 	addi	r2,r2,1
 823528c:	1085883a 	add	r2,r2,r2
 8235290:	1085883a 	add	r2,r2,r2
 8235294:	1885883a 	add	r2,r3,r2
 8235298:	10800017 	ldw	r2,0(r2)
 823529c:	00000206 	br	82352a8 <ifd_get+0x50>
   else
   {
#ifdef NPDEBUG
      dtrap();
 82352a0:	822d2e00 	call	822d2e0 <dtrap>
#endif
      return INVALID_SOCKET;
 82352a4:	00bfffc4 	movi	r2,-1
   }
}
 82352a8:	e037883a 	mov	sp,fp
 82352ac:	dfc00117 	ldw	ra,4(sp)
 82352b0:	df000017 	ldw	fp,0(sp)
 82352b4:	dec00204 	addi	sp,sp,8
 82352b8:	f800283a 	ret

082352bc <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 82352bc:	defff504 	addi	sp,sp,-44
 82352c0:	dfc00a15 	stw	ra,40(sp)
 82352c4:	df000915 	stw	fp,36(sp)
 82352c8:	df000904 	addi	fp,sp,36
 82352cc:	e13ffd15 	stw	r4,-12(fp)
 82352d0:	e17ffe15 	stw	r5,-8(fp)
 82352d4:	e1bfff15 	stw	r6,-4(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 82352d8:	e0bffd17 	ldw	r2,-12(fp)
 82352dc:	10800d17 	ldw	r2,52(r2)
 82352e0:	10800817 	ldw	r2,32(r2)
 82352e4:	e0bff815 	stw	r2,-32(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 82352e8:	e0bffe17 	ldw	r2,-8(fp)
 82352ec:	1000a426 	beq	r2,zero,8235580 <tcp_reass+0x2c4>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 82352f0:	e0bffd17 	ldw	r2,-12(fp)
 82352f4:	10800017 	ldw	r2,0(r2)
 82352f8:	e0bff715 	stw	r2,-36(fp)
 82352fc:	00000906 	br	8235324 <tcp_reass+0x68>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 8235300:	e0bff717 	ldw	r2,-36(fp)
 8235304:	10c00617 	ldw	r3,24(r2)
 8235308:	e0bffe17 	ldw	r2,-8(fp)
 823530c:	10800617 	ldw	r2,24(r2)
 8235310:	1885c83a 	sub	r2,r3,r2
 8235314:	00800716 	blt	zero,r2,8235334 <tcp_reass+0x78>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 8235318:	e0bff717 	ldw	r2,-36(fp)
 823531c:	10800017 	ldw	r2,0(r2)
 8235320:	e0bff715 	stw	r2,-36(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 8235324:	e0fff717 	ldw	r3,-36(fp)
 8235328:	e0bffd17 	ldw	r2,-12(fp)
 823532c:	18bff41e 	bne	r3,r2,8235300 <tcp_reass+0x44>
 8235330:	00000106 	br	8235338 <tcp_reass+0x7c>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
      break;
 8235334:	0001883a 	nop
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 8235338:	e0bff717 	ldw	r2,-36(fp)
 823533c:	10c00117 	ldw	r3,4(r2)
 8235340:	e0bffd17 	ldw	r2,-12(fp)
 8235344:	18803f26 	beq	r3,r2,8235444 <tcp_reass+0x188>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 8235348:	e0bff717 	ldw	r2,-36(fp)
 823534c:	10800117 	ldw	r2,4(r2)
 8235350:	e0bff715 	stw	r2,-36(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 8235354:	e0bff717 	ldw	r2,-36(fp)
 8235358:	10c00617 	ldw	r3,24(r2)
 823535c:	e0bff717 	ldw	r2,-36(fp)
 8235360:	1080028b 	ldhu	r2,10(r2)
 8235364:	10bfffcc 	andi	r2,r2,65535
 8235368:	1887883a 	add	r3,r3,r2
 823536c:	e0bffe17 	ldw	r2,-8(fp)
 8235370:	10800617 	ldw	r2,24(r2)
 8235374:	1885c83a 	sub	r2,r3,r2
 8235378:	e0bff915 	stw	r2,-28(fp)
      if (i > 0) 
 823537c:	e0bff917 	ldw	r2,-28(fp)
 8235380:	00802d0e 	bge	zero,r2,8235438 <tcp_reass+0x17c>
      {
         if (i >= (long)ti->ti_len) 
 8235384:	e0bffe17 	ldw	r2,-8(fp)
 8235388:	1080028b 	ldhu	r2,10(r2)
 823538c:	10bfffcc 	andi	r2,r2,65535
 8235390:	e0fff917 	ldw	r3,-28(fp)
 8235394:	18801816 	blt	r3,r2,82353f8 <tcp_reass+0x13c>
         {
            tcpstat.tcps_rcvduppack++;
 8235398:	008209b4 	movhi	r2,2086
 823539c:	10b8aa04 	addi	r2,r2,-7512
 82353a0:	10801f17 	ldw	r2,124(r2)
 82353a4:	10c00044 	addi	r3,r2,1
 82353a8:	008209b4 	movhi	r2,2086
 82353ac:	10b8aa04 	addi	r2,r2,-7512
 82353b0:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 82353b4:	008209b4 	movhi	r2,2086
 82353b8:	10b8aa04 	addi	r2,r2,-7512
 82353bc:	10c02017 	ldw	r3,128(r2)
 82353c0:	e0bffe17 	ldw	r2,-8(fp)
 82353c4:	1080028b 	ldhu	r2,10(r2)
 82353c8:	10bfffcc 	andi	r2,r2,65535
 82353cc:	1887883a 	add	r3,r3,r2
 82353d0:	008209b4 	movhi	r2,2086
 82353d4:	10b8aa04 	addi	r2,r2,-7512
 82353d8:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 82353dc:	008025c4 	movi	r2,151
 82353e0:	d0a0b215 	stw	r2,-32056(gp)
 82353e4:	0001883a 	nop
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
      sorwakeup(so);
   return (flags);
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 82353e8:	e13fff17 	ldw	r4,-4(fp)
 82353ec:	822e3840 	call	822e384 <m_freem>
   return (0);
 82353f0:	0005883a 	mov	r2,zero
 82353f4:	0000b006 	br	82356b8 <tcp_reass+0x3fc>
         {
            tcpstat.tcps_rcvduppack++;
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
            GOTO_DROP;
         }
         m_adj (ti_mbuf, (int)i);
 82353f8:	e17ff917 	ldw	r5,-28(fp)
 82353fc:	e13fff17 	ldw	r4,-4(fp)
 8235400:	822e6bc0 	call	822e6bc <m_adj>
         ti->ti_len -= (short)i;
 8235404:	e0bffe17 	ldw	r2,-8(fp)
 8235408:	1080028b 	ldhu	r2,10(r2)
 823540c:	e0fff917 	ldw	r3,-28(fp)
 8235410:	10c5c83a 	sub	r2,r2,r3
 8235414:	1007883a 	mov	r3,r2
 8235418:	e0bffe17 	ldw	r2,-8(fp)
 823541c:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 8235420:	e0bffe17 	ldw	r2,-8(fp)
 8235424:	10c00617 	ldw	r3,24(r2)
 8235428:	e0bff917 	ldw	r2,-28(fp)
 823542c:	1887883a 	add	r3,r3,r2
 8235430:	e0bffe17 	ldw	r2,-8(fp)
 8235434:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 8235438:	e0bff717 	ldw	r2,-36(fp)
 823543c:	10800017 	ldw	r2,0(r2)
 8235440:	e0bff715 	stw	r2,-36(fp)
   }
   tcpstat.tcps_rcvoopack++;
 8235444:	008209b4 	movhi	r2,2086
 8235448:	10b8aa04 	addi	r2,r2,-7512
 823544c:	10802317 	ldw	r2,140(r2)
 8235450:	10c00044 	addi	r3,r2,1
 8235454:	008209b4 	movhi	r2,2086
 8235458:	10b8aa04 	addi	r2,r2,-7512
 823545c:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 8235460:	008209b4 	movhi	r2,2086
 8235464:	10b8aa04 	addi	r2,r2,-7512
 8235468:	10c02417 	ldw	r3,144(r2)
 823546c:	e0bffe17 	ldw	r2,-8(fp)
 8235470:	1080028b 	ldhu	r2,10(r2)
 8235474:	10bfffcc 	andi	r2,r2,65535
 8235478:	1887883a 	add	r3,r3,r2
 823547c:	008209b4 	movhi	r2,2086
 8235480:	10b8aa04 	addi	r2,r2,-7512
 8235484:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235488:	00003206 	br	8235554 <tcp_reass+0x298>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 823548c:	e0bffe17 	ldw	r2,-8(fp)
 8235490:	10c00617 	ldw	r3,24(r2)
 8235494:	e0bffe17 	ldw	r2,-8(fp)
 8235498:	1080028b 	ldhu	r2,10(r2)
 823549c:	10bfffcc 	andi	r2,r2,65535
 82354a0:	1887883a 	add	r3,r3,r2
 82354a4:	e0bff717 	ldw	r2,-36(fp)
 82354a8:	10800617 	ldw	r2,24(r2)
 82354ac:	1885c83a 	sub	r2,r3,r2
 82354b0:	e0bffa15 	stw	r2,-24(fp)
      if (i <= 0)
 82354b4:	e0bffa17 	ldw	r2,-24(fp)
 82354b8:	00802a0e 	bge	zero,r2,8235564 <tcp_reass+0x2a8>
         break;
      if (i < (int)(q->ti_len))
 82354bc:	e0bff717 	ldw	r2,-36(fp)
 82354c0:	1080028b 	ldhu	r2,10(r2)
 82354c4:	10bfffcc 	andi	r2,r2,65535
 82354c8:	e0fffa17 	ldw	r3,-24(fp)
 82354cc:	1880130e 	bge	r3,r2,823551c <tcp_reass+0x260>
      {
         q->ti_seq += i;
 82354d0:	e0bff717 	ldw	r2,-36(fp)
 82354d4:	10c00617 	ldw	r3,24(r2)
 82354d8:	e0bffa17 	ldw	r2,-24(fp)
 82354dc:	1887883a 	add	r3,r3,r2
 82354e0:	e0bff717 	ldw	r2,-36(fp)
 82354e4:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 82354e8:	e0bff717 	ldw	r2,-36(fp)
 82354ec:	1080028b 	ldhu	r2,10(r2)
 82354f0:	e0fffa17 	ldw	r3,-24(fp)
 82354f4:	10c5c83a 	sub	r2,r2,r3
 82354f8:	1007883a 	mov	r3,r2
 82354fc:	e0bff717 	ldw	r2,-36(fp)
 8235500:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 8235504:	e13ff717 	ldw	r4,-36(fp)
 8235508:	822e8d00 	call	822e8d0 <dtom>
 823550c:	e17ffa17 	ldw	r5,-24(fp)
 8235510:	1009883a 	mov	r4,r2
 8235514:	822e6bc0 	call	822e6bc <m_adj>
         break;
 8235518:	00001306 	br	8235568 <tcp_reass+0x2ac>
      }
      q = (struct tcpiphdr *)q->ti_next;
 823551c:	e0bff717 	ldw	r2,-36(fp)
 8235520:	10800017 	ldw	r2,0(r2)
 8235524:	e0bff715 	stw	r2,-36(fp)
      m = dtom(q->ti_prev);
 8235528:	e0bff717 	ldw	r2,-36(fp)
 823552c:	10800117 	ldw	r2,4(r2)
 8235530:	1009883a 	mov	r4,r2
 8235534:	822e8d00 	call	822e8d0 <dtom>
 8235538:	e0bffb15 	stw	r2,-20(fp)
      remque (q->ti_prev);
 823553c:	e0bff717 	ldw	r2,-36(fp)
 8235540:	10800117 	ldw	r2,4(r2)
 8235544:	1009883a 	mov	r4,r2
 8235548:	822e96c0 	call	822e96c <remque>
      m_freem (m);
 823554c:	e13ffb17 	ldw	r4,-20(fp)
 8235550:	822e3840 	call	822e384 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235554:	e0fff717 	ldw	r3,-36(fp)
 8235558:	e0bffd17 	ldw	r2,-12(fp)
 823555c:	18bfcb1e 	bne	r3,r2,823548c <tcp_reass+0x1d0>
 8235560:	00000106 	br	8235568 <tcp_reass+0x2ac>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
      if (i <= 0)
         break;
 8235564:	0001883a 	nop
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 8235568:	e0bff717 	ldw	r2,-36(fp)
 823556c:	10800117 	ldw	r2,4(r2)
 8235570:	100b883a 	mov	r5,r2
 8235574:	e13ffe17 	ldw	r4,-8(fp)
 8235578:	822e9dc0 	call	822e9dc <insque>
 823557c:	00000106 	br	8235584 <tcp_reass+0x2c8>
   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
      goto present;
 8235580:	0001883a 	nop
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 8235584:	e0bffd17 	ldw	r2,-12(fp)
 8235588:	10800217 	ldw	r2,8(r2)
 823558c:	108000c8 	cmpgei	r2,r2,3
 8235590:	1000021e 	bne	r2,zero,823559c <tcp_reass+0x2e0>
      return (0);
 8235594:	0005883a 	mov	r2,zero
 8235598:	00004706 	br	82356b8 <tcp_reass+0x3fc>
   ti = tp->seg_next;
 823559c:	e0bffd17 	ldw	r2,-12(fp)
 82355a0:	10800017 	ldw	r2,0(r2)
 82355a4:	e0bffe15 	stw	r2,-8(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 82355a8:	e0fffe17 	ldw	r3,-8(fp)
 82355ac:	e0bffd17 	ldw	r2,-12(fp)
 82355b0:	18800526 	beq	r3,r2,82355c8 <tcp_reass+0x30c>
 82355b4:	e0bffe17 	ldw	r2,-8(fp)
 82355b8:	10c00617 	ldw	r3,24(r2)
 82355bc:	e0bffd17 	ldw	r2,-12(fp)
 82355c0:	10801617 	ldw	r2,88(r2)
 82355c4:	18800226 	beq	r3,r2,82355d0 <tcp_reass+0x314>
      return (0);
 82355c8:	0005883a 	mov	r2,zero
 82355cc:	00003a06 	br	82356b8 <tcp_reass+0x3fc>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 82355d0:	e0bffd17 	ldw	r2,-12(fp)
 82355d4:	10800217 	ldw	r2,8(r2)
 82355d8:	108000d8 	cmpnei	r2,r2,3
 82355dc:	1000061e 	bne	r2,zero,82355f8 <tcp_reass+0x33c>
 82355e0:	e0bffe17 	ldw	r2,-8(fp)
 82355e4:	1080028b 	ldhu	r2,10(r2)
 82355e8:	10bfffcc 	andi	r2,r2,65535
 82355ec:	10000226 	beq	r2,zero,82355f8 <tcp_reass+0x33c>
      return (0);
 82355f0:	0005883a 	mov	r2,zero
 82355f4:	00003006 	br	82356b8 <tcp_reass+0x3fc>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 82355f8:	e0bffd17 	ldw	r2,-12(fp)
 82355fc:	10c01617 	ldw	r3,88(r2)
 8235600:	e0bffe17 	ldw	r2,-8(fp)
 8235604:	1080028b 	ldhu	r2,10(r2)
 8235608:	10bfffcc 	andi	r2,r2,65535
 823560c:	1887883a 	add	r3,r3,r2
 8235610:	e0bffd17 	ldw	r2,-12(fp)
 8235614:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 8235618:	e0bffe17 	ldw	r2,-8(fp)
 823561c:	10800843 	ldbu	r2,33(r2)
 8235620:	10803fcc 	andi	r2,r2,255
 8235624:	1080004c 	andi	r2,r2,1
 8235628:	e0bffc15 	stw	r2,-16(fp)
      remque(ti);
 823562c:	e13ffe17 	ldw	r4,-8(fp)
 8235630:	822e96c0 	call	822e96c <remque>
      m = dtom(ti);
 8235634:	e13ffe17 	ldw	r4,-8(fp)
 8235638:	822e8d00 	call	822e8d0 <dtom>
 823563c:	e0bffb15 	stw	r2,-20(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 8235640:	e0bffe17 	ldw	r2,-8(fp)
 8235644:	10800017 	ldw	r2,0(r2)
 8235648:	e0bffe15 	stw	r2,-8(fp)
      if (so->so_state & SS_CANTRCVMORE)
 823564c:	e0bff817 	ldw	r2,-32(fp)
 8235650:	1080088b 	ldhu	r2,34(r2)
 8235654:	10bfffcc 	andi	r2,r2,65535
 8235658:	1080080c 	andi	r2,r2,32
 823565c:	10000326 	beq	r2,zero,823566c <tcp_reass+0x3b0>
         m_freem (m);
 8235660:	e13ffb17 	ldw	r4,-20(fp)
 8235664:	822e3840 	call	822e384 <m_freem>
 8235668:	00000506 	br	8235680 <tcp_reass+0x3c4>
      else
         sbappend (&so->so_rcv, m);
 823566c:	e0bff817 	ldw	r2,-32(fp)
 8235670:	10800a04 	addi	r2,r2,40
 8235674:	e17ffb17 	ldw	r5,-20(fp)
 8235678:	1009883a 	mov	r4,r2
 823567c:	82341400 	call	8234140 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 8235680:	e0fffe17 	ldw	r3,-8(fp)
 8235684:	e0bffd17 	ldw	r2,-12(fp)
 8235688:	18800526 	beq	r3,r2,82356a0 <tcp_reass+0x3e4>
 823568c:	e0bffe17 	ldw	r2,-8(fp)
 8235690:	10c00617 	ldw	r3,24(r2)
 8235694:	e0bffd17 	ldw	r2,-12(fp)
 8235698:	10801617 	ldw	r2,88(r2)
 823569c:	18bfd626 	beq	r3,r2,82355f8 <tcp_reass+0x33c>
      sorwakeup(so);
 82356a0:	e0bff817 	ldw	r2,-32(fp)
 82356a4:	10800a04 	addi	r2,r2,40
 82356a8:	100b883a 	mov	r5,r2
 82356ac:	e13ff817 	ldw	r4,-32(fp)
 82356b0:	8233f900 	call	8233f90 <sbwakeup>
   return (flags);
 82356b4:	e0bffc17 	ldw	r2,-16(fp)
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
   return (0);
}
 82356b8:	e037883a 	mov	sp,fp
 82356bc:	dfc00117 	ldw	ra,4(sp)
 82356c0:	df000017 	ldw	fp,0(sp)
 82356c4:	dec00204 	addi	sp,sp,8
 82356c8:	f800283a 	ret

082356cc <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 82356cc:	deffdf04 	addi	sp,sp,-132
 82356d0:	dfc02015 	stw	ra,128(sp)
 82356d4:	df001f15 	stw	fp,124(sp)
 82356d8:	df001f04 	addi	fp,sp,124
 82356dc:	e13ffe15 	stw	r4,-8(fp)
 82356e0:	e17fff15 	stw	r5,-4(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 82356e4:	e03fe515 	stw	zero,-108(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 82356e8:	e03fe615 	stw	zero,-104(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 82356ec:	e03fe815 	stw	zero,-96(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 82356f0:	e03feb15 	stw	zero,-84(fp)
   int   dropsocket  =  0;
 82356f4:	e03fec15 	stw	zero,-80(fp)
   long  iss   =  0;
 82356f8:	e03fed15 	stw	zero,-76(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 82356fc:	008209b4 	movhi	r2,2086
 8235700:	10b8aa04 	addi	r2,r2,-7512
 8235704:	10801917 	ldw	r2,100(r2)
 8235708:	10c00044 	addi	r3,r2,1
 823570c:	008209b4 	movhi	r2,2086
 8235710:	10b8aa04 	addi	r2,r2,-7512
 8235714:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 8235718:	008209b4 	movhi	r2,2086
 823571c:	10b87c04 	addi	r2,r2,-7696
 8235720:	10800917 	ldw	r2,36(r2)
 8235724:	10c00044 	addi	r3,r2,1
 8235728:	008209b4 	movhi	r2,2086
 823572c:	10b87c04 	addi	r2,r2,-7696
 8235730:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 8235734:	e0bffe17 	ldw	r2,-8(fp)
 8235738:	10800317 	ldw	r2,12(r2)
 823573c:	e0bfe315 	stw	r2,-116(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 8235740:	e0bfe317 	ldw	r2,-116(fp)
 8235744:	10800003 	ldbu	r2,0(r2)
 8235748:	10803fcc 	andi	r2,r2,255
 823574c:	108011b0 	cmpltui	r2,r2,70
 8235750:	1000061e 	bne	r2,zero,823576c <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 8235754:	e17ffe17 	ldw	r5,-8(fp)
 8235758:	e13fe317 	ldw	r4,-116(fp)
 823575c:	822f3080 	call	822f308 <np_stripoptions>
         pip = mtod(m, struct ip *);
 8235760:	e0bffe17 	ldw	r2,-8(fp)
 8235764:	10800317 	ldw	r2,12(r2)
 8235768:	e0bfe315 	stw	r2,-116(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 823576c:	e0bffe17 	ldw	r2,-8(fp)
 8235770:	10800217 	ldw	r2,8(r2)
 8235774:	10800a28 	cmpgeui	r2,r2,40
 8235778:	1000081e 	bne	r2,zero,823579c <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 823577c:	008209b4 	movhi	r2,2086
 8235780:	10b8aa04 	addi	r2,r2,-7512
 8235784:	10801e17 	ldw	r2,120(r2)
 8235788:	10c00044 	addi	r3,r2,1
 823578c:	008209b4 	movhi	r2,2086
 8235790:	10b8aa04 	addi	r2,r2,-7512
 8235794:	10c01e15 	stw	r3,120(r2)
         return;
 8235798:	00089306 	br	82379e8 <tcp_input+0x231c>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 823579c:	e0bfe317 	ldw	r2,-116(fp)
 82357a0:	1080008b 	ldhu	r2,2(r2)
 82357a4:	10bfffcc 	andi	r2,r2,65535
 82357a8:	e0bff115 	stw	r2,-60(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 82357ac:	e0bffe17 	ldw	r2,-8(fp)
 82357b0:	10800317 	ldw	r2,12(r2)
 82357b4:	e0bff215 	stw	r2,-56(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 82357b8:	e0bffe17 	ldw	r2,-8(fp)
 82357bc:	10800117 	ldw	r2,4(r2)
 82357c0:	10800117 	ldw	r2,4(r2)
 82357c4:	e0fff217 	ldw	r3,-56(fp)
 82357c8:	1880032e 	bgeu	r3,r2,82357d8 <tcp_input+0x10c>
      {
         panic("tcp_input");
 82357cc:	01020974 	movhi	r4,2085
 82357d0:	2102b904 	addi	r4,r4,2788
 82357d4:	82289940 	call	8228994 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 82357d8:	e0bff217 	ldw	r2,-56(fp)
 82357dc:	10800803 	ldbu	r2,32(r2)
 82357e0:	10803fcc 	andi	r2,r2,255
 82357e4:	1004d13a 	srli	r2,r2,4
 82357e8:	10803fcc 	andi	r2,r2,255
 82357ec:	1085883a 	add	r2,r2,r2
 82357f0:	1085883a 	add	r2,r2,r2
 82357f4:	e0bff315 	stw	r2,-52(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 82357f8:	e0bff317 	ldw	r2,-52(fp)
 82357fc:	10800530 	cmpltui	r2,r2,20
 8235800:	1000031e 	bne	r2,zero,8235810 <tcp_input+0x144>
 8235804:	e0bff317 	ldw	r2,-52(fp)
 8235808:	e0fff117 	ldw	r3,-60(fp)
 823580c:	1880110e 	bge	r3,r2,8235854 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 8235810:	008209b4 	movhi	r2,2086
 8235814:	10b8aa04 	addi	r2,r2,-7512
 8235818:	10801d17 	ldw	r2,116(r2)
 823581c:	10c00044 	addi	r3,r2,1
 8235820:	008209b4 	movhi	r2,2086
 8235824:	10b8aa04 	addi	r2,r2,-7512
 8235828:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 823582c:	008209b4 	movhi	r2,2086
 8235830:	10b87c04 	addi	r2,r2,-7696
 8235834:	10800d17 	ldw	r2,52(r2)
 8235838:	10c00044 	addi	r3,r2,1
 823583c:	008209b4 	movhi	r2,2086
 8235840:	10b87c04 	addi	r2,r2,-7696
 8235844:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 8235848:	00805784 	movi	r2,350
 823584c:	d0a0b215 	stw	r2,-32056(gp)
 8235850:	00085006 	br	8237994 <tcp_input+0x22c8>
   }
   tlen -= (int)off;
 8235854:	e0fff117 	ldw	r3,-60(fp)
 8235858:	e0bff317 	ldw	r2,-52(fp)
 823585c:	1885c83a 	sub	r2,r3,r2
 8235860:	e0bff115 	stw	r2,-60(fp)
   ti->ti_len = (u_short)tlen;
 8235864:	e0bff117 	ldw	r2,-60(fp)
 8235868:	1007883a 	mov	r3,r2
 823586c:	e0bff217 	ldw	r2,-56(fp)
 8235870:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 8235874:	e0bff317 	ldw	r2,-52(fp)
 8235878:	10800570 	cmpltui	r2,r2,21
 823587c:	1000331e 	bne	r2,zero,823594c <tcp_input+0x280>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 8235880:	e0bff317 	ldw	r2,-52(fp)
 8235884:	10bffb04 	addi	r2,r2,-20
 8235888:	e0bff415 	stw	r2,-48(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 823588c:	e17ff417 	ldw	r5,-48(fp)
 8235890:	01000044 	movi	r4,1
 8235894:	822e0f40 	call	822e0f4 <m_getnbuf>
 8235898:	e0bfe515 	stw	r2,-108(fp)
      if (om == 0)
 823589c:	e0bfe517 	ldw	r2,-108(fp)
 82358a0:	1000031e 	bne	r2,zero,82358b0 <tcp_input+0x1e4>
         GOTO_DROP;
 82358a4:	00805a84 	movi	r2,362
 82358a8:	d0a0b215 	stw	r2,-32056(gp)
 82358ac:	00083906 	br	8237994 <tcp_input+0x22c8>
      om->m_len = olen;       /* set mbuf length */
 82358b0:	e0fff417 	ldw	r3,-48(fp)
 82358b4:	e0bfe517 	ldw	r2,-108(fp)
 82358b8:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 82358bc:	e0bffe17 	ldw	r2,-8(fp)
 82358c0:	10800117 	ldw	r2,4(r2)
 82358c4:	1080080b 	ldhu	r2,32(r2)
 82358c8:	10ffffcc 	andi	r3,r2,65535
 82358cc:	00b76194 	movui	r2,56710
 82358d0:	1880051e 	bne	r3,r2,82358e8 <tcp_input+0x21c>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 82358d4:	e0bffe17 	ldw	r2,-8(fp)
 82358d8:	10800317 	ldw	r2,12(r2)
 82358dc:	10800504 	addi	r2,r2,20
 82358e0:	e0bfee15 	stw	r2,-72(fp)
 82358e4:	00000406 	br	82358f8 <tcp_input+0x22c>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 82358e8:	e0bffe17 	ldw	r2,-8(fp)
 82358ec:	10800317 	ldw	r2,12(r2)
 82358f0:	10800a04 	addi	r2,r2,40
 82358f4:	e0bfee15 	stw	r2,-72(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 82358f8:	e0bfe517 	ldw	r2,-108(fp)
 82358fc:	10800317 	ldw	r2,12(r2)
 8235900:	e0fff417 	ldw	r3,-48(fp)
 8235904:	180d883a 	mov	r6,r3
 8235908:	e17fee17 	ldw	r5,-72(fp)
 823590c:	1009883a 	mov	r4,r2
 8235910:	8202c5c0 	call	8202c5c <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 8235914:	e0bffe17 	ldw	r2,-8(fp)
 8235918:	10c00317 	ldw	r3,12(r2)
 823591c:	e0bfe517 	ldw	r2,-108(fp)
 8235920:	10800217 	ldw	r2,8(r2)
 8235924:	1887883a 	add	r3,r3,r2
 8235928:	e0bffe17 	ldw	r2,-8(fp)
 823592c:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 8235930:	e0bffe17 	ldw	r2,-8(fp)
 8235934:	10c00217 	ldw	r3,8(r2)
 8235938:	e0bfe517 	ldw	r2,-108(fp)
 823593c:	10800217 	ldw	r2,8(r2)
 8235940:	1887c83a 	sub	r3,r3,r2
 8235944:	e0bffe17 	ldw	r2,-8(fp)
 8235948:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 823594c:	e0bff217 	ldw	r2,-56(fp)
 8235950:	10800843 	ldbu	r2,33(r2)
 8235954:	10803fcc 	andi	r2,r2,255
 8235958:	e0bfe715 	stw	r2,-100(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 823595c:	e0bff217 	ldw	r2,-56(fp)
 8235960:	10800617 	ldw	r2,24(r2)
 8235964:	1006d63a 	srli	r3,r2,24
 8235968:	e0bff217 	ldw	r2,-56(fp)
 823596c:	10800617 	ldw	r2,24(r2)
 8235970:	1004d23a 	srli	r2,r2,8
 8235974:	10bfc00c 	andi	r2,r2,65280
 8235978:	1886b03a 	or	r3,r3,r2
 823597c:	e0bff217 	ldw	r2,-56(fp)
 8235980:	10800617 	ldw	r2,24(r2)
 8235984:	10bfc00c 	andi	r2,r2,65280
 8235988:	1004923a 	slli	r2,r2,8
 823598c:	1886b03a 	or	r3,r3,r2
 8235990:	e0bff217 	ldw	r2,-56(fp)
 8235994:	10800617 	ldw	r2,24(r2)
 8235998:	1004963a 	slli	r2,r2,24
 823599c:	1886b03a 	or	r3,r3,r2
 82359a0:	e0bff217 	ldw	r2,-56(fp)
 82359a4:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 82359a8:	e0bff217 	ldw	r2,-56(fp)
 82359ac:	10800717 	ldw	r2,28(r2)
 82359b0:	1006d63a 	srli	r3,r2,24
 82359b4:	e0bff217 	ldw	r2,-56(fp)
 82359b8:	10800717 	ldw	r2,28(r2)
 82359bc:	1004d23a 	srli	r2,r2,8
 82359c0:	10bfc00c 	andi	r2,r2,65280
 82359c4:	1886b03a 	or	r3,r3,r2
 82359c8:	e0bff217 	ldw	r2,-56(fp)
 82359cc:	10800717 	ldw	r2,28(r2)
 82359d0:	10bfc00c 	andi	r2,r2,65280
 82359d4:	1004923a 	slli	r2,r2,8
 82359d8:	1886b03a 	or	r3,r3,r2
 82359dc:	e0bff217 	ldw	r2,-56(fp)
 82359e0:	10800717 	ldw	r2,28(r2)
 82359e4:	1004963a 	slli	r2,r2,24
 82359e8:	1886b03a 	or	r3,r3,r2
 82359ec:	e0bff217 	ldw	r2,-56(fp)
 82359f0:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 82359f4:	e0bff217 	ldw	r2,-56(fp)
 82359f8:	1080098b 	ldhu	r2,38(r2)
 82359fc:	10bfffcc 	andi	r2,r2,65535
 8235a00:	1004d23a 	srli	r2,r2,8
 8235a04:	1007883a 	mov	r3,r2
 8235a08:	e0bff217 	ldw	r2,-56(fp)
 8235a0c:	1080098b 	ldhu	r2,38(r2)
 8235a10:	10bfffcc 	andi	r2,r2,65535
 8235a14:	1004923a 	slli	r2,r2,8
 8235a18:	1884b03a 	or	r2,r3,r2
 8235a1c:	1007883a 	mov	r3,r2
 8235a20:	e0bff217 	ldw	r2,-56(fp)
 8235a24:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 8235a28:	e0bffe17 	ldw	r2,-8(fp)
 8235a2c:	10800117 	ldw	r2,4(r2)
 8235a30:	1080080b 	ldhu	r2,32(r2)
 8235a34:	10bfffcc 	andi	r2,r2,65535
 8235a38:	10800220 	cmpeqi	r2,r2,8
 8235a3c:	10002226 	beq	r2,zero,8235ac8 <tcp_input+0x3fc>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 8235a40:	e0bffe17 	ldw	r2,-8(fp)
 8235a44:	10800317 	ldw	r2,12(r2)
 8235a48:	10c00a04 	addi	r3,r2,40
 8235a4c:	e0bffe17 	ldw	r2,-8(fp)
 8235a50:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 8235a54:	e0bffe17 	ldw	r2,-8(fp)
 8235a58:	10800217 	ldw	r2,8(r2)
 8235a5c:	10fff604 	addi	r3,r2,-40
 8235a60:	e0bffe17 	ldw	r2,-8(fp)
 8235a64:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235a68:	e0bff217 	ldw	r2,-56(fp)
 8235a6c:	11000317 	ldw	r4,12(r2)
 8235a70:	e0bff217 	ldw	r2,-56(fp)
 8235a74:	1080050b 	ldhu	r2,20(r2)
 8235a78:	117fffcc 	andi	r5,r2,65535
 8235a7c:	e0bff217 	ldw	r2,-56(fp)
 8235a80:	11800417 	ldw	r6,16(r2)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 8235a84:	e0bff217 	ldw	r2,-56(fp)
 8235a88:	1080058b 	ldhu	r2,22(r2)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235a8c:	10bfffcc 	andi	r2,r2,65535
 8235a90:	00c00044 	movi	r3,1
 8235a94:	d8c00115 	stw	r3,4(sp)
 8235a98:	d8800015 	stw	r2,0(sp)
 8235a9c:	300f883a 	mov	r7,r6
 8235aa0:	280d883a 	mov	r6,r5
 8235aa4:	200b883a 	mov	r5,r4
 8235aa8:	010209b4 	movhi	r4,2086
 8235aac:	21389f04 	addi	r4,r4,-7556
 8235ab0:	82481b80 	call	82481b8 <in_pcblookup>
 8235ab4:	e0bfe415 	stw	r2,-112(fp)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
 8235ab8:	0001883a 	nop
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 8235abc:	e0bfe417 	ldw	r2,-112(fp)
 8235ac0:	1000061e 	bne	r2,zero,8235adc <tcp_input+0x410>
 8235ac4:	00000206 	br	8235ad0 <tcp_input+0x404>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 8235ac8:	822d2e00 	call	822d2e0 <dtrap>
      return;
 8235acc:	0007c606 	br	82379e8 <tcp_input+0x231c>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 8235ad0:	00806b04 	movi	r2,428
 8235ad4:	d0a0b215 	stw	r2,-32056(gp)
 8235ad8:	00076d06 	br	8237890 <tcp_input+0x21c4>
   tp = intotcpcb (inp);
 8235adc:	e0bfe417 	ldw	r2,-112(fp)
 8235ae0:	10800917 	ldw	r2,36(r2)
 8235ae4:	e0bfe615 	stw	r2,-104(fp)
   if (tp == 0)
 8235ae8:	e0bfe617 	ldw	r2,-104(fp)
 8235aec:	1000031e 	bne	r2,zero,8235afc <tcp_input+0x430>
      GOTO_DROPWITHRESET;
 8235af0:	00806bc4 	movi	r2,431
 8235af4:	d0a0b215 	stw	r2,-32056(gp)
 8235af8:	00076506 	br	8237890 <tcp_input+0x21c4>
   if (tp->t_state == TCPS_CLOSED)
 8235afc:	e0bfe617 	ldw	r2,-104(fp)
 8235b00:	10800217 	ldw	r2,8(r2)
 8235b04:	1000031e 	bne	r2,zero,8235b14 <tcp_input+0x448>
      GOTO_DROP;
 8235b08:	00806c44 	movi	r2,433
 8235b0c:	d0a0b215 	stw	r2,-32056(gp)
 8235b10:	0007a006 	br	8237994 <tcp_input+0x22c8>
   so = inp->inp_socket;
 8235b14:	e0bfe417 	ldw	r2,-112(fp)
 8235b18:	10800817 	ldw	r2,32(r2)
 8235b1c:	e0bfe815 	stw	r2,-96(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 8235b20:	e0bff217 	ldw	r2,-56(fp)
 8235b24:	1080088b 	ldhu	r2,34(r2)
 8235b28:	10bfffcc 	andi	r2,r2,65535
 8235b2c:	1004d23a 	srli	r2,r2,8
 8235b30:	10bfffcc 	andi	r2,r2,65535
 8235b34:	10c03fcc 	andi	r3,r2,255
 8235b38:	e0bff217 	ldw	r2,-56(fp)
 8235b3c:	1080088b 	ldhu	r2,34(r2)
 8235b40:	10bfffcc 	andi	r2,r2,65535
 8235b44:	1004923a 	slli	r2,r2,8
 8235b48:	10bfffcc 	andi	r2,r2,65535
 8235b4c:	1884b03a 	or	r2,r3,r2
 8235b50:	e0bff515 	stw	r2,-44(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 8235b54:	e0bfe817 	ldw	r2,-96(fp)
 8235b58:	10800417 	ldw	r2,16(r2)
 8235b5c:	1080008c 	andi	r2,r2,2
 8235b60:	10002c26 	beq	r2,zero,8235c14 <tcp_input+0x548>
   {
      so = sonewconn(so);
 8235b64:	e13fe817 	ldw	r4,-96(fp)
 8235b68:	8233a840 	call	8233a84 <sonewconn>
 8235b6c:	e0bfe815 	stw	r2,-96(fp)
      if (so == 0)
 8235b70:	e0bfe817 	ldw	r2,-96(fp)
 8235b74:	1000031e 	bne	r2,zero,8235b84 <tcp_input+0x4b8>
         GOTO_DROP;
 8235b78:	00807344 	movi	r2,461
 8235b7c:	d0a0b215 	stw	r2,-32056(gp)
 8235b80:	00078406 	br	8237994 <tcp_input+0x22c8>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 8235b84:	e0bfec17 	ldw	r2,-80(fp)
 8235b88:	10800044 	addi	r2,r2,1
 8235b8c:	e0bfec15 	stw	r2,-80(fp)

      inp = (struct inpcb *)so->so_pcb;
 8235b90:	e0bfe817 	ldw	r2,-96(fp)
 8235b94:	10800117 	ldw	r2,4(r2)
 8235b98:	e0bfe415 	stw	r2,-112(fp)
      inp->ifp = ifp;      /* save iface to peer */
 8235b9c:	e0bfe417 	ldw	r2,-112(fp)
 8235ba0:	e0ffff17 	ldw	r3,-4(fp)
 8235ba4:	10c00a15 	stw	r3,40(r2)

      switch(so->so_domain)
 8235ba8:	e0bfe817 	ldw	r2,-96(fp)
 8235bac:	10800517 	ldw	r2,20(r2)
 8235bb0:	108000a0 	cmpeqi	r2,r2,2
 8235bb4:	10000d26 	beq	r2,zero,8235bec <tcp_input+0x520>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 8235bb8:	e0bfe417 	ldw	r2,-112(fp)
 8235bbc:	e0fff217 	ldw	r3,-56(fp)
 8235bc0:	18c00417 	ldw	r3,16(r3)
 8235bc4:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8235bc8:	e0bfff17 	ldw	r2,-4(fp)
 8235bcc:	10c00917 	ldw	r3,36(r2)
 8235bd0:	e0bfff17 	ldw	r2,-4(fp)
 8235bd4:	10800817 	ldw	r2,32(r2)
 8235bd8:	10800a04 	addi	r2,r2,40
 8235bdc:	1887c83a 	sub	r3,r3,r2
 8235be0:	e0bfe417 	ldw	r2,-112(fp)
 8235be4:	10c00615 	stw	r3,24(r2)
#endif   /* IP_PMTU */
         break;
 8235be8:	0001883a 	nop
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 8235bec:	e0bff217 	ldw	r2,-56(fp)
 8235bf0:	10c0058b 	ldhu	r3,22(r2)
 8235bf4:	e0bfe417 	ldw	r2,-112(fp)
 8235bf8:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 8235bfc:	e0bfe417 	ldw	r2,-112(fp)
 8235c00:	10800917 	ldw	r2,36(r2)
 8235c04:	e0bfe615 	stw	r2,-104(fp)
      tp->t_state = TCPS_LISTEN;
 8235c08:	e0bfe617 	ldw	r2,-104(fp)
 8235c0c:	00c00044 	movi	r3,1
 8235c10:	10c00215 	stw	r3,8(r2)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 8235c14:	e0bfe617 	ldw	r2,-104(fp)
 8235c18:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 8235c1c:	d0e03e17 	ldw	r3,-32520(gp)
 8235c20:	e0bfe617 	ldw	r2,-104(fp)
 8235c24:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 8235c28:	e0bfe517 	ldw	r2,-108(fp)
 8235c2c:	10000926 	beq	r2,zero,8235c54 <tcp_input+0x588>
 8235c30:	e0bfe617 	ldw	r2,-104(fp)
 8235c34:	10800217 	ldw	r2,8(r2)
 8235c38:	10800060 	cmpeqi	r2,r2,1
 8235c3c:	1000051e 	bne	r2,zero,8235c54 <tcp_input+0x588>
   {
      tcp_dooptions(tp, om, ti);
 8235c40:	e1bff217 	ldw	r6,-56(fp)
 8235c44:	e17fe517 	ldw	r5,-108(fp)
 8235c48:	e13fe617 	ldw	r4,-104(fp)
 8235c4c:	82379fc0 	call	82379fc <tcp_dooptions>
      om = 0;
 8235c50:	e03fe515 	stw	zero,-108(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 8235c54:	e0bff217 	ldw	r2,-56(fp)
 8235c58:	10c00717 	ldw	r3,28(r2)
 8235c5c:	e0bfe617 	ldw	r2,-104(fp)
 8235c60:	10800e17 	ldw	r2,56(r2)
 8235c64:	1885c83a 	sub	r2,r3,r2
 8235c68:	e0bff615 	stw	r2,-40(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 8235c6c:	e0bfe817 	ldw	r2,-96(fp)
 8235c70:	10800b17 	ldw	r2,44(r2)
 8235c74:	1007883a 	mov	r3,r2
 8235c78:	e0bfe817 	ldw	r2,-96(fp)
 8235c7c:	10800a17 	ldw	r2,40(r2)
 8235c80:	1885c83a 	sub	r2,r3,r2
 8235c84:	10000616 	blt	r2,zero,8235ca0 <tcp_input+0x5d4>
 8235c88:	e0bfe817 	ldw	r2,-96(fp)
 8235c8c:	10c00b17 	ldw	r3,44(r2)
 8235c90:	e0bfe817 	ldw	r2,-96(fp)
 8235c94:	10800a17 	ldw	r2,40(r2)
 8235c98:	1885c83a 	sub	r2,r3,r2
 8235c9c:	00000106 	br	8235ca4 <tcp_input+0x5d8>
 8235ca0:	0005883a 	mov	r2,zero
 8235ca4:	e0bfef15 	stw	r2,-68(fp)
      if (win < 0)
 8235ca8:	e0bfef17 	ldw	r2,-68(fp)
 8235cac:	1000010e 	bge	r2,zero,8235cb4 <tcp_input+0x5e8>
         win = 0;
 8235cb0:	e03fef15 	stw	zero,-68(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 8235cb4:	e0bfe617 	ldw	r2,-104(fp)
 8235cb8:	10c01917 	ldw	r3,100(r2)
 8235cbc:	e0bfe617 	ldw	r2,-104(fp)
 8235cc0:	10801617 	ldw	r2,88(r2)
 8235cc4:	1885c83a 	sub	r2,r3,r2
 8235cc8:	e0ffef17 	ldw	r3,-68(fp)
 8235ccc:	10c0012e 	bgeu	r2,r3,8235cd4 <tcp_input+0x608>
 8235cd0:	1805883a 	mov	r2,r3
 8235cd4:	e0ffe617 	ldw	r3,-104(fp)
 8235cd8:	18801515 	stw	r2,84(r3)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235cdc:	e0bfe617 	ldw	r2,-104(fp)
 8235ce0:	10800217 	ldw	r2,8(r2)
 8235ce4:	10800118 	cmpnei	r2,r2,4
 8235ce8:	1001021e 	bne	r2,zero,82360f4 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235cec:	e0bfe717 	ldw	r2,-100(fp)
 8235cf0:	10800dcc 	andi	r2,r2,55
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235cf4:	10800418 	cmpnei	r2,r2,16
 8235cf8:	1000fe1e 	bne	r2,zero,82360f4 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
 8235cfc:	e0bff217 	ldw	r2,-56(fp)
 8235d00:	10c00617 	ldw	r3,24(r2)
 8235d04:	e0bfe617 	ldw	r2,-104(fp)
 8235d08:	10801617 	ldw	r2,88(r2)
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235d0c:	1880f91e 	bne	r3,r2,82360f4 <tcp_input+0xa28>
       (ti->ti_seq == tp->rcv_nxt) &&
 8235d10:	e0bff517 	ldw	r2,-44(fp)
 8235d14:	1000f726 	beq	r2,zero,82360f4 <tcp_input+0xa28>
       (rx_win && rx_win == tp->snd_wnd) &&
 8235d18:	e0bfe617 	ldw	r2,-104(fp)
 8235d1c:	10c01417 	ldw	r3,80(r2)
 8235d20:	e0bff517 	ldw	r2,-44(fp)
 8235d24:	1880f31e 	bne	r3,r2,82360f4 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
 8235d28:	e0bfe617 	ldw	r2,-104(fp)
 8235d2c:	10c00f17 	ldw	r3,60(r2)
 8235d30:	e0bfe617 	ldw	r2,-104(fp)
 8235d34:	10801a17 	ldw	r2,104(r2)
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
 8235d38:	1880ee1e 	bne	r3,r2,82360f4 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 8235d3c:	e0bff217 	ldw	r2,-56(fp)
 8235d40:	1080028b 	ldhu	r2,10(r2)
 8235d44:	10bfffcc 	andi	r2,r2,65535
 8235d48:	1000611e 	bne	r2,zero,8235ed0 <tcp_input+0x804>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8235d4c:	e0bff217 	ldw	r2,-56(fp)
 8235d50:	10c00717 	ldw	r3,28(r2)
 8235d54:	e0bfe617 	ldw	r2,-104(fp)
 8235d58:	10800e17 	ldw	r2,56(r2)
 8235d5c:	1885c83a 	sub	r2,r3,r2
 8235d60:	0080e40e 	bge	zero,r2,82360f4 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8235d64:	e0bff217 	ldw	r2,-56(fp)
 8235d68:	10c00717 	ldw	r3,28(r2)
 8235d6c:	e0bfe617 	ldw	r2,-104(fp)
 8235d70:	10801a17 	ldw	r2,104(r2)
 8235d74:	1885c83a 	sub	r2,r3,r2
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8235d78:	0080de16 	blt	zero,r2,82360f4 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
             tp->snd_cwnd >= tp->snd_wnd) 
 8235d7c:	e0bfe617 	ldw	r2,-104(fp)
 8235d80:	10c01b17 	ldw	r3,108(r2)
 8235d84:	e0bfe617 	ldw	r2,-104(fp)
 8235d88:	10801417 	ldw	r2,80(r2)
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8235d8c:	1880d936 	bltu	r3,r2,82360f4 <tcp_input+0xa28>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 8235d90:	008209b4 	movhi	r2,2086
 8235d94:	10b8aa04 	addi	r2,r2,-7512
 8235d98:	10803517 	ldw	r2,212(r2)
 8235d9c:	10c00044 	addi	r3,r2,1
 8235da0:	008209b4 	movhi	r2,2086
 8235da4:	10b8aa04 	addi	r2,r2,-7512
 8235da8:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 8235dac:	e0bfe617 	ldw	r2,-104(fp)
 8235db0:	10801e17 	ldw	r2,120(r2)
 8235db4:	10000826 	beq	r2,zero,8235dd8 <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8235db8:	e0bff217 	ldw	r2,-56(fp)
 8235dbc:	10c00717 	ldw	r3,28(r2)
 8235dc0:	e0bfe617 	ldw	r2,-104(fp)
 8235dc4:	10801f17 	ldw	r2,124(r2)
 8235dc8:	1885c83a 	sub	r2,r3,r2
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
            if (tp->t_rttick && 
 8235dcc:	0080020e 	bge	zero,r2,8235dd8 <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 8235dd0:	e13fe617 	ldw	r4,-104(fp)
 8235dd4:	8237cb00 	call	8237cb0 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 8235dd8:	008209b4 	movhi	r2,2086
 8235ddc:	10b8aa04 	addi	r2,r2,-7512
 8235de0:	10802b17 	ldw	r2,172(r2)
 8235de4:	10c00044 	addi	r3,r2,1
 8235de8:	008209b4 	movhi	r2,2086
 8235dec:	10b8aa04 	addi	r2,r2,-7512
 8235df0:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 8235df4:	008209b4 	movhi	r2,2086
 8235df8:	10b8aa04 	addi	r2,r2,-7512
 8235dfc:	10c02c17 	ldw	r3,176(r2)
 8235e00:	e0bff617 	ldw	r2,-40(fp)
 8235e04:	1887883a 	add	r3,r3,r2
 8235e08:	008209b4 	movhi	r2,2086
 8235e0c:	10b8aa04 	addi	r2,r2,-7512
 8235e10:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 8235e14:	e0bfe817 	ldw	r2,-96(fp)
 8235e18:	10801204 	addi	r2,r2,72
 8235e1c:	e17ff617 	ldw	r5,-40(fp)
 8235e20:	1009883a 	mov	r4,r2
 8235e24:	82346f80 	call	82346f8 <sbdrop>
            tp->snd_una = ti->ti_ack;
 8235e28:	e0bff217 	ldw	r2,-56(fp)
 8235e2c:	10c00717 	ldw	r3,28(r2)
 8235e30:	e0bfe617 	ldw	r2,-104(fp)
 8235e34:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 8235e38:	e13ffe17 	ldw	r4,-8(fp)
 8235e3c:	822e3840 	call	822e384 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 8235e40:	e0bfe617 	ldw	r2,-104(fp)
 8235e44:	10c00e17 	ldw	r3,56(r2)
 8235e48:	e0bfe617 	ldw	r2,-104(fp)
 8235e4c:	10801a17 	ldw	r2,104(r2)
 8235e50:	1880031e 	bne	r3,r2,8235e60 <tcp_input+0x794>
               tp->t_timer[TCPT_REXMT] = 0;
 8235e54:	e0bfe617 	ldw	r2,-104(fp)
 8235e58:	10000315 	stw	zero,12(r2)
 8235e5c:	00000706 	br	8235e7c <tcp_input+0x7b0>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 8235e60:	e0bfe617 	ldw	r2,-104(fp)
 8235e64:	10800417 	ldw	r2,16(r2)
 8235e68:	1000041e 	bne	r2,zero,8235e7c <tcp_input+0x7b0>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8235e6c:	e0bfe617 	ldw	r2,-104(fp)
 8235e70:	10c00817 	ldw	r3,32(r2)
 8235e74:	e0bfe617 	ldw	r2,-104(fp)
 8235e78:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8235e7c:	e0bfe817 	ldw	r2,-96(fp)
 8235e80:	1080190b 	ldhu	r2,100(r2)
 8235e84:	10bfffcc 	andi	r2,r2,65535
 8235e88:	1080030c 	andi	r2,r2,12
 8235e8c:	10000526 	beq	r2,zero,8235ea4 <tcp_input+0x7d8>
               sowwakeup(so);
 8235e90:	e0bfe817 	ldw	r2,-96(fp)
 8235e94:	10801204 	addi	r2,r2,72
 8235e98:	100b883a 	mov	r5,r2
 8235e9c:	e13fe817 	ldw	r4,-96(fp)
 8235ea0:	8233f900 	call	8233f90 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 8235ea4:	e0bfe817 	ldw	r2,-96(fp)
 8235ea8:	10801217 	ldw	r2,72(r2)
 8235eac:	e0ffe617 	ldw	r3,-104(fp)
 8235eb0:	19000f17 	ldw	r4,60(r3)
 8235eb4:	e0ffe617 	ldw	r3,-104(fp)
 8235eb8:	18c00e17 	ldw	r3,56(r3)
 8235ebc:	20c7c83a 	sub	r3,r4,r3
 8235ec0:	1886c02e 	bgeu	r3,r2,82379c4 <tcp_input+0x22f8>
               (void) tcp_output(tp);
 8235ec4:	e13fe617 	ldw	r4,-104(fp)
 8235ec8:	823804c0 	call	823804c <tcp_output>
            return;
 8235ecc:	0006bd06 	br	82379c4 <tcp_input+0x22f8>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8235ed0:	e0bff217 	ldw	r2,-56(fp)
 8235ed4:	10c00717 	ldw	r3,28(r2)
 8235ed8:	e0bfe617 	ldw	r2,-104(fp)
 8235edc:	10800e17 	ldw	r2,56(r2)
 8235ee0:	1880841e 	bne	r3,r2,82360f4 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
 8235ee4:	e0bfe617 	ldw	r2,-104(fp)
 8235ee8:	10c00017 	ldw	r3,0(r2)
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8235eec:	e0bfe617 	ldw	r2,-104(fp)
 8235ef0:	1880801e 	bne	r3,r2,82360f4 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
          ti->ti_len <= sbspace(&so->so_rcv))
 8235ef4:	e0bff217 	ldw	r2,-56(fp)
 8235ef8:	1080028b 	ldhu	r2,10(r2)
 8235efc:	10ffffcc 	andi	r3,r2,65535
 8235f00:	e0bfe817 	ldw	r2,-96(fp)
 8235f04:	10800b17 	ldw	r2,44(r2)
 8235f08:	1009883a 	mov	r4,r2
 8235f0c:	e0bfe817 	ldw	r2,-96(fp)
 8235f10:	10800a17 	ldw	r2,40(r2)
 8235f14:	2085c83a 	sub	r2,r4,r2
 8235f18:	10000616 	blt	r2,zero,8235f34 <tcp_input+0x868>
 8235f1c:	e0bfe817 	ldw	r2,-96(fp)
 8235f20:	11000b17 	ldw	r4,44(r2)
 8235f24:	e0bfe817 	ldw	r2,-96(fp)
 8235f28:	10800a17 	ldw	r2,40(r2)
 8235f2c:	2085c83a 	sub	r2,r4,r2
 8235f30:	00000106 	br	8235f38 <tcp_input+0x86c>
 8235f34:	0005883a 	mov	r2,zero
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
          tp->seg_next == (struct tcpiphdr *)tp &&
 8235f38:	10c06e36 	bltu	r2,r3,82360f4 <tcp_input+0xa28>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 8235f3c:	e0bfe617 	ldw	r2,-104(fp)
 8235f40:	10801517 	ldw	r2,84(r2)
 8235f44:	10000c1e 	bne	r2,zero,8235f78 <tcp_input+0x8ac>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 8235f48:	008209b4 	movhi	r2,2086
 8235f4c:	10b8aa04 	addi	r2,r2,-7512
 8235f50:	10802817 	ldw	r2,160(r2)
 8235f54:	10c00044 	addi	r3,r2,1
 8235f58:	008209b4 	movhi	r2,2086
 8235f5c:	10b8aa04 	addi	r2,r2,-7512
 8235f60:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 8235f64:	e13ffe17 	ldw	r4,-8(fp)
 8235f68:	822e3840 	call	822e384 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 8235f6c:	e13fe617 	ldw	r4,-104(fp)
 8235f70:	823804c0 	call	823804c <tcp_output>
            return;
 8235f74:	00069c06 	br	82379e8 <tcp_input+0x231c>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 8235f78:	008209b4 	movhi	r2,2086
 8235f7c:	10b8aa04 	addi	r2,r2,-7512
 8235f80:	10803617 	ldw	r2,216(r2)
 8235f84:	10c00044 	addi	r3,r2,1
 8235f88:	008209b4 	movhi	r2,2086
 8235f8c:	10b8aa04 	addi	r2,r2,-7512
 8235f90:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 8235f94:	e0bfe617 	ldw	r2,-104(fp)
 8235f98:	10c01617 	ldw	r3,88(r2)
 8235f9c:	e0bff217 	ldw	r2,-56(fp)
 8235fa0:	1080028b 	ldhu	r2,10(r2)
 8235fa4:	10bfffcc 	andi	r2,r2,65535
 8235fa8:	1887883a 	add	r3,r3,r2
 8235fac:	e0bfe617 	ldw	r2,-104(fp)
 8235fb0:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 8235fb4:	008209b4 	movhi	r2,2086
 8235fb8:	10b8aa04 	addi	r2,r2,-7512
 8235fbc:	10801a17 	ldw	r2,104(r2)
 8235fc0:	10c00044 	addi	r3,r2,1
 8235fc4:	008209b4 	movhi	r2,2086
 8235fc8:	10b8aa04 	addi	r2,r2,-7512
 8235fcc:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8235fd0:	008209b4 	movhi	r2,2086
 8235fd4:	10b8aa04 	addi	r2,r2,-7512
 8235fd8:	10c01b17 	ldw	r3,108(r2)
 8235fdc:	e0bff217 	ldw	r2,-56(fp)
 8235fe0:	1080028b 	ldhu	r2,10(r2)
 8235fe4:	10bfffcc 	andi	r2,r2,65535
 8235fe8:	1887883a 	add	r3,r3,r2
 8235fec:	008209b4 	movhi	r2,2086
 8235ff0:	10b8aa04 	addi	r2,r2,-7512
 8235ff4:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 8235ff8:	e0bfe817 	ldw	r2,-96(fp)
 8235ffc:	10800a04 	addi	r2,r2,40
 8236000:	e17ffe17 	ldw	r5,-8(fp)
 8236004:	1009883a 	mov	r4,r2
 8236008:	82341400 	call	8234140 <sbappend>
         sorwakeup(so);
 823600c:	e0bfe817 	ldw	r2,-96(fp)
 8236010:	10800a04 	addi	r2,r2,40
 8236014:	100b883a 	mov	r5,r2
 8236018:	e13fe817 	ldw	r4,-96(fp)
 823601c:	8233f900 	call	8233f90 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 8236020:	e0bfe717 	ldw	r2,-100(fp)
 8236024:	1080020c 	andi	r2,r2,8
 8236028:	10000726 	beq	r2,zero,8236048 <tcp_input+0x97c>
            tp->t_flags |= TF_ACKNOW;
 823602c:	e0bfe617 	ldw	r2,-104(fp)
 8236030:	10800b0b 	ldhu	r2,44(r2)
 8236034:	10800054 	ori	r2,r2,1
 8236038:	1007883a 	mov	r3,r2
 823603c:	e0bfe617 	ldw	r2,-104(fp)
 8236040:	10c00b0d 	sth	r3,44(r2)
 8236044:	00000606 	br	8236060 <tcp_input+0x994>
         else
            tp->t_flags |= TF_DELACK;
 8236048:	e0bfe617 	ldw	r2,-104(fp)
 823604c:	10800b0b 	ldhu	r2,44(r2)
 8236050:	10800094 	ori	r2,r2,2
 8236054:	1007883a 	mov	r3,r2
 8236058:	e0bfe617 	ldw	r2,-104(fp)
 823605c:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 8236060:	e0bfe617 	ldw	r2,-104(fp)
 8236064:	10c01517 	ldw	r3,84(r2)
 8236068:	e0bfe617 	ldw	r2,-104(fp)
 823606c:	11001617 	ldw	r4,88(r2)
 8236070:	e0bfe617 	ldw	r2,-104(fp)
 8236074:	10801917 	ldw	r2,100(r2)
 8236078:	2085c83a 	sub	r2,r4,r2
 823607c:	1885883a 	add	r2,r3,r2
 8236080:	e0bff715 	stw	r2,-36(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 8236084:	e0bfe617 	ldw	r2,-104(fp)
 8236088:	10800a0b 	ldhu	r2,40(r2)
 823608c:	10bfffcc 	andi	r2,r2,65535
 8236090:	1085883a 	add	r2,r2,r2
 8236094:	1007883a 	mov	r3,r2
 8236098:	e0bff717 	ldw	r2,-36(fp)
 823609c:	10c0050e 	bge	r2,r3,82360b4 <tcp_input+0x9e8>
             (tp->t_flags & TF_ACKNOW))
 82360a0:	e0bfe617 	ldw	r2,-104(fp)
 82360a4:	10800b0b 	ldhu	r2,44(r2)
 82360a8:	10bfffcc 	andi	r2,r2,65535
 82360ac:	1080004c 	andi	r2,r2,1
            tp->t_flags |= TF_DELACK;

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 82360b0:	10064626 	beq	r2,zero,82379cc <tcp_input+0x2300>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 82360b4:	e0bfe617 	ldw	r2,-104(fp)
 82360b8:	10800b0b 	ldhu	r2,44(r2)
 82360bc:	10800054 	ori	r2,r2,1
 82360c0:	1007883a 	mov	r3,r2
 82360c4:	e0bfe617 	ldw	r2,-104(fp)
 82360c8:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 82360cc:	e0bfe617 	ldw	r2,-104(fp)
 82360d0:	10c00b0b 	ldhu	r3,44(r2)
 82360d4:	00bfff44 	movi	r2,-3
 82360d8:	1884703a 	and	r2,r3,r2
 82360dc:	1007883a 	mov	r3,r2
 82360e0:	e0bfe617 	ldw	r2,-104(fp)
 82360e4:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 82360e8:	e13fe617 	ldw	r4,-104(fp)
 82360ec:	823804c0 	call	823804c <tcp_output>
         }

         return;
 82360f0:	00063606 	br	82379cc <tcp_input+0x2300>
      }
   }

   switch (tp->t_state) 
 82360f4:	e0bfe617 	ldw	r2,-104(fp)
 82360f8:	10800217 	ldw	r2,8(r2)
 82360fc:	10c00060 	cmpeqi	r3,r2,1
 8236100:	1800031e 	bne	r3,zero,8236110 <tcp_input+0xa44>
 8236104:	108000a0 	cmpeqi	r2,r2,2
 8236108:	1000aa1e 	bne	r2,zero,82363b4 <tcp_input+0xce8>
 823610c:	00017e06 	br	8236708 <tcp_input+0x103c>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 8236110:	e0bfe717 	ldw	r2,-100(fp)
 8236114:	1080010c 	andi	r2,r2,4
 8236118:	10000326 	beq	r2,zero,8236128 <tcp_input+0xa5c>
            GOTO_DROP;
 823611c:	0080bec4 	movi	r2,763
 8236120:	d0a0b215 	stw	r2,-32056(gp)
 8236124:	00061b06 	br	8237994 <tcp_input+0x22c8>
         if (tiflags & TH_ACK)
 8236128:	e0bfe717 	ldw	r2,-100(fp)
 823612c:	1080040c 	andi	r2,r2,16
 8236130:	10000326 	beq	r2,zero,8236140 <tcp_input+0xa74>
            GOTO_DROPWITHRESET;
 8236134:	0080bf44 	movi	r2,765
 8236138:	d0a0b215 	stw	r2,-32056(gp)
 823613c:	0005d406 	br	8237890 <tcp_input+0x21c4>
         if ((tiflags & TH_SYN) == 0)
 8236140:	e0bfe717 	ldw	r2,-100(fp)
 8236144:	1080008c 	andi	r2,r2,2
 8236148:	1000031e 	bne	r2,zero,8236158 <tcp_input+0xa8c>
            GOTO_DROP;
 823614c:	0080bfc4 	movi	r2,767
 8236150:	d0a0b215 	stw	r2,-32056(gp)
 8236154:	00060f06 	br	8237994 <tcp_input+0x22c8>
         if(in_broadcast(ti->ti_dst.s_addr))
 8236158:	e0bff217 	ldw	r2,-56(fp)
 823615c:	10800417 	ldw	r2,16(r2)
 8236160:	1009883a 	mov	r4,r2
 8236164:	822f2d00 	call	822f2d0 <in_broadcast>
 8236168:	10000326 	beq	r2,zero,8236178 <tcp_input+0xaac>
            GOTO_DROP;
 823616c:	0080c044 	movi	r2,769
 8236170:	d0a0b215 	stw	r2,-32056(gp)
 8236174:	00060706 	br	8237994 <tcp_input+0x22c8>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8236178:	01400404 	movi	r5,16
 823617c:	01000244 	movi	r4,9
 8236180:	822e0f40 	call	822e0f4 <m_getnbuf>
 8236184:	e0bffa15 	stw	r2,-24(fp)
         if (am == NULL)
 8236188:	e0bffa17 	ldw	r2,-24(fp)
 823618c:	1000031e 	bne	r2,zero,823619c <tcp_input+0xad0>
            GOTO_DROP;
 8236190:	0080c104 	movi	r2,772
 8236194:	d0a0b215 	stw	r2,-32056(gp)
 8236198:	0005fe06 	br	8237994 <tcp_input+0x22c8>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 823619c:	e0bfe417 	ldw	r2,-112(fp)
 82361a0:	10800817 	ldw	r2,32(r2)
 82361a4:	10800517 	ldw	r2,20(r2)
 82361a8:	10800098 	cmpnei	r2,r2,2
 82361ac:	10002c1e 	bne	r2,zero,8236260 <tcp_input+0xb94>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 82361b0:	e0bffa17 	ldw	r2,-24(fp)
 82361b4:	00c00404 	movi	r3,16
 82361b8:	10c00215 	stw	r3,8(r2)
         sin = mtod(am, struct sockaddr_in *);
 82361bc:	e0bffa17 	ldw	r2,-24(fp)
 82361c0:	10800317 	ldw	r2,12(r2)
 82361c4:	e0bffb15 	stw	r2,-20(fp)
         sin->sin_family = AF_INET;
 82361c8:	e0bffb17 	ldw	r2,-20(fp)
 82361cc:	00c00084 	movi	r3,2
 82361d0:	10c0000d 	sth	r3,0(r2)
         sin->sin_addr = ti->ti_src;
 82361d4:	e0bffb17 	ldw	r2,-20(fp)
 82361d8:	e0fff217 	ldw	r3,-56(fp)
 82361dc:	18c00317 	ldw	r3,12(r3)
 82361e0:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 82361e4:	e0bff217 	ldw	r2,-56(fp)
 82361e8:	10c0050b 	ldhu	r3,20(r2)
 82361ec:	e0bffb17 	ldw	r2,-20(fp)
 82361f0:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 82361f4:	e0bfe417 	ldw	r2,-112(fp)
 82361f8:	10800417 	ldw	r2,16(r2)
 82361fc:	e0bffd15 	stw	r2,-12(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 8236200:	e0bfe417 	ldw	r2,-112(fp)
 8236204:	10800417 	ldw	r2,16(r2)
 8236208:	1000041e 	bne	r2,zero,823621c <tcp_input+0xb50>
            inp->inp_laddr = ti->ti_dst;
 823620c:	e0bfe417 	ldw	r2,-112(fp)
 8236210:	e0fff217 	ldw	r3,-56(fp)
 8236214:	18c00417 	ldw	r3,16(r3)
 8236218:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 823621c:	e17ffa17 	ldw	r5,-24(fp)
 8236220:	e13fe417 	ldw	r4,-112(fp)
 8236224:	8247e740 	call	8247e74 <in_pcbconnect>
 8236228:	10000826 	beq	r2,zero,823624c <tcp_input+0xb80>
         {
            inp->inp_laddr = laddr;
 823622c:	e0bfe417 	ldw	r2,-112(fp)
 8236230:	e0fffd17 	ldw	r3,-12(fp)
 8236234:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 8236238:	e13ffa17 	ldw	r4,-24(fp)
 823623c:	822e27c0 	call	822e27c <m_free>
            GOTO_DROP;
 8236240:	0080c684 	movi	r2,794
 8236244:	d0a0b215 	stw	r2,-32056(gp)
 8236248:	0005d206 	br	8237994 <tcp_input+0x22c8>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 823624c:	e0bfe417 	ldw	r2,-112(fp)
 8236250:	e0ffff17 	ldw	r3,-4(fp)
 8236254:	10c00a15 	stw	r3,40(r2)
         
         (void) m_free (am);
 8236258:	e13ffa17 	ldw	r4,-24(fp)
 823625c:	822e27c0 	call	822e27c <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 8236260:	e13fe617 	ldw	r4,-104(fp)
 8236264:	823926c0 	call	823926c <tcp_template>
 8236268:	1007883a 	mov	r3,r2
 823626c:	e0bfe617 	ldw	r2,-104(fp)
 8236270:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 8236274:	e0bfe617 	ldw	r2,-104(fp)
 8236278:	10800c17 	ldw	r2,48(r2)
 823627c:	1000071e 	bne	r2,zero,823629c <tcp_input+0xbd0>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 8236280:	01401a44 	movi	r5,105
 8236284:	e13fe617 	ldw	r4,-104(fp)
 8236288:	82398800 	call	8239880 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 823628c:	e03fec15 	stw	zero,-80(fp)
            GOTO_DROP;
 8236290:	0080d1c4 	movi	r2,839
 8236294:	d0a0b215 	stw	r2,-32056(gp)
 8236298:	0005be06 	br	8237994 <tcp_input+0x22c8>
         }
         if (om) 
 823629c:	e0bfe517 	ldw	r2,-108(fp)
 82362a0:	10000526 	beq	r2,zero,82362b8 <tcp_input+0xbec>
         {
            tcp_dooptions(tp, om, ti);
 82362a4:	e1bff217 	ldw	r6,-56(fp)
 82362a8:	e17fe517 	ldw	r5,-108(fp)
 82362ac:	e13fe617 	ldw	r4,-104(fp)
 82362b0:	82379fc0 	call	82379fc <tcp_dooptions>
            om = 0;
 82362b4:	e03fe515 	stw	zero,-108(fp)
         }
         if (iss)
 82362b8:	e0bfed17 	ldw	r2,-76(fp)
 82362bc:	10000426 	beq	r2,zero,82362d0 <tcp_input+0xc04>
            tp->iss = iss;
 82362c0:	e0ffed17 	ldw	r3,-76(fp)
 82362c4:	e0bfe617 	ldw	r2,-104(fp)
 82362c8:	10c01315 	stw	r3,76(r2)
 82362cc:	00000306 	br	82362dc <tcp_input+0xc10>
         else
            tp->iss = tcp_iss;
 82362d0:	d0e0b517 	ldw	r3,-32044(gp)
 82362d4:	e0bfe617 	ldw	r2,-104(fp)
 82362d8:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 82362dc:	d0e0b517 	ldw	r3,-32044(gp)
 82362e0:	00be9fd4 	movui	r2,64127
 82362e4:	1885883a 	add	r2,r3,r2
 82362e8:	d0a0b515 	stw	r2,-32044(gp)
         tp->irs = ti->ti_seq;
 82362ec:	e0bff217 	ldw	r2,-56(fp)
 82362f0:	10c00617 	ldw	r3,24(r2)
 82362f4:	e0bfe617 	ldw	r2,-104(fp)
 82362f8:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 82362fc:	e0bfe617 	ldw	r2,-104(fp)
 8236300:	10c01317 	ldw	r3,76(r2)
 8236304:	e0bfe617 	ldw	r2,-104(fp)
 8236308:	10c01015 	stw	r3,64(r2)
 823630c:	e0bfe617 	ldw	r2,-104(fp)
 8236310:	10c01017 	ldw	r3,64(r2)
 8236314:	e0bfe617 	ldw	r2,-104(fp)
 8236318:	10c01a15 	stw	r3,104(r2)
 823631c:	e0bfe617 	ldw	r2,-104(fp)
 8236320:	10c01a17 	ldw	r3,104(r2)
 8236324:	e0bfe617 	ldw	r2,-104(fp)
 8236328:	10c00f15 	stw	r3,60(r2)
 823632c:	e0bfe617 	ldw	r2,-104(fp)
 8236330:	10c00f17 	ldw	r3,60(r2)
 8236334:	e0bfe617 	ldw	r2,-104(fp)
 8236338:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 823633c:	e0bfe617 	ldw	r2,-104(fp)
 8236340:	10801817 	ldw	r2,96(r2)
 8236344:	10c00044 	addi	r3,r2,1
 8236348:	e0bfe617 	ldw	r2,-104(fp)
 823634c:	10c01615 	stw	r3,88(r2)
 8236350:	e0bfe617 	ldw	r2,-104(fp)
 8236354:	10c01617 	ldw	r3,88(r2)
 8236358:	e0bfe617 	ldw	r2,-104(fp)
 823635c:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 8236360:	e0bfe617 	ldw	r2,-104(fp)
 8236364:	10800b0b 	ldhu	r2,44(r2)
 8236368:	10800054 	ori	r2,r2,1
 823636c:	1007883a 	mov	r3,r2
 8236370:	e0bfe617 	ldw	r2,-104(fp)
 8236374:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 8236378:	e0bfe617 	ldw	r2,-104(fp)
 823637c:	00c000c4 	movi	r3,3
 8236380:	10c00215 	stw	r3,8(r2)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 8236384:	e0bfe617 	ldw	r2,-104(fp)
 8236388:	00c02584 	movi	r3,150
 823638c:	10c00515 	stw	r3,20(r2)
         dropsocket = 0;      /* committed to socket */
 8236390:	e03fec15 	stw	zero,-80(fp)
         tcpstat.tcps_accepts++;
 8236394:	008209b4 	movhi	r2,2086
 8236398:	10b8aa04 	addi	r2,r2,-7512
 823639c:	10800117 	ldw	r2,4(r2)
 82363a0:	10c00044 	addi	r3,r2,1
 82363a4:	008209b4 	movhi	r2,2086
 82363a8:	10b8aa04 	addi	r2,r2,-7512
 82363ac:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 82363b0:	00009006 	br	82365f4 <tcp_input+0xf28>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 82363b4:	e0bfe417 	ldw	r2,-112(fp)
 82363b8:	e0ffff17 	ldw	r3,-4(fp)
 82363bc:	10c00a15 	stw	r3,40(r2)
      if ((tiflags & TH_ACK) &&
 82363c0:	e0bfe717 	ldw	r2,-100(fp)
 82363c4:	1080040c 	andi	r2,r2,16
 82363c8:	10000f26 	beq	r2,zero,8236408 <tcp_input+0xd3c>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 82363cc:	e0bff217 	ldw	r2,-56(fp)
 82363d0:	10c00717 	ldw	r3,28(r2)
 82363d4:	e0bfe617 	ldw	r2,-104(fp)
 82363d8:	10801317 	ldw	r2,76(r2)
 82363dc:	1885c83a 	sub	r2,r3,r2
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
 82363e0:	0080060e 	bge	zero,r2,82363fc <tcp_input+0xd30>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
 82363e4:	e0bff217 	ldw	r2,-56(fp)
 82363e8:	10c00717 	ldw	r3,28(r2)
 82363ec:	e0bfe617 	ldw	r2,-104(fp)
 82363f0:	10801a17 	ldw	r2,104(r2)
 82363f4:	1885c83a 	sub	r2,r3,r2
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 82363f8:	0080030e 	bge	zero,r2,8236408 <tcp_input+0xd3c>
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 82363fc:	0080dc04 	movi	r2,880
 8236400:	d0a0b215 	stw	r2,-32056(gp)
 8236404:	00052206 	br	8237890 <tcp_input+0x21c4>
      }
      if (tiflags & TH_RST) 
 8236408:	e0bfe717 	ldw	r2,-100(fp)
 823640c:	1080010c 	andi	r2,r2,4
 8236410:	10000926 	beq	r2,zero,8236438 <tcp_input+0xd6c>
      {
         if (tiflags & TH_ACK)
 8236414:	e0bfe717 	ldw	r2,-100(fp)
 8236418:	1080040c 	andi	r2,r2,16
 823641c:	10000326 	beq	r2,zero,823642c <tcp_input+0xd60>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 8236420:	01401bc4 	movi	r5,111
 8236424:	e13fe617 	ldw	r4,-104(fp)
 8236428:	82398800 	call	8239880 <tcp_drop>
         GOTO_DROP;
 823642c:	0080dd84 	movi	r2,886
 8236430:	d0a0b215 	stw	r2,-32056(gp)
 8236434:	00055706 	br	8237994 <tcp_input+0x22c8>
      }
      if ((tiflags & TH_SYN) == 0)
 8236438:	e0bfe717 	ldw	r2,-100(fp)
 823643c:	1080008c 	andi	r2,r2,2
 8236440:	1000031e 	bne	r2,zero,8236450 <tcp_input+0xd84>
         GOTO_DROP;
 8236444:	0080de44 	movi	r2,889
 8236448:	d0a0b215 	stw	r2,-32056(gp)
 823644c:	00055106 	br	8237994 <tcp_input+0x22c8>
      if (tiflags & TH_ACK) 
 8236450:	e0bfe717 	ldw	r2,-100(fp)
 8236454:	1080040c 	andi	r2,r2,16
 8236458:	10000e26 	beq	r2,zero,8236494 <tcp_input+0xdc8>
      {
         tp->snd_una = ti->ti_ack;
 823645c:	e0bff217 	ldw	r2,-56(fp)
 8236460:	10c00717 	ldw	r3,28(r2)
 8236464:	e0bfe617 	ldw	r2,-104(fp)
 8236468:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 823646c:	e0bfe617 	ldw	r2,-104(fp)
 8236470:	10c00f17 	ldw	r3,60(r2)
 8236474:	e0bfe617 	ldw	r2,-104(fp)
 8236478:	10800e17 	ldw	r2,56(r2)
 823647c:	1885c83a 	sub	r2,r3,r2
 8236480:	1000040e 	bge	r2,zero,8236494 <tcp_input+0xdc8>
            tp->snd_nxt = tp->snd_una;
 8236484:	e0bfe617 	ldw	r2,-104(fp)
 8236488:	10c00e17 	ldw	r3,56(r2)
 823648c:	e0bfe617 	ldw	r2,-104(fp)
 8236490:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 8236494:	e0bfe617 	ldw	r2,-104(fp)
 8236498:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 823649c:	e0bff217 	ldw	r2,-56(fp)
 82364a0:	10c00617 	ldw	r3,24(r2)
 82364a4:	e0bfe617 	ldw	r2,-104(fp)
 82364a8:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 82364ac:	e0bfe617 	ldw	r2,-104(fp)
 82364b0:	10801817 	ldw	r2,96(r2)
 82364b4:	10c00044 	addi	r3,r2,1
 82364b8:	e0bfe617 	ldw	r2,-104(fp)
 82364bc:	10c01615 	stw	r3,88(r2)
 82364c0:	e0bfe617 	ldw	r2,-104(fp)
 82364c4:	10c01617 	ldw	r3,88(r2)
 82364c8:	e0bfe617 	ldw	r2,-104(fp)
 82364cc:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 82364d0:	e0bfe417 	ldw	r2,-112(fp)
 82364d4:	10c00417 	ldw	r3,16(r2)
 82364d8:	e0bff217 	ldw	r2,-56(fp)
 82364dc:	10800417 	ldw	r2,16(r2)
 82364e0:	18801726 	beq	r3,r2,8236540 <tcp_input+0xe74>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 82364e4:	e0bffe17 	ldw	r2,-8(fp)
 82364e8:	10800117 	ldw	r2,4(r2)
 82364ec:	10800617 	ldw	r2,24(r2)
 82364f0:	10001326 	beq	r2,zero,8236540 <tcp_input+0xe74>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
 82364f4:	e0bffe17 	ldw	r2,-8(fp)
 82364f8:	10800117 	ldw	r2,4(r2)
 82364fc:	10800617 	ldw	r2,24(r2)
 8236500:	10c00a17 	ldw	r3,40(r2)
 8236504:	e0bff217 	ldw	r2,-56(fp)
 8236508:	10800417 	ldw	r2,16(r2)
 823650c:	18800c1e 	bne	r3,r2,8236540 <tcp_input+0xe74>
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 8236510:	e0bfe417 	ldw	r2,-112(fp)
 8236514:	e0fff217 	ldw	r3,-56(fp)
 8236518:	18c00417 	ldw	r3,16(r3)
 823651c:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 8236520:	e0bfe617 	ldw	r2,-104(fp)
 8236524:	10800c17 	ldw	r2,48(r2)
 8236528:	10000526 	beq	r2,zero,8236540 <tcp_input+0xe74>
               tp->t_template->ti_src = ti->ti_dst;
 823652c:	e0bfe617 	ldw	r2,-104(fp)
 8236530:	10800c17 	ldw	r2,48(r2)
 8236534:	e0fff217 	ldw	r3,-56(fp)
 8236538:	18c00417 	ldw	r3,16(r3)
 823653c:	10c00315 	stw	r3,12(r2)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 8236540:	e0bfe617 	ldw	r2,-104(fp)
 8236544:	10800b0b 	ldhu	r2,44(r2)
 8236548:	10800054 	ori	r2,r2,1
 823654c:	1007883a 	mov	r3,r2
 8236550:	e0bfe617 	ldw	r2,-104(fp)
 8236554:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 8236558:	e0bfe717 	ldw	r2,-100(fp)
 823655c:	1080040c 	andi	r2,r2,16
 8236560:	10002126 	beq	r2,zero,82365e8 <tcp_input+0xf1c>
 8236564:	e0bfe617 	ldw	r2,-104(fp)
 8236568:	10c00e17 	ldw	r3,56(r2)
 823656c:	e0bfe617 	ldw	r2,-104(fp)
 8236570:	10801317 	ldw	r2,76(r2)
 8236574:	1885c83a 	sub	r2,r3,r2
 8236578:	00801b0e 	bge	zero,r2,82365e8 <tcp_input+0xf1c>
      {
         tcpstat.tcps_connects++;
 823657c:	008209b4 	movhi	r2,2086
 8236580:	10b8aa04 	addi	r2,r2,-7512
 8236584:	10800217 	ldw	r2,8(r2)
 8236588:	10c00044 	addi	r3,r2,1
 823658c:	008209b4 	movhi	r2,2086
 8236590:	10b8aa04 	addi	r2,r2,-7512
 8236594:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 8236598:	e0bfe617 	ldw	r2,-104(fp)
 823659c:	00c00104 	movi	r3,4
 82365a0:	10c00215 	stw	r3,8(r2)
         soisconnected (so);
 82365a4:	e13fe817 	ldw	r4,-96(fp)
 82365a8:	82338240 	call	8233824 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 82365ac:	e13fe817 	ldw	r4,-96(fp)
 82365b0:	8237f540 	call	8237f54 <tcp_mss>
 82365b4:	1007883a 	mov	r3,r2
 82365b8:	e0bfe617 	ldw	r2,-104(fp)
 82365bc:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 82365c0:	e1bffe17 	ldw	r6,-8(fp)
 82365c4:	000b883a 	mov	r5,zero
 82365c8:	e13fe617 	ldw	r4,-104(fp)
 82365cc:	82352bc0 	call	82352bc <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 82365d0:	e0bfe617 	ldw	r2,-104(fp)
 82365d4:	10801e17 	ldw	r2,120(r2)
 82365d8:	10000626 	beq	r2,zero,82365f4 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
 82365dc:	e13fe617 	ldw	r4,-104(fp)
 82365e0:	8237cb00 	call	8237cb0 <tcp_xmit_timer>
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 82365e4:	00000306 	br	82365f4 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 82365e8:	e0bfe617 	ldw	r2,-104(fp)
 82365ec:	00c000c4 	movi	r3,3
 82365f0:	10c00215 	stw	r3,8(r2)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 82365f4:	e0bff217 	ldw	r2,-56(fp)
 82365f8:	10800617 	ldw	r2,24(r2)
 82365fc:	10c00044 	addi	r3,r2,1
 8236600:	e0bff217 	ldw	r2,-56(fp)
 8236604:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 8236608:	e0bff217 	ldw	r2,-56(fp)
 823660c:	1080028b 	ldhu	r2,10(r2)
 8236610:	10bfffcc 	andi	r2,r2,65535
 8236614:	e0ffe617 	ldw	r3,-104(fp)
 8236618:	18c01517 	ldw	r3,84(r3)
 823661c:	1880302e 	bgeu	r3,r2,82366e0 <tcp_input+0x1014>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 8236620:	e0bff217 	ldw	r2,-56(fp)
 8236624:	1080028b 	ldhu	r2,10(r2)
 8236628:	10ffffcc 	andi	r3,r2,65535
 823662c:	e0bfe617 	ldw	r2,-104(fp)
 8236630:	10801517 	ldw	r2,84(r2)
 8236634:	10bfffcc 	andi	r2,r2,65535
 8236638:	1885c83a 	sub	r2,r3,r2
 823663c:	e0bfe915 	stw	r2,-92(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 8236640:	e0bffe17 	ldw	r2,-8(fp)
 8236644:	10800217 	ldw	r2,8(r2)
 8236648:	10000626 	beq	r2,zero,8236664 <tcp_input+0xf98>
         {
            m_adj(m, -todrop);
 823664c:	e0bfe917 	ldw	r2,-92(fp)
 8236650:	0085c83a 	sub	r2,zero,r2
 8236654:	100b883a 	mov	r5,r2
 8236658:	e13ffe17 	ldw	r4,-8(fp)
 823665c:	822e6bc0 	call	822e6bc <m_adj>
 8236660:	00000706 	br	8236680 <tcp_input+0xfb4>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 8236664:	e0bffe17 	ldw	r2,-8(fp)
 8236668:	10c00617 	ldw	r3,24(r2)
 823666c:	e0bfe917 	ldw	r2,-92(fp)
 8236670:	0085c83a 	sub	r2,zero,r2
 8236674:	100b883a 	mov	r5,r2
 8236678:	1809883a 	mov	r4,r3
 823667c:	822e6bc0 	call	822e6bc <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 8236680:	e0bfe617 	ldw	r2,-104(fp)
 8236684:	10801517 	ldw	r2,84(r2)
 8236688:	1007883a 	mov	r3,r2
 823668c:	e0bff217 	ldw	r2,-56(fp)
 8236690:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 8236694:	e0ffe717 	ldw	r3,-100(fp)
 8236698:	00bfff84 	movi	r2,-2
 823669c:	1884703a 	and	r2,r3,r2
 82366a0:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpackafterwin++;
 82366a4:	008209b4 	movhi	r2,2086
 82366a8:	10b8aa04 	addi	r2,r2,-7512
 82366ac:	10802517 	ldw	r2,148(r2)
 82366b0:	10c00044 	addi	r3,r2,1
 82366b4:	008209b4 	movhi	r2,2086
 82366b8:	10b8aa04 	addi	r2,r2,-7512
 82366bc:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 82366c0:	008209b4 	movhi	r2,2086
 82366c4:	10b8aa04 	addi	r2,r2,-7512
 82366c8:	10c02617 	ldw	r3,152(r2)
 82366cc:	e0bfe917 	ldw	r2,-92(fp)
 82366d0:	1887883a 	add	r3,r3,r2
 82366d4:	008209b4 	movhi	r2,2086
 82366d8:	10b8aa04 	addi	r2,r2,-7512
 82366dc:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 82366e0:	e0bff217 	ldw	r2,-56(fp)
 82366e4:	10800617 	ldw	r2,24(r2)
 82366e8:	10ffffc4 	addi	r3,r2,-1
 82366ec:	e0bfe617 	ldw	r2,-104(fp)
 82366f0:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 82366f4:	e0bff217 	ldw	r2,-56(fp)
 82366f8:	10c00617 	ldw	r3,24(r2)
 82366fc:	e0bfe617 	ldw	r2,-104(fp)
 8236700:	10c01715 	stw	r3,92(r2)
      goto step6;
 8236704:	0002ee06 	br	82372c0 <tcp_input+0x1bf4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 8236708:	e0bfe617 	ldw	r2,-104(fp)
 823670c:	10c01617 	ldw	r3,88(r2)
 8236710:	e0bff217 	ldw	r2,-56(fp)
 8236714:	10800617 	ldw	r2,24(r2)
 8236718:	1885c83a 	sub	r2,r3,r2
 823671c:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236720:	e0bfe917 	ldw	r2,-92(fp)
 8236724:	0080910e 	bge	zero,r2,823696c <tcp_input+0x12a0>
   {
      if (tiflags & TH_SYN) 
 8236728:	e0bfe717 	ldw	r2,-100(fp)
 823672c:	1080008c 	andi	r2,r2,2
 8236730:	10001c26 	beq	r2,zero,82367a4 <tcp_input+0x10d8>
      {
         tiflags &= ~TH_SYN;
 8236734:	e0ffe717 	ldw	r3,-100(fp)
 8236738:	00bfff44 	movi	r2,-3
 823673c:	1884703a 	and	r2,r3,r2
 8236740:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_seq++;
 8236744:	e0bff217 	ldw	r2,-56(fp)
 8236748:	10800617 	ldw	r2,24(r2)
 823674c:	10c00044 	addi	r3,r2,1
 8236750:	e0bff217 	ldw	r2,-56(fp)
 8236754:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 8236758:	e0bff217 	ldw	r2,-56(fp)
 823675c:	1080098b 	ldhu	r2,38(r2)
 8236760:	10bfffcc 	andi	r2,r2,65535
 8236764:	108000b0 	cmpltui	r2,r2,2
 8236768:	1000071e 	bne	r2,zero,8236788 <tcp_input+0x10bc>
            ti->ti_urp--;
 823676c:	e0bff217 	ldw	r2,-56(fp)
 8236770:	1080098b 	ldhu	r2,38(r2)
 8236774:	10bfffc4 	addi	r2,r2,-1
 8236778:	1007883a 	mov	r3,r2
 823677c:	e0bff217 	ldw	r2,-56(fp)
 8236780:	10c0098d 	sth	r3,38(r2)
 8236784:	00000406 	br	8236798 <tcp_input+0x10cc>
         else
            tiflags &= ~TH_URG;
 8236788:	e0ffe717 	ldw	r3,-100(fp)
 823678c:	00bff7c4 	movi	r2,-33
 8236790:	1884703a 	and	r2,r3,r2
 8236794:	e0bfe715 	stw	r2,-100(fp)
         todrop--;
 8236798:	e0bfe917 	ldw	r2,-92(fp)
 823679c:	10bfffc4 	addi	r2,r2,-1
 82367a0:	e0bfe915 	stw	r2,-92(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 82367a4:	e0bff217 	ldw	r2,-56(fp)
 82367a8:	1080028b 	ldhu	r2,10(r2)
 82367ac:	10ffffcc 	andi	r3,r2,65535
 82367b0:	e0bfe917 	ldw	r2,-92(fp)
 82367b4:	18800816 	blt	r3,r2,82367d8 <tcp_input+0x110c>
          ((todrop == (int)ti->ti_len) && 
 82367b8:	e0bff217 	ldw	r2,-56(fp)
 82367bc:	1080028b 	ldhu	r2,10(r2)
 82367c0:	10ffffcc 	andi	r3,r2,65535
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 82367c4:	e0bfe917 	ldw	r2,-92(fp)
 82367c8:	1880351e 	bne	r3,r2,82368a0 <tcp_input+0x11d4>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
 82367cc:	e0bfe717 	ldw	r2,-100(fp)
 82367d0:	1080004c 	andi	r2,r2,1
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
          ((todrop == (int)ti->ti_len) && 
 82367d4:	1000321e 	bne	r2,zero,82368a0 <tcp_input+0x11d4>
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 82367d8:	008209b4 	movhi	r2,2086
 82367dc:	10b8aa04 	addi	r2,r2,-7512
 82367e0:	10801f17 	ldw	r2,124(r2)
 82367e4:	10c00044 	addi	r3,r2,1
 82367e8:	008209b4 	movhi	r2,2086
 82367ec:	10b8aa04 	addi	r2,r2,-7512
 82367f0:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 82367f4:	008209b4 	movhi	r2,2086
 82367f8:	10b8aa04 	addi	r2,r2,-7512
 82367fc:	10c02017 	ldw	r3,128(r2)
 8236800:	e0bff217 	ldw	r2,-56(fp)
 8236804:	1080028b 	ldhu	r2,10(r2)
 8236808:	10bfffcc 	andi	r2,r2,65535
 823680c:	1887883a 	add	r3,r3,r2
 8236810:	008209b4 	movhi	r2,2086
 8236814:	10b8aa04 	addi	r2,r2,-7512
 8236818:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 823681c:	e0bfe717 	ldw	r2,-100(fp)
 8236820:	1080004c 	andi	r2,r2,1
 8236824:	10000626 	beq	r2,zero,8236840 <tcp_input+0x1174>
 8236828:	e0bff217 	ldw	r2,-56(fp)
 823682c:	1080028b 	ldhu	r2,10(r2)
 8236830:	10bfffcc 	andi	r2,r2,65535
 8236834:	10c00044 	addi	r3,r2,1
 8236838:	e0bfe917 	ldw	r2,-92(fp)
 823683c:	18800926 	beq	r3,r2,8236864 <tcp_input+0x1198>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236840:	e0bfe717 	ldw	r2,-100(fp)
 8236844:	1080010c 	andi	r2,r2,4
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236848:	10040026 	beq	r2,zero,823784c <tcp_input+0x2180>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 823684c:	e0bff217 	ldw	r2,-56(fp)
 8236850:	10c00617 	ldw	r3,24(r2)
 8236854:	e0bfe617 	ldw	r2,-104(fp)
 8236858:	10801617 	ldw	r2,88(r2)
 823685c:	10bfffc4 	addi	r2,r2,-1
 8236860:	1883fa1e 	bne	r3,r2,823784c <tcp_input+0x2180>
         {
            todrop = ti->ti_len;
 8236864:	e0bff217 	ldw	r2,-56(fp)
 8236868:	1080028b 	ldhu	r2,10(r2)
 823686c:	10bfffcc 	andi	r2,r2,65535
 8236870:	e0bfe915 	stw	r2,-92(fp)
            tiflags &= ~TH_FIN;
 8236874:	e0ffe717 	ldw	r3,-100(fp)
 8236878:	00bfff84 	movi	r2,-2
 823687c:	1884703a 	and	r2,r3,r2
 8236880:	e0bfe715 	stw	r2,-100(fp)
            tp->t_flags |= TF_ACKNOW;
 8236884:	e0bfe617 	ldw	r2,-104(fp)
 8236888:	10800b0b 	ldhu	r2,44(r2)
 823688c:	10800054 	ori	r2,r2,1
 8236890:	1007883a 	mov	r3,r2
 8236894:	e0bfe617 	ldw	r2,-104(fp)
 8236898:	10c00b0d 	sth	r3,44(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 823689c:	00000f06 	br	82368dc <tcp_input+0x1210>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 82368a0:	008209b4 	movhi	r2,2086
 82368a4:	10b8aa04 	addi	r2,r2,-7512
 82368a8:	10802117 	ldw	r2,132(r2)
 82368ac:	10c00044 	addi	r3,r2,1
 82368b0:	008209b4 	movhi	r2,2086
 82368b4:	10b8aa04 	addi	r2,r2,-7512
 82368b8:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 82368bc:	008209b4 	movhi	r2,2086
 82368c0:	10b8aa04 	addi	r2,r2,-7512
 82368c4:	10c02217 	ldw	r3,136(r2)
 82368c8:	e0bfe917 	ldw	r2,-92(fp)
 82368cc:	1887883a 	add	r3,r3,r2
 82368d0:	008209b4 	movhi	r2,2086
 82368d4:	10b8aa04 	addi	r2,r2,-7512
 82368d8:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 82368dc:	e17fe917 	ldw	r5,-92(fp)
 82368e0:	e13ffe17 	ldw	r4,-8(fp)
 82368e4:	822e6bc0 	call	822e6bc <m_adj>
      ti->ti_seq += todrop;
 82368e8:	e0bff217 	ldw	r2,-56(fp)
 82368ec:	10c00617 	ldw	r3,24(r2)
 82368f0:	e0bfe917 	ldw	r2,-92(fp)
 82368f4:	1887883a 	add	r3,r3,r2
 82368f8:	e0bff217 	ldw	r2,-56(fp)
 82368fc:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 8236900:	e0bff217 	ldw	r2,-56(fp)
 8236904:	1080028b 	ldhu	r2,10(r2)
 8236908:	e0ffe917 	ldw	r3,-92(fp)
 823690c:	10c5c83a 	sub	r2,r2,r3
 8236910:	1007883a 	mov	r3,r2
 8236914:	e0bff217 	ldw	r2,-56(fp)
 8236918:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 823691c:	e0bff217 	ldw	r2,-56(fp)
 8236920:	1080098b 	ldhu	r2,38(r2)
 8236924:	10bfffcc 	andi	r2,r2,65535
 8236928:	e0ffe917 	ldw	r3,-92(fp)
 823692c:	18ffffcc 	andi	r3,r3,65535
 8236930:	1880080e 	bge	r3,r2,8236954 <tcp_input+0x1288>
         ti->ti_urp -= (u_short)todrop;
 8236934:	e0bff217 	ldw	r2,-56(fp)
 8236938:	1080098b 	ldhu	r2,38(r2)
 823693c:	e0ffe917 	ldw	r3,-92(fp)
 8236940:	10c5c83a 	sub	r2,r2,r3
 8236944:	1007883a 	mov	r3,r2
 8236948:	e0bff217 	ldw	r2,-56(fp)
 823694c:	10c0098d 	sth	r3,38(r2)
 8236950:	00000606 	br	823696c <tcp_input+0x12a0>
      else 
      {
         tiflags &= ~TH_URG;
 8236954:	e0ffe717 	ldw	r3,-100(fp)
 8236958:	00bff7c4 	movi	r2,-33
 823695c:	1884703a 	and	r2,r3,r2
 8236960:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_urp = 0;
 8236964:	e0bff217 	ldw	r2,-56(fp)
 8236968:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 823696c:	e0bfe817 	ldw	r2,-96(fp)
 8236970:	1080088b 	ldhu	r2,34(r2)
 8236974:	10bfffcc 	andi	r2,r2,65535
 8236978:	1080004c 	andi	r2,r2,1
 823697c:	10001526 	beq	r2,zero,82369d4 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236980:	e0bfe617 	ldw	r2,-104(fp)
 8236984:	10800217 	ldw	r2,8(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236988:	10800190 	cmplti	r2,r2,6
 823698c:	1000111e 	bne	r2,zero,82369d4 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236990:	e0bff217 	ldw	r2,-56(fp)
 8236994:	1080028b 	ldhu	r2,10(r2)
 8236998:	10bfffcc 	andi	r2,r2,65535
 823699c:	10000d26 	beq	r2,zero,82369d4 <tcp_input+0x1308>
   {
      tp = tcp_close(tp);
 82369a0:	e13fe617 	ldw	r4,-104(fp)
 82369a4:	823992c0 	call	823992c <tcp_close>
 82369a8:	e0bfe615 	stw	r2,-104(fp)
      tcpstat.tcps_rcvafterclose++;
 82369ac:	008209b4 	movhi	r2,2086
 82369b0:	10b8aa04 	addi	r2,r2,-7512
 82369b4:	10802717 	ldw	r2,156(r2)
 82369b8:	10c00044 	addi	r3,r2,1
 82369bc:	008209b4 	movhi	r2,2086
 82369c0:	10b8aa04 	addi	r2,r2,-7512
 82369c4:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 82369c8:	00810444 	movi	r2,1041
 82369cc:	d0a0b215 	stw	r2,-32056(gp)
 82369d0:	0003af06 	br	8237890 <tcp_input+0x21c4>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 82369d4:	e0bff217 	ldw	r2,-56(fp)
 82369d8:	10c00617 	ldw	r3,24(r2)
 82369dc:	e0bff217 	ldw	r2,-56(fp)
 82369e0:	1080028b 	ldhu	r2,10(r2)
 82369e4:	10bfffcc 	andi	r2,r2,65535
 82369e8:	10a0001c 	xori	r2,r2,32768
 82369ec:	10a00004 	addi	r2,r2,-32768
 82369f0:	1887883a 	add	r3,r3,r2
 82369f4:	e0bfe617 	ldw	r2,-104(fp)
 82369f8:	11001617 	ldw	r4,88(r2)
 82369fc:	e0bfe617 	ldw	r2,-104(fp)
 8236a00:	10801517 	ldw	r2,84(r2)
 8236a04:	2085883a 	add	r2,r4,r2
 8236a08:	1885c83a 	sub	r2,r3,r2
 8236a0c:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236a10:	e0bfe917 	ldw	r2,-92(fp)
 8236a14:	0080690e 	bge	zero,r2,8236bbc <tcp_input+0x14f0>
   {
      tcpstat.tcps_rcvpackafterwin++;
 8236a18:	008209b4 	movhi	r2,2086
 8236a1c:	10b8aa04 	addi	r2,r2,-7512
 8236a20:	10802517 	ldw	r2,148(r2)
 8236a24:	10c00044 	addi	r3,r2,1
 8236a28:	008209b4 	movhi	r2,2086
 8236a2c:	10b8aa04 	addi	r2,r2,-7512
 8236a30:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 8236a34:	e0bff217 	ldw	r2,-56(fp)
 8236a38:	1080028b 	ldhu	r2,10(r2)
 8236a3c:	10bfffcc 	andi	r2,r2,65535
 8236a40:	e0ffe917 	ldw	r3,-92(fp)
 8236a44:	18803a16 	blt	r3,r2,8236b30 <tcp_input+0x1464>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 8236a48:	008209b4 	movhi	r2,2086
 8236a4c:	10b8aa04 	addi	r2,r2,-7512
 8236a50:	10c02617 	ldw	r3,152(r2)
 8236a54:	e0bff217 	ldw	r2,-56(fp)
 8236a58:	1080028b 	ldhu	r2,10(r2)
 8236a5c:	10bfffcc 	andi	r2,r2,65535
 8236a60:	1887883a 	add	r3,r3,r2
 8236a64:	008209b4 	movhi	r2,2086
 8236a68:	10b8aa04 	addi	r2,r2,-7512
 8236a6c:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236a70:	e0bfe717 	ldw	r2,-100(fp)
 8236a74:	1080008c 	andi	r2,r2,2
 8236a78:	10001726 	beq	r2,zero,8236ad8 <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
 8236a7c:	e0bfe617 	ldw	r2,-104(fp)
 8236a80:	10800217 	ldw	r2,8(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236a84:	10800298 	cmpnei	r2,r2,10
 8236a88:	1000131e 	bne	r2,zero,8236ad8 <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
 8236a8c:	e0bff217 	ldw	r2,-56(fp)
 8236a90:	10c00617 	ldw	r3,24(r2)
 8236a94:	e0bfe617 	ldw	r2,-104(fp)
 8236a98:	10801617 	ldw	r2,88(r2)
 8236a9c:	1885c83a 	sub	r2,r3,r2
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
             tp->t_state == TCPS_TIME_WAIT &&
 8236aa0:	00800d0e 	bge	zero,r2,8236ad8 <tcp_input+0x140c>
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 8236aa4:	e0bfe617 	ldw	r2,-104(fp)
 8236aa8:	10c01617 	ldw	r3,88(r2)
 8236aac:	008000b4 	movhi	r2,2
 8236ab0:	10bd3fc4 	addi	r2,r2,-2817
 8236ab4:	1885883a 	add	r2,r3,r2
 8236ab8:	e0bfed15 	stw	r2,-76(fp)
            if (iss & 0xff000000)
 8236abc:	e0bfed17 	ldw	r2,-76(fp)
 8236ac0:	10bfc02c 	andhi	r2,r2,65280
 8236ac4:	10000126 	beq	r2,zero,8236acc <tcp_input+0x1400>
            {
               iss = 0L;
 8236ac8:	e03fed15 	stw	zero,-76(fp)
            }
            (void) tcp_close(tp);
 8236acc:	e13fe617 	ldw	r4,-104(fp)
 8236ad0:	823992c0 	call	823992c <tcp_close>
            goto findpcb;
 8236ad4:	003bd406 	br	8235a28 <tcp_input+0x35c>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 8236ad8:	e0bfe617 	ldw	r2,-104(fp)
 8236adc:	10801517 	ldw	r2,84(r2)
 8236ae0:	10035a1e 	bne	r2,zero,823784c <tcp_input+0x2180>
 8236ae4:	e0bff217 	ldw	r2,-56(fp)
 8236ae8:	10c00617 	ldw	r3,24(r2)
 8236aec:	e0bfe617 	ldw	r2,-104(fp)
 8236af0:	10801617 	ldw	r2,88(r2)
 8236af4:	1883551e 	bne	r3,r2,823784c <tcp_input+0x2180>
         {
            tp->t_flags |= TF_ACKNOW;
 8236af8:	e0bfe617 	ldw	r2,-104(fp)
 8236afc:	10800b0b 	ldhu	r2,44(r2)
 8236b00:	10800054 	ori	r2,r2,1
 8236b04:	1007883a 	mov	r3,r2
 8236b08:	e0bfe617 	ldw	r2,-104(fp)
 8236b0c:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 8236b10:	008209b4 	movhi	r2,2086
 8236b14:	10b8aa04 	addi	r2,r2,-7512
 8236b18:	10802817 	ldw	r2,160(r2)
 8236b1c:	10c00044 	addi	r3,r2,1
 8236b20:	008209b4 	movhi	r2,2086
 8236b24:	10b8aa04 	addi	r2,r2,-7512
 8236b28:	10c02815 	stw	r3,160(r2)
 8236b2c:	00000806 	br	8236b50 <tcp_input+0x1484>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 8236b30:	008209b4 	movhi	r2,2086
 8236b34:	10b8aa04 	addi	r2,r2,-7512
 8236b38:	10c02617 	ldw	r3,152(r2)
 8236b3c:	e0bfe917 	ldw	r2,-92(fp)
 8236b40:	1887883a 	add	r3,r3,r2
 8236b44:	008209b4 	movhi	r2,2086
 8236b48:	10b8aa04 	addi	r2,r2,-7512
 8236b4c:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 8236b50:	e0bffe17 	ldw	r2,-8(fp)
 8236b54:	10800217 	ldw	r2,8(r2)
 8236b58:	10000626 	beq	r2,zero,8236b74 <tcp_input+0x14a8>
      {
         m_adj(m, -todrop);
 8236b5c:	e0bfe917 	ldw	r2,-92(fp)
 8236b60:	0085c83a 	sub	r2,zero,r2
 8236b64:	100b883a 	mov	r5,r2
 8236b68:	e13ffe17 	ldw	r4,-8(fp)
 8236b6c:	822e6bc0 	call	822e6bc <m_adj>
 8236b70:	00000706 	br	8236b90 <tcp_input+0x14c4>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 8236b74:	e0bffe17 	ldw	r2,-8(fp)
 8236b78:	10c00617 	ldw	r3,24(r2)
 8236b7c:	e0bfe917 	ldw	r2,-92(fp)
 8236b80:	0085c83a 	sub	r2,zero,r2
 8236b84:	100b883a 	mov	r5,r2
 8236b88:	1809883a 	mov	r4,r3
 8236b8c:	822e6bc0 	call	822e6bc <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 8236b90:	e0bff217 	ldw	r2,-56(fp)
 8236b94:	1080028b 	ldhu	r2,10(r2)
 8236b98:	e0ffe917 	ldw	r3,-92(fp)
 8236b9c:	10c5c83a 	sub	r2,r2,r3
 8236ba0:	1007883a 	mov	r3,r2
 8236ba4:	e0bff217 	ldw	r2,-56(fp)
 8236ba8:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 8236bac:	e0ffe717 	ldw	r3,-100(fp)
 8236bb0:	00bffd84 	movi	r2,-10
 8236bb4:	1884703a 	and	r2,r3,r2
 8236bb8:	e0bfe715 	stw	r2,-100(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 8236bbc:	e0bfe717 	ldw	r2,-100(fp)
 8236bc0:	1080010c 	andi	r2,r2,4
 8236bc4:	10003426 	beq	r2,zero,8236c98 <tcp_input+0x15cc>
   {
      switch (tp->t_state) 
 8236bc8:	e0bfe617 	ldw	r2,-104(fp)
 8236bcc:	10800217 	ldw	r2,8(r2)
 8236bd0:	10bfff44 	addi	r2,r2,-3
 8236bd4:	10c00228 	cmpgeui	r3,r2,8
 8236bd8:	18002f1e 	bne	r3,zero,8236c98 <tcp_input+0x15cc>
 8236bdc:	100690ba 	slli	r3,r2,2
 8236be0:	008208f4 	movhi	r2,2083
 8236be4:	109afd04 	addi	r2,r2,27636
 8236be8:	1885883a 	add	r2,r3,r2
 8236bec:	10800017 	ldw	r2,0(r2)
 8236bf0:	1000683a 	jmp	r2
 8236bf4:	08236c14 	ori	zero,at,36272
 8236bf8:	08236c24 	muli	zero,at,-29264
 8236bfc:	08236c40 	call	8236c4 <OSCtxSw_SWITCH_PC+0x823684>
 8236c00:	08236c40 	call	8236c4 <OSCtxSw_SWITCH_PC+0x823684>
 8236c04:	08236c84 	addi	zero,at,-29262
 8236c08:	08236c84 	addi	zero,at,-29262
 8236c0c:	08236c40 	call	8236c4 <OSCtxSw_SWITCH_PC+0x823684>
 8236c10:	08236c84 	addi	zero,at,-29262
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 8236c14:	e0bfe817 	ldw	r2,-96(fp)
 8236c18:	00c01bc4 	movi	r3,111
 8236c1c:	10c00615 	stw	r3,24(r2)
         goto close;
 8236c20:	00000a06 	br	8236c4c <tcp_input+0x1580>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236c24:	008209b4 	movhi	r2,2086
 8236c28:	10b87c04 	addi	r2,r2,-7696
 8236c2c:	10800717 	ldw	r2,28(r2)
 8236c30:	10c00044 	addi	r3,r2,1
 8236c34:	008209b4 	movhi	r2,2086
 8236c38:	10b87c04 	addi	r2,r2,-7696
 8236c3c:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 8236c40:	e0bfe817 	ldw	r2,-96(fp)
 8236c44:	00c01a04 	movi	r3,104
 8236c48:	10c00615 	stw	r3,24(r2)
         close:
         tp->t_state = TCPS_CLOSED;
 8236c4c:	e0bfe617 	ldw	r2,-104(fp)
 8236c50:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 8236c54:	008209b4 	movhi	r2,2086
 8236c58:	10b8aa04 	addi	r2,r2,-7512
 8236c5c:	10800317 	ldw	r2,12(r2)
 8236c60:	10c00044 	addi	r3,r2,1
 8236c64:	008209b4 	movhi	r2,2086
 8236c68:	10b8aa04 	addi	r2,r2,-7512
 8236c6c:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 8236c70:	e13fe617 	ldw	r4,-104(fp)
 8236c74:	823992c0 	call	823992c <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 8236c78:	00812204 	movi	r2,1160
 8236c7c:	d0a0b215 	stw	r2,-32056(gp)
 8236c80:	00034406 	br	8237994 <tcp_input+0x22c8>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 8236c84:	e13fe617 	ldw	r4,-104(fp)
 8236c88:	823992c0 	call	823992c <tcp_close>
         GOTO_DROP;
 8236c8c:	00812384 	movi	r2,1166
 8236c90:	d0a0b215 	stw	r2,-32056(gp)
 8236c94:	00033f06 	br	8237994 <tcp_input+0x22c8>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 8236c98:	e0bfe717 	ldw	r2,-100(fp)
 8236c9c:	1080008c 	andi	r2,r2,2
 8236ca0:	10000726 	beq	r2,zero,8236cc0 <tcp_input+0x15f4>
   {
      tp = tcp_drop(tp, ECONNRESET);
 8236ca4:	01401a04 	movi	r5,104
 8236ca8:	e13fe617 	ldw	r4,-104(fp)
 8236cac:	82398800 	call	8239880 <tcp_drop>
 8236cb0:	e0bfe615 	stw	r2,-104(fp)
      GOTO_DROPWITHRESET;
 8236cb4:	00812b04 	movi	r2,1196
 8236cb8:	d0a0b215 	stw	r2,-32056(gp)
 8236cbc:	0002f406 	br	8237890 <tcp_input+0x21c4>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 8236cc0:	e0bfe717 	ldw	r2,-100(fp)
 8236cc4:	1080040c 	andi	r2,r2,16
 8236cc8:	1000031e 	bne	r2,zero,8236cd8 <tcp_input+0x160c>
      GOTO_DROP;
 8236ccc:	00812d04 	movi	r2,1204
 8236cd0:	d0a0b215 	stw	r2,-32056(gp)
 8236cd4:	00032f06 	br	8237994 <tcp_input+0x22c8>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 8236cd8:	e0bfe617 	ldw	r2,-104(fp)
 8236cdc:	10800217 	ldw	r2,8(r2)
 8236ce0:	10c000e0 	cmpeqi	r3,r2,3
 8236ce4:	1800051e 	bne	r3,zero,8236cfc <tcp_input+0x1630>
 8236ce8:	10c000d0 	cmplti	r3,r2,3
 8236cec:	1801741e 	bne	r3,zero,82372c0 <tcp_input+0x1bf4>
 8236cf0:	108002c8 	cmpgei	r2,r2,11
 8236cf4:	1001721e 	bne	r2,zero,82372c0 <tcp_input+0x1bf4>
 8236cf8:	00003006 	br	8236dbc <tcp_input+0x16f0>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236cfc:	e0bfe617 	ldw	r2,-104(fp)
 8236d00:	10c00e17 	ldw	r3,56(r2)
 8236d04:	e0bff217 	ldw	r2,-56(fp)
 8236d08:	10800717 	ldw	r2,28(r2)
 8236d0c:	1885c83a 	sub	r2,r3,r2
 8236d10:	00800616 	blt	zero,r2,8236d2c <tcp_input+0x1660>
          SEQ_GT(ti->ti_ack, tp->snd_max))
 8236d14:	e0bff217 	ldw	r2,-56(fp)
 8236d18:	10c00717 	ldw	r3,28(r2)
 8236d1c:	e0bfe617 	ldw	r2,-104(fp)
 8236d20:	10801a17 	ldw	r2,104(r2)
 8236d24:	1885c83a 	sub	r2,r3,r2
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236d28:	00800a0e 	bge	zero,r2,8236d54 <tcp_input+0x1688>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236d2c:	008209b4 	movhi	r2,2086
 8236d30:	10b87c04 	addi	r2,r2,-7696
 8236d34:	10800717 	ldw	r2,28(r2)
 8236d38:	10c00044 	addi	r3,r2,1
 8236d3c:	008209b4 	movhi	r2,2086
 8236d40:	10b87c04 	addi	r2,r2,-7696
 8236d44:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 8236d48:	00813184 	movi	r2,1222
 8236d4c:	d0a0b215 	stw	r2,-32056(gp)
 8236d50:	0002cf06 	br	8237890 <tcp_input+0x21c4>
      }
      tcpstat.tcps_connects++;
 8236d54:	008209b4 	movhi	r2,2086
 8236d58:	10b8aa04 	addi	r2,r2,-7512
 8236d5c:	10800217 	ldw	r2,8(r2)
 8236d60:	10c00044 	addi	r3,r2,1
 8236d64:	008209b4 	movhi	r2,2086
 8236d68:	10b8aa04 	addi	r2,r2,-7512
 8236d6c:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 8236d70:	e0bfe617 	ldw	r2,-104(fp)
 8236d74:	00c00104 	movi	r3,4
 8236d78:	10c00215 	stw	r3,8(r2)
      soisconnected(so);
 8236d7c:	e13fe817 	ldw	r4,-96(fp)
 8236d80:	82338240 	call	8233824 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 8236d84:	e13fe817 	ldw	r4,-96(fp)
 8236d88:	8237f540 	call	8237f54 <tcp_mss>
 8236d8c:	1007883a 	mov	r3,r2
 8236d90:	e0bfe617 	ldw	r2,-104(fp)
 8236d94:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 8236d98:	e1bffe17 	ldw	r6,-8(fp)
 8236d9c:	000b883a 	mov	r5,zero
 8236da0:	e13fe617 	ldw	r4,-104(fp)
 8236da4:	82352bc0 	call	82352bc <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 8236da8:	e0bff217 	ldw	r2,-56(fp)
 8236dac:	10800617 	ldw	r2,24(r2)
 8236db0:	10ffffc4 	addi	r3,r2,-1
 8236db4:	e0bfe617 	ldw	r2,-104(fp)
 8236db8:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 8236dbc:	e0bff217 	ldw	r2,-56(fp)
 8236dc0:	10c00717 	ldw	r3,28(r2)
 8236dc4:	e0bfe617 	ldw	r2,-104(fp)
 8236dc8:	10800e17 	ldw	r2,56(r2)
 8236dcc:	1885c83a 	sub	r2,r3,r2
 8236dd0:	00806316 	blt	zero,r2,8236f60 <tcp_input+0x1894>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 8236dd4:	e0bff217 	ldw	r2,-56(fp)
 8236dd8:	1080028b 	ldhu	r2,10(r2)
 8236ddc:	10bfffcc 	andi	r2,r2,65535
 8236de0:	10005a1e 	bne	r2,zero,8236f4c <tcp_input+0x1880>
 8236de4:	e0bfe617 	ldw	r2,-104(fp)
 8236de8:	10c01417 	ldw	r3,80(r2)
 8236dec:	e0bff517 	ldw	r2,-44(fp)
 8236df0:	1880561e 	bne	r3,r2,8236f4c <tcp_input+0x1880>
         {
            tcpstat.tcps_rcvdupack++;
 8236df4:	008209b4 	movhi	r2,2086
 8236df8:	10b8aa04 	addi	r2,r2,-7512
 8236dfc:	10802917 	ldw	r2,164(r2)
 8236e00:	10c00044 	addi	r3,r2,1
 8236e04:	008209b4 	movhi	r2,2086
 8236e08:	10b8aa04 	addi	r2,r2,-7512
 8236e0c:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236e10:	e0bfe617 	ldw	r2,-104(fp)
 8236e14:	10800317 	ldw	r2,12(r2)
 8236e18:	10000526 	beq	r2,zero,8236e30 <tcp_input+0x1764>
                ti->ti_ack != tp->snd_una)
 8236e1c:	e0bff217 	ldw	r2,-56(fp)
 8236e20:	10c00717 	ldw	r3,28(r2)
 8236e24:	e0bfe617 	ldw	r2,-104(fp)
 8236e28:	10800e17 	ldw	r2,56(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236e2c:	18800326 	beq	r3,r2,8236e3c <tcp_input+0x1770>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 8236e30:	e0bfe617 	ldw	r2,-104(fp)
 8236e34:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236e38:	00004706 	br	8236f58 <tcp_input+0x188c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 8236e3c:	e0bfe617 	ldw	r2,-104(fp)
 8236e40:	10800917 	ldw	r2,36(r2)
 8236e44:	10c00044 	addi	r3,r2,1
 8236e48:	e0bfe617 	ldw	r2,-104(fp)
 8236e4c:	10c00915 	stw	r3,36(r2)
 8236e50:	e0bfe617 	ldw	r2,-104(fp)
 8236e54:	10c00917 	ldw	r3,36(r2)
 8236e58:	d0a03c83 	ldbu	r2,-32526(gp)
 8236e5c:	10803fcc 	andi	r2,r2,255
 8236e60:	1080201c 	xori	r2,r2,128
 8236e64:	10bfe004 	addi	r2,r2,-128
 8236e68:	18803b1e 	bne	r3,r2,8236f58 <tcp_input+0x188c>
            {
               tcp_seq onxt = tp->snd_nxt;
 8236e6c:	e0bfe617 	ldw	r2,-104(fp)
 8236e70:	10800f17 	ldw	r2,60(r2)
 8236e74:	e0bff815 	stw	r2,-32(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8236e78:	e0bfe617 	ldw	r2,-104(fp)
 8236e7c:	11001417 	ldw	r4,80(r2)
 8236e80:	e0bfe617 	ldw	r2,-104(fp)
 8236e84:	10c01b17 	ldw	r3,108(r2)
 8236e88:	2005883a 	mov	r2,r4
 8236e8c:	1880012e 	bgeu	r3,r2,8236e94 <tcp_input+0x17c8>
 8236e90:	1805883a 	mov	r2,r3
 8236e94:	1006d07a 	srli	r3,r2,1
               tp->t_maxseg;
 8236e98:	e0bfe617 	ldw	r2,-104(fp)
 8236e9c:	10800a0b 	ldhu	r2,40(r2)
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8236ea0:	10bfffcc 	andi	r2,r2,65535
 8236ea4:	100b883a 	mov	r5,r2
 8236ea8:	1809883a 	mov	r4,r3
 8236eac:	820295c0 	call	820295c <__udivsi3>
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
 8236eb0:	e0bff00d 	sth	r2,-64(fp)
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;

               if (win < 2)
 8236eb4:	e0bff00b 	ldhu	r2,-64(fp)
 8236eb8:	108000a8 	cmpgeui	r2,r2,2
 8236ebc:	1000021e 	bne	r2,zero,8236ec8 <tcp_input+0x17fc>
                  win = 2;
 8236ec0:	00800084 	movi	r2,2
 8236ec4:	e0bff00d 	sth	r2,-64(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 8236ec8:	e0bfe617 	ldw	r2,-104(fp)
 8236ecc:	10c00a0b 	ldhu	r3,40(r2)
 8236ed0:	e0bff00b 	ldhu	r2,-64(fp)
 8236ed4:	1885383a 	mul	r2,r3,r2
 8236ed8:	10ffffcc 	andi	r3,r2,65535
 8236edc:	e0bfe617 	ldw	r2,-104(fp)
 8236ee0:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 8236ee4:	e0bfe617 	ldw	r2,-104(fp)
 8236ee8:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 8236eec:	e0bfe617 	ldw	r2,-104(fp)
 8236ef0:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 8236ef4:	e0bff217 	ldw	r2,-56(fp)
 8236ef8:	10c00717 	ldw	r3,28(r2)
 8236efc:	e0bfe617 	ldw	r2,-104(fp)
 8236f00:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 8236f04:	e0bfe617 	ldw	r2,-104(fp)
 8236f08:	10800a0b 	ldhu	r2,40(r2)
 8236f0c:	10ffffcc 	andi	r3,r2,65535
 8236f10:	e0bfe617 	ldw	r2,-104(fp)
 8236f14:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 8236f18:	e13fe617 	ldw	r4,-104(fp)
 8236f1c:	823804c0 	call	823804c <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 8236f20:	e0bfe617 	ldw	r2,-104(fp)
 8236f24:	10800f17 	ldw	r2,60(r2)
 8236f28:	e0fff817 	ldw	r3,-32(fp)
 8236f2c:	1885c83a 	sub	r2,r3,r2
 8236f30:	0080030e 	bge	zero,r2,8236f40 <tcp_input+0x1874>
                  tp->snd_nxt = onxt;
 8236f34:	e0bfe617 	ldw	r2,-104(fp)
 8236f38:	e0fff817 	ldw	r3,-32(fp)
 8236f3c:	10c00f15 	stw	r3,60(r2)
               GOTO_DROP;
 8236f40:	00814544 	movi	r2,1301
 8236f44:	d0a0b215 	stw	r2,-32056(gp)
 8236f48:	00029206 	br	8237994 <tcp_input+0x22c8>
            }
         } else
            tp->t_dupacks = 0;
 8236f4c:	e0bfe617 	ldw	r2,-104(fp)
 8236f50:	10000915 	stw	zero,36(r2)
         break;
 8236f54:	0000da06 	br	82372c0 <tcp_input+0x1bf4>
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236f58:	0001883a 	nop
                  tp->snd_nxt = onxt;
               GOTO_DROP;
            }
         } else
            tp->t_dupacks = 0;
         break;
 8236f5c:	0000d806 	br	82372c0 <tcp_input+0x1bf4>
      }
      tp->t_dupacks = 0;
 8236f60:	e0bfe617 	ldw	r2,-104(fp)
 8236f64:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 8236f68:	e0bff217 	ldw	r2,-56(fp)
 8236f6c:	10c00717 	ldw	r3,28(r2)
 8236f70:	e0bfe617 	ldw	r2,-104(fp)
 8236f74:	10801a17 	ldw	r2,104(r2)
 8236f78:	1885c83a 	sub	r2,r3,r2
 8236f7c:	0080080e 	bge	zero,r2,8236fa0 <tcp_input+0x18d4>
      {
         tcpstat.tcps_rcvacktoomuch++;
 8236f80:	008209b4 	movhi	r2,2086
 8236f84:	10b8aa04 	addi	r2,r2,-7512
 8236f88:	10802a17 	ldw	r2,168(r2)
 8236f8c:	10c00044 	addi	r3,r2,1
 8236f90:	008209b4 	movhi	r2,2086
 8236f94:	10b8aa04 	addi	r2,r2,-7512
 8236f98:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 8236f9c:	00022b06 	br	823784c <tcp_input+0x2180>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 8236fa0:	e0bff217 	ldw	r2,-56(fp)
 8236fa4:	10c00717 	ldw	r3,28(r2)
 8236fa8:	e0bfe617 	ldw	r2,-104(fp)
 8236fac:	10800e17 	ldw	r2,56(r2)
 8236fb0:	1885c83a 	sub	r2,r3,r2
 8236fb4:	e0bff615 	stw	r2,-40(fp)
      tcpstat.tcps_rcvackpack++;
 8236fb8:	008209b4 	movhi	r2,2086
 8236fbc:	10b8aa04 	addi	r2,r2,-7512
 8236fc0:	10802b17 	ldw	r2,172(r2)
 8236fc4:	10c00044 	addi	r3,r2,1
 8236fc8:	008209b4 	movhi	r2,2086
 8236fcc:	10b8aa04 	addi	r2,r2,-7512
 8236fd0:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 8236fd4:	008209b4 	movhi	r2,2086
 8236fd8:	10b8aa04 	addi	r2,r2,-7512
 8236fdc:	10c02c17 	ldw	r3,176(r2)
 8236fe0:	e0bff617 	ldw	r2,-40(fp)
 8236fe4:	1887883a 	add	r3,r3,r2
 8236fe8:	008209b4 	movhi	r2,2086
 8236fec:	10b8aa04 	addi	r2,r2,-7512
 8236ff0:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8236ff4:	e0bfe617 	ldw	r2,-104(fp)
 8236ff8:	10801e17 	ldw	r2,120(r2)
 8236ffc:	10000826 	beq	r2,zero,8237020 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8237000:	e0bff217 	ldw	r2,-56(fp)
 8237004:	10c00717 	ldw	r3,28(r2)
 8237008:	e0bfe617 	ldw	r2,-104(fp)
 823700c:	10801f17 	ldw	r2,124(r2)
 8237010:	1885c83a 	sub	r2,r3,r2
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8237014:	0080020e 	bge	zero,r2,8237020 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 8237018:	e13fe617 	ldw	r4,-104(fp)
 823701c:	8237cb00 	call	8237cb0 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 8237020:	e0bff217 	ldw	r2,-56(fp)
 8237024:	10c00717 	ldw	r3,28(r2)
 8237028:	e0bfe617 	ldw	r2,-104(fp)
 823702c:	10801a17 	ldw	r2,104(r2)
 8237030:	1880051e 	bne	r3,r2,8237048 <tcp_input+0x197c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 8237034:	e0bfe617 	ldw	r2,-104(fp)
 8237038:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 823703c:	00800044 	movi	r2,1
 8237040:	e0bfeb15 	stw	r2,-84(fp)
 8237044:	00000706 	br	8237064 <tcp_input+0x1998>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 8237048:	e0bfe617 	ldw	r2,-104(fp)
 823704c:	10800417 	ldw	r2,16(r2)
 8237050:	1000041e 	bne	r2,zero,8237064 <tcp_input+0x1998>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8237054:	e0bfe617 	ldw	r2,-104(fp)
 8237058:	10c00817 	ldw	r3,32(r2)
 823705c:	e0bfe617 	ldw	r2,-104(fp)
 8237060:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 8237064:	e0bfe617 	ldw	r2,-104(fp)
 8237068:	10801b17 	ldw	r2,108(r2)
 823706c:	e0bff915 	stw	r2,-28(fp)
         u_short  incr  =  tp->t_maxseg;
 8237070:	e0bfe617 	ldw	r2,-104(fp)
 8237074:	10800a0b 	ldhu	r2,40(r2)
 8237078:	e0bff08d 	sth	r2,-62(fp)

         if (cw > tp->snd_ssthresh)
 823707c:	e0bfe617 	ldw	r2,-104(fp)
 8237080:	10c01c17 	ldw	r3,112(r2)
 8237084:	e0bff917 	ldw	r2,-28(fp)
 8237088:	18800a2e 	bgeu	r3,r2,82370b4 <tcp_input+0x19e8>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 823708c:	e0fff08b 	ldhu	r3,-62(fp)
 8237090:	e0bff08b 	ldhu	r2,-62(fp)
 8237094:	1885383a 	mul	r2,r3,r2
 8237098:	e17ff917 	ldw	r5,-28(fp)
 823709c:	1009883a 	mov	r4,r2
 82370a0:	820295c0 	call	820295c <__udivsi3>
 82370a4:	10c00428 	cmpgeui	r3,r2,16
 82370a8:	1800011e 	bne	r3,zero,82370b0 <tcp_input+0x19e4>
 82370ac:	00800404 	movi	r2,16
 82370b0:	e0bff08d 	sth	r2,-62(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 82370b4:	e0fff08b 	ldhu	r3,-62(fp)
 82370b8:	e0bff917 	ldw	r2,-28(fp)
 82370bc:	1885883a 	add	r2,r3,r2
 82370c0:	10d80070 	cmpltui	r3,r2,24577
 82370c4:	1800011e 	bne	r3,zero,82370cc <tcp_input+0x1a00>
 82370c8:	00980004 	movi	r2,24576
 82370cc:	e0ffe617 	ldw	r3,-104(fp)
 82370d0:	18801b15 	stw	r2,108(r3)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 82370d4:	e0bfe817 	ldw	r2,-96(fp)
 82370d8:	10801217 	ldw	r2,72(r2)
 82370dc:	1007883a 	mov	r3,r2
 82370e0:	e0bff617 	ldw	r2,-40(fp)
 82370e4:	1880120e 	bge	r3,r2,8237130 <tcp_input+0x1a64>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 82370e8:	e0bfe617 	ldw	r2,-104(fp)
 82370ec:	10c01417 	ldw	r3,80(r2)
 82370f0:	e0bfe817 	ldw	r2,-96(fp)
 82370f4:	10801217 	ldw	r2,72(r2)
 82370f8:	10bfffcc 	andi	r2,r2,65535
 82370fc:	1887c83a 	sub	r3,r3,r2
 8237100:	e0bfe617 	ldw	r2,-104(fp)
 8237104:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 8237108:	e0bfe817 	ldw	r2,-96(fp)
 823710c:	10c01204 	addi	r3,r2,72
 8237110:	e0bfe817 	ldw	r2,-96(fp)
 8237114:	10801217 	ldw	r2,72(r2)
 8237118:	100b883a 	mov	r5,r2
 823711c:	1809883a 	mov	r4,r3
 8237120:	82346f80 	call	82346f8 <sbdrop>
         ourfinisacked = 1;
 8237124:	00800044 	movi	r2,1
 8237128:	e0bfea15 	stw	r2,-88(fp)
 823712c:	00000d06 	br	8237164 <tcp_input+0x1a98>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 8237130:	e0bfe817 	ldw	r2,-96(fp)
 8237134:	10801204 	addi	r2,r2,72
 8237138:	e17ff617 	ldw	r5,-40(fp)
 823713c:	1009883a 	mov	r4,r2
 8237140:	82346f80 	call	82346f8 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 8237144:	e0bfe617 	ldw	r2,-104(fp)
 8237148:	10c01417 	ldw	r3,80(r2)
 823714c:	e0bff617 	ldw	r2,-40(fp)
 8237150:	10bfffcc 	andi	r2,r2,65535
 8237154:	1887c83a 	sub	r3,r3,r2
 8237158:	e0bfe617 	ldw	r2,-104(fp)
 823715c:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 8237160:	e03fea15 	stw	zero,-88(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8237164:	e0bfe817 	ldw	r2,-96(fp)
 8237168:	1080190b 	ldhu	r2,100(r2)
 823716c:	10bfffcc 	andi	r2,r2,65535
 8237170:	1080030c 	andi	r2,r2,12
 8237174:	10000526 	beq	r2,zero,823718c <tcp_input+0x1ac0>
         sowwakeup(so);
 8237178:	e0bfe817 	ldw	r2,-96(fp)
 823717c:	10801204 	addi	r2,r2,72
 8237180:	100b883a 	mov	r5,r2
 8237184:	e13fe817 	ldw	r4,-96(fp)
 8237188:	8233f900 	call	8233f90 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 823718c:	e0bff217 	ldw	r2,-56(fp)
 8237190:	10c00717 	ldw	r3,28(r2)
 8237194:	e0bfe617 	ldw	r2,-104(fp)
 8237198:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 823719c:	e0bfe617 	ldw	r2,-104(fp)
 82371a0:	10c00f17 	ldw	r3,60(r2)
 82371a4:	e0bfe617 	ldw	r2,-104(fp)
 82371a8:	10800e17 	ldw	r2,56(r2)
 82371ac:	1885c83a 	sub	r2,r3,r2
 82371b0:	1000040e 	bge	r2,zero,82371c4 <tcp_input+0x1af8>
         tp->snd_nxt = tp->snd_una;
 82371b4:	e0bfe617 	ldw	r2,-104(fp)
 82371b8:	10c00e17 	ldw	r3,56(r2)
 82371bc:	e0bfe617 	ldw	r2,-104(fp)
 82371c0:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 82371c4:	e0bfe617 	ldw	r2,-104(fp)
 82371c8:	10800217 	ldw	r2,8(r2)
 82371cc:	10c001e0 	cmpeqi	r3,r2,7
 82371d0:	18001a1e 	bne	r3,zero,823723c <tcp_input+0x1b70>
 82371d4:	10c00208 	cmpgei	r3,r2,8
 82371d8:	1800031e 	bne	r3,zero,82371e8 <tcp_input+0x1b1c>
 82371dc:	108001a0 	cmpeqi	r2,r2,6
 82371e0:	1000061e 	bne	r2,zero,82371fc <tcp_input+0x1b30>
 82371e4:	00003606 	br	82372c0 <tcp_input+0x1bf4>
 82371e8:	10c00220 	cmpeqi	r3,r2,8
 82371ec:	1800221e 	bne	r3,zero,8237278 <tcp_input+0x1bac>
 82371f0:	108002a0 	cmpeqi	r2,r2,10
 82371f4:	1000271e 	bne	r2,zero,8237294 <tcp_input+0x1bc8>
 82371f8:	00003106 	br	82372c0 <tcp_input+0x1bf4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 82371fc:	e0bfea17 	ldw	r2,-88(fp)
 8237200:	10002a26 	beq	r2,zero,82372ac <tcp_input+0x1be0>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 8237204:	e0bfe817 	ldw	r2,-96(fp)
 8237208:	1080088b 	ldhu	r2,34(r2)
 823720c:	10bfffcc 	andi	r2,r2,65535
 8237210:	1080080c 	andi	r2,r2,32
 8237214:	10000526 	beq	r2,zero,823722c <tcp_input+0x1b60>
            {
               soisdisconnected(so);
 8237218:	e13fe817 	ldw	r4,-96(fp)
 823721c:	82339c00 	call	82339c0 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 8237220:	d0e0b417 	ldw	r3,-32048(gp)
 8237224:	e0bfe617 	ldw	r2,-104(fp)
 8237228:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 823722c:	e0bfe617 	ldw	r2,-104(fp)
 8237230:	00c00244 	movi	r3,9
 8237234:	10c00215 	stw	r3,8(r2)
         }
         break;
 8237238:	00001c06 	br	82372ac <tcp_input+0x1be0>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 823723c:	e0bfea17 	ldw	r2,-88(fp)
 8237240:	10001c26 	beq	r2,zero,82372b4 <tcp_input+0x1be8>
         {
            tp->t_state = TCPS_TIME_WAIT;
 8237244:	e0bfe617 	ldw	r2,-104(fp)
 8237248:	00c00284 	movi	r3,10
 823724c:	10c00215 	stw	r3,8(r2)
            tcp_canceltimers(tp);
 8237250:	e13fe617 	ldw	r4,-104(fp)
 8237254:	8239dc40 	call	8239dc4 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237258:	d0a03b17 	ldw	r2,-32532(gp)
 823725c:	1085883a 	add	r2,r2,r2
 8237260:	1007883a 	mov	r3,r2
 8237264:	e0bfe617 	ldw	r2,-104(fp)
 8237268:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 823726c:	e13fe817 	ldw	r4,-96(fp)
 8237270:	82339c00 	call	82339c0 <soisdisconnected>
         }
         break;
 8237274:	00000f06 	br	82372b4 <tcp_input+0x1be8>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 8237278:	e0bfea17 	ldw	r2,-88(fp)
 823727c:	10000f26 	beq	r2,zero,82372bc <tcp_input+0x1bf0>
         {
            SETTP(tp, tcp_close(tp));
 8237280:	e13fe617 	ldw	r4,-104(fp)
 8237284:	823992c0 	call	823992c <tcp_close>
            GOTO_DROP;
 8237288:	00816644 	movi	r2,1433
 823728c:	d0a0b215 	stw	r2,-32056(gp)
 8237290:	0001c006 	br	8237994 <tcp_input+0x22c8>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237294:	d0a03b17 	ldw	r2,-32532(gp)
 8237298:	1085883a 	add	r2,r2,r2
 823729c:	1007883a 	mov	r3,r2
 82372a0:	e0bfe617 	ldw	r2,-104(fp)
 82372a4:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 82372a8:	00016806 	br	823784c <tcp_input+0x2180>
               soisdisconnected(so);
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
            }
            tp->t_state = TCPS_FIN_WAIT_2;
         }
         break;
 82372ac:	0001883a 	nop
 82372b0:	00000306 	br	82372c0 <tcp_input+0x1bf4>
            tp->t_state = TCPS_TIME_WAIT;
            tcp_canceltimers(tp);
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
            soisdisconnected(so);
         }
         break;
 82372b4:	0001883a 	nop
 82372b8:	00000106 	br	82372c0 <tcp_input+0x1bf4>
         if (ourfinisacked) 
         {
            SETTP(tp, tcp_close(tp));
            GOTO_DROP;
         }
         break;
 82372bc:	0001883a 	nop
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82372c0:	e0bfe717 	ldw	r2,-100(fp)
 82372c4:	1080040c 	andi	r2,r2,16
 82372c8:	10004426 	beq	r2,zero,82373dc <tcp_input+0x1d10>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82372cc:	e0bfe617 	ldw	r2,-104(fp)
 82372d0:	10c01117 	ldw	r3,68(r2)
 82372d4:	e0bff217 	ldw	r2,-56(fp)
 82372d8:	10800617 	ldw	r2,24(r2)
 82372dc:	1885c83a 	sub	r2,r3,r2
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82372e0:	10001416 	blt	r2,zero,8237334 <tcp_input+0x1c68>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82372e4:	e0bfe617 	ldw	r2,-104(fp)
 82372e8:	10c01117 	ldw	r3,68(r2)
 82372ec:	e0bff217 	ldw	r2,-56(fp)
 82372f0:	10800617 	ldw	r2,24(r2)
 82372f4:	1880391e 	bne	r3,r2,82373dc <tcp_input+0x1d10>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 82372f8:	e0bfe617 	ldw	r2,-104(fp)
 82372fc:	10c01217 	ldw	r3,72(r2)
 8237300:	e0bff217 	ldw	r2,-56(fp)
 8237304:	10800717 	ldw	r2,28(r2)
 8237308:	1885c83a 	sub	r2,r3,r2
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 823730c:	10000916 	blt	r2,zero,8237334 <tcp_input+0x1c68>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 8237310:	e0bfe617 	ldw	r2,-104(fp)
 8237314:	10c01217 	ldw	r3,72(r2)
 8237318:	e0bff217 	ldw	r2,-56(fp)
 823731c:	10800717 	ldw	r2,28(r2)
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 8237320:	18802e1e 	bne	r3,r2,82373dc <tcp_input+0x1d10>
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 8237324:	e0bfe617 	ldw	r2,-104(fp)
 8237328:	10c01417 	ldw	r3,80(r2)
 823732c:	e0bff517 	ldw	r2,-44(fp)
 8237330:	18802a2e 	bgeu	r3,r2,82373dc <tcp_input+0x1d10>
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237334:	e0bff217 	ldw	r2,-56(fp)
 8237338:	1080028b 	ldhu	r2,10(r2)
 823733c:	10bfffcc 	andi	r2,r2,65535
 8237340:	1000101e 	bne	r2,zero,8237384 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
 8237344:	e0bfe617 	ldw	r2,-104(fp)
 8237348:	10c01217 	ldw	r3,72(r2)
 823734c:	e0bff217 	ldw	r2,-56(fp)
 8237350:	10800717 	ldw	r2,28(r2)
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237354:	18800b1e 	bne	r3,r2,8237384 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
 8237358:	e0bfe617 	ldw	r2,-104(fp)
 823735c:	10c01417 	ldw	r3,80(r2)
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
          (tp->snd_wl2 == ti->ti_ack) &&
 8237360:	e0bff517 	ldw	r2,-44(fp)
 8237364:	1880072e 	bgeu	r3,r2,8237384 <tcp_input+0x1cb8>
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 8237368:	008209b4 	movhi	r2,2086
 823736c:	10b8aa04 	addi	r2,r2,-7512
 8237370:	10802d17 	ldw	r2,180(r2)
 8237374:	10c00044 	addi	r3,r2,1
 8237378:	008209b4 	movhi	r2,2086
 823737c:	10b8aa04 	addi	r2,r2,-7512
 8237380:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 8237384:	e0bfe617 	ldw	r2,-104(fp)
 8237388:	e0fff517 	ldw	r3,-44(fp)
 823738c:	10c01415 	stw	r3,80(r2)
      tp->snd_wl1 = ti->ti_seq;
 8237390:	e0bff217 	ldw	r2,-56(fp)
 8237394:	10c00617 	ldw	r3,24(r2)
 8237398:	e0bfe617 	ldw	r2,-104(fp)
 823739c:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 82373a0:	e0bff217 	ldw	r2,-56(fp)
 82373a4:	10c00717 	ldw	r3,28(r2)
 82373a8:	e0bfe617 	ldw	r2,-104(fp)
 82373ac:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 82373b0:	e0bfe617 	ldw	r2,-104(fp)
 82373b4:	10801417 	ldw	r2,80(r2)
 82373b8:	e0ffe617 	ldw	r3,-104(fp)
 82373bc:	18c02317 	ldw	r3,140(r3)
 82373c0:	1880042e 	bgeu	r3,r2,82373d4 <tcp_input+0x1d08>
         tp->max_sndwnd = tp->snd_wnd;
 82373c4:	e0bfe617 	ldw	r2,-104(fp)
 82373c8:	10c01417 	ldw	r3,80(r2)
 82373cc:	e0bfe617 	ldw	r2,-104(fp)
 82373d0:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 82373d4:	00800044 	movi	r2,1
 82373d8:	e0bfeb15 	stw	r2,-84(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 82373dc:	e0bfe717 	ldw	r2,-100(fp)
 82373e0:	1080080c 	andi	r2,r2,32
 82373e4:	10005626 	beq	r2,zero,8237540 <tcp_input+0x1e74>
 82373e8:	e0bff217 	ldw	r2,-56(fp)
 82373ec:	1080098b 	ldhu	r2,38(r2)
 82373f0:	10bfffcc 	andi	r2,r2,65535
 82373f4:	10005226 	beq	r2,zero,8237540 <tcp_input+0x1e74>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 82373f8:	e0bfe617 	ldw	r2,-104(fp)
 82373fc:	10800217 	ldw	r2,8(r2)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 8237400:	10800288 	cmpgei	r2,r2,10
 8237404:	10004e1e 	bne	r2,zero,8237540 <tcp_input+0x1e74>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 8237408:	e0bff217 	ldw	r2,-56(fp)
 823740c:	1080098b 	ldhu	r2,38(r2)
 8237410:	10ffffcc 	andi	r3,r2,65535
 8237414:	e0bfe817 	ldw	r2,-96(fp)
 8237418:	10800a17 	ldw	r2,40(r2)
 823741c:	1885883a 	add	r2,r3,r2
 8237420:	10900070 	cmpltui	r2,r2,16385
 8237424:	1000071e 	bne	r2,zero,8237444 <tcp_input+0x1d78>
      {
         ti->ti_urp = 0;         /* XXX */
 8237428:	e0bff217 	ldw	r2,-56(fp)
 823742c:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 8237430:	e0ffe717 	ldw	r3,-100(fp)
 8237434:	00bff7c4 	movi	r2,-33
 8237438:	1884703a 	and	r2,r3,r2
 823743c:	e0bfe715 	stw	r2,-100(fp)
         goto dodata;         /* XXX */
 8237440:	00004b06 	br	8237570 <tcp_input+0x1ea4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 8237444:	e0bff217 	ldw	r2,-56(fp)
 8237448:	10c00617 	ldw	r3,24(r2)
 823744c:	e0bff217 	ldw	r2,-56(fp)
 8237450:	1080098b 	ldhu	r2,38(r2)
 8237454:	10bfffcc 	andi	r2,r2,65535
 8237458:	1887883a 	add	r3,r3,r2
 823745c:	e0bfe617 	ldw	r2,-104(fp)
 8237460:	10801717 	ldw	r2,92(r2)
 8237464:	1885c83a 	sub	r2,r3,r2
 8237468:	0080250e 	bge	zero,r2,8237500 <tcp_input+0x1e34>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 823746c:	e0bff217 	ldw	r2,-56(fp)
 8237470:	10c00617 	ldw	r3,24(r2)
 8237474:	e0bff217 	ldw	r2,-56(fp)
 8237478:	1080098b 	ldhu	r2,38(r2)
 823747c:	10bfffcc 	andi	r2,r2,65535
 8237480:	1887883a 	add	r3,r3,r2
 8237484:	e0bfe617 	ldw	r2,-104(fp)
 8237488:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 823748c:	e0bfe817 	ldw	r2,-96(fp)
 8237490:	10c00a17 	ldw	r3,40(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
 8237494:	e0bfe617 	ldw	r2,-104(fp)
 8237498:	11001717 	ldw	r4,92(r2)
 823749c:	e0bfe617 	ldw	r2,-104(fp)
 82374a0:	10801617 	ldw	r2,88(r2)
 82374a4:	2085c83a 	sub	r2,r4,r2
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 82374a8:	1885883a 	add	r2,r3,r2
         (tp->rcv_up - tp->rcv_nxt) - 1;
 82374ac:	10ffffc4 	addi	r3,r2,-1
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 82374b0:	e0bfe817 	ldw	r2,-96(fp)
 82374b4:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 82374b8:	e0bfe817 	ldw	r2,-96(fp)
 82374bc:	10801a17 	ldw	r2,104(r2)
 82374c0:	1000061e 	bne	r2,zero,82374dc <tcp_input+0x1e10>
            so->so_state |= SS_RCVATMARK;
 82374c4:	e0bfe817 	ldw	r2,-96(fp)
 82374c8:	1080088b 	ldhu	r2,34(r2)
 82374cc:	10801014 	ori	r2,r2,64
 82374d0:	1007883a 	mov	r3,r2
 82374d4:	e0bfe817 	ldw	r2,-96(fp)
 82374d8:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 82374dc:	e13fe817 	ldw	r4,-96(fp)
 82374e0:	82337680 	call	8233768 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 82374e4:	e0bfe617 	ldw	r2,-104(fp)
 82374e8:	10c02403 	ldbu	r3,144(r2)
 82374ec:	00bfff04 	movi	r2,-4
 82374f0:	1884703a 	and	r2,r3,r2
 82374f4:	1007883a 	mov	r3,r2
 82374f8:	e0bfe617 	ldw	r2,-104(fp)
 82374fc:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237500:	e0bff217 	ldw	r2,-56(fp)
 8237504:	1100098b 	ldhu	r4,38(r2)
 8237508:	e0bff217 	ldw	r2,-56(fp)
 823750c:	10c0028b 	ldhu	r3,10(r2)
 8237510:	20bfffcc 	andi	r2,r4,65535
 8237514:	18ffffcc 	andi	r3,r3,65535
 8237518:	18801436 	bltu	r3,r2,823756c <tcp_input+0x1ea0>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
 823751c:	e0bfe817 	ldw	r2,-96(fp)
 8237520:	10800417 	ldw	r2,16(r2)
 8237524:	1080400c 	andi	r2,r2,256
 8237528:	1000101e 	bne	r2,zero,823756c <tcp_input+0x1ea0>
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 823752c:	e1bffe17 	ldw	r6,-8(fp)
 8237530:	e17ff217 	ldw	r5,-56(fp)
 8237534:	e13fe817 	ldw	r4,-96(fp)
 8237538:	8237b840 	call	8237b84 <tcp_pulloutofband>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 823753c:	00000b06 	br	823756c <tcp_input+0x1ea0>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 8237540:	e0bfe617 	ldw	r2,-104(fp)
 8237544:	10c01617 	ldw	r3,88(r2)
 8237548:	e0bfe617 	ldw	r2,-104(fp)
 823754c:	10801717 	ldw	r2,92(r2)
 8237550:	1885c83a 	sub	r2,r3,r2
 8237554:	0080060e 	bge	zero,r2,8237570 <tcp_input+0x1ea4>
      tp->rcv_up = tp->rcv_nxt;
 8237558:	e0bfe617 	ldw	r2,-104(fp)
 823755c:	10c01617 	ldw	r3,88(r2)
 8237560:	e0bfe617 	ldw	r2,-104(fp)
 8237564:	10c01715 	stw	r3,92(r2)
 8237568:	00000106 	br	8237570 <tcp_input+0x1ea4>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 823756c:	0001883a 	nop
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 8237570:	e0bff217 	ldw	r2,-56(fp)
 8237574:	1080028b 	ldhu	r2,10(r2)
 8237578:	10bfffcc 	andi	r2,r2,65535
 823757c:	1000031e 	bne	r2,zero,823758c <tcp_input+0x1ec0>
 8237580:	e0bfe717 	ldw	r2,-100(fp)
 8237584:	1080004c 	andi	r2,r2,1
 8237588:	10005e26 	beq	r2,zero,8237704 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 823758c:	e0bfe617 	ldw	r2,-104(fp)
 8237590:	10800217 	ldw	r2,8(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 8237594:	10800288 	cmpgei	r2,r2,10
 8237598:	10005a1e 	bne	r2,zero,8237704 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 823759c:	e0bff217 	ldw	r2,-56(fp)
 82375a0:	10c00617 	ldw	r3,24(r2)
 82375a4:	e0bfe617 	ldw	r2,-104(fp)
 82375a8:	10801617 	ldw	r2,88(r2)
 82375ac:	1880371e 	bne	r3,r2,823768c <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82375b0:	e0bfe617 	ldw	r2,-104(fp)
 82375b4:	10c00017 	ldw	r3,0(r2)
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 82375b8:	e0bfe617 	ldw	r2,-104(fp)
 82375bc:	1880331e 	bne	r3,r2,823768c <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
         (tp->t_state == TCPS_ESTABLISHED))
 82375c0:	e0bfe617 	ldw	r2,-104(fp)
 82375c4:	10800217 	ldw	r2,8(r2)
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82375c8:	10800118 	cmpnei	r2,r2,4
 82375cc:	10002f1e 	bne	r2,zero,823768c <tcp_input+0x1fc0>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 82375d0:	e0bfe617 	ldw	r2,-104(fp)
 82375d4:	10800b0b 	ldhu	r2,44(r2)
 82375d8:	10800054 	ori	r2,r2,1
 82375dc:	1007883a 	mov	r3,r2
 82375e0:	e0bfe617 	ldw	r2,-104(fp)
 82375e4:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 82375e8:	e0bfe617 	ldw	r2,-104(fp)
 82375ec:	10c01617 	ldw	r3,88(r2)
 82375f0:	e0bff217 	ldw	r2,-56(fp)
 82375f4:	1080028b 	ldhu	r2,10(r2)
 82375f8:	10bfffcc 	andi	r2,r2,65535
 82375fc:	1887883a 	add	r3,r3,r2
 8237600:	e0bfe617 	ldw	r2,-104(fp)
 8237604:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 8237608:	e0bff217 	ldw	r2,-56(fp)
 823760c:	10800843 	ldbu	r2,33(r2)
 8237610:	10803fcc 	andi	r2,r2,255
 8237614:	1080004c 	andi	r2,r2,1
 8237618:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpack++;
 823761c:	008209b4 	movhi	r2,2086
 8237620:	10b8aa04 	addi	r2,r2,-7512
 8237624:	10801a17 	ldw	r2,104(r2)
 8237628:	10c00044 	addi	r3,r2,1
 823762c:	008209b4 	movhi	r2,2086
 8237630:	10b8aa04 	addi	r2,r2,-7512
 8237634:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8237638:	008209b4 	movhi	r2,2086
 823763c:	10b8aa04 	addi	r2,r2,-7512
 8237640:	10c01b17 	ldw	r3,108(r2)
 8237644:	e0bff217 	ldw	r2,-56(fp)
 8237648:	1080028b 	ldhu	r2,10(r2)
 823764c:	10bfffcc 	andi	r2,r2,65535
 8237650:	1887883a 	add	r3,r3,r2
 8237654:	008209b4 	movhi	r2,2086
 8237658:	10b8aa04 	addi	r2,r2,-7512
 823765c:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 8237660:	e0bfe817 	ldw	r2,-96(fp)
 8237664:	10800a04 	addi	r2,r2,40
 8237668:	e17ffe17 	ldw	r5,-8(fp)
 823766c:	1009883a 	mov	r4,r2
 8237670:	82341400 	call	8234140 <sbappend>
         sorwakeup(so);
 8237674:	e0bfe817 	ldw	r2,-96(fp)
 8237678:	10800a04 	addi	r2,r2,40
 823767c:	100b883a 	mov	r5,r2
 8237680:	e13fe817 	ldw	r4,-96(fp)
 8237684:	8233f900 	call	8233f90 <sbwakeup>
 8237688:	00000b06 	br	82376b8 <tcp_input+0x1fec>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 823768c:	e1bffe17 	ldw	r6,-8(fp)
 8237690:	e17ff217 	ldw	r5,-56(fp)
 8237694:	e13fe617 	ldw	r4,-104(fp)
 8237698:	82352bc0 	call	82352bc <tcp_reass>
 823769c:	e0bfe715 	stw	r2,-100(fp)
         tp->t_flags |= TF_ACKNOW;
 82376a0:	e0bfe617 	ldw	r2,-104(fp)
 82376a4:	10800b0b 	ldhu	r2,44(r2)
 82376a8:	10800054 	ori	r2,r2,1
 82376ac:	1007883a 	mov	r3,r2
 82376b0:	e0bfe617 	ldw	r2,-104(fp)
 82376b4:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 82376b8:	e0bfe817 	ldw	r2,-96(fp)
 82376bc:	10c00b17 	ldw	r3,44(r2)
 82376c0:	e0bfe617 	ldw	r2,-104(fp)
 82376c4:	11001617 	ldw	r4,88(r2)
 82376c8:	e0bfe617 	ldw	r2,-104(fp)
 82376cc:	10801917 	ldw	r2,100(r2)
 82376d0:	2085c83a 	sub	r2,r4,r2
 82376d4:	1885883a 	add	r2,r3,r2
 82376d8:	e0bffc15 	stw	r2,-16(fp)
      if (len > (int)tp->max_rcvd)
 82376dc:	e0bfe617 	ldw	r2,-104(fp)
 82376e0:	10802217 	ldw	r2,136(r2)
 82376e4:	1007883a 	mov	r3,r2
 82376e8:	e0bffc17 	ldw	r2,-16(fp)
 82376ec:	18800b0e 	bge	r3,r2,823771c <tcp_input+0x2050>
         tp->max_rcvd = (u_short)len;
 82376f0:	e0bffc17 	ldw	r2,-16(fp)
 82376f4:	10ffffcc 	andi	r3,r2,65535
 82376f8:	e0bfe617 	ldw	r2,-104(fp)
 82376fc:	10c02215 	stw	r3,136(r2)
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
      if (len > (int)tp->max_rcvd)
 8237700:	00000606 	br	823771c <tcp_input+0x2050>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 8237704:	e13ffe17 	ldw	r4,-8(fp)
 8237708:	822e3840 	call	822e384 <m_freem>
      tiflags &= ~TH_FIN;
 823770c:	e0ffe717 	ldw	r3,-100(fp)
 8237710:	00bfff84 	movi	r2,-2
 8237714:	1884703a 	and	r2,r3,r2
 8237718:	e0bfe715 	stw	r2,-100(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 823771c:	e0bfe717 	ldw	r2,-100(fp)
 8237720:	1080004c 	andi	r2,r2,1
 8237724:	10003f26 	beq	r2,zero,8237824 <tcp_input+0x2158>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 8237728:	e0bfe617 	ldw	r2,-104(fp)
 823772c:	10800217 	ldw	r2,8(r2)
 8237730:	10800288 	cmpgei	r2,r2,10
 8237734:	10000d1e 	bne	r2,zero,823776c <tcp_input+0x20a0>
      {
         socantrcvmore(so);
 8237738:	e13fe817 	ldw	r4,-96(fp)
 823773c:	8233e900 	call	8233e90 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 8237740:	e0bfe617 	ldw	r2,-104(fp)
 8237744:	10800b0b 	ldhu	r2,44(r2)
 8237748:	10800054 	ori	r2,r2,1
 823774c:	1007883a 	mov	r3,r2
 8237750:	e0bfe617 	ldw	r2,-104(fp)
 8237754:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 8237758:	e0bfe617 	ldw	r2,-104(fp)
 823775c:	10801617 	ldw	r2,88(r2)
 8237760:	10c00044 	addi	r3,r2,1
 8237764:	e0bfe617 	ldw	r2,-104(fp)
 8237768:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 823776c:	e0bfe617 	ldw	r2,-104(fp)
 8237770:	10800217 	ldw	r2,8(r2)
 8237774:	10bfff44 	addi	r2,r2,-3
 8237778:	10c00228 	cmpgeui	r3,r2,8
 823777c:	1800291e 	bne	r3,zero,8237824 <tcp_input+0x2158>
 8237780:	100690ba 	slli	r3,r2,2
 8237784:	008208f4 	movhi	r2,2083
 8237788:	109de604 	addi	r2,r2,30616
 823778c:	1885883a 	add	r2,r3,r2
 8237790:	10800017 	ldw	r2,0(r2)
 8237794:	1000683a 	jmp	r2
 8237798:	082377b8 	rdprs	zero,at,-29218
 823779c:	082377b8 	rdprs	zero,at,-29218
 82377a0:	08237824 	muli	zero,at,-29216
 82377a4:	082377c8 	cmpgei	zero,at,-29217
 82377a8:	08237824 	muli	zero,at,-29216
 82377ac:	08237824 	muli	zero,at,-29216
 82377b0:	082377d8 	cmpnei	zero,at,-29217
 82377b4:	0823780c 	andi	zero,at,36320
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 82377b8:	e0bfe617 	ldw	r2,-104(fp)
 82377bc:	00c00144 	movi	r3,5
 82377c0:	10c00215 	stw	r3,8(r2)
         break;
 82377c4:	00001706 	br	8237824 <tcp_input+0x2158>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 82377c8:	e0bfe617 	ldw	r2,-104(fp)
 82377cc:	00c001c4 	movi	r3,7
 82377d0:	10c00215 	stw	r3,8(r2)
         break;
 82377d4:	00001306 	br	8237824 <tcp_input+0x2158>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 82377d8:	e0bfe617 	ldw	r2,-104(fp)
 82377dc:	00c00284 	movi	r3,10
 82377e0:	10c00215 	stw	r3,8(r2)
         tcp_canceltimers(tp);
 82377e4:	e13fe617 	ldw	r4,-104(fp)
 82377e8:	8239dc40 	call	8239dc4 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 82377ec:	d0a03b17 	ldw	r2,-32532(gp)
 82377f0:	1085883a 	add	r2,r2,r2
 82377f4:	1007883a 	mov	r3,r2
 82377f8:	e0bfe617 	ldw	r2,-104(fp)
 82377fc:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 8237800:	e13fe817 	ldw	r4,-96(fp)
 8237804:	82339c00 	call	82339c0 <soisdisconnected>
         break;
 8237808:	00000606 	br	8237824 <tcp_input+0x2158>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 823780c:	d0a03b17 	ldw	r2,-32532(gp)
 8237810:	1085883a 	add	r2,r2,r2
 8237814:	1007883a 	mov	r3,r2
 8237818:	e0bfe617 	ldw	r2,-104(fp)
 823781c:	10c00615 	stw	r3,24(r2)
         break;
 8237820:	0001883a 	nop
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 8237824:	e0bfeb17 	ldw	r2,-84(fp)
 8237828:	1000051e 	bne	r2,zero,8237840 <tcp_input+0x2174>
 823782c:	e0bfe617 	ldw	r2,-104(fp)
 8237830:	10800b0b 	ldhu	r2,44(r2)
 8237834:	10bfffcc 	andi	r2,r2,65535
 8237838:	1080004c 	andi	r2,r2,1
 823783c:	10006526 	beq	r2,zero,82379d4 <tcp_input+0x2308>
      (void) tcp_output(tp);
 8237840:	e13fe617 	ldw	r4,-104(fp)
 8237844:	823804c0 	call	823804c <tcp_output>
   return;
 8237848:	00006206 	br	82379d4 <tcp_input+0x2308>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 823784c:	e0bfe717 	ldw	r2,-100(fp)
 8237850:	1080010c 	andi	r2,r2,4
 8237854:	10000326 	beq	r2,zero,8237864 <tcp_input+0x2198>
      GOTO_DROP;
 8237858:	0081a904 	movi	r2,1700
 823785c:	d0a0b215 	stw	r2,-32056(gp)
 8237860:	00004c06 	br	8237994 <tcp_input+0x22c8>
   m_freem (m);
 8237864:	e13ffe17 	ldw	r4,-8(fp)
 8237868:	822e3840 	call	822e384 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 823786c:	e0bfe617 	ldw	r2,-104(fp)
 8237870:	10800b0b 	ldhu	r2,44(r2)
 8237874:	10800054 	ori	r2,r2,1
 8237878:	1007883a 	mov	r3,r2
 823787c:	e0bfe617 	ldw	r2,-104(fp)
 8237880:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 8237884:	e13fe617 	ldw	r4,-104(fp)
 8237888:	823804c0 	call	823804c <tcp_output>
   return;
 823788c:	00005606 	br	82379e8 <tcp_input+0x231c>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 8237890:	008209b4 	movhi	r2,2086
 8237894:	10b87c04 	addi	r2,r2,-7696
 8237898:	10800d17 	ldw	r2,52(r2)
 823789c:	10c00044 	addi	r3,r2,1
 82378a0:	008209b4 	movhi	r2,2086
 82378a4:	10b87c04 	addi	r2,r2,-7696
 82378a8:	10c00d15 	stw	r3,52(r2)
   if (om) 
 82378ac:	e0bfe517 	ldw	r2,-108(fp)
 82378b0:	10000326 	beq	r2,zero,82378c0 <tcp_input+0x21f4>
   {
      (void) m_free(om);
 82378b4:	e13fe517 	ldw	r4,-108(fp)
 82378b8:	822e27c0 	call	822e27c <m_free>
      om = 0;
 82378bc:	e03fe515 	stw	zero,-108(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 82378c0:	e0bfe717 	ldw	r2,-100(fp)
 82378c4:	1080010c 	andi	r2,r2,4
 82378c8:	10000326 	beq	r2,zero,82378d8 <tcp_input+0x220c>
      GOTO_DROP;
 82378cc:	0081ad04 	movi	r2,1716
 82378d0:	d0a0b215 	stw	r2,-32056(gp)
 82378d4:	00002f06 	br	8237994 <tcp_input+0x22c8>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 82378d8:	e0bff217 	ldw	r2,-56(fp)
 82378dc:	10800417 	ldw	r2,16(r2)
 82378e0:	1009883a 	mov	r4,r2
 82378e4:	822f2d00 	call	822f2d0 <in_broadcast>
 82378e8:	10000326 	beq	r2,zero,82378f8 <tcp_input+0x222c>
      GOTO_DROP;
 82378ec:	0081af44 	movi	r2,1725
 82378f0:	d0a0b215 	stw	r2,-32056(gp)
 82378f4:	00002706 	br	8237994 <tcp_input+0x22c8>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 82378f8:	e0bfe717 	ldw	r2,-100(fp)
 82378fc:	1080040c 	andi	r2,r2,16
 8237900:	10000c26 	beq	r2,zero,8237934 <tcp_input+0x2268>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 8237904:	e0bff217 	ldw	r2,-56(fp)
 8237908:	10c00717 	ldw	r3,28(r2)
 823790c:	e0bffe17 	ldw	r2,-8(fp)
 8237910:	d8800115 	stw	r2,4(sp)
 8237914:	00800104 	movi	r2,4
 8237918:	d8800015 	stw	r2,0(sp)
 823791c:	180f883a 	mov	r7,r3
 8237920:	000d883a 	mov	r6,zero
 8237924:	e17ff217 	ldw	r5,-56(fp)
 8237928:	e13fe617 	ldw	r4,-104(fp)
 823792c:	82393740 	call	8239374 <tcp_respond>
 8237930:	00001306 	br	8237980 <tcp_input+0x22b4>
   else
   {
      if (tiflags & TH_SYN)
 8237934:	e0bfe717 	ldw	r2,-100(fp)
 8237938:	1080008c 	andi	r2,r2,2
 823793c:	10000526 	beq	r2,zero,8237954 <tcp_input+0x2288>
         ti->ti_seq++;
 8237940:	e0bff217 	ldw	r2,-56(fp)
 8237944:	10800617 	ldw	r2,24(r2)
 8237948:	10c00044 	addi	r3,r2,1
 823794c:	e0bff217 	ldw	r2,-56(fp)
 8237950:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 8237954:	e0bff217 	ldw	r2,-56(fp)
 8237958:	10c00617 	ldw	r3,24(r2)
 823795c:	e0bffe17 	ldw	r2,-8(fp)
 8237960:	d8800115 	stw	r2,4(sp)
 8237964:	00800504 	movi	r2,20
 8237968:	d8800015 	stw	r2,0(sp)
 823796c:	000f883a 	mov	r7,zero
 8237970:	180d883a 	mov	r6,r3
 8237974:	e17ff217 	ldw	r5,-56(fp)
 8237978:	e13fe617 	ldw	r4,-104(fp)
 823797c:	82393740 	call	8239374 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 8237980:	e0bfec17 	ldw	r2,-80(fp)
 8237984:	10001526 	beq	r2,zero,82379dc <tcp_input+0x2310>
      (void) soabort(so);
 8237988:	e13fe817 	ldw	r4,-96(fp)
 823798c:	8231e200 	call	8231e20 <soabort>
   return;
 8237990:	00001206 	br	82379dc <tcp_input+0x2310>

drop:
   if (om)
 8237994:	e0bfe517 	ldw	r2,-108(fp)
 8237998:	10000226 	beq	r2,zero,82379a4 <tcp_input+0x22d8>
      (void) m_free(om);
 823799c:	e13fe517 	ldw	r4,-108(fp)
 82379a0:	822e27c0 	call	822e27c <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 82379a4:	e13ffe17 	ldw	r4,-8(fp)
 82379a8:	822e3840 	call	822e384 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 82379ac:	e0bfec17 	ldw	r2,-80(fp)
 82379b0:	10000c26 	beq	r2,zero,82379e4 <tcp_input+0x2318>
      (void) soabort(so);
 82379b4:	e13fe817 	ldw	r4,-96(fp)
 82379b8:	8231e200 	call	8231e20 <soabort>
   return;
 82379bc:	0001883a 	nop
 82379c0:	00000806 	br	82379e4 <tcp_input+0x2318>
            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
 82379c4:	0001883a 	nop
 82379c8:	00000706 	br	82379e8 <tcp_input+0x231c>
            tp->t_flags |= TF_ACKNOW;
            tp->t_flags &= ~TF_DELACK;
            tcp_output(tp);   /* send the ack now... */
         }

         return;
 82379cc:	0001883a 	nop
 82379d0:	00000506 	br	82379e8 <tcp_input+0x231c>
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
      (void) tcp_output(tp);
   return;
 82379d4:	0001883a 	nop
 82379d8:	00000306 	br	82379e8 <tcp_input+0x231c>
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
   }
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 82379dc:	0001883a 	nop
 82379e0:	00000106 	br	82379e8 <tcp_input+0x231c>
#endif
   m_freem(m);
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 82379e4:	0001883a 	nop
}
 82379e8:	e037883a 	mov	sp,fp
 82379ec:	dfc00117 	ldw	ra,4(sp)
 82379f0:	df000017 	ldw	fp,0(sp)
 82379f4:	dec00204 	addi	sp,sp,8
 82379f8:	f800283a 	ret

082379fc <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 82379fc:	defff404 	addi	sp,sp,-48
 8237a00:	dfc00b15 	stw	ra,44(sp)
 8237a04:	df000a15 	stw	fp,40(sp)
 8237a08:	dc000915 	stw	r16,36(sp)
 8237a0c:	df000a04 	addi	fp,sp,40
 8237a10:	e13ffc15 	stw	r4,-16(fp)
 8237a14:	e17ffd15 	stw	r5,-12(fp)
 8237a18:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 8237a1c:	e0bffc17 	ldw	r2,-16(fp)
 8237a20:	10800d17 	ldw	r2,52(r2)
 8237a24:	10800817 	ldw	r2,32(r2)
 8237a28:	e0bff915 	stw	r2,-28(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 8237a2c:	e0bffd17 	ldw	r2,-12(fp)
 8237a30:	10800317 	ldw	r2,12(r2)
 8237a34:	e0bff615 	stw	r2,-40(fp)
   cnt = om->m_len;
 8237a38:	e0bffd17 	ldw	r2,-12(fp)
 8237a3c:	10800217 	ldw	r2,8(r2)
 8237a40:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237a44:	00004006 	br	8237b48 <tcp_dooptions+0x14c>
   {
      opt = cp[0];
 8237a48:	e0bff617 	ldw	r2,-40(fp)
 8237a4c:	10800003 	ldbu	r2,0(r2)
 8237a50:	10803fcc 	andi	r2,r2,255
 8237a54:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 8237a58:	e0bffa17 	ldw	r2,-24(fp)
 8237a5c:	10003d26 	beq	r2,zero,8237b54 <tcp_dooptions+0x158>
         break;
      if (opt == TCPOPT_NOP)
 8237a60:	e0bffa17 	ldw	r2,-24(fp)
 8237a64:	10800058 	cmpnei	r2,r2,1
 8237a68:	1000031e 	bne	r2,zero,8237a78 <tcp_dooptions+0x7c>
         optlen = 1;
 8237a6c:	00800044 	movi	r2,1
 8237a70:	e0bff715 	stw	r2,-36(fp)
 8237a74:	00000706 	br	8237a94 <tcp_dooptions+0x98>
      else 
      {
         optlen = cp[1];
 8237a78:	e0bff617 	ldw	r2,-40(fp)
 8237a7c:	10800044 	addi	r2,r2,1
 8237a80:	10800003 	ldbu	r2,0(r2)
 8237a84:	10803fcc 	andi	r2,r2,255
 8237a88:	e0bff715 	stw	r2,-36(fp)
         if (optlen <= 0)
 8237a8c:	e0bff717 	ldw	r2,-36(fp)
 8237a90:	0080320e 	bge	zero,r2,8237b5c <tcp_dooptions+0x160>
            break;
      }

      switch (opt) 
 8237a94:	e0bffa17 	ldw	r2,-24(fp)
 8237a98:	108000a0 	cmpeqi	r2,r2,2
 8237a9c:	1000011e 	bne	r2,zero,8237aa4 <tcp_dooptions+0xa8>
         }
         break;
#endif   /* TCP_TIMESTAMP */

      default:
         break;
 8237aa0:	00002106 	br	8237b28 <tcp_dooptions+0x12c>
      switch (opt) 
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 8237aa4:	e0bff717 	ldw	r2,-36(fp)
 8237aa8:	10800120 	cmpeqi	r2,r2,4
 8237aac:	10001b26 	beq	r2,zero,8237b1c <tcp_dooptions+0x120>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 8237ab0:	e0bffe17 	ldw	r2,-8(fp)
 8237ab4:	10800843 	ldbu	r2,33(r2)
 8237ab8:	10803fcc 	andi	r2,r2,255
 8237abc:	1080008c 	andi	r2,r2,2
 8237ac0:	10001826 	beq	r2,zero,8237b24 <tcp_dooptions+0x128>
            continue;
         mssval = *(u_short *)(cp + 2);
 8237ac4:	e0bff617 	ldw	r2,-40(fp)
 8237ac8:	1080008b 	ldhu	r2,2(r2)
 8237acc:	e0bffb0d 	sth	r2,-20(fp)
         mssval = ntohs(mssval);
 8237ad0:	e0bffb0b 	ldhu	r2,-20(fp)
 8237ad4:	1004d23a 	srli	r2,r2,8
 8237ad8:	1007883a 	mov	r3,r2
 8237adc:	e0bffb0b 	ldhu	r2,-20(fp)
 8237ae0:	1004923a 	slli	r2,r2,8
 8237ae4:	1884b03a 	or	r2,r3,r2
 8237ae8:	e0bffb0d 	sth	r2,-20(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 8237aec:	e43ffb0b 	ldhu	r16,-20(fp)
 8237af0:	e13ff917 	ldw	r4,-28(fp)
 8237af4:	8237f540 	call	8237f54 <tcp_mss>
 8237af8:	10bfffcc 	andi	r2,r2,65535
 8237afc:	1400030e 	bge	r2,r16,8237b0c <tcp_dooptions+0x110>
 8237b00:	e13ff917 	ldw	r4,-28(fp)
 8237b04:	8237f540 	call	8237f54 <tcp_mss>
 8237b08:	00000106 	br	8237b10 <tcp_dooptions+0x114>
 8237b0c:	e0bffb0b 	ldhu	r2,-20(fp)
 8237b10:	e0fffc17 	ldw	r3,-16(fp)
 8237b14:	18800a0d 	sth	r2,40(r3)
         break;
 8237b18:	00000306 	br	8237b28 <tcp_dooptions+0x12c>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
            continue;
 8237b1c:	0001883a 	nop
 8237b20:	00000106 	br	8237b28 <tcp_dooptions+0x12c>
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
            continue;
 8237b24:	0001883a 	nop
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237b28:	e0fff817 	ldw	r3,-32(fp)
 8237b2c:	e0bff717 	ldw	r2,-36(fp)
 8237b30:	1885c83a 	sub	r2,r3,r2
 8237b34:	e0bff815 	stw	r2,-32(fp)
 8237b38:	e0bff717 	ldw	r2,-36(fp)
 8237b3c:	e0fff617 	ldw	r3,-40(fp)
 8237b40:	1885883a 	add	r2,r3,r2
 8237b44:	e0bff615 	stw	r2,-40(fp)
 8237b48:	e0bff817 	ldw	r2,-32(fp)
 8237b4c:	00bfbe16 	blt	zero,r2,8237a48 <tcp_dooptions+0x4c>
 8237b50:	00000306 	br	8237b60 <tcp_dooptions+0x164>
   {
      opt = cp[0];
      if (opt == TCPOPT_EOL)
         break;
 8237b54:	0001883a 	nop
 8237b58:	00000106 	br	8237b60 <tcp_dooptions+0x164>
         optlen = 1;
      else 
      {
         optlen = cp[1];
         if (optlen <= 0)
            break;
 8237b5c:	0001883a 	nop

      default:
         break;
      }
   }
   (void) m_free(om);
 8237b60:	e13ffd17 	ldw	r4,-12(fp)
 8237b64:	822e27c0 	call	822e27c <m_free>
      if(!gotstamp)
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
 8237b68:	0001883a 	nop
}
 8237b6c:	e6ffff04 	addi	sp,fp,-4
 8237b70:	dfc00217 	ldw	ra,8(sp)
 8237b74:	df000117 	ldw	fp,4(sp)
 8237b78:	dc000017 	ldw	r16,0(sp)
 8237b7c:	dec00304 	addi	sp,sp,12
 8237b80:	f800283a 	ret

08237b84 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 8237b84:	defff804 	addi	sp,sp,-32
 8237b88:	dfc00715 	stw	ra,28(sp)
 8237b8c:	df000615 	stw	fp,24(sp)
 8237b90:	df000604 	addi	fp,sp,24
 8237b94:	e13ffd15 	stw	r4,-12(fp)
 8237b98:	e17ffe15 	stw	r5,-8(fp)
 8237b9c:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 8237ba0:	e0bffe17 	ldw	r2,-8(fp)
 8237ba4:	1080098b 	ldhu	r2,38(r2)
 8237ba8:	10bfffcc 	andi	r2,r2,65535
 8237bac:	10bfffc4 	addi	r2,r2,-1
 8237bb0:	e0bffa15 	stw	r2,-24(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237bb4:	00003206 	br	8237c80 <tcp_pulloutofband+0xfc>
   {
      if (m->m_len > (unsigned)cnt) 
 8237bb8:	e0bfff17 	ldw	r2,-4(fp)
 8237bbc:	10800217 	ldw	r2,8(r2)
 8237bc0:	e0fffa17 	ldw	r3,-24(fp)
 8237bc4:	1880242e 	bgeu	r3,r2,8237c58 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 8237bc8:	e0bfff17 	ldw	r2,-4(fp)
 8237bcc:	10c00317 	ldw	r3,12(r2)
 8237bd0:	e0bffa17 	ldw	r2,-24(fp)
 8237bd4:	1885883a 	add	r2,r3,r2
 8237bd8:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 8237bdc:	e0bffd17 	ldw	r2,-12(fp)
 8237be0:	10800117 	ldw	r2,4(r2)
 8237be4:	10800917 	ldw	r2,36(r2)
 8237be8:	e0bffc15 	stw	r2,-16(fp)

         tp->t_iobc = *cp;
 8237bec:	e0bffb17 	ldw	r2,-20(fp)
 8237bf0:	10c00003 	ldbu	r3,0(r2)
 8237bf4:	e0bffc17 	ldw	r2,-16(fp)
 8237bf8:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 8237bfc:	e0bffc17 	ldw	r2,-16(fp)
 8237c00:	10802403 	ldbu	r2,144(r2)
 8237c04:	10800054 	ori	r2,r2,1
 8237c08:	1007883a 	mov	r3,r2
 8237c0c:	e0bffc17 	ldw	r2,-16(fp)
 8237c10:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 8237c14:	e0bffb17 	ldw	r2,-20(fp)
 8237c18:	11000044 	addi	r4,r2,1
 8237c1c:	e0bfff17 	ldw	r2,-4(fp)
 8237c20:	10c00217 	ldw	r3,8(r2)
 8237c24:	e0bffa17 	ldw	r2,-24(fp)
 8237c28:	1885c83a 	sub	r2,r3,r2
 8237c2c:	10bfffc4 	addi	r2,r2,-1
 8237c30:	100d883a 	mov	r6,r2
 8237c34:	200b883a 	mov	r5,r4
 8237c38:	e13ffb17 	ldw	r4,-20(fp)
 8237c3c:	8202c5c0 	call	8202c5c <memcpy>
         m->m_len--;
 8237c40:	e0bfff17 	ldw	r2,-4(fp)
 8237c44:	10800217 	ldw	r2,8(r2)
 8237c48:	10ffffc4 	addi	r3,r2,-1
 8237c4c:	e0bfff17 	ldw	r2,-4(fp)
 8237c50:	10c00215 	stw	r3,8(r2)
         return;
 8237c54:	00001106 	br	8237c9c <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 8237c58:	e0fffa17 	ldw	r3,-24(fp)
 8237c5c:	e0bfff17 	ldw	r2,-4(fp)
 8237c60:	10800217 	ldw	r2,8(r2)
 8237c64:	1885c83a 	sub	r2,r3,r2
 8237c68:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
 8237c6c:	e0bfff17 	ldw	r2,-4(fp)
 8237c70:	10800617 	ldw	r2,24(r2)
 8237c74:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 8237c78:	e0bfff17 	ldw	r2,-4(fp)
 8237c7c:	10000326 	beq	r2,zero,8237c8c <tcp_pulloutofband+0x108>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237c80:	e0bffa17 	ldw	r2,-24(fp)
 8237c84:	103fcc0e 	bge	r2,zero,8237bb8 <tcp_pulloutofband+0x34>
 8237c88:	00000106 	br	8237c90 <tcp_pulloutofband+0x10c>
         return;
      }
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
 8237c8c:	0001883a 	nop
   }
   panic("tcp_pulloutofband");
 8237c90:	01020974 	movhi	r4,2085
 8237c94:	2102bc04 	addi	r4,r4,2800
 8237c98:	82289940 	call	8228994 <panic>
}
 8237c9c:	e037883a 	mov	sp,fp
 8237ca0:	dfc00117 	ldw	ra,4(sp)
 8237ca4:	df000017 	ldw	fp,0(sp)
 8237ca8:	dec00204 	addi	sp,sp,8
 8237cac:	f800283a 	ret

08237cb0 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 8237cb0:	defffb04 	addi	sp,sp,-20
 8237cb4:	dfc00415 	stw	ra,16(sp)
 8237cb8:	df000315 	stw	fp,12(sp)
 8237cbc:	df000304 	addi	fp,sp,12
 8237cc0:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 8237cc4:	e0bfff17 	ldw	r2,-4(fp)
 8237cc8:	10801e17 	ldw	r2,120(r2)
 8237ccc:	1000021e 	bne	r2,zero,8237cd8 <tcp_xmit_timer+0x28>
 8237cd0:	822d2e00 	call	822d2e0 <dtrap>
 8237cd4:	00008806 	br	8237ef8 <tcp_xmit_timer+0x248>
#endif

   tcpstat.tcps_rttupdated++;
 8237cd8:	008209b4 	movhi	r2,2086
 8237cdc:	10b8aa04 	addi	r2,r2,-7512
 8237ce0:	10800717 	ldw	r2,28(r2)
 8237ce4:	10c00044 	addi	r3,r2,1
 8237ce8:	008209b4 	movhi	r2,2086
 8237cec:	10b8aa04 	addi	r2,r2,-7512
 8237cf0:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 8237cf4:	d0e0a817 	ldw	r3,-32096(gp)
 8237cf8:	e0bfff17 	ldw	r2,-4(fp)
 8237cfc:	10801e17 	ldw	r2,120(r2)
 8237d00:	1887c83a 	sub	r3,r3,r2
 8237d04:	00947b34 	movhi	r2,20972
 8237d08:	10a147c4 	addi	r2,r2,-31457
 8237d0c:	1888383a 	mulxuu	r4,r3,r2
 8237d10:	1885383a 	mul	r2,r3,r2
 8237d14:	100b883a 	mov	r5,r2
 8237d18:	200d883a 	mov	r6,r4
 8237d1c:	3004d13a 	srli	r2,r6,4
 8237d20:	e0bffe15 	stw	r2,-8(fp)
   if(tp->t_srtt != 0)
 8237d24:	e0bfff17 	ldw	r2,-4(fp)
 8237d28:	10802017 	ldw	r2,128(r2)
 8237d2c:	10004626 	beq	r2,zero,8237e48 <tcp_xmit_timer+0x198>
   {
      if(rtt == 0)      /* fast path for small round trip */
 8237d30:	e0bffe17 	ldw	r2,-8(fp)
 8237d34:	1000131e 	bne	r2,zero,8237d84 <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 8237d38:	e0bfff17 	ldw	r2,-4(fp)
 8237d3c:	10802017 	ldw	r2,128(r2)
 8237d40:	10800090 	cmplti	r2,r2,2
 8237d44:	1000051e 	bne	r2,zero,8237d5c <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 8237d48:	e0bfff17 	ldw	r2,-4(fp)
 8237d4c:	10802017 	ldw	r2,128(r2)
 8237d50:	10ffffc4 	addi	r3,r2,-1
 8237d54:	e0bfff17 	ldw	r2,-4(fp)
 8237d58:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 8237d5c:	e0bfff17 	ldw	r2,-4(fp)
 8237d60:	10802117 	ldw	r2,132(r2)
 8237d64:	10800090 	cmplti	r2,r2,2
 8237d68:	1000441e 	bne	r2,zero,8237e7c <tcp_xmit_timer+0x1cc>
            tp->t_rttvar--;
 8237d6c:	e0bfff17 	ldw	r2,-4(fp)
 8237d70:	10802117 	ldw	r2,132(r2)
 8237d74:	10ffffc4 	addi	r3,r2,-1
 8237d78:	e0bfff17 	ldw	r2,-4(fp)
 8237d7c:	10c02115 	stw	r3,132(r2)
 8237d80:	00003e06 	br	8237e7c <tcp_xmit_timer+0x1cc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 8237d84:	e0bffe17 	ldw	r2,-8(fp)
 8237d88:	10bfffc4 	addi	r2,r2,-1
 8237d8c:	1085883a 	add	r2,r2,r2
 8237d90:	1085883a 	add	r2,r2,r2
 8237d94:	1007883a 	mov	r3,r2
 8237d98:	e0bfff17 	ldw	r2,-4(fp)
 8237d9c:	10802017 	ldw	r2,128(r2)
 8237da0:	1005d0fa 	srai	r2,r2,3
 8237da4:	1885c83a 	sub	r2,r3,r2
 8237da8:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_srtt += delta) <= 0)
 8237dac:	e0bfff17 	ldw	r2,-4(fp)
 8237db0:	10c02017 	ldw	r3,128(r2)
 8237db4:	e0bffd17 	ldw	r2,-12(fp)
 8237db8:	1887883a 	add	r3,r3,r2
 8237dbc:	e0bfff17 	ldw	r2,-4(fp)
 8237dc0:	10c02015 	stw	r3,128(r2)
 8237dc4:	e0bfff17 	ldw	r2,-4(fp)
 8237dc8:	10802017 	ldw	r2,128(r2)
 8237dcc:	00800316 	blt	zero,r2,8237ddc <tcp_xmit_timer+0x12c>
         tp->t_srtt = 1;
 8237dd0:	e0bfff17 	ldw	r2,-4(fp)
 8237dd4:	00c00044 	movi	r3,1
 8237dd8:	10c02015 	stw	r3,128(r2)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 8237ddc:	e0bffd17 	ldw	r2,-12(fp)
 8237de0:	1000030e 	bge	r2,zero,8237df0 <tcp_xmit_timer+0x140>
         delta = -delta;
 8237de4:	e0bffd17 	ldw	r2,-12(fp)
 8237de8:	0085c83a 	sub	r2,zero,r2
 8237dec:	e0bffd15 	stw	r2,-12(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 8237df0:	e0bfff17 	ldw	r2,-4(fp)
 8237df4:	10802117 	ldw	r2,132(r2)
 8237df8:	1005d07a 	srai	r2,r2,1
 8237dfc:	10bfffcc 	andi	r2,r2,65535
 8237e00:	10a0001c 	xori	r2,r2,32768
 8237e04:	10a00004 	addi	r2,r2,-32768
 8237e08:	e0fffd17 	ldw	r3,-12(fp)
 8237e0c:	1885c83a 	sub	r2,r3,r2
 8237e10:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_rttvar += delta) <= 0)
 8237e14:	e0bfff17 	ldw	r2,-4(fp)
 8237e18:	10c02117 	ldw	r3,132(r2)
 8237e1c:	e0bffd17 	ldw	r2,-12(fp)
 8237e20:	1887883a 	add	r3,r3,r2
 8237e24:	e0bfff17 	ldw	r2,-4(fp)
 8237e28:	10c02115 	stw	r3,132(r2)
 8237e2c:	e0bfff17 	ldw	r2,-4(fp)
 8237e30:	10802117 	ldw	r2,132(r2)
 8237e34:	00801116 	blt	zero,r2,8237e7c <tcp_xmit_timer+0x1cc>
         tp->t_rttvar = 1;
 8237e38:	e0bfff17 	ldw	r2,-4(fp)
 8237e3c:	00c00044 	movi	r3,1
 8237e40:	10c02115 	stw	r3,132(r2)
 8237e44:	00000d06 	br	8237e7c <tcp_xmit_timer+0x1cc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 8237e48:	e0bffe17 	ldw	r2,-8(fp)
 8237e4c:	00800216 	blt	zero,r2,8237e58 <tcp_xmit_timer+0x1a8>
         rtt = 1;
 8237e50:	00800044 	movi	r2,1
 8237e54:	e0bffe15 	stw	r2,-8(fp)
      tp->t_srtt = rtt << 3;
 8237e58:	e0bffe17 	ldw	r2,-8(fp)
 8237e5c:	100690fa 	slli	r3,r2,3
 8237e60:	e0bfff17 	ldw	r2,-4(fp)
 8237e64:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 8237e68:	e0bffe17 	ldw	r2,-8(fp)
 8237e6c:	1085883a 	add	r2,r2,r2
 8237e70:	1007883a 	mov	r3,r2
 8237e74:	e0bfff17 	ldw	r2,-4(fp)
 8237e78:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 8237e7c:	e0bfff17 	ldw	r2,-4(fp)
 8237e80:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 8237e84:	e0bfff17 	ldw	r2,-4(fp)
 8237e88:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 8237e8c:	e0bfff17 	ldw	r2,-4(fp)
 8237e90:	10802017 	ldw	r2,128(r2)
 8237e94:	1007d0ba 	srai	r3,r2,2
 8237e98:	e0bfff17 	ldw	r2,-4(fp)
 8237e9c:	10802117 	ldw	r2,132(r2)
 8237ea0:	1885883a 	add	r2,r3,r2
 8237ea4:	1005d07a 	srai	r2,r2,1
 8237ea8:	10ffffcc 	andi	r3,r2,65535
 8237eac:	18e0001c 	xori	r3,r3,32768
 8237eb0:	18e00004 	addi	r3,r3,-32768
 8237eb4:	e0bfff17 	ldw	r2,-4(fp)
 8237eb8:	10c00815 	stw	r3,32(r2)
 8237ebc:	e0bfff17 	ldw	r2,-4(fp)
 8237ec0:	10800817 	ldw	r2,32(r2)
 8237ec4:	10800088 	cmpgei	r2,r2,2
 8237ec8:	1000041e 	bne	r2,zero,8237edc <tcp_xmit_timer+0x22c>
 8237ecc:	e0bfff17 	ldw	r2,-4(fp)
 8237ed0:	00c00084 	movi	r3,2
 8237ed4:	10c00815 	stw	r3,32(r2)
 8237ed8:	00000706 	br	8237ef8 <tcp_xmit_timer+0x248>
 8237edc:	e0bfff17 	ldw	r2,-4(fp)
 8237ee0:	10800817 	ldw	r2,32(r2)
 8237ee4:	10802050 	cmplti	r2,r2,129
 8237ee8:	1000031e 	bne	r2,zero,8237ef8 <tcp_xmit_timer+0x248>
 8237eec:	e0bfff17 	ldw	r2,-4(fp)
 8237ef0:	00c02004 	movi	r3,128
 8237ef4:	10c00815 	stw	r3,32(r2)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 8237ef8:	e037883a 	mov	sp,fp
 8237efc:	dfc00117 	ldw	ra,4(sp)
 8237f00:	df000017 	ldw	fp,0(sp)
 8237f04:	dec00204 	addi	sp,sp,8
 8237f08:	f800283a 	ret

08237f0c <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 8237f0c:	defffd04 	addi	sp,sp,-12
 8237f10:	df000215 	stw	fp,8(sp)
 8237f14:	df000204 	addi	fp,sp,8
 8237f18:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 8237f1c:	e0bfff17 	ldw	r2,-4(fp)
 8237f20:	10800117 	ldw	r2,4(r2)
 8237f24:	10800a17 	ldw	r2,40(r2)
 8237f28:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 8237f2c:	e0bffe17 	ldw	r2,-8(fp)
 8237f30:	10c00917 	ldw	r3,36(r2)
 8237f34:	e0bffe17 	ldw	r2,-8(fp)
 8237f38:	10800817 	ldw	r2,32(r2)
 8237f3c:	10800a04 	addi	r2,r2,40
 8237f40:	1885c83a 	sub	r2,r3,r2
}
 8237f44:	e037883a 	mov	sp,fp
 8237f48:	df000017 	ldw	fp,0(sp)
 8237f4c:	dec00104 	addi	sp,sp,4
 8237f50:	f800283a 	ret

08237f54 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 8237f54:	defffa04 	addi	sp,sp,-24
 8237f58:	dfc00515 	stw	ra,20(sp)
 8237f5c:	df000415 	stw	fp,16(sp)
 8237f60:	df000404 	addi	fp,sp,16
 8237f64:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 8237f68:	e0bfff17 	ldw	r2,-4(fp)
 8237f6c:	10000726 	beq	r2,zero,8237f8c <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
 8237f70:	e0bfff17 	ldw	r2,-4(fp)
 8237f74:	10800117 	ldw	r2,4(r2)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 8237f78:	10000426 	beq	r2,zero,8237f8c <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
 8237f7c:	e0bfff17 	ldw	r2,-4(fp)
 8237f80:	10800117 	ldw	r2,4(r2)
 8237f84:	10800a17 	ldw	r2,40(r2)
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
       (so->so_pcb == NULL) ||
 8237f88:	1000061e 	bne	r2,zero,8237fa4 <tcp_mss+0x50>
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 8237f8c:	e0bfff17 	ldw	r2,-4(fp)
 8237f90:	10800517 	ldw	r2,20(r2)
 8237f94:	10800098 	cmpnei	r2,r2,2
 8237f98:	1000021e 	bne	r2,zero,8237fa4 <tcp_mss+0x50>
         return TCP_MSS;            /* user defined */
 8237f9c:	00816d04 	movi	r2,1460
 8237fa0:	00002506 	br	8238038 <tcp_mss+0xe4>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 8237fa4:	e13fff17 	ldw	r4,-4(fp)
 8237fa8:	8237f0c0 	call	8237f0c <ip4_tcpmss>
 8237fac:	e0bffc15 	stw	r2,-16(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 8237fb0:	e0bffc17 	ldw	r2,-16(fp)
 8237fb4:	10816d50 	cmplti	r2,r2,1461
 8237fb8:	1000021e 	bne	r2,zero,8237fc4 <tcp_mss+0x70>
      mss = TCP_MSS;
 8237fbc:	00816d04 	movi	r2,1460
 8237fc0:	e0bffc15 	stw	r2,-16(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 8237fc4:	e0bfff17 	ldw	r2,-4(fp)
 8237fc8:	10800117 	ldw	r2,4(r2)
 8237fcc:	e0bffd15 	stw	r2,-12(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 8237fd0:	e0bffd17 	ldw	r2,-12(fp)
 8237fd4:	10800917 	ldw	r2,36(r2)
 8237fd8:	e0bffe15 	stw	r2,-8(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 8237fdc:	e0bffe17 	ldw	r2,-8(fp)
 8237fe0:	10800b0b 	ldhu	r2,44(r2)
 8237fe4:	10bfffcc 	andi	r2,r2,65535
 8237fe8:	1081000c 	andi	r2,r2,1024
 8237fec:	10000426 	beq	r2,zero,8238000 <tcp_mss+0xac>
      return tp->t_maxseg;    /* yup */
 8237ff0:	e0bffe17 	ldw	r2,-8(fp)
 8237ff4:	10800a0b 	ldhu	r2,40(r2)
 8237ff8:	10bfffcc 	andi	r2,r2,65535
 8237ffc:	00000e06 	br	8238038 <tcp_mss+0xe4>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 8238000:	e0bffe17 	ldw	r2,-8(fp)
 8238004:	10800a0b 	ldhu	r2,40(r2)
 8238008:	10bfffcc 	andi	r2,r2,65535
 823800c:	10000926 	beq	r2,zero,8238034 <tcp_mss+0xe0>
 8238010:	e0bffe17 	ldw	r2,-8(fp)
 8238014:	10800a0b 	ldhu	r2,40(r2)
 8238018:	10ffffcc 	andi	r3,r2,65535
 823801c:	e0bffc17 	ldw	r2,-16(fp)
 8238020:	1880040e 	bge	r3,r2,8238034 <tcp_mss+0xe0>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 8238024:	e0bffe17 	ldw	r2,-8(fp)
 8238028:	10800a0b 	ldhu	r2,40(r2)
 823802c:	10bfffcc 	andi	r2,r2,65535
 8238030:	e0bffc15 	stw	r2,-16(fp)
   }

   return mss;
 8238034:	e0bffc17 	ldw	r2,-16(fp)
}
 8238038:	e037883a 	mov	sp,fp
 823803c:	dfc00117 	ldw	ra,4(sp)
 8238040:	df000017 	ldw	fp,0(sp)
 8238044:	dec00204 	addi	sp,sp,8
 8238048:	f800283a 	ret

0823804c <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 823804c:	deffe804 	addi	sp,sp,-96
 8238050:	dfc01715 	stw	ra,92(sp)
 8238054:	df001615 	stw	fp,88(sp)
 8238058:	df001604 	addi	fp,sp,88
 823805c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8238060:	e0bfff17 	ldw	r2,-4(fp)
 8238064:	10800d17 	ldw	r2,52(r2)
 8238068:	10800817 	ldw	r2,32(r2)
 823806c:	e0bff215 	stw	r2,-56(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 8238070:	e03fee15 	stw	zero,-72(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 8238074:	e0bfff17 	ldw	r2,-4(fp)
 8238078:	10c01a17 	ldw	r3,104(r2)
 823807c:	e0bfff17 	ldw	r2,-4(fp)
 8238080:	10800e17 	ldw	r2,56(r2)
 8238084:	1885003a 	cmpeq	r2,r3,r2
 8238088:	10803fcc 	andi	r2,r2,255
 823808c:	e0bff315 	stw	r2,-52(fp)

again:
   sendalot = 0;
 8238090:	e03fef15 	stw	zero,-68(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 8238094:	e0bfff17 	ldw	r2,-4(fp)
 8238098:	10c00f17 	ldw	r3,60(r2)
 823809c:	e0bfff17 	ldw	r2,-4(fp)
 82380a0:	10800e17 	ldw	r2,56(r2)
 82380a4:	1885c83a 	sub	r2,r3,r2
 82380a8:	e0bff415 	stw	r2,-48(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 82380ac:	e0bfff17 	ldw	r2,-4(fp)
 82380b0:	10801417 	ldw	r2,80(r2)
 82380b4:	e0bfeb15 	stw	r2,-84(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 82380b8:	e0bfff17 	ldw	r2,-4(fp)
 82380bc:	10801b17 	ldw	r2,108(r2)
 82380c0:	1007883a 	mov	r3,r2
 82380c4:	e0bfeb17 	ldw	r2,-84(fp)
 82380c8:	1880060e 	bge	r3,r2,82380e4 <tcp_output+0x98>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 82380cc:	e0bfff17 	ldw	r2,-4(fp)
 82380d0:	10801b17 	ldw	r2,108(r2)
 82380d4:	1007883a 	mov	r3,r2
 82380d8:	00bfff04 	movi	r2,-4
 82380dc:	1884703a 	and	r2,r3,r2
 82380e0:	e0bfeb15 	stw	r2,-84(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 82380e4:	e0bfff17 	ldw	r2,-4(fp)
 82380e8:	10800a83 	ldbu	r2,42(r2)
 82380ec:	10803fcc 	andi	r2,r2,255
 82380f0:	1080201c 	xori	r2,r2,128
 82380f4:	10bfe004 	addi	r2,r2,-128
 82380f8:	10000926 	beq	r2,zero,8238120 <tcp_output+0xd4>
   {
      if (win == 0)
 82380fc:	e0bfeb17 	ldw	r2,-84(fp)
 8238100:	1000031e 	bne	r2,zero,8238110 <tcp_output+0xc4>
         win = 1;
 8238104:	00800044 	movi	r2,1
 8238108:	e0bfeb15 	stw	r2,-84(fp)
 823810c:	00000406 	br	8238120 <tcp_output+0xd4>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 8238110:	e0bfff17 	ldw	r2,-4(fp)
 8238114:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 8238118:	e0bfff17 	ldw	r2,-4(fp)
 823811c:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 8238120:	e0bff217 	ldw	r2,-56(fp)
 8238124:	10801217 	ldw	r2,72(r2)
 8238128:	e0ffeb17 	ldw	r3,-84(fp)
 823812c:	1880012e 	bgeu	r3,r2,8238134 <tcp_output+0xe8>
 8238130:	1805883a 	mov	r2,r3
 8238134:	1007883a 	mov	r3,r2
 8238138:	e0bff417 	ldw	r2,-48(fp)
 823813c:	1885c83a 	sub	r2,r3,r2
 8238140:	e0bfea15 	stw	r2,-88(fp)
   }

   flags = tcp_outflags[tp->t_state];
 8238144:	e0bfff17 	ldw	r2,-4(fp)
 8238148:	10c00217 	ldw	r3,8(r2)
 823814c:	00820974 	movhi	r2,2085
 8238150:	108de204 	addi	r2,r2,14216
 8238154:	10c5883a 	add	r2,r2,r3
 8238158:	10800003 	ldbu	r2,0(r2)
 823815c:	10803fcc 	andi	r2,r2,255
 8238160:	e0bfec15 	stw	r2,-80(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 8238164:	e0bfec17 	ldw	r2,-80(fp)
 8238168:	1080008c 	andi	r2,r2,2
 823816c:	10000926 	beq	r2,zero,8238194 <tcp_output+0x148>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 8238170:	e0ffee17 	ldw	r3,-72(fp)
 8238174:	d0a0b304 	addi	r2,gp,-32052
 8238178:	1885883a 	add	r2,r3,r2
 823817c:	e1fff217 	ldw	r7,-56(fp)
 8238180:	e1bfec17 	ldw	r6,-80(fp)
 8238184:	100b883a 	mov	r5,r2
 8238188:	e13fff17 	ldw	r4,-4(fp)
 823818c:	82391500 	call	8239150 <bld_options>
 8238190:	e0bfee15 	stw	r2,-72(fp)
   }
#endif

   if (len < 0)
 8238194:	e0bfea17 	ldw	r2,-88(fp)
 8238198:	1000090e 	bge	r2,zero,82381c0 <tcp_output+0x174>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 823819c:	e03fea15 	stw	zero,-88(fp)
      if (win == 0) 
 82381a0:	e0bfeb17 	ldw	r2,-84(fp)
 82381a4:	1000061e 	bne	r2,zero,82381c0 <tcp_output+0x174>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 82381a8:	e0bfff17 	ldw	r2,-4(fp)
 82381ac:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 82381b0:	e0bfff17 	ldw	r2,-4(fp)
 82381b4:	10c00e17 	ldw	r3,56(r2)
 82381b8:	e0bfff17 	ldw	r2,-4(fp)
 82381bc:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 82381c0:	e0bfff17 	ldw	r2,-4(fp)
 82381c4:	10800a0b 	ldhu	r2,40(r2)
 82381c8:	10ffffcc 	andi	r3,r2,65535
 82381cc:	e0bfea17 	ldw	r2,-88(fp)
 82381d0:	1880060e 	bge	r3,r2,82381ec <tcp_output+0x1a0>
   {
      len = tp->t_maxseg;
 82381d4:	e0bfff17 	ldw	r2,-4(fp)
 82381d8:	10800a0b 	ldhu	r2,40(r2)
 82381dc:	10bfffcc 	andi	r2,r2,65535
 82381e0:	e0bfea15 	stw	r2,-88(fp)
      sendalot = 1;
 82381e4:	00800044 	movi	r2,1
 82381e8:	e0bfef15 	stw	r2,-68(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 82381ec:	e0bfff17 	ldw	r2,-4(fp)
 82381f0:	10c00f17 	ldw	r3,60(r2)
 82381f4:	e0bfea17 	ldw	r2,-88(fp)
 82381f8:	1887883a 	add	r3,r3,r2
 82381fc:	e0bfff17 	ldw	r2,-4(fp)
 8238200:	11000e17 	ldw	r4,56(r2)
 8238204:	e0bff217 	ldw	r2,-56(fp)
 8238208:	10801217 	ldw	r2,72(r2)
 823820c:	2085883a 	add	r2,r4,r2
 8238210:	1885c83a 	sub	r2,r3,r2
 8238214:	1000040e 	bge	r2,zero,8238228 <tcp_output+0x1dc>
      flags &= ~TH_FIN;
 8238218:	e0ffec17 	ldw	r3,-80(fp)
 823821c:	00bfff84 	movi	r2,-2
 8238220:	1884703a 	and	r2,r3,r2
 8238224:	e0bfec15 	stw	r2,-80(fp)
   win = (long)(sbspace(&so->so_rcv));
 8238228:	e0bff217 	ldw	r2,-56(fp)
 823822c:	10800b17 	ldw	r2,44(r2)
 8238230:	1007883a 	mov	r3,r2
 8238234:	e0bff217 	ldw	r2,-56(fp)
 8238238:	10800a17 	ldw	r2,40(r2)
 823823c:	1885c83a 	sub	r2,r3,r2
 8238240:	10000616 	blt	r2,zero,823825c <tcp_output+0x210>
 8238244:	e0bff217 	ldw	r2,-56(fp)
 8238248:	10c00b17 	ldw	r3,44(r2)
 823824c:	e0bff217 	ldw	r2,-56(fp)
 8238250:	10800a17 	ldw	r2,40(r2)
 8238254:	1885c83a 	sub	r2,r3,r2
 8238258:	00000106 	br	8238260 <tcp_output+0x214>
 823825c:	0005883a 	mov	r2,zero
 8238260:	e0bfeb15 	stw	r2,-84(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238264:	e0bfec17 	ldw	r2,-80(fp)
 8238268:	1080004c 	andi	r2,r2,1
 823826c:	10000d26 	beq	r2,zero,82382a4 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
 8238270:	e0bff217 	ldw	r2,-56(fp)
 8238274:	10801217 	ldw	r2,72(r2)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238278:	10000a1e 	bne	r2,zero,82382a4 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 823827c:	e0bfff17 	ldw	r2,-4(fp)
 8238280:	10800b0b 	ldhu	r2,44(r2)
 8238284:	10bfffcc 	andi	r2,r2,65535
 8238288:	1080040c 	andi	r2,r2,16
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
       (so->so_snd.sb_cc == 0) &&
 823828c:	10007926 	beq	r2,zero,8238474 <tcp_output+0x428>
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 8238290:	e0bfff17 	ldw	r2,-4(fp)
 8238294:	10c00f17 	ldw	r3,60(r2)
 8238298:	e0bfff17 	ldw	r2,-4(fp)
 823829c:	10800e17 	ldw	r2,56(r2)
 82382a0:	18807426 	beq	r3,r2,8238474 <tcp_output+0x428>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 82382a4:	e0bfff17 	ldw	r2,-4(fp)
 82382a8:	10800b0b 	ldhu	r2,44(r2)
 82382ac:	10bfffcc 	andi	r2,r2,65535
 82382b0:	1080004c 	andi	r2,r2,1
 82382b4:	10005c1e 	bne	r2,zero,8238428 <tcp_output+0x3dc>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 82382b8:	e0bfec17 	ldw	r2,-80(fp)
 82382bc:	1080018c 	andi	r2,r2,6
 82382c0:	10005b1e 	bne	r2,zero,8238430 <tcp_output+0x3e4>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 82382c4:	e0bfff17 	ldw	r2,-4(fp)
 82382c8:	10c01017 	ldw	r3,64(r2)
 82382cc:	e0bfff17 	ldw	r2,-4(fp)
 82382d0:	10800e17 	ldw	r2,56(r2)
 82382d4:	1885c83a 	sub	r2,r3,r2
 82382d8:	00805716 	blt	zero,r2,8238438 <tcp_output+0x3ec>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 82382dc:	e0bfea17 	ldw	r2,-88(fp)
 82382e0:	10002426 	beq	r2,zero,8238374 <tcp_output+0x328>
   {
      if (len == (int)tp->t_maxseg)
 82382e4:	e0bfff17 	ldw	r2,-4(fp)
 82382e8:	10800a0b 	ldhu	r2,40(r2)
 82382ec:	10ffffcc 	andi	r3,r2,65535
 82382f0:	e0bfea17 	ldw	r2,-88(fp)
 82382f4:	18805226 	beq	r3,r2,8238440 <tcp_output+0x3f4>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 82382f8:	e0bff317 	ldw	r2,-52(fp)
 82382fc:	1000051e 	bne	r2,zero,8238314 <tcp_output+0x2c8>
 8238300:	e0bfff17 	ldw	r2,-4(fp)
 8238304:	10800b0b 	ldhu	r2,44(r2)
 8238308:	10bfffcc 	andi	r2,r2,65535
 823830c:	1080010c 	andi	r2,r2,4
 8238310:	10000626 	beq	r2,zero,823832c <tcp_output+0x2e0>
          len + off >= (int)so->so_snd.sb_cc)
 8238314:	e0ffea17 	ldw	r3,-88(fp)
 8238318:	e0bff417 	ldw	r2,-48(fp)
 823831c:	1885883a 	add	r2,r3,r2
 8238320:	e0fff217 	ldw	r3,-56(fp)
 8238324:	18c01217 	ldw	r3,72(r3)
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 8238328:	10c0470e 	bge	r2,r3,8238448 <tcp_output+0x3fc>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 823832c:	e0bfff17 	ldw	r2,-4(fp)
 8238330:	10800a83 	ldbu	r2,42(r2)
 8238334:	10803fcc 	andi	r2,r2,255
 8238338:	1080201c 	xori	r2,r2,128
 823833c:	10bfe004 	addi	r2,r2,-128
 8238340:	1000431e 	bne	r2,zero,8238450 <tcp_output+0x404>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 8238344:	e0bfff17 	ldw	r2,-4(fp)
 8238348:	10802317 	ldw	r2,140(r2)
 823834c:	1004d07a 	srli	r2,r2,1
 8238350:	1007883a 	mov	r3,r2
 8238354:	e0bfea17 	ldw	r2,-88(fp)
 8238358:	10c03f0e 	bge	r2,r3,8238458 <tcp_output+0x40c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 823835c:	e0bfff17 	ldw	r2,-4(fp)
 8238360:	10c00f17 	ldw	r3,60(r2)
 8238364:	e0bfff17 	ldw	r2,-4(fp)
 8238368:	10801a17 	ldw	r2,104(r2)
 823836c:	1885c83a 	sub	r2,r3,r2
 8238370:	10003b16 	blt	r2,zero,8238460 <tcp_output+0x414>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 8238374:	e0bfeb17 	ldw	r2,-84(fp)
 8238378:	00801c0e 	bge	zero,r2,82383ec <tcp_output+0x3a0>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 823837c:	e0bfff17 	ldw	r2,-4(fp)
 8238380:	10c01617 	ldw	r3,88(r2)
 8238384:	e0bfff17 	ldw	r2,-4(fp)
 8238388:	10801917 	ldw	r2,100(r2)
 823838c:	1885c83a 	sub	r2,r3,r2
 8238390:	1007883a 	mov	r3,r2
 8238394:	e0bfeb17 	ldw	r2,-84(fp)
 8238398:	1885883a 	add	r2,r3,r2
 823839c:	e0bffd15 	stw	r2,-12(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 82383a0:	e0bff217 	ldw	r2,-56(fp)
 82383a4:	10800a17 	ldw	r2,40(r2)
 82383a8:	1000071e 	bne	r2,zero,82383c8 <tcp_output+0x37c>
 82383ac:	e0bfff17 	ldw	r2,-4(fp)
 82383b0:	10800a0b 	ldhu	r2,40(r2)
 82383b4:	10bfffcc 	andi	r2,r2,65535
 82383b8:	1085883a 	add	r2,r2,r2
 82383bc:	1007883a 	mov	r3,r2
 82383c0:	e0bffd17 	ldw	r2,-12(fp)
 82383c4:	10c0280e 	bge	r2,r3,8238468 <tcp_output+0x41c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 82383c8:	e0bffd17 	ldw	r2,-12(fp)
 82383cc:	10c01924 	muli	r3,r2,100
 82383d0:	e0bff217 	ldw	r2,-56(fp)
 82383d4:	10800b17 	ldw	r2,44(r2)
 82383d8:	100b883a 	mov	r5,r2
 82383dc:	1809883a 	mov	r4,r3
 82383e0:	820295c0 	call	820295c <__udivsi3>
 82383e4:	108008f0 	cmpltui	r2,r2,35
 82383e8:	10002126 	beq	r2,zero,8238470 <tcp_output+0x424>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 82383ec:	e0bff217 	ldw	r2,-56(fp)
 82383f0:	10801217 	ldw	r2,72(r2)
 82383f4:	10000a26 	beq	r2,zero,8238420 <tcp_output+0x3d4>
 82383f8:	e0bfff17 	ldw	r2,-4(fp)
 82383fc:	10800317 	ldw	r2,12(r2)
 8238400:	1000071e 	bne	r2,zero,8238420 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
 8238404:	e0bfff17 	ldw	r2,-4(fp)
 8238408:	10800417 	ldw	r2,16(r2)
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 823840c:	1000041e 	bne	r2,zero,8238420 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 8238410:	e0bfff17 	ldw	r2,-4(fp)
 8238414:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 8238418:	e13fff17 	ldw	r4,-4(fp)
 823841c:	82390500 	call	8239050 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 8238420:	0005883a 	mov	r2,zero
 8238424:	00030506 	br	823903c <tcp_output+0xff0>
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
      goto send;
 8238428:	0001883a 	nop
 823842c:	00001106 	br	8238474 <tcp_output+0x428>
   if (flags & (TH_SYN|TH_RST))
      goto send;
 8238430:	0001883a 	nop
 8238434:	00000f06 	br	8238474 <tcp_output+0x428>
   if (SEQ_GT(tp->snd_up, tp->snd_una))
      goto send;
 8238438:	0001883a 	nop
 823843c:	00000d06 	br	8238474 <tcp_output+0x428>
    * to send into a small window), then must resend.
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
 8238440:	0001883a 	nop
 8238444:	00000b06 	br	8238474 <tcp_output+0x428>
      if ((idle || tp->t_flags & TF_NODELAY) &&
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
 8238448:	0001883a 	nop
 823844c:	00000906 	br	8238474 <tcp_output+0x428>
      }
      if (tp->t_force)
         goto send;
 8238450:	0001883a 	nop
 8238454:	00000706 	br	8238474 <tcp_output+0x428>
      if (len >= (int)(tp->max_sndwnd / 2))
         goto send;
 8238458:	0001883a 	nop
 823845c:	00000506 	br	8238474 <tcp_output+0x428>
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
         goto send;
 8238460:	0001883a 	nop
 8238464:	00000306 	br	8238474 <tcp_output+0x428>
   if (win > 0)
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
         goto send;
 8238468:	0001883a 	nop
 823846c:	00000106 	br	8238474 <tcp_output+0x428>
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
         goto send;
 8238470:	0001883a 	nop
    * No reason to send a segment, just return.
    */
   return (0);

send:
   ENTER_CRIT_SECTION(tp);
 8238474:	822d4b80 	call	822d4b8 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 8238478:	e0bff417 	ldw	r2,-48(fp)
 823847c:	e0bff115 	stw	r2,-60(fp)
   sendm = so->so_snd.sb_mb;
 8238480:	e0bff217 	ldw	r2,-56(fp)
 8238484:	10801817 	ldw	r2,96(r2)
 8238488:	e0bff015 	stw	r2,-64(fp)
   if (len)
 823848c:	e0bfea17 	ldw	r2,-88(fp)
 8238490:	10005526 	beq	r2,zero,82385e8 <tcp_output+0x59c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 8238494:	00000a06 	br	82384c0 <tcp_output+0x474>
      {
         bufoff -= sendm->m_len;
 8238498:	e0fff117 	ldw	r3,-60(fp)
 823849c:	e0bff017 	ldw	r2,-64(fp)
 82384a0:	10800217 	ldw	r2,8(r2)
 82384a4:	1885c83a 	sub	r2,r3,r2
 82384a8:	e0bff115 	stw	r2,-60(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 82384ac:	e0bff117 	ldw	r2,-60(fp)
 82384b0:	10000616 	blt	r2,zero,82384cc <tcp_output+0x480>
            break;
         sendm = sendm->m_next;
 82384b4:	e0bff017 	ldw	r2,-64(fp)
 82384b8:	10800617 	ldw	r2,24(r2)
 82384bc:	e0bff015 	stw	r2,-64(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 82384c0:	e0bff017 	ldw	r2,-64(fp)
 82384c4:	103ff41e 	bne	r2,zero,8238498 <tcp_output+0x44c>
 82384c8:	00000106 	br	82384d0 <tcp_output+0x484>
      {
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
 82384cc:	0001883a 	nop
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 82384d0:	e0bff017 	ldw	r2,-64(fp)
 82384d4:	1000011e 	bne	r2,zero,82384dc <tcp_output+0x490>
 82384d8:	822d2e00 	call	822d2e0 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 82384dc:	e0bff017 	ldw	r2,-64(fp)
 82384e0:	10c00217 	ldw	r3,8(r2)
 82384e4:	e0bff117 	ldw	r2,-60(fp)
 82384e8:	1885883a 	add	r2,r3,r2
 82384ec:	e0bff115 	stw	r2,-60(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 82384f0:	e0bff017 	ldw	r2,-64(fp)
 82384f4:	10800617 	ldw	r2,24(r2)
 82384f8:	10000b26 	beq	r2,zero,8238528 <tcp_output+0x4dc>
 82384fc:	e0bff017 	ldw	r2,-64(fp)
 8238500:	10800217 	ldw	r2,8(r2)
 8238504:	1007883a 	mov	r3,r2
 8238508:	e0bfea17 	ldw	r2,-88(fp)
 823850c:	1880060e 	bge	r3,r2,8238528 <tcp_output+0x4dc>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 8238510:	e0ffec17 	ldw	r3,-80(fp)
 8238514:	00bfff84 	movi	r2,-2
 8238518:	1884703a 	and	r2,r3,r2
 823851c:	e0bfec15 	stw	r2,-80(fp)
         sendalot = 1;     /* set to send more segments */
 8238520:	00800044 	movi	r2,1
 8238524:	e0bfef15 	stw	r2,-68(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 8238528:	e0bfec17 	ldw	r2,-80(fp)
 823852c:	1080004c 	andi	r2,r2,1
 8238530:	10000826 	beq	r2,zero,8238554 <tcp_output+0x508>
 8238534:	e0bff217 	ldw	r2,-56(fp)
 8238538:	10801217 	ldw	r2,72(r2)
 823853c:	e0ffea17 	ldw	r3,-88(fp)
 8238540:	1880042e 	bgeu	r3,r2,8238554 <tcp_output+0x508>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 8238544:	e0ffec17 	ldw	r3,-80(fp)
 8238548:	00bfff84 	movi	r2,-2
 823854c:	1884703a 	and	r2,r3,r2
 8238550:	e0bfec15 	stw	r2,-80(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 8238554:	e0bff017 	ldw	r2,-64(fp)
 8238558:	10800217 	ldw	r2,8(r2)
 823855c:	e0ffea17 	ldw	r3,-88(fp)
 8238560:	1880010e 	bge	r3,r2,8238568 <tcp_output+0x51c>
 8238564:	1805883a 	mov	r2,r3
 8238568:	e0bfea15 	stw	r2,-88(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 823856c:	e0bff117 	ldw	r2,-60(fp)
 8238570:	1000081e 	bne	r2,zero,8238594 <tcp_output+0x548>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
 8238574:	e0bff017 	ldw	r2,-64(fp)
 8238578:	10800317 	ldw	r2,12(r2)
 823857c:	1007883a 	mov	r3,r2
 8238580:	e0bff017 	ldw	r2,-64(fp)
 8238584:	10800417 	ldw	r2,16(r2)
 8238588:	1885c83a 	sub	r2,r3,r2
 823858c:	108000cc 	andi	r2,r2,3
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 8238590:	10001526 	beq	r2,zero,82385e8 <tcp_output+0x59c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 8238594:	e0bff017 	ldw	r2,-64(fp)
 8238598:	10c00217 	ldw	r3,8(r2)
 823859c:	e0bff117 	ldw	r2,-60(fp)
 82385a0:	1885c83a 	sub	r2,r3,r2
 82385a4:	e0ffea17 	ldw	r3,-88(fp)
 82385a8:	1880010e 	bge	r3,r2,82385b0 <tcp_output+0x564>
 82385ac:	1805883a 	mov	r2,r3
 82385b0:	e0bfea15 	stw	r2,-88(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82385b4:	d0a03717 	ldw	r2,-32548(gp)
 82385b8:	10bff204 	addi	r2,r2,-56
 82385bc:	1007883a 	mov	r3,r2
 82385c0:	e0bfea17 	ldw	r2,-88(fp)
 82385c4:	1880080e 	bge	r3,r2,82385e8 <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
 82385c8:	008209b4 	movhi	r2,2086
 82385cc:	10b7e104 	addi	r2,r2,-8316
 82385d0:	10800217 	ldw	r2,8(r2)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82385d4:	10800088 	cmpgei	r2,r2,2
 82385d8:	1000031e 	bne	r2,zero,82385e8 <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 82385dc:	d0a03717 	ldw	r2,-32548(gp)
 82385e0:	10bff204 	addi	r2,r2,-56
 82385e4:	e0bfea15 	stw	r2,-88(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 82385e8:	e0bfea17 	ldw	r2,-88(fp)
 82385ec:	10003626 	beq	r2,zero,82386c8 <tcp_output+0x67c>
 82385f0:	e0bff117 	ldw	r2,-60(fp)
 82385f4:	1000341e 	bne	r2,zero,82386c8 <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
 82385f8:	e0bff017 	ldw	r2,-64(fp)
 82385fc:	10800117 	ldw	r2,4(r2)
 8238600:	10800917 	ldw	r2,36(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 8238604:	10800058 	cmpnei	r2,r2,1
 8238608:	10002f1e 	bne	r2,zero,82386c8 <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 823860c:	e0bff017 	ldw	r2,-64(fp)
 8238610:	10800317 	ldw	r2,12(r2)
 8238614:	1007883a 	mov	r3,r2
 8238618:	e0bff017 	ldw	r2,-64(fp)
 823861c:	10800417 	ldw	r2,16(r2)
 8238620:	1885c83a 	sub	r2,r3,r2
 8238624:	108000cc 	andi	r2,r2,3

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
       (sendm->pkt->inuse == 1) &&
 8238628:	1000271e 	bne	r2,zero,82386c8 <tcp_output+0x67c>
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 823862c:	e0bfee17 	ldw	r2,-72(fp)
 8238630:	1000251e 	bne	r2,zero,82386c8 <tcp_output+0x67c>
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 8238634:	000b883a 	mov	r5,zero
 8238638:	01000084 	movi	r4,2
 823863c:	822e0f40 	call	822e0f4 <m_getnbuf>
 8238640:	e0bfed15 	stw	r2,-76(fp)
      if (!m)
 8238644:	e0bfed17 	ldw	r2,-76(fp)
 8238648:	1000031e 	bne	r2,zero,8238658 <tcp_output+0x60c>
      {
         EXIT_CRIT_SECTION(tp);
 823864c:	822d5180 	call	822d518 <irq_Unmask>
         return (ENOBUFS);
 8238650:	00801a44 	movi	r2,105
 8238654:	00027906 	br	823903c <tcp_output+0xff0>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 8238658:	e0bff017 	ldw	r2,-64(fp)
 823865c:	10c00117 	ldw	r3,4(r2)
 8238660:	e0bfed17 	ldw	r2,-76(fp)
 8238664:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 8238668:	e0bfed17 	ldw	r2,-76(fp)
 823866c:	10800117 	ldw	r2,4(r2)
 8238670:	10c00917 	ldw	r3,36(r2)
 8238674:	18c00044 	addi	r3,r3,1
 8238678:	10c00915 	stw	r3,36(r2)
      m->m_base = sendm->m_base; /* clone mbuf members */
 823867c:	e0bff017 	ldw	r2,-64(fp)
 8238680:	10c00417 	ldw	r3,16(r2)
 8238684:	e0bfed17 	ldw	r2,-76(fp)
 8238688:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 823868c:	e0bff017 	ldw	r2,-64(fp)
 8238690:	10c00517 	ldw	r3,20(r2)
 8238694:	e0bfed17 	ldw	r2,-76(fp)
 8238698:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 823869c:	e0bfea17 	ldw	r2,-88(fp)
 82386a0:	10800a04 	addi	r2,r2,40
 82386a4:	1007883a 	mov	r3,r2
 82386a8:	e0bfed17 	ldw	r2,-76(fp)
 82386ac:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 82386b0:	e0bff017 	ldw	r2,-64(fp)
 82386b4:	10800317 	ldw	r2,12(r2)
 82386b8:	10fff604 	addi	r3,r2,-40
 82386bc:	e0bfed17 	ldw	r2,-76(fp)
 82386c0:	10c00315 	stw	r3,12(r2)
 82386c4:	00002706 	br	8238764 <tcp_output+0x718>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 82386c8:	d0a08117 	ldw	r2,-32252(gp)
 82386cc:	10800a04 	addi	r2,r2,40
 82386d0:	100b883a 	mov	r5,r2
 82386d4:	010000c4 	movi	r4,3
 82386d8:	822e0f40 	call	822e0f4 <m_getnbuf>
 82386dc:	e0bfed15 	stw	r2,-76(fp)
      if (m ==(struct mbuf *)NULL)
 82386e0:	e0bfed17 	ldw	r2,-76(fp)
 82386e4:	1000031e 	bne	r2,zero,82386f4 <tcp_output+0x6a8>
      {
         EXIT_CRIT_SECTION(tp);
 82386e8:	822d5180 	call	822d518 <irq_Unmask>
         return ENOBUFS;
 82386ec:	00801a44 	movi	r2,105
 82386f0:	00025206 	br	823903c <tcp_output+0xff0>
      }

      m->m_len = TCPIPHDRSZ;
 82386f4:	e0bfed17 	ldw	r2,-76(fp)
 82386f8:	00c00a04 	movi	r3,40
 82386fc:	10c00215 	stw	r3,8(r2)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 8238700:	e0bfed17 	ldw	r2,-76(fp)
 8238704:	10800317 	ldw	r2,12(r2)
 8238708:	d0e08117 	ldw	r3,-32252(gp)
 823870c:	10c7883a 	add	r3,r2,r3
 8238710:	e0bfed17 	ldw	r2,-76(fp)
 8238714:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 8238718:	e0bfea17 	ldw	r2,-88(fp)
 823871c:	10001126 	beq	r2,zero,8238764 <tcp_output+0x718>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 8238720:	e0bff217 	ldw	r2,-56(fp)
 8238724:	10801817 	ldw	r2,96(r2)
 8238728:	e1bfea17 	ldw	r6,-88(fp)
 823872c:	e17ff417 	ldw	r5,-48(fp)
 8238730:	1009883a 	mov	r4,r2
 8238734:	822e3c80 	call	822e3c8 <m_copy>
 8238738:	1007883a 	mov	r3,r2
 823873c:	e0bfed17 	ldw	r2,-76(fp)
 8238740:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 8238744:	e0bfed17 	ldw	r2,-76(fp)
 8238748:	10800617 	ldw	r2,24(r2)
 823874c:	1000051e 	bne	r2,zero,8238764 <tcp_output+0x718>
         {
            m_freem(m);
 8238750:	e13fed17 	ldw	r4,-76(fp)
 8238754:	822e3840 	call	822e384 <m_freem>
            EXIT_CRIT_SECTION(tp);
 8238758:	822d5180 	call	822d518 <irq_Unmask>
            return ENOBUFS;
 823875c:	00801a44 	movi	r2,105
 8238760:	00023606 	br	823903c <tcp_output+0xff0>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 8238764:	822d5180 	call	822d518 <irq_Unmask>

   if (len) 
 8238768:	e0bfea17 	ldw	r2,-88(fp)
 823876c:	10003726 	beq	r2,zero,823884c <tcp_output+0x800>
   {
      if (tp->t_force && len == 1)
 8238770:	e0bfff17 	ldw	r2,-4(fp)
 8238774:	10800a83 	ldbu	r2,42(r2)
 8238778:	10803fcc 	andi	r2,r2,255
 823877c:	1080201c 	xori	r2,r2,128
 8238780:	10bfe004 	addi	r2,r2,-128
 8238784:	10000b26 	beq	r2,zero,82387b4 <tcp_output+0x768>
 8238788:	e0bfea17 	ldw	r2,-88(fp)
 823878c:	10800058 	cmpnei	r2,r2,1
 8238790:	1000081e 	bne	r2,zero,82387b4 <tcp_output+0x768>
         tcpstat.tcps_sndprobe++;
 8238794:	008209b4 	movhi	r2,2086
 8238798:	10b8aa04 	addi	r2,r2,-7512
 823879c:	10801517 	ldw	r2,84(r2)
 82387a0:	10c00044 	addi	r3,r2,1
 82387a4:	008209b4 	movhi	r2,2086
 82387a8:	10b8aa04 	addi	r2,r2,-7512
 82387ac:	10c01515 	stw	r3,84(r2)
 82387b0:	00005306 	br	8238900 <tcp_output+0x8b4>
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 82387b4:	e0bfff17 	ldw	r2,-4(fp)
 82387b8:	10c00f17 	ldw	r3,60(r2)
 82387bc:	e0bfff17 	ldw	r2,-4(fp)
 82387c0:	10801a17 	ldw	r2,104(r2)
 82387c4:	1885c83a 	sub	r2,r3,r2
 82387c8:	1000100e 	bge	r2,zero,823880c <tcp_output+0x7c0>
      {
         tcpstat.tcps_sndrexmitpack++;
 82387cc:	008209b4 	movhi	r2,2086
 82387d0:	10b8aa04 	addi	r2,r2,-7512
 82387d4:	10801217 	ldw	r2,72(r2)
 82387d8:	10c00044 	addi	r3,r2,1
 82387dc:	008209b4 	movhi	r2,2086
 82387e0:	10b8aa04 	addi	r2,r2,-7512
 82387e4:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 82387e8:	008209b4 	movhi	r2,2086
 82387ec:	10b8aa04 	addi	r2,r2,-7512
 82387f0:	10c01317 	ldw	r3,76(r2)
 82387f4:	e0bfea17 	ldw	r2,-88(fp)
 82387f8:	1887883a 	add	r3,r3,r2
 82387fc:	008209b4 	movhi	r2,2086
 8238800:	10b8aa04 	addi	r2,r2,-7512
 8238804:	10c01315 	stw	r3,76(r2)
 8238808:	00003d06 	br	8238900 <tcp_output+0x8b4>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 823880c:	008209b4 	movhi	r2,2086
 8238810:	10b8aa04 	addi	r2,r2,-7512
 8238814:	10801017 	ldw	r2,64(r2)
 8238818:	10c00044 	addi	r3,r2,1
 823881c:	008209b4 	movhi	r2,2086
 8238820:	10b8aa04 	addi	r2,r2,-7512
 8238824:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 8238828:	008209b4 	movhi	r2,2086
 823882c:	10b8aa04 	addi	r2,r2,-7512
 8238830:	10c01117 	ldw	r3,68(r2)
 8238834:	e0bfea17 	ldw	r2,-88(fp)
 8238838:	1887883a 	add	r3,r3,r2
 823883c:	008209b4 	movhi	r2,2086
 8238840:	10b8aa04 	addi	r2,r2,-7512
 8238844:	10c01115 	stw	r3,68(r2)
 8238848:	00002d06 	br	8238900 <tcp_output+0x8b4>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 823884c:	e0bfff17 	ldw	r2,-4(fp)
 8238850:	10800b0b 	ldhu	r2,44(r2)
 8238854:	10bfffcc 	andi	r2,r2,65535
 8238858:	1080004c 	andi	r2,r2,1
 823885c:	10000826 	beq	r2,zero,8238880 <tcp_output+0x834>
   {
      tcpstat.tcps_sndacks++;
 8238860:	008209b4 	movhi	r2,2086
 8238864:	10b8aa04 	addi	r2,r2,-7512
 8238868:	10801417 	ldw	r2,80(r2)
 823886c:	10c00044 	addi	r3,r2,1
 8238870:	008209b4 	movhi	r2,2086
 8238874:	10b8aa04 	addi	r2,r2,-7512
 8238878:	10c01415 	stw	r3,80(r2)
 823887c:	00002006 	br	8238900 <tcp_output+0x8b4>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 8238880:	e0bfec17 	ldw	r2,-80(fp)
 8238884:	108001cc 	andi	r2,r2,7
 8238888:	10000826 	beq	r2,zero,82388ac <tcp_output+0x860>
      tcpstat.tcps_sndctrl++;
 823888c:	008209b4 	movhi	r2,2086
 8238890:	10b8aa04 	addi	r2,r2,-7512
 8238894:	10801817 	ldw	r2,96(r2)
 8238898:	10c00044 	addi	r3,r2,1
 823889c:	008209b4 	movhi	r2,2086
 82388a0:	10b8aa04 	addi	r2,r2,-7512
 82388a4:	10c01815 	stw	r3,96(r2)
 82388a8:	00001506 	br	8238900 <tcp_output+0x8b4>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 82388ac:	e0bfff17 	ldw	r2,-4(fp)
 82388b0:	10c01017 	ldw	r3,64(r2)
 82388b4:	e0bfff17 	ldw	r2,-4(fp)
 82388b8:	10800e17 	ldw	r2,56(r2)
 82388bc:	1885c83a 	sub	r2,r3,r2
 82388c0:	0080080e 	bge	zero,r2,82388e4 <tcp_output+0x898>
      tcpstat.tcps_sndurg++;
 82388c4:	008209b4 	movhi	r2,2086
 82388c8:	10b8aa04 	addi	r2,r2,-7512
 82388cc:	10801617 	ldw	r2,88(r2)
 82388d0:	10c00044 	addi	r3,r2,1
 82388d4:	008209b4 	movhi	r2,2086
 82388d8:	10b8aa04 	addi	r2,r2,-7512
 82388dc:	10c01615 	stw	r3,88(r2)
 82388e0:	00000706 	br	8238900 <tcp_output+0x8b4>
   else
      tcpstat.tcps_sndwinup++;
 82388e4:	008209b4 	movhi	r2,2086
 82388e8:	10b8aa04 	addi	r2,r2,-7512
 82388ec:	10801717 	ldw	r2,92(r2)
 82388f0:	10c00044 	addi	r3,r2,1
 82388f4:	008209b4 	movhi	r2,2086
 82388f8:	10b8aa04 	addi	r2,r2,-7512
 82388fc:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 8238900:	e0bfed17 	ldw	r2,-76(fp)
 8238904:	10800317 	ldw	r2,12(r2)
 8238908:	e0bff515 	stw	r2,-44(fp)
   if ((char *)ti < m->pkt->nb_buff)
 823890c:	e0bfed17 	ldw	r2,-76(fp)
 8238910:	10800117 	ldw	r2,4(r2)
 8238914:	10800117 	ldw	r2,4(r2)
 8238918:	e0fff517 	ldw	r3,-44(fp)
 823891c:	1880032e 	bgeu	r3,r2,823892c <tcp_output+0x8e0>
   {
      panic("tcp_out- packet ptr underflow\n");
 8238920:	01020974 	movhi	r4,2085
 8238924:	2102c104 	addi	r4,r4,2820
 8238928:	82289940 	call	8228994 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 823892c:	e0bfed17 	ldw	r2,-76(fp)
 8238930:	e0bff615 	stw	r2,-40(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 8238934:	e0bfff17 	ldw	r2,-4(fp)
 8238938:	10800c17 	ldw	r2,48(r2)
 823893c:	1000031e 	bne	r2,zero,823894c <tcp_output+0x900>
      panic("tcp_output");
 8238940:	01020974 	movhi	r4,2085
 8238944:	2102c904 	addi	r4,r4,2852
 8238948:	82289940 	call	8228994 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 823894c:	e0bfff17 	ldw	r2,-4(fp)
 8238950:	10800c17 	ldw	r2,48(r2)
 8238954:	01800a04 	movi	r6,40
 8238958:	100b883a 	mov	r5,r2
 823895c:	e13ff517 	ldw	r4,-44(fp)
 8238960:	8202c5c0 	call	8202c5c <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238964:	e0bfec17 	ldw	r2,-80(fp)
 8238968:	1080004c 	andi	r2,r2,1
 823896c:	10000f26 	beq	r2,zero,82389ac <tcp_output+0x960>
 8238970:	e0bfff17 	ldw	r2,-4(fp)
 8238974:	10800b0b 	ldhu	r2,44(r2)
 8238978:	10bfffcc 	andi	r2,r2,65535
 823897c:	1080040c 	andi	r2,r2,16
 8238980:	10000a26 	beq	r2,zero,82389ac <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
 8238984:	e0bfff17 	ldw	r2,-4(fp)
 8238988:	10c00f17 	ldw	r3,60(r2)
 823898c:	e0bfff17 	ldw	r2,-4(fp)
 8238990:	10801a17 	ldw	r2,104(r2)
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238994:	1880051e 	bne	r3,r2,82389ac <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 8238998:	e0bfff17 	ldw	r2,-4(fp)
 823899c:	10800f17 	ldw	r2,60(r2)
 82389a0:	10ffffc4 	addi	r3,r2,-1
 82389a4:	e0bfff17 	ldw	r2,-4(fp)
 82389a8:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 82389ac:	e0bfff17 	ldw	r2,-4(fp)
 82389b0:	10800f17 	ldw	r2,60(r2)
 82389b4:	1006d63a 	srli	r3,r2,24
 82389b8:	e0bfff17 	ldw	r2,-4(fp)
 82389bc:	10800f17 	ldw	r2,60(r2)
 82389c0:	1004d23a 	srli	r2,r2,8
 82389c4:	10bfc00c 	andi	r2,r2,65280
 82389c8:	1886b03a 	or	r3,r3,r2
 82389cc:	e0bfff17 	ldw	r2,-4(fp)
 82389d0:	10800f17 	ldw	r2,60(r2)
 82389d4:	10bfc00c 	andi	r2,r2,65280
 82389d8:	1004923a 	slli	r2,r2,8
 82389dc:	1886b03a 	or	r3,r3,r2
 82389e0:	e0bfff17 	ldw	r2,-4(fp)
 82389e4:	10800f17 	ldw	r2,60(r2)
 82389e8:	1004963a 	slli	r2,r2,24
 82389ec:	1886b03a 	or	r3,r3,r2
 82389f0:	e0bff517 	ldw	r2,-44(fp)
 82389f4:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 82389f8:	e0bfff17 	ldw	r2,-4(fp)
 82389fc:	10801617 	ldw	r2,88(r2)
 8238a00:	1006d63a 	srli	r3,r2,24
 8238a04:	e0bfff17 	ldw	r2,-4(fp)
 8238a08:	10801617 	ldw	r2,88(r2)
 8238a0c:	1004d23a 	srli	r2,r2,8
 8238a10:	10bfc00c 	andi	r2,r2,65280
 8238a14:	1886b03a 	or	r3,r3,r2
 8238a18:	e0bfff17 	ldw	r2,-4(fp)
 8238a1c:	10801617 	ldw	r2,88(r2)
 8238a20:	10bfc00c 	andi	r2,r2,65280
 8238a24:	1004923a 	slli	r2,r2,8
 8238a28:	1886b03a 	or	r3,r3,r2
 8238a2c:	e0bfff17 	ldw	r2,-4(fp)
 8238a30:	10801617 	ldw	r2,88(r2)
 8238a34:	1004963a 	slli	r2,r2,24
 8238a38:	1886b03a 	or	r3,r3,r2
 8238a3c:	e0bff517 	ldw	r2,-44(fp)
 8238a40:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 8238a44:	e0bfec17 	ldw	r2,-80(fp)
 8238a48:	1080008c 	andi	r2,r2,2
 8238a4c:	10002426 	beq	r2,zero,8238ae0 <tcp_output+0xa94>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 8238a50:	e0bff217 	ldw	r2,-56(fp)
 8238a54:	10800117 	ldw	r2,4(r2)
 8238a58:	e0bff715 	stw	r2,-36(fp)

      switch(so->so_domain)
 8238a5c:	e0bff217 	ldw	r2,-56(fp)
 8238a60:	10800517 	ldw	r2,20(r2)
 8238a64:	108000a0 	cmpeqi	r2,r2,2
 8238a68:	10001a26 	beq	r2,zero,8238ad4 <tcp_output+0xa88>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 8238a6c:	e0bfec17 	ldw	r2,-80(fp)
 8238a70:	1080040c 	andi	r2,r2,16
 8238a74:	1000191e 	bne	r2,zero,8238adc <tcp_output+0xa90>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 8238a78:	e0bff517 	ldw	r2,-44(fp)
 8238a7c:	10800417 	ldw	r2,16(r2)
 8238a80:	e0fffe04 	addi	r3,fp,-8
 8238a84:	180b883a 	mov	r5,r3
 8238a88:	1009883a 	mov	r4,r2
 8238a8c:	8240a340 	call	8240a34 <iproute>
 8238a90:	e0bff815 	stw	r2,-32(fp)
               if(ifp)
 8238a94:	e0bff817 	ldw	r2,-32(fp)
 8238a98:	10000926 	beq	r2,zero,8238ac0 <tcp_output+0xa74>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8238a9c:	e0bff817 	ldw	r2,-32(fp)
 8238aa0:	10c00917 	ldw	r3,36(r2)
 8238aa4:	e0bff817 	ldw	r2,-32(fp)
 8238aa8:	10800817 	ldw	r2,32(r2)
 8238aac:	10800a04 	addi	r2,r2,40
 8238ab0:	1887c83a 	sub	r3,r3,r2
 8238ab4:	e0bff717 	ldw	r2,-36(fp)
 8238ab8:	10c00615 	stw	r3,24(r2)
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238abc:	00000706 	br	8238adc <tcp_output+0xa90>
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
               if(ifp)
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 8238ac0:	e0bff717 	ldw	r2,-36(fp)
 8238ac4:	00c09104 	movi	r3,580
 8238ac8:	10c00615 	stw	r3,24(r2)
            }
#endif   /* IP_PMTU */
         }
         break;
 8238acc:	0001883a 	nop
 8238ad0:	00000206 	br	8238adc <tcp_output+0xa90>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 8238ad4:	822d2e00 	call	822d2e0 <dtrap>
 8238ad8:	00000106 	br	8238ae0 <tcp_output+0xa94>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238adc:	0001883a 	nop
         dtrap();    /* bad domain setting */
      }
   }

   /* fill in options if any are set */
   if (optlen)
 8238ae0:	e0bfee17 	ldw	r2,-72(fp)
 8238ae4:	10002b26 	beq	r2,zero,8238b94 <tcp_output+0xb48>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 8238ae8:	01404004 	movi	r5,256
 8238aec:	01000084 	movi	r4,2
 8238af0:	822e0f40 	call	822e0f4 <m_getnbuf>
 8238af4:	e0bff915 	stw	r2,-28(fp)
      if (mopt == NULL) 
 8238af8:	e0bff917 	ldw	r2,-28(fp)
 8238afc:	1000041e 	bne	r2,zero,8238b10 <tcp_output+0xac4>
      {
         m_freem(m);
 8238b00:	e13fed17 	ldw	r4,-76(fp)
 8238b04:	822e3840 	call	822e384 <m_freem>
         return (ENOBUFS);
 8238b08:	00801a44 	movi	r2,105
 8238b0c:	00014b06 	br	823903c <tcp_output+0xff0>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 8238b10:	e0bff617 	ldw	r2,-40(fp)
 8238b14:	10c00617 	ldw	r3,24(r2)
 8238b18:	e0bff917 	ldw	r2,-28(fp)
 8238b1c:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 8238b20:	e0bff617 	ldw	r2,-40(fp)
 8238b24:	e0fff917 	ldw	r3,-28(fp)
 8238b28:	10c00615 	stw	r3,24(r2)

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238b2c:	00000606 	br	8238b48 <tcp_output+0xafc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 8238b30:	e0bfee17 	ldw	r2,-72(fp)
 8238b34:	10c00044 	addi	r3,r2,1
 8238b38:	e0ffee15 	stw	r3,-72(fp)
 8238b3c:	d0e0b304 	addi	r3,gp,-32052
 8238b40:	10c5883a 	add	r2,r2,r3
 8238b44:	10000005 	stb	zero,0(r2)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238b48:	e0bfee17 	ldw	r2,-72(fp)
 8238b4c:	108000cc 	andi	r2,r2,3
 8238b50:	103ff71e 	bne	r2,zero,8238b30 <tcp_output+0xae4>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 8238b54:	e0bff917 	ldw	r2,-28(fp)
 8238b58:	10800317 	ldw	r2,12(r2)
 8238b5c:	e1bfee17 	ldw	r6,-72(fp)
 8238b60:	d160b304 	addi	r5,gp,-32052
 8238b64:	1009883a 	mov	r4,r2
 8238b68:	8202c5c0 	call	8202c5c <memcpy>
      mopt->m_len = optlen;
 8238b6c:	e0bff917 	ldw	r2,-28(fp)
 8238b70:	e0ffee17 	ldw	r3,-72(fp)
 8238b74:	10c00215 	stw	r3,8(r2)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 8238b78:	e0bfee17 	ldw	r2,-72(fp)
 8238b7c:	10800504 	addi	r2,r2,20
 8238b80:	1004d0ba 	srli	r2,r2,2
 8238b84:	1004913a 	slli	r2,r2,4
 8238b88:	1007883a 	mov	r3,r2
 8238b8c:	e0bff517 	ldw	r2,-44(fp)
 8238b90:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 8238b94:	e0bfec17 	ldw	r2,-80(fp)
 8238b98:	1007883a 	mov	r3,r2
 8238b9c:	e0bff517 	ldw	r2,-44(fp)
 8238ba0:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 8238ba4:	e0bff217 	ldw	r2,-56(fp)
 8238ba8:	10800b17 	ldw	r2,44(r2)
 8238bac:	1004d0ba 	srli	r2,r2,2
 8238bb0:	1007883a 	mov	r3,r2
 8238bb4:	e0bfeb17 	ldw	r2,-84(fp)
 8238bb8:	10c0060e 	bge	r2,r3,8238bd4 <tcp_output+0xb88>
 8238bbc:	e0bfff17 	ldw	r2,-4(fp)
 8238bc0:	10800a0b 	ldhu	r2,40(r2)
 8238bc4:	10bfffcc 	andi	r2,r2,65535
 8238bc8:	e0ffeb17 	ldw	r3,-84(fp)
 8238bcc:	1880010e 	bge	r3,r2,8238bd4 <tcp_output+0xb88>
      win = 0;
 8238bd0:	e03feb15 	stw	zero,-84(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 8238bd4:	e0bfff17 	ldw	r2,-4(fp)
 8238bd8:	10c01917 	ldw	r3,100(r2)
 8238bdc:	e0bfff17 	ldw	r2,-4(fp)
 8238be0:	10801617 	ldw	r2,88(r2)
 8238be4:	1885c83a 	sub	r2,r3,r2
 8238be8:	1007883a 	mov	r3,r2
 8238bec:	e0bfeb17 	ldw	r2,-84(fp)
 8238bf0:	10c0060e 	bge	r2,r3,8238c0c <tcp_output+0xbc0>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 8238bf4:	e0bfff17 	ldw	r2,-4(fp)
 8238bf8:	10c01917 	ldw	r3,100(r2)
 8238bfc:	e0bfff17 	ldw	r2,-4(fp)
 8238c00:	10801617 	ldw	r2,88(r2)
 8238c04:	1885c83a 	sub	r2,r3,r2
 8238c08:	e0bfeb15 	stw	r2,-84(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 8238c0c:	008209b4 	movhi	r2,2086
 8238c10:	10b7e104 	addi	r2,r2,-8316
 8238c14:	10800217 	ldw	r2,8(r2)
 8238c18:	1000021e 	bne	r2,zero,8238c24 <tcp_output+0xbd8>
   {
      win = 0;
 8238c1c:	e03feb15 	stw	zero,-84(fp)
 8238c20:	00001006 	br	8238c64 <tcp_output+0xc18>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 8238c24:	008209b4 	movhi	r2,2086
 8238c28:	10b7e104 	addi	r2,r2,-8316
 8238c2c:	10800217 	ldw	r2,8(r2)
 8238c30:	10bfffc4 	addi	r2,r2,-1
 8238c34:	d0e03917 	ldw	r3,-32540(gp)
 8238c38:	10c7383a 	mul	r3,r2,r3
 8238c3c:	e0bfeb17 	ldw	r2,-84(fp)
 8238c40:	1880080e 	bge	r3,r2,8238c64 <tcp_output+0xc18>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 8238c44:	008209b4 	movhi	r2,2086
 8238c48:	10b7e104 	addi	r2,r2,-8316
 8238c4c:	10800217 	ldw	r2,8(r2)
 8238c50:	10bfffc4 	addi	r2,r2,-1
 8238c54:	1007883a 	mov	r3,r2
 8238c58:	d0a03917 	ldw	r2,-32540(gp)
 8238c5c:	1885383a 	mul	r2,r3,r2
 8238c60:	e0bfeb15 	stw	r2,-84(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 8238c64:	e0bfeb17 	ldw	r2,-84(fp)
 8238c68:	10bfffcc 	andi	r2,r2,65535
 8238c6c:	1005d23a 	srai	r2,r2,8
 8238c70:	10803fcc 	andi	r2,r2,255
 8238c74:	1007883a 	mov	r3,r2
 8238c78:	e0bfeb17 	ldw	r2,-84(fp)
 8238c7c:	10bfffcc 	andi	r2,r2,65535
 8238c80:	1004923a 	slli	r2,r2,8
 8238c84:	1884b03a 	or	r2,r3,r2
 8238c88:	1007883a 	mov	r3,r2
 8238c8c:	e0bff517 	ldw	r2,-44(fp)
 8238c90:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 8238c94:	e0bfff17 	ldw	r2,-4(fp)
 8238c98:	10c01017 	ldw	r3,64(r2)
 8238c9c:	e0bfff17 	ldw	r2,-4(fp)
 8238ca0:	10800f17 	ldw	r2,60(r2)
 8238ca4:	1885c83a 	sub	r2,r3,r2
 8238ca8:	00801c0e 	bge	zero,r2,8238d1c <tcp_output+0xcd0>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 8238cac:	e0bfff17 	ldw	r2,-4(fp)
 8238cb0:	10801017 	ldw	r2,64(r2)
 8238cb4:	1007883a 	mov	r3,r2
 8238cb8:	e0bfff17 	ldw	r2,-4(fp)
 8238cbc:	10800f17 	ldw	r2,60(r2)
 8238cc0:	1885c83a 	sub	r2,r3,r2
 8238cc4:	10bfffcc 	andi	r2,r2,65535
 8238cc8:	1004d23a 	srli	r2,r2,8
 8238ccc:	1007883a 	mov	r3,r2
 8238cd0:	e0bfff17 	ldw	r2,-4(fp)
 8238cd4:	10801017 	ldw	r2,64(r2)
 8238cd8:	1009883a 	mov	r4,r2
 8238cdc:	e0bfff17 	ldw	r2,-4(fp)
 8238ce0:	10800f17 	ldw	r2,60(r2)
 8238ce4:	2085c83a 	sub	r2,r4,r2
 8238ce8:	10bfffcc 	andi	r2,r2,65535
 8238cec:	1004923a 	slli	r2,r2,8
 8238cf0:	1884b03a 	or	r2,r3,r2
 8238cf4:	1007883a 	mov	r3,r2
 8238cf8:	e0bff517 	ldw	r2,-44(fp)
 8238cfc:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 8238d00:	e0bff517 	ldw	r2,-44(fp)
 8238d04:	10800843 	ldbu	r2,33(r2)
 8238d08:	10800814 	ori	r2,r2,32
 8238d0c:	1007883a 	mov	r3,r2
 8238d10:	e0bff517 	ldw	r2,-44(fp)
 8238d14:	10c00845 	stb	r3,33(r2)
 8238d18:	00000406 	br	8238d2c <tcp_output+0xce0>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 8238d1c:	e0bfff17 	ldw	r2,-4(fp)
 8238d20:	10c00e17 	ldw	r3,56(r2)
 8238d24:	e0bfff17 	ldw	r2,-4(fp)
 8238d28:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 8238d2c:	e0bfea17 	ldw	r2,-88(fp)
 8238d30:	10000c26 	beq	r2,zero,8238d64 <tcp_output+0xd18>
 8238d34:	e0fff417 	ldw	r3,-48(fp)
 8238d38:	e0bfea17 	ldw	r2,-88(fp)
 8238d3c:	1885883a 	add	r2,r3,r2
 8238d40:	e0fff217 	ldw	r3,-56(fp)
 8238d44:	18c01217 	ldw	r3,72(r3)
 8238d48:	10c0061e 	bne	r2,r3,8238d64 <tcp_output+0xd18>
      ti->ti_flags |= TH_PUSH;
 8238d4c:	e0bff517 	ldw	r2,-44(fp)
 8238d50:	10800843 	ldbu	r2,33(r2)
 8238d54:	10800214 	ori	r2,r2,8
 8238d58:	1007883a 	mov	r3,r2
 8238d5c:	e0bff517 	ldw	r2,-44(fp)
 8238d60:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 8238d64:	e0bfff17 	ldw	r2,-4(fp)
 8238d68:	10800a83 	ldbu	r2,42(r2)
 8238d6c:	10803fcc 	andi	r2,r2,255
 8238d70:	1080201c 	xori	r2,r2,128
 8238d74:	10bfe004 	addi	r2,r2,-128
 8238d78:	10000326 	beq	r2,zero,8238d88 <tcp_output+0xd3c>
 8238d7c:	e0bfff17 	ldw	r2,-4(fp)
 8238d80:	10800417 	ldw	r2,16(r2)
 8238d84:	10004d1e 	bne	r2,zero,8238ebc <tcp_output+0xe70>
   {
      tcp_seq startseq = tp->snd_nxt;
 8238d88:	e0bfff17 	ldw	r2,-4(fp)
 8238d8c:	10800f17 	ldw	r2,60(r2)
 8238d90:	e0bffa15 	stw	r2,-24(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 8238d94:	e0bfec17 	ldw	r2,-80(fp)
 8238d98:	1080008c 	andi	r2,r2,2
 8238d9c:	10000526 	beq	r2,zero,8238db4 <tcp_output+0xd68>
         tp->snd_nxt++;
 8238da0:	e0bfff17 	ldw	r2,-4(fp)
 8238da4:	10800f17 	ldw	r2,60(r2)
 8238da8:	10c00044 	addi	r3,r2,1
 8238dac:	e0bfff17 	ldw	r2,-4(fp)
 8238db0:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 8238db4:	e0bfec17 	ldw	r2,-80(fp)
 8238db8:	1080004c 	andi	r2,r2,1
 8238dbc:	10000b26 	beq	r2,zero,8238dec <tcp_output+0xda0>
      {
         tp->snd_nxt++;
 8238dc0:	e0bfff17 	ldw	r2,-4(fp)
 8238dc4:	10800f17 	ldw	r2,60(r2)
 8238dc8:	10c00044 	addi	r3,r2,1
 8238dcc:	e0bfff17 	ldw	r2,-4(fp)
 8238dd0:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 8238dd4:	e0bfff17 	ldw	r2,-4(fp)
 8238dd8:	10800b0b 	ldhu	r2,44(r2)
 8238ddc:	10800414 	ori	r2,r2,16
 8238de0:	1007883a 	mov	r3,r2
 8238de4:	e0bfff17 	ldw	r2,-4(fp)
 8238de8:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 8238dec:	e0bfff17 	ldw	r2,-4(fp)
 8238df0:	10c00f17 	ldw	r3,60(r2)
 8238df4:	e0bfea17 	ldw	r2,-88(fp)
 8238df8:	1887883a 	add	r3,r3,r2
 8238dfc:	e0bfff17 	ldw	r2,-4(fp)
 8238e00:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 8238e04:	e0bfff17 	ldw	r2,-4(fp)
 8238e08:	10c00f17 	ldw	r3,60(r2)
 8238e0c:	e0bfff17 	ldw	r2,-4(fp)
 8238e10:	10801a17 	ldw	r2,104(r2)
 8238e14:	1885c83a 	sub	r2,r3,r2
 8238e18:	0080140e 	bge	zero,r2,8238e6c <tcp_output+0xe20>
      {
         tp->snd_max = tp->snd_nxt;
 8238e1c:	e0bfff17 	ldw	r2,-4(fp)
 8238e20:	10c00f17 	ldw	r3,60(r2)
 8238e24:	e0bfff17 	ldw	r2,-4(fp)
 8238e28:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 8238e2c:	e0bfff17 	ldw	r2,-4(fp)
 8238e30:	10801e17 	ldw	r2,120(r2)
 8238e34:	10000d1e 	bne	r2,zero,8238e6c <tcp_output+0xe20>
         {
            tp->t_rttick = cticks;
 8238e38:	d0e0a817 	ldw	r3,-32096(gp)
 8238e3c:	e0bfff17 	ldw	r2,-4(fp)
 8238e40:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 8238e44:	e0bfff17 	ldw	r2,-4(fp)
 8238e48:	e0fffa17 	ldw	r3,-24(fp)
 8238e4c:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_segstimed++;
 8238e50:	008209b4 	movhi	r2,2086
 8238e54:	10b8aa04 	addi	r2,r2,-7512
 8238e58:	10800617 	ldw	r2,24(r2)
 8238e5c:	10c00044 	addi	r3,r2,1
 8238e60:	008209b4 	movhi	r2,2086
 8238e64:	10b8aa04 	addi	r2,r2,-7512
 8238e68:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8238e6c:	e0bfff17 	ldw	r2,-4(fp)
 8238e70:	10800317 	ldw	r2,12(r2)
 8238e74:	1000201e 	bne	r2,zero,8238ef8 <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
 8238e78:	e0bfff17 	ldw	r2,-4(fp)
 8238e7c:	10c00f17 	ldw	r3,60(r2)
 8238e80:	e0bfff17 	ldw	r2,-4(fp)
 8238e84:	10800e17 	ldw	r2,56(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8238e88:	18801b26 	beq	r3,r2,8238ef8 <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8238e8c:	e0bfff17 	ldw	r2,-4(fp)
 8238e90:	10c00817 	ldw	r3,32(r2)
 8238e94:	e0bfff17 	ldw	r2,-4(fp)
 8238e98:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 8238e9c:	e0bfff17 	ldw	r2,-4(fp)
 8238ea0:	10800417 	ldw	r2,16(r2)
 8238ea4:	10001426 	beq	r2,zero,8238ef8 <tcp_output+0xeac>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 8238ea8:	e0bfff17 	ldw	r2,-4(fp)
 8238eac:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 8238eb0:	e0bfff17 	ldw	r2,-4(fp)
 8238eb4:	10000715 	stw	zero,28(r2)
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 8238eb8:	00000f06 	br	8238ef8 <tcp_output+0xeac>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 8238ebc:	e0bfff17 	ldw	r2,-4(fp)
 8238ec0:	10c00f17 	ldw	r3,60(r2)
 8238ec4:	e0bfea17 	ldw	r2,-88(fp)
 8238ec8:	1887883a 	add	r3,r3,r2
 8238ecc:	e0bfff17 	ldw	r2,-4(fp)
 8238ed0:	10801a17 	ldw	r2,104(r2)
 8238ed4:	1885c83a 	sub	r2,r3,r2
 8238ed8:	0080080e 	bge	zero,r2,8238efc <tcp_output+0xeb0>
         tp->snd_max = tp->snd_nxt + len;
 8238edc:	e0bfff17 	ldw	r2,-4(fp)
 8238ee0:	10c00f17 	ldw	r3,60(r2)
 8238ee4:	e0bfea17 	ldw	r2,-88(fp)
 8238ee8:	1887883a 	add	r3,r3,r2
 8238eec:	e0bfff17 	ldw	r2,-4(fp)
 8238ef0:	10c01a15 	stw	r3,104(r2)
 8238ef4:	00000106 	br	8238efc <tcp_output+0xeb0>
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 8238ef8:	0001883a 	nop
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 8238efc:	e03ffb15 	stw	zero,-20(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 8238f00:	e0bfed17 	ldw	r2,-76(fp)
 8238f04:	10800317 	ldw	r2,12(r2)
 8238f08:	e0bffc15 	stw	r2,-16(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 8238f0c:	e0bfee17 	ldw	r2,-72(fp)
 8238f10:	1007883a 	mov	r3,r2
 8238f14:	e0bfea17 	ldw	r2,-88(fp)
 8238f18:	1885883a 	add	r2,r3,r2
 8238f1c:	10800a04 	addi	r2,r2,40
 8238f20:	1007883a 	mov	r3,r2
 8238f24:	e0bffc17 	ldw	r2,-16(fp)
 8238f28:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 8238f2c:	e0bff217 	ldw	r2,-56(fp)
 8238f30:	10801f17 	ldw	r2,124(r2)
 8238f34:	100b883a 	mov	r5,r2
 8238f38:	e13fed17 	ldw	r4,-76(fp)
 8238f3c:	822ed200 	call	822ed20 <ip_output>
 8238f40:	e0bffb15 	stw	r2,-20(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 8238f44:	e0bffb17 	ldw	r2,-20(fp)
 8238f48:	10001326 	beq	r2,zero,8238f98 <tcp_output+0xf4c>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 8238f4c:	e0bffb17 	ldw	r2,-20(fp)
 8238f50:	10801a58 	cmpnei	r2,r2,105
 8238f54:	10000e1e 	bne	r2,zero,8238f90 <tcp_output+0xf44>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 8238f58:	e0bfed17 	ldw	r2,-76(fp)
 8238f5c:	10800817 	ldw	r2,32(r2)
 8238f60:	1000031e 	bne	r2,zero,8238f70 <tcp_output+0xf24>
            m = m->m_next;
 8238f64:	e0bfed17 	ldw	r2,-76(fp)
 8238f68:	10800617 	ldw	r2,24(r2)
 8238f6c:	e0bfed15 	stw	r2,-76(fp)
         m_freem(m); /* free the mbuf chain */
 8238f70:	e13fed17 	ldw	r4,-76(fp)
 8238f74:	822e3840 	call	822e384 <m_freem>
         tcp_quench(tp->t_inpcb);
 8238f78:	e0bfff17 	ldw	r2,-4(fp)
 8238f7c:	10800d17 	ldw	r2,52(r2)
 8238f80:	1009883a 	mov	r4,r2
 8238f84:	8239a1c0 	call	8239a1c <tcp_quench>
         return (error);
 8238f88:	e0bffb17 	ldw	r2,-20(fp)
 8238f8c:	00002b06 	br	823903c <tcp_output+0xff0>
      }
      return (error);
 8238f90:	e0bffb17 	ldw	r2,-20(fp)
 8238f94:	00002906 	br	823903c <tcp_output+0xff0>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 8238f98:	008209b4 	movhi	r2,2086
 8238f9c:	10b87c04 	addi	r2,r2,-7696
 8238fa0:	10800a17 	ldw	r2,40(r2)
 8238fa4:	10c00044 	addi	r3,r2,1
 8238fa8:	008209b4 	movhi	r2,2086
 8238fac:	10b87c04 	addi	r2,r2,-7696
 8238fb0:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 8238fb4:	008209b4 	movhi	r2,2086
 8238fb8:	10b8aa04 	addi	r2,r2,-7512
 8238fbc:	10800f17 	ldw	r2,60(r2)
 8238fc0:	10c00044 	addi	r3,r2,1
 8238fc4:	008209b4 	movhi	r2,2086
 8238fc8:	10b8aa04 	addi	r2,r2,-7512
 8238fcc:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 8238fd0:	e0bfeb17 	ldw	r2,-84(fp)
 8238fd4:	00800e0e 	bge	zero,r2,8239010 <tcp_output+0xfc4>
 8238fd8:	e0bfff17 	ldw	r2,-4(fp)
 8238fdc:	10c01617 	ldw	r3,88(r2)
 8238fe0:	e0bfeb17 	ldw	r2,-84(fp)
 8238fe4:	1887883a 	add	r3,r3,r2
 8238fe8:	e0bfff17 	ldw	r2,-4(fp)
 8238fec:	10801917 	ldw	r2,100(r2)
 8238ff0:	1885c83a 	sub	r2,r3,r2
 8238ff4:	0080060e 	bge	zero,r2,8239010 <tcp_output+0xfc4>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 8238ff8:	e0bfff17 	ldw	r2,-4(fp)
 8238ffc:	10c01617 	ldw	r3,88(r2)
 8239000:	e0bfeb17 	ldw	r2,-84(fp)
 8239004:	1887883a 	add	r3,r3,r2
 8239008:	e0bfff17 	ldw	r2,-4(fp)
 823900c:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 8239010:	e0bfff17 	ldw	r2,-4(fp)
 8239014:	10c00b0b 	ldhu	r3,44(r2)
 8239018:	00bfef04 	movi	r2,-68
 823901c:	1884703a 	and	r2,r3,r2
 8239020:	1007883a 	mov	r3,r2
 8239024:	e0bfff17 	ldw	r2,-4(fp)
 8239028:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 823902c:	e0bfef17 	ldw	r2,-68(fp)
 8239030:	10000126 	beq	r2,zero,8239038 <tcp_output+0xfec>
      goto again;
 8239034:	003c1606 	br	8238090 <tcp_output+0x44>
   return (0);
 8239038:	0005883a 	mov	r2,zero
}
 823903c:	e037883a 	mov	sp,fp
 8239040:	dfc00117 	ldw	ra,4(sp)
 8239044:	df000017 	ldw	fp,0(sp)
 8239048:	dec00204 	addi	sp,sp,8
 823904c:	f800283a 	ret

08239050 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 8239050:	defffc04 	addi	sp,sp,-16
 8239054:	dfc00315 	stw	ra,12(sp)
 8239058:	df000215 	stw	fp,8(sp)
 823905c:	df000204 	addi	fp,sp,8
 8239060:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8239064:	e0bfff17 	ldw	r2,-4(fp)
 8239068:	10802017 	ldw	r2,128(r2)
 823906c:	1007d0ba 	srai	r3,r2,2
 8239070:	e0bfff17 	ldw	r2,-4(fp)
 8239074:	10802117 	ldw	r2,132(r2)
 8239078:	1885883a 	add	r2,r3,r2
 823907c:	1005d07a 	srai	r2,r2,1
 8239080:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 8239084:	e0bfff17 	ldw	r2,-4(fp)
 8239088:	10800317 	ldw	r2,12(r2)
 823908c:	10000326 	beq	r2,zero,823909c <tcp_setpersist+0x4c>
      panic("tcp_output REXMT");
 8239090:	01020974 	movhi	r4,2085
 8239094:	2102cc04 	addi	r4,r4,2864
 8239098:	82289940 	call	8228994 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 823909c:	e0bffe17 	ldw	r2,-8(fp)
 82390a0:	1009883a 	mov	r4,r2
 82390a4:	e0bfff17 	ldw	r2,-4(fp)
 82390a8:	10c00717 	ldw	r3,28(r2)
 82390ac:	00820974 	movhi	r2,2085
 82390b0:	108de4c4 	addi	r2,r2,14227
 82390b4:	10c5883a 	add	r2,r2,r3
 82390b8:	10800003 	ldbu	r2,0(r2)
 82390bc:	10803fcc 	andi	r2,r2,255
 82390c0:	2085383a 	mul	r2,r4,r2
 82390c4:	10ffffcc 	andi	r3,r2,65535
 82390c8:	18e0001c 	xori	r3,r3,32768
 82390cc:	18e00004 	addi	r3,r3,-32768
 82390d0:	e0bfff17 	ldw	r2,-4(fp)
 82390d4:	10c00415 	stw	r3,16(r2)
 82390d8:	e0bfff17 	ldw	r2,-4(fp)
 82390dc:	10800417 	ldw	r2,16(r2)
 82390e0:	10800288 	cmpgei	r2,r2,10
 82390e4:	1000041e 	bne	r2,zero,82390f8 <tcp_setpersist+0xa8>
 82390e8:	e0bfff17 	ldw	r2,-4(fp)
 82390ec:	00c00284 	movi	r3,10
 82390f0:	10c00415 	stw	r3,16(r2)
 82390f4:	00000706 	br	8239114 <tcp_setpersist+0xc4>
 82390f8:	e0bfff17 	ldw	r2,-4(fp)
 82390fc:	10800417 	ldw	r2,16(r2)
 8239100:	10801e50 	cmplti	r2,r2,121
 8239104:	1000031e 	bne	r2,zero,8239114 <tcp_setpersist+0xc4>
 8239108:	e0bfff17 	ldw	r2,-4(fp)
 823910c:	00c01e04 	movi	r3,120
 8239110:	10c00415 	stw	r3,16(r2)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 8239114:	e0bfff17 	ldw	r2,-4(fp)
 8239118:	10800717 	ldw	r2,28(r2)
 823911c:	10800308 	cmpgei	r2,r2,12
 8239120:	1000051e 	bne	r2,zero,8239138 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 8239124:	e0bfff17 	ldw	r2,-4(fp)
 8239128:	10800717 	ldw	r2,28(r2)
 823912c:	10c00044 	addi	r3,r2,1
 8239130:	e0bfff17 	ldw	r2,-4(fp)
 8239134:	10c00715 	stw	r3,28(r2)

}
 8239138:	0001883a 	nop
 823913c:	e037883a 	mov	sp,fp
 8239140:	dfc00117 	ldw	ra,4(sp)
 8239144:	df000017 	ldw	fp,0(sp)
 8239148:	dec00204 	addi	sp,sp,8
 823914c:	f800283a 	ret

08239150 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 8239150:	defff804 	addi	sp,sp,-32
 8239154:	dfc00715 	stw	ra,28(sp)
 8239158:	df000615 	stw	fp,24(sp)
 823915c:	df000604 	addi	fp,sp,24
 8239160:	e13ffc15 	stw	r4,-16(fp)
 8239164:	e17ffd15 	stw	r5,-12(fp)
 8239168:	e1bffe15 	stw	r6,-8(fp)
 823916c:	e1ffff15 	stw	r7,-4(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 8239170:	e0bffc17 	ldw	r2,-16(fp)
 8239174:	10800b0b 	ldhu	r2,44(r2)
 8239178:	10bfffcc 	andi	r2,r2,65535
 823917c:	1080020c 	andi	r2,r2,8
 8239180:	10000226 	beq	r2,zero,823918c <bld_options+0x3c>
      return 0;
 8239184:	0005883a 	mov	r2,zero
 8239188:	00001e06 	br	8239204 <bld_options+0xb4>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 823918c:	e0bffe17 	ldw	r2,-8(fp)
 8239190:	1080008c 	andi	r2,r2,2
 8239194:	10001926 	beq	r2,zero,82391fc <bld_options+0xac>
   {
      mss   =  (u_short)tcp_mss(so);
 8239198:	e13fff17 	ldw	r4,-4(fp)
 823919c:	8237f540 	call	8237f54 <tcp_mss>
 82391a0:	e0bffb0d 	sth	r2,-20(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 82391a4:	e0bffd17 	ldw	r2,-12(fp)
 82391a8:	00c00084 	movi	r3,2
 82391ac:	10c00005 	stb	r3,0(r2)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 82391b0:	e0bffd17 	ldw	r2,-12(fp)
 82391b4:	10800044 	addi	r2,r2,1
 82391b8:	00c00104 	movi	r3,4
 82391bc:	10c00005 	stb	r3,0(r2)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 82391c0:	e0bffd17 	ldw	r2,-12(fp)
 82391c4:	10800084 	addi	r2,r2,2
 82391c8:	e0fffb0b 	ldhu	r3,-20(fp)
 82391cc:	1806d23a 	srli	r3,r3,8
 82391d0:	10c00005 	stb	r3,0(r2)
      *(cp + 3)  = (u_char) (mss & 0xff);
 82391d4:	e0bffd17 	ldw	r2,-12(fp)
 82391d8:	108000c4 	addi	r2,r2,3
 82391dc:	e0fffb0b 	ldhu	r3,-20(fp)
 82391e0:	10c00005 	stb	r3,0(r2)
      len = 4;
 82391e4:	00800104 	movi	r2,4
 82391e8:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 82391ec:	e0bffd17 	ldw	r2,-12(fp)
 82391f0:	10800104 	addi	r2,r2,4
 82391f4:	e0bffd15 	stw	r2,-12(fp)
 82391f8:	00000106 	br	8239200 <bld_options+0xb0>
   }
   else
      len = 0;
 82391fc:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 8239200:	e0bffa17 	ldw	r2,-24(fp)
}
 8239204:	e037883a 	mov	sp,fp
 8239208:	dfc00117 	ldw	ra,4(sp)
 823920c:	df000017 	ldw	fp,0(sp)
 8239210:	dec00204 	addi	sp,sp,8
 8239214:	f800283a 	ret

08239218 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 8239218:	deffff04 	addi	sp,sp,-4
 823921c:	df000015 	stw	fp,0(sp)
 8239220:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 8239224:	00800044 	movi	r2,1
 8239228:	d0a0b515 	stw	r2,-32044(gp)
   tcb.inp_next = tcb.inp_prev = &tcb;
 823922c:	008209b4 	movhi	r2,2086
 8239230:	10b89f04 	addi	r2,r2,-7556
 8239234:	00c209b4 	movhi	r3,2086
 8239238:	18f89f04 	addi	r3,r3,-7556
 823923c:	10c00115 	stw	r3,4(r2)
 8239240:	008209b4 	movhi	r2,2086
 8239244:	10b89f04 	addi	r2,r2,-7556
 8239248:	10c00117 	ldw	r3,4(r2)
 823924c:	008209b4 	movhi	r2,2086
 8239250:	10b89f04 	addi	r2,r2,-7556
 8239254:	10c00015 	stw	r3,0(r2)
}
 8239258:	0001883a 	nop
 823925c:	e037883a 	mov	sp,fp
 8239260:	df000017 	ldw	fp,0(sp)
 8239264:	dec00104 	addi	sp,sp,4
 8239268:	f800283a 	ret

0823926c <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 823926c:	defffb04 	addi	sp,sp,-20
 8239270:	dfc00415 	stw	ra,16(sp)
 8239274:	df000315 	stw	fp,12(sp)
 8239278:	df000304 	addi	fp,sp,12
 823927c:	e13fff15 	stw	r4,-4(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 8239280:	e0bfff17 	ldw	r2,-4(fp)
 8239284:	10800d17 	ldw	r2,52(r2)
 8239288:	e0bffe15 	stw	r2,-8(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 823928c:	e0bfff17 	ldw	r2,-4(fp)
 8239290:	10800c17 	ldw	r2,48(r2)
 8239294:	e0bffd15 	stw	r2,-12(fp)
 8239298:	e0bffd17 	ldw	r2,-12(fp)
 823929c:	1000071e 	bne	r2,zero,82392bc <tcp_template+0x50>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 82392a0:	01000a04 	movi	r4,40
 82392a4:	822deb80 	call	822deb8 <npalloc>
 82392a8:	e0bffd15 	stw	r2,-12(fp)
      if (n == NULL)
 82392ac:	e0bffd17 	ldw	r2,-12(fp)
 82392b0:	1000021e 	bne	r2,zero,82392bc <tcp_template+0x50>
         return (0);
 82392b4:	0005883a 	mov	r2,zero
 82392b8:	00002906 	br	8239360 <tcp_template+0xf4>
   }
   n->ti_next = n->ti_prev = 0;
 82392bc:	e0bffd17 	ldw	r2,-12(fp)
 82392c0:	10000115 	stw	zero,4(r2)
 82392c4:	e0bffd17 	ldw	r2,-12(fp)
 82392c8:	10c00117 	ldw	r3,4(r2)
 82392cc:	e0bffd17 	ldw	r2,-12(fp)
 82392d0:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 82392d4:	e0bffd17 	ldw	r2,-12(fp)
 82392d8:	00c50004 	movi	r3,5120
 82392dc:	10c0028d 	sth	r3,10(r2)
   n->ti_src = inp->inp_laddr;
 82392e0:	e0bffd17 	ldw	r2,-12(fp)
 82392e4:	e0fffe17 	ldw	r3,-8(fp)
 82392e8:	18c00417 	ldw	r3,16(r3)
 82392ec:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 82392f0:	e0bffd17 	ldw	r2,-12(fp)
 82392f4:	e0fffe17 	ldw	r3,-8(fp)
 82392f8:	18c00317 	ldw	r3,12(r3)
 82392fc:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 8239300:	e0bffe17 	ldw	r2,-8(fp)
 8239304:	10c0078b 	ldhu	r3,30(r2)
 8239308:	e0bffd17 	ldw	r2,-12(fp)
 823930c:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 8239310:	e0bffe17 	ldw	r2,-8(fp)
 8239314:	10c0070b 	ldhu	r3,28(r2)
 8239318:	e0bffd17 	ldw	r2,-12(fp)
 823931c:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 8239320:	e0bffd17 	ldw	r2,-12(fp)
 8239324:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 8239328:	e0bffd17 	ldw	r2,-12(fp)
 823932c:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 8239330:	e0bffd17 	ldw	r2,-12(fp)
 8239334:	00c01404 	movi	r3,80
 8239338:	10c00805 	stb	r3,32(r2)
   n->ti_flags = 0;
 823933c:	e0bffd17 	ldw	r2,-12(fp)
 8239340:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 8239344:	e0bffd17 	ldw	r2,-12(fp)
 8239348:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 823934c:	e0bffd17 	ldw	r2,-12(fp)
 8239350:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 8239354:	e0bffd17 	ldw	r2,-12(fp)
 8239358:	1000098d 	sth	zero,38(r2)
   return (n);
 823935c:	e0bffd17 	ldw	r2,-12(fp)
}
 8239360:	e037883a 	mov	sp,fp
 8239364:	dfc00117 	ldw	ra,4(sp)
 8239368:	df000017 	ldw	fp,0(sp)
 823936c:	dec00204 	addi	sp,sp,8
 8239370:	f800283a 	ret

08239374 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 8239374:	defff204 	addi	sp,sp,-56
 8239378:	dfc00d15 	stw	ra,52(sp)
 823937c:	df000c15 	stw	fp,48(sp)
 8239380:	df000c04 	addi	fp,sp,48
 8239384:	e13ffc15 	stw	r4,-16(fp)
 8239388:	e17ffd15 	stw	r5,-12(fp)
 823938c:	e1bffe15 	stw	r6,-8(fp)
 8239390:	e1ffff15 	stw	r7,-4(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 8239394:	e03ff615 	stw	zero,-40(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 8239398:	e0bffc17 	ldw	r2,-16(fp)
 823939c:	10001726 	beq	r2,zero,82393fc <tcp_respond+0x88>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 82393a0:	e0bffc17 	ldw	r2,-16(fp)
 82393a4:	10800d17 	ldw	r2,52(r2)
 82393a8:	10800817 	ldw	r2,32(r2)
 82393ac:	10800b17 	ldw	r2,44(r2)
 82393b0:	1007883a 	mov	r3,r2
 82393b4:	e0bffc17 	ldw	r2,-16(fp)
 82393b8:	10800d17 	ldw	r2,52(r2)
 82393bc:	10800817 	ldw	r2,32(r2)
 82393c0:	10800a17 	ldw	r2,40(r2)
 82393c4:	1885c83a 	sub	r2,r3,r2
 82393c8:	10000a16 	blt	r2,zero,82393f4 <tcp_respond+0x80>
 82393cc:	e0bffc17 	ldw	r2,-16(fp)
 82393d0:	10800d17 	ldw	r2,52(r2)
 82393d4:	10800817 	ldw	r2,32(r2)
 82393d8:	10c00b17 	ldw	r3,44(r2)
 82393dc:	e0bffc17 	ldw	r2,-16(fp)
 82393e0:	10800d17 	ldw	r2,52(r2)
 82393e4:	10800817 	ldw	r2,32(r2)
 82393e8:	10800a17 	ldw	r2,40(r2)
 82393ec:	1885c83a 	sub	r2,r3,r2
 82393f0:	00000106 	br	82393f8 <tcp_respond+0x84>
 82393f4:	0005883a 	mov	r2,zero
 82393f8:	e0bff615 	stw	r2,-40(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 82393fc:	e0800217 	ldw	r2,8(fp)
 8239400:	1000261e 	bne	r2,zero,823949c <tcp_respond+0x128>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 8239404:	01401004 	movi	r5,64
 8239408:	010000c4 	movi	r4,3
 823940c:	822e0f40 	call	822e0f4 <m_getnbuf>
 8239410:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 8239414:	e0bff717 	ldw	r2,-36(fp)
 8239418:	1000d026 	beq	r2,zero,823975c <tcp_respond+0x3e8>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 823941c:	00800044 	movi	r2,1
 8239420:	e0bff415 	stw	r2,-48(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 8239424:	e0bff417 	ldw	r2,-48(fp)
 8239428:	10800a04 	addi	r2,r2,40
 823942c:	1007883a 	mov	r3,r2
 8239430:	e0bff717 	ldw	r2,-36(fp)
 8239434:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 8239438:	e0bff717 	ldw	r2,-36(fp)
 823943c:	10800317 	ldw	r2,12(r2)
 8239440:	e0bff815 	stw	r2,-32(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 8239444:	e0bff717 	ldw	r2,-36(fp)
 8239448:	10800117 	ldw	r2,4(r2)
 823944c:	10800117 	ldw	r2,4(r2)
 8239450:	e0fff817 	ldw	r3,-32(fp)
 8239454:	1880032e 	bgeu	r3,r2,8239464 <tcp_respond+0xf0>
      {
         panic("tcp_respond- packet ptr underflow\n");
 8239458:	01020974 	movhi	r4,2085
 823945c:	2102d104 	addi	r4,r4,2884
 8239460:	82289940 	call	8228994 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 8239464:	01800a04 	movi	r6,40
 8239468:	e17ffd17 	ldw	r5,-12(fp)
 823946c:	e13ff817 	ldw	r4,-32(fp)
 8239470:	8202c5c0 	call	8202c5c <memcpy>
      ti = tmp_thdr;
 8239474:	e0bff817 	ldw	r2,-32(fp)
 8239478:	e0bffd15 	stw	r2,-12(fp)
      flags = TH_ACK;
 823947c:	00800404 	movi	r2,16
 8239480:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 8239484:	e0bffc17 	ldw	r2,-16(fp)
 8239488:	10800d17 	ldw	r2,52(r2)
 823948c:	10800817 	ldw	r2,32(r2)
 8239490:	10800517 	ldw	r2,20(r2)
 8239494:	e0bff515 	stw	r2,-44(fp)
 8239498:	00003b06 	br	8239588 <tcp_respond+0x214>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 823949c:	e0800317 	ldw	r2,12(fp)
 82394a0:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 82394a4:	e0bff717 	ldw	r2,-36(fp)
 82394a8:	10800117 	ldw	r2,4(r2)
 82394ac:	1080080b 	ldhu	r2,32(r2)
 82394b0:	10bfffcc 	andi	r2,r2,65535
 82394b4:	10800218 	cmpnei	r2,r2,8
 82394b8:	1000031e 	bne	r2,zero,82394c8 <tcp_respond+0x154>
         domain = AF_INET;
 82394bc:	00800084 	movi	r2,2
 82394c0:	e0bff515 	stw	r2,-44(fp)
 82394c4:	00000206 	br	82394d0 <tcp_respond+0x15c>
      else
         domain = AF_INET6;
 82394c8:	008000c4 	movi	r2,3
 82394cc:	e0bff515 	stw	r2,-44(fp)

      m_freem(m->m_next);
 82394d0:	e0bff717 	ldw	r2,-36(fp)
 82394d4:	10800617 	ldw	r2,24(r2)
 82394d8:	1009883a 	mov	r4,r2
 82394dc:	822e3840 	call	822e384 <m_freem>
      m->m_next = 0;
 82394e0:	e0bff717 	ldw	r2,-36(fp)
 82394e4:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 82394e8:	e03ff415 	stw	zero,-48(fp)
      m->m_len = TCPIPHDRSZ;
 82394ec:	e0bff717 	ldw	r2,-36(fp)
 82394f0:	00c00a04 	movi	r3,40
 82394f4:	10c00215 	stw	r3,8(r2)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 82394f8:	e0bffd17 	ldw	r2,-12(fp)
 82394fc:	1080058b 	ldhu	r2,22(r2)
 8239500:	e0bff90d 	sth	r2,-28(fp)
 8239504:	e0bffd17 	ldw	r2,-12(fp)
 8239508:	10c0050b 	ldhu	r3,20(r2)
 823950c:	e0bffd17 	ldw	r2,-12(fp)
 8239510:	10c0058d 	sth	r3,22(r2)
 8239514:	e0bffd17 	ldw	r2,-12(fp)
 8239518:	e0fff90b 	ldhu	r3,-28(fp)
 823951c:	10c0050d 	sth	r3,20(r2)
      if(m->pkt->type == IPTP)
 8239520:	e0bff717 	ldw	r2,-36(fp)
 8239524:	10800117 	ldw	r2,4(r2)
 8239528:	1080080b 	ldhu	r2,32(r2)
 823952c:	10bfffcc 	andi	r2,r2,65535
 8239530:	10800218 	cmpnei	r2,r2,8
 8239534:	10000a1e 	bne	r2,zero,8239560 <tcp_respond+0x1ec>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 8239538:	e0bffd17 	ldw	r2,-12(fp)
 823953c:	10800417 	ldw	r2,16(r2)
 8239540:	e0bffa15 	stw	r2,-24(fp)
 8239544:	e0bffd17 	ldw	r2,-12(fp)
 8239548:	10c00317 	ldw	r3,12(r2)
 823954c:	e0bffd17 	ldw	r2,-12(fp)
 8239550:	10c00415 	stw	r3,16(r2)
 8239554:	e0bffd17 	ldw	r2,-12(fp)
 8239558:	e0fffa17 	ldw	r3,-24(fp)
 823955c:	10c00315 	stw	r3,12(r2)
      if (flags & TH_RST)  /* count resets in MIB */
 8239560:	e0800217 	ldw	r2,8(fp)
 8239564:	1080010c 	andi	r2,r2,4
 8239568:	10000726 	beq	r2,zero,8239588 <tcp_respond+0x214>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 823956c:	008209b4 	movhi	r2,2086
 8239570:	10b87c04 	addi	r2,r2,-7696
 8239574:	10800e17 	ldw	r2,56(r2)
 8239578:	10c00044 	addi	r3,r2,1
 823957c:	008209b4 	movhi	r2,2086
 8239580:	10b87c04 	addi	r2,r2,-7696
 8239584:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 8239588:	e0bfff17 	ldw	r2,-4(fp)
 823958c:	1006d63a 	srli	r3,r2,24
 8239590:	e0bfff17 	ldw	r2,-4(fp)
 8239594:	1004d23a 	srli	r2,r2,8
 8239598:	10bfc00c 	andi	r2,r2,65280
 823959c:	1886b03a 	or	r3,r3,r2
 82395a0:	e0bfff17 	ldw	r2,-4(fp)
 82395a4:	10bfc00c 	andi	r2,r2,65280
 82395a8:	1004923a 	slli	r2,r2,8
 82395ac:	1886b03a 	or	r3,r3,r2
 82395b0:	e0bfff17 	ldw	r2,-4(fp)
 82395b4:	1004963a 	slli	r2,r2,24
 82395b8:	1886b03a 	or	r3,r3,r2
 82395bc:	e0bffd17 	ldw	r2,-12(fp)
 82395c0:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 82395c4:	e0bffe17 	ldw	r2,-8(fp)
 82395c8:	1006d63a 	srli	r3,r2,24
 82395cc:	e0bffe17 	ldw	r2,-8(fp)
 82395d0:	1004d23a 	srli	r2,r2,8
 82395d4:	10bfc00c 	andi	r2,r2,65280
 82395d8:	1886b03a 	or	r3,r3,r2
 82395dc:	e0bffe17 	ldw	r2,-8(fp)
 82395e0:	10bfc00c 	andi	r2,r2,65280
 82395e4:	1004923a 	slli	r2,r2,8
 82395e8:	1886b03a 	or	r3,r3,r2
 82395ec:	e0bffe17 	ldw	r2,-8(fp)
 82395f0:	1004963a 	slli	r2,r2,24
 82395f4:	1886b03a 	or	r3,r3,r2
 82395f8:	e0bffd17 	ldw	r2,-12(fp)
 82395fc:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 8239600:	e0bffd17 	ldw	r2,-12(fp)
 8239604:	00c01404 	movi	r3,80
 8239608:	10c00805 	stb	r3,32(r2)
   ti->ti_flags = (u_char)flags;
 823960c:	e0800217 	ldw	r2,8(fp)
 8239610:	1007883a 	mov	r3,r2
 8239614:	e0bffd17 	ldw	r2,-12(fp)
 8239618:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 823961c:	e0bff617 	ldw	r2,-40(fp)
 8239620:	10bfffcc 	andi	r2,r2,65535
 8239624:	1005d23a 	srai	r2,r2,8
 8239628:	10803fcc 	andi	r2,r2,255
 823962c:	1007883a 	mov	r3,r2
 8239630:	e0bff617 	ldw	r2,-40(fp)
 8239634:	10bfffcc 	andi	r2,r2,65535
 8239638:	1004923a 	slli	r2,r2,8
 823963c:	1884b03a 	or	r2,r3,r2
 8239640:	1007883a 	mov	r3,r2
 8239644:	e0bffd17 	ldw	r2,-12(fp)
 8239648:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 823964c:	e0bffd17 	ldw	r2,-12(fp)
 8239650:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 8239654:	e0bff517 	ldw	r2,-44(fp)
 8239658:	108000a0 	cmpeqi	r2,r2,2
 823965c:	10003b26 	beq	r2,zero,823974c <tcp_respond+0x3d8>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 8239660:	e0bffd17 	ldw	r2,-12(fp)
 8239664:	e0bffb15 	stw	r2,-20(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 8239668:	e0bff417 	ldw	r2,-48(fp)
 823966c:	10800a04 	addi	r2,r2,40
 8239670:	1007883a 	mov	r3,r2
 8239674:	e0bffb17 	ldw	r2,-20(fp)
 8239678:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 823967c:	e0bff717 	ldw	r2,-36(fp)
 8239680:	10800117 	ldw	r2,4(r2)
 8239684:	10800117 	ldw	r2,4(r2)
 8239688:	d0e08117 	ldw	r3,-32252(gp)
 823968c:	10c5883a 	add	r2,r2,r3
 8239690:	e0fffb17 	ldw	r3,-20(fp)
 8239694:	18800436 	bltu	r3,r2,82396a8 <tcp_respond+0x334>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 8239698:	e0bff717 	ldw	r2,-36(fp)
 823969c:	e0fffb17 	ldw	r3,-20(fp)
 82396a0:	10c00315 	stw	r3,12(r2)
 82396a4:	00001106 	br	82396ec <tcp_respond+0x378>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 82396a8:	e0bff717 	ldw	r2,-36(fp)
 82396ac:	10800117 	ldw	r2,4(r2)
 82396b0:	e0fff717 	ldw	r3,-36(fp)
 82396b4:	18c00117 	ldw	r3,4(r3)
 82396b8:	18c00117 	ldw	r3,4(r3)
 82396bc:	d1208117 	ldw	r4,-32252(gp)
 82396c0:	1907883a 	add	r3,r3,r4
 82396c4:	10c00315 	stw	r3,12(r2)
 82396c8:	10c00317 	ldw	r3,12(r2)
 82396cc:	e0bff717 	ldw	r2,-36(fp)
 82396d0:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 82396d4:	e0bff717 	ldw	r2,-36(fp)
 82396d8:	10800317 	ldw	r2,12(r2)
 82396dc:	01800a04 	movi	r6,40
 82396e0:	e17ffb17 	ldw	r5,-20(fp)
 82396e4:	1009883a 	mov	r4,r2
 82396e8:	8202da40 	call	8202da4 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 82396ec:	e0bffc17 	ldw	r2,-16(fp)
 82396f0:	1000031e 	bne	r2,zero,8239700 <tcp_respond+0x38c>
              m_freem(m);
 82396f4:	e13ff717 	ldw	r4,-36(fp)
 82396f8:	822e3840 	call	822e384 <m_freem>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 82396fc:	00001506 	br	8239754 <tcp_respond+0x3e0>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 8239700:	e0bffc17 	ldw	r2,-16(fp)
 8239704:	10800d17 	ldw	r2,52(r2)
 8239708:	10000c26 	beq	r2,zero,823973c <tcp_respond+0x3c8>
 823970c:	e0bffc17 	ldw	r2,-16(fp)
 8239710:	10800d17 	ldw	r2,52(r2)
 8239714:	10800817 	ldw	r2,32(r2)
 8239718:	10000826 	beq	r2,zero,823973c <tcp_respond+0x3c8>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 823971c:	e0bffc17 	ldw	r2,-16(fp)
 8239720:	10800d17 	ldw	r2,52(r2)
 8239724:	10800817 	ldw	r2,32(r2)
 8239728:	10801f17 	ldw	r2,124(r2)
 823972c:	100b883a 	mov	r5,r2
 8239730:	e13ff717 	ldw	r4,-36(fp)
 8239734:	822ed200 	call	822ed20 <ip_output>
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 8239738:	00000606 	br	8239754 <tcp_respond+0x3e0>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 823973c:	000b883a 	mov	r5,zero
 8239740:	e13ff717 	ldw	r4,-36(fp)
 8239744:	822ed200 	call	822ed20 <ip_output>
		 }

         break;
 8239748:	00000206 	br	8239754 <tcp_respond+0x3e0>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 823974c:	822d2e00 	call	822d2e0 <dtrap>
         break;
 8239750:	0001883a 	nop
   }
   return;
 8239754:	0001883a 	nop
 8239758:	00000106 	br	8239760 <tcp_respond+0x3ec>
   if (flags == 0)   /* sending keepalive from timer */
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
      if (m == NULL)
         return;
 823975c:	0001883a 	nop
      default:
         dtrap();
         break;
   }
   return;
}
 8239760:	e037883a 	mov	sp,fp
 8239764:	dfc00117 	ldw	ra,4(sp)
 8239768:	df000017 	ldw	fp,0(sp)
 823976c:	dec00204 	addi	sp,sp,8
 8239770:	f800283a 	ret

08239774 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 8239774:	defffb04 	addi	sp,sp,-20
 8239778:	dfc00415 	stw	ra,16(sp)
 823977c:	df000315 	stw	fp,12(sp)
 8239780:	df000304 	addi	fp,sp,12
 8239784:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 8239788:	01002504 	movi	r4,148
 823978c:	822deb80 	call	822deb8 <npalloc>
 8239790:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 8239794:	e0bffd17 	ldw	r2,-12(fp)
 8239798:	1000021e 	bne	r2,zero,82397a4 <tcp_newtcpcb+0x30>
      return (struct tcpcb *)NULL;
 823979c:	0005883a 	mov	r2,zero
 82397a0:	00003206 	br	823986c <tcp_newtcpcb+0xf8>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 82397a4:	e0bffd17 	ldw	r2,-12(fp)
 82397a8:	e0fffd17 	ldw	r3,-12(fp)
 82397ac:	10c00115 	stw	r3,4(r2)
 82397b0:	e0bffd17 	ldw	r2,-12(fp)
 82397b4:	10c00117 	ldw	r3,4(r2)
 82397b8:	e0bffd17 	ldw	r2,-12(fp)
 82397bc:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 82397c0:	e0bffd17 	ldw	r2,-12(fp)
 82397c4:	00c16d04 	movi	r3,1460
 82397c8:	10c00a0d 	sth	r3,40(r2)
   tp->t_flags = 0;        /* sends options! */
 82397cc:	e0bffd17 	ldw	r2,-12(fp)
 82397d0:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 82397d4:	e0bffd17 	ldw	r2,-12(fp)
 82397d8:	e0ffff17 	ldw	r3,-4(fp)
 82397dc:	10c00d15 	stw	r3,52(r2)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 82397e0:	e0bffd17 	ldw	r2,-12(fp)
 82397e4:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 82397e8:	e0bffd17 	ldw	r2,-12(fp)
 82397ec:	00c00604 	movi	r3,24
 82397f0:	10c02115 	stw	r3,132(r2)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 82397f4:	00800304 	movi	r2,12
 82397f8:	e0bffe0d 	sth	r2,-8(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 82397fc:	e0fffe0f 	ldh	r3,-8(fp)
 8239800:	e0bffd17 	ldw	r2,-12(fp)
 8239804:	10c00815 	stw	r3,32(r2)
 8239808:	e0bffd17 	ldw	r2,-12(fp)
 823980c:	10800817 	ldw	r2,32(r2)
 8239810:	10800088 	cmpgei	r2,r2,2
 8239814:	1000041e 	bne	r2,zero,8239828 <tcp_newtcpcb+0xb4>
 8239818:	e0bffd17 	ldw	r2,-12(fp)
 823981c:	00c00084 	movi	r3,2
 8239820:	10c00815 	stw	r3,32(r2)
 8239824:	00000706 	br	8239844 <tcp_newtcpcb+0xd0>
 8239828:	e0bffd17 	ldw	r2,-12(fp)
 823982c:	10800817 	ldw	r2,32(r2)
 8239830:	10802050 	cmplti	r2,r2,129
 8239834:	1000031e 	bne	r2,zero,8239844 <tcp_newtcpcb+0xd0>
 8239838:	e0bffd17 	ldw	r2,-12(fp)
 823983c:	00c02004 	movi	r3,128
 8239840:	10c00815 	stw	r3,32(r2)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 8239844:	e0bffd17 	ldw	r2,-12(fp)
 8239848:	00c2da04 	movi	r3,2920
 823984c:	10c01b15 	stw	r3,108(r2)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 8239850:	e0bffd17 	ldw	r2,-12(fp)
 8239854:	00ffffd4 	movui	r3,65535
 8239858:	10c01c15 	stw	r3,112(r2)

   inp->inp_ppcb = (char *)tp;
 823985c:	e0bfff17 	ldw	r2,-4(fp)
 8239860:	e0fffd17 	ldw	r3,-12(fp)
 8239864:	10c00915 	stw	r3,36(r2)
   return (tp);
 8239868:	e0bffd17 	ldw	r2,-12(fp)
}
 823986c:	e037883a 	mov	sp,fp
 8239870:	dfc00117 	ldw	ra,4(sp)
 8239874:	df000017 	ldw	fp,0(sp)
 8239878:	dec00204 	addi	sp,sp,8
 823987c:	f800283a 	ret

08239880 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 8239880:	defffb04 	addi	sp,sp,-20
 8239884:	dfc00415 	stw	ra,16(sp)
 8239888:	df000315 	stw	fp,12(sp)
 823988c:	df000304 	addi	fp,sp,12
 8239890:	e13ffe15 	stw	r4,-8(fp)
 8239894:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8239898:	e0bffe17 	ldw	r2,-8(fp)
 823989c:	10800d17 	ldw	r2,52(r2)
 82398a0:	10800817 	ldw	r2,32(r2)
 82398a4:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 82398a8:	e0bffe17 	ldw	r2,-8(fp)
 82398ac:	10800217 	ldw	r2,8(r2)
 82398b0:	108000d0 	cmplti	r2,r2,3
 82398b4:	10000c1e 	bne	r2,zero,82398e8 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 82398b8:	e0bffe17 	ldw	r2,-8(fp)
 82398bc:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 82398c0:	e13ffe17 	ldw	r4,-8(fp)
 82398c4:	823804c0 	call	823804c <tcp_output>
      tcpstat.tcps_drops++;
 82398c8:	008209b4 	movhi	r2,2086
 82398cc:	10b8aa04 	addi	r2,r2,-7512
 82398d0:	10800317 	ldw	r2,12(r2)
 82398d4:	10c00044 	addi	r3,r2,1
 82398d8:	008209b4 	movhi	r2,2086
 82398dc:	10b8aa04 	addi	r2,r2,-7512
 82398e0:	10c00315 	stw	r3,12(r2)
 82398e4:	00000706 	br	8239904 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 82398e8:	008209b4 	movhi	r2,2086
 82398ec:	10b8aa04 	addi	r2,r2,-7512
 82398f0:	10800417 	ldw	r2,16(r2)
 82398f4:	10c00044 	addi	r3,r2,1
 82398f8:	008209b4 	movhi	r2,2086
 82398fc:	10b8aa04 	addi	r2,r2,-7512
 8239900:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 8239904:	e0bffd17 	ldw	r2,-12(fp)
 8239908:	e0ffff17 	ldw	r3,-4(fp)
 823990c:	10c00615 	stw	r3,24(r2)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 8239910:	e13ffe17 	ldw	r4,-8(fp)
 8239914:	823992c0 	call	823992c <tcp_close>
}
 8239918:	e037883a 	mov	sp,fp
 823991c:	dfc00117 	ldw	ra,4(sp)
 8239920:	df000017 	ldw	fp,0(sp)
 8239924:	dec00204 	addi	sp,sp,8
 8239928:	f800283a 	ret

0823992c <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 823992c:	defff904 	addi	sp,sp,-28
 8239930:	dfc00615 	stw	ra,24(sp)
 8239934:	df000515 	stw	fp,20(sp)
 8239938:	df000504 	addi	fp,sp,20
 823993c:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 8239940:	e0bfff17 	ldw	r2,-4(fp)
 8239944:	10800d17 	ldw	r2,52(r2)
 8239948:	e0bffc15 	stw	r2,-16(fp)
   struct socket *   so =  inp->inp_socket;
 823994c:	e0bffc17 	ldw	r2,-16(fp)
 8239950:	10800817 	ldw	r2,32(r2)
 8239954:	e0bffd15 	stw	r2,-12(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 8239958:	e0bfff17 	ldw	r2,-4(fp)
 823995c:	10800017 	ldw	r2,0(r2)
 8239960:	e0bffb15 	stw	r2,-20(fp)
   while (t != (struct tcpiphdr *)tp) 
 8239964:	00000e06 	br	82399a0 <tcp_close+0x74>
   {
      t = (struct tcpiphdr *)t->ti_next;
 8239968:	e0bffb17 	ldw	r2,-20(fp)
 823996c:	10800017 	ldw	r2,0(r2)
 8239970:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(t->ti_prev);
 8239974:	e0bffb17 	ldw	r2,-20(fp)
 8239978:	10800117 	ldw	r2,4(r2)
 823997c:	1009883a 	mov	r4,r2
 8239980:	822e8d00 	call	822e8d0 <dtom>
 8239984:	e0bffe15 	stw	r2,-8(fp)
      remque(t->ti_prev);
 8239988:	e0bffb17 	ldw	r2,-20(fp)
 823998c:	10800117 	ldw	r2,4(r2)
 8239990:	1009883a 	mov	r4,r2
 8239994:	822e96c0 	call	822e96c <remque>
      m_freem (m);
 8239998:	e13ffe17 	ldw	r4,-8(fp)
 823999c:	822e3840 	call	822e384 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 82399a0:	e0fffb17 	ldw	r3,-20(fp)
 82399a4:	e0bfff17 	ldw	r2,-4(fp)
 82399a8:	18bfef1e 	bne	r3,r2,8239968 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 82399ac:	e0bfff17 	ldw	r2,-4(fp)
 82399b0:	10800c17 	ldw	r2,48(r2)
 82399b4:	10000426 	beq	r2,zero,82399c8 <tcp_close+0x9c>
      TPH_FREE (tp->t_template);
 82399b8:	e0bfff17 	ldw	r2,-4(fp)
 82399bc:	10800c17 	ldw	r2,48(r2)
 82399c0:	1009883a 	mov	r4,r2
 82399c4:	822deec0 	call	822deec <npfree>
   TCB_FREE (tp);
 82399c8:	e13fff17 	ldw	r4,-4(fp)
 82399cc:	822deec0 	call	822deec <npfree>
   inp->inp_ppcb = 0;
 82399d0:	e0bffc17 	ldw	r2,-16(fp)
 82399d4:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 82399d8:	e13ffd17 	ldw	r4,-12(fp)
 82399dc:	82339c00 	call	82339c0 <soisdisconnected>
   in_pcbdetach(inp);
 82399e0:	e13ffc17 	ldw	r4,-16(fp)
 82399e4:	8247c0c0 	call	8247c0c <in_pcbdetach>
   tcpstat.tcps_closed++;
 82399e8:	008209b4 	movhi	r2,2086
 82399ec:	10b8aa04 	addi	r2,r2,-7512
 82399f0:	10800517 	ldw	r2,20(r2)
 82399f4:	10c00044 	addi	r3,r2,1
 82399f8:	008209b4 	movhi	r2,2086
 82399fc:	10b8aa04 	addi	r2,r2,-7512
 8239a00:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 8239a04:	0005883a 	mov	r2,zero
}
 8239a08:	e037883a 	mov	sp,fp
 8239a0c:	dfc00117 	ldw	ra,4(sp)
 8239a10:	df000017 	ldw	fp,0(sp)
 8239a14:	dec00204 	addi	sp,sp,8
 8239a18:	f800283a 	ret

08239a1c <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 8239a1c:	defffd04 	addi	sp,sp,-12
 8239a20:	df000215 	stw	fp,8(sp)
 8239a24:	df000204 	addi	fp,sp,8
 8239a28:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 8239a2c:	e0bfff17 	ldw	r2,-4(fp)
 8239a30:	10800917 	ldw	r2,36(r2)
 8239a34:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 8239a38:	e0bffe17 	ldw	r2,-8(fp)
 8239a3c:	10000526 	beq	r2,zero,8239a54 <tcp_quench+0x38>
      tp->snd_cwnd = tp->t_maxseg;
 8239a40:	e0bffe17 	ldw	r2,-8(fp)
 8239a44:	10800a0b 	ldhu	r2,40(r2)
 8239a48:	10ffffcc 	andi	r3,r2,65535
 8239a4c:	e0bffe17 	ldw	r2,-8(fp)
 8239a50:	10c01b15 	stw	r3,108(r2)
}
 8239a54:	0001883a 	nop
 8239a58:	e037883a 	mov	sp,fp
 8239a5c:	df000017 	ldw	fp,0(sp)
 8239a60:	dec00104 	addi	sp,sp,4
 8239a64:	f800283a 	ret

08239a68 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 8239a68:	defffc04 	addi	sp,sp,-16
 8239a6c:	df000315 	stw	fp,12(sp)
 8239a70:	df000304 	addi	fp,sp,12
 8239a74:	e13ffe15 	stw	r4,-8(fp)
 8239a78:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 8239a7c:	e0bffe17 	ldw	r2,-8(fp)
 8239a80:	108000c4 	addi	r2,r2,3
 8239a84:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239a88:	e03ffd15 	stw	zero,-12(fp)
 8239a8c:	00000b06 	br	8239abc <tcp_putseq+0x54>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 8239a90:	e0bffe17 	ldw	r2,-8(fp)
 8239a94:	10ffffc4 	addi	r3,r2,-1
 8239a98:	e0fffe15 	stw	r3,-8(fp)
 8239a9c:	e0ffff17 	ldw	r3,-4(fp)
 8239aa0:	10c00005 	stb	r3,0(r2)
      seq >>= 8;
 8239aa4:	e0bfff17 	ldw	r2,-4(fp)
 8239aa8:	1004d23a 	srli	r2,r2,8
 8239aac:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239ab0:	e0bffd17 	ldw	r2,-12(fp)
 8239ab4:	10800044 	addi	r2,r2,1
 8239ab8:	e0bffd15 	stw	r2,-12(fp)
 8239abc:	e0bffd17 	ldw	r2,-12(fp)
 8239ac0:	10800110 	cmplti	r2,r2,4
 8239ac4:	103ff21e 	bne	r2,zero,8239a90 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 8239ac8:	e0bffe17 	ldw	r2,-8(fp)
 8239acc:	10800144 	addi	r2,r2,5
}
 8239ad0:	e037883a 	mov	sp,fp
 8239ad4:	df000017 	ldw	fp,0(sp)
 8239ad8:	dec00104 	addi	sp,sp,4
 8239adc:	f800283a 	ret

08239ae0 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 8239ae0:	defffc04 	addi	sp,sp,-16
 8239ae4:	df000315 	stw	fp,12(sp)
 8239ae8:	df000304 	addi	fp,sp,12
 8239aec:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 8239af0:	e03ffe15 	stw	zero,-8(fp)

   for(i = 0; i < 4; i++)
 8239af4:	e03ffd15 	stw	zero,-12(fp)
 8239af8:	00000e06 	br	8239b34 <tcp_getseq+0x54>
   {
      seq <<= 8;
 8239afc:	e0bffe17 	ldw	r2,-8(fp)
 8239b00:	1004923a 	slli	r2,r2,8
 8239b04:	e0bffe15 	stw	r2,-8(fp)
      seq += (u_long)*(cp++);
 8239b08:	e0bfff17 	ldw	r2,-4(fp)
 8239b0c:	10c00044 	addi	r3,r2,1
 8239b10:	e0ffff15 	stw	r3,-4(fp)
 8239b14:	10800003 	ldbu	r2,0(r2)
 8239b18:	10803fcc 	andi	r2,r2,255
 8239b1c:	e0fffe17 	ldw	r3,-8(fp)
 8239b20:	1885883a 	add	r2,r3,r2
 8239b24:	e0bffe15 	stw	r2,-8(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 8239b28:	e0bffd17 	ldw	r2,-12(fp)
 8239b2c:	10800044 	addi	r2,r2,1
 8239b30:	e0bffd15 	stw	r2,-12(fp)
 8239b34:	e0bffd17 	ldw	r2,-12(fp)
 8239b38:	10800110 	cmplti	r2,r2,4
 8239b3c:	103fef1e 	bne	r2,zero,8239afc <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 8239b40:	e0bffe17 	ldw	r2,-8(fp)
}
 8239b44:	e037883a 	mov	sp,fp
 8239b48:	df000017 	ldw	fp,0(sp)
 8239b4c:	dec00104 	addi	sp,sp,4
 8239b50:	f800283a 	ret

08239b54 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 8239b54:	defff704 	addi	sp,sp,-36
 8239b58:	dfc00815 	stw	ra,32(sp)
 8239b5c:	df000715 	stw	fp,28(sp)
 8239b60:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 8239b64:	d0a03f17 	ldw	r2,-32516(gp)
 8239b68:	100490fa 	slli	r2,r2,3
 8239b6c:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239b70:	008209b4 	movhi	r2,2086
 8239b74:	10b87704 	addi	r2,r2,-7716
 8239b78:	10800017 	ldw	r2,0(r2)
 8239b7c:	e0bffa15 	stw	r2,-24(fp)
 8239b80:	00008006 	br	8239d84 <tcp_slowtimo+0x230>
   {
      sonext = so->next;
 8239b84:	e0bffa17 	ldw	r2,-24(fp)
 8239b88:	10800017 	ldw	r2,0(r2)
 8239b8c:	e0bffb15 	stw	r2,-20(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 8239b90:	e0bffa17 	ldw	r2,-24(fp)
 8239b94:	10800983 	ldbu	r2,38(r2)
 8239b98:	10803fcc 	andi	r2,r2,255
 8239b9c:	1080201c 	xori	r2,r2,128
 8239ba0:	10bfe004 	addi	r2,r2,-128
 8239ba4:	10800058 	cmpnei	r2,r2,1
 8239ba8:	1000461e 	bne	r2,zero,8239cc4 <tcp_slowtimo+0x170>
      {
         ip = so->so_pcb;
 8239bac:	e0bffa17 	ldw	r2,-24(fp)
 8239bb0:	10800117 	ldw	r2,4(r2)
 8239bb4:	e0bffc15 	stw	r2,-16(fp)
         if (!ip)
 8239bb8:	e0bffc17 	ldw	r2,-16(fp)
 8239bbc:	10006a26 	beq	r2,zero,8239d68 <tcp_slowtimo+0x214>
            continue;
         ipnxt = ip->inp_next;
 8239bc0:	e0bffc17 	ldw	r2,-16(fp)
 8239bc4:	10800017 	ldw	r2,0(r2)
 8239bc8:	e0bffd15 	stw	r2,-12(fp)

         tp = intotcpcb(so->so_pcb);
 8239bcc:	e0bffa17 	ldw	r2,-24(fp)
 8239bd0:	10800117 	ldw	r2,4(r2)
 8239bd4:	10800917 	ldw	r2,36(r2)
 8239bd8:	e0bffe15 	stw	r2,-8(fp)
         if (!tp)
 8239bdc:	e0bffe17 	ldw	r2,-8(fp)
 8239be0:	10006326 	beq	r2,zero,8239d70 <tcp_slowtimo+0x21c>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239be4:	e03ff915 	stw	zero,-28(fp)
 8239be8:	00002e06 	br	8239ca4 <tcp_slowtimo+0x150>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 8239bec:	e0fffe17 	ldw	r3,-8(fp)
 8239bf0:	e0bff917 	ldw	r2,-28(fp)
 8239bf4:	108000c4 	addi	r2,r2,3
 8239bf8:	1085883a 	add	r2,r2,r2
 8239bfc:	1085883a 	add	r2,r2,r2
 8239c00:	1885883a 	add	r2,r3,r2
 8239c04:	10800017 	ldw	r2,0(r2)
 8239c08:	10002326 	beq	r2,zero,8239c98 <tcp_slowtimo+0x144>
 8239c0c:	e0fffe17 	ldw	r3,-8(fp)
 8239c10:	e0bff917 	ldw	r2,-28(fp)
 8239c14:	108000c4 	addi	r2,r2,3
 8239c18:	1085883a 	add	r2,r2,r2
 8239c1c:	1085883a 	add	r2,r2,r2
 8239c20:	1885883a 	add	r2,r3,r2
 8239c24:	10800017 	ldw	r2,0(r2)
 8239c28:	10ffffc4 	addi	r3,r2,-1
 8239c2c:	e13ffe17 	ldw	r4,-8(fp)
 8239c30:	e0bff917 	ldw	r2,-28(fp)
 8239c34:	108000c4 	addi	r2,r2,3
 8239c38:	1085883a 	add	r2,r2,r2
 8239c3c:	1085883a 	add	r2,r2,r2
 8239c40:	2085883a 	add	r2,r4,r2
 8239c44:	10c00015 	stw	r3,0(r2)
 8239c48:	e0fffe17 	ldw	r3,-8(fp)
 8239c4c:	e0bff917 	ldw	r2,-28(fp)
 8239c50:	108000c4 	addi	r2,r2,3
 8239c54:	1085883a 	add	r2,r2,r2
 8239c58:	1085883a 	add	r2,r2,r2
 8239c5c:	1885883a 	add	r2,r3,r2
 8239c60:	10800017 	ldw	r2,0(r2)
 8239c64:	10000c1e 	bne	r2,zero,8239c98 <tcp_slowtimo+0x144>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 8239c68:	e0bffa17 	ldw	r2,-24(fp)
 8239c6c:	00c004c4 	movi	r3,19
 8239c70:	10c00715 	stw	r3,28(r2)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 8239c74:	e0bff917 	ldw	r2,-28(fp)
 8239c78:	100d883a 	mov	r6,r2
 8239c7c:	000b883a 	mov	r5,zero
 8239c80:	e13ffa17 	ldw	r4,-24(fp)
 8239c84:	823a2a40 	call	823a2a4 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 8239c88:	e0bffd17 	ldw	r2,-12(fp)
 8239c8c:	10c00117 	ldw	r3,4(r2)
 8239c90:	e0bffc17 	ldw	r2,-16(fp)
 8239c94:	1880381e 	bne	r3,r2,8239d78 <tcp_slowtimo+0x224>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239c98:	e0bff917 	ldw	r2,-28(fp)
 8239c9c:	10800044 	addi	r2,r2,1
 8239ca0:	e0bff915 	stw	r2,-28(fp)
 8239ca4:	e0bff917 	ldw	r2,-28(fp)
 8239ca8:	10800110 	cmplti	r2,r2,4
 8239cac:	103fcf1e 	bne	r2,zero,8239bec <tcp_slowtimo+0x98>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 8239cb0:	e0bffe17 	ldw	r2,-8(fp)
 8239cb4:	10801d17 	ldw	r2,116(r2)
 8239cb8:	10c00044 	addi	r3,r2,1
 8239cbc:	e0bffe17 	ldw	r2,-8(fp)
 8239cc0:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 8239cc4:	e0bffa17 	ldw	r2,-24(fp)
 8239cc8:	10800a04 	addi	r2,r2,40
 8239ccc:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239cd0:	e0bfff17 	ldw	r2,-4(fp)
 8239cd4:	1080070b 	ldhu	r2,28(r2)
 8239cd8:	10bfffcc 	andi	r2,r2,65535
 8239cdc:	1080020c 	andi	r2,r2,8
 8239ce0:	10000a26 	beq	r2,zero,8239d0c <tcp_slowtimo+0x1b8>
      {
         select_wait = 0;
 8239ce4:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239ce8:	d120b004 	addi	r4,gp,-32064
 8239cec:	82293f40 	call	82293f4 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239cf0:	e0bfff17 	ldw	r2,-4(fp)
 8239cf4:	10c0070b 	ldhu	r3,28(r2)
 8239cf8:	00bffdc4 	movi	r2,-9
 8239cfc:	1884703a 	and	r2,r3,r2
 8239d00:	1007883a 	mov	r3,r2
 8239d04:	e0bfff17 	ldw	r2,-4(fp)
 8239d08:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 8239d0c:	e0bffa17 	ldw	r2,-24(fp)
 8239d10:	10801204 	addi	r2,r2,72
 8239d14:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239d18:	e0bfff17 	ldw	r2,-4(fp)
 8239d1c:	1080070b 	ldhu	r2,28(r2)
 8239d20:	10bfffcc 	andi	r2,r2,65535
 8239d24:	1080020c 	andi	r2,r2,8
 8239d28:	10000a26 	beq	r2,zero,8239d54 <tcp_slowtimo+0x200>
      {
         select_wait = 0;         
 8239d2c:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239d30:	d120b004 	addi	r4,gp,-32064
 8239d34:	82293f40 	call	82293f4 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239d38:	e0bfff17 	ldw	r2,-4(fp)
 8239d3c:	10c0070b 	ldhu	r3,28(r2)
 8239d40:	00bffdc4 	movi	r2,-9
 8239d44:	1884703a 	and	r2,r3,r2
 8239d48:	1007883a 	mov	r3,r2
 8239d4c:	e0bfff17 	ldw	r2,-4(fp)
 8239d50:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 8239d54:	e0bffa17 	ldw	r2,-24(fp)
 8239d58:	10800904 	addi	r2,r2,36
 8239d5c:	1009883a 	mov	r4,r2
 8239d60:	82293f40 	call	82293f4 <tcp_wakeup>
 8239d64:	00000506 	br	8239d7c <tcp_slowtimo+0x228>
       */
      if (so->so_type == SOCK_STREAM)
      {
         ip = so->so_pcb;
         if (!ip)
            continue;
 8239d68:	0001883a 	nop
 8239d6c:	00000306 	br	8239d7c <tcp_slowtimo+0x228>
         ipnxt = ip->inp_next;

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;
 8239d70:	0001883a 	nop
 8239d74:	00000106 	br	8239d7c <tcp_slowtimo+0x228>
               (void) tcp_usrreq(so, (struct mbuf *)0, 
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
                  goto tpgone;
 8239d78:	0001883a 	nop
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239d7c:	e0bffb17 	ldw	r2,-20(fp)
 8239d80:	e0bffa15 	stw	r2,-24(fp)
 8239d84:	e0bffa17 	ldw	r2,-24(fp)
 8239d88:	103f7e1e 	bne	r2,zero,8239b84 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 8239d8c:	d0e0b517 	ldw	r3,-32044(gp)
 8239d90:	00be9fd4 	movui	r2,64127
 8239d94:	1885883a 	add	r2,r3,r2
 8239d98:	d0a0b515 	stw	r2,-32044(gp)

   if (tcp_iss & 0xff000000)
 8239d9c:	d0a0b517 	ldw	r2,-32044(gp)
 8239da0:	10bfc02c 	andhi	r2,r2,65280
 8239da4:	10000126 	beq	r2,zero,8239dac <tcp_slowtimo+0x258>
      tcp_iss = 0L;
 8239da8:	d020b515 	stw	zero,-32044(gp)
}
 8239dac:	0001883a 	nop
 8239db0:	e037883a 	mov	sp,fp
 8239db4:	dfc00117 	ldw	ra,4(sp)
 8239db8:	df000017 	ldw	fp,0(sp)
 8239dbc:	dec00204 	addi	sp,sp,8
 8239dc0:	f800283a 	ret

08239dc4 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 8239dc4:	defffd04 	addi	sp,sp,-12
 8239dc8:	df000215 	stw	fp,8(sp)
 8239dcc:	df000204 	addi	fp,sp,8
 8239dd0:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 8239dd4:	e03ffe15 	stw	zero,-8(fp)
 8239dd8:	00000a06 	br	8239e04 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 8239ddc:	e0ffff17 	ldw	r3,-4(fp)
 8239de0:	e0bffe17 	ldw	r2,-8(fp)
 8239de4:	108000c4 	addi	r2,r2,3
 8239de8:	1085883a 	add	r2,r2,r2
 8239dec:	1085883a 	add	r2,r2,r2
 8239df0:	1885883a 	add	r2,r3,r2
 8239df4:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 8239df8:	e0bffe17 	ldw	r2,-8(fp)
 8239dfc:	10800044 	addi	r2,r2,1
 8239e00:	e0bffe15 	stw	r2,-8(fp)
 8239e04:	e0bffe17 	ldw	r2,-8(fp)
 8239e08:	10800110 	cmplti	r2,r2,4
 8239e0c:	103ff31e 	bne	r2,zero,8239ddc <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 8239e10:	0001883a 	nop
 8239e14:	e037883a 	mov	sp,fp
 8239e18:	df000017 	ldw	fp,0(sp)
 8239e1c:	dec00104 	addi	sp,sp,4
 8239e20:	f800283a 	ret

08239e24 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 8239e24:	defff804 	addi	sp,sp,-32
 8239e28:	dfc00715 	stw	ra,28(sp)
 8239e2c:	df000615 	stw	fp,24(sp)
 8239e30:	df000604 	addi	fp,sp,24
 8239e34:	e13ffe15 	stw	r4,-8(fp)
 8239e38:	e17fff15 	stw	r5,-4(fp)
   int   rexmt;

   switch (timer) 
 8239e3c:	e0bfff17 	ldw	r2,-4(fp)
 8239e40:	10c00060 	cmpeqi	r3,r2,1
 8239e44:	1800b21e 	bne	r3,zero,823a110 <tcp_timers+0x2ec>
 8239e48:	10c00088 	cmpgei	r3,r2,2
 8239e4c:	1800021e 	bne	r3,zero,8239e58 <tcp_timers+0x34>
 8239e50:	10001826 	beq	r2,zero,8239eb4 <tcp_timers+0x90>
 8239e54:	00010d06 	br	823a28c <tcp_timers+0x468>
 8239e58:	10c000a0 	cmpeqi	r3,r2,2
 8239e5c:	1800bd1e 	bne	r3,zero,823a154 <tcp_timers+0x330>
 8239e60:	108000e0 	cmpeqi	r2,r2,3
 8239e64:	10010926 	beq	r2,zero,823a28c <tcp_timers+0x468>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 8239e68:	e0bffe17 	ldw	r2,-8(fp)
 8239e6c:	10800217 	ldw	r2,8(r2)
 8239e70:	108002a0 	cmpeqi	r2,r2,10
 8239e74:	10000b1e 	bne	r2,zero,8239ea4 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
 8239e78:	e0bffe17 	ldw	r2,-8(fp)
 8239e7c:	10801d17 	ldw	r2,116(r2)
 8239e80:	d0e0b417 	ldw	r3,-32048(gp)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 8239e84:	18800716 	blt	r3,r2,8239ea4 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 8239e88:	d0a03f17 	ldw	r2,-32516(gp)
 8239e8c:	10ffffcc 	andi	r3,r2,65535
 8239e90:	18e0001c 	xori	r3,r3,32768
 8239e94:	18e00004 	addi	r3,r3,-32768
 8239e98:	e0bffe17 	ldw	r2,-8(fp)
 8239e9c:	10c00615 	stw	r3,24(r2)
      }
      else
         tp = tcp_close(tp);
      break;
 8239ea0:	0000fa06 	br	823a28c <tcp_timers+0x468>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 8239ea4:	e13ffe17 	ldw	r4,-8(fp)
 8239ea8:	823992c0 	call	823992c <tcp_close>
 8239eac:	e0bffe15 	stw	r2,-8(fp)
      break;
 8239eb0:	0000f606 	br	823a28c <tcp_timers+0x468>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 8239eb4:	008209b4 	movhi	r2,2086
 8239eb8:	10b87c04 	addi	r2,r2,-7696
 8239ebc:	10800b17 	ldw	r2,44(r2)
 8239ec0:	10c00044 	addi	r3,r2,1
 8239ec4:	008209b4 	movhi	r2,2086
 8239ec8:	10b87c04 	addi	r2,r2,-7696
 8239ecc:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 8239ed0:	e0bffe17 	ldw	r2,-8(fp)
 8239ed4:	10800717 	ldw	r2,28(r2)
 8239ed8:	10c00044 	addi	r3,r2,1
 8239edc:	e0bffe17 	ldw	r2,-8(fp)
 8239ee0:	10c00715 	stw	r3,28(r2)
 8239ee4:	e0bffe17 	ldw	r2,-8(fp)
 8239ee8:	10800717 	ldw	r2,28(r2)
 8239eec:	10800350 	cmplti	r2,r2,13
 8239ef0:	10000f1e 	bne	r2,zero,8239f30 <tcp_timers+0x10c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 8239ef4:	e0bffe17 	ldw	r2,-8(fp)
 8239ef8:	00c00304 	movi	r3,12
 8239efc:	10c00715 	stw	r3,28(r2)
         tcpstat.tcps_timeoutdrop++;
 8239f00:	008209b4 	movhi	r2,2086
 8239f04:	10b8aa04 	addi	r2,r2,-7512
 8239f08:	10800917 	ldw	r2,36(r2)
 8239f0c:	10c00044 	addi	r3,r2,1
 8239f10:	008209b4 	movhi	r2,2086
 8239f14:	10b8aa04 	addi	r2,r2,-7512
 8239f18:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 8239f1c:	01401d04 	movi	r5,116
 8239f20:	e13ffe17 	ldw	r4,-8(fp)
 8239f24:	82398800 	call	8239880 <tcp_drop>
 8239f28:	e0bffe15 	stw	r2,-8(fp)
         break;
 8239f2c:	0000d706 	br	823a28c <tcp_timers+0x468>
      }
      tcpstat.tcps_rexmttimeo++;
 8239f30:	008209b4 	movhi	r2,2086
 8239f34:	10b8aa04 	addi	r2,r2,-7512
 8239f38:	10800a17 	ldw	r2,40(r2)
 8239f3c:	10c00044 	addi	r3,r2,1
 8239f40:	008209b4 	movhi	r2,2086
 8239f44:	10b8aa04 	addi	r2,r2,-7512
 8239f48:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8239f4c:	e0bffe17 	ldw	r2,-8(fp)
 8239f50:	10802017 	ldw	r2,128(r2)
 8239f54:	1007d0ba 	srai	r3,r2,2
 8239f58:	e0bffe17 	ldw	r2,-8(fp)
 8239f5c:	10802117 	ldw	r2,132(r2)
 8239f60:	1885883a 	add	r2,r3,r2
 8239f64:	1005d07a 	srai	r2,r2,1
 8239f68:	e0bffd15 	stw	r2,-12(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 8239f6c:	e0bffe17 	ldw	r2,-8(fp)
 8239f70:	10c00717 	ldw	r3,28(r2)
 8239f74:	00820974 	movhi	r2,2085
 8239f78:	108de4c4 	addi	r2,r2,14227
 8239f7c:	10c5883a 	add	r2,r2,r3
 8239f80:	10800003 	ldbu	r2,0(r2)
 8239f84:	10803fcc 	andi	r2,r2,255
 8239f88:	e0fffd17 	ldw	r3,-12(fp)
 8239f8c:	1885383a 	mul	r2,r3,r2
 8239f90:	e0bffd15 	stw	r2,-12(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 8239f94:	e0bffd17 	ldw	r2,-12(fp)
 8239f98:	10ffffcc 	andi	r3,r2,65535
 8239f9c:	18e0001c 	xori	r3,r3,32768
 8239fa0:	18e00004 	addi	r3,r3,-32768
 8239fa4:	e0bffe17 	ldw	r2,-8(fp)
 8239fa8:	10c00815 	stw	r3,32(r2)
 8239fac:	e0bffe17 	ldw	r2,-8(fp)
 8239fb0:	10800817 	ldw	r2,32(r2)
 8239fb4:	10800088 	cmpgei	r2,r2,2
 8239fb8:	1000041e 	bne	r2,zero,8239fcc <tcp_timers+0x1a8>
 8239fbc:	e0bffe17 	ldw	r2,-8(fp)
 8239fc0:	00c00084 	movi	r3,2
 8239fc4:	10c00815 	stw	r3,32(r2)
 8239fc8:	00000706 	br	8239fe8 <tcp_timers+0x1c4>
 8239fcc:	e0bffe17 	ldw	r2,-8(fp)
 8239fd0:	10800817 	ldw	r2,32(r2)
 8239fd4:	10802050 	cmplti	r2,r2,129
 8239fd8:	1000031e 	bne	r2,zero,8239fe8 <tcp_timers+0x1c4>
 8239fdc:	e0bffe17 	ldw	r2,-8(fp)
 8239fe0:	00c02004 	movi	r3,128
 8239fe4:	10c00815 	stw	r3,32(r2)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8239fe8:	e0bffe17 	ldw	r2,-8(fp)
 8239fec:	10c00817 	ldw	r3,32(r2)
 8239ff0:	e0bffe17 	ldw	r2,-8(fp)
 8239ff4:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 8239ff8:	e0bffe17 	ldw	r2,-8(fp)
 8239ffc:	10800717 	ldw	r2,28(r2)
 823a000:	10800110 	cmplti	r2,r2,4
 823a004:	10000f1e 	bne	r2,zero,823a044 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
 823a008:	e0bffe17 	ldw	r2,-8(fp)
 823a00c:	10800b0b 	ldhu	r2,44(r2)
 823a010:	10bfffcc 	andi	r2,r2,65535
 823a014:	1080400c 	andi	r2,r2,256
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a018:	10000a1e 	bne	r2,zero,823a044 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 823a01c:	e0bffe17 	ldw	r2,-8(fp)
 823a020:	10c02117 	ldw	r3,132(r2)
 823a024:	e0bffe17 	ldw	r2,-8(fp)
 823a028:	10802017 	ldw	r2,128(r2)
 823a02c:	1005d0ba 	srai	r2,r2,2
 823a030:	1887883a 	add	r3,r3,r2
 823a034:	e0bffe17 	ldw	r2,-8(fp)
 823a038:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 823a03c:	e0bffe17 	ldw	r2,-8(fp)
 823a040:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 823a044:	e0bffe17 	ldw	r2,-8(fp)
 823a048:	10c00e17 	ldw	r3,56(r2)
 823a04c:	e0bffe17 	ldw	r2,-8(fp)
 823a050:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 823a054:	e0bffe17 	ldw	r2,-8(fp)
 823a058:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 823a05c:	e0bffe17 	ldw	r2,-8(fp)
 823a060:	10800d17 	ldw	r2,52(r2)
 823a064:	10800817 	ldw	r2,32(r2)
 823a068:	10800417 	ldw	r2,16(r2)
 823a06c:	1090000c 	andi	r2,r2,16384
 823a070:	1000241e 	bne	r2,zero,823a104 <tcp_timers+0x2e0>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 823a074:	e0bffe17 	ldw	r2,-8(fp)
 823a078:	11001417 	ldw	r4,80(r2)
 823a07c:	e0bffe17 	ldw	r2,-8(fp)
 823a080:	10c01b17 	ldw	r3,108(r2)
 823a084:	2005883a 	mov	r2,r4
 823a088:	1880012e 	bgeu	r3,r2,823a090 <tcp_timers+0x26c>
 823a08c:	1805883a 	mov	r2,r3
 823a090:	e0bffc15 	stw	r2,-16(fp)
         win = win / 2 / tp->t_maxseg;
 823a094:	e0bffc17 	ldw	r2,-16(fp)
 823a098:	1006d07a 	srli	r3,r2,1
 823a09c:	e0bffe17 	ldw	r2,-8(fp)
 823a0a0:	10800a0b 	ldhu	r2,40(r2)
 823a0a4:	10bfffcc 	andi	r2,r2,65535
 823a0a8:	100b883a 	mov	r5,r2
 823a0ac:	1809883a 	mov	r4,r3
 823a0b0:	820295c0 	call	820295c <__udivsi3>
 823a0b4:	e0bffc15 	stw	r2,-16(fp)
         if (win < 2)
 823a0b8:	e0bffc17 	ldw	r2,-16(fp)
 823a0bc:	108000a8 	cmpgeui	r2,r2,2
 823a0c0:	1000021e 	bne	r2,zero,823a0cc <tcp_timers+0x2a8>
            win = 2;
 823a0c4:	00800084 	movi	r2,2
 823a0c8:	e0bffc15 	stw	r2,-16(fp)
         tp->snd_cwnd = tp->t_maxseg;
 823a0cc:	e0bffe17 	ldw	r2,-8(fp)
 823a0d0:	10800a0b 	ldhu	r2,40(r2)
 823a0d4:	10ffffcc 	andi	r3,r2,65535
 823a0d8:	e0bffe17 	ldw	r2,-8(fp)
 823a0dc:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 823a0e0:	e0bffc17 	ldw	r2,-16(fp)
 823a0e4:	10ffffcc 	andi	r3,r2,65535
 823a0e8:	e0bffe17 	ldw	r2,-8(fp)
 823a0ec:	10800a0b 	ldhu	r2,40(r2)
 823a0f0:	10bfffcc 	andi	r2,r2,65535
 823a0f4:	1885383a 	mul	r2,r3,r2
 823a0f8:	1007883a 	mov	r3,r2
 823a0fc:	e0bffe17 	ldw	r2,-8(fp)
 823a100:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 823a104:	e13ffe17 	ldw	r4,-8(fp)
 823a108:	823804c0 	call	823804c <tcp_output>
      break;
 823a10c:	00005f06 	br	823a28c <tcp_timers+0x468>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 823a110:	008209b4 	movhi	r2,2086
 823a114:	10b8aa04 	addi	r2,r2,-7512
 823a118:	10800b17 	ldw	r2,44(r2)
 823a11c:	10c00044 	addi	r3,r2,1
 823a120:	008209b4 	movhi	r2,2086
 823a124:	10b8aa04 	addi	r2,r2,-7512
 823a128:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 823a12c:	e13ffe17 	ldw	r4,-8(fp)
 823a130:	82390500 	call	8239050 <tcp_setpersist>
      tp->t_force = 1;
 823a134:	e0bffe17 	ldw	r2,-8(fp)
 823a138:	00c00044 	movi	r3,1
 823a13c:	10c00a85 	stb	r3,42(r2)
      (void) tcp_output(tp);
 823a140:	e13ffe17 	ldw	r4,-8(fp)
 823a144:	823804c0 	call	823804c <tcp_output>
      tp->t_force = 0;
 823a148:	e0bffe17 	ldw	r2,-8(fp)
 823a14c:	10000a85 	stb	zero,42(r2)
      break;
 823a150:	00004e06 	br	823a28c <tcp_timers+0x468>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 823a154:	008209b4 	movhi	r2,2086
 823a158:	10b8aa04 	addi	r2,r2,-7512
 823a15c:	10800c17 	ldw	r2,48(r2)
 823a160:	10c00044 	addi	r3,r2,1
 823a164:	008209b4 	movhi	r2,2086
 823a168:	10b8aa04 	addi	r2,r2,-7512
 823a16c:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 823a170:	e0bffe17 	ldw	r2,-8(fp)
 823a174:	10800217 	ldw	r2,8(r2)
 823a178:	10800108 	cmpgei	r2,r2,4
 823a17c:	10003426 	beq	r2,zero,823a250 <tcp_timers+0x42c>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a180:	e0bffe17 	ldw	r2,-8(fp)
 823a184:	10800d17 	ldw	r2,52(r2)
 823a188:	10800817 	ldw	r2,32(r2)
 823a18c:	10800417 	ldw	r2,16(r2)
 823a190:	1080020c 	andi	r2,r2,8
 823a194:	10002726 	beq	r2,zero,823a234 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
 823a198:	e0bffe17 	ldw	r2,-8(fp)
 823a19c:	10800217 	ldw	r2,8(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a1a0:	10800188 	cmpgei	r2,r2,6
 823a1a4:	1000231e 	bne	r2,zero,823a234 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 823a1a8:	e0bffe17 	ldw	r2,-8(fp)
 823a1ac:	10c01d17 	ldw	r3,116(r2)
 823a1b0:	d1203e17 	ldw	r4,-32520(gp)
 823a1b4:	d0a0b417 	ldw	r2,-32048(gp)
 823a1b8:	2085883a 	add	r2,r4,r2
 823a1bc:	1880260e 	bge	r3,r2,823a258 <tcp_timers+0x434>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 823a1c0:	008209b4 	movhi	r2,2086
 823a1c4:	10b8aa04 	addi	r2,r2,-7512
 823a1c8:	10800d17 	ldw	r2,52(r2)
 823a1cc:	10c00044 	addi	r3,r2,1
 823a1d0:	008209b4 	movhi	r2,2086
 823a1d4:	10b8aa04 	addi	r2,r2,-7512
 823a1d8:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a1dc:	e0bffe17 	ldw	r2,-8(fp)
 823a1e0:	10c00c17 	ldw	r3,48(r2)
 823a1e4:	e0bffe17 	ldw	r2,-8(fp)
 823a1e8:	10801617 	ldw	r2,88(r2)
 823a1ec:	113fffc4 	addi	r4,r2,-1
            tp->snd_una - 1, 0, (struct mbuf *)NULL);
 823a1f0:	e0bffe17 	ldw	r2,-8(fp)
 823a1f4:	10800e17 	ldw	r2,56(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a1f8:	10bfffc4 	addi	r2,r2,-1
 823a1fc:	d8000115 	stw	zero,4(sp)
 823a200:	d8000015 	stw	zero,0(sp)
 823a204:	100f883a 	mov	r7,r2
 823a208:	200d883a 	mov	r6,r4
 823a20c:	180b883a 	mov	r5,r3
 823a210:	e13ffe17 	ldw	r4,-8(fp)
 823a214:	82393740 	call	8239374 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 823a218:	d0a03f17 	ldw	r2,-32516(gp)
 823a21c:	10ffffcc 	andi	r3,r2,65535
 823a220:	18e0001c 	xori	r3,r3,32768
 823a224:	18e00004 	addi	r3,r3,-32768
 823a228:	e0bffe17 	ldw	r2,-8(fp)
 823a22c:	10c00515 	stw	r3,20(r2)
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
 823a230:	00001606 	br	823a28c <tcp_timers+0x468>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 823a234:	d0a03e17 	ldw	r2,-32520(gp)
 823a238:	10ffffcc 	andi	r3,r2,65535
 823a23c:	18e0001c 	xori	r3,r3,32768
 823a240:	18e00004 	addi	r3,r3,-32768
 823a244:	e0bffe17 	ldw	r2,-8(fp)
 823a248:	10c00515 	stw	r3,20(r2)
      break;
 823a24c:	00000f06 	br	823a28c <tcp_timers+0x468>
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
 823a250:	0001883a 	nop
 823a254:	00000106 	br	823a25c <tcp_timers+0x438>
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
            goto dropit;
 823a258:	0001883a 	nop
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
      dropit:
      tcpstat.tcps_keepdrops++;
 823a25c:	008209b4 	movhi	r2,2086
 823a260:	10b8aa04 	addi	r2,r2,-7512
 823a264:	10800e17 	ldw	r2,56(r2)
 823a268:	10c00044 	addi	r3,r2,1
 823a26c:	008209b4 	movhi	r2,2086
 823a270:	10b8aa04 	addi	r2,r2,-7512
 823a274:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 823a278:	01401d04 	movi	r5,116
 823a27c:	e13ffe17 	ldw	r4,-8(fp)
 823a280:	82398800 	call	8239880 <tcp_drop>
 823a284:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a288:	0001883a 	nop
   }
   return tp;
 823a28c:	e0bffe17 	ldw	r2,-8(fp)
}
 823a290:	e037883a 	mov	sp,fp
 823a294:	dfc00117 	ldw	ra,4(sp)
 823a298:	df000017 	ldw	fp,0(sp)
 823a29c:	dec00204 	addi	sp,sp,8
 823a2a0:	f800283a 	ret

0823a2a4 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823a2a4:	defff604 	addi	sp,sp,-40
 823a2a8:	dfc00915 	stw	ra,36(sp)
 823a2ac:	df000815 	stw	fp,32(sp)
 823a2b0:	df000804 	addi	fp,sp,32
 823a2b4:	e13ffd15 	stw	r4,-12(fp)
 823a2b8:	e17ffe15 	stw	r5,-8(fp)
 823a2bc:	e1bfff15 	stw	r6,-4(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 823a2c0:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 823a2c4:	e0bffd17 	ldw	r2,-12(fp)
 823a2c8:	10800717 	ldw	r2,28(r2)
 823a2cc:	e0bffa15 	stw	r2,-24(fp)
   inp = sotoinpcb(so);
 823a2d0:	e0bffd17 	ldw	r2,-12(fp)
 823a2d4:	10800117 	ldw	r2,4(r2)
 823a2d8:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 823a2dc:	e0bffb17 	ldw	r2,-20(fp)
 823a2e0:	1000041e 	bne	r2,zero,823a2f4 <tcp_usrreq+0x50>
 823a2e4:	e0bffa17 	ldw	r2,-24(fp)
 823a2e8:	10000226 	beq	r2,zero,823a2f4 <tcp_usrreq+0x50>
   {
      return (EINVAL);
 823a2ec:	00800584 	movi	r2,22
 823a2f0:	00019c06 	br	823a964 <tcp_usrreq+0x6c0>
   }

   if (inp)
 823a2f4:	e0bffb17 	ldw	r2,-20(fp)
 823a2f8:	10000426 	beq	r2,zero,823a30c <tcp_usrreq+0x68>
      tp = intotcpcb(inp);
 823a2fc:	e0bffb17 	ldw	r2,-20(fp)
 823a300:	10800917 	ldw	r2,36(r2)
 823a304:	e0bff815 	stw	r2,-32(fp)
 823a308:	00000706 	br	823a328 <tcp_usrreq+0x84>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 823a30c:	e0bffa17 	ldw	r2,-24(fp)
 823a310:	1000021e 	bne	r2,zero,823a31c <tcp_usrreq+0x78>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 823a314:	e03ff815 	stw	zero,-32(fp)
 823a318:	00000306 	br	823a328 <tcp_usrreq+0x84>
      else
      {
         dtrap(); /* programming error? */
 823a31c:	822d2e00 	call	822d2e0 <dtrap>
         return EINVAL;
 823a320:	00800584 	movi	r2,22
 823a324:	00018f06 	br	823a964 <tcp_usrreq+0x6c0>
      }
   }

   switch (req) 
 823a328:	e0bffa17 	ldw	r2,-24(fp)
 823a32c:	10800528 	cmpgeui	r2,r2,20
 823a330:	1001761e 	bne	r2,zero,823a90c <tcp_usrreq+0x668>
 823a334:	e0bffa17 	ldw	r2,-24(fp)
 823a338:	100690ba 	slli	r3,r2,2
 823a33c:	00820934 	movhi	r2,2084
 823a340:	10a8d404 	addi	r2,r2,-23728
 823a344:	1885883a 	add	r2,r3,r2
 823a348:	10800017 	ldw	r2,0(r2)
 823a34c:	1000683a 	jmp	r2
 823a350:	0823a3a0 	cmpeqi	zero,at,-29042
 823a354:	0823a400 	call	823a40 <OSCtxSw_SWITCH_PC+0x823a00>
 823a358:	0823a428 	cmpgeui	zero,at,36496
 823a35c:	0823a460 	cmpeqi	zero,at,-29039
 823a360:	0823a498 	cmpnei	zero,at,-29038
 823a364:	0823a5f0 	cmpltui	zero,at,36503
 823a368:	0823a5e4 	muli	zero,at,-29033
 823a36c:	0823a6a0 	cmpeqi	zero,at,-29030
 823a370:	0823a6cc 	andi	zero,at,36507
 823a374:	0823a6d8 	cmpnei	zero,at,-29029
 823a378:	0823a734 	orhi	zero,at,36508
 823a37c:	0823a90c 	andi	zero,at,36516
 823a380:	0823a744 	addi	zero,at,-29027
 823a384:	0823a750 	cmplti	zero,at,-29027
 823a388:	0823a808 	cmpgei	zero,at,-29024
 823a38c:	0823a8d8 	cmpnei	zero,at,-29021
 823a390:	0823a8e8 	cmpgeui	zero,at,36515
 823a394:	0823a5d8 	cmpnei	zero,at,-29033
 823a398:	0823a90c 	andi	zero,at,36516
 823a39c:	0823a8f8 	rdprs	zero,at,-29021
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 823a3a0:	e0bffb17 	ldw	r2,-20(fp)
 823a3a4:	10000326 	beq	r2,zero,823a3b4 <tcp_usrreq+0x110>
      {
         error = EISCONN;
 823a3a8:	00801fc4 	movi	r2,127
 823a3ac:	e0bff915 	stw	r2,-28(fp)
         break;
 823a3b0:	00016b06 	br	823a960 <tcp_usrreq+0x6bc>
      }
      error = tcp_attach(so);
 823a3b4:	e13ffd17 	ldw	r4,-12(fp)
 823a3b8:	823a9780 	call	823a978 <tcp_attach>
 823a3bc:	e0bff915 	stw	r2,-28(fp)
      if (error)
 823a3c0:	e0bff917 	ldw	r2,-28(fp)
 823a3c4:	1001551e 	bne	r2,zero,823a91c <tcp_usrreq+0x678>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823a3c8:	e0bffd17 	ldw	r2,-12(fp)
 823a3cc:	10800417 	ldw	r2,16(r2)
 823a3d0:	1080200c 	andi	r2,r2,128
 823a3d4:	10015326 	beq	r2,zero,823a924 <tcp_usrreq+0x680>
 823a3d8:	e0bffd17 	ldw	r2,-12(fp)
 823a3dc:	1080080b 	ldhu	r2,32(r2)
 823a3e0:	10bfffcc 	andi	r2,r2,65535
 823a3e4:	10a0001c 	xori	r2,r2,32768
 823a3e8:	10a00004 	addi	r2,r2,-32768
 823a3ec:	10014d1e 	bne	r2,zero,823a924 <tcp_usrreq+0x680>
         so->so_linger = TCP_LINGERTIME;
 823a3f0:	e0bffd17 	ldw	r2,-12(fp)
 823a3f4:	00c01e04 	movi	r3,120
 823a3f8:	10c0080d 	sth	r3,32(r2)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a3fc:	00014906 	br	823a924 <tcp_usrreq+0x680>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 823a400:	e0bff817 	ldw	r2,-32(fp)
 823a404:	10800217 	ldw	r2,8(r2)
 823a408:	10800090 	cmplti	r2,r2,2
 823a40c:	1000031e 	bne	r2,zero,823a41c <tcp_usrreq+0x178>
         SETTP(tp, tcp_disconnect(tp));
 823a410:	e13ff817 	ldw	r4,-32(fp)
 823a414:	823aa900 	call	823aa90 <tcp_disconnect>
      else
         SETTP(tp, tcp_close(tp));
      break;
 823a418:	00015106 	br	823a960 <tcp_usrreq+0x6bc>
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
         SETTP(tp, tcp_disconnect(tp));
      else
         SETTP(tp, tcp_close(tp));
 823a41c:	e13ff817 	ldw	r4,-32(fp)
 823a420:	823992c0 	call	823992c <tcp_close>
      break;
 823a424:	00014e06 	br	823a960 <tcp_usrreq+0x6bc>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 823a428:	e0bffb17 	ldw	r2,-20(fp)
 823a42c:	10800817 	ldw	r2,32(r2)
 823a430:	10800517 	ldw	r2,20(r2)
 823a434:	10800098 	cmpnei	r2,r2,2
 823a438:	1000051e 	bne	r2,zero,823a450 <tcp_usrreq+0x1ac>
      {
         error = in_pcbbind(inp, nam);
 823a43c:	e17fff17 	ldw	r5,-4(fp)
 823a440:	e13ffb17 	ldw	r4,-20(fp)
 823a444:	8247c640 	call	8247c64 <in_pcbbind>
 823a448:	e0bff915 	stw	r2,-28(fp)
         break;
 823a44c:	00014406 	br	823a960 <tcp_usrreq+0x6bc>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 823a450:	822d2e00 	call	822d2e0 <dtrap>
      error = EINVAL;
 823a454:	00800584 	movi	r2,22
 823a458:	e0bff915 	stw	r2,-28(fp)
      break;
 823a45c:	00014006 	br	823a960 <tcp_usrreq+0x6bc>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 823a460:	e0bffb17 	ldw	r2,-20(fp)
 823a464:	1080078b 	ldhu	r2,30(r2)
 823a468:	10bfffcc 	andi	r2,r2,65535
 823a46c:	1000041e 	bne	r2,zero,823a480 <tcp_usrreq+0x1dc>
         error = in_pcbbind(inp, (struct mbuf *)0);
 823a470:	000b883a 	mov	r5,zero
 823a474:	e13ffb17 	ldw	r4,-20(fp)
 823a478:	8247c640 	call	8247c64 <in_pcbbind>
 823a47c:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 823a480:	e0bff917 	ldw	r2,-28(fp)
 823a484:	1001291e 	bne	r2,zero,823a92c <tcp_usrreq+0x688>
         tp->t_state = TCPS_LISTEN;
 823a488:	e0bff817 	ldw	r2,-32(fp)
 823a48c:	00c00044 	movi	r3,1
 823a490:	10c00215 	stw	r3,8(r2)
      break;
 823a494:	00012506 	br	823a92c <tcp_usrreq+0x688>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 823a498:	e0bffb17 	ldw	r2,-20(fp)
 823a49c:	1080078b 	ldhu	r2,30(r2)
 823a4a0:	10bfffcc 	andi	r2,r2,65535
 823a4a4:	1000061e 	bne	r2,zero,823a4c0 <tcp_usrreq+0x21c>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 823a4a8:	000b883a 	mov	r5,zero
 823a4ac:	e13ffb17 	ldw	r4,-20(fp)
 823a4b0:	8247c640 	call	8247c64 <in_pcbbind>
 823a4b4:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 823a4b8:	e0bff917 	ldw	r2,-28(fp)
 823a4bc:	10011d1e 	bne	r2,zero,823a934 <tcp_usrreq+0x690>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 823a4c0:	e17fff17 	ldw	r5,-4(fp)
 823a4c4:	e13ffb17 	ldw	r4,-20(fp)
 823a4c8:	8247e740 	call	8247e74 <in_pcbconnect>
 823a4cc:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 823a4d0:	e0bff917 	ldw	r2,-28(fp)
 823a4d4:	1001191e 	bne	r2,zero,823a93c <tcp_usrreq+0x698>
         break;
      tp->t_template = tcp_template(tp);
 823a4d8:	e13ff817 	ldw	r4,-32(fp)
 823a4dc:	823926c0 	call	823926c <tcp_template>
 823a4e0:	1007883a 	mov	r3,r2
 823a4e4:	e0bff817 	ldw	r2,-32(fp)
 823a4e8:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 823a4ec:	e0bff817 	ldw	r2,-32(fp)
 823a4f0:	10800c17 	ldw	r2,48(r2)
 823a4f4:	1000051e 	bne	r2,zero,823a50c <tcp_usrreq+0x268>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 823a4f8:	e13ffb17 	ldw	r4,-20(fp)
 823a4fc:	82480540 	call	8248054 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 823a500:	00801a44 	movi	r2,105
 823a504:	e0bff915 	stw	r2,-28(fp)
         break;
 823a508:	00011506 	br	823a960 <tcp_usrreq+0x6bc>
      }

      soisconnecting(so);
 823a50c:	e13ffd17 	ldw	r4,-12(fp)
 823a510:	82337b40 	call	82337b4 <soisconnecting>
      tcpstat.tcps_connattempt++;
 823a514:	008209b4 	movhi	r2,2086
 823a518:	10b8aa04 	addi	r2,r2,-7512
 823a51c:	10800017 	ldw	r2,0(r2)
 823a520:	10c00044 	addi	r3,r2,1
 823a524:	008209b4 	movhi	r2,2086
 823a528:	10b8aa04 	addi	r2,r2,-7512
 823a52c:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 823a530:	e0bff817 	ldw	r2,-32(fp)
 823a534:	00c00084 	movi	r3,2
 823a538:	10c00215 	stw	r3,8(r2)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 823a53c:	e0bff817 	ldw	r2,-32(fp)
 823a540:	00c02584 	movi	r3,150
 823a544:	10c00515 	stw	r3,20(r2)
      tp->iss = tcp_iss; 
 823a548:	d0e0b517 	ldw	r3,-32044(gp)
 823a54c:	e0bff817 	ldw	r2,-32(fp)
 823a550:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 823a554:	d0e0b517 	ldw	r3,-32044(gp)
 823a558:	00be9fd4 	movui	r2,64127
 823a55c:	1885883a 	add	r2,r3,r2
 823a560:	d0a0b515 	stw	r2,-32044(gp)
      tcp_sendseqinit(tp);
 823a564:	e0bff817 	ldw	r2,-32(fp)
 823a568:	10c01317 	ldw	r3,76(r2)
 823a56c:	e0bff817 	ldw	r2,-32(fp)
 823a570:	10c01015 	stw	r3,64(r2)
 823a574:	e0bff817 	ldw	r2,-32(fp)
 823a578:	10c01017 	ldw	r3,64(r2)
 823a57c:	e0bff817 	ldw	r2,-32(fp)
 823a580:	10c01a15 	stw	r3,104(r2)
 823a584:	e0bff817 	ldw	r2,-32(fp)
 823a588:	10c01a17 	ldw	r3,104(r2)
 823a58c:	e0bff817 	ldw	r2,-32(fp)
 823a590:	10c00f15 	stw	r3,60(r2)
 823a594:	e0bff817 	ldw	r2,-32(fp)
 823a598:	10c00f17 	ldw	r3,60(r2)
 823a59c:	e0bff817 	ldw	r2,-32(fp)
 823a5a0:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 823a5a4:	e13ff817 	ldw	r4,-32(fp)
 823a5a8:	823804c0 	call	823804c <tcp_output>
 823a5ac:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 823a5b0:	e0bff917 	ldw	r2,-28(fp)
 823a5b4:	1000e31e 	bne	r2,zero,823a944 <tcp_usrreq+0x6a0>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 823a5b8:	008209b4 	movhi	r2,2086
 823a5bc:	10b87c04 	addi	r2,r2,-7696
 823a5c0:	10800417 	ldw	r2,16(r2)
 823a5c4:	10c00044 	addi	r3,r2,1
 823a5c8:	008209b4 	movhi	r2,2086
 823a5cc:	10b87c04 	addi	r2,r2,-7696
 823a5d0:	10c00415 	stw	r3,16(r2)
      break;
 823a5d4:	0000db06 	br	823a944 <tcp_usrreq+0x6a0>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 823a5d8:	008017c4 	movi	r2,95
 823a5dc:	e0bff915 	stw	r2,-28(fp)
      break;
 823a5e0:	0000df06 	br	823a960 <tcp_usrreq+0x6bc>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 823a5e4:	e13ff817 	ldw	r4,-32(fp)
 823a5e8:	823aa900 	call	823aa90 <tcp_disconnect>
      break;
 823a5ec:	0000dc06 	br	823a960 <tcp_usrreq+0x6bc>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 823a5f0:	e0bfff17 	ldw	r2,-4(fp)
 823a5f4:	10800317 	ldw	r2,12(r2)
 823a5f8:	e0bffc15 	stw	r2,-16(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 823a5fc:	e0bffd17 	ldw	r2,-12(fp)
 823a600:	10800517 	ldw	r2,20(r2)
 823a604:	10800098 	cmpnei	r2,r2,2
 823a608:	10000e1e 	bne	r2,zero,823a644 <tcp_usrreq+0x3a0>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 823a60c:	e0bfff17 	ldw	r2,-4(fp)
 823a610:	00c00404 	movi	r3,16
 823a614:	10c00215 	stw	r3,8(r2)
            sin->sin_family = AF_INET;
 823a618:	e0bffc17 	ldw	r2,-16(fp)
 823a61c:	00c00084 	movi	r3,2
 823a620:	10c0000d 	sth	r3,0(r2)
            sin->sin_port = inp->inp_fport;
 823a624:	e0bffb17 	ldw	r2,-20(fp)
 823a628:	10c0070b 	ldhu	r3,28(r2)
 823a62c:	e0bffc17 	ldw	r2,-16(fp)
 823a630:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 823a634:	e0bffc17 	ldw	r2,-16(fp)
 823a638:	e0fffb17 	ldw	r3,-20(fp)
 823a63c:	18c00317 	ldw	r3,12(r3)
 823a640:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a644:	e0bffd17 	ldw	r2,-12(fp)
 823a648:	10800517 	ldw	r2,20(r2)
 823a64c:	108000a0 	cmpeqi	r2,r2,2
 823a650:	10000b1e 	bne	r2,zero,823a680 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
 823a654:	e0bffd17 	ldw	r2,-12(fp)
 823a658:	10800517 	ldw	r2,20(r2)
            sin->sin_family = AF_INET;
            sin->sin_port = inp->inp_fport;
            sin->sin_addr = inp->inp_faddr;
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a65c:	108000e0 	cmpeqi	r2,r2,3
 823a660:	1000071e 	bne	r2,zero,823a680 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 823a664:	e0bffd17 	ldw	r2,-12(fp)
 823a668:	10800517 	ldw	r2,20(r2)
 823a66c:	100b883a 	mov	r5,r2
 823a670:	01020974 	movhi	r4,2085
 823a674:	2102da04 	addi	r4,r4,2920
 823a678:	82030ec0 	call	82030ec <printf>
            dtrap();
 823a67c:	822d2e00 	call	822d2e0 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 823a680:	008209b4 	movhi	r2,2086
 823a684:	10b87c04 	addi	r2,r2,-7696
 823a688:	10800517 	ldw	r2,20(r2)
 823a68c:	10c00044 	addi	r3,r2,1
 823a690:	008209b4 	movhi	r2,2086
 823a694:	10b87c04 	addi	r2,r2,-7696
 823a698:	10c00515 	stw	r3,20(r2)
         break;
 823a69c:	0000b006 	br	823a960 <tcp_usrreq+0x6bc>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 823a6a0:	e13ffd17 	ldw	r4,-12(fp)
 823a6a4:	8233e380 	call	8233e38 <socantsendmore>
      tp = tcp_usrclosed(tp);
 823a6a8:	e13ff817 	ldw	r4,-32(fp)
 823a6ac:	823ab5c0 	call	823ab5c <tcp_usrclosed>
 823a6b0:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 823a6b4:	e0bff817 	ldw	r2,-32(fp)
 823a6b8:	1000a426 	beq	r2,zero,823a94c <tcp_usrreq+0x6a8>
         error = tcp_output(tp);
 823a6bc:	e13ff817 	ldw	r4,-32(fp)
 823a6c0:	823804c0 	call	823804c <tcp_output>
 823a6c4:	e0bff915 	stw	r2,-28(fp)
      break;
 823a6c8:	0000a006 	br	823a94c <tcp_usrreq+0x6a8>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 823a6cc:	e13ff817 	ldw	r4,-32(fp)
 823a6d0:	823804c0 	call	823804c <tcp_output>
      break;
 823a6d4:	0000a206 	br	823a960 <tcp_usrreq+0x6bc>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 823a6d8:	e0bffd17 	ldw	r2,-12(fp)
 823a6dc:	10800117 	ldw	r2,4(r2)
 823a6e0:	1000031e 	bne	r2,zero,823a6f0 <tcp_usrreq+0x44c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a6e4:	00800804 	movi	r2,32
 823a6e8:	e0bff915 	stw	r2,-28(fp)
         break;
 823a6ec:	00009c06 	br	823a960 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
 823a6f0:	e0bffd17 	ldw	r2,-12(fp)
 823a6f4:	10801204 	addi	r2,r2,72
 823a6f8:	e17ffe17 	ldw	r5,-8(fp)
 823a6fc:	1009883a 	mov	r4,r2
 823a700:	82341400 	call	8234140 <sbappend>
      error = tcp_output(tp);
 823a704:	e13ff817 	ldw	r4,-32(fp)
 823a708:	823804c0 	call	823804c <tcp_output>
 823a70c:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a710:	e0bff917 	ldw	r2,-28(fp)
 823a714:	10801a58 	cmpnei	r2,r2,105
 823a718:	10008e1e 	bne	r2,zero,823a954 <tcp_usrreq+0x6b0>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a71c:	e0bffd17 	ldw	r2,-12(fp)
 823a720:	10801204 	addi	r2,r2,72
 823a724:	e17ffe17 	ldw	r5,-8(fp)
 823a728:	1009883a 	mov	r4,r2
 823a72c:	82348b00 	call	82348b0 <sbdropend>
      break;
 823a730:	00008806 	br	823a954 <tcp_usrreq+0x6b0>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 823a734:	01401c44 	movi	r5,113
 823a738:	e13ff817 	ldw	r4,-32(fp)
 823a73c:	82398800 	call	8239880 <tcp_drop>
      break;
 823a740:	00008706 	br	823a960 <tcp_usrreq+0x6bc>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 823a744:	822d2e00 	call	822d2e0 <dtrap>
      return (0);
 823a748:	0005883a 	mov	r2,zero
 823a74c:	00008506 	br	823a964 <tcp_usrreq+0x6c0>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823a750:	e0bffd17 	ldw	r2,-12(fp)
 823a754:	10801a17 	ldw	r2,104(r2)
 823a758:	1000051e 	bne	r2,zero,823a770 <tcp_usrreq+0x4cc>
          (so->so_state & SS_RCVATMARK) == 0) ||
 823a75c:	e0bffd17 	ldw	r2,-12(fp)
 823a760:	1080088b 	ldhu	r2,34(r2)
 823a764:	10bfffcc 	andi	r2,r2,65535
 823a768:	1080100c 	andi	r2,r2,64
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823a76c:	10000926 	beq	r2,zero,823a794 <tcp_usrreq+0x4f0>
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823a770:	e0bffd17 	ldw	r2,-12(fp)
 823a774:	10800417 	ldw	r2,16(r2)
 823a778:	1080400c 	andi	r2,r2,256
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
 823a77c:	1000051e 	bne	r2,zero,823a794 <tcp_usrreq+0x4f0>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
 823a780:	e0bff817 	ldw	r2,-32(fp)
 823a784:	10802403 	ldbu	r2,144(r2)
 823a788:	10803fcc 	andi	r2,r2,255
 823a78c:	1080008c 	andi	r2,r2,2

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823a790:	10000326 	beq	r2,zero,823a7a0 <tcp_usrreq+0x4fc>
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 823a794:	00800584 	movi	r2,22
 823a798:	e0bff915 	stw	r2,-28(fp)
         break;
 823a79c:	00007006 	br	823a960 <tcp_usrreq+0x6bc>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 823a7a0:	e0bff817 	ldw	r2,-32(fp)
 823a7a4:	10802403 	ldbu	r2,144(r2)
 823a7a8:	10803fcc 	andi	r2,r2,255
 823a7ac:	1080004c 	andi	r2,r2,1
 823a7b0:	1000031e 	bne	r2,zero,823a7c0 <tcp_usrreq+0x51c>
      {
         error = EWOULDBLOCK;
 823a7b4:	008002c4 	movi	r2,11
 823a7b8:	e0bff915 	stw	r2,-28(fp)
         break;
 823a7bc:	00006806 	br	823a960 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
 823a7c0:	e0bffe17 	ldw	r2,-8(fp)
 823a7c4:	00c00044 	movi	r3,1
 823a7c8:	10c00215 	stw	r3,8(r2)
      *mtod(m, char *) = tp->t_iobc;
 823a7cc:	e0bffe17 	ldw	r2,-8(fp)
 823a7d0:	10800317 	ldw	r2,12(r2)
 823a7d4:	e0fff817 	ldw	r3,-32(fp)
 823a7d8:	18c02443 	ldbu	r3,145(r3)
 823a7dc:	10c00005 	stb	r3,0(r2)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 823a7e0:	e0bfff17 	ldw	r2,-4(fp)
 823a7e4:	1080008c 	andi	r2,r2,2
 823a7e8:	10005c1e 	bne	r2,zero,823a95c <tcp_usrreq+0x6b8>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 823a7ec:	e0bff817 	ldw	r2,-32(fp)
 823a7f0:	10802403 	ldbu	r2,144(r2)
 823a7f4:	108000dc 	xori	r2,r2,3
 823a7f8:	1007883a 	mov	r3,r2
 823a7fc:	e0bff817 	ldw	r2,-32(fp)
 823a800:	10c02405 	stb	r3,144(r2)
      break;
 823a804:	00005506 	br	823a95c <tcp_usrreq+0x6b8>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 823a808:	e0bffd17 	ldw	r2,-12(fp)
 823a80c:	10800117 	ldw	r2,4(r2)
 823a810:	1000031e 	bne	r2,zero,823a820 <tcp_usrreq+0x57c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a814:	00800804 	movi	r2,32
 823a818:	e0bff915 	stw	r2,-28(fp)
         break;
 823a81c:	00005006 	br	823a960 <tcp_usrreq+0x6bc>
      }
      if (sbspace(&so->so_snd) == 0) 
 823a820:	e0bffd17 	ldw	r2,-12(fp)
 823a824:	10801317 	ldw	r2,76(r2)
 823a828:	1007883a 	mov	r3,r2
 823a82c:	e0bffd17 	ldw	r2,-12(fp)
 823a830:	10801217 	ldw	r2,72(r2)
 823a834:	1885c83a 	sub	r2,r3,r2
 823a838:	10000516 	blt	r2,zero,823a850 <tcp_usrreq+0x5ac>
 823a83c:	e0bffd17 	ldw	r2,-12(fp)
 823a840:	10c01317 	ldw	r3,76(r2)
 823a844:	e0bffd17 	ldw	r2,-12(fp)
 823a848:	10801217 	ldw	r2,72(r2)
 823a84c:	1880051e 	bne	r3,r2,823a864 <tcp_usrreq+0x5c0>
      {
         m_freem(m);
 823a850:	e13ffe17 	ldw	r4,-8(fp)
 823a854:	822e3840 	call	822e384 <m_freem>
         error = ENOBUFS;
 823a858:	00801a44 	movi	r2,105
 823a85c:	e0bff915 	stw	r2,-28(fp)
         break;
 823a860:	00003f06 	br	823a960 <tcp_usrreq+0x6bc>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 823a864:	e0bffd17 	ldw	r2,-12(fp)
 823a868:	10801204 	addi	r2,r2,72
 823a86c:	e17ffe17 	ldw	r5,-8(fp)
 823a870:	1009883a 	mov	r4,r2
 823a874:	82341400 	call	8234140 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 823a878:	e0bff817 	ldw	r2,-32(fp)
 823a87c:	10c00e17 	ldw	r3,56(r2)
 823a880:	e0bffd17 	ldw	r2,-12(fp)
 823a884:	10801217 	ldw	r2,72(r2)
 823a888:	1887883a 	add	r3,r3,r2
 823a88c:	e0bff817 	ldw	r2,-32(fp)
 823a890:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 823a894:	e0bff817 	ldw	r2,-32(fp)
 823a898:	00c00044 	movi	r3,1
 823a89c:	10c00a85 	stb	r3,42(r2)
      error = tcp_output(tp);
 823a8a0:	e13ff817 	ldw	r4,-32(fp)
 823a8a4:	823804c0 	call	823804c <tcp_output>
 823a8a8:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a8ac:	e0bff917 	ldw	r2,-28(fp)
 823a8b0:	10801a58 	cmpnei	r2,r2,105
 823a8b4:	1000051e 	bne	r2,zero,823a8cc <tcp_usrreq+0x628>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a8b8:	e0bffd17 	ldw	r2,-12(fp)
 823a8bc:	10801204 	addi	r2,r2,72
 823a8c0:	e17ffe17 	ldw	r5,-8(fp)
 823a8c4:	1009883a 	mov	r4,r2
 823a8c8:	82348b00 	call	82348b0 <sbdropend>
      tp->t_force = 0;
 823a8cc:	e0bff817 	ldw	r2,-32(fp)
 823a8d0:	10000a85 	stb	zero,42(r2)
      break;
 823a8d4:	00002206 	br	823a960 <tcp_usrreq+0x6bc>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 823a8d8:	e17fff17 	ldw	r5,-4(fp)
 823a8dc:	e13ffb17 	ldw	r4,-20(fp)
 823a8e0:	82480b00 	call	82480b0 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 823a8e4:	00001e06 	br	823a960 <tcp_usrreq+0x6bc>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 823a8e8:	e17fff17 	ldw	r5,-4(fp)
 823a8ec:	e13ffb17 	ldw	r4,-20(fp)
 823a8f0:	82481340 	call	8248134 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 823a8f4:	00001a06 	br	823a960 <tcp_usrreq+0x6bc>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 823a8f8:	e0bfff17 	ldw	r2,-4(fp)
 823a8fc:	100b883a 	mov	r5,r2
 823a900:	e13ff817 	ldw	r4,-32(fp)
 823a904:	8239e240 	call	8239e24 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 823a908:	00001506 	br	823a960 <tcp_usrreq+0x6bc>

      default:
      panic("tcp_usrreq");
 823a90c:	01020974 	movhi	r4,2085
 823a910:	2102e204 	addi	r4,r4,2952
 823a914:	82289940 	call	8228994 <panic>
 823a918:	00001106 	br	823a960 <tcp_usrreq+0x6bc>
         error = EISCONN;
         break;
      }
      error = tcp_attach(so);
      if (error)
         break;
 823a91c:	0001883a 	nop
 823a920:	00000f06 	br	823a960 <tcp_usrreq+0x6bc>
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
         so->so_linger = TCP_LINGERTIME;
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a924:	0001883a 	nop
 823a928:	00000d06 	br	823a960 <tcp_usrreq+0x6bc>
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
         error = in_pcbbind(inp, (struct mbuf *)0);
      if (error == 0)
         tp->t_state = TCPS_LISTEN;
      break;
 823a92c:	0001883a 	nop
 823a930:	00000b06 	br	823a960 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
            break;
 823a934:	0001883a 	nop
 823a938:	00000906 	br	823a960 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
         break;
 823a93c:	0001883a 	nop
 823a940:	00000706 	br	823a960 <tcp_usrreq+0x6bc>
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
      tcp_sendseqinit(tp);
      error = tcp_output(tp);
      if (!error)
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
      break;
 823a944:	0001883a 	nop
 823a948:	00000506 	br	823a960 <tcp_usrreq+0x6bc>
   case PRU_SHUTDOWN:
      socantsendmore(so);
      tp = tcp_usrclosed(tp);
      if (tp)
         error = tcp_output(tp);
      break;
 823a94c:	0001883a 	nop
 823a950:	00000306 	br	823a960 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
      error = tcp_output(tp);
      if (error == ENOBUFS)
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
      break;
 823a954:	0001883a 	nop
 823a958:	00000106 	br	823a960 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
      *mtod(m, char *) = tp->t_iobc;
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
      break;
 823a95c:	0001883a 	nop
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 823a960:	e0bff917 	ldw	r2,-28(fp)
}
 823a964:	e037883a 	mov	sp,fp
 823a968:	dfc00117 	ldw	ra,4(sp)
 823a96c:	df000017 	ldw	fp,0(sp)
 823a970:	dec00204 	addi	sp,sp,8
 823a974:	f800283a 	ret

0823a978 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 823a978:	defff904 	addi	sp,sp,-28
 823a97c:	dfc00615 	stw	ra,24(sp)
 823a980:	df000515 	stw	fp,20(sp)
 823a984:	df000504 	addi	fp,sp,20
 823a988:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 823a98c:	e0bfff17 	ldw	r2,-4(fp)
 823a990:	10801317 	ldw	r2,76(r2)
 823a994:	10000326 	beq	r2,zero,823a9a4 <tcp_attach+0x2c>
 823a998:	e0bfff17 	ldw	r2,-4(fp)
 823a99c:	10800b17 	ldw	r2,44(r2)
 823a9a0:	10000b1e 	bne	r2,zero,823a9d0 <tcp_attach+0x58>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 823a9a4:	d0a04017 	ldw	r2,-32512(gp)
 823a9a8:	d0e04117 	ldw	r3,-32508(gp)
 823a9ac:	180d883a 	mov	r6,r3
 823a9b0:	100b883a 	mov	r5,r2
 823a9b4:	e13fff17 	ldw	r4,-4(fp)
 823a9b8:	823401c0 	call	823401c <soreserve>
 823a9bc:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 823a9c0:	e0bffb17 	ldw	r2,-20(fp)
 823a9c4:	10000226 	beq	r2,zero,823a9d0 <tcp_attach+0x58>
         return (error);
 823a9c8:	e0bffb17 	ldw	r2,-20(fp)
 823a9cc:	00002b06 	br	823aa7c <tcp_attach+0x104>
   }
   error = in_pcballoc(so, &tcb);
 823a9d0:	014209b4 	movhi	r5,2086
 823a9d4:	29789f04 	addi	r5,r5,-7556
 823a9d8:	e13fff17 	ldw	r4,-4(fp)
 823a9dc:	8247b840 	call	8247b84 <in_pcballoc>
 823a9e0:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 823a9e4:	e0bffb17 	ldw	r2,-20(fp)
 823a9e8:	10000226 	beq	r2,zero,823a9f4 <tcp_attach+0x7c>
      return (error);
 823a9ec:	e0bffb17 	ldw	r2,-20(fp)
 823a9f0:	00002206 	br	823aa7c <tcp_attach+0x104>
   inp = sotoinpcb(so);
 823a9f4:	e0bfff17 	ldw	r2,-4(fp)
 823a9f8:	10800117 	ldw	r2,4(r2)
 823a9fc:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 823aa00:	e13ffc17 	ldw	r4,-16(fp)
 823aa04:	82397740 	call	8239774 <tcp_newtcpcb>
 823aa08:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 823aa0c:	e0bffd17 	ldw	r2,-12(fp)
 823aa10:	1000171e 	bne	r2,zero,823aa70 <tcp_attach+0xf8>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 823aa14:	e0bfff17 	ldw	r2,-4(fp)
 823aa18:	1080088b 	ldhu	r2,34(r2)
 823aa1c:	10bfffcc 	andi	r2,r2,65535
 823aa20:	1080004c 	andi	r2,r2,1
 823aa24:	e0bffe15 	stw	r2,-8(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 823aa28:	e0bfff17 	ldw	r2,-4(fp)
 823aa2c:	10c0088b 	ldhu	r3,34(r2)
 823aa30:	00bfff84 	movi	r2,-2
 823aa34:	1884703a 	and	r2,r3,r2
 823aa38:	1007883a 	mov	r3,r2
 823aa3c:	e0bfff17 	ldw	r2,-4(fp)
 823aa40:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 823aa44:	e13ffc17 	ldw	r4,-16(fp)
 823aa48:	8247c0c0 	call	8247c0c <in_pcbdetach>
      so->so_state |= nofd;
 823aa4c:	e0bfff17 	ldw	r2,-4(fp)
 823aa50:	1080088b 	ldhu	r2,34(r2)
 823aa54:	e0fffe17 	ldw	r3,-8(fp)
 823aa58:	10c4b03a 	or	r2,r2,r3
 823aa5c:	1007883a 	mov	r3,r2
 823aa60:	e0bfff17 	ldw	r2,-4(fp)
 823aa64:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 823aa68:	00801a44 	movi	r2,105
 823aa6c:	00000306 	br	823aa7c <tcp_attach+0x104>
   }
   tp->t_state = TCPS_CLOSED;
 823aa70:	e0bffd17 	ldw	r2,-12(fp)
 823aa74:	10000215 	stw	zero,8(r2)
   return (0);
 823aa78:	0005883a 	mov	r2,zero
}
 823aa7c:	e037883a 	mov	sp,fp
 823aa80:	dfc00117 	ldw	ra,4(sp)
 823aa84:	df000017 	ldw	fp,0(sp)
 823aa88:	dec00204 	addi	sp,sp,8
 823aa8c:	f800283a 	ret

0823aa90 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 823aa90:	defffc04 	addi	sp,sp,-16
 823aa94:	dfc00315 	stw	ra,12(sp)
 823aa98:	df000215 	stw	fp,8(sp)
 823aa9c:	df000204 	addi	fp,sp,8
 823aaa0:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823aaa4:	e0bfff17 	ldw	r2,-4(fp)
 823aaa8:	10800d17 	ldw	r2,52(r2)
 823aaac:	10800817 	ldw	r2,32(r2)
 823aab0:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 823aab4:	e0bfff17 	ldw	r2,-4(fp)
 823aab8:	10800217 	ldw	r2,8(r2)
 823aabc:	10800108 	cmpgei	r2,r2,4
 823aac0:	1000041e 	bne	r2,zero,823aad4 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 823aac4:	e13fff17 	ldw	r4,-4(fp)
 823aac8:	823992c0 	call	823992c <tcp_close>
 823aacc:	e0bfff15 	stw	r2,-4(fp)
 823aad0:	00001c06 	br	823ab44 <tcp_disconnect+0xb4>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823aad4:	e0bffe17 	ldw	r2,-8(fp)
 823aad8:	10800417 	ldw	r2,16(r2)
 823aadc:	1080200c 	andi	r2,r2,128
 823aae0:	10000b26 	beq	r2,zero,823ab10 <tcp_disconnect+0x80>
 823aae4:	e0bffe17 	ldw	r2,-8(fp)
 823aae8:	1080080b 	ldhu	r2,32(r2)
 823aaec:	10bfffcc 	andi	r2,r2,65535
 823aaf0:	10a0001c 	xori	r2,r2,32768
 823aaf4:	10a00004 	addi	r2,r2,-32768
 823aaf8:	1000051e 	bne	r2,zero,823ab10 <tcp_disconnect+0x80>
      tp = tcp_drop(tp, 0);
 823aafc:	000b883a 	mov	r5,zero
 823ab00:	e13fff17 	ldw	r4,-4(fp)
 823ab04:	82398800 	call	8239880 <tcp_drop>
 823ab08:	e0bfff15 	stw	r2,-4(fp)
 823ab0c:	00000d06 	br	823ab44 <tcp_disconnect+0xb4>
   else 
   {
      soisdisconnecting(so);
 823ab10:	e13ffe17 	ldw	r4,-8(fp)
 823ab14:	82339280 	call	8233928 <soisdisconnecting>
      sbflush(&so->so_rcv);
 823ab18:	e0bffe17 	ldw	r2,-8(fp)
 823ab1c:	10800a04 	addi	r2,r2,40
 823ab20:	1009883a 	mov	r4,r2
 823ab24:	82346740 	call	8234674 <sbflush>
      tp = tcp_usrclosed(tp);
 823ab28:	e13fff17 	ldw	r4,-4(fp)
 823ab2c:	823ab5c0 	call	823ab5c <tcp_usrclosed>
 823ab30:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 823ab34:	e0bfff17 	ldw	r2,-4(fp)
 823ab38:	10000226 	beq	r2,zero,823ab44 <tcp_disconnect+0xb4>
         (void) tcp_output(tp);
 823ab3c:	e13fff17 	ldw	r4,-4(fp)
 823ab40:	823804c0 	call	823804c <tcp_output>
   }
   return (tp);
 823ab44:	e0bfff17 	ldw	r2,-4(fp)
}
 823ab48:	e037883a 	mov	sp,fp
 823ab4c:	dfc00117 	ldw	ra,4(sp)
 823ab50:	df000017 	ldw	fp,0(sp)
 823ab54:	dec00204 	addi	sp,sp,8
 823ab58:	f800283a 	ret

0823ab5c <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 823ab5c:	defffd04 	addi	sp,sp,-12
 823ab60:	dfc00215 	stw	ra,8(sp)
 823ab64:	df000115 	stw	fp,4(sp)
 823ab68:	df000104 	addi	fp,sp,4
 823ab6c:	e13fff15 	stw	r4,-4(fp)

   switch (tp->t_state) 
 823ab70:	e0bfff17 	ldw	r2,-4(fp)
 823ab74:	10800217 	ldw	r2,8(r2)
 823ab78:	10c001a8 	cmpgeui	r3,r2,6
 823ab7c:	18001a1e 	bne	r3,zero,823abe8 <tcp_usrclosed+0x8c>
 823ab80:	100690ba 	slli	r3,r2,2
 823ab84:	00820934 	movhi	r2,2084
 823ab88:	10aae604 	addi	r2,r2,-21608
 823ab8c:	1885883a 	add	r2,r3,r2
 823ab90:	10800017 	ldw	r2,0(r2)
 823ab94:	1000683a 	jmp	r2
 823ab98:	0823abb0 	cmpltui	zero,at,36526
 823ab9c:	0823abb0 	cmpltui	zero,at,36526
 823aba0:	0823abb0 	cmpltui	zero,at,36526
 823aba4:	0823abc8 	cmpgei	zero,at,-29009
 823aba8:	0823abc8 	cmpgei	zero,at,-29009
 823abac:	0823abd8 	cmpnei	zero,at,-29009
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 823abb0:	e0bfff17 	ldw	r2,-4(fp)
 823abb4:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 823abb8:	e13fff17 	ldw	r4,-4(fp)
 823abbc:	823992c0 	call	823992c <tcp_close>
 823abc0:	e0bfff15 	stw	r2,-4(fp)
      break;
 823abc4:	00000806 	br	823abe8 <tcp_usrclosed+0x8c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 823abc8:	e0bfff17 	ldw	r2,-4(fp)
 823abcc:	00c00184 	movi	r3,6
 823abd0:	10c00215 	stw	r3,8(r2)
      break;
 823abd4:	00000406 	br	823abe8 <tcp_usrclosed+0x8c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 823abd8:	e0bfff17 	ldw	r2,-4(fp)
 823abdc:	00c00204 	movi	r3,8
 823abe0:	10c00215 	stw	r3,8(r2)
      break;
 823abe4:	0001883a 	nop
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 823abe8:	e0bfff17 	ldw	r2,-4(fp)
 823abec:	10000926 	beq	r2,zero,823ac14 <tcp_usrclosed+0xb8>
 823abf0:	e0bfff17 	ldw	r2,-4(fp)
 823abf4:	10800217 	ldw	r2,8(r2)
 823abf8:	10800250 	cmplti	r2,r2,9
 823abfc:	1000051e 	bne	r2,zero,823ac14 <tcp_usrclosed+0xb8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 823ac00:	e0bfff17 	ldw	r2,-4(fp)
 823ac04:	10800d17 	ldw	r2,52(r2)
 823ac08:	10800817 	ldw	r2,32(r2)
 823ac0c:	1009883a 	mov	r4,r2
 823ac10:	82339c00 	call	82339c0 <soisdisconnected>
   return (tp);
 823ac14:	e0bfff17 	ldw	r2,-4(fp)
}
 823ac18:	e037883a 	mov	sp,fp
 823ac1c:	dfc00117 	ldw	ra,4(sp)
 823ac20:	df000017 	ldw	fp,0(sp)
 823ac24:	dec00204 	addi	sp,sp,8
 823ac28:	f800283a 	ret

0823ac2c <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 823ac2c:	defffd04 	addi	sp,sp,-12
 823ac30:	dfc00215 	stw	ra,8(sp)
 823ac34:	df000115 	stw	fp,4(sp)
 823ac38:	df000104 	addi	fp,sp,4
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 823ac3c:	822ea580 	call	822ea58 <nptcp_init>
 823ac40:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 823ac44:	e0bfff17 	ldw	r2,-4(fp)
 823ac48:	10000226 	beq	r2,zero,823ac54 <tcpinit+0x28>
      return e;
 823ac4c:	e0bfff17 	ldw	r2,-4(fp)
 823ac50:	00000106 	br	823ac58 <tcpinit+0x2c>

   return 0;   /* good return */
 823ac54:	0005883a 	mov	r2,zero
}
 823ac58:	e037883a 	mov	sp,fp
 823ac5c:	dfc00117 	ldw	ra,4(sp)
 823ac60:	df000017 	ldw	fp,0(sp)
 823ac64:	dec00204 	addi	sp,sp,8
 823ac68:	f800283a 	ret

0823ac6c <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 823ac6c:	defffd04 	addi	sp,sp,-12
 823ac70:	df000215 	stw	fp,8(sp)
 823ac74:	df000204 	addi	fp,sp,8
 823ac78:	e13fff15 	stw	r4,-4(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823ac7c:	d0a09c17 	ldw	r2,-32144(gp)
 823ac80:	e0bffe15 	stw	r2,-8(fp)
 823ac84:	00000906 	br	823acac <udp_lookup+0x40>
      if (tmp->u_data == (void*)so)
 823ac88:	e0bffe17 	ldw	r2,-8(fp)
 823ac8c:	10c00617 	ldw	r3,24(r2)
 823ac90:	e0bfff17 	ldw	r2,-4(fp)
 823ac94:	1880021e 	bne	r3,r2,823aca0 <udp_lookup+0x34>
      return (tmp);
 823ac98:	e0bffe17 	ldw	r2,-8(fp)
 823ac9c:	00000606 	br	823acb8 <udp_lookup+0x4c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823aca0:	e0bffe17 	ldw	r2,-8(fp)
 823aca4:	10800017 	ldw	r2,0(r2)
 823aca8:	e0bffe15 	stw	r2,-8(fp)
 823acac:	e0bffe17 	ldw	r2,-8(fp)
 823acb0:	103ff51e 	bne	r2,zero,823ac88 <udp_lookup+0x1c>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 823acb4:	0005883a 	mov	r2,zero
}
 823acb8:	e037883a 	mov	sp,fp
 823acbc:	df000017 	ldw	fp,0(sp)
 823acc0:	dec00104 	addi	sp,sp,4
 823acc4:	f800283a 	ret

0823acc8 <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 823acc8:	defff504 	addi	sp,sp,-44
 823accc:	dfc00a15 	stw	ra,40(sp)
 823acd0:	df000915 	stw	fp,36(sp)
 823acd4:	df000904 	addi	fp,sp,36
 823acd8:	e13ffe15 	stw	r4,-8(fp)
 823acdc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 823ace0:	e0bfff17 	ldw	r2,-4(fp)
 823ace4:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 823ace8:	0009883a 	mov	r4,zero
 823acec:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 823acf0:	e0bff717 	ldw	r2,-36(fp)
 823acf4:	10c00a17 	ldw	r3,40(r2)
 823acf8:	e0bffe17 	ldw	r2,-8(fp)
 823acfc:	10800417 	ldw	r2,16(r2)
 823ad00:	1887883a 	add	r3,r3,r2
 823ad04:	e0bff717 	ldw	r2,-36(fp)
 823ad08:	10800b17 	ldw	r2,44(r2)
 823ad0c:	18800436 	bltu	r3,r2,823ad20 <udp_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ad10:	0009883a 	mov	r4,zero
 823ad14:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ad18:	00801a44 	movi	r2,105
 823ad1c:	00004d06 	br	823ae54 <udp_soinput+0x18c>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 823ad20:	000b883a 	mov	r5,zero
 823ad24:	01000044 	movi	r4,1
 823ad28:	822e0f40 	call	822e0f4 <m_getnbuf>
 823ad2c:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 823ad30:	e0bff817 	ldw	r2,-32(fp)
 823ad34:	1000041e 	bne	r2,zero,823ad48 <udp_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ad38:	0009883a 	mov	r4,zero
 823ad3c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ad40:	00801a44 	movi	r2,105
 823ad44:	00004306 	br	823ae54 <udp_soinput+0x18c>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 823ad48:	e0bff817 	ldw	r2,-32(fp)
 823ad4c:	e0fffe17 	ldw	r3,-8(fp)
 823ad50:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 823ad54:	e0bffe17 	ldw	r2,-8(fp)
 823ad58:	10c00317 	ldw	r3,12(r2)
 823ad5c:	e0bff817 	ldw	r2,-32(fp)
 823ad60:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 823ad64:	e0bffe17 	ldw	r2,-8(fp)
 823ad68:	10c00417 	ldw	r3,16(r2)
 823ad6c:	e0bff817 	ldw	r2,-32(fp)
 823ad70:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 823ad74:	e0bffe17 	ldw	r2,-8(fp)
 823ad78:	10c00117 	ldw	r3,4(r2)
 823ad7c:	e0bff817 	ldw	r2,-32(fp)
 823ad80:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 823ad84:	e0bffe17 	ldw	r2,-8(fp)
 823ad88:	10c00217 	ldw	r3,8(r2)
 823ad8c:	e0bff817 	ldw	r2,-32(fp)
 823ad90:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 823ad94:	e0bffe17 	ldw	r2,-8(fp)
 823ad98:	10800717 	ldw	r2,28(r2)
 823ad9c:	e0bffb15 	stw	r2,-20(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 823ada0:	e0bffe17 	ldw	r2,-8(fp)
 823ada4:	10800317 	ldw	r2,12(r2)
 823ada8:	10bffe04 	addi	r2,r2,-8
 823adac:	e0bff915 	stw	r2,-28(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 823adb0:	e0bff917 	ldw	r2,-28(fp)
 823adb4:	1080000b 	ldhu	r2,0(r2)
 823adb8:	10bfffcc 	andi	r2,r2,65535
 823adbc:	1004d23a 	srli	r2,r2,8
 823adc0:	1007883a 	mov	r3,r2
 823adc4:	e0bff917 	ldw	r2,-28(fp)
 823adc8:	1080000b 	ldhu	r2,0(r2)
 823adcc:	10bfffcc 	andi	r2,r2,65535
 823add0:	1004923a 	slli	r2,r2,8
 823add4:	1884b03a 	or	r2,r3,r2
 823add8:	e0bffa8d 	sth	r2,-22(fp)
   sin.sin_family = AF_INET;
 823addc:	00800084 	movi	r2,2
 823ade0:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 823ade4:	e0bff717 	ldw	r2,-36(fp)
 823ade8:	10800a04 	addi	r2,r2,40
 823adec:	e0fffa04 	addi	r3,fp,-24
 823adf0:	e1bff817 	ldw	r6,-32(fp)
 823adf4:	180b883a 	mov	r5,r3
 823adf8:	1009883a 	mov	r4,r2
 823adfc:	82342b80 	call	82342b8 <sbappendaddr>
 823ae00:	1000081e 	bne	r2,zero,823ae24 <udp_soinput+0x15c>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 823ae04:	e0bff817 	ldw	r2,-32(fp)
 823ae08:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 823ae0c:	e13ff817 	ldw	r4,-32(fp)
 823ae10:	822e27c0 	call	822e27c <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ae14:	0009883a 	mov	r4,zero
 823ae18:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ae1c:	00801a44 	movi	r2,105
 823ae20:	00000c06 	br	823ae54 <udp_soinput+0x18c>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 823ae24:	e0bff717 	ldw	r2,-36(fp)
 823ae28:	10800a04 	addi	r2,r2,40
 823ae2c:	1009883a 	mov	r4,r2
 823ae30:	82293f40 	call	82293f4 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 823ae34:	e0bff717 	ldw	r2,-36(fp)
 823ae38:	10800a04 	addi	r2,r2,40
 823ae3c:	100b883a 	mov	r5,r2
 823ae40:	e13ff717 	ldw	r4,-36(fp)
 823ae44:	8233f900 	call	8233f90 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 823ae48:	0009883a 	mov	r4,zero
 823ae4c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return 0;
 823ae50:	0005883a 	mov	r2,zero
}
 823ae54:	e037883a 	mov	sp,fp
 823ae58:	dfc00117 	ldw	ra,4(sp)
 823ae5c:	df000017 	ldw	fp,0(sp)
 823ae60:	dec00204 	addi	sp,sp,8
 823ae64:	f800283a 	ret

0823ae68 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823ae68:	defff804 	addi	sp,sp,-32
 823ae6c:	dfc00715 	stw	ra,28(sp)
 823ae70:	df000615 	stw	fp,24(sp)
 823ae74:	df000604 	addi	fp,sp,24
 823ae78:	e13ffd15 	stw	r4,-12(fp)
 823ae7c:	e17ffe15 	stw	r5,-8(fp)
 823ae80:	e1bfff15 	stw	r6,-4(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 823ae84:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 823ae88:	e0bffd17 	ldw	r2,-12(fp)
 823ae8c:	10800717 	ldw	r2,28(r2)
 823ae90:	e0bffc15 	stw	r2,-16(fp)

   switch (req) 
 823ae94:	e0bffc17 	ldw	r2,-16(fp)
 823ae98:	10800468 	cmpgeui	r2,r2,17
 823ae9c:	10007b1e 	bne	r2,zero,823b08c <udp_usrreq+0x224>
 823aea0:	e0bffc17 	ldw	r2,-16(fp)
 823aea4:	100690ba 	slli	r3,r2,2
 823aea8:	00820934 	movhi	r2,2084
 823aeac:	10abaf04 	addi	r2,r2,-20804
 823aeb0:	1885883a 	add	r2,r3,r2
 823aeb4:	10800017 	ldw	r2,0(r2)
 823aeb8:	1000683a 	jmp	r2
 823aebc:	0823af00 	call	823af0 <OSCtxSw_SWITCH_PC+0x823ab0>
 823aec0:	0823af84 	addi	zero,at,-28994
 823aec4:	0823afc0 	call	823afc <OSCtxSw_SWITCH_PC+0x823abc>
 823aec8:	0823b08c 	andi	zero,at,36546
 823aecc:	0823afc0 	call	823afc <OSCtxSw_SWITCH_PC+0x823abc>
 823aed0:	0823b08c 	andi	zero,at,36546
 823aed4:	0823b080 	call	823b08 <OSCtxSw_SWITCH_PC+0x823ac8>
 823aed8:	0823b08c 	andi	zero,at,36546
 823aedc:	0823b080 	call	823b08 <OSCtxSw_SWITCH_PC+0x823ac8>
 823aee0:	0823b000 	call	823b00 <OSCtxSw_SWITCH_PC+0x823ac0>
 823aee4:	0823b08c 	andi	zero,at,36546
 823aee8:	0823b08c 	andi	zero,at,36546
 823aeec:	0823b08c 	andi	zero,at,36546
 823aef0:	0823b08c 	andi	zero,at,36546
 823aef4:	0823b08c 	andi	zero,at,36546
 823aef8:	0823b040 	call	823b04 <OSCtxSw_SWITCH_PC+0x823ac4>
 823aefc:	0823b040 	call	823b04 <OSCtxSw_SWITCH_PC+0x823ac4>
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 823af00:	82451f00 	call	82451f0 <udp_maxalloc>
 823af04:	1007883a 	mov	r3,r2
 823af08:	e0bffd17 	ldw	r2,-12(fp)
 823af0c:	10c01315 	stw	r3,76(r2)
 823af10:	e0bffd17 	ldw	r2,-12(fp)
 823af14:	10c01317 	ldw	r3,76(r2)
 823af18:	e0bffd17 	ldw	r2,-12(fp)
 823af1c:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 823af20:	e0bffd17 	ldw	r2,-12(fp)
 823af24:	10800517 	ldw	r2,20(r2)
 823af28:	10800098 	cmpnei	r2,r2,2
 823af2c:	10000f1e 	bne	r2,zero,823af6c <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 823af30:	0009883a 	mov	r4,zero
 823af34:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 823af38:	82450840 	call	8245084 <udp_socket>
 823af3c:	10ffffcc 	andi	r3,r2,65535
 823af40:	e0bffd17 	ldw	r2,-12(fp)
 823af44:	d8800015 	stw	r2,0(sp)
 823af48:	01c20934 	movhi	r7,2084
 823af4c:	39eb3204 	addi	r7,r7,-21304
 823af50:	180d883a 	mov	r6,r3
 823af54:	000b883a 	mov	r5,zero
 823af58:	0009883a 	mov	r4,zero
 823af5c:	822ce780 	call	822ce78 <udp_open>
 823af60:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 823af64:	0009883a 	mov	r4,zero
 823af68:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 823af6c:	e0bffb17 	ldw	r2,-20(fp)
 823af70:	1000021e 	bne	r2,zero,823af7c <udp_usrreq+0x114>
         return(EINVAL);
 823af74:	00800584 	movi	r2,22
 823af78:	00004506 	br	823b090 <udp_usrreq+0x228>
      return 0;
 823af7c:	0005883a 	mov	r2,zero
 823af80:	00004306 	br	823b090 <udp_usrreq+0x228>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 823af84:	e13ffd17 	ldw	r4,-12(fp)
 823af88:	823ac6c0 	call	823ac6c <udp_lookup>
 823af8c:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 823af90:	e0bffb17 	ldw	r2,-20(fp)
 823af94:	1000021e 	bne	r2,zero,823afa0 <udp_usrreq+0x138>
         return(EINVAL);
 823af98:	00800584 	movi	r2,22
 823af9c:	00003c06 	br	823b090 <udp_usrreq+0x228>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823afa0:	0009883a 	mov	r4,zero
 823afa4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 823afa8:	e13ffb17 	ldw	r4,-20(fp)
 823afac:	822d0740 	call	822d074 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 823afb0:	0009883a 	mov	r4,zero
 823afb4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      return 0;
 823afb8:	0005883a 	mov	r2,zero
 823afbc:	00003406 	br	823b090 <udp_usrreq+0x228>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 823afc0:	e0bfff17 	ldw	r2,-4(fp)
 823afc4:	1000021e 	bne	r2,zero,823afd0 <udp_usrreq+0x168>
         return(EINVAL);
 823afc8:	00800584 	movi	r2,22
 823afcc:	00003006 	br	823b090 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823afd0:	e0bffd17 	ldw	r2,-12(fp)
 823afd4:	10800517 	ldw	r2,20(r2)
 823afd8:	10800098 	cmpnei	r2,r2,2
 823afdc:	1000051e 	bne	r2,zero,823aff4 <udp_usrreq+0x18c>
        return udp4_sockbind(so, nam, req );
 823afe0:	e1bffc17 	ldw	r6,-16(fp)
 823afe4:	e17fff17 	ldw	r5,-4(fp)
 823afe8:	e13ffd17 	ldw	r4,-12(fp)
 823afec:	823b0a40 	call	823b0a4 <udp4_sockbind>
 823aff0:	00002706 	br	823b090 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823aff4:	822d2e00 	call	822d2e0 <dtrap>
      return EINVAL;
 823aff8:	00800584 	movi	r2,22
 823affc:	00002406 	br	823b090 <udp_usrreq+0x228>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 823b000:	e0bffe17 	ldw	r2,-8(fp)
 823b004:	1000021e 	bne	r2,zero,823b010 <udp_usrreq+0x1a8>
         return(EINVAL);
 823b008:	00800584 	movi	r2,22
 823b00c:	00002006 	br	823b090 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b010:	e0bffd17 	ldw	r2,-12(fp)
 823b014:	10800517 	ldw	r2,20(r2)
 823b018:	10800098 	cmpnei	r2,r2,2
 823b01c:	1000051e 	bne	r2,zero,823b034 <udp_usrreq+0x1cc>
        return udp4_socksend(so, m, nam );
 823b020:	e1bfff17 	ldw	r6,-4(fp)
 823b024:	e17ffe17 	ldw	r5,-8(fp)
 823b028:	e13ffd17 	ldw	r4,-12(fp)
 823b02c:	823b3780 	call	823b378 <udp4_socksend>
 823b030:	00001706 	br	823b090 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 823b034:	822d2e00 	call	822d2e0 <dtrap>
      return EINVAL;
 823b038:	00800584 	movi	r2,22
 823b03c:	00001406 	br	823b090 <udp_usrreq+0x228>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 823b040:	e0bfff17 	ldw	r2,-4(fp)
 823b044:	1000021e 	bne	r2,zero,823b050 <udp_usrreq+0x1e8>
         return(EINVAL);
 823b048:	00800584 	movi	r2,22
 823b04c:	00001006 	br	823b090 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b050:	e0bffd17 	ldw	r2,-12(fp)
 823b054:	10800517 	ldw	r2,20(r2)
 823b058:	10800098 	cmpnei	r2,r2,2
 823b05c:	1000051e 	bne	r2,zero,823b074 <udp_usrreq+0x20c>
        return udp4_sockaddr(so, nam, req );
 823b060:	e1bffc17 	ldw	r6,-16(fp)
 823b064:	e17fff17 	ldw	r5,-4(fp)
 823b068:	e13ffd17 	ldw	r4,-12(fp)
 823b06c:	823b6f80 	call	823b6f8 <udp4_sockaddr>
 823b070:	00000706 	br	823b090 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b074:	822d2e00 	call	822d2e0 <dtrap>
      return EINVAL;
 823b078:	00800584 	movi	r2,22
 823b07c:	00000406 	br	823b090 <udp_usrreq+0x228>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 823b080:	822d2e00 	call	822d2e0 <dtrap>
      return 0;
 823b084:	0005883a 	mov	r2,zero
 823b088:	00000106 	br	823b090 <udp_usrreq+0x228>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 823b08c:	008017c4 	movi	r2,95
   }
}
 823b090:	e037883a 	mov	sp,fp
 823b094:	dfc00117 	ldw	ra,4(sp)
 823b098:	df000017 	ldw	fp,0(sp)
 823b09c:	dec00204 	addi	sp,sp,8
 823b0a0:	f800283a 	ret

0823b0a4 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 823b0a4:	defff304 	addi	sp,sp,-52
 823b0a8:	dfc00c15 	stw	ra,48(sp)
 823b0ac:	df000b15 	stw	fp,44(sp)
 823b0b0:	df000b04 	addi	fp,sp,44
 823b0b4:	e13ffd15 	stw	r4,-12(fp)
 823b0b8:	e17ffe15 	stw	r5,-8(fp)
 823b0bc:	e1bfff15 	stw	r6,-4(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 823b0c0:	e0bffe17 	ldw	r2,-8(fp)
 823b0c4:	10800317 	ldw	r2,12(r2)
 823b0c8:	e0bffa15 	stw	r2,-24(fp)
  if (sin == NULL)
 823b0cc:	e0bffa17 	ldw	r2,-24(fp)
 823b0d0:	1000021e 	bne	r2,zero,823b0dc <udp4_sockbind+0x38>
    return(EINVAL);
 823b0d4:	00800584 	movi	r2,22
 823b0d8:	0000a206 	br	823b364 <udp4_sockbind+0x2c0>
  if (nam->m_len != sizeof (*sin))
 823b0dc:	e0bffe17 	ldw	r2,-8(fp)
 823b0e0:	10800217 	ldw	r2,8(r2)
 823b0e4:	10800420 	cmpeqi	r2,r2,16
 823b0e8:	1000021e 	bne	r2,zero,823b0f4 <udp4_sockbind+0x50>
    return(EINVAL);
 823b0ec:	00800584 	movi	r2,22
 823b0f0:	00009c06 	br	823b364 <udp4_sockbind+0x2c0>
  udpconn = udp_lookup(so);
 823b0f4:	e13ffd17 	ldw	r4,-12(fp)
 823b0f8:	823ac6c0 	call	823ac6c <udp_lookup>
 823b0fc:	e0bffb15 	stw	r2,-20(fp)
  if (!udpconn)
 823b100:	e0bffb17 	ldw	r2,-20(fp)
 823b104:	1000021e 	bne	r2,zero,823b110 <udp4_sockbind+0x6c>
     return(EINVAL);
 823b108:	00800584 	movi	r2,22
 823b10c:	00009506 	br	823b364 <udp4_sockbind+0x2c0>
  if (req == PRU_BIND)
 823b110:	e0bfff17 	ldw	r2,-4(fp)
 823b114:	10800098 	cmpnei	r2,r2,2
 823b118:	1000531e 	bne	r2,zero,823b268 <udp4_sockbind+0x1c4>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 823b11c:	e0bffa17 	ldw	r2,-24(fp)
 823b120:	1080008b 	ldhu	r2,2(r2)
 823b124:	10bfffcc 	andi	r2,r2,65535
 823b128:	10000b1e 	bne	r2,zero,823b158 <udp4_sockbind+0xb4>
    {
      if (udpconn->u_lport != 0)
 823b12c:	e0bffb17 	ldw	r2,-20(fp)
 823b130:	1080018b 	ldhu	r2,6(r2)
 823b134:	10bfffcc 	andi	r2,r2,65535
 823b138:	10000426 	beq	r2,zero,823b14c <udp4_sockbind+0xa8>
        lport = udpconn->u_lport;
 823b13c:	e0bffb17 	ldw	r2,-20(fp)
 823b140:	1080018b 	ldhu	r2,6(r2)
 823b144:	e0bff60d 	sth	r2,-40(fp)
 823b148:	00000e06 	br	823b184 <udp4_sockbind+0xe0>
      else
        lport = udp_socket();
 823b14c:	82450840 	call	8245084 <udp_socket>
 823b150:	e0bff60d 	sth	r2,-40(fp)
 823b154:	00000b06 	br	823b184 <udp4_sockbind+0xe0>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 823b158:	e0bffa17 	ldw	r2,-24(fp)
 823b15c:	1080008b 	ldhu	r2,2(r2)
 823b160:	10bfffcc 	andi	r2,r2,65535
 823b164:	1004d23a 	srli	r2,r2,8
 823b168:	1007883a 	mov	r3,r2
 823b16c:	e0bffa17 	ldw	r2,-24(fp)
 823b170:	1080008b 	ldhu	r2,2(r2)
 823b174:	10bfffcc 	andi	r2,r2,65535
 823b178:	1004923a 	slli	r2,r2,8
 823b17c:	1884b03a 	or	r2,r3,r2
 823b180:	e0bff60d 	sth	r2,-40(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b184:	e0bffa17 	ldw	r2,-24(fp)
 823b188:	10800117 	ldw	r2,4(r2)
 823b18c:	1000021e 	bne	r2,zero,823b198 <udp4_sockbind+0xf4>
    {
      lhost = 0L;
 823b190:	e03ff815 	stw	zero,-32(fp)
 823b194:	00001706 	br	823b1f4 <udp4_sockbind+0x150>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 823b198:	e0bffa17 	ldw	r2,-24(fp)
 823b19c:	10800117 	ldw	r2,4(r2)
 823b1a0:	e0bff815 	stw	r2,-32(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b1a4:	008209b4 	movhi	r2,2086
 823b1a8:	10b97b04 	addi	r2,r2,-6676
 823b1ac:	10800017 	ldw	r2,0(r2)
 823b1b0:	e0bff915 	stw	r2,-28(fp)
 823b1b4:	00000706 	br	823b1d4 <udp4_sockbind+0x130>
        if (ifp->n_ipaddr == lhost)
 823b1b8:	e0bff917 	ldw	r2,-28(fp)
 823b1bc:	10c00a17 	ldw	r3,40(r2)
 823b1c0:	e0bff817 	ldw	r2,-32(fp)
 823b1c4:	18800626 	beq	r3,r2,823b1e0 <udp4_sockbind+0x13c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b1c8:	e0bff917 	ldw	r2,-28(fp)
 823b1cc:	10800017 	ldw	r2,0(r2)
 823b1d0:	e0bff915 	stw	r2,-28(fp)
 823b1d4:	e0bff917 	ldw	r2,-28(fp)
 823b1d8:	103ff71e 	bne	r2,zero,823b1b8 <udp4_sockbind+0x114>
 823b1dc:	00000106 	br	823b1e4 <udp4_sockbind+0x140>
        if (ifp->n_ipaddr == lhost)
          break;
 823b1e0:	0001883a 	nop
      if (ifp == NULL)
 823b1e4:	e0bff917 	ldw	r2,-28(fp)
 823b1e8:	1000021e 	bne	r2,zero,823b1f4 <udp4_sockbind+0x150>
        return(EADDRNOTAVAIL);
 823b1ec:	00801f44 	movi	r2,125
 823b1f0:	00005c06 	br	823b364 <udp4_sockbind+0x2c0>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 823b1f4:	e0bffd17 	ldw	r2,-12(fp)
 823b1f8:	10800417 	ldw	r2,16(r2)
 823b1fc:	1080010c 	andi	r2,r2,4
 823b200:	1000121e 	bne	r2,zero,823b24c <udp4_sockbind+0x1a8>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b204:	d0a09c17 	ldw	r2,-32144(gp)
 823b208:	e0bff515 	stw	r2,-44(fp)
 823b20c:	00000d06 	br	823b244 <udp4_sockbind+0x1a0>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 823b210:	e0bff517 	ldw	r2,-44(fp)
 823b214:	1080018b 	ldhu	r2,6(r2)
 823b218:	10ffffcc 	andi	r3,r2,65535
 823b21c:	e0bff60b 	ldhu	r2,-40(fp)
 823b220:	1880051e 	bne	r3,r2,823b238 <udp4_sockbind+0x194>
 823b224:	e0fff517 	ldw	r3,-44(fp)
 823b228:	e0bffb17 	ldw	r2,-20(fp)
 823b22c:	18800226 	beq	r3,r2,823b238 <udp4_sockbind+0x194>
          return(EADDRINUSE);
 823b230:	00801c04 	movi	r2,112
 823b234:	00004b06 	br	823b364 <udp4_sockbind+0x2c0>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b238:	e0bff517 	ldw	r2,-44(fp)
 823b23c:	10800017 	ldw	r2,0(r2)
 823b240:	e0bff515 	stw	r2,-44(fp)
 823b244:	e0bff517 	ldw	r2,-44(fp)
 823b248:	103ff11e 	bne	r2,zero,823b210 <udp4_sockbind+0x16c>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 823b24c:	e0bffb17 	ldw	r2,-20(fp)
 823b250:	e0fff60b 	ldhu	r3,-40(fp)
 823b254:	10c0018d 	sth	r3,6(r2)
    udpconn->u_lhost = lhost;
 823b258:	e0bffb17 	ldw	r2,-20(fp)
 823b25c:	e0fff817 	ldw	r3,-32(fp)
 823b260:	10c00315 	stw	r3,12(r2)
 823b264:	00003e06 	br	823b360 <udp4_sockbind+0x2bc>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 823b268:	e0bffa17 	ldw	r2,-24(fp)
 823b26c:	1080008b 	ldhu	r2,2(r2)
 823b270:	10bfffcc 	andi	r2,r2,65535
 823b274:	1004d23a 	srli	r2,r2,8
 823b278:	1007883a 	mov	r3,r2
 823b27c:	e0bffa17 	ldw	r2,-24(fp)
 823b280:	1080008b 	ldhu	r2,2(r2)
 823b284:	10bfffcc 	andi	r2,r2,65535
 823b288:	1004923a 	slli	r2,r2,8
 823b28c:	1884b03a 	or	r2,r3,r2
 823b290:	e0bffc0d 	sth	r2,-16(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b294:	e0bffa17 	ldw	r2,-24(fp)
 823b298:	10800117 	ldw	r2,4(r2)
 823b29c:	1000021e 	bne	r2,zero,823b2a8 <udp4_sockbind+0x204>
      fhost = 0L;
 823b2a0:	e03ff715 	stw	zero,-36(fp)
 823b2a4:	00000306 	br	823b2b4 <udp4_sockbind+0x210>
    else
      fhost = sin->sin_addr.s_addr;
 823b2a8:	e0bffa17 	ldw	r2,-24(fp)
 823b2ac:	10800117 	ldw	r2,4(r2)
 823b2b0:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 823b2b4:	e13ff717 	ldw	r4,-36(fp)
 823b2b8:	82406e80 	call	82406e8 <ip_mymach>
 823b2bc:	e0bff815 	stw	r2,-32(fp)
    if (lhost == 0)
 823b2c0:	e0bff817 	ldw	r2,-32(fp)
 823b2c4:	1000021e 	bne	r2,zero,823b2d0 <udp4_sockbind+0x22c>
      return(ENETUNREACH);
 823b2c8:	00801c84 	movi	r2,114
 823b2cc:	00002506 	br	823b364 <udp4_sockbind+0x2c0>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 823b2d0:	e0bffb17 	ldw	r2,-20(fp)
 823b2d4:	1080018b 	ldhu	r2,6(r2)
 823b2d8:	e0bff60d 	sth	r2,-40(fp)
    if (lport == 0)
 823b2dc:	e0bff60b 	ldhu	r2,-40(fp)
 823b2e0:	1000021e 	bne	r2,zero,823b2ec <udp4_sockbind+0x248>
      lport = udp_socket();
 823b2e4:	82450840 	call	8245084 <udp_socket>
 823b2e8:	e0bff60d 	sth	r2,-40(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 823b2ec:	e0bffb17 	ldw	r2,-20(fp)
 823b2f0:	e0fff817 	ldw	r3,-32(fp)
 823b2f4:	10c00315 	stw	r3,12(r2)
    udpconn->u_lport = lport;
 823b2f8:	e0bffb17 	ldw	r2,-20(fp)
 823b2fc:	e0fff60b 	ldhu	r3,-40(fp)
 823b300:	10c0018d 	sth	r3,6(r2)
    udpconn->u_fhost = fhost;
 823b304:	e0bffb17 	ldw	r2,-20(fp)
 823b308:	e0fff717 	ldw	r3,-36(fp)
 823b30c:	10c00415 	stw	r3,16(r2)
    udpconn->u_fport = fport;
 823b310:	e0bffb17 	ldw	r2,-20(fp)
 823b314:	e0fffc0b 	ldhu	r3,-16(fp)
 823b318:	10c0020d 	sth	r3,8(r2)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 823b31c:	e0bffd17 	ldw	r2,-12(fp)
 823b320:	10c0088b 	ldhu	r3,34(r2)
 823b324:	00bffcc4 	movi	r2,-13
 823b328:	1884703a 	and	r2,r3,r2
 823b32c:	1007883a 	mov	r3,r2
 823b330:	e0bffd17 	ldw	r2,-12(fp)
 823b334:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 823b338:	e0bffd17 	ldw	r2,-12(fp)
 823b33c:	1080088b 	ldhu	r2,34(r2)
 823b340:	10800094 	ori	r2,r2,2
 823b344:	1007883a 	mov	r3,r2
 823b348:	e0bffd17 	ldw	r2,-12(fp)
 823b34c:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 823b350:	e0bffd17 	ldw	r2,-12(fp)
 823b354:	10800a04 	addi	r2,r2,40
 823b358:	1009883a 	mov	r4,r2
 823b35c:	82346740 	call	8234674 <sbflush>
  }
  return 0;
 823b360:	0005883a 	mov	r2,zero
}
 823b364:	e037883a 	mov	sp,fp
 823b368:	dfc00117 	ldw	ra,4(sp)
 823b36c:	df000017 	ldw	fp,0(sp)
 823b370:	dec00204 	addi	sp,sp,8
 823b374:	f800283a 	ret

0823b378 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 823b378:	defff304 	addi	sp,sp,-52
 823b37c:	dfc00c15 	stw	ra,48(sp)
 823b380:	df000b15 	stw	fp,44(sp)
 823b384:	dc000a15 	stw	r16,40(sp)
 823b388:	df000b04 	addi	fp,sp,44
 823b38c:	e13ffc15 	stw	r4,-16(fp)
 823b390:	e17ffd15 	stw	r5,-12(fp)
 823b394:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 823b398:	e13ffc17 	ldw	r4,-16(fp)
 823b39c:	823ac6c0 	call	823ac6c <udp_lookup>
 823b3a0:	e0bff815 	stw	r2,-32(fp)
  if (!udpconn)
 823b3a4:	e0bff817 	ldw	r2,-32(fp)
 823b3a8:	1000041e 	bne	r2,zero,823b3bc <udp4_socksend+0x44>
  {
    m_free(m);
 823b3ac:	e13ffd17 	ldw	r4,-12(fp)
 823b3b0:	822e27c0 	call	822e27c <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 823b3b4:	00801bc4 	movi	r2,111
 823b3b8:	0000c906 	br	823b6e0 <udp4_socksend+0x368>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 823b3bc:	e0bffe17 	ldw	r2,-8(fp)
 823b3c0:	10000e1e 	bne	r2,zero,823b3fc <udp4_socksend+0x84>
  { 
    if (so->so_state & SS_ISCONNECTED)
 823b3c4:	e0bffc17 	ldw	r2,-16(fp)
 823b3c8:	1080088b 	ldhu	r2,34(r2)
 823b3cc:	10bfffcc 	andi	r2,r2,65535
 823b3d0:	1080008c 	andi	r2,r2,2
 823b3d4:	10000726 	beq	r2,zero,823b3f4 <udp4_socksend+0x7c>
    {
      fport = udpconn->u_fport;
 823b3d8:	e0bff817 	ldw	r2,-32(fp)
 823b3dc:	1080020b 	ldhu	r2,8(r2)
 823b3e0:	e0bff50d 	sth	r2,-44(fp)
      fhost = udpconn->u_fhost;
 823b3e4:	e0bff817 	ldw	r2,-32(fp)
 823b3e8:	10800417 	ldw	r2,16(r2)
 823b3ec:	e0bff615 	stw	r2,-40(fp)
 823b3f0:	00002806 	br	823b494 <udp4_socksend+0x11c>
    }
    else
      return (EINVAL);
 823b3f4:	00800584 	movi	r2,22
 823b3f8:	0000b906 	br	823b6e0 <udp4_socksend+0x368>
  }
  else if(nam->m_len != sizeof (*sin))
 823b3fc:	e0bffe17 	ldw	r2,-8(fp)
 823b400:	10800217 	ldw	r2,8(r2)
 823b404:	10800420 	cmpeqi	r2,r2,16
 823b408:	1000031e 	bne	r2,zero,823b418 <udp4_socksend+0xa0>
  {
    dtrap();
 823b40c:	822d2e00 	call	822d2e0 <dtrap>
    return (EINVAL);
 823b410:	00800584 	movi	r2,22
 823b414:	0000b206 	br	823b6e0 <udp4_socksend+0x368>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 823b418:	e0bffe17 	ldw	r2,-8(fp)
 823b41c:	10800317 	ldw	r2,12(r2)
 823b420:	e0bff915 	stw	r2,-28(fp)
    fhost = sin->sin_addr.s_addr;
 823b424:	e0bff917 	ldw	r2,-28(fp)
 823b428:	10800117 	ldw	r2,4(r2)
 823b42c:	e0bff615 	stw	r2,-40(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 823b430:	e0bff917 	ldw	r2,-28(fp)
 823b434:	1080008b 	ldhu	r2,2(r2)
 823b438:	10bfffcc 	andi	r2,r2,65535
 823b43c:	10000c26 	beq	r2,zero,823b470 <udp4_socksend+0xf8>
      fport = ntohs(sin->sin_port);
 823b440:	e0bff917 	ldw	r2,-28(fp)
 823b444:	1080008b 	ldhu	r2,2(r2)
 823b448:	10bfffcc 	andi	r2,r2,65535
 823b44c:	1004d23a 	srli	r2,r2,8
 823b450:	1007883a 	mov	r3,r2
 823b454:	e0bff917 	ldw	r2,-28(fp)
 823b458:	1080008b 	ldhu	r2,2(r2)
 823b45c:	10bfffcc 	andi	r2,r2,65535
 823b460:	1004923a 	slli	r2,r2,8
 823b464:	1884b03a 	or	r2,r3,r2
 823b468:	e0bff50d 	sth	r2,-44(fp)
 823b46c:	00000906 	br	823b494 <udp4_socksend+0x11c>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 823b470:	e0bff817 	ldw	r2,-32(fp)
 823b474:	1080020b 	ldhu	r2,8(r2)
 823b478:	10bfffcc 	andi	r2,r2,65535
 823b47c:	1000021e 	bne	r2,zero,823b488 <udp4_socksend+0x110>
        return (EINVAL);
 823b480:	00800584 	movi	r2,22
 823b484:	00009606 	br	823b6e0 <udp4_socksend+0x368>
      fport = udpconn->u_fport;
 823b488:	e0bff817 	ldw	r2,-32(fp)
 823b48c:	1080020b 	ldhu	r2,8(r2)
 823b490:	e0bff50d 	sth	r2,-44(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 823b494:	e0bffd17 	ldw	r2,-12(fp)
 823b498:	14000217 	ldw	r16,8(r2)
 823b49c:	82451f00 	call	82451f0 <udp_maxalloc>
 823b4a0:	1400032e 	bgeu	r2,r16,823b4b0 <udp4_socksend+0x138>
  {
    dtrap(); /* should never happen */
 823b4a4:	822d2e00 	call	822d2e0 <dtrap>
    return EMSGSIZE;  /* try to recover */
 823b4a8:	00801e84 	movi	r2,122
 823b4ac:	00008c06 	br	823b6e0 <udp4_socksend+0x368>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 823b4b0:	e0bffd17 	ldw	r2,-12(fp)
 823b4b4:	10800217 	ldw	r2,8(r2)
 823b4b8:	000b883a 	mov	r5,zero
 823b4bc:	1009883a 	mov	r4,r2
 823b4c0:	82451340 	call	8245134 <udp_alloc>
 823b4c4:	e0bffa15 	stw	r2,-24(fp)
  if (!pkt)
 823b4c8:	e0bffa17 	ldw	r2,-24(fp)
 823b4cc:	1000041e 	bne	r2,zero,823b4e0 <udp4_socksend+0x168>
  {
    m_free(m);
 823b4d0:	e13ffd17 	ldw	r4,-12(fp)
 823b4d4:	822e27c0 	call	822e27c <m_free>
    return ENOBUFS;   /* report buffer shortages */
 823b4d8:	00801a44 	movi	r2,105
 823b4dc:	00008006 	br	823b6e0 <udp4_socksend+0x368>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 823b4e0:	e0bffa17 	ldw	r2,-24(fp)
 823b4e4:	10c00317 	ldw	r3,12(r2)
 823b4e8:	e0bffd17 	ldw	r2,-12(fp)
 823b4ec:	11000317 	ldw	r4,12(r2)
 823b4f0:	e0bffd17 	ldw	r2,-12(fp)
 823b4f4:	10800217 	ldw	r2,8(r2)
 823b4f8:	100d883a 	mov	r6,r2
 823b4fc:	200b883a 	mov	r5,r4
 823b500:	1809883a 	mov	r4,r3
 823b504:	8202c5c0 	call	8202c5c <memcpy>
  pkt->nb_plen = m->m_len;
 823b508:	e0bffd17 	ldw	r2,-12(fp)
 823b50c:	10c00217 	ldw	r3,8(r2)
 823b510:	e0bffa17 	ldw	r2,-24(fp)
 823b514:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 823b518:	e13ffd17 	ldw	r4,-12(fp)
 823b51c:	822e27c0 	call	822e27c <m_free>
  pkt->fhost = fhost;
 823b520:	e0bffa17 	ldw	r2,-24(fp)
 823b524:	e0fff617 	ldw	r3,-40(fp)
 823b528:	10c00715 	stw	r3,28(r2)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 823b52c:	e0bff617 	ldw	r2,-40(fp)
 823b530:	10bfffd8 	cmpnei	r2,r2,-1
 823b534:	10004a1e 	bne	r2,zero,823b660 <udp4_socksend+0x2e8>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 823b538:	e0bff817 	ldw	r2,-32(fp)
 823b53c:	10800317 	ldw	r2,12(r2)
 823b540:	10001026 	beq	r2,zero,823b584 <udp4_socksend+0x20c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b544:	008209b4 	movhi	r2,2086
 823b548:	10b97b04 	addi	r2,r2,-6676
 823b54c:	10800017 	ldw	r2,0(r2)
 823b550:	e0bff715 	stw	r2,-36(fp)
 823b554:	00000806 	br	823b578 <udp4_socksend+0x200>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 823b558:	e0bff717 	ldw	r2,-36(fp)
 823b55c:	10c00a17 	ldw	r3,40(r2)
 823b560:	e0bff817 	ldw	r2,-32(fp)
 823b564:	10800317 	ldw	r2,12(r2)
 823b568:	18801d26 	beq	r3,r2,823b5e0 <udp4_socksend+0x268>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b56c:	e0bff717 	ldw	r2,-36(fp)
 823b570:	10800017 	ldw	r2,0(r2)
 823b574:	e0bff715 	stw	r2,-36(fp)
 823b578:	e0bff717 	ldw	r2,-36(fp)
 823b57c:	103ff61e 	bne	r2,zero,823b558 <udp4_socksend+0x1e0>
 823b580:	00001a06 	br	823b5ec <udp4_socksend+0x274>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b584:	008209b4 	movhi	r2,2086
 823b588:	10b97b04 	addi	r2,r2,-6676
 823b58c:	10800017 	ldw	r2,0(r2)
 823b590:	e0bff715 	stw	r2,-36(fp)
 823b594:	00000f06 	br	823b5d4 <udp4_socksend+0x25c>
        if ((ifp->n_flags & NF_BCAST) &&
 823b598:	e0bff717 	ldw	r2,-36(fp)
 823b59c:	10802a17 	ldw	r2,168(r2)
 823b5a0:	1080004c 	andi	r2,r2,1
 823b5a4:	10000826 	beq	r2,zero,823b5c8 <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b5a8:	e0bff717 	ldw	r2,-36(fp)
 823b5ac:	10802717 	ldw	r2,156(r2)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
 823b5b0:	10000526 	beq	r2,zero,823b5c8 <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b5b4:	e0bff717 	ldw	r2,-36(fp)
 823b5b8:	10802717 	ldw	r2,156(r2)
 823b5bc:	10800617 	ldw	r2,24(r2)
 823b5c0:	10800058 	cmpnei	r2,r2,1
 823b5c4:	10000826 	beq	r2,zero,823b5e8 <udp4_socksend+0x270>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b5c8:	e0bff717 	ldw	r2,-36(fp)
 823b5cc:	10800017 	ldw	r2,0(r2)
 823b5d0:	e0bff715 	stw	r2,-36(fp)
 823b5d4:	e0bff717 	ldw	r2,-36(fp)
 823b5d8:	103fef1e 	bne	r2,zero,823b598 <udp4_socksend+0x220>
 823b5dc:	00000306 	br	823b5ec <udp4_socksend+0x274>
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
 823b5e0:	0001883a 	nop
 823b5e4:	00000106 	br	823b5ec <udp4_socksend+0x274>
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
 823b5e8:	0001883a 	nop
    }
    if (ifp == NULL)
 823b5ec:	e0bff717 	ldw	r2,-36(fp)
 823b5f0:	1000181e 	bne	r2,zero,823b654 <udp4_socksend+0x2dc>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b5f4:	008209b4 	movhi	r2,2086
 823b5f8:	10b97b04 	addi	r2,r2,-6676
 823b5fc:	10800017 	ldw	r2,0(r2)
 823b600:	e0bff715 	stw	r2,-36(fp)
 823b604:	00000b06 	br	823b634 <udp4_socksend+0x2bc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b608:	e0bff717 	ldw	r2,-36(fp)
 823b60c:	10802717 	ldw	r2,156(r2)
 823b610:	10000526 	beq	r2,zero,823b628 <udp4_socksend+0x2b0>
 823b614:	e0bff717 	ldw	r2,-36(fp)
 823b618:	10802717 	ldw	r2,156(r2)
 823b61c:	10800617 	ldw	r2,24(r2)
 823b620:	10800058 	cmpnei	r2,r2,1
 823b624:	10000626 	beq	r2,zero,823b640 <udp4_socksend+0x2c8>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b628:	e0bff717 	ldw	r2,-36(fp)
 823b62c:	10800017 	ldw	r2,0(r2)
 823b630:	e0bff715 	stw	r2,-36(fp)
 823b634:	e0bff717 	ldw	r2,-36(fp)
 823b638:	103ff31e 	bne	r2,zero,823b608 <udp4_socksend+0x290>
 823b63c:	00000106 	br	823b644 <udp4_socksend+0x2cc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
 823b640:	0001883a 	nop
      if (ifp == NULL)
 823b644:	e0bff717 	ldw	r2,-36(fp)
 823b648:	1000021e 	bne	r2,zero,823b654 <udp4_socksend+0x2dc>
        return(EADDRNOTAVAIL);
 823b64c:	00801f44 	movi	r2,125
 823b650:	00002306 	br	823b6e0 <udp4_socksend+0x368>
    }
    pkt->net = ifp;
 823b654:	e0bffa17 	ldw	r2,-24(fp)
 823b658:	e0fff717 	ldw	r3,-36(fp)
 823b65c:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 823b660:	e0bffc17 	ldw	r2,-16(fp)
 823b664:	10800317 	ldw	r2,12(r2)
 823b668:	10000426 	beq	r2,zero,823b67c <udp4_socksend+0x304>
     pkt->imo = so->inp_moptions;
 823b66c:	e0bffc17 	ldw	r2,-16(fp)
 823b670:	10c00317 	ldw	r3,12(r2)
 823b674:	e0bffa17 	ldw	r2,-24(fp)
 823b678:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 823b67c:	e0bffc17 	ldw	r2,-16(fp)
 823b680:	10801f17 	ldw	r2,124(r2)
 823b684:	10000426 	beq	r2,zero,823b698 <udp4_socksend+0x320>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 823b688:	e0bffc17 	ldw	r2,-16(fp)
 823b68c:	10c01f17 	ldw	r3,124(r2)
 823b690:	e0bffa17 	ldw	r2,-24(fp)
 823b694:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 823b698:	0009883a 	mov	r4,zero
 823b69c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 823b6a0:	e0fff50b 	ldhu	r3,-44(fp)
 823b6a4:	e0bff817 	ldw	r2,-32(fp)
 823b6a8:	1080018b 	ldhu	r2,6(r2)
 823b6ac:	10bfffcc 	andi	r2,r2,65535
 823b6b0:	e1bffa17 	ldw	r6,-24(fp)
 823b6b4:	100b883a 	mov	r5,r2
 823b6b8:	1809883a 	mov	r4,r3
 823b6bc:	8244cf80 	call	8244cf8 <udp_send>
 823b6c0:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 823b6c4:	0009883a 	mov	r4,zero
 823b6c8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
  if (e < 0) 
 823b6cc:	e0bffb17 	ldw	r2,-20(fp)
 823b6d0:	1000020e 	bge	r2,zero,823b6dc <udp4_socksend+0x364>
     return(e);
 823b6d4:	e0bffb17 	ldw	r2,-20(fp)
 823b6d8:	00000106 	br	823b6e0 <udp4_socksend+0x368>
  return 0;
 823b6dc:	0005883a 	mov	r2,zero
}
 823b6e0:	e6ffff04 	addi	sp,fp,-4
 823b6e4:	dfc00217 	ldw	ra,8(sp)
 823b6e8:	df000117 	ldw	fp,4(sp)
 823b6ec:	dc000017 	ldw	r16,0(sp)
 823b6f0:	dec00304 	addi	sp,sp,12
 823b6f4:	f800283a 	ret

0823b6f8 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 823b6f8:	defff904 	addi	sp,sp,-28
 823b6fc:	dfc00615 	stw	ra,24(sp)
 823b700:	df000515 	stw	fp,20(sp)
 823b704:	df000504 	addi	fp,sp,20
 823b708:	e13ffd15 	stw	r4,-12(fp)
 823b70c:	e17ffe15 	stw	r5,-8(fp)
 823b710:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 823b714:	e0bffe17 	ldw	r2,-8(fp)
 823b718:	10800317 	ldw	r2,12(r2)
 823b71c:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 823b720:	e0bffb17 	ldw	r2,-20(fp)
 823b724:	1000021e 	bne	r2,zero,823b730 <udp4_sockaddr+0x38>
     return(EINVAL);
 823b728:	00800584 	movi	r2,22
 823b72c:	00003706 	br	823b80c <udp4_sockaddr+0x114>
  udpconn = udp_lookup(so);
 823b730:	e13ffd17 	ldw	r4,-12(fp)
 823b734:	823ac6c0 	call	823ac6c <udp_lookup>
 823b738:	e0bffc15 	stw	r2,-16(fp)
  if (!udpconn)
 823b73c:	e0bffc17 	ldw	r2,-16(fp)
 823b740:	1000021e 	bne	r2,zero,823b74c <udp4_sockaddr+0x54>
     return(EINVAL);
 823b744:	00800584 	movi	r2,22
 823b748:	00003006 	br	823b80c <udp4_sockaddr+0x114>
  nam->m_len = sizeof(*sin);
 823b74c:	e0bffe17 	ldw	r2,-8(fp)
 823b750:	00c00404 	movi	r3,16
 823b754:	10c00215 	stw	r3,8(r2)
  if (req == PRU_SOCKADDR)
 823b758:	e0bfff17 	ldw	r2,-4(fp)
 823b75c:	108003d8 	cmpnei	r2,r2,15
 823b760:	1000151e 	bne	r2,zero,823b7b8 <udp4_sockaddr+0xc0>
  {
     sin->sin_family = AF_INET;
 823b764:	e0bffb17 	ldw	r2,-20(fp)
 823b768:	00c00084 	movi	r3,2
 823b76c:	10c0000d 	sth	r3,0(r2)
     sin->sin_port = htons(udpconn->u_lport);
 823b770:	e0bffc17 	ldw	r2,-16(fp)
 823b774:	1080018b 	ldhu	r2,6(r2)
 823b778:	10bfffcc 	andi	r2,r2,65535
 823b77c:	1004d23a 	srli	r2,r2,8
 823b780:	1007883a 	mov	r3,r2
 823b784:	e0bffc17 	ldw	r2,-16(fp)
 823b788:	1080018b 	ldhu	r2,6(r2)
 823b78c:	10bfffcc 	andi	r2,r2,65535
 823b790:	1004923a 	slli	r2,r2,8
 823b794:	1884b03a 	or	r2,r3,r2
 823b798:	1007883a 	mov	r3,r2
 823b79c:	e0bffb17 	ldw	r2,-20(fp)
 823b7a0:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 823b7a4:	e0bffc17 	ldw	r2,-16(fp)
 823b7a8:	10c00317 	ldw	r3,12(r2)
 823b7ac:	e0bffb17 	ldw	r2,-20(fp)
 823b7b0:	10c00115 	stw	r3,4(r2)
 823b7b4:	00001406 	br	823b808 <udp4_sockaddr+0x110>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 823b7b8:	e0bffb17 	ldw	r2,-20(fp)
 823b7bc:	00c00084 	movi	r3,2
 823b7c0:	10c0000d 	sth	r3,0(r2)
    sin->sin_port = htons(udpconn->u_fport);
 823b7c4:	e0bffc17 	ldw	r2,-16(fp)
 823b7c8:	1080020b 	ldhu	r2,8(r2)
 823b7cc:	10bfffcc 	andi	r2,r2,65535
 823b7d0:	1004d23a 	srli	r2,r2,8
 823b7d4:	1007883a 	mov	r3,r2
 823b7d8:	e0bffc17 	ldw	r2,-16(fp)
 823b7dc:	1080020b 	ldhu	r2,8(r2)
 823b7e0:	10bfffcc 	andi	r2,r2,65535
 823b7e4:	1004923a 	slli	r2,r2,8
 823b7e8:	1884b03a 	or	r2,r3,r2
 823b7ec:	1007883a 	mov	r3,r2
 823b7f0:	e0bffb17 	ldw	r2,-20(fp)
 823b7f4:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 823b7f8:	e0bffc17 	ldw	r2,-16(fp)
 823b7fc:	10c00417 	ldw	r3,16(r2)
 823b800:	e0bffb17 	ldw	r2,-20(fp)
 823b804:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 823b808:	0005883a 	mov	r2,zero
}
 823b80c:	e037883a 	mov	sp,fp
 823b810:	dfc00117 	ldw	ra,4(sp)
 823b814:	df000017 	ldw	fp,0(sp)
 823b818:	dec00204 	addi	sp,sp,8
 823b81c:	f800283a 	ret

0823b820 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 823b820:	defff504 	addi	sp,sp,-44
 823b824:	df000a15 	stw	fp,40(sp)
 823b828:	df000a04 	addi	fp,sp,40
 823b82c:	e13ffc15 	stw	r4,-16(fp)
 823b830:	e17ffd15 	stw	r5,-12(fp)
 823b834:	e1bffe15 	stw	r6,-8(fp)
 823b838:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 823b83c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823b840:	d0a0b817 	ldw	r2,-32032(gp)
  
  if (alt_ticks_per_second ())
 823b844:	10003c26 	beq	r2,zero,823b938 <alt_alarm_start+0x118>
  {
    if (alarm)
 823b848:	e0bffc17 	ldw	r2,-16(fp)
 823b84c:	10003826 	beq	r2,zero,823b930 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 823b850:	e0bffc17 	ldw	r2,-16(fp)
 823b854:	e0fffe17 	ldw	r3,-8(fp)
 823b858:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 823b85c:	e0bffc17 	ldw	r2,-16(fp)
 823b860:	e0ffff17 	ldw	r3,-4(fp)
 823b864:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823b868:	0005303a 	rdctl	r2,status
 823b86c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823b870:	e0fff917 	ldw	r3,-28(fp)
 823b874:	00bfff84 	movi	r2,-2
 823b878:	1884703a 	and	r2,r3,r2
 823b87c:	1001703a 	wrctl	status,r2
  
  return context;
 823b880:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 823b884:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 823b888:	d0a0b917 	ldw	r2,-32028(gp)
      
      current_nticks = alt_nticks();
 823b88c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 823b890:	e0fffd17 	ldw	r3,-12(fp)
 823b894:	e0bff617 	ldw	r2,-40(fp)
 823b898:	1885883a 	add	r2,r3,r2
 823b89c:	10c00044 	addi	r3,r2,1
 823b8a0:	e0bffc17 	ldw	r2,-16(fp)
 823b8a4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 823b8a8:	e0bffc17 	ldw	r2,-16(fp)
 823b8ac:	10c00217 	ldw	r3,8(r2)
 823b8b0:	e0bff617 	ldw	r2,-40(fp)
 823b8b4:	1880042e 	bgeu	r3,r2,823b8c8 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 823b8b8:	e0bffc17 	ldw	r2,-16(fp)
 823b8bc:	00c00044 	movi	r3,1
 823b8c0:	10c00405 	stb	r3,16(r2)
 823b8c4:	00000206 	br	823b8d0 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 823b8c8:	e0bffc17 	ldw	r2,-16(fp)
 823b8cc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 823b8d0:	e0bffc17 	ldw	r2,-16(fp)
 823b8d4:	d0e04904 	addi	r3,gp,-32476
 823b8d8:	e0fffa15 	stw	r3,-24(fp)
 823b8dc:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823b8e0:	e0bffb17 	ldw	r2,-20(fp)
 823b8e4:	e0fffa17 	ldw	r3,-24(fp)
 823b8e8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823b8ec:	e0bffa17 	ldw	r2,-24(fp)
 823b8f0:	10c00017 	ldw	r3,0(r2)
 823b8f4:	e0bffb17 	ldw	r2,-20(fp)
 823b8f8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823b8fc:	e0bffa17 	ldw	r2,-24(fp)
 823b900:	10800017 	ldw	r2,0(r2)
 823b904:	e0fffb17 	ldw	r3,-20(fp)
 823b908:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823b90c:	e0bffa17 	ldw	r2,-24(fp)
 823b910:	e0fffb17 	ldw	r3,-20(fp)
 823b914:	10c00015 	stw	r3,0(r2)
 823b918:	e0bff817 	ldw	r2,-32(fp)
 823b91c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823b920:	e0bff717 	ldw	r2,-36(fp)
 823b924:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 823b928:	0005883a 	mov	r2,zero
 823b92c:	00000306 	br	823b93c <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 823b930:	00bffa84 	movi	r2,-22
 823b934:	00000106 	br	823b93c <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 823b938:	00bfde84 	movi	r2,-134
  }
}
 823b93c:	e037883a 	mov	sp,fp
 823b940:	df000017 	ldw	fp,0(sp)
 823b944:	dec00104 	addi	sp,sp,4
 823b948:	f800283a 	ret

0823b94c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823b94c:	defffe04 	addi	sp,sp,-8
 823b950:	dfc00115 	stw	ra,4(sp)
 823b954:	df000015 	stw	fp,0(sp)
 823b958:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823b95c:	d0a04717 	ldw	r2,-32484(gp)
 823b960:	10000326 	beq	r2,zero,823b970 <alt_get_errno+0x24>
 823b964:	d0a04717 	ldw	r2,-32484(gp)
 823b968:	103ee83a 	callr	r2
 823b96c:	00000106 	br	823b974 <alt_get_errno+0x28>
 823b970:	d0a06304 	addi	r2,gp,-32372
}
 823b974:	e037883a 	mov	sp,fp
 823b978:	dfc00117 	ldw	ra,4(sp)
 823b97c:	df000017 	ldw	fp,0(sp)
 823b980:	dec00204 	addi	sp,sp,8
 823b984:	f800283a 	ret

0823b988 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 823b988:	defffb04 	addi	sp,sp,-20
 823b98c:	dfc00415 	stw	ra,16(sp)
 823b990:	df000315 	stw	fp,12(sp)
 823b994:	df000304 	addi	fp,sp,12
 823b998:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 823b99c:	e0bfff17 	ldw	r2,-4(fp)
 823b9a0:	10000616 	blt	r2,zero,823b9bc <alt_close+0x34>
 823b9a4:	e0bfff17 	ldw	r2,-4(fp)
 823b9a8:	10c00324 	muli	r3,r2,12
 823b9ac:	00820974 	movhi	r2,2085
 823b9b0:	108df204 	addi	r2,r2,14280
 823b9b4:	1885883a 	add	r2,r3,r2
 823b9b8:	00000106 	br	823b9c0 <alt_close+0x38>
 823b9bc:	0005883a 	mov	r2,zero
 823b9c0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 823b9c4:	e0bffd17 	ldw	r2,-12(fp)
 823b9c8:	10001926 	beq	r2,zero,823ba30 <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 823b9cc:	e0bffd17 	ldw	r2,-12(fp)
 823b9d0:	10800017 	ldw	r2,0(r2)
 823b9d4:	10800417 	ldw	r2,16(r2)
 823b9d8:	10000626 	beq	r2,zero,823b9f4 <alt_close+0x6c>
 823b9dc:	e0bffd17 	ldw	r2,-12(fp)
 823b9e0:	10800017 	ldw	r2,0(r2)
 823b9e4:	10800417 	ldw	r2,16(r2)
 823b9e8:	e13ffd17 	ldw	r4,-12(fp)
 823b9ec:	103ee83a 	callr	r2
 823b9f0:	00000106 	br	823b9f8 <alt_close+0x70>
 823b9f4:	0005883a 	mov	r2,zero
 823b9f8:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 823b9fc:	e13fff17 	ldw	r4,-4(fp)
 823ba00:	823c4980 	call	823c498 <alt_release_fd>
    if (rval < 0)
 823ba04:	e0bffe17 	ldw	r2,-8(fp)
 823ba08:	1000070e 	bge	r2,zero,823ba28 <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 823ba0c:	823b94c0 	call	823b94c <alt_get_errno>
 823ba10:	1007883a 	mov	r3,r2
 823ba14:	e0bffe17 	ldw	r2,-8(fp)
 823ba18:	0085c83a 	sub	r2,zero,r2
 823ba1c:	18800015 	stw	r2,0(r3)
      return -1;
 823ba20:	00bfffc4 	movi	r2,-1
 823ba24:	00000706 	br	823ba44 <alt_close+0xbc>
    }
    return 0;
 823ba28:	0005883a 	mov	r2,zero
 823ba2c:	00000506 	br	823ba44 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 823ba30:	823b94c0 	call	823b94c <alt_get_errno>
 823ba34:	1007883a 	mov	r3,r2
 823ba38:	00801444 	movi	r2,81
 823ba3c:	18800015 	stw	r2,0(r3)
    return -1;
 823ba40:	00bfffc4 	movi	r2,-1
  }
}
 823ba44:	e037883a 	mov	sp,fp
 823ba48:	dfc00117 	ldw	ra,4(sp)
 823ba4c:	df000017 	ldw	fp,0(sp)
 823ba50:	dec00204 	addi	sp,sp,8
 823ba54:	f800283a 	ret

0823ba58 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 823ba58:	defffb04 	addi	sp,sp,-20
 823ba5c:	df000415 	stw	fp,16(sp)
 823ba60:	df000404 	addi	fp,sp,16
 823ba64:	e13ffe15 	stw	r4,-8(fp)
 823ba68:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 823ba6c:	e0fffe17 	ldw	r3,-8(fp)
 823ba70:	e0bfff17 	ldw	r2,-4(fp)
 823ba74:	1885883a 	add	r2,r3,r2
 823ba78:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823ba7c:	e0bffe17 	ldw	r2,-8(fp)
 823ba80:	e0bffc15 	stw	r2,-16(fp)
 823ba84:	00000506 	br	823ba9c <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 823ba88:	e0bffc17 	ldw	r2,-16(fp)
 823ba8c:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823ba90:	e0bffc17 	ldw	r2,-16(fp)
 823ba94:	10800804 	addi	r2,r2,32
 823ba98:	e0bffc15 	stw	r2,-16(fp)
 823ba9c:	e0fffc17 	ldw	r3,-16(fp)
 823baa0:	e0bffd17 	ldw	r2,-12(fp)
 823baa4:	18bff836 	bltu	r3,r2,823ba88 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 823baa8:	e0bffe17 	ldw	r2,-8(fp)
 823baac:	108007cc 	andi	r2,r2,31
 823bab0:	10000226 	beq	r2,zero,823babc <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 823bab4:	e0bffc17 	ldw	r2,-16(fp)
 823bab8:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 823babc:	0001883a 	nop
 823bac0:	e037883a 	mov	sp,fp
 823bac4:	df000017 	ldw	fp,0(sp)
 823bac8:	dec00104 	addi	sp,sp,4
 823bacc:	f800283a 	ret

0823bad0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 823bad0:	defffc04 	addi	sp,sp,-16
 823bad4:	df000315 	stw	fp,12(sp)
 823bad8:	df000304 	addi	fp,sp,12
 823badc:	e13ffd15 	stw	r4,-12(fp)
 823bae0:	e17ffe15 	stw	r5,-8(fp)
 823bae4:	e1bfff15 	stw	r6,-4(fp)
  return len;
 823bae8:	e0bfff17 	ldw	r2,-4(fp)
}
 823baec:	e037883a 	mov	sp,fp
 823baf0:	df000017 	ldw	fp,0(sp)
 823baf4:	dec00104 	addi	sp,sp,4
 823baf8:	f800283a 	ret

0823bafc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823bafc:	defffe04 	addi	sp,sp,-8
 823bb00:	dfc00115 	stw	ra,4(sp)
 823bb04:	df000015 	stw	fp,0(sp)
 823bb08:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823bb0c:	d0a04717 	ldw	r2,-32484(gp)
 823bb10:	10000326 	beq	r2,zero,823bb20 <alt_get_errno+0x24>
 823bb14:	d0a04717 	ldw	r2,-32484(gp)
 823bb18:	103ee83a 	callr	r2
 823bb1c:	00000106 	br	823bb24 <alt_get_errno+0x28>
 823bb20:	d0a06304 	addi	r2,gp,-32372
}
 823bb24:	e037883a 	mov	sp,fp
 823bb28:	dfc00117 	ldw	ra,4(sp)
 823bb2c:	df000017 	ldw	fp,0(sp)
 823bb30:	dec00204 	addi	sp,sp,8
 823bb34:	f800283a 	ret

0823bb38 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 823bb38:	defffa04 	addi	sp,sp,-24
 823bb3c:	dfc00515 	stw	ra,20(sp)
 823bb40:	df000415 	stw	fp,16(sp)
 823bb44:	df000404 	addi	fp,sp,16
 823bb48:	e13ffe15 	stw	r4,-8(fp)
 823bb4c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 823bb50:	e0bffe17 	ldw	r2,-8(fp)
 823bb54:	10000326 	beq	r2,zero,823bb64 <alt_dev_llist_insert+0x2c>
 823bb58:	e0bffe17 	ldw	r2,-8(fp)
 823bb5c:	10800217 	ldw	r2,8(r2)
 823bb60:	1000061e 	bne	r2,zero,823bb7c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 823bb64:	823bafc0 	call	823bafc <alt_get_errno>
 823bb68:	1007883a 	mov	r3,r2
 823bb6c:	00800584 	movi	r2,22
 823bb70:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 823bb74:	00bffa84 	movi	r2,-22
 823bb78:	00001306 	br	823bbc8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 823bb7c:	e0bffe17 	ldw	r2,-8(fp)
 823bb80:	e0ffff17 	ldw	r3,-4(fp)
 823bb84:	e0fffc15 	stw	r3,-16(fp)
 823bb88:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823bb8c:	e0bffd17 	ldw	r2,-12(fp)
 823bb90:	e0fffc17 	ldw	r3,-16(fp)
 823bb94:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823bb98:	e0bffc17 	ldw	r2,-16(fp)
 823bb9c:	10c00017 	ldw	r3,0(r2)
 823bba0:	e0bffd17 	ldw	r2,-12(fp)
 823bba4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823bba8:	e0bffc17 	ldw	r2,-16(fp)
 823bbac:	10800017 	ldw	r2,0(r2)
 823bbb0:	e0fffd17 	ldw	r3,-12(fp)
 823bbb4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823bbb8:	e0bffc17 	ldw	r2,-16(fp)
 823bbbc:	e0fffd17 	ldw	r3,-12(fp)
 823bbc0:	10c00015 	stw	r3,0(r2)

  return 0;  
 823bbc4:	0005883a 	mov	r2,zero
}
 823bbc8:	e037883a 	mov	sp,fp
 823bbcc:	dfc00117 	ldw	ra,4(sp)
 823bbd0:	df000017 	ldw	fp,0(sp)
 823bbd4:	dec00204 	addi	sp,sp,8
 823bbd8:	f800283a 	ret

0823bbdc <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 823bbdc:	defffd04 	addi	sp,sp,-12
 823bbe0:	dfc00215 	stw	ra,8(sp)
 823bbe4:	df000115 	stw	fp,4(sp)
 823bbe8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bbec:	00820974 	movhi	r2,2085
 823bbf0:	10af0704 	addi	r2,r2,-17380
 823bbf4:	e0bfff15 	stw	r2,-4(fp)
 823bbf8:	00000606 	br	823bc14 <_do_ctors+0x38>
        (*ctor) (); 
 823bbfc:	e0bfff17 	ldw	r2,-4(fp)
 823bc00:	10800017 	ldw	r2,0(r2)
 823bc04:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bc08:	e0bfff17 	ldw	r2,-4(fp)
 823bc0c:	10bfff04 	addi	r2,r2,-4
 823bc10:	e0bfff15 	stw	r2,-4(fp)
 823bc14:	e0ffff17 	ldw	r3,-4(fp)
 823bc18:	00820974 	movhi	r2,2085
 823bc1c:	10af0804 	addi	r2,r2,-17376
 823bc20:	18bff62e 	bgeu	r3,r2,823bbfc <_do_ctors+0x20>
        (*ctor) (); 
}
 823bc24:	0001883a 	nop
 823bc28:	e037883a 	mov	sp,fp
 823bc2c:	dfc00117 	ldw	ra,4(sp)
 823bc30:	df000017 	ldw	fp,0(sp)
 823bc34:	dec00204 	addi	sp,sp,8
 823bc38:	f800283a 	ret

0823bc3c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 823bc3c:	defffd04 	addi	sp,sp,-12
 823bc40:	dfc00215 	stw	ra,8(sp)
 823bc44:	df000115 	stw	fp,4(sp)
 823bc48:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bc4c:	00820974 	movhi	r2,2085
 823bc50:	10af0704 	addi	r2,r2,-17380
 823bc54:	e0bfff15 	stw	r2,-4(fp)
 823bc58:	00000606 	br	823bc74 <_do_dtors+0x38>
        (*dtor) (); 
 823bc5c:	e0bfff17 	ldw	r2,-4(fp)
 823bc60:	10800017 	ldw	r2,0(r2)
 823bc64:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bc68:	e0bfff17 	ldw	r2,-4(fp)
 823bc6c:	10bfff04 	addi	r2,r2,-4
 823bc70:	e0bfff15 	stw	r2,-4(fp)
 823bc74:	e0ffff17 	ldw	r3,-4(fp)
 823bc78:	00820974 	movhi	r2,2085
 823bc7c:	10af0804 	addi	r2,r2,-17376
 823bc80:	18bff62e 	bgeu	r3,r2,823bc5c <_do_dtors+0x20>
        (*dtor) (); 
}
 823bc84:	0001883a 	nop
 823bc88:	e037883a 	mov	sp,fp
 823bc8c:	dfc00117 	ldw	ra,4(sp)
 823bc90:	df000017 	ldw	fp,0(sp)
 823bc94:	dec00204 	addi	sp,sp,8
 823bc98:	f800283a 	ret

0823bc9c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 823bc9c:	defffa04 	addi	sp,sp,-24
 823bca0:	dfc00515 	stw	ra,20(sp)
 823bca4:	df000415 	stw	fp,16(sp)
 823bca8:	df000404 	addi	fp,sp,16
 823bcac:	e13ffe15 	stw	r4,-8(fp)
 823bcb0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 823bcb4:	e0bfff17 	ldw	r2,-4(fp)
 823bcb8:	10800017 	ldw	r2,0(r2)
 823bcbc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 823bcc0:	e13ffe17 	ldw	r4,-8(fp)
 823bcc4:	8203cac0 	call	8203cac <strlen>
 823bcc8:	10800044 	addi	r2,r2,1
 823bccc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bcd0:	00000d06 	br	823bd08 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 823bcd4:	e0bffc17 	ldw	r2,-16(fp)
 823bcd8:	10800217 	ldw	r2,8(r2)
 823bcdc:	e0fffd17 	ldw	r3,-12(fp)
 823bce0:	180d883a 	mov	r6,r3
 823bce4:	e17ffe17 	ldw	r5,-8(fp)
 823bce8:	1009883a 	mov	r4,r2
 823bcec:	820c3280 	call	820c328 <memcmp>
 823bcf0:	1000021e 	bne	r2,zero,823bcfc <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 823bcf4:	e0bffc17 	ldw	r2,-16(fp)
 823bcf8:	00000706 	br	823bd18 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 823bcfc:	e0bffc17 	ldw	r2,-16(fp)
 823bd00:	10800017 	ldw	r2,0(r2)
 823bd04:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bd08:	e0fffc17 	ldw	r3,-16(fp)
 823bd0c:	e0bfff17 	ldw	r2,-4(fp)
 823bd10:	18bff01e 	bne	r3,r2,823bcd4 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 823bd14:	0005883a 	mov	r2,zero
}
 823bd18:	e037883a 	mov	sp,fp
 823bd1c:	dfc00117 	ldw	ra,4(sp)
 823bd20:	df000017 	ldw	fp,0(sp)
 823bd24:	dec00204 	addi	sp,sp,8
 823bd28:	f800283a 	ret

0823bd2c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823bd2c:	defff904 	addi	sp,sp,-28
 823bd30:	dfc00615 	stw	ra,24(sp)
 823bd34:	df000515 	stw	fp,20(sp)
 823bd38:	df000504 	addi	fp,sp,20
 823bd3c:	e13ffc15 	stw	r4,-16(fp)
 823bd40:	e17ffd15 	stw	r5,-12(fp)
 823bd44:	e1bffe15 	stw	r6,-8(fp)
 823bd48:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 823bd4c:	e0800217 	ldw	r2,8(fp)
 823bd50:	d8800015 	stw	r2,0(sp)
 823bd54:	e1ffff17 	ldw	r7,-4(fp)
 823bd58:	e1bffe17 	ldw	r6,-8(fp)
 823bd5c:	e17ffd17 	ldw	r5,-12(fp)
 823bd60:	e13ffc17 	ldw	r4,-16(fp)
 823bd64:	823bedc0 	call	823bedc <alt_iic_isr_register>
}  
 823bd68:	e037883a 	mov	sp,fp
 823bd6c:	dfc00117 	ldw	ra,4(sp)
 823bd70:	df000017 	ldw	fp,0(sp)
 823bd74:	dec00204 	addi	sp,sp,8
 823bd78:	f800283a 	ret

0823bd7c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 823bd7c:	defff904 	addi	sp,sp,-28
 823bd80:	df000615 	stw	fp,24(sp)
 823bd84:	df000604 	addi	fp,sp,24
 823bd88:	e13ffe15 	stw	r4,-8(fp)
 823bd8c:	e17fff15 	stw	r5,-4(fp)
 823bd90:	e0bfff17 	ldw	r2,-4(fp)
 823bd94:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bd98:	0005303a 	rdctl	r2,status
 823bd9c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bda0:	e0fffb17 	ldw	r3,-20(fp)
 823bda4:	00bfff84 	movi	r2,-2
 823bda8:	1884703a 	and	r2,r3,r2
 823bdac:	1001703a 	wrctl	status,r2
  
  return context;
 823bdb0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823bdb4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 823bdb8:	00c00044 	movi	r3,1
 823bdbc:	e0bffa17 	ldw	r2,-24(fp)
 823bdc0:	1884983a 	sll	r2,r3,r2
 823bdc4:	1007883a 	mov	r3,r2
 823bdc8:	d0a0b717 	ldw	r2,-32036(gp)
 823bdcc:	1884b03a 	or	r2,r3,r2
 823bdd0:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823bdd4:	d0a0b717 	ldw	r2,-32036(gp)
 823bdd8:	100170fa 	wrctl	ienable,r2
 823bddc:	e0bffc17 	ldw	r2,-16(fp)
 823bde0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bde4:	e0bffd17 	ldw	r2,-12(fp)
 823bde8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823bdec:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 823bdf0:	0001883a 	nop
}
 823bdf4:	e037883a 	mov	sp,fp
 823bdf8:	df000017 	ldw	fp,0(sp)
 823bdfc:	dec00104 	addi	sp,sp,4
 823be00:	f800283a 	ret

0823be04 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 823be04:	defff904 	addi	sp,sp,-28
 823be08:	df000615 	stw	fp,24(sp)
 823be0c:	df000604 	addi	fp,sp,24
 823be10:	e13ffe15 	stw	r4,-8(fp)
 823be14:	e17fff15 	stw	r5,-4(fp)
 823be18:	e0bfff17 	ldw	r2,-4(fp)
 823be1c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823be20:	0005303a 	rdctl	r2,status
 823be24:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823be28:	e0fffb17 	ldw	r3,-20(fp)
 823be2c:	00bfff84 	movi	r2,-2
 823be30:	1884703a 	and	r2,r3,r2
 823be34:	1001703a 	wrctl	status,r2
  
  return context;
 823be38:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823be3c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 823be40:	00c00044 	movi	r3,1
 823be44:	e0bffa17 	ldw	r2,-24(fp)
 823be48:	1884983a 	sll	r2,r3,r2
 823be4c:	0084303a 	nor	r2,zero,r2
 823be50:	1007883a 	mov	r3,r2
 823be54:	d0a0b717 	ldw	r2,-32036(gp)
 823be58:	1884703a 	and	r2,r3,r2
 823be5c:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823be60:	d0a0b717 	ldw	r2,-32036(gp)
 823be64:	100170fa 	wrctl	ienable,r2
 823be68:	e0bffc17 	ldw	r2,-16(fp)
 823be6c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823be70:	e0bffd17 	ldw	r2,-12(fp)
 823be74:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823be78:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 823be7c:	0001883a 	nop
}
 823be80:	e037883a 	mov	sp,fp
 823be84:	df000017 	ldw	fp,0(sp)
 823be88:	dec00104 	addi	sp,sp,4
 823be8c:	f800283a 	ret

0823be90 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 823be90:	defffc04 	addi	sp,sp,-16
 823be94:	df000315 	stw	fp,12(sp)
 823be98:	df000304 	addi	fp,sp,12
 823be9c:	e13ffe15 	stw	r4,-8(fp)
 823bea0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 823bea4:	000530fa 	rdctl	r2,ienable
 823bea8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 823beac:	00c00044 	movi	r3,1
 823beb0:	e0bfff17 	ldw	r2,-4(fp)
 823beb4:	1884983a 	sll	r2,r3,r2
 823beb8:	1007883a 	mov	r3,r2
 823bebc:	e0bffd17 	ldw	r2,-12(fp)
 823bec0:	1884703a 	and	r2,r3,r2
 823bec4:	1004c03a 	cmpne	r2,r2,zero
 823bec8:	10803fcc 	andi	r2,r2,255
}
 823becc:	e037883a 	mov	sp,fp
 823bed0:	df000017 	ldw	fp,0(sp)
 823bed4:	dec00104 	addi	sp,sp,4
 823bed8:	f800283a 	ret

0823bedc <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823bedc:	defff504 	addi	sp,sp,-44
 823bee0:	dfc00a15 	stw	ra,40(sp)
 823bee4:	df000915 	stw	fp,36(sp)
 823bee8:	df000904 	addi	fp,sp,36
 823beec:	e13ffc15 	stw	r4,-16(fp)
 823bef0:	e17ffd15 	stw	r5,-12(fp)
 823bef4:	e1bffe15 	stw	r6,-8(fp)
 823bef8:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 823befc:	00bffa84 	movi	r2,-22
 823bf00:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 823bf04:	e0bffd17 	ldw	r2,-12(fp)
 823bf08:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 823bf0c:	e0bff817 	ldw	r2,-32(fp)
 823bf10:	10800808 	cmpgei	r2,r2,32
 823bf14:	1000271e 	bne	r2,zero,823bfb4 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bf18:	0005303a 	rdctl	r2,status
 823bf1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bf20:	e0fffb17 	ldw	r3,-20(fp)
 823bf24:	00bfff84 	movi	r2,-2
 823bf28:	1884703a 	and	r2,r3,r2
 823bf2c:	1001703a 	wrctl	status,r2
  
  return context;
 823bf30:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 823bf34:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 823bf38:	008209b4 	movhi	r2,2086
 823bf3c:	10b8e204 	addi	r2,r2,-7288
 823bf40:	e0fff817 	ldw	r3,-32(fp)
 823bf44:	180690fa 	slli	r3,r3,3
 823bf48:	10c5883a 	add	r2,r2,r3
 823bf4c:	e0fffe17 	ldw	r3,-8(fp)
 823bf50:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 823bf54:	008209b4 	movhi	r2,2086
 823bf58:	10b8e204 	addi	r2,r2,-7288
 823bf5c:	e0fff817 	ldw	r3,-32(fp)
 823bf60:	180690fa 	slli	r3,r3,3
 823bf64:	10c5883a 	add	r2,r2,r3
 823bf68:	10800104 	addi	r2,r2,4
 823bf6c:	e0ffff17 	ldw	r3,-4(fp)
 823bf70:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 823bf74:	e0bffe17 	ldw	r2,-8(fp)
 823bf78:	10000526 	beq	r2,zero,823bf90 <alt_iic_isr_register+0xb4>
 823bf7c:	e0bff817 	ldw	r2,-32(fp)
 823bf80:	100b883a 	mov	r5,r2
 823bf84:	e13ffc17 	ldw	r4,-16(fp)
 823bf88:	823bd7c0 	call	823bd7c <alt_ic_irq_enable>
 823bf8c:	00000406 	br	823bfa0 <alt_iic_isr_register+0xc4>
 823bf90:	e0bff817 	ldw	r2,-32(fp)
 823bf94:	100b883a 	mov	r5,r2
 823bf98:	e13ffc17 	ldw	r4,-16(fp)
 823bf9c:	823be040 	call	823be04 <alt_ic_irq_disable>
 823bfa0:	e0bff715 	stw	r2,-36(fp)
 823bfa4:	e0bffa17 	ldw	r2,-24(fp)
 823bfa8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bfac:	e0bff917 	ldw	r2,-28(fp)
 823bfb0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 823bfb4:	e0bff717 	ldw	r2,-36(fp)
}
 823bfb8:	e037883a 	mov	sp,fp
 823bfbc:	dfc00117 	ldw	ra,4(sp)
 823bfc0:	df000017 	ldw	fp,0(sp)
 823bfc4:	dec00204 	addi	sp,sp,8
 823bfc8:	f800283a 	ret

0823bfcc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 823bfcc:	defff904 	addi	sp,sp,-28
 823bfd0:	dfc00615 	stw	ra,24(sp)
 823bfd4:	df000515 	stw	fp,20(sp)
 823bfd8:	df000504 	addi	fp,sp,20
 823bfdc:	e13ffc15 	stw	r4,-16(fp)
 823bfe0:	e17ffd15 	stw	r5,-12(fp)
 823bfe4:	e1bffe15 	stw	r6,-8(fp)
 823bfe8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 823bfec:	e1bfff17 	ldw	r6,-4(fp)
 823bff0:	e17ffe17 	ldw	r5,-8(fp)
 823bff4:	e13ffd17 	ldw	r4,-12(fp)
 823bff8:	823c20c0 	call	823c20c <open>
 823bffc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 823c000:	e0bffb17 	ldw	r2,-20(fp)
 823c004:	10001c16 	blt	r2,zero,823c078 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 823c008:	00820974 	movhi	r2,2085
 823c00c:	108df204 	addi	r2,r2,14280
 823c010:	e0fffb17 	ldw	r3,-20(fp)
 823c014:	18c00324 	muli	r3,r3,12
 823c018:	10c5883a 	add	r2,r2,r3
 823c01c:	10c00017 	ldw	r3,0(r2)
 823c020:	e0bffc17 	ldw	r2,-16(fp)
 823c024:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 823c028:	00820974 	movhi	r2,2085
 823c02c:	108df204 	addi	r2,r2,14280
 823c030:	e0fffb17 	ldw	r3,-20(fp)
 823c034:	18c00324 	muli	r3,r3,12
 823c038:	10c5883a 	add	r2,r2,r3
 823c03c:	10800104 	addi	r2,r2,4
 823c040:	10c00017 	ldw	r3,0(r2)
 823c044:	e0bffc17 	ldw	r2,-16(fp)
 823c048:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 823c04c:	00820974 	movhi	r2,2085
 823c050:	108df204 	addi	r2,r2,14280
 823c054:	e0fffb17 	ldw	r3,-20(fp)
 823c058:	18c00324 	muli	r3,r3,12
 823c05c:	10c5883a 	add	r2,r2,r3
 823c060:	10800204 	addi	r2,r2,8
 823c064:	10c00017 	ldw	r3,0(r2)
 823c068:	e0bffc17 	ldw	r2,-16(fp)
 823c06c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 823c070:	e13ffb17 	ldw	r4,-20(fp)
 823c074:	823c4980 	call	823c498 <alt_release_fd>
  }
} 
 823c078:	0001883a 	nop
 823c07c:	e037883a 	mov	sp,fp
 823c080:	dfc00117 	ldw	ra,4(sp)
 823c084:	df000017 	ldw	fp,0(sp)
 823c088:	dec00204 	addi	sp,sp,8
 823c08c:	f800283a 	ret

0823c090 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 823c090:	defffb04 	addi	sp,sp,-20
 823c094:	dfc00415 	stw	ra,16(sp)
 823c098:	df000315 	stw	fp,12(sp)
 823c09c:	df000304 	addi	fp,sp,12
 823c0a0:	e13ffd15 	stw	r4,-12(fp)
 823c0a4:	e17ffe15 	stw	r5,-8(fp)
 823c0a8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 823c0ac:	01c07fc4 	movi	r7,511
 823c0b0:	01800044 	movi	r6,1
 823c0b4:	e17ffd17 	ldw	r5,-12(fp)
 823c0b8:	01020974 	movhi	r4,2085
 823c0bc:	210df504 	addi	r4,r4,14292
 823c0c0:	823bfcc0 	call	823bfcc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 823c0c4:	01c07fc4 	movi	r7,511
 823c0c8:	000d883a 	mov	r6,zero
 823c0cc:	e17ffe17 	ldw	r5,-8(fp)
 823c0d0:	01020974 	movhi	r4,2085
 823c0d4:	210df204 	addi	r4,r4,14280
 823c0d8:	823bfcc0 	call	823bfcc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 823c0dc:	01c07fc4 	movi	r7,511
 823c0e0:	01800044 	movi	r6,1
 823c0e4:	e17fff17 	ldw	r5,-4(fp)
 823c0e8:	01020974 	movhi	r4,2085
 823c0ec:	210df804 	addi	r4,r4,14304
 823c0f0:	823bfcc0 	call	823bfcc <alt_open_fd>
}  
 823c0f4:	0001883a 	nop
 823c0f8:	e037883a 	mov	sp,fp
 823c0fc:	dfc00117 	ldw	ra,4(sp)
 823c100:	df000017 	ldw	fp,0(sp)
 823c104:	dec00204 	addi	sp,sp,8
 823c108:	f800283a 	ret

0823c10c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c10c:	defffe04 	addi	sp,sp,-8
 823c110:	dfc00115 	stw	ra,4(sp)
 823c114:	df000015 	stw	fp,0(sp)
 823c118:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c11c:	d0a04717 	ldw	r2,-32484(gp)
 823c120:	10000326 	beq	r2,zero,823c130 <alt_get_errno+0x24>
 823c124:	d0a04717 	ldw	r2,-32484(gp)
 823c128:	103ee83a 	callr	r2
 823c12c:	00000106 	br	823c134 <alt_get_errno+0x28>
 823c130:	d0a06304 	addi	r2,gp,-32372
}
 823c134:	e037883a 	mov	sp,fp
 823c138:	dfc00117 	ldw	ra,4(sp)
 823c13c:	df000017 	ldw	fp,0(sp)
 823c140:	dec00204 	addi	sp,sp,8
 823c144:	f800283a 	ret

0823c148 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 823c148:	defffd04 	addi	sp,sp,-12
 823c14c:	df000215 	stw	fp,8(sp)
 823c150:	df000204 	addi	fp,sp,8
 823c154:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 823c158:	e0bfff17 	ldw	r2,-4(fp)
 823c15c:	10800217 	ldw	r2,8(r2)
 823c160:	10d00034 	orhi	r3,r2,16384
 823c164:	e0bfff17 	ldw	r2,-4(fp)
 823c168:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c16c:	e03ffe15 	stw	zero,-8(fp)
 823c170:	00001d06 	br	823c1e8 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c174:	00820974 	movhi	r2,2085
 823c178:	108df204 	addi	r2,r2,14280
 823c17c:	e0fffe17 	ldw	r3,-8(fp)
 823c180:	18c00324 	muli	r3,r3,12
 823c184:	10c5883a 	add	r2,r2,r3
 823c188:	10c00017 	ldw	r3,0(r2)
 823c18c:	e0bfff17 	ldw	r2,-4(fp)
 823c190:	10800017 	ldw	r2,0(r2)
 823c194:	1880111e 	bne	r3,r2,823c1dc <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c198:	00820974 	movhi	r2,2085
 823c19c:	108df204 	addi	r2,r2,14280
 823c1a0:	e0fffe17 	ldw	r3,-8(fp)
 823c1a4:	18c00324 	muli	r3,r3,12
 823c1a8:	10c5883a 	add	r2,r2,r3
 823c1ac:	10800204 	addi	r2,r2,8
 823c1b0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c1b4:	1000090e 	bge	r2,zero,823c1dc <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 823c1b8:	e0bffe17 	ldw	r2,-8(fp)
 823c1bc:	10c00324 	muli	r3,r2,12
 823c1c0:	00820974 	movhi	r2,2085
 823c1c4:	108df204 	addi	r2,r2,14280
 823c1c8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c1cc:	e0bfff17 	ldw	r2,-4(fp)
 823c1d0:	18800226 	beq	r3,r2,823c1dc <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 823c1d4:	00bffcc4 	movi	r2,-13
 823c1d8:	00000806 	br	823c1fc <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c1dc:	e0bffe17 	ldw	r2,-8(fp)
 823c1e0:	10800044 	addi	r2,r2,1
 823c1e4:	e0bffe15 	stw	r2,-8(fp)
 823c1e8:	d0a04617 	ldw	r2,-32488(gp)
 823c1ec:	1007883a 	mov	r3,r2
 823c1f0:	e0bffe17 	ldw	r2,-8(fp)
 823c1f4:	18bfdf2e 	bgeu	r3,r2,823c174 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 823c1f8:	0005883a 	mov	r2,zero
}
 823c1fc:	e037883a 	mov	sp,fp
 823c200:	df000017 	ldw	fp,0(sp)
 823c204:	dec00104 	addi	sp,sp,4
 823c208:	f800283a 	ret

0823c20c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 823c20c:	defff604 	addi	sp,sp,-40
 823c210:	dfc00915 	stw	ra,36(sp)
 823c214:	df000815 	stw	fp,32(sp)
 823c218:	df000804 	addi	fp,sp,32
 823c21c:	e13ffd15 	stw	r4,-12(fp)
 823c220:	e17ffe15 	stw	r5,-8(fp)
 823c224:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 823c228:	00bfffc4 	movi	r2,-1
 823c22c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 823c230:	00bffb44 	movi	r2,-19
 823c234:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 823c238:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 823c23c:	d1604404 	addi	r5,gp,-32496
 823c240:	e13ffd17 	ldw	r4,-12(fp)
 823c244:	823bc9c0 	call	823bc9c <alt_find_dev>
 823c248:	e0bff815 	stw	r2,-32(fp)
 823c24c:	e0bff817 	ldw	r2,-32(fp)
 823c250:	1000051e 	bne	r2,zero,823c268 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 823c254:	e13ffd17 	ldw	r4,-12(fp)
 823c258:	8249fc80 	call	8249fc8 <alt_find_file>
 823c25c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 823c260:	00800044 	movi	r2,1
 823c264:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 823c268:	e0bff817 	ldw	r2,-32(fp)
 823c26c:	10002926 	beq	r2,zero,823c314 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 823c270:	e13ff817 	ldw	r4,-32(fp)
 823c274:	824a0d00 	call	824a0d0 <alt_get_fd>
 823c278:	e0bff915 	stw	r2,-28(fp)
 823c27c:	e0bff917 	ldw	r2,-28(fp)
 823c280:	1000030e 	bge	r2,zero,823c290 <open+0x84>
    {
      status = index;
 823c284:	e0bff917 	ldw	r2,-28(fp)
 823c288:	e0bffa15 	stw	r2,-24(fp)
 823c28c:	00002306 	br	823c31c <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 823c290:	e0bff917 	ldw	r2,-28(fp)
 823c294:	10c00324 	muli	r3,r2,12
 823c298:	00820974 	movhi	r2,2085
 823c29c:	108df204 	addi	r2,r2,14280
 823c2a0:	1885883a 	add	r2,r3,r2
 823c2a4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 823c2a8:	e0fffe17 	ldw	r3,-8(fp)
 823c2ac:	00900034 	movhi	r2,16384
 823c2b0:	10bfffc4 	addi	r2,r2,-1
 823c2b4:	1886703a 	and	r3,r3,r2
 823c2b8:	e0bffc17 	ldw	r2,-16(fp)
 823c2bc:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 823c2c0:	e0bffb17 	ldw	r2,-20(fp)
 823c2c4:	1000051e 	bne	r2,zero,823c2dc <open+0xd0>
 823c2c8:	e13ffc17 	ldw	r4,-16(fp)
 823c2cc:	823c1480 	call	823c148 <alt_file_locked>
 823c2d0:	e0bffa15 	stw	r2,-24(fp)
 823c2d4:	e0bffa17 	ldw	r2,-24(fp)
 823c2d8:	10001016 	blt	r2,zero,823c31c <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 823c2dc:	e0bff817 	ldw	r2,-32(fp)
 823c2e0:	10800317 	ldw	r2,12(r2)
 823c2e4:	10000826 	beq	r2,zero,823c308 <open+0xfc>
 823c2e8:	e0bff817 	ldw	r2,-32(fp)
 823c2ec:	10800317 	ldw	r2,12(r2)
 823c2f0:	e1ffff17 	ldw	r7,-4(fp)
 823c2f4:	e1bffe17 	ldw	r6,-8(fp)
 823c2f8:	e17ffd17 	ldw	r5,-12(fp)
 823c2fc:	e13ffc17 	ldw	r4,-16(fp)
 823c300:	103ee83a 	callr	r2
 823c304:	00000106 	br	823c30c <open+0x100>
 823c308:	0005883a 	mov	r2,zero
 823c30c:	e0bffa15 	stw	r2,-24(fp)
 823c310:	00000206 	br	823c31c <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 823c314:	00bffb44 	movi	r2,-19
 823c318:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 823c31c:	e0bffa17 	ldw	r2,-24(fp)
 823c320:	1000090e 	bge	r2,zero,823c348 <open+0x13c>
  {
    alt_release_fd (index);  
 823c324:	e13ff917 	ldw	r4,-28(fp)
 823c328:	823c4980 	call	823c498 <alt_release_fd>
    ALT_ERRNO = -status;
 823c32c:	823c10c0 	call	823c10c <alt_get_errno>
 823c330:	1007883a 	mov	r3,r2
 823c334:	e0bffa17 	ldw	r2,-24(fp)
 823c338:	0085c83a 	sub	r2,zero,r2
 823c33c:	18800015 	stw	r2,0(r3)
    return -1;
 823c340:	00bfffc4 	movi	r2,-1
 823c344:	00000106 	br	823c34c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 823c348:	e0bff917 	ldw	r2,-28(fp)
}
 823c34c:	e037883a 	mov	sp,fp
 823c350:	dfc00117 	ldw	ra,4(sp)
 823c354:	df000017 	ldw	fp,0(sp)
 823c358:	dec00204 	addi	sp,sp,8
 823c35c:	f800283a 	ret

0823c360 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c360:	defffe04 	addi	sp,sp,-8
 823c364:	dfc00115 	stw	ra,4(sp)
 823c368:	df000015 	stw	fp,0(sp)
 823c36c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c370:	d0a04717 	ldw	r2,-32484(gp)
 823c374:	10000326 	beq	r2,zero,823c384 <alt_get_errno+0x24>
 823c378:	d0a04717 	ldw	r2,-32484(gp)
 823c37c:	103ee83a 	callr	r2
 823c380:	00000106 	br	823c388 <alt_get_errno+0x28>
 823c384:	d0a06304 	addi	r2,gp,-32372
}
 823c388:	e037883a 	mov	sp,fp
 823c38c:	dfc00117 	ldw	ra,4(sp)
 823c390:	df000017 	ldw	fp,0(sp)
 823c394:	dec00204 	addi	sp,sp,8
 823c398:	f800283a 	ret

0823c39c <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 823c39c:	defff904 	addi	sp,sp,-28
 823c3a0:	dfc00615 	stw	ra,24(sp)
 823c3a4:	df000515 	stw	fp,20(sp)
 823c3a8:	df000504 	addi	fp,sp,20
 823c3ac:	e13ffd15 	stw	r4,-12(fp)
 823c3b0:	e17ffe15 	stw	r5,-8(fp)
 823c3b4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c3b8:	e0bffd17 	ldw	r2,-12(fp)
 823c3bc:	10000616 	blt	r2,zero,823c3d8 <alt_read+0x3c>
 823c3c0:	e0bffd17 	ldw	r2,-12(fp)
 823c3c4:	10c00324 	muli	r3,r2,12
 823c3c8:	00820974 	movhi	r2,2085
 823c3cc:	108df204 	addi	r2,r2,14280
 823c3d0:	1885883a 	add	r2,r3,r2
 823c3d4:	00000106 	br	823c3dc <alt_read+0x40>
 823c3d8:	0005883a 	mov	r2,zero
 823c3dc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c3e0:	e0bffb17 	ldw	r2,-20(fp)
 823c3e4:	10002226 	beq	r2,zero,823c470 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c3e8:	e0bffb17 	ldw	r2,-20(fp)
 823c3ec:	10800217 	ldw	r2,8(r2)
 823c3f0:	108000cc 	andi	r2,r2,3
 823c3f4:	10800060 	cmpeqi	r2,r2,1
 823c3f8:	1000181e 	bne	r2,zero,823c45c <alt_read+0xc0>
        (fd->dev->read))
 823c3fc:	e0bffb17 	ldw	r2,-20(fp)
 823c400:	10800017 	ldw	r2,0(r2)
 823c404:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c408:	10001426 	beq	r2,zero,823c45c <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 823c40c:	e0bffb17 	ldw	r2,-20(fp)
 823c410:	10800017 	ldw	r2,0(r2)
 823c414:	10800517 	ldw	r2,20(r2)
 823c418:	e0ffff17 	ldw	r3,-4(fp)
 823c41c:	180d883a 	mov	r6,r3
 823c420:	e17ffe17 	ldw	r5,-8(fp)
 823c424:	e13ffb17 	ldw	r4,-20(fp)
 823c428:	103ee83a 	callr	r2
 823c42c:	e0bffc15 	stw	r2,-16(fp)
 823c430:	e0bffc17 	ldw	r2,-16(fp)
 823c434:	1000070e 	bge	r2,zero,823c454 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 823c438:	823c3600 	call	823c360 <alt_get_errno>
 823c43c:	1007883a 	mov	r3,r2
 823c440:	e0bffc17 	ldw	r2,-16(fp)
 823c444:	0085c83a 	sub	r2,zero,r2
 823c448:	18800015 	stw	r2,0(r3)
          return -1;
 823c44c:	00bfffc4 	movi	r2,-1
 823c450:	00000c06 	br	823c484 <alt_read+0xe8>
        }
        return rval;
 823c454:	e0bffc17 	ldw	r2,-16(fp)
 823c458:	00000a06 	br	823c484 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 823c45c:	823c3600 	call	823c360 <alt_get_errno>
 823c460:	1007883a 	mov	r3,r2
 823c464:	00800344 	movi	r2,13
 823c468:	18800015 	stw	r2,0(r3)
 823c46c:	00000406 	br	823c480 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 823c470:	823c3600 	call	823c360 <alt_get_errno>
 823c474:	1007883a 	mov	r3,r2
 823c478:	00801444 	movi	r2,81
 823c47c:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c480:	00bfffc4 	movi	r2,-1
}
 823c484:	e037883a 	mov	sp,fp
 823c488:	dfc00117 	ldw	ra,4(sp)
 823c48c:	df000017 	ldw	fp,0(sp)
 823c490:	dec00204 	addi	sp,sp,8
 823c494:	f800283a 	ret

0823c498 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 823c498:	defffe04 	addi	sp,sp,-8
 823c49c:	df000115 	stw	fp,4(sp)
 823c4a0:	df000104 	addi	fp,sp,4
 823c4a4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 823c4a8:	e0bfff17 	ldw	r2,-4(fp)
 823c4ac:	108000d0 	cmplti	r2,r2,3
 823c4b0:	10000d1e 	bne	r2,zero,823c4e8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 823c4b4:	00820974 	movhi	r2,2085
 823c4b8:	108df204 	addi	r2,r2,14280
 823c4bc:	e0ffff17 	ldw	r3,-4(fp)
 823c4c0:	18c00324 	muli	r3,r3,12
 823c4c4:	10c5883a 	add	r2,r2,r3
 823c4c8:	10800204 	addi	r2,r2,8
 823c4cc:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 823c4d0:	00820974 	movhi	r2,2085
 823c4d4:	108df204 	addi	r2,r2,14280
 823c4d8:	e0ffff17 	ldw	r3,-4(fp)
 823c4dc:	18c00324 	muli	r3,r3,12
 823c4e0:	10c5883a 	add	r2,r2,r3
 823c4e4:	10000015 	stw	zero,0(r2)
  }
}
 823c4e8:	0001883a 	nop
 823c4ec:	e037883a 	mov	sp,fp
 823c4f0:	df000017 	ldw	fp,0(sp)
 823c4f4:	dec00104 	addi	sp,sp,4
 823c4f8:	f800283a 	ret

0823c4fc <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 823c4fc:	defffd04 	addi	sp,sp,-12
 823c500:	df000215 	stw	fp,8(sp)
 823c504:	df000204 	addi	fp,sp,8
 823c508:	e13ffe15 	stw	r4,-8(fp)
 823c50c:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 823c510:	e0fffe17 	ldw	r3,-8(fp)
 823c514:	00a00034 	movhi	r2,32768
 823c518:	10bfffc4 	addi	r2,r2,-1
 823c51c:	1884703a 	and	r2,r3,r2
}
 823c520:	e037883a 	mov	sp,fp
 823c524:	df000017 	ldw	fp,0(sp)
 823c528:	dec00104 	addi	sp,sp,4
 823c52c:	f800283a 	ret

0823c530 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 823c530:	defffa04 	addi	sp,sp,-24
 823c534:	df000515 	stw	fp,20(sp)
 823c538:	df000504 	addi	fp,sp,20
 823c53c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c540:	0005303a 	rdctl	r2,status
 823c544:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c548:	e0fffc17 	ldw	r3,-16(fp)
 823c54c:	00bfff84 	movi	r2,-2
 823c550:	1884703a 	and	r2,r3,r2
 823c554:	1001703a 	wrctl	status,r2
  
  return context;
 823c558:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 823c55c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 823c560:	e0bfff17 	ldw	r2,-4(fp)
 823c564:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 823c568:	e0bffd17 	ldw	r2,-12(fp)
 823c56c:	10800017 	ldw	r2,0(r2)
 823c570:	e0fffd17 	ldw	r3,-12(fp)
 823c574:	18c00117 	ldw	r3,4(r3)
 823c578:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 823c57c:	e0bffd17 	ldw	r2,-12(fp)
 823c580:	10800117 	ldw	r2,4(r2)
 823c584:	e0fffd17 	ldw	r3,-12(fp)
 823c588:	18c00017 	ldw	r3,0(r3)
 823c58c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 823c590:	e0bffd17 	ldw	r2,-12(fp)
 823c594:	e0fffd17 	ldw	r3,-12(fp)
 823c598:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 823c59c:	e0bffd17 	ldw	r2,-12(fp)
 823c5a0:	e0fffd17 	ldw	r3,-12(fp)
 823c5a4:	10c00015 	stw	r3,0(r2)
 823c5a8:	e0bffb17 	ldw	r2,-20(fp)
 823c5ac:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c5b0:	e0bffe17 	ldw	r2,-8(fp)
 823c5b4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 823c5b8:	0001883a 	nop
 823c5bc:	e037883a 	mov	sp,fp
 823c5c0:	df000017 	ldw	fp,0(sp)
 823c5c4:	dec00104 	addi	sp,sp,4
 823c5c8:	f800283a 	ret

0823c5cc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 823c5cc:	defffb04 	addi	sp,sp,-20
 823c5d0:	dfc00415 	stw	ra,16(sp)
 823c5d4:	df000315 	stw	fp,12(sp)
 823c5d8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 823c5dc:	d0a04917 	ldw	r2,-32476(gp)
 823c5e0:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 823c5e4:	d0a0b917 	ldw	r2,-32028(gp)
 823c5e8:	10800044 	addi	r2,r2,1
 823c5ec:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c5f0:	00002e06 	br	823c6ac <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 823c5f4:	e0bffd17 	ldw	r2,-12(fp)
 823c5f8:	10800017 	ldw	r2,0(r2)
 823c5fc:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 823c600:	e0bffd17 	ldw	r2,-12(fp)
 823c604:	10800403 	ldbu	r2,16(r2)
 823c608:	10803fcc 	andi	r2,r2,255
 823c60c:	10000426 	beq	r2,zero,823c620 <alt_tick+0x54>
 823c610:	d0a0b917 	ldw	r2,-32028(gp)
 823c614:	1000021e 	bne	r2,zero,823c620 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 823c618:	e0bffd17 	ldw	r2,-12(fp)
 823c61c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 823c620:	e0bffd17 	ldw	r2,-12(fp)
 823c624:	10800217 	ldw	r2,8(r2)
 823c628:	d0e0b917 	ldw	r3,-32028(gp)
 823c62c:	18801d36 	bltu	r3,r2,823c6a4 <alt_tick+0xd8>
 823c630:	e0bffd17 	ldw	r2,-12(fp)
 823c634:	10800403 	ldbu	r2,16(r2)
 823c638:	10803fcc 	andi	r2,r2,255
 823c63c:	1000191e 	bne	r2,zero,823c6a4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 823c640:	e0bffd17 	ldw	r2,-12(fp)
 823c644:	10800317 	ldw	r2,12(r2)
 823c648:	e0fffd17 	ldw	r3,-12(fp)
 823c64c:	18c00517 	ldw	r3,20(r3)
 823c650:	1809883a 	mov	r4,r3
 823c654:	103ee83a 	callr	r2
 823c658:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 823c65c:	e0bfff17 	ldw	r2,-4(fp)
 823c660:	1000031e 	bne	r2,zero,823c670 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 823c664:	e13ffd17 	ldw	r4,-12(fp)
 823c668:	823c5300 	call	823c530 <alt_alarm_stop>
 823c66c:	00000d06 	br	823c6a4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 823c670:	e0bffd17 	ldw	r2,-12(fp)
 823c674:	10c00217 	ldw	r3,8(r2)
 823c678:	e0bfff17 	ldw	r2,-4(fp)
 823c67c:	1887883a 	add	r3,r3,r2
 823c680:	e0bffd17 	ldw	r2,-12(fp)
 823c684:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 823c688:	e0bffd17 	ldw	r2,-12(fp)
 823c68c:	10c00217 	ldw	r3,8(r2)
 823c690:	d0a0b917 	ldw	r2,-32028(gp)
 823c694:	1880032e 	bgeu	r3,r2,823c6a4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 823c698:	e0bffd17 	ldw	r2,-12(fp)
 823c69c:	00c00044 	movi	r3,1
 823c6a0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 823c6a4:	e0bffe17 	ldw	r2,-8(fp)
 823c6a8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c6ac:	e0fffd17 	ldw	r3,-12(fp)
 823c6b0:	d0a04904 	addi	r2,gp,-32476
 823c6b4:	18bfcf1e 	bne	r3,r2,823c5f4 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 823c6b8:	82155c40 	call	82155c4 <OSTimeTick>
}
 823c6bc:	0001883a 	nop
 823c6c0:	e037883a 	mov	sp,fp
 823c6c4:	dfc00117 	ldw	ra,4(sp)
 823c6c8:	df000017 	ldw	fp,0(sp)
 823c6cc:	dec00204 	addi	sp,sp,8
 823c6d0:	f800283a 	ret

0823c6d4 <alt_uncached_free>:
/*
 * Free a block of uncached memory.
 */

void alt_uncached_free (volatile void* ptr)
{
 823c6d4:	defffd04 	addi	sp,sp,-12
 823c6d8:	dfc00215 	stw	ra,8(sp)
 823c6dc:	df000115 	stw	fp,4(sp)
 823c6e0:	df000104 	addi	fp,sp,4
 823c6e4:	e13fff15 	stw	r4,-4(fp)
  free ((void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK));
 823c6e8:	e0ffff17 	ldw	r3,-4(fp)
 823c6ec:	00a00034 	movhi	r2,32768
 823c6f0:	10bfffc4 	addi	r2,r2,-1
 823c6f4:	1884703a 	and	r2,r3,r2
 823c6f8:	1009883a 	mov	r4,r2
 823c6fc:	824b3f00 	call	824b3f0 <free>
}
 823c700:	0001883a 	nop
 823c704:	e037883a 	mov	sp,fp
 823c708:	dfc00117 	ldw	ra,4(sp)
 823c70c:	df000017 	ldw	fp,0(sp)
 823c710:	dec00204 	addi	sp,sp,8
 823c714:	f800283a 	ret

0823c718 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 823c718:	defffc04 	addi	sp,sp,-16
 823c71c:	dfc00315 	stw	ra,12(sp)
 823c720:	df000215 	stw	fp,8(sp)
 823c724:	df000204 	addi	fp,sp,8
 823c728:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
 823c72c:	e13fff17 	ldw	r4,-4(fp)
 823c730:	824b3dc0 	call	824b3dc <malloc>
 823c734:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
 823c738:	e17fff17 	ldw	r5,-4(fp)
 823c73c:	e13ffe17 	ldw	r4,-8(fp)
 823c740:	823ba580 	call	823ba58 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 823c744:	e0bffe17 	ldw	r2,-8(fp)
 823c748:	10000326 	beq	r2,zero,823c758 <alt_uncached_malloc+0x40>
 823c74c:	e0bffe17 	ldw	r2,-8(fp)
 823c750:	10a00034 	orhi	r2,r2,32768
 823c754:	00000106 	br	823c75c <alt_uncached_malloc+0x44>
 823c758:	0005883a 	mov	r2,zero
}
 823c75c:	e037883a 	mov	sp,fp
 823c760:	dfc00117 	ldw	ra,4(sp)
 823c764:	df000017 	ldw	fp,0(sp)
 823c768:	dec00204 	addi	sp,sp,8
 823c76c:	f800283a 	ret

0823c770 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 823c770:	defffb04 	addi	sp,sp,-20
 823c774:	dfc00415 	stw	ra,16(sp)
 823c778:	df000315 	stw	fp,12(sp)
 823c77c:	df000304 	addi	fp,sp,12
 823c780:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 823c784:	d0a06b43 	ldbu	r2,-32339(gp)
 823c788:	10803fcc 	andi	r2,r2,255
 823c78c:	1000031e 	bne	r2,zero,823c79c <usleep+0x2c>
  {
    return alt_busy_sleep (us);
 823c790:	e13fff17 	ldw	r4,-4(fp)
 823c794:	8249d140 	call	8249d14 <alt_busy_sleep>
 823c798:	00003e06 	br	823c894 <usleep+0x124>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823c79c:	d0a0b817 	ldw	r2,-32032(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 823c7a0:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 823c7a4:	e0ffff17 	ldw	r3,-4(fp)
 823c7a8:	0090c734 	movhi	r2,17180
 823c7ac:	10b7a0c4 	addi	r2,r2,-8573
 823c7b0:	1888383a 	mulxuu	r4,r3,r2
 823c7b4:	1885383a 	mul	r2,r3,r2
 823c7b8:	1013883a 	mov	r9,r2
 823c7bc:	2015883a 	mov	r10,r4
 823c7c0:	5006d4ba 	srli	r3,r10,18
 823c7c4:	e0bffe17 	ldw	r2,-8(fp)
 823c7c8:	1893383a 	mul	r9,r3,r2
 823c7cc:	e0ffff17 	ldw	r3,-4(fp)
 823c7d0:	0090c734 	movhi	r2,17180
 823c7d4:	10b7a0c4 	addi	r2,r2,-8573
 823c7d8:	1888383a 	mulxuu	r4,r3,r2
 823c7dc:	1885383a 	mul	r2,r3,r2
 823c7e0:	100f883a 	mov	r7,r2
 823c7e4:	2011883a 	mov	r8,r4
 823c7e8:	4004d4ba 	srli	r2,r8,18
 823c7ec:	010003f4 	movhi	r4,15
 823c7f0:	21109004 	addi	r4,r4,16960
 823c7f4:	1105383a 	mul	r2,r2,r4
 823c7f8:	1885c83a 	sub	r2,r3,r2
 823c7fc:	e0fffe17 	ldw	r3,-8(fp)
 823c800:	10c7383a 	mul	r3,r2,r3
 823c804:	0090c734 	movhi	r2,17180
 823c808:	10b7a0c4 	addi	r2,r2,-8573
 823c80c:	1888383a 	mulxuu	r4,r3,r2
 823c810:	1885383a 	mul	r2,r3,r2
 823c814:	100b883a 	mov	r5,r2
 823c818:	200d883a 	mov	r6,r4
 823c81c:	3004d4ba 	srli	r2,r6,18
 823c820:	4885883a 	add	r2,r9,r2
 823c824:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823c828:	00000706 	br	823c848 <usleep+0xd8>
  {
    OSTimeDly(0xffff);
 823c82c:	013fffd4 	movui	r4,65535
 823c830:	821bc240 	call	821bc24 <OSTimeDly>
    ticks -= 0xffff;
 823c834:	e0fffd17 	ldw	r3,-12(fp)
 823c838:	00bffff4 	movhi	r2,65535
 823c83c:	10800044 	addi	r2,r2,1
 823c840:	1885883a 	add	r2,r3,r2
 823c844:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823c848:	e0bffd17 	ldw	r2,-12(fp)
 823c84c:	00ffffd4 	movui	r3,65535
 823c850:	18bff636 	bltu	r3,r2,823c82c <usleep+0xbc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 823c854:	e0bffd17 	ldw	r2,-12(fp)
 823c858:	10bfffcc 	andi	r2,r2,65535
 823c85c:	1009883a 	mov	r4,r2
 823c860:	821bc240 	call	821bc24 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 823c864:	e17ffe17 	ldw	r5,-8(fp)
 823c868:	010003f4 	movhi	r4,15
 823c86c:	21109004 	addi	r4,r4,16960
 823c870:	820295c0 	call	820295c <__udivsi3>
 823c874:	1007883a 	mov	r3,r2
 823c878:	e0bfff17 	ldw	r2,-4(fp)
 823c87c:	180b883a 	mov	r5,r3
 823c880:	1009883a 	mov	r4,r2
 823c884:	82029c00 	call	82029c0 <__umodsi3>
 823c888:	1009883a 	mov	r4,r2
 823c88c:	8249d140 	call	8249d14 <alt_busy_sleep>

  return 0;  
 823c890:	0005883a 	mov	r2,zero
}
 823c894:	e037883a 	mov	sp,fp
 823c898:	dfc00117 	ldw	ra,4(sp)
 823c89c:	df000017 	ldw	fp,0(sp)
 823c8a0:	dec00204 	addi	sp,sp,8
 823c8a4:	f800283a 	ret

0823c8a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c8a8:	defffe04 	addi	sp,sp,-8
 823c8ac:	dfc00115 	stw	ra,4(sp)
 823c8b0:	df000015 	stw	fp,0(sp)
 823c8b4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c8b8:	d0a04717 	ldw	r2,-32484(gp)
 823c8bc:	10000326 	beq	r2,zero,823c8cc <alt_get_errno+0x24>
 823c8c0:	d0a04717 	ldw	r2,-32484(gp)
 823c8c4:	103ee83a 	callr	r2
 823c8c8:	00000106 	br	823c8d0 <alt_get_errno+0x28>
 823c8cc:	d0a06304 	addi	r2,gp,-32372
}
 823c8d0:	e037883a 	mov	sp,fp
 823c8d4:	dfc00117 	ldw	ra,4(sp)
 823c8d8:	df000017 	ldw	fp,0(sp)
 823c8dc:	dec00204 	addi	sp,sp,8
 823c8e0:	f800283a 	ret

0823c8e4 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 823c8e4:	defff904 	addi	sp,sp,-28
 823c8e8:	dfc00615 	stw	ra,24(sp)
 823c8ec:	df000515 	stw	fp,20(sp)
 823c8f0:	df000504 	addi	fp,sp,20
 823c8f4:	e13ffd15 	stw	r4,-12(fp)
 823c8f8:	e17ffe15 	stw	r5,-8(fp)
 823c8fc:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c900:	e0bffd17 	ldw	r2,-12(fp)
 823c904:	10000616 	blt	r2,zero,823c920 <alt_write+0x3c>
 823c908:	e0bffd17 	ldw	r2,-12(fp)
 823c90c:	10c00324 	muli	r3,r2,12
 823c910:	00820974 	movhi	r2,2085
 823c914:	108df204 	addi	r2,r2,14280
 823c918:	1885883a 	add	r2,r3,r2
 823c91c:	00000106 	br	823c924 <alt_write+0x40>
 823c920:	0005883a 	mov	r2,zero
 823c924:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c928:	e0bffb17 	ldw	r2,-20(fp)
 823c92c:	10002126 	beq	r2,zero,823c9b4 <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 823c930:	e0bffb17 	ldw	r2,-20(fp)
 823c934:	10800217 	ldw	r2,8(r2)
 823c938:	108000cc 	andi	r2,r2,3
 823c93c:	10001826 	beq	r2,zero,823c9a0 <alt_write+0xbc>
 823c940:	e0bffb17 	ldw	r2,-20(fp)
 823c944:	10800017 	ldw	r2,0(r2)
 823c948:	10800617 	ldw	r2,24(r2)
 823c94c:	10001426 	beq	r2,zero,823c9a0 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 823c950:	e0bffb17 	ldw	r2,-20(fp)
 823c954:	10800017 	ldw	r2,0(r2)
 823c958:	10800617 	ldw	r2,24(r2)
 823c95c:	e0ffff17 	ldw	r3,-4(fp)
 823c960:	180d883a 	mov	r6,r3
 823c964:	e17ffe17 	ldw	r5,-8(fp)
 823c968:	e13ffb17 	ldw	r4,-20(fp)
 823c96c:	103ee83a 	callr	r2
 823c970:	e0bffc15 	stw	r2,-16(fp)
 823c974:	e0bffc17 	ldw	r2,-16(fp)
 823c978:	1000070e 	bge	r2,zero,823c998 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 823c97c:	823c8a80 	call	823c8a8 <alt_get_errno>
 823c980:	1007883a 	mov	r3,r2
 823c984:	e0bffc17 	ldw	r2,-16(fp)
 823c988:	0085c83a 	sub	r2,zero,r2
 823c98c:	18800015 	stw	r2,0(r3)
        return -1;
 823c990:	00bfffc4 	movi	r2,-1
 823c994:	00000c06 	br	823c9c8 <alt_write+0xe4>
      }
      return rval;
 823c998:	e0bffc17 	ldw	r2,-16(fp)
 823c99c:	00000a06 	br	823c9c8 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 823c9a0:	823c8a80 	call	823c8a8 <alt_get_errno>
 823c9a4:	1007883a 	mov	r3,r2
 823c9a8:	00800344 	movi	r2,13
 823c9ac:	18800015 	stw	r2,0(r3)
 823c9b0:	00000406 	br	823c9c4 <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 823c9b4:	823c8a80 	call	823c8a8 <alt_get_errno>
 823c9b8:	1007883a 	mov	r3,r2
 823c9bc:	00801444 	movi	r2,81
 823c9c0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c9c4:	00bfffc4 	movi	r2,-1
}
 823c9c8:	e037883a 	mov	sp,fp
 823c9cc:	dfc00117 	ldw	ra,4(sp)
 823c9d0:	df000017 	ldw	fp,0(sp)
 823c9d4:	dec00204 	addi	sp,sp,8
 823c9d8:	f800283a 	ret

0823c9dc <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 823c9dc:	deffff04 	addi	sp,sp,-4
 823c9e0:	df000015 	stw	fp,0(sp)
 823c9e4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 823c9e8:	000170fa 	wrctl	ienable,zero
}
 823c9ec:	0001883a 	nop
 823c9f0:	e037883a 	mov	sp,fp
 823c9f4:	df000017 	ldw	fp,0(sp)
 823c9f8:	dec00104 	addi	sp,sp,4
 823c9fc:	f800283a 	ret

0823ca00 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 823ca00:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 823ca04:	d0e00217 	ldw	r3,-32760(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 823ca08:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 823ca0c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 823ca10:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 823ca14:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 823ca18:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 823ca1c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 823ca20:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 823ca24:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 823ca28:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 823ca2c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 823ca30:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 823ca34:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 823ca38:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823ca3c:	823cc740 	call	823cc74 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 823ca40:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 823ca44:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 823ca48:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 823ca4c:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 823ca50:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 823ca54:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 823ca58:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 823ca5c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 823ca60:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 823ca64:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 823ca68:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 823ca6c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 823ca70:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 823ca74:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 823ca78:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 823ca7c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 823ca80:	d0e00215 	stw	r3,-32760(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 823ca84:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 823ca88:	f800283a 	ret

0823ca8c <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 823ca8c:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 823ca90:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 823ca94:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 823ca98:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823ca9c:	823cc740 	call	823cc74 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 823caa0:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 823caa4:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 823caa8:	003fe506 	br	823ca40 <OSCtxSw+0x40>

0823caac <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 823caac:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 823cab0:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 823cab4:	10800054 	ori	r2,r2,1
      wrctl status, r2
 823cab8:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 823cabc:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 823cac0:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 823cac4:	dec00204 	addi	sp,sp,8

      callr r2
 823cac8:	103ee83a 	callr	r2

      nop
 823cacc:	0001883a 	nop

0823cad0 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 823cad0:	defff704 	addi	sp,sp,-36
 823cad4:	dfc00815 	stw	ra,32(sp)
 823cad8:	df000715 	stw	fp,28(sp)
 823cadc:	df000704 	addi	fp,sp,28
 823cae0:	e13ffc15 	stw	r4,-16(fp)
 823cae4:	e17ffd15 	stw	r5,-12(fp)
 823cae8:	e1bffe15 	stw	r6,-8(fp)
 823caec:	3805883a 	mov	r2,r7
 823caf0:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 823caf4:	e0fffe17 	ldw	r3,-8(fp)
 823caf8:	00bfff04 	movi	r2,-4
 823cafc:	1884703a 	and	r2,r3,r2
 823cb00:	10bef704 	addi	r2,r2,-1060
 823cb04:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 823cb08:	01810904 	movi	r6,1060
 823cb0c:	000b883a 	mov	r5,zero
 823cb10:	e13ff917 	ldw	r4,-28(fp)
 823cb14:	8202f000 	call	8202f00 <memset>
 823cb18:	e0bff917 	ldw	r2,-28(fp)
 823cb1c:	10c0bb04 	addi	r3,r2,748
 823cb20:	e0bff917 	ldw	r2,-28(fp)
 823cb24:	10c00115 	stw	r3,4(r2)
 823cb28:	e0bff917 	ldw	r2,-28(fp)
 823cb2c:	10c0d504 	addi	r3,r2,852
 823cb30:	e0bff917 	ldw	r2,-28(fp)
 823cb34:	10c00215 	stw	r3,8(r2)
 823cb38:	e0bff917 	ldw	r2,-28(fp)
 823cb3c:	10c0ef04 	addi	r3,r2,956
 823cb40:	e0bff917 	ldw	r2,-28(fp)
 823cb44:	10c00315 	stw	r3,12(r2)
 823cb48:	e0fff917 	ldw	r3,-28(fp)
 823cb4c:	00820974 	movhi	r2,2085
 823cb50:	1082e804 	addi	r2,r2,2976
 823cb54:	18800d15 	stw	r2,52(r3)
 823cb58:	e0bff917 	ldw	r2,-28(fp)
 823cb5c:	00c00044 	movi	r3,1
 823cb60:	10c02915 	stw	r3,164(r2)
 823cb64:	10002a15 	stw	zero,168(r2)
 823cb68:	e0bff917 	ldw	r2,-28(fp)
 823cb6c:	00ccc384 	movi	r3,13070
 823cb70:	10c02b0d 	sth	r3,172(r2)
 823cb74:	e0bff917 	ldw	r2,-28(fp)
 823cb78:	00eaf344 	movi	r3,-21555
 823cb7c:	10c02b8d 	sth	r3,174(r2)
 823cb80:	e0bff917 	ldw	r2,-28(fp)
 823cb84:	00c48d04 	movi	r3,4660
 823cb88:	10c02c0d 	sth	r3,176(r2)
 823cb8c:	e0bff917 	ldw	r2,-28(fp)
 823cb90:	00f99b44 	movi	r3,-6547
 823cb94:	10c02c8d 	sth	r3,178(r2)
 823cb98:	e0bff917 	ldw	r2,-28(fp)
 823cb9c:	00f7bb04 	movi	r3,-8468
 823cba0:	10c02d0d 	sth	r3,180(r2)
 823cba4:	e0bff917 	ldw	r2,-28(fp)
 823cba8:	00c00144 	movi	r3,5
 823cbac:	10c02d8d 	sth	r3,182(r2)
 823cbb0:	e0bff917 	ldw	r2,-28(fp)
 823cbb4:	00c002c4 	movi	r3,11
 823cbb8:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 823cbbc:	e0bff917 	ldw	r2,-28(fp)
 823cbc0:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 823cbc4:	e0bffa17 	ldw	r2,-24(fp)
 823cbc8:	10bff304 	addi	r2,r2,-52
 823cbcc:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 823cbd0:	e0bffb17 	ldw	r2,-20(fp)
 823cbd4:	10800c04 	addi	r2,r2,48
 823cbd8:	e0fffc17 	ldw	r3,-16(fp)
 823cbdc:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 823cbe0:	e0bffb17 	ldw	r2,-20(fp)
 823cbe4:	10800b04 	addi	r2,r2,44
 823cbe8:	e0fffd17 	ldw	r3,-12(fp)
 823cbec:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 823cbf0:	e0bffb17 	ldw	r2,-20(fp)
 823cbf4:	10800a04 	addi	r2,r2,40
 823cbf8:	e0fff917 	ldw	r3,-28(fp)
 823cbfc:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 823cc00:	00820934 	movhi	r2,2084
 823cc04:	10b2ab04 	addi	r2,r2,-13652
 823cc08:	10c00104 	addi	r3,r2,4
 823cc0c:	e0bffb17 	ldw	r2,-20(fp)
 823cc10:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 823cc14:	e0bffb17 	ldw	r2,-20(fp)
}
 823cc18:	e037883a 	mov	sp,fp
 823cc1c:	dfc00117 	ldw	ra,4(sp)
 823cc20:	df000017 	ldw	fp,0(sp)
 823cc24:	dec00204 	addi	sp,sp,8
 823cc28:	f800283a 	ret

0823cc2c <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 823cc2c:	defffe04 	addi	sp,sp,-8
 823cc30:	df000115 	stw	fp,4(sp)
 823cc34:	df000104 	addi	fp,sp,4
 823cc38:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 823cc3c:	0001883a 	nop
 823cc40:	e037883a 	mov	sp,fp
 823cc44:	df000017 	ldw	fp,0(sp)
 823cc48:	dec00104 	addi	sp,sp,4
 823cc4c:	f800283a 	ret

0823cc50 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 823cc50:	defffe04 	addi	sp,sp,-8
 823cc54:	df000115 	stw	fp,4(sp)
 823cc58:	df000104 	addi	fp,sp,4
 823cc5c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 823cc60:	0001883a 	nop
 823cc64:	e037883a 	mov	sp,fp
 823cc68:	df000017 	ldw	fp,0(sp)
 823cc6c:	dec00104 	addi	sp,sp,4
 823cc70:	f800283a 	ret

0823cc74 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 823cc74:	deffff04 	addi	sp,sp,-4
 823cc78:	df000015 	stw	fp,0(sp)
 823cc7c:	d839883a 	mov	fp,sp
}
 823cc80:	0001883a 	nop
 823cc84:	e037883a 	mov	sp,fp
 823cc88:	df000017 	ldw	fp,0(sp)
 823cc8c:	dec00104 	addi	sp,sp,4
 823cc90:	f800283a 	ret

0823cc94 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 823cc94:	deffff04 	addi	sp,sp,-4
 823cc98:	df000015 	stw	fp,0(sp)
 823cc9c:	d839883a 	mov	fp,sp
}
 823cca0:	0001883a 	nop
 823cca4:	e037883a 	mov	sp,fp
 823cca8:	df000017 	ldw	fp,0(sp)
 823ccac:	dec00104 	addi	sp,sp,4
 823ccb0:	f800283a 	ret

0823ccb4 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 823ccb4:	defffe04 	addi	sp,sp,-8
 823ccb8:	dfc00115 	stw	ra,4(sp)
 823ccbc:	df000015 	stw	fp,0(sp)
 823ccc0:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 823ccc4:	822d45c0 	call	822d45c <cticks_hook>
#endif
}
 823ccc8:	0001883a 	nop
 823cccc:	e037883a 	mov	sp,fp
 823ccd0:	dfc00117 	ldw	ra,4(sp)
 823ccd4:	df000017 	ldw	fp,0(sp)
 823ccd8:	dec00204 	addi	sp,sp,8
 823ccdc:	f800283a 	ret

0823cce0 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 823cce0:	deffff04 	addi	sp,sp,-4
 823cce4:	df000015 	stw	fp,0(sp)
 823cce8:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 823ccec:	0001883a 	nop
 823ccf0:	e037883a 	mov	sp,fp
 823ccf4:	df000017 	ldw	fp,0(sp)
 823ccf8:	dec00104 	addi	sp,sp,4
 823ccfc:	f800283a 	ret

0823cd00 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 823cd00:	deffff04 	addi	sp,sp,-4
 823cd04:	df000015 	stw	fp,0(sp)
 823cd08:	d839883a 	mov	fp,sp
}
 823cd0c:	0001883a 	nop
 823cd10:	e037883a 	mov	sp,fp
 823cd14:	df000017 	ldw	fp,0(sp)
 823cd18:	dec00104 	addi	sp,sp,4
 823cd1c:	f800283a 	ret

0823cd20 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 823cd20:	deffff04 	addi	sp,sp,-4
 823cd24:	df000015 	stw	fp,0(sp)
 823cd28:	d839883a 	mov	fp,sp
}
 823cd2c:	0001883a 	nop
 823cd30:	e037883a 	mov	sp,fp
 823cd34:	df000017 	ldw	fp,0(sp)
 823cd38:	dec00104 	addi	sp,sp,4
 823cd3c:	f800283a 	ret

0823cd40 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 823cd40:	defffe04 	addi	sp,sp,-8
 823cd44:	df000115 	stw	fp,4(sp)
 823cd48:	df000104 	addi	fp,sp,4
 823cd4c:	e13fff15 	stw	r4,-4(fp)
}
 823cd50:	0001883a 	nop
 823cd54:	e037883a 	mov	sp,fp
 823cd58:	df000017 	ldw	fp,0(sp)
 823cd5c:	dec00104 	addi	sp,sp,4
 823cd60:	f800283a 	ret

0823cd64 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 823cd64:	defffb04 	addi	sp,sp,-20
 823cd68:	dfc00415 	stw	ra,16(sp)
 823cd6c:	df000315 	stw	fp,12(sp)
 823cd70:	dc000215 	stw	r16,8(sp)
 823cd74:	df000304 	addi	fp,sp,12
   int   e = 0;
 823cd78:	e03ffd15 	stw	zero,-12(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 823cd7c:	d0a04b17 	ldw	r2,-32468(gp)
 823cd80:	1009883a 	mov	r4,r2
 823cd84:	82033700 	call	8203370 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 823cd88:	01020974 	movhi	r4,2085
 823cd8c:	2102f404 	addi	r4,r4,3024
 823cd90:	82033700 	call	8203370 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 823cd94:	822dc280 	call	822dc28 <pre_task_setup>
 823cd98:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823cd9c:	e0bffe17 	ldw	r2,-8(fp)
 823cda0:	10000226 	beq	r2,zero,823cdac <netmain_init+0x48>
      panic(msg);
 823cda4:	e13ffe17 	ldw	r4,-8(fp)
 823cda8:	82289940 	call	8228994 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 823cdac:	82265d00 	call	82265d0 <ip_startup>
 823cdb0:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823cdb4:	e0bffe17 	ldw	r2,-8(fp)
 823cdb8:	10000726 	beq	r2,zero,823cdd8 <netmain_init+0x74>
   {
      printf("inet startup error: %s\n", msg);
 823cdbc:	e17ffe17 	ldw	r5,-8(fp)
 823cdc0:	01020974 	movhi	r4,2085
 823cdc4:	21030604 	addi	r4,r4,3096
 823cdc8:	82030ec0 	call	82030ec <printf>
      panic("IP");
 823cdcc:	01020974 	movhi	r4,2085
 823cdd0:	21030c04 	addi	r4,r4,3120
 823cdd4:	82289940 	call	8228994 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 823cdd8:	8246eb00 	call	8246eb0 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 823cddc:	82464500 	call	8246450 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 823cde0:	d0208315 	stw	zero,-32244(gp)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823cde4:	008209b4 	movhi	r2,2086
 823cde8:	10b97b04 	addi	r2,r2,-6676
 823cdec:	10800017 	ldw	r2,0(r2)
 823cdf0:	14000104 	addi	r16,r2,4
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 823cdf4:	008209b4 	movhi	r2,2086
 823cdf8:	10b97b04 	addi	r2,r2,-6676
 823cdfc:	10800017 	ldw	r2,0(r2)
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823ce00:	10800a17 	ldw	r2,40(r2)
 823ce04:	1009883a 	mov	r4,r2
 823ce08:	82287400 	call	8228740 <print_ipad>
 823ce0c:	100d883a 	mov	r6,r2
 823ce10:	800b883a 	mov	r5,r16
 823ce14:	01020974 	movhi	r4,2085
 823ce18:	21030d04 	addi	r4,r4,3124
 823ce1c:	82030ec0 	call	82030ec <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 823ce20:	822dc740 	call	822dc74 <post_task_setup>
 823ce24:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823ce28:	e0bffe17 	ldw	r2,-8(fp)
 823ce2c:	10000226 	beq	r2,zero,823ce38 <netmain_init+0xd4>
      panic(msg);
 823ce30:	e13ffe17 	ldw	r4,-8(fp)
 823ce34:	82289940 	call	8228994 <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 823ce38:	8246b380 	call	8246b38 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 823ce3c:	0001883a 	nop
 823ce40:	e6ffff04 	addi	sp,fp,-4
 823ce44:	dfc00217 	ldw	ra,8(sp)
 823ce48:	df000117 	ldw	fp,4(sp)
 823ce4c:	dc000017 	ldw	r16,0(sp)
 823ce50:	dec00304 	addi	sp,sp,12
 823ce54:	f800283a 	ret

0823ce58 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 823ce58:	defffb04 	addi	sp,sp,-20
 823ce5c:	dfc00415 	stw	ra,16(sp)
 823ce60:	df000315 	stw	fp,12(sp)
 823ce64:	dc000215 	stw	r16,8(sp)
 823ce68:	df000304 	addi	fp,sp,12
 823ce6c:	e13ffd15 	stw	r4,-12(fp)
 823ce70:	e17ffe15 	stw	r5,-8(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 823ce74:	e0bffe17 	ldw	r2,-8(fp)
 823ce78:	10800003 	ldbu	r2,0(r2)
 823ce7c:	10c03fcc 	andi	r3,r2,255
 823ce80:	18c0201c 	xori	r3,r3,128
 823ce84:	18ffe004 	addi	r3,r3,-128
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 823ce88:	00820974 	movhi	r2,2085
 823ce8c:	108e5204 	addi	r2,r2,14664
 823ce90:	18c7883a 	add	r3,r3,r3
 823ce94:	18c7883a 	add	r3,r3,r3
 823ce98:	10c5883a 	add	r2,r2,r3
 823ce9c:	14000017 	ldw	r16,0(r2)
 823cea0:	e0bffd17 	ldw	r2,-12(fp)
 823cea4:	10800717 	ldw	r2,28(r2)
 823cea8:	1009883a 	mov	r4,r2
 823ceac:	82287400 	call	8228740 <print_ipad>
 823ceb0:	100d883a 	mov	r6,r2
 823ceb4:	800b883a 	mov	r5,r16
 823ceb8:	01020974 	movhi	r4,2085
 823cebc:	21031d04 	addi	r4,r4,3188
 823cec0:	82030ec0 	call	82030ec <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 823cec4:	d0a04c17 	ldw	r2,-32464(gp)
 823cec8:	1009883a 	mov	r4,r2
 823cecc:	82030ec0 	call	82030ec <printf>
}
 823ced0:	0001883a 	nop
 823ced4:	e6ffff04 	addi	sp,fp,-4
 823ced8:	dfc00217 	ldw	ra,8(sp)
 823cedc:	df000117 	ldw	fp,4(sp)
 823cee0:	dc000017 	ldw	r16,0(sp)
 823cee4:	dec00304 	addi	sp,sp,12
 823cee8:	f800283a 	ret

0823ceec <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 823ceec:	defff904 	addi	sp,sp,-28
 823cef0:	dfc00615 	stw	ra,24(sp)
 823cef4:	df000515 	stw	fp,20(sp)
 823cef8:	dc000415 	stw	r16,16(sp)
 823cefc:	df000504 	addi	fp,sp,20
 823cf00:	e13ffe15 	stw	r4,-8(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823cf04:	e03ffc15 	stw	zero,-16(fp)
 823cf08:	008209b4 	movhi	r2,2086
 823cf0c:	10b97b04 	addi	r2,r2,-6676
 823cf10:	10800017 	ldw	r2,0(r2)
 823cf14:	e0bffd15 	stw	r2,-12(fp)
 823cf18:	00002506 	br	823cfb0 <station_state+0xc4>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
 823cf1c:	e0bffd17 	ldw	r2,-12(fp)
 823cf20:	14000104 	addi	r16,r2,4
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 823cf24:	e0bffd17 	ldw	r2,-12(fp)
 823cf28:	10800a17 	ldw	r2,40(r2)
 823cf2c:	1009883a 	mov	r4,r2
 823cf30:	82287400 	call	8228740 <print_ipad>
 823cf34:	d8800015 	stw	r2,0(sp)
 823cf38:	800f883a 	mov	r7,r16
 823cf3c:	e1bffc17 	ldw	r6,-16(fp)
 823cf40:	01420974 	movhi	r5,2085
 823cf44:	29432604 	addi	r5,r5,3224
 823cf48:	e13ffe17 	ldw	r4,-8(fp)
 823cf4c:	8228bac0 	call	8228bac <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 823cf50:	e0bffd17 	ldw	r2,-12(fp)
 823cf54:	10800c17 	ldw	r2,48(r2)
 823cf58:	1009883a 	mov	r4,r2
 823cf5c:	82287400 	call	8228740 <print_ipad>
 823cf60:	100d883a 	mov	r6,r2
 823cf64:	01420974 	movhi	r5,2085
 823cf68:	29432d04 	addi	r5,r5,3252
 823cf6c:	e13ffe17 	ldw	r4,-8(fp)
 823cf70:	8228bac0 	call	8228bac <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 823cf74:	e0bffd17 	ldw	r2,-12(fp)
 823cf78:	10800d17 	ldw	r2,52(r2)
 823cf7c:	1009883a 	mov	r4,r2
 823cf80:	82287400 	call	8228740 <print_ipad>
 823cf84:	100d883a 	mov	r6,r2
 823cf88:	01420974 	movhi	r5,2085
 823cf8c:	29433004 	addi	r5,r5,3264
 823cf90:	e13ffe17 	ldw	r4,-8(fp)
 823cf94:	8228bac0 	call	8228bac <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823cf98:	e0bffd17 	ldw	r2,-12(fp)
 823cf9c:	10800017 	ldw	r2,0(r2)
 823cfa0:	e0bffd15 	stw	r2,-12(fp)
 823cfa4:	e0bffc17 	ldw	r2,-16(fp)
 823cfa8:	10800044 	addi	r2,r2,1
 823cfac:	e0bffc15 	stw	r2,-16(fp)
 823cfb0:	e0bffd17 	ldw	r2,-12(fp)
 823cfb4:	103fd91e 	bne	r2,zero,823cf1c <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 823cfb8:	d0a0a817 	ldw	r2,-32096(gp)
 823cfbc:	100d883a 	mov	r6,r2
 823cfc0:	01420974 	movhi	r5,2085
 823cfc4:	29433304 	addi	r5,r5,3276
 823cfc8:	e13ffe17 	ldw	r4,-8(fp)
 823cfcc:	8228bac0 	call	8228bac <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 823cfd0:	d0e04d17 	ldw	r3,-32460(gp)
 823cfd4:	d0a04d17 	ldw	r2,-32460(gp)
 823cfd8:	108002a4 	muli	r2,r2,10
 823cfdc:	100f883a 	mov	r7,r2
 823cfe0:	180d883a 	mov	r6,r3
 823cfe4:	01420974 	movhi	r5,2085
 823cfe8:	29433904 	addi	r5,r5,3300
 823cfec:	e13ffe17 	ldw	r4,-8(fp)
 823cff0:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 823cff4:	d0a0ba17 	ldw	r2,-32024(gp)
 823cff8:	1009883a 	mov	r4,r2
 823cffc:	82287400 	call	8228740 <print_ipad>
 823d000:	100d883a 	mov	r6,r2
 823d004:	01420974 	movhi	r5,2085
 823d008:	29434504 	addi	r5,r5,3348
 823d00c:	e13ffe17 	ldw	r4,-8(fp)
 823d010:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 823d014:	d0a04e17 	ldw	r2,-32456(gp)
 823d018:	100d883a 	mov	r6,r2
 823d01c:	01420974 	movhi	r5,2085
 823d020:	29434c04 	addi	r5,r5,3376
 823d024:	e13ffe17 	ldw	r4,-8(fp)
 823d028:	8228bac0 	call	8228bac <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 823d02c:	e13ffe17 	ldw	r4,-8(fp)
 823d030:	823d5900 	call	823d590 <task_stats>

   return 0;
 823d034:	0005883a 	mov	r2,zero
}
 823d038:	e6ffff04 	addi	sp,fp,-4
 823d03c:	dfc00217 	ldw	ra,8(sp)
 823d040:	df000117 	ldw	fp,4(sp)
 823d044:	dc000017 	ldw	r16,0(sp)
 823d048:	dec00304 	addi	sp,sp,12
 823d04c:	f800283a 	ret

0823d050 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 823d050:	deffff04 	addi	sp,sp,-4
 823d054:	df000015 	stw	fp,0(sp)
 823d058:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 823d05c:	d160a817 	ldw	r5,-32096(gp)
 823d060:	00947b34 	movhi	r2,20972
 823d064:	10a147c4 	addi	r2,r2,-31457
 823d068:	288c383a 	mulxuu	r6,r5,r2
 823d06c:	2885383a 	mul	r2,r5,r2
 823d070:	1007883a 	mov	r3,r2
 823d074:	3009883a 	mov	r4,r6
 823d078:	2004d17a 	srli	r2,r4,5
 823d07c:	10801924 	muli	r2,r2,100
}
 823d080:	e037883a 	mov	sp,fp
 823d084:	df000017 	ldw	fp,0(sp)
 823d088:	dec00104 	addi	sp,sp,4
 823d08c:	f800283a 	ret

0823d090 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 823d090:	defffe04 	addi	sp,sp,-8
 823d094:	dfc00115 	stw	ra,4(sp)
 823d098:	df000015 	stw	fp,0(sp)
 823d09c:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 823d0a0:	d0a0bb17 	ldw	r2,-32020(gp)
 823d0a4:	1000081e 	bne	r2,zero,823d0c8 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 823d0a8:	d0a0bb17 	ldw	r2,-32020(gp)
 823d0ac:	10800044 	addi	r2,r2,1
 823d0b0:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 823d0b4:	82260100 	call	8226010 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 823d0b8:	d0a0bb17 	ldw	r2,-32020(gp)
 823d0bc:	10bfffc4 	addi	r2,r2,-1
 823d0c0:	d0a0bb15 	stw	r2,-32020(gp)
 823d0c4:	00000106 	br	823d0cc <packet_check+0x3c>

void
packet_check(void)
{
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
      return;           /* do not re-enter pktdemux(), packet will wait... */
 823d0c8:	0001883a 	nop
   inside_pktdemux++;   /* set re-entrany flag */
   pktdemux();          /* process low level packet input */
   inside_pktdemux--;   /* clear re-entrany flag */
}
 823d0cc:	e037883a 	mov	sp,fp
 823d0d0:	dfc00117 	ldw	ra,4(sp)
 823d0d4:	df000017 	ldw	fp,0(sp)
 823d0d8:	dec00204 	addi	sp,sp,8
 823d0dc:	f800283a 	ret

0823d0e0 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 823d0e0:	defffe04 	addi	sp,sp,-8
 823d0e4:	df000115 	stw	fp,4(sp)
 823d0e8:	df000104 	addi	fp,sp,4
 823d0ec:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 823d0f0:	0005883a 	mov	r2,zero
}
 823d0f4:	e037883a 	mov	sp,fp
 823d0f8:	df000017 	ldw	fp,0(sp)
 823d0fc:	dec00104 	addi	sp,sp,4
 823d100:	f800283a 	ret

0823d104 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 823d104:	defffd04 	addi	sp,sp,-12
 823d108:	dfc00215 	stw	ra,8(sp)
 823d10c:	df000115 	stw	fp,4(sp)
 823d110:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 823d114:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 823d118:	8249cf00 	call	8249cf0 <prep_vfs>
 823d11c:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 823d120:	e0bfff17 	ldw	r2,-4(fp)
 823d124:	10000626 	beq	r2,zero,823d140 <prep_modules+0x3c>
   {
      dprintf("VFS Module prep failed\n");
 823d128:	01020974 	movhi	r4,2085
 823d12c:	21035404 	addi	r4,r4,3408
 823d130:	82033700 	call	8203370 <puts>
      panic("prep_modules");
 823d134:	01020974 	movhi	r4,2085
 823d138:	21035a04 	addi	r4,r4,3432
 823d13c:	82289940 	call	8228994 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 823d140:	0005883a 	mov	r2,zero
}
 823d144:	e037883a 	mov	sp,fp
 823d148:	dfc00117 	ldw	ra,4(sp)
 823d14c:	df000017 	ldw	fp,0(sp)
 823d150:	dec00204 	addi	sp,sp,8
 823d154:	f800283a 	ret

0823d158 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 823d158:	defffe04 	addi	sp,sp,-8
 823d15c:	dfc00115 	stw	ra,4(sp)
 823d160:	df000015 	stw	fp,0(sp)
 823d164:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 823d168:	d0e0c917 	ldw	r3,-31964(gp)
 823d16c:	d0a0a817 	ldw	r2,-32096(gp)
 823d170:	1880012e 	bgeu	r3,r2,823d178 <inet_timer+0x20>
      ip_reasm_process_timer_tick ();
 823d174:	82422180 	call	8242218 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 823d178:	822f7440 	call	822f744 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 823d17c:	823d1e40 	call	823d1e4 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 823d180:	d0e08717 	ldw	r3,-32228(gp)
 823d184:	d0a0a817 	ldw	r2,-32096(gp)
 823d188:	1880012e 	bgeu	r3,r2,823d190 <inet_timer+0x38>
      igmp_fasttimo();
 823d18c:	8226bbc0 	call	8226bbc <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d190:	d0e0bc17 	ldw	r3,-32016(gp)
 823d194:	d0a0a817 	ldw	r2,-32096(gp)
 823d198:	18800436 	bltu	r3,r2,823d1ac <inet_timer+0x54>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
 823d19c:	d0a0a817 	ldw	r2,-32096(gp)
 823d1a0:	10c0fa04 	addi	r3,r2,1000
 823d1a4:	d0a0bc17 	ldw	r2,-32016(gp)
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d1a8:	1880082e 	bgeu	r3,r2,823d1cc <inet_timer+0x74>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 823d1ac:	d0a0a817 	ldw	r2,-32096(gp)
 823d1b0:	10801904 	addi	r2,r2,100
 823d1b4:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 823d1b8:	d0a0bd17 	ldw	r2,-32012(gp)
 823d1bc:	10000226 	beq	r2,zero,823d1c8 <inet_timer+0x70>
         (*port_1s_callout)();
 823d1c0:	d0a0bd17 	ldw	r2,-32012(gp)
 823d1c4:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 823d1c8:	822ba5c0 	call	822ba5c <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 823d1cc:	0001883a 	nop
 823d1d0:	e037883a 	mov	sp,fp
 823d1d4:	dfc00117 	ldw	ra,4(sp)
 823d1d8:	df000017 	ldw	fp,0(sp)
 823d1dc:	dec00204 	addi	sp,sp,8
 823d1e0:	f800283a 	ret

0823d1e4 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 823d1e4:	defffc04 	addi	sp,sp,-16
 823d1e8:	dfc00315 	stw	ra,12(sp)
 823d1ec:	df000215 	stw	fp,8(sp)
 823d1f0:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 823d1f4:	e03fff15 	stw	zero,-4(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 823d1f8:	d0a0be17 	ldw	r2,-32008(gp)
 823d1fc:	0080560e 	bge	zero,r2,823d358 <check_interval_timers+0x174>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d200:	e03ffe15 	stw	zero,-8(fp)
 823d204:	00004f06 	br	823d344 <check_interval_timers+0x160>
      {
         if (intimers[i].callback)   /* is this timer active? */
 823d208:	008209b4 	movhi	r2,2086
 823d20c:	10b92204 	addi	r2,r2,-7032
 823d210:	e0fffe17 	ldw	r3,-8(fp)
 823d214:	18c00524 	muli	r3,r3,20
 823d218:	10c5883a 	add	r2,r2,r3
 823d21c:	10800017 	ldw	r2,0(r2)
 823d220:	10004526 	beq	r2,zero,823d338 <check_interval_timers+0x154>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 823d224:	008209b4 	movhi	r2,2086
 823d228:	10b92204 	addi	r2,r2,-7032
 823d22c:	e0fffe17 	ldw	r3,-8(fp)
 823d230:	18c00524 	muli	r3,r3,20
 823d234:	10c5883a 	add	r2,r2,r3
 823d238:	10800304 	addi	r2,r2,12
 823d23c:	10c00017 	ldw	r3,0(r2)
 823d240:	d0a0a817 	ldw	r2,-32096(gp)
 823d244:	1880362e 	bgeu	r3,r2,823d320 <check_interval_timers+0x13c>
 823d248:	008209b4 	movhi	r2,2086
 823d24c:	10b92204 	addi	r2,r2,-7032
 823d250:	e0fffe17 	ldw	r3,-8(fp)
 823d254:	18c00524 	muli	r3,r3,20
 823d258:	10c5883a 	add	r2,r2,r3
 823d25c:	10800404 	addi	r2,r2,16
 823d260:	10800017 	ldw	r2,0(r2)
 823d264:	10002e1e 	bne	r2,zero,823d320 <check_interval_timers+0x13c>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 823d268:	008209b4 	movhi	r2,2086
 823d26c:	10b92204 	addi	r2,r2,-7032
 823d270:	e0fffe17 	ldw	r3,-8(fp)
 823d274:	18c00524 	muli	r3,r3,20
 823d278:	10c5883a 	add	r2,r2,r3
 823d27c:	10800204 	addi	r2,r2,8
 823d280:	10c00017 	ldw	r3,0(r2)
 823d284:	d0a0a817 	ldw	r2,-32096(gp)
 823d288:	1887883a 	add	r3,r3,r2
 823d28c:	008209b4 	movhi	r2,2086
 823d290:	10b92204 	addi	r2,r2,-7032
 823d294:	e13ffe17 	ldw	r4,-8(fp)
 823d298:	21000524 	muli	r4,r4,20
 823d29c:	1105883a 	add	r2,r2,r4
 823d2a0:	10800304 	addi	r2,r2,12
 823d2a4:	10c00015 	stw	r3,0(r2)
               intimers[i].inuse = TRUE;
 823d2a8:	008209b4 	movhi	r2,2086
 823d2ac:	10b92204 	addi	r2,r2,-7032
 823d2b0:	e0fffe17 	ldw	r3,-8(fp)
 823d2b4:	18c00524 	muli	r3,r3,20
 823d2b8:	10c5883a 	add	r2,r2,r3
 823d2bc:	10800404 	addi	r2,r2,16
 823d2c0:	00c00044 	movi	r3,1
 823d2c4:	10c00015 	stw	r3,0(r2)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 823d2c8:	008209b4 	movhi	r2,2086
 823d2cc:	10b92204 	addi	r2,r2,-7032
 823d2d0:	e0fffe17 	ldw	r3,-8(fp)
 823d2d4:	18c00524 	muli	r3,r3,20
 823d2d8:	10c5883a 	add	r2,r2,r3
 823d2dc:	10c00017 	ldw	r3,0(r2)
 823d2e0:	008209b4 	movhi	r2,2086
 823d2e4:	10b92204 	addi	r2,r2,-7032
 823d2e8:	e13ffe17 	ldw	r4,-8(fp)
 823d2ec:	21000524 	muli	r4,r4,20
 823d2f0:	1105883a 	add	r2,r2,r4
 823d2f4:	10800104 	addi	r2,r2,4
 823d2f8:	10800017 	ldw	r2,0(r2)
 823d2fc:	1009883a 	mov	r4,r2
 823d300:	183ee83a 	callr	r3
               intimers[i].inuse = FALSE;
 823d304:	008209b4 	movhi	r2,2086
 823d308:	10b92204 	addi	r2,r2,-7032
 823d30c:	e0fffe17 	ldw	r3,-8(fp)
 823d310:	18c00524 	muli	r3,r3,20
 823d314:	10c5883a 	add	r2,r2,r3
 823d318:	10800404 	addi	r2,r2,16
 823d31c:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 823d320:	e0bfff17 	ldw	r2,-4(fp)
 823d324:	10800044 	addi	r2,r2,1
 823d328:	e0bfff15 	stw	r2,-4(fp)
 823d32c:	d0a0be17 	ldw	r2,-32008(gp)
 823d330:	e0ffff17 	ldw	r3,-4(fp)
 823d334:	1880070e 	bge	r3,r2,823d354 <check_interval_timers+0x170>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d338:	e0bffe17 	ldw	r2,-8(fp)
 823d33c:	10800044 	addi	r2,r2,1
 823d340:	e0bffe15 	stw	r2,-8(fp)
 823d344:	e0bffe17 	ldw	r2,-8(fp)
 823d348:	10800150 	cmplti	r2,r2,5
 823d34c:	103fae1e 	bne	r2,zero,823d208 <check_interval_timers+0x24>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 823d350:	00000106 	br	823d358 <check_interval_timers+0x174>
               intimers[i].callback(intimers[i].parm);      /* call user routine */
               intimers[i].inuse = FALSE;
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
               break;
 823d354:	0001883a 	nop
         }
      }
   }
}
 823d358:	0001883a 	nop
 823d35c:	e037883a 	mov	sp,fp
 823d360:	dfc00117 	ldw	ra,4(sp)
 823d364:	df000017 	ldw	fp,0(sp)
 823d368:	dec00204 	addi	sp,sp,8
 823d36c:	f800283a 	ret

0823d370 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 823d370:	defffa04 	addi	sp,sp,-24
 823d374:	dfc00515 	stw	ra,20(sp)
 823d378:	df000415 	stw	fp,16(sp)
 823d37c:	df000404 	addi	fp,sp,16
 823d380:	e13ffd15 	stw	r4,-12(fp)
 823d384:	e17ffe15 	stw	r5,-8(fp)
 823d388:	e1bfff15 	stw	r6,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d38c:	e03ffc15 	stw	zero,-16(fp)
 823d390:	00004606 	br	823d4ac <in_timerset+0x13c>
   {
      if(intimers[i].callback == NULL)
 823d394:	008209b4 	movhi	r2,2086
 823d398:	10b92204 	addi	r2,r2,-7032
 823d39c:	e0fffc17 	ldw	r3,-16(fp)
 823d3a0:	18c00524 	muli	r3,r3,20
 823d3a4:	10c5883a 	add	r2,r2,r3
 823d3a8:	10800017 	ldw	r2,0(r2)
 823d3ac:	10003c1e 	bne	r2,zero,823d4a0 <in_timerset+0x130>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 823d3b0:	008209b4 	movhi	r2,2086
 823d3b4:	10b92204 	addi	r2,r2,-7032
 823d3b8:	e0fffc17 	ldw	r3,-16(fp)
 823d3bc:	18c00524 	muli	r3,r3,20
 823d3c0:	10c5883a 	add	r2,r2,r3
 823d3c4:	e0fffd17 	ldw	r3,-12(fp)
 823d3c8:	10c00015 	stw	r3,0(r2)
         intimers[i].parm = parm;
 823d3cc:	008209b4 	movhi	r2,2086
 823d3d0:	10b92204 	addi	r2,r2,-7032
 823d3d4:	e0fffc17 	ldw	r3,-16(fp)
 823d3d8:	18c00524 	muli	r3,r3,20
 823d3dc:	10c5883a 	add	r2,r2,r3
 823d3e0:	10800104 	addi	r2,r2,4
 823d3e4:	e0ffff17 	ldw	r3,-4(fp)
 823d3e8:	10c00015 	stw	r3,0(r2)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 823d3ec:	e0bffe17 	ldw	r2,-8(fp)
 823d3f0:	10801924 	muli	r2,r2,100
 823d3f4:	0140fa04 	movi	r5,1000
 823d3f8:	1009883a 	mov	r4,r2
 823d3fc:	82028640 	call	8202864 <__divsi3>
 823d400:	1009883a 	mov	r4,r2
 823d404:	008209b4 	movhi	r2,2086
 823d408:	10b92204 	addi	r2,r2,-7032
 823d40c:	e0fffc17 	ldw	r3,-16(fp)
 823d410:	18c00524 	muli	r3,r3,20
 823d414:	10c5883a 	add	r2,r2,r3
 823d418:	10800204 	addi	r2,r2,8
 823d41c:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 823d420:	008209b4 	movhi	r2,2086
 823d424:	10b92204 	addi	r2,r2,-7032
 823d428:	e0fffc17 	ldw	r3,-16(fp)
 823d42c:	18c00524 	muli	r3,r3,20
 823d430:	10c5883a 	add	r2,r2,r3
 823d434:	10800204 	addi	r2,r2,8
 823d438:	10c00017 	ldw	r3,0(r2)
 823d43c:	d0a0a817 	ldw	r2,-32096(gp)
 823d440:	1887883a 	add	r3,r3,r2
 823d444:	008209b4 	movhi	r2,2086
 823d448:	10b92204 	addi	r2,r2,-7032
 823d44c:	e13ffc17 	ldw	r4,-16(fp)
 823d450:	21000524 	muli	r4,r4,20
 823d454:	1105883a 	add	r2,r2,r4
 823d458:	10800304 	addi	r2,r2,12
 823d45c:	10c00015 	stw	r3,0(r2)
		 intimers[i].inuse = FALSE;
 823d460:	008209b4 	movhi	r2,2086
 823d464:	10b92204 	addi	r2,r2,-7032
 823d468:	e0fffc17 	ldw	r3,-16(fp)
 823d46c:	18c00524 	muli	r3,r3,20
 823d470:	10c5883a 	add	r2,r2,r3
 823d474:	10800404 	addi	r2,r2,16
 823d478:	10000015 	stw	zero,0(r2)
         numtimers++;
 823d47c:	d0a0be17 	ldw	r2,-32008(gp)
 823d480:	10800044 	addi	r2,r2,1
 823d484:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 823d488:	e0bffc17 	ldw	r2,-16(fp)
 823d48c:	10c00524 	muli	r3,r2,20
 823d490:	008209b4 	movhi	r2,2086
 823d494:	10b92204 	addi	r2,r2,-7032
 823d498:	1885883a 	add	r2,r3,r2
 823d49c:	00000706 	br	823d4bc <in_timerset+0x14c>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d4a0:	e0bffc17 	ldw	r2,-16(fp)
 823d4a4:	10800044 	addi	r2,r2,1
 823d4a8:	e0bffc15 	stw	r2,-16(fp)
 823d4ac:	e0bffc17 	ldw	r2,-16(fp)
 823d4b0:	10800150 	cmplti	r2,r2,5
 823d4b4:	103fb71e 	bne	r2,zero,823d394 <in_timerset+0x24>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 823d4b8:	0005883a 	mov	r2,zero
}
 823d4bc:	e037883a 	mov	sp,fp
 823d4c0:	dfc00117 	ldw	ra,4(sp)
 823d4c4:	df000017 	ldw	fp,0(sp)
 823d4c8:	dec00204 	addi	sp,sp,8
 823d4cc:	f800283a 	ret

0823d4d0 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 823d4d0:	defffc04 	addi	sp,sp,-16
 823d4d4:	dfc00315 	stw	ra,12(sp)
 823d4d8:	df000215 	stw	fp,8(sp)
 823d4dc:	df000204 	addi	fp,sp,8
 823d4e0:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d4e4:	e03ffe15 	stw	zero,-8(fp)
 823d4e8:	00001606 	br	823d544 <in_timerkill+0x74>
   {
      if(timer == (long)&intimers[i])
 823d4ec:	e0bffe17 	ldw	r2,-8(fp)
 823d4f0:	10c00524 	muli	r3,r2,20
 823d4f4:	008209b4 	movhi	r2,2086
 823d4f8:	10b92204 	addi	r2,r2,-7032
 823d4fc:	1885883a 	add	r2,r3,r2
 823d500:	1007883a 	mov	r3,r2
 823d504:	e0bfff17 	ldw	r2,-4(fp)
 823d508:	18800b1e 	bne	r3,r2,823d538 <in_timerkill+0x68>
      {
         intimers[i].callback = NULL;
 823d50c:	008209b4 	movhi	r2,2086
 823d510:	10b92204 	addi	r2,r2,-7032
 823d514:	e0fffe17 	ldw	r3,-8(fp)
 823d518:	18c00524 	muli	r3,r3,20
 823d51c:	10c5883a 	add	r2,r2,r3
 823d520:	10000015 	stw	zero,0(r2)
         numtimers--;
 823d524:	d0a0be17 	ldw	r2,-32008(gp)
 823d528:	10bfffc4 	addi	r2,r2,-1
 823d52c:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 823d530:	0005883a 	mov	r2,zero
 823d534:	00000806 	br	823d558 <in_timerkill+0x88>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d538:	e0bffe17 	ldw	r2,-8(fp)
 823d53c:	10800044 	addi	r2,r2,1
 823d540:	e0bffe15 	stw	r2,-8(fp)
 823d544:	e0bffe17 	ldw	r2,-8(fp)
 823d548:	10800150 	cmplti	r2,r2,5
 823d54c:	103fe71e 	bne	r2,zero,823d4ec <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 823d550:	822d2e00 	call	822d2e0 <dtrap>
   return ENP_PARAM;
 823d554:	00bffd84 	movi	r2,-10
}
 823d558:	e037883a 	mov	sp,fp
 823d55c:	dfc00117 	ldw	ra,4(sp)
 823d560:	df000017 	ldw	fp,0(sp)
 823d564:	dec00204 	addi	sp,sp,8
 823d568:	f800283a 	ret

0823d56c <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 823d56c:	defffe04 	addi	sp,sp,-8
 823d570:	df000115 	stw	fp,4(sp)
 823d574:	df000104 	addi	fp,sp,4
int e = 0;
 823d578:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 823d57c:	e0bfff17 	ldw	r2,-4(fp)
}
 823d580:	e037883a 	mov	sp,fp
 823d584:	df000017 	ldw	fp,0(sp)
 823d588:	dec00104 	addi	sp,sp,4
 823d58c:	f800283a 	ret

0823d590 <task_stats>:
 */


void
task_stats(void * pio)
{
 823d590:	defffd04 	addi	sp,sp,-12
 823d594:	dfc00215 	stw	ra,8(sp)
 823d598:	df000115 	stw	fp,4(sp)
 823d59c:	df000104 	addi	fp,sp,4
 823d5a0:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 823d5a4:	01420974 	movhi	r5,2085
 823d5a8:	29435e04 	addi	r5,r5,3448
 823d5ac:	e13fff17 	ldw	r4,-4(fp)
 823d5b0:	8228bac0 	call	8228bac <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 823d5b4:	d0a08a17 	ldw	r2,-32216(gp)
 823d5b8:	100d883a 	mov	r6,r2
 823d5bc:	01420974 	movhi	r5,2085
 823d5c0:	29436204 	addi	r5,r5,3464
 823d5c4:	e13fff17 	ldw	r4,-4(fp)
 823d5c8:	8228bac0 	call	8228bac <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 823d5cc:	d0a08b17 	ldw	r2,-32212(gp)
 823d5d0:	100d883a 	mov	r6,r2
 823d5d4:	01420974 	movhi	r5,2085
 823d5d8:	29436604 	addi	r5,r5,3480
 823d5dc:	e13fff17 	ldw	r4,-4(fp)
 823d5e0:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 823d5e4:	01420974 	movhi	r5,2085
 823d5e8:	29436a04 	addi	r5,r5,3496
 823d5ec:	e13fff17 	ldw	r4,-4(fp)
 823d5f0:	8228bac0 	call	8228bac <ns_printf>
}
 823d5f4:	0001883a 	nop
 823d5f8:	e037883a 	mov	sp,fp
 823d5fc:	dfc00117 	ldw	ra,4(sp)
 823d600:	df000017 	ldw	fp,0(sp)
 823d604:	dec00204 	addi	sp,sp,8
 823d608:	f800283a 	ret

0823d60c <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 823d60c:	defff804 	addi	sp,sp,-32
 823d610:	dfc00515 	stw	ra,20(sp)
 823d614:	df000415 	stw	fp,16(sp)
 823d618:	df000404 	addi	fp,sp,16
 823d61c:	e13ffe15 	stw	r4,-8(fp)
 823d620:	e17fff15 	stw	r5,-4(fp)
 823d624:	e1800215 	stw	r6,8(fp)
 823d628:	e1c00315 	stw	r7,12(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 823d62c:	e0bffe17 	ldw	r2,-8(fp)
 823d630:	10800808 	cmpgei	r2,r2,32
 823d634:	10000c1e 	bne	r2,zero,823d668 <fcntl+0x5c>
  {
    va_start(argp, cmd);
 823d638:	e0800204 	addi	r2,fp,8
 823d63c:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d640:	e0bffd17 	ldw	r2,-12(fp)
 823d644:	10c00104 	addi	r3,r2,4
 823d648:	e0fffd15 	stw	r3,-12(fp)
 823d64c:	10800017 	ldw	r2,0(r2)
 823d650:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 823d654:	e1bffc17 	ldw	r6,-16(fp)
 823d658:	e17fff17 	ldw	r5,-4(fp)
 823d65c:	e13ffe17 	ldw	r4,-8(fp)
 823d660:	8249ea80 	call	8249ea8 <alt_fcntl>
 823d664:	00000c06 	br	823d698 <fcntl+0x8c>
  }
  else
  {
    va_start(argp, cmd);
 823d668:	e0800204 	addi	r2,fp,8
 823d66c:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d670:	e0bffd17 	ldw	r2,-12(fp)
 823d674:	10c00104 	addi	r3,r2,4
 823d678:	e0fffd15 	stw	r3,-12(fp)
 823d67c:	10800017 	ldw	r2,0(r2)
 823d680:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 823d684:	e0bfff17 	ldw	r2,-4(fp)
 823d688:	e1bffc17 	ldw	r6,-16(fp)
 823d68c:	100b883a 	mov	r5,r2
 823d690:	e13ffe17 	ldw	r4,-8(fp)
 823d694:	8227f880 	call	8227f88 <bsd_ioctl>
  }
}
 823d698:	e037883a 	mov	sp,fp
 823d69c:	dfc00117 	ldw	ra,4(sp)
 823d6a0:	df000017 	ldw	fp,0(sp)
 823d6a4:	dec00404 	addi	sp,sp,16
 823d6a8:	f800283a 	ret

0823d6ac <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 823d6ac:	defffe04 	addi	sp,sp,-8
 823d6b0:	dfc00115 	stw	ra,4(sp)
 823d6b4:	df000015 	stw	fp,0(sp)
 823d6b8:	d839883a 	mov	fp,sp
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 823d6bc:	01018204 	movi	r4,1544
 823d6c0:	823ebd80 	call	823ebd8 <reg_type>
 823d6c4:	10000526 	beq	r2,zero,823d6dc <etainit+0x30>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 823d6c8:	01020974 	movhi	r4,2085
 823d6cc:	21036b04 	addi	r4,r4,3500
 823d6d0:	82033700 	call	8203370 <puts>
#endif
      return (1);
 823d6d4:	00800044 	movi	r2,1
 823d6d8:	00000106 	br	823d6e0 <etainit+0x34>
   }
   return (0);
 823d6dc:	0005883a 	mov	r2,zero
}
 823d6e0:	e037883a 	mov	sp,fp
 823d6e4:	dfc00117 	ldw	ra,4(sp)
 823d6e8:	df000017 	ldw	fp,0(sp)
 823d6ec:	dec00204 	addi	sp,sp,8
 823d6f0:	f800283a 	ret

0823d6f4 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 823d6f4:	defff904 	addi	sp,sp,-28
 823d6f8:	dfc00615 	stw	ra,24(sp)
 823d6fc:	df000515 	stw	fp,20(sp)
 823d700:	df000504 	addi	fp,sp,20
 823d704:	e13ffe15 	stw	r4,-8(fp)
 823d708:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823d70c:	e0bffe17 	ldw	r2,-8(fp)
 823d710:	10800617 	ldw	r2,24(r2)
 823d714:	10802717 	ldw	r2,156(r2)
 823d718:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 823d71c:	d0e0a817 	ldw	r3,-32096(gp)
 823d720:	e0bfff17 	ldw	r2,-4(fp)
 823d724:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 823d728:	e0bffe17 	ldw	r2,-8(fp)
 823d72c:	10800317 	ldw	r2,12(r2)
 823d730:	10fffc04 	addi	r3,r2,-16
 823d734:	e0bffe17 	ldw	r2,-8(fp)
 823d738:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 823d73c:	e0bffe17 	ldw	r2,-8(fp)
 823d740:	10800417 	ldw	r2,16(r2)
 823d744:	10c00404 	addi	r3,r2,16
 823d748:	e0bffe17 	ldw	r2,-8(fp)
 823d74c:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 823d750:	e0bffe17 	ldw	r2,-8(fp)
 823d754:	10800317 	ldw	r2,12(r2)
 823d758:	10800084 	addi	r2,r2,2
 823d75c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 823d760:	e0bffe17 	ldw	r2,-8(fp)
 823d764:	10800117 	ldw	r2,4(r2)
 823d768:	e0fffd17 	ldw	r3,-12(fp)
 823d76c:	1880032e 	bgeu	r3,r2,823d77c <et_send+0x88>
      panic("et_send: prepend");
 823d770:	01020974 	movhi	r4,2085
 823d774:	21037704 	addi	r4,r4,3548
 823d778:	82289940 	call	8228994 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 823d77c:	e0bfff17 	ldw	r2,-4(fp)
 823d780:	10800104 	addi	r2,r2,4
 823d784:	01800184 	movi	r6,6
 823d788:	100b883a 	mov	r5,r2
 823d78c:	e13ffd17 	ldw	r4,-12(fp)
 823d790:	8202da40 	call	8202da4 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 823d794:	e0bffd17 	ldw	r2,-12(fp)
 823d798:	10c00184 	addi	r3,r2,6
 823d79c:	e0bffc17 	ldw	r2,-16(fp)
 823d7a0:	10800517 	ldw	r2,20(r2)
 823d7a4:	01800184 	movi	r6,6
 823d7a8:	100b883a 	mov	r5,r2
 823d7ac:	1809883a 	mov	r4,r3
 823d7b0:	8202da40 	call	8202da4 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 823d7b4:	e0bfff17 	ldw	r2,-4(fp)
 823d7b8:	1080070b 	ldhu	r2,28(r2)
 823d7bc:	10bfffcc 	andi	r2,r2,65535
 823d7c0:	108000cc 	andi	r2,r2,3
 823d7c4:	108000a0 	cmpeqi	r2,r2,2
 823d7c8:	1000041e 	bne	r2,zero,823d7dc <et_send+0xe8>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 823d7cc:	e0bffd17 	ldw	r2,-12(fp)
 823d7d0:	10800304 	addi	r2,r2,12
 823d7d4:	00c00204 	movi	r3,8
 823d7d8:	10c00005 	stb	r3,0(r2)
 823d7dc:	e0bffd17 	ldw	r2,-12(fp)
 823d7e0:	10800344 	addi	r2,r2,13
 823d7e4:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 823d7e8:	e0bffe17 	ldw	r2,-8(fp)
 823d7ec:	10800617 	ldw	r2,24(r2)
 823d7f0:	10800417 	ldw	r2,16(r2)
 823d7f4:	10000726 	beq	r2,zero,823d814 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 823d7f8:	e0bffe17 	ldw	r2,-8(fp)
 823d7fc:	10800617 	ldw	r2,24(r2)
 823d800:	10800417 	ldw	r2,16(r2)
 823d804:	e13ffe17 	ldw	r4,-8(fp)
 823d808:	103ee83a 	callr	r2
 823d80c:	e0bffb15 	stw	r2,-20(fp)
 823d810:	00001206 	br	823d85c <et_send+0x168>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 823d814:	e0bffe17 	ldw	r2,-8(fp)
 823d818:	10800617 	ldw	r2,24(r2)
 823d81c:	10800317 	ldw	r2,12(r2)
 823d820:	e0fffe17 	ldw	r3,-8(fp)
 823d824:	19000617 	ldw	r4,24(r3)
 823d828:	e0fffe17 	ldw	r3,-8(fp)
 823d82c:	19400317 	ldw	r5,12(r3)
 823d830:	e0fffe17 	ldw	r3,-8(fp)
 823d834:	18c00417 	ldw	r3,16(r3)
 823d838:	180d883a 	mov	r6,r3
 823d83c:	103ee83a 	callr	r2
 823d840:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823d844:	01000084 	movi	r4,2
 823d848:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823d84c:	e13ffe17 	ldw	r4,-8(fp)
 823d850:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823d854:	01000084 	movi	r4,2
 823d858:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 823d85c:	e0bffb17 	ldw	r2,-20(fp)
}
 823d860:	e037883a 	mov	sp,fp
 823d864:	dfc00117 	ldw	ra,4(sp)
 823d868:	df000017 	ldw	fp,0(sp)
 823d86c:	dec00204 	addi	sp,sp,8
 823d870:	f800283a 	ret

0823d874 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 823d874:	defffb04 	addi	sp,sp,-20
 823d878:	dfc00415 	stw	ra,16(sp)
 823d87c:	df000315 	stw	fp,12(sp)
 823d880:	df000304 	addi	fp,sp,12
 823d884:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 823d888:	e0bfff17 	ldw	r2,-4(fp)
 823d88c:	10800417 	ldw	r2,16(r2)
 823d890:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;
 823d894:	e0bfff17 	ldw	r2,-4(fp)
 823d898:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823d89c:	01000084 	movi	r4,2
 823d8a0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 823d8a4:	00000906 	br	823d8cc <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 823d8a8:	e0bffd17 	ldw	r2,-12(fp)
 823d8ac:	10800017 	ldw	r2,0(r2)
 823d8b0:	e0bffe15 	stw	r2,-8(fp)
      tmppkt->next = (PACKET)NULL;
 823d8b4:	e0bffd17 	ldw	r2,-12(fp)
 823d8b8:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 823d8bc:	e13ffd17 	ldw	r4,-12(fp)
 823d8c0:	822ca880 	call	822ca88 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 823d8c4:	e0bffe17 	ldw	r2,-8(fp)
 823d8c8:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 823d8cc:	e0bffd17 	ldw	r2,-12(fp)
 823d8d0:	103ff51e 	bne	r2,zero,823d8a8 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 823d8d4:	e0bfff17 	ldw	r2,-4(fp)
 823d8d8:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823d8dc:	01000084 	movi	r4,2
 823d8e0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
}
 823d8e4:	0001883a 	nop
 823d8e8:	e037883a 	mov	sp,fp
 823d8ec:	dfc00117 	ldw	ra,4(sp)
 823d8f0:	df000017 	ldw	fp,0(sp)
 823d8f4:	dec00204 	addi	sp,sp,8
 823d8f8:	f800283a 	ret

0823d8fc <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 823d8fc:	defffc04 	addi	sp,sp,-16
 823d900:	dfc00315 	stw	ra,12(sp)
 823d904:	df000215 	stw	fp,8(sp)
 823d908:	df000204 	addi	fp,sp,8
 823d90c:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 823d910:	e0bfff17 	ldw	r2,-4(fp)
 823d914:	10800417 	ldw	r2,16(r2)
 823d918:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823d91c:	00000906 	br	823d944 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 823d920:	e0bffe17 	ldw	r2,-8(fp)
 823d924:	10c00017 	ldw	r3,0(r2)
 823d928:	e0bfff17 	ldw	r2,-4(fp)
 823d92c:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 823d930:	e0bffe17 	ldw	r2,-8(fp)
 823d934:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 823d938:	e17fff17 	ldw	r5,-4(fp)
 823d93c:	e13ffe17 	ldw	r4,-8(fp)
 823d940:	823d6f40 	call	823d6f4 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823d944:	e0bfff17 	ldw	r2,-4(fp)
 823d948:	10800417 	ldw	r2,16(r2)
 823d94c:	e0bffe15 	stw	r2,-8(fp)
 823d950:	e0bffe17 	ldw	r2,-8(fp)
 823d954:	103ff21e 	bne	r2,zero,823d920 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 823d958:	0001883a 	nop
 823d95c:	e037883a 	mov	sp,fp
 823d960:	dfc00117 	ldw	ra,4(sp)
 823d964:	df000017 	ldw	fp,0(sp)
 823d968:	dec00204 	addi	sp,sp,8
 823d96c:	f800283a 	ret

0823d970 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 823d970:	defff404 	addi	sp,sp,-48
 823d974:	dfc00b15 	stw	ra,44(sp)
 823d978:	df000a15 	stw	fp,40(sp)
 823d97c:	df000a04 	addi	fp,sp,40
 823d980:	e13ffe15 	stw	r4,-8(fp)
 823d984:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 823d988:	e0bffe17 	ldw	r2,-8(fp)
 823d98c:	10800617 	ldw	r2,24(r2)
 823d990:	e0bff615 	stw	r2,-40(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823d994:	e0bffe17 	ldw	r2,-8(fp)
 823d998:	10800617 	ldw	r2,24(r2)
 823d99c:	10802717 	ldw	r2,156(r2)
 823d9a0:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823d9a4:	e0bfff17 	ldw	r2,-4(fp)
 823d9a8:	10bfffe0 	cmpeqi	r2,r2,-1
 823d9ac:	1000191e 	bne	r2,zero,823da14 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
 823d9b0:	e0bff617 	ldw	r2,-40(fp)
 823d9b4:	10800c17 	ldw	r2,48(r2)
 823d9b8:	0086303a 	nor	r3,zero,r2
 823d9bc:	e0bfff17 	ldw	r2,-4(fp)
 823d9c0:	1886703a 	and	r3,r3,r2
 823d9c4:	e0bff617 	ldw	r2,-40(fp)
 823d9c8:	10800c17 	ldw	r2,48(r2)
 823d9cc:	0084303a 	nor	r2,zero,r2
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823d9d0:	18801026 	beq	r3,r2,823da14 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
       || (IN_MULTICAST(ntohl(dest_ip)) ))
 823d9d4:	e0bfff17 	ldw	r2,-4(fp)
 823d9d8:	1006d63a 	srli	r3,r2,24
 823d9dc:	e0bfff17 	ldw	r2,-4(fp)
 823d9e0:	1004d23a 	srli	r2,r2,8
 823d9e4:	10bfc00c 	andi	r2,r2,65280
 823d9e8:	1886b03a 	or	r3,r3,r2
 823d9ec:	e0bfff17 	ldw	r2,-4(fp)
 823d9f0:	10bfc00c 	andi	r2,r2,65280
 823d9f4:	1004923a 	slli	r2,r2,8
 823d9f8:	1886b03a 	or	r3,r3,r2
 823d9fc:	e0bfff17 	ldw	r2,-4(fp)
 823da00:	1004963a 	slli	r2,r2,24
 823da04:	1884b03a 	or	r2,r3,r2
 823da08:	10fc002c 	andhi	r3,r2,61440
 823da0c:	00b80034 	movhi	r2,57344
 823da10:	1880391e 	bne	r3,r2,823daf8 <send_arp+0x188>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 823da14:	e0bffe17 	ldw	r2,-8(fp)
 823da18:	10800617 	ldw	r2,24(r2)
 823da1c:	100b883a 	mov	r5,r2
 823da20:	e13fff17 	ldw	r4,-4(fp)
 823da24:	823df300 	call	823df30 <make_arp_entry>
 823da28:	e0bff915 	stw	r2,-28(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 823da2c:	e0bff917 	ldw	r2,-28(fp)
 823da30:	10800104 	addi	r2,r2,4
 823da34:	01800184 	movi	r6,6
 823da38:	01403fc4 	movi	r5,255
 823da3c:	1009883a 	mov	r4,r2
 823da40:	8202f000 	call	8202f00 <memset>
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 823da44:	e0bffe17 	ldw	r2,-8(fp)
 823da48:	10800617 	ldw	r2,24(r2)
 823da4c:	10802b17 	ldw	r2,172(r2)
 823da50:	10002526 	beq	r2,zero,823dae8 <send_arp+0x178>
 823da54:	e0bfff17 	ldw	r2,-4(fp)
 823da58:	1006d63a 	srli	r3,r2,24
 823da5c:	e0bfff17 	ldw	r2,-4(fp)
 823da60:	1004d23a 	srli	r2,r2,8
 823da64:	10bfc00c 	andi	r2,r2,65280
 823da68:	1886b03a 	or	r3,r3,r2
 823da6c:	e0bfff17 	ldw	r2,-4(fp)
 823da70:	10bfc00c 	andi	r2,r2,65280
 823da74:	1004923a 	slli	r2,r2,8
 823da78:	1886b03a 	or	r3,r3,r2
 823da7c:	e0bfff17 	ldw	r2,-4(fp)
 823da80:	1004963a 	slli	r2,r2,24
 823da84:	1884b03a 	or	r2,r3,r2
 823da88:	10fc002c 	andhi	r3,r2,61440
 823da8c:	00b80034 	movhi	r2,57344
 823da90:	1880151e 	bne	r3,r2,823dae8 <send_arp+0x178>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 823da94:	e0bfff17 	ldw	r2,-4(fp)
 823da98:	e0bffd15 	stw	r2,-12(fp)
         oldest->t_phy_addr[0] = 0x01;
 823da9c:	e0bff917 	ldw	r2,-28(fp)
 823daa0:	00c00044 	movi	r3,1
 823daa4:	10c00105 	stb	r3,4(r2)
         oldest->t_phy_addr[1] = 0x00;
 823daa8:	e0bff917 	ldw	r2,-28(fp)
 823daac:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 823dab0:	e0bff917 	ldw	r2,-28(fp)
 823dab4:	00c01784 	movi	r3,94
 823dab8:	10c00185 	stb	r3,6(r2)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 823dabc:	e0bffd43 	ldbu	r2,-11(fp)
 823dac0:	10801fcc 	andi	r2,r2,127
 823dac4:	1007883a 	mov	r3,r2
 823dac8:	e0bff917 	ldw	r2,-28(fp)
 823dacc:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 823dad0:	e0fffd83 	ldbu	r3,-10(fp)
 823dad4:	e0bff917 	ldw	r2,-28(fp)
 823dad8:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 823dadc:	e0fffdc3 	ldbu	r3,-9(fp)
 823dae0:	e0bff917 	ldw	r2,-28(fp)
 823dae4:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 823dae8:	e17ff917 	ldw	r5,-28(fp)
 823daec:	e13ffe17 	ldw	r4,-8(fp)
 823daf0:	823d6f40 	call	823d6f4 <et_send>
 823daf4:	0000ae06 	br	823ddb0 <send_arp+0x440>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823daf8:	e0bffe17 	ldw	r2,-8(fp)
 823dafc:	10c00717 	ldw	r3,28(r2)
 823db00:	e0bffe17 	ldw	r2,-8(fp)
 823db04:	10800617 	ldw	r2,24(r2)
 823db08:	10800a17 	ldw	r2,40(r2)
 823db0c:	18800d1e 	bne	r3,r2,823db44 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
 823db10:	e0bffe17 	ldw	r2,-8(fp)
 823db14:	10800717 	ldw	r2,28(r2)
 823db18:	10803fcc 	andi	r2,r2,255

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823db1c:	10801fe0 	cmpeqi	r2,r2,127
 823db20:	1000081e 	bne	r2,zero,823db44 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823db24:	01000084 	movi	r4,2
 823db28:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823db2c:	e13ffe17 	ldw	r4,-8(fp)
 823db30:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823db34:	01000084 	movi	r4,2
 823db38:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 823db3c:	00bff7c4 	movi	r2,-33
 823db40:	00009b06 	br	823ddb0 <send_arp+0x440>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823db44:	01000084 	movi	r4,2
 823db48:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823db4c:	01000c04 	movi	r4,48
 823db50:	822c7380 	call	822c738 <pk_alloc>
 823db54:	e0bff815 	stw	r2,-32(fp)
   if (!arppkt)
 823db58:	e0bff817 	ldw	r2,-32(fp)
 823db5c:	1000061e 	bne	r2,zero,823db78 <send_arp+0x208>
   {
      pk_free(pkt);
 823db60:	e13ffe17 	ldw	r4,-8(fp)
 823db64:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823db68:	01000084 	movi	r4,2
 823db6c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823db70:	00bffa84 	movi	r2,-22
 823db74:	00008e06 	br	823ddb0 <send_arp+0x440>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823db78:	01000084 	movi	r4,2
 823db7c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823db80:	e0bff817 	ldw	r2,-32(fp)
 823db84:	10c00117 	ldw	r3,4(r2)
 823db88:	e0bff817 	ldw	r2,-32(fp)
 823db8c:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823db90:	e0bff817 	ldw	r2,-32(fp)
 823db94:	00c00c04 	movi	r3,48
 823db98:	10c00415 	stw	r3,16(r2)
   arppkt->net = pkt->net;
 823db9c:	e0bffe17 	ldw	r2,-8(fp)
 823dba0:	10c00617 	ldw	r3,24(r2)
 823dba4:	e0bff817 	ldw	r2,-32(fp)
 823dba8:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 823dbac:	e0bffe17 	ldw	r2,-8(fp)
 823dbb0:	10800617 	ldw	r2,24(r2)
 823dbb4:	100b883a 	mov	r5,r2
 823dbb8:	e13fff17 	ldw	r4,-4(fp)
 823dbbc:	823df300 	call	823df30 <make_arp_entry>
 823dbc0:	e0bff915 	stw	r2,-28(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 823dbc4:	e0bff917 	ldw	r2,-28(fp)
 823dbc8:	e0fffe17 	ldw	r3,-8(fp)
 823dbcc:	10c00415 	stw	r3,16(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823dbd0:	e0bff817 	ldw	r2,-32(fp)
 823dbd4:	10800117 	ldw	r2,4(r2)
 823dbd8:	10800084 	addi	r2,r2,2
 823dbdc:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823dbe0:	e0bff817 	ldw	r2,-32(fp)
 823dbe4:	10800117 	ldw	r2,4(r2)
 823dbe8:	10800404 	addi	r2,r2,16
 823dbec:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823dbf0:	e0bffb17 	ldw	r2,-20(fp)
 823dbf4:	00c04004 	movi	r3,256
 823dbf8:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823dbfc:	e0bffb17 	ldw	r2,-20(fp)
 823dc00:	00c00204 	movi	r3,8
 823dc04:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823dc08:	e0bffb17 	ldw	r2,-20(fp)
 823dc0c:	00c00184 	movi	r3,6
 823dc10:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823dc14:	e0bffb17 	ldw	r2,-20(fp)
 823dc18:	00c00104 	movi	r3,4
 823dc1c:	10c00145 	stb	r3,5(r2)
   arphdr->ar_op = ARREQ;
 823dc20:	e0bffb17 	ldw	r2,-20(fp)
 823dc24:	00c04004 	movi	r3,256
 823dc28:	10c0018d 	sth	r3,6(r2)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 823dc2c:	e0bffb17 	ldw	r2,-20(fp)
 823dc30:	e0ffff17 	ldw	r3,-4(fp)
 823dc34:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 823dc38:	e0bffe17 	ldw	r2,-8(fp)
 823dc3c:	10800617 	ldw	r2,24(r2)
 823dc40:	10c00a17 	ldw	r3,40(r2)
 823dc44:	e0bffb17 	ldw	r2,-20(fp)
 823dc48:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823dc4c:	e0bffb17 	ldw	r2,-20(fp)
 823dc50:	10c00204 	addi	r3,r2,8
 823dc54:	e0bff717 	ldw	r2,-36(fp)
 823dc58:	10800517 	ldw	r2,20(r2)
 823dc5c:	01800184 	movi	r6,6
 823dc60:	100b883a 	mov	r5,r2
 823dc64:	1809883a 	mov	r4,r3
 823dc68:	8202da40 	call	8202da4 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823dc6c:	01800184 	movi	r6,6
 823dc70:	01403fc4 	movi	r5,255
 823dc74:	e13ffa17 	ldw	r4,-24(fp)
 823dc78:	8202f000 	call	8202f00 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823dc7c:	e0bffa17 	ldw	r2,-24(fp)
 823dc80:	10c00184 	addi	r3,r2,6
 823dc84:	e0bff717 	ldw	r2,-36(fp)
 823dc88:	10800517 	ldw	r2,20(r2)
 823dc8c:	01800184 	movi	r6,6
 823dc90:	100b883a 	mov	r5,r2
 823dc94:	1809883a 	mov	r4,r3
 823dc98:	8202da40 	call	8202da4 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823dc9c:	e0bffa17 	ldw	r2,-24(fp)
 823dca0:	10800304 	addi	r2,r2,12
 823dca4:	00c00204 	movi	r3,8
 823dca8:	10c00005 	stb	r3,0(r2)
 823dcac:	e0bffa17 	ldw	r2,-24(fp)
 823dcb0:	10800344 	addi	r2,r2,13
 823dcb4:	00c00184 	movi	r3,6
 823dcb8:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823dcbc:	e0bffb17 	ldw	r2,-20(fp)
 823dcc0:	e0bffc15 	stw	r2,-16(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823dcc4:	e0bffc17 	ldw	r2,-16(fp)
 823dcc8:	10c00204 	addi	r3,r2,8
 823dccc:	e0bffb17 	ldw	r2,-20(fp)
 823dcd0:	10800204 	addi	r2,r2,8
 823dcd4:	01800184 	movi	r6,6
 823dcd8:	100b883a 	mov	r5,r2
 823dcdc:	1809883a 	mov	r4,r3
 823dce0:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823dce4:	e0bffc17 	ldw	r2,-16(fp)
 823dce8:	10c00384 	addi	r3,r2,14
 823dcec:	e0bffb17 	ldw	r2,-20(fp)
 823dcf0:	10800404 	addi	r2,r2,16
 823dcf4:	01800104 	movi	r6,4
 823dcf8:	100b883a 	mov	r5,r2
 823dcfc:	1809883a 	mov	r4,r3
 823dd00:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823dd04:	e0bffc17 	ldw	r2,-16(fp)
 823dd08:	10c00484 	addi	r3,r2,18
 823dd0c:	e0bffb17 	ldw	r2,-20(fp)
 823dd10:	10800504 	addi	r2,r2,20
 823dd14:	01800184 	movi	r6,6
 823dd18:	100b883a 	mov	r5,r2
 823dd1c:	1809883a 	mov	r4,r3
 823dd20:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823dd24:	e0bffc17 	ldw	r2,-16(fp)
 823dd28:	10c00604 	addi	r3,r2,24
 823dd2c:	e0bffb17 	ldw	r2,-20(fp)
 823dd30:	10800704 	addi	r2,r2,28
 823dd34:	01800104 	movi	r6,4
 823dd38:	100b883a 	mov	r5,r2
 823dd3c:	1809883a 	mov	r4,r3
 823dd40:	8202da40 	call	8202da4 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823dd44:	e0bff617 	ldw	r2,-40(fp)
 823dd48:	10800417 	ldw	r2,16(r2)
 823dd4c:	10000526 	beq	r2,zero,823dd64 <send_arp+0x3f4>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823dd50:	e0bff617 	ldw	r2,-40(fp)
 823dd54:	10800417 	ldw	r2,16(r2)
 823dd58:	e13ff817 	ldw	r4,-32(fp)
 823dd5c:	103ee83a 	callr	r2
 823dd60:	00000f06 	br	823dda0 <send_arp+0x430>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823dd64:	e0bff617 	ldw	r2,-40(fp)
 823dd68:	10800317 	ldw	r2,12(r2)
 823dd6c:	e0fff817 	ldw	r3,-32(fp)
 823dd70:	19000617 	ldw	r4,24(r3)
 823dd74:	e0fff817 	ldw	r3,-32(fp)
 823dd78:	18c00117 	ldw	r3,4(r3)
 823dd7c:	01800c04 	movi	r6,48
 823dd80:	180b883a 	mov	r5,r3
 823dd84:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823dd88:	01000084 	movi	r4,2
 823dd8c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823dd90:	e13ff817 	ldw	r4,-32(fp)
 823dd94:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dd98:	01000084 	movi	r4,2
 823dd9c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823dda0:	d0a0c317 	ldw	r2,-31988(gp)
 823dda4:	10800044 	addi	r2,r2,1
 823dda8:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823ddac:	00800044 	movi	r2,1
}
 823ddb0:	e037883a 	mov	sp,fp
 823ddb4:	dfc00117 	ldw	ra,4(sp)
 823ddb8:	df000017 	ldw	fp,0(sp)
 823ddbc:	dec00204 	addi	sp,sp,8
 823ddc0:	f800283a 	ret

0823ddc4 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 823ddc4:	defff804 	addi	sp,sp,-32
 823ddc8:	dfc00715 	stw	ra,28(sp)
 823ddcc:	df000615 	stw	fp,24(sp)
 823ddd0:	df000604 	addi	fp,sp,24
 823ddd4:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 823ddd8:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 823dddc:	e03ffc15 	stw	zero,-16(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 823dde0:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823dde4:	d0a0a817 	ldw	r2,-32096(gp)
 823dde8:	e0bffe15 	stw	r2,-8(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823ddec:	008209b4 	movhi	r2,2086
 823ddf0:	10b93b04 	addi	r2,r2,-6932
 823ddf4:	e0bffa15 	stw	r2,-24(fp)
 823ddf8:	00003b06 	br	823dee8 <find_oldest_arp+0x124>
   {
      /* age out old, pending entries */
      if (tp->pending)
 823ddfc:	e0bffa17 	ldw	r2,-24(fp)
 823de00:	10800417 	ldw	r2,16(r2)
 823de04:	10000b26 	beq	r2,zero,823de34 <find_oldest_arp+0x70>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 823de08:	e0bffa17 	ldw	r2,-24(fp)
 823de0c:	10800517 	ldw	r2,20(r2)
 823de10:	e0fffe17 	ldw	r3,-8(fp)
 823de14:	1885c83a 	sub	r2,r3,r2
 823de18:	10801970 	cmpltui	r2,r2,101
 823de1c:	1000171e 	bne	r2,zero,823de7c <find_oldest_arp+0xb8>
         {
            arp_free_pending(tp);   /* free pending packets */
 823de20:	e13ffa17 	ldw	r4,-24(fp)
 823de24:	823d8740 	call	823d874 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823de28:	e0bffa17 	ldw	r2,-24(fp)
 823de2c:	10000015 	stw	zero,0(r2)
 823de30:	00001206 	br	823de7c <find_oldest_arp+0xb8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823de34:	e0bffa17 	ldw	r2,-24(fp)
 823de38:	10800017 	ldw	r2,0(r2)
 823de3c:	10000f26 	beq	r2,zero,823de7c <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823de40:	e0bffa17 	ldw	r2,-24(fp)
 823de44:	10800517 	ldw	r2,20(r2)
 823de48:	e0fffe17 	ldw	r3,-8(fp)
 823de4c:	1885c83a 	sub	r2,r3,r2
 823de50:	1007883a 	mov	r3,r2
 823de54:	d0a04f17 	ldw	r2,-32452(gp)
         {
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823de58:	18800816 	blt	r3,r2,823de7c <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
 823de5c:	e0bffa17 	ldw	r2,-24(fp)
 823de60:	10800617 	ldw	r2,24(r2)
 823de64:	e0fffe17 	ldw	r3,-8(fp)
 823de68:	1885c83a 	sub	r2,r3,r2
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823de6c:	10801910 	cmplti	r2,r2,100
 823de70:	1000021e 	bne	r2,zero,823de7c <find_oldest_arp+0xb8>
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823de74:	e0bffa17 	ldw	r2,-24(fp)
 823de78:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 823de7c:	e0bffa17 	ldw	r2,-24(fp)
 823de80:	10c00017 	ldw	r3,0(r2)
 823de84:	e0bfff17 	ldw	r2,-4(fp)
 823de88:	1880031e 	bne	r3,r2,823de98 <find_oldest_arp+0xd4>
      {
         exact = tp;
 823de8c:	e0bffa17 	ldw	r2,-24(fp)
 823de90:	e0bffb15 	stw	r2,-20(fp)
 823de94:	00001106 	br	823dedc <find_oldest_arp+0x118>
      }
      else if (tp->t_pro_addr != 0)
 823de98:	e0bffa17 	ldw	r2,-24(fp)
 823de9c:	10800017 	ldw	r2,0(r2)
 823dea0:	10000a26 	beq	r2,zero,823decc <find_oldest_arp+0x108>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 823dea4:	e0bffc17 	ldw	r2,-16(fp)
 823dea8:	10000526 	beq	r2,zero,823dec0 <find_oldest_arp+0xfc>
 823deac:	e0bffa17 	ldw	r2,-24(fp)
 823deb0:	10c00617 	ldw	r3,24(r2)
 823deb4:	e0bffc17 	ldw	r2,-16(fp)
 823deb8:	10800617 	ldw	r2,24(r2)
 823debc:	1880072e 	bgeu	r3,r2,823dedc <find_oldest_arp+0x118>
            oldest = tp;
 823dec0:	e0bffa17 	ldw	r2,-24(fp)
 823dec4:	e0bffc15 	stw	r2,-16(fp)
 823dec8:	00000406 	br	823dedc <find_oldest_arp+0x118>
      }
      else if (!empty)
 823decc:	e0bffd17 	ldw	r2,-12(fp)
 823ded0:	1000021e 	bne	r2,zero,823dedc <find_oldest_arp+0x118>
         empty = tp;          /* grab first empty slot */
 823ded4:	e0bffa17 	ldw	r2,-24(fp)
 823ded8:	e0bffd15 	stw	r2,-12(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823dedc:	e0bffa17 	ldw	r2,-24(fp)
 823dee0:	10800804 	addi	r2,r2,32
 823dee4:	e0bffa15 	stw	r2,-24(fp)
 823dee8:	e0fffa17 	ldw	r3,-24(fp)
 823deec:	008209b4 	movhi	r2,2086
 823def0:	10b97b04 	addi	r2,r2,-6676
 823def4:	18bfc136 	bltu	r3,r2,823ddfc <find_oldest_arp+0x38>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 823def8:	e0bffb17 	ldw	r2,-20(fp)
 823defc:	1000061e 	bne	r2,zero,823df18 <find_oldest_arp+0x154>
 823df00:	e0bffd17 	ldw	r2,-12(fp)
 823df04:	10000226 	beq	r2,zero,823df10 <find_oldest_arp+0x14c>
 823df08:	e0bffd17 	ldw	r2,-12(fp)
 823df0c:	00000306 	br	823df1c <find_oldest_arp+0x158>
 823df10:	e0bffc17 	ldw	r2,-16(fp)
 823df14:	00000106 	br	823df1c <find_oldest_arp+0x158>
 823df18:	e0bffb17 	ldw	r2,-20(fp)
}
 823df1c:	e037883a 	mov	sp,fp
 823df20:	dfc00117 	ldw	ra,4(sp)
 823df24:	df000017 	ldw	fp,0(sp)
 823df28:	dec00204 	addi	sp,sp,8
 823df2c:	f800283a 	ret

0823df30 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 823df30:	defffa04 	addi	sp,sp,-24
 823df34:	dfc00515 	stw	ra,20(sp)
 823df38:	df000415 	stw	fp,16(sp)
 823df3c:	df000404 	addi	fp,sp,16
 823df40:	e13ffe15 	stw	r4,-8(fp)
 823df44:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 823df48:	d0a0a817 	ldw	r2,-32096(gp)
 823df4c:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 823df50:	e13ffe17 	ldw	r4,-8(fp)
 823df54:	823ddc40 	call	823ddc4 <find_oldest_arp>
 823df58:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 823df5c:	e0bffd17 	ldw	r2,-12(fp)
 823df60:	10800417 	ldw	r2,16(r2)
 823df64:	10000626 	beq	r2,zero,823df80 <make_arp_entry+0x50>
 823df68:	e0bffd17 	ldw	r2,-12(fp)
 823df6c:	10c00017 	ldw	r3,0(r2)
 823df70:	e0bffe17 	ldw	r2,-8(fp)
 823df74:	18800226 	beq	r3,r2,823df80 <make_arp_entry+0x50>
   {
      arp_free_pending(oldest);
 823df78:	e13ffd17 	ldw	r4,-12(fp)
 823df7c:	823d8740 	call	823d874 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 823df80:	e0bffd17 	ldw	r2,-12(fp)
 823df84:	e0fffe17 	ldw	r3,-8(fp)
 823df88:	10c00015 	stw	r3,0(r2)
   oldest->net = net;
 823df8c:	e0bffd17 	ldw	r2,-12(fp)
 823df90:	e0ffff17 	ldw	r3,-4(fp)
 823df94:	10c00315 	stw	r3,12(r2)
   oldest->flags = 0;
 823df98:	e0bffd17 	ldw	r2,-12(fp)
 823df9c:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 823dfa0:	e0bffd17 	ldw	r2,-12(fp)
 823dfa4:	10800104 	addi	r2,r2,4
 823dfa8:	01800184 	movi	r6,6
 823dfac:	000b883a 	mov	r5,zero
 823dfb0:	1009883a 	mov	r4,r2
 823dfb4:	8202f000 	call	8202f00 <memset>
   oldest->createtime = oldest->lasttime = lticks;
 823dfb8:	e0bffd17 	ldw	r2,-12(fp)
 823dfbc:	e0fffc17 	ldw	r3,-16(fp)
 823dfc0:	10c00615 	stw	r3,24(r2)
 823dfc4:	e0bffd17 	ldw	r2,-12(fp)
 823dfc8:	10c00617 	ldw	r3,24(r2)
 823dfcc:	e0bffd17 	ldw	r2,-12(fp)
 823dfd0:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 823dfd4:	d0a0bf17 	ldw	r2,-32004(gp)
 823dfd8:	1000071e 	bne	r2,zero,823dff8 <make_arp_entry+0xc8>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 823dfdc:	000d883a 	mov	r6,zero
 823dfe0:	0149c404 	movi	r5,10000
 823dfe4:	01020934 	movhi	r4,2084
 823dfe8:	2139b404 	addi	r4,r4,-6448
 823dfec:	823d3700 	call	823d370 <in_timerset>
 823dff0:	d0a0bf15 	stw	r2,-32004(gp)
 823dff4:	00000706 	br	823e014 <make_arp_entry+0xe4>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823dff8:	d0a0bf17 	ldw	r2,-32004(gp)
 823dffc:	1009883a 	mov	r4,r2
              ((struct intimer *)arp_timer)->interval + lticks;
 823e000:	d0a0bf17 	ldw	r2,-32004(gp)
 823e004:	10c00217 	ldw	r3,8(r2)
 823e008:	e0bffc17 	ldw	r2,-16(fp)
 823e00c:	1885883a 	add	r2,r3,r2
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e010:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 823e014:	e0bffd17 	ldw	r2,-12(fp)
}
 823e018:	e037883a 	mov	sp,fp
 823e01c:	dfc00117 	ldw	ra,4(sp)
 823e020:	df000017 	ldw	fp,0(sp)
 823e024:	dec00204 	addi	sp,sp,8
 823e028:	f800283a 	ret

0823e02c <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 823e02c:	defff704 	addi	sp,sp,-36
 823e030:	dfc00815 	stw	ra,32(sp)
 823e034:	df000715 	stw	fp,28(sp)
 823e038:	df000704 	addi	fp,sp,28
 823e03c:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e040:	01000084 	movi	r4,2
 823e044:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 823e048:	01000c04 	movi	r4,48
 823e04c:	822c7380 	call	822c738 <pk_alloc>
 823e050:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e054:	01000084 	movi	r4,2
 823e058:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 823e05c:	e0bff917 	ldw	r2,-28(fp)
 823e060:	1000021e 	bne	r2,zero,823e06c <arpReply+0x40>
   {
      dtrap();
 823e064:	822d2e00 	call	822d2e0 <dtrap>
      return;
 823e068:	00009b06 	br	823e2d8 <arpReply+0x2ac>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 823e06c:	e0bfff17 	ldw	r2,-4(fp)
 823e070:	10c00617 	ldw	r3,24(r2)
 823e074:	e0bff917 	ldw	r2,-28(fp)
 823e078:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e07c:	e0bfff17 	ldw	r2,-4(fp)
 823e080:	10800317 	ldw	r2,12(r2)
 823e084:	10bffc84 	addi	r2,r2,-14
 823e088:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 823e08c:	e0bff917 	ldw	r2,-28(fp)
 823e090:	10800117 	ldw	r2,4(r2)
 823e094:	10800084 	addi	r2,r2,2
 823e098:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 823e09c:	e0bffb17 	ldw	r2,-20(fp)
 823e0a0:	10800304 	addi	r2,r2,12
 823e0a4:	00c00204 	movi	r3,8
 823e0a8:	10c00005 	stb	r3,0(r2)
 823e0ac:	e0bffb17 	ldw	r2,-20(fp)
 823e0b0:	10800344 	addi	r2,r2,13
 823e0b4:	00c00184 	movi	r3,6
 823e0b8:	10c00005 	stb	r3,0(r2)
      in = (struct arp_hdr *)(pkt->nb_prot);
 823e0bc:	e0bfff17 	ldw	r2,-4(fp)
 823e0c0:	10800317 	ldw	r2,12(r2)
 823e0c4:	e0bffc15 	stw	r2,-16(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 823e0c8:	e0bff917 	ldw	r2,-28(fp)
 823e0cc:	10800117 	ldw	r2,4(r2)
 823e0d0:	10800404 	addi	r2,r2,16
 823e0d4:	e0bffd15 	stw	r2,-12(fp)
      outpkt->nb_plen = arpsize;
 823e0d8:	e0bff917 	ldw	r2,-28(fp)
 823e0dc:	00c00c04 	movi	r3,48
 823e0e0:	10c00415 	stw	r3,16(r2)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e0e4:	e0bffd17 	ldw	r2,-12(fp)
 823e0e8:	00c04004 	movi	r3,256
 823e0ec:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 823e0f0:	e0bffd17 	ldw	r2,-12(fp)
 823e0f4:	00c00204 	movi	r3,8
 823e0f8:	10c0008d 	sth	r3,2(r2)
   out->ar_hln = 6;
 823e0fc:	e0bffd17 	ldw	r2,-12(fp)
 823e100:	00c00184 	movi	r3,6
 823e104:	10c00105 	stb	r3,4(r2)
   out->ar_pln = 4;
 823e108:	e0bffd17 	ldw	r2,-12(fp)
 823e10c:	00c00104 	movi	r3,4
 823e110:	10c00145 	stb	r3,5(r2)
   out->ar_op = ARREP;
 823e114:	e0bffd17 	ldw	r2,-12(fp)
 823e118:	00c08004 	movi	r3,512
 823e11c:	10c0018d 	sth	r3,6(r2)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 823e120:	e0bffc17 	ldw	r2,-16(fp)
 823e124:	10c00417 	ldw	r3,16(r2)
 823e128:	e0bffd17 	ldw	r2,-12(fp)
 823e12c:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 823e130:	e0bffc17 	ldw	r2,-16(fp)
 823e134:	10c00717 	ldw	r3,28(r2)
 823e138:	e0bffd17 	ldw	r2,-12(fp)
 823e13c:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 823e140:	e0bffd17 	ldw	r2,-12(fp)
 823e144:	10c00504 	addi	r3,r2,20
 823e148:	e0bffc17 	ldw	r2,-16(fp)
 823e14c:	10800204 	addi	r2,r2,8
 823e150:	01800184 	movi	r6,6
 823e154:	100b883a 	mov	r5,r2
 823e158:	1809883a 	mov	r4,r3
 823e15c:	8202da40 	call	8202da4 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 823e160:	e0bffd17 	ldw	r2,-12(fp)
 823e164:	10c00204 	addi	r3,r2,8
 823e168:	e0bff917 	ldw	r2,-28(fp)
 823e16c:	10800617 	ldw	r2,24(r2)
 823e170:	10802717 	ldw	r2,156(r2)
 823e174:	10800517 	ldw	r2,20(r2)
 823e178:	01800184 	movi	r6,6
 823e17c:	100b883a 	mov	r5,r2
 823e180:	1809883a 	mov	r4,r3
 823e184:	8202da40 	call	8202da4 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 823e188:	e0bffa17 	ldw	r2,-24(fp)
 823e18c:	10800184 	addi	r2,r2,6
 823e190:	01800184 	movi	r6,6
 823e194:	100b883a 	mov	r5,r2
 823e198:	e13ffb17 	ldw	r4,-20(fp)
 823e19c:	8202da40 	call	8202da4 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 823e1a0:	e0bffb17 	ldw	r2,-20(fp)
 823e1a4:	10c00184 	addi	r3,r2,6
 823e1a8:	e0bff917 	ldw	r2,-28(fp)
 823e1ac:	10800617 	ldw	r2,24(r2)
 823e1b0:	10802717 	ldw	r2,156(r2)
 823e1b4:	10800517 	ldw	r2,20(r2)
 823e1b8:	01800184 	movi	r6,6
 823e1bc:	100b883a 	mov	r5,r2
 823e1c0:	1809883a 	mov	r4,r3
 823e1c4:	8202da40 	call	8202da4 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 823e1c8:	e0bffd17 	ldw	r2,-12(fp)
 823e1cc:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 823e1d0:	e0bffe17 	ldw	r2,-8(fp)
 823e1d4:	10c00204 	addi	r3,r2,8
 823e1d8:	e0bffd17 	ldw	r2,-12(fp)
 823e1dc:	10800204 	addi	r2,r2,8
 823e1e0:	01800184 	movi	r6,6
 823e1e4:	100b883a 	mov	r5,r2
 823e1e8:	1809883a 	mov	r4,r3
 823e1ec:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 823e1f0:	e0bffe17 	ldw	r2,-8(fp)
 823e1f4:	10c00384 	addi	r3,r2,14
 823e1f8:	e0bffd17 	ldw	r2,-12(fp)
 823e1fc:	10800404 	addi	r2,r2,16
 823e200:	01800104 	movi	r6,4
 823e204:	100b883a 	mov	r5,r2
 823e208:	1809883a 	mov	r4,r3
 823e20c:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 823e210:	e0bffe17 	ldw	r2,-8(fp)
 823e214:	10c00484 	addi	r3,r2,18
 823e218:	e0bffd17 	ldw	r2,-12(fp)
 823e21c:	10800504 	addi	r2,r2,20
 823e220:	01800184 	movi	r6,6
 823e224:	100b883a 	mov	r5,r2
 823e228:	1809883a 	mov	r4,r3
 823e22c:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 823e230:	e0bffe17 	ldw	r2,-8(fp)
 823e234:	10c00604 	addi	r3,r2,24
 823e238:	e0bffd17 	ldw	r2,-12(fp)
 823e23c:	10800704 	addi	r2,r2,28
 823e240:	01800104 	movi	r6,4
 823e244:	100b883a 	mov	r5,r2
 823e248:	1809883a 	mov	r4,r3
 823e24c:	8202da40 	call	8202da4 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 823e250:	e0bff917 	ldw	r2,-28(fp)
 823e254:	10800617 	ldw	r2,24(r2)
 823e258:	10800417 	ldw	r2,16(r2)
 823e25c:	10000a26 	beq	r2,zero,823e288 <arpReply+0x25c>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 823e260:	e0bff917 	ldw	r2,-28(fp)
 823e264:	10c00117 	ldw	r3,4(r2)
 823e268:	e0bff917 	ldw	r2,-28(fp)
 823e26c:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 823e270:	e0bff917 	ldw	r2,-28(fp)
 823e274:	10800617 	ldw	r2,24(r2)
 823e278:	10800417 	ldw	r2,16(r2)
 823e27c:	e13ff917 	ldw	r4,-28(fp)
 823e280:	103ee83a 	callr	r2
 823e284:	00001106 	br	823e2cc <arpReply+0x2a0>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 823e288:	e0bff917 	ldw	r2,-28(fp)
 823e28c:	10800617 	ldw	r2,24(r2)
 823e290:	10800317 	ldw	r2,12(r2)
 823e294:	e0ffff17 	ldw	r3,-4(fp)
 823e298:	19000617 	ldw	r4,24(r3)
 823e29c:	e0fff917 	ldw	r3,-28(fp)
 823e2a0:	19400117 	ldw	r5,4(r3)
 823e2a4:	e0fff917 	ldw	r3,-28(fp)
 823e2a8:	18c00417 	ldw	r3,16(r3)
 823e2ac:	180d883a 	mov	r6,r3
 823e2b0:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e2b4:	01000084 	movi	r4,2
 823e2b8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 823e2bc:	e13ff917 	ldw	r4,-28(fp)
 823e2c0:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e2c4:	01000084 	movi	r4,2
 823e2c8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 823e2cc:	d0a0c517 	ldw	r2,-31980(gp)
 823e2d0:	10800044 	addi	r2,r2,1
 823e2d4:	d0a0c515 	stw	r2,-31980(gp)
}
 823e2d8:	e037883a 	mov	sp,fp
 823e2dc:	dfc00117 	ldw	ra,4(sp)
 823e2e0:	df000017 	ldw	fp,0(sp)
 823e2e4:	dec00204 	addi	sp,sp,8
 823e2e8:	f800283a 	ret

0823e2ec <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 823e2ec:	defff904 	addi	sp,sp,-28
 823e2f0:	dfc00615 	stw	ra,24(sp)
 823e2f4:	df000515 	stw	fp,20(sp)
 823e2f8:	df000504 	addi	fp,sp,20
 823e2fc:	e13fff15 	stw	r4,-4(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e300:	e0bfff17 	ldw	r2,-4(fp)
 823e304:	10800317 	ldw	r2,12(r2)
 823e308:	10bffc84 	addi	r2,r2,-14
 823e30c:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 823e310:	e0bfff17 	ldw	r2,-4(fp)
 823e314:	10800317 	ldw	r2,12(r2)
 823e318:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e31c:	e0bffd17 	ldw	r2,-12(fp)
 823e320:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 823e324:	e0bffd17 	ldw	r2,-12(fp)
 823e328:	10c00704 	addi	r3,r2,28
 823e32c:	e0bffe17 	ldw	r2,-8(fp)
 823e330:	10800604 	addi	r2,r2,24
 823e334:	01800104 	movi	r6,4
 823e338:	100b883a 	mov	r5,r2
 823e33c:	1809883a 	mov	r4,r3
 823e340:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 823e344:	e0bffd17 	ldw	r2,-12(fp)
 823e348:	10c00504 	addi	r3,r2,20
 823e34c:	e0bffe17 	ldw	r2,-8(fp)
 823e350:	10800484 	addi	r2,r2,18
 823e354:	01800184 	movi	r6,6
 823e358:	100b883a 	mov	r5,r2
 823e35c:	1809883a 	mov	r4,r3
 823e360:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 823e364:	e0bffd17 	ldw	r2,-12(fp)
 823e368:	10c00404 	addi	r3,r2,16
 823e36c:	e0bffe17 	ldw	r2,-8(fp)
 823e370:	10800384 	addi	r2,r2,14
 823e374:	01800104 	movi	r6,4
 823e378:	100b883a 	mov	r5,r2
 823e37c:	1809883a 	mov	r4,r3
 823e380:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 823e384:	e0bffd17 	ldw	r2,-12(fp)
 823e388:	10c00204 	addi	r3,r2,8
 823e38c:	e0bffe17 	ldw	r2,-8(fp)
 823e390:	10800204 	addi	r2,r2,8
 823e394:	01800184 	movi	r6,6
 823e398:	100b883a 	mov	r5,r2
 823e39c:	1809883a 	mov	r4,r3
 823e3a0:	8202da40 	call	8202da4 <memmove>
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e3a4:	e0bffd17 	ldw	r2,-12(fp)
 823e3a8:	10c00717 	ldw	r3,28(r2)
 823e3ac:	e0bfff17 	ldw	r2,-4(fp)
 823e3b0:	10800617 	ldw	r2,24(r2)
 823e3b4:	10800a17 	ldw	r2,40(r2)
 823e3b8:	18801c26 	beq	r3,r2,823e42c <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
 823e3bc:	e0bffd17 	ldw	r2,-12(fp)
 823e3c0:	10800717 	ldw	r2,28(r2)
 823e3c4:	1006d63a 	srli	r3,r2,24
 823e3c8:	e0bffd17 	ldw	r2,-12(fp)
 823e3cc:	10800717 	ldw	r2,28(r2)
 823e3d0:	1004d23a 	srli	r2,r2,8
 823e3d4:	10bfc00c 	andi	r2,r2,65280
 823e3d8:	1886b03a 	or	r3,r3,r2
 823e3dc:	e0bffd17 	ldw	r2,-12(fp)
 823e3e0:	10800717 	ldw	r2,28(r2)
 823e3e4:	10bfc00c 	andi	r2,r2,65280
 823e3e8:	1004923a 	slli	r2,r2,8
 823e3ec:	1886b03a 	or	r3,r3,r2
 823e3f0:	e0bffd17 	ldw	r2,-12(fp)
 823e3f4:	10800717 	ldw	r2,28(r2)
 823e3f8:	1004963a 	slli	r2,r2,24
 823e3fc:	1884b03a 	or	r2,r3,r2
 823e400:	10fc002c 	andhi	r3,r2,61440
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e404:	00b80034 	movhi	r2,57344
 823e408:	18800826 	beq	r3,r2,823e42c <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e40c:	01000084 	movi	r4,2
 823e410:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 823e414:	e13fff17 	ldw	r4,-4(fp)
 823e418:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e41c:	01000084 	movi	r4,2
 823e420:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 823e424:	00800084 	movi	r2,2
 823e428:	00004406 	br	823e53c <arprcv+0x250>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 823e42c:	e0bffd17 	ldw	r2,-12(fp)
 823e430:	1080018b 	ldhu	r2,6(r2)
 823e434:	10bfffcc 	andi	r2,r2,65535
 823e438:	10804018 	cmpnei	r2,r2,256
 823e43c:	10000d1e 	bne	r2,zero,823e474 <arprcv+0x188>
   {
      arpReqsIn++;   /* count these */
 823e440:	d0a0c217 	ldw	r2,-31992(gp)
 823e444:	10800044 	addi	r2,r2,1
 823e448:	d0a0c215 	stw	r2,-31992(gp)
      arpReply(pkt); /* send arp reply */
 823e44c:	e13fff17 	ldw	r4,-4(fp)
 823e450:	823e02c0 	call	823e02c <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 823e454:	e0bffd17 	ldw	r2,-12(fp)
 823e458:	10c00417 	ldw	r3,16(r2)
 823e45c:	e0bfff17 	ldw	r2,-4(fp)
 823e460:	10800617 	ldw	r2,24(r2)
 823e464:	100b883a 	mov	r5,r2
 823e468:	1809883a 	mov	r4,r3
 823e46c:	823df300 	call	823df30 <make_arp_entry>
 823e470:	00000306 	br	823e480 <arprcv+0x194>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 823e474:	d0a0c417 	ldw	r2,-31984(gp)
 823e478:	10800044 	addi	r2,r2,1
 823e47c:	d0a0c415 	stw	r2,-31984(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e480:	008209b4 	movhi	r2,2086
 823e484:	10b93b04 	addi	r2,r2,-6932
 823e488:	e0bffb15 	stw	r2,-20(fp)
 823e48c:	00002006 	br	823e510 <arprcv+0x224>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 823e490:	e0bffb17 	ldw	r2,-20(fp)
 823e494:	10c00017 	ldw	r3,0(r2)
 823e498:	e0bffd17 	ldw	r2,-12(fp)
 823e49c:	10800417 	ldw	r2,16(r2)
 823e4a0:	1880181e 	bne	r3,r2,823e504 <arprcv+0x218>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 823e4a4:	e0bffb17 	ldw	r2,-20(fp)
 823e4a8:	10c00104 	addi	r3,r2,4
 823e4ac:	e0bffd17 	ldw	r2,-12(fp)
 823e4b0:	10800204 	addi	r2,r2,8
 823e4b4:	01800184 	movi	r6,6
 823e4b8:	100b883a 	mov	r5,r2
 823e4bc:	1809883a 	mov	r4,r3
 823e4c0:	8202da40 	call	8202da4 <memmove>
         tp->lasttime = cticks;
 823e4c4:	d0e0a817 	ldw	r3,-32096(gp)
 823e4c8:	e0bffb17 	ldw	r2,-20(fp)
 823e4cc:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 823e4d0:	e0bffb17 	ldw	r2,-20(fp)
 823e4d4:	10800417 	ldw	r2,16(r2)
 823e4d8:	10000226 	beq	r2,zero,823e4e4 <arprcv+0x1f8>
         {
            arp_send_pending(tp);
 823e4dc:	e13ffb17 	ldw	r4,-20(fp)
 823e4e0:	823d8fc0 	call	823d8fc <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823e4e4:	01000084 	movi	r4,2
 823e4e8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 823e4ec:	e13fff17 	ldw	r4,-4(fp)
 823e4f0:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e4f4:	01000084 	movi	r4,2
 823e4f8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

         return (0);
 823e4fc:	0005883a 	mov	r2,zero
 823e500:	00000e06 	br	823e53c <arprcv+0x250>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e504:	e0bffb17 	ldw	r2,-20(fp)
 823e508:	10800804 	addi	r2,r2,32
 823e50c:	e0bffb15 	stw	r2,-20(fp)
 823e510:	e0fffb17 	ldw	r3,-20(fp)
 823e514:	008209b4 	movhi	r2,2086
 823e518:	10b97b04 	addi	r2,r2,-6676
 823e51c:	18bfdc36 	bltu	r3,r2,823e490 <arprcv+0x1a4>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e520:	01000084 	movi	r4,2
 823e524:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(pkt);
 823e528:	e13fff17 	ldw	r4,-4(fp)
 823e52c:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e530:	01000084 	movi	r4,2
 823e534:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 823e538:	00800084 	movi	r2,2
}
 823e53c:	e037883a 	mov	sp,fp
 823e540:	dfc00117 	ldw	ra,4(sp)
 823e544:	df000017 	ldw	fp,0(sp)
 823e548:	dec00204 	addi	sp,sp,8
 823e54c:	f800283a 	ret

0823e550 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 823e550:	defff804 	addi	sp,sp,-32
 823e554:	dfc00715 	stw	ra,28(sp)
 823e558:	df000615 	stw	fp,24(sp)
 823e55c:	df000604 	addi	fp,sp,24
 823e560:	e13ffe15 	stw	r4,-8(fp)
 823e564:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 823e568:	d0a0a817 	ldw	r2,-32096(gp)
 823e56c:	e0bffd15 	stw	r2,-12(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 823e570:	e0bfff17 	ldw	r2,-4(fp)
 823e574:	1000081e 	bne	r2,zero,823e598 <send_via_arp+0x48>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e578:	01000084 	movi	r4,2
 823e57c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823e580:	e13ffe17 	ldw	r4,-8(fp)
 823e584:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e588:	01000084 	movi	r4,2
 823e58c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 823e590:	00bffa84 	movi	r2,-22
 823e594:	00004906 	br	823e6bc <send_via_arp+0x16c>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 823e598:	d0a0c117 	ldw	r2,-31996(gp)
 823e59c:	e0fffd17 	ldw	r3,-12(fp)
 823e5a0:	1885c83a 	sub	r2,r3,r2
 823e5a4:	10801970 	cmpltui	r2,r2,101
 823e5a8:	1000011e 	bne	r2,zero,823e5b0 <send_via_arp+0x60>
      arpcache = (struct arptabent *)NULL;
 823e5ac:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 823e5b0:	d0a0c017 	ldw	r2,-32000(gp)
 823e5b4:	10000726 	beq	r2,zero,823e5d4 <send_via_arp+0x84>
 823e5b8:	d0a0c017 	ldw	r2,-32000(gp)
 823e5bc:	10c00017 	ldw	r3,0(r2)
 823e5c0:	e0bfff17 	ldw	r2,-4(fp)
 823e5c4:	1880031e 	bne	r3,r2,823e5d4 <send_via_arp+0x84>
      tp = arpcache;
 823e5c8:	d0a0c017 	ldw	r2,-32000(gp)
 823e5cc:	e0bffa15 	stw	r2,-24(fp)
 823e5d0:	00000306 	br	823e5e0 <send_via_arp+0x90>
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 823e5d4:	e13fff17 	ldw	r4,-4(fp)
 823e5d8:	823ddc40 	call	823ddc4 <find_oldest_arp>
 823e5dc:	e0bffa15 	stw	r2,-24(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 823e5e0:	e0bffa17 	ldw	r2,-24(fp)
 823e5e4:	10c00017 	ldw	r3,0(r2)
 823e5e8:	e0bfff17 	ldw	r2,-4(fp)
 823e5ec:	18802e1e 	bne	r3,r2,823e6a8 <send_via_arp+0x158>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 823e5f0:	e0bffa17 	ldw	r2,-24(fp)
 823e5f4:	10800417 	ldw	r2,16(r2)
 823e5f8:	10002226 	beq	r2,zero,823e684 <send_via_arp+0x134>
      {
         if (lilfreeq.q_len < 2)
 823e5fc:	008209b4 	movhi	r2,2086
 823e600:	10b79c04 	addi	r2,r2,-8592
 823e604:	10800217 	ldw	r2,8(r2)
 823e608:	10800088 	cmpgei	r2,r2,2
 823e60c:	1000091e 	bne	r2,zero,823e634 <send_via_arp+0xe4>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823e610:	01000084 	movi	r4,2
 823e614:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 823e618:	e13ffe17 	ldw	r4,-8(fp)
 823e61c:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e620:	01000084 	movi	r4,2
 823e624:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 823e628:	00bffa84 	movi	r2,-22
 823e62c:	e0bffb15 	stw	r2,-20(fp)
 823e630:	00002106 	br	823e6b8 <send_via_arp+0x168>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 823e634:	e0bffa17 	ldw	r2,-24(fp)
 823e638:	10800417 	ldw	r2,16(r2)
 823e63c:	e0bffc15 	stw	r2,-16(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e640:	00000306 	br	823e650 <send_via_arp+0x100>
               tmppkt = tmppkt->next;
 823e644:	e0bffc17 	ldw	r2,-16(fp)
 823e648:	10800017 	ldw	r2,0(r2)
 823e64c:	e0bffc15 	stw	r2,-16(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e650:	e0bffc17 	ldw	r2,-16(fp)
 823e654:	10800017 	ldw	r2,0(r2)
 823e658:	103ffa1e 	bne	r2,zero,823e644 <send_via_arp+0xf4>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 823e65c:	e0bffc17 	ldw	r2,-16(fp)
 823e660:	e0fffe17 	ldw	r3,-8(fp)
 823e664:	10c00015 	stw	r3,0(r2)
            if (pkt->next)
 823e668:	e0bffe17 	ldw	r2,-8(fp)
 823e66c:	10800017 	ldw	r2,0(r2)
 823e670:	10000126 	beq	r2,zero,823e678 <send_via_arp+0x128>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 823e674:	822d2e00 	call	822d2e0 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 823e678:	00800044 	movi	r2,1
 823e67c:	e0bffb15 	stw	r2,-20(fp)
 823e680:	00000d06 	br	823e6b8 <send_via_arp+0x168>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 823e684:	e0bffa17 	ldw	r2,-24(fp)
 823e688:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 823e68c:	e0bffd17 	ldw	r2,-12(fp)
 823e690:	d0a0c115 	stw	r2,-31996(gp)
         err = et_send(pkt, tp);
 823e694:	e17ffa17 	ldw	r5,-24(fp)
 823e698:	e13ffe17 	ldw	r4,-8(fp)
 823e69c:	823d6f40 	call	823d6f4 <et_send>
 823e6a0:	e0bffb15 	stw	r2,-20(fp)
 823e6a4:	00000406 	br	823e6b8 <send_via_arp+0x168>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 823e6a8:	e17fff17 	ldw	r5,-4(fp)
 823e6ac:	e13ffe17 	ldw	r4,-8(fp)
 823e6b0:	823d9700 	call	823d970 <send_arp>
 823e6b4:	e0bffb15 	stw	r2,-20(fp)

   return (err);
 823e6b8:	e0bffb17 	ldw	r2,-20(fp)
}
 823e6bc:	e037883a 	mov	sp,fp
 823e6c0:	dfc00117 	ldw	ra,4(sp)
 823e6c4:	df000017 	ldw	fp,0(sp)
 823e6c8:	dec00204 	addi	sp,sp,8
 823e6cc:	f800283a 	ret

0823e6d0 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 823e6d0:	defffa04 	addi	sp,sp,-24
 823e6d4:	dfc00515 	stw	ra,20(sp)
 823e6d8:	df000415 	stw	fp,16(sp)
 823e6dc:	df000404 	addi	fp,sp,16
 823e6e0:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 823e6e4:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e6e8:	d0a0a817 	ldw	r2,-32096(gp)
 823e6ec:	e0bffe15 	stw	r2,-8(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e6f0:	008209b4 	movhi	r2,2086
 823e6f4:	10b93b04 	addi	r2,r2,-6932
 823e6f8:	e0bffc15 	stw	r2,-16(fp)
 823e6fc:	00002706 	br	823e79c <cb_arpent_tmo+0xcc>
   {
      if (tp->t_pro_addr != 0)
 823e700:	e0bffc17 	ldw	r2,-16(fp)
 823e704:	10800017 	ldw	r2,0(r2)
 823e708:	10002126 	beq	r2,zero,823e790 <cb_arpent_tmo+0xc0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 823e70c:	e0bffc17 	ldw	r2,-16(fp)
 823e710:	10800417 	ldw	r2,16(r2)
 823e714:	10000b26 	beq	r2,zero,823e744 <cb_arpent_tmo+0x74>
 823e718:	e0bffc17 	ldw	r2,-16(fp)
 823e71c:	10800517 	ldw	r2,20(r2)
 823e720:	e0fffe17 	ldw	r3,-8(fp)
 823e724:	1885c83a 	sub	r2,r3,r2
 823e728:	10801970 	cmpltui	r2,r2,101
 823e72c:	1000051e 	bne	r2,zero,823e744 <cb_arpent_tmo+0x74>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 823e730:	e13ffc17 	ldw	r4,-16(fp)
 823e734:	823d8740 	call	823d874 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e738:	e0bffc17 	ldw	r2,-16(fp)
 823e73c:	10000015 	stw	zero,0(r2)
 823e740:	00001306 	br	823e790 <cb_arpent_tmo+0xc0>
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e744:	e0bffc17 	ldw	r2,-16(fp)
 823e748:	10800517 	ldw	r2,20(r2)
 823e74c:	e0fffe17 	ldw	r3,-8(fp)
 823e750:	1885c83a 	sub	r2,r3,r2
 823e754:	1007883a 	mov	r3,r2
 823e758:	d0a04f17 	ldw	r2,-32452(gp)
 823e75c:	18800916 	blt	r3,r2,823e784 <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
 823e760:	e0bffc17 	ldw	r2,-16(fp)
 823e764:	10800617 	ldw	r2,24(r2)
 823e768:	e0fffe17 	ldw	r3,-8(fp)
 823e76c:	1885c83a 	sub	r2,r3,r2
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e770:	10801910 	cmplti	r2,r2,100
 823e774:	1000031e 	bne	r2,zero,823e784 <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e778:	e0bffc17 	ldw	r2,-16(fp)
 823e77c:	10000015 	stw	zero,0(r2)
 823e780:	00000306 	br	823e790 <cb_arpent_tmo+0xc0>
         }
         else
            arp_count++;
 823e784:	e0bffd17 	ldw	r2,-12(fp)
 823e788:	10800044 	addi	r2,r2,1
 823e78c:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e790:	e0bffc17 	ldw	r2,-16(fp)
 823e794:	10800804 	addi	r2,r2,32
 823e798:	e0bffc15 	stw	r2,-16(fp)
 823e79c:	e0fffc17 	ldw	r3,-16(fp)
 823e7a0:	008209b4 	movhi	r2,2086
 823e7a4:	10b97b04 	addi	r2,r2,-6676
 823e7a8:	18bfd536 	bltu	r3,r2,823e700 <cb_arpent_tmo+0x30>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 823e7ac:	e0bffd17 	ldw	r2,-12(fp)
 823e7b0:	1000041e 	bne	r2,zero,823e7c4 <cb_arpent_tmo+0xf4>
   {
      in_timerkill(arp_timer);
 823e7b4:	d0a0bf17 	ldw	r2,-32004(gp)
 823e7b8:	1009883a 	mov	r4,r2
 823e7bc:	823d4d00 	call	823d4d0 <in_timerkill>
      arp_timer = 0;
 823e7c0:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 823e7c4:	0001883a 	nop
 823e7c8:	e037883a 	mov	sp,fp
 823e7cc:	dfc00117 	ldw	ra,4(sp)
 823e7d0:	df000017 	ldw	fp,0(sp)
 823e7d4:	dec00204 	addi	sp,sp,8
 823e7d8:	f800283a 	ret

0823e7dc <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 823e7dc:	defff704 	addi	sp,sp,-36
 823e7e0:	dfc00815 	stw	ra,32(sp)
 823e7e4:	df000715 	stw	fp,28(sp)
 823e7e8:	df000704 	addi	fp,sp,28
 823e7ec:	e13ffe15 	stw	r4,-8(fp)
 823e7f0:	e17fff15 	stw	r5,-4(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 823e7f4:	e0bffe17 	ldw	r2,-8(fp)
 823e7f8:	10802717 	ldw	r2,156(r2)
 823e7fc:	e0bff915 	stw	r2,-28(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823e800:	01000084 	movi	r4,2
 823e804:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823e808:	01000c04 	movi	r4,48
 823e80c:	822c7380 	call	822c738 <pk_alloc>
 823e810:	e0bffa15 	stw	r2,-24(fp)
   if (!arppkt)
 823e814:	e0bffa17 	ldw	r2,-24(fp)
 823e818:	1000041e 	bne	r2,zero,823e82c <grat_arp+0x50>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e81c:	01000084 	movi	r4,2
 823e820:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823e824:	00bffa84 	movi	r2,-22
 823e828:	00009506 	br	823ea80 <grat_arp+0x2a4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e82c:	01000084 	movi	r4,2
 823e830:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823e834:	e0bffa17 	ldw	r2,-24(fp)
 823e838:	10c00117 	ldw	r3,4(r2)
 823e83c:	e0bffa17 	ldw	r2,-24(fp)
 823e840:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823e844:	e0bffa17 	ldw	r2,-24(fp)
 823e848:	00c00c04 	movi	r3,48
 823e84c:	10c00415 	stw	r3,16(r2)
   arppkt->net = net;
 823e850:	e0bffa17 	ldw	r2,-24(fp)
 823e854:	e0fffe17 	ldw	r3,-8(fp)
 823e858:	10c00615 	stw	r3,24(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823e85c:	e0bffa17 	ldw	r2,-24(fp)
 823e860:	10800117 	ldw	r2,4(r2)
 823e864:	10800084 	addi	r2,r2,2
 823e868:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823e86c:	e0bffa17 	ldw	r2,-24(fp)
 823e870:	10800117 	ldw	r2,4(r2)
 823e874:	10800404 	addi	r2,r2,16
 823e878:	e0bffc15 	stw	r2,-16(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e87c:	e0bffc17 	ldw	r2,-16(fp)
 823e880:	00c04004 	movi	r3,256
 823e884:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823e888:	e0bffc17 	ldw	r2,-16(fp)
 823e88c:	00c00204 	movi	r3,8
 823e890:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823e894:	e0bffc17 	ldw	r2,-16(fp)
 823e898:	00c00184 	movi	r3,6
 823e89c:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823e8a0:	e0bffc17 	ldw	r2,-16(fp)
 823e8a4:	00c00104 	movi	r3,4
 823e8a8:	10c00145 	stb	r3,5(r2)
   
   /* ARP req? */
   if (flag == 0)
 823e8ac:	e0bfff17 	ldw	r2,-4(fp)
 823e8b0:	1000041e 	bne	r2,zero,823e8c4 <grat_arp+0xe8>
      /* yup */
      arphdr->ar_op = ARREQ;
 823e8b4:	e0bffc17 	ldw	r2,-16(fp)
 823e8b8:	00c04004 	movi	r3,256
 823e8bc:	10c0018d 	sth	r3,6(r2)
 823e8c0:	00000306 	br	823e8d0 <grat_arp+0xf4>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 823e8c4:	e0bffc17 	ldw	r2,-16(fp)
 823e8c8:	00c08004 	movi	r3,512
 823e8cc:	10c0018d 	sth	r3,6(r2)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 823e8d0:	e0bffe17 	ldw	r2,-8(fp)
 823e8d4:	10c00a17 	ldw	r3,40(r2)
 823e8d8:	e0bffc17 	ldw	r2,-16(fp)
 823e8dc:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 823e8e0:	e0bffe17 	ldw	r2,-8(fp)
 823e8e4:	10c00a17 	ldw	r3,40(r2)
 823e8e8:	e0bffc17 	ldw	r2,-16(fp)
 823e8ec:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823e8f0:	e0bffc17 	ldw	r2,-16(fp)
 823e8f4:	10c00204 	addi	r3,r2,8
 823e8f8:	e0bff917 	ldw	r2,-28(fp)
 823e8fc:	10800517 	ldw	r2,20(r2)
 823e900:	01800184 	movi	r6,6
 823e904:	100b883a 	mov	r5,r2
 823e908:	1809883a 	mov	r4,r3
 823e90c:	8202da40 	call	8202da4 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823e910:	01800184 	movi	r6,6
 823e914:	01403fc4 	movi	r5,255
 823e918:	e13ffb17 	ldw	r4,-20(fp)
 823e91c:	8202f000 	call	8202f00 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823e920:	e0bffb17 	ldw	r2,-20(fp)
 823e924:	10c00184 	addi	r3,r2,6
 823e928:	e0bff917 	ldw	r2,-28(fp)
 823e92c:	10800517 	ldw	r2,20(r2)
 823e930:	01800184 	movi	r6,6
 823e934:	100b883a 	mov	r5,r2
 823e938:	1809883a 	mov	r4,r3
 823e93c:	8202da40 	call	8202da4 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823e940:	e0bffb17 	ldw	r2,-20(fp)
 823e944:	10800304 	addi	r2,r2,12
 823e948:	00c00204 	movi	r3,8
 823e94c:	10c00005 	stb	r3,0(r2)
 823e950:	e0bffb17 	ldw	r2,-20(fp)
 823e954:	10800344 	addi	r2,r2,13
 823e958:	00c00184 	movi	r3,6
 823e95c:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e960:	e0bffc17 	ldw	r2,-16(fp)
 823e964:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823e968:	e0bffd17 	ldw	r2,-12(fp)
 823e96c:	10c00204 	addi	r3,r2,8
 823e970:	e0bffc17 	ldw	r2,-16(fp)
 823e974:	10800204 	addi	r2,r2,8
 823e978:	01800184 	movi	r6,6
 823e97c:	100b883a 	mov	r5,r2
 823e980:	1809883a 	mov	r4,r3
 823e984:	8202da40 	call	8202da4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823e988:	e0bffd17 	ldw	r2,-12(fp)
 823e98c:	10c00384 	addi	r3,r2,14
 823e990:	e0bffc17 	ldw	r2,-16(fp)
 823e994:	10800404 	addi	r2,r2,16
 823e998:	01800104 	movi	r6,4
 823e99c:	100b883a 	mov	r5,r2
 823e9a0:	1809883a 	mov	r4,r3
 823e9a4:	8202da40 	call	8202da4 <memmove>

   /* ARP req? */
   if (flag == 0)
 823e9a8:	e0bfff17 	ldw	r2,-4(fp)
 823e9ac:	1000091e 	bne	r2,zero,823e9d4 <grat_arp+0x1f8>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823e9b0:	e0bffd17 	ldw	r2,-12(fp)
 823e9b4:	10c00484 	addi	r3,r2,18
 823e9b8:	e0bffc17 	ldw	r2,-16(fp)
 823e9bc:	10800504 	addi	r2,r2,20
 823e9c0:	01800184 	movi	r6,6
 823e9c4:	100b883a 	mov	r5,r2
 823e9c8:	1809883a 	mov	r4,r3
 823e9cc:	8202da40 	call	8202da4 <memmove>
 823e9d0:	00000806 	br	823e9f4 <grat_arp+0x218>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 823e9d4:	e0bffd17 	ldw	r2,-12(fp)
 823e9d8:	10c00484 	addi	r3,r2,18
 823e9dc:	e0bffc17 	ldw	r2,-16(fp)
 823e9e0:	10800204 	addi	r2,r2,8
 823e9e4:	01800184 	movi	r6,6
 823e9e8:	100b883a 	mov	r5,r2
 823e9ec:	1809883a 	mov	r4,r3
 823e9f0:	8202da40 	call	8202da4 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823e9f4:	e0bffd17 	ldw	r2,-12(fp)
 823e9f8:	10c00604 	addi	r3,r2,24
 823e9fc:	e0bffc17 	ldw	r2,-16(fp)
 823ea00:	10800704 	addi	r2,r2,28
 823ea04:	01800104 	movi	r6,4
 823ea08:	100b883a 	mov	r5,r2
 823ea0c:	1809883a 	mov	r4,r3
 823ea10:	8202da40 	call	8202da4 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823ea14:	e0bffe17 	ldw	r2,-8(fp)
 823ea18:	10800417 	ldw	r2,16(r2)
 823ea1c:	10000526 	beq	r2,zero,823ea34 <grat_arp+0x258>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823ea20:	e0bffe17 	ldw	r2,-8(fp)
 823ea24:	10800417 	ldw	r2,16(r2)
 823ea28:	e13ffa17 	ldw	r4,-24(fp)
 823ea2c:	103ee83a 	callr	r2
 823ea30:	00000f06 	br	823ea70 <grat_arp+0x294>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823ea34:	e0bffe17 	ldw	r2,-8(fp)
 823ea38:	10800317 	ldw	r2,12(r2)
 823ea3c:	e0fffa17 	ldw	r3,-24(fp)
 823ea40:	19000617 	ldw	r4,24(r3)
 823ea44:	e0fffa17 	ldw	r3,-24(fp)
 823ea48:	18c00117 	ldw	r3,4(r3)
 823ea4c:	01800c04 	movi	r6,48
 823ea50:	180b883a 	mov	r5,r3
 823ea54:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823ea58:	01000084 	movi	r4,2
 823ea5c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823ea60:	e13ffa17 	ldw	r4,-24(fp)
 823ea64:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ea68:	01000084 	movi	r4,2
 823ea6c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823ea70:	d0a0c317 	ldw	r2,-31988(gp)
 823ea74:	10800044 	addi	r2,r2,1
 823ea78:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823ea7c:	00800044 	movi	r2,1
}
 823ea80:	e037883a 	mov	sp,fp
 823ea84:	dfc00117 	ldw	ra,4(sp)
 823ea88:	df000017 	ldw	fp,0(sp)
 823ea8c:	dec00204 	addi	sp,sp,8
 823ea90:	f800283a 	ret

0823ea94 <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 823ea94:	defffc04 	addi	sp,sp,-16
 823ea98:	dfc00315 	stw	ra,12(sp)
 823ea9c:	df000215 	stw	fp,8(sp)
 823eaa0:	df000204 	addi	fp,sp,8
 823eaa4:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823eaa8:	008209b4 	movhi	r2,2086
 823eaac:	10b97b04 	addi	r2,r2,-6676
 823eab0:	10800017 	ldw	r2,0(r2)
 823eab4:	e0bffe15 	stw	r2,-8(fp)
 823eab8:	00000906 	br	823eae0 <if_getbynum+0x4c>
   {
      if(ifnum-- == 0)
 823eabc:	e0bfff17 	ldw	r2,-4(fp)
 823eac0:	10ffffc4 	addi	r3,r2,-1
 823eac4:	e0ffff15 	stw	r3,-4(fp)
 823eac8:	1000021e 	bne	r2,zero,823ead4 <if_getbynum+0x40>
         return ifp;
 823eacc:	e0bffe17 	ldw	r2,-8(fp)
 823ead0:	00000706 	br	823eaf0 <if_getbynum+0x5c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ead4:	e0bffe17 	ldw	r2,-8(fp)
 823ead8:	10800017 	ldw	r2,0(r2)
 823eadc:	e0bffe15 	stw	r2,-8(fp)
 823eae0:	e0bffe17 	ldw	r2,-8(fp)
 823eae4:	103ff51e 	bne	r2,zero,823eabc <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 823eae8:	822d2e00 	call	822d2e0 <dtrap>
   return NULL;   /* list is not long enough */
 823eaec:	0005883a 	mov	r2,zero
}
 823eaf0:	e037883a 	mov	sp,fp
 823eaf4:	dfc00117 	ldw	ra,4(sp)
 823eaf8:	df000017 	ldw	fp,0(sp)
 823eafc:	dec00204 	addi	sp,sp,8
 823eb00:	f800283a 	ret

0823eb04 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 823eb04:	defffd04 	addi	sp,sp,-12
 823eb08:	df000215 	stw	fp,8(sp)
 823eb0c:	df000204 	addi	fp,sp,8
 823eb10:	e13ffe15 	stw	r4,-8(fp)
 823eb14:	e17fff15 	stw	r5,-4(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 823eb18:	e0bfff17 	ldw	r2,-4(fp)
 823eb1c:	108000cc 	andi	r2,r2,3
 823eb20:	10000e26 	beq	r2,zero,823eb5c <isbcast+0x58>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 823eb24:	e0bfff17 	ldw	r2,-4(fp)
 823eb28:	1080000b 	ldhu	r2,0(r2)
 823eb2c:	10ffffcc 	andi	r3,r2,65535
 823eb30:	00bfffd4 	movui	r2,65535
 823eb34:	18800226 	beq	r3,r2,823eb40 <isbcast+0x3c>
         return(FALSE);
 823eb38:	0005883a 	mov	r2,zero
 823eb3c:	00002206 	br	823ebc8 <isbcast+0xc4>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 823eb40:	e0bfff17 	ldw	r2,-4(fp)
 823eb44:	10800084 	addi	r2,r2,2
 823eb48:	10800017 	ldw	r2,0(r2)
 823eb4c:	10bfffe0 	cmpeqi	r2,r2,-1
 823eb50:	1000101e 	bne	r2,zero,823eb94 <isbcast+0x90>
         return FALSE;
 823eb54:	0005883a 	mov	r2,zero
 823eb58:	00001b06 	br	823ebc8 <isbcast+0xc4>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 823eb5c:	e0bfff17 	ldw	r2,-4(fp)
 823eb60:	10800017 	ldw	r2,0(r2)
 823eb64:	10bfffe0 	cmpeqi	r2,r2,-1
 823eb68:	1000021e 	bne	r2,zero,823eb74 <isbcast+0x70>
         return FALSE;
 823eb6c:	0005883a 	mov	r2,zero
 823eb70:	00001506 	br	823ebc8 <isbcast+0xc4>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 823eb74:	e0bfff17 	ldw	r2,-4(fp)
 823eb78:	10800104 	addi	r2,r2,4
 823eb7c:	1080000b 	ldhu	r2,0(r2)
 823eb80:	10ffffcc 	andi	r3,r2,65535
 823eb84:	00bfffd4 	movui	r2,65535
 823eb88:	18800226 	beq	r3,r2,823eb94 <isbcast+0x90>
         return(FALSE);
 823eb8c:	0005883a 	mov	r2,zero
 823eb90:	00000d06 	br	823ebc8 <isbcast+0xc4>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823eb94:	e0bffe17 	ldw	r2,-8(fp)
 823eb98:	10802717 	ldw	r2,156(r2)
 823eb9c:	10800217 	ldw	r2,8(r2)
 823eba0:	108005e0 	cmpeqi	r2,r2,23
 823eba4:	1000051e 	bne	r2,zero,823ebbc <isbcast+0xb8>
       (ifc->n_mib->ifType == SLIP))
 823eba8:	e0bffe17 	ldw	r2,-8(fp)
 823ebac:	10802717 	ldw	r2,156(r2)
 823ebb0:	10800217 	ldw	r2,8(r2)
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
         return(FALSE);
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823ebb4:	10800718 	cmpnei	r2,r2,28
 823ebb8:	1000021e 	bne	r2,zero,823ebc4 <isbcast+0xc0>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 823ebbc:	0005883a 	mov	r2,zero
 823ebc0:	00000106 	br	823ebc8 <isbcast+0xc4>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 823ebc4:	00800044 	movi	r2,1
}
 823ebc8:	e037883a 	mov	sp,fp
 823ebcc:	df000017 	ldw	fp,0(sp)
 823ebd0:	dec00104 	addi	sp,sp,4
 823ebd4:	f800283a 	ret

0823ebd8 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 823ebd8:	defffb04 	addi	sp,sp,-20
 823ebdc:	dfc00415 	stw	ra,16(sp)
 823ebe0:	df000315 	stw	fp,12(sp)
 823ebe4:	df000304 	addi	fp,sp,12
 823ebe8:	2005883a 	mov	r2,r4
 823ebec:	e0bfff0d 	sth	r2,-4(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ebf0:	008209b4 	movhi	r2,2086
 823ebf4:	10b97b04 	addi	r2,r2,-6676
 823ebf8:	10800017 	ldw	r2,0(r2)
 823ebfc:	e0bffd15 	stw	r2,-12(fp)
 823ec00:	00001106 	br	823ec48 <reg_type+0x70>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 823ec04:	e0bffd17 	ldw	r2,-12(fp)
 823ec08:	10800617 	ldw	r2,24(r2)
 823ec0c:	10000b26 	beq	r2,zero,823ec3c <reg_type+0x64>
      {
         e = (ifp->n_reg_type)(type, ifp);
 823ec10:	e0bffd17 	ldw	r2,-12(fp)
 823ec14:	10800617 	ldw	r2,24(r2)
 823ec18:	e0ffff0b 	ldhu	r3,-4(fp)
 823ec1c:	e17ffd17 	ldw	r5,-12(fp)
 823ec20:	1809883a 	mov	r4,r3
 823ec24:	103ee83a 	callr	r2
 823ec28:	e0bffe15 	stw	r2,-8(fp)
         if (e)
 823ec2c:	e0bffe17 	ldw	r2,-8(fp)
 823ec30:	10000226 	beq	r2,zero,823ec3c <reg_type+0x64>
            return e;   /* bails out if error */
 823ec34:	e0bffe17 	ldw	r2,-8(fp)
 823ec38:	00000606 	br	823ec54 <reg_type+0x7c>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ec3c:	e0bffd17 	ldw	r2,-12(fp)
 823ec40:	10800017 	ldw	r2,0(r2)
 823ec44:	e0bffd15 	stw	r2,-12(fp)
 823ec48:	e0bffd17 	ldw	r2,-12(fp)
 823ec4c:	103fed1e 	bne	r2,zero,823ec04 <reg_type+0x2c>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 823ec50:	0005883a 	mov	r2,zero
}
 823ec54:	e037883a 	mov	sp,fp
 823ec58:	dfc00117 	ldw	ra,4(sp)
 823ec5c:	df000017 	ldw	fp,0(sp)
 823ec60:	dec00204 	addi	sp,sp,8
 823ec64:	f800283a 	ret

0823ec68 <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 823ec68:	defffa04 	addi	sp,sp,-24
 823ec6c:	dfc00515 	stw	ra,20(sp)
 823ec70:	df000415 	stw	fp,16(sp)
 823ec74:	df000404 	addi	fp,sp,16
 823ec78:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 823ec7c:	008209b4 	movhi	r2,2086
 823ec80:	10b87704 	addi	r2,r2,-7716
 823ec84:	10800017 	ldw	r2,0(r2)
 823ec88:	e0bffc15 	stw	r2,-16(fp)
   while(so)
 823ec8c:	00001306 	br	823ecdc <if_killsocks+0x74>
   {
      if(so->so_pcb)
 823ec90:	e0bffc17 	ldw	r2,-16(fp)
 823ec94:	10800117 	ldw	r2,4(r2)
 823ec98:	10000526 	beq	r2,zero,823ecb0 <if_killsocks+0x48>
         so_ifp = so->so_pcb->ifp;
 823ec9c:	e0bffc17 	ldw	r2,-16(fp)
 823eca0:	10800117 	ldw	r2,4(r2)
 823eca4:	10800a17 	ldw	r2,40(r2)
 823eca8:	e0bffd15 	stw	r2,-12(fp)
 823ecac:	00000106 	br	823ecb4 <if_killsocks+0x4c>
      else
         so_ifp = NULL;
 823ecb0:	e03ffd15 	stw	zero,-12(fp)
      next = (struct socket *)so->next;
 823ecb4:	e0bffc17 	ldw	r2,-16(fp)
 823ecb8:	10800017 	ldw	r2,0(r2)
 823ecbc:	e0bffe15 	stw	r2,-8(fp)
      if (so_ifp == ifp)
 823ecc0:	e0fffd17 	ldw	r3,-12(fp)
 823ecc4:	e0bfff17 	ldw	r2,-4(fp)
 823ecc8:	1880021e 	bne	r3,r2,823ecd4 <if_killsocks+0x6c>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 823eccc:	e13ffc17 	ldw	r4,-16(fp)
 823ecd0:	8231e200 	call	8231e20 <soabort>
      }
      so = next;
 823ecd4:	e0bffe17 	ldw	r2,-8(fp)
 823ecd8:	e0bffc15 	stw	r2,-16(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 823ecdc:	e0bffc17 	ldw	r2,-16(fp)
 823ece0:	103feb1e 	bne	r2,zero,823ec90 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 823ece4:	0001883a 	nop
 823ece8:	e037883a 	mov	sp,fp
 823ecec:	dfc00117 	ldw	ra,4(sp)
 823ecf0:	df000017 	ldw	fp,0(sp)
 823ecf4:	dec00204 	addi	sp,sp,8
 823ecf8:	f800283a 	ret

0823ecfc <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 823ecfc:	defffe04 	addi	sp,sp,-8
 823ed00:	dfc00115 	stw	ra,4(sp)
 823ed04:	df000015 	stw	fp,0(sp)
 823ed08:	d839883a 	mov	fp,sp

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 823ed0c:	01000204 	movi	r4,8
 823ed10:	823ebd80 	call	823ebd8 <reg_type>
 823ed14:	10000526 	beq	r2,zero,823ed2c <ip_init+0x30>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 823ed18:	01020974 	movhi	r4,2085
 823ed1c:	21037c04 	addi	r4,r4,3568
 823ed20:	82033700 	call	8203370 <puts>
#endif
      return(1);
 823ed24:	00800044 	movi	r2,1
 823ed28:	00002906 	br	823edd0 <ip_init+0xd4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 823ed2c:	01801404 	movi	r6,80
 823ed30:	000b883a 	mov	r5,zero
 823ed34:	010209b4 	movhi	r4,2086
 823ed38:	21398004 	addi	r4,r4,-6656
 823ed3c:	8202f000 	call	8202f00 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 823ed40:	008209b4 	movhi	r2,2086
 823ed44:	10b98004 	addi	r2,r2,-6656
 823ed48:	00c00084 	movi	r3,2
 823ed4c:	10c00015 	stw	r3,0(r2)
   ip_mib.ipDefaultTTL = IP_TTL;
 823ed50:	008209b4 	movhi	r2,2086
 823ed54:	10b98004 	addi	r2,r2,-6656
 823ed58:	00c01004 	movi	r3,64
 823ed5c:	10c00115 	stw	r3,4(r2)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 823ed60:	d0a05117 	ldw	r2,-32444(gp)
 823ed64:	10800f24 	muli	r2,r2,60
 823ed68:	1009883a 	mov	r4,r2
 823ed6c:	822deb80 	call	822deb8 <npalloc>
 823ed70:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 823ed74:	d0a0c617 	ldw	r2,-31976(gp)
 823ed78:	1000051e 	bne	r2,zero,823ed90 <ip_init+0x94>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 823ed7c:	01020974 	movhi	r4,2085
 823ed80:	21038904 	addi	r4,r4,3620
 823ed84:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 823ed88:	00bffb04 	movi	r2,-20
 823ed8c:	00001006 	br	823edd0 <ip_init+0xd4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 823ed90:	d0e0c617 	ldw	r3,-31976(gp)
 823ed94:	d0a05117 	ldw	r2,-32444(gp)
 823ed98:	10800f24 	muli	r2,r2,60
 823ed9c:	100d883a 	mov	r6,r2
 823eda0:	000b883a 	mov	r5,zero
 823eda4:	1809883a 	mov	r4,r3
 823eda8:	8202f000 	call	8202f00 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 823edac:	008209b4 	movhi	r2,2086
 823edb0:	10b98004 	addi	r2,r2,-6656
 823edb4:	00c00044 	movi	r3,1
 823edb8:	10c00015 	stw	r3,0(r2)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 823edbc:	008209b4 	movhi	r2,2086
 823edc0:	10b98004 	addi	r2,r2,-6656
 823edc4:	00c01e04 	movi	r3,120
 823edc8:	10c00c15 	stw	r3,48(r2)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 823edcc:	0005883a 	mov	r2,zero
}
 823edd0:	e037883a 	mov	sp,fp
 823edd4:	dfc00117 	ldw	ra,4(sp)
 823edd8:	df000017 	ldw	fp,0(sp)
 823eddc:	dec00204 	addi	sp,sp,8
 823ede0:	f800283a 	ret

0823ede4 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 823ede4:	defff804 	addi	sp,sp,-32
 823ede8:	dfc00715 	stw	ra,28(sp)
 823edec:	df000615 	stw	fp,24(sp)
 823edf0:	df000604 	addi	fp,sp,24
 823edf4:	e13ffc15 	stw	r4,-16(fp)
 823edf8:	e17ffd15 	stw	r5,-12(fp)
 823edfc:	3007883a 	mov	r3,r6
 823ee00:	3805883a 	mov	r2,r7
 823ee04:	e0fffe05 	stb	r3,-8(fp)
 823ee08:	e0bfff0d 	sth	r2,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 823ee0c:	e0bffc17 	ldw	r2,-16(fp)
 823ee10:	10800317 	ldw	r2,12(r2)
 823ee14:	10fffb04 	addi	r3,r2,-20
 823ee18:	e0bffc17 	ldw	r2,-16(fp)
 823ee1c:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823ee20:	e0bffc17 	ldw	r2,-16(fp)
 823ee24:	10800417 	ldw	r2,16(r2)
 823ee28:	10c00504 	addi	r3,r2,20
 823ee2c:	e0bffc17 	ldw	r2,-16(fp)
 823ee30:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 823ee34:	e0bffc17 	ldw	r2,-16(fp)
 823ee38:	10800317 	ldw	r2,12(r2)
 823ee3c:	e0bffa15 	stw	r2,-24(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823ee40:	e0bffa17 	ldw	r2,-24(fp)
 823ee44:	00c01144 	movi	r3,69
 823ee48:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 823ee4c:	e0bffa17 	ldw	r2,-24(fp)
 823ee50:	e0ffff0b 	ldhu	r3,-4(fp)
 823ee54:	10c0018d 	sth	r3,6(r2)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 823ee58:	e0bffd17 	ldw	r2,-12(fp)
 823ee5c:	10bfffcc 	andi	r2,r2,65535
 823ee60:	1005d23a 	srai	r2,r2,8
 823ee64:	10803fcc 	andi	r2,r2,255
 823ee68:	1007883a 	mov	r3,r2
 823ee6c:	e0bffd17 	ldw	r2,-12(fp)
 823ee70:	10bfffcc 	andi	r2,r2,65535
 823ee74:	1004923a 	slli	r2,r2,8
 823ee78:	1884b03a 	or	r2,r3,r2
 823ee7c:	1007883a 	mov	r3,r2
 823ee80:	e0bffa17 	ldw	r2,-24(fp)
 823ee84:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 823ee88:	e0bffc17 	ldw	r2,-16(fp)
 823ee8c:	10800417 	ldw	r2,16(r2)
 823ee90:	10bfffcc 	andi	r2,r2,65535
 823ee94:	1005d23a 	srai	r2,r2,8
 823ee98:	10803fcc 	andi	r2,r2,255
 823ee9c:	1007883a 	mov	r3,r2
 823eea0:	e0bffc17 	ldw	r2,-16(fp)
 823eea4:	10800417 	ldw	r2,16(r2)
 823eea8:	10bfffcc 	andi	r2,r2,65535
 823eeac:	1004923a 	slli	r2,r2,8
 823eeb0:	1884b03a 	or	r2,r3,r2
 823eeb4:	1007883a 	mov	r3,r2
 823eeb8:	e0bffa17 	ldw	r2,-24(fp)
 823eebc:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 823eec0:	e0bffa17 	ldw	r2,-24(fp)
 823eec4:	e0fffe03 	ldbu	r3,-8(fp)
 823eec8:	10c00245 	stb	r3,9(r2)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823eecc:	e0bffc17 	ldw	r2,-16(fp)
 823eed0:	10800c17 	ldw	r2,48(r2)
 823eed4:	e0bffb15 	stw	r2,-20(fp)
 823eed8:	e0bffb17 	ldw	r2,-20(fp)
 823eedc:	10001126 	beq	r2,zero,823ef24 <ip_bldhead+0x140>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823eee0:	e0bffb17 	ldw	r2,-20(fp)
 823eee4:	10800043 	ldbu	r2,1(r2)
 823eee8:	10803fcc 	andi	r2,r2,255
 823eeec:	10000526 	beq	r2,zero,823ef04 <ip_bldhead+0x120>
         pip->ip_time = sopts->ip_ttl;
 823eef0:	e0bffb17 	ldw	r2,-20(fp)
 823eef4:	10c00043 	ldbu	r3,1(r2)
 823eef8:	e0bffa17 	ldw	r2,-24(fp)
 823eefc:	10c00205 	stb	r3,8(r2)
 823ef00:	00000306 	br	823ef10 <ip_bldhead+0x12c>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 823ef04:	e0bffa17 	ldw	r2,-24(fp)
 823ef08:	00c01004 	movi	r3,64
 823ef0c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823ef10:	e0bffb17 	ldw	r2,-20(fp)
 823ef14:	10c00003 	ldbu	r3,0(r2)
 823ef18:	e0bffa17 	ldw	r2,-24(fp)
 823ef1c:	10c00045 	stb	r3,1(r2)
 823ef20:	00000506 	br	823ef38 <ip_bldhead+0x154>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 823ef24:	e0bffa17 	ldw	r2,-24(fp)
 823ef28:	00c01004 	movi	r3,64
 823ef2c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823ef30:	e0bffa17 	ldw	r2,-24(fp)
 823ef34:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 823ef38:	e0bffa17 	ldw	r2,-24(fp)
 823ef3c:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823ef40:	01400284 	movi	r5,10
 823ef44:	e13ffa17 	ldw	r4,-24(fp)
 823ef48:	82285000 	call	8228500 <cksum>
 823ef4c:	0084303a 	nor	r2,zero,r2
 823ef50:	1007883a 	mov	r3,r2
 823ef54:	e0bffa17 	ldw	r2,-24(fp)
 823ef58:	10c0028d 	sth	r3,10(r2)
}
 823ef5c:	0001883a 	nop
 823ef60:	e037883a 	mov	sp,fp
 823ef64:	dfc00117 	ldw	ra,4(sp)
 823ef68:	df000017 	ldw	fp,0(sp)
 823ef6c:	dec00204 	addi	sp,sp,8
 823ef70:	f800283a 	ret

0823ef74 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 823ef74:	defff004 	addi	sp,sp,-64
 823ef78:	dfc00f15 	stw	ra,60(sp)
 823ef7c:	df000e15 	stw	fp,56(sp)
 823ef80:	df000e04 	addi	fp,sp,56
 823ef84:	e13fff15 	stw	r4,-4(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 823ef88:	e0bfff17 	ldw	r2,-4(fp)
 823ef8c:	10800717 	ldw	r2,28(r2)
 823ef90:	1006d63a 	srli	r3,r2,24
 823ef94:	e0bfff17 	ldw	r2,-4(fp)
 823ef98:	10800717 	ldw	r2,28(r2)
 823ef9c:	1004d23a 	srli	r2,r2,8
 823efa0:	10bfc00c 	andi	r2,r2,65280
 823efa4:	1886b03a 	or	r3,r3,r2
 823efa8:	e0bfff17 	ldw	r2,-4(fp)
 823efac:	10800717 	ldw	r2,28(r2)
 823efb0:	10bfc00c 	andi	r2,r2,65280
 823efb4:	1004923a 	slli	r2,r2,8
 823efb8:	1886b03a 	or	r3,r3,r2
 823efbc:	e0bfff17 	ldw	r2,-4(fp)
 823efc0:	10800717 	ldw	r2,28(r2)
 823efc4:	1004963a 	slli	r2,r2,24
 823efc8:	1884b03a 	or	r2,r3,r2
 823efcc:	10fc002c 	andhi	r3,r2,61440
 823efd0:	00b80034 	movhi	r2,57344
 823efd4:	1880a81e 	bne	r3,r2,823f278 <ip_write_internal+0x304>
   {
      if (p->imo != NULL)
 823efd8:	e0bfff17 	ldw	r2,-4(fp)
 823efdc:	10800b17 	ldw	r2,44(r2)
 823efe0:	10001426 	beq	r2,zero,823f034 <ip_write_internal+0xc0>
         if (p->imo->imo_multicast_netp)
 823efe4:	e0bfff17 	ldw	r2,-4(fp)
 823efe8:	10800b17 	ldw	r2,44(r2)
 823efec:	10800017 	ldw	r2,0(r2)
 823eff0:	10000626 	beq	r2,zero,823f00c <ip_write_internal+0x98>
            p->net = p->imo->imo_multicast_netp;
 823eff4:	e0bfff17 	ldw	r2,-4(fp)
 823eff8:	10800b17 	ldw	r2,44(r2)
 823effc:	10c00017 	ldw	r3,0(r2)
 823f000:	e0bfff17 	ldw	r2,-4(fp)
 823f004:	10c00615 	stw	r3,24(r2)
 823f008:	00002506 	br	823f0a0 <ip_write_internal+0x12c>
         else
            p->net = iproute(p->fhost, &firsthop);
 823f00c:	e0bfff17 	ldw	r2,-4(fp)
 823f010:	10800717 	ldw	r2,28(r2)
 823f014:	e0fffe04 	addi	r3,fp,-8
 823f018:	180b883a 	mov	r5,r3
 823f01c:	1009883a 	mov	r4,r2
 823f020:	8240a340 	call	8240a34 <iproute>
 823f024:	1007883a 	mov	r3,r2
 823f028:	e0bfff17 	ldw	r2,-4(fp)
 823f02c:	10c00615 	stw	r3,24(r2)
 823f030:	00001b06 	br	823f0a0 <ip_write_internal+0x12c>
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f034:	e03ff515 	stw	zero,-44(fp)
 823f038:	00001606 	br	823f094 <ip_write_internal+0x120>
            if (nets[i]->n_mcastlist)
 823f03c:	008209b4 	movhi	r2,2086
 823f040:	10b73a04 	addi	r2,r2,-8984
 823f044:	e0fff517 	ldw	r3,-44(fp)
 823f048:	18c7883a 	add	r3,r3,r3
 823f04c:	18c7883a 	add	r3,r3,r3
 823f050:	10c5883a 	add	r2,r2,r3
 823f054:	10800017 	ldw	r2,0(r2)
 823f058:	10802b17 	ldw	r2,172(r2)
 823f05c:	10000a26 	beq	r2,zero,823f088 <ip_write_internal+0x114>
            {
               p->net = nets[i];
 823f060:	008209b4 	movhi	r2,2086
 823f064:	10b73a04 	addi	r2,r2,-8984
 823f068:	e0fff517 	ldw	r3,-44(fp)
 823f06c:	18c7883a 	add	r3,r3,r3
 823f070:	18c7883a 	add	r3,r3,r3
 823f074:	10c5883a 	add	r2,r2,r3
 823f078:	10c00017 	ldw	r3,0(r2)
 823f07c:	e0bfff17 	ldw	r2,-4(fp)
 823f080:	10c00615 	stw	r3,24(r2)
               break;
 823f084:	00000606 	br	823f0a0 <ip_write_internal+0x12c>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f088:	e0bff517 	ldw	r2,-44(fp)
 823f08c:	10800044 	addi	r2,r2,1
 823f090:	e0bff515 	stw	r2,-44(fp)
 823f094:	d0a08417 	ldw	r2,-32240(gp)
 823f098:	e0fff517 	ldw	r3,-44(fp)
 823f09c:	18bfe736 	bltu	r3,r2,823f03c <ip_write_internal+0xc8>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 823f0a0:	e0bfff17 	ldw	r2,-4(fp)
 823f0a4:	10800617 	ldw	r2,24(r2)
 823f0a8:	10000426 	beq	r2,zero,823f0bc <ip_write_internal+0x148>
 823f0ac:	e0bfff17 	ldw	r2,-4(fp)
 823f0b0:	10800617 	ldw	r2,24(r2)
 823f0b4:	10802b17 	ldw	r2,172(r2)
 823f0b8:	10002c1e 	bne	r2,zero,823f16c <ip_write_internal+0x1f8>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f0bc:	d0a08317 	ldw	r2,-32244(gp)
 823f0c0:	1080840c 	andi	r2,r2,528
 823f0c4:	10001a26 	beq	r2,zero,823f130 <ip_write_internal+0x1bc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f0c8:	e0bfff17 	ldw	r2,-4(fp)
 823f0cc:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f0d0:	e0bfff17 	ldw	r2,-4(fp)
 823f0d4:	10800717 	ldw	r2,28(r2)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f0d8:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f0dc:	e0bfff17 	ldw	r2,-4(fp)
 823f0e0:	10800717 	ldw	r2,28(r2)
 823f0e4:	1004d23a 	srli	r2,r2,8
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f0e8:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f0ec:	e0ffff17 	ldw	r3,-4(fp)
 823f0f0:	18c00717 	ldw	r3,28(r3)
 823f0f4:	1806d43a 	srli	r3,r3,16
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f0f8:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f0fc:	e13fff17 	ldw	r4,-4(fp)
 823f100:	21000717 	ldw	r4,28(r4)
 823f104:	2008d63a 	srli	r4,r4,24
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f108:	d9000215 	stw	r4,8(sp)
 823f10c:	d8c00115 	stw	r3,4(sp)
 823f110:	d8800015 	stw	r2,0(sp)
 823f114:	300f883a 	mov	r7,r6
 823f118:	280d883a 	mov	r6,r5
 823f11c:	e17fff17 	ldw	r5,-4(fp)
 823f120:	01020974 	movhi	r4,2085
 823f124:	21039304 	addi	r4,r4,3660
 823f128:	82030ec0 	call	82030ec <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f12c:	822d2e00 	call	822d2e0 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 823f130:	008209b4 	movhi	r2,2086
 823f134:	10b98004 	addi	r2,r2,-6656
 823f138:	10800b17 	ldw	r2,44(r2)
 823f13c:	10c00044 	addi	r3,r2,1
 823f140:	008209b4 	movhi	r2,2086
 823f144:	10b98004 	addi	r2,r2,-6656
 823f148:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f14c:	01000084 	movi	r4,2
 823f150:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f154:	e13fff17 	ldw	r4,-4(fp)
 823f158:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f15c:	01000084 	movi	r4,2
 823f160:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f164:	00bff7c4 	movi	r2,-33
 823f168:	00014606 	br	823f684 <ip_write_internal+0x710>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 823f16c:	e0bfff17 	ldw	r2,-4(fp)
 823f170:	10c00717 	ldw	r3,28(r2)
 823f174:	e0bfff17 	ldw	r2,-4(fp)
 823f178:	10800617 	ldw	r2,24(r2)
 823f17c:	100b883a 	mov	r5,r2
 823f180:	1809883a 	mov	r4,r3
 823f184:	82438f40 	call	82438f4 <lookup_mcast>
 823f188:	e0bff715 	stw	r2,-36(fp)
      if ((inm != NULL) &&
 823f18c:	e0bff717 	ldw	r2,-36(fp)
 823f190:	10001b26 	beq	r2,zero,823f200 <ip_write_internal+0x28c>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f194:	e0bfff17 	ldw	r2,-4(fp)
 823f198:	10800b17 	ldw	r2,44(r2)
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
      if ((inm != NULL) &&
 823f19c:	10000526 	beq	r2,zero,823f1b4 <ip_write_internal+0x240>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f1a0:	e0bfff17 	ldw	r2,-4(fp)
 823f1a4:	10800b17 	ldw	r2,44(r2)
 823f1a8:	10800143 	ldbu	r2,5(r2)
 823f1ac:	10803fcc 	andi	r2,r2,255
 823f1b0:	10001326 	beq	r2,zero,823f200 <ip_write_internal+0x28c>
      {
         p->type = IPTP;
 823f1b4:	e0bfff17 	ldw	r2,-4(fp)
 823f1b8:	00c00204 	movi	r3,8
 823f1bc:	10c0080d 	sth	r3,32(r2)
         pkt2 = ip_copypkt(p);
 823f1c0:	e13fff17 	ldw	r4,-4(fp)
 823f1c4:	8240c0c0 	call	8240c0c <ip_copypkt>
 823f1c8:	e0bff815 	stw	r2,-32(fp)
         if (pkt2)
 823f1cc:	e0bff817 	ldw	r2,-32(fp)
 823f1d0:	10000b26 	beq	r2,zero,823f200 <ip_write_internal+0x28c>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 823f1d4:	01000044 	movi	r4,1
 823f1d8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 823f1dc:	e17ff817 	ldw	r5,-32(fp)
 823f1e0:	010209b4 	movhi	r4,2086
 823f1e4:	21367504 	addi	r4,r4,-9772
 823f1e8:	822ccc80 	call	822ccc8 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f1ec:	01000044 	movi	r4,1
 823f1f0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 823f1f4:	d0a0ab17 	ldw	r2,-32084(gp)
 823f1f8:	1009883a 	mov	r4,r2
 823f1fc:	821a1980 	call	821a198 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 823f200:	e0bfff17 	ldw	r2,-4(fp)
 823f204:	10800317 	ldw	r2,12(r2)
 823f208:	e0bff915 	stw	r2,-28(fp)
      if ((pip->ip_time == 0) || 
 823f20c:	e0bff917 	ldw	r2,-28(fp)
 823f210:	10800203 	ldbu	r2,8(r2)
 823f214:	10803fcc 	andi	r2,r2,255
 823f218:	10000b26 	beq	r2,zero,823f248 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f21c:	e0bfff17 	ldw	r2,-4(fp)
 823f220:	10800717 	ldw	r2,28(r2)
 823f224:	10803fcc 	andi	r2,r2,255
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
 823f228:	10801fe0 	cmpeqi	r2,r2,127
 823f22c:	1000061e 	bne	r2,zero,823f248 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
 823f230:	e0bfff17 	ldw	r2,-4(fp)
 823f234:	10c00717 	ldw	r3,28(r2)
 823f238:	e0bfff17 	ldw	r2,-4(fp)
 823f23c:	10800617 	ldw	r2,24(r2)
 823f240:	10800a17 	ldw	r2,40(r2)
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f244:	1880081e 	bne	r3,r2,823f268 <ip_write_internal+0x2f4>
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f248:	01000084 	movi	r4,2
 823f24c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f250:	e13fff17 	ldw	r4,-4(fp)
 823f254:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f258:	01000084 	movi	r4,2
 823f25c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 823f260:	0005883a 	mov	r2,zero
 823f264:	00010706 	br	823f684 <ip_write_internal+0x710>
      }

      firsthop = p->fhost;
 823f268:	e0bfff17 	ldw	r2,-4(fp)
 823f26c:	10800717 	ldw	r2,28(r2)
 823f270:	e0bffe15 	stw	r2,-8(fp)

      goto sendit;
 823f274:	00004006 	br	823f378 <ip_write_internal+0x404>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 823f278:	e0bfff17 	ldw	r2,-4(fp)
 823f27c:	10800717 	ldw	r2,28(r2)
 823f280:	10bfffd8 	cmpnei	r2,r2,-1
 823f284:	1000041e 	bne	r2,zero,823f298 <ip_write_internal+0x324>
   {
      firsthop = p->fhost;
 823f288:	e0bfff17 	ldw	r2,-4(fp)
 823f28c:	10800717 	ldw	r2,28(r2)
 823f290:	e0bffe15 	stw	r2,-8(fp)
 823f294:	00003806 	br	823f378 <ip_write_internal+0x404>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 823f298:	e0bfff17 	ldw	r2,-4(fp)
 823f29c:	10800717 	ldw	r2,28(r2)
 823f2a0:	e0fffe04 	addi	r3,fp,-8
 823f2a4:	180b883a 	mov	r5,r3
 823f2a8:	1009883a 	mov	r4,r2
 823f2ac:	8240a340 	call	8240a34 <iproute>
 823f2b0:	1007883a 	mov	r3,r2
 823f2b4:	e0bfff17 	ldw	r2,-4(fp)
 823f2b8:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 823f2bc:	e0bfff17 	ldw	r2,-4(fp)
 823f2c0:	10800617 	ldw	r2,24(r2)
 823f2c4:	10002c1e 	bne	r2,zero,823f378 <ip_write_internal+0x404>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f2c8:	d0a08317 	ldw	r2,-32244(gp)
 823f2cc:	1080840c 	andi	r2,r2,528
 823f2d0:	10001a26 	beq	r2,zero,823f33c <ip_write_internal+0x3c8>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f2d4:	e0bfff17 	ldw	r2,-4(fp)
 823f2d8:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f2dc:	e0bfff17 	ldw	r2,-4(fp)
 823f2e0:	10800717 	ldw	r2,28(r2)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f2e4:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f2e8:	e0bfff17 	ldw	r2,-4(fp)
 823f2ec:	10800717 	ldw	r2,28(r2)
 823f2f0:	1004d23a 	srli	r2,r2,8
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f2f4:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f2f8:	e0ffff17 	ldw	r3,-4(fp)
 823f2fc:	18c00717 	ldw	r3,28(r3)
 823f300:	1806d43a 	srli	r3,r3,16
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f304:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f308:	e13fff17 	ldw	r4,-4(fp)
 823f30c:	21000717 	ldw	r4,28(r4)
 823f310:	2008d63a 	srli	r4,r4,24
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f314:	d9000215 	stw	r4,8(sp)
 823f318:	d8c00115 	stw	r3,4(sp)
 823f31c:	d8800015 	stw	r2,0(sp)
 823f320:	300f883a 	mov	r7,r6
 823f324:	280d883a 	mov	r6,r5
 823f328:	e17fff17 	ldw	r5,-4(fp)
 823f32c:	01020974 	movhi	r4,2085
 823f330:	21039304 	addi	r4,r4,3660
 823f334:	82030ec0 	call	82030ec <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f338:	822d2e00 	call	822d2e0 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 823f33c:	008209b4 	movhi	r2,2086
 823f340:	10b98004 	addi	r2,r2,-6656
 823f344:	10800b17 	ldw	r2,44(r2)
 823f348:	10c00044 	addi	r3,r2,1
 823f34c:	008209b4 	movhi	r2,2086
 823f350:	10b98004 	addi	r2,r2,-6656
 823f354:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f358:	01000084 	movi	r4,2
 823f35c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f360:	e13fff17 	ldw	r4,-4(fp)
 823f364:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f368:	01000084 	movi	r4,2
 823f36c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f370:	00bff7c4 	movi	r2,-33
 823f374:	0000c306 	br	823f684 <ip_write_internal+0x710>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 823f378:	d0a08317 	ldw	r2,-32244(gp)
 823f37c:	1080800c 	andi	r2,r2,512
 823f380:	10002926 	beq	r2,zero,823f428 <ip_write_internal+0x4b4>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f384:	e0bfff17 	ldw	r2,-4(fp)
 823f388:	11000417 	ldw	r4,16(r2)
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f38c:	e0bfff17 	ldw	r2,-4(fp)
 823f390:	10800717 	ldw	r2,28(r2)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f394:	11403fcc 	andi	r5,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f398:	e0bfff17 	ldw	r2,-4(fp)
 823f39c:	10800717 	ldw	r2,28(r2)
 823f3a0:	1004d23a 	srli	r2,r2,8
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f3a4:	11803fcc 	andi	r6,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3a8:	e0bfff17 	ldw	r2,-4(fp)
 823f3ac:	10800717 	ldw	r2,28(r2)
 823f3b0:	1004d43a 	srli	r2,r2,16
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f3b4:	10803fcc 	andi	r2,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3b8:	e0ffff17 	ldw	r3,-4(fp)
 823f3bc:	18c00717 	ldw	r3,28(r3)
 823f3c0:	1806d63a 	srli	r3,r3,24
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f3c4:	d8c00115 	stw	r3,4(sp)
 823f3c8:	d8800015 	stw	r2,0(sp)
 823f3cc:	300f883a 	mov	r7,r6
 823f3d0:	280d883a 	mov	r6,r5
 823f3d4:	200b883a 	mov	r5,r4
 823f3d8:	01020974 	movhi	r4,2085
 823f3dc:	2103a304 	addi	r4,r4,3724
 823f3e0:	82030ec0 	call	82030ec <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 823f3e4:	e0bffe17 	ldw	r2,-8(fp)
 823f3e8:	10c03fcc 	andi	r3,r2,255
 823f3ec:	e0bffe17 	ldw	r2,-8(fp)
 823f3f0:	1004d23a 	srli	r2,r2,8
 823f3f4:	11003fcc 	andi	r4,r2,255
 823f3f8:	e0bffe17 	ldw	r2,-8(fp)
 823f3fc:	1004d43a 	srli	r2,r2,16
 823f400:	11403fcc 	andi	r5,r2,255
 823f404:	e0bffe17 	ldw	r2,-8(fp)
 823f408:	1004d63a 	srli	r2,r2,24
 823f40c:	d8800015 	stw	r2,0(sp)
 823f410:	280f883a 	mov	r7,r5
 823f414:	200d883a 	mov	r6,r4
 823f418:	180b883a 	mov	r5,r3
 823f41c:	01020974 	movhi	r4,2085
 823f420:	2103ac04 	addi	r4,r4,3760
 823f424:	82030ec0 	call	82030ec <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f428:	e0bfff17 	ldw	r2,-4(fp)
 823f42c:	10800617 	ldw	r2,24(r2)
 823f430:	10c00a17 	ldw	r3,40(r2)
 823f434:	e0bfff17 	ldw	r2,-4(fp)
 823f438:	10800717 	ldw	r2,28(r2)
 823f43c:	1880271e 	bne	r3,r2,823f4dc <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
 823f440:	e0bfff17 	ldw	r2,-4(fp)
 823f444:	10800717 	ldw	r2,28(r2)
 823f448:	10803fcc 	andi	r2,r2,255
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f44c:	10801fe0 	cmpeqi	r2,r2,127
 823f450:	1000221e 	bne	r2,zero,823f4dc <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 823f454:	e0bfff17 	ldw	r2,-4(fp)
 823f458:	10800617 	ldw	r2,24(r2)
 823f45c:	10802a17 	ldw	r2,168(r2)
 823f460:	1080020c 	andi	r2,r2,8
 823f464:	1000091e 	bne	r2,zero,823f48c <ip_write_internal+0x518>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 823f468:	822d2e00 	call	822d2e0 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f46c:	01000084 	movi	r4,2
 823f470:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f474:	e13fff17 	ldw	r4,-4(fp)
 823f478:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f47c:	01000084 	movi	r4,2
 823f480:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 823f484:	00bffd44 	movi	r2,-11
 823f488:	00007e06 	br	823f684 <ip_write_internal+0x710>
      }
      p->type = IPTP;
 823f48c:	e0bfff17 	ldw	r2,-4(fp)
 823f490:	00c00204 	movi	r3,8
 823f494:	10c0080d 	sth	r3,32(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 823f498:	0009883a 	mov	r4,zero
 823f49c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 823f4a0:	01000044 	movi	r4,1
 823f4a4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 823f4a8:	e17fff17 	ldw	r5,-4(fp)
 823f4ac:	010209b4 	movhi	r4,2086
 823f4b0:	21367504 	addi	r4,r4,-9772
 823f4b4:	822ccc80 	call	822ccc8 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f4b8:	01000044 	movi	r4,1
 823f4bc:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 823f4c0:	0009883a 	mov	r4,zero
 823f4c4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 823f4c8:	d0a0ab17 	ldw	r2,-32084(gp)
 823f4cc:	1009883a 	mov	r4,r2
 823f4d0:	821a1980 	call	821a198 <OSSemPost>

      return SUCCESS;
 823f4d4:	0005883a 	mov	r2,zero
 823f4d8:	00006a06 	br	823f684 <ip_write_internal+0x710>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 823f4dc:	e0bfff17 	ldw	r2,-4(fp)
 823f4e0:	10800a17 	ldw	r2,40(r2)
 823f4e4:	1080040c 	andi	r2,r2,16
 823f4e8:	1005003a 	cmpeq	r2,r2,zero
 823f4ec:	e0bffa05 	stb	r2,-24(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 823f4f0:	822cb340 	call	822cb34 <pk_get_max_intrsafe_buf_len>
 823f4f4:	e0bffb15 	stw	r2,-20(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 823f4f8:	e0bffa03 	ldbu	r2,-24(fp)
 823f4fc:	1000081e 	bne	r2,zero,823f520 <ip_write_internal+0x5ac>
       limit = MIN(maxbuflen,p->net->n_mtu);
 823f500:	e0bfff17 	ldw	r2,-4(fp)
 823f504:	10800617 	ldw	r2,24(r2)
 823f508:	10800917 	ldw	r2,36(r2)
 823f50c:	e0fffb17 	ldw	r3,-20(fp)
 823f510:	1880012e 	bgeu	r3,r2,823f518 <ip_write_internal+0x5a4>
 823f514:	1805883a 	mov	r2,r3
 823f518:	e0bff615 	stw	r2,-40(fp)
 823f51c:	00000406 	br	823f530 <ip_write_internal+0x5bc>
   else
       limit = p->net->n_mtu;
 823f520:	e0bfff17 	ldw	r2,-4(fp)
 823f524:	10800617 	ldw	r2,24(r2)
 823f528:	10800917 	ldw	r2,36(r2)
 823f52c:	e0bff615 	stw	r2,-40(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 823f530:	e0bfff17 	ldw	r2,-4(fp)
 823f534:	10800417 	ldw	r2,16(r2)
 823f538:	e0ffff17 	ldw	r3,-4(fp)
 823f53c:	18c00617 	ldw	r3,24(r3)
 823f540:	18c00817 	ldw	r3,32(r3)
 823f544:	10c5883a 	add	r2,r2,r3
 823f548:	e0fff617 	ldw	r3,-40(fp)
 823f54c:	1880072e 	bgeu	r3,r2,823f56c <ip_write_internal+0x5f8>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 823f550:	e0bffe17 	ldw	r2,-8(fp)
 823f554:	100b883a 	mov	r5,r2
 823f558:	e13fff17 	ldw	r4,-4(fp)
 823f55c:	82401240 	call	8240124 <ip_fragment>
 823f560:	e0bffc15 	stw	r2,-16(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 823f564:	e0bffc17 	ldw	r2,-16(fp)
 823f568:	00004606 	br	823f684 <ip_write_internal+0x710>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 823f56c:	e0bffa03 	ldbu	r2,-24(fp)
 823f570:	1000401e 	bne	r2,zero,823f674 <ip_write_internal+0x700>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f574:	01000084 	movi	r4,2
 823f578:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 823f57c:	e0bfff17 	ldw	r2,-4(fp)
 823f580:	10800417 	ldw	r2,16(r2)
 823f584:	e0ffff17 	ldw	r3,-4(fp)
 823f588:	18c00617 	ldw	r3,24(r3)
 823f58c:	18c00817 	ldw	r3,32(r3)
 823f590:	10c5883a 	add	r2,r2,r3
 823f594:	1009883a 	mov	r4,r2
 823f598:	822c7380 	call	822c738 <pk_alloc>
 823f59c:	e0bffd15 	stw	r2,-12(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f5a0:	01000084 	movi	r4,2
 823f5a4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 823f5a8:	e0bffd17 	ldw	r2,-12(fp)
 823f5ac:	1000081e 	bne	r2,zero,823f5d0 <ip_write_internal+0x65c>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f5b0:	01000084 	movi	r4,2
 823f5b4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(p);
 823f5b8:	e13fff17 	ldw	r4,-4(fp)
 823f5bc:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f5c0:	01000084 	movi	r4,2
 823f5c4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 823f5c8:	00bffac4 	movi	r2,-21
 823f5cc:	00002d06 	br	823f684 <ip_write_internal+0x710>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 823f5d0:	e0bffd17 	ldw	r2,-12(fp)
 823f5d4:	10800117 	ldw	r2,4(r2)
 823f5d8:	e0ffff17 	ldw	r3,-4(fp)
 823f5dc:	18c00617 	ldw	r3,24(r3)
 823f5e0:	18c00817 	ldw	r3,32(r3)
 823f5e4:	10c7883a 	add	r3,r2,r3
 823f5e8:	e0bffd17 	ldw	r2,-12(fp)
 823f5ec:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 823f5f0:	e0bffd17 	ldw	r2,-12(fp)
 823f5f4:	10c00317 	ldw	r3,12(r2)
 823f5f8:	e0bfff17 	ldw	r2,-4(fp)
 823f5fc:	11000317 	ldw	r4,12(r2)
 823f600:	e0bfff17 	ldw	r2,-4(fp)
 823f604:	10800417 	ldw	r2,16(r2)
 823f608:	100d883a 	mov	r6,r2
 823f60c:	200b883a 	mov	r5,r4
 823f610:	1809883a 	mov	r4,r3
 823f614:	8202c5c0 	call	8202c5c <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 823f618:	e0bfff17 	ldw	r2,-4(fp)
 823f61c:	10c00417 	ldw	r3,16(r2)
 823f620:	e0bffd17 	ldw	r2,-12(fp)
 823f624:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 823f628:	e0bfff17 	ldw	r2,-4(fp)
 823f62c:	10c00617 	ldw	r3,24(r2)
 823f630:	e0bffd17 	ldw	r2,-12(fp)
 823f634:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 823f638:	e0bfff17 	ldw	r2,-4(fp)
 823f63c:	10c00717 	ldw	r3,28(r2)
 823f640:	e0bffd17 	ldw	r2,-12(fp)
 823f644:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f648:	01000084 	movi	r4,2
 823f64c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(p);
 823f650:	e13fff17 	ldw	r4,-4(fp)
 823f654:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f658:	01000084 	movi	r4,2
 823f65c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 823f660:	e0bffe17 	ldw	r2,-8(fp)
 823f664:	100b883a 	mov	r5,r2
 823f668:	e13ffd17 	ldw	r4,-12(fp)
 823f66c:	82264440 	call	8226444 <ip2mac>
 823f670:	00000406 	br	823f684 <ip_write_internal+0x710>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 823f674:	e0bffe17 	ldw	r2,-8(fp)
 823f678:	100b883a 	mov	r5,r2
 823f67c:	e13fff17 	ldw	r4,-4(fp)
 823f680:	82264440 	call	8226444 <ip2mac>
      }
   }
}
 823f684:	e037883a 	mov	sp,fp
 823f688:	dfc00117 	ldw	ra,4(sp)
 823f68c:	df000017 	ldw	fp,0(sp)
 823f690:	dec00204 	addi	sp,sp,8
 823f694:	f800283a 	ret

0823f698 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 823f698:	defff904 	addi	sp,sp,-28
 823f69c:	dfc00615 	stw	ra,24(sp)
 823f6a0:	df000515 	stw	fp,20(sp)
 823f6a4:	df000504 	addi	fp,sp,20
 823f6a8:	2005883a 	mov	r2,r4
 823f6ac:	e17fff15 	stw	r5,-4(fp)
 823f6b0:	e0bffe05 	stb	r2,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f6b4:	008209b4 	movhi	r2,2086
 823f6b8:	10b98004 	addi	r2,r2,-6656
 823f6bc:	10800917 	ldw	r2,36(r2)
 823f6c0:	10c00044 	addi	r3,r2,1
 823f6c4:	008209b4 	movhi	r2,2086
 823f6c8:	10b98004 	addi	r2,r2,-6656
 823f6cc:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 823f6d0:	e0bfff17 	ldw	r2,-4(fp)
 823f6d4:	10800317 	ldw	r2,12(r2)
 823f6d8:	10fffb04 	addi	r3,r2,-20
 823f6dc:	e0bfff17 	ldw	r2,-4(fp)
 823f6e0:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f6e4:	e0bfff17 	ldw	r2,-4(fp)
 823f6e8:	10800417 	ldw	r2,16(r2)
 823f6ec:	10c00504 	addi	r3,r2,20
 823f6f0:	e0bfff17 	ldw	r2,-4(fp)
 823f6f4:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 823f6f8:	e0bfff17 	ldw	r2,-4(fp)
 823f6fc:	10800317 	ldw	r2,12(r2)
 823f700:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823f704:	e0bffc17 	ldw	r2,-16(fp)
 823f708:	00c01144 	movi	r3,69
 823f70c:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 823f710:	e0bffc17 	ldw	r2,-16(fp)
 823f714:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823f718:	d0a05017 	ldw	r2,-32448(gp)
 823f71c:	10bfffcc 	andi	r2,r2,65535
 823f720:	1005d23a 	srai	r2,r2,8
 823f724:	10803fcc 	andi	r2,r2,255
 823f728:	1007883a 	mov	r3,r2
 823f72c:	d0a05017 	ldw	r2,-32448(gp)
 823f730:	10bfffcc 	andi	r2,r2,65535
 823f734:	1004923a 	slli	r2,r2,8
 823f738:	1884b03a 	or	r2,r3,r2
 823f73c:	1007883a 	mov	r3,r2
 823f740:	e0bffc17 	ldw	r2,-16(fp)
 823f744:	10c0010d 	sth	r3,4(r2)
   uid++;
 823f748:	d0a05017 	ldw	r2,-32448(gp)
 823f74c:	10800044 	addi	r2,r2,1
 823f750:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823f754:	e0bfff17 	ldw	r2,-4(fp)
 823f758:	10800417 	ldw	r2,16(r2)
 823f75c:	10bfffcc 	andi	r2,r2,65535
 823f760:	1005d23a 	srai	r2,r2,8
 823f764:	10803fcc 	andi	r2,r2,255
 823f768:	1007883a 	mov	r3,r2
 823f76c:	e0bfff17 	ldw	r2,-4(fp)
 823f770:	10800417 	ldw	r2,16(r2)
 823f774:	10bfffcc 	andi	r2,r2,65535
 823f778:	1004923a 	slli	r2,r2,8
 823f77c:	1884b03a 	or	r2,r3,r2
 823f780:	1007883a 	mov	r3,r2
 823f784:	e0bffc17 	ldw	r2,-16(fp)
 823f788:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823f78c:	e0bffc17 	ldw	r2,-16(fp)
 823f790:	e0fffe03 	ldbu	r3,-8(fp)
 823f794:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823f798:	e0bffc17 	ldw	r2,-16(fp)
 823f79c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823f7a0:	00801004 	movi	r2,64
 823f7a4:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823f7a8:	e0bfff17 	ldw	r2,-4(fp)
 823f7ac:	10800717 	ldw	r2,28(r2)
 823f7b0:	1006d63a 	srli	r3,r2,24
 823f7b4:	e0bfff17 	ldw	r2,-4(fp)
 823f7b8:	10800717 	ldw	r2,28(r2)
 823f7bc:	1004d23a 	srli	r2,r2,8
 823f7c0:	10bfc00c 	andi	r2,r2,65280
 823f7c4:	1886b03a 	or	r3,r3,r2
 823f7c8:	e0bfff17 	ldw	r2,-4(fp)
 823f7cc:	10800717 	ldw	r2,28(r2)
 823f7d0:	10bfc00c 	andi	r2,r2,65280
 823f7d4:	1004923a 	slli	r2,r2,8
 823f7d8:	1886b03a 	or	r3,r3,r2
 823f7dc:	e0bfff17 	ldw	r2,-4(fp)
 823f7e0:	10800717 	ldw	r2,28(r2)
 823f7e4:	1004963a 	slli	r2,r2,24
 823f7e8:	1884b03a 	or	r2,r3,r2
 823f7ec:	10fc002c 	andhi	r3,r2,61440
 823f7f0:	00b80034 	movhi	r2,57344
 823f7f4:	1880071e 	bne	r3,r2,823f814 <ip_write+0x17c>
 823f7f8:	e0bfff17 	ldw	r2,-4(fp)
 823f7fc:	10800b17 	ldw	r2,44(r2)
 823f800:	10000426 	beq	r2,zero,823f814 <ip_write+0x17c>
      ttl = p->imo->imo_multicast_ttl;
 823f804:	e0bfff17 	ldw	r2,-4(fp)
 823f808:	10800b17 	ldw	r2,44(r2)
 823f80c:	10800103 	ldbu	r2,4(r2)
 823f810:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823f814:	e0bfff17 	ldw	r2,-4(fp)
 823f818:	10800c17 	ldw	r2,48(r2)
 823f81c:	e0bffd15 	stw	r2,-12(fp)
 823f820:	e0bffd17 	ldw	r2,-12(fp)
 823f824:	10001126 	beq	r2,zero,823f86c <ip_write+0x1d4>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823f828:	e0bffd17 	ldw	r2,-12(fp)
 823f82c:	10800043 	ldbu	r2,1(r2)
 823f830:	10803fcc 	andi	r2,r2,255
 823f834:	10000526 	beq	r2,zero,823f84c <ip_write+0x1b4>
         pip->ip_time = sopts->ip_ttl;
 823f838:	e0bffd17 	ldw	r2,-12(fp)
 823f83c:	10c00043 	ldbu	r3,1(r2)
 823f840:	e0bffc17 	ldw	r2,-16(fp)
 823f844:	10c00205 	stb	r3,8(r2)
 823f848:	00000306 	br	823f858 <ip_write+0x1c0>
	  else
         pip->ip_time = ttl;
 823f84c:	e0bffc17 	ldw	r2,-16(fp)
 823f850:	e0fffb03 	ldbu	r3,-20(fp)
 823f854:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823f858:	e0bffd17 	ldw	r2,-12(fp)
 823f85c:	10c00003 	ldbu	r3,0(r2)
 823f860:	e0bffc17 	ldw	r2,-16(fp)
 823f864:	10c00045 	stb	r3,1(r2)
 823f868:	00000506 	br	823f880 <ip_write+0x1e8>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 823f86c:	e0bffc17 	ldw	r2,-16(fp)
 823f870:	e0fffb03 	ldbu	r3,-20(fp)
 823f874:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823f878:	e0bffc17 	ldw	r2,-16(fp)
 823f87c:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 823f880:	01400284 	movi	r5,10
 823f884:	e13ffc17 	ldw	r4,-16(fp)
 823f888:	82285000 	call	8228500 <cksum>
 823f88c:	0084303a 	nor	r2,zero,r2
 823f890:	1007883a 	mov	r3,r2
 823f894:	e0bffc17 	ldw	r2,-16(fp)
 823f898:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823f89c:	e13fff17 	ldw	r4,-4(fp)
 823f8a0:	823ef740 	call	823ef74 <ip_write_internal>
}
 823f8a4:	e037883a 	mov	sp,fp
 823f8a8:	dfc00117 	ldw	ra,4(sp)
 823f8ac:	df000017 	ldw	fp,0(sp)
 823f8b0:	dec00204 	addi	sp,sp,8
 823f8b4:	f800283a 	ret

0823f8b8 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 823f8b8:	defff604 	addi	sp,sp,-40
 823f8bc:	dfc00915 	stw	ra,36(sp)
 823f8c0:	df000815 	stw	fp,32(sp)
 823f8c4:	df000804 	addi	fp,sp,32
 823f8c8:	2005883a 	mov	r2,r4
 823f8cc:	e17ffe15 	stw	r5,-8(fp)
 823f8d0:	e1bfff15 	stw	r6,-4(fp)
 823f8d4:	e0bffd05 	stb	r2,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 823f8d8:	00800504 	movi	r2,20
 823f8dc:	e0bff845 	stb	r2,-31(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f8e0:	008209b4 	movhi	r2,2086
 823f8e4:	10b98004 	addi	r2,r2,-6656
 823f8e8:	10800917 	ldw	r2,36(r2)
 823f8ec:	10c00044 	addi	r3,r2,1
 823f8f0:	008209b4 	movhi	r2,2086
 823f8f4:	10b98004 	addi	r2,r2,-6656
 823f8f8:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823f8fc:	e0bfff17 	ldw	r2,-4(fp)
 823f900:	e0bff915 	stw	r2,-28(fp)
 823f904:	00000d06 	br	823f93c <ip_write2+0x84>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 823f908:	e0bff917 	ldw	r2,-28(fp)
 823f90c:	10800003 	ldbu	r2,0(r2)
 823f910:	10803fcc 	andi	r2,r2,255
 823f914:	10800520 	cmpeqi	r2,r2,20
 823f918:	1000011e 	bne	r2,zero,823f920 <ip_write2+0x68>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823f91c:	00000406 	br	823f930 <ip_write2+0x78>
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 823f920:	e0bff843 	ldbu	r2,-31(fp)
 823f924:	10800104 	addi	r2,r2,4
 823f928:	e0bff845 	stb	r2,-31(fp)
            break;
 823f92c:	0001883a 	nop
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823f930:	e0bff917 	ldw	r2,-28(fp)
 823f934:	10800044 	addi	r2,r2,1
 823f938:	e0bff915 	stw	r2,-28(fp)
 823f93c:	e0bff917 	ldw	r2,-28(fp)
 823f940:	10800003 	ldbu	r2,0(r2)
 823f944:	10803fcc 	andi	r2,r2,255
 823f948:	103fef1e 	bne	r2,zero,823f908 <ip_write2+0x50>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 823f94c:	e0bff843 	ldbu	r2,-31(fp)
 823f950:	108000cc 	andi	r2,r2,3
 823f954:	10000726 	beq	r2,zero,823f974 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 823f958:	e0bff843 	ldbu	r2,-31(fp)
 823f95c:	108000cc 	andi	r2,r2,3
 823f960:	1007883a 	mov	r3,r2
 823f964:	00800104 	movi	r2,4
 823f968:	10c5c83a 	sub	r2,r2,r3
 823f96c:	e0bffa05 	stb	r2,-24(fp)
 823f970:	00000106 	br	823f978 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 823f974:	e03ffa05 	stb	zero,-24(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 823f978:	e0bffe17 	ldw	r2,-8(fp)
 823f97c:	10c00317 	ldw	r3,12(r2)
 823f980:	e13ff843 	ldbu	r4,-31(fp)
 823f984:	e0bffa03 	ldbu	r2,-24(fp)
 823f988:	2085883a 	add	r2,r4,r2
 823f98c:	0085c83a 	sub	r2,zero,r2
 823f990:	1887883a 	add	r3,r3,r2
 823f994:	e0bffe17 	ldw	r2,-8(fp)
 823f998:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 823f99c:	e0bffe17 	ldw	r2,-8(fp)
 823f9a0:	10800417 	ldw	r2,16(r2)
 823f9a4:	e13ff843 	ldbu	r4,-31(fp)
 823f9a8:	e0fffa03 	ldbu	r3,-24(fp)
 823f9ac:	20c7883a 	add	r3,r4,r3
 823f9b0:	10c7883a 	add	r3,r2,r3
 823f9b4:	e0bffe17 	ldw	r2,-8(fp)
 823f9b8:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 823f9bc:	e0bffe17 	ldw	r2,-8(fp)
 823f9c0:	10800317 	ldw	r2,12(r2)
 823f9c4:	e0bffb15 	stw	r2,-20(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 823f9c8:	e0fff843 	ldbu	r3,-31(fp)
 823f9cc:	e0bffa03 	ldbu	r2,-24(fp)
 823f9d0:	1885883a 	add	r2,r3,r2
 823f9d4:	1005d0ba 	srai	r2,r2,2
 823f9d8:	10801014 	ori	r2,r2,64
 823f9dc:	1007883a 	mov	r3,r2
 823f9e0:	e0bffb17 	ldw	r2,-20(fp)
 823f9e4:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 823f9e8:	e0bffb17 	ldw	r2,-20(fp)
 823f9ec:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823f9f0:	d0a05017 	ldw	r2,-32448(gp)
 823f9f4:	10bfffcc 	andi	r2,r2,65535
 823f9f8:	1005d23a 	srai	r2,r2,8
 823f9fc:	10803fcc 	andi	r2,r2,255
 823fa00:	1007883a 	mov	r3,r2
 823fa04:	d0a05017 	ldw	r2,-32448(gp)
 823fa08:	10bfffcc 	andi	r2,r2,65535
 823fa0c:	1004923a 	slli	r2,r2,8
 823fa10:	1884b03a 	or	r2,r3,r2
 823fa14:	1007883a 	mov	r3,r2
 823fa18:	e0bffb17 	ldw	r2,-20(fp)
 823fa1c:	10c0010d 	sth	r3,4(r2)
   uid++;
 823fa20:	d0a05017 	ldw	r2,-32448(gp)
 823fa24:	10800044 	addi	r2,r2,1
 823fa28:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823fa2c:	e0bffe17 	ldw	r2,-8(fp)
 823fa30:	10800417 	ldw	r2,16(r2)
 823fa34:	10bfffcc 	andi	r2,r2,65535
 823fa38:	1005d23a 	srai	r2,r2,8
 823fa3c:	10803fcc 	andi	r2,r2,255
 823fa40:	1007883a 	mov	r3,r2
 823fa44:	e0bffe17 	ldw	r2,-8(fp)
 823fa48:	10800417 	ldw	r2,16(r2)
 823fa4c:	10bfffcc 	andi	r2,r2,65535
 823fa50:	1004923a 	slli	r2,r2,8
 823fa54:	1884b03a 	or	r2,r3,r2
 823fa58:	1007883a 	mov	r3,r2
 823fa5c:	e0bffb17 	ldw	r2,-20(fp)
 823fa60:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823fa64:	e0bffb17 	ldw	r2,-20(fp)
 823fa68:	e0fffd03 	ldbu	r3,-12(fp)
 823fa6c:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fa70:	e0bffb17 	ldw	r2,-20(fp)
 823fa74:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823fa78:	00801004 	movi	r2,64
 823fa7c:	e0bff805 	stb	r2,-32(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823fa80:	e0bffe17 	ldw	r2,-8(fp)
 823fa84:	10800717 	ldw	r2,28(r2)
 823fa88:	1006d63a 	srli	r3,r2,24
 823fa8c:	e0bffe17 	ldw	r2,-8(fp)
 823fa90:	10800717 	ldw	r2,28(r2)
 823fa94:	1004d23a 	srli	r2,r2,8
 823fa98:	10bfc00c 	andi	r2,r2,65280
 823fa9c:	1886b03a 	or	r3,r3,r2
 823faa0:	e0bffe17 	ldw	r2,-8(fp)
 823faa4:	10800717 	ldw	r2,28(r2)
 823faa8:	10bfc00c 	andi	r2,r2,65280
 823faac:	1004923a 	slli	r2,r2,8
 823fab0:	1886b03a 	or	r3,r3,r2
 823fab4:	e0bffe17 	ldw	r2,-8(fp)
 823fab8:	10800717 	ldw	r2,28(r2)
 823fabc:	1004963a 	slli	r2,r2,24
 823fac0:	1884b03a 	or	r2,r3,r2
 823fac4:	10fc002c 	andhi	r3,r2,61440
 823fac8:	00b80034 	movhi	r2,57344
 823facc:	1880071e 	bne	r3,r2,823faec <ip_write2+0x234>
 823fad0:	e0bffe17 	ldw	r2,-8(fp)
 823fad4:	10800b17 	ldw	r2,44(r2)
 823fad8:	10000426 	beq	r2,zero,823faec <ip_write2+0x234>
      ttl = p->imo->imo_multicast_ttl;
 823fadc:	e0bffe17 	ldw	r2,-8(fp)
 823fae0:	10800b17 	ldw	r2,44(r2)
 823fae4:	10800103 	ldbu	r2,4(r2)
 823fae8:	e0bff805 	stb	r2,-32(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 823faec:	e0bffe17 	ldw	r2,-8(fp)
 823faf0:	10800c17 	ldw	r2,48(r2)
 823faf4:	e0bffc15 	stw	r2,-16(fp)
 823faf8:	e0bffc17 	ldw	r2,-16(fp)
 823fafc:	10001126 	beq	r2,zero,823fb44 <ip_write2+0x28c>
   {
      if (sopts->ip_ttl)
 823fb00:	e0bffc17 	ldw	r2,-16(fp)
 823fb04:	10800043 	ldbu	r2,1(r2)
 823fb08:	10803fcc 	andi	r2,r2,255
 823fb0c:	10000526 	beq	r2,zero,823fb24 <ip_write2+0x26c>
         pip->ip_time = sopts->ip_ttl;
 823fb10:	e0bffc17 	ldw	r2,-16(fp)
 823fb14:	10c00043 	ldbu	r3,1(r2)
 823fb18:	e0bffb17 	ldw	r2,-20(fp)
 823fb1c:	10c00205 	stb	r3,8(r2)
 823fb20:	00000306 	br	823fb30 <ip_write2+0x278>
      else
         pip->ip_time = ttl;
 823fb24:	e0bffb17 	ldw	r2,-20(fp)
 823fb28:	e0fff803 	ldbu	r3,-32(fp)
 823fb2c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fb30:	e0bffc17 	ldw	r2,-16(fp)
 823fb34:	10c00003 	ldbu	r3,0(r2)
 823fb38:	e0bffb17 	ldw	r2,-20(fp)
 823fb3c:	10c00045 	stb	r3,1(r2)
 823fb40:	00000506 	br	823fb58 <ip_write2+0x2a0>
   }
   else
   {
      pip->ip_time = ttl;
 823fb44:	e0bffb17 	ldw	r2,-20(fp)
 823fb48:	e0fff803 	ldbu	r3,-32(fp)
 823fb4c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fb50:	e0bffb17 	ldw	r2,-20(fp)
 823fb54:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fb58:	e0bffe17 	ldw	r2,-8(fp)
 823fb5c:	10800317 	ldw	r2,12(r2)
 823fb60:	10800504 	addi	r2,r2,20
 823fb64:	e0bff915 	stw	r2,-28(fp)
 823fb68:	00001006 	br	823fbac <ip_write2+0x2f4>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 823fb6c:	e0bfff17 	ldw	r2,-4(fp)
 823fb70:	10800003 	ldbu	r2,0(r2)
 823fb74:	10803fcc 	andi	r2,r2,255
 823fb78:	10800520 	cmpeqi	r2,r2,20
 823fb7c:	1000011e 	bne	r2,zero,823fb84 <ip_write2+0x2cc>
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fb80:	00000706 	br	823fba0 <ip_write2+0x2e8>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 823fb84:	e0bff917 	ldw	r2,-28(fp)
 823fb88:	00c12504 	movi	r3,1172
 823fb8c:	10c00015 	stw	r3,0(r2)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 823fb90:	e0bff917 	ldw	r2,-28(fp)
 823fb94:	10800104 	addi	r2,r2,4
 823fb98:	e0bff915 	stw	r2,-28(fp)
            break;
 823fb9c:	0001883a 	nop
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fba0:	e0bfff17 	ldw	r2,-4(fp)
 823fba4:	10800044 	addi	r2,r2,1
 823fba8:	e0bfff15 	stw	r2,-4(fp)
 823fbac:	e0bfff17 	ldw	r2,-4(fp)
 823fbb0:	10800003 	ldbu	r2,0(r2)
 823fbb4:	10803fcc 	andi	r2,r2,255
 823fbb8:	103fec1e 	bne	r2,zero,823fb6c <ip_write2+0x2b4>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 823fbbc:	e03ffa45 	stb	zero,-23(fp)
 823fbc0:	00000706 	br	823fbe0 <ip_write2+0x328>
 823fbc4:	e0bffa43 	ldbu	r2,-23(fp)
 823fbc8:	e0fff917 	ldw	r3,-28(fp)
 823fbcc:	1885883a 	add	r2,r3,r2
 823fbd0:	10000005 	stb	zero,0(r2)
 823fbd4:	e0bffa43 	ldbu	r2,-23(fp)
 823fbd8:	10800044 	addi	r2,r2,1
 823fbdc:	e0bffa45 	stb	r2,-23(fp)
 823fbe0:	e0fffa43 	ldbu	r3,-23(fp)
 823fbe4:	e0bffa03 	ldbu	r2,-24(fp)
 823fbe8:	18bff636 	bltu	r3,r2,823fbc4 <ip_write2+0x30c>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 823fbec:	e0fff843 	ldbu	r3,-31(fp)
 823fbf0:	e0bffa03 	ldbu	r2,-24(fp)
 823fbf4:	1885883a 	add	r2,r3,r2
 823fbf8:	1006d7fa 	srli	r3,r2,31
 823fbfc:	1885883a 	add	r2,r3,r2
 823fc00:	1005d07a 	srai	r2,r2,1
 823fc04:	100b883a 	mov	r5,r2
 823fc08:	e13ffb17 	ldw	r4,-20(fp)
 823fc0c:	82285000 	call	8228500 <cksum>
 823fc10:	0084303a 	nor	r2,zero,r2
 823fc14:	1007883a 	mov	r3,r2
 823fc18:	e0bffb17 	ldw	r2,-20(fp)
 823fc1c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 823fc20:	e13ffe17 	ldw	r4,-8(fp)
 823fc24:	823ef740 	call	823ef74 <ip_write_internal>
}
 823fc28:	e037883a 	mov	sp,fp
 823fc2c:	dfc00117 	ldw	ra,4(sp)
 823fc30:	df000017 	ldw	fp,0(sp)
 823fc34:	dec00204 	addi	sp,sp,8
 823fc38:	f800283a 	ret

0823fc3c <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 823fc3c:	defffc04 	addi	sp,sp,-16
 823fc40:	dfc00315 	stw	ra,12(sp)
 823fc44:	df000215 	stw	fp,8(sp)
 823fc48:	df000204 	addi	fp,sp,8
 823fc4c:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823fc50:	008209b4 	movhi	r2,2086
 823fc54:	10b98004 	addi	r2,r2,-6656
 823fc58:	10800917 	ldw	r2,36(r2)
 823fc5c:	10c00044 	addi	r3,r2,1
 823fc60:	008209b4 	movhi	r2,2086
 823fc64:	10b98004 	addi	r2,r2,-6656
 823fc68:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 823fc6c:	e0bfff17 	ldw	r2,-4(fp)
 823fc70:	10800317 	ldw	r2,12(r2)
 823fc74:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 823fc78:	e0bffe17 	ldw	r2,-8(fp)
 823fc7c:	1080010b 	ldhu	r2,4(r2)
 823fc80:	10bfffcc 	andi	r2,r2,65535
 823fc84:	10000f1e 	bne	r2,zero,823fcc4 <ip_raw_write+0x88>
   {
      pip->ip_id = htons((unshort)uid);
 823fc88:	d0a05017 	ldw	r2,-32448(gp)
 823fc8c:	10bfffcc 	andi	r2,r2,65535
 823fc90:	1005d23a 	srai	r2,r2,8
 823fc94:	10803fcc 	andi	r2,r2,255
 823fc98:	1007883a 	mov	r3,r2
 823fc9c:	d0a05017 	ldw	r2,-32448(gp)
 823fca0:	10bfffcc 	andi	r2,r2,65535
 823fca4:	1004923a 	slli	r2,r2,8
 823fca8:	1884b03a 	or	r2,r3,r2
 823fcac:	1007883a 	mov	r3,r2
 823fcb0:	e0bffe17 	ldw	r2,-8(fp)
 823fcb4:	10c0010d 	sth	r3,4(r2)
      uid++;
 823fcb8:	d0a05017 	ldw	r2,-32448(gp)
 823fcbc:	10800044 	addi	r2,r2,1
 823fcc0:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fcc4:	e0bffe17 	ldw	r2,-8(fp)
 823fcc8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823fccc:	01400284 	movi	r5,10
 823fcd0:	e13ffe17 	ldw	r4,-8(fp)
 823fcd4:	82285000 	call	8228500 <cksum>
 823fcd8:	0084303a 	nor	r2,zero,r2
 823fcdc:	1007883a 	mov	r3,r2
 823fce0:	e0bffe17 	ldw	r2,-8(fp)
 823fce4:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823fce8:	e13fff17 	ldw	r4,-4(fp)
 823fcec:	823ef740 	call	823ef74 <ip_write_internal>
}
 823fcf0:	e037883a 	mov	sp,fp
 823fcf4:	dfc00117 	ldw	ra,4(sp)
 823fcf8:	df000017 	ldw	fp,0(sp)
 823fcfc:	dec00204 	addi	sp,sp,8
 823fd00:	f800283a 	ret

0823fd04 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 823fd04:	defff104 	addi	sp,sp,-60
 823fd08:	dfc00e15 	stw	ra,56(sp)
 823fd0c:	df000d15 	stw	fp,52(sp)
 823fd10:	df000d04 	addi	fp,sp,52
 823fd14:	e13ffe15 	stw	r4,-8(fp)
 823fd18:	e17fff15 	stw	r5,-4(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 823fd1c:	008209b4 	movhi	r2,2086
 823fd20:	10b98004 	addi	r2,r2,-6656
 823fd24:	10801017 	ldw	r2,64(r2)
 823fd28:	10c00044 	addi	r3,r2,1
 823fd2c:	008209b4 	movhi	r2,2086
 823fd30:	10b98004 	addi	r2,r2,-6656
 823fd34:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 823fd38:	e0bffe17 	ldw	r2,-8(fp)
 823fd3c:	10800317 	ldw	r2,12(r2)
 823fd40:	e0bff815 	stw	r2,-32(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 823fd44:	e0bff817 	ldw	r2,-32(fp)
 823fd48:	10800003 	ldbu	r2,0(r2)
 823fd4c:	10803fcc 	andi	r2,r2,255
 823fd50:	108003cc 	andi	r2,r2,15
 823fd54:	1085883a 	add	r2,r2,r2
 823fd58:	1085883a 	add	r2,r2,r2
 823fd5c:	e0bff915 	stw	r2,-28(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 823fd60:	e0bffe17 	ldw	r2,-8(fp)
 823fd64:	10800417 	ldw	r2,16(r2)
 823fd68:	1007883a 	mov	r3,r2
 823fd6c:	e0bff917 	ldw	r2,-28(fp)
 823fd70:	1885c83a 	sub	r2,r3,r2
 823fd74:	e0bff515 	stw	r2,-44(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 823fd78:	e0bffe17 	ldw	r2,-8(fp)
 823fd7c:	10800617 	ldw	r2,24(r2)
 823fd80:	10c00917 	ldw	r3,36(r2)
 823fd84:	e0bffe17 	ldw	r2,-8(fp)
 823fd88:	10800617 	ldw	r2,24(r2)
 823fd8c:	11000817 	ldw	r4,32(r2)
 823fd90:	e0bff917 	ldw	r2,-28(fp)
 823fd94:	2085883a 	add	r2,r4,r2
 823fd98:	10800204 	addi	r2,r2,8
 823fd9c:	1885c83a 	sub	r2,r3,r2
 823fda0:	e0bffa15 	stw	r2,-24(fp)
   if (maxipsize < 64)  /* to small to use */
 823fda4:	e0bffa17 	ldw	r2,-24(fp)
 823fda8:	10801028 	cmpgeui	r2,r2,64
 823fdac:	1000031e 	bne	r2,zero,823fdbc <ip_fragment_lc+0xb8>
   {
      dtrap();    /* probably bad programming */
 823fdb0:	822d2e00 	call	822d2e0 <dtrap>
      return ENP_LOGIC;
 823fdb4:	00bffd44 	movi	r2,-11
 823fdb8:	0000d506 	br	8240110 <ip_fragment_lc+0x40c>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 823fdbc:	e0bffe17 	ldw	r2,-8(fp)
 823fdc0:	10800417 	ldw	r2,16(r2)
 823fdc4:	e17ffa17 	ldw	r5,-24(fp)
 823fdc8:	1009883a 	mov	r4,r2
 823fdcc:	820295c0 	call	820295c <__udivsi3>
 823fdd0:	10800044 	addi	r2,r2,1
 823fdd4:	e0bffb15 	stw	r2,-20(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 823fdd8:	e0bffe17 	ldw	r2,-8(fp)
 823fddc:	10c00417 	ldw	r3,16(r2)
 823fde0:	e0bffb17 	ldw	r2,-20(fp)
 823fde4:	1885883a 	add	r2,r3,r2
 823fde8:	10bfffc4 	addi	r2,r2,-1
 823fdec:	e17ffb17 	ldw	r5,-20(fp)
 823fdf0:	1009883a 	mov	r4,r2
 823fdf4:	820295c0 	call	820295c <__udivsi3>
 823fdf8:	10c001c4 	addi	r3,r2,7
 823fdfc:	00bffe04 	movi	r2,-8
 823fe00:	1884703a 	and	r2,r3,r2
 823fe04:	e0bffc15 	stw	r2,-16(fp)
   foffset = 0;
 823fe08:	e03ff315 	stw	zero,-52(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 823fe0c:	e0bff817 	ldw	r2,-32(fp)
 823fe10:	1080018b 	ldhu	r2,6(r2)
 823fe14:	10bfffcc 	andi	r2,r2,65535
 823fe18:	1004d23a 	srli	r2,r2,8
 823fe1c:	1007883a 	mov	r3,r2
 823fe20:	e0bff817 	ldw	r2,-32(fp)
 823fe24:	1080018b 	ldhu	r2,6(r2)
 823fe28:	10bfffcc 	andi	r2,r2,65535
 823fe2c:	1004923a 	slli	r2,r2,8
 823fe30:	1884b03a 	or	r2,r3,r2
 823fe34:	e0bffd0d 	sth	r2,-12(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 823fe38:	e0fffd0b 	ldhu	r3,-12(fp)
 823fe3c:	00bffff4 	movhi	r2,65535
 823fe40:	1087ffc4 	addi	r2,r2,8191
 823fe44:	1884703a 	and	r2,r3,r2
 823fe48:	10000826 	beq	r2,zero,823fe6c <ip_fragment_lc+0x168>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 823fe4c:	e0fffd0b 	ldhu	r3,-12(fp)
 823fe50:	00bffff4 	movhi	r2,65535
 823fe54:	1087ffc4 	addi	r2,r2,8191
 823fe58:	1884703a 	and	r2,r3,r2
 823fe5c:	e0bff315 	stw	r2,-52(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 823fe60:	e0bff317 	ldw	r2,-52(fp)
 823fe64:	100490fa 	slli	r2,r2,3
 823fe68:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 823fe6c:	e0bffe17 	ldw	r2,-8(fp)
 823fe70:	e0bff615 	stw	r2,-40(fp)
   e = 0;
 823fe74:	e03ff715 	stw	zero,-36(fp)
   while (left > 1)  /* more data left to send? */
 823fe78:	0000a106 	br	8240100 <ip_fragment_lc+0x3fc>
   {
      p = pkt2;  /* move next fragment up */
 823fe7c:	e0bff617 	ldw	r2,-40(fp)
 823fe80:	e0bffe15 	stw	r2,-8(fp)
      pip = (struct ip *)(p->nb_prot);
 823fe84:	e0bffe17 	ldw	r2,-8(fp)
 823fe88:	10800317 	ldw	r2,12(r2)
 823fe8c:	e0bff815 	stw	r2,-32(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 823fe90:	e0bffc17 	ldw	r2,-16(fp)
 823fe94:	e0fff517 	ldw	r3,-44(fp)
 823fe98:	1880010e 	bge	r3,r2,823fea0 <ip_fragment_lc+0x19c>
 823fe9c:	1805883a 	mov	r2,r3
 823fea0:	e0fff917 	ldw	r3,-28(fp)
 823fea4:	10c5883a 	add	r2,r2,r3
 823fea8:	1007883a 	mov	r3,r2
 823feac:	e0bffe17 	ldw	r2,-8(fp)
 823feb0:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 823feb4:	e0fff517 	ldw	r3,-44(fp)
 823feb8:	e0bffc17 	ldw	r2,-16(fp)
 823febc:	1885c83a 	sub	r2,r3,r2
 823fec0:	e0bff515 	stw	r2,-44(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 823fec4:	e0bffe17 	ldw	r2,-8(fp)
 823fec8:	10800417 	ldw	r2,16(r2)
 823fecc:	10bfffcc 	andi	r2,r2,65535
 823fed0:	1005d23a 	srai	r2,r2,8
 823fed4:	10803fcc 	andi	r2,r2,255
 823fed8:	1007883a 	mov	r3,r2
 823fedc:	e0bffe17 	ldw	r2,-8(fp)
 823fee0:	10800417 	ldw	r2,16(r2)
 823fee4:	10bfffcc 	andi	r2,r2,65535
 823fee8:	1004923a 	slli	r2,r2,8
 823feec:	1884b03a 	or	r2,r3,r2
 823fef0:	1007883a 	mov	r3,r2
 823fef4:	e0bff817 	ldw	r2,-32(fp)
 823fef8:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 823fefc:	e0bff317 	ldw	r2,-52(fp)
 823ff00:	1004d0fa 	srli	r2,r2,3
 823ff04:	e0bff40d 	sth	r2,-48(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 823ff08:	e0bff517 	ldw	r2,-44(fp)
 823ff0c:	10800090 	cmplti	r2,r2,2
 823ff10:	1000021e 	bne	r2,zero,823ff1c <ip_fragment_lc+0x218>
 823ff14:	00880004 	movi	r2,8192
 823ff18:	00000106 	br	823ff20 <ip_fragment_lc+0x21c>
 823ff1c:	0005883a 	mov	r2,zero
 823ff20:	e0fff40b 	ldhu	r3,-48(fp)
 823ff24:	10c4b03a 	or	r2,r2,r3
 823ff28:	e0bff40d 	sth	r2,-48(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 823ff2c:	e0bffd0b 	ldhu	r2,-12(fp)
 823ff30:	1088000c 	andi	r2,r2,8192
 823ff34:	10000326 	beq	r2,zero,823ff44 <ip_fragment_lc+0x240>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 823ff38:	e0bff40b 	ldhu	r2,-48(fp)
 823ff3c:	10880014 	ori	r2,r2,8192
 823ff40:	e0bff40d 	sth	r2,-48(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 823ff44:	e0bff40b 	ldhu	r2,-48(fp)
 823ff48:	1004d23a 	srli	r2,r2,8
 823ff4c:	1007883a 	mov	r3,r2
 823ff50:	e0bff40b 	ldhu	r2,-48(fp)
 823ff54:	1004923a 	slli	r2,r2,8
 823ff58:	1884b03a 	or	r2,r3,r2
 823ff5c:	1007883a 	mov	r3,r2
 823ff60:	e0bff817 	ldw	r2,-32(fp)
 823ff64:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 823ff68:	e0bff517 	ldw	r2,-44(fp)
 823ff6c:	10800090 	cmplti	r2,r2,2
 823ff70:	10003e1e 	bne	r2,zero,824006c <ip_fragment_lc+0x368>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823ff74:	01000084 	movi	r4,2
 823ff78:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 823ff7c:	e0fff517 	ldw	r3,-44(fp)
 823ff80:	e0bff917 	ldw	r2,-28(fp)
 823ff84:	1887883a 	add	r3,r3,r2
 823ff88:	d0a08117 	ldw	r2,-32252(gp)
 823ff8c:	1885883a 	add	r2,r3,r2
 823ff90:	1009883a 	mov	r4,r2
 823ff94:	822c7380 	call	822c738 <pk_alloc>
 823ff98:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ff9c:	01000084 	movi	r4,2
 823ffa0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 823ffa4:	e0bff617 	ldw	r2,-40(fp)
 823ffa8:	1000101e 	bne	r2,zero,823ffec <ip_fragment_lc+0x2e8>
         {
            dtrap();
 823ffac:	822d2e00 	call	822d2e0 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823ffb0:	01000084 	movi	r4,2
 823ffb4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(p);
 823ffb8:	e13ffe17 	ldw	r4,-8(fp)
 823ffbc:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ffc0:	01000084 	movi	r4,2
 823ffc4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 823ffc8:	008209b4 	movhi	r2,2086
 823ffcc:	10b98004 	addi	r2,r2,-6656
 823ffd0:	10801117 	ldw	r2,68(r2)
 823ffd4:	10c00044 	addi	r3,r2,1
 823ffd8:	008209b4 	movhi	r2,2086
 823ffdc:	10b98004 	addi	r2,r2,-6656
 823ffe0:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 823ffe4:	00bffa84 	movi	r2,-22
 823ffe8:	00004906 	br	8240110 <ip_fragment_lc+0x40c>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 823ffec:	e0bffe17 	ldw	r2,-8(fp)
 823fff0:	10c00617 	ldw	r3,24(r2)
 823fff4:	e0bff617 	ldw	r2,-40(fp)
 823fff8:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 823fffc:	e0bffe17 	ldw	r2,-8(fp)
 8240000:	10c00717 	ldw	r3,28(r2)
 8240004:	e0bff617 	ldw	r2,-40(fp)
 8240008:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 824000c:	e0bff617 	ldw	r2,-40(fp)
 8240010:	10c00317 	ldw	r3,12(r2)
 8240014:	e0bffe17 	ldw	r2,-8(fp)
 8240018:	10800317 	ldw	r2,12(r2)
 824001c:	e13ff917 	ldw	r4,-28(fp)
 8240020:	200d883a 	mov	r6,r4
 8240024:	100b883a 	mov	r5,r2
 8240028:	1809883a 	mov	r4,r3
 824002c:	8202c5c0 	call	8202c5c <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 8240030:	e0bff617 	ldw	r2,-40(fp)
 8240034:	10c00317 	ldw	r3,12(r2)
 8240038:	e0bff917 	ldw	r2,-28(fp)
 824003c:	188f883a 	add	r7,r3,r2
 8240040:	e0bffe17 	ldw	r2,-8(fp)
 8240044:	10c00317 	ldw	r3,12(r2)
 8240048:	e13ff917 	ldw	r4,-28(fp)
 824004c:	e0bffc17 	ldw	r2,-16(fp)
 8240050:	2085883a 	add	r2,r4,r2
 8240054:	1885883a 	add	r2,r3,r2
 8240058:	e0fff517 	ldw	r3,-44(fp)
 824005c:	180d883a 	mov	r6,r3
 8240060:	100b883a 	mov	r5,r2
 8240064:	3809883a 	mov	r4,r7
 8240068:	8202c5c0 	call	8202c5c <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 824006c:	e0bff817 	ldw	r2,-32(fp)
 8240070:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 8240074:	01400284 	movi	r5,10
 8240078:	e13ff817 	ldw	r4,-32(fp)
 824007c:	82285000 	call	8228500 <cksum>
 8240080:	0084303a 	nor	r2,zero,r2
 8240084:	1007883a 	mov	r3,r2
 8240088:	e0bff817 	ldw	r2,-32(fp)
 824008c:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 8240090:	e17fff17 	ldw	r5,-4(fp)
 8240094:	e13ffe17 	ldw	r4,-8(fp)
 8240098:	82264440 	call	8226444 <ip2mac>
 824009c:	e0bff715 	stw	r2,-36(fp)
      ip_mib.ipFragCreates++;
 82400a0:	008209b4 	movhi	r2,2086
 82400a4:	10b98004 	addi	r2,r2,-6656
 82400a8:	10801217 	ldw	r2,72(r2)
 82400ac:	10c00044 	addi	r3,r2,1
 82400b0:	008209b4 	movhi	r2,2086
 82400b4:	10b98004 	addi	r2,r2,-6656
 82400b8:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 82400bc:	e0bff717 	ldw	r2,-36(fp)
 82400c0:	10000b0e 	bge	r2,zero,82400f0 <ip_fragment_lc+0x3ec>
      {
         if (left > 1) 
 82400c4:	e0bff517 	ldw	r2,-44(fp)
 82400c8:	10800090 	cmplti	r2,r2,2
 82400cc:	1000061e 	bne	r2,zero,82400e8 <ip_fragment_lc+0x3e4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82400d0:	01000084 	movi	r4,2
 82400d4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 82400d8:	e13ff617 	ldw	r4,-40(fp)
 82400dc:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82400e0:	01000084 	movi	r4,2
 82400e4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         }
         return e;
 82400e8:	e0bff717 	ldw	r2,-36(fp)
 82400ec:	00000806 	br	8240110 <ip_fragment_lc+0x40c>
      }
      foffset += fragsize;    /* offset for next fragment */
 82400f0:	e0fff317 	ldw	r3,-52(fp)
 82400f4:	e0bffc17 	ldw	r2,-16(fp)
 82400f8:	1885883a 	add	r2,r3,r2
 82400fc:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 8240100:	e0bff517 	ldw	r2,-44(fp)
 8240104:	10800088 	cmpgei	r2,r2,2
 8240108:	103f5c1e 	bne	r2,zero,823fe7c <ip_fragment_lc+0x178>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 824010c:	e0bff717 	ldw	r2,-36(fp)
}
 8240110:	e037883a 	mov	sp,fp
 8240114:	dfc00117 	ldw	ra,4(sp)
 8240118:	df000017 	ldw	fp,0(sp)
 824011c:	dec00204 	addi	sp,sp,8
 8240120:	f800283a 	ret

08240124 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 8240124:	defff004 	addi	sp,sp,-64
 8240128:	dfc00f15 	stw	ra,60(sp)
 824012c:	df000e15 	stw	fp,56(sp)
 8240130:	df000e04 	addi	fp,sp,56
 8240134:	e13ffe15 	stw	r4,-8(fp)
 8240138:	e17fff15 	stw	r5,-4(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 824013c:	e0bffe17 	ldw	r2,-8(fp)
 8240140:	10800317 	ldw	r2,12(r2)
 8240144:	e0bff515 	stw	r2,-44(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 8240148:	e0bff517 	ldw	r2,-44(fp)
 824014c:	1080018b 	ldhu	r2,6(r2)
 8240150:	10bfffcc 	andi	r2,r2,65535
 8240154:	1004d23a 	srli	r2,r2,8
 8240158:	10bfffcc 	andi	r2,r2,65535
 824015c:	10c03fcc 	andi	r3,r2,255
 8240160:	e0bff517 	ldw	r2,-44(fp)
 8240164:	1080018b 	ldhu	r2,6(r2)
 8240168:	10bfffcc 	andi	r2,r2,65535
 824016c:	1004923a 	slli	r2,r2,8
 8240170:	10bfffcc 	andi	r2,r2,65535
 8240174:	1884b03a 	or	r2,r3,r2
 8240178:	1090000c 	andi	r2,r2,16384
 824017c:	10001c26 	beq	r2,zero,82401f0 <ip_fragment+0xcc>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240180:	01000084 	movi	r4,2
 8240184:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 8240188:	e13ffe17 	ldw	r4,-8(fp)
 824018c:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240190:	01000084 	movi	r4,2
 8240194:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 8240198:	008209b4 	movhi	r2,2086
 824019c:	10b98004 	addi	r2,r2,-6656
 82401a0:	10801117 	ldw	r2,68(r2)
 82401a4:	10c00044 	addi	r3,r2,1
 82401a8:	008209b4 	movhi	r2,2086
 82401ac:	10b98004 	addi	r2,r2,-6656
 82401b0:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82401b4:	e0bff517 	ldw	r2,-44(fp)
 82401b8:	10c00317 	ldw	r3,12(r2)
 82401bc:	e0bffe17 	ldw	r2,-8(fp)
 82401c0:	10800617 	ldw	r2,24(r2)
 82401c4:	11000a17 	ldw	r4,40(r2)
 82401c8:	e0bffe17 	ldw	r2,-8(fp)
 82401cc:	10800617 	ldw	r2,24(r2)
 82401d0:	d8800015 	stw	r2,0(sp)
 82401d4:	01c00104 	movi	r7,4
 82401d8:	e1bff517 	ldw	r6,-44(fp)
 82401dc:	200b883a 	mov	r5,r4
 82401e0:	1809883a 	mov	r4,r3
 82401e4:	824ad100 	call	824ad10 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 82401e8:	0005883a 	mov	r2,zero
 82401ec:	00013906 	br	82406d4 <ip_fragment+0x5b0>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 82401f0:	822cb340 	call	822cb34 <pk_get_max_intrsafe_buf_len>
 82401f4:	e0bff615 	stw	r2,-40(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 82401f8:	e0bffe17 	ldw	r2,-8(fp)
 82401fc:	10800617 	ldw	r2,24(r2)
 8240200:	10800917 	ldw	r2,36(r2)
 8240204:	1007883a 	mov	r3,r2
 8240208:	e0bff617 	ldw	r2,-40(fp)
 824020c:	10c0022e 	bgeu	r2,r3,8240218 <ip_fragment+0xf4>
 8240210:	e0bff617 	ldw	r2,-40(fp)
 8240214:	00000306 	br	8240224 <ip_fragment+0x100>
 8240218:	e0bffe17 	ldw	r2,-8(fp)
 824021c:	10800617 	ldw	r2,24(r2)
 8240220:	10800917 	ldw	r2,36(r2)
 8240224:	e0bff70d 	sth	r2,-36(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 8240228:	e0bff517 	ldw	r2,-44(fp)
 824022c:	10800003 	ldbu	r2,0(r2)
 8240230:	108003cc 	andi	r2,r2,15
 8240234:	1085883a 	add	r2,r2,r2
 8240238:	1085883a 	add	r2,r2,r2
 824023c:	e0bff785 	stb	r2,-34(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 8240240:	e0bffe17 	ldw	r2,-8(fp)
 8240244:	10800617 	ldw	r2,24(r2)
 8240248:	10800817 	ldw	r2,32(r2)
 824024c:	e0bff7c5 	stb	r2,-33(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 8240250:	e0bff783 	ldbu	r2,-34(fp)
 8240254:	e0fff70b 	ldhu	r3,-36(fp)
 8240258:	1885c83a 	sub	r2,r3,r2
 824025c:	1007883a 	mov	r3,r2
 8240260:	e0bff7c3 	ldbu	r2,-33(fp)
 8240264:	1885c83a 	sub	r2,r3,r2
 8240268:	e0bff80d 	sth	r2,-32(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 824026c:	e0fff80b 	ldhu	r3,-32(fp)
 8240270:	00bffe04 	movi	r2,-8
 8240274:	1884703a 	and	r2,r3,r2
 8240278:	e0bff80d 	sth	r2,-32(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 824027c:	e0bff517 	ldw	r2,-44(fp)
 8240280:	1080008b 	ldhu	r2,2(r2)
 8240284:	10bfffcc 	andi	r2,r2,65535
 8240288:	1004d23a 	srli	r2,r2,8
 824028c:	1007883a 	mov	r3,r2
 8240290:	e0bff517 	ldw	r2,-44(fp)
 8240294:	1080008b 	ldhu	r2,2(r2)
 8240298:	10bfffcc 	andi	r2,r2,65535
 824029c:	1004923a 	slli	r2,r2,8
 82402a0:	1884b03a 	or	r2,r3,r2
 82402a4:	1007883a 	mov	r3,r2
 82402a8:	e0bff783 	ldbu	r2,-34(fp)
 82402ac:	1885c83a 	sub	r2,r3,r2
 82402b0:	e0bff88d 	sth	r2,-30(fp)
   num_frags = (total_payload_len / useable_payload_len);
 82402b4:	e0bff88b 	ldhu	r2,-30(fp)
 82402b8:	e0fff80b 	ldhu	r3,-32(fp)
 82402bc:	180b883a 	mov	r5,r3
 82402c0:	1009883a 	mov	r4,r2
 82402c4:	820295c0 	call	820295c <__udivsi3>
 82402c8:	e0bff30d 	sth	r2,-52(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 82402cc:	e0bff88b 	ldhu	r2,-30(fp)
 82402d0:	e0fff80b 	ldhu	r3,-32(fp)
 82402d4:	180b883a 	mov	r5,r3
 82402d8:	1009883a 	mov	r4,r2
 82402dc:	82029c00 	call	82029c0 <__umodsi3>
 82402e0:	e0bff90d 	sth	r2,-28(fp)
 82402e4:	e0bff90b 	ldhu	r2,-28(fp)
 82402e8:	10000326 	beq	r2,zero,82402f8 <ip_fragment+0x1d4>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 82402ec:	e0bff30b 	ldhu	r2,-52(fp)
 82402f0:	10800044 	addi	r2,r2,1
 82402f4:	e0bff30d 	sth	r2,-52(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 82402f8:	e0bff30b 	ldhu	r2,-52(fp)
 82402fc:	10800128 	cmpgeui	r2,r2,4
 8240300:	1000081e 	bne	r2,zero,8240324 <ip_fragment+0x200>
 8240304:	e0bffe17 	ldw	r2,-8(fp)
 8240308:	10800a17 	ldw	r2,40(r2)
 824030c:	1080040c 	andi	r2,r2,16
 8240310:	1000041e 	bne	r2,zero,8240324 <ip_fragment+0x200>
   {
      return (ip_fragment_lc (p, firsthop));
 8240314:	e17fff17 	ldw	r5,-4(fp)
 8240318:	e13ffe17 	ldw	r4,-8(fp)
 824031c:	823fd040 	call	823fd04 <ip_fragment_lc>
 8240320:	0000ec06 	br	82406d4 <ip_fragment+0x5b0>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8240324:	e0bff517 	ldw	r2,-44(fp)
 8240328:	1080018b 	ldhu	r2,6(r2)
 824032c:	10bfffcc 	andi	r2,r2,65535
 8240330:	1004d23a 	srli	r2,r2,8
 8240334:	10bfffcc 	andi	r2,r2,65535
 8240338:	10c03fcc 	andi	r3,r2,255
 824033c:	e0bff517 	ldw	r2,-44(fp)
 8240340:	1080018b 	ldhu	r2,6(r2)
 8240344:	10bfffcc 	andi	r2,r2,65535
 8240348:	1004923a 	slli	r2,r2,8
 824034c:	10bfffcc 	andi	r2,r2,65535
 8240350:	1884b03a 	or	r2,r3,r2
 8240354:	100490fa 	slli	r2,r2,3
 8240358:	e0bff98d 	sth	r2,-26(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 824035c:	e0bff517 	ldw	r2,-44(fp)
 8240360:	1080018b 	ldhu	r2,6(r2)
 8240364:	10bfffcc 	andi	r2,r2,65535
 8240368:	1004d23a 	srli	r2,r2,8
 824036c:	1007883a 	mov	r3,r2
 8240370:	e0bff517 	ldw	r2,-44(fp)
 8240374:	1080018b 	ldhu	r2,6(r2)
 8240378:	10bfffcc 	andi	r2,r2,65535
 824037c:	1004923a 	slli	r2,r2,8
 8240380:	1884b03a 	or	r2,r3,r2
 8240384:	1088000c 	andi	r2,r2,8192
 8240388:	e0bffa0d 	sth	r2,-24(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 824038c:	e03ff38d 	sth	zero,-50(fp)
 8240390:	0000bf06 	br	8240690 <ip_fragment+0x56c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240394:	01000084 	movi	r4,2
 8240398:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 824039c:	e0fff80b 	ldhu	r3,-32(fp)
 82403a0:	e0bff783 	ldbu	r2,-34(fp)
 82403a4:	1887883a 	add	r3,r3,r2
 82403a8:	e0bff7c3 	ldbu	r2,-33(fp)
 82403ac:	1885883a 	add	r2,r3,r2
 82403b0:	1009883a 	mov	r4,r2
 82403b4:	822c7380 	call	822c738 <pk_alloc>
 82403b8:	e0bffb15 	stw	r2,-20(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82403bc:	01000084 	movi	r4,2
 82403c0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 82403c4:	e0bffb17 	ldw	r2,-20(fp)
 82403c8:	10000f1e 	bne	r2,zero,8240408 <ip_fragment+0x2e4>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82403cc:	01000084 	movi	r4,2
 82403d0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 82403d4:	e13ffe17 	ldw	r4,-8(fp)
 82403d8:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82403dc:	01000084 	movi	r4,2
 82403e0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 82403e4:	008209b4 	movhi	r2,2086
 82403e8:	10b98004 	addi	r2,r2,-6656
 82403ec:	10801117 	ldw	r2,68(r2)
 82403f0:	10c00044 	addi	r3,r2,1
 82403f4:	008209b4 	movhi	r2,2086
 82403f8:	10b98004 	addi	r2,r2,-6656
 82403fc:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 8240400:	00bffac4 	movi	r2,-21
 8240404:	0000b306 	br	82406d4 <ip_fragment+0x5b0>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 8240408:	e0bffb17 	ldw	r2,-20(fp)
 824040c:	10c00117 	ldw	r3,4(r2)
 8240410:	e0bff7c3 	ldbu	r2,-33(fp)
 8240414:	1887883a 	add	r3,r3,r2
 8240418:	e0bffe17 	ldw	r2,-8(fp)
 824041c:	10800317 	ldw	r2,12(r2)
 8240420:	e13ff783 	ldbu	r4,-34(fp)
 8240424:	200d883a 	mov	r6,r4
 8240428:	100b883a 	mov	r5,r2
 824042c:	1809883a 	mov	r4,r3
 8240430:	8202c5c0 	call	8202c5c <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 8240434:	e0fff38b 	ldhu	r3,-50(fp)
 8240438:	e0bff30b 	ldhu	r2,-52(fp)
 824043c:	10bfffc4 	addi	r2,r2,-1
 8240440:	1880030e 	bge	r3,r2,8240450 <ip_fragment+0x32c>
         {
            amt_to_copy = useable_payload_len;
 8240444:	e0bff80b 	ldhu	r2,-32(fp)
 8240448:	e0bff40d 	sth	r2,-48(fp)
 824044c:	00000606 	br	8240468 <ip_fragment+0x344>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 8240450:	e0bff90b 	ldhu	r2,-28(fp)
 8240454:	1000021e 	bne	r2,zero,8240460 <ip_fragment+0x33c>
 8240458:	e0bff80b 	ldhu	r2,-32(fp)
 824045c:	00000106 	br	8240464 <ip_fragment+0x340>
 8240460:	e0bff90b 	ldhu	r2,-28(fp)
 8240464:	e0bff40d 	sth	r2,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 8240468:	e0bffb17 	ldw	r2,-20(fp)
 824046c:	10c00117 	ldw	r3,4(r2)
 8240470:	e13ff7c3 	ldbu	r4,-33(fp)
 8240474:	e0bff783 	ldbu	r2,-34(fp)
 8240478:	2085883a 	add	r2,r4,r2
 824047c:	188f883a 	add	r7,r3,r2
 8240480:	e0bffe17 	ldw	r2,-8(fp)
 8240484:	10c00317 	ldw	r3,12(r2)
 8240488:	e0bff783 	ldbu	r2,-34(fp)
 824048c:	e17ff80b 	ldhu	r5,-32(fp)
 8240490:	e13ff38b 	ldhu	r4,-50(fp)
 8240494:	2909383a 	mul	r4,r5,r4
 8240498:	1105883a 	add	r2,r2,r4
 824049c:	1885883a 	add	r2,r3,r2
 82404a0:	e0fff40b 	ldhu	r3,-48(fp)
 82404a4:	180d883a 	mov	r6,r3
 82404a8:	100b883a 	mov	r5,r2
 82404ac:	3809883a 	mov	r4,r7
 82404b0:	8202c5c0 	call	8202c5c <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 82404b4:	e0bffb17 	ldw	r2,-20(fp)
 82404b8:	10c00117 	ldw	r3,4(r2)
 82404bc:	e0bff7c3 	ldbu	r2,-33(fp)
 82404c0:	1887883a 	add	r3,r3,r2
 82404c4:	e0bffb17 	ldw	r2,-20(fp)
 82404c8:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 82404cc:	e0fff783 	ldbu	r3,-34(fp)
 82404d0:	e0bff40b 	ldhu	r2,-48(fp)
 82404d4:	1885883a 	add	r2,r3,r2
 82404d8:	1007883a 	mov	r3,r2
 82404dc:	e0bffb17 	ldw	r2,-20(fp)
 82404e0:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 82404e4:	e0bffe17 	ldw	r2,-8(fp)
 82404e8:	10c00617 	ldw	r3,24(r2)
 82404ec:	e0bffb17 	ldw	r2,-20(fp)
 82404f0:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 82404f4:	e0bffe17 	ldw	r2,-8(fp)
 82404f8:	10c00717 	ldw	r3,28(r2)
 82404fc:	e0bffb17 	ldw	r2,-20(fp)
 8240500:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 8240504:	e0bffb17 	ldw	r2,-20(fp)
 8240508:	00c20004 	movi	r3,2048
 824050c:	10c0080d 	sth	r3,32(r2)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 8240510:	e0bffb17 	ldw	r2,-20(fp)
 8240514:	10800317 	ldw	r2,12(r2)
 8240518:	e0bffc15 	stw	r2,-16(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 824051c:	e0bffb17 	ldw	r2,-20(fp)
 8240520:	10800417 	ldw	r2,16(r2)
 8240524:	1004d23a 	srli	r2,r2,8
 8240528:	10803fcc 	andi	r2,r2,255
 824052c:	1007883a 	mov	r3,r2
 8240530:	e0bffb17 	ldw	r2,-20(fp)
 8240534:	10800417 	ldw	r2,16(r2)
 8240538:	1004923a 	slli	r2,r2,8
 824053c:	1884b03a 	or	r2,r3,r2
 8240540:	1007883a 	mov	r3,r2
 8240544:	e0bffc17 	ldw	r2,-16(fp)
 8240548:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 824054c:	e0fff98b 	ldhu	r3,-26(fp)
 8240550:	e13ff80b 	ldhu	r4,-32(fp)
 8240554:	e0bff38b 	ldhu	r2,-50(fp)
 8240558:	2085383a 	mul	r2,r4,r2
 824055c:	1885883a 	add	r2,r3,r2
 8240560:	1005d2fa 	srai	r2,r2,11
 8240564:	10803fcc 	andi	r2,r2,255
 8240568:	100b883a 	mov	r5,r2
 824056c:	e0fff98b 	ldhu	r3,-26(fp)
 8240570:	e13ff80b 	ldhu	r4,-32(fp)
 8240574:	e0bff38b 	ldhu	r2,-50(fp)
 8240578:	2085383a 	mul	r2,r4,r2
 824057c:	1885883a 	add	r2,r3,r2
 8240580:	1005d0fa 	srai	r2,r2,3
 8240584:	1004923a 	slli	r2,r2,8
 8240588:	2884b03a 	or	r2,r5,r2
 824058c:	1007883a 	mov	r3,r2
 8240590:	e0bffc17 	ldw	r2,-16(fp)
 8240594:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 8240598:	e0fff38b 	ldhu	r3,-50(fp)
 824059c:	e0bff30b 	ldhu	r2,-52(fp)
 82405a0:	10bfffc4 	addi	r2,r2,-1
 82405a4:	1880070e 	bge	r3,r2,82405c4 <ip_fragment+0x4a0>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82405a8:	e0bffc17 	ldw	r2,-16(fp)
 82405ac:	1080018b 	ldhu	r2,6(r2)
 82405b0:	10800814 	ori	r2,r2,32
 82405b4:	1007883a 	mov	r3,r2
 82405b8:	e0bffc17 	ldw	r2,-16(fp)
 82405bc:	10c0018d 	sth	r3,6(r2)
 82405c0:	00000806 	br	82405e4 <ip_fragment+0x4c0>
         }
         else
         {
            if (parent_mf)
 82405c4:	e0bffa0b 	ldhu	r2,-24(fp)
 82405c8:	10000626 	beq	r2,zero,82405e4 <ip_fragment+0x4c0>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82405cc:	e0bffc17 	ldw	r2,-16(fp)
 82405d0:	1080018b 	ldhu	r2,6(r2)
 82405d4:	10800814 	ori	r2,r2,32
 82405d8:	1007883a 	mov	r3,r2
 82405dc:	e0bffc17 	ldw	r2,-16(fp)
 82405e0:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 82405e4:	e0bffc17 	ldw	r2,-16(fp)
 82405e8:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 82405ec:	e0bff783 	ldbu	r2,-34(fp)
 82405f0:	1004d07a 	srli	r2,r2,1
 82405f4:	10803fcc 	andi	r2,r2,255
 82405f8:	100b883a 	mov	r5,r2
 82405fc:	e13ffc17 	ldw	r4,-16(fp)
 8240600:	82285000 	call	8228500 <cksum>
 8240604:	0084303a 	nor	r2,zero,r2
 8240608:	1007883a 	mov	r3,r2
 824060c:	e0bffc17 	ldw	r2,-16(fp)
 8240610:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 8240614:	008209b4 	movhi	r2,2086
 8240618:	10b98004 	addi	r2,r2,-6656
 824061c:	10801217 	ldw	r2,72(r2)
 8240620:	10c00044 	addi	r3,r2,1
 8240624:	008209b4 	movhi	r2,2086
 8240628:	10b98004 	addi	r2,r2,-6656
 824062c:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 8240630:	e17fff17 	ldw	r5,-4(fp)
 8240634:	e13ffb17 	ldw	r4,-20(fp)
 8240638:	82264440 	call	8226444 <ip2mac>
 824063c:	e0bffd15 	stw	r2,-12(fp)
         if (e < 0)
 8240640:	e0bffd17 	ldw	r2,-12(fp)
 8240644:	10000f0e 	bge	r2,zero,8240684 <ip_fragment+0x560>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8240648:	01000084 	movi	r4,2
 824064c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(p);
 8240650:	e13ffe17 	ldw	r4,-8(fp)
 8240654:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240658:	01000084 	movi	r4,2
 824065c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 8240660:	008209b4 	movhi	r2,2086
 8240664:	10b98004 	addi	r2,r2,-6656
 8240668:	10801117 	ldw	r2,68(r2)
 824066c:	10c00044 	addi	r3,r2,1
 8240670:	008209b4 	movhi	r2,2086
 8240674:	10b98004 	addi	r2,r2,-6656
 8240678:	10c01115 	stw	r3,68(r2)
            return e;
 824067c:	e0bffd17 	ldw	r2,-12(fp)
 8240680:	00001406 	br	82406d4 <ip_fragment+0x5b0>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 8240684:	e0bff38b 	ldhu	r2,-50(fp)
 8240688:	10800044 	addi	r2,r2,1
 824068c:	e0bff38d 	sth	r2,-50(fp)
 8240690:	e0fff38b 	ldhu	r3,-50(fp)
 8240694:	e0bff30b 	ldhu	r2,-52(fp)
 8240698:	18bf3e36 	bltu	r3,r2,8240394 <ip_fragment+0x270>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824069c:	01000084 	movi	r4,2
 82406a0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 82406a4:	e13ffe17 	ldw	r4,-8(fp)
 82406a8:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82406ac:	01000084 	movi	r4,2
 82406b0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 82406b4:	008209b4 	movhi	r2,2086
 82406b8:	10b98004 	addi	r2,r2,-6656
 82406bc:	10801017 	ldw	r2,64(r2)
 82406c0:	10c00044 	addi	r3,r2,1
 82406c4:	008209b4 	movhi	r2,2086
 82406c8:	10b98004 	addi	r2,r2,-6656
 82406cc:	10c01015 	stw	r3,64(r2)

   return 0;
 82406d0:	0005883a 	mov	r2,zero
}
 82406d4:	e037883a 	mov	sp,fp
 82406d8:	dfc00117 	ldw	ra,4(sp)
 82406dc:	df000017 	ldw	fp,0(sp)
 82406e0:	dec00204 	addi	sp,sp,8
 82406e4:	f800283a 	ret

082406e8 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 82406e8:	defffa04 	addi	sp,sp,-24
 82406ec:	dfc00515 	stw	ra,20(sp)
 82406f0:	df000415 	stw	fp,16(sp)
 82406f4:	df000404 	addi	fp,sp,16
 82406f8:	e13fff15 	stw	r4,-4(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 82406fc:	e0bffe04 	addi	r2,fp,-8
 8240700:	100b883a 	mov	r5,r2
 8240704:	e13fff17 	ldw	r4,-4(fp)
 8240708:	8240a340 	call	8240a34 <iproute>
 824070c:	e0bffd15 	stw	r2,-12(fp)
   if (tnet == 0)
 8240710:	e0bffd17 	ldw	r2,-12(fp)
 8240714:	1000161e 	bne	r2,zero,8240770 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 8240718:	d0a08317 	ldw	r2,-32244(gp)
 824071c:	1080050c 	andi	r2,r2,20
 8240720:	10001126 	beq	r2,zero,8240768 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 8240724:	e0bfff17 	ldw	r2,-4(fp)
 8240728:	10c03fcc 	andi	r3,r2,255
 824072c:	e0bfff17 	ldw	r2,-4(fp)
 8240730:	1004d23a 	srli	r2,r2,8
 8240734:	11003fcc 	andi	r4,r2,255
 8240738:	e0bfff17 	ldw	r2,-4(fp)
 824073c:	1004d43a 	srli	r2,r2,16
 8240740:	11403fcc 	andi	r5,r2,255
 8240744:	e0bfff17 	ldw	r2,-4(fp)
 8240748:	1004d63a 	srli	r2,r2,24
 824074c:	d8800015 	stw	r2,0(sp)
 8240750:	280f883a 	mov	r7,r5
 8240754:	200d883a 	mov	r6,r4
 8240758:	180b883a 	mov	r5,r3
 824075c:	01020974 	movhi	r4,2085
 8240760:	2103b104 	addi	r4,r4,3780
 8240764:	82030ec0 	call	82030ec <printf>
#endif   /* NPDEBUG */
      return 0L;
 8240768:	0005883a 	mov	r2,zero
 824076c:	00000206 	br	8240778 <ip_mymach+0x90>
   }
   return tnet->n_ipaddr;
 8240770:	e0bffd17 	ldw	r2,-12(fp)
 8240774:	10800a17 	ldw	r2,40(r2)
#endif /* MULTI_HOMED */
}
 8240778:	e037883a 	mov	sp,fp
 824077c:	dfc00117 	ldw	ra,4(sp)
 8240780:	df000017 	ldw	fp,0(sp)
 8240784:	dec00204 	addi	sp,sp,8
 8240788:	f800283a 	ret

0824078c <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 824078c:	defff704 	addi	sp,sp,-36
 8240790:	dfc00815 	stw	ra,32(sp)
 8240794:	df000715 	stw	fp,28(sp)
 8240798:	df000704 	addi	fp,sp,28
 824079c:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 82407a0:	e0bfff17 	ldw	r2,-4(fp)
 82407a4:	10800317 	ldw	r2,12(r2)
 82407a8:	e0bffc15 	stw	r2,-16(fp)
   osum = pip->ip_chksum;
 82407ac:	e0bffc17 	ldw	r2,-16(fp)
 82407b0:	1080028b 	ldhu	r2,10(r2)
 82407b4:	e0bffd0d 	sth	r2,-12(fp)
   pip->ip_chksum = 0;
 82407b8:	e0bffc17 	ldw	r2,-16(fp)
 82407bc:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 82407c0:	e0bffc17 	ldw	r2,-16(fp)
 82407c4:	10800003 	ldbu	r2,0(r2)
 82407c8:	10803fcc 	andi	r2,r2,255
 82407cc:	108003cc 	andi	r2,r2,15
 82407d0:	1085883a 	add	r2,r2,r2
 82407d4:	1085883a 	add	r2,r2,r2
 82407d8:	1005d07a 	srai	r2,r2,1
 82407dc:	100b883a 	mov	r5,r2
 82407e0:	e13ffc17 	ldw	r4,-16(fp)
 82407e4:	82285000 	call	8228500 <cksum>
 82407e8:	0084303a 	nor	r2,zero,r2
 82407ec:	e0bffd8d 	sth	r2,-10(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 82407f0:	e0fffd0b 	ldhu	r3,-12(fp)
 82407f4:	e0bffd8b 	ldhu	r2,-10(fp)
 82407f8:	18800126 	beq	r3,r2,8240800 <ip_dump+0x74>
   {
      dtrap();
 82407fc:	822d2e00 	call	822d2e0 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 8240800:	01420974 	movhi	r5,2085
 8240804:	2943ba04 	addi	r5,r5,3816
 8240808:	0009883a 	mov	r4,zero
 824080c:	8228bac0 	call	8228bac <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 8240810:	e0bffc17 	ldw	r2,-16(fp)
 8240814:	e0bffe15 	stw	r2,-8(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240818:	e0bffe17 	ldw	r2,-8(fp)
 824081c:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240820:	11403fcc 	andi	r5,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240824:	e0bffe17 	ldw	r2,-8(fp)
 8240828:	10800044 	addi	r2,r2,1
 824082c:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240830:	11803fcc 	andi	r6,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240834:	e0bffc17 	ldw	r2,-16(fp)
 8240838:	1080008b 	ldhu	r2,2(r2)
 824083c:	10bfffcc 	andi	r2,r2,65535
 8240840:	1004d23a 	srli	r2,r2,8
 8240844:	10bfffcc 	andi	r2,r2,65535
 8240848:	10c03fcc 	andi	r3,r2,255
 824084c:	e0bffc17 	ldw	r2,-16(fp)
 8240850:	1080008b 	ldhu	r2,2(r2)
 8240854:	10bfffcc 	andi	r2,r2,65535
 8240858:	1004923a 	slli	r2,r2,8
 824085c:	10bfffcc 	andi	r2,r2,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240860:	1884b03a 	or	r2,r3,r2
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240864:	e0fffc17 	ldw	r3,-16(fp)
 8240868:	18c0010b 	ldhu	r3,4(r3)
 824086c:	18ffffcc 	andi	r3,r3,65535
 8240870:	1806d23a 	srli	r3,r3,8
 8240874:	18ffffcc 	andi	r3,r3,65535
 8240878:	19003fcc 	andi	r4,r3,255
 824087c:	e0fffc17 	ldw	r3,-16(fp)
 8240880:	18c0010b 	ldhu	r3,4(r3)
 8240884:	18ffffcc 	andi	r3,r3,65535
 8240888:	1806923a 	slli	r3,r3,8
 824088c:	18ffffcc 	andi	r3,r3,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240890:	20c6b03a 	or	r3,r4,r3
 8240894:	d8c00115 	stw	r3,4(sp)
 8240898:	d8800015 	stw	r2,0(sp)
 824089c:	300f883a 	mov	r7,r6
 82408a0:	280d883a 	mov	r6,r5
 82408a4:	01420974 	movhi	r5,2085
 82408a8:	2943bf04 	addi	r5,r5,3836
 82408ac:	0009883a 	mov	r4,zero
 82408b0:	8228bac0 	call	8228bac <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 82408b4:	e0bffe17 	ldw	r2,-8(fp)
 82408b8:	10800184 	addi	r2,r2,6
 82408bc:	1080000b 	ldhu	r2,0(r2)
 82408c0:	10bfffcc 	andi	r2,r2,65535
 82408c4:	1004d23a 	srli	r2,r2,8
 82408c8:	10bfffcc 	andi	r2,r2,65535
 82408cc:	10c03fcc 	andi	r3,r2,255
 82408d0:	e0bffe17 	ldw	r2,-8(fp)
 82408d4:	10800184 	addi	r2,r2,6
 82408d8:	1080000b 	ldhu	r2,0(r2)
 82408dc:	10bfffcc 	andi	r2,r2,65535
 82408e0:	1004923a 	slli	r2,r2,8
 82408e4:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 82408e8:	188cb03a 	or	r6,r3,r2
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 82408ec:	e0bffc17 	ldw	r2,-16(fp)
 82408f0:	10800203 	ldbu	r2,8(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 82408f4:	11c03fcc 	andi	r7,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 82408f8:	e0bffc17 	ldw	r2,-16(fp)
 82408fc:	10800243 	ldbu	r2,9(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240900:	10c03fcc 	andi	r3,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
 8240904:	e0bffd0b 	ldhu	r2,-12(fp)
 8240908:	1004d23a 	srli	r2,r2,8
 824090c:	10bfffcc 	andi	r2,r2,65535
 8240910:	11003fcc 	andi	r4,r2,255
 8240914:	e0bffd0b 	ldhu	r2,-12(fp)
 8240918:	1004923a 	slli	r2,r2,8
 824091c:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240920:	2088b03a 	or	r4,r4,r2
 8240924:	e17ffd0b 	ldhu	r5,-12(fp)
 8240928:	e0bffd8b 	ldhu	r2,-10(fp)
 824092c:	2880031e 	bne	r5,r2,824093c <ip_dump+0x1b0>
 8240930:	00820974 	movhi	r2,2085
 8240934:	1083cb04 	addi	r2,r2,3884
 8240938:	00000206 	br	8240944 <ip_dump+0x1b8>
 824093c:	00820974 	movhi	r2,2085
 8240940:	1083cc04 	addi	r2,r2,3888
 8240944:	d8800215 	stw	r2,8(sp)
 8240948:	d9000115 	stw	r4,4(sp)
 824094c:	d8c00015 	stw	r3,0(sp)
 8240950:	01420974 	movhi	r5,2085
 8240954:	2943cd04 	addi	r5,r5,3892
 8240958:	0009883a 	mov	r4,zero
 824095c:	8228bac0 	call	8228bac <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 8240960:	e0bffc17 	ldw	r2,-16(fp)
 8240964:	10800317 	ldw	r2,12(r2)
 8240968:	11003fcc 	andi	r4,r2,255
 824096c:	e0bffc17 	ldw	r2,-16(fp)
 8240970:	10800317 	ldw	r2,12(r2)
 8240974:	1004d23a 	srli	r2,r2,8
 8240978:	11403fcc 	andi	r5,r2,255
 824097c:	e0bffc17 	ldw	r2,-16(fp)
 8240980:	10800317 	ldw	r2,12(r2)
 8240984:	1004d43a 	srli	r2,r2,16
 8240988:	10803fcc 	andi	r2,r2,255
 824098c:	e0fffc17 	ldw	r3,-16(fp)
 8240990:	18c00317 	ldw	r3,12(r3)
 8240994:	1806d63a 	srli	r3,r3,24
 8240998:	d8c00115 	stw	r3,4(sp)
 824099c:	d8800015 	stw	r2,0(sp)
 82409a0:	280f883a 	mov	r7,r5
 82409a4:	200d883a 	mov	r6,r4
 82409a8:	01420974 	movhi	r5,2085
 82409ac:	2943dd04 	addi	r5,r5,3956
 82409b0:	0009883a 	mov	r4,zero
 82409b4:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 82409b8:	e0bffc17 	ldw	r2,-16(fp)
 82409bc:	10800417 	ldw	r2,16(r2)
 82409c0:	11003fcc 	andi	r4,r2,255
 82409c4:	e0bffc17 	ldw	r2,-16(fp)
 82409c8:	10800417 	ldw	r2,16(r2)
 82409cc:	1004d23a 	srli	r2,r2,8
 82409d0:	11403fcc 	andi	r5,r2,255
 82409d4:	e0bffc17 	ldw	r2,-16(fp)
 82409d8:	10800417 	ldw	r2,16(r2)
 82409dc:	1004d43a 	srli	r2,r2,16
 82409e0:	10803fcc 	andi	r2,r2,255
 82409e4:	e0fffc17 	ldw	r3,-16(fp)
 82409e8:	18c00417 	ldw	r3,16(r3)
 82409ec:	1806d63a 	srli	r3,r3,24
 82409f0:	d8c00115 	stw	r3,4(sp)
 82409f4:	d8800015 	stw	r2,0(sp)
 82409f8:	280f883a 	mov	r7,r5
 82409fc:	200d883a 	mov	r6,r4
 8240a00:	01420974 	movhi	r5,2085
 8240a04:	2943e204 	addi	r5,r5,3976
 8240a08:	0009883a 	mov	r4,zero
 8240a0c:	8228bac0 	call	8228bac <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 8240a10:	e0bffc17 	ldw	r2,-16(fp)
 8240a14:	e0fffd0b 	ldhu	r3,-12(fp)
 8240a18:	10c0028d 	sth	r3,10(r2)
}
 8240a1c:	0001883a 	nop
 8240a20:	e037883a 	mov	sp,fp
 8240a24:	dfc00117 	ldw	ra,4(sp)
 8240a28:	df000017 	ldw	fp,0(sp)
 8240a2c:	dec00204 	addi	sp,sp,8
 8240a30:	f800283a 	ret

08240a34 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 8240a34:	defff804 	addi	sp,sp,-32
 8240a38:	dfc00715 	stw	ra,28(sp)
 8240a3c:	df000615 	stw	fp,24(sp)
 8240a40:	df000604 	addi	fp,sp,24
 8240a44:	e13ffe15 	stw	r4,-8(fp)
 8240a48:	e17fff15 	stw	r5,-4(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 8240a4c:	e0bffe17 	ldw	r2,-8(fp)
 8240a50:	1000021e 	bne	r2,zero,8240a5c <iproute+0x28>
      return NULL;
 8240a54:	0005883a 	mov	r2,zero
 8240a58:	00006706 	br	8240bf8 <iproute+0x1c4>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 8240a5c:	d0a0c617 	ldw	r2,-31976(gp)
 8240a60:	1000021e 	bne	r2,zero,8240a6c <iproute+0x38>
      return NULL;
 8240a64:	0005883a 	mov	r2,zero
 8240a68:	00006306 	br	8240bf8 <iproute+0x1c4>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 8240a6c:	d0a0d017 	ldw	r2,-31936(gp)
 8240a70:	10000e26 	beq	r2,zero,8240aac <iproute+0x78>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 8240a74:	d0a0d017 	ldw	r2,-31936(gp)
 8240a78:	10c00017 	ldw	r3,0(r2)
 8240a7c:	e0bffe17 	ldw	r2,-8(fp)
 8240a80:	18800a1e 	bne	r3,r2,8240aac <iproute+0x78>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 8240a84:	d0a0d017 	ldw	r2,-31936(gp)
 8240a88:	10c00617 	ldw	r3,24(r2)
 8240a8c:	e0bfff17 	ldw	r2,-4(fp)
 8240a90:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 8240a94:	d0a0d017 	ldw	r2,-31936(gp)
 8240a98:	d0e0a817 	ldw	r3,-32096(gp)
 8240a9c:	10c00915 	stw	r3,36(r2)
         return(cachedRoute->ifp); /* net to send on */
 8240aa0:	d0a0d017 	ldw	r2,-31936(gp)
 8240aa4:	10800e17 	ldw	r2,56(r2)
 8240aa8:	00005306 	br	8240bf8 <iproute+0x1c4>
      }
   }

   rtp = rt_lookup(host);
 8240aac:	e13ffe17 	ldw	r4,-8(fp)
 8240ab0:	8243f280 	call	8243f28 <rt_lookup>
 8240ab4:	e0bffd15 	stw	r2,-12(fp)
   if(rtp)
 8240ab8:	e0bffd17 	ldw	r2,-12(fp)
 8240abc:	10000926 	beq	r2,zero,8240ae4 <iproute+0xb0>
   {
      cachedRoute = rtp;
 8240ac0:	e0bffd17 	ldw	r2,-12(fp)
 8240ac4:	d0a0d015 	stw	r2,-31936(gp)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 8240ac8:	e0bffd17 	ldw	r2,-12(fp)
 8240acc:	10c00617 	ldw	r3,24(r2)
 8240ad0:	e0bfff17 	ldw	r2,-4(fp)
 8240ad4:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 8240ad8:	e0bffd17 	ldw	r2,-12(fp)
 8240adc:	10800e17 	ldw	r2,56(r2)
 8240ae0:	00004506 	br	8240bf8 <iproute+0x1c4>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 8240ae4:	008209b4 	movhi	r2,2086
 8240ae8:	10b97b04 	addi	r2,r2,-6676
 8240aec:	10800017 	ldw	r2,0(r2)
 8240af0:	e0bffc15 	stw	r2,-16(fp)
   i = 0;
 8240af4:	e03ffb15 	stw	zero,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240af8:	00002406 	br	8240b8c <iproute+0x158>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240afc:	e0bffc17 	ldw	r2,-16(fp)
 8240b00:	10800c17 	ldw	r2,48(r2)
 8240b04:	10001b26 	beq	r2,zero,8240b74 <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
 8240b08:	e0bffc17 	ldw	r2,-16(fp)
 8240b0c:	10800a17 	ldw	r2,40(r2)
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240b10:	10001826 	beq	r2,zero,8240b74 <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
 8240b14:	e0bffc17 	ldw	r2,-16(fp)
 8240b18:	10c00a17 	ldw	r3,40(r2)
 8240b1c:	e0bffe17 	ldw	r2,-8(fp)
 8240b20:	1886f03a 	xor	r3,r3,r2
 8240b24:	e0bffc17 	ldw	r2,-16(fp)
 8240b28:	10800c17 	ldw	r2,48(r2)
 8240b2c:	1884703a 	and	r2,r3,r2
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
         (ifp->n_ipaddr != 0) && 
 8240b30:	1000101e 	bne	r2,zero,8240b74 <iproute+0x140>
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 8240b34:	00800044 	movi	r2,1
 8240b38:	d8800015 	stw	r2,0(sp)
 8240b3c:	e1fffb17 	ldw	r7,-20(fp)
 8240b40:	e1bffe17 	ldw	r6,-8(fp)
 8240b44:	017fffc4 	movi	r5,-1
 8240b48:	e13ffe17 	ldw	r4,-8(fp)
 8240b4c:	824407c0 	call	824407c <add_route>
 8240b50:	d0a0d015 	stw	r2,-31936(gp)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 8240b54:	d0a0d017 	ldw	r2,-31936(gp)
 8240b58:	1000011e 	bne	r2,zero,8240b60 <iproute+0x12c>
            dtrap();
 8240b5c:	822d2e00 	call	822d2e0 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 8240b60:	e0bfff17 	ldw	r2,-4(fp)
 8240b64:	e0fffe17 	ldw	r3,-8(fp)
 8240b68:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240b6c:	e0bffc17 	ldw	r2,-16(fp)
 8240b70:	00002106 	br	8240bf8 <iproute+0x1c4>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240b74:	e0bffc17 	ldw	r2,-16(fp)
 8240b78:	10800017 	ldw	r2,0(r2)
 8240b7c:	e0bffc15 	stw	r2,-16(fp)
 8240b80:	e0bffb17 	ldw	r2,-20(fp)
 8240b84:	10800044 	addi	r2,r2,1
 8240b88:	e0bffb15 	stw	r2,-20(fp)
 8240b8c:	e0bffc17 	ldw	r2,-16(fp)
 8240b90:	103fda1e 	bne	r2,zero,8240afc <iproute+0xc8>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 8240b94:	008209b4 	movhi	r2,2086
 8240b98:	10b97b04 	addi	r2,r2,-6676
 8240b9c:	10800017 	ldw	r2,0(r2)
 8240ba0:	e0bffc15 	stw	r2,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240ba4:	00000c06 	br	8240bd8 <iproute+0x1a4>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 8240ba8:	e0bffc17 	ldw	r2,-16(fp)
 8240bac:	10800d17 	ldw	r2,52(r2)
 8240bb0:	10000626 	beq	r2,zero,8240bcc <iproute+0x198>
      {
         *hop1 = ifp->n_defgw;
 8240bb4:	e0bffc17 	ldw	r2,-16(fp)
 8240bb8:	10c00d17 	ldw	r3,52(r2)
 8240bbc:	e0bfff17 	ldw	r2,-4(fp)
 8240bc0:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240bc4:	e0bffc17 	ldw	r2,-16(fp)
 8240bc8:	00000b06 	br	8240bf8 <iproute+0x1c4>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240bcc:	e0bffc17 	ldw	r2,-16(fp)
 8240bd0:	10800017 	ldw	r2,0(r2)
 8240bd4:	e0bffc15 	stw	r2,-16(fp)
 8240bd8:	e0bffc17 	ldw	r2,-16(fp)
 8240bdc:	103ff21e 	bne	r2,zero,8240ba8 <iproute+0x174>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 8240be0:	e0bfff17 	ldw	r2,-4(fp)
 8240be4:	e0fffe17 	ldw	r3,-8(fp)
 8240be8:	10c00015 	stw	r3,0(r2)
   return((NET)(netlist.q_head));
 8240bec:	008209b4 	movhi	r2,2086
 8240bf0:	10b97b04 	addi	r2,r2,-6676
 8240bf4:	10800017 	ldw	r2,0(r2)
#endif   /* STRICT_SUBNETTING */
}
 8240bf8:	e037883a 	mov	sp,fp
 8240bfc:	dfc00117 	ldw	ra,4(sp)
 8240c00:	df000017 	ldw	fp,0(sp)
 8240c04:	dec00204 	addi	sp,sp,8
 8240c08:	f800283a 	ret

08240c0c <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 8240c0c:	defffb04 	addi	sp,sp,-20
 8240c10:	dfc00415 	stw	ra,16(sp)
 8240c14:	df000315 	stw	fp,12(sp)
 8240c18:	df000304 	addi	fp,sp,12
 8240c1c:	e13fff15 	stw	r4,-4(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 8240c20:	e0bfff17 	ldw	r2,-4(fp)
 8240c24:	10800417 	ldw	r2,16(r2)
 8240c28:	e0ffff17 	ldw	r3,-4(fp)
 8240c2c:	18c00317 	ldw	r3,12(r3)
 8240c30:	1809883a 	mov	r4,r3
 8240c34:	e0ffff17 	ldw	r3,-4(fp)
 8240c38:	18c00117 	ldw	r3,4(r3)
 8240c3c:	20c7c83a 	sub	r3,r4,r3
 8240c40:	10c5883a 	add	r2,r2,r3
 8240c44:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8240c48:	01000084 	movi	r4,2
 8240c4c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 8240c50:	e0bffd17 	ldw	r2,-12(fp)
 8240c54:	1009883a 	mov	r4,r2
 8240c58:	822c7380 	call	822c738 <pk_alloc>
 8240c5c:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240c60:	01000084 	movi	r4,2
 8240c64:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 8240c68:	e0bffe17 	ldw	r2,-8(fp)
 8240c6c:	1000061e 	bne	r2,zero,8240c88 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 8240c70:	e17ffd17 	ldw	r5,-12(fp)
 8240c74:	01020974 	movhi	r4,2085
 8240c78:	2103e704 	addi	r4,r4,3996
 8240c7c:	82030ec0 	call	82030ec <printf>
#endif
      return NULL;
 8240c80:	0005883a 	mov	r2,zero
 8240c84:	00002906 	br	8240d2c <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 8240c88:	e0bffe17 	ldw	r2,-8(fp)
 8240c8c:	10c00117 	ldw	r3,4(r2)
 8240c90:	e0bfff17 	ldw	r2,-4(fp)
 8240c94:	10800117 	ldw	r2,4(r2)
 8240c98:	e13ffd17 	ldw	r4,-12(fp)
 8240c9c:	200d883a 	mov	r6,r4
 8240ca0:	100b883a 	mov	r5,r2
 8240ca4:	1809883a 	mov	r4,r3
 8240ca8:	8202c5c0 	call	8202c5c <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 8240cac:	e0bffe17 	ldw	r2,-8(fp)
 8240cb0:	10800117 	ldw	r2,4(r2)
 8240cb4:	e0ffff17 	ldw	r3,-4(fp)
 8240cb8:	18c00317 	ldw	r3,12(r3)
 8240cbc:	1809883a 	mov	r4,r3
 8240cc0:	e0ffff17 	ldw	r3,-4(fp)
 8240cc4:	18c00117 	ldw	r3,4(r3)
 8240cc8:	20c7c83a 	sub	r3,r4,r3
 8240ccc:	10c7883a 	add	r3,r2,r3
 8240cd0:	e0bffe17 	ldw	r2,-8(fp)
 8240cd4:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 8240cd8:	e0bfff17 	ldw	r2,-4(fp)
 8240cdc:	10c00417 	ldw	r3,16(r2)
 8240ce0:	e0bffe17 	ldw	r2,-8(fp)
 8240ce4:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 8240ce8:	e0bfff17 	ldw	r2,-4(fp)
 8240cec:	10c00617 	ldw	r3,24(r2)
 8240cf0:	e0bffe17 	ldw	r2,-8(fp)
 8240cf4:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 8240cf8:	e0bfff17 	ldw	r2,-4(fp)
 8240cfc:	10c00717 	ldw	r3,28(r2)
 8240d00:	e0bffe17 	ldw	r2,-8(fp)
 8240d04:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 8240d08:	e0bfff17 	ldw	r2,-4(fp)
 8240d0c:	10c0080b 	ldhu	r3,32(r2)
 8240d10:	e0bffe17 	ldw	r2,-8(fp)
 8240d14:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 8240d18:	e0bfff17 	ldw	r2,-4(fp)
 8240d1c:	10c00517 	ldw	r3,20(r2)
 8240d20:	e0bffe17 	ldw	r2,-8(fp)
 8240d24:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 8240d28:	e0bffe17 	ldw	r2,-8(fp)
}
 8240d2c:	e037883a 	mov	sp,fp
 8240d30:	dfc00117 	ldw	ra,4(sp)
 8240d34:	df000017 	ldw	fp,0(sp)
 8240d38:	dec00204 	addi	sp,sp,8
 8240d3c:	f800283a 	ret

08240d40 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 8240d40:	defffa04 	addi	sp,sp,-24
 8240d44:	df000515 	stw	fp,20(sp)
 8240d48:	df000504 	addi	fp,sp,20
 8240d4c:	e13fff15 	stw	r4,-4(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 8240d50:	e0bfff17 	ldw	r2,-4(fp)
 8240d54:	10800317 	ldw	r2,12(r2)
 8240d58:	e0bffc15 	stw	r2,-16(fp)
   dest = pip->ip_dest;
 8240d5c:	e0bfff17 	ldw	r2,-4(fp)
 8240d60:	10800417 	ldw	r2,16(r2)
 8240d64:	e0bffd15 	stw	r2,-12(fp)
   prot = pip->ip_prot;
 8240d68:	e0bfff17 	ldw	r2,-4(fp)
 8240d6c:	10800243 	ldbu	r2,9(r2)
 8240d70:	e0bffe05 	stb	r2,-8(fp)
   id = pip->ip_id;
 8240d74:	e0bfff17 	ldw	r2,-4(fp)
 8240d78:	1080010b 	ldhu	r2,4(r2)
 8240d7c:	e0bffe8d 	sth	r2,-6(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8240d80:	d0a0c817 	ldw	r2,-31968(gp)
 8240d84:	e0bffb15 	stw	r2,-20(fp)
 8240d88:	00001706 	br	8240de8 <ip_reasm_match_frag_with_ire+0xa8>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8240d8c:	e0bffb17 	ldw	r2,-20(fp)
 8240d90:	10c00117 	ldw	r3,4(r2)
 8240d94:	e0bffc17 	ldw	r2,-16(fp)
 8240d98:	1880101e 	bne	r3,r2,8240ddc <ip_reasm_match_frag_with_ire+0x9c>
 8240d9c:	e0bffb17 	ldw	r2,-20(fp)
 8240da0:	10c00217 	ldw	r3,8(r2)
 8240da4:	e0bffd17 	ldw	r2,-12(fp)
 8240da8:	18800c1e 	bne	r3,r2,8240ddc <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8240dac:	e0bffb17 	ldw	r2,-20(fp)
 8240db0:	10800383 	ldbu	r2,14(r2)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8240db4:	10c03fcc 	andi	r3,r2,255
 8240db8:	e0bffe03 	ldbu	r2,-8(fp)
 8240dbc:	1880071e 	bne	r3,r2,8240ddc <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8240dc0:	e0bffb17 	ldw	r2,-20(fp)
 8240dc4:	1080030b 	ldhu	r2,12(r2)
 8240dc8:	10ffffcc 	andi	r3,r2,65535
 8240dcc:	e0bffe8b 	ldhu	r2,-6(fp)
 8240dd0:	1880021e 	bne	r3,r2,8240ddc <ip_reasm_match_frag_with_ire+0x9c>
         {
         return tmpp; /* we've found a match */
 8240dd4:	e0bffb17 	ldw	r2,-20(fp)
 8240dd8:	00000606 	br	8240df4 <ip_reasm_match_frag_with_ire+0xb4>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8240ddc:	e0bffb17 	ldw	r2,-20(fp)
 8240de0:	10800017 	ldw	r2,0(r2)
 8240de4:	e0bffb15 	stw	r2,-20(fp)
 8240de8:	e0bffb17 	ldw	r2,-20(fp)
 8240dec:	103fe71e 	bne	r2,zero,8240d8c <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 8240df0:	0005883a 	mov	r2,zero
}
 8240df4:	e037883a 	mov	sp,fp
 8240df8:	df000017 	ldw	fp,0(sp)
 8240dfc:	dec00104 	addi	sp,sp,4
 8240e00:	f800283a 	ret

08240e04 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 8240e04:	defffc04 	addi	sp,sp,-16
 8240e08:	df000315 	stw	fp,12(sp)
 8240e0c:	df000304 	addi	fp,sp,12
 8240e10:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 8240e14:	e0bfff17 	ldw	r2,-4(fp)
 8240e18:	1080018b 	ldhu	r2,6(r2)
 8240e1c:	10bfffcc 	andi	r2,r2,65535
 8240e20:	1004d23a 	srli	r2,r2,8
 8240e24:	10bfffcc 	andi	r2,r2,65535
 8240e28:	10c03fcc 	andi	r3,r2,255
 8240e2c:	e0bfff17 	ldw	r2,-4(fp)
 8240e30:	1080018b 	ldhu	r2,6(r2)
 8240e34:	10bfffcc 	andi	r2,r2,65535
 8240e38:	1004923a 	slli	r2,r2,8
 8240e3c:	10bfffcc 	andi	r2,r2,65535
 8240e40:	1884b03a 	or	r2,r3,r2
 8240e44:	1088000c 	andi	r2,r2,8192
 8240e48:	1005d37a 	srai	r2,r2,13
 8240e4c:	e0bffe0d 	sth	r2,-8(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 8240e50:	e0bfff17 	ldw	r2,-4(fp)
 8240e54:	1080018b 	ldhu	r2,6(r2)
 8240e58:	10bfffcc 	andi	r2,r2,65535
 8240e5c:	1004d23a 	srli	r2,r2,8
 8240e60:	1007883a 	mov	r3,r2
 8240e64:	e0bfff17 	ldw	r2,-4(fp)
 8240e68:	1080018b 	ldhu	r2,6(r2)
 8240e6c:	10bfffcc 	andi	r2,r2,65535
 8240e70:	1004923a 	slli	r2,r2,8
 8240e74:	1884b03a 	or	r2,r3,r2
 8240e78:	1087ffcc 	andi	r2,r2,8191
 8240e7c:	e0bffe8d 	sth	r2,-6(fp)

  if (mf == 0)
 8240e80:	e0bffe0b 	ldhu	r2,-8(fp)
 8240e84:	1000071e 	bne	r2,zero,8240ea4 <ip_reasm_determine_type_of_frag+0xa0>
     {
     if (foff == 0) {rc = IP_CP;}
 8240e88:	e0bffe8b 	ldhu	r2,-6(fp)
 8240e8c:	1000021e 	bne	r2,zero,8240e98 <ip_reasm_determine_type_of_frag+0x94>
 8240e90:	e03ffd15 	stw	zero,-12(fp)
 8240e94:	00000a06 	br	8240ec0 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_LF;}
 8240e98:	00800144 	movi	r2,5
 8240e9c:	e0bffd15 	stw	r2,-12(fp)
 8240ea0:	00000706 	br	8240ec0 <ip_reasm_determine_type_of_frag+0xbc>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 8240ea4:	e0bffe8b 	ldhu	r2,-6(fp)
 8240ea8:	1000031e 	bne	r2,zero,8240eb8 <ip_reasm_determine_type_of_frag+0xb4>
 8240eac:	00800044 	movi	r2,1
 8240eb0:	e0bffd15 	stw	r2,-12(fp)
 8240eb4:	00000206 	br	8240ec0 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_MF;}
 8240eb8:	008000c4 	movi	r2,3
 8240ebc:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 8240ec0:	e0bffd17 	ldw	r2,-12(fp)
}
 8240ec4:	e037883a 	mov	sp,fp
 8240ec8:	df000017 	ldw	fp,0(sp)
 8240ecc:	dec00104 	addi	sp,sp,4
 8240ed0:	f800283a 	ret

08240ed4 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 8240ed4:	defffe04 	addi	sp,sp,-8
 8240ed8:	df000115 	stw	fp,4(sp)
 8240edc:	df000104 	addi	fp,sp,4
 8240ee0:	2005883a 	mov	r2,r4
 8240ee4:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8240ee8:	d0a0c717 	ldw	r2,-31972(gp)
 8240eec:	00c001b4 	movhi	r3,6
 8240ef0:	1880072e 	bgeu	r3,r2,8240f10 <ip_reasm_check_mem_useage+0x3c>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8240ef4:	008209b4 	movhi	r2,2086
 8240ef8:	10b99404 	addi	r2,r2,-6576
 8240efc:	10800217 	ldw	r2,8(r2)
 8240f00:	10c00044 	addi	r3,r2,1
 8240f04:	008209b4 	movhi	r2,2086
 8240f08:	10b99404 	addi	r2,r2,-6576
 8240f0c:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8240f10:	d0e0c717 	ldw	r3,-31972(gp)
 8240f14:	008001b4 	movhi	r2,6
 8240f18:	18800526 	beq	r3,r2,8240f30 <ip_reasm_check_mem_useage+0x5c>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
 8240f1c:	e0ffff0b 	ldhu	r3,-4(fp)
 8240f20:	d0a0c717 	ldw	r2,-31972(gp)
 8240f24:	1885883a 	add	r2,r3,r2
      ++ire_stats.bad_max_mem;
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8240f28:	00c001b4 	movhi	r3,6
 8240f2c:	1880092e 	bgeu	r3,r2,8240f54 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 8240f30:	008209b4 	movhi	r2,2086
 8240f34:	10b99404 	addi	r2,r2,-6576
 8240f38:	10800317 	ldw	r2,12(r2)
 8240f3c:	10c00044 	addi	r3,r2,1
 8240f40:	008209b4 	movhi	r2,2086
 8240f44:	10b99404 	addi	r2,r2,-6576
 8240f48:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 8240f4c:	00bffa84 	movi	r2,-22
 8240f50:	00000106 	br	8240f58 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 8240f54:	0005883a 	mov	r2,zero
}
 8240f58:	e037883a 	mov	sp,fp
 8240f5c:	df000017 	ldw	fp,0(sp)
 8240f60:	dec00104 	addi	sp,sp,4
 8240f64:	f800283a 	ret

08240f68 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 8240f68:	defffe04 	addi	sp,sp,-8
 8240f6c:	df000115 	stw	fp,4(sp)
 8240f70:	df000104 	addi	fp,sp,4
 8240f74:	2005883a 	mov	r2,r4
 8240f78:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8240f7c:	d0a0c717 	ldw	r2,-31972(gp)
 8240f80:	00c001b4 	movhi	r3,6
 8240f84:	1880092e 	bgeu	r3,r2,8240fac <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8240f88:	008209b4 	movhi	r2,2086
 8240f8c:	10b99404 	addi	r2,r2,-6576
 8240f90:	10800217 	ldw	r2,8(r2)
 8240f94:	10c00044 	addi	r3,r2,1
 8240f98:	008209b4 	movhi	r2,2086
 8240f9c:	10b99404 	addi	r2,r2,-6576
 8240fa0:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 8240fa4:	00bffa84 	movi	r2,-22
 8240fa8:	00001306 	br	8240ff8 <ip_reasm_incr_mem_useage+0x90>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 8240fac:	e0ffff0b 	ldhu	r3,-4(fp)
 8240fb0:	d0a0c717 	ldw	r2,-31972(gp)
 8240fb4:	1885883a 	add	r2,r3,r2
 8240fb8:	00c001b4 	movhi	r3,6
 8240fbc:	1880092e 	bgeu	r3,r2,8240fe4 <ip_reasm_incr_mem_useage+0x7c>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 8240fc0:	008209b4 	movhi	r2,2086
 8240fc4:	10b99404 	addi	r2,r2,-6576
 8240fc8:	10800417 	ldw	r2,16(r2)
 8240fcc:	10c00044 	addi	r3,r2,1
 8240fd0:	008209b4 	movhi	r2,2086
 8240fd4:	10b99404 	addi	r2,r2,-6576
 8240fd8:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 8240fdc:	00bffa84 	movi	r2,-22
 8240fe0:	00000506 	br	8240ff8 <ip_reasm_incr_mem_useage+0x90>
   }

   ipr_curr_mem += increment;
 8240fe4:	e0ffff0b 	ldhu	r3,-4(fp)
 8240fe8:	d0a0c717 	ldw	r2,-31972(gp)
 8240fec:	1885883a 	add	r2,r3,r2
 8240ff0:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 8240ff4:	0005883a 	mov	r2,zero
}
 8240ff8:	e037883a 	mov	sp,fp
 8240ffc:	df000017 	ldw	fp,0(sp)
 8241000:	dec00104 	addi	sp,sp,4
 8241004:	f800283a 	ret

08241008 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 8241008:	defffe04 	addi	sp,sp,-8
 824100c:	df000115 	stw	fp,4(sp)
 8241010:	df000104 	addi	fp,sp,4
 8241014:	2005883a 	mov	r2,r4
 8241018:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 824101c:	d0a0c717 	ldw	r2,-31972(gp)
 8241020:	00c001b4 	movhi	r3,6
 8241024:	1880092e 	bgeu	r3,r2,824104c <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8241028:	008209b4 	movhi	r2,2086
 824102c:	10b99404 	addi	r2,r2,-6576
 8241030:	10800217 	ldw	r2,8(r2)
 8241034:	10c00044 	addi	r3,r2,1
 8241038:	008209b4 	movhi	r2,2086
 824103c:	10b99404 	addi	r2,r2,-6576
 8241040:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 8241044:	00bffa84 	movi	r2,-22
 8241048:	00001106 	br	8241090 <ip_reasm_decr_mem_useage+0x88>
   }
   if (ipr_curr_mem < decrement)
 824104c:	e0bfff0b 	ldhu	r2,-4(fp)
 8241050:	d0e0c717 	ldw	r3,-31972(gp)
 8241054:	1880092e 	bgeu	r3,r2,824107c <ip_reasm_decr_mem_useage+0x74>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 8241058:	008209b4 	movhi	r2,2086
 824105c:	10b99404 	addi	r2,r2,-6576
 8241060:	10800517 	ldw	r2,20(r2)
 8241064:	10c00044 	addi	r3,r2,1
 8241068:	008209b4 	movhi	r2,2086
 824106c:	10b99404 	addi	r2,r2,-6576
 8241070:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 8241074:	00bffa84 	movi	r2,-22
 8241078:	00000506 	br	8241090 <ip_reasm_decr_mem_useage+0x88>
   }

   ipr_curr_mem -= decrement;
 824107c:	d0e0c717 	ldw	r3,-31972(gp)
 8241080:	e0bfff0b 	ldhu	r2,-4(fp)
 8241084:	1885c83a 	sub	r2,r3,r2
 8241088:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 824108c:	0005883a 	mov	r2,zero
}
 8241090:	e037883a 	mov	sp,fp
 8241094:	df000017 	ldw	fp,0(sp)
 8241098:	dec00104 	addi	sp,sp,4
 824109c:	f800283a 	ret

082410a0 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 82410a0:	defff704 	addi	sp,sp,-36
 82410a4:	dfc00815 	stw	ra,32(sp)
 82410a8:	df000715 	stw	fp,28(sp)
 82410ac:	df000704 	addi	fp,sp,28
 82410b0:	e13fff15 	stw	r4,-4(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 82410b4:	e0bfff17 	ldw	r2,-4(fp)
 82410b8:	10800217 	ldw	r2,8(r2)
 82410bc:	10802204 	addi	r2,r2,136
 82410c0:	10bfffcc 	andi	r2,r2,65535
 82410c4:	1009883a 	mov	r4,r2
 82410c8:	8240ed40 	call	8240ed4 <ip_reasm_check_mem_useage>
 82410cc:	e0bff915 	stw	r2,-28(fp)
 82410d0:	e0bff917 	ldw	r2,-28(fp)
 82410d4:	10000f26 	beq	r2,zero,8241114 <ip_reasm_process_first_fragment+0x74>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 82410d8:	01000084 	movi	r4,2
 82410dc:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free (p);
 82410e0:	e13fff17 	ldw	r4,-4(fp)
 82410e4:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82410e8:	01000084 	movi	r4,2
 82410ec:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 82410f0:	008209b4 	movhi	r2,2086
 82410f4:	10b98004 	addi	r2,r2,-6656
 82410f8:	10800f17 	ldw	r2,60(r2)
 82410fc:	10c00044 	addi	r3,r2,1
 8241100:	008209b4 	movhi	r2,2086
 8241104:	10b98004 	addi	r2,r2,-6656
 8241108:	10c00f15 	stw	r3,60(r2)
      return rc;
 824110c:	e0bff917 	ldw	r2,-28(fp)
 8241110:	00008c06 	br	8241344 <ip_reasm_process_first_fragment+0x2a4>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 8241114:	01002204 	movi	r4,136
 8241118:	822deb80 	call	822deb8 <npalloc>
 824111c:	e0bffa15 	stw	r2,-24(fp)
   if (irep == 0) 
 8241120:	e0bffa17 	ldw	r2,-24(fp)
 8241124:	10000f1e 	bne	r2,zero,8241164 <ip_reasm_process_first_fragment+0xc4>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241128:	01000084 	movi	r4,2
 824112c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241130:	e13fff17 	ldw	r4,-4(fp)
 8241134:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241138:	01000084 	movi	r4,2
 824113c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241140:	008209b4 	movhi	r2,2086
 8241144:	10b98004 	addi	r2,r2,-6656
 8241148:	10800f17 	ldw	r2,60(r2)
 824114c:	10c00044 	addi	r3,r2,1
 8241150:	008209b4 	movhi	r2,2086
 8241154:	10b98004 	addi	r2,r2,-6656
 8241158:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 824115c:	00bffa84 	movi	r2,-22
 8241160:	00007806 	br	8241344 <ip_reasm_process_first_fragment+0x2a4>
   }

   pip = ip_head(p);
 8241164:	e0bfff17 	ldw	r2,-4(fp)
 8241168:	10800317 	ldw	r2,12(r2)
 824116c:	e0bffb15 	stw	r2,-20(fp)
   iphlen = ip_hlen(pip);
 8241170:	e0bffb17 	ldw	r2,-20(fp)
 8241174:	10800003 	ldbu	r2,0(r2)
 8241178:	108003cc 	andi	r2,r2,15
 824117c:	1085883a 	add	r2,r2,r2
 8241180:	1085883a 	add	r2,r2,r2
 8241184:	e0bffc05 	stb	r2,-16(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 8241188:	e13ffb17 	ldw	r4,-20(fp)
 824118c:	8240e040 	call	8240e04 <ip_reasm_determine_type_of_frag>
 8241190:	e0bffd15 	stw	r2,-12(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8241194:	e0bffb17 	ldw	r2,-20(fp)
 8241198:	1080018b 	ldhu	r2,6(r2)
 824119c:	10bfffcc 	andi	r2,r2,65535
 82411a0:	1004d23a 	srli	r2,r2,8
 82411a4:	10bfffcc 	andi	r2,r2,65535
 82411a8:	10c03fcc 	andi	r3,r2,255
 82411ac:	e0bffb17 	ldw	r2,-20(fp)
 82411b0:	1080018b 	ldhu	r2,6(r2)
 82411b4:	10bfffcc 	andi	r2,r2,65535
 82411b8:	1004923a 	slli	r2,r2,8
 82411bc:	10bfffcc 	andi	r2,r2,65535
 82411c0:	1884b03a 	or	r2,r3,r2
 82411c4:	100490fa 	slli	r2,r2,3
 82411c8:	e0bffe0d 	sth	r2,-8(fp)
   total_len = ntohs(pip->ip_len);
 82411cc:	e0bffb17 	ldw	r2,-20(fp)
 82411d0:	1080008b 	ldhu	r2,2(r2)
 82411d4:	10bfffcc 	andi	r2,r2,65535
 82411d8:	1004d23a 	srli	r2,r2,8
 82411dc:	1007883a 	mov	r3,r2
 82411e0:	e0bffb17 	ldw	r2,-20(fp)
 82411e4:	1080008b 	ldhu	r2,2(r2)
 82411e8:	10bfffcc 	andi	r2,r2,65535
 82411ec:	1004923a 	slli	r2,r2,8
 82411f0:	1884b03a 	or	r2,r3,r2
 82411f4:	e0bffe8d 	sth	r2,-6(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 82411f8:	e0bffb17 	ldw	r2,-20(fp)
 82411fc:	10c00317 	ldw	r3,12(r2)
 8241200:	e0bffa17 	ldw	r2,-24(fp)
 8241204:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 8241208:	e0bffb17 	ldw	r2,-20(fp)
 824120c:	10c00417 	ldw	r3,16(r2)
 8241210:	e0bffa17 	ldw	r2,-24(fp)
 8241214:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 8241218:	e0bffb17 	ldw	r2,-20(fp)
 824121c:	10c00243 	ldbu	r3,9(r2)
 8241220:	e0bffa17 	ldw	r2,-24(fp)
 8241224:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 8241228:	e0bffb17 	ldw	r2,-20(fp)
 824122c:	10c0010b 	ldhu	r3,4(r2)
 8241230:	e0bffa17 	ldw	r2,-24(fp)
 8241234:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 8241238:	e0bffd17 	ldw	r2,-12(fp)
 824123c:	10800158 	cmpnei	r2,r2,5
 8241240:	10000a1e 	bne	r2,zero,824126c <ip_reasm_process_first_fragment+0x1cc>
      {
      irep->length = frag_offset + (total_len - iphlen);
 8241244:	e0bffc03 	ldbu	r2,-16(fp)
 8241248:	e0fffe8b 	ldhu	r3,-6(fp)
 824124c:	1885c83a 	sub	r2,r3,r2
 8241250:	1007883a 	mov	r3,r2
 8241254:	e0bffe0b 	ldhu	r2,-8(fp)
 8241258:	1885883a 	add	r2,r3,r2
 824125c:	1007883a 	mov	r3,r2
 8241260:	e0bffa17 	ldw	r2,-24(fp)
 8241264:	10c0040d 	sth	r3,16(r2)
 8241268:	00000a06 	br	8241294 <ip_reasm_process_first_fragment+0x1f4>
      }
   else if (ftype == IP_FF)
 824126c:	e0bffd17 	ldw	r2,-12(fp)
 8241270:	10800058 	cmpnei	r2,r2,1
 8241274:	1000071e 	bne	r2,zero,8241294 <ip_reasm_process_first_fragment+0x1f4>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 8241278:	e0bfff17 	ldw	r2,-4(fp)
 824127c:	10c00117 	ldw	r3,4(r2)
 8241280:	e0bffa17 	ldw	r2,-24(fp)
 8241284:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241288:	e0bffa17 	ldw	r2,-24(fp)
 824128c:	e0fffb17 	ldw	r3,-20(fp)
 8241290:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 8241294:	e0bffc03 	ldbu	r2,-16(fp)
 8241298:	e0fffe8b 	ldhu	r3,-6(fp)
 824129c:	1885c83a 	sub	r2,r3,r2
 82412a0:	1007883a 	mov	r3,r2
 82412a4:	e0bffa17 	ldw	r2,-24(fp)
 82412a8:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 82412ac:	e0bffa17 	ldw	r2,-24(fp)
 82412b0:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 82412b4:	e0bffa17 	ldw	r2,-24(fp)
 82412b8:	10802103 	ldbu	r2,132(r2)
 82412bc:	10800054 	ori	r2,r2,1
 82412c0:	1007883a 	mov	r3,r2
 82412c4:	e0bffa17 	ldw	r2,-24(fp)
 82412c8:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 82412cc:	e0bffa17 	ldw	r2,-24(fp)
 82412d0:	e0ffff17 	ldw	r3,-4(fp)
 82412d4:	10c00715 	stw	r3,28(r2)
   irep->rfq.frag_offset[0] = frag_offset;
 82412d8:	e0bffa17 	ldw	r2,-24(fp)
 82412dc:	e0fffe0b 	ldhu	r3,-8(fp)
 82412e0:	10c0170d 	sth	r3,92(r2)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 82412e4:	e0bfff17 	ldw	r2,-4(fp)
 82412e8:	10c00317 	ldw	r3,12(r2)
 82412ec:	e0bffc03 	ldbu	r2,-16(fp)
 82412f0:	1887883a 	add	r3,r3,r2
 82412f4:	e0bfff17 	ldw	r2,-4(fp)
 82412f8:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 82412fc:	e0bfff17 	ldw	r2,-4(fp)
 8241300:	10c00417 	ldw	r3,16(r2)
 8241304:	e0bffc03 	ldbu	r2,-16(fp)
 8241308:	1887c83a 	sub	r3,r3,r2
 824130c:	e0bfff17 	ldw	r2,-4(fp)
 8241310:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 8241314:	d0e0c817 	ldw	r3,-31968(gp)
 8241318:	e0bffa17 	ldw	r2,-24(fp)
 824131c:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 8241320:	e0bffa17 	ldw	r2,-24(fp)
 8241324:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 8241328:	e0bfff17 	ldw	r2,-4(fp)
 824132c:	10800217 	ldw	r2,8(r2)
 8241330:	10802204 	addi	r2,r2,136
 8241334:	10bfffcc 	andi	r2,r2,65535
 8241338:	1009883a 	mov	r4,r2
 824133c:	8240f680 	call	8240f68 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 8241340:	0005883a 	mov	r2,zero
}
 8241344:	e037883a 	mov	sp,fp
 8241348:	dfc00117 	ldw	ra,4(sp)
 824134c:	df000017 	ldw	fp,0(sp)
 8241350:	dec00204 	addi	sp,sp,8
 8241354:	f800283a 	ret

08241358 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 8241358:	defff904 	addi	sp,sp,-28
 824135c:	dfc00615 	stw	ra,24(sp)
 8241360:	df000515 	stw	fp,20(sp)
 8241364:	df000504 	addi	fp,sp,20
 8241368:	e13fff15 	stw	r4,-4(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 824136c:	e0bfff17 	ldw	r2,-4(fp)
 8241370:	10800317 	ldw	r2,12(r2)
 8241374:	e0bffb15 	stw	r2,-20(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 8241378:	e13ffb17 	ldw	r4,-20(fp)
 824137c:	8240d400 	call	8240d40 <ip_reasm_match_frag_with_ire>
 8241380:	e0bffc15 	stw	r2,-16(fp)

   if (!irep)
 8241384:	e0bffc17 	ldw	r2,-16(fp)
 8241388:	1000071e 	bne	r2,zero,82413a8 <ip_reassm+0x50>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 824138c:	e13fff17 	ldw	r4,-4(fp)
 8241390:	82410a00 	call	82410a0 <ip_reasm_process_first_fragment>
 8241394:	e0bffd15 	stw	r2,-12(fp)
 8241398:	e0bffd17 	ldw	r2,-12(fp)
 824139c:	10000a26 	beq	r2,zero,82413c8 <ip_reassm+0x70>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 82413a0:	e0bffd17 	ldw	r2,-12(fp)
 82413a4:	00000906 	br	82413cc <ip_reassm+0x74>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 82413a8:	e17ffc17 	ldw	r5,-16(fp)
 82413ac:	e13fff17 	ldw	r4,-4(fp)
 82413b0:	82419440 	call	8241944 <ip_reasm_process_subsequent_fragments>
 82413b4:	e0bffe15 	stw	r2,-8(fp)
 82413b8:	e0bffe17 	ldw	r2,-8(fp)
 82413bc:	10000226 	beq	r2,zero,82413c8 <ip_reassm+0x70>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 82413c0:	e0bffe17 	ldw	r2,-8(fp)
 82413c4:	00000106 	br	82413cc <ip_reassm+0x74>
      }
   }

   return IPREASM_OK;
 82413c8:	0005883a 	mov	r2,zero
}
 82413cc:	e037883a 	mov	sp,fp
 82413d0:	dfc00117 	ldw	ra,4(sp)
 82413d4:	df000017 	ldw	fp,0(sp)
 82413d8:	dec00204 	addi	sp,sp,8
 82413dc:	f800283a 	ret

082413e0 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 82413e0:	defff204 	addi	sp,sp,-56
 82413e4:	dfc00d15 	stw	ra,52(sp)
 82413e8:	df000c15 	stw	fp,48(sp)
 82413ec:	df000c04 	addi	fp,sp,48
 82413f0:	e13ffc15 	stw	r4,-16(fp)
 82413f4:	e17ffd15 	stw	r5,-12(fp)
 82413f8:	e1bffe15 	stw	r6,-8(fp)
 82413fc:	e1ffff15 	stw	r7,-4(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241400:	e13ffd17 	ldw	r4,-12(fp)
 8241404:	8241e740 	call	8241e74 <ip_reasm_find_ire>
 8241408:	10803fcc 	andi	r2,r2,255
 824140c:	10800060 	cmpeqi	r2,r2,1
 8241410:	10000f1e 	bne	r2,zero,8241450 <ip_reasm_compute_overlap+0x70>
      {
      ++ire_stats.bad_irep;
 8241414:	008209b4 	movhi	r2,2086
 8241418:	10b99404 	addi	r2,r2,-6576
 824141c:	10800017 	ldw	r2,0(r2)
 8241420:	10c00044 	addi	r3,r2,1
 8241424:	008209b4 	movhi	r2,2086
 8241428:	10b99404 	addi	r2,r2,-6576
 824142c:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241430:	01000084 	movi	r4,2
 8241434:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241438:	e13ffc17 	ldw	r4,-16(fp)
 824143c:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241440:	01000084 	movi	r4,2
 8241444:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 8241448:	00800044 	movi	r2,1
 824144c:	00013806 	br	8241930 <ip_reasm_compute_overlap+0x550>
      }

   jrip = ip_head(p);
 8241450:	e0bffc17 	ldw	r2,-16(fp)
 8241454:	10800317 	ldw	r2,12(r2)
 8241458:	e0bff715 	stw	r2,-36(fp)
   iphlen = ip_hlen (jrip);
 824145c:	e0bff717 	ldw	r2,-36(fp)
 8241460:	10800003 	ldbu	r2,0(r2)
 8241464:	108003cc 	andi	r2,r2,15
 8241468:	1085883a 	add	r2,r2,r2
 824146c:	1085883a 	add	r2,r2,r2
 8241470:	e0bff805 	stb	r2,-32(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8241474:	e0bff717 	ldw	r2,-36(fp)
 8241478:	1080018b 	ldhu	r2,6(r2)
 824147c:	10bfffcc 	andi	r2,r2,65535
 8241480:	1004d23a 	srli	r2,r2,8
 8241484:	10bfffcc 	andi	r2,r2,65535
 8241488:	10c03fcc 	andi	r3,r2,255
 824148c:	e0bff717 	ldw	r2,-36(fp)
 8241490:	1080018b 	ldhu	r2,6(r2)
 8241494:	10bfffcc 	andi	r2,r2,65535
 8241498:	1004923a 	slli	r2,r2,8
 824149c:	10bfffcc 	andi	r2,r2,65535
 82414a0:	1884b03a 	or	r2,r3,r2
 82414a4:	100490fa 	slli	r2,r2,3
 82414a8:	e0bff50d 	sth	r2,-44(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 82414ac:	e0bff717 	ldw	r2,-36(fp)
 82414b0:	1080008b 	ldhu	r2,2(r2)
 82414b4:	10bfffcc 	andi	r2,r2,65535
 82414b8:	1004d23a 	srli	r2,r2,8
 82414bc:	1007883a 	mov	r3,r2
 82414c0:	e0bff717 	ldw	r2,-36(fp)
 82414c4:	1080008b 	ldhu	r2,2(r2)
 82414c8:	10bfffcc 	andi	r2,r2,65535
 82414cc:	1004923a 	slli	r2,r2,8
 82414d0:	1884b03a 	or	r2,r3,r2
 82414d4:	1007883a 	mov	r3,r2
 82414d8:	e0bff803 	ldbu	r2,-32(fp)
 82414dc:	1885c83a 	sub	r2,r3,r2
 82414e0:	1007883a 	mov	r3,r2
 82414e4:	e0bff50b 	ldhu	r2,-44(fp)
 82414e8:	1885883a 	add	r2,r3,r2
 82414ec:	10bfffc4 	addi	r2,r2,-1
 82414f0:	e0bff58d 	sth	r2,-42(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 82414f4:	e0bffc17 	ldw	r2,-16(fp)
 82414f8:	10c00317 	ldw	r3,12(r2)
 82414fc:	e0bff803 	ldbu	r2,-32(fp)
 8241500:	1887883a 	add	r3,r3,r2
 8241504:	e0bffc17 	ldw	r2,-16(fp)
 8241508:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 824150c:	e0bffc17 	ldw	r2,-16(fp)
 8241510:	10c00417 	ldw	r3,16(r2)
 8241514:	e0bff803 	ldbu	r2,-32(fp)
 8241518:	1887c83a 	sub	r3,r3,r2
 824151c:	e0bffc17 	ldw	r2,-16(fp)
 8241520:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 8241524:	e0800217 	ldw	r2,8(fp)
 8241528:	e0fff50b 	ldhu	r3,-44(fp)
 824152c:	10c0000d 	sth	r3,0(r2)
   *indexp = INVALID_FRAG_INDEX;
 8241530:	e0bffe17 	ldw	r2,-8(fp)
 8241534:	00c00404 	movi	r3,16
 8241538:	10c0000d 	sth	r3,0(r2)
   *last_rfqpp = 0;
 824153c:	e0bfff17 	ldw	r2,-4(fp)
 8241540:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 8241544:	e0800317 	ldw	r2,12(fp)
 8241548:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 824154c:	e0bffd17 	ldw	r2,-12(fp)
 8241550:	10800604 	addi	r2,r2,24
 8241554:	e0bff415 	stw	r2,-48(fp)

   while (rfqp)
 8241558:	0000ef06 	br	8241918 <ip_reasm_compute_overlap+0x538>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824155c:	e03ff60d 	sth	zero,-40(fp)
 8241560:	0000dd06 	br	82418d8 <ip_reasm_compute_overlap+0x4f8>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 8241564:	e0bff60b 	ldhu	r2,-40(fp)
 8241568:	e0fff417 	ldw	r3,-48(fp)
 824156c:	10800044 	addi	r2,r2,1
 8241570:	1085883a 	add	r2,r2,r2
 8241574:	1085883a 	add	r2,r2,r2
 8241578:	1885883a 	add	r2,r3,r2
 824157c:	10800017 	ldw	r2,0(r2)
 8241580:	e0bff915 	stw	r2,-28(fp)
 8241584:	e0bff917 	ldw	r2,-28(fp)
 8241588:	1000c026 	beq	r2,zero,824188c <ip_reasm_compute_overlap+0x4ac>
            {
            currstart = rfqp->frag_offset[i];
 824158c:	e0bff60b 	ldhu	r2,-40(fp)
 8241590:	e0fff417 	ldw	r3,-48(fp)
 8241594:	10800884 	addi	r2,r2,34
 8241598:	1085883a 	add	r2,r2,r2
 824159c:	1885883a 	add	r2,r3,r2
 82415a0:	1080000b 	ldhu	r2,0(r2)
 82415a4:	e0bffa0d 	sth	r2,-24(fp)
            currend = currstart + currpkt->nb_plen - 1;
 82415a8:	e0bff917 	ldw	r2,-28(fp)
 82415ac:	10800417 	ldw	r2,16(r2)
 82415b0:	1007883a 	mov	r3,r2
 82415b4:	e0bffa0b 	ldhu	r2,-24(fp)
 82415b8:	1885883a 	add	r2,r3,r2
 82415bc:	10bfffc4 	addi	r2,r2,-1
 82415c0:	e0bffa8d 	sth	r2,-22(fp)

            if (currstart < jrstart)
 82415c4:	e0fffa0b 	ldhu	r3,-24(fp)
 82415c8:	e0bff50b 	ldhu	r2,-44(fp)
 82415cc:	18802b2e 	bgeu	r3,r2,824167c <ip_reasm_compute_overlap+0x29c>
               {
               if (currend < jrend) /* cases A1 and A2 */
 82415d0:	e0fffa8b 	ldhu	r3,-22(fp)
 82415d4:	e0bff58b 	ldhu	r2,-42(fp)
 82415d8:	1880202e 	bgeu	r3,r2,824165c <ip_reasm_compute_overlap+0x27c>
                  {
                  if (currend < jrstart) /* A1 */
 82415dc:	e0fffa8b 	ldhu	r3,-22(fp)
 82415e0:	e0bff50b 	ldhu	r2,-44(fp)
 82415e4:	1880b936 	bltu	r3,r2,82418cc <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 82415e8:	e0fffa8b 	ldhu	r3,-22(fp)
 82415ec:	e0bff50b 	ldhu	r2,-44(fp)
 82415f0:	1885c83a 	sub	r2,r3,r2
 82415f4:	10800044 	addi	r2,r2,1
 82415f8:	e0bffb0d 	sth	r2,-20(fp)
                     p->nb_prot += drop_len;
 82415fc:	e0bffc17 	ldw	r2,-16(fp)
 8241600:	10c00317 	ldw	r3,12(r2)
 8241604:	e0bffb0b 	ldhu	r2,-20(fp)
 8241608:	1887883a 	add	r3,r3,r2
 824160c:	e0bffc17 	ldw	r2,-16(fp)
 8241610:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 8241614:	e0bffc17 	ldw	r2,-16(fp)
 8241618:	10c00417 	ldw	r3,16(r2)
 824161c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241620:	1887c83a 	sub	r3,r3,r2
 8241624:	e0bffc17 	ldw	r2,-16(fp)
 8241628:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 824162c:	e0fff50b 	ldhu	r3,-44(fp)
 8241630:	e0bffb0b 	ldhu	r2,-20(fp)
 8241634:	1885883a 	add	r2,r3,r2
 8241638:	e0bff50d 	sth	r2,-44(fp)
                     jrend = jrstart + p->nb_plen - 1;
 824163c:	e0bffc17 	ldw	r2,-16(fp)
 8241640:	10800417 	ldw	r2,16(r2)
 8241644:	1007883a 	mov	r3,r2
 8241648:	e0bff50b 	ldhu	r2,-44(fp)
 824164c:	1885883a 	add	r2,r3,r2
 8241650:	10bfffc4 	addi	r2,r2,-1
 8241654:	e0bff58d 	sth	r2,-42(fp)
 8241658:	00009c06 	br	82418cc <ip_reasm_compute_overlap+0x4ec>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 824165c:	01000084 	movi	r4,2
 8241660:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241664:	e13ffc17 	ldw	r4,-16(fp)
 8241668:	822ca880 	call	822ca88 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 824166c:	01000084 	movi	r4,2
 8241670:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241674:	0005883a 	mov	r2,zero
 8241678:	0000ad06 	br	8241930 <ip_reasm_compute_overlap+0x550>
                  }
               }
            else if (currstart > jrstart)
 824167c:	e0bffa0b 	ldhu	r2,-24(fp)
 8241680:	e0fff50b 	ldhu	r3,-44(fp)
 8241684:	18804e2e 	bgeu	r3,r2,82417c0 <ip_reasm_compute_overlap+0x3e0>
               {
               if (currend > jrend) /* cases B1 and B2 */
 8241688:	e0bffa8b 	ldhu	r2,-22(fp)
 824168c:	e0fff58b 	ldhu	r3,-42(fp)
 8241690:	1880112e 	bgeu	r3,r2,82416d8 <ip_reasm_compute_overlap+0x2f8>
                  {
                  if (currstart > jrend) /* B1 */
 8241694:	e0bffa0b 	ldhu	r2,-24(fp)
 8241698:	e0fff58b 	ldhu	r3,-42(fp)
 824169c:	18808b36 	bltu	r3,r2,82418cc <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 82416a0:	e0fffa0b 	ldhu	r3,-24(fp)
 82416a4:	e0bff50b 	ldhu	r2,-44(fp)
 82416a8:	1885c83a 	sub	r2,r3,r2
 82416ac:	1007883a 	mov	r3,r2
 82416b0:	e0bffc17 	ldw	r2,-16(fp)
 82416b4:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 82416b8:	e0bffc17 	ldw	r2,-16(fp)
 82416bc:	10800417 	ldw	r2,16(r2)
 82416c0:	1007883a 	mov	r3,r2
 82416c4:	e0bff50b 	ldhu	r2,-44(fp)
 82416c8:	1885883a 	add	r2,r3,r2
 82416cc:	10bfffc4 	addi	r2,r2,-1
 82416d0:	e0bff58d 	sth	r2,-42(fp)
 82416d4:	00007d06 	br	82418cc <ip_reasm_compute_overlap+0x4ec>
                     }
                  }
               else if (currend == jrend) /* F1 */
 82416d8:	e0fffa8b 	ldhu	r3,-22(fp)
 82416dc:	e0bff58b 	ldhu	r2,-42(fp)
 82416e0:	18800e1e 	bne	r3,r2,824171c <ip_reasm_compute_overlap+0x33c>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 82416e4:	e0fffa0b 	ldhu	r3,-24(fp)
 82416e8:	e0bff50b 	ldhu	r2,-44(fp)
 82416ec:	1885c83a 	sub	r2,r3,r2
 82416f0:	1007883a 	mov	r3,r2
 82416f4:	e0bffc17 	ldw	r2,-16(fp)
 82416f8:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 82416fc:	e0bffc17 	ldw	r2,-16(fp)
 8241700:	10800417 	ldw	r2,16(r2)
 8241704:	1007883a 	mov	r3,r2
 8241708:	e0bff50b 	ldhu	r2,-44(fp)
 824170c:	1885883a 	add	r2,r3,r2
 8241710:	10bfffc4 	addi	r2,r2,-1
 8241714:	e0bff58d 	sth	r2,-42(fp)
 8241718:	00006c06 	br	82418cc <ip_reasm_compute_overlap+0x4ec>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 824171c:	e0bff917 	ldw	r2,-28(fp)
 8241720:	10800217 	ldw	r2,8(r2)
 8241724:	10bfffcc 	andi	r2,r2,65535
 8241728:	1009883a 	mov	r4,r2
 824172c:	82410080 	call	8241008 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 8241730:	e0bffd17 	ldw	r2,-12(fp)
 8241734:	1080048b 	ldhu	r2,18(r2)
 8241738:	e0fff917 	ldw	r3,-28(fp)
 824173c:	18c00417 	ldw	r3,16(r3)
 8241740:	10c5c83a 	sub	r2,r2,r3
 8241744:	1007883a 	mov	r3,r2
 8241748:	e0bffd17 	ldw	r2,-12(fp)
 824174c:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241750:	01000084 	movi	r4,2
 8241754:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 8241758:	e13ff917 	ldw	r4,-28(fp)
 824175c:	822ca880 	call	822ca88 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241760:	01000084 	movi	r4,2
 8241764:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 8241768:	e0bff60b 	ldhu	r2,-40(fp)
 824176c:	e0fff417 	ldw	r3,-48(fp)
 8241770:	10800044 	addi	r2,r2,1
 8241774:	1085883a 	add	r2,r2,r2
 8241778:	1085883a 	add	r2,r2,r2
 824177c:	1885883a 	add	r2,r3,r2
 8241780:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 8241784:	e0bffe17 	ldw	r2,-8(fp)
 8241788:	1080000b 	ldhu	r2,0(r2)
 824178c:	10bfffcc 	andi	r2,r2,65535
 8241790:	10800418 	cmpnei	r2,r2,16
 8241794:	1000061e 	bne	r2,zero,82417b0 <ip_reasm_compute_overlap+0x3d0>
                     {
                     *indexp = i;
 8241798:	e0bffe17 	ldw	r2,-8(fp)
 824179c:	e0fff60b 	ldhu	r3,-40(fp)
 82417a0:	10c0000d 	sth	r3,0(r2)
                     *last_rfqpp = rfqp;
 82417a4:	e0bfff17 	ldw	r2,-4(fp)
 82417a8:	e0fff417 	ldw	r3,-48(fp)
 82417ac:	10c00015 	stw	r3,0(r2)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 82417b0:	e0800317 	ldw	r2,12(fp)
 82417b4:	00c00044 	movi	r3,1
 82417b8:	10c00005 	stb	r3,0(r2)
 82417bc:	00004306 	br	82418cc <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 82417c0:	e0fffa8b 	ldhu	r3,-22(fp)
 82417c4:	e0bff58b 	ldhu	r2,-42(fp)
 82417c8:	1880081e 	bne	r3,r2,82417ec <ip_reasm_compute_overlap+0x40c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 82417cc:	01000084 	movi	r4,2
 82417d0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
                  pk_free (p);
 82417d4:	e13ffc17 	ldw	r4,-16(fp)
 82417d8:	822ca880 	call	822ca88 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82417dc:	01000084 	movi	r4,2
 82417e0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 82417e4:	0005883a 	mov	r2,zero
 82417e8:	00005106 	br	8241930 <ip_reasm_compute_overlap+0x550>
                  }
               else if (currend > jrend) /* case D1 */
 82417ec:	e0bffa8b 	ldhu	r2,-22(fp)
 82417f0:	e0fff58b 	ldhu	r3,-42(fp)
 82417f4:	1880082e 	bgeu	r3,r2,8241818 <ip_reasm_compute_overlap+0x438>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 82417f8:	01000084 	movi	r4,2
 82417fc:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241800:	e13ffc17 	ldw	r4,-16(fp)
 8241804:	822ca880 	call	822ca88 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241808:	01000084 	movi	r4,2
 824180c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241810:	0005883a 	mov	r2,zero
 8241814:	00004606 	br	8241930 <ip_reasm_compute_overlap+0x550>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 8241818:	e0fffa8b 	ldhu	r3,-22(fp)
 824181c:	e0bff50b 	ldhu	r2,-44(fp)
 8241820:	1885c83a 	sub	r2,r3,r2
 8241824:	10800044 	addi	r2,r2,1
 8241828:	e0bffb0d 	sth	r2,-20(fp)
                  p->nb_prot += drop_len;
 824182c:	e0bffc17 	ldw	r2,-16(fp)
 8241830:	10c00317 	ldw	r3,12(r2)
 8241834:	e0bffb0b 	ldhu	r2,-20(fp)
 8241838:	1887883a 	add	r3,r3,r2
 824183c:	e0bffc17 	ldw	r2,-16(fp)
 8241840:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 8241844:	e0bffc17 	ldw	r2,-16(fp)
 8241848:	10c00417 	ldw	r3,16(r2)
 824184c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241850:	1887c83a 	sub	r3,r3,r2
 8241854:	e0bffc17 	ldw	r2,-16(fp)
 8241858:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 824185c:	e0fff50b 	ldhu	r3,-44(fp)
 8241860:	e0bffb0b 	ldhu	r2,-20(fp)
 8241864:	1885883a 	add	r2,r3,r2
 8241868:	e0bff50d 	sth	r2,-44(fp)
                  jrend = jrstart + p->nb_plen - 1;
 824186c:	e0bffc17 	ldw	r2,-16(fp)
 8241870:	10800417 	ldw	r2,16(r2)
 8241874:	1007883a 	mov	r3,r2
 8241878:	e0bff50b 	ldhu	r2,-44(fp)
 824187c:	1885883a 	add	r2,r3,r2
 8241880:	10bfffc4 	addi	r2,r2,-1
 8241884:	e0bff58d 	sth	r2,-42(fp)
 8241888:	00001006 	br	82418cc <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 824188c:	e0bffe17 	ldw	r2,-8(fp)
 8241890:	1080000b 	ldhu	r2,0(r2)
 8241894:	10bfffcc 	andi	r2,r2,65535
 8241898:	10800418 	cmpnei	r2,r2,16
 824189c:	1000061e 	bne	r2,zero,82418b8 <ip_reasm_compute_overlap+0x4d8>
               {
               *indexp = i;
 82418a0:	e0bffe17 	ldw	r2,-8(fp)
 82418a4:	e0fff60b 	ldhu	r3,-40(fp)
 82418a8:	10c0000d 	sth	r3,0(r2)
               *last_rfqpp = rfqp;               
 82418ac:	e0bfff17 	ldw	r2,-4(fp)
 82418b0:	e0fff417 	ldw	r3,-48(fp)
 82418b4:	10c00015 	stw	r3,0(r2)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 82418b8:	e0bffd17 	ldw	r2,-12(fp)
 82418bc:	10802103 	ldbu	r2,132(r2)
 82418c0:	10803fcc 	andi	r2,r2,255
 82418c4:	1080004c 	andi	r2,r2,1
 82418c8:	1000071e 	bne	r2,zero,82418e8 <ip_reasm_compute_overlap+0x508>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82418cc:	e0bff60b 	ldhu	r2,-40(fp)
 82418d0:	10800044 	addi	r2,r2,1
 82418d4:	e0bff60d 	sth	r2,-40(fp)
 82418d8:	e0bff60b 	ldhu	r2,-40(fp)
 82418dc:	10800430 	cmpltui	r2,r2,16
 82418e0:	103f201e 	bne	r2,zero,8241564 <ip_reasm_compute_overlap+0x184>
 82418e4:	00000106 	br	82418ec <ip_reasm_compute_overlap+0x50c>
               *indexp = i;
               *last_rfqpp = rfqp;               
               }
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 82418e8:	0001883a 	nop
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 82418ec:	e0bffe17 	ldw	r2,-8(fp)
 82418f0:	1080000b 	ldhu	r2,0(r2)
 82418f4:	10bfffcc 	andi	r2,r2,65535
 82418f8:	10800418 	cmpnei	r2,r2,16
 82418fc:	1000031e 	bne	r2,zero,824190c <ip_reasm_compute_overlap+0x52c>
         {
         *last_rfqpp = rfqp;
 8241900:	e0bfff17 	ldw	r2,-4(fp)
 8241904:	e0fff417 	ldw	r3,-48(fp)
 8241908:	10c00015 	stw	r3,0(r2)
         }
      rfqp = rfqp->next;
 824190c:	e0bff417 	ldw	r2,-48(fp)
 8241910:	10800017 	ldw	r2,0(r2)
 8241914:	e0bff415 	stw	r2,-48(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 8241918:	e0bff417 	ldw	r2,-48(fp)
 824191c:	103f0f1e 	bne	r2,zero,824155c <ip_reasm_compute_overlap+0x17c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 8241920:	e0800217 	ldw	r2,8(fp)
 8241924:	e0fff50b 	ldhu	r3,-44(fp)
 8241928:	10c0000d 	sth	r3,0(r2)

   return IPREASM_ACCEPT_FRAG;
 824192c:	00800084 	movi	r2,2
}
 8241930:	e037883a 	mov	sp,fp
 8241934:	dfc00117 	ldw	ra,4(sp)
 8241938:	df000017 	ldw	fp,0(sp)
 824193c:	dec00204 	addi	sp,sp,8
 8241940:	f800283a 	ret

08241944 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 8241944:	defff104 	addi	sp,sp,-60
 8241948:	dfc00e15 	stw	ra,56(sp)
 824194c:	df000d15 	stw	fp,52(sp)
 8241950:	df000d04 	addi	fp,sp,52
 8241954:	e13ffe15 	stw	r4,-8(fp)
 8241958:	e17fff15 	stw	r5,-4(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 824195c:	e03ff515 	stw	zero,-44(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241960:	e13fff17 	ldw	r4,-4(fp)
 8241964:	8241e740 	call	8241e74 <ip_reasm_find_ire>
 8241968:	10803fcc 	andi	r2,r2,255
 824196c:	10800060 	cmpeqi	r2,r2,1
 8241970:	1000161e 	bne	r2,zero,82419cc <ip_reasm_process_subsequent_fragments+0x88>
      {
      ++ire_stats.bad_irep;
 8241974:	008209b4 	movhi	r2,2086
 8241978:	10b99404 	addi	r2,r2,-6576
 824197c:	10800017 	ldw	r2,0(r2)
 8241980:	10c00044 	addi	r3,r2,1
 8241984:	008209b4 	movhi	r2,2086
 8241988:	10b99404 	addi	r2,r2,-6576
 824198c:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241990:	01000084 	movi	r4,2
 8241994:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241998:	e13ffe17 	ldw	r4,-8(fp)
 824199c:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82419a0:	01000084 	movi	r4,2
 82419a4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 82419a8:	008209b4 	movhi	r2,2086
 82419ac:	10b98004 	addi	r2,r2,-6656
 82419b0:	10800f17 	ldw	r2,60(r2)
 82419b4:	10c00044 	addi	r3,r2,1
 82419b8:	008209b4 	movhi	r2,2086
 82419bc:	10b98004 	addi	r2,r2,-6656
 82419c0:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 82419c4:	00bffd84 	movi	r2,-10
 82419c8:	00012506 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>
      }

   pip = ip_head(p);
 82419cc:	e0bffe17 	ldw	r2,-8(fp)
 82419d0:	10800317 	ldw	r2,12(r2)
 82419d4:	e0bff615 	stw	r2,-40(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 82419d8:	e13ff617 	ldw	r4,-40(fp)
 82419dc:	8240e040 	call	8240e04 <ip_reasm_determine_type_of_frag>
 82419e0:	e0bff715 	stw	r2,-36(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 82419e4:	e0bff717 	ldw	r2,-36(fp)
 82419e8:	10800158 	cmpnei	r2,r2,5
 82419ec:	1000251e 	bne	r2,zero,8241a84 <ip_reasm_process_subsequent_fragments+0x140>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 82419f0:	e0bff617 	ldw	r2,-40(fp)
 82419f4:	1080018b 	ldhu	r2,6(r2)
 82419f8:	10bfffcc 	andi	r2,r2,65535
 82419fc:	1004d23a 	srli	r2,r2,8
 8241a00:	10bfffcc 	andi	r2,r2,65535
 8241a04:	10c03fcc 	andi	r3,r2,255
 8241a08:	e0bff617 	ldw	r2,-40(fp)
 8241a0c:	1080018b 	ldhu	r2,6(r2)
 8241a10:	10bfffcc 	andi	r2,r2,65535
 8241a14:	1004923a 	slli	r2,r2,8
 8241a18:	10bfffcc 	andi	r2,r2,65535
 8241a1c:	1884b03a 	or	r2,r3,r2
 8241a20:	100490fa 	slli	r2,r2,3
 8241a24:	1007883a 	mov	r3,r2
 8241a28:	e0bff617 	ldw	r2,-40(fp)
 8241a2c:	1080008b 	ldhu	r2,2(r2)
 8241a30:	10bfffcc 	andi	r2,r2,65535
 8241a34:	1004d23a 	srli	r2,r2,8
 8241a38:	1009883a 	mov	r4,r2
 8241a3c:	e0bff617 	ldw	r2,-40(fp)
 8241a40:	1080008b 	ldhu	r2,2(r2)
 8241a44:	10bfffcc 	andi	r2,r2,65535
 8241a48:	1004923a 	slli	r2,r2,8
 8241a4c:	2084b03a 	or	r2,r4,r2
 8241a50:	1009883a 	mov	r4,r2
 8241a54:	e0bff617 	ldw	r2,-40(fp)
 8241a58:	10800003 	ldbu	r2,0(r2)
 8241a5c:	10803fcc 	andi	r2,r2,255
 8241a60:	108003cc 	andi	r2,r2,15
 8241a64:	1085883a 	add	r2,r2,r2
 8241a68:	1085883a 	add	r2,r2,r2
 8241a6c:	2085c83a 	sub	r2,r4,r2
 8241a70:	1885883a 	add	r2,r3,r2
 8241a74:	1007883a 	mov	r3,r2
 8241a78:	e0bfff17 	ldw	r2,-4(fp)
 8241a7c:	10c0040d 	sth	r3,16(r2)
 8241a80:	00000a06 	br	8241aac <ip_reasm_process_subsequent_fragments+0x168>
      }
   else if (ftype == IP_FF)
 8241a84:	e0bff717 	ldw	r2,-36(fp)
 8241a88:	10800058 	cmpnei	r2,r2,1
 8241a8c:	1000071e 	bne	r2,zero,8241aac <ip_reasm_process_subsequent_fragments+0x168>
      {
      irep->l2_hdr = p->nb_buff;
 8241a90:	e0bffe17 	ldw	r2,-8(fp)
 8241a94:	10c00117 	ldw	r3,4(r2)
 8241a98:	e0bfff17 	ldw	r2,-4(fp)
 8241a9c:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241aa0:	e0bfff17 	ldw	r2,-4(fp)
 8241aa4:	e0fff617 	ldw	r3,-40(fp)
 8241aa8:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 8241aac:	e13ffc04 	addi	r4,fp,-16
 8241ab0:	e0fffb04 	addi	r3,fp,-20
 8241ab4:	e0bffd84 	addi	r2,fp,-10
 8241ab8:	d8800115 	stw	r2,4(sp)
 8241abc:	e0bffd04 	addi	r2,fp,-12
 8241ac0:	d8800015 	stw	r2,0(sp)
 8241ac4:	200f883a 	mov	r7,r4
 8241ac8:	180d883a 	mov	r6,r3
 8241acc:	e17fff17 	ldw	r5,-4(fp)
 8241ad0:	e13ffe17 	ldw	r4,-8(fp)
 8241ad4:	82413e00 	call	82413e0 <ip_reasm_compute_overlap>
 8241ad8:	e0bff815 	stw	r2,-32(fp)
 8241adc:	e0bff817 	ldw	r2,-32(fp)
 8241ae0:	108000a0 	cmpeqi	r2,r2,2
 8241ae4:	1000091e 	bne	r2,zero,8241b0c <ip_reasm_process_subsequent_fragments+0x1c8>
      {
      switch (rc2)
 8241ae8:	e0bff817 	ldw	r2,-32(fp)
 8241aec:	10c00060 	cmpeqi	r3,r2,1
 8241af0:	1800031e 	bne	r3,zero,8241b00 <ip_reasm_process_subsequent_fragments+0x1bc>
 8241af4:	00800436 	bltu	zero,r2,8241b08 <ip_reasm_process_subsequent_fragments+0x1c4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 8241af8:	0005883a 	mov	r2,zero
 8241afc:	0000d806 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 8241b00:	00bffd84 	movi	r2,-10
 8241b04:	0000d606 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>
          * Altera Niche Stack Nios port modification:
          * Handle IPREASM_ACCEPT_FRAG case (will never
          * get here per if() above) to remove build warning.
          */
         case IPREASM_ACCEPT_FRAG:
            while(0);
 8241b08:	0001883a 	nop
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 8241b0c:	e0bffe17 	ldw	r2,-8(fp)
 8241b10:	10800217 	ldw	r2,8(r2)
 8241b14:	10bfffcc 	andi	r2,r2,65535
 8241b18:	1009883a 	mov	r4,r2
 8241b1c:	8240ed40 	call	8240ed4 <ip_reasm_check_mem_useage>
 8241b20:	e0bff915 	stw	r2,-28(fp)
 8241b24:	e0bff917 	ldw	r2,-28(fp)
 8241b28:	10001126 	beq	r2,zero,8241b70 <ip_reasm_process_subsequent_fragments+0x22c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241b2c:	01000084 	movi	r4,2
 8241b30:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241b34:	e13ffe17 	ldw	r4,-8(fp)
 8241b38:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241b3c:	01000084 	movi	r4,2
 8241b40:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 8241b44:	e13fff17 	ldw	r4,-4(fp)
 8241b48:	82422f00 	call	82422f0 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 8241b4c:	008209b4 	movhi	r2,2086
 8241b50:	10b98004 	addi	r2,r2,-6656
 8241b54:	10800f17 	ldw	r2,60(r2)
 8241b58:	10c00044 	addi	r3,r2,1
 8241b5c:	008209b4 	movhi	r2,2086
 8241b60:	10b98004 	addi	r2,r2,-6656
 8241b64:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241b68:	e0bff917 	ldw	r2,-28(fp)
 8241b6c:	0000bc06 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 8241b70:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b74:	10bfffcc 	andi	r2,r2,65535
 8241b78:	10800420 	cmpeqi	r2,r2,16
 8241b7c:	1000121e 	bne	r2,zero,8241bc8 <ip_reasm_process_subsequent_fragments+0x284>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 8241b80:	e0fffc17 	ldw	r3,-16(fp)
 8241b84:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b88:	10bfffcc 	andi	r2,r2,65535
 8241b8c:	10800044 	addi	r2,r2,1
 8241b90:	1085883a 	add	r2,r2,r2
 8241b94:	1085883a 	add	r2,r2,r2
 8241b98:	1885883a 	add	r2,r3,r2
 8241b9c:	e0fffe17 	ldw	r3,-8(fp)
 8241ba0:	10c00015 	stw	r3,0(r2)
      rfqp->frag_offset[index] = frag_offset;
 8241ba4:	e13ffc17 	ldw	r4,-16(fp)
 8241ba8:	e0bffb0b 	ldhu	r2,-20(fp)
 8241bac:	10bfffcc 	andi	r2,r2,65535
 8241bb0:	e0fffd0b 	ldhu	r3,-12(fp)
 8241bb4:	10800884 	addi	r2,r2,34
 8241bb8:	1085883a 	add	r2,r2,r2
 8241bbc:	2085883a 	add	r2,r4,r2
 8241bc0:	10c0000d 	sth	r3,0(r2)
 8241bc4:	00003906 	br	8241cac <ip_reasm_process_subsequent_fragments+0x368>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 8241bc8:	e0bffe17 	ldw	r2,-8(fp)
 8241bcc:	10800217 	ldw	r2,8(r2)
 8241bd0:	10801904 	addi	r2,r2,100
 8241bd4:	10bfffcc 	andi	r2,r2,65535
 8241bd8:	1009883a 	mov	r4,r2
 8241bdc:	8240ed40 	call	8240ed4 <ip_reasm_check_mem_useage>
 8241be0:	e0bff915 	stw	r2,-28(fp)
 8241be4:	e0bff917 	ldw	r2,-28(fp)
 8241be8:	10001126 	beq	r2,zero,8241c30 <ip_reasm_process_subsequent_fragments+0x2ec>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241bec:	01000084 	movi	r4,2
 8241bf0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free (p);
 8241bf4:	e13ffe17 	ldw	r4,-8(fp)
 8241bf8:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241bfc:	01000084 	movi	r4,2
 8241c00:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241c04:	e13fff17 	ldw	r4,-4(fp)
 8241c08:	82422f00 	call	82422f0 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241c0c:	008209b4 	movhi	r2,2086
 8241c10:	10b98004 	addi	r2,r2,-6656
 8241c14:	10800f17 	ldw	r2,60(r2)
 8241c18:	10c00044 	addi	r3,r2,1
 8241c1c:	008209b4 	movhi	r2,2086
 8241c20:	10b98004 	addi	r2,r2,-6656
 8241c24:	10c00f15 	stw	r3,60(r2)
         return rc;
 8241c28:	e0bff917 	ldw	r2,-28(fp)
 8241c2c:	00008c06 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 8241c30:	01001904 	movi	r4,100
 8241c34:	822deb80 	call	822deb8 <npalloc>
 8241c38:	e0bff515 	stw	r2,-44(fp)
      if (new_rfqp == 0)
 8241c3c:	e0bff517 	ldw	r2,-44(fp)
 8241c40:	1000111e 	bne	r2,zero,8241c88 <ip_reasm_process_subsequent_fragments+0x344>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241c44:	01000084 	movi	r4,2
 8241c48:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free (p);
 8241c4c:	e13ffe17 	ldw	r4,-8(fp)
 8241c50:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241c54:	01000084 	movi	r4,2
 8241c58:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241c5c:	e13fff17 	ldw	r4,-4(fp)
 8241c60:	82422f00 	call	82422f0 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241c64:	008209b4 	movhi	r2,2086
 8241c68:	10b98004 	addi	r2,r2,-6656
 8241c6c:	10800f17 	ldw	r2,60(r2)
 8241c70:	10c00044 	addi	r3,r2,1
 8241c74:	008209b4 	movhi	r2,2086
 8241c78:	10b98004 	addi	r2,r2,-6656
 8241c7c:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 8241c80:	00bffa84 	movi	r2,-22
 8241c84:	00007606 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 8241c88:	e0bff517 	ldw	r2,-44(fp)
 8241c8c:	e0fffe17 	ldw	r3,-8(fp)
 8241c90:	10c00115 	stw	r3,4(r2)
         new_rfqp->frag_offset[0] = frag_offset;
 8241c94:	e0fffd0b 	ldhu	r3,-12(fp)
 8241c98:	e0bff517 	ldw	r2,-44(fp)
 8241c9c:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 8241ca0:	e0bffc17 	ldw	r2,-16(fp)
 8241ca4:	e0fff517 	ldw	r3,-44(fp)
 8241ca8:	10c00015 	stw	r3,0(r2)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 8241cac:	e0bffd83 	ldbu	r2,-10(fp)
 8241cb0:	10803fcc 	andi	r2,r2,255
 8241cb4:	10001426 	beq	r2,zero,8241d08 <ip_reasm_process_subsequent_fragments+0x3c4>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 8241cb8:	e13fff17 	ldw	r4,-4(fp)
 8241cbc:	82424a40 	call	82424a4 <ip_reasm_mark_compact_rfq>
 8241cc0:	e0bff915 	stw	r2,-28(fp)
 8241cc4:	e0bff917 	ldw	r2,-28(fp)
 8241cc8:	10000f26 	beq	r2,zero,8241d08 <ip_reasm_process_subsequent_fragments+0x3c4>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 8241ccc:	01000084 	movi	r4,2
 8241cd0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free (p);
 8241cd4:	e13ffe17 	ldw	r4,-8(fp)
 8241cd8:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241cdc:	01000084 	movi	r4,2
 8241ce0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 8241ce4:	008209b4 	movhi	r2,2086
 8241ce8:	10b98004 	addi	r2,r2,-6656
 8241cec:	10800f17 	ldw	r2,60(r2)
 8241cf0:	10c00044 	addi	r3,r2,1
 8241cf4:	008209b4 	movhi	r2,2086
 8241cf8:	10b98004 	addi	r2,r2,-6656
 8241cfc:	10c00f15 	stw	r3,60(r2)
            return rc;
 8241d00:	e0bff917 	ldw	r2,-28(fp)
 8241d04:	00005606 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 8241d08:	e0bfff17 	ldw	r2,-4(fp)
 8241d0c:	1080048b 	ldhu	r2,18(r2)
 8241d10:	e0fffe17 	ldw	r3,-8(fp)
 8241d14:	18c00417 	ldw	r3,16(r3)
 8241d18:	10c5883a 	add	r2,r2,r3
 8241d1c:	1007883a 	mov	r3,r2
 8241d20:	e0bfff17 	ldw	r2,-4(fp)
 8241d24:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 8241d28:	e0bffe17 	ldw	r2,-8(fp)
 8241d2c:	10800217 	ldw	r2,8(r2)
 8241d30:	1007883a 	mov	r3,r2
 8241d34:	e0bff517 	ldw	r2,-44(fp)
 8241d38:	1000021e 	bne	r2,zero,8241d44 <ip_reasm_process_subsequent_fragments+0x400>
 8241d3c:	0005883a 	mov	r2,zero
 8241d40:	00000106 	br	8241d48 <ip_reasm_process_subsequent_fragments+0x404>
 8241d44:	00801904 	movi	r2,100
 8241d48:	1885883a 	add	r2,r3,r2
 8241d4c:	10bfffcc 	andi	r2,r2,65535
 8241d50:	1009883a 	mov	r4,r2
 8241d54:	8240f680 	call	8240f68 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 8241d58:	e0bfff17 	ldw	r2,-4(fp)
 8241d5c:	1080040b 	ldhu	r2,16(r2)
 8241d60:	10bfffcc 	andi	r2,r2,65535
 8241d64:	10003d26 	beq	r2,zero,8241e5c <ip_reasm_process_subsequent_fragments+0x518>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 8241d68:	e0bfff17 	ldw	r2,-4(fp)
 8241d6c:	10c0048b 	ldhu	r3,18(r2)
 8241d70:	e0bfff17 	ldw	r2,-4(fp)
 8241d74:	1080040b 	ldhu	r2,16(r2)
 8241d78:	18ffffcc 	andi	r3,r3,65535
 8241d7c:	10bfffcc 	andi	r2,r2,65535
 8241d80:	1880361e 	bne	r3,r2,8241e5c <ip_reasm_process_subsequent_fragments+0x518>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 8241d84:	e0bfff17 	ldw	r2,-4(fp)
 8241d88:	10802017 	ldw	r2,128(r2)
 8241d8c:	e0bff615 	stw	r2,-40(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241d90:	01000084 	movi	r4,2
 8241d94:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 8241d98:	e0bfff17 	ldw	r2,-4(fp)
 8241d9c:	1080040b 	ldhu	r2,16(r2)
 8241da0:	10ffffcc 	andi	r3,r2,65535
 8241da4:	e0bfff17 	ldw	r2,-4(fp)
 8241da8:	10802017 	ldw	r2,128(r2)
 8241dac:	1009883a 	mov	r4,r2
 8241db0:	e0bfff17 	ldw	r2,-4(fp)
 8241db4:	10801f17 	ldw	r2,124(r2)
 8241db8:	2085c83a 	sub	r2,r4,r2
 8241dbc:	1887883a 	add	r3,r3,r2
 8241dc0:	e0bff617 	ldw	r2,-40(fp)
 8241dc4:	10800003 	ldbu	r2,0(r2)
 8241dc8:	10803fcc 	andi	r2,r2,255
 8241dcc:	108003cc 	andi	r2,r2,15
 8241dd0:	1085883a 	add	r2,r2,r2
 8241dd4:	1085883a 	add	r2,r2,r2
 8241dd8:	1885883a 	add	r2,r3,r2
 8241ddc:	1009883a 	mov	r4,r2
 8241de0:	822c7380 	call	822c738 <pk_alloc>
 8241de4:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241de8:	01000084 	movi	r4,2
 8241dec:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 8241df0:	e0bffa17 	ldw	r2,-24(fp)
 8241df4:	10000b1e 	bne	r2,zero,8241e24 <ip_reasm_process_subsequent_fragments+0x4e0>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 8241df8:	e13fff17 	ldw	r4,-4(fp)
 8241dfc:	82422f00 	call	82422f0 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 8241e00:	008209b4 	movhi	r2,2086
 8241e04:	10b98004 	addi	r2,r2,-6656
 8241e08:	10800f17 	ldw	r2,60(r2)
 8241e0c:	10c00044 	addi	r3,r2,1
 8241e10:	008209b4 	movhi	r2,2086
 8241e14:	10b98004 	addi	r2,r2,-6656
 8241e18:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 8241e1c:	00bffac4 	movi	r2,-21
 8241e20:	00000f06 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x51c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 8241e24:	e17fff17 	ldw	r5,-4(fp)
 8241e28:	e13ffa17 	ldw	r4,-24(fp)
 8241e2c:	8241ecc0 	call	8241ecc <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 8241e30:	e13fff17 	ldw	r4,-4(fp)
 8241e34:	82422f00 	call	82422f0 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 8241e38:	008209b4 	movhi	r2,2086
 8241e3c:	10b98004 	addi	r2,r2,-6656
 8241e40:	10800e17 	ldw	r2,56(r2)
 8241e44:	10c00044 	addi	r3,r2,1
 8241e48:	008209b4 	movhi	r2,2086
 8241e4c:	10b98004 	addi	r2,r2,-6656
 8241e50:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 8241e54:	e13ffa17 	ldw	r4,-24(fp)
 8241e58:	82432c80 	call	82432c8 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 8241e5c:	0005883a 	mov	r2,zero
}
 8241e60:	e037883a 	mov	sp,fp
 8241e64:	dfc00117 	ldw	ra,4(sp)
 8241e68:	df000017 	ldw	fp,0(sp)
 8241e6c:	dec00204 	addi	sp,sp,8
 8241e70:	f800283a 	ret

08241e74 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 8241e74:	defffd04 	addi	sp,sp,-12
 8241e78:	df000215 	stw	fp,8(sp)
 8241e7c:	df000204 	addi	fp,sp,8
 8241e80:	e13fff15 	stw	r4,-4(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241e84:	d0a0c817 	ldw	r2,-31968(gp)
 8241e88:	e0bffe15 	stw	r2,-8(fp)
 8241e8c:	00000806 	br	8241eb0 <ip_reasm_find_ire+0x3c>
      {
      if (tmpp == irep) 
 8241e90:	e0fffe17 	ldw	r3,-8(fp)
 8241e94:	e0bfff17 	ldw	r2,-4(fp)
 8241e98:	1880021e 	bne	r3,r2,8241ea4 <ip_reasm_find_ire+0x30>
         {
         return IPREASM_TRUE;
 8241e9c:	00800044 	movi	r2,1
 8241ea0:	00000606 	br	8241ebc <ip_reasm_find_ire+0x48>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241ea4:	e0bffe17 	ldw	r2,-8(fp)
 8241ea8:	10800017 	ldw	r2,0(r2)
 8241eac:	e0bffe15 	stw	r2,-8(fp)
 8241eb0:	e0bffe17 	ldw	r2,-8(fp)
 8241eb4:	103ff61e 	bne	r2,zero,8241e90 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 8241eb8:	0005883a 	mov	r2,zero
}
 8241ebc:	e037883a 	mov	sp,fp
 8241ec0:	df000017 	ldw	fp,0(sp)
 8241ec4:	dec00104 	addi	sp,sp,4
 8241ec8:	f800283a 	ret

08241ecc <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 8241ecc:	defff504 	addi	sp,sp,-44
 8241ed0:	dfc00a15 	stw	ra,40(sp)
 8241ed4:	df000915 	stw	fp,36(sp)
 8241ed8:	df000904 	addi	fp,sp,36
 8241edc:	e13ffe15 	stw	r4,-8(fp)
 8241ee0:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 8241ee4:	e03ff915 	stw	zero,-28(fp)

   pip = (struct ip *) irep->l3_hdr;
 8241ee8:	e0bfff17 	ldw	r2,-4(fp)
 8241eec:	10802017 	ldw	r2,128(r2)
 8241ef0:	e0bffa15 	stw	r2,-24(fp)
   iphlen = ip_hlen (pip);
 8241ef4:	e0bffa17 	ldw	r2,-24(fp)
 8241ef8:	10800003 	ldbu	r2,0(r2)
 8241efc:	108003cc 	andi	r2,r2,15
 8241f00:	1085883a 	add	r2,r2,r2
 8241f04:	1085883a 	add	r2,r2,r2
 8241f08:	e0bffb05 	stb	r2,-20(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 8241f0c:	e0bfff17 	ldw	r2,-4(fp)
 8241f10:	10802017 	ldw	r2,128(r2)
 8241f14:	1007883a 	mov	r3,r2
 8241f18:	e0bfff17 	ldw	r2,-4(fp)
 8241f1c:	10801f17 	ldw	r2,124(r2)
 8241f20:	1885c83a 	sub	r2,r3,r2
 8241f24:	1007883a 	mov	r3,r2
 8241f28:	e0bffb03 	ldbu	r2,-20(fp)
 8241f2c:	1885883a 	add	r2,r3,r2
 8241f30:	e0bffb45 	stb	r2,-19(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 8241f34:	e0bffe17 	ldw	r2,-8(fp)
 8241f38:	10c00117 	ldw	r3,4(r2)
 8241f3c:	e0bfff17 	ldw	r2,-4(fp)
 8241f40:	10801f17 	ldw	r2,124(r2)
 8241f44:	e13ffb43 	ldbu	r4,-19(fp)
 8241f48:	200d883a 	mov	r6,r4
 8241f4c:	100b883a 	mov	r5,r2
 8241f50:	1809883a 	mov	r4,r3
 8241f54:	8202c5c0 	call	8202c5c <memcpy>

   rfqp = &(irep->rfq);
 8241f58:	e0bfff17 	ldw	r2,-4(fp)
 8241f5c:	10800604 	addi	r2,r2,24
 8241f60:	e0bff715 	stw	r2,-36(fp)
   writep = reassy_pkt->nb_buff + offset;
 8241f64:	e0bffe17 	ldw	r2,-8(fp)
 8241f68:	10c00117 	ldw	r3,4(r2)
 8241f6c:	e0bffb43 	ldbu	r2,-19(fp)
 8241f70:	1885883a 	add	r2,r3,r2
 8241f74:	e0bffc15 	stw	r2,-16(fp)

   while (rfqp)
 8241f78:	00004506 	br	8242090 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241f7c:	e03ff80d 	sth	zero,-32(fp)
 8241f80:	00003b06 	br	8242070 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a4>
         {
         if ((p = rfqp->bufp [i]) != 0)
 8241f84:	e0bff80b 	ldhu	r2,-32(fp)
 8241f88:	e0fff717 	ldw	r3,-36(fp)
 8241f8c:	10800044 	addi	r2,r2,1
 8241f90:	1085883a 	add	r2,r2,r2
 8241f94:	1085883a 	add	r2,r2,r2
 8241f98:	1885883a 	add	r2,r3,r2
 8241f9c:	10800017 	ldw	r2,0(r2)
 8241fa0:	e0bffd15 	stw	r2,-12(fp)
 8241fa4:	e0bffd17 	ldw	r2,-12(fp)
 8241fa8:	10002926 	beq	r2,zero,8242050 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 8241fac:	e0bff80b 	ldhu	r2,-32(fp)
 8241fb0:	e0fff717 	ldw	r3,-36(fp)
 8241fb4:	10800884 	addi	r2,r2,34
 8241fb8:	1085883a 	add	r2,r2,r2
 8241fbc:	1885883a 	add	r2,r3,r2
 8241fc0:	1080000b 	ldhu	r2,0(r2)
 8241fc4:	10bfffcc 	andi	r2,r2,65535
 8241fc8:	e0fffc17 	ldw	r3,-16(fp)
 8241fcc:	1887883a 	add	r3,r3,r2
 8241fd0:	e0bffd17 	ldw	r2,-12(fp)
 8241fd4:	11000317 	ldw	r4,12(r2)
 8241fd8:	e0bffd17 	ldw	r2,-12(fp)
 8241fdc:	10800417 	ldw	r2,16(r2)
 8241fe0:	100d883a 	mov	r6,r2
 8241fe4:	200b883a 	mov	r5,r4
 8241fe8:	1809883a 	mov	r4,r3
 8241fec:	8202c5c0 	call	8202c5c <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 8241ff0:	e0bff917 	ldw	r2,-28(fp)
 8241ff4:	1000031e 	bne	r2,zero,8242004 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x138>
 8241ff8:	e0bffd17 	ldw	r2,-12(fp)
 8241ffc:	e0bff915 	stw	r2,-28(fp)
 8242000:	00000b06 	br	8242030 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 8242004:	e0bffd17 	ldw	r2,-12(fp)
 8242008:	10800217 	ldw	r2,8(r2)
 824200c:	10bfffcc 	andi	r2,r2,65535
 8242010:	1009883a 	mov	r4,r2
 8242014:	82410080 	call	8241008 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 8242018:	01000084 	movi	r4,2
 824201c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
               pk_free (p);
 8242020:	e13ffd17 	ldw	r4,-12(fp)
 8242024:	822ca880 	call	822ca88 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242028:	01000084 	movi	r4,2
 824202c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 8242030:	e0bff80b 	ldhu	r2,-32(fp)
 8242034:	e0fff717 	ldw	r3,-36(fp)
 8242038:	10800044 	addi	r2,r2,1
 824203c:	1085883a 	add	r2,r2,r2
 8242040:	1085883a 	add	r2,r2,r2
 8242044:	1885883a 	add	r2,r3,r2
 8242048:	10000015 	stw	zero,0(r2)
 824204c:	00000506 	br	8242064 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x198>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242050:	e0bfff17 	ldw	r2,-4(fp)
 8242054:	10802103 	ldbu	r2,132(r2)
 8242058:	10803fcc 	andi	r2,r2,255
 824205c:	1080004c 	andi	r2,r2,1
 8242060:	1000071e 	bne	r2,zero,8242080 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b4>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242064:	e0bff80b 	ldhu	r2,-32(fp)
 8242068:	10800044 	addi	r2,r2,1
 824206c:	e0bff80d 	sth	r2,-32(fp)
 8242070:	e0bff80b 	ldhu	r2,-32(fp)
 8242074:	10800430 	cmpltui	r2,r2,16
 8242078:	103fc21e 	bne	r2,zero,8241f84 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb8>
 824207c:	00000106 	br	8242084 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242080:	0001883a 	nop
               }
            }
          }

      rfqp = rfqp->next;
 8242084:	e0bff717 	ldw	r2,-36(fp)
 8242088:	10800017 	ldw	r2,0(r2)
 824208c:	e0bff715 	stw	r2,-36(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 8242090:	e0bff717 	ldw	r2,-36(fp)
 8242094:	103fb91e 	bne	r2,zero,8241f7c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb0>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 8242098:	e0bffe17 	ldw	r2,-8(fp)
 824209c:	10800117 	ldw	r2,4(r2)
 82420a0:	e0ffff17 	ldw	r3,-4(fp)
 82420a4:	18c02017 	ldw	r3,128(r3)
 82420a8:	1809883a 	mov	r4,r3
 82420ac:	e0ffff17 	ldw	r3,-4(fp)
 82420b0:	18c01f17 	ldw	r3,124(r3)
 82420b4:	20c7c83a 	sub	r3,r4,r3
 82420b8:	10c7883a 	add	r3,r2,r3
 82420bc:	e0bffe17 	ldw	r2,-8(fp)
 82420c0:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 82420c4:	e0bfff17 	ldw	r2,-4(fp)
 82420c8:	1080040b 	ldhu	r2,16(r2)
 82420cc:	10ffffcc 	andi	r3,r2,65535
 82420d0:	e0bffb03 	ldbu	r2,-20(fp)
 82420d4:	1885883a 	add	r2,r3,r2
 82420d8:	1007883a 	mov	r3,r2
 82420dc:	e0bffe17 	ldw	r2,-8(fp)
 82420e0:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 82420e4:	d0a0a817 	ldw	r2,-32096(gp)
 82420e8:	1007883a 	mov	r3,r2
 82420ec:	e0bffe17 	ldw	r2,-8(fp)
 82420f0:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 82420f4:	e0bffe17 	ldw	r2,-8(fp)
 82420f8:	10c00a17 	ldw	r3,40(r2)
 82420fc:	e0bff917 	ldw	r2,-28(fp)
 8242100:	10800a17 	ldw	r2,40(r2)
 8242104:	108000cc 	andi	r2,r2,3
 8242108:	1886b03a 	or	r3,r3,r2
 824210c:	e0bffe17 	ldw	r2,-8(fp)
 8242110:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 8242114:	e0bff917 	ldw	r2,-28(fp)
 8242118:	10c00617 	ldw	r3,24(r2)
 824211c:	e0bffe17 	ldw	r2,-8(fp)
 8242120:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 8242124:	e0bff917 	ldw	r2,-28(fp)
 8242128:	10c0080b 	ldhu	r3,32(r2)
 824212c:	e0bffe17 	ldw	r2,-8(fp)
 8242130:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 8242134:	e0bff917 	ldw	r2,-28(fp)
 8242138:	10800217 	ldw	r2,8(r2)
 824213c:	10bfffcc 	andi	r2,r2,65535
 8242140:	1009883a 	mov	r4,r2
 8242144:	82410080 	call	8241008 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8242148:	01000084 	movi	r4,2
 824214c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 8242150:	e13ff917 	ldw	r4,-28(fp)
 8242154:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242158:	01000084 	movi	r4,2
 824215c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 8242160:	e0bffe17 	ldw	r2,-8(fp)
 8242164:	10800317 	ldw	r2,12(r2)
 8242168:	e0bffa15 	stw	r2,-24(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 824216c:	e0bffe17 	ldw	r2,-8(fp)
 8242170:	10800417 	ldw	r2,16(r2)
 8242174:	1004d23a 	srli	r2,r2,8
 8242178:	10803fcc 	andi	r2,r2,255
 824217c:	1007883a 	mov	r3,r2
 8242180:	e0bffe17 	ldw	r2,-8(fp)
 8242184:	10800417 	ldw	r2,16(r2)
 8242188:	1004923a 	slli	r2,r2,8
 824218c:	1884b03a 	or	r2,r3,r2
 8242190:	1007883a 	mov	r3,r2
 8242194:	e0bffa17 	ldw	r2,-24(fp)
 8242198:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 824219c:	e0bffa17 	ldw	r2,-24(fp)
 82421a0:	10c0018b 	ldhu	r3,6(r2)
 82421a4:	00bff7c4 	movi	r2,-33
 82421a8:	1884703a 	and	r2,r3,r2
 82421ac:	1007883a 	mov	r3,r2
 82421b0:	e0bffa17 	ldw	r2,-24(fp)
 82421b4:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 82421b8:	e0bffa17 	ldw	r2,-24(fp)
 82421bc:	1080018b 	ldhu	r2,6(r2)
 82421c0:	1080380c 	andi	r2,r2,224
 82421c4:	1007883a 	mov	r3,r2
 82421c8:	e0bffa17 	ldw	r2,-24(fp)
 82421cc:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 82421d0:	e0bffa17 	ldw	r2,-24(fp)
 82421d4:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 82421d8:	e0bffb03 	ldbu	r2,-20(fp)
 82421dc:	1004d07a 	srli	r2,r2,1
 82421e0:	10803fcc 	andi	r2,r2,255
 82421e4:	100b883a 	mov	r5,r2
 82421e8:	e13ffa17 	ldw	r4,-24(fp)
 82421ec:	82285000 	call	8228500 <cksum>
 82421f0:	0084303a 	nor	r2,zero,r2
 82421f4:	1007883a 	mov	r3,r2
 82421f8:	e0bffa17 	ldw	r2,-24(fp)
 82421fc:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 8242200:	0005883a 	mov	r2,zero
}
 8242204:	e037883a 	mov	sp,fp
 8242208:	dfc00117 	ldw	ra,4(sp)
 824220c:	df000017 	ldw	fp,0(sp)
 8242210:	dec00204 	addi	sp,sp,8
 8242214:	f800283a 	ret

08242218 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 8242218:	defffc04 	addi	sp,sp,-16
 824221c:	dfc00315 	stw	ra,12(sp)
 8242220:	df000215 	stw	fp,8(sp)
 8242224:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 8242228:	0009883a 	mov	r4,zero
 824222c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 8242230:	d0a0c817 	ldw	r2,-31968(gp)
 8242234:	e0bffe15 	stw	r2,-8(fp)
 8242238:	00002006 	br	82422bc <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 824223c:	e0bffe17 	ldw	r2,-8(fp)
 8242240:	10800017 	ldw	r2,0(r2)
 8242244:	e0bfff15 	stw	r2,-4(fp)
      ++tmpp->age;
 8242248:	e0bffe17 	ldw	r2,-8(fp)
 824224c:	10800517 	ldw	r2,20(r2)
 8242250:	10c00044 	addi	r3,r2,1
 8242254:	e0bffe17 	ldw	r2,-8(fp)
 8242258:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 824225c:	e0bffe17 	ldw	r2,-8(fp)
 8242260:	10800517 	ldw	r2,20(r2)
 8242264:	10801e18 	cmpnei	r2,r2,120
 8242268:	1000121e 	bne	r2,zero,82422b4 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 824226c:	008209b4 	movhi	r2,2086
 8242270:	10b99404 	addi	r2,r2,-6576
 8242274:	10800117 	ldw	r2,4(r2)
 8242278:	10c00044 	addi	r3,r2,1
 824227c:	008209b4 	movhi	r2,2086
 8242280:	10b99404 	addi	r2,r2,-6576
 8242284:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 8242288:	e13ffe17 	ldw	r4,-8(fp)
 824228c:	824292c0 	call	824292c <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 8242290:	e13ffe17 	ldw	r4,-8(fp)
 8242294:	82422f00 	call	82422f0 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8242298:	008209b4 	movhi	r2,2086
 824229c:	10b98004 	addi	r2,r2,-6656
 82422a0:	10800f17 	ldw	r2,60(r2)
 82422a4:	10c00044 	addi	r3,r2,1
 82422a8:	008209b4 	movhi	r2,2086
 82422ac:	10b98004 	addi	r2,r2,-6656
 82422b0:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 82422b4:	e0bfff17 	ldw	r2,-4(fp)
 82422b8:	e0bffe15 	stw	r2,-8(fp)
 82422bc:	e0bffe17 	ldw	r2,-8(fp)
 82422c0:	103fde1e 	bne	r2,zero,824223c <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 82422c4:	d0a0a817 	ldw	r2,-32096(gp)
 82422c8:	10801904 	addi	r2,r2,100
 82422cc:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 82422d0:	0009883a 	mov	r4,zero
 82422d4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 82422d8:	0005883a 	mov	r2,zero
}
 82422dc:	e037883a 	mov	sp,fp
 82422e0:	dfc00117 	ldw	ra,4(sp)
 82422e4:	df000017 	ldw	fp,0(sp)
 82422e8:	dec00204 	addi	sp,sp,8
 82422ec:	f800283a 	ret

082422f0 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 82422f0:	defff604 	addi	sp,sp,-40
 82422f4:	dfc00915 	stw	ra,36(sp)
 82422f8:	df000815 	stw	fp,32(sp)
 82422fc:	df000804 	addi	fp,sp,32
 8242300:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 8242304:	e03ffb15 	stw	zero,-20(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242308:	d0a0c817 	ldw	r2,-31968(gp)
 824230c:	e0bffa15 	stw	r2,-24(fp)
 8242310:	00001406 	br	8242364 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 8242314:	e0fffa17 	ldw	r3,-24(fp)
 8242318:	e0bfff17 	ldw	r2,-4(fp)
 824231c:	18800c1e 	bne	r3,r2,8242350 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 8242320:	d0a0c817 	ldw	r2,-31968(gp)
 8242324:	e0fffa17 	ldw	r3,-24(fp)
 8242328:	1880041e 	bne	r3,r2,824233c <ip_reasm_delete_ire+0x4c>
 824232c:	e0bfff17 	ldw	r2,-4(fp)
 8242330:	10800017 	ldw	r2,0(r2)
 8242334:	d0a0c815 	stw	r2,-31968(gp)
         else prev_tmpp->next = irep->next;
         break;
 8242338:	00000c06 	br	824236c <ip_reasm_delete_ire+0x7c>
      {
      if (tmpp == irep) 
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
         else prev_tmpp->next = irep->next;
 824233c:	e0bfff17 	ldw	r2,-4(fp)
 8242340:	10c00017 	ldw	r3,0(r2)
 8242344:	e0bffb17 	ldw	r2,-20(fp)
 8242348:	10c00015 	stw	r3,0(r2)
         break;
 824234c:	00000706 	br	824236c <ip_reasm_delete_ire+0x7c>
         }
      prev_tmpp = tmpp;
 8242350:	e0bffa17 	ldw	r2,-24(fp)
 8242354:	e0bffb15 	stw	r2,-20(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242358:	e0bffa17 	ldw	r2,-24(fp)
 824235c:	10800017 	ldw	r2,0(r2)
 8242360:	e0bffa15 	stw	r2,-24(fp)
 8242364:	e0bffa17 	ldw	r2,-24(fp)
 8242368:	103fea1e 	bne	r2,zero,8242314 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 824236c:	e0bffa17 	ldw	r2,-24(fp)
 8242370:	1000091e 	bne	r2,zero,8242398 <ip_reasm_delete_ire+0xa8>
      {
      ++ire_stats.bad_irep;
 8242374:	008209b4 	movhi	r2,2086
 8242378:	10b99404 	addi	r2,r2,-6576
 824237c:	10800017 	ldw	r2,0(r2)
 8242380:	10c00044 	addi	r3,r2,1
 8242384:	008209b4 	movhi	r2,2086
 8242388:	10b99404 	addi	r2,r2,-6576
 824238c:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 8242390:	00bffd84 	movi	r2,-10
 8242394:	00003e06 	br	8242490 <ip_reasm_delete_ire+0x1a0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 8242398:	e0bfff17 	ldw	r2,-4(fp)
 824239c:	10800604 	addi	r2,r2,24
 82423a0:	e0bffc15 	stw	r2,-16(fp)
 82423a4:	e0bffc17 	ldw	r2,-16(fp)
 82423a8:	e0bff815 	stw	r2,-32(fp)

   while (rfqp)
 82423ac:	00003106 	br	8242474 <ip_reasm_delete_ire+0x184>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82423b0:	e03ff90d 	sth	zero,-28(fp)
 82423b4:	00001e06 	br	8242430 <ip_reasm_delete_ire+0x140>
         {
         if ((p = rfqp->bufp [i]) != 0)
 82423b8:	e0bff90b 	ldhu	r2,-28(fp)
 82423bc:	e0fff817 	ldw	r3,-32(fp)
 82423c0:	10800044 	addi	r2,r2,1
 82423c4:	1085883a 	add	r2,r2,r2
 82423c8:	1085883a 	add	r2,r2,r2
 82423cc:	1885883a 	add	r2,r3,r2
 82423d0:	10800017 	ldw	r2,0(r2)
 82423d4:	e0bffd15 	stw	r2,-12(fp)
 82423d8:	e0bffd17 	ldw	r2,-12(fp)
 82423dc:	10000c26 	beq	r2,zero,8242410 <ip_reasm_delete_ire+0x120>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 82423e0:	e0bffd17 	ldw	r2,-12(fp)
 82423e4:	10800217 	ldw	r2,8(r2)
 82423e8:	10bfffcc 	andi	r2,r2,65535
 82423ec:	1009883a 	mov	r4,r2
 82423f0:	82410080 	call	8241008 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 82423f4:	01000084 	movi	r4,2
 82423f8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free (p);
 82423fc:	e13ffd17 	ldw	r4,-12(fp)
 8242400:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 8242404:	01000084 	movi	r4,2
 8242408:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
 824240c:	00000506 	br	8242424 <ip_reasm_delete_ire+0x134>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242410:	e0bfff17 	ldw	r2,-4(fp)
 8242414:	10802103 	ldbu	r2,132(r2)
 8242418:	10803fcc 	andi	r2,r2,255
 824241c:	1080004c 	andi	r2,r2,1
 8242420:	1000071e 	bne	r2,zero,8242440 <ip_reasm_delete_ire+0x150>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242424:	e0bff90b 	ldhu	r2,-28(fp)
 8242428:	10800044 	addi	r2,r2,1
 824242c:	e0bff90d 	sth	r2,-28(fp)
 8242430:	e0bff90b 	ldhu	r2,-28(fp)
 8242434:	10800430 	cmpltui	r2,r2,16
 8242438:	103fdf1e 	bne	r2,zero,82423b8 <ip_reasm_delete_ire+0xc8>
 824243c:	00000106 	br	8242444 <ip_reasm_delete_ire+0x154>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242440:	0001883a 	nop
               }
            }
          }

       prev_rfqp = rfqp;
 8242444:	e0bff817 	ldw	r2,-32(fp)
 8242448:	e0bffe15 	stw	r2,-8(fp)
       rfqp = rfqp->next;
 824244c:	e0bff817 	ldw	r2,-32(fp)
 8242450:	10800017 	ldw	r2,0(r2)
 8242454:	e0bff815 	stw	r2,-32(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 8242458:	e0fffe17 	ldw	r3,-8(fp)
 824245c:	e0bffc17 	ldw	r2,-16(fp)
 8242460:	18800426 	beq	r3,r2,8242474 <ip_reasm_delete_ire+0x184>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 8242464:	01001904 	movi	r4,100
 8242468:	82410080 	call	8241008 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 824246c:	e13ffe17 	ldw	r4,-8(fp)
 8242470:	822deec0 	call	822deec <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 8242474:	e0bff817 	ldw	r2,-32(fp)
 8242478:	103fcd1e 	bne	r2,zero,82423b0 <ip_reasm_delete_ire+0xc0>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 824247c:	01002204 	movi	r4,136
 8242480:	82410080 	call	8241008 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 8242484:	e13fff17 	ldw	r4,-4(fp)
 8242488:	822deec0 	call	822deec <npfree>

   return IPREASM_OK;
 824248c:	0005883a 	mov	r2,zero
}
 8242490:	e037883a 	mov	sp,fp
 8242494:	dfc00117 	ldw	ra,4(sp)
 8242498:	df000017 	ldw	fp,0(sp)
 824249c:	dec00204 	addi	sp,sp,8
 82424a0:	f800283a 	ret

082424a4 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 82424a4:	defffb04 	addi	sp,sp,-20
 82424a8:	dfc00415 	stw	ra,16(sp)
 82424ac:	df000315 	stw	fp,12(sp)
 82424b0:	df000304 	addi	fp,sp,12
 82424b4:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 82424b8:	e03ffe85 	stb	zero,-6(fp)
   u_char compact = IPREASM_TRUE;
 82424bc:	00800044 	movi	r2,1
 82424c0:	e0bffec5 	stb	r2,-5(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 82424c4:	e13fff17 	ldw	r4,-4(fp)
 82424c8:	8241e740 	call	8241e74 <ip_reasm_find_ire>
 82424cc:	10803fcc 	andi	r2,r2,255
 82424d0:	10800060 	cmpeqi	r2,r2,1
 82424d4:	1000091e 	bne	r2,zero,82424fc <ip_reasm_mark_compact_rfq+0x58>
   {
      ++ire_stats.bad_irep;
 82424d8:	008209b4 	movhi	r2,2086
 82424dc:	10b99404 	addi	r2,r2,-6576
 82424e0:	10800017 	ldw	r2,0(r2)
 82424e4:	10c00044 	addi	r3,r2,1
 82424e8:	008209b4 	movhi	r2,2086
 82424ec:	10b99404 	addi	r2,r2,-6576
 82424f0:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 82424f4:	00bffd84 	movi	r2,-10
 82424f8:	00003106 	br	82425c0 <ip_reasm_mark_compact_rfq+0x11c>
   }

   rfqp = &(irep->rfq);
 82424fc:	e0bfff17 	ldw	r2,-4(fp)
 8242500:	10800604 	addi	r2,r2,24
 8242504:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 8242508:	00001a06 	br	8242574 <ip_reasm_mark_compact_rfq+0xd0>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824250c:	e03ffe0d 	sth	zero,-8(fp)
 8242510:	00001206 	br	824255c <ip_reasm_mark_compact_rfq+0xb8>
         {
         if (rfqp->bufp [i] == 0)
 8242514:	e0bffe0b 	ldhu	r2,-8(fp)
 8242518:	e0fffd17 	ldw	r3,-12(fp)
 824251c:	10800044 	addi	r2,r2,1
 8242520:	1085883a 	add	r2,r2,r2
 8242524:	1085883a 	add	r2,r2,r2
 8242528:	1885883a 	add	r2,r3,r2
 824252c:	10800017 	ldw	r2,0(r2)
 8242530:	1000031e 	bne	r2,zero,8242540 <ip_reasm_mark_compact_rfq+0x9c>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 8242534:	00800044 	movi	r2,1
 8242538:	e0bffe85 	stb	r2,-6(fp)
 824253c:	00000406 	br	8242550 <ip_reasm_mark_compact_rfq+0xac>
            }
         else
            {
            if (empty_slot_discovered) 
 8242540:	e0bffe83 	ldbu	r2,-6(fp)
 8242544:	10000226 	beq	r2,zero,8242550 <ip_reasm_mark_compact_rfq+0xac>
               {
               compact = IPREASM_FALSE;
 8242548:	e03ffec5 	stb	zero,-5(fp)
               break;
 824254c:	00000606 	br	8242568 <ip_reasm_mark_compact_rfq+0xc4>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242550:	e0bffe0b 	ldhu	r2,-8(fp)
 8242554:	10800044 	addi	r2,r2,1
 8242558:	e0bffe0d 	sth	r2,-8(fp)
 824255c:	e0bffe0b 	ldhu	r2,-8(fp)
 8242560:	10800430 	cmpltui	r2,r2,16
 8242564:	103feb1e 	bne	r2,zero,8242514 <ip_reasm_mark_compact_rfq+0x70>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 8242568:	e0bffd17 	ldw	r2,-12(fp)
 824256c:	10800017 	ldw	r2,0(r2)
 8242570:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 8242574:	e0bffd17 	ldw	r2,-12(fp)
 8242578:	103fe41e 	bne	r2,zero,824250c <ip_reasm_mark_compact_rfq+0x68>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 824257c:	e0bffec3 	ldbu	r2,-5(fp)
 8242580:	10000726 	beq	r2,zero,82425a0 <ip_reasm_mark_compact_rfq+0xfc>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 8242584:	e0bfff17 	ldw	r2,-4(fp)
 8242588:	10802103 	ldbu	r2,132(r2)
 824258c:	10800054 	ori	r2,r2,1
 8242590:	1007883a 	mov	r3,r2
 8242594:	e0bfff17 	ldw	r2,-4(fp)
 8242598:	10c02105 	stb	r3,132(r2)
 824259c:	00000706 	br	82425bc <ip_reasm_mark_compact_rfq+0x118>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 82425a0:	e0bfff17 	ldw	r2,-4(fp)
 82425a4:	10c02103 	ldbu	r3,132(r2)
 82425a8:	00bfff84 	movi	r2,-2
 82425ac:	1884703a 	and	r2,r3,r2
 82425b0:	1007883a 	mov	r3,r2
 82425b4:	e0bfff17 	ldw	r2,-4(fp)
 82425b8:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 82425bc:	0005883a 	mov	r2,zero
}
 82425c0:	e037883a 	mov	sp,fp
 82425c4:	dfc00117 	ldw	ra,4(sp)
 82425c8:	df000017 	ldw	fp,0(sp)
 82425cc:	dec00204 	addi	sp,sp,8
 82425d0:	f800283a 	ret

082425d4 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 82425d4:	deffeb04 	addi	sp,sp,-84
 82425d8:	dfc01415 	stw	ra,80(sp)
 82425dc:	df001315 	stw	fp,76(sp)
 82425e0:	dc401215 	stw	r17,72(sp)
 82425e4:	dc001115 	stw	r16,68(sp)
 82425e8:	df001304 	addi	fp,sp,76
 82425ec:	e13ffd15 	stw	r4,-12(fp)
   unsigned long ticks_elapsed = cticks;
 82425f0:	d0a0a817 	ldw	r2,-32096(gp)
 82425f4:	e0bffb15 	stw	r2,-20(fp)
   u_short size_ire = sizeof(IRE);
 82425f8:	00802204 	movi	r2,136
 82425fc:	e0bffc0d 	sth	r2,-16(fp)
   u_short size_rfq = sizeof(RFQ);
 8242600:	00801904 	movi	r2,100
 8242604:	e0bffc8d 	sth	r2,-14(fp)
   IREP tmpp;
   u_short count = 0;
 8242608:	e03ff80d 	sth	zero,-32(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 824260c:	e03ffa0d 	sth	zero,-24(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 8242610:	01420974 	movhi	r5,2085
 8242614:	2943f304 	addi	r5,r5,4044
 8242618:	e13ffd17 	ldw	r4,-12(fp)
 824261c:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 8242620:	d160c717 	ldw	r5,-31972(gp)
 8242624:	e0fffb17 	ldw	r3,-20(fp)
 8242628:	00947b34 	movhi	r2,20972
 824262c:	10a147c4 	addi	r2,r2,-31457
 8242630:	1888383a 	mulxuu	r4,r3,r2
 8242634:	1885383a 	mul	r2,r3,r2
 8242638:	1021883a 	mov	r16,r2
 824263c:	2023883a 	mov	r17,r4
 8242640:	8804d17a 	srli	r2,r17,5
 8242644:	e0fffc0b 	ldhu	r3,-16(fp)
 8242648:	e13ffc8b 	ldhu	r4,-14(fp)
 824264c:	d9000215 	stw	r4,8(sp)
 8242650:	d8c00115 	stw	r3,4(sp)
 8242654:	d8800015 	stw	r2,0(sp)
 8242658:	e1fffb17 	ldw	r7,-20(fp)
 824265c:	280d883a 	mov	r6,r5
 8242660:	01420974 	movhi	r5,2085
 8242664:	2943fa04 	addi	r5,r5,4072
 8242668:	e13ffd17 	ldw	r4,-12(fp)
 824266c:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 8242670:	008209b4 	movhi	r2,2086
 8242674:	10b99404 	addi	r2,r2,-6576
 8242678:	11800117 	ldw	r6,4(r2)
 824267c:	008209b4 	movhi	r2,2086
 8242680:	10b99404 	addi	r2,r2,-6576
 8242684:	11c00017 	ldw	r7,0(r2)
 8242688:	008209b4 	movhi	r2,2086
 824268c:	10b99404 	addi	r2,r2,-6576
 8242690:	10c00217 	ldw	r3,8(r2)
 8242694:	008209b4 	movhi	r2,2086
 8242698:	10b99404 	addi	r2,r2,-6576
 824269c:	11000317 	ldw	r4,12(r2)
 82426a0:	008209b4 	movhi	r2,2086
 82426a4:	10b99404 	addi	r2,r2,-6576
 82426a8:	11400417 	ldw	r5,16(r2)
 82426ac:	008209b4 	movhi	r2,2086
 82426b0:	10b99404 	addi	r2,r2,-6576
 82426b4:	10800517 	ldw	r2,20(r2)
 82426b8:	d8800315 	stw	r2,12(sp)
 82426bc:	d9400215 	stw	r5,8(sp)
 82426c0:	d9000115 	stw	r4,4(sp)
 82426c4:	d8c00015 	stw	r3,0(sp)
 82426c8:	01420974 	movhi	r5,2085
 82426cc:	29440a04 	addi	r5,r5,4136
 82426d0:	e13ffd17 	ldw	r4,-12(fp)
 82426d4:	8228bac0 	call	8228bac <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 82426d8:	d0a0c817 	ldw	r2,-31968(gp)
 82426dc:	100d883a 	mov	r6,r2
 82426e0:	01420974 	movhi	r5,2085
 82426e4:	29441f04 	addi	r5,r5,4220
 82426e8:	e13ffd17 	ldw	r4,-12(fp)
 82426ec:	8228bac0 	call	8228bac <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82426f0:	d0a0c817 	ldw	r2,-31968(gp)
 82426f4:	e0bff715 	stw	r2,-36(fp)
 82426f8:	00007c06 	br	82428ec <ipr_stats+0x318>
      {
      ++count;
 82426fc:	e0bff80b 	ldhu	r2,-32(fp)
 8242700:	10800044 	addi	r2,r2,1
 8242704:	e0bff80d 	sth	r2,-32(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 8242708:	e0bff717 	ldw	r2,-36(fp)
 824270c:	10800604 	addi	r2,r2,24
 8242710:	e0bff915 	stw	r2,-28(fp)
      while (rfqp)
 8242714:	00001e06 	br	8242790 <ipr_stats+0x1bc>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242718:	e03ffa8d 	sth	zero,-22(fp)
 824271c:	00001406 	br	8242770 <ipr_stats+0x19c>
            {
            if (rfqp->bufp [i] != 0)
 8242720:	e0bffa8b 	ldhu	r2,-22(fp)
 8242724:	e0fff917 	ldw	r3,-28(fp)
 8242728:	10800044 	addi	r2,r2,1
 824272c:	1085883a 	add	r2,r2,r2
 8242730:	1085883a 	add	r2,r2,r2
 8242734:	1885883a 	add	r2,r3,r2
 8242738:	10800017 	ldw	r2,0(r2)
 824273c:	10000426 	beq	r2,zero,8242750 <ipr_stats+0x17c>
               {
               ++frag_count;            
 8242740:	e0bffa0b 	ldhu	r2,-24(fp)
 8242744:	10800044 	addi	r2,r2,1
 8242748:	e0bffa0d 	sth	r2,-24(fp)
 824274c:	00000506 	br	8242764 <ipr_stats+0x190>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 8242750:	e0bff717 	ldw	r2,-36(fp)
 8242754:	10802103 	ldbu	r2,132(r2)
 8242758:	10803fcc 	andi	r2,r2,255
 824275c:	1080004c 	andi	r2,r2,1
 8242760:	1000071e 	bne	r2,zero,8242780 <ipr_stats+0x1ac>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242764:	e0bffa8b 	ldhu	r2,-22(fp)
 8242768:	10800044 	addi	r2,r2,1
 824276c:	e0bffa8d 	sth	r2,-22(fp)
 8242770:	e0bffa8b 	ldhu	r2,-22(fp)
 8242774:	10800430 	cmpltui	r2,r2,16
 8242778:	103fe91e 	bne	r2,zero,8242720 <ipr_stats+0x14c>
 824277c:	00000106 	br	8242784 <ipr_stats+0x1b0>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
                  {
                  break;
 8242780:	0001883a 	nop
                  }
               }
            }
         rfqp = rfqp->next;
 8242784:	e0bff917 	ldw	r2,-28(fp)
 8242788:	10800017 	ldw	r2,0(r2)
 824278c:	e0bff915 	stw	r2,-28(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 8242790:	e0bff917 	ldw	r2,-28(fp)
 8242794:	103fe01e 	bne	r2,zero,8242718 <ipr_stats+0x144>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 8242798:	e33ffa0b 	ldhu	r12,-24(fp)
 824279c:	e0bff717 	ldw	r2,-36(fp)
 82427a0:	10800117 	ldw	r2,4(r2)
 82427a4:	1006d63a 	srli	r3,r2,24
 82427a8:	e0bff717 	ldw	r2,-36(fp)
 82427ac:	10800117 	ldw	r2,4(r2)
 82427b0:	1004d23a 	srli	r2,r2,8
 82427b4:	10bfc00c 	andi	r2,r2,65280
 82427b8:	1886b03a 	or	r3,r3,r2
 82427bc:	e0bff717 	ldw	r2,-36(fp)
 82427c0:	10800117 	ldw	r2,4(r2)
 82427c4:	10bfc00c 	andi	r2,r2,65280
 82427c8:	1004923a 	slli	r2,r2,8
 82427cc:	1886b03a 	or	r3,r3,r2
 82427d0:	e0bff717 	ldw	r2,-36(fp)
 82427d4:	10800117 	ldw	r2,4(r2)
 82427d8:	1004963a 	slli	r2,r2,24
 82427dc:	1884b03a 	or	r2,r3,r2
 82427e0:	e0fff717 	ldw	r3,-36(fp)
 82427e4:	18c00217 	ldw	r3,8(r3)
 82427e8:	1808d63a 	srli	r4,r3,24
 82427ec:	e0fff717 	ldw	r3,-36(fp)
 82427f0:	18c00217 	ldw	r3,8(r3)
 82427f4:	1806d23a 	srli	r3,r3,8
 82427f8:	18ffc00c 	andi	r3,r3,65280
 82427fc:	20c8b03a 	or	r4,r4,r3
 8242800:	e0fff717 	ldw	r3,-36(fp)
 8242804:	18c00217 	ldw	r3,8(r3)
 8242808:	18ffc00c 	andi	r3,r3,65280
 824280c:	1806923a 	slli	r3,r3,8
 8242810:	20c8b03a 	or	r4,r4,r3
 8242814:	e0fff717 	ldw	r3,-36(fp)
 8242818:	18c00217 	ldw	r3,8(r3)
 824281c:	1806963a 	slli	r3,r3,24
 8242820:	20c6b03a 	or	r3,r4,r3
 8242824:	e13ff717 	ldw	r4,-36(fp)
 8242828:	21000383 	ldbu	r4,14(r4)
 824282c:	21003fcc 	andi	r4,r4,255
 8242830:	e17ff717 	ldw	r5,-36(fp)
 8242834:	2940030b 	ldhu	r5,12(r5)
 8242838:	297fffcc 	andi	r5,r5,65535
 824283c:	280ad23a 	srli	r5,r5,8
 8242840:	297fffcc 	andi	r5,r5,65535
 8242844:	29803fcc 	andi	r6,r5,255
 8242848:	e17ff717 	ldw	r5,-36(fp)
 824284c:	2940030b 	ldhu	r5,12(r5)
 8242850:	297fffcc 	andi	r5,r5,65535
 8242854:	280a923a 	slli	r5,r5,8
 8242858:	297fffcc 	andi	r5,r5,65535
 824285c:	314ab03a 	or	r5,r6,r5
 8242860:	e1bff717 	ldw	r6,-36(fp)
 8242864:	3180040b 	ldhu	r6,16(r6)
 8242868:	31bfffcc 	andi	r6,r6,65535
 824286c:	e1fff717 	ldw	r7,-36(fp)
 8242870:	39c0048b 	ldhu	r7,18(r7)
 8242874:	39ffffcc 	andi	r7,r7,65535
 8242878:	e23ff717 	ldw	r8,-36(fp)
 824287c:	42000517 	ldw	r8,20(r8)
 8242880:	e27ff717 	ldw	r9,-36(fp)
 8242884:	4a401f17 	ldw	r9,124(r9)
 8242888:	e2bff717 	ldw	r10,-36(fp)
 824288c:	52802017 	ldw	r10,128(r10)
 8242890:	e2fff717 	ldw	r11,-36(fp)
 8242894:	5ac02103 	ldbu	r11,132(r11)
 8242898:	5ac03fcc 	andi	r11,r11,255
 824289c:	5ac0004c 	andi	r11,r11,1
 82428a0:	dac00915 	stw	r11,36(sp)
 82428a4:	da800815 	stw	r10,32(sp)
 82428a8:	da400715 	stw	r9,28(sp)
 82428ac:	da000615 	stw	r8,24(sp)
 82428b0:	d9c00515 	stw	r7,20(sp)
 82428b4:	d9800415 	stw	r6,16(sp)
 82428b8:	d9400315 	stw	r5,12(sp)
 82428bc:	d9000215 	stw	r4,8(sp)
 82428c0:	d8c00115 	stw	r3,4(sp)
 82428c4:	d8800015 	stw	r2,0(sp)
 82428c8:	600f883a 	mov	r7,r12
 82428cc:	e1bff717 	ldw	r6,-36(fp)
 82428d0:	01420974 	movhi	r5,2085
 82428d4:	29442504 	addi	r5,r5,4244
 82428d8:	e13ffd17 	ldw	r4,-12(fp)
 82428dc:	8228bac0 	call	8228bac <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82428e0:	e0bff717 	ldw	r2,-36(fp)
 82428e4:	10800017 	ldw	r2,0(r2)
 82428e8:	e0bff715 	stw	r2,-36(fp)
 82428ec:	e0bff717 	ldw	r2,-36(fp)
 82428f0:	103f821e 	bne	r2,zero,82426fc <ipr_stats+0x128>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 82428f4:	e0bff80b 	ldhu	r2,-32(fp)
 82428f8:	100d883a 	mov	r6,r2
 82428fc:	01420974 	movhi	r5,2085
 8242900:	29444004 	addi	r5,r5,4352
 8242904:	e13ffd17 	ldw	r4,-12(fp)
 8242908:	8228bac0 	call	8228bac <ns_printf>

   return IPREASM_OK;
 824290c:	0005883a 	mov	r2,zero
}
 8242910:	e6fffe04 	addi	sp,fp,-8
 8242914:	dfc00317 	ldw	ra,12(sp)
 8242918:	df000217 	ldw	fp,8(sp)
 824291c:	dc400117 	ldw	r17,4(sp)
 8242920:	dc000017 	ldw	r16,0(sp)
 8242924:	dec00404 	addi	sp,sp,16
 8242928:	f800283a 	ret

0824292c <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 824292c:	defffc04 	addi	sp,sp,-16
 8242930:	dfc00315 	stw	ra,12(sp)
 8242934:	df000215 	stw	fp,8(sp)
 8242938:	df000204 	addi	fp,sp,8
 824293c:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 8242940:	e0bfff17 	ldw	r2,-4(fp)
 8242944:	10801f17 	ldw	r2,124(r2)
 8242948:	10000626 	beq	r2,zero,8242964 <ip_reasm_send_icmp_timex+0x38>
      {
      pip = (struct ip *) irep->l3_hdr;
 824294c:	e0bfff17 	ldw	r2,-4(fp)
 8242950:	10802017 	ldw	r2,128(r2)
 8242954:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 8242958:	01400044 	movi	r5,1
 824295c:	e13ffe17 	ldw	r4,-8(fp)
 8242960:	824b0100 	call	824b010 <icmp_timex>
      }

   return IPREASM_OK;
 8242964:	0005883a 	mov	r2,zero
}
 8242968:	e037883a 	mov	sp,fp
 824296c:	dfc00117 	ldw	ra,4(sp)
 8242970:	df000017 	ldw	fp,0(sp)
 8242974:	dec00204 	addi	sp,sp,8
 8242978:	f800283a 	ret

0824297c <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 824297c:	defff404 	addi	sp,sp,-48
 8242980:	dfc00b15 	stw	ra,44(sp)
 8242984:	df000a15 	stw	fp,40(sp)
 8242988:	dc000915 	stw	r16,36(sp)
 824298c:	df000a04 	addi	fp,sp,40
 8242990:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 8242994:	00bfffc4 	movi	r2,-1
 8242998:	e0bff715 	stw	r2,-36(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824299c:	d0a08317 	ldw	r2,-32244(gp)
 82429a0:	1081000c 	andi	r2,r2,1024
 82429a4:	10000e26 	beq	r2,zero,82429e0 <ip_rcv+0x64>
 82429a8:	d0a08317 	ldw	r2,-32244(gp)
 82429ac:	1080800c 	andi	r2,r2,512
 82429b0:	10000b26 	beq	r2,zero,82429e0 <ip_rcv+0x64>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
         p->nb_plen, net_num(p->net));
 82429b4:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 82429b8:	14000417 	ldw	r16,16(r2)
         p->nb_plen, net_num(p->net));
 82429bc:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 82429c0:	10800617 	ldw	r2,24(r2)
 82429c4:	1009883a 	mov	r4,r2
 82429c8:	82269b40 	call	82269b4 <if_netnumber>
 82429cc:	100d883a 	mov	r6,r2
 82429d0:	800b883a 	mov	r5,r16
 82429d4:	01020974 	movhi	r4,2085
 82429d8:	21044904 	addi	r4,r4,4388
 82429dc:	82030ec0 	call	82030ec <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   ip_mib.ipInReceives++;
 82429e0:	008209b4 	movhi	r2,2086
 82429e4:	10b98004 	addi	r2,r2,-6656
 82429e8:	10800217 	ldw	r2,8(r2)
 82429ec:	10c00044 	addi	r3,r2,1
 82429f0:	008209b4 	movhi	r2,2086
 82429f4:	10b98004 	addi	r2,r2,-6656
 82429f8:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 82429fc:	e0bffe17 	ldw	r2,-8(fp)
 8242a00:	10800317 	ldw	r2,12(r2)
 8242a04:	e0bff815 	stw	r2,-32(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 8242a08:	e0bffe17 	ldw	r2,-8(fp)
 8242a0c:	10800417 	ldw	r2,16(r2)
 8242a10:	e0fff817 	ldw	r3,-32(fp)
 8242a14:	18c0008b 	ldhu	r3,2(r3)
 8242a18:	18ffffcc 	andi	r3,r3,65535
 8242a1c:	1806d23a 	srli	r3,r3,8
 8242a20:	18ffffcc 	andi	r3,r3,65535
 8242a24:	19003fcc 	andi	r4,r3,255
 8242a28:	e0fff817 	ldw	r3,-32(fp)
 8242a2c:	18c0008b 	ldhu	r3,2(r3)
 8242a30:	18ffffcc 	andi	r3,r3,65535
 8242a34:	1806923a 	slli	r3,r3,8
 8242a38:	18ffffcc 	andi	r3,r3,65535
 8242a3c:	20c6b03a 	or	r3,r4,r3
 8242a40:	10c01f2e 	bgeu	r2,r3,8242ac0 <ip_rcv+0x144>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242a44:	d0a08317 	ldw	r2,-32244(gp)
 8242a48:	1081000c 	andi	r2,r2,1024
 8242a4c:	10000c26 	beq	r2,zero,8242a80 <ip_rcv+0x104>
 8242a50:	d0a08317 	ldw	r2,-32244(gp)
 8242a54:	1080800c 	andi	r2,r2,512
 8242a58:	10000926 	beq	r2,zero,8242a80 <ip_rcv+0x104>
      {
         dprintf("ip_rcv: bad pkt len\n");
 8242a5c:	01020974 	movhi	r4,2085
 8242a60:	21045204 	addi	r4,r4,4424
 8242a64:	82033700 	call	8203370 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242a68:	d0a08317 	ldw	r2,-32244(gp)
 8242a6c:	1080008c 	andi	r2,r2,2
 8242a70:	10000326 	beq	r2,zero,8242a80 <ip_rcv+0x104>
 8242a74:	e0bffe17 	ldw	r2,-8(fp)
 8242a78:	1009883a 	mov	r4,r2
 8242a7c:	824078c0 	call	824078c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242a80:	008209b4 	movhi	r2,2086
 8242a84:	10b98004 	addi	r2,r2,-6656
 8242a88:	10800317 	ldw	r2,12(r2)
 8242a8c:	10c00044 	addi	r3,r2,1
 8242a90:	008209b4 	movhi	r2,2086
 8242a94:	10b98004 	addi	r2,r2,-6656
 8242a98:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242a9c:	01000084 	movi	r4,2
 8242aa0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 8242aa4:	e0bffe17 	ldw	r2,-8(fp)
 8242aa8:	1009883a 	mov	r4,r2
 8242aac:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242ab0:	01000084 	movi	r4,2
 8242ab4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242ab8:	00bff804 	movi	r2,-32
 8242abc:	00008906 	br	8242ce4 <ip_rcv+0x368>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 8242ac0:	e0bff817 	ldw	r2,-32(fp)
 8242ac4:	1080008b 	ldhu	r2,2(r2)
 8242ac8:	10bfffcc 	andi	r2,r2,65535
 8242acc:	1004d23a 	srli	r2,r2,8
 8242ad0:	10bfffcc 	andi	r2,r2,65535
 8242ad4:	10c03fcc 	andi	r3,r2,255
 8242ad8:	e0bff817 	ldw	r2,-32(fp)
 8242adc:	1080008b 	ldhu	r2,2(r2)
 8242ae0:	10bfffcc 	andi	r2,r2,65535
 8242ae4:	1004923a 	slli	r2,r2,8
 8242ae8:	10bfffcc 	andi	r2,r2,65535
 8242aec:	1884b03a 	or	r2,r3,r2
 8242af0:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 8242af4:	e0bffe17 	ldw	r2,-8(fp)
 8242af8:	e0fff917 	ldw	r3,-28(fp)
 8242afc:	10c00415 	stw	r3,16(r2)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 8242b00:	e0bff817 	ldw	r2,-32(fp)
 8242b04:	10800003 	ldbu	r2,0(r2)
 8242b08:	10803fcc 	andi	r2,r2,255
 8242b0c:	1004d13a 	srli	r2,r2,4
 8242b10:	10803fcc 	andi	r2,r2,255
 8242b14:	10800120 	cmpeqi	r2,r2,4
 8242b18:	10001f1e 	bne	r2,zero,8242b98 <ip_rcv+0x21c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242b1c:	d0a08317 	ldw	r2,-32244(gp)
 8242b20:	1081000c 	andi	r2,r2,1024
 8242b24:	10000c26 	beq	r2,zero,8242b58 <ip_rcv+0x1dc>
 8242b28:	d0a08317 	ldw	r2,-32244(gp)
 8242b2c:	1080800c 	andi	r2,r2,512
 8242b30:	10000926 	beq	r2,zero,8242b58 <ip_rcv+0x1dc>
      {
         dprintf("ip_rcv: bad version number\n");
 8242b34:	01020974 	movhi	r4,2085
 8242b38:	21045704 	addi	r4,r4,4444
 8242b3c:	82033700 	call	8203370 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242b40:	d0a08317 	ldw	r2,-32244(gp)
 8242b44:	1080008c 	andi	r2,r2,2
 8242b48:	10000326 	beq	r2,zero,8242b58 <ip_rcv+0x1dc>
 8242b4c:	e0bffe17 	ldw	r2,-8(fp)
 8242b50:	1009883a 	mov	r4,r2
 8242b54:	824078c0 	call	824078c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242b58:	008209b4 	movhi	r2,2086
 8242b5c:	10b98004 	addi	r2,r2,-6656
 8242b60:	10800317 	ldw	r2,12(r2)
 8242b64:	10c00044 	addi	r3,r2,1
 8242b68:	008209b4 	movhi	r2,2086
 8242b6c:	10b98004 	addi	r2,r2,-6656
 8242b70:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242b74:	01000084 	movi	r4,2
 8242b78:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 8242b7c:	e0bffe17 	ldw	r2,-8(fp)
 8242b80:	1009883a 	mov	r4,r2
 8242b84:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242b88:	01000084 	movi	r4,2
 8242b8c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242b90:	00bff804 	movi	r2,-32
 8242b94:	00005306 	br	8242ce4 <ip_rcv+0x368>
   }

   csum = pip->ip_chksum;
 8242b98:	e0bff817 	ldw	r2,-32(fp)
 8242b9c:	1080028b 	ldhu	r2,10(r2)
 8242ba0:	e0bffa0d 	sth	r2,-24(fp)
   pip->ip_chksum = 0;
 8242ba4:	e0bff817 	ldw	r2,-32(fp)
 8242ba8:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 8242bac:	e0bff817 	ldw	r2,-32(fp)
 8242bb0:	10800003 	ldbu	r2,0(r2)
 8242bb4:	10803fcc 	andi	r2,r2,255
 8242bb8:	108003cc 	andi	r2,r2,15
 8242bbc:	1085883a 	add	r2,r2,r2
 8242bc0:	1085883a 	add	r2,r2,r2
 8242bc4:	e0bffb15 	stw	r2,-20(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 8242bc8:	e0bffb17 	ldw	r2,-20(fp)
 8242bcc:	1004d07a 	srli	r2,r2,1
 8242bd0:	100b883a 	mov	r5,r2
 8242bd4:	e13ff817 	ldw	r4,-32(fp)
 8242bd8:	82285000 	call	8228500 <cksum>
 8242bdc:	0084303a 	nor	r2,zero,r2
 8242be0:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 8242be4:	e0fffa0b 	ldhu	r3,-24(fp)
 8242be8:	e0bffc0b 	ldhu	r2,-16(fp)
 8242bec:	18802226 	beq	r3,r2,8242c78 <ip_rcv+0x2fc>
   {
      pip->ip_chksum = csum;
 8242bf0:	e0bff817 	ldw	r2,-32(fp)
 8242bf4:	e0fffa0b 	ldhu	r3,-24(fp)
 8242bf8:	10c0028d 	sth	r3,10(r2)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242bfc:	d0a08317 	ldw	r2,-32244(gp)
 8242c00:	1081000c 	andi	r2,r2,1024
 8242c04:	10000c26 	beq	r2,zero,8242c38 <ip_rcv+0x2bc>
 8242c08:	d0a08317 	ldw	r2,-32244(gp)
 8242c0c:	1080800c 	andi	r2,r2,512
 8242c10:	10000926 	beq	r2,zero,8242c38 <ip_rcv+0x2bc>
      {
         dprintf("ip_rcv: bad xsum\n");
 8242c14:	01020974 	movhi	r4,2085
 8242c18:	21045e04 	addi	r4,r4,4472
 8242c1c:	82033700 	call	8203370 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242c20:	d0a08317 	ldw	r2,-32244(gp)
 8242c24:	1080008c 	andi	r2,r2,2
 8242c28:	10000326 	beq	r2,zero,8242c38 <ip_rcv+0x2bc>
 8242c2c:	e0bffe17 	ldw	r2,-8(fp)
 8242c30:	1009883a 	mov	r4,r2
 8242c34:	824078c0 	call	824078c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242c38:	008209b4 	movhi	r2,2086
 8242c3c:	10b98004 	addi	r2,r2,-6656
 8242c40:	10800317 	ldw	r2,12(r2)
 8242c44:	10c00044 	addi	r3,r2,1
 8242c48:	008209b4 	movhi	r2,2086
 8242c4c:	10b98004 	addi	r2,r2,-6656
 8242c50:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242c54:	01000084 	movi	r4,2
 8242c58:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 8242c5c:	e0bffe17 	ldw	r2,-8(fp)
 8242c60:	1009883a 	mov	r4,r2
 8242c64:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242c68:	01000084 	movi	r4,2
 8242c6c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242c70:	00bff804 	movi	r2,-32
 8242c74:	00001b06 	br	8242ce4 <ip_rcv+0x368>
   }

   pip->ip_chksum = csum;
 8242c78:	e0bff817 	ldw	r2,-32(fp)
 8242c7c:	e0fffa0b 	ldhu	r3,-24(fp)
 8242c80:	10c0028d 	sth	r3,10(r2)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 8242c84:	00800044 	movi	r2,1
 8242c88:	e0bffc8d 	sth	r2,-14(fp)
    pktp = &p;
 8242c8c:	e0bffe04 	addi	r2,fp,-8
 8242c90:	e0bffd15 	stw	r2,-12(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242c94:	e03ff605 	stb	zero,-40(fp)
 8242c98:	00000d06 	br	8242cd0 <ip_rcv+0x354>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 8242c9c:	e0bff603 	ldbu	r2,-40(fp)
 8242ca0:	1085883a 	add	r2,r2,r2
 8242ca4:	1085883a 	add	r2,r2,r2
 8242ca8:	1007883a 	mov	r3,r2
 8242cac:	e0bffd17 	ldw	r2,-12(fp)
 8242cb0:	10c5883a 	add	r2,r2,r3
 8242cb4:	10800017 	ldw	r2,0(r2)
 8242cb8:	1009883a 	mov	r4,r2
 8242cbc:	8242cfc0 	call	8242cfc <ip_rcv_phase2>
 8242cc0:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242cc4:	e0bff603 	ldbu	r2,-40(fp)
 8242cc8:	10800044 	addi	r2,r2,1
 8242ccc:	e0bff605 	stb	r2,-40(fp)
 8242cd0:	e0bff603 	ldbu	r2,-40(fp)
 8242cd4:	10ffffcc 	andi	r3,r2,65535
 8242cd8:	e0bffc8b 	ldhu	r2,-14(fp)
 8242cdc:	18bfef36 	bltu	r3,r2,8242c9c <ip_rcv+0x320>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 8242ce0:	e0bff717 	ldw	r2,-36(fp)
}
 8242ce4:	e6ffff04 	addi	sp,fp,-4
 8242ce8:	dfc00217 	ldw	ra,8(sp)
 8242cec:	df000117 	ldw	fp,4(sp)
 8242cf0:	dc000017 	ldw	r16,0(sp)
 8242cf4:	dec00304 	addi	sp,sp,12
 8242cf8:	f800283a 	ret

08242cfc <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 8242cfc:	defff504 	addi	sp,sp,-44
 8242d00:	dfc00a15 	stw	ra,40(sp)
 8242d04:	df000915 	stw	fp,36(sp)
 8242d08:	df000904 	addi	fp,sp,36
 8242d0c:	e13fff15 	stw	r4,-4(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 8242d10:	e0bfff17 	ldw	r2,-4(fp)
 8242d14:	10800317 	ldw	r2,12(r2)
 8242d18:	e0bff815 	stw	r2,-32(fp)
   nt = p->net;      /* which interface it came in on */
 8242d1c:	e0bfff17 	ldw	r2,-4(fp)
 8242d20:	10800617 	ldw	r2,24(r2)
 8242d24:	e0bff915 	stw	r2,-28(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 8242d28:	e0bff817 	ldw	r2,-32(fp)
 8242d2c:	10800417 	ldw	r2,16(r2)
 8242d30:	1006d63a 	srli	r3,r2,24
 8242d34:	e0bff817 	ldw	r2,-32(fp)
 8242d38:	10800417 	ldw	r2,16(r2)
 8242d3c:	1004d23a 	srli	r2,r2,8
 8242d40:	10bfc00c 	andi	r2,r2,65280
 8242d44:	1886b03a 	or	r3,r3,r2
 8242d48:	e0bff817 	ldw	r2,-32(fp)
 8242d4c:	10800417 	ldw	r2,16(r2)
 8242d50:	10bfc00c 	andi	r2,r2,65280
 8242d54:	1004923a 	slli	r2,r2,8
 8242d58:	1886b03a 	or	r3,r3,r2
 8242d5c:	e0bff817 	ldw	r2,-32(fp)
 8242d60:	10800417 	ldw	r2,16(r2)
 8242d64:	1004963a 	slli	r2,r2,24
 8242d68:	1884b03a 	or	r2,r3,r2
 8242d6c:	10fc002c 	andhi	r3,r2,61440
 8242d70:	00b80034 	movhi	r2,57344
 8242d74:	1880171e 	bne	r3,r2,8242dd4 <ip_rcv_phase2+0xd8>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 8242d78:	e0bff817 	ldw	r2,-32(fp)
 8242d7c:	10800417 	ldw	r2,16(r2)
 8242d80:	e17ff917 	ldw	r5,-28(fp)
 8242d84:	1009883a 	mov	r4,r2
 8242d88:	82438f40 	call	82438f4 <lookup_mcast>
 8242d8c:	e0bffa15 	stw	r2,-24(fp)
      if (inm == NULL) 
 8242d90:	e0bffa17 	ldw	r2,-24(fp)
 8242d94:	1001081e 	bne	r2,zero,82431b8 <ip_rcv_phase2+0x4bc>
      {
         ip_mib.ipOutNoRoutes++;
 8242d98:	008209b4 	movhi	r2,2086
 8242d9c:	10b98004 	addi	r2,r2,-6656
 8242da0:	10800b17 	ldw	r2,44(r2)
 8242da4:	10c00044 	addi	r3,r2,1
 8242da8:	008209b4 	movhi	r2,2086
 8242dac:	10b98004 	addi	r2,r2,-6656
 8242db0:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8242db4:	01000084 	movi	r4,2
 8242db8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 8242dbc:	e13fff17 	ldw	r4,-4(fp)
 8242dc0:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242dc4:	01000084 	movi	r4,2
 8242dc8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 8242dcc:	00800084 	movi	r2,2
 8242dd0:	00013806 	br	82432b4 <ip_rcv_phase2+0x5b8>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8242dd4:	e0bff817 	ldw	r2,-32(fp)
 8242dd8:	10c00417 	ldw	r3,16(r2)
 8242ddc:	e0bff917 	ldw	r2,-28(fp)
 8242de0:	10800a17 	ldw	r2,40(r2)
 8242de4:	1880f726 	beq	r3,r2,82431c4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8242de8:	e0bff817 	ldw	r2,-32(fp)
 8242dec:	10800417 	ldw	r2,16(r2)
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8242df0:	10bfffe0 	cmpeqi	r2,r2,-1
 8242df4:	1000f31e 	bne	r2,zero,82431c4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8242df8:	e0bff817 	ldw	r2,-32(fp)
 8242dfc:	10c00417 	ldw	r3,16(r2)
 8242e00:	e0bff917 	ldw	r2,-28(fp)
 8242e04:	10800e17 	ldw	r2,56(r2)
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8242e08:	1880ee26 	beq	r3,r2,82431c4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8242e0c:	e0bff817 	ldw	r2,-32(fp)
 8242e10:	10c00417 	ldw	r3,16(r2)
 8242e14:	e0bff917 	ldw	r2,-28(fp)
 8242e18:	10800f17 	ldw	r2,60(r2)
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8242e1c:	1880e926 	beq	r3,r2,82431c4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8242e20:	e0bff817 	ldw	r2,-32(fp)
 8242e24:	10c00417 	ldw	r3,16(r2)
 8242e28:	e0bff917 	ldw	r2,-28(fp)
 8242e2c:	10801017 	ldw	r2,64(r2)
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8242e30:	1880e426 	beq	r3,r2,82431c4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
 8242e34:	e0bff917 	ldw	r2,-28(fp)
 8242e38:	10c00a17 	ldw	r3,40(r2)
 8242e3c:	e0bff917 	ldw	r2,-28(fp)
 8242e40:	10800c17 	ldw	r2,48(r2)
 8242e44:	0084303a 	nor	r2,zero,r2
 8242e48:	1884703a 	and	r2,r3,r2

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8242e4c:	1000dd26 	beq	r2,zero,82431c4 <ip_rcv_phase2+0x4c8>
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242e50:	d0a08317 	ldw	r2,-32244(gp)
 8242e54:	1081000c 	andi	r2,r2,1024
 8242e58:	10001826 	beq	r2,zero,8242ebc <ip_rcv_phase2+0x1c0>
 8242e5c:	d0a08317 	ldw	r2,-32244(gp)
 8242e60:	1080800c 	andi	r2,r2,512
 8242e64:	10001526 	beq	r2,zero,8242ebc <ip_rcv_phase2+0x1c0>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
       PUSH_IPADDR(pip->ip_dest));
 8242e68:	e0bff817 	ldw	r2,-32(fp)
 8242e6c:	10800417 	ldw	r2,16(r2)
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242e70:	10c03fcc 	andi	r3,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242e74:	e0bff817 	ldw	r2,-32(fp)
 8242e78:	10800417 	ldw	r2,16(r2)
 8242e7c:	1004d23a 	srli	r2,r2,8
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242e80:	11003fcc 	andi	r4,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242e84:	e0bff817 	ldw	r2,-32(fp)
 8242e88:	10800417 	ldw	r2,16(r2)
 8242e8c:	1004d43a 	srli	r2,r2,16
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242e90:	11403fcc 	andi	r5,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242e94:	e0bff817 	ldw	r2,-32(fp)
 8242e98:	10800417 	ldw	r2,16(r2)
 8242e9c:	1004d63a 	srli	r2,r2,24
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242ea0:	d8800015 	stw	r2,0(sp)
 8242ea4:	280f883a 	mov	r7,r5
 8242ea8:	200d883a 	mov	r6,r4
 8242eac:	180b883a 	mov	r5,r3
 8242eb0:	01020974 	movhi	r4,2085
 8242eb4:	21046304 	addi	r4,r4,4492
 8242eb8:	82030ec0 	call	82030ec <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 8242ebc:	008209b4 	movhi	r2,2086
 8242ec0:	10b98004 	addi	r2,r2,-6656
 8242ec4:	10800017 	ldw	r2,0(r2)
 8242ec8:	10800098 	cmpnei	r2,r2,2
 8242ecc:	10000f1e 	bne	r2,zero,8242f0c <ip_rcv_phase2+0x210>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8242ed0:	008209b4 	movhi	r2,2086
 8242ed4:	10b98004 	addi	r2,r2,-6656
 8242ed8:	10800a17 	ldw	r2,40(r2)
 8242edc:	10c00044 	addi	r3,r2,1
 8242ee0:	008209b4 	movhi	r2,2086
 8242ee4:	10b98004 	addi	r2,r2,-6656
 8242ee8:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8242eec:	01000084 	movi	r4,2
 8242ef0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
         pk_free(p);
 8242ef4:	e13fff17 	ldw	r4,-4(fp)
 8242ef8:	822ca880 	call	822ca88 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242efc:	01000084 	movi	r4,2
 8242f00:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 8242f04:	00bff7c4 	movi	r2,-33
 8242f08:	0000ea06 	br	82432b4 <ip_rcv_phase2+0x5b8>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 8242f0c:	008209b4 	movhi	r2,2086
 8242f10:	10b98004 	addi	r2,r2,-6656
 8242f14:	10800517 	ldw	r2,20(r2)
 8242f18:	10c00044 	addi	r3,r2,1
 8242f1c:	008209b4 	movhi	r2,2086
 8242f20:	10b98004 	addi	r2,r2,-6656
 8242f24:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 8242f28:	e0bff817 	ldw	r2,-32(fp)
 8242f2c:	10800203 	ldbu	r2,8(r2)
 8242f30:	10803fcc 	andi	r2,r2,255
 8242f34:	108000a8 	cmpgeui	r2,r2,2
 8242f38:	10001c1e 	bne	r2,zero,8242fac <ip_rcv_phase2+0x2b0>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8242f3c:	008209b4 	movhi	r2,2086
 8242f40:	10b98004 	addi	r2,r2,-6656
 8242f44:	10800a17 	ldw	r2,40(r2)
 8242f48:	10c00044 	addi	r3,r2,1
 8242f4c:	008209b4 	movhi	r2,2086
 8242f50:	10b98004 	addi	r2,r2,-6656
 8242f54:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 8242f58:	e0bff817 	ldw	r2,-32(fp)
 8242f5c:	10c00317 	ldw	r3,12(r2)
 8242f60:	e0bfff17 	ldw	r2,-4(fp)
 8242f64:	10800617 	ldw	r2,24(r2)
 8242f68:	11000a17 	ldw	r4,40(r2)
 8242f6c:	e0bfff17 	ldw	r2,-4(fp)
 8242f70:	10800617 	ldw	r2,24(r2)
 8242f74:	d8800015 	stw	r2,0(sp)
 8242f78:	01c2c004 	movi	r7,2816
 8242f7c:	e1bff817 	ldw	r6,-32(fp)
 8242f80:	200b883a 	mov	r5,r4
 8242f84:	1809883a 	mov	r4,r3
 8242f88:	824ad100 	call	824ad10 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8242f8c:	01000084 	movi	r4,2
 8242f90:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(p);
 8242f94:	e13fff17 	ldw	r4,-4(fp)
 8242f98:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242f9c:	01000084 	movi	r4,2
 8242fa0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8242fa4:	00bff7c4 	movi	r2,-33
 8242fa8:	0000c206 	br	82432b4 <ip_rcv_phase2+0x5b8>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 8242fac:	e0bff817 	ldw	r2,-32(fp)
 8242fb0:	10c00417 	ldw	r3,16(r2)
 8242fb4:	e0bfff17 	ldw	r2,-4(fp)
 8242fb8:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 8242fbc:	e0bfff17 	ldw	r2,-4(fp)
 8242fc0:	10800717 	ldw	r2,28(r2)
 8242fc4:	e0fffe04 	addi	r3,fp,-8
 8242fc8:	180b883a 	mov	r5,r3
 8242fcc:	1009883a 	mov	r4,r2
 8242fd0:	8240a340 	call	8240a34 <iproute>
 8242fd4:	e0bffb15 	stw	r2,-20(fp)
 8242fd8:	e0bffb17 	ldw	r2,-20(fp)
 8242fdc:	10000f1e 	bne	r2,zero,824301c <ip_rcv_phase2+0x320>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 8242fe0:	008209b4 	movhi	r2,2086
 8242fe4:	10b98004 	addi	r2,r2,-6656
 8242fe8:	10800b17 	ldw	r2,44(r2)
 8242fec:	10c00044 	addi	r3,r2,1
 8242ff0:	008209b4 	movhi	r2,2086
 8242ff4:	10b98004 	addi	r2,r2,-6656
 8242ff8:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8242ffc:	01000084 	movi	r4,2
 8243000:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
            pk_free(p);
 8243004:	e13fff17 	ldw	r4,-4(fp)
 8243008:	822ca880 	call	822ca88 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824300c:	01000084 	movi	r4,2
 8243010:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8243014:	00bff7c4 	movi	r2,-33
 8243018:	0000a606 	br	82432b4 <ip_rcv_phase2+0x5b8>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 824301c:	e0bff817 	ldw	r2,-32(fp)
 8243020:	10c00417 	ldw	r3,16(r2)
 8243024:	e0bffb17 	ldw	r2,-20(fp)
 8243028:	10800a17 	ldw	r2,40(r2)
 824302c:	18806426 	beq	r3,r2,82431c0 <ip_rcv_phase2+0x4c4>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8243030:	e0bff817 	ldw	r2,-32(fp)
 8243034:	10c00417 	ldw	r3,16(r2)
 8243038:	e0bffb17 	ldw	r2,-20(fp)
 824303c:	10800e17 	ldw	r2,56(r2)
 8243040:	18806026 	beq	r3,r2,82431c4 <ip_rcv_phase2+0x4c8>
            (pip->ip_dest == p->net->n_netbr))
 8243044:	e0bff817 	ldw	r2,-32(fp)
 8243048:	10c00417 	ldw	r3,16(r2)
 824304c:	e0bfff17 	ldw	r2,-4(fp)
 8243050:	10800617 	ldw	r2,24(r2)
 8243054:	10800e17 	ldw	r2,56(r2)
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8243058:	18805a26 	beq	r3,r2,82431c4 <ip_rcv_phase2+0x4c8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 824305c:	e0bfff17 	ldw	r2,-4(fp)
 8243060:	e0fffb17 	ldw	r3,-20(fp)
 8243064:	10c00615 	stw	r3,24(r2)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 8243068:	e0bfff17 	ldw	r2,-4(fp)
 824306c:	10800417 	ldw	r2,16(r2)
 8243070:	e0ffff17 	ldw	r3,-4(fp)
 8243074:	18c00617 	ldw	r3,24(r3)
 8243078:	18c00817 	ldw	r3,32(r3)
 824307c:	10c5883a 	add	r2,r2,r3
 8243080:	e0fffb17 	ldw	r3,-20(fp)
 8243084:	18c00917 	ldw	r3,36(r3)
 8243088:	1880372e 	bgeu	r3,r2,8243168 <ip_rcv_phase2+0x46c>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 824308c:	e0bff817 	ldw	r2,-32(fp)
 8243090:	1080018b 	ldhu	r2,6(r2)
 8243094:	10bfffcc 	andi	r2,r2,65535
 8243098:	1004d23a 	srli	r2,r2,8
 824309c:	10bfffcc 	andi	r2,r2,65535
 82430a0:	10c03fcc 	andi	r3,r2,255
 82430a4:	e0bff817 	ldw	r2,-32(fp)
 82430a8:	1080018b 	ldhu	r2,6(r2)
 82430ac:	10bfffcc 	andi	r2,r2,65535
 82430b0:	1004923a 	slli	r2,r2,8
 82430b4:	10bfffcc 	andi	r2,r2,65535
 82430b8:	1884b03a 	or	r2,r3,r2
 82430bc:	1090000c 	andi	r2,r2,16384
 82430c0:	10001c26 	beq	r2,zero,8243134 <ip_rcv_phase2+0x438>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82430c4:	e0bff817 	ldw	r2,-32(fp)
 82430c8:	10c00317 	ldw	r3,12(r2)
 82430cc:	e0bfff17 	ldw	r2,-4(fp)
 82430d0:	10800617 	ldw	r2,24(r2)
 82430d4:	11000a17 	ldw	r4,40(r2)
 82430d8:	e0bfff17 	ldw	r2,-4(fp)
 82430dc:	10800617 	ldw	r2,24(r2)
 82430e0:	d8800015 	stw	r2,0(sp)
 82430e4:	01c00104 	movi	r7,4
 82430e8:	e1bff817 	ldw	r6,-32(fp)
 82430ec:	200b883a 	mov	r5,r4
 82430f0:	1809883a 	mov	r4,r3
 82430f4:	824ad100 	call	824ad10 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 82430f8:	008209b4 	movhi	r2,2086
 82430fc:	10b98004 	addi	r2,r2,-6656
 8243100:	10801117 	ldw	r2,68(r2)
 8243104:	10c00044 	addi	r3,r2,1
 8243108:	008209b4 	movhi	r2,2086
 824310c:	10b98004 	addi	r2,r2,-6656
 8243110:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 8243114:	01000084 	movi	r4,2
 8243118:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
               pk_free(p);
 824311c:	e13fff17 	ldw	r4,-4(fp)
 8243120:	822ca880 	call	822ca88 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243124:	01000084 	movi	r4,2
 8243128:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 824312c:	00bffd44 	movi	r2,-11
 8243130:	00006006 	br	82432b4 <ip_rcv_phase2+0x5b8>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 8243134:	e0bff817 	ldw	r2,-32(fp)
 8243138:	10800203 	ldbu	r2,8(r2)
 824313c:	10bfffc4 	addi	r2,r2,-1
 8243140:	1007883a 	mov	r3,r2
 8243144:	e0bff817 	ldw	r2,-32(fp)
 8243148:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 824314c:	e0bffe17 	ldw	r2,-8(fp)
 8243150:	100b883a 	mov	r5,r2
 8243154:	e13fff17 	ldw	r4,-4(fp)
 8243158:	82401240 	call	8240124 <ip_fragment>
 824315c:	e0bffc15 	stw	r2,-16(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 8243160:	e0bffc17 	ldw	r2,-16(fp)
 8243164:	00005306 	br	82432b4 <ip_rcv_phase2+0x5b8>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 8243168:	e0bff817 	ldw	r2,-32(fp)
 824316c:	10800203 	ldbu	r2,8(r2)
 8243170:	10bfffc4 	addi	r2,r2,-1
 8243174:	1007883a 	mov	r3,r2
 8243178:	e0bff817 	ldw	r2,-32(fp)
 824317c:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 8243180:	e0bff817 	ldw	r2,-32(fp)
 8243184:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 8243188:	01400284 	movi	r5,10
 824318c:	e13ff817 	ldw	r4,-32(fp)
 8243190:	82285000 	call	8228500 <cksum>
 8243194:	0084303a 	nor	r2,zero,r2
 8243198:	1007883a 	mov	r3,r2
 824319c:	e0bff817 	ldw	r2,-32(fp)
 82431a0:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 82431a4:	e0bffe17 	ldw	r2,-8(fp)
 82431a8:	100b883a 	mov	r5,r2
 82431ac:	e13fff17 	ldw	r4,-4(fp)
 82431b0:	82264440 	call	8226444 <ip2mac>
 82431b4:	00003f06 	br	82432b4 <ip_rcv_phase2+0x5b8>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
      }
      else
         goto ours;
 82431b8:	0001883a 	nop
 82431bc:	00000106 	br	82431c4 <ip_rcv_phase2+0x4c8>
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
            goto ours;
 82431c0:	0001883a 	nop
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 82431c4:	e0bff817 	ldw	r2,-32(fp)
 82431c8:	1080018b 	ldhu	r2,6(r2)
 82431cc:	10bfffcc 	andi	r2,r2,65535
 82431d0:	1004d23a 	srli	r2,r2,8
 82431d4:	1007883a 	mov	r3,r2
 82431d8:	e0bff817 	ldw	r2,-32(fp)
 82431dc:	1080018b 	ldhu	r2,6(r2)
 82431e0:	10bfffcc 	andi	r2,r2,65535
 82431e4:	1004923a 	slli	r2,r2,8
 82431e8:	1884b03a 	or	r2,r3,r2
 82431ec:	e0bffd0d 	sth	r2,-12(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 82431f0:	e0bffd0b 	ldhu	r2,-12(fp)
 82431f4:	1088000c 	andi	r2,r2,8192
 82431f8:	1000051e 	bne	r2,zero,8243210 <ip_rcv_phase2+0x514>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
 82431fc:	e0fffd0b 	ldhu	r3,-12(fp)
 8243200:	00bffff4 	movhi	r2,65535
 8243204:	1087ffc4 	addi	r2,r2,8191
 8243208:	1884703a 	and	r2,r3,r2
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 824320c:	10002726 	beq	r2,zero,82432ac <ip_rcv_phase2+0x5b0>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243210:	d0a08317 	ldw	r2,-32244(gp)
 8243214:	1081000c 	andi	r2,r2,1024
 8243218:	10001a26 	beq	r2,zero,8243284 <ip_rcv_phase2+0x588>
 824321c:	d0a08317 	ldw	r2,-32244(gp)
 8243220:	1080800c 	andi	r2,r2,512
 8243224:	10001726 	beq	r2,zero,8243284 <ip_rcv_phase2+0x588>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
          PUSH_IPADDR(pip->ip_src));
 8243228:	e0bff817 	ldw	r2,-32(fp)
 824322c:	10800317 	ldw	r2,12(r2)
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243230:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243234:	e0bff817 	ldw	r2,-32(fp)
 8243238:	10800317 	ldw	r2,12(r2)
 824323c:	1004d23a 	srli	r2,r2,8
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243240:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243244:	e0bff817 	ldw	r2,-32(fp)
 8243248:	10800317 	ldw	r2,12(r2)
 824324c:	1004d43a 	srli	r2,r2,16
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243250:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243254:	e0bff817 	ldw	r2,-32(fp)
 8243258:	10800317 	ldw	r2,12(r2)
 824325c:	1004d63a 	srli	r2,r2,24
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243260:	d8800015 	stw	r2,0(sp)
 8243264:	280f883a 	mov	r7,r5
 8243268:	200d883a 	mov	r6,r4
 824326c:	180b883a 	mov	r5,r3
 8243270:	01020974 	movhi	r4,2085
 8243274:	21046f04 	addi	r4,r4,4540
 8243278:	82030ec0 	call	82030ec <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 824327c:	e13fff17 	ldw	r4,-4(fp)
 8243280:	824078c0 	call	824078c <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 8243284:	008209b4 	movhi	r2,2086
 8243288:	10b98004 	addi	r2,r2,-6656
 824328c:	10800d17 	ldw	r2,52(r2)
 8243290:	10c00044 	addi	r3,r2,1
 8243294:	008209b4 	movhi	r2,2086
 8243298:	10b98004 	addi	r2,r2,-6656
 824329c:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 82432a0:	e13fff17 	ldw	r4,-4(fp)
 82432a4:	82413580 	call	8241358 <ip_reassm>
 82432a8:	00000206 	br	82432b4 <ip_rcv_phase2+0x5b8>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 82432ac:	e13fff17 	ldw	r4,-4(fp)
 82432b0:	82432c80 	call	82432c8 <ip_demux>
}
 82432b4:	e037883a 	mov	sp,fp
 82432b8:	dfc00117 	ldw	ra,4(sp)
 82432bc:	df000017 	ldw	fp,0(sp)
 82432c0:	dec00204 	addi	sp,sp,8
 82432c4:	f800283a 	ret

082432c8 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 82432c8:	defff904 	addi	sp,sp,-28
 82432cc:	dfc00615 	stw	ra,24(sp)
 82432d0:	df000515 	stw	fp,20(sp)
 82432d4:	df000504 	addi	fp,sp,20
 82432d8:	e13fff15 	stw	r4,-4(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 82432dc:	e0bfff17 	ldw	r2,-4(fp)
 82432e0:	10800317 	ldw	r2,12(r2)
 82432e4:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 82432e8:	e0bffe17 	ldw	r2,-8(fp)
 82432ec:	10800003 	ldbu	r2,0(r2)
 82432f0:	10803fcc 	andi	r2,r2,255
 82432f4:	10801160 	cmpeqi	r2,r2,69
 82432f8:	1000131e 	bne	r2,zero,8243348 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 82432fc:	e0bffe17 	ldw	r2,-8(fp)
 8243300:	10800003 	ldbu	r2,0(r2)
 8243304:	10803fcc 	andi	r2,r2,255
 8243308:	10801170 	cmpltui	r2,r2,69
 824330c:	1000051e 	bne	r2,zero,8243324 <ip_demux+0x5c>
         (pip->ip_ver_ihl > 0x47))
 8243310:	e0bffe17 	ldw	r2,-8(fp)
 8243314:	10800003 	ldbu	r2,0(r2)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
   {
      if((pip->ip_ver_ihl < 0x45) ||
 8243318:	10803fcc 	andi	r2,r2,255
 824331c:	10801230 	cmpltui	r2,r2,72
 8243320:	1000091e 	bne	r2,zero,8243348 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 8243324:	e0bffe17 	ldw	r2,-8(fp)
 8243328:	10800003 	ldbu	r2,0(r2)
 824332c:	10803fcc 	andi	r2,r2,255
 8243330:	100b883a 	mov	r5,r2
 8243334:	01020974 	movhi	r4,2085
 8243338:	21047804 	addi	r4,r4,4576
 824333c:	82030ec0 	call	82030ec <printf>
         return ENP_LOGIC;
 8243340:	00bffd44 	movi	r2,-11
 8243344:	0000d006 	br	8243688 <ip_demux+0x3c0>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 8243348:	e0bffe17 	ldw	r2,-8(fp)
 824334c:	10c00317 	ldw	r3,12(r2)
 8243350:	e0bfff17 	ldw	r2,-4(fp)
 8243354:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243358:	d0a08317 	ldw	r2,-32244(gp)
 824335c:	1081000c 	andi	r2,r2,1024
 8243360:	10002126 	beq	r2,zero,82433e8 <ip_demux+0x120>
 8243364:	d0a08317 	ldw	r2,-32244(gp)
 8243368:	1080800c 	andi	r2,r2,512
 824336c:	10001e26 	beq	r2,zero,82433e8 <ip_demux+0x120>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243370:	e0bffe17 	ldw	r2,-8(fp)
 8243374:	10800243 	ldbu	r2,9(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243378:	11003fcc 	andi	r4,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824337c:	e0bffe17 	ldw	r2,-8(fp)
 8243380:	10800317 	ldw	r2,12(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243384:	11403fcc 	andi	r5,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243388:	e0bffe17 	ldw	r2,-8(fp)
 824338c:	10800317 	ldw	r2,12(r2)
 8243390:	1004d23a 	srli	r2,r2,8
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243394:	11803fcc 	andi	r6,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243398:	e0bffe17 	ldw	r2,-8(fp)
 824339c:	10800317 	ldw	r2,12(r2)
 82433a0:	1004d43a 	srli	r2,r2,16
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82433a4:	10803fcc 	andi	r2,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 82433a8:	e0fffe17 	ldw	r3,-8(fp)
 82433ac:	18c00317 	ldw	r3,12(r3)
 82433b0:	1806d63a 	srli	r3,r3,24
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82433b4:	d8c00115 	stw	r3,4(sp)
 82433b8:	d8800015 	stw	r2,0(sp)
 82433bc:	300f883a 	mov	r7,r6
 82433c0:	280d883a 	mov	r6,r5
 82433c4:	200b883a 	mov	r5,r4
 82433c8:	01020974 	movhi	r4,2085
 82433cc:	21047f04 	addi	r4,r4,4604
 82433d0:	82030ec0 	call	82030ec <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 82433d4:	d0a08317 	ldw	r2,-32244(gp)
 82433d8:	1080008c 	andi	r2,r2,2
 82433dc:	10000226 	beq	r2,zero,82433e8 <ip_demux+0x120>
 82433e0:	e13fff17 	ldw	r4,-4(fp)
 82433e4:	824078c0 	call	824078c <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 82433e8:	e0bffe17 	ldw	r2,-8(fp)
 82433ec:	10800243 	ldbu	r2,9(r2)
 82433f0:	10803fcc 	andi	r2,r2,255
 82433f4:	10c000a0 	cmpeqi	r3,r2,2
 82433f8:	18001f1e 	bne	r3,zero,8243478 <ip_demux+0x1b0>
 82433fc:	10c000c8 	cmpgei	r3,r2,3
 8243400:	1800031e 	bne	r3,zero,8243410 <ip_demux+0x148>
 8243404:	10800060 	cmpeqi	r2,r2,1
 8243408:	1000101e 	bne	r2,zero,824344c <ip_demux+0x184>
 824340c:	00003006 	br	82434d0 <ip_demux+0x208>
 8243410:	10c001a0 	cmpeqi	r3,r2,6
 8243414:	1800231e 	bne	r3,zero,82434a4 <ip_demux+0x1dc>
 8243418:	10800460 	cmpeqi	r2,r2,17
 824341c:	10002c26 	beq	r2,zero,82434d0 <ip_demux+0x208>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 8243420:	008209b4 	movhi	r2,2086
 8243424:	10b98004 	addi	r2,r2,-6656
 8243428:	10800817 	ldw	r2,32(r2)
 824342c:	10c00044 	addi	r3,r2,1
 8243430:	008209b4 	movhi	r2,2086
 8243434:	10b98004 	addi	r2,r2,-6656
 8243438:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 824343c:	e13fff17 	ldw	r4,-4(fp)
 8243440:	82445500 	call	8244550 <udpdemux>
 8243444:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243448:	00002c06 	br	82434fc <ip_demux+0x234>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 824344c:	008209b4 	movhi	r2,2086
 8243450:	10b98004 	addi	r2,r2,-6656
 8243454:	10800817 	ldw	r2,32(r2)
 8243458:	10c00044 	addi	r3,r2,1
 824345c:	008209b4 	movhi	r2,2086
 8243460:	10b98004 	addi	r2,r2,-6656
 8243464:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 8243468:	e13fff17 	ldw	r4,-4(fp)
 824346c:	824a1ac0 	call	824a1ac <icmprcv>
 8243470:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243474:	00002106 	br	82434fc <ip_demux+0x234>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 8243478:	008209b4 	movhi	r2,2086
 824347c:	10b98004 	addi	r2,r2,-6656
 8243480:	10800817 	ldw	r2,32(r2)
 8243484:	10c00044 	addi	r3,r2,1
 8243488:	008209b4 	movhi	r2,2086
 824348c:	10b98004 	addi	r2,r2,-6656
 8243490:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 8243494:	e13fff17 	ldw	r4,-4(fp)
 8243498:	8226adc0 	call	8226adc <igmp_input>
 824349c:	e0bffd15 	stw	r2,-12(fp)
      break;
 82434a0:	00001606 	br	82434fc <ip_demux+0x234>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 82434a4:	008209b4 	movhi	r2,2086
 82434a8:	10b98004 	addi	r2,r2,-6656
 82434ac:	10800817 	ldw	r2,32(r2)
 82434b0:	10c00044 	addi	r3,r2,1
 82434b4:	008209b4 	movhi	r2,2086
 82434b8:	10b98004 	addi	r2,r2,-6656
 82434bc:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 82434c0:	e13fff17 	ldw	r4,-4(fp)
 82434c4:	822eb500 	call	822eb50 <tcp_rcv>
 82434c8:	e0bffd15 	stw	r2,-12(fp)
      break;
 82434cc:	00000b06 	br	82434fc <ip_demux+0x234>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 82434d0:	008209b4 	movhi	r2,2086
 82434d4:	10b98004 	addi	r2,r2,-6656
 82434d8:	10800817 	ldw	r2,32(r2)
 82434dc:	10c00044 	addi	r3,r2,1
 82434e0:	008209b4 	movhi	r2,2086
 82434e4:	10b98004 	addi	r2,r2,-6656
 82434e8:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 82434ec:	e13fff17 	ldw	r4,-4(fp)
 82434f0:	8243bc00 	call	8243bc0 <ip_raw_input>
 82434f4:	e0bffd15 	stw	r2,-12(fp)
      break;
 82434f8:	0001883a 	nop
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 82434fc:	e0bffd17 	ldw	r2,-12(fp)
 8243500:	10bffda0 	cmpeqi	r2,r2,-10
 8243504:	1000021e 	bne	r2,zero,8243510 <ip_demux+0x248>
   {
      return err;
 8243508:	e0bffd17 	ldw	r2,-12(fp)
 824350c:	00005e06 	br	8243688 <ip_demux+0x3c0>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243510:	e0bffe17 	ldw	r2,-8(fp)
 8243514:	10800417 	ldw	r2,16(r2)
 8243518:	10bfffe0 	cmpeqi	r2,r2,-1
 824351c:	10004c1e 	bne	r2,zero,8243650 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243520:	e0bffe17 	ldw	r2,-8(fp)
 8243524:	10800417 	ldw	r2,16(r2)
 8243528:	1006d63a 	srli	r3,r2,24
 824352c:	e0bffe17 	ldw	r2,-8(fp)
 8243530:	10800417 	ldw	r2,16(r2)
 8243534:	1004d23a 	srli	r2,r2,8
 8243538:	10bfc00c 	andi	r2,r2,65280
 824353c:	1886b03a 	or	r3,r3,r2
 8243540:	e0bffe17 	ldw	r2,-8(fp)
 8243544:	10800417 	ldw	r2,16(r2)
 8243548:	10bfc00c 	andi	r2,r2,65280
 824354c:	1004923a 	slli	r2,r2,8
 8243550:	1886b03a 	or	r3,r3,r2
 8243554:	e0bffe17 	ldw	r2,-8(fp)
 8243558:	10800417 	ldw	r2,16(r2)
 824355c:	1004963a 	slli	r2,r2,24
 8243560:	1884b03a 	or	r2,r3,r2
 8243564:	10fc002c 	andhi	r3,r2,61440

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243568:	00b80034 	movhi	r2,57344
 824356c:	18803826 	beq	r3,r2,8243650 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 8243570:	e0bffe17 	ldw	r2,-8(fp)
 8243574:	10c00417 	ldw	r3,16(r2)
 8243578:	e0bfff17 	ldw	r2,-4(fp)
 824357c:	10800617 	ldw	r2,24(r2)
 8243580:	10800e17 	ldw	r2,56(r2)
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243584:	18803226 	beq	r3,r2,8243650 <ip_demux+0x388>
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8243588:	e0bffe17 	ldw	r2,-8(fp)
 824358c:	10c00417 	ldw	r3,16(r2)
 8243590:	e0bfff17 	ldw	r2,-4(fp)
 8243594:	10800617 	ldw	r2,24(r2)
 8243598:	10800f17 	ldw	r2,60(r2)
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 824359c:	18802c26 	beq	r3,r2,8243650 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82435a0:	e0bffe17 	ldw	r2,-8(fp)
 82435a4:	10c00417 	ldw	r3,16(r2)
 82435a8:	e0bfff17 	ldw	r2,-4(fp)
 82435ac:	10800617 	ldw	r2,24(r2)
 82435b0:	10801017 	ldw	r2,64(r2)
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 82435b4:	18802626 	beq	r3,r2,8243650 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
 82435b8:	e0bfff17 	ldw	r2,-4(fp)
 82435bc:	10800617 	ldw	r2,24(r2)
 82435c0:	10c00a17 	ldw	r3,40(r2)
 82435c4:	e0bfff17 	ldw	r2,-4(fp)
 82435c8:	10800617 	ldw	r2,24(r2)
 82435cc:	10801017 	ldw	r2,64(r2)
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82435d0:	18801f26 	beq	r3,r2,8243650 <ip_demux+0x388>
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 82435d4:	d0a08317 	ldw	r2,-32244(gp)
 82435d8:	1081000c 	andi	r2,r2,1024
 82435dc:	10000f26 	beq	r2,zero,824361c <ip_demux+0x354>
 82435e0:	d0a08317 	ldw	r2,-32244(gp)
 82435e4:	1080800c 	andi	r2,r2,512
 82435e8:	10000c26 	beq	r2,zero,824361c <ip_demux+0x354>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 82435ec:	e0bffe17 	ldw	r2,-8(fp)
 82435f0:	10800243 	ldbu	r2,9(r2)
 82435f4:	10803fcc 	andi	r2,r2,255
 82435f8:	100b883a 	mov	r5,r2
 82435fc:	01020974 	movhi	r4,2085
 8243600:	21048904 	addi	r4,r4,4644
 8243604:	82030ec0 	call	82030ec <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 8243608:	d0a08317 	ldw	r2,-32244(gp)
 824360c:	1080008c 	andi	r2,r2,2
 8243610:	10000226 	beq	r2,zero,824361c <ip_demux+0x354>
 8243614:	e13fff17 	ldw	r4,-4(fp)
 8243618:	824078c0 	call	824078c <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 824361c:	e0bffe17 	ldw	r2,-8(fp)
 8243620:	10c00317 	ldw	r3,12(r2)
 8243624:	e0bfff17 	ldw	r2,-4(fp)
 8243628:	10800617 	ldw	r2,24(r2)
 824362c:	11000a17 	ldw	r4,40(r2)
 8243630:	e0bfff17 	ldw	r2,-4(fp)
 8243634:	10800617 	ldw	r2,24(r2)
 8243638:	d8800015 	stw	r2,0(sp)
 824363c:	01c00084 	movi	r7,2
 8243640:	e1bffe17 	ldw	r6,-8(fp)
 8243644:	200b883a 	mov	r5,r4
 8243648:	1809883a 	mov	r4,r3
 824364c:	824ad100 	call	824ad10 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 8243650:	008209b4 	movhi	r2,2086
 8243654:	10b98004 	addi	r2,r2,-6656
 8243658:	10800617 	ldw	r2,24(r2)
 824365c:	10c00044 	addi	r3,r2,1
 8243660:	008209b4 	movhi	r2,2086
 8243664:	10b98004 	addi	r2,r2,-6656
 8243668:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824366c:	01000084 	movi	r4,2
 8243670:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 8243674:	e13fff17 	ldw	r4,-4(fp)
 8243678:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824367c:	01000084 	movi	r4,2
 8243680:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 8243684:	00800084 	movi	r2,2
}
 8243688:	e037883a 	mov	sp,fp
 824368c:	dfc00117 	ldw	ra,4(sp)
 8243690:	df000017 	ldw	fp,0(sp)
 8243694:	dec00204 	addi	sp,sp,8
 8243698:	f800283a 	ret

0824369c <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 824369c:	defff904 	addi	sp,sp,-28
 82436a0:	dfc00615 	stw	ra,24(sp)
 82436a4:	df000515 	stw	fp,20(sp)
 82436a8:	df000504 	addi	fp,sp,20
 82436ac:	e13ffd15 	stw	r4,-12(fp)
 82436b0:	e17ffe15 	stw	r5,-8(fp)
 82436b4:	e1bfff15 	stw	r6,-4(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 82436b8:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 82436bc:	e0bffd17 	ldw	r2,-12(fp)
 82436c0:	10000326 	beq	r2,zero,82436d0 <in_addmulti+0x34>
 82436c4:	e0bffd17 	ldw	r2,-12(fp)
 82436c8:	10800017 	ldw	r2,0(r2)
 82436cc:	1000021e 	bne	r2,zero,82436d8 <in_addmulti+0x3c>
      return ((struct in_multi *)NULL);  
 82436d0:	0005883a 	mov	r2,zero
 82436d4:	00003f06 	br	82437d4 <in_addmulti+0x138>

   ENTER_CRIT_SECTION(netp);
 82436d8:	822d4b80 	call	822d4b8 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 82436dc:	e0bfff17 	ldw	r2,-4(fp)
 82436e0:	108001a0 	cmpeqi	r2,r2,6
 82436e4:	1000061e 	bne	r2,zero,8243700 <in_addmulti+0x64>
      inm = lookup_mcast(*ap, netp);
 82436e8:	e0bffd17 	ldw	r2,-12(fp)
 82436ec:	10800017 	ldw	r2,0(r2)
 82436f0:	e17ffe17 	ldw	r5,-8(fp)
 82436f4:	1009883a 	mov	r4,r2
 82436f8:	82438f40 	call	82438f4 <lookup_mcast>
 82436fc:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 8243700:	e0bffb17 	ldw	r2,-20(fp)
 8243704:	10000626 	beq	r2,zero,8243720 <in_addmulti+0x84>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 8243708:	e0bffb17 	ldw	r2,-20(fp)
 824370c:	10800217 	ldw	r2,8(r2)
 8243710:	10c00044 	addi	r3,r2,1
 8243714:	e0bffb17 	ldw	r2,-20(fp)
 8243718:	10c00215 	stw	r3,8(r2)
 824371c:	00002b06 	br	82437cc <in_addmulti+0x130>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 8243720:	01000604 	movi	r4,24
 8243724:	822deb80 	call	822deb8 <npalloc>
 8243728:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 824372c:	e0bffb17 	ldw	r2,-20(fp)
 8243730:	1000031e 	bne	r2,zero,8243740 <in_addmulti+0xa4>
      {
         EXIT_CRIT_SECTION(netp);
 8243734:	822d5180 	call	822d518 <irq_Unmask>
         return ((struct in_multi *)NULL);
 8243738:	0005883a 	mov	r2,zero
 824373c:	00002506 	br	82437d4 <in_addmulti+0x138>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 8243740:	e0bfff17 	ldw	r2,-4(fp)
 8243744:	108001a0 	cmpeqi	r2,r2,6
 8243748:	1000041e 	bne	r2,zero,824375c <in_addmulti+0xc0>
         inm->inm_addr = *ap;
 824374c:	e0bffd17 	ldw	r2,-12(fp)
 8243750:	10c00017 	ldw	r3,0(r2)
 8243754:	e0bffb17 	ldw	r2,-20(fp)
 8243758:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 824375c:	e0bffb17 	ldw	r2,-20(fp)
 8243760:	e0fffe17 	ldw	r3,-8(fp)
 8243764:	10c00115 	stw	r3,4(r2)
      inm->inm_refcount = 1;
 8243768:	e0bffb17 	ldw	r2,-20(fp)
 824376c:	00c00044 	movi	r3,1
 8243770:	10c00215 	stw	r3,8(r2)
      inm->inm_next = netp->mc_list;
 8243774:	e0bffe17 	ldw	r2,-8(fp)
 8243778:	10c02c17 	ldw	r3,176(r2)
 824377c:	e0bffb17 	ldw	r2,-20(fp)
 8243780:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 8243784:	e0bffe17 	ldw	r2,-8(fp)
 8243788:	e0fffb17 	ldw	r3,-20(fp)
 824378c:	10c02c15 	stw	r3,176(r2)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 8243790:	e0bffe17 	ldw	r2,-8(fp)
 8243794:	10802b17 	ldw	r2,172(r2)
 8243798:	10000626 	beq	r2,zero,82437b4 <in_addmulti+0x118>
         error = netp->n_mcastlist(inm);
 824379c:	e0bffe17 	ldw	r2,-8(fp)
 82437a0:	10802b17 	ldw	r2,172(r2)
 82437a4:	e13ffb17 	ldw	r4,-20(fp)
 82437a8:	103ee83a 	callr	r2
 82437ac:	e0bffc15 	stw	r2,-16(fp)
 82437b0:	00000106 	br	82437b8 <in_addmulti+0x11c>
      else
         error = 0;
 82437b4:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 82437b8:	e0bffb17 	ldw	r2,-20(fp)
 82437bc:	10800017 	ldw	r2,0(r2)
 82437c0:	10000226 	beq	r2,zero,82437cc <in_addmulti+0x130>
 82437c4:	e13ffb17 	ldw	r4,-20(fp)
 82437c8:	8226fcc0 	call	8226fcc <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 82437cc:	822d5180 	call	822d518 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 82437d0:	e0bffb17 	ldw	r2,-20(fp)
}
 82437d4:	e037883a 	mov	sp,fp
 82437d8:	dfc00117 	ldw	ra,4(sp)
 82437dc:	df000017 	ldw	fp,0(sp)
 82437e0:	dec00204 	addi	sp,sp,8
 82437e4:	f800283a 	ret

082437e8 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 82437e8:	defffa04 	addi	sp,sp,-24
 82437ec:	dfc00515 	stw	ra,20(sp)
 82437f0:	df000415 	stw	fp,16(sp)
 82437f4:	df000404 	addi	fp,sp,16
 82437f8:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 82437fc:	e0bfff17 	ldw	r2,-4(fp)
 8243800:	10800117 	ldw	r2,4(r2)
 8243804:	e0bffe15 	stw	r2,-8(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 8243808:	822d4b80 	call	822d4b8 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 824380c:	e0bfff17 	ldw	r2,-4(fp)
 8243810:	10800217 	ldw	r2,8(r2)
 8243814:	10ffffc4 	addi	r3,r2,-1
 8243818:	e0bfff17 	ldw	r2,-4(fp)
 824381c:	10c00215 	stw	r3,8(r2)
 8243820:	e0bfff17 	ldw	r2,-4(fp)
 8243824:	10800217 	ldw	r2,8(r2)
 8243828:	10002b1e 	bne	r2,zero,82438d8 <in_delmulti+0xf0>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 824382c:	e0bffe17 	ldw	r2,-8(fp)
 8243830:	10802c17 	ldw	r2,176(r2)
 8243834:	e0bffc15 	stw	r2,-16(fp)
 8243838:	00001406 	br	824388c <in_delmulti+0xa4>
      {
         if(p == inm)   /* inm is first in mc_list */
 824383c:	e0fffc17 	ldw	r3,-16(fp)
 8243840:	e0bfff17 	ldw	r2,-4(fp)
 8243844:	1880051e 	bne	r3,r2,824385c <in_delmulti+0x74>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 8243848:	e0bffc17 	ldw	r2,-16(fp)
 824384c:	10c00517 	ldw	r3,20(r2)
 8243850:	e0bffe17 	ldw	r2,-8(fp)
 8243854:	10c02c15 	stw	r3,176(r2)
            break;
 8243858:	00000e06 	br	8243894 <in_delmulti+0xac>
         }
         else if(p->inm_next == inm)   /* inm is next */
 824385c:	e0bffc17 	ldw	r2,-16(fp)
 8243860:	10c00517 	ldw	r3,20(r2)
 8243864:	e0bfff17 	ldw	r2,-4(fp)
 8243868:	1880051e 	bne	r3,r2,8243880 <in_delmulti+0x98>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 824386c:	e0bfff17 	ldw	r2,-4(fp)
 8243870:	10c00517 	ldw	r3,20(r2)
 8243874:	e0bffc17 	ldw	r2,-16(fp)
 8243878:	10c00515 	stw	r3,20(r2)
            break;
 824387c:	00000506 	br	8243894 <in_delmulti+0xac>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243880:	e0bffc17 	ldw	r2,-16(fp)
 8243884:	10800517 	ldw	r2,20(r2)
 8243888:	e0bffc15 	stw	r2,-16(fp)
 824388c:	e0bffc17 	ldw	r2,-16(fp)
 8243890:	103fea1e 	bne	r2,zero,824383c <in_delmulti+0x54>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 8243894:	e0bffe17 	ldw	r2,-8(fp)
 8243898:	10802b17 	ldw	r2,172(r2)
 824389c:	10000626 	beq	r2,zero,82438b8 <in_delmulti+0xd0>
         error = netp->n_mcastlist(inm);
 82438a0:	e0bffe17 	ldw	r2,-8(fp)
 82438a4:	10802b17 	ldw	r2,172(r2)
 82438a8:	e13fff17 	ldw	r4,-4(fp)
 82438ac:	103ee83a 	callr	r2
 82438b0:	e0bffd15 	stw	r2,-12(fp)
 82438b4:	00000106 	br	82438bc <in_delmulti+0xd4>
      else
         error = 0;
 82438b8:	e03ffd15 	stw	zero,-12(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 82438bc:	e0bfff17 	ldw	r2,-4(fp)
 82438c0:	10800017 	ldw	r2,0(r2)
 82438c4:	10000226 	beq	r2,zero,82438d0 <in_delmulti+0xe8>
 82438c8:	e13fff17 	ldw	r4,-4(fp)
 82438cc:	82272200 	call	8227220 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 82438d0:	e13fff17 	ldw	r4,-4(fp)
 82438d4:	822deec0 	call	822deec <npfree>
   }

   EXIT_CRIT_SECTION(inm);
 82438d8:	822d5180 	call	822d518 <irq_Unmask>
   USE_ARG(error);
}
 82438dc:	0001883a 	nop
 82438e0:	e037883a 	mov	sp,fp
 82438e4:	dfc00117 	ldw	ra,4(sp)
 82438e8:	df000017 	ldw	fp,0(sp)
 82438ec:	dec00204 	addi	sp,sp,8
 82438f0:	f800283a 	ret

082438f4 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 82438f4:	defffc04 	addi	sp,sp,-16
 82438f8:	df000315 	stw	fp,12(sp)
 82438fc:	df000304 	addi	fp,sp,12
 8243900:	e13ffe15 	stw	r4,-8(fp)
 8243904:	e17fff15 	stw	r5,-4(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243908:	e0bfff17 	ldw	r2,-4(fp)
 824390c:	10802c17 	ldw	r2,176(r2)
 8243910:	e0bffd15 	stw	r2,-12(fp)
 8243914:	00000906 	br	824393c <lookup_mcast+0x48>
   {
      if(imp->inm_addr == addr)
 8243918:	e0bffd17 	ldw	r2,-12(fp)
 824391c:	10c00017 	ldw	r3,0(r2)
 8243920:	e0bffe17 	ldw	r2,-8(fp)
 8243924:	1880021e 	bne	r3,r2,8243930 <lookup_mcast+0x3c>
         return imp;
 8243928:	e0bffd17 	ldw	r2,-12(fp)
 824392c:	00000606 	br	8243948 <lookup_mcast+0x54>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243930:	e0bffd17 	ldw	r2,-12(fp)
 8243934:	10800517 	ldw	r2,20(r2)
 8243938:	e0bffd15 	stw	r2,-12(fp)
 824393c:	e0bffd17 	ldw	r2,-12(fp)
 8243940:	103ff51e 	bne	r2,zero,8243918 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 8243944:	0005883a 	mov	r2,zero
}
 8243948:	e037883a 	mov	sp,fp
 824394c:	df000017 	ldw	fp,0(sp)
 8243950:	dec00104 	addi	sp,sp,4
 8243954:	f800283a 	ret

08243958 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 8243958:	defffd04 	addi	sp,sp,-12
 824395c:	dfc00215 	stw	ra,8(sp)
 8243960:	df000115 	stw	fp,4(sp)
 8243964:	df000104 	addi	fp,sp,4
 8243968:	e13fff15 	stw	r4,-4(fp)
   if (port_prep)
 824396c:	d0a0ca17 	ldw	r2,-31960(gp)
 8243970:	10000426 	beq	r2,zero,8243984 <prep_ifaces+0x2c>
      ifaces_found = port_prep(ifaces_found);
 8243974:	d0a0ca17 	ldw	r2,-31960(gp)
 8243978:	e13fff17 	ldw	r4,-4(fp)
 824397c:	103ee83a 	callr	r2
 8243980:	e0bfff15 	stw	r2,-4(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 8243984:	e0bfff17 	ldw	r2,-4(fp)
 8243988:	d0a08415 	stw	r2,-32240(gp)

   initmsg("prepped %u interface%s, initializing...\n", 
 824398c:	e0bfff17 	ldw	r2,-4(fp)
 8243990:	10800058 	cmpnei	r2,r2,1
 8243994:	1000031e 	bne	r2,zero,82439a4 <prep_ifaces+0x4c>
 8243998:	00820974 	movhi	r2,2085
 824399c:	10849104 	addi	r2,r2,4676
 82439a0:	00000206 	br	82439ac <prep_ifaces+0x54>
 82439a4:	00820974 	movhi	r2,2085
 82439a8:	10849204 	addi	r2,r2,4680
 82439ac:	100d883a 	mov	r6,r2
 82439b0:	e17fff17 	ldw	r5,-4(fp)
 82439b4:	01020974 	movhi	r4,2085
 82439b8:	21049304 	addi	r4,r4,4684
 82439bc:	82030ec0 	call	82030ec <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 82439c0:	e0bfff17 	ldw	r2,-4(fp)
}
 82439c4:	e037883a 	mov	sp,fp
 82439c8:	dfc00117 	ldw	ra,4(sp)
 82439cc:	df000017 	ldw	fp,0(sp)
 82439d0:	dec00204 	addi	sp,sp,8
 82439d4:	f800283a 	ret

082439d8 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 82439d8:	defffd04 	addi	sp,sp,-12
 82439dc:	dfc00215 	stw	ra,8(sp)
 82439e0:	df000115 	stw	fp,4(sp)
 82439e4:	df000104 	addi	fp,sp,4
 82439e8:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 82439ec:	00800044 	movi	r2,1
 82439f0:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 82439f4:	82268e40 	call	82268e4 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 82439f8:	e13fff17 	ldw	r4,-4(fp)
 82439fc:	824b3a40 	call	824b3a4 <exit>

08243a00 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 8243a00:	deffff04 	addi	sp,sp,-4
 8243a04:	df000015 	stw	fp,0(sp)
 8243a08:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 8243a0c:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 8243a10:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 8243a14:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 8243a18:	0001883a 	nop
 8243a1c:	e037883a 	mov	sp,fp
 8243a20:	df000017 	ldw	fp,0(sp)
 8243a24:	dec00104 	addi	sp,sp,4
 8243a28:	f800283a 	ret

08243a2c <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 8243a2c:	defff904 	addi	sp,sp,-28
 8243a30:	dfc00615 	stw	ra,24(sp)
 8243a34:	df000515 	stw	fp,20(sp)
 8243a38:	df000504 	addi	fp,sp,20
 8243a3c:	2005883a 	mov	r2,r4
 8243a40:	e17ffd15 	stw	r5,-12(fp)
 8243a44:	e1bffe15 	stw	r6,-8(fp)
 8243a48:	e1ffff15 	stw	r7,-4(fp)
 8243a4c:	e0bffc05 	stb	r2,-16(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243a50:	0009883a 	mov	r4,zero
 8243a54:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 8243a58:	01000604 	movi	r4,24
 8243a5c:	822deb80 	call	822deb8 <npalloc>
 8243a60:	e0bffb15 	stw	r2,-20(fp)
   if (ep == NULL)
 8243a64:	e0bffb17 	ldw	r2,-20(fp)
 8243a68:	10000a1e 	bne	r2,zero,8243a94 <ip_raw_open+0x68>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 8243a6c:	d0a08317 	ldw	r2,-32244(gp)
 8243a70:	1080010c 	andi	r2,r2,4
 8243a74:	10000326 	beq	r2,zero,8243a84 <ip_raw_open+0x58>
         dprintf("IP: Couldn't allocate ep storage.\n");
 8243a78:	01020974 	movhi	r4,2085
 8243a7c:	21049e04 	addi	r4,r4,4728
 8243a80:	82033700 	call	8203370 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243a84:	0009883a 	mov	r4,zero
 8243a88:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ep;
 8243a8c:	e0bffb17 	ldw	r2,-20(fp)
 8243a90:	00001706 	br	8243af0 <ip_raw_open+0xc4>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 8243a94:	e0bffb17 	ldw	r2,-20(fp)
 8243a98:	e0fffd17 	ldw	r3,-12(fp)
 8243a9c:	10c00115 	stw	r3,4(r2)
   ep->ipr_faddr = faddr;
 8243aa0:	e0bffb17 	ldw	r2,-20(fp)
 8243aa4:	e0fffe17 	ldw	r3,-8(fp)
 8243aa8:	10c00215 	stw	r3,8(r2)
   ep->ipr_prot = prot;
 8243aac:	e0bffb17 	ldw	r2,-20(fp)
 8243ab0:	e0fffc03 	ldbu	r3,-16(fp)
 8243ab4:	10c00505 	stb	r3,20(r2)
   ep->ipr_rcv = handler;
 8243ab8:	e0bffb17 	ldw	r2,-20(fp)
 8243abc:	e0ffff17 	ldw	r3,-4(fp)
 8243ac0:	10c00315 	stw	r3,12(r2)
   ep->ipr_data = data;
 8243ac4:	e0bffb17 	ldw	r2,-20(fp)
 8243ac8:	e0c00217 	ldw	r3,8(fp)
 8243acc:	10c00415 	stw	r3,16(r2)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 8243ad0:	d0e0cf17 	ldw	r3,-31940(gp)
 8243ad4:	e0bffb17 	ldw	r2,-20(fp)
 8243ad8:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 8243adc:	e0bffb17 	ldw	r2,-20(fp)
 8243ae0:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243ae4:	0009883a 	mov	r4,zero
 8243ae8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return ep;
 8243aec:	e0bffb17 	ldw	r2,-20(fp)
}
 8243af0:	e037883a 	mov	sp,fp
 8243af4:	dfc00117 	ldw	ra,4(sp)
 8243af8:	df000017 	ldw	fp,0(sp)
 8243afc:	dec00204 	addi	sp,sp,8
 8243b00:	f800283a 	ret

08243b04 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 8243b04:	defffb04 	addi	sp,sp,-20
 8243b08:	dfc00415 	stw	ra,16(sp)
 8243b0c:	df000315 	stw	fp,12(sp)
 8243b10:	df000304 	addi	fp,sp,12
 8243b14:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243b18:	0009883a 	mov	r4,zero
 8243b1c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243b20:	e03ffd15 	stw	zero,-12(fp)
 8243b24:	d0a0cf17 	ldw	r2,-31940(gp)
 8243b28:	e0bffe15 	stw	r2,-8(fp)
 8243b2c:	00000806 	br	8243b50 <ip_raw_close+0x4c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 8243b30:	e0fffe17 	ldw	r3,-8(fp)
 8243b34:	e0bfff17 	ldw	r2,-4(fp)
 8243b38:	18800826 	beq	r3,r2,8243b5c <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 8243b3c:	e0bffe17 	ldw	r2,-8(fp)
 8243b40:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 8243b44:	e0bffe17 	ldw	r2,-8(fp)
 8243b48:	10800017 	ldw	r2,0(r2)
 8243b4c:	e0bffe15 	stw	r2,-8(fp)
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243b50:	e0bffe17 	ldw	r2,-8(fp)
 8243b54:	103ff61e 	bne	r2,zero,8243b30 <ip_raw_close+0x2c>
 8243b58:	00000106 	br	8243b60 <ip_raw_close+0x5c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
         break;
 8243b5c:	0001883a 	nop
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 8243b60:	e0bffe17 	ldw	r2,-8(fp)
 8243b64:	1000041e 	bne	r2,zero,8243b78 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 8243b68:	822d2e00 	call	822d2e0 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243b6c:	0009883a 	mov	r4,zero
 8243b70:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return;
 8243b74:	00000d06 	br	8243bac <ip_raw_close+0xa8>
   }

   /* unlink it from the list */
   if (prev_ep)
 8243b78:	e0bffd17 	ldw	r2,-12(fp)
 8243b7c:	10000426 	beq	r2,zero,8243b90 <ip_raw_close+0x8c>
      prev_ep = curr_ep->ipr_next;
 8243b80:	e0bffe17 	ldw	r2,-8(fp)
 8243b84:	10800017 	ldw	r2,0(r2)
 8243b88:	e0bffd15 	stw	r2,-12(fp)
 8243b8c:	00000306 	br	8243b9c <ip_raw_close+0x98>
   else
      ipraw_eps = curr_ep->ipr_next;
 8243b90:	e0bffe17 	ldw	r2,-8(fp)
 8243b94:	10800017 	ldw	r2,0(r2)
 8243b98:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 8243b9c:	e13ffe17 	ldw	r4,-8(fp)
 8243ba0:	822deec0 	call	822deec <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243ba4:	0009883a 	mov	r4,zero
 8243ba8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
}
 8243bac:	e037883a 	mov	sp,fp
 8243bb0:	dfc00117 	ldw	ra,4(sp)
 8243bb4:	df000017 	ldw	fp,0(sp)
 8243bb8:	dec00204 	addi	sp,sp,8
 8243bbc:	f800283a 	ret

08243bc0 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 8243bc0:	defff604 	addi	sp,sp,-40
 8243bc4:	dfc00915 	stw	ra,36(sp)
 8243bc8:	df000815 	stw	fp,32(sp)
 8243bcc:	df000804 	addi	fp,sp,32
 8243bd0:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 8243bd4:	e03ff915 	stw	zero,-28(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 8243bd8:	e03ffb15 	stw	zero,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 8243bdc:	e0bfff17 	ldw	r2,-4(fp)
 8243be0:	10800317 	ldw	r2,12(r2)
 8243be4:	e0bffc15 	stw	r2,-16(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243be8:	d0a0cf17 	ldw	r2,-31940(gp)
 8243bec:	e0bff815 	stw	r2,-32(fp)
 8243bf0:	00004c06 	br	8243d24 <ip_raw_input+0x164>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 8243bf4:	e0bff817 	ldw	r2,-32(fp)
 8243bf8:	10800017 	ldw	r2,0(r2)
 8243bfc:	e0bffd15 	stw	r2,-12(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 8243c00:	e0bff817 	ldw	r2,-32(fp)
 8243c04:	10800503 	ldbu	r2,20(r2)
 8243c08:	10803fcc 	andi	r2,r2,255
 8243c0c:	10000726 	beq	r2,zero,8243c2c <ip_raw_input+0x6c>
 8243c10:	e0bff817 	ldw	r2,-32(fp)
 8243c14:	10c00503 	ldbu	r3,20(r2)
 8243c18:	e0bffc17 	ldw	r2,-16(fp)
 8243c1c:	10800243 	ldbu	r2,9(r2)
 8243c20:	18c03fcc 	andi	r3,r3,255
 8243c24:	10803fcc 	andi	r2,r2,255
 8243c28:	1880371e 	bne	r3,r2,8243d08 <ip_raw_input+0x148>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 8243c2c:	e0bff817 	ldw	r2,-32(fp)
 8243c30:	10800117 	ldw	r2,4(r2)
 8243c34:	10000526 	beq	r2,zero,8243c4c <ip_raw_input+0x8c>
 8243c38:	e0bff817 	ldw	r2,-32(fp)
 8243c3c:	10c00117 	ldw	r3,4(r2)
 8243c40:	e0bffc17 	ldw	r2,-16(fp)
 8243c44:	10800417 	ldw	r2,16(r2)
 8243c48:	1880311e 	bne	r3,r2,8243d10 <ip_raw_input+0x150>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 8243c4c:	e0bff817 	ldw	r2,-32(fp)
 8243c50:	10800217 	ldw	r2,8(r2)
 8243c54:	10000526 	beq	r2,zero,8243c6c <ip_raw_input+0xac>
 8243c58:	e0bff817 	ldw	r2,-32(fp)
 8243c5c:	10c00217 	ldw	r3,8(r2)
 8243c60:	e0bffc17 	ldw	r2,-16(fp)
 8243c64:	10800317 	ldw	r2,12(r2)
 8243c68:	18802b1e 	bne	r3,r2,8243d18 <ip_raw_input+0x158>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 8243c6c:	e0bff817 	ldw	r2,-32(fp)
 8243c70:	10800317 	ldw	r2,12(r2)
 8243c74:	10002926 	beq	r2,zero,8243d1c <ip_raw_input+0x15c>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243c78:	e0bff917 	ldw	r2,-28(fp)
 8243c7c:	10001f26 	beq	r2,zero,8243cfc <ip_raw_input+0x13c>
 8243c80:	e0bff917 	ldw	r2,-28(fp)
 8243c84:	10800317 	ldw	r2,12(r2)
 8243c88:	10001c26 	beq	r2,zero,8243cfc <ip_raw_input+0x13c>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 8243c8c:	e13fff17 	ldw	r4,-4(fp)
 8243c90:	8240c0c0 	call	8240c0c <ip_copypkt>
 8243c94:	e0bffe15 	stw	r2,-8(fp)
            if (p2)
 8243c98:	e0bffe17 	ldw	r2,-8(fp)
 8243c9c:	10001726 	beq	r2,zero,8243cfc <ip_raw_input+0x13c>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 8243ca0:	0009883a 	mov	r4,zero
 8243ca4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 8243ca8:	e0bff917 	ldw	r2,-28(fp)
 8243cac:	10800317 	ldw	r2,12(r2)
 8243cb0:	e0fff917 	ldw	r3,-28(fp)
 8243cb4:	18c00417 	ldw	r3,16(r3)
 8243cb8:	180b883a 	mov	r5,r3
 8243cbc:	e13ffe17 	ldw	r4,-8(fp)
 8243cc0:	103ee83a 	callr	r2
 8243cc4:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 8243cc8:	0009883a 	mov	r4,zero
 8243ccc:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
               if (err)
 8243cd0:	e0bffa17 	ldw	r2,-24(fp)
 8243cd4:	10000726 	beq	r2,zero,8243cf4 <ip_raw_input+0x134>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 8243cd8:	01000084 	movi	r4,2
 8243cdc:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
                  pk_free(p2);
 8243ce0:	e13ffe17 	ldw	r4,-8(fp)
 8243ce4:	822ca880 	call	822ca88 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243ce8:	01000084 	movi	r4,2
 8243cec:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
 8243cf0:	00000206 	br	8243cfc <ip_raw_input+0x13c>
               }
               else
                  delivered = 1;
 8243cf4:	00800044 	movi	r2,1
 8243cf8:	e0bffb15 	stw	r2,-20(fp)
            }
         }
         matched_ep = ep;
 8243cfc:	e0bff817 	ldw	r2,-32(fp)
 8243d00:	e0bff915 	stw	r2,-28(fp)
 8243d04:	00000506 	br	8243d1c <ip_raw_input+0x15c>
      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
         continue;
 8243d08:	0001883a 	nop
 8243d0c:	00000306 	br	8243d1c <ip_raw_input+0x15c>
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
         continue;
 8243d10:	0001883a 	nop
 8243d14:	00000106 	br	8243d1c <ip_raw_input+0x15c>
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
         continue;
 8243d18:	0001883a 	nop

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243d1c:	e0bffd17 	ldw	r2,-12(fp)
 8243d20:	e0bff815 	stw	r2,-32(fp)
 8243d24:	e0bff817 	ldw	r2,-32(fp)
 8243d28:	103fb21e 	bne	r2,zero,8243bf4 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243d2c:	e0bff917 	ldw	r2,-28(fp)
 8243d30:	10001426 	beq	r2,zero,8243d84 <ip_raw_input+0x1c4>
 8243d34:	e0bff917 	ldw	r2,-28(fp)
 8243d38:	10800317 	ldw	r2,12(r2)
 8243d3c:	10001126 	beq	r2,zero,8243d84 <ip_raw_input+0x1c4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243d40:	0009883a 	mov	r4,zero
 8243d44:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 8243d48:	e0bff917 	ldw	r2,-28(fp)
 8243d4c:	10800317 	ldw	r2,12(r2)
 8243d50:	e0fff917 	ldw	r3,-28(fp)
 8243d54:	18c00417 	ldw	r3,16(r3)
 8243d58:	180b883a 	mov	r5,r3
 8243d5c:	e13fff17 	ldw	r4,-4(fp)
 8243d60:	103ee83a 	callr	r2
 8243d64:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 8243d68:	0009883a 	mov	r4,zero
 8243d6c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      if (err == 0)
 8243d70:	e0bffa17 	ldw	r2,-24(fp)
 8243d74:	10000c1e 	bne	r2,zero,8243da8 <ip_raw_input+0x1e8>
         delivered = 1;
 8243d78:	00800044 	movi	r2,1
 8243d7c:	e0bffb15 	stw	r2,-20(fp)
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
      LOCK_NET_RESOURCE(NET_RESID);
      if (err == 0)
 8243d80:	00000906 	br	8243da8 <ip_raw_input+0x1e8>
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 8243d84:	00bffd84 	movi	r2,-10
 8243d88:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 8243d8c:	008209b4 	movhi	r2,2086
 8243d90:	10b98004 	addi	r2,r2,-6656
 8243d94:	10800617 	ldw	r2,24(r2)
 8243d98:	10c00044 	addi	r3,r2,1
 8243d9c:	008209b4 	movhi	r2,2086
 8243da0:	10b98004 	addi	r2,r2,-6656
 8243da4:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 8243da8:	e0bffb17 	ldw	r2,-20(fp)
 8243dac:	1000071e 	bne	r2,zero,8243dcc <ip_raw_input+0x20c>
      ip_mib.ipInDelivers--;
 8243db0:	008209b4 	movhi	r2,2086
 8243db4:	10b98004 	addi	r2,r2,-6656
 8243db8:	10800817 	ldw	r2,32(r2)
 8243dbc:	10ffffc4 	addi	r3,r2,-1
 8243dc0:	008209b4 	movhi	r2,2086
 8243dc4:	10b98004 	addi	r2,r2,-6656
 8243dc8:	10c00815 	stw	r3,32(r2)

   return err;
 8243dcc:	e0bffa17 	ldw	r2,-24(fp)
}
 8243dd0:	e037883a 	mov	sp,fp
 8243dd4:	dfc00117 	ldw	ra,4(sp)
 8243dd8:	df000017 	ldw	fp,0(sp)
 8243ddc:	dec00204 	addi	sp,sp,8
 8243de0:	f800283a 	ret

08243de4 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 8243de4:	defffa04 	addi	sp,sp,-24
 8243de8:	dfc00515 	stw	ra,20(sp)
 8243dec:	df000415 	stw	fp,16(sp)
 8243df0:	df000404 	addi	fp,sp,16
 8243df4:	e13ffe15 	stw	r4,-8(fp)
 8243df8:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 8243dfc:	e0bffe17 	ldw	r2,-8(fp)
 8243e00:	10c00044 	addi	r3,r2,1
 8243e04:	00bfff84 	movi	r2,-2
 8243e08:	1884703a 	and	r2,r3,r2
 8243e0c:	e0bffc15 	stw	r2,-16(fp)
   if (!hdrincl)
 8243e10:	e0bfff17 	ldw	r2,-4(fp)
 8243e14:	1000031e 	bne	r2,zero,8243e24 <ip_raw_alloc+0x40>
      len += IPHSIZ;
 8243e18:	e0bffc17 	ldw	r2,-16(fp)
 8243e1c:	10800504 	addi	r2,r2,20
 8243e20:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243e24:	01000084 	movi	r4,2
 8243e28:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 8243e2c:	d0e08117 	ldw	r3,-32252(gp)
 8243e30:	e0bffc17 	ldw	r2,-16(fp)
 8243e34:	1885883a 	add	r2,r3,r2
 8243e38:	1009883a 	mov	r4,r2
 8243e3c:	822c7380 	call	822c738 <pk_alloc>
 8243e40:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243e44:	01000084 	movi	r4,2
 8243e48:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   if (p)
 8243e4c:	e0bffd17 	ldw	r2,-12(fp)
 8243e50:	10000c26 	beq	r2,zero,8243e84 <ip_raw_alloc+0xa0>
   {
      if (!hdrincl)
 8243e54:	e0bfff17 	ldw	r2,-4(fp)
 8243e58:	10000a1e 	bne	r2,zero,8243e84 <ip_raw_alloc+0xa0>
      {
         p->nb_prot += IPHSIZ;
 8243e5c:	e0bffd17 	ldw	r2,-12(fp)
 8243e60:	10800317 	ldw	r2,12(r2)
 8243e64:	10c00504 	addi	r3,r2,20
 8243e68:	e0bffd17 	ldw	r2,-12(fp)
 8243e6c:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 8243e70:	e0bffd17 	ldw	r2,-12(fp)
 8243e74:	10800417 	ldw	r2,16(r2)
 8243e78:	10fffb04 	addi	r3,r2,-20
 8243e7c:	e0bffd17 	ldw	r2,-12(fp)
 8243e80:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 8243e84:	e0bffd17 	ldw	r2,-12(fp)
}
 8243e88:	e037883a 	mov	sp,fp
 8243e8c:	dfc00117 	ldw	ra,4(sp)
 8243e90:	df000017 	ldw	fp,0(sp)
 8243e94:	dec00204 	addi	sp,sp,8
 8243e98:	f800283a 	ret

08243e9c <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 8243e9c:	defffd04 	addi	sp,sp,-12
 8243ea0:	dfc00215 	stw	ra,8(sp)
 8243ea4:	df000115 	stw	fp,4(sp)
 8243ea8:	df000104 	addi	fp,sp,4
 8243eac:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243eb0:	01000084 	movi	r4,2
 8243eb4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 8243eb8:	e13fff17 	ldw	r4,-4(fp)
 8243ebc:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243ec0:	01000084 	movi	r4,2
 8243ec4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
}
 8243ec8:	0001883a 	nop
 8243ecc:	e037883a 	mov	sp,fp
 8243ed0:	dfc00117 	ldw	ra,4(sp)
 8243ed4:	df000017 	ldw	fp,0(sp)
 8243ed8:	dec00204 	addi	sp,sp,8
 8243edc:	f800283a 	ret

08243ee0 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 8243ee0:	defffd04 	addi	sp,sp,-12
 8243ee4:	df000215 	stw	fp,8(sp)
 8243ee8:	df000204 	addi	fp,sp,8
 8243eec:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 8243ef0:	d0a03917 	ldw	r2,-32540(gp)
 8243ef4:	d0e08117 	ldw	r3,-32252(gp)
 8243ef8:	10c5c83a 	sub	r2,r2,r3
 8243efc:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 8243f00:	e0bfff17 	ldw	r2,-4(fp)
 8243f04:	1000031e 	bne	r2,zero,8243f14 <ip_raw_maxalloc+0x34>
      len -= IPHSIZ;
 8243f08:	e0bffe17 	ldw	r2,-8(fp)
 8243f0c:	10bffb04 	addi	r2,r2,-20
 8243f10:	e0bffe15 	stw	r2,-8(fp)
   return len;
 8243f14:	e0bffe17 	ldw	r2,-8(fp)
}
 8243f18:	e037883a 	mov	sp,fp
 8243f1c:	df000017 	ldw	fp,0(sp)
 8243f20:	dec00104 	addi	sp,sp,4
 8243f24:	f800283a 	ret

08243f28 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 8243f28:	defff804 	addi	sp,sp,-32
 8243f2c:	df000715 	stw	fp,28(sp)
 8243f30:	df000704 	addi	fp,sp,28
 8243f34:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 8243f38:	e03ffb05 	stb	zero,-20(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 8243f3c:	e03ffa15 	stw	zero,-24(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8243f40:	d0a0c617 	ldw	r2,-31976(gp)
 8243f44:	e0bff915 	stw	r2,-28(fp)
 8243f48:	00003a06 	br	8244034 <rt_lookup+0x10c>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 8243f4c:	e0bff917 	ldw	r2,-28(fp)
 8243f50:	10800617 	ldw	r2,24(r2)
 8243f54:	10003326 	beq	r2,zero,8244024 <rt_lookup+0xfc>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 8243f58:	e0bff917 	ldw	r2,-28(fp)
 8243f5c:	10800a17 	ldw	r2,40(r2)
 8243f60:	e0bffd15 	stw	r2,-12(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 8243f64:	e0bff917 	ldw	r2,-28(fp)
 8243f68:	10c00017 	ldw	r3,0(r2)
 8243f6c:	e0bfff17 	ldw	r2,-4(fp)
 8243f70:	1886f03a 	xor	r3,r3,r2
 8243f74:	e0bffd17 	ldw	r2,-12(fp)
 8243f78:	1884703a 	and	r2,r3,r2
 8243f7c:	10002a1e 	bne	r2,zero,8244028 <rt_lookup+0x100>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8243f80:	e03ffb45 	stb	zero,-19(fp)
 8243f84:	00a00034 	movhi	r2,32768
 8243f88:	e0bffc15 	stw	r2,-16(fp)
 8243f8c:	00001806 	br	8243ff0 <rt_lookup+0xc8>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 8243f90:	e0bffd17 	ldw	r2,-12(fp)
 8243f94:	1006d63a 	srli	r3,r2,24
 8243f98:	e0bffd17 	ldw	r2,-12(fp)
 8243f9c:	1004d23a 	srli	r2,r2,8
 8243fa0:	10bfc00c 	andi	r2,r2,65280
 8243fa4:	1886b03a 	or	r3,r3,r2
 8243fa8:	e0bffd17 	ldw	r2,-12(fp)
 8243fac:	10bfc00c 	andi	r2,r2,65280
 8243fb0:	1004923a 	slli	r2,r2,8
 8243fb4:	1886b03a 	or	r3,r3,r2
 8243fb8:	e0bffd17 	ldw	r2,-12(fp)
 8243fbc:	1004963a 	slli	r2,r2,24
 8243fc0:	1886b03a 	or	r3,r3,r2
 8243fc4:	e0bffc17 	ldw	r2,-16(fp)
 8243fc8:	1884703a 	and	r2,r3,r2
 8243fcc:	e0bffe15 	stw	r2,-8(fp)
            if (extracted_bit) ++curr_bits_matched;
 8243fd0:	e0bffe17 	ldw	r2,-8(fp)
 8243fd4:	10000326 	beq	r2,zero,8243fe4 <rt_lookup+0xbc>
 8243fd8:	e0bffb43 	ldbu	r2,-19(fp)
 8243fdc:	10800044 	addi	r2,r2,1
 8243fe0:	e0bffb45 	stb	r2,-19(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8243fe4:	e0bffc17 	ldw	r2,-16(fp)
 8243fe8:	1004d07a 	srli	r2,r2,1
 8243fec:	e0bffc15 	stw	r2,-16(fp)
 8243ff0:	e0bffc17 	ldw	r2,-16(fp)
 8243ff4:	103fe61e 	bne	r2,zero,8243f90 <rt_lookup+0x68>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 8243ff8:	e0bffb43 	ldbu	r2,-19(fp)
 8243ffc:	e0fffb03 	ldbu	r3,-20(fp)
 8244000:	1880092e 	bgeu	r3,r2,8244028 <rt_lookup+0x100>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 8244004:	e0bffb43 	ldbu	r2,-19(fp)
 8244008:	e0bffb05 	stb	r2,-20(fp)
            netmatch = rtp;
 824400c:	e0bff917 	ldw	r2,-28(fp)
 8244010:	e0bffa15 	stw	r2,-24(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 8244014:	e0bffb03 	ldbu	r2,-20(fp)
 8244018:	10800818 	cmpnei	r2,r2,32
 824401c:	10000c26 	beq	r2,zero,8244050 <rt_lookup+0x128>
 8244020:	00000106 	br	8244028 <rt_lookup+0x100>

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
         continue;
 8244024:	0001883a 	nop
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244028:	e0bff917 	ldw	r2,-28(fp)
 824402c:	10800f04 	addi	r2,r2,60
 8244030:	e0bff915 	stw	r2,-28(fp)
 8244034:	d0e0c617 	ldw	r3,-31976(gp)
 8244038:	d0a05117 	ldw	r2,-32444(gp)
 824403c:	10800f24 	muli	r2,r2,60
 8244040:	1885883a 	add	r2,r3,r2
 8244044:	e0fff917 	ldw	r3,-28(fp)
 8244048:	18bfc036 	bltu	r3,r2,8243f4c <rt_lookup+0x24>
 824404c:	00000106 	br	8244054 <rt_lookup+0x12c>
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
            netmatch = rtp;
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
               break;
 8244050:	0001883a 	nop
         }
      }
   }

   if (netmatch)
 8244054:	e0bffa17 	ldw	r2,-24(fp)
 8244058:	10000326 	beq	r2,zero,8244068 <rt_lookup+0x140>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 824405c:	d0e0a817 	ldw	r3,-32096(gp)
 8244060:	e0bffa17 	ldw	r2,-24(fp)
 8244064:	10c00915 	stw	r3,36(r2)

   return netmatch;
 8244068:	e0bffa17 	ldw	r2,-24(fp)
}
 824406c:	e037883a 	mov	sp,fp
 8244070:	df000017 	ldw	fp,0(sp)
 8244074:	dec00104 	addi	sp,sp,4
 8244078:	f800283a 	ret

0824407c <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 824407c:	defff704 	addi	sp,sp,-36
 8244080:	dfc00815 	stw	ra,32(sp)
 8244084:	df000715 	stw	fp,28(sp)
 8244088:	df000704 	addi	fp,sp,28
 824408c:	e13ffc15 	stw	r4,-16(fp)
 8244090:	e17ffd15 	stw	r5,-12(fp)
 8244094:	e1bffe15 	stw	r6,-8(fp)
 8244098:	e1ffff15 	stw	r7,-4(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 824409c:	e03ffa15 	stw	zero,-24(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 82440a0:	e13fff17 	ldw	r4,-4(fp)
 82440a4:	823ea940 	call	823ea94 <if_getbynum>
 82440a8:	e0bffb15 	stw	r2,-20(fp)
   if(!ifp)
 82440ac:	e0bffb17 	ldw	r2,-20(fp)
 82440b0:	1000021e 	bne	r2,zero,82440bc <add_route+0x40>
      return NULL;
 82440b4:	0005883a 	mov	r2,zero
 82440b8:	0000db06 	br	8244428 <add_route+0x3ac>

   if (rt_mib == NULL)
 82440bc:	d0a0c617 	ldw	r2,-31976(gp)
 82440c0:	1000021e 	bne	r2,zero,82440cc <add_route+0x50>
      return NULL;
 82440c4:	0005883a 	mov	r2,zero
 82440c8:	0000d706 	br	8244428 <add_route+0x3ac>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 82440cc:	e0bffc17 	ldw	r2,-16(fp)
 82440d0:	10000226 	beq	r2,zero,82440dc <add_route+0x60>
 82440d4:	e0bffd17 	ldw	r2,-12(fp)
 82440d8:	1000221e 	bne	r2,zero,8244164 <add_route+0xe8>
   {
      dtrap();    /* bad configuration? */
 82440dc:	822d2e00 	call	822d2e0 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
	      htonl(dest), htonl(mask) );
 82440e0:	e0bffc17 	ldw	r2,-16(fp)
 82440e4:	1006d63a 	srli	r3,r2,24
 82440e8:	e0bffc17 	ldw	r2,-16(fp)
 82440ec:	1004d23a 	srli	r2,r2,8
 82440f0:	10bfc00c 	andi	r2,r2,65280
 82440f4:	1886b03a 	or	r3,r3,r2
 82440f8:	e0bffc17 	ldw	r2,-16(fp)
 82440fc:	10bfc00c 	andi	r2,r2,65280
 8244100:	1004923a 	slli	r2,r2,8
 8244104:	1886b03a 	or	r3,r3,r2
 8244108:	e0bffc17 	ldw	r2,-16(fp)
 824410c:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244110:	1888b03a 	or	r4,r3,r2
	      htonl(dest), htonl(mask) );
 8244114:	e0bffd17 	ldw	r2,-12(fp)
 8244118:	1006d63a 	srli	r3,r2,24
 824411c:	e0bffd17 	ldw	r2,-12(fp)
 8244120:	1004d23a 	srli	r2,r2,8
 8244124:	10bfc00c 	andi	r2,r2,65280
 8244128:	1886b03a 	or	r3,r3,r2
 824412c:	e0bffd17 	ldw	r2,-12(fp)
 8244130:	10bfc00c 	andi	r2,r2,65280
 8244134:	1004923a 	slli	r2,r2,8
 8244138:	1886b03a 	or	r3,r3,r2
 824413c:	e0bffd17 	ldw	r2,-12(fp)
 8244140:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244144:	1884b03a 	or	r2,r3,r2
 8244148:	100d883a 	mov	r6,r2
 824414c:	200b883a 	mov	r5,r4
 8244150:	01020974 	movhi	r4,2085
 8244154:	2104a704 	addi	r4,r4,4764
 8244158:	82030ec0 	call	82030ec <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 824415c:	0005883a 	mov	r2,zero
 8244160:	0000b106 	br	8244428 <add_route+0x3ac>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244164:	d0a0c617 	ldw	r2,-31976(gp)
 8244168:	e0bff915 	stw	r2,-28(fp)
 824416c:	00006a06 	br	8244318 <add_route+0x29c>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 8244170:	e0bff917 	ldw	r2,-28(fp)
 8244174:	10c00017 	ldw	r3,0(r2)
 8244178:	e0bffc17 	ldw	r2,-16(fp)
 824417c:	1880151e 	bne	r3,r2,82441d4 <add_route+0x158>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 8244180:	e0bff917 	ldw	r2,-28(fp)
 8244184:	e0fffe17 	ldw	r3,-8(fp)
 8244188:	10c00615 	stw	r3,24(r2)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 824418c:	d0e0a817 	ldw	r3,-32096(gp)
 8244190:	e0bff917 	ldw	r2,-28(fp)
 8244194:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 8244198:	e0bfff17 	ldw	r2,-4(fp)
 824419c:	10c00044 	addi	r3,r2,1
 82441a0:	e0bff917 	ldw	r2,-28(fp)
 82441a4:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 82441a8:	e0bff917 	ldw	r2,-28(fp)
 82441ac:	e0c00217 	ldw	r3,8(fp)
 82441b0:	10c00815 	stw	r3,32(r2)
         rtp->ipRouteMask = mask;
 82441b4:	e0bff917 	ldw	r2,-28(fp)
 82441b8:	e0fffd17 	ldw	r3,-12(fp)
 82441bc:	10c00a15 	stw	r3,40(r2)
         rtp->ifp = ifp;
 82441c0:	e0bff917 	ldw	r2,-28(fp)
 82441c4:	e0fffb17 	ldw	r3,-20(fp)
 82441c8:	10c00e15 	stw	r3,56(r2)
         return(rtp);   /* just update and exit */
 82441cc:	e0bff917 	ldw	r2,-28(fp)
 82441d0:	00009506 	br	8244428 <add_route+0x3ac>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 82441d4:	e0bffa17 	ldw	r2,-24(fp)
 82441d8:	10000326 	beq	r2,zero,82441e8 <add_route+0x16c>
 82441dc:	e0bffa17 	ldw	r2,-24(fp)
 82441e0:	10800817 	ldw	r2,32(r2)
 82441e4:	10004926 	beq	r2,zero,824430c <add_route+0x290>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 82441e8:	e0bff917 	ldw	r2,-28(fp)
 82441ec:	10800617 	ldw	r2,24(r2)
 82441f0:	1000051e 	bne	r2,zero,8244208 <add_route+0x18c>
         {
            newrt = rtp;   /* record empty route for use */
 82441f4:	e0bff917 	ldw	r2,-28(fp)
 82441f8:	e0bffa15 	stw	r2,-24(fp)
            newrt->ipRouteProto = 0;
 82441fc:	e0bffa17 	ldw	r2,-24(fp)
 8244200:	10000815 	stw	zero,32(r2)
            continue;
 8244204:	00004106 	br	824430c <add_route+0x290>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 8244208:	00820974 	movhi	r2,2085
 824420c:	108e5804 	addi	r2,r2,14688
 8244210:	e0c00217 	ldw	r3,8(fp)
 8244214:	10c5883a 	add	r2,r2,r3
 8244218:	11000003 	ldbu	r4,0(r2)
 824421c:	e0bff917 	ldw	r2,-28(fp)
 8244220:	10c00817 	ldw	r3,32(r2)
 8244224:	00820974 	movhi	r2,2085
 8244228:	108e5804 	addi	r2,r2,14688
 824422c:	10c5883a 	add	r2,r2,r3
 8244230:	10800003 	ldbu	r2,0(r2)
 8244234:	20c03fcc 	andi	r3,r4,255
 8244238:	10803fcc 	andi	r2,r2,255
 824423c:	18803336 	bltu	r3,r2,824430c <add_route+0x290>
         {
            if (!newrt)
 8244240:	e0bffa17 	ldw	r2,-24(fp)
 8244244:	1000031e 	bne	r2,zero,8244254 <add_route+0x1d8>
            {
               newrt = rtp;
 8244248:	e0bff917 	ldw	r2,-28(fp)
 824424c:	e0bffa15 	stw	r2,-24(fp)
               continue;
 8244250:	00002e06 	br	824430c <add_route+0x290>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244254:	e0bff917 	ldw	r2,-28(fp)
 8244258:	10c00817 	ldw	r3,32(r2)
 824425c:	00820974 	movhi	r2,2085
 8244260:	108e5804 	addi	r2,r2,14688
 8244264:	10c5883a 	add	r2,r2,r3
 8244268:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 824426c:	e0bffa17 	ldw	r2,-24(fp)
 8244270:	10c00817 	ldw	r3,32(r2)
 8244274:	00820974 	movhi	r2,2085
 8244278:	108e5804 	addi	r2,r2,14688
 824427c:	10c5883a 	add	r2,r2,r3
 8244280:	10800003 	ldbu	r2,0(r2)
               newrt = rtp;
               continue;
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244284:	20c03fcc 	andi	r3,r4,255
 8244288:	10803fcc 	andi	r2,r2,255
 824428c:	1880032e 	bgeu	r3,r2,824429c <add_route+0x220>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 8244290:	e0bff917 	ldw	r2,-28(fp)
 8244294:	e0bffa15 	stw	r2,-24(fp)
 8244298:	00001c06 	br	824430c <add_route+0x290>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 824429c:	e0bff917 	ldw	r2,-28(fp)
 82442a0:	10c00817 	ldw	r3,32(r2)
 82442a4:	00820974 	movhi	r2,2085
 82442a8:	108e5804 	addi	r2,r2,14688
 82442ac:	10c5883a 	add	r2,r2,r3
 82442b0:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 82442b4:	e0bffa17 	ldw	r2,-24(fp)
 82442b8:	10c00817 	ldw	r3,32(r2)
 82442bc:	00820974 	movhi	r2,2085
 82442c0:	108e5804 	addi	r2,r2,14688
 82442c4:	10c5883a 	add	r2,r2,r3
 82442c8:	10800003 	ldbu	r2,0(r2)
            if (rtp_priority[rtp->ipRouteProto] < 
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82442cc:	20c03fcc 	andi	r3,r4,255
 82442d0:	10803fcc 	andi	r2,r2,255
 82442d4:	18800d1e 	bne	r3,r2,824430c <add_route+0x290>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 82442d8:	e0bff917 	ldw	r2,-28(fp)
 82442dc:	10c00917 	ldw	r3,36(r2)
 82442e0:	e0bffa17 	ldw	r2,-24(fp)
 82442e4:	10800917 	ldw	r2,36(r2)
 82442e8:	100b883a 	mov	r5,r2
 82442ec:	1809883a 	mov	r4,r3
 82442f0:	82263b40 	call	82263b4 <c_older>
 82442f4:	1007883a 	mov	r3,r2
 82442f8:	e0bff917 	ldw	r2,-28(fp)
 82442fc:	10800917 	ldw	r2,36(r2)
 8244300:	1880021e 	bne	r3,r2,824430c <add_route+0x290>
                  newrt = rtp;   /* got an older one */
 8244304:	e0bff917 	ldw	r2,-28(fp)
 8244308:	e0bffa15 	stw	r2,-24(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824430c:	e0bff917 	ldw	r2,-28(fp)
 8244310:	10800f04 	addi	r2,r2,60
 8244314:	e0bff915 	stw	r2,-28(fp)
 8244318:	d0e0c617 	ldw	r3,-31976(gp)
 824431c:	d0a05117 	ldw	r2,-32444(gp)
 8244320:	10800f24 	muli	r2,r2,60
 8244324:	1885883a 	add	r2,r3,r2
 8244328:	e0fff917 	ldw	r3,-28(fp)
 824432c:	18bf9036 	bltu	r3,r2,8244170 <add_route+0xf4>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 8244330:	e0bffa17 	ldw	r2,-24(fp)
 8244334:	10002926 	beq	r2,zero,82443dc <add_route+0x360>
      rtp = newrt;   /* create new entry in lowest priority slot */
 8244338:	e0bffa17 	ldw	r2,-24(fp)
 824433c:	e0bff915 	stw	r2,-28(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 8244340:	e0bff917 	ldw	r2,-28(fp)
 8244344:	e0fffb17 	ldw	r3,-20(fp)
 8244348:	10c00e15 	stw	r3,56(r2)
   rtp->ipRouteDest = dest;
 824434c:	e0bff917 	ldw	r2,-28(fp)
 8244350:	e0fffc17 	ldw	r3,-16(fp)
 8244354:	10c00015 	stw	r3,0(r2)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 8244358:	e13ffb17 	ldw	r4,-20(fp)
 824435c:	82269b40 	call	82269b4 <if_netnumber>
 8244360:	10c00044 	addi	r3,r2,1
 8244364:	e0bff917 	ldw	r2,-28(fp)
 8244368:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 824436c:	008209b4 	movhi	r2,2086
 8244370:	10b98004 	addi	r2,r2,-6656
 8244374:	10800117 	ldw	r2,4(r2)
 8244378:	1007883a 	mov	r3,r2
 824437c:	e0bff917 	ldw	r2,-28(fp)
 8244380:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 8244384:	e0bff917 	ldw	r2,-28(fp)
 8244388:	00ffffc4 	movi	r3,-1
 824438c:	10c00315 	stw	r3,12(r2)
   rtp->ipRouteMetric3 = -1;
 8244390:	e0bff917 	ldw	r2,-28(fp)
 8244394:	00ffffc4 	movi	r3,-1
 8244398:	10c00415 	stw	r3,16(r2)
   rtp->ipRouteMetric4 = -1;
 824439c:	e0bff917 	ldw	r2,-28(fp)
 82443a0:	00ffffc4 	movi	r3,-1
 82443a4:	10c00515 	stw	r3,20(r2)
   rtp->ipRouteNextHop = nexthop;
 82443a8:	e0bff917 	ldw	r2,-28(fp)
 82443ac:	e0fffe17 	ldw	r3,-8(fp)
 82443b0:	10c00615 	stw	r3,24(r2)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 82443b4:	e0bff917 	ldw	r2,-28(fp)
 82443b8:	e0c00217 	ldw	r3,8(fp)
 82443bc:	10c00815 	stw	r3,32(r2)

   if ((dest & mask) == (nexthop & mask))
 82443c0:	e0fffc17 	ldw	r3,-16(fp)
 82443c4:	e0bffe17 	ldw	r2,-8(fp)
 82443c8:	1886f03a 	xor	r3,r3,r2
 82443cc:	e0bffd17 	ldw	r2,-12(fp)
 82443d0:	1884703a 	and	r2,r3,r2
 82443d4:	1000071e 	bne	r2,zero,82443f4 <add_route+0x378>
 82443d8:	00000206 	br	82443e4 <add_route+0x368>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 82443dc:	0005883a 	mov	r2,zero
 82443e0:	00001106 	br	8244428 <add_route+0x3ac>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 82443e4:	e0bff917 	ldw	r2,-28(fp)
 82443e8:	00c000c4 	movi	r3,3
 82443ec:	10c00715 	stw	r3,28(r2)
 82443f0:	00000306 	br	8244400 <add_route+0x384>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 82443f4:	e0bff917 	ldw	r2,-28(fp)
 82443f8:	00c00104 	movi	r3,4
 82443fc:	10c00715 	stw	r3,28(r2)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 8244400:	d0e0a817 	ldw	r3,-32096(gp)
 8244404:	e0bff917 	ldw	r2,-28(fp)
 8244408:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 824440c:	e0bff917 	ldw	r2,-28(fp)
 8244410:	e0fffd17 	ldw	r3,-12(fp)
 8244414:	10c00a15 	stw	r3,40(r2)
   rtp->ipRouteMetric5 = -1;
 8244418:	e0bff917 	ldw	r2,-28(fp)
 824441c:	00ffffc4 	movi	r3,-1
 8244420:	10c00b15 	stw	r3,44(r2)
   return(rtp);
 8244424:	e0bff917 	ldw	r2,-28(fp)
}
 8244428:	e037883a 	mov	sp,fp
 824442c:	dfc00117 	ldw	ra,4(sp)
 8244430:	df000017 	ldw	fp,0(sp)
 8244434:	dec00204 	addi	sp,sp,8
 8244438:	f800283a 	ret

0824443c <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 824443c:	defff804 	addi	sp,sp,-32
 8244440:	dfc00715 	stw	ra,28(sp)
 8244444:	df000615 	stw	fp,24(sp)
 8244448:	df000604 	addi	fp,sp,24
 824444c:	e13ffd15 	stw	r4,-12(fp)
 8244450:	e17ffe15 	stw	r5,-8(fp)
 8244454:	e1bfff15 	stw	r6,-4(fp)
   RTMIB rtp;
   int   retval   =  0;
 8244458:	e03ffb15 	stw	zero,-20(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 824445c:	e0bfff17 	ldw	r2,-4(fp)
 8244460:	10bfffd8 	cmpnei	r2,r2,-1
 8244464:	1000021e 	bne	r2,zero,8244470 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 8244468:	e03ffc15 	stw	zero,-16(fp)
 824446c:	00000306 	br	824447c <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 8244470:	e13fff17 	ldw	r4,-4(fp)
 8244474:	823ea940 	call	823ea94 <if_getbynum>
 8244478:	e0bffc15 	stw	r2,-16(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 824447c:	d0a0c617 	ldw	r2,-31976(gp)
 8244480:	1000021e 	bne	r2,zero,824448c <del_route+0x50>
      return 0;
 8244484:	0005883a 	mov	r2,zero
 8244488:	00002c06 	br	824453c <del_route+0x100>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824448c:	d0a0c617 	ldw	r2,-31976(gp)
 8244490:	e0bffa15 	stw	r2,-24(fp)
 8244494:	00002206 	br	8244520 <del_route+0xe4>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 8244498:	e0bffa17 	ldw	r2,-24(fp)
 824449c:	10800617 	ldw	r2,24(r2)
 82444a0:	10001926 	beq	r2,zero,8244508 <del_route+0xcc>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 82444a4:	e0bffc17 	ldw	r2,-16(fp)
 82444a8:	10000426 	beq	r2,zero,82444bc <del_route+0x80>
 82444ac:	e0bffa17 	ldw	r2,-24(fp)
 82444b0:	10c00e17 	ldw	r3,56(r2)
 82444b4:	e0bffc17 	ldw	r2,-16(fp)
 82444b8:	1880151e 	bne	r3,r2,8244510 <del_route+0xd4>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 82444bc:	e0bffa17 	ldw	r2,-24(fp)
 82444c0:	10c00017 	ldw	r3,0(r2)
 82444c4:	e0bffd17 	ldw	r2,-12(fp)
 82444c8:	1886f03a 	xor	r3,r3,r2
 82444cc:	e0bffe17 	ldw	r2,-8(fp)
 82444d0:	1884703a 	and	r2,r3,r2
 82444d4:	1000071e 	bne	r2,zero,82444f4 <del_route+0xb8>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 82444d8:	01800f04 	movi	r6,60
 82444dc:	000b883a 	mov	r5,zero
 82444e0:	e13ffa17 	ldw	r4,-24(fp)
 82444e4:	8202f000 	call	8202f00 <memset>
         retval++;
 82444e8:	e0bffb17 	ldw	r2,-20(fp)
 82444ec:	10800044 	addi	r2,r2,1
 82444f0:	e0bffb15 	stw	r2,-20(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 82444f4:	d0e0d017 	ldw	r3,-31936(gp)
 82444f8:	e0bffa17 	ldw	r2,-24(fp)
 82444fc:	1880051e 	bne	r3,r2,8244514 <del_route+0xd8>
         cachedRoute = NULL;
 8244500:	d020d015 	stw	zero,-31936(gp)
 8244504:	00000306 	br	8244514 <del_route+0xd8>
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
         continue;
 8244508:	0001883a 	nop
 824450c:	00000106 	br	8244514 <del_route+0xd8>
      if(ifp != NULL && ifp != rtp->ifp)
         continue;   /* interface didn't match */
 8244510:	0001883a 	nop
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244514:	e0bffa17 	ldw	r2,-24(fp)
 8244518:	10800f04 	addi	r2,r2,60
 824451c:	e0bffa15 	stw	r2,-24(fp)
 8244520:	d0e0c617 	ldw	r3,-31976(gp)
 8244524:	d0a05117 	ldw	r2,-32444(gp)
 8244528:	10800f24 	muli	r2,r2,60
 824452c:	1885883a 	add	r2,r3,r2
 8244530:	e0fffa17 	ldw	r3,-24(fp)
 8244534:	18bfd836 	bltu	r3,r2,8244498 <del_route+0x5c>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 8244538:	e0bffb17 	ldw	r2,-20(fp)
}
 824453c:	e037883a 	mov	sp,fp
 8244540:	dfc00117 	ldw	ra,4(sp)
 8244544:	df000017 	ldw	fp,0(sp)
 8244548:	dec00204 	addi	sp,sp,8
 824454c:	f800283a 	ret

08244550 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 8244550:	deffec04 	addi	sp,sp,-80
 8244554:	dfc01315 	stw	ra,76(sp)
 8244558:	df001215 	stw	fp,72(sp)
 824455c:	df001204 	addi	fp,sp,72
 8244560:	e13fff15 	stw	r4,-4(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 8244564:	e0bfff17 	ldw	r2,-4(fp)
 8244568:	10800317 	ldw	r2,12(r2)
 824456c:	e0bff615 	stw	r2,-40(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 8244570:	e0bff617 	ldw	r2,-40(fp)
 8244574:	10800003 	ldbu	r2,0(r2)
 8244578:	10803fcc 	andi	r2,r2,255
 824457c:	108003cc 	andi	r2,r2,15
 8244580:	1085883a 	add	r2,r2,r2
 8244584:	1085883a 	add	r2,r2,r2
 8244588:	1007883a 	mov	r3,r2
 824458c:	e0bff617 	ldw	r2,-40(fp)
 8244590:	10c5883a 	add	r2,r2,r3
 8244594:	e0bff715 	stw	r2,-36(fp)
   plen = htons(pup->ud_len);
 8244598:	e0bff717 	ldw	r2,-36(fp)
 824459c:	1080010b 	ldhu	r2,4(r2)
 82445a0:	10bfffcc 	andi	r2,r2,65535
 82445a4:	1004d23a 	srli	r2,r2,8
 82445a8:	10bfffcc 	andi	r2,r2,65535
 82445ac:	10c03fcc 	andi	r3,r2,255
 82445b0:	e0bff717 	ldw	r2,-36(fp)
 82445b4:	1080010b 	ldhu	r2,4(r2)
 82445b8:	10bfffcc 	andi	r2,r2,65535
 82445bc:	1004923a 	slli	r2,r2,8
 82445c0:	10bfffcc 	andi	r2,r2,65535
 82445c4:	1884b03a 	or	r2,r3,r2
 82445c8:	e0bff815 	stw	r2,-32(fp)

   if (plen > p->nb_plen)
 82445cc:	e0bfff17 	ldw	r2,-4(fp)
 82445d0:	10c00417 	ldw	r3,16(r2)
 82445d4:	e0bff817 	ldw	r2,-32(fp)
 82445d8:	1880252e 	bgeu	r3,r2,8244670 <udpdemux+0x120>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 82445dc:	d0a08317 	ldw	r2,-32244(gp)
 82445e0:	1081000c 	andi	r2,r2,1024
 82445e4:	10001726 	beq	r2,zero,8244644 <udpdemux+0xf4>
 82445e8:	d0a08317 	ldw	r2,-32244(gp)
 82445ec:	1080400c 	andi	r2,r2,256
 82445f0:	10001426 	beq	r2,zero,8244644 <udpdemux+0xf4>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 82445f4:	e0bfff17 	ldw	r2,-4(fp)
 82445f8:	11000417 	ldw	r4,16(r2)
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 82445fc:	e0bff717 	ldw	r2,-36(fp)
 8244600:	1080010b 	ldhu	r2,4(r2)
 8244604:	10bfffcc 	andi	r2,r2,65535
 8244608:	1004d23a 	srli	r2,r2,8
 824460c:	10bfffcc 	andi	r2,r2,65535
 8244610:	10c03fcc 	andi	r3,r2,255
 8244614:	e0bff717 	ldw	r2,-36(fp)
 8244618:	1080010b 	ldhu	r2,4(r2)
 824461c:	10bfffcc 	andi	r2,r2,65535
 8244620:	1004923a 	slli	r2,r2,8
 8244624:	10bfffcc 	andi	r2,r2,65535
 8244628:	1884b03a 	or	r2,r3,r2
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 824462c:	10800204 	addi	r2,r2,8
 8244630:	100d883a 	mov	r6,r2
 8244634:	200b883a 	mov	r5,r4
 8244638:	01020974 	movhi	r4,2085
 824463c:	2104b504 	addi	r4,r4,4820
 8244640:	82030ec0 	call	82030ec <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 8244644:	008209b4 	movhi	r2,2086
 8244648:	10b99a04 	addi	r2,r2,-6552
 824464c:	10800217 	ldw	r2,8(r2)
 8244650:	10c00044 	addi	r3,r2,1
 8244654:	008209b4 	movhi	r2,2086
 8244658:	10b99a04 	addi	r2,r2,-6552
 824465c:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244660:	e13fff17 	ldw	r4,-4(fp)
 8244664:	82452140 	call	8245214 <udp_free>
      return ENP_BAD_HEADER;
 8244668:	00bff804 	movi	r2,-32
 824466c:	00019d06 	br	8244ce4 <udpdemux+0x794>
   }

   osum = pup->ud_cksum;
 8244670:	e0bff717 	ldw	r2,-36(fp)
 8244674:	1080018b 	ldhu	r2,6(r2)
 8244678:	e0bff90d 	sth	r2,-28(fp)
   /* did other guy use checksumming? */
   if (osum)
 824467c:	e0bff90b 	ldhu	r2,-28(fp)
 8244680:	10005826 	beq	r2,zero,82447e4 <udpdemux+0x294>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 8244684:	e0bff817 	ldw	r2,-32(fp)
 8244688:	1080004c 	andi	r2,r2,1
 824468c:	10000426 	beq	r2,zero,82446a0 <udpdemux+0x150>
 8244690:	e0fff717 	ldw	r3,-36(fp)
 8244694:	e0bff817 	ldw	r2,-32(fp)
 8244698:	1885883a 	add	r2,r3,r2
 824469c:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 82446a0:	e0bfff17 	ldw	r2,-4(fp)
 82446a4:	10800717 	ldw	r2,28(r2)
 82446a8:	e0bffc15 	stw	r2,-16(fp)
      php.ph_dest = pip->ip_dest;
 82446ac:	e0bff617 	ldw	r2,-40(fp)
 82446b0:	10800417 	ldw	r2,16(r2)
 82446b4:	e0bffd15 	stw	r2,-12(fp)
      php.ph_zero = 0;
 82446b8:	e03ffe05 	stb	zero,-8(fp)
      php.ph_prot = UDP_PROT;
 82446bc:	00800444 	movi	r2,17
 82446c0:	e0bffe45 	stb	r2,-7(fp)
      php.ph_len  = pup->ud_len;
 82446c4:	e0bff717 	ldw	r2,-36(fp)
 82446c8:	1080010b 	ldhu	r2,4(r2)
 82446cc:	e0bffe8d 	sth	r2,-6(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 82446d0:	e0bffc04 	addi	r2,fp,-16
 82446d4:	01400184 	movi	r5,6
 82446d8:	1009883a 	mov	r4,r2
 82446dc:	82285000 	call	8228500 <cksum>
 82446e0:	1007883a 	mov	r3,r2
 82446e4:	e0bff717 	ldw	r2,-36(fp)
 82446e8:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 82446ec:	e0bff817 	ldw	r2,-32(fp)
 82446f0:	10800044 	addi	r2,r2,1
 82446f4:	1004d07a 	srli	r2,r2,1
 82446f8:	100b883a 	mov	r5,r2
 82446fc:	e13ff717 	ldw	r4,-36(fp)
 8244700:	82285000 	call	8228500 <cksum>
 8244704:	0084303a 	nor	r2,zero,r2
 8244708:	e0bff30d 	sth	r2,-52(fp)
      if (!xsum)
 824470c:	e0bff30b 	ldhu	r2,-52(fp)
 8244710:	1000021e 	bne	r2,zero,824471c <udpdemux+0x1cc>
         xsum = 0xffff;
 8244714:	00bfffc4 	movi	r2,-1
 8244718:	e0bff30d 	sth	r2,-52(fp)
      pup->ud_cksum = osum;
 824471c:	e0bff717 	ldw	r2,-36(fp)
 8244720:	e0fff90b 	ldhu	r3,-28(fp)
 8244724:	10c0018d 	sth	r3,6(r2)
      if (xsum != osum)
 8244728:	e0fff30b 	ldhu	r3,-52(fp)
 824472c:	e0bff90b 	ldhu	r2,-28(fp)
 8244730:	18802c26 	beq	r3,r2,82447e4 <udpdemux+0x294>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244734:	d0a08317 	ldw	r2,-32244(gp)
 8244738:	1081000c 	andi	r2,r2,1024
 824473c:	10001e26 	beq	r2,zero,82447b8 <udpdemux+0x268>
 8244740:	d0a08317 	ldw	r2,-32244(gp)
 8244744:	1080400c 	andi	r2,r2,256
 8244748:	10001b26 	beq	r2,zero,82447b8 <udpdemux+0x268>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 824474c:	e17ff90b 	ldhu	r5,-28(fp)
 8244750:	e1bff30b 	ldhu	r6,-52(fp)
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244754:	e0bfff17 	ldw	r2,-4(fp)
 8244758:	10800717 	ldw	r2,28(r2)
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 824475c:	11c03fcc 	andi	r7,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244760:	e0bfff17 	ldw	r2,-4(fp)
 8244764:	10800717 	ldw	r2,28(r2)
 8244768:	1004d23a 	srli	r2,r2,8
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 824476c:	10803fcc 	andi	r2,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244770:	e0ffff17 	ldw	r3,-4(fp)
 8244774:	18c00717 	ldw	r3,28(r3)
 8244778:	1806d43a 	srli	r3,r3,16
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 824477c:	18c03fcc 	andi	r3,r3,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244780:	e13fff17 	ldw	r4,-4(fp)
 8244784:	21000717 	ldw	r4,28(r4)
 8244788:	2008d63a 	srli	r4,r4,24
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 824478c:	d9000215 	stw	r4,8(sp)
 8244790:	d8c00115 	stw	r3,4(sp)
 8244794:	d8800015 	stw	r2,0(sp)
 8244798:	01020974 	movhi	r4,2085
 824479c:	2104bf04 	addi	r4,r4,4860
 82447a0:	82030ec0 	call	82030ec <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 82447a4:	d0a08317 	ldw	r2,-32244(gp)
 82447a8:	1080008c 	andi	r2,r2,2
 82447ac:	10000226 	beq	r2,zero,82447b8 <udpdemux+0x268>
               ip_dump(p);
 82447b0:	e13fff17 	ldw	r4,-4(fp)
 82447b4:	824078c0 	call	824078c <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 82447b8:	008209b4 	movhi	r2,2086
 82447bc:	10b99a04 	addi	r2,r2,-6552
 82447c0:	10800217 	ldw	r2,8(r2)
 82447c4:	10c00044 	addi	r3,r2,1
 82447c8:	008209b4 	movhi	r2,2086
 82447cc:	10b99a04 	addi	r2,r2,-6552
 82447d0:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 82447d4:	e13fff17 	ldw	r4,-4(fp)
 82447d8:	82452140 	call	8245214 <udp_free>
         return ENP_BAD_HEADER;
 82447dc:	00bff804 	movi	r2,-32
 82447e0:	00014006 	br	8244ce4 <udpdemux+0x794>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 82447e4:	e13ff717 	ldw	r4,-36(fp)
 82447e8:	8244f900 	call	8244f90 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 82447ec:	e0bff617 	ldw	r2,-40(fp)
 82447f0:	10800003 	ldbu	r2,0(r2)
 82447f4:	10803fcc 	andi	r2,r2,255
 82447f8:	108003cc 	andi	r2,r2,15
 82447fc:	1085883a 	add	r2,r2,r2
 8244800:	1085883a 	add	r2,r2,r2
 8244804:	10800204 	addi	r2,r2,8
 8244808:	e0bff415 	stw	r2,-48(fp)
   p->nb_plen -= e;
 824480c:	e0bfff17 	ldw	r2,-4(fp)
 8244810:	10c00417 	ldw	r3,16(r2)
 8244814:	e0bff417 	ldw	r2,-48(fp)
 8244818:	1887c83a 	sub	r3,r3,r2
 824481c:	e0bfff17 	ldw	r2,-4(fp)
 8244820:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 8244824:	e0bfff17 	ldw	r2,-4(fp)
 8244828:	10c00317 	ldw	r3,12(r2)
 824482c:	e0bff417 	ldw	r2,-48(fp)
 8244830:	1887883a 	add	r3,r3,r2
 8244834:	e0bfff17 	ldw	r2,-4(fp)
 8244838:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 824483c:	d0a08317 	ldw	r2,-32244(gp)
 8244840:	1081000c 	andi	r2,r2,1024
 8244844:	10001f26 	beq	r2,zero,82448c4 <udpdemux+0x374>
 8244848:	d0a08317 	ldw	r2,-32244(gp)
 824484c:	1080400c 	andi	r2,r2,256
 8244850:	10001c26 	beq	r2,zero,82448c4 <udpdemux+0x374>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244854:	e0bfff17 	ldw	r2,-4(fp)
 8244858:	10800717 	ldw	r2,28(r2)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 824485c:	11803fcc 	andi	r6,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244860:	e0bfff17 	ldw	r2,-4(fp)
 8244864:	10800717 	ldw	r2,28(r2)
 8244868:	1004d23a 	srli	r2,r2,8
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 824486c:	11c03fcc 	andi	r7,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244870:	e0bfff17 	ldw	r2,-4(fp)
 8244874:	10800717 	ldw	r2,28(r2)
 8244878:	1004d43a 	srli	r2,r2,16
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 824487c:	10803fcc 	andi	r2,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244880:	e0ffff17 	ldw	r3,-4(fp)
 8244884:	18c00717 	ldw	r3,28(r3)
 8244888:	1806d63a 	srli	r3,r3,24
 824488c:	e13ff717 	ldw	r4,-36(fp)
 8244890:	2100000b 	ldhu	r4,0(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244894:	213fffcc 	andi	r4,r4,65535
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244898:	e17ff717 	ldw	r5,-36(fp)
 824489c:	2940008b 	ldhu	r5,2(r5)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 82448a0:	297fffcc 	andi	r5,r5,65535
 82448a4:	d9400315 	stw	r5,12(sp)
 82448a8:	d9000215 	stw	r4,8(sp)
 82448ac:	d8c00115 	stw	r3,4(sp)
 82448b0:	d8800015 	stw	r2,0(sp)
 82448b4:	e17ff817 	ldw	r5,-32(fp)
 82448b8:	01020974 	movhi	r4,2085
 82448bc:	2104cd04 	addi	r4,r4,4916
 82448c0:	82030ec0 	call	82030ec <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 82448c4:	d0a09c17 	ldw	r2,-32144(gp)
 82448c8:	e0bff215 	stw	r2,-56(fp)
 82448cc:	0000ae06 	br	8244b88 <udpdemux+0x638>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 82448d0:	e0bff217 	ldw	r2,-56(fp)
 82448d4:	1080018b 	ldhu	r2,6(r2)
 82448d8:	10bfffcc 	andi	r2,r2,65535
 82448dc:	10000726 	beq	r2,zero,82448fc <udpdemux+0x3ac>
 82448e0:	e0bff217 	ldw	r2,-56(fp)
 82448e4:	10c0018b 	ldhu	r3,6(r2)
 82448e8:	e0bff717 	ldw	r2,-36(fp)
 82448ec:	1080008b 	ldhu	r2,2(r2)
 82448f0:	18ffffcc 	andi	r3,r3,65535
 82448f4:	10bfffcc 	andi	r2,r2,65535
 82448f8:	1880991e 	bne	r3,r2,8244b60 <udpdemux+0x610>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 82448fc:	e0bff217 	ldw	r2,-56(fp)
 8244900:	1080020b 	ldhu	r2,8(r2)
 8244904:	10bfffcc 	andi	r2,r2,65535
 8244908:	10000726 	beq	r2,zero,8244928 <udpdemux+0x3d8>
 824490c:	e0bff217 	ldw	r2,-56(fp)
 8244910:	10c0020b 	ldhu	r3,8(r2)
 8244914:	e0bff717 	ldw	r2,-36(fp)
 8244918:	1080000b 	ldhu	r2,0(r2)
 824491c:	18ffffcc 	andi	r3,r3,65535
 8244920:	10bfffcc 	andi	r2,r2,65535
 8244924:	1880901e 	bne	r3,r2,8244b68 <udpdemux+0x618>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 8244928:	e0bff217 	ldw	r2,-56(fp)
 824492c:	10800417 	ldw	r2,16(r2)
 8244930:	10000526 	beq	r2,zero,8244948 <udpdemux+0x3f8>
 8244934:	e0bff217 	ldw	r2,-56(fp)
 8244938:	10c00417 	ldw	r3,16(r2)
 824493c:	e0bfff17 	ldw	r2,-4(fp)
 8244940:	10800717 	ldw	r2,28(r2)
 8244944:	18808a1e 	bne	r3,r2,8244b70 <udpdemux+0x620>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 8244948:	e0bff617 	ldw	r2,-40(fp)
 824494c:	10800417 	ldw	r2,16(r2)
 8244950:	1006d63a 	srli	r3,r2,24
 8244954:	e0bff617 	ldw	r2,-40(fp)
 8244958:	10800417 	ldw	r2,16(r2)
 824495c:	1004d23a 	srli	r2,r2,8
 8244960:	10bfc00c 	andi	r2,r2,65280
 8244964:	1886b03a 	or	r3,r3,r2
 8244968:	e0bff617 	ldw	r2,-40(fp)
 824496c:	10800417 	ldw	r2,16(r2)
 8244970:	10bfc00c 	andi	r2,r2,65280
 8244974:	1004923a 	slli	r2,r2,8
 8244978:	1886b03a 	or	r3,r3,r2
 824497c:	e0bff617 	ldw	r2,-40(fp)
 8244980:	10800417 	ldw	r2,16(r2)
 8244984:	1004963a 	slli	r2,r2,24
 8244988:	1884b03a 	or	r2,r3,r2
 824498c:	10fc002c 	andhi	r3,r2,61440
 8244990:	00b80034 	movhi	r2,57344
 8244994:	1880301e 	bne	r3,r2,8244a58 <udpdemux+0x508>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 8244998:	e0bff217 	ldw	r2,-56(fp)
 824499c:	10800617 	ldw	r2,24(r2)
 82449a0:	e0bffa15 	stw	r2,-24(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 82449a4:	e0bff217 	ldw	r2,-56(fp)
 82449a8:	10c00517 	ldw	r3,20(r2)
 82449ac:	00820934 	movhi	r2,2084
 82449b0:	10ab3204 	addi	r2,r2,-21304
 82449b4:	1880281e 	bne	r3,r2,8244a58 <udpdemux+0x508>
 82449b8:	e0bffa17 	ldw	r2,-24(fp)
 82449bc:	10800317 	ldw	r2,12(r2)
 82449c0:	10002526 	beq	r2,zero,8244a58 <udpdemux+0x508>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 82449c4:	e0bffa17 	ldw	r2,-24(fp)
 82449c8:	10800317 	ldw	r2,12(r2)
 82449cc:	e0bffb15 	stw	r2,-20(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 82449d0:	e03ff50d 	sth	zero,-44(fp)
 82449d4:	00001906 	br	8244a3c <udpdemux+0x4ec>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 82449d8:	e0bff50b 	ldhu	r2,-44(fp)
 82449dc:	e0fffb17 	ldw	r3,-20(fp)
 82449e0:	10800084 	addi	r2,r2,2
 82449e4:	1085883a 	add	r2,r2,r2
 82449e8:	1085883a 	add	r2,r2,r2
 82449ec:	1885883a 	add	r2,r3,r2
 82449f0:	10800017 	ldw	r2,0(r2)
 82449f4:	10c00117 	ldw	r3,4(r2)
 82449f8:	e0bfff17 	ldw	r2,-4(fp)
 82449fc:	10800617 	ldw	r2,24(r2)
 8244a00:	18800b1e 	bne	r3,r2,8244a30 <udpdemux+0x4e0>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
 8244a04:	e0bff50b 	ldhu	r2,-44(fp)
 8244a08:	e0fffb17 	ldw	r3,-20(fp)
 8244a0c:	10800084 	addi	r2,r2,2
 8244a10:	1085883a 	add	r2,r2,r2
 8244a14:	1085883a 	add	r2,r2,r2
 8244a18:	1885883a 	add	r2,r3,r2
 8244a1c:	10800017 	ldw	r2,0(r2)
 8244a20:	10c00017 	ldw	r3,0(r2)
 8244a24:	e0bff617 	ldw	r2,-40(fp)
 8244a28:	10800417 	ldw	r2,16(r2)
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244a2c:	18800926 	beq	r3,r2,8244a54 <udpdemux+0x504>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244a30:	e0bff50b 	ldhu	r2,-44(fp)
 8244a34:	10800044 	addi	r2,r2,1
 8244a38:	e0bff50d 	sth	r2,-44(fp)
 8244a3c:	e0bffb17 	ldw	r2,-20(fp)
 8244a40:	1080018b 	ldhu	r2,6(r2)
 8244a44:	10bfffcc 	andi	r2,r2,65535
 8244a48:	e0fff50b 	ldhu	r3,-44(fp)
 8244a4c:	18bfe236 	bltu	r3,r2,82449d8 <udpdemux+0x488>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 8244a50:	00004a06 	br	8244b7c <udpdemux+0x62c>
            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
 8244a54:	0001883a 	nop
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 8244a58:	e0bff617 	ldw	r2,-40(fp)
 8244a5c:	10800417 	ldw	r2,16(r2)
 8244a60:	1006d63a 	srli	r3,r2,24
 8244a64:	e0bff617 	ldw	r2,-40(fp)
 8244a68:	10800417 	ldw	r2,16(r2)
 8244a6c:	1004d23a 	srli	r2,r2,8
 8244a70:	10bfc00c 	andi	r2,r2,65280
 8244a74:	1886b03a 	or	r3,r3,r2
 8244a78:	e0bff617 	ldw	r2,-40(fp)
 8244a7c:	10800417 	ldw	r2,16(r2)
 8244a80:	10bfc00c 	andi	r2,r2,65280
 8244a84:	1004923a 	slli	r2,r2,8
 8244a88:	1886b03a 	or	r3,r3,r2
 8244a8c:	e0bff617 	ldw	r2,-40(fp)
 8244a90:	10800417 	ldw	r2,16(r2)
 8244a94:	1004963a 	slli	r2,r2,24
 8244a98:	1884b03a 	or	r2,r3,r2
 8244a9c:	10fc002c 	andhi	r3,r2,61440
 8244aa0:	00b80034 	movhi	r2,57344
 8244aa4:	18800826 	beq	r3,r2,8244ac8 <udpdemux+0x578>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 8244aa8:	e0bff217 	ldw	r2,-56(fp)
 8244aac:	10800317 	ldw	r2,12(r2)
 8244ab0:	10000526 	beq	r2,zero,8244ac8 <udpdemux+0x578>
 8244ab4:	e0bff217 	ldw	r2,-56(fp)
 8244ab8:	10c00317 	ldw	r3,12(r2)
 8244abc:	e0bff617 	ldw	r2,-40(fp)
 8244ac0:	10800417 	ldw	r2,16(r2)
 8244ac4:	18802c1e 	bne	r3,r2,8244b78 <udpdemux+0x628>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 8244ac8:	008209b4 	movhi	r2,2086
 8244acc:	10b99a04 	addi	r2,r2,-6552
 8244ad0:	10800017 	ldw	r2,0(r2)
 8244ad4:	10c00044 	addi	r3,r2,1
 8244ad8:	008209b4 	movhi	r2,2086
 8244adc:	10b99a04 	addi	r2,r2,-6552
 8244ae0:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 8244ae4:	e0bff217 	ldw	r2,-56(fp)
 8244ae8:	10800517 	ldw	r2,20(r2)
 8244aec:	10000d26 	beq	r2,zero,8244b24 <udpdemux+0x5d4>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244af0:	0009883a 	mov	r4,zero
 8244af4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 8244af8:	e0bff217 	ldw	r2,-56(fp)
 8244afc:	10800517 	ldw	r2,20(r2)
 8244b00:	e0fff217 	ldw	r3,-56(fp)
 8244b04:	18c00617 	ldw	r3,24(r3)
 8244b08:	180b883a 	mov	r5,r3
 8244b0c:	e13fff17 	ldw	r4,-4(fp)
 8244b10:	103ee83a 	callr	r2
 8244b14:	e0bff415 	stw	r2,-48(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8244b18:	0009883a 	mov	r4,zero
 8244b1c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
 8244b20:	00000206 	br	8244b2c <udpdemux+0x5dc>
      }
      else
         e = ENP_LOGIC;
 8244b24:	00bffd44 	movi	r2,-11
 8244b28:	e0bff415 	stw	r2,-48(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 8244b2c:	e0bff417 	ldw	r2,-48(fp)
 8244b30:	10000926 	beq	r2,zero,8244b58 <udpdemux+0x608>
      {
         udp_mib.udpInErrors++;
 8244b34:	008209b4 	movhi	r2,2086
 8244b38:	10b99a04 	addi	r2,r2,-6552
 8244b3c:	10800217 	ldw	r2,8(r2)
 8244b40:	10c00044 	addi	r3,r2,1
 8244b44:	008209b4 	movhi	r2,2086
 8244b48:	10b99a04 	addi	r2,r2,-6552
 8244b4c:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244b50:	e13fff17 	ldw	r4,-4(fp)
 8244b54:	82452140 	call	8245214 <udp_free>
      }

      return(e);
 8244b58:	e0bff417 	ldw	r2,-48(fp)
 8244b5c:	00006106 	br	8244ce4 <udpdemux+0x794>
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
         continue;
 8244b60:	0001883a 	nop
 8244b64:	00000506 	br	8244b7c <udpdemux+0x62c>
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
         continue;
 8244b68:	0001883a 	nop
 8244b6c:	00000306 	br	8244b7c <udpdemux+0x62c>
      if (con->u_fhost && (con->u_fhost != p->fhost))
         continue;
 8244b70:	0001883a 	nop
 8244b74:	00000106 	br	8244b7c <udpdemux+0x62c>
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
            continue;
 8244b78:	0001883a 	nop
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244b7c:	e0bff217 	ldw	r2,-56(fp)
 8244b80:	10800017 	ldw	r2,0(r2)
 8244b84:	e0bff215 	stw	r2,-56(fp)
 8244b88:	e0bff217 	ldw	r2,-56(fp)
 8244b8c:	103f501e 	bne	r2,zero,82448d0 <udpdemux+0x380>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244b90:	e0bff617 	ldw	r2,-40(fp)
 8244b94:	10800417 	ldw	r2,16(r2)
 8244b98:	10bfffe0 	cmpeqi	r2,r2,-1
 8244b9c:	1000121e 	bne	r2,zero,8244be8 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244ba0:	e0bff617 	ldw	r2,-40(fp)
 8244ba4:	10c00417 	ldw	r3,16(r2)
 8244ba8:	e0bfff17 	ldw	r2,-4(fp)
 8244bac:	10800617 	ldw	r2,24(r2)
 8244bb0:	10800e17 	ldw	r2,56(r2)

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244bb4:	18800c26 	beq	r3,r2,8244be8 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244bb8:	e0bff617 	ldw	r2,-40(fp)
 8244bbc:	10c00417 	ldw	r3,16(r2)
 8244bc0:	e0bfff17 	ldw	r2,-4(fp)
 8244bc4:	10800617 	ldw	r2,24(r2)
 8244bc8:	10800f17 	ldw	r2,60(r2)
   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244bcc:	18800626 	beq	r3,r2,8244be8 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
 8244bd0:	e0bff617 	ldw	r2,-40(fp)
 8244bd4:	10c00417 	ldw	r3,16(r2)
 8244bd8:	e0bfff17 	ldw	r2,-4(fp)
 8244bdc:	10800617 	ldw	r2,24(r2)
 8244be0:	10801017 	ldw	r2,64(r2)
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244be4:	1880141e 	bne	r3,r2,8244c38 <udpdemux+0x6e8>
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244be8:	d0a08317 	ldw	r2,-32244(gp)
 8244bec:	1081000c 	andi	r2,r2,1024
 8244bf0:	10000626 	beq	r2,zero,8244c0c <udpdemux+0x6bc>
 8244bf4:	d0a08317 	ldw	r2,-32244(gp)
 8244bf8:	1080400c 	andi	r2,r2,256
 8244bfc:	10000326 	beq	r2,zero,8244c0c <udpdemux+0x6bc>
         dprintf("UDP: ignoring ip broadcast\n");
 8244c00:	01020974 	movhi	r4,2085
 8244c04:	2104d704 	addi	r4,r4,4956
 8244c08:	82033700 	call	8203370 <puts>
#endif
      udp_mib.udpInErrors++;
 8244c0c:	008209b4 	movhi	r2,2086
 8244c10:	10b99a04 	addi	r2,r2,-6552
 8244c14:	10800217 	ldw	r2,8(r2)
 8244c18:	10c00044 	addi	r3,r2,1
 8244c1c:	008209b4 	movhi	r2,2086
 8244c20:	10b99a04 	addi	r2,r2,-6552
 8244c24:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244c28:	e13fff17 	ldw	r4,-4(fp)
 8244c2c:	82452140 	call	8245214 <udp_free>
      return ENP_NOT_MINE;
 8244c30:	00800084 	movi	r2,2
 8244c34:	00002b06 	br	8244ce4 <udpdemux+0x794>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244c38:	d0a08317 	ldw	r2,-32244(gp)
 8244c3c:	1081000c 	andi	r2,r2,1024
 8244c40:	10000f26 	beq	r2,zero,8244c80 <udpdemux+0x730>
 8244c44:	d0a08317 	ldw	r2,-32244(gp)
 8244c48:	1080400c 	andi	r2,r2,256
 8244c4c:	10000c26 	beq	r2,zero,8244c80 <udpdemux+0x730>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 8244c50:	e0bff717 	ldw	r2,-36(fp)
 8244c54:	1080008b 	ldhu	r2,2(r2)
 8244c58:	10bfffcc 	andi	r2,r2,65535
 8244c5c:	100b883a 	mov	r5,r2
 8244c60:	01020974 	movhi	r4,2085
 8244c64:	2104de04 	addi	r4,r4,4984
 8244c68:	82030ec0 	call	82030ec <printf>
      if (NDEBUG & DUMP) 
 8244c6c:	d0a08317 	ldw	r2,-32244(gp)
 8244c70:	1080008c 	andi	r2,r2,2
 8244c74:	10000226 	beq	r2,zero,8244c80 <udpdemux+0x730>
         ip_dump(p);
 8244c78:	e13fff17 	ldw	r4,-4(fp)
 8244c7c:	824078c0 	call	824078c <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244c80:	e13ff717 	ldw	r4,-36(fp)
 8244c84:	8244f900 	call	8244f90 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 8244c88:	e0bfff17 	ldw	r2,-4(fp)
 8244c8c:	10c00717 	ldw	r3,28(r2)
 8244c90:	e0bfff17 	ldw	r2,-4(fp)
 8244c94:	10800617 	ldw	r2,24(r2)
 8244c98:	11000a17 	ldw	r4,40(r2)
 8244c9c:	e0bfff17 	ldw	r2,-4(fp)
 8244ca0:	10800617 	ldw	r2,24(r2)
 8244ca4:	d8800015 	stw	r2,0(sp)
 8244ca8:	01c000c4 	movi	r7,3
 8244cac:	e1bff617 	ldw	r6,-40(fp)
 8244cb0:	200b883a 	mov	r5,r4
 8244cb4:	1809883a 	mov	r4,r3
 8244cb8:	824ad100 	call	824ad10 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 8244cbc:	008209b4 	movhi	r2,2086
 8244cc0:	10b99a04 	addi	r2,r2,-6552
 8244cc4:	10800117 	ldw	r2,4(r2)
 8244cc8:	10c00044 	addi	r3,r2,1
 8244ccc:	008209b4 	movhi	r2,2086
 8244cd0:	10b99a04 	addi	r2,r2,-6552
 8244cd4:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 8244cd8:	e13fff17 	ldw	r4,-4(fp)
 8244cdc:	82452140 	call	8245214 <udp_free>
   return ENP_NOT_MINE;
 8244ce0:	00800084 	movi	r2,2
}
 8244ce4:	e037883a 	mov	sp,fp
 8244ce8:	dfc00117 	ldw	ra,4(sp)
 8244cec:	df000017 	ldw	fp,0(sp)
 8244cf0:	dec00204 	addi	sp,sp,8
 8244cf4:	f800283a 	ret

08244cf8 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 8244cf8:	deffef04 	addi	sp,sp,-68
 8244cfc:	dfc01015 	stw	ra,64(sp)
 8244d00:	df000f15 	stw	fp,60(sp)
 8244d04:	df000f04 	addi	fp,sp,60
 8244d08:	2007883a 	mov	r3,r4
 8244d0c:	2805883a 	mov	r2,r5
 8244d10:	e1bfff15 	stw	r6,-4(fp)
 8244d14:	e0fffd0d 	sth	r3,-12(fp)
 8244d18:	e0bffe0d 	sth	r2,-8(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 8244d1c:	d0a08317 	ldw	r2,-32244(gp)
 8244d20:	1080410c 	andi	r2,r2,260
 8244d24:	10001a26 	beq	r2,zero,8244d90 <udp_send+0x98>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244d28:	e0bfff17 	ldw	r2,-4(fp)
 8244d2c:	12000417 	ldw	r8,16(r2)
 8244d30:	e1bffe0b 	ldhu	r6,-8(fp)
    PUSH_IPADDR(p->fhost), fport);
 8244d34:	e0bfff17 	ldw	r2,-4(fp)
 8244d38:	10800717 	ldw	r2,28(r2)
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244d3c:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244d40:	e0bfff17 	ldw	r2,-4(fp)
 8244d44:	10800717 	ldw	r2,28(r2)
 8244d48:	1004d23a 	srli	r2,r2,8
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244d4c:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244d50:	e0ffff17 	ldw	r3,-4(fp)
 8244d54:	18c00717 	ldw	r3,28(r3)
 8244d58:	1806d43a 	srli	r3,r3,16
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244d5c:	18c03fcc 	andi	r3,r3,255
    PUSH_IPADDR(p->fhost), fport);
 8244d60:	e13fff17 	ldw	r4,-4(fp)
 8244d64:	21000717 	ldw	r4,28(r4)
 8244d68:	2008d63a 	srli	r4,r4,24
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244d6c:	e17ffd0b 	ldhu	r5,-12(fp)
 8244d70:	d9400315 	stw	r5,12(sp)
 8244d74:	d9000215 	stw	r4,8(sp)
 8244d78:	d8c00115 	stw	r3,4(sp)
 8244d7c:	d8800015 	stw	r2,0(sp)
 8244d80:	400b883a 	mov	r5,r8
 8244d84:	01020974 	movhi	r4,2085
 8244d88:	2104e504 	addi	r4,r4,5012
 8244d8c:	82030ec0 	call	82030ec <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 8244d90:	0009883a 	mov	r4,zero
 8244d94:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 8244d98:	e0bfff17 	ldw	r2,-4(fp)
 8244d9c:	10800317 	ldw	r2,12(r2)
 8244da0:	10fffe04 	addi	r3,r2,-8
 8244da4:	e0bfff17 	ldw	r2,-4(fp)
 8244da8:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 8244dac:	e0bfff17 	ldw	r2,-4(fp)
 8244db0:	10800317 	ldw	r2,12(r2)
 8244db4:	e0bff615 	stw	r2,-40(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 8244db8:	e0bfff17 	ldw	r2,-4(fp)
 8244dbc:	10800417 	ldw	r2,16(r2)
 8244dc0:	10800204 	addi	r2,r2,8
 8244dc4:	e0bff715 	stw	r2,-36(fp)
   p->nb_plen = udplen;
 8244dc8:	e0fff717 	ldw	r3,-36(fp)
 8244dcc:	e0bfff17 	ldw	r2,-4(fp)
 8244dd0:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 8244dd4:	e0bff717 	ldw	r2,-36(fp)
 8244dd8:	1080004c 	andi	r2,r2,1
 8244ddc:	10000426 	beq	r2,zero,8244df0 <udp_send+0xf8>
 8244de0:	e0bff717 	ldw	r2,-36(fp)
 8244de4:	e0fff617 	ldw	r3,-40(fp)
 8244de8:	1885883a 	add	r2,r3,r2
 8244dec:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 8244df0:	e0bff717 	ldw	r2,-36(fp)
 8244df4:	1007883a 	mov	r3,r2
 8244df8:	e0bff617 	ldw	r2,-40(fp)
 8244dfc:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 8244e00:	e0bff617 	ldw	r2,-40(fp)
 8244e04:	e0fffe0b 	ldhu	r3,-8(fp)
 8244e08:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = fport;
 8244e0c:	e0bff617 	ldw	r2,-40(fp)
 8244e10:	e0fffd0b 	ldhu	r3,-12(fp)
 8244e14:	10c0008d 	sth	r3,2(r2)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244e18:	e13ff617 	ldw	r4,-40(fp)
 8244e1c:	8244f900 	call	8244f90 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 8244e20:	e0bfff17 	ldw	r2,-4(fp)
 8244e24:	10800717 	ldw	r2,28(r2)
 8244e28:	10bfffd8 	cmpnei	r2,r2,-1
 8244e2c:	10000f1e 	bne	r2,zero,8244e6c <udp_send+0x174>
   {
      if (!p->net)
 8244e30:	e0bfff17 	ldw	r2,-4(fp)
 8244e34:	10800617 	ldw	r2,24(r2)
 8244e38:	1000071e 	bne	r2,zero,8244e58 <udp_send+0x160>
      {
         dtrap();    /* programmer forgot to select iface */
 8244e3c:	822d2e00 	call	822d2e0 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 8244e40:	e13fff17 	ldw	r4,-4(fp)
 8244e44:	82452140 	call	8245214 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244e48:	0009883a 	mov	r4,zero
 8244e4c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 8244e50:	00bff784 	movi	r2,-34
 8244e54:	00004906 	br	8244f7c <udp_send+0x284>
      }
      src_ip = p->net->n_ipaddr;
 8244e58:	e0bfff17 	ldw	r2,-4(fp)
 8244e5c:	10800617 	ldw	r2,24(r2)
 8244e60:	10800a17 	ldw	r2,40(r2)
 8244e64:	e0bff515 	stw	r2,-44(fp)
 8244e68:	00000506 	br	8244e80 <udp_send+0x188>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 8244e6c:	e0bfff17 	ldw	r2,-4(fp)
 8244e70:	10800717 	ldw	r2,28(r2)
 8244e74:	1009883a 	mov	r4,r2
 8244e78:	82406e80 	call	82406e8 <ip_mymach>
 8244e7c:	e0bff515 	stw	r2,-44(fp)
   php.ph_src = src_ip;
 8244e80:	e0bff517 	ldw	r2,-44(fp)
 8244e84:	e0bffa15 	stw	r2,-24(fp)
   php.ph_dest = p->fhost;
 8244e88:	e0bfff17 	ldw	r2,-4(fp)
 8244e8c:	10800717 	ldw	r2,28(r2)
 8244e90:	e0bffb15 	stw	r2,-20(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 8244e94:	e03ffc05 	stb	zero,-16(fp)
   php.ph_prot = UDP_PROT;
 8244e98:	00800444 	movi	r2,17
 8244e9c:	e0bffc45 	stb	r2,-15(fp)
   php.ph_len = pup->ud_len;
 8244ea0:	e0bff617 	ldw	r2,-40(fp)
 8244ea4:	1080010b 	ldhu	r2,4(r2)
 8244ea8:	e0bffc8d 	sth	r2,-14(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 8244eac:	e0bffa04 	addi	r2,fp,-24
 8244eb0:	01400184 	movi	r5,6
 8244eb4:	1009883a 	mov	r4,r2
 8244eb8:	82285000 	call	8228500 <cksum>
 8244ebc:	1007883a 	mov	r3,r2
 8244ec0:	e0bff617 	ldw	r2,-40(fp)
 8244ec4:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 8244ec8:	e0bff717 	ldw	r2,-36(fp)
 8244ecc:	10800044 	addi	r2,r2,1
 8244ed0:	1005d07a 	srai	r2,r2,1
 8244ed4:	100b883a 	mov	r5,r2
 8244ed8:	e13ff617 	ldw	r4,-40(fp)
 8244edc:	82285000 	call	8228500 <cksum>
 8244ee0:	0084303a 	nor	r2,zero,r2
 8244ee4:	1007883a 	mov	r3,r2
 8244ee8:	e0bff617 	ldw	r2,-40(fp)
 8244eec:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 8244ef0:	e0bff617 	ldw	r2,-40(fp)
 8244ef4:	1080018b 	ldhu	r2,6(r2)
 8244ef8:	10bfffcc 	andi	r2,r2,65535
 8244efc:	1000031e 	bne	r2,zero,8244f0c <udp_send+0x214>
      pup->ud_cksum = 0xffff;
 8244f00:	e0bff617 	ldw	r2,-40(fp)
 8244f04:	00ffffc4 	movi	r3,-1
 8244f08:	10c0018d 	sth	r3,6(r2)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 8244f0c:	e0bfff17 	ldw	r2,-4(fp)
 8244f10:	10800317 	ldw	r2,12(r2)
 8244f14:	10bffb04 	addi	r2,r2,-20
 8244f18:	e0bff815 	stw	r2,-32(fp)
   pip->ip_src = src_ip;
 8244f1c:	e0bff817 	ldw	r2,-32(fp)
 8244f20:	e0fff517 	ldw	r3,-44(fp)
 8244f24:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = p->fhost;
 8244f28:	e0bfff17 	ldw	r2,-4(fp)
 8244f2c:	10c00717 	ldw	r3,28(r2)
 8244f30:	e0bff817 	ldw	r2,-32(fp)
 8244f34:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 8244f38:	008209b4 	movhi	r2,2086
 8244f3c:	10b99a04 	addi	r2,r2,-6552
 8244f40:	10800317 	ldw	r2,12(r2)
 8244f44:	10c00044 	addi	r3,r2,1
 8244f48:	008209b4 	movhi	r2,2086
 8244f4c:	10b99a04 	addi	r2,r2,-6552
 8244f50:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 8244f54:	e0fff717 	ldw	r3,-36(fp)
 8244f58:	e0bfff17 	ldw	r2,-4(fp)
 8244f5c:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 8244f60:	e17fff17 	ldw	r5,-4(fp)
 8244f64:	01000444 	movi	r4,17
 8244f68:	823f6980 	call	823f698 <ip_write>
 8244f6c:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8244f70:	0009883a 	mov	r4,zero
 8244f74:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   return e;
 8244f78:	e0bff917 	ldw	r2,-28(fp)
}
 8244f7c:	e037883a 	mov	sp,fp
 8244f80:	dfc00117 	ldw	ra,4(sp)
 8244f84:	df000017 	ldw	fp,0(sp)
 8244f88:	dec00204 	addi	sp,sp,8
 8244f8c:	f800283a 	ret

08244f90 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 8244f90:	defffe04 	addi	sp,sp,-8
 8244f94:	df000115 	stw	fp,4(sp)
 8244f98:	df000104 	addi	fp,sp,4
 8244f9c:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 8244fa0:	e0bfff17 	ldw	r2,-4(fp)
 8244fa4:	1080000b 	ldhu	r2,0(r2)
 8244fa8:	10bfffcc 	andi	r2,r2,65535
 8244fac:	1004d23a 	srli	r2,r2,8
 8244fb0:	1007883a 	mov	r3,r2
 8244fb4:	e0bfff17 	ldw	r2,-4(fp)
 8244fb8:	1080000b 	ldhu	r2,0(r2)
 8244fbc:	10bfffcc 	andi	r2,r2,65535
 8244fc0:	1004923a 	slli	r2,r2,8
 8244fc4:	1884b03a 	or	r2,r3,r2
 8244fc8:	1007883a 	mov	r3,r2
 8244fcc:	e0bfff17 	ldw	r2,-4(fp)
 8244fd0:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 8244fd4:	e0bfff17 	ldw	r2,-4(fp)
 8244fd8:	1080008b 	ldhu	r2,2(r2)
 8244fdc:	10bfffcc 	andi	r2,r2,65535
 8244fe0:	1004d23a 	srli	r2,r2,8
 8244fe4:	1007883a 	mov	r3,r2
 8244fe8:	e0bfff17 	ldw	r2,-4(fp)
 8244fec:	1080008b 	ldhu	r2,2(r2)
 8244ff0:	10bfffcc 	andi	r2,r2,65535
 8244ff4:	1004923a 	slli	r2,r2,8
 8244ff8:	1884b03a 	or	r2,r3,r2
 8244ffc:	1007883a 	mov	r3,r2
 8245000:	e0bfff17 	ldw	r2,-4(fp)
 8245004:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 8245008:	e0bfff17 	ldw	r2,-4(fp)
 824500c:	1080010b 	ldhu	r2,4(r2)
 8245010:	10bfffcc 	andi	r2,r2,65535
 8245014:	1004d23a 	srli	r2,r2,8
 8245018:	1007883a 	mov	r3,r2
 824501c:	e0bfff17 	ldw	r2,-4(fp)
 8245020:	1080010b 	ldhu	r2,4(r2)
 8245024:	10bfffcc 	andi	r2,r2,65535
 8245028:	1004923a 	slli	r2,r2,8
 824502c:	1884b03a 	or	r2,r3,r2
 8245030:	1007883a 	mov	r3,r2
 8245034:	e0bfff17 	ldw	r2,-4(fp)
 8245038:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 824503c:	e0bfff17 	ldw	r2,-4(fp)
 8245040:	1080018b 	ldhu	r2,6(r2)
 8245044:	10bfffcc 	andi	r2,r2,65535
 8245048:	1004d23a 	srli	r2,r2,8
 824504c:	1007883a 	mov	r3,r2
 8245050:	e0bfff17 	ldw	r2,-4(fp)
 8245054:	1080018b 	ldhu	r2,6(r2)
 8245058:	10bfffcc 	andi	r2,r2,65535
 824505c:	1004923a 	slli	r2,r2,8
 8245060:	1884b03a 	or	r2,r3,r2
 8245064:	1007883a 	mov	r3,r2
 8245068:	e0bfff17 	ldw	r2,-4(fp)
 824506c:	10c0018d 	sth	r3,6(r2)
}
 8245070:	0001883a 	nop
 8245074:	e037883a 	mov	sp,fp
 8245078:	df000017 	ldw	fp,0(sp)
 824507c:	dec00104 	addi	sp,sp,4
 8245080:	f800283a 	ret

08245084 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 8245084:	defffe04 	addi	sp,sp,-8
 8245088:	df000115 	stw	fp,4(sp)
 824508c:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 8245090:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245094:	10bfffcc 	andi	r2,r2,65535
 8245098:	10812c28 	cmpgeui	r2,r2,1200
 824509c:	10000a1e 	bne	r2,zero,82450c8 <udp_socket+0x44>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 82450a0:	d0a0a817 	ldw	r2,-32096(gp)
 82450a4:	109fffcc 	andi	r2,r2,32767
 82450a8:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 82450ac:	d0a0d10b 	ldhu	r2,-31932(gp)
 82450b0:	10bfffcc 	andi	r2,r2,65535
 82450b4:	10812c28 	cmpgeui	r2,r2,1200
 82450b8:	1000031e 	bne	r2,zero,82450c8 <udp_socket+0x44>
         usocket += MINSOCKET;
 82450bc:	d0a0d10b 	ldhu	r2,-31932(gp)
 82450c0:	10812c04 	addi	r2,r2,1200
 82450c4:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 82450c8:	d0a09c17 	ldw	r2,-32144(gp)
 82450cc:	e0bfff15 	stw	r2,-4(fp)
 82450d0:	00000f06 	br	8245110 <udp_socket+0x8c>
   {
      if (tmp->u_lport == usocket)
 82450d4:	e0bfff17 	ldw	r2,-4(fp)
 82450d8:	10c0018b 	ldhu	r3,6(r2)
 82450dc:	d0a0d10b 	ldhu	r2,-31932(gp)
 82450e0:	18ffffcc 	andi	r3,r3,65535
 82450e4:	10bfffcc 	andi	r2,r2,65535
 82450e8:	1880061e 	bne	r3,r2,8245104 <udp_socket+0x80>
      {
         usocket++;     /* bump socket number */
 82450ec:	d0a0d10b 	ldhu	r2,-31932(gp)
 82450f0:	10800044 	addi	r2,r2,1
 82450f4:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 82450f8:	d0a09c17 	ldw	r2,-32144(gp)
 82450fc:	e0bfff15 	stw	r2,-4(fp)
         continue;
 8245100:	0001883a 	nop
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 8245104:	e0bfff17 	ldw	r2,-4(fp)
 8245108:	10800017 	ldw	r2,0(r2)
 824510c:	e0bfff15 	stw	r2,-4(fp)
 8245110:	e0bfff17 	ldw	r2,-4(fp)
 8245114:	103fef1e 	bne	r2,zero,82450d4 <udp_socket+0x50>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 8245118:	d0a0d10b 	ldhu	r2,-31932(gp)
 824511c:	10c00044 	addi	r3,r2,1
 8245120:	d0e0d10d 	sth	r3,-31932(gp)
}
 8245124:	e037883a 	mov	sp,fp
 8245128:	df000017 	ldw	fp,0(sp)
 824512c:	dec00104 	addi	sp,sp,4
 8245130:	f800283a 	ret

08245134 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 8245134:	defffa04 	addi	sp,sp,-24
 8245138:	dfc00515 	stw	ra,20(sp)
 824513c:	df000415 	stw	fp,16(sp)
 8245140:	df000404 	addi	fp,sp,16
 8245144:	e13ffe15 	stw	r4,-8(fp)
 8245148:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 824514c:	e0bffe17 	ldw	r2,-8(fp)
 8245150:	10800244 	addi	r2,r2,9
 8245154:	1007883a 	mov	r3,r2
 8245158:	00bfff84 	movi	r2,-2
 824515c:	1884703a 	and	r2,r3,r2
 8245160:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245164:	01000084 	movi	r4,2
 8245168:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 824516c:	e0bffc17 	ldw	r2,-16(fp)
 8245170:	10c00904 	addi	r3,r2,36
 8245174:	e0bfff17 	ldw	r2,-4(fp)
 8245178:	1885883a 	add	r2,r3,r2
 824517c:	1009883a 	mov	r4,r2
 8245180:	822c7380 	call	822c738 <pk_alloc>
 8245184:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245188:	01000084 	movi	r4,2
 824518c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 8245190:	e0bffd17 	ldw	r2,-12(fp)
 8245194:	10001026 	beq	r2,zero,82451d8 <udp_alloc+0xa4>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 8245198:	e0bfff17 	ldw	r2,-4(fp)
 824519c:	1005d0ba 	srai	r2,r2,2
 82451a0:	10800704 	addi	r2,r2,28
 82451a4:	e0bffc15 	stw	r2,-16(fp)
      p->nb_prot += len;
 82451a8:	e0bffd17 	ldw	r2,-12(fp)
 82451ac:	10c00317 	ldw	r3,12(r2)
 82451b0:	e0bffc17 	ldw	r2,-16(fp)
 82451b4:	1887883a 	add	r3,r3,r2
 82451b8:	e0bffd17 	ldw	r2,-12(fp)
 82451bc:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 82451c0:	e0bffd17 	ldw	r2,-12(fp)
 82451c4:	10c00417 	ldw	r3,16(r2)
 82451c8:	e0bffc17 	ldw	r2,-16(fp)
 82451cc:	1887c83a 	sub	r3,r3,r2
 82451d0:	e0bffd17 	ldw	r2,-12(fp)
 82451d4:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 82451d8:	e0bffd17 	ldw	r2,-12(fp)
}
 82451dc:	e037883a 	mov	sp,fp
 82451e0:	dfc00117 	ldw	ra,4(sp)
 82451e4:	df000017 	ldw	fp,0(sp)
 82451e8:	dec00204 	addi	sp,sp,8
 82451ec:	f800283a 	ret

082451f0 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 82451f0:	deffff04 	addi	sp,sp,-4
 82451f4:	df000015 	stw	fp,0(sp)
 82451f8:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 82451fc:	d0a03917 	ldw	r2,-32540(gp)
 8245200:	10bff704 	addi	r2,r2,-36
#endif
}
 8245204:	e037883a 	mov	sp,fp
 8245208:	df000017 	ldw	fp,0(sp)
 824520c:	dec00104 	addi	sp,sp,4
 8245210:	f800283a 	ret

08245214 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 8245214:	defffd04 	addi	sp,sp,-12
 8245218:	dfc00215 	stw	ra,8(sp)
 824521c:	df000115 	stw	fp,4(sp)
 8245220:	df000104 	addi	fp,sp,4
 8245224:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245228:	01000084 	movi	r4,2
 824522c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 8245230:	e13fff17 	ldw	r4,-4(fp)
 8245234:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245238:	01000084 	movi	r4,2
 824523c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
}
 8245240:	0001883a 	nop
 8245244:	e037883a 	mov	sp,fp
 8245248:	dfc00117 	ldw	ra,4(sp)
 824524c:	df000017 	ldw	fp,0(sp)
 8245250:	dec00204 	addi	sp,sp,8
 8245254:	f800283a 	ret

08245258 <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 8245258:	defff804 	addi	sp,sp,-32
 824525c:	dfc00715 	stw	ra,28(sp)
 8245260:	df000615 	stw	fp,24(sp)
 8245264:	df000604 	addi	fp,sp,24
 8245268:	e13fff15 	stw	r4,-4(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 824526c:	e0bfff17 	ldw	r2,-4(fp)
 8245270:	10800617 	ldw	r2,24(r2)
 8245274:	e0bffc15 	stw	r2,-16(fp)
   int rc;
         
   pip = ip_head (p);
 8245278:	e0bfff17 	ldw	r2,-4(fp)
 824527c:	10800317 	ldw	r2,12(r2)
 8245280:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245284:	e0bffd17 	ldw	r2,-12(fp)
 8245288:	10800003 	ldbu	r2,0(r2)
 824528c:	10803fcc 	andi	r2,r2,255
 8245290:	108003cc 	andi	r2,r2,15
 8245294:	1085883a 	add	r2,r2,r2
 8245298:	1085883a 	add	r2,r2,r2
 824529c:	1007883a 	mov	r3,r2
 82452a0:	e0bffd17 	ldw	r2,-12(fp)
 82452a4:	10c5883a 	add	r2,r2,r3
 82452a8:	e0bffe15 	stw	r2,-8(fp)

   switch (igmp->igmp_type) 
 82452ac:	e0bffe17 	ldw	r2,-8(fp)
 82452b0:	10800003 	ldbu	r2,0(r2)
 82452b4:	10803fcc 	andi	r2,r2,255
 82452b8:	10c00460 	cmpeqi	r3,r2,17
 82452bc:	1800031e 	bne	r3,zero,82452cc <igmpv1_input+0x74>
 82452c0:	108004a0 	cmpeqi	r2,r2,18
 82452c4:	1000571e 	bne	r2,zero,8245424 <igmpv1_input+0x1cc>
 82452c8:	00007606 	br	82454a4 <igmpv1_input+0x24c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 82452cc:	008209b4 	movhi	r2,2086
 82452d0:	10b73e04 	addi	r2,r2,-8968
 82452d4:	10800117 	ldw	r2,4(r2)
 82452d8:	10c00044 	addi	r3,r2,1
 82452dc:	008209b4 	movhi	r2,2086
 82452e0:	10b73e04 	addi	r2,r2,-8968
 82452e4:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82452e8:	e0bffc17 	ldw	r2,-16(fp)
 82452ec:	10802c17 	ldw	r2,176(r2)
 82452f0:	e0bffa15 	stw	r2,-24(fp)
 82452f4:	00004706 	br	8245414 <igmpv1_input+0x1bc>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 82452f8:	e0bffa17 	ldw	r2,-24(fp)
 82452fc:	10800017 	ldw	r2,0(r2)
 8245300:	10004026 	beq	r2,zero,8245404 <igmpv1_input+0x1ac>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 8245304:	e0bffa17 	ldw	r2,-24(fp)
 8245308:	10c00017 	ldw	r3,0(r2)
 824530c:	d0a08817 	ldw	r2,-32224(gp)
 8245310:	18803d26 	beq	r3,r2,8245408 <igmpv1_input+0x1b0>
         {
            if (inm->inm_timer == 0)
 8245314:	e0bffa17 	ldw	r2,-24(fp)
 8245318:	10800317 	ldw	r2,12(r2)
 824531c:	10003a1e 	bne	r2,zero,8245408 <igmpv1_input+0x1b0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8245320:	008209b4 	movhi	r2,2086
 8245324:	10b98004 	addi	r2,r2,-6656
 8245328:	10c00217 	ldw	r3,8(r2)
 824532c:	008209b4 	movhi	r2,2086
 8245330:	10b73a04 	addi	r2,r2,-8984
 8245334:	10800017 	ldw	r2,0(r2)
 8245338:	10800a17 	ldw	r2,40(r2)
 824533c:	1008d63a 	srli	r4,r2,24
 8245340:	008209b4 	movhi	r2,2086
 8245344:	10b73a04 	addi	r2,r2,-8984
 8245348:	10800017 	ldw	r2,0(r2)
 824534c:	10800a17 	ldw	r2,40(r2)
 8245350:	1004d23a 	srli	r2,r2,8
 8245354:	10bfc00c 	andi	r2,r2,65280
 8245358:	2088b03a 	or	r4,r4,r2
 824535c:	008209b4 	movhi	r2,2086
 8245360:	10b73a04 	addi	r2,r2,-8984
 8245364:	10800017 	ldw	r2,0(r2)
 8245368:	10800a17 	ldw	r2,40(r2)
 824536c:	10bfc00c 	andi	r2,r2,65280
 8245370:	1004923a 	slli	r2,r2,8
 8245374:	2088b03a 	or	r4,r4,r2
 8245378:	008209b4 	movhi	r2,2086
 824537c:	10b73a04 	addi	r2,r2,-8984
 8245380:	10800017 	ldw	r2,0(r2)
 8245384:	10800a17 	ldw	r2,40(r2)
 8245388:	1004963a 	slli	r2,r2,24
 824538c:	2084b03a 	or	r2,r4,r2
 8245390:	1887883a 	add	r3,r3,r2
 8245394:	e0bffa17 	ldw	r2,-24(fp)
 8245398:	10800017 	ldw	r2,0(r2)
 824539c:	1008d63a 	srli	r4,r2,24
 82453a0:	e0bffa17 	ldw	r2,-24(fp)
 82453a4:	10800017 	ldw	r2,0(r2)
 82453a8:	1004d23a 	srli	r2,r2,8
 82453ac:	10bfc00c 	andi	r2,r2,65280
 82453b0:	2088b03a 	or	r4,r4,r2
 82453b4:	e0bffa17 	ldw	r2,-24(fp)
 82453b8:	10800017 	ldw	r2,0(r2)
 82453bc:	10bfc00c 	andi	r2,r2,65280
 82453c0:	1004923a 	slli	r2,r2,8
 82453c4:	2088b03a 	or	r4,r4,r2
 82453c8:	e0bffa17 	ldw	r2,-24(fp)
 82453cc:	10800017 	ldw	r2,0(r2)
 82453d0:	1004963a 	slli	r2,r2,24
 82453d4:	2084b03a 	or	r2,r4,r2
 82453d8:	1885883a 	add	r2,r3,r2
 82453dc:	01400c84 	movi	r5,50
 82453e0:	1009883a 	mov	r4,r2
 82453e4:	82029c00 	call	82029c0 <__umodsi3>
 82453e8:	10c00044 	addi	r3,r2,1
 82453ec:	e0bffa17 	ldw	r2,-24(fp)
 82453f0:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 82453f4:	d0a08617 	ldw	r2,-32232(gp)
 82453f8:	10800044 	addi	r2,r2,1
 82453fc:	d0a08615 	stw	r2,-32232(gp)
 8245400:	00000106 	br	8245408 <igmpv1_input+0x1b0>
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
            continue;
 8245404:	0001883a 	nop
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245408:	e0bffa17 	ldw	r2,-24(fp)
 824540c:	10800517 	ldw	r2,20(r2)
 8245410:	e0bffa15 	stw	r2,-24(fp)
 8245414:	e0bffa17 	ldw	r2,-24(fp)
 8245418:	103fb71e 	bne	r2,zero,82452f8 <igmpv1_input+0xa0>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 824541c:	e03ffb15 	stw	zero,-20(fp)
      break;
 8245420:	00002a06 	br	82454cc <igmpv1_input+0x274>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 8245424:	008209b4 	movhi	r2,2086
 8245428:	10b73e04 	addi	r2,r2,-8968
 824542c:	10800217 	ldw	r2,8(r2)
 8245430:	10c00044 	addi	r3,r2,1
 8245434:	008209b4 	movhi	r2,2086
 8245438:	10b73e04 	addi	r2,r2,-8968
 824543c:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 8245440:	e0bffe17 	ldw	r2,-8(fp)
 8245444:	10800117 	ldw	r2,4(r2)
 8245448:	e17ffc17 	ldw	r5,-16(fp)
 824544c:	1009883a 	mov	r4,r2
 8245450:	82438f40 	call	82438f4 <lookup_mcast>
 8245454:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL) 
 8245458:	e0bffa17 	ldw	r2,-24(fp)
 824545c:	10000f26 	beq	r2,zero,824549c <igmpv1_input+0x244>
      {
         if (inm->inm_timer > 0)
 8245460:	e0bffa17 	ldw	r2,-24(fp)
 8245464:	10800317 	ldw	r2,12(r2)
 8245468:	10000c26 	beq	r2,zero,824549c <igmpv1_input+0x244>
         {
            inm->inm_timer = 0;
 824546c:	e0bffa17 	ldw	r2,-24(fp)
 8245470:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 8245474:	d0a08617 	ldw	r2,-32232(gp)
 8245478:	10bfffc4 	addi	r2,r2,-1
 824547c:	d0a08615 	stw	r2,-32232(gp)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 8245480:	008209b4 	movhi	r2,2086
 8245484:	10b73e04 	addi	r2,r2,-8968
 8245488:	10800317 	ldw	r2,12(r2)
 824548c:	10c00044 	addi	r3,r2,1
 8245490:	008209b4 	movhi	r2,2086
 8245494:	10b73e04 	addi	r2,r2,-8968
 8245498:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 824549c:	e03ffb15 	stw	zero,-20(fp)
      break;
 82454a0:	00000a06 	br	82454cc <igmpv1_input+0x274>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 82454a4:	008209b4 	movhi	r2,2086
 82454a8:	10b73e04 	addi	r2,r2,-8968
 82454ac:	10801017 	ldw	r2,64(r2)
 82454b0:	10c00044 	addi	r3,r2,1
 82454b4:	008209b4 	movhi	r2,2086
 82454b8:	10b73e04 	addi	r2,r2,-8968
 82454bc:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 82454c0:	00bfffc4 	movi	r2,-1
 82454c4:	e0bffb15 	stw	r2,-20(fp)
      break;   
 82454c8:	0001883a 	nop
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82454cc:	01000084 	movi	r4,2
 82454d0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 82454d4:	e13fff17 	ldw	r4,-4(fp)
 82454d8:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82454dc:	01000084 	movi	r4,2
 82454e0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      
   return rc;
 82454e4:	e0bffb17 	ldw	r2,-20(fp)
}
 82454e8:	e037883a 	mov	sp,fp
 82454ec:	dfc00117 	ldw	ra,4(sp)
 82454f0:	df000017 	ldw	fp,0(sp)
 82454f4:	dec00204 	addi	sp,sp,8
 82454f8:	f800283a 	ret

082454fc <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 82454fc:	defff904 	addi	sp,sp,-28
 8245500:	dfc00615 	stw	ra,24(sp)
 8245504:	df000515 	stw	fp,20(sp)
 8245508:	df000504 	addi	fp,sp,20
 824550c:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   u_char type;
   int rc;

   pip = ip_head (p);    
 8245510:	e0bfff17 	ldw	r2,-4(fp)
 8245514:	10800317 	ldw	r2,12(r2)
 8245518:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 824551c:	e0bffc17 	ldw	r2,-16(fp)
 8245520:	10800003 	ldbu	r2,0(r2)
 8245524:	10803fcc 	andi	r2,r2,255
 8245528:	108003cc 	andi	r2,r2,15
 824552c:	1085883a 	add	r2,r2,r2
 8245530:	1085883a 	add	r2,r2,r2
 8245534:	1007883a 	mov	r3,r2
 8245538:	e0bffc17 	ldw	r2,-16(fp)
 824553c:	10c5883a 	add	r2,r2,r3
 8245540:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 8245544:	e0bffd17 	ldw	r2,-12(fp)
 8245548:	10800003 	ldbu	r2,0(r2)
 824554c:	e0bffe05 	stb	r2,-8(fp)

   switch (type) 
 8245550:	e0bffe03 	ldbu	r2,-8(fp)
 8245554:	10c004a0 	cmpeqi	r3,r2,18
 8245558:	18000e1e 	bne	r3,zero,8245594 <igmpv2_input+0x98>
 824555c:	10c004c8 	cmpgei	r3,r2,19
 8245560:	1800031e 	bne	r3,zero,8245570 <igmpv2_input+0x74>
 8245564:	10800460 	cmpeqi	r2,r2,17
 8245568:	1000061e 	bne	r2,zero,8245584 <igmpv2_input+0x88>
 824556c:	00001606 	br	82455c8 <igmpv2_input+0xcc>
 8245570:	10c005a0 	cmpeqi	r3,r2,22
 8245574:	1800071e 	bne	r3,zero,8245594 <igmpv2_input+0x98>
 8245578:	108005e0 	cmpeqi	r2,r2,23
 824557c:	1000091e 	bne	r2,zero,82455a4 <igmpv2_input+0xa8>
 8245580:	00001106 	br	82455c8 <igmpv2_input+0xcc>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 8245584:	e13fff17 	ldw	r4,-4(fp)
 8245588:	82457540 	call	8245754 <igmpv2_process_query>
 824558c:	e0bffb15 	stw	r2,-20(fp)
         break;
 8245590:	00001706 	br	82455f0 <igmpv2_input+0xf4>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 8245594:	e13fff17 	ldw	r4,-4(fp)
 8245598:	82456200 	call	8245620 <igmpv2_process_report>
 824559c:	e0bffb15 	stw	r2,-20(fp)
         break;
 82455a0:	00001306 	br	82455f0 <igmpv2_input+0xf4>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 82455a4:	008209b4 	movhi	r2,2086
 82455a8:	10b73e04 	addi	r2,r2,-8968
 82455ac:	10800917 	ldw	r2,36(r2)
 82455b0:	10c00044 	addi	r3,r2,1
 82455b4:	008209b4 	movhi	r2,2086
 82455b8:	10b73e04 	addi	r2,r2,-8968
 82455bc:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 82455c0:	e03ffb15 	stw	zero,-20(fp)
         break;               
 82455c4:	00000a06 	br	82455f0 <igmpv2_input+0xf4>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 82455c8:	008209b4 	movhi	r2,2086
 82455cc:	10b73e04 	addi	r2,r2,-8968
 82455d0:	10801517 	ldw	r2,84(r2)
 82455d4:	10c00044 	addi	r3,r2,1
 82455d8:	008209b4 	movhi	r2,2086
 82455dc:	10b73e04 	addi	r2,r2,-8968
 82455e0:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 82455e4:	00bfffc4 	movi	r2,-1
 82455e8:	e0bffb15 	stw	r2,-20(fp)
         break;
 82455ec:	0001883a 	nop
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82455f0:	01000084 	movi	r4,2
 82455f4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   pk_free(p);
 82455f8:	e13fff17 	ldw	r4,-4(fp)
 82455fc:	822ca880 	call	822ca88 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245600:	01000084 	movi	r4,2
 8245604:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
   
   return rc;
 8245608:	e0bffb17 	ldw	r2,-20(fp)
}
 824560c:	e037883a 	mov	sp,fp
 8245610:	dfc00117 	ldw	ra,4(sp)
 8245614:	df000017 	ldw	fp,0(sp)
 8245618:	dec00204 	addi	sp,sp,8
 824561c:	f800283a 	ret

08245620 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 8245620:	defff904 	addi	sp,sp,-28
 8245624:	dfc00615 	stw	ra,24(sp)
 8245628:	df000515 	stw	fp,20(sp)
 824562c:	df000504 	addi	fp,sp,20
 8245630:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 8245634:	e0bfff17 	ldw	r2,-4(fp)
 8245638:	10800617 	ldw	r2,24(r2)
 824563c:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 8245640:	e0bfff17 	ldw	r2,-4(fp)
 8245644:	10800317 	ldw	r2,12(r2)
 8245648:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 824564c:	e0bffc17 	ldw	r2,-16(fp)
 8245650:	10800003 	ldbu	r2,0(r2)
 8245654:	10803fcc 	andi	r2,r2,255
 8245658:	108003cc 	andi	r2,r2,15
 824565c:	1085883a 	add	r2,r2,r2
 8245660:	1085883a 	add	r2,r2,r2
 8245664:	1007883a 	mov	r3,r2
 8245668:	e0bffc17 	ldw	r2,-16(fp)
 824566c:	10c5883a 	add	r2,r2,r3
 8245670:	e0bffd15 	stw	r2,-12(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 8245674:	e0bffd17 	ldw	r2,-12(fp)
 8245678:	10800117 	ldw	r2,4(r2)
 824567c:	e17ffb17 	ldw	r5,-20(fp)
 8245680:	1009883a 	mov	r4,r2
 8245684:	82438f40 	call	82438f4 <lookup_mcast>
 8245688:	e0bffe15 	stw	r2,-8(fp)
   if (inm != NULL) 
 824568c:	e0bffe17 	ldw	r2,-8(fp)
 8245690:	10002326 	beq	r2,zero,8245720 <igmpv2_process_report+0x100>
   {
      if (inm->inm_timer != 0)
 8245694:	e0bffe17 	ldw	r2,-8(fp)
 8245698:	10800317 	ldw	r2,12(r2)
 824569c:	10001826 	beq	r2,zero,8245700 <igmpv2_process_report+0xe0>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82456a0:	e0bffb17 	ldw	r2,-20(fp)
 82456a4:	10802d03 	ldbu	r2,180(r2)
 82456a8:	10803fcc 	andi	r2,r2,255
 82456ac:	10000526 	beq	r2,zero,82456c4 <igmpv2_process_report+0xa4>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
 82456b0:	e0bffd17 	ldw	r2,-12(fp)
 82456b4:	10800003 	ldbu	r2,0(r2)
   if (inm != NULL) 
   {
      if (inm->inm_timer != 0)
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82456b8:	10803fcc 	andi	r2,r2,255
 82456bc:	108005a0 	cmpeqi	r2,r2,22
 82456c0:	10001e1e 	bne	r2,zero,824573c <igmpv2_process_report+0x11c>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 82456c4:	e0bffe17 	ldw	r2,-8(fp)
 82456c8:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 82456cc:	d0a08617 	ldw	r2,-32232(gp)
 82456d0:	10bfffc4 	addi	r2,r2,-1
 82456d4:	d0a08615 	stw	r2,-32232(gp)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 82456d8:	e0bffe17 	ldw	r2,-8(fp)
 82456dc:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 82456e0:	008209b4 	movhi	r2,2086
 82456e4:	10b73e04 	addi	r2,r2,-8968
 82456e8:	10800717 	ldw	r2,28(r2)
 82456ec:	10c00044 	addi	r3,r2,1
 82456f0:	008209b4 	movhi	r2,2086
 82456f4:	10b73e04 	addi	r2,r2,-8968
 82456f8:	10c00715 	stw	r3,28(r2)
 82456fc:	00000f06 	br	824573c <igmpv2_process_report+0x11c>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 8245700:	008209b4 	movhi	r2,2086
 8245704:	10b73e04 	addi	r2,r2,-8968
 8245708:	10800817 	ldw	r2,32(r2)
 824570c:	10c00044 	addi	r3,r2,1
 8245710:	008209b4 	movhi	r2,2086
 8245714:	10b73e04 	addi	r2,r2,-8968
 8245718:	10c00815 	stw	r3,32(r2)
 824571c:	00000706 	br	824573c <igmpv2_process_report+0x11c>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 8245720:	008209b4 	movhi	r2,2086
 8245724:	10b73e04 	addi	r2,r2,-8968
 8245728:	10801317 	ldw	r2,76(r2)
 824572c:	10c00044 	addi	r3,r2,1
 8245730:	008209b4 	movhi	r2,2086
 8245734:	10b73e04 	addi	r2,r2,-8968
 8245738:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 824573c:	0005883a 	mov	r2,zero
}
 8245740:	e037883a 	mov	sp,fp
 8245744:	dfc00117 	ldw	ra,4(sp)
 8245748:	df000017 	ldw	fp,0(sp)
 824574c:	dec00204 	addi	sp,sp,8
 8245750:	f800283a 	ret

08245754 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 8245754:	defff804 	addi	sp,sp,-32
 8245758:	dfc00715 	stw	ra,28(sp)
 824575c:	df000615 	stw	fp,24(sp)
 8245760:	df000604 	addi	fp,sp,24
 8245764:	e13fff15 	stw	r4,-4(fp)
   NET netp;
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;

   netp = p->net;
 8245768:	e0bfff17 	ldw	r2,-4(fp)
 824576c:	10800617 	ldw	r2,24(r2)
 8245770:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 8245774:	e0bfff17 	ldw	r2,-4(fp)
 8245778:	10800317 	ldw	r2,12(r2)
 824577c:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245780:	e0bffd17 	ldw	r2,-12(fp)
 8245784:	10800003 	ldbu	r2,0(r2)
 8245788:	10803fcc 	andi	r2,r2,255
 824578c:	108003cc 	andi	r2,r2,15
 8245790:	1085883a 	add	r2,r2,r2
 8245794:	1085883a 	add	r2,r2,r2
 8245798:	1007883a 	mov	r3,r2
 824579c:	e0bffd17 	ldw	r2,-12(fp)
 82457a0:	10c5883a 	add	r2,r2,r3
 82457a4:	e0bffe15 	stw	r2,-8(fp)

   if (igmp->igmp_code == 0)
 82457a8:	e0bffe17 	ldw	r2,-8(fp)
 82457ac:	10800043 	ldbu	r2,1(r2)
 82457b0:	10803fcc 	andi	r2,r2,255
 82457b4:	1000121e 	bne	r2,zero,8245800 <igmpv2_process_query+0xac>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 82457b8:	e0bffc17 	ldw	r2,-16(fp)
 82457bc:	00c00044 	movi	r3,1
 82457c0:	10c02d05 	stb	r3,180(r2)
      netp->igmpv1_query_rcvd_time = cticks;      
 82457c4:	d0e0a817 	ldw	r3,-32096(gp)
 82457c8:	e0bffc17 	ldw	r2,-16(fp)
 82457cc:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 82457d0:	008209b4 	movhi	r2,2086
 82457d4:	10b73e04 	addi	r2,r2,-8968
 82457d8:	10800417 	ldw	r2,16(r2)
 82457dc:	10c00044 	addi	r3,r2,1
 82457e0:	008209b4 	movhi	r2,2086
 82457e4:	10b73e04 	addi	r2,r2,-8968
 82457e8:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 82457ec:	00800c84 	movi	r2,50
 82457f0:	e0bffa0d 	sth	r2,-24(fp)
      process_all = IGMP_TRUE;
 82457f4:	00800044 	movi	r2,1
 82457f8:	e0bffa85 	stb	r2,-22(fp)
 82457fc:	00001d06 	br	8245874 <igmpv2_process_query+0x120>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 8245800:	e0bffe17 	ldw	r2,-8(fp)
 8245804:	10800117 	ldw	r2,4(r2)
 8245808:	10000a1e 	bne	r2,zero,8245834 <igmpv2_process_query+0xe0>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 824580c:	008209b4 	movhi	r2,2086
 8245810:	10b73e04 	addi	r2,r2,-8968
 8245814:	10800517 	ldw	r2,20(r2)
 8245818:	10c00044 	addi	r3,r2,1
 824581c:	008209b4 	movhi	r2,2086
 8245820:	10b73e04 	addi	r2,r2,-8968
 8245824:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 8245828:	00800044 	movi	r2,1
 824582c:	e0bffa85 	stb	r2,-22(fp)
 8245830:	00000806 	br	8245854 <igmpv2_process_query+0x100>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 8245834:	008209b4 	movhi	r2,2086
 8245838:	10b73e04 	addi	r2,r2,-8968
 824583c:	10800617 	ldw	r2,24(r2)
 8245840:	10c00044 	addi	r3,r2,1
 8245844:	008209b4 	movhi	r2,2086
 8245848:	10b73e04 	addi	r2,r2,-8968
 824584c:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 8245850:	e03ffa85 	stb	zero,-22(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 8245854:	e0bffe17 	ldw	r2,-8(fp)
 8245858:	10800043 	ldbu	r2,1(r2)
 824585c:	10803fcc 	andi	r2,r2,255
 8245860:	10800164 	muli	r2,r2,5
 8245864:	01400284 	movi	r5,10
 8245868:	1009883a 	mov	r4,r2
 824586c:	82028640 	call	8202864 <__divsi3>
 8245870:	e0bffa0d 	sth	r2,-24(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 8245874:	e0bffa83 	ldbu	r2,-22(fp)
 8245878:	10001726 	beq	r2,zero,82458d8 <igmpv2_process_query+0x184>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 824587c:	e0bffc17 	ldw	r2,-16(fp)
 8245880:	10802c17 	ldw	r2,176(r2)
 8245884:	e0bffb15 	stw	r2,-20(fp)
 8245888:	00001006 	br	82458cc <igmpv2_process_query+0x178>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 824588c:	e0bffb17 	ldw	r2,-20(fp)
 8245890:	10800017 	ldw	r2,0(r2)
 8245894:	10000926 	beq	r2,zero,82458bc <igmpv2_process_query+0x168>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 8245898:	e0bffb17 	ldw	r2,-20(fp)
 824589c:	10c00017 	ldw	r3,0(r2)
 82458a0:	d0a08817 	ldw	r2,-32224(gp)
 82458a4:	18800626 	beq	r3,r2,82458c0 <igmpv2_process_query+0x16c>
            igmpv2_chk_set_timer (inm, max_resp_time);
 82458a8:	e0bffa0b 	ldhu	r2,-24(fp)
 82458ac:	100b883a 	mov	r5,r2
 82458b0:	e13ffb17 	ldw	r4,-20(fp)
 82458b4:	82459400 	call	8245940 <igmpv2_chk_set_timer>
 82458b8:	00000106 	br	82458c0 <igmpv2_process_query+0x16c>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 82458bc:	0001883a 	nop
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82458c0:	e0bffb17 	ldw	r2,-20(fp)
 82458c4:	10800517 	ldw	r2,20(r2)
 82458c8:	e0bffb15 	stw	r2,-20(fp)
 82458cc:	e0bffb17 	ldw	r2,-20(fp)
 82458d0:	103fee1e 	bne	r2,zero,824588c <igmpv2_process_query+0x138>
 82458d4:	00001406 	br	8245928 <igmpv2_process_query+0x1d4>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 82458d8:	e0bffe17 	ldw	r2,-8(fp)
 82458dc:	10800117 	ldw	r2,4(r2)
 82458e0:	e17ffc17 	ldw	r5,-16(fp)
 82458e4:	1009883a 	mov	r4,r2
 82458e8:	82438f40 	call	82438f4 <lookup_mcast>
 82458ec:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL)
 82458f0:	e0bffb17 	ldw	r2,-20(fp)
 82458f4:	10000526 	beq	r2,zero,824590c <igmpv2_process_query+0x1b8>
         igmpv2_chk_set_timer (inm, max_resp_time);
 82458f8:	e0bffa0b 	ldhu	r2,-24(fp)
 82458fc:	100b883a 	mov	r5,r2
 8245900:	e13ffb17 	ldw	r4,-20(fp)
 8245904:	82459400 	call	8245940 <igmpv2_chk_set_timer>
 8245908:	00000706 	br	8245928 <igmpv2_process_query+0x1d4>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 824590c:	008209b4 	movhi	r2,2086
 8245910:	10b73e04 	addi	r2,r2,-8968
 8245914:	10801217 	ldw	r2,72(r2)
 8245918:	10c00044 	addi	r3,r2,1
 824591c:	008209b4 	movhi	r2,2086
 8245920:	10b73e04 	addi	r2,r2,-8968
 8245924:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 8245928:	0005883a 	mov	r2,zero
}
 824592c:	e037883a 	mov	sp,fp
 8245930:	dfc00117 	ldw	ra,4(sp)
 8245934:	df000017 	ldw	fp,0(sp)
 8245938:	dec00204 	addi	sp,sp,8
 824593c:	f800283a 	ret

08245940 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 8245940:	defffc04 	addi	sp,sp,-16
 8245944:	dfc00315 	stw	ra,12(sp)
 8245948:	df000215 	stw	fp,8(sp)
 824594c:	df000204 	addi	fp,sp,8
 8245950:	e13ffe15 	stw	r4,-8(fp)
 8245954:	2805883a 	mov	r2,r5
 8245958:	e0bfff0d 	sth	r2,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 824595c:	e0bffe17 	ldw	r2,-8(fp)
 8245960:	10800317 	ldw	r2,12(r2)
 8245964:	e0ffff0b 	ldhu	r3,-4(fp)
 8245968:	18800336 	bltu	r3,r2,8245978 <igmpv2_chk_set_timer+0x38>
       (inm->inm_timer == 0))
 824596c:	e0bffe17 	ldw	r2,-8(fp)
 8245970:	10800317 	ldw	r2,12(r2)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245974:	10003d1e 	bne	r2,zero,8245a6c <igmpv2_chk_set_timer+0x12c>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 8245978:	e0bffe17 	ldw	r2,-8(fp)
 824597c:	10800317 	ldw	r2,12(r2)
 8245980:	1000031e 	bne	r2,zero,8245990 <igmpv2_chk_set_timer+0x50>
 8245984:	d0a08617 	ldw	r2,-32232(gp)
 8245988:	10800044 	addi	r2,r2,1
 824598c:	d0a08615 	stw	r2,-32232(gp)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 8245990:	008209b4 	movhi	r2,2086
 8245994:	10b98004 	addi	r2,r2,-6656
 8245998:	10c00217 	ldw	r3,8(r2)
 824599c:	008209b4 	movhi	r2,2086
 82459a0:	10b73a04 	addi	r2,r2,-8984
 82459a4:	10800017 	ldw	r2,0(r2)
 82459a8:	10800a17 	ldw	r2,40(r2)
 82459ac:	1008d63a 	srli	r4,r2,24
 82459b0:	008209b4 	movhi	r2,2086
 82459b4:	10b73a04 	addi	r2,r2,-8984
 82459b8:	10800017 	ldw	r2,0(r2)
 82459bc:	10800a17 	ldw	r2,40(r2)
 82459c0:	1004d23a 	srli	r2,r2,8
 82459c4:	10bfc00c 	andi	r2,r2,65280
 82459c8:	2088b03a 	or	r4,r4,r2
 82459cc:	008209b4 	movhi	r2,2086
 82459d0:	10b73a04 	addi	r2,r2,-8984
 82459d4:	10800017 	ldw	r2,0(r2)
 82459d8:	10800a17 	ldw	r2,40(r2)
 82459dc:	10bfc00c 	andi	r2,r2,65280
 82459e0:	1004923a 	slli	r2,r2,8
 82459e4:	2088b03a 	or	r4,r4,r2
 82459e8:	008209b4 	movhi	r2,2086
 82459ec:	10b73a04 	addi	r2,r2,-8984
 82459f0:	10800017 	ldw	r2,0(r2)
 82459f4:	10800a17 	ldw	r2,40(r2)
 82459f8:	1004963a 	slli	r2,r2,24
 82459fc:	2084b03a 	or	r2,r4,r2
 8245a00:	1887883a 	add	r3,r3,r2
 8245a04:	e0bffe17 	ldw	r2,-8(fp)
 8245a08:	10800017 	ldw	r2,0(r2)
 8245a0c:	1008d63a 	srli	r4,r2,24
 8245a10:	e0bffe17 	ldw	r2,-8(fp)
 8245a14:	10800017 	ldw	r2,0(r2)
 8245a18:	1004d23a 	srli	r2,r2,8
 8245a1c:	10bfc00c 	andi	r2,r2,65280
 8245a20:	2088b03a 	or	r4,r4,r2
 8245a24:	e0bffe17 	ldw	r2,-8(fp)
 8245a28:	10800017 	ldw	r2,0(r2)
 8245a2c:	10bfc00c 	andi	r2,r2,65280
 8245a30:	1004923a 	slli	r2,r2,8
 8245a34:	2088b03a 	or	r4,r4,r2
 8245a38:	e0bffe17 	ldw	r2,-8(fp)
 8245a3c:	10800017 	ldw	r2,0(r2)
 8245a40:	1004963a 	slli	r2,r2,24
 8245a44:	2084b03a 	or	r2,r4,r2
 8245a48:	1885883a 	add	r2,r3,r2
 8245a4c:	e0ffff0b 	ldhu	r3,-4(fp)
 8245a50:	180b883a 	mov	r5,r3
 8245a54:	1009883a 	mov	r4,r2
 8245a58:	82029c00 	call	82029c0 <__umodsi3>
 8245a5c:	10c00044 	addi	r3,r2,1
 8245a60:	e0bffe17 	ldw	r2,-8(fp)
 8245a64:	10c00315 	stw	r3,12(r2)
   }

   return;
 8245a68:	0001883a 	nop
 8245a6c:	0001883a 	nop
}
 8245a70:	e037883a 	mov	sp,fp
 8245a74:	dfc00117 	ldw	ra,4(sp)
 8245a78:	df000017 	ldw	fp,0(sp)
 8245a7c:	dec00204 	addi	sp,sp,8
 8245a80:	f800283a 	ret

08245a84 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 8245a84:	defffb04 	addi	sp,sp,-20
 8245a88:	df000415 	stw	fp,16(sp)
 8245a8c:	df000404 	addi	fp,sp,16
 8245a90:	e13fff15 	stw	r4,-4(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 8245a94:	e0bfff17 	ldw	r2,-4(fp)
 8245a98:	10800003 	ldbu	r2,0(r2)
 8245a9c:	108003cc 	andi	r2,r2,15
 8245aa0:	1085883a 	add	r2,r2,r2
 8245aa4:	1085883a 	add	r2,r2,r2
 8245aa8:	10bffb04 	addi	r2,r2,-20
 8245aac:	e0bffd05 	stb	r2,-12(fp)

   if (total_optlen > 0)
 8245ab0:	e0bffd03 	ldbu	r2,-12(fp)
 8245ab4:	10003e26 	beq	r2,zero,8245bb0 <igmpv2_chk4_rtr_alert_opt+0x12c>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 8245ab8:	e0bfff17 	ldw	r2,-4(fp)
 8245abc:	10800504 	addi	r2,r2,20
 8245ac0:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 8245ac4:	00003806 	br	8245ba8 <igmpv2_chk4_rtr_alert_opt+0x124>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 8245ac8:	e0bffc17 	ldw	r2,-16(fp)
 8245acc:	10800003 	ldbu	r2,0(r2)
 8245ad0:	108007cc 	andi	r2,r2,31
 8245ad4:	e0bffd85 	stb	r2,-10(fp)
         switch (optval)
 8245ad8:	e0bffd83 	ldbu	r2,-10(fp)
 8245adc:	10c00060 	cmpeqi	r3,r2,1
 8245ae0:	1800071e 	bne	r3,zero,8245b00 <igmpv2_chk4_rtr_alert_opt+0x7c>
 8245ae4:	10c00520 	cmpeqi	r3,r2,20
 8245ae8:	1800081e 	bne	r3,zero,8245b0c <igmpv2_chk4_rtr_alert_opt+0x88>
 8245aec:	1000201e 	bne	r2,zero,8245b70 <igmpv2_chk4_rtr_alert_opt+0xec>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 8245af0:	00800044 	movi	r2,1
 8245af4:	e0bffd45 	stb	r2,-11(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 8245af8:	0005883a 	mov	r2,zero
 8245afc:	00002d06 	br	8245bb4 <igmpv2_chk4_rtr_alert_opt+0x130>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 8245b00:	00800044 	movi	r2,1
 8245b04:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245b08:	00001f06 	br	8245b88 <igmpv2_chk4_rtr_alert_opt+0x104>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 8245b0c:	e0bffc17 	ldw	r2,-16(fp)
 8245b10:	e0bffe15 	stw	r2,-8(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 8245b14:	e0bffe17 	ldw	r2,-8(fp)
 8245b18:	10800017 	ldw	r2,0(r2)
 8245b1c:	1006d63a 	srli	r3,r2,24
 8245b20:	e0bffe17 	ldw	r2,-8(fp)
 8245b24:	10800017 	ldw	r2,0(r2)
 8245b28:	1004d23a 	srli	r2,r2,8
 8245b2c:	10bfc00c 	andi	r2,r2,65280
 8245b30:	1886b03a 	or	r3,r3,r2
 8245b34:	e0bffe17 	ldw	r2,-8(fp)
 8245b38:	10800017 	ldw	r2,0(r2)
 8245b3c:	10bfc00c 	andi	r2,r2,65280
 8245b40:	1004923a 	slli	r2,r2,8
 8245b44:	1886b03a 	or	r3,r3,r2
 8245b48:	e0bffe17 	ldw	r2,-8(fp)
 8245b4c:	10800017 	ldw	r2,0(r2)
 8245b50:	1004963a 	slli	r2,r2,24
 8245b54:	1886b03a 	or	r3,r3,r2
 8245b58:	00a50134 	movhi	r2,37892
 8245b5c:	1880021e 	bne	r3,r2,8245b68 <igmpv2_chk4_rtr_alert_opt+0xe4>
                  /* found the option, return success */
                  return IGMP_TRUE;
 8245b60:	00800044 	movi	r2,1
 8245b64:	00001306 	br	8245bb4 <igmpv2_chk4_rtr_alert_opt+0x130>
               else return IGMP_FALSE;
 8245b68:	0005883a 	mov	r2,zero
 8245b6c:	00001106 	br	8245bb4 <igmpv2_chk4_rtr_alert_opt+0x130>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 8245b70:	e0bffc17 	ldw	r2,-16(fp)
 8245b74:	10800044 	addi	r2,r2,1
 8245b78:	10800003 	ldbu	r2,0(r2)
 8245b7c:	10800084 	addi	r2,r2,2
 8245b80:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245b84:	0001883a 	nop
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 8245b88:	e0bffd43 	ldbu	r2,-11(fp)
 8245b8c:	e0fffc17 	ldw	r3,-16(fp)
 8245b90:	1885883a 	add	r2,r3,r2
 8245b94:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 8245b98:	e0fffd03 	ldbu	r3,-12(fp)
 8245b9c:	e0bffd43 	ldbu	r2,-11(fp)
 8245ba0:	1885c83a 	sub	r2,r3,r2
 8245ba4:	e0bffd05 	stb	r2,-12(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 8245ba8:	e0bffd03 	ldbu	r2,-12(fp)
 8245bac:	103fc61e 	bne	r2,zero,8245ac8 <igmpv2_chk4_rtr_alert_opt+0x44>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 8245bb0:	0005883a 	mov	r2,zero
}
 8245bb4:	e037883a 	mov	sp,fp
 8245bb8:	df000017 	ldw	fp,0(sp)
 8245bbc:	dec00104 	addi	sp,sp,4
 8245bc0:	f800283a 	ret

08245bc4 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 8245bc4:	defffc04 	addi	sp,sp,-16
 8245bc8:	df000315 	stw	fp,12(sp)
 8245bcc:	df000304 	addi	fp,sp,12
 8245bd0:	e13ffe15 	stw	r4,-8(fp)
 8245bd4:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 8245bd8:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 8245bdc:	e0fffd0b 	ldhu	r3,-12(fp)
 8245be0:	008209b4 	movhi	r2,2086
 8245be4:	10b73a04 	addi	r2,r2,-8984
 8245be8:	18c7883a 	add	r3,r3,r3
 8245bec:	18c7883a 	add	r3,r3,r3
 8245bf0:	10c5883a 	add	r2,r2,r3
 8245bf4:	10c00017 	ldw	r3,0(r2)
 8245bf8:	e0bfff17 	ldw	r2,-4(fp)
 8245bfc:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 8245c00:	e0bffe17 	ldw	r2,-8(fp)
 8245c04:	10002e1e 	bne	r2,zero,8245cc0 <IPADDR_TO_NETP+0xfc>
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245c08:	e03ffd0d 	sth	zero,-12(fp)
 8245c0c:	00001606 	br	8245c68 <IPADDR_TO_NETP+0xa4>
      {
         if (nets[idx]->n_mcastlist)
 8245c10:	e0fffd0b 	ldhu	r3,-12(fp)
 8245c14:	008209b4 	movhi	r2,2086
 8245c18:	10b73a04 	addi	r2,r2,-8984
 8245c1c:	18c7883a 	add	r3,r3,r3
 8245c20:	18c7883a 	add	r3,r3,r3
 8245c24:	10c5883a 	add	r2,r2,r3
 8245c28:	10800017 	ldw	r2,0(r2)
 8245c2c:	10802b17 	ldw	r2,172(r2)
 8245c30:	10000a26 	beq	r2,zero,8245c5c <IPADDR_TO_NETP+0x98>
         {
            *netp = nets[idx];
 8245c34:	e0fffd0b 	ldhu	r3,-12(fp)
 8245c38:	008209b4 	movhi	r2,2086
 8245c3c:	10b73a04 	addi	r2,r2,-8984
 8245c40:	18c7883a 	add	r3,r3,r3
 8245c44:	18c7883a 	add	r3,r3,r3
 8245c48:	10c5883a 	add	r2,r2,r3
 8245c4c:	10c00017 	ldw	r3,0(r2)
 8245c50:	e0bfff17 	ldw	r2,-4(fp)
 8245c54:	10c00015 	stw	r3,0(r2)
            break;
 8245c58:	00002206 	br	8245ce4 <IPADDR_TO_NETP+0x120>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245c5c:	e0bffd0b 	ldhu	r2,-12(fp)
 8245c60:	10800044 	addi	r2,r2,1
 8245c64:	e0bffd0d 	sth	r2,-12(fp)
 8245c68:	e0fffd0b 	ldhu	r3,-12(fp)
 8245c6c:	d0a08417 	ldw	r2,-32240(gp)
 8245c70:	18bfe736 	bltu	r3,r2,8245c10 <IPADDR_TO_NETP+0x4c>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245c74:	00001b06 	br	8245ce4 <IPADDR_TO_NETP+0x120>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 8245c78:	e0bffd0b 	ldhu	r2,-12(fp)
 8245c7c:	10800044 	addi	r2,r2,1
 8245c80:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 8245c84:	e0fffd0b 	ldhu	r3,-12(fp)
 8245c88:	d0a08417 	ldw	r2,-32240(gp)
 8245c8c:	18800336 	bltu	r3,r2,8245c9c <IPADDR_TO_NETP+0xd8>
         {
            *netp = NULL;
 8245c90:	e0bfff17 	ldw	r2,-4(fp)
 8245c94:	10000015 	stw	zero,0(r2)
            break;
 8245c98:	00001206 	br	8245ce4 <IPADDR_TO_NETP+0x120>
         }
         else
            *netp = nets[idx];
 8245c9c:	e0fffd0b 	ldhu	r3,-12(fp)
 8245ca0:	008209b4 	movhi	r2,2086
 8245ca4:	10b73a04 	addi	r2,r2,-8984
 8245ca8:	18c7883a 	add	r3,r3,r3
 8245cac:	18c7883a 	add	r3,r3,r3
 8245cb0:	10c5883a 	add	r2,r2,r3
 8245cb4:	10c00017 	ldw	r3,0(r2)
 8245cb8:	e0bfff17 	ldw	r2,-4(fp)
 8245cbc:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 8245cc0:	e0bfff17 	ldw	r2,-4(fp)
 8245cc4:	10800017 	ldw	r2,0(r2)
 8245cc8:	10000626 	beq	r2,zero,8245ce4 <IPADDR_TO_NETP+0x120>
 8245ccc:	e0bfff17 	ldw	r2,-4(fp)
 8245cd0:	10800017 	ldw	r2,0(r2)
 8245cd4:	10c00a17 	ldw	r3,40(r2)
 8245cd8:	e0bffe17 	ldw	r2,-8(fp)
 8245cdc:	18bfe61e 	bne	r3,r2,8245c78 <IPADDR_TO_NETP+0xb4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245ce0:	00000006 	br	8245ce4 <IPADDR_TO_NETP+0x120>
 8245ce4:	0001883a 	nop
 8245ce8:	e037883a 	mov	sp,fp
 8245cec:	df000017 	ldw	fp,0(sp)
 8245cf0:	dec00104 	addi	sp,sp,4
 8245cf4:	f800283a 	ret

08245cf8 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 8245cf8:	defff304 	addi	sp,sp,-52
 8245cfc:	dfc00c15 	stw	ra,48(sp)
 8245d00:	df000b15 	stw	fp,44(sp)
 8245d04:	dc000a15 	stw	r16,40(sp)
 8245d08:	df000b04 	addi	fp,sp,44
 8245d0c:	e13ffc15 	stw	r4,-16(fp)
 8245d10:	e17ffd15 	stw	r5,-12(fp)
 8245d14:	e1bffe15 	stw	r6,-8(fp)
   int   error =  0;
 8245d18:	e03ff515 	stw	zero,-44(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 8245d1c:	e03ffb15 	stw	zero,-20(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 8245d20:	e0bffd17 	ldw	r2,-12(fp)
 8245d24:	10800317 	ldw	r2,12(r2)
 8245d28:	e0bff715 	stw	r2,-36(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 8245d2c:	e0bffd17 	ldw	r2,-12(fp)
 8245d30:	10800304 	addi	r2,r2,12
 8245d34:	e0bff815 	stw	r2,-32(fp)
   ip_addr addr;


   if (imo == NULL) 
 8245d38:	e0bff717 	ldw	r2,-36(fp)
 8245d3c:	1000141e 	bne	r2,zero,8245d90 <ip_setmoptions+0x98>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 8245d40:	01001604 	movi	r4,88
 8245d44:	822deb80 	call	822deb8 <npalloc>
 8245d48:	e0bff715 	stw	r2,-36(fp)

      if (imo == NULL)
 8245d4c:	e0bff717 	ldw	r2,-36(fp)
 8245d50:	1000021e 	bne	r2,zero,8245d5c <ip_setmoptions+0x64>
         return (ENOBUFS);
 8245d54:	00801a44 	movi	r2,105
 8245d58:	00015306 	br	82462a8 <ip_setmoptions+0x5b0>
      *imop = imo;
 8245d5c:	e0bff817 	ldw	r2,-32(fp)
 8245d60:	e0fff717 	ldw	r3,-36(fp)
 8245d64:	10c00015 	stw	r3,0(r2)
      imo->imo_multicast_netp = NULL;
 8245d68:	e0bff717 	ldw	r2,-36(fp)
 8245d6c:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 8245d70:	e0bff717 	ldw	r2,-36(fp)
 8245d74:	00c00044 	movi	r3,1
 8245d78:	10c00105 	stb	r3,4(r2)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 8245d7c:	e0bff717 	ldw	r2,-36(fp)
 8245d80:	00c00044 	movi	r3,1
 8245d84:	10c00145 	stb	r3,5(r2)
      imo->imo_num_memberships = 0;
 8245d88:	e0bff717 	ldw	r2,-36(fp)
 8245d8c:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 8245d90:	e0bffc17 	ldw	r2,-16(fp)
 8245d94:	10bffdc4 	addi	r2,r2,-9
 8245d98:	10c00168 	cmpgeui	r3,r2,5
 8245d9c:	1801261e 	bne	r3,zero,8246238 <ip_setmoptions+0x540>
 8245da0:	100690ba 	slli	r3,r2,2
 8245da4:	00820934 	movhi	r2,2084
 8245da8:	10976e04 	addi	r2,r2,23992
 8245dac:	1885883a 	add	r2,r3,r2
 8245db0:	10800017 	ldw	r2,0(r2)
 8245db4:	1000683a 	jmp	r2
 8245db8:	08245dcc 	andi	zero,at,37239
 8245dbc:	08245e34 	orhi	zero,at,37240
 8245dc0:	08245e48 	cmpgei	zero,at,-28295
 8245dc4:	08245e7c 	xorhi	zero,at,37241
 8245dc8:	08246050 	cmplti	zero,at,-28287

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 8245dcc:	e0bffe17 	ldw	r2,-8(fp)
 8245dd0:	10800017 	ldw	r2,0(r2)
 8245dd4:	e0bff915 	stw	r2,-28(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 8245dd8:	e0bff917 	ldw	r2,-28(fp)
 8245ddc:	1000031e 	bne	r2,zero,8245dec <ip_setmoptions+0xf4>
      {
         imo->imo_multicast_netp = NULL;
 8245de0:	e0bff717 	ldw	r2,-36(fp)
 8245de4:	10000015 	stw	zero,0(r2)
         break;
 8245de8:	00011706 	br	8246248 <ip_setmoptions+0x550>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 8245dec:	e0bffb04 	addi	r2,fp,-20
 8245df0:	100b883a 	mov	r5,r2
 8245df4:	e13ff917 	ldw	r4,-28(fp)
 8245df8:	8245bc40 	call	8245bc4 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 8245dfc:	e0bffb17 	ldw	r2,-20(fp)
 8245e00:	10000326 	beq	r2,zero,8245e10 <ip_setmoptions+0x118>
 8245e04:	e0bffb17 	ldw	r2,-20(fp)
 8245e08:	10802b17 	ldw	r2,172(r2)
 8245e0c:	1000031e 	bne	r2,zero,8245e1c <ip_setmoptions+0x124>
      {
         error = EADDRNOTAVAIL;
 8245e10:	00801f44 	movi	r2,125
 8245e14:	e0bff515 	stw	r2,-44(fp)
         break;
 8245e18:	00010b06 	br	8246248 <ip_setmoptions+0x550>
      }
      if (addr != AADDR) 
 8245e1c:	e0bff917 	ldw	r2,-28(fp)
 8245e20:	10010826 	beq	r2,zero,8246244 <ip_setmoptions+0x54c>
         imo->imo_multicast_netp = netp;
 8245e24:	e0fffb17 	ldw	r3,-20(fp)
 8245e28:	e0bff717 	ldw	r2,-36(fp)
 8245e2c:	10c00015 	stw	r3,0(r2)
      break;
 8245e30:	00010406 	br	8246244 <ip_setmoptions+0x54c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 8245e34:	e0bffe17 	ldw	r2,-8(fp)
 8245e38:	10c00003 	ldbu	r3,0(r2)
 8245e3c:	e0bff717 	ldw	r2,-36(fp)
 8245e40:	10c00105 	stb	r3,4(r2)
      break;
 8245e44:	00010006 	br	8246248 <ip_setmoptions+0x550>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 8245e48:	e0bffe17 	ldw	r2,-8(fp)
 8245e4c:	10800003 	ldbu	r2,0(r2)
 8245e50:	10803fcc 	andi	r2,r2,255
 8245e54:	108000b0 	cmpltui	r2,r2,2
 8245e58:	1000031e 	bne	r2,zero,8245e68 <ip_setmoptions+0x170>
      {
         error = EINVAL;
 8245e5c:	00800584 	movi	r2,22
 8245e60:	e0bff515 	stw	r2,-44(fp)
         break;
 8245e64:	0000f806 	br	8246248 <ip_setmoptions+0x550>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 8245e68:	e0bffe17 	ldw	r2,-8(fp)
 8245e6c:	10c00003 	ldbu	r3,0(r2)
 8245e70:	e0bff717 	ldw	r2,-36(fp)
 8245e74:	10c00145 	stb	r3,5(r2)
      break;
 8245e78:	0000f306 	br	8246248 <ip_setmoptions+0x550>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8245e7c:	e0bffe17 	ldw	r2,-8(fp)
 8245e80:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8245e84:	e0bffa17 	ldw	r2,-24(fp)
 8245e88:	10800017 	ldw	r2,0(r2)
 8245e8c:	1006d63a 	srli	r3,r2,24
 8245e90:	e0bffa17 	ldw	r2,-24(fp)
 8245e94:	10800017 	ldw	r2,0(r2)
 8245e98:	1004d23a 	srli	r2,r2,8
 8245e9c:	10bfc00c 	andi	r2,r2,65280
 8245ea0:	1886b03a 	or	r3,r3,r2
 8245ea4:	e0bffa17 	ldw	r2,-24(fp)
 8245ea8:	10800017 	ldw	r2,0(r2)
 8245eac:	10bfc00c 	andi	r2,r2,65280
 8245eb0:	1004923a 	slli	r2,r2,8
 8245eb4:	1886b03a 	or	r3,r3,r2
 8245eb8:	e0bffa17 	ldw	r2,-24(fp)
 8245ebc:	10800017 	ldw	r2,0(r2)
 8245ec0:	1004963a 	slli	r2,r2,24
 8245ec4:	1884b03a 	or	r2,r3,r2
 8245ec8:	10fc002c 	andhi	r3,r2,61440
 8245ecc:	00b80034 	movhi	r2,57344
 8245ed0:	18800326 	beq	r3,r2,8245ee0 <ip_setmoptions+0x1e8>
      {
         error = EINVAL;
 8245ed4:	00800584 	movi	r2,22
 8245ed8:	e0bff515 	stw	r2,-44(fp)
         break;
 8245edc:	0000da06 	br	8246248 <ip_setmoptions+0x550>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 8245ee0:	e0bffa17 	ldw	r2,-24(fp)
 8245ee4:	10800117 	ldw	r2,4(r2)
 8245ee8:	e0fffb04 	addi	r3,fp,-20
 8245eec:	180b883a 	mov	r5,r3
 8245ef0:	1009883a 	mov	r4,r2
 8245ef4:	8245bc40 	call	8245bc4 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 8245ef8:	e0bffb17 	ldw	r2,-20(fp)
 8245efc:	10000326 	beq	r2,zero,8245f0c <ip_setmoptions+0x214>
 8245f00:	e0bffb17 	ldw	r2,-20(fp)
 8245f04:	10802b17 	ldw	r2,172(r2)
 8245f08:	1000031e 	bne	r2,zero,8245f18 <ip_setmoptions+0x220>
      {
         error = EADDRNOTAVAIL;
 8245f0c:	00801f44 	movi	r2,125
 8245f10:	e0bff515 	stw	r2,-44(fp)
         break;
 8245f14:	0000cc06 	br	8246248 <ip_setmoptions+0x550>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8245f18:	e03ff60d 	sth	zero,-40(fp)
 8245f1c:	00001806 	br	8245f80 <ip_setmoptions+0x288>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8245f20:	e0bff60b 	ldhu	r2,-40(fp)
 8245f24:	e0fff717 	ldw	r3,-36(fp)
 8245f28:	10800084 	addi	r2,r2,2
 8245f2c:	1085883a 	add	r2,r2,r2
 8245f30:	1085883a 	add	r2,r2,r2
 8245f34:	1885883a 	add	r2,r3,r2
 8245f38:	10800017 	ldw	r2,0(r2)
 8245f3c:	10c00117 	ldw	r3,4(r2)
 8245f40:	e0bffb17 	ldw	r2,-20(fp)
 8245f44:	18800b1e 	bne	r3,r2,8245f74 <ip_setmoptions+0x27c>
             imo->imo_membership[i]->inm_addr
 8245f48:	e0bff60b 	ldhu	r2,-40(fp)
 8245f4c:	e0fff717 	ldw	r3,-36(fp)
 8245f50:	10800084 	addi	r2,r2,2
 8245f54:	1085883a 	add	r2,r2,r2
 8245f58:	1085883a 	add	r2,r2,r2
 8245f5c:	1885883a 	add	r2,r3,r2
 8245f60:	10800017 	ldw	r2,0(r2)
 8245f64:	10c00017 	ldw	r3,0(r2)
             == mreq->imr_multiaddr)
 8245f68:	e0bffa17 	ldw	r2,-24(fp)
 8245f6c:	10800017 	ldw	r2,0(r2)
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8245f70:	18800926 	beq	r3,r2,8245f98 <ip_setmoptions+0x2a0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8245f74:	e0bff60b 	ldhu	r2,-40(fp)
 8245f78:	10800044 	addi	r2,r2,1
 8245f7c:	e0bff60d 	sth	r2,-40(fp)
 8245f80:	e0bff717 	ldw	r2,-36(fp)
 8245f84:	1080018b 	ldhu	r2,6(r2)
 8245f88:	10bfffcc 	andi	r2,r2,65535
 8245f8c:	e0fff60b 	ldhu	r3,-40(fp)
 8245f90:	18bfe336 	bltu	r3,r2,8245f20 <ip_setmoptions+0x228>
 8245f94:	00000106 	br	8245f9c <ip_setmoptions+0x2a4>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
             imo->imo_membership[i]->inm_addr
             == mreq->imr_multiaddr)
         {
            break;
 8245f98:	0001883a 	nop
         }
      }
      if (i < imo->imo_num_memberships) 
 8245f9c:	e0bff717 	ldw	r2,-36(fp)
 8245fa0:	1080018b 	ldhu	r2,6(r2)
 8245fa4:	10bfffcc 	andi	r2,r2,65535
 8245fa8:	e0fff60b 	ldhu	r3,-40(fp)
 8245fac:	1880032e 	bgeu	r3,r2,8245fbc <ip_setmoptions+0x2c4>
      {
         error = EADDRINUSE;
 8245fb0:	00801c04 	movi	r2,112
 8245fb4:	e0bff515 	stw	r2,-44(fp)
         break;
 8245fb8:	0000a306 	br	8246248 <ip_setmoptions+0x550>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 8245fbc:	e0bff60b 	ldhu	r2,-40(fp)
 8245fc0:	10800518 	cmpnei	r2,r2,20
 8245fc4:	1000031e 	bne	r2,zero,8245fd4 <ip_setmoptions+0x2dc>
      {
         error = ETOOMANYREFS;
 8245fc8:	00802044 	movi	r2,129
 8245fcc:	e0bff515 	stw	r2,-44(fp)
         break;
 8245fd0:	00009d06 	br	8246248 <ip_setmoptions+0x550>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 8245fd4:	e43ff60b 	ldhu	r16,-40(fp)
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
 8245fd8:	e0bffa17 	ldw	r2,-24(fp)
 8245fdc:	e0fffb17 	ldw	r3,-20(fp)
 8245fe0:	01800104 	movi	r6,4
 8245fe4:	180b883a 	mov	r5,r3
 8245fe8:	1009883a 	mov	r4,r2
 8245fec:	824369c0 	call	824369c <in_addmulti>
 8245ff0:	1009883a 	mov	r4,r2
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 8245ff4:	e0fff717 	ldw	r3,-36(fp)
 8245ff8:	80800084 	addi	r2,r16,2
 8245ffc:	1085883a 	add	r2,r2,r2
 8246000:	1085883a 	add	r2,r2,r2
 8246004:	1885883a 	add	r2,r3,r2
 8246008:	11000015 	stw	r4,0(r2)
 824600c:	e0fff717 	ldw	r3,-36(fp)
 8246010:	80800084 	addi	r2,r16,2
 8246014:	1085883a 	add	r2,r2,r2
 8246018:	1085883a 	add	r2,r2,r2
 824601c:	1885883a 	add	r2,r3,r2
 8246020:	10800017 	ldw	r2,0(r2)
 8246024:	1000031e 	bne	r2,zero,8246034 <ip_setmoptions+0x33c>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 8246028:	00801a44 	movi	r2,105
 824602c:	e0bff515 	stw	r2,-44(fp)
         break;
 8246030:	00008506 	br	8246248 <ip_setmoptions+0x550>
      }
      ++imo->imo_num_memberships;
 8246034:	e0bff717 	ldw	r2,-36(fp)
 8246038:	1080018b 	ldhu	r2,6(r2)
 824603c:	10800044 	addi	r2,r2,1
 8246040:	1007883a 	mov	r3,r2
 8246044:	e0bff717 	ldw	r2,-36(fp)
 8246048:	10c0018d 	sth	r3,6(r2)
      break;
 824604c:	00007e06 	br	8246248 <ip_setmoptions+0x550>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8246050:	e0bffe17 	ldw	r2,-8(fp)
 8246054:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8246058:	e0bffa17 	ldw	r2,-24(fp)
 824605c:	10800017 	ldw	r2,0(r2)
 8246060:	1006d63a 	srli	r3,r2,24
 8246064:	e0bffa17 	ldw	r2,-24(fp)
 8246068:	10800017 	ldw	r2,0(r2)
 824606c:	1004d23a 	srli	r2,r2,8
 8246070:	10bfc00c 	andi	r2,r2,65280
 8246074:	1886b03a 	or	r3,r3,r2
 8246078:	e0bffa17 	ldw	r2,-24(fp)
 824607c:	10800017 	ldw	r2,0(r2)
 8246080:	10bfc00c 	andi	r2,r2,65280
 8246084:	1004923a 	slli	r2,r2,8
 8246088:	1886b03a 	or	r3,r3,r2
 824608c:	e0bffa17 	ldw	r2,-24(fp)
 8246090:	10800017 	ldw	r2,0(r2)
 8246094:	1004963a 	slli	r2,r2,24
 8246098:	1884b03a 	or	r2,r3,r2
 824609c:	10fc002c 	andhi	r3,r2,61440
 82460a0:	00b80034 	movhi	r2,57344
 82460a4:	18800326 	beq	r3,r2,82460b4 <ip_setmoptions+0x3bc>
      {
         error = EINVAL;
 82460a8:	00800584 	movi	r2,22
 82460ac:	e0bff515 	stw	r2,-44(fp)
         break;
 82460b0:	00006506 	br	8246248 <ip_setmoptions+0x550>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 82460b4:	e0bffa17 	ldw	r2,-24(fp)
 82460b8:	10800117 	ldw	r2,4(r2)
 82460bc:	e0fffb04 	addi	r3,fp,-20
 82460c0:	180b883a 	mov	r5,r3
 82460c4:	1009883a 	mov	r4,r2
 82460c8:	8245bc40 	call	8245bc4 <IPADDR_TO_NETP>
      if (netp == NULL) 
 82460cc:	e0bffb17 	ldw	r2,-20(fp)
 82460d0:	1000031e 	bne	r2,zero,82460e0 <ip_setmoptions+0x3e8>
      {
         error = EADDRNOTAVAIL;
 82460d4:	00801f44 	movi	r2,125
 82460d8:	e0bff515 	stw	r2,-44(fp)
         break;
 82460dc:	00005a06 	br	8246248 <ip_setmoptions+0x550>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 82460e0:	e03ff60d 	sth	zero,-40(fp)
 82460e4:	00001a06 	br	8246150 <ip_setmoptions+0x458>
      {
         if ((netp == NULL ||
 82460e8:	e0bffb17 	ldw	r2,-20(fp)
 82460ec:	10000a26 	beq	r2,zero,8246118 <ip_setmoptions+0x420>
             imo->imo_membership[i]->inm_netp == netp) &&
 82460f0:	e0bff60b 	ldhu	r2,-40(fp)
 82460f4:	e0fff717 	ldw	r3,-36(fp)
 82460f8:	10800084 	addi	r2,r2,2
 82460fc:	1085883a 	add	r2,r2,r2
 8246100:	1085883a 	add	r2,r2,r2
 8246104:	1885883a 	add	r2,r3,r2
 8246108:	10800017 	ldw	r2,0(r2)
 824610c:	10c00117 	ldw	r3,4(r2)
 8246110:	e0bffb17 	ldw	r2,-20(fp)
      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
 8246114:	18800b1e 	bne	r3,r2,8246144 <ip_setmoptions+0x44c>
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
 8246118:	e0bff60b 	ldhu	r2,-40(fp)
 824611c:	e0fff717 	ldw	r3,-36(fp)
 8246120:	10800084 	addi	r2,r2,2
 8246124:	1085883a 	add	r2,r2,r2
 8246128:	1085883a 	add	r2,r2,r2
 824612c:	1885883a 	add	r2,r3,r2
 8246130:	10800017 	ldw	r2,0(r2)
 8246134:	10c00017 	ldw	r3,0(r2)
             mreq->imr_multiaddr)
 8246138:	e0bffa17 	ldw	r2,-24(fp)
 824613c:	10800017 	ldw	r2,0(r2)
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
 8246140:	18800926 	beq	r3,r2,8246168 <ip_setmoptions+0x470>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246144:	e0bff60b 	ldhu	r2,-40(fp)
 8246148:	10800044 	addi	r2,r2,1
 824614c:	e0bff60d 	sth	r2,-40(fp)
 8246150:	e0bff717 	ldw	r2,-36(fp)
 8246154:	1080018b 	ldhu	r2,6(r2)
 8246158:	10bfffcc 	andi	r2,r2,65535
 824615c:	e0fff60b 	ldhu	r3,-40(fp)
 8246160:	18bfe136 	bltu	r3,r2,82460e8 <ip_setmoptions+0x3f0>
 8246164:	00000106 	br	824616c <ip_setmoptions+0x474>
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
             mreq->imr_multiaddr)
         {
            break;
 8246168:	0001883a 	nop
         }
      }
      if (i == imo->imo_num_memberships) 
 824616c:	e0bff717 	ldw	r2,-36(fp)
 8246170:	1080018b 	ldhu	r2,6(r2)
 8246174:	10ffffcc 	andi	r3,r2,65535
 8246178:	e0bff60b 	ldhu	r2,-40(fp)
 824617c:	1880031e 	bne	r3,r2,824618c <ip_setmoptions+0x494>
      {
         error = EADDRNOTAVAIL;
 8246180:	00801f44 	movi	r2,125
 8246184:	e0bff515 	stw	r2,-44(fp)
         break;
 8246188:	00002f06 	br	8246248 <ip_setmoptions+0x550>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 824618c:	e0bff60b 	ldhu	r2,-40(fp)
 8246190:	e0fff717 	ldw	r3,-36(fp)
 8246194:	10800084 	addi	r2,r2,2
 8246198:	1085883a 	add	r2,r2,r2
 824619c:	1085883a 	add	r2,r2,r2
 82461a0:	1885883a 	add	r2,r3,r2
 82461a4:	10800017 	ldw	r2,0(r2)
 82461a8:	1009883a 	mov	r4,r2
 82461ac:	82437e80 	call	82437e8 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 82461b0:	e0bff60b 	ldhu	r2,-40(fp)
 82461b4:	10800044 	addi	r2,r2,1
 82461b8:	e0bff60d 	sth	r2,-40(fp)
 82461bc:	00001206 	br	8246208 <ip_setmoptions+0x510>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 82461c0:	e0bff60b 	ldhu	r2,-40(fp)
 82461c4:	117fffc4 	addi	r5,r2,-1
 82461c8:	e0bff60b 	ldhu	r2,-40(fp)
 82461cc:	e0fff717 	ldw	r3,-36(fp)
 82461d0:	10800084 	addi	r2,r2,2
 82461d4:	1085883a 	add	r2,r2,r2
 82461d8:	1085883a 	add	r2,r2,r2
 82461dc:	1885883a 	add	r2,r3,r2
 82461e0:	10c00017 	ldw	r3,0(r2)
 82461e4:	e13ff717 	ldw	r4,-36(fp)
 82461e8:	28800084 	addi	r2,r5,2
 82461ec:	1085883a 	add	r2,r2,r2
 82461f0:	1085883a 	add	r2,r2,r2
 82461f4:	2085883a 	add	r2,r4,r2
 82461f8:	10c00015 	stw	r3,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 82461fc:	e0bff60b 	ldhu	r2,-40(fp)
 8246200:	10800044 	addi	r2,r2,1
 8246204:	e0bff60d 	sth	r2,-40(fp)
 8246208:	e0bff717 	ldw	r2,-36(fp)
 824620c:	1080018b 	ldhu	r2,6(r2)
 8246210:	10bfffcc 	andi	r2,r2,65535
 8246214:	e0fff60b 	ldhu	r3,-40(fp)
 8246218:	18bfe936 	bltu	r3,r2,82461c0 <ip_setmoptions+0x4c8>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 824621c:	e0bff717 	ldw	r2,-36(fp)
 8246220:	1080018b 	ldhu	r2,6(r2)
 8246224:	10bfffc4 	addi	r2,r2,-1
 8246228:	1007883a 	mov	r3,r2
 824622c:	e0bff717 	ldw	r2,-36(fp)
 8246230:	10c0018d 	sth	r3,6(r2)
      break;
 8246234:	00000406 	br	8246248 <ip_setmoptions+0x550>

      default:
      error = EOPNOTSUPP;
 8246238:	008017c4 	movi	r2,95
 824623c:	e0bff515 	stw	r2,-44(fp)
      break;
 8246240:	00000106 	br	8246248 <ip_setmoptions+0x550>
         error = EADDRNOTAVAIL;
         break;
      }
      if (addr != AADDR) 
         imo->imo_multicast_netp = netp;
      break;
 8246244:	0001883a 	nop
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 8246248:	e0bff717 	ldw	r2,-36(fp)
 824624c:	10800017 	ldw	r2,0(r2)
 8246250:	1000141e 	bne	r2,zero,82462a4 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246254:	e0bff717 	ldw	r2,-36(fp)
 8246258:	10800103 	ldbu	r2,4(r2)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 824625c:	10803fcc 	andi	r2,r2,255
 8246260:	10800058 	cmpnei	r2,r2,1
 8246264:	10000f1e 	bne	r2,zero,82462a4 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246268:	e0bff717 	ldw	r2,-36(fp)
 824626c:	10800143 	ldbu	r2,5(r2)

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246270:	10803fcc 	andi	r2,r2,255
 8246274:	10800058 	cmpnei	r2,r2,1
 8246278:	10000a1e 	bne	r2,zero,82462a4 <ip_setmoptions+0x5ac>
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
 824627c:	e0bff717 	ldw	r2,-36(fp)
 8246280:	1080018b 	ldhu	r2,6(r2)
      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246284:	10bfffcc 	andi	r2,r2,65535
 8246288:	1000061e 	bne	r2,zero,82462a4 <ip_setmoptions+0x5ac>
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 824628c:	e0bff817 	ldw	r2,-32(fp)
 8246290:	10800017 	ldw	r2,0(r2)
 8246294:	1009883a 	mov	r4,r2
 8246298:	822deec0 	call	822deec <npfree>
      *imop = NULL;
 824629c:	e0bff817 	ldw	r2,-32(fp)
 82462a0:	10000015 	stw	zero,0(r2)
   }
   return (error);
 82462a4:	e0bff517 	ldw	r2,-44(fp)
}
 82462a8:	e6ffff04 	addi	sp,fp,-4
 82462ac:	dfc00217 	ldw	ra,8(sp)
 82462b0:	df000117 	ldw	fp,4(sp)
 82462b4:	dc000017 	ldw	r16,0(sp)
 82462b8:	dec00304 	addi	sp,sp,12
 82462bc:	f800283a 	ret

082462c0 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 82462c0:	defff804 	addi	sp,sp,-32
 82462c4:	df000715 	stw	fp,28(sp)
 82462c8:	df000704 	addi	fp,sp,28
 82462cc:	e13ffd15 	stw	r4,-12(fp)
 82462d0:	e17ffe15 	stw	r5,-8(fp)
 82462d4:	e1bfff15 	stw	r6,-4(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 82462d8:	e0bffe17 	ldw	r2,-8(fp)
 82462dc:	10800317 	ldw	r2,12(r2)
 82462e0:	e0bff915 	stw	r2,-28(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 82462e4:	e0bffd17 	ldw	r2,-12(fp)
 82462e8:	10c002a0 	cmpeqi	r3,r2,10
 82462ec:	1800151e 	bne	r3,zero,8246344 <ip_getmoptions+0x84>
 82462f0:	10c002e0 	cmpeqi	r3,r2,11
 82462f4:	1800211e 	bne	r3,zero,824637c <ip_getmoptions+0xbc>
 82462f8:	10800260 	cmpeqi	r2,r2,9
 82462fc:	10002d26 	beq	r2,zero,82463b4 <ip_getmoptions+0xf4>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 8246300:	e0bfff17 	ldw	r2,-4(fp)
 8246304:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 8246308:	e0bff917 	ldw	r2,-28(fp)
 824630c:	10000326 	beq	r2,zero,824631c <ip_getmoptions+0x5c>
 8246310:	e0bff917 	ldw	r2,-28(fp)
 8246314:	10800017 	ldw	r2,0(r2)
 8246318:	1000031e 	bne	r2,zero,8246328 <ip_getmoptions+0x68>
         *addr = AADDR;
 824631c:	e0bffa17 	ldw	r2,-24(fp)
 8246320:	10000015 	stw	zero,0(r2)
 8246324:	00000506 	br	824633c <ip_getmoptions+0x7c>
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 8246328:	e0bff917 	ldw	r2,-28(fp)
 824632c:	10800017 	ldw	r2,0(r2)
 8246330:	10c00a17 	ldw	r3,40(r2)
 8246334:	e0bffa17 	ldw	r2,-24(fp)
 8246338:	10c00015 	stw	r3,0(r2)
      return (0);
 824633c:	0005883a 	mov	r2,zero
 8246340:	00001d06 	br	82463b8 <ip_getmoptions+0xf8>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 8246344:	e0bfff17 	ldw	r2,-4(fp)
 8246348:	e0bffb15 	stw	r2,-20(fp)
      if (imo == NULL)
 824634c:	e0bff917 	ldw	r2,-28(fp)
 8246350:	1000041e 	bne	r2,zero,8246364 <ip_getmoptions+0xa4>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 8246354:	e0bffb17 	ldw	r2,-20(fp)
 8246358:	00c00044 	movi	r3,1
 824635c:	10c00005 	stb	r3,0(r2)
 8246360:	00000406 	br	8246374 <ip_getmoptions+0xb4>
      else
         *ttl = imo->imo_multicast_ttl;
 8246364:	e0bff917 	ldw	r2,-28(fp)
 8246368:	10c00103 	ldbu	r3,4(r2)
 824636c:	e0bffb17 	ldw	r2,-20(fp)
 8246370:	10c00005 	stb	r3,0(r2)
      return (0);
 8246374:	0005883a 	mov	r2,zero
 8246378:	00000f06 	br	82463b8 <ip_getmoptions+0xf8>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 824637c:	e0bfff17 	ldw	r2,-4(fp)
 8246380:	e0bffc15 	stw	r2,-16(fp)
      if (imo == NULL)
 8246384:	e0bff917 	ldw	r2,-28(fp)
 8246388:	1000041e 	bne	r2,zero,824639c <ip_getmoptions+0xdc>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 824638c:	e0bffc17 	ldw	r2,-16(fp)
 8246390:	00c00044 	movi	r3,1
 8246394:	10c00005 	stb	r3,0(r2)
 8246398:	00000406 	br	82463ac <ip_getmoptions+0xec>
      else
         *loop = imo->imo_multicast_loop;
 824639c:	e0bff917 	ldw	r2,-28(fp)
 82463a0:	10c00143 	ldbu	r3,5(r2)
 82463a4:	e0bffc17 	ldw	r2,-16(fp)
 82463a8:	10c00005 	stb	r3,0(r2)
      return (0);
 82463ac:	0005883a 	mov	r2,zero
 82463b0:	00000106 	br	82463b8 <ip_getmoptions+0xf8>

      default:
      return (EOPNOTSUPP);
 82463b4:	008017c4 	movi	r2,95
   }
}
 82463b8:	e037883a 	mov	sp,fp
 82463bc:	df000017 	ldw	fp,0(sp)
 82463c0:	dec00104 	addi	sp,sp,4
 82463c4:	f800283a 	ret

082463c8 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 82463c8:	defffc04 	addi	sp,sp,-16
 82463cc:	dfc00315 	stw	ra,12(sp)
 82463d0:	df000215 	stw	fp,8(sp)
 82463d4:	df000204 	addi	fp,sp,8
 82463d8:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 82463dc:	e0bfff17 	ldw	r2,-4(fp)
 82463e0:	10001526 	beq	r2,zero,8246438 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 82463e4:	e03ffe0d 	sth	zero,-8(fp)
 82463e8:	00000c06 	br	824641c <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 82463ec:	e0bffe0b 	ldhu	r2,-8(fp)
 82463f0:	e0ffff17 	ldw	r3,-4(fp)
 82463f4:	10800084 	addi	r2,r2,2
 82463f8:	1085883a 	add	r2,r2,r2
 82463fc:	1085883a 	add	r2,r2,r2
 8246400:	1885883a 	add	r2,r3,r2
 8246404:	10800017 	ldw	r2,0(r2)
 8246408:	1009883a 	mov	r4,r2
 824640c:	82437e80 	call	82437e8 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 8246410:	e0bffe0b 	ldhu	r2,-8(fp)
 8246414:	10800044 	addi	r2,r2,1
 8246418:	e0bffe0d 	sth	r2,-8(fp)
 824641c:	e0bfff17 	ldw	r2,-4(fp)
 8246420:	1080018b 	ldhu	r2,6(r2)
 8246424:	10bfffcc 	andi	r2,r2,65535
 8246428:	e0fffe0b 	ldhu	r3,-8(fp)
 824642c:	18bfef36 	bltu	r3,r2,82463ec <ip_freemoptions+0x24>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 8246430:	e13fff17 	ldw	r4,-4(fp)
 8246434:	822deec0 	call	822deec <npfree>
   }
}
 8246438:	0001883a 	nop
 824643c:	e037883a 	mov	sp,fp
 8246440:	dfc00117 	ldw	ra,4(sp)
 8246444:	df000017 	ldw	fp,0(sp)
 8246448:	dec00204 	addi	sp,sp,8
 824644c:	f800283a 	ret

08246450 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 8246450:	defffe04 	addi	sp,sp,-8
 8246454:	dfc00115 	stw	ra,4(sp)
 8246458:	df000015 	stw	fp,0(sp)
 824645c:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 8246460:	01020974 	movhi	r4,2085
 8246464:	2104ef04 	addi	r4,r4,5052
 8246468:	82033700 	call	8203370 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 824646c:	0001883a 	nop
 8246470:	e037883a 	mov	sp,fp
 8246474:	dfc00117 	ldw	ra,4(sp)
 8246478:	df000017 	ldw	fp,0(sp)
 824647c:	dec00204 	addi	sp,sp,8
 8246480:	f800283a 	ret

08246484 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 8246484:	defede04 	addi	sp,sp,-1160
 8246488:	dfc12115 	stw	ra,1156(sp)
 824648c:	df012015 	stw	fp,1152(sp)
 8246490:	df012004 	addi	fp,sp,1152
 8246494:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 8246498:	009cdcf4 	movhi	r2,29555
 824649c:	10995344 	addi	r2,r2,25933
 82464a0:	e0bff215 	stw	r2,-56(fp)
 82464a4:	00881974 	movhi	r2,8293
 82464a8:	1099d844 	addi	r2,r2,26465
 82464ac:	e0bff315 	stw	r2,-52(fp)
 82464b0:	00989b74 	movhi	r2,25197
 82464b4:	109d5b84 	addi	r2,r2,30062
 82464b8:	e0bff415 	stw	r2,-48(fp)
 82464bc:	00880eb4 	movhi	r2,8250
 82464c0:	109c9944 	addi	r2,r2,29285
 82464c4:	e0bff515 	stw	r2,-44(fp)
 82464c8:	00880834 	movhi	r2,8224
 82464cc:	10880804 	addi	r2,r2,8224
 82464d0:	e0bff615 	stw	r2,-40(fp)
 82464d4:	00880834 	movhi	r2,8224
 82464d8:	10880804 	addi	r2,r2,8224
 82464dc:	e0bff715 	stw	r2,-36(fp)
 82464e0:	00880834 	movhi	r2,8224
 82464e4:	10880804 	addi	r2,r2,8224
 82464e8:	e0bff815 	stw	r2,-32(fp)
 82464ec:	00800804 	movi	r2,32
 82464f0:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 82464f4:	000d883a 	mov	r6,zero
 82464f8:	01400084 	movi	r5,2
 82464fc:	01000084 	movi	r4,2
 8246500:	823017c0 	call	823017c <t_socket>
 8246504:	e0bee315 	stw	r2,-1140(fp)

   if (s == INVALID_SOCKET) 
 8246508:	e0bee317 	ldw	r2,-1140(fp)
 824650c:	10bfffd8 	cmpnei	r2,r2,-1
 8246510:	1000091e 	bne	r2,zero,8246538 <u_mctest_run+0xb4>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 8246514:	e13ee317 	ldw	r4,-1140(fp)
 8246518:	82316e80 	call	82316e8 <t_errno>
 824651c:	100d883a 	mov	r6,r2
 8246520:	01420974 	movhi	r5,2085
 8246524:	2944f404 	addi	r5,r5,5072
 8246528:	e13fff17 	ldw	r4,-4(fp)
 824652c:	8228bac0 	call	8228bac <ns_printf>
      exit(1);
 8246530:	01000044 	movi	r4,1
 8246534:	824b3a40 	call	824b3a4 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 8246538:	00800044 	movi	r2,1
 824653c:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 8246540:	e0fffa04 	addi	r3,fp,-24
 8246544:	00800104 	movi	r2,4
 8246548:	d8800015 	stw	r2,0(sp)
 824654c:	180f883a 	mov	r7,r3
 8246550:	01800104 	movi	r6,4
 8246554:	017fffc4 	movi	r5,-1
 8246558:	e13ee317 	ldw	r4,-1140(fp)
 824655c:	8230b5c0 	call	8230b5c <t_setsockopt>
 8246560:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246564:	e0bee417 	ldw	r2,-1136(fp)
 8246568:	10bfffd8 	cmpnei	r2,r2,-1
 824656c:	1000071e 	bne	r2,zero,824658c <u_mctest_run+0x108>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 8246570:	e13ee317 	ldw	r4,-1140(fp)
 8246574:	82316e80 	call	82316e8 <t_errno>
 8246578:	100d883a 	mov	r6,r2
 824657c:	01420974 	movhi	r5,2085
 8246580:	2944fb04 	addi	r5,r5,5100
 8246584:	e13fff17 	ldw	r4,-4(fp)
 8246588:	8228bac0 	call	8228bac <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 824658c:	00800084 	movi	r2,2
 8246590:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 8246594:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 8246598:	00a00344 	movi	r2,-32755
 824659c:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 82465a0:	e0bee604 	addi	r2,fp,-1128
 82465a4:	01800404 	movi	r6,16
 82465a8:	100b883a 	mov	r5,r2
 82465ac:	e13ee317 	ldw	r4,-1140(fp)
 82465b0:	82301fc0 	call	82301fc <t_bind>
 82465b4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82465b8:	e0bee417 	ldw	r2,-1136(fp)
 82465bc:	10bfffd8 	cmpnei	r2,r2,-1
 82465c0:	1000061e 	bne	r2,zero,82465dc <u_mctest_run+0x158>
   {
      printf ("t_bind() failed, Err: %d\n",
 82465c4:	e13ee317 	ldw	r4,-1140(fp)
 82465c8:	82316e80 	call	82316e8 <t_errno>
 82465cc:	100b883a 	mov	r5,r2
 82465d0:	01020974 	movhi	r4,2085
 82465d4:	21050704 	addi	r4,r4,5148
 82465d8:	82030ec0 	call	82030ec <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 82465dc:	01820974 	movhi	r6,2085
 82465e0:	31850e04 	addi	r6,r6,5176
 82465e4:	01420974 	movhi	r5,2085
 82465e8:	29451104 	addi	r5,r5,5188
 82465ec:	e13fff17 	ldw	r4,-4(fp)
 82465f0:	8228bac0 	call	8228bac <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 82465f4:	01020974 	movhi	r4,2085
 82465f8:	21050e04 	addi	r4,r4,5176
 82465fc:	82475600 	call	8247560 <inet_addr>
 8246600:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246604:	008209b4 	movhi	r2,2086
 8246608:	10b67a04 	addi	r2,r2,-9752
 824660c:	10800a17 	ldw	r2,40(r2)
 8246610:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 8246614:	e0fffb04 	addi	r3,fp,-20
 8246618:	00800204 	movi	r2,8
 824661c:	d8800015 	stw	r2,0(sp)
 8246620:	180f883a 	mov	r7,r3
 8246624:	01800304 	movi	r6,12
 8246628:	000b883a 	mov	r5,zero
 824662c:	e13ee317 	ldw	r4,-1140(fp)
 8246630:	8230b5c0 	call	8230b5c <t_setsockopt>
 8246634:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246638:	e0bee417 	ldw	r2,-1136(fp)
 824663c:	10bfffd8 	cmpnei	r2,r2,-1
 8246640:	1000071e 	bne	r2,zero,8246660 <u_mctest_run+0x1dc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246644:	e13ee317 	ldw	r4,-1140(fp)
 8246648:	82316e80 	call	82316e8 <t_errno>
 824664c:	100d883a 	mov	r6,r2
 8246650:	01420974 	movhi	r5,2085
 8246654:	29451904 	addi	r5,r5,5220
 8246658:	e13fff17 	ldw	r4,-4(fp)
 824665c:	8228bac0 	call	8228bac <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 8246660:	82295580 	call	8229558 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 8246664:	01820974 	movhi	r6,2085
 8246668:	31852604 	addi	r6,r6,5272
 824666c:	01420974 	movhi	r5,2085
 8246670:	29451104 	addi	r5,r5,5188
 8246674:	e13fff17 	ldw	r4,-4(fp)
 8246678:	8228bac0 	call	8228bac <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 824667c:	01020974 	movhi	r4,2085
 8246680:	21052604 	addi	r4,r4,5272
 8246684:	82475600 	call	8247560 <inet_addr>
 8246688:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 824668c:	008209b4 	movhi	r2,2086
 8246690:	10b67a04 	addi	r2,r2,-9752
 8246694:	10800a17 	ldw	r2,40(r2)
 8246698:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 824669c:	e0fffb04 	addi	r3,fp,-20
 82466a0:	00800204 	movi	r2,8
 82466a4:	d8800015 	stw	r2,0(sp)
 82466a8:	180f883a 	mov	r7,r3
 82466ac:	01800304 	movi	r6,12
 82466b0:	000b883a 	mov	r5,zero
 82466b4:	e13ee317 	ldw	r4,-1140(fp)
 82466b8:	8230b5c0 	call	8230b5c <t_setsockopt>
 82466bc:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 82466c0:	e0bee417 	ldw	r2,-1136(fp)
 82466c4:	10bfffd8 	cmpnei	r2,r2,-1
 82466c8:	1000071e 	bne	r2,zero,82466e8 <u_mctest_run+0x264>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 82466cc:	e13ee317 	ldw	r4,-1140(fp)
 82466d0:	82316e80 	call	82316e8 <t_errno>
 82466d4:	100d883a 	mov	r6,r2
 82466d8:	01420974 	movhi	r5,2085
 82466dc:	29451904 	addi	r5,r5,5220
 82466e0:	e13fff17 	ldw	r4,-4(fp)
 82466e4:	8228bac0 	call	8228bac <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 82466e8:	82295580 	call	8229558 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 82466ec:	01820974 	movhi	r6,2085
 82466f0:	31852904 	addi	r6,r6,5284
 82466f4:	01420974 	movhi	r5,2085
 82466f8:	29451104 	addi	r5,r5,5188
 82466fc:	e13fff17 	ldw	r4,-4(fp)
 8246700:	8228bac0 	call	8228bac <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 8246704:	01020974 	movhi	r4,2085
 8246708:	21052904 	addi	r4,r4,5284
 824670c:	82475600 	call	8247560 <inet_addr>
 8246710:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246714:	008209b4 	movhi	r2,2086
 8246718:	10b67a04 	addi	r2,r2,-9752
 824671c:	10800a17 	ldw	r2,40(r2)
 8246720:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 8246724:	e0fffb04 	addi	r3,fp,-20
 8246728:	00800204 	movi	r2,8
 824672c:	d8800015 	stw	r2,0(sp)
 8246730:	180f883a 	mov	r7,r3
 8246734:	01800304 	movi	r6,12
 8246738:	000b883a 	mov	r5,zero
 824673c:	e13ee317 	ldw	r4,-1140(fp)
 8246740:	8230b5c0 	call	8230b5c <t_setsockopt>
 8246744:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246748:	e0bee417 	ldw	r2,-1136(fp)
 824674c:	10bfffd8 	cmpnei	r2,r2,-1
 8246750:	1000071e 	bne	r2,zero,8246770 <u_mctest_run+0x2ec>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246754:	e13ee317 	ldw	r4,-1140(fp)
 8246758:	82316e80 	call	82316e8 <t_errno>
 824675c:	100d883a 	mov	r6,r2
 8246760:	01420974 	movhi	r5,2085
 8246764:	29451904 	addi	r5,r5,5220
 8246768:	e13fff17 	ldw	r4,-4(fp)
 824676c:	8228bac0 	call	8228bac <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 8246770:	82295580 	call	8229558 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 8246774:	00800084 	movi	r2,2
 8246778:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 824677c:	e0fffd04 	addi	r3,fp,-12
 8246780:	00800044 	movi	r2,1
 8246784:	d8800015 	stw	r2,0(sp)
 8246788:	180f883a 	mov	r7,r3
 824678c:	01800284 	movi	r6,10
 8246790:	000b883a 	mov	r5,zero
 8246794:	e13ee317 	ldw	r4,-1140(fp)
 8246798:	8230b5c0 	call	8230b5c <t_setsockopt>
 824679c:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82467a0:	e0bee417 	ldw	r2,-1136(fp)
 82467a4:	10bfffd8 	cmpnei	r2,r2,-1
 82467a8:	1000071e 	bne	r2,zero,82467c8 <u_mctest_run+0x344>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 82467ac:	e13ee317 	ldw	r4,-1140(fp)
 82467b0:	82316e80 	call	82316e8 <t_errno>
 82467b4:	100d883a 	mov	r6,r2
 82467b8:	01420974 	movhi	r5,2085
 82467bc:	29452c04 	addi	r5,r5,5296
 82467c0:	e13fff17 	ldw	r4,-4(fp)
 82467c4:	8228bac0 	call	8228bac <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 82467c8:	00800044 	movi	r2,1
 82467cc:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 82467d0:	e0fffd04 	addi	r3,fp,-12
 82467d4:	00800044 	movi	r2,1
 82467d8:	d8800015 	stw	r2,0(sp)
 82467dc:	180f883a 	mov	r7,r3
 82467e0:	018002c4 	movi	r6,11
 82467e4:	000b883a 	mov	r5,zero
 82467e8:	e13ee317 	ldw	r4,-1140(fp)
 82467ec:	8230b5c0 	call	8230b5c <t_setsockopt>
 82467f0:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82467f4:	e0bee417 	ldw	r2,-1136(fp)
 82467f8:	10bfffd8 	cmpnei	r2,r2,-1
 82467fc:	1000071e 	bne	r2,zero,824681c <u_mctest_run+0x398>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 8246800:	e13ee317 	ldw	r4,-1140(fp)
 8246804:	82316e80 	call	82316e8 <t_errno>
 8246808:	100d883a 	mov	r6,r2
 824680c:	01420974 	movhi	r5,2085
 8246810:	29453904 	addi	r5,r5,5348
 8246814:	e13fff17 	ldw	r4,-4(fp)
 8246818:	8228bac0 	call	8228bac <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 824681c:	00800084 	movi	r2,2
 8246820:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 8246824:	01020974 	movhi	r4,2085
 8246828:	21052604 	addi	r4,r4,5272
 824682c:	82475600 	call	8247560 <inet_addr>
 8246830:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 8246834:	00a00344 	movi	r2,-32755
 8246838:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 824683c:	01820974 	movhi	r6,2085
 8246840:	31852604 	addi	r6,r6,5272
 8246844:	01420974 	movhi	r5,2085
 8246848:	29454604 	addi	r5,r5,5400
 824684c:	e13fff17 	ldw	r4,-4(fp)
 8246850:	8228bac0 	call	8228bac <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246854:	e03ee215 	stw	zero,-1144(fp)
 8246858:	00008606 	br	8246a74 <u_mctest_run+0x5f0>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 824685c:	d0a05217 	ldw	r2,-32440(gp)
 8246860:	10c00044 	addi	r3,r2,1
 8246864:	d0e05215 	stw	r3,-32440(gp)
 8246868:	e0fff204 	addi	r3,fp,-56
 824686c:	18c00404 	addi	r3,r3,16
 8246870:	100d883a 	mov	r6,r2
 8246874:	01420974 	movhi	r5,2085
 8246878:	29455504 	addi	r5,r5,5460
 824687c:	1809883a 	mov	r4,r3
 8246880:	82034640 	call	8203464 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 8246884:	e0fff204 	addi	r3,fp,-56
 8246888:	00800404 	movi	r2,16
 824688c:	d8800115 	stw	r2,4(sp)
 8246890:	e0beea04 	addi	r2,fp,-1112
 8246894:	d8800015 	stw	r2,0(sp)
 8246898:	000f883a 	mov	r7,zero
 824689c:	01800784 	movi	r6,30
 82468a0:	180b883a 	mov	r5,r3
 82468a4:	e13ee317 	ldw	r4,-1140(fp)
 82468a8:	82310c80 	call	82310c8 <t_sendto>
 82468ac:	e0bee415 	stw	r2,-1136(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 82468b0:	e0bee417 	ldw	r2,-1136(fp)
 82468b4:	1000080e 	bge	r2,zero,82468d8 <u_mctest_run+0x454>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 82468b8:	e13ee317 	ldw	r4,-1140(fp)
 82468bc:	82316e80 	call	82316e8 <t_errno>
 82468c0:	100d883a 	mov	r6,r2
 82468c4:	01420974 	movhi	r5,2085
 82468c8:	29455604 	addi	r5,r5,5464
 82468cc:	e13fff17 	ldw	r4,-4(fp)
 82468d0:	8228bac0 	call	8228bac <ns_printf>
         /*     exit(1); */
         goto exitloop;
 82468d4:	00006a06 	br	8246a80 <u_mctest_run+0x5fc>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 82468d8:	00800044 	movi	r2,1
 82468dc:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 82468e0:	e0fffa04 	addi	r3,fp,-24
 82468e4:	00800104 	movi	r2,4
 82468e8:	d8800015 	stw	r2,0(sp)
 82468ec:	180f883a 	mov	r7,r3
 82468f0:	01840584 	movi	r6,4118
 82468f4:	017fffc4 	movi	r5,-1
 82468f8:	e13ee317 	ldw	r4,-1140(fp)
 82468fc:	8230b5c0 	call	8230b5c <t_setsockopt>
 8246900:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246904:	e0bee417 	ldw	r2,-1136(fp)
 8246908:	10bfffd8 	cmpnei	r2,r2,-1
 824690c:	1000071e 	bne	r2,zero,824692c <u_mctest_run+0x4a8>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 8246910:	e13ee317 	ldw	r4,-1140(fp)
 8246914:	82316e80 	call	82316e8 <t_errno>
 8246918:	100d883a 	mov	r6,r2
 824691c:	01420974 	movhi	r5,2085
 8246920:	29455e04 	addi	r5,r5,5496
 8246924:	e13fff17 	ldw	r4,-4(fp)
 8246928:	8228bac0 	call	8228bac <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 824692c:	d0a0a817 	ldw	r2,-32096(gp)
 8246930:	10807d04 	addi	r2,r2,500
 8246934:	e0bee515 	stw	r2,-1132(fp)

      while (cticks < endtime)
 8246938:	00003406 	br	8246a0c <u_mctest_run+0x588>
      {
         int sa_size = sizeof(struct sockaddr_in);
 824693c:	00800404 	movi	r2,16
 8246940:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 8246944:	82295580 	call	8229558 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 8246948:	e0fef204 	addi	r3,fp,-1080
 824694c:	e0bffe04 	addi	r2,fp,-8
 8246950:	d8800115 	stw	r2,4(sp)
 8246954:	e0beee04 	addi	r2,fp,-1096
 8246958:	d8800015 	stw	r2,0(sp)
 824695c:	000f883a 	mov	r7,zero
 8246960:	01810004 	movi	r6,1024
 8246964:	180b883a 	mov	r5,r3
 8246968:	e13ee317 	ldw	r4,-1140(fp)
 824696c:	8230f880 	call	8230f88 <t_recvfrom>
 8246970:	e0bee415 	stw	r2,-1136(fp)
         if (iRet < 0) 
 8246974:	e0bee417 	ldw	r2,-1136(fp)
 8246978:	10000c0e 	bge	r2,zero,82469ac <u_mctest_run+0x528>
         {
            if (t_errno(s) != EWOULDBLOCK)
 824697c:	e13ee317 	ldw	r4,-1140(fp)
 8246980:	82316e80 	call	82316e8 <t_errno>
 8246984:	108002e0 	cmpeqi	r2,r2,11
 8246988:	1000081e 	bne	r2,zero,82469ac <u_mctest_run+0x528>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 824698c:	e13ee317 	ldw	r4,-1140(fp)
 8246990:	82316e80 	call	82316e8 <t_errno>
 8246994:	100d883a 	mov	r6,r2
 8246998:	01420974 	movhi	r5,2085
 824699c:	29456a04 	addi	r5,r5,5544
 82469a0:	e13fff17 	ldw	r4,-4(fp)
 82469a4:	8228bac0 	call	8228bac <ns_printf>
 82469a8:	00003506 	br	8246a80 <u_mctest_run+0x5fc>
               /*     exit(1); */
               goto exitloop;
            }
         }
         if (iRet > 0)
 82469ac:	e0bee417 	ldw	r2,-1136(fp)
 82469b0:	0080160e 	bge	zero,r2,8246a0c <u_mctest_run+0x588>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 82469b4:	e0beef17 	ldw	r2,-1092(fp)
 82469b8:	1009883a 	mov	r4,r2
 82469bc:	82287400 	call	8228740 <print_ipad>
 82469c0:	1009883a 	mov	r4,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 82469c4:	e0beee8b 	ldhu	r2,-1094(fp)
 82469c8:	10bfffcc 	andi	r2,r2,65535
 82469cc:	1004d23a 	srli	r2,r2,8
 82469d0:	10bfffcc 	andi	r2,r2,65535
 82469d4:	10c03fcc 	andi	r3,r2,255
 82469d8:	e0beee8b 	ldhu	r2,-1094(fp)
 82469dc:	10bfffcc 	andi	r2,r2,65535
 82469e0:	1004923a 	slli	r2,r2,8
 82469e4:	10bfffcc 	andi	r2,r2,65535
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 82469e8:	1886b03a 	or	r3,r3,r2
 82469ec:	e0bef204 	addi	r2,fp,-1080
 82469f0:	d8800015 	stw	r2,0(sp)
 82469f4:	180f883a 	mov	r7,r3
 82469f8:	200d883a 	mov	r6,r4
 82469fc:	01420974 	movhi	r5,2085
 8246a00:	29457204 	addi	r5,r5,5576
 8246a04:	e13fff17 	ldw	r4,-4(fp)
 8246a08:	8228bac0 	call	8228bac <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 8246a0c:	d0e0a817 	ldw	r3,-32096(gp)
 8246a10:	e0bee517 	ldw	r2,-1132(fp)
 8246a14:	18bfc936 	bltu	r3,r2,824693c <u_mctest_run+0x4b8>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 8246a18:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 8246a1c:	e0fffd04 	addi	r3,fp,-12
 8246a20:	00800044 	movi	r2,1
 8246a24:	d8800015 	stw	r2,0(sp)
 8246a28:	180f883a 	mov	r7,r3
 8246a2c:	01840584 	movi	r6,4118
 8246a30:	017fffc4 	movi	r5,-1
 8246a34:	e13ee317 	ldw	r4,-1140(fp)
 8246a38:	8230b5c0 	call	8230b5c <t_setsockopt>
 8246a3c:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246a40:	e0bee417 	ldw	r2,-1136(fp)
 8246a44:	10bfffd8 	cmpnei	r2,r2,-1
 8246a48:	1000071e 	bne	r2,zero,8246a68 <u_mctest_run+0x5e4>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 8246a4c:	e13ee317 	ldw	r4,-1140(fp)
 8246a50:	82316e80 	call	82316e8 <t_errno>
 8246a54:	100d883a 	mov	r6,r2
 8246a58:	01420974 	movhi	r5,2085
 8246a5c:	29457904 	addi	r5,r5,5604
 8246a60:	e13fff17 	ldw	r4,-4(fp)
 8246a64:	8228bac0 	call	8228bac <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246a68:	e0bee217 	ldw	r2,-1144(fp)
 8246a6c:	10800044 	addi	r2,r2,1
 8246a70:	e0bee215 	stw	r2,-1144(fp)
 8246a74:	e0bee217 	ldw	r2,-1144(fp)
 8246a78:	108000d0 	cmplti	r2,r2,3
 8246a7c:	103f771e 	bne	r2,zero,824685c <u_mctest_run+0x3d8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 8246a80:	01020974 	movhi	r4,2085
 8246a84:	21050e04 	addi	r4,r4,5176
 8246a88:	82475600 	call	8247560 <inet_addr>
 8246a8c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246a90:	008209b4 	movhi	r2,2086
 8246a94:	10b67a04 	addi	r2,r2,-9752
 8246a98:	10800a17 	ldw	r2,40(r2)
 8246a9c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 8246aa0:	e0fffb04 	addi	r3,fp,-20
 8246aa4:	00800204 	movi	r2,8
 8246aa8:	d8800015 	stw	r2,0(sp)
 8246aac:	180f883a 	mov	r7,r3
 8246ab0:	01800344 	movi	r6,13
 8246ab4:	000b883a 	mov	r5,zero
 8246ab8:	e13ee317 	ldw	r4,-1140(fp)
 8246abc:	8230b5c0 	call	8230b5c <t_setsockopt>
 8246ac0:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246ac4:	e0bee417 	ldw	r2,-1136(fp)
 8246ac8:	10bfffd8 	cmpnei	r2,r2,-1
 8246acc:	1000071e 	bne	r2,zero,8246aec <u_mctest_run+0x668>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 8246ad0:	e13ee317 	ldw	r4,-1140(fp)
 8246ad4:	82316e80 	call	82316e8 <t_errno>
 8246ad8:	100d883a 	mov	r6,r2
 8246adc:	01420974 	movhi	r5,2085
 8246ae0:	29458504 	addi	r5,r5,5652
 8246ae4:	e13fff17 	ldw	r4,-4(fp)
 8246ae8:	8228bac0 	call	8228bac <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 8246aec:	e13ee317 	ldw	r4,-1140(fp)
 8246af0:	82315980 	call	8231598 <t_socketclose>
 8246af4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246af8:	e0bee417 	ldw	r2,-1136(fp)
 8246afc:	10bfffd8 	cmpnei	r2,r2,-1
 8246b00:	1000071e 	bne	r2,zero,8246b20 <u_mctest_run+0x69c>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 8246b04:	e13ee317 	ldw	r4,-1140(fp)
 8246b08:	82316e80 	call	82316e8 <t_errno>
 8246b0c:	100d883a 	mov	r6,r2
 8246b10:	01420974 	movhi	r5,2085
 8246b14:	29459204 	addi	r5,r5,5704
 8246b18:	e13fff17 	ldw	r4,-4(fp)
 8246b1c:	8228bac0 	call	8228bac <ns_printf>
   }

   return(0);
 8246b20:	0005883a 	mov	r2,zero
}  /* end main() */  
 8246b24:	e037883a 	mov	sp,fp
 8246b28:	dfc00117 	ldw	ra,4(sp)
 8246b2c:	df000017 	ldw	fp,0(sp)
 8246b30:	dec00204 	addi	sp,sp,8
 8246b34:	f800283a 	ret

08246b38 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 8246b38:	defff604 	addi	sp,sp,-40
 8246b3c:	dfc00915 	stw	ra,36(sp)
 8246b40:	df000815 	stw	fp,32(sp)
 8246b44:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 8246b48:	e03ff915 	stw	zero,-28(fp)

   e = dhc_init();
 8246b4c:	82298180 	call	8229818 <dhc_init>
 8246b50:	e0bffa15 	stw	r2,-24(fp)

   if (e)
 8246b54:	e0bffa17 	ldw	r2,-24(fp)
 8246b58:	10000526 	beq	r2,zero,8246b70 <dhc_setup+0x38>
   {
      printf("Error starting DHCP client code.\n");
 8246b5c:	01020974 	movhi	r4,2085
 8246b60:	21059b04 	addi	r4,r4,5740
 8246b64:	82033700 	call	8203370 <puts>
      netexit(1);
 8246b68:	01000044 	movi	r4,1
 8246b6c:	82439d80 	call	82439d8 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 8246b70:	d0a0a817 	ldw	r2,-32096(gp)
 8246b74:	e0bffb15 	stw	r2,-20(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246b78:	e03ff815 	stw	zero,-32(fp)
 8246b7c:	00005006 	br	8246cc0 <dhc_setup+0x188>
   {
      if (!nets[iface])
 8246b80:	008209b4 	movhi	r2,2086
 8246b84:	10b73a04 	addi	r2,r2,-8984
 8246b88:	e0fff817 	ldw	r3,-32(fp)
 8246b8c:	18c7883a 	add	r3,r3,r3
 8246b90:	18c7883a 	add	r3,r3,r3
 8246b94:	10c5883a 	add	r2,r2,r3
 8246b98:	10800017 	ldw	r2,0(r2)
 8246b9c:	10004226 	beq	r2,zero,8246ca8 <dhc_setup+0x170>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 8246ba0:	008209b4 	movhi	r2,2086
 8246ba4:	10b73a04 	addi	r2,r2,-8984
 8246ba8:	e0fff817 	ldw	r3,-32(fp)
 8246bac:	18c7883a 	add	r3,r3,r3
 8246bb0:	18c7883a 	add	r3,r3,r3
 8246bb4:	10c5883a 	add	r2,r2,r3
 8246bb8:	10800017 	ldw	r2,0(r2)
 8246bbc:	10802a17 	ldw	r2,168(r2)
 8246bc0:	1080400c 	andi	r2,r2,256
 8246bc4:	10003a26 	beq	r2,zero,8246cb0 <dhc_setup+0x178>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 8246bc8:	008209b4 	movhi	r2,2086
 8246bcc:	10b76004 	addi	r2,r2,-8832
 8246bd0:	e0fff817 	ldw	r3,-32(fp)
 8246bd4:	18c00f24 	muli	r3,r3,60
 8246bd8:	10c5883a 	add	r2,r2,r3
 8246bdc:	10800e04 	addi	r2,r2,56
 8246be0:	10800017 	ldw	r2,0(r2)
 8246be4:	1000041e 	bne	r2,zero,8246bf8 <dhc_setup+0xc0>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 8246be8:	01420934 	movhi	r5,2084
 8246bec:	295b6704 	addi	r5,r5,28060
 8246bf0:	e13ff817 	ldw	r4,-32(fp)
 8246bf4:	82298c80 	call	82298c8 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 8246bf8:	008209b4 	movhi	r2,2086
 8246bfc:	10b73a04 	addi	r2,r2,-8984
 8246c00:	e0fff817 	ldw	r3,-32(fp)
 8246c04:	18c7883a 	add	r3,r3,r3
 8246c08:	18c7883a 	add	r3,r3,r3
 8246c0c:	10c5883a 	add	r2,r2,r3
 8246c10:	10800017 	ldw	r2,0(r2)
 8246c14:	10c00a17 	ldw	r3,40(r2)
 8246c18:	e0bff817 	ldw	r2,-32(fp)
 8246c1c:	1085883a 	add	r2,r2,r2
 8246c20:	1085883a 	add	r2,r2,r2
 8246c24:	e13ff804 	addi	r4,fp,-32
 8246c28:	2085883a 	add	r2,r4,r2
 8246c2c:	10800404 	addi	r2,r2,16
 8246c30:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 8246c34:	e0bff817 	ldw	r2,-32(fp)
 8246c38:	1085883a 	add	r2,r2,r2
 8246c3c:	1085883a 	add	r2,r2,r2
 8246c40:	e0fff804 	addi	r3,fp,-32
 8246c44:	1885883a 	add	r2,r3,r2
 8246c48:	10800404 	addi	r2,r2,16
 8246c4c:	10800017 	ldw	r2,0(r2)
 8246c50:	1000041e 	bne	r2,zero,8246c64 <dhc_setup+0x12c>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 8246c54:	01400044 	movi	r5,1
 8246c58:	e13ff817 	ldw	r4,-32(fp)
 8246c5c:	822c1e40 	call	822c1e4 <dhc_state_init>
 8246c60:	00000306 	br	8246c70 <dhc_setup+0x138>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 8246c64:	000b883a 	mov	r5,zero
 8246c68:	e13ff817 	ldw	r4,-32(fp)
 8246c6c:	822c1e40 	call	822c1e4 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 8246c70:	822ba5c0 	call	822ba5c <dhc_second>
 8246c74:	e0bffa15 	stw	r2,-24(fp)
      if (e)
 8246c78:	e0bffa17 	ldw	r2,-24(fp)
 8246c7c:	10000626 	beq	r2,zero,8246c98 <dhc_setup+0x160>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 8246c80:	e17ff817 	ldw	r5,-32(fp)
 8246c84:	01020974 	movhi	r4,2085
 8246c88:	2105a404 	addi	r4,r4,5776
 8246c8c:	82030ec0 	call	82030ec <printf>
         netexit(1);
 8246c90:	01000044 	movi	r4,1
 8246c94:	82439d80 	call	82439d8 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 8246c98:	e0bff917 	ldw	r2,-28(fp)
 8246c9c:	10800044 	addi	r2,r2,1
 8246ca0:	e0bff915 	stw	r2,-28(fp)
 8246ca4:	00000306 	br	8246cb4 <dhc_setup+0x17c>
   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
   {
      if (!nets[iface])
         continue; /* no valid iface for this network */
 8246ca8:	0001883a 	nop
 8246cac:	00000106 	br	8246cb4 <dhc_setup+0x17c>
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
         continue;
 8246cb0:	0001883a 	nop
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246cb4:	e0bff817 	ldw	r2,-32(fp)
 8246cb8:	10800044 	addi	r2,r2,1
 8246cbc:	e0bff815 	stw	r2,-32(fp)
 8246cc0:	e0bff817 	ldw	r2,-32(fp)
 8246cc4:	10800110 	cmplti	r2,r2,4
 8246cc8:	103fad1e 	bne	r2,zero,8246b80 <dhc_setup+0x48>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 8246ccc:	e0bff917 	ldw	r2,-28(fp)
 8246cd0:	10002c26 	beq	r2,zero,8246d84 <dhc_setup+0x24c>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246cd4:	00000206 	br	8246ce0 <dhc_setup+0x1a8>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 8246cd8:	82295580 	call	8229558 <tk_yield>
      pktdemux();
 8246cdc:	82260100 	call	8226010 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246ce0:	d0e0a817 	ldw	r3,-32096(gp)
 8246ce4:	e0bffb17 	ldw	r2,-20(fp)
 8246ce8:	1885c83a 	sub	r2,r3,r2
 8246cec:	108cb228 	cmpgeui	r2,r2,13000
 8246cf0:	1000021e 	bne	r2,zero,8246cfc <dhc_setup+0x1c4>
      (dhc_alldone() == FALSE))
 8246cf4:	822c23c0 	call	822c23c <dhc_alldone>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246cf8:	103ff726 	beq	r2,zero,8246cd8 <dhc_setup+0x1a0>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 8246cfc:	822c23c0 	call	822c23c <dhc_alldone>
 8246d00:	1000211e 	bne	r2,zero,8246d88 <dhc_setup+0x250>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 8246d04:	01020974 	movhi	r4,2085
 8246d08:	2105ae04 	addi	r4,r4,5816
 8246d0c:	82033700 	call	8203370 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246d10:	e03ff815 	stw	zero,-32(fp)
 8246d14:	00001706 	br	8246d74 <dhc_setup+0x23c>
      {
         if (dhc_ifacedone(iface) == FALSE)
 8246d18:	e13ff817 	ldw	r4,-32(fp)
 8246d1c:	822c2c40 	call	822c2c4 <dhc_ifacedone>
 8246d20:	1000111e 	bne	r2,zero,8246d68 <dhc_setup+0x230>
         {
            dhc_halt(iface);
 8246d24:	e13ff817 	ldw	r4,-32(fp)
 8246d28:	822bfac0 	call	822bfac <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 8246d2c:	008209b4 	movhi	r2,2086
 8246d30:	10b73a04 	addi	r2,r2,-8984
 8246d34:	e0fff817 	ldw	r3,-32(fp)
 8246d38:	18c7883a 	add	r3,r3,r3
 8246d3c:	18c7883a 	add	r3,r3,r3
 8246d40:	10c5883a 	add	r2,r2,r3
 8246d44:	10c00017 	ldw	r3,0(r2)
 8246d48:	e0bff817 	ldw	r2,-32(fp)
 8246d4c:	1085883a 	add	r2,r2,r2
 8246d50:	1085883a 	add	r2,r2,r2
 8246d54:	e13ff804 	addi	r4,fp,-32
 8246d58:	2085883a 	add	r2,r4,r2
 8246d5c:	10800404 	addi	r2,r2,16
 8246d60:	10800017 	ldw	r2,0(r2)
 8246d64:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246d68:	e0bff817 	ldw	r2,-32(fp)
 8246d6c:	10800044 	addi	r2,r2,1
 8246d70:	e0bff815 	stw	r2,-32(fp)
 8246d74:	e0bff817 	ldw	r2,-32(fp)
 8246d78:	10800110 	cmplti	r2,r2,4
 8246d7c:	103fe61e 	bne	r2,zero,8246d18 <dhc_setup+0x1e0>
 8246d80:	00000106 	br	8246d88 <dhc_setup+0x250>
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
      return;
 8246d84:	0001883a 	nop
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 8246d88:	e037883a 	mov	sp,fp
 8246d8c:	dfc00117 	ldw	ra,4(sp)
 8246d90:	df000017 	ldw	fp,0(sp)
 8246d94:	dec00204 	addi	sp,sp,8
 8246d98:	f800283a 	ret

08246d9c <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 8246d9c:	defffc04 	addi	sp,sp,-16
 8246da0:	dfc00315 	stw	ra,12(sp)
 8246da4:	df000215 	stw	fp,8(sp)
 8246da8:	df000204 	addi	fp,sp,8
 8246dac:	e13ffe15 	stw	r4,-8(fp)
 8246db0:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 8246db4:	e0bfff17 	ldw	r2,-4(fp)
 8246db8:	10800198 	cmpnei	r2,r2,6
 8246dbc:	1000361e 	bne	r2,zero,8246e98 <dhc_main_ipset+0xfc>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
              nets[iface]->name);
 8246dc0:	008209b4 	movhi	r2,2086
 8246dc4:	10b73a04 	addi	r2,r2,-8984
 8246dc8:	e0fffe17 	ldw	r3,-8(fp)
 8246dcc:	18c7883a 	add	r3,r3,r3
 8246dd0:	18c7883a 	add	r3,r3,r3
 8246dd4:	10c5883a 	add	r2,r2,r3
 8246dd8:	10800017 	ldw	r2,0(r2)
 8246ddc:	10800104 	addi	r2,r2,4
dhc_main_ipset(int iface, int state)
{
   if ( state == DHCS_BOUND )
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 8246de0:	100b883a 	mov	r5,r2
 8246de4:	01020974 	movhi	r4,2085
 8246de8:	2105bc04 	addi	r4,r4,5872
 8246dec:	82030ec0 	call	82030ec <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 8246df0:	008209b4 	movhi	r2,2086
 8246df4:	10b73a04 	addi	r2,r2,-8984
 8246df8:	e0fffe17 	ldw	r3,-8(fp)
 8246dfc:	18c7883a 	add	r3,r3,r3
 8246e00:	18c7883a 	add	r3,r3,r3
 8246e04:	10c5883a 	add	r2,r2,r3
 8246e08:	10800017 	ldw	r2,0(r2)
 8246e0c:	10800a17 	ldw	r2,40(r2)
 8246e10:	1009883a 	mov	r4,r2
 8246e14:	82287400 	call	8228740 <print_ipad>
 8246e18:	100b883a 	mov	r5,r2
 8246e1c:	01020974 	movhi	r4,2085
 8246e20:	2105ca04 	addi	r4,r4,5928
 8246e24:	82030ec0 	call	82030ec <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 8246e28:	008209b4 	movhi	r2,2086
 8246e2c:	10b73a04 	addi	r2,r2,-8984
 8246e30:	e0fffe17 	ldw	r3,-8(fp)
 8246e34:	18c7883a 	add	r3,r3,r3
 8246e38:	18c7883a 	add	r3,r3,r3
 8246e3c:	10c5883a 	add	r2,r2,r3
 8246e40:	10800017 	ldw	r2,0(r2)
 8246e44:	10800c17 	ldw	r2,48(r2)
 8246e48:	1009883a 	mov	r4,r2
 8246e4c:	82287400 	call	8228740 <print_ipad>
 8246e50:	100b883a 	mov	r5,r2
 8246e54:	01020974 	movhi	r4,2085
 8246e58:	2105cf04 	addi	r4,r4,5948
 8246e5c:	82030ec0 	call	82030ec <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 8246e60:	008209b4 	movhi	r2,2086
 8246e64:	10b73a04 	addi	r2,r2,-8984
 8246e68:	e0fffe17 	ldw	r3,-8(fp)
 8246e6c:	18c7883a 	add	r3,r3,r3
 8246e70:	18c7883a 	add	r3,r3,r3
 8246e74:	10c5883a 	add	r2,r2,r3
 8246e78:	10800017 	ldw	r2,0(r2)
 8246e7c:	10800d17 	ldw	r2,52(r2)
 8246e80:	1009883a 	mov	r4,r2
 8246e84:	82287400 	call	8228740 <print_ipad>
 8246e88:	100b883a 	mov	r5,r2
 8246e8c:	01020974 	movhi	r4,2085
 8246e90:	2105d404 	addi	r4,r4,5968
 8246e94:	82030ec0 	call	82030ec <printf>
   }
   return 0;
 8246e98:	0005883a 	mov	r2,zero
}
 8246e9c:	e037883a 	mov	sp,fp
 8246ea0:	dfc00117 	ldw	ra,4(sp)
 8246ea4:	df000017 	ldw	fp,0(sp)
 8246ea8:	dec00204 	addi	sp,sp,8
 8246eac:	f800283a 	ret

08246eb0 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 8246eb0:	deffff04 	addi	sp,sp,-4
 8246eb4:	df000015 	stw	fp,0(sp)
 8246eb8:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 8246ebc:	d0e0d417 	ldw	r3,-31920(gp)
 8246ec0:	00820974 	movhi	r2,2085
 8246ec4:	108e5b04 	addi	r2,r2,14700
 8246ec8:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 8246ecc:	00820974 	movhi	r2,2085
 8246ed0:	108e5b04 	addi	r2,r2,14700
 8246ed4:	d0a0d415 	stw	r2,-31920(gp)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 8246ed8:	d0e0d617 	ldw	r3,-31912(gp)
 8246edc:	00820974 	movhi	r2,2085
 8246ee0:	108e6404 	addi	r2,r2,14736
 8246ee4:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 8246ee8:	00820974 	movhi	r2,2085
 8246eec:	108e8504 	addi	r2,r2,14868
 8246ef0:	d0a0d615 	stw	r2,-31912(gp)

   return 0;
 8246ef4:	0005883a 	mov	r2,zero
}
 8246ef8:	e037883a 	mov	sp,fp
 8246efc:	df000017 	ldw	fp,0(sp)
 8246f00:	dec00104 	addi	sp,sp,4
 8246f04:	f800283a 	ret

08246f08 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 8246f08:	defffd04 	addi	sp,sp,-12
 8246f0c:	df000215 	stw	fp,8(sp)
 8246f10:	df000204 	addi	fp,sp,8
 8246f14:	e13ffe15 	stw	r4,-8(fp)
 8246f18:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 8246f1c:	0005883a 	mov	r2,zero
}
 8246f20:	e037883a 	mov	sp,fp
 8246f24:	df000017 	ldw	fp,0(sp)
 8246f28:	dec00104 	addi	sp,sp,4
 8246f2c:	f800283a 	ret

08246f30 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 8246f30:	defffe04 	addi	sp,sp,-8
 8246f34:	df000115 	stw	fp,4(sp)
 8246f38:	df000104 	addi	fp,sp,4
 8246f3c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 8246f40:	0001883a 	nop
 8246f44:	e037883a 	mov	sp,fp
 8246f48:	df000017 	ldw	fp,0(sp)
 8246f4c:	dec00104 	addi	sp,sp,4
 8246f50:	f800283a 	ret

08246f54 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8246f54:	defff704 	addi	sp,sp,-36
 8246f58:	dfc00815 	stw	ra,32(sp)
 8246f5c:	df000715 	stw	fp,28(sp)
 8246f60:	df000704 	addi	fp,sp,28
 8246f64:	e13ffc15 	stw	r4,-16(fp)
 8246f68:	e17ffd15 	stw	r5,-12(fp)
 8246f6c:	e1bffe15 	stw	r6,-8(fp)
 8246f70:	e1ffff15 	stw	r7,-4(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 8246f74:	00800834 	movhi	r2,32
 8246f78:	e0bffa15 	stw	r2,-24(fp)
   if(vfd && vfd->file)
 8246f7c:	e0bfff17 	ldw	r2,-4(fp)
 8246f80:	10000726 	beq	r2,zero,8246fa0 <md_fread+0x4c>
 8246f84:	e0bfff17 	ldw	r2,-4(fp)
 8246f88:	10800117 	ldw	r2,4(r2)
 8246f8c:	10000426 	beq	r2,zero,8246fa0 <md_fread+0x4c>
   {
      file_size = vfd->file->real_size; 
 8246f90:	e0bfff17 	ldw	r2,-4(fp)
 8246f94:	10800117 	ldw	r2,4(r2)
 8246f98:	10800717 	ldw	r2,28(r2)
 8246f9c:	e0bffa15 	stw	r2,-24(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 8246fa0:	e0bfff17 	ldw	r2,-4(fp)
 8246fa4:	10800217 	ldw	r2,8(r2)
 8246fa8:	1007883a 	mov	r3,r2
 8246fac:	e0bfff17 	ldw	r2,-4(fp)
 8246fb0:	10800117 	ldw	r2,4(r2)
 8246fb4:	10800617 	ldw	r2,24(r2)
 8246fb8:	1885c83a 	sub	r2,r3,r2
 8246fbc:	e0bffb15 	stw	r2,-20(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 8246fc0:	e0fffe17 	ldw	r3,-8(fp)
 8246fc4:	e0bffd17 	ldw	r2,-12(fp)
 8246fc8:	1885383a 	mul	r2,r3,r2
 8246fcc:	e0bff915 	stw	r2,-28(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 8246fd0:	e0fffb17 	ldw	r3,-20(fp)
 8246fd4:	e0bff917 	ldw	r2,-28(fp)
 8246fd8:	1885883a 	add	r2,r3,r2
 8246fdc:	e0fffa17 	ldw	r3,-24(fp)
 8246fe0:	1880042e 	bgeu	r3,r2,8246ff4 <md_fread+0xa0>
      bcount = ((u_long)file_size - location);
 8246fe4:	e0fffa17 	ldw	r3,-24(fp)
 8246fe8:	e0bffb17 	ldw	r2,-20(fp)
 8246fec:	1885c83a 	sub	r2,r3,r2
 8246ff0:	e0bff915 	stw	r2,-28(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 8246ff4:	e0fffb17 	ldw	r3,-20(fp)
 8246ff8:	e0bffa17 	ldw	r2,-24(fp)
 8246ffc:	1880052e 	bgeu	r3,r2,8247014 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 8247000:	e0bff917 	ldw	r2,-28(fp)
 8247004:	10bfffec 	andhi	r2,r2,65535
   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
      bcount = ((u_long)file_size - location);

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 8247008:	1000021e 	bne	r2,zero,8247014 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 824700c:	e0bff917 	ldw	r2,-28(fp)
 8247010:	1000021e 	bne	r2,zero,824701c <md_fread+0xc8>
      (bcount == 0))
   {
      return 0;
 8247014:	0005883a 	mov	r2,zero
 8247018:	00002006 	br	824709c <md_fread+0x148>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 824701c:	e0bfff17 	ldw	r2,-4(fp)
 8247020:	10800117 	ldw	r2,4(r2)
 8247024:	1080058b 	ldhu	r2,22(r2)
 8247028:	10bfffcc 	andi	r2,r2,65535
 824702c:	10a0001c 	xori	r2,r2,32768
 8247030:	10a00004 	addi	r2,r2,-32768
 8247034:	10001016 	blt	r2,zero,8247078 <md_fread+0x124>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 8247038:	e0bfff17 	ldw	r2,-4(fp)
 824703c:	10800117 	ldw	r2,4(r2)
 8247040:	10800103 	ldbu	r2,4(r2)
 8247044:	10803fcc 	andi	r2,r2,255
 8247048:	1080201c 	xori	r2,r2,128
 824704c:	10bfe004 	addi	r2,r2,-128
 8247050:	10801b58 	cmpnei	r2,r2,109
 8247054:	1000081e 	bne	r2,zero,8247078 <md_fread+0x124>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 8247058:	e0bfff17 	ldw	r2,-4(fp)
 824705c:	10c00217 	ldw	r3,8(r2)
 8247060:	00800834 	movhi	r2,32
 8247064:	1885883a 	add	r2,r3,r2
 8247068:	e1bff917 	ldw	r6,-28(fp)
 824706c:	100b883a 	mov	r5,r2
 8247070:	e13ffc17 	ldw	r4,-16(fp)
 8247074:	8202c5c0 	call	8202c5c <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 8247078:	e0bfff17 	ldw	r2,-4(fp)
 824707c:	10c00217 	ldw	r3,8(r2)
 8247080:	e0bff917 	ldw	r2,-28(fp)
 8247084:	1887883a 	add	r3,r3,r2
 8247088:	e0bfff17 	ldw	r2,-4(fp)
 824708c:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 8247090:	e17ffd17 	ldw	r5,-12(fp)
 8247094:	e13ff917 	ldw	r4,-28(fp)
 8247098:	820295c0 	call	820295c <__udivsi3>
}
 824709c:	e037883a 	mov	sp,fp
 82470a0:	dfc00117 	ldw	ra,4(sp)
 82470a4:	df000017 	ldw	fp,0(sp)
 82470a8:	dec00204 	addi	sp,sp,8
 82470ac:	f800283a 	ret

082470b0 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82470b0:	defffb04 	addi	sp,sp,-20
 82470b4:	df000415 	stw	fp,16(sp)
 82470b8:	df000404 	addi	fp,sp,16
 82470bc:	e13ffc15 	stw	r4,-16(fp)
 82470c0:	e17ffd15 	stw	r5,-12(fp)
 82470c4:	e1bffe15 	stw	r6,-8(fp)
 82470c8:	e1ffff15 	stw	r7,-4(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 82470cc:	e0bfff17 	ldw	r2,-4(fp)
 82470d0:	10800117 	ldw	r2,4(r2)
 82470d4:	10800103 	ldbu	r2,4(r2)
 82470d8:	10803fcc 	andi	r2,r2,255
 82470dc:	1080201c 	xori	r2,r2,128
 82470e0:	10bfe004 	addi	r2,r2,-128
 82470e4:	10801b58 	cmpnei	r2,r2,109
 82470e8:	1000021e 	bne	r2,zero,82470f4 <md_fwrite+0x44>
      return 0;   /* not writable device */
 82470ec:	0005883a 	mov	r2,zero
 82470f0:	00000906 	br	8247118 <md_fwrite+0x68>

   vfd->cmploc += (items * size);   /* adjust location */
 82470f4:	e0bfff17 	ldw	r2,-4(fp)
 82470f8:	10c00217 	ldw	r3,8(r2)
 82470fc:	e13ffe17 	ldw	r4,-8(fp)
 8247100:	e0bffd17 	ldw	r2,-12(fp)
 8247104:	2085383a 	mul	r2,r4,r2
 8247108:	1887883a 	add	r3,r3,r2
 824710c:	e0bfff17 	ldw	r2,-4(fp)
 8247110:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 8247114:	e0bffe17 	ldw	r2,-8(fp)
}
 8247118:	e037883a 	mov	sp,fp
 824711c:	df000017 	ldw	fp,0(sp)
 8247120:	dec00104 	addi	sp,sp,4
 8247124:	f800283a 	ret

08247128 <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 8247128:	defffc04 	addi	sp,sp,-16
 824712c:	df000315 	stw	fp,12(sp)
 8247130:	df000304 	addi	fp,sp,12
 8247134:	e13ffd15 	stw	r4,-12(fp)
 8247138:	e17ffe15 	stw	r5,-8(fp)
 824713c:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 8247140:	0005883a 	mov	r2,zero
}
 8247144:	e037883a 	mov	sp,fp
 8247148:	df000017 	ldw	fp,0(sp)
 824714c:	dec00104 	addi	sp,sp,4
 8247150:	f800283a 	ret

08247154 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 8247154:	defffe04 	addi	sp,sp,-8
 8247158:	df000115 	stw	fp,4(sp)
 824715c:	df000104 	addi	fp,sp,4
 8247160:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 8247164:	00800834 	movhi	r2,32
}
 8247168:	e037883a 	mov	sp,fp
 824716c:	df000017 	ldw	fp,0(sp)
 8247170:	dec00104 	addi	sp,sp,4
 8247174:	f800283a 	ret

08247178 <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 8247178:	defffc04 	addi	sp,sp,-16
 824717c:	df000315 	stw	fp,12(sp)
 8247180:	df000304 	addi	fp,sp,12
 8247184:	e13fff15 	stw	r4,-4(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 8247188:	e03ffd15 	stw	zero,-12(fp)

   location = vfd->cmploc - vfd->file->data;
 824718c:	e0bfff17 	ldw	r2,-4(fp)
 8247190:	10800217 	ldw	r2,8(r2)
 8247194:	1007883a 	mov	r3,r2
 8247198:	e0bfff17 	ldw	r2,-4(fp)
 824719c:	10800117 	ldw	r2,4(r2)
 82471a0:	10800617 	ldw	r2,24(r2)
 82471a4:	1885c83a 	sub	r2,r3,r2
 82471a8:	e0bffe15 	stw	r2,-8(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 82471ac:	e0bfff17 	ldw	r2,-4(fp)
 82471b0:	10800117 	ldw	r2,4(r2)
 82471b4:	10800717 	ldw	r2,28(r2)
 82471b8:	e0fffe17 	ldw	r3,-8(fp)
 82471bc:	18800236 	bltu	r3,r2,82471c8 <md_fgetc+0x50>
      return EOF;
 82471c0:	00bfffc4 	movi	r2,-1
 82471c4:	00001a06 	br	8247230 <md_fgetc+0xb8>

   if (!(vfd->file->flags & VF_NODATA))
 82471c8:	e0bfff17 	ldw	r2,-4(fp)
 82471cc:	10800117 	ldw	r2,4(r2)
 82471d0:	1080058b 	ldhu	r2,22(r2)
 82471d4:	10bfffcc 	andi	r2,r2,65535
 82471d8:	10a0001c 	xori	r2,r2,32768
 82471dc:	10a00004 	addi	r2,r2,-32768
 82471e0:	10000d16 	blt	r2,zero,8247218 <md_fgetc+0xa0>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 82471e4:	e0bfff17 	ldw	r2,-4(fp)
 82471e8:	10800117 	ldw	r2,4(r2)
 82471ec:	10800103 	ldbu	r2,4(r2)
 82471f0:	10803fcc 	andi	r2,r2,255
 82471f4:	1080201c 	xori	r2,r2,128
 82471f8:	10bfe004 	addi	r2,r2,-128
 82471fc:	10801b58 	cmpnei	r2,r2,109
 8247200:	1000051e 	bne	r2,zero,8247218 <md_fgetc+0xa0>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 8247204:	e0bfff17 	ldw	r2,-4(fp)
 8247208:	10800217 	ldw	r2,8(r2)
 824720c:	10800003 	ldbu	r2,0(r2)
 8247210:	10803fcc 	andi	r2,r2,255
 8247214:	e0bffd15 	stw	r2,-12(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 8247218:	e0bfff17 	ldw	r2,-4(fp)
 824721c:	10800217 	ldw	r2,8(r2)
 8247220:	10c00044 	addi	r3,r2,1
 8247224:	e0bfff17 	ldw	r2,-4(fp)
 8247228:	10c00215 	stw	r3,8(r2)
   return retval;
 824722c:	e0bffd17 	ldw	r2,-12(fp)
}
 8247230:	e037883a 	mov	sp,fp
 8247234:	df000017 	ldw	fp,0(sp)
 8247238:	dec00104 	addi	sp,sp,4
 824723c:	f800283a 	ret

08247240 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 8247240:	defffe04 	addi	sp,sp,-8
 8247244:	df000115 	stw	fp,4(sp)
 8247248:	df000104 	addi	fp,sp,4
 824724c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 8247250:	0005883a 	mov	r2,zero
}
 8247254:	e037883a 	mov	sp,fp
 8247258:	df000017 	ldw	fp,0(sp)
 824725c:	dec00104 	addi	sp,sp,4
 8247260:	f800283a 	ret

08247264 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 8247264:	defff604 	addi	sp,sp,-40
 8247268:	dfc00915 	stw	ra,36(sp)
 824726c:	df000815 	stw	fp,32(sp)
 8247270:	df000804 	addi	fp,sp,32
 8247274:	e13ffd15 	stw	r4,-12(fp)
 8247278:	e17ffe15 	stw	r5,-8(fp)
 824727c:	e1bfff15 	stw	r6,-4(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 8247280:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 8247284:	00820974 	movhi	r2,2085
 8247288:	1085d904 	addi	r2,r2,5988
 824728c:	e0bffa15 	stw	r2,-24(fp)

   cp = stringin;
 8247290:	e0bfff17 	ldw	r2,-4(fp)
 8247294:	e0bff815 	stw	r2,-32(fp)
   while (*cp)
 8247298:	00002506 	br	8247330 <parse_ipad+0xcc>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 824729c:	e0bff817 	ldw	r2,-32(fp)
 82472a0:	10800003 	ldbu	r2,0(r2)
 82472a4:	10803fcc 	andi	r2,r2,255
 82472a8:	1080201c 	xori	r2,r2,128
 82472ac:	10bfe004 	addi	r2,r2,-128
 82472b0:	10800e88 	cmpgei	r2,r2,58
 82472b4:	10000e1e 	bne	r2,zero,82472f0 <parse_ipad+0x8c>
 82472b8:	e0bff817 	ldw	r2,-32(fp)
 82472bc:	10800003 	ldbu	r2,0(r2)
 82472c0:	10803fcc 	andi	r2,r2,255
 82472c4:	1080201c 	xori	r2,r2,128
 82472c8:	10bfe004 	addi	r2,r2,-128
 82472cc:	10800b90 	cmplti	r2,r2,46
 82472d0:	1000071e 	bne	r2,zero,82472f0 <parse_ipad+0x8c>
 82472d4:	e0bff817 	ldw	r2,-32(fp)
 82472d8:	10800003 	ldbu	r2,0(r2)
 82472dc:	10803fcc 	andi	r2,r2,255
 82472e0:	1080201c 	xori	r2,r2,128
 82472e4:	10bfe004 	addi	r2,r2,-128
 82472e8:	10800bd8 	cmpnei	r2,r2,47
 82472ec:	1000031e 	bne	r2,zero,82472fc <parse_ipad+0x98>
         return("all chars must be digits (0-9) or dots (.)");
 82472f0:	00820974 	movhi	r2,2085
 82472f4:	1085e204 	addi	r2,r2,6024
 82472f8:	00009406 	br	824754c <parse_ipad+0x2e8>
      if (*cp == '.')dots++;
 82472fc:	e0bff817 	ldw	r2,-32(fp)
 8247300:	10800003 	ldbu	r2,0(r2)
 8247304:	10803fcc 	andi	r2,r2,255
 8247308:	1080201c 	xori	r2,r2,128
 824730c:	10bfe004 	addi	r2,r2,-128
 8247310:	10800b98 	cmpnei	r2,r2,46
 8247314:	1000031e 	bne	r2,zero,8247324 <parse_ipad+0xc0>
 8247318:	e0bff917 	ldw	r2,-28(fp)
 824731c:	10800044 	addi	r2,r2,1
 8247320:	e0bff915 	stw	r2,-28(fp)
         cp++;
 8247324:	e0bff817 	ldw	r2,-32(fp)
 8247328:	10800044 	addi	r2,r2,1
 824732c:	e0bff815 	stw	r2,-32(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 8247330:	e0bff817 	ldw	r2,-32(fp)
 8247334:	10800003 	ldbu	r2,0(r2)
 8247338:	10803fcc 	andi	r2,r2,255
 824733c:	1080201c 	xori	r2,r2,128
 8247340:	10bfe004 	addi	r2,r2,-128
 8247344:	103fd51e 	bne	r2,zero,824729c <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 8247348:	e0bff917 	ldw	r2,-28(fp)
 824734c:	0080030e 	bge	zero,r2,824735c <parse_ipad+0xf8>
 8247350:	e0bff917 	ldw	r2,-28(fp)
 8247354:	10800110 	cmplti	r2,r2,4
 8247358:	1000031e 	bne	r2,zero,8247368 <parse_ipad+0x104>
      return("string must contain 1 - 3 dots (.)");
 824735c:	00820974 	movhi	r2,2085
 8247360:	1085ed04 	addi	r2,r2,6068
 8247364:	00007906 	br	824754c <parse_ipad+0x2e8>

   cp = stringin;
 8247368:	e0bfff17 	ldw	r2,-4(fp)
 824736c:	e0bff815 	stw	r2,-32(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 8247370:	e13ff817 	ldw	r4,-32(fp)
 8247374:	824b38c0 	call	824b38c <atoi>
 8247378:	e0bffb15 	stw	r2,-20(fp)
 824737c:	e0bffb17 	ldw	r2,-20(fp)
 8247380:	10804010 	cmplti	r2,r2,256
 8247384:	1000021e 	bne	r2,zero,8247390 <parse_ipad+0x12c>
      return(toobig);
 8247388:	e0bffa17 	ldw	r2,-24(fp)
 824738c:	00006f06 	br	824754c <parse_ipad+0x2e8>

   retval.c[0] = (u_char)number;
 8247390:	e0bffb17 	ldw	r2,-20(fp)
 8247394:	e0bffc05 	stb	r2,-16(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 8247398:	00000306 	br	82473a8 <parse_ipad+0x144>
 824739c:	e0bff817 	ldw	r2,-32(fp)
 82473a0:	10800044 	addi	r2,r2,1
 82473a4:	e0bff815 	stw	r2,-32(fp)
 82473a8:	e0bff817 	ldw	r2,-32(fp)
 82473ac:	10800003 	ldbu	r2,0(r2)
 82473b0:	10803fcc 	andi	r2,r2,255
 82473b4:	1080201c 	xori	r2,r2,128
 82473b8:	10bfe004 	addi	r2,r2,-128
 82473bc:	10800b98 	cmpnei	r2,r2,46
 82473c0:	103ff61e 	bne	r2,zero,824739c <parse_ipad+0x138>
      cp++;             /* point past dot */
 82473c4:	e0bff817 	ldw	r2,-32(fp)
 82473c8:	10800044 	addi	r2,r2,1
 82473cc:	e0bff815 	stw	r2,-32(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 82473d0:	e0bff917 	ldw	r2,-28(fp)
 82473d4:	10800060 	cmpeqi	r2,r2,1
 82473d8:	1000031e 	bne	r2,zero,82473e8 <parse_ipad+0x184>
 82473dc:	e0bff917 	ldw	r2,-28(fp)
 82473e0:	10800098 	cmpnei	r2,r2,2
 82473e4:	1000021e 	bne	r2,zero,82473f0 <parse_ipad+0x18c>
 82473e8:	e03ffc45 	stb	zero,-15(fp)
 82473ec:	00001806 	br	8247450 <parse_ipad+0x1ec>
      else
   {
      number = atoi(cp);
 82473f0:	e13ff817 	ldw	r4,-32(fp)
 82473f4:	824b38c0 	call	824b38c <atoi>
 82473f8:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 82473fc:	00000306 	br	824740c <parse_ipad+0x1a8>
 8247400:	e0bff817 	ldw	r2,-32(fp)
 8247404:	10800044 	addi	r2,r2,1
 8247408:	e0bff815 	stw	r2,-32(fp)
 824740c:	e0bff817 	ldw	r2,-32(fp)
 8247410:	10800003 	ldbu	r2,0(r2)
 8247414:	10803fcc 	andi	r2,r2,255
 8247418:	1080201c 	xori	r2,r2,128
 824741c:	10bfe004 	addi	r2,r2,-128
 8247420:	10800b98 	cmpnei	r2,r2,46
 8247424:	103ff61e 	bne	r2,zero,8247400 <parse_ipad+0x19c>
         cp++;             /* point past dot */
 8247428:	e0bff817 	ldw	r2,-32(fp)
 824742c:	10800044 	addi	r2,r2,1
 8247430:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 8247434:	e0bffb17 	ldw	r2,-20(fp)
 8247438:	10804010 	cmplti	r2,r2,256
 824743c:	1000021e 	bne	r2,zero,8247448 <parse_ipad+0x1e4>
 8247440:	e0bffa17 	ldw	r2,-24(fp)
 8247444:	00004106 	br	824754c <parse_ipad+0x2e8>
         retval.c[1] = (u_char)number;
 8247448:	e0bffb17 	ldw	r2,-20(fp)
 824744c:	e0bffc45 	stb	r2,-15(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 8247450:	e0bff917 	ldw	r2,-28(fp)
 8247454:	10800058 	cmpnei	r2,r2,1
 8247458:	1000021e 	bne	r2,zero,8247464 <parse_ipad+0x200>
 824745c:	e03ffc85 	stb	zero,-14(fp)
 8247460:	00001806 	br	82474c4 <parse_ipad+0x260>
      else
   {
      number = atoi(cp);
 8247464:	e13ff817 	ldw	r4,-32(fp)
 8247468:	824b38c0 	call	824b38c <atoi>
 824746c:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247470:	00000306 	br	8247480 <parse_ipad+0x21c>
 8247474:	e0bff817 	ldw	r2,-32(fp)
 8247478:	10800044 	addi	r2,r2,1
 824747c:	e0bff815 	stw	r2,-32(fp)
 8247480:	e0bff817 	ldw	r2,-32(fp)
 8247484:	10800003 	ldbu	r2,0(r2)
 8247488:	10803fcc 	andi	r2,r2,255
 824748c:	1080201c 	xori	r2,r2,128
 8247490:	10bfe004 	addi	r2,r2,-128
 8247494:	10800b98 	cmpnei	r2,r2,46
 8247498:	103ff61e 	bne	r2,zero,8247474 <parse_ipad+0x210>
         cp++;             /* point past dot */
 824749c:	e0bff817 	ldw	r2,-32(fp)
 82474a0:	10800044 	addi	r2,r2,1
 82474a4:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 82474a8:	e0bffb17 	ldw	r2,-20(fp)
 82474ac:	10804010 	cmplti	r2,r2,256
 82474b0:	1000021e 	bne	r2,zero,82474bc <parse_ipad+0x258>
 82474b4:	e0bffa17 	ldw	r2,-24(fp)
 82474b8:	00002406 	br	824754c <parse_ipad+0x2e8>
         retval.c[2] = (u_char)number;
 82474bc:	e0bffb17 	ldw	r2,-20(fp)
 82474c0:	e0bffc85 	stb	r2,-14(fp)
   }

   if ((number = atoi(cp)) > 255)
 82474c4:	e13ff817 	ldw	r4,-32(fp)
 82474c8:	824b38c0 	call	824b38c <atoi>
 82474cc:	e0bffb15 	stw	r2,-20(fp)
 82474d0:	e0bffb17 	ldw	r2,-20(fp)
 82474d4:	10804010 	cmplti	r2,r2,256
 82474d8:	1000021e 	bne	r2,zero,82474e4 <parse_ipad+0x280>
      return(toobig);
 82474dc:	e0bffa17 	ldw	r2,-24(fp)
 82474e0:	00001a06 	br	824754c <parse_ipad+0x2e8>
   retval.c[3] = (u_char)number;
 82474e4:	e0bffb17 	ldw	r2,-20(fp)
 82474e8:	e0bffcc5 	stb	r2,-13(fp)

   if (retval.c[0] < 128) *sbits = 8;
 82474ec:	e0bffc03 	ldbu	r2,-16(fp)
 82474f0:	10803fcc 	andi	r2,r2,255
 82474f4:	1080201c 	xori	r2,r2,128
 82474f8:	10bfe004 	addi	r2,r2,-128
 82474fc:	10000416 	blt	r2,zero,8247510 <parse_ipad+0x2ac>
 8247500:	e0bffe17 	ldw	r2,-8(fp)
 8247504:	00c00204 	movi	r3,8
 8247508:	10c00015 	stw	r3,0(r2)
 824750c:	00000b06 	br	824753c <parse_ipad+0x2d8>
      else if(retval.c[0] < 192) *sbits = 16;
 8247510:	e0bffc03 	ldbu	r2,-16(fp)
 8247514:	10803fcc 	andi	r2,r2,255
 8247518:	10803028 	cmpgeui	r2,r2,192
 824751c:	1000041e 	bne	r2,zero,8247530 <parse_ipad+0x2cc>
 8247520:	e0bffe17 	ldw	r2,-8(fp)
 8247524:	00c00404 	movi	r3,16
 8247528:	10c00015 	stw	r3,0(r2)
 824752c:	00000306 	br	824753c <parse_ipad+0x2d8>
      else *sbits = 24;
 8247530:	e0bffe17 	ldw	r2,-8(fp)
 8247534:	00c00604 	movi	r3,24
 8247538:	10c00015 	stw	r3,0(r2)

      *ipout = retval.l;      /* everything went OK, return number */
 824753c:	e0fffc17 	ldw	r3,-16(fp)
 8247540:	e0bffd17 	ldw	r2,-12(fp)
 8247544:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 8247548:	0005883a 	mov	r2,zero
}
 824754c:	e037883a 	mov	sp,fp
 8247550:	dfc00117 	ldw	ra,4(sp)
 8247554:	df000017 	ldw	fp,0(sp)
 8247558:	dec00204 	addi	sp,sp,8
 824755c:	f800283a 	ret

08247560 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 8247560:	defffb04 	addi	sp,sp,-20
 8247564:	dfc00415 	stw	ra,16(sp)
 8247568:	df000315 	stw	fp,12(sp)
 824756c:	df000304 	addi	fp,sp,12
 8247570:	e13fff15 	stw	r4,-4(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 8247574:	e17fff17 	ldw	r5,-4(fp)
 8247578:	01020974 	movhi	r4,2085
 824757c:	21112e04 	addi	r4,r4,17592
 8247580:	824b4040 	call	824b404 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 8247584:	e0bffe04 	addi	r2,fp,-8
 8247588:	01820974 	movhi	r6,2085
 824758c:	31912e04 	addi	r6,r6,17592
 8247590:	100b883a 	mov	r5,r2
 8247594:	e13ffd04 	addi	r4,fp,-12
 8247598:	82472640 	call	8247264 <parse_ipad>
 824759c:	1000021e 	bne	r2,zero,82475a8 <inet_addr+0x48>
   {
      return ipaddr ;
 82475a0:	e0bffd17 	ldw	r2,-12(fp)
 82475a4:	00000106 	br	82475ac <inet_addr+0x4c>
   }
   else
   {
      return (u_long)NULL ;
 82475a8:	0005883a 	mov	r2,zero
   }
}
 82475ac:	e037883a 	mov	sp,fp
 82475b0:	dfc00117 	ldw	ra,4(sp)
 82475b4:	df000017 	ldw	fp,0(sp)
 82475b8:	dec00204 	addi	sp,sp,8
 82475bc:	f800283a 	ret

082475c0 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 82475c0:	defffe04 	addi	sp,sp,-8
 82475c4:	df000115 	stw	fp,4(sp)
 82475c8:	df000104 	addi	fp,sp,4
 82475cc:	e13fff15 	stw	r4,-4(fp)
   val &= 0x0f;
 82475d0:	e0bfff17 	ldw	r2,-4(fp)
 82475d4:	108003cc 	andi	r2,r2,15
 82475d8:	e0bfff15 	stw	r2,-4(fp)
   if(val < 10)
 82475dc:	e0bfff17 	ldw	r2,-4(fp)
 82475e0:	10800288 	cmpgei	r2,r2,10
 82475e4:	1000031e 	bne	r2,zero,82475f4 <hextoa+0x34>
      return (char)(val + '0');
 82475e8:	e0bfff17 	ldw	r2,-4(fp)
 82475ec:	10800c04 	addi	r2,r2,48
 82475f0:	00000206 	br	82475fc <hextoa+0x3c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 82475f4:	e0bfff17 	ldw	r2,-4(fp)
 82475f8:	10800dc4 	addi	r2,r2,55
}
 82475fc:	e037883a 	mov	sp,fp
 8247600:	df000017 	ldw	fp,0(sp)
 8247604:	dec00104 	addi	sp,sp,4
 8247608:	f800283a 	ret

0824760c <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 824760c:	defff804 	addi	sp,sp,-32
 8247610:	dfc00715 	stw	ra,28(sp)
 8247614:	df000615 	stw	fp,24(sp)
 8247618:	df000604 	addi	fp,sp,24
 824761c:	e13ffd15 	stw	r4,-12(fp)
 8247620:	e17ffe15 	stw	r5,-8(fp)
 8247624:	e1bfff15 	stw	r6,-4(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 8247628:	e0bffd17 	ldw	r2,-12(fp)
 824762c:	10800098 	cmpnei	r2,r2,2
 8247630:	1000151e 	bne	r2,zero,8247688 <inet_pton+0x7c>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 8247634:	e0fffc04 	addi	r3,fp,-16
 8247638:	e0bffb04 	addi	r2,fp,-20
 824763c:	e1bffe17 	ldw	r6,-8(fp)
 8247640:	180b883a 	mov	r5,r3
 8247644:	1009883a 	mov	r4,r2
 8247648:	82472640 	call	8247264 <parse_ipad>
 824764c:	e0bffa15 	stw	r2,-24(fp)
      if(err == NULL)
 8247650:	e0bffa17 	ldw	r2,-24(fp)
 8247654:	1000071e 	bne	r2,zero,8247674 <inet_pton+0x68>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 8247658:	e0bffb04 	addi	r2,fp,-20
 824765c:	01800104 	movi	r6,4
 8247660:	100b883a 	mov	r5,r2
 8247664:	e13fff17 	ldw	r4,-4(fp)
 8247668:	8202c5c0 	call	8202c5c <memcpy>
         return 0;
 824766c:	0005883a 	mov	r2,zero
 8247670:	00000606 	br	824768c <inet_pton+0x80>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 8247674:	00820974 	movhi	r2,2085
 8247678:	1085f704 	addi	r2,r2,6108
 824767c:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 8247680:	00800044 	movi	r2,1
 8247684:	00000106 	br	824768c <inet_pton+0x80>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 8247688:	0005883a 	mov	r2,zero
}
 824768c:	e037883a 	mov	sp,fp
 8247690:	dfc00117 	ldw	ra,4(sp)
 8247694:	df000017 	ldw	fp,0(sp)
 8247698:	dec00204 	addi	sp,sp,8
 824769c:	f800283a 	ret

082476a0 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 82476a0:	defff804 	addi	sp,sp,-32
 82476a4:	dfc00715 	stw	ra,28(sp)
 82476a8:	df000615 	stw	fp,24(sp)
 82476ac:	df000604 	addi	fp,sp,24
 82476b0:	e13ffc15 	stw	r4,-16(fp)
 82476b4:	e17ffd15 	stw	r5,-12(fp)
 82476b8:	e1bffe15 	stw	r6,-8(fp)
 82476bc:	e1ffff15 	stw	r7,-4(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 82476c0:	e0bffc17 	ldw	r2,-16(fp)
 82476c4:	10800098 	cmpnei	r2,r2,2
 82476c8:	1000101e 	bne	r2,zero,824770c <inet_ntop+0x6c>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 82476cc:	e0bffd17 	ldw	r2,-12(fp)
 82476d0:	10800017 	ldw	r2,0(r2)
 82476d4:	e0bffa15 	stw	r2,-24(fp)
      cp = print_ipad(ip4addr);
 82476d8:	e13ffa17 	ldw	r4,-24(fp)
 82476dc:	82287400 	call	8228740 <print_ipad>
 82476e0:	e0bffb15 	stw	r2,-20(fp)
      if (strlen(cp) < size)
 82476e4:	e13ffb17 	ldw	r4,-20(fp)
 82476e8:	8203cac0 	call	8203cac <strlen>
 82476ec:	1007883a 	mov	r3,r2
 82476f0:	e0bfff17 	ldw	r2,-4(fp)
 82476f4:	1880052e 	bgeu	r3,r2,824770c <inet_ntop+0x6c>
      {
         strcpy(str, cp);
 82476f8:	e17ffb17 	ldw	r5,-20(fp)
 82476fc:	e13ffe17 	ldw	r4,-8(fp)
 8247700:	824b4040 	call	824b404 <strcpy>
         return (str);
 8247704:	e0bffe17 	ldw	r2,-8(fp)
 8247708:	00000106 	br	8247710 <inet_ntop+0x70>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 824770c:	0005883a 	mov	r2,zero
}
 8247710:	e037883a 	mov	sp,fp
 8247714:	dfc00117 	ldw	ra,4(sp)
 8247718:	df000017 	ldw	fp,0(sp)
 824771c:	dec00204 	addi	sp,sp,8
 8247720:	f800283a 	ret

08247724 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 8247724:	defffc04 	addi	sp,sp,-16
 8247728:	dfc00315 	stw	ra,12(sp)
 824772c:	df000215 	stw	fp,8(sp)
 8247730:	df000204 	addi	fp,sp,8
 8247734:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr->sa_family == AF_INET)
 8247738:	e0bfff17 	ldw	r2,-4(fp)
 824773c:	1080000b 	ldhu	r2,0(r2)
 8247740:	10bfffcc 	andi	r2,r2,65535
 8247744:	10800098 	cmpnei	r2,r2,2
 8247748:	1000071e 	bne	r2,zero,8247768 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 824774c:	e0bfff17 	ldw	r2,-4(fp)
 8247750:	e0bffe15 	stw	r2,-8(fp)
      return print_ipad(addr->sin_addr.s_addr);
 8247754:	e0bffe17 	ldw	r2,-8(fp)
 8247758:	10800117 	ldw	r2,4(r2)
 824775c:	1009883a 	mov	r4,r2
 8247760:	82287400 	call	8228740 <print_ipad>
 8247764:	00000106 	br	824776c <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 8247768:	0005883a 	mov	r2,zero
}
 824776c:	e037883a 	mov	sp,fp
 8247770:	dfc00117 	ldw	ra,4(sp)
 8247774:	df000017 	ldw	fp,0(sp)
 8247778:	dec00204 	addi	sp,sp,8
 824777c:	f800283a 	ret

08247780 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 8247780:	defffb04 	addi	sp,sp,-20
 8247784:	dfc00415 	stw	ra,16(sp)
 8247788:	df000315 	stw	fp,12(sp)
 824778c:	df000304 	addi	fp,sp,12
 8247790:	e13ffe15 	stw	r4,-8(fp)
 8247794:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 8247798:	e0bfff17 	ldw	r2,-4(fp)
 824779c:	00c00084 	movi	r3,2
 82477a0:	10c0000d 	sth	r3,0(r2)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 82477a4:	e0bffe17 	ldw	r2,-8(fp)
 82477a8:	10800044 	addi	r2,r2,1
 82477ac:	10800003 	ldbu	r2,0(r2)
 82477b0:	10803fcc 	andi	r2,r2,255
 82477b4:	1080201c 	xori	r2,r2,128
 82477b8:	10bfe004 	addi	r2,r2,-128
 82477bc:	10800ba0 	cmpeqi	r2,r2,46
 82477c0:	1000101e 	bne	r2,zero,8247804 <inet46_addr+0x84>
 82477c4:	e0bffe17 	ldw	r2,-8(fp)
 82477c8:	10800084 	addi	r2,r2,2
 82477cc:	10800003 	ldbu	r2,0(r2)
 82477d0:	10803fcc 	andi	r2,r2,255
 82477d4:	1080201c 	xori	r2,r2,128
 82477d8:	10bfe004 	addi	r2,r2,-128
 82477dc:	10800ba0 	cmpeqi	r2,r2,46
 82477e0:	1000081e 	bne	r2,zero,8247804 <inet46_addr+0x84>
 82477e4:	e0bffe17 	ldw	r2,-8(fp)
 82477e8:	108000c4 	addi	r2,r2,3
 82477ec:	10800003 	ldbu	r2,0(r2)
 82477f0:	10803fcc 	andi	r2,r2,255
 82477f4:	1080201c 	xori	r2,r2,128
 82477f8:	10bfe004 	addi	r2,r2,-128
 82477fc:	10800b98 	cmpnei	r2,r2,46
 8247800:	10000a1e 	bne	r2,zero,824782c <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 8247804:	e0bfff17 	ldw	r2,-4(fp)
 8247808:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 824780c:	e13ffe17 	ldw	r4,-8(fp)
 8247810:	82475600 	call	8247560 <inet_addr>
 8247814:	1007883a 	mov	r3,r2
 8247818:	e0bffd17 	ldw	r2,-12(fp)
 824781c:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 8247820:	e0bffd17 	ldw	r2,-12(fp)
 8247824:	00c00084 	movi	r3,2
 8247828:	10c0000d 	sth	r3,0(r2)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 824782c:	0005883a 	mov	r2,zero
}
 8247830:	e037883a 	mov	sp,fp
 8247834:	dfc00117 	ldw	ra,4(sp)
 8247838:	df000017 	ldw	fp,0(sp)
 824783c:	dec00204 	addi	sp,sp,8
 8247840:	f800283a 	ret

08247844 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 8247844:	defffc04 	addi	sp,sp,-16
 8247848:	df000315 	stw	fp,12(sp)
 824784c:	df000304 	addi	fp,sp,12
 8247850:	e13ffe15 	stw	r4,-8(fp)
 8247854:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 8247858:	e0bffe17 	ldw	r2,-8(fp)
 824785c:	1080000b 	ldhu	r2,0(r2)
 8247860:	10bfffcc 	andi	r2,r2,65535
 8247864:	10800098 	cmpnei	r2,r2,2
 8247868:	10000c1e 	bne	r2,zero,824789c <inet_setport+0x58>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 824786c:	e0bffe17 	ldw	r2,-8(fp)
 8247870:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 8247874:	e0bfff17 	ldw	r2,-4(fp)
 8247878:	1005d23a 	srai	r2,r2,8
 824787c:	10803fcc 	andi	r2,r2,255
 8247880:	1007883a 	mov	r3,r2
 8247884:	e0bfff17 	ldw	r2,-4(fp)
 8247888:	1004923a 	slli	r2,r2,8
 824788c:	1884b03a 	or	r2,r3,r2
 8247890:	1007883a 	mov	r3,r2
 8247894:	e0bffd17 	ldw	r2,-12(fp)
 8247898:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 824789c:	0001883a 	nop
 82478a0:	e037883a 	mov	sp,fp
 82478a4:	df000017 	ldw	fp,0(sp)
 82478a8:	dec00104 	addi	sp,sp,4
 82478ac:	f800283a 	ret

082478b0 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 82478b0:	defff904 	addi	sp,sp,-28
 82478b4:	df000615 	stw	fp,24(sp)
 82478b8:	df000604 	addi	fp,sp,24
 82478bc:	e13fff15 	stw	r4,-4(fp)
   const char *cp = p;
 82478c0:	e0bfff17 	ldw	r2,-4(fp)
 82478c4:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 82478c8:	e0bffe04 	addi	r2,fp,-8
 82478cc:	e0bffd15 	stw	r2,-12(fp)
   int n = 0;
 82478d0:	e03ffb15 	stw	zero,-20(fp)
   unsigned short v = 0;
 82478d4:	e03ffc0d 	sth	zero,-16(fp)
   dw = 0;
 82478d8:	e03ffe15 	stw	zero,-8(fp)
   while(*cp)
 82478dc:	00003106 	br	82479a4 <convert_ip+0xf4>
   {
      if( *cp == '.')
 82478e0:	e0bffa17 	ldw	r2,-24(fp)
 82478e4:	10800003 	ldbu	r2,0(r2)
 82478e8:	10803fcc 	andi	r2,r2,255
 82478ec:	1080201c 	xori	r2,r2,128
 82478f0:	10bfe004 	addi	r2,r2,-128
 82478f4:	10800b98 	cmpnei	r2,r2,46
 82478f8:	10000e1e 	bne	r2,zero,8247934 <convert_ip+0x84>
      {
         lpb[n] = (unsigned char) v;
 82478fc:	e0bffb17 	ldw	r2,-20(fp)
 8247900:	e0fffd17 	ldw	r3,-12(fp)
 8247904:	1885883a 	add	r2,r3,r2
 8247908:	e0fffc0b 	ldhu	r3,-16(fp)
 824790c:	10c00005 	stb	r3,0(r2)
         v = 0;
 8247910:	e03ffc0d 	sth	zero,-16(fp)
         n++;
 8247914:	e0bffb17 	ldw	r2,-20(fp)
 8247918:	10800044 	addi	r2,r2,1
 824791c:	e0bffb15 	stw	r2,-20(fp)
         if(n > 3)
 8247920:	e0bffb17 	ldw	r2,-20(fp)
 8247924:	10800110 	cmplti	r2,r2,4
 8247928:	10001b1e 	bne	r2,zero,8247998 <convert_ip+0xe8>
         {
            return dw;
 824792c:	e0bffe17 	ldw	r2,-8(fp)
 8247930:	00002806 	br	82479d4 <convert_ip+0x124>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 8247934:	e0bffa17 	ldw	r2,-24(fp)
 8247938:	10800003 	ldbu	r2,0(r2)
 824793c:	10803fcc 	andi	r2,r2,255
 8247940:	1080201c 	xori	r2,r2,128
 8247944:	10bfe004 	addi	r2,r2,-128
 8247948:	10800c10 	cmplti	r2,r2,48
 824794c:	1000121e 	bne	r2,zero,8247998 <convert_ip+0xe8>
 8247950:	e0bffa17 	ldw	r2,-24(fp)
 8247954:	10800003 	ldbu	r2,0(r2)
 8247958:	10803fcc 	andi	r2,r2,255
 824795c:	1080201c 	xori	r2,r2,128
 8247960:	10bfe004 	addi	r2,r2,-128
 8247964:	10800e88 	cmpgei	r2,r2,58
 8247968:	10000b1e 	bne	r2,zero,8247998 <convert_ip+0xe8>
      {
         v = (v * 10) + (*cp - '0');
 824796c:	e0bffc0b 	ldhu	r2,-16(fp)
 8247970:	108002a4 	muli	r2,r2,10
 8247974:	1007883a 	mov	r3,r2
 8247978:	e0bffa17 	ldw	r2,-24(fp)
 824797c:	10800003 	ldbu	r2,0(r2)
 8247980:	10803fcc 	andi	r2,r2,255
 8247984:	1080201c 	xori	r2,r2,128
 8247988:	10bfe004 	addi	r2,r2,-128
 824798c:	1885883a 	add	r2,r3,r2
 8247990:	10bff404 	addi	r2,r2,-48
 8247994:	e0bffc0d 	sth	r2,-16(fp)
      }
      cp++;
 8247998:	e0bffa17 	ldw	r2,-24(fp)
 824799c:	10800044 	addi	r2,r2,1
 82479a0:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 82479a4:	e0bffa17 	ldw	r2,-24(fp)
 82479a8:	10800003 	ldbu	r2,0(r2)
 82479ac:	10803fcc 	andi	r2,r2,255
 82479b0:	1080201c 	xori	r2,r2,128
 82479b4:	10bfe004 	addi	r2,r2,-128
 82479b8:	103fc91e 	bne	r2,zero,82478e0 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 82479bc:	e0bffb17 	ldw	r2,-20(fp)
 82479c0:	e0fffd17 	ldw	r3,-12(fp)
 82479c4:	1885883a 	add	r2,r3,r2
 82479c8:	e0fffc0b 	ldhu	r3,-16(fp)
 82479cc:	10c00005 	stb	r3,0(r2)
   return dw;
 82479d0:	e0bffe17 	ldw	r2,-8(fp)
}  /* convert_ip() */
 82479d4:	e037883a 	mov	sp,fp
 82479d8:	df000017 	ldw	fp,0(sp)
 82479dc:	dec00104 	addi	sp,sp,4
 82479e0:	f800283a 	ret

082479e4 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 82479e4:	defff704 	addi	sp,sp,-36
 82479e8:	dfc00815 	stw	ra,32(sp)
 82479ec:	df000715 	stw	fp,28(sp)
 82479f0:	df000704 	addi	fp,sp,28
 82479f4:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 82479f8:	e03ffa15 	stw	zero,-24(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 82479fc:	e03ffb05 	stb	zero,-20(fp)

   iphlen = (unshort)ip_hlen(pip);
 8247a00:	e0bfff17 	ldw	r2,-4(fp)
 8247a04:	10800003 	ldbu	r2,0(r2)
 8247a08:	10803fcc 	andi	r2,r2,255
 8247a0c:	108003cc 	andi	r2,r2,15
 8247a10:	1085883a 	add	r2,r2,r2
 8247a14:	1085883a 	add	r2,r2,r2
 8247a18:	e0bffc0d 	sth	r2,-16(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 8247a1c:	e0bfff17 	ldw	r2,-4(fp)
 8247a20:	1080008b 	ldhu	r2,2(r2)
 8247a24:	10bfffcc 	andi	r2,r2,65535
 8247a28:	1004d23a 	srli	r2,r2,8
 8247a2c:	1007883a 	mov	r3,r2
 8247a30:	e0bfff17 	ldw	r2,-4(fp)
 8247a34:	1080008b 	ldhu	r2,2(r2)
 8247a38:	10bfffcc 	andi	r2,r2,65535
 8247a3c:	1004923a 	slli	r2,r2,8
 8247a40:	1884b03a 	or	r2,r3,r2
 8247a44:	1007883a 	mov	r3,r2
 8247a48:	e0bffc0b 	ldhu	r2,-16(fp)
 8247a4c:	1885c83a 	sub	r2,r3,r2
 8247a50:	e0bff90d 	sth	r2,-28(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 8247a54:	e0bfff17 	ldw	r2,-4(fp)
 8247a58:	10800003 	ldbu	r2,0(r2)
 8247a5c:	10803fcc 	andi	r2,r2,255
 8247a60:	108003cc 	andi	r2,r2,15
 8247a64:	1085883a 	add	r2,r2,r2
 8247a68:	1085883a 	add	r2,r2,r2
 8247a6c:	1007883a 	mov	r3,r2
 8247a70:	e0bfff17 	ldw	r2,-4(fp)
 8247a74:	10c5883a 	add	r2,r2,r3
 8247a78:	e0bffd15 	stw	r2,-12(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 8247a7c:	e0bffd17 	ldw	r2,-12(fp)
 8247a80:	1080040b 	ldhu	r2,16(r2)
 8247a84:	e0bffe0d 	sth	r2,-8(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 8247a88:	e0bff90b 	ldhu	r2,-28(fp)
 8247a8c:	10800184 	addi	r2,r2,6
 8247a90:	1005d23a 	srai	r2,r2,8
 8247a94:	10803fcc 	andi	r2,r2,255
 8247a98:	1007883a 	mov	r3,r2
 8247a9c:	e0bff90b 	ldhu	r2,-28(fp)
 8247aa0:	10800184 	addi	r2,r2,6
 8247aa4:	1004923a 	slli	r2,r2,8
 8247aa8:	1884b03a 	or	r2,r3,r2
 8247aac:	1007883a 	mov	r3,r2
 8247ab0:	e0bffd17 	ldw	r2,-12(fp)
 8247ab4:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 8247ab8:	e0bff90b 	ldhu	r2,-28(fp)
 8247abc:	1080004c 	andi	r2,r2,1
 8247ac0:	10000e26 	beq	r2,zero,8247afc <tcp_cksum+0x118>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 8247ac4:	e0fffc0b 	ldhu	r3,-16(fp)
 8247ac8:	e0bff90b 	ldhu	r2,-28(fp)
 8247acc:	1885883a 	add	r2,r3,r2
 8247ad0:	e0ffff17 	ldw	r3,-4(fp)
 8247ad4:	1885883a 	add	r2,r3,r2
 8247ad8:	e0bffa15 	stw	r2,-24(fp)
      oddchar = *tcpdata;
 8247adc:	e0bffa17 	ldw	r2,-24(fp)
 8247ae0:	10800003 	ldbu	r2,0(r2)
 8247ae4:	e0bffb05 	stb	r2,-20(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 8247ae8:	e0bffa17 	ldw	r2,-24(fp)
 8247aec:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 8247af0:	e0bff90b 	ldhu	r2,-28(fp)
 8247af4:	10800044 	addi	r2,r2,1
 8247af8:	e0bff90d 	sth	r2,-28(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 8247afc:	e0bffd17 	ldw	r2,-12(fp)
 8247b00:	10fffe04 	addi	r3,r2,-8
 8247b04:	e0bff90b 	ldhu	r2,-28(fp)
 8247b08:	10800204 	addi	r2,r2,8
 8247b0c:	1005d07a 	srai	r2,r2,1
 8247b10:	100b883a 	mov	r5,r2
 8247b14:	1809883a 	mov	r4,r3
 8247b18:	82285000 	call	8228500 <cksum>
 8247b1c:	0084303a 	nor	r2,zero,r2
 8247b20:	e0bffb8d 	sth	r2,-18(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 8247b24:	e0fffb8b 	ldhu	r3,-18(fp)
 8247b28:	e0bffe0b 	ldhu	r2,-8(fp)
 8247b2c:	18800726 	beq	r3,r2,8247b4c <tcp_cksum+0x168>
 8247b30:	e0fffe0b 	ldhu	r3,-8(fp)
 8247b34:	00bfffd4 	movui	r2,65535
 8247b38:	1880041e 	bne	r3,r2,8247b4c <tcp_cksum+0x168>
 8247b3c:	e0bffb8b 	ldhu	r2,-18(fp)
 8247b40:	1000021e 	bne	r2,zero,8247b4c <tcp_cksum+0x168>
      newsum = 0xffff;
 8247b44:	00bfffc4 	movi	r2,-1
 8247b48:	e0bffb8d 	sth	r2,-18(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 8247b4c:	e0bffd17 	ldw	r2,-12(fp)
 8247b50:	e0fffe0b 	ldhu	r3,-8(fp)
 8247b54:	10c0040d 	sth	r3,16(r2)
   if (oddchar)
 8247b58:	e0bffb07 	ldb	r2,-20(fp)
 8247b5c:	10000326 	beq	r2,zero,8247b6c <tcp_cksum+0x188>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 8247b60:	e0bffa17 	ldw	r2,-24(fp)
 8247b64:	e0fffb03 	ldbu	r3,-20(fp)
 8247b68:	10c00005 	stb	r3,0(r2)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 8247b6c:	e0bffb8b 	ldhu	r2,-18(fp)
}
 8247b70:	e037883a 	mov	sp,fp
 8247b74:	dfc00117 	ldw	ra,4(sp)
 8247b78:	df000017 	ldw	fp,0(sp)
 8247b7c:	dec00204 	addi	sp,sp,8
 8247b80:	f800283a 	ret

08247b84 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 8247b84:	defffb04 	addi	sp,sp,-20
 8247b88:	dfc00415 	stw	ra,16(sp)
 8247b8c:	df000315 	stw	fp,12(sp)
 8247b90:	df000304 	addi	fp,sp,12
 8247b94:	e13ffe15 	stw	r4,-8(fp)
 8247b98:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 8247b9c:	01000b04 	movi	r4,44
 8247ba0:	822deb80 	call	822deb8 <npalloc>
 8247ba4:	e0bffd15 	stw	r2,-12(fp)
   if (inp == 0)
 8247ba8:	e0bffd17 	ldw	r2,-12(fp)
 8247bac:	1000021e 	bne	r2,zero,8247bb8 <in_pcballoc+0x34>
      return ENOMEM;
 8247bb0:	00800304 	movi	r2,12
 8247bb4:	00001006 	br	8247bf8 <in_pcballoc+0x74>
   inp->inp_head = head;
 8247bb8:	e0bffd17 	ldw	r2,-12(fp)
 8247bbc:	e0ffff17 	ldw	r3,-4(fp)
 8247bc0:	10c00215 	stw	r3,8(r2)
   inp->inp_socket = so;
 8247bc4:	e0bffd17 	ldw	r2,-12(fp)
 8247bc8:	e0fffe17 	ldw	r3,-8(fp)
 8247bcc:	10c00815 	stw	r3,32(r2)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 8247bd0:	e0bffd17 	ldw	r2,-12(fp)
 8247bd4:	00c08004 	movi	r3,512
 8247bd8:	10c00615 	stw	r3,24(r2)
   insque(inp, head);
 8247bdc:	e17fff17 	ldw	r5,-4(fp)
 8247be0:	e13ffd17 	ldw	r4,-12(fp)
 8247be4:	822e9dc0 	call	822e9dc <insque>
   so->so_pcb = inp;
 8247be8:	e0bffe17 	ldw	r2,-8(fp)
 8247bec:	e0fffd17 	ldw	r3,-12(fp)
 8247bf0:	10c00115 	stw	r3,4(r2)
   return 0;
 8247bf4:	0005883a 	mov	r2,zero
}
 8247bf8:	e037883a 	mov	sp,fp
 8247bfc:	dfc00117 	ldw	ra,4(sp)
 8247c00:	df000017 	ldw	fp,0(sp)
 8247c04:	dec00204 	addi	sp,sp,8
 8247c08:	f800283a 	ret

08247c0c <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 8247c0c:	defffc04 	addi	sp,sp,-16
 8247c10:	dfc00315 	stw	ra,12(sp)
 8247c14:	df000215 	stw	fp,8(sp)
 8247c18:	df000204 	addi	fp,sp,8
 8247c1c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247c20:	e0bfff17 	ldw	r2,-4(fp)
 8247c24:	10800817 	ldw	r2,32(r2)
 8247c28:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 8247c2c:	e0bffe17 	ldw	r2,-8(fp)
 8247c30:	10000115 	stw	zero,4(r2)
   sofree(so);
 8247c34:	e13ffe17 	ldw	r4,-8(fp)
 8247c38:	8231a540 	call	8231a54 <sofree>
   remque(inp);
 8247c3c:	e13fff17 	ldw	r4,-4(fp)
 8247c40:	822e96c0 	call	822e96c <remque>
   INP_FREE (inp);
 8247c44:	e13fff17 	ldw	r4,-4(fp)
 8247c48:	822deec0 	call	822deec <npfree>
}
 8247c4c:	0001883a 	nop
 8247c50:	e037883a 	mov	sp,fp
 8247c54:	dfc00117 	ldw	ra,4(sp)
 8247c58:	df000017 	ldw	fp,0(sp)
 8247c5c:	dec00204 	addi	sp,sp,8
 8247c60:	f800283a 	ret

08247c64 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8247c64:	defff504 	addi	sp,sp,-44
 8247c68:	dfc00a15 	stw	ra,40(sp)
 8247c6c:	df000915 	stw	fp,36(sp)
 8247c70:	df000904 	addi	fp,sp,36
 8247c74:	e13ffe15 	stw	r4,-8(fp)
 8247c78:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247c7c:	e0bffe17 	ldw	r2,-8(fp)
 8247c80:	10800817 	ldw	r2,32(r2)
 8247c84:	e0bffb15 	stw	r2,-20(fp)
   struct inpcb * head  =  inp->inp_head;
 8247c88:	e0bffe17 	ldw	r2,-8(fp)
 8247c8c:	10800217 	ldw	r2,8(r2)
 8247c90:	e0bffc15 	stw	r2,-16(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 8247c94:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 8247c98:	e0bffe17 	ldw	r2,-8(fp)
 8247c9c:	1080078b 	ldhu	r2,30(r2)
 8247ca0:	10bfffcc 	andi	r2,r2,65535
 8247ca4:	1000031e 	bne	r2,zero,8247cb4 <in_pcbbind+0x50>
 8247ca8:	e0bffe17 	ldw	r2,-8(fp)
 8247cac:	10800417 	ldw	r2,16(r2)
 8247cb0:	10000226 	beq	r2,zero,8247cbc <in_pcbbind+0x58>
      return (EINVAL);
 8247cb4:	00800584 	movi	r2,22
 8247cb8:	00006906 	br	8247e60 <in_pcbbind+0x1fc>
   if (nam == 0)
 8247cbc:	e0bfff17 	ldw	r2,-4(fp)
 8247cc0:	10003926 	beq	r2,zero,8247da8 <in_pcbbind+0x144>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 8247cc4:	e0bfff17 	ldw	r2,-4(fp)
 8247cc8:	10800317 	ldw	r2,12(r2)
 8247ccc:	e0bffd15 	stw	r2,-12(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 8247cd0:	e0bffd17 	ldw	r2,-12(fp)
 8247cd4:	10800117 	ldw	r2,4(r2)
 8247cd8:	10000a26 	beq	r2,zero,8247d04 <in_pcbbind+0xa0>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 8247cdc:	e0bffd17 	ldw	r2,-12(fp)
 8247ce0:	10800117 	ldw	r2,4(r2)
 8247ce4:	1009883a 	mov	r4,r2
 8247ce8:	82406e80 	call	82406e8 <ip_mymach>
 8247cec:	1007883a 	mov	r3,r2
 8247cf0:	e0bffd17 	ldw	r2,-12(fp)
 8247cf4:	10800117 	ldw	r2,4(r2)
 8247cf8:	18800226 	beq	r3,r2,8247d04 <in_pcbbind+0xa0>
      return (EADDRNOTAVAIL);
 8247cfc:	00801f44 	movi	r2,125
 8247d00:	00005706 	br	8247e60 <in_pcbbind+0x1fc>
   }
   lport = sin->sin_port;
 8247d04:	e0bffd17 	ldw	r2,-12(fp)
 8247d08:	1080008b 	ldhu	r2,2(r2)
 8247d0c:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 8247d10:	e0bff90b 	ldhu	r2,-28(fp)
 8247d14:	10001f26 	beq	r2,zero,8247d94 <in_pcbbind+0x130>
   {
      int   wild  =  0;
 8247d18:	e03ffa15 	stw	zero,-24(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247d1c:	e0bffb17 	ldw	r2,-20(fp)
 8247d20:	10800417 	ldw	r2,16(r2)
 8247d24:	1080010c 	andi	r2,r2,4
 8247d28:	10000c1e 	bne	r2,zero,8247d5c <in_pcbbind+0xf8>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247d2c:	e0bffb17 	ldw	r2,-20(fp)
 8247d30:	10800217 	ldw	r2,8(r2)
 8247d34:	1080010b 	ldhu	r2,4(r2)
 8247d38:	10bfffcc 	andi	r2,r2,65535
 8247d3c:	1080010c 	andi	r2,r2,4
   if (lport) 
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247d40:	10000426 	beq	r2,zero,8247d54 <in_pcbbind+0xf0>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
 8247d44:	e0bffb17 	ldw	r2,-20(fp)
 8247d48:	10800417 	ldw	r2,16(r2)
 8247d4c:	1080008c 	andi	r2,r2,2
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247d50:	1000021e 	bne	r2,zero,8247d5c <in_pcbbind+0xf8>
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 8247d54:	00800044 	movi	r2,1
 8247d58:	e0bffa15 	stw	r2,-24(fp)
      }
      if (in_pcblookup(head,
 8247d5c:	e0bffd17 	ldw	r2,-12(fp)
 8247d60:	11000117 	ldw	r4,4(r2)
 8247d64:	e0bff90b 	ldhu	r2,-28(fp)
 8247d68:	e0fffa17 	ldw	r3,-24(fp)
 8247d6c:	d8c00115 	stw	r3,4(sp)
 8247d70:	d8800015 	stw	r2,0(sp)
 8247d74:	200f883a 	mov	r7,r4
 8247d78:	000d883a 	mov	r6,zero
 8247d7c:	000b883a 	mov	r5,zero
 8247d80:	e13ffc17 	ldw	r4,-16(fp)
 8247d84:	82481b80 	call	82481b8 <in_pcblookup>
 8247d88:	10000226 	beq	r2,zero,8247d94 <in_pcbbind+0x130>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 8247d8c:	00801c04 	movi	r2,112
 8247d90:	00003306 	br	8247e60 <in_pcbbind+0x1fc>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 8247d94:	e0bffe17 	ldw	r2,-8(fp)
 8247d98:	e0fffd17 	ldw	r3,-12(fp)
 8247d9c:	18c00117 	ldw	r3,4(r3)
 8247da0:	10c00415 	stw	r3,16(r2)
 8247da4:	00000106 	br	8247dac <in_pcbbind+0x148>


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
      return (EINVAL);
   if (nam == 0)
      goto noname;
 8247da8:	0001883a 	nop
         return (EADDRINUSE);
      }
   }
   inp->inp_laddr = sin->sin_addr;
noname:
   if (lport == 0)
 8247dac:	e0bff90b 	ldhu	r2,-28(fp)
 8247db0:	1000271e 	bne	r2,zero,8247e50 <in_pcbbind+0x1ec>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8247db4:	e0bffc17 	ldw	r2,-16(fp)
 8247db8:	1080078b 	ldhu	r2,30(r2)
 8247dbc:	10c00044 	addi	r3,r2,1
 8247dc0:	1809883a 	mov	r4,r3
 8247dc4:	e0fffc17 	ldw	r3,-16(fp)
 8247dc8:	1900078d 	sth	r4,30(r3)
 8247dcc:	10bfffcc 	andi	r2,r2,65535
 8247dd0:	10810030 	cmpltui	r2,r2,1024
 8247dd4:	1000051e 	bne	r2,zero,8247dec <in_pcbbind+0x188>
             head->inp_lport > IPPORT_USERRESERVED)
 8247dd8:	e0bffc17 	ldw	r2,-16(fp)
 8247ddc:	1080078b 	ldhu	r2,30(r2)
noname:
   if (lport == 0)
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8247de0:	10bfffcc 	andi	r2,r2,65535
 8247de4:	1084e270 	cmpltui	r2,r2,5001
 8247de8:	1000031e 	bne	r2,zero,8247df8 <in_pcbbind+0x194>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 8247dec:	e0bffc17 	ldw	r2,-16(fp)
 8247df0:	00c10004 	movi	r3,1024
 8247df4:	10c0078d 	sth	r3,30(r2)
         }
         lport = htons(head->inp_lport);
 8247df8:	e0bffc17 	ldw	r2,-16(fp)
 8247dfc:	1080078b 	ldhu	r2,30(r2)
 8247e00:	10bfffcc 	andi	r2,r2,65535
 8247e04:	1004d23a 	srli	r2,r2,8
 8247e08:	1007883a 	mov	r3,r2
 8247e0c:	e0bffc17 	ldw	r2,-16(fp)
 8247e10:	1080078b 	ldhu	r2,30(r2)
 8247e14:	10bfffcc 	andi	r2,r2,65535
 8247e18:	1004923a 	slli	r2,r2,8
 8247e1c:	1884b03a 	or	r2,r3,r2
 8247e20:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 8247e24:	e0bffe17 	ldw	r2,-8(fp)
 8247e28:	10c00417 	ldw	r3,16(r2)
 8247e2c:	e0bff90b 	ldhu	r2,-28(fp)
 8247e30:	d8000115 	stw	zero,4(sp)
 8247e34:	d8800015 	stw	r2,0(sp)
 8247e38:	180f883a 	mov	r7,r3
 8247e3c:	000d883a 	mov	r6,zero
 8247e40:	000b883a 	mov	r5,zero
 8247e44:	e13ffc17 	ldw	r4,-16(fp)
 8247e48:	82481b80 	call	82481b8 <in_pcblookup>
 8247e4c:	103fd91e 	bne	r2,zero,8247db4 <in_pcbbind+0x150>
   }
   inp->inp_lport = lport;
 8247e50:	e0bffe17 	ldw	r2,-8(fp)
 8247e54:	e0fff90b 	ldhu	r3,-28(fp)
 8247e58:	10c0078d 	sth	r3,30(r2)
   return (0);
 8247e5c:	0005883a 	mov	r2,zero
}
 8247e60:	e037883a 	mov	sp,fp
 8247e64:	dfc00117 	ldw	ra,4(sp)
 8247e68:	df000017 	ldw	fp,0(sp)
 8247e6c:	dec00204 	addi	sp,sp,8
 8247e70:	f800283a 	ret

08247e74 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8247e74:	defff604 	addi	sp,sp,-40
 8247e78:	dfc00915 	stw	ra,36(sp)
 8247e7c:	df000815 	stw	fp,32(sp)
 8247e80:	df000804 	addi	fp,sp,32
 8247e84:	e13ffe15 	stw	r4,-8(fp)
 8247e88:	e17fff15 	stw	r5,-4(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 8247e8c:	e0bfff17 	ldw	r2,-4(fp)
 8247e90:	10800317 	ldw	r2,12(r2)
 8247e94:	e0bffb15 	stw	r2,-20(fp)

   if (nam->m_len < sizeof (*sin))
 8247e98:	e0bfff17 	ldw	r2,-4(fp)
 8247e9c:	10800217 	ldw	r2,8(r2)
 8247ea0:	10800428 	cmpgeui	r2,r2,16
 8247ea4:	1000021e 	bne	r2,zero,8247eb0 <in_pcbconnect+0x3c>
      return (EINVAL);
 8247ea8:	00800584 	movi	r2,22
 8247eac:	00006406 	br	8248040 <in_pcbconnect+0x1cc>
   if (sin->sin_family != AF_INET)
 8247eb0:	e0bffb17 	ldw	r2,-20(fp)
 8247eb4:	1080000b 	ldhu	r2,0(r2)
 8247eb8:	10bfffcc 	andi	r2,r2,65535
 8247ebc:	10a0001c 	xori	r2,r2,32768
 8247ec0:	10a00004 	addi	r2,r2,-32768
 8247ec4:	108000a0 	cmpeqi	r2,r2,2
 8247ec8:	1000021e 	bne	r2,zero,8247ed4 <in_pcbconnect+0x60>
      return (EAFNOSUPPORT);
 8247ecc:	00801a84 	movi	r2,106
 8247ed0:	00005b06 	br	8248040 <in_pcbconnect+0x1cc>
   if (sin->sin_port == 0)
 8247ed4:	e0bffb17 	ldw	r2,-20(fp)
 8247ed8:	1080008b 	ldhu	r2,2(r2)
 8247edc:	10bfffcc 	andi	r2,r2,65535
 8247ee0:	1000021e 	bne	r2,zero,8247eec <in_pcbconnect+0x78>
      return (EADDRNOTAVAIL);
 8247ee4:	00801f44 	movi	r2,125
 8247ee8:	00005506 	br	8248040 <in_pcbconnect+0x1cc>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 8247eec:	e0bffb17 	ldw	r2,-20(fp)
 8247ef0:	10800117 	ldw	r2,4(r2)
 8247ef4:	10000d1e 	bne	r2,zero,8247f2c <in_pcbconnect+0xb8>
   {
      if (inp && inp->ifp)
 8247ef8:	e0bffe17 	ldw	r2,-8(fp)
 8247efc:	10000926 	beq	r2,zero,8247f24 <in_pcbconnect+0xb0>
 8247f00:	e0bffe17 	ldw	r2,-8(fp)
 8247f04:	10800a17 	ldw	r2,40(r2)
 8247f08:	10000626 	beq	r2,zero,8247f24 <in_pcbconnect+0xb0>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 8247f0c:	e0bffe17 	ldw	r2,-8(fp)
 8247f10:	10800a17 	ldw	r2,40(r2)
 8247f14:	10c00a17 	ldw	r3,40(r2)
 8247f18:	e0bffb17 	ldw	r2,-20(fp)
 8247f1c:	10c00115 	stw	r3,4(r2)
 8247f20:	00000806 	br	8247f44 <in_pcbconnect+0xd0>
      else
         return (EADDRNOTAVAIL);
 8247f24:	00801f44 	movi	r2,125
 8247f28:	00004506 	br	8248040 <in_pcbconnect+0x1cc>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 8247f2c:	e0bffb17 	ldw	r2,-20(fp)
 8247f30:	10800117 	ldw	r2,4(r2)
 8247f34:	10bfffd8 	cmpnei	r2,r2,-1
 8247f38:	1000021e 	bne	r2,zero,8247f44 <in_pcbconnect+0xd0>
      return (EADDRNOTAVAIL);
 8247f3c:	00801f44 	movi	r2,125
 8247f40:	00003f06 	br	8248040 <in_pcbconnect+0x1cc>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 8247f44:	e0bffe17 	ldw	r2,-8(fp)
 8247f48:	10800417 	ldw	r2,16(r2)
 8247f4c:	10000f1e 	bne	r2,zero,8247f8c <in_pcbconnect+0x118>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 8247f50:	e0bffb17 	ldw	r2,-20(fp)
 8247f54:	10800117 	ldw	r2,4(r2)
 8247f58:	e0fffd04 	addi	r3,fp,-12
 8247f5c:	180b883a 	mov	r5,r3
 8247f60:	1009883a 	mov	r4,r2
 8247f64:	8240a340 	call	8240a34 <iproute>
 8247f68:	e0bffc15 	stw	r2,-16(fp)
      if (!npnet)
 8247f6c:	e0bffc17 	ldw	r2,-16(fp)
 8247f70:	1000021e 	bne	r2,zero,8247f7c <in_pcbconnect+0x108>
         return EADDRNOTAVAIL;
 8247f74:	00801f44 	movi	r2,125
 8247f78:	00003106 	br	8248040 <in_pcbconnect+0x1cc>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 8247f7c:	e0bffc17 	ldw	r2,-16(fp)
 8247f80:	10800a17 	ldw	r2,40(r2)
 8247f84:	e0bffa15 	stw	r2,-24(fp)
 8247f88:	00000306 	br	8247f98 <in_pcbconnect+0x124>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 8247f8c:	e0bffe17 	ldw	r2,-8(fp)
 8247f90:	10800417 	ldw	r2,16(r2)
 8247f94:	e0bffa15 	stw	r2,-24(fp)

   if (in_pcblookup(inp->inp_head,
 8247f98:	e0bffe17 	ldw	r2,-8(fp)
 8247f9c:	10c00217 	ldw	r3,8(r2)
 8247fa0:	e0bffb17 	ldw	r2,-20(fp)
 8247fa4:	11000117 	ldw	r4,4(r2)
       sin->sin_addr.s_addr,
       sin->sin_port,
 8247fa8:	e0bffb17 	ldw	r2,-20(fp)
 8247fac:	1080008b 	ldhu	r2,2(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 8247fb0:	117fffcc 	andi	r5,r2,65535
       sin->sin_addr.s_addr,
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
 8247fb4:	e0bffe17 	ldw	r2,-8(fp)
 8247fb8:	1080078b 	ldhu	r2,30(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 8247fbc:	10bfffcc 	andi	r2,r2,65535
 8247fc0:	d8000115 	stw	zero,4(sp)
 8247fc4:	d8800015 	stw	r2,0(sp)
 8247fc8:	e1fffa17 	ldw	r7,-24(fp)
 8247fcc:	280d883a 	mov	r6,r5
 8247fd0:	200b883a 	mov	r5,r4
 8247fd4:	1809883a 	mov	r4,r3
 8247fd8:	82481b80 	call	82481b8 <in_pcblookup>
 8247fdc:	10000226 	beq	r2,zero,8247fe8 <in_pcbconnect+0x174>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 8247fe0:	00801c04 	movi	r2,112
 8247fe4:	00001606 	br	8248040 <in_pcbconnect+0x1cc>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 8247fe8:	e0bffe17 	ldw	r2,-8(fp)
 8247fec:	10800417 	ldw	r2,16(r2)
 8247ff0:	10000a1e 	bne	r2,zero,824801c <in_pcbconnect+0x1a8>
   {
      if (inp->inp_lport == 0)
 8247ff4:	e0bffe17 	ldw	r2,-8(fp)
 8247ff8:	1080078b 	ldhu	r2,30(r2)
 8247ffc:	10bfffcc 	andi	r2,r2,65535
 8248000:	1000031e 	bne	r2,zero,8248010 <in_pcbconnect+0x19c>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 8248004:	000b883a 	mov	r5,zero
 8248008:	e13ffe17 	ldw	r4,-8(fp)
 824800c:	8247c640 	call	8247c64 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 8248010:	e0bffe17 	ldw	r2,-8(fp)
 8248014:	e0fffa17 	ldw	r3,-24(fp)
 8248018:	10c00415 	stw	r3,16(r2)
   }
   inp->inp_faddr = sin->sin_addr;
 824801c:	e0bffe17 	ldw	r2,-8(fp)
 8248020:	e0fffb17 	ldw	r3,-20(fp)
 8248024:	18c00117 	ldw	r3,4(r3)
 8248028:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 824802c:	e0bffb17 	ldw	r2,-20(fp)
 8248030:	10c0008b 	ldhu	r3,2(r2)
 8248034:	e0bffe17 	ldw	r2,-8(fp)
 8248038:	10c0070d 	sth	r3,28(r2)
   return 0;
 824803c:	0005883a 	mov	r2,zero
}
 8248040:	e037883a 	mov	sp,fp
 8248044:	dfc00117 	ldw	ra,4(sp)
 8248048:	df000017 	ldw	fp,0(sp)
 824804c:	dec00204 	addi	sp,sp,8
 8248050:	f800283a 	ret

08248054 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 8248054:	defffd04 	addi	sp,sp,-12
 8248058:	dfc00215 	stw	ra,8(sp)
 824805c:	df000115 	stw	fp,4(sp)
 8248060:	df000104 	addi	fp,sp,4
 8248064:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 8248068:	e0bfff17 	ldw	r2,-4(fp)
 824806c:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 8248070:	e0bfff17 	ldw	r2,-4(fp)
 8248074:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 8248078:	e0bfff17 	ldw	r2,-4(fp)
 824807c:	10800817 	ldw	r2,32(r2)
 8248080:	1080088b 	ldhu	r2,34(r2)
 8248084:	10bfffcc 	andi	r2,r2,65535
 8248088:	1080004c 	andi	r2,r2,1
 824808c:	10000226 	beq	r2,zero,8248098 <in_pcbdisconnect+0x44>
      in_pcbdetach (inp);
 8248090:	e13fff17 	ldw	r4,-4(fp)
 8248094:	8247c0c0 	call	8247c0c <in_pcbdetach>
}
 8248098:	0001883a 	nop
 824809c:	e037883a 	mov	sp,fp
 82480a0:	dfc00117 	ldw	ra,4(sp)
 82480a4:	df000017 	ldw	fp,0(sp)
 82480a8:	dec00204 	addi	sp,sp,8
 82480ac:	f800283a 	ret

082480b0 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 82480b0:	defffb04 	addi	sp,sp,-20
 82480b4:	dfc00415 	stw	ra,16(sp)
 82480b8:	df000315 	stw	fp,12(sp)
 82480bc:	df000304 	addi	fp,sp,12
 82480c0:	e13ffe15 	stw	r4,-8(fp)
 82480c4:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 82480c8:	e0bfff17 	ldw	r2,-4(fp)
 82480cc:	00c00404 	movi	r3,16
 82480d0:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 82480d4:	e0bfff17 	ldw	r2,-4(fp)
 82480d8:	10800317 	ldw	r2,12(r2)
 82480dc:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 82480e0:	01800404 	movi	r6,16
 82480e4:	000b883a 	mov	r5,zero
 82480e8:	e13ffd17 	ldw	r4,-12(fp)
 82480ec:	8202f000 	call	8202f00 <memset>
   sin->sin_family = AF_INET;
 82480f0:	e0bffd17 	ldw	r2,-12(fp)
 82480f4:	00c00084 	movi	r3,2
 82480f8:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_lport;
 82480fc:	e0bffe17 	ldw	r2,-8(fp)
 8248100:	10c0078b 	ldhu	r3,30(r2)
 8248104:	e0bffd17 	ldw	r2,-12(fp)
 8248108:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 824810c:	e0bffd17 	ldw	r2,-12(fp)
 8248110:	e0fffe17 	ldw	r3,-8(fp)
 8248114:	18c00417 	ldw	r3,16(r3)
 8248118:	10c00115 	stw	r3,4(r2)
}
 824811c:	0001883a 	nop
 8248120:	e037883a 	mov	sp,fp
 8248124:	dfc00117 	ldw	ra,4(sp)
 8248128:	df000017 	ldw	fp,0(sp)
 824812c:	dec00204 	addi	sp,sp,8
 8248130:	f800283a 	ret

08248134 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8248134:	defffb04 	addi	sp,sp,-20
 8248138:	dfc00415 	stw	ra,16(sp)
 824813c:	df000315 	stw	fp,12(sp)
 8248140:	df000304 	addi	fp,sp,12
 8248144:	e13ffe15 	stw	r4,-8(fp)
 8248148:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 824814c:	e0bfff17 	ldw	r2,-4(fp)
 8248150:	00c00404 	movi	r3,16
 8248154:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 8248158:	e0bfff17 	ldw	r2,-4(fp)
 824815c:	10800317 	ldw	r2,12(r2)
 8248160:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 8248164:	01800404 	movi	r6,16
 8248168:	000b883a 	mov	r5,zero
 824816c:	e13ffd17 	ldw	r4,-12(fp)
 8248170:	8202f000 	call	8202f00 <memset>
   sin->sin_family = AF_INET;
 8248174:	e0bffd17 	ldw	r2,-12(fp)
 8248178:	00c00084 	movi	r3,2
 824817c:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_fport;
 8248180:	e0bffe17 	ldw	r2,-8(fp)
 8248184:	10c0070b 	ldhu	r3,28(r2)
 8248188:	e0bffd17 	ldw	r2,-12(fp)
 824818c:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 8248190:	e0bffd17 	ldw	r2,-12(fp)
 8248194:	e0fffe17 	ldw	r3,-8(fp)
 8248198:	18c00317 	ldw	r3,12(r3)
 824819c:	10c00115 	stw	r3,4(r2)
}
 82481a0:	0001883a 	nop
 82481a4:	e037883a 	mov	sp,fp
 82481a8:	dfc00117 	ldw	ra,4(sp)
 82481ac:	df000017 	ldw	fp,0(sp)
 82481b0:	dec00204 	addi	sp,sp,8
 82481b4:	f800283a 	ret

082481b8 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 82481b8:	defff504 	addi	sp,sp,-44
 82481bc:	df000a15 	stw	fp,40(sp)
 82481c0:	df000a04 	addi	fp,sp,40
 82481c4:	e13ffb15 	stw	r4,-20(fp)
 82481c8:	e17ffc15 	stw	r5,-16(fp)
 82481cc:	3007883a 	mov	r3,r6
 82481d0:	e1fffe15 	stw	r7,-8(fp)
 82481d4:	e0800117 	ldw	r2,4(fp)
 82481d8:	e0fffd0d 	sth	r3,-12(fp)
 82481dc:	e0bfff0d 	sth	r2,-4(fp)
   struct inpcb * inp, *   match =  0;
 82481e0:	e03ff715 	stw	zero,-36(fp)
   unshort  fport =  xfport; 
 82481e4:	e0bffd0b 	ldhu	r2,-12(fp)
 82481e8:	e0bffa0d 	sth	r2,-24(fp)
   unshort  lport =  xlport;
 82481ec:	e0bfff0b 	ldhu	r2,-4(fp)
 82481f0:	e0bffa8d 	sth	r2,-22(fp)
   int   matchwild   =  3;
 82481f4:	008000c4 	movi	r2,3
 82481f8:	e0bff815 	stw	r2,-32(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 82481fc:	e0bffb17 	ldw	r2,-20(fp)
 8248200:	10800017 	ldw	r2,0(r2)
 8248204:	e0bff615 	stw	r2,-40(fp)
 8248208:	00004f06 	br	8248348 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 824820c:	e0bff617 	ldw	r2,-40(fp)
 8248210:	1080078b 	ldhu	r2,30(r2)
 8248214:	10ffffcc 	andi	r3,r2,65535
 8248218:	e0bffa8b 	ldhu	r2,-22(fp)
 824821c:	1880401e 	bne	r3,r2,8248320 <in_pcblookup+0x168>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 8248220:	e0bff617 	ldw	r2,-40(fp)
 8248224:	10800817 	ldw	r2,32(r2)
 8248228:	10800517 	ldw	r2,20(r2)
 824822c:	108000a0 	cmpeqi	r2,r2,2
 8248230:	10003d26 	beq	r2,zero,8248328 <in_pcblookup+0x170>
         continue;

      wildcard = 0;
 8248234:	e03ff915 	stw	zero,-28(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 8248238:	e0bff617 	ldw	r2,-40(fp)
 824823c:	10800417 	ldw	r2,16(r2)
 8248240:	10000b26 	beq	r2,zero,8248270 <in_pcblookup+0xb8>
      {
         if (laddr == INADDR_ANY)
 8248244:	e0bffe17 	ldw	r2,-8(fp)
 8248248:	1000041e 	bne	r2,zero,824825c <in_pcblookup+0xa4>
            wildcard++;
 824824c:	e0bff917 	ldw	r2,-28(fp)
 8248250:	10800044 	addi	r2,r2,1
 8248254:	e0bff915 	stw	r2,-28(fp)
 8248258:	00000a06 	br	8248284 <in_pcblookup+0xcc>
         else if (inp->inp_laddr.s_addr != laddr)
 824825c:	e0bff617 	ldw	r2,-40(fp)
 8248260:	10c00417 	ldw	r3,16(r2)
 8248264:	e0bffe17 	ldw	r2,-8(fp)
 8248268:	18800626 	beq	r3,r2,8248284 <in_pcblookup+0xcc>
            continue;
 824826c:	00003306 	br	824833c <in_pcblookup+0x184>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 8248270:	e0bffe17 	ldw	r2,-8(fp)
 8248274:	10000326 	beq	r2,zero,8248284 <in_pcblookup+0xcc>
            wildcard++;
 8248278:	e0bff917 	ldw	r2,-28(fp)
 824827c:	10800044 	addi	r2,r2,1
 8248280:	e0bff915 	stw	r2,-28(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 8248284:	e0bff617 	ldw	r2,-40(fp)
 8248288:	10800317 	ldw	r2,12(r2)
 824828c:	10001026 	beq	r2,zero,82482d0 <in_pcblookup+0x118>
      {
         if (faddr == INADDR_ANY)
 8248290:	e0bffc17 	ldw	r2,-16(fp)
 8248294:	1000041e 	bne	r2,zero,82482a8 <in_pcblookup+0xf0>
            wildcard++;
 8248298:	e0bff917 	ldw	r2,-28(fp)
 824829c:	10800044 	addi	r2,r2,1
 82482a0:	e0bff915 	stw	r2,-28(fp)
 82482a4:	00000f06 	br	82482e4 <in_pcblookup+0x12c>
         else if (inp->inp_faddr.s_addr != faddr ||
 82482a8:	e0bff617 	ldw	r2,-40(fp)
 82482ac:	10c00317 	ldw	r3,12(r2)
 82482b0:	e0bffc17 	ldw	r2,-16(fp)
 82482b4:	18801e1e 	bne	r3,r2,8248330 <in_pcblookup+0x178>
             inp->inp_fport != fport)
 82482b8:	e0bff617 	ldw	r2,-40(fp)
 82482bc:	1080070b 	ldhu	r2,28(r2)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
      {
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
 82482c0:	10ffffcc 	andi	r3,r2,65535
 82482c4:	e0bffa0b 	ldhu	r2,-24(fp)
 82482c8:	18800626 	beq	r3,r2,82482e4 <in_pcblookup+0x12c>
             inp->inp_fport != fport)
         {
            continue;
 82482cc:	00001806 	br	8248330 <in_pcblookup+0x178>
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 82482d0:	e0bffc17 	ldw	r2,-16(fp)
 82482d4:	10000326 	beq	r2,zero,82482e4 <in_pcblookup+0x12c>
            wildcard++;
 82482d8:	e0bff917 	ldw	r2,-28(fp)
 82482dc:	10800044 	addi	r2,r2,1
 82482e0:	e0bff915 	stw	r2,-28(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 82482e4:	e0bff917 	ldw	r2,-28(fp)
 82482e8:	10000326 	beq	r2,zero,82482f8 <in_pcblookup+0x140>
 82482ec:	e0800217 	ldw	r2,8(fp)
 82482f0:	1080004c 	andi	r2,r2,1
 82482f4:	10001026 	beq	r2,zero,8248338 <in_pcblookup+0x180>
         continue;
      if (wildcard < matchwild) 
 82482f8:	e0fff917 	ldw	r3,-28(fp)
 82482fc:	e0bff817 	ldw	r2,-32(fp)
 8248300:	18800e0e 	bge	r3,r2,824833c <in_pcblookup+0x184>
      {
         match = inp;
 8248304:	e0bff617 	ldw	r2,-40(fp)
 8248308:	e0bff715 	stw	r2,-36(fp)
         matchwild = wildcard;
 824830c:	e0bff917 	ldw	r2,-28(fp)
 8248310:	e0bff815 	stw	r2,-32(fp)
         if (matchwild == 0)
 8248314:	e0bff817 	ldw	r2,-32(fp)
 8248318:	10000f26 	beq	r2,zero,8248358 <in_pcblookup+0x1a0>
 824831c:	00000706 	br	824833c <in_pcblookup+0x184>
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
   {
      if (inp->inp_lport != lport)
         continue;
 8248320:	0001883a 	nop
 8248324:	00000506 	br	824833c <in_pcblookup+0x184>

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
         continue;
 8248328:	0001883a 	nop
 824832c:	00000306 	br	824833c <in_pcblookup+0x184>
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
             inp->inp_fport != fport)
         {
            continue;
 8248330:	0001883a 	nop
 8248334:	00000106 	br	824833c <in_pcblookup+0x184>
      {
         if (faddr != INADDR_ANY)
            wildcard++;
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
         continue;
 8248338:	0001883a 	nop
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 824833c:	e0bff617 	ldw	r2,-40(fp)
 8248340:	10800017 	ldw	r2,0(r2)
 8248344:	e0bff615 	stw	r2,-40(fp)
 8248348:	e0fff617 	ldw	r3,-40(fp)
 824834c:	e0bffb17 	ldw	r2,-20(fp)
 8248350:	18bfae1e 	bne	r3,r2,824820c <in_pcblookup+0x54>
 8248354:	00000106 	br	824835c <in_pcblookup+0x1a4>
      if (wildcard < matchwild) 
      {
         match = inp;
         matchwild = wildcard;
         if (matchwild == 0)
            break;
 8248358:	0001883a 	nop
      }
   }
   if (match == NULL)
 824835c:	e0bff717 	ldw	r2,-36(fp)
 8248360:	1000021e 	bne	r2,zero,824836c <in_pcblookup+0x1b4>
      return match;
 8248364:	e0bff717 	ldw	r2,-36(fp)
 8248368:	00002406 	br	82483fc <in_pcblookup+0x244>

   if (head->inp_next == match)  /* got cache hit? */
 824836c:	e0bffb17 	ldw	r2,-20(fp)
 8248370:	10c00017 	ldw	r3,0(r2)
 8248374:	e0bff717 	ldw	r2,-36(fp)
 8248378:	1880041e 	bne	r3,r2,824838c <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 824837c:	d0a0d217 	ldw	r2,-31928(gp)
 8248380:	10800044 	addi	r2,r2,1
 8248384:	d0a0d215 	stw	r2,-31928(gp)
 8248388:	00001b06 	br	82483f8 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 824838c:	d0a0d317 	ldw	r2,-31924(gp)
 8248390:	10800044 	addi	r2,r2,1
 8248394:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 8248398:	e0bff717 	ldw	r2,-36(fp)
 824839c:	10800017 	ldw	r2,0(r2)
 82483a0:	e0fff717 	ldw	r3,-36(fp)
 82483a4:	18c00117 	ldw	r3,4(r3)
 82483a8:	10c00115 	stw	r3,4(r2)
      match->inp_prev->inp_next = match->inp_next;
 82483ac:	e0bff717 	ldw	r2,-36(fp)
 82483b0:	10800117 	ldw	r2,4(r2)
 82483b4:	e0fff717 	ldw	r3,-36(fp)
 82483b8:	18c00017 	ldw	r3,0(r3)
 82483bc:	10c00015 	stw	r3,0(r2)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 82483c0:	e0bffb17 	ldw	r2,-20(fp)
 82483c4:	10c00017 	ldw	r3,0(r2)
 82483c8:	e0bff717 	ldw	r2,-36(fp)
 82483cc:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 82483d0:	e0bffb17 	ldw	r2,-20(fp)
 82483d4:	e0fff717 	ldw	r3,-36(fp)
 82483d8:	10c00015 	stw	r3,0(r2)
      match->inp_prev = head;
 82483dc:	e0bff717 	ldw	r2,-36(fp)
 82483e0:	e0fffb17 	ldw	r3,-20(fp)
 82483e4:	10c00115 	stw	r3,4(r2)
      match->inp_next->inp_prev = match;
 82483e8:	e0bff717 	ldw	r2,-36(fp)
 82483ec:	10800017 	ldw	r2,0(r2)
 82483f0:	e0fff717 	ldw	r3,-36(fp)
 82483f4:	10c00115 	stw	r3,4(r2)
   }
   return (match);
 82483f8:	e0bff717 	ldw	r2,-36(fp)
}
 82483fc:	e037883a 	mov	sp,fp
 8248400:	df000017 	ldw	fp,0(sp)
 8248404:	dec00104 	addi	sp,sp,4
 8248408:	f800283a 	ret

0824840c <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 824840c:	defffe04 	addi	sp,sp,-8
 8248410:	df000115 	stw	fp,4(sp)
 8248414:	df000104 	addi	fp,sp,4
 8248418:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 824841c:	e0bfff17 	ldw	r2,-4(fp)
 8248420:	d0a0d715 	stw	r2,-31908(gp)
}
 8248424:	0001883a 	nop
 8248428:	e037883a 	mov	sp,fp
 824842c:	df000017 	ldw	fp,0(sp)
 8248430:	dec00104 	addi	sp,sp,4
 8248434:	f800283a 	ret

08248438 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 8248438:	deffff04 	addi	sp,sp,-4
 824843c:	df000015 	stw	fp,0(sp)
 8248440:	d839883a 	mov	fp,sp
   return vfopen_error;
 8248444:	d0a0d717 	ldw	r2,-31908(gp)
}
 8248448:	e037883a 	mov	sp,fp
 824844c:	df000017 	ldw	fp,0(sp)
 8248450:	dec00104 	addi	sp,sp,4
 8248454:	f800283a 	ret

08248458 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 8248458:	defffd04 	addi	sp,sp,-12
 824845c:	dfc00215 	stw	ra,8(sp)
 8248460:	df000115 	stw	fp,4(sp)
 8248464:	df000104 	addi	fp,sp,4
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 8248468:	d0a0d917 	ldw	r2,-31900(gp)
 824846c:	10803ff0 	cmpltui	r2,r2,255
 8248470:	1000021e 	bne	r2,zero,824847c <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 8248474:	0005883a 	mov	r2,zero
 8248478:	00000e06 	br	82484b4 <vf_alloc_and_link_vop+0x5c>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 824847c:	01000504 	movi	r4,20
 8248480:	822deb80 	call	822deb8 <npalloc>
 8248484:	e0bfff15 	stw	r2,-4(fp)

   /* if the allocation succeeded */
   if (vop)
 8248488:	e0bfff17 	ldw	r2,-4(fp)
 824848c:	10000826 	beq	r2,zero,82484b0 <vf_alloc_and_link_vop+0x58>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 8248490:	d0e0d517 	ldw	r3,-31916(gp)
 8248494:	e0bfff17 	ldw	r2,-4(fp)
 8248498:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 824849c:	e0bfff17 	ldw	r2,-4(fp)
 82484a0:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 82484a4:	d0a0d917 	ldw	r2,-31900(gp)
 82484a8:	10800044 	addi	r2,r2,1
 82484ac:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 82484b0:	e0bfff17 	ldw	r2,-4(fp)
}
 82484b4:	e037883a 	mov	sp,fp
 82484b8:	dfc00117 	ldw	ra,4(sp)
 82484bc:	df000017 	ldw	fp,0(sp)
 82484c0:	dec00204 	addi	sp,sp,8
 82484c4:	f800283a 	ret

082484c8 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 82484c8:	defff904 	addi	sp,sp,-28
 82484cc:	dfc00615 	stw	ra,24(sp)
 82484d0:	df000515 	stw	fp,20(sp)
 82484d4:	df000504 	addi	fp,sp,20
 82484d8:	e13fff15 	stw	r4,-4(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 82484dc:	d0e0da17 	ldw	r3,-31896(gp)
 82484e0:	e0bfff17 	ldw	r2,-4(fp)
 82484e4:	1885883a 	add	r2,r3,r2
 82484e8:	00ffffd4 	movui	r3,65535
 82484ec:	1880022e 	bgeu	r3,r2,82484f8 <vf_alloc_buffer+0x30>
      return NULL;
 82484f0:	0005883a 	mov	r2,zero
 82484f4:	00002106 	br	824857c <vf_alloc_buffer+0xb4>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 82484f8:	00800104 	movi	r2,4
 82484fc:	e0bffb15 	stw	r2,-20(fp)
   int_size = sizeof(unsigned int);
 8248500:	00800104 	movi	r2,4
 8248504:	e0bffc15 	stw	r2,-16(fp)
   if (long_size > int_size)
 8248508:	e0bffb17 	ldw	r2,-20(fp)
 824850c:	e0fffc17 	ldw	r3,-16(fp)
 8248510:	1880102e 	bgeu	r3,r2,8248554 <vf_alloc_buffer+0x8c>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 8248514:	e0bffc17 	ldw	r2,-16(fp)
 8248518:	108000a0 	cmpeqi	r2,r2,2
 824851c:	10000826 	beq	r2,zero,8248540 <vf_alloc_buffer+0x78>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 8248520:	00bffff4 	movhi	r2,65535
 8248524:	e0bffd15 	stw	r2,-12(fp)
         break;
 8248528:	0001883a 	nop
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 824852c:	e0ffff17 	ldw	r3,-4(fp)
 8248530:	e0bffd17 	ldw	r2,-12(fp)
 8248534:	1884703a 	and	r2,r3,r2
 8248538:	10000626 	beq	r2,zero,8248554 <vf_alloc_buffer+0x8c>
 824853c:	00000306 	br	824854c <vf_alloc_buffer+0x84>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 8248540:	822d2e00 	call	822d2e0 <dtrap>
         return NULL;
 8248544:	0005883a 	mov	r2,zero
 8248548:	00000c06 	br	824857c <vf_alloc_buffer+0xb4>
      }

      if (size & mem_mask)
         return NULL;
 824854c:	0005883a 	mov	r2,zero
 8248550:	00000a06 	br	824857c <vf_alloc_buffer+0xb4>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 8248554:	e13fff17 	ldw	r4,-4(fp)
 8248558:	822deb80 	call	822deb8 <npalloc>
 824855c:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (buffer)
 8248560:	e0bffe17 	ldw	r2,-8(fp)
 8248564:	10000426 	beq	r2,zero,8248578 <vf_alloc_buffer+0xb0>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 8248568:	d0e0da17 	ldw	r3,-31896(gp)
 824856c:	e0bfff17 	ldw	r2,-4(fp)
 8248570:	1885883a 	add	r2,r3,r2
 8248574:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 8248578:	e0bffe17 	ldw	r2,-8(fp)
}
 824857c:	e037883a 	mov	sp,fp
 8248580:	dfc00117 	ldw	ra,4(sp)
 8248584:	df000017 	ldw	fp,0(sp)
 8248588:	dec00204 	addi	sp,sp,8
 824858c:	f800283a 	ret

08248590 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 8248590:	defffc04 	addi	sp,sp,-16
 8248594:	dfc00315 	stw	ra,12(sp)
 8248598:	df000215 	stw	fp,8(sp)
 824859c:	df000204 	addi	fp,sp,8
 82485a0:	e13ffe15 	stw	r4,-8(fp)
 82485a4:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 82485a8:	e0bffe17 	ldw	r2,-8(fp)
 82485ac:	10000226 	beq	r2,zero,82485b8 <vf_free_buffer+0x28>
      npfree(buffer);
 82485b0:	e13ffe17 	ldw	r4,-8(fp)
 82485b4:	822deec0 	call	822deec <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 82485b8:	d0e0da17 	ldw	r3,-31896(gp)
 82485bc:	e0bfff17 	ldw	r2,-4(fp)
 82485c0:	1885c83a 	sub	r2,r3,r2
 82485c4:	d0a0da15 	stw	r2,-31896(gp)
}
 82485c8:	0001883a 	nop
 82485cc:	e037883a 	mov	sp,fp
 82485d0:	dfc00117 	ldw	ra,4(sp)
 82485d4:	df000017 	ldw	fp,0(sp)
 82485d8:	dec00204 	addi	sp,sp,8
 82485dc:	f800283a 	ret

082485e0 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 82485e0:	defff904 	addi	sp,sp,-28
 82485e4:	dfc00615 	stw	ra,24(sp)
 82485e8:	df000515 	stw	fp,20(sp)
 82485ec:	df000504 	addi	fp,sp,20
 82485f0:	e13ffe15 	stw	r4,-8(fp)
 82485f4:	e17fff15 	stw	r5,-4(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 82485f8:	0009883a 	mov	r4,zero
 82485fc:	824840c0 	call	824840c <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 8248600:	01400fc4 	movi	r5,63
 8248604:	e13ffe17 	ldw	r4,-8(fp)
 8248608:	82034d00 	call	82034d0 <strchr>
 824860c:	10000326 	beq	r2,zero,824861c <vfopen_locked+0x3c>
   {
      dtrap();
 8248610:	822d2e00 	call	822d2e0 <dtrap>
      return NULL;
 8248614:	0005883a 	mov	r2,zero
 8248618:	0000ba06 	br	8248904 <vfopen_locked+0x324>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 824861c:	e13ffe17 	ldw	r4,-8(fp)
 8248620:	82498640 	call	8249864 <vfslookup_locked>
 8248624:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 8248628:	e0bffc17 	ldw	r2,-16(fp)
 824862c:	10004a26 	beq	r2,zero,8248758 <vfopen_locked+0x178>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 8248630:	e0bfff17 	ldw	r2,-4(fp)
 8248634:	10800003 	ldbu	r2,0(r2)
 8248638:	10803fcc 	andi	r2,r2,255
 824863c:	1080201c 	xori	r2,r2,128
 8248640:	10bfe004 	addi	r2,r2,-128
 8248644:	10801dd8 	cmpnei	r2,r2,119
 8248648:	1000091e 	bne	r2,zero,8248670 <vfopen_locked+0x90>
 824864c:	e0bffc17 	ldw	r2,-16(fp)
 8248650:	1080058b 	ldhu	r2,22(r2)
 8248654:	10bfffcc 	andi	r2,r2,65535
 8248658:	1080080c 	andi	r2,r2,32
 824865c:	1000041e 	bne	r2,zero,8248670 <vfopen_locked+0x90>
      {
         set_vfopen_error(ENP_FILEIO);
 8248660:	013ff984 	movi	r4,-26
 8248664:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248668:	0005883a 	mov	r2,zero
 824866c:	0000a506 	br	8248904 <vfopen_locked+0x324>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248670:	82484580 	call	8248458 <vf_alloc_and_link_vop>
 8248674:	e0bffd15 	stw	r2,-12(fp)

      /* check for failure */
      if (!vop)
 8248678:	e0bffd17 	ldw	r2,-12(fp)
 824867c:	1000041e 	bne	r2,zero,8248690 <vfopen_locked+0xb0>
      {
         set_vfopen_error(ENP_NOMEM);
 8248680:	013ffb04 	movi	r4,-20
 8248684:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248688:	0005883a 	mov	r2,zero
 824868c:	00009d06 	br	8248904 <vfopen_locked+0x324>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 8248690:	e0bffd17 	ldw	r2,-12(fp)
 8248694:	e0fffc17 	ldw	r3,-16(fp)
 8248698:	10c00115 	stw	r3,4(r2)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 824869c:	e0bffc17 	ldw	r2,-16(fp)
 82486a0:	10c00617 	ldw	r3,24(r2)
 82486a4:	e0bffd17 	ldw	r2,-12(fp)
 82486a8:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 82486ac:	e0bfff17 	ldw	r2,-4(fp)
 82486b0:	10800003 	ldbu	r2,0(r2)
 82486b4:	10803fcc 	andi	r2,r2,255
 82486b8:	1080201c 	xori	r2,r2,128
 82486bc:	10bfe004 	addi	r2,r2,-128
 82486c0:	10801858 	cmpnei	r2,r2,97
 82486c4:	10000a1e 	bne	r2,zero,82486f0 <vfopen_locked+0x110>
      {
         if (vfp->data)
 82486c8:	e0bffc17 	ldw	r2,-16(fp)
 82486cc:	10800617 	ldw	r2,24(r2)
 82486d0:	10000726 	beq	r2,zero,82486f0 <vfopen_locked+0x110>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 82486d4:	e0bffc17 	ldw	r2,-16(fp)
 82486d8:	10c00617 	ldw	r3,24(r2)
 82486dc:	e0bffc17 	ldw	r2,-16(fp)
 82486e0:	10800817 	ldw	r2,32(r2)
 82486e4:	1887883a 	add	r3,r3,r2
 82486e8:	e0bffd17 	ldw	r2,-12(fp)
 82486ec:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 82486f0:	e0bfff17 	ldw	r2,-4(fp)
 82486f4:	10800003 	ldbu	r2,0(r2)
 82486f8:	10803fcc 	andi	r2,r2,255
 82486fc:	1080201c 	xori	r2,r2,128
 8248700:	10bfe004 	addi	r2,r2,-128
 8248704:	10801dd8 	cmpnei	r2,r2,119
 8248708:	1000111e 	bne	r2,zero,8248750 <vfopen_locked+0x170>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 824870c:	e0bffc17 	ldw	r2,-16(fp)
 8248710:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 8248714:	e0bffc17 	ldw	r2,-16(fp)
 8248718:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 824871c:	e0bffc17 	ldw	r2,-16(fp)
 8248720:	1080058b 	ldhu	r2,22(r2)
 8248724:	10808014 	ori	r2,r2,512
 8248728:	1007883a 	mov	r3,r2
 824872c:	e0bffc17 	ldw	r2,-16(fp)
 8248730:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 8248734:	e0bffc17 	ldw	r2,-16(fp)
 8248738:	10c0058b 	ldhu	r3,22(r2)
 824873c:	00bfff84 	movi	r2,-2
 8248740:	1884703a 	and	r2,r3,r2
 8248744:	1007883a 	mov	r3,r2
 8248748:	e0bffc17 	ldw	r2,-16(fp)
 824874c:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 8248750:	e0bffd17 	ldw	r2,-12(fp)
 8248754:	00006b06 	br	8248904 <vfopen_locked+0x324>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 8248758:	e0bfff17 	ldw	r2,-4(fp)
 824875c:	10800003 	ldbu	r2,0(r2)
 8248760:	10803fcc 	andi	r2,r2,255
 8248764:	1080201c 	xori	r2,r2,128
 8248768:	10bfe004 	addi	r2,r2,-128
 824876c:	10801ca0 	cmpeqi	r2,r2,114
 8248770:	1000121e 	bne	r2,zero,82487bc <vfopen_locked+0x1dc>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 8248774:	d0a0d417 	ldw	r2,-31920(gp)
 8248778:	e0bffb15 	stw	r2,-20(fp)
 824877c:	00000d06 	br	82487b4 <vfopen_locked+0x1d4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 8248780:	e0bffb17 	ldw	r2,-20(fp)
 8248784:	10800117 	ldw	r2,4(r2)
 8248788:	e17fff17 	ldw	r5,-4(fp)
 824878c:	e13ffe17 	ldw	r4,-8(fp)
 8248790:	103ee83a 	callr	r2
 8248794:	e0bffd15 	stw	r2,-12(fp)
 8248798:	e0bffd17 	ldw	r2,-12(fp)
 824879c:	10000226 	beq	r2,zero,82487a8 <vfopen_locked+0x1c8>
         {
            return vop;
 82487a0:	e0bffd17 	ldw	r2,-12(fp)
 82487a4:	00005706 	br	8248904 <vfopen_locked+0x324>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 82487a8:	e0bffb17 	ldw	r2,-20(fp)
 82487ac:	10800017 	ldw	r2,0(r2)
 82487b0:	e0bffb15 	stw	r2,-20(fp)
 82487b4:	e0bffb17 	ldw	r2,-20(fp)
 82487b8:	103ff11e 	bne	r2,zero,8248780 <vfopen_locked+0x1a0>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 82487bc:	e0bfff17 	ldw	r2,-4(fp)
 82487c0:	10800003 	ldbu	r2,0(r2)
 82487c4:	10803fcc 	andi	r2,r2,255
 82487c8:	1080201c 	xori	r2,r2,128
 82487cc:	10bfe004 	addi	r2,r2,-128
 82487d0:	10801ca0 	cmpeqi	r2,r2,114
 82487d4:	1000481e 	bne	r2,zero,82488f8 <vfopen_locked+0x318>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 82487d8:	d0a0db17 	ldw	r2,-31892(gp)
 82487dc:	10803ff0 	cmpltui	r2,r2,255
 82487e0:	1000041e 	bne	r2,zero,82487f4 <vfopen_locked+0x214>
      {
         set_vfopen_error(ENP_NOMEM);
 82487e4:	013ffb04 	movi	r4,-20
 82487e8:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 82487ec:	0005883a 	mov	r2,zero
 82487f0:	00004406 	br	8248904 <vfopen_locked+0x324>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 82487f4:	e13ffe17 	ldw	r4,-8(fp)
 82487f8:	8203cac0 	call	8203cac <strlen>
 82487fc:	10800470 	cmpltui	r2,r2,17
 8248800:	1000041e 	bne	r2,zero,8248814 <vfopen_locked+0x234>
      {
         set_vfopen_error(ENP_PARAM);
 8248804:	013ffd84 	movi	r4,-10
 8248808:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 824880c:	0005883a 	mov	r2,zero
 8248810:	00003c06 	br	8248904 <vfopen_locked+0x324>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 8248814:	01000b04 	movi	r4,44
 8248818:	822deb80 	call	822deb8 <npalloc>
 824881c:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 8248820:	e0bffc17 	ldw	r2,-16(fp)
 8248824:	1000041e 	bne	r2,zero,8248838 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_NOMEM);
 8248828:	013ffb04 	movi	r4,-20
 824882c:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248830:	0005883a 	mov	r2,zero
 8248834:	00003306 	br	8248904 <vfopen_locked+0x324>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248838:	82484580 	call	8248458 <vf_alloc_and_link_vop>
 824883c:	e0bffd15 	stw	r2,-12(fp)

      /* check for memory allocation failure */
      if (!vop)
 8248840:	e0bffd17 	ldw	r2,-12(fp)
 8248844:	1000061e 	bne	r2,zero,8248860 <vfopen_locked+0x280>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 8248848:	e13ffc17 	ldw	r4,-16(fp)
 824884c:	822deec0 	call	822deec <npfree>
         set_vfopen_error(ENP_NOMEM);
 8248850:	013ffb04 	movi	r4,-20
 8248854:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248858:	0005883a 	mov	r2,zero
 824885c:	00002906 	br	8248904 <vfopen_locked+0x324>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 8248860:	d0e0d617 	ldw	r3,-31912(gp)
 8248864:	e0bffc17 	ldw	r2,-16(fp)
 8248868:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 824886c:	e0bffc17 	ldw	r2,-16(fp)
 8248870:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 8248874:	d0a0db17 	ldw	r2,-31892(gp)
 8248878:	10800044 	addi	r2,r2,1
 824887c:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 8248880:	e0bffe17 	ldw	r2,-8(fp)
 8248884:	10800003 	ldbu	r2,0(r2)
 8248888:	10803fcc 	andi	r2,r2,255
 824888c:	1080201c 	xori	r2,r2,128
 8248890:	10bfe004 	addi	r2,r2,-128
 8248894:	10800be0 	cmpeqi	r2,r2,47
 8248898:	1000071e 	bne	r2,zero,82488b8 <vfopen_locked+0x2d8>
 824889c:	e0bffe17 	ldw	r2,-8(fp)
 82488a0:	10800003 	ldbu	r2,0(r2)
 82488a4:	10803fcc 	andi	r2,r2,255
 82488a8:	1080201c 	xori	r2,r2,128
 82488ac:	10bfe004 	addi	r2,r2,-128
 82488b0:	10801718 	cmpnei	r2,r2,92
 82488b4:	1000031e 	bne	r2,zero,82488c4 <vfopen_locked+0x2e4>
         name++;
 82488b8:	e0bffe17 	ldw	r2,-8(fp)
 82488bc:	10800044 	addi	r2,r2,1
 82488c0:	e0bffe15 	stw	r2,-8(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 82488c4:	e0bffc17 	ldw	r2,-16(fp)
 82488c8:	10800104 	addi	r2,r2,4
 82488cc:	e17ffe17 	ldw	r5,-8(fp)
 82488d0:	1009883a 	mov	r4,r2
 82488d4:	824b4040 	call	824b404 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 82488d8:	e0bffc17 	ldw	r2,-16(fp)
 82488dc:	00c0d804 	movi	r3,864
 82488e0:	10c0058d 	sth	r3,22(r2)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 82488e4:	e0bffd17 	ldw	r2,-12(fp)
 82488e8:	e0fffc17 	ldw	r3,-16(fp)
 82488ec:	10c00115 	stw	r3,4(r2)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 82488f0:	e0bffd17 	ldw	r2,-12(fp)
 82488f4:	00000306 	br	8248904 <vfopen_locked+0x324>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 82488f8:	013ff9c4 	movi	r4,-25
 82488fc:	824840c0 	call	824840c <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 8248900:	0005883a 	mov	r2,zero

#endif   /* HT_LOCALFS */
}
 8248904:	e037883a 	mov	sp,fp
 8248908:	dfc00117 	ldw	ra,4(sp)
 824890c:	df000017 	ldw	fp,0(sp)
 8248910:	dec00204 	addi	sp,sp,8
 8248914:	f800283a 	ret

08248918 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 8248918:	defffb04 	addi	sp,sp,-20
 824891c:	dfc00415 	stw	ra,16(sp)
 8248920:	df000315 	stw	fp,12(sp)
 8248924:	df000304 	addi	fp,sp,12
 8248928:	e13ffe15 	stw	r4,-8(fp)
 824892c:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248930:	01000144 	movi	r4,5
 8248934:	822d8f40 	call	822d8f4 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 8248938:	e17fff17 	ldw	r5,-4(fp)
 824893c:	e13ffe17 	ldw	r4,-8(fp)
 8248940:	82485e00 	call	82485e0 <vfopen_locked>
 8248944:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 8248948:	01000144 	movi	r4,5
 824894c:	822d9b00 	call	822d9b0 <post_app_sem>

   return vfd;
 8248950:	e0bffd17 	ldw	r2,-12(fp)
}
 8248954:	e037883a 	mov	sp,fp
 8248958:	dfc00117 	ldw	ra,4(sp)
 824895c:	df000017 	ldw	fp,0(sp)
 8248960:	dec00204 	addi	sp,sp,8
 8248964:	f800283a 	ret

08248968 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 8248968:	defff804 	addi	sp,sp,-32
 824896c:	dfc00715 	stw	ra,28(sp)
 8248970:	df000615 	stw	fp,24(sp)
 8248974:	df000604 	addi	fp,sp,24
 8248978:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 824897c:	e03ffb15 	stw	zero,-20(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 8248980:	d0a0d517 	ldw	r2,-31916(gp)
 8248984:	e0bffa15 	stw	r2,-24(fp)
   while (vtmp)
 8248988:	00000806 	br	82489ac <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 824898c:	e0ffff17 	ldw	r3,-4(fp)
 8248990:	e0bffa17 	ldw	r2,-24(fp)
 8248994:	18800826 	beq	r3,r2,82489b8 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 8248998:	e0bffa17 	ldw	r2,-24(fp)
 824899c:	e0bffb15 	stw	r2,-20(fp)
      vtmp = vtmp->next;
 82489a0:	e0bffa17 	ldw	r2,-24(fp)
 82489a4:	10800017 	ldw	r2,0(r2)
 82489a8:	e0bffa15 	stw	r2,-24(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 82489ac:	e0bffa17 	ldw	r2,-24(fp)
 82489b0:	103ff61e 	bne	r2,zero,824898c <vfclose_locked+0x24>
 82489b4:	00000106 	br	82489bc <vfclose_locked+0x54>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
         break;
 82489b8:	0001883a 	nop
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 82489bc:	e0ffff17 	ldw	r3,-4(fp)
 82489c0:	e0bffa17 	ldw	r2,-24(fp)
 82489c4:	1880511e 	bne	r3,r2,8248b0c <vfclose_locked+0x1a4>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 82489c8:	e0bfff17 	ldw	r2,-4(fp)
 82489cc:	10800117 	ldw	r2,4(r2)
 82489d0:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 82489d4:	e0bffc17 	ldw	r2,-16(fp)
 82489d8:	10003826 	beq	r2,zero,8248abc <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 82489dc:	e0bffc17 	ldw	r2,-16(fp)
 82489e0:	10800a17 	ldw	r2,40(r2)
 82489e4:	10000826 	beq	r2,zero,8248a08 <vfclose_locked+0xa0>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 82489e8:	e0bffc17 	ldw	r2,-16(fp)
 82489ec:	10800a17 	ldw	r2,40(r2)
 82489f0:	e0bffd15 	stw	r2,-12(fp)

         vfs->r_fclose(vfd);
 82489f4:	e0bffd17 	ldw	r2,-12(fp)
 82489f8:	10800217 	ldw	r2,8(r2)
 82489fc:	e13fff17 	ldw	r4,-4(fp)
 8248a00:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 8248a04:	00003006 	br	8248ac8 <vfclose_locked+0x160>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248a08:	e0bffc17 	ldw	r2,-16(fp)
 8248a0c:	1080058b 	ldhu	r2,22(r2)
 8248a10:	10bfffcc 	andi	r2,r2,65535
 8248a14:	1080200c 	andi	r2,r2,128
 8248a18:	10002a26 	beq	r2,zero,8248ac4 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248a1c:	e0bffc17 	ldw	r2,-16(fp)
 8248a20:	10c00917 	ldw	r3,36(r2)
 8248a24:	e0bffc17 	ldw	r2,-16(fp)
 8248a28:	10800817 	ldw	r2,32(r2)
 8248a2c:	1885c83a 	sub	r2,r3,r2

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248a30:	10804030 	cmpltui	r2,r2,256
 8248a34:	1000231e 	bne	r2,zero,8248ac4 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
          vfp->data) /* this last test is a sanity check */
 8248a38:	e0bffc17 	ldw	r2,-16(fp)
 8248a3c:	10800617 	ldw	r2,24(r2)
      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248a40:	10002026 	beq	r2,zero,8248ac4 <vfclose_locked+0x15c>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 8248a44:	e0bffc17 	ldw	r2,-16(fp)
 8248a48:	10800817 	ldw	r2,32(r2)
 8248a4c:	1009883a 	mov	r4,r2
 8248a50:	82484c80 	call	82484c8 <vf_alloc_buffer>
 8248a54:	e0bffe15 	stw	r2,-8(fp)

         /* if the allocation worked */
         if (new_buffer)
 8248a58:	e0bffe17 	ldw	r2,-8(fp)
 8248a5c:	10001926 	beq	r2,zero,8248ac4 <vfclose_locked+0x15c>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8248a60:	e0bffc17 	ldw	r2,-16(fp)
 8248a64:	10c00617 	ldw	r3,24(r2)
 8248a68:	e0bffc17 	ldw	r2,-16(fp)
 8248a6c:	10800817 	ldw	r2,32(r2)
 8248a70:	100d883a 	mov	r6,r2
 8248a74:	180b883a 	mov	r5,r3
 8248a78:	e13ffe17 	ldw	r4,-8(fp)
 8248a7c:	8202c5c0 	call	8202c5c <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 8248a80:	e0bffc17 	ldw	r2,-16(fp)
 8248a84:	10c00617 	ldw	r3,24(r2)
 8248a88:	e0bffc17 	ldw	r2,-16(fp)
 8248a8c:	10800917 	ldw	r2,36(r2)
 8248a90:	100b883a 	mov	r5,r2
 8248a94:	1809883a 	mov	r4,r3
 8248a98:	82485900 	call	8248590 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 8248a9c:	e0bffc17 	ldw	r2,-16(fp)
 8248aa0:	e0fffe17 	ldw	r3,-8(fp)
 8248aa4:	10c00615 	stw	r3,24(r2)
            vfp->buf_size = vfp->comp_size;
 8248aa8:	e0bffc17 	ldw	r2,-16(fp)
 8248aac:	10c00817 	ldw	r3,32(r2)
 8248ab0:	e0bffc17 	ldw	r2,-16(fp)
 8248ab4:	10c00915 	stw	r3,36(r2)
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248ab8:	00000206 	br	8248ac4 <vfclose_locked+0x15c>
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
         break;
 8248abc:	0001883a 	nop
 8248ac0:	00000106 	br	8248ac8 <vfclose_locked+0x160>
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248ac4:	0001883a 	nop

   }

   if (vlast)  /* unlink from list of open files */
 8248ac8:	e0bffb17 	ldw	r2,-20(fp)
 8248acc:	10000526 	beq	r2,zero,8248ae4 <vfclose_locked+0x17c>
      vlast->next = vtmp->next;
 8248ad0:	e0bffa17 	ldw	r2,-24(fp)
 8248ad4:	10c00017 	ldw	r3,0(r2)
 8248ad8:	e0bffb17 	ldw	r2,-20(fp)
 8248adc:	10c00015 	stw	r3,0(r2)
 8248ae0:	00000306 	br	8248af0 <vfclose_locked+0x188>
   else
      vfiles = vtmp->next;
 8248ae4:	e0bffa17 	ldw	r2,-24(fp)
 8248ae8:	10800017 	ldw	r2,0(r2)
 8248aec:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 8248af0:	e13ffa17 	ldw	r4,-24(fp)
 8248af4:	822deec0 	call	822deec <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 8248af8:	d0a0d917 	ldw	r2,-31900(gp)
 8248afc:	10bfffc4 	addi	r2,r2,-1
 8248b00:	d0a0d915 	stw	r2,-31900(gp)
   return;
 8248b04:	0001883a 	nop
 8248b08:	00000106 	br	8248b10 <vfclose_locked+0x1a8>

#ifdef HT_LOCALFS
      /* default to call on local system */
      fclose((FILE*)vfd);
#endif   /* HT_LOCALFS */
      return;
 8248b0c:	0001883a 	nop
   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
   /* decrement the number of open files */
   vfs_open_files--;
   return;
}
 8248b10:	e037883a 	mov	sp,fp
 8248b14:	dfc00117 	ldw	ra,4(sp)
 8248b18:	df000017 	ldw	fp,0(sp)
 8248b1c:	dec00204 	addi	sp,sp,8
 8248b20:	f800283a 	ret

08248b24 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 8248b24:	defffd04 	addi	sp,sp,-12
 8248b28:	dfc00215 	stw	ra,8(sp)
 8248b2c:	df000115 	stw	fp,4(sp)
 8248b30:	df000104 	addi	fp,sp,4
 8248b34:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248b38:	01000144 	movi	r4,5
 8248b3c:	822d8f40 	call	822d8f4 <wait_app_sem>

   vfclose_locked(vfd);
 8248b40:	e13fff17 	ldw	r4,-4(fp)
 8248b44:	82489680 	call	8248968 <vfclose_locked>

   vfs_unlock();
 8248b48:	01000144 	movi	r4,5
 8248b4c:	822d9b00 	call	822d9b0 <post_app_sem>
}
 8248b50:	0001883a 	nop
 8248b54:	e037883a 	mov	sp,fp
 8248b58:	dfc00117 	ldw	ra,4(sp)
 8248b5c:	df000017 	ldw	fp,0(sp)
 8248b60:	dec00204 	addi	sp,sp,8
 8248b64:	f800283a 	ret

08248b68 <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 8248b68:	defffd04 	addi	sp,sp,-12
 8248b6c:	dfc00215 	stw	ra,8(sp)
 8248b70:	df000115 	stw	fp,4(sp)
 8248b74:	df000104 	addi	fp,sp,4
 8248b78:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248b7c:	01000144 	movi	r4,5
 8248b80:	822d8f40 	call	822d8f4 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 8248b84:	01020974 	movhi	r4,2085
 8248b88:	2105fe04 	addi	r4,r4,6136
 8248b8c:	82033700 	call	8203370 <puts>

   vfs_unlock();
 8248b90:	01000144 	movi	r4,5
 8248b94:	822d9b00 	call	822d9b0 <post_app_sem>
   return(0);
 8248b98:	0005883a 	mov	r2,zero
}
 8248b9c:	e037883a 	mov	sp,fp
 8248ba0:	dfc00117 	ldw	ra,4(sp)
 8248ba4:	df000017 	ldw	fp,0(sp)
 8248ba8:	dec00204 	addi	sp,sp,8
 8248bac:	f800283a 	ret

08248bb0 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 8248bb0:	defff904 	addi	sp,sp,-28
 8248bb4:	dfc00615 	stw	ra,24(sp)
 8248bb8:	df000515 	stw	fp,20(sp)
 8248bbc:	df000504 	addi	fp,sp,20
 8248bc0:	e13ffd15 	stw	r4,-12(fp)
 8248bc4:	e17ffe15 	stw	r5,-8(fp)
 8248bc8:	e1bfff15 	stw	r6,-4(fp)
   int   c   = EOF;
 8248bcc:	00bfffc4 	movi	r2,-1
 8248bd0:	e0bffb15 	stw	r2,-20(fp)
   char* ret = s;
 8248bd4:	e0bffd17 	ldw	r2,-12(fp)
 8248bd8:	e0bffc15 	stw	r2,-16(fp)

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248bdc:	00000b06 	br	8248c0c <vfgets+0x5c>
      if (( *ret ++ = c) == '\n')
 8248be0:	e0bffc17 	ldw	r2,-16(fp)
 8248be4:	10c00044 	addi	r3,r2,1
 8248be8:	e0fffc15 	stw	r3,-16(fp)
 8248bec:	e0fffb17 	ldw	r3,-20(fp)
 8248bf0:	10c00005 	stb	r3,0(r2)
 8248bf4:	10800003 	ldbu	r2,0(r2)
 8248bf8:	10803fcc 	andi	r2,r2,255
 8248bfc:	1080201c 	xori	r2,r2,128
 8248c00:	10bfe004 	addi	r2,r2,-128
 8248c04:	10800298 	cmpnei	r2,r2,10
 8248c08:	10000c26 	beq	r2,zero,8248c3c <vfgets+0x8c>
char * vfgets(char * s, int lim, VFILE * fp) 
{
   int   c   = EOF;
   char* ret = s;

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248c0c:	e0bffe17 	ldw	r2,-8(fp)
 8248c10:	10bfffc4 	addi	r2,r2,-1
 8248c14:	e0bffe15 	stw	r2,-8(fp)
 8248c18:	e0bffe17 	ldw	r2,-8(fp)
 8248c1c:	0080080e 	bge	zero,r2,8248c40 <vfgets+0x90>
 8248c20:	e13fff17 	ldw	r4,-4(fp)
 8248c24:	824981c0 	call	824981c <vgetc>
 8248c28:	e0bffb15 	stw	r2,-20(fp)
 8248c2c:	e0bffb17 	ldw	r2,-20(fp)
 8248c30:	10bfffd8 	cmpnei	r2,r2,-1
 8248c34:	103fea1e 	bne	r2,zero,8248be0 <vfgets+0x30>
 8248c38:	00000106 	br	8248c40 <vfgets+0x90>
      if (( *ret ++ = c) == '\n')
         break;
 8248c3c:	0001883a 	nop
   *ret = '\0';
 8248c40:	e0bffc17 	ldw	r2,-16(fp)
 8248c44:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 8248c48:	e0bffb17 	ldw	r2,-20(fp)
 8248c4c:	10bfffd8 	cmpnei	r2,r2,-1
 8248c50:	1000031e 	bne	r2,zero,8248c60 <vfgets+0xb0>
 8248c54:	e0fffc17 	ldw	r3,-16(fp)
 8248c58:	e0bffd17 	ldw	r2,-12(fp)
 8248c5c:	18800226 	beq	r3,r2,8248c68 <vfgets+0xb8>
 8248c60:	e0bffd17 	ldw	r2,-12(fp)
 8248c64:	00000106 	br	8248c6c <vfgets+0xbc>
 8248c68:	0005883a 	mov	r2,zero
}
 8248c6c:	e037883a 	mov	sp,fp
 8248c70:	dfc00117 	ldw	ra,4(sp)
 8248c74:	df000017 	ldw	fp,0(sp)
 8248c78:	dec00204 	addi	sp,sp,8
 8248c7c:	f800283a 	ret

08248c80 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 8248c80:	defffc04 	addi	sp,sp,-16
 8248c84:	dfc00315 	stw	ra,12(sp)
 8248c88:	df000215 	stw	fp,8(sp)
 8248c8c:	df000204 	addi	fp,sp,8
 8248c90:	e13fff15 	stw	r4,-4(fp)
   int c = 0;
 8248c94:	e03ffe15 	stw	zero,-8(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 8248c98:	e13fff17 	ldw	r4,-4(fp)
 8248c9c:	824981c0 	call	824981c <vgetc>
 8248ca0:	e0bffe15 	stw	r2,-8(fp)
 8248ca4:	e0bffe17 	ldw	r2,-8(fp)
 8248ca8:	10bfffd8 	cmpnei	r2,r2,-1
 8248cac:	1000021e 	bne	r2,zero,8248cb8 <vfeof+0x38>
   {
      return 1;
 8248cb0:	00800044 	movi	r2,1
 8248cb4:	00000106 	br	8248cbc <vfeof+0x3c>
   }   
   return 0;
 8248cb8:	0005883a 	mov	r2,zero
}
 8248cbc:	e037883a 	mov	sp,fp
 8248cc0:	dfc00117 	ldw	ra,4(sp)
 8248cc4:	df000017 	ldw	fp,0(sp)
 8248cc8:	dec00204 	addi	sp,sp,8
 8248ccc:	f800283a 	ret

08248cd0 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 8248cd0:	defffd04 	addi	sp,sp,-12
 8248cd4:	df000215 	stw	fp,8(sp)
 8248cd8:	df000204 	addi	fp,sp,8
 8248cdc:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248ce0:	d0a0d517 	ldw	r2,-31916(gp)
 8248ce4:	e0bffe15 	stw	r2,-8(fp)
 8248ce8:	00000906 	br	8248d10 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 8248cec:	e0bffe17 	ldw	r2,-8(fp)
 8248cf0:	10c00117 	ldw	r3,4(r2)
 8248cf4:	e0bfff17 	ldw	r2,-4(fp)
 8248cf8:	1880021e 	bne	r3,r2,8248d04 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 8248cfc:	e0bffe17 	ldw	r2,-8(fp)
 8248d00:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248d04:	e0bffe17 	ldw	r2,-8(fp)
 8248d08:	10800017 	ldw	r2,0(r2)
 8248d0c:	e0bffe15 	stw	r2,-8(fp)
 8248d10:	e0bffe17 	ldw	r2,-8(fp)
 8248d14:	103ff51e 	bne	r2,zero,8248cec <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 8248d18:	0001883a 	nop
 8248d1c:	e037883a 	mov	sp,fp
 8248d20:	df000017 	ldw	fp,0(sp)
 8248d24:	dec00104 	addi	sp,sp,4
 8248d28:	f800283a 	ret

08248d2c <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 8248d2c:	defff604 	addi	sp,sp,-40
 8248d30:	dfc00915 	stw	ra,36(sp)
 8248d34:	df000815 	stw	fp,32(sp)
 8248d38:	df000804 	addi	fp,sp,32
 8248d3c:	e13fff15 	stw	r4,-4(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 8248d40:	e03ff815 	stw	zero,-32(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 8248d44:	e13fff17 	ldw	r4,-4(fp)
 8248d48:	8203cac0 	call	8203cac <strlen>
 8248d4c:	10800044 	addi	r2,r2,1
 8248d50:	1009883a 	mov	r4,r2
 8248d54:	824b3dc0 	call	824b3dc <malloc>
 8248d58:	e0bffb15 	stw	r2,-20(fp)
   strcpy(name, const_name);
 8248d5c:	e17fff17 	ldw	r5,-4(fp)
 8248d60:	e13ffb17 	ldw	r4,-20(fp)
 8248d64:	824b4040 	call	824b404 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248d68:	01000144 	movi	r4,5
 8248d6c:	822d8f40 	call	822d8f4 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 8248d70:	e13ffb17 	ldw	r4,-20(fp)
 8248d74:	82498640 	call	8249864 <vfslookup_locked>
 8248d78:	e0bffc15 	stw	r2,-16(fp)
 8248d7c:	e0bffc17 	ldw	r2,-16(fp)
 8248d80:	1000061e 	bne	r2,zero,8248d9c <vunlink+0x70>
   {
      vfs_unlock();
 8248d84:	01000144 	movi	r4,5
 8248d88:	822d9b00 	call	822d9b0 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 8248d8c:	e13ffb17 	ldw	r4,-20(fp)
 8248d90:	824b3f00 	call	824b3f0 <free>
      return -1;
 8248d94:	00bfffc4 	movi	r2,-1
 8248d98:	00005f06 	br	8248f18 <vunlink+0x1ec>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 8248d9c:	e0bffc17 	ldw	r2,-16(fp)
 8248da0:	10800017 	ldw	r2,0(r2)
 8248da4:	e0bffd15 	stw	r2,-12(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 8248da8:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8248dac:	d0a0d617 	ldw	r2,-31912(gp)
 8248db0:	e0bff915 	stw	r2,-28(fp)
 8248db4:	00000806 	br	8248dd8 <vunlink+0xac>
   {
      if (vtmp == vfp)
 8248db8:	e0fff917 	ldw	r3,-28(fp)
 8248dbc:	e0bffc17 	ldw	r2,-16(fp)
 8248dc0:	18800826 	beq	r3,r2,8248de4 <vunlink+0xb8>
         break;
      vflast = vtmp;
 8248dc4:	e0bff917 	ldw	r2,-28(fp)
 8248dc8:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8248dcc:	e0bff917 	ldw	r2,-28(fp)
 8248dd0:	10800017 	ldw	r2,0(r2)
 8248dd4:	e0bff915 	stw	r2,-28(fp)
 8248dd8:	e0bff917 	ldw	r2,-28(fp)
 8248ddc:	103ff61e 	bne	r2,zero,8248db8 <vunlink+0x8c>
 8248de0:	00000106 	br	8248de8 <vunlink+0xbc>
   {
      if (vtmp == vfp)
         break;
 8248de4:	0001883a 	nop
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 8248de8:	e0bff917 	ldw	r2,-28(fp)
 8248dec:	1000071e 	bne	r2,zero,8248e0c <vunlink+0xe0>
   {
      dtrap();
 8248df0:	822d2e00 	call	822d2e0 <dtrap>
      vfs_unlock();
 8248df4:	01000144 	movi	r4,5
 8248df8:	822d9b00 	call	822d9b0 <post_app_sem>
      free(name);
 8248dfc:	e13ffb17 	ldw	r4,-20(fp)
 8248e00:	824b3f00 	call	824b3f0 <free>
      return -1;
 8248e04:	00bfffc4 	movi	r2,-1
 8248e08:	00004306 	br	8248f18 <vunlink+0x1ec>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 8248e0c:	e0bffc17 	ldw	r2,-16(fp)
 8248e10:	10800a17 	ldw	r2,40(r2)
 8248e14:	10000926 	beq	r2,zero,8248e3c <vunlink+0x110>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 8248e18:	e0bffc17 	ldw	r2,-16(fp)
 8248e1c:	10800a17 	ldw	r2,40(r2)
 8248e20:	e0bffe15 	stw	r2,-8(fp)

         rc = vfs->r_unlink(name);
 8248e24:	e0bffe17 	ldw	r2,-8(fp)
 8248e28:	10800817 	ldw	r2,32(r2)
 8248e2c:	e13ffb17 	ldw	r4,-20(fp)
 8248e30:	103ee83a 	callr	r2
 8248e34:	e0bff815 	stw	r2,-32(fp)
         break;   /* break to list deletion code after end of phoney loop */
 8248e38:	00002606 	br	8248ed4 <vunlink+0x1a8>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 8248e3c:	e0bffc17 	ldw	r2,-16(fp)
 8248e40:	1080058b 	ldhu	r2,22(r2)
 8248e44:	10bfffcc 	andi	r2,r2,65535
 8248e48:	1080080c 	andi	r2,r2,32
 8248e4c:	1000061e 	bne	r2,zero,8248e68 <vunlink+0x13c>
      {
         vfs_unlock();
 8248e50:	01000144 	movi	r4,5
 8248e54:	822d9b00 	call	822d9b0 <post_app_sem>
         free(name);
 8248e58:	e13ffb17 	ldw	r4,-20(fp)
 8248e5c:	824b3f00 	call	824b3f0 <free>
         return -1;
 8248e60:	00bfffc4 	movi	r2,-1
 8248e64:	00002c06 	br	8248f18 <vunlink+0x1ec>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 8248e68:	e0bffc17 	ldw	r2,-16(fp)
 8248e6c:	1080058b 	ldhu	r2,22(r2)
 8248e70:	10bfffcc 	andi	r2,r2,65535
 8248e74:	1080200c 	andi	r2,r2,128
 8248e78:	10000a26 	beq	r2,zero,8248ea4 <vunlink+0x178>
 8248e7c:	e0bffc17 	ldw	r2,-16(fp)
 8248e80:	10800617 	ldw	r2,24(r2)
 8248e84:	10000726 	beq	r2,zero,8248ea4 <vunlink+0x178>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8248e88:	e0bffc17 	ldw	r2,-16(fp)
 8248e8c:	10c00617 	ldw	r3,24(r2)
 8248e90:	e0bffc17 	ldw	r2,-16(fp)
 8248e94:	10800917 	ldw	r2,36(r2)
 8248e98:	100b883a 	mov	r5,r2
 8248e9c:	1809883a 	mov	r4,r3
 8248ea0:	82485900 	call	8248590 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 8248ea4:	e0bffc17 	ldw	r2,-16(fp)
 8248ea8:	1080058b 	ldhu	r2,22(r2)
 8248eac:	10bfffcc 	andi	r2,r2,65535
 8248eb0:	1080100c 	andi	r2,r2,64
 8248eb4:	10000526 	beq	r2,zero,8248ecc <vunlink+0x1a0>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 8248eb8:	d0a0db17 	ldw	r2,-31892(gp)
 8248ebc:	10bfffc4 	addi	r2,r2,-1
 8248ec0:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 8248ec4:	e13ffc17 	ldw	r4,-16(fp)
 8248ec8:	822deec0 	call	822deec <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 8248ecc:	e03ff815 	stw	zero,-32(fp)

      break;
 8248ed0:	0001883a 	nop
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 8248ed4:	e0bffa17 	ldw	r2,-24(fp)
 8248ed8:	10000426 	beq	r2,zero,8248eec <vunlink+0x1c0>
      vflast->next = vfnext;
 8248edc:	e0bffa17 	ldw	r2,-24(fp)
 8248ee0:	e0fffd17 	ldw	r3,-12(fp)
 8248ee4:	10c00015 	stw	r3,0(r2)
 8248ee8:	00000206 	br	8248ef4 <vunlink+0x1c8>
   else
      vfsfiles = vfnext;
 8248eec:	e0bffd17 	ldw	r2,-12(fp)
 8248ef0:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 8248ef4:	e13ffc17 	ldw	r4,-16(fp)
 8248ef8:	8248cd00 	call	8248cd0 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 8248efc:	00800044 	movi	r2,1
 8248f00:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 8248f04:	01000144 	movi	r4,5
 8248f08:	822d9b00 	call	822d9b0 <post_app_sem>
   free(name);
 8248f0c:	e13ffb17 	ldw	r4,-20(fp)
 8248f10:	824b3f00 	call	824b3f0 <free>
   return rc;
 8248f14:	e0bff817 	ldw	r2,-32(fp)
}
 8248f18:	e037883a 	mov	sp,fp
 8248f1c:	dfc00117 	ldw	ra,4(sp)
 8248f20:	df000017 	ldw	fp,0(sp)
 8248f24:	dec00204 	addi	sp,sp,8
 8248f28:	f800283a 	ret

08248f2c <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8248f2c:	defff604 	addi	sp,sp,-40
 8248f30:	dfc00915 	stw	ra,36(sp)
 8248f34:	df000815 	stw	fp,32(sp)
 8248f38:	df000804 	addi	fp,sp,32
 8248f3c:	e13ffc15 	stw	r4,-16(fp)
 8248f40:	e17ffd15 	stw	r5,-12(fp)
 8248f44:	e1bffe15 	stw	r6,-8(fp)
 8248f48:	e1ffff15 	stw	r7,-4(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8248f4c:	01000144 	movi	r4,5
 8248f50:	822d8f40 	call	822d8f4 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 8248f54:	e13fff17 	ldw	r4,-4(fp)
 8248f58:	8249b9c0 	call	8249b9c <isvfile_locked>
 8248f5c:	10004e26 	beq	r2,zero,8249098 <vfread+0x16c>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 8248f60:	e0bfff17 	ldw	r2,-4(fp)
 8248f64:	10800117 	ldw	r2,4(r2)
 8248f68:	1000041e 	bne	r2,zero,8248f7c <vfread+0x50>
      {
         vfs_unlock();
 8248f6c:	01000144 	movi	r4,5
 8248f70:	822d9b00 	call	822d9b0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8248f74:	0005883a 	mov	r2,zero
 8248f78:	00004a06 	br	82490a4 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 8248f7c:	e0bfff17 	ldw	r2,-4(fp)
 8248f80:	10800117 	ldw	r2,4(r2)
 8248f84:	10800a17 	ldw	r2,40(r2)
 8248f88:	10001026 	beq	r2,zero,8248fcc <vfread+0xa0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 8248f8c:	e0bfff17 	ldw	r2,-4(fp)
 8248f90:	10800117 	ldw	r2,4(r2)
 8248f94:	10800a17 	ldw	r2,40(r2)
 8248f98:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 8248f9c:	e0bff917 	ldw	r2,-28(fp)
 8248fa0:	10800317 	ldw	r2,12(r2)
 8248fa4:	e1ffff17 	ldw	r7,-4(fp)
 8248fa8:	e1bffe17 	ldw	r6,-8(fp)
 8248fac:	e17ffd17 	ldw	r5,-12(fp)
 8248fb0:	e13ffc17 	ldw	r4,-16(fp)
 8248fb4:	103ee83a 	callr	r2
 8248fb8:	e0bffa15 	stw	r2,-24(fp)
         vfs_unlock();
 8248fbc:	01000144 	movi	r4,5
 8248fc0:	822d9b00 	call	822d9b0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 8248fc4:	e0bffa17 	ldw	r2,-24(fp)
 8248fc8:	00003606 	br	82490a4 <vfread+0x178>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 8248fcc:	e0bfff17 	ldw	r2,-4(fp)
 8248fd0:	10800117 	ldw	r2,4(r2)
 8248fd4:	10800617 	ldw	r2,24(r2)
 8248fd8:	1000041e 	bne	r2,zero,8248fec <vfread+0xc0>
      {
         vfs_unlock();
 8248fdc:	01000144 	movi	r4,5
 8248fe0:	822d9b00 	call	822d9b0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8248fe4:	0005883a 	mov	r2,zero
 8248fe8:	00002e06 	br	82490a4 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 8248fec:	e0fffe17 	ldw	r3,-8(fp)
 8248ff0:	e0bffd17 	ldw	r2,-12(fp)
 8248ff4:	1885383a 	mul	r2,r3,r2
 8248ff8:	e0bff815 	stw	r2,-32(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 8248ffc:	e0bfff17 	ldw	r2,-4(fp)
 8249000:	10800217 	ldw	r2,8(r2)
 8249004:	1007883a 	mov	r3,r2
 8249008:	e0bfff17 	ldw	r2,-4(fp)
 824900c:	10800117 	ldw	r2,4(r2)
 8249010:	10800617 	ldw	r2,24(r2)
 8249014:	1885c83a 	sub	r2,r3,r2
 8249018:	e0bffb15 	stw	r2,-20(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 824901c:	e0fffb17 	ldw	r3,-20(fp)
 8249020:	e0bff817 	ldw	r2,-32(fp)
 8249024:	1885883a 	add	r2,r3,r2
 8249028:	e0ffff17 	ldw	r3,-4(fp)
 824902c:	18c00117 	ldw	r3,4(r3)
 8249030:	18c00817 	ldw	r3,32(r3)
 8249034:	1880062e 	bgeu	r3,r2,8249050 <vfread+0x124>
            bcount = (unsigned)(vfd->file->comp_size - location);
 8249038:	e0bfff17 	ldw	r2,-4(fp)
 824903c:	10800117 	ldw	r2,4(r2)
 8249040:	10c00817 	ldw	r3,32(r2)
 8249044:	e0bffb17 	ldw	r2,-20(fp)
 8249048:	1885c83a 	sub	r2,r3,r2
 824904c:	e0bff815 	stw	r2,-32(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 8249050:	e0bfff17 	ldw	r2,-4(fp)
 8249054:	10800217 	ldw	r2,8(r2)
 8249058:	e1bff817 	ldw	r6,-32(fp)
 824905c:	100b883a 	mov	r5,r2
 8249060:	e13ffc17 	ldw	r4,-16(fp)
 8249064:	8202c5c0 	call	8202c5c <memcpy>
         vfd->cmploc += bcount;
 8249068:	e0bfff17 	ldw	r2,-4(fp)
 824906c:	10c00217 	ldw	r3,8(r2)
 8249070:	e0bff817 	ldw	r2,-32(fp)
 8249074:	1887883a 	add	r3,r3,r2
 8249078:	e0bfff17 	ldw	r2,-4(fp)
 824907c:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 8249080:	01000144 	movi	r4,5
 8249084:	822d9b00 	call	822d9b0 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 8249088:	e17ffd17 	ldw	r5,-12(fp)
 824908c:	e13ff817 	ldw	r4,-32(fp)
 8249090:	820295c0 	call	820295c <__udivsi3>
 8249094:	00000306 	br	82490a4 <vfread+0x178>
   }

   vfs_unlock();
 8249098:	01000144 	movi	r4,5
 824909c:	822d9b00 	call	822d9b0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 82490a0:	0005883a 	mov	r2,zero
#endif   /* HT_LOCALFS */
}
 82490a4:	e037883a 	mov	sp,fp
 82490a8:	dfc00117 	ldw	ra,4(sp)
 82490ac:	df000017 	ldw	fp,0(sp)
 82490b0:	dec00204 	addi	sp,sp,8
 82490b4:	f800283a 	ret

082490b8 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82490b8:	defff204 	addi	sp,sp,-56
 82490bc:	dfc00d15 	stw	ra,52(sp)
 82490c0:	df000c15 	stw	fp,48(sp)
 82490c4:	df000c04 	addi	fp,sp,48
 82490c8:	e13ffc15 	stw	r4,-16(fp)
 82490cc:	e17ffd15 	stw	r5,-12(fp)
 82490d0:	e1bffe15 	stw	r6,-8(fp)
 82490d4:	e1ffff15 	stw	r7,-4(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 82490d8:	e13fff17 	ldw	r4,-4(fp)
 82490dc:	8249b9c0 	call	8249b9c <isvfile_locked>
 82490e0:	1000021e 	bne	r2,zero,82490ec <vfwrite_locked+0x34>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 82490e4:	00800244 	movi	r2,9
 82490e8:	0000da06 	br	8249454 <vfwrite_locked+0x39c>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 82490ec:	e0bfff17 	ldw	r2,-4(fp)
 82490f0:	10800117 	ldw	r2,4(r2)
 82490f4:	10800a17 	ldw	r2,40(r2)
 82490f8:	10000e26 	beq	r2,zero,8249134 <vfwrite_locked+0x7c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 82490fc:	e0bfff17 	ldw	r2,-4(fp)
 8249100:	10800117 	ldw	r2,4(r2)
 8249104:	10800a17 	ldw	r2,40(r2)
 8249108:	e0bff415 	stw	r2,-48(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 824910c:	e0bff417 	ldw	r2,-48(fp)
 8249110:	10800417 	ldw	r2,16(r2)
 8249114:	e1ffff17 	ldw	r7,-4(fp)
 8249118:	e1bffe17 	ldw	r6,-8(fp)
 824911c:	e17ffd17 	ldw	r5,-12(fp)
 8249120:	e13ffc17 	ldw	r4,-16(fp)
 8249124:	103ee83a 	callr	r2
 8249128:	e0bff515 	stw	r2,-44(fp)
      return rc;
 824912c:	e0bff517 	ldw	r2,-44(fp)
 8249130:	0000c806 	br	8249454 <vfwrite_locked+0x39c>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 8249134:	e0bfff17 	ldw	r2,-4(fp)
 8249138:	10800117 	ldw	r2,4(r2)
 824913c:	1000021e 	bne	r2,zero,8249148 <vfwrite_locked+0x90>
   {
      return 0;
 8249140:	0005883a 	mov	r2,zero
 8249144:	0000c306 	br	8249454 <vfwrite_locked+0x39c>
   }

   vfp = vfd->file;
 8249148:	e0bfff17 	ldw	r2,-4(fp)
 824914c:	10800117 	ldw	r2,4(r2)
 8249150:	e0bff615 	stw	r2,-40(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 8249154:	e0bff617 	ldw	r2,-40(fp)
 8249158:	1080058b 	ldhu	r2,22(r2)
 824915c:	10bfffcc 	andi	r2,r2,65535
 8249160:	1080080c 	andi	r2,r2,32
 8249164:	1000051e 	bne	r2,zero,824917c <vfwrite_locked+0xc4>
   {
      vfd->error = ENP_FILEIO;
 8249168:	e0bfff17 	ldw	r2,-4(fp)
 824916c:	00fff984 	movi	r3,-26
 8249170:	10c00415 	stw	r3,16(r2)
      return 0;
 8249174:	0005883a 	mov	r2,zero
 8249178:	0000b606 	br	8249454 <vfwrite_locked+0x39c>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 824917c:	e0fffd17 	ldw	r3,-12(fp)
 8249180:	e0bffe17 	ldw	r2,-8(fp)
 8249184:	1885383a 	mul	r2,r3,r2
 8249188:	e0bff715 	stw	r2,-36(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 824918c:	e0bff717 	ldw	r2,-36(fp)
 8249190:	1000021e 	bne	r2,zero,824919c <vfwrite_locked+0xe4>
   {
      return 0;
 8249194:	0005883a 	mov	r2,zero
 8249198:	0000ae06 	br	8249454 <vfwrite_locked+0x39c>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 824919c:	e0bff617 	ldw	r2,-40(fp)
 82491a0:	10800617 	ldw	r2,24(r2)
 82491a4:	10003d1e 	bne	r2,zero,824929c <vfwrite_locked+0x1e4>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 82491a8:	e0bff717 	ldw	r2,-36(fp)
 82491ac:	10bfffc4 	addi	r2,r2,-1
 82491b0:	1004d37a 	srli	r2,r2,13
 82491b4:	10800044 	addi	r2,r2,1
 82491b8:	1004937a 	slli	r2,r2,13
 82491bc:	e0bff815 	stw	r2,-32(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 82491c0:	e13ff817 	ldw	r4,-32(fp)
 82491c4:	82484c80 	call	82484c8 <vf_alloc_buffer>
 82491c8:	1007883a 	mov	r3,r2
 82491cc:	e0bff617 	ldw	r2,-40(fp)
 82491d0:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 82491d4:	e0bff617 	ldw	r2,-40(fp)
 82491d8:	10800617 	ldw	r2,24(r2)
 82491dc:	1000051e 	bne	r2,zero,82491f4 <vfwrite_locked+0x13c>
      {
         vfd->error = ENP_NOMEM;
 82491e0:	e0bfff17 	ldw	r2,-4(fp)
 82491e4:	00fffb04 	movi	r3,-20
 82491e8:	10c00415 	stw	r3,16(r2)
         return 0;
 82491ec:	0005883a 	mov	r2,zero
 82491f0:	00009806 	br	8249454 <vfwrite_locked+0x39c>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 82491f4:	e0bff617 	ldw	r2,-40(fp)
 82491f8:	e0fff817 	ldw	r3,-32(fp)
 82491fc:	10c00915 	stw	r3,36(r2)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 8249200:	e0bff617 	ldw	r2,-40(fp)
 8249204:	e0fff717 	ldw	r3,-36(fp)
 8249208:	10c00715 	stw	r3,28(r2)
      vfp->comp_size = bcount;
 824920c:	e0bff617 	ldw	r2,-40(fp)
 8249210:	e0fff717 	ldw	r3,-36(fp)
 8249214:	10c00815 	stw	r3,32(r2)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 8249218:	e0bff617 	ldw	r2,-40(fp)
 824921c:	10c00617 	ldw	r3,24(r2)
 8249220:	e0bff717 	ldw	r2,-36(fp)
 8249224:	1887883a 	add	r3,r3,r2
 8249228:	e0bfff17 	ldw	r2,-4(fp)
 824922c:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 8249230:	e0bff617 	ldw	r2,-40(fp)
 8249234:	10c0058b 	ldhu	r3,22(r2)
 8249238:	00bfff84 	movi	r2,-2
 824923c:	1884703a 	and	r2,r3,r2
 8249240:	1007883a 	mov	r3,r2
 8249244:	e0bff617 	ldw	r2,-40(fp)
 8249248:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 824924c:	e0bff617 	ldw	r2,-40(fp)
 8249250:	1080058b 	ldhu	r2,22(r2)
 8249254:	10808014 	ori	r2,r2,512
 8249258:	1007883a 	mov	r3,r2
 824925c:	e0bff617 	ldw	r2,-40(fp)
 8249260:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249264:	e0bff617 	ldw	r2,-40(fp)
 8249268:	1080058b 	ldhu	r2,22(r2)
 824926c:	10802014 	ori	r2,r2,128
 8249270:	1007883a 	mov	r3,r2
 8249274:	e0bff617 	ldw	r2,-40(fp)
 8249278:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 824927c:	e0bff617 	ldw	r2,-40(fp)
 8249280:	10800617 	ldw	r2,24(r2)
 8249284:	e1bff717 	ldw	r6,-36(fp)
 8249288:	e17ffc17 	ldw	r5,-16(fp)
 824928c:	1009883a 	mov	r4,r2
 8249290:	8202c5c0 	call	8202c5c <memcpy>

      /* return the number of "items" written */
      return items;
 8249294:	e0bffe17 	ldw	r2,-8(fp)
 8249298:	00006e06 	br	8249454 <vfwrite_locked+0x39c>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 824929c:	e0bfff17 	ldw	r2,-4(fp)
 82492a0:	10800217 	ldw	r2,8(r2)
 82492a4:	1007883a 	mov	r3,r2
 82492a8:	e0bff617 	ldw	r2,-40(fp)
 82492ac:	10800617 	ldw	r2,24(r2)
 82492b0:	1885c83a 	sub	r2,r3,r2
 82492b4:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 82492b8:	e0fff917 	ldw	r3,-28(fp)
 82492bc:	e0bff717 	ldw	r2,-36(fp)
 82492c0:	1885883a 	add	r2,r3,r2
 82492c4:	e0fff617 	ldw	r3,-40(fp)
 82492c8:	18c00917 	ldw	r3,36(r3)
 82492cc:	1880382e 	bgeu	r3,r2,82493b0 <vfwrite_locked+0x2f8>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 82492d0:	e0fff917 	ldw	r3,-28(fp)
 82492d4:	e0bff717 	ldw	r2,-36(fp)
 82492d8:	1885883a 	add	r2,r3,r2
 82492dc:	10bfffc4 	addi	r2,r2,-1
 82492e0:	1004d37a 	srli	r2,r2,13
 82492e4:	10800044 	addi	r2,r2,1
 82492e8:	1004937a 	slli	r2,r2,13
 82492ec:	e0bffa15 	stw	r2,-24(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 82492f0:	e13ffa17 	ldw	r4,-24(fp)
 82492f4:	82484c80 	call	82484c8 <vf_alloc_buffer>
 82492f8:	e0bffb15 	stw	r2,-20(fp)

      /* check for allocation failure */
      if (!new_buffer)
 82492fc:	e0bffb17 	ldw	r2,-20(fp)
 8249300:	1000051e 	bne	r2,zero,8249318 <vfwrite_locked+0x260>
      {
         vfd->error = ENP_NOMEM;
 8249304:	e0bfff17 	ldw	r2,-4(fp)
 8249308:	00fffb04 	movi	r3,-20
 824930c:	10c00415 	stw	r3,16(r2)
         return 0;
 8249310:	0005883a 	mov	r2,zero
 8249314:	00004f06 	br	8249454 <vfwrite_locked+0x39c>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8249318:	e0bff617 	ldw	r2,-40(fp)
 824931c:	10c00617 	ldw	r3,24(r2)
 8249320:	e0bff617 	ldw	r2,-40(fp)
 8249324:	10800817 	ldw	r2,32(r2)
 8249328:	100d883a 	mov	r6,r2
 824932c:	180b883a 	mov	r5,r3
 8249330:	e13ffb17 	ldw	r4,-20(fp)
 8249334:	8202c5c0 	call	8202c5c <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 8249338:	e0bff617 	ldw	r2,-40(fp)
 824933c:	1080058b 	ldhu	r2,22(r2)
 8249340:	10bfffcc 	andi	r2,r2,65535
 8249344:	1080200c 	andi	r2,r2,128
 8249348:	10000726 	beq	r2,zero,8249368 <vfwrite_locked+0x2b0>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 824934c:	e0bff617 	ldw	r2,-40(fp)
 8249350:	10c00617 	ldw	r3,24(r2)
 8249354:	e0bff617 	ldw	r2,-40(fp)
 8249358:	10800917 	ldw	r2,36(r2)
 824935c:	100b883a 	mov	r5,r2
 8249360:	1809883a 	mov	r4,r3
 8249364:	82485900 	call	8248590 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 8249368:	e0bff617 	ldw	r2,-40(fp)
 824936c:	e0fffb17 	ldw	r3,-20(fp)
 8249370:	10c00615 	stw	r3,24(r2)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 8249374:	e0bff617 	ldw	r2,-40(fp)
 8249378:	e0fffa17 	ldw	r3,-24(fp)
 824937c:	10c00915 	stw	r3,36(r2)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249380:	e0bff617 	ldw	r2,-40(fp)
 8249384:	1080058b 	ldhu	r2,22(r2)
 8249388:	10802014 	ori	r2,r2,128
 824938c:	1007883a 	mov	r3,r2
 8249390:	e0bff617 	ldw	r2,-40(fp)
 8249394:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 8249398:	e0bff617 	ldw	r2,-40(fp)
 824939c:	10c00617 	ldw	r3,24(r2)
 82493a0:	e0bff917 	ldw	r2,-28(fp)
 82493a4:	1887883a 	add	r3,r3,r2
 82493a8:	e0bfff17 	ldw	r2,-4(fp)
 82493ac:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 82493b0:	e0bfff17 	ldw	r2,-4(fp)
 82493b4:	10800217 	ldw	r2,8(r2)
 82493b8:	e1bff717 	ldw	r6,-36(fp)
 82493bc:	e17ffc17 	ldw	r5,-16(fp)
 82493c0:	1009883a 	mov	r4,r2
 82493c4:	8202c5c0 	call	8202c5c <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 82493c8:	e0bfff17 	ldw	r2,-4(fp)
 82493cc:	10c00217 	ldw	r3,8(r2)
 82493d0:	e0bff717 	ldw	r2,-36(fp)
 82493d4:	1887883a 	add	r3,r3,r2
 82493d8:	e0bfff17 	ldw	r2,-4(fp)
 82493dc:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 82493e0:	e0fff917 	ldw	r3,-28(fp)
 82493e4:	e0bff717 	ldw	r2,-36(fp)
 82493e8:	1885883a 	add	r2,r3,r2
 82493ec:	e0fff617 	ldw	r3,-40(fp)
 82493f0:	18c00817 	ldw	r3,32(r3)
 82493f4:	1880052e 	bgeu	r3,r2,824940c <vfwrite_locked+0x354>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 82493f8:	e0fff917 	ldw	r3,-28(fp)
 82493fc:	e0bff717 	ldw	r2,-36(fp)
 8249400:	1887883a 	add	r3,r3,r2
 8249404:	e0bff617 	ldw	r2,-40(fp)
 8249408:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 824940c:	e0bff617 	ldw	r2,-40(fp)
 8249410:	10c00817 	ldw	r3,32(r2)
 8249414:	e0bff617 	ldw	r2,-40(fp)
 8249418:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 824941c:	e0bff617 	ldw	r2,-40(fp)
 8249420:	10c0058b 	ldhu	r3,22(r2)
 8249424:	00bfff84 	movi	r2,-2
 8249428:	1884703a 	and	r2,r3,r2
 824942c:	1007883a 	mov	r3,r2
 8249430:	e0bff617 	ldw	r2,-40(fp)
 8249434:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 8249438:	e0bff617 	ldw	r2,-40(fp)
 824943c:	1080058b 	ldhu	r2,22(r2)
 8249440:	10808014 	ori	r2,r2,512
 8249444:	1007883a 	mov	r3,r2
 8249448:	e0bff617 	ldw	r2,-40(fp)
 824944c:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 8249450:	e0bffe17 	ldw	r2,-8(fp)

#endif   /* HT_RWVFS */
}
 8249454:	e037883a 	mov	sp,fp
 8249458:	dfc00117 	ldw	ra,4(sp)
 824945c:	df000017 	ldw	fp,0(sp)
 8249460:	dec00204 	addi	sp,sp,8
 8249464:	f800283a 	ret

08249468 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8249468:	defff904 	addi	sp,sp,-28
 824946c:	dfc00615 	stw	ra,24(sp)
 8249470:	df000515 	stw	fp,20(sp)
 8249474:	df000504 	addi	fp,sp,20
 8249478:	e13ffc15 	stw	r4,-16(fp)
 824947c:	e17ffd15 	stw	r5,-12(fp)
 8249480:	e1bffe15 	stw	r6,-8(fp)
 8249484:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8249488:	01000144 	movi	r4,5
 824948c:	822d8f40 	call	822d8f4 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 8249490:	e1ffff17 	ldw	r7,-4(fp)
 8249494:	e1bffe17 	ldw	r6,-8(fp)
 8249498:	e17ffd17 	ldw	r5,-12(fp)
 824949c:	e13ffc17 	ldw	r4,-16(fp)
 82494a0:	82490b80 	call	82490b8 <vfwrite_locked>
 82494a4:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 82494a8:	01000144 	movi	r4,5
 82494ac:	822d9b00 	call	822d9b0 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 82494b0:	e0bffb17 	ldw	r2,-20(fp)
}
 82494b4:	e037883a 	mov	sp,fp
 82494b8:	dfc00117 	ldw	ra,4(sp)
 82494bc:	df000017 	ldw	fp,0(sp)
 82494c0:	dec00204 	addi	sp,sp,8
 82494c4:	f800283a 	ret

082494c8 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 82494c8:	defff904 	addi	sp,sp,-28
 82494cc:	dfc00615 	stw	ra,24(sp)
 82494d0:	df000515 	stw	fp,20(sp)
 82494d4:	df000504 	addi	fp,sp,20
 82494d8:	e13ffd15 	stw	r4,-12(fp)
 82494dc:	e17ffe15 	stw	r5,-8(fp)
 82494e0:	e1bfff15 	stw	r6,-4(fp)
   /* lock the VFS */
   vfs_lock();
 82494e4:	01000144 	movi	r4,5
 82494e8:	822d8f40 	call	822d8f4 <wait_app_sem>

   if (isvfile_locked(vfd))
 82494ec:	e13ffd17 	ldw	r4,-12(fp)
 82494f0:	8249b9c0 	call	8249b9c <isvfile_locked>
 82494f4:	10003f26 	beq	r2,zero,82495f4 <vfseek+0x12c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 82494f8:	e0bffd17 	ldw	r2,-12(fp)
 82494fc:	10800117 	ldw	r2,4(r2)
 8249500:	1000041e 	bne	r2,zero,8249514 <vfseek+0x4c>
      {
         vfs_unlock();
 8249504:	01000144 	movi	r4,5
 8249508:	822d9b00 	call	822d9b0 <post_app_sem>
         return -1;
 824950c:	00bfffc4 	movi	r2,-1
 8249510:	00003b06 	br	8249600 <vfseek+0x138>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249514:	e0bffd17 	ldw	r2,-12(fp)
 8249518:	10800117 	ldw	r2,4(r2)
 824951c:	10800a17 	ldw	r2,40(r2)
 8249520:	10000f26 	beq	r2,zero,8249560 <vfseek+0x98>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 8249524:	e0bffd17 	ldw	r2,-12(fp)
 8249528:	10800117 	ldw	r2,4(r2)
 824952c:	10800a17 	ldw	r2,40(r2)
 8249530:	e0bffb15 	stw	r2,-20(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 8249534:	e0bffb17 	ldw	r2,-20(fp)
 8249538:	10800517 	ldw	r2,20(r2)
 824953c:	e1bfff17 	ldw	r6,-4(fp)
 8249540:	e17ffe17 	ldw	r5,-8(fp)
 8249544:	e13ffd17 	ldw	r4,-12(fp)
 8249548:	103ee83a 	callr	r2
 824954c:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 8249550:	01000144 	movi	r4,5
 8249554:	822d9b00 	call	822d9b0 <post_app_sem>
         return rc;
 8249558:	e0bffc17 	ldw	r2,-16(fp)
 824955c:	00002806 	br	8249600 <vfseek+0x138>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 8249560:	e0bfff17 	ldw	r2,-4(fp)
 8249564:	10c00060 	cmpeqi	r3,r2,1
 8249568:	18000b1e 	bne	r3,zero,8249598 <vfseek+0xd0>
 824956c:	10c000a0 	cmpeqi	r3,r2,2
 8249570:	1800101e 	bne	r3,zero,82495b4 <vfseek+0xec>
 8249574:	10001b1e 	bne	r2,zero,82495e4 <vfseek+0x11c>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 8249578:	e0bffd17 	ldw	r2,-12(fp)
 824957c:	10800117 	ldw	r2,4(r2)
 8249580:	10c00617 	ldw	r3,24(r2)
 8249584:	e0bffe17 	ldw	r2,-8(fp)
 8249588:	1887883a 	add	r3,r3,r2
 824958c:	e0bffd17 	ldw	r2,-12(fp)
 8249590:	10c00215 	stw	r3,8(r2)
         break;
 8249594:	00001306 	br	82495e4 <vfseek+0x11c>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 8249598:	e0bffd17 	ldw	r2,-12(fp)
 824959c:	10c00217 	ldw	r3,8(r2)
 82495a0:	e0bffe17 	ldw	r2,-8(fp)
 82495a4:	1887883a 	add	r3,r3,r2
 82495a8:	e0bffd17 	ldw	r2,-12(fp)
 82495ac:	10c00215 	stw	r3,8(r2)
         break;
 82495b0:	00000c06 	br	82495e4 <vfseek+0x11c>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 82495b4:	e0bffd17 	ldw	r2,-12(fp)
 82495b8:	10800117 	ldw	r2,4(r2)
 82495bc:	10c00617 	ldw	r3,24(r2)
 82495c0:	e0bffd17 	ldw	r2,-12(fp)
 82495c4:	10800117 	ldw	r2,4(r2)
 82495c8:	11000817 	ldw	r4,32(r2)
 82495cc:	e0bffe17 	ldw	r2,-8(fp)
 82495d0:	2085883a 	add	r2,r4,r2
 82495d4:	1887883a 	add	r3,r3,r2
 82495d8:	e0bffd17 	ldw	r2,-12(fp)
 82495dc:	10c00215 	stw	r3,8(r2)
         break;
 82495e0:	0001883a 	nop
      }
      vfs_unlock();
 82495e4:	01000144 	movi	r4,5
 82495e8:	822d9b00 	call	822d9b0 <post_app_sem>
      return(0);
 82495ec:	0005883a 	mov	r2,zero
 82495f0:	00000306 	br	8249600 <vfseek+0x138>
   }

   vfs_unlock();
 82495f4:	01000144 	movi	r4,5
 82495f8:	822d9b00 	call	822d9b0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 82495fc:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249600:	e037883a 	mov	sp,fp
 8249604:	dfc00117 	ldw	ra,4(sp)
 8249608:	df000017 	ldw	fp,0(sp)
 824960c:	dec00204 	addi	sp,sp,8
 8249610:	f800283a 	ret

08249614 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 8249614:	defffb04 	addi	sp,sp,-20
 8249618:	dfc00415 	stw	ra,16(sp)
 824961c:	df000315 	stw	fp,12(sp)
 8249620:	df000304 	addi	fp,sp,12
 8249624:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249628:	01000144 	movi	r4,5
 824962c:	822d8f40 	call	822d8f4 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249630:	e13fff17 	ldw	r4,-4(fp)
 8249634:	8249b9c0 	call	8249b9c <isvfile_locked>
 8249638:	10003226 	beq	r2,zero,8249704 <vftell+0xf0>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 824963c:	e0bfff17 	ldw	r2,-4(fp)
 8249640:	10800117 	ldw	r2,4(r2)
 8249644:	1000041e 	bne	r2,zero,8249658 <vftell+0x44>
      {
         vfs_unlock();
 8249648:	01000144 	movi	r4,5
 824964c:	822d9b00 	call	822d9b0 <post_app_sem>
         return -1;
 8249650:	00bfffc4 	movi	r2,-1
 8249654:	00002e06 	br	8249710 <vftell+0xfc>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249658:	e0bfff17 	ldw	r2,-4(fp)
 824965c:	10800117 	ldw	r2,4(r2)
 8249660:	10800a17 	ldw	r2,40(r2)
 8249664:	10000d26 	beq	r2,zero,824969c <vftell+0x88>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249668:	e0bfff17 	ldw	r2,-4(fp)
 824966c:	10800117 	ldw	r2,4(r2)
 8249670:	10800a17 	ldw	r2,40(r2)
 8249674:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 8249678:	e0bffd17 	ldw	r2,-12(fp)
 824967c:	10800617 	ldw	r2,24(r2)
 8249680:	e13fff17 	ldw	r4,-4(fp)
 8249684:	103ee83a 	callr	r2
 8249688:	e0bffe15 	stw	r2,-8(fp)
         vfs_unlock();
 824968c:	01000144 	movi	r4,5
 8249690:	822d9b00 	call	822d9b0 <post_app_sem>
         return rc;
 8249694:	e0bffe17 	ldw	r2,-8(fp)
 8249698:	00001d06 	br	8249710 <vftell+0xfc>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 824969c:	e0bfff17 	ldw	r2,-4(fp)
 82496a0:	10c00217 	ldw	r3,8(r2)
 82496a4:	e0bfff17 	ldw	r2,-4(fp)
 82496a8:	10800117 	ldw	r2,4(r2)
 82496ac:	11000617 	ldw	r4,24(r2)
 82496b0:	e0bfff17 	ldw	r2,-4(fp)
 82496b4:	10800117 	ldw	r2,4(r2)
 82496b8:	10800817 	ldw	r2,32(r2)
 82496bc:	2085883a 	add	r2,r4,r2
 82496c0:	1880061e 	bne	r3,r2,82496dc <vftell+0xc8>
      {
         vfs_unlock();
 82496c4:	01000144 	movi	r4,5
 82496c8:	822d9b00 	call	822d9b0 <post_app_sem>

         return vfd->file->comp_size;
 82496cc:	e0bfff17 	ldw	r2,-4(fp)
 82496d0:	10800117 	ldw	r2,4(r2)
 82496d4:	10800817 	ldw	r2,32(r2)
 82496d8:	00000d06 	br	8249710 <vftell+0xfc>
      }
      else
      {
         vfs_unlock();
 82496dc:	01000144 	movi	r4,5
 82496e0:	822d9b00 	call	822d9b0 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 82496e4:	e0bfff17 	ldw	r2,-4(fp)
 82496e8:	10800217 	ldw	r2,8(r2)
 82496ec:	1007883a 	mov	r3,r2
 82496f0:	e0bfff17 	ldw	r2,-4(fp)
 82496f4:	10800117 	ldw	r2,4(r2)
 82496f8:	10800617 	ldw	r2,24(r2)
 82496fc:	1885c83a 	sub	r2,r3,r2
 8249700:	00000306 	br	8249710 <vftell+0xfc>
      }
   }

   vfs_unlock();
 8249704:	01000144 	movi	r4,5
 8249708:	822d9b00 	call	822d9b0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 824970c:	00800244 	movi	r2,9
#endif   /* HT_LOCALFS */
}
 8249710:	e037883a 	mov	sp,fp
 8249714:	dfc00117 	ldw	ra,4(sp)
 8249718:	df000017 	ldw	fp,0(sp)
 824971c:	dec00204 	addi	sp,sp,8
 8249720:	f800283a 	ret

08249724 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 8249724:	defffb04 	addi	sp,sp,-20
 8249728:	dfc00415 	stw	ra,16(sp)
 824972c:	df000315 	stw	fp,12(sp)
 8249730:	df000304 	addi	fp,sp,12
 8249734:	e13fff15 	stw	r4,-4(fp)
   int   chr;

   if (isvfile_locked(vfd))
 8249738:	e13fff17 	ldw	r4,-4(fp)
 824973c:	8249b9c0 	call	8249b9c <isvfile_locked>
 8249740:	10002f26 	beq	r2,zero,8249800 <vgetc_locked+0xdc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 8249744:	e0bfff17 	ldw	r2,-4(fp)
 8249748:	10800117 	ldw	r2,4(r2)
 824974c:	1000021e 	bne	r2,zero,8249758 <vgetc_locked+0x34>
      {
         return EOF;
 8249750:	00bfffc4 	movi	r2,-1
 8249754:	00002c06 	br	8249808 <vgetc_locked+0xe4>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249758:	e0bfff17 	ldw	r2,-4(fp)
 824975c:	10800117 	ldw	r2,4(r2)
 8249760:	10800a17 	ldw	r2,40(r2)
 8249764:	10000926 	beq	r2,zero,824978c <vgetc_locked+0x68>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249768:	e0bfff17 	ldw	r2,-4(fp)
 824976c:	10800117 	ldw	r2,4(r2)
 8249770:	10800a17 	ldw	r2,40(r2)
 8249774:	e0bffe15 	stw	r2,-8(fp)
         return (vfp->r_fgetc(vfd));
 8249778:	e0bffe17 	ldw	r2,-8(fp)
 824977c:	10800717 	ldw	r2,28(r2)
 8249780:	e13fff17 	ldw	r4,-4(fp)
 8249784:	103ee83a 	callr	r2
 8249788:	00001f06 	br	8249808 <vgetc_locked+0xe4>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 824978c:	e0bfff17 	ldw	r2,-4(fp)
 8249790:	10800117 	ldw	r2,4(r2)
 8249794:	10800617 	ldw	r2,24(r2)
 8249798:	1000021e 	bne	r2,zero,82497a4 <vgetc_locked+0x80>
         return EOF;
 824979c:	00bfffc4 	movi	r2,-1
 82497a0:	00001906 	br	8249808 <vgetc_locked+0xe4>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 82497a4:	e0bfff17 	ldw	r2,-4(fp)
 82497a8:	10c00217 	ldw	r3,8(r2)
 82497ac:	e0bfff17 	ldw	r2,-4(fp)
 82497b0:	10800117 	ldw	r2,4(r2)
 82497b4:	11000617 	ldw	r4,24(r2)
 82497b8:	e0bfff17 	ldw	r2,-4(fp)
 82497bc:	10800117 	ldw	r2,4(r2)
 82497c0:	10800817 	ldw	r2,32(r2)
 82497c4:	2085883a 	add	r2,r4,r2
 82497c8:	18800336 	bltu	r3,r2,82497d8 <vgetc_locked+0xb4>
            chr = EOF;
 82497cc:	00bfffc4 	movi	r2,-1
 82497d0:	e0bffd15 	stw	r2,-12(fp)
 82497d4:	00000806 	br	82497f8 <vgetc_locked+0xd4>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 82497d8:	e0bfff17 	ldw	r2,-4(fp)
 82497dc:	10800217 	ldw	r2,8(r2)
 82497e0:	11000044 	addi	r4,r2,1
 82497e4:	e0ffff17 	ldw	r3,-4(fp)
 82497e8:	19000215 	stw	r4,8(r3)
 82497ec:	10800003 	ldbu	r2,0(r2)
 82497f0:	10803fcc 	andi	r2,r2,255
 82497f4:	e0bffd15 	stw	r2,-12(fp)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 82497f8:	e0bffd17 	ldw	r2,-12(fp)
 82497fc:	00000206 	br	8249808 <vgetc_locked+0xe4>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 8249800:	822d2e00 	call	822d2e0 <dtrap>
   return EOF;
 8249804:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249808:	e037883a 	mov	sp,fp
 824980c:	dfc00117 	ldw	ra,4(sp)
 8249810:	df000017 	ldw	fp,0(sp)
 8249814:	dec00204 	addi	sp,sp,8
 8249818:	f800283a 	ret

0824981c <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 824981c:	defffc04 	addi	sp,sp,-16
 8249820:	dfc00315 	stw	ra,12(sp)
 8249824:	df000215 	stw	fp,8(sp)
 8249828:	df000204 	addi	fp,sp,8
 824982c:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249830:	01000144 	movi	r4,5
 8249834:	822d8f40 	call	822d8f4 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 8249838:	e13fff17 	ldw	r4,-4(fp)
 824983c:	82497240 	call	8249724 <vgetc_locked>
 8249840:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249844:	01000144 	movi	r4,5
 8249848:	822d9b00 	call	822d9b0 <post_app_sem>
   return rc;
 824984c:	e0bffe17 	ldw	r2,-8(fp)
}
 8249850:	e037883a 	mov	sp,fp
 8249854:	dfc00117 	ldw	ra,4(sp)
 8249858:	df000017 	ldw	fp,0(sp)
 824985c:	dec00204 	addi	sp,sp,8
 8249860:	f800283a 	ret

08249864 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 8249864:	defffb04 	addi	sp,sp,-20
 8249868:	dfc00415 	stw	ra,16(sp)
 824986c:	df000315 	stw	fp,12(sp)
 8249870:	df000304 	addi	fp,sp,12
 8249874:	e13fff15 	stw	r4,-4(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 8249878:	e0bfff17 	ldw	r2,-4(fp)
 824987c:	10800003 	ldbu	r2,0(r2)
 8249880:	10803fcc 	andi	r2,r2,255
 8249884:	1080201c 	xori	r2,r2,128
 8249888:	10bfe004 	addi	r2,r2,-128
 824988c:	10800be0 	cmpeqi	r2,r2,47
 8249890:	1000071e 	bne	r2,zero,82498b0 <vfslookup_locked+0x4c>
 8249894:	e0bfff17 	ldw	r2,-4(fp)
 8249898:	10800003 	ldbu	r2,0(r2)
 824989c:	10803fcc 	andi	r2,r2,255
 82498a0:	1080201c 	xori	r2,r2,128
 82498a4:	10bfe004 	addi	r2,r2,-128
 82498a8:	10801718 	cmpnei	r2,r2,92
 82498ac:	1000191e 	bne	r2,zero,8249914 <vfslookup_locked+0xb0>
   {
      cp = strippath(name);
 82498b0:	e13fff17 	ldw	r4,-4(fp)
 82498b4:	82499d00 	call	82499d0 <strippath>
 82498b8:	e0bffe15 	stw	r2,-8(fp)

      if (!cp) /* strippath coundn't match our path */
 82498bc:	e0bffe17 	ldw	r2,-8(fp)
 82498c0:	1000121e 	bne	r2,zero,824990c <vfslookup_locked+0xa8>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 82498c4:	e0bfff17 	ldw	r2,-4(fp)
 82498c8:	10800003 	ldbu	r2,0(r2)
 82498cc:	10803fcc 	andi	r2,r2,255
 82498d0:	1080201c 	xori	r2,r2,128
 82498d4:	10bfe004 	addi	r2,r2,-128
 82498d8:	10800be0 	cmpeqi	r2,r2,47
 82498dc:	1000071e 	bne	r2,zero,82498fc <vfslookup_locked+0x98>
 82498e0:	e0bfff17 	ldw	r2,-4(fp)
 82498e4:	10800003 	ldbu	r2,0(r2)
 82498e8:	10803fcc 	andi	r2,r2,255
 82498ec:	1080201c 	xori	r2,r2,128
 82498f0:	10bfe004 	addi	r2,r2,-128
 82498f4:	10801718 	cmpnei	r2,r2,92
 82498f8:	1000061e 	bne	r2,zero,8249914 <vfslookup_locked+0xb0>
            name++;
 82498fc:	e0bfff17 	ldw	r2,-4(fp)
 8249900:	10800044 	addi	r2,r2,1
 8249904:	e0bfff15 	stw	r2,-4(fp)
 8249908:	00000206 	br	8249914 <vfslookup_locked+0xb0>
      }
      else
         name = cp ;
 824990c:	e0bffe17 	ldw	r2,-8(fp)
 8249910:	e0bfff15 	stw	r2,-4(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 8249914:	01400fc4 	movi	r5,63
 8249918:	e13fff17 	ldw	r4,-4(fp)
 824991c:	82034d00 	call	82034d0 <strchr>
 8249920:	10000326 	beq	r2,zero,8249930 <vfslookup_locked+0xcc>
   {
      dtrap(); /* is this still allowed? */
 8249924:	822d2e00 	call	822d2e0 <dtrap>
      return NULL;
 8249928:	0005883a 	mov	r2,zero
 824992c:	00001106 	br	8249974 <vfslookup_locked+0x110>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249930:	d0a0d617 	ldw	r2,-31912(gp)
 8249934:	e0bffd15 	stw	r2,-12(fp)
 8249938:	00000b06 	br	8249968 <vfslookup_locked+0x104>
   {
      if (strcmp(name, vp->name) == 0)
 824993c:	e0bffd17 	ldw	r2,-12(fp)
 8249940:	10800104 	addi	r2,r2,4
 8249944:	100b883a 	mov	r5,r2
 8249948:	e13fff17 	ldw	r4,-4(fp)
 824994c:	820dcf80 	call	820dcf8 <strcmp>
 8249950:	1000021e 	bne	r2,zero,824995c <vfslookup_locked+0xf8>
         return vp;
 8249954:	e0bffd17 	ldw	r2,-12(fp)
 8249958:	00000606 	br	8249974 <vfslookup_locked+0x110>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 824995c:	e0bffd17 	ldw	r2,-12(fp)
 8249960:	10800017 	ldw	r2,0(r2)
 8249964:	e0bffd15 	stw	r2,-12(fp)
 8249968:	e0bffd17 	ldw	r2,-12(fp)
 824996c:	103ff31e 	bne	r2,zero,824993c <vfslookup_locked+0xd8>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 8249970:	0005883a 	mov	r2,zero
}
 8249974:	e037883a 	mov	sp,fp
 8249978:	dfc00117 	ldw	ra,4(sp)
 824997c:	df000017 	ldw	fp,0(sp)
 8249980:	dec00204 	addi	sp,sp,8
 8249984:	f800283a 	ret

08249988 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 8249988:	defffc04 	addi	sp,sp,-16
 824998c:	dfc00315 	stw	ra,12(sp)
 8249990:	df000215 	stw	fp,8(sp)
 8249994:	df000204 	addi	fp,sp,8
 8249998:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 824999c:	01000144 	movi	r4,5
 82499a0:	822d8f40 	call	822d8f4 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 82499a4:	e13fff17 	ldw	r4,-4(fp)
 82499a8:	82498640 	call	8249864 <vfslookup_locked>
 82499ac:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 82499b0:	01000144 	movi	r4,5
 82499b4:	822d9b00 	call	822d9b0 <post_app_sem>
   return vp;
 82499b8:	e0bffe17 	ldw	r2,-8(fp)
}
 82499bc:	e037883a 	mov	sp,fp
 82499c0:	dfc00117 	ldw	ra,4(sp)
 82499c4:	df000017 	ldw	fp,0(sp)
 82499c8:	dec00204 	addi	sp,sp,8
 82499cc:	f800283a 	ret

082499d0 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 82499d0:	defff904 	addi	sp,sp,-28
 82499d4:	dfc00615 	stw	ra,24(sp)
 82499d8:	df000515 	stw	fp,20(sp)
 82499dc:	df000504 	addi	fp,sp,20
 82499e0:	e13fff15 	stw	r4,-4(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 82499e4:	e13fff17 	ldw	r4,-4(fp)
 82499e8:	8228b300 	call	8228b30 <uslash>
 82499ec:	e0bffc15 	stw	r2,-16(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 82499f0:	d0a05517 	ldw	r2,-32428(gp)
 82499f4:	e0bffb15 	stw	r2,-20(fp)
   while (*path && *ntmp)
 82499f8:	00003a06 	br	8249ae4 <strippath+0x114>
   {
      while (*path == '/') path++;   /* strip leading slash */
 82499fc:	e0bffb17 	ldw	r2,-20(fp)
 8249a00:	10800044 	addi	r2,r2,1
 8249a04:	e0bffb15 	stw	r2,-20(fp)
 8249a08:	e0bffb17 	ldw	r2,-20(fp)
 8249a0c:	10800003 	ldbu	r2,0(r2)
 8249a10:	10803fcc 	andi	r2,r2,255
 8249a14:	1080201c 	xori	r2,r2,128
 8249a18:	10bfe004 	addi	r2,r2,-128
 8249a1c:	10800be0 	cmpeqi	r2,r2,47
 8249a20:	103ff61e 	bne	r2,zero,82499fc <strippath+0x2c>
         if (*path == 0)
 8249a24:	e0bffb17 	ldw	r2,-20(fp)
 8249a28:	10800003 	ldbu	r2,0(r2)
 8249a2c:	10803fcc 	andi	r2,r2,255
 8249a30:	1080201c 	xori	r2,r2,128
 8249a34:	10bfe004 	addi	r2,r2,-128
 8249a38:	10003726 	beq	r2,zero,8249b18 <strippath+0x148>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 8249a3c:	01400bc4 	movi	r5,47
 8249a40:	e13ffb17 	ldw	r4,-20(fp)
 8249a44:	82034d00 	call	82034d0 <strchr>
 8249a48:	e0bffe15 	stw	r2,-8(fp)
      if (ptmp)
 8249a4c:	e0bffe17 	ldw	r2,-8(fp)
 8249a50:	10000526 	beq	r2,zero,8249a68 <strippath+0x98>
         dirlen = ptmp - path;
 8249a54:	e0fffe17 	ldw	r3,-8(fp)
 8249a58:	e0bffb17 	ldw	r2,-20(fp)
 8249a5c:	1885c83a 	sub	r2,r3,r2
 8249a60:	e0bffd15 	stw	r2,-12(fp)
 8249a64:	00000706 	br	8249a84 <strippath+0xb4>
      else
         dirlen = strlen(path);
 8249a68:	e13ffb17 	ldw	r4,-20(fp)
 8249a6c:	8203cac0 	call	8203cac <strlen>
 8249a70:	e0bffd15 	stw	r2,-12(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 8249a74:	00000306 	br	8249a84 <strippath+0xb4>
 8249a78:	e0bffc17 	ldw	r2,-16(fp)
 8249a7c:	10800044 	addi	r2,r2,1
 8249a80:	e0bffc15 	stw	r2,-16(fp)
 8249a84:	e0bffc17 	ldw	r2,-16(fp)
 8249a88:	10800003 	ldbu	r2,0(r2)
 8249a8c:	10803fcc 	andi	r2,r2,255
 8249a90:	1080201c 	xori	r2,r2,128
 8249a94:	10bfe004 	addi	r2,r2,-128
 8249a98:	10800be0 	cmpeqi	r2,r2,47
 8249a9c:	103ff61e 	bne	r2,zero,8249a78 <strippath+0xa8>
         if (strncmp(ntmp, path, dirlen) == 0)
 8249aa0:	e0bffd17 	ldw	r2,-12(fp)
 8249aa4:	100d883a 	mov	r6,r2
 8249aa8:	e17ffb17 	ldw	r5,-20(fp)
 8249aac:	e13ffc17 	ldw	r4,-16(fp)
 8249ab0:	824b4940 	call	824b494 <strncmp>
 8249ab4:	1000091e 	bne	r2,zero,8249adc <strippath+0x10c>
      {
         path += dirlen;
 8249ab8:	e0bffd17 	ldw	r2,-12(fp)
 8249abc:	e0fffb17 	ldw	r3,-20(fp)
 8249ac0:	1885883a 	add	r2,r3,r2
 8249ac4:	e0bffb15 	stw	r2,-20(fp)
         ntmp += dirlen;
 8249ac8:	e0bffd17 	ldw	r2,-12(fp)
 8249acc:	e0fffc17 	ldw	r3,-16(fp)
 8249ad0:	1885883a 	add	r2,r3,r2
 8249ad4:	e0bffc15 	stw	r2,-16(fp)
 8249ad8:	00000206 	br	8249ae4 <strippath+0x114>
      }
      else
         return NULL;   /* didn't match */
 8249adc:	0005883a 	mov	r2,zero
 8249ae0:	00002906 	br	8249b88 <strippath+0x1b8>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 8249ae4:	e0bffb17 	ldw	r2,-20(fp)
 8249ae8:	10800003 	ldbu	r2,0(r2)
 8249aec:	10803fcc 	andi	r2,r2,255
 8249af0:	1080201c 	xori	r2,r2,128
 8249af4:	10bfe004 	addi	r2,r2,-128
 8249af8:	10000826 	beq	r2,zero,8249b1c <strippath+0x14c>
 8249afc:	e0bffc17 	ldw	r2,-16(fp)
 8249b00:	10800003 	ldbu	r2,0(r2)
 8249b04:	10803fcc 	andi	r2,r2,255
 8249b08:	1080201c 	xori	r2,r2,128
 8249b0c:	10bfe004 	addi	r2,r2,-128
 8249b10:	103fbd1e 	bne	r2,zero,8249a08 <strippath+0x38>
 8249b14:	00000106 	br	8249b1c <strippath+0x14c>
   {
      while (*path == '/') path++;   /* strip leading slash */
         if (*path == 0)
         break;
 8249b18:	0001883a 	nop
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 8249b1c:	e0bffb17 	ldw	r2,-20(fp)
 8249b20:	10800003 	ldbu	r2,0(r2)
 8249b24:	10803fcc 	andi	r2,r2,255
 8249b28:	1080201c 	xori	r2,r2,128
 8249b2c:	10bfe004 	addi	r2,r2,-128
 8249b30:	1000141e 	bne	r2,zero,8249b84 <strippath+0x1b4>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249b34:	00000306 	br	8249b44 <strippath+0x174>
         ntmp++;
 8249b38:	e0bffc17 	ldw	r2,-16(fp)
 8249b3c:	10800044 	addi	r2,r2,1
 8249b40:	e0bffc15 	stw	r2,-16(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249b44:	e0bffc17 	ldw	r2,-16(fp)
 8249b48:	10800003 	ldbu	r2,0(r2)
 8249b4c:	10803fcc 	andi	r2,r2,255
 8249b50:	1080201c 	xori	r2,r2,128
 8249b54:	10bfe004 	addi	r2,r2,-128
 8249b58:	10801720 	cmpeqi	r2,r2,92
 8249b5c:	103ff61e 	bne	r2,zero,8249b38 <strippath+0x168>
 8249b60:	e0bffc17 	ldw	r2,-16(fp)
 8249b64:	10800003 	ldbu	r2,0(r2)
 8249b68:	10803fcc 	andi	r2,r2,255
 8249b6c:	1080201c 	xori	r2,r2,128
 8249b70:	10bfe004 	addi	r2,r2,-128
 8249b74:	10800be0 	cmpeqi	r2,r2,47
 8249b78:	103fef1e 	bne	r2,zero,8249b38 <strippath+0x168>
         ntmp++;
      return ntmp;
 8249b7c:	e0bffc17 	ldw	r2,-16(fp)
 8249b80:	00000106 	br	8249b88 <strippath+0x1b8>
   }
   else
      return NULL;
 8249b84:	0005883a 	mov	r2,zero
}
 8249b88:	e037883a 	mov	sp,fp
 8249b8c:	dfc00117 	ldw	ra,4(sp)
 8249b90:	df000017 	ldw	fp,0(sp)
 8249b94:	dec00204 	addi	sp,sp,8
 8249b98:	f800283a 	ret

08249b9c <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 8249b9c:	defffd04 	addi	sp,sp,-12
 8249ba0:	df000215 	stw	fp,8(sp)
 8249ba4:	df000204 	addi	fp,sp,8
 8249ba8:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249bac:	d0a0d517 	ldw	r2,-31916(gp)
 8249bb0:	e0bffe15 	stw	r2,-8(fp)
 8249bb4:	00000806 	br	8249bd8 <isvfile_locked+0x3c>
      if (vtmp == vfp)
 8249bb8:	e0fffe17 	ldw	r3,-8(fp)
 8249bbc:	e0bfff17 	ldw	r2,-4(fp)
 8249bc0:	1880021e 	bne	r3,r2,8249bcc <isvfile_locked+0x30>
      return TRUE;
 8249bc4:	00800044 	movi	r2,1
 8249bc8:	00000606 	br	8249be4 <isvfile_locked+0x48>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249bcc:	e0bffe17 	ldw	r2,-8(fp)
 8249bd0:	10800017 	ldw	r2,0(r2)
 8249bd4:	e0bffe15 	stw	r2,-8(fp)
 8249bd8:	e0bffe17 	ldw	r2,-8(fp)
 8249bdc:	103ff61e 	bne	r2,zero,8249bb8 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 8249be0:	0005883a 	mov	r2,zero
}
 8249be4:	e037883a 	mov	sp,fp
 8249be8:	df000017 	ldw	fp,0(sp)
 8249bec:	dec00104 	addi	sp,sp,4
 8249bf0:	f800283a 	ret

08249bf4 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 8249bf4:	defffc04 	addi	sp,sp,-16
 8249bf8:	dfc00315 	stw	ra,12(sp)
 8249bfc:	df000215 	stw	fp,8(sp)
 8249c00:	df000204 	addi	fp,sp,8
 8249c04:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249c08:	01000144 	movi	r4,5
 8249c0c:	822d8f40 	call	822d8f4 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 8249c10:	e13fff17 	ldw	r4,-4(fp)
 8249c14:	8249b9c0 	call	8249b9c <isvfile_locked>
 8249c18:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249c1c:	01000144 	movi	r4,5
 8249c20:	822d9b00 	call	822d9b0 <post_app_sem>
   return rc;
 8249c24:	e0bffe17 	ldw	r2,-8(fp)
}
 8249c28:	e037883a 	mov	sp,fp
 8249c2c:	dfc00117 	ldw	ra,4(sp)
 8249c30:	df000017 	ldw	fp,0(sp)
 8249c34:	dec00204 	addi	sp,sp,8
 8249c38:	f800283a 	ret

08249c3c <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 8249c3c:	defffd04 	addi	sp,sp,-12
 8249c40:	dfc00215 	stw	ra,8(sp)
 8249c44:	df000115 	stw	fp,4(sp)
 8249c48:	df000104 	addi	fp,sp,4
 8249c4c:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249c50:	01000144 	movi	r4,5
 8249c54:	822d8f40 	call	822d8f4 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249c58:	e13fff17 	ldw	r4,-4(fp)
 8249c5c:	8249b9c0 	call	8249b9c <isvfile_locked>
 8249c60:	10000526 	beq	r2,zero,8249c78 <vferror+0x3c>
   {
      vfs_unlock();
 8249c64:	01000144 	movi	r4,5
 8249c68:	822d9b00 	call	822d9b0 <post_app_sem>

      return vfd->error;
 8249c6c:	e0bfff17 	ldw	r2,-4(fp)
 8249c70:	10800417 	ldw	r2,16(r2)
 8249c74:	00000306 	br	8249c84 <vferror+0x48>
   }

   vfs_unlock();
 8249c78:	01000144 	movi	r4,5
 8249c7c:	822d9b00 	call	822d9b0 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 8249c80:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249c84:	e037883a 	mov	sp,fp
 8249c88:	dfc00117 	ldw	ra,4(sp)
 8249c8c:	df000017 	ldw	fp,0(sp)
 8249c90:	dec00204 	addi	sp,sp,8
 8249c94:	f800283a 	ret

08249c98 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 8249c98:	defffd04 	addi	sp,sp,-12
 8249c9c:	dfc00215 	stw	ra,8(sp)
 8249ca0:	df000115 	stw	fp,4(sp)
 8249ca4:	df000104 	addi	fp,sp,4
 8249ca8:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249cac:	01000144 	movi	r4,5
 8249cb0:	822d8f40 	call	822d8f4 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249cb4:	e13fff17 	ldw	r4,-4(fp)
 8249cb8:	8249b9c0 	call	8249b9c <isvfile_locked>
 8249cbc:	10000526 	beq	r2,zero,8249cd4 <vclearerr+0x3c>
   {
      vfs_unlock();
 8249cc0:	01000144 	movi	r4,5
 8249cc4:	822d9b00 	call	822d9b0 <post_app_sem>

      vfd->error = 0;
 8249cc8:	e0bfff17 	ldw	r2,-4(fp)
 8249ccc:	10000415 	stw	zero,16(r2)
      return;
 8249cd0:	00000206 	br	8249cdc <vclearerr+0x44>
   }

   vfs_unlock();
 8249cd4:	01000144 	movi	r4,5
 8249cd8:	822d9b00 	call	822d9b0 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 8249cdc:	e037883a 	mov	sp,fp
 8249ce0:	dfc00117 	ldw	ra,4(sp)
 8249ce4:	df000017 	ldw	fp,0(sp)
 8249ce8:	dec00204 	addi	sp,sp,8
 8249cec:	f800283a 	ret

08249cf0 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 8249cf0:	defffe04 	addi	sp,sp,-8
 8249cf4:	df000115 	stw	fp,4(sp)
 8249cf8:	df000104 	addi	fp,sp,4
int e = 0;
 8249cfc:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 8249d00:	e0bfff17 	ldw	r2,-4(fp)
}
 8249d04:	e037883a 	mov	sp,fp
 8249d08:	df000017 	ldw	fp,0(sp)
 8249d0c:	dec00104 	addi	sp,sp,4
 8249d10:	f800283a 	ret

08249d14 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 8249d14:	defffa04 	addi	sp,sp,-24
 8249d18:	dfc00515 	stw	ra,20(sp)
 8249d1c:	df000415 	stw	fp,16(sp)
 8249d20:	df000404 	addi	fp,sp,16
 8249d24:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 8249d28:	008000c4 	movi	r2,3
 8249d2c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 8249d30:	e0fffd17 	ldw	r3,-12(fp)
 8249d34:	008003f4 	movhi	r2,15
 8249d38:	10909004 	addi	r2,r2,16960
 8249d3c:	1885383a 	mul	r2,r3,r2
 8249d40:	100b883a 	mov	r5,r2
 8249d44:	0100bef4 	movhi	r4,763
 8249d48:	213c2004 	addi	r4,r4,-3968
 8249d4c:	820295c0 	call	820295c <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 8249d50:	100b883a 	mov	r5,r2
 8249d54:	01200034 	movhi	r4,32768
 8249d58:	213fffc4 	addi	r4,r4,-1
 8249d5c:	820295c0 	call	820295c <__udivsi3>
 8249d60:	100b883a 	mov	r5,r2
 8249d64:	e13fff17 	ldw	r4,-4(fp)
 8249d68:	820295c0 	call	820295c <__udivsi3>
 8249d6c:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 8249d70:	e0bffe17 	ldw	r2,-8(fp)
 8249d74:	10002a26 	beq	r2,zero,8249e20 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 8249d78:	e03ffc15 	stw	zero,-16(fp)
 8249d7c:	00001706 	br	8249ddc <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 8249d80:	00a00034 	movhi	r2,32768
 8249d84:	10bfffc4 	addi	r2,r2,-1
 8249d88:	10bfffc4 	addi	r2,r2,-1
 8249d8c:	103ffe1e 	bne	r2,zero,8249d88 <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 8249d90:	e0fffd17 	ldw	r3,-12(fp)
 8249d94:	008003f4 	movhi	r2,15
 8249d98:	10909004 	addi	r2,r2,16960
 8249d9c:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 8249da0:	100b883a 	mov	r5,r2
 8249da4:	0100bef4 	movhi	r4,763
 8249da8:	213c2004 	addi	r4,r4,-3968
 8249dac:	820295c0 	call	820295c <__udivsi3>
 8249db0:	100b883a 	mov	r5,r2
 8249db4:	01200034 	movhi	r4,32768
 8249db8:	213fffc4 	addi	r4,r4,-1
 8249dbc:	820295c0 	call	820295c <__udivsi3>
 8249dc0:	1007883a 	mov	r3,r2
 8249dc4:	e0bfff17 	ldw	r2,-4(fp)
 8249dc8:	10c5c83a 	sub	r2,r2,r3
 8249dcc:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 8249dd0:	e0bffc17 	ldw	r2,-16(fp)
 8249dd4:	10800044 	addi	r2,r2,1
 8249dd8:	e0bffc15 	stw	r2,-16(fp)
 8249ddc:	e0fffc17 	ldw	r3,-16(fp)
 8249de0:	e0bffe17 	ldw	r2,-8(fp)
 8249de4:	18bfe616 	blt	r3,r2,8249d80 <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 8249de8:	e0fffd17 	ldw	r3,-12(fp)
 8249dec:	008003f4 	movhi	r2,15
 8249df0:	10909004 	addi	r2,r2,16960
 8249df4:	1885383a 	mul	r2,r3,r2
 8249df8:	100b883a 	mov	r5,r2
 8249dfc:	0100bef4 	movhi	r4,763
 8249e00:	213c2004 	addi	r4,r4,-3968
 8249e04:	820295c0 	call	820295c <__udivsi3>
 8249e08:	1007883a 	mov	r3,r2
 8249e0c:	e0bfff17 	ldw	r2,-4(fp)
 8249e10:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 8249e14:	10bfffc4 	addi	r2,r2,-1
 8249e18:	103ffe1e 	bne	r2,zero,8249e14 <alt_busy_sleep+0x100>
 8249e1c:	00000d06 	br	8249e54 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 8249e20:	e0fffd17 	ldw	r3,-12(fp)
 8249e24:	008003f4 	movhi	r2,15
 8249e28:	10909004 	addi	r2,r2,16960
 8249e2c:	1885383a 	mul	r2,r3,r2
 8249e30:	100b883a 	mov	r5,r2
 8249e34:	0100bef4 	movhi	r4,763
 8249e38:	213c2004 	addi	r4,r4,-3968
 8249e3c:	820295c0 	call	820295c <__udivsi3>
 8249e40:	1007883a 	mov	r3,r2
 8249e44:	e0bfff17 	ldw	r2,-4(fp)
 8249e48:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 8249e4c:	10bfffc4 	addi	r2,r2,-1
 8249e50:	00bffe16 	blt	zero,r2,8249e4c <alt_busy_sleep+0x138>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 8249e54:	0005883a 	mov	r2,zero
}
 8249e58:	e037883a 	mov	sp,fp
 8249e5c:	dfc00117 	ldw	ra,4(sp)
 8249e60:	df000017 	ldw	fp,0(sp)
 8249e64:	dec00204 	addi	sp,sp,8
 8249e68:	f800283a 	ret

08249e6c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8249e6c:	defffe04 	addi	sp,sp,-8
 8249e70:	dfc00115 	stw	ra,4(sp)
 8249e74:	df000015 	stw	fp,0(sp)
 8249e78:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8249e7c:	d0a04717 	ldw	r2,-32484(gp)
 8249e80:	10000326 	beq	r2,zero,8249e90 <alt_get_errno+0x24>
 8249e84:	d0a04717 	ldw	r2,-32484(gp)
 8249e88:	103ee83a 	callr	r2
 8249e8c:	00000106 	br	8249e94 <alt_get_errno+0x28>
 8249e90:	d0a06304 	addi	r2,gp,-32372
}
 8249e94:	e037883a 	mov	sp,fp
 8249e98:	dfc00117 	ldw	ra,4(sp)
 8249e9c:	df000017 	ldw	fp,0(sp)
 8249ea0:	dec00204 	addi	sp,sp,8
 8249ea4:	f800283a 	ret

08249ea8 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 8249ea8:	defff704 	addi	sp,sp,-36
 8249eac:	dfc00615 	stw	ra,24(sp)
 8249eb0:	df000515 	stw	fp,20(sp)
 8249eb4:	df000504 	addi	fp,sp,20
 8249eb8:	e13ffe15 	stw	r4,-8(fp)
 8249ebc:	e17fff15 	stw	r5,-4(fp)
 8249ec0:	e1800215 	stw	r6,8(fp)
 8249ec4:	e1c00315 	stw	r7,12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8249ec8:	e0bffe17 	ldw	r2,-8(fp)
 8249ecc:	10000616 	blt	r2,zero,8249ee8 <alt_fcntl+0x40>
 8249ed0:	e0bffe17 	ldw	r2,-8(fp)
 8249ed4:	10c00324 	muli	r3,r2,12
 8249ed8:	00820974 	movhi	r2,2085
 8249edc:	108df204 	addi	r2,r2,14280
 8249ee0:	1885883a 	add	r2,r3,r2
 8249ee4:	00000106 	br	8249eec <alt_fcntl+0x44>
 8249ee8:	0005883a 	mov	r2,zero
 8249eec:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 8249ef0:	e0bffb17 	ldw	r2,-20(fp)
 8249ef4:	10002a26 	beq	r2,zero,8249fa0 <alt_fcntl+0xf8>
  {
    switch (cmd)
 8249ef8:	e0bfff17 	ldw	r2,-4(fp)
 8249efc:	10c000e0 	cmpeqi	r3,r2,3
 8249f00:	1800031e 	bne	r3,zero,8249f10 <alt_fcntl+0x68>
 8249f04:	10800120 	cmpeqi	r2,r2,4
 8249f08:	1000071e 	bne	r2,zero,8249f28 <alt_fcntl+0x80>
 8249f0c:	00001e06 	br	8249f88 <alt_fcntl+0xe0>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 8249f10:	e0bffb17 	ldw	r2,-20(fp)
 8249f14:	10c00217 	ldw	r3,8(r2)
 8249f18:	00900034 	movhi	r2,16384
 8249f1c:	10bfffc4 	addi	r2,r2,-1
 8249f20:	1884703a 	and	r2,r3,r2
 8249f24:	00002306 	br	8249fb4 <alt_fcntl+0x10c>
    case F_SETFL:
      va_start(argp, cmd);
 8249f28:	e0800204 	addi	r2,fp,8
 8249f2c:	e0bffd15 	stw	r2,-12(fp)
      flags = va_arg(argp, long);
 8249f30:	e0bffd17 	ldw	r2,-12(fp)
 8249f34:	10c00104 	addi	r3,r2,4
 8249f38:	e0fffd15 	stw	r3,-12(fp)
 8249f3c:	10800017 	ldw	r2,0(r2)
 8249f40:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 8249f44:	e0bffb17 	ldw	r2,-20(fp)
 8249f48:	10c00217 	ldw	r3,8(r2)
 8249f4c:	00affdc4 	movi	r2,-16393
 8249f50:	1886703a 	and	r3,r3,r2
 8249f54:	e0bffb17 	ldw	r2,-20(fp)
 8249f58:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 8249f5c:	e0bffb17 	ldw	r2,-20(fp)
 8249f60:	10800217 	ldw	r2,8(r2)
 8249f64:	1007883a 	mov	r3,r2
 8249f68:	e0bffc17 	ldw	r2,-16(fp)
 8249f6c:	1090020c 	andi	r2,r2,16392
 8249f70:	1884b03a 	or	r2,r3,r2
 8249f74:	1007883a 	mov	r3,r2
 8249f78:	e0bffb17 	ldw	r2,-20(fp)
 8249f7c:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 8249f80:	0005883a 	mov	r2,zero
 8249f84:	00000b06 	br	8249fb4 <alt_fcntl+0x10c>
    default:
      ALT_ERRNO = EINVAL;
 8249f88:	8249e6c0 	call	8249e6c <alt_get_errno>
 8249f8c:	1007883a 	mov	r3,r2
 8249f90:	00800584 	movi	r2,22
 8249f94:	18800015 	stw	r2,0(r3)
      return -1;
 8249f98:	00bfffc4 	movi	r2,-1
 8249f9c:	00000506 	br	8249fb4 <alt_fcntl+0x10c>
    }
  }

  ALT_ERRNO = EBADFD;
 8249fa0:	8249e6c0 	call	8249e6c <alt_get_errno>
 8249fa4:	1007883a 	mov	r3,r2
 8249fa8:	00801444 	movi	r2,81
 8249fac:	18800015 	stw	r2,0(r3)
  return -1;
 8249fb0:	00bfffc4 	movi	r2,-1
}
 8249fb4:	e037883a 	mov	sp,fp
 8249fb8:	dfc00117 	ldw	ra,4(sp)
 8249fbc:	df000017 	ldw	fp,0(sp)
 8249fc0:	dec00404 	addi	sp,sp,16
 8249fc4:	f800283a 	ret

08249fc8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 8249fc8:	defffb04 	addi	sp,sp,-20
 8249fcc:	dfc00415 	stw	ra,16(sp)
 8249fd0:	df000315 	stw	fp,12(sp)
 8249fd4:	df000304 	addi	fp,sp,12
 8249fd8:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 8249fdc:	d0a04217 	ldw	r2,-32504(gp)
 8249fe0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 8249fe4:	00003106 	br	824a0ac <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 8249fe8:	e0bffd17 	ldw	r2,-12(fp)
 8249fec:	10800217 	ldw	r2,8(r2)
 8249ff0:	1009883a 	mov	r4,r2
 8249ff4:	8203cac0 	call	8203cac <strlen>
 8249ff8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 8249ffc:	e0bffd17 	ldw	r2,-12(fp)
 824a000:	10c00217 	ldw	r3,8(r2)
 824a004:	e0bffe17 	ldw	r2,-8(fp)
 824a008:	10bfffc4 	addi	r2,r2,-1
 824a00c:	1885883a 	add	r2,r3,r2
 824a010:	10800003 	ldbu	r2,0(r2)
 824a014:	10803fcc 	andi	r2,r2,255
 824a018:	1080201c 	xori	r2,r2,128
 824a01c:	10bfe004 	addi	r2,r2,-128
 824a020:	10800bd8 	cmpnei	r2,r2,47
 824a024:	1000031e 	bne	r2,zero,824a034 <alt_find_file+0x6c>
    {
      len -= 1;
 824a028:	e0bffe17 	ldw	r2,-8(fp)
 824a02c:	10bfffc4 	addi	r2,r2,-1
 824a030:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a034:	e0bffe17 	ldw	r2,-8(fp)
 824a038:	e0ffff17 	ldw	r3,-4(fp)
 824a03c:	1885883a 	add	r2,r3,r2
 824a040:	10800003 	ldbu	r2,0(r2)
 824a044:	10803fcc 	andi	r2,r2,255
 824a048:	1080201c 	xori	r2,r2,128
 824a04c:	10bfe004 	addi	r2,r2,-128
 824a050:	10800be0 	cmpeqi	r2,r2,47
 824a054:	1000081e 	bne	r2,zero,824a078 <alt_find_file+0xb0>
 824a058:	e0bffe17 	ldw	r2,-8(fp)
 824a05c:	e0ffff17 	ldw	r3,-4(fp)
 824a060:	1885883a 	add	r2,r3,r2
 824a064:	10800003 	ldbu	r2,0(r2)
 824a068:	10803fcc 	andi	r2,r2,255
 824a06c:	1080201c 	xori	r2,r2,128
 824a070:	10bfe004 	addi	r2,r2,-128
 824a074:	10000a1e 	bne	r2,zero,824a0a0 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 824a078:	e0bffd17 	ldw	r2,-12(fp)
 824a07c:	10800217 	ldw	r2,8(r2)
 824a080:	e0fffe17 	ldw	r3,-8(fp)
 824a084:	180d883a 	mov	r6,r3
 824a088:	e17fff17 	ldw	r5,-4(fp)
 824a08c:	1009883a 	mov	r4,r2
 824a090:	820c3280 	call	820c328 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a094:	1000021e 	bne	r2,zero,824a0a0 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 824a098:	e0bffd17 	ldw	r2,-12(fp)
 824a09c:	00000706 	br	824a0bc <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 824a0a0:	e0bffd17 	ldw	r2,-12(fp)
 824a0a4:	10800017 	ldw	r2,0(r2)
 824a0a8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a0ac:	e0fffd17 	ldw	r3,-12(fp)
 824a0b0:	d0a04204 	addi	r2,gp,-32504
 824a0b4:	18bfcc1e 	bne	r3,r2,8249fe8 <alt_find_file+0x20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 824a0b8:	0005883a 	mov	r2,zero
}
 824a0bc:	e037883a 	mov	sp,fp
 824a0c0:	dfc00117 	ldw	ra,4(sp)
 824a0c4:	df000017 	ldw	fp,0(sp)
 824a0c8:	dec00204 	addi	sp,sp,8
 824a0cc:	f800283a 	ret

0824a0d0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 824a0d0:	defff904 	addi	sp,sp,-28
 824a0d4:	dfc00615 	stw	ra,24(sp)
 824a0d8:	df000515 	stw	fp,20(sp)
 824a0dc:	df000504 	addi	fp,sp,20
 824a0e0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 824a0e4:	00bffa04 	movi	r2,-24
 824a0e8:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 824a0ec:	d0a0b617 	ldw	r2,-32040(gp)
 824a0f0:	e0bffd15 	stw	r2,-12(fp)
 824a0f4:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 824a0f8:	e0bffe0b 	ldhu	r2,-8(fp)
 824a0fc:	e0fffe84 	addi	r3,fp,-6
 824a100:	180d883a 	mov	r6,r3
 824a104:	100b883a 	mov	r5,r2
 824a108:	e13ffd17 	ldw	r4,-12(fp)
 824a10c:	8219e200 	call	8219e20 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a110:	e03ffb15 	stw	zero,-20(fp)
 824a114:	00001906 	br	824a17c <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
 824a118:	00820974 	movhi	r2,2085
 824a11c:	108df204 	addi	r2,r2,14280
 824a120:	e0fffb17 	ldw	r3,-20(fp)
 824a124:	18c00324 	muli	r3,r3,12
 824a128:	10c5883a 	add	r2,r2,r3
 824a12c:	10800017 	ldw	r2,0(r2)
 824a130:	10000f1e 	bne	r2,zero,824a170 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
 824a134:	00820974 	movhi	r2,2085
 824a138:	108df204 	addi	r2,r2,14280
 824a13c:	e0fffb17 	ldw	r3,-20(fp)
 824a140:	18c00324 	muli	r3,r3,12
 824a144:	10c5883a 	add	r2,r2,r3
 824a148:	e0ffff17 	ldw	r3,-4(fp)
 824a14c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 824a150:	d0e04617 	ldw	r3,-32488(gp)
 824a154:	e0bffb17 	ldw	r2,-20(fp)
 824a158:	1880020e 	bge	r3,r2,824a164 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
 824a15c:	e0bffb17 	ldw	r2,-20(fp)
 824a160:	d0a04615 	stw	r2,-32488(gp)
      }
      rc = i;
 824a164:	e0bffb17 	ldw	r2,-20(fp)
 824a168:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 824a16c:	00000606 	br	824a188 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a170:	e0bffb17 	ldw	r2,-20(fp)
 824a174:	10800044 	addi	r2,r2,1
 824a178:	e0bffb15 	stw	r2,-20(fp)
 824a17c:	e0bffb17 	ldw	r2,-20(fp)
 824a180:	10800810 	cmplti	r2,r2,32
 824a184:	103fe41e 	bne	r2,zero,824a118 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 824a188:	d0a0b617 	ldw	r2,-32040(gp)
 824a18c:	1009883a 	mov	r4,r2
 824a190:	821a1980 	call	821a198 <OSSemPost>

  return rc;
 824a194:	e0bffc17 	ldw	r2,-16(fp)
}
 824a198:	e037883a 	mov	sp,fp
 824a19c:	dfc00117 	ldw	ra,4(sp)
 824a1a0:	df000017 	ldw	fp,0(sp)
 824a1a4:	dec00204 	addi	sp,sp,8
 824a1a8:	f800283a 	ret

0824a1ac <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 824a1ac:	deffef04 	addi	sp,sp,-68
 824a1b0:	dfc01015 	stw	ra,64(sp)
 824a1b4:	df000f15 	stw	fp,60(sp)
 824a1b8:	dc400e15 	stw	r17,56(sp)
 824a1bc:	dc000d15 	stw	r16,52(sp)
 824a1c0:	df000f04 	addi	fp,sp,60
 824a1c4:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 824a1c8:	e03ff305 	stb	zero,-52(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 824a1cc:	008209b4 	movhi	r2,2086
 824a1d0:	10b99e04 	addi	r2,r2,-6536
 824a1d4:	10800017 	ldw	r2,0(r2)
 824a1d8:	10c00044 	addi	r3,r2,1
 824a1dc:	008209b4 	movhi	r2,2086
 824a1e0:	10b99e04 	addi	r2,r2,-6536
 824a1e4:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 824a1e8:	e0bffd17 	ldw	r2,-12(fp)
 824a1ec:	10800317 	ldw	r2,12(r2)
 824a1f0:	e0bff415 	stw	r2,-48(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 824a1f4:	e0bffd17 	ldw	r2,-12(fp)
 824a1f8:	10c00417 	ldw	r3,16(r2)
 824a1fc:	e0bff417 	ldw	r2,-48(fp)
 824a200:	10800003 	ldbu	r2,0(r2)
 824a204:	10803fcc 	andi	r2,r2,255
 824a208:	108003cc 	andi	r2,r2,15
 824a20c:	1085883a 	add	r2,r2,r2
 824a210:	1085883a 	add	r2,r2,r2
 824a214:	1885c83a 	sub	r2,r3,r2
 824a218:	e0bff515 	stw	r2,-44(fp)
   host = p->fhost;                       /* filled in by IP layer */
 824a21c:	e0bffd17 	ldw	r2,-12(fp)
 824a220:	10800717 	ldw	r2,28(r2)
 824a224:	e0bff615 	stw	r2,-40(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a228:	d0a08317 	ldw	r2,-32244(gp)
 824a22c:	1081000c 	andi	r2,r2,1024
 824a230:	10001526 	beq	r2,zero,824a288 <icmprcv+0xdc>
 824a234:	d0a08317 	ldw	r2,-32244(gp)
 824a238:	1080800c 	andi	r2,r2,512
 824a23c:	10001226 	beq	r2,zero,824a288 <icmprcv+0xdc>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 824a240:	e0bff617 	ldw	r2,-40(fp)
 824a244:	11003fcc 	andi	r4,r2,255
 824a248:	e0bff617 	ldw	r2,-40(fp)
 824a24c:	1004d23a 	srli	r2,r2,8
 824a250:	11403fcc 	andi	r5,r2,255
 824a254:	e0bff617 	ldw	r2,-40(fp)
 824a258:	1004d43a 	srli	r2,r2,16
 824a25c:	10803fcc 	andi	r2,r2,255
 824a260:	e0fff617 	ldw	r3,-40(fp)
 824a264:	1806d63a 	srli	r3,r3,24
 824a268:	d8c00115 	stw	r3,4(sp)
 824a26c:	d8800015 	stw	r2,0(sp)
 824a270:	280f883a 	mov	r7,r5
 824a274:	200d883a 	mov	r6,r4
 824a278:	e17ff517 	ldw	r5,-44(fp)
 824a27c:	01020974 	movhi	r4,2085
 824a280:	21060b04 	addi	r4,r4,6188
 824a284:	82030ec0 	call	82030ec <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 824a288:	e0bff417 	ldw	r2,-48(fp)
 824a28c:	10800003 	ldbu	r2,0(r2)
 824a290:	10803fcc 	andi	r2,r2,255
 824a294:	108003cc 	andi	r2,r2,15
 824a298:	1085883a 	add	r2,r2,r2
 824a29c:	1085883a 	add	r2,r2,r2
 824a2a0:	1007883a 	mov	r3,r2
 824a2a4:	e0bff417 	ldw	r2,-48(fp)
 824a2a8:	10c5883a 	add	r2,r2,r3
 824a2ac:	e0bff715 	stw	r2,-36(fp)

   osum = e->pchksum;
 824a2b0:	e0bff717 	ldw	r2,-36(fp)
 824a2b4:	1080008b 	ldhu	r2,2(r2)
 824a2b8:	e0bff80d 	sth	r2,-32(fp)
   e->pchksum = 0;
 824a2bc:	e0bff717 	ldw	r2,-36(fp)
 824a2c0:	1000008d 	sth	zero,2(r2)

   if (len&1)
 824a2c4:	e0bff517 	ldw	r2,-44(fp)
 824a2c8:	1080004c 	andi	r2,r2,1
 824a2cc:	10000926 	beq	r2,zero,824a2f4 <icmprcv+0x148>
   {
      sav_ch = *(((char *) e) + len);
 824a2d0:	e0fff717 	ldw	r3,-36(fp)
 824a2d4:	e0bff517 	ldw	r2,-44(fp)
 824a2d8:	1885883a 	add	r2,r3,r2
 824a2dc:	10800003 	ldbu	r2,0(r2)
 824a2e0:	e0bff305 	stb	r2,-52(fp)
      ((char *)e)[len] = 0;
 824a2e4:	e0fff717 	ldw	r3,-36(fp)
 824a2e8:	e0bff517 	ldw	r2,-44(fp)
 824a2ec:	1885883a 	add	r2,r3,r2
 824a2f0:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 824a2f4:	e0bff517 	ldw	r2,-44(fp)
 824a2f8:	10800044 	addi	r2,r2,1
 824a2fc:	1004d07a 	srli	r2,r2,1
 824a300:	100b883a 	mov	r5,r2
 824a304:	e13ff717 	ldw	r4,-36(fp)
 824a308:	82285000 	call	8228500 <cksum>
 824a30c:	0084303a 	nor	r2,zero,r2
 824a310:	e0bff88d 	sth	r2,-30(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 824a314:	e0bff517 	ldw	r2,-44(fp)
 824a318:	1080004c 	andi	r2,r2,1
 824a31c:	10000526 	beq	r2,zero,824a334 <icmprcv+0x188>
 824a320:	e0fff717 	ldw	r3,-36(fp)
 824a324:	e0bff517 	ldw	r2,-44(fp)
 824a328:	1885883a 	add	r2,r3,r2
 824a32c:	e0fff303 	ldbu	r3,-52(fp)
 824a330:	10c00005 	stb	r3,0(r2)
   if (xsum != osum)
 824a334:	e0fff88b 	ldhu	r3,-30(fp)
 824a338:	e0bff80b 	ldhu	r2,-32(fp)
 824a33c:	18802426 	beq	r3,r2,824a3d0 <icmprcv+0x224>
   {
      e->pchksum = osum;
 824a340:	e0bff717 	ldw	r2,-36(fp)
 824a344:	e0fff80b 	ldhu	r3,-32(fp)
 824a348:	10c0008d 	sth	r3,2(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a34c:	d0a08317 	ldw	r2,-32244(gp)
 824a350:	1081000c 	andi	r2,r2,1024
 824a354:	10000f26 	beq	r2,zero,824a394 <icmprcv+0x1e8>
 824a358:	d0a08317 	ldw	r2,-32244(gp)
 824a35c:	1080800c 	andi	r2,r2,512
 824a360:	10000c26 	beq	r2,zero,824a394 <icmprcv+0x1e8>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 824a364:	e0bff80b 	ldhu	r2,-32(fp)
 824a368:	e0fff88b 	ldhu	r3,-30(fp)
 824a36c:	180d883a 	mov	r6,r3
 824a370:	100b883a 	mov	r5,r2
 824a374:	01020974 	movhi	r4,2085
 824a378:	21061304 	addi	r4,r4,6220
 824a37c:	82030ec0 	call	82030ec <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 824a380:	d0a08317 	ldw	r2,-32244(gp)
 824a384:	1080008c 	andi	r2,r2,2
 824a388:	10000226 	beq	r2,zero,824a394 <icmprcv+0x1e8>
 824a38c:	e13ffd17 	ldw	r4,-12(fp)
 824a390:	824078c0 	call	824078c <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 824a394:	008209b4 	movhi	r2,2086
 824a398:	10b99e04 	addi	r2,r2,-6536
 824a39c:	10800117 	ldw	r2,4(r2)
 824a3a0:	10c00044 	addi	r3,r2,1
 824a3a4:	008209b4 	movhi	r2,2086
 824a3a8:	10b99e04 	addi	r2,r2,-6536
 824a3ac:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a3b0:	01000084 	movi	r4,2
 824a3b4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824a3b8:	e13ffd17 	ldw	r4,-12(fp)
 824a3bc:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a3c0:	01000084 	movi	r4,2
 824a3c4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 824a3c8:	00bff804 	movi	r2,-32
 824a3cc:	00024906 	br	824acf4 <icmprcv+0xb48>
   }

   e->pchksum = osum;
 824a3d0:	e0bff717 	ldw	r2,-36(fp)
 824a3d4:	e0fff80b 	ldhu	r3,-32(fp)
 824a3d8:	10c0008d 	sth	r3,2(r2)

   switch (e->ptype) 
 824a3dc:	e0bff717 	ldw	r2,-36(fp)
 824a3e0:	10800003 	ldbu	r2,0(r2)
 824a3e4:	10803fcc 	andi	r2,r2,255
 824a3e8:	1080201c 	xori	r2,r2,128
 824a3ec:	10bfe004 	addi	r2,r2,-128
 824a3f0:	10c00428 	cmpgeui	r3,r2,16
 824a3f4:	1802251e 	bne	r3,zero,824ac8c <icmprcv+0xae0>
 824a3f8:	100690ba 	slli	r3,r2,2
 824a3fc:	00820974 	movhi	r2,2085
 824a400:	10a90404 	addi	r2,r2,-23536
 824a404:	1885883a 	add	r2,r3,r2
 824a408:	10800017 	ldw	r2,0(r2)
 824a40c:	1000683a 	jmp	r2
 824a410:	0824a6c4 	addi	zero,at,-28005
 824a414:	0824ac8c 	andi	zero,at,37554
 824a418:	0824ac8c 	andi	zero,at,37554
 824a41c:	0824a6ec 	andhi	zero,at,37531
 824a420:	0824a7e8 	cmpgeui	zero,at,37535
 824a424:	0824a884 	addi	zero,at,-27998
 824a428:	0824ac8c 	andi	zero,at,37554
 824a42c:	0824ac8c 	andi	zero,at,37554
 824a430:	0824a450 	cmplti	zero,at,-28015
 824a434:	0824ac8c 	andi	zero,at,37554
 824a438:	0824ac8c 	andi	zero,at,37554
 824a43c:	0824a9b8 	rdprs	zero,at,-27994
 824a440:	0824aac0 	call	824aac <OSCtxSw_SWITCH_PC+0x824a6c>
 824a444:	0824ab24 	muli	zero,at,-27988
 824a448:	0824ac8c 	andi	zero,at,37554
 824a44c:	0824ac58 	cmpnei	zero,at,-27983
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 824a450:	008209b4 	movhi	r2,2086
 824a454:	10b99e04 	addi	r2,r2,-6536
 824a458:	10800717 	ldw	r2,28(r2)
 824a45c:	10c00044 	addi	r3,r2,1
 824a460:	008209b4 	movhi	r2,2086
 824a464:	10b99e04 	addi	r2,r2,-6536
 824a468:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a46c:	d0a08317 	ldw	r2,-32244(gp)
 824a470:	1081000c 	andi	r2,r2,1024
 824a474:	10001426 	beq	r2,zero,824a4c8 <icmprcv+0x31c>
 824a478:	d0a08317 	ldw	r2,-32244(gp)
 824a47c:	1080800c 	andi	r2,r2,512
 824a480:	10001126 	beq	r2,zero,824a4c8 <icmprcv+0x31c>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a484:	e0bff617 	ldw	r2,-40(fp)
 824a488:	10c03fcc 	andi	r3,r2,255
 824a48c:	e0bff617 	ldw	r2,-40(fp)
 824a490:	1004d23a 	srli	r2,r2,8
 824a494:	11003fcc 	andi	r4,r2,255
 824a498:	e0bff617 	ldw	r2,-40(fp)
 824a49c:	1004d43a 	srli	r2,r2,16
 824a4a0:	11403fcc 	andi	r5,r2,255
 824a4a4:	e0bff617 	ldw	r2,-40(fp)
 824a4a8:	1004d63a 	srli	r2,r2,24
 824a4ac:	d8800015 	stw	r2,0(sp)
 824a4b0:	280f883a 	mov	r7,r5
 824a4b4:	200d883a 	mov	r6,r4
 824a4b8:	180b883a 	mov	r5,r3
 824a4bc:	01020974 	movhi	r4,2085
 824a4c0:	21061e04 	addi	r4,r4,6264
 824a4c4:	82030ec0 	call	82030ec <printf>
#endif
      e->ptype = ECHOREP;
 824a4c8:	e0bff717 	ldw	r2,-36(fp)
 824a4cc:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 824a4d0:	e0bff717 	ldw	r2,-36(fp)
 824a4d4:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 824a4d8:	e0bff517 	ldw	r2,-44(fp)
 824a4dc:	1080004c 	andi	r2,r2,1
 824a4e0:	10000926 	beq	r2,zero,824a508 <icmprcv+0x35c>
      {
         sav_ch = *(((char *) e) + len);
 824a4e4:	e0fff717 	ldw	r3,-36(fp)
 824a4e8:	e0bff517 	ldw	r2,-44(fp)
 824a4ec:	1885883a 	add	r2,r3,r2
 824a4f0:	10800003 	ldbu	r2,0(r2)
 824a4f4:	e0bff305 	stb	r2,-52(fp)
         ((char *)e)[len] = 0;
 824a4f8:	e0fff717 	ldw	r3,-36(fp)
 824a4fc:	e0bff517 	ldw	r2,-44(fp)
 824a500:	1885883a 	add	r2,r3,r2
 824a504:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 824a508:	e0bff517 	ldw	r2,-44(fp)
 824a50c:	10800044 	addi	r2,r2,1
 824a510:	1004d07a 	srli	r2,r2,1
 824a514:	100b883a 	mov	r5,r2
 824a518:	e13ff717 	ldw	r4,-36(fp)
 824a51c:	82285000 	call	8228500 <cksum>
 824a520:	0084303a 	nor	r2,zero,r2
 824a524:	1007883a 	mov	r3,r2
 824a528:	e0bff717 	ldw	r2,-36(fp)
 824a52c:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 824a530:	e0bff517 	ldw	r2,-44(fp)
 824a534:	1080004c 	andi	r2,r2,1
 824a538:	10000526 	beq	r2,zero,824a550 <icmprcv+0x3a4>
 824a53c:	e0fff717 	ldw	r3,-36(fp)
 824a540:	e0bff517 	ldw	r2,-44(fp)
 824a544:	1885883a 	add	r2,r3,r2
 824a548:	e0fff303 	ldbu	r3,-52(fp)
 824a54c:	10c00005 	stb	r3,0(r2)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a550:	e0bff417 	ldw	r2,-48(fp)
 824a554:	10800417 	ldw	r2,16(r2)
 824a558:	10bfffe0 	cmpeqi	r2,r2,-1
 824a55c:	10001f1e 	bne	r2,zero,824a5dc <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a560:	e0bff417 	ldw	r2,-48(fp)
 824a564:	10800417 	ldw	r2,16(r2)
 824a568:	1006d63a 	srli	r3,r2,24
 824a56c:	e0bff417 	ldw	r2,-48(fp)
 824a570:	10800417 	ldw	r2,16(r2)
 824a574:	1004d23a 	srli	r2,r2,8
 824a578:	10bfc00c 	andi	r2,r2,65280
 824a57c:	1886b03a 	or	r3,r3,r2
 824a580:	e0bff417 	ldw	r2,-48(fp)
 824a584:	10800417 	ldw	r2,16(r2)
 824a588:	10bfc00c 	andi	r2,r2,65280
 824a58c:	1004923a 	slli	r2,r2,8
 824a590:	1886b03a 	or	r3,r3,r2
 824a594:	e0bff417 	ldw	r2,-48(fp)
 824a598:	10800417 	ldw	r2,16(r2)
 824a59c:	1004963a 	slli	r2,r2,24
 824a5a0:	1884b03a 	or	r2,r3,r2
 824a5a4:	10fc002c 	andhi	r3,r2,61440
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a5a8:	00b80034 	movhi	r2,57344
 824a5ac:	18800b26 	beq	r3,r2,824a5dc <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
 824a5b0:	e0bff417 	ldw	r2,-48(fp)
 824a5b4:	10c00417 	ldw	r3,16(r2)
 824a5b8:	e0bffd17 	ldw	r2,-12(fp)
 824a5bc:	10800617 	ldw	r2,24(r2)
 824a5c0:	11000a17 	ldw	r4,40(r2)
 824a5c4:	e0bffd17 	ldw	r2,-12(fp)
 824a5c8:	10800617 	ldw	r2,24(r2)
 824a5cc:	10800c17 	ldw	r2,48(r2)
 824a5d0:	0084303a 	nor	r2,zero,r2
 824a5d4:	2084b03a 	or	r2,r4,r2
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a5d8:	1880061e 	bne	r3,r2,824a5f4 <icmprcv+0x448>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 824a5dc:	e0bffd17 	ldw	r2,-12(fp)
 824a5e0:	10800617 	ldw	r2,24(r2)
 824a5e4:	10c00a17 	ldw	r3,40(r2)
 824a5e8:	e0bff417 	ldw	r2,-48(fp)
 824a5ec:	10c00315 	stw	r3,12(r2)
 824a5f0:	00000406 	br	824a604 <icmprcv+0x458>
      }
      else pip->ip_src = pip->ip_dest;
 824a5f4:	e0bff417 	ldw	r2,-48(fp)
 824a5f8:	10c00417 	ldw	r3,16(r2)
 824a5fc:	e0bff417 	ldw	r2,-48(fp)
 824a600:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 824a604:	e0bff417 	ldw	r2,-48(fp)
 824a608:	e0fff617 	ldw	r3,-40(fp)
 824a60c:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutEchoReps++;
 824a610:	008209b4 	movhi	r2,2086
 824a614:	10b99e04 	addi	r2,r2,-6536
 824a618:	10801517 	ldw	r2,84(r2)
 824a61c:	10c00044 	addi	r3,r2,1
 824a620:	008209b4 	movhi	r2,2086
 824a624:	10b99e04 	addi	r2,r2,-6536
 824a628:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 824a62c:	008209b4 	movhi	r2,2086
 824a630:	10b99e04 	addi	r2,r2,-6536
 824a634:	10800d17 	ldw	r2,52(r2)
 824a638:	10c00044 	addi	r3,r2,1
 824a63c:	008209b4 	movhi	r2,2086
 824a640:	10b99e04 	addi	r2,r2,-6536
 824a644:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 824a648:	e0bffd17 	ldw	r2,-12(fp)
 824a64c:	e0fff617 	ldw	r3,-40(fp)
 824a650:	10c00715 	stw	r3,28(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824a654:	e0bffd17 	ldw	r2,-12(fp)
 824a658:	10c00317 	ldw	r3,12(r2)
 824a65c:	e0bff417 	ldw	r2,-48(fp)
 824a660:	10800003 	ldbu	r2,0(r2)
 824a664:	10803fcc 	andi	r2,r2,255
 824a668:	108003cc 	andi	r2,r2,15
 824a66c:	1085883a 	add	r2,r2,r2
 824a670:	1085883a 	add	r2,r2,r2
 824a674:	1887883a 	add	r3,r3,r2
 824a678:	e0bffd17 	ldw	r2,-12(fp)
 824a67c:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 824a680:	e0bffd17 	ldw	r2,-12(fp)
 824a684:	e0fff517 	ldw	r3,-44(fp)
 824a688:	10c00415 	stw	r3,16(r2)

      i = ip_write(ICMP_PROT, p);
 824a68c:	e17ffd17 	ldw	r5,-12(fp)
 824a690:	01000044 	movi	r4,1
 824a694:	823f6980 	call	823f698 <ip_write>
 824a698:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824a69c:	e0bff917 	ldw	r2,-28(fp)
 824a6a0:	1000060e 	bge	r2,zero,824a6bc <icmprcv+0x510>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 824a6a4:	d0a08317 	ldw	r2,-32244(gp)
 824a6a8:	1081000c 	andi	r2,r2,1024
 824a6ac:	10000326 	beq	r2,zero,824a6bc <icmprcv+0x510>
            dprintf("icmp: reply failed\n");
 824a6b0:	01020974 	movhi	r4,2085
 824a6b4:	21062704 	addi	r4,r4,6300
 824a6b8:	82033700 	call	8203370 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 824a6bc:	0005883a 	mov	r2,zero
 824a6c0:	00018c06 	br	824acf4 <icmprcv+0xb48>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 824a6c4:	008209b4 	movhi	r2,2086
 824a6c8:	10b99e04 	addi	r2,r2,-6536
 824a6cc:	10800817 	ldw	r2,32(r2)
 824a6d0:	10c00044 	addi	r3,r2,1
 824a6d4:	008209b4 	movhi	r2,2086
 824a6d8:	10b99e04 	addi	r2,r2,-6536
 824a6dc:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 824a6e0:	e13ffd17 	ldw	r4,-12(fp)
 824a6e4:	8243bc00 	call	8243bc0 <ip_raw_input>
 824a6e8:	00018206 	br	824acf4 <icmprcv+0xb48>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 824a6ec:	008209b4 	movhi	r2,2086
 824a6f0:	10b99e04 	addi	r2,r2,-6536
 824a6f4:	10800217 	ldw	r2,8(r2)
 824a6f8:	10c00044 	addi	r3,r2,1
 824a6fc:	008209b4 	movhi	r2,2086
 824a700:	10b99e04 	addi	r2,r2,-6536
 824a704:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 824a708:	e0bff717 	ldw	r2,-36(fp)
 824a70c:	e0bffa15 	stw	r2,-24(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a710:	d0a08317 	ldw	r2,-32244(gp)
 824a714:	1081000c 	andi	r2,r2,1024
 824a718:	10002f26 	beq	r2,zero,824a7d8 <icmprcv+0x62c>
      {
         dprintf("ICMP: got dest unreachable type ");
 824a71c:	01020974 	movhi	r4,2085
 824a720:	21062c04 	addi	r4,r4,6320
 824a724:	82030ec0 	call	82030ec <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a728:	e0bffa17 	ldw	r2,-24(fp)
 824a72c:	10800043 	ldbu	r2,1(r2)
 824a730:	11003fcc 	andi	r4,r2,255
 824a734:	2100201c 	xori	r4,r4,128
 824a738:	213fe004 	addi	r4,r4,-128
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a73c:	e0bffa17 	ldw	r2,-24(fp)
 824a740:	10800617 	ldw	r2,24(r2)
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a744:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a748:	e0bffa17 	ldw	r2,-24(fp)
 824a74c:	10800617 	ldw	r2,24(r2)
 824a750:	1004d23a 	srli	r2,r2,8
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a754:	11803fcc 	andi	r6,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a758:	e0bffa17 	ldw	r2,-24(fp)
 824a75c:	10800617 	ldw	r2,24(r2)
 824a760:	1004d43a 	srli	r2,r2,16
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a764:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a768:	e0fffa17 	ldw	r3,-24(fp)
 824a76c:	18c00617 	ldw	r3,24(r3)
 824a770:	1806d63a 	srli	r3,r3,24
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a774:	d8c00115 	stw	r3,4(sp)
 824a778:	d8800015 	stw	r2,0(sp)
 824a77c:	300f883a 	mov	r7,r6
 824a780:	280d883a 	mov	r6,r5
 824a784:	200b883a 	mov	r5,r4
 824a788:	01020974 	movhi	r4,2085
 824a78c:	21063504 	addi	r4,r4,6356
 824a790:	82030ec0 	call	82030ec <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a794:	e0bff617 	ldw	r2,-40(fp)
 824a798:	10c03fcc 	andi	r3,r2,255
 824a79c:	e0bff617 	ldw	r2,-40(fp)
 824a7a0:	1004d23a 	srli	r2,r2,8
 824a7a4:	11003fcc 	andi	r4,r2,255
 824a7a8:	e0bff617 	ldw	r2,-40(fp)
 824a7ac:	1004d43a 	srli	r2,r2,16
 824a7b0:	11403fcc 	andi	r5,r2,255
 824a7b4:	e0bff617 	ldw	r2,-40(fp)
 824a7b8:	1004d63a 	srli	r2,r2,24
 824a7bc:	d8800015 	stw	r2,0(sp)
 824a7c0:	280f883a 	mov	r7,r5
 824a7c4:	200d883a 	mov	r6,r4
 824a7c8:	180b883a 	mov	r5,r3
 824a7cc:	01020974 	movhi	r4,2085
 824a7d0:	21063a04 	addi	r4,r4,6376
 824a7d4:	82030ec0 	call	82030ec <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 824a7d8:	e17ffa17 	ldw	r5,-24(fp)
 824a7dc:	e13ffd17 	ldw	r4,-12(fp)
 824a7e0:	824b3240 	call	824b324 <icmp_du>
      break;
 824a7e4:	00014206 	br	824acf0 <icmprcv+0xb44>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 824a7e8:	008209b4 	movhi	r2,2086
 824a7ec:	10b99e04 	addi	r2,r2,-6536
 824a7f0:	10800517 	ldw	r2,20(r2)
 824a7f4:	10c00044 	addi	r3,r2,1
 824a7f8:	008209b4 	movhi	r2,2086
 824a7fc:	10b99e04 	addi	r2,r2,-6536
 824a800:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a804:	d0a08317 	ldw	r2,-32244(gp)
 824a808:	1081000c 	andi	r2,r2,1024
 824a80c:	10001626 	beq	r2,zero,824a868 <icmprcv+0x6bc>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a810:	e0bff617 	ldw	r2,-40(fp)
 824a814:	10c03fcc 	andi	r3,r2,255
 824a818:	e0bff617 	ldw	r2,-40(fp)
 824a81c:	1004d23a 	srli	r2,r2,8
 824a820:	11003fcc 	andi	r4,r2,255
 824a824:	e0bff617 	ldw	r2,-40(fp)
 824a828:	1004d43a 	srli	r2,r2,16
 824a82c:	11403fcc 	andi	r5,r2,255
 824a830:	e0bff617 	ldw	r2,-40(fp)
 824a834:	1004d63a 	srli	r2,r2,24
 824a838:	d8800015 	stw	r2,0(sp)
 824a83c:	280f883a 	mov	r7,r5
 824a840:	200d883a 	mov	r6,r4
 824a844:	180b883a 	mov	r5,r3
 824a848:	01020974 	movhi	r4,2085
 824a84c:	21063f04 	addi	r4,r4,6396
 824a850:	82030ec0 	call	82030ec <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824a854:	d0a08317 	ldw	r2,-32244(gp)
 824a858:	1080008c 	andi	r2,r2,2
 824a85c:	10000226 	beq	r2,zero,824a868 <icmprcv+0x6bc>
 824a860:	e13ffd17 	ldw	r4,-12(fp)
 824a864:	824078c0 	call	824078c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a868:	01000084 	movi	r4,2
 824a86c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824a870:	e13ffd17 	ldw	r4,-12(fp)
 824a874:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a878:	01000084 	movi	r4,2
 824a87c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      break;
 824a880:	00011b06 	br	824acf0 <icmprcv+0xb44>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 824a884:	008209b4 	movhi	r2,2086
 824a888:	10b99e04 	addi	r2,r2,-6536
 824a88c:	10800617 	ldw	r2,24(r2)
 824a890:	10c00044 	addi	r3,r2,1
 824a894:	008209b4 	movhi	r2,2086
 824a898:	10b99e04 	addi	r2,r2,-6536
 824a89c:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 824a8a0:	e0bff717 	ldw	r2,-36(fp)
 824a8a4:	e0bffb15 	stw	r2,-20(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a8a8:	d0a08317 	ldw	r2,-32244(gp)
 824a8ac:	1081000c 	andi	r2,r2,1024
 824a8b0:	10002a26 	beq	r2,zero,824a95c <icmprcv+0x7b0>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a8b4:	e0bffb17 	ldw	r2,-20(fp)
 824a8b8:	10800617 	ldw	r2,24(r2)
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a8bc:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a8c0:	e0bffb17 	ldw	r2,-20(fp)
 824a8c4:	10800617 	ldw	r2,24(r2)
 824a8c8:	1004d23a 	srli	r2,r2,8
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a8cc:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a8d0:	e0bffb17 	ldw	r2,-20(fp)
 824a8d4:	10800617 	ldw	r2,24(r2)
 824a8d8:	1004d43a 	srli	r2,r2,16
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a8dc:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a8e0:	e0bffb17 	ldw	r2,-20(fp)
 824a8e4:	10800617 	ldw	r2,24(r2)
 824a8e8:	1004d63a 	srli	r2,r2,24
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a8ec:	d8800015 	stw	r2,0(sp)
 824a8f0:	280f883a 	mov	r7,r5
 824a8f4:	200d883a 	mov	r6,r4
 824a8f8:	180b883a 	mov	r5,r3
 824a8fc:	01020974 	movhi	r4,2085
 824a900:	21064904 	addi	r4,r4,6436
 824a904:	82030ec0 	call	82030ec <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 824a908:	e0bffb17 	ldw	r2,-20(fp)
 824a90c:	10800117 	ldw	r2,4(r2)
 824a910:	10c03fcc 	andi	r3,r2,255
 824a914:	e0bffb17 	ldw	r2,-20(fp)
 824a918:	10800117 	ldw	r2,4(r2)
 824a91c:	1004d23a 	srli	r2,r2,8
 824a920:	11003fcc 	andi	r4,r2,255
 824a924:	e0bffb17 	ldw	r2,-20(fp)
 824a928:	10800117 	ldw	r2,4(r2)
 824a92c:	1004d43a 	srli	r2,r2,16
 824a930:	11403fcc 	andi	r5,r2,255
 824a934:	e0bffb17 	ldw	r2,-20(fp)
 824a938:	10800117 	ldw	r2,4(r2)
 824a93c:	1004d63a 	srli	r2,r2,24
 824a940:	d8800015 	stw	r2,0(sp)
 824a944:	280f883a 	mov	r7,r5
 824a948:	200d883a 	mov	r6,r4
 824a94c:	180b883a 	mov	r5,r3
 824a950:	01020974 	movhi	r4,2085
 824a954:	21065304 	addi	r4,r4,6476
 824a958:	82030ec0 	call	82030ec <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 824a95c:	e0bffb17 	ldw	r2,-20(fp)
 824a960:	14000617 	ldw	r16,24(r2)
 824a964:	e0bffb17 	ldw	r2,-20(fp)
 824a968:	14400117 	ldw	r17,4(r2)
 824a96c:	e0bffd17 	ldw	r2,-12(fp)
 824a970:	10800617 	ldw	r2,24(r2)
 824a974:	1009883a 	mov	r4,r2
 824a978:	82269b40 	call	82269b4 <if_netnumber>
 824a97c:	1007883a 	mov	r3,r2
 824a980:	00800104 	movi	r2,4
 824a984:	d8800015 	stw	r2,0(sp)
 824a988:	180f883a 	mov	r7,r3
 824a98c:	880d883a 	mov	r6,r17
 824a990:	017fffc4 	movi	r5,-1
 824a994:	8009883a 	mov	r4,r16
 824a998:	824407c0 	call	824407c <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a99c:	01000084 	movi	r4,2
 824a9a0:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824a9a4:	e13ffd17 	ldw	r4,-12(fp)
 824a9a8:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a9ac:	01000084 	movi	r4,2
 824a9b0:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      break;
 824a9b4:	0000ce06 	br	824acf0 <icmprcv+0xb44>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 824a9b8:	008209b4 	movhi	r2,2086
 824a9bc:	10b99e04 	addi	r2,r2,-6536
 824a9c0:	10800317 	ldw	r2,12(r2)
 824a9c4:	10c00044 	addi	r3,r2,1
 824a9c8:	008209b4 	movhi	r2,2086
 824a9cc:	10b99e04 	addi	r2,r2,-6536
 824a9d0:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a9d4:	d0a08317 	ldw	r2,-32244(gp)
 824a9d8:	1081000c 	andi	r2,r2,1024
 824a9dc:	10003126 	beq	r2,zero,824aaa4 <icmprcv+0x8f8>
      {
         struct timex * pt =  (struct  timex *)e;
 824a9e0:	e0bff717 	ldw	r2,-36(fp)
 824a9e4:	e0bffc15 	stw	r2,-16(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
          PUSH_IPADDR(p->fhost));
 824a9e8:	e0bffd17 	ldw	r2,-12(fp)
 824a9ec:	10800717 	ldw	r2,28(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824a9f0:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(p->fhost));
 824a9f4:	e0bffd17 	ldw	r2,-12(fp)
 824a9f8:	10800717 	ldw	r2,28(r2)
 824a9fc:	1004d23a 	srli	r2,r2,8
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824aa00:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(p->fhost));
 824aa04:	e0bffd17 	ldw	r2,-12(fp)
 824aa08:	10800717 	ldw	r2,28(r2)
 824aa0c:	1004d43a 	srli	r2,r2,16
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824aa10:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(p->fhost));
 824aa14:	e0bffd17 	ldw	r2,-12(fp)
 824aa18:	10800717 	ldw	r2,28(r2)
 824aa1c:	1004d63a 	srli	r2,r2,24
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824aa20:	d8800015 	stw	r2,0(sp)
 824aa24:	280f883a 	mov	r7,r5
 824aa28:	200d883a 	mov	r6,r4
 824aa2c:	180b883a 	mov	r5,r3
 824aa30:	01020974 	movhi	r4,2085
 824aa34:	21065704 	addi	r4,r4,6492
 824aa38:	82030ec0 	call	82030ec <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 824aa3c:	e0bffc17 	ldw	r2,-16(fp)
 824aa40:	10800617 	ldw	r2,24(r2)
 824aa44:	10c03fcc 	andi	r3,r2,255
 824aa48:	e0bffc17 	ldw	r2,-16(fp)
 824aa4c:	10800617 	ldw	r2,24(r2)
 824aa50:	1004d23a 	srli	r2,r2,8
 824aa54:	11003fcc 	andi	r4,r2,255
 824aa58:	e0bffc17 	ldw	r2,-16(fp)
 824aa5c:	10800617 	ldw	r2,24(r2)
 824aa60:	1004d43a 	srli	r2,r2,16
 824aa64:	11403fcc 	andi	r5,r2,255
 824aa68:	e0bffc17 	ldw	r2,-16(fp)
 824aa6c:	10800617 	ldw	r2,24(r2)
 824aa70:	1004d63a 	srli	r2,r2,24
 824aa74:	d8800015 	stw	r2,0(sp)
 824aa78:	280f883a 	mov	r7,r5
 824aa7c:	200d883a 	mov	r6,r4
 824aa80:	180b883a 	mov	r5,r3
 824aa84:	01020974 	movhi	r4,2085
 824aa88:	21066004 	addi	r4,r4,6528
 824aa8c:	82030ec0 	call	82030ec <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824aa90:	d0a08317 	ldw	r2,-32244(gp)
 824aa94:	1080008c 	andi	r2,r2,2
 824aa98:	10000226 	beq	r2,zero,824aaa4 <icmprcv+0x8f8>
 824aa9c:	e13ffd17 	ldw	r4,-12(fp)
 824aaa0:	824078c0 	call	824078c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824aaa4:	01000084 	movi	r4,2
 824aaa8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824aaac:	e13ffd17 	ldw	r4,-12(fp)
 824aab0:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aab4:	01000084 	movi	r4,2
 824aab8:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      break;
 824aabc:	00008c06 	br	824acf0 <icmprcv+0xb44>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 824aac0:	008209b4 	movhi	r2,2086
 824aac4:	10b99e04 	addi	r2,r2,-6536
 824aac8:	10800417 	ldw	r2,16(r2)
 824aacc:	10c00044 	addi	r3,r2,1
 824aad0:	008209b4 	movhi	r2,2086
 824aad4:	10b99e04 	addi	r2,r2,-6536
 824aad8:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824aadc:	d0a08317 	ldw	r2,-32244(gp)
 824aae0:	1081000c 	andi	r2,r2,1024
 824aae4:	10000326 	beq	r2,zero,824aaf4 <icmprcv+0x948>
         dprintf("ICMP: got param problem message\n");
 824aae8:	01020974 	movhi	r4,2085
 824aaec:	21066504 	addi	r4,r4,6548
 824aaf0:	82033700 	call	8203370 <puts>
      if (NDEBUG & DUMP)
 824aaf4:	d0a08317 	ldw	r2,-32244(gp)
 824aaf8:	1080008c 	andi	r2,r2,2
 824aafc:	10000226 	beq	r2,zero,824ab08 <icmprcv+0x95c>
      {
         ip_dump(p);
 824ab00:	e13ffd17 	ldw	r4,-12(fp)
 824ab04:	824078c0 	call	824078c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ab08:	01000084 	movi	r4,2
 824ab0c:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824ab10:	e13ffd17 	ldw	r4,-12(fp)
 824ab14:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ab18:	01000084 	movi	r4,2
 824ab1c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      break;
 824ab20:	00007306 	br	824acf0 <icmprcv+0xb44>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 824ab24:	008209b4 	movhi	r2,2086
 824ab28:	10b99e04 	addi	r2,r2,-6536
 824ab2c:	10800917 	ldw	r2,36(r2)
 824ab30:	10c00044 	addi	r3,r2,1
 824ab34:	008209b4 	movhi	r2,2086
 824ab38:	10b99e04 	addi	r2,r2,-6536
 824ab3c:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ab40:	d0a08317 	ldw	r2,-32244(gp)
 824ab44:	1081000c 	andi	r2,r2,1024
 824ab48:	10000326 	beq	r2,zero,824ab58 <icmprcv+0x9ac>
         dprintf("ICMP: got timestamp request\n");
 824ab4c:	01020974 	movhi	r4,2085
 824ab50:	21066d04 	addi	r4,r4,6580
 824ab54:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 824ab58:	e0bff717 	ldw	r2,-36(fp)
 824ab5c:	00c00384 	movi	r3,14
 824ab60:	10c00005 	stb	r3,0(r2)
      e->pchksum = 0;
 824ab64:	e0bff717 	ldw	r2,-36(fp)
 824ab68:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 824ab6c:	01400284 	movi	r5,10
 824ab70:	e13ff717 	ldw	r4,-36(fp)
 824ab74:	82285000 	call	8228500 <cksum>
 824ab78:	0084303a 	nor	r2,zero,r2
 824ab7c:	1007883a 	mov	r3,r2
 824ab80:	e0bff717 	ldw	r2,-36(fp)
 824ab84:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 824ab88:	e0bff417 	ldw	r2,-48(fp)
 824ab8c:	10c00417 	ldw	r3,16(r2)
 824ab90:	e0bff417 	ldw	r2,-48(fp)
 824ab94:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 824ab98:	e0bff417 	ldw	r2,-48(fp)
 824ab9c:	e0fff617 	ldw	r3,-40(fp)
 824aba0:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutMsgs++;
 824aba4:	008209b4 	movhi	r2,2086
 824aba8:	10b99e04 	addi	r2,r2,-6536
 824abac:	10800d17 	ldw	r2,52(r2)
 824abb0:	10c00044 	addi	r3,r2,1
 824abb4:	008209b4 	movhi	r2,2086
 824abb8:	10b99e04 	addi	r2,r2,-6536
 824abbc:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 824abc0:	008209b4 	movhi	r2,2086
 824abc4:	10b99e04 	addi	r2,r2,-6536
 824abc8:	10801717 	ldw	r2,92(r2)
 824abcc:	10c00044 	addi	r3,r2,1
 824abd0:	008209b4 	movhi	r2,2086
 824abd4:	10b99e04 	addi	r2,r2,-6536
 824abd8:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824abdc:	e0bffd17 	ldw	r2,-12(fp)
 824abe0:	10c00317 	ldw	r3,12(r2)
 824abe4:	e0bff417 	ldw	r2,-48(fp)
 824abe8:	10800003 	ldbu	r2,0(r2)
 824abec:	10803fcc 	andi	r2,r2,255
 824abf0:	108003cc 	andi	r2,r2,15
 824abf4:	1085883a 	add	r2,r2,r2
 824abf8:	1085883a 	add	r2,r2,r2
 824abfc:	1887883a 	add	r3,r3,r2
 824ac00:	e0bffd17 	ldw	r2,-12(fp)
 824ac04:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 824ac08:	e0bffd17 	ldw	r2,-12(fp)
 824ac0c:	00c00504 	movi	r3,20
 824ac10:	10c00415 	stw	r3,16(r2)
      p->fhost = host;
 824ac14:	e0bffd17 	ldw	r2,-12(fp)
 824ac18:	e0fff617 	ldw	r3,-40(fp)
 824ac1c:	10c00715 	stw	r3,28(r2)
      i = ip_write(ICMP_PROT, p);
 824ac20:	e17ffd17 	ldw	r5,-12(fp)
 824ac24:	01000044 	movi	r4,1
 824ac28:	823f6980 	call	823f698 <ip_write>
 824ac2c:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824ac30:	e0bff917 	ldw	r2,-28(fp)
 824ac34:	1000060e 	bge	r2,zero,824ac50 <icmprcv+0xaa4>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 824ac38:	d0a08317 	ldw	r2,-32244(gp)
 824ac3c:	1081000c 	andi	r2,r2,1024
 824ac40:	10000326 	beq	r2,zero,824ac50 <icmprcv+0xaa4>
            dprintf("icmp: can't send timestamp reply\n");
 824ac44:	01020974 	movhi	r4,2085
 824ac48:	21067404 	addi	r4,r4,6608
 824ac4c:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 824ac50:	0005883a 	mov	r2,zero
 824ac54:	00002706 	br	824acf4 <icmprcv+0xb48>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ac58:	d0a08317 	ldw	r2,-32244(gp)
 824ac5c:	1081000c 	andi	r2,r2,1024
 824ac60:	10000326 	beq	r2,zero,824ac70 <icmprcv+0xac4>
         dprintf("icmp: got info request\n");
 824ac64:	01020974 	movhi	r4,2085
 824ac68:	21067d04 	addi	r4,r4,6644
 824ac6c:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ac70:	01000084 	movi	r4,2
 824ac74:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824ac78:	e13ffd17 	ldw	r4,-12(fp)
 824ac7c:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ac80:	01000084 	movi	r4,2
 824ac84:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      break;
 824ac88:	00001906 	br	824acf0 <icmprcv+0xb44>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ac8c:	d0a08317 	ldw	r2,-32244(gp)
 824ac90:	1081000c 	andi	r2,r2,1024
 824ac94:	10000e26 	beq	r2,zero,824acd0 <icmprcv+0xb24>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 824ac98:	e0bff717 	ldw	r2,-36(fp)
 824ac9c:	10800003 	ldbu	r2,0(r2)
 824aca0:	10803fcc 	andi	r2,r2,255
 824aca4:	1080201c 	xori	r2,r2,128
 824aca8:	10bfe004 	addi	r2,r2,-128
 824acac:	100b883a 	mov	r5,r2
 824acb0:	01020974 	movhi	r4,2085
 824acb4:	21068304 	addi	r4,r4,6668
 824acb8:	82030ec0 	call	82030ec <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824acbc:	d0a08317 	ldw	r2,-32244(gp)
 824acc0:	1080008c 	andi	r2,r2,2
 824acc4:	10000226 	beq	r2,zero,824acd0 <icmprcv+0xb24>
 824acc8:	e13ffd17 	ldw	r4,-12(fp)
 824accc:	824078c0 	call	824078c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824acd0:	01000084 	movi	r4,2
 824acd4:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
      pk_free(p);
 824acd8:	e13ffd17 	ldw	r4,-12(fp)
 824acdc:	822ca880 	call	822ca88 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ace0:	01000084 	movi	r4,2
 824ace4:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 824ace8:	00800084 	movi	r2,2
 824acec:	00000106 	br	824acf4 <icmprcv+0xb48>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 824acf0:	00800084 	movi	r2,2
#endif   /* FULL_ICMP */
}
 824acf4:	e6fffe04 	addi	sp,fp,-8
 824acf8:	dfc00317 	ldw	ra,12(sp)
 824acfc:	df000217 	ldw	fp,8(sp)
 824ad00:	dc400117 	ldw	r17,4(sp)
 824ad04:	dc000017 	ldw	r16,0(sp)
 824ad08:	dec00404 	addi	sp,sp,16
 824ad0c:	f800283a 	ret

0824ad10 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 824ad10:	defff404 	addi	sp,sp,-48
 824ad14:	dfc00b15 	stw	ra,44(sp)
 824ad18:	df000a15 	stw	fp,40(sp)
 824ad1c:	df000a04 	addi	fp,sp,40
 824ad20:	e13ffc15 	stw	r4,-16(fp)
 824ad24:	e17ffd15 	stw	r5,-12(fp)
 824ad28:	e1bffe15 	stw	r6,-8(fp)
 824ad2c:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824ad30:	d0a08317 	ldw	r2,-32244(gp)
 824ad34:	1080040c 	andi	r2,r2,16
 824ad38:	10001a26 	beq	r2,zero,824ada4 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ad3c:	e0bfff17 	ldw	r2,-4(fp)
 824ad40:	10c03fcc 	andi	r3,r2,255
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ad44:	00820974 	movhi	r2,2085
 824ad48:	108eb004 	addi	r2,r2,15040
 824ad4c:	18c7883a 	add	r3,r3,r3
 824ad50:	18c7883a 	add	r3,r3,r3
 824ad54:	10c5883a 	add	r2,r2,r3
 824ad58:	11000017 	ldw	r4,0(r2)
 824ad5c:	e0bffc17 	ldw	r2,-16(fp)
 824ad60:	11403fcc 	andi	r5,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ad64:	e0bffc17 	ldw	r2,-16(fp)
 824ad68:	1004d23a 	srli	r2,r2,8
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ad6c:	11803fcc 	andi	r6,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ad70:	e0bffc17 	ldw	r2,-16(fp)
 824ad74:	1004d43a 	srli	r2,r2,16
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ad78:	10803fcc 	andi	r2,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ad7c:	e0fffc17 	ldw	r3,-16(fp)
 824ad80:	1806d63a 	srli	r3,r3,24
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ad84:	d8c00115 	stw	r3,4(sp)
 824ad88:	d8800015 	stw	r2,0(sp)
 824ad8c:	300f883a 	mov	r7,r6
 824ad90:	280d883a 	mov	r6,r5
 824ad94:	200b883a 	mov	r5,r4
 824ad98:	01020974 	movhi	r4,2085
 824ad9c:	21069d04 	addi	r4,r4,6772
 824ada0:	82030ec0 	call	82030ec <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 824ada4:	01000084 	movi	r4,2
 824ada8:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 824adac:	01008504 	movi	r4,532
 824adb0:	822c7380 	call	822c738 <pk_alloc>
 824adb4:	e0bff815 	stw	r2,-32(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824adb8:	01000084 	movi	r4,2
 824adbc:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824adc0:	e0bff817 	ldw	r2,-32(fp)
 824adc4:	10000e1e 	bne	r2,zero,824ae00 <icmp_destun+0xf0>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824adc8:	d0a08317 	ldw	r2,-32244(gp)
 824adcc:	1080800c 	andi	r2,r2,512
 824add0:	10000326 	beq	r2,zero,824ade0 <icmp_destun+0xd0>
         dprintf("icmp: can't alloc pkt\n");
 824add4:	01020974 	movhi	r4,2085
 824add8:	2106aa04 	addi	r4,r4,6824
 824addc:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824ade0:	008209b4 	movhi	r2,2086
 824ade4:	10b99e04 	addi	r2,r2,-6536
 824ade8:	10800e17 	ldw	r2,56(r2)
 824adec:	10c00044 	addi	r3,r2,1
 824adf0:	008209b4 	movhi	r2,2086
 824adf4:	10b99e04 	addi	r2,r2,-6536
 824adf8:	10c00e15 	stw	r3,56(r2)
      return;
 824adfc:	00007f06 	br	824affc <icmp_destun+0x2ec>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824ae00:	e0bff817 	ldw	r2,-32(fp)
 824ae04:	10800317 	ldw	r2,12(r2)
 824ae08:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 824ae0c:	e0bff917 	ldw	r2,-28(fp)
 824ae10:	e0fffd17 	ldw	r3,-12(fp)
 824ae14:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = host;
 824ae18:	e0bff917 	ldw	r2,-28(fp)
 824ae1c:	e0fffc17 	ldw	r3,-16(fp)
 824ae20:	10c00415 	stw	r3,16(r2)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 824ae24:	e0bff817 	ldw	r2,-32(fp)
 824ae28:	10800317 	ldw	r2,12(r2)
 824ae2c:	10c00504 	addi	r3,r2,20
 824ae30:	e0bff817 	ldw	r2,-32(fp)
 824ae34:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 824ae38:	e0bff817 	ldw	r2,-32(fp)
 824ae3c:	10800417 	ldw	r2,16(r2)
 824ae40:	10fffb04 	addi	r3,r2,-20
 824ae44:	e0bff817 	ldw	r2,-32(fp)
 824ae48:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 824ae4c:	e0bff817 	ldw	r2,-32(fp)
 824ae50:	e0c00217 	ldw	r3,8(fp)
 824ae54:	10c00615 	stw	r3,24(r2)

   d = (struct destun *)p->nb_prot;
 824ae58:	e0bff817 	ldw	r2,-32(fp)
 824ae5c:	10800317 	ldw	r2,12(r2)
 824ae60:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 824ae64:	e0bfff17 	ldw	r2,-4(fp)
 824ae68:	10bfc00c 	andi	r2,r2,65280
 824ae6c:	10000626 	beq	r2,zero,824ae88 <icmp_destun+0x178>
      d->dtype = (char)(typecode >>8);  /* then use it */
 824ae70:	e0bfff17 	ldw	r2,-4(fp)
 824ae74:	1004d23a 	srli	r2,r2,8
 824ae78:	1007883a 	mov	r3,r2
 824ae7c:	e0bffa17 	ldw	r2,-24(fp)
 824ae80:	10c00005 	stb	r3,0(r2)
 824ae84:	00000306 	br	824ae94 <icmp_destun+0x184>
   else                                 /* else use default */
      d->dtype = DESTIN;
 824ae88:	e0bffa17 	ldw	r2,-24(fp)
 824ae8c:	00c000c4 	movi	r3,3
 824ae90:	10c00005 	stb	r3,0(r2)
   d->dcode = (char)(typecode & 0xFF);
 824ae94:	e0bfff17 	ldw	r2,-4(fp)
 824ae98:	1007883a 	mov	r3,r2
 824ae9c:	e0bffa17 	ldw	r2,-24(fp)
 824aea0:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 824aea4:	e0bffa17 	ldw	r2,-24(fp)
 824aea8:	1000018d 	sth	zero,6(r2)
 824aeac:	e0bffa17 	ldw	r2,-24(fp)
 824aeb0:	10c0018b 	ldhu	r3,6(r2)
 824aeb4:	e0bffa17 	ldw	r2,-24(fp)
 824aeb8:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 824aebc:	e0bfff17 	ldw	r2,-4(fp)
 824aec0:	10803fcc 	andi	r2,r2,255
 824aec4:	10800118 	cmpnei	r2,r2,4
 824aec8:	1000121e 	bne	r2,zero,824af14 <icmp_destun+0x204>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 824aecc:	e0800217 	ldw	r2,8(fp)
 824aed0:	10c00917 	ldw	r3,36(r2)
 824aed4:	e0800217 	ldw	r2,8(fp)
 824aed8:	10800817 	ldw	r2,32(r2)
 824aedc:	1885c83a 	sub	r2,r3,r2
 824aee0:	1005d23a 	srai	r2,r2,8
 824aee4:	10803fcc 	andi	r2,r2,255
 824aee8:	1009883a 	mov	r4,r2
 824aeec:	e0800217 	ldw	r2,8(fp)
 824aef0:	10c00917 	ldw	r3,36(r2)
 824aef4:	e0800217 	ldw	r2,8(fp)
 824aef8:	10800817 	ldw	r2,32(r2)
 824aefc:	1885c83a 	sub	r2,r3,r2
 824af00:	1004923a 	slli	r2,r2,8
 824af04:	2084b03a 	or	r2,r4,r2
 824af08:	1007883a 	mov	r3,r2
 824af0c:	e0bffa17 	ldw	r2,-24(fp)
 824af10:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 824af14:	e0bffa17 	ldw	r2,-24(fp)
 824af18:	10800204 	addi	r2,r2,8
 824af1c:	01800704 	movi	r6,28
 824af20:	e17ffe17 	ldw	r5,-8(fp)
 824af24:	1009883a 	mov	r4,r2
 824af28:	8202c5c0 	call	8202c5c <memcpy>

   d->dchksum = 0;
 824af2c:	e0bffa17 	ldw	r2,-24(fp)
 824af30:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 824af34:	01400484 	movi	r5,18
 824af38:	e13ffa17 	ldw	r4,-24(fp)
 824af3c:	82285000 	call	8228500 <cksum>
 824af40:	0084303a 	nor	r2,zero,r2
 824af44:	1007883a 	mov	r3,r2
 824af48:	e0bffa17 	ldw	r2,-24(fp)
 824af4c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 824af50:	e0bff817 	ldw	r2,-32(fp)
 824af54:	00c00904 	movi	r3,36
 824af58:	10c00415 	stw	r3,16(r2)
   p->fhost = host;
 824af5c:	e0bff817 	ldw	r2,-32(fp)
 824af60:	e0fffc17 	ldw	r3,-16(fp)
 824af64:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824af68:	e17ff817 	ldw	r5,-32(fp)
 824af6c:	01000044 	movi	r4,1
 824af70:	823f6980 	call	823f698 <ip_write>
 824af74:	e0bffb15 	stw	r2,-20(fp)
   if (i < 0)
 824af78:	e0bffb17 	ldw	r2,-20(fp)
 824af7c:	10000e0e 	bge	r2,zero,824afb8 <icmp_destun+0x2a8>
   {
      icmp_mib.icmpOutErrors++;
 824af80:	008209b4 	movhi	r2,2086
 824af84:	10b99e04 	addi	r2,r2,-6536
 824af88:	10800e17 	ldw	r2,56(r2)
 824af8c:	10c00044 	addi	r3,r2,1
 824af90:	008209b4 	movhi	r2,2086
 824af94:	10b99e04 	addi	r2,r2,-6536
 824af98:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824af9c:	d0a08317 	ldw	r2,-32244(gp)
 824afa0:	1080860c 	andi	r2,r2,536
 824afa4:	10001426 	beq	r2,zero,824aff8 <icmp_destun+0x2e8>
         dprintf("ICMP: Can't send dest unreachable\n");
 824afa8:	01020974 	movhi	r4,2085
 824afac:	2106b004 	addi	r4,r4,6848
 824afb0:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG  */
      return;
 824afb4:	00001006 	br	824aff8 <icmp_destun+0x2e8>
   }
   icmp_mib.icmpOutMsgs++;
 824afb8:	008209b4 	movhi	r2,2086
 824afbc:	10b99e04 	addi	r2,r2,-6536
 824afc0:	10800d17 	ldw	r2,52(r2)
 824afc4:	10c00044 	addi	r3,r2,1
 824afc8:	008209b4 	movhi	r2,2086
 824afcc:	10b99e04 	addi	r2,r2,-6536
 824afd0:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 824afd4:	008209b4 	movhi	r2,2086
 824afd8:	10b99e04 	addi	r2,r2,-6536
 824afdc:	10800f17 	ldw	r2,60(r2)
 824afe0:	10c00044 	addi	r3,r2,1
 824afe4:	008209b4 	movhi	r2,2086
 824afe8:	10b99e04 	addi	r2,r2,-6536
 824afec:	10c00f15 	stw	r3,60(r2)
   return;
 824aff0:	0001883a 	nop
 824aff4:	00000106 	br	824affc <icmp_destun+0x2ec>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send dest unreachable\n");
#endif   /* NPDEBUG  */
      return;
 824aff8:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutDestUnreachs++;
   return;
}
 824affc:	e037883a 	mov	sp,fp
 824b000:	dfc00117 	ldw	ra,4(sp)
 824b004:	df000017 	ldw	fp,0(sp)
 824b008:	dec00204 	addi	sp,sp,8
 824b00c:	f800283a 	ret

0824b010 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 824b010:	defff504 	addi	sp,sp,-44
 824b014:	dfc00a15 	stw	ra,40(sp)
 824b018:	df000915 	stw	fp,36(sp)
 824b01c:	df000904 	addi	fp,sp,36
 824b020:	e13ffe15 	stw	r4,-8(fp)
 824b024:	2805883a 	mov	r2,r5
 824b028:	e0bfff05 	stb	r2,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824b02c:	d0a08317 	ldw	r2,-32244(gp)
 824b030:	1080040c 	andi	r2,r2,16
 824b034:	10003026 	beq	r2,zero,824b0f8 <icmp_timex+0xe8>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b038:	e17fff07 	ldb	r5,-4(fp)
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b03c:	e0bffe17 	ldw	r2,-8(fp)
 824b040:	10800317 	ldw	r2,12(r2)
 824b044:	1004d23a 	srli	r2,r2,8
 824b048:	10c03fcc 	andi	r3,r2,255
 824b04c:	e0bffe17 	ldw	r2,-8(fp)
 824b050:	10800317 	ldw	r2,12(r2)
 824b054:	1004923a 	slli	r2,r2,8
 824b058:	10bfffcc 	andi	r2,r2,65535
 824b05c:	1884b03a 	or	r2,r3,r2
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b060:	11803fcc 	andi	r6,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b064:	e0bffe17 	ldw	r2,-8(fp)
 824b068:	10800317 	ldw	r2,12(r2)
 824b06c:	1004d23a 	srli	r2,r2,8
 824b070:	10c03fcc 	andi	r3,r2,255
 824b074:	e0bffe17 	ldw	r2,-8(fp)
 824b078:	10800317 	ldw	r2,12(r2)
 824b07c:	1004923a 	slli	r2,r2,8
 824b080:	10bfffcc 	andi	r2,r2,65535
 824b084:	1884b03a 	or	r2,r3,r2
 824b088:	1004d23a 	srli	r2,r2,8
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b08c:	11c03fcc 	andi	r7,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b090:	e0bffe17 	ldw	r2,-8(fp)
 824b094:	10800317 	ldw	r2,12(r2)
 824b098:	1004d23a 	srli	r2,r2,8
 824b09c:	10c03fcc 	andi	r3,r2,255
 824b0a0:	e0bffe17 	ldw	r2,-8(fp)
 824b0a4:	10800317 	ldw	r2,12(r2)
 824b0a8:	1004923a 	slli	r2,r2,8
 824b0ac:	10bfffcc 	andi	r2,r2,65535
 824b0b0:	1884b03a 	or	r2,r3,r2
 824b0b4:	1004d43a 	srli	r2,r2,16
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b0b8:	10803fcc 	andi	r2,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b0bc:	e0fffe17 	ldw	r3,-8(fp)
 824b0c0:	18c00317 	ldw	r3,12(r3)
 824b0c4:	1806d23a 	srli	r3,r3,8
 824b0c8:	19003fcc 	andi	r4,r3,255
 824b0cc:	e0fffe17 	ldw	r3,-8(fp)
 824b0d0:	18c00317 	ldw	r3,12(r3)
 824b0d4:	1806923a 	slli	r3,r3,8
 824b0d8:	18ffffcc 	andi	r3,r3,65535
 824b0dc:	20c6b03a 	or	r3,r4,r3
 824b0e0:	1806d63a 	srli	r3,r3,24
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b0e4:	d8c00115 	stw	r3,4(sp)
 824b0e8:	d8800015 	stw	r2,0(sp)
 824b0ec:	01020974 	movhi	r4,2085
 824b0f0:	2106b904 	addi	r4,r4,6884
 824b0f4:	82030ec0 	call	82030ec <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 824b0f8:	e0bffe17 	ldw	r2,-8(fp)
 824b0fc:	10800003 	ldbu	r2,0(r2)
 824b100:	108003cc 	andi	r2,r2,15
 824b104:	1085883a 	add	r2,r2,r2
 824b108:	1085883a 	add	r2,r2,r2
 824b10c:	10800404 	addi	r2,r2,16
 824b110:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824b114:	01000084 	movi	r4,2
 824b118:	822d55c0 	call	822d55c <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 824b11c:	e0bff903 	ldbu	r2,-28(fp)
 824b120:	d0e08117 	ldw	r3,-32252(gp)
 824b124:	10c5883a 	add	r2,r2,r3
 824b128:	10800504 	addi	r2,r2,20
 824b12c:	1009883a 	mov	r4,r2
 824b130:	822c7380 	call	822c738 <pk_alloc>
 824b134:	e0bffa15 	stw	r2,-24(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824b138:	01000084 	movi	r4,2
 824b13c:	822d6200 	call	822d620 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824b140:	e0bffa17 	ldw	r2,-24(fp)
 824b144:	10000e1e 	bne	r2,zero,824b180 <icmp_timex+0x170>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824b148:	d0a08317 	ldw	r2,-32244(gp)
 824b14c:	1080800c 	andi	r2,r2,512
 824b150:	10000326 	beq	r2,zero,824b160 <icmp_timex+0x150>
         dprintf("icmp: can't alloc pkt\n");
 824b154:	01020974 	movhi	r4,2085
 824b158:	2106aa04 	addi	r4,r4,6824
 824b15c:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824b160:	008209b4 	movhi	r2,2086
 824b164:	10b99e04 	addi	r2,r2,-6536
 824b168:	10800e17 	ldw	r2,56(r2)
 824b16c:	10c00044 	addi	r3,r2,1
 824b170:	008209b4 	movhi	r2,2086
 824b174:	10b99e04 	addi	r2,r2,-6536
 824b178:	10c00e15 	stw	r3,56(r2)
      return;
 824b17c:	00006406 	br	824b310 <icmp_timex+0x300>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824b180:	e0bffa17 	ldw	r2,-24(fp)
 824b184:	10800317 	ldw	r2,12(r2)
 824b188:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 824b18c:	e0bffe17 	ldw	r2,-8(fp)
 824b190:	10c00417 	ldw	r3,16(r2)
 824b194:	e0bffb17 	ldw	r2,-20(fp)
 824b198:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 824b19c:	e0bffe17 	ldw	r2,-8(fp)
 824b1a0:	10c00317 	ldw	r3,12(r2)
 824b1a4:	e0bffb17 	ldw	r2,-20(fp)
 824b1a8:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 824b1ac:	e0bffa17 	ldw	r2,-24(fp)
 824b1b0:	10800317 	ldw	r2,12(r2)
 824b1b4:	10c00504 	addi	r3,r2,20
 824b1b8:	e0bffa17 	ldw	r2,-24(fp)
 824b1bc:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 824b1c0:	e0bffa17 	ldw	r2,-24(fp)
 824b1c4:	10800317 	ldw	r2,12(r2)
 824b1c8:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 824b1cc:	e0bffc17 	ldw	r2,-16(fp)
 824b1d0:	00c002c4 	movi	r3,11
 824b1d4:	10c00005 	stb	r3,0(r2)
   tx->tcode = code;
 824b1d8:	e0bffc17 	ldw	r2,-16(fp)
 824b1dc:	e0ffff03 	ldbu	r3,-4(fp)
 824b1e0:	10c00045 	stb	r3,1(r2)
   tx->tno1 = tx->tno2 = 0;
 824b1e4:	e0bffc17 	ldw	r2,-16(fp)
 824b1e8:	1000018d 	sth	zero,6(r2)
 824b1ec:	e0bffc17 	ldw	r2,-16(fp)
 824b1f0:	10c0018b 	ldhu	r3,6(r2)
 824b1f4:	e0bffc17 	ldw	r2,-16(fp)
 824b1f8:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 824b1fc:	e0bffc17 	ldw	r2,-16(fp)
 824b200:	10c00204 	addi	r3,r2,8
 824b204:	e0bffe17 	ldw	r2,-8(fp)
 824b208:	10800003 	ldbu	r2,0(r2)
 824b20c:	10803fcc 	andi	r2,r2,255
 824b210:	108003cc 	andi	r2,r2,15
 824b214:	1085883a 	add	r2,r2,r2
 824b218:	1085883a 	add	r2,r2,r2
 824b21c:	10800204 	addi	r2,r2,8
 824b220:	100d883a 	mov	r6,r2
 824b224:	e17ffe17 	ldw	r5,-8(fp)
 824b228:	1809883a 	mov	r4,r3
 824b22c:	8202c5c0 	call	8202c5c <memcpy>

   tx->tchksum = 0;
 824b230:	e0bffc17 	ldw	r2,-16(fp)
 824b234:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 824b238:	e0bff903 	ldbu	r2,-28(fp)
 824b23c:	1004d07a 	srli	r2,r2,1
 824b240:	10803fcc 	andi	r2,r2,255
 824b244:	100b883a 	mov	r5,r2
 824b248:	e13ffc17 	ldw	r4,-16(fp)
 824b24c:	82285000 	call	8228500 <cksum>
 824b250:	0084303a 	nor	r2,zero,r2
 824b254:	1007883a 	mov	r3,r2
 824b258:	e0bffc17 	ldw	r2,-16(fp)
 824b25c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 824b260:	e0fff903 	ldbu	r3,-28(fp)
 824b264:	e0bffa17 	ldw	r2,-24(fp)
 824b268:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 824b26c:	e0bffb17 	ldw	r2,-20(fp)
 824b270:	10c00417 	ldw	r3,16(r2)
 824b274:	e0bffa17 	ldw	r2,-24(fp)
 824b278:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b27c:	e17ffa17 	ldw	r5,-24(fp)
 824b280:	01000044 	movi	r4,1
 824b284:	823f6980 	call	823f698 <ip_write>
 824b288:	e0bffd15 	stw	r2,-12(fp)
   if (i < 0)
 824b28c:	e0bffd17 	ldw	r2,-12(fp)
 824b290:	10000e0e 	bge	r2,zero,824b2cc <icmp_timex+0x2bc>
   {
      icmp_mib.icmpOutErrors++;
 824b294:	008209b4 	movhi	r2,2086
 824b298:	10b99e04 	addi	r2,r2,-6536
 824b29c:	10800e17 	ldw	r2,56(r2)
 824b2a0:	10c00044 	addi	r3,r2,1
 824b2a4:	008209b4 	movhi	r2,2086
 824b2a8:	10b99e04 	addi	r2,r2,-6536
 824b2ac:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b2b0:	d0a08317 	ldw	r2,-32244(gp)
 824b2b4:	1080860c 	andi	r2,r2,536
 824b2b8:	10001426 	beq	r2,zero,824b30c <icmp_timex+0x2fc>
         dprintf("ICMP: Can't send Time Exceeded\n");
 824b2bc:	01020974 	movhi	r4,2085
 824b2c0:	2106c904 	addi	r4,r4,6948
 824b2c4:	82033700 	call	8203370 <puts>
#endif   /* NPDEBUG  */
      return;
 824b2c8:	00001006 	br	824b30c <icmp_timex+0x2fc>
   }
   icmp_mib.icmpOutMsgs++;
 824b2cc:	008209b4 	movhi	r2,2086
 824b2d0:	10b99e04 	addi	r2,r2,-6536
 824b2d4:	10800d17 	ldw	r2,52(r2)
 824b2d8:	10c00044 	addi	r3,r2,1
 824b2dc:	008209b4 	movhi	r2,2086
 824b2e0:	10b99e04 	addi	r2,r2,-6536
 824b2e4:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 824b2e8:	008209b4 	movhi	r2,2086
 824b2ec:	10b99e04 	addi	r2,r2,-6536
 824b2f0:	10801017 	ldw	r2,64(r2)
 824b2f4:	10c00044 	addi	r3,r2,1
 824b2f8:	008209b4 	movhi	r2,2086
 824b2fc:	10b99e04 	addi	r2,r2,-6536
 824b300:	10c01015 	stw	r3,64(r2)
   return;
 824b304:	0001883a 	nop
 824b308:	00000106 	br	824b310 <icmp_timex+0x300>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send Time Exceeded\n");
#endif   /* NPDEBUG  */
      return;
 824b30c:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutTimeExcds++;
   return;
}
 824b310:	e037883a 	mov	sp,fp
 824b314:	dfc00117 	ldw	ra,4(sp)
 824b318:	df000017 	ldw	fp,0(sp)
 824b31c:	dec00204 	addi	sp,sp,8
 824b320:	f800283a 	ret

0824b324 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 824b324:	defffc04 	addi	sp,sp,-16
 824b328:	dfc00315 	stw	ra,12(sp)
 824b32c:	df000215 	stw	fp,8(sp)
 824b330:	df000204 	addi	fp,sp,8
 824b334:	e13ffe15 	stw	r4,-8(fp)
 824b338:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 824b33c:	d0a0dc17 	ldw	r2,-31888(gp)
 824b340:	10000426 	beq	r2,zero,824b354 <icmp_du+0x30>
      icmpdu_hook(p, pdp);
 824b344:	d0a0dc17 	ldw	r2,-31888(gp)
 824b348:	e17fff17 	ldw	r5,-4(fp)
 824b34c:	e13ffe17 	ldw	r4,-8(fp)
 824b350:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 824b354:	e17fff17 	ldw	r5,-4(fp)
 824b358:	e13ffe17 	ldw	r4,-8(fp)
 824b35c:	822f3fc0 	call	822f3fc <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 824b360:	0001883a 	nop
 824b364:	e037883a 	mov	sp,fp
 824b368:	dfc00117 	ldw	ra,4(sp)
 824b36c:	df000017 	ldw	fp,0(sp)
 824b370:	dec00204 	addi	sp,sp,8
 824b374:	f800283a 	ret

0824b378 <atexit>:
 824b378:	200b883a 	mov	r5,r4
 824b37c:	000f883a 	mov	r7,zero
 824b380:	000d883a 	mov	r6,zero
 824b384:	0009883a 	mov	r4,zero
 824b388:	824b93c1 	jmpi	824b93c <__register_exitproc>

0824b38c <atoi>:
 824b38c:	01800284 	movi	r6,10
 824b390:	000b883a 	mov	r5,zero
 824b394:	824b8881 	jmpi	824b888 <strtol>

0824b398 <_atoi_r>:
 824b398:	01c00284 	movi	r7,10
 824b39c:	000d883a 	mov	r6,zero
 824b3a0:	824b6501 	jmpi	824b650 <_strtol_r>

0824b3a4 <exit>:
 824b3a4:	defffe04 	addi	sp,sp,-8
 824b3a8:	000b883a 	mov	r5,zero
 824b3ac:	dc000015 	stw	r16,0(sp)
 824b3b0:	dfc00115 	stw	ra,4(sp)
 824b3b4:	2021883a 	mov	r16,r4
 824b3b8:	824ba540 	call	824ba54 <__call_exitprocs>
 824b3bc:	00820974 	movhi	r2,2085
 824b3c0:	108eb704 	addi	r2,r2,15068
 824b3c4:	11000017 	ldw	r4,0(r2)
 824b3c8:	20800f17 	ldw	r2,60(r4)
 824b3cc:	10000126 	beq	r2,zero,824b3d4 <exit+0x30>
 824b3d0:	103ee83a 	callr	r2
 824b3d4:	8009883a 	mov	r4,r16
 824b3d8:	824bbec0 	call	824bbec <_exit>

0824b3dc <malloc>:
 824b3dc:	00820974 	movhi	r2,2085
 824b3e0:	108eb804 	addi	r2,r2,15072
 824b3e4:	200b883a 	mov	r5,r4
 824b3e8:	11000017 	ldw	r4,0(r2)
 824b3ec:	820ba381 	jmpi	820ba38 <_malloc_r>

0824b3f0 <free>:
 824b3f0:	00820974 	movhi	r2,2085
 824b3f4:	108eb804 	addi	r2,r2,15072
 824b3f8:	200b883a 	mov	r5,r4
 824b3fc:	11000017 	ldw	r4,0(r2)
 824b400:	820ae4c1 	jmpi	820ae4c <_free_r>

0824b404 <strcpy>:
 824b404:	2906b03a 	or	r3,r5,r4
 824b408:	18c000cc 	andi	r3,r3,3
 824b40c:	2005883a 	mov	r2,r4
 824b410:	1800161e 	bne	r3,zero,824b46c <strcpy+0x68>
 824b414:	29c00017 	ldw	r7,0(r5)
 824b418:	02ffbff4 	movhi	r11,65279
 824b41c:	5affbfc4 	addi	r11,r11,-257
 824b420:	02a02074 	movhi	r10,32897
 824b424:	01c6303a 	nor	r3,zero,r7
 824b428:	3ac9883a 	add	r4,r7,r11
 824b42c:	52a02004 	addi	r10,r10,-32640
 824b430:	20c6703a 	and	r3,r4,r3
 824b434:	1a86703a 	and	r3,r3,r10
 824b438:	18000c1e 	bne	r3,zero,824b46c <strcpy+0x68>
 824b43c:	1011883a 	mov	r8,r2
 824b440:	41c00015 	stw	r7,0(r8)
 824b444:	29400104 	addi	r5,r5,4
 824b448:	29c00017 	ldw	r7,0(r5)
 824b44c:	41800104 	addi	r6,r8,4
 824b450:	3011883a 	mov	r8,r6
 824b454:	3ad3883a 	add	r9,r7,r11
 824b458:	01c6303a 	nor	r3,zero,r7
 824b45c:	48c6703a 	and	r3,r9,r3
 824b460:	1a86703a 	and	r3,r3,r10
 824b464:	183ff626 	beq	r3,zero,824b440 <strcpy+0x3c>
 824b468:	00000106 	br	824b470 <strcpy+0x6c>
 824b46c:	100d883a 	mov	r6,r2
 824b470:	28c00003 	ldbu	r3,0(r5)
 824b474:	31800044 	addi	r6,r6,1
 824b478:	29400044 	addi	r5,r5,1
 824b47c:	30ffffc5 	stb	r3,-1(r6)
 824b480:	18c03fcc 	andi	r3,r3,255
 824b484:	18c0201c 	xori	r3,r3,128
 824b488:	18ffe004 	addi	r3,r3,-128
 824b48c:	183ff81e 	bne	r3,zero,824b470 <strcpy+0x6c>
 824b490:	f800283a 	ret

0824b494 <strncmp>:
 824b494:	30003126 	beq	r6,zero,824b55c <strncmp+0xc8>
 824b498:	2144b03a 	or	r2,r4,r5
 824b49c:	108000cc 	andi	r2,r2,3
 824b4a0:	10001e1e 	bne	r2,zero,824b51c <strncmp+0x88>
 824b4a4:	024000c4 	movi	r9,3
 824b4a8:	49801c2e 	bgeu	r9,r6,824b51c <strncmp+0x88>
 824b4ac:	20800017 	ldw	r2,0(r4)
 824b4b0:	28c00017 	ldw	r3,0(r5)
 824b4b4:	10c0191e 	bne	r2,r3,824b51c <strncmp+0x88>
 824b4b8:	31bfff04 	addi	r6,r6,-4
 824b4bc:	30002726 	beq	r6,zero,824b55c <strncmp+0xc8>
 824b4c0:	02ffbff4 	movhi	r11,65279
 824b4c4:	5affbfc4 	addi	r11,r11,-257
 824b4c8:	0086303a 	nor	r3,zero,r2
 824b4cc:	02a02074 	movhi	r10,32897
 824b4d0:	12c5883a 	add	r2,r2,r11
 824b4d4:	52a02004 	addi	r10,r10,-32640
 824b4d8:	10c4703a 	and	r2,r2,r3
 824b4dc:	1284703a 	and	r2,r2,r10
 824b4e0:	10000b26 	beq	r2,zero,824b510 <strncmp+0x7c>
 824b4e4:	00001d06 	br	824b55c <strncmp+0xc8>
 824b4e8:	20c00017 	ldw	r3,0(r4)
 824b4ec:	29c00017 	ldw	r7,0(r5)
 824b4f0:	1ad1883a 	add	r8,r3,r11
 824b4f4:	00c4303a 	nor	r2,zero,r3
 824b4f8:	4084703a 	and	r2,r8,r2
 824b4fc:	1284703a 	and	r2,r2,r10
 824b500:	19c0061e 	bne	r3,r7,824b51c <strncmp+0x88>
 824b504:	31bfff04 	addi	r6,r6,-4
 824b508:	30001426 	beq	r6,zero,824b55c <strncmp+0xc8>
 824b50c:	1000131e 	bne	r2,zero,824b55c <strncmp+0xc8>
 824b510:	21000104 	addi	r4,r4,4
 824b514:	29400104 	addi	r5,r5,4
 824b518:	49bff336 	bltu	r9,r6,824b4e8 <strncmp+0x54>
 824b51c:	28800007 	ldb	r2,0(r5)
 824b520:	20c00007 	ldb	r3,0(r4)
 824b524:	31bfffc4 	addi	r6,r6,-1
 824b528:	10c0081e 	bne	r2,r3,824b54c <strncmp+0xb8>
 824b52c:	30000b26 	beq	r6,zero,824b55c <strncmp+0xc8>
 824b530:	10000a26 	beq	r2,zero,824b55c <strncmp+0xc8>
 824b534:	21000044 	addi	r4,r4,1
 824b538:	29400044 	addi	r5,r5,1
 824b53c:	20800007 	ldb	r2,0(r4)
 824b540:	28c00007 	ldb	r3,0(r5)
 824b544:	31bfffc4 	addi	r6,r6,-1
 824b548:	10fff826 	beq	r2,r3,824b52c <strncmp+0x98>
 824b54c:	20800003 	ldbu	r2,0(r4)
 824b550:	28c00003 	ldbu	r3,0(r5)
 824b554:	10c5c83a 	sub	r2,r2,r3
 824b558:	f800283a 	ret
 824b55c:	0005883a 	mov	r2,zero
 824b560:	f800283a 	ret

0824b564 <strncpy>:
 824b564:	2906b03a 	or	r3,r5,r4
 824b568:	18c000cc 	andi	r3,r3,3
 824b56c:	2005883a 	mov	r2,r4
 824b570:	18002c1e 	bne	r3,zero,824b624 <strncpy+0xc0>
 824b574:	010000c4 	movi	r4,3
 824b578:	21802a2e 	bgeu	r4,r6,824b624 <strncpy+0xc0>
 824b57c:	033fbff4 	movhi	r12,65279
 824b580:	02e02074 	movhi	r11,32897
 824b584:	633fbfc4 	addi	r12,r12,-257
 824b588:	5ae02004 	addi	r11,r11,-32640
 824b58c:	100f883a 	mov	r7,r2
 824b590:	2a000017 	ldw	r8,0(r5)
 824b594:	3815883a 	mov	r10,r7
 824b598:	4313883a 	add	r9,r8,r12
 824b59c:	0206303a 	nor	r3,zero,r8
 824b5a0:	48c6703a 	and	r3,r9,r3
 824b5a4:	1ac6703a 	and	r3,r3,r11
 824b5a8:	1800261e 	bne	r3,zero,824b644 <strncpy+0xe0>
 824b5ac:	39c00104 	addi	r7,r7,4
 824b5b0:	52000015 	stw	r8,0(r10)
 824b5b4:	31bfff04 	addi	r6,r6,-4
 824b5b8:	3811883a 	mov	r8,r7
 824b5bc:	29400104 	addi	r5,r5,4
 824b5c0:	21bff336 	bltu	r4,r6,824b590 <strncpy+0x2c>
 824b5c4:	30001e26 	beq	r6,zero,824b640 <strncpy+0xdc>
 824b5c8:	29c00003 	ldbu	r7,0(r5)
 824b5cc:	31bfffc4 	addi	r6,r6,-1
 824b5d0:	40c00044 	addi	r3,r8,1
 824b5d4:	41c00005 	stb	r7,0(r8)
 824b5d8:	39c03fcc 	andi	r7,r7,255
 824b5dc:	39c0201c 	xori	r7,r7,128
 824b5e0:	39ffe004 	addi	r7,r7,-128
 824b5e4:	29400044 	addi	r5,r5,1
 824b5e8:	38001026 	beq	r7,zero,824b62c <strncpy+0xc8>
 824b5ec:	1811883a 	mov	r8,r3
 824b5f0:	00000906 	br	824b618 <strncpy+0xb4>
 824b5f4:	29c00003 	ldbu	r7,0(r5)
 824b5f8:	31bfffc4 	addi	r6,r6,-1
 824b5fc:	29400044 	addi	r5,r5,1
 824b600:	41c00005 	stb	r7,0(r8)
 824b604:	39c03fcc 	andi	r7,r7,255
 824b608:	39c0201c 	xori	r7,r7,128
 824b60c:	39ffe004 	addi	r7,r7,-128
 824b610:	1811883a 	mov	r8,r3
 824b614:	38000526 	beq	r7,zero,824b62c <strncpy+0xc8>
 824b618:	18c00044 	addi	r3,r3,1
 824b61c:	303ff51e 	bne	r6,zero,824b5f4 <strncpy+0x90>
 824b620:	f800283a 	ret
 824b624:	1011883a 	mov	r8,r2
 824b628:	003fe606 	br	824b5c4 <strncpy+0x60>
 824b62c:	30000726 	beq	r6,zero,824b64c <strncpy+0xe8>
 824b630:	198d883a 	add	r6,r3,r6
 824b634:	18000005 	stb	zero,0(r3)
 824b638:	18c00044 	addi	r3,r3,1
 824b63c:	19bffd1e 	bne	r3,r6,824b634 <strncpy+0xd0>
 824b640:	f800283a 	ret
 824b644:	3811883a 	mov	r8,r7
 824b648:	003fdf06 	br	824b5c8 <strncpy+0x64>
 824b64c:	f800283a 	ret

0824b650 <_strtol_r>:
 824b650:	00820974 	movhi	r2,2085
 824b654:	defff404 	addi	sp,sp,-48
 824b658:	108eb604 	addi	r2,r2,15064
 824b65c:	dd400715 	stw	r21,28(sp)
 824b660:	15400017 	ldw	r21,0(r2)
 824b664:	dd800815 	stw	r22,32(sp)
 824b668:	dd000615 	stw	r20,24(sp)
 824b66c:	dcc00515 	stw	r19,20(sp)
 824b670:	d9000015 	stw	r4,0(sp)
 824b674:	dfc00b15 	stw	ra,44(sp)
 824b678:	df000a15 	stw	fp,40(sp)
 824b67c:	ddc00915 	stw	r23,36(sp)
 824b680:	dc800415 	stw	r18,16(sp)
 824b684:	dc400315 	stw	r17,12(sp)
 824b688:	dc000215 	stw	r16,8(sp)
 824b68c:	2829883a 	mov	r20,r5
 824b690:	3027883a 	mov	r19,r6
 824b694:	382d883a 	mov	r22,r7
 824b698:	2809883a 	mov	r4,r5
 824b69c:	24000003 	ldbu	r16,0(r4)
 824b6a0:	24400044 	addi	r17,r4,1
 824b6a4:	2007883a 	mov	r3,r4
 824b6a8:	ac05883a 	add	r2,r21,r16
 824b6ac:	10800043 	ldbu	r2,1(r2)
 824b6b0:	8809883a 	mov	r4,r17
 824b6b4:	1080020c 	andi	r2,r2,8
 824b6b8:	103ff81e 	bne	r2,zero,824b69c <_strtol_r+0x4c>
 824b6bc:	00800b44 	movi	r2,45
 824b6c0:	80805826 	beq	r16,r2,824b824 <_strtol_r+0x1d4>
 824b6c4:	00800ac4 	movi	r2,43
 824b6c8:	80805a26 	beq	r16,r2,824b834 <_strtol_r+0x1e4>
 824b6cc:	0039883a 	mov	fp,zero
 824b6d0:	b0004426 	beq	r22,zero,824b7e4 <_strtol_r+0x194>
 824b6d4:	00800404 	movi	r2,16
 824b6d8:	b0806026 	beq	r22,r2,824b85c <_strtol_r+0x20c>
 824b6dc:	b02f883a 	mov	r23,r22
 824b6e0:	00a00034 	movhi	r2,32768
 824b6e4:	e025003a 	cmpeq	r18,fp,zero
 824b6e8:	14a5c83a 	sub	r18,r2,r18
 824b6ec:	b80b883a 	mov	r5,r23
 824b6f0:	9009883a 	mov	r4,r18
 824b6f4:	82029c00 	call	82029c0 <__umodsi3>
 824b6f8:	b80b883a 	mov	r5,r23
 824b6fc:	9009883a 	mov	r4,r18
 824b700:	d8800115 	stw	r2,4(sp)
 824b704:	820295c0 	call	820295c <__udivsi3>
 824b708:	ac07883a 	add	r3,r21,r16
 824b70c:	18c00043 	ldbu	r3,1(r3)
 824b710:	880b883a 	mov	r5,r17
 824b714:	000d883a 	mov	r6,zero
 824b718:	1a00010c 	andi	r8,r3,4
 824b71c:	0009883a 	mov	r4,zero
 824b720:	02800044 	movi	r10,1
 824b724:	027fffc4 	movi	r9,-1
 824b728:	d9c00117 	ldw	r7,4(sp)
 824b72c:	40000e26 	beq	r8,zero,824b768 <_strtol_r+0x118>
 824b730:	843ff404 	addi	r16,r16,-48
 824b734:	8580120e 	bge	r16,r22,824b780 <_strtol_r+0x130>
 824b738:	32400526 	beq	r6,r9,824b750 <_strtol_r+0x100>
 824b73c:	11002536 	bltu	r2,r4,824b7d4 <_strtol_r+0x184>
 824b740:	20802326 	beq	r4,r2,824b7d0 <_strtol_r+0x180>
 824b744:	25c9383a 	mul	r4,r4,r23
 824b748:	01800044 	movi	r6,1
 824b74c:	8109883a 	add	r4,r16,r4
 824b750:	2c000003 	ldbu	r16,0(r5)
 824b754:	29400044 	addi	r5,r5,1
 824b758:	ac07883a 	add	r3,r21,r16
 824b75c:	18c00043 	ldbu	r3,1(r3)
 824b760:	1a00010c 	andi	r8,r3,4
 824b764:	403ff21e 	bne	r8,zero,824b730 <_strtol_r+0xe0>
 824b768:	18c000cc 	andi	r3,r3,3
 824b76c:	18000426 	beq	r3,zero,824b780 <_strtol_r+0x130>
 824b770:	1a801a26 	beq	r3,r10,824b7dc <_strtol_r+0x18c>
 824b774:	00c015c4 	movi	r3,87
 824b778:	80e1c83a 	sub	r16,r16,r3
 824b77c:	85bfee16 	blt	r16,r22,824b738 <_strtol_r+0xe8>
 824b780:	00bfffc4 	movi	r2,-1
 824b784:	30801e26 	beq	r6,r2,824b800 <_strtol_r+0x1b0>
 824b788:	e0001b1e 	bne	fp,zero,824b7f8 <_strtol_r+0x1a8>
 824b78c:	2005883a 	mov	r2,r4
 824b790:	98000326 	beq	r19,zero,824b7a0 <_strtol_r+0x150>
 824b794:	3000211e 	bne	r6,zero,824b81c <_strtol_r+0x1cc>
 824b798:	a00b883a 	mov	r5,r20
 824b79c:	99400015 	stw	r5,0(r19)
 824b7a0:	dfc00b17 	ldw	ra,44(sp)
 824b7a4:	df000a17 	ldw	fp,40(sp)
 824b7a8:	ddc00917 	ldw	r23,36(sp)
 824b7ac:	dd800817 	ldw	r22,32(sp)
 824b7b0:	dd400717 	ldw	r21,28(sp)
 824b7b4:	dd000617 	ldw	r20,24(sp)
 824b7b8:	dcc00517 	ldw	r19,20(sp)
 824b7bc:	dc800417 	ldw	r18,16(sp)
 824b7c0:	dc400317 	ldw	r17,12(sp)
 824b7c4:	dc000217 	ldw	r16,8(sp)
 824b7c8:	dec00c04 	addi	sp,sp,48
 824b7cc:	f800283a 	ret
 824b7d0:	3c3fdc0e 	bge	r7,r16,824b744 <_strtol_r+0xf4>
 824b7d4:	01bfffc4 	movi	r6,-1
 824b7d8:	003fdd06 	br	824b750 <_strtol_r+0x100>
 824b7dc:	00c00dc4 	movi	r3,55
 824b7e0:	003fe506 	br	824b778 <_strtol_r+0x128>
 824b7e4:	00800c04 	movi	r2,48
 824b7e8:	80801626 	beq	r16,r2,824b844 <_strtol_r+0x1f4>
 824b7ec:	05800284 	movi	r22,10
 824b7f0:	b02f883a 	mov	r23,r22
 824b7f4:	003fba06 	br	824b6e0 <_strtol_r+0x90>
 824b7f8:	0109c83a 	sub	r4,zero,r4
 824b7fc:	003fe306 	br	824b78c <_strtol_r+0x13c>
 824b800:	d9000017 	ldw	r4,0(sp)
 824b804:	00c00884 	movi	r3,34
 824b808:	e005003a 	cmpeq	r2,fp,zero
 824b80c:	20c00015 	stw	r3,0(r4)
 824b810:	00e00034 	movhi	r3,32768
 824b814:	1885c83a 	sub	r2,r3,r2
 824b818:	983fe126 	beq	r19,zero,824b7a0 <_strtol_r+0x150>
 824b81c:	297fffc4 	addi	r5,r5,-1
 824b820:	003fde06 	br	824b79c <_strtol_r+0x14c>
 824b824:	1c400084 	addi	r17,r3,2
 824b828:	1c000043 	ldbu	r16,1(r3)
 824b82c:	07000044 	movi	fp,1
 824b830:	003fa706 	br	824b6d0 <_strtol_r+0x80>
 824b834:	1c400084 	addi	r17,r3,2
 824b838:	1c000043 	ldbu	r16,1(r3)
 824b83c:	0039883a 	mov	fp,zero
 824b840:	003fa306 	br	824b6d0 <_strtol_r+0x80>
 824b844:	88800003 	ldbu	r2,0(r17)
 824b848:	00c01604 	movi	r3,88
 824b84c:	108037cc 	andi	r2,r2,223
 824b850:	10c00826 	beq	r2,r3,824b874 <_strtol_r+0x224>
 824b854:	05800204 	movi	r22,8
 824b858:	003fa006 	br	824b6dc <_strtol_r+0x8c>
 824b85c:	00800c04 	movi	r2,48
 824b860:	80bf9e1e 	bne	r16,r2,824b6dc <_strtol_r+0x8c>
 824b864:	88800003 	ldbu	r2,0(r17)
 824b868:	00c01604 	movi	r3,88
 824b86c:	108037cc 	andi	r2,r2,223
 824b870:	10ff9a1e 	bne	r2,r3,824b6dc <_strtol_r+0x8c>
 824b874:	05c00404 	movi	r23,16
 824b878:	8c000043 	ldbu	r16,1(r17)
 824b87c:	b82d883a 	mov	r22,r23
 824b880:	8c400084 	addi	r17,r17,2
 824b884:	003f9606 	br	824b6e0 <_strtol_r+0x90>

0824b888 <strtol>:
 824b888:	00820974 	movhi	r2,2085
 824b88c:	108eb804 	addi	r2,r2,15072
 824b890:	300f883a 	mov	r7,r6
 824b894:	280d883a 	mov	r6,r5
 824b898:	200b883a 	mov	r5,r4
 824b89c:	11000017 	ldw	r4,0(r2)
 824b8a0:	824b6501 	jmpi	824b650 <_strtol_r>

0824b8a4 <vprintf>:
 824b8a4:	00820974 	movhi	r2,2085
 824b8a8:	108eb804 	addi	r2,r2,15072
 824b8ac:	200d883a 	mov	r6,r4
 824b8b0:	11000017 	ldw	r4,0(r2)
 824b8b4:	280f883a 	mov	r7,r5
 824b8b8:	21400217 	ldw	r5,8(r4)
 824b8bc:	824bbd41 	jmpi	824bbd4 <_vfprintf_r>

0824b8c0 <_vprintf_r>:
 824b8c0:	300f883a 	mov	r7,r6
 824b8c4:	280d883a 	mov	r6,r5
 824b8c8:	21400217 	ldw	r5,8(r4)
 824b8cc:	824bbd41 	jmpi	824bbd4 <_vfprintf_r>

0824b8d0 <_vsprintf_r>:
 824b8d0:	00a00034 	movhi	r2,32768
 824b8d4:	deffe504 	addi	sp,sp,-108
 824b8d8:	10bfffc4 	addi	r2,r2,-1
 824b8dc:	2807883a 	mov	r3,r5
 824b8e0:	02008204 	movi	r8,520
 824b8e4:	d8800215 	stw	r2,8(sp)
 824b8e8:	d8800515 	stw	r2,20(sp)
 824b8ec:	d80b883a 	mov	r5,sp
 824b8f0:	00bfffc4 	movi	r2,-1
 824b8f4:	d8c00015 	stw	r3,0(sp)
 824b8f8:	d8c00415 	stw	r3,16(sp)
 824b8fc:	dfc01a15 	stw	ra,104(sp)
 824b900:	da00030d 	sth	r8,12(sp)
 824b904:	d880038d 	sth	r2,14(sp)
 824b908:	82045a80 	call	82045a8 <___svfprintf_internal_r>
 824b90c:	d8c00017 	ldw	r3,0(sp)
 824b910:	18000005 	stb	zero,0(r3)
 824b914:	dfc01a17 	ldw	ra,104(sp)
 824b918:	dec01b04 	addi	sp,sp,108
 824b91c:	f800283a 	ret

0824b920 <vsprintf>:
 824b920:	00820974 	movhi	r2,2085
 824b924:	108eb804 	addi	r2,r2,15072
 824b928:	300f883a 	mov	r7,r6
 824b92c:	280d883a 	mov	r6,r5
 824b930:	200b883a 	mov	r5,r4
 824b934:	11000017 	ldw	r4,0(r2)
 824b938:	824b8d01 	jmpi	824b8d0 <_vsprintf_r>

0824b93c <__register_exitproc>:
 824b93c:	defffa04 	addi	sp,sp,-24
 824b940:	dc000315 	stw	r16,12(sp)
 824b944:	04020974 	movhi	r16,2085
 824b948:	840eb704 	addi	r16,r16,15068
 824b94c:	80c00017 	ldw	r3,0(r16)
 824b950:	dc400415 	stw	r17,16(sp)
 824b954:	dfc00515 	stw	ra,20(sp)
 824b958:	18805217 	ldw	r2,328(r3)
 824b95c:	2023883a 	mov	r17,r4
 824b960:	10003726 	beq	r2,zero,824ba40 <__register_exitproc+0x104>
 824b964:	10c00117 	ldw	r3,4(r2)
 824b968:	010007c4 	movi	r4,31
 824b96c:	20c00e16 	blt	r4,r3,824b9a8 <__register_exitproc+0x6c>
 824b970:	1a000044 	addi	r8,r3,1
 824b974:	8800221e 	bne	r17,zero,824ba00 <__register_exitproc+0xc4>
 824b978:	18c00084 	addi	r3,r3,2
 824b97c:	18c7883a 	add	r3,r3,r3
 824b980:	18c7883a 	add	r3,r3,r3
 824b984:	12000115 	stw	r8,4(r2)
 824b988:	10c7883a 	add	r3,r2,r3
 824b98c:	19400015 	stw	r5,0(r3)
 824b990:	0005883a 	mov	r2,zero
 824b994:	dfc00517 	ldw	ra,20(sp)
 824b998:	dc400417 	ldw	r17,16(sp)
 824b99c:	dc000317 	ldw	r16,12(sp)
 824b9a0:	dec00604 	addi	sp,sp,24
 824b9a4:	f800283a 	ret
 824b9a8:	00820974 	movhi	r2,2085
 824b9ac:	10acf704 	addi	r2,r2,-19492
 824b9b0:	10002626 	beq	r2,zero,824ba4c <__register_exitproc+0x110>
 824b9b4:	01006404 	movi	r4,400
 824b9b8:	d9400015 	stw	r5,0(sp)
 824b9bc:	d9800115 	stw	r6,4(sp)
 824b9c0:	d9c00215 	stw	r7,8(sp)
 824b9c4:	824b3dc0 	call	824b3dc <malloc>
 824b9c8:	d9400017 	ldw	r5,0(sp)
 824b9cc:	d9800117 	ldw	r6,4(sp)
 824b9d0:	d9c00217 	ldw	r7,8(sp)
 824b9d4:	10001d26 	beq	r2,zero,824ba4c <__register_exitproc+0x110>
 824b9d8:	81000017 	ldw	r4,0(r16)
 824b9dc:	10000115 	stw	zero,4(r2)
 824b9e0:	02000044 	movi	r8,1
 824b9e4:	22405217 	ldw	r9,328(r4)
 824b9e8:	0007883a 	mov	r3,zero
 824b9ec:	12400015 	stw	r9,0(r2)
 824b9f0:	20805215 	stw	r2,328(r4)
 824b9f4:	10006215 	stw	zero,392(r2)
 824b9f8:	10006315 	stw	zero,396(r2)
 824b9fc:	883fde26 	beq	r17,zero,824b978 <__register_exitproc+0x3c>
 824ba00:	18c9883a 	add	r4,r3,r3
 824ba04:	2109883a 	add	r4,r4,r4
 824ba08:	1109883a 	add	r4,r2,r4
 824ba0c:	21802215 	stw	r6,136(r4)
 824ba10:	01800044 	movi	r6,1
 824ba14:	12406217 	ldw	r9,392(r2)
 824ba18:	30cc983a 	sll	r6,r6,r3
 824ba1c:	4992b03a 	or	r9,r9,r6
 824ba20:	12406215 	stw	r9,392(r2)
 824ba24:	21c04215 	stw	r7,264(r4)
 824ba28:	01000084 	movi	r4,2
 824ba2c:	893fd21e 	bne	r17,r4,824b978 <__register_exitproc+0x3c>
 824ba30:	11006317 	ldw	r4,396(r2)
 824ba34:	218cb03a 	or	r6,r4,r6
 824ba38:	11806315 	stw	r6,396(r2)
 824ba3c:	003fce06 	br	824b978 <__register_exitproc+0x3c>
 824ba40:	18805304 	addi	r2,r3,332
 824ba44:	18805215 	stw	r2,328(r3)
 824ba48:	003fc606 	br	824b964 <__register_exitproc+0x28>
 824ba4c:	00bfffc4 	movi	r2,-1
 824ba50:	003fd006 	br	824b994 <__register_exitproc+0x58>

0824ba54 <__call_exitprocs>:
 824ba54:	defff504 	addi	sp,sp,-44
 824ba58:	df000915 	stw	fp,36(sp)
 824ba5c:	dd400615 	stw	r21,24(sp)
 824ba60:	dc800315 	stw	r18,12(sp)
 824ba64:	dfc00a15 	stw	ra,40(sp)
 824ba68:	ddc00815 	stw	r23,32(sp)
 824ba6c:	dd800715 	stw	r22,28(sp)
 824ba70:	dd000515 	stw	r20,20(sp)
 824ba74:	dcc00415 	stw	r19,16(sp)
 824ba78:	dc400215 	stw	r17,8(sp)
 824ba7c:	dc000115 	stw	r16,4(sp)
 824ba80:	d9000015 	stw	r4,0(sp)
 824ba84:	2839883a 	mov	fp,r5
 824ba88:	04800044 	movi	r18,1
 824ba8c:	057fffc4 	movi	r21,-1
 824ba90:	00820974 	movhi	r2,2085
 824ba94:	108eb704 	addi	r2,r2,15068
 824ba98:	12000017 	ldw	r8,0(r2)
 824ba9c:	45005217 	ldw	r20,328(r8)
 824baa0:	44c05204 	addi	r19,r8,328
 824baa4:	a0001c26 	beq	r20,zero,824bb18 <__call_exitprocs+0xc4>
 824baa8:	a0800117 	ldw	r2,4(r20)
 824baac:	15ffffc4 	addi	r23,r2,-1
 824bab0:	b8000d16 	blt	r23,zero,824bae8 <__call_exitprocs+0x94>
 824bab4:	14000044 	addi	r16,r2,1
 824bab8:	8421883a 	add	r16,r16,r16
 824babc:	8421883a 	add	r16,r16,r16
 824bac0:	84402004 	addi	r17,r16,128
 824bac4:	a463883a 	add	r17,r20,r17
 824bac8:	a421883a 	add	r16,r20,r16
 824bacc:	e0001e26 	beq	fp,zero,824bb48 <__call_exitprocs+0xf4>
 824bad0:	80804017 	ldw	r2,256(r16)
 824bad4:	e0801c26 	beq	fp,r2,824bb48 <__call_exitprocs+0xf4>
 824bad8:	bdffffc4 	addi	r23,r23,-1
 824badc:	843fff04 	addi	r16,r16,-4
 824bae0:	8c7fff04 	addi	r17,r17,-4
 824bae4:	bd7ff91e 	bne	r23,r21,824bacc <__call_exitprocs+0x78>
 824bae8:	00820974 	movhi	r2,2085
 824baec:	10acfc04 	addi	r2,r2,-19472
 824baf0:	10000926 	beq	r2,zero,824bb18 <__call_exitprocs+0xc4>
 824baf4:	a0800117 	ldw	r2,4(r20)
 824baf8:	1000301e 	bne	r2,zero,824bbbc <__call_exitprocs+0x168>
 824bafc:	a0800017 	ldw	r2,0(r20)
 824bb00:	10003226 	beq	r2,zero,824bbcc <__call_exitprocs+0x178>
 824bb04:	a009883a 	mov	r4,r20
 824bb08:	98800015 	stw	r2,0(r19)
 824bb0c:	824b3f00 	call	824b3f0 <free>
 824bb10:	9d000017 	ldw	r20,0(r19)
 824bb14:	a03fe41e 	bne	r20,zero,824baa8 <__call_exitprocs+0x54>
 824bb18:	dfc00a17 	ldw	ra,40(sp)
 824bb1c:	df000917 	ldw	fp,36(sp)
 824bb20:	ddc00817 	ldw	r23,32(sp)
 824bb24:	dd800717 	ldw	r22,28(sp)
 824bb28:	dd400617 	ldw	r21,24(sp)
 824bb2c:	dd000517 	ldw	r20,20(sp)
 824bb30:	dcc00417 	ldw	r19,16(sp)
 824bb34:	dc800317 	ldw	r18,12(sp)
 824bb38:	dc400217 	ldw	r17,8(sp)
 824bb3c:	dc000117 	ldw	r16,4(sp)
 824bb40:	dec00b04 	addi	sp,sp,44
 824bb44:	f800283a 	ret
 824bb48:	a0800117 	ldw	r2,4(r20)
 824bb4c:	80c00017 	ldw	r3,0(r16)
 824bb50:	10bfffc4 	addi	r2,r2,-1
 824bb54:	15c01426 	beq	r2,r23,824bba8 <__call_exitprocs+0x154>
 824bb58:	80000015 	stw	zero,0(r16)
 824bb5c:	183fde26 	beq	r3,zero,824bad8 <__call_exitprocs+0x84>
 824bb60:	95c8983a 	sll	r4,r18,r23
 824bb64:	a0806217 	ldw	r2,392(r20)
 824bb68:	a5800117 	ldw	r22,4(r20)
 824bb6c:	2084703a 	and	r2,r4,r2
 824bb70:	10000b26 	beq	r2,zero,824bba0 <__call_exitprocs+0x14c>
 824bb74:	a0806317 	ldw	r2,396(r20)
 824bb78:	2088703a 	and	r4,r4,r2
 824bb7c:	20000c1e 	bne	r4,zero,824bbb0 <__call_exitprocs+0x15c>
 824bb80:	89400017 	ldw	r5,0(r17)
 824bb84:	d9000017 	ldw	r4,0(sp)
 824bb88:	183ee83a 	callr	r3
 824bb8c:	a0800117 	ldw	r2,4(r20)
 824bb90:	15bfbf1e 	bne	r2,r22,824ba90 <__call_exitprocs+0x3c>
 824bb94:	98800017 	ldw	r2,0(r19)
 824bb98:	153fcf26 	beq	r2,r20,824bad8 <__call_exitprocs+0x84>
 824bb9c:	003fbc06 	br	824ba90 <__call_exitprocs+0x3c>
 824bba0:	183ee83a 	callr	r3
 824bba4:	003ff906 	br	824bb8c <__call_exitprocs+0x138>
 824bba8:	a5c00115 	stw	r23,4(r20)
 824bbac:	003feb06 	br	824bb5c <__call_exitprocs+0x108>
 824bbb0:	89000017 	ldw	r4,0(r17)
 824bbb4:	183ee83a 	callr	r3
 824bbb8:	003ff406 	br	824bb8c <__call_exitprocs+0x138>
 824bbbc:	a0800017 	ldw	r2,0(r20)
 824bbc0:	a027883a 	mov	r19,r20
 824bbc4:	1029883a 	mov	r20,r2
 824bbc8:	003fb606 	br	824baa4 <__call_exitprocs+0x50>
 824bbcc:	0005883a 	mov	r2,zero
 824bbd0:	003ffb06 	br	824bbc0 <__call_exitprocs+0x16c>

0824bbd4 <_vfprintf_r>:
 824bbd4:	deffff04 	addi	sp,sp,-4
 824bbd8:	dfc00015 	stw	ra,0(sp)
 824bbdc:	82067880 	call	8206788 <___vfprintf_internal_r>
 824bbe0:	dfc00017 	ldw	ra,0(sp)
 824bbe4:	dec00104 	addi	sp,sp,4
 824bbe8:	f800283a 	ret

0824bbec <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 824bbec:	defffd04 	addi	sp,sp,-12
 824bbf0:	df000215 	stw	fp,8(sp)
 824bbf4:	df000204 	addi	fp,sp,8
 824bbf8:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 824bbfc:	d0206b45 	stb	zero,-32339(gp)
 824bc00:	e0bfff17 	ldw	r2,-4(fp)
 824bc04:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 824bc08:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 824bc0c:	10000226 	beq	r2,zero,824bc18 <_exit+0x2c>
    ALT_SIM_FAIL();
 824bc10:	002af070 	cmpltui	zero,zero,43969
 824bc14:	00000106 	br	824bc1c <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 824bc18:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 824bc1c:	003fff06 	br	824bc1c <_exit+0x30>
